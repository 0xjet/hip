{
    "id": "369d803f-bf8c-4216-b282-09550a898e9b",
    "created_at": "2023-01-12T15:07:09.628089Z",
    "updated_at": "2025-03-27T02:06:00.452358Z",
    "deleted_at": null,
    "sha1_hash": "2cf5e88732d004bdc398144b702d370c4b1d658b",
    "title": "2020-06-22 - Unpacking Visual Basic Packers – IcedID",
    "authors": "",
    "file_creation_date": "2022-05-27T22:01:01Z",
    "file_modification_date": "2022-05-27T22:01:01Z",
    "file_size": 1453256,
    "plain_text": "# Unpacking Visual Basic Packers – IcedID\n\n**[zero2auto.com/2020/06/22/unpacking-visual-basic-packers/](https://zero2auto.com/2020/06/22/unpacking-visual-basic-packers/)**\n\n0verfl0wz2a June 22, 2020\n\nDespite the fact that VisualBasic is an age-old programming language, it is still being used to\ndevelop malicious software – specifically packers – to this day. As a result, you will often\nencounter VisualBasic based packers used in a lot of “script-kiddie” malware, such as\nkeyloggers and remote access tools being sold on forums, and more recently, IcedID! For\nthose of you not aware, IcedID (AKA BokBot) is a banking trojan that has been around for a\ncouple years now, which was quite infamous in the malware analysis community due to it’s\nnovelty process injection technique of API hooking certain calls to execute code inside of a\nspawned svchost.exe process. If you haven’t heard of this injection technique before, don’t\nworry! We will be covering it in Section 3 of the Zero2Automated course, along with other\ninjection techniques – but, if you would like to check out a few articles about IcedID to get\nsome context before reading this one, feel free to! Anyway, let’s jump straight into the\nanalysis!\n\n**Indicator Of Compromise:**\n\nMD5 Hash of Packed Sample: 462018be60a69aa89b539c239761248c\n\n**Initial Analysis:**\n\nSo, while I do know that this sample is packed as I have looked at it before, let’s approach it\nas if we had no idea what it was. First things first, we want to open it up in a PE analysis tool,\nwhich in this case I will be using CFF Explorer. One of the good things about CFF Explorer\nis the fact that as soon as we open up the malicious executable in it, we can see the File\n**Info, which is Microsoft Visual Basic 5/6, so automatically we know that VB was used to**\ncreate the file.\n\n\n-----\n\nAs we don’t want to spend too long analyzing the executable, let’s go ahead and open it up\nin x32dbg to begin with. The reason we are opening it up in a debugger to begin with rather\nthan IDA Pro is due to the fact that VB is more commonly used to create malware packers\nthan malware itself, so we are saving ourselves some time here. What we see in the\ndebugger can tell us if the executable is packed or not, so let’s check that out first. As you\ncan see in the image below, the entry point is a lot different to the entry points of most\nexecutables, as all there is is a push instruction and then a call to ThunRTMain().\n\n\n-----\n\nWhen we view the pushed address in the dump, you ll notice a few strings such as VB5! and\n_Custom Tabs. This is actually a structure used to tell ThunRTMain() about the program,_\n[including where the entry point of the user code actually is. Here you can see a table](https://www.vb-decompiler.org/pcode_decompiling.htm)\ncontaining information about the different values inside the structure, and the position of\nthem. The value we want to find is referred to as aSubMain, as that is the address called by\n**ThunRTMain() once everything has been initialized. The area highlighted in red in the**\nmemory dump should contain the address of aSubMain, however it is completely empty!\nThis indicates that there is some obfuscation going on, or the authors have altered the\ncompilation routine. As a result of this, we will have to rely on setting some breakpoints\ninstead to unpack the sample, rather than statically analyze it.\n\nWhen unpacking VB based packers, I like to put a breakpoint on 4 main API calls:\n\n**VirtualAlloc**\n**VirtualProtect**\n**IsDebuggerPresent**\n**CreateProcessInternalW**\n\nThis allows us to; view any allocated regions of memory that may have an executable written\ninto it, prevent any processes from being created, as well as stop the most common antidebug method from executing, which is quite common in these VB packers. The reason we\nwant to break on it is so we can alter the value to “hide” the debugger from the process. If a\ndebugger is detected by the malware, it might not halt execution as many of you may have\n\n\n-----\n\nthought – it is quite common for the program to continue executing, however it will take a\nvery different path that does nothing. This can lead you to analyze a program for hours,\ntrying to figure out why nothing malicious is actually happening.\n\nSo, putting a breakpoint on these calls and running the debugger, you can see we hit\n**IsDebuggerPresent immediately. In order to alter the return value of this call, we want to**\n_Execute To Return and then alter the value in EAX from 1 to 0. Then go ahead and execute_\nthe debugger again, and wait for the next breakpoint to be hit!\n\nThe next breakpoint to be hit is VirtualAlloc, so let’s execute to return again and follow the\nvalue stored in EAX in the dump – buuut on the first run you’ll notice that there is no option to\nfollow the value in the dump. This is also quite common for some samples – what happens is\nit first calls VirtualAlloc in order to reserve the memory location, and then it will allocate it on\nthe second call. Therefore, go ahead and execute the debugger again and you’ll see it\nbreaks on VirtualAlloc once more – this time when you execute to return, you’ll be able to\nfollow the value in the dump!\n\n\n-----\n\nAfter that last allocate, running the debugger once again, it’ll break on VirtualAlloc. At this\npoint, you’ll notice the previous memory region has been filled in, however it doesn’t seem to\nbe very useful and it definitely isn’t an executable, so let’s continue running the debugger\nand keep an eye on any allocated regions of memory, until something interesting happens!\n\n\n-----\n\nFinally, after ignoring several more useless VirtualAlloc and VirtualProtect calls, we finally\nfind a new region being allocated at 0x00770000! Now let’s follow this in the dump and run\nthe debugger once more to see if anything interesting is copied over.\n\n\n-----\n\nThe next breakpoint that is hit is a call to VirtualProtect, which is changing the protection of\nthe region of memory just allocated – which has also been filled in with what seems to be\nshellcode. If you watched the initial video in the section regarding packers, you’ll remember\nthat packers often use shellcode to decrypt the executable and overwrite the packer (in\nmemory) with the decrypted executable, so that could be what is happening here. Let’s go\nahead and run the debugger again, until we see an executable being written to an allocated\nregion of memory!\n\n\n-----\n\nSure enough, after a few more triggered breakpoints, we reach a call to VirtualAlloc that\nallocates a memory region, which shortly after has an executable written to it! This isn’t the\nwhole executable however, if you scroll down you’ll notice only the header has been written,\nso we can’t dump it out just yet. The reason why it hasn’t been fully written into memory yet\nis due to the fact that the executable must be mapped into memory in order to execute, so\nthe packer will go ahead and allocate memory at 0x024F1000 and write the .text section to\nit, then allocate memory at 0x024F2000 and write the .rdata section to it, and so on.\nTherefore, let’s go ahead and run the debugger until we hit a call to VirtualProtect, as this is\nwhen the packer begins to change the protection of the different regions of memory in the\nexecutable – such as changing the protection on the .text section to RWX (read-writeexecute).\n\n\n-----\n\nOnce we’ve hit VirtualProtect, we can go ahead and dump out the executable from memory,\nas this is the fully unpacked IcedID loader! One of my favourite tools to do this is Process\n**Hacker 2 but you can use whatever tool you like or even use the inbuilt x32dbg memory**\n\n\n-----\n\ndump functionality.\n\nWith the executable dumped from memory, we now need to unmap it. As I said before, the\npacker maps it into memory, and so if we were to open the program up in IDA Pro, it would\ntry and resolve values as if the executable was unmapped – so instead of finding the .text\nsection at 0x024F1000, it would look at 0x00040400 (as an example). Therefore, we need to\nunmap it. The best tool to do this is PE-Bear, and upon opening the program up in it, we\nwant to go to the Section Hdrs tab, and change the Raw Addr. tab to match the values\nshown in the Virtual Addr. tab, and then change the Raw Size values so they match up as\nwell (this is the difference between the sections in terms of size) – so let’s go ahead and\nchange that!\n\n\n-----\n\nIf everything has gone as planned, you’ll now have something that looks like the image\nbelow! If you check the Imports tab, you’ll notice that they have also been filled in, so now we\ncan view all the imports that the malware uses at some point in it’s execution! Go ahead and\nsave the fixed dump by right clicking the filename in the top left and choosing to Save\n_Executable As…and congratulations! You have successfully unpacked this VB packed_\nsample of an IcedID Loader!\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-22 - Unpacking Visual Basic Packers – IcedID.pdf"
    ],
    "report_names": [
        "2020-06-22 - Unpacking Visual Basic Packers – IcedID.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536029,
    "ts_updated_at": 1743041160,
    "ts_creation_date": 1653688861,
    "ts_modification_date": 1653688861,
    "files": {
        "pdf": "https://archive.orkl.eu/2cf5e88732d004bdc398144b702d370c4b1d658b.pdf",
        "text": "https://archive.orkl.eu/2cf5e88732d004bdc398144b702d370c4b1d658b.txt",
        "img": "https://archive.orkl.eu/2cf5e88732d004bdc398144b702d370c4b1d658b.jpg"
    }
}