{
    "id": "2e07e626-23e0-462b-8e1d-1a83037e9509",
    "created_at": "2023-01-12T14:59:54.999615Z",
    "updated_at": "2025-03-27T02:08:40.628368Z",
    "deleted_at": null,
    "sha1_hash": "ce12fabac6ef7d4faad496a5ccaa3bf6211a7ebb",
    "title": "2020-04-24 - LockBit ransomware borrows tricks to keep up with REvil and Maze",
    "authors": "",
    "file_creation_date": "2022-05-29T10:50:01Z",
    "file_modification_date": "2022-05-29T10:50:01Z",
    "file_size": 4064334,
    "plain_text": "# LockBit ransomware borrows tricks to keep up with REvil and Maze\n\n**[news.sophos.com/en-us/2020/04/24/lockbit-ransomware-borrows-tricks-to-keep-up-with-revil-and-maze/](https://news.sophos.com/en-us/2020/04/24/lockbit-ransomware-borrows-tricks-to-keep-up-with-revil-and-maze/)**\n\nAlbert Zsigovits April 24, 2020\n\nRansomware operators are always on the lookout for a way to take their ransomware to the\nnext level. That’s particularly true of the gang behind LockBit. Following the lead of the Maze\nand REvil ransomware crime rings, LockBit’s operators are now threatening to leak the data\nof their victims in order to extort payment. And the ransomware itself also includes a number\nof technical improvements that show LockBit’s developers are climbing the ransomware\nlearning curve—and have developed an interesting technique to circumvent Windows’ User\nAccount Control (UAC).\n\nBecause of recent dynamics in the ransomware world, we suspect that this privilegeescalation technique will pop up in other ransomware families in the future. We’ve seen a\nsurge in “imposter” ransomware that are essentially rebranded variants of already-existing\nransomware. Not a single day goes by where a new brand of ransomware does not come\nout. It has become surprisingly easy to clone ransomware and release it, with small\nmodifications, under a different umbrella.\n\n### The Ransomware Learning Curve\n\n\n-----\n\nBefore we jump into the synopsis of LockBit, let s take a moment to look at how ransomware\nis developed, in general. Many families follow a common timeline when it comes to the\ntechniques and procedures ransomware developers implement at each stage. This appears\nto stem from the learning curve involved in creating ransomware, and the iteration of the\nmalware as the developer builds his or her related knowledge of the malware craft.\n\nEach ransomware seems to have an “infancy phase,” where the developer implements TTPs\nhastily just so the “product” can come out and start gaining its reputation. In this phase, the\nsimplest ideas are implemented first, strings are usually plain text, the encryption is\nimplemented in a way that only a single-thread is used, and LanguageID checks are in place\n[to avoid encrypting computers in CIS countries. and avoid attracting unwanted attention from](https://worldpopulationreview.com/countries/cis-countries/)\nCIS law enforcement agencies.\n\nAfter about 2 months into the ransomware operation, the developer starts implementing\nmore sophisticated elements. They may introduce multi-threading, establish a presence in\nunderground forums, obfuscate or encrypt strings in the binary, and there is usually a skip\nlist/kill list for services and processes.\n\nAround 4 months into the ransomware’s life, we start seeing things get more serious. The\nbusiness model may now switch to Ransomware as a Service (RaaS), putting an Affiliate\nprogram in place. Oftentimes, binaries are cryptographically signed with valid, stolen\ncertificates. There is a possibility that the ransomware developer starts implementing UAC\nbypasses at this stage. This appears to be the stage the LockBit group is entering.\n\n\n-----\n\n### Advertising the goods\n\nAs with most ransomware, LockBit maintains a forum topic on a well-known underground\nweb board to promote their product. Ransomware operators maintain a forum presence\nmainly to advertise the ransomware, discuss customer inquiries and bugs, and to advertise\nan affiliate program through which other criminals can lease components of the ransomware\ncode to build their own ransomware and infrastructure.\n\nIn January, LockBit’s operators created a new thread in the web board’s marketplace forum,\nannouncing the “LockBit Cryptolocker Affiliate Program” and advertising the capabilities of\ntheir malware. The post claims that the new version had been in development since\nSeptember of 2019, and emphasizes the performance of the encryptor and its lower use of\nsystem resources to prevent its detection.\n\n\n-----\n\nA\n\nforum post announcing LockBit’s affiliate program.\nLockBit’s post indicates that “we do not work in the CIS,” meaning that the ransomware will\nnot target victims in Russia and other Commonwealth of Independent States countries. This\ncomes as no surprise—as we have seen previously, CIS authorities don’t bother\ninvestigating these groups unless they are operating against targets in their area of\njurisdiction.\n\nThat does not mean that the LockBit group won’t do business with other CIS-based gangs. In\nfact, they won’t work with English-speaking developers without a Russian-speaking\n“guarantor” to vouch for them.\n\n### Escalating the extortion\n\nIn this most recent evolution of LockBit, the malware now drops a ransom note that threatens\nto leak data the malware has stolen from victims: “!!! We also download huge amount of your\n_private data, including finance information, clients personal info, network diagrams,_\n_passwords and so on. Don’t forget about GDPR.”_\n\nLockBit ransom note\n\n\n-----\n\nIf the threat were to be carried out, it might result in real-world sanctions against the\nransomware victims from regulators or privacy authorities—for example, for violating the\nEuropean Union’s General Data Privacy Rules (GDPR) that make companies responsible for\nsecuring sensitive customer data in their possession.\n\nAn increasing number of ransomware gangs use extortion that threatens the release of\nprivate data, which might include sensitive customer information, trade secrets, or\nembarrassing correspondence to incentivize victims to pay the ransom, even if they have\n[backups that prevented data loss. The data leak threat has become a signature of the REvil](https://nakedsecurity.sophos.com/2020/03/23/stolen-data-of-company-that-refused-revil-ransom-payment-now-on-sale/)\nand Maze ransomware gangs; the Maze group has gone as far as to publicly publish chunks\nof data from victims who fail to pay by the deadline, taking down the dumps when they are\nfinally paid.\n\n## Picking through LockBit’s code\n\nFrom a first glance at the recent LockBit sample with a reverse-engineering tool, we can tell\nthat the program was written primarily in C++ with some additions made using Assembler.\nFor example, a few anti-debug techniques employ the fs:30h function call to manually check\nthe PEB (Process Environment Block) for the BeingDebugged flag, instead of using\n**IsDebuggerPresent().**\n\nThe first thing the ransomware does at execution is to check whether the sample was\nexecuted with any parameters added from the command line. Usually, this is done to check\nfor whether the sample is being executed in a sandbox environment. Contemporary malware\noften requires that the command to run the malware use specific parameters to prevent the\nmalware from being analyzed by an automated sandbox, which often execute samples\nwithout parameters. But the LockBit sample we examined doesn’t do that—it won’t execute if\nthere is any parameter entered from the command line. If there are no arguments in the\ncommand that executes it, Lockbit hides its console output, where the malware prints debug\nmessages, and proceeds to do its job.\n\n\n-----\n\nThe command-line\n\nparameter checker in LockBit halts the ransomware if there’s any parameter passed.\nThis could be intended to detect if the sample was executed in a sandbox environment. But\nit’s possible that either the malware author made a mistake in the implementation of the\ncheck (and wanted to check the other way around), or that this behavior is just a placeholder,\nand future versions will introduce different logic.\n\n### Hiding strings\n\nLockBit’s author also used several techniques to make it more difficult to reconstruct the\ncode behind it. The Portable Executable (PE) binary shows signs of being heavily optimized,\nas well as some efforts by the group to cover their coding tracks—or at least get rid of some\nof the low-hanging fruit that reverse engineering tools look for, such as unencrypted text\nstrings.\n\nThose heavy optimizations also increase LockBit’s performance. The binary makes heavy\nuse of Intel’s SSE instruction set and architecture-specific features to boost its performance.\nThat includes the use of multiple XMM registers used to store and decrypt the service\nnames, process names and other strings used to interact with the operating system that are\nunique to the ransomware.\n\nXmmword registers store encrypted LockBit strings\nThese string variables get decrypted on the fly with a 1-byte XOR key unique to each string:\nthe first hex byte of every variable.\n\n\n-----\n\nAlmost all the functions contain a small routine that loops around and is in charge of\ndecrypting hidden strings. In this case, we can see that how the original\n**MSSQLServerADHelper100 service name gets de-obfuscated: the malware leverages a**\none-byte “0A” XOR key to decrypt the plaintext service name.\n\nDeobfuscating service names in the source\n\n### Check your privilege\n\n\n-----\n\nTo ensure that it can do the most damage possible, LockBit has a procedure to check\nwhether its process has Administrator privileges. And if it doesn’t, it uses a technique that is\ngrowing in popularity among malware developers: a Windows User Account Control (UAC)\nbypass.\n\nLeveraging OpenProcessToken, it queries the current process via a TOKEN_QUERY\naccess mask. After that, it calls CreateWellKnownSid to create a user security identifier\n(SID) that matches the administrator group (WinBuiltinAdministratorsSid), so now the\nmalware has a reference it can use for comparisons. Finally, it checks whether the current\nprocess privileges are sufficient for Administrator rights, with a call to\n**CheckTokenMembership.**\n\nChecking Administrator SID against the current process’ SID\nIf the current process does not have Admin privileges, the ransomware tries to sidestep\nWindows UAC with a bypass. In order for that to succeed, a Windows COM object needs to\nauto-elevate to Admin-level access first.\n\nTo make this possible, LockBit calls a procedure called supMasqueradeProcess upon\nprocess initialization. Using supMasqueradeProcess allows LockBit to conceal its process’\ninformation by injecting into a process running in a trusted directory. And what better target is\nthere for that than explorer.exe?\n\n[The source code for the masquerade procedure can be found in a Github repository.](https://github.com/hfiref0x/UACME/blob/master/Source/Akagi/sup.c)\n\n\n-----\n\nLockBit “masquerades” as explorer.exe\nWith the use of IDA Pro’s COM helper tool, we see two CLSIDs—globally unique identifiers\nthat identify COM class object—that LockBit’s code references. CLSIDs, represented as 128bit hexadecimal numbers within a pair of curly braces, are stored in the Registry path\n**HKEY_LOCAL_MACHINE\\Software\\Classes\\CLSID.**\n\nCLSIDs recognized by IDA.\nLooking up these reveals that the two CSLIDS belong to IColorDataProxy and ICMLuaUtil\n[—both undocumented COM interfaces that are prone to UAC bypass.](https://github.com/hfiref0x/UACME/blob/master/Source/Akagi/methods/hybrids.c)\n\n**Name** **CLSID** **DLL**\n\n\nCMSTPLUA {3E5FC7F9-9A51-4367-9063A120244FBEC7}\n\n\nColor\nManagement\n\n\n{D2E7041B-2927-42fb-8E9F7CE93B6DC937}\n\n\n..\\system32\\cmstplua.dll\n\n..\\system32\\colorui.dll\n\n\n-----\n\nMasquerading as explorer.exe, LockBit calls CoInitializeEx to initialize the COM library, with\n**COINIT_MULTITHREADED and COINIT_DISABLE_OLE1DDE flags to set the concurrency**\nmodel. The hex values here (CLSIDs) are then moved and aligned into the stack segment\nregister, and the next function call (lockbit.413980) will further use them.\n\nUAC bypass step 1\n\nUAC bypass step 2\n**Lockbit.413980 hosts the COM elevation moniker, which allows applications that are**\nrunning under user account control (UAC) to activate COM classes (via the following format:\n_Elevation:Administrator!new:{guid} ) with elevated privileges._\n\nThe malware adds the 2 previously seen CLSIDs to the moniker and executes them.\n\n\n-----\n\nThe COM\n\nElevation Moniker in use.\nNow, the privilege has been successfully elevated with the UAC bypass and the control flow\nis passed back to the ransomware. We also notice two events and a registry key change\nduring the execution:\n\nC:\\WINDOWS\\SysWOW64\\DllHost.exe /Processid:{3E5FC7F9-9A51-4367-9063A120244FBEC7}\n\nC:\\WINDOWS\\SysWOW64\\DllHost.exe /Processid:{D2E7041B-2927-42fb-8E9F7CE93B6DC937}\n\nKey: Software\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\Calibration\n\nValue: DisplayCalibrator\n\n### Kill or skip\n\nLockBit enumerates the currently running processes and started services via the API calls\n**CreateToolhelp32Snapshot, Process32First, Process32Next and finally OpenProcess,**\nand compares the names against an internal service and process list. If one process\n\n\n-----\n\nmatches with one on the list, LockBit will attempt to terminate it via TerminateProcess.\n\nThe procedure to kill a service is a bit different. The malware will first connect to the Service\nControl Manager via OpenSCManagerA. It then attempts to check whether a service from\nthe list exists via OpenServiceA. If the targeted service is present, it then tries to determine\nits state by calling to QueryServiceStatusEx. Based on the status returned, it will call\n**ControlService with the parameter SERVICE_CONTROL_STOP (0x00000001) on the**\nspecific service to stop it. But before that, another function (0x40F310) will cycle through all\ndependent services in conjunction with the target service, so dependencies are stopped too.\nThe malware will initiate calls to EnumDependentServicesA to achieve this.\n\nHardcoded service names being checked against running services\nThe services that the malware tries to stop include anti-virus software (to avoid detection)\nand backup solution services. (Sophos is not affected by this attempt.) Other services are\nstopped because they might lock files on the disk, and might make it more difficult for the\nransomware to easily acquire handles to files—stopping them improves LockBit’s\neffectiveness.\n\nSome of the services of note that the ransomware attempts to stop, in the order they are\ncoded into the ransomware, are:\n\nDefWatch Symantec Defwatch\n\nccEvtMgr Norton AntiVirus Event Manager Service\n\nccSetMgr Symantec Common Client Settings Manager Service\n\nSavRoam Symantec AntiVirus suite\n\nRTVscan Symantec AntiVirus\n\nQBFCService QuickBooks is an accounting software\n\n\n-----\n\nQBIDPService QuickBooks for Windows by Intuit, Inc..\n\nIntuit.QuickBooks.FCS QuickBooks for Windows by Intuit, Inc..\n\nQBCFMonitorService QuickBooks for Windows by Intuit, Inc..\n\nYooBackup Wooxo Backup\n\nYooIT Wooxo Backup\n\nzhudongfangyu 360 by Qihoo 360 Deep Scan\n\nsophos Sophos\n\nstc_raw_agent STC Raw Backup Agent\n\nVSNAPVSS StorageCraft Volume Snapshot VSS Provider\n\nVeeamTransportSvc Veeam Backup Transport Service\n\nVeeamDeploymentService Veeam Deployment Service\n\nVeeamNFSSvc Veeam Backup and Replication Service\n\nveeam Veeam\n\nPDVFSService Veritas Backup Exec PureDisk Filesystem\n\nBackupExecVSSProvider Veritas Backup Exec VSS Provider\n\nBackupExecAgentAccelerator Veritas Backup Exec Agent Accelerator\n\nBackupExecAgentBrowser Veritas Backup Exec Agent Browser\n\nBackupExecDiveciMediaService Veritas Backup Exec Media Service\n\nBackupExecJobEngine Veritas Backup Exec Job Engine\n\nBackupExecManagementService Veritas Backup Exec Management Service\n\nBackupExecRPCService Veritas Backup Exec RPC Service\n\nAcrSch2Svc Acronis Scheduler Service\n\nAcronisAgent Acronis Agent\n\nCASAD2DWebSvc Arcserve UDP Agent service\n\nCAARCUpdateSvc Arcserve UDP Update service\n\n\n-----\n\nIn addition to the list of services to kill, LockBit also carries a list of things not to encrypt,\nincluding certain folders, specific files and files with certain extensions that are important to\nthe operating system—since disabling the operating system would make it difficult for the\nvictim to receive and act upon the ransom note. These are stored in obfuscated lists within\nthe code (shown below), A function within LockBit uses the FindFirstFileExW and\n**FindNextFileW API calls to read through the file names and folder names on the targeted**\ndisk, and then a simple lstrcmpiW function is called to compare the hardcoded list with\nthose names.\n\n### Accelerating file encryption\n\nRecently, we have seen ransomware groups taking more advanced concepts and applying it\nto their craft. One of these advanced concepts applied in LockBit is the use of Input/Output\n**Completion Ports (IOCPs).**\n\nIOCPs are a model for creating a queue to efficient threads to process multiple\nasynchronous I/O requests. They allow processes to handle many concurrent asynchronous\nI/O more quickly and efficiently without having to create new threads each time they get an\nI/O request.\n\n\n-----\n\nThat capability makes them well-suited to ransomware. The sole purpose of ransomware is\nto encrypt as many delicate files as possible, rendering the user’s data useless. REvil\n(Sodinokibi) ransomware also uses IOCPs to achieve higher encryption performance.\n\nLockBit’s aim was to be much faster than any other multi-threaded locker. The group behind\nthe ransomware claims to have used the following methods to boost the performance of their\nfile encryption:\n\n_Open files with the FILE_FLAG_NO_BUFFERING flag, write by sector size_\n_Transfer work with files to Native API_\n_Use asynchronous file I/O_\n_Use I/O port completion_\n_Pass control to the kernel yourself, google KiFastSystemCall_\n\n\n-----\n\nOnce a file is marked for encryption—meaning, it did not match entries on the skip-list—a\nLockBit routine checks whether the file already has a .lockbit extension. If it does not, it\nencrypts the file and appends the .lockbit extension to the end of the filename.\n\nLockbit relies on LoadLibraryA and GetProcAddress to load bcrypt.dll and import the\n**BCryptGenRandom function. If the malware successfully imports that DLL, it uses**\n**BCRYPT_USE_SYSTEM_PREFERRED_RNG which means use the system-preferred**\n_random number generator algorithm. If the malware was unsuccessful calling bcrypt.dll, it_\ninvokes CryptAcquireContextW and CryptGenRandom to invoke the Microsoft Base\nCryptographic Provider v1.0 and generates 32 bytes of random data to use as a seed.\n\nBCryptGenRandom in use\nAlso, at this stage, the hardcoded ransom note, Restore-My-Files.txt, gets de-obfuscated\nand the ransomware drops the .txt file in every directory that contains at least one encrypted\nfile.\n\n### Victim ID\n\nLockBit creates 2 registry keys with key blobs as values under the following registry hive:\n**HKEY_CURRENT_USER\\Software\\LockBit**\n\nThe two registry keys are:\n\n**LockBit\\full**\n\n**LockBit\\Public**\n\nThese registry keys correlate with the Victim ID, file markers, and the unique TOR URL ID\nthat LockBit builds for each system it takes down.\n\n\n-----\n\nLet s take the unique TOR URL from the ransom note:\n\nLockBit ransom note\nIn this example, the 16 byte long unique ID is at the end of the URL,\nhttp://lockbitks2tvnmwk[.]onion/?A0C155001DD0CB01AE0692717A2DB14A :\n\nThe first 8 bytes used here (A0C155001DD0CB01)is the first 8 bytes of the file marker\nthat is present in every encrypted file’s end .\n\nFile marker at end of encrypted file.\nThe last 8 bytes (AE0692717A2DB14A) is the first 8 bytes of the Public registry key.\n\nThe file marker (0x10 long) is divided into 2 sections:\n\nA0C155001DD0CB01\n\nThe first 8 bytes of the file marker and the first 8 bytes of the TOR unique URL ID.\n\nD4EA7A79A0835006\n\nThe second 8 bytes are same for all encrypted files in a given run\n\nAlso, the value of the full registry key (0x500 long, starting as\n1A443C7179498278B40DC082FCF8DE26… in this example) is also present in every\nencrypted file, just before the file marker.\n\n\n-----\n\nLockBit registry keys (full and Public) that are related to the victim machine.\n\n### Share enumeration\n\nFor a successful ransomware hit and run, the goal is to encrypt as many files as possible. So\nnaturally, LockBit scans for network shares and other attached drives with the help of the\nfollowing API calls.\n\nFirst, the malware enumerates the available drive letters with a call to GetLogicalDrives,\nthen it cycles through the found drives and uses a call to GetDriveTypeW to determine\nwhether the drive letters it finds are network shares by comparing the result with 0x4\n(DRIVE_REMOTE).\n\nOnce it finds a networked drive, it calls WNetGetConnectionW to get the name of the share,\nthen recursively enumerates all the folders and files on the share using the\n**WNetOpenEnumW, WNetEnumResourceW API calls.**\n\nThe ransomware can also enter network shares that might require user credentials. LockBit\nuses the WNetAddConnection2W API call with parameters lpUserName = 0 and\n_lpPassword = 0, which (counterintuitively) transmits the username and password of the_\ncurrent, logged in user to connect to the given share. Then it can enumerate the share using\nthe NetShareEnum API call.\n\n\n-----\n\nEnumeration of attached, remote drives\n\n### Don’t quit just yet\n\nI an attempt to ensure that LockBit would not be kept from finishing its job by a system\nshutdown, the developers of this ransomware implemented a small routine that uses a call to\n**ShutdownBlockReasonCreate.**\n\nThe developers didn’t try to conceal the ransomware as the cause of the shutdown block: the\nransomware sets the message for blocking shutdown as LockBit Ransom. Computer users\nwould also see the message LockBit Ransom under the process’ name.\n\n**SetProcessShutdownParameters is also called to set the shutdown order level of the**\nransomware’s process to 0, the lowest level, so that the ransomware’s parent process will be\nactive as long as it can, before a shutdown terminates the process.\n\nIf the system is shut down, the malware also has capability to persist after a reboot. LockBit\ncreates a registry key to restart itself under\nHKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\, called XO1XADpO01.\n\nPlacing a persistence Run key in registry\n\n\n-----\n\n### Stop me if you ve heard this before\n\nLockBit prevents multiple ransomware instances on a single system by way of a hardcoded\nmutex: Global\\{BEF590BE-11A6-442A-A85B-656C1081E04C}. Before LockBit starts\nencrypting, the ransomware checks that the mutex does not already exist by calling\n**OpenMutexA, and calls ExitProcess if it does.**\n\nAs soon as the ransomware is mapped into memory and the encryption process finishes, the\nsample will execute the following command to maintain a stealthy operation:\n\n**exe /C ping 1.1.1.1 -n 22 > Nul & \\”%s\\”** _(earlier version of LockBit)_\n**exe /C ping 127.0.0.7 -n 3 > Nul & fsutil file setZeroData offset=0 length=524288**\n**“%s” & Del /f /q “%s”** _(recent version of LockBit)_\n\nThe ping command at the front is used because the sample can’t delete itself, due to the fact\nthat it is locked. Once ping terminates, the command can delete the executable.\n\nWe clearly see an evolution to the applied technique here: in the earlier versions, the sample\nwas missing a Del procedure at the end, so the ransomware would not delete itself.\n\nIn the recent version, the crooks had decided to use fsutil to basically zero out the initial\nbinary to perhaps throw off forensic analysis efforts. After the file is zeroed out, the now nullfile is deleted also, making double-sure the malware is not forensically recoverable.\n\n### Language matters\n\nAs we noted earlier, LockBit’s developers wanted to avoid having their ransomware hit\nvictims in Commonwealth of Independent States (CIS) countries. The mechanism used by\nthe ransomware to achieve this calls GetUserDefaultLangID and looks for specific language\nidentifier constants in the region format setting for the current user. If the current user’s\nlanguage setting matches any of the values below, the ransomware exits and does not start\nthe encryption routine.\n\n\n-----\n\nIf\n\nyour computer’s UserDefaultLangId is set to one of these values, LockBit does no damage\n\n### Changing the wallpaper\n\nTo get the affected user’s attention, the malware (as is typical) creates and displays a\nransom note wallpaper. A set of API calls are involved in this process, listed below.\n\nThe created wallpaper gets stored under %APPDATA%\\Local\\Temp\\A7D8.tmp.bmp.\n\nIn the meantime, the malware also sets a few registry keys so that the wallpaper is not tiled,\nand the image is stretched out to fill the screen:\n\nHKEY_CURRENT_USER\\Control Panel\\Desktop\n\n**TileWallpaper=0 – (No tile)**\n**WallpaperStyle=2 – (Stretch and fill)**\n\nWallpaper used by a previous version of LockBit\n\nWallpaper set by a recent version of LockBit\n\n### Stack Exchange for crooks\n\n\n-----\n\nLockBit leverages a very similar service-list to MedusaLocker ransomware. It comes as no\nsurprise that crooks copy these lists, so they don’t have to reinvent the wheel.\n\nThe unique Registry run key and ransom note filename that was written by LockBit—\n**XO1XADpO01 and Restore-My-Files.txt — were also seen being used by Phobos, and by**\na Phobos imposter ransomware. This would suggest that there is a connection between\nthese families, but without further evidence that is hard to justify.\n\n### The future for LockBit\n\nA recent Twitter post demonstrates what the future looks like for LockBit. In a recent LockBit\nattack, the MBR was overwritten with roughly 2000 bytes; The infected machine would not\nboot up unless a password is supplied. The hash of this sample is currently not known.\n\n\n-----\n\nhttps://twitter.com/spacetrain31/status/1232296412378955776\n[The e-mail used for extortion ondrugs@firemail.cc was also seen with STOP ransomware—](http://10.10.0.46/mailto:ondrugs@firemail.cc)\nan uncanny connection. The group behind might be related.\n\nThere is also speculation that application Diskcryptor was combined with the ransomware to\nadd this extra lockdown layer. The MAMBA ransomware was also using this technique,\nleveraging Diskcryptor to lock the victim machine. DiskCryptor is currently being detected as\n**AppC/DCrpt-Gen by Sophos Anti-Virus.**\n\nA list of the indicators of compromise (IoCs) for this post have been published to the\nSophosLabs Github.\n\n\n-----\n\n## Acknowledgments\n\n The author would like to acknowledge the public contributions of @demonslay335 and @hfiref0x.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-24 - LockBit ransomware borrows tricks to keep up with REvil and Maze.pdf"
    ],
    "report_names": [
        "2020-04-24 - LockBit ransomware borrows tricks to keep up with REvil and Maze.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535594,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653821401,
    "ts_modification_date": 1653821401,
    "files": {
        "pdf": "https://archive.orkl.eu/ce12fabac6ef7d4faad496a5ccaa3bf6211a7ebb.pdf",
        "text": "https://archive.orkl.eu/ce12fabac6ef7d4faad496a5ccaa3bf6211a7ebb.txt",
        "img": "https://archive.orkl.eu/ce12fabac6ef7d4faad496a5ccaa3bf6211a7ebb.jpg"
    }
}