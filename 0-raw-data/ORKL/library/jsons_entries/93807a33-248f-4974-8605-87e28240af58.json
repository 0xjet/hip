{
    "id": "93807a33-248f-4974-8605-87e28240af58",
    "created_at": "2023-01-12T15:00:17.35206Z",
    "updated_at": "2025-03-27T02:16:25.543885Z",
    "deleted_at": null,
    "sha1_hash": "a8621f55d0056c799196bb6df4ba0273555b3d17",
    "title": "2021-02-17 - ELF Malware Analysis 101- Part 3 - Advanced Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T15:51:54Z",
    "file_modification_date": "2022-05-28T15:51:54Z",
    "file_size": 4313634,
    "plain_text": "# ELF Malware Analysis 101: Part 3 - Advanced Analysis\n\n**[intezer.com/blog/malware-analysis/elf-malware-analysis-101-part-3-advanced-analysis/](https://www.intezer.com/blog/malware-analysis/elf-malware-analysis-101-part-3-advanced-analysis/)**\n\nFebruary 17, 2021\n\nWritten by Avigayil Mechtinger - 17 February 2021\n\n### Get Free Account\n\nJoin Now\n\n### Top Blogs\n\n## Getting Caught Up to Speed\n\n[So far in this series we have profiled the ELF threat landscape and covered the most](https://www.intezer.com/blog/linux/elf-malware-analysis-101-linux-threats-no-longer-an-afterthought/)\n[common intrusion vectors seen in Linux systems. We also pursued initial ELF analysis with](https://www.intezer.com/blog/linux/elf-malware-analysis-101-initial-analysis/)\nan emphasis on static analysis. We learned about the different artifacts and components\nthat are relevant for initial analysis and how they can help us gather immediate insights\nabout a file. In Part 3, we will take the next step and dynamically analyze ELF malware.\n\n\n-----\n\nWhile static analysis is performed without execution, dynamic analysis gives us an\nunderstanding of how a file interacts with the operating system at runtime. Insights about\nfile behavior help us better assess the potential impact of the malware and gather additional\nindicators that can help us paint the bigger picture (C&C for instance). Dynamic analysis\n[also allows us to collect further Tactics, Techniques, and Procedures (TTPs) that can be](https://www.intezer.com/blog/malware-analysis/new-feature-get-more-context-for-your-analysis-with-ttps/)\nattributed to specific malicious tools and threat actors.\n\nStatic and dynamic analysis are complementary. The information gathered during initial\nanalysis will accelerate the dynamic analysis process.\n\n## Agenda\n\nAfter reading this article you will be able to understand which insights can be extracted\nduring ELF runtime and what tools can help you do so.\n\nThe following subjects will be covered in this article:\n\n1. Linux Processes\n2. ELF Syscalls\n3. Persistence Methods\n4. Network Sniffing\n5. Sandboxes\n\nAfter covering our dynamic analysis toolset, we will put them to use by practicing on a real\nsample found in the wild.\n\n## Analysis Environment Preparations\n\nBefore we get started, let’s prep your Linux VM (virtual machine). If you don’t have a Linux\nVM, follow [this guide to install one.](https://itsfoss.com/install-linux-in-virtualbox/)\n\nNeedless to say, running malware should only be done in isolated environments such as\nVMs. Even when using a VM the malware can cause harm, not only to your system but also\nto other machines over the internet. For example, running a worm can spread it over the\nnetwork (see [New Golang Worm Drops XMRig Miner on Servers). Running ransomware or](https://www.intezer.com/blog/research/new-golang-worm-drops-xmrig-miner-on-servers/)\nstealers can encrypt and/or collect information from your VM, including files located on the\nshared folders with your host.\n\nMake sure that before you run a malware your virtual environment meets the following\ncriteria:\n\n1. Your machine host name and user name are generic. Run uname -n to see the\n\nhost name of your machine, and run getent passwd {1000..60000} to list all human\nusernames on the machine.\n\n\n-----\n\n2. Your IP is not easily trackable. Blurring your public IP can be done in several ways:\n\n1. Basic: Use a [VPN service on your host machine during dynamic analysis. The](https://cybernews.com/best-vpn/)\n\ntraffic from your VM should be tunneled through your host. Verify your public IP\nfrom within the VM by running a command such as: curl ‘https://api.ipify.org’.\n[There are various free VPN programs you can use such as OpenVPN.](https://openvpn.net/)\n2. Advanced: Use a second VM as a router that tunnels traffic, via Tor for\n\ninstance. Establishing that, you can route the entire network from your malware\nanalysis VM through the router VM.\nNote that you can always disconnect your machine from the internet and start the\ndynamic analysis with no network connection as a first step.\n\n1. Your machine is clean from private information. Make sure that you don’t have any\n\npasswords, API keys, etc. written on the machine.\n2. Disable shared folder and shared clipboard before running the malware.\n\n## Setting Up SSH Connection\n\nUse SSH to transfer files from your machine (host) to your VM (guest). Follow these steps\nto establish connection:\n\n1. Install [OpenSSH on your VM:](https://www.openssh.com/)\n\n**_sudo apt-get update_**\n\n**_sudo apt-get install -y openssh-server_**\n2. Shut down your VM.\n\n1.\n\n1. Go to Settings > Network.\n\n1. Adapter 1 should be set to NAT:\n\n\n-----\n\n1.\n\n1. Add a second adapter: Choose “Host-only Adapter” and apply changes.\n\n1. Go to Settings > System > Motherboard and make sure these entries are enabled:\n\n\n-----\n\n1. Start your VM and get the LAN IP address of the VM instance. Run ip addr show.\n\n\n-----\n\n1.\n\n1. Make sure the OpenSSH service is active on the VM by running: sudo service\n\n**ssh status.**\n\n1. You should now be able to connect from your host to the guest machine via SSH.\n\nUsing scp command you can copy files and directories from your host machine to the\nVM. Run on your host:\n**scp -r \\my\\host\\path VM-username@/path/to/whereyouwant/thefile**\n\n## Linux Processes\n\nEvery instance of a running program on the system is a process. Each process has its\nunique process ID. You can see all of your processes by running ps aux. The [ps command](https://man7.org/linux/man-pages/man1/ps.1.html)\ndisplays information about the process that ran at the exact time you ran the ps command.\n[To see an ongoing repetitive output use top.](https://man7.org/linux/man-pages/man1/top.1.html)\n\n_Figure 1: ps aux output_\n\n## The proc Filesystem\n\nThe “proc” filesystem is a pseudo-filesystem provided by the Linux kernel. It provides an\ninterface to kernel data structures which includes information about all currently running\nprocesses. It will commonly be mounted under the /proc directory. Each process has its own\n\n\n-----\n\ndirectory under /proc and the directory name is the process ID.\n\nTo get a better understanding of the proc directory, open two terminals on your Linux VM\nand run ping 8.8.8.8 on one of them. On the second terminal, run pidof ping to retrieve\nping’s process ID.\n\nLet’s review the process directory by browsing the /proc/PID directory and running ls. You\ncan see that it has different directories and files. All process directories share the same\nstructure, filenames and directories. Figure 2 describes the flow above.\n\n_Figure 2: Retrieving ping’s process ID and the process directory content_\n\nThe following are some interesting files that will be present under every process directory:\n\n**cmdline – command line arguments that ran the file.**\n\n**status – process status in human readable form.**\n\n**maps – memory maps regions and their access permissions.**\n\n**exe – symbolic link containing the pathname of the executed command. Attempting to open**\nit will open the executable. Try running sha256sum exe and sha256sum on the ping file:\n**sha256sum $(which ping). You will see they match.**\n\nAfter you kill the ping process, you will see the /proc/PID directory no longer exists.\n\n[Browse here for more information about the proc file system.](https://man7.org/linux/man-pages/man5/proc.5.html)\n\n## Process Tree\n\nThe process tree structure can give you insights about what is running on a machine before\ndiving into specific processes.\n\n\n-----\n\nA single executable can create more than one process on the machine. Let s emphasize\nthat by using the pstree command to view the running processes as a tree. The following\nare some examples of what the process tree will look like for each scenario:\n\n1. Other process creation: A process can call other processes. Let’s compile a simple\n\nprogram that runs a ping command via bash and name it ping-google-dns:\n\n_Figure 3: ping-google-dns source code_\n\nLet’s run the program and on another terminal run pstree | grep ping-google-dns:\n\n_Figure 4: Process tree created by ping-google-dns_\n\nWe ran the ping-google-dns program from a terminal (bash process) which called sh\nbinary (a command language interpreter) that called the ping binary.\n\n\n-----\n\n1. Forks: fork() creates a new, duplicate process of the called process. The new process\n\nis called a child process and it will have a different process ID than its parent. Let’s recompile the ping-google-dns source code, this time with the addition of a fork() call.\n\n_Figure 5: ping-google-dns source code_\n\nLet’s run the program and on another terminal run pstree | grep ping-google-dns.\n\nFigure 6 shows what the process tree looks like with one fork call. You will see in the\nscreenshot below that the same program has two process IDs.\n\n_Figure 6: Process tree created by ping-google-dns_\n\n1. Threads: Threads provide multiple executions within the program. A process thread\n\nwill not create a new process ID. Let’s compile this code that runs three threads as\n**[print-something (the compiled file can be downloaded from here).](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-3-Advanced-Analysis/Article-samples/print-something)**\n\n\n-----\n\n_Figure 7: print-something source code_\n\nNow let’s run the program and run pstree | grep print-something on another terminal.\nFigure 8 emphasizes what the process tree of a program that runs with three threads will\nlook like.\n\n_Figure 8: Process tree created by print-something_\n\n## Process Monitoring Tools\n\n[Sysinternals Suite provides convenient GUIs for monitoring all processes that are running](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)\non a Windows machine (among other things). Microsoft’s [ProcMon-for-Linux based on](https://github.com/Sysinternals/ProcMon-for-Linux/)\n[ProcMon and Intezer’s](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) [Linux Expl0rer inspired by ProcExp, are intuitive solutions for Linux](https://github.com/intezer/linux-explorer)\n\n\n-----\n\nprocess tracking.\n\n## System Calls\n\nOnly the kernel can perform changes outside of the process’s own memory space. The\nprocess must ask the kernel to perform tasks such as creating files or writing output. This is\nwhere system calls come into play.\n\n[Syscalls (system calls) are the interface used by the application to request services from](https://man7.org/linux/man-pages/man2/syscalls.2.html)\nthe kernel. Syscalls are usually invoked via glibc wrappers and not directly to the kernel\nbecause of portability. The low level syscalls differ between architectures which is why glibc\nhandles these differences instead of the developer.\n\n**Syscalls are an interface that the malware must pass through in order to cause actual**\n**harm to the system. Analyzing syscalls can help us understand how the file interacts**\n**with the system and how it operates behind the scenes.**\n\n_[strace is a powerful tool to trace a file’s system calls. Run strace whoami on your Linux VM](https://man7.org/linux/man-pages/man1/strace.1.html)_\nand take a look at the output. Each row in the strace output is a syscall, and the first syscall\nwill be execve which stands for execute program. Each system call has a return value that\nvaries between calls. It can be a file descriptor (integer) or 0 on success, -1 on error and\nmore.\n\nThese are some interesting syscalls we will look for by analyzing the strace output:\n\n**open/openat – open and possibly create a file.**\n\n**read – read from a file descriptor.**\n\n**access – check user’s permissions for a file.**\n\n**write – write to a file descriptor.**\n\n**mkdir/mkdirat – make directories.**\n\n**connect – initiate a connection on a socket.**\n\n**socket – create an endpoint for communication.**\n\n**execve – execute program.**\n\n[Let’s try it ourselves. Run the trace-me file on your VM using strace. Use the -o flag to save](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-3-Advanced-Analysis/Article-samples/trace-me)\nthe command output: strace -o out.txt ./trace-me:\n\n\n-----\n\n_Figure 9: trace-me output_\n\nNow, let’s read the strace output to see what happened on the system. Run cat out.txt:\n\n_Figure 10: strace output_\n\nYou will see the file creates the .tomato directory under tmp directory, and creates a file\n\n**answer.txt inside this directory. If you look carefully on the flow, you can see the return**\nvalue of openat for the anser.txt file is 3, which is the file descriptor. Then, write syscall, “I\n**was created!!” uses the file descriptor 3 as an input. This means that this text is written to**\nthe answer.txt.\n\n**Tips:**\n\n1. In most cases the syscalls output will be much bigger than the last example. It is\n\nrecommended to always save the strace output to a text (strace -o out.txt ./file).\n[Make sure that you have a convenient text editor such as Sublime Text that will help](https://www.sublimetext.com/docs/3/linux_repositories.html)\nyou analyze the large text file.\n2. To gain full visibility on all syscalls of the processes created by the file, including forks,\n\nyou can run strace with the fork flag -f (strace -f ./file).\n3. The default strings length is 32. Use the -v (verbose) and -s (string size) flags to see\n\nmore characters (strace -v -s 150 ./file).\n4. To reduce noise, you can choose which syscalls will be presented on strace output\n\nusing the -e flag. For example, if you are searching for network-related calls together\nwith read and write calls, you can run strace -e network,read,write ./file.\n\n[Learn more about syscalls](https://man7.org/linux/man-pages/man2/syscalls.2.html)\n\n## Persistence\n\n\n-----\n\nOnce a malware finds its way into a compromised system, it will often attempt to achieve\npersistence in order to survive reboot. Another reason why malware developers add\npersistence capabilities is to harden removal efforts, which is also attempted by other\nmalware families in order to gain a foothold on already compromised systems. This is more\ncommon among CoinMiners, which will search for other known Miners on a compromised\nmachine and attempt to kill them, to be the only CoinMiner running on the system and\nultimately win the machine’s resources. See War of Linux Cryptocurrency Miners: A Battle\nfor Resources.\n\n**Detecting persistence methods is important for understanding how to respond to**\n**malware on a compromised machine. Killing the process is not always enough to**\n**mitigate the threat, the persistence methods should be cleared as well.**\n\nThese are the most common persistence methods used by Linux malware:\n\n[1. Cron – Malware will create scheduled tasks to run periodically on a system using cron](https://attack.mitre.org/techniques/T1053/003/)\n\njobs. [crontab and](https://man7.org/linux/man-pages/man5/crontab.5.html) [anacrontab are the configuration files used for cron and](https://linux.die.net/man/5/anacrontab) [anacron](https://linux.die.net/man/8/anacron)\nservices which are in charge of executing scheduled tasks. The malware will write\nregistries to the configuration files which are located under: /etc/crontab,\n/var/spool/cron/, /etc/cron.d/, /etc/anacrontab, /var/spool/anacron/. The following\n[XMRig Miner dropper uses crontab as one of its persistence methods. Figure 11](https://twitter.com/IntezerLabs/status/1334147151329435650)\nemphasizes what a crontab registry looks like:\n\n_Figure 11: crontab registry written by a malware_\n\n**Note: Running crontab -l will list the existing cron jobs per user. Using root privileges, you**\ncan either run crontab -l -u <user> or cat /var/spool/cron/crontabs/<user> for specific\nusers. To view the cron jobs for all users, run cd /var/spool/cron/crontabs/ && grep . *\n\n[1. Services – Linux has initialization scripts that are used to start services on system](https://attack.mitre.org/techniques/T1053/006/)\n\nboot. The program in charge of starting the rest of the system will run as PID 1 (you\ncan explore your /proc/1 directory). Malware will often attempt to gain persistence by\ncreating a service which will run by the init program on boot. The init program varies\nbetween Linux distributions and versions, however, systemd is most common these\ndays. rc.d and init.d are older init services which are still used in certain Linux\n[distributions. Learn more about why init.d was replaced by systemd](https://www.tecmint.com/systemd-replaces-init-in-linux/)\nThe service will commonly be found under the following paths: /etc/systemd/system/,\n~/.config/systemd, /etc/rc.d/, /etc/init.d/.\n\n[IPStorm Linux version is an example of a malware that gained persistence by creating](https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/)\na service under /etc/systemd/system/storm.service. Figure 12 emphasizes the\nstructure of a systemd service file.\n\n\n-----\n\n_Figure 12: storm.service content_\n\n[1. Event Triggered Executions – Once a user logs in or a new shell session is created,](https://attack.mitre.org/techniques/T1546/004/)\n\nLinux will automatically launch executables by using configuration files. These\nconfiguration files are bash scripts which can be edited to trigger a malware. Files\nlocations: /etc/profile.d, /etc/profile, /etc/bash.bashrc, ∼/.bashrc, ∼/.bash_profile,\n[~/.bash_login, ~/.profile. Linux Rabbit is a malware that uses the .bashrc to set up](https://www.anomali.com/blog/pulling-linux-rabbit-rabbot-malware-out-of-a-hat)\npersistence.\n\n[1. Graphical Desktop Autostarts – Similar to event triggered executions, once a user](https://attack.mitre.org/techniques/T1547/)\n\nlogs in via a graphical desktop environment such as GNOME or KDE, Linux will\nautomatically search for desktop entries to execute applications on startup. A generic\nlocation for desktop entries is under ∼/.config/autostart/. Other possible locations\ninclude: ~/.kde/Autostart,~/.kde/share/autostart, ~/.kde4/Autostart,\n/usr/share/autostart/, /etc/xdg/autostart/. The autostart service will have a .desktop\nsuffix. This persistence method is relevant for malware that targets endpoints.\n[ElectroRAT’s Linux version gains persistence by creating a desktop entry under](https://twitter.com/AbbyMCH/status/1346470180247937027)\n~/.config/autostart/mdworker.desktop.\n\n\n-----\n\n[1. Loadable Kernel Modules (LKM) – The Linux kernel is designed to allow loading of](https://attack.mitre.org/techniques/T1547/006/)\n\nexternal pieces of code called kernel modules. Kernel modules are automatically\nloaded on system boot. Because the Linux kernel runs as root, and the modules can\n[be loaded dynamically (using modprobe or](https://linux.die.net/man/8/modprobe) [insmod) with no need to reboot the](https://linux.die.net/man/8/insmod)\nsystem, this method is commonly used for rootkits as well. Malware that attempts to\ngain persistence via this method will create malicious kernel modules that will be\nloaded to the kernel and run on boot. The location of the kernel modules is under:\n/lib/modules/$(uname -r). By running lsmod you can see what kernel modules are\ncurrently loaded.\n\n[1. Hijack Execution Flow – Dynamically linked binaries use shared libraries during](https://attack.mitre.org/techniques/T1574/006/)\n\nruntime (in the previous article we explained the differences between dynamically and\nstatically linked files). These libraries are loaded by the dynamic linker which searches\nfor libraries on absolute paths and common directories. LD_PRELOAD is an optional\nenvironmental variable containing paths to shared libraries or objects. The dynamic\nlinker will load the libraries in LD_PRELOAD before loading any other shared library\n(including libc). Malware developers can set LD_PRELOAD to point to malicious\nlibraries. Once a dynamically linked binary is executed on a compromised machine, it\n[will load the malicious library too. HiddenWasp is a malware that uses LD_PRELOAD](https://www.intezer.com/blog/linux/hiddenwasp-malware-targeting-linux-systems/)\nfor persistence.\n\nTo summarize this section, there are different startup locations which can be used as\npersistence methods for malware. However, the most commonly used methods are services\nand cron jobs.\n\n**Tip: A convenient way to check if a malware attempts to gain persistence is by analyzing**\nthe syscalls (strace output) and searching for known methods. For example, you can run\n**_cat strace_output.txt | grep cron to search for any interaction with the cron process._**\n\n## Network Sniffing\n\nSo far we covered how to monitor a file’s activity internally on the system. You can\nunderstand if a malware interacts with a C&C or external services by analyzing network[related syscalls such as socket and](https://man7.org/linux/man-pages/man2/socket.2.html) [connect. However, syscalls are not the way to go for](https://man7.org/linux/man-pages/man2/connect.2.html)\nnetwork monitoring. You should use a packet sniffing and network monitoring tool to\n[analyze the traffic. The most popular tools for this purpose are tcpdump and](https://www.tcpdump.org/) [Wireshark,](https://www.wireshark.org/)\nboth based on libpcap. tcpdump is a CLI tool that should be preinstalled on commonly used\nLinux distributions. Wireshark has similar functionalities to tcpdump and provides a\nconvenient GUI.\n\nTo install Wireshark on your VM run the following commands:\n\n\n-----\n\n**sudo add-apt-repository ppa:wireshark-dev/stable**\n**sudo apt install -y wireshark**\n**sudo wireshark**\n\n**Tip: Make sure to run Wireshark before running the file you are analyzing so that you won’t**\nmiss any packets related to the malware.\n\n## Sandboxes\n\nSandboxes can accelerate analysis by providing context about the file’s behavior on a\nmachine without the hassle of opening a VM, running the malware and relevant tools. They\nwill not always replace a hands-on, deep dive analysis of a VM, but sandboxes help you\npinpoint interesting behaviors while saving you time.\n\nHere are some relevant tools:\n\n## Real Life Example\n\n[Let’s practice your dynamic analysis skills! We will begin with initial analysis to gather](https://www.intezer.com/blog/linux/elf-malware-analysis-101-initial-analysis/)\ninsights and then proceed to dynamic analysis. Our mission is 1. Understand how the file\nbehaves and 2. See how dynamic analysis tools come in handy.\n\n[Our test sample? This ELF malware found in the wild.](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-3-Advanced-Analysis/Real-life-example/337674d6349c21d3c66a4245c82cb454fea1c4e9c9d6e3578634804793e3a6d6.sample)\n\n[A quick side note. Uploading this file to Intezer Analyze classifies it as Reekoobe, based on](https://analyze.intezer.com/files/337674d6349c21d3c66a4245c82cb454fea1c4e9c9d6e3578634804793e3a6d6)\ncode reused from previous Rekoobe samples. We will analyze the file manually for practice\nanyway.\n\n\n-----\n\n[Step one, download/copy the sample to your VM. Make sure:](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-3-Advanced-Analysis/Real-life-example/337674d6349c21d3c66a4245c82cb454fea1c4e9c9d6e3578634804793e3a6d6.sample)\n\n1. Your environment is prepared based on the Analysis Environment Preparation\n\nsection.\n2. You have a clean snapshot of your VM with the relevant tools. In this example we will\n\nbe using Wireshark and Sublime Text editor. Other tools should be preinstalled on the\nmachine.\n\nLet’s begin with static analysis and try to read the file’s symbols to see if there are any\nhuman readable function names. Run readelf -s sample. There is no output for the\ncommand, which means the file has been stripped.\n\nLet’s read the file’s program headers by running readelf -l sample. The following image\nshows the command’s output:\n\n\n-----\n\n_Figure 13: Sample’s program headers_\n\nWe can tell the file is statically linked because there is no dynamic symbols table or\ndynamic program header.\n\nLet’s run the strings command on the file. Because the file is statically linked you should\n[expect to see a large number of strings related to libc. Figure 14 is a snippet of the strings](https://linux.die.net/man/1/strings)\ncommands output:\n\n\n-----\n\n_Figure 14: Snippet from strings output_\n\nThe strings snippet is a big indicator that the file will attempt to create a service to gain\npersistence. “systemctl enable likemae” and other strings can help us understand that the\nservice name will be likemae. Another interesting string is c[.]linux-hosts[.]com which could\nbe the C&C.\n\n**Now that we have gathered enough information in the initial analysis step, let’s**\n**proceed to dynamic analysis.**\n\nFirst, prepare a running program of Wireshark and then run the sample with strace: sudo\n**strace -f -o out.txt ./sample. We will analyze this malware as if it ran with a privileged user**\nto see its full capabilities\n\n\n-----\n\nOpen the out.txt with a convenient text editor such as Sublime Text. The following snippet\nshows the beginning of the strace output:\n\n_Figure 15: Snippet from strace output_\n\nAnalyzing syscalls from the snippet, it’s clear that this malware checks for the existence of\nlikemae.service with the access syscall. The return value is -1 because the service doesn’t\nyet exist on the machine. The malware renames the file and locates it under\n**/usr/bin/likemae using the rename syscall. Next, using the open syscall, the malware**\ncreates likemae.service and writes to it.\n\nLet’s view the service’s full content:\n\n_Figure 16: likemae.service content_\n\nYou can also use grep to find interesting syscalls. Run cat out.txt | grep exe to see all\nexecutions created by the malware.\n\n\n-----\n\nThe malware made sure that the likemae service would run. Check that the service is\nindeed active on your machine by running systemctl | grep likemae.\n\n_Figure 17: likemae service is active_\n\nSo far, you know the malware created persistence on the machine using the service\ncreation method and copied itself to the /user/bin/likmae. You can also tell the process that\nwe ran has exited after establishing persistence. Let’s check if a process called likemae is\ncurrently running on our system. Run pstree -p | grep likemae (-p flag to retrieve the\nprocess ID).\n\n_Figure 18: likemae process is running with PID 15083_\n\nIf we run cat /proc/1503/cmdline, we will see that is /bin/bash. This is because the\nprocess was triggered by the service.\n\nNow that the service exists and the malware established persistence, you can expect the\nnew malware process to perform different actions on the system. Attach strace to the\nlikemaes’s PID by running strace -p 15083.\n\nAnalyzing syscalls we can understand that the process attempts to connect to the c[.]linuxhosts[.]com host and then sleeps for 30 seconds (see nanosleep syscall). The following\nsnippet shows the connection attempt loop. You can see the syscalls that are made in order\nto connect to the C&C.\n\n\n-----\n\n_Figure 19: Connection attempt loop_\n\nYou can view the network connection attempts in Wireshark as well.\n\n_Figure 20: Network connection attempts in Wireshark_\n\nIn Figure 20, you can see the host DNS resolution and the attempt to reach it via TCP. The\nTCP connection is not established, meaning the host doesn’t reply with a [SYN,ACK] packet\nbut rather a [RST,ACK] response is sent back. The port the malware attempts to connect to\non the C&C is closed.\n\n\n-----\n\nBecause the C&C is not reachable as expected, we have essentially come to a dead end\nwith the dynamic analysis step. You can still explore the domain for other open ports but we\nwill not dive into it further in this article. Nonetheless, you gained crucial insights on how the\nmalware operates once it runs, how to detect it on compromised systems, and how to clear\nthe malware from your system.\n\n**Tip: Some malware behave differently when they run as a privileged vs. an unprivileged**\nuser. The malware we have analyzed will not gain persistence if it runs as an unprivileged\nuser. It is recommended to run the file as both privileged and unprivileged users to\nunderstand the full spectrum of its capabilities.\n\n## Wrap-Up\n\nWe reviewed ELF dynamic analysis and detailed the different components and tools\nrelevant for this step. You learned how to gather insights about a file’s behavior using these\ntools. You also learned how insights gathered during initial analysis can help you focus on\ncertain components during dynamic analysis.\n\nThere are certain cases where you will hit a dead end during the dynamic analysis process.\nThe C&C could be down, the malware runs on a particular environment or time zone, and\nmore. Remember, the goal in dynamic analysis is to gather additional insights on how the\nmalware behaves. This will help you detect the malware on compromised systems, collect\nindicators related to the malware such as file names, C&C, persistent methods and more.\nThis can lead you to connect the malware to other tools, campaigns and/or threat actors.\n\nDynamic analysis should be done responsibly. The safety of your system and network\ntogether with other machines should be taken into consideration when analyzing malware\ndynamically.\n\n## What’s Next?\n\nNext up you will learn how to get payloads from packers and loaders by extracting memory\ndumps.\n\n## Appendix\n\nThese tools and commands were used or mentioned in this article:\n\n\n-----\n\n**Avigayil Mechtinger**\nAvigayil is a product manager at Intezer, leading Intezer Analyze product lifecycle. Prior to\nthis role, Avigayil was part of Intezer's research team and specialized in malware analysis\nand threat hunting. During her time at Intezer, she has uncovered and documented different\nmalware targeting both Linux and Windows platforms.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-17 - ELF Malware Analysis 101- Part 3 - Advanced Analysis.pdf"
    ],
    "report_names": [
        "2021-02-17 - ELF Malware Analysis 101- Part 3 - Advanced Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1f6ae238-765f-4495-9d54-6a7883d7a319",
            "created_at": "2022-10-25T16:07:24.573456Z",
            "updated_at": "2025-03-27T02:02:10.284644Z",
            "deleted_at": null,
            "main_name": "TA511",
            "aliases": [
                "MAN1",
                "Moskalvzapoe"
            ],
            "source_name": "ETDA:TA511",
            "tools": [
                "Agentemis",
                "Chanitor",
                "Cobalt Strike",
                "CobaltStrike",
                "Ficker Stealer",
                "Hancitor",
                "NetSupport",
                "NetSupport Manager",
                "NetSupport Manager RAT",
                "NetSupport RAT",
                "NetSupportManager RAT",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "542cf9d0-9c68-428c-aff8-81b6f59dc985",
            "created_at": "2023-02-15T02:01:49.554105Z",
            "updated_at": "2025-03-27T02:00:03.110991Z",
            "deleted_at": null,
            "main_name": "Moskalvzapoe",
            "aliases": [
                "MAN1",
                "TA511"
            ],
            "source_name": "MISPGALAXY:Moskalvzapoe",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535617,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653753114,
    "ts_modification_date": 1653753114,
    "files": {
        "pdf": "https://archive.orkl.eu/a8621f55d0056c799196bb6df4ba0273555b3d17.pdf",
        "text": "https://archive.orkl.eu/a8621f55d0056c799196bb6df4ba0273555b3d17.txt",
        "img": "https://archive.orkl.eu/a8621f55d0056c799196bb6df4ba0273555b3d17.jpg"
    }
}