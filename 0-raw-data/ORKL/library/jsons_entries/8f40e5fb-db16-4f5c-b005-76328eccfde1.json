{
    "id": "8f40e5fb-db16-4f5c-b005-76328eccfde1",
    "created_at": "2022-10-25T16:48:16.716993Z",
    "updated_at": "2025-03-27T02:13:12.179083Z",
    "deleted_at": null,
    "sha1_hash": "1e729f9e0fb15678179f162dc381853962074027",
    "title": "",
    "authors": "",
    "file_creation_date": "2012-09-19T11:42:17Z",
    "file_modification_date": "2012-09-19T07:20:39Z",
    "file_size": 2058767,
    "plain_text": "# OSX/Flashback\n\n### The first malware to infect hundreds of thousands of Apple Mac\n\n\n-----\n\n## OSX/Flashback\n\nThe Apple OS X operating system, like all operating systems, can become a\nvictim of malicious software. Before OSX/Flashback there had been a few\ndocumented cases of malware targeting OS X, but so far OSX/Flashback\nhas claimed the greatest number of victims. In this article we describe\nthe most interesting technical characteristics of this threat, particularly\nits method of spying on network communications and its algorithms for\ndynamically generating domain names. We also summarize the significant\ntimeline milestones of this malware whose life cycle has persisted over\nseveral months.\n\n\n#### Introduction\n\nFlashback is a threat on the OS X platform which was detected for the\nfirst time in the fall of 2011 [1]. After staying unnoticed for several months,\nFlashback attracted general attention in April 2012 by managing to\ninfect over 500,000 computers. How could the rate of infection have\nbeen so high? Are the techniques for obfuscating Flashback as complex\nas those we generally associate with Windows malware? What was the\nperpetrator’s intention?\n\nIn this article, we will first look at the method of propagation used\nby Flashback. Then we provide an analysis of two of the different\ncomponents of Flashback: the installation component and the library,\nwhich is used to intercept network traffic in order to spy on the user.\n\n\n-----\n\n## OSX/Flashback\n\n#### The Infection Vector\n\nThe method used to infect the victims of Flashback has evolved over\ntime. The first variants masqueraded as an update of Adobe Flash player.\nThe victim is directed to a malicious website, probably as the result of\nmalicious \"Search Engine Optimization\" (S.E.O) campaigns. The victim,\npersuaded that he has to perform a legitimate update, downloads and\nruns the offered file. By entering his password, as requested during the\ninstallation, the victim allows Flashback to proceed to self-install on his\nMac.\n\nThe second method of infection which has been identified, however, used\na Java-signed applet. By visiting a malicious website, the victim receives a\nmessage from the Java interpreter requesting permission to run an applet\n\n\nthat claims to be signed by Apple. Of course, the certificate did not come\nfrom Apple, it was self-signed. As a result of authorization given by the\nuser, the Mac is infected.\n\nThe method which has been by far the most effective at propagating\nFlashback infection was one thatxploits one of two flaws in Java: CVE2012-0507 or CVE-2011-3544. In this case, the vulnerabilities lead Flashback\nto an automatic installation without the knowledge or input of the user,\nsimply by visiting a website containing the malicious Java applet, either\ndirectly or via an Iframe. More than half a million Macs became infected in\nthis way.\n\nOver time, the methods of obfuscation of each component became more\ncomplex. The remainder of this analysis will be based on the latest variant\nof Flashback, the one that has infected the majority of computers by using\nthe flaw CVE-2011-0507\n\n\n-----\n\n## OSX/Flashback\n\n#### The Installation Package\n\nOnce the Java exploit is running successfully, a Mach-O executable\nfile is installed in the user's home directory. In order to remain hidden\nthe name of the file starts with a dot. A plist file (Property List File) is\ncreated in ~/Library/LaunchAgents to run the command each time\nthe user logs onto the infected computer. The sole purpose of this\nexecutable file is the downloading and installation of a web traffic\ninterception component.\n\n#### Obfuscation Techniques\n\nDynamic analysis of the installation package shows that when it is\nfirst run, the malware sends the Platform UUID from the infected\nsystem to the Command and Control (C&C) server over HTTP. The\nresponse to this first query is not actually acted upon by the malware.\nTherefore the URL is not the focus for automatic control. We believe\nthat it is only used by the operator of the malicious software for\ngathering statistical data.\n\nFollowing the first execution, we note that the executable file itself\nhas been modified. What difference might that make? Firstly, we\nnote that the URL used for statistics in the first command has been\nremoved from the executable file. In addition, a large part of the data\nsection has completely changed.\n\n\n-----\n\n## OSX/Flashback\n\nDespite the changes, the file remains a valid executable. Subsequent\nexecutions are identical to the first with one exception: there is no\nmore traffic to the URL as it has been deleted. It therefore seems we\nare facing self-encrypting malware.\nIn order to analyze the malicious encrypted files submitted by our\ncustomers or found on Internet, we had to first analyze the methods\nof encryption used byFlashback. First of all let's look at how the coded\nsection is used at the beginning of the execution.\n\n```\n v9 = IORegistryEntryFromPath(kIOMasterPortDefault_ptr,\n\"IOService:/\");\n v10 = *kCFAllocatorDefault_ptr;\n v11 = __CFStringMakeConstantString(\"IOPlatformUUID\");\n uuid_cfstr = IORegistryEntryCreateCFProperty(v9, v11, v10,\n0);\n if ( !uuid_cfstr )\n  return 0;\n IOObjectRelease(v9);\n uuid = g_uuid_ref;\n CFStringGetCString(uuid_cfstr, g_uuid_ref, 1024, 0);\n CFRelease(uuid_cfstr);\n strings_size = *g_strings_size_ptr;\n strings = (char *)malloc(*g_strings_size_ptr);\n if ( *stat_url )\n { // First execution, the g_string is not encrypted yet\n  memcpy(strings, g_strings, strings_size);\n\n```\n```\n }\n else\n { //  We need to decrypt the data  uuid_len =\nstrlen(uuid);\n  v14 = 0;\n  do\n  { // Initialisation of the RC4 table\n   rc4_table[v14] = v14;\n   ++v14;\n  }\n  while ( v14 != 256 );\n  v15 = rc4_table;\n  index = 0;\n  v17 = 0;\n  v213 = 0;\n  v214 = 0;\n  do\n  { // Creation of the RC4 table, using the platform UUID\nas a key\n   v18 = index++;\n   v19 = *v15;\n   v17 += (unsigned __int8)(uuid[(unsigned __int64)(v18 %\nuuid_len)] + *v15);\n   LODWORD(v18) = &rc4_table[(unsigned __int8)v17];\n   *v15++ = *(_BYTE *)v18;\n   *(_BYTE *)v18 = v19;\n  }\n\n```\n\n-----\n\n## OSX/Flashback\n\n```\n  while ( index != 256 );\n  LOWORD(index) = 0;\n  while ( index < (signed int)strings_size )\n  { // Decryption of the encrypted blob  \n   ++v213;\n   v20 = rc4_table[v213] + v214;\n   v21 = &rc4_table[v213];\n   v214 = v20;\n   v22 = &rc4_table[v20];\n   v23 = *v21;\n   *v21 = *v22;\n   *v22 = v23;\n   strings[index] = rc4_table[(unsigned __int8)(rc4_\ntable[v214] + rc4_table[v213])] ^ g_strings[index];\n   ++index;\n  }\n }\n\n```\n\nAs the Platform UUID is unique for each machine, the encrypted\nexecutable file cannot run on any Mac other than the one on which\nit was first run. As most of the submitted variants, plus those found\non the Internet, were encrypted, it was impossible to ascertain\ntheir contents without knowing the Platform UUID of the infected\nmachine.\n\nBut what might this encrypted part contain? Even after decryption\nwith RC4, we still do not have a clear character string or recognizable\ndata structure. Let's see how the block is used further. We will need to\ncontinue to monitor the execution to find calls to a function that finds\nstrings in the structure. Here are a few examples of these calls:\n\n\nIn the code above, we see that the malware acquires the Platform\nUUID from the computer. The Platform UUID of a Mac is a unique\nidentifier located on all Mac computers, a bit like a serial number or\nthe MAC address of a network card in that it should only be assigned to\none unique device. We note that if the command contains a URL, there\nwill be no decryption. Indeed, since this is its first execution, there has\nas yet been no encryption. We simply copy directly from memcpy. In\nthe case where there is no URL, the file has been modified. The author\nhas implemented the RC4 algorithm to decrypt the content using the\nPlatform UUID as the key.\n\n```\nget_string(&strings_struct, 0xD18Fu, 0xDC737201735473FAuLL,\n(char *)&v240, &v239);\nget_string(&strings_struct, 0xF12Eu, 0x4748FF63A8193474uLL,\n(char *)&v252, &v251);\nget_string(&strings_struct, 0xE002u, 0x836391EF93A94401uLL,\n(char *)&v250, &v249);\nget_string(&strings_struct, 0x6C8Au, 0x9183AACBE1931244uLL,\n(char *)&v248, &v247);\n...\n\n```\n\n-----\n\n## OSX/Flashback\n\nLet us examine the content of the function:\n\n```\nsigned int __cdecl get_string(strings_s *strings_struct,\nunsigned __int16 key, unsigned __int64 xor_key, char\n**decrypted, int *decrypted_size)\n{\n signed int v5; // eax@1\n signed int ret_value; // edx@1\n char *value; // esi@2\n int key_byte; // ecx@2\n int i; // ebx@2\n char xored_value; // dl@3\n\n```\nv5 = find_string(strings_struct, key, decrypted, decrypted_\n```\nsize);\n ret_value = 5;\n if ( v5 != 5 )\n {\n  value = *decrypted;\n  key_byte = 0;\n  for ( i = 0; i < *decrypted_size; ++i )\n  {\n   xored_value = *((_BYTE *)&xor_key + key_byte++) ^\nvalue[i];\n   value[i] = xored_value;\n   if ( key_byte == 8 )\n    key_byte = 0;\n  }\n\n```\n```\n  ret_value = 0;\n }\n return ret_value;\n}\n\n```\n\nget_string which takes 5 perimeters.\n\n1. strings_struct: A structure that contains a pointer towards\nour data\n2. key: The value key to find in the data\n3. xor_key: The XOR key to be used to decrypt the content\n4. decrypted: As output, will contain a pointer to the decrypted\nvalue in the dictionary\n5. decrypted_length: As output, will contain the length of the string\n\nget_string finds the string in the dictionary from the key with\nfind_string, and then applies the given key XOR to all 64-bit blocks.\nIf we analyze find_string, we find the structure of a dictionary in the\nmemory. The following table shows the structure representing this\ndictionary.\n\n\n-----\n\n## OSX/Flashback\n\n**Magic Number** 1 byte (0xFD)\n\n**Key 1 (k1)** 2 bytes\n\n**Length 1 (l1)** 4 bytes\n\n**Value 1 (v1)** l1 bytes\n\n**Magic Number** 1 byte (0xFD)\n\n**Key 2 (k2)** 2 bytes\n\n**Length 2 (l2)** 4 bytes\n\n**Value 2 (v2)** l2 bytes\n\nFortunately, the data and their XOR keys are the same from one\nvariant to another, which makes it easier to decrypt the different\nvariants, statistically-speaking. The encrypted part therefore must\ncontain a dictionary of keys and values which are used by the\ninstallation package.\n\nFrom here, we are beginning to see the clear strings, but most are\nstill obfuscated. A last pass of decryption reveals their final value. The\nalgorithm that is used in the latter decryption does not seem to be a\nknown algorithm. In short, a deterministic pseudo random list of 216\nbytes is generated. Each word of 2 bytes in the string is equivalent to\nthe index of the desired octet in the list.\n\nOnce all these steps are accomplished, there are several lists separated\nby \"|\". Here is the final result of our decryption.\n\n\n$ python extract_dropper_config.py sbm\n```\nFilename : sbm\nMD5 : 473426b7be5335816c545036cc724021\nSHA1 : 94e4b5112e750c7902968d97237618f5b61efeb2\n0x0fa7 : Public Key Exponent : 65537\n0xd18f : Public Key Modulus : 55ead1182a...81be12abef (2048\nbits)\n0x6192 : 0xdedbe511, 0x1f2e4872, 0x237345de\n0x1f91 :\n [00] .com\n ...\n [04] .kz\n0x4280 :\n [00] ##begin##\n [01] ##sign##\n [02] ##end##\n [03] /index.html\n [04] Mozilla/5.0 (Windows NT 6.1; WOW64; rv:9.0.1; sv:%s;\nid:%s) Gecko/20100101 Firefox/9.0.1\n [05] nohup \"%s\" 1>&2 &>/dev/null &\n [06] /tmp/\n0x6c8a :\n [00] 4\n [01] sysctl.proc_cputype\n0x92be :\n [00] pioqzqzsthpcva.net\n [01] lpjwscxnwpqkaq.com\n\n```\n\n-----\n\n## OSX/Flashback\n\n```\n …\n [23] kkkgmnbgzrajkk.com\n [24] ahvpufwqnqcad.com\n0x92fa :\n [00] /Library/Little Snitch\n [01] /Developer/Applications/Xcode.app/Contents/MacOS/\nXcode\n …\n [06] /Applications/HTTPScoop.app\n [07] /Applications/Packet Peeper.app\n0xe002 :\n [00] _NSGetExecutablePath\n [01] CFStringCreateWithCString\n …\n [30] BN_bin2bn\n [31] RSA_new\n0xf12e :\n [00] /System/Library/Frameworks/IOKit.framework/\nVersions/A/IOKit\n …\n [05] /usr/lib/libcrypto.dylib\n\n```\n\nIIn the key 0x92fa, we see a list of paths to anti-virus software, firewall\nsoftware or software intended for the use of experienced users. If one of\nthese files exists on the infected system, the execution will end and the\nmalware will uninstall itself from the system.\n\n\nWe also find the names of libraries and functions to keys 0xf12e and\n0xe002. These will be loaded dynamically with dlopen and dlsym. Knowing\nnow the functions that are called, we understand better the behavior of\nthe malware.\n\n#### Behavior\n\nPeriodically, the malicious software polls a list of domains from which it\ncan download and run a file. The fields are derived from three separate\nsources:\n\n1. A domain list is hard-coded in the installation package (with the key\n0x92be);\n\n2. 5 prefixes of domains are dynamically generated from constants found\nin the installation package (the three constants to the key 0x6192);\n\n3. Another domain prefix is generated dynamically based on the date.\n\nFor each of the domain prefixes generated dynamically at point 2 and 3,\nthe suffixes which will be added to each are in the key 0x1f91. In all variants\nwe have analyzed, the same 5 top-level domains were contained. The\nprefixes in point 2 are pseudo-random strings of 11 to 13 letters. They differ\naccording to the variant. The prefix in point 3 is also a pseudo-random\nstring but is unique according to the current date and is the same for all\nvariants. The 5 suffixes will also be appended to the daily prefix.\n\nBy excluding the domains auto-generated based on the day at point 3,\nwe have identified 185 domains from all the variants at our disposal.\n\n\n-----\n\n## OSX/Flashback\n\nOne of the peculiarities of the installation component of Flashback is that\nthe author had not previously registered all possible domains, perhaps\nbecause there were too many to register on a daily basis. In addition, the\nalgorithm used to generate domain names for the day is the same for all\nFlashback variants.\n\nIn the course of reverse engineering of the domain name generation\nalgorithm, several companies including DrWeb, ESET, Kaspersky and\nSymantec were able to register the domain names readily available and\nput sinkholes into operation, allowing these organizations to estimate the\nnumber of infected systems.\n\nOnce the malware establishes a connection with one of the domains, the\nsoftware attempts to perform an HTTP GETcommand. It expects to have a\nresponse with the format.\n\n```\n##begin##\n<base64 encoded executable>\n##sign##\n<base64 encoded signature>\n##end##\n\n```\n\nYou have probably noticed the presence of a public key in the strings above\nat the keys 0xd18f and 0x0fa7. This key will be used to verify the signature\nof the downloaded file.\n\nThe only thing that we have seen being downloaded by the installation\ncomponent is a network traffic interception component. The next section\n\n\n#### Web Interception Component\n\nOur analysis indicates that the primary purpose of the installation\ncomponent is to insert a second module for intercepting HTTP and\nHTTPS communications. This interception allows the injection of ads\ninto the HTTP and HTTPS streams which are then displayed to the\nuser of the infected system. This new module is independent of the\ninstallation component that we have seen previously. In this section,\nwe will show the features of HTTP interception used by Flashback.\n\n#### The Library\n\nThe interception component does not take the form of an executable,\nbut that of a library, which raises a good question: how come the code\ninside happens to be running? The component of Mac OS X which is\nin charge of dynamically loading the libraries is called dyld. Normally,\nthe paths to libraries, needed for a program to run, are in its Mach-O\nheader, and dyld is in charge of loading them at runtime. The manual\npage of dyld [6] shows various environment variables to configure\ndyld. In order to be loaded, Flashback uses DYLD_INSERT_LIBRARY\nwhich allows you to load a library before those that are specified in\nthe program to be run. To change this environmental variable in a\npersistent manner, Flashback uses 2 techniques.\n\n1. If it has administrator privileges, Flashback will change the meta\ndata of the browsers installed to assign the environmental variable\nbefore running. This is made possible by adding it into the key\nLSEnvironment of the Info.plist inside an application.\n2. If it does not have administrator privileges, Flashback will add i\n\n\n-----\n\n## OSX/Flashback\n\ncreation of one if it does not exist (as is usually the case). When the\nuser logs in, the variable will be affected; therefore the library will be\nloaded in all applications which will be started by that user.\n\nFor users infected by the Java exploit, it is the second method which is\nused because the applet does not have the administrator’s privileges.\n\n#### Flashback Intervenes\n\nThe library contains a section “ __interpose”which allows replacing a\nfunction provided by another loaded library [5]. With DYLD_INSERT_\nLIBRARY, therefore, it is possible to stand between the caller and\nthe original function. The result is similar to the use of LD_PRELOAD\nunder Linux.\n\nFlashback interposes 2 functions: CFReadStreamRead\nand CFWriteStreamWrite. These two functions are part of\nCoreFoundation, the C programming language API in Mac OS X.\nAs indicated by their names, these functions are used for sending\nand receiving data on a stream. Unless using directly the low-level\nfunctions send and recv, all network communications in Mac OS X will\ngo through these functions.\n\nIt is interesting to know that it is possible to create a CFStream\nencrypted in SSL by using the functionalities of CoreFoundation. This\nmeans that the interposition of Flashback allows intercepting the\nHTTPS data in their decrypted state.\n\n\n#### Configuration\n\nWhen one opens the library in a disassembler, we notice a large\nstring of Base64 encoded characters. Even decoded, the result is\nunfortunately not intelligible. We have no choice but to find how it is\ndecoded in order to access its contents. The next section of the library\nshows the routine that takes care of the decoding.\n\n```\nstd::allocator<char>::allocator(&v29);\n\n```\nstd::string::string(&base64_config, (const char *)base64_\n\nconfig_ref + 5, &v29);\n\nbase64_decode(&crypted_config, &base64_config);\n\nstd::string::_string(&base64_config);\n```\nstd::allocator<char>::_allocator(&v29);\n\n```\nrc4_crypt(&v10, &a2->uuid, &crypted_config);\n```\nstd::allocator<char>::allocator(&v30);\nstd::string::string(&static_rc4_key, g_rc4_key, g_rc4_key_\nsize, &v30);\nrc4_crypt(&v20, &static_rc4_key, &v10);\n\n```\nuncompress_h(&plain_text_config, (const Bytef **)&v20);\n\n\n-----\n\n## OSX/Flashback\n\nFirstly we see the classical decrypted Base64 encoded form, shifted\nby 5 bytes further. “cfinh”is used as a marker, it is found in all variants.\nThen, there is decryption with RC4 using Platform UUID as key, and\nfinally decryption with RC4 by using this time a 16 characters key\nhard-coded in the binary. In conclusion, the uncompress function is\ncalled to decompress the decrypted data. Once again, we note that\nan interesting part of Flashback is encrypted with the Platform UUID,\nwhich makes the analysis very difficult if the reverse engineer does\nnot have this information.\n\nOnce decoded, the string of character represents a dictionary\ncomposed of several elements.\n\n```\nMWU5MWNiNjJjZDVlYTMwN2E5OWYxZGYzMDU2MmE5NmRiOTUzMTYyNg==|OKOnEr\n8jeQuUW[...]mlBW2M=\n\n```\n\ncontrol servers as well as a large list of domains where it can be\nupdated. By analyzing all of our samples, we counted a total of 276\ndomain names. As for the installation component, the author has\nregistered only a few of these domains.\n\n#### Validation of the Command and Control Server\n\nThe first thing that is found in the network trace is an HTTP GET towards /\nscheck. Here is the format of the answer:\n\n```\n...{2588545561:3:OTk5},{201539444:3:aHR0cDovLw==},\n{3604130400:3:U2FmYXJ8V2ViUHJv}...\n\n```\n\nFor each element of the key, you have the type and the value\nrespectively. We note that for types other than an integer (type 1) the\nvalue is encoded in Base64.\n\nThis configuration is really the key to our analysis because it\nrepresents the configuration of Flashback: it contains, among other,\nthe addresses of the command and control servers and a list of\ndomain names used for auto-updating.\n\nA peculiarity of Flashback is its long list of domains contained in\nthe configuration. There are several domains for the command and\n\n\nThe decoding of Base64 gives nothing interesting. No ASCII, no\ncompressed file, nothing that we know. The second part is of 512\noctets. We will need to see inside the code to be able to find the use of\nthe OpenSSL connected to this query.\n\n\nv9 = get_item_at_index(&v20, 0); // The first part, before\n```\nthe pipe (|)\nstd::string::string(&a2, v9);\nbase64_decode(&hex_digest, &a2);\nstd::string::_string(&a2);\nv10 = get_item_at_index(&v20, 1); // The second part, after\nthe pipe (|)\n\n```\n\n-----\n\n## OSX/Flashback\n\n```\nstd::string::string(&v25, v10);\nbase64_decode(&signature, &v25);\nstd::string::_string(&v25);\nif ( verify_signature_with_rsa(system_info->rsa, &hex_\ndigest, &signature) )\n{\n cnc_hostname = get_item_at_index(&cnc_list, cnc_index);\n sha1_hexdigest(&cnc_hostname_hash, cnc_hostname);\n v12 = std::string::compare(&cnc_hostname_hash, &hex_\ndigest, v15);\n std::string::_string(&cnc_hostname_hash);\n if ( !v12 )\n {\n  valid_cnc = get_item_at_index(&v19, cnc_index);\n  if ( !system_info )\n   system_info = create_system_info();\n  set_cnc(system_info, valid_cnc);\n\n```\n\nIn the list of the command and control center, several domains had\nnot been registered by the author. This check at startup has been\nimplemented to avoid a third party taking control and sending\ncommands to the infected Macs.\n\n#### Interception\n\nAt the interception of data, Flashback determines whether it is a\nHTTP GET request by looking at the beginning of the data sent to\nCFWriteStream. When it comes to a search query sent to Google, the\nsearch keywords as well as information on the machine such as the\nPlatform UUID and the language configured are sent to the command\nand control server. The latter responds to the next action to execute\nby taking good care of encrypting it by using RC4 with the MD5 hash\nof the Platform UUID as the key. The query to Google is unchanged;\nhowever the answer may be altered to simulate a click on an ad.\n\nHere is an example of a valid response from the command and control\nserver:\n\n\nWe first look to see if the signature (the second part of the answer)\nis valid for the payload (the first part) with a 2048 bits RSA key hardcoded in the library. verify_signature_with_rsa uses RSA_verify from\nOpenSSL. Then we check that the payload is the SHA-1 digest of the\ncommand and control server address.. We can verify that it is the case\nhere.\n\n```\n__cstring:0002236A aBidfail db 'BIDFAIL',0 ; DATA XREF:\nsub_13522+78Eo\n__cstring:00022372 aH_setup db 'H_SETUP',0 ; DATA XREF:\nsub_13522+7BAo\n__cstring:0002237A aAdd_s db 'ADD_S',0   ; DATA XREF:\nsub_13522+889o\n\n```\n```\n__cstring:00022364 aBidok  db 'BIDOK',0 ; DATA XREF:\nsub_13522+6D7o\n\n```\n```\nbase64(sha1('95.154.246.120') in hex)=> MWU5MWNiNjJjZDVlYTMw\nN2E5OWYxZGYzMDU2MmE5NmRiOTUzMTYyNg==\n\n```\n\n-----\n\n## OSX/Flashback\n\n```\nsub_13522+8EDo\n__cstring:00022383 aSk  db 'SK',0    ; DATA XREF:\nsub_13522+951o\n\n```\n\nDuring our experiments, we only observed the use of two commands:\nBIDOK and BIDFAIL. The other commands, which are used to add\nservers in its list (ADD_S) or even to auto-destroy (SK), have not been\nviewed in our traffic captures.\n\n#### Use of Twitter as Mechanism to Command and Control\n\nIn the configuration we can find an URL to search for a hashtag on\nTwitter. What is its purpose? If we look at how it is used, we find\nanother technique available to the botmaster to manage his or her\nBotnet.\n\n```\nTrident/3.1; IEMobile/7.0; HTC; 7 Mozart T8698)\nbase64_decode_string(&random_user_agent, &v16);\nstd::string::_string(&v17);\n\n```\nget_config_string(&v18, &twitter_config, 0x37CF19CAu);// 442\n```\nuser_agent_count = string_to_integer(&v18);\nstd::string::_string(&v19);\nif ( user_agent_count > 1 )\n{\n random_int = rand();\n\n```\nget_config_string(&user_agent_b64, &twitter_config, random_\n```\nint % user_agent_count + 0xAEEE0000);\n base64_decode_string(&v27, &user_agent_b64);// 0xAEEE0000\nto 0xAEEE01B9 contains User Agent string of several mobile\ndevices\n std::string::assign(&random_user_agent, &v27);\n std::string::_string(&v27);\n std::string::_string(&v21);\n}\nmake_http_request(&v29, &twitter_url, &random_user_\n\n```\nagent);get_config_string(&v22, &twitter_config, 0x9FC4EBA3u);//\n```\nbumpbegin\nbase64_decode_string(&v28, &v22);\nstd::string::_string(&v23);\n\n```\nget_config_string(&v12, &twitter_config, 0xEAC11340u);//\n```\nendbump\n\n```\n```\ngenerate_string_for_day(&generated_string_for_day, user_\nagent, day, month, year);\n\n```\nget_config_string(&v14, &twitter_config, 0xE21C0275u);//\n```\nhttp://mobile.twitter.com/searches?q=%23\nbase64_decode_string(&v26, &v14);\nstring_concat(&twitter_url, &v26, &generated_string_for_\nday);\nstd::string::_string(&v26);std::string::_string(&v15);\n\n```\nget_config_string(&v16, &twitter_config, 0xEE3A469Du);//\n```\nMozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0;\n\n```\n\n-----\n\n## OSX/Flashback\n\n```\nbase64_decode_string(&v32, &v12);\nstd::string::_string(&v13);\n\n```\nv7 = std::string::find(&v29, &v28);\n\nv8 = std::string::find(&v29, &v32);\n\n\nA different hash-tag is generated each day. A search for this hashtag\non Twitter reveals the IP address or the domain name of the new\ncommand and control server to use. In the tweet, we find the\ninformation between the delimiters « beginbump » and « endbump »\n(these delimiters are also part of the configuration).\n\ngenerate_string_for_day concatenates 3 character strings from a list\nin the configuration. If, for example, in the configuration are found\n\n\n#### Dynamically Generated Domains\n\nDuring our analysis, we have seen another interesting element in our\nnetwork trace. Flashback was trying to resolve domain names that\nbegan with the hashtag of the day. We found in the configuration a\nlist of suffixes to be applied to the generated string, as in the case of\nthe installation component.\n\n```\n1 : abcd\n2 : efgh\n3 : ijkl\n\n```\n```\nKey : 0xb78140d6\nValue : .org|.com|.co.uk|.cn|.in\n\n```\n\nthe hashtag for February 2, 2003 will be #efghabcdijkl (the month of\nJanuary being 0). We have listed 6 different lists of strings in various\nvariants analyzed.\n\nWe have no trace of the tweet of the malefactor. Probably they would\nhave already been deleted if he had really used them. However, we\nfound that someone who seems to work for an antivirus company has\ntried to bring in traffic to their sinkhole by tweeting its address with\nthe correct hashtag.\n\n```\nKey : 0xb78140d6\nValue : .org|.com|.co.uk|.cn|.in|.PassingGas.net|.\nMyRedirect.us|.rr.nu|.Kwik.To|.myfw.us|.OnTheWeb.nu|.\nIsTheBe.st|.Kwik.To|.ByInter.net|FindHere.org|.OnTheNetAs.\ncom|.UglyAs.com|.AsSexyAs.com|.PassAs.us|.PassingGas.\nnet|.AtHisSite.com|.AtHerSite.com|.IsGre.at|.Lookin.At|.\nBestDeals.At|.LowestPrices.At\n\n```\n\nAnd in an older variant:\n\n\n-----\n\n## OSX/Flashback\n\nThese domains will be used, after the list in the configuration, in order\nto auto-update. The updates are also signed, therefore, it is difficult\nfor a third party without the private key to register the domain name\nof the day and spread its own code.\n\n#### Mass Decryption of Samples\n\nStarting in the beginning of April, ESET was able to register domain\nnames used by the installation component of Flashback. The malware\nfacilitates things in one respect: it sends the Platform UUID of the\nmachine on which it has been installed in the User-Agent field of the\nHTTP header. So it is therefore possible for us to count in a sufficiently\nprecise manner the number of infected machines since Platform UUID\nidentifies each Mac in a unique way.\n\nWe had in our possession several samples of Flashback, but we had\na major problem: we were not able to determine the Platform UUID\nof the infected computer. With our sinkhole in place, the chances\nthat the infected computer communicated with the latter were high.\nThanks to this tool, we were able to gather around 600,000 Platform\nUUID. From this moment, it was possible to use this list to brute force\nthe decryption of the samples for the installation component as well\nas the component of interception.\n\n\n#### Chronology of Events\n\nSeptember 2011: Emergence of the first variant\n\nFebruary 2012: Oracle makes available an update for Java which\ncorrects a flaw exploited by Flashback [7]\n\nMarch 2012: Rapid Spread via the feat Java\n\nEnd of March 2012: First Sinkholes to be recorded by different\nanti-virus companies\n\nApril 3, 2012: Apple makes available the Java update with the corrected\nflaw\n\nApril 4, 2012: First statistics on sinkholes (DrWeb)\n\nApril 6, 2012: Apple publish a second update for Java\n\nApril 13, 2012: Apple publishes a tool to clean Flashback [8]\n\nMay 1, 2012: The control centers did not answer any more\n\n\n-----\n\n## OSX/Flashback\n\n#### Conclusion\n\nSome Mac users believe themselves to be immune to malicious\nsoftware because they are using OS X. Certainly, the malware threats\nto OS X are less numerous than to Windows, but they are not nonexistent. Flashback is an example of large-scale attack against the\nOS X platform. There are also more targeted attacks as in the case\nof Lamadai [3] and MacControl [4] who attacked the Tibetan nongovernmental organizations.\n\nThe version of Java installed with Mac OS X cannot be updated by\nOracle. Apple must validate and distribute updates via its updating\nsystem, leading some to wonder if Apple was too slow to publish\nthe Java update that fixed the flaw exploited by Flashback. A two\nmonth wait for an update that corrects a security vulnerability whose\noperating technique is available on the Internet, creates a sizeable\nwindow for damage to be done.\n\nSince Mac OS X Lion (10.7), Apple no longer installs Java interpreters by\ndefault on its operating system, a move that can be seen as reducing\navenues of attack. This might also be interpreted as an attempt to\navoid the burden of updating software that is beyond its control.\n\nAfter the appearance of Flashback in the media, Apple reacted very\nquickly. First, they registered all the names of the available domains\nconnected to Flashback, including those generated dynamically.\nShortly after that, Apple created an update to OS X that detected the\n\n\npresence of Flashback and uninstalled it from the system. However,\nApple was relatively low key in its strategy (the presence of Flashback\nin the media was hardly a good advertisement for Apple).\n\nThere are many questions left unanswered: Who are the authors\nof Flashback? Had they expected to have a high infection rate and\nto be this much publicized? Did they simply give up? Flashback has\ndemonstrated that OS X is not immune to a large scale infection, the\nauthors of malicious software might become more interested in OS\nX as a means to deploy their malware. Mac users should therefore be\nvigiland and adopt safe computing practices.\n\n_Thanks to Pierre-Marc Bureau and Alexis Dorais-Joncas for their proofreading_\n_and corrections._\n\n_Marc-Etienne M.Léveillé, leveille@eset.com, @marc_etienne__\n\n\n-----\n\n## OSX/Flashback\n\n#### Analyzed Files\n\nNom MD5 SHA1\n\nsbm 473426b7be5335816c545036cc724021 94e4b5112e750c7902968d 97237618f5b61efeb2\n\nfb_10.so 0de5cb4d61a09d4615f17f1 eb85783a9 7a5e75b563c87320977e47dc220b ea5782e9ce92\n\n\n#### Reference\n\n[1] http://go.eset.com/us/threat-center/threatsense-updates/\npage/11/?q=flashback\n\n[2] http://blog.eset.com/2012/04/13/fighting-the-osxflashback-hydra\n\n[3] http://blog.eset.com/2012/03/28/osxlamadai-a-the-mac-payload\n\n[4] http://blog.eset.com/2012/04/25/osx-lamadai-flashback-isnt-theonly-mac-threat\n\n[5] http://www.opensource.apple.com/source/dyld/dyld-195.6/include/\nmach-o/dyld-interposing.h\n\n[6] https://developer.apple.com/library/mac/#documentation/Darwin/\nReference/Manpages/man1/dyld.1.html\n\n[7] http://www.oracle.com/technetwork/topics/security/\njavacpufeb2012-366318.html\n\n[8] http://support.apple.com/kb/DL1517\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.welivesecurity.com/wp-content/uploads/200x/white-papers/osx_flashback.pdf",
        "https://web-assets.esetstatic.com/wls/200x/white-papers/osx_flashback.pdf"
    ],
    "report_names": [
        "osx_flashback.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1f6ae238-765f-4495-9d54-6a7883d7a319",
            "created_at": "2022-10-25T16:07:24.573456Z",
            "updated_at": "2025-03-27T02:02:10.284644Z",
            "deleted_at": null,
            "main_name": "TA511",
            "aliases": [
                "MAN1",
                "Moskalvzapoe"
            ],
            "source_name": "ETDA:TA511",
            "tools": [
                "Agentemis",
                "Chanitor",
                "Cobalt Strike",
                "CobaltStrike",
                "Ficker Stealer",
                "Hancitor",
                "NetSupport",
                "NetSupport Manager",
                "NetSupport Manager RAT",
                "NetSupport RAT",
                "NetSupportManager RAT",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "542cf9d0-9c68-428c-aff8-81b6f59dc985",
            "created_at": "2023-02-15T02:01:49.554105Z",
            "updated_at": "2025-03-27T02:00:03.110991Z",
            "deleted_at": null,
            "main_name": "Moskalvzapoe",
            "aliases": [
                "MAN1",
                "TA511"
            ],
            "source_name": "MISPGALAXY:Moskalvzapoe",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041592,
    "ts_creation_date": 1348054937,
    "ts_modification_date": 1348039239,
    "files": {
        "pdf": "https://archive.orkl.eu/1e729f9e0fb15678179f162dc381853962074027.pdf",
        "text": "https://archive.orkl.eu/1e729f9e0fb15678179f162dc381853962074027.txt",
        "img": "https://archive.orkl.eu/1e729f9e0fb15678179f162dc381853962074027.jpg"
    }
}