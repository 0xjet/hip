{
    "id": "10524cc8-bf09-47e5-bcc7-0f9e5ec1c061",
    "created_at": "2023-01-12T15:07:04.974014Z",
    "updated_at": "2025-03-27T02:09:29.515692Z",
    "deleted_at": null,
    "sha1_hash": "4419f18e18bba21ee99002a9da301d621ed54658",
    "title": "2020-03-21 - On the Royal Road",
    "authors": "",
    "file_creation_date": "2022-05-28T04:04:52Z",
    "file_modification_date": "2022-05-28T04:04:52Z",
    "file_size": 187082,
    "plain_text": "# MalwareLab.pl Research Notes\n\n**blog.malwarelab.pl/posts/on_the_royal_road/**\n\n## On the Royal Road\n\n Intro\n\n\nMarch 21, 2020\n\n\nRoyal Road or 8.t is one of the most known RTF weaponizer, its used and shared mostly\namongst Chinese speaking actors - there are also couple very good publications including\none form [nao_sec,](https://nao-sec.org/2020/01/an-overhead-view-of-the-royal-road.html) [Sebdraven and](https://medium.com/@Sebdraven) [Anomali. It was on my todo list for some time, and thanks](https://www.anomali.com/blog/analyzing-digital-quartermasters-in-asia-do-chinese-and-indian-apts-have-a-shared-supply-chain)\nto recent [twitter discussion as well as quarantine time i finally took a deeper look at it. We’ll](https://twitter.com/Sebdraven/status/1239853425594155008)\ngo into how to quickly analyze RTF maldocs, quickly tear-down shellcode used and finally\nhow to extract embedded payload.\n\n## Getting shellcode\n\nDocument that will be used as an example caused a discussion on twitter regarding actor\nbehind this attack due to some code overlap of a dropped payload. We wont talk about this\npart tho, aforementioned document has a sha256\n**1527f7b9bdea7752f72ffcd8b0a97e9f05092fed2cb9909a463e5775e12bd2d6 and in order**\nto lures victim it exploits current pandemic situation having a title President discusses\n**budget savings due to coronavirus with Finance Minister.rtf**\n\nLike with most documents, you can relay on oletools to help you with dissecting rtfs, rtfobj\ndoes a great job extracting both shellcode and encoded payload.\n\n\n-----\n\n```\nFile: /tmp/5e31d16d6bf35ea117d6d2c4d42ea879.bin  size: 574379 bytes\n---+----------+--------------------------------------------------------------id |index   |OLE Object                           \n---+----------+--------------------------------------------------------------0 |0000CAE6h |format_id: 2 (Embedded)                    \n  |     |class name: 'Package'                     \n  |     |data size: 254164                       \n  |     |OLE Package object:                      \n  |     |Filename: u'wd32PrvSE.wmf'                   \n  |     |Source path: u'C:\\\\Windows\\\\wd32PrvSE.wmf'           \n  |     |Temp path = u'C:\\\\Windows\\\\wd32PrvSE.wmf'           \n  |     |MD5 = 'b33dabc3e9e653ce14fdc5323cec12f8'            \n---+----------+--------------------------------------------------------------1 |00088D1Eh |format_id: 2 (Embedded)                    \n  |     |class name: 'Equation.2\\x00\\x124Vx\\x90\\x124VxvT2'       \n  |     |data size: 6436                        \n  |     |MD5 = '865ea38d8074829351a66826ebab2fe9'            \n---+----------+--------------------------------------------------------------2 |00088D04h |Not a well-formed OLE object                  \n---+----------+--------------------------------------------------------------Saving file embedded in OLE object #0:\n format_id = 2\n class name = 'Equation.2\\x00\\x124Vx\\x90\\x124VxvT2'\n data size = 6436\n saving to file /tmp/5e31d16d6bf35ea117d6d2c4d42ea879.bin_object_00088D1E.bin\n md5 865ea38d8074829351a66826ebab2fe9\n\n## Shellcode stub\n\n```\nFrom output above we can assume that document attempts to exploit a bug in Equation\nEditor so object number 1 will most likely contain a shellcode and will be a target of our\nanalysis. Let’s throw it in our favorite disassembler. Unfortunately IDA doesn’t reveal any\ncode which hints us that somewhere there there is a decoding stub, responsible for decoding\nactual shellcode. Indeed we can find one at offset `6Ah`\n\n\n-----\n\n```\nseg000:0000006A E8 FF FF FF FF             call  near ptr loc_6A+4\nseg000:0000006F C3                   retn\nseg000:00000070             ; -------------------------------------------------------------------------seg000:00000070 5F                   pop   edi\nseg000:00000071 83 C7 1A                add   edi, 1Ah\nseg000:00000074 33 C9                  xor   ecx, ecx\nseg000:00000076 66 B9 A5 0B               mov   cx, 0BA5h\nseg000:0000007A\nseg000:0000007A             loc_7A:                 ;\nCODE XREF: seg000:00000087↓j\nseg000:0000007A 66 83 3F 00               cmp   word ptr [edi], 0\nseg000:0000007E 74 05                  jz   short loc_85\nseg000:00000080 66 81 37 C3 90             xor   word ptr [edi], 90C3h\nseg000:00000085\nseg000:00000085             loc_85:                 ;\nCODE XREF: seg000:0000007E↑j\nseg000:00000085 47                   inc   edi\nseg000:00000086 47                   inc   edi\nseg000:00000087 E2 F1                  loop  loc_7A\n\n```\nWhen analyzing shellcodes used in Equation Editor exploits i prefer to look for a bytes\nindicating jumps or calls instead of parsing structure of a file, this yields quicker results and\nallows to throw out garbage bytes like here at the begin of a file. Anyhow here we have a\ntypical jump-into-instruction and short xoring loop. Nothing that can’t be solved with a bit of\nscripting. To make it more fun, will make it a generic\n```\ndef decode_first_stage():\n  pat = \"C3 5F 83 C7 ? 33 C9 66 B9 ? ? 66 83 3F ? 74 ?? 66 81 37 ? ? 47 47 E2 ?\"\n  off = FindBinary(idaapi.get_imagebase(), idaapi.SEARCH_DOWN,pat)\n  size = ida_bytes.get_word(off+9)\n  key = ida_bytes.get_word(off + 20)\n  ea = off + ida_bytes.get_byte(off + 4)\n  for i in range(size):\n    if ida_bytes.get_word(ea):\n      patch_word(ea,ida_bytes.get_word(ea) ^ key)\n    ea += 2\n\n```\nThis will take care of our problem. It is also worth noticing that this stub is pretty uncommon\ndue to comparison to zero at `7Ah which makes it pretty good candidate for YARA signature!`\nsomething like that should do the trick.\n\n\n-----\n\n```\nrule royal_road_dec_loop : RoyalRoad\n{\n meta:\n  author = \"mak\"\n  hash = \"1527f7b9bdea7752f72ffcd8b0a97e9f05092fed2cb9909a463e5775e12bd2d6\"\n  hash = \"3e216e2b0320201082b81ebc3a35b65a242ff260f2d7f8e441970ac5262b3a71\"\n  description = \"matches a shellcode stub in binary and rtf document\"\n /*\n 0x70L 5F              pop edi\n 0x71L 83C71A            add edi, 0x1a\n 0x74L 33C9             xor ecx, ecx\n 0x76L 66B9A50B           mov cx, 0xba5\n 0x7aL 66833F00           cmp word ptr [edi], 0\n 0x7eL 7405             je 0x85\n 0x80L 668137C390          xor word ptr [edi], 0x90c3\n 0x85L 47              inc edi\n 0x86L 47              inc edi\n 0x87L E2F1             loop 0x7a\n  */\n strings:\n  $chunk_1 = { 5F 83 C7 ?? 33 C9 66 B9 ?? ?? 66 83 3F ?? 74 ?? 66 81 37 ?? ?? 47 47\nE2 }\n  $enc_chunk = { 35 46 38 33 43 37 ?? ?? 33 33 43 39 36 36 42 39 ?? ?? ?? ?? 36 36\n38 33 33 46 ?? ?? 37 34 ?? ?? 36 36 38 31 33 37 ?? ?? ?? ?? 34 37 34 37 45 32 }\n  $enc_chunk1 = { 35 66 38 33 63 37 ?? ?? 33 33 63 39 36 36 62 39 ?? ?? ?? ?? 36 36\n38 33 33 66 ?? ?? 37 34 ?? ?? 36 36 38 31 33 37 ?? ?? ?? ?? 34 37 34 37 65 32 }\n  $rtf = \"{\\\\rt\"\n condition:\n  ($rtf and 1 of ($enc*)) or $chunk_1\n}\n\n```\nNote that we have hex encoded version for upper and lower cases. But enough of this\ndigression, lets get back to our shellcode.\n\n## Shellcode\n\nAt first glance, decompilation of main shellcode function doesn’t look very nice, but we can\nmake it work. If one scroll down a little it’s actually pretty easy to find a decoding loop and\nmake an educated guess that this will decode a payload, but this time will do it step by step.\n\nFirst when dealing with shellcodes (or generally with most malwares) its important to find\nhow it utilize API calls. In most cases there will be a search for library addresses by walking\na PEB and later parsing PE files and applying some sort of hashing in order to resolve\nimports. Same here. At offset `b67h there is a function that will resolve all necessary`\nimports.\n\n\n-----\n\n```\n v0 (int )(sub_79E() + 13247445);\n v0[2] = sub_6BF();\n v1 = sub_669();\n v2 = v0[27];\n v3 = v0[2];\n *v0 = v1;\n v4 = ((int (__fastcall *)(int, int))sub_70A)(v3, v2);\n v5 = v0[98];\n v6 = v0[2];\n v0[27] = v4;\n v0[98] = ((int (__fastcall *)(int, int))sub_70A)(v6, v5);\n\n```\nAt top of this function we can see a call to a function and some strange number being added\nto a returned value, this is typical way of obfuscating address of a global structure that will\nhold pointers to resolved APIs - sometimes it also hold hashes of APIs that need to be\nresolved, exactly like in this case - which we can see immediately when following memory\noperations. After looking at `sub_70A we found out that hashing algorithm is` `ror7`\n```\ndef ror7_hash(name):\n  x = 0\n  for c in name:\n    x = ror(x, 7) & 0xffffffff\n    x += ord(c)\n    x &= 0xffffffff\n  return x\n\n```\nAfter this quick analysis we know that:\n\nhashing function is `ror7`\nlist of hash values is located at `-13242239 + 13247445 = 0x1456`\n\nLets create a script that will create CTX objects for us. First we need a list of API names,\n[here mlib has you covered as it exposes couple thousands of standard APIs one can found](https://github.com/mak/mlib)\nin windows dll’s. Rest is just a matter of creating and naming a structure members. Following\nscript accomplishes that.\n```\nfrom mlib.winapi import make_hash_dict\nfrom mlib.hash import ror7_hash\ndef create_ctx(addr):\n  api_dict = make_hash_dict(ror7_hash)\n  st_id = ida_struct.add_struc(idaapi.BADADDR,'ctx')\n  st = ida_struct.get_struc(st_id)\n  h = 0 \n  while h != idaapi.BADADDR:\n    h = ida_bytes.get_dword(addr)\n    name = api_dict.get(h,None)\n    if name:\n      name = 'api_' + name\n    addr +=4 \n    ida_struct.add_struc_member(st, name, idaapi.BADADDR, idaapi.FF_DWORD, None,\n4)\n\n```\n\n-----\n\nAnd soon after applying this and some more types we can get a nice clear view of a main\nfunction\n\n\n-----\n\n```\nctx main_function()\n{\n int v0; // edi\n ctx *v1; // esi\n char *v2; // edx\n char *i; // ecx\n int v4; // ecx\n char v5; // al\n unsigned int v6; // ebx\n unsigned int v7; // ebx\n int v8; // edx\n int v9; // edi\n unsigned int v10; // ebx\n unsigned int v11; // eax\n int v13; // [esp-44h] [ebp-68h]\n int v14; // [esp+10h] [ebp-14h]\n _BYTE *pefile; // [esp+14h] [ebp-10h]\n char v16; // [esp+18h] [ebp-Ch]\n int v17; // [esp+1Ch] [ebp-8h]\n int file_size; // [esp+20h] [ebp-4h]\n v0 = 4;\n v17 = 0;\n v1 = (ctx *)(get_ctx_offset() + 13247445);\n resolve_api();\n v1->call_func(v1->api_GetTempPathA, 2, 260, (unsigned int)v1->temp_path, 0, 0, 0,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n v2 = v1->file_name;\n for ( i = v1->temp_path; *i; ++i )\n  ;\n v4 = i - v2;\n do\n {\n  v5 = *v2;\n  v2[v4] = *v2;\n  ++v2;\n }\n while ( v5 );\n v14 = v1->call_func(v1->api_CreateFileA, 7, (int)v1->temp_path, 0x80000000, 0, 0,\n3, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n v6 = v1->call_func(v1->api_GetFileSize, 2, v14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0);\n v13 = v1->api_VirtualAlloc;\n file_size = v6;\n pefile = (_BYTE *)v1->call_func(v13, 4, 0, v6, 12288, 64, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0, 0);\n v1->call_func(v1->api_ReadFile, 5, v14, (unsigned int)pefile, v6, &v16, 0, 0, 0, 0,\n0, 0, 0, 0, 0, 0, 0);\n v7 = 2029427297;\n v8 = 0;\n if ( file_size > 0 )\n {\n  do\n  {\n   v9 = 7;\n\n```\n\n-----\n\n```\n   do\n   {\n    v7 = v7 & 4 ^ ((v7 ^ (v7 >> 27)) >> 3) & 1 | (2 * v7);\n    --v9;\n   }\n   while ( v9 );\n   pefile[v8++] ^= v7;\n  }\n  while ( v8 < file_size );\n  v0 = 4;\n }\n while ( 1 )\n {\n  v10 = v1->call_func(v1->api_GetFileSize, 2, v0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0, 0);\n  if ( v10 >= 0x1000 )\n  {\n   v1->call_func(v1->api_ReadFile, 5, v0, (unsigned int)&v17, 4, &v16, 0, 0, 0, 0,\n0, 0, 0, 0, 0, 0, 0);\n   if ( v17 == -535703600 )\n    break;\n  }\n  v0 += 4;\n }\n v11 = v1->call_func(v1->api_VirtualAlloc, 4, 0, v10, 12288, 64, 0, 0, 0, 0, 0, 0,\n0, 0, 0, 0, 0);\n v1->call_func(v1->api_WriteFile, 5, v0, v11, v10, &v16, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0);\n v1->call_func(v1->api_CloseHandle, 1, v0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0);\n load_pe(pefile, file_size);\n v1->call_func(v1->api_CloseHandle, 1, v14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0);\n v1->call_func(v1->api_TerminateProcess, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n0, 0);\n return v1;\n\n```\nThis will be enough to continue analysis of a campaign, as we can now switch to decoding\npayload and analyze whats there, however its sometimes worth to dig a little deeper into and\nuncover some interesting flavors that are inside. We will do exactly that.\n```\ncall_func - down to rabbit hole\n\n```\nWe skipped over analysis of how exactly api is resolved, lets apply some types first and take\nanother look. First thing that will strike us is that it walks `IMAGE_DATA_DIRECTORY instead of`\n```\nEXPORTS, indeed get_api function (located at 70Ah ) will recive as a frist argument\n\n```\npointer to begin of msvcrt.dll and will relay on addresses resolved when this librarly was\nloaded. This is a very nice anti-analysis trick, as this library is not automatically loaded, and\ncan cause some problems when analyzing shellcode outside of it designed host. After\naddress is resolved `5 is being added to it, this is strange! Keep it in mind and lets move to`\n\n\n-----\n\nfunction located at `7B7h . This function will make sure that we have` `GetProcAddr and`\n```\nVirtualProtect as well will try to resolve address of clearerr from msvcrt.dll (via\nGetProcAddr ). In order to call any of those APIs we have to go through a wrapper at\n8AEh and eventually we will reach function at 8D5h that will call our pointer, but before\n\n```\nthat it will do some checks.\n\nHere lays the mystery of those `+5 from` `get_api, before API is called first few bytes of its`\nprologue are checked. Any experienced eye can immediately recognize right hand values as\nan encoding of call or jmp asm opcodes. This is anti-hooking mechanism! If it detects\nhooking it will skip first 5 bytes emulating typical function prologue, thus rendering most of\nuser-mode api loggers useless.\nAfter address `clearerr is resolved, it content is overwritten with bytes from` `8AEh to`\n```\n8FDh which contains functions responsible for anti-hooking call proxy. There is another nice\n\n```\ntrick here, as the address of interesting area is dynamically calculated\n\n\n-----\n\n```\nseg000:000008A4         call  override_clearerr\nseg000:000008A9         call  $+5\n...\nseg000:000008F4         pop   ebx\nseg000:000008F5         mov   eax, [ebx+1]\nseg000:000008F8         add   ebx, eax\nseg000:000008FA         add   ebx, 5\nseg000:000008FD         mov   [ebp-18h], ebx\nseg000:00000900         push  50h ; 'P'    ; a3\nseg000:00000902         mov   edx, [ebp-18h] ; a2\nseg000:00000905         mov   ecx, [ebp-8]  ; a1\nseg000:00000908         call  copy\n\n```\nHere, beside call-pop technique, we can see that address that will be called from `8A9h is`\nextracted allowing to put interesting region anywhere in binary. While that deep analysis is\nnot necessary to obtain final payload, it adds some information about anyone who coded this\nshellcode as those tricks are quite sophisticated and uncommon, One can try to go through\npast and current samples of Royal Road and check how this shellcode evolves and if its\nmaybe typical to specific threat actor or not.\n\n## Optimizing decoding\n\n[Along side their publication researchers at nao_sec released a tool that can help decode](https://github.com/nao-sec/rr_decoder/raw/master/rr_decode.py)\nembedded payload into proper PE file. They realized that keys used to bootstrap decoding\nalgorithm in shellcode are reused and first 4 bytes of encoded binary will always be the\nsame. They found 4 different algorithms and 4 diffrent keys, all of the algorithms look more or\nless the same and have a shape of the one discussed earlier. It is important to notice that in\ntheir code two decoding functions ( decode_b25a6f00 and `decode_b2a66dff ) are totally`\ndifferent than what one can see in binaries, those are simple xors with one byte. Lets take a\nlook at `decode_b2a66dff :`\n```\n int v0, v9;\n int v7 = 2029427297;\n int v8 = 0;\n  do\n  {\n   v9 = 7;\n   do\n   {\n    v7 = v7 & 4 ^ ((v7 ^ (v7 >> 27)) >> 3) & 1 | (2 * v7);\n    --v9;\n   }\n   while ( v9 );\n   v8++;\n   printf(\"%x\\n\", v7);\n  }\n  while ( v8 < v18 );\n  v0 = 4;\n\n```\n\n-----\n\nThis function will very quickly reach `0xfffffffc and is degenerating whole encoding`\nscheme to just a xor with constant byte 0xfc. Lets split the line into simpler components\n```\nint x = ((v7 ^ (v7 >> 27)) >> 3) & 1;\nint z = v7&4;\nv7 = z ^ x | (2*v7);\n\n```\nProblem lies in `v7&4 which will keep its bit light up forever after the first time it will be set to`\n1. This is because it will be XORed with 1 bit variable and ORed with a value multiplied by 2.\nNext the bit will spread around the rest of the bits with every step until all the bits on the left\nwill be set to 1 (thanks to @dsredford for clarification) This is clearly a mistake caused\nprobably by a typo or lack understanding of operators priority, what author wanted to\naccomplish was something like this (based on later modifications):\n```\nint x = ((v7 ^ (v7 >> 27)) >> 3)\nint z = v7&4;\nv7 = (z ^ x)&1 | (2*v7);\n\n```\nUnfortunately these mistakes are not present in every version, hence more elaborate codes\nin `rr_decode.py . This script can of course take care of other schemas but it take some`\ntime when dealing with bigger binaries:\n```\n$ python3 rr_decode.py\n./df684cc86f19d5843f07dfd3603603723bb6491a29a88de7c3d70686df8635cc.bin_8.t xx.bin\n[!] Type [b0747746] is Detected!\n[+] Decoding...\n[!] Complete!\nreal 31m49.903s\nuser 30m30.094s\nsys 0m40.822s\n$ du -hs /tmp/xx.bin\n536K /tmp/xx.bin\n\n```\nThis is a problem for our automatic processing. Maybe we can do something about it? Lets\ntake a look at this one,\n\n\n-----\n\n```\n v9 0x48B53A6C;\n v10 = 0;\n if ( v8 > 0 )\n {\n  v11 = v8;\n  do\n  {\n   v12 = 7;\n   do\n   {\n    v9 = ((v9 ^ ((v9 ^ (v9 >> 26)) >> 3)) & 1 | (2 * v9)) + 1;\n    --v12;\n   }\n   while ( v12 );\n   *(_BYTE *)(v10++ + v22) ^= v9;\n  }\n  while ( v10 < v11 );\n\n```\ncan we somehow optimize expression assigned to `v9 ? It turns out we can! ;]`\nLets expand it a little bit this part `((9 ^ ((v9 ^ (v9 >> 26)) >> 3))&1 using the fact`\nthat `(x ^ y ) >> z is the same as` `(x >> z) ^ (x >> z) . We’ll end up with` `(v9 ^`\n```\n((v9>>27)>>3) ^ (v9>>3))&1 . We can see here that the whole expression is being anded\n\n```\nwith 1, meaning we only care about one bit of this operation. This bit will be a result of xoring\n3 bits from a number, more precisely we will xor following bits\n\n0th\n3th\n29th\n\nextracting those bits is easy, for example to get a 29th bit one can do:\n```\n(x & (1<<29)) == (1<<29)\n\n```\nWe tested many variants of how to efficiently write it down, but it turns out that doing just that\nyields best results!. We ended up with a following code:\n```\ndef decode_b0747746(data):\n  xor_key = 1219836524\n  for i in xrange(len(data)):\n    for _ in range(7):\n      x0 = (xor_key & 0x20000000) == 0x20000000\n      x1 = (xor_key & 8) == 8\n      x2 = xor_key & 1\n      x = 1 + (x0 ^ x1 ^ x2)\n      xor_key = (xor_key + xor_key) + x\n    data[i] ^= xor_key & 0xff\n  return data\n\n```\nand its way faster\n\n\n-----\n\n```\n$ time ripper df684cc86f19d5843f07dfd3603603723bb6491a29a88de7c3d70686df8635cc.bin \nPotential malware family dected: ['royal_road']\nmalware data:\n{'object_name': None,\n 'payload': '23d263b6f55ac81f64c3c3cf628dd169d745e0f2b264581305f2f46efc879587',\n 'payload_enc_type': 'b0747746',\n 'payload_key': 1219836524,\n 'shellcode_key': 50064,\n 'target_path': '%TEMP%\\\\..\\\\..\\\\Roaming\\\\Microsoft\\\\Word\\\\STARTUP\\\\intel.wll',\n 'type': 'royal_road_rtf'}\nreal 6m11.555s\nuser 6m3.671s\nsys 0m0.162s\n\n```\nSimilar operation can be done for 4th encoding scheme, but we will leave this as an exercise\nfor a reader.\n\n## Conclusion\n\nEven with a plethora of tools and analysis made available by other researchers its beneficial\nto sometimes take a deeper look into a subject. This can potentially uncover new ways of\ndealing with problems, revels new clues or patterns typical to threat actor, or simply find a\nnice new trick. This time we saw most of those came to life. In addition to deep analysis of\nRoyal Road shellcode we showed some generic methods of how to approach and/or speed\nup future analysis of any type of shellcode by utilizing power of scripting your disassembler\nand concentrating on most important parts. More of those tips an tricks can be found in our\n**ExtREme Malware Analysis training.**\n\nIt seems that Royal Road is going to stay with us for some time, despite all of the public\nresearch and that it exploits more than year old vulnerabilities. That being said we are\nlooking forward to see if developers will implement any new trick or will change their\n[approach in anyway. Research published at VB2019 shows that Royal Road is no longer in](https://www.virusbulletin.com/conference/vb2019/abstracts/attribution-object-using-rtf-object-dimensions-track-apt-phishing-weaponizers)\nuse only by APT groups but also by typical cyber-crime actors and we think its safe to\nassume that this weapnonizer was somehow leaked as we are seeing very strange testing\npayloads that almost reassemble red team exercises1 which suggests that its somehow\navailable to any parties .2\n\n\n## Analysis Artifacts - Hashes, domains, urls, etc\n\nHASHES: 2aff4cbb4b1ba8a62e45b74944362d757ebfdb960867db5e7dbca7a6beab69e1\n723bdb101d5d046a470618ff3c90dcad9018530cf02248f2c30f3a95e8eb9f8a\naaa9ad2f93c15204053516500c73b86bdbcc14956f5f63cb208528c68fad8755\n657c45152a924cbf8542faff7fc10aa264bb9d4b55f79bf992569704b392610b\n52aa0924797e3600d9a2d2f9f55526358aba19bcc25b5d22c98ce05d2b6cfc25\n44657dcf6286836be5898a464165331ebaa9d7d57762f88f8255ab9499751338\n5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9\n\n\n-----\n\nda23586cf0efffab039358e2b4410ea0a6b6eb4a9d7430a0d46ca1235a402027\n3f12dbce11f6faf0b27a4046e3c341b672228764eb5c3f98cee709980f2ec955\n4ac1e100cf5d46dca4cca9e051d744ff1406630904f836d95ee3c172a9d2aca5\n440ab62ec3520c378c61ee2def3da3ec32f553ab3ddd6eccda0cb0a70d9e8523\nd7f15f750cceeb9e28e412f278949f183f98aeb65fe99731b2340c8f1c008465\n100ded4eeffbd9c927cccd7850a3e83a2fb7b127e40e03f1570bbf6939cbb5fe\n98f06ddae144a0f22aac6898caa3469b965b1b02b90c1d54600e7e461a1cbdf7\n72cdfc4b25c6c0253a4cf1449d2a67343ee87c32176425bac5a7cbdd30007ec3\n1527f7b9bdea7752f72ffcd8b0a97e9f05092fed2cb9909a463e5775e12bd2d6\nc83c28add56ec8cad23a14155d5d3d082a1166c64ea5b7432e0acaa728231165\n500b6037ddb5efff0dd91f75b22ccce5b04d996c459d83d1f07fae8780b24e09\nb7bebe92a5802aa922e5719c948e35716f908e67701cfffaeebfcadc7a6e650a\n0eb7ba6457367f8f5f917f37ebbf1e7ccf0e971557dbe5d7547e49d129ac0e98\n855a060c43a83aa42faa63bfe4b08f31b4ba11cd64ea4cad69ad50910730f02f\n9d99badebbfc6616d9a74dbfced6b7db9097d274366a232025469980f9a229a0\ndf684cc86f19d5843f07dfd3603603723bb6491a29a88de7c3d70686df8635cc\n\n1. fb38bea02499d8cec47c88333234b033849307d6ad4d4442e6b6fd6837664d3b and\n\nac61b5fa62ea33717bdc80178f1083c49cfd34204b56556c805b8edb2265e534 ↩\n\n2. It’s also possible that someone went an extra mile and create a weaponizer that will\n\nappear as Royal Road based on publicly available YARA signatures ↩\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-21 - On the Royal Road.pdf"
    ],
    "report_names": [
        "2020-03-21 - On the Royal Road.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536024,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653710692,
    "ts_modification_date": 1653710692,
    "files": {
        "pdf": "https://archive.orkl.eu/4419f18e18bba21ee99002a9da301d621ed54658.pdf",
        "text": "https://archive.orkl.eu/4419f18e18bba21ee99002a9da301d621ed54658.txt",
        "img": "https://archive.orkl.eu/4419f18e18bba21ee99002a9da301d621ed54658.jpg"
    }
}