{
    "id": "fdb31911-f214-470f-9a3d-cc8ca353ca23",
    "created_at": "2023-01-12T14:59:53.726812Z",
    "updated_at": "2025-03-27T02:16:25.889537Z",
    "deleted_at": null,
    "sha1_hash": "78537f3d1bc1f38eaae86ccf9d49cbab2def3647",
    "title": "2014-06-02 - Analysis of Uroburos, using WinDbg",
    "authors": "",
    "file_creation_date": "2022-05-27T23:12:59Z",
    "file_modification_date": "2022-05-27T23:12:59Z",
    "file_size": 387741,
    "plain_text": "# Analysis of Uroburos, using WinDbg\n\n**[gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg](https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg)**\n\nUroburos was already described as a very sophisticated and highly complex malware in our\nG DATA Red Paper, where we had a look at the malware’s behavior. This malware belongs\nto a specific type called rootkit. The general purpose of a rootkit is to modify the behavior of\nthe system and, especially, to hide its activity. Generally, a rootkit resides in the kernel. To\nanalyze this kind of malicious software, analysts need to use specific tools, such as WinDbg,\nto debug the Microsoft Windows kernel. WinDbg is a debugger provided by Microsoft. One\ncan use this tool to debug user mode applications and kernel mode applications (for example\nthe drivers).\n\nToday, we would like to give you an understanding of how analysts work their way through\nmalware and give you some insights into the code of one of the most sophisticated digital\nthreats. In this current example case, we decided to work with a memory dump (crash dump)\nof a system infected with Uroburos. To facilitate the analysis, we added an extension to add\nthe support of python, called: PyKd. WinDbg has its own script language, but it is not easy to\nunderstand. One can download this python extension here, for free:\n[http://pykd.codeplex.com/.](http://pykd.codeplex.com/)\n\nTo realize this article, the machine was infected by the Uroburos dropper with the following\nmd5: 626576e5f0f85d77c460a322a92bb267.\n\n## Visualization of the hooks\n\nThe Uroburos rootkit adds several hooks to hide its activity. In our specific case, the hooking\nis a technique used to alter the behavior of specific system functions; the rootkit fakes the\noutput of the Microsoft Windows API. For example, it hides registry entries, files and more.\n\nTo perform this task, the rootkit developers decided to use interrupts. We can display the\nInterrupt Descriptor Table (IDT), as shown below. The IDT table stores pointers to ISR\n(Interrupt Service Routines), which are called when an interrupt is triggered.\n\n\n-----\n\nOne of the pointers (0x859e84f0) is unknown and cannot be resolved. All other pointers have\na function name, following the address. The last digits of the first column are the ID of the\ninterrupt (in our case 0xC3). We can disassemble the code available at this address:\n\nThe last argument of the WinDbg command is the length (L0x16) to disassemble. The\nfunction starts by a series of NOP. The interrupt 0xC3 is used by the malware, the next step\nis to identify how and when this interrupt is triggered. Here is the code of the beginning of the\nfunction IoCreateDevice():\n\nWe can see that the second instruction is int 0xC3 (interrupt 0xC3). Thanks to the PyKd\nextension, we can easily create a python script to detect every function with this interrupt:\n\n\n-----\n\nThis script starts to list each exported function in ntoskrnl.exe. Secondly, for each function it\nchecks if the second instruction is int 0xC3 (cdc3). If it is the case, the exported function’s\nname is displayed. Here is the output of the script regarding the current analysis:\n\nWe could use the function: !chkimg to easily identify the hook. However, it was a good\nexercise to play with PyKd.\n\nAnother interesting step is to dump the code of the driver. To perform this task, we first need\nto find the beginning of the PE. We can find the address thanks to the address of the code\nexecuted when an interrupt is triggered:\n\n\n-----\n\nThis output shows us two remarkable things:\n\nFirst, the driver uses a well-known Windows kernel memory pool tag called \"NtFs\".\nThe Windows components mark allocated memory block with a unique tag. But the\nrootkit uses the same tag as the legitimate ntfs.sys driver. This choice was made to\nhide the rootkit and dupe the analyst.\nSecondly, the output looks like the beginning of a PE. But this PE is broken: the MZ is\nnot available and some information is missing. For example, the value of the\nSizeOfImage (85980000+0x140) is null...\n\nThe rootkit alters the beginning of the PE to hide itself. Some tools parse the memory and\nlook for the MZ string to identify the beginning of a PE. In our current case, if we used these\ntools looking for a PE file, we would never identify our malware using this automation.\nManual analysis is needed here. To dump our driver we need to reconstruct the PE but we\ndon't know the size of the binary, as mentioned above, so we need to make a large dump, to\nbe sure to not forget a part of the binary.\n\n## Modules, drivers and devices\n\nWe can now display the loaded (and unloaded) modules with WinDbg:\n\n\n-----\n\nIn our case, the rootkit’s module is fdisk.sys. According to the code shown above, it seems to\nbe unloaded, but as we analyzed before, the code is really present on the infected system.\nSo, the developers found a way to unload the modules while the malicious code is still\nrunning!\n\nWe can list the drive\n\nThe driver used by our module is \\driver\\Null. All other modules are legitimate modules used\nby Windows. We can display the devices associated to the driver we are focusing on:\n\n\n-----\n\nThe device objects associated to our driver are:\n\n0x864473e0\n0x862531e0\n0x86253748\n0x8576a2d0\n\nFurthermore, we can see the description of those devic\n\n\n-----\n\nTwo objects are particularly interesting: FWPMCALLOUT and RawDisk1\n\n## WFP callout\n\nThis first device is FWPMCALLOUT. Thanks to the name of the device we can guess that\nthe rootkit registers a callout for Windows Filtering Platform (WFP). The WFP is a set of API\nand system services which provides a platform for creating network filtering applications. In\nour case, the rootkit uses this technology to perform Deep Packet Inspection (DPI) and\nmodifications of the network flow. The purpose of this device is to intercept relevant data as\nsoon as a connection to the Command & Control server or other local infected machines\nused as relay is established and to receive commands.\n\n\n-----\n\nAs there is no command to simply list the WFP callouts, we have to extract the information\nneeded using different steps:\n\nFirst, the netio!gWfpGlobal variable contains the starting point for the WFP data structures:\n\nA global table stores the number of callouts and the array of the corresponding callout\nstructures.\n\nHere is a method to find suitable offsets:\n\nThe first number is the offset that contains the number of total callouts made, in hex, of\ncourse:\n\nThe second number is the offset that contains the array in which the callout structure is\nstored:\n\nThe pool tag of this address confirms our findings so far and proves that we have found the\nright track:\n\n\n-----\n\nWe can now extract the size of each structure stored within the array. As it is not\ndocumented by Microsoft, we identify the size by disassembling the function\nInitDefaultCallout():\n\nFinally, we use a one-liner command to list the elements of this array:\n\n\n-----\n\nThe list of elements reminds us of the information we have seen in the IDT: two addresses\nare not resolved. Those two WFP callouts are: 0x859b5040 and 0x859b5520. WinDbg is not\nable to resolve these two addresses because the addresses are unknown. These are not\naddresses of a Microsoft. Now that we have the addresses, we can use the command !pool\nto validate that the addresses are in the same region as the code executed when an interrupt\nis triggered:\n\n\n-----\n\n## Virtual file system\n\nPreviously, when looking at the device objects, we came across two devices with very similar\nnames: RawDisk1 and RawDisk2. Let us have a detailed look at the first one:\n\nAs we can see, RawDisk1 device is in fact an NTFS file system; a virtual file system used by\nthe rootkit to store its configuration, the exfiltrated data…\n\nWe can identify the used files (opened handles) within the file system, like \\queue and \\klog:\n\n\n-----\n\n-----\n\nThanks to this command we are able to list the files hidden from the operating system.\n\n## Digital signature enforcement\n\nMicrosoft created a Driver Signing Policy for its 64-bit versions of Windows Vista and later\nversions. To load a driver, the .sys file must be signed by a legitimate publisher. Developers\nmay disable the Driver Signature Enforcement process during the development phase of a\ndriver, which means a developer does not have to sign each compiled driver version during\ndevelopment phase. This mode is called “Test-mode”. In our case, the rootkit is not signed,\nwhich would usually mean that it had no chance to be accepted by Microsoft’s policy, but it\ndisables the digital signature process to circumvent the checks. The status of this feature is\nstored in the global variable nt!g_cienabled. Compare the value of this variable on a clean\nsystem, without infection with the same information on an infected system:\n\nThe code above shows that the value is set to 1\n\nWe can clearly identify that the malware disabled the driver signature enforcement. Generally\nspeaking, we could do the same by using bcdedit.exe -set TESTSIGNING OFF, to switch\ninto testing mode to be able to load unsigned driver. The difference is: Using bcdedit.exe\ntriggers a message window which is shown to the user, at the bottom of the desktop, and this\nis not very secretive. The action could be detected immediately.\n\nMore information about the malware’s circumvention of the driver signature enforcement can\nbe found in our SecurityBlog article: Uroburos – Deeper travel into kernel protection\nmitigation\n\n## Conclusion\n\nWhat you have seen now, is a very limited part of the extensive analysis of complicated\nmalware and a very short introduction into WinDbg. Generally, it is very hard to apprehend\nsuch an extensive tool, but when working on such a case of kernel land analysis,\nresearchers do not have a choice.\n\nProcessed like this, in an article with code snippets, the results seem logic and do make\nperfect sense. But, believe us, working with malware code costs a lot of extensive training,\nexperience and time.\n\n## Related articles\n\n\n-----\n\n[2014/05/13 Uroburos rootkit: Belgian Foreign Ministry stricken](https://www.gdatasoftware.com/blog/2014/05/23958-uroburos-rootkit-belgian-foreign-ministry-stricken)\n\n[2014/03/07 Uroburos – Deeper travel into kernel protection mitigation](https://www.gdatasoftware.com/blog/2014/03/23966-uroburos-deeper-travel-into-kernel-protection-mitigation)\n\n[2014/02/28 Uroburos - highly complex espionage software with Russian roots](https://www.gdatasoftware.com/blog/2014/02/23968-uroburos-highly-complex-espionage-software-with-russian-roots)\n\n[2014/02/28 G DATA RedPaper about Uroburos](https://secure.gd/dl-en-rp-Uroburos)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2014/2014-06-02 - Analysis of Uroburos, using WinDbg.pdf"
    ],
    "report_names": [
        "2014-06-02 - Analysis of Uroburos, using WinDbg.pdf"
    ],
    "threat_actors": [
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535593,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653693179,
    "ts_modification_date": 1653693179,
    "files": {
        "pdf": "https://archive.orkl.eu/78537f3d1bc1f38eaae86ccf9d49cbab2def3647.pdf",
        "text": "https://archive.orkl.eu/78537f3d1bc1f38eaae86ccf9d49cbab2def3647.txt",
        "img": "https://archive.orkl.eu/78537f3d1bc1f38eaae86ccf9d49cbab2def3647.jpg"
    }
}