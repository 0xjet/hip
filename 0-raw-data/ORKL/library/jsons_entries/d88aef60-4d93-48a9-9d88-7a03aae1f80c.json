{
    "id": "d88aef60-4d93-48a9-9d88-7a03aae1f80c",
    "created_at": "2023-01-12T15:03:46.216632Z",
    "updated_at": "2025-03-27T02:09:18.323113Z",
    "deleted_at": null,
    "sha1_hash": "8befdaac16221f50fd3303e57952ae2c42008311",
    "title": "2022-02-18 - Hackers No Hashing- Randomizing API Hashes to Evade Cobalt Strike Shellcode Detection",
    "authors": "",
    "file_creation_date": "2022-05-27T21:55:24Z",
    "file_modification_date": "2022-05-27T21:55:24Z",
    "file_size": 3742158,
    "plain_text": "# Hackers No Hashing: Randomizing API Hashes to Evade Cobalt Strike Shellcode Detection\n\n**[huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection](https://www.huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection)**\n\nWhile researching Application Programming Interface (API) hashing techniques commonly\nused in popular malware (particularly Metasploit and Cobalt Strike), the Huntress ThreatOps\nTeam found that hackers are sticking to the default settings that come with hacker tooling.\nOur research has suggested that many detection/antivirus (AV) vendors have realized this\nand have built their detection logic around the presence of artifacts left by these defaults.\n\nWith a bit of tinkering and curiosity, we found that if trivial changes are made to those\ndefaults, a large number of vendors will fail to detect otherwise simple and commodity\nmalware. As a result, simple and commodity malware suddenly starts approaching FUD\nstatus. üòÖ\n\nIn this post, we‚Äôll dive into how we discovered those minor changes and how you can\nimplement them yourself to test your detection tooling. We have included a script that\nautomates a large portion of this process, as well as a YARA rule which will detect most\nmodifications made using this technique.\n\nWhether you‚Äôre on Team Red, Team Blue, or anywhere in between, we hope this blog\nprovides some useful insight into an interesting bypass and detection technique.\n\nIf screenshots like this excite you, read on.\n\n\n-----\n\n**Technical TL;DR**\n\nOur research suggests that a large number of vendors have based their Cobalt Strike and\nMetasploit shellcode detection capability on the presence of ROR13 API hashes. By making\ntrivial changes to the ROR13 logic and updating the hashes accordingly, a large number of\nvendor detections can be seemingly bypassed without breaking code functionality.\n\nIn order to detect this behavior, YARA rules that previously detected ROR13 hashes can be\nmodified to detect blocks of code associated with typical ROR-based hashing. This move to\ndetection of ROR blocks can provide a more robust means of detection than detecting on\nhashes alone.\n\n**Graphical TL;DR**\n\n\n-----\n\n## But First, A Quick Refresher on API Hashing\n\nAPI hashing is a technique often used by malware to disguise the usage of suspicious APIs\n(essentially functions) from the prying eyes of a detection analyst or security engineer.\n\nTraditionally, if a piece of software needed to call a function of the Windows API (for\nexample, if it wanted to use CreateFileW to create a file), the software would need to\nreference the API name ‚Äúdirectly‚Äù in the code. This typically looks like the screenshot below.\n\n\n-----\n\nBy ‚Äúdirectly‚Äù using an API, the name of the API is left present in the code. This enables an\nanalyst to easily identify what the piece of suspicious code might be doing. In this case, that\nsuspicious action is creating or opening a file.\n\nWhen a ‚Äúdirect‚Äù API call is used, it also leaves the API present in the import table of the file.\nThis import table can be easily viewed within PeStudio or any other analysis tool and looks\nlike the screenshot below. Note we can also see the other APIs that the malware is using.\n\nIf you‚Äôre an attacker trying to hide the creation of a malicious file, then neither of these\nsituations is ideal. It would be far better if you could hide your API usage away from an\nanalyst who may see `CreateFileW` and then go searching for suspicious files.\n\nIf an attacker doesn‚Äôt want their API to show up in an import table, then the alternative is to\nload the APIs dynamically (when the malware actually runs). The easiest way to do this is to\nuse a Windows function called GetProcAddress. This method avoids leaving suspicious APIs\nin the import table as we saw above in PeStudio.\n\n\n-----\n\nA quick caveat using dynamic loading is that although the original suspicious API\n`CreateFileW` would be absent from the import table, the usage of ‚ÄúGetProcAddress‚Äù will\nnow be in the import table instead. A keen-eyed analyst who sees the presence of\nGetProcAddress can run the malware in a debugger and find out what is being loaded.\n\nWith a well-placed breakpoint, an analyst can view the arguments being passed to the\nGetProcAddress function and find out what is being loaded. Upon running the suspicious\ncode, a debugger would then present something like this, revealing the usage of\nCreateFileW and indicating to an analyst that they should go looking for suspicious files that\nmay have been created.\n\n\n-----\n\nA common means of avoiding both of these situations is to use a technique known as API\nhashing.\n\nThis is a technique where attackers will implement their own version of GetProcAddress that\nwill load a function by a hash rather than a name. This avoids leaving suspicious APIs in\nimport tables and avoids using suspicious APIs that can be easily viewed in a debugger.\n\nIf an analyst wants to find out what‚Äôs going on, they would need to get familiar with x86\nassembly.\n\n### The TL;DR Takeaways\n\nThere are multiple ways to load suspicious APIs; however, most will leave easy-to-find\nindicators for malware analysts\nAPI hashing uses unique hashes rather than function names. This hinders the analysis\nof function names that target strings or arguments at breakpoints\n\n## Hashing Indicators\n\nNow that we know why someone might want to use API hashing, we can take a look at how\nto deal with it when analyzing suspicious code. It is relatively easy to identify, as you will\noften see random hex values pushed to the stack, followed by an immediate call to a register\nvalue.\n\nTypically, this call will resemble call rbp, but the register could technically be any value.\nBelow is a screenshot taken from some Cobalt Strike shellcode where API hashing was\nused.\n\n\n-----\n\nIn the screenshot, we can see two hex values pushed to a register prior to a `call rbp`. These\nare the hashes that will be resolved and used to load suspicious functions used by malware.\n\nThe hashes above correspond to 0x726774c (LoadLibraryA) and 0xa779563a\n(InternetOpenA).\n\nIf you were to find the value of rbp in this situation, you would find that it points to the\n‚Äúmanual‚Äù implementation of GetProcAddress, which then resolves the hash and calls the\nassociated API.\n\nAt a high level, the hash resolution logic is similar to the below pseudo code.\n\n\n-----\n\nAdditionally, you would find that the Calculatehash Logic, which is largely based on the ror13\nhashing algorithm, is similar to this. The value of 0xd (13) is important here as later we will\nchange this value to generate new hashes that can bypass detection.\n\nThis is a simplification, and the actual logic is slightly more complex. If you‚Äôre interested in\nunderstanding the logic in more detail, there are some great write-ups on the topic from\n[Nviso and Avast.](https://blog.nviso.eu/2021/09/02/anatomy-and-disruption-of-metasploit-shellcode/)\n\nAfter analyzing numerous malware samples using API hashing in shellcode, we noticed that\nsimilar malware families will often use extremely similar hashing logic to calculate and\nresolve API hashes.\n\n\n-----\n\nIn particular, we found that most Cobalt Strike, Msfvenom and Metasploit use exactly the\nsame hashing logic for resolving API hashes. Since they utilize the same logic, they produce\nthe same hashes for any given function.\n\nFor example, both Cobalt Strike and Metasploit will use the hash 0x726774c when resolving\n‚ÄúLoadLibraryA‚Äù.\n\n### The TL;DR Takeaways\n\nAPI hashing is relatively simple to identify through static analysis, although it is difficult\nto find what the hashes resolve to\nSimilar hashing logic is often used across similar malware families\nThe exact same hashing logic is often across samples from MsfVenom, Metasploit and\nCobalt Strike\n\n## Poking a Bit Further\n\nWe eventually found that it was easy to identify shellcode that was generated by Cobalt\nStrike or Metasploit simply by googling the hash values present in the code.\n\nIf we were to google the value of 0x726774c (LoadLibraryA), we would immediately get hits\nfor the Metasploit framework (which shares code with Cobalt Strike). We see the same if we\ngoogle the hash for 0xa779563a (InternetOpenA).\n\n\n-----\n\nGenerating our own shellcode samples from these frameworks, we observed that the hashes\npresent in our payloads were consistently identifiable as those used by Metasploit and\nCobalt Strike.\n\n### The TL;DR Takeaways\n\nMetasploit and Cobalt Strike (at least by default) use the same API hashing routine and\nwill produce the same hash values when using the same function\nThese hashes introduce unique hex values that can be used to easily identify the\nmalware families by using Google\n\n## YARA Rules\n\nFrom the perspective of a security analyst or detection engineer, this was great information.\nWithout performing a deep dive into shellcode and assembly, we could easily identify that a\npayload likely belonged to either Metasploit or Cobalt Strike.\n\n\n-----\n\nThis got us thinking‚Äîif these hash values are unique to tools like Cobalt Strike and\nMetasploit‚Ä¶ what if those hashes are unique enough to be used for YARA rules?\n\n[We found a fantastic article from Avast that captured the same idea. Their article details the](https://decoded.avast.io/threatintel/decoding-cobalt-strike-understanding-payloads/)\nuse of these same API hashes to detect Cobalt Strike and Metasploit shellcode. Below we\ncan see a YARA rule from Avast which relies largely on the hashes we previously identified\n(as well as the other hashes required for an HTTP stager).\n\nTesting these YARA rules against our raw Cobalt Strike and Metasploit shellcode (without\n[any encoders enabled), we confirmed the Avast YARA ruleset reliably detected and identified](https://github.com/avast/ioc/tree/master/CobaltStrike)\nall of our generated payloads. Great news for Team Blue‚Äîand great work from the Threat\nIntel Team at Avast.\n\n### The TL;DR Takeaways\n\nAPI hashes present in shellcode are reliable indicators that can be used for detection\nVendors are actively using these indicators to detect malicious shellcode\n\n## But What if the Hashes in the Shellcode Are Changed?\n\nAt face value, the usage of API hashes for detection is a great idea. But that got us thinking,\nwhat happens if those hash values were to change?\n\nAs an initial proof-of-concept, we took our payloads and rather crudely changed the hashes\nto 0x11111111. We knew this would break the shellcode as the hashes would no longer\nresolve‚Äîbut it would allow us to check how well the shellcode is detected without the\npresence of known API hashes.\n\nOur new shellcode would contain hashes like this in place of the actual hashes seen before.\n\n\n-----\n\nWe then did a before and after check on a Cobalt Strike HTTP payload using Virustotal, and\nfound that 15 vendors failed to detect the shellcode after these changes were made.\n\nAs a proof-of-concept, this was pretty interesting. But as an attacker, this is largely useless.\nIn its current modified state, the shellcode would no longer resolve hashes and would not be\nable to find the APIs it requires in order to execute‚Äîturning our shellcode into a nice digital\n\n\n-----\n\npaperweight.\n\n### The TL;DR Takeaways\n\nAt least some vendors are using API hashes to detect Cobalt Strike and similar\nmalware\nIf these defaults are changed, at least some vendors will fail to detect previously\ndetected payloads\nCrudely modifying API hashes will break your code\n\n## But What if Modified Hashes Could Resolve Properly?\n\nAfter confirming our suspicion that vendors were using API hashes to detect shellcode, we\ndecided to explore what would happen if the hashes were modified less crudely, in a way\nthat would still enable the modified hashes to resolve and execute.\n\nFirst, we needed to understand exactly how the hashes were generated. Our ThreatOps\nteam was able to discover this through a combination of the Metasploit source code and by\nanalyzing the assembly instructions present in samples of shellcode.\nBy nature of how hashing works, we theorized that it should only take minor changes to the\nhashing logic to produce vastly different hashes. In the end, rather than getting fancy with\nany entirely new hashing routines, we decided to just change the rotation value in the\nexisting logic from 0xd/13 to 0xf/15.\n\nIn theory, this would result in entirely new hashes, while maintaining largely the same logic\nand hashing structure.\n\nWe then created a script to generate new hashes according to our new rotation value of 0xf.\nThis logic can be found in the final script included in this post.\n\n\n-----\n\nAfter generating new hash values, we then updated our shellcode to correspond to our new\nhashes, and our new ror value of 0xf. Note that our shellcode structure is still largely intact,\nthe only thing that changed is the hash and rotation (ror) values.\n\nWe then confirmed that our code was still able to function as expected. This process was\n[vastly sped up using the Speakeasy tool from FireEye.](https://github.com/mandiant/speakeasy)\n\nBelow we can see a screenshot of the APIs still successfully resolving in our newly modified\nshellcode.\n\n[Using a combination of netcat and the BlobRunner tool from OAlabs, we did an extra check](https://github.com/OALabs/BlobRunner)\nto confirm that our shellcode still worked and would ‚Äúcall out‚Äù as expected.\n\n\n-----\n\nAfter confirming that our code definitely still worked, we uploaded it to VirusTotal. And found\nthat we still had two vendors remaining, the same two vendors from our previous dummy\nvalue testing.\n\nThis was pretty interesting, since this was now functioning Cobalt Strike shellcode‚Äîwith 15\nfewer detections than before it was modified.\n\nFor a sanity check, we re-ran the same process using a TCP bind shell from Metasploit (no\nencoders enabled). After confirming that the code still worked, we submitted it to VirusTotal\nand found that 26 vendors had failed to detect the modified payload.\n\n\n-----\n\nDuring our analysis, it was interesting to note that the two remaining vendors differed\nbetween the modified payloads.\n\nAt this point, we also checked that the original YARA rules were no longer detecting our\npayloads. And confirmed that they were no longer being detected.\n\n### The TL;DR Takeaways\n\nA large number of vendors are using default ror13 hashes to detect Cobalt Strike and\nMetasploit/Msfvenom payloads.\n\n\n-----\n\nModifying these hashes has a considerable impact on detection rates.\nWhen done properly, modifying these hashes will not break shellcode functionality.\nThis technique works well on both Msfvenom and Cobalt Strike. Hence likely works on\nother malware families too.\n\n## So What About Those Remaining Vendors?\n\nRather than leave it at 2/55, we decided to tackle the two remaining vendors detecting our\nshellcode.\n\nFirst, we noted that the remaining vendors were detecting generic shellcode and not Cobalt\nStrike or Metasploit specifically. This led us to believe that they were detecting generic\nshellcode indicators, rather than anything specific to our family of malware.\n\nWe theorized the following might be targeted by the remaining vendors, since they are\nbehaviors typically associated with shellcode.\n\nCLD/0xfc being the first instructions executed - (CLD is used to reset direction flags\nused in byte/string copy operations)\nSuspicious calls to registers (eg call rbp)\nPresence of library names in stack strings\n\nTo test, we slightly modified these indicators in our remaining payload. We achieved this by\n\nMoving the initial CLD instruction to another location in our shellcode, so that it still\nexecuted but was no longer the first instruction. (Assuming CLD executes before any\nstring operations, this should have no impact on shellcode functionality)\nInserting a NOP/0x90 in place of the original CLD\nInserting an uppercase character in the arguments to the initial call to LoadLibraryA.\n(Since LoadLibraryA is not case sensitive, this shouldn‚Äôt break any functionality)\n\nBelow, we have a before and after of the modified shellcode. Note the minor changes from\n‚Äúwininet‚Äù (all lower case) to ‚ÄúwIninet‚Äù (one upper case I). As well as the CLD instruction now\n\n\n-----\n\nlocated after our pop rbp.\n\nWe then confirmed that our shellcode still functioned, and then resubmitted it to VirusTotal.\n\nFinally, we had hit 0/55 detections without breaking our code.\n\nWe then checked the same with Antiscan and found that we had also hit zero detections for\nour Cobalt Strike shellcode‚Äîwhereas a non-modified copy had 13 detections.\n\n\n-----\n\n**The TL;DR Takeaways**\n\n\n-----\n\nVendors are definitely using API hashes to identify Cobalt Strike shellcode\nRemoving API hashes will remove most‚Äîbut not all‚ÄîVirusTotal detections\nLacking hashes, some vendors will detect on other generic shellcode indicators\nWe can modify these remaining indicators to achieve zero detections\n\n## Automating the Process\n\nSince the hashing replacement process could be achieved with a byte-level search and\nreplace, the Huntress ThreatOps team developed a script to automate the process.\n\nThis script‚Ä¶\n\nTakes a raw shellcode file as input (no encoders present)\nAutomates the hash replacement process, using a randomized ror value between one\nand 255\nSince a different ror value is used each time, a unique file and hash is generated upon\neach run, allowing multiple files to be created for a single piece of shellcode\n\nWe decided not to automate the process of upper-casing the library name and moving the\nCLD/0xfc, so you will need to do those manually if you wish to have zero detections. Both\nactivities can be done manually and with minimal effort using a hex editor.\n\nIn order to use the script, generate a raw payload with Msfvenom or Cobalt Strike (make\nsure your output is raw‚Äîdo NOT use any encoders), save it to a raw binary file and then\npass it as an argument to the Python script. The script will handle the hash replacement\nprocess with a random ror value and unique hashes.\n\nAn example of how to generate a simple reverse shell payload using msfvenom. Note the\nuse of ‚Äú--format raw‚Äù to avoid using encoders.\n\nBelow is an example of how to use the script to modify the shellcode file.\n\n\n-----\n\n### Notes and Limitations of This Script\n\nThis script only replaces hashes and the hashing logic. If there are other suspicious\nindicators in your shellcode, you may need to find your own method to hide them\nThis script is NOT an encoder, so you will still need to deal with bad characters and null\nbytes within your shellcode\nUsing a public and well-known encoder (like Shikata ga nai) will introduce its own\nindicators which will work against you\n\n### Detection of Modified Shellcode\n\nAfter confirming that our script for generating new shellcode works for bypassing generic\ndetections, we then developed a YARA rule for detecting shellcode generated by our script.\n\nBelow we‚Äôve included a copy of a YARA that detected all Msfvenom and Cobalt Strike\npayloads that we tested with, regardless of whether they had been modified by our script. In\nour testing, we did not hit any false positives within our test set of binaries, but you may wish\nto modify the rule to fit your needs if false positives arise.\n\n### How It Works\n\nSince existing detection rules are detecting hashes generated _by the hashing routine (which_\ncan be easily changed), this rule detects the hashing routine itself. This allows for slightly\nmore robust detection of Cobalt Strike and Metasploit shellcode.\n\nAs with any detection, this rule is not bulletproof. A determined attacker can introduce\nmore complex changes to the hashing routine which will break this YARA rule. We have\nallowed for minor variations in our rule, but more complex changes will still defeat it.\n\n## Final Comments\n\nClearly, detections aren‚Äôt always perfect, and a well-determined attacker will always be able\nto sneak through. If you‚Äôre a defender, make sure you‚Äôre always testing and updating your\ndetection rules (you never know what might sneak past).\n\n\n-----\n\nIf you re an attacker (a Red Teamer, of course), don t rely on defaults to get you by‚Äîsimple\nchanges can have a significant impact on your chances of being detected.\n\nAnd finally, a few key takeaways for Blue and Red Teamers, respectively:\n\nTeam Blue\n\nContinuously test and update your detection logic\nActively threat hunt! No alerts ‚â† no malware\nSearch through a variety of log sources‚Äîan AV may not have caught this, but the\nnetwork traffic might stand out like a sore thumb\n\nTeam Red\n\nDon‚Äôt use defaults! Tinker with everything\nDon‚Äôt be afraid to get familiar with assembly!\n\n### Scripts/YARA Rules\n\n**YARA**\n\n**Main Script (view the full script** **[here)](https://github.com/matthewB-huntress/APIHashReplace)**\n\n**References**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-18 - Hackers No Hashing- Randomizing API Hashes to Evade Cobalt Strike Shellcode Detection.pdf"
    ],
    "report_names": [
        "2022-02-18 - Hackers No Hashing- Randomizing API Hashes to Evade Cobalt Strike Shellcode Detection.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535826,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653688524,
    "ts_modification_date": 1653688524,
    "files": {
        "pdf": "https://archive.orkl.eu/8befdaac16221f50fd3303e57952ae2c42008311.pdf",
        "text": "https://archive.orkl.eu/8befdaac16221f50fd3303e57952ae2c42008311.txt",
        "img": "https://archive.orkl.eu/8befdaac16221f50fd3303e57952ae2c42008311.jpg"
    }
}