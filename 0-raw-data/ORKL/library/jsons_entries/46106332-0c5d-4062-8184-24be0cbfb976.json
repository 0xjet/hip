{
    "id": "46106332-0c5d-4062-8184-24be0cbfb976",
    "created_at": "2023-01-12T15:10:26.739813Z",
    "updated_at": "2025-03-27T02:09:18.553026Z",
    "deleted_at": null,
    "sha1_hash": "aa5e9a48e65b5fb1d2896294e56be2d173da6ace",
    "title": "2021-12-28 - Extracting Hancitorâ€™s Configuration with Ghidra part 1",
    "authors": "",
    "file_creation_date": "2022-05-27T23:00:46Z",
    "file_modification_date": "2022-05-27T23:00:46Z",
    "file_size": 1164964,
    "plain_text": "# Extracting Hancitorâ€™s Configuration with Ghidra part 1\n\n**[medium.com/@crovax/extracting-hancitors-configuration-with-ghidra-7963900494b5](https://medium.com/@crovax/extracting-hancitors-configuration-with-ghidra-7963900494b5)**\n\nCrovax January 21, 2022\n\n[Crovax](https://medium.com/@crovax?source=post_page-----7963900494b5--------------------------------)\n\nDec 27, 2021\n\n\n7 min read\n\n## Topics covered\n\nLocate the decryption function\nDetermine the decryption algorithm\nBuild Ghidra script to decrypt the configuration file\nBuild yara detection rule (In part 2)\n\n## Hancitor Overview\n\nHancitor is an older malware loader that is known to drop additional malware on to the\nsystem once infected (cobalt strike and some ransomware variants). The entry point is from\nyour typical malspam campaign, that contains a link to an office doc or already has one\nembedded in the email.\n\nThe original dll is usually packed, and once unpacked, will execute the hancitor payload and\nreach out to one of its hard coded c2's.\n\n**Original packed samples:**\n\n[https://www.malware-traffic-analysis.net/2021/06/17/index.html](https://www.malware-traffic-analysis.net/2021/06/17/index.html)\n\n**Unpacked Sample:**\n\nSHA-256\n\n882b30e147fe5fa6c79b7c7411ce9d8035086ad2f58650f5d79aadfb2ffd34f4\n\n## Locating the decryption function\n\n\n-----\n\nHancitor leverages the Windows native Cryptographic Service provider (CSP) context to\nperform its decryption routine. Knowing that, locating the decryption function will be relatively\neasy.\n\nOne way, is to load the binary into Ghidra and look at import table list for one of the\ncryptographic functions (CryptDecrypt, CryptAcquireContextA etc) then follow the referenced\nfunction from there.\n\nNow that we have located the function leveraging the CryptDecrypt routine, we can get a\nbetter picture of how the decryption process works. Below is the decompiled view of the\nfunction performing the decryption routine. Weâ€™ll step through each function to determine\nhow the decryption logic works then start programming it out.\n\n## CryptAcquireContextA\n\nThe CryptAcquireContextA function initiates the call to the Cryptographic Service Provider\n(CSP) to determine what kind of CSP to use for the CryptoAPI functions. This function is\nstraightforward as its role is just to initiate the CSP context for use. We can determine which\nCSP is going to be used by the first â€˜PUSH 0x0\" instruction. Since its a null value being used,\nthe default selection is made (native windows cryptographic service provider)\n\n\n-----\n\n## CryptCreateHash\n\nWhen the CryptCreateHash function is called, it creates the hashing object to be used in the\ncryptographic routine, and determines the type of hashing algorithm to be used. Once\nsuccessful, it returns a handle to the object, for subsequent calls to the other cryptographic\nfunctions.\n\nTo determine what hashing algorithm is being used, we can look at the â€˜Algidâ€™ value that will\nbe pushed on to the stack. In this case, we see the â€˜PUSH CALG_SHA1â€™ instruction is being\nused. So, we know that the hashing algorithm is SHA1.\n\n## CryptHashData\n\nThis function is going to hash the data passed to it, using the previously specified\nalgorithm(SHA1). But what is being hashed and how do we figure it out?\n\nFirst we need to look back at the arguments being passed into the function (I have labeled it\nâ€œDecryptionâ€™) to see what data is being passed and where its located.\n\n\n-----\n\nby looking at the arguments and their position in which they re being passed in, we need to\nfind out what the data is expecting and where is it located. In order to find this information we\ncan follow the data that is being passed into the function.\n\nHint: I have already labeled it ðŸ˜ƒ\n\nAs you can see, the third argument being passed is a pointer to the â€˜keyâ€™ thats going to be\nhashed, and the argument being passed to the right of it (8) is the key length.\n\nso we know the following:\n\n**Key = bâ€™\\xb3\\x03\\x18\\xaa\\x0a\\xd2\\x77\\xdeâ€™**\n\n**Key length = 8 bytes**\n\n## CryptDeriveKey\n\nThis next part is going to be a bit tricky. The CryptDeriveKey is going to accept a few\nparameters:\n\n\n-----\n\n**hProv = handle to the cryptographic service provided being used.**\n\n**Algid = algorithm for which the key is to be generated. In this case, its going to be RC4.**\n\n**hHash or hBaseData = handle to the hash object that points to the data.**\n\n**dwFlags = this is going to be key length that is going to be used. Which is the lower 16 bits**\nof the value being passed. In our case that value is 0x00280011, so we only want the lower\nvalues or 0x0028 (we can truncate the leading zeros). So by dividing 0x28 / key length(8)\nthat was being passed to the CryptHashData function, we know how many bytes of the RC4\nkey is going to be used to decrypt the configuration data.\n\n**RC4 key: 0x28 / 8 = (5 bytes)**\n\n## CryptDecrypt\n\nThis function is straightforward, it accepts the data to be decrypted, the key used, and the\nlength of the data as parameters. To verify, we can once again look at the arguments that are\nbeing passed to the function.\n\nbased on the value being passed in, we can see the encrypted data length is equal to\n0x2000 bytes.\n\n\n-----\n\nBelow is a graphical representation of the actions performed thus far.\n\n## Creating the Ghidra script\n\nWe now understand how the decryption process works. The next step is to create a script in\nGhidra to automate this whole process, so we can extract the build/campaign id and the c2\ndomains from this sample.\n\n**[Note: the python script can be downloaded from my github (link here). Your cursor needs to](https://github.com/CrovaxTheCursed/CrovaxTheCursed/tree/main/Malware_Analysis/Hancitor_Ghidra_Script)**\nbe pointing to the first address of the encrypted data before running the script. This is due to\nthe â€˜currentAddressâ€™ method.\n\nWe know we need to create a sha1 hash of the 8 byte key thatâ€™s being passed into the\nDecryption function. So we can copy those bytes out of Ghidra and store them into a\nvariable. The next step is to get a hash (sha1) of the key and extract the first 5 bytes (Key\nHash: a956a1e6ff).\n\nNext we need to get the encrypted data using ghidraâ€™s getBytes function, and then perform\nany necessary conversions on the hex values\n\n\n-----\n\n```\ndef get_encrypted_bytes(): \n  get_addr = currentAddress\n  get_bytes = list(getBytes(get_addr, 2000))\n  converted_bytes = ''\n  cByte = ''\n  for byte in get_bytes:\n    if byte < 0:\n      cByte = (0xff - abs(byte) + 1)\n    else:\n      cByte = byte\n    converted_bytes += chr(cByte)\n      return converted_bytes\n\n```\nWe now have our key and the encrypted data we need to decrypt. The last step is to pass\nthese parameters to a our rc4 decryption function to perform the remaining steps.\n```\ndef rc4_decrypt(key, data):  x = 0  box = range(256)  for i in range(256):   \nx = (x + box[i] + ord(key[i % len(key)])) % 256    box[i], box[x] = box[x],\nbox[i]  x = 0  y = 0  out = []  for char in data:    x = (x + 1) % 256  \ny = (y + box[x]) % 256    box[x], box[y] = box[y], box[x]    \nout.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256]))  return ''.join(out)\n\n```\nNow that we have our decrypted data, we just need to format the data we want and discard\nany null bytes.\n```\nprint 'Current Address:', currentAddress print 'Key\nHash:',binascii.hexlify(key_hash)get_data = get_encrypted_bytes()config = \nrc4_decrypt(key_hash, get_data)build_id = config.split('\\x00')[0]print 'Build_id:',\nbuild_idfor string in config.split('\\x00')[1:]:  if string != '':    c2 =\nstring    breakc2_List = c2.split('|')for c2 in c2_List:  if c2 != '':    \nprint 'c2:', c2\n\n```\nThe output should look something like this ðŸ˜ƒ\n\n\n-----\n\n_Decode_Config.py> Runningâ€¦key length 8Current Address: 005c5018Key Hash:_\n_a956a1e6ffBuild_id: 1706_apkreb6c2: http://thestaccultur.com/8/forum[.]phpc2:_\n_http://arguendinfuld.ru/8/forum[.]phpc2: http://waxotheousch.ru/8/forum[.]php_\n\n## Conclusion\n\nBy breaking down the individual functions of the decryption routine we were able to\ndetermine how hancitor was decrypting its c2 domain configuration. We then applied the\nsame process in creating a Ghidra script to automatically perform the same steps statically,\nto reveal the encrypted data.\n\nIn part 2, we well take a similar approach and build a yara rule to test our theory and see if\nwe can detect multiple hancitor variants.\n\nAs always, Donâ€™t expect much, as I have no clue what Iâ€™m doing. ðŸ˜ƒ\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-28 - Extracting Hancitorâ€™s Configuration with Ghidra part 1.pdf"
    ],
    "report_names": [
        "2021-12-28 - Extracting Hancitorâ€™s Configuration with Ghidra part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536226,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653692446,
    "ts_modification_date": 1653692446,
    "files": {
        "pdf": "https://archive.orkl.eu/aa5e9a48e65b5fb1d2896294e56be2d173da6ace.pdf",
        "text": "https://archive.orkl.eu/aa5e9a48e65b5fb1d2896294e56be2d173da6ace.txt",
        "img": "https://archive.orkl.eu/aa5e9a48e65b5fb1d2896294e56be2d173da6ace.jpg"
    }
}