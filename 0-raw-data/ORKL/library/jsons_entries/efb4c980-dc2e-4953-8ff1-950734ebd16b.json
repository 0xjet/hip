{
    "id": "efb4c980-dc2e-4953-8ff1-950734ebd16b",
    "created_at": "2023-01-12T15:10:12.861979Z",
    "updated_at": "2025-03-27T02:06:13.797215Z",
    "deleted_at": null,
    "sha1_hash": "da42abb3a01302ee5aa274e740475e5b43a11d73",
    "title": "2022-08-03 - Journey to Network Protocol Fuzzing – Dissecting Microsoft IMAP Client Protocol",
    "authors": "",
    "file_creation_date": "2022-08-18T03:59:28Z",
    "file_modification_date": "2022-08-18T03:59:28Z",
    "file_size": 1032974,
    "plain_text": "# A Journey to Network Protocol Fuzzing – Dissecting Microsoft IMAP Client Protocol\n\n**fortinet.com/blog/threat-research/analyzing-microsoft-imap-client-protocol**\n\nAugust 3, 2022\n\nIn networking, a protocol is a set of rules that defines standard formats and processes for interpreting raw data sent by\ncomputers. Network protocols are like a common language for computers. The computers within a network may use\nvastly different software and hardware; however, protocols enable them to communicate with each other regardless.\n\nMany network protocols on the Internet serve different purposes, some of which can be complex and sophisticated.\nBecause of their inherent complexity, security vulnerabilities in network applications are inevitable. Security holes in\nnetwork applications often yield a more significant security impact as compared to other attack vectors, as adversaries\nmay be able to leverage those vulnerabilities to gain remote code execution status on vulnerable computers without\nany user interactions. We have seen such attacks in real-life, such as the notorious WannaCry ransomware that\nexploited the Simple Message Block (SMB) protocol, dubbed EternalBlue, to attack Microsoft Windows computers by\nencrypting data and demanding ransom payments in Bitcoin cryptocurrency. To date, this malware is estimated to have\n[affected over 200,000 computers across 150 countries.](https://en.wikipedia.org/wiki/WannaCry_ransomware_attack)\n\nHardening network applications is a mission-critical task to minimize attack vectors like WannaCry. Threat researchers\nwork to ensure that many of the most popular network applications are properly secured using tools like network\nprotocol fuzzing. This vulnerability discovery technique sends malformed packets to the application being tested to\n\n\n-----\n\nuncover vulnerabilities in network protocol implementations. Finding and reporting these vulnerabilities, especially in\ncommonly used applications, help lower cyber risk for everyone.\n\nFortinet researchers join the rest of the threat research community in helping to achieve this goal. For this blog, we\ndocument the process of auditing and fuzzing the Microsoft Internet Message Access Protocol (IMAP) Client protocol.\nWhile we did not discover any new vulnerabilities, this step-by-step guide can help others looking to add or improve\nfuzzing technique strategies to their arsenal of threat discovery and analysis tools.\n\n## Why IMAP client protocol?\n\nNetwork applications use client and server architectures to exchange data. However, data interpretations between\nclient and server are different even if they share the same network protocol specifications. Data interpretation is\ntypically performed by parsers implemented in the respective components following individual specifications. Because\nof this, researchers have to inspect both the client and server to ensure that the parsers are correctly implemented.\n\nOur experience shows that servers receive more attention from researchers when auditing security implementations\nthan clients. However, it is also possible for a less secure client to contain low-hanging fruit that can be exploited. But\nsince we have not seen many IMAP client security issues publicly reported by vendors, we decided to look into IMAP\nclient implementations and, at the same time, gain some hands-on experience on the open source fuzzer, What The\nFuzz (WTF). WTF is a distributed, code-coverage guided, customizable, cross-platform snapshot-based fuzzer\ndesigned for attacking user and or kernel-mode targets running on Microsoft Windows.\n\nA spoiler here: there is no vulnerability disclosure in this article as we did not discover any security issues in the\nMicrosoft IMAP client. But we do share some rabbit holes, limitations we encountered, and tips and tricks on debugging\nthe WTF fuzzer module. We will also walk through the reversing process for one particularly interesting IMAP response\ninput that seemed vulnerable initially but, after digging into the code, was found to be benign.\n\n## Understanding the basic IMAP protocol\n\nIMAP client supports a wide range of commands for different IMAP operations. The client command begins an\noperation and expects a response from the server. Each client command is prefixed with an identifier known as “tag”.\nThis “tag” should be unique for every command sent by client. Generally, a client command looks like this:\n\n<tag> <command> <arg1 arg2 …>\n\nIt is important that clients must follow the syntax as per specification strictly. It is a syntax error to send a command with\nmissing or extraneous spaces or arguments.\n\nAn IMAP connection consists of the establishment of a client/server network connection, an initial greeting from the\nserver, and client/server interactions. These client/server interactions consist of a client command, server data, and a\nserver completion result response.\n\nAll interactions transmitted by client and server are in the form of lines, that is, strings that end with a carriage return\nand line feeds.\n\nThe first thing clients need to do is to make a connection to the remote server on a specific port. In this case, we use\nopenssl to connect to a custom IMAP server from a terminal.\n\n$ openssl s_client -connect 192.168.0.2:993 –crlf\n\n... server verifications removed for brevity...\n\n- OK IMAP4rev1 Service Ready\n\nNoticed that server status response is prefixed with “*”, called untagged response, that indicates server greeting, or\nserver status that does not indicate the completion of a command (for example, an impending system shutdown alert).\n\n\n-----\n\nThe next command the client typically send is CAPABILITY. The CAPABILITY command allows the client to get a listing\nof features that the server supports. Any features that are not listed in untagged response will be treated as BAD\ncommand by the server indicated in tagged response.\n\ntag1 CAPABILITY\n\n- CAPABILITY IMAP4rev1 LITERAL+ SASL-IR CHILDREN UNSELECT MOVE IDLE NAMESPACE CONDSTORE\nCOMPRESS=DEFLATE X-GM-EXT-1 METADATA ID APPENDLIMIT AUTH=PLAIN\n\ntag1 OK CAPABILITY completed\n\nStatus responses can be tagged or untagged. Tagged status responses indicate the completion result (OK, NO, or BAD\nstatus) of a client command, and have a prefixed tag matching the command.\n\nThe clients have to authenticate to the IMAP server before they are able to navigate the mailbox. There is some IMAP\nserver implementation that allows access to certain mailboxes anonymously. Like the following example, our custom\nIMAP server allows anonymous access. However, it is note-worthy that the list of capabilities for an authenticated client\nis usually different from the unauthenticated client. The logged-in client typically contains more unlocked features from\nthe IMAP server.\n\ntag2 LOGIN username password\n\ntag2 OK LOGIN completed\n\nNow that the client is logged in, it can list out folders exist in the mailbox\n\ntag3:LIST\n\n- LIST (HasNoChildren) \"/\" INBOX\n\ntag3 OK LIST completed\n\nHere we can see the folder hierarchy that exists in the mailbox. Folders have name attributes, indicated in parentheses.\nSome of attributes are useful for traversing the folder hierarchy, like HasNoChildren and HasChilden. The presence of\nHasNoChildren attribute indicates that the mailbox has no descendant mailboxes that are accessible to the currently\nauthenticated client.\n\nAfter knowing the folder structure of the mailbox, the client can open a session on the folder using SELECT command\nso that messages in the mailbox can be accessed.\n\ntag4 SELECT \"INBOX\"\n\n- FLAGS (Seen)\n\n- OK [PERMANENTFLAGS (\\*)] Flags permitted\n\n- 1 EXISTS\n\n- OK [UIDNEXT 7] Predicted next UID\n\n- OK [UIDVALIDITY 1] UIDs valid\n\ntag4 OK [READ-WRITE] SELECT completed\n\nWhen a selected state is returned, the server must send the above untagged data to the client before returning an OK\nto the client. If the selected state is established successfully, the client is said to be in the selected state and it can\nsearch and download messages from the mailbox.\n\ntag5 SEARCH ALL\n\n- SEARCH 1\n\ntag5 OK SEARCH completed\n\nThe SEARCH command searches the mailbox for messages that match the given searching criteria. The searching\ncriteria consist of one or more search keys. It can support a more comprehensive search criteria such as finding\nmessages that have a header with the specified field-name and that contains the specified string in the text of the\nheader. The above example shows the simplest form of SEARCH command that will search all the available messages\nin the server. The untagged response indicates that there is one message available in the custom IMAP server.\n\n\n-----\n\nSome clients provides preview of the email message. This can be done by using FETCH command to download the\nmessage header only. While UID FETCH command will download the whole email message and store it locally in the\nclient application.\n\ntag6 UID FETCH 6 (RFC822.HEADER BODY.PEEK[1])\n\n- 1 FETCH (RFC822.HEADER {194}\n\nFrom: [contact@example.org](mailto:contact@example.org)\n\nTo: [contact@example.org](mailto:contact@example.org)\n\nSubject: A little message, just for you\nDate: Wed, 22 Mar 2022 14:31:59 +0000\n\nMessage-ID: <0000000@localhost/>\n\nContent-Type: text/plain\n\nBODY[1] {11}\n\nHi there :) UID 6)\n\ntag6 OK UID FETCH completed\n\nFigure 1: IMAP client-server’s state and flow diagram. Adapted from IETF Internet Message Access Protocol (IMAP) Version 4rev2\n\n## The unpaved road to the IMAP client fuzzer\n\nA harness is required to drive the fuzzing operation along with the primary fuzzer program in modern fuzzing. While this\nis not mandatory for the WTF fuzzer, a dedicated fuzzer module is required. If you have experience with AFL/WinAFL,\na lot of time will be spent on writing an effective harness program, but you will spend most of your time developing and\ntroubleshooting the WTF fuzzer module. Under the hood, the WTF fuzzer acts as an emulator that programmatically\nemulates codes within a memory dump driven by the fuzzer module. Basically, the core of a fuzzer module consists of a\nfunction breakpoint and breakpoint handlers. These breakpoint handlers are comprised of logics that serve different\npurposes, such as intercepting and modifying input data consumed by the target and replicating functions such as I/O\noperations, registry operations, and thread scheduling. The project’s repository provides a comprehensive guideline for\nthe fuzzer development process.\n\nAs a starting point, you have to identify the target component you want to fuzz and dump a snapshot of a virtual image\nto be consumed by the fuzzer module. According to the documentation from the project’s repository, this snapshot\nimage is typically taken from the entry point of the target module of interest, where parser routines consume input data.\nIn the case of the Microsoft IMAP client, InternetMail.dll is the target component that implements both the IMAP and\nPOP3 client protocol. This DLL module is hosted by the Windows host process for services, also known as\nsvchost.exe.\n\nWindows Mail is the front-end user interface (UI) interacting with this module, which means the UI enables a user to set\nup an IMAP account and download email messages from an email server. While writing our IMAP client fuzzer module,\nwe encountered many obstacles, some of which are, luckily, partially documented in the project’s issue tracker. While\nthe majority of the hindrances are pretty specific to whatever target you are working on, we thought it might be helpful\nto document these challenges and our workarounds.\n\n## Preparation for IMAP client fuzzer module development\n\nPreparation is the key to success. This is especially true when using a new fuzzer. Writing a fuzzer module for the WTF\nfuzzer is not an easy task. This is because we are trying to emulate code from a memory dump. In the software\nemulation world, you cannot expect emulated code to behave the same as the code executed on a native device.\nBecause of this, there are numerous roadblocks to resolve to make the emulation work as intended. So, it is essential\nto determine the proper tools to trace and debug the fuzzer module before starting.\n\n\n-----\n\nWTF fuzzer supports two types of trace files, coverage trace log and Tenet trace file. Basically, a coverage trace log\ncontains the traces for each of the instructions being executed by the emulator. It helps diagnose most of the fuzzer\nmodule issues. A Tenet trace file contains each of the executed instructions plus memory/stack data manipulated by\neach instruction. The Tenet plugin can only consume a Tenet trace file. [Tenet is an excellent trace-record-and-replay](https://github.com/gaasedelen/tenet)\nIDA Pro plugin useful for offline debugging. The Tenet trace file generated by the WTF fuzzer can be replayed through\nIDA Pro. From there, it allows users to explore executed code and even analyze the data read/write into memory/stack,\nmaking debugging and troubleshooting the fuzzer module much easier.\n\nHowever, the caveat is that the plugin takes a very long time to process a recorded trace file if it is too large. For\nexample, a trace file a few gigabytes in size can easily occupy most of the host memory, which could fail to replay the\ntraces through IDA Pro. As a workaround, we introduce a “--trace-starting-address” command line parameter to the\nWTF fuzzer so the fuzzer will begin its tracer only when it hits a specified address. This newly introduced command line\nparameter significantly reduced the trace files' size. However, the results of this filtering mechanism do not turn out to\nbe very successful in some cases. We sometimes still get a large trace file because the starting address in the function\nof interest is not unique. For example, the function could be triggered in multiple locations that are non-deterministic,\ncausing the tracer to fire unexpectedly, which defeats our objective.\n\nFigure 2: Simple filtering for Tenet traces\n\nAfter some experiments, we found the Time-Travel-Debugging (TTD) feature from WinDbg Preview that can serve the\nsame purpose for offline debugging. WinDbg Preview will attach a running process and inject a TTD proprietary tracer\nDLL into the target process. The injected tracer DLL is responsible for capturing the runtime execution of the target\nprocess and keeping the executed code in the trace file stored in the physical disk. To simulate this process, we\ncreated a simple IMAP server that reads IMAP packets defined in JSON format and sends the packets to the\nconnected client, Windows Mail, when the IMAP connection is established. At the same time, WinDbg Preview is\nattached to the Windows host process for service to record the code execution. The catch for this approach is you can\nonly manually generate one execution trace at a time. However, TTD is still a helpful feature that complements the\noffline debugging experience.\n\nFigure 3: Alternative approach to generating code execution traces for the target executable\n\nAnother use case leverages differential debugging techniques by comparing the traces generated by TTD and Tenet to\ndeeply troubleshoot more problematic issues from your fuzzer module. Nevertheless, Tenet is still the first option for\ntrace file generation to debug more complex issues encountered during fuzzer module development.\n\nIn the rest of this article, we will share some tips and tricks on pinpointing some of the more apparent issues directly\nfrom the coverage trace log instead of using a Tenet trace file. This can hopefully save you time on fuzzer module\ndevelopment.\n\n## Developing an IMAP client fuzzer module\n\nThe WTF fuzzer module works on top of the WTF framework. Each fuzzer module has to implement callback functions\nregistered by the WTF framework and later triggered from the WTF executable. We will not cover the development\ndetails here since the project’s repository includes step-by-step guidelines.\n\nIMAP includes operations for creating, deleting, and renaming mailboxes, checking for new messages, permanently\nremoving messages, setting and clearing flags, and the selective fetching of message attributes and texts. As a result,\nimplementing a comprehensive mutation strategy for the IMAP protocol could be time-killing. In our case, we only\nfocused on specific IMAP commands that Windows Mail uses to interact with an IMAP server. First, we attached the\nWinDbg Preview debugger to the target process to generate execution traces for Windows Mail interacting with a realworld IMAP server (Gmail) to collect the typical commands in IMAP transactions. Listing 1 shows the debugger's\noutput, consisting of IMAP commands sent to the Gmail server by a Windows Mail client.\n\n0:000> bp InternetMail!ImapCommunicationManager::_IssueCommandRaw+0x2b \".printf \\\"_SendText: %ma\\\\n\\\",\nrdx;gc\"\n\n\n-----\n\nbreakpoint 0 redefined\n\n0:000> g\n\nModLoad: 00007ff9`8fcc0000 00007ff9`8fd9b000  c:\\windows\\system32\\efswrt.dll\n\nModLoad: 00007ff9`a22a0000 00007ff9`a22e5000  C:\\Windows\\SYSTEM32\\feclient.dll\n\nModLoad: 00000241`a5a30000 00000241`a5a34000  C:\\Windows\\System32\\UserDataAccessRes.dll\n\nModLoad: 00007ff9`c9380000 00007ff9`c9401000  C:\\Windows\\System32\\fwpuclnt.dll\n\n_SendText: A2 NOOP\n\n_SendText: A3 CAPABILITY\n\n_SendText: A4 ID (\"vendor\" \"Microsoft\" \"os\" \"Windows Mobile\" \"os-version\" \"10.0\" \"guid\"\n\"45363445433632373438364639394335353946323134423434313739434334344239413838323431\")\n\n_SendText: A5 LOGIN \"censoredusername\" \"censoredpassword\"\n\n_SendText: A6 NAMESPACE\n\n_SendText: A7 LIST \"\" %\n\n_SendText: A8 LIST \"[Gmail]/\" *\n\n_SendText: A9 SELECT \"INBOX\" (CONDSTORE)\n\n_SendText: A10 SEARCH UNDELETED SINCE 28-Jun-2022\n\n_SendText: A11 FETCH 89:90 (INTERNALDATE UID FLAGS X-GM-THRID RFC822.SIZE\nBODY.PEEK[HEADER.FIELDS (DATE FROM SUBJECT CONTENT-TYPE X-MS-TNEF-Correlator CONTENT-CLASS\nIMPORTANCE PRIORITY X-PRIORITY THREAD-TOPIC REPLY-TO)] BODYSTRUCTURE)\n\nModLoad: 00007ff9`cbef0000 00007ff9`cc09e000  C:\\Windows\\system32\\windowscodecs.dll\n\n_SendText: A12 UID FETCH 219 (RFC822.HEADER BODY.PEEK[1.2] BODY.PEEK[2])\n\n_SendText: A13 UID FETCH 220 (RFC822.HEADER BODY.PEEK[2])\n\n_SendText: A14 SELECT \"INBOX\" (CONDSTORE)\n\n_SendText: A15 SEARCH UNDELETED SINCE 1-Apr-2022\n\n_SendText: A16 FETCH 58:90 (INTERNALDATE UID FLAGS X-GM-THRID RFC822.SIZE\nBODY.PEEK[HEADER.FIELDS (DATE FROM SUBJECT CONTENT-TYPE X-MS-TNEF-Correlator CONTENT-CLASS\nIMPORTANCE PRIORITY X-PRIORITY THREAD-TOPIC REPLY-TO)] BODYSTRUCTURE)\n\n_SendText: A17 SELECT \"INBOX\" (CONDSTORE)\n\nListing 1: Debugger output IMAP commands sent by a Windows Mail client\n\nHere, our mutation approach focuses on IMAP responses for NAMESPACE, LIST, SELECT, SEARCH, and FETCH\ncommands. We decided to skip fuzzing the UID FETCH command because this response handler involves read/write to\na message database in the local filesystem. Unfortunately, this operation cannot be trivially implemented for our case,\neven if WTF provides an I/O subsystem emulation framework by default. We thought this was a fair tradeoff as most of\nthe important parsing operations, such as message header parsers, take place in the FETCH command.\n\n\n-----\n\n[An IMAP packet consists of a series of structured text messages defined by the specification here. Therefore, our IMAP](https://datatracker.ietf.org/doc/html/rfc9051)\npacket mutation strategy also needs to be structure-aware. Inspired by the famous structure-aware mutation library\nlibprotobuf-mutator, we used a JSON file format to store each mutated IMAP response. This JSON file will serve as an\ninput test case to the fuzzer module. As per specification, the JSON object's critical component is the\n_ResponseParams, which consists of core data that the IMAP client will interpret. Nevertheless, our mutator will focus on_\nmutating data from ResponseParams, ResponseStatus, and ResponseType.\n\n{\n\n\"Packets\": [\n\n{\n\n\"Command\": \"NAMESPACE\",\n\n\"ResponseParams\": [\n\n[\n\n\"NIL NIL ((\\\"\\\" \\\".\\\"))\"\n\n]\n\n],\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A6\",\n\n\"ResponseType\": 42\n\n},\n\n{\n\n\"Command\": \"LIST\",\n\n\"ResponseParams\": [\n\n[\n\n\"() \\\"/\\\" \\\"INBOX\\\"\"\n\n]\n\n],\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A7\",\n\n\"ResponseType\": 42\n\n},\n\n{\n\n\"Command\": \"LIST\",\n\n\"ResponseParams\": [\n\n\n-----\n\n[\n\n\"(\\\\All \\\\HasNoChildren) \\\"/\\\" \\\"INBOX/All Mail\\\"\"\n\n]\n\n],\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A8\",\n\n\"ResponseType\": 42\n\n},\n\n{\n\n\"Command\": \"SELECT\",\n\n\"ResponseParams\": [\n\n[\n\n\"* FLAGS (\\\\Seen)\",\n\n\"* OK [PERMANENTFLAGS (\\\\*)] Flags permitted\",\n\n\"* 1 EXISTS\",\n\n\"* 0 RECENT\",\n\n\"* OK [UIDNEXT 7] Predicted next UID\",\n\n\"* OK [UIDVALIDITY 1] UIDs valid\"\n\n]\n\n],\n\n\"ResponseStatus\": \"OK [READ-WRITE]\",\n\n\"ResponseTag\": \"A9\",\n\n\"ResponseType\": 42\n\n},\n\n{\n\n\"Command\": \"SEARCH\",\n\n\"ResponseParams\": [\n\n[\n\n\"SEARCH 1\"\n\n]\n\n],\n\n\n-----\n\nResponseStatus : OK,\n\n\"ResponseTag\": \"A10\",\n\n\"ResponseType\": 42\n\n},\n\n{\n\n\"Command\": \"FETCH\",\n\n\"ResponseParams\": [\n\n[\n\n\"38 FETCH\",\n\n\"UID 6\",\n\n\"INTERNALDATE \\\"31-Mar-2022 24:59:59 +0800\\\"\",\n\n\"FLAGS (\\\\Seen ks6JUz2l )\",\n\n\"RFC822.SIZE 433313086\",\n\n\"X-GM-THRID \",\n\n\"BODYSTRUCTURE (\\\"report\\\" \\\"alternative\\\" (\\\"attachment\\\" \\\"(\\\"filename\\\" \\\"winmail.dat\\\")\\\" \\\"charset\\\" \\\"\n(\\\"filename\\\" \\\"winmail.dat\\\")\\\" \\\"\\\" \\\"\\\" \\\"charset\\\" \\\"us-ascii\\\" \\\"charset\\\" \\\"utf-8\\\") i.DS. I3j7]iQxo:hxfSl \\\"BASE64\\\" 26 )\",\n\n\"BODY[HEADER.FIELDS (DATE FROM SUBJECT CONTENT-TYPE X-MS-TNEF-Correlator CONTENT-CLASS\nIMPORTANCE PRIORITY X-PRIORITY THREAD-TOPIC REPLY-TO)] {671}\\r\\nContent-Duration: 5725206\\r\\nContentType: \\u0002\\r\\nDate: Wed, 22\\n Feb 2022 10:08:--62094 \\r\\nFrom: sample <sample@sample.com>\\r\\nMIME-Version:\n97.56\\r\\nMessage-Context: voide 󠀪󠁕\\r\\nReceived: from DB5EUR03FT058.eop-EUR03.prod.protection.outlook.com\n(2603:10a6:6:2d:cafe::b0)\\r\\nby DB6PR07CA0011.outlook.office365.com(2603:10a6:6:2d::21)\\r\\nwith Microsoft SMTP\nServer(version = TLS1_2,cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)\\r\\nid 15.20.4352.8\\r\\nvia\nFrontend Transport; Wed, 14 Jul 2021 05:46:31 +0000\\r\\nReply-To:\nexample/example\\r\\n<reply+ABFSGURWRY340282366920938463463374607431768211458OIKSMTFLHORW\\r\\nReturnPath: sampleʱ\\r\\nSubject: Example message\\r\\nX-MS-TNEF-Correlator: \\r\\n\"ᅟ\n\n]\n\n],\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A11\",\n\n\"ResponseType\": 42\n\n}\n\n]\n\n}\n\nListing 2: Sample IMAP response input test case\n\n## Challenge #1: Extensible Storage Engine cache clean up\n\n\n-----\n\nWindows Mail utilizes a unified store database to keep email data, such as email addresses and messages, in a local\nfile system. This database is located on path %LOCALAPPDATA%\\Comms\\UnistoreDB\\store.vol. The Extensible\nStorage Engine (ESENT) builds the database using a proprietary binary format for its data structure. This binary format\n[can be viewed using a tool like ESEDatabaseView. The benefit of using ESENT is that it has a caching mechanism to](https://www.nirsoft.net/utils/ese_database_view.html)\nmaximize high-performance access to data. It is this caching mechanism that gives us our first roadblock.\n\nUnder the hood, the cache buffer is allocated a size based on the ESENT parameter JET_paramVerPageSize that is\ninitialized when the system service initiates UserDataService. The default cache size is 0x2000 and must be aligned\nwith page size granularity. However, this becomes an issue in the context of the WTF fuzzer module.\n\nThe problem is that ESENT will queue a work item to purge the cache buffer when the cache buffer is full. A work item\nis a subroutine that a program can submit to a thread pool. The work item is executed asynchronously and will be\nalerted by the scheduler system based on the availability of system resources. Unfortunately, it is a complex\nmechanism that the WTF fuzzer cannot emulate. as a result, the fuzzer module will exit during context switch when it\nhits threading APIs (e.g., KERNELBASE!QueueUserWorkItem). It is a waste of CPU time to let the fuzzer go beyond\nthe context switch. This is the reason why you should find a similar breakpoint handler in every WTF fuzzer module that\nlooks like Figure 4:\n\nFigure 4: Breakpoint handler to stop the fuzzer module during a context switch\n\nWhen an unexpected context switch occurs, the author must understand why it happened and implement workarounds\nto reach the desired code path. This can be done by analyzing the coverage trace log generated by the WTF fuzzer\nand post-processed by 0vercl0k’s [Symbolizer. An example of a coverage trace log that stops at a context switch is](https://github.com/0vercl0k/symbolizer)\nshown in Figure 5:\n\nFigure 5: Example of a coverage trace log generated via Symbolizer\n\nThere are no sophisticated tricks here to analyze the coverage trace log. We simply do backtracking to locate a module\nor function transition (i.e., modA!funcnameX -> modB!funcnameY) to discover the cause of the context switch.\nTypically, we load the module file into IDA Pro to statistically study and understand the underlying code. Sometimes, it\nmight not be sufficient to perform static code analysis, especially if the code includes virtual function calls that cannot\nbe resolved automatically by IDA Pro. Instead, you can use TTD to resolve the virtual function call or explore the\nexecuted code.\n\nFigure 6: Coverage trace log reveals the cause of a context switch\n\nFigure 6 shows that ESENT!CGPTaskManager::ErrTMPost+0xd4 calls KERNELBASE!QueueUserWorkItem,\nessentially placing an executable thread in the thread pool queue, while ESENT!CGPTaskManager::ErrTMPost is\nderived from ESENT!VER::VERSignalCleanup. After a deep dive in analyzing the function, with the help of TTD, we\ndetermined the purpose of ESENT!VER::VERSignalCleanup compares the current buffer cache size against the default\ncache size specified via JET_paramVerPageSize. It calls QueueUserWorkItem to execute the cache cleanup thread,\n_ESENT!_ _VER::VERIRCECleanProc, if the current cache buffer is filled up, which eventually results in a context switch._\nSo, our challenge is to find a way to prevent the cleanup procedure from being triggered.\n\nOur first thought was that the simplest workaround would be to increase the default cache size from 0x2000 to its\nmaximum size of 0x10000. Technically, the configuration settings for the database engine can be adjusted using the\nAPI JetSetSystemParameter, as per MSDN documentation. But we cannot achieve this goal using an external program\nto change settings that reside in an isolated system service process space.\n\n# RetAddr      : Call Site\n\n00 00007ff9`d9773c38 : ESENT!SetConfiguration+0xce\n\n01 00007ff9`d9773adf : ESENT!ErrSetSystemParameter+0x10c\n\n02 00007ff9`d9772fe1 : ESENT!JetSetSystemParameterEx+0x203\n\n\n-----\n\n03 00007ff9 d9772e83 : ESENT!JetSetSystemParameterExA+0x65\n\n04 00007ff9`cc099d77 : ESENT!JetSetSystemParameterA+0x53\n\n05 00007ff9`cc099e12 : UserDataPlatformHelperUtil!SetJetSystemParameter+0x2f\n\n06 00007ff9`e833627a : UserDataPlatformHelperUtil!SetParametersInitOnce+0x32\n\n07 00007ff9`e5d709b1 : ntdll!RtlRunOnceExecuteOnce+0x9a\n\n08 00007ff9`cc09a199 : KERNELBASE!InitOnceExecuteOnce+0x21\n\n09 00007ff9`8cb98280 : UserDataPlatformHelperUtil!SetCommsServiceJetGlobalSystemParameters+0x29 0a\n00007ff9`8cb909d6 : unistore!DBManager::_InitializeJetInstance+0x134\n\n0b 00007ff9`8cb908bd : unistore!DBManager::InitializeDeviceVolumeImpl+0x32\n\n0c 00007ff9`8cb786e2 : unistore!DBManager::InitializeDeviceVolume+0xd9\n\n0d 00007ff9`8cc02743 : unistore!DBManager::GetInstance+0x8c\n\n0e 00007ff9`8cbb49a0 : unistore!ObjectCollection::Init+0x7b\n\n0f 00007ff9`8cbb8c5e : unistore!CFactory::CreateObjectCollection+0x80\n\n10 00007ff9`8cbb7a57 : unistore!CStoreManager::GetStoreCollection+0x9e\n\n11 00007ff9`8cbb6faf : unistore!CStoreManager::FinalConstruct+0xd7\n\n12 00007ff9`8cbb7050 : unistore!ATL::CComObject<CStoreManager>::CreateInstance+0x5f\n\n13 00007ff9`8cb86cca : unistore!CStoreManager::CreateInstance+0x50\n\n14 00007ff9`8cb86d6b : unistore!_CreateInprocStoreManager+0x12e\n\n15 00007ff9`8cb87373 : unistore!_CreateStoreManager+0x77\n\n16 00007ff9`8cb8730f : unistore!CreateStoreManagerWithToken+0x23\n\n17 00007ff9`a9f1050e : unistore!CreateStoreManager+0xaf\n\n18 00007ff9`a9f117e0 : CEMAPI!GetStoreManagerCache+0x12\n\n19 00007ff9`a9f0e407 : CEMAPI!MapiCtx::_GetSingletonInstance+0x6c\n\n1a 00007ff9`a9f0e5fa : CEMAPI!LogonMapi+0x97\n\n1b 00007ff9`8c6fa92c : CEMAPI!MAPILogonEx+0x5a\n\n1c 00007ff9`8c6f5738 : MessagingDataModel2!CSmStore::FinalConstruct+0x64\n\n1d 00007ff9`8c6f3794 : MessagingDataModel2!ATL::CComCreator<ATL::CComObject<CSmStore>\n>::CreateInstance+0xc0\n\n1e 00007ff9`e6e7aa6d : MessagingDataModel2!ATL::CComClassFactory::CreateInstance+0x64\n\n1f 00007ff9`e6e8baef : combase!CServerContextActivator::CreateInstance+0x1fd\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 874]\n\n20 00007ff9`e6e79c4c : combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n\n-----\n\n21 00007ff9 e6ee5b28 : combase!CApartmentActivator::CreateInstance+0xcc\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 2178]\n\n22 00007ff9`e6eecaac : combase!CProcessActivator::CCICallback+0x68 [onecore\\com\\combase\\objact\\actvator.cxx\n@ 1617]\n\n23 00007ff9`e6ee1bfe : combase!CProcessActivator::AttemptActivation+0x4c\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1504]\n\n24 00007ff9`e6e7a844 : combase!CProcessActivator::ActivateByContext+0x9e\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1348]\n\n25 00007ff9`e6e8baef : combase!CProcessActivator::CreateInstance+0x94 [onecore\\com\\combase\\objact\\actvator.cxx\n@ 1248]\n\n26 00007ff9`e6e7b604 : combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n27 00007ff9`e6e8baef : combase!CClientContextActivator::CreateInstance+0x124\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 558]\n\n28 00007ff9`e6e8eb83 : combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n29 00007ff9`e6e8e125 : combase!ICoCreateInstanceEx+0x8a3 [onecore\\com\\combase\\objact\\objact.cxx @ 1931]\n\n2a 00007ff9`e6e8df5c : combase!CComActivator::DoCreateInstance+0x175 [onecore\\com\\combase\\objact\\immact.hxx\n@ 388]\n\n2b (Inline Function) : combase!CoCreateInstanceEx+0xd1 [onecore\\com\\combase\\objact\\actapi.cxx @ 320]\n\n2c 00007ff9`8c76c607 : combase!CoCreateInstance+0x10c [onecore\\com\\combase\\objact\\actapi.cxx @ 264]\n\n2d 00007ff9`8c76c2e0 : MessagingDataModel2!MessagingNotificationFactory::CreateNotificationManager+0x53\n\n2e 00007ff9`8c86be4a : MessagingDataModel2!Messaging_StartNotification+0x30\n\n2f 00007ff9`8c922a02 : userdataservice!DataModelService::OnStarted+0x9a\n\n30 00007ff9`8c9223c9 : userdataservice!ServiceBase::_ServiceMainInner+0x126\n\n31 00007ff6`8e23296e : userdataservice!ServiceBase::ServiceMain+0x71\n\n32 00007ff9`e71b0752 : svchost!ServiceStarter+0x5fe\n\n33 00007ff9`e75054e0 : sechost!ScSvcctrlThreadW+0x32\n\n34 00007ff9`e832485b : KERNEL32!BaseThreadInitThunk+0x10\n\n35 00000000`00000000 : ntdll!RtlUserThreadStart+0x2b\n\nListing 3: Call-stack that shows the system host service set database engine configuration settings\n\nLooking at the call-stack in Listing 3, we then thought of tackling this issue by hijacking UserDataService and adjusting\nthe default cache size hard coded at a specific offset in ESENT.dll before the database engine configuration setting\ntook place. We decided to give it a shot.\n\nHijacking a service DLL is straightforward. We can locate the target service registry entry, which is defined under:\n\n\n-----\n\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UserDataSvc\\Parameters\nServiceDLL= %SystemRoot%\\System32\\userdataservice.dll\n\nWhen the ServiceDLL entry is adjusted to our custom service DLL file, it will become:\n\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UserDataSvc\\Parameters\n\nServiceDLL=c:\\userdatasvc\\UserDataSvcProxy.dll\n\nThe custom service DLL exports two mandatory mockup functions, ServiceMain and SvchostPushServiceGlobals. After\nmodifying the above registry entry, the system service will load the custom service DLL, which executes the mockup\n_ServiceMain function. The mockup ServiceMain function will patch JET_paramVerPageSize at a specific offset in_\nESENT.dll. After patching, it will pass the execution to the initial ServiceMain function exported by UserDataService and\ncontinue its initial routine as usual.\n\n[The complete source code of the custom service DLL is available here.](https://github.com/x9090/UserDataSvcProxy/blob/main/UserDataSvcProxy/ServiceMain.cpp)\n\n# Child-SP     RetAddr        Call Site\n\n00 000000a6`d807d3d8 00007ff9`c86209d6   unistore!DBManager::_InitializeJetInstance+0x5\n\n01 000000a6`d807d3e0 00007ff9`c86208bd   unistore!DBManager::InitializeDeviceVolumeImpl+0x32\n\n02 000000a6`d807d420 00007ff9`c86086e2   unistore!DBManager::InitializeDeviceVolume+0xd9\n\n03 000000a6`d807d490 00007ff9`c8692743   unistore!DBManager::GetInstance+0x8c\n\n04 000000a6`d807d4e0 00007ff9`c86449a0   unistore!ObjectCollection::Init+0x7b\n\n05 000000a6`d807d710 00007ff9`c8648c5e   unistore!CFactory::CreateObjectCollection+0x80\n\n06 000000a6`d807d770 00007ff9`c8647a57   unistore!CStoreManager::GetStoreCollection+0x9e\n\n07 000000a6`d807d7e0 00007ff9`c8646faf   unistore!CStoreManager::FinalConstruct+0xd7\n\n08 000000a6`d807d8e0 00007ff9`c8647050   unistore!ATL::CComObject<CStoreManager>::CreateInstance+0x5f\n\n09 000000a6`d807d910 00007ff9`c8616cca   unistore!CStoreManager::CreateInstance+0x50\n\n0a 000000a6`d807d950 00007ff9`c8616d6b   unistore!_CreateInprocStoreManager+0x12e\n\n0b 000000a6`d807d990 00007ff9`c8617373   unistore!_CreateStoreManager+0x77\n\n0c 000000a6`d807da20 00007ff9`c861730f   unistore!CreateStoreManagerWithToken+0x23\n\n0d 000000a6`d807da70 00007ff9`c91a050e   unistore!CreateStoreManager+0xaf\n\n0e 000000a6`d807dab0 00007ff9`c91a17e0   CEMAPI!GetStoreManagerCache+0x12\n\n0f 000000a6`d807daf0 00007ff9`c919e407   CEMAPI!MapiCtx::_GetSingletonInstance+0x6c\n\n10 000000a6`d807db30 00007ff9`c919e5fa   CEMAPI!LogonMapi+0x97\n\n11 000000a6`d807db70 00007ff9`9b1aa92c   CEMAPI!MAPILogonEx+0x5a\n\n12 000000a6`d807dbd0 00007ff9`9b1a5738   MessagingDataModel2!CSmStore::FinalConstruct+0x64\n\n13 000000a6`d807dc20 00007ff9`9b1a3794\nMessagingDataModel2!ATL::CComCreator<ATL::CComObject<CSmStore> >::CreateInstance+0xc0\n\n14 000000a6`d807dc60 00007ff9`e4adaa6d   MessagingDataModel2!ATL::CComClassFactory::CreateInstance+0x64\n\n\n-----\n\n15 000000a6 d807dc90 00007ff9 e4aebaef   combase!CServerContextActivator::CreateInstance+0x1fd\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 874]\n\n16 000000a6`d807de10 00007ff9`e4ad9c4c   combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n17 000000a6`d807dea0 00007ff9`e4b45b28   combase!CApartmentActivator::CreateInstance+0xcc\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 2178]\n\n18 000000a6`d807df50 00007ff9`e4b4caac   combase!CProcessActivator::CCICallback+0x68\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1617]\n\n19 000000a6`d807dfa0 00007ff9`e4b41bfe   combase!CProcessActivator::AttemptActivation+0x4c\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1504]\n\n1a 000000a6`d807dff0 00007ff9`e4ada844   combase!CProcessActivator::ActivateByContext+0x9e\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1348]\n\n1b 000000a6`d807e080 00007ff9`e4aebaef   combase!CProcessActivator::CreateInstance+0x94\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 1248]\n\n1c 000000a6`d807e0d0 00007ff9`e4adb604   combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n1d 000000a6`d807e160 00007ff9`e4aebaef   combase!CClientContextActivator::CreateInstance+0x124\n\n[onecore\\com\\combase\\objact\\actvator.cxx @ 558]\n\n1e 000000a6`d807e200 00007ff9`e4aeeb83   combase!ActivationPropertiesIn::DelegateCreateInstance+0x8f\n\n[onecore\\com\\combase\\actprops\\actprops.cxx @ 1960]\n\n1f 000000a6`d807e290 00007ff9`e4aee125   combase!ICoCreateInstanceEx+0x8a3\n\n[onecore\\com\\combase\\objact\\objact.cxx @ 1931]\n\n20 000000a6`d807ef30 00007ff9`e4aedf5c   combase!CComActivator::DoCreateInstance+0x175\n\n[onecore\\com\\combase\\objact\\immact.hxx @ 388]\n\n21 (Inline Function) --------`--------   combase!CoCreateInstanceEx+0xd1 [onecore\\com\\combase\\objact\\actapi.cxx @\n320]\n\n22 000000a6`d807f070 00007ff9`9b21c607   combase!CoCreateInstance+0x10c\n\n[onecore\\com\\combase\\objact\\actapi.cxx @ 264]\n\n23 000000a6`d807f110 00007ff9`9b21c2e0\nMessagingDataModel2!MessagingNotificationFactory::CreateNotificationManager+0x53\n\n24 000000a6`d807f190 00007ff9`a458be4a   MessagingDataModel2!Messaging_StartNotification+0x30\n\n25 000000a6`d807f1d0 00007ff9`a4642a02   UserDataService!DataModelService::OnStarted+0x9a\n\n26 000000a6`d807f2f0 00007ff9`a46423c9   UserDataService!ServiceBase::_ServiceMainInner+0x126\n\n27 000000a6`d807f320 00007ff9`9b340ca7   UserDataService!ServiceBase::ServiceMain+0x71\n\n28 000000a6`d807f350 00007ff9`9b333666   userdatasvcproxy!SvchostPushServiceGlobals+0xcaf2\n\n29 000000a6`d807f358 000000a6`d807f3e8   userdatasvcproxy!ServiceMain\n\nListing 4: Call-stack that shows the custom service DLL hijacking UserDataService\n\n\n-----\n\nAfter everything was set, we ran the fuzzer module against the new snapshot image with the custom service DLL\nloaded that should adjust the cache size to 0x10000. But unfortunately, it still hits= the cleanup procedure. So, we\nneeded to figure out another workaround.\n\nWe looked into the ESENT!VER::VERSignalCleanup but realizes that the function does not return a value to the caller\nfunction, which made us believe that the function routine does not care whether this cleanup procedure has been\nexecuted successfully or not. On top of that, it does not seem to keep track of any global state or event that would\npotentially cause unexpected behavior in ESENT. Considering all this, we decided to skip this cleanup procedure by\nsimply setting a breakpoint to simulate this function by returning to the caller immediately when the breakpoint is hit, as\nshown in Figure 7:\n\nFigure 7: Skipping ESENT!VER::VERSignalCleanup to avoid context switch\n\nAnd voila! Our fuzzer module can execute beyond the cleanup procedure without hitting a context switch! However, the\ncaveat is that this could potentially grow memory usage substantially inside the snapshot image. But this should not\npose any potential issues to us, as the snapshot image will revert to its original state once a fuzzing iteration is\ncompleted. In other words, the dangling cache buffers are negligible.\n\n## Challenge #2 Loading an unloaded DLL and executing paged out memory\n\nIf you are familiar with software emulation, you understand that making an emulator behave like a native machine is\nimpossible. The same thing applies to the WTF fuzzer. We need to find workarounds when such limitations arise. But\nsome workarounds could be straightforward depending on the complexity of the limitations face, with some\nworkarounds as simple as tweaking the snapshot image.\n\nThe next issue we encountered is that a context switch happens when WTF attempts to load an unloaded DLL file from\nthe file system. Again, we determined the root cause of the issue by analyzing the coverage trace log and some code\nsnippets, shown in Figure 8. From the coverage trace log, we can tell that the CoCreateInstance API is called from\n_MCCSEngineShared!Decode2047Header+0xfe. This COM API is responsible for loading a COM object specified in a_\nclass ID, which in this case is CLSID_CMultiLanguage. This class ID corresponds to\nC:\\WINDOWS\\SYSTEM32\\mlang.dll.\n\nFigure 8: Diagnosis of loading an unloaded DLL file\n\nWith this information, we manually injected the COM object DLL into the target process, dumped the image as a new\nsnapshot, and tested it. As a result, it went beyond MCCSEngineShared!Decode2047Header, which is good, but we\nfaced another issue.\n\nFigure 9: Yet another context switch due to a memory access error\n\nUpon looking into the coverage trace log in Figure 9, we realized an unusual code execution transition from user-mode\n_exsmime!CMimeReader::FindBoundary to kernel-mode nt!MiUserFault happens. Our experience indicates that the_\nemulator may have hit a reserved memory address or memory address swapped out to a page file. This is a common\nWindows memory management mechanism to keep infrequently used memory in a page file for performance reasons.\nTo verify that, we used WinDbg debugger to load the memory dump and examined the code specified at\n_exsmime!CMimeReader::FindBoundary+0x4f, as shown in Figure 10._\n\nFigure 10: Memory access error when calling a virtual function\n\nIt calls a virtual function from the virtual function table but the destination of the virtual function,\n_exsmime!CHdrContentType::value, is determined via TTD snapshot, as shown in Figure 11:_\n\nFigure 11: Using TTD to determine the destination address of the virtual function\n\n[To work around this memory access issue, we ran the lockmem utility, which ensures that every available memory](https://github.com/0vercl0k/lockmem)\nregion of a specified process will persist in memory so it will not be written to a page file, which incurs page fault on\naccess For the best result performing a complete memory dump is always recommended to avoid other unforeseen\n\n\n-----\n\nmemory access issues. This tip is especially useful when you are fuzzing a kernel mode component.\n\n## Challenge #3 Registry hooks\n\nWindows registry is a hierarchical database that stores low-level settings for the Windows operating system and\napplications. This database keeps the information of registry hives in the file system. In other words, a registry\noperation involves I/O operations to some extent. Neither of these operations is supported by an emulator, so we need\nto replicate these functionalities.\n\nAt the time of writing, WTF provides a fshook subsystem to replicate I/O operations but not registry hook (reghook\nthereafter). Apparently, we cannot reuse fshook for reghook because they are different APIs, but we can adapt some of\nthe implementations from fshook into reghook. For example, we can reuse the pseudo-handle algorithm in fshook and\nRegHandleTable_t class. The critical difference between fshook and reghook is how the intended contents (i.e., file\ncontents for I/O operations and registry data for registry operations) are emulated. For reghook, if a registry operation is\ngoing to open a new handle, for example, the RegOpenKey API is called to open a handle to a particular registry key.\nIts corresponding hook handler redirects the API call to the native machine. In other words, the native device will\nattempt to open the registry key using the native API and return the handle if the registry key exists. The opened handle\nis valid for the native machine but not the guest machine that is the memory dump. So, a pseudo-handle should be\n[generated and mapped to the native handle. The current implementation of reghook can be found here.](https://github.com/x9090/wtf/blob/custom/src/wtf/reghooks.cc)\n\nTo reiterate, the current reghook implementation is incomplete and not being tested comprehensively for other targets.\nBut it should be reasonably straightforward to expand the existing reghook to support other registry APIs.\n\n## The curious case of RFC822.SIZE\n\nAfter deploying and distributing the fuzzer module, we start to harvest interesting input gathered by the fuzzers. From\nthere, we begin to generate code traces and load those up in IDA Pro with the Lighthouse plugin for further analysis.\n\nWe first focus on reverse engineering the InternetMail.dll to find the code that manipulates the mutated input—\nparticularly the ResponseParams the fuzzer feeds into the target. One interesting ResponseParams in the FETCH\n[response, RFC822.SIZE, immediately caught our attention. Per the available documentation, RFC822.SIZE is one of](https://tools.ietf.org/id/draft-ietf-extra-imap4rev2-15.html#fetch-command)\nthe FETCH command's attributes that represents the message's size. Simply put, it tells the email client the size of the\nentire email message that arrived in the client, including email headers, contents, and attachments.\n\nInterestingly, from the code snippet in Listing 5, the code sanitization for this value is pretty simple – merely ensuring\nthe size of the message is not 4 gigabytes (4294967295 in base 10 or 0xFFFFFFFF in 32-bit hexadecimal). It yields an\nerror when it does.\n\nelse if (!_strnicmp(\"RFC822.SIZE\", strItem, 0xBui64))\n\n{\n\nstdstring_startItemData = this->stdstring_startItemData;\n\nthis->rfc822_size = 0;\n\nv11 = strtoul(stdstring_startItemData, 0i64, 10); // **(1)**\n\nthis->rfc822_size = v11;\n\nif (v11 == 0xFFFFFFFF) // **(2)**\n\n{\n\nv7 = 37;\n\n_hr = INTSAFE_E_ARITHMETIC_OVERFLOW;_\n\n\n-----\n\nLABEL_17:\n\nLog_HREvent(hr, 0, \"onecoreuap\\\\base\\\\mailcontactscalendarsync\\\\engines\\\\internetmail\\\\imap\\\\fetch.cpp\", v7);\n\n}\n\n}\n\nListing 5: Fetching RFC822.SIZE and saving it in a data structure\n\nIn (1), a zero value is returned if no valid conversion could be performed by strtoul. But, it seems that the code\nsanitization in (2) is not meaningful as a value such as 4294967294 (0xFFFFFFFE in 32-bit hexadecimal) could bypass\nthe check and pose an arithmetic overflow if this value is going to be used in some arithmetic operation somewhere in\nthe code. After digging into the code, we only found a single function that manipulates this value. Not surprisingly, we\nsee the same code sanitization here.\n\n__int64 __fastcall HeaderParser::_PostNewMessageCreation(HeaderParser* this, struct IMessage* lppMessage)\n\n{\n\nrfc822_size = this->rfc822_size;\n\nif ((_DWORD)rfc822_size != 0xFFFFFFFF)\n\n{\n\n_v1 = (void*)*((_QWORD*)this->pImapSyncContext + 27); // **(A)**_\n\nif (rfc822_size <= 0xA000)\n\n{\n\nif ((unsigned int)rfc822_size <= 0x5000ui64)\n\n{\n\nif ((unsigned int)rfc822_size <= 0x2800ui64)\n\n{\n\n_offset = 0x48i64;_\n\nif ((unsigned int)rfc822_size > 0x1400ui64)\n\n_offset = 0x50i64;_\n\n}\n\nelse\n\n{\n\n_offset = 0x58i64;_\n\n}\n\n}\n\nelse\n\n{\n\n\n-----\n\n_offset 0x60i64;_\n\n}\n\n}\n\nelse\n\n{\n\n_offset = 0x68i64;_\n\n}\n\n__InterlockedExchangeAdd64((volatile signed __int64*)((char*)v1 + offset), 1ui64); // **(B)**_\n\n__InterlockedExchangeAdd64((volatile signed __int64*)v1 + 8, (unsigned int)rfc822_size);_\n\n}   // **(C)**\n\nListing 6: HeaderParser::_PostNewMessageCreation manipulates RFC822.SIZE\n\nIn (A), the v1 pointer is retrieved from pImapSyncContext, indicating that the unknown pointer might be related to some\ndata structure that keeps some synchronization states. Looking further at the code, we see two arithmetic operations in\n(B) and (C). For (B), an incremental operation takes place depending on the value of RFC822.SIZE and the result of\nthe incremented value is saved to the v1 pointer, while the RFC822.SIZE value is aggregated in (C). This seems to\ndeserve a deeper look.\n\nSo, we prepare an IMAP packet that consists of multiple FETCH ResponseParams with bogus RFC822.SIZE and then\nuse TTD to capture the executed code.\n\n{\n\n\"Packets\": [\n\n{\n\n\"ResponseParams\": [\n\n[\n\n\"NIL NIL ((\\\"\\\" \\\".\\\"))\"\n\n]\n\n],\n\n\"ResponseType\": 42,\n\n\"Command\": \"NAMESPACE\",\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A6\"\n\n},\n\n{\n\n\"ResponseParams\": [\n\n\n-----\n\n[\n\n\"() \\\"/\\\" \\\"INBOX\\\"\"\n\n]\n\n],\n\n\"ResponseType\": 42,\n\n\"Command\": \"LIST\",\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A7\"\n\n},\n\n{\n\n\"ResponseParams\": [\n\n[\n\n\"\"\n\n]\n\n],\n\n\"ResponseType\": 42,\n\n\"Command\": \"LIST\",\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A8\"\n\n},\n\n{\n\n\"ResponseParams\": [\n\n[\n\n\"FLAGS (\\\\Seen)\",\n\n\"OK [PERMANENTFLAGS (\\\\*)] Flags permitted\",\n\n\"2 EXISTS\",\n\n\"0 RECENT\",\n\n\"OK [UIDNEXT 3] Predicted next UID\",\n\n\"OK [UIDVALIDITY 1] UIDs valid\"\n\n]\n\n],\n\n\n-----\n\nResponseType : 42,\n\n\"Command\": \"SELECT\",\n\n\"ResponseStatus\": \"OK [READ-WRITE]\",\n\n\"ResponseTag\": \"A9\"\n\n},\n\n{\n\n\"ResponseParams\": [\n\n[\n\n\"SEARCH 1 2\"\n\n]\n\n],\n\n\"ResponseType\": 42,\n\n\"Command\": \"SEARCH\",\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A10\"\n\n},\n\n{\n\n\"ResponseParams\": [\n\n[\n\n\"1 FETCH\",\n\n\"UID 1\",\n\n\"INTERNALDATE \\\"31-Mar-2022 24:59:59 +0800\\\"\",\n\n\"FLAGS (\\\\Seen)\",\n\n\"RFC822.SIZE 4294967294\",\n\n\"X-GM-THRID NIL\",\n\n\"BODYSTRUCTURE (\\\"TEXT\\\" \\\"PLAIN\\\" () NIL NIL NIL 11 1 NIL NIL NIL NIL)\",\n\n\"BODY[HEADER.FIELDS (DATE FROM SUBJECT CONTENT-TYPE X-MS-TNEF-Correlator CONTENTCLASS IMPORTANCE PRIORITY X-PRIORITY THREAD-TOPIC REPLY-TO)]{135}\\r\\nFrom:\ncontact@example.org\\r\\nSubject: A little message, just for you\\r\\nDate: Wed, 22 Mar 2022 14:31:59 +0000\\r\\nContentType: text/plain\\r\\n\\r\\n\"\n\n],\n\n[\n\n\n-----\n\n2 FETCH,\n\n\"UID 2\",\n\n\"INTERNALDATE \\\"31-Mar-2022 24:59:59 +0800\\\"\",\n\n\"FLAGS (\\\\Seen)\",\n\n\"RFC822.SIZE 4294967294\",\n\n\"X-GM-THRID NIL\",\n\n\"BODYSTRUCTURE (\\\"TEXT\\\" \\\"PLAIN\\\" () NIL NIL NIL 11 1 NIL NIL NIL NIL)\",\n\n\"BODY[HEADER.FIELDS (DATE FROM SUBJECT CONTENT-TYPE X-MS-TNEF-Correlator CONTENTCLASS IMPORTANCE PRIORITY X-PRIORITY THREAD-TOPIC REPLY-TO)]{135}\\r\\nFrom:\ncontact@example.org\\r\\nSubject: B little message, just for you\\r\\nDate: Wed, 22 Mar 2022 14:31:59 +0000\\r\\nContentType: text/plain\\r\\n\\r\\n\"\n\n]\n\n],\n\n\"ResponseType\": 42,\n\n\"Command\": \"FETCH\",\n\n\"ResponseStatus\": \"OK\",\n\n\"ResponseTag\": \"A11\"\n\n}\n\n]\n\n}\n\nListing 7: IMAP packet with two FETCH response parameters using bogus RFC822.SIZE\n```\n0:000> !tt 0\n\nSetting position to the beginning of the trace\n\nSetting position: 78:0\n\n(1f58.9e0): Break instruction exception - code 80000003 (first/second chance not available)\n\nTime Travel Position: 78:0\n\nntdll!NtClose+0x14:\n\n00007fff`11a834b4 c3       ret\n\n0:000> x internetmail!*PostNewMessageCreation*\n\n00007fff`24253a64 InternetMail!HeaderParser::_PostNewMessageCreation (protected: long __cdecl\nHeaderParser::_PostNewMessageCreation\n\n(struct IMessage *))\n\n0:000> bp InternetMail!HeaderParser::_PostNewMessageCreation+0x84 \"r r9; dc r10+30\"\n\n0:000> g\n\n```\n\n-----\n\n```\n                                   y p\nModLoad: 00007fff`40e20000 00007fff`40e62000  C:\\Windows\\system32\\mlang.dll\n\nr9=00000000fffffffe\n\n00000251`a1f590b8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590c8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590d8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590e8 00000000 00000000 00000001 00000000 ................\n\n00000251`a1f590f8 00000000 00000000 00000001 00000000 ................\n\n00000251`a1f59108 00000000 00000000 f672a68a c667e448 ..........r.H.g.\n\n00000251`a1f59118 00000000 40200000 f673a6ba c667e449 ...... @..s.I.g.\n\n00000251`a1f59128 00000000 00000000 00000000 00000000 ................\n\nTime Travel Position: 106C6FF:0\n\nInternetMail!HeaderParser::_PostNewMessageCreation+0x84:\n\n00007fff`24253ae8 f04d0fc14a40  lock xadd qword ptr [r10+40h],r9 ds:00000251`a1f590c8=0000000000000000\n\n0:012> g\n\nr9=00000000fffffffe\n\n00000251`a1f590b8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590c8 fffffffe 00000000 00000000 00000000 ................\n\n00000251`a1f590d8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590e8 00000000 00000000 00000002 00000000 ................\n\n00000251`a1f590f8 00000000 00000000 00000001 00000000 ................\n\n00000251`a1f59108 00000000 00000000 f672a68a c667e448 ..........r.H.g.\n\n00000251`a1f59118 00000000 40200000 f673a6ba c667e449 ...... @..s.I.g.\n\n00000251`a1f59128 00000000 00000000 00000000 00000000 ................\n\nTime Travel Position: 1346091:0\n\nInternetMail!HeaderParser::_PostNewMessageCreation+0x84:\n\n00007fff`24253ae8 f04d0fc14a40  lock xadd qword ptr [r10+40h],r9 ds:00000251`a1f590c8=00000000fffffffe\n\n0:012> p\n\nTime Travel Position: 1346091:1\n\nInternetMail!HeaderParser::_PostNewMessageCreation+0x8a:\n\n00007fff`24253aee 488364245000  and   qword ptr [rsp+50h],0 ss:000000d2`e71fe3b0=0000000000000000\n\n0:012> dc r10+30\n\n00000251`a1f590b8 00000000 00000000 00000000 00000000 ................\n\n00000251`a1f590c8 fffffffc 00000001 00000000 00000000 ................\n\n00000251`a1f590d8 00000000 00000000 00000000 00000000 ................\n\n```\n\n-----\n\n```\n00000251`a1f590f8 00000000 00000000 00000001 00000000 ................\n\n00000251`a1f59108 00000000 00000000 f672a68a c667e448 ..........r.H.g.\n\n00000251`a1f59118 00000000 40200000 f673a6ba c667e449 ...... @..s.I.g.\n\n00000251`a1f59128 00000000 00000000 00000000 00000000 ................\n\n```\nListing 8: Debugger output shows the aggregated value of RFC822.SIZE in v1 pointer\n\nThe highlighted area in Listing 8 clearly shows that the aggregated value has overflowed the adjacent field in the v1\npointer. But we are unsure if the overwritten field poses any security issue. So, we need to determine the data structure\nfields for this raw memory. We use TTD.Utility.GetHeapAddress to reveal the starting heap address and the location\nwhere this heap address is allocated and initialized.\n```\n0:012> dx -g @$cursession.TTD.Utility.GetHeapAddress(0x00000251`a1f590b8)\n\n==============================================================================================================\n\n=               = Action  = Heap       = Address     = Size   = Flags = (+)\nTimeStart = (+) TimeEnd =\n\n==============================================================================================================\n\n= [0x1151e] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  D9B98:EC   - D9B9C:9C   =\n\n= [0x29b79] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  216478:EC   - 21647C:9C  =\n\n= [0x2adb1] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  220BC6:EC   - 220BCA:9C  =\n\n= [0x2c419] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  22C5A7:EC   - 22C5AB:9C  =\n\n= [0x2d88a] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  236CF9:EC   - 236CFD:9C  =\n\n= [0x2ea3d] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  23FCCF:EC   - 23FCD3:9C  =\n\n= [0x49a30] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  3985B0:EC   - 3985B4:9C  =\n\n= [0x4aeec] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  3A33F8:EC   - 3A33FC:9C  =\n\n= [0x4c02b] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f10  - 0x1b8  - 0x0  3AC168:EC   - 3AC16C:9C  =\n\n= [0x76275] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f60  - 0x190  - 0x0  5C6A57:A9   - 5C6A5B:9C  =\n\n= [0x7b09a] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f60  - 0x190  - 0x0  602818:81   - 60281C:9C  =\n\n= [0x7b14d] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f60  - 0x190  - 0x0  602E2E:81   - 602E32:9C  =\n\n= [0x7b1c3] : [object Object] - Alloc  - 0x251a2120000  - 0x251a1f58f60  - 0x1a0  - 0x0  6031FD:58   - 603201:9C  = 0:012> !tt 6031FD:58\n\n```\n\n-----\n\n```\n    g p\nModLoad: 00007fff`40e20000 00007fff`40e62000  C:\\Windows\\system32\\mlang.dll\n\n(1e8c.360): Break instruction exception - code 80000003 (first/second chance not available)\n\nTime Travel Position: 6031FD:58\n\nntdll!RtlAllocateHeap:\n\n00007fff`515e89a0 48895c2408   mov   qword ptr [rsp+8],rbx ss:000000d2`e7dfee80=000000d200000001\n\n0:005> kb\n\n # RetAddr        : Args to Child                              : Call Site\n\n00 00007fff`5076c750   : 000000d2`00000001 00000000`00000000 000000d2`e7dff000 00000000`00000000 :\nntdll!RtlAllocateHeap\n\n01 00007fff`36bb1d97   : 00007fff`36c14678 000000d2`e7dff008 00000251`a1f8be30 00000251`a1f59dd8 :\nmsvcrt!malloc+0x70\n\n02 00007fff`36bb33da   : 00007fff`36c14678 00007fff`336b651c 00000000`00000000 00000251`a1f50001 :\nSYNCUTIL!operator new+0x23\n\n03 00007fff`36bcb229   : 00000000`00000001 000000d2`e7dff088 00007876`9ee69ed8 00000000`00000001 :\nSYNCUTIL!operator new+0x12\n\n04 00007fff`36bcb7c1   : 000000d2`00000001 00007fff`2420ecfc 00000251`a1f02f00 00000251`a1f02e10 :\nSYNCUTIL!SyncStatsHelpers::_LookupAccountSyncStats+0xdd\n\n05 00007fff`2420976d   : 00000251`a1f02f00 00000000`00000000 00000000`00000000 00000251`a1f02f00 :\nSYNCUTIL!GetCurrentSyncStats+0x21\n\n06 00007fff`243100d2   : 00000000`00000000 00000251`a1fa9950 000000d2`e7dff0a0 00000251`a1f59d50 :\nInternetMail!ImapIdleExecutor::Initialize+0x3d\n\n07 00007fff`2430c5f1   : 00000000`00000000 00000251`a1f08980 00000000`00000000 00000251`a1f59d50 :\nSyncController!AccountSyncControllerAggregator::_Initialize+0x17e\n\n08 00007fff`242eec39   : 00000251`a1f08988 00007fff`00000000 00000251`a1f08988 00000251`a1f08980 :\nSyncController!AccountSyncControllerAggregator::CreateInstance+0x24d\n\n09 00007fff`242ea861   : 00000251`00000000 00007fff`2435dfd0 00000251`a2120000 00007fff`515e8d78 :\nSyncController!SyncBookkeeper::_AddSyncController+0x2dd\n\n0a 00007fff`242c8fd4   : 000063c9`e8e3b474 00007fff`515e752d 00000251`a1f91b10 00007fff`51662d96 :\nSyncController!SyncBookkeeper::CreateSyncController+0xf1\n\n0b 00007fff`242c7b4b   : 00000251`a1f6bc88 000000d2`e7dff390 00000251`a1f08900 000000d2`e7dff498 :\nSyncController!SyncActivityFactory::_CreateActivity+0x34\n\n0c 00007fff`36c508ae   : 00007fff`36c76410 00000251`a1f73b90 00000000`00000000 00000000`00000000 :\nSyncController!ProviderActivityFactory<SyncActivityFactory,&SyncActivityFactoryCLSID>::CreateDefaultActivityFo\n\n0d 00007fff`36c50c13   : 00000251`a1f08900 00007fff`36c76410 00000251`a1f75048 00007fff`5076c750 :\naphostservice!StdJobProviderByClsId<_BootstrapSyncAccountsSNJobArgs,unsigned long>::CreateActivity+0x7e\n\n0e 00007fff`36c2547e   : 00000000`00000000 000000d2`e7dff580 00007fff`36c76410 00000000`00000000 :\naphostservice!StdJob<_BootstrapSyncAccountsSNJobArgs,unsigned long>::ExecuteActivityStep+0x53\n\n0f 00007fff`36c2455d   : 00000251`a1f6dae8 00000251`a3b5e4b0 00000251`aa0f9d00 00000000`7ffe0386 :\naphostservice!JobScheduler::_UpdateJobQueue+0xd7e\n\n10 00007fff`5162952a   : 00000251`aa0f9dc8 00000000`00000000 00000251`aa0f9dc8 00000251`a1e02340 :\naphostservice!JobScheduler::s_BackgroundThreadProc+0x2ed\n\n```\n\n-----\n\n```\nntdll!TppWorkpExecuteCallback+0x13a\n\n12 00007fff`503254e0   : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 :\nntdll!TppWorkerThread+0x686\n\n13 00007fff`515c485b   : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 :\nKERNEL32!BaseThreadInitThunk+0x10\n\n14 00000000`00000000   : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 :\nntdll!RtlUserThreadStart+0x2b\n\n```\nListing 9: GetHeapAddress output and heap allocation call-stack for v1 pointer\n\nBased on the output of TTD.Utility.GetHeapAddress, we identify that the starting heap address of the v1 pointer is\n0x251a1f58f60 and is initialized from SYNCUTIL!SyncStatsHelpers::_LookupAccountSyncStats. Within this function,\nwe realize that the v1 pointer is passed to SYNCUTIL!SyncStatsHelpers::_LoadSyncStats that loads various stats into\nthe data structure referenced by the v1 pointer.\n\n__int64 __fastcall SyncStatsHelpers::_LoadSyncStats(\n\n_GUID* rguid,_\n\nAccSyncStates_t* v1,\n\nstruct SyncStatsHelpers::MUTABLE_SYNC_STATS* a3)\n\n{\n\nhKey = 0i64;\n\nv5 = (HANDLE*)tlx::replace<HKEY__*, long (*)(HKEY__*), &long RegCloseKey(HKEY__*), 0>(&hKey);\n\nRegKey = SyncCreateRegKey(rguid, v5);\n\nif (RegKey < 0)\n\n{\n\nv9 = 186i64;\n\nLABEL_3:\n\nLog_HREvent_5((unsigned int)RegKey, 1i64, v7, v9);\n\nif (hKey)\n\n_RegCloseKey(hKey);_\n\nreturn (unsigned int)RegKey;\n\n}\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"ReceivedMailCount\",\n\n(const unsigned __int16*)&v22,\n\nv8);\n\n\n-----\n\nif (RegKey < 0)\n\n{\n\nv9 = 191i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccReceivedMailCount, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"DeletedMailCount\",\n\n(const unsigned __int16*)&v22,\n\nv11);\n\nif (RegKey < 0)\n\n{\n\nv9 = 192i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccDeletedMailCount, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"UpdatedMailCount\",\n\n(const unsigned __int16*)&v22,\n\nv12);\n\nif (RegKey < 0)\n\n{\n\nv9 = 193i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccUpdatedMailCount, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"SentMailCount\",\n\n\n-----\n\n(const unsigned __int16 )&v22,\n\nv13);\n\nif (RegKey < 0)\n\n{\n\nv9 = 194i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccSentMailCount, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"MailReceivedCountUnder5k\",\n\n(const unsigned __int16*)&v22,\n\nv14);\n\nif (RegKey < 0)\n\n{\n\nv9 = 196i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccMailReceivedCountUnder5k, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"MailReceivedCount5kTo10k\",\n\n(const unsigned __int16*)&v22,\n\nv15);\n\nif (RegKey < 0)\n\n{\n\nv9 = 197i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccMailReceivedCount5kTo10k, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n\n-----\n\n(SyncStatesHelpers )hKey,\n\n(HKEY)L\"MailReceivedCount10kTo20k\",\n\n(const unsigned __int16*)&v22,\n\nv16);\n\nif (RegKey < 0)\n\n{\n\nv9 = 198i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccMailReceivedCount10kTo20k, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"MailReceivedCount20kTo40k\",\n\n(const unsigned __int16*)&v22,\n\nv17);\n\nif (RegKey < 0)\n\n{\n\nv9 = 199i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccMailReceivedCount20kTo40k, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"MailReceivedCountOver40k\",\n\n(const unsigned __int16*)&v22,\n\nv18);\n\nif (RegKey < 0)\n\n{\n\nv9 = 200i64;\n\ngoto LABEL_3;\n\n}\n\n\n-----\n\n__InterlockedExchange64((volatile __int64 )&v1 >AccMailReceivedCountOver40k, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"ClientUnreadToReadCount\",\n\n(const unsigned __int16*)&v22,\n\nv19);\n\nif (RegKey < 0)\n\n{\n\nv9 = 202i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccClientUnreadToReadCount, v22);_\n\nRegKey = SyncStatsHelpers::_LoadStatsCounter(\n\n(SyncStatesHelpers*)hKey,\n\n(HKEY)L\"MailReceivedKB\",\n\n(const unsigned __int16*)&v22,\n\nv20);\n\nif (RegKey < 0)\n\n{\n\nv9 = 205i64;\n\ngoto LABEL_3;\n\n}\n\n__InterlockedExchange64((volatile __int64*)&v1->AccMailReceivedKB, v22 << 10);_\n\nif (hKey)\n\n_RegCloseKey(hKey);_\n\nreturn 0i64;\n\n}\n\nListing 10: Initializing v1 pointer with email account stats\n\nAt this point, we recovered some of the data structure fields for the v1 pointer. We determined that the v1 pointer is a\nsynchronization stats object that keeps current session stats, aggregated stats, and account stats that can be\nrepresented using a data structure, as shown in Listing 11.\n\nstruct CSyncStates\n\n\n-----\n\n{\n\nvoid *lpVtbl;\n\nDWORD RefCount;\n\nDWORD UnkCount;\n\nSyncStates_t SyncStates;\n\n};\n\nstruct SyncStates_t\n\n{\n\nLPCRITICAL_SECTION CritSecObj;\n\nQWORD qwUnknown08;\n\nQWORD qwUnknown10;\n\nQWORD qwUnknown18;\n\nQWORD qwUnknown20;\n\nAccSyncStats_t AccSyncStats;\n\nAggrSyncStats_t AggrSyncStats;\n\nSessionSyncStats_t SessSyncStats;\n\n};\n\nstruct AccSyncStats_t\n\n{\n\nQWORD StartAccountSyncStats;\n\nQWORD qwUnknown30;\n\nQWORD AccReceivedMailCount;\n\nQWORD AccDeletedMailCount;\n\nQWORD AccUpdatedMailCount;\n\nQWORD AccSentMailCount;\n\nQWORD qwUnknown58;\n\nQWORD qwUnknown60;\n\nQWORD AccMailReceivedKB;\n\nQWORD AccMailReceivedCountUnder5k;\n\nQWORD AccMailReceivedCount5kTo10k;\n\nQWORD AccMailReceivedCount10kTo20k;\n\n\n-----\n\nQWORD AccMailReceivedCount20kTo40k;\n\nQWORD AccMailReceivedCountOver40k;\n\nQWORD AccClientUnreadToReadCount;\n\n};\n\nstruct AggrSyncStats_t\n\n{\n\nQWORD StartAggrSyncStats;\n\nQWORD qwUnknown08;\n\nQWORD AggrReceivedMailCount;\n\nQWORD AggrDeletedMailCount;\n\nQWORD AggrUpdatedMailCount;\n\nQWORD AggrSentMailCount;\n\nQWORD qwUnknown30;\n\nQWORD qwUnknown38;\n\nQWORD AggrMailReceivedKB;\n\nQWORD AggrMailReceivedCountUnder5k;\n\nQWORD AggrMailReceivedCount5kTo10k;\n\nQWORD AggrMailReceivedCount10kTo20k;\n\nQWORD AggrMailReceivedCount20kTo40k;\n\nQWORD AggrMailReceivedCountOver40k;\n\nQWORD AggrClientUnreadToReadCount;\n\n};\n\nstruct SessionSyncStats_t\n\n{\n\nQWORD StartSessionSyncStats;\n\nQWORD qwUnknown08;\n\nQWORD SessReceivedMailCount;\n\nQWORD SessDeletedMailCount;\n\nQWORD SessUpdatedMailCount;\n\nQWORD SessSentMailCount;\n\nQWORD qwUnknown30;\n\n\n-----\n\nQWORD qwUnknown38;\n\nQWORD SessMailReceivedKB;\n\nQWORD SessMailReceivedCountUnder5k;\n\nQWORD SessMailReceivedCount5kTo10k;\n\nQWORD SessMailReceivedCount10kTo20k;\n\nQWORD SessMailReceivedCount20kTo40k;\n\nQWORD SessMailReceivedCountOver40k;\n\nQWORD SessClientUnreadToReadCount;\n\n};\n\nListing 11: v1 pointer data structure\n\nAfter applying the data structure defined in Listing 11 in IDA Pro and decompiling\nHeaderParser::_PostNewMessageCreation again, we will get better decompiled code, as shown in Listing 12:\n\n__int64 __fastcall HeaderParser::_PostNewMessageCreation(HeaderParser* this, struct IMessage* lppMessage)\n\n{\n\nrfc822_size = this->rfc822_size;\n\nif ((_DWORD)rfc822_size != 0xFFFFFFFF)\n\n{\n\nCurrentSyncStats = (SessionSyncStats_t*)*((_QWORD*)this->pImapSyncContext + 27);\n\nif (rfc822_size <= 0xA000)\n\n{\n\nif ((unsigned int)rfc822_size <= 0x5000ui64)\n\n{\n\nif ((unsigned int)rfc822_size <= 0x2800ui64)\n\n{\n\noffset = 0x48i64;\n\nif ((unsigned int)rfc822_size > 0x1400ui64)\n\noffset = 0x50i64;\n\n}\n\nelse\n\n{\n\noffset = 0x58i64;\n\n\n-----\n\n}\n\n}\n\nelse\n\n{\n\noffset = 0x60i64;\n\n}\n\n}\n\nelse\n\n{\n\noffset = 0x68i64;\n\n}\n\n__InterlockedExchangeAdd64((volatile signed __int64*)((char*)CurrentSyncStats + offset), 1ui64);_\n\n__InterlockedExchangeAdd64(_\n\n(volatile signed __int64*)&CurrentSyncStats->SessMailReceivedKB,\n\n(unsigned int)rfc822_size);\n\n}\n\nListing 12: Better decompiled code for HeaderParser::_PostNewMessageCreation\n\nSo, it turns out that the field is a 64-bit field, which means the arithmetic overflow we suspected at first is not harmful.\nWe also verified the code that manipulates SessionSyncStats_t->SessMailReceivedKB, but it turns out this value is\neventually written to the registry key “MailReceivedKB”.\n\n__int64 __fastcall AggregateAccountSyncStats(\n\n_GUID* AccountGuid,_\n\n__int64 a2,\n\nstruct SyncStatsHelpers::AccountStatSingletons** a3)\n\n{\n\nSyncStates = 0i64;\n\nhr = SyncStatsHelpers::_LookupAccountSyncStats(AccountGuid, (SyncStates_t*)&SyncStates, a3);\n\nif (hr >= 0)\n\n{\n\n_EnterCriticalSection((LPCRITICAL_SECTION)SyncStates);_\n\nSyncStatsHelpers::MUTABLE_SYNC_STATS::AggregateSyncStats(&SyncStates->AggrSyncStates,\n&SyncStates->SessSyncStates);\n\n\n-----\n\nSyncStatsHelpers::MUTABLE_SYNC_STATS::AggregateSyncStats(\n\n(AggrSyncStates_t*)&SyncStates->AccSyncStates,\n\n(SessionSyncStates_t*)&SyncStates->AggrSyncStates);\n\nhr = SyncStatsHelpers::_StoreSyncStats(AccountGuid, &SyncStates->AccSyncStates, v8);\n\nif (hr >= 0)\n\nhr = 0;\n\nelse\n\nLog_HREvent_5((unsigned int)hr, 1i64, v10, 346i64);\n\n_LeaveCriticalSection((LPCRITICAL_SECTION)SyncStates);_\n\n}\n\nelse\n\n{\n\nLog_HREvent_5((unsigned int)hr, 1i64, v5, 338i64);\n\n}\n\nreturn (unsigned int)hr;\n\n}\n\n__int64 __fastcall SyncStatsHelpers::_StoreSyncStats(\n\n_GUID* rguid,_\n\nAccSyncStates_t* SyncStates,\n\nconst struct SyncStatsHelpers::MUTABLE_SYNC_STATS* a3)\n\n{\n\nhKey = 0i64;\n\nv5 = (HANDLE*)tlx::replace<HKEY__*, long (*)(HKEY__*), &long RegCloseKey(HKEY__*), 0>(&hKey);\n\nRegKey = SyncCreateRegKey(rguid, v5);\n\nif (RegKey < 0)\n\n{\n\nv8 = 227i64;\n\nLABEL_3:\n\nLog_HREvent_5((unsigned int)RegKey, 1i64, v7, v8);\n\nif (hKey)\n\n_RegCloseKey(hKey);_\n\n\n-----\n\nreturn (unsigned int)RegKey;\n\n}\n\nv10 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccReceivedMailCount, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"ReceivedMailCount\", v10);\n\nif (RegKey < 0)\n\n{\n\nv8 = 231i64;\n\ngoto LABEL_3;\n\n}\n\nv11 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccDeletedMailCount, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"DeletedMailCount\", v11);\n\nif (RegKey < 0)\n\n{\n\nv8 = 232i64;\n\ngoto LABEL_3;\n\n}\n\nv12 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccUpdatedMailCount, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"UpdatedMailCount\", v12);\n\nif (RegKey < 0)\n\n{\n\nv8 = 233i64;\n\ngoto LABEL_3;\n\n}\n\nv13 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccSentMailCount, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"SentMailCount\", v13);\n\nif (RegKey < 0)\n\n{\n\nv8 = 234i64;\n\ngoto LABEL_3;\n\n}\n\nv14 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedCountUnder5k, 0i64);\n\n\n-----\n\nRegKey SetRegQWORD(hKey, 0i64, L MailReceivedCountUnder5k, v14);\n\nif (RegKey < 0)\n\n{\n\nv8 = 236i64;\n\ngoto LABEL_3;\n\n}\n\nv15 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedCount5kTo10k, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"MailReceivedCount5kTo10k\", v15);\n\nif (RegKey < 0)\n\n{\n\nv8 = 237i64;\n\ngoto LABEL_3;\n\n}\n\nv16 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedCount10kTo20k,\n0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"MailReceivedCount10kTo20k\", v16);\n\nif (RegKey < 0)\n\n{\n\nv8 = 238i64;\n\ngoto LABEL_3;\n\n}\n\nv17 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedCount20kTo40k,\n0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"MailReceivedCount20kTo40k\", v17);\n\nif (RegKey < 0)\n\n{\n\nv8 = 239i64;\n\ngoto LABEL_3;\n\n}\n\nv18 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedCountOver40k, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"MailReceivedCountOver40k\", v18);\n\nif (RegKey < 0)\n\n\n-----\n\n{\n\nv8 = 240i64;\n\ngoto LABEL_3;\n\n}\n\nv19 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccClientUnreadToReadCount, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"ClientUnreadToReadCount\", v19);\n\nif (RegKey < 0)\n\n{\n\nv8 = 242i64;\n\ngoto LABEL_3;\n\n}\n\nv20 = _InterlockedExchangeAdd64((volatile signed __int64*)&SyncStates->AccMailReceivedKB, 0i64);\n\nRegKey = SetRegQWORD(hKey, 0i64, L\"MailReceivedKB\", v20 >> 10);\n\nif (RegKey < 0)\n\n{\n\nv8 = 246i64;\n\ngoto LABEL_3;\n\n}\n\nif (hKey)\n\n_RegCloseKey(hKey);_\n\nreturn 0i64;\n\n}\n\nListing 13: Session synchronization stats being pushed to the registry key\n\n## Conclusion\n\nOur fuzzer module did not discover any vulnerabilities at the time of writing, and our attempt to find potential memory\ncorruption issues through a manual code audit did not yield any results. However, we did learn a lot in the process of\nfuzzing the Microsoft IMAP client. The key takeaway of this research project is that we learned more about WTF fuzzer\nand gained some hands-on experience using it with a real-world target. And while there are still some challenges we\ndid not cover in this article, this tool is definitely one of the must-have tools for security researchers for black-box\nfuzzing.\n\n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization and the FortiGuard Security](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-03 - Journey to Network Protocol Fuzzing – Dissecting Microsoft IMAP Client Protocol.pdf"
    ],
    "report_names": [
        "2022-08-03 - Journey to Network Protocol Fuzzing – Dissecting Microsoft IMAP Client Protocol.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536212,
    "ts_updated_at": 1743041173,
    "ts_creation_date": 1660795168,
    "ts_modification_date": 1660795168,
    "files": {
        "pdf": "https://archive.orkl.eu/da42abb3a01302ee5aa274e740475e5b43a11d73.pdf",
        "text": "https://archive.orkl.eu/da42abb3a01302ee5aa274e740475e5b43a11d73.txt",
        "img": "https://archive.orkl.eu/da42abb3a01302ee5aa274e740475e5b43a11d73.jpg"
    }
}