{
    "id": "4c504925-d964-4216-b2a9-f0e61d77a52a",
    "created_at": "2023-01-12T15:07:14.468181Z",
    "updated_at": "2025-03-27T02:10:17.878057Z",
    "deleted_at": null,
    "sha1_hash": "9abeed3d2035137887063e357a6f3798f230d0d8",
    "title": "2021-10-15 - Memory Forensics R&D Illustrated- Detecting Mimikatz's Skeleton Key Attack",
    "authors": "",
    "file_creation_date": "2022-05-28T05:01:38Z",
    "file_modification_date": "2022-05-28T05:01:38Z",
    "file_size": 1787577,
    "plain_text": "# Memory Forensics R&D Illustrated: Detecting Mimikatz's Skeleton Key Attack\n\n**[volatility-labs.blogspot.com/2021/10/memory-forensics-r-illustrated.html](https://volatility-labs.blogspot.com/2021/10/memory-forensics-r-illustrated.html)**\n\nIn this blog post, we are going to walk you through the research and development process\nthat leads to new and powerful memory analysis capabilities. We are often asked about what\nthis workflow looks like, and how the abuse of an API by malware or a new code injection\ntechnique can be successfully uncovered by a Volatility plugin. To showcase this process, we\nare going to analyze the Skeleton Key feature of Mimikatz, and then develop a brand-new\nVolatility 3 plugin that can successfully detect this backdoor technique across memory\n[samples. While Volexity Volcano customers have had this capability, we wanted to contribute](https://www.volexity.com/products-overview/volcano/)\nthis back to the Volatility community, since there was no publicly available plugin. This post\nwill also reveal a number of entirely new features.\n\nTo reach this goal, we will first study the relevant Mimikatz source code; then we will reverse\nengineer the API that Mimikatz uses to locate its victim data structure; and then we will write\na plugin that can replicate this search and look for signs of tampering. As you will see shortly,\nthe new Skeleton Key detection plugin is fully documented and shows how to perform a wide\nrange of tasks using the APIs of Volatility 3.\n\nOur hope with this blog post is to inspire more members of the community to challenge\nthemselves to develop their own new capabilities, and to experience what real-world\nmalware and operating systems investigations entail. If you find this work interesting and\ndecide to develop your own plugin(s), please consider submitting them to our 2021 Volatility\nPlugin Contest and take a chance at winning several prizes, including cash or a free spot in\n[our popular Malware and Memory Forensics training.](https://volatility-labs.blogspot.com/2021/01/malware-and-memory-forensics-training.html)\n\n## Skeleton Key Background\n\nThe Skeleton Key technique was first detected in the wild by the DFIR team at SecureWorks.\nTheir [blog post walks through the steps taken by the malware sample they uncovered. They](https://www.secureworks.com/research/skeleton-key-malware-analysis)\n[also worked with Microsoft on a follow-up paper about the attack type and its variations. The](https://www.virusbulletin.com/uploads/pdf/magazine/2016/vb201601-skeleton-key.pdf)\nimplementation in Mimikatz is very similar to the one described in their research.\n\n\n-----\n\nThe idea behind the Skeleton Key technique is to backdoor the authentication subsystem of\nWindows Active Directory domain controllers. This is accomplished by injecting code into the\nrunning lsass.exe process, and then hooking the routines used when verifying a domain\naccount’s credentials. With the hooks in place, attackers are able to authenticate as any valid\nuser in an AD domain by using a hard-coded password (termed the Skeleton Key by\nSecureWorks).\n\nThe ability of attackers to log in as any user makes several traditional incident remediation\nprocedures largely ineffective. As an example, it is very common during incidents to\ntemporarily disable accounts that attackers are/were using or to at least force a password\nreset of these accounts. When a Skeleton Key is active, these procedures are not helpful,\nsince any account can be used. This problem is also compounded by the fact that all user\naccounts in a domain could potentially be abused by attackers, and a significant amount of\nlog review (assuming logs are available) is necessary to trace the abuse of accounts and any\nassociated lateral movement. This ability to authenticate as any user to any system is\nincredibly powerful and significantly expands the scope of DFIR engagements.\n\n## Analyzing the Skeleton Key Capability of Mimikatz\n\nActivating the Skeleton Key attack of Mimikatz requires using its misc::skeleton command\nafter running the usual privilege::debug command. There are many great blog posts that\ndocument this process by showing the related Mimikatz output and other related information,\nsuch as [here,](https://riccardoancarani.github.io/2020-08-08-hunting-for-skeleton-keys) [here, and](https://www.hackingarticles.in/domain-controller-backdoor-skeleton-key/) [here. Cycraft also](https://adsecurity.org/?p=1255) [documented malware from the Chimera APT](https://cycraft.com/download/%5BTLP-White%5D20200415%20Chimera_V4.1.pdf)\n[group that used a significant amount of code from misc::skeleton to implement its own](https://attack.mitre.org/groups/G0114/)\nSkeleton Key attack. The end result of this command is a Skeleton Key attack being active\non the system; the attacker is able to authenticate with the malware-controlled credentials.\n\n[Running the misc::skeleton command will lead to the kuhl_m_misc_skeleton function being](https://github.com/gentilkiwi/mimikatz/blob/fe4e98405589e96ed6de5e05ce3c872f8108c0a0/mimikatz/modules/kuhl_m_misc.c#L655)\ncalled inside the active Mimikatz instance. This function is responsible for patching the\nneeded code and data inside the lsass.exe process to make the Skeleton Key active. The\nfirst steps in this process are shown in the following image:\n\nIn this code, Mimikatz first gets the process ID of lsass.exe and stores it in the processId\n[variable. Next, it calls OpenProcess to obtain a handle to the lsass.exe process. This handle](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\ngives the ability to read and write the memory of the lsass.exe process from the calling\n\n\n-----\n\nprocess. Mimikatz then calls kull_m_memory_open, which is an internal Mimikatz function\nthat stores the handle for later use.\n\nAfter Mimikatz is able to read and write memory of the lsass.exe process, it then searches\nfor the Kerberos-Newer-Keys string in memory so that it can find the data structure related to\nAES-based authentication. It then manipulates this structure so that authentication is\ndowngraded to the weaker RC4 without the use of a salt. Note that this is the same approach\ndescribed in the previously linked Cycraft report. Older reports, such as the one from\nMicrosoft, describe how malware can also achieve the same result by hooking the\n_SamIRetrieveMultiplePrimaryCredentials function and forcing it return an error when the_\n_Kerberos-Newer-Keys package is used. The end result of both methods is the same: all_\nauthentication attempts to an infected domain controller will use the weaker RC4 algorithm.\n\nAfter downgrading the domain controller to RC4, Mimikatz will then attempt to locate and\npatch the data structure that handles RC4-based authentication. The following image shows\nthe beginning of this code:\n\nFirst, the [module information is gathered for the “cryptdll.dll” module loaded within the](https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmoduleinformation)\nlsass.exe process. This module is responsible for implementing the different encryption\npackages, which are also known as systems. Next, the address of where cryptdll.dll is\nloaded within the Mimikatz process is gathered by calling GetModuleHandle.\n\nThe undocumented CDLocateCSystem function is then called with an argument of\nKERB_ETYPE_RC4_HMAC_NT and the address to store the resulting lookup (&pCrypt).\n_CDLocateCSystem determines the address of the data structure that handles the given_\n(KERB_ETYPE_RC4_HMAC_NT) authentication system and copies its contents into the\n\n\n-----\n\npassed-in pCrypt address. In this instance, it will be for the system that implements RC4based authentication, and it will contain the information shown below:\n\nThe actual data structure definition for this type is not documented by Microsoft, so the\n[above image is directly from the Mimikatz source code. The arrows point to the members](https://github.com/gentilkiwi/mimikatz/blob/master/modules/kull_m_crypto_system.h)\nrelevant to our plugin, which include the encryption type; the function pointers for the\ninitialization, encryption, decryption, and finish operation handlers; and the pointer to the\nstring name of the system.\n\nAfter finding the _KERB_ECRYPT instance for RC4 through the use of CDLocateCSystem,\nMimikatz then hooks the legitimate initialization (Initialize) and decryption (Decrypt) members\nof the structure. These hooks point the handlers to Mimikatz’s malicious handlers\n(kuhl_misc_skeleton_rc4_init and kuhl_misc_skeleton_rc4_init_decrypt) instead of the\nlegitimate ones. The malicious handlers are injected into the address space of lsass.exe\nthrough the use of the [WriteProcessMemory function. Combined, these malicious handlers](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf)\nare what implement the Skeleton Key attack, as they give Mimikatz control over all future\nauthentication attempts to the infected domain controller.\n\n## Devising a Detection Strategy\n\nNow that we understand how Mimikatz implements its attack—forcing a downgrade to RC4\nfollowed by hooking the RC4 initialization and decryption routines—we can devise a strategy\nto detect the attack in memory.\n\n\n-----\n\nWe could start by attempting to detect the RC4 downgrade, but this has a few limitations.\nFirst, the string needed to find this data structure (Kerberos-Newer-Keys) is zeroed out as\npart of the attack, removing the possibility of a scanning-based approach to finding it.\nSecond, attempting to detect that this string has been zeroed out would lead to many false\npositives due to paging of data out to disk, as well as the possibility of the page holding the\nstring being smeared. Third, there are other methods to force a downgrade to RC4 without\ndirectly altering this string (as discussed in earlier references), meaning several approaches\nwould be needed to completely detect it. Finally, finding proof of the downgrade only gives a\nclue that a Skeleton Key attack might have been performed, but it does not offer direct\nevidence.\n\nOn the other hand, by examining the RC4 data structure directly, we can inspect the\nhandlers for the initialization and decryption routines and determine if they were altered at\nruntime. This not only definitively tells us if a Skeleton Key attack occurred, but it also tells us\nexactly where the malicious handlers are inside of the infected lsass.exe process. Given that\nthis approach gives direct evidence of the attack, as well as directly points out the malicious\ncode, inspecting these handlers was chosen as the detection method for our plugin.\n\n## Reverse Engineering CDLocateCSystem\n\nBefore we can locate the handlers to then verify them, we need to be able to find the RC4\ndata structure in a repeatable and consistent manner. As shown previously, Mimikatz locates\nthe address of the RC4 data structure by calling CDLocateCSystem. This tells us that if we\ncan replicate the algorithm of CDLocateCSystem—or at least build an algorithm that is equal\n—we can reliably locate the RC4 structure to then verify its handlers.\n\nSince cryptdll.dll contains the CDLocateCSystem function implementation and is closed\nsource, we will need to reverse engineer the function to determine its algorithm. As you will\nsee next, this function is pretty simple, so do not panic if you have never reverse engineered\nbefore; the concept will be straightforward.\n\nThe following images show the IDA Pro decompiler and graph view of CDLocateCSystem:\n\n\n-----\n\nAs seen above, the function is pretty small and simple. It begins (the first instruction of\n_CDLocateCSystem in the disassembly view) by copying the current value of cCSystems_\nglobal variable into the r8d register, which is an alias for the lower 32 bits of 64-bit r8 register.\n\n\n-----\n\nIt then tests (CDLocateCSystem+22) if the value is zero and bails with an error (+27) if it is. If\nthe value is anything but zero, then it moves to basic block, starting at offset +9. This basic\nblock begins by decrementing the r8d register (+9). This code pattern of storing a variable,\nchecking if it is zero, and then decrementing the value tells us that this is likely a counter for\nlooping (iterating) through a data structure. Looking ahead, the red line leading from +20\nback to +22 in the graph confirms this, as the code at +22 will be evaluated every time the\nbasic block starting at +9 fails to exit. This is exactly how loops look in IDA Pro and other\nbasic block graphing tools.\n\nFurther studying the basic block starting at +9, we see the address of the CSystems global\nvariable copied into the r9 register. Next (+13), the value in r8d is copied into eax, and then\nrax is shifted left by 7\n(+16), which is the same thing as being multiplied by 128 (2 to the 7 power). This computedth\nvalue is then stored into r9, and the data r9 points to is compared with the value in ecx (+1D).\nIf this comparison matches, then the function returns. Otherwise, the flow starting at +9\nrepeats.\n\nBreaking this down, the code is using the current value of r8d multiplied by 128 (shifted left\nby 7) as an index into CSystems. This is exactly what iterating through an array looks like. As\neach array element is stored contiguously in memory, by knowing the size and count, you\ncan successfully locate each element. This understanding of the code now tells us two\nthings:\n\n1. cCSystems holds the number of elements in CSystems.\n2. The size of each CSystems element is 128 bytes.\n\nFor the basic block at +9, the only remaining parts to understand are which values are being\ncompared at +1D and the purpose of that comparison. Since the loop breaks dependent on\nthat comparison, it is likely critical to the function’s overall purpose. Looking at the two\nvalues, [r9] and ecx, we know a few things. First, the comparison will be comparing two 32bit values, as that is the size of ecx, which is the lower 32 bits of rcx. Second, the brackets\naround r9 mean to treat the value of r9 as an address in memory and then retrieve the value\nat that address, which is known as dereferencing an address (pointer). From our previous\ndiscussion, we know that r9 holds the address of the current CSystems element being\ninspected. Dereferencing it as [r9] is equivalent to dereferencing [r9+0], which tells us that\nthe first 4 bytes (32 bits) of the referenced structure are being accessed.\n\nAs for ecx, the instruction at +1D is the first time ecx (or any of rcx) is referenced. This\nmeans the value must have been set before the function was called. Consulting the Microsoft\n[documentation on function-calling conventions, we see that the rcx register is used on 64-bit](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160)\nsystems to store the first parameter sent to a function. Earlier, when we examined how\nMimikatz called CDLocateCSystem, we noted that the first argument was the\n_KERB ETYPE RC4 HMAC NT constant, which is defined in NTSecAPI.h of the Windows_\n\n\n-----\n\nSDK as 0x17 hex (23 decimal). This means that CDLocateCSystem will be searching for an\nelement of CSystems that has 0x17 (23) as the first integer.\n\nLooking at the end of the function (+2E -> +33), we see that r9 is stored into the address\npointed to by rdx; the previous Microsoft documentation tells us rdx stores the second\nparameter to a function. We know for CDLocateCSystem that this is the address of where\nthe calling code (Mimikatz) wants Windows to store the address of the requested\nauthentication system (RC4).\n\nSeeing that the address of the CSystems element found in the loop is directly returned to the\ncaller tells us that the data structure returned is also of type _KERB_ECRYPT, since we\nknow that is the type of the second parameter to CDLocateCSystem. This then tells us that\nthe integer at offset 0, that is compared in the loop, is actually the EncryptionType member of\nstructure. This makes sense, since it holds the integer value for the particular authentication\nsystem type. It also means that the elements in CSystems are the ones actually used by\nWindows during the authentication process, since these are the ones directly targeted by\nSkeleton Key attacks.\n\nIn summary, reverse engineering has showed us that the active RC4 authentication system\nstructure can be located by enumerating CSystems and then looking for the element that has\nan EncryptionType of 0x17 (23). This precisely matches how CDLocateCSystem uses its first\nparameter to determine which element of the CSystems array to return to the caller. It also\ntells us that the type of each element is KERB_ECRYPT, which is very handy since we\nalready have the definition for this type.\n\n## Reverse Engineering the RC4 Structure Origin\n\nAfter learning how CDLocateCSystem operated, the next analysis step taken was to\ndetermine if the RC4 structure inside the CSystems array could be found directly. While\nenumerating the array is not difficult nor time consuming, in memory forensics research we\naim to find the most direct path to data to avoid analysis issues that can be caused by\nsmear.\n\nTo begin this analysis, we wanted to determine how elements of CSystems were registered,\nwith particular interest in the RC4 system. Examining cross-references (meaning, finding\ncode that references), CSystems showed only a few locations inside of cryptdll.dll. Of these,\nthe CDRegisterCSystem function sounded the most promising, as it would hopefully lead us\nto RC4 being registered.\n\nThe following image shows the decompiled view of this function:\n\n\n-----\n\nAs can be seen, this is a pretty simple function that first (line 6) checks against the maximum\nnumber of registered systems (0x18), and then bails if already at the maximum. Next, the\nfunction determines the offset into CSystems (line 9) by using cCSystems shifted by 7. This\nmatches our understanding of cCSystems and the shifting by 7 from earlier. The function\nthen simply copies in the values from the passed in data structure (a1) into the correct offsets\nof CSystems. In summary, whatever values are in the system being registered are copied\nseparately inside of CSystems, duplicating them in memory.\n\nFollowing cross-references to CDRegisterCSystem leads us to many references inside of\n_LibAttach; a decompiled view is shown below:_\n\n\n-----\n\nThis function is exactly what we were looking for, as we can see all the different systems\nbeing registered. We also see our system of interest, csRC4_HMAC, being registered on line\n5. If we examine the data at this address, we can verify this with seeing 0x17 (23) as the first\ninteger. We learned earlier that this is the EncryptionType targeted by Mimikatz.\n\n\n-----\n\nAs seen above, not only is the 0x17 (23) present at the first offset, but a little further down we\nalso see the string defined for the system (RSADSI RC4-HMAC), as well as the handlers for\nevents the system must support. Looking at the list of functions, we find the legitimate\nhandlers for the initialization (rc4HmacInitialize) and decryption (rc4HmacDecrypt) routines\nthat Mimikatz targets. This gives us the specific symbol names that should correspond to the\nhandlers we find inside of analyzed memory samples.\n\nIn summary, this reverse-engineering effort to find the origin structure led us to two import\nconclusions. First, even though we know the symbol name of the static RC4 structure\n(csRC4_HMAC), we cannot analyze this directly, as a copy of its values will be placed inside\nof CSystems. This means we will still need to enumerate CSystems to get the “active”\nvalues, but it also means that we can potentially choose to leverage the duplicate, original\ndata in our plugin. Second, by knowing the symbol names of the legitimate initialization and\ndecryption handlers, we can make the sanity checks performed by our plugins as specific as\npossible.\n\nWith these two reversing efforts complete, we can now start to develop our plugin!\n\n## Designing the windows.skeleton_key_check Plugin\n\nOur previous analysis gave us all the information we need to design and implement our\nplugin; we saw exactly how the operating system retrieves our desired data structure. As a\ndirect approach, this would include the following steps:\n\n1. Find the address of CSystems\n2. Walk each element to find the active RC4 system\n3. Compare its initialization and decryption handlers to the known-good symbols\n\nAfter the handlers are processed, the plugin would then report whether the handler’s value is\nlegitimate or if a Skeleton Key attack has been performed.\n\n## Creating a New Plugin\n\nTo start, we must create a base Volatility 3 plugin that is capable of processing Windows\nsamples. A major goal of Volatility 3 was to have significant and always-up-to-date\ndocumentation for both users and developers. This documentation is stored on the Volatility\n[3 page of readthedocs. There is also a section specifically on writing a basic plugin here.](https://volatility3.readthedocs.io/)\n\nAt a high level, all plugins must define their requirements, a run method, and a generator\nmethod The run method executes first and calls the generator method to create the data\n\n\n-----\n\nsets that will be displayed on the terminal (or output in whatever format other interfaces\nsupport). For more information, please see the documentation above.\n\nFor our Skeleton Key plugin, we use the basic starting form to then implement the steps\nlisted previously. Note that the plugin being described in this blog post is already available in\n[Volatility 3 here. Since line numbers change after each new commit, we instead will be](https://github.com/volatilityfoundation/volatility3/blob/develop/volatility3/framework/plugins/windows/skeleton_key_check.py)\nreferencing portions of the plugin by the function name. Also, we will be showing screenshots\nof code portions being discussed with the line numbers starting at 1. This will guide the\ndiscussion in a consistent manner.\n\n## Implementation - Writing the run Function\n\nThe run function is called first when a plugin’s execution begins. The expected return value is\na TreeGrid that the calling user interface will then display for the analyst. The following image\nshows the run function, along with the process filter from our Skeleton Key plugin:\n\nOn line 12, the return statement begins with the construction of the required TreeGrid\ninstance. The first parameter to the TreeGrid constructor is the list of columns that the plugin\nwill display. Each column is specified with its name and type. For this plugin, we have chosen\nto display the process ID and name of analyzed lsass.exe instances; whether or not a\nSkeleton Key attack was found; and the addresses of the initialization and decryption\nhandlers. Note that the handlers are listed by their address in memory, which Volatility 3 will\nautomatically print in hexadecimal due to the format_hints.Hex specifier. This is similar to the\n\n_[addrpad] specifier of Volatility 2._\n\nNext, the generator function is called. For plugins that operate on data not made available by\nanother plugin the generator function will be called with no arguments For Skeleton Key\n\n\n-----\n\nsince we only want to analyze lsass.exe processes, we can leverage list_processes to\nperform the filtering for us. This filtering occurs through the use of the filter_func argument,\nwhich specifies a callback that evaluates if a process object should be yielded to the caller.\nOur filtering function, lsassproc_filter, is very simple; it only needs to evaluate if the process\nname is lsass.exe.\n\n## Implementation – Leveraging PDBs\n\nOur reverse-engineering effort showed us that four symbols—cSystems, cCSystems,\n_rc4HmacInitialize, rc4HmacDecrypt—hold the key data we need to write a complete plugin._\nLuckily, one of the new features of Volatility 3 is the ability to automatically download and\nincorporate PDB (symbol) files into the analysis flow of plugins. This is accomplished by\nlocating the PE file (.exe, .dll, .sys) of interest and parsing it with the PDB utility API. Since\ncryptdll.dll holds the symbols our plugins need, the first step is to find the DLL within the\naddress of lsass.exe:\n\nThe above image shows that _find_cryptdll—a function that receives the process object for\nlsass.exe—iterates through its memory regions (line 12), retrieves the filename for the\ncurrent region (line 13), and checks for the file of interest (13-15). Once cryptdll.dll is found,\nits base address and size are returned (16-17).\n\nOnce cryptdll.dll has been located, its information can then be passed to the PDB utility APIs:\n\n\n-----\n\nAs shown, calling into the PDB API is straightforward, but this actually triggers quite a bit of\nactivity inside the core of Volatility 3. First, the memory range specified for the PE file is\nscanned to find its [GUID, which is unique identifier for the file. Next, the local Volatility cache](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)\nis checked to see if the PDB for this GUID has already been downloaded and processed\nduring previous plugin runs. If so, then the cached file is parsed and returned to the caller.\n\nIf the GUID is not in the cache, then Volatility will attempt to download the PDB file from the\nMicrosoft symbol server. If successful, then the PDB will be parsed, converted to Volatility’s\n[symbol table format, and stored within the cache.](https://volatility3.readthedocs.io/en/stable/symbol-tables.html#how-volatility-finds-symbol-tables)\n\nAssuming the PDB is successfully downloaded and parsed, then our plugin has direct\naccess to the offsets of the needed symbols within the particular version of cryptdll.dll. This\nallows us to trivially find their values within a particular memory sample:\n\n\n-----\n\nThe code shown gathers the runtime address for each of the four desired symbols. For the\nhandlers, we only need their address in memory to compare to the ones in the active RC4\nsystem. For cCSystems, we treat it separately, as we do not want processing to fail simply\nbecause the page holding the count is unavailable.\n\nWe also treat CSystems separately, as we need to construct an array type to cleanly\nenumerate its elements. Constructing this object requires not only the address of where\nCSystems is in memory, but also the structure definition for the array elements. Unlike the\nPDB file for the kernel, which includes both symbol offsets and type information, the PDB file\nfor cryptdll.dll only includes the symbol offsets. This means we need to manually inform\nVolatility of the data structure layout. This is performed in Volatility 3 by creating a JSON file\nthat describes the data structure(s) a plugin requires. You can view this file for the\n__KERB_ECRYPT structure_ [here, which was based on the definition from Mimikatz discussed](https://github.com/volatilityfoundation/volatility3/blob/db2ec8cfb21e0f3f4808bc55b56d27a115263565/volatility3/framework/symbols/windows/kerb_ecrypt.json)\nearlier.\n\n\n-----\n\nOnce the array is constructed, it can then be enumerated as shown below:\n\nVolatility has built-in support for enumerating arrays, so the for loop will walk each element,\ncreating the csystem variable as the _KERB_ECRYPT type. Before processing an element, it\nis checked for being valid (mapped) into the process address space (lines 2-3). Next, the\n_EncryptionType value is compared with our type of interest (lines 6-7). To determine if a_\nSkeleton Key is present, we compare the Initialize and Decrypt members of the system\nfound in memory to the expected values from the PDB file. If either of these have been\nmodified, then a Skeleton Key attack has occurred, or at a minimum, a modification has\noccurred that an analyst would want to know about.\n\nWith all of the values computed, displaying the results to the analyst requires just a simple\nyield of the data. This can be seen in lines 13-17 and will result in the process name and\nPID, presence of a Skeleton Key, and handler addresses being displayed. This immediately\ninforms the analyst if a Skeleton Key was found, and if so, where the malicious handler\nvalues are in memory.\n\nThe following image shows a run of our new plugin against an infected memory sample:\n\n## Adding Resiliency to windows.skeleton_key_check\n\n\n-----\n\nSo far, our plugin is able to successfully detect Skeleton Key attacks by leveraging the\ncryptdll.dll PDB file to determine where our four symbols of interest are located in memory.\nUnfortunately, real-world memory forensics is not always this straightforward, and the data\nwe would like may not be memory resident or it may be smeared. Thus, it is also\nadvantageous to consider other approaches.\n\nIn the case of leveraging a PDB file for analysis, there are a few situations that could prevent\nus from determining which PDB file is needed for analysis, as well as obtaining that PDB file.\n\n1. The page containing cryptdll.dll’s GUID could be paged out or smeared.\n2. The analysis system may be offline and unable to download the PDB file from\n\nMicrosoft’s symbol server.\n3. Although rare, Microsoft has published corrupt/broken PDB files for modules shipped\n\nwith stable versions of Windows.\n\nIn these situations, we would still like to be able to detect Skeleton Key attacks, but we need\na different approach to gather the required data.\n\n## Finding CSystems Without a PDB File\n\nUsing knowledge gained from previous work on the plugin, we know that the\n_CDLocateCSystem function directly references two of the four symbols we need: CSystems_\nand cCSystems. This means that by performing static binary analysis of CDLocateCSystem,\nwe should be able to determine the address of these symbols, since the function’s\ninstructions will reference the addresses themselves. This is a common tactic in memory\nanalysis and reverse engineering tasks to find symbols that are not exported or where a\nsymbol file cannot be obtained.\n\nTo attempt to find CDLocateCSystem without the use of a PDB file, we parse the export\ndirectory of cryptdll.dll, since it exports CDLocateCSystem by name. The following image\nshows how this is performed in Volatility 3:\n\n\n-----\n\n-----\n\nFirst, a reference is obtained to the type information for PE files (lines 1-7). Next, a Volatility\n3 PE file object is constructed starting at the base address of cryptdll.dll (lines 9-11). This\nobject contains a number of convenience methods for accessing common data, such as the\ndata directories. This is leveraged on line 15 to parse the export directory, and then loop\nthrough its exported symbols starting on line 22. The body of this loop then looks for\n_CDLocateCSystem, and when found, attempts to read the bytes (opcodes of the instructions)_\nfrom its location in memory.\n\nIf these bytes can be read, then the _analyze_cdlocatecsystem function is called, which\n[leverages capstone to perform the static disassembly necessary to locate both symbols.](https://www.capstone-engine.org/)\nAfter locating them, it will construct the array object using the same method as described\nwhen the PDB file symbols were used.\n\nAssuming the export table and opcodes for CDLocationCSystem are present, this method\nwill successfully find CSystems and allow us to locate the RC4 structure as we did\npreviously.\n\n## Finding rc4HmacInitialize and rc4HmacDecrypt\n\nSo far, we have been able to locate the RC4 structure without the PDB file. Unfortunately,\nthere are no direct references to the legitimate initialize and decrypt handlers that we can\nleverage. This leaves us with two options. The first option is to verify the memory region\nholding the handlers, which will be discussed in this section. The second option is to attempt\nto scan for the values, which is discussed in the next section. Each has advantages and\ndrawbacks, as we will discuss.\n\nEach memory region within a process’s address space is tracked by a virtual address\ndescriptor (VAD). Information in the VAD includes the starting and ending address of the\nregion; the initial protection of the region; and the number of committed pages. For\nexecutables, such as lsass.exe and cryptdll.dll, one VAD will track all regions of the\nexecutable, including its code and data. Knowing this, we can check if the values of the\ninitialization and decryption handlers are within the region for cryptdll.dll. This is shown in the\nfollowing image:\n\nThis simple check ensures that the value of the handler is within the starting and ending\nrange of the VAD for cryptdll.dll. Although this check is not as precise as having the exact,\nlegitimate values from the PDB file, this method still detects all forms of Skeleton Key attacks\n\n\n-----\n\nfound in the wild, as they all allocate new VADs to hold the shellcode of the malicious\nhandlers.\n\n[Note: Theoretically, an in-memory code cave could be used to place redirection stubs within](https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves)\ncryptdll.dll and this check would be bypassed, but no malware—in the wild or proof-ofconcept—has leveraged this approach. Furthermore, the PDB-based method and the one\ndescribed in the next section would still detect these, rendering them not particularly stealthy.\nThese types of attacks are also much less portable to differing operating system versions,\nwhich is one of the reasons they are uncommon in the real world.\n\n## Adding Scanning as a Last Resort to windows.skeleton_key_check\n\nWe currently have two methods to gather the data needed for Skeleton Key attacks: PDB\nfiles and export table analysis. As discussed previously, the PDB file method can be\nunavailable for a number of reasons, and unfortunately, the export table method can be as\nwell. The most common reason for this is the PE header metadata being paged out or the\npage(s) holding the export table information are paged out. The end result is that we cannot\nuse the export table to tell us directly where to look for our needed information.\n\nIn these situations, there is a long history of memory forensic tools scanning for the data they\nneed. Since we have access to all pages that are present within a process’s address space,\nwe can simply scan them in hopes of finding what we need. In the case of our Skeleton Key\nplugin, we were able to develop a highly effective and efficient scanner to meet our needs.\n\nTo begin, we used our knowledge that the data we need is contained within cryptdll.dll. This\nmeans we only have to scan a very small space (the size of the DLL). Second, as shown\nbefore, the layout of the active structure starts with the integer for the encryption type, which\nwe know is 0x17 for RC4. Other research showed that the second member, BlockSize, had a\nvalue of 1 in all of our test samples. Using this knowledge, we developed a scanner based\non Volatility 3’s scanning API:\n\n\n-----\n\nThe scanner is configured to look for an 8-byte pattern of 0x17 followed by 1 in little-endian\ninteger format. It attempts to instantiate a _KERB_ECRYPT type at each address where this\npattern is found. To strengthen the check, we also verify that the Encrypt and Finish\nmembers our potential structure reference addresses are inside of cryptdll.dll. Neither of\nthese are targeted by Skeleton Key attacks and validating their values provides a strong\ncheck against false positives.\n\nThe following shows the output of our plugin when the scanning method is used:\n\nNote that there are two lines of output. This occurs beause the scanner finds both the active\nversion of the RC4 structure and the version that is statically compiled into the application.\nHaving both outputs provides some advantages: there is direct visual confirmation that the\nactive structure is hooked, and the statically compiled version reveals the addresses for the\nlegitimate handlers, even without PDB usage.\n\n## Wrap Up\n\n\n-----\n\nIn this blog post, we have walked through the entire process for memory forensics research\nand development. We analyzed a target (Mimikatz’s Skeleton Key attack), analyzed the\nsubsystem it abuses (the authentication systems managed by cryptdll.dll), and developed a\nnew Volatility plugin that can automatically analyze this subsystem for abuse. This is a\ncommon workflow used to develop Volatility plugins.\n\nIf you find this type of research interesting, please consider developing a new plugin and\n[submitting it to our Volatility Plugin Contest. Note that your submission does not have to be](https://volatility-labs.blogspot.com/2021/08/the-9th-annual-volatility-plugin-contest.html)\nanywhere near as thorough as the plugin presented here; even submitting a new capability\nwith just one of the discovery methods (PDB files, export analysis, scanning) used would be\nsufficient for an entry. We showed the full range here to display many of Volatility 3's new\ncapabilities, but we certainly do not expect all plugins to meet this level of complexity.\n\nWe hope you have enjoyed this post. If you have any questions or comments, please let us\n[know. You can find us on Twitter (@volatility) and our Slack server.](https://www.twitter.com/volatility)\n\n-- The Volatility Team\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-15 - Memory Forensics R&D Illustrated- Detecting Mimikatz's Skeleton Key Attack.pdf"
    ],
    "report_names": [
        "2021-10-15 - Memory Forensics R&D Illustrated- Detecting Mimikatz's Skeleton Key Attack.pdf"
    ],
    "threat_actors": [
        {
            "id": "873a6c6f-a4d1-49b3-8142-4a147d4288ef",
            "created_at": "2022-10-25T16:07:23.455744Z",
            "updated_at": "2025-03-27T02:02:09.811933Z",
            "deleted_at": null,
            "main_name": "Chimera",
            "aliases": [
                "Operation Skeleton Key"
            ],
            "source_name": "ETDA:Chimera",
            "tools": [
                "Agentemis",
                "Cobalt Strike",
                "CobaltStrike",
                "SkeletonKeyInjector",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f88b16bc-df4b-48e7-ae35-f4117240ff24",
            "created_at": "2022-10-25T15:50:23.556699Z",
            "updated_at": "2025-03-27T02:00:55.499173Z",
            "deleted_at": null,
            "main_name": "Chimera",
            "aliases": [
                "Chimera"
            ],
            "source_name": "MITRE:Chimera",
            "tools": [
                "PsExec",
                "esentutl",
                "Mimikatz",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536034,
    "ts_updated_at": 1743041417,
    "ts_creation_date": 1653714098,
    "ts_modification_date": 1653714098,
    "files": {
        "pdf": "https://archive.orkl.eu/9abeed3d2035137887063e357a6f3798f230d0d8.pdf",
        "text": "https://archive.orkl.eu/9abeed3d2035137887063e357a6f3798f230d0d8.txt",
        "img": "https://archive.orkl.eu/9abeed3d2035137887063e357a6f3798f230d0d8.jpg"
    }
}