{
    "id": "f0596f79-3760-4b50-932c-9b5daefb3e97",
    "created_at": "2023-01-12T15:08:04.389808Z",
    "updated_at": "2025-03-27T02:06:02.759988Z",
    "deleted_at": null,
    "sha1_hash": "43b95f9495d3db9c70fd9af12a1945f1df9f3869",
    "title": "2022-09-12 - The evolution of GuLoader",
    "authors": "",
    "file_creation_date": "2022-10-02T12:10:27Z",
    "file_modification_date": "2022-10-02T12:10:27Z",
    "file_size": 1818022,
    "plain_text": "# The evolution of GuLoader\n\n**[vmray.com/cyber-security-blog/malware-analysis-spotlight-guloader](https://www.vmray.com/cyber-security-blog/malware-analysis-spotlight-guloader)**\n\nThe evolution of GuLoader\nMALWARE ANALYSIS SPOTLIGHT\nFROM VMRAY LABS\n\n\n-----\n\n**Table of Contents**\n\n**Introduction**\n\nIn this Spotlight, we take another look at GuLoader. The malware family is active since at\nleast 2020. It gained some attention because of its evasion techniques and abusing\nlegitimate and popular cloud services to host its malicious payloads. The downloader is\ncommonly used to deliver other malware families such as FormBook, XLoader, and Lokibot.\n[After we took a closer look at GuLoader’s evasion techniques in a Threat Bulletin, we](https://www.vmray.com/cyber-security-blog/guloader-evasion-techniques-threat-bulletin/)\nobserved some additional behavior later that year.\n\nRecently, we collected samples that are different from the samples we have seen before.\nThe file that executes GuLoader’s shellcode has changed, and the functionality of GuLoader\n[has been extended compared to our last Spotlight. The sample in discussion leads to the](https://www.vmray.com/cyber-security-blog/azorult-delivered-by-guloader-malware-analysis-spotlight/)\nexecution of Lokibot as indicated by the extracted configurations in Figure 1.\n\n\n-----\n\nFigure 1: VMRay Analyzer - VTI highlighting GuLoader's behavior and extracted\nconfigurations.\n\n**GuLoader’s Delivery**\n\nThe main functionality of GuLoader is implemented as shellcode, and typically an executable\ntakes care of loading the shellcode into memory and transferring the execution flow to it. So\nfar this executable was written in VB6. However, the executable in this analysis is a signed\nNSIS installer that leads to the execution of GuLoader.\n\nDuring the installation process, the installer extracts multiple files to the hard disk including a\nDLL (Dynamic Link Library) named “System.dll”, and a file named “Gestisk.For” (Figure 2.).\n\n\n-----\n\nFigure 2: VMRay Analyzer - Dropped files\nWhile the name for the DLL seems to be consistent across similar samples, the name of the\nsecond file can vary. After writing “System.dll” to the hard disk, it is loaded by\nthe installer and used to call WinAPI functions to allocate memory where the shellcode will\nend up alter on.\n\nPrevious samples written in VB6 called the WinAPI functions directly instead of using a\nseparate DLL.\n\n**GuLoader’s Evolution**\n\nAt first glance, we can see the typical behavior of GuLoader. It tries to detect an analysis\nenvironment and if none was found it injects the shellcode into another process instance of\nthe executable.\n\nNext, the second instance downloads and executes the payload from the well-known cloud\nservice Google Drive. When comparing the memory dump of the shellcode with memory\ndumps from older samples, we can see that GuLoader stopped storing the strings in\nplaintext. Instead, they are decrypted at runtime and stored in a separate memory region\n(Figure 3.).\n\nFigure 3: Encrypted strings embedded in shellcode (left), and decrypted strings stored in a\nseparate memory region (right).\n\n[VMRay Analyzer uses special triggers that allow obtaining the region which contains the](https://www.vmray.com/cyber-security-blog/vmray-platform-feature-highlight-extended-smart-memory-dumping/)\ndecrypted strings.\n\n\n-----\n\nMoving on to the [observed function calls, we can see that the sample utilizes additional](https://www.vmray.com/analyses/e7ee8ff4872d/logs/flog.txt)\nWinAPI functions compared to previous ones. Figure 4. lists additional function calls that we\ndiscuss next.\n\nRtlAddVectoredExceptionHandler\n\nEnumDeviceDrivers\n\nGetDeviceDriverBaseNameA\n\nMsiEnumProductsA\n\nMsiGetProductInfoA\n\nOpenSCManagerA\n\nEnumServicesStatusA\nFigure 4: List of additional WinAPI functions observed in newer samples.\n\nWhile we have seen calls to functions related to enumerating products and services in\nprevious samples, the registration of a new exception handler and the examination of device\ndrivers have been added recently. This leads to the assumption that GuLoader is still under\nactive development.\n\nGiven the function log, we can see that the address of the exception handler is part of the\nshellcode (Figure 5.).\n\nFigure 5: VMRay Analyzer - Exception handler registration\n\n\n-----\n\nThis exception handler first checks if the exception was raised because of a software\nbreakpoint. Next, the function inspects the CPU registers to detect the presence of hardware\nbreakpoints. In case no breakpoint is set, the handler continues to change the instruction\npointer. The new value depends on the current instruction pointer and the byte followed after\nthe int3 instruction that triggered the exception handler (Figure 6). If a hardware breakpoint is\nset, the handler doesn’t change the instruction pointer, subsequently executing invalid\ninstructions.\n\nAdditionally, the function checks for int3 instructions between the current and the new\ninstruction pointer value.\n\nFigure 6: Exception handler snippet that modifies the instruction pointer.\nBy registering the exception handler, GuLoader uses int3 instructions as relative jumps.\nBecause debuggers like WinDbg and x64dbg use int3 instructions for software breakpoints,\nthis approach interferes with debugging if the debugger handles these exceptions first.\n\nA deeper look at the function log reveals that multiple WinAPI functions are called from the\nsame address within the shellcode (Figure 7.). This is an indicator that some kind of wrapper\nfunction takes care of calling the WinAPI functions.\n\n\n-----\n\nFigure 7: VMRay Analyzer - Excerpt from flog.xml revealing the same from address is being\nused multiple times.\nIn this example, GuLoader uses such a function to partially overwrite its code before calling\nthe actual WinAPI function. Figure 8. shows the part of the wrapper function that overwrites\nthe code by xoring it with the return address before and after the call instruction.\n\n\n-----\n\nFigure 8: Partially overwriting code before WinAPI function calls.\nBy overwriting code before the calls, GuLoader avoids being extracted correctly by\n**analysis tools that use WinAPI functions as memory dump trigger.**\n\nLooking at the list of called functions, we can see that GuLoader gathers information about\nthe\n\nname of installed drivers EnumDeviceDrivers and GetDeviceDriverBaseNameA)\npublisher of installed products (MsiEnumProductsA and MsiGetProductInfoA)\nservices in the SERVICES_ACTIVE_DATABASE\n\nThe resulting strings are then hashed using a customized djb2 algorithm and compared\nagainst a block list of pre-computed values of analysis environment artifacts.\n\n**Device names:**\n\n0x0A4F1B4F0\n\n0x0D277D8C6\n\n\n-----\n\n0x06E5A1CF8\n0x0966FE6F7\n\n0x0EC7C85F9\n\n**Product publisher:**\n\n0x07630654D\n\n0x0A80331E9\n\n0x0F8727F49\n\n0x060FAFADD\n\n**Services:**\n\n0x0C749257D\n\n0x0CC359518\n\n0x0C55733D2\n\n0x0A0F0EF16\n\n0x0BA252FC4\n\n0x02DC0E42A\n\n0x077C8F76A\n\nFigure 9: Blocklist of pre-computed values of analysis environment artifacts\n\nIf the calculated value is present in the block list, GuLoader stops its execution and therefore\nevades the analysis.\n\nThis technique was used earlier with the original djb2 algorithm. In this particular sample, the\ndjb2 algorithm is customized in a way that the hash is xored with the key 0x0C93EB2D8 in\neach iteration (Figure 9.)\n\n**def djb2_custom(s: bytes) -> int:**\n\nhash = 5381\n\n**for x in s:**\n\nhash = ((hash << 5) + hash) + x\n\nhash = (hash ^ 0x0C93EB2D8) & 0xFFFFFFFF\n\n**return hash**\n\nFigure 10: Customized djb2 algorithm in Python\n\nIn general, values of the block list are indicators analysts can take advantage of for detection\nand identification as long as the algorithm remains the same across samples. GuLoader\nprevents this by slightly changing the algorithm.\n\nFinally, GuLoader creates another process of the installer, injects code, and delivers the\npayload. In this case, the payload is Lokibot and hosted on Google Drive.\n\n\n-----\n\nVMRay Analyzer extracts the malware configuration for both malware families, which eases\nthe detection and identification of infected systems.\n\n**Extracted Payload URLs**\n\nIn addition to Google Drive being abused to host the malicious payload, we have seen\nother services in our extracted configurations.\n\nFigure 10. shows the distribution of hostnames. While Google Drive remains the most\ncommon one, other cloud services like Microsoft OneDrive are used a well.\n\nFigure 11: Distribution of host names\n\n**Conclusion**\n\nIn this post, we took another look at GuLoader with a focus on behavioral differences\ncompared to past samples. We have seen that not only the executable, which leads to\nGuLoader’s shellcode has been changed but also its functionality has been further extended.\n\n\n-----\n\nWhile GuLoader utilizes new techniques to search for artifacts revealing an analysis\nenvironment, some of the existing logic changed to further thwart detection and analysis\nattempts. Given VMRay Analyzer’s unique monitoring approach, GuLoader can’t detect the\npresence of the sandbox and reveal its malicious behavior leading to the delivery of Lokibot.\nThe extracted malware configuration for both families allows analysts and incident\nresponders to quickly take actions to prevent the infection and identify already compromised\nmachines.\n\n**IOCs**\n\n**Initial Sample:**\n\ne7ee8ff4872d57b2fba736ee6556e3f92a3fc1c3c8738c50cc8b1e6acbb4379f\n\n**GuLoader Payload URL:**\n\nhxxps://drive[.]google[.]com/uc?\nexport=download&id=1SrbfkJ9_Bx7Q9qhzb5JeLy5TlBRjWwjF\n\n**Lokibot C&Cs:**\n\nalphastand[.]trade/alien/fre.php\n\nalphastand[.]top/alien/fre.php\n\nalphastand[.]win/alien/fre.php\n\nkbfvzoboss[.]bid/alien/fre.php\n\nhxxp://198[.]187[.]30[.]47/p.php?id=67243588715181780\n\nPascal Brackmann\nPascal is a Threat Researcher at VMRay Labs. His recent projects cover in-depth analysis of\nemerging and evolving malware.\n\n**See Analyzer in action.**\n\nSolve your own challenges.\n\n[REQUEST FREE TRIAL NOW](https://www.vmray.com/try-vmray-products/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-12 - The evolution of GuLoader.pdf"
    ],
    "report_names": [
        "2022-09-12 - The evolution of GuLoader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536084,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1664712627,
    "ts_modification_date": 1664712627,
    "files": {
        "pdf": "https://archive.orkl.eu/43b95f9495d3db9c70fd9af12a1945f1df9f3869.pdf",
        "text": "https://archive.orkl.eu/43b95f9495d3db9c70fd9af12a1945f1df9f3869.txt",
        "img": "https://archive.orkl.eu/43b95f9495d3db9c70fd9af12a1945f1df9f3869.jpg"
    }
}