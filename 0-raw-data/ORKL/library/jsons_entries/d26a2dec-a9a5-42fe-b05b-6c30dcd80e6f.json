{
    "id": "d26a2dec-a9a5-42fe-b05b-6c30dcd80e6f",
    "created_at": "2023-06-05T02:07:39.241927Z",
    "updated_at": "2025-03-27T02:09:29.736899Z",
    "deleted_at": null,
    "sha1_hash": "a09dd19b89d416fe1f5a16cb0614813f60b91e6c",
    "title": "2023-05-09 - Advanced Cyberchef Tips - AsyncRAT Loader",
    "authors": "",
    "file_creation_date": "2023-06-04T12:41:16Z",
    "file_modification_date": "2023-06-04T12:41:16Z",
    "file_size": 12968719,
    "plain_text": "# Advanced CyberChef Tips: AsyncRAT Loader\n\n**[huntress.com/blog/advanced-cyberchef-tips-asyncrat-loader](https://www.huntress.com/blog/advanced-cyberchef-tips-asyncrat-loader)**\n\nThe Huntress ThreatOps team encountered and investigated an infection involving a\nmalicious malware loader on a Huntress-protected host. This investigation was initiated via\npersistence monitoring, which triggered on a suspicious visual basic (.vbs) script persisting\nvia a scheduled task.\n\nThe script was highly obfuscated and required manual analysis and decoding to investigate.\nToday we’ll demonstrate our methods and thought process for manually decoding the\nmalware.\n\n[We'll primarily be using CyberChef, alongside RegExper for validating regular expressions.](https://gchq.github.io/CyberChef/)\n\n[If you would like to follow along, here is a link to the malware sample.](https://bazaar.abuse.ch/sample/26c9f29fceaee8b13ba0fe4d7170f50c8046e43e11e461a43ce92b22d8e24bf5/)\n\n(If you do choose to follow along, make sure you do so inside of a safe virtual machine and\nnot on your host computer)\n\n## Let's Get Started\n\nThe initial investigation was for a persistent .vbs file residing inside of a user's startup\ndirectory. There are few legitimate reasons for a .vbs file to be persistent, so we immediately\nobtained the file for further analysis and investigation.\n\nGiven that .vbs is text-based, we transferred the file into an analysis Virtual Machine and\nopened it using a text editor. Upon realizing the script was obfuscated, we transferred the\ncontents into CyberChef.\n\n## Analysing the File\n\nThe obfuscated contents of the script can be seen below.\n\n\n-----\n\nThere are numerous forms of obfuscation used - (Chr(45), StrReverse, Replace, etc.)\n\nWe simplified the script using a syntax highlighter set to \"vbscript\".\n\nSyntax highlighting is a simple and effective means to improve the readability of an\nobfuscated script, prior to doing any form of manipulation or analysis.\n\nTip: Leaving the language as “auto-detect” will work, but we have found that highlighting is\nsignificantly quicker if specified manually. This also solves the occasional issue where\nCyberchef incorrectly identifies the language of an obfuscated script.\n\n\n-----\n\n### Obfuscation 1: Decimal Encoded Values\n\nDelving into the first few lines of output, there are numerous numerical values scattered\n[around. Each numerical value is contained within a “chr” function.](https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/chr-function)\n\n[A quick Google reveals that \"chr\" is a built-in visual basic function that converts decimal](https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/chr-function)\nvalues into their plaintext/ascii representation.\n\n[You can find a reference to the chr function here and](https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/chr-function) [here. You can also find a full list of](https://www.w3schools.com/asp/func_chr.asp)\n[decimal values and their ASCII equivalents here.](https://www.asciitable.com/)\n\nHere are the “chr” obfuscated values in their original obfuscated form.\n\nThese numerical values can be crudely decoded using CyberChef, by manually copying out\neach value and applying \"From Decimal\".\n\n\n-----\n\nManually copying the values is simple and will work most of the time, but it is timeconsuming for a large script and requires an analyst to manually copy the results back into\nthe original script.\n\nWe'll now show how to automate this process using CyberChef.\n\n### Obfuscation 1: Automating the From Decimal Using CyberChef\n\nTo automate the decimal decoding, the ThreatOps team utilized some regex and advanced\nCyberChef tactics.\n\nAt a high level, this consisted of:\n\nDeveloping a regex that would find decimal encoded values (locate the encoded data)\nConverting this regex into a subsection (this tells CyberChef to act ONLY on the\nencoded data)\nExtracting decimal values (Remove the \"chr\" and any surrounding data)\nDecoding the results (Perform the \"From Decimal\" decoding)\nRemoving surrounding junk (Cleaning up any remaining junk)\nRestoring the script back to “normal”\n\nSo let’s see that in action.\n\n[We first implemented a regex pattern to automatically highlight and extract “chr” encoded](https://en.wikipedia.org/wiki/Regular_expression)\nvalues from the original script.\n\nAs a means of testing our initial regex, we utilized the “Regular Expression” and “Highlight\nMatches” option in CyberChef.\n\nThis allowed the effectiveness of our regex to be observed in real-time.\n\nIf anything didn’t match as intended, we could easily adjust the Regex and the highlighting\nwould update accordingly.\n\n\n-----\n\nThe “Highlight Matches” provides similar functionality to the popular regex testing site\n[regex101.](https://regex101.com/)\n\n[A visual representation of the regex can be seen here - courtesy of regexper.com.](https://regexper.com/#chr%5C%28%5Cd%2B%5C%29)\n\n(Regexper.com is an excellent site for visually learning and testing regex)\n\n\n-----\n\nThe regex successfully matched the “chr” and encoded numerical values, so we then\nconverted it into a “subsection”.\n\nA subsection takes a regex as input, and forces all future operations to match only on values\nthat match the regex.\n\nThe process of \"converting to a subsection\", is just copy-and-pasting the regex from \"Regular\nExpression\" to \"Subsection\".\n\n**What is a subsection?**\n\n**A TLDR: A subsection is a feature of CyberChef that forces all future operations to apply**\nonly to values that match a provided regex. (Eg the highlighted values from previous\nscreenshots)\n\nA subsection is an effective way to “hone in” on particular content or values, allowing bulk\noperations without mangling the entire script.\n\nThis was useful to avoid accidentally decoding numerical values which are unrelated to the\n“chr” functions and encoding.\n\nTo hone in on our values, we replaced our previous regex with a subsection. (Making sure to\nkeep the regex the same)\n\n\n-----\n\nAt first glance this isn t exciting - but the true power arrives when the recipe is expanded.\n\nFor example, the “chr” can now be easily removed, leaving only the brackets () and decimal\nvalues.\n\nBy applying the subsection before the find/replace, we can use the \"chr\" as a marker to hone\nin on specific values.\n\nWe could skip the subsection and go straight to find/replace, but this may result in\naccidentally acting on other numerical values that are unrelated to our current decoding.\n\nA second regex can now be applied, this will extract only the numerical values our previous\nregex.\n\nIn the below screenshot - note how “chr(45)” becomes “45” and “chr(110)” becomes “110”\nand so on.\n\n\n-----\n\nHoning in on those results, we can see that the “chr” and “()” have been removed. This\nleaves only the integers/numerical values, as well as the “& used for string concatenation.\n(We’ll deal with these later.)\n\nA “from decimal” can then be added, which will convert those numerical values back into\nASCII.\n\n\n-----\n\nClose up, it’s still a bit messy, but we’ll deal with that in a moment.\n\nFor now, we can observe that the “chr” operations have been replaced with their ASCII\nequivalents. (Although the The String concatenations make this hard to read)\n\nIn order to clean up for good, we needed to do two things.\n\nFirst, we would need to undo our subsection. This would allow us to remove the “&”\noperations that were not included in our initial regex.\n\nThis can be done with a “merge” operation. (Essentially an “Undo” button for subsections)\n\nWe then utilised a Find/Replace to remove the quote “” and “&” junk.\n\nThe recipe then looked like this. The most complex piece is the `&?”&?\\+?` regex.\n\nThis looks for any quotes that are preceded or followed by a & character. The (?) specifies\nthat the “&” is optional.\n\n\n-----\n\n[A visual representation of the regex, courtesy of regexper.com.](https://regexper.com/#%26%3F%E2%80%9D%26%3F%5C%2B%3F)\n\nWe then had a nice decoded value and no remaining “chr” operations in our script.\n\nIf you’re confident with your regex, you could incorporate the previous two into one.\n\nThis ultimately leaves something like this. Which is conceptually the same, but slightly\ncleaner than the original recipe we had before, at the cost of a slightly more complex regex.\n\n\n-----\n\n[For a deeper explanation of the regex used, we highly recommend regexper.com and](https://regexper.com/#%22%3F%26%3Fchr%5C%28%5Cd%2B%5C%29%26%3F%22%3F)\n[regex101.com.](https://regex101.com/)\n\n[If you’re completely new to regex, we also strongly recommend regexone.com.](https://regexone.com/)\n\n### Obfuscation 1: Conclusion\n\nTLDR - Defeating Decimal Encoding:\n\nUse regex to locate the encoded values (locate the chr)\nUse a subsection to ‘act’ on the encoded values (Hone in on the chr)\nUse Find/Replace to remove surrounding junk (remove the chr)\nPerform the decoding (from decimal)\nIf necessary, remove any additional junk (remove the string concatenation)\nMake it pretty with a syntax highlighter\n\n\n-----\n\n### Obfuscation 2: Reversed Strings\n\nFurther analysis determined that there were reversed strings scattered throughout the code.\nThis is typically used to evade simple string-based detection and analysis.\n\nThis would likely evade YARA signatures that scan for suspicious strings in files that have\nbeen saved to disk.\n\nBelow we can see the reversed content.\n\nThis encoding is simple and is literally just reversing the content of a string.\n\nWe could perform this operation manually in CyberChef, but like before, we knew it would\ntake a while to deal with all of the reversed values.\n\nThe full [StrReverse specification is here.](https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/strreverse-function)\n\nWe decided to do these operations in bulk using CyberChef.\n\n**Our approach…**\n\nUtilise regex to locate the “reversed” values\nUse Find/Replace or regex to remove surrounding junk (The StrReverse function name\nin this case)\nPerform the decoding (Utilising “Reverse” + “by Character”)\nRestore the original state (Utilise a merge to undo the subsection)\n\nFirst, we developed the regex to locate only the reversed values.\n\n\n-----\n\nWe used the same method as before, utilising regular expression and highlight matches\nuntil the highlight matched exactly what we needed.\n\n(We all have our own regex styles, you can use any regex which successfully highlights the\ncontent that you are interested in).\n\n[An overview of the regex, courtesy of regexper.com](https://regexper.com/#StrReverse%5C%28%22%5B%5E%22%5D%2B%22%5C%29)\n\nThis basically says\n\nGrab any occurrence of “StrReverse(“ including the opening parenthesis\nGrab everything that is not a double quote\nGrab the ending double quote and closing parenthesis.\n\nWe then converted the regex into a subsection and followed a similar methodology to\nbefore.\n\nSubsection - Extract the “general” content of interest (in this case, “StrReverse” and\nany following quoted content)\n\n\n-----\n\nRegular Expression - Extract the exact content of interest (Extract only the content in\nquotes)\nReverse + By Character - Perform the reverse operation.\n\nWe then observed that the “StrReverse” operations were removed and cleaned.\n\nWith a before and after of an offending line.\n\n### Obfuscation 3: Replace\n\nBuilding on our last result, we could now see numerous “replace” operations scattered\nthroughout the code.\n\nWe followed the same process as before.\n\nUse regex to “locate” the “encoded” values\nUse a subsection to “act” on the encoded values\nPerform the decoding\nRestore the script to a clean state\n\n\n-----\n\nWe utilised regex to locate our values of interest.\n\nThis essentially grabs “Replace” followed by the next three values contained in double\nquotes.\n\nAfter confirming that our regex worked as intended, we converted the regex into a subsection\nand applied a register.\n\nA register would allow us to extract values from the script and store them in “registers”, which\nare the CyberChef equivalent of variables. This would allow us to better implement the string\nreplace operation.\n\nIn order to apply a register, we applied the same regex as before, but added parentheses\naround the values that we wanted to store as variables.\n\nThis concept is also known as a “capture group” if you’re already familiar with regex.\n\n[(You can find a short tutorial on capture groups on regexone.com)](https://regexone.com/lesson/capturing_groups)\n\nWe briefly shortened the malware script to better demonstrate this concept. See how the\nvarious values in the “replace” operation are now stored as variables $R0, $R1, $R2 etc.\n\n\n-----\n\n[Another graphical explanation courtesy of regexper.com.](https://regexper.com/#Replace%5C%28%28%22%5B%5E%22%5D%2B%22%29%2C%22%28%5B%5E%22%5D%2B%29%22%2C%22%28%5B%5E%22%5D%2B%29%22%5C%29)\n\nWe had successfully extracted values of interest using registers. Which we then applied to a\nfind/replace operation.\n\n\n-----\n\n-----\n\nThis operation was able to convert this original line into the following.\n(Again, the malware script has been shortened to demonstrate the concept)\n\nWe then restored the full malware script and were able to obtain the following decoded\ncontent. Noting that the Replace operations were now removed.\n\nThe completed recipe can be seen in the screenshot below.\n\n\n-----\n\n(Note the optional addition of find/replace to turn backslashes into hyphens. The initial\nextracted backslashes were causing issues with the find/replace operation, this isn't\nnecessary to do but it results in a slightly cleaner output)\n\n### Obfuscation 4: String Concatenation\n\nWe then had one final obfuscation remaining. It is arguably the simplest so far and ironically\nthe only one that could not be resolved via CyberChef.\n\nThroughout the code are concatenated strings that the malware previously stored in\nvariables.\n\nAn attempt was made to resolve this using subsections and registers, but ultimately we could\nnot find a solution.\n\nWe then found a workaround that wasn’t CyberChef, but technically didn’t involve leaving the\nCyberChef window so it was close enough.\n\nHere is the script with the original string concatenations \"&\"\n\nWe then replaced the visual basic string concatenations (&) with a javascript equivalent (+)\n\n\n-----\n\nThe firefox developer console to dynamically concatenate the strings.\n\nThe concatenated strings can be seen below. This reveals the ultimate intention and purpose\nof the script, which was to utilize Powershell to execute a second payload (a batch script)\nstored on the machine.\n\nFor the sake of readability and completeness, we manually replaced the last decoded\nvalues, leaving this as the final state of the script.\n\n\n-----\n\n### Before and After Pics\n\nHere you can see a full before and after of our CyberChef Decoding.\n\nHere you can see a full before/after, with the string concatenations and assigments manually\nremoved.\n\n## Conclusion\n\nAt this point, we considered the script to be fully decoded and proceeded to analyze the\nremaining .bat script. This .bat script was itself obfuscated, and unravelled itself into another\n(unsurprisingly) obfuscated PowerShell script. This PowerShell script contained a loader for\nAsyncRat malware.\n\nIf you’re interested in seeing some additional analysis of the remaining payloads, we highly\nrecommend the following posts.\n\n\n-----\n\n[Matthew Brennan - @embee_research](https://twitter.com/embee_research)\n[https://twitter.com/embee_research/status/1589453390450683905?s=20](https://twitter.com/embee_research/status/1589453390450683905?s=20)\n[Michael Elford - @Maverick_011](https://twitter.com/011Maverick)\n\nhttps://hcksyd.medium.com/asyncrat-analysing-the-three-stages-of-execution378b343216bf\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-09 - Advanced Cyberchef Tips - AsyncRAT Loader.pdf"
    ],
    "report_names": [
        "2023-05-09 - Advanced Cyberchef Tips - AsyncRAT Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1685930859,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1685882476,
    "ts_modification_date": 1685882476,
    "files": {
        "pdf": "https://archive.orkl.eu/a09dd19b89d416fe1f5a16cb0614813f60b91e6c.pdf",
        "text": "https://archive.orkl.eu/a09dd19b89d416fe1f5a16cb0614813f60b91e6c.txt",
        "img": "https://archive.orkl.eu/a09dd19b89d416fe1f5a16cb0614813f60b91e6c.jpg"
    }
}