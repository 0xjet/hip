{
    "id": "ea55407f-9a59-40fe-b95e-98b72a26ef98",
    "created_at": "2023-06-05T02:06:05.11423Z",
    "updated_at": "2025-03-27T02:15:38.017002Z",
    "deleted_at": null,
    "sha1_hash": "74fd83cf2a3b4e35ebb4e28310507f66d827ff78",
    "title": "2022-11-11 - GraceWire - FlawedGrace malware adventure",
    "authors": "",
    "file_creation_date": "2023-06-04T12:45:16Z",
    "file_modification_date": "2023-06-04T12:45:16Z",
    "file_size": 561055,
    "plain_text": "# GraceWire / FlawedGrace malware adventure\n\n**blog.codsec.com/posts/malware/gracewire_adventure/**\n\nNovember 11, 2022\n\n#### This is some note about the Gracewire malware that I come across in last year during some investigation. Maybe this will help people who are working on it. I’ve documented the persistence mechanism and the recovery mechanism for the Virtual File System (aka the configuration)\n\n The persistence mechanism was well hidden beneath a lot of layers and allowed it to be fileless. They change the ComHandler of an existing Windows Task schedule. Tools like autoruns still think it’s a Windows valid entry and hide it. The modification timestamp of the task schedule file can be used to find out the malware infection.\n\n Gracewire is complex, Rolf Rolles publish a state-of-the-art IDB on one version of FlawedGrace/Gracewire. His work saved me a lot of time in getting the information I needed.\n\n## Gracewire\n\n Gracewire fileless loading version\n\n#### This information comes from an infected system, where no malware was found directly on the disk.\n\n### Stage 1\n\n#### The malware maintains persistence by updating an existing Windows task schedule\n```\n\\Windows\\System32\\Tasks\\Microsoft\\Windows\\Registry\\RegIdleBackup (this task is hard-coded\n\n inside the malware). It changes the ComHandler action with the UUID {CF8C0CD5-8DAA-4899-91FEDF8DD3D165DE}.\n\n They did not timestomp the file after updating it. So, it’s possible to find the persistence with a timeline analysis.\n\n In the registry, they create the key HKLM:\\Software\\Classes\\CLSID\\{CF8C0CD5-8DAA-4899-91FEDF8DD3D165DE}\\TreatAs is set to {972903D2-3A23-4C4D-A3D2-B6DE37AC983C}. The execution of the\n\n task schedule will, in fact, execute the command saved in HKLM:\\Software\\Classes\\CLSID\\\n{972903D2-3A23-4C4D-A3D2-B6DE37AC983C}\\LocalServer.\nLocalServer contains the command below\nC:\\Windows\\SYstem32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle Minimized -c \"&\n{iex([System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('...')))}\"\n\n I’ve to hide the payload a little. This command will load and execute the PowerShell script saved in\nHKLM:\\Software\\Classes\\CLSID\\{972903D2-3A23-4C4D-A3D2-B6DE37AC983C}\\ProgID under the\n\n name {972903D2-3A23-4C4D-A3D2-B6DE37AC983C}\n\n The two UUID derivate from a seed value, but we don’t know the seed value.\n\n```\n\n-----\n\n### Stage 2\n\n#### Inside the key HKLM:\\Software\\Classes\\CLSID\\{972903D2-3A23-4C4D-A3D2```\nB6DE37AC983C}\\ProgID the entry name {972903D2-3A23-4C4D-A3D2-B6DE37AC983C} has for value a\n\n PowerShell script.\nfunction DJEKGLRA{param($DJEKGLRB)\n[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($DJEKGLRB))....\n\n This script loads a DLL from HKLM:\\Software\\Classes\\CLSID\\{972903D2-3A23-4C4D-A3D2B6DE37AC983C}\\VersionIndependentProgID with the name {972903D2-3A23-4C4D-A3D2B6DE37AC983C} and execute it inside the powershell.exe process.\n\n### Stage 3\n\n#### This file is not on VT and I can’t share it.\n\n stage3.bin\n\n file size 61440 (60.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n PE date 2012-12-28 02:58:07 GMT\n\n This DLL is packed with a simple packer.\n\n stage3.unpack.bin\n\n file size 36864 (36.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n PE date 2010-12-14 15:47:25 GMT\n\n This DLL assumes that it’s running inside another thread than the main one; otherwise it will exit. The goal is to load the final payload from a registry key. The registry key used depends on the system information.\n\n This file is later found in the VFS embed inside the installer (file /c) with this information. I provide it on the GitHub repo in samples.zip.\n\n c.embded.stage3.dll\n\n file size 36864 (36.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 18d1e87283eb975a76bb682e59dbaafa\n\n sha1 24a7988b43b76bc19a814ba5d44a8bd5fa6f54fc\n\n```\n\n-----\n\n#### c.embded.stage3.dll\n\n sha256 0e82f50477a4df52bdee361ef155d3c0496f2cd87523c17f492216e8ebceff9a\n\n imphash c438b77d56d8a538d975960a500f2199\n\n PE date 2014-08-07 02:26:11 GMT\n\n It generates 3 UUID that derivate from a seed, a volume serial id, and computer name (script is here. Depending on the usage, it will be formatted or not.\n```\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x6f3ad240; desc: loader_reg_key; val: {8D7B67726772-8D7B-1C17-07FB05037B8D}\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x91fa4e91; desc: loader_reg_name; val: {73BBFBA3FBA3-73BB-80C6-C705D49FBB73}\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x350af376; desc: loader_enc_key; val:\n44464bd744464bd7213d37a133224bd7\n\n Seed 0x6f3ad240 is used to generate the registry key SOFTWARE\\Classes\\CLSID\\{8D7B6772-67728D7B-1C17-07FB05037B8D}\n\n Seed 0x91fa4e91 is used to generate the value name of the registry key.\n\n The value will contain a payload encrypted. The key to decrypt it come from the value generated by the seed 0x350af376. Due to how they implement it, the encryption is weak and can be simplified to a xor with a one-byte key. (python unpacker here)\n\n The payload extracted will be called grace.loader.bin\n\n### GraceWire loader payload\n\n#### grace.loader.bin / 6f3ad240.dec.bin\n\n file size 1146880 (1.1MiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 534362e1316c41dd0637f757c7766858\n\n sha1 0377a70765062922e9b6a2363b958a2dfc8b62f7\n\n sha256 a2da59241b1f6d898f0f32087b2684da2a38954063b2c0078a459171c27eab26\n\n imphash\n\n PE date 2012-12-28 02:58:07 GMT\n\n The same packer as stage 3 is used.\n$ python3 grace_unpacker.py unpack -f ../samples/Gracewire_sample1/grace.loader.bin >\n../samples/Gracewire_sample1/grace.loader.unpack.bin\n\n$ file ../samples/Gracewire_sample1/grace.loader.unpack.bin\n\n../samples/Gracewire_sample1/grace.loader.unpack.bin: MS-DOS executable PE32+ executable (DLL)\n(GUI) x86-64 for MS Windows\n\n```\n\n-----\n\n#### grace.loader.unpack.bin / 6f3ad240.unpack.hd.bin\n\n file size 1122304 (1.1MiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 0a8ebb14016dc90af35c6360d73e126a\n\n sha1 cbaffd2383bf9fb518f7a7d13d25a7cc262c99ed\n\n sha256 bb151716c5755f4ddb39ee16f0041e42044e3b408abad1300c7107f727093df9\n\n imphash f8f56226b601010b649b11718ebc7593\n\n PE date 2015-05-28 06:31:14 GMT\n\n This is the loader for the main module of GraceWire/FlawedGrace, which is in charge to get the configuration and the main module, migrate to another process and execute the main module.\n\n To work on this file, I wrote few scripts\n\n gracewire_loader_string_ida.py decrypt and add in comment the string in the IDB qiling_grace_loader_resolv.py Qiling script to find out the id, name of import used. This script used to work, but now is failing. I update it to work on the recent Qiling version but during some decryption there is some junk, so it failed to resolv an import and don’t get fully initialized. grace_loader_generate_uuid.py The script used to generate the UUID for a system common to the different layer.\n\n They used some obfuscation probably with LLVM to add a lot of junk code, between real instruction\n\n grace_core_ida_obfuscation\n\n After removing some of the obfuscation with IDA\n\n grace_core_ida_deobfuscation\n\n At one moment my script was most likely okay and I try to be too aggressive in the deobfuscation so at the end that was removing useful information. I lost the working version. The script is here for ida_grace_core_deobfucation.py and ida_grace_core_deobfucation_old.py\n\n The malware can load its configuration from at least two different places:\n\n From the resource of the DLL himself (resource name N) encryption is AES and key is\n```\n   er0ewjflk3qrhj81\n\n From the registry using a similar system as we saw in stage 3\n\n In this file, the resource section is corrupt, probably on purpose, so it’s not inside.\n\n The configuration in the registry for the system can be found in SOFTWARE\\Classes\\CLSID\\\n{BB5B4C31-4C31-BB5B-3754-27CD46285BBB} (seed 0x591af903). This value is encrypted with AES\n CBC (slightly modified see below) the key is derivate from seed 0x46ed5316 and only the first 16\n\n```\n\n-----\n\n#### bytes or the UUID without separator are used so 24E6ACA424E6ACA4.\n\n I provide a copy of the decrypted registry key in grace_vfs_from_reg_93f4d91a.vfs\n\n The decrypted data follow the DataHive structure describe latter.\n\n Before passing the execution to the main module, the malware will copy the hive to a file in memory under the name Global\\7c1828b07c1828b0196354c60b7c28b0 or Local\\B028187C-187C-B028-6319```\n54C60B7C28B0. This come from the seed 0x5269ad4e but can be modified with the command line\n\n parameter cs. A mutex is created with the name m1828B07C1828B0196354C60B7C28B0 using the seed\n0x5269ad4e. This allows modules to get access to the hive data.\n\n UUID and seed value for this payload:\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x46ed5316; desc: config_enc_key; val:\nA4ACE624E624A4AC\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x591af903; desc: config_reg_key; val: {BB5B4C314C31-BB5B-3754-27CD46285BBB}\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x5269ad4e; desc: mutant; val: Local\\B028187C-187CB028-6319-54C60B7C28B0\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x5269ad4e; desc: mutant; val:\nGlobal\\7c1828b07c1828b0196354c60b7c28b0\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x5269ad4e; desc: mutant; val:\nm1828B07C1828B0196354C60B7C28B0\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x93f4d91a; desc: unknown; val: {71B56C28-6C2871B5-174D-C9075F08B571}\n\ncn: WINDEV2210EVAL; vsn: 0xe241b532; seed: 0x6f6772e0; desc: unknown; val: {8D26C7D2-C7D28D26-BCB7-5AFBA5A3268D}\n\n```\n\n-----\n\n#### At that point, I knew that it was loading some sort of VFS, but due to the obfuscation in this version, I wasn’t really able to make quick progress. Since I was seeing some sort of configuration and 5 PE files, at that point that was enough information.\n\n A month or two later, I had some free time and decided to try reversing the VFS and found Rolf Rolles’s post and IDB. I was able to quickly write a python script to dump the VFS.\n\n\n-----\n\n```\n$ python3 grace_vfs.py f ../samples/grace_vfs_from_reg_93f4d91a.vfs\n\nByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\npack 0x00000018 | name =\n\n entry 0x000000db | name = v | 0x1\n\n entry 0x000000ec | name = l2 |\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\\nx00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n entry 0x000aa0fe | name = p1 |\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\\nx00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n entry 0x000af110 | name = p2 |\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\\nx00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n entry 0x000b5122 | name = ni | AC0EF5AB240F4FA1E09AF46A4F789CD4\n\n entry 0x000b5183 | name = sr | 0x1\n\n entry 0x000b5195 | name = hv | 0x42b\n\n entry 0x000b51a7 | name = h |\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\\nx00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n entry 0x001cf1b8 | name = avt | 0x1\n\n entry 0x002cc25b | name = tlc | 0x0\n\n entry 0x002cc26e | name = au | 0x0\n\n entry 0x00341292 | name = se | 0x99533bfb\n\n entry 0x003412a4 | name = ve | 0x1\n\n entry 0x003412b6 | name = c |\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\\nx00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n entry 0x003b62c7 | name = lo | 0x2\n\n pack 0x000b5154 | name = AC0EF5AB240F4FA1E09AF46A4F789CD4\n\n pack 0x00000038 | name = mt\n\n  entry 0x0000005a | name = w | AC2696B99D5E44B21A9A4B5987DCC0E4\n\n  pack 0x00000049 | name = se\n\n  pack 0x0000008b | name = [0]\n\n   entry 0x0000009d | name = p | 0x1bb\n\n   entry 0x000000ae | name = h | 46.161.40.87\n\n  pack 0x00000027 | name = mo\n\n  pack 0x002cc1ed | name = us\n\n  pack 0x002cc1fe | name = D08F22EDA5AB458E68B9C0D8508ECEDA\n\n   entry 0x002cc22d | name = n | SYSTEM\n\n   entry 0x002cc24a | name = p | 0x218\n\n pack 0x002cc280 | name = m\n\n#### I dump the VFS, I provide a copy in samples.zip samples/Gracewire_sample1/dump_vfs\n\n```\n\n-----\n\n```\ndump_vfs\n\n├── AC0EF5AB240F4FA1E09AF46A4F789CD4\n\n│  └── mt\n\n│    ├── se\n\n│    │  └── [0]\n\n│    │    ├── h\n\n│    │    └── p\n\n│    ├── us\n\n│    │  └── D08F22EDA5AB458E68B9C0D8508ECEDA\n\n│    │    ├── n\n\n│    │    └── p\n\n│    └── w\n\n├── au\n\n├── avt\n\n├── c\n\n├── h\n\n├── hv\n\n├── l2\n\n├── lo\n\n├── ni\n\n├── p1\n\n├── p2\n\n├── se\n\n├── sr\n\n├── tlc\n\n├── v\n\n└── ve\n\n#### Inside we have the 5 payloads and some configuration fields.\n\n l2\n\n file size 696320 (680.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 562dd15f883320fa04c0b5a9bdb003cd\n\n sha1 da74135a4c3630e6a5c7e0d7554bcdd370a76358\n\n sha256 ca03ff2ab99e9d0bac8e92b0697a2fea0f06d5384648551bb8648efa31f61ed9\n\n imphash bbcf353adf7d223bba7b33576d501b1d\n\n PE date 2014-09-05 01:38:14 GMT\nl2 is GraceWire main module\n\n p1\n\n file size 20480 (20.0KiB)\n\n file magic PE32 executable (DLL) (GUI) Intel 80386, for MS Windows\n\n md5 88695dbddd4fc57025b523f4fca268d7\n\n```\n\n-----\n\n#### p1\n\n sha1 57ab5d9b5302644e91e3953062b40c5346b236e3\n\n sha256 f92dbf7943590c2c4011f911ba9ba445010c9d5895b5c8b57a5da9c8708c221d\n\n imphash\n\n PE date 2009-10-19 13:41:28 GMT\n```\np1 is a 32bit DLL used to inject 32bit payload\n\n p2\n\n file size 24576 (24.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 b032fcb03d685b591054855572ac8f85\n\n sha1 869b38a87802af5628fe8a318323bfcb24229086\n\n sha256 a0286ea3521167642cbc73dbe1c23bc9870bc7a3012ee521be98b38836ce834e\n\n imphash\n\n PE date 2018-09-08 05:36:12 GMT\np2 is a 64bit DLL used to inject 64bit payload\n\n h\n\n file size 1155072 (1.1MiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n md5 69d2507bbf73cf4fa6d6ca1647754f03\n\n sha1 93eafaa180b5085babee7b2bb85c0a349131328f\n\n sha256 0d37468eb7748e4f26f54e6858e2e5e2389ba3530552394abbd56bfeb873e5d0\n\n imphash\n\n PE date 2018-09-08 05:36:12 GMT\nh is the GraceWire Loader (packed) found in registry\n\n c\n\n file size 479232 (468.0KiB)\n\n file magic PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n```\n\n-----\n\n#### c\n\n md5 80a20106ced1a5d9f350b1401dbe7d14\n\n sha1 753561bf6da3cbb75711d109ed0e38b7abb28db8\n\n sha256 6d15a0807858dce0be652e480fa7f298482c7bbf2c1e116e6cf0a3d3df95180f\n\n imphash 7edbb1f08aaa2756392c6eb6a6201489\n\n PE date 2010-05-08 17:04:47 GMT\n```\nc is the installer to setup the stage3 ?? two DLLs embedded\n\n## Another older version\n\n#### This was another file I took a look when I wanted to start looking at the VFS [this file efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74]\n [https://www.virustotal.com/gui/file/efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be 587647b74].\n\n efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74\n\n file size 564040 (550.8KiB)\n\n```\n\n#### file magic\n\n\n#### PE32 executable (GUI) Intel 80386, for MS Windows, Nullsoft Installer self-extracting archive\n\n\n#### md5 4b9054475ff9aa15be35b42264715354\n\n sha1 a088dfaee1779878353a1dc347a91a892e5dfd74\n\n sha256 efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74\n\n imphash 3abe302b6d9a1256e6a915429af4ffd2\n\n PE date 2018-01-30 03:57:45 GMT\n\n The first layer is pack, once unpack we get this version. The PE timestamp is legit the same timestamp is found in other PE directory entries. A date in strings Nov 20 2017 10:53:33 is used when building the system information for the field built\n\n efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74_unpacked\n\n file size 455680 (445.0KiB)\n\n\n#### file magic\n\n\n#### PE32 executable (GUI) Intel 80386, for MS Windows\n\n\n#### md5 b405d76e325c20d951e74b33781540ba\n\n sha1 eeb1313ae855af3642a56022eb6298a470d76671\n\n\n-----\n\n#### efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74_unpacked\n\n sha256 efea3b1ccea2a9f592631b282b62ba542d5eb73fd4ee1cecfe4efc379d215305\n\n imphash af1157c6aa4a47f92f955f129e023851\n\n PE date 2017-11-20 18:54:59 GMT\n\n This sample doesn’t have a VFS/configuration inside, this version doesn’t load from the registry or resource.\n\n The part in charge to load the configuration from the disk builds the path to the VFS by getting the value for CSIDL_COMMON_APPDATA (normally C:\\ProgramData); then generate a UUID base on the drive serial number and computername. The algorithm to derivate the UUID is not the same in this one.\n\n\n-----\n\n#### The function GenerateUuid start at 0x004323D0 and ends at 0x004325E3.\n\n I used Qiling to execute the function to be able to generate UUID for a targeted system.\n\n The interesting part is here, the complete script is here.\n\n\n-----\n\n```\n  # Set hook on GetVolumeInformationW because Qiling\n\n  # implementation set a string instead of a DWORD in lpVolumeSerialNumber\n\n  # I should push a pull request\n\n  ql.os.set_api(\"GetVolumeInformationW\", my_GetVolumeInformationW, QL_INTERCEPT.CALL)\n\n  # We allocate a buffer and set it as arg0 of the target function\n\n  # IDA detect the calling convention as __thiscall so arg0 is ecx\n\n  ptr = ql.mem.map_anywhere(256, minaddr=0x1000)\n\n  # this string is set the default one set by the malware\n\n  ql.mem.string(ptr, \"B597B8EF3F3F4BDE683FEFEF65479B0E\")\n\n  ql.arch.regs.write(\"ecx\", ptr)\n\n  #ql.arch.stack_push(ptr)\n\n  # We set the sandbox profile to match the target VSN and computername\n\n  ql.os.profile[\"VOLUME\"][\"serial_number\"] = f'{vsn:d}'\n\n  ql.os.profile[\"SYSTEM\"][\"computername\"] = computername\n\n  # The unpack version as a bug in the CRT (maybe a bad unpack)\n\n  # we have to stop before the vsnprintf and dump the fmt parameter by hand\n\n  # ql.run(begin=0x4323d0, end=0x4325d7)\n\n  # data = ql.mem.read(ptr, 128)\n\n  ql.run(begin=0x4323d0, end=0x4325c7)\n\n  # We are at the call to vsnprintf we can dump the parameters\n\n  [buffer, buffercount, maxcount, ptr_fmt, arg0, arg1, arg2, arg3, arg4, arg5] = \\\n\n    [ ql.arch.stack_pop(), ql.arch.stack_pop(), ql.arch.stack_pop(),\n\n     ql.arch.stack_pop(), ql.arch.stack_pop(), ql.arch.stack_pop(),\n\n     ql.arch.stack_pop(), ql.arch.stack_pop(), ql.arch.stack_pop(),\n\n     ql.arch.stack_pop()]\n\n  # We read the format string from the ptr and format it\n\n  fmt = ql.mem.string(ptr_fmt)\n\n  uuid = fmt % ( arg0, arg1, arg2, arg3, arg4, arg5 )\n\n  return uuid\n\n$ export QL_ROOTFS=$HOME/truenas/lab-re/qiling/rootfs\n\n$ python3 qiling_grace_uuid.py\n../efcee275d23b6e71589452b1cb3095ff92b10ab68cd07957b2ad6be587647b74/efcee275d23b6e71589452b1cb\n3095ff92b10ab68cd07957b2ad6be587647b74_unpacked 0xe241b532 WINDEV2210EVAL\n\nWINDEV2210EVAL ; 0xe241b532 ; 99d912e9a7db7b98698cc3acefa57b98\n\n#### For the test system, the file will be in C:\\ProgramData\\99d912e9a7db7b98698cc3acefa57b98.dat\n\n Now we can locate the VFS file.\n\n The VFS for this version is encrypted in AES CBC and used the key c3oeCSIfx0J6UtcV\n\n```\n\n-----\n\n## Custom AES implementation\n\n#### The implementation of AES CBC have a subtlety for the last block.\n\n\n-----\n\n```\nimport aes # https://raw.githubusercontent.com/boppreh/aes/master/aes.py\n\n###\n\n# Grace custom AES\n\n###\n\nclass GraceAes(aes.AES):\n\n  def decrypt_cbc(self, data):\n\n    fp = io.BytesIO(data)\n\n    dwLen = len(data)\n\n    previous = fp.read(0x10)\n\n    dst = b''\n\n    while True:\n\n      if fp.tell() >= dwLen - 0x20:\n\n        # Read last full block and decrypt it\n\n        d = fp.read(0x10)\n\n        val = self.decrypt_block(d)\n\n        # Read the final block and xor with decrypted last full block\n\n        d2 = fp.read(0x10)\n\n        val2 = aes.xor_bytes(val, d2)\n\n        # Append the decrypted block bytes to get a full block\n\n        d2 += bytes(val[-(0x10-len(d2)):])\n\n        # decrypt and CBC\n\n        val = self.decrypt_block(d2)\n\n        val = aes.xor_bytes(previous, val)\n\n        dst += val\n\n        dst += val2\n\n        break\n\n        # last case\n\n\n      d = fp.read(0x10)\n\n      val = self.decrypt_block(d) # decrypt\n\n      val = aes.xor_bytes(previous, val) # do CBC\n\n      dst += val\n\n      previous = d\n\n    return dst\n\n## The VFS\n\n#### Now that’s when I found Rolf Rolles’s IDB saved me a lot of time.\n\n He calls those functions DataHive.\n\n```\n\n-----\n\n#### Since he reversed all the internal structure, decoding the VFS was just a matter of copying the structure in a python script and follow the DataHive::Constructor method.\n\n\n-----\n\n```\nclass VFS_ByteStreamHeaderPattern(CStruct_):\n\n  __def__ = \"\"\"\n\n    struct {\n\n      uint32_t magic;\n\n      uint16_t fixed4;\n\n      uint8_t m64BitFlag;\n\n      uint8_t dummy0;\n\n      uint64_t dwHeaderLen;\n\n      uint64_t zero;\n\n    }\n\n  \"\"\"\n\nclass VFS_SerializedEntry32(CStruct_):\n\n  __def__ = \"\"\"\n\n    struct {\n\n      uint32_t dwNextEntryStreamPos;\n\n      uint32_t dwDataStreamPos;\n\n      uint32_t dwSerializedSize;\n\n      uint8_t bValueType;\n\n      uint8_t bEntryNameIsWideString;\n\n      uint8_t wEntryNameLen;\n\n      uint8_t dummy;\n\n    }\n\n  \"\"\"\n\nclass VFS_SerializedPack32(CStruct_):\n\n  __def__ = \"\"\"\n\n    struct {\n\n      uint32_t dwStreamPos_NextSiblingPack;\n\n      uint32_t dwStreamPos_FirstChildPack;\n\n      uint32_t dwStreamPos_FirstEntry;\n\n      uint8_t bEntryNameIsWideString;\n\n      uint8_t wEntryNameLen;\n\n      uint8_t dummy;\n\n    }\n\n  \"\"\"\n\nclass VFS_SerializedPack64(CStruct_):\n\n  __def__ = \"\"\"\n\n    struct {\n\n      uint64_t dwStreamPos_NextSiblingPack;\n\n      uint64_t dwStreamPos_FirstChildPack;\n\n      uint64_t dwStreamPos_FirstEntry;\n\n      uint8_t bEntryNameIsWideString;\n\n      uint16_t wEntryNameLen;\n\n    }\n\n  \"\"\"\n\n\ndef VFS_StrData(data):\n\n  if isinstance(data, bytes):\n\n    return f'{data[0:0x10]}'\n\n  elif isinstance(data, int):\n\n    return f'0x{data:x}'\n\n  else:\n\n    return f'{data}'\n\n\n```\n\n-----\n\n```\ndef VFS_UnserializedData(fp, se):\n\n  fp.seek(se.dwDataStreamPos)\n\n  if se.bValueType == 0: # Bytes\n\n    return fp.read(se.dwSerializedSize)\n\n  elif se.bValueType == 1: # Int\n\n    return se.dwDataStreamPos\n\n    #return struct.unpack('<I', fp.read(se.dwSerializedSize))[0]\n\n  elif se.bValueType == 2: # Int64\n\n    return struct.unpack('<Q', fp.read(se.dwSerializedSize))[0]\n\n  elif se.bValueType == 3: # String\n\n    return fp.read(se.dwSerializedSize).decode()\n\n  elif se.bValueType == 4: # WString\n\n    return fp.read(se.dwSerializedSize).decode()\n\n  return None\n\ndef VFS_BuildEntryMetaData32(fp, pos, depth=0, path='', cb=None):\n\n  s = VFS_SerializedEntry32()\n\n  while(True):\n\n    fp.seek(pos)\n\n    try:\n\n      s.unpack(fp)\n\n    except:\n\n      return\n\n    name = fp.read(s.wEntryNameLen)\n\n    try:\n\n      name = name.decode()\n\n    except:\n\n      logger.debug('failed to decode name')\n\n      pass\n\n    try:\n\n      data = VFS_UnserializedData(fp, s)\n\n      try:\n\n        if cb: cb(f'{path}/{name}', data)\n\n      except Exception:\n\n        logger.exception(\"cb\")\n\n      logger.debug(f'{\" \" * depth}entry 0x{pos:08x} | name = {name} |\n{VFS_StrData(data)}')\n\n    except:\n\n      logger.exception(\"failed to UnserializedData\")\n\n      logger.debug(f'{\" \" * depth}entry 0x{pos:08x} | name = {name}')\n\n    if not s.dwNextEntryStreamPos:\n\n      return\n\n    pos = s.dwNextEntryStreamPos\n\ndef VFS_BuildPackMetaData32(fp, pos, depth=0, path='', cb=None):\n\n  s = VFS_SerializedPack32()\n\n  while(True):\n\n    fp.seek(pos)\n\n    s.unpack(fp)\n\n    fp.seek(pos + s.size -1)\n\n    name = fp.read(s.wEntryNameLen)\n\n```\n\n-----\n\n```\n    try:\n\n      name = name.decode()\n\n    except:\n\n      pass\n\n    # First name is empty so we want to avoid //\n\n    if name != '':\n\n      path_ = f'{path}/{name}'\n\n    else:\n\n      path_ = ''\n\n    logger.debug(f'{\" \" * depth}pack 0x{pos:08x} | name = {name}')\n\n    if s.dwStreamPos_FirstEntry:\n\n      VFS_BuildEntryMetaData32(fp, s.dwStreamPos_FirstEntry, depth+1, path_, cb)\n\n    if s.dwStreamPos_FirstChildPack:\n\n      VFS_BuildPackMetaData32(fp, s.dwStreamPos_FirstChildPack, depth+1, path_, cb)\n\n    if not s.dwStreamPos_NextSiblingPack:\n\n      return\n\n    pos = s.dwStreamPos_NextSiblingPack\n\n\n#### Something interesting in the DataHive::Constructor is that the VFS start with a magic 0xE6F49DC4.\n\n## The hunt\n\n#### I decide to try to find new samples in the hope to collect some VFS so I wrote some Yara rules and run it on VT\n\n```\n\n-----\n\n```\nimport pe\n\nrule gracewire_rsrc_names\n\n{\n\n  condition:\n\n    pe.number_of_resources >= 1 and  \n\n    for any y in (0..pe.number_of_resources - 1): (\n\n      pe.resources[y].name_string == \"XC\\x00\\x00\\x00\")\n\n}\n\nrule gracewire_vfs_header\n\n{\n\n  strings:\n\n    $magic = { c4 9d f4 e6 03 00 00 00 }\n\n  condition:\n\n    $magic\n\n}\n\nrule gracewire_packer_01\n\n{\n\n  strings:\n\n    $name = \"c.dll\"\n\n    $ldrloaddll = { C6 44 ?? ?? 4C\n\n            C6 44 ?? ?? 64\n\n            C6 44 ?? ?? 72\n\n            C6 44 ?? ?? 4c\n\n            C6 44 ?? ?? 6f\n\n            C6 44 ?? ?? 61\n\n            C6 44 ?? ?? 64\n\n            C6 44 ?? ?? 44\n\n            C6 44 ?? ?? 6c\n\n            C6 44 ?? ?? 6c }\n\n  condition:\n\n    $name and $ldrloaddll\n\n}\n\n// content:\"f93j5RFRjhf2ASfy\" or content:\"er0ewjflk3qrhj81\" or content:\"c3oeCSIfx0J6UtcV\" or\ncontent:\"kwREgu73245Nwg7842h\" or content:{12 20 A5 16 76 E7 79 BD 87 7C BE CA C4 B9 B8 69 6D\n1A 93 F3 2B 74 3A 3E 67 90 E4 0D 74 56 93 DE 58 B1 DD 17 F6 59 88 BE FE 1D 6C 62 D5 41 6B 25\nBB 78 EF 06 22 B5 F8 21 4C 6B 34 E8 07 BA F9 AA }\n\nrule gracewire_keys\n\n{\n\n  strings:\n\n    $k1 = \"f93j5RFRjhf2ASfy\"\n\n    $k2 = \"er0ewjflk3qrhj81\"\n\n    $k3 = \"c3oeCSIfx0J6UtcV\"\n\n    $k4 = \"kwREgu73245Nwg7842h\"\n\n    $k5 =\n\"1220A51676E779BD877CBECAC4B9B8696D1A93F32B743A3E6790E40D745693DE58B1DD17F65988BEFE1D6C62D5416\nB25BB78EF0622B5F8214C6B34E807BAF9AA\"\n\n    $k6 = {12 20 A5 16 76 E7 79 BD 87 7C BE CA C4 B9 B8 69 6D 1A 93 F3 2B 74 3A 3E 67 90\nE4 0D 74 56 93 DE 58 B1 DD 17 F6 59 88 BE FE 1D 6C 62 D5 41 6B 25 BB 78 EF 06 22 B5 F8 21 4C\n6B 34 E8 07 BA F9 AA }\n\n  condition:\n\n```\n\n-----\n\n```\n    any of them\n\n}\n\n#### The gracewire_keys are keys that I’ve collected. They are most of the time used to decrypt the resources or VFS.\n\n I get some hits, and I still get some from time to time, but everything is mostly old. Some samples have a small VFS in the resource, but the IOC are known and old. If it’s in the resource after the decryption, we need to inflate it lznt1 before parsing the VFS (@todo verify).\n\n One hit was exciting because the rule was gracewire_vfs_header so an embed VFS without encryption.\ngracewire_vfs_header P2P/926b145b5bda585657326e0f08c9aebb1be698e4f617c08352da50532a989244\n\n It was a sample I had never encountered before, but with the style of the Grace’s developer.\n\n## A P2P botnet\n\n#### 926b145b5bda585657326e0f08c9aebb1be698e4f617c08352da50532a989244\n\n file size 548352 (535.5KiB)\n\n file magic PE32 executable (DLL) (GUI) Intel 80386, for MS Windows\n\n md5 029338d01927c127d703625a3cd3d46d\n\n sha1 61ea8be635f0e6b62e618fe4e4d23f3238847eb4\n\n sha256 926b145b5bda585657326e0f08c9aebb1be698e4f617c08352da50532a989244\n\n imphash 1ec7c4f47b9b2cc9fc83c06310bc0b21\n\n PE date 2021-05-24 12:27:57 GMT\n\n VT ratio detection ⁄5 67\n\n VT scan_date 2022-01-09 23:15:54\n\n VT link link\n\n I start looking around the internet and I found out this was not very new, NCC Group had already published some information on it.\n\n https://research.nccgroup.com/2021/12/01/tracking-a-p2p-network-related-with-ta505/\n\n The structures they provide help me to start writing a P2P client in Python, but at the end I was unable to finish it.\n\n```\n\n#### At the time of writing this post (2022 11⁄ ) everything seem offline, and I was unable to find new IOC on VT to try to bootstrap the network.\n\n\n-----\n\n## The node configuration\n\n#### The first configuration inside the sample is\n```\n$ python3 ../tools2/grace_vfs.py -f\n926b145b5bda585657326e0f08c9aebb1be698e4f617c08352da50532a989244.vfs.config\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /cx/nid 1CF094259E06664DA5504A5E1C551759\n\n4    <class 'int'>  /cx/dgx 0x4\n\n4    <class 'int'>  /cx/exe 0x2\n\n451   <class 'bytes'> /cx/key b'-----BEGIN PUBLI'\n\n4    <class 'int'>  /cx/port    0xce5d\n\n4    <class 'int'>  /va/45.129.137.237   0x84ac\n\n4    <class 'int'>  /va/78.128.112.139   0x84ac\n\n   /cx/nid is the network id\n   /cx/exe DLL/exe\n   /cx/key a RSA public key\n   /cx/port the port to listen to on UDP\n   /va the filename is the IP and the content of the entry the port to connect\n\n The second one is\n$ python3 ../tools2/grace_vfs.py -f\n926b145b5bda585657326e0f08c9aebb1be698e4f617c08352da50532a989244.vfs2.config\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n4    <class 'int'>  /meta/app    0x1\n\n4    <class 'int'>  /meta/mod    0x1\n\n4    <class 'int'>  /meta/bld    0x1\n\n4    <class 'int'>  /meta/api    0x1\n\n4    <class 'int'>  /meta/llr    0x1\n\n4    <class 'int'>  /meta/llt    0x1\n\n\n## Records\n\n#### I was able to recover some records from peers.\n\n This based on my vague souvenir.\n\n This record is an update command received from one of the peers:\n   /meta/pwd is the password to decrypt the record\n   /meta/seal is some kind of signature (RSA ?) to avoid hijacking the botnet\n   /meta/cfg is a another VFS inside\n   /hash is the information to ask for file block for the update, each block is 0x1000 bytes and a\n\n hash is provided.\n   /drop I don’t remember, maybe some kind of blacklist to remove bad node?\n\n```\n\n-----\n\n```\n$ python3 ../../tools2/grace_vfs.py f record_997378FCD959AA48893CB3BB84541841.bin\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /meta/net    1CF094259E06664DA5504A5E1C551759\n\n32   <class 'str'>  /meta/id    997378FCD959AA48893CB3BB84541841\n\n6    <class 'str'>  /meta/tag    update\n\n4    <class 'int'>  /meta/sta    0x1d7523c51f1de80\n\n4    <class 'int'>  /meta/load   0x1df35\n\n4    <class 'int'>  /meta/snc    0x1d7523c51e5f7a0\n\n4    <class 'int'>  /meta/utl    0x0\n\n12   <class 'str'>  /meta/uni    update.block\n\n32   <class 'str'>  /meta/pwd    D486BB2FAB71BB44821A327124CA9233\n\n256   <class 'bytes'> /meta/seal   b'\\x89oy\\xed\\xa24\\xfcL\\xe5uN\\xf2sM\\xe4\\xd2'\n\n125   <class 'bytes'> /meta/cfg   \nb'\\xc4\\x9d\\xf4\\xe6\\x03\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n4    <class 'int'>  /hash/dgst   0x4\n\n4    <class 'int'>  /hash/size   0x20\n\n4    <class 'int'>  /hash/0/ofs   0x0\n\n4    <class 'int'>  /hash/0/size  0x1000\n\n32   <class 'bytes'> /hash/0/hash  \nb'\\x82\\x8e\\xa2\\xa6w\\xbf\\x80g\\x1c\\x0b\\x99W\\xc3)\\x99\\xa5'\n\n4    <class 'int'>  /hash/1/ofs   0x1000\n\n4    <class 'int'>  /hash/1/size  0x1000\n\n32   <class 'bytes'> /hash/1/hash  b'=\\x82\"2\\xd7^\\xbb\\x8d:[\\xeb\\xef\\xf9\\x1c\\xbb\\xc0'\n\n4    <class 'int'>  /hash/2/ofs   0x2000\n\n4    <class 'int'>  /hash/2/size  0x1000\n\n32   <class 'bytes'> /hash/2/hash  b't\\xfc\\x82\\xfb\\xe4M}\\xe1\\x14\\xb1\\xe6r\\x0f\\xf0G\\xbe'\n\n4    <class 'int'>  /hash/3/ofs   0x3000\n\n4    <class 'int'>  /hash/3/size  0x1000\n\n32   <class 'bytes'> /hash/3/hash  b'NU\\xf2\\x00\\x9ea1\\x8dvi\\xcc\\x82\\xb38\\x8e\\xc0'\n\n4    <class 'int'>  /hash/4/ofs   0x4000\n\n4    <class 'int'>  /hash/4/size  0x1000\n\n32   <class 'bytes'> /hash/4/hash  b'#j\\x9c\\xe7\\xac\\xea\\xc7\\x8a\\n\\xf0\\xf7\\x98\\x95<\\x01Q'\n\n4    <class 'int'>  /hash/5/ofs   0x5000\n\n4    <class 'int'>  /hash/5/size  0x1000\n\n32   <class 'bytes'> /hash/5/hash  b'\\xb9\\x97\\xa1jK<\\xa8in)R\\xd2\\x87\\x8cLR'\n4    <class 'int'>  /hash/6/ofs   0x6000\n\n4    <class 'int'>  /hash/6/size  0x1000\n\n32   <class 'bytes'> /hash/6/hash  b'\\xd6Eil\\xa7\\xb4\\x8c\\x0e\\xb4\\x97\\x91\\xdb\\x8eC\\x155'\n\n4    <class 'int'>  /hash/7/ofs   0x7000\n\n4    <class 'int'>  /hash/7/size  0x1000\n\n32   <class 'bytes'> /hash/7/hash  b'\\xea\\x06\\xb0WF\\x06\\xfeUh\\xe5&o\\xf5\\xab\\tH'\n\n4    <class 'int'>  /hash/8/ofs   0x8000\n\n4    <class 'int'>  /hash/8/size  0x1000\n\n32   <class 'bytes'> /hash/8/hash  b'\\xe1*\\x06\\xd6-\\xad\\xe5\\x9b\\xcb?\n\\x96\\x11\\xf6\\x88\\x86\\x8e'\n\n4    <class 'int'>  /hash/9/ofs   0x9000\n\n4    <class 'int'>  /hash/9/size  0x1000\n\n32   <class 'bytes'> /hash/9/hash  b'J\\x96[\\x05\\xafs2Q\\xed&\\xb7$\\xf8\\nL\\x12'\n\n4    <class 'int'>  /hash/A/ofs   0xa000\n\n4    <class 'int'>  /hash/A/size  0x1000\n\n32   <class 'bytes'> /hash/A/hash  \nb'\\xd9\\x9c\\xa4L\\xbe\\xe3\\xe9\\x87\\x8a\\xd2\\x99J\\xe6P4\\x9a'\n\n4    <class 'int'>  /hash/B/ofs   0xb000\n\n4    <class 'int'>  /hash/B/size  0x1000\n\n32   <class 'bytes'> /hash/B/hash  b'||\\xfb<\\x10Y\\xceV\\xe3C\\x97\\xa2\\xc0E\\xae\\x16'\n\n4    <class 'int'>  /hash/C/ofs   0xc000\n\n```\n\n-----\n\n```\n4    class int  /hash/C/size  0x1000\n\n32   <class 'bytes'> /hash/C/hash  b')7\\xcdN\\xfe\\xc2\\x80\\xc32\\xf5Tu`\\x83\\xc5\\xd3'\n\n4    <class 'int'>  /hash/D/ofs   0xd000\n\n4    <class 'int'>  /hash/D/size  0x1000\n\n32   <class 'bytes'> /hash/D/hash  \nb'\\xa5\\xdc\\xf1D\\x86\\x9f\\x80\\x9c\\x7f\\xb7D\\xcd\\x19\\xea\\xd1Q'\n\n4    <class 'int'>  /hash/E/ofs   0xe000\n\n4    <class 'int'>  /hash/E/size  0x1000\n\n32   <class 'bytes'> /hash/E/hash  b'\\xcf\\xea,-)\\xf8!`8*\\xd7\\xabEW&v'\n\n4    <class 'int'>  /hash/F/ofs   0xf000\n\n4    <class 'int'>  /hash/F/size  0x1000\n\n32   <class 'bytes'> /hash/F/hash  b'\\x83\\\\1WI\\x86\\x1aq\\x88~\\xdd\\xdf\\xc5+\\x9b3'\n\n4    <class 'int'>  /hash/10/ofs  0x10000\n\n4    <class 'int'>  /hash/10/size  0x1000\n\n32   <class 'bytes'> /hash/10/hash \nb'\\xd2\\xe1\\xac/\\x83\\xe5\\xf9\\xe2\\xd3\\xde\\x119\\xe1\\xe4\\xb44'\n\n4    <class 'int'>  /hash/11/ofs  0x11000\n\n4    <class 'int'>  /hash/11/size  0x1000\n\n32   <class 'bytes'> /hash/11/hash \nb'\\xf6\\xb7\\xed\\x8a\\xda\\x80\\xed\\x06\\x8e\\xa9\\xc9\\x9c<\\x15m\\xd7'\n\n4    <class 'int'>  /hash/12/ofs  0x12000\n\n4    <class 'int'>  /hash/12/size  0x1000\n\n32   <class 'bytes'> /hash/12/hash \nb'\\x03\\x11\\xff\\xf8\\xeb\\xd5\\xba2O\\xcdi\\x90\\xf5^\\xcc\\x8a'\n\n4    <class 'int'>  /hash/13/ofs  0x13000\n\n4    <class 'int'>  /hash/13/size  0x1000\n\n32   <class 'bytes'> /hash/13/hash \nb'<\\xddY\\x13\\xedI\\x11\\xa0\\xd1\\xaa\\xc5\\xd9\\xe2I\\xc4\\xe9'\n\n4    <class 'int'>  /hash/14/ofs  0x14000\n\n4    <class 'int'>  /hash/14/size  0x1000\n\n32   <class 'bytes'> /hash/14/hash  b'\\xad%~e\\xccU\\xbc\\x97\\xf5\\xe7#\\xe7[\\x1b\\xd36'\n\n4    <class 'int'>  /hash/15/ofs  0x15000\n\n4    <class 'int'>  /hash/15/size  0x1000\n\n32   <class 'bytes'> /hash/15/hash  b'\\xee\\xe2\\xf72\\xc5\\x8aJ\\x0ciOS\\xf8[\\xfc\\xbb8'\n\n4    <class 'int'>  /hash/16/ofs  0x16000\n\n4    <class 'int'>  /hash/16/size  0x1000\n\n32   <class 'bytes'> /hash/16/hash \nb'1\\x90\\xcbu\\xdf7\\xbb\\xd6\\n\\xd8\\xf8\\x18\\xb6\\xf2\\x18\\xe0'\n\n4    <class 'int'>  /hash/17/ofs  0x17000\n\n4    <class 'int'>  /hash/17/size  0x1000\n\n32   <class 'bytes'> /hash/17/hash  b'\\xda\\xbc\\xecZ\\x93j\\xda\\x8ay\\x14\\xd5_\\xc4\\xa7\\xa5\"'\n\n4    <class 'int'>  /hash/18/ofs  0x18000\n\n4    <class 'int'>  /hash/18/size  0x1000\n\n32   <class 'bytes'> /hash/18/hash  b'\\x8f\\xdd\\xf9d\\xc0\\x1fq0_\\xe7\\xb1\\xf9.\\xec\\xef\\x18'\n\n4    <class 'int'>  /hash/19/ofs  0x19000\n\n4    <class 'int'>  /hash/19/size  0x1000\n\n32   <class 'bytes'> /hash/19/hash  b'\\xed/#\\x85\\xf4\\xf1\\xfe)\\xdah\\xe4Sw\\xad\\xf9\\xc2'\n\n4    <class 'int'>  /hash/1A/ofs  0x1a000\n\n4    <class 'int'>  /hash/1A/size  0x1000\n\n32   <class 'bytes'> /hash/1A/hash  b'\\x882`x*\\xf3\\xf8\\\\\\x80\\x05m=>4\\xac\\xab'\n\n4    <class 'int'>  /hash/1B/ofs  0x1b000\n\n4    <class 'int'>  /hash/1B/size  0x1000\n\n32   <class 'bytes'> /hash/1B/hash  b'\\xc2\\xd36,\\xeb\\xeaN\\xc4BD\\xac\\xd9\\xf2k\\xe1\\x92'\n\n4    <class 'int'>  /hash/1C/ofs  0x1c000\n\n4    <class 'int'>  /hash/1C/size  0x1000\n\n32   <class 'bytes'> /hash/1C/hash  b'\\xf6<\\xf5O\\xd0\\xa9\\x1ez}f_B\\x12\\xc7g\\x1c'\n\n4    <class 'int'>  /hash/1D/ofs  0x1d000\n\n```\n\n-----\n\n```\n4    class int  /hash/1D/size  0xf35\n\n32   <class 'bytes'> /hash/1D/hash  b'm\\x96\\xcfC\\xd0Z88Ar\\xd3\\xce\\xa8\\x03\\xe8\\xbd'\n\n13   <class 'str'>  /drop/0/host  194.165.16.94\n\n4    <class 'int'>  /drop/0/port  0x8ad5\n\n#### From /meta/cfg\n32   <class 'str'>  /fp   B88763DF8318F4962F0EFD398234DF96\n\n4    <class 'int'>  /rs   0x1\n\n4    <class 'int'>  /md   0x0\n\n\n## Packet handler\n\n#### I rewrite kind of pkt_handler in python\n\n```\n\n-----\n\n```\n  def pkt_handler(self, addr, pkt, pkt_data, data):\n\n    if pkt.bFrameId == 0x10:\n\n      logging.info(f'[#] echo recv')\n\n    elif pkt.bFrameId == 0x7:\n\n      logging.info(f'[#] fit one packet')\n\n      hdr = NodePktDataHeader()\n\n      hdr.unpack(data)\n\n      logging.info(f'{hdr}')\n\n      if hdr.bCmdId == 0x1:\n\n        logging.info(f' [#] invitation packet')\n\n        inv = NodePktInvitation()\n\n        inv.unpack(data)\n\n        logging.info(f' {inv}')\n\n      elif hdr.bCmdId == 0x2:\n\n        logging.info(f' [#] add node to probes')\n\n        inv = NodePktInvitation()\n\n        inv.unpack(data)\n\n        logging.info(f' {inv}')\n\n      elif hdr.bCmdId == 0x03:\n\n        logging.info(f' [#] Get a ping request')\n\n        node_info = unserialized(data[hdr.size:])\n\n        logging.info(f' node_info: {node_info} | {node_info[1]}/{node_info[0]}\nconnections | {node_info[2]} records')\n\n        # @todo implement response\n\n      elif hdr.bCmdId == 0x4:\n\n        logging.info(f' [#] node info')\n\n        node_info = unserialized(data[hdr.size:])\n\n        logging.info(f' node_info: {node_info} | {node_info[1]}/{node_info[0]}\nconnections | {node_info[2]} records')\n\n      elif hdr.bCmdId == 0x05:\n\n        logging.info(f' [#] Get a new node')\n\n        fp = io.BytesIO(data[hdr.size:])\n\n        node_id = fp.read(0x10)\n\n        node_port = struct.unpack('<H', fp.read(2))[0]\n\n        node_ip = fp.read(ord(fp.read(1))).decode()\n\n        logging.info(f' node_id: {node_id.hex()} node: {node_ip}:{node_port:d}')\n\n        n = { 'addr': [node_ip, node_port], 'node_id': node_id.hex()}\n\n        is_exist = False\n\n        for v in self.store['nodes']:\n\n          if v['node_id'] == node_id.hex():\n\n            is_exist = True\n\n            break\n\n        if not is_exist:\n\n          logging.info(f' adding node to store')\n\n          self.store['nodes'].append(n)\n\n          self.send_invitation(n['addr'])\n\n\n      elif hdr.bCmdId == 0x06:\n\n        logging.info(f' [#] Get a record metadata')\n\n        record_id = data[hdr.size:hdr.size+0x10]\n\n        record_info = unserialized(data[hdr.size+0x10:])\n\n        logging.info(f' record_id: {record_id.hex()} record_info: {record_info}')\n\n      elif hdr.bCmdId == 0xa:\n\n        logging.info(f' [#] Get a record')\n\n```\n\n-----\n\n```\n        r NodePktRecord()\n\n        r.unpack(data)\n\n        logging.info(f' {r}')\n\n      else:\n\n        logging.info(f' [#] unsupported hdr.bCmdId 0x{hdr.bCmdId:x}')\n\n    elif pkt.bFrameId == 0xd:\n\n      open(f'record_{pkt_data.dwUnk}_{pkt_data.dwCurId}_{pkt_data.dwTotal}.bin',\n'wb').write(data)\n\n      pass\n\n    else:\n\n      logging.info(f'[#] unsupported pkt.bFrameId 0x{pkt.bFrameId:x}')\n\n## File store on the filesystem\n\n#### On execution, the malware use the file system to store information about the P2P network state. Most of the file follow the VFS structure. In fs_files_from_sandbox.zip\n├── net.dsx\n\n├── node\n\n│  ├── 997378FCD959AA48893CB3BB84541841\n\n│  │  ├── l\n\n│  │  ├── m\n\n│  │  └── p\n\n│  └── BBBD9035B2A3CE4FB2A563F5FC6572DF\n\n│    ├── l\n\n│    ├── m\n\n│    └── p\n\n├── probes.dsx\n\n├── reports.dsx\n\n├── sessions\n\n│  └── 40DFE0CD66457646B3990B9B2160F622\n\n├── trash\n\n├── units\n\n│  ├── block\n\n│  │  └── block.dll\n\n│  └── exec\n\n│    ├── exec.dll\n\n├── units.dsx\n\n└── updates\n\n   net.dsx contain the node id\n   node contains record received from node, the sub key is the record id\n      l unknown\n      m contains the record meta data\n      p is the record data\n      session the files inside are VFS, but I don’t remember\n      probe.dsx contains other node information\n      units contains the unit it’s the payload recover from the record download from node in p\n\n```\n\n-----\n\n```\n$ python3 ../../tools2/grace_vfs.py f net.dsx\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /gx/id 67E3945FF45AC644982765568986F30A\n\n$ python3 ../../tools2/grace_vfs.py -f units.dsx\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /blo/rec    997378FCD959AA48893CB3BB84541841\n\n100   <class 'str'>  /blo/exec    C:\\Users\\John\\Desktop\\target\\units\\block\\block.dll\n\n4    <class 'int'>  /blo/meta/app  0x1\n\n4    <class 'int'>  /blo/meta/mod  0x2\n\n10   <class 'str'>  /blo/meta/name block\n\n4    <class 'int'>  /blo/meta/bld  0x1\n\n4    <class 'int'>  /blo/meta/hlt  0x1\n\n4    <class 'int'>  /blo/meta/api  0x1\n\n32   <class 'str'>  /ex/rec BBBD9035B2A3CE4FB2A563F5FC6572DF\n\n96   <class 'str'>  /ex/exec    C:\\Users\\John\\Desktop\\target\\units\\exec\\exec.dll\n\n4    <class 'int'>  /ex/meta/app  0x1\n\n4    <class 'int'>  /ex/meta/mod  0x2\n\n8    <class 'str'>  /ex/meta/name  exec\n\n4    <class 'int'>  /ex/meta/bld  0x1\n\n4    <class 'int'>  /ex/meta/hlt  0x1\n\n4    <class 'int'>  /ex/meta/api  0x1\n\n$ python3 ../../tools2/grace_vfs.py -f probes.dsx\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n4    <class 'int'>  /78.128.112.139/33964/curr   0x2\n\n4    <class 'int'>  /78.128.112.139/33964/max    0x5\n\n4    <class 'int'>  /78.128.112.139/33964/next   0x1d8228c5da8f7b0\n\n$ python3 ../../tools2/grace_vfs.py -f reports.dsx\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /0536FC541A7AC84DA4D94C46541B475A/rec \n997378FCD959AA48893CB3BB84541841\n\n13   <class 'str'>  /0536FC541A7AC84DA4D94C46541B475A/ah  194.165.16.94\n\n4    <class 'int'>  /0536FC541A7AC84DA4D94C46541B475A/ap  0x8ad5\n\n4    <class 'int'>  /0536FC541A7AC84DA4D94C46541B475A/ec  0x0\n\n4    <class 'int'>  /0536FC541A7AC84DA4D94C46541B475A/atm  0x3e8\n\n4    <class 'int'>  /0536FC541A7AC84DA4D94C46541B475A/last 0x0\n\n4    <class 'int'>  /0536FC541A7AC84DA4D94C46541B475A/es  0x1d8228c1b9030f0\n\n$ python3 ../../tools2/grace_vfs.py -f sessions/40DFE0CD66457646B3990B9B2160F622\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n4    <class 'int'>  /g/c  0x1d8228bf4c4b400\n\n4    <class 'int'>  /g/l  0x1d8228c4b60f1c0\n\n16   <class 'bytes'> /a/x  b'\\x02\\x00\\x84\\xac\\x81\\x89\\xed\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n\n$ python3 ../../tools2/grace_vfs.py -f node/997378FCD959AA48893CB3BB84541841/m\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /meta/net    1CF094259E06664DA5504A5E1C551759\n\n```\n\n-----\n\n```\n32   class str  /meta/id    997378FCD959AA48893CB3BB84541841\n\n6    <class 'str'>  /meta/tag    update\n\n4    <class 'int'>  /meta/sta    0x1d7523c51f1de80\n\n4    <class 'int'>  /meta/load   0x1df35\n\n4    <class 'int'>  /meta/snc    0x1d7523c51e5f7a0\n\n4    <class 'int'>  /meta/utl    0x0\n\n12   <class 'str'>  /meta/uni    update.block\n\n32   <class 'str'>  /meta/pwd    D486BB2FAB71BB44821A327124CA9233\n\n256   <class 'bytes'> /meta/seal   b'\\x89oy\\xed\\xa24\\xfcL\\xe5uN\\xf2sM\\xe4\\xd2'\n\n125   <class 'bytes'> /meta/cfg   \nb'\\xc4\\x9d\\xf4\\xe6\\x03\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n4    <class 'int'>  /hash/dgst   0x4\n\n4    <class 'int'>  /hash/size   0x20\n\n4    <class 'int'>  /hash/0/ofs   0x0\n\n4    <class 'int'>  /hash/0/size  0x1000\n\n32   <class 'bytes'> /hash/0/hash  \nb'\\x82\\x8e\\xa2\\xa6w\\xbf\\x80g\\x1c\\x0b\\x99W\\xc3)\\x99\\xa5'\n\n4    <class 'int'>  /hash/1/ofs   0x1000\n\n4    <class 'int'>  /hash/1/size  0x1000\n\n...\n\n$ python3 ../../tools2/grace_vfs.py -f node/BBBD9035B2A3CE4FB2A563F5FC6572DF/m\n\nVFS_ByteStreamHeaderPattern(magic=0xe6f49dc4, fixed4=0x3, m64BitFlag=0x0, dummy0=0x0,\ndwHeaderLen=0x18, zero=0x0)\n\n32   <class 'str'>  /meta/net    1CF094259E06664DA5504A5E1C551759\n\n32   <class 'str'>  /meta/id    BBBD9035B2A3CE4FB2A563F5FC6572DF\n\n6    <class 'str'>  /meta/tag    update\n\n4    <class 'int'>  /meta/sta    0x1d7523c51fb7b70\n\n4    <class 'int'>  /meta/load   0x20d2f\n\n4    <class 'int'>  /meta/snc    0x1d7523c51f6c080\n\n4    <class 'int'>  /meta/utl    0x0\n\n11   <class 'str'>  /meta/uni    update.exec\n\n32   <class 'str'>  /meta/pwd    2ECDEA5A357B5D4F968AD1EBF2B86B39\n\n256   <class 'bytes'> /meta/seal   b'!\\xb2N\\xc7*\\xcf\\xb3D/\\xea[\\xfc\\x0e\\xa5N\\xca'\n\n125   <class 'bytes'> /meta/cfg   \nb'\\xc4\\x9d\\xf4\\xe6\\x03\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n4    <class 'int'>  /hash/dgst   0x4\n\n4    <class 'int'>  /hash/size   0x20\n\n4    <class 'int'>  /hash/0/ofs   0x0\n\n4    <class 'int'>  /hash/0/size  0x2000\n\n32   <class 'bytes'> /hash/0/hash  \nb'<\\xf5\\xf3\\xe2\\x91\\xd3\\x07\\x05\\xdb8\\xde_\\xb3\\x12E\\xe2'\n\n4    <class 'int'>  /hash/1/ofs   0x2000\n\n4    <class 'int'>  /hash/1/size  0x2000\n\n...\n\n\n#### Go to top\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-11-11 - GraceWire - FlawedGrace malware adventure.pdf"
    ],
    "report_names": [
        "2022-11-11 - GraceWire - FlawedGrace malware adventure.pdf"
    ],
    "threat_actors": [
        {
            "id": "99cb4e5b-8071-4f9e-aa1d-45bfbb6197e3",
            "created_at": "2023-01-06T13:46:38.860754Z",
            "updated_at": "2025-03-27T02:00:02.937438Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "SectorJ04 Group",
                "Dudear",
                "G0092",
                "ATK103",
                "Hive0065",
                "Spandex Tempest",
                "GRACEFUL SPIDER",
                "GOLD TAHOE",
                "CHIMBORAZO",
                "SectorJ04"
            ],
            "source_name": "MISPGALAXY:TA505",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5e6b31a6-80e3-4e7d-8b0a-d94897ce9b59",
            "created_at": "2024-06-19T02:03:08.128175Z",
            "updated_at": "2025-03-27T02:05:17.400394Z",
            "deleted_at": null,
            "main_name": "GOLD TAHOE",
            "aliases": [
                "SectorJ04 ",
                "Spandex Tempest ",
                "TA505 ",
                "FIN11 "
            ],
            "source_name": "Secureworks:GOLD TAHOE",
            "tools": [
                " Cobalt Strike",
                " FlawedAmmy",
                " Get2",
                " GraceWire",
                " Malichus",
                " SDBbot",
                " ServHelper",
                " TrueBot",
                "Clop"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75d4d6a9-b5d1-4087-a7a0-e4a9587c45f4",
            "created_at": "2022-10-25T15:50:23.5188Z",
            "updated_at": "2025-03-27T02:00:55.489882Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "TA505",
                "Hive0065",
                "Spandex Tempest",
                "CHIMBORAZO"
            ],
            "source_name": "MITRE:TA505",
            "tools": [
                "AdFind",
                "Azorult",
                "FlawedAmmyy",
                "Mimikatz",
                "Dridex",
                "TrickBot",
                "Get2",
                "FlawedGrace",
                "Cobalt Strike",
                "ServHelper",
                "Amadey",
                "SDBbot",
                "PowerSploit"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e447d393-c259-46e2-9932-19be2ba67149",
            "created_at": "2022-10-25T16:07:24.28282Z",
            "updated_at": "2025-03-27T02:02:10.159466Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "ATK 103",
                "Chimborazo",
                "Gold Evergreen",
                "Gold Tahoe",
                "Graceful Spider",
                "Hive0065",
                "Operation Tovar",
                "Operation Trident Breach",
                "SectorJ04",
                "Spandex Tempest",
                "TA505",
                "TEMP.Warlock"
            ],
            "source_name": "ETDA:TA505",
            "tools": [
                "Amadey",
                "AmmyyRAT",
                "AndroMut",
                "Azer",
                "Bart",
                "Bugat v5",
                "CryptFile2",
                "CryptoLocker",
                "CryptoMix",
                "CryptoShield",
                "Dridex",
                "Dudear",
                "EmailStealer",
                "FRIENDSPEAK",
                "Fake Globe",
                "Fareit",
                "FlawedAmmyy",
                "FlawedGrace",
                "FlowerPippi",
                "GOZ",
                "GameOver Zeus",
                "GazGolder",
                "Gelup",
                "Get2",
                "GetandGo",
                "GlobeImposter",
                "Gorhax",
                "GraceWire",
                "Gussdoor",
                "Jaff",
                "Kasidet",
                "Kegotip",
                "Kneber",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Locky",
                "MINEBRIDGE",
                "MINEBRIDGE RAT",
                "MirrorBlast",
                "Neutrino Bot",
                "Neutrino Exploit Kit",
                "P2P Zeus",
                "Peer-to-Peer Zeus",
                "Philadelphia",
                "Philadephia Ransom",
                "Pony Loader",
                "Rakhni",
                "ReflectiveGnome",
                "Remote Manipulator System",
                "RockLoader",
                "RuRAT",
                "SDBbot",
                "ServHelper",
                "Shifu",
                "Siplog",
                "TeslaGun",
                "TiniMet",
                "TinyMet",
                "Trojan.Zbot",
                "Wsnpoem",
                "Zbot",
                "Zeta",
                "ZeuS",
                "Zeus"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1685930765,
    "ts_updated_at": 1743041738,
    "ts_creation_date": 1685882716,
    "ts_modification_date": 1685882716,
    "files": {
        "pdf": "https://archive.orkl.eu/74fd83cf2a3b4e35ebb4e28310507f66d827ff78.pdf",
        "text": "https://archive.orkl.eu/74fd83cf2a3b4e35ebb4e28310507f66d827ff78.txt",
        "img": "https://archive.orkl.eu/74fd83cf2a3b4e35ebb4e28310507f66d827ff78.jpg"
    }
}