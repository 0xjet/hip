{
    "id": "ad42b2b8-1d40-4631-b9c7-f4a9b0f4a907",
    "created_at": "2023-01-12T14:59:09.081989Z",
    "updated_at": "2025-03-27T02:05:36.291284Z",
    "deleted_at": null,
    "sha1_hash": "52de95988f1f6d606d32d4e77e9ee5f4df795a6f",
    "title": "2022-04-25 - Defeating BazarLoader Anti-Analysis Techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T15:14:10Z",
    "file_modification_date": "2022-05-28T15:14:10Z",
    "file_size": 948914,
    "plain_text": "# Defeating BazarLoader Anti-Analysis Techniques\n\n**[unit42.paloaltonetworks.com/bazarloader-anti-analysis-techniques/](https://unit42.paloaltonetworks.com/bazarloader-anti-analysis-techniques/)**\n\nMark Lim April 25, 2022\n\nBy [Mark Lim](https://unit42.paloaltonetworks.com/author/mark-lim/)\n\nApril 25, 2022 at 6:00 AM\n\n[Category: Malware](https://unit42.paloaltonetworks.com/category/malware-2/)\n\nTags: [anti-analysis,](https://unit42.paloaltonetworks.com/tag/anti-analysis/) [BazarLoader](https://unit42.paloaltonetworks.com/tag/bazarloader/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/bazarloader-anti-analysis-techniques/)\n\n## Executive Summary\n\nMalware authors embed multiple anti-analysis techniques in their code to retard the analysis\nprocesses of human analysts and sandboxes. However, there are ways defenders can\ndefeat these techniques in turn. This blog post describes two methods for faster analysis of\nmalware that employs two distinctive anti-analysis techniques. The first technique is API\nfunction hashing, a known trick to obfuscate which functions are called. The second is\nopaque predicate, a technique used for control flow obfuscation.\n\nThe scripts that we are going to show here can be applied to BazarLoader, as well as other\nmalware families that utilize similar anti-analysis techniques. As an illustration, we will show\nthe [IDAPython scripts we created during a recent analysis of BazarLoader with the reverse](https://github.com/idapython)\n\n\n-----\n\nengineering tool IDA Pro to defeat these anti-analysis techniques. BazarLoader is a\n[Windows backdoor that is used by various ransomware groups.](https://malpedia.caad.fkie.fraunhofer.de/details/win.bazarbackdoor)\n\nPalo Alto Networks customers are protected from malware families using similar anti[analysis techniques with Cortex XDR or the Next-Generation Firewall with the WildFire and](https://www.paloaltonetworks.com/cortex/cortex-xdr)\n[Threat Prevention security subscriptions.](http://paloaltonetworks.com/products/secure-the-network/subscriptions/threat-prevention)\n\nPrimary Malware Discussed [BazarLoader](https://unit42.paloaltonetworks.com/tag/bazarloader/)\n\nRelated Unit 42 Topics [Malware,](https://unit42.paloaltonetworks.com/category/malware-2/) [anti-analysis techniques](https://unit42.paloaltonetworks.com/tag/anti-analysis/)\n\n## Table of Contents\n\nReusing Malware Code to Defeat Obfuscated API Calls\n\nAutomating Opaque Predicate Removal\n\nMalware Analysts vs Malware Authors\n\nIndicators of Compromise\n\nAdditional Resources\n\n## Reusing Malware Code to Defeat Obfuscated API Calls\n\nMalware compiled as native files has to call Windows API functions to carry out malicious\nbehaviors. The information on which functions are used is usually stored in the Import\nAddress Table (IAT) in the file. Therefore, this table is often a good place to start the analysis\nprocess to get an idea of what the malware is trying to do.\n\nTo demonstrate, we focused on a BazarLoader sample we recently detected. After peeling\naway the packer layer of our BazarLoader sample, we saw that it doesn’t have an IAT (see\nFigure 1). Also, there is no IAT constructed during execution, a technique sometimes seen in\nother malware. BazarLoader obfuscates its function calls to make analysis more difficult and\nto evade detection techniques that rely on reading the IAT.\n\n\n-----\n\nFigure 1. Missing IAT in BazarLoader as seen with CFF Explorer.\nIn fact, BazarLoader resolves every API function to be called individually at run time. After\nwe figured out that the functions are resolved during execution, the following function caught\nour attention as it was referenced more than 300 times:\n\nFigure 2. Function for resolving the obfuscated Windows API functions (marked in yellow).\nWhile most pieces of malware rely on publicly known hashing algorithms to resolve the\nfunctions’ addresses, the one used by BazarLoader is unique. The API function resolution\nprocedure (sub_18000B9B0, labelled as FN_API_Decoder) requires three parameters and\nreturns the address of the requested function.\n\n\n-----\n\nNow, we could reverse engineer the algorithm used in FN_API_Decoder and reimplement it\nin Python to get all functions resolved. However, this would take a lot of time and we would\nhave to repeat the whole process for every piece of malware that uses a different hashing\nalgorithm.\n\nInstead, the approach we used is independent from the hashing algorithm as it makes use of\n[the hashing function itself. For this, we used the Appcall feature with IDAPython in IDA Pro to](https://hex-rays.com/blog/introducing-the-appcall-feature-in-ida-pro-5-6/)\ncall FN_API_Decoder and pass it the required parameters. The result from Appcall would be\nthe resolved address of the Windows API function. The Appcall feature used while\ndebugging the malware allows us to execute any function from the sample as if it were a\nbuilt-in function.\n\nUsing the following code, we can run FN_API_Decoder to resolve Windows API function\naddresses while debugging the malware process.\n\nFigure 3. Using Appcall with IDAPython.\nNext, we gathered all the required parameters by looking up all the cross references to\nFN_API_Decoder. The following code will search and extract the required parameters for\nresolving the API function calls.\n\n\n-----\n\nFigure 4. IDAPython code to search and extract the three parameters.\nFinally, by using the returned value from Appcall we are able to rename all the dynamic calls\nto the APIs to their corresponding names and apply comments:\n\n\n-----\n\nFigure 5. IDAPython code to locate dynamic calls.\nPutting the above steps together, we deobfuscated the API function calls:\n\nFigure 6. Before executing the above IDAPython scripts.\n\nFigure 7. Renamed API function call with added comment.\nAfter all the API function calls are renamed, we can now easily locate other interesting\nfunctions in the malware. For example, sub_1800155E0 is the procedure in BazarLoader\nthat carries out code injection.\n\n\n-----\n\nFigure 8. Before renaming API calls.\n\n\n-----\n\nFigure 9. Obfuscated API calls labeled with APIs related to code injection.\nWith the help of our IDAPython scripts, we are now able to faster assess which functionality\nthis BazarLoader sample contains.\n\n## Automating Opaque Predicate Removal\n\nOpaque Predicate (OP) is used in BazarLoader to protect it from reverse engineering tools.\nOP is an expression that evaluates to either true or false at runtime. Malware authors make\nuse of multiple OPs together with unexecuted code blocks to add complexities that static\nanalysis tools have to deal with.\n\nThe following disassembled code shows one of the OPs in Bazarloader:\n\n\n-----\n\nFigure 10. One example of OP in BazarLoader.\nFrom the above control flow graph (CFG), the code flow won’t end up in infinite loops (Figure\n10, red code blocks). Therefore, the above OP will be evaluated to avoid the infinite loop.\n\nWe can demonstrate the extent of the challenge OPs pose to malware analysts. The\nfollowing CFG shows the unexecuted code blocks (Figure 11, red code blocks) in one of the\nsmaller functions (sub_18000F640) in the sample.\n\n\n-----\n\nFigure 11. sub_18000F640 function in BazarLoader with unexecuted code blocks colored in\nred.\nWe could manually patch away the code blocks that are not executed as we analyze each\nfunction in the sample, but this is not very practical and takes a lot of time. Instead, we will\nchoose a smarter way by doing it automatically.\n\n\n-----\n\nFirst, we have to locate all the OPs. The most common way to do this is to make use of the\nbinary search mechanism in IDA Pro to find all the byte sequences of the OPs. This turns out\nnot to be possible, as the OPs were likely generated by a compiler during the build process\nof the malware sample. There are just too many variants of the OPs that could be covered\nusing the byte sequence.\n\nNot only do we need to locate the OPs, we also have to know the exact point when the\nmalware sample decides to avoid the unexecuted code blocks.\n\nUsing the following code, we locate the OPs in a function:\n\nFigure 12. IDAPython code to locate the OPs in a function.\nNext, we have to patch the instructions in OPs to force the code flow away from the\nunexecuted code blocks.\n\nUsing the following code, we patch the OPs in a function:\n\n\n-----\n\nFigure 13. IDAPython code to patch the OPs.\nThe OPs also messed with the output of the HexRays decompiler. This is how the function\n(sub_18000F640) looks before the OPs are patched:\n\n\n-----\n\nFigure 14. Decompiled sub_18000F640 function.\nAfter applying the two techniques above, we have decompiled pseudocode that is much\neasier to read and understand.\n\nAfter patching all the OPs and renaming the obfuscated API calls, we could then tell that the\nfunction (sub_18000F640) is just a wrapper function for GetModuleFileNameW().\n\nFigure 15. Decompiled sub_18000F640 function after removing the OPs.\n\n## Malware Analysts vs Malware Authors\n\n\n-----\n\nMalware authors often include anti-analysis techniques with the hope that they will increase\nthe time and resources taken for malware analysts. With the above script snippets showing\nhow to defeat these techniques for BazarLoader, you can reduce the time needed to analyze\nmalware samples of other families that use similar techniques.\n\nPalo Alto Networks customers are further protected from malware families using similar antianalysis techniques with Cortex XDR or the Next-Generation Firewall with the WildFire and\nThreat Prevention cloud-delivered security subscriptions.\n\n## Indicators of Compromise\n\nBazarLoader Sample\nce5ee2fd8aa4acda24baf6221b5de66220172da0eb312705936adc5b164cc052\n\n## Additional Resources\n\n[Complete IDAPython script to rename or resolve obfuscation API calls is available on](https://github.com/pan-unit42/iocs/blob/master/Appcall_rename_api)\nGitHub.\n\n[Complete IDAPython script to search and patch Opaque Predicates in a function is available](https://github.com/pan-unit42/iocs/blob/master/DeObfuscate_Opaque)\non GitHub.\n\n**Get updates from**\n**Palo Alto**\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-25 - Defeating BazarLoader Anti-Analysis Techniques.pdf"
    ],
    "report_names": [
        "2022-04-25 - Defeating BazarLoader Anti-Analysis Techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535549,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653750850,
    "ts_modification_date": 1653750850,
    "files": {
        "pdf": "https://archive.orkl.eu/52de95988f1f6d606d32d4e77e9ee5f4df795a6f.pdf",
        "text": "https://archive.orkl.eu/52de95988f1f6d606d32d4e77e9ee5f4df795a6f.txt",
        "img": "https://archive.orkl.eu/52de95988f1f6d606d32d4e77e9ee5f4df795a6f.jpg"
    }
}