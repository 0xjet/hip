{
    "id": "267dd649-975f-4085-b136-79077e560a7b",
    "created_at": "2024-01-05T02:08:15.48503Z",
    "updated_at": "2025-03-27T02:09:55.040427Z",
    "deleted_at": null,
    "sha1_hash": "e22b4351d5cdae2ce8ec011d65b1b2753fa32b65",
    "title": "China Panda attacks supply chain against Vietnam Government Certification Authority - Part1",
    "authors": "Vincss",
    "file_creation_date": "2024-01-04T04:45:12Z",
    "file_modification_date": "2024-01-04T04:45:12Z",
    "file_size": 2963423,
    "plain_text": "# [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1\n\n**blog.vincss.net/2020/12/re018-1-analyzing-new-malware-of-china-panda-hacker-group-used-to-attack-supply-chain-**\nagainst-vietnam-government-certification-authority.html\n\n**I. Introduction**\n\nIn process of monitoring and analyzing malware samples, we discovered an\ninteresting blog\npost of NTT [here. Following the sample\nhash in this report, we noticed\na hash on VirusTotal:](https://insight-jp.nttsecurity.com/post/102glv5/pandas-new-arsenal-part-3-smanager)\n\n_Figure 1. Hash’s information in the NTT blog_\n\nOn the event that a hacker group believed to be from Russia attacked and\nexploited the\nsoftware supply chain to target a series of major US agencies, along\nwith discovery that the\nkeyword eToken.exe belongs to the software that is quite popularly used in agencies,\norganizations and businesses in Vietnam, we have used eToken.exe and SafeNet as\nkeywords for searching on VirusTotal and Google. As a result, we\nuncovered information\n[about two remarkable installation files (1,](https://www.virustotal.com/gui/file/6be34df727fcb79123e4e8f472ad24b698d83395fb17d4db019e9976f485cd83/detection) [2) that have been\nuploaded to VirusTotal since](https://www.virustotal.com/gui/file/b0fd1ff7f5d45be89fffc04937f352754c6055e1f4ca26a9257169ce168569ef/detection)\n**August 2020:**\n\n\n-----\n\n_Figure 2. Information look up on VirusTotal_\n\nThe name of the installation files are quite familiar: gca01-client-v2-x32-8.3.msi and gca01**client-v2-x64-8.3.msi, We have tried to\ndownload these two files from the website and they**\nhave the same hash value. However,\nat the present time, all files on the VGCA homepage\nhave been removed and\nreplaced with the official clean version. According to the initial\nassessment,\nwe consider this could be an attack campaign aimed at the software supply\nchain\nthat can be leveraged to target important agencies, organizations and\nbusinesses in\nVietnam.\n\nOn December 17, ESET announced a discovery of an attack on\nAPT they called \"Operationth\nSignSight\" against the Vietnam Government Certification Authority (VGCA). In\nthat report,\nESET said they have also notified VNCERT and VGCA and VGCA has confirmed\nthat they\nwere aware of the attack before and notified the users who downloaded\nthe trojanized\nsoftware.\n\n\n-----\n\nAt the time of analysis, we have obtained two setup files that have been\ntampered by\nhackers. This blog post series will focus on analyzing the signatures\nand techniques that\nhackers have applied to malicious samples in these two\ninstallation files.\n\n**II. Analyze installation file**\n\nThis application is named as \"SafeNet\nAuthentication Clients\" from SafeNet\n.Inc company.\nPortable Executable (PE) files are mostly signed with SafeNet\ncertificates.\n\n_Figure 3. PE files\nsigned with SafeNet certificate_\n\nBy using UniExtract tool, we\nextracted the entire file from an installer (x64 setup file). The\ntotal number\nof files is 218 files, 68 subfolders, the total size is 75.1 MB (78,778,368 bytes).\nTo find out which file has been implanted by\nhackers, we only focus on analyzing and\nidentifying unsigned PE files.\n\nWith the help of sigcheck\ntool in Micorsoft's SysInternals Suite,\nwith the test parameters is\nsigned, hash, scan all PE files, scan the hash on\nVirusTotal, the output is csv file. Then\nsorting by unsigned file, resulting\nfrom VirusTotal, we discovered that eToken.exe is the file\nwas implanted by the hacker.\n\n_Figure 4. Discovered\nfile was implanted by hacker_\n\nThe hash of this eToken.exe matches with the one in NTTSecurity's report. Another strange\npoint is\nthat it’s a 32bit PE but located in the x64 directory, the version information such\nas\n“Company, Description, Product…”\nare not valid for such a large company application. Here\n[is the scan result of\nthe eToken file on VirusTotal.](https://www.virustotal.com/gui/file/97a5fe1d2174e9d34cee8c1d6751bf01f99d8f40b1ae0bce205b8f2f0483225c/detection)\n\n\n-----\n\nSince this application is built with Visual C ++ of Visual Studio 2005 which is old version, and\nuses\nthe Qt4 library, some of the dll files of this installer are also unsigned. We\nchecked each\nfile and determined that the files were clean, leaving only three suspicious\nfiles:\n**RegistereToken.exe, eTOKCSP.dll and eTOKCSP64.dll.**\n\nSo eToken.exe file is a malware\nthat hackers have added to the installation of the software\nsuite. To find out\nhow eToken.exe is executed, we\nanalyze the installation file: msi file\n(Microsoft\nWindows Installer file): gca01-client-v2-x64-8.3.msi\n\nExtracting the msi file to raw format before installing, we obtained two\n.cab files (Microsoft\n_Cabinet file): Data1.cab and Cabs.w1.cab. This is anomaly because a normal msi file has_\nonly one main .cab file.\nCheck the Data1.cab file and the MSI log\ntext file, eToken.exe and\n**RegistereToken.exe are in Data1.cab file. And both .exe files have no GUID ID info:**\n\n_Figure 5. Exe files\ndo not have a GUID ID info_\n\nContinue checking the features: DriverFeature, and two files eToken.exe and\n**RegistereToken.exe msi file with Microsoft's Orca\ntool (a specialized tool for analyze and**\n_modify msi files). Through a search, the hacker has added a custom action: RegisterToken_\n(without \"e\"\nbefore Token) to the msi file and added that CustomAction at the end of\n**InstallExecuteSequence. RegistereToken.exe will be called with the parameter is**\n**eToken.exe:**\n\n\n-----\n\n_Figure 6. Hacker implanted\na custom action_\n\nAnalyzing the RegistereToken.exe file, we see that this file was built on \"Wednesday,\n**22.07.2020 07:40:31 UTC\", ie 07/22/2020, 2h40m31s PM GMT +7, PE64, using VC ++**\n**2013:**\n\n_Figure 7. Information\nof the RegistereToken.exe file_\n\n**RegistereToken.exe's pseudo code only calls the WinExec API to execute the passed in**\nargument:\n\n_Figure 8. Tasks of RegistereToken.exe_\n\nWith all the information above and based on the timestamp in the Data1.cab and\n**RegistereToken.exe files, we can conclude:**\n\nHacker has created and modified the .msi file and created the Data1.cab file at\ntimestamp: 07/20/2020 - 15:15 UTC time added the eToken exe file at this time\n\n\n-----\n\nBuild RegistereToken.exe file at timestamp: 22/07/2020 - 07:40 UTC\nAdd RegistereToken.exe file to Data1.cab at timestamp: 22/07/2020 - 08:40 UTC\n\nNote: According to Cab file format, the two Date and Time fields of a file in the cab file are\n**DOS Datetime format, each of which is a Word 2 bytes which reflect the time when the file**\nwas added according to DOS time. Cab file processing programs will convert and\ndisplay in\nUTC time. That is, the above UTC times are the current time on the\nhacker machine. See\nmore [here.](https://docs.microsoft.com/en-us/windows/win32/sysinfo/ms-dos-date-and-time)\n\n_Figure 9. MS DOS\nDatetime Information_\n\n**III. Analyze\neToken.exe**\n\n**1. Analyze PE Structure**\n\nFile eToken.exe:\n\nSize: 192 KB (196,608 bytes)\nMD5: 830DD354A31EF40856978616F35BD6B7\nSHA256:\n97A5FE1D2174E9D34CEE8C1D6751BF01F99D8F40B1AE0BCE205B8F2F0483225C\n\nInformation about compiler, RichID and build timestamp:\n\nBuild with VC ++ 6 of Microsoft Visual Studio, Service Pack 6.\nBuild at: 26/04/2020 - 15:12:58 UTC\nChecksum is correct, file has not been modified PE Header.\nLinking with MFC42.dll library, Microsoft Foundation Class v4.2 library of Microsoft, is a\nlibrary supporting GUI programming on Windows, always included in Visual Studio\nsuite\n\n\n-----\n\nLink with a special library: dbghelp.dll. Use the MakeSureDirectoryPathExist API\nfunction. See more [here.](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-makesuredirectorypathexists)\n\nChecking the resource section of the file, we determined that this is a\nDialog application,\ncreated by MFC Wizard\nof Visual Studio 6. The project name is VVSup, which means the\n**.exe file when built out would be VVSup.exe.**\n\n_Figure 10. File's resource\ninformation_\n\n**2. Static code analysis**\n\n**eToken.exe (VVSup.exe) is built with\ndynamic link DLL mode with MFC42.dll, so the .exe**\nfile will be small and the functions of the MFC42 libirary\nwill be easily identified via the name\nimport of the DLL. The name mangling\nrule of Microsoft VC ++ compiler reflects the class\nname, function name,\nparameter name, call type... of functions. IDA helps us to define the\nfunctions\nimport by ordinal of MFC42.dll using the file mfc42.ids and mfc42.idt included\nwith IDA\n\n\n-----\n\nHowever, VVSup is built with the RTTI (Runtime Type Information)\noption is disabled, so\nthere is no information about the RTTI and Virtual Method Table of all classes in the file. We\nonly have RTTI of class type_info, the root class of RTTI.\n\n_Figure 11. RTTI Info of\ntype_info class_\n\nThe analysis will show how to define classes, recreate the code of this\nmalware, and share\nexperience in applying when analyzing malwares/files using\nMFC.\n\nPlugins used:\n\nSimabus’s ClassInformer\nMatrosov’s HexRaysCodeXplorer\n**MFC_Helper**\n\nThe MFC C++ source code can be found in the src\\mfc directory of the\nVisual Studio\ninstaller. Since MFC4.2 (MFC of VS6) is very old, it can be found\non Github. We refer [here.](https://github.com/dblock/msiext/tree/master/externals/WinDDK/7600.16385.1/inc/mfc42)\n[About the\nrelationship chart of the classes of MFC (Hierarchy Chart), you can see at this\nlink.](https://docs.microsoft.com/en-us/cpp/mfc/hierarchy-chart?view=msvc-160)\n\nThree important dlls file to diffing/compare with MFC malware, for\nexample in this sample\n**eToken, are mfc42.dll, mfc42d.dll, mfco42d.dll. You can find and download the correct**\ndebug\nsymbol file (.pdb) of the dlls you have. The most important one is mfc42d.dll (debug\n_build), since its .pdb will contain full information about the types, enumes, classes, and_\nvtables of the MFC classes. We export local types from mfc42d.dll to .h\nfile, then import into\nour idb database. IDA's Parse C ++ has an error, unable\nto parse the \"<>\" template syntax,\nso we find and replace pairs of \"<\" and \">\" to \"_\"\nin .h files.\n\nParallel opening mfc42d.dll in new IDA together with IDA is parsing malware, copy names,\ntypes of\nclasses, functions from mfc42d.dll. As mentioned, this malware is an MFC Dialog\napplication, so we will\ndefinitely have the following classes in the malware: CObject,\n**CCmdTarget, CWinThread, CWnd, CDialog. According to the MFC Wizard's auto-naming**\nrule, we have classes with\nthe following names: CVVSupApp (inherited from CWinApp),\n**CAboutDlg (dialog About, resID = 100), CVVSupDlg (main dialog, resID = 102).**\n\nScan results of vtables, classes of two plugins ClassInformer and HexRaysCodeXplorer.\n\n\n-----\n\n_Figure 12. Scanning vtables,\nclasses result_\n\nUse MFC_Helper scan CRuntimeClass, as expected, CVVSupDlg has CRuntimeClass\nand add another class: CVVSupDlgAutoProxy. It shows that the hacker when running the\nMFC Wizard, clicked to\nselect support OLE Control.\n\n_Figure 13. Detect classe after\nrun MFC_Helper_\n\nBased on the import function CWinApp::GetRuntimeClass, we can determine CVVSupApp\nvtable, and based on CDialog::GetRuntimeClass we can define two vtables of the other\ntwo\ndialogs. But which dialog is About, which dialog is a malware dialog? Identify\nall the\ninternal structures of MFX such as AFX_MSGMAP, AFX_DISPMAP,\n**AFX_INTERFACEMAP...**\n\nUsing the Xref to feature call the CDialog constructor: void __thiscall CDialog::CDialog\n**(CDialog *this, unsigned int\nnIDTemplate, CWnd *pParentWnd), nIDTemplate is the**\n**resID of the dialog, we define the vtable of CAboutDlg and CMalwareDlg. Because**\n**CMalwareDlg does not have CRuntimeClass and RTTI, so it is temporarily named like that.**\nThe hacker deleted the DECLARE_DYNAMIC_CREATE line of these two\nclasses and the\n**CVVSupApp class when build.**\n\n\n-----\n\n_Figure 14. Identify vtable of\nCAboutDlg and CMalwareDlg_\n\nRelational Classes table of this malware:\n\n\n-----\n\n_Figure 15. Relational classes table\nof this malware_\n\nCopy the names of functions, types, function types, parameters ... from\nthe respective parent\nclasses of the above classes, in the correct order in the\nvtable, identify the generated MFC\nWizard functions and the functions the\nhacker wrote.\n\n_Figure 16. Result after copy\nname of functions, types, function types, parameters_\n\nEvery MFC application has a global variable called theApp, belonging to the main class\n**CXXXApp inheriting from CWinApp. In the case of this malware are: CVVSupApp theApp;**\nThis global variable is initialized by C RTL in the start function, called before main/WinMain,\nin table __xc_a. The functions in this table call after the C RTL constructors in __xi_a. These\ntables are the parameters passed to the\ninternal _initterm function of C RTL.\n\n\n-----\n\n_Figure 17. TheApp global\nvariable in the MFC application_\n\nThe flowchart of creating and executing an MFC application is as\nfollows:\n\n_Figure 18. Flowchart of\ncreating and executing an MFC application_\n\nThe CVVSupApp :: InitInstance function is also a common code generated by MFC\nwizard\n\n\n-----\n\n_Figure 19.\nCVVSupApp::InitInstance function_\n\nConstructor of CVVSupDlg: void CVVSupDlg::CVVSupDlg() is also common code\ngenerated by MFC Wizard.\nBut in CVVSupDlg::OnInitDialog, which is called\nfrom\n**CVVSupDlg::DoModal(), we can see\nimmediately, at the end of the code that the MFC**\nWizard generated, CMalwareDlg is initialized and shown, then the malware\nexits forcibly\n**exit (0).**\n\n\n-----\n\n_Figure 20. CMalwareDlg was created and shown_\n\nThe value 129 is\nthe resID of the CMalwareDlg dialog, and sizeof(CMalwareDlg) = 0x290,\nwhich is larger than the size of the parent\nCDialog. It proves that CMalwareDlg was added\nby hackers to some data members. Through analysis, we\nrecreated the data members of\n**CMalwareDlg:**\n\n_Figure 21. Recreate data\nmembers of CMalwareDlg_\n\nThe CMalwareDlg::CMalwareDlg Constructor does the following initialization\njobs. Note the\ncopy string \"192.168\" into the field m_szMask:\n\n\n-----\n\n_Figure 22. Copy\n\"192.168\" string to m_szMask field_\n\nWhen shown, CMalwareDlg::OnInitDialog will be called, and the main function that is\nimportant for doing the malware's task is called here:\n\n_Figure 23. The Infect main function will do the malware's job_\n\nThe Infect (we named) function is relatively long, so it should be presented via\nthe flowchart\nbelow:\n\n\n-----\n\n_Figure 24. Infect function\nflowchart_\n\nWe'll go into detail each of the important child functions called by the\nInfect function of the\n**CMalwareDlg class. The UserIsAdmin function, using the IsUserAdmin() API of**\n**shell32.dll:**\n\n\n-----\n\n_Figure 25. UserIsAdmin fuction_\n\n**GetSomeAPIAddrs function is a redundant function, function pointers are taken but**\ncompletely unused. We guess this could be an old code.\n\n\n-----\n\n_Figure 26. GetSomeAPIAddrs\nfunction_\n\nThe Base64Decode function is like other Base64 decode functions, except that the Base64\ncode table is copied by the hacker to a char arrary m_szBase64Table and accessed from\nhere. After being decoded Base64, the original\nServiceName\n\"TmV0QmlvcyBNZXNzYWdlciBSZWdpc3Rlcg==\" will be \"NetBios Messager Register\".\nThe original ServiceDescription\n\"TmV0QmlvcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gc3lzdGVtIGNvbXBvbmVudHMu\"\nwould be\n\"NetBios\ncommunication between system components.\"\n\nThe ExtractCabFile function is a global function, not part of the CMalwareDlg class. Note\nthat the file is created with the\nattribute hidden.\n\n\n-----\n\n_Figure 27. ExtractCabFile function_\n\nThe .cab file is completely embedded in the .data section, size = 94874 (0x1729A). Hackers\ndeclared\nthe following equivalent: \"static BYTE g_abCabFile[] = {0xXXXX, 0xYYYY};\" (no\n**const, so it will be located in .data section). Extracting that area, we have a .cab file**\ncontaining a file, named smanager_ssl.dll, the date added to\nthe cab is 04/26/2020 - 23:11\n**UTC, build date 26.04.2020 15:11:24 UTC.**\n\n_Figure 28. The embedded .cab\nfile contains the file smanager_ssl.dll_\n\nThe smanager_ssl.dll file (netapi32.dll) will be analyzed in the next post because it is\nrelatively complex.\n\n\n-----\n\n_Figure 29. RunExtrac32Exe function_\n\nThe ExecuteAndWait function is also a global function, using the ShellExecuteExA API to\ncall and wait\nuntil the execution completes.\n\n_Figure 30. ExecuteAndWait\nfunction_\n\nThe Config of the Proxy on the victim machine is defined by the hacker\nthrough a struct as\nshown, PROXY_TYPE is an enum:\n\n\n-----\n\n_Figure 31. struct PROXY_CONFIG_\n\nThe ReadProxyConfig function will read from the victim's registry first, otherwise it will\nread\nfrom the Firefox pref.js file. We are still not clear why hackers tried to read from Firefox,\nmaybe they did a reconnaisance to learn about the commonly used web browsers at\nthe\ntarget.\n\n_Figure 32. ReadProxyConfig\nfunction_\n\nThe ReadProxyConfigFromRegistry function is a bit long so there are only\nimportant parts:\n\n\n-----\n\n_Figure 33. The main job of the\nReadProxyConfigFromRegistry function_\n\nThe ReadProxyConfigFromFireFox function is very long so we won't cover it in\ndetail here.\nThe UpdateFile function uses the memsearh equivalent function to find a string in the file's\ncontent, and C&C\nInfo will be written at the found location. In the case of this malware, the\nmask string is \"192.168\".\n\n\n-----\n\n_Figure 34: The\nUpdateFile function uses the memsearh equivalent function to find a string_\n\nWe recreated the C&C Info struct as follows:\n\n_Figure 35. struct of C&C\ninfo_\n\nAnd C&C info has been hardcoded by hackers in the code:\n\n\n-----\n\n_Figure 36. C&C information\nis hardcoded in the malicious code_\n\nThe content of smanager_ssl.dll* (netapi32.dll**) is original and\nafter being updated from\n**g_CCInfo structure via:**\n\n_Figure 37. Contents of\nsmanager_ssl.dll file (netapi32.dll) before and after being updated_\n\nThe function to load the extracted file and create the Scheduler Task:\n\n\n-----\n\n_Figure 38. Function LoadDllAndCreateSchedulerTask to load the extracted\nfile and create a Scheduler_\n\n_Task_\n\nThen, if the malware is run with admin, it will register as a ServiceDll, with the name\nmentioned above, the Service\nregistry key chosen at random from a table of ten elements,\nand appended \"Ex\". These series include: \"Winmads\", \"Winrs\", \"Vsssvr\", \"PlugSvr\",\n\"WaRpc\", \"GuiSvr\", \"WlanSvr\", \"DisSvr\", \"MediaSvr\", \"NvdiaSvr\".\n\nAfter appending Ex by\nthe sprintf function, the\nregistry key on the victim machine is created\nunder the branch HKLM\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\Svchost will\nbe one of the following strings: “WinmadsEx”, “WinrsEx”, “VsssvrEx”, “PlugSvrEx”,\n“WaRpcEx”, “GuiSvrEx”, “WlanSvrEx”, “DisSvrEx”, “MediaSvrEx”, “NvdiaSvrEx”.\n\nSince the function is also a bit long, only the main points are covered\nhere:\n\n\n-----\n\n_Figure 39. Create a registry\nkey on a victim machine_\n\n_Figure 40. Create service on victim machine_\n\n\n-----\n\nThe RegistryCall function is a self-written function by hacker, it is a global function,\nalso only\ndoing tasks with the Registry. From our point of view, hackers'\nprogramming styles are\nextremely messy and inconsistent (maybe this is how they intentionally confusing), which\nmade it\ndifficult for us to analyze. After registering as a Dll service, the Infect\nfunction\ncompletes and returns. Malware will exit because of the above call to exit(0) on\n**OnInitDialog**\n\nWe will provide .xml file containing analysis information on IDA so anyone interested in\nthis\nmalware can use it to re-import IDA and Ghidra using Ghidra's plugin xml_importer.py.\n\nThe IOCs of the malicious code have been noted in the\narticle. You can write your own .bat\nfile or script using PowerShell, VBS\n... to find and remove this malware on the victim's\ncomputers.\n\n**Note:**\n\nOriginal smanager_ssl.dll\n\nMD5: C11E25278417F985CC968C1E361A0FB0\nSHA256:\nF659B269FBE4128588F7A2FA4D6022CC74E508D28EEE05C5AFF26CC23B7BD1A5\n\n**netapi32.dll (ie smanager_ssl.dll has updated CCInfo):**\n\nMD5: 43CE409C21CAD2EF41C9E1725CA12CEA\nSHA256:\n6C1DB6C3D32C921858A4272E8CC7D78280B46BAD20A1DE23833CBE2956EEBF75\n\n[Click here for Vietnamese version: Part 1,](https://blog.vincss.net/2020/12/phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-Panda.html) [Part 2](https://blog.vincss.net/2020/12/re017-2-phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-Panda.html)\n\n**Trương Quốc Ngân (aka HTC)**\n\n**Malware Analysis Expert - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/7kpp4fupti1rrzasopaggbaj8rgyi3aa"
    ],
    "report_names": [
        "Vincss-RE018-ChinaPanda-attack-supply-chain-against-Vietnam-1(12-19-2020)"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bbdb2d7d-4bf4-4100-a108-f4742cfd69ff",
            "created_at": "2022-10-25T16:07:24.01101Z",
            "updated_at": "2025-03-27T02:02:10.074776Z",
            "deleted_at": null,
            "main_name": "Operation SignSight",
            "aliases": [],
            "source_name": "ETDA:Operation SignSight",
            "tools": [
                "Mimikatz",
                "PhantomNet",
                "SManager"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1704420495,
    "ts_updated_at": 1743041395,
    "ts_creation_date": 1704343512,
    "ts_modification_date": 1704343512,
    "files": {
        "pdf": "https://archive.orkl.eu/e22b4351d5cdae2ce8ec011d65b1b2753fa32b65.pdf",
        "text": "https://archive.orkl.eu/e22b4351d5cdae2ce8ec011d65b1b2753fa32b65.txt",
        "img": "https://archive.orkl.eu/e22b4351d5cdae2ce8ec011d65b1b2753fa32b65.jpg"
    }
}