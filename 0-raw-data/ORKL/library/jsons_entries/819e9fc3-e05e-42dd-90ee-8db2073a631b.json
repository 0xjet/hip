{
    "id": "819e9fc3-e05e-42dd-90ee-8db2073a631b",
    "created_at": "2022-10-25T16:48:18.748364Z",
    "updated_at": "2025-03-27T02:13:50.582369Z",
    "deleted_at": null,
    "sha1_hash": "b3337c0f3226c009089da347f58b0611411dfbed",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-01-26T07:34:23Z",
    "file_modification_date": "2021-01-26T07:34:24Z",
    "file_size": 1768385,
    "plain_text": "###### TLP: WHITE\n\n\n# A WILD KOBALOS APPEARS\n\n### Tricksy Linux malware goes after HPCs\n\n#### Marc-Etienne M.Léveillé Ignacio Sanmillan\n\n\n-----\n\n#### TABLE OF CONTENTS\n\n1. Executive summary  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 4\n\n1.1 Key findings  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  4\n\n2. Introduction .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 5\n\n3. Operation .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 6\n\n3.1 Victimology .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  6\n\n3.2 Initial compromise vector  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  7\n\n3.3 High performance computer networks under attack  .   .   .   .   .   .   .   .  7\n\n3.4 Overview of Kobalos  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  7\n\n4. Kobalos technical analysis .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 10\n\n4.1 Obfuscation  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 10\n\n4.2 Configuration .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  13\n\n4.3 Deployment and persistence .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 14\n\n4.4 Interacting with the backdoor  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  14\n\n4.5 Malware operation .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  19\n\n5. OpenSSH credential stealer .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 24\n\n5.1 An evolving malware family  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 25\n\n6. Conclusion  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 26\n\n7. Appendix – Inlined functions in Kobalos .  .  .  .  .  .  .  .  .  .  .  .  .  . 27\n\n8. Indicators of compromise .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 28\n\n8.1 ESET detection names .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 28\n\n8.2 Samples  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 28\n\n8.3 Keys .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 28\n\n8.4 YARA rules .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 29\n\n9. MITRE ATT&CK techniques  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 30\n\n\n-----\n\n#### LIST OF TABLES\n\nTable 1 _Structure of Kobalos static configuration blob  .   .   .   .   .   .   .   .   .   .   . 13_\n\nTable 2 _Structure of authentication packet (encrypted with the RSA private key) .   .  16_\n\nTable 3 _Structure of authentication reply from Kobalos_\n_(encrypted with the RSA public key)  .   .   .   .   .   .   .   .   .   .   .   .   .   . 17_\n\nTable 4 _Kobalos packet structure  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  17_\n\nTable 5 _Commands to use Kobalos as a proxy .   .   .   .   .   .   .   .   .   .   .   .   .  20_\n\nTable 6 _Commands understood by Kobalos for reading and writing files .   .   .   .   . 20_\n\nTable 7 _Commands for creating and managing pseudo-terminals  .   .   .   .   .   .   .  21_\n\nTable 8 _Commands for managing a Kobalos C&C server  .   .   .   .   .   .   .   .   .   .  22_\n\nTable 9 _Other commands understood by Kobalos .   .   .   .   .   .   .   .   .   .   .   .  23_\n\n#### LIST OF FIGURES\n\nFigure 1 _Industry and region of compromised organizations  .   .   .   .   .   .   .   .   .  6_\n\nFigure 2 _Overview of Kobalos features and ways to access them  .   .   .   .   .   .   .   . 9_\n\nFigure 3 _Control flow graph of Kobalos  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 10_\n\nFigure 4 _C code showing what the source of Kobalos may look like after control_\n_flow flattening is performed .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 11_\n\nFigure 5 _Kobalos avoids creating core dumps on crash and will ignore most signals .   . 12_\n\nFigure 6 _Example configuration seen in a Kobalos sample embedded in sshd_ _.   .   .   . 13_\n\nFigure 7 _Call to kobalos function from trojanized OpenSSH main function_\n_after a new TCP connection is accepted .   .   .   .   .   .   .   .   .   .   .   .   . 14_\n\nFigure 8 _Comparing source port with 55201  .   .   .   .   .   .   .   .   .   .   .   .   .   .   15_\n\nFigure 9 _Comparing source port against the list of 16 ports .   .   .   .   .   .   .   .   .   . 15_\n\nFigure 10 _Authentication taking place after 320 bytes are received  .   .   .   .   .   .   .  16_\n\nFigure 11 _Loading of the RSA-512 public key  .   .   .   .   .   .   .   .   .   .   .   .   .   .   16_\n\nFigure 12 _Information sent from the compromised host to the operator  .   .   .   .   .   . 18_\n\nFigure 13 _Sequence diagram summarizing Kobalos network protocols  .   .   .   .   .   .  18_\n\nFigure 14 _Kobalos used as proxy  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  19_\n\nFigure 15 _Operator of Kobalos reaching out to bots reporting to a C&C server .   .   .   22_\n\nFigure 16 _Packets related to managing the C&C server forwarded_\n_to the subprocess via TCP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  22_\n\nFigure 17 _Commands 0x07 and 0x09 do not perform any operation .   .   .   .   .   .   . 23_\n\nFigure 18 _Encrypting and writing SSH credentials to a file .   .   .   .   .   .   .   .   .   .  24_\n\nFigure 19 _Malware sending credentials over UDP .   .   .   .   .   .   .   .   .   .   .   .   .  25_\n\nFigure 20 _Example configuration using a file to write stolen credentials .   .   .   .   .   . 25_\n\n\n-----\n\n#### 1. EXECUTIVE SUMMARY\n\nESET Research has analyzed Kobalos, previously unknown and complex multiplatform malware\ntargeting Linux, FreeBSD and Solaris systems. Given that the victims of this threat are mostly high-profile\norganizations, it seems almost certain this malware is deployed against chosen targets rather than\nopportunistically. When deployed, this malware gives access to the file system of the compromised host\nand enables access to a remote terminal, giving the attackers the ability to run arbitrary commands.\n\nThe network capabilities of Kobalos make this malware quite distinctive. It supports acting both as a passive\nimplant and as a bot actively connecting to its C&C server. Interestingly, these C&C servers are themselves\ncompromised with Kobalos; the code for running such servers is present in all Kobalos samples.\n\nBy performing an internet-wide scan, ESET Research was able to identify and notify victims of this threat.\n\nIt is unclear how old this malware is, but the first known activity was confirmed by a victim\nwho was compromised in late 2019. The group operating Kobalos remained active throughout 2020.\n\nThe Linux threat landscape continues to evolve, and at times, malware authors invest a considerable\namount of resources into their tradecraft. Kobalos is one of these cases.\n\n##### 1.1 Key findings\n\n- Kobalos is a multiplatform backdoor that works on Linux, FreeBSD and Solaris. There are also artifacts\n\nindicating that variants of this malware may exist for AIX and even Windows.\n\n- The targets of Kobalos are high profile and include high-performance computers, servers in academia,\n\nan endpoint security vendor, and a large internet service provider. It was deployed in servers located\nin Europe, North America, and Asia.\n\n- Kobalos uses a complex obfuscation mechanism that makes its analysis challenging.\n\n- Any Kobalos-compromised server can be turned into a C&C server for other hosts compromised\n\nby Kobalos. The code is embedded into the malware and can be activated by the operator at any time.\n\n- Most hosts compromised by Kobalos that we investigated also had an OpenSSH credential stealer\n\ninstalled. This may explain how Kobalos propagates.\n\n- The intent of the authors of this malware is still unknown. We have not found any clues to indicate\n\nwhether they steal confidential information, pursue monetary gain, or are after something else.\nNo other malware was found on compromised systems except the SSH credential stealer.\n\n\n-----\n\n#### 2. INTRODUCTION\n\nIf you have been following ESET Research’s work over the past few years, you may have noticed we like\nfinding and documenting server-side malware targeting Linux and other less commonly targeted operating\n[systems. One of our first such reports was Operation Windigo, which documents multiple malware families](https://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf)\nworking together to perform internet traffic redirection, send spam, and perform other malicious activity.\nThe core malware of Operation Windigo is Ebury, an OpenSSH backdoor and credential stealer. Ebury\nis able to compromise the SSH client and server without actually modifying the OpenSSH executable files;\nit modifies a library loaded by them and patches functions to enable Ebury and steal credentials when\nthe backdoor is loaded. This is not easily done, but the Ebury authors are able to do this in a reliable way.\n\nSince our paper on Operation Windigo, we discovered and documented multiple other Linux threats\n[such as Mumblehard, Moose, Shishiga and tens of backdoors for OpenSSH in a paper we titled The dark side](https://www.welivesecurity.com/wp-content/uploads/2015/04/mumblehard.pdf)\n_[of the ForSSHe.](https://www.welivesecurity.com/wp-content/uploads/2018/12/ESET-The_Dark_Side_of_the_ForSSHe.pdf)_\n\nUp until now, when it comes to analysis, we have not found any Linux malware as challenging as Ebury.\nBut this time there’s a different twist: unlike Ebury, Kobalos’s operations seem not to be at a large scale.\nThe number of machines compromised by Kobalos are more in the tens than, as in the case of Linux/Ebury,\nin the tens of thousands.\n\nThis paper covers our full technical analysis of Kobalos, the targets of this group of attackers, and indicators\nof compromise to help potential victims uncover and remediate it.\n\n\n-----\n\n#### 3. OPERATION\n\n##### 3.1 Victimology\n\nFollowing our analysis, ESET conducted internet-wide scans in an effort to find victims of Kobalos.\nOur fingerprint leverages a specific behavior of the backdoor that occurs when a TCP connection\nis established with a compromised host from a specific source port.\n\nOne of the surprising things about this threat, given its sophistication, is the very limited number\nof victims we could find. Targets, however, don’t seem to be random and tend to be high-performance\ncomputers (HPC) and servers that are part of academic and research networks. One of the HPCs\nhas no less than 512GB of RAM and almost a petabyte of storage. We also uncovered other high-profile\nvictims such as an endpoint security software vendor (not ourselves!).\n\nFigure 1 is a map of the regions and industries of the victims we found.\n\nNorth America Europe Asia\n\nEndpoint security University networks Large Internet\nsoftware vendor service provider\n\nHigh performance\n\nPersonal servers computing\n\nGovernment Marketing agency\n\nHosting\n\nFigure 1 // Industry and region of compromised organizations\n\nSome organizations had multiple servers compromised.\n\nWe notified all victims we identified and worked with them to remediate. We would like to thank\nall victims who replied and shared information that helped us in this research.\n\n\n-----\n\n##### 3.2 Initial compromise vector\n\nWe do not have firsthand knowledge of how systems were compromised to gain administrative access\nto install the Kobalos backdoor on them. We can only speculate based on the forensic artifacts we collected\nwhile assisting victims.\n\nOn compromised machines whose system administrators were able to investigate further, we discovered\nthat an SSH credential stealer was present in the form of a trojanized OpenSSH client. The /usr/bin/ssh\nfile was replaced with a modified executable that recorded username, password and target hostname, and\nwrote them to an encrypted file. Thus, we believe that credential stealing could be one of the ways Kobalos\npropagates. It could also explain why many academic networks were compromised; if one of those system’s\nSSH clients was used by students or researchers from multiple universities, it could have leaked credentials\nto all these third-party systems.\n\nAnother possible entry point could be exploitation of a known vulnerability. Some of the compromised\nmachines ran old, unsupported, or unpatched operating systems and software. While the use\nof an undisclosed vulnerability isn’t impossible, a known exploit is more likely in this situation.\n\n##### 3.3 High performance computer networks under attack\n\nESET shared information with organizations, such as the CERN Computer Security Team, who played\nan instrumental role in handling the incidents at research and academic sites. What these organizations\ncould confirm is that between the end of 2019 and mid-2020, a wave of three different attacks targeted\n[the HPC community. Some have been reported](https://www.cadosecurity.com/post/recent-attacks-against-supercomputers) _publicly._\n\nAfter many months of investigations, it remains unclear whether these three campaigns are connected\nor a surprising coincidence. On one hand, operations seem to leverage different tactics, techniques (TTPs)\nand levels of sophistication. On the other hand, it seems odd that there is an overlap in some of the\nIP addresses used to launch the different attacks.\n\n1. The earliest campaign used Kobalos, the malware described in this research.\n\n2. The second campaign appears to have focused on cryptocurrency mining by leveraging\n\na totally different toolset.\n\n3. The third campaign was the most widespread, yet no payload was identified.\n\nPartial indicators of compromise for the second and third attacks were published by the European\n[Grid Infrastructure Computer Security Incident Response Team (EGI CSIRT) as incident #EGI20200421](https://csirt.egi.eu/attacks-on-multiple-hpc-sites/)\n_[and #EGI2020512 respectively.](https://csirt.egi.eu/attacks-on-multiple-hpc-sites/)_\n\nIt is not clear why the HPC community is overly represented among the victims of these attacks.\nHPC centers are obviously interesting targets but typically less easily accessible than other academic servers.\nThrough a fully community-based, distributed incident response process, CERN and other incident response\nteams involved observed a number of legacy designs and suboptimal security practices that played a key\nrole in enabling the attackers to spread their attacks. Additionally, most HPC victims were poorly prepared\nfor forensics, in particular with regard to traceability.\n\n##### 3.4 Overview of Kobalos\n\nKobalos has multiple features to access the compromised systems and hide the tracks of its usage.\n\n###### Access to the compromised system\n\nFirst, the Kobalos malware contains generic commands to read from and write to the file system and spawn\na terminal to execute arbitrary commands. Unfortunately, it doesn’t contain any specific payload that could\nindicate the intentions of its authors. The operators likely open a shell through the terminal and perform\nwhatever commands they need to.\n\n\n-----\n\n###### Reachability\n\nSecond, there are numerous functionalities related to establishing network connectivity between\nthe operators and the running Kobalos malware. It supports multiple ways to make itself reachable\nfrom the outside:\n\n1. By opening a TCP port and waiting for an incoming connection (sometimes called a passive backdoor).\n\n2. By connecting to another instance of Kobalos configured to run as C&C server.\n\n3. By waiting for connections to an already running, legitimate service but coming from a specific\n\nTCP source port.\n\nThat last option requires replacing the running service with one containing the Kobalos code.\nIn all cases we’ve seen for this method, they have chosen to modify the running OpenSSH server.\nThe sshd file was completely replaced, so the malware is persistent across service or system restarts.\n\n###### Authentication and network encryption\n\nThird, triggering the backdoor requires its clients to authenticate. Clients must possess an RSA-512 private\nkey and a password. Once both are validated, Kobalos generates and encrypts two 16-byte keys with the\nRSA-512 public key and sends them to the attackers. These two keys are used to RC4 encrypt subsequent\ninbound and outbound traffic.\n\n###### Alternate port\n\nFourth, during the authentication phase, the operator can choose to continue the communication\non another TCP connection. When asked, Kobalos will start listening on the requested TCP port and the rest\nof the communication will use that connection. Data going through this channel is encrypted using\nthe RC4 keys previously exchanged during authentication.\n\n###### Proxying to other compromised machines\n\nFifth, Kobalos can also be used as a proxy to connect other servers compromised with Kobalos. It is not\na generic TCP proxy; it expects communication to be encapsulated in packets specific to this threat. It also\nsupports the alternate port option mentioned above: a command can be sent to the proxy to “switch”\nthe connection to a new TCP port.\n\nProxies can be chained, which means the operators can use multiple Kobalos-compromised machines\nto reach their targets.\n\n\n-----\n\n###### Putting it all together\n\nFigure 2 provides an overview of the different features of Kobalos.\n\n\nCompromised\nserver A\n\n\n**2**\n\n|Col1|2|\n|---|---|\n\n\nOperator **1**\n\n###### >[_]\n\nFile\n\nTerminal\n\nsystem\n\nScenario 1 Scenario 2\n\n|1|Col2|\n|---|---|\n|||\n\n|Col1|Col2|\n|---|---|\n\n\nScenario 3\n\n\n**3**\n\n\nServer A is used to proxy\nconnection to Server C.\n\n\nDirect connection\nto the backdoor.\n\n\nServer B uses Server A\nas C&C server.\n\n\nFigure 2 // Overview of Kobalos features and ways to access them\n\nFigure 2 also shows different possible scenarios where the operators try to reach compromised servers.\nThe first is a simple direct connection to a compromised server to access its resources. In the example above,\nthe backdoor is running inside a compromised OpenSSH server process and expects the connection to have\na source port. Communication with the backdoor requires the right TCP source port from the operator.\n\nThe second one is perhaps the trickiest, but also one of the most unique features of Kobalos. Its operators\nhave the ability to start a C&C server from any of the servers running the malware. It doesn’t require\nadditional code: everything is in the malware already. Once started, it will manage a list of connected bots\ngiving the operator the ability to connect to any of them. Authentication is still required on the final node\nand end-to-end encryption is enforced using the exchanged RC4 keys. For this scheme to work, the Kobalos\nmalware sample running on Server B needs to have in its configuration the IP address and port of the C&C\nserver running on Server A. From the perspective of Server B, it will only see traffic to and from Server A,\nhiding the IP address of the operator.\n\nIn the third scenario, Server A is used as a proxy to connect to Server C. Again, authentication\nand end-to-end encryption is enforced. The proxying functionality allows the operator to set the source\nport of the connection from Server A to Server C. This means it can be used to connect to Kobalos instances\nthat expect a specific source port when connecting.\n\n\n-----\n\n#### 4. KOBALOS TECHNICAL ANALYSIS\n\nThe first sample of Kobalos we analyzed was a trojanized OpenSSH server. The size of the Kobalos\nmalicious code and data is quite small: about 25 kB for x86-64 samples. One of the things that makes\nit special is that all of Kobalos’s code is bundled into a single function. There is also only a single call\nto that function from the legitimate OpenSSH code.\n\nKobalos is a complex piece of malware in which, it is clear, its developers invested a considerable amount\nof resources. Its authors implemented quite a lot of features and also took the time to implement\nwhat seems to be custom obfuscation.\n\n##### 4.1 Obfuscation\n\n###### Exceptional control flow flattening\n\nJust because it fits into a single function doesn’t mean control flow is linear; Kobalos recursively calls\nthat function to perform whatever subtask it needs to do. Figure 3 shows the complex control flow graph\nof the Kobalos function.\n\nFigure 3 // Control flow graph of Kobalos\n\nThe first parameter to the function is the action to perform. There are actually 37 actions understood\nby the malware. They are listed in “Appendix – Inlined functions in Kobalos” to help the analysis of existing\nand possible future versions of this malware.\n\nIn addition to these 37 actions, the function also serves as a signal handler for SIGCHLD to let child process\nterminate gracefully and SIGALRM to handle connection timeout.\n\nFrom the point of view of the source code of the malware, it would be like compiling the following C code.\nPart of this transformation could be automated with the function inlining capability of the compiler, but still\nrequires manual work or custom tooling to assign numerical identifier to each function and handle the same\nnumber of arguments in all functions. Figure 4 shows what the C source code could look like before\nand after this obfuscation is applied.\n\n\n-----\n\nFigure 4 // C code showing what the source of Kobalos may look like after control flow flattening is performed\n\n###### Encrypted strings\n\nKobalos doesn’t have any readable plain text string in its code or its data. It only uses a few small\nstrings, which are encrypted using RC4. They are decrypted right after the initial communication\nbut before the authentication. They key is the same for all samples we analyzed\n(AE 0E 05 09 0F 3A C2 B5 0B 1B C6 E9 1D 2F E3 CE).\n\nThe decrypted strings are:\n\n**1.** `%s %s`\n\n2. `/dev/ptmx`\n\n3. `ptem`\n\n4. `ldterm`\n\n5. `ttcompat`\n\n**6.** `/dev/tty`\n\n**7.** `%s`\n\n**8.** `%d`\n\n**9.** `/`\n\n10. \\\n\n11. `%d.%d`\n\n12. `win3.11`\n\n13. `win95`\n\n14. `winNT`\n\n15. `win??`\n\n16. `\\\\.\\pipe\\2`\n\n17. `%s %s.%s`\n\n18. `/dev/ptc`\n\n\n-----\n\nOnly the strings in bold (1 and 6–9) are used by the Kobalos samples we have analyzed. None of the others\nare referenced; however, they may be used by some other variants. Specifically:\n\n- Strings 10 and 12–16 (in blue) seems to be specific to Windows\n\n- String 18 (in pink) is the path to the pseudo-terminal device driver on AIX\n\n- Strings 3–5 (in orange) are used by pseudo-terminal system calls on Solaris\n\nWe cannot exclude an attempt to fool researchers into thinking there are versions for additional operating\nsystems. Considering we confirmed three operating systems are supported, it wouldn’t be surprising\nif more were. On the other hand, Windows 3.11 and Windows 95 are more than 25 years old. Do variants\nof this malware really exist for these legacy operating systems?\n\nAnti-forensics\n\nOnce authentication is done, some anti-forensic techniques will be enforced on the backdoor’s process,\nas shown in Figure 5. They are:\n\n- Set RLIMIT_CORE to zero to prevent core-dump generation if the process crashes\n\n- Ignore most signals to make it more difficult to interrupt the process.\n\nFigure 5 // Kobalos avoids creating core dumps on crash and will ignore most signals\n\nIt’s important to note that setting RLIMIT_CORE will not prevent the process from being dumped manually\nby, for example, gdb’s gcore. This limit is used by the kernel to determine the maximum size of a memory\ndump in the event the process crashes.\n\n\n-----\n\nTimestomping\n\nAnalysis of the file system of compromised servers showed that after either is installed, timestamps\nof replaced files, such as ssh to add the credential stealer or sshd to deploy Kobalos, are tampered\nwith to reduce suspicion.\n\n##### 4.2 Configuration\n\nKobalos has a static configuration that enables or disables functions of the malware. Table 1 lists the fields\nwe identified as part of the configuration and Figure 6 shows what it looks like in an actual sample.\n\n\nTable 1 _Structure of Kobalos static configuration blob_\n\n\nSize (bytes) Description\n\nPossibly a version number. It is reported upon successful authentication. All samples we have seen\n2\nhave value 0xB03 (assuming it is transmitted big-endian, like all other Kobalos communications).\n\n320 Public RSA key modulus. Encoded in a specific binary form.\n\nTCP port to listen to. If set to zero, Kobalos will not listen to any port and use other methods to wait\n2\nfor a connection to the backdoor.\n\nTimeout minimum in minutes for incoming connection or connection to a C&C server. If not set,\n2\nthe timeout defaults to one day.\n\nTimeout range in minutes. The final timeout is a random number of minutes between the minimum\n2\n(previous value) and the minimum plus the range (this value).\n\nIP address of the C&C server to connect to in order to process commands. Set to zero if passively\n4\nwaiting for a connection instead.\n\n2 x 16 TCP ports to try when connecting to C&C server.\n\n16 MD5 hash of the password required for authentication.\n\nFigure 6 // Example configuration seen in a Kobalos sample embedded in sshd\n\n\n-----\n\nPart of this configuration differs when Kobalos is running inside sshd or as a stand-alone executable.\nThe latter requires either a remote C&C server address (remote_c2_addr) or a port to listen\non (listen_port).\n\n##### 4.3 Deployment and persistence\n\nWhen Kobalos is deployed to run as part of the OpenSSH server, the sshd file must be recompiled\nto include the malicious code. We compared the version of OpenSSH that was trojanized and the version\nof OpenSSH that should be installed on the system, such as the one from the package manager. It seems\nthat the operators compile Kobalos using the proper OpenSSH source, the one that was already installed.\nThis suggests that operators possibly compile the malicious OpenSSH executable on the victim’s machine\nbefore replacing the original. This is likely done in order to enable persistence while preventing mismatching\nversion anomalies, such as library incompatibilities.\n\nIt’s worth noting that replacing sshd requires root privileges. However, there exist stand-alone variants\nthat either connect to a C&C server or listen on a TCP port. Those variants do not require administrative\nprivileges to run. However, file system access and commands will be limited to the current\nuser’s access levels.\n\n##### 4.4 Interacting with the backdoor\n\n###### Connecting to the backdoor\n\nOne of the notable features of Kobalos is the malleability of the ways in which the link between\nits operators and the compromised host can be established. There are three possible ways it can be done:\n\n1. Listen on a given TCP port (passive mode).\n\n2. Connect to a C&C server (active mode) and wait for operator to connect through the C&C server.\n\n3. Replace an existing service that listens on a TCP port and wait for connections from specific\n\nTCP source ports.\n\nAlthough it would be possible to activate multiple methods via the static configuration of the malware,\nonly one of them is activated per sample we have analyzed.\n\nThe last method described requires modifying a running daemon. The trojanized version calls Kobalos’s\ncode each time a new TCP connection is accepted, as seen in Figure 7. Kobalos can decide to take over\nfrom there if the connection is from a specific TCP source port. In the case of such a port match, the function\nnever returns and the subprocess will exit when the connection is closed. Otherwise, it does nothing\nand returns to the legitimate service’s code so it still functions properly.\n\nFigure 7 // Call to kobalos function from trojanized OpenSSH main function after a new TCP connection is accepted\n\n\n-----\n\nWe have only seen the OpenSSH server being abused with this method, and this is the most popular method\nwe’ve seen deployed. However, we may be biased because it was also the method we could fingerprint\nin our internet-wide scans.\n\nAs seen in Figure 8, the TCP source port expected by Kobalos is 55201.\n\nFigure 8 // Comparing source port with 55201\n\nThere is also an additional method implemented for filtering incoming TCP connections in Kobalos,\nwhich instead compares the source port against a list of 16 ports, as seen in Figure 9.\n\nFigure 9 // Comparing source port against the list of 16 ports\n\nThe list of ports is\n\n\n20\n\n21\n\n53\n\n230\n\n\n567\n\n982\n\n1821\n\n1912\n\n\n2734\n\n5392\n\n11568\n\n19678\n\n\n22392\n\n33921\n\n44983\n\n55201\n\n\n-----\n\nHowever, we have not seen this filter ever used in any of the samples we analyzed. It may have been used\nin a previous version of this malware.\n\n###### Authentication\n\nOnce a link is established, an authentication process takes place. A private RSA key and a 32-byte password\nare required to go any further. An initial 320-byte packet, whose structure is outlined in Table 2, is sent\nby the Kobalos client to the backdoored server.\n\n\nTable 2 _Structure of authentication packet (encrypted with the RSA private key)_\n\n\nSize (bytes) Description Value\n\n4 Magic `0x7FFF000A`\n\n\n2 Port to bind\n\n\nif 0x0000: Kobalos picks a random port\n\nif 0xFFFF: use existing TCP connection\n\n\nCommunication\n1 Seems to always be set to 0xFF\nchannel identifier\n\nCommunication\n1 Seems to always be set to 0xFF\nchannel identifier\n\nThe password whose value matches the MD5 hash\n32 Password\nin the static configuration.\n\n280 _Padding_\n\nThe first 64 bytes of the packet are decrypted using the RSA-512 public key modulus provided\nin the configuration and the 0x10001 exponent (see Figure 11). Then, as seen in Figure 10, the 32-byte\npassword is MD5-hashed and compared to the digest found in the static configuration.\n\nFigure 10 // Authentication taking place after 320 bytes are received\n\nFigure 11 // Loading of the RSA-512 public key\n\n\n-----\n\nKobalos will use the public RSA key to encrypt a set of RC4 keys to use for the rest of the communication:\none for inbound traffic and one for outbound traffic. Those encrypted keys are sent back in the reply.\nTable 3 outlines the structure of the reply from Kobalos.\n\nThe structure of the reply from Kobalos is the following:\n\n\nTable 3 _Structure of authentication reply from Kobalos (encrypted with the RSA public key)_\n\n\nSize (bytes) Description Value\n\n4 Magic `0x7FFF000A`\n\nRC4 key for inbound\n16 RC4 key to use for traffic to the compromised host\ntraffic\n\nRC4 key for outbound\n16 RC4 key to use for traffic from the compromised host\ntraffic\n\nTCP port open to use as the active channel. Set to 0xFFFF means\n2 Bound port\nit’s using the existing connection.\n\n282 _Padding_\n\n###### Active channel\n\nAfter authentication is accepted, the active channel may use a different port than the one used\nfor authentication. You may have noticed that the client authenticating to Kobalos must provide\na “port to bind” in its encrypted message.\n\n- If this value is different from 0xFFFF, Kobalos will start listening to the given TCP port.\n\n- If this value is zero, it will start listening to a random port above 1024.\n\nAs mentioned above, the newly opened port number is included in the authentication reply alongside\nthe pair of RC4 keys. This additional TCP connection is entirely optional: if 0xFFFF is given as the TCP port\nto bind to, the existing connection is used.\n\nThe rest of the communication on these TCP connections is encapsulated in packets with the format\noutlined in Table 4.\n\n\nTable 4 _Kobalos packet structure_\n\n\nSize (bytes) Value\n\n1 Magic (0x7F)\n\n2 payload_size\n\n1 Communication channel identifier\n\n1 Communication channel identifier\n\npayload_size Payload (RC4 encrypted)\n\nThe Kobalos malware will be the first to send a packet to the connected operator. It contains basic details\nabout the machine such as the hostname and kernel version. Figure 12 depicts the encapsulation layers\nemployed in this packet.\n\n\n-----\n\nPayload\n(RC4-encrypted, 35 bytes)\n```\n                                  v i n l i\n7F 00 23 01 FF 04 0B 03 0A 00 00 05 D7 A1 76 69 6E 20 6C 69\n\n```\n\nMagic Channel\n(0x7f) identifiers\n\n\nConstant from\nconfiguration\n(version?)\n\n\nConnection\ndestination\nport (55201)\n\n|from tion n?)|Col2|\n|---|---|\n\n|Col1|Col2|\n|---|---|\n\n\nUsername (vin) Running kernel\n\n\nLocal IP address\n(10.0.0.5)\n\n\nPacket size\n(35 bytes)\n\n\nCommand ID\n(4, host info reply)\n\n```\n n u x 5 . 3 . 0 - 5 3 - g e n e r i c\n6E 75 78 20 35 2E 33 2E 30 2D 35 33 2D 67 65 6E 65 72 69 63\n\n```\n\nFigure 12 // Information sent from the compromised host to the operator\n\nFigure 13 provides a summary of the link establishment processes between Kobalos and its client.\n\nOperator Kobalos\n\nConnection\nestablishement\n(alternatives)\n\nConnect to SSH sever using source port 55201\n\nConnect to Kobalos listening on a TCP port\n\nReport to server\n\nCreate tunnel\n\nC&C Server\n(Kobalos-infected)\n\nAuthentication\n\nSend authentication packet\n(RSA-encrypted with private key, 320 bytes)\n\nAuthentication Success\n\nSend RC4 keys (RSA-encrypted with public key)\n\nAuthentication Failure\n\nDisconnect\n\nReconnect to requested TCP port (optional)\n\nActive Channel\n(RC4 encrypted) Send victim profile\n\nLoop\n\nCommand\n\nReply\n\nFigure 13 // Sequence diagram summarizing Kobalos network protocols\n\n|Col1|Connect to SSH sever using source port 55201 Connect to Kobalos listening on a TCP port Report to server Create tunnel C&C Server (Kobalos-infected) Send authentication packet (RSA-encrypted with private key, 320 bytes) Authentication Success Send RC4 keys (RSA-encrypted with public key) Authentication Failure Disconnect Reconnect to requested TCP port (optional) Send victim profile Loop Command Reply|Col3|\n|---|---|---|\n||||\n||||\n||||\n||||\n||||\n||||\n\n\n-----\n\n##### 4.5 Malware operation\n\nOnce authenticated, an operator can issue various commands to the backdoor. We can split them\ninto the following categories:\n\n1. Connect to other Kobalos-compromised servers and act as a proxy.\n\n2. Read and write any files on the file system.\n\n3. Launch and access a pseudo-terminal on the compromised host.\n\n4. Run and manage Kobalos C&C servers and access connected bots.\n\nCommands are encapsulated in the active channel and start with a single byte to identify the command,\nfollowed by parameters parsed by that command. The commands documented in this paper are the ones\nhandled by the Kobalos malware, meaning they are sent from the operators to the compromised system\nusing a custom client. Replies from Kobalos have a similar format, with their first byte being an identifier,\nand are handled by that custom client. An example is the “send host info” command (0x04) sent after\nauthentication, as described above.\n\n###### Use as proxy\n\nOperators can use Kobalos installed on a compromised machine to connect to another instance\nof the malware running on a different system.\n\nThe proxy functionality expects specific packet sizes for authentication and encapsulation specific\nto Kobalos as described above, so it’s not a simple, raw TCP proxy.\n\nWhen connecting to a third-party machine, the operator can choose the TCP source port. This allows\nconnecting to instances expecting a specific source port. It also supports having the active channel\n(see Active channel) run through an alternate port. A command can be issued to reconnect to the host\nto the alternate port.\n\nOne of the end goals of this feature is to provide a certain level of anonymity to the malware operators.\nThe end node would only see the IP address of another compromised machine, and not the IP address\nof the operator. To mask the operators’ IP address even further, it is possible to chain multiple\nKobalos-compromised machines as proxies to a final Kobalos-compromised machine.\nFigure 14 shows the network connections involved in this scenario\n\n\nUse backdoor\naccess\n\n\nOperator\n\n\nServer compromised\nwith Kobalos\n\n\nServer compromised\nwith Kobalos\n\nTunnel after\nauthentication\n\n|access|Col2|\n|---|---|\n\n|Col1|S|\n|---|---|\n\n\nTunnel after\nauthentication\n\n\nFigure 14 // Kobalos used as proxy\n\n\n-----\n\nCommands controlling Kobalos’s proxy mechanism are documented in Table 5.\n\n\nTable 5 _Commands to use Kobalos as a proxy_\n\n\n_Command_ _Description_ _Parameters_\n\nRemote address\n\n\nEstablish connection to another\n0x01\nKobalos-compromised host.\n\n\nSource port\n\nDestination port\n\nAuthentication message (320 bytes)\n\nDestination port\n\n\n0x03\n\n\nReconnect using another destination port.\nUseful when active channel is requested\nin a new TCP connection.\n\n\n0x05 Close connection to the other host. _None_\n\n###### File system access\n\nOnce authenticated, an operator can read or write any file on the system.\n\nIn the Kobalos network protocol, an encapsulated Kobalos payload size is defined using a 16-bit integer.\nIt means that the operator can only send a 64 kB packet. For example, if the operator wants to write 200 kB\nof data into a file, four successive write commands are needed. The read command is even more restricted,\nas only 1000 bytes of data are read and sent at a time.\n\nTable 6 lists the commands implementing file-system-related operations.\n\n\nTable 6 _Commands understood by Kobalos for reading and writing files_\n\n\n_Command_ _Description_ _Parameters_\n\nSeek position\n\n0x18 Open file for writing; create it if it doesn’t exist.\n\nFile path\n\nData to write. Data will be overwritten\n0x1A Write data to file.\nat the seek position.\n\n0x1C Close file after write. _None_\n\nSeek position\n\n0x1D Open and read file.\n\nFile path\n\n0x20 Close file after read. _None_\n\n\n-----\n\n###### Pseudo-terminal creation\n\nThis functionality allows an authenticated operator to spawn a shell in a new pseudo-terminal and execute\narbitrary commands at the command prompt. Internally, it is managed by the commands listed in Table 7.\n\n\nTable 7 _Commands for creating and managing pseudo-terminals_\n\n\n_Command_ _Description_ _Parameters_\n\n\n0x12 Start a new pseudo-terminal.\n\n\nPath to shell (e.g. /bin/sh)\n\nArgument\n\n\n0x0D Set pseudo-terminal window size. [Values of winsize struct as accepted by TIOCSWINSZ](https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/baselib-ttyio-2.html)\n\n0x14 Close pseudo-terminal. _None_\n\n0x16 Write to pseudo-terminal. Data to write\n\nThe data output from the terminal is sent back to the operators and uses the command ID 0x17 followed\nby the data. This command is implemented on the client used by the operators.\n\n###### Use as a C&C server\n\nOne of the most unique features of Kobalos is that the code that runs the C&C server is in the malware itself.\nThis enables the perpetrator to use any Kobalos-compromised machine to turn it into a C&C server\n(for other bots) simply by sending a single command.\n\nAfter the C&C server is started, the malware authors can set the IP address and port of this new C&C server\nin the configuration of the future Kobalos instances they will deploy on other hosts. This feature has two\nmain advantages:\n\n- It allows using compromised resources as C&C servers instead of renting a server at a traditional\n\nhosting provider. This reduces the risk for the server to be taken down.\n\n- It allows using the C&C server as a pivot point to machines behind firewalls that are not normally\n\nreachable from the internet.\n\nWhen the operator sends the “turn on C&C mode” command (0x21), a port is given as a parameter.\nKobalos starts listening on this port and bots will use it to connect to this C&C server instance. It will also\nlisten to the next higher port. For example, if the TCP port 7070 is used for the bots, Kobalos in C&C mode\nwill also listen to 7071. This second port is used by the operator to control the C&C functionality,\nsuch as listing bots and establishing tunnels to them. This is outlined in Figure 15.\n\n\n-----\n\nTunnel after\nauthentication\n\nServer compromised\n\nTCP/7070 with Kobalos\n\nUse backdoor\naccess or TCP/7071\n\nOperator\n\nServer compromised TCP/7070 Server compromised\nwith Kobalos with Kobalos\n\nRunning C&C\nserver on port 7070\n\nServer compromised\nwith Kobalos\n\nFigure 15 // Operator of Kobalos reaching out to bots reporting to a C&C server\n\nTable 8 lists the commands to enable and manage the C&C server functionality.\n\n\nTable 8 _Commands for managing a Kobalos C&C server_\n\n\n_Command_ _Description_ _Parameters_\n\n0x21 Start a C&C server. TCP port to open for C&C server\n\nGet number of active connections and total\n0x23\nnumber of connections since C&C was started.\n\n0x25 List all bots ready for commands.\n\n0x29 Shutdown C&C server.\n\nIndex of bot to connect to in list of bots\n\n0x2B Establish connection to bot.\n\nAuthentication message (320 bytes)\n\nEstablish connection to bot without\n0x2D Index of bot to connect to in list of bots\nauthentication.\n\nCommands 0x23—0x2D are handled by the C&C server subprocess. As seen in Figure 16, when they are sent\non the active channel, the data is forwarded via TCP to the loopback interface of the control port (port used\nby bots plus one) of the C&C server.\n\nFigure 16 // Packets related to managing the C&C server forwarded to the subprocess via TCP\n\n\n-----\n\n###### Other commands\n\nEnvironment variables\n\nThere’s a command to set environment variables for the backdoor process (see Table 9). It takes a string\n[as a parameter and simply passes it to putenv, which expects the format “VAR=value”.](https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html)\n\n\nTable 9 _Other commands understood by Kobalos_\n\n\n_Command_ _Description_ _Parameters_\n\n0x0E Set environment variable in session. String to pass to putenv\n\nNo-op\n\nTwo other commands are implemented, but they do not perform any operations, as seen in Figure 17.\nWe see two possible explanations:\n\n- They were removed because they were used in previous versions and are no longer necessary.\n\n- They are platform-specific and do not apply to the Linux or FreeBSD variants of Kobalos we analyzed.\n\nFigure 17 // Commands 0x07 and 0x09 do not perform any operation\n\nThe latter explanation seems more likely, since we know strings for Solaris, AIX and Windows are present\n(see Encrypted strings).\n\n\n-----\n\n#### 5. OPENSSH CREDENTIAL STEALER\n\nOn most systems compromised by Kobalos, malware was also deployed to steal SSH credentials via\na trojanized SSH client. Different variants of these files were found, including Linux and FreeBSD instances.\nUnlike Kobalos, this credential stealer features almost no obfuscation.\n\nTheir main capabilities consist of stealing hostname, port, username and password used to establish an SSH\nconnection from the compromised host. They are saved into an encrypted file. Recent versions of this trojan\nalso feature the ability to exfiltrate credentials over the network via UDP, but this was not activated\nin the configuration of most of the samples we analyzed.\n\nAt the time we published our previous research on OpenSSH backdoors, “The dark side of the ForSSHE”,\nwe didn’t know about this credential stealer and it doesn’t correspond to any malware family we described\nin that paper. We also cannot map it to any other publicly documented OpenSSH credential stealer.\n\nThe location of the file where the stolen SSH credentials are saved varies depending on the variant.\nAll samples create a file under /var/run with a “.pid” extension. The “.pid” file extension is used for most\nof the legitimate files under /var/run. See the SSH credential stealer samples in the Indicators of compromise\nsection for example filenames and paths used in various samples.\n\nAll samples found use the same simple cipher for the contents of the files. As seen in Figure 18 it simply\nadds 123 to each byte of data to be saved.\n\nFigure 18 // Encrypting and writing SSH credentials to a file\n\nFor the FreeBSD version, the same format and cipher is applied. However, there are some small\nimplementation differences, such as encrypting the file path in the malware with a single-byte XOR.\n\n\n-----\n\n##### 5.1 An evolving malware family\n\nAfter we notified one of the victims, they found what seems to be a more recent version\nof the credential stealer.\n\nThis new version contains an encrypted configuration and adds the functionality to exfiltrate credentials\nover UDP to a remote host specified in the configuration. Exfiltrating credentials over UDP is something\nEbury and other SSH credential stealers such as Bonadan, Kessel and Chandrila have been doing. The choice\nof UDP could be to bypass a firewall and avoid creating TCP network flow to potentially untrusted hosts.\n\nIt can only use one exfiltration method, file or network, because the configuration holds the target\nhostname and file path in the same variable.\n\nFigure 19 shows the decompiled code responsible for sending data over UDP. Figure 20 is the\nconfiguration blob found in the sample. This sample was configured to write stolen credentials\nin /var/run/sshd/sshd.pid.\n\nFigure 19 // Malware sending credentials over UDP\n\nFigure 20 // Example configuration using a file to write stolen credentials\n\nInterestingly, the configuration includes the hostname of the victim. It is likely used by the operators\nto know the origin of the credentials. This also means that each compromised server receives a unique\nsample of the credential stealer.\n\n\n-----\n\n#### 6. CONCLUSION\n\nThe numerous well-implemented features and the network evasion techniques show the attackers\nbehind Kobalos are much more knowledgeable than the typical malware author targeting Linux and other\nnon-Windows systems. Their targets, being quite high profile, also show that the objective of the Kobalos\noperators isn’t to compromise as many systems as possible. Its small footprint and network evasion\ntechniques may explain why it went undetected until we approached victims with the results of our\ninternet-wide scan.\n\nOne of the questions we cannot answer is what the intentions of the attackers are. The actions that\nthe backdoor can perform are very generic and could be used for any purpose. No other malware, besides\nthe SSH password stealer, was found on the compromised machines, which we strongly suspect as the entry\npoint rather than the payload. According to system administrators of the compromised HPC systems,\nthere was no attempt to perform cryptocurrency mining or any other computationally expensive tasks.\nWhat are these attackers after?\n\nAnother thing we couldn’t determine is how long this malware has been in use. We found strings related\nto Windows 3.11 and Windows 95 – operating systems released more that 25 years ago. Did Kobalos variants\nexist for Windows and has this malware been around for such a long time? We know there were new\ncompromises in 2019 and 2020, but couldn’t find evidence of its usage before that time.\n\nEven though the authors of this malware seem knowledgeable about IP networking and the operating\nsystems they target, there are still a few weaknesses to Kobalos. First, there are issues with the cryptography,\nperhaps due to advances in the field if Kobalos actually is very old. Secondly, it’s possible to fingerprint\nvariants passively listening, especially if it requires a specific TCP source port. We successfully exploited\nthis flaw to find and notify victims in an effort to reduce the number of compromised hosts and better\nunderstand this newly discovered threat.\n\n_[We would like to acknowledge the work of Maciej Kotowicz from MalwareLab.pl who also analyzed Kobalos inde­](https://twitter.com/maciekkotowicz)_\n_[pendently and with whom we mutually share results. He presented on this threat at the Oh My H@ck 2020 conference.](https://omhconf.pl/lecture#id=63871)_\n\n\n-----\n\n#### 7. APPENDIX – INLINED FUNCTIONS IN KOBALOS\n\nValue Short Description Parameters Description\n\n\n1003 `INITIALIZE` socket, filter\n\n\nStart Kobalos using the given process\nif it matches a given filter (an integer\nfrom an enum).\n\n\nStart listening or connect to a C&C server\n1004 `START_LISTENING` none\nbased on malware configuration.\n\n1005 `START_C2_SERVER` socket_1, socket_2 Start the C&C server.\n\n\n1006 `SEND_PACKET`\n\n1007 `RECV_PACKET`\n\n\nsocket_fd, &channel_1,\n&channel_2, data,\ndata_len\n\nsocket_fd, &channel_1,\n&channel_2, data,\ndata_len\n\n\nSend Kobalos-encapsulated data\nto socket_fd.\n\nReceive a Kobalos-encapsulated packet\nfrom socket_fd.\n\n\nGet a random 32-bit integer. PRNG seeded\n1008 `GET_RANDOM_INT` returns random_int\nwith current time.\n\n\nout_buf, returns\n1009 `GET_HOST_INFO`\nbuf_len\n\n\nGet a buffer with hostname, IP address\nand running kernel version.\n\n\nSet SO_REUSEADDR and SO_KEEPALIVE\n1010 `SET_COMMON_SOCKOPT` socket\nto true and SO_LINGER to 15 seconds.\n\nRC4-decrypt the string str with the\n1011 `RC4_DECRYPT_STRING_INPLACE` str, len\nRC4 key from the malware configuration.\n\n\nwhat_to_close,\n1012 `CLEANUP_THINGS`\nsend_report\n\n\nBoth parameters are integers. Close\nsockets and free memory. Send report.\n\n\nInitialize the RC4 algorithm\n1013 `RC4_INIT` context, key_size, key\nwith the provided key.\n\ncontext, len, data_in,\n1014 `RC4_CRYPT` Perform RC4 encryption or decryption.\ndata_out\n\ninput, input_len,\n1015 `MD5` Compute MD5 hash.\noutput_digest\n\n1016\nAsymmetric cryptography related functions\nto 1037\n\n\ndata_in, data_out,\n1038 `RSA_PUBLIC_DECRYPT`\npublic_key\n\nkey_bin_data,\n1039 `LOAD_PUB_KEY`\npublic_key\n\n\nEncrypt or decrypt using the provided\npublic RSA key.\n\nLoad the public RSA key blob\nin key_bin_data to public_key.\n\n\n-----\n\n#### 8. INDICATORS OF COMPROMISE\n\n##### 8.1 ESET detection names\n\n- Linux/Kobalos\n\n- Linux/Agent.IV\n\n- Linux/SSHDoor.EV\n\n- Linux/SSHDoor.FB\n\n- Linux/SSHDoor.FC\n\n##### 8.2 Samples\n\n###### Kobalos\n\nSHA-1 Target OS Embedded in Reachability\n\nWait for connection\n`FBF0A76CED2939D1F7EC5F9EA58C5A294207F7FE` RHEL sshd\nfrom source port 55201\n\nConnects to\n`479F470E83F9A5B66363FBA5547FDFCF727949DA` Debian Stand-alone\n```\n                                           151.80.57[.]191:7070\n\n```\nWait for connection\n`AFFA12CC94578D63A8B178AE19F6601D5C8BB224` FreeBSD sshd\nfrom source port 55201\n\nWait for connection\n`325F24E8F5D56DB43D6914D9234C08C888CDAE50` Ubuntu sshd\nfrom source port 55201\n\nWait for connection\n`A4050A8171B0FA3AE9031E0F8B7272FACF04A3AA` Arch Linux sshd\nfrom source port 55201\n\n###### SSH credential stealer\n\nSHA-1 Target OS Writes to\n\n`6616DE799B5105EE2EB83BBE25C7F4433420DFF7` RHEL `/var/run/nscd/ns.pid`\n\n`E094DD02CC954B6104791925E0D1880782B046CF` RHEL `/var/run/udev/ud.pid`\n\n`1DD0EDC5744D63A731DB8C3B42EFBD09D91FED78` FreeBSD `/var/run/udevd.pid`\n\n`C1F530D3C189B9A74DBE02CFEB29F38BE8CA41BA` Arch Linux `/var/run/nscd/ns.pid`\n\n`659CBDF9288137937BB71146B6F722FFCDA1C5FE` Ubuntu `/var/run/sshd/sshd.pid`\n\n##### 8.3 Keys\n\n###### RSA public key\n```\n-----BEGIN PUBLIC KEY----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOUgD8sEF1kZ04QxCd60HrB+TxWnLQED\n\nwzb0sZ8vMMD6xnUAJspdYzSVDnRnKYjTOM43qtLNcJOwVj6cuC1uHHMCAwEAAQ==\n\n-----END PUBLIC KEY----\n Static RC4 key for strings\nAE0E05090F3AC2B50B1BC6E91D2FE3CE\n\n```\n\n-----\n\n##### 8.4 YARA rules\n```\nrule kobalos\n{\n  meta:\n    description = “Kobalos malware”\n    author = “Marc-Etienne M.Léveillé”\n    date = “2020-11-02”\n    reference = “http://www.welivesecurity.com”\n    source = “https://github.com/eset/malware-ioc/”\n    license = “BSD 2-Clause”\n    version = “1”\n  strings:\n    $encrypted_strings_sizes = {\n      05 00 00 00 09 00 00 00 04 00 00 00 06 00 00 00\n      08 00 00 00 08 00 00 00 02 00 00 00 02 00 00 00\n      01 00 00 00 01 00 00 00 05 00 00 00 07 00 00 00\n      05 00 00 00 05 00 00 00 05 00 00 00 0A 00 00 00\n    }\n    $password_md5_digest = { 3ADD48192654BD558A4A4CED9C255C4C }\n    $rsa_512_mod_header = { 10 11 02 00 09 02 00 }\n    $strings_RC4_key = { AE0E05090F3AC2B50B1BC6E91D2FE3CE }\n  condition:\n    any of them\n}\nrule kobalos_ssh_credential_stealer {\n  meta:\n    description = “Kobalos SSH credential stealer seen in OpenSSH client”\n    author = “Marc-Etienne M.Léveillé”\n    date = “2020-11-02”\n    reference = “http://www.welivesecurity.com”\n    source = “https://github.com/eset/malware-ioc/”\n    license = “BSD 2-Clause”\n    version = “1”\n  strings:\n    $ = “user: %.128s host: %.128s port %05d user: %.128s password: %.128s”\n  condition:\n    any of them\n}\n\n```\n\n-----\n\n#### 9. MITRE ATT&CK TECHNIQUES\n\n[This table was built using version 8 of the ATT&CK framework.](https://attack.mitre.org/versions/)\n\nTactic ID Name Description\n\n\nKobalos may embed its malicious payload\nin the OpenSSH server and replace the legitimate\nfile (sshd).\n\nKobalos replaces the SSH client on compromised\nsystems to steal credentials.\n\nKobalos may be triggered by an incoming\nTCP connection to a legitimate service from\na specific source port.\n\n\nPersistence\n\nDefense Evasion\n\nCommand\nAnd Control\n\n\nCompromise Client\n_[T1554](https://attack.mitre.org/versions/v8/techniques/T1554/)_\nSoftware Binary\n\n_[T1205](https://attack.mitre.org/versions/v8/techniques/T1205/)_ Traffic Signaling\n\n\nNo command history related to the attack\n_[T1070.003](https://attack.mitre.org/versions/v8/techniques/T1070/003)_ Clear Command History\nwas found on Kobalos-infected machines.\n\nWhen files are replaced by Kobalos operators,\n_[T1070.006](https://attack.mitre.org/versions/v8/techniques/T1070/006)_ Timestomp\ntimestamps are forged.\n\n\n_[T1027.002](https://attack.mitre.org/versions/v8/techniques/T1027/002)_ Software Packing\n\nEncrypted Channel:\n_[T1573.001](https://attack.mitre.org/versions/v8/techniques/T1573/001)_\nSymmetric Cryptography\n\nEncrypted Channel:\n_[T1573.002](https://attack.mitre.org/versions/v8/techniques/T1573/002)_\nAsymmetric Cryptography\n\n\nKobalos’s code is flattened into a single\nfunction using a custom packer and its strings\nare encrypted.\n\nKobalos’s post-authentication communication\nchannel is encrypted with RC4.\n\nKobalos’s authentication and key exchange\nis performed using RSA-512.\n\n\nKobalos can serve as a proxy to other\n_[T1090.003](https://attack.mitre.org/versions/v8/techniques/T1090/003)_ Proxy: Multi-hop Proxy\nKobalos-compromised systems.\n\n\n-----\n\n## About ESET\n\n[For more than 30 years, ESET® has been developing industry-leading IT security](http://www.eset.com/int/)\n\nsoftware and services to protect businesses, critical infrastructure and consumers\n\nworldwide from increasingly sophisticated digital threats. From endpoint and mobile\n\nsecurity to endpoint detection and response, as well as encryption and multifactor\n\nauthentication, ESET’s high-performing, easy-to-use solutions unobtrusively protect\n\nand monitor 24/7, updating defenses in real time to keep users safe and businesses\n\nrunning without interruption. Evolving threats require an evolving IT security\n\ncompany that enables the safe use of technology. This is backed by ESET’s R&D\n\ncenters worldwide, working in support of our shared future. For more information,\n\n[visit www.eset.com or follow us on LinkedIn, Facebook and Twitter.](https://www.eset.com/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "https://www.welivesecurity.com/wp-content/uploads/2021/01/ESET_Kobalos.pdf",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.02.02.Kobalos/ESET_Kobalos.pdf"
    ],
    "report_names": [
        "ESET_Kobalos.pdf",
        "ESET_Kobalos"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3844202f-b24a-4e16-b7b9-dfe8c0a44d5d",
            "created_at": "2022-10-25T16:07:24.526179Z",
            "updated_at": "2025-03-27T02:02:10.27234Z",
            "deleted_at": null,
            "main_name": "Operation Windigo",
            "aliases": [],
            "source_name": "ETDA:Operation Windigo",
            "tools": [
                "CDorked",
                "CDorked.A",
                "Calfbot",
                "Ebury"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1934b371-2525-4615-a90a-772182bc4184",
            "created_at": "2022-10-25T15:50:23.396576Z",
            "updated_at": "2025-03-27T02:00:55.460522Z",
            "deleted_at": null,
            "main_name": "Windigo",
            "aliases": [
                "Windigo"
            ],
            "source_name": "MITRE:Windigo",
            "tools": [
                "Ebury"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716498,
    "ts_updated_at": 1743041630,
    "ts_creation_date": 1611646463,
    "ts_modification_date": 1611646464,
    "files": {
        "pdf": "https://archive.orkl.eu/b3337c0f3226c009089da347f58b0611411dfbed.pdf",
        "text": "https://archive.orkl.eu/b3337c0f3226c009089da347f58b0611411dfbed.txt",
        "img": "https://archive.orkl.eu/b3337c0f3226c009089da347f58b0611411dfbed.jpg"
    }
}