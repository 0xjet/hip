{
    "id": "9d684712-f5ba-4a23-8c9a-6ba949792a49",
    "created_at": "2022-10-25T16:48:14.553339Z",
    "updated_at": "2025-03-27T02:09:07.986795Z",
    "deleted_at": null,
    "sha1_hash": "d093387297c46493c1f14b18b9fee8911b803e21",
    "title": "Wardle-VB2014.indd",
    "authors": "",
    "file_creation_date": "2014-10-21T15:05:10Z",
    "file_modification_date": "2014-10-21T15:05:10Z",
    "file_size": 4759053,
    "plain_text": "# METHODS OF MALWARE PERSISTENCE ON MAC OS X\n## Patrick Wardle Synack, USA\n\n Email patrick@synack.com\n\n ABSTRACT\n\nAs Mac OS X continues to increase in popularity, OS X malware\n(once a rare phenomenon) is now more common than ever.\nTherefore, it is essential for cybersecurity and malware analysts\nto possess an in-depth understanding of OS X and how it may be\nattacked by persistent, malicious code.\n\nThis paper presents a detailed analysis of Apple’s anti-malware\nmechanisms (revealing several signifi cant weaknesses), before\ndiving into the bowels of the Mac startup process. Here, points\nof persistence are detailed comprehensively. Following this,\nexamples of OS X malware are examined to illustrate how code\nmay abuse the OS in order to achieve reboot persistence.\n\nFinally, a novel open- source tool is discussed that can enumerate\nand display persistent OS X binaries that are set to execute\nautomatically upon reboot. Armed with such a tool, users can\nensure that they are protected against both current and future\npersistent OS X threats.\n\n## BACKGROUND\n\nBefore diving into methods of persistence abused by OS X\nmalware, it is important to understand why such a topic is truly\nrelevant.\n\nAs is obvious to even the most naïve amongst us, Macs have\nbecome more prevalent than ever. According to a recent study by\nthe International Data Corporation (IDC), Apple is now the\nnumber three US computer vendor, making up almost 15% of\ncomputer sales [1]. Moreover, if ‘iDevices’ (iPhones, iPads, etc.)\nare added to the equation, Apple devices\noutsold Windows PCs globally in Q4 of 2013\n\n[2].\n\nOne of the driving forces behind the\nincreased adoption of Apple computers is\nthe notion that OS X is immune to malware.\nThis claim was propagated by Apple, who\nclaimed ‘[Mac OS X] doesn’t get PC\nviruses. A Mac isn’t susceptible to the\nthousands of viruses plaguing\n_Windows-based computers’ [3]._\n\nIronically, the fi rst personal computer virus\ndiscovered in the wild (Elk Cloner), was a\nMac virus that infected Apple IIs [4]. Since\nthen, Mac malware has fl ourished. Just last\nyear, over 30 new OS X malware families\nwere discovered, some infecting the\ncorporate systems of companies such as\n_Apple, Facebook, and Twitter [5, 6]._\n\n\n_Figure 1: Mac’s growth 2009–2013._\n\n## APPLE’S ANTI-MALWARE ENHANCEMENTS AND THEIR FLAWS\n\nIn recent versions of OS X, Apple has introduced a myriad of\nsecurity enhancements which aim to thwart malware. Examples\nof these enhancements include: XProtect (Apple’s built-in\nanti-virus solution), Gatekeeper (which verifi es downloaded\nsoftware), sandboxing (which prevents Mac Store applications\nfrom accessing OS-level components), and signed-code\nrequirements (where signatures are verifi ed and only signed\nkernel extensions can be loaded). While these are spun by\n_Apple’s marketing team as proactive security measures, in reality_\nthey are more reactive and act as an acknowledgement of the\n_OS X malware problem. Moreover, while they are a step in the_\nright direction, many of these security enhancements are trivial\nto bypass.\n\n## XProtect\n\n_Apple’s attempt at an anti-virus product is internally referred to as_\n_XProtect. Implemented within the CoreServicesUIAgent, it uses_\nsignatures from /System/Library/CoreServices/CoreTypes.bundle/\nContents/Resources/XProtect.plist to detect OS X malware.\n\nFigure 2 shows an entry from the XProtect signature fi le.\n\n_Figure 2: XProtect’s signature for LaoShu.A._\n\n\n-----\n\nThe highlighted entry in Figure 2 aims to detect the\nOSX/LaoShu.A malware by matching a SHA1 hash and a\nfi lename (‘worty’). While the benefi t of such an exact match/\ndetection scheme is zero false positives, there are several major\ndownsides. For one, a slight change in the malware (the renaming\nof a fi le, or a recompilation to change the hash), will prevent a\nmatch, and thus detection, from being made. The malware will\nremain undetected and will be able to execute. Another obvious\ndownside to XProtect’s signature-based malware detection\nscheme is that new malware will never be detected.\n\nBesides the weaknesses in the detection scheme used by\n_XProtect, it is plagued by other design issues. In its current_\nimplementation, XProtect only scans binaries that contain a\nquarantine attribute. This attribute is set by the application that\ndownloaded the binary (e.g. a browser), not the OS. This is\nproblematic, as an exploit-based attack that manually downloads\nmalware will, of course, do so without setting the quarantine\nattribute. As such, these binaries will not be scanned, allowing\ndownloaded malware to execute without fear of detection.\n\n## Gatekeeper\n\nAccording to Apple, Gatekeeper helps protect Macs from\nmalicious apps that are downloaded and installed from the\nInternet [6].\n\n_Figure 3: Gatekeeper in action._\n\nContrary to popular belief, Gatekeeper (like XProtect), is fairly\nlimited in the attacks it can prevent. Specifi cally, it is limited to\nonly preventing attacks where users are coerced into\ndownloading and installing malicious content (e.g. fake Flash\ninstallers or ‘media plug-ins’), from infected or rogue websites.\nThis is due to the fact that Gatekeeper will only examine\nbinaries that contain a quarantine attribute. As previously\nmentioned, this attribute must be set by the downloading\napplication. Thus binaries downloaded as the result of a\n‘drive-by’ exploit-based attack will not be subjected to\nexamination. Interestingly, this is precisely how employees of\n_Apple, Facebook and Twitter were recently infected by malware_\nwhich ‘bypassed OS X Gatekeeper protection’ [7].\n\nAnother shortcoming is based on the fact that, in its default\nconfi guration, Gatekeeper may allow any signed application to\n\n\nexecute. Hence if a malware sample is signed with a valid Apple\nDeveloper ID (code-signing certifi cate), it may be able to\n‘bypass the Gatekeeper security feature’ [8].\n\n## Signed applications\n\nBorrowing from iOS, OS X now verifi es all binary signatures.\nThis is important as it allows the OS to verify that binaries have\nnot been subverted (e.g. infected by a virus). Binary infection is a\npowerful technique as it affords an attacker a way to persist, hide,\nand inherit trust. For example, imagine a malicious piece of code\nthat infects Safari. Every time the user launches Safari, the\nmalicious code is also executed (persistence). Since the malicious\ncode may exist solely within the infected binary, no external\nmalicious fi les or processes are required (stealth). Finally, as the\nbrowser is expected to access network resources, malicious code\nhosted within its process space should also be able to access the\nnetwork (inheriting trust), even if a personal fi rewall is installed.\n\nSo what happens if malware infects a signed application or\nbinary? Well, when loading signed binaries (or applications),\nthe OS loader will check the digital signature. Any\nmodifi cations will invalidate this signature, easily allowing the\nloader to detect any subversions. By design, the OS loader will\nthen immediately terminate (crash) the modifi ed binary.\n\n_Figure 4: OS X loader terminating a modifi ed signed_\n_application._\n\nOn OS X (unlike iOS), unsigned apps are allowed to execute\nfreely. During the loading process, the OS loader checks\nwhether the binary is signed by looking for an embedded\nLC_CODE_SIGNATURE block. If it fi nds one, it verifi es the\nbinary’s signature. However, research has revealed that if the\nLC_CODE_SIGNATURE signature block is removed, the\nloader performs no verifi cations, allowing the binary to be\nmodifi ed with no consequences. This is a rather big security\nissue, as any signed application can be unsigned, then infected\nwith viral code, and will still be allowed to execute.\n\nTo illustrate this security weakness, a python script (unsign.py)\nwas created to ‘unsign’ and infect Apple’s signed applications.\nThe script is shown in Figure 5.\n\n_Figure 5: Unsigning (and modifying) an Apple signed_\n_application._\n\n\n-----\n\nAs shown in Figure 4, Safari was previously terminated when\nthe OS loader detected a modifi cation. However, as Figure 5\nillustrates, once unsigned, Safari, can be modifi ed, and still able\nto execute without interference or termination.\n\n## Signed kernel extensions\n\nIn order to protect the kernel from malicious code (i.e. rootkits),\nall kernel extensions (or ‘kexts’) are required to be signed on\n_OS X Mavericks. An unsigned or modifi ed kext will fail to load._\nUnfortunately for Apple, it turns out that this anti-malware\nmechanism is trivial to bypass. The fi rst method of bypassing\nthese code-signing requirements is described in [9]. In a\nnutshell, the user-mode daemon that loads kernel extensions\n(kextd) is responsible for verifying the signature. Yes, the\nsignature is verifi ed in user mode – fail! This is clearly a\nsecurity issue, since it means that an attacker can easily subvert\n(turn off) the user-mode checks, then load any unsigned kext. As\ndescribed in [9], this can be accomplished by injecting code into\nthe kextd, then patching out the code-signing checks (in the\ncheckKextSignature() function). For illustrative purposes, this\ncan also be accomplished via a debugger, as shown in Figure 6.\n\n_Figure 6: Patching out kext code-signing requirements._\n\nThe publicly described technique requires some pretty low-level\nhacking (e.g. code injection and in-memory patching). Research\nperformed at the start of the year revealed a non-public, 0-day\ntechnique that allowed any unsigned kext to be loaded[1]. By fi rst\nstopping the daemon that is responsible for loading kernel\nextensions (kextd), then attempting to load the unsigned kext\nwith the kextload command, an alternate code path is executed.\nThis code path loads the kext directly into the kernel, bypassing\nthe logic that enforces the kext code-signing requirements.\n\nIn the case of computer security, ignorance is not bliss. The\nvarious weaknesses in the OS X anti-malware/security\nmechanisms presented above should be a cause for concern for\nthe ever-growing Mac user base, especially as OS X malware is\nan ever-growing threat. One way to combat such threats is to\ngain a thorough understanding of the Mac system startup\nprocess, identifying methods of persistence that are abused by\n\n1 This technique (or a slight variation) was later discussed independently\nat Black Hat Asia by Team T5 [10].\n\n\n_OS X malware. With this information, persistent malware may_\nbe detected generically or, ideally, even prevented.\n\n## MAC SYSTEM STARTUP\n\nBefore cataloguing methods of persistence abused by OS X\nmalware, it is important to understand what happens when a\nMac is powered on.\n\nThe boot/startup process is somewhat complex, but can be\nbroken down into easily understandable stages. These stages\ninclude power-on/boot, kernel initialization, the execution of\nlaunchd daemon, and the LoginWindow process. It should be\nnoted that many of the low-level technical details of the startup\nprocess are beyond the scope of this paper. However, interested\nreaders are encouraged to consult [11] for a very comprehensive\nand thorough discussion of the entire startup process.\n\nEarly startup covers everything from power-on, until the kernel\n(OS X) begins execution. Once power is present, the bootROM\ntakes over. The bootROM, or fi rmware, is the fi rst code to\nexecute. It verifi es memory, begins hardware initialization and\nselects the OS partition. Once complete, the bootROM executes\nthe boot.efi program. This performs a variety of actions such as\ninitializing the device tree (IO registry), locating and loading the\nkernel into memory, loading any boot kernel extensions, and\nfi nally jumping to the kernel’s entry point.\n\nOnce the early boot stage is complete, OS X begins its\ninitialization. This starts with the kernel, which is composed of\nvarious sub-systems (each of which must be initialized). First,\nthe Mach subsystem is initialized, then IOKit loads all\ndevice-specifi c kexts. Finally, the BSD subsystem initializes,\nwhich most notably includes executing launchd, the fi rst\nuser-mode process.\n\nLaunchd, as its name suggests, launches all daemons and agents\n(both of which are somewhat conceptually similar to Windows\nservices). As the fi rst process (pid of 0x1), it is an ancestor of all\nother processes.\n\nThe fi nal step before reaching the desktop is authenticating the\nuser. This is handled by the LoginWindow process, which\nauthenticates the user, sets up their environment, and then hangs\naround to manage the user’s session. Once the user is presented\nwith their desktop, the Mac system startup process is complete.\n\n## METHODS OF PERSISTENCE\n\nA decent understanding of the Mac startup process provides the\nnecessary background for examining the ways in which it may\nbe abused to achieve persistence. Before diving in, recall that\npersistence is essential for malware, as it ensures that whenever\na computer is restarted, the malicious code is automatically\nre-executed by the OS.\n\n## Low-level/pre-OS X\n\nStarting at the lowest level, there are several options for\npersistence. While these options are complex, and often\nhardware specifi c, they run ‘below’ (before) the OS, and thus\nare very diffi cult to detect. Possible low-level options for\npersistence may include: re-fl ashing the fi rmware, installing a\n\n\n-----\n\nmalicious EFI component, or even infecting boot.efi . It should\nbe noted that, due to the complexities of these techniques, each\ncould fi ll a paper unto themselves. For a more in-depth analysis\nof low-level methods of persistence, interested readers should\nconsult [12], an intriguing paper on Mac EFI rootkits.\n\n## Kernel extensions\n\nSince code in the kernel runs at the highest privilege level, it is\na great place for advanced malware to live. Malware that\nexecutes here is often referred to as a rootkit. It is fairly trivial\nto create a persistent kernel extension that will automatically\nbe executed by the OS whenever the computer is restarted.\nFirst, a kext can be created via the ‘Generic Kernel Extension’\ntemplate in XCode, as described in Apple’s documentation\n\n[13]. It is important to set the kext’s match category (in its\nInfo.plist) to ‘IOResources.’ As described in [11], this is ‘a\nspecial provider class that provides system-wide resources’\nand ensures that, once installed, the kext will automatically be\nstarted by OS X.\n\nTo install a kext persistently, it should be copied into one of the\n_OS X kext directories: /System/Library/Extensions or /Library/_\nExtensions.\n\nOnce copied to an install directory, the kext should be set to be\nowned by root and, optionally, the kernel cache rebuilt. If these\nsteps are followed, the kext will automatically be loaded each\ntime the OS is (re)loaded.\n\n_Figure 7: Installing a persistent kernel extension._\n\nAs mentioned previously, starting with OS X Mavericks, kext\nextensions must be signed. However, malware may abuse\nseveral previously stated methods in order to bypass this\nrequirement.\n\n## Launch daemons/agents\n\nWhile code that runs in the kernel is very powerful, it is diffi cult\nto get right. Running in user mode is far simpler and thus often\npreferable. Launch daemons and agents are the\n‘Apple-approved’ way to persist non-application binaries (e.g.\nsoftware updaters, anti-virus products, etc.). Both launch\ndaemons and launch agents are commonly abused by OS X\nmalware as a means to gain persistence. Launch daemons are\nnon-interactive, and run before user login. On the other hand,\nlaunch agents run once the user has logged in, and may be\ninteractive. Creating a persistent launched daemon or agent is as\nsimple as creating the binary, then placing a confi guration\nproperty list in one of the launch daemon or agent directories, as\nshown in Table 1.\n\nProperty lists (or ‘plists’ in Apple parlance) are xml fi les that are\nused by OS X to store serialized objects. In the case of the\nlaunch daemons and agents, there is a plist for each daemon or\n\n|Launch daemon (plist) directories|Launch agent (plist) directories|\n|---|---|\n|/System/Library/ LaunchDaemons|/System/Library/ LaunchAgents|\n|/Library/LaunchDaemons|/Library/LaunchAgents and ~/Library/LaunchAgents|\n\n\n_Table 1: Launch daemon/agent plist directories._\n\nagent that contains required confi guration information. These\nfi les are processed by the OS as part of its initialization process\nand can contain key value pairs that may instruct the OS to\nautomatically start the daemon or agent. Figure 8 shows a\nsnippet from an example launch daemon/agent confi guration\nplist fi le. Besides containing the path to the binary image of the\ndaemon or agent (and any program arguments), it also contains\na key value pair (RunAtLoad: true), to indicate that it should be\nstarted automatically by the OS.\n\n_Figure 8: A launch daemon/agent plist._\n\n## Cron jobs\n\nContaining a large amount of BSD code and logic within its\ncore, OS X presents many ‘Unix-y’ fl avoured persistence\nmechanisms that may be abused by OS X malware. Cron jobs\nare an example of exactly this. OS X supports cron jobs, which\ncan be used to execute a command or script at certain\nintervals. For example, Figure 9 illustrates how a cron job can\nbe created to echo some text each minute. To register the cron\njob, the command to execute is saved to fi le, then registered\nvia the crontab command. To confi rm the registration of the\ncommand, the crontab command is re-executed with the ‘-l’\nparameter.\n\n_Figure 9: Cron job creation/enumeration._\n\n## Login/logout hooks\n\nBy creating a login or logout hook, a script or command can\nautomatically be executed whenever a user logs in or out. Apple\nstates that these hooks are deprecated [14], but they still work\n\n\n-----\n\non OS X Mavericks. The ‘defaults’ command can be used to\ncreate such a hook. Simply specify a write action, the\ncom.apple.loginwindow.plist fi le, and then script or command to\npersist (see Figure 10).\n\n_Figure 10: Creation of a login hook._\n\n## Login items\n\nFor applications, login items are the ‘Apple-approved’ way to\npersist. Anything that’s registered as a login item is visible in a\nGUI, via the System Preferences app. Login items are stored\nin the user’s Library/Preferences directory, in a plist fi le\nnamed com.apple.loginitems.plist. This fi le contains an entry\nfor each login item, which contains the name of the item,\nwhether it should be hidden, and base64-encoded data\ncontaining the path to the persistent application. Login items\ncan be created via the GUI, programmatically by utilizing the\n‘launch services’ API, or by directly manipulating the login\nitem’s plist (com.apple.loginitems.plist).\n\n_Figure 11: Login item: in the GUI and plist._\n\n\n## Sandboxed login items\n\nWith the introduction of the application sandbox, applications\ndownloaded from the Mac application store can no longer create\nor register themselves as traditional login items. To maintain\ncompatibility, Apple designed a new way in which sandboxed\napplications could create login items. In order to register an\napplication persistently in this manner, two applications are\nrequired: a main application and a helper. The application to\npersist (the helper), should be placed into a LoginItems\nsub-directory of the main application, as shown in Figure 12.\n\n_Figure 12: Required layout for a sandboxed login item._\n\nOnce executed, the main application should invoke the\nSMLoginItemSetEnabled() function. This function causes the\nhelper application to persist, and ensures that it will\nautomatically be executed whenever the user logs in.\n\n_Figure 13: Code to persist a sandboxed login item._\n\n## Re-opened applications\n\n_OS X recently introduced a feature that automatically reopens_\napplications whenever the user (re)logs in. The applications to\nreopen are stored in a plist within the user’s Library/\nPreferences/ByHost directory. Viewing the contents of this plist\nreveals keys such as the ID of the application, whether to hide it,\n\n_Figure 14: Plist entry of a re-launched application_\n_(terminal.app)._\n\n\n-----\n\nand of course the path to the application. While there is not a\n(documented) programmatic API to manipulate the re-opened\napplication plist directly, it may be possible to modify it directly\nin order to gain persistence.\n\n## Startup items\n\nAnother deprecated technique that still works on OS X\n_Mavericks is ‘startup items’. Apple documentation explains that_\nstartup items allow a command or script to automatically be\nexecuted during OS X initialization. Creating a startup item\ninvolves placing two fi les into a startup item directory. The fi rst\nfi le is a script that is to be executed automatically. The other fi le\nmust be named ‘StartupParameters.plist’ and must contain a\n‘Provides’ key that contains the name of the script fi le. Both of\nthese fi les should be placed in a sub-directory in either the\n/System/Library/StartupItems or /Library/StartupItems\ndirectory. The name of the sub-directory must be the same as\nthe name of the script fi le (and the value of the ‘Provides’ key in\nthe StartupParameters.plist). Figure 15 illustrates the required\nfi le-system layout of a startup item.\n\n_Figure 15: Directory structure of a startup item._\n\n## Rc.common\n\nRC scripts are used in another BSD-fl avoured persistence\ntechnique that works on OS X, allowing scripts or commands to\nautomatically be executed. For example, the rc.common fi le can\nbe edited to insert arbitrary commands that will automatically\nexecute when OS X starts.\n\n_Figure 16: Injecting commands into rc.common._\n\n## Launchd.conf\n\nRecall that launchd is the fi rst user-mode program to execute\nduring OS X’s initialization. The launchd.conf fi le, as its name\nsuggests, contains confi guration parameters for launchd. As\nlaunchd.conf can contain arbitrary commands (via the bsexec\ncommand), malware can inject malicious instructions in order to\nachieve persistence.\n\n_Figure 17: Injecting commands into launched.conf._\n\n\n## DYLD_INSERT_LIBRARIES\n\nVia the DYLD_INSERT_LIBRARIES environment variable,\n_OS X provides a way to load arbitrary dynamic libraries_\n(‘dylibs’) into a process. Specifi cally, when loading a process,\nthe dynamic loader will examine the DYLD_INSERT_\nLIBRARIES variable and load any libraries it specifi es. By\nabusing this technique, an attacker can ensure that a malicious\nlibrary will persistently be loaded into a targeted process\nwhenever that process is started.\n\nThere are two main ways to set the DYLD_INSERT_\nLIBRARIES environment variable so that arbitrary libraries will\nbe loaded into a specifi c (targeted) process. When targeting a\nlaunch daemon or agent, an ‘EnvironmentVariables’ dictionary\nmay be added to launch item’s plist. For targeting an\napplication, the application’s Info.plist can be altered to contain\na ‘LSEnvironment’ dictionary, see Figure 18.\n\n_Figure 18: The application’s Info.plist is altered to contain a_\n_‘LSEnvironment’ dictionary._\n\n## Mach-O binary infection\n\nComputer viruses are one of the oldest forms of malware.\nViruses infect fi les by injecting viral code in order to replicate.\nHowever, this viral code can also provide persistence: any time\nthe infected binary is executed, the virus code will be executed\nas well. Since OS X binaries (and applications) can be unsigned,\nviral infection may be back in fashion! There are many ways to\ninfect an OS X (mach-O) binary. The simplest method,\ndescribed initially by the (in)famous VX’er roy g biv, involves\ninjecting some viral code into a target binary, then hijacking the\nentry point to point to the virus code.\n\nFigure 19 shows the LC_MAIN load command within an\nuninfected macho-O binary. This load command contains the\n‘Entry Offset,’ or entry point, which may be hijacked during\ninfection (to point to the viral code).\n\n_Figure 19: Mach-O binary structure/entry offset._\n\n\n-----\n\n## Application-specifi c persistence\n\nThe fi nal persistence mechanism covered in this paper is more\nof a generic class: application-specifi c persistence. Many\napplications (such as browsers) support plug-ins, which are\ngenerally dynamic libraries that are loaded automatically when\nthe application is run. While plug-ins can legitimately extend\nthe functionality of an application, malware can abuse this\nfunctionality to gain persistence. Applications that may be\nsubverted include browsers such as Safari, Firefox and Chrome,\nor others such as iTunes [15].\n\nIt should be noted that sometimes it may be challenging to\ncoerce an application to execute a malicious plug-in (it might\nload the plug-in, then decide it doesn’t like it). However, if the\npersistent plug-in exports a constructor (see Figure 19), it will\nautomatically be executed (by the OS loader) as soon as it is\nloaded. Thus, even if the host application rejects the plug-in, it\nis too late as persistent code execution has already been\nachieved.\n\n_Figure 20: Dynamic library (plug-in) constructor._\n\n## Rest in peace\n\nWhile researching methods of malware persistence, several\npreviously functional persistence techniques were found to\nhave either been fully deprecated or removed in OS X\n\n\n_Mavericks. These include modifying environment.plist,_\nmodifying com.apple.SystemLoginItems.plist and setting an\n‘AutoLaunchedApplicationDictionary’ within the /Library/\nPreferences/loginwindow fi le.\n\nWhile these methods of persistence are (or were?) common in\nolder OS X malware samples, they are likely to fade into\noblivion as they no longer work on the latest version of OS X.\n\n## PERSISTENT OS X MALWARE\n\nWhile not all of the methods of persistence presented are (yet)\nabused by OS X malware, many are. The following section\nexamines several OS X malware samples and reveals their\npersistence mechanisms.\n\n## OSX/CallMe\n\nA few years ago, somebody (likely the Chinese government),\nstarted targeting Tibetan activists with malicious Word\ndocuments that attempted to exploit CVE-2009-0563. The\npayload of these attacks was named OSX/CallMe [16]. This\nmalware was fairly basic, providing the attackers with the\nability to execute arbitrary commands on an infected host, as\nwell as exfi ltrating the victim’s contacts (address book) [17].\nIn order to persist, CallMe installs itself as an auto launched\nlaunch daemon. Specifi cally, it creates a launch daemon plist,\nrealPlayerUpdate.plist, within the /Library/LaunchDaemons\ndirectory that references the malware’s binary,\n.realPlayerUpdate (see Figure 21).\n\n## OSX/Flashback\n\nFlashback shattered the notion that OS X was immune to\nmalware. By exploiting a known, but unpatched Java\nvulnerability, Flashback was able to automatically infect users\nas they visited a compromised or malicious website. At its\nheight, it amassed over 600,000 infected hosts, making it the\nmost ‘successful’ OS X malware to date [18]. Flashback’s goal\n\n\n_Figure 21: CallMe’s launch daemon persistence._\n\n\n-----\n\nwas simply fi nancial gain – by injecting ads into users’ web\nsessions. To ensure it was (re)executed each time an infected\ncomputer was rebooted, it installed itself as a user launch agent\n(com.java.update.plist, .jupdate). (See Figure 22.)\n\n## OSX/Crisis\n\nAccording to online sources, OSX/Crisis is ‘an expensive\nrootkit used by governments’ [19]. Delivered via targeted\nexploits, it provides extensive surveillance capabilities by\ncollecting audio, images, screenshots and keystrokes. Crisis also\nemploys some fairly sophisticated stealth capabilities via a\nrootkit (kernel) component that can hide processes and fi les.\nFigure 23 illustrates some pseudo-disassembly, revealing the\nmalware building a path to a fi le within the user’s launch agent\ndirectory. In other words, the disassembly shows the malware\npreparing to persist as a launch agent.\n\n## OSX/Janicab\n\nJanicab is a somewhat unique OS X malware sample, as it is\nwritten in Python (though compiled for distribution). The\nmalware is also signed with an Apple Developer ID, probably in\nan attempt hide its maliciousness and thwart Gatekeeper. Since\nit is written in Python, the malware is easy to analyse and\nuncovering its persistence mechanism is trivial. As may be seen\nin the malware installer’s code, a cron job (set to execute every\nminute) is created to ensure that the malware is persisted (see\nFigure 24). It should be noted that once the malware is installed,\nthe crontab -l command easily reveals the malicious cron job.\n\n## OSX/Kitmos\n\nKitmos is another OS X malware sample that targets activists.\nDiscovered on an activist’s computer during the Oslo Freedom\nForum Workshop, Kitmos takes screenshots and uploads them\nto a remote command and control server [20]. As the\ndisassembly in Figure 25 shows, the malware invokes the\nLSSharedFileListInsertItemURL() function to add itself as a\nlogin item for the current user. Once registered as a login item,\nthe malware will automatically be (re)executed by the OS\nwhenever the user logs in.\n\n\n_Figure 22: Flashback’s launch agent persistence._\n\n_Figure 23: Crisis’ launch agent persistence._\n\n_Figure 24: Janicab’s cron job persistence._\n\n\n_Figure 25: Kitmos’ login item persistence._\n\n\n-----\n\n_Figure 26: Yontoo’s browser extension(s) persistence._\n\n_Figure 27: Renepo’s startup item persistence._\n\n_Figure 28: MacProtector’s login item persistence._\n\n\n## OSX/Yontoo\n\nIt is fairly common for malware to use social engineering\ntricks to coerce the user into infecting themselves. Yontoo\nmasquerades as an ‘HD video codec’ to trick users who visit\ncompromised or malicious websites into installing the\nmalware. The malware creates malicious plug-ins for Safari,\n_Firefox and Chrome. This allows the malware to automatically_\nbe executed whenever the user launches their browser. Once\nloaded into the context of the browser’s process content, the\nplug-ins transmit information about the loaded pages to a\nremote server as well as injecting ads into the user’s browsing\nsession (see Figure 26).\n\n## OSX/Renepo\n\nRenepo is an older OS X malware sample that disables security\nmechanisms before downloading and executing other ‘hacker\ntools’ such as password crackers [21]. Since this malware is a\nscript (which helpfully includes comments), it is easy to\nunderstand its installation and persistence logic. As shown in\nFigure 27, it persists as a startup item.\n\n## OSX/MacProtector\n\nMacProtector is a fake (or ‘rogue’) anti-virus product. When a\nuser visits a compromised or malicious website, MacProtector\ntries to convince the user that their computer is infected and that\nthey should download an application to ‘fi x’ it [22].\nUnfortunately, if the user allows the downloaded installer to\ncomplete, they become infected with MacProtector. Reverse\nengineering this malware reveals that it installs itself as a login\nitem. Though this will cause the malware to persist, it will also\nmake it appear in the GUI (as well as in the login item’s plist).\n(See Figure 28.)\n\n## OSX/Clapzok\n\nThe previously discussed OS X malware samples are generally\nall stand- alone binaries or applications. OSX/Clapzok bucks this\ntrend: it is a classic virus that infects binaries both to spread and\nto gain persistence [23]. It works by injecting viral code into a\nbinary, then hijacking the entry point. However, since Clapzok\ninfects signed apps (without un-signing them), it will likely\n\n\n_Figure 29: Clapzok’s mach-O infection persistence [23]._\n\n\n-----\n\ncause major annoyances and, as a result, will be easily\ndiscovered (see Figure 29).\n\n## KNOCKKNOCK\n\nResearch into persistence mechanisms on OS X has revealed\nmany locations within the boot process and OS startup sequence\nthat can be abused by malicious code. As we have shown in this\npaper, many OS X malware variants exist in the wild that are\nabusing several of these persistence mechanisms. Although\n_Apple has introduced several anti-malware mitigations, these_\nclearly fall short, as OS X users worldwide continue to be\ninfected.\n\nIn order to generically detect persistent OS X malware, a new\ntool has been created that can enumerate and display persistent\n_OS X binaries. Named KnockKnock, its goal is simple: to tell_\nyou who’s there! Armed with this tool, users can ensure that\nthey are protected against both current and future OS X threats.\n\nThere are many methods of persistence on OS X – and new ones\nare sure to be found. As such, the open-source, Python-based\n_KnockKnock [24] was designed to use a plug-in-based_\narchitecture, where each plug-in can scan for a particular\npersistence technique. When new persistence techniques are\ndiscovered, KnockKnock can easily be extended with new plugins. Luckily, as its core performs most of the work, writing a\nplug-in is incredibly simple. This is illustrated in the example in\nFigure 30, which shows the main logic for a plug-in that\nenumerates all launch daemons that are set to execute\nautomatically as a Mac computer boots up.\n\nAs the code snippet in Figure 30 illustrates, it only takes about\n10 lines of Python code for this plug-in to enumerate a specifi c\npersistence class. (For more details, including a comprehensive\nplug-in-writing guide, see [24].)\n\n_KnockKnock has the ability to display persistent OS X binaries_\nthat are set to execute automatically at each boot. Since\n_KnockKnock takes such an unbiased approach, it can generically_\ndetect persistent OS X malware today, as well as in the future. It\nshould be noted though, that this approach will also list\nlegitimate binaries. However, as KnockKnock can fi lter out\n\n\n_Figure 31: KnockKnock Janicab (runner.pyc) detection._\n\n_Figure 32: KnockKnock CallMe (.realPlayerUpdate) detection._\n\nunmodifi ed Apple-signed binaries, the output is reduced by a\nfactor of roughly 90%, generally leaving a handful of binaries\nthat can quickly be examined and verifi ed manually.\n\nThe screenshots in Figures 31 and 32 show KnockKnock\nrevealing various OS X malware infections, including\nOSX/Janicab (cron job) and OSX/CallMe (launch daemon).\n\n## CONCLUSION\n\nEven in the latest version of Mac _OS X, Apple’s anti-malware_\nmitigations fall far short, allowing OS X malware to become an\never more pervasive reality. However, by thoroughly\n\n\n_Figure 30: KnockKnock launch daemon plug-in._\n\n\n-----\n\nunderstanding the Mac’s startup process, points of persistence\ncan be identifi ed, which allow for the generic detection of\nmalware. KnockKnock, an open-source tool, aims to aid in this\ndetection and to ensure that everyday users are protected against\nboth current and future OS X threats.\n\n## REFERENCES\n\n[1] IDC Worldwide Quarterly PC Tracker, 9 January 2014.\nhttp://www.idc.com/getdoc.jsp?containerId=prUS2459\n5914.\n\n[2] Apple passing Microsoft. http://ben-evans.com/\nbenedictevans/2014/2/12/apple-passes-microsoft.\n\n[3] Apple homepage. 2012. http://www.apple.com/.\n\n[4] Ször, P. The Art of Computer Virus Research and\nDefense. Symantec Press. 2005.\n\n[5] F-Secure Threat Report, H1 2013. http://www.f-secure.\ncom/static/doc/labs_global/Research/Threat_Report_\nH1_2013.pdf.\n\n[6] OS X: About Gatekeeper. http://support.apple.com/kb/\nht5290.\n\n[7] Mac malware that infected Facebook bypassed OS X\nGatekeeper protection. http://arstechnica.com/\nsecurity/2013/03/mac-malware-that-infected-facebookbypassed-os-x-gatekeeper-protection/.\n\n[8] Researchers fi nd more versions of digitally signed Mac\nOS X spyware. http://www.macworld.com/\narticle/2039640/researchers-fi nd-more-versions-ofdigitally-signed-mac-os-x-spyware.html.\n\n[9] Breaking OS X signed kernel extensions with a NOP.\nhttp://reverse.put.as/2013/11/23/breaking-os-x-signedkernel-extensions-with-a-nop.\n\n[10] You can’t see me. http://www.blackhat.com/docs/asia14/materials/Tsai/Asia-14-Tsai-You-Cant-See-Me-AMac-OS-X-Rootkit-Uses-The-Tricks-You-HaventKnown-Yet.pdf.\n\n[11] Levin, J. Mac OS X and iOS Internals: To the Apple’s\nCore. Wrox. 2012.\n\n[12] DE MYSTERIIS DOM JOBSIVS Mac EFI Rootkits.\nhttp://ho.ax/De_Mysteriis_Dom_Jobsivs_Black_Hat_\nPaper.pdf.\n\n[13] Creating a Device Driver with Xcode. https://developer.\napple.com/library/mac/documentation/Darwin/\nConceptual/KEXTConcept/KEXTConceptIOKit/iokit_\ntutorial.html#//apple_ref/doc/uid/20002366.\n\n[14] Customizing Login and Logout. https://developer.apple.\ncom/library/mac/documentation/macosx/conceptual/\nbpsystemstartup/chapters/CustomLogin.html.\n\n[15] iTunes Evil Plugin Proof of Concept. http://reverse.put.\nas/2014/02/15/appledoesntgiveafuckaboutsecurityitunes-evil-plugin-proof-of-concept/.\n\n[16] New Targeted Attack on Tibetan Activists Using OS X\nDiscovered. http://www.intego.com/mac-security-blog/\nnew-targeted-attack-on-tibetan-activists-using-os-xdiscovered/.\n\n\n\n[17] New CallMe malware discovered. http://www.\nthesafemac.com/new-callme-malware-discovered/.\n\n[18] Kaspersky Lab confi rms Flashfake/Flashback botnet\ninfected more than 600,000 Mac OS X Computers.\nhttp://www.kaspersky.com/about/news/virus/2012/\nKaspersky_Lab_Confi rms_Flashfake_Flashback_\nBotnet_Infected_more_than_600_000_Mac_OS_X_\nComputers_Describes_Ramifi cations_and_Remedies.\n\n[19] New OSX/Crisis or Business Cards Gone Wild.\nhttp://www.intego.com/mac-security-blog/new-osxcrisis-business-cards-gone-wild/.\n\n[20] OSX Kitmos analysis. http://blog.sbarbeau.fr/2013/05/\nosx-kitmos-analysis.html.\n\n[21] Renepo worm targets Mac OS X users, Sophos reports.\nhttp://www.sophos.com/en-us/press-offi ce/pressreleases/2004/10/va_renepo.aspx.\n\n[22] Mac Security Threats: How Vulnerable Is Apple?\nhttp://content.time.com/time/business/\narticle/0,8599,2075218,00.html.\n\n[23] Clapzok.A: reversing the OS X part of a multiplatform\nPoC infector. http://reverse.put.as/2013/05/31/clapzoka-reversing-the-os-x-part-of-a-multiplatform-pocinfector/.\n\n[24] KnockKnock. https://github.com/synack/knockknock.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf"
    ],
    "report_names": [
        "VB2014-Wardle.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041347,
    "ts_creation_date": 1413903910,
    "ts_modification_date": 1413903910,
    "files": {
        "pdf": "https://archive.orkl.eu/d093387297c46493c1f14b18b9fee8911b803e21.pdf",
        "text": "https://archive.orkl.eu/d093387297c46493c1f14b18b9fee8911b803e21.txt",
        "img": "https://archive.orkl.eu/d093387297c46493c1f14b18b9fee8911b803e21.jpg"
    }
}