{
    "id": "47b43cf0-a160-4c3f-8559-ef676bfe0b83",
    "created_at": "2023-01-12T15:03:49.470339Z",
    "updated_at": "2025-03-27T02:16:59.194931Z",
    "deleted_at": null,
    "sha1_hash": "508e860c1d92ba3cc84f075ec204b8be1f8d67de",
    "title": "2021-03-24 - APT Encounters of the Third Kind",
    "authors": "",
    "file_creation_date": "2022-05-27T21:40:12Z",
    "file_modification_date": "2022-05-27T21:40:12Z",
    "file_size": 1634003,
    "plain_text": "# APT Encounters of the Third Kind\n\n**igor-blue.github.io/2021/03/24/apt1.html**\n\n18 minute read\n\n\nMarch 24, 2021\n\n\nA few weeks ago an ordinary security assessment turned into an incident response\nwhirlwind. It was definitely a first for me, and I was kindly granted permission to outline the\nevents in this blog post. This investigation started scary but turned out be quite fun, and I\nhope reading it will be informative to you too. I'll be back to posting about my hardware\nresearch soon.\n\n## How it started\n\nTwice a year I am hired to do security assessments for a specific client. We have been\nworking together for several years, and I had a pretty good understanding of their network\nand what to look for.\n\nThis time my POC, Klaus, asked me to focus on privacy issues and GDPR compliance.\nHowever, he asked me to first look at their cluster of reverse gateways / load balancers:\n\nI had some prior knowledge of these gateways, but decided to start by creating my own test\nenvironment first. The gateways run a custom Linux stack: basically a monolithic compiled\nkernel (without any modules), and a static GOlang application on top. The 100+ machines\nhave no internal storage, but rather boot from an external USB media that has the kernel and\n\n\n-----\n\nthe application. The GOlang app serves in two capacities: an `init replacement and the`\nreverse gateway software. During initialization it mounts /proc, /sys, devfs and so on, then\nmounts an NFS share hardcoded in the app. The NFS share contains the app's\nconfiguration, TLS certificates, blacklist data and a few more. It starts listening on 443, filters\nincoming communication and passes valid requests on different services in the production\nsegment.\n\nI set up a self contained test environment, and spent a day in black box examination. Having\nfound nothing much I suggested we move on to looking at the production network, but Klaus\ninsisted I continue with the gateways. Specifically he wanted to know if I could develop a\nmethodology for testing if an attacker has gained access to the gateways and is trying to\naccess PII (Personally Identifiable Information) from within the decrypted HTTP stream.\n\nI couldn't SSH into the host (no SSH), so I figured we will have to add some kind of\ninstrumentation to the GO app. Klaus still insisted I start by looking at the traffic before (red)\nand after the GW (green), and gave me access to a mirrored port on both sides so I could\ncapture traffic to a standalone laptop he prepared for me and I could access through an LTE\nmodem but was not allowed to upload data from:\n\n\n-----\n\nThe problem I faced now was how to find out what HTTPS traffic corresponded to requests\nwith embedded PII. One possible avenue was to try and correlate the encrypted traffic with\nthe decrypted HTTP traffic. This proved impossible using timing alone. However, unspecting\nthe decoded traffic I noticed the GW app adds an 'X-Orig-Connection' with the four-tuple of\nthe TLS connection! Yay!\n\n\n-----\n\nI wrote a small python program to scan the port 80 traffic capture and create a mapping from\neach four-tuple TLS connection to a boolean - True for connection with PII and False for all\nothers:\n```\n10.4.254.254,443,[Redacted],43404,376106847.319,False\n10.4.254.254,443,[Redacted],52064,376106856.146,False\n10.4.254.254,443,[Redacted],40946,376106856.295,False\n10.4.254.254,443,[Redacted],48366,376106856.593,False\n10.4.254.254,443,[Redacted],48362,376106856.623,True\n10.4.254.254,443,[Redacted],45872,376106856.645,False\n10.4.254.254,443,[Redacted],40124,376106856.675,False \n...\n\n```\nWith this in mind I could now extract the data from the PCAPs and do some correlations.\nAfter a few long hours getting `scapy to actually parse timestamps consistently enough for`\ncomparisons, I had a list of connection timing information correlated with PII. A few more fun\nhours with Excel and I got histogram graphs of time vs count of packets. Everything looked\nnormal for the HTTP traffic, although I expected more of a normal distribution than the\npower-low type thingy I got. Port 443 initially looked the same, and I got the normal\ndistribution I expected. But when filtering for PII something was seriously wrong. The\ndistribution was skewed and shifted to longer time frames. And there was nothing similar on\nthe port 80 end.\n\n\n-----\n\nMy only explanation was that something was wrong with my testing setup (the blue bars) vs.\nthe real live setup (the orange bars). I wrote on our slack channel 'I think my setup is sh*t,\ncan anyone resend me the config files?', but this was already very late at night, and no one\nresponded. Having a slight OCD I couldn’t let this go. To my rescue came another security?\nfeature of the GWs: Thet restarted daily, staggered one by one, with about 10 minutes\nbetween hosts. This means that every ten minutes or so one of them would reboot, and thus\nreload it’s configuration files over NFS. And since I could see the NFS traffic through the port\nmirror I had access to, I recokoned I could get the production configuration files from the\nNFS capture (bottom dotted blue line in the diagram before).\n\nSo to cut a long story short I found the NFS read reply packet, and got the data I need. But\n… why the hack is `eof 77685??? Come on people, its 3:34AM!`\n\nWhat's more, the actual data was 77685 bytes, exactly 8192 bytes more then the ‘Read\nlength’. The entropy for that data was pretty uniform, suggesting it was encrypted. The file I\nhad was definitely not encrypted.\n\n\n-----\n\nHistogram of extra 8192 bytes:\n\nWhen I mounted the NFS export myself I got a normal EOF value of `1 !`\n\n\n-----\n\n## What hell is this?\n\nComparing the capture from my testing machine with the one from the port mirror I saw\nsomething else weird:\n\n\n-----\n\nFor other NFS open requests (on all of my test system captures and for other files in the\nproduction system) we get:\n\nSpot the difference?\n\nThe `open id: string became` `open-id: . Was I dealing with some corrupt packet? But the`\nexact same problem reappeared the next time `blacklist.db was send over the wire by`\nanother GW host.\n\nTime to look at the kernel source code:\n\nThe “open id” string is hardcoded. What's up?\n\nAfter a good night sleep and no beer this time I repeated the experiment and convincing\nmyself I was not hullucinating I decided to compare the source code of the exact kernel\nversion with the kernel binary I got.\n\nWhat I expected to see was this (from nfs4xdr.c):\n\n\n-----\n\n```\nstatic inline void encode_openhdr(struct xdr_stream xdr, const struct nfs_openargs\n*arg)\n{\n  __be32 *p;\n /*\n * opcode 4, seqid 4, share_access 4, share_deny 4, clientid 8, ownerlen 4,\n * owner 4 = 32\n */\n  encode_nfs4_seqid(xdr, arg->seqid);\n  encode_share_access(xdr, arg->share_access);\n  p = reserve_space(xdr, 36);\n  p = xdr_encode_hyper(p, arg->clientid);\n  *p++ = cpu_to_be32(24);\n  p = xdr_encode_opaque_fixed(p, \"open id:\", 8);\n  *p++ = cpu_to_be32(arg->server->s_dev);\n  *p++ = cpu_to_be32(arg->id.uniquifier);\n  xdr_encode_hyper(p, arg->id.create_time);\n}\n\n```\nRunning `binwalk -e -M bzImage I got the internal ELF image, and opened it in IDA. Of`\ncourse I didn’t have any symbols, but I got `nfs4_xdr_enc_open() from /proc/kallsyms, and`\nfrom there to `encode_open() which led me to` `encode_openhdr() . With some help from`\nhex-rays I got code that looked very similiar, but with one key difference:\n```\nstatic inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs\n*arg)\n{\n  ...\n  p = xdr_encode_opaque_fixed(p, unknown_func(\"open id:\", arg), 8);\n  ...\n}\n\n```\nThe function `unknown_func was pretty long and complicated but eventually sometimes`\ndecided to replace the space between 'open' and 'id' with a hyphen.\n\nDoes the NFS server care? Apparently this string it is some opaque client identifier that is\nignored by the NFS server, so no one would see the difference. That is unless they were\ntrying to extract something from an NFS stream, and obviously this was not a likely scenario.\nOK, back to the weird 'eof' thingy from the NFS server.\n\n## The NFS Server\n\nThe server was running the 'NFS-ganesha-3.3' package. This is a very modular user-space\nNFS server that is implemented as a series of loadable modules called FSALs. For example\nsupport for files on the regular filesystem is implemented through a module called\n```\nlibfsalvfs.so . Having verified all the files on disk had the same SHA1 as the distro\n\n```\npackage, I decided to dump the process memory. I didn't have any tools on the host, so I\nused GDB which helpfully was already there. Unexpectadly GDB was suddenly killed, the file\nI specified as output got erased, and the nfs server process restarted.\n\n\n-----\n\nI took the dump again but there was nothing special there!\n\nI was pretty suspicious at this time, and wanted to recover the original dump file from the first\ndump. Fortunately for me I was dumping the file to the laptop, again over NFS. The file had\nbeen deleted, but I managed to recover it from the disk on that server.\n\n## 2nd malicious binary\n\nThe memory dump was truncated, but had a corrupt version of NFS-ganesha inside. There\nwere two `libfsalvfs.so libraries loaded: the original one and an injected SO file with the`\nsame name. The injected file was clearly malicious. The main binary was patched in a few\nplaces, and the function table into `libfsalvfs.so as replaced with the alternate`\n```\nlibfsalvfs.so . The alternate file was compiled from NFS-ganesha sources, but modified\n\n```\nto include new and improved (wink wink) functionality.\n\nThe most interesting of the new functionality were two separate implementations of covert\nchannels.\n\nThe first one we encountered already:\n\nWhen an open request comes in with 'open-id' instead of 'open id', the file handle is\nmarked. This change is opaque to the NFS server, so unpatched servers just ignore it\nand nothing much happens.\nFor infiltrated NFS server, when the file handle opened this way is read, the NFS server\nappends the last block with a payload coming from the malware's runtime storage, and\nthe 'eof' on-the-wire value is changed to be the new total size. An unpatched kernel\n(which shouldn’t really happen, since it marked the file in the first place) will just ignore\nthe extra bytes. The EOF value is used as a bool, e.g. checked for 0 or not and not a\nspecific value, so having a large integer values doesn’t change anything in the flow of\nan unmodified kernel.\n\nThe second covert channel is used for command and control, and is implemented in the VFS\ncode as a fake directory.\n\nAny writes to `/<export>/.snapshot/meta/<cmdid> are handled by the malware code and`\nnot passed on to the FS. They are pseudo-files that implement commands through read and\nwrite operations.\n\nThe malware implemented the following commands:\n\n1701 - self destruct\n1702 - set auto self destruct time\n1703 - run shell command\n1704 - load SO file from buffer specified in command\n1706 - get basic system description\n\n\n-----\n\n1707 - get network connections\n170A - upgrade to new SO file\n74201 - put buffer in memory dict by ID\n74202 - get buffer from memory dict by ID\n74650 - put a payload in memory for the first covert channel\n74651 - arm the first covert channel\n74652 - disarm the first covert channel\n\nFor example `cp payload.so /mnt/server/.snapshot/meta/1704 will load the SO file in`\nthe NFS ganesha process on the target server, and `echo 1616580589 >`\n```\n/mnt/server/.snapshot/meta/1702 will set an autodestruct time. Reading this file will\n\n```\nretrieve the time.\n\nThe self destruct command (0x1701) is very interesting - it sends a UDP broadcast on port\n41701 with a random payload of size 321 bytes, and then restarts a clean NFS-ganesha. I\nguess this is some kind of network signalling.\n\nIt appears the malware has a watchdog that iterates over all `/proc/<pid>/fd/* links`\nevery 25ms, and if a link is open to `/proc/<malware pid>/maps or` `/proc/<malware`\n```\npid>/smaps or /proc/<malware pid>/mem it:\n\n```\nkills the offending process,\ndeletes any writeable file handle it had opened (before it was killed) in\n```\n   /proc/<pid>/fd/, first trying to wipe it,\n\n```\ncalls the self destruct command (0x1701).\n\n## Further forensics\n\nLets go back to that awful Saturday I triggered the self-destruct. Having a faint understanding\nI triggered something (that being before I reversed the devil) I asked Klaus to disconnect all\nthe network connections to the outer world and we started taking memory dumps of\nwhatever we could, storing them all on the laptop. In hindsight we destroyed quiet a bit of\nevidence by triggering more self destructs in other subnets, but I think the self destruct signal\nhas already gone out to the bad guys through a different piece of malware that I later partially\nrecovered, and probably \"heard\" the UDP distress signal (that's what is was called in the\nbinary, not my naming).\n\nAfter getting all the forensics the client insisted on reconnecting his systems to the web, they\nwere \"losing money\". I switched from forensics to reversing. In the process, while inspecting\nthe malicious `libfsalvfs.so I discovered the commands I mentioned above, and`\ndiscovered a \"feature\" that helped me fill more paces of the puzzle.\n\n\n-----\n\nReversing malware you always find some feeble attempt to obfuscate string using XOR or\nRC4, or just scrambling the letter ordering. In this case I pretty quickly found a function I\ncalled `get_obfuscated_string(buffer, string_id) . The difference however, was that`\nthis one was just horrendous, practically irreversible:\n\nIt had like a billion nested switches:\n\n\n-----\n\nI think they let some intern fresh out of college write that one. It seems the complete list of\nstrings used by the tool are encoded inside in a tree of nested switches, with a variable\nlength encoding, e.g. in one branch the 2nd level might have 3 bits and in another it might\nhave 5 and in a third only a single bit. Some kind of prefix tree if I remember anything from\nUni.\n\n\n-----\n\nEventually I managed to write code to just brute force the function:\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string>\n#include <set>\nint main(int argc, char* argv[])\n{\n     // error handling code omitted\n     const char* filename = (argc > 1) ? argv[1] : \"reconstructed.elf\";\n     unsigned long offset = (argc > 1) ? strtol(argv[2], NULL, 16) : 0x22a0;\n     int fd = open(filename, O_RDONLY);\n     struct stat stbuf;\n     fstat(fd, &stbuf);\n     const char* addr = (char*)mmap(NULL, stbuf.st_size, PROT_READ | PROT_EXEC,\nMAP_PRIVATE, fd, 0);\n     close(fd);\n     const char* base = addr + offset;\n     typedef int (*entry_t)(char* outbuf, int id);\n     entry_t entry = (entry_t)base;\n     std::set<std::string> found;\n     char buffer[1024];\n     for(long bits = 1; bits < 64; ++ bits) {\n          bool any_new = false;\n          for(long id = (bits == 1) ? 0 : (1 << (bits - 1)); id < (1<<bits); ++\nid) {\n              int status = entry(buffer, id);\n              if(status == 0)\n                   continue;\n              if(found.find(buffer) != found.end())\n                   continue;\n              found.insert(buffer);\n              printf(\"Got '%s'! [0x%x]\\n\", buffer, id);\n              any_new = true;\n          }\n          if(!any_new)\n              break;\n     }\n     return 0;\n}\n\n```\nThis first binary had the following strings (I am keeping 3 to myself as they have client related\ninfo):\n\n\n-----\n\n```\n /proc/self/mem, \n'/proc/self/maps',\n'/proc/self/cwd',\n'/proc/self/environ',\n'/proc/self/fd/%d',\n'/proc/self/fdinfo/%d',\n'/proc/self/limits',\n'/proc/self/cgroup',\n'/proc/self/exe',\n'/proc/self/cmdline',\n'/proc/self/mounts',\n'/proc/self/smaps',\n'/proc/self/stat',\n'/proc/%d/mem', \n'/proc/%d/maps',\n'/proc/%d/cwd',\n'/proc/%d/environ',\n'/proc/%d/fd/%d',\n'/proc/%d/fdinfo/%d',\n'/proc/%d/limits',\n'/proc/%d/cgroup',\n'/proc/%d/exe',\n'/proc/%d/cmdline',\n'/proc/%d/mounts',\n'/proc/%d/smaps',\n'/proc/%d/stat',    \n'nfs',\n'nfs4',\n'tmpfs',\n'devtmpfs',\n'procfs',\n'sysfs',\n'WSL2',\n'/etc/os-release',\n'/etc/passwd',\n'/etc/lsb-release',\n'/etc/debian_version',\n'/etc/redhat-release',\n'/home/%s/.ssh',\n'/var/log/wtmp',\n'/var/log/syslog',\n'/var/log/auth.log',\n'/var/log/cron.log',\n'/var/log/syslog.log',\n'/etc/netplan/*.yaml',\n'/etc/yp.conf',\n'/var/yp/binding/',\n'/etc/krb5.conf',\n'/var/kerberos/krb5kdc/kdc.conf',\n'/var/log/ganesha.log',\n'/etc/ganesha/ganesha.conf',\n'/etc/ganesha/exports',\n'/etc/exports',\n'Error: init failed',\n'DELL',\n\n```\n\n-----\n\n```\n /usr/lib/x86_64 linux gnu/libnfs.so.4,\n'/tmp/.Test-unix/.fa76c5adb8c04239ff3034106842773b',\n'Error: config missing',\n'Error: sysdep missing',\n'Running',\n'LOG',\n'/usr/lib/x86_64-linux-gnu/ganesha/libfsalvfs.so',\n'none',\n'/etc/sudoers',\n'/proc/net/tcp',\n'/proc/net/udp',\n'/etc/selinux/config',\n'libdl.so.2',\n'libc-',\n'.so',\n'cluster-config',\n'recovery-signal',\n\n## Eureka Moment\n\n```\nStaring endlessly at this weird function I thought to myself: maybe I can look for code that is\nstructured like this in all the dumps we obtained. We have all those block of `mov byte ptr`\n```\n[rdi+?], '?' :\n\n```\nSo lets look for blocks of code that are highly dense with these opcodes:\n\n\n-----\n\n```\nimport sys\nwith open(sys.argv[1], 'rb') as f:\n  data = f.read()\nSTATE=None\nfor i in range(len(data) - 6):\n  if ord(data[i]) == 0xc6 and ord(data[i + 1]) == 0x47:\n    if STATE and (STATE[0] + STATE[1] + 0x40) >= i:\n      STATE[1] = i - STATE[0]\n      STATE[2] += 1\n    else:\n      if STATE and STATE[2] >= 20:\n        print('Found region at 0x%x - 0x%x' % (STATE[0], STATE[0] +\nSTATE[1]))\n      STATE = [i, 4, 1] \n\n```\nAnd I found them. Oh I did. Some adjustment even led to a version for ARM systems:\n\n\n-----\n\n## The GOlang thingy\n\nI finally found the payload that was sent over to the GW machines. It had 2 stages: the first\nwas the 8192 buffer loaded through the first covert channel. The kernel was modified to\ninject this buffer into the GOlang application and hook it. This will get fairly technical, but I\nenjoyed it and so will you:\n\nFirst note that in the Golang stdlib an HTTP connection can be read through the\n```\n   net/http.(connReader).Read function. The calls are made through a io.Reader\n\n```\ninterface, so the calls are made through a virtual table, and the call locations cannot be\nstatically identified.\nthe kernel inject begins by allocating a bunch of RWX memory immediately after the\nGOlang binary - let's call it the trampoline area, and it will include two types of\ngenerated trampoline functions,\nNext the ELF symbol table was used to find the 'net/http.(*connReader).Read' symbol,\nWhat we’ll call the 1st trampoline function (code below) is copied to the trampoline\narea, patching the area marked with `HERE with the first 9 bytes of` `net/http.`\n\n```\n(\\*connReader).Read\n\n```\n```\nmprotect(net_http_connReader_read & ~0xfff, 8192, PROT_EXEC |\n\n```\n```\n   PROT_READ | PROT_WRITE)\n\n```\nmodified the beginning of `net/http.(\\*connReader).Read to a near jump into the`\ntrampoline - using 5 bytes of the 9 original used by 'move rcx, fs:….' that are the\npreamble to function.\n\nFirst trampoline function\n```\n   pop   rax      \n   pop   rcx\n   push  rcx\n   push  rax\n   mov   r11, cs:qword_<relocated>\n   mov   rdi, rcx\n   call  qword ptr [r11+8]\n   pop   rax\n   pop   rcx\n   push  rcx\n   mov   rcx, fs:0FFFFFFFFFFFFFFF8h <---- HERE\n   cmp   rsp, [rcx+10h]\n   jmp   rax\n\n```\nWhen the trampoline is called (from the new near jump in the beginning of `net/http.`\n```\n   (*connReader).Read ) it examines the stack to locate the return address, and checks\n\n```\nif a second type of trampoline we'll refer to as the return trampoline has already been\nallocated for the return address for the function,\nIf not it allocates a new trampoline per call location of `net/http.`\n```\n   (*connReader).Read from the code below, replacing 123456789ABCDEFh with the\n\n```\nabsolute address of a function in the malware,\n\n\n-----\n\nGOlang uses memory for all function argument passing, so immediately after the virtual\nfunction call to `Read() there will always be a 5 byte` `mov reg, [rsp+?] to load`\n```\n   Read() 's result into a register. This mov instruction is copied into the first db 5\n   dup(0) area,\n\n```\nthose same 5 bytes are then replacing with a near jump to the 2nd trampoline\nthe 2nd db 5 dup(0) are filled with a relative near `jmp back to the original code patch`\nsite.\n```\n     mov   rax, 123456789ABCDEFh\n     mov   rdi, rsp\n     call  rax\n     db 5 dup(0)\n     db 5 dup(0)   \n\n```\nThis way eventually all the `net/http.(*connReader).Read call sites are patched to call a`\nfunction immediatly after `net/http.(*connReader).Read virtual call returns. This lets the`\nmalicous code inspect the decoded HTTP packet.\n\nOn initialization the 1st stage malware also loads the hefty 2nd stage through the 2nd covert\nchannel, and passes each buffer received from the patch on `net/http.`\n```\n(*connReader).Read to it for inspection. The data collected is collected and compressed by\n\n```\nthe malware and stored back to the NFS server (the 2nd covert channel which bypasses\nread ACLs on NFS).\n\nBefore this case I did not think there was any nice way to hook random GO binaries, this\ntechnique is pretty cool.\n\nUnfortunatly I cannot discuss what the 2nd payload actually as it will reveal stuff my\nemployer isn't ready for yet.\n\n## How the kernel got patched? and why not the golang app?\n\nThe golang app is built inside the CI/CD network segment. This segment can only be\naccessed through monitored jump hosts with MFA. Each day, the CI/CD pipline clones the\nsource code from the GIT server, builds it, and automatically tests it in a pre-production\nsegment. Once tested it gets digitally signed and uploaded to the NFS server. The running\napp self updates, checking the digital signature beforehand.\n\nThe kernel, on the other hand, is manually built by the guy responsible for it on his own\nlaptop. He then digitally signs it and stores it on a server where it is used by the CI/CD\npipeline. Fortunatly for us a commented out line in a script in the CI/CD pipline (a line that\nwas not commented out in the GIT!) did not delete old versions of the kernel and we know\nwhich versions were tampered with.\n\n\n-----\n\nWe noticed a 3 month gap about 5 month ago, and it corresponded with the guy moving the\nkernel build from a Linux laptop to a new Windows laptop with a VirtualBox VM in it for\ncompiling the kernel. It looks as if it took the attackers three months to gain access back into\nthe box and into the VM build.\n\n## What we have so far\n\nWe found a bunch of malware sitting in the network collecting PII information from incoming\nHTTPS connection after they are decoded in a GOlang app. The data is exfiltrated through\nthe malware network and eventually is sent to the bad guys. We have more info but I am still\nworking on it, expect another blog post in the future with more details, samples, etc’.\n\n## Q&A\n\n**Q: What was the initial access vector?**\n\n**A: We have a pretty good idea, but I cannot publish it yet (RD and stuff). Stay tuned!**\n\n**Q: Why didn't you upload anything to VT yet?**\n\n**A: A few reasons:**\n\nI need to make sure no client info is in the binaries - some of the binaries have\nhardcoded strings that cannot be shared\nAll of the binaries I have have been reconstructed from memory dumps, so are\nnot in their original form. Does anyone know how to upload partial dumps into\nVT?\n**Q: It there a security vulnerability in GO? in the Kernel?**\n\n**A: Defenitly not! this is just an obnoxious attacker doing what obnoxious attacker do. I**\nmight even say the complexity of the stuff means they don’t have a 0day for this\nplatform.\n\n**Q: What about YARA rules, C2 address, etc'?**\n\n**A: Wait for it, there is a lot more coming!**\n\n**Q: Why did you publish instead of collecting more?**\n\n**A: To quote the client \"I don't care who else they are attacking. I just want them off my**\nlawn!\", and he thinks publishing will prevent them from returning to THIS network.\nHopefully what we publish next time will get them off other people’s lawns.\n\n**Q: Any Windows malware?**\n\n**A: Definitly, including what we believe is an EDR bypass. Still working on it.**\n\n\n-----\n\n**Q: Any zero days?**\n\n**A: Maybe …**\n\n**Q: Who are these bad guys you keep refering to?**\n\n**A: No clue. Didn’t find anything similiar published. There is now sure way to make**\nanything except unsubstantiated guesses, and I won’t do that.\n\n**To be continued.**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-24 - APT Encounters of the Third Kind.pdf"
    ],
    "report_names": [
        "2021-03-24 - APT Encounters of the Third Kind.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dabb6779-f72e-40ca-90b7-1810ef08654d",
            "created_at": "2022-10-25T15:50:23.463113Z",
            "updated_at": "2025-03-27T02:00:55.47619Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "APT1",
                "Comment Crew",
                "Comment Group",
                "Comment Panda"
            ],
            "source_name": "MITRE:APT1",
            "tools": [
                "Seasalt",
                "ipconfig",
                "Cachedump",
                "PsExec",
                "GLOOXMAIL",
                "Lslsass",
                "PoisonIvy",
                "WEBC2",
                "Mimikatz",
                "gsecdump",
                "Pass-The-Hash Toolkit",
                "Tasklist",
                "xCmd",
                "pwdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "cf7fc640-acfe-41c4-9f3d-5515d53a3ffb",
            "created_at": "2023-01-06T13:46:38.228042Z",
            "updated_at": "2025-03-27T02:00:02.775905Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "GIF89a",
                "G0006",
                "PLA Unit 61398",
                "Group 3",
                "TG-8223",
                "Comment Group",
                "ShadyRAT",
                "COMMENT PANDA",
                "Comment Crew",
                "Byzantine Candor",
                "Brown Fox"
            ],
            "source_name": "MISPGALAXY:APT1",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535829,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1653687612,
    "ts_modification_date": 1653687612,
    "files": {
        "pdf": "https://archive.orkl.eu/508e860c1d92ba3cc84f075ec204b8be1f8d67de.pdf",
        "text": "https://archive.orkl.eu/508e860c1d92ba3cc84f075ec204b8be1f8d67de.txt",
        "img": "https://archive.orkl.eu/508e860c1d92ba3cc84f075ec204b8be1f8d67de.jpg"
    }
}