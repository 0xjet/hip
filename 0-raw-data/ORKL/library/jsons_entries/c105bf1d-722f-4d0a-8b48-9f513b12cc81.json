{
    "id": "c105bf1d-722f-4d0a-8b48-9f513b12cc81",
    "created_at": "2023-01-12T14:59:16.699123Z",
    "updated_at": "2025-03-27T02:05:58.786147Z",
    "deleted_at": null,
    "sha1_hash": "4a3004c9fed91d69cb9352687c94bc3aecd1d6db",
    "title": "2020-04-07 - Thinking Outside the Bochs- Code Grafting to Unpack Malware in Emulation",
    "authors": "",
    "file_creation_date": "2022-05-27T21:09:21Z",
    "file_modification_date": "2022-05-27T21:09:21Z",
    "file_size": 1760608,
    "plain_text": "# Thinking Outside the Bochs: Code Grafting to Unpack Malware in Emulation\n\n**[fireeye.com/blog/threat-research/2020/04/code-grafting-to-unpack-malware-in-emulation.html](https://www.fireeye.com/blog/threat-research/2020/04/code-grafting-to-unpack-malware-in-emulation.html)**\n\n## Threat Research Blog\n\nApril 07, 2020 | by [Michael Bailey](https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/michael-bailey)\nThis blog post continues the FLARE script series with a discussion of patching IDA Pro\ndatabase files (IDBs) to interactively emulate code. While the fastest way to analyze or\nunpack malware is often to run it, malware won’t always successfully execute in a VM. I use\n[IDA Pro’s Bochs integration in IDB mode to sidestep tedious debugging scenarios and get](https://www.hex-rays.com/wp-content/uploads/2019/12/debugging_bochs.pdf)\nquick results. Bochs emulates the opcodes directly from your IDB in a Bochs VM with no OS.\n\nBochs IDB mode eliminates distractions like switching VMs, debugger setup, neutralizing\nanti-analysis measures, and navigating the program counter to the logic of interest. Alas,\nwhere there is no OS, there can be no loader or dynamic imports. Execution is constrained\nto opcodes found in the IDB. This precludes emulating routines that call imported string\nfunctions or memory allocators. Tom Bennett’s [flare-emu ships with emulated versions of](https://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html)\nthese, but for off-the-cuff analysis (especially when I don’t know if there will be a payoff), I\nprefer interactively examining registers and memory to adjust my tactics ad hoc.\n\n\n-----\n\nWhat if I could bring my own imported functions to Bochs like flare-emu does? I ve devised\nsuch a technique, and I call it code grafting. In this post I’ll discuss the particulars of statically\nlinking stand-ins for common functions into an IDB to get more mileage out of Bochs. I’ll\ndemonstrate using this on an EVILNEST sample to unpack and dump next-stage payloads\nfrom emulated memory. I’ll also show how I copied a tricky call sequence from one IDB to\nanother IDB so I could keep the unpacking process all in a single Bochs debug session.\n\n**EVILNEST Scenario**\n\nMy sample (MD5 hash 37F7F1F691D42DCAD6AE740E6D9CAB63 which is available on\n[VirusTotal) was an EVILNEST variant that populates the stack with configuration data before](https://www.virustotal.com/gui/file/dda11fe201d188ea32020cda0eac130651bb0ff1f8991c2f73820d8a0b9e6242/details)\ncalling an intermediate payload. Figure 1 shows this unusual call site.\n\nFigure 1: Call site for intermediate payload\n\nThe code in Figure 1 executes in a remote thread within a hollowed-out iexplore.exe\nprocess; the malware uses anti-analysis tactics as well. I had the intermediate payload stage\nand wanted to unpack next-stage payloads without managing a multi-process debugging\nscenario with anti-analysis. I knew I could stub out a few function calls in the malware to run\nall of the relevant logic in Bochs. Here’s how I did it.\n\n**Code Carving**\n\nI needed opcodes for a few common functions to inject into my IDBs and emulate in Bochs. I\nbuilt simple C implementations of selected functions and compiled them into one binary.\nFigure 2 shows some of these stand-ins.\n\n\n-----\n\nFigure 2: Simple implementations of common functions\n\nI compiled this and then used IDAPython code similar to Figure 3 to extract the function\nopcode bytes.\n\nFigure 3: Function extraction\n\nI curated a library of function opcodes in an IDAPython script as shown in Figure 4. The\nnonstandard function opcodes at the bottom of the figure were hand-assembled as tersely as\npossible to generically return specific values and manipulate the stack (or not) in\n\n\n-----\n\nconformance with calling conventions.\n\nFigure 4: Extracted function opcodes\n\nOn top of simple functions like memcpy, I implemented a memory allocator. The allocator\nreferenced global state data, meaning I couldn’t just inject it into an IDB and expect it to\nwork. I read the disassembly to find references to global operands and templatize them for\nuse with Python’s format method. Figure 5 shows an example for malloc.\n\n\n-----\n\nFigure 5: HeapAlloc template code\n\nI organized the stubs by name as shown in Figure 6 both to call out functions I would need to\npatch, and to conveniently add more function stubs as I encounter use cases for them. The\nmangled name I specified as an alias for free is operator delete.\n\nFigure 6: Function stubs and associated names\n\nTo inject these functions into the binary, I wrote code to find the next available segment of a\ngiven size. I avoided occupying low memory because Bochs places its loader segment below\n0x10000. Adjacent to the code in my code segment, I included space for the data used by\n\n\n-----\n\nmy memory allocator. Figure 7 shows the result of patching these functions and data into the\nIDB and naming each location (stub functions are prefixed with stub_).\n\nFigure 7: Data and code injected into IDB\n\nThe script then iterates all the relevant calls in the binary and patches them with calls to their\nstub implementations in the newly added segment. As shown in Figure 8, IDAPython’s\nAssemble function saved the effort of calculating the offset for the call operand manually.\nNote that the Assemble function worked well here, but for bigger tasks, Hex-Rays\nrecommends a dedicated assembler such as [Keystone Engine and its](http://www.keystone-engine.org/) [Keypatch plugin for](http://www.keystone-engine.org/keypatch/)\nIDA Pro.\n\nFigure 8: Abbreviated routine for assembling a call instruction and patching a call site to an\nimport\n\n\n-----\n\nThe Code Grafting script updated all the relevant call sites to resemble Figure 9, with the\ntarget functions being replaced by calls to the stub_ implementations injected earlier. This\nprevented Bochs in IDB mode from getting derailed when hitting these call sites, because the\ncall operands now pointed to valid code inside the IDB.\n\nFigure 9: Patched operator new() call site\n\n**Dealing with EVILNEST**\n\nThe debug scenario for the dropper was slightly inconvenient, and simultaneously, it was\nsetting up a very unusual call site for the payload entry point. I used Bochs to execute the\ndropper until it placed the configuration data on the stack, and then I used IDAPython’s\nidc.get_bytes function to extract the resulting stack data. I wrote IDAPython script code to\niterate the stack data and assemble push instructions into the payload IDB leading up to a\ncall instruction pointing to the DLL’s export. This allowed me to debug the unpacking process\nfrom Bochs within a single session.\n\nI clicked on the beginning of my synthesized call site and hit F4 to run it in Bochs. I was\ngreeted with the warning in Figure 10 indicating that the patched IDB would not match the\ndepictions made by the debugger (which is untrue in the case of Bochs IDB mode). Bochs\nfaithfully executed my injected opcodes producing exactly the desired result.\n\n\n-----\n\nFigure 10: Patch warning\n\nI watched carefully as the instruction pointer approached and passed the IsDebuggerPresent\ncheck. Because of the stub I injected (stub_IsDebuggerPresent), it passed the check\nreturning zero as shown in Figure 11.\n\n\n-----\n\nFigure 11: Passing up IsDebuggerPresent\n\nI allowed the program counter to advance to address 0x1A1538, just beyond the unpacking\nroutine. Figure 12 shows the register state at this point which reflects a value in EAX that\nwas handed out by my fake heap allocator and which I was about to visit.\n\n\n-----\n\nFigure 12: Running to the end of the unpacker and preparing to view the result\n\nFigure 13 shows that there was indeed an IMAGE_DOS_SIGNATURE (“MZ”) at this location.\nI used idc.get_bytes() to dump the unpacked binary from the fake heap location and saved it\nfor analysis.\n\n\n-----\n\nFigure 13: Dumping the unpacked binary\n\nThrough Bochs IDB mode, I was also able to use the interactive debugger interface of IDA\nPro to experiment with manipulating execution and traversing a different branch to unpack\nanother payload for this malware as well.\n\n**Conclusion**\n\nAlthough dynamic analysis is sometimes the fastest road, setting it up and navigating minutia\ndetract from my focus, so I’ve developed an eye for routines that I can likely emulate in\nBochs to dodge those distractions while still getting answers. Injecting code into an IDB\nbroadens the set of functions that I can do this with, letting me get more out of Bochs. This in\nturn lets me do more on-the-fly experimentation, one-off string decodes, or validation of\nhypotheses before attacking something at scale. It also allows me to experiment dynamically\nwith samples that won’t load correctly anyway, such as unpacked code with damaged or\nincorrect PE headers.\n\n[I’ve shared the Code Grafting tools as part of the flare-ida GitHub repository. To use this for](https://github.com/fireeye/flare-ida/)\nyour own analyses:\n\n1. In IDA Pro’s IDAPython prompt, run code_grafter.py or import it as a module.\n2. Instantiate a CodeGrafter object and invoke its graftCodeToIdb() method:\n\nCodeGrafter().graftCodeToIdb()\n3. Use Bochs in IDB mode to conveniently execute your modified sample and experiment\n\naway!\n\n\n-----\n\nThis post makes it clear just how far I ll go to avoid breaking eye contact with IDA. If you re a\nfan of using Bochs with IDA too, then this is my gift to you. Enjoy!\n\nPrevious Post\nNext Post\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-07 - Thinking Outside the Bochs- Code Grafting to Unpack Malware in Emulation.pdf"
    ],
    "report_names": [
        "2020-04-07 - Thinking Outside the Bochs- Code Grafting to Unpack Malware in Emulation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535556,
    "ts_updated_at": 1743041158,
    "ts_creation_date": 1653685761,
    "ts_modification_date": 1653685761,
    "files": {
        "pdf": "https://archive.orkl.eu/4a3004c9fed91d69cb9352687c94bc3aecd1d6db.pdf",
        "text": "https://archive.orkl.eu/4a3004c9fed91d69cb9352687c94bc3aecd1d6db.txt",
        "img": "https://archive.orkl.eu/4a3004c9fed91d69cb9352687c94bc3aecd1d6db.jpg"
    }
}