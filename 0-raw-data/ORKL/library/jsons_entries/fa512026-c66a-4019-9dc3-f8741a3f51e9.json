{
    "id": "fa512026-c66a-4019-9dc3-f8741a3f51e9",
    "created_at": "2023-01-12T15:03:13.566725Z",
    "updated_at": "2025-03-27T02:05:56.618623Z",
    "deleted_at": null,
    "sha1_hash": "147d6b8871ff7bcb2704b7c47663338c2ddb58dd",
    "title": "2021-04-12 - Unpacking RAGNARLOCKER via emulation",
    "authors": "",
    "file_creation_date": "2022-05-28T03:10:34Z",
    "file_modification_date": "2022-05-28T03:10:34Z",
    "file_size": 535583,
    "plain_text": "# Unpacking RAGNARLOCKER via emulation\n\n**[reversing.fun/posts/2021/04/15/unpacking_ragnarlocker_via_emulation.html](http://reversing.fun/posts/2021/04/15/unpacking_ragnarlocker_via_emulation.html)**\n\n.. April 15, 2021\n\n### Apr 15, 2021\n\n## Introduction\n\n### Packers are a common way for adversaries to protect their payloads, avoid detections and make reverse engineering a bit harder.\n\n Manual analysis of packers helps in tasks such as making signatures to track more malware using that specific packer and developing tools that allow us to unpack malware automatically. To do that, reverse engineers need to understand how the packer is working.\n\n I like automating tasks whenever is possible, and I’ve always wondered about the automation of unpacking malware.\n\n Recently I’ve started to read more about emulation and came across the Qiling framework. The idea of unpacking malware via emulation seemed very interesting hence I started exploring the capabilities of Qiling for this specific use case.\n\n Here I’ll try to explain my approach to unpack RAGNARLOCKER with Qiling.\n\n## Reverse engineering the packer\n\n### To extract the payload via emulation, I needed to understand how the three stages of this packer work.\n\n There was no need to understand all the details of the algorithms used by this packer since I’ll just let the malware run (with Qiling) and let it unpack the payload itself.\n\n Instead, I need to understand the flow of the unpacking routines and try to identify a stage where the payload is unpacked in memory so that I could dump it.\n\n First stage\n\n In this first stage, the packer executes several worthless instructions, functions, and loops to slow down the analysis. It also uses some anti-emulation techniques, possibly to avoid emulators like Qiling. Below it’s possible to see some examples.\n\n Worthless function:\n\n\n-----\n\n### Worthless loop and instructions:\n\n Giant loop to slow down the execution (this is costly to an emulator, specially one that is written in python):\n\n Anti emulating via GetLastError API:\n\n GetLastError() is used to check the last error code of the calling thread. The packer calls SetWindowContextHelpId() with an invalid handle and checks if the last error is ERROR INVALID WINDOW HANDLE that corresponds to the value 0x578\n\n\n-----\n\n### Second stage\n\n In this stage, the packer allocates a new memory region, decrypts a shellcode, copies it to the newly allocated memory, and executes it.\n\n Allocating a new memory region:\n\n Decrypting the shellcode:\n\n Shellcode execution:\n\n As seen, a handle to KERNEL32.dll is passed to the shellcode. This handle is later used to resolve all the needed APIs.\n\n Third stage - final shellcode\n\n In this last stage, the shellcode decrypts the payload and loads it using a self replacement technique.\n\n Resolving the needed APIs:\n\n\n-----\n\n### Summary of the APIs used by the shellcode:\n```\nVirtualAlloc\nGetProcAddress\nVirtualProtect\nLoadLibraryA\nVirtualFree\nVirtualFree\nVirtualQuery\nTerminateThread\n\n Allocating two memory regions:\n\n Copying the encrypted payload to the first memory region and decrypting it:\n\n```\n\n-----\n\n### Copying the decrypted payload from the first memory region to the second memory region, and calling VirtualFree():\n\n The perfect time to dump the unpacked RAGNARLOCKER payload is when the shellcode calls VirtualFree(). As seen below, when the shellcode calls VirtualFree(), the second memory region allocated by the shellcode contains a PE file (the unpacked payload).\n\n Based on the analysis of the packer the strategy to unpack the payload with Qiling is the following:\n\n Strategy to unpack\n\n Track all the allocated memory regions. To accomplish this task, I used hooks in VirtualAlloc() and VirtualAllocEx().\n\n When the packer calls VirtualFree(), dump the last allocated memory region.\n\n\n-----\n\n### The strategy seems simple enough, but I also needed to overcome the anti-emulation tricks and Qiling limitations:\n\n Strategy to overcome Anti-Emulation tricks and Qiling limitations\n\n Bypass GetLastError() anti-emulation trick.\n\n Patch the large anti-emulation loop.\n\n Implement any missing windows apis. (Qiling limitation)\n\n## Qiling Emulation Framework\n\n### Qiling is a high-level framework that tries to emulate both the CPU and the OS.\n\n Description from the official website:\n\n Qiling is designed as a higher level framework, that leverages Unicorn to emulate CPU instructions, but Qiling understands OS: it has executable format loaders (for PE, MachO & ELF at the moment), dynamic linkers (so we can load & relocate shared libraries), syscall & IO handlers. For this reason, Qiling can run excutable binaries that normally runs in native OS\n\n The advantage of using a framework like this to unpack malware is that there is no need to understand all the unpacking algorithm. Also, the unpacker script may survive updates in the algorithm of the packer.\n\n Bypass GetLastError() anti-emulation trick\n\n As seen before, this packer uses the GetLastError() to check if the last error code was 0x578 after calling SetWindowContextHelpId().\n\n Fortunately, in Qiling, it’s possible to set specific error codes. The hook implementation for this API is the following:\n```\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_SetWindowContextHelpId(ql, address, params):\n  ERROR_INVALID_WINDOW_HANDLE = 0x578 \n  ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE \n  return False\n\n```\n\n-----\n\n### Additionally, GetWindowContextHelpId() seems to be called with the SetWindowContextHelpId() call. Since this API is also not implemented in Qiling, I needed to implement it and set the correct error code.\n```\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\") \ndef hook_GetWindowContextHelpId(ql, address, params): \n  ERROR_INVALID_WINDOW_HANDLE = 0x578 \n  ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE \n  return False\n\n Patching the large anti-emulation loop\n\n As seen before, the packer uses a large “for” loop possibly to avoid being executed under emulators like Qiling.\n\n Fortunately, Qiling can search for specific byte patterns in memory and patch them.\n\n The bytes that I choose to patch were the ones that make the instruction cmp\n[ebp+var_1B8], 1E8480h :\n\n The idea was to change the instruction to cmp [ebp+var_1B8], 0 . This way the code does not enter the “for” loop.\n\n Note: Another approach could be to turn the conditional jump that comes after in an unconditional jump)\n\n Patch function:\n\n```\n\n-----\n\n```\n# Patch specific byte patterns\ndef patch_bytes(ql):\n  patches = []\n  # Patch needed to avoid the anti-emulation loop\n  # original bytes -> 81 BD 48 FE FF FF 80 84 1E 00 = cmp dword ptr ss:[ebp1B8],1E8480\n  # patched bytes -> 83 BD 48 FE FF FF 00 90 90 90 = cmp dword ptr ss:[ebp-1B8],0\n  patches.append({'original': b'\\x81\\xBD\\x48\\xFE\\xFF\\xFF\\x80\\x84\\x1E\\x00', 'patch':\nb'\\x83\\xBD\\x48\\xFE\\xFF\\xFF\\x00\\x90\\x90\\x90'})\n  for patch in patches:\n    addr = ql.mem.search(patch['original'])\n    if addr:\n      ql.log.warning('found target patch bytes at addr:\n{}'.format(hex(addr[0])))\n      try:\n        ql.patch(addr[0], patch['patch'])\n        ql.log.info('patch sucessfully applied')\n        return \n      except Exception as err:\n        ql.log.error('unable to apply the patch. error: {}'.format(str(e)))\n    else:\n      ql.log.warning('target patch bytes not found')\n\n### Overcoming Qiling limitations\n\n Some Windows APIs aren’t supported in Qiling yet. In Qiling, to implement an API, it’s the same as hooking an API.\n\n```\n\n-----\n\n```\nNot implemented in Qiling\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_CharUpperW(ql, address, params):\n  return params[\"lpsz\"]\n'''\nNot implemented in Qiling\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_CharUpperBuffW(ql, address, params):\n  return 100\n'''\nThis api is giving troubles to Qiling in the way the malware passes arguments.\nSo let's hook it and making it returning null since the packer does not use the\nreturn value for nothing.\n'''\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_CreateEventA(ql, address, params):\n  return 0\n'''\nQiling is retuning 0x0 by default and the packer stub only continues if this value is\ndifferent from 0.\nSo let's just hook it and make it return a value different then 0\n'''\n@ winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\") \ndef hook_VirtualQuery(ql, address, params): \n  return params['dwLength']\n\n### Defining the needed hooks\n\n With the anti-emulation loop patched and the Qiling limitations been taken care of, it was a matter of hooking the rest of the needed functions to keep up with the unpacking strategy.\n\n```\n\n-----\n\n```\n@winsdkapi(cc STDCALL, dllname kernel32_dll )\ndef hook_VirtualFree(ql, address, params):\n  global mem_regions\n  lpAddress = params['lpAddress']\n  ql.log.warning('VirtualFree called. lpAddress = {}'.format(hex(lpAddress)))\n  ql.log.warning('time to dump last allocated memory...')\n  unpacked_mem_region = mem_regions[-1]\n  dump_memory_region(ql, unpacked_mem_region['start'], unpacked_mem_region['size'])\n  ql.os.heap.free(lpAddress)\n  exit()\n  return 1\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualProtect(ql, address, params):\n  return 1\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualAllocEx(ql, address, params):\n  global mem_regions\n  dw_size = params[\"dwSize\"]\n  addr = ql.os.heap.alloc(dw_size) # allocate memory in heap\n  ql.log.warning('VirtualAllocEx hook allocated a new memory on the heap at -> {}\nwith size -> {} bytes'.format(hex(addr), hex(dw_size)))\n  mem_reg = {\"start\": addr, \"size\": dw_size}\n  mem_regions.append(mem_reg)\n  return addr\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualAlloc(ql, address, params):\n  global mem_regions\n  dw_size = params[\"dwSize\"]\n  addr = ql.os.heap.alloc(dw_size) # allocate memory in heap\n  ql.log.warning('VirtualAlloc hook allocated a new memory on the heap at -> {}\nwith size -> {} bytes'.format(hex(addr), hex(dw_size)))\n  mem_reg = {\"start\": addr, \"size\": dw_size}\n  mem_regions.append(mem_reg)\n  return addr\n\n### Things to notice in the above definitions:\n\n The VirtualAlloc() and VirtualAllocEx() hooks save the allocated memory regions to a global variable. The VirtualFree() hook calls a function to dump the last memory region.\n\n The function that dumps the memory region:\n\n```\n\n-----\n\n```\ndef dump_memory_region(ql, address, size):\n  ql.log.warning('dumping memory section at: {}'.format(hex(address)))\n  ql.log.warning('size: {}'.format(hex(size)))\n  try:\n    exec_mem = ql.mem.read(address, size)\n    with open('{}.bin'.format(hex(address)), \"wb\") as f:\n      f.write(exec_mem)\n  except Exception as e:\n    ql.log.error(str(e))\n\n## Unpacking RAGNARLOCKER\n\n### Script output:\n\n As seen, the script was able to dump the unpacked RAGNARLOCKER payload:\n\n As seen, PE-BEAR opens the unpacked file with no problems:\n\n```\n\n-----\n\n## Conclusion\n\n### I can see the potential in using a framework like Qiling to automate reverse engineering tasks, and I’ll keep exploring emulation and other use cases besides unpacking.\n\n## Packed sample\n```\n68eb2d2d7866775d6bf106a914281491d23769a9eda88fc078328150b8432bb3\n\n Full code\n\n```\n\n-----\n\n```\nfrom qiling import \nfrom qiling.const import *\nfrom qiling.exception import *\nfrom qiling.os.const import *\nfrom qiling.os.windows.const import *\nfrom qiling.os.windows.fncc import *\nfrom qiling.os.windows.handle import *\nfrom qiling.os.windows.thread import *\nfrom qiling.os.windows.utils import *\nimport sys\nfrom sys import exit\nfrom os.path import expanduser\nmem_regions = []\ndef dump_memory_region(ql, address, size):\n  ql.log.warning('dumping memory section at: {}'.format(hex(address)))\n  ql.log.warning('size: {}'.format(hex(size)))\n  try:\n    exec_mem = ql.mem.read(address, size)\n    with open('{}.bin'.format(hex(address)), \"wb\") as f:\n      f.write(exec_mem)\n  except Exception as e:\n    ql.log.error(str(e))\n'''\nNot implemented in Qiling\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_CharUpperW(ql, address, params):\n  return params[\"lpsz\"]\n'''\nNot implemented in Qiling\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_CharUpperBuffW(ql, address, params):\n  return 100\n'''\nThis api is giving troubles to Qiling in the way the malware passes arguments.\nSo let's hook it and making it returning null since the packer does not use the\nreturn value for nothing.\n'''\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_CreateEventA(ql, address, params):\n  return 0\n'''\nQiling is retuning 0x0 by default and the packer stub only continues if this value is\ndifferent from 0.\nSo let's just hook it and make it return a value different then 0\n'''\n@ winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualQuery(ql, address, params):\n\n```\n\n-----\n\n```\n  return params[ dwLength ]\n'''\nAnti emulation\nWe need this api to set the last error code to be: 0x578\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_SetWindowContextHelpId(ql, address, params):\n  ERROR_INVALID_WINDOW_HANDLE = 0x578\n  ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE\n  return False\n'''\nAnti emulation\nIt is called with SetWindowContextHelpId.\nSince this api is not implemented in Qiling we need to implement it too and make it\nset the correct error code.\n'''\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\")\ndef hook_GetWindowContextHelpId(ql, address, params):\n  ERROR_INVALID_WINDOW_HANDLE = 0x578\n  ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE\n  return False\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualFree(ql, address, params):\n  global mem_regions\n  lpAddress = params['lpAddress']\n  ql.log.warning('VirtualFree called. lpAddress = {}'.format(hex(lpAddress)))\n  ql.log.warning('time to dump last allocated memory...')\n  unpacked_mem_region = mem_regions[-1]\n  dump_memory_region(ql, unpacked_mem_region['start'], unpacked_mem_region['size'])\n  ql.os.heap.free(lpAddress)\n  exit()\n  return 1\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualProtect(ql, address, params):\n  return 1\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualAllocEx(ql, address, params):\n  global mem_regions\n  dw_size = params[\"dwSize\"]\n  addr = ql.os.heap.alloc(dw_size) # allocate memory in heap\n  ql.log.warning('VirtualAllocEx hook allocated a new memory on the heap at -> {}\nwith size -> {} bytes'.format(hex(addr), hex(dw_size)))\n  mem_reg = {\"start\": addr, \"size\": dw_size}\n  mem_regions.append(mem_reg)\n  return addr\n\n```\n\n-----\n\n```\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\")\ndef hook_VirtualAlloc(ql, address, params):\n  global mem_regions\n  dw_size = params[\"dwSize\"]\n  addr = ql.os.heap.alloc(dw_size) # allocate memory in heap\n  ql.log.warning('VirtualAlloc hook allocated a new memory on the heap at -> {}\nwith size -> {} bytes'.format(hex(addr), hex(dw_size)))\n  mem_reg = {\"start\": addr, \"size\": dw_size}\n  mem_regions.append(mem_reg)\n  return addr\n# Patch specific byte patterns\ndef patch_bytes(ql):\n  patches = []\n  # Patch needed to avoid the anti-emulation loop\n  # original bytes -> 81 BD 48 FE FF FF 80 84 1E 00 = cmp dword ptr ss:[ebp1B8],1E8480\n  # patched bytes -> 83 BD 48 FE FF FF 00 90 90 90 = cmp dword ptr ss:[ebp-1B8],0\n  patches.append({'original': b'\\x81\\xBD\\x48\\xFE\\xFF\\xFF\\x80\\x84\\x1E\\x00', 'patch':\nb'\\x83\\xBD\\x48\\xFE\\xFF\\xFF\\x00\\x90\\x90\\x90'})\n  for patch in patches:\n    addr = ql.mem.search(patch['original'])\n    if addr:\n      ql.log.warning('found target patch bytes at addr:\n{}'.format(hex(addr[0])))\n      try:\n        ql.patch(addr[0], patch['patch'])\n        ql.log.info('patch sucessfully applied')\n        return\n      except Exception as err:\n        ql.log.error('unable to apply the patch. error: {}'.format(str(e)))\n    else:\n      ql.log.warning('target patch bytes not found')\ndef sandbox(path, rootfs):\n  # Create a sandbox for windows x86\n  ql = Qiling([path], rootfs, verbose=QL_VERBOSE.DEFAULT, console=True)\n  # Apply the hooks\n  ql.set_api(\"VirtualAlloc\", hook_VirtualAlloc)\n  ql.set_api(\"VirtualAllocEx\", hook_VirtualAllocEx)\n  ql.set_api(\"VirtualProtect\", hook_VirtualProtect)\n  ql.set_api('CharUpperW', hook_CharUpperW)\n  ql.set_api('CharUpperBuffW', hook_CharUpperBuffW)\n  ql.set_api('SetWindowContextHelpId', hook_SetWindowContextHelpId)\n  ql.set_api('GetWindowContextHelpId', hook_GetWindowContextHelpId)\n  ql.set_api('CreateEventA', hook_CreateEventA)\n\n```\n\n-----\n\n```\n  ql.set_api( VirtualQuery, hook_VirtualQuery)\n  ql.set_api('VirtualFree', hook_VirtualFree)\n  # Path anti emulation loops\n  patch_bytes(ql)\n  # Start the sandbox\n  try:\n    ql.run()\n  except Exception as e:\n    print('error: {}'.format(str(e)))\n    exit(-1)\ndef main():\n  if not len(sys.argv) == 2:\n    print(f\"usage: {sys.argv[0]} <exefile>\")\n    return\n  path = sys.argv[1]\n  rootfs = f\"{expanduser('~')}/qiling/examples/rootfs/x86_windows\"\n  sandbox(path, rootfs)\nif __name__ == \"__main__\":\n  main()\n\n## References\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-12 - Unpacking RAGNARLOCKER via emulation.pdf"
    ],
    "report_names": [
        "2021-04-12 - Unpacking RAGNARLOCKER via emulation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535793,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653707434,
    "ts_modification_date": 1653707434,
    "files": {
        "pdf": "https://archive.orkl.eu/147d6b8871ff7bcb2704b7c47663338c2ddb58dd.pdf",
        "text": "https://archive.orkl.eu/147d6b8871ff7bcb2704b7c47663338c2ddb58dd.txt",
        "img": "https://archive.orkl.eu/147d6b8871ff7bcb2704b7c47663338c2ddb58dd.jpg"
    }
}