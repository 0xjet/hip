{
    "id": "2891dd3a-6391-4e7b-b0cd-ab02e085ec3c",
    "created_at": "2023-01-12T15:05:15.668399Z",
    "updated_at": "2025-03-27T02:06:13.347812Z",
    "deleted_at": null,
    "sha1_hash": "160718043ab517b9cd3b2254d199edb83278ee48",
    "title": "2020-09-23 - Looking for sophisticated malware in IoT devices",
    "authors": "",
    "file_creation_date": "2022-05-28T19:26:26Z",
    "file_modification_date": "2022-05-28T19:26:26Z",
    "file_size": 1202416,
    "plain_text": "# Looking for sophisticated malware in IoT devices\n\n**[securelist.com/looking-for-sophisticated-malware-in-iot-devices/98530/](https://securelist.com/looking-for-sophisticated-malware-in-iot-devices/98530/)**\n\nAuthors\n\n[Noushin Shabab](https://securelist.com/author/noushinshabab/)\n\n_One of the motivations for this post is to encourage other researchers who are interested in_\n_this topic to join in, to share ideas and knowledge and to help build more capabilities in order_\n_to better protect our smart devices._\n\n## Research background\n\nSmart watches, smart home devices and even smart cars – as more and more connected\ndevices join the IoT ecosystem, the importance of ensuring their security becomes patently\nobvious.\n\nIt’s widely known that the smart devices which are now inseparable parts of our lives are not\nvery secure against cyberattacks. Malware targeting IoT devices has been around for more\nthan a decade. Hydra, the first known router malware that operated automatically, appeared\nin 2008 in the form of an open-source tool. Hydra was an open-source prototype of router\n\n\n-----\n\nmalware. Soon after Hydra, in-the-wild malware was also found targeting network devices.\nSince then, different botnet families have emerged and become widespread, including\nfamilies such as Mirai, Hajime and Gafgyt.\n\nApart from the malware mentioned above, there are also vulnerabilities found in\ncommunication protocols used in IoT devices, such as Zigbee, which can be exploited by an\nattacker to target a device and to propagate malware to other devices in a network, similar to\ncomputer worms.\n\nIn this research, we are focusing on hunting low-level sophisticated attacks targeting IoT\ndevices and, in particular, taking a closer look at the firmware of IoT devices to find backdoor\nimplants, modifications to the boot process and other malicious alterations to different parts\nof the firmware.\n\nNow, let’s talk about the structure of the firmware of an IoT device in order to get a better\nunderstanding of the different components.\n\n## IoT firmware structure\n\nRegardless of the CPU architecture of an IoT device, the boot process consists of the\nfollowing stages: the boot loader, the kernel and the file system (shown in the figure below).\nWhen an IoT device is switched on, the code from the onboard SoC (System on Chip) ROM\ntransfers control to the bootloader, the bootloader loads the kernel and kernel then mounts\nthe root file system.\n\nThe boot loader, the kernel and the file system also comprise the three main components of\ntypical IoT firmware.\n\n\n-----\n\n**_IoT boot process_**\n\nThere are a variety of CPU architectures used in IoT devices. Therefore, being able to\nanalyze and understand the different components of firmware requires a good understanding\nof these architectures and also their instruction set. The most common CPU architectures\n\n\n-----\n\namong IoT devices are:\n\nARM\nMIPS\nPowerPC\nSPARC\n\n## Possible attack scenarios\n\nUnderstanding the firmware structure enables us to think about how an attacker might take\nadvantage of the various components when deploying a stealth attack that’s difficult to\ndetect.\n\nThe bootloader is the first component that takes control of the system. Therefore, targeting\nthe bootloader offers an attacker a perfect opportunity to carry out malicious tasks. It also\nmeans that an attack can remain persistent after a reboot.\n\nAn attacker can also manipulate the kernel modules. The majority of IoT devices use the\nLinux kernel. As easy as it is for a developer to customize and choose whatever they need\nfrom the Linux kernel, an attacker who manages to access and manipulate the device\nfirmware can also add or edit kernel modules.\n\nMoving on to the file system, there are also a number of common file systems used in IoT\ndevices. These file systems are usually easy to work with. An attacker can extract,\ndecompress and also mount the original file system from the firmware, add malicious\nmodules and compress it again using common utilities. For instance, SquashFS is a\ncompressed file system for Linux that is quite common among IoT manufacturers. It’s very\nstraightforward to mount or uncompress a SquashFS file system using the Linux utilities\n“squashfs” and “unsquashfs”.\n\n## Challenges of this research\n\n### Obtaining firmware\n\nThere are different ways to obtain firmware. When deciding to investigate, sometimes you\nwant the acquired firmware to belong to the exact same device with the same specifications;\nand you also want it to be deployed on the device through some specific means. For\nexample, you suspect that the network through which the firmware is updated has been\ncompromised and you consider the possibility of the firmware being manipulated in transition\nbetween the vendor’s server and the device, hence you want to investigate the updated\nfirmware to validate its integrity. In another example scenario, you might have bought a\ndevice from a third-party vendor and have doubts about the firmware’s authenticity.\n\n\n-----\n\nThere are also a large number of IoT devices where the manufacturers don t implement any\nways to get access to the firmware, not even for an update. The device is released from the\nmanufacturer with firmware for its lifetime.\n\nIn such cases the surest way to obtain the exact firmware you are after, is to extract the\nfirmware from the device itself.\n\nThe main challenge here is that this process requires a certain domain-specific knowledge\nand also specialist hardware/software experience of working with embedded systems. This\napproach also lacks scalability if you want to find sophisticated attacks targeting IoT devices\nin general.\n\nAmong the various ways of obtaining IoT firmware, the easiest way is to download the\nfirmware from the device manufacturer’s website. However, not all manufacturers publish\ntheir firmware on their website. In general, a large number of IoT devices can only be\nupdated through the device physical interface or via a specific software application (e.g.\nmobile app) used to manage the device.\n\nWhen downloading firmware from a vendor’s website, a common issue is that you might not\nbe able to find older versions of the firmware for your specific device model. Let’s also not\nforget that in many cases the published firmware binaries are encrypted and can only be\ndecrypted through the older firmware modules installed on the device.\n\n### Understanding firmware\n\nAccording to Wikipedia, “firmware is a specific class of computer software that provides the\nlow-level control for a device’s specific hardware. Firmware can either provide a standardized\noperating environment for more complex device software (allowing more hardwareindependence), or, for less complex devices, act as the device’s complete operating system,\nperforming all control, monitoring and data manipulation functions.”\n\nEven though the main components of firmware are almost always the same, there is no\nstandard architecture for firmware.\n\nThe main components of firmware are typically the bootloader, the kernel module and the file\nsystem; but there are many other components that can be found in a firmware binary, such\nas the device tree, the digital certificates, and other device specific resources and\ncomponents.\n\nOnce the firmware binary has been retrieved from the vendor’s website, we can then begin\nanalyzing it and taking it apart. Given the specialized nature of the firmware, its analysis is\nvery challenging and rather involved. To get some more details about these challenges and\nhow to tackle them, refer to the “IoT firmware analysis” section.\n\n### Finding suspicious elements in firmware\n\n\n-----\n\nAfter the components of the firmware have been extracted, you can start to look for\nsuspicious modules, code snippets or any sort of malicious modifications to the components.\n\nAn easy step to start with, is to scan the file system contents against a set of YARA rules\nwhich can be based on known IoT malware or heuristic rules. You can also scan the\nextracted file system contents with an antivirus scanner.\n\nSomething else you can do is look for the startup scripts inside the file system. These scripts\ncontain lists of modules that get loaded every time the system boots up. The address to a\nmalicious module might have been inserted in a script like this with malicious intent.\n\n[Here the Firmwalker tool can help with scanning an extracted file system for potentially](https://github.com/craigz28/firmwalker)\nvulnerable files.\n\n.\n\n**_Firmwalker capabilities (https://craigsmith.net/firmwalker/)_**\n\nAnother place to investigate is the bootloader component, though this is more challenging.\n\n[There are a number of common bootloaders used in IoT devices with U Boot being the most](https://github.com/u-boot/u-boot)\ncommon. U Boot is highly customizable, which makes it very difficult to determine whether\nthe compiled code has been manipulated or not. Finding malicious modifications becomes\neven more complicated with uncommon or custom bootloaders.\n\n\n-----\n\n## IoT firmware analysis\n\nThere are a variety of open-source and closed-source tools that can help with firmware\nanalysis. The best approach is to use a combination of the tools and techniques suggested\nby experienced firmware analysts.\n\nLet’s begin with Binwalk, the most comprehensive firmware analysis tool. Binwalk scans the\nfirmware binary and looks for known patterns and signatures.\n\nIt has a large collection of signatures for various bootloaders and file systems used in IoT\ndevices. It also has signatures for common encryption and compression algorithms along\nwith the respective routines for decompression and decoding.\n\nBinwalk is also capable of extracting the components it finds in the firmware binary.\n\nThe following screenshot shows the output of a Binwalk scan on a sample firmware binary:\n\n**_Binwalk scan output_**\n\nIn this screenshot, Binwalk has found and printed out the header, the bootloader and the\nLinux kernel as well as the file system. There are also metadata details that have been\nextracted from the headers and the components themselves, such as the type and size of\neach component, CRC checksums, important addresses, CPU architecture, image name\nand so on. Now you can go on and use Binwalk itself to extract the above-mentioned parts,\nor manually calculate the sizes and extract the parts based on the start offset found by\nBinwalk.\n\nAfter extracting the components of the firmware, you can go on and extract, decompress or\neven mount the file system and start investigating the file system content. You can also look\nat the bootloader code in a disassembler, or debug it through a debugger.\n\nHowever, doing firmware analysis is not always that straightforward. Firmware is so varied\nand diverse that understanding its structure and extracting the components is usually quite\ncomplicated.\n\nLet’s take a close look at another sample firmware and try to understand its structure.\n\n\n-----\n\n**1. Binwalk firmware.bin**\n\nThe Binwalk scan shows nothing in the result. This means that Binwalk could not find any\nknown signatures.\n\n**_Binwalk scan output_**\n\nWe can see in this case that the simple Binwalk scan was not very helpful. However, be\naware that there are other tools and techniques we can use to learn more about the structure\nof this firmware.\n\n**2. File firmware.bin**\n\nLet’s next try the Linux file utility on the firmware binary.\n\n**_File utility output_**\n\nThe file utility shows the file type as Targa image data. By looking at the beginning of the\nbinary file, and doing a Google search on the Targa image data signature, the result is\nobviously a false positive.\n\n**_First bytes of the firmware binary_**\n\nThis is because the first bytes of the firmware file, 0x01010000, match the Targa image data\nsignature. See the screenshot above.\n\n**3. Binwalk -E firmware.bin**\n\nLet’s use another capability of Binwalk and check the entropy of the firmware binary.\n\n\n-----\n\nRunning Binwalk using the -E command option gives an entropy diagram for the firmware\nfile and some additional details such as the offset for falling and rising entropy.\n\n**_Entropy details_**\n\n**_Entropy diagram_**\n\nEntropy figures close to 1 indicate compression, while the lower entropy figures indicate\nuncompressed and unencrypted areas. As can be seen from the screenshots above, the\noffset 55296 (0xD800) is the beginning of the high entropy part.\n\nThere is also another tool that can be helpful in visualizing the binary. With the help of\nbinvis.io you can see the contents of the firmware file and its visualization in two side-by-side\npanes. Different parts are shown in different colors based on their entropy. (binvis.io)\n\n\n-----\n\n**Visualization of the firmware created by binvis.io**\n\n**4. Binwalk -A firmware.bin**\n\nBinwalk can also scan the binary file for common executable opcode signatures.\n\n**_First function prologues found in the file_**\n\n\n-----\n\n**_Last function prologues found in the file_**\n\nAs we can see from the screenshot above, the result of the opcode signature check is\nactually very helpful! First, we can see that the firmware belongs to an ARM device.\n\nSecond, if we consider the offsets of the first and last function prologue signatures, we get an\nindication that these are the sections of the firmware binary that contain code.\n\nFrom the screenshot, we can also see that the last function is found at the address 0xD600,\nwhich is just 0x200 bytes before the part where the entropy goes up. From this, we can make\nan educated guess that this offset is likely the end of the code of the bootloader and the\nbeginning of the compressed kernel modules.\n\n**5. Hexdump -C**\n\nhexdump -C firmware.bin | grep -C 4 -e “^\\*$”\n\nNow that we know the rough boundaries of some of the components of the firmware file, we\ncan try to confirm these boundary offsets by looking at the actual contents of the firmware file\naround these areas.\n\nIf we run the firmware file through a hexdump, and look for lines that contain only an asterisk\n“*”, we can locate the compiler-added padding for each of the firmware components.\n\n\n-----\n\n**Contents of the firmware binary**\n\n**_Contents of other parts of the firmware binary_**\n\nThe output of the Hexdump utility, together with the previous findings, confirm the section of\nthe firmware binary containing ARM code. We previously suspected that this code belongs to\nthe bootloader.\n\n**6. Strings –radix=x firmware.bin**\n\nNext, let’s extract the ASCII strings from the firmware together with their offsets.\n\n\n-----\n\n**_Last ASCII strings found in the firmware binary_**\n\nLooking at the screenshot above, there are some strings related to the module entry point.\nThese strings can give us a good indication of the nature of the code involved.\n\nWe can see some other interesting strings from the beginning of the firmware binary in the\nscreenshot below. For example, the “MctlApplet.cpp” library name can be used to find other\nbinaries or packages from the same developers. Having other firmware images from the\nsame vendor helps to better understand the binary structure.\n\nAnother interesting string from the same screenshot is “Not Booting from softloader” which\ncan indicate the process state or perhaps the nature of this module.\n\nStrings containing “Assert()” can suggest different information about the code. Using Asserts\nis a common practice in firmware development, as it helps the developer to debug and\ntroubleshoot the code during the development and production phase.\n\n\n-----\n\n**_First ASCII strings found in the firmware binary_**\n\n**7. IDA -parm firmware.bin**\n\nWe can see that we have already collected lots of valuable information from this firmware\nbinary that seemed quite incomprehensible at the beginning.\n\nLet’s now use IDA to inspect the code. As this binary is not an ELF file with standard headers\nthat show the ISA, we need to explicitly tell IDA to use the ARM instruction set to\ndisassemble the code.\n\n\n-----\n\n**_Disassembly view of part of a function in IDA_**\n\nThe above screenshot from IDA shows how the strings found in the previous analysis steps\ncan be used to help find the call to the entry point of the kernel module.\n\n**8. dd**\n\nWe can now go ahead and extract the part of the firmware binary which our analysis found to\nbe the bootloader module.\n\n**9. Qemu**\n\nAfter all the modules have been extracted from the firmware binary – the file system content,\nthe kernel modules and other components – we can then use Qemu to run the binaries, and\neven emulate the files that were meant for a different architecture from our own machine,\nand start interacting with them.\n\n## Conclusion\n\nThe number of IoT devices is getting bigger and bigger every day. From industrial control\nsystems, smart cities and cars to consumer-grade devices such as mobile phones,\nnetworking devices, personal assistants, smart watches and a large variety of smart home\nappliances.\n\nIoT devices are derived from embedded systems that have been around for many years. The\nmanufacture and development of software for embedded devices has always had different\npriorities from those of general-purpose computer systems due to the different nature of\nthese devices. These priorities have been shaped by the limited and specific functions of the\ndevices themselves the limited capabilities and capacities of the underlying hardware as\n\n\n-----\n\nwell as the inaccessibility of the developed code to subsequent alteration and modifications.\nHowever, IoT devices have significant differences to traditional embedded systems. Most IoT\ndevices nowadays run on hardware that have similar capabilities to a general-purpose\ncomputer system.\n\nAs IoT devices become more prevalent, they are now accessing and controlling many\naspects of our lives and day-to-day interactions. IoT devices can now potentially give\nmalicious actors unprecedented opportunities to do harm. This highlights the importance of\nsecurity in IoT devices and also shows the relevance of research around this topic. The good\nnews is that there are many tools and techniques available to assist current and future\nresearch in this field. Acquiring a good understanding of the architecture of IoT devices,\nlearning the language these devices speak and a good dose of determination and\nperseverance are what it takes to enter this research field.\n\nThis post has been written primarily to motivate individuals who want to start diving into IoT\nsecurity research. You can reach out to us regarding this research at\niot_firmware_research@kaspersky.com or via my twitter account, @Noushinshbb.\n\nWe’ll be publishing more in the future! Stay tuned!\n\n[Firmware](https://securelist.com/tag/firmware/)\n[Internet of Things](https://securelist.com/tag/internet-of-things/)\n[Linux](https://securelist.com/tag/linux/)\n[Malware](https://securelist.com/tag/malware/)\n\nAuthors\n\n[Noushin Shabab](https://securelist.com/author/noushinshabab/)\n\nLooking for sophisticated malware in IoT devices\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-23 - Looking for sophisticated malware in IoT devices.pdf"
    ],
    "report_names": [
        "2020-09-23 - Looking for sophisticated malware in IoT devices.pdf"
    ],
    "threat_actors": [
        {
            "id": "a4aca3ca-9e04-42d1-b037-f7fb3fbab0b1",
            "created_at": "2023-01-06T13:46:39.042499Z",
            "updated_at": "2025-03-27T02:00:02.984002Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Colourful Panda",
                "BRONZE DUDLEY"
            ],
            "source_name": "MISPGALAXY:TA428",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535915,
    "ts_updated_at": 1743041173,
    "ts_creation_date": 1653765986,
    "ts_modification_date": 1653765986,
    "files": {
        "pdf": "https://archive.orkl.eu/160718043ab517b9cd3b2254d199edb83278ee48.pdf",
        "text": "https://archive.orkl.eu/160718043ab517b9cd3b2254d199edb83278ee48.txt",
        "img": "https://archive.orkl.eu/160718043ab517b9cd3b2254d199edb83278ee48.jpg"
    }
}