{
    "id": "64d5688c-0ba0-4fde-a07c-44acb7350e2f",
    "created_at": "2022-10-25T16:48:16.283788Z",
    "updated_at": "2025-03-27T02:08:23.138539Z",
    "deleted_at": null,
    "sha1_hash": "12793d7ddf96e8d9fa2f481966ae3d1022186fc0",
    "title": "CMSY10",
    "authors": "",
    "file_creation_date": "2013-09-04T10:32:03Z",
    "file_modification_date": "2013-09-04T10:32:03Z",
    "file_size": 106946,
    "plain_text": "# Highly Resilient Peer-to-Peer Botnets Are Here: An Analysis of Gameover Zeus\n\n## Dennis Andriesse[1], Christian Rossow[1], Brett Stone-Gross[2], Daniel Plohmann[3], and Herbert Bos[1]\n\n1VU University Amsterdam, The Netherlands, {d.a.andriesse,c.rossow,h.j.bos}@vu.nl\n2Dell SecureWorks, bstonegross@secureworks.com\n3Fraunhofer FKIE, Bonn, Germany, daniel.plohmann@fkie.fraunhofer.de\n\n\n## Abstract\n\nZeus is a family of credential-stealing trojans which\noriginally appeared in 2007. The first two variants of Zeus\nare based on centralized command servers. These command servers are now routinely tracked and blocked by the\nsecurity community. In an apparent effort to withstand these\nroutine countermeasures, the second version of Zeus was\nforked into a peer-to-peer variant in September 2011. Compared to earlier versions of Zeus, this peer-to-peer variant\nis fundamentally more difficult to disable. Through a detailed analysis of this new Zeus variant, we demonstrate\nthe high resilience of state of the art peer-to-peer botnets\nin general, and of peer-to-peer Zeus in particular.\n\n## 1 Introduction\n\nSince its first appearance in 2007, Zeus has grown into one\nof the most popular families of credential-stealing trojans.\nDue to its popularity, previous versions of Zeus have been\nextensively investigated by the security community [6, 18].\nThe internals of the first two versions of Zeus, which are\nbased on centralized Command and Control (C2) servers,\nare well understood, and C2 servers used by these variants\nare routinely tracked and blocked.[1]\n\nIn May 2011, the source code of the second centralized\nversion of Zeus leaked into the public domain. This has\nled to the development of several centralized trojans based\non Zeus, such as ICE IX [16], and the more successful\nCitadel [14]. In September 2011, a peer-to-peer (P2P) mutation of centralized Zeus appeared, known as P2P Zeus or\nGameOver. Due to its lack of centralized C2 servers, P2P\nZeus is not susceptible to traditional anti-Zeus countermeasures, and is much more resilient against takedown efforts\nthan centralized Zeus variants. In this paper, we perform a\ndetailed analysis of the P2P Zeus protocol to highlight how\nit achieves its resilience. Our insights also shed light on the\nresilience potential of peer-to-peer botnets in general.\nCentralized Zeus variants are sold as builder kits in the\nunderground community, allowing each user to build a private Zeus botnet. Interestingly, this is no longer supported\n\n1http://zeustracker.abuse.ch\n\n\nin P2P Zeus, which is based on a single coherent P2P network. The main P2P network is divided into several virtual\nsub-botnets by a hardcoded sub-botnet identifier in each bot\nbinary. While the Zeus P2P network is maintained and periodically updated as a whole, the sub-botnets are independently controlled by several botmasters. Bot enumeration\nresults from our previous work indicate that the Zeus P2P\nnetwork contains at least 200.000 bots [11].\nThe Zeus P2P network serves two main purposes. (1)\nBots exchange binary and configuration updates with each\nother. (2) Bots exchange lists of proxy bots, which are designated bots where stolen data can be dropped and commands can be retrieved. Additionally, bots exchange neighbor lists (peer lists) with each other to maintain a coherent\nnetwork. As a backup channel, P2P Zeus also uses a Domain Name Generation Algorithm (DGA) [1], in case contact with the regular P2P network is lost.\nOur results are based on Zeus samples collected from the\nSandnet analysis environment [13] between February 2012\nand July 2013. When we began our analysis, no detailed\ninformation on the Zeus P2P protocol was available from\nrelated work. We verified the correctness of our results\nthrough prototype poisoning and crawling attacks against\nZeus, which are described in our previous work [11].\nOur contributions are as follows.\n\n1. We reverse engineer and detail the entire Zeus P2P\nprotocol and topology, highlighting features that increase the botnet’s resilience to takedown attempts.\n2. We show that P2P Zeus has evolved into a complex\nbot with attack capabilities that go beyond typical\nbanking trojans. Particularly, we find that P2P Zeus\nis used for activities as diverse as DDoS attacks, malware dropping, Bitcoin theft, and theft of Skype and\nbanking credentials.\n3. Reports from academia and industry have long\nwarned of the high resilience potential of peer-to-peer\nbotnets [4, 5, 7, 19, 20]. Through our analysis of the\ncommunication protocol and resilience mechanisms\nof P2P Zeus, we show that highly resilient P2P botnets are now a very real threat.\n\n\n-----\n\n## 2 Network Topology\n\nThe Zeus network is organized into three disjoint layers, as\nshown in Figure 1. At the bottom of the hierarchy is the\nP2P layer, which contains the bots. Periodically, a subset\nof the bots is assigned the status of proxy bot. This appears to be done manually by the botmasters, by pushing a\ncryptographically signed proxy announcement message into\nthe network. The details of this mechanism are explained in\nSection 3. The proxy bots are used by harvester bots to fetch\ncommands and drop stolen data. Aside from their special\nfunction, proxy bots behave like harvester bots.\nThe proxy bots act as intermediaries between the P2P\nlayer and a higher layer, which we call the C2 proxy\nlayer. The C2 proxy layer contains several dedicated HTTP\nservers (not bots), which form an additional layer between\nthe proxy bots and the true root of the C2 communication.\nPeriodically, the proxy bots interact with the C2 proxy layer\nto update their command repository, and to forward the\nstolen data collected from the bots upward in the hierarchy.\n\nC2 Layer\n\nC2 Proxy Layer\n\nP2P Layer\n\nFigure 1: Topology of P2P Zeus. Shaded nodes represent proxy\nbots. The dotted line shows the information flow between a harvester bot and the C2 layer.\n\nFinally, at the top of the hierarchy is the C2 layer, which\nis the source of commands and the end destination of stolen\ndata. Commands propagate downward from the C2 layer,\nthrough the C2 proxy layer to the proxy bots, where they\nare fetched by harvester bots. Similarly, data stolen by harvester bots is collected by the proxy bots, and periodically\npropagated up until it ultimately reaches the C2 layer.\nAs mentioned in Section 1, the main P2P network is divided into several virtual sub-botnets by a hardcoded subbotnet identifier in each bot binary. Since each of these\nsub-botnets is independently controlled, the C2 layer may\ncontain multiple command sources and data sinks.\n\n## 3 P2P Protocol\n\nThis section describes our analysis results on the Zeus\nP2P communication protocol. The results are based on Zeus\n\n\nvariants we tracked between February 2012 and July 2013.\nIn that time, several changes were made to the protocol by\nthe Zeus authors. The results presented here apply to all\nrecent P2P Zeus versions, except where noted differently.\nWe first provide a high level overview of the Zeus P2P\nprotocol in Section 3.1. Next, we describe the encryption\nused in Zeus traffic in Section 3.2. Sections 3.3 and 3.4\nprovide a detailed overview of the Zeus message structure.\nFinally, Section 3.5 describes in detail how the Zeus P2P\nprotocol operates.\n\n## 3.1 Overview\n\nAs mentioned in Section 1, the Zeus P2P network’s main\nfunctions are (1) to facilitate the exchange of binary and\nconfiguration updates among bots, and (2) to propagate lists\nof proxy bots. Most normal communication between bots\nis based on UDP. The exceptions are Command and Control (C2) communication between harvester bots and proxy\nbots, and binary/configuration update exchanges, both of\nwhich are TCP-based.\nBootstrapping onto the network is achieved through a\nhardcoded bootstrap peer list. This list contains the IP addresses, ports and unique identifiers of up to 50 Zeus bots.\nZeus port numbers range from 1024 to 10000 in versions\nafter June 2013, and from 10000 to 30000 in older versions.\nUnique identifiers are 20 bytes long and are generated at\ninfection time by taking a SHA-1 hash over the Windows\nComputerName and the Volume ID of the first hard-drive.\nThese unique identifiers are used to keep contact information for bots with dynamic IPs up-to-date.\nNetwork coherence is maintained through a push-/pullbased peer list exchange mechanism. Zeus generally prefers\nto push peer list updates; when a bot receives a message\nfrom another bot, it adds this other bot to its local peer\nlist if the list contains less than 50 peers. Bots in desperate need of new peers can also actively request them. In\nprinciple, the peer pushing mechanism facilitates peer list\npoisoning attacks against Zeus. However, as we will see in\nSections 3.2, 3.5.1 and 4, Zeus includes several resilience\nmeasures which severely complicate poisoning attacks.\nZeus bots check the responsiveness of their neighbors\nevery 30 minutes. Each neighbor is contacted in turn, and\ngiven 5 opportunities to reply. If a neighbor does not reply within 5 retries, it is deemed unresponsive, and is discarded from the peer list. During this verification round,\nevery neighbor is asked for its current binary and configuration file version numbers. If a neighbor has an update\navailable, the probing bot spawns a new thread to download\nthe update. Updates are signed using RSA-2048, and are\napplied after the bot has checked that the update’s embedded version number is higher than its current version. Thus,\nit is impossible to force bots to “update” to older versions.\n\n\n-----\n\nThe neighbor verification round is also used to pull peer\nlist updates if necessary. If the probing bot’s peer list contains less than 25 peers, it asks each of its neighbors for a\nlist of new neighbors. The returned peer lists can contain\nup to 10 peers. The returned peers are selected by minimal\nKademlia-like XOR distance to the requesting bot’s identifier [10]. However, we note that the Zeus P2P network\nis not a Distributed Hash Table, and apart from this XOR\nmetric the protocol bears no resemblance to Kademlia.\nIn case a Zeus bot finds all of its neighbors to be unresponsive, it attempts to re-bootstrap onto the network by\ncontacting the peers in its hardcoded peer list. If this also\nfails, the bot switches to a DGA backup channel, which can\nbe used to retrieve a fresh, RSA-2048 signed, peer list. Additionally, in recent variants of Zeus, the DGA channel is\nalso contacted if a bot is unable to retrieve updates for a\nweek or longer. This is a very important resilience feature,\nas it allows the botnet to recover from peer list poisoning\nattacks. The DGA mechanism is described in more detail in\nSection 4.\nAs mentioned, one of the most important functions of\nthe Zeus P2P network is to propagate lists of proxy bots.\nThese proxy bots are periodically selected from the general\nbot population, and are contacted by bots which need to\nfetch commands and drop stolen data. Like the peer list exchange mechanism, the proxy list mechanism is also push/pull-based. When a new proxy bot is appointed by the botmasters, an RSA-2048 signed push message is disseminated\nthrough the network to announce it.\nBots are commanded in two ways. (1) As mentioned before, harvester bots can contact proxy bots to retrieve commands. (2) Configuration file updates can also be used to\nconvey commands to the bots.\n\n## 3.2 Encryption\n\nUntil recently, bot traffic was encrypted using a rolling XOR\nalgorithm, known as “visual encryption” from centralized\nZeus [18], which encrypts each byte by XORing it with the\npreceding byte. Since June 2013, Zeus uses RC4 instead\nof the XOR algorithm, using the recipient’s bot identifier\nas the key. Rogue bots used by analysts to infiltrate the\nnetwork typically use continuously changing bot identifiers\nto avoid detection [11]. The new RC4 encryption is a problem, because a rogue bot may not always know under which\nidentifier it is known to other bots, thus preventing it from\ndecrypting messages it receives. In addition, RC4 increases\nthe load on botnet detection systems which rely on decrypting C2 traffic [12].\nZeus uses RSA-2048 to sign sensitive messages originating from the botmasters, such as updates and proxy announcements. In all P2P Zeus variants we studied, update\nexchanges and C2 messages feature RC4 encryption over\n\n\nan XOR encryption layer. For these messages, either the\nidentifier of the receiving bot or a hardcoded value is used\nas the RC4 key, depending on the message type.\n\n## 3.3 Message Structure\n\nThis section describes the structure of Zeus network messages. Zeus messages vary in size, but have a minimum\nlength of 44 bytes. The first 44 bytes of each message form\na header, while the remaining bytes form a payload concatenated with padding bytes. The Zeus message structure\nis illustrated in Figure 2. The following message structure\ndiagrams are to scale. Shaded areas do not represent part of\nthe message structure itself, but serve to align the fields in\nthe figures.\n\nrnd TTL LOP type\n(1B) (1B) (1B) (1B)\n\nsession ID (20 bytes)\n\nsource ID (20 bytes)\n\npayload + padding\n\n...\n\nFigure 2: The Zeus message structure.\n\n3.3.1 rnd (random)\n\nIn Zeus versions which use the XOR encryption, this byte\nis set to a random value. This is done to avoid leaking information, since the XOR encryption leaves the first byte in\nplaintext. In Zeus versions which use RC4 for message encryption, this byte is set to match the first byte of the session\nID, so that it can be used to confirm that packet decryption\nwas successful. Backward compatibility with older bots is\nachieved by falling back to the XOR encryption if RC4 decryption fails.\n\n3.3.2 TTL (time to live)\n\nThe TTL field is usually unused, in which case it is set to\na random value, or to the second byte of the session ID for\nvariants using RC4 encryption. However, for certain message types, this field serves as a time to live counter. A bot\nreceiving a message using the TTL field forwards it with a\ndecremented TTL. This continues iteratively until the TTL\nreaches zero.\n\n3.3.3 LOP (length of padding)\n\nZeus messages end with a random amount of padding bytes.\nThis is most likely done to confuse signature-based intrusion detection systems. The length of padding field indicates the number of padding bytes appended to a message.\n\n|Col1|rnd (1B)|TTL (1B)|LOP (1B)|type (1B)|\n|---|---|---|---|---|\n|session ID (20 bytes)|||||\n|source ID (20 bytes)|||||\n|payload + padding . . .|||||\n\n\n-----\n\n3.3.4 type\n\nThis field indicates the type of the message. The message\ntype is used to determine the structure of the payload, and in\ncertain cases the meaning of some of the header fields, such\nas the TTL field. Valid Zeus message types are described in\nSection 3.4.\n\n3.3.5 session ID\n\nWhen a Zeus bot sends a request to another bot, it includes\na random session ID in the request header. The corresponding reply will include the same session ID, and incoming\nreplies with unexpected session ID values are discarded.\nThis makes it more difficult for attackers to blindly spoof\nZeus messages.\n\n3.3.6 source ID\n\nThis field contains the 20 byte bot identifier of the sending\nbot. The source ID field facilitates the push-based peer list\nupdate mechanism, where a bot receiving a message adds\nthe sender of the message to its peer list in case the peer list\ncontains less than 50 peers.\n\n3.3.7 payload\n\nThis is a variable-length field which contains a payload dependent on the message type. The structures of relevant\nmessage payload types are described in detail in Section 3.4.\n\n3.3.8 padding\n\nThis field contains a random number of random (non-zero)\npadding bytes. The number of padding bytes is specified in\nthe length of padding field in the message header.\n\n## 3.4 Payload Structure\n\nIn this section, we describe the structure and usage of the\nmost relevant Zeus message types. Each of these message\ntypes is communicated over UDP, except for C2 messages\nand updates, which are exchanged over a TCP connection.\n\n3.4.1 Version request (type 0x00)\n\nVersion request messages are used to request a bot’s current\nbinary and configuration file version numbers. These messages usually contain no payload, but may contain a payload\nconsisting of a little endian integer with value 1, followed\nby 4 random bytes. Such a payload serves as a marker to indicate that the requesting peer wants to receive a type 0x06\nproxy reply message (see Section 3.4.7).\n\n\n3.4.2 Version reply (type 0x01)\n\nA version reply contains the version numbers of the binary\nand configuration files of the sender. The binary version indicates the sender’s Zeus version, while the configuration\nfile version indicates the sender’s configuration file version.\nA TCP port is also sent, which may be contacted to download the updates via TCP, although some Zeus variants also\nsupport using UDP for this (see Sections 3.4.5 and 3.4.6).\nVersion replies end with 12 random bytes. The reply structure is shown in Figure 3.\n\nbinary version (4 bytes)\n\nconfig file version (4 bytes)\n\nTCP port (2 bytes)\n\nrandom (12 bytes)\n\nFigure 3: Version reply payload (22 bytes).\n\n3.4.3 Peer list request (type 0x02)\n\nPeer list requests (Figure 4) are used to request new peers\nfrom other bots. Zeus only sends active peer list requests if\nits peer list is becoming critically short (less than 25 peers).\nOtherwise, bots typically rely on storing the senders of incoming requests.\nThe payload of a peer list request consists of a 20 byte\nidentifier, followed by 8 random bytes. The responding peer\nwill return the peers from its own peer list that are closest to\nthe requested identifier.\n\nidentifier (20 bytes)\n\nrandom (8 bytes)\n\nFigure 4: Peer list request payload (28 bytes).\n\n3.4.4 Peer list reply (type 0x03)\n\nPeer list replies contain 10 peers from the responding peer’s\npeer list which are closest to the requested identifier. If the\nresponding peer knows fewer than 10 peers, then as many\npeers as possible (potentially zero) are returned, and any remaining peer slots are zeroed out. For each returned peer,\nthe payload format is as shown in Figure 5. Zeus supports\nboth IPv4 and IPv6, but in practice we have observed very\nfew IPv6 peers. The IP type field indicates whether the peer\nis reachable via IPv4 (set to 0) or IPv6 (set to 2). The remaining fields contain the peer’s identifier, IP address and\nUDP port. Any unused fields are randomized.\n\n|identifier (20 bytes) random (8 bytes)|Col2|Col3|\n|---|---|---|\n||random (8 bytes)||\n\n\n-----\n\n|Col1|IP type (1B)|\n|---|---|\n\n|IPv4 addr (4 bytes)|IPv4 port (2B)|\n|---|---|\n\n\nFigure 5: Peer struct (45 bytes).\n\n3.4.5 Data request (type 0x04/0x68/0x6A)\n\nA UDP data request payload, shown in Figure 6, starts with\na single byte indicating the kind of requested data. This byte\nis set to 1 for a configuration file download, or to 2 for a binary update. The offset field indicates the word offset into\nthe data at which transmission should start, and the size field\nspecifies how many data bytes should be sent. TCP data requests consist of a message header with type 0x68 for a\nbinary request, or type 0x6A for a configuration request.\n\ntype (1B)\n\noffset (2 bytes) size (2 bytes)\n\nFigure 6: Data request payload (5 bytes).\n\n3.4.6 Data reply (type 0x05/0x64/0x66)\n\nUDP data transfers (type 0x05) are sent in chunks of 1360\nbytes, until no more data is available. If a bot receives a data\nreply containing less than 1360 data bytes, it assumes that\nthis is the last data block, and ends the download. If a data\nreply takes longer than 5 seconds to arrive, the download\nis aborted, and the maximum total size of any download\nis 10MB. These constraints mean that it is not possible to\nlaunch “tarpit” attacks, where bots are tied up by very slow\nand never ending downloads.\nEach data reply (Figure 7) starts with a 4 byte randomly\nchosen file identifier, followed by the requested data. The\ntransmitted files end with an RSA-2048 signature over the\nMD5 hash of the plaintext data, and are encrypted with RC4\nusing a hardcoded key on top of an XOR encryption layer.\nBefore applying an update, Zeus checks that the version\nnumber contained in the update is strictly higher than its\ncurrent version number. This means that it is not possible to\nmake Zeus bots revert to older versions.\nTCP data transfers start with a message header of type\n0x64 for a binary update, or 0x66 for a configuration update, followed by the RC4 encrypted data.\n\n\nFigure 7: Data reply payload (length varies).\n\n3.4.7 Proxy reply (type 0x06)\n\nProxy replies return proxy bots in response to version requests carrying a proxy request marker. A proxy reply can\ncontain up to 4 proxy bot entries, each of which is RSA2048 signed. Each proxy entry is formatted as shown in\nFigure 8. The format is similar to that used in peer list\nreplies, except that the IP type field is 4 bytes long, and\nthere is an RSA signature at the end of each proxy entry.\n\n3.4.8 Proxy announcement (type 0x32)\n\nProxy announcements are similar to proxy replies, but are\nactively pushed through the Zeus network by bots which\nare appointed as proxies by the botmasters. Newly appointed proxy bots announce themselves to all their neighbors, which pass on the message to all their neighbors, and\nso on. This continues until the TTL field (Section 3.3)\nreaches zero. The TTL field has an initial value of 4 for\nproxy announcements. Thus, proxy announcements propagate very rapidly, although they cannot reach NATed bots\ndirectly. Proxy announcements contain a single proxy entry\nof the same format used in type 0x06 messages, as shown\nin Figure 8.\n\nIP type (4 bytes)\n\nproxy ID (20 bytes)\n\nIPv4 addr (4 bytes) IPv4 port(2B)\n\nIPv6 addr (16 bytes)\n\nIPv6 port\n(2B)\n\nRSA signature (256 bytes)\n\n..\n.\n\nFigure 8: Proxy struct (304 bytes).\n\n3.4.9 C2 message (type 0xCC)\n\nUnlike most message types, C2 messages are only exchanged between harvester bots and proxy bots, and are\nexchanged over TCP. C2 messages are used as wrappers\nfor HTTP messages. Because of this, we suspect that the\n\n|Col1|Col2|type (1B)|\n|---|---|---|\n|offset (2 bytes)|size (2 bytes)||\n\n|IPv4 addr (4 bytes)|IPv4 port (2B)|\n|---|---|\n\n\n-----\n\ncommunication between proxy bots and the C2 proxy layer\nis HTTP-based. The HTTP-based C2 protocol is heavily\nbased on the C2 protocol used in centralized Zeus [2, 6].\nAn example C2 HTTP header for a command request is\nshown in Figure 9. The X-ID field specifies the sub-botnet\nfor which a command is being requested.\n\nPOST /write HTTP/1.1\nHost: default\nAccept-Encoding:\nConnection: close\nContent-Length: 400\nX-ID: 100\nFigure 9: C2 HTTP header.\n\nThe HTTP header is followed by an HTTP payload,\nwhich consists of several, optionally zlib-compressed, data\nfields. The payload begins with a header specifying the payload size and flags, and the number of data fields that follow.\nThe payload header ends with an MD5 hash of the combined data fields, which is used to verify message integrity.\nEach data field is XOR encrypted, and starts with a\nheader specifying the field type, flags, and compressed and\nuncompressed sizes. After the header comes the actual data,\nthe structure of which is dependent on the field type.\nC2 request messages typically contain several status and\ninformation fields about the requesting bot. Typical fields\nincluded in C2 requests are shown in Table 1. Note that\nthe type numbers of data fields are completely independent\nfrom Zeus message type numbers.\n\nType Content\n\n0x65 System name and volume ID\n0x66 Bot identifier\n0x67 Infecting spam campaign\n0x6b System timing information\n0x77 Stolen data\n\nTable 1: Typical C2 request fields.\n\nThe most important data field contained in a C2 response\nis the command field, which has type 0x01. It contains\nan MD5 hash used to verify integrity of the command, followed by the command itself in the form of an ASCII-string.\nNotable command strings are listed in Table 2.\n\nCommand Meaning\n\nuser execute Execute file at URL\nuser certs get Steal crypto certificates\nuser cookies get Steal cookies\nddos url DDoS a given URL\nuser homepage set Set homepage to URL\nfs pack path Upload local files to botmaster\nbot bc add Open VNC server\n\nTable 2: Notable C2 command strings.\n\n\nAs can be seen from Table 2, Zeus supports a diverse\nset of commands, which goes far beyond that of a typical\nbanking trojan. The supported commands include dropping\nfiles, launching DDoS attacks, providing remote access to\nthe botmasters, and stealing a plethora of credentials. Aside\nfrom banking credentials, we have observed Zeus stealing\nSkype and MSN database files, as well as Bitcoin wallets.\n\n## 3.5 Communication Patterns\n\nEach Zeus bot runs a passive thread, which listens for incoming requests, as well as an active thread, which periodically generates requests to keep the bot up-to-date and\nwell-connected. We describe the behavior of each of these\nthreads in turn.\n\n3.5.1 Passive thread\n\nEvery Zeus bot listens for incoming messages in its passive thread. A Zeus bot receiving an incoming request attempts to handle this request as described in Section 3.4.\nThe sender of any successfully handled request is considered for addition to the receiving bot’s peer list. This is the\nmain mechanism used by externally reachable Zeus bots to\nlearn about neighbors, and it is also how new bots introduce themselves to the network. If the receiving bot has\nfewer than 50 neighbors, then it always adds the sender of\nthe request to its peer list. Additionally, if the identifier of\nthe sender is already present in the peer list, then the corresponding IP address and port are updated. This is done to\naccommodate senders with dynamic IPs and discard stale\ndynamic IPs. If the identifier of the sender is not yet known,\nbut the peer list already contains 50 peers or more, then the\nsending peer is stored in a queue of peers to be considered\nfor addition during the next neighbor verification round (see\nSection 3.5.2).\nBefore adding a new peer to the peer list, a number of\nsanity checks are performed. First, only peers which have a\nsource port in the expected range are accepted. NATed bots\nmay make it into the peer lists of other bots, if they happen\nto choose a port in the valid range. Additionally, only one\nIP address per /20 subnet may occur in a bot’s peer list at\nonce. This defeats peer list poisoning attempts which use\nIP ranges within the same subnet. Recent versions of Zeus\nalso include an automatic blacklisting mechanism, which\nblacklists IPs that contact a bot too frequently in a specified\ntime window. This mechanism further complicates efficient\ncrawling and poisoning of the network.\nWhen a type 0x32 proxy announcement arrives, its signature is first checked for validity. If the message passes\nthe check, the TTL field is decremented and the message is\nforwarded to all known neighbors if the TTL is still positive. Furthermore, new proxy bots which pass verification\n\n\n-----\n\nare considered for addition to the receiving bot’s proxy list.\nThe proxy list is similar to the peer list, but is maintained\nseparately. If the identifier of the new proxy is already in\nthe proxy list, then the corresponding IP address and port\nare updated. Otherwise, if a proxy list entry is found that\nis over 100 minutes older than the new proxy, this entry is\noverwritten with the new proxy (this is not done for type\n0x06 proxy replies). In any other case, the new proxy is\nadded to the end of the proxy list. Finally, the proxy list is\ntruncated to its maximum length of 10 entries, effectively\ndiscarding the new proxy if the proxy list was already 10\nentries long.\n\n3.5.2 Active thread\n\nThe Zeus active communication pattern consists of a large\nloop which repeats every 30 minutes. The function of the\nactive communication loop is to keep Zeus itself, as well as\nthe peer list and proxy list, up to date.\nIn each iteration of the loop, Zeus queries each of its\nneighbors for their binary and configuration file versions.\nThis step serves to keep the bot up to date, and to check each\nneighbor for responsiveness. If Zeus knows fewer than 4\nproxy bots, it piggybacks a proxy request marker with each\nversion request. Each peer is given 5 chances to respond to\na version request. If a peer fails to answer within the maximum number of retries, Zeus checks if it has working Internet access by attempting to contact www.google.com or\nwww.bing.com. If it does, the unresponsive peer is discarded. If the peer responded and is found to have an update\navailable, the update is downloaded in a separate thread.\nAfter version querying all peers in its peer list, Zeus proceeds to handle any pending peers which were queued from\nincoming requests (see Section 3.5.1). Pending peers are\nonly handled if the peer list contains fewer than 50 peers,\nand the procedure is stopped as soon as the peer list reaches\nlength 50. Each pending peer is sent a single version request, and is added to the peer list if it responds.\nFinally, if the peer list contains fewer than 25 peers, the\nbot will actively send peer list requests to each of its neighbors until the peer list reaches a maximum size of 150 peers.\nThis is only done once every 6 loop cycles (3 hours), and is\nan emergency measure to prevent the bot from becoming\nisolated. If, despite this effort, a bot does find itself isolated, it will attempt to recover connectivity by contacting\nits hardcoded bootstrap peer list. If this also fails, the bot\nwill enter DGA mode, as further described in Section 4.\n\n## 4 Domain Name Generation Algorithm\n\nAs mentioned in Section 3.1, Zeus contains a Domain Generation Algorithm, activated if all of a bot’s neighbors are\nunresponsive, or the bot cannot fetch updates for a week.\n\n\nThe DGA generates domains where Zeus can download a\nfresh RSA-2048 signed peer list. The DGA is a very potent backup mechanism, which makes long term poisoning\nor sinkholing attacks against Zeus very difficult [11].\n\n## 4.1 Algorithm Details\n\nThe Zeus Domain Generation Algorithm generates 1000\nunique domains per week. A bot entering the DGA starts\nat a random position in the current week’s domain list and\nsequentially tries all domains until it finds a responsive domain. The DGA uses top-level domains taken from the\nset {biz, com, info, net, org, ru}. The Zeus DGA\nbears some resemblance to the DGA of Murofet, a malware\nknown to be related to centralized Zeus [8].\n\nfor(i = 0; i < 1000; i++) {\nS[0] = (year + 48) % 256; S[1] = month;\nS[2] = 7 * (day / 7); *[(][int]*[)&S[3] = i;]\n\n/* convert hash to domain name */\nname = \"\"; hash = md5(S);\nfor(j = 0; j < len(hash); j++) {\nc1 = (hash[j] & 0x1F) + ’a’;\nc2 = (hash[j] / 8) + ’a’;\ni f (c1 != c2 && c1 <= ’z’) name += c1;\ni f (c1 != c2 && c2 <= ’z’) name += c2;\n}\n\n/* select TLD for domain */\n\ni f (i % 6 == 0) name += \".ru\";\nelse i f (i % 5 != 0) {\ni f (i & 0x03 == 0) name += \".info\";\nelse i f (i % 3 != 0) {\ni f ((i % 256) & 0x01 != 0) name += \".com\";\nelse name += \".net\";\n} else name += \".org\";\n} else name += \".biz\";\n\ndomains[i] = name;\n}\n\nFigure 10: The P2P Zeus Domain Name Generation Algorithm.\n\nThe Zeus DGA is shown in C-like pseudocode in Figure 10. The code shown generates all 1000 domains for\na given week. The generation of a domain name starts by\ntaking the MD5 hash over the concatenation of (transformations of) the year, month, day, and domain index. The MD5\nhash is then used to generate a domain name of at most\n32 lower case alphabetic characters. Finally, the domain is\ncompleted by selecting one of the six top-level domains and\nconcatenating it to the domain name.\n\n## 5 Related Work\n\nEarly insights on P2P Zeus were provided by Lelli [9] and\nabuse.ch [17]. Special attention to the lifecycle of Zeus\nhas been given by Stone-Gross [15].\nThe most recent previous account of P2P Zeus that we\nknow of is given in a technical report by CERT.pl [3]. The\nresearch of CERT.pl took place independently from, but\n\n\n-----\n\nconcurrently with, our own research. While CERT.pl has\nfocused on the P2P Zeus malware as a whole, we provide a\nmore in-depth account focused specifically on the peer-topeer protocol and its resilience. Additionally, the CERT.pl\nreport predates the Zeus protocol change of June 2013, and\nthus does not include information on the new protocol features and encryption mechanism.\nOur previous work has provided a comparison of the\nZeus P2P protocol to other P2P botnet protocols [11]. Our\ncurrent work differs in that we provide a much more detailed insight into the functionality and resilience of P2P\nZeus in particular. To the best of our knowledge, our work\nis the most detailed account of P2P Zeus to date.\n\n## 6 Conclusion\n\nP2P Zeus is a significant evolution of earlier Zeus variants.\nCompared to traditional centralized versions of Zeus, P2P\nZeus is much more resilient against takedown attempts. Potential countermeasures against P2P Zeus are complicated\nby its application of RSA-2048 signatures to mission critical messages, and rogue bot insertion is complicated by\nthe Zeus message encryption mechanism which makes the\nuse of random bot identifiers impossible. Poisoning attempts are forced to use widely distributed IPs due to a\nper-bot IP filter which only allows a single IP per /20 subnet. The network’s resilience against takedown efforts is\nfurther increased by its use of a Domain Generation Algorithm backup channel, and by an automatic blacklisting\nmechanism. P2P Zeus demonstrates that modern P2P botnets represent a new level of botnet resilience, previously\nunseen in centralized botnets.\n\n## Acknowledgements\n\nWe would like to thank Tillmann Werner for the collaboration on reversing the Zeus peer-to-peer protocol. We also\nthank Christian J. Dietrich and Tomasz Bukowski for sharing their insights with us. This work was supported by the\nEuropean Research Council Starting Grant “Rosetta” and\nthe EU FP7-ICT-257007 SysSec project.\n\n## References\n\n[1] M. Antonakakis, R. Perdisci, Y. Nadji, N. Vasiloglou, S. Abu-Nimeh,\nW. Lee, and D. Dagon. From Throw-Away Traffic to Bots: Detecting the Rise of DGA-Based Malware. In Proceedings of the\n21st USENIX Security Symposium (USENIX Sec’12), Bellevue, WA,\nUSA, 2012.\n\n[2] H. Binsalleeh, T. Ormerod, A. Boukhtouta, P. Sinha, A. Youssef,\nM. Debbabi, and L. Wang. On the Analysis of the Zeus Botnet\nCrimeware Toolkit. In Proceedings of the 8th Annual Conference\non Privacy, Security and Trust (PST’10), Ottawa, Ontario, Canada,\nAugust 2010.\n\n\n\n[3] CERT.pl. Zeus P2P Monitoring and Analysis, 2013. Technical Report. http://www.cert.pl/PDF/2013-06-p2prap_en.pdf.\n\n[4] D. Dagon, G. Gu, C. P. Lee, and W. Lee. A Taxonomy of Botnet\nStructures. In Proceedings of the 23rd Annual Computer Security\nApplications Conference (ACSAC’07), 2007.\n\n[5] D. Dittrich and S. Dietrich. P2P as Botnet Command and Control:\nA Deeper Insight. In Proceedings of the 3rd International Conference on Malicious and Unwanted Software (MALWARE’08), October 2008.\n\n[6] N. Falliere and E. Chien. Zeus: King of the Bots, 2009. Technical\nReport, Symantec.\n\n[7] R. Hund, M. Hamann, and T. Holz. Towards Next-Generation Botnets. In Proceedings of the 4th European Conference on Computer\nNetwork Defense (EC2ND’08), 2008.\n\n[8] K. Itabashi. How Trojan.Zbot.B!inf Uses the Crypto API, 2010.\nTechnical Report, Symantec. http://www.symantec.com/\nconnect/blogs/how-trojanzbotbinf-uses-cryptoapi.\n\n[9] A. Lelli. Zeusbot/Spyeye P2P Updated, Fortifying the Botnet,\n2012. Technical Report, Symantec. http://www.symantec.\ncom/connect/blogs/zeusbotspyeye-p2p-updatedfortifying-botnet.\n\n[10] P. Maymounkov and D. Mazi`eres. Kademlia: A Peer-to-Peer Information System Based on the XOR Metric. In Revised Papers from\nthe 1st International Workshop on Peer-to-Peer Systems (IPTPS’02),\n2002.\n\n[11] C. Rossow, D. Andriesse, T. Werner, B. Stone-Gross, D. Plohmann,\nC. Dietrich, and H. Bos. P2PWNED: Modeling and Evaluating the\nResilience of Peer-to-Peer Botnets. In Proceedings of the 34th IEEE\nSymposium on Security and Privacy (S&P’13), San Francisco, CA,\nUSA, May 2013.\n\n[12] C. Rossow and C. J. Dietrich. ProVeX: Detecting Botnets with Encrypted Command and Control Channels. In Proceedings of the 10th\nConference on Detection of Intrusions and Malware & Vulnerability\nAssessment (DIMVA’13), July 2013.\n\n[13] C. Rossow, C. J. Dietrich, H. Bos, L. Cavallaro, M. van Steen, F. C.\nFreiling, and N. Pohlmann. Sandnet: Network Traffic Analysis of\nMalicious Software. In Proceedings of the 1st ACM EuroSys Workshop on Building Analysis Datasets and Gathering Experience Returns for Security (BADGERS’11), 2011.\n\n[14] R. Sherstobitoff. Inside the World of the Citadel Trojan, 2013. Technical Report, McAfee.\n\n[15] B. Stone-Gross. The Lifecycle of Peer-to-Peer Zeus, 2012. Technical Report, Dell SecureWorks. http://www.secureworks.\ncom/cyber-threat-intelligence/threats/The_\nLifecycle_of_Peer_to_Peer_Gameover_ZeuS/.\n\n[16] D. Tarakanov. Ice IX: Not Cool At All, 2011. Technical Report,\nKaspersky Lab. http://www.securelist.com/en/blog/\n563/Ice_IX_not_cool_at_all.\n\n[17] abuse.ch. Zeus Gets More Sophisticated Using P2P Techniques,\n2011. Technical Report. http://www.abuse.ch/?p=3499.\n\n[18] J. Wyke. What is Zeus?, 2011. Technical Report, SophosLabs.\n\n[19] G. Yan, S. Chen, and S. Eidenbenz. RatBot: Anti-enumeration Peerto-Peer Botnets. In Lecture Notes in Computer Science, vol. 7001,\n2011.\n\n[20] T.-F. Yen and M. K. Reiter. Revisiting Botnet Models and Their Implications for Takedown Strategies. In Proceedings of the 1st Conference on Principles of Security and Trust (POST’12), 2012.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "http://www.syssec-project.eu/m/page-media/3/zeus_malware13.pdf"
    ],
    "report_names": [
        "zeus_malware13.pdf"
    ],
    "threat_actors": [
        {
            "id": "81dde5cc-c29f-430d-8c6e-e5e92d5015e7",
            "created_at": "2022-10-25T16:07:23.704358Z",
            "updated_at": "2025-03-27T02:02:09.932453Z",
            "deleted_at": null,
            "main_name": "Harvester",
            "aliases": [],
            "source_name": "ETDA:Harvester",
            "tools": [
                "Agentemis",
                "Cobalt Strike",
                "CobaltStrike",
                "Graphon",
                "Metasploit",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041303,
    "ts_creation_date": 1378290723,
    "ts_modification_date": 1378290723,
    "files": {
        "pdf": "https://archive.orkl.eu/12793d7ddf96e8d9fa2f481966ae3d1022186fc0.pdf",
        "text": "https://archive.orkl.eu/12793d7ddf96e8d9fa2f481966ae3d1022186fc0.txt",
        "img": "https://archive.orkl.eu/12793d7ddf96e8d9fa2f481966ae3d1022186fc0.jpg"
    }
}