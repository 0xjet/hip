{
    "id": "b80b9f82-be6b-4008-a229-5fe5e4c27051",
    "created_at": "2023-01-12T15:00:46.686161Z",
    "updated_at": "2025-03-27T02:05:36.868007Z",
    "deleted_at": null,
    "sha1_hash": "fd5908af1638871b302e884797fa979a53e249fd",
    "title": "2020-12-08 - The why, what, and how of threat research",
    "authors": "",
    "file_creation_date": "2022-05-28T01:59:14Z",
    "file_modification_date": "2022-05-28T01:59:14Z",
    "file_size": 278794,
    "plain_text": "# See what it's like to have a partner in the fight.\n\n**redcanary.com/blog/threat-research-questions**\n\nIn a recent [blog post, we introduced you to AtomicTestHarnesses, one of the ways Red](https://redcanary.com/blog/introducing-atomictestharnesses/)\nCanary’s threat research team iteratively improves detection coverage. In this post, we will\nhighlight the philosophy and methodology that goes into understanding an attack technique,\ndefining its scope, and developing test harness code for the purpose of validating detection\npipelines. This process encourages analysts to ask more specific, mindful questions in\npursuit of their detection and prevention goals.\n\n## Attack technique research workflow in action\n\nLong before implementing code, you should have a good sense of the scope of the\ntechnique at hand, and that’s what this research process helps to uncover. Continuing the\n[thread from our last blog post, using MSHTA as our example, we’ll want to ask ourselves,](https://attack.mitre.org/techniques/T1218/005/)\n“from a detection perspective, how would we think about detecting suspicious usage of\n**MSHTA?” That being a very broad question, we need to scope the problem to avoid going**\ndown too many research rabbit holes that may ultimately deviate from the technique at\nhand.\n\nSo to start scoping, we ask ourselves the following question: what exactly, at a technical\n**level, do we define MSHTA to be?**\n\n### Step 1: Define and scope the technique\n\n\n-----\n\nIn order to define what MSHTA is, we start with what we implicitly know it to be and then ask\nleading questions from there. The easiest way to start with what we know is to look to open\nsource intelligence and identify how attackers abuse MSHTA. For example, we know that\nattackers execute malicious code with MSHTA using both `mshta.exe —the supported,`\nbuilt-in utility for doing so—and `rundll32.exe, which appears (“appears” being an`\nintentionally speculative word requiring clarification) to be a non-standard method of\nexecuting HTA content by [calling the RunHTMLApplication function within](https://thisissecurity.stormshield.com/2014/08/20/poweliks-command-line-confusion/) `mshtml.dll .`\n\nSo is MSHTA defined by `mshta.exe and` `rundll32.exe (and nothing else)? Well, not`\nquite, since `rundll32.exe is a general purpose utility used to execute specifically crafted`\nDLL export functions. The `rundll32.exe execution, however, can offer a hint as to the`\ncore of what makes MSHTA… MSHTA. Some light reversing of `mshta.exe reveals that`\nthe executable is no more than a simple wrapper for the `RunHTMLApplication function in`\n```\nmshtml.dll :\n\n```\nThe common component that invokes HTA functionality appears to be the\n```\nRunHTMLApplication function. After arriving to that conclusion, we now have the required\n\n```\nvocabulary to ask the following questions to help further refine our scope:\n\n**Can any other built-in utilities be used to invoke** `RunHTMLApplication`\n**functionality?**\n**What advantage, if any, would an attacker have in building their own tool to**\n**interface with the** `RunHTMLApplication function?`\n\n**Expand the scope beyond in-the-wild usage**\n\n\n-----\n\nCan any other built-in utilities be used to invoke HTA functionality? The short answer is, no.\nWe performed a sweep of all binaries that might invoke the `RunHTMLApplication function`\nand found no additional binaries that would yield direct execution of HTA script code. Does\nthat mean that no such binary exists? Of course not. But we were content with the level of\ndue diligence applied to answer the question at the time it was posed. And if anyone\ndiscovered another signed HTA host binary that could be easily weaponized, we could very\nquickly improve our coverage by incorporating that variant into our existing automation of\nthe technique. With threat research and detection engineering, as with any other discipline,\nwe must always remain mindful to not let perfect be the enemy of good. “Perfection”\ncomprises an infinite number of rabbit holes for which there is no fixed destination.\n\nWith threat research and detection engineering, we must always remain mindful to not\nlet perfect be the enemy of good. “Perfection” comprises an infinite number of rabbit\nholes for which there is no fixed destination.\n\n**Finalize the initial scope**\n\nFrom an evasion perspective, we pondered what advantage an attacker would have in\nbuilding their own tool to interface with the `RunHTMLApplication function. As trivial as it`\nwould be for an attacker to implement their own code to invoke malicious HTA content, we\nwere unclear on what it would buy them if they already have the means to execute arbitrary\ncode. In other words, what additional evasion opportunities would it buy an\n**adversary? We couldn’t come up with a compelling evasion justification.**\n\nNow, because we arrived at this conclusion, does that mean that we should not care about\nattackers directly interfacing with the `RunHTMLApplication function? Absolutely not. In`\nfact, were an attacker to do such a thing, we might be able to detect such behavior as an\n[anomaly. Ultimately though, as Jeffrey Snover eloquently puts it, “to ship is to choose.”](https://twitter.com/jsnover)\n\nTo decide on what HTA functionality to automate, we needed to define the scope of what\nwould be implemented. After considering our questions and subsequent investigations, we\ndecided to focus automation of HTA script code around only `mshta.exe and`\n```\nrundll32.exe . We are confident in this decision; it buys us a ton of coverage, and we can\n\n```\neasily extend our automation to support new variations should they become operationally\nviable.\n\n### Step 2: Identify technique variations\n\nWith the scope defined, now what? This is where the fun begins! Now that we’ve narrowed\nour scope down to automating HTA script execution via `mshta.exe and` `rundll32.exe,`\nwe can now ask more targeted questions. Specifically, what inputs does an attacker have\n**control over to influence execution and potentially evade naive detections? This**\n\n\n-----\n\nquestion often involves more in-depth research, and in the interest of time, we won t delve\ninto the technical specifics. Through the course of our efforts, we honed in on the following\nattributes that an attacker had direct control over:\n\n1. The HTA filename can be any name and any file extension that isn’t associated with\n\n[the “text/plain” MIME type (e.g., an extension of .txt will result in displaying but not](https://tools.ietf.org/html/rfc1521#section-7.1.2)\nexecuting HTA script content).\n2. A URI can be specified from where HTA content is first downloaded. It turns out that a\n\n[URI in Windows terminology is an instance of a protocol handler, a piece of code that](https://docs.microsoft.com/en-us/windows/win32/search/-search-3x-wds-extidx-prot-implementing)\nis responsible for parsing and interpreting strings that begin with the following format:\n“handler_name:” (e.g., “https:”, “javascript:”, “about:”, etc.)\n3. Different script engines can be supplied in HTA content. We needed to determine\n\nwhat script engines were available and which ones facilitated the execution of\narbitrary code. This script engine dictates a specific DLL image load that would occur\n(e.g., `vbscript.dll,` `jscript9.dll,` `jscript.dll, etc.).`\n4. Protocol handlers (e.g., “vbscript”, “javascript”, “about”) can be specified to influence\n\nhow inline HTA content can be executed, i.e., without needing to drop HTA content to\ndisk. We needed to enumerate the available protocol handlers and then identify which\nones led to direct code execution.\n[5. HTA content can be embedded and executed from within other file formats. Learning](http://blog.sevagas.com/?Hacking-around-HTA-files)\n\n[of this is also what led to our discovery of CVE-2020-1599.](https://twitter.com/mattifestation/status/1326228491302563846)\n6. HTA content can be executed remotely via UNC paths.\n7. HTA exposes a COM interface that is remotely accessible, making HTA execution a\n\n[viable option for lateral movement.](https://codewhitesec.blogspot.com/2018/07/lethalhta.html)\n8. .hta files have a default file handler, meaning that they can be executed by double\n\nclicking on them or invoking them with “explorer.exe foo.hta”.\n9. An attacker has full control over the path and filename of `mshta.exe and`\n```\n   rundll32.exe .\n\n```\nEvery single one of the variations in which an attacker realistically has control over inputs to\ninfluence HTA script execution with `mshta.exe and` `rundll32.exe ought to be`\nautomated in a way that is sufficiently abstracted to allow non-subject matter experts control\nover those points of influence. And this is exactly what we implemented in the HTA test\nharness in AtomicTestHarnesses, `Invoke-ATHHTMLApplication .`\n\n\n-----\n\nTaking stock in what aspects of a technique an attacker has control over, you may get a\nbetter sense of two things:\n\n1. Potentially naive detection logic that an attacker could easily evade\n2. The variables that an attacker has less or no control over\n\nIn an ideal scenario, the most robust detection logic accounts for everything an attacker has\nlittle or no control over. Without performing this level of due diligence with technique\nresearch, it can be very difficult to comprehend or quantify how a robust detection would\ntake shape. A robust detection has an arbitrarily longer shelf life than one that does not take\nattacker-controlled inputs into account.\n\nThe most robust detection logic accounts for everything an attacker has little or no\ncontrol over.\n\n\n-----\n\n### Step 3: Identify technique choke points\n\nNow that we have a clearer sense of the set of inputs an attacker has to make use of an\nattack technique, let’s talk about outputs. What is the set of outputs that a technique\n**might generate that we can potentially use to build detections from? This is another**\none of those questions that is overly broad and requires a little bit of deliberate scoping. A\nmore specific question that we might consider first is, what conditions must be satisfied\n**in order to successfully make use of an attack technique? In the case of MSHTA, within**\nour established scope of `mshta.exe and` `rundll32.exe, the following conditions must`\nbe met:\n\n1. `mshta.exe or` `rundll32.exe must execute.`\n2. Command-line arguments are supplied to `mshta.exe or` `rundll32.exe .`\n3. `mshtml.dll must load as a first step in order to execute script content.`\n4. One of the DLLs associated with script execution will load depending upon the script\n\nengine specified in the HTA. This will be either `vbscript.dll or` `jscript.dll`\nbased on our investigation.\n\nHaving a clearer sense of the components required enables us to more narrowly focus\npotential detection logic and to have a better idea of what, if any, options are available to\nprevent this technique from being abused. After all, if any link of this chain can be severed,\nthe technique fails. We refer to these “minimum viable” components as attack technique\n“choke points.”\n\nFrom a detection perspective, now that we know the necessary components, we can start\nto identify some potential data needs:\n\n1. We’ll need process creation optics that ideally include optics related to the aspects of\n\nthe technique that an attacker has control over, which include—but are not limited to—\nthe following:\n\n**Executable filename: So that we can identify when** `mshta.exe or`\n```\n      rundll32.exe run and whether or not the adversary attempts to rename the\n\n```\nfile.\n**Executable path: So that we can identify if** `mshta.exe or` `rundll32.exe are`\nexecuting from an expected directory or copied to a location in an attempt to\nevade naive detection logic.\n**Process command line: Because we scoped our research to** `mshta.exe and`\n```\n      rundll32.exe execution, command-line optics are crucial since an attacker\n\n```\nmust supply their malicious HTA script code via the command line. Are there\nmethods of evading command-line logging? Yes, but that is a separate attack\ntechnique that would warrant its own dedicated research and detection initiative.\nRemember that we must not fall into too many rabbit holes.\n\n\n-----\n\n2. It could be useful to have insight into processes that load `mshtml.dll . While the`\n\nloading of `mshtml.dll is implied in our current scope of` `mshta.exe and`\n```\n   rundll32.exe (in the case of RunHTMLApplication being executed), this insight\n\n```\nwould facilitate future threat hunting. For example, how do we know that attackers will\nonly ever use or abuse `mshta.exe or` `rundll32.exe ?`\n3. Having insight into processes that load related scripting engine components could be\n\nuseful down the line, but currently would only be used to differentiate VBScript versus\nJScript execution. However, knowing that these DLLs load does point to the ability of\n[WSH script components to log script content via the AMSI interface.](https://posts.specterops.io/antimalware-scan-interface-detection-optics-analysis-methodology-858c37c38383)\n\nFrom a prevention perspective, we have an initial idea of what components could possibly\nbe blocked. For example, would it be possible to block the execution of `mshta.exe or`\n```\nrundll32.exe within a specific organization? Aside from outright blocking executables\n\n```\nthough, we must consider other preventative mechanisms. Through reverse engineering the\n```\nRunHTMLApplication function in mshtml.dll (again, the core component required to\n\n```\n[invoke HTA functionality), we discovered that if Windows Defender Application Control](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control)\n[(WDAC) is in enforcement mode, HTA execution is outright banned. This means that even if](https://twitter.com/mattifestation/status/1106650783028838401)\nan attacker discovered another executable that invoked HTA functionality, or if they\ninterfaced with the `RunHTMLApplication itself, by default, HTA execution would be`\nblocked. That, in our book, is a very robust mitigation.\n\n## Conclusion\n\nIn summary, this research methodology offers the following outcomes:\n\nThe research process focuses as much on the constant refinement of scope as it\ndoes gaining further understanding of the technique at hand.\nEnumeration of attack technique variations serves to offer clear insight into the\naspects of a technique that an attacker has direct control over and, conversely, what\nthey have little-to-no control over. In an ideal scenario, a detection engineer has the\nopportunity to build the most robust detection (i.e., resilient against evasion) using\nlogic that depends as little as possible on aspects of a technique that an attacker has\ncontrol over.\nTactical identification of attack technique “choke points” determines the minimum set\nof technical components required where, if any one of those links in the chain breaks,\nweaponization of the technique fails.\nKnowledge of attack technique choke points further refines the scope of research,\nwhich further refines scope for detection and prevention.\n\nWhile we used MSHTA as an illustrative example, this research process can be applied\nequally to any attack technique. Effective research is built on a foundation of asking\nspecific, deliberate questions in an attempt to reduce a broad objective (e.g., “can we detect\ntechnique X?”) into something more achievable, measurable, and resilient against evasion.\n\n\n-----\n\n## Appendix\n\nHere is a sampling of the ad-hoc scripts we wrote during our research process to answer\nsome of the questions that arose. Please excuse the lack of cleanliness, as these were\ndesigned as one-time use scripts to answer very specific questions.\n\n### Identifying built-in utilities that incorporate HTA functionality\n\nThe following code was used to identify any other built-in application beyond `mshta.exe`\nthat calls `RunHTMLApplication :`\n```\nGet-CimInstance -ClassName CIM_DataFile -Filter 'Drive = \"C:\" AND (Extension = \"dll\"\nOR Extension = \"exe\")' -Property 'Name' | % { Get-Item $_.Name |Select-String Pattern 'RunHTMLApplication' -Encoding ascii }\n\n```\nThe above one-liner found no other built-in utilities that make native use of the\n```\nRunHTMLApplication function outside of mshta.exe and rundll32.exe . Had this\n\n```\nyielded any candidate executables, a manual review process would have been required to\nassess feasibility of its use to execute attacker-supplied HTA script code.\n\n### Identifying available WSH script engines\n\nWhile running a procmon trace, we observed that the presence of an “OLEScript” subkey\nwithin the HKEY_CLASSES_ROOT registry hive is an indication that the WSH scripting\nengine is being used. It’s known that you can specify VBScript and JScript as the scripting\nlanguage in HTA, but it was unclear if any other scripting engines were supported. We wrote\nthe following PowerShell function to enumerate other possible WSH scripting engines:\n\n\n-----\n\n```\nfunction Get-OLEScriptingEngine {\n  Get-ChildItem -Path 'Registry::HKEY_CLASSES_ROOT\\' | % {\n    $Key = $_ | Get-Item\n    $HasOLEScript = $Key.GetSubKeyNames() | ? { $_ -contains 'OLEScript' }\n    if ($HasOLEScript) {\n      # Pull the CLSID of the corresponding script engine\n      $CLSID = Get-ItemPropertyValue -Path \"Registry::$($Key.Name)\\CLSID\" Name '(Default)'\n      $EnginePath = Get-ItemPropertyValue -Path\n\"Registry::HKEY_CLASSES_ROOT\\CLSID\\$CLSID\\InprocServer32\" -Name '(Default)'\n      [PSCustomObject] @{\n        EngineName = $Key.PSChildName\n        CLSID = $CLSID\n        EnginePath = $EnginePath\n      }\n    }\n  }\n}\n\n```\nThe PowerShell function yielded the following results:\n\n\n-----\n\n```\nEngineName       CLSID                 EnginePath\n----------       -----                 ---------ECMAScript       {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nECMAScript Author   {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript       {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript Author   {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.1     {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.1 Author  {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.2     {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.2 Author  {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.3     {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJavaScript1.3 Author  {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJScript        {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJScript Author     {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJScript.Compact    {cc5bbec3-db4a-4bed-828d-08d78ee3e1ed}\nC:\\Windows\\System32\\jscript.dll\nJScript.Compact Author {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nJScript.Encode     {f414c262-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nLiveScript       {f414c260-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nLiveScript Author   {f414c261-6ac0-11cf-b6d1-00aa00bbbb58}\nC:\\Windows\\System32\\jscript.dll\nVBS          {B54F3741-5B07-11cf-A4B0-00AA004A55E8}\nC:\\Windows\\System32\\vbscript.dll\nVBS Author       {B54F3742-5B07-11cf-A4B0-00AA004A55E8}\nC:\\Windows\\System32\\vbscript.dll\nVBScript        {B54F3741-5B07-11cf-A4B0-00AA004A55E8}\nC:\\Windows\\System32\\vbscript.dll\nVBScript Author    {B54F3742-5B07-11cf-A4B0-00AA004A55E8}\nC:\\Windows\\System32\\vbscript.dll\nVBScript.Encode    {B54F3743-5B07-11cf-A4B0-00AA004A55E8}\nC:\\Windows\\System32\\vbscript.dll\nVBScript.RegExp    {3F4DACA4-160D-11D2-A8E9-00104B365C9F}\nC:\\Windows\\System32\\vbscript.dll\nXML          {989D1DC0-B162-11D1-B6EC-D27DDCF9A923}\nC:\\Windows\\System32\\msxml3.dll\n\n```\n\n-----\n\nNot all of these scripting engines support the full functionality that VBScript and JScript\nwould, so we didn’t prioritize testing them (e.g., XML, VBScript.RegExp). The primary\ntakeaway here is that while script code can be reflected in different ways based on the\nscript engine, detection artifacts will remain the same (i.e., same DLL loads and same\nstructure to the HTA document). Selection of the scripting engine will affect, however,\nmalicious script analysis. For example, a decoder would be required to interpret\nJScript.Encode and VBScript.Encode content.\n\n### HTTP[S] hosting of HTA content\n\nIt took us a while to realize that HTA content could not be hosted on GitHub and\ndownloaded/executed by `mshta.exe because GitHub uses a “text/plain” MIME type and`\nHTA content will only display and not execute in that case. To address this, we hosted\nsample HTA content from a static site where we had control over the MIME type and\ndiscovered that not only did specifying a MIME type of application/HTA cause the HTA\ncontent to execute, but any MIME type that’s not text/plain appears to cause the content to\nexecute. This finding is relatively significant because it reveals that one actor was hosting\nHTA content appended to a .crl file and the MIME type used was “application/x-x509-cacert”, which blends in quite well over the network. This finding also helped confirm that any\nfile extension containing HTA content can be downloaded and executed.\n\nThe following code was used to enumerate built-in MIME types and their corresponding file\nassociations:\n```\n Get-ChildItem -Path 'Registry::HKEY_CLASSES_ROOT' | Where-Object {\n $_.GetValueNames() -contains 'Content Type' } | ForEach-Object { [PSCustomObject] @{\n Extension = $_.PSChildName; ContentType = (Get-ItemPropertyValue -Path\n \"Registry::HKEY_CLASSES_ROOT\\$($_.PSChildName)\" -Name 'Content Type') } } | Sort Object -Property ContentType\n\n```\nThis code didn’t produce any significant findings but it satiated a curiosity around what\nMIME types are associated with an array of file extensions in Windows by default.\n\n## References\n\nThe following resources were indispensable to our understanding of HTA tradecraft and\nhelped reduce the amount of time required to fully contextualize the technique:\n\nRelated Articles\n\nDetection and response\n\n\n-----\n\n### ChromeLoader: a pushy malvertiser\n\nDetection and response\n\n### Intelligence Insights: May 2022\n\nDetection and response\n\n### The Goot cause: Detecting Gootloader and its follow-on activity\n\nDetection and response\n\n### Marshmallows & Kerberoasting\n\n**Subscribe to our blog**\n\nOur website uses cookies to provide you with a better browsing experience. More\n[information can be found in our Privacy Policy.](https://redcanary.com/privacy-policy)\n\nX\n\n**Privacy Overview**\n\nThis website uses cookies to improve your experience while you navigate through the\nwebsite. Out of these cookies, the cookies that are categorized as necessary are stored on\nyour browser as they are essential for the working of basic functionalities of the website. We\nalso use third-party cookies that help us analyze and understand how you use this website.\nThese cookies will be stored in your browser only with your consent. You also have the\noption to opt-out of these cookies. But opting out of some of these cookies may have an\neffect on your browsing experience.\n\nNecessary cookies are absolutely essential for the website to function properly. This category\nonly includes cookies that ensures basic functionalities and security features of the website.\nThese cookies do not store any personal information.\n\nAny cookies that may not be particularly necessary for the website to function and is used\nspecifically to collect user personal data via analytics, ads, other embedded contents are\ntermed as non-necessary cookies. It is mandatory to procure user consent prior to running\nthese cookies on your website.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-08 - The why, what, and how of threat research.pdf"
    ],
    "report_names": [
        "2020-12-08 - The why, what, and how of threat research.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535646,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653703154,
    "ts_modification_date": 1653703154,
    "files": {
        "pdf": "https://archive.orkl.eu/fd5908af1638871b302e884797fa979a53e249fd.pdf",
        "text": "https://archive.orkl.eu/fd5908af1638871b302e884797fa979a53e249fd.txt",
        "img": "https://archive.orkl.eu/fd5908af1638871b302e884797fa979a53e249fd.jpg"
    }
}