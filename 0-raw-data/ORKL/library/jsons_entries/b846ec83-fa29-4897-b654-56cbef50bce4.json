{
    "id": "b846ec83-fa29-4897-b654-56cbef50bce4",
    "created_at": "2023-01-12T15:01:08.276171Z",
    "updated_at": "2025-03-27T02:05:58.846262Z",
    "deleted_at": null,
    "sha1_hash": "1637d4fa90786ccfd7494767f18858ee86da73c0",
    "title": "2022-02-28 - Analyzing conti-leaks without speaking russian — only methodology",
    "authors": "",
    "file_creation_date": "2022-05-29T10:49:08Z",
    "file_modification_date": "2022-05-29T10:49:08Z",
    "file_size": 1473073,
    "plain_text": "# Analyzing conti-leaks without speaking russian — only methodology\n\n**[medium.com/@arnozobec/analyzing-conti-leaks-without-speaking-russian-only-methodology-f5aecc594d1b](https://medium.com/@arnozobec/analyzing-conti-leaks-without-speaking-russian-only-methodology-f5aecc594d1b)**\n\nArnaud Zobec February 28, 2022\n\n[Arnaud Zobec](https://medium.com/@arnozobec?source=post_page-----f5aecc594d1b--------------------------------)\n\nFeb 28\n\n\n5 min read\n\nIf you’re like me and you don’t speak russian, and you have a conti leak to analyze, here is\nsome tricks for you.\n\n**Disclaimer : I will not do the analysis in depth of the files here. It’s just a blogpost to show**\nmethodology in such case. The audience for this blogpost can be students, or people\ninterested in CTI without big budget. This is NOT an analysis of Conti-leaks. This is NOT a\nTODO list in every case. It’s my methodology for json files.\n\nI will talk about how I modified the file to load it easily with Python, and how I used some\nlibraries to translate the text, and how I used other softwares, like Gephi, or command-lines\nlike egrep to have informations quickly.\n\n## First look at the files\n\nWhen you look at the files first, it appears to be in json. Awesome, we love JSON, it’s very\neasy to use it.\n\n\n-----\n\nFirst look at the content of the json files contained in the leak.\nYou have several ways to load the file into Python, and I’ll show you two different methods\nunder:\n\n## First method : transform the files a little bit and load it via JSON libraries\n```\n#To make one filecat *.json > big.json#To remove the first \\nsed -i -e\n':a;N;$!ba;s/{\\n/{/g' big.json#Remove the \\n after the commassed -i -e\n':a;N;$!ba;s/,\\n/,/g' big.json#Remove the \\n before {sed -i -e\n':a;N;$!ba;s/\\\"\\n/\\\"/g' big.json\n\n```\nYour file should now look like this :\n\nbig.json content\nBut you know, there is a WAY simpler trick if you use jq :) . It was just to forced you to use\nsed to make a little bit of file manipulation ;)\n```\ncat *.json | jq -cr > big.json\n\n```\n\n-----\n\nIt will make a one-line for each json line it can read.\n\nAnd now that I have a clean file, what I want to do is to load every line in a list of\ndictionnaries in python (and print it for the example).\n```\nimport jsonchatList = []with open('onebig.json') as f:  for jsonObj in f:    \n_Dict = json.loads(jsonObj)    chatList.append(_Dict)for line in chatList:  \nprint(line['body'])#print each body\n\n```\nEasy peasy lemon squeezy\n\nRemember ? I don’t speak russian, but I want to read it, and I have no money to pay a\nprofessionnal translator. But my data is inside a python dictionnary, so I can do whatever I\nwant with it.\n\n## Translation via python\n\n[I use a free library that is called deep-translator (https://github.com/nidhaloff/deep-translator)](https://github.com/nidhaloff/deep-translator)\n\n(to install it : pip install -U deep-translator)\n\nWhat I will do is to use the library on the “body” key in the json file, for each line, and\ntranslate it into english into a new key “LANG-EN”. And if there is some fail, I want the\nmessage to be “Error during Translation”\n\nAnd finally, I want to print the result of the line as a JSON line.\n```\nimport jsonfrom deep_translator import GoogleTranslatorchatList = []with\nopen('onebig.json') as f:  for jsonObj in f:    _Dict = json.loads(jsonObj)  \nchatList.append(_Dict)for line in chatList:  try:    translation =\nGoogleTranslator(source='auto', target='en').translate(line[\"body\"])    \nline[\"LANG-EN\"] = translation  except Exception as e:    line[\"LANG-EN\"] =\n\"Error during Translation\"  print(json.dumps(line, ensure_ascii =\nFalse).encode('utf8').decode())\n\n```\nAs you can see, I had to use ensure_ascii = False and encode(‘utf-8’) because I still want to\nprint russian characters.\n\nNow, your output should look like this :\n\noutput of the translation script in python\n\n## Second method : transform the files a little bit and load it via pandas\n\n\n-----\n\nI will transform the first big.json file a little bit, to make it like one big JSON file.\n\nTo do it, I’ll put every json line into a json tab:\n```\n#add a \",\" between \"}\" and \"{\"sed -i -e ':a;N;$!ba;s/}/},/g' big.jsonThen I add this\ncharacter \"[\" at the beginning of the file and this character \"]\" at the end of the\nfile\n\n```\nAnd now, I can load it into a Pandas DataFrame very easily !\n```\nimport pandas as pddf = pd.read_json('big.json')#Yes, it's that easy\n\n```\nAnd why using pandas dataframe ?\n\nWell we can sort it by dates very easily, and transform it into CSV to export to use with other\ntools that do not deal with JSON easily.\n```\nimport pandas as pddf = pd.read_json('big.json')sorted_df =\ndf.sort_values(by=\"ts\")sorted_df.to_csv('onebig.csv', doublequote=True, quoting=1,\nescapechar=\"\\\\\")\n\n```\nThis code above will create a file called “onebig.csv” sorted by dates.\n\nonbig.csv output\n\n## And now what ?\n\n Visualisations : with gephi\n\nGephi is an Open Graph Viz Platform - [https://gephi.org/](https://gephi.org/)\n\nYou can use gephi, and a Yifan Hu spacialisation to see the interactions between people, by\napplying a ponderation on links (for example).\n\nThe bigger is the arrow, the bigger is the weight of the link. It means those at each side of the\narrow are two people that are often talking together.\n\nWe can easily identify people of interest using gephi with this methodology.\n\nOh. You may want to have a graphic card to use it, it’s very power consumptive.\n\n\n-----\n\nYifan Hu spacialisation using Gephi\n\n## Visualisations : with elasticsearch and kibana\n\nWith a very simple configuration, you can load your data into an elasticsearch/kibana cluster,\nand read things, request it, etc.\n```\n#content of /etc/logstash/conf.d/00-leak-analysis.confinput {    # this is the\nactual live log file to monitor    file {       path =>\n\"/myfolder/leak/*.json\"       type => \"leak\"       #codec => json   \nstart_position => [\"beginning\"]    }}filter{ if [type] == \"leak\" {     json { \nsource => message     } }}output {  if [type] == \"leak\" {    elasticsearch\n{      hosts => [\"localhost:9200\"]      index => \"leak-%{+yyyy-MM-dd}\"  \n}  }}\n\n```\n\n-----\n\nread messages in Kibana\nThen, while using kibana, you can sort by users, or search for specific things.\n\n## To go further :\n\nMaybe you want to extract quickly the url contained in the big.json file ?\n\nquick hint : use regexp via egrep\n```\negrep '(http|https):\\/\\/[a-zA-Z0-9.\\/?=_%&:-]*' -o big.json > url_output.txt\n\n```\nAnd there you are. Oh, and you can use defang (python tool) on your file to read it safely !\n\n(to install defang : pip install defang)\n```\ndefang -i url_output.txt -o url_output_defanged.txt\n\n```\n\n-----\n\ndefanged URL observed in leak\nIt’s now your turn to be imaginative to read things inside this leak. Have fun :)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-28 - Analyzing conti-leaks without speaking russian — only methodology.pdf"
    ],
    "report_names": [
        "2022-02-28 - Analyzing conti-leaks without speaking russian — only methodology.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535668,
    "ts_updated_at": 1743041158,
    "ts_creation_date": 1653821348,
    "ts_modification_date": 1653821348,
    "files": {
        "pdf": "https://archive.orkl.eu/1637d4fa90786ccfd7494767f18858ee86da73c0.pdf",
        "text": "https://archive.orkl.eu/1637d4fa90786ccfd7494767f18858ee86da73c0.txt",
        "img": "https://archive.orkl.eu/1637d4fa90786ccfd7494767f18858ee86da73c0.jpg"
    }
}