{
    "id": "94fa8cdb-5fa9-4440-8454-cc8cbc9a94fc",
    "created_at": "2023-01-12T15:02:59.397719Z",
    "updated_at": "2025-03-27T02:05:25.033844Z",
    "deleted_at": null,
    "sha1_hash": "7cc626c508da190a20c1fa6714d2945e0151f3a6",
    "title": "2022-03-01 - How IoT Botnets Evade Detection and Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T05:02:00Z",
    "file_modification_date": "2022-05-28T05:02:00Z",
    "file_size": 3232106,
    "plain_text": "# How IoT Botnets Evade Detection and Analysis\n\n**[nozominetworks.com/blog/how-iot-botnets-evade-detection-and-analysis/](https://www.nozominetworks.com/blog/how-iot-botnets-evade-detection-and-analysis/)**\n\nBy March 1, 2022\n\n## On the Hunt for Elusive Malware\n\nMalware families targeting the IoT sector share multiple similarities with their Windows-based\ncounterparts, such as trying to evade detection by both researchers and security products.\nTheir aim is to stay below the radar as long as possible. One key technique to stymie reverse\nengineering botnet code is to obfuscate the code by compressing or encrypting the\nexecutable, called packing.\n\nIn this post, we explore the current status of the packers used by IoT malware, using data\ncollected by Nozomi Networks honeypots. We’ll also dig deeper into various obstacles that\nresearchers face when analyzing obfuscated samples and show how they can be handled.\n\nAs malware targeting the IoT sector evolves, many features are being borrowed from the\nmore well-known IT sector.\n\n## IoT Botnet Attack Statistics\n\n\n-----\n\nHoneypots are vulnerable systems that are deliberately made available to adversaries so\nthat information on malicious activity can be collected for research, detection, and defensive\npurposes. Nozomi Networks Labs runs a network of passive honeypots across various\nregions that emulate multiple protocols commonly abused by attackers. The data they collect\nis aggregated and used for research and detection efforts.\n\nOver the course of a seven-day period, Nozomi Networks honeypots collected 205 unique\nsamples from attacks. The vast majority of the collected files are Linux executable files for\n32-bit architectures.\n\nStatistics of the different file types collected by our honeypots.\n\nAttackers use packers to obfuscate their code, concealing the original code with the intent of\nevading detection and making malware analysis more difficult and time consuming. Of the\nsamples we collected, approximately one third were packed using multiple versions of UPX,\na free and open-source packer widely used by both legitimate companies and malicious\nactors. UPX was the only packer used in this set of samples.\n\n\n-----\n\nPercentage breakdown of UPX-packed samples and unpacked samples collected by the\nhoneypots.\n\n[At the time of the analysis, 49 of 205 samples were not present on VirusTotal, a share site for](https://www.virustotal.com/gui/home/upload)\nmalware details and research, and thus we decided to focus on these potentially new\nthreats. This subset of files follows a similar percentage distribution regarding the packer and\nthe version employed. Most of the new files—almost 80%—were not packed at all, with the\nremainder packed with UPX.\nBased on initial research, one of these samples appears to belong to the same malware\nfamily that showed up in other internal Threat Intelligence research. It also stands out\nbecause of the particular UPX packing structure modifications.\n\n\n-----\n\nOf new samples not present on VirusTotal, 80% were not packed, while the rest were packed\nwith UPX.\n\n## Unpacking Challenges\n\nWhen a sample is only packed with UPX, it is very easy to unpack with the standard UPX\ntool using the `-d command line argument. Therefore, attackers will commonly modify the`\nUPX structures of a packed sample so that it remains executable, but the standard UPX tool\ncan no longer recognize and unpack it.\n\nSince UPX is an open-source tool, we can check its source code on GitHub to understand its\nstructures and what fields it uses. (You can see more of its file structure [here.)](https://github.com/upx/upx/blob/d7ba31cab8ce8d95d2c10e88d2ec787ac52005ef/src/stub/src/include/linux.h#L721)\n\n\n-----\n\nSample UPX file structure.\n\nMost IoT samples packed with UPX modify the `l_info and` `p_info structs in the header.`\n[For example, as we have seen before with the SBIDIOT malware, it’s common for malware](https://eur03.safelinks.protection.outlook.com/GetUrlReputation)\nauthors to modify the `l_magic value of the` `l_info struct in UPX-packed samples. In this`\ncase, unpacking the sample is as trivial as replacing the modified `l_magic value with`\n```\nUPX! and executing upx -d .\n\n```\n[In other cases, like the Mozi IoT malware family, the p_info struct is modified to set](https://threatpost.com/mozi-botnet-majority-iot-traffic/159337/)\n```\np_filesize and p_blocksize to zero. The solution then involves repairing the two\n\n```\nzeroed values by replacing them with the filesize value that is available at the trailer of the\nbinary.\n\nHowever, when we tried to unpack the samples of interest, UPX returned an unusual error:\n\n\n-----\n\nMalware sample fails while testing to determine if it can be unpacked with UPX.\n\nIn this case, UPX is telling us that there was a problem with the `b_info structure. After`\nsome research, we concluded that this structure doesn’t seem to be widely used by malware\nauthors. `b_info is a structure placed before each compressed block and contains`\ninformation about its compressed and uncompressed size, along with the algorithm and\nparameters used to compress them. Once we checked the `b_info structure in the file, we`\nrealized it hadn’t been zeroed or modified in an obvious way.\n\n[Diving deeper into the internals of UPX, we found the exact place in the code that raises this](https://github.com/upx/upx/blob/devel/src/p_unix.cpp)\nexception. If the compressed size ( sz_cpr ) is bigger than the uncompressed size\n( sz_unc ), UPX will fail. However, their values were coherent, so we discarded this\n[modification as the source of the problem. In these lines of code, we can see that the most](https://github.com/upx/upx/blob/devel/src/p_unix.cpp#L514)\npromising reason could be a problem with a difference between the sum of the declared size\nof the uncompressed sections and the declared size of the uncompressed file. In our sample,\nthe sum of the value of `sz_unc was bigger than the value of` `p_filesize, so we modified`\nthe appropriate `p_info structure to set its` `p_filesize field with a value that wouldn’t`\ntrigger this exception.\n\nAfter changing these values, a header checksum exception was raised. Calculating this\nchecksum value was possible since we had its source code, but it would be time-consuming,\nso we temporarily moved to another research path. We decided to create packed samples\nthat were as similar as possible to the malicious sample so it would be easier to spot the\ndifferences.\n\nWith the help of `upx --fileinfo we got the parameters needed to pack another`\nexecutable with almost the same compression and decompression algorithm.\n\nExtracting compression information from a malware sample.\n\nTo compress the sample, the attackers used a command similar to `upx --best --nrv2d`\n```\n<elf_file> . As a starting point to check differences, we used the rz-diff tool to\n\n```\n\n-----\n\ncompare the main decompression functions:\n\nCreating an executable with similar packing and comparing unpacking functions.\n\nWe started comparing the differences between the functions, looking for the code we were\nthinking the attackers added to the decompression process. An unexpected difference\nappeared:\n\nMalware sample packed using UPX 4.0.0.\n\nAt the moment, the stable UPX version is v3.96, and version 4.0.0 is in development.\nChangelog doesn’t seem to contain big changes in how ELF compression works, but there\nare a lot of commits that affect portions of the code involved in the calculation of these\nvalues.\nWe then checked how this new version handled the issues we were seeing by downloading\nthe pre-release version of UPX and compiling it. After only fixing the `UPX! strings headers`\n( b_info and `p_info structures were left untouched) and passing this executable to` `UPX`\n\n\n-----\n\nversion 4.0.0, the sample was accurately decompressed.\n\nSuccessful extraction with UPX 4.0.0 (commit a46b63).\nIt is possible that the attackers realized that this version of UPX (which is still in\ndevelopment) generates functional samples that cannot be extracted by standard production\nversions of UPX versions used by default by everyone.\n\n## Universal Manual Unpacking\n\nInstead of digging deeper into the modifications introduced by attackers, there is another\napproach we can consider. The idea here is to stop the debugging process when the code\nand data are already unpacked but the unpacked code hasn’t been executed yet, to prevent\nthe subsequent possible data and code modifications, and write down the unpacked code\nand data back to the disk. This approach is widely used to unpack Windows samples, but\nwhat about IoT threats? From a high-level perspective, the same logic can certainly be\napplied to them.\n\nHere are several universal techniques that allow us to circumvent packers regardless of what\nmodifications are introduced. They generally involve relying on the steps that an unpacker\nhas to do in order to achieve its goal, mainly:\n\n1. The packed code and data should be read and unpacked\n2. A big memory block should be available to host the resulting unpacked sample\n3. The result of the unpacking should be written into this big memory block\n4. Depending on the existing protection flags for this block, they may need to be adjusted\n\nto make code execution possible\n5. Finally, the control should be transferred to the first instruction of the unpacked code\n\nknown as the Original Entry Point (OEP)\n\nSo, how can these techniques help us unpack the samples?\n\n1. Generally, packed code and data have high entropy and can therefore be easily\n\nidentified in hex editors. Finding these blocks and tracking their cross-references can\nhelp us find the decryption/decompression/decoding routine(s).\n\n\n-----\n\n2. Keeping track of memory allocations (mmap syscall) may help us find the future virtual\naddress of the unpacked code and data.\n\nmmap syscall (rax = 0x09) with a big memory block length requested.\n3. Memory or hardware breakpoint on write operation set on the allocated block will help us\nintercept the moment when the unpacked code and data of interest will be written there.\n\n\n-----\n\nSetting a hardware breakpoint on write operation in IDA.\n4. Keeping an eye on the mprotect syscall, which is commonly used to change protection\nflags, can help identify the moment when this will happen.\n\nmprotect syscall followed by an unusual control flow instruction.\n5. Looking for unusual control flow instructions can help identify the moment when the\nunpacker finished its job and is ready to transfer control to the first instruction of the freshly\nunpacked code (OEP).\n\n\n-----\n\nThe final unusual control flow instruction leading to the OEP.\nFollowing these approaches separately or in combination eventually helps intercept the\nmoment when the unpacked code and data finally reside in memory readily available to be\ndumped to the disk for subsequent static analysis.\nIn addition to these techniques, calling munmap syscall next to transferring control to the\nOEP is another feature of UPX that allows researchers to quickly unpack such samples.\nThey can simply intercept it and then follow the execution flow.\n\nmunmap syscall (rax = 0x0B) executed next to transferring control to the OEP.\n\n## Conclusions\n\nThe landscape of malware targeting the IoT sector keeps evolving and borrowing many\nfeatures from the more well-known IT sector. Staying up-to-date with the latest trends in this\narea and being able to handle them helps the security community combat new threats more\nefficiently and reduces the potential impact of associated cyberattacks.\n\n**Related Content**\n\n\n-----\n\nRESEARCH REPORT\n\n## OT/IoT Security Report – 2021 2H\n\nInsights on the latest cyber threats\nHow and why critical infrastructure industries such as transportation and healthcare are\nbeing targeted\nAnalysis of recent ICS-CERT vulnerabilities and exploitation trends\nRemediation strategies to address today’s emerging threats\n\n[Download](https://www.nozominetworks.com/ot-iot-security-report/)\n**Related Links**\n\nBlog: [Extract Firmware from OT Devices for Vulnerability Research](https://www.nozominetworks.com/blog/extract-firmware-from-ot-devices-for-vulnerability-research/)\nBlog: [Critical Log4shell (Apache Log4j) Zero-Day Attack Analysis](https://www.nozominetworks.com/blog/critical-log4shell-apache-log4j-zero-day-attack-analysis/)\nBlog: [How to Analyze Malware for Technical Writing](https://www.nozominetworks.com/blog/how-to-analyze-malware-for-technical-writing/)\nBlog: [The Clever Use of Postdissectors to Analyze Layer 2 Protocols](https://www.nozominetworks.com/blog/the-clever-use-of-postdissectors-to-analyze-layer-2-protocols/)\nBlog: [Nozomi Networks Labs Webinars & Podcasts](https://www.nozominetworks.com/labs/webinars-podcasts/)\n\n[Nozomi Networks Labs](https://www.nozominetworks.com/author/nn-labs/)\n\n\n-----\n\nNozomi Networks Labs is dedicated to reducing cyber risk for the world s industrial and\ncritical infrastructure organizations. Through our cybersecurity research and collaboration\nwith industry and institutions, we’re helping defend the operational systems that support\neveryday life.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-01 - How IoT Botnets Evade Detection and Analysis.pdf"
    ],
    "report_names": [
        "2022-03-01 - How IoT Botnets Evade Detection and Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535779,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1653714120,
    "ts_modification_date": 1653714120,
    "files": {
        "pdf": "https://archive.orkl.eu/7cc626c508da190a20c1fa6714d2945e0151f3a6.pdf",
        "text": "https://archive.orkl.eu/7cc626c508da190a20c1fa6714d2945e0151f3a6.txt",
        "img": "https://archive.orkl.eu/7cc626c508da190a20c1fa6714d2945e0151f3a6.jpg"
    }
}