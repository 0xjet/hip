{
    "id": "a23f2294-a55c-45cf-8455-a47ca6828bec",
    "created_at": "2023-01-12T14:59:47.966702Z",
    "updated_at": "2025-03-27T02:16:26.543655Z",
    "deleted_at": null,
    "sha1_hash": "8a7dd9efd0f95e4f6e98d4667ef467232075f7c9",
    "title": "2022-01-02 - Analyzing a Magnitude EK Appx Package Dropping Magniber",
    "authors": "",
    "file_creation_date": "2022-05-28T05:06:48Z",
    "file_modification_date": "2022-05-28T05:06:48Z",
    "file_size": 276266,
    "plain_text": "# Analyzing a Magnitude EK Appx Package Dropping Magniber\n\n**[forensicitguy.github.io/analyzing-magnitude-magniber-appx/](https://forensicitguy.github.io/analyzing-magnitude-magniber-appx/)**\n\n### By Tony Lambert Posted 2022-01-02 Updated 2022-03-28 10 min read\n\n\nJanuary 2, 2022\n\n\n### In this post I’ll work through analyzing an AppX package from Magnitude Exploit Kit that drops Magniber. This adventure comes courtesy of a tweet from @JAMESWT_MHT:\n\n Some #Magniber sampleshttps://t.co/6XaMq0X2QH https://t.co/wWef0eSk2o\n\n — JAMESWT (@JAMESWT_MHT) January 1, 2022\n\n This caught my interest because AppX packages have gotten some mileage as droppers lately courtesy of Bazar and Emotet.\n\n https://news.sophos.com/en-us/2021/11/11/bazarloader-call-me-back-attack-abuses- windows-10-apps-mechanism/ https://redcanary.com/blog/intelligence-insights-december-2021/\n\n If you want to play along from home, the file I’m analyzing is here: https://bazaar.abuse.ch/sample/da1729efaaa590d66f46d388680ed5b1b956246ababd277e7cdd1 4f90fbf60fa/\n\n## Analyzing the AppX Package\n\n### To start off, let’s get a handle on what kind of file an AppX package is. We can do this using\n```\n file .\n  remnux@remnux:~/cases/magnitude/update$ file\n  edge_update.appx \n  edge_update.appx: Zip archive data, at least v4.5 to\n  extract\n\n The file command says the magic bytes for the file correspond to a zip archive. This is common with application or package archives like AppX, JARs, and more. If we want more confirmation we can always look at the first few bytes with hexdump and head .\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/magnitude/update$ hexdump -C edge_update.appx |\n  head\n  00000000 50 4b 03 04 2d 00 08 00 00 00 f8 6e 9d 53 00 00 \n  |PK..-......n.S..|\n  00000010 00 00 00 00 00 00 00 00 00 00 26 00 00 00 49 6d \n  |..........&...Im|\n  00000020 61 67 65 73 2f 53 71 75 61 72 65 31 35 30 78 31 \n  |ages/Square150x1|\n  00000030 35 30 4c 6f 67 6f 2e 73 63 61 6c 65 2d 31 35 30 \n  |50Logo.scale-150|\n  00000040 2e 70 6e 67 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d \n  |.png.PNG........|\n  00000050 49 48 44 52 00 00 00 e1 00 00 00 e1 08 06 00 00 \n  |IHDR............|\n  00000060 00 3e b3 d2 7a 00 00 00 09 70 48 59 73 00 00 0e \n  |.>..z....pHYs...|\n  00000070 c3 00 00 0e c3 01 c7 6f a8 64 00 00 71 fc 49 44 \n  |.......o.d..q.ID|\n  00000080 41 54 78 9c ec bd 77 90 25 c7 79 27 f8 65 99 e7 \n  |ATx...w.%.y'.e..|\n  00000090 db 9b e9 ee f1 33 98 19 0c 06 84 77 04 41 18 92 \n  |.....3.....w.A..|\n\n### Yup, looks like a zip file based on 50 4b 03 04! That means we can unpack the archive using\nunzip .\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/magnitude/update$ unzip edge_update.appx\n  Archive: edge_update.appx\n  extracting: Images/Square150x150Logo.scale-150.png \n  extracting: Images/Wide310x150Logo.scale-150.png \n  extracting: Images/SmallTile.scale-150.png \n  extracting: Images/LargeTile.scale-150.png \n  extracting: Images/BadgeLogo.scale-150.png \n  extracting: Images/SplashScreen.scale-150.png \n  extracting: Images/StoreLogo.scale-150.png \n  extracting: Images/Square44x44Logo.targetsize-32.png \n  extracting: Images/Square44x44Logo.altform-unplated_targetsize-32.png \n  extracting: Images/Square44x44Logo.scale-150.png \n  extracting: Images/Square44x44Logo.altform-lightunplated_targetsize  32.png \n   inflating: eediwjus/eediwjus.exe  \n   inflating: eediwjus/eediwjus.dll  \n   inflating: resources.pri      \n   inflating: AppxManifest.xml    \n   inflating: AppxBlockMap.xml    \n   inflating: [Content_Types].xml   \n   inflating: AppxMetadata/CodeIntegrity.cat \n   inflating: AppxSignature.p7x\n\n### With the archive unzipped, we can focus on significant files within the package. These are:\n\n AppxManifest.xml (list of properties and components used by the AppX package) AppxSignature.p7x (AppX Signature Object, contains code signatures for AppX Package)\n\n```\n\n-----\n\n### eediwjus/eediwjus.exe (non-default content that is likely executable) eediwjus/eediwjus.dll (non-default content that is likely executable)\n\n First, we can look at the AppxManifest.xml file. I’ve included the points of interest below.\n```\n  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <Package xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\" xmlns:re\n  scap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabili\n  ties\" IgnorableNamespaces=\"uap rescap build\" xmlns:build=\"http://schem\n  as.microsoft.com/developer/appx/2015/build\">\n   <Identity Name=\"3669e262-ec02-4e9d-bcb4-3d008b4afac9\" Publisher=\"CN=Foresee Consulting\n  Inc., O=Foresee Consulting Inc., L=North York, S=Ontario, C=CA, SERIA\n  LNUMBER=1004913-1, OID.1.3.6.1.4.1.311.60.2.1.3=CA, OID.2.5.4.15=Private Organization\"\n  Version=\"96.0.1072.0\" ProcessorArchitecture=\"neutral\" />\n   <Properties>\n    <DisplayName>Edge Update</DisplayName>\n    <PublisherDisplayName>Microsoft Inc</PublisherDisplayName>\n    <Logo>Images\\StoreLogo.png</Logo>\n   </Properties>\n  ...\n   <Applications>\n    <Application Id=\"App\" Executable=\"eediwjus\\eediwjus.exe\"\n  EntryPoint=\"Windows.FullTrustApplication\">\n     ...\n    </Application>\n   </Applications>\n   <Capabilities>\n    <Capability Name=\"internetClient\" />\n    <rescap:Capability Name=\"runFullTrust\" />\n   </Capabilities>\n  </Package>\n\n```\n\n-----\n\n### First, let’s take a look at the Identity and Properties sections. Identity contains code signature information that should theoretically be included within the AppxSignature.p7x file. The Properties section contains metadata the Windows Store/Universal Windows App interface uses to identify the app. From the name Edge Update and publisher name Microsoft Inc, it appears the malware wants to masquerade as a Microsoft Edge browser update. Note how there is no link or control between the publisher display name and the actual signing identity. This is a major problem for victims trying to be sure of themselves.\n\n The Application section identifies the EXE that will execute when the package is installed and run. In this sample, the EXE is eediwjus.exe . In the package content there is also a DLL, but that isn’t mentioned in the manifest. A possibility to explore might be that the EXE uses content from the DLL for execution.\n\n Finally, the Capabilities section shows the app will execute with internetClient and\n```\nrunFullTrust capabilities. Documented by Microsoft, these capabilities just mean the app can\n\n download stuff from the Internet. Now we can jump into the executable content, the EXE file.\n\n## Analyzing the Application Executable\n\n### The EXE has these hashes:\n  filepath:            eediwjus.exe\n  md5:               3439bbe95df314d390cc4862cdad94fd\n  sha1:              92429885d54a05ed87a5c14d34aa504c28ea8b54\n  sha256:             \n  ad4f74c0c3ac37e6f1cf600a96ae203c38341d263dbac0741e602686794c4f5a\n  ssdeep:             48:6/yaz1YKkikwFJSDq6tPRqBHwOul2a3iq:yz1fkigtJkGYK\n  imphash:             f34d5f2d4577ed6d9ceec516c1f5a744\n\n Note the import table hash starting with f34d . That specific import table hash commonly appears with .NET binaries, so if you pivot on it in VT or other tools, you’ll find a lot of .NET. Using Detect It Easy in REMnux, we can confirm the executable is a .NET binary.\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/magnitude/update/eediwjus$ diec\n  eediwjus.exe \n  filetype: PE32\n  arch: I386\n  mode: 32-bit\n  endianess: LE\n  type: GUI\n   library: .NET(v4.0.30319)[-]\n   linker: Microsoft Linker(11.0)[GUI32]\n\n### So let’s take a peek with floss from Mandiant to see if there are signs of obfuscation. There aren’t any signs of obfuscation like randomized, high-entropy strings, but we do get some interesting strings.\n\n```\n\n-----\n\n```\n  mscorlib\n  System\n  Object\n  mhjpfzvitta\n  Main\n  .ctor\n  lpBuffer\n  args\n  System.Runtime.Versioning\n  TargetFrameworkAttribute\n  System.Security.Permission\n  s\n  SecurityPermissionAttribut\n  e\n  SecurityAction\n  System.Runtime.CompilerSer\n  vices\n  CompilationRelaxationsAttr\n  ibute\n  RuntimeCompatibilityAttrib\n  ute\n  System.Runtime.InteropServ\n  ices\n  DllImportAttribute\n  eediwjus.dll\n\n### Sure enough, the EXE references the DLL in the same folder, and it includes the string\nDllImportAttribute . This is a good sign that the EXE will load an unmanaged DLL and call\n\n an export from it. Unobfuscated .NET code is usually pretty easy to decompile from bytecode form into source, so we can give that a shot with ilspycmd . If you’re on Windows you can also use ILSpy or DNSpy . The result is a pretty brief source file:\n\n```\n\n-----\n\n```\n  g y ;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing System.Runtime.Versioning;\nusing System.Security;\nusing System.Security.Permissions;\n[assembly: TargetFramework(\".NETFramework,Version=v4.5\", FrameworkDisplayName = \".NET\nFramework 4.5\")]\n[assembly: CompilationRelaxations(8)]\n[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\n[assembly: SecurityPermission(8, SkipVerification = true)]\n[assembly: AssemblyVersion(\"0.0.0.0\")]\n[module: UnverifiableCode]\nnamespace eediwjus\n{\n     public class eediwjus\n     {\n          [DllImport(\"eediwjus.dll\")]\n          private static extern void mhjpfzvitta(uint lpBuffer);\n          private static void Main(string[] args)\n          {\n              uint lpBuffer = 5604u;\n              mhjpfzvitta(lpBuffer);\n          }\n     }\n}\n\n```\n\n-----\n\n### The entry point for the program is the Main function inside the eediwjus class. The\n```\nDllImport code imports the function mhjpfzvitta() from the DLL and calls it with the\n\n argument lpBuffer . That argument contains an unsigned integer value of 5604. lpBuffer appears loads of times in Microsoft documentation around Windows calls like VirtualAlloc and others that need a buffer of memory for operation. It stands to reason that lpBuffer here might correspond to some form of a memory management call.\n\n## Analyzing the Magniber DLL\n\n### The DLL has these hashes:\n  filepath:            eediwjus.dll\n  md5:               e7e4878847d31c4de301d3edf7378ecb\n  sha1:              a93d0f59b3374c6d3669a5872d44515f056e9dbf\n  sha256:             \n  f423bd6daae6c8002acf5c203267e015f7beb4c52ed54a78789dd86ab35e46c6\n  ssdeep:             \n  96:qUG6xykl2J6lc5irN3qjNu47Ru/8IAgecgKDD:qsQMl0u3qjA47RuZAhk\n\n Our pehash command didn’t find an import table hash, so that’s interesting. There may not be an import table in this binary or it might be mangled. We can take a look using the Python\npefile library.\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/magnitude/update/eediwjus$ python3\n  Python 3.8.10 (default, Nov 26 2021, 20:14:08) \n  [GCC 9.3.0] on linux\n  Type \"help\", \"copyright\", \"credits\" or \"license\" for more\n  information.\n  >>> import pefile\n  >>> bin = pefile.PE('eediwjus.dll')\n  >>> bin.get_imphash()\n  ''\n  >>> bin.get_rich_header_hash()\n  ''\n\n### Sure enough, the binary doesn’t seem to have an import table hash or rich header hash. Maybe those parts don’t exist? We can confirm with pefile again.\n\n```\n\n-----\n\n```\n  >>> for directory in\n  bin.OPTIONAL_HEADER.DATA_DIRECTORY:\n  ...   print(directory)\n  ... \n  [IMAGE_DIRECTORY_ENTRY_EXPORT]\n  0x148   0x0  VirtualAddress:        \n  0x2000  \n  0x14C   0x4  Size:             0x4B \n  [IMAGE_DIRECTORY_ENTRY_IMPORT]\n  0x150   0x0  VirtualAddress:        0x0 \n  0x154   0x4  Size:             0x0 \n  ...\n  >>> bin.RICH_HEADER\n  >>> \n\n### Sure enough, the import table is apparently empty and no rich header exists for the binary. This is slightly unusual, so let’s see if we can run some more commands to find capabilities before jumping further into analysis.\n\n The Mandiant tools floss and capa yield nothing significant.\n\n```\n\n-----\n\n```\n  +-----------+-------------------------------------------------------------  ----+\n  | md5    | e7e4878847d31c4de301d3edf7378ecb               \n  |\n  | sha1   | a93d0f59b3374c6d3669a5872d44515f056e9dbf           \n  |\n  | sha256  |\n  f423bd6daae6c8002acf5c203267e015f7beb4c52ed54a78789dd86ab35e46c6 |\n  | path   | eediwjus.dll                         \n  |\n  +-----------+-------------------------------------------------------------  ----+\n  no capabilities found\n\n### Yara tells us more of what we already know.\n  remnux@remnux:~/cases/magnitude/update/eediwjus$ yara-rules\n  eediwjus.dll \n  IsPE64 eediwjus.dll\n  IsDLL eediwjus.dll\n  IsWindowsGUI eediwjus.dll\n  ImportTableIsBad eediwjus.dll\n  HasModified_DOS_Message eediwjus.dll\n\n A pedump command gets us some export info. You could also get this with pefile in Python, I just like this output better.\n\n```\n\n-----\n\n```\n  === EXPORTS ===\n  # module \"eediwjus.dll\"\n  # flags=0x0 ts=\"2021-12-29 10:55:45\" version=0.0 \n  ord_base=1\n  # nFuncs=1 nNames=1\n   ORD ENTRY_VA NAME\n    1   1f74 mhjpfzvitta\n\n### The export mhjpfzvitta() jives with what we expect coming from the EXE previously seen. This is probably our best entry point to examine the DLL.\n\n## Getting Dirty In Assembly\n\n### I usually work with Ghidra, but Cutter seemed to have a better representation of the assembly for this binary.\n\n The entry point export mhjpfzvitta() is fairly brief.\n6: mhjpfzvitta (int64_t arg1);\n; arg int64_t arg1 @ rcx\n0x180001f74   call fcn.18000113f\n0x180001f79   ret\n\n The entry point immediately calls a function at offset 18000113f and returns. Once we go to look at the assembly for that function, we see quite a wild execution graph.\n\n```\n\n-----\n\n### Once entering the function, the sample contains loads of jmp instructions that cause execution to bounce around to various points of the binary. This makes it hard for analysts to follow execution, and eventually we see some more evidence of suspicious activity in decompiled code.\n\n\n-----\n\n```\n  undefined8 fcn.180001f8e(int64_t\n  arg1)\n  {\n    syscall();\n    return 0x18;\n  }\n\n### Since the sample doesn’t have an import table, it’s relying on manual syscall calls like one to\n0x18 for NtAllocateVirtualMemory . Avast saw this with Magniber in the past, alongside the\njmp obfuscation.\n\n```\n\n-----\n\n### While I’m not yet skilled enough to tear much more out of the binary through static analysis, my eye was caught by one section of code that pushes 0x40 and 0x1000 to registers. These two values sometimes pop up when malware calls VirtualAlloc . 0x40 refers to\n\n\n-----\n\n```\nPAGE_EXECUTE_READWRITE protection and 0x1000 refers to MEM_COMMIT . Since these values\n\n### popped up in the sample, we can hypothesize that the sample may inject or unpack material into a memory space.\n\n## How do we know it’s Magniber?\n\n### I didn’t have luck getting Yara rules for Magniber to match this sample, so the best references I have right now are the tweet from @@JAMESWT_MHT and the blog post from Avast showing similar jmp obfuscation and syscall references.\n\n Thanks for reading!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-02 - Analyzing a Magnitude EK Appx Package Dropping Magniber.pdf"
    ],
    "report_names": [
        "2022-01-02 - Analyzing a Magnitude EK Appx Package Dropping Magniber.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535587,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653714408,
    "ts_modification_date": 1653714408,
    "files": {
        "pdf": "https://archive.orkl.eu/8a7dd9efd0f95e4f6e98d4667ef467232075f7c9.pdf",
        "text": "https://archive.orkl.eu/8a7dd9efd0f95e4f6e98d4667ef467232075f7c9.txt",
        "img": "https://archive.orkl.eu/8a7dd9efd0f95e4f6e98d4667ef467232075f7c9.jpg"
    }
}