{
    "id": "827bd662-121d-4b4d-b9dc-83dfe1ac2fd2",
    "created_at": "2023-01-12T15:00:58.971335Z",
    "updated_at": "2025-03-27T02:05:42.446818Z",
    "deleted_at": null,
    "sha1_hash": "0aeb66843cb5a9e7b5be3e31b2052e9c7107cf86",
    "title": "2010-11-20 - The Kernel-Mode Device Driver Stealth Rootkit",
    "authors": "",
    "file_creation_date": "2022-05-27T21:47:09Z",
    "file_modification_date": "2022-05-27T21:47:09Z",
    "file_size": 2465279,
    "plain_text": "# The Kernel-Mode Device Driver Stealth Rootkit\n\n**[resources.infosecinstitute.com/zeroaccess-malware-part-2-the-kernel-mode-device-driver-stealth-rootkit/](http://resources.infosecinstitute.com/zeroaccess-malware-part-2-the-kernel-mode-device-driver-stealth-rootkit/)**\n\n[Part 1: Introduction and De-Obfuscating and Reversing the User-Mode Agent Dropper](https://resources.infosecinstitute.com/step-by-step-tutorial-on-reverse-engineering-malware-the-zeroaccessmaxsmiscer-crimeware-rootkit/)\n\n**Part 2: Reverse Engineering the Kernel-Mode Device Driver Stealth Rootkit**\n\n[Part 3: Reverse Engineering the Kernel-Mode Device Driver Process Injection Rootkit](https://resources.infosecinstitute.com/zeroaccess-malware-part-3-the-device-driver-process-injection-rootkit/)\n\n[Part 4:Tracing the Crimeware Origins by Reversing the Injected Code](https://resources.infosecinstitute.com/zeroaccess-malware-part-4-tracing-the-crimeware-origins-by-reversing-injected-code/)\n\nIn Part 2 of the ZeroAccess Malware Reverse Engineering series of articles, we will reverse\nengineer the first driver dropped by the user-mode agent that was reversed in Part 1. The\nprimary purpose of this driver is to support the stealth features and functionality of the\nZeroAccess malicious software delivery platform. This rootkit has low level disk access that\nallows it to create new volumes that are totally hidden from the victim’s operating system and\nAntivirus. Consider the case where someone attempts to remove the rootkit by formatting the\nvolume where their OS is installed (say the c:) and reinstalling Windows. ZeroAccess will\nsurvive this cleaning process and reinstall itself onto the fresh copy of Windows. This is likely\nvery frustrating for anyone attacked by ZeroAccess. We will also investigate the IRP hooking\nroutine that the rootkit employs to avoid detection and support invisibility features.\nZeroAccess has the ability to infect various system drivers that further support stealth. Lastly,\nwe will cover some vulnerabilities in the rootkit that allow for its detection using readily\navailable tools.\n\nFirst, lets report the metadata and hashes for this file:\n\nFileSize: 132.00 KB (135168 bytes)\n\nMD5: 83CB83EB5B7D818F0315CC149785D532\n\nSHA-1: 39C8FCEE00D53B4514D01A8F645FDF5CF677FFD2\n\nNo VersionInfo Available.\n\nNo Resources Available.\n\nWhen disassembly of this driver begins, the first thing that we notice is the presence of\nDebugging Symbols. What follows is a graphical skeleton for the order of execution between\nthe various code blocks:\n\n\n-----\n\nIn modern advanced rootkits, the first operation performed after decrypting and dropping\nfrom the Agent is to cover its presence from users and antivirus. The functionality scope of\nthis driver includes a set of operations to install a framework to make the infection resilient\nand almost impossible to remove, as well as completely infect the system drivers started by\nuser-mode Agent.\n\nThe most handy and easily approachable method for rootkit driver analysis is to attach\ndirectly to the module. We will load a kernel-mode debugger, such as Syser. In our case the\nentire ZeroAccess code is placed into DriverEntry (the main() of every driver). We will also\ndiscover various dispatch routines and system threads that would give a non-linear execution\nflow.\n\nLet’s check out the code from beginning:\n\n\n-----\n\nIf you remember, the selected system driver to be infected is stored as registry entry and\nstarts with a ‘dot’. In the above code block, we see the driver checking for this registry key\nentry. Next, you can see ResultLength, which belongs to the OBJECT_ATTRIBUTES\nstructure, is used specify attributes that can be applied to the various objects. To continue\nanalysis:\n\nWe see OBJECT_ATTRIBUTES is filled with NULL values (EAX) except ObjectName that\nwill contain RegistryPath, and then we have two subcalls. The first call performs registry key\nenumeration, then deletes it and returns the deletion status. The next call accomplishes the\nsame task, this time deleting:\n\nregistryMACHINESYSTEMCurrentControlSetEnumrootLEGACY_*driver_name*\n\nNext we see a call to an important routine:\n\n\n-----\n\n100037A5 mov Object, eax ; Object = DriverObject\n\n100037AA call sub_100036CA\n\nInside this sub we will see we have IRP Hooking routine.\n\n## __IRP Hooking__\n\nLet’s begin with looking at this block of code:\n\nHere we have one of the primary functionalities of ZeroAccess rootkit, the Disk Driver IRP\nHooking routine. Disk.sys is a drivers that is responsible for interacting heavily with\nhardware. Every operation from the OS that deals disk storage must pass through\nDriverDisk. If you aren’t familiar with this concept, here is a visual representation of the\nWindows disk storage stack:\n\nPicture is taken from http://technet.microsoft.com/enus/library/ee619734%28WS.10%29.aspx\n\n\n-----\n\nThe red arrow points where ZeroAccess is lives and works, you can see this is the lowest\nlevel of the storage devices stack. The closer to the hardware, the more stealthy the rootkit\ncan be. The technology used by ZeroAccess is simple conceptually, and has been found to\nbe the most effective.\n\nThe concept behind IRP hooking is to replace the original IRP dispatch routines with the\nrootkit’s custom IRP handlers. If the rootkit succeds in hooking, the controlled IRPs are\nredirected to the rootkit code that accomplishes a certain operations, usually devoted to\nmonitoring and/or invisibility and user deception. From a conceptual level, these high level\ngoals are performed by the rootkit by manipulating data:\n\nMonitoring is implemented when input data is somehow stored and transmitted\nInvisibility is implemented when data returned to other processes and functions is\nmodified\nUser deception is implemented when fake data is returned\n\nIn our case returned data is specifically crafted to cover traces of malicious files located in\nand around the victim’s filesystem.\n\nLet’s revert back to the latest code screenshot, as you can see IRP HandlerAddress is\ninserted into Object ( that is a pointer to DRIVER_OBJECT structure, which we detail later\non) + 38h that corresponds to PDRIVER_DISPATCH MajorFunction. This is a dispatch table\nconsisting of an array of entry points for the driver’s various dispatch routines. The array’s\nindex values are the IRP_MJ_XXX values representing each IRP major function code.\n\nWe see the original Disk IRP Dispatch Table is filled with the malicious rootkit dispatch\nfunction. Essentially the malicious IRP handling function is going to need to parse an\nimpressive amount of I/O request packets to verify if core rootkit files are touched. If it does\ndetect that rootkit files are being accessed, it will return a fake result and mark it as\ncompleted in the IRP.\n\nLet’s take a look at this function:\n\n\n-----\n\nThis function takes as arguments the previously described object pointer and the PIRP IRP.\nThe PRIP IRP is the IRP to parse. At first, the object is parsed with a DeviceObject of the\nZeroAccess Device. If two objects matches, the code calls sub_1000292A, which takes as\nan argument, the IRP itself . Next, it exits and returns the status given by this call. Inside the\ncall sub_1000292A we have schematically another set of IRP parsing rules, this time directly\nfocused on three specific areas:\n\nCore ZeroAccess rootkit file queries\nPower IRPs\nMalware IRP Requests\n\nThe I/O request to be faked are always managed in the same way, the function protype looks\nlike this:\n\nIrp->IoStatus.Status = FakeFailureStatus;\n\nThis completes the IRP via IofCompleteRequest function.\n\nPower IRPs are managed via PoStartNextPowerIrp and similar functions.\n\nFinally we have the IRP Traffic generated by ZeroAccess. Because of the nature of the traffic\nit is necessary to identify which process sent the request, this is accomplished by checking:\n\nIrp->Tail.Overlay.OriginalFileObject\n\n\n-----\n\nLet s go back to the main handling function. In cases where objects does not match, the\nobject is checked to see if the CurrentIrpStackLocation is 0x16. If it is 0x16, it is escalated via\nPoStartNextPowerIrp. The immediate effect of calling this routine lets the driver know it is\nfinished with the previous power IRP.\n\nThe driver must then call PoStartNextPowerIrp while the current IRP stack location points to\nthe current driver. Immediately after the code retrieves Irp>Tail.Overlay.CurrentStackLocation (which corresponds to an undocumented indirect use of\nIoGetCurrentIrpStackLocation). we have a PoCallDriver that passes a power IRP to the nextlowest driver in the device stack and exits. Let’s move on to the next block of code:\n\nHere we have a conditional branch. It needs to match various requirements, one of them\ngiven by the call sub_1000273D that returns a NTSTATUS value stored into a variable that\nwe called resStatOperation. Now if the conditional branch check fails, we suddenly reach a\npiece of code that sets IO_STATUS members and marks them as completed via\nIofCompleteRequest on the intercepted IRP.\n\n\n-----\n\nThe source code that likely created the completion code would have looked like:\n\nIrp->IoStatus.Information = 0;\n\nIrp->IoStatus.Status = resStatOperation;\n\nIofCompleteRequest(Irp, 1);\n\nreturn resStatOperation;\n\nIRPs that are not relevant to cloaking and hiding files are easly passed to the underlying\ndriver and processed by the original corresponding dispatch routine. As you have seen in\nthese code blocks, the whole parsing routine is based on the CurrentStackLocation struct\nmember. This feature can be a bit difficult to understand, so we will explain it a bit more. The\nI/O Packet structure consists of two pieces:\n\nHeader.\nVarious Stack Locations.\n\nIRP Stack Location contains a function code constituted by Major and Minor Code, basically\nthe most important is the Major Code because identifies which of a driver’s dispatch routines\nthe IOManager invokes when passing an IRP to a driver.\n\n## __End IRP Hooking__\n\nLet’ comeback now to the DriverEntry code\n\nInside call sub_10003108 we have an important piece of code:\n\n\n-----\n\nOf particular importance the parameter of IoCreateDevice pointed to by the red arrow.\nFILE_DEVICE_DISK creates a disk like structure. If device creation is successful, the object\nis transformed in a Temporary Object. This is done because a Temporary Object and can be\ndeleted later, meaning it can be removed from namespace, then next derefenced. The\nObDereferenceObject decreases the reference count of an object by one. If the object was\ncreated (in our case transformed into) a temporary objct and the reference count reaches\nzero, the object can be deleted by the system.\n\nAs you can see from code immediately after we have the following string:\n\nsystemrootsystem32config12345678.sav\n\nLet’s take a look at the next logical block of code:\n\n\n-----\n\nThe entire string 12345678.sav is passed as parameter to call sub_10002F87. Inside this call\nwe have some weak obsfucation. The algorithm is pretty easy to decipher and can be deobfuscated via a XOR + ADDITION where the key is a value extracted from Windows\nregistry.\n\nWhen reversing any kernel mode rootkit and you see the ZwCreateFile call, one of the\nparameters to inspect after the call is the member information of IO_STATUS_BLOCK\nstructure. This is the 4 parameter of ZwCreateFile. It contains the final completion status,th\nmeaning you can then determine if the file has been,\nCreated/Opened/Overwritten/Superdesed/etc.\n\nUpon further analysis we determined that this -random-.sav file works as a configuration file.\nIn addition to the information stored, there is a copy of original properties of the clean,\nuninfected system driver. If a user or file scanner accesses the infected driver, due to\nZeroAccess’s low level interaction with Disk driver, file will be substituted on fly with original\none. This will total deceive whatever process is inspecting the infected system driver.\n\nLet’s look again at our routine.\n\nAs you can see here the rootkit checks for exactly the same thing, it compares\nIoStatusBlock->Information with constant value 0x2. This value corresponds to\nFILE_CREATE. If file has a FILE_CREATE status, then ZwFsControlCode sends to this file a\n\n\n-----\n\nFSCTL_SET_COMPRESSION control code.\n\nThe ZwSetInformationFile routine changes various kinds of information about a file object. In\nour case we have as the FileInformationClass, FileEndOfFileInformation that changes the\ncurrent end-of-file information, supplied in a FILE_END_OF_FILE_INFORMATION structure.\nThe operation can either truncate or extend the file. The caller must have opened the file with\nthe FILE_WRITE_DATA flag set in the DesiredAccess parameter for this to work. Let’s look\nat the next block of code:\n\nThe ObReferenceObjectByHandle routine provides access validation on the object handle,\nand, if access can be granted, returns the corresponding pointer to the object’s body. After\nreferencing our file object, via IoGetRelatedDeviceObject, we have the pointer corresponding\nto its device object.\n\nIf you remember, the device driver was builded with FILE_DEVICE_DISK. This means that\nthe device represents a volume, as you can see from there code, there is a deviceObj>SectorSize reference.\n\nBy looking at the documentation for DEVICE_OBJECT we can see the following descriptor\nfor SectorSize member:\n\n“this member specifies the volume’s sector size, in bytes. The I/O manager uses this\n_member to make sure that all read operations, write operations, and set file position_\n_operations that are issued are aligned correctly when intermediate buffering is disabled. A_\n\n\n-----\n\n_default system bytes-per-sector value is used when the device object is created_\n\nThe DISK structure will serve the purpose of offering an easy way to covertly manage the\nrootkit files, namely, by managing this rootkit device as a common Disk.\n\nAt this point if you take a look at start code of this driver you will see that in DriverEntry() we\nhave a ‘.’ character check If the condition matches we have the execution flow previously\nseen, otherwise execution jumps directly to this last one piece of code:\n\nThe above instructions are fully commented. EBX points to the string of the randomly\nselected System Driver, call sub_10002F87 scrambles the ‘Snifer67’ string according to a\nvalue extracted from a registry key value. Next you can see a call that we have named\nHashCheck. It takes three arguments, HANDLE SourceString, int, PULONG HashValue:\n\n\n-----\n\nIf the hash check fails, inside the call sub_100036E9, MDL is released. Otherwise execution\nis reidrected toward call sub_100022C3, as shown below:\n\n\n-----\n\nWhat we have here is a method of interaction between kernel-mode and user-mode called\nmemory sharing. With memory sharing, it is possible to map kernel memory into user mode.\nThere are two common techniques for memory sharing, they are:\n\nShared objects and shared views.\nMapped memory buffers\n\nWe have already seen how Section Objects work in user-mode, in kernel-mode the concept\nis not very different. What changes in this case we have to deal with MDLs, and we need\nadditional security checks because sharing memory between kernel and user space can be\na pretty dangerous operation. After opening a Section into the target a View is created by\nusing ZwMapViewOfSection. Let’s suppose that you want to know where this section is\nopened, a fast way to discover this is via handle table check.To do this, the first step is to\nlocate where handle is stored. Simply point your debugger memory view to the\nSectionHandle parameter of ZwOpenSection.\n\nIf Section Opening is successful, in memory you will see the handle, and now we can query\nmore details about this handle. The syntax varies with your debugger of choice:\n\nIn Syser type: handle handle_number\n\nIn WinDbgtype : !handle handle_number ff\n\nHere is what the WinDbg output looks like:\n\n- !handle 1c0 ff\n\nHandle 1c0\n\nType Section\n\nAttributes 0\n\nGrantedAccess 0x6:\n\nNone\n\nMapWrite,MapRead\n\nHandleCount 22\n\nPointerCount 24\n\nName BaseNamedObjectswindows shell global counters\n\n\n-----\n\nObject Specific Information\n\nIn our case, the Section Object and successive View is opened into the randomly chosen\nsystem driver. It’s important to specify that the usage of ZwMapViewOfSection maps the view\ninto the user virtual address space of the specified process. Mapping the driver’s view into\nthe system process prevents user-mode applications from tampering with the view and\nensures that the driver’s handle is accessible only from kernel mode. Let’s take a look at the\nnext code block:\n\nThe MmAllocatePagesForMdl routine allocates zero-filled, nonpaged, physical memory\npages to an MDL. In ESI, if allocation succeeds, we have the MDL pointer, used by\nMmMapLockedPagesSpecifyCache that maps the physical pages that are described by MDL\npointer, and allows the caller to specify the cache behavior of the mapped memory. The\nBaseAddress parameter specifies the Starting User Address to map the MDL to. When this\nparam value is NULL the system will choose the StartingAddress. EBX contains the return\nvalue that is the starting address of the mapped pages. Next there is a classic memcpy,\nwhich the author has documented in the screenshot.\n\n\n-----\n\nThis call returns a true/false value based on the success/fail of ZwMapViewOfSection.\n\nIf the function fails, execution will jump to the MDL Clear call previously seen and then exits.\nIn the else case we land to the final piece of this driver. Once again, let’s clarify that the\nscope of all of these operations performed on the randomly chosen System Driver, the\npurpose is inoculate malicious code delivered by the authors of ZeroAccess and to ensure\nthat the rootkit survives any sort of cleaning or antivirus operation. Lets review the next block\nof code:\n\nThis section is rich in functionality that is of interest to malware reverse engineers. Let’s first\nlook at the first call of the routine, call sub_10002D9F, which takes as argument the\npreviously described SourceString. Further analysis shows:\n\n\n-----\n\nYou should be able understand what this piece of code does, it’s pretty similar to the Memory\nSharing routine previously seen. This time SectionObject is applied to the randomly chosen\ndriver.\n\nLet’s now examine the second call:\n\n\n-----\n\nThis is an interesting piece of code. ObReferenceObjectByName is an Undocumented\nExport of the kernel declared as follow:\n\nNTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(\n\nPUNICODE_STRING ObjectName,\n\nULONG Attributes,\n\nPACCESS_STATE AccessState,\n\nACCESS_MASK DesiredAccess,\n\nPOBJECT_TYPE ObjectType,\n\nKPROCESSOR_MODE AccessMode,\n\nPVOID ParseContext OPTIONAL,\n\nOUT PVOID* Object);\n\n\n-----\n\nThis function is given a name of an object, and then the routine returns a pointer to the body\nof the object with proper ref counts, the wanted ObjectType is clearly specified by the 5th\nparameter ( POBJECT_TYPE ). In our case it will be IoDriverObjectType.\n\n_ObReferenceObjectByName is a handy function largely used by rootkits to steal objects or_\nas a function involved in the IRP Hooking Process. In our case we have an object stealing\nattempt, if you remember IRP Hook already happened previously in our analysis. The way\nthis works is by locating the pointer to the driver object structure (DRIVER_OBJECT) that\nrepresents the image of a loaded kernel-mode driver, the rootkit is able to access, inspect\nand modify this structure.\n\nNow, let’s take a look at this block code uncommented. We want to show you the WinDbg\nview with addition of -b option and the complete DRIVER_OBJECT structure:\n\n0:001> dt nt!_DRIVER_OBJECT -b\n\nntdll!_DRIVER_OBJECT\n\n+0x000 Type : Int2B\n\n+0x002 Size : Int2B\n\n+0x004 DeviceObject : Ptr32\n\n+0x008 Flags : Uint4B\n\n+0x00c DriverStart : Ptr32\n\n+0x010 DriverSize : Uint4B\n\n+0x014 DriverSection : Ptr32\n\n+0x018 DriverExtension : Ptr32\n\n+0x01c DriverName : _UNICODE_STRING\n\n+0x000 Length : Uint2B\n\n+0x002 MaximumLength : Uint2B\n\n+0x004 Buffer : Ptr32\n\n+0x024 HardwareDatabase : Ptr32\n\n+0x028 FastIoDispatch : Ptr32\n\n+0x02c DriverInit : Ptr32\n\n\n-----\n\n+0x030 DriverStartIo : Ptr32\n\n+0x034 DriverUnload : Ptr32\n\n+0x038 MajorFunction : Ptr32\n\nThis code is easy to understand. From the base pointer there is an additional value that\nreaches the wanted DRIVER_OBJECT member, the other blue colorred members are stolen.\n\nWe get more clarity if you take a look at last member entry that corresponds (you can see\nthis via a live debugging session) to DriverDisk. Next ObfDereferenceObject is called, the\ngoal is to dereference the Driver Object previously obtained with\nObReferenceObjectByName. We want to show the fact that the ‘f’ variant of\nObDereferenceObject is. This ‘f’ verion is undocumented, before this call we do not see the\ntypical stacked parameter passage. This is the fastcall calling method.\n\nNow let’s see the next call:\n\nKeInitializeQueue initializes a queue object on which threads can wait for entries,\nimmediately after as you can see, after object referencing, we have a\nPsCreateSystemThread that creates a system thread that executes in kernel mode and\n\n\n-----\n\nreturns a handle for the thread. Observe that the last parameter pushed StartContext is the\nstolen DriverObject, this parameter supplies a single argument that is passed to the thread\nwhen execution begins.\n\nNow, we have a break in linear execution flow, so we need to put a breakpoint into the\nStartRoutine to be able to catch from debugger what happens into this System Thread.\n\n## __System Thread Analysis__\n\nLet’s check out the code of this System Thread.\n\nLike the DPC (Deferred Procedure Call), the System Thread will serve network purposes.\n\n## __End Of System Thread Analysis__\n\nNow we are on the final piece of code of DriverEntry, an IoAllocateWorkItem is called, this\nfunction allocates a work item, its return value is a pointer to IO_WORKITEM structure.\n\n\n-----\n\nA driver that requires delayed processing can use a work item, which contains a pointer to a\ndriver callback routine that performs the actual processing. The driver queues the work item,\nand a system worker thread removes the work item from the queue and runs the driver’s\ncallback routine. The system maintains a pool of these system worker threads, which are\nsystem threads that each process one work item at a time.\n\nIt’s interesting that a DPC that needs to initiate a processing task which requires lengthy\nprocessing or makes a blocking call should delegate the processing of that task to one or\nmore work items. While a DPC runs, all threads are prevented from running. The system\nworker thread that processes a work item runs at IRQL = PASSIVE_LEVEL. Thus, the work\nitem can contain blocking calls. For example, a system worker thread can wait on a\ndispatcher object.\n\nIn our case if IoAllocateWorkItem returns a NULL value (this could happen if there are not\nenough resources), execution jumps directly to IoCreateDriver, otherwise a Kernel Timer is\ninstalled and a DPC called. But let’s see in detail what this mean.\n\nKeInitializeTimer fills the KTIMER structure, successively KeInitializeDpc creates a Custom\nDPC and finally KeSetTimerEx sets the absolute or relative interval at which a timer object is\nto be set to a Signaled State.\n\nBOOLEAN KeSetTimerEx(\n\n__inout PKTIMER Timer,\n\n__in LARGE_INTEGER DueTime,\n\n__in LONG Period,\n\n__in_opt PKDPC Dpc\n\n);\n\nDue to the fact that we are in presence of a DPC, the whole routine is a classical\nCustomTimerDpc installation, this Deferred Procedure Call is executed when timer object’s\ninterval expires.\n\nWhat emerges from the whole routine is another break in linear execution flow of the device\ndriver given by KeInitializeDpc.The DPC provides the capability of breaking into the\nexecution of the currently running thread (in our case when timer expires) and executing a\nspecified procedure at IRQL DISPATCH_LEVEL. DPC can be followed in the debugger by\nplacing a breakpoint into the address pointed by DeferredRoutine parameter of\nKeInitializeDpc.\n\n## __Deferred Procedure Call Analysis__\n\n\n-----\n\nThis is the core instructions related to the Deferred Procedure Call installed:\n\nWe need to inspect WorkerRoutine, pointed by the IoQueueWorkItem parameter. Without\ngoing into unnecessary detail, from inspection of WorkerRoutine we find the\nRtlIpv4StringToAddressExA function. It converts a string representation of an IPv4 address\nand port number to a binary IPv4 address and port. By checking IDA NameWindow we can\nsee via CrossReferences that reconducts to DPC routine the following strings:\n\nDeviceTcp\n\nDeviceUdp\n\ndb ‘GET /%s?m=%S HTTP/1.1‘,0Dh,0Ah\n\ndb ‘Host: %s‘,0Dh,0Ah\n\ndb ‘User-Agent: Opera/9.29 (Windows NT 5.1; U; en)‘,0Dh,0Ah\n\ndb ‘Connection: close‘,0Dh,0Ah\n\nAnd\n\ndb ‘GET /install/setup.php?m=%S HTTP/1.1‘,0Dh,0Ah\n\ndb ‘Host: %s‘,0Dh,0Ah\n\ndb ‘User-Agent: Opera/9.29 (Windows NT 5.1; U; en)‘,0Dh,0Ah\n\ndb ‘Connection: close‘,0Dh,0Ah\n\nThe DPC is connecting on the network at the TDI (Transport Data Interface), this is\nimmediately clear due to the usage of TDI providers DeviceTcp and DeviceTcp. The purpose\nof this is clear, the DPC downloads other malicious files that will be placed into:\n\n??C2CAD972#4079#4fd3#A68D#AD34CC121074\n\n**Vulnerabilities in the ZeroAccess Rootkit.**\n\n\n-----\n\nEvery rootkit has features that are more stealthy than others. In our case with the\nZeroAccess rootkit the filesystem stealth features are very good. When reverse\nengineering malware to this level, we discover some weaknesses in the stealth model that\nwe can exploit. This results in some common markers of rootkit infection.\n\nIn this driver the most visible points are:\n\nSystem Thread\nKernel Timer and DPC\nUnnamed nature of the Module\n\nLet’s see DPC infection from an investigation perspective. A DPC is nothing more that a\nsimple LIST_ENTRY structure with a callback pointer, represented by KDPC structure. This\nstructure is a member of DEVICE_OBJECT structure, so a easy method to be able to\nretrieve this Device Object is to surf inside and locate presence of DPC registered routines.\nTo accomplish this task we usually use KernelDetective tool, really handy application that\ncan greatly help kernel forensic inspections.\n\nDPC is associated to a Timer Object so we need to enumerate all kernel timers:\n\nAs you can see, the timer is suspect because module is unnamed, and the period\ncorresponds to the one previously seen into the code block screenshot. Scrolling down into\nan associated DPC we have the proof that ZeroAccess is present:\n\n\n-----\n\nAs you should remember this driver also creates a System Thread via\nPsCreateSystemThread. This operation is extremely visible because the function creates a\nsystem process object. A system process object has an address space that is initialized to\nan empty address space that maps the system.The process inherits its access token and\nother attributes from the initial system process. The process is created with an empty handle\ntable.\n\nAll this implies that when looking for a rootkit infection, you should also include inspecting the\nSystem Thread. These are objects that really easy to reach and enumerate; we can use the\nTuluka ( [http://www.tuluka.org/ ) tool to automatically discover suspicious system threads:](http://www.tuluka.org/)\n\n\n-----\n\n## __End Of Deferred Procedure Call Analysis__\n\nAfter the CustomTimerDpc installation, finally we land to the last piece of code where\nIoCreateDriver is called. This is another undocumented kernel export.\n\nNTSTATUS WINAPI IoCreateDriver(\n\nUNICODE_STRING *name,\n\nPDRIVER_INITIALIZE init ) ;\n\n\n-----\n\nThis function creates a driver object for a kernel component that was not loaded as a driver.\nIf the creation of the driver object succeeds, the initialization function is invoked with the\nsame parameters passed to DriverEntry.\n\nSo we have to inspect this ‘new’ DriverEntry routine.\n\n## __New DriverEntry__\n\nHere is the code for the new DriverEntry:\n\nObject Directory is opened via ZwOpenDirectoryObject and after allocating a block of Pool\nMemory, this block will be used to store output of ZwQueryDirectoryObject.\n\n\n-----\n\nIn this piece of code, rootkit loops inside Object Directory, and assembling for each iteration\nthe following string:\n\n[deviceidedevice_name](http://10.10.0.46/smb://device//ide//device_name)\n\nFrom Object Name obtains a DEVICE_OBJECT pointer by using IoGetDeviceObjectPointer.\nThis pointer gives us the following relations:\n\nDeviceObject = Object->DeviceObject;\n\ndrvObject = DeviceObject->DriverObject;\n\nObfReferenceObject(DeviceObject);\n\nObMakeTemporaryObject(DeviceObject);\n\nObfDereferenceObject(Object);\n\nNow we have both DeviceObject and DriverObject.\n\n\n-----\n\nThe DriverObject creates the corresponding device and next verifies if DeviceObject>DeviceType is a FILE_DEVICE_CONTROLLER . If so, it then performs the aforementioned\nobject stealing routine.\n\nEssentially the rootkit searches through the stack of devices and selects IDE devices that are\nresponsible of interactions with victim’s disk drives.\n\nIDE devices are created by the atapi driver. The first two you see in the illustration below,\nserve as the CD and Hard Disk. The last two are controllers that work with with Mini-Port\nDrivers. This is why ZeroAccess looks for FILE_DEVICE_CONTROLLER types (IdePort1\nand IdePort0)\n\nThis means that ZeroAccess must add object stealing capabilities not only Disk.sys but also\nAtapi.sys.\n\nLet’s now observe with DeviceTree how driver and device anatomy change after a\nZeroAcess rootkit infection:\n\n\n-----\n\nWe have some critical evidence of a ZeroAccess rootkit infection, we see presence of two\nAtapi DRV instances where one of them has a stack of Unnamed Devices.This behavior is\nalso typical of a wide range of rootkits. This output is matches perfectly with the analysis of\nthe driver code instructions performed previously. .\n\nIn the second instance, we have evidence that is a bit less evident. We see two new devices\nthat belong to Atapi Driver:\n\nPciIde0Channel1-1\nPciIde0Channel0-0\n\nHere we see another example of object stealing with the IRP Hook for FileSystem hiding\npurposes, this time based on DevicePCI.\n\nThis completes the analysis of the first driver.\nNext, in part 3 we reverse Engineering the Kernel-Mode Device Driver Process Injection\nRootkit >>\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2010/2010-11-20 - The Kernel-Mode Device Driver Stealth Rootkit.pdf"
    ],
    "report_names": [
        "2010-11-20 - The Kernel-Mode Device Driver Stealth Rootkit.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535658,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653688029,
    "ts_modification_date": 1653688029,
    "files": {
        "pdf": "https://archive.orkl.eu/0aeb66843cb5a9e7b5be3e31b2052e9c7107cf86.pdf",
        "text": "https://archive.orkl.eu/0aeb66843cb5a9e7b5be3e31b2052e9c7107cf86.txt",
        "img": "https://archive.orkl.eu/0aeb66843cb5a9e7b5be3e31b2052e9c7107cf86.jpg"
    }
}