{
    "id": "1a1fb5f8-97be-4b89-8bec-9df2fa31843b",
    "created_at": "2023-01-12T15:07:11.404442Z",
    "updated_at": "2025-03-27T02:05:20.527961Z",
    "deleted_at": null,
    "sha1_hash": "7b3ae931f438a8bb6ad142677f54dc05367cd695",
    "title": "2021-05-26 - Melting Ice – Tracking IcedID Servers with a few simple steps",
    "authors": "",
    "file_creation_date": "2022-05-28T03:10:58Z",
    "file_modification_date": "2022-05-28T03:10:58Z",
    "file_size": 1380227,
    "plain_text": "# Melting Ice – Tracking IcedID Servers with a few simple steps\n\n**[research.checkpoint.com/2021/melting-ice-tracking-icedid-servers-with-a-few-simple-steps/](https://research.checkpoint.com/2021/melting-ice-tracking-icedid-servers-with-a-few-simple-steps/)**\n\nMay 26, 2021\n\nMay 26, 2021\n**Research by: Alex Ilgayev**\n\n## Introduction\n\nTracking botnets usually demands a significant amount of effort, time, and threat intelligence\nknow-how. The barrier to entry grows even larger in cases of multi-staged complex malware\nfamilies such as IcedID, Emotet, and QakBot. Therefore, as malware analysts, we tend to\nlook for ways to automate the process as much as we can — collecting a large scale of\nsamples, identifying them, extracting their configurations, and then having these yield value\nwe are interested in, such as a clearer threat intel picture or a more up-to-date domain\nreputation engine.\n\nWhile the malware analysis life is often as difficult as described above, it doesn’t have to be.\nSometimes, if we are clever, 10% of the work will get us 90% of the result we are interested\nin. In this article, we demonstrate such a sleight-of-hand and show how to hunt IcedID C&C\nservers quickly and without tracking or analyzing any samples.\n\n## IcedID Background\n\n\n-----\n\nThe IcedID banker malware first emerged in September 2017 and has made significant\nprogress since then. This threat, also known as BokBot, has constantly been growing in the\npast year and boasts a wide range of malicious capabilities such as browser hooking,\ncredential theft, MiTM proxy setup and a VNC module, among others.\n\nThe bot’s internal capabilities, including infection chain and malicious components, were\n[described thoroughly by Malwarebytes,](https://blog.malwarebytes.com/threat-analysis/2019/12/new-version-of-icedid-trojan-uses-steganographic-payloads/) _[Group-IB, and](https://blog.group-ib.com/icedid)_ _[Binary Defense past publications.](https://www.binarydefense.com/icedid-gziploader-analysis/)_\n\nAccording to the latest infection chain presented by Binary Defense researchers, recent\niterations of IcedID contain three malicious components – The entry-point DOC/XLS\ncontaining malicious macros; a first stage payload; and finally a second-stage payload, which\nitself consists of two sub-parts – A 64bit DLL loader, and the encrypted actual bot disguised\nas a “.dat” file.\n\nEach second-stage payload usually contains 2-4 unique embedded domains, which all\nresolve to the same IP address. Suppose that we set an objective to track these domains/IPs\nand block them; naturally, we are interested in the quickest and painless way to do it.\n\nThe communication protocol for the victims is HTTPS, so we inspected the bundled TLS\ncertificate. As we can observe below, the IcedID people care more about the hard, concrete\nguarantees provided by RSA-2048 and less about following security guidelines; the\ncertificate is issued to the defaultly-named “Internet Widgits Pty, Ltd” which resides in “Some\nState”.\n\n**Figure 1 – Sample IcedID C&C certificate**\n\n\n-----\n\nIf we compare this IcedID certificate with a default self-signed certificate, the most notable\ndifference would be the common-name field. Public servers should have their FQDN (e.g.\n\n`checkpoint.com ) in this field and not` `localhost` like in this case.\n\nYou probably understand where this is going; we promptly got to scanning the wide web and\nlooking for other servers which present this certificate.\n\n## Enumerating Servers\n\nLoath to reinvent the wheel, we opted to use the popular internet scanning platform Censys\nto create a list of potential C&C candidates. Additional internet scanning platforms, like\n_Shodan, could be fit for this purpose as well._\n\nThe Censys engine gave us a great amount of control for certificate querying. After some\ntweaking and fiddling, we constructed the following query:\n```\n443.https.tls.certificate.parsed.issuer_dn: \"CN=localhost, C=AU, ST=SomeState, O=Internet Widgits Pty Ltd\" and\n443.https.tls.certificate.parsed.subject_dn: \"CN=localhost, C=AU, ST=SomeState, O=Internet Widgits Pty Ltd\"\n\n```\n\n-----\n\n**Figure 2 – One of Censys results with the certificate**\n\nIf you doubt the uniqueness of having `localhost as a common name in a certificate, a`\nshort experiment proves it handily: the dozens of servers our search yielded may seem like\nmuch, but if you omit the requirement `CN=localhost from the search query, the results`\nexplode in size and number in the ten of thousands.\n\nAt the moment, we cannot assume that each of these servers is an active IcedID malicious\nC&C, so we need to validate them. Luckily, this is possible due to another unique property\nwe discovered during the research.\n\n## Validating The Servers\n\nWhile we were reverse-engineering the bot functionality, we noticed the bot makes a pretty\ninteresting test before communicating with the C&C server. The following code is part of a\ncallback function of `WinHttpSendRequest` and is called before contacting the C&C.\n\n\n-----\n\n**Figure 3 – Certificate verification code**\n\nIn simple words, this code runs Fowler–Noll–Vo 32 bit hash function over the certificate’s\npublic key and compares it with the assigned serial number of the certificate. The\ncommunication proceeds only when that comparison matches (Or with an XOR-ed value\n```\n0x384A2414 ).\n\n```\nThe Certificate Serial Number field is assigned by the Certificate Authority and provides a\nunique identifier for each generated certificate. The Certificate Issuer must ensure that no\ntwo distinct certificates with the same Certificate Issuer DN contain the same serial number,\nbut no one can guarantee that.\n\nIn our case, the certificate is self-signed, and the malware operators assign its C&C serial\nnumber field uniquely according to the above logic. Using this verification algorithm\nourselves, against a suspected server, we can make sure it is part of the IcedID\ninfrastructure. We provided a simple python script to verify that logic against a supplied\nremote server in Appendix A.\n\nApplying that method, we discovered that most of the previous potential results were IcedID\nrelated and narrowed the list down to 52 servers. Given the unique certificate property paired\nwith the uncommon hash function, we could safely deduce that these servers are\ncomponents in IcedID C&C infrastructure. With this list in hand, we went to take a closer look\nat the servers.\n\n## Server Analysis\n\nBy analyzing their internet-facing banners, we could find several similar properties for most\nof the deployed servers. The most common properties were open ports, operating system,\nand web-server:\n\n**Open Ports – All servers had port 443 available, 94% also listened on port 80 and 77% on**\nSSH port (22).\n\n**Operating System – 77% of the servers were running a Debian OS.**\n\n\n-----\n\n**Web Server – 94% of the servers were running nginx web-server.**\n\nWe could also see that most of the servers reside in Romania, United States, and Germany:\n\n**Figure 4 – IcedID servers locations**\n\nAnother angle of analysis is via a passive DNS service such as RiskIQ. Using this service\nallows us to find associated domains for each IP address we have and expand our threat\nintel picture. These extra domains must logically be embedded in some samples that we do\nnot have direct access to. For example, one of the addresses we found was\n```\n152[.]89.247.60, which unresolved to the following IcedID domains:\nformgotobig[.]top\nponduroviga[.]top\ntranmigrust[.]club\naswenedo[.]space\n\n## Summary\n\n```\nIt is a sad fact of life that doing the “right thing” can backfire. Such is the case for IcedID\ncampaign maintainers here; they produced a self-signed certificate and had their malicious\noperation support HTTPS, a laudable effort that the vast majority of malware cannot be\nbothered with, and even some long-running legitimate websites could not be bothered with\nfor the longest time. By doing this, they made it much more challenging to instigate a hostile\ntakeover of their network — but they also made all their servers basically respond to\nstandard scanning services with a cheerful “Hi, I’m a malicious C&C”.\n\nOnce these servers were exposed, we were able to continuously track them and analyze\ntheir behavior without ever running a regular expression, never mind launching a debugger\nor disassembler. For someone running a malicious campaign, this is a nightmare scenario;\nthey aim to place the “prize” of the continuously updating C&C server list just out of reach, at\n\n\n-----\n\nthe top of the tier list. Instead, due to this too-clever-by-half TLS business, collecting the\nservers (and obtaining a bunch of juicy information, which is out of scope for this article)\nbecame within the analyst’s capabilities with a week of experience. As a wise person once\nsaid, think before using a technique, or your opponent will use it against you.\n\n## IOC\n\nIcedID C&C servers:\n```\n83[.]97.20.249\n83[.]97.20.174\n194[.]5.249.52\n45[.]153.240.135\n194[.]5.250.104\n152[.]89.247.60\n91[.]193.19.97\n194[.]5.249.81\n83[.]97.20.73\n194[.]5.250.35\n83[.]97.20.176\n194[.]5.250.46\n212[.]114.52.186\n91[.]193.19.37\n45[.]147.231.113\n188[.]119.148.75\n185[.]38.185.90\n45[.]138.172.179\n91[.]193.19.51\n83[.]97.20.122\n194[.]5.249.103\n139[.]60.161.63\n194[.]5.249.86\n139[.]60.161.48\n185[.]33.85.35\n194[.]5.249.97\n79[.]141.164.241\n194[.]5.249.90\n193[.]109.69.52\n194[.]5.249.54\n185[.]70.184.87\n79[.]141.166.39\n146[.]0.77.92\n31[.]184.199.11\n45[.]129.99.241\n194[.]5.249.46\n185[.]123.53.202\n\n```\n\n-----\n\n```\n146[.]0.77.18\n31[.]24.228.170\n45[.]147.230.88\n83[.]97.20.254\n45[.]147.230.82\n194[.]5.249.72\n46[.]17.98.191\n45[.]153.241.115\n185[.]70.184.41\n139[.]60.161.50\n194[.]5.249.143\n79[.]141.161.176\n5[.]149.252.179\n45[.]147.228.198\n91[.]193.19.251\n\n## Appendix A\n\n```\nTesting a server for IcedID certificate:\n\n\n-----\n\n```\nimport idna\nfrom socket import socket\nfrom OpenSSL import SSL\nfrom cryptography.hazmat.primitives.serialization import Encoding\nfrom cryptography.hazmat.primitives.serialization import PublicFormat\ndef fnv1a_32(data: bytes) -> int:\n  \"\"\"Fowler–Noll–Vo hash function variation.\n  Args:\n    data (bytes): Input data\n  Returns:\n    int: Output 32 bit hash\n  \"\"\"\n  hval_init = 0x811c9dc5\n  fnv_prime = 0x01000193\n  fnv_size = 2 ** 32\n  hval = hval_init\n  for byte in data:\n    hval = hval ^ byte\n    hval = (hval * fnv_prime) % fnv_size\n  return hval\ndef get_certificate(hostname: str, port: int):\n  \"\"\"Connects to the remote server,\n  and retrieves the certificate.\n  Args:\n    hostname (str): Remote hostname\n    port (int): Remote port (usually 443)\n  Returns: \n    Certificate object\n  \"\"\"\n  hostname_idna = idna.encode(hostname)\n  # We are building a SSL context on top of a raw socket.\n  sock = socket()\n  sock.connect((hostname, port))\n  ctx = SSL.Context(SSL.SSLv23_METHOD)\n  ctx.check_hostname = False\n  # the cert is self-signed so we don't want to verify it\n  ctx.verify_mode = SSL.VERIFY_NONE\n  # making SSL handshake\n  sock_ssl = SSL.Connection(ctx, sock)\n  sock_ssl.set_connect_state()\n  sock_ssl.set_tlsext_host_name(hostname_idna)\n  sock_ssl.do_handshake()\n  # retrieving certificate and converting it to an cryptography object\n  cert = sock_ssl.get_peer_certificate()\n\n```\n\n-----\n\n```\n  crypto_cert cert.to_cryptography()\n  sock_ssl.close()\n  sock.close()\n  return crypto_cert\ndef test_is_icedid_c2(hostname: str, port: int) -> bool:\n  \"\"\"Testing whether a remote server is part of IcedID\n  C&C infrastructure.\n  Args:\n    hostname (str): Remote hostname\n    port (int): Remote port (usually 443)\n  Returns:\n    bool: True if the server is IcedID verified, or False otherwise.\n  \"\"\"\n  try:\n    # We query the server and retrieve its certificate.\n    cert = get_certificate(hostname, port)\n    serial_number = cert.serial_number\n    # Getting the public key, and hashing it.\n    public_key = cert.public_key().public_bytes(Encoding.DER, PublicFormat.PKCS1)\n    fnv_hash = fnv1a_32(public_key) & 0x7fffffff\n    # Finally comparing the hash to the serial number.\n    if serial_number == fnv_hash or serial_number == fnv_hash ^ 0x384A2414:\n      return True\n  except Exception as e:\n    return False\n  return False\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-26 - Melting Ice – Tracking IcedID Servers with a few simple steps.pdf"
    ],
    "report_names": [
        "2021-05-26 - Melting Ice – Tracking IcedID Servers with a few simple steps.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536031,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1653707458,
    "ts_modification_date": 1653707458,
    "files": {
        "pdf": "https://archive.orkl.eu/7b3ae931f438a8bb6ad142677f54dc05367cd695.pdf",
        "text": "https://archive.orkl.eu/7b3ae931f438a8bb6ad142677f54dc05367cd695.txt",
        "img": "https://archive.orkl.eu/7b3ae931f438a8bb6ad142677f54dc05367cd695.jpg"
    }
}