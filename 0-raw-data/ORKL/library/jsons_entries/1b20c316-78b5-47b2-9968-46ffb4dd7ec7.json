{
    "id": "1b20c316-78b5-47b2-9968-46ffb4dd7ec7",
    "created_at": "2022-10-25T16:48:16.183434Z",
    "updated_at": "2025-03-27T02:13:34.661501Z",
    "deleted_at": null,
    "sha1_hash": "73ab28174d255e1168f7f37a1059e7724c030081",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-07-26T22:21:38Z",
    "file_modification_date": "2021-07-26T22:21:44Z",
    "file_size": 816340,
    "plain_text": "## TG1021: “Praying Mantis”  DISSECTING AN ADVANCED MEMORY-RESIDENT ATTACK\n\n#### July 2021\n\n Sygnia Incident Response Team\n\n\n-----\n\n# Overview\n\n### The Sygnia Incident Response team identified  an advanced and persistent threat actor, operating almost completely  in-memory. The operators behind the activity targeted Windows internet-facing servers, using mostly deserialization attacks, to load a completely volatile, custom malware platform tailored for the Windows IIS environment. Sygnia refers to this threat actor as “Praying Mantis”.\n\n1 [Copy-paste compromises](https://www.cyber.gov.au/sites/default/files/2020-06/ACSC-Advisory-2020-008-Copy-Paste-Compromises.pdf)\n\n\nDuring the past year, Sygnia’s Incident Response team has been\nresponding to a series of targeted cyber intrusion attacks,\nperformed by a highly capable and persistent threat actor –\nTG1021: “Praying Mantis”. These attacks targeted prominent\norganizations and compromised their networks by exploiting\ninternet facing servers.\n\nThe initial foothold within a network was obtained by leveraging\na variety of deserialization exploits targeting Windows IIS servers\nand web applications. The activity observed suggests that the\nthreat actor is highly familiar with the Windows IIS platform, and\nequipped with 0-day exploits.\n\nTG1021 utilize a completely volatile and custom malware\nframework tailor-made for IIS servers. The core component,\nloaded on to internet facing IIS servers, intercepts and handles\nany HTTP request received by the server. TG1021 also use an\nadditional stealthy backdoor and several post-exploitations\nmodules to perform network reconnaissance, elevate\nprivileges, and move laterally within networks.\n\nThe nature of the activity and general modus-operandi suggest\nTG1021 to be an experienced stealthy actor, highly aware of\nOPSEC (operations security). The malware used by TG1021\nshows a significant effort to avoid detection, both by actively\ninterfering with logging mechanisms, successfully evading\ncommercial EDRs and by silently awaiting incoming\nconnections, rather than connecting back to a C2 channel and\ncontinuously generating traffic. Furthermore, the threat actor\nactively removed all disk-resident tools after using them,\neffectively giving up on persistency in exchange for stealth.\n\nThe threat actor’s tactics, techniques, and procedures (TTPs)\nstrongly correlate with the ones described in an advisory\npublished by the Australian Cyber Security Centre (ACSC) –\n“Copy-paste compromises”[1]. The advisory, published in June\n2020, details the activity of a sophisticated state-sponsored\nactor which represents “the most significant, coordinated\n_cyber-targeting against Australian institutions the Australian_\n_Government has ever observed.”_\n\n2\n\n\n-----\n\n# Table of Contents\n\nOverview ............................................................................................................................................................................................................................ 2\n\nWindows IIS Server & Web Application Exploits .............................................................................................................................................................. 4\n\nCheckbox Survey RCE Exploit (CVE-2021-27852) ....................................................................................................................................................... 4\n\nVIEWSTATE Deserialization Exploit ................................................................................................................................................................................. 5\n\nAltserialization Insecure Deserialization ....................................................................................................................................................................... 6\n\nTelerik-UI Exploit (CVE-2019-18935, CVE-2017-11317) ................................................................................................................................................. 7\n\nToolset Infrastructure & IIS Platform Malware ................................................................................................................................................................. 7\n\nNodeIISWeb Malware ................................................................................................................................................................................................... 8\n\nHooking Mechanism .................................................................................................................................................................................................. 9\n\nPayload Search ........................................................................................................................................................................................................ 10\n\nModule Reflective Loading ..................................................................................................................................................................................... 11\n\nJScript Payload Execution ....................................................................................................................................................................................... 12\n\nTraffic Forwarding ..................................................................................................................................................................................................... 12\n\nNodeIISWeb Reflective Loaders ................................................................................................................................................................................. 14\n\nReflective Loader DLL .............................................................................................................................................................................................. 14\n\nLoader Web Shell ..................................................................................................................................................................................................... 15\n\nSecond Stage Malware - ExtDLL.dll ........................................................................................................................................................................... 17\n\nAdditional Modules ..................................................................................................................................................................................................... 18\n\nPSRunner.dll .............................................................................................................................................................................................................. 18\n\nForward.dll ................................................................................................................................................................................................................ 18\n\nPotatoEx.dll ............................................................................................................................................................................................................... 19\n\nE.dll ............................................................................................................................................................................................................................ 19\n\nPost-exploitation Activities .............................................................................................................................................................................................. 19\n\nCredential harvesting .............................................................................................................................................................................................. 19\n\nReconnaissance ....................................................................................................................................................................................................... 20\n\nLateral Movement ................................................................................................................................................................................................... 20\n\nSimilarities to the Copy-Paste threat actor ................................................................................................................................................................... 20\n\nDefending Against TG1021 Attacks ............................................................................................................................................................................... 20\n\nSealing .NET Deserialization Exploits & Best Practices............................................................................................................................................... 21\n\nIndicators of Compromise .......................................................................................................................................................................................... 22\n\nFiles ............................................................................................................................................................................................................................ 22\n\nAdditional IOCs ........................................................................................................................................................................................................ 23\n\nMITRE ATT&CK Breakdown .............................................................................................................................................................................................. 24\n\n3\n\n\n-----\n\n# Windows IIS Server & Web Application Exploits\n\nDuring the past year Sygnia has been monitoring attacks conducted by TG1021. The actor leveraged a variety of\nexploits targeting internet facing servers to gain initial access to target networks. These exploits abuse deserialization\nmechanisms and known vulnerabilities in web applications and are used to execute a sophisticated memoryresident malware that acts as a backdoor. This malware will be referred to as the “NodeIISWeb” malware.\n\nThe threat actor uses an arsenal of web application exploits and is an expert in their execution. The swiftness and\nversatility of operation combined with the sophistication of post-exploitation activities suggest an advanced and\nhighly skillful actor conducted the operations. The following four exploits were used by the threat actor to\ncompromise target systems.\n\n### Checkbox Survey RCE Exploit (CVE-2021-27852)\n\nOne of the vulnerabilities that the threat actor leveraged to exploit IIS servers is a 0-day vulnerability associated with\nan insecure implementation of the deserialization mechanism within the “Checkbox Survey” web application, a\ncommercial survey platform. The vulnerability in the “Checkbox Survey” application enables remote code execution\n(RCE) on the target resulting with the initial compromise of an IIS server. Analysis of the activity found the vulnerability\nresides in an insecure implementation of the VIEWSTATE mechanism in .NET.\n\nVIEWSTATE is a mechanism in .NET used to maintain and preserve web page session data between a client and a\nserver. When using this feature any client that browses an application receives a serialized .NET object that contains\nthe values of specific variables. When the client sends an HTTP request back to the web application, the VIEWSTATE\nobject is sent along with it, which in turn gets deserialized and processed on the server’s side setting the variables to\ntheir previous values.\n\nThe vulnerability in “Checkbox Survey” was identified on a specific webpage in the application where the methods\noriginally used to handle the VIEWSTATE mechanism were replaced with an insecure and compressed version called\nVSTATE. As illustrated in Figure 1, the new “LoadPageStateFromPersistenceMedium” method does not validate the\nintegrity of the data passed in the VSTATE variable, blindly triggering the deserialization process. Sending a crafted\nVSTATE variable which exploits the “LosFormatter” deserialization process would allow a threat actor to execute code\nremotely on the Checkbox application server.\n\n**_Figure 1: Vulnerable code snippet found within Checkbox code[2]_**\n\n2 Checkbox source code found on [GitHub](https://github.com/udalcse/Checkbox_CBE)\n\n4\n\n\n-----\n\nThe same exact VSTATE implementation was published in a blog post in 2005 as a solution for a compressed\nimplementation of VIEWSTATE. Some web applications have copied this piece of code into their own repository,\nexposing the application to the vulnerability. This topic of VSTATE deserialization exploits was covered in the past by\n[Graa – Security Blog. The vulnerable piece of code was found in version 6 of the “Checkbox Survey” software and is](https://www.graa.nl/articles/2010.html)\nshown in Figure 1.\n\nThe flow of the VSTATE deserialization exploit used by the threat actor was executed in a single HTTP POST to the\nCheckbox application server, and is illustrated in Figure 2 below:\n\n1. The threat actor crafts and sends an HTTP POST request containing two main components – A crafted VSTATE\nvariable containing a reflective loader DLL and a VSTATEGENERATOR variable containing the _NodeIISWeb_\nmalware.\n\n2. The exploited deserialization process executes the reflective loader DLL contained in the VSTATE variable.\n\n3. The reflective loader DLL reads, decodes, and decrypts the data passed in the “__VSTATEGENERATOR”\nparameter.\n\n4. Finally, the decrypted data (the NodeIISWeb malware) is reflectively loaded and acts as a backdoor on the\ncompromised asset.\n\n**_Figure 2: Threat actor VSTATE/VIEWSTATE exploit flow._**\n\n### VIEWSTATE Deserialization Exploit\n\nThe threat actor also leveraged and exploited the standard VIEWSTATE deserialization process to regain access to\ncompromised machines. Newer versions of .NET enforce encryption and validation of the VIEWSTATE data and offers\nprotection against this kind of exploit. However, if the encryption and validation keys are stolen or leaked, they can\nbe used to bypass the integrity check mechanism and eventually execute malicious code on the IIS server.\n\n5\n\n\n-----\n\nDuring one of Sygnia’s investigations, TG1021 leveraged stolen decryption and validation keys to exploit IIS web\nservers. The flow of the VIEWSTATE deserialization exploit is almost identical to the VSTATE exploit explained above,\nwith the adjustment of encrypting and signing the VIEWSTATE data instead of compressing it.\n\nThis exploit was used several times by the threat actor to regain access to compromised machines, since they rely\non a volatile backdoor and tools. Additionally, it was used in order to move laterally between machines in a cluster.\nThis is possible because if a web application is set to run in a cluster, all the instances need to share same secret keys\notherwise the VIEWSTATE feature would not work.\n\n### Altserialization Insecure Deserialization\n\nThe threat actor leveraged a second vulnerability involving insecure deserialization to exploit IIS servers. This section\ndescribes that process.\n\nASP.NET allows web applications to store user sessions to be used later once the user returns and interacts with the\napplication. This works by saving a serialized .NET session object to a MSSQL database and assigning it a unique\ncookie which is given to the user when browsing the application. Once the user browses again with the cookie the\nsession state is loaded and deserialized. A crafted serialized object which is written to the database could lead to\nremote code execution on a web application server once the implanted cookie is passed in an HTTP request.\n\nThis technique was used by TG1021 in order to move laterally between IIS servers within an environment. An initial IIS\nserver was compromised using one of the deserialization vulnerabilities listed above. From there the threat actor was\nable to conduct reconnaissance activities on a targeted ASP.NET session state MSSQL server and execute the exploit,\nas illustrated below and in Figure 3:\n\n1. After gathering information on the environment, a malicious serialized object was written to the database.\n\n2. The threat actor sent an HTTP GET request using the crafted ASP.NET session state cookie.\n\n3. The target IIS web server loaded and deserialized the matching session state object correlating to the planted\ncookie.\n\n4. The deserialization process is exploited by the crafted object in order to compile an in-memory web shell.\n\n5. Immediately after the web shell was created the threat actor accessed it to reflectively load the malicious\n_NodeIISWeb malware on the compromised asset._\n\n6\n\n\n-----\n\n**_Figure 3: Altserialization exploit attack flow_**\n\n### Telerik-UI Exploit (CVE-2019-18935, CVE-2017-11317)\n\nTelerik is known for several products providing functionality to web application development. One of the products,\nTelerik UI for ASP.NET AJAX, is a widely used suite of UI components for web applications. This product was found to\nbe vulnerable due to weak encryption, enabling a malicious actor to upload a file and/or to run malicious code.\n\nThe vulnerabilities were used by TG1021 to upload a web shell loader to IIS servers accessible from the internet. The\nweb shell was later used to upload additional modules and was deleted after a short period of time. Subsequent to\nthe initial use, the web shell was uploaded at the beginning of every following wave of threat actor activity.\n\n# Toolset Infrastructure & IIS Platform Malware\n\nTG1021 uses a custom-made malware framework, built around a common core, tailor-made for IIS servers. The toolset\nis completely volatile, reflectively loaded into an affected machine’s memory and leaves little-to-no trace on\ninfected targets.\n\n7\n\n\n-----\n\nThe framework consists of a two-stage toolset:\n\n1. The first consists of lightweight dynamic loaders in the form of DLLs and web shells, and the core component (The\n_NodeIISWeb malware). These are the first stage tools used on compromised IIS webservers._\n\n2. The second stage tools are more generic Windows-based tools which consist of a stealthy backdoor and a set of\npost-exploitation modules loaded on demand to extend functionality.\n\n**_Figure 4: Toolset Infrastructure Overview_**\n\n### NodeIISWeb Malware\n\n**Overview**\n\nThe _NodeIISWeb malware is a .NET DLL reflectively loaded module that is injected into the w3wp.exe process of_\naffected machines. It serves as the core component of the threat actor’s malware framework and acts as the main\nbackdoor on a compromised IIS server. It can operate in two different modes:\n\n1. IIS Hooking Mode\n\nThe malware hooks native IIS input validation functions in the injected w3wp.exe process, which provides access\nto all incoming HTTP traffic. The requests are analyzed by the backdoor, allowing the operators to communicate\nwith it by sending crafted HTTP requests to any web page in the process context.\n\n8\n\n\n-----\n\n2. Web Shell Controller Mode\n\nThe malware is executed and controlled using a custom web shell Loader. By sending specially crafted HTTP\nrequests to the web shell, the operators trigger the execution of the command input function of an instance\nloaded to a w3wp.exe process. In this mode the _NodeIISWeb will execute without hooking the IIS validation_\nfunctions and can be controlled only through the specific web page where the web shell is located.\n\nThe NodeIISWeb malware provides the threat actor with four different capabilities:\n\n1. Run a set of basic functions - Such as gathering system information or accessing and manipulating the file system\non the machine.\n\n2. Execute JScript payloads on the machine.\n\n3. Dynamically load additional modules.\n\n4. Perform several network related operations, including HTTP and SQL traffic forwarding and an implementation of\na TCP client instance. These capabilities enable active command and control of other backdoors deployed within\nthe network as well as control of the extension modules over the machine loopback interface.\n\nTo make analysis of the module more difficult, NodeIISWeb is protected by a public tool “CofuserCore” which packs\nand obfuscates the binary.\n\nThe _NodeIISWeb malware bares similarity to the “js_eval” malware family described in the “Copy-Paste_\nCompromises” ACSC advisory. This will be further discussed in the section “Similarities to the Copy-Paste threat actor”.\n\n### Hooking Mechanism\n\nTo establish a command-and-control channel, the malware deploys an inline hook on a validation function within\nthe IIS request handling process. During this process, the malware will first attempt to obtain a pointer to the method\n“ValidateInputIfRequiredByConfig”, which is a default function used by ASP.NET HTTPRequest class to validate any\ninput within the request, if input validation is enabled in the web page configuration. If a pointer to the method is not\nfound, the malware will attempt to obtain a pointer to another default method called “ValidateInput”.\n\nThe final stage of the process is then initiated when a hook is performed using the malware’s built-in functionality\nnamed “ManagedHook”. The hook swaps between the obtained method pointer and a malicious method created\nby the threat actor named “_ValidateInput”. After the malicious method is executed, the “ManagedHook“ instance\ncalls the original hooked function.\n\nThe hooking process is initiated by invoking one of the malware’s methods called “InitHook”. The method is invoked\nwith an additional string argument (will be referred to as “HOOK_KEY”). The “HOOK_KEY” string is crucial to the\nmalware’s operation, as it is used to search for threat actor payloads within incoming HTTP traffic. A reconstructed\nversion of the “InitHook” method code is shown in the following snippet:\n\n**_Figure 5: IIS validation function hooking performed by the “InitHook” method, reconstructed by Sygnia_**\n\n9\n\n\n-----\n\n### Payload Search\n\nThe malicious function “_ValidateInput” is used to process incoming requests, searching for payloads in several\nlocations within the request. The following list describes the search order for payloads:\n\n1. A file larger than 8 bytes which is attached to the request and has a name that matches the “HOOK_KEY”.\n\n2. An HTTP POST request containing a parameter with a key name that matches the “HOOK_KEY” and value length\nis greater than 8 bytes.\n\n3. An HTTP cookie with a name that matches the “HOOK_KEY” and that its value’s length is over 10 bytes.\n\n4. If no payload was found in the previous steps, the NodeIISWeb will try to treat the whole request content as the\npayload.\n\nAfter identifying an incoming payload, the malware attempts to extract two variables from it – A “Command”\nvariable and a “Forward” variable. The parameters are extracted in the following procedure:\n\n1. Key and IV Generation – A decryption key is generated by calculating the SHA256 value of the payload’s first 3\nbytes concatenated to the “HOOK_KEY” string value. The malware then calculates the MD5 value of the key, the\n16 bytes MD5 output is used as the IV for the decryption process.\n\n2. Decryption – The payload (starting from the 3[rd] byte) is decrypted with a standard AES algorithm using the\ngenerated key and IV from the previous step.\n\n3. Decompression – After decryption, the payload is decompressed recursively using GZip.\n\nOnce the “Command” and “Forward” variables are extracted, they are used by the malware to launch the\nrequested built-in functionality. The first byte of the “Command” parameter (“Command ID”) is used to determine\nwhich built-in function will be executed by the malware. In most cases, the “Forward” data will contain the arguments\nfor the requested function, but in some cases, the selected functionality will not require both variables and only the\n“Command” variable is resolved. The built-in functionalities of the NodeIISWeb malware can be seen in the following\ntable:\n\n**Command ID** **Description**\n\n0x00 Information gathering - Query domain membership, operation system information, process and\nowner information of the current process, time zone, network interfaces information and status\nand drives information.\n\n0x01 Recursive directory listing.\n\n0x02 File reading.\n\n0x03 File writing.\n\n0x04 Copying or moving files, or recursively copying directories.\n\n0x05 files and recursive directories deletion.\n\n0x06 Directory creation.\n\n0x07 Custom reflective loading.\n\n0x08 Traffic forwarding, either HTTP, SQL or TCP. used to communicate to additional backdoors\ninstalled within the network, as well as to memory loaded payloads via loopback\ncommunication.\n\n0x09 Dynamic execution of JScript payloads.\n\n**C2 communication flow with the backdoor with full built-in capabilities**\n\n10\n\n\n-----\n\n### Module Reflective Loading\n\nOne of the malware’s most interesting built-in function capabilities is reflective loading of custom DLLs. In order to\nreflectively load a payload, the following 3-step procedure is performed using the “Command” and “Forward”\nvariables as arguments:\n\n1. A random port is selected by the malware for future communications with the loaded module. The port’s\navailability is checked by opening and closing a TCP socket over the loopback. After that, a target IP address is\nextracted from the “Command” variable in the format of a 32 bit integer. The port and IP are concatenated to\nform a struct which is later passed as an argument to the loaded module.\n\n**_Figure 6: Random port generation before reflective DLL loading_**\n\nA shellcode is extracted from the “Command” variable and loaded to memory. This shellcode reflectively loads\na DLL passed in the “Forward” variable and returns a pointer to an initial method. If a shellcode and DLL were\npreviously loaded, the NodeIISWeb will use the previously exported method unless given a flag which forces a\nreload and execution of the shellcode and DLL.\n\na. The custom shellcode that performs the necessary operations to enable execution of the loaded DLL, for\nexample relocations within the binary.\n\nb. The shellcode returns a pointer to a specific exported function of the DLL by comparing the name of the\nexported function to a hash value embedded within the shellcode. That way the threat actor controls which\nfunction is returned by generating a custom shellcode for any needed function.\n\nc. If no DLL was provided in the “Forward” variable – the shellcode is simply executed with a null-pointer as\nargument, allowing execution of generic shellcodes.\n\n**_Figure 7: Reconstructed InitLoader method - Execution of shellcode to reflectively load payload DLL_**\n\n2. Finally, the exported method is invoked using the structure created in step 1 as an argument.\n\n11\n\n\n-----\n\n**Figure 8: Reflective loading of payload DLL and invocation of the selected function**\n\nA sample shellcode was acquired alongside the malicious DLL that was loaded using that shellcode. The shellcode\nwhich was found is a Position Independent Code (PIC) used to reflectively load “ExtDLL.dll” to memory by\nallocating, writing and relocating any needed addresses to the appropriate allocated address. The exported\nmethod returned by the shellcode is a method named “Hello” – which is the method used to execute the main\nflow of “ExtDLL.dll”.\n\n### JScript Payload Execution\n\nThe malware implements code execution by invoking in-memory Jscript code sent to the NodeIISWeb malware.\nThis is done by loading the “Microsoft.Jscript.Eval” assembly to the current process and invoking the\n“JscriptEvaluate” function with the given payload. The malware uses a custom hardcoded template script-block\nfor the Jscript code execution:\n\n**_Figure 9: NodeIISWeb hard coded Jscript evaluation code_**\n\n**_Figure 10: Invocation of Jscript evaluation code_**\n\nThis method of implementation achieves a stealthy remote code execution method by avoiding spawning new\nprocess on the machine.\n\n### Traffic Forwarding\n\nThe NodeIISWeb malware enables three types of traffic forwarding:\n\n1. TCP Tunneling – used as a C2 channel to other in-memory modules or additional NodeIISWeb instances in an\n\n12\n\n\n-----\n\ninfected network.\n\n2. HTTP forwarding\n\n3. SQL forwarding\n\nBoth HTTP and SQL traffic forwarding commands are implemented with an additional XML formatted string\ncontaining configuration instructions for crafting the relevant traffic. The different XML attributes allow for creation\nof different HTTP and SQL requests. By default, the HTTP method is set to GET, unless additional data is passed to the\nfunction through the matching “Data” variable. The following table summarizes each attribute role in an XML\ndescribing an HTTP request:\n\n**XML Attribute** **Description**\n\nU Target URL\n\nIM Windows user impersonation\n\nTO Request timeout\n\nAT Network credentials are to be used\n\nAD Domain name (only applicable if “AT” is defined)\n\nAU Username (only applicable if “AT” is defined)\n\nAP User password (only applicable if “AT” is defined)\n\nPX Web proxy is to be used and defined in “AD” attribute\n\nPD Web proxy domain name (only applicable if “PX” and “PU” are defined)\n\nPU Web proxy username (only applicable if “PX” is defined)\n\nPP Web proxy password (only applicable if “PX” and “PU” are defined)\n\nMT HTTP method\n\nCT Content type\n\nH Headers to be added to the request\n\nK Header name contained under “H” attributes (only applicable if “H” defined)\n\nA similar XML would be provided to craft an SQL query with the following attributes:\n\n**XML Attribute** **Description**\n\nS SQL connection string\n\nT Windows user impersonation\n\nQ SQL query\n\nO SQL command timeout\n\nThe functionality of traffic forwarding in the main NodeIISWeb malware is a direct implementation of the\n“Forward.dll” module with additions for the SQL traffic. This mechanism of traffic forwarding has some default values\nwhich are used in the requests generated. These characteristics, such as a default user-agent, can be used to\ndetect malicious traffic.\n\n13\n\n\n-----\n\n### NodeIISWeb Reflective Loaders\n\nAs a volatile tool, the NodeIISWeb malware is used by the threat actor solely in-memory. To do so, the tool is loaded\ndynamically into the process memory using one of the following ways:\n\n1. When the threat actor had RCE capabilities on a target IIS server, a DLL acting as a dynamic loader was used\nas an initial payload for the exploit. This DLL in turn dynamically loads the NodeIISWeb malware calling the\n“InitHook” method.\n\n2. When the threat actor only had the ability to upload files to a target IIS server, an NodeIISWeb web shell loader\nand controller was deployed. The initial access to this web shell created an NodeIISWeb instance on the\nmachine (without hooking the IIS validation methods), and further access would be made to control the\nmalware.\n\nBoth loaders are similar to one another in their functionality and basic safety measures, however there is a\nsignificant difference in the operational mode and control over the malware.\n\n### Reflective Loader DLL\n\nA lightweight .NET reflective loader designed to load malicious .NET DLLs to the IIS process memory and execute a\nselected function within it. This DLL was used in the VIEWSTATE/VSTATE deserialization exploit workflow to execute the\nthreat actors’ main implant – the _NodeIISWeb malware. In the instances observed, the threat actor invoked the_\n“InitHook” method to initialize an NodeIISWeb malware instance and hook HTTP validation functions on the servers.\nBy doing so, the threat actor established the first foothold on the target server.\n\nThe DLL does not persist on the victim machine, which means it is uploaded as a payload in every exploit. Once the\nDLL is loaded it checks if the request that it was sent with is above 4096 bytes in size. If so, it searches for the\n“__VSTATEGENERATOR\" parameter and attempts to decode and decrypt it using a basic XOR operation.\n\nThe decoded payload consists of three main sections:\n\n1. The first 2 bytes are used in the decryption process as XOR keys.\n\n2. Bytes 2-32 are a string containing the .NET class name, function name within that class and argument supplied to\nthe function, all separated by pipe characters (\"|\").\n\n3. The rest of the payload is a .NET DLL, containing the said .NET class.\n\nThe returned response contains the header \"Pragma\" with the value \"no-cache\", signaling a successful execution.\n\n14\n\n\n-----\n\n**Figure 11: A snippet of code from ReflectiveLoadForms.dll**\n\n### Loader Web Shell\n\nOn some occasions, TG1021 deployed a web shell on IIS servers for a short period of time. In most cases, these web\nshells were deleted shortly after they were dropped. The web shell functionality is almost identical to the Reflective\nLoader DLL, as it used to load binaries and initialize a malware instance from within it, using an almost identical\ndecryption and decoding mechanism:\n\n1. The first 2 bytes are used in the decryption process as XOR keys.\n\n2. Bytes 2-32 represent an array of strings later used for invocation, separated by “|”.\n\n3. All bytes starting from 32 are the malicious binary payload.\n\n15\n\n\n-----\n\n**_Figure 12: The NodeIISWeb Loader & Controller web shell_**\n\nThe first object in the string array “keys” is placed in the web application HTTP cache under the value\n“_CAPCACHE__CAPCACHE_”. When the NodeIISWeb malware instance is initialized without arguments, it looks for\nthe value stored in this key to be used as the “HOOK_KEY”.\n\n**_Figure 13: The IISNode class constructor_**\n\nAfter initialization, a pointer to the malware instance is saved in the web application HTTP cache under the key\n“_CAPCACHE_”. When the attacker revisits the specific webpage, the object’s “ToString” method is invoked which\nin turn initiates the C2 logic of the malware. Without knowing what object is stored in the cache under the key\n“_CAPCACHE_”, it might seem as a legitimate comparison between two string objects, when really the “ToString”\n\n16\n\n\n-----\n\nmethod triggers the malware commands.\n\nIn a few cases the threat actor placed the controller in specific locations leveraging default IIS webpage naming.\nThe threat actor would locate a directory in the web application that did not contain a default webpage file and\nplace the controller in that directory using one of the default document namings. When the threat actor would\nrequest the directory via HTTP without requesting a specific resource, the IIS server would serve the first resource\nmatching one of the default values.\n\n**_Figure 14: Default IIS configuration for “defaultDocument” files_**\n\n### Second Stage Malware - ExtDLL.dll\n\nThe threat actor uses a generic Windows-based malware for operating on compromised Windows machines as a\nsecond stage for the _NodeIISWeb malware. The backdoor uses a passive C2 channel, listening for incoming TCP_\nconnections, minimizing network traffic when it is not in use. The tool provides backdoor functionality, allowing the\nthreat actor to perform various actions on the affected host, for example:\n\n- File and directory manipulation (read, write, delete, copy, move)\n\n- System information gathering\n\n- Dynamic DLL loading and execution\n\n- Code injection, token manipulation and additional common attack technique functionalities\n\nThe malware also holds defense tampering capabilities to hide its activities by applying inline hooks on specific\nsecurity related functions on all the process’ threads:\n\n1. AV scanning functions – The malware hooks the functions “AmsiScanBuffer” and “AmsiScanString” from the\n“Amsi.dll” library with a simple function which returns AMSI_RESULT_CLEAN.\n\n2. Event log reporting functions – The malware hooks the functions “ReportEventW” and “EventWriteTransfer” from\nthe “Advapi32.dll” library with a simple function which returns 1 (any non-zero value is considered as conformation\nthat the event was written). By doing so the malware disables the capability of event logging from the affected\nprocess.\n\n3. .NET code trust checks – The malware hooks the functions “WldpQueryDynamicCodeTrust” and\n“WldpIsClassInApprovedList” functions from the “Wldp.dll” library. The purpose of those hooks is to bypass Device\nGuard policy and execute malicious .NET code in memory. The hook leads to yet another simple function returning\nS_OK value.\n\n4. PowerShell related registry keys actions – The malware hooks the function “RegOpenKeyExW” from “Advapi32.dll”.\nAny subkey under or including “Software\\policies\\microsoft\\Windows\\Powershell” will return an\nERROR_FILE_NOT_FOUND error.\n\n17\n\n\n-----\n\n**_Figure 15: Hooking of Anti-Virus and .NET Device Guard functions_**\n\nAlthough it seems that the malware performs the hooking only on the current injected process, it holds the capability\nto perform this behavior on other user-land processes.\n\n### Additional Modules\n\nThe threat actor leveraged the NodeIISWeb and ExtDLL.dll malware to execute other modules, containing additional\ncapabilities. These modules are .NET modules, which were obfuscated using Confuser.Core 1.4.1 (build 5d92e25e43).\n\n### PSRunner.dll\n\n“PSRunner.dll” provides the threat actor with the ability to run PowerShell script-blocks on a host without spawning a\nPowerShell process and manage incoming PowerShell payloads. Some of the functionality of the module resembles\nthe functionality of an open-source tool named “UnmanagedPowerShell”[3], which enables execution of PowerShell\nscript blocks from an unmanaged process. A snippet from PSRunner code is shown below.\n\n**_Figure 16: A snippet of code from PSRunner.dll_**\n\n### Forward.dll\n\n“Forward.dll” enables the threat actor to forward HTTP traffic to a remote host based on a given set of parameters.\nThe DLL’s functionality is also implemented in the _NodeIISWeb malware and replicates its traffic forwarding_\ncapabilities. The traffic forwarding is done by processing an XML formatted string containing instructions, and by\nassembling a request with the given parameters – see Traffic Forwarding for the full list of parameter options.\n\n3 https://github.com/leechristensen/UnmanagedPowerShell\n\n18\n\n\n-----\n\n**_Figure 17: A snippet of code from Forward.dll_**\n\n### PotatoEx.dll\n\n“PotatoEx.dll” is a custom version of the Potato family tools, which is a common local privilege Escalation (PE) tool.\nConsistent with the other tools in the threat actor’s arsenal, this is a .NET version of the Potato family, which also has\n[implementations of additional open-source tools such as “PingCastle” – also seen in “BadPotato”.](https://github.com/BeichenDream/BadPotato)\n\n### E.dll\n\n“E.dll” is a lightweight .NET payload used by the threat actor to verify whether an exploit had successfully executed\non a target IIS server. A successful exploit with “E.dll” as a payload would result in a HTTP response containing custom\nfabricated headers, cookies, and content.\n\nThe name “E.dll” has a direct connection the [“YSoSerial.Net” open-source tool used to generate payloads that](https://github.com/pwntester/ysoserial.net)\nexploit insecure .NET object deserialization. During preparation of payloads using “YSoSerial.Net”, the deserialization\ngadget searches for “e.dll” as the payload for the operation.\n\n# Post-exploitation Activities\n\nThe threat actor utilized the access provided using the IIS to conduct additional activity, including credential\nharvesting, reconnaissance, and lateral movement.\n\n### Credential harvesting\n\nThe threat actor modified login webpages to record credentials and save them to a file in clear text format. The\nmodification is a short-embedded code-block at the beginning of the webpage file with a simple try-catch phrase\ncode:\n\n19\n\n\n-----\n\n**_Figure 18: Credential tap code block modification_**\n\nThe short piece of code checks the “UserName” and “Password” attributes in a post-back form and if both are not\nempty, they are stored in clear text to the designated output path. Once users would login to the website, credentials\nwould be stored there and the threat actor could easily access the file by browsing the relevant path. The name of\nthe output file chosen by TG1021 would resemble a native file in an existing directory with a different extension in\norder to blend in with legitimate requests to the server.\n\n### Reconnaissance\n\nAs in many other cases, the threat actor used publicly available offensive security tools (OST) in order to perform\nreconnaissance. For example, “SharpHound” was used to scan and map targets by loading it directly to infected\nmachines memory without writing the binary on the disk. Quickly after the execution, the threat actor retrieved the\noutput files and deleted them. In addition, “PowerSploit” was loaded and executed using the same technique.\n\n### Lateral Movement \n\nAfter establishing foothold on an external IIS server, the threat actor access shared folders on internal web servers\nover SMB using compromised domain credentials. On several occasions the threat actor dropped the NodeIISWeb\nweb shell loader via SMB to compromise additional servers.\n\nAdditionally, the threat actor utilized the exploits mentioned above to move laterally between IIS servers.\n\n# Similarities to the Copy-Paste threat actor\n\nThe Tactics, Techniques and Procedures (TTPs) used by TG1021, bare various similarities to those of “Copy-Paste\nCompromises” actor described by the Australian Cyber Security Centre (ACSC). The advisory, published in June 2020,\ndetails the TTPs of a sophisticated state-sponsored actor targeting Australian public and private sector organizations.\n\nMuch like TG1021, the threat actor described in the advisory utilizes a variety of deserialization exploits and specifically\nthe Telerik UI vulnerabilities and VIEWSTATE handling in Microsoft IIS servers. There are major overlaps in the toolsets\nused by both actors, such as the usage of JScript payloads, Potato family malware and “Confuser” for obfuscation.\nThe “PowerHunter” malware described in the advisory provides extremely unique functionality, high similar to\n“ExtDLL.dll” described in this report.\n\nIt is important to note the activity described in the advisory is wider and consists of additional tactics, techniques and\nprocedures that were not observed in the activities analyzed by Sygnia.\n\n# Defending Against TG1021 Attacks\n\nAs a volatile threat actor, defending against TG1021 attacks is a tough task. We recommend the following:\n\n1. Patching .NET deserialization vulnerabilities\n\n2. Searching for known indicators of compromise\n\n3. Scanning internet facing IIS servers with a set of Yara rules designed to detect the tools discussed in this paper\n\n20\n\n\n-----\n\n4. Actively hunt for suspicious activity on internet-facing IIS environments\n\n### Sealing .NET Deserialization Exploits & Best Practices\n\n1. Telerik Version Update –\n\nIf you are running a .NET web application that uses Telerik UI for ASP.NET AJAX, make sure to use the newest version\nthat is not vulnerable to known CVEs.\n\n2. Enforce VIEWSTATE MAC validation and Rotate Machine Keys Routinely –\n\nVIEWSTATE deserialization attacks can easily lead to a network compromise due to a small misconfiguration.\nVersion 4.5 of .NET enforces the relevant security measures of validating VIEWSTATE messages before attempting\ndeserialization. Make sure the following configurations are in place:\n\n  - Ensure the “enableViewStateMac” variable in the IIS configuration is set to True.\n\n  - Ensure the “aspnet:AllowInsecureDeserialization” variable in the IIS configuration is set to False.\n\n  - Ensure the registry key “AspNetEnforceViewStateMac” under the path\n“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\.NETFramework\\<Version>” is set to 1.\n\nIn addition to these security measures, encryption and validation keys should be handled with care as sensitive\ncredentials. If possible, use auto-generated keys, otherwise routinely rotate the machine keys on your IIS servers\nto make sure you would not be susceptible to attacks where keys were stolen or leaked.\n\n3. Validate any usage of VSTATE in .NET applications –\n\nIf any of the .NET web applications running in your environment use the compressed version of VIEWSTATE (whether\nhomebrew or a third-party application), validate the implementation is done securely. Search for the following piece\nof code in your applications, and make sure they are replaced:\n\n**_Figure 19: Insecure implementation of compressed VIEWSTATE_**\n\n4. Secure ASP.NET session DB –\n\nIf ASP.NET session state is used by your web applications make sure access to the database can only be done\nfrom legitimate network locations. Separate session state MSSQL databases between different IIS servers / web\napplications as much as possible or create different SQL users with proper minimal CRUD permissions.\n\n5. Block any unnecessary communications from IIS servers –\n\nYour IIS servers should only generate traffic matching the set of known rules, limit and block these activities to the\nminimum possible.\n\n6. Configure a suitable application pool identity to run the web application –\n\nMake sure your .NET web applications are running with a designated application pool identity with the lowest\nprivileges possible. This would create an additional obstacle for TG1021.\n\n21\n\n\n-----\n\n### Indicators of Compromise\n Files\n\n- Default.aspx (Loader web shell)\n\n`o` f69d32157189945fa2bf47a690a8bd62\n\n`o` 4f10e10050d3da0b369f6636ede18a418ecab3a0\n\n`o` ea463bf8e502d0ff68736afa3dcbb59c969a6dc5776c0d7d10bb282ec3b62282\n\n- NodeIISWeb.dll\n\n`o` de19ea6e9cdf2ac5d22a00d24898532d\n\n`o` 0786eb857c20dedb578e181cafba81ef0a097205\n\n`o` 562cfbab3c6c4daf3a7f81412c77d5b70402c48aed3f49066cb758742b068afd\n\n- PSRunner.dll (Memory Resident)\n\n`o` c8d12b90e9efd04a2c523efaef3d01d4\n\n`o` abd78cf430d91d07387e7305be6523249af38caa\n\n`o` 88cb332eb82f3c086eaa33607a173cf6410bff0b9a21d6692225ffb9bbe877c6\n\n- PotatoEx.dll (Memory Resident)\n\n`o` 92fd2e7d4dfced8c635fbcb54bb651b9\n\n`o` be6648ada0074cb76b5da7854c37cb784c52f989\n\n`o` 4a41a1b8adf426959ece8ebed0fccdcd5db1124eb0686c2f590b3b93392429e6\n\n- ExtDLL.dll (Memory Resident)\n\n`o` 6322a2a4b5dd34ecff3af22c4fac94cf\n\n`o` 5679ada30e9cdbdfe62a05448d76e7034489945a\n\n`o` 40b1bc34ecaddc7f08ca6399cb2a07520a7203394aa3accb1bb7d94aa21b35d6\n\n- WebTunnel.dll (Memory Resident)\n\n`o` 3a0f85d811916f66371b9a994472667c\n\n`o` ba251c5f2884e2535a2178509b9065a9be969965\n\n`o` 0d6dec29075584af62801306913430c1733882955eedcd9e9a4916b2dae4d457\n\n- AssemblyManager.dll (Memory Resident)\n\n`o` 0bd1d822710ca4cd8612cfcd78a12155\n\n`o` 94df55b21bbd7bb82ab269d7840a3188003e5d35\n\n`o` e1f3763092aa779fd291afe9aa18866658966332b13caa57d34d294120e1f608\n\n- ReflectiveLoadForms.dll\n\n`o` 9d705f6333fc8cb3e75dde04e7a71ca4\n\n`o` cb84313a708723268a0608929887ad16fcf83a26\n\n`o` 01e33b20366589b19f66ffdd560538e83fe1a63cab7f29e0a6754bcbb49ec7bb\n\n\n22\n\n\n-----\n\n### Additional IOCs\n\n- Malicious HTTP Identifiers:\n\n`o` User agent hard-coded in the tools –\n“Mozilla/5.0+(Windows+NT+10.0;+WOW64;+Trident/7.0;+rv:11.0)+like+Gecko”\n\n`o` HTTP parameter and cookie – “AESKey”\n\n`o` HTTP parameter – “__VSTATEGENERATOR”\n\n\n23\n\n\n-----\n\n# MITRE ATT&CK Breakdown\n\n**1.** Reconnaissance\n\nT1595.002 - Active Scanning: Vulnerability Scanning\n\nT1592 – Gather Victim Host Information\n\nT1590 – Gather Victim Network Information\n\n**2.** Resource Development\n\nT1587.001 - Develop Capabilities: Malware\n\nT1587.004 - Develop Capabilities: Exploits\n\n**3.** Initial Access\n\nT1190 - Exploit Public-Facing Application\n\n**4.** Execution\n\nT1059.001 - Command and Scripting Interpreter: PowerShell\n\nT1059.007 - Command and Scripting Interpreter: JavaScript/JScript\n\n**5.** Persistence\n\nT1505.003 – Web Shell\n\n**6.** Privilege Escalation\n\nT1055.001 - Process Injection: Dynamic-link Library Injection\n\nT1055.001 - Process Injection: Dynamic-link Library Injection\n\nT1068 – Exploitation for Privilege Escalation\n\n**7.** Defense Evasion\n\nT1036.005 - Masquerading: Match Legitimate Name or Location\n\nT1036.005 - Masquerading: Match Legitimate Name or Location\n\nT1140 - Deobfuscate/Decode Files or Information\n\nT1070.004 - Indicator Removal on Host: File Deletion\n\nT1134.001 - Access Token Manipulation: Token Impersonation/Theft\n\nT1562.002 - Impair Defenses: Disable Windows Event Logging\n\nT1078.002 – Domain Accounts\n\nT1027.002 – Software Packing\n\n**8.** Credential Access\n\nT1056.003 - Input Capture: Web Portal Capture\n\n**9.** Discovery\n\nT1135 - Network Share Discovery\n\nT1083 - File and Directory Discovery\n\n\n24\n\n\n-----\n\n**10.** Lateral Movement\n\nT1550.004 - Use Alternate Authentication Material: Web Session Cookie\n\nT1021.002 - Remote Services: SMB/Windows Admin Shares\n\nT1210 - Exploitation of Remote Services\n\nT1570 - Lateral Tool Transfer\n\n**11.** Collection\n\nT1005 - Data from Local System\n\n**12.** Command and Control\n\nT1071.001 - Application Layer Protocol: Web Protocols\n\nT1001 – Data Obfuscation\n\nT1090.001 – Internal Proxy\n\nT1132.001 - Data Encoding: Standard Encoding\n\nT1573.001 - Encrypted Channel: Symmetric Cryptography\n\nT1572 - Protocol Tunneling\n\n**About** **Sygnia**\n\nSygnia is a cyber technology and services company, providing high-end consulting and incident\nresponse support for organizations worldwide. Sygnia works with companies to proactively build their\ncyber resilience and to respond and defeat attacks within their networks. It is the trusted advisor and\ncyber security service provider of IT and security teams, senior managements and boards of leading\norganizations worldwide, including Fortune 100 companies.\n\n\n94a Yigal Alon St.,\nFor more information:\n29th floor, Tel Aviv,\n**[www.sygnia.co](http://www.sygnia.co/)** Israel, 6789155\n\n\n488 Madison Ave.,\n11th floor, New York,\nNY, USA, 10022\n\n\n52 Tras St., 2nd\nfloor, Singapore,\n078991\n\n\n25\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.08.02.TG1021_Praying_Mantis/TG1021%20-%20Praying%20Mantis%20Threat%20Actor.pdf",
        "https://f.hubspotusercontent30.net/hubfs/8776530/TG1021%20-%20Praying%20Mantis%20Threat%20Actor.pdf"
    ],
    "report_names": [
        "TG1021 - Praying Mantis Threat Actor",
        "TG1021%20-%20Praying%20Mantis%20Threat%20Actor.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1a76ed30-4daf-4817-98ae-87c667364464",
            "created_at": "2022-10-25T16:47:55.891029Z",
            "updated_at": "2025-03-27T02:05:17.408867Z",
            "deleted_at": null,
            "main_name": "IRON LIBERTY",
            "aliases": [
                "ATK6 ",
                "BROMINE ",
                "CASTLE ",
                "Crouching Yeti ",
                "DYMALLOY ",
                "Dragonfly ",
                "Energetic Bear / Berserk Bear ",
                "Ghost Blizzard ",
                "TEMP.Isotope ",
                "TG-4192 ",
                "ALLANITE "
            ],
            "source_name": "Secureworks:IRON LIBERTY",
            "tools": [
                " Ddex Loader",
                " Havex",
                " Karagany",
                " Loek",
                " MCMD",
                " Sysmain",
                " xfrost",
                "ClientX"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1627338098,
    "ts_modification_date": 1627338104,
    "files": {
        "pdf": "https://archive.orkl.eu/73ab28174d255e1168f7f37a1059e7724c030081.pdf",
        "text": "https://archive.orkl.eu/73ab28174d255e1168f7f37a1059e7724c030081.txt",
        "img": "https://archive.orkl.eu/73ab28174d255e1168f7f37a1059e7724c030081.jpg"
    }
}