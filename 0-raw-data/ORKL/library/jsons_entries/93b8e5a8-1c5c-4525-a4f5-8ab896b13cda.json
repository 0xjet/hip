{
    "id": "93b8e5a8-1c5c-4525-a4f5-8ab896b13cda",
    "created_at": "2023-01-12T15:04:49.286329Z",
    "updated_at": "2025-03-27T02:05:36.041911Z",
    "deleted_at": null,
    "sha1_hash": "66be7330225bbc2829342463b91df0e949647943",
    "title": "2016-05-05 - Sophisticated New Packer Identified in CryptXXX Ransomware Sample",
    "authors": "",
    "file_creation_date": "2022-05-28T05:08:05Z",
    "file_modification_date": "2022-05-28T05:08:05Z",
    "file_size": 156133,
    "plain_text": "# Sophisticated New Packer Identified in CryptXXX Ransomware Sample\n\n**[sentinelone.com/blog/sophisticated-new-packer-identified-in-cryptxxx-ransomware-sample/](https://www.sentinelone.com/blog/sophisticated-new-packer-identified-in-cryptxxx-ransomware-sample/)**\n\n## Summary of Execution\n\nThis sample is being delivered using the Angler Exploit Kit within a\n\ndrive-by download attack. The exploit is the latest Adobe Flash exploit.\n\nThe packing on the sample is very sophisticated; far more sophisticated than\n\nthe final payload. The packer looks to be written in C and utilizes many\n\n[techniques used by shellcode, but is repurposed to evade static analysis. The](https://www.sentinelone.com/blog/malicious-input-how-hackers-use-shellcode/)\n\npacker also has many unnecessary API calls whose purpose could only be to\n\nconfuse dynamic and behavioral detection. Multiple layers of packing are\n\nused to further conceal itself.\n\nThe ransomware payload is written in Delphi and only has a few dirty tricks\n\nto mask it’s malicious intent. In addition to the ransom, the payload\n\nhunts down bitcoin wallet files on the disk to steal their contents.\n\n\nMay 5, 2016\n\n\nWhy would an adversary spend more resources in the packing of ransomware instead\n\nof the ransomware itself? I maintain that they are trying to increase the time\n\nbetween the initial release of the malware and the time of detection by the\n\nantivirus software. This longer time period will net them more infections, and\n\nin turn, increase revenue on an individual campaign. It makes economical sense\n\nto spend more resources on gumming up the antivirus analysis and detection\n\nprocess, than building a better ransomware.\n\n\n-----\n\n**Packed Sample**\n\nFilename: api-ms-win-system-hid-l1-1-0.dll\nFile size: 252,416 bytes\nMD5: 8D044D1FC07526FA0B1ADADD1FBDAA28\nSHA-1: 41A70AD7D7D43C33C73485C827ADAEF30C86597A\nSHA-256: 175e01b113bbd7637adb88e4f1d3bc526dc429b221465a7a1fbd5bf1ed22662f\n\n**Unpacked Sample**\n\nFile size: 394,240 bytes\nMD5: BAF5EC28F7E25FB3C54153C509940712\nSHA-1: C47A6626CAB9BE3904AA70CF24910A26E46F16BF\nSHA-256:\nA386FE46D245BC3C53DD9154266557E19219DB0086DCBE1BC6FD7B9B0EC9B70B\n\n## Packer Layer 0 (Psychological)\n\nFrom an initial inspection, the sample looks like an innocuous DLL from Microsoft.\n\nThe file has a good sounding scary-to-delete-me name. The version strings\n\nin the resource section are formatted exactly to Microsoft style. Most malware\n\nI’ve seen that tries to masquerade as a Microsoft binary forgets certain features\n\nlike the copyright symbol.\n\nAll the DLL export symbol names are in the format lua_*. It looks like a\n\nlegitimate Lua library, but the disconnect begins here. When have you ever\n\nheard of a Microsoft product written in Lua?\n\nAll of these exports are just stub functions. Just standard procedure\n\nprolog and epilogs with no implementation in-between.\n\nThe sample is also hard to get started unless you have full context of how it is supposed to\nbe run.\n\nThe sample is initially run using rundll32.exe\n\n```\nC:WindowsSystem32rundll32.exe api-ms-win-system-hid-l1-1-0.dll,Working\n\n```\n\nWhen first loaded, a call to the dll entry point is made, then a call to Working(). The\n\npacked DLL does not have an export named Working(), but the unpacked payload\n\ndoes. Working() will check the the command line string to ensure that it\n\nwas launched with rundll32.exe. If it isn’t, It will create a new process\n\nusing rundll32.exe. Once Working() is sure that the process was created\n\n\n-----\n\nwith rundll32.exe, it will then start a new process using rundll32.exe, but\nthis time it will run the AccessToken() export. AccessToken() is the\nbeginning of the ransomware code.\n\nTo successfully launch the ransomeware, you must pass the “Working” or\n“AccessToken” parameter in the rundll32 command line. Without it, it will not\nrun. Why would the author be troubled to limit the infection?\nI postulate that the author did this on purpose. I can see the scenario playing\nout in my head: A forensics analyst has found this DLL, and determines that\nit is related to the compromise. He sends the sample\nto a malware analyst who tries running the DLL, but can’t get the\nransomeware to invoke.\nThe malware analyst will incorrectly respond to the forensic analyst,\nsaying that there must be more to the infection. This will slow down the\ninitial response process, allowing more infections. Before the malware analyst\ncan get the ransomeware to run, he will have to unpack the sample to get the\npayload, and see the two exports of the payload.\n\nThe packer is riddled with API calls that have no effect whatsoever. This\nmakes it a nightmare for manual dynamic analysis. It was hard to tell what\ncode is important, and what is just a red herring. An analyst who sees\na call to GetLogicalDrives() might think, “I must be really close to the\nransomware code!” but only to be disappointed to find that the ransomware isn’t\neven unpacked. Here is a call to MoveFile(), that might look like it’s using\nobfuscated strings statically, but dynamically, you can see the function\nreturn 0 indicating failure.\n\nThere are imports to winmm.dll (multi-media) that are never used. This might\nbe an attempt\nto make the DLL look more legitimate (since the filename has HID in the name\nand most MIDI devices also have a HID component), but I believe the author’s\nreasoning to include all these unused imports is to hide one crucial\nimport: VirtualProtect().\n\nThis one call to VirtualProtect() opens the gate to the rest of the packer.\n\n## Packer Layer 1\n\nThe first software layer of protection used by the packer is an encrypted region\n\nof code. The code is decrypted in place, but because the “.text” section\n\nis marked as read-execute in the PE header, a call to VirtualProtect() must\n\nbe made to allow write access.\n\n\n-----\n\nOnce the region is decrypted, it is run. Unfortunately, OllyDBG has determined\nthis region to be data, not code. So in the debugger, Olly will not display\nthe disassembly. I eventually discovered that you can remove Olly’s analysis\nfor a section using ctrl+backspace:\n\nAt this point, I made a dump of the DLL to analyze the uncovered region.\n\n## Packer Layer 2\n\nThe windows loader was not able to patch the relocations for this encrypted\n\nregion, because it was still encrypted during the loading process. As a result,\n\nmany restrictions are on the author for this region of code.\n\nAll the code must be written similar to shellcode. It has to run wherever it\n\nis loaded in memory. This means no access to global variables, the import\n\ntable, or string literals.\n\nThe first thing that is done, is a large structure is allocated on the stack.\n\nThis structure contains the ‘global variables’ for this section of code. because\n\nIt doesn’t know where the “.data” segment is to access normal global variables.\n\nYou can see in my reverse engineered version of this structure, there\n\nare pointers to API calls. This is done because the encrypted portion\n\nof the packer was not linked during compile time. It also hides these\n\nentries from the import section.\n\nNow, the base address of the DLL is recovered using a technique similar to an\n\negghunter. a call $+5; pop eax is used to find the value of EIP, and\n\nmemory is search for ‘MZ’ at the start of a each 4k page. This value is stored\n\nfor later use.\n\nBecause this section of code isn’t linked into the main binary at compile time, its imports\n\nhave to manually be resolved. This is done with a technique commonly used in windows\n\nshellcode. A pointer to a linked list of loaded modules is stored inside the\n\nProcess Environment Block (PEB). By traversing this linked list, the required\n\nmodules containing the exported functions needed can be found. Once the modules\n\nare found, the individual exports can be found by following the PE structure.\n\nAlso, because this section of code can’t use any string literals, instead\n\nof using a string compare, all strings needed are hashed and the hashes are compared.\n\n[In the following image, the hash value of the string “kernel32.dll” is 0x6a4abc5b.](https://www.sentinelone.com/blog/what-is-hash-how-does-it-work/)\n\nThe most important symbols to resolve are LoadLibrary() and GetProcAddress().\n\nBoth are in kernel32. Using these two functions, all other symbols can be resolved.\n\nBut because of the limitation of no string literals, some strings have to be built\n\n\n-----\n\non the stack first.\n\nNow that all the prep-work for this stage is done, it must now unpack the payload\nand position it in memory.\n\nFirst the packed dll is read off of the disk and into memory. The region\ncontaining the compressed payload is found.\n\nThe payload dll is decompressed using “RtlDecompressBuffer()”. The PE header is\nparsed and the image is reconstructed in memory. This image must have its\nimports manually linked in and relocations patch. But the address range the\npayload image has been reconstruced in is not it’s final resting place. The\npacked dll is occupying that region.\n\nTo remove the packed image from memory to make room for the final position of\nthe unpacked payload DLL, a bit of code must be placed outside of these two regions.\nThis portion of the code is identified by a ‘MOV EAX, 0x11223344’ instruction.\nA VirtualAlloc() is performed, and the code is copied to the newly allocated region.\nExecution continues at this region.\n\nThis last bit of code will unmap the packed dll from memory using a call\nto UnmapViewOfFile(). Next, it reallocates this exact same region to copy\nthe unpacked payload image. The unpacked payload is freed from it’s temporary\nposition and execution continues at the entry point of the payload dll.\n\nFrom here, the ransomware runs.\n\n## Ransomware\n\nThe ransomware communicates to one of two hard coded command servers.\n\nThe IP addresses of the command servers are 146.185.250.152 and 217.23.6.40.\n\nThere are no domain names stored in the sample, only the IP addresses.\n\nWhois records for these ip ranges appear to be issued to Ukraine and Netherlands.\n\nDomain names that are associated with these ip addresses in the past are:\n\n146.185.250.152\n\nf0rget–a00lls.com\n\nweeell-drive.com\n\n647hnhjnnc-nje00l.com\n\nfeeeel–t00ll.com\n\ndaertnw90-kola.com\n\n217.23.6.40\n\np3.regularclass.com\n\n\n-----\n\nregularclass.com\nns2.streamingmp4.net\nns1.streamingmp4.net\nns2.streamingmp4.net\nns1.streamingmp4.net\nns2.streamingmp4.net\nns1.streamingmp4.net\ncdn78.livefile.org\nvenusbjerget.dk\nsemi2.wrzhost.com\nkidshot.ijustcantbelieve.com\ncallspoof.ijustcantbelieve.com\ncelebrityhotnews.net\njustinbieberoncam.ijustcantbelieve.com\n\nMany of these records appear to be old by at least a year, and are probably not used in the\nattack.\n\nOnce the local files are encrypted, the user is presented with a ransom notice:\n\n## Conclusion\n\nAs adversaries continue to invest resources on packing we should expect to see more\nexamples of how these tricks will still slow down the detection pipeline.\n\nSentinelOne detects this specific attack at the initial exploit phase, before the ransomeware\nis even unpacked.\n\nTo learn more about how SentinelOne can help you prevent these kinds of attacks, please\n[click here to download SentinelOne’s Technical Overview.](https://go.sentinelone.com/012016TechBriefWP.html)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-05-05 - Sophisticated New Packer Identified in CryptXXX Ransomware Sample.pdf"
    ],
    "report_names": [
        "2016-05-05 - Sophisticated New Packer Identified in CryptXXX Ransomware Sample.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535889,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653714485,
    "ts_modification_date": 1653714485,
    "files": {
        "pdf": "https://archive.orkl.eu/66be7330225bbc2829342463b91df0e949647943.pdf",
        "text": "https://archive.orkl.eu/66be7330225bbc2829342463b91df0e949647943.txt",
        "img": "https://archive.orkl.eu/66be7330225bbc2829342463b91df0e949647943.jpg"
    }
}