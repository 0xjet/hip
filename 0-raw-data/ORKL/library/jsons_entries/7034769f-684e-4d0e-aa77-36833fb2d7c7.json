{
    "id": "7034769f-684e-4d0e-aa77-36833fb2d7c7",
    "created_at": "2023-01-12T15:06:21.523964Z",
    "updated_at": "2025-03-27T02:14:02.584216Z",
    "deleted_at": null,
    "sha1_hash": "41d22c4be0af5b32c5c3e3c82b41a8e0b8f5071f",
    "title": "2016-05-03 - A Universal Windows Bootkit",
    "authors": "",
    "file_creation_date": "2022-05-28T19:31:11Z",
    "file_modification_date": "2022-05-28T19:31:11Z",
    "file_size": 630177,
    "plain_text": "# A Universal Windows Bootkit\n\n**williamshowalter.com/a-universal-windows-bootkit/**\n\n### William Showalter\n\nInformation Security. Enjoys traveling. Mississippi State University graduate student.\nFormerly of the University of Alaska Fairbanks.\n\n[Email](http://10.10.0.46/mailto:williamshowalter@gmail.com) [Twitter](http://twitter.com/willshowalter) [LinkedIn](http://linkedin.com/in/williamshowalter) [Github](http://github.com/williamshowalter) [Flickr](http://www.flickr.com/williamshowalter)\n\n\n-----\n\n### An analysis of the MBR bootkit referred to as HDRoot\n\n## Executive Summary\n\nIn October, 2015 Kaspersky released an analysis of a family of malware they dubbed\n“HDRoot” on their Securelist blog. It was an installment in their ongoing series on the\nWINNTI group, known for targeting gaming companies in their APT campaigns. The\nSecurelist blog was dismissive of the HDRoot bootkit and called out a number of mistakes\nthey claimed the authors made, which brought it to be the focus of their ridicule.\n\nThe bootkit in question uses two stolen signing certificates and is capable of running without\nproblem on any Windows system that was released in the last 16 years, from Windows 2000\nto Windows 10. The one limitation is that it will only run as an MBR bootkit and will not work\non systems using UEFI. It contains the ability to install any backdoor payload to be launched\nin the context of a system service when Windows starts up on both 32 and 64-bit systems. It\nalso does a fairly good job of concealing the actual bootkit code, only failing to remove the\nbackdoor after running it at boot. This likely a conscious choice made by the authors to have\nthe backdoor responsible for removing itself, and not an oversight.\n\nHDRoot represents a serious commitment in time and effort to develop, and likely has been\nin use or development since at least 2006. The sample analyzed here dates to sometime in\n2012 or 2013, and is the same sample Kasperky reports to have analyzed in their debut post\non HDRoot. However, all evidence points to Kaspersky doing their analysis with a 2006\nsample, criticizing problems in the malware that are not actually present. Additionally, they\nprovide no hashes or other information on the actual sample they used.\n\nThe samples I analyzed in this report are detailed in appendix 1 and hashes are provided in\nappendix 2. They can be found in the following git repo below:\n\n[https://github.com/williamshowalter/hdroot-bootkit-analysis](https://github.com/williamshowalter/hdroot-bootkit-analysis)\n\n[Download White Paper](https://williamshowalter.com/assets/a-universal-windows-bootkit/A%20Universal%20Windows%20Bootkit.pdf)\n\n## Table of Contents\n\n Introduction\n\n Sample:\n\nMD5: 2c85404fe7d1891fd41fcee4c92ad305\n\nSHA1: 4c3171b48d600e6337f1495142c43172d3b01770\n\nSHA256: a9a8dc4ae77b1282f0c8bdebd2643458fc1ceb3145db4e30120dd81676ff9b61\n\n\n-----\n\nOriginal Filename: net.exe\nProduce Name: Microsoft Windows Operating System\nProduct Version: 6.1.7600.16385\nTime Stamp: 2012/08/06 13:12:39 UTC\nRetrieved from malwr [1].\n\n## This report\n\nMy analysis of this HDRoot sample began as an exercise to become more familiar with lowlevel malware and the techniques required for reverse engineering them. I had no prior\nknowledge of the WINNTI group who Kaspersky attributes this malware to, nor do I have any\nother samples beyond those associated with the dropper and bootkit analyzed here. The\ndropper is capable of installing any PE executable as the payload for the bootkit, but does\nnot come bundled with any default payloads. As such, this report offers no insight into the\nvarious payloads used by the authors. For information on the other malware associated with\nthe WINNTI group, see Trend Micro or Kaspersky’s reports on the group [2][3]. This report\ndoes, however, offer a very in-depth look into the technical workings of the HDRoot bootkit\nand its components.\n\nI also address a number of technical inaccuracies and misrepresentations from Kaspersky’s\nSecureList post of October 2015, “I am HDRoot! Part 1,” which is the only research on this\nsample to be published before my own [4]. Kaspersky’s research was very helpful getting\nstarted, but I soon discovered that their analysis was not actually performed using the\nsample identified by MD5 in the article and thus could not be relied upon. I believe this to be\nthe reason for many of their criticisms for HDRoot, which they call “quite conspicuous,” and,\n“not what you expect from such a serious APT actor.” The sample analyzed here is not free\nof criticisms, but none of the problems addressed by Kaspersky appear to be valid on the\nsample they claim to have analyzed.\n\nI also freely acknowledge that the level of detail that this report goes into is impractical for\nalmost all incident response purposes, and that this venture was largely done for my own\neducation and curiosity.\n\n## Overview\n\nThe malware examined here can be broken into several stages. The 64-bit dropper, which\nwas signed with a stolen certificate that has since been revoked, is the first component that\nis executed. The dropper installs the bootkit to the hard drive along with a backdoor\nexecutable to be run on subsequent boots. The backdoor is supplied as a parameter to the\ndropper and can be any Win32 or Win64 executable.\n\nUpon boot, the computer will execute the maliciously installed MBR, which loads a\nsubsequent component that I named the “verifier”. It is a single sector block that verifies that\nthe rest of the bootkit and the backdoor are intact before running them The bulk of the\n\n\n-----\n\nbootkit s work is done by the next component, rkImage. The name rkImage actually comes\nfrom the interface of the dropper, which explicitly refers to it when installing the bootkit.\nrkImage works by manually reading the file system from the disk in order to write the\nbackdoor (the generic term referring to the payload) into the filesystem and redirect a\nWindows system service to launch the backdoor.\n\nWhen rkImage is finished it transfers execution back to the original, non-infected MBR and\nallows Windows to boot normally. The booting system will run the backdoor instead of the\nreplaced system service, but will then restore and start the legitimate service after the\nbackdoor has ran, hiding the fact it was ever replaced.\n\n## Dropper\n\nThe dropper is designed to disguise itself as the Windows system utility net.exe. The\nproperties on the executable attempt to mirror the settings found on a Windows 7 version of\nthe utility, reporting it to a Microsoft program. When run without parameters, HDRoot shows\nthe options menu as if it were net.exe. That is where the similarities end, however.\n\nFigure 1: Dropper disguising itself as net.exe\n\nThe dropper executable, while masquerading as the Microsoft net command, has been\nsigned with a digital certificate belonging to Guangzhou YuanLuo Technology Co, Ltd, a firm\nbased in the city of Guangzhou, China who had their signing certificate stolen by the WINNTI\ngroup. The certificate has since been revoked, and, if the signing time and compilation dates\non the executable are to be believed, it was signed in 2013 almost a year after this version\nwas initially compiled.\n\n\n-----\n\nFigure 2: Dropper’s revoked certificate\n\nWhen run with any of the legitimate net command parameters or with unrecognized\nparameters, no output is given. The only commands that provide output are the valid HDRoot\ncommands programmed by the authors. Kaspersky, by analyzing an older sample from 2006,\nwas able to get a “help” output, rather than the “net” output, which contained a list of\ncommands for that version. Most of these commands still worked on the newer sample. All of\nthe commands were five or less characters in length, and even short words like install were\nabbreviated to “inst”. Since the Kaspersky command listing was half a decade older than this\nsample, and that some of the commands from their listing were no longer present, I wrote a\nsimple, and very slow, fuzzer to attempt to check all possible commands of five or less\n\n\n-----\n\ncharacters. Given the length of the other commands and that input appears to be case\ninsensitive, this appears to be a sensible approach. The code for the fuzzer can be found in\nthe supplemental files detailed in appendix 1.1. Screenshots for each command can be\nfound in appendix 3.1, as well. No additional commands to the ones Kaspersky detailed were\nfound by the fuzzer, and the table below is the known list of commands.\n\n**Command** **Description**\n\ncheck Checks for the presence of the bootkit and the integrity if present.\n\nclean Removes the bootkit.\n\n\ninst\n<Backdoor>\n\ninfo\n<Backdoor>\n\n\nInstalls the bootkit\n\nShows information about the checksums and requirements for an\nexecutable if it was installed as the backdoor.\n\n\nTable 1: HDRoot dropper commands\n\n\n-----\n\nFigure 3: inst command output\n\n## VMProtect\n\nA notable hindrance to reversing the dropper is that it was packed using VMProtect. Unlike\nmost packers, which decompress and then jump to the original executable code, VMProtect\nconverts the x86 opcodes into an automatically generated language of bytecodes to be\ninterpreted in its own emulator. Attempting to statically analyze the sample would prove an\narduous task. There have been a few unpacking plugins for Ollydbg written for certain\nversions of VMProtect, but these are generally found in forum posts and are not well\nmaintained. I believe this to be the reason Kaspersky did the bulk of their analysis with a\ndifferent sample that was almost, but not quite, functionally the same. Not wanting to spend\nmy time tackling VMProtect either, I instead used a number of dynamic analysis techniques.\n\n\n-----\n\n-----\n\nFigure 4: Graph overview of VMProtect’s emulator. Not fun.\n\n## DEBUGFILE.sys - A signed kernel driver\n\nAt the time the dropper installs the bootkit, no changes to the filesystem or the registry are\nseen between snapshots taken before and after. I took the approach of running the dropper\nin a continuous loop in a virtual machine, suspending the VM, and analyzing the resulting\nmemory image. Performing memory capture from outside the VM appeared to be the best\noption because there were a number of anti-debugging techniques employed along with the\nanti-disassembly. Using Volatility, I discovered two more PE files that were extracted inside\nthe process, but none of the four clear text resources Kaspersky claimed to have extracted\nfrom a memory dump, providing further proof that they did their analysis on a different\nsample than is listed in their blog post. The two PE files I found were kernel drivers, one 32bit and one 64-bit. The 64-bit driver is signed, as is required by 64-bit versions of Windows,\nusing yet another stolen certificate, while the 32-bit driver is not signed. This certificate\nbelongs to a South Korean video game company, Neowiz. The certificate, unlike the one for\nthe dropper, has yet to be revoked (see Figure 6).\n\nThe use of the kernel drivers is fairly straightforward. Without kernel access there is no way\nfor malware to write directly to the physical disk as there are no Windows API calls available\nto userland processes for doing so. The dropper writes out the appropriate driver to\nC:\\Windows\\system32\\Drivers\\DEBUGFILE.sys, and then creates a service for it. This shows\nup in the memory image as a handle to the registry key\nHKLM\\System\\ControlSet001\\services\\DEBUGFILE. The service runs and the driver\n\\Driver\\DEBUGFILE is created. DEBUGFILE.sys is also deleted from the disk. The driver is\nused by the dropper to proxy its direct access to the physical disk. A number of things are\ndone in this process. The original MBR is backed up and then overwritten by the new bootkit\nMBR, and then weakly encrypted components are written to disk. Near the beginning of the\ndisk is the component I’ve named the verifier, followed by two identical copies of the original\nMBR. In another section of the disk is the main component of the bootkit, rkImage, followed\nby the backdoor that was installed.\n\n\n-----\n\nFigure 5: Physical Disk Layout written by DEBUGFILE.sys\n\nOne peculiar thing the malware does is install a second copy of the rkImage and backdoor\nfiles. This copy is encrypted identically to the first, and positioned such that it ends exactly\n2063 sectors from the end of the drive. What makes this strange is that nothing in the bootkit\nwill ever transfer execution to the second copy, and that the second copy is only installed if\nthe drive has at least 30% free space. Kaspersky erroneously identified this behavior as only\ninstalling if the disk has greater than 30% free space, rather than installing a redundant copy\nof itself. As can be seen in a Windows 7 screenshot from the appendix 1.3 files, the bootkit is\nperfectly capable of installing with less than 30% free space. The only guess I make as to the\npurpose of this second copy is for the indented backdoor to be able to identify if one of the\ncopies has been modified after it starts. The dropper will also detect a modified copy.\n\n\n-----\n\n-----\n\nFigure 6: DEBUGFILE.sys\n\n## MBR\n\nFor all x86 systems not running UEFI, the boot process starts with the BIOS loading the\nMaster Boot Record into memory and jumping to it. By convention, the BIOS loads the MBR\nto the physical memory address of 0x7C00. Another convention that many MBRs follow is to\ncopy themselves a single 0x200 sized sector to the address 0x600 and then transfer\n\n\n-----\n\nexecution to this location. The HDRoot bootkit is no exception. This is partly because the\nonly code it actually changes in the original MBR is the jump address and the code jumped\nto. Most of the original MBR and partition table information is intact.\n\nA normal MBR would look at the partition table to find the partition with the boot flag set, and\nthen load the volume boot sector of that partition and transfer execution. HDRoot’s MBR\nworks similarly by calling interrupt 13 to read two sectors from disk into memory at the\naddress 0x7A00 (through 0x7DFF). These are the verifier and the original MBR, which now\nhas been loaded into the location where the MBR would have originally loaded on a noninfected system. The bootkit does not store these on disk in clear text, however. They are\nwritten to disk having been XOR’d with the byte value 0x76. Appendix 1.2 has a C utility that\ncan be used to decrypt the values. A function at offset MBR+0x88 performs these read and\ndecrypt operations, copies the partition table from the infected MBR to the original (incase\nthe victim has changed any partitions since the bootkit was installed), and then transfers\nexecution to the verifier.\n\nFigure 7: Address layout of memory loaded before rkImage\n\n\n-----\n\nFigure 8: Infected MBR code to load, decrypt verifier\n\n## Verifier\n\nThe job of the verifier is to make sure that the bootkit is intact and that a specific set of\ncriteria are met before allowing the bootkit to run. If any of these criteria fail the verifier will\ntransfer the boot process to the original MBR, now at 0x7C00, without the bootkit executing.\nThis mechanism helps prevent bricking the victim machines in the event that one or more of\nthe hidden sectors are corrupted or overwritten.\n\nThe first criteria in the verifier process is a check for whether the alt key is pressed on the\nkeyboard. If the alt key is pressed, the bootkit launch will be aborted. The verifier then\nchecks for a value at 0x7A08 (+0x8 from the verifier start address). If the value is null, the\nstartup is aborted. This value is the drive identifier of where rkImage and the backdoor are\nstored. This was 0x80 in all the systems I tested on, which indicates drive 0. The dropper\nsets this value, and the subsequent bytes, before writing them to disk. This ensures that the\nbootkit was properly setup during install, and allows for the bootkit to be stored on a separate\ndisk from the system disk. Table 2 shows a breakdown of the rkImage information stored in\nthe verifier.\n\n\n-----\n\n**AddressAddress** **ContentsContents**\n\n0x7A02 0x55AA, not used, signals start of rkImage location data.\n\n0x7A04 CRC16 value for rkImage+Backdoor.\n\n0x7A06 Sector count for rkImage+Backdoor.\n\n0x7A08 Drive number\n\n0x7A09 Sector where rkImage+Backdoor starts.\n\n0x7A0D Next 0x55AA value, if present\n\n… …\n\nTable 2: rkImage location information in verifier\n\nThe third and final check done by the verifier is computing a CRC16 value on the encrypted\ncontents of rkImage and the backdoor (still only encrypted with an XOR 0x76). It compares\nthe results to the saved CRC, and if they do not match it aborts. Otherwise it reads the entire\nrkImage, but not the backdoor, to 0x10000, and then decrypts both. The last step is to copy\nthe size and location information to the start of rkImage, so it can locate the backdoor for\ninstalling.\n\n## rkImage\n\nA significant component to reverse engineering the functionality of this bootkit was becoming\nfamiliar with the mechanics of low-level, pre-OS x86. For anyone looking to get into this I\nwould highly recommend the Intermediate Intel x86 videos on OpenSecurityTraining.info [5].\nEven just following the transition from the verifier to rkImage requires some understanding,\nas the processor is still in 16-bit real mode at this time and a far jump is being performed,\ncrossing a barrier between segments. This seems like a trivial thing until you find out that\nGDB, even operating in 8086 mode remotely debugging the bootkit running in QEMU, has\nabsolutely zero understanding of segment addressing and completely falls apart trying to set\nbreakpoints at any address higher than 0xFFFF. In retrospect Bochs might have been a\nbetter choice for this over QEMU, but not being familiar with it either I struggled through with\nQEMU, learning as I went and performing most my analysis indirectly, either statically or\ndynamically through the clues left behind by the bootkit’s actions.\n\nThe first task rkImage sets itself to, like any sane code booting up, is to transfer itself from\nreal mode to protected mode, and then to 32-bit mode. In order to enable protected mode,\nthe Global Descriptor Table must be setup and loaded. This is actually fairly unimportant to\nthe operation of the malware but understanding it helped getting the disassembly properly\nsetup in IDA to assist with the process. I will not get into the details and the contents of the\nsegment descriptors, but I will state that I found the clearest explanations and diagrams in\n\n\n-----\n\nthe AMD Architecture Programmer s Manual, Vol 2., for system programming [6]. Something\nthat caused confusion was that most diagrams detailing the structure of segment descriptors\n(the entries in the Global Descriptor Table) are for the descriptors in 64-bit mode, since the\n32-bit descriptors, called legacy segment descriptors in AMD’s documentation, have a\ndifferent structure. The work done reassembling the GDT can be seen in the rkImage IDB file\nin appendix 1.4.\n\nOnce setup in a 32-bit environment, rkImage decrypts two sections in itself, the first\ncontaining a 32-bit DLL, and the second containing a 64-bit DLL. These are used to launch\nthe backdoor from a Windows system service upon Windows booting. Each DLL has a 4byte XOR key. The data is stored in rkImage in the format: 4-byte key, 4-byte length,\nencrypted PE file contents. The 32-bit DLL and its data are located at an offset of 0x4BE0\nand the 64-bit values are at 0x6DE8, immediately after the previous DLL. These DLLs as\npackaged contain the registry path to the LanmanServer service DLL. The version of\nrkImage in this sample, installed by the 64-bit dropper, overwrites the LanmanServer\ninformation with the paths and values for the Schedule service. This allows for changing the\ntarget service without the need to recompile the DLLs embedded in rkImage. Kaspersky’s\nobservations that there are a number of different services that different samples have\ntargeted supports this.\n\nThe backdoor executable is then loaded into memory and decrypted with the 0x76 XOR\noperation. At the end of this preparation work of loading, decrypting, and copying data,\nrkImage calls a function that I mark in my disassembly as being named\nDETERMINE_VERSION_NT_32_64_BIT. This is the function that determines what Windows\nversion is installed, what malicious DLL to use, and where to install it. Since the malware will\nattempt to boot in any Windows version from Windows 2000 to Windows 10, there is a\nconsiderable nest of switch and if statements happening here. It first checks whether there is\na “\\winnt” directory, which is present in Windows 2000, and if “\\winnt” is not found it will check\nfor “\\windows\\system32\\kernel32.dll”. The check for kernel32.dll prevents the bootkit from\ncontinuing install on Windows 98 and lower systems, as kernel32.dll was stored in\n“\\windows\\system\\kernel32.dll”. If kernel32.dll is found it will check for “\\users” and\n“\\documents and settings” to determine if it is XP/2003, or Vista or newer. If it is not able to\nlocate any of these, it fails out of the switch statement and no bootkit is installed.\n\nIf the directory selected was not “\\winnt”, it will check for “\\windows\\syswow64” and set a\nvariable indicating if the system is 64-bit. This is used later when choosing which DLL to\ninstall (which means it is even 64-bit Windows XP / Server 2003 compatible). Then for each\nof the three operating system categories it will write the backdoor to %TEMP%\\Explorer.exe\n(wherever %TEMP% is located for that version of Windows), and iterate through a list of\nfiles. If the file is present it will copy the appropriate DLL into the beginning of the file,\noverwriting the contents already there. The files to be overwritten in question are shown in\nTable 3, and appear to be carefully selected to cause the least potential problems, with all\nbut one of them being for different architectures than the running host.\n\n\n-----\n\n**Windows Version** **Path**\n\nWindows 2000 \\winnt\\help\\access.hlp\n\nWindows 2000 \\winnt\\system\\OLESVR.DLL\n\nWindows XP or 2003 \\windows\\twain.dll\n\nWindows XP or 2003 \\windows\\system\\OLESVR.DLL\n\nWindows Vista/2008 + \\windows\\syswow64\\C_932.NLS\n\nWindows Vista/2008 + \\windows\\system\\OLESVR.DLL\n\nWindows Vista/2008 + \\windows\\syswow64\\kmddsp.tsp\n\nWindows Vista/2008 + \\windows\\syswow64\\Irclass.dll\n\nTable 3: Service DLL Paths by OS, in order attempted\n\nWindows 2000 will attempt to first overwrite the access.hlp file, which, if anyone has not\nalready disabled the help popups, may cause errors. Similarly, the 16-bit OLESVR.DLL file is\noverwritten if access.hlp does not exist. This will only cause issues if it is used by a 16-bit\napplication, as 32-bit applications will be using the system32\\OLESVR32.DLL file. Windows\nXP will attempt to overwrite the 16-bit version of the twain.dll library for scanners (even using\nold scanners, twain32.dll should be used), and then the 16-bit OLESVR.DLL if the twain.dll is\nnot found.\n\nIn 64-bit Windows Vista and newer systems, the default target is C_932.NLS, which is a 32bit National Language Support file for the Japanese language [7]. This assumes that authors\ndid not plan on infecting targets running 32-bit applications in Japanese, as this would cause\nissues. The only file that will be tried for 32-bit Windows Vista and newer is the same 16-bit\nOLESVR.DLL. This will only cause issues for applications run in 16-bit\ncompatibility/emulation mode, as they are not natively supported by Vista and newer, and is\ntherefore unlikely to affect most targets. The other two potential target files, which are also\nunlikely to be used, are both 16-bit DLLs found in the syswow64 (32-bit compatibility)\ndirectory. They are actually only labeled as compatible with Windows Server 2003 and earlier\noperating systems on MSDN, but are for some reason still included in the syswow64\ndirectory. Kmddsp.tsp is a “kernel mode device driver” for “telephony service provider”\nnetwork drivers, and IRClass.dll is an Infrared Class Coinstaller [8]. Neither should ever be\nused on a 64-bit system and therefore won’t cause any issues if overwritten.\n\nOnce the DLL has been written to the appropriate file, the registry is patched to overwrite the\nSchedule service’s DLL path with the path to the overwritten file. This should be\napproximately:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\Schedule\\Parameters\\ServiceDLL\n\n\n-----\n\nrkImage will then return to 16-bit real mode, handing execution back to the original MBR at\n0x7C00, allowing the boot process to continue and Windows to load. It is worth noting that\nsince Windows NT also used the C:\\WINNT directory, it will match the first section of the\nbootkit which chooses the files to write the DLL into. However, since Windows did not\nintroduce the svchost.exe process until Windows 2000, services did not have a Parameters\nsub-key or a ServiceDLL value in Windows NT. As such, if installed on Windows NT the\nbootkit wouldn’t be able to locate the registry key for editing, and would fail out of the\ninstallation process. Additionally, it is likely that 32-bit versions of the dropper would not allow\nthe install to a Windows 2000 system.\n\nFigure 9: Diagram showing the out-of-OS boot process.\n\n## Schedule service DLL\n\nThe final component of the bootkit, responsible for running the backdoor within Windows, is\nthe DLL that replaced the Schedule service’s DLL. The bootkit did not change the rest of the\nregistry key, so it will be loaded into a svchost.exe executable. The Schedule service is part\nof the NetworkService group, so the DLL will be loaded into the svchost.exe containing the\nother services for the group, and a new thread will be spawned to run the ServiceMain for\nthat DLL. Additionally, as happens every time a DLL is loaded, the DLL’s entry point\n(DLLMain, in this case) is called by the Windows loader in another thread.\n\n\n-----\n\nThe HDRoot authors chose to use the DLLMain function to start the backdoor process and\nServiceMain to revert the service registry entry back to the original path. The DLLMain\nthread creates another thread running the function I identified in my disassembly as\nSpawnBackdoorThread. That thread creates a process running the backdoor, which rkImage\nsaved to %TEMP%\\Explorer.exe. It then sets a global variable in the DLL to signal that it\nsuccessfully launched the backdoor, and suspends itself before continuing.\n\nSimultaneously the ServiceMain thread reverts the registry, and waits for the backdoor to\nstart, sleeping and periodically checking for the flag to be set. After the flag is set it resumes\nthe SpawnBackdoor thread, and then exits. In turn, the SpawnBackdoor thread unloads the\nDLL from memory and then exits itself.\n\nFigure 10: Flow of the malicious Schedule service\n\nThis has the effect of both threads exiting and the DLL unloading at almost the exact same\ntime, guaranteeing that the service manager will have to restart the service, causing the\nlegitimate service DLL to be loaded and run from the patched registry entry. In all my tests of\nthis sample, not once did the real Windows service ever fail to start after running the bootkit.\nThis is completely contrary to Kaspersky’s claim that the bootkit breaks the service and that\nall the victims must just not have cared or noticed that the service failed to start.\n\n## Conclusions\n\nMy analysis of the HDRoot malware shows Kaspersky’s claims that this bootkit was written\nsloppily is patently wrong. It also leads me to no other conclusion than that they did their\nentire analysis with and presented research on a ten-year-old sample, passing it off as a\n\n\n-----\n\nsample from 2012 that had been in modern use. It also shows that the authors, who have\nbeen designated as the WINNTI group, have been around for a significant period of time,\ndating back to at least 2006 if Kaspersky’s sample is to be believed.\n\nThe one stage of the attack in which the bootkit did not make good use of hiding techniques\nwas in covering its tracks for the service and backdoor executables. Both the modified file\nhosting the DLL (C:\\Windows\\syswow64\\C_932.NLS in most my tests) and the backdoor in\n%TEMP%\\Explorer.exe were left intact on the file system. However, it is likely that a\nsophisticated backdoor run by the bootkit would know to remove these two pieces of\nevidence after starting itself, and it may just have been a choice of segregation of duties\nmade by the authors.\n\nAnother criticism that can be made is the extremely weak use of encryption. The XOR cipher\nis little more than obfuscation and was trivial to figure out even just looking at the encrypted\nsectors on the disk. It can be argued, however, that since the entire contents of the bootkit is\ncode that will be decrypted before it can be run, there is little point in hiding it from anything\nbut simple scans, as it could just be captured from memory by analysts. To that end, the\nsimple cipher serves its purpose of not matching the signatures for executables or of a boot\nsector while on disk.\n\nOverall I was impressed with the level of detail that went into making this malware which is\ncapable of installing itself on any Windows version, 32 or 64-bit, dating back to Windows\n2000, with the exception of newer installs using UEFI. The lack of UEFI support is unlikely to\nbe an issue when targeting server systems, however, especially with virtualization on the rise\n\n- very few virtual environments are virtualizing UEFI in their guests. The small touches, such\nas anticipating that the drive may have been repartitioned, are particularly impressive.\nClearly significant thought and work went into the creation of this bootkit, and it is a mistake\nto dismiss it as amateur. While different versions of the dropper are geared toward different\ntargets (the observed sample here targets the Schedule service on 64-bit systems), the\noverall framework is very flexible. The choices made in the dropper or when compiling the\ndropper are able to be tuned toward the target, choosing a service compatible with that\nversion of Windows. This makes narrowing down the traits of the bootkit from which services\nthey target to be very difficult, as it is trivial for the authors to change their target.\n\n## References\n\n[1] “malwr,” [Online]. Available:\n[https://malwr.com/analysis/NGFiNDBmMWNmYjM0NDVmZWIxNTg5OWFkMDUwYmIzNTQ/.](https://malwr.com/analysis/NGFiNDBmMWNmYjM0NDVmZWIxNTg5OWFkMDUwYmIzNTQ/)\n\n[2] E. A. II, “Backdoor Built With Aheadlib Used in Targeted Attacks?,” Trend Micro, [Online].\nAvailable: http://blog.trendmicro.com/trendlabs-security-intelligence/backdoor-built-withaheadlib-used-in-targeted-attacks/.\n\n[3] Securelist, “WINNTI: More than just a game,” [Online]. Available:\n[https://securelist.com/analysis/internal-threats-reports/37029/winnti-more-than-just-a-game/.](https://securelist.com/analysis/internal-threats-reports/37029/winnti-more-than-just-a-game/)\n\n\n-----\n\n[4] Securelist, I am HDRoot Part 1, [Online]. Available:\n[https://securelist.com/analysis/publications/72275/i-am-hdroot-part-1/.](https://securelist.com/analysis/publications/72275/i-am-hdroot-part-1/)\n\n[5] X. Kovah, “Intermediate Intel x86,” [Online]. Available:\n[http://opensecuritytraining.info/IntermediateX86.html.](http://opensecuritytraining.info/IntermediateX86.html)\n\n[6] AMD, “AMD64 Architecture Programmer’s Manual, Volume 2,” [Online]. Available:\n[http://developer.amd.com/wordpress/media/2012/10/24593_APM_v21.pdf.](http://developer.amd.com/wordpress/media/2012/10/24593_APM_v21.pdf)\n\n[7] Microsoft, “National Language Support (NLS) API Reference,” [Online]. Available:\n[https://www.microsoft.com/resources/msdn/goglobal/default.mspx.](https://www.microsoft.com/resources/msdn/goglobal/default.mspx)\n\n[8] Microsoft, “Kernel-Mode Device Driver TSP,” [Online]. Available:\n[https://msdn.microsoft.com/en-us/library/ms725209(v=vs.85).aspx.](https://msdn.microsoft.com/en-us/library/ms725209(v=vs.85).aspx)\n\n## Appendix 1. Index of Supplemental File Repository\n\n[Files are available at: https://github.com/williamshowalter/hdroot-bootkit-analysis](https://github.com/williamshowalter/hdroot-bootkit-analysis)\n\n## 1.1 Binary Files – hdroot-bootkit-analysis/binaries\n\n**File** **Description**\n\nC_932.NLS 64-bit bootkit service DLL sample, as installed\n\ndriver32.sys.bin 32-bit kernel driver used by the dropper to write\ndirectly to the physical disk.\n\ndriver64.sys.bin 64-bit signed kernel driver used by the dropper to write\ndirectly to the physical disk.\n\ndropper64.bin 64-bit dropper sample that installs bootkit\n\nmbr-clean.bin MBR before modification, for comparison.\n\nmbr-inst.bin MBR that has been modified after install.\n\npe1_decrypted.bin 32-bit bootkit service DLL sample, extracted and\ndecrypted from decrypted rkimage\n\npe1_encrypted_b61e1dcf.bin 32-bit bootkit service DLL sample, extracted in original\nform from decrypted rkimage. XOR key is 0xb64e1dcf.\n\npe2_decrypted.bin 64-bit bootkit service DLL sample, extracted and\ndecrypted from decrypted rkimage\n\npe2_encrypted_b61e8d81.bin 64-bit bootkit service DLL sample, extracted in original\nform from decrypted rkimage. XOR key is\n0xb64e8d81.\n\nrkimage_decrypted.bin rkImage sample, extracted from harddrive and\ndecrypted.\n\n\n-----\n\n**File** **Description**\n\nrkimage_encrypted.bin rkImage sample, extracted from harddrive and\ndecrypted.\n\nrkimage_backdoor_decrypted.bin rkImage sample with example backdoor, extracted\nfrom harddrive and decrypted.\n\nrkimage_backdoor_encrypted.bin rkImage sample with example backdoor, extracted\nfrom harddrive. Obfuscated with 0x76 byte-XOR.\n\nverifier_win7_decrypted.bin verifier sample, containing the verifier sector followed\nby two copies of the original mbr sector.\n\nverifier_win7_encrypted.bin Verifier sample, containing the verifier sector followed\nby two copies of the original mbr sector. Obfuscated\nwith 0x76 byte-XOR.\n\nverifier_win10_decrypted.bin verifier sample, containing the verifier sector followed\nby two copies of the original mbr sector.\n\nverifier_win10_encrypted.bin Verifier sample, containing the verifier sector followed\nby two copies of the original mbr sector. Obfuscated\nwith 0x76 byte-XOR.\n\n## 1.2 Code Files – hdroot-bootkit-analysis/code\n\n**File** **Description**\n\nconvert.c C utility to decrypt verifier and rkimage samples.\n\ndll_decryptor.c C utility to decrypt service DLL samples with 4-byte XOR keys.\n\nfuzzer.py Simple python fuzzer to discover commands to dropper64.bin\n\nproof.cpp C++ program to install as backdoor. Writes C:\\proof.txt as evidence that\nbootkit ran successfully.\n\n## 1.3 Evidence Files – hdroot-bootkit-analysis/evidence\n\n**File** **Description**\n\ncrc_error.PNG Error message shown by check command when secondary\nbootkit image is modified after install.\n\ndriver64_certificate.PNG Screenshot of the stolen certificate used by the 64-bit kernel\ndriver.\n\n\n-----\n\n**File** **Description**\n\ndriver64_valid.PNG Screenshot showing that the certificate on the kernel driver\nhas not been revoked.\n\ndropper64_certificate.PNG Screenshot of the stolen certificate used by the 64-bit\ndropper.\n\ndropper64_revoked.PNG Screenshot showing that the certificate on the dropper has\nbeen revoked.\n\nhashes_after.txt Hashes taken of files after the bootkit has run on a Windows\n7 virtual machine.\n\nhashes_before.txt Hashes taken of files before the bootkit has run on a\nWindows 7 virtual machine.\n\nhashes_win10.txt Hashes of the first and second rkImage locations on a\nWindows 10 virtual machine with > 30% free space.\n\ninstall_win10.PNG Screenshot of installing a backdoor on Windows 10.\n\ninstall_win10_cmd.PNG Screenshot of installing cmd.exe as the backdoor.\n\ninstall_win7.PNG Screenshot of installing a backdoor on Windows 7 with low\ndisk space.\n\ninstaller_cmd.txt The text output of installing a backdoor on Windows 10.\n\nNeowiz.p7b Extracted certificate used in the 64-bit kernel driver.\n\nreg_service_after.txt Registry after boot, with timestamps showing it was written\nto, even if the values didn’t change.\n\nreg_service_before.txt Registry before rebooting, with timestamps.\n\nvol_modules.txt Volatility output snippet from listing modules that shows the\nkernel driver.\n\nvol_reg_debugfile.txt Volatility output that shows a registry key for the DEBUGFILE\nservice used by the kernel driver.\n\n## 1.4 Ida Pro Files – hdroot-bootkit-analysis/ida pro\n\n**File** **Description**\n\ndriver32.sys.idb Ida Pro file for the 32-bit kernel driver. Functionally same as the\n64-bit driver.\n\n\n-----\n\n**File** **Description**\n\ndriver64.sys.idb Ida Pro file for the 64-bit kernel driver. Functionally same as the\n32-bit driver.\n\ndropper64.i64 Ida Pro file for the dropper sample. Largely not reversed, as the\nstatic sample is packed with VMProtect.\n\nmbr_infected.idb Ida Pro file for the bootkit MBR. Disassembly is 16-bit.\n\npe1_decrypted.idb Ida Pro file for the 32-bit service DLL. Functionally same as the\n64-bit DLL.\n\npe2_decrypted.i64 Ida Pro file for the 64-bit service DLL. Functionally same as the\n32-bit DLL.\n\nrkimage_decrypted.idb Ida Pro file for rkImage. Contains real mode (16-bit) and\nprotected mode (32-bit) segments. Also has undefined data at\nthe end because the sample disassembled was mistakenly\nlonger than the rkimage+bootkit length.\n\nverifier_decrypted.idb Ida Pro file for the verifier. Contains verifier and original MBR.\nDisassembly is 16-bit.\n\n## Appendix 2: Sample Hashes\n\n MD5\n\n2c85404fe7d1891fd41fcee4c92ad305 dropper64.bin\n\n4dc2fc6ad7d9ed9fcf13d914660764cd driver32.sys.bin\n\n8062cbccb2895fb9215b3423cdefa396 driver64.sys.bin\n\nc7fee0e094ee43f22882fb141c089cea pe1_decrypted.bin\n\nd0cb0eb5588eb3b14c9b9a3fa7551c28 pe2_decrypted.bin\n\n76e1e42988befbf13b4f934604206250 rkimage_encrypted.bin\n\n613fd19d0abc3d018ead52afabd59fec rkimage_decrypted.bin\n\n287fac6f4dac57253ac0061be1508f9d C_932.NLS.bin\n\n## SHA1\n\n4c3171b48d600e6337f1495142c43172d3b01770 dropper64.bin\n7ff22bd8667ce23e7db8c759bd03c15fb7226c76 driver32.sys.bin\n268dd909933c187d2798b5815674d70b930b498e driver64.sys.bin\n24a80cd100274e2c39180741aa688a4e73282552 pe1_decrypted.bin\n5d6c1a3c2d827c714b764b1c5a3e7370ed737986 pe2_decrypted.bin\n\n\n-----\n\naaf677acc05ae94f98f836fb44fd672a4b2d90db rkimage_encrypted.bin\n3c22ef94a737484e2f708393dcbabdfdb9d6cfbc rkimage_decrypted.bin\n88912b5227145d3a715ae6eeebd5935c89955721 C_932.NLS.bin\n\n## Appendix 3: Screenshots\n\n Dropper\n\n\n-----\n\nFigure 11: Dropper’s certificate\n\n\n-----\n\nFigure 12: Check before inst\n\nFigure 13: Check after inst\n\n\n-----\n\nFigure 14: Info for backdoor\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-05-03 - A Universal Windows Bootkit.pdf"
    ],
    "report_names": [
        "2016-05-03 - A Universal Windows Bootkit.pdf"
    ],
    "threat_actors": [
        {
            "id": "5bbced13-72f7-40dc-8c41-dcce75bf885e",
            "created_at": "2022-10-25T15:50:23.695735Z",
            "updated_at": "2025-03-27T02:00:55.525839Z",
            "deleted_at": null,
            "main_name": "Winnti Group",
            "aliases": [
                "Winnti Group"
            ],
            "source_name": "MITRE:Winnti Group",
            "tools": [
                "PipeMon",
                "Winnti for Windows",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "945a572f-ebe3-4e2f-a288-512fe751cfa8",
            "created_at": "2022-10-25T16:07:24.413971Z",
            "updated_at": "2025-03-27T02:02:10.212853Z",
            "deleted_at": null,
            "main_name": "Winnti Group",
            "aliases": [
                "Wicked Panda",
                "Winnti Group"
            ],
            "source_name": "ETDA:Winnti Group",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "FunnySwitch",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535981,
    "ts_updated_at": 1743041642,
    "ts_creation_date": 1653766271,
    "ts_modification_date": 1653766271,
    "files": {
        "pdf": "https://archive.orkl.eu/41d22c4be0af5b32c5c3e3c82b41a8e0b8f5071f.pdf",
        "text": "https://archive.orkl.eu/41d22c4be0af5b32c5c3e3c82b41a8e0b8f5071f.txt",
        "img": "https://archive.orkl.eu/41d22c4be0af5b32c5c3e3c82b41a8e0b8f5071f.jpg"
    }
}