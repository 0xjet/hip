{
    "id": "74ede1a8-96f9-4a36-986a-0b0b8c79c880",
    "created_at": "2023-01-12T15:00:29.095268Z",
    "updated_at": "2025-03-27T02:05:39.437374Z",
    "deleted_at": null,
    "sha1_hash": "5936cdced427f03e9ee822a533b7d41c9cad9c4f",
    "title": "2022-06-17 - Unpacking Kovter malware",
    "authors": "",
    "file_creation_date": "2022-07-02T23:15:31Z",
    "file_modification_date": "2022-07-02T23:15:31Z",
    "file_size": 5327243,
    "plain_text": "# Unpacking Kovter malware\n\n**0xchrollo.github.io/articles/unpacking-kovter-malware/**\n\nJune 17, 2022\n\nSample:\n```\n40050153DCEEC2C8FBB1912F8EEABE449D1E265F0C8198008BE8B34E5403E731\n\n\n## Behaviour analysis\n\n```\n\nJune 17, 2022\n\n\nthis malware uses a highly sophisticated way of unpacking, I’ll be demonstrating how to fully\nunpack it and extract the second stage of it.\n\nlet’s start by dynamically analysing this sample, fire up ProcMon and execute the sample.\n\nafter capturing events with ProcMon, save it to a CSV file and load it to ProcDot, it will look\nlike this.\n\n\n-----\n\nthis is a lot of output!, what we need to focus on are the red colored event.\n\n\n-----\n\nwe see that it dropped a file to disk. and also\n\nsome weird registry keys created.\n\nlet’s first start by navigating to that dropped file’s directory.\n\nwe see two files one of them is a .bat file and the other has a random extension .2ed62.\n\nnote: batch files are scripts that contains multiple commands to be executed by the\ncommand line in Windows.\n\nlet’s view the batch file’s contents.\n\nthe start command will open this file d031.2ed62 but what is the file actually is?.\nthis file is\nnot even an executable, after some time I realised that this is just a dummy file and the\nactual purpose is not to execute it.\n\nWindows by default when it tries to open any file, it looks for the software that can run the file\nin the registry, what we can do now is to open the registry\nand look for the software or\ncommand that executes .2ed62 extensions.\n\n\n-----\n\nyou can find a list of extensions under HKEY_CURRENT_USER\\Software\\Classes\n\nwe found the extension but what is the value 0346?, it is supposed to hold the name of the\nsoftware that will open it.\n\nthis 0346 is just there for obfuscation purpose and it acts like a pointer (means that you can\nfind it in the list of extensions).\n\ngoing down the list of extensions we can see our pointer and it points to mshta.exe followed\nby a JavaScript code to execute.\n\ndouble click on the name and extract the whole command.\n\nWhat pops up into our eyes immediately is the registry key\nHKCU\\software\\gxyhwinsg\\zbrqoytjz.\nit reads the contents and store it in V0ZOG variable,\nthen calls eval function which will execute the script (it needs to be a JS script).\nSo let’s\n\n\n-----\n\nexamine what s in that key.\n\nThis time if we tried to just double-click it, it won’t work because of the length.\n\nWe can use reg_export command line tool instead.\n\ncommand:\n```\nreg_export HKEY_CURRENT_USER\\Software\\gxyhwinsg zbrqoytjz dumped_scp.js\n\n\n```\nthe script we extracted looks very hard to analyse, a good thing to start with is to try\nsearching for any evals.\n\nand indeed near the end of the code we can see an eval, why is this important?\n\n\n-----\n\nas we can see this code has alot of numeric data stored which can be another form of JS\nscripts that is being decoded and executed.\n\neval is a the function that will execute any JS script, so rather than spending time analysing\nthe code (which will be a big pain), we can simply reach the point\nthat it calls eval (obviously\nafter decoding the payload) and just examine what is passed to eval.\n\nhow can we do that?\n\nOne of the quick ways is to patch eval and make it print the code to us.\n\nappend this code to the top of the script:\n```\noe = eval\n\neval = function(i){\n\n  WScript.Echo(i);\n\n  oe(i);\n\n}\n\n\n```\nrun the script with wscript.exe.\n\nwe got what it seems to be some base64 encoded data, let’s copy and decode it.\n\nnote: you can’t copy directly from windows script host, so a good way to get this string\nis to open:\n\n\n-----\n\nProcess Hacker\n\nwscript.exe Process [go to strings].\n\nfind the encoded string and extract it.\n\nafter extracting the script, we open and see a reference to powershell.exe at the end of the\nscript.\n\n\n-----\n\nthat means after decoding the base64 data we ll find a powershell script.\n\nand yes, it is a powershell script, let’s move on to our windows machine and analyse it.\n\nthere is a great tool called powershell_ise to debug powershell scripts, let’s use it to open our\nscript.\n\nopening the script in powershell_ise we can see a variable called sc32 at line 26 that holds a\nset of hex values.\n\n\n-----\n\nand at line 28 we see a VirtualAlloc invoked to allocate the length of sc32 with 0x40\n(READ_WRITE_EXECUTE).\n\nand if we take a look at line 32 and 34 we see that it copies the bytes from sc32 to some\nmemory pointer then calls CreateThread to execute that region of memory.\n\nSo, what we can conclude from this basic analysis?\n\n1. this powershell script is just another loading stage to load and execute the shellcode in\n\n**sc32 (the name also tells us that this is a shellcode [shellcode32]).**\n\nlet’s dump this shellcode and analyse it, don’t go too far, we can also use powershell_ise to\nextract this shellcode.\n\nfirst we need to put a breakpoint in the line after sc32 variable (rigth-click and toggle\nbreakpoint).\n\nrun the script (it will break after 15 seconds because at the beginning of the script it sleeps).\nafter you hit the breakpoint type this in the bottom console.\n```\n[io.file]::WriteAllBytes('shellcode.bin',$sc32)\n\n```\n\n-----\n\nand now we have our shellcode set and ready for analysis.\nlet s start analysing from SCDbg\ntool.\n\nclick launch and observe the output.\n\nnothing intersting, we can see that it only open some registry keys (which are not presented\nbecause this shellcode is not loaded in memory so it can determine strings based on his\naddress) and thats it, we have to dynamically analyse it in order to know what it is essentially\n\n\n-----\n\ndoing.\n\nlet’s use runsc tool.\n\nas we see in the console, we need to open XDBG and attach runsc process then put a\nbreakpoint on the shellcode’s address.\n\nafter you put the breakpoint, go back to the runsc window and click any key once or twice\nuntill you hit the breakpoint in XDBG.\n\nwe are now in the shellcode code!.\n\nfrom our previous analysis we see that this sample calls RegOpenKeyExA but take a note\nthat if you do a bp RegOpenKeyExA the breakpoint wont trigger because this function is\nactually loaded from advapi32.dll\n\nso type the following in the XDBG console:\n```\nbp advapi32.RegOpenKeyExA\n\n```\n\n-----\n\nrun.\n\nand YES! we hit it, and as we see from the stdcall window, we know the key it opens.\n\nlet’s get back to user code, if we scrolled down a little we can see a call to\nRegQueryValueExA (makes sense because we called RegOpenKeyExA) and VirtualAlloc.\n\nlet’s put a breakpoint on VirtualAlloc and watch the memory that it allocates (the return\nmemory address is in EAX).\n\n\n-----\n\nrun again and observe how this memory region changes.\n\nwe hit another VirtualAlloc and our memory was filled with some random data.\nfollow the\nsecond VirtualAlloc’s return address in dump and run.\n\n\n-----\n\nWE GOT THE UNPACKED EXECUTABLE!\n\nWHAT A LONG JOURNEY!!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-17 - Unpacking Kovter malware.pdf"
    ],
    "report_names": [
        "2022-06-17 - Unpacking Kovter malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535629,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1656803731,
    "ts_modification_date": 1656803731,
    "files": {
        "pdf": "https://archive.orkl.eu/5936cdced427f03e9ee822a533b7d41c9cad9c4f.pdf",
        "text": "https://archive.orkl.eu/5936cdced427f03e9ee822a533b7d41c9cad9c4f.txt",
        "img": "https://archive.orkl.eu/5936cdced427f03e9ee822a533b7d41c9cad9c4f.jpg"
    }
}