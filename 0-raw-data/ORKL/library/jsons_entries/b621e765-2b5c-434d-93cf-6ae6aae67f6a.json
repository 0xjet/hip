{
    "id": "b621e765-2b5c-434d-93cf-6ae6aae67f6a",
    "created_at": "2022-10-25T16:48:14.626772Z",
    "updated_at": "2025-03-27T02:14:02.810073Z",
    "deleted_at": null,
    "sha1_hash": "77cb524019f00c62291b56c239af3b64cde985e3",
    "title": "Study of the ShadowPad APT backdoor and its relation to PlugX",
    "authors": "",
    "file_creation_date": "2020-10-26T18:02:38Z",
    "file_modification_date": "2020-10-26T18:02:38Z",
    "file_size": 3202409,
    "plain_text": "# Study of the ShadowPad APT backdoor and its relation to PlugX\n\n\n-----\n\n**© Doctor Web, Ltd., 2020. All rights reserved.**\n\nThis document is the property of Doctor Web, Ltd. (hereinafter - Doctor Web). No part of this\ndocument may be reproduced, published or transmitted in any form or by any means for any\npurpose without proper attribution.\n\nDoctor Web develops and distributes Dr.Web information security solutions which provide\nefficient protection from malicious software and spam.\n\nDoctor Web customers can be found among home users from all over the world and in\ngovernment enterprises, small companies and nationwide corporations.\n\nDr.Web antivirus solutions are well known since 1992 for continuing excellence in malware\ndetection and compliance with international information security standards. State certificates and\nawards received by the Dr.Web solutions, as well as the globally widespread use of our products\nare the best evidence of exceptional trust to the company products.\n\n**Study of the ShadowPad APT backdoor and its relation to PlugX**\n**10/26/2020**\n\nDoctor Web Head Office\n2-12A, 3rd str. Yamskogo polya\nMoscow, Russia\n125040\n\nWebsite: www.drweb.com\nPhone: +7 (495) 789-45-87\n\nRefer to the official website for regional and international office information.\n\n\n-----\n\n## Table of Contents\n\n###### Introduction 4\n\n List of detected malware 5\n\n Conclusion 6\n\n Operating Routine of Discovered Malware Samples 6\n\n**BackDoor.ShadowPad.1** **6**\n\n**BackDoor.ShadowPad.3** **44**\n\n**BackDoor.ShadowPad.4** **70**\n\n**BackDoor.Farfli.122** **77**\n\n**BackDoor.Farfli.125** **78**\n\n**BackDoor.Siggen2.3243** **103**\n\n###### Appendix 1. Indicators of compromise 110\n\n\n-----\n\n### Introduction\n\n[In July 2020, we released a study of targeted attacks on state institutions in Kazakhstan and](https://news.drweb.com/show/?i=13907&lng=en)\nKyrgyzstan with a detailed analysis of malware found in compromised networks. During the\ninvestigation, Doctor Web specialists analyzed and described several groups of trojan programs,\nincluding new samples of trojan families already encountered by our virus analysts, as well as\n[previously unknown trojans. The most notable discovery was the samples of the XPath family.](https://vms.drweb.com/search/?q=Trojan.XPath&lng=en)\nWe were also able to find evidence that allowed us to link two initially independent incidents. In\nboth cases, the attackers used a similar selection of malware, including the same specialized\nbackdoors that infected domain controllers in the attacked organizations.\n\n[During the examination, analysts studied samples of PlugX multi-module backdoors used for](https://vms.drweb.com/search/?q=BackDoor.PlugX&lng=en)\ninitial penetration into the network infrastructure. The analysis showed that certain PlugX\nmodifications used the same domain names of C&C servers, as did other backdoors related to\ntargeted attacks on Central Asian state institutions. The detection of the PlugX programs\nindicates Chinese APT groups are possibly involved in these incidents.\n\nAccording to our data, the unauthorized presence in both networks lasted for more than three\nyears, and several hacker groups could be behind the attacks. Investigations of such complex\ncyber incidents involve long-term work, so they are rarely covered by a single article.\n\nThe Doctor Web virus laboratory received new samples of malware found on the infected\ncomputers in the local network of a state institution in Kyrgyzstan.\n\n[In addition to the malware described in the previous article, the ShadowPad backdoor deserves](https://vms.drweb.com/search/?q=BackDoor.ShadowPad&lng=en)\nparticular attention. Various modifications of this malware family are a well-known tool of the\nWinnti APT group, presumably of Chinese origin, active since at least 2012. It is noteworthy that\n[the Farfli backdoor was also installed on computer along with ShadowPad, and both programs](https://vms.drweb.com/search/?q=BackDoor.Farfli&lng=en)\nreferred to the same C&C server. Additionally, we uncovered several PlugX modifications on the\nsame computer.\n\nIn this study we analyzed the algorithms of the detected backdoors. Special attention is paid to\nthe code similarities between the ShadowPad and PlugX samples, as well as to some\nintersections in their network infrastructure.\n\n\n-----\n\n### List of detected malware\n\n\nThe following backdoors were found on the infected computer:\n\n|SHA256 hashes|Detection name|The C&C server|Installation dates|\n|---|---|---|---|\n|ac6938e03f2a076152ee4c e23a39a0bfcd676e4f0b03 1574d442b6e2df532646|BackDoor.ShadowPad.1|www[.]pneword[.]net|07.09.2018 13:14:57.664|\n|9135cdfd09a08435d344cf 4470335e6d5577e250c2f0 0017aa3ab7a9be3756b3 2c4bab3df593ba1d36894 e3d911de51d76972b6504 d94be22d659cff1325822e|BackDoor.Farfli.122 BackDoor.Farfli.125|www[.]pneword[.]net|03.11.2017 09:06:07.646|\n|3ff98ed63e3612e56be10e 0c22b26fc1069f85852ea1c 0b306e4c6a8447c546a (DLL loader) b8a13c2a4e09e04487309 ef10e4a8825d08e2cd4112 846b3ebda17e013c97339 (main module)|BackDoor.PlugX.47 BackDoor.PlugX.48|www[.]mongolv[.]com|29.12.2016 14:57:00.526|\n|32e95d80f96dae768a8230 5be974202f1ac8fcbcb985 e3543f29797396454bd1 (DLL loader) b8a13c2a4e09e04487309 ef10e4a8825d08e2cd4112 846b3ebda17e013c97339 (main module)|BackDoor.PlugX.47 BackDoor.PlugX.48|www[.]arestc[.]net|23.03.2018 13:06:01.444|\n|b8a13c2a4e09e04487309 ef10e4a8825d08e2cd4112 846b3ebda17e013c97339 (main module)|BackDoor.PlugX.48|www[.]icefirebest[.]com|03.12.2018 14:12:24.111|\n\n\n-----\n\nFor further research, we found and analyzed other samples of the ShadowPad family in order to\nperform a detailed examination of the similarities between the ShadowPad and PlugX\nbackdoors:\n\n - BackDoor.ShadowPad.3\n\n - BackDoor.ShadowPad.4—a modification of ShadowPad that was part of a self-extracting\nWinRAR dropper. It loaded an atypical for this family module in the form of a DLL library.\n\nA thorough study of ShadowPad samples and their comparison with previously studied PlugX\nmodifications indicates a high similarity in the operation principles and modular structures of the\nbackdoors from both families. These malicious programs are united not only by the general\nconcept, but also by the nuances of the code: certain development techniques, ideas, and\ntechnical solutions are nearly identical. An important point is that both backdoors were located\nin the compromised network of a state institution in Kyrgyzstan.\n\n### Conclusion\n\nThe available data allow us to conclude that these families are related in terms of simple code\nborrowing or the development of both programs by one author or a group of authors. In the\nsecond case, it is very likely that ShadowPad is an evolution of PlugX as a newer and more\nadvanced APT tool. The storage format of the malicious modules used in the ShadowPad makes\nit much more difficult to detect them in RAM.\n\n\n### Operating Routine of Discovered Malware Samples\n\n\n#### BackDoor.ShadowPad.1\n\nIt is a multi-module backdoor written in C and Assembler and designed to run on 32-bit and 64bit Microsoft Windows operating systems. It is used in targeted attacks on information systems\nfor gaining unauthorized access to data and transferring it to C&C servers. Its key feature is\nutilizing hardcoded plug-ins that contain the main backdoor’s functionality.\n\n##### Operating routine\n\nThe backdoor’s DLL library is loaded into RAM by DLL Hijacking using the genuine executable file\n```\nTosBtKbd.exe from TOSHIBA CORPORATION. On the infected computer, the file was named\nmsmsgs.exe.\n\n```\n\n-----\n\nThe backdoor can be related to BackDoor.Farfli.125, since both malware programs use the same\nC&C server—www[.]pneword[.]net.\n\nThe sample was located on the infected computer in C:\\ProgramData\\Messenger\\ and\nwas installed as the Messenger service.\n\nIt is worth noting that BackDoor.Farfli.125 can execute the 0x7532 command, which is used to\nstart a service with the same name—Messenger.\n\n##### Start of operation\n\nThe malicious library has two export functions:\n```\n SetTosBtKbdHook\n UnHookTosBtKbd\n\n```\nThe module name specified in the export table is TosBtKbd.dll.\n\nThe DLLMain function and the UnHookTosBtKbd export function are stubs.\n\n\n-----\n\nThe SetTosBtKbdHook function performs an exhaustive search through the handles in order to\nfind objects whose names contain TosBtKbd.exe and then closes them.\n\n\n-----\n\nAfter that, the shellcode stored in the backdoor body is decrypted using SetTosBtKbdHook.\n\n\n-----\n\nShellcode decryption algorithm:\n\n\n-----\n\nThe decrypted shellcode utilizes obfuscation by using two consecutive conditional JMP\ninstructions at a single address.\n\n\n-----\n\nAfter bypassing obfuscation, the function becomes correct:\n\nThe shellcode is designed for loading the main payload, which is a disassembled PE module\nwithout the MZ and PE headers. A custom header consisting of separate parts of standard\nheaders is used for the loading.\n\n\n-----\n\nThe header is stored in the shellcode after the first block of instructions.\n\n\n-----\n\nThe module_loader function then loads the payload directly. First, through the PEB structure,\nthe backdoor obtains the addresses of the following functions from kernel32:\n```\n LoadLibraryA\n GetProcAddress\n VirtualAlloc\n Sleep\nKernel32 library name and the specified APIs are searched by the hash of the name, which is\n\n```\ncalculated by the algorithm:\n\n\n-----\n\nAfter receiving the API addresses, the backdoor checks the integrity of the header values using\nan algorithm based on the XOR operation—module_header.key ^\n```\nmodule_header.key_check. The value must be 0x7C35D9A3 and it is the same value used\n\n```\nwhen hashing function names from kernel32. After that, it checks the value of the signature\n```\nmodule_header.HDR32_MAGIC signature that must be equal to 0x10B. The backdoor then\n\n```\nallocates an executable buffer of the module_header.import_table_RVA size and adds\n```\n0x4000 for the module.\n\n```\nAfter that, it fills a block with the size of 0x1000 bytes at the beginning of the\n```\nmodule_header.section_1.RVA allocated buffer. That buffer is where the PE header of the\n\n```\nloaded module should have been located.\n\n\n-----\n\nThe ECX register initially contains the address of the allocated executable buffer.\n\nThe backdoor then loads the module sections according to their RVA (Relative Virtual Address).\nSection data is stored in the shellcode after the header, and the offset to the\n(section.raw_data_offset) data is counted from the beginning of the header.\n\nAfter the sections, the program processes relocations that are stored as\n```\nIMAGE_BASE_RELOCATION structures, but each WORD, which is responsible for the relocation\n\n```\ntype and for the offset from the beginning of the block, is encrypted. The initial key is taken\nfrom module_header.key, and it changes after each iteration. It is worth noting that the key\nobtained after all iterations will be used for processing import functions.\n\nRelocations processing algorithm:\n\n\n-----\n\n-----\n\nAfter all the relocations are processed, the structure is filled with null values.\n\nNext, BackDoor.ShadowPad.1 starts processing the import functions. In general, the procedure\nis standard, but the names of libraries and functions are encrypted. The key that was modified\nafter processing the relocations is used, and is also changed after each encryption iteration. After\nprocessing the next import function, its address is not placed directly in the cell specified relative\nto IMAGE_IMPORT_DESCRIPTOR.FirstThunk. Instead, a block of instructions is generated\nthat passes control to the API:\n```\nmov eax, <addr>\nneg eax\njmp eax\n\n```\nAlgorithm for processing import functions:\n\n\n-----\n\n-----\n\nThe import table is also filled with null values after processing.\n\nThe control is then passed to the loaded module. Arguments are passed as:\n\n- Address of the beginning of the buffer where the module is loaded,\n\n\n-----\n\n- Value 1 (code),\n\n- Pointer to the shellarg structure.\n\nAt the entry point, the loaded module checks the code passed from the loader:\n\n- 1—the main functionality,\n\n- 0x64, 0x65—no action provided,\n\n- 0x66—returns the code 0x64 in the third argument,\n\n- 0x67—decrypts and returns the Root string (hereinafter Root—the name of the module),\n\n- 0x68—in the third argument returns a pointer to the table of functions implemented in this\nmodule.\n\nDecryption algorithm:\n\n\n-----\n\nIt is worth noting that the code snippets contained in this module, as well as some objects, are\n[typical of the BackDoor.PlugX family.](https://vms.drweb.ru/search/?q=BackDoor.PlugX)\n\nWhen called with the code 1, the module proceeds to perform the main functions. At first, the\nprogram registers a top-level exception handler. When receiving control, the handler generates a\ndebug string with information about the exception.\n\nThe program then outputs it using the OutputDebugString function, and writes it to the log\nfile located in %ALLUSERPROFILE%\\error.log.\n\n\n-----\n\nException handlers are also registered in the BackDoor.PlugX family. In particular, in\n[BackDoor.PlugX.38 a string with information about the exception is formed, but the format](https://vms.drweb.com/virus/?lng=en&i=21507830)\ndiffers slightly:\n\n\n-----\n\nAfter registering the handler, a table of auxiliary functions is formed that is used for interaction\nbetween modules. Next, Root proceeds to load the additional built-in modules.\n\n\n-----\n\nEach module is stored in an encrypted form and also compressed using the QuickLZ algorithm.\nAt the beginning, the module has a header size of 0x14 bytes. The header is decoded during the\nfirst step. Encryption algorithm:\n\n\n-----\n\nThe initial value of the encryption key is stored in the module header. The structure looks as\nfollows:\n\n\n-----\n\nAfter decrypting the header, the backdoor checks the value of flags. If the 0x8000 flag is set,\nit means that the module consists of only one header. Then the first byte’s zero bit value is\nchecked in the decrypted block. If the zero bit has the value 1, it means the module body is\ncompressed by the QuickLZ algorithm.\n\nAfter unpacking, the malware checks the size of the resulting data with the values in the header\nand proceeds directly to loading the module. To do so, it allocates an executable memory buffer\nto which it copies the load function and then passes control to it. Each module has the same\nformat as the Root module, so it has its own header and encrypted import functions and\nrelocations; therefore, loading occurs in the same way. After the module is loaded, the loader\nfunction calls its entry point with the code 1. Each module, like Root, initializes its function table\nusing this code. Then Root calls the entry point of the loaded module sequentially with the\ncodes 0x64, 0x66, and 0x68. This way, the backdoor initializes the module and passes it\npointers to the necessary objects.\n\nModules are represented as objects combined in a linked list. Referring to a specific module is\nperformed using the code the plug-in puts in its object after calling its entry point with the code\n```\n0x66.\n struct loaded_module\n {\n  LIST_ENTRY list;\n  DWORD run_count;\n  DWORD timestamp;\n  DWORD code_id;\n  DWORD field_14;\n  BOOL loaded;\n  BOOL unk;\n  BOOL module_is_PE;\n  DWORD module_size;\n  LPVOID module_base;\n  Root_helper *func_tab; //указатель на таблицу функций модуля Root\n }\n\n```\nWhen referring to the module entry point with the code 0x67, a string is decrypted and\nreturned, which can be designated as the module name:\n\n- 1—Plugins\n\n\n-----\n\n- 2—Online\n\n- 3—Config\n\n- 4—Install\n\n- 5—TCP\n\n- 6—HTTP\n\n- 7—UDP\n\n- 8—DNS\n\nIf one converts the timestamp fields from the headers of each plugin to dates, one gets the\ncorrect date and time values:\n\n- Plugins—2017-07-02 05:52:53\n\n- Online—2017-07-02 05:53:08\n\n- Config—2017-07-02 05:52:58\n\n- Install—2017-07-02 05:53:30\n\n- TCP—2017-07-02 05:51:36\n\n- HTTP—2017-07-02 05:51:44\n\n- UDP—2017-07-02 05:51:50\n\n- DNS—2017-07-02 05:51:55\n\nAfter loading all the Root modules, the malware searches the list for the Install module and\ncalls the second of the two functions located in its function table.\n\n**Install**\n\nFirst of all, the backdoor gets the SeTcbPrivilege and SeDebugPrivilege privileges. Then\nit obtains the configuration using the Config module. To access functions, the adapter\nfunctions of the following type are used:\n\n\n-----\n\nThrough the object that stores the list of loaded modules, the backdoor finds the necessary one\nusing the code, then the necessary function is called through the table.\n\nDuring the first step of the configuration initialization, the buffer stored in the Root module is\nchecked. If the first four bytes of this buffer are X, this means the backdoor needs to create a\ndefault configuration. Otherwise, this buffer is an encoded configuration. The configuration is\nstored in the same format as plug-ins—it is compressed using the QuickLZ algorithm and\nencrypted using the same algorithm used for plug-in encryption. 0x858 bytes are reserved for\nthe decrypted and unpacked configuration. Its structure can be represented as follows:\n\n\n-----\n\n-----\n\nFields named off_* contain offsets to encrypted strings from the beginning of the\nconfiguration. The strings are encrypted with the same algorithm as used to encrypt the names\nof the plug-ins. After initialization, the backdoor also attempts to get the configuration from the\nfile located in the %ALLUSERSPROFILE%\\<rnd1>\\<rnd2>\\<rnd3>\\<rnd4> directory. The\npath and file name elements are generated during execution and depend on the serial number of\nthe system partition.\n\nAfter initializing the configuration, the mode parameter is checked, which is stored in the\n```\nshellarg structure. That structure is filled in by the loader (shellcode) and stored in the\nstage_1 module.\n struct shellarg\n {\n   module_header *p_module_header;\n   DWORD module_size;\n   DWORD mode;\n   DWORD unk;\n }\n\n```\nThe algorithm provides a number of possible values for the mode parameter—2, 3, 4, 5,\n```\n6, 7. If the value is different from the listed ones, the backdoor is installed in the system, and\n\n```\nthen the main functions are performed.\n\nA series of values 2, 3,4—to begin interaction with the C&C server, bypassing the\ninstallation.\n\nA series of values 5, 6—to work with the plug-in with the code 0x6A stored in the registry.\n\n\n-----\n\nValue 7—using the IFileOperation interface, the source module is copied to %TEMP%, as\nwell as to System32 or SysWOW64, depending on the system bitness. This is necessary to\nrestart the backdoor with UAC bypass using the wusa.exe file.\n\n##### Backdoor installation process\n\nDuring installation, the backdoor checks the current path of the executable file by comparing it\nwith the value of off_bin_path from the configuration (%ALLUSERSPROFILE%\n```\n\\Messenger\\msmsgs.exe). If the path does not match and the backdoor is launched for the\n\n```\nfirst time, a mutex is created, the name of which is generated as follows:\n\nFormat of the mutex name for wsprintfW is Global\\%d%d%d.\n\nThen checks whether UAC is enabled. If control is disabled, the malware creates the\n```\ncontrol.exe process (from System32 or SysWOW64, depending on the system's bitness)\n\n```\nwith the CREATE_SUSPENDED flag. After that, the backdoor injects the Root module into it,\nusing WriteProcessMemory. Before doing this, the backdoor also implements a function that\nloads the module and transfers control to it. If UAC is enabled, this step is skipped.\n\nThe main executable file (msmsgs.exe) and TosBtKbd.dll are copied to the directory specified in\nthe off_bin_path parameter and then installed as a service. The service name, display name,\nand description are contained in the configuration (parameters off_svc_name,\n```\noff_svc_display_name, and off_svc_description). In this sample all three parameters\n\n```\nhave the Messenger value. If the service fails to start, the backdoor is registered in the registry.\nThe key and parameter name for this case are also stored in the configuration\n(off_reg_key_install and off_reg_value_name parameters).\n\nAfter installation, the backdoor attempts to inject the Root module into one of the processes\nspecified in the configuration (off_inject_target_<1..4>). If successful, the current\nprocess terminates, and the new process (or service) proceeds to interact with the C&C server.\n\nA separate thread is created for this purpose. After that, a new registry key is created or an\nexisting registry key is opened, which is used as the malware's virtual file system. The key is\nlocated in the Software\\Microsoft\\<key> branch, and the <key> value is also generated\ndepending on the serial number of the system volume. The key can also be located in the HKLM\nand HKCU, depending on the privileges of the process. Next, the RegNotifyChangeKey\nfunction tracks changes in this key. Each parameter is a compressed and encrypted plug-in. The\nbackdoor extracts each value and loads it as a module, adding it to the list of available ones.\n\n\n-----\n\nThis functionality is executed in a separate thread.\n\nThe next step generates a pseudo-random sequence from 3 to 9 bytes long, which is written to\nthe registry in the SOFTWARE\\ key located in the HKLM or HKCU. The parameter name is also\ngenerated and is unique for each computer. This value is used as the ID of the infected device.\n\nAfter that, the backdoor extracts the address of the first C&C server from the configuration. The\nserver storage format is as follows: <protocol>://<address>:<port>. In addition to the\nvalues that explicitly define the protocol used (HTTP, TCP, UDP), the URL value can also be\nspecified. In this case, the backdoor refers to this URL and receives a new address of the C&C\nserver in response, using the domain generation algorithm (DGA). The algorithm generates the\nstring:\n\n\n-----\n\n-----\n\nThe resulting string is combined with the string stored in the configuration, using the part before\nthe @ symbol. The received URL is used for an HTTP request, which is answered with the encoded\naddress of the C&C server.\n\nAfter that, a connection object is created that corresponds to the protocol specified for this\nserver.\n\n**TCP**\n\nSOCKS4, SOCKS5, and HTTP proxy protocols are supported when connecting over TCP. At the\nbeginning, a socket is created and a connection to the server is established in keep-alive mode.\nA packet with the following header format is used for communication with the server:\n\n\n-----\n\n**HTTP**\n\nWhen using the HTTP protocol, data is sent by a POST request:\n\nData transfer over HTTP is performed by the handler function in a separate thread. The\nmechanism is similar to that of BackDoor.PlugX.\n\nDNS servers from the configuration are used to resolve the addresses of C&C servers (in this\nsample all 4 addresses are 8.8.8.8). The first packet sent to the server is a sequence of zeros from\n```\n0 to 0x3f bytes in length. The length is selected randomly.\n\n```\nThe backdoor receives a response from the server, which is then decrypted and unpacked. Then,\nthe packet header checks the module_code value, which contains the code of the plug-in for\nwhich the command was received. The backdoor refers to the plug-in whose code is specified in\nthe command and calls the function for processing commands from its table. The ID of the\ncommand itself is contained in the id field of the header.\n\n##### Operating with plug-ins\n\nCommand IDs for the Plugins module can have the following values id—0x650000,\n```\n0x650001, 0x650002, 0x650003, or 0x650004. In fact, the Plugins module is a plug-in\n\n```\nmanager, allowing one to register new plug-ins and delete existing ones.\n\n|Value|Size, byte|\n|---|---|\n|plug-in name|variable length null-terminated string|\n|number of plug-in calls|4|\n\n|Command ID|Description|\n|---|---|\n|0x650003|Deletes the specified plug-in from the storage in the registry.|\n|0x650000|Sends information about available plug-ins. Value Size, byte plug-in name variable length null-terminated string number of plug-in calls 4|\n\n\n-----\n\n|DateTimeStamp|4|\n|---|---|\n|plug-in code|4|\n|loaded_module.field_14 (unknown)|4|\n|status (loaded or not)|4|\n|initialized|4|\n|size|4|\n|base|8|\n\n|Command ID|Description|\n|---|---|\n||DateTimeStamp 4 plug-in code 4 loaded_module.field_14 (unknown) 4 status (loaded or not) 4 initialized 4 size 4 base 8|\n|0x650001|Body of the command contains a new plug-in. The plug-in format is the same as the built-in ones. The backdoor compresses it with the QuickLZ algorithm, encrypts it and stores it in the registry storage, then pauses the current thread so the plug-in processing thread loads a new plug-in from the registry storage.|\n|0x650002|The command contains the name of the DLL that the backdoor attempts to load, and then sequentially calls its entry point with dwReason 0x64, 0x66, 0x68.|\n|0x650004|The command contains the module code. If a plug-in with the specified code is present in the list, the backdoor deinitializes it.|\n\n\n**Online**\n\nThe command IDs for the Online plug-in can have the values 0x680002, 0x680003,\n```\n0x680004, or 0x680005.\n\n```\n|Command ID|Description|\n|---|---|\n|0x680002|Starts processing commands for plug-ins in a separate thread and initializes a new connection to the current server.|\n|0x680003|Sends system information. It can be represented as the structure: struct date { BYTE year; //+0x30|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n||BYTE month; BYTE day; BYTE hour; BYTE minute; BYTE second; BYTE space; } struct sysinfo { byte id[8]; DWORD datestamp1; //20150810 DWORD datestamp2; //20170330 BYTE year; //+0x30 BYTE month; BYTE day; BYTE hour; BYTE minute; BYTE second; BYTE space; DWORD module_code; WORD module_timestamp; //the lower 2 bytes of the loaded_module.timestamp field of the connection module DWORD IP_address; LARGE_INTEGER total_physical_memory; DWORD cpu_0_MHZ;|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n||DWORD number_of_processors; DWORD dwOemID; LARGE_INTEGER total_disk_space[number_of_disks]; //iterates all disks starting from C: DWORD pels_width; //screen width in pixels DWORD pels_height; //screen height in pixels DWORD LCID; LARGE_INTEGER perfomance_frequency; //pseudo-random value generated using QueryPerformanceCounter and QueryPerformanceFrequency DWORD current_PID; DWORD os_version_major; DWORD os_version_minor; DWORD os_version_build_number; DWORD os_version_product_type; DWORD sm_Server_R2_build_number; //GetSystemMetrics(SM_SERVE RR2) //the strings below - null-terminated char hostname[x]; char domain_name[x]; char domain__username[x]; //separated \"/\" char module_file_name[x]; char osver_info_szCSDVersion[x]; char str_from_config_offset1[x]; //Messenger } The id value is the unique identifier of the infected computer stored in the registry.|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n||It is worth noting that the values of the datestamp1 and datestamp2 fields are set to 20150810 and 20170330, respectively. Similar constants in the form of dates were also used in PlugX backdoor plug-ins.|\n|0x680004|Sends a packet with a random length body (from 0 to 0x1F bytes). The packet body is filled with 0.|\n|0x680005|Sends an empty packet (header only) and then calls Sleep(1000) 3 times in a row.|\n\n\n**Config**\n\nThis is a plug-in for working with the configuration.\n\n**Command ID** **Description**\n\n0x660000 Sends the current configuration to the server.\n\n0x660001 Receives and applies the new configuration.\n\n0x660002 Deletes the saved configuration file.\n\n**Install**\n\n**Command ID** **Description**\n\n0x670000 Installs the backdoor as a service or installs it in the registry.\n\n0x670001 Calls Sleep(1000) three times in a row, then checks the shellarg.mode\nparameter: if its value is 4, it then terminates the current process.\n\n##### Artifacts\n\nIn the historical WHOIS record of the С&С server domain, one can observe the Registrar's email\naddress: ddggcc@189[.]cn.\n\nThe same address is found in the icefirebest[.]com and www[.]arestc[.]net domain records, which\nwere contained in the configurations of PlugX backdoor samples installed on the same\ncomputer.\n```\nDomain Name: ICEFIREBEST.COM\nRegistry Domain ID: 2042439159_DOMAIN_COM-VRSN\n\n```\n|Command ID|Description|\n|---|---|\n|0x660000|Sends the current configuration to the server.|\n|0x660001|Receives and applies the new configuration.|\n|0x660002|Deletes the saved configuration file.|\n\n|Command ID|Description|\n|---|---|\n|0x670000|Installs the backdoor as a service or installs it in the registry.|\n|0x670001|Calls Sleep(1000) three times in a row, then checks the shellarg.mode parameter: if its value is 4, it then terminates the current process.|\n\n\n-----\n\n```\nRegistrar WHOIS Server: whois.1api.net\nRegistrar URL: http://www.1api.net\nUpdated Date: 2016-07-28T16:55:13Z\nCreation Date: 2016-07-13T01:39:31Z\nRegistrar Registration Expiration Date: 2017-07-13T01:39:31Z\nRegistrar: 1API GmbH\nRegistrar IANA ID: 1387\nRegistrar Abuse Contact Email: abuse@1api.net\nRegistrar Abuse Contact Phone: +49.68416984x200\nDomain Status: ok - http://www.icann.org/epp#OK\nRegistry Registrant ID:\nRegistrant Name: edward davis\nRegistrant Organization: Edward Davis\nRegistrant Street: Tianhe District Sports West Road 111\nRegistrant City: HONG KONG\nRegistrant State/Province: Hongkong\nRegistrant Postal Code: 510000\nRegistrant Country: HK\nRegistrant Phone: +86.2029171680\nRegistrant Phone Ext:\nRegistrant Fax: +86.2029171680\nRegistrant Fax Ext:\nRegistrant Email: ddggcc@189.cn\nRegistry Admin ID:\nAdmin Name: edward davis\nAdmin Organization: Edward Davis\nAdmin Street: Tianhe District Sports West Road 111\nAdmin City: HONG KONG\nAdmin State/Province: Hongkong\nAdmin Postal Code: 510000\nAdmin Country: HK\nAdmin Phone: +86.2029171680\nAdmin Phone Ext:\nAdmin Fax: +86.2029171680\nAdmin Fax Ext:\n\n```\n\n-----\n\n```\nAdmin Email: ddggcc@189.cn\nRegistry Tech ID:\nTech Name: edward davis\nTech Organization: Edward Davis\nTech Street: Tianhe District Sports West Road 111\nTech City: HONG KONG\nTech State/Province: Hongkong\nTech Postal Code: 510000\nTech Country: HK\nTech Phone: +86.2029171680\nTech Phone Ext:\nTech Fax: +86.2029171680\nTech Fax Ext:\nTech Email: ddggcc@189.cn\nName Server: ns1.ispapi.net 194.50.187.134\nName Server: ns2.ispapi.net 194.0.182.1\nName Server: ns3.ispapi.net 193.227.117.124\nDNSSEC: unsigned\nURL of the ICANN WHOIS Data Problem Reporting System:\nhttp://wdprs[.]internic[.]net/\nDomain Name: ARESTC.NET\nRegistry Domain ID: 2196389400_DOMAIN_NET-VRSN\nRegistrar WHOIS Server: whois.1api.net\nRegistrar URL: http://www.1api.net\nUpdated Date: 2017-12-06T08:43:04Z\nCreation Date: 2017-12-06T08:43:04Z\nRegistrar Registration Expiration Date: 2018-12-06T08:43:04Z\nRegistrar: 1API GmbH\nRegistrar IANA ID: 1387\nRegistrar Abuse Contact Email: abuse@1api.net\nRegistrar Abuse Contact Phone: +49.68416984x200\nDomain Status: ok - http://www.icann.org/epp#OK\nRegistry Registrant ID:\nRegistrant Name: li yiyi\nRegistrant Organization: li yiyi\n\n```\n\n-----\n\n```\nRegistrant Street: Tianhe District Sports West Road 111\nRegistrant City: GuangZhou\nRegistrant State/Province: Guangdong\nRegistrant Postal Code: 510000\nRegistrant Country: CN\nRegistrant Phone: +86.2029179999\nRegistrant Phone Ext:\nRegistrant Fax: +86.2029179999\nRegistrant Fax Ext:\nRegistrant Email: ddggcc@189.cn\nRegistry Admin ID:\nAdmin Name: li yiyi\nAdmin Organization: li yiyi\nAdmin Street: Tianhe District Sports West Road 111\nAdmin City: GuangZhou\nAdmin State/Province: Guangdong\nAdmin Postal Code: 510000\nAdmin Country: CN\nAdmin Phone: +86.2029179999\nAdmin Phone Ext:\nAdmin Fax: +86.2029179999\nAdmin Fax Ext:\nAdmin Email: ddggcc@189.cn\nRegistry Tech ID:\nTech Name: li yiyi\nTech Organization: li yiyi\nTech Street: Tianhe District Sports West Road 111\nTech City: GuangZhou\nTech State/Province: Guangdong\nTech Postal Code: 510000\nTech Country: CN\nTech Phone: +86.2029179999\nTech Phone Ext:\nTech Fax: +86.2029179999\nTech Fax Ext:\n\n```\n\n-----\n\n```\nTech Email: ddggcc@189.cn\nName Server: ns1.ispapi.net 194.50.187.134\nName Server: ns2.ispapi.net 194.0.182.1\nName Server: ns3.ispapi.net 193.227.117.124\nDNSSEC: unsigned\nURL of the ICANN WHOIS Data Problem Reporting System:\nhttp://wdprs[.]internic[.]net/\n\n#### BackDoor.ShadowPad.3\n\n```\nIt is a multi-module backdoor written in C/C++ and Assembler and designed to run on 32-bit\nand 64-bit Microsoft Windows operating systems. It is used in targeted attacks on information\nsystems for gaining unauthorized access to data and transferring it to C&C servers. Its key\nfeature is utilizing plug-ins that contain the main backdoor’s functionality. It is a malicious DLL\nwhose original name—hpqhvsei.dll—is found in the export table. Like\n**BackDoor.ShadowPad.1, this modification has a lot in common with the malware samples of**\n[the BackDoor.PlugX family.](https://vms.drweb.com/search/?q=BackDoor.PlugX&lng=en)\n\n##### Operating routine\n\nExport functions are absent. The timestamp from the export table is identical to that from the PE\nheader.\n\nThe first execution steps generally correspond to the BackDoor.ShadowPad.1:\n\n - Decrypting the shellcode and transferring control to it\n\n - The shellcode loads the main Root module, which is stored in a special format\n\n - The Root module loads remaining modules\n\nThe exception is that there is no exhaustive search through the handles to find objects whose\nnames contain TosBtKbd.exe.\n\nThe string encryption algorithm is almost identical, but the constants differ:\n\n\n-----\n\nThe algorithm for loading additional modules is also similar to BackDoor.ShadowPad.1;\nhowever, there are new modules in this sample. The backdoor has 16 modules in total. A list of\ntheir names with codes and timestamps is provided in the following table:\n\n|Module name|Code|Timestamp|\n|---|---|---|\n|Config|0x66|2019-05-06 08:33:07|\n|Disk|0x12C|2019-05-06 08:29:55|\n|ImpUser|0x6A|2019-05-06 08:33:18|\n|Install|0x67|2019-05-06 08:33:34|\n|KeyLogger|0x132|2019-05-06 08:30:26|\n|Online|0x68|2019-05-06 08:33:13|\n|PIPE|0xCF|2019-05-06 08:29:11|\n|Plugins|0x65|2019-05-06 08:33:02|\n|Process|0x12D|2019-05-06 08:30:00|\n|RecentFiles|0x13D|2019-05-06 08:31:23|\n|Register|0x12F|2019-05-06 08:30:10|\n|Screen|0x133|2019-05-06 08:30:31|\n|Servcie (the original spelling)|0x12E|2019-05-06 08:30:05|\n|Shell|0x130|2019-05-06 08:30:15|\n\n\n-----\n\n|TCP|0xC8|2019-05-06 08:28:45|\n|---|---|---|\n|UDP|0xCA|2019-05-06 08:28:56|\n\n\nFor each loadable module a structure is formed that is added to the list that modules can use to\ncall each other's functions. To work with this list and for other auxiliary tasks, the Root module\nexports the function table.\n\nDuring initialization of the Plugins module, a top-level exception handler is registered. In\n**BackDoor.ShadowPad.1 this handler generated a string with information about the exception**\nfor debugging purposes. However, in BackDoor.ShadowPad.3 it only terminates the thread\n[that caused the exception. In this case, the mechanism is similar to BackDoor.PlugX.28.](https://vms.drweb.com/virus/?lng=en&i=21507745)\n\n\n-----\n\nThe key difference between the functions in this case is that PlugX operates on an object\ncontaining a linked list of all running threads, while ShadowPad directly terminates the current\nthread. However, in general, there is an analogue with the ShadowPad object, which stores\nloaded modules as a list.\n```\n struct all_modules //shadowpad\n {\n   LIST_ENTRY list;\n   DWORD modules_count;\n   CRITICAL_SECTION crit_sect;\n }\n struct obj_threads //plugx\n {\n   CRITICAL_SECTION crit_sect;\n   LIST_ENTRY list;\n   DWORD threads_running;\n }\n\n```\nThe main payload execution starts with the Install module. Similar to\n**BackDoor.ShadowPad.1, at the beginning of this stage, the backdoor obtains the necessary**\nprivileges. It is worth noting that the first stages of operation are similar to those of the PlugX\nbackdoors we studied earlier. The illustrations below show a comparison between the\n**[BackDoor.ShadowPad.3 and BackDoor.PlugX.38 algorithms.](https://vms.drweb.com/virus/?lng=en&i=21507830)**\n\n\n-----\n\n-----\n\nThen the malware initializes the configuration using the Config module. There is also a similarity\nwith BackDoor.PlugX at this stage. At the beginning, the backdoor checks the first four bytes of\nthe buffer where the encrypted configuration should be stored. If the bytes are 0x58585858\n(XXXX\" in ASCII), then:\n\n- In the BackDoor.ShadowPad.3 an empty configuration is initialized;\n\n- In the BackDoor.ShadowPad.1 a default configuration is initialized.\n\nIn BackDoor.PlugX, the first 8 bytes are checked for equality with the string XXXXXXXX.\n\n\n-----\n\n-----\n\nThe illustrations below show a comparison between the BackDoor.ShadowPad.3 and\n**BackDoor.PlugX.28 algorithms.**\n\n\n-----\n\n-----\n\nAfter initializing the configuration, the backdoor checks the value of mode in the shellarg\nstructure passed from the module loader. Actions in accordance with the value of mode are\nsimilar to those of BackDoor.ShadowPad.1.\n\nWith the mode 5 or mode 6 values, the backdoor searches the list for a module with the code\n```\n0x6A (ImpUser) and calls a function from its table. In the\n\n```\n**BackDoor.ShadowPad.1 the ImpUser module was missing. This module is used for injecting**\ninto a process that is created either with the environment of the current session, or by a remotely\nconnected user. In the context of this process, further commands from the C&C server will be\nprocessed, which must be received through a pipe from another running instance of the\nbackdoor. Thus, the backdoor running with mode 5 or mode 6 acts as a “server” for the pipe\nconnection, and its second instance relays commands to it from the C&C server. Below is a list of\nprocesses that the backdoor attempts to inject a payload into:\n\n- dllhost.exe\n\n- conhost.exe\n\n- svchost.exe\n\nSimilar functionality exists in the PlugX family of backdoors. For example, in\n**BackDoor.PlugX.38 the named thread DoImpUserProc is responsible for this.**\n\n\n-----\n\n-----\n\nIf the values are mode 7 or mode 8, the backdoor attempts to perform a UAC Bypass using the\nDLL hijack of dpx.dll library, loaded by the wusa.exe process (it has the autoElevate\nproperty), and the IFileOperation COM interface. To do this, it extracts its copy—dpx.dll\n(1d4a2acc73a7c6c83a2625efa8cc04d1f312325c), which attempts to run the original copy of the\nbackdoor with elevated privileges.\n\nThe patterns of BackDoor.ShadowPad.3, depending on the value of the shellarg.mode\nparameter, are similar to the behavior of PlugX. In the shellarg structure of the\n```\nBackDoor.PlugX.28 there is a op_mode parameter, which determines the work patterns of\n\n```\nthe malware (installation in the system, injection, function interception, etc.).\n\n\n-----\n\n##### Main functionality\n\n**BackDoor.ShadowPad.3, similar to BackDoor.ShadowPad.1, can achieve persistence either as**\na service or by using the autorun key. The service name, its description, display name, and\nregistry parameter name are stored in the configuration. Like the PlugX family,\n**BackDoor.ShadowPad.3 uses mutexes with names that depend on the process ID to**\nsynchronize the restarted program process and the parent process.\n\nBackDoor.ShadowPad.3\n\nBackDoor.PlugX.38\n\nThis backdoor also uses a mutex to prevent restarts. The name for the mutex is generated by a\nspecial function of the Config module.\n\n\n-----\n\nThe same function is also used to generate the name of the file that stores the configuration, the\ndirectory where screen screenshots are stored, and so on. The result of generation depends on\nthe seed transferred to the function and the serial number of the system volume. A similar\napproach to generating unique names was used in BackDoor.PlugX.28:\n\n\n-----\n\n-----\n\nBefore connecting to the C&C server, the backdoor uses a function to generate a string with the\n```\n0x434944 seed (CID in ASCII). This string is used as a key name and registry parameter to store\n\n```\nthe ID of the infected computer. The ID itself is an array of 8 random bytes. Thus, the backdoor\nattempts to save the following structure in the registry at\n```\n<HKEY>\\Software\\<CID_generated>\\<CID_generated> (it is also possible to save it in\n\n```\nthe HKLM or HKCU sections):\n```\n struct id_time\n {\n   BYTE id[8];\n   SYSTEMTIME current_time;\n }\n\n```\nIt should be noted that the previously analyzed PlugX samples also generate a computer ID\nbefore starting a dialog with the server and save it in the registry. A certain seed is used for\ngeneration.\n\nAfter creating the ID, the backdoor performs a network scan and starts interacting with the C&C\nserver. Network scanning is necessary to search for other infected systems on the local network.\nTo do this, 4 separate threads are started:\n\n1) scanning the range between two IP addresses specified in the backdoor configuration\n\n2) scanning the entire address range for each network adapter found in the system\n\n3) opening the port specified in the configuration\n\n\n-----\n\n4) opening the specified port and relaying packets between the local client and the actual C&C\nserver\n\nScanning sends a TCP packet containing the unique identifier of the infected computer. The\nresponse is a similar packet. If the IDs do not match, the IP address from which the packet is\nreceived becomes the address of the C&C server for the backdoor. For local communication, the\nport used is the one hardcoded in the configuration in the config.port_to_scan parameter.\nThere are 2 scanning modes available:\n\n- All addressess in the range between the two specified in the configuration are scanned\n(config.ip_addr_1 and config.ip_addr_2)\n\n- All subnets available to the infected computer are scanned (searching for network adapters)\n\nA Network Discover (TCP) firewall rule is created to open the listening port for an\nincoming connection.\n\n\n-----\n\nThe rule is created using the FirewallAPI functions of the INetFwMgr COM interface.\n\nTo work in server mode the backdoor opens a port from the configuration and waits for an\nincoming connection from clients. When a new connection is received, a tunnel is created\nbetween the local client and the actual C&C server. Network communication in scanning and\ntunneling mode is performed using the TCP module. The format and structure of the packet are\nsimilar to BackDoor.ShadowPad.1.\n\n\n-----\n\nThe functionality of the backdoor in server mode in the local network is also present in the\n**PlugX samples. In particular, in BackDoor.PlugX.38 the JoProc named threads are used for**\nthis purpose:\n\n- JoProcListen (a tunnel between the local client and the C&C server)\n\n- JoProcBroadcast (network broadcasting)\n\n- JoProcBroadcastRecv (processing responses to broadcasted messages)\n\nAfter initializing the local tunnel, BackDoor.ShadowPad.3 starts to establish the connection to\nthe C&C server. At the first stage, the backdoor attempts to connect directly to the server\nspecified in the configuration as a string. If the attempt fails, it retrieves the proxy server settings\nfrom the configuration and attempts to connect to the server using the proxy.\n\nAfter a successful connection, it sends a packet with 0 to 31 random bytes written in the body.\nThe response is a command for a plug-in. The commands for Plugins, Config, Install,\nand Online are identical to the BackDoor.ShadowPad.1 commands with some exceptions:\n\n- The 0x670001 command for the Install module is used to uninstall the backdoor\n\n- The command format for the Online module is 0x68005X instead of 0x68000X\n\n\n-----\n\n##### Processing commands for modules\n\n**ImpUser**\n\n**Command** **Description**\n**ID**\n\n0x6A0000\n\nbetween the C&C server and the process with injection.\n\n0x6A0001 Sends information about all processes injected by the\n\n**Disk**\n\n|Command ID|Description|\n|---|---|\n|0x6A0000|To establish a connection to the pipe designed for relaying data from the C&C server to the process with injection. After the connection, a tunnel is created between the C&C server and the process with injection.|\n|0x6A0001|Sends information about all processes injected by the ImpUser.|\n\n|Command ID|Description|\n|---|---|\n|0x12C0000|To get a list of letters and types of disks|\n|0x12C0001|To specify the directory; the response is a list of attached files and folders in the directory (the depth is 1 level). The following data is sent for each item: · name; · file attributes · creation time · last access time · time of last recording · size|\n|0x12C0002|To specify the file name; the backdoor checks whether the file exists|\n|0x12C0003|To create the directory specified in the command|\n|0x12C0004|To get information about the file specified in the command: attributes and time (when created, last accessed, and recorded)|\n|0x12C0005|To set attributes (file and temporary) for the file specified in the command|\n|0x12C0006|To execute SHFileOperationW with the arguments specified in the command|\n|0x12C0007|To execute CreateProcess with the lpCommandLine argument specified in the command|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n|0x12C0008|To read or write a file|\n|0x12C000A|To get a list of files by mask in the specified directory (recursively). The mask can contain the “?” and “*” symbols|\n|0x12C000C|To clear the cache by the URL specified in the command (DeleteUrlCacheEntryW), then download the file from this URL and clear the cache again|\n\n\n**Process**\n\n**Command** **Description**\n**ID**\n\n0x12D0000 To obtain a list of processes The following data is gathered for each process:\n\n        - PID;\n\n        - bitness\n\n       - domain\n\n       - username\n\n        - version of the executable file\n\n        - executable file icon data\n\n0x12D0001 To terminate the process; the command specifies the process ID\n\n**Servcie**\n\nThe name of the module with spelling mistake is contained in the code.\n\n|Command ID|Description|\n|---|---|\n|0x12D0000|To obtain a list of processes The following data is gathered for each process: · PID; · bitness · domain · username · version of the executable file · executable file icon data|\n|0x12D0001|To terminate the process; the command specifies the process ID|\n\n|Command ID|Description|\n|---|---|\n|0x12F0000|To get a list of all services. The following data is gathered for each service: · service name · description · service display name · path to the binary file · value of the ServiceDLL parameter|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n|0x12F0000|To stop a service|\n|0x12F0000|To delete a service|\n|0x12F0001|To start a service|\n|0x12F0002|To pause a service|\n|0x12F0003|To resume a service|\n\n\n**Register**\n\n**Command** **Description**\n**ID**\n\n0x12F0000 To get a list of nested keys in the registry key specified by the command\n\n0x12F0001 To create a registry key\n\n0x12F0002 To delete a registry key\n\n0x12F0003 To get a list of parameters and their values in the registry key specified by the\ncommand\n\n0x12F0004 To set the parameter value\n\n0x12F0005 To delete a parameter\n\n**Shell**\n\nThe module contains a single command—0x1300000. This command creates the command\nshell cmd.exe with I / O redirection through pipes to the C&C server.\n\n**KeyLogger**\n\nWhen initializing the KeyLogger module, a hook of the WH_KEYBOARD_LL type is set.\nKeystrokes with window names are recorded in a log file. The file name and path are generated\nusing the previously specified function.\n\n|Command ID|Description|\n|---|---|\n|0x12F0000|To get a list of nested keys in the registry key specified by the command|\n|0x12F0001|To create a registry key|\n|0x12F0002|To delete a registry key|\n|0x12F0003|To get a list of parameters and their values in the registry key specified by the command|\n|0x12F0004|To set the parameter value|\n|0x12F0005|To delete a parameter|\n\n\n-----\n\n|Command ID|Description|\n|---|---|\n|0x1320000|To get a log file|\n|0x1320001|To delete a log file|\n\n\n**Screen**\n\nThe Screen module takes a screenshot during initialization and saves it in the directory whose\nname and path are generated. The screenshot settings and JPEG encoding parameters are\ncontained in the configuration file located in the Log subdirectory of the backdoor home\ndirectory.\n\n**Command** **Description**\n**ID**\n\n0x1330000 To get a list of connected displays with the following information:\n\n      - name\n\n        - description\n\n        - screen resolution in pixels (height and width)\n\n0x1330001 To take and send a screenshot to the server\n\n0x1330002 To start a remote desktop service (RDP simulation)\n\n0x1330010 To send a screenshot storage path\n\n0x1330011 To send a file with screenshot parameters to the server\n\n0x1330012 To receive a new file from the server with the settings for screenshots\n\n**RecentFiles**\n\nThe module is designed to work with recent files and has one command—0x13D0000. When\nthe command is received, the backdoor lists all files with the .lnk extension in %USERPROFILE\n```\n%\\AppData\\Roaming\\Microsoft\\Windows\\Recent and retrieves information for each of\n\n```\nthem using the COM interfaces IShellLinkW and IPersistFile.\n\n|Command ID|Description|\n|---|---|\n|0x1330000|To get a list of connected displays with the following information: · name · description · screen resolution in pixels (height and width)|\n|0x1330001|To take and send a screenshot to the server|\n|0x1330002|To start a remote desktop service (RDP simulation)|\n|0x1330010|To send a screenshot storage path|\n|0x1330011|To send a file with screenshot parameters to the server|\n|0x1330012|To receive a new file from the server with the settings for screenshots|\n\n\n-----\n\n-----\n\n-----\n\nIt is also worth noting that ShadowPad and PlugX use identical encryption algorithms:\n\n\n-----\n\n#### BackDoor.ShadowPad.4\n\nA trojan DLL that installs other malware onto computers running 32-bit and 64-bit Microsoft\nWindows operating systems. The library is written in C and Assembler.\n\n##### Operating routine\n\nThe TosBtKbd.dll library has the following functions exports:\n\n - SetTosBt\n\n - SetTosBtKbd\n\n - SetTosBtKbdHook\n\n - UnHook\n\n - UnHookTosBt\n\n - UnHookTosBtKbd\n\nThe SetTosBt, SetTosBtKbd and SetTosBtKbdHook exports are valid and refer to the main\nmalicious function of the trojan, while UnHook, UnHookTosBt and UnHookTosBtKbd\nrepresent the dummy exports.\n\n\n-----\n\nThe analyzed sample of the BackDoor.ShadowPad.4 was spread inside the WinRAR SFX\ndropper (6ad20dade4717656beed296ecd72e35c3c8e6721), which has the following\ncomponents:\n\n- TosBtKbd.exe (a4c6d9eab106e46953f98008f72150e1e86323d6) – legitimate application\nused to launch the malicious module TosBtKbd.dll;\n\n- TosBtKbd.dll (13dda1896509d5a27bce1e2b26fef51707c19503) – the described\n**BackDoor.ShadowPad.4 module;**\n\n- TosBtKbdLayer.dll (27e8474286382ff8e2de2c49398179f11936c3c5) – a\n**BackDoor.Siggen2.3243 trojan module, which is loaded by the TosBtKbd.dll during its**\noperation.\n\n##### The launch\n```\nTosBtKbd.dll is loaded into the memory using the DLL hijacking technique through the\nTosBtKbd.exe application found inside the main dropper. Similar to the\n\n```\n**BackDoor.ShadowPad.1 trojan, upon launching, the library goes through the handles looking**\nfor an object with the TosBtKbd.exe name and tries to close it.\n\nNext, it decrypts the shellcode that loads the main malicious module, TosBtKbdLayer.dll,\ndetected by Dr.Web Anti-Virus as a BackDoor.Siggen2.3243.\n\nThe entry point of the loaded module is provided with two values of the code that is transferred\nfrom the loader:\n\nIt lacks the function that returns the module name, as well as the name of the functions table\nthat this module “exports”.\n\n\n-----\n\nSimilar to the BackDoor.ShadowPad.1 and BackDoor.ShadowPad.3 trojans and some\n[modifications of the BackDoor.PlugX trojan family, BackDoor.ShadowPad.4 obtains the](https://vms.drweb.com/search/?q=BackDoor.PlugX&lng=en)\n```\nSeTcbPrivilege and SeDebugPrivilege system privileges:\n\n```\nNext, the trojan verifies the shellarg.mode value, as well as the provided code values and\ncorresponding actions. These actions are shown below:\n\n1, 2—creates the process with the session token and injects into it, performing the main\nmalicious actions;\n\n3—closes the parent process, creates the process with the session token and injects into it,\nperforming the main malicious actions;\n\n4, 5—performs the main malicious actions;\n\nother values—installs into the system, creates the process with the session token and injects into\nit, performing the main malicious actions.\n\nBy default, the loader sets the mode 0 value. Therefore, upon initial launch, the trojan will try to\ninstall itself into the system.\n\n\n-----\n\n##### The installation\n\n**BackDoor.ShadowPad.4 verifies the current date. If it is 01.01.2021 or later, it stops its**\nexecution.\n\nThe trojan copies files necessary for its work into the %ALLUSERSPROFILE%\\DRM\\Toshiba\ndirectory and tries to install itself as a service. If it fails, it registers itself to the autorun, modifying\nthe [HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run] registry key or\n```\n[HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run] if the first attempt was\n\n```\nunsuccessful.\n\nNext, BackDoor.ShadowPad.4 tries to perform an inject. To do so, the trojan creates a\n```\ndllhost.exe process with the CREATE_SUSPENDED flag and tries to inject a shellcode,\n\n```\nresponsible for malicious module loading, into it. It also tries to inject the module itself, using\nthe strVirtualAllocEx -> WriteProcessMemory -> CreateRemoteThread\nscheme. To create a process, the following command line is used:\n```\n %SystemRoot%\\system32\\dllhost.exe /Processid:{D54EEE56-AAAB-11D0-9E1D 00A0C922E6EC}\n\n```\nIf the injection was successful, the current process is terminated. Otherwise, the trojan tries to\nperform the inject into the created process, using the current session token.\n\nWhen it runs in the context of a new process, BackDoor.ShadowPad.4 uses mutex to locate the\nparent process and terminates it. The name of the mutex is generated with the following\nfunction:\n\nNext, the trojan tries to inject its main module into the wmplayer.exe process created with the\nenvironment, obtained with the duplicate of the current session token. If it successful, it\nterminates the current process; if failed, it proceeds to its main functionality.\n\nWhen it runs in the context of wmplayer.exe, BackDoor.ShadowPad.4 proceeds to its main\nfunctionality immediately. Thus, it loads the TosBtKbdLayer.dll library into the memory and\nsends the ID of the infected computer to the С&C server.\n\n\n-----\n\n##### The main malicious functionality\n\nUsing the LoadLibrary function, BackDoor.ShadowPad.4 loads the TosBtKbdLayer.dll\nlibrary into the memory. It then generates the sequence of 16 random bytes that represents the\nID of the infected computer. If it has administrator rights, the trojan saves this ID in the ID1\nparameter of the [HKLM\\SOFTWARE\\WAD] registry key. If it doesn’t have the appropriate rights,\nit saves it in the parameter of the [HKCU\\SOFTWARE\\WAD] registry key.\n\nAfter that, BackDoor.ShadowPad.4 creates the UDP socket and binds to it, but doesn’t call the\n```\nlisten function for it to listen to the connection. After that, it generates the\nwinhook\\tdzkd\\t<id>\\t<computer_name> string, where:\n\n```\n- <id> is the generated ID of the infected computer in the form of a hex string;\n\n- <computer_name> is the name of the computer;\n\n- \\t is the tabulation symbol (0x09);\n\n- winhook and dzkd are the strings hardcoded in the trojan’s code.\n\nThe resulted string is encrypted and sent to the C&C server located at the 125.65.40.163:\n\nThe string generation and its upload to the C&C server is repeated once every hour.\n\n\n-----\n\nCompared to other modifications of the family, all the necessary parameters of\n**BackDoor.ShadowPad.4, such as the names of registry keys, services and the C&C server**\naddress, are stored in the body of the trojan as separate strings. The encryption algorithm for\nthese strings is similar to the one used in BackDoor.ShadowPad.3. The code of this algorithm is\nmodified, but the result of its execution for both malicious apps is the same:\n\n\n-----\n\n-----\n\n#### BackDoor.Farfli.122\n\nA trojan library written in C++. It represents a dropper designed to deliver other malware to\ncomputers running 32-bit and 64-bit Microsoft Windows operating systems. The analyzed\nsample is used to load the main malicious module, hidden in the encrypted file, into the\nmemory.\n\n\n-----\n\n##### Operating routine\n\nThe library loads to the memory by the RasTls.exe tool using the DLL-hijacking mechanism.\nNext, it decrypts the shellcode from the RasTls.dat file stored in its body and transfers\ncontrol to it:\n\nIn turn, this shellcode uses an XOR operation with the 0xCC byte to decrypt the main payload\n(Dr.Web detects it as BackDoor.Farfli.125) and loads it into the memory. After that, it changes\nthe strings MZ and PE to BB and CC, respectively, in the signature header of an executable file.\n\n#### BackDoor.Farfli.125\n\nA malicious .DLL installed on targeted computers by the BackDoor.Farfli.122 trojan. It is written\nin C++ and supports 32-bit and 64-bit Microsoft Windows operating systems. This library\nrepresents a backdoor that receives commands from attackers and allows them to remotely\ncontrol the infected computers.\n\n##### Operating routine\n\nThe library is loaded into the memory by BackDoor.Farfli.122. It exports the mystart function\nthat contains the main malicious functionality. This library has a PcMain.exe name in the\nexporting table.\n\n\n-----\n\n**mystart function**\n\nUpon receiving control from the shellcode loaded by BackDoor.Farfli.122, BackDoor.Farfli.125\nperforms various checkups. At the beginning, the trojan determines if it has been launched\nthrough the Wow64 subsystem and runs in the 64-bit environment. With that, if the\n```\nIsWow64Process function execution returns an error, it displays a MessageBox with the x1\n\n```\ntext. Next, BackDoor.Farfli.125 checks whenever the module file name has \\explorer.exe or\n```\n\\internet explorer\\iexplore.exe</\n\n```\nIf the backdoor runs in the context of the explorer.exe or IE process, it creates a hidden\ndirectory C:\\Microsoft\\TEMP\\Networks\\Connections\\Pbksn. Next, it verifies the\nmodule file name has a nvdiassnx string and tries to create a nvdiassnx folder in the\ndirectory it created earlier. If the trojan does not run from the nvdiassnx folder, it creates a file\nwith the RasTls<rnd>.exe name, where <rnd> represents a result of the GetTickCount\nfunction execution in the %08x format.\n\nIf the backdoor does not run in the context of the explorer.exe or IE process, it creates a C:\n```\n\\Microsoft\\TEMP\\Networks\\Connections\\Pbksn\\nvdiassnx\\ky3log.dat file.\n\n##### Anchoring in the system\n\n```\nUpon completing the initial preparation, the trojan checks if it runs in the context of the\n```\nexplorer.exe or iexplore.exe process and if it was launched from the ...\\nvdiassnx\n\n```\ndirectory.\n\n- Operation in the context of the explore.exe or iexplore.exe process\n\nIf it runs in the context of the explorer.exe or iexplore.exe process, BackDoor.Farfli.125\nimmediately proceeds to its main malicious functionality. Otherwise, it verifies if it runs from the\n```\n...\\nvdiassnx.\n\n```\n- Operation from the nvdiassnx directory\n\nIf the trojan was not launched from the ...\\\\nvdiassnx directory, it checks if the Global\\\n```\n\\vssafuyuhdw332kjgtts1 event is present. If it exists, it terminates its process to ensure\n\n```\nonly one copy of the trojan is launched. Otherwise, the trojan moves its components—\nRasTls.exe, RasTls.dll and RasTls.dat—to the C:\n```\n\\Microsoft\\TEMP\\Networks\\Connections\\Pbksn\\nvdiassnx directory.\n\n```\nIts further actions depend on the operating system version.\n\nIf BackDoor.Farfli.125 is running on Windows Vista and later Windows versions, the RasTls.exe\nmodule is set to autorun through the\n```\n[HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce] registry\n\n```\n\n-----\n\n```\nkey. Next, the trojan launches the iexplore.exe process with the\nCREATE_SUSPENDED flag, reads the shellcode from the RasTls.dat file, decrypts and injects it\n\n```\ninto the iexplore.exe process, launched earlier, continuously using the VirtualAllocEx,\n```\nWriteProcessMemory and ResumeThread functions. Herewith, it patches the entry point of\n\n```\nthe process so the injected shellcode will receive control.\n\nIf BackDoor.Farfli.125 is running on a Windows version below Windows Vista and not through\nthe Wow64 subsystem, the trojan performs the same actions but injects the shellcode into the\n```\nexplorer.exe process.\n\n```\nIf the trojan is launched from the ...\\\\nvdiassnx directory, it performs the same actions\ndescribed earlier, excluding the Global\\\\vssafuyuhdw332kjgtts1 event check and moving\nfiles.\n\n##### Main functionality\n\n**BackDoor.Farfli.125 creates a Global\\\\vssafuyuhdw332kjgtts1 event and receives the**\naddresses of the API functions it needs. To do so, it searches for the signature of two\nconsecutive DWORD 0x8776633 and 0x18776655, starting from the trojan module base. This\nsignature is located at the beginning of the last section of the module itself. With that, the\nsection is nameless and contains various service strings, including the API functions names, as\nwell as a compressed trojan configuration.\n\n\n-----\n\nThe section contains three blocks of compressed data. The first block has the strings, the second\nblock has the trojan configuration, and the third block remains empty. Herewith, the second and\nthird blocks are located at the end of the section:\n\nAfter the decompression, the second block represents a list of numbered strings listed below:\n```\nPS_10001=ole32.dll\nPS_10002=CoCreateGuid\nPS_10003=Shlwapi.dll\nPS_10004=SHDeleteKeyA\nPS_10005=wininet.dll\nPS_10006=InternetOpenA\nPS_10007=InternetOpenUrlA\nPS_10008=InternetCloseHandle\nPS_10009=HttpQueryInfoA\nPS_10010=InternetReadFile\nPS_10011=IMM32.dll\nPS_10012=ImmReleaseContext\nPS_10013=ImmGetCompositionStringW\nPS_10014=ImmGetCompositionStringA\nPS_10015=ImmGetContext\nPS_10016=ADVAPI32.dll\nPS_10017=GetUserNameW\nPS_10018=RegCloseKey\nPS_10019=RegOpenKeyExA\nPS_10020=RegCreateKeyExA\n\n```\n\n-----\n\n```\nPS_10021=RegSetValueExA\nPS_10022=RegDeleteValueA\nPS_10023=AdjustTokenPrivileges\nPS_10024=LookupPrivilegeValueA\nPS_10025=OpenProcessToken\nPS_10026=StartServiceA\nPS_10027=CloseServiceHandle\nPS_10028=OpenServiceA\nPS_10029=OpenSCManagerA\nPS_10030=CreateServiceA\nPS_10031=DeleteService\nPS_10032=RegisterServiceCtrlHandlerA\nPS_10033=SetServiceStatus\nPS_10034=Shell32.dll\nPS_10035=ShellExecuteExW\nPS_10036=ShellExecuteA\nPS_10037=User32.dll\nPS_10038=PostThreadMessageA\nPS_10039=wsprintfW\nPS_10040=CharLowerA\nPS_10041=GetMessageA\nPS_10042=PostMessageA\nPS_10043=CallNextHookEx\nPS_10044=GetForegroundWindow\nPS_10045=GetWindowTextA\nPS_10046=GetWindowThreadProcessId\nPS_10047=GetActiveWindow\nPS_10048=UnhookWindowsHookEx\nPS_10049=SetWindowsHookExW\nPS_10050=SetThreadDesktop\nPS_10051=OpenDesktopA\nPS_10052=GetThreadDesktop\nPS_10053=Kernel32.dll\nPS_10054=GetModuleHandleA\nPS_10055=DeviceIoControl\n\n```\n\n-----\n\n```\nPS_10056=CreateMutexA\nPS_10057=OpenMutexA\nPS_10058=ReleaseMutex\nPS_10059=CreateEventA\nPS_10060=OpenEventA\nPS_10061=SetEvent\nPS_10062=WaitForSingleObject\nPS_10063=GetLocalTime\nPS_10064=GetTickCount\nPS_10065=lstrcpyW\nPS_10066=lstrcatW\nPS_10067=lstrlenW\nPS_10068=lstrcmpW\nPS_10069=CreateThread\nPS_10070=GetSystemDirectoryA\nPS_10071=GetCurrentProcess\nPS_10072=OpenProcess\nPS_10073=MultiByteToWideChar\nPS_10074=WideCharToMultiByte\nPS_10075=Sleep\nPS_10076=CreateFileA\nPS_10077=DeleteFileA\nPS_10078=WriteFile\nPS_10079=ReadFile\nPS_10080=CopyFileA\nPS_10081=SetFilePointer\nPS_10082=CloseHandle\nPS_10083=GetModuleFileNameA\nPS_10084=GetVersionExA\nPS_10085=GetVersion\nPS_10086=GetCurrentThreadId\nPS_10087=GetFileSize\nPS_10088=GetTempPathA\nPS_10089=Psapi.dll\nPS_10090=GetModuleFileNameExA\n\n```\n\n-----\n\n```\nPS_10091=EnumProcesses\nPS_10092=strstr\nPS_10093=strchr\nPS_10094=strcat\nPS_10095=atoi\nPS_10096=srand\nPS_10097=rand\nPS_10098=time\nPS_10099=strrchr\nPS_10100=strlen\nPS_10101=strcpy\nPS_10102=strcmp\nPS_10103=memset\nPS_10104=MSVCRT.dll\nPS_10105=sprintf\nPS_10106=memcmp\nPS_10107=memcpy\nPS_10108=GetLogicalDriveStringsA\nPS_10109=CreateDirectoryA\nPS_10110=MoveFileA\nPS_10111=GetVolumeInformationA\nPS_10112=FindNextFileA\nPS_10113=FindFirstFileA\nPS_10114=FindClose\nPS_10115=GetDriveTypeA\nPS_10116=GetFileAttributesExA\nPS_10117=GetLastError\nPS_10118=SHFileOperationA\nPS_10119=GetCurrentProcessId\nPS_10120=OpenInputDesktop\nPS_10121=CreateToolhelp32Snapshot\nPS_10122=Process32First\nPS_10123=Process32Next\nPS_10124=RegEnumValueA\nPS_10125=EnumWindows\n\n```\n\n-----\n\n```\nPS_10126=RegEnumKeyExA\nPS_10127=ControlService\nPS_10128=TerminateProcess\nPS_10129=ShowWindow\nPS_10130=BringWindowToTop\nPS_10131=UpdateWindow\nPS_10132=MessageBoxA\nPS_10133=Winmm.dll\nPS_10134=waveInOpen\nPS_10135=waveInClose\nPS_10136=waveInPrepareHeader\nPS_10137=waveInUnprepareHeader\nPS_10138=waveInAddBuffer\nPS_10139=waveInStart\nPS_10140=waveInStop\nPS_10141=GetFileSizeEx\nPS_10142=SetFilePointerEx\nPS_10143=RegQueryValueExA\nPS_10144=GetStdHandle\nPS_10145=CreatePipe\nPS_10146=SetStdHandle\nPS_10147=DuplicateHandle\nPS_10148=CreateProcessA\nPS_10149=GlobalFree\nPS_10150=GlobalAlloc\nPS_10151=GlobalLock\nPS_10152=ResetEvent\nPS_10153=Gdiplus.dll\nPS_10154=GdiplusStartup\nPS_10155=Ole32.dll\nPS_10156=CreateStreamOnHGlobal\nPS_10157=CoInitializeEx\nPS_10158=OpenWindowStationA\nPS_10159=SetProcessWindowStation\nPS_10160=ExitProcess\n\n```\n\n-----\n\n```\nPS_10161=Wtsapi32.dll\nPS_10162=WTSSendMessageA\nPS_10163=WTSQueryUserToken\nPS_10164=WTSGetActiveConsoleSessionId\nPS_10165=DuplicateTokenEx\nPS_10166=Userenv.dll\nPS_10167=CreateEnvironmentBlock\nPS_10168=DestroyEnvironmentBlock\nPS_10169=ExitWindowsEx\nPS_10170=CreateProcessAsUserA\nPS_10171=ImpersonateSelf\nPS_10172=OpenThreadToken\nPS_10173=GetComputerNameA\nPS_10174=GlobalMemoryStatusEx\nPS_10175=GetSystemInfo\nPS_10176=GetACP\nPS_10177=GetOEMCP\nPS_10178=Gdi32.dll\nPS_10179=DeleteDC\nPS_10180=CreateDCA\nPS_10181=DeleteObject\nPS_10182=BitBlt\nPS_10183=CreateCompatibleDC\nPS_10184=SelectObject\nPS_10185=GetDeviceCaps\nPS_10186=GetDIBits\nPS_10187=CreateCompatibleBitmap\nPS_10188=SetThreadAffinityMask\nPS_10189=SetCursorPos\nPS_10190=SendInput\nPS_10191=ChangeServiceConfigA\nPS_10192=EnumServicesStatusA\nPS_10193=QueryServiceConfigA\nPS_10194=GetCurrentThread\nPS_10195=GetDiskFreeSpaceExA\n\n```\n\n-----\n\n```\nPS_10196=GetEnvironmentVariableA\nPS_10197=%08x.exe\nPS_10198=ServiceMain\nPS_10199=%s.dll\nPS_10200=TWO\nPS_10201=runas\nPS_10202=%scom.exe\nPS_10203=http://%s\nPS_10204=%08x.txt\nPS_10205=200\nPS_10206=\\svchost.exe -k\nPS_10207=%SystemRoot%\\System32\nPS_10208=%ProgramFiles%\\Common Files\\Microsoft Shared\nPS_10209=\\Services\\\nPS_10210=ControlSet003\nPS_10211=ControlSet002\nPS_10212=ControlSet001\nPS_10213=CurrentControlSet\nPS_10214=SYSTEM\\\nPS_10215=%s%s%s%s\\Parameters\nPS_10216=%s%s%s%s\nPS_10217=SeDebugPrivilege\nPS_10218=ravmond.exe\nPS_10219=rstray.exe\nPS_10220=360tray.exe\nPS_10221=ServiceDll\nPS_10222=Start\nPS_10223=Description\nPS_10224=SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost\nPS_10225=Windows Registry Editor Version 5.00\nPS_10226=[HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Messenger\\\nParameters]\nPS_10227=\"ServiceDll\"=hex(2):\nPS_10228=%02x,00,\nPS_10229=00,00\nPS_10230=SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n\n```\n\n-----\n\n```\nPS_10231=rundll32.exe \"%s\",ServiceMain\nPS_10232=ATI\nPS_10233=ctr.dll\nPS_10234=msgsvc.dll\nPS_10235=\"%s\",%s\nPS_10236=rundll32.exe\nPS_10237=%SystemRoot%\\System32\\\nPS_10238=%ProgramFiles%\\Common Files\\Microsoft Shared\\\nPS_10239=%sreg.reg\nPS_10240=%sreg.dll\nPS_10241=SystemRoot\nPS_10242=%s\\System32\\%s.dll\nPS_10243=CommonProgramFiles\nPS_10244=%s\\Microsoft Shared\\%s.dll\nPS_10245=.upa\nPS_10246=svchost.exe\nPS_10247=-s \"%s\"\nPS_10248=regedit.exe\nPS_10249=%scpy.dll\nPS_10250=CurrectUser:\nPS_10251=Password:\nPS_10252=[%04d-%02d-%02d %02d:%02d:%02d]\nPS_10253=%s %s %s\nPS_10254=***System Account And Password[%04d-%02d-%02d %02d:%02d:%\n02d]***\nPS_10255=.txt\nPS_10256=Default\nPS_10257=Winlogon\nPS_10258=%SystemRoot%\\System32\\msgsvc.dll\nPS_10259=HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\nPS_10260=~MHz\nPS_10261=SYSTEM\\ControlSet001\\Services\\%s\nPS_10262=rundll32.exe \"%s\",%s ServerAddr=%s;ServerPort=%d;Hwnd=%\nd;Cmd=%d;DdnsUrl=%s;\nPS_10263=ServerAddr\nPS_10264=ServerPort\n\n```\n\n-----\n\n```\nPS_10265=Hwnd\nPS_10266=Cmd\nPS_10267=DdnsUrl\nPS_10268=Default IME\nPS_10269=iexplore.exe\nPS_10270=SeShutdownPrivilege\nPS_10271=WinSta0\nPS_10272=Warning\nPS_10273=Action\nPS_10274=Error\nPS_10275=DISPLAY\nPS_10276=image/jpeg\nPS_10277=NULL renderer\nPS_10278=Grabber\nPS_10279=FriendlyName\nPS_10280=Cap\nPS_10281=\\%ssck.ini\nPS_10282=\\%skey.dll\nPS_10283=\\%skey.txt\nPS_10284=%skey\nPS_10285=%08x%s\nPS_10286=%s\\\nPS_10287=%s\\*.*\nPS_10288=%s\\%s\nPS_10289=CMD.EXE\nPS_10290=%s=\nPS_10291=[HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Messenger]\nPS_10292=\"Start\"=dword:00000002\nPS_10293=\"Start\"=dword:00000004\nPS_10294=Messenger\nPS_10309=\\%s.dll\nPS_10310=360safe.exe\nPS_10311=\\%sctr.dll\nPS_10312=tmp.dll\nPS_10313=ChangeServiceConfig2A\n\n```\n\n-----\n\n```\nPS_10314=QueryServiceConfig2A\nPS_10315=ServiceName\n\n```\nThe trojan keeps the unpacked block with the strings in its memory and extracts these strings\nwhenever it needs them, according to their specific numbers.\n\n**BackDoor.Farfli.125 consecutively loads all the required libraries, receives the addresses of**\nnecessary functions, and saves them inside the global structure through which it will call them.\nThe code fragment, executing this routine, is shown on the next image:\n\n\n-----\n\nAfter the necessary APIs are loaded, it finds the structure of the last section and unpacks the\nsecond block, which contains the configuration of the backdoor. This configuration contains the\nC&C address and various parameters. The structure of the BackDoor.Farfli.125 is as follows:\n\n\n-----\n\nNext, BackDoor.Farfli.125 verifies the config.copy_to_temp flag. If its value is not 0, the\ntrojan copies the .exe file from which it is running into the %TEMP% directory as a file with the\n```\n<config.name>com.exe name pattern and launches it through the ShellExecuteA\n\n```\nfunction. In the analyzed sample, the kfwktt is used for config.name in the file name.\n**BackDoor.Farfli.125 uses the current executable module name as an argument for the**\ncommand line.\n\nAfter that, the trojan verifies the config.delete_files flag. If its value is not 0, the backdoor tries\nto read the %TEMP%\\install00.tmp file and deletes the file whose name is stored in\n```\ninstall00.tmp. Next, it deletes the install00.tmp, thumbs.db, rapi.dll and\nrapiexe.exe files.\n\n```\n**BackDoor.Farfli.125 creates a C&C server connection object, initializes the Windows Sockets**\nAPI, but does not establish the connection itself. Next, using the SetProcessWindowStation\nfunction, the trojan associates itself with WinSta0 and binds the thread to the Default\ndesktop though the SetThreadDesktop function.\n\nIf the backdoor finds a config.start_keylogger flag, it initializes a keylogger. Upon its\ninitialization, the mutex is created. Its name consists of two combined names of the module\nwithout a file extension:\n```\n<module_name><module_name>\n\n```\nNext, an event with the <module_name> name is created. The name for the log file is formed as\nfollows:\n```\n%TEMP%\\<module_name>.txt.\n\n```\nTo intercept the keystrokes, the window KBDLoger with the KBDLoger class name is created.\nWith that, the interception is performed, using the RegisterRawInputDevices and\n```\nGetRawInputData functions. The keylogger log file entries are encrypted with the XOR\n\n```\noperation and the 0x62 byte.\n\n**BackDoor.Farfli.125 tries to read the <config.name>sck.ini file, which is supposed to**\ncontain the configuration for the trojan to operate as a SOCKS proxy server. This configuration\ncontains the port number to which the proxy server binding is performed, as well as the name\nand the password for the authentication. The backdoor supports the SOCKS4 and SOCKS5\nmodes with capabilities to authenticate using the name and password and is able to resolve the\ndomain names.\n\nThe operation in the SOCKS proxy server mode is performed in a separate thread. If the\nconfiguration file is missing, the trojan skips the proxy server creation stage.\n\n##### C&C communication\n\nThe name of the С&C server is stored in config.srv_addr as a string. Moreover,\n```\nconfig.url can store a URL, which the trojan uses to request a new address through the\n\n```\n\n-----\n\nWinHTTP API. In this case, the response comes as a C&C server address string, which can also\ncontain the port number, followed by :. The received address is saved in the %TEMP%\n```\n\\<threadid>.txt file, where <threadid> is the identificator of the current thread in the %\n08x format. Subsequently, the trojan reads the C&C server address from this file and applies it\n\n```\nto its configuration.\n\n**BackDoor.Farfli.125 establishes a keep-alive connection through the TCP socket and generates**\nthe encryption key, using the XOR operation with one byte. Next, it extracts the\n```\nconfig.password string from the configuration and forms a key in the size of 1 byte from it,\n\n```\nusing the following algorithm:\n```\n key = 0\n i = 0\n for x in password:\n  k = k ^ ((x << i) & 0xFF)\n  i += 1\n\n```\nThe config.password string in the analyzed sample is empty, so the data sent to the C&C\nserver remains unencrypted.\n\n**BackDoor.Farfli.125 collects the following information about the system:**\n\n- OS version\n\n- CPU frequency\n\n- the number of processors\n\n- the amount of RAM\n\n- the name of the computer\n\n- code pages for the ANSI and OEM\n\nNext, based on the collected information, it prepares the structure as follows:\n\n\n-----\n\n**id**\n\nWhen sending the first packet to the C&C server, the id field has a 0x1F40 value. When\nsending further packets, this field contains the command ID.\n\n**dword_0**\n\nThe dword_0 field equals 1 if the id value corresponds to the 0x1F40; in other cases (i.e. if this\nis the first packet) it equals 0.\n\n**cfg_dword**\n\nThe cfg_dword field equals the config.cfg_dword value.\n\n\n-----\n\n**OS_version**\n\nDepending on the version of the attacked operating system, the OS_version field can take the\nfollowing values:\n\n- 0—for Windows with the build number of 8XXXX and higher\n\n- 1—for Windows 95\n\n- 2—for Windows 2000\n\n- 3—for Windows XP\n\n- 4—for Windows Server 2003\n\n- 5—for Windows Vista, Windows Server 2008\n\n- 6—for Windows 7, Windows Server 2008 R2\n\n- 7—for Windows 8, Windows Server 2012\n\n- 8—for Windows 8.1 and higher\n\n**created_GUID**\n\nThe created_GUID field is generated through the CoCreateGuid function each time the\nstructure is sent to the C&C server. It is also saved in config.created_GUID.\n\n**unk_str**\n\nThe unk_str string is copied from the config.unk_str. In the analyzed sample, this string is\nempty.\n\n**str_group**\n\nThe str_group string is copied from config.str_group. In the analyzed sample, it has a\nvalue of General Group.\n\n**str_version**\n\nThe str_version string is copied from the config.str_version. In the analyzed sample, it\nhas a value of Customized Version.\n\nAfter the structure is formed, it is encrypted with a one-byte XOR operation if there is a key and\nsent to the C&C server. If sending has failed, the thread goes to sleep for config.timeout\nmilliseconds and tries to send the packet again. This routine is repeated until the structure is\nsuccessfully sent.\n\n\n-----\n\nIf sending was successful, BackDoor.Farfli.125 receives a block, consisting of two DWORD in\nreturn. The first DWORD is the command ID, while the second DWORD is used in the reply to\nthe command the trojan sends to the C&C server.\n\n##### The operation with the commands\n\nWhen responding to each command, the backdoor first verifies the packet with the sysinfo\ndata, where the id field holds the ID of the received command, and the cfg_dword field\nrepresents the second DWORD received with this command.\n\nThere are two groups of commands BackDoor.Farfli.125 works with:\n\n- the main commands\n\n- the secondary commands; the backdoor starts to work with them upon receiving the\ncommands with the 0x1F42, 0x1F43, 0x1F44[/strong], 0x1F4E and 0x1F54 IDs\n\n**The main commands**\n\n|Command ID|Performed actions|\n|---|---|\n|0x7535|To obtain a SeShutdownPrivilege privilege and shut down the system with the SHTDN_REASON_MINOR_RECONFIG code.|\n|0x7534|To obtain a SeShutdownPrivilege privilege and reboot the system with the SHTDN_REASON_MINOR_RECONFIG code.|\n|0x7532|To load a .DLL into the memory, call the ServiceMain function from it and delete the library. Due to possible error in the code, instead of the .DLL file, the trojan tries to load a text file with the keylogger log. If the .DLL was successfully loaded, the backdoor checks the value of the config.service parameter. This value can be as follows: · 1—the trojan deletes the ATI value in the [HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run] key · 2—the trojan forms the file %TEMP%\\<config.name>reg.reg and imports it into the Windows registry · other value—the trojan deletes the <config.name> value from the [HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost] key The reg.reg file formed by the backdoor has the following contents: Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Messenger]|\n\n\n-----\n\n|Col1|\"Start\"=dword:00000004 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Messenger] \"Start\"=dword:00000004 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet003\\Services\\Messenger] \"Start\"=dword:00000004 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Messenger\\Pa rameters] \"ServiceDll\"=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00, 52,00,6f,00,6f,00,74,00,25,00,5c,00,53,00,79,00,73,00,74,00,65 ,00,6d,00,33,00,32,00,5c,00,6d,00,73,00,67,00,73,00,76,00,63,0 0,2e,00,64,00,6c,00,6c,00,00,00 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Messenger\\Pa rameters] \"ServiceDll\"=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00, 52,00,6f,00,6f,00,74,00,25,00,5c,00,53,00,79,00,73,00,74,00,65 ,00,6d,00,33,00,32,00,5c,00,6d,00,73,00,67,00,73,00,76,00,63,0 0,2e,00,64,00,6c,00,6c,00,00,00 [HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet003\\Services\\Messenger\\Pa rameters] \"ServiceDll\"=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00, 52,00,6f,00,6f,00,74,00,25,00,5c,00,53,00,79,00,7 Where the ServiceDll name in it corresponds to the %SystemRoot% \\System32\\msgsvc.dll\\ path.|\n|---|---|\n|0x22B8|To delete the keylogger log file.|\n|0x1F5A|To shut down the SOCKS proxy server and delete the configuration file.|\n|0x1F59|To send the keylogger log file to the C&C server. The contents of the file are packed with the same algorithm as the data in the last section and sent in 3 stages: 1. the size of the packed data is sent 2. the second DWORD from the command is sent 3. the data itself is sent|\n|0x1F58|To receive a file name from the C&C server and then a buffer with the data. To open the specified file and write a received buffer into its end.|\n|0x1F57|To record a sound through the microphone into the WAV file and send it as blocks to the C&C server.|\n\n\n-----\n\n|0x1F56|To take a screenshot of the desktop and send it to the C&C server as a jpeg file.|\n|---|---|\n|0x1F52|To run a SOCKS proxy server. First, the trojan receives a configuration file, then binds a proxy server to a port specified in the configuration and starts to process the incoming connections.|\n|0x1F51|To launch Internet Explorer with the command line arguments sent in the command.|\n|0x1F50|To demonstrate MessageBox with the specified parameters.|\n|0x1F4B|To receive a file from the C&C server, save it in %TEMP%\\<threadid>.<ext> and run it using the ShellExecute function. A file extension and nShowCmd parameter are also sent in the command.|\n|0x1F4A|To receive a URL from the C&C server from which a file will be downloaded. The trojan saves the file in %TEMP% and runs it.|\n|0x1F49|To receive an executable module from the C&C server. In this module, the trojan searches for signatures similar to the one located in its last section. After this signature, it places the config.created_GUID value. Next, it saves a file in %TEMP %\\<threadid>.exe and creates a process from it. After the process is successfully created, it performs the same actions as upon receiving the 0x7532 command.|\n|0x1F48|To send a specified file to the C&C server.|\n|0x1F47|A remote control using cmd.exe. The trojan redirects I/O to the pipes, receives the commands from the C&C server, sends them into the pipe set as hStdInput for cmd.exe, reads the results from the pipe set as hStdOutput. The results are compressed before being sent and the received commands are also compressed.|\n|0x1F41|An RDP protocol imitation. The trojan takes desktop screenshots, sends them to the C&C server as .jpeg files and receives the input commands in response.|\n\n\n##### The secondary commands\n\n**BackDoor.Farfli.125 sends the sysinfo structure to the C&C server with the 0x1F42 ID after it**\nreceives one of the following commands: 0x1F42, 0x1F43, 0x1F44, 0x1F4E, or 0x1F54. In\nresponse, the server sends a compressed block with the additional command’s ID and other\ndata.\n\nThe result of the command execution is written into the %TEMP%\\<threadid>.tmp\n```\ntemporary file first, where threadid is the ID of the current thread in the %08x\n\n```\nformat. Next, the file is read and its contents are packed and sent to the C&C server.\n\n\n-----\n\n|Command ID|Performed actions|\n|---|---|\n|0x1771|To collect the information about the disk the path to which is specified in the command. The data is sent to the C&C server in the form of the structure shown below: struct disk_info { DWORD type; DWORD dword_0; LARGE_INTEGER free_bytes_available_to_caller; LARGE_INTEGER total_number_of_bytes; LARGE_INTEGER total_number_of_free_bytes; BYTE volume_name[128]; DWORD gap_0[32]; BYTE file_system_name[128]; DWORD gap_1[32]; BYTE path[64];s };|\n|0x1772|To receive the information about properties of the file specified in the command. The result of the command’s execution is saved as the following structure: struct file_info { WIN32_FILE_ATTRIBUTE_DATA attrs; //WINAPI struct char filename[512]; };|\n|0x1773|To receive the following information about a specified directory: · the properties of the directory · the number of files and subdirectories in it|\n\n\n-----\n\n|Col1|· the total amount of the data stored in it The command is executed recursively. The received information is saved as the following structure: struct dir_info { WIN32_FILE_ATTRIBUTE_DATA attrs; DWORD number_of_files; DWORD number_of_subdirs; DWORD dword_0; LARGE_INTEGER total_dir_size; BYTE path[512]; };|\n|---|---|\n|0x1774|To write a list of the files and subdirectories in the specified directory to the temporary file. The list represents a sequence of the file_info structures for each element.|\n|0x1775|To delete files listed in the command.|\n|0x1776|To create a directory.|\n|0x1777|To move a file. The current and new file name are set as two consequent buffers of the size of 0x200 bytes.|\n|0x1778|To list all available disks, forming a disk_info structure with the corresponding information for each of them. The collected data is sent to the C&C server in a response message.|\n|0x1779|To open a specified file, calling the ShellExecuteA function with the nCmdShow parameter, which equals SW_SHOW.|\n|0x177A|To obtain a SE_DEBUG_PRIVILEGE privilege and terminate a process. The command contains the PID of the targeted process in a text format.|\n\n\n-----\n\n|0x177B|To list the contents of the registry key. For each element of the key the following structure is formed: struct reg_key_item { DWORD ValueName_len; DWORD type; DWORD data_size; DWORD is_subkey; BYTE element_name[512]; BYTE data[512]; };|\n|---|---|\n|0x177C|To delete a specified registry key.|\n|0x177E|To delete a parameter in the registry key.|\n|0x177F|To set a parameter value in the registry key.|\n|0x1781|This command contains the list of paths to files and folders (one or more paths). If the path received in the command leads to the file, the trojan writes its name and size into the temporary file. If the path leads to the directory, the trojan recursively goes through it and for each file found in it, it writes its name and size into the temporary file.|\n|0x1782|To create the list of active processes. For each process the following structure is formed: struct proc_info { DWORD pid; DWORD threads_base_priority; DWORD number_of_threads; BYTE exe_file[512]; };|\n\n\n-----\n\n|Col1|The collected information is sent to the C&C server.|\n|---|---|\n|0x1783|To create a list of running services of the SERVICE_WIN32 type. For each service the following structure is formed: struct service_info { DWORD service_type; DWORD start_type; DWORD error_control; DWORD tagID; BYTE service_name[520]; BYTE display_name[520]; DWORD current_state; DWORD gap_0[9]; BYTE binary_path_name[512]; BYTE load_order_group[512]; BYTE dependencies[512]; BYTE service_start_name[1024]; BYTE description[1024]; };|\n|0x1784|To stop or launch a service. The command contains the buffer with the size of 0x200 with the service name, followed by a code. If the code is 1, the trojan needs to stop the service; if the code is 0, it needs to launch it.|\n|0x1785|The command is responsible for the service configuration control. The trojan can change the type of the launch, the name, and the displayed name of the service.|\n|0x1787|To delete a service.|\n|0x1788|To search files, using the mask. The trojan saves the list of files with their properties in the temporary file.|\n\n\n-----\n\n|0x1789|To list opened windows. For each window the trojan forms the following structure: struct window_info { BYTE text[512]; BYTE owner_process_name[512]; HWND hWnd; DWORD dword; }|\n|---|---|\n|0x178A|To close or show a window. The command contains a handle of the window, the code of the message, and the nCmdShow parameter.|\n\n\n#### BackDoor.Siggen2.3243\n\n**BackDoor.Siggen2.3243 is a malicious DLL module written in C++ and designed for 32-bit and**\n64-bit Microsoft Windows operating systems. Its functionality includes a keylogger, snooping\non clipboard contents, extracting saved logins and passwords, obtaining information about\ninstalled applications and collecting general information about the infected system.\n\n##### Operating routine\n\n**[BackDoor.Siggen2.3243 is statically linked with several libraries, such as OpenSSL, SQLite, gloox](https://camaya.net/gloox/)**\n[XMPP client library, CJsonObject JSON parser and STL.](https://github.com/Bwar/CJsonObject)\n\nThe trojan is loaded into the memory by BackDoor.ShadowPad.4 through the LoadLibrary\nfunction. At the beginning, it creates the [Guid(\"71ED330D-F80C-499A-A442```\n744EAD224A8F\")] mutex. Next, in the current directory it creates a log file whose name is\n\n```\ncalculated as an MD5 hash of the winhook-clientLog string, which is\n```\neb3816e69e6c007b96a09e2ecee968e5. After that, the trojan writes the strings in this file as\n\n```\nfollows:\n```\nInfo [YYYY-MM-DD HH:MM:SS]Log::setLogPath\nsuccess,<eb3816e69e6c007b96a09e2ecee968e5,a>\nInfo [YYYY-MM-DD HH:MM:SS]..Start.. 0.0.9a\n\n```\n\n-----\n\nWhen running, BackDoor.Siggen2.3243 saves the information about every operation it\nperforms, including information about the errors:\n\nWith that, the error messages are written with the Warring type. The example of such record is\nshown below:\n\n\n-----\n\nUsing the UDP protocol, the trojan sends messages in the form of the DKGETMMHOST\\r\\n\nstring to the remote server 1.1.1.1:8005, which belongs to the Cloudflare DNS service:\n\nSending such non-standard messages doesn’t have any practical use and can indicate the\nanalyzed sample represents a test version of the trojan, and the 1.1.1.1 server address is used as\na temporary plug.\n\nIn the response message from the server, BackDoor.Siggen2.3243 searches for the\n```\nDKMMHOST: string, followed by the address of the C&C server the trojan needs to connect to. In\n\n```\naddition, in the current directory the backdoor searches for the file whose name is the MD5 hash\nof the register.json string. This file should represent a JSON configuration file encoded with\nBase64 and containing the parameters needed to connect to the C&C server.\n\n\n-----\n\nTo communicate with the C&C server, the trojan uses JSON as well. BackDoor.Siggen2.3243 has\nthe corresponding classes to establish the connection:\n\n- doyou::io::UdpClient\n\n- doyou::io::TcpHttpClient\n\n##### Artifacts\n\nThe malicious library contains the information about the path to the project file:\n```\nC:\\Users\\Administrator\\Desktop\\Fun\\bin\\Win32\\Release\\winsafe.pdb\n\n```\nThe following strings can also be found in its body:\n```\nBrowseHistory.db\nselect url, title, last_visit_time, visit_count from urls\ntitle\nlast_visit_time\nvisit_count\nBrowseHistory::urlChrome, %s, %s\nselect id, title, last, hit from UserRankUrl\nBrowseHistory::urlSogouExplorer,%s, %s\nes.sqlite\nselect url, title, last_visit_date, visit_count from moz_places\nlast_visit_date\nBrowseHistory::urlSogouExplorer, %s\n\\\\2345Explorer\\\\User Data\\\\Default\\\\History\n2345Explorer.exe\n\\\\google\\\\chrome\\\\User Data\\\\default\\\\History\nchrome.exe\n\\\\360Chrome\\\\chrome\\\\User Data\\\\default\\\\History\n\n```\n\n-----\n\n```\n360chrome.exe\n\\\\User Data\\\\default\\\\History\n\\\\360se6\\\\User Data\\\\default\\\\History\n360se.exe\n\\\\Tencent\\\\QQBrowser\\\\User Data\\\\Default\\\\History\nQQBrowser.exe\n\\\\SogouExplorer\\\\HistoryUrl3.db\nSogouExplorer.exe\n\\\\Mozilla\\\\Firefox\\\\Profiles\nfirefox.exe\n++ %p s_buff_size = %u mb\n-- %p s_buff_size = %u mb\nwrite2socket1:sockfd<%d> client socket closed.\nwrite2socket1:sockfd<%d> nSize<%d> nLast<%d> ret<%d>\nsockfd<%d> onClose\nwarning, initSocket close old socket<%d>...\ncreate socket failed...\n<socket=%d> connect <%s:%d> failed...\nhostname2ip(hostname is null ptr).\nhostname2ip(port is null ptr).\n%s getaddrinfo\n%s getnameinfo\n--\\r\\n\\r\\n\nContent-Disposition: form-data; name=\\\"%s\\\"\\r\\n\\r\\n\n!_form_data_buf.canWrite(bytesize), url=%s\nreadsize != bytesize, url=%s\nreadsize >= 1MB\nContent-Disposition: form-data; name=\\\"%s\\\"; filename=\\\"%s\\\"\\r\\n\nContent-Type: application/octet-stream\\r\\n\\r\\n\ntotal %.2f GB (%.2f GB available)\nsystem_hide::CreatePipe\nsystem_hide::CreateProcess\nwmic path win32_physicalmedia get SerialNumber\nWMIC diskdrive get Name, Manufacturer, Model\nLocalData::task_load::PathFileExists, %s\n\n```\n\n-----\n\n```\nLocalData::task_load::read.data.empty, %s\nLocalData::task_load::CJsonObject.Parse.empty, %s\nLocalData::task_add::taskid exists %d\ntask_cache_init\nLocalData::task_cache_init::taskids.IsEmpty()\nLocalData::task_cache_init::read.data.empty, taskid=%s\nLocalData::task_cache_init::Parse.data.empty, taskid=%s\nLocalData::task_cache_init::task_state.empty, taskid=%s\ncmd_10050\nclipboard_records\ncmd_10026\nkeyboard_records\nset_do_scanfs_lasttime\n/windows/register failed!\nsuccess\nregister failed!\nregister c2s!\napplication/json\nContent-Type\n/windows/register\ntoken-refresh lost! to register_dev\ntoken-refresh s2c <%d><%s>\ntoken-refresh success! to start pushclient, token=%s\ntoken-refresh failed! to register_dev\ntoken-refresh c2s <%s>\n/windows/token-refresh\nsubmit-data warring! e.cmd<%s> != cmd<%s>\nsubmit-data failed! <%s>\nsubmit_data s2c <%s><%s>\nsubmit_data s2c <%s><%d>\nsubmit_data c2s <%p : %p> <%s>\n/windows/submit-data\nsubmit-file failed! <%s>\nsubmit_file s2c <%s><%s><%s>\n----boundaryb1zYhTI38xpQxBK00\n\n```\n\n-----\n\n```\nmultipart/form-data; boundary=\nupfile\nsubmit_file c2s <%p : %p> <%s><%s>\n/windows/submit-file\nendFile %s cbFun\nremove %s\nendFile %s\ncmd_99998\nmessage\ndo cmd_10001\nmem_size\nsd_sn\nsd_model\nsd_volume\nsd_partitioning\nvolume\ndisk_size\nfile_sys\nparation_table\nremaining_percent\nremaining_size\nmac_net\nmac_wifi\nnetwork\nsd_info\ncamera\nmicrophone\n2.0.1\nmm_version\ncmd_10001\ndo cmd_10002\ncmd_10002\nappinfo\nGetSoftInfo info.empty()\nappname\n\n```\n\n-----\n\n```\nversion\ninstall_time\ninstall_path\nuninstall_path\npublisher\ndo cmd_10014\ncmd_10014\nall_request\nGetBrowsHistory info.empty()\ndo cmd_10052\ncmd_10052\nbrowser_accounts\nUserAccHistory info.empty()\n{\\\"local_task\\\":\\\"true\\\",\\\"data\\\":{\\\"instructions\\\":{\\\"cmd\\\":\n\\\"cmd_10018\\\"}}}\ndo cmd_10013_log\n2ecee968e5\\\", \\\"filename\\\" : \\\"eb3816e69e6c007b96a09e2ecee968e5\\\"},\n\\\"extend\\\" : {\\\"id\\\":\\\"3f056c333f4f7ce015ec02f109454c54\\\", \\\"log_id\\\"\n: 2113}}}}\n{\\\"code\\\":\\\"policypush\\\", \\\"data\\\" : {\\\"type\\\":\\\"policypush\\\",\n\\\"createdatetime\\\" : \\\"2019 - 07 - 17 15:51 : 00\\\", \\\"instructions\\\"\n: {\\\"cmd\\\":\\\"cmd_10013\\\", \\\"data\\\" : {\\\"path\\\":\\\"\n\n```\n\n### Appendix 1. Indicators of compromise\n\n\n##### SHA1 hashes\n\n**BackDoor.ShadowPad.1**\n\n4bba897ee81240b10f9cca41ec010a26586e8c09: TosBtKbd.dll\n\n**BackDoor.ShadowPad.3**\n\n693f0bd265e7a68b5b98f411ecf1cd3fed3c84af: hpqhvsei.dll\n\n**BackDoor.ShadowPad.4**\n\n6ad20dade4717656beed296ecd72e35c3c8e6721: WinRAR SFX\n\n\n-----\n\n13dda1896509d5a27bce1e2b26fef51707c19503: TosBtKbd.dll\n\n27e8474286382ff8e2de2c49398179f11936c3c5: TosBtKbdLayer.dll\n\n**BackDoor.Farfli.122**\n\n6a1d928709f46d344f75936519c81137258e287c: RasTls.dll\n\n8638bcebe84be1982c430e05e6bcd72911f36e43: RasTls.dat\n\n5c54429b219614627a925347fa5006935a70d9d7: RasTls.dat decrypted\n\n**BackDoor.Farfli.125**\n\n736d8e03e40e245d4c812b091b5743fce855a529\n\n**BackDoor.PlugX.47**\n\n1acc85504c94707ac9c56a0ec23b49c4ca671c8a: fslapi.dll\n\n8f386b29d8d458df67f0a67c4e155827dcee68c9: fslapi.dll\n\n**BackDoor.PlugX.48**\n\n781831e8343d895aa4d9d95838eddda08a4673d8\n\n##### Domains\n\nwww[.]pneword[.]net\n\nwww[.]mongolv[.]com\n\nwww[.]arestc[.]net\n\nwww[.]icefirebest[.]com\n\n##### IP\n\n103.43.16[.]183\n\n103.233.98[.]123\n\n107.183.203[.]235\n\n\n-----\n\n125.65.40[.]163\n\n144.48.6[.]235\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.10.26.ShadowPad_APT_backdoor_PlugX/Study_of_the_ShadowPad_APT_backdoor_and_its_relation_to_PlugX_en%20%281%29.pdf",
        "https://st.drweb.com/static/new-www/news/2020/october/Study_of_the_ShadowPad_APT_backdoor_and_its_relation_to_PlugX_en.pdf"
    ],
    "report_names": [
        "Study_of_the_ShadowPad_APT_backdoor_and_its_relation_to_PlugX_en (1)",
        "Study_of_the_ShadowPad_APT_backdoor_and_its_relation_to_PlugX_en.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041642,
    "ts_creation_date": 1603735358,
    "ts_modification_date": 1603735358,
    "files": {
        "pdf": "https://archive.orkl.eu/77cb524019f00c62291b56c239af3b64cde985e3.pdf",
        "text": "https://archive.orkl.eu/77cb524019f00c62291b56c239af3b64cde985e3.txt",
        "img": "https://archive.orkl.eu/77cb524019f00c62291b56c239af3b64cde985e3.jpg"
    }
}