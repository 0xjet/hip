{
    "id": "171cea19-d359-454f-948b-dd1776b4fc15",
    "created_at": "2022-10-25T16:48:11.788334Z",
    "updated_at": "2025-03-27T02:16:59.15581Z",
    "deleted_at": null,
    "sha1_hash": "89329e8d50b8b425da91a7990c9efa0c6c5a0287",
    "title": "",
    "authors": "",
    "file_creation_date": "2011-06-23T22:19:08Z",
    "file_modification_date": "2011-06-23T22:19:08Z",
    "file_size": 821896,
    "plain_text": "# Killing the Myth of Cisco IOS Diversity∗ :\n\n## Recent Advances in Reliable Shellcode Design\n\n\n### Ang Cui\n##### Department of Computer Science Columbia University New York NY, 10027, USA\n### ang@cs.columbia.edu\n\n\n### Jatin Kataria\n##### Department of Computer Science Columbia University New York NY, 10027, USA\n### jk3319@columbia.edu\n\n\n### Salvatore J. Stolfo\n##### Department of Computer Science Columbia University New York NY, 10027, USA\n### sal@cs.columbia.edu\n\n\n### ABSTRACT\nIOS firmware diversity, the unintended consequence of a\ncomplex firmware compilation process, has historically made\nreliable exploitation of Cisco routers difficult. With approximately 300,000 unique IOS images in existence, a new class\nof version-agnostic shellcode is needed in order to make the\nlarge-scale exploitation of Cisco IOS possible. We show\nthat such attacks are now feasible by demonstrating two\ndifferent reliable shellcodes which will operate correctly over\nmany Cisco hardware platforms and all known IOS versions.\nWe propose a novel two-phase attack strategy against Cisco\nrouters and the use of offline analysis of existing IOS images to defeat IOS firmware diversity. Furthermore, we discuss a new IOS rootkit which hijacks all interrupt service\nroutines within the router and its ability to use intercept\nand modify process-switched packets just before they are\nscheduled for transmission. This ability allows the attacker\nto use the payload of innocuous packets, like ICMP, as a\ncovert command and control channel. The same mechanism\ncan be used to stealthily exfiltrate data out of the router,\nusing response packets generated by the router itself as the\nvehicle. We present the implementation and quantitative reliability measurements by testing both shellcode algorithms\nagainst a large collection of IOS images. As our experimental results show, the techniques proposed in this paper\ncan reliably inject command and control capabilities into\narbitrary IOS images in a version-agnostic manner. We believe that the technique presented in this paper overcomes\nan important hurdle in the large-scale, reliable rootkit execution within Cisco IOS. Thus, effective host-based defense\nfor such routers is imperative for maintaining the integrity\nof our global communication infrastructures.\n\n_∗_\nVideo demos of both IOS shellcodes and our stealthy exfiltration module can be found at [7].\n\n\n### 1. INTRODUCTION\nOver the past decade, Cisco IOS has been shown to be vulnerable to the same types of attacks that plague general\npurpose computers [13, 11]. Various exploitation techniques\nand proof-of-concept rootkits [14, 12] have been proposed.\nHowever, all current offensive techniques are impeded by an\nunintended security feature of IOS: diversity. As Felix “FX”\nLindner points out, Cisco IOS is not a homogenous collection of binaries, but a collection of approximately 300,000\ndiverse firmwares [12]. Although never intended as a defense against exploitation, this diversity makes the creation\nof reliable exploits and rootkits difficult.\n\nKnown proof-of-concept rootkits operate by patching specific locations within IOS. In the case of DIK [14], the rootkit\nintercepted a specific function responsible for checking password. The major drawback of this approach is that it relies on a priori knowledge of the location of this function.\nAs previously noted, this knowledge is generally difficult\nto obtain with accuracy prior to attack. Therefore, any\nrootkit which depends on specific memory locations cannot\nbe used reliably in large-scale attacks against the Internet\nsubstrate. Conversely, version-agnostic shellcode, combined\nwith known vulnerabilities in IOS, makes such large-scale\nattacks against Cisco routers a feasible reality.\n\nFor reliable, large-scale payload execution in IOS to be feasible, we must construct attacks and shellcodes which are\nversion and platform agnostic. Towards this end, we outline\na two-stage attack methodology as follows:\n\n**Stage 1: Leverage some IOS invariant to compute a host**\nfingerprint. Using computed information, inject stage2 shellcode. Furthermore, exfiltrate host fingerprint\nback to attacker.\n**Stage 2: Persistent rootkit with covert command and con-**\ntrol capability. The attacker will use exfiltrated fingerprint data to construct a version specific rootkit,\nwhich is loaded via the second-stage shellcode.\n\nThe attacker is at a disadvantage when attempting an online\nattack. However, since all IOS images can be obtained, and\nsuch images are not polymorphically mutated, an attacker\ncan construct a large collection of version specific rootkits\noffline. If the attacker is able to simultaneously inject a\nsimple rootkit and exfiltrate a host-environment fingerprint\n\n\n-----\n\n**Figure 1: Timeline of two-stage attack against vul-**\n**nerable IOS router of unknown hardware platform**\n**and firmware version.** **Attacker launches exploit**\n**with reliable shellcode (1.a).** **Shellcode installs**\n**rootkit and exfiltrates victim device’s IOS finger-**\n**print (1.b).** **The attacker finds exact IOS version**\n**from fingerprint by consulting offline database (2.a).**\n**The attacker then creates a version specific rootkit**\n**for victim, and uploads it using 1.b rootkit (2.b).**\n\nduring the first phase of the attack, the attacker can then\nload a rootkit specifically parameterized for the exact IOS\nversion of the victim router. Figure 1 shows the timeline of\nour proposed attack, which is intentionally broken into two\nphases to shift the advantage towards the attacker.\n\nThe two requirements of our first-stage shellcode, the need to\nreliably inject a basic second-stage rootkit, and the need to\naccurately fingerprint the victim device, can be satisfied simultaneously. Both shellcodes presented in this paper compute a set of critical memory locations within IOS’s .text\nsection. These memory addresses are used both as intercept\npoints for our second-stage code, but also used to uniquely\nidentify the exact micro-version of the victim’s firmware. As\nfigure 1 shows, this fingerprint data is exfiltrated back to the\nattacker and compared to a database of pre-computed fingerprints for all known IOS firmwares. As Section 8 shows, the\nfingerprints can be computed using simple linear-time algorithms and efficiently stored in a database. Pre-computing\nsuch fingerprints for all 300,000 IOS images should not take\nmore than a few days on a typical desktop.\n\nWe present two different techniques for implementing this\ntwo-stage attack. The disassembling shellcode is discussed\nin Section 5. A novel interrupt hijack shellcode is discussed\nin Section 6. A stealthy exfiltration technique which modifies process-switched packets just before it is scheduled for\ntransmission is discussed in Section 7. The intercept hijacking shellcode and the exfiltration mechanism built on\ntop of it has several interesting advantages over existing\nrootkit techniques. First, the command and control protocol is built into the payload of incoming packets. No specific protocol is required, as long as the packet is punted to\nthe router’s control-plane. This allows the attacker to access\nthe backdoor using a wide gamut of packet types, thus evading network-based intrusion detection systems. Hiding the\nrootkit inside interrupt handlers also allows it to execute for_ever without violating any watchdog timers. Furthermore,_\n\n\nthe CPU overhead of this shellcode will be distributed across\na large number of random IOS processes. Unlike with shellcodes which take over a specific process, the network administrator can not detect unusual CPU spikes within any\nparticular process using commands like show proc cpu, making it very difficult to detect by conventional means.\n\nThe remainder of this paper is organized as follows: Section\n2 outlines the challenges of reliable IOS rootkit execution\nand provides motivation for the need for version-agnostic\nshellcodes. Section 3 presents a survey of advancements in\nCisco IOS exploitation over the past decade and provides\na timeline of public disclosures of significant vulnerabilities\nand exploitation techniques. Section 4 outlines a general\ntwo-stage attack strategy against unknown Cisco devices.\nSection 5 presents our first reliable IOS shellcode, a disassembling shellcode, which was first proposed by Felix Lindner for PowerPC based Cisco devices. Section 6 presents\nour second reliable IOS shellcode. This shellcode hijacks all\ninterrupt handler routines within the victim device, and is\nfaster, stealthier and more reliable than our first shellcode.\nExperimental data, performance, overhead and reliability\nmeasurements are presented in Section 8. Potential defenses\nagainst our proposed shellcodes are discussed in Section 9.\nConcluding remarks are presented in Section 10. Lastly, the\nfull source code of both shellcodes are listed in Appendix A.\n\nPlease note that the remainder of this paper will focus on\nMIPS-based Cisco IOS. All code examples will be shown in\nMIPS. However, the techniques presented can be applied to\nPowerPC, ARM and even x86-based systems.\n\n### 2. MOTIVATION\nSeveral recent studies demonstrate that there are vast numbers of unsecured, vulnerable embedded devices on the Internet [8], such devices are vulnerable to the same types of\nattacks as general purpose computers [3, 11], and can be\nsystematically exploited in much the same way [1, 3, 5].\nFor example, various exploitable vulnerabilities [13, 12] and\nrootkits [14] have been found and disclosed for Cisco’s flagship system, IOS. Cisco devices running IOS constitutes a\nsignificant portion of our global communication infrastructure, and are deployed within critical areas of our residential,\ncommercial, financial, government, military and backbone\nnetworks.\n\nTypical of the embedded security landscape, IOS is an aging system which does not employee standard protection\nschemes found within modern operating systems [14], and\ndoes not have any host-based anti-virus to speak of. In fact,\nnot only is the installation of third-party anti-virus (which\ndoes not yet exist for IOS) not possible via any published OS\ninterface, any attempt to do so will also violate the vendor’s\nEULA and thus void existing support contracts.\n\nConsider the availability of proof-of-concept exploits and\nrootkits, the wide gamut of high-value targets which can be\ncompromised by the exploitation of devices like routers and\nfirewalls, and the lack of host-based defenses within closesource embedded device firmwares. Such conditions should\nmake the vast numbers of vulnerable embedded devices on\nthe Internet highly attractive targets. Indeed, we have observed successful attempts to create botnets using Linux\n\n-----\n\nbased home routers [4]. As Section 3 shows, the necessary\ntechniques of exploiting Cisco IOS and installing root-kits\non running Cisco routers are well understood. However, an\nobstacle still stands in the way of reliable large-scale exploitation of Cisco devices: firmware diversity.\n\nAs Felix Lindner and others have pointed out [12], there\nare over 300,000 unique versions of Cisco IOS. Diverse hardware platforms, overlapping feature-sets, cryptography export laws, licensing agreements and varying compilation and\nbuild procedures all contribute to create an operating environment that is highly diverse. Although unintentional and\nnot strictly a defense mechanism, this firmware diversity has\nmade the deployment of reliable attacks and shellcodes difficult in practice. Therefore, in order for IOS exploitation\nto be feasible and practical, reliable shellcode that operate\ncorrectly across large populations of IOS versions is needed.\n\nAs Lindner demonstrates [12], certain common features within\nCisco routers can be used to improve the chances of reliable execution of IOS shellcode. The disassembling shellcode concept was proposed in the same work. Building off\nthis insight, we first tested the reliability of the proposed disassembling shellcode. While this technique works smoothly\nacross all versions of IOS for several major hardware platforms, it failed on all versions of IOS for several popular platforms, including the Cisco 2800 series routers. Furthermore,\nits computational complexity frequently triggered watchdog\ntimer exceptions, which logs a clear trace of the shellcode.\nSection 5 discusses the reason for this failure, and several\nother drawbacks of this disassembling approach.\n\nLooking to improve reliability and performance, we constructed a different shellcode by leveraging a common invariant of not only Cisco IOS, but all embedded systems,\n_interrupt handler routines. Hijacking interrupt handlers is_\nadvantageous for several reasons. First, such routines can\nbe identified by a single 32-bit instruction, eret, or excep_tion return._ The search for a single eret instruction reduces the computational complexity of the first-stage shellcode. Whereas the disassembling shellcode frequently causes\nwatchdog timer exceptions on busy routers (See Section 5),\nthe interrupt-handler hijacking first-stage shellcode executes\nquickly enough to avoid such timer exceptions, even on heavily utilized routers. Second, there are approximately two\ndozen interrupt handler routines on any IOS image, all of\nwhich are clustered around a common memory range. By\nusing offline analysis of large numbers of IOS images, we can\nsafely reduce the memory range searched by the first-stage\nshellcode to a small fraction of IOS’s .text section, further\nimproving the efficiency of the shellcode (See Figures 8 and\n9).\n\nAs our experimental data shows, the two proposed shellcodes, along with our proposed data exfiltration mechanism\npresented in Section 7, combined with available vulnerabilities of Cisco IOS makes the large-scale of Cisco routers feasible. Weaponizing the techniques presented in this paper\nto create worms which target routers is possible, and can\nseriously damage the Internet substrate. Therefore, the development of advanced host-based defense mechanisms to\nmitigate such techniques should now be considered a necessity. Section 9 discusses potential host-based defenses for\n\n\nCisco IOS and other similar embedded devices.\n\n### 3. RELATED WORK\nA timeline of significant advancements in offensive technologies against Cisco IOS is listed below.\n\n**FX, 2003: FX analyzes several IOS vulnerabilities and var-**\nious exploitation techniques [11].\n**Lynn, 2005: Lynn described several IOS shellcode and ex-**\nploitation techniques, demonstrating VTY binding shellcode [13].\n**Lynn, 2005: Cisco and ISS Inc. files injunction against Michael**\nLynn [2].\n**Uppal, 2007: Uppal releases IOS Bind shellcode v1.0 [16].**\n**Davis, 2007: Davis releases IOS FTP server remote exploit**\ncode [10].\n**Muniz: 2008 Muniz releases DIK (Da IOS rootKit) [14].**\n**FX, 2009: FX demonstrates IOS diversity, demonstrates**\nreliable disassembling shellcode and reliable execution\nmethods involving ROMMON [12].\n**Muniz and Ortega, 2011: Muniz and Ortega releases GDB**\nsupport for the Dynamips IOS emulator, and demonstrates fuzzing attacks against IOS [15].\n\nThe techniques presented in this paper extend the above line\nof work by introducing novel methods of constructing reliable IOS shellcodes and stealthy exfiltration, making largescale exploitation feasible across all IOS-based devices.\n\n### 4. TWO-STAGE ATTACK STRATEGY\nSections 5 and 6 discusses two reliable shellcode techniques.\nUnlike existing IOS shellcodes, these two examples are designed to work in a two-phase attack. Figure 1 illustrates\nthe attack process. In general, this attack first computes a\nseries of memory locations which the second-stage shellcode\nwill intercept to obtain minimal rootkit capability. This\nseries of memory locations is also exfiltrated back to the attacker after the first-stage rootkit finishes execution. Using\nthis information as a host fingerprint, the attacker queries\na database of pre-computed fingerprints for all known IOS\nimages to determine the exact micro-version of firmware running on the victim router. Once this is known, a version specific rootkit can be constructed automatically, then loaded\nonto the victim router via the rootkit installed by the firststage shellcode.\n\nEach shellcode computes a different set of features. In the\ncase of the disassembling shellcode, a 2-tuple is computed;\nthe address of an invariant string and the address of the\npassword authentication function. In the case of the interrupt hijacking shellcode, a n-tuple is exfiltrated, containing\na list of memory address for all interrupt handler routines\non the victim device. Section 8 will discuss how accurately\neach feature-set can uniquely identify the micro-version of\nthe victim IOS environment.\n\nAs the demonstration videos [7] show, the two shellcodes\npresented in this paper are tested using standard IOS images with an artificially introduced vulnerability allowing\narbitrary memory modification and code execution. More\n\n\n-----\n\nB: xref A: str\n\n|f|f_c B|Col3|B: xref|Col5|Col6|\"%Ba A: str|\n|---|---|---|---|---|---|---|\n||||.text|||.data|\n||||||||\n\n\n#### .text .data\n\n\n**Figure 2: The disassembling shellcode first locates a**\n**known string (A), then locates a xref to this string**\n**(B). Once this xref location is found, the attacker**\n**can patch the function containing the xref.** **This**\n**shellcode requires two linear scans of IOS memory,**\n**one through the .data section, and a second one**\n**through the .text section.**\n\nspecifically, the shellcodes are tested with a simple code\nloader which overwrites the IOS command ”show call filter component”. The efficacy of both shellcodes is tested\non both Dynamips emulations and physical Cisco hardware.\nDuring the development and testing process, Muniz and Ortega’s GDB patch [15] for Dynamips as well as a custom\nGDB proxy for physical Cisco devices were used.\n\n\n### 5. SHELLCODE #1: DISASM SHELLCODE\nFirst proposed by Felix Lindner [12] for PowerPC-based\nrouters, the disassembling shellcode scans the victim router’s\nmemory twice in order to locate and patch a target function\nbased on some functional invariant, and works as follows:\n\n**A. Find String Addr: Scan through memory, looking for**\na specific string pattern. For example, ‘%Bad Secrets’.\n**B. Find String-Xref: With the string’s memory location**\nknown, construct the instruction which loads this address. Rescan through memory, looking for code which\nreferences this string.\n**C. Patch Function: The data reference is located within**\nthe function we wish to find. Search within this function for the desired intercept point. For example, the\nfunction entry point, or a specific branch instruction.\n\n\nAny function which prints a predictable string can be identified and patched in this manner. A particularly useful\nfunction is the credential verification function, which prints\n‘%Bad Secrets’ when the wrong enable password is entered\n3 times.\n\nFigure 3 shows the disassembly of this function. We can\nbypass password authentication by overwriting a single move\ninstruction, highlighted in red.\n\nAs experimental results in Section 8 shows, this first-stage\nshellcode reliably disables password authentication for all\nversions of Cisco 7200 and 3600 IOS images tested. However,\nit failed for all Cisco 2800 series IOS images.\n\nIn general, this type of disassembling shellcode is suitable for\nfinding direct data references, and will fail to find indirect\nreferences. Indirect references can be identified at the price\n\n\n**Figure 3: A disassembly of a typical f chkpasswd.**\n**The string xref is the first highlighted block.** **The**\n**second highlighted block is the single instruction**\n**which can disable password authentication in IOS.**\n**While these addresses vary greatly, they can be re-**\n**liably computed at exploitation time by the disas-**\n**sembling shellcode.**\n\nof computational complexity. In the case of Cisco routers,\nthis limit is a very practical one. A watchdog timer constantly monitors every process within IOS, terminating any\nprocess running for longer than several seconds.[1] As Figure\n11 shows, our implementation of the disassembling shellcode\nfrequently caused watchdog timer exceptions to be thrown,\nleaving clear evidence of the attack in the router’s logs.\n\nOnce the first-stage completes execution, the attacker can\nconnect to the victim router with level 15 privilege, bypassing authentication. The attacker can then identify the exact\nIOS version by a number of methods by using the router’s\nadministrative interface. While this backdoor gives the attacker persistent control of the device, it is not covert. Section 6 shows our interrupt hijack shellcode, which installs an\nequivalent backdoor through a covert channel, using payloads of IP packets punted[2] to the router’s CPU. In our\ndemonstration, we use a large collection of arbitrary UDP\nand ICMP packets to load complex rootkits into the router’s\nmemory.\n\nThe video demonstration of the disassembling shellcode running on a Cisco 7204 and 12.4T IOS can be found at [7].\n\n\n### 6. SHELLCODE #2: INTERRUPT HIJACKER\nAs Section 5 showed, the disassembling shellcode can be used\nreliably, at least for several major hardware platforms, to locate and intercept a critical function which handles credential verification in IOS. However, this shellcode must search\nthrough large portions of the router’s memory twice in order to identify the target string reference, and the target\nfunction. This required computation frequently triggered\nthe router’s watchdog timer, leaving evidence of the shellcode in the router’s log. In general, we want to minimize\nthe amount of computation required by the first-stage shell\n1The default watchdog timer value is 2 seconds.\n2A packet is punted to a router’s CPU when it cannot be\nhandled by its linecards, and must be inspected and process\nswitched.\n\n\n-----\n\n**$GP**\n\n|Col1|Col2|Col3|Col4|.text|Col6|Col7|...|Col9|Col10|\n|---|---|---|---|---|---|---|---|---|---|\n|||||||||||\n\n\n##### .text ...\n\n\n**Figure 4: The interrupt hijack shellcode first locates**\n**all eret (exception return) instructions within IOS’s**\n**.text section. The second-stage rootkit is then un-**\n**packed inside the $gp memory area (which is unused**\n**by IOS). All eret instructions, and thus all interrupt**\n**service routines are hooked to invoke the second-**\n**stage code.** **We now have reliable control of the**\n**CPU by intercepting all interrupt handlers of the**\n**victim router.**\n\ncode to evade the watchdog timer, and avoid any perceivable\nCPU spike or performance degradation.\n\n\nindicated by the packet, or jumps the PC to a specified\nlocation. In order to load such packets into the victim\nrouter’s IOMEM, the attacker simply needs to craft IP packets which will be punted to the router’s CPU. Any packets\nwhich must be inspected by the router’s control-plane will\nsuffice.[3] For demonstration purposes, we used a variety of\nUDP and ICMP packets. Such packets need not even be destined to the router’s interface. Various malformed broadcast\nand multicast packets are automatically punted to CPU and\ncopied to the router’s IOMEM region (on the 7200 platform).\n\nWhen the first-stage shellcode completes, the attacker has:\n\n**Host fingerprint: The list of eret addresses is exfiltrated**\nto the attacker, and will uniquely identify the microversion of the victim’s IOS (See Section 8).\n**Perpetual CPU control: The second-stage code, copied**\nto the global-scope memory area, is invoked each time\nan interrupt is serviced by IOS.\n\n\n### 6.1 First-stage shellcode\nThe interrupt hijacking shellcode performs a single scan through\nthe router’s .text section, locating and intercepting the end\nof all interrupt handler routines, and works as follows:\n\n**Unpack second-stage: The second-stage shellcode, which**\ncontains a basic rootkit, is unpacked and copied to\nthe location pointed to by $gp, the general purpose\nregister.\n**Locate ERET instructions: Scan through memory, look-**\ning for all [eret] instructions. All such addresses are\nstored and exfiltrated for offline fingerprinting (See\nSection 7).\n**Intercept all interrupt handler routines: Hijack all in-**\nterrupt handler routines by replacing all eret instructions with the [jr $gp] instruction.\n\n\nWe now present a second-stage rootkit which monitors all\nincoming packet-data entries, or payloads of packets which\nhave been punted to the router’s control-plane for process\nswitching, continuously scanning incoming packets for commands from the attacker. Using the second-stage rootkit\npresented below, the attacker can load and execute arbitrary\ncode by crafting command and control packets in the payload of any IP packet which will be punted to the router’s\nCPU. The attacker can stealthily assemble large programs\nwithin the router’s memory by using a wide spectrum of\ndifferent packet types, like ICMP, DNS, mDNS, etc.\n\nSince we intercept all interrupt handlers, the second-stage\ncode is invoked whenever any interrupt is serviced, including\ntimer interrupts, interrupts from linecards, etc. Therefore,\na very limited amount of computation (under a hundred\ninstructions) can be done inside interrupt handlers without seriously impacting the router’s stability and performance. Figure 5 illustrates a second-stage rootkit that is designed specifically for high-frequency execution within interrupt handlers. Each time the second-stage code is invoked,\nthe rootkit scans through the linked-list of packet data entries located within IOMEM. Figure 6 shows a snapshot of\nthis data structure in IOMEM. Each time the second-stage\ncode is invoked, it scans through a fixed number of packetdata entries, looking for specially marked packets containing\na 32-bit magic number. The number of packet data entries\nscanned at each iteration directly impacts the reliability of\nthis method (See Section 8).\n\nOnce such an entry is found, the second-stage code does the\nfollowing:\n\n**Parse OpCode: Parse the packet data entry, looking for**\na 1-byte opcode, along with a 4-byte target address\nvalue.\n\n3Different router platforms have different packet handling\ncapabilities, trying to reduce the number of packets that\nmust be punted to CPU. However, packets destined to routing processes, like BGP, OSPF, along with ICMP and SNMP\npackets are typically punted to CPU.\n\n\nThe eret, or exception return instruction takes no operands,\nand is represented by the 32-bit value [0x42000018]. As the\nname suggests, eret is the last instruction in any interrupt\nhandler routine, and returns the CPU context back to the\nprevious state before the interrupt was serviced. Once intercepted, any interrupt serviced by the CPU will invoke our\nsecond-stage code, giving us persistent, perpetual control of\nthe CPU to execute our second-stage rootkit.\n\n### 6.2 Second-stage shellcode\nThe second-stage is essentially a simple code loader which\ncontinuously monitors the router’s IOMEM range, looking\nfor incoming packets with a specific format. The secondstage rootkit locates packet payloads marked with a 32-bit\nmagic-number. Such packets contain a 4-byte target address\nvalue, a 1-byte flag and variable length data (up to the MTU\nof the network).\n\nWhen such a packet is found, the second-stage either copies\nthe variable length data to the 4-byte memory location as\n\n\n-----\n\n|ISR #3|...|ISR #N|\n|---|---|---|\n\n\n2nd-stage shellcode: exit\n\n\nISR #3 ... ISR #N\n\n\nISR #1\n\n\neret\n\n\n**Figure 5: Interrupt hijack second-stage rootkit. Each**\n**time any ISR (interrupt service routine) is invoked,**\n**the rootkit will seek through the latest punted pack-**\n**ets within IOMEM for specially crafted command and**\n**control packet payloads.**\n\n**If OpCode = Load: The second-stage code will copy the**\ncontent of the remainder of the packet-data entry to\nthe 4-byte address indicated by the packet.\n**If OpCode = Run: The second-stage code will jump the**\nPC to the target address indicated by the packet.\n\nThe second-stage code is designed to execute with high frequency, but in small bursts. It will execute approximately\n100 instructions each time it is invoked, which allows us to\nscan through several dozen packets before returning control\nof the CPU back to the interrupt handler, and thus the preempted IOS code.\n\nNote that the head of the packet-data linked-list structure\nis located in a well-known address within the IOMEM region, which is mapped to the same virtual-memory address\nregardless of router model or IOS version [6], making this\npacket-scrubbing technique reliable across all IOS versions\non many router platforms.\n\nThe intercept hijacking shellcode has several interesting advantages over existing rootkit techniques. First, the command and control protocol is built into the payload of incoming packets. No specific protocol is required, as long as\nthe packet is punted to the router’s control-plane. This allows the attacker to access the backdoor using a wide gamut\nof packet types, thus evading network-based intrusion detection systems. Hiding the rootkit inside interrupt handlers\nalso allows it to execute forever without violating any watchdog timers. Furthermore, the CPU overhead of this shellcode will be distributed across a large number of random IOS\nprocesses. Unlike with shellcodes which take over a specific\nprocess, the network administrator cannot detect unusual\nCPU spikes within any particular process using commands\nlike show proc cpu, making it very difficult to detect by conventional means.\n\n\nLoad Code\n\nIOMEM Packet\nScrubber\n\nExecute Code\n\n\nISR #2\n\n\n**Figure 6: Highlighted words, left to right, top to bot-**\n**tom.** **1:** **Pointer to previous packet data node.** **2.**\n**Pointer to next packet data node. 3. Exfiltration re-**\n**quest magic pattern. 4. Beginning of next packet data**\n**entry, pointed to by 2.**\n\nThe video demonstration of the interrupt hijack shellcode\nrunning on a Cisco 7204 router and 12.4T IOS can be found\nat [7].\n\n### 7. STEALTHY DATA EXFILTRATION\nAfter the first-stage shellcode completes, it yields a sequence\nof memory addresses where the eret instruction is located.\nAs Section 8 shows, this data can serve as a host fingerprint,\nallowing the attacker to identify the exact micro-version of\nthe victim’s IOS firmware. Several known methods can be\nused to exfiltrate this fingerprint back to the attacker. Note\nthat the entire memory sequence need not be transmitted, as\na simple hash of the data will suffice. The attacker can carry\nout a VTY binding [16] to open a reverse shell back to the\nattacker, or simply use the console connection to generate\nan ICMP packet back to the attacker. Depending on which\nservices are publicly accessible on the router, the attacker\ncan inject the fingerprint data into the server response. For\nexample, the HTTP server’s default HTML can be modified.\n\nThese methods will most likely leave some detectable sideeffect which can trigger standard network intrusion detection\nsystem. We present a new exfiltration technique which modifies the payload content of process-switched packets just\nprior to transmission. The data is exfiltrated using packets\ngenerated by router itself, thus making the detection of this\ncovert channel more difficult.\n\nOnce a packet is punted to the router’s control-plane, it is\ncopied from the network interface hardware to the router’s\nIOMEM region. For efficiency, when such a packet is process switched, the packet-data entry is not copied. Instead,\nthe pointer to this data is simply moved from the router’s\nRX queue to its TX queue. Once there, the packet is scheduled for transmission, then forwarded appropriately. If the\nattacker can modify the contents of the packet-data entry before it is transmitted, such payloads can be used as a vehicle\nfor stealthy exfiltration. Figure 7 illustrates this exfiltration\n\n\n2nd-stage shellcode: init\n\n\n-----\n\n|Col1|Hardware Platform|Sample Size|Reliability|\n|---|---|---|---|\n|xref|7200|76|100%|\n|eret|7200|76|100%|\n|xref|3600|52|100%|\n|eret|3600|52|100%|\n|xref|2800|31|0%|\n|eret|2800|31|100%|\n\n|Col1|2|4|8|16|32|64|\n|---|---|---|---|---|---|---|\n|reliability|0%|0.67%|1.29%|4.67%|5.38%|10.10%|\n\n\nRX Queue TX Queue\n\n2: Packet data\ncopied to IOMEM.\n\nicmp\nrequest Packet Data\n\nicmp\nreply\n\n...magic-pattern...\n\n4: ICMP\n\n{Exfiltrated Data} request\n\nserviced by\nCPU. Packet\n\nInterrupt 3: Shellcode Data linked to\nHijack locates magic- TX Queue.\n\npattern, overwrites\n\nShellcode\n\npayload with\nexfiltrated data.\n\n\n1: Attacker\nsends ICMP\nrequest with\nmagic pattern in\npayload.\n\n|Victim Router|Victim Router|Col3|Col4|\n|---|---|---|---|\n|RX Queue TX Queue 2: Packet data copied to IOMEM. icmp request Packet Data icmp reply ...magic-pattern... 4: ICMP {Exfiltrated Data} request serviced by CPU. Packet Interrupt 3: Shellcode Data linked to Hijack locates magic- TX Queue. pattern, overwrites Shellcode payload with exfiltrated data. 1: Attacker 5: Exfiltrated data sends ICMP Attacker sent via ICMP request with response back to magic pattern in attacker. Win!|RX Queue TX Queue 2: Packet data copied to IOMEM. icmp request Packet Data icmp reply ...magic-pattern... 4: ICMP {Exfiltrated Data} request serviced by CPU. Packet Interrupt 3: Shellcode Data linked to Hijack locates magic- TX Queue. pattern, overwrites Shellcode payload with exfiltrated data.|||\n|||Attacker||\n|request with magic pattern in||||\n\n\nAttacker\n\n\n**Figure** **7:** **Data** **exfiltration** **through** **forwarded**\n**packet payload. 1: The attacker crafts a packet with**\n**a magic pattern in its payload indicating exfiltration**\n**request. 2: Packet payload is copied into a *packet**\n**data* structure. 3: Rootkit locates magic pattern,**\n**overwrites remaining packet with exfiltrated data.**\n**4: Packet is process-switched. The packet data en-**\n**try is linked to the TX queue.** **5:** **The requested**\n**data is sent back to the attacker inside an ICMP**\n**response packet.**\n\nprocess.\n\nThis type of manipulation is highly time-sensitive, as the\nattacker will typically only have a few milliseconds after the\npacket’s arrival to locate and manipulate its payload, before\nthe packet is transmitted. However, since the second-stage\nrootkit is invoked with every interrupt, it can precisely intercept the desired packet before it is placed on the TX\nqueue, allowing the attacker to use the same covert command and control channel for data exfiltration. Section 8\ndiscusses the performance of this exfiltration method. Due\nto the timing constraints of the interrupt hijack shellcode\nand various race conditions related to process-switching and\nCEF, not all exfiltration requests sent by the attacker will\nbe processed. In practice, approximately 10% of exfiltration requests are answered by the rootkit when tested on an\nemulated 7204VXR/NPE-400 router.\n\nThe video demonstration of this exfiltration method can be\nfound at [7].\n\n### 8. EXPERIMENTAL DATA\nThe reliability of the disassembling shellcode, presented in\nSection 5 and the interrupt hijack shellcode, presented in\nSection 6, are shown in Table 1. Three major Cisco router\nplatforms, the 7200, 3600 and 2800 series routers are tested.\nThe two proposed shellcode algorithms are tested against\n159 IOS images, ranging from IOS version 12.0 to 15.\n\n\n**Table 1: Reliability of the disassembling shellcode**\n**and interrupt hijack shellcode when tested on 159**\n**IOS images.**\n\n2 4 8 16 32 64\nreliability 0% 0.67% 1.29% 4.67% 5.38% 10.10%\n\n**Table 2: Reliability of exfiltration mechanism when**\n**the number of packet-data nodes searched per invo-**\n**cation varies. Searching more than 64 nodes caused**\n**the test router to behave erratically.**\n\nThe computational overhead of both shellcodes are shown\nin Figure 10 for a typical 7200 IOS 12.4 image. In some instances, the disassembling shellcode did not terminate in\ntime, which triggered a watchdog timer exception to be\nthrown and logged (See Figure 11). The interrupt hijack\nshellcode consistently completed first-stage execution without triggering any watchdog timer exception.\n\nTable 2 shows the reliability of the exfiltration mechanism\npresented in Section 7, as the number of packet-data nodes\nsearched during each interrupt-driven invocation. The reliability rate is calculated by counting the number of exfiltration requests the rootkit successfully answered out of 150\nICMP requests. Searching more than 64 nodes at each invocation caused the router to behave erratically, sometimes\nleading to crashes.\n\nFigure 8 and 9 shows the distribution of features found by\nthe disassembling shellcode and interrupt hijack shellcode\nrespectively across 159 tested IOS images. Note that while\n\n**Figure 10: CPU utilization of 7204 router during the**\n**first-stage execution of both the disassembling and**\n**intercept hijack shellcodes. Note that the interrupt**\n**hijack shellcode is simpler, requires less CPU and**\n**thus avoids watchdog timer exceptions.**\n\n\n-----\n\n**Figure 8: Distribution of the location of the**\n**password authentication function. This lo-**\n**cation varies greatly across the IOS .text**\n**segment, forcing the disassembling shell-**\n**code to search a large region.**\n\n**Figure 11: CPU intensive shellcodes will be caught**\n**by Cisco’s watchdog timer, which terminates and**\n**logs all long running processes. The disassembling**\n**shellcode, although reliably bypasses password ver-**\n**ification, consistently triggered the watchdog timer,**\n**generating the above logs, which give precise mem-**\n**ory location of the shellcode.**\n\nthe string reference tends to be more widely distributed,\ninterrupt handler routines are typically found in a much\nsmaller area. While the exact location of interrupt handlers still remain unpredictable, this concentration allows\nthe interrupt hijack first-stage shellcode to search through\na relatively small range of memory when compared to the\ndisassembling shellcode.\n\n### 9. DEFENSE\nIn order to categorically mitigate against the offensive techniques described in this paper, host-based defenses must\nbe introduced into the router’s firmware. Since persistent\nrootkits must modify portions of the router’s code, a selfchecksumming mechanism can be injected into IOS to detect and prevent unauthorized modification of IOS itself.\nThis can be generalized to all regions of the router which\nshould remain static during normal operation of the router,\nand can include large portions of the .data, ROMMON, and\n.text sections.\n\n\n**Figure 9: Distribution of the location of eret**\n**instructions over 162 IOS images. These lo-**\n**cations mark the end of all interrupt ser-**\n**vice routines in IOS, and tend to be concen-**\n**trated within a predictable region of IOS.**\n\nSuch a defensive mechanism, called Symbiotic Embedded\nMachines, have been proposed by the authors to solve this\nproblem [9]. We have shown that Symbiotes can be injected\ninto Cisco IOS in a version-agnostic manner to provide continuous integrity validation capability to the host router.\nOur experimental results show that such Symbiotes can detect unauthorized modification to any static region of IOS\nin approximately 300ms. Symbiotic defenses of this type is\nthe focus of ongoing research.\n\n### 10. CONCLUSION\nWe present a two-stage attack strategy against Cisco IOS, as\nwell as two unique multi-stage shellcodes capable of reliable\nexecution within a large collection of IOS images on different hardware platforms. The disassembling shellcode, first\nproposed by Felix Lindner [12] operates by scanning through\nthe router’s memory, looking for a string reference, allowing\nthe attacker to disable authentication on the victim router.\nThe interrupt hijack shellcode injects a second-stage shellcode capable of continuously monitoring incoming punted\npackets for specially crafted command and control packets\nfrom the attacker. The attacker can use this covert backdoor\nby sending a wide gamut of packet types, like ICMP and\nUDP, with specially crafted payloads. In both shellcodes,\nwhen the first-stage completes execution, a host fingerprint\nis computed and exfiltrated back to the attacker. Using this\ndata, the attacker can accurately identify the exact microversion of IOS running on the host router. Using the secondstage rootkit, the attacker can then upload a version specific\nrootkit, which can be pre-made a priori for all IOS images,\nonto the victim router. This two-stage attack scenario allows the attacker to compromise any vulnerable IOS router\nas if the specific version of the firmware is known, bypassing the software diversity hurdle which has obstructed the\nreliable, large-scale rootkit execution within Cisco routers.\n\n### 11. ACKNOWLEDGEMENTS\nThis work was partially supported by DARPA Contract,\nCRASH Program, SPARCHS, FA8750-10-2-0253.\n\n\n-----\n\n### 12. REFERENCES Target Platform Tested IOS versions Size\n\n[1] kaiten.c IRC DDOS Bot. All MIPS (12.0 - 12.4) 200 bytes\nhttp://packetstormsecurity.nl/irc/kaiten.c.\n\n[2] Injunction Against Michael Lynn.\n\n**Table 3: MIPS-based disassembling rootkit statis-**\n\nhttp://www.infowarrior.org/users/rforno/lynn\n**tics.**\n\ncisco.pdf.\n\n[3] The Target Platform Tested IOS versions Size\nEnd of Your Internet: Malware for Home Routers, 2008. All MIPS (12.0 - 12.4) 420 bytes\nhttp://data.nicenamecrew.com/papers/malwareforrouters/paper.txt.\n\n[4] Network Bluepill. Dronebl.org, 2008.\n\n**Table 4: MIPS-based interrupt hijack rootkit statis-**\n\nhttp://www.dronebl.org/blog/8.\n\n**tics.**\n\n[5] New worm can infect home modem/routers.\nAPCMAG.com, 2009.\nhttp://apcmag.com/Content.aspx?id=3687. **APPENDIX**\n\n[6] Vijay Bollapragada, Curtis Murphy, and Russ White. **A.** **DISASSEMBLING SHELLCODE**\nInside cisco ios software architecture. Cisco Press,\n\nSource code is available to reputable researchers upon formal\n\n2000. Demonstration of Hardware Trojans.\n\nrequest.\n\n[7] Ang Cui.\nhttp://www.hacktory.cs.columbia.edu/ios-rootkit.\n\n### B. INTERRUPT HIJACKING SHELLCODE\n\n[8] Ang Cui and Salvatore J. Stolfo. A quantitative\n\nSource code is available to reputable researchers upon formal\n\nanalysis of the insecurity of embedded network\n\nrequest.\n\ndevices: results of a wide-area scan. In Carrie Gates,\nMichael Franz, and John P. McDermott, editors,\n_ACSAC, pages 97–106. ACM, 2010._\n\n[9] Ang Cui and Salvatore J. Stolfo. Defending embedded\nsystems with software symbiotes. In Somesh Jha,\nRobin Sommer, and Christian Kreibich, editors,\n_RAID, volume 6308 of Lecture Notes in Computer_\n_Science, pages 127–130. Springer, 2011._\n\n[10] Andy Davis. Cisco ios ftp server remote exploit. In\n_http://www.securityfocus.com/archive/1/494868, 2007._\n\n[11] Felix ”FX” Lindner. Cisco Vulnerabilities. In In\n_BlackHat USA, 2003._\n\n[12] Felix ”FX” Lindner. Cisco IOS Router Exploitation. In\n_In BlackHat USA, 2009._\n\n[13] Michael Lynn. Cisco IOS Shellcode, 2005. In BlackHat\nUSA.\n\n[14] Sebastian Muniz. Killing the myth of Cisco IOS\nrootkits: DIK, 2008. In EUSecWest.\n\n[15] Sebastian Muniz and Alfredo Ortega. Fuzzing and\nDebugging Cisco IOS, 2011. In Blackhat Europe.\n\n[16] Varun Uppal. Cisco IOS Bind shellcode v1.0. In\n_http://www.exploit-db.com/exploits/13292/, 2007._\n\n|Target Platform|Tested IOS versions|Size|\n|---|---|---|\n|All MIPS|(12.0 - 12.4)|200 bytes|\n\n|Target Platform|Tested IOS versions|Size|\n|---|---|---|\n|All MIPS|(12.0 - 12.4)|420 bytes|\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.usenix.org/legacy/event/woot/tech/final_files/Cui.pdf"
    ],
    "report_names": [
        "Cui.pdf"
    ],
    "threat_actors": [
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716491,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1308867548,
    "ts_modification_date": 1308867548,
    "files": {
        "pdf": "https://archive.orkl.eu/89329e8d50b8b425da91a7990c9efa0c6c5a0287.pdf",
        "text": "https://archive.orkl.eu/89329e8d50b8b425da91a7990c9efa0c6c5a0287.txt",
        "img": "https://archive.orkl.eu/89329e8d50b8b425da91a7990c9efa0c6c5a0287.jpg"
    }
}