{
    "id": "a600abf2-c243-4964-a5fc-e31ab0fcc873",
    "created_at": "2023-01-12T14:59:47.001032Z",
    "updated_at": "2025-03-27T02:05:49.158698Z",
    "deleted_at": null,
    "sha1_hash": "727a5267c4d7b74670c008d1e3218aae888f0ec6",
    "title": "2010-11-16 - ZEROACCESS MALWARE - PART 3- The Device Driver Process Injection Rootkit",
    "authors": "",
    "file_creation_date": "2022-05-27T21:47:04Z",
    "file_modification_date": "2022-05-27T21:47:04Z",
    "file_size": 1148723,
    "plain_text": "# The Device Driver Process Injection Rootkit\n\n**[resources.infosecinstitute.com/zeroaccess-malware-part-3-the-device-driver-process-injection-rootkit/](http://resources.infosecinstitute.com/zeroaccess-malware-part-3-the-device-driver-process-injection-rootkit/)**\n\nReverse engineering\nNovember 16, 2010 by Giuseppe Bonfa\n\n### New SQL Injection Lab!\n\nSkillset Labs walk you through infosec tutorials, step-by-step, with over 30 hands-on\npenetration testing labs available for FREE!\n\n[FREE SQL Injection Labs](https://www.skillset.com/labs/sql-injection?t=sql-trial)\n\n[Skillset Labs](https://www.skillset.com/labs/sql-injection?t=sql-trial)\n\n[Part 1: Introduction and De-Obfuscating and Reversing the User-Mode Agent Dropper](https://resources.infosecinstitute.com/step-by-step-tutorial-on-reverse-engineering-malware-the-zeroaccessmaxsmiscer-crimeware-rootkit/)\n\n[Part 2: Reverse Engineering the Kernel-Mode Device Driver Stealth Rootkit](https://resources.infosecinstitute.com/zeroaccess-malware-part-2-the-kernel-mode-device-driver-stealth-rootkit/)\n\n**Part 3: Reverse Engineering the Kernel-Mode Device Driver Process Injection Rootkit**\n\n[Part 4:Tracing the Crimeware Origins by Reversing the Injected Code](https://resources.infosecinstitute.com/zeroaccess-malware-part-4-tracing-the-crimeware-origins-by-reversing-injected-code/)\n\nLet’s now take a look at the second driver dropped by the agent. This driver allows for\nZeroAccess to inject arbitrary code into the process space of other processes. Here are the\nhashes of this driver:\n\nFileSize: 8.00 KB (8192 bytes)\nMD5: 799CFC0F0F028789201A0B86F06DE38F\nSHA-1: 1023B17201063E72D41746EFF8D9447ECF109736\nNo VersionInfo Available.\nNo Resources Available.\n\nAs with the first driver, in this case we see the presence of debugging symbols upon\ndisassembly, here is a view of the call graph:\n\n\n-----\n\nDriverEntry() essentially installs a callback. This causes the graph to misrepresent the true\ncode execution flow, due to the fact that a NotifyRoutine represenst an indirect calling\nsystem. Keep in mind that we have a piece of code actually present that’s not visible. Lets\ndisassemble the first code block:\n\n\n-----\n\nPsSetLoadImageNotifyRoutine registers a driver-supplied callback that is subsequently\nnotified whenever an image is loaded for execution.\n\nNTSTATUS PsSetLoadImageNotifyRoutine( IN PLOAD_IMAGE_NOTIFY_ROUTINE\n_NotifyRoutine );_\n\nParameters\n\n_NotifyRoutine_\n\nSpecifies the entry point of the caller-supplied load-image callback.\n\nAfter such a driver’s callback has been registered, the system calls its load-image notify\nroutine whenever an executable image is mapped into virtual memory. This occurs whether\nin kernel space or user space, and before the execution of the image begins.\n\nTo be able to correctly analyze this callback we need to know the prototype of a generic\nNotifyRoutine:\n\nVOID\n\n(*PLOAD_IMAGE_NOTIFY_ROUTINE) (\n\n\n-----\n\nIN PUNICODE_STRING FullImageName,\n\nIN HANDLE ProcessId, // where image is mapped\n\nIN PIMAGE_INFO ImageInfo\n\n);\n\nThe_IMAGE_INFO struct contains information about the loaded image.\n\nThis is an interesting piece of code, here we have an APC (Asynchronous Procedure Call)\nroutine. An APC found in a rootkit is usually used to inject malicious code into victim\nprocesses.\n\nThe APC allows user programs and system components to execute code in the context of a\nparticular thread and, therefore, within the address space of a particular process. We have\ntwo possible cases of APC usage: user-mode based (which will work if thread is placed in\n\n\n-----\n\nalertable status) and kernel-mode ones that can be of two types, regular or special.\n\nIn our case, since we are in a device driver, the APC is managed by using KeInitializeApc()\nand KeInsertQueueApc() functions.\n\nNTKERNELAPI\n\nVOID\n\nKeInitializeApc (\n\nIN PRKAPC Apc,\n\nIN PKTHREAD Thread,\n\nIN KAPC_ENVIRONMENT Environment,\n\nIN PKKERNEL_ROUTINE KernelRoutine,\n\nIN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,\n\nIN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,\n\nIN KPROCESSOR_MODE ApcMode,\n\nIN PVOID NormalContext\n\n);\n\nAnd\n\nBOOLEAN\nKeInsertQueueApc(\nPKAPC Apc,\nPVOID SystemArgument1,\nPVOID SystemArgument2,\n\nUCHAR mode);\n\nThe APC mechanism is poorly documented and kernel APIs to use them are not public (no\nprototype presence in the DDK) so here we will give some more in depth explaination to\nwell clarify how APC works.\n\nKeInitializeApc: As the name suggests, this function is used to initialize an APC Object,\nfrom function parameters you can see that we have a KAPC struct easly uncoverable by\nusing the method seen at beginning of the post:\n\n\n-----\n\nkd> dt nt!_KAPC\n\n+0x000 Type : UChar\n\n+0x001 SpareByte0 : UChar\n\n+0x002 Size : UChar\n\n+0x003 SpareByte1 : UChar\n\n+0x004 SpareLong0 : Uint4B\n\n+0x008 Thread : Ptr32 _KTHREAD\n\n+0x00c ApcListEntry : _LIST_ENTRY\n\n+0x014 KernelRoutine : Ptr32\n\n+0x018 RundownRoutine : Ptr32\n\n+0x01c NormalRoutine : Ptr32\n\n+0x020 NormalContext : Ptr32 Void\n\n+0x024 SystemArgument1 : Ptr32 Void\n\n+0x028 SystemArgument2 : Ptr32 Void\n\n+0x02c ApcStateIndex : Char\n\n+0x02d ApcMode : Char\n\n+0x02e Inserted : Uchar\n\nBy watching successive function parameters you can see that the essential scope of this\nfunction is to initialize KAPC struct.\n\nCalling KeInitializeApc does not schedule the APC yet: it just fills the members of the\n_KAPC, sets the Type field to a constant value (0x12) which identifies this structure as a\n_KAPC and the Size field to 0x30. Take a look into the ZeroAccess rootkit code\nExAllocatePool, it is exactly 0x30, and is the first parameter.The KernelRoutine parameter is\na pointer to a routine that will be called once APC is dispatched. NormalRoutine considered\nin combination with ApcMode will tell us what kind of APC is requested, so let’s take a look\nto rootkit code:\n\n100010E1 mov eax, [ebp+ImageInfo]\n100010E7 push dword ptr [eax+4]\n\n\n-----\n\nThis means that NormalRoutine is non-zero in combination with ApcMode which is 1. We\ncan correctly say that this is a user mode APC, which will therefore call the NormalRoutine\nin user mode.\nRundown Routine: This routine must reside in kernel memory and is only called when the\nsystem needs to discard the contents of the APC queues, such as when the thread exits.\n\nOnce the APC object is completely initialized, device drivers call KeInsertQueueApc to\nplace the APC Object in the target thread’s corresponding APC Queue.\n\n[Further details about APC Internals can be found HERE](http://www.opening-windows.com/techart_windows_vista_apc_internals.htm)\n\nNow let’s study what happens in KernelRoutine:\n\nInitially we have an IRQL Synchronization. KeGetCurrentIrql returns a KIRQL that contains\nthe actual IRQL in which is running the current thread. Next via KfLowerIrql, we see a move\nto the new IRQL.ZwAllocateVirtualMemory commits and reserves a region of pages within\nuser-mode virtual address space of the specified process. Let’s take a look at the next code\nblock:\n\n\n-----\n\nIf allocation fails, execution jumps to IRQL Restore Routine ( via KfRaiseIrql ) and then\nexits. Otherwise we have a memcpy that copies 0x180 bytes from sub_10001338 to\nallocated memory. Note that space is allocated with PAGE_EXECUTE_READWRITE\nprotection, meaning that the call copied by memcpy can be executed.\n\nDue to the fact that this memory commit has EXECUTE rights we need to analyze the block\nof data as if it were a block of code, because it will be executed once placed into the\naddress space of another process. Once reached via xRefs we have to force conversion\nfrom data to code. Moving forward:\n\n\n-----\n\nOur assumptions were correct, as you can see this is a piece of executable code. We also\nat 1000134E a subtle trick to prevent reverse engineering and static analysis, more opcode\nscission.\n\nNow let’s move our point of view from code to hex dump:\n\nAs you can see from hex dump, after the starting code (in green) we have a a string marked\nby red rectangle, we have already seen this string, behavior is now clear. This device driver\ninjects the malicious DLL max++.00.x86 into victim process address space.\n\n\n-----\n\nNext step is logically to discover what this dll does.\n\n## __The Weakness__\n\nWhile this driver is made to be very stealthy, we can apply some forensic techniques to\ndiscover a weakness in the stealth technology employed by this driver. The main weakness\nof this driver is given by PsSetLoadImageNotifyRoutine. It essentially registers a Callback\nvia ExAllocateCallBack, a mechanism that is very transparent and easy to find. Existing\ncallbacks can be reveled by scanning all slots that hosts PEX_CALLBACK_FUNCTION\ntype. To inspect these Slots we can use again KernelDetective.\n\nImageLoad registered Callback of an Unknown Module as should be clear, is really suspect,\nthis is a strong evidence of rootkit infection.\n\nNext up, in part 4 we can [trace the Crimeware Origins by reversing the injected code!](https://resources.infosecinstitute.com/zeroaccess-malware-part-4-tracing-the-crimeware-origins-by-reversing-injected-code/)\n\nPosted: November 16, 2010\n\nAuthor\n\n**Giuseppe Bonfa**\n\n**VIEW PROFILE**\nGiuseppe is a security researcher for InfoSec Institute and a seasoned InfoSec professional\nin reverse-engineering and development with 10 years of experience under the Windows\nplatforms. He is currently deeply focused on Malware Reversing (Hostile Code and Extreme\nPackers) especially Rootkit Technology and Windows Internals. He has previously worked\nas Malware Analyst for Comodo Security Solutions as a member of the most known\nReverse Engineering Teams and is currently a consultant for private customers in the field\nof Device Driver Development, Malware Analysis and Development of Custom Tools for\nDigital Forensics. He collaborates with Malware Intelligence and Threat Investigation\n\n\n-----\n\norganizations and has even discovered vulnerabilities in PGP and Avast Antivirus Device\nDrivers. As a technical author, Giuseppe has over 10 years of experience and hundreds of\npublished pieces of research.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2010/2010-11-16 - ZEROACCESS MALWARE - PART 3- The Device Driver Process Injection Rootkit.pdf"
    ],
    "report_names": [
        "2010-11-16 - ZEROACCESS MALWARE - PART 3- The Device Driver Process Injection Rootkit.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535587,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1653688024,
    "ts_modification_date": 1653688024,
    "files": {
        "pdf": "https://archive.orkl.eu/727a5267c4d7b74670c008d1e3218aae888f0ec6.pdf",
        "text": "https://archive.orkl.eu/727a5267c4d7b74670c008d1e3218aae888f0ec6.txt",
        "img": "https://archive.orkl.eu/727a5267c4d7b74670c008d1e3218aae888f0ec6.jpg"
    }
}