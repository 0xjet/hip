{
    "id": "563731ec-e1b3-48e1-9e93-d5132fd6d444",
    "created_at": "2023-01-12T15:09:39.311346Z",
    "updated_at": "2025-03-27T02:16:25.52226Z",
    "deleted_at": null,
    "sha1_hash": "997a6e29e5c9d0f2d225976264e4abb70e04af75",
    "title": "2021-05-17 - VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture",
    "authors": "",
    "file_creation_date": "2022-05-29T01:33:35Z",
    "file_modification_date": "2022-05-29T01:33:35Z",
    "file_size": 830545,
    "plain_text": "# VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture\n\n**back.engineering/17/05/2021/**\n\nMay 17, 2021\n\ncalendar May 17, 2021\n\nclock 68 min read\ntag [VMProtect-2](https://back.engineering/tags/vmprotect-2/) [Obfuscation](https://back.engineering/tags/obfuscation/)\ncodepen Author(s): [_xeroxz](https://back.engineering/researchers/_xeroxz/)\n[Download link: VMProtect 2 Reverse Engineering](https://githacks.org/vmp2)\n\n## Table Of Contents\n\nCredit - Links to Existing Work\nTerminology\nIntroduction\nvmtracer - Tracing Virtual Instructions\nvmprofile-cli - Static Analysis Using Runtime Traces\nDisplaying Trace Information - vmprofiler-qt\nVirtual Machine Behavior\nDemo - Creating and Inspecting A Virtual Trace\nAltering Virtual Instruction Results\nEncoding Virtual Instructions - Inverse Transformations\nConclusion - Static Analysis, Dynamic Analysis\n\n## Credit - Links to Existing Work\n\n Preamble - Intentions and Purpose\n\n\n-----\n\nBefore diving into this post I would like to state a few things in regards to existing VMProtect\n2 work, the purpose of this article, and my intentions, as these seem to become\nmisconstrued and distorted at times.\n\n**Purpose**\n\nAlthough there has been a lot of research already conducted on VMProtect 2, I feel that\nthere is still information which has not been discussed publicly nor enough source code\ndisclosed to the public. The information I am disclosing in this article aims to go beyond\ngeneric architectural analysis but much lower. The level in which one could encode their own\nvirtual machine instructions given a VMProtect’ed binary as well as intercept and alter results\nof virtual instructions with ease. The dynamic analysis discussed in this article is based upon\nexisting work by Samuel Chevet, my dynamic analysis research and vmtracer project is\nsimply an expansion upon his work demonstrated in his presentation “Inside VMProtect”.\n\n**Intentions**\n\nThis post is not intending to cast any negative views upon VMProtect 2, the creator(s) of said\nsoftware or anyone who uses it. I admire the creator(s) who clearly have impressive skills to\ncreate such a product.\n\nThis post has also been created under the impression that everything discussed here has\nmost likely been discovered by private entities, and that I am not the first to find or document\nsuch things about the VMProtect 2 architecture. I am not intending to present this information\nas though it is ground breaking or something that no one else has already discovered, quite\nthe opposite. This is simply a collection of existing information appended with my own\nresearch.\n\nThis being said, I humbly present to you, “VMProtect 2, Detailed Analysis of the Virtual\nMachine Architecture”.\n\n## Terminology\n```\nVIP - Virtual Instruction Pointer, this equivalent to the x86-64 RIP register which contains\n\n```\nthe address of the next instruction to be executed. VMProtect 2 uses the native register RSI\nto hold the address of the next virtual instruction pointer. Thus RSI is equivalent to VIP.\n```\nVSP - Virtual Stack Pointer, this is equivalent to the x86-64 RSP register which contains the\n\n```\naddress of the stack. VMProtect 2 uses the native register RBP to hold the address of the\nvirtual stack pointer. Thus RBP is equivalent to VSP.\n\n\n-----\n\n```\nVM Handler - A routine which contains the native code to execute a virtual instruction. For\n\n```\nexample, the VADD64 instruction adds two values on the stack together and stores the result\nas well as RFLAGS on the stack.\n```\nVirtual Instruction - Also known as “virtual bytecode” is the bytes interpreted by the\n\n```\nvirtual machine and subsequently executed. Each virtual instruction is composed of at least\none or more operands. The first operand contains the opcode for the instruction.\n```\nVirtual Opcode - The first operand of every virtual instruction. This is the vm handler\n\n```\nindex. The size of a VMProtect 2 opcode is always one byte.\n```\nIMM / Immediate Value - A value encoded into a virtual instruction by which operations\n\n```\nare to happen upon, such as loading said value onto the stack or into a virtual register.\nVirtual instructions such as LREG, SREG, and LCONST all have immediate values.\n```\nTransformations - The term “transform” used throughout this post refers specifically to\n\n```\noperations done to decrypt operands of virtual instructions and vm handler table entries.\nThese transformations consist of add, sub, inc, dec, not, neg, shl, shr, ror, rol, and lastly\nBSWAP. Transformations are done with sizes of 1, 2, 4, and 8 bytes. Transformations can\nalso have immediate/constant values associated with them such as “xor rax, 0x123456”, or\n“add rax, 0x123456”.\n\n## Introduction\n\nVMProtect 2 is a virtual machine based x86 obfuscator which converts x86 instructions to a\nRISC, stack machine, instruction set. Each protected binary has a unique set of encrypted\nvirtual machine instructions with unique obfuscation. This project aims to disclose very\nsignificant signatures which are in every single VMProtect 2 binary with the intent to aid in\nfurther research. This article will also briefly discuss different types of VMProtect 2\nobfuscation. All techniques to deobfuscate are tailor specifically to virtual machine routines\nand will not work on generally obfuscated routines, specifically routines which have real\nJCC’s in them.\n\n## Obfuscation - Deadstore, Opaque Branching\n\nVMProtect 2 uses two types of obfuscation for the most part, the first being deadstore, and\nthe second being opaque branching. Throughout obfuscated routines you can see a few\ninstructions followed by a JCC, then another set of instructions followed by another JCC.\nAnother contributing part of opaque branching is random instructions which affect the FLAGS\nregister. You can see these little buggers everywhere. They are mostly bit test instructions,\nuseless compares, as well as set/clear flags instructions.\n\n\n-----\n\n**Opaque Branching Obfuscation Example**\n\nIn this opaque branching obfuscation example I will go over what VMProtect 2 opaque\nbranching looks like, other factors such as the state of rflags, and most importantly how to\ndetermine if you are looking at an opaque branch or a legitimate JCC.\n```\n.vmp0:00000001400073B4 D0 C8         ror   al, 1\n.vmp0:00000001400073B6 0F CA         bswap  edx\n.vmp0:00000001400073B8 66 0F CA        bswap  dx\n.vmp0:00000001400073BB 66 0F BE D2      movsx  dx, dl\n.vmp0:00000001400073BF 48 FF C6        inc   rsi\n.vmp0:00000001400073C2 48 0F BA FA 0F     btc   rdx, 0Fh\n.vmp0:00000001400073C7 F6 D8         neg   al\n.vmp0:00000001400073C9 0F 81 6F D0 FF FF   jno   loc_14000443E\n.vmp0:00000001400073CF 66 C1 FA 04      sar   dx, 4\n.vmp0:00000001400073D3 81 EA EC 94 CD 47   sub   edx, 47CD94ECh\n.vmp0:00000001400073D9 28 C3         sub   bl, al\n.vmp0:00000001400073DB D2 F6         sal   dh, cl\n.vmp0:00000001400073DD 66 0F BA F2 0E     btr   dx, 0Eh\n.vmp0:00000001400073E2 8B 14 38        mov   edx, [rax+rdi]\n\n```\nConsider the above obfuscated code. Notice the JNO branch. If you follow this branch in ida\nand compare the instructions against the instructions after the JNO you can see that the\nbranch is useless as both paths execute the same meaningful instructions.\n```\nloc_14000443E:\n.vmp0:000000014000443E F5           cmc\n.vmp0:000000014000443F 0F B3 CA        btr   edx, ecx\n.vmp0:0000000140004442 0F BE D3        movsx  edx, bl\n.vmp0:0000000140004445 66 21 F2        and   dx, si\n.vmp0:0000000140004448 28 C3         sub   bl, al\n.vmp0:000000014000444A 48 81 FA 38 04 AA 4E  cmp   rdx, 4EAA0438h\n.vmp0:0000000140004451 48 8D 90 90 50 F5 BB  lea   rdx, [rax-440AAF70h]\n.vmp0:0000000140004458 D2 F2         sal   dl, cl\n.vmp0:000000014000445A D2 C2         rol   dl, cl\n.vmp0:000000014000445C 8B 14 38        mov   edx, [rax+rdi]\n\n```\nIf you look close enough you can see that there are a few instructions which are in both\nbranches. It can be difficult to determine what code is deadstore and what code is required,\nhowever if you select a register in ida and look at all the places it is written to prior to the\ninstruction you are looking at, you can remove all of those other writing instructions up until\nthere is a read of said register. Now, back to the example, In this case the following\ninstructions are what matter:\n```\n.vmp0:0000000140004448 28 C3         sub   bl, al\n.vmp0:000000014000445C 8B 14 38        mov   edx, [rax+rdi]\n\n```\nGeneration of these opaque branches makes it so there are duplicate instructions. For each\ncode path there is also more deadstore obfuscation as well as opaque conditions and other\ninstructions that affect RFLAGS\n\n\n-----\n\n**Deadstore Obfuscation Example**\n\nVMProtect 2 deadstore obfuscation adds the most junk to the instruction stream aside from\nopaque bit tests and comparisons. These instructions serve no purpose and can be spotted\nand removed by hand with ease. Consider the following:\n\n\n-----\n\n```\n.vmp0:0000000140004149 66 D3 D7        rcl   di, cl\n.vmp0:000000014000414C 58           pop   rax\n.vmp0:000000014000414D 66 41 0F A4 DB 01   shld  r11w, bx, 1\n.vmp0:0000000140004153 41 5B         pop   r11\n.vmp0:0000000140004155 80 E6 CA        and   dh, 0CAh\n.vmp0:0000000140004158 66 F7 D7        not   di\n.vmp0:000000014000415B 5F           pop   rdi\n.vmp0:000000014000415C 66 41 C1 C1 0C     rol   r9w, 0Ch\n.vmp0:0000000140004161 F9           stc\n.vmp0:0000000140004162 41 58         pop   r8\n.vmp0:0000000140004164 F5           cmc\n.vmp0:0000000140004165 F8           clc\n.vmp0:0000000140004166 66 41 C1 E1 0B     shl   r9w, 0Bh\n.vmp0:000000014000416B 5A           pop   rdx\n.vmp0:000000014000416C 66 81 F9 EB D2     cmp   cx, 0D2EBh\n.vmp0:0000000140004171 48 0F A3 F1      bt   rcx, rsi\n.vmp0:0000000140004175 41 59         pop   r9\n.vmp0:0000000140004177 66 41 21 E2      and   r10w, sp\n.vmp0:000000014000417B 41 C1 D2 10      rcl   r10d, 10h\n.vmp0:000000014000417F 41 5A         pop   r10\n.vmp0:0000000140004181 66 0F BA F9 0C     btc   cx, 0Ch\n.vmp0:0000000140004186 49 0F CC        bswap  r12\n.vmp0:0000000140004189 48 3D 97 74 7D C7   cmp   rax, 0FFFFFFFFC77D7497h\n.vmp0:000000014000418F 41 5C         pop   r12\n.vmp0:0000000140004191 66 D3 C1        rol   cx, cl\n.vmp0:0000000140004194 F5           cmc\n.vmp0:0000000140004195 66 0F BA F5 01     btr   bp, 1\n.vmp0:000000014000419A 66 41 D3 FE      sar   r14w, cl\n.vmp0:000000014000419E 5D           pop   rbp\n.vmp0:000000014000419F 66 41 29 F6      sub   r14w, si\n.vmp0:00000001400041A3 66 09 F6        or   si, si\n.vmp0:00000001400041A6 01 C6         add   esi, eax\n.vmp0:00000001400041A8 66 0F C1 CE      xadd  si, cx\n.vmp0:00000001400041AC 9D           popfq\n.vmp0:00000001400041AD 0F 9F C1        setnle cl\n.vmp0:00000001400041B0 0F 9E C1        setle  cl\n.vmp0:00000001400041B3 4C 0F BE F0      movsx  r14, al\n.vmp0:00000001400041B7 59           pop   rcx\n.vmp0:00000001400041B8 F7 D1         not   ecx\n.vmp0:00000001400041BA 59           pop   rcx\n.vmp0:00000001400041BB 4C 8D A8 ED 19 28 C9  lea   r13, [rax-36D7E613h]\n.vmp0:00000001400041C2 66 F7 D6        not   si\n.vmp0:00000001400041CB 41 5E         pop   r14\n.vmp0:00000001400041CD 66 F7 D6        not   si\n.vmp0:00000001400041D0 66 44 0F BE EA     movsx  r13w, dl\n.vmp0:00000001400041D5 41 BD B2 6B 48 B7   mov   r13d, 0B7486BB2h\n.vmp0:00000001400041DB 5E           pop   rsi\n.vmp0:00000001400041DC 66 41 BD CA 44     mov   r13w, 44CAh\n.vmp0:0000000140007AEA 4C 8D AB 31 11 63 14  lea   r13, [rbx+14631131h]\n.vmp0:0000000140007AF1 41 0F CD        bswap  r13d\n.vmp0:0000000140007AF4 41 5D         pop   r13\n.vmp0:0000000140007AF6 C3           retn\n\n```\n\n-----\n\nLet s start from the top, one instruction at a time. The first instruction at 0x140004149 is RCL\n\n- Rotate Left Carry”. This instruction affects the FLAGS register as well as DI. Lets see the\nnext time DI is referenced. Is it a read or a write? The next reference to DI is the NOT\ninstruction at 0x140004158. NOT reads and writes DI, so far both instructions are valid. The\nnext instruction that references DI is the POP instructions. This is critical as all write’s to RDI\nprior to this POP can be removed from the instruction stream.\n```\n.vmp0:000000014000414C 58           pop   rax\n.vmp0:000000014000414D 66 41 0F A4 DB 01   shld  r11w, bx, 1\n.vmp0:0000000140004153 41 5B         pop   r11\n.vmp0:0000000140004155 80 E6 CA        and   dh, 0CAh\n.vmp0:000000014000415B 5F           pop   rdi\n\n```\nThe next instruction is POP RAX at `0x14000414C . RAX is never written too throughout the`\nentire instruction stream it is only read from. Since it has a read dependency this instruction\ncannot be removed. Moving onto the next instruction, `SHLD - double precision shift left, a`\nwrite dependency on R11, read dependency on BX. The next instruction that references R11\nis the POP R11 at `0x140004153 . We can remove the SHLD instruction as its deadstore.`\n```\n.vmp0:000000014000414C 58           pop   rax\n.vmp0:0000000140004153 41 5B         pop   r11\n.vmp0:0000000140004155 80 E6 CA        and   dh, 0CAh\n.vmp0:000000014000415B 5F           pop   rdi\n\n```\nNow just repeat the process for every single instruction. The end result should look\nsomething like this:\n```\n.vmp0:000000014000414C 58                      pop   rax\n.vmp0:0000000140004153 41 5B                     pop   r11\n.vmp0:000000014000415B 5F                      pop   rdi\n.vmp0:0000000140004162 41 58                     pop   r8\n.vmp0:000000014000416B 5A                      pop   rdx\n.vmp0:0000000140004175 41 59                     pop   r9\n.vmp0:000000014000417F 41 5A                     pop   r10\n.vmp0:000000014000418F 41 5C                     pop   r12\n.vmp0:000000014000419E 5D                      pop   rbp\n.vmp0:00000001400041AC 9D                      popfq\n.vmp0:00000001400041B7 59                      pop   rcx\n.vmp0:00000001400041B7 59                      pop   rcx\n.vmp0:00000001400041CB 41 5E                     pop   r14\n.vmp0:00000001400041DB 5E                      pop   rsi\n.vmp0:0000000140007AF4 41 5D                     pop   r13\n.vmp0:0000000140007AF6 C3                      retn\n\n```\nThis method is not perfect for removing deadstore obfuscation as there is a second POP\nRCX which is missing from this result above. POP and PUSH instructions are special cases\nwhich should not be emitted from the instruction stream as these instructions also change\nRSP. This method for removing deadstore is also only applied to vm_entry and vm handlers.\n\n\n-----\n\nThis cannot be applied to generically obfuscated routines as-is. Again, this method is NOT\ngoing to work on any obfuscated routine, it’s specifically tailored for vm_entry and vm\nhandlers as these routines have no legitimate JCC’s in them.\n\n## Overview - VMProtect 2 Virtual Machine\n\nVirtual instructions are decrypted and interpreted by virtual instruction handlers referred to as\n“vm handlers”. The virtual machine is a RISC based stack machine with scratch registers.\nPrior to vm-entries an encrypted RVA (relative virtual address) to virtual instructions is\npushed onto the stack and all general purpose registers as well as flags are pushed onto the\nstack. The VIP is decrypted, calculated, and loaded into RSI. A rolling decryption key is then\nstarted in RBX and is used to decrypt every single operand of every single virtual instruction.\nThe rolling decryption key is updated by transforming it with the decrypted operand value.\n\n**Rolling Decryption**\n\nVMProtect 2 uses a rolling decryption key. This key is used to decrypt virtual instruction\noperands, which subsequently prevents any sort of hooking, as if any virtual instructions are\nexecuted out of order the rolling decryption key will become invalid causing further\ndecryption of virtual operands to be invalid.\n\n## Native Register Usage\n\n\n-----\n\nDuring execution inside of the virtual machine, some natiive registers are dedicated for the\nvirtual machine mechanisms such as the virtual instruction pointer and virtual stack. In this\nsection I will be discussing these native registers and their uses for the virtual machine.\n\n**Non-Volatile Registers - Registers With Specific Usage**\n\nTo begin, RSI is always used for the virtual instruction pointer. Operands are fetched from the\naddress stored in RSI. The initial value loaded into RSI is done by vm_entry.\n\nRBP is used for the virtual stack pointer, the address stored in RBP is actually the native\nstack memory. RBP is loaded with RSP prior to allocation of scratch registers. This brings us\nto RDI which contains scratch registers. The address in RDI is initialized as well in vm_entry\nand is set to an address landing inside of the native stack.\n\nR12 is loaded with the linear virtual address of the vm handler table. This is done inside of\nvm_entry and throughout the entire duration of execution inside of the virtual machine R12\nwill contain this address.\n\nR13 is loaded with the linear virtual address of the module base address inside of vm_entry\nand is not altered throughout execution inside of the virtual machine.\n\nRBX is a very special register which contains the rolling decryption key. After every\ndecryption of every operand of every virtual instruction RBX is updated by applying a\ntransformation to it with the decrypted operand’s value.\n\n**Volatile Registers - Temp Registers**\n\nRAX, RCX, and RDX are used as temporary registers inside of the virtual machine, however\nRAX is used for very specific temporary operations over the other registers. RAX is used to\ndecrypt operands of virtual instructions, AL specifically is used when decrypting the opcode\nof a virtual instruction.\n\n\n-----\n\n**vm_entry - Entering The Virtual Machine**\n\nvm_entry is a very significant component to the virtual machine architecture. Prior to entering\nthe VM, an encrypted RVA to virtual instructions is pushed onto the stack. This RVA is a four\nbyte value.\n```\n.vmp0:000000014000822C 68 FA 01 00 89     push  0FFFFFFFF890001FAh\n\n```\nAfter this value is pushed onto the stack, a jmp is then executed to start executing vm_entry.\nvm_entry is subjected to obfuscation which I explained in great detail above. By flattening\nand then removing deadstore code we can get a nice clean view of vm_entry.\n\n\n-----\n\n```\n> 0x822c :                  push 0xFFFFFFFF890001FA\n> 0x7fc9 :                  push 0x45D3BF1F\n> 0x48e4 :                  push r13\n> 0x4690 :                  push rsi\n> 0x4e53 :                  push r14\n> 0x74fb :                  push rcx\n> 0x607c :                  push rsp\n> 0x4926 :                  pushfq\n> 0x4dc2 :                  push rbp\n> 0x5c8c :                  push r12\n> 0x52ac :                  push r10\n> 0x51a5 :                  push r9\n> 0x5189 :                  push rdx\n> 0x7d5f :                  push r8\n> 0x4505 :                  push rdi\n> 0x4745 :                  push r11\n> 0x478b :                  push rax\n> 0x7a53 :                  push rbx\n> 0x500d :                  push r15\n> 0x6030 :                  push [0x00000000000018E2]\n> 0x593a :                  mov rax, 0x7FF634270000\n> 0x5955 :                  mov r13, rax\n> 0x5965 :                  push rax\n> 0x596f :                  mov esi, [rsp+0xA0]\n> 0x5979 :                  not esi\n> 0x5985 :                  neg esi\n> 0x598d :                  ror esi, 0x1A\n> 0x599e :                  mov rbp, rsp\n> 0x59a8 :                  sub rsp, 0x140\n> 0x59b5 :                  and rsp, 0xFFFFFFFFFFFFFFF0\n> 0x59c1 :                  mov rdi, rsp\n> 0x59cb :                  lea r12, [0x0000000000000AA8]\n> 0x59df :                  mov rax, 0x100000000\n> 0x59ec :                  add rsi, rax\n> 0x59f3 :                  mov rbx, rsi\n> 0x59fa :                  add rsi, [rbp]\n> 0x5a05 :                  mov al, [rsi]\n> 0x5a0a :                  xor al, bl\n> 0x5a11 :                  neg al\n> 0x5a19 :                  rol al, 0x05\n> 0x5a26 :                  inc al\n> 0x5a2f :                  xor bl, al\n> 0x5a34 :                  movzx rax, al\n> 0x5a41 :                  mov rdx, [r12+rax*8]\n> 0x5a49 :                  xor rdx, 0x7F3D2149\n> 0x5507 :                  inc rsi\n> 0x7951 :                  add rdx, r13\n> 0x7954 :                  jmp rdx\n\n```\nAs expected all registers as well as RFLAGS is pushed to the stack. The last push puts eight\nbytes of zeros on the stack, not a relocation which I first expected. The ordering in which\nthese pushes happen are unique per-build, however the last push of eight zero’s is always\n\n\n-----\n\nthe same throughout all binaries. This is a very stable signature to determine when the end\nof general register pushes is done. Below are the exact sequences of instructions I am\nreferring to in this paragraph.\n```\n> 0x48e4 :                  push r13\n> 0x4690 :                  push rsi\n> 0x4e53 :                  push r14\n> 0x74fb :                  push rcx\n> 0x607c :                  push rsp\n> 0x4926 :                  pushfq\n> 0x4dc2 :                  push rbp\n> 0x5c8c :                  push r12\n> 0x52ac :                  push r10\n> 0x51a5 :                  push r9\n> 0x5189 :                  push rdx\n> 0x7d5f :                  push r8\n> 0x4505 :                  push rdi\n> 0x4745 :                  push r11\n> 0x478b :                  push rax\n> 0x7a53 :                  push rbx\n> 0x500d :                  push r15\n> 0x6030 :                  push [0x00000000000018E2] ; pushes 0’s\n\n```\nAfter all registers and RFLAGS is pushed onto the stack the base address of the module is\nloaded into R13. This happens in every single binary, R13 always contains the base address\nof the module during execution of the VM. The base address of the module is also pushed\nonto the stack.\n```\n> 0x593a :                  mov rax, 0x7FF634270000\n> 0x5955 :                  mov r13, rax\n> 0x5965 :                  push rax\n\n```\nNext, the relative virtual address of the desired virtual instructions to be executed is\ndecrypted. This is done by loading the 32bit RVA into ESI from RSP+0xA0. This is a very\nsignificant signature and can be found trivially. Three transformations are then applied to ESI\nto get the decrypted RVA of the virtual instructions. The three transformations are unique\nper-binary. However, there are always three transformations.\n```\n> 0x596f :                  mov esi, [rsp+0xA0]\n> 0x5979 :                  not esi\n> 0x5985 :                  neg esi\n> 0x598d :                  ror esi, 0x1A\n\n```\nFurthermore, the next notable operation that occurs is space allocated on the stack for\nscratch registers. RSP is always moved to RBP always, then RSP is subtracted by 0x140.\nThen aligned by 16 bytes. After this is done the address is moved into RDI. During the\nexecution of the VM RDI always contains a pointer to scratch registers.\n\n\n-----\n\n```\n> 0x599e :                  mov rbp, rsp\n> 0x59a8 :                  sub rsp, 0x140\n> 0x59b5 :                  and rsp, 0xFFFFFFFFFFFFFFF0\n> 0x59c1 :                  mov rdi, rsp\n\n```\nThe next notable operation is loading the address of the vm handler table into R12. This is\ndone on every single VMProtect 2 binary. R12 always contains the linear virtual address of\nthe vm handler table. This is yet another significant signature which can be used to find the\nlocation of the vm handler table quite trivially.\n```\n> 0x59cb :                  lea r12, [0x0000000000000AA8]\n\n```\nAnother operation is then done on RSI to calculate VIP. Inside of the PE headers, there is a\nheader called the “optional header”. This contains an assortment of information. One of the\nfields is called “ImageBase”. If there are any bits above 32 in this field those bits are then\nadded to RSI. For example, vmptest.vmp.exe ImageBase field contains the value\n0x140000000. Thus 0x100000000 is added to RSI as part of the calculation. If an\nImageBase field contains less than a 32 bit value zero is added to RSI.\n```\n> 0x59df :                  mov rax, 0x100000000\n> 0x59ec :                  add rsi, rax\n\n```\nAfter this addition is done to RSI, a small and somewhat insignificant instruction is executed.\nThis instruction loads the linear virtual address of the virtual instructions into RBX. Now, RBX\nhas a very special purpose, it contains the “rolling decryption” key. As you can see, the first\nvalue loaded into RBX is going to be the address of the virtual instructions themselves! Not\nthe linear virtual address but just the RVA including the top 32bits of the ImageBase field.\n```\n> 0x59f3 :                  mov rbx, rsi\n\n```\nNext, the base address of the vmp module is added to RSI computing the full, linear virtual\naddress of the virtual instructions. Remember that RBP contains the address of RSP prior to\nthe allocation of scratch space. The base address of the module is on the top of the stack at\nthis point.\n```\n> 0x59fa :                  add rsi, [rbp]\n\n```\nThis concludes the details for vm_entry, the next part of this routine is actually referred to as\n“calc_vm_handler” and is executed after every single virtual instruction besides the vm_exit\ninstruction.\n\n## calc_jmp - Decryption Of Vm Handler Index\n\ncalc_jmp is part of the vm_entry routine, however it’s referred to by more than just the\nvm_entry routine. Every single vm handler will eventually jump to calc_jmp (besides\nvm_exit). This snippet of code is responsible for decrypting the opcode of every virtual\n\n\n-----\n\ninstruction as well as indexing into the vm handler table, decrypting the vm handler table\nentry and jumping to the resulting vm handler.\n```\n> 0x5a05 :                  mov al, [rsi]\n> 0x5a0a :                  xor al, bl\n> 0x5a11 :                  neg al\n> 0x5a19 :                  rol al, 0x05\n> 0x5a26 :                  inc al\n> 0x5a2f :                  xor bl, al\n> 0x5a34 :                  movzx rax, al\n> 0x5a41 :                  mov rdx, [r12+rax*8]\n> 0x5a49 :                  xor rdx, 0x7F3D2149\n> 0x5507 :                  inc rsi\n> 0x7951 :                  add rdx, r13\n> 0x7954 :                  jmp rdx\n\n```\nThe first instruction of this snippet of code reads a single byte out of RSI which as you know\nis VIP. This byte is an encrypted opcode. In other words it’s an encrypted index into the vm\nhandler table. There are 5 total transformations which are done. The first transformation is\nalways applied to the encrypted opcode and the value in RBX as the source. This is the\n“rolling encryption” at play. It’s important to note that the first value loaded into RBX is the\nRVA to the virtual instructions. Thus BL will contain the last byte of this RVA.\n```\n> 0x5a05 :                  mov al, [rsi]\n> 0x5a2f :                  xor bl, al ; transformation is unique\nto each build\n\n```\nNext, three transformations are applied to AL directly. These transformations can have\nimmediate values, however there is never another register’s value added into these\ntransformations.\n```\n> 0x5a11 :                  neg al\n> 0x5a19 :                  rol al, 0x05\n> 0x5a26 :                  inc al\n\n```\nThe last transformation is applied to the rolling encryption key stored in RBX. This\ntransformation is the same transformation as the first. However the registers swap places.\nThe end result is the decrypted vm handler index. The value of AL is then zero extended to\nthe rest of RAX.\n```\n> 0x5a2f :                  xor bl, al\n> 0x5a34 :                  movzx rax, al\n\n```\nNow that the index into the vm handler table has been decrypted the vm handler entry itself\nmust be fetched and decrypted. There is only a single transformation applied to these vm\nhandler table entries. No register values are ever used in these transformations. The register\nin which the encrypted vm table entry value is loaded into is always RCX or RDX.\n```\n> 0x5a41 :                  mov rdx, [r12+rax*8]\n> 0x5a49 :                  xor rdx, 0x7F3D2149\n\n```\n\n-----\n\nVIP is now advanced. VIP can be advanced either forward or backwards and the\nadvancement operation itself can be an LEA, INC, DEC, ADD, or SUB instruction.\n```\n> 0x5507 :                  inc rsi\n\n```\nLastly, the base address of the module is added to the decrypted vm handler RVA and a JMP\nis then executed to start executing this vm handler routine. Again RDX or RCX is always\nused for this ADD and JMP. This is another significant signature in the virtual machine.\n```\n> 0x7951 :                  add rdx, r13\n> 0x7954 :                  jmp rdx\n\n```\nThis concludes the calc_jmp code snippet specifications. As you can see there are some\nvery significant signatures which can be found trivially using Zydis. Especially the decryption\ndone on vm handler table entries, and fetching these encrypted values.\n\n## vm_exit - Leaving The Virtual Machine\n\nUnlike vm_entry, vm_exit is quite a straightforward routine. This routine simply POP’s all\nregisters back into place including RFLAGS. There are some redundant POP’s which are\nused to clear the module base, padding, as well as RSP off of the stack since they are not\nneeded. The order in which the pops occur are the inverse of the order in which they are\npushed onto the stack by vm_entry. The return address is calculated and loaded onto the\nstack prior to the vm_exit routine.\n```\n.vmp0:000000014000635F 48 89 EC        mov   rsp, rbp\n.vmp0:0000000140006371 58           pop   rax ; pop module base of the\nstack\n.vmp0:000000014000637F 5B           pop   rbx ; pop zero’s off the stack\n.vmp0:0000000140006387 41 5F         pop   r15\n.vmp0:0000000140006393 5B           pop   rbx\n.vmp0:000000014000414C 58           pop   rax\n.vmp0:0000000140004153 41 5B         pop   r11\n.vmp0:000000014000415B 5F           pop   rdi\n.vmp0:0000000140004162 41 58         pop   r8\n.vmp0:000000014000416B 5A           pop   rdx\n.vmp0:0000000140004175 41 59         pop   r9\n.vmp0:000000014000417F 41 5A         pop   r10\n.vmp0:000000014000418F 41 5C         pop   r12\n.vmp0:000000014000419E 5D           pop   rbp\n.vmp0:00000001400041AC 9D           popfq\n.vmp0:00000001400041B7 59           pop   rcx ; pop RSP off the stack.\n.vmp0:00000001400041BA 59           pop   rcx\n.vmp0:00000001400041CB 41 5E         pop   r14\n.vmp0:00000001400041DB 5E           pop   rsi\n.vmp0:0000000140007AF4 41 5D         pop   r13\n.vmp0:0000000140007AF6 C3           retn\n\n## check_vsp - relocate scratch registers\n\n```\n\n-----\n\nVm handlers which put any new values on the stack will have a stack check after the vm\nhandler executes. This routine checks to see if the stack is encroaching upon the scratch\nregisters.\n```\n.vmp0:00000001400044AA 48 8D 87 E0 00 00 00    lea   rax, [rdi+0E0h]\n.vmp0:00000001400044B2 48 39 C5          cmp   rbp, rax\n.vmp0:000000014000429D 0F 87 5B 17 00 00     ja   calc_jmp\n.vmp0:00000001400042AC 48 89 E2          mov   rdx, rsp\n.vmp0:0000000140005E5F 48 8D 8F C0 00 00 00    lea   rcx, [rdi+0C0h]\n.vmp0:0000000140005E75 48 29 D1          sub   rcx, rdx\n.vmp0:000000014000464C 48 8D 45 80        lea   rax, [rbp-80h]\n.vmp0:0000000140004655 24 F0           and   al, 0F0h\n.vmp0:000000014000465F 48 29 C8          sub   rax, rcx\n.vmp0:000000014000466B 48 89 C4          mov   rsp, rax\n.vmp0:0000000140004672 9C             pushfq\n.vmp0:000000014000467C 56             push  rsi\n.vmp0:0000000140004685 48 89 D6          mov   rsi, rdx\n.vmp0:00000001400057D6 48 8D BC 01 40 FF FF FF  lea   rdi, [rcx+rax-0C0h]\n.vmp0:00000001400051FC 57             push  rdi\n.vmp0:000000014000520C 48 89 C7          mov   rdi, rax\n.vmp0:0000000140004A34 F3 A4           rep movsb\n.vmp0:0000000140004A3E 5F             pop   rdi\n.vmp0:0000000140004A42 5E             pop   rsi\n.vmp0:0000000140004A48 9D             popfq\n.vmp0:0000000140004A49 E9 B0 0F 00 00       jmp   calc_jmp\n\n```\n_Note the usage of “movsb” which is used to copy the contents of the scratch registers._\n\n## Virtual Instructions - Opcodes, Operands, Specifications\n\nVirtual instructions consist of two or more operands. The first operand being the opcode of\nthe virtual instruction. Opcodes are 8bit, unsigned values which when decrypted are the\nindex into the vm handler table. There can be a second operand which is a one to eight byte\nimmediate value.\n\n\n-----\n\nAll operands are encrypted and must be decrypted with the rolling decrypt key. Decryption is\ndone inside of calc_jmp as well as vm handlers themselves. Vm handlers that do decryption\nwill be operating on immediate values only and not an opcode.\n\n## Operand Decryption - Transformations\n\nVMProtect 2 encrypts its virtual instructions using a rolling decryption key. This key is located\nin RBX and is initially set to the address of the virtual instructions. The transformations done\nto decrypt operands consist of XOR, NEG, NOT, AND, ROR, ROL, SHL, SHR, ADD, SUB,\nINC, DEC, and BSWAP. When an operand is decrypted the first transformation applied to the\noperand includes the rolling decryption key. Thus only XOR, AND, ROR, ROL, ADD, and\nSUB are going to be the first transformation applied to the operand. Then, there are always\nthree transformations directly applied to the operand. At this stage, the operand is completely\ndecrypted and the value in RAX will hold the decrypted operand value. Lastly the rolling\ndecryption key is updated by transforming the rolling decryption key with the fully decrypted\noperand value. An example looks like this:\n```\n.vmp0:0000000140005A0A 30 D8         xor   al, bl ; decrypt using rolling\nkey...\n.vmp0:0000000140005A11 F6 D8         neg   al ; 1/3 transformations...\n.vmp0:0000000140005A19 C0 C0 05        rol   al, 5 ; 2/3 transformations...\n.vmp0:0000000140005A26 FE C0         inc   al 3/3 transformations...\n.vmp0:0000000140005A2F 30 C3         xor   bl, al ; update rolling key...\n\n```\nThis above snippet of code decrypts the first operand, which is always the instructions\nopcode. This code is part of the calc_jmp routine, however the transformation format is the\nsame for any second operands.\n\n\n-----\n\n## VM Handlers - Specifications\n\nVM handlers contain the native code to execute virtual instructions. Every VMProtect 2\nbinary has a vm handler table which is an array of 256 QWORD’s. Each entry contains an\nencrypted relative virtual address to the corresponding VM handler. There are many variants\nof virtual instructions such as different sizes of immediate values as well as sign and zero\nextended values. This section will go over a few virtual instruction examples as well as some\nkey information which must be noted when trying to parse VM handlers.\n\n\n-----\n\nVM handlers which handle immediate values fetch the encrypted immediate value from RSI.\nThe traditional five transformations are then applied to this encrypted immediate value. The\ntransformation format follows the same as the calc_jmp transformations. The first\ntransformation is applied to the encrypted immediate value with the rolling decryption key\nbeing the source of the operation. Then three transformations are applied directly to the\nencrypted immediate value, this decrypts the value fully. Lastly the rolling decryption key is\nupdated by doing the first transformation except with the destination and source operands\nswapped.\n\n\n-----\n\n```\n.vmp0:00000001400076D2 48 8B 06        mov   rax, [rsi] ; fetch immediate\nvalue...\n.vmp0:00000001400076D9 48 31 D8        xor   rax, rbx ; rolling key\ntransformation...\n.vmp0:00000001400076DE 48 C1 C0 1D      rol   rax, 1Dh ; 1/3\ntransformations...\n.vmp0:0000000140007700 48 0F C8        bswap  rax ; 2/3 transformations...\n.vmp0:000000014000770F 48 C1 C0 30      rol   rax, 30h ; 3/3\ntransformations...\n.vmp0:0000000140007714 48 31 C3        xor   rbx, rax ; update rolling\nkey...\n\n```\nAlso note that vm handlers are subjected to opaque branching as well as deadstore\nobfuscation.\n\n## LCONST - Load Constant Value Onto Stack\n\nOne of the most iconic virtual machine instructions is LCONST. This virtual instruction loads\na constant value from the second operand of a virtual instruction onto the stack.\n\n**LCONSTQ - Load Constant QWORD**\n\nThis is the deobfuscated view of LCONSTQ VM handler. As you can see this VM handler\nreads the second operand of the virtual instruction out of VIP (RSI). It then decrypts this\nimmediate value and advances VIP. The decrypted immediate value is then put onto the\nVSP.\n```\nmov   rax, [rsi]\nxor   rax, rbx ; transformation\nbswap  rax ; transformation\nlea   rsi, [rsi+8] ; advance VIP…\nrol   rax, 0Ch ; transformation\ninc   rax ; transformation\nxor   rbx, rax ; transformation (update rolling decrypt key)\nsub   rbp, 8\nmov   [rbp+0], rax\n\n```\n**LCONSTCDQE - Load Constant DWORD Sign Extended to a QWORD**\n\nThis virtual instruction loads a DWORD size operand from RSI, decrypts it, and extends it to\na QWORD, finally putting it on the virtual stack.\n\n\n-----\n\n```\nmov   eax, [rsi]\nxor   eax, ebx\nxor   eax, 32B63802h\ndec   eax\nlea   rsi, [rsi+4] ; advance VIP\nxor   eax, 7E4087EEh\n; look below for details on this...\npush  rbx\nxor   [rsp], eax\npop   rbx\ncdqe ; sign extend EAX to RAX…\nsub   rbp, 8\nmov   [rbp+0], rax\n\n```\nNote, this last vm handler updates the rolling decryption key by putting the value on the stack\nthen applying the transformation. This is something that could cause significant problems\nwhen parsing these VM handlers. Luckily there is a very simple trick to handle this, always\nremember that the transformation applied to the rolling key is the same transformation as the\nfirst. In the above case it’s a simple XOR.\n\n**LCONSTCBW - Load Constant Byte Convert To Word**\n\nLCONSTCBW loads a constant byte value from RSI, decrypts it, and zero extends the result\nas a WORD value. This decrypted value is then placed upon the virtual stack.\n```\nmovzx eax, byte ptr [rsi]\nadd al, bl\ninc al\nneg al\nror al, 0x06\nadd bl, al\nmov ax, [rax+rdi*1]\nsub rbp, 0x02\ninc rsi\nmov [rbp], ax\n\n```\n**LCONSTCWDE - Load Constant Word Convert To DWORD**\n\nLCONSTCWDE loads a constant word from RSI, decrypts it, and sign extends it to a\nDWORD. Lastly the resulting value is placed upon the virtual stack.\n\n\n-----\n\n```\nmov ax, [rsi]\nadd rsi, 0x02\nxor ax, bx\nrol ax, 0x0E\nxor ax, 0xA808\nneg ax\nxor bx, ax\ncwde\nsub rbp, 0x04\nmov [rbp], eax\n\n```\n**LCONSTDW - Load Constant DWORD**\n\nLCONSTDW loads a constant dword from RSI, decrypts it, and lastly places the result upon\nthe virtual stack. Also note that VIP advances backwards in the example below. You can see\nthis in the operand fetch as its subtracting from RSI prior to a dereference.\n```\nmov eax, [rsi-0x04]\nbswap eax\nadd eax, ebx\ndec eax\nneg eax\nxor eax, 0x2FFD187C\npush rbx\nadd [rsp], eax\npop rbx\nsub rbp, 0x04\nmov [rbp], eax\nadd rsi, 0xFFFFFFFFFFFFFFFC\n\n## LREG - Load Scratch Register Value Onto Stack\n\n```\nLet’s look at another VM handler, this one by the name of LREG. Just like LCONST there are\nmany variants of this instruction, especially for different sizes. LREG is also going to be in\nevery single binary as it’s used inside of the VM to load register values into scratch registers.\nMore on this later.\n\n**LREGQ - Load Scratch Register QWORD**\n\nLREGQ has a one byte immediate value. This is the scratch register index. A pointer to\nscratch registers is always loaded into RDI. As described above many times, there are five\ntotal transformations applied to the immediate value to decrypt it. The first transformation is\napplied from the rolling decryption key, followed by three transformations applied directly to\nthe immediate value which fully decrypts it. Lastly the rolling decryption key is updated by\napplying the first transformation on it with the decrypted immediate value as the source.\n\n\n-----\n\n```\nmov   al, [rsi]\nsub   al, bl\nror   al, 2\nnot   al\ninc   al\nsub   bl, al\nmov   rdx, [rax+rdi]\nsub   rbp, 8\nmov   [rbp+0], rdx\ninc   rsi\n\n```\n**LREGDW - Load Scratch Register DWORD**\n\nLREGDW is a variant of LREG which loads a DWORD from a scratch register onto the stack.\nIt has two operands, the second being a single byte representing the scratch register index.\nThe snippet of code below is a deobfuscated view of LREGDW.\n```\nmov   al, [rsi]\nsub   al, bl\nadd   al, 97h\nror   al, 1\nneg   al\nsub   bl, al\nmov   edx, [rax+rdi]\nsub   rbp, 4\nmov   [rbp+0], edx\n\n## SREG - Set Scratch Register Value\n\n```\nAnother iconic virtual instruction which is in every single binary is SREG. There are many\nvariants to this instruction which set scratch registers to certain sizes values. This virtual\ninstruction has two operands, the second being a single byte immediate value containing the\nscratch register index.\n\n**SREGQ - Set Scratch Register Value QWORD**\n\nSREGQ sets a virtual scratch register with a QWORD value from on top of the virtual stack.\nThis virtual instruction consists of two operands, the second being a single byte representing\nthe virtual scratch register.\n\n\n-----\n\n```\nmovzx  eax, byte ptr [rsi]\nsub   al, bl\nror   al, 2\nnot   al\ninc   al\nsub   bl, al\nmov   rdx, [rbp+0]\nadd   rbp, 8\nmov   [rax+rdi], rdx\n\n```\n**SREGDW - Set Scratch Register Value DWORD**\n\nSREGDW sets a virtual scratch register with a DWORD value from on top of the virtual\nstack. This virtual instruction consists of two operands, the second being a single byte\nrepresenting the virtual scratch register.\n```\nmovzx eax, byte ptr [rsi-0x01]\nxor al, bl\ninc al\nror al, 0x02\nadd al, 0xDE\nxor bl, al\nlea rsi, [rsi-0x01]\nmov dx, [rbp]\nadd rbp, 0x02\nmov [rax+rdi*1], dx\n\n```\n**SREGW - Set Scratch Register Value WORD**\n\nSREGW sets a virtual scratch register with a WORD value from on top of the virtual stack.\nThis virtual instruction consists of two operands, the second being a single byte representing\nthe virtual scratch register.\n```\nmovzx eax, byte ptr [rsi-0x01]\nsub al, bl\nror al, 0x06\nneg al\nrol al, 0x02\nsub bl, al\nmov edx, [rbp]\nadd rbp, 0x04\ndec rsi\nmov [rax+rdi*1], edx\n\n```\n**SREGB - Set Scratch Register Value Byte**\n\n\n-----\n\nSREGB sets a virtual scratch register with a BYTE value from on top of the virtual stack. This\nvirtual instruction consists of two operands, the second being a single byte representing the\nvirtual scratch register.\n```\nmov al, [rsi-0x01]\nxor al, bl\nnot al\nxor al, 0x10\nneg al\nxor bl, al\nsub rsi, 0x01\nmov dx, [rbp]\nadd rbp, 0x02\nmov [rax+rdi*1], dl\n\n## ADD - Add Two Values\n\n```\nThe virtual ADD instruction adds two values on the stack together and stores the result in the\nsecond value position on the stack. RFLAGS is then pushed onto the stack as the ADD\ninstruction alters RFLAGS.\n\n**ADDQ - Add Two QWORD Values**\n\nADDQ adds two QWORD values stored on top of the virtual stack. RFLAGS is also pushed\nonto the stack as the native ADD instruction alters flags.\n```\nmov   rax, [rbp+0]\nadd   [rbp+8], rax\npushfq\npop   qword ptr [rbp+0]\n\n```\n**ADDW - Add Two WORDS Values**\n\nADDW adds two WORD values stored on top of the virtual stack. RFLAGS is also pushed\nonto the stack as the native ADD instruction alters flags.\n```\nmov ax, [rbp]\nsub rbp, 0x06\nadd [rbp+0x08], ax\npushfq\npop [rbp]\n\n```\n**ADDB - Add Two Bytes Values**\n\nADDB adds two BYTE values stored on top of the virtual stack. RFLAGS is also pushed onto\nthe stack as the native ADD instruction alters flags\n\n\n-----\n\n```\nmov al, [rbp]\nsub rbp, 0x06\nadd [rbp+0x08], al\npushfq\npop [rbp]\n\n## MUL - Unsigned Multiplication\n\n```\nThe virtual MUL instruction multiples two values stored on the stack together. These vm\nhandlers use the native MUL instruction, additionally RFLAGS is pushed onto the stack.\nLastly, it is a single operand instruction which means there is no immediate value associated\nwith this instruction.\n\n**MULQ - Unsigned Multiplication of QWORD’s**\n\nMULQ multiples two QWORD values together, the result is stored on the stack at VSP+24,\nadditionally RFLAGS is pushed onto the stack.\n```\nmov rax, [rbp+0x08]\nsub rbp, 0x08\nmul rdx\nmov [rbp+0x08], rdx\nmov [rbp+0x10], rax\npushfq\npop [rbp]\n\n## DIV - Unsigned Division\n\n```\nThe virtual DIV instruction uses the native DIV instruction, the top operands used in division\nare located on top of the virtual stack. This is a single operand virtual instruction thus there is\nno immediate value. RFLAGS is also pushed onto the stack as the native DIV instruction can\nalso RFLAGS.\n\n**DIVQ - Unsigned Division Of QWORD’s**\n\nDIVQ divides two QWORD values located on the virtual stack. Push RFLAGS onto the stack.\n```\nmov rdx, [rbp]\nmov rax, [rbp+0x08]\ndiv [rbp+0x10]\nmov [rbp+0x08], rdx\nmov [rbp+0x10], rax\npushfq\npop [rbp]\n\n```\n\n-----\n\n## READ - Read Memory\n\nThe READ instruction reads memory of different sizes. There is a variant of this instruction to\nread one, two, four, and eight bytes.\n\n**READQ - Read QWORD**\n\nREADQ reads a QWORD value from the address stored on top of the stack. This virtual\ninstruction seems to sometimes have a segment prepended to it. However not all READQ\nvm handlers have this `ss associated with it. The QWORD value is now stored on top of the`\nvirtual stack.\n```\nmov rax, [rbp]\nmov rax, ss:[rax]\nmov [rbp], rax\n\n```\n**READDW - Read DWORD**\n\nREADDW reads a DWORD value from the address stored on top of the virtual stack. The\nDWORD value is then put on top of the virtual stack. Below are two examples of READDW,\none which uses this segment index syntax and the other without it.\n```\nmov rax, [rbp]\nadd rbp, 0x04\nmov eax, [rax]\nmov [rbp], eax\n\n```\n_Note the segment offset usage below with_ `ss …`\n```\nmov rax, [rbp]\nadd rbp, 0x04\nmov eax, ss:[rax]\nmov [rbp], eax\n\n```\n**READW - Read Word**\n\nREADW reads a WORD value from the address stored on top of the virtual stack. The\nWORD value is then put on top of the virtual stack. Below is an example of this vm handler\nusing a segment index syntax however keep in mind there are vm handlers without this\nsegment index.\n```\nmov rax, [rbp]\nadd rbp, 0x06\nmov ax, ss:[rax]\nmov [rbp], ax\n\n```\n\n-----\n\n## WRITE - Write Memory\n\nThe WRITE virtual instruction writes up to eight bytes to an address. There are four variants\nof this virtual instruction, one for each power of two up to and including eight. There are also\nversions of each vm handler which use a segment offset type instruction encoding. However\nin longmode some segment base addresses are zero. The segment that seems to always be\nused is the SS segment which has the base of zero thus the segment base has no effect\nhere, it simply makes it a little more difficult to parse these vm handlers.\n\n**WRITEQ - Write Memory QWORD**\n\nWRITEQ writes a QWORD value to the address located on top of the virtual stack. The stack\nis incremented by 16 bytes.\n```\n.vmp0:0000000140005A74 48 8B 45 00      mov   rax, [rbp+0]\n.vmp0:0000000140005A82 48 8B 55 08      mov   rdx, [rbp+8]\n.vmp0:0000000140005A8A 48 83 C5 10      add   rbp, 10h\n.vmp0:00000001400075CF 48 89 10        mov   [rax], rdx\n\n```\n**WRITEDW - Write DWORD**\n\nWRITEDW writes a DWORD value to the address located on top of the virtual stack. The\nstack is incremented by 12 bytes.\n```\nmov rax, [rbp]\nmov edx, [rbp+0x08]\nadd rbp, 0x0C\nmov [rax], edx\n\n```\n_Note the segment offset_ `ss usage below…`\n```\nmov rax, [rbp]\nmov edx, [rbp+0x08]\nadd rbp, 0x0C\nmov ss:[rax], edx ; note the SS usage here...\n\n```\n**WRITEW - Write WORD**\n\nThe WRITEW virtual instruction writes a WORD value to the address located on top of the\nvirtual stack. The stack is then incremented by ten bytes.\n```\nmov rax, [rbp]\nmov dx, [rbp+0x08]\nadd rbp, 0x0A\nmov ss:[rax], dx\n\n```\n\n-----\n\n**WRITEB - Write Byte**\n\nThe WRITEB virtual instruction writes a BYTE value to the address located on top of the\nvirtual stack. The stack is then incremented by ten bytes.\n```\nmov rax, [rbp]\nmov dl, [rbp+0x08]\nadd rbp, 0x0A\nmov ss:[rax], dl\n\n## SHL - Shift Left\n\n```\nThe SHL vm handler shifts a value located on top of the stack to the left by a number of bits.\nThe number of bits to shift is stored above the value to be shifted on the stack. The result is\nthen put onto the stack as well as RFLAGS.\n\n**SHLCBW - Shift Left Convert Result To WORD**\n\nSHLCBW shifts a byte value to the left and zero extends the result to a WORD. RFLAGS is\npushed onto the stack.\n```\nmov   al, [rbp+0]\nmov   cl, [rbp+2]\nsub   rbp, 6\nshl   al, cl\nmov   [rbp+8], ax\npushfq\npop   qword ptr [rbp+0]\n\n```\n**SHLW - Shift Left WORD**\n\nSHLW shifts a WORD value to the left. RFLAGS is pushed onto the virtual stack.\n```\nmov ax, [rbp]\nmov cl, [rbp+0x02]\nsub rbp, 0x06\nshl ax, cl\nmov [rbp+0x08], ax\npushfq\npop [rbp]\n\n```\n**SHLDW - Shift Left DWORD**\n\nSHLDW shifts a DWORD to the left. RFLAGS is pushed onto the virtual stack.\n\n\n-----\n\n```\nmov eax, [rbp]\nmov cl, [rbp+0x04]\nsub rbp, 0x06\nshl eax, cl\nmov [rbp+0x08], eax\npushfq\npop [rbp]\n\n```\n**SHLQ - Shift Left QWORD**\n\nSHLQ shifts a QWORD to the left. RFLAGS is pushed onto the virtual stack.\n```\nmov rax, [rbp]\nmov cl, [rbp+0x08]\nsub rbp, 0x06\nshl rax, cl\nmov [rbp+0x08], rax\npushfq\npop [rbp]\n\n## SHLD - Shift Left Double Precision\n\n```\nThe SHLD virtual instruction shifts a value to the left using the native instruction SHLD. The\nresult is then put onto the stack as well as RFLAGS. There is a variant of this instruction for\none, two, four, and eight byte shifts.\n\n**SHLDQ - Shift Left Double Precision QWORD**\n\nSHLDQ shifts a QWORD to the left with double precision. The result is then put onto the\nvirtual stack and RFLAGS is pushed onto the virtual stack.\n```\nmov rax, [rbp]\nmov rdx, [rbp+0x08]\nmov cl, [rbp+0x10]\nadd rbp, 0x02\nshld rax, rdx, cl\nmov [rbp+0x08], rax\npushfq\npop [rbp]\n\n```\n**SHLDDW - Shift Left Double Precision DWORD**\n\nThe SHLDDW virtual instruction shifts a DWORD value to the left with double precision. The\nresult is pushed onto the virtual stack as well as RFLAGS.\n\n\n-----\n\n```\nmov eax, [rbp]\nmov edx, [rbp+0x04]\nmov cl, [rbp+0x08]\nsub rbp, 0x02\nshld eax, edx, cl\nmov [rbp+0x08], eax\npushfq\npop [rbp]\n\n## SHR - Shift Right\n\n```\nThe SHR instruction is the complement to SHL, this virtual instruction alters RFLAGS and\nthus the RFLAGS value will be on the top of the stack after executing this virtual instruction.\n\n**SHRQ - Shift Right QWORD**\n\nSHRQ shifts a QWORD value to the right. The result is put onto the virtual stack as well as\nRFLAGS.\n```\nmov rax, [rbp]\nmov cl, [rbp+0x08]\nsub rbp, 0x06\nshr rax, cl\nmov [rbp+0x08], rax\npushfq\npop [rbp]\n\n## SHRD - Double Precision Shift Right\n\n```\nThe SHRD virtual instruction shifts a value to the right with double precision. There is a\nvariant of this instruction for one, two, four, and eight byte shifts. The virtual instruction\nconcludes with RFLAGS being pushed onto the virtual stack.\n\n**SHRDQ - Double Precision Shift Right QWORD**\n\nSHRDQ shifts a QWORD value to the right with double precision. The result is put onto the\nvirtual stack. RFLAGS is then pushed onto the virtual stack.\n```\nmov rax, [rbp]\nmov rdx, [rbp+0x08]\nmov cl, [rbp+0x10]\nadd rbp, 0x02\nshrd rax, rdx, cl\nmov [rbp+0x08], rax\npushfq\npop [rbp]\n\n```\n\n-----\n\n**SHRDDW - Double Precision Shift Right DWORD**\n\nSHRDDW shifts a DWORD value to the right with double precision. The result is put onto the\nvirtual stack. RFLAGS is then pushed onto the virtual stack.\n```\nmov eax, [rbp]\nmov edx, [rbp+0x04]\nmov cl, [rbp+0x08]\nsub rbp, 0x02\nshrd eax, edx, cl\nmov [rbp+0x08], eax\npushfq\npop [rbp]\n\n## NAND - Not Then And\n\n```\nThe NAND instruction consists of a not being applied to the values on top of the stack,\nfollowed by the result of this not being bit wise and’ed to the next value on the stack. The and\ninstruction alters RFLAGS thus, RFLAGS will be pushed onto the virtual stack.\n\n**NANDW - Not Then And WORD’s**\n\nNANDW NOT’s two WORD values then bitwise AND’s them together. RFLAGs is then\npushed onto the virtual stack.\n```\nnot dword ptr [rbp]\nmov ax, [rbp]\nsub rbp, 0x06\nand [rbp+0x08], ax\npushfq\npop [rbp]\n\n## READCR3 - Read Control Register Three\n\n```\nThe READCR3 virtual instruction is a wrapper vm handler around the native `mov reg,`\n```\ncr3 . This instruction will put the value of CR3 onto the virtual stack.\nmov rax, cr3\nsub rbp, 0x08\nmov [rbp], rax\n\n## WRITECR3 - Write Control Register Three\n\n```\n\n-----\n\nThe WRITECR3 virtual instruction is a wrapper vm handler around the native `mov cr3,`\n```\nreg . This instruction will put a value into CR3.\nmov rax, [rbp]\nadd rbp, 0x08\nmov cr3, rax\n\n## PUSHVSP - Push Virtual Stack Pointer\n\n```\nPUSHVSP virtual instruction pushes the value contained in native register RBP onto the\nvirtual stack stack. There is a variant of this instruction for one, two, four, and eight bytes.\n\n**PUSHVSPQ - Push Virtual Stack Pointer QWORD**\n\nPUSHVSPQ pushes the entire value of the virtual stack pointer onto the virtual stack.\n```\nmov rax, rbp\nsub rbp, 0x08\nmov [rbp], rax\n\n```\n**PUSHVSPDW - Push Virtual Stack Pointer DWORD**\n\nPUSHVSPDW pushes the bottom four bytes of the virtual stack pointer onto the virtual stack.\n```\nmov eax, ebp\nsub rbp, 0x04\nmov [rbp], eax\n\n```\n**PUSVSPW - Push Virtual Stack Pointer WORD**\n\nPUSVSPW pushes the bottom WORD value of the virtual stack pointer onto the virtual stack.\n```\nmov eax, ebp\nsub rbp, 0x02\nmov [rbp], ax\n\n## LVSP - Load Virtual Stack Pointer\n\n```\nThis virtual instruction loads the virtual stack pointer register with the value at the top of the\nstack.\n```\nmov rbp, [rbp]\n\n```\n**LVSPW - Load Virtual Stack Pointer Word**\n\n\n-----\n\nThis virtual instruction loads the virtual stack pointer register with the WORD value at the top\nof the stack.\n```\nmov bp, [rbp]\n\n```\n**LVSPDW - Load Virtual Stack Pointer DWORD**\n\nThis virtual instruction loads the virtual stack pointer register with the DWORD value at the\ntop of the stack.\n```\nmov ebp, [rbp]\n\n## LRFLAGS - Load RFLAGS\n\n```\nThis virtual instruction loads the native flags register with the QWORD value at the top of the\nstack.\n```\npush [rbp]\nadd rbp, 0x08\npopfq\n\n## JMP - Virtual Jump Instruction\n\n```\nThe virtual JMP instruction changes the RSI register to point to a new set of virtual\ninstructions. The value at the top of the stack is the lower 32bits of the RVA from the module\nbase to the virtual instructions. This value is then added to the top 32bits of the image base\nvalue found in the optional header of the PE file. The base address is then added to this\nvalue.\n```\nmov esi, [rbp]\nadd rbp, 0x08\nlea r12, [0x0000000000048F29]\nmov rax, 0x00 ; image base bytes above 32bits...\nadd rsi, rax\nmov rbx, rsi ; update decrypt key\nadd rsi, [rbp] ; add module base address\n\n## CALL - Virtual Call Instruction\n\n```\nThe virtual call instruction takes an address of the top of the virtual stack and then calls it.\nRDX is used to hold the address so you can only really call functions with a single parameter\nusing this.\n\n\n-----\n\n```\nmov rdx, [rbp]\nadd rbp, 0x08\ncall rdx\n\n## Significant Virtual Machine Signatures - Static Analysis\n\n```\nNow that VMProtect 2’s virtual machine architecture has been documented, we can reflect\non the significant signatures. In addition, the obfuscation that VMProtect 2 generates can\nalso be handled with quite simple techniques. This can make parsing the vm_entry routine\ntrivial. vm_entry has no legit JCC’s so everytime we encounter a JCC we can simply follow it,\nremove the JCC from the instruction stream, then stop once we hit a JMP RCX/RDX. We can\nremove most deadstore by following how an instruction is used with Zydis, specifically\ntracking read and write dependencies on the destination register of an instruction. Finally\nwith the cleaned up vm_entry we can now iterate through all of the instructions and find vm\nhandlers, transformations required to decrypt vm handler table entries, and lastly the\ntransformations required to decrypt the relative virtual address to the virtual instructions\npushed onto the stack prior to jumping to vm_entry.\n\n**Locating VM Handler Table**\n\nOne of the best, and most well known signatures is LEA r12, vm_handlers. This instruction is\nlocated inside of the vm_entry snippet of code and loads the linear virtual address of the vm\nhandler table into R12. Using Zydis we can easily locate and parse this LEA to locate the vm\nhandler table ourselves.\n\n\n-----\n\n```\nstd::uintptr_t vm::handler::table::get(const zydis_routine_t& vm_entry)\n{\n  const auto result = std::find_if(\n    vm_entry.begin(), vm_entry.end(),\n    [](const zydis_instr_t& instr_data) -> bool\n    {\n      const auto instr = &instr_data.instr;\n      // lea r12, vm_handlers... (always r12)...\n      if (instr->mnemonic == ZYDIS_MNEMONIC_LEA &&\n        instr->operands[0].type == ZYDIS_OPERAND_TYPE_REGISTER &&\n        instr->operands[0].reg.value == ZYDIS_REGISTER_R12 &&\n        !instr->raw.sib.base) // no register used for the sib base...\n        return true;\n      return false;\n    }\n  );\n  if (result == vm_entry.end())\n    return nullptr;\n  std::uintptr_t ptr = 0u;\n  ZydisCalcAbsoluteAddress(&result->instr,\n    &result->instr.operands[1], result->addr, &ptr);\n  return reinterpret_cast<std::uintptr_t*>(ptr);\n}\n\n```\nThe above Zydis routine will locate the address of the VM handler table statically. It only\nrequires a vector of ZydisDecodedInstructions, one for each instruction in the vm_entry\nroutine. My implementation of this (vmprofiler) will deobfuscate vm_entry first then pass\naround this vector.\n\n**Locating VM Handler Table Entry Decryption**\n\nYou can easily, programmatically determine what transformation is applied to VM handler\ntable entries by first locating the instruction which fetches entries from said table. This\ninstruction is documented in the vm_entry section, it consists of a SIB instruction with RDX or\nRCX as the destination, R12 as the base, RAX as the index, and eight as the scale.\n```\n.vmp0:0000000140005A41 49 8B 14 C4      mov   rdx, [r12+rax*8]\n\n```\nThis is easily located using Zydis. All that must be done is locate a SIB mov instruction with\nRCX, or RDX as the destination, R12 as the base, RAX as the index, and lastly eight as the\nindex. Now, using Zydis we can find the next instruction with RDX or RCX as the destination,\nthis instruction will be the transformation applied to VM handler table entries.\n\n\n-----\n\n```\nbool vm::handler::table::get_transform(\n  const zydis_routine_t& vm_entry, ZydisDecodedInstruction* transform_instr)\n{\n  ZydisRegister rcx_or_rdx = ZYDIS_REGISTER_NONE;\n  auto handler_fetch = std::find_if(\n    vm_entry.begin(), vm_entry.end(),\n    [&](const zydis_instr_t& instr_data) -> bool\n    {\n      const auto instr = &instr_data.instr;\n      if (instr->mnemonic == ZYDIS_MNEMONIC_MOV &&\n        instr->operand_count == 2 &&\n        instr->operands[1].type == ZYDIS_OPERAND_TYPE_MEMORY &&\n        instr->operands[1].mem.base == ZYDIS_REGISTER_R12 &&\n        instr->operands[1].mem.index == ZYDIS_REGISTER_RAX &&\n        instr->operands[1].mem.scale == 8 &&\n        instr->operands[0].type == ZYDIS_OPERAND_TYPE_REGISTER &&\n        (instr->operands[0].reg.value == ZYDIS_REGISTER_RDX ||\n          instr->operands[0].reg.value == ZYDIS_REGISTER_RCX))\n      {\n        rcx_or_rdx = instr->operands[0].reg.value;\n        return true;\n      }\n      return false;\n    }\n  );\n  // check to see if we found the fetch instruction and if the next instruction\n  // is not the end of the vector...\n  if (handler_fetch == vm_entry.end() || ++handler_fetch == vm_entry.end() ||\n    // must be RCX or RDX... else something went wrong...\n    (rcx_or_rdx != ZYDIS_REGISTER_RCX && rcx_or_rdx != ZYDIS_REGISTER_RDX))\n    return false;\n  // find the next instruction that writes to RCX or RDX...\n  // the register is determined by the vm handler fetch above...\n  auto handler_transform = std::find_if(\n    handler_fetch, vm_entry.end(),\n    [&](const zydis_instr_t& instr_data) -> bool\n    {\n      if (instr_data.instr.operands[0].reg.value == rcx_or_rdx &&\n        instr_data.instr.operands[0].actions & ZYDIS_OPERAND_ACTION_WRITE)\n        return true;\n      return false;\n    }\n  );\n  if (handler_transform == vm_entry.end())\n    return false;\n  *transform_instr = handler_transform->instr;\n  return true;\n}\n\n```\n\n-----\n\nThis function will parse the vm_entry routine and return the transformation done to decrypt\nVM handler table entries. In C++ each transformation operation can be implemented in\nlambdas and a single function can be coded to return the corresponding lambda routine for\nthe transformation that must be applied.\n```\n.vmp0:0000000140005A41 49 8B 14 C4      mov   rdx, [r12+rax*8]\n.vmp0:0000000140005A49 48 81 F2 49 21 3D 7F  xor   rdx, 7F3D2149h\n\n```\nThe above code is equivalent to the below C++ code. This will decrypt vm handler entries. To\nencrypt new values an inverse operation must be done. However for XOR that is simply\nXOR.\n```\nvm::decrypt_handler _decrypt_handler = \n  [](std::uint8_t idx) -> std::uint64_t \n{\n  return vm_handlers[idx] ^ 0x7F3D2149;\n};\n// this is not the best example as the inverse of XOR is XOR...\nvm::encrypt_handler _encrypt_handler = \n  [](std::uint8_t idx) -> std::uint64_t \n{\n  return vm_handlers[idx] ^ 0x7F3D2149;\n};\n\n## Handling Transformations - Templated Lambdas and Maps\n\n```\nThe above decrypt and encrypt handlers can be dynamically generated by creating a map of\neach transformation type and a C++ lambda reimplementation of this instruction.\nFurthermore a routine to handle dynamic values such as byte sizes can be created. This\nprevents a switch case from being created every single time a transformation is required.\n\n\n-----\n\n```\nnamespace transform\n{\n  // ...\n  template <class T>\n  inline std::map<ZydisMnemonic, transform_t<T>> transforms =\n  {\n    { ZYDIS_MNEMONIC_ADD, _add<T> },\n    { ZYDIS_MNEMONIC_XOR, _xor<T> },\n    { ZYDIS_MNEMONIC_BSWAP, _bswap<T> },\n    // SUB, INC, DEC, OR, AND, ETC...\n  };\n  // max size of a and b is 64 bits, a and b is then converted to \n  // the number of bits in bitsize, the transformation is applied,\n  // finally the result is converted back to 64bits...\n  inline auto apply(std::uint8_t bitsize, ZydisMnemonic op,\n    std::uint64_t a, std::uint64_t b) -> std::uint64_t\n  {\n    switch (bitsize)\n    {\n    case 8:\n      return transforms<std::uint8_t>[op](a, b);\n    case 16:\n      return transforms<std::uint16_t>[op](a, b);\n    case 32:\n      return transforms<std::uint32_t>[op](a, b);\n    case 64:\n      return transforms<std::uint64_t>[op](a, b);\n    default:\n      throw std::invalid_argument(\"invalid bit size...\");\n    }\n  }\n  // ...\n}\n\n```\nThis small snippet of code will allow for easy implementation of transformations in C++ with\noverflows in mind. It’s very important that sizes are respected during transformation as\nwithout correct size overflows as well as rolls and shifts will be incorrect. The below code is\nan example of how to decrypt operands of a virtual instruction by implementing the\ntransformation in C++ dynamically.\n\n\n-----\n\n```\n// here for your eyes better understanding of the code : )\nusing map_t = std::map<transform::type, ZydisDecodedInstruction>;\nauto decrypt_operand(transform::map_t& transforms, \n  std::uint64_t operand, std::uint64_t rolling_key) -> std::pair<std::uint64_t,\nstd::uint64_t>\n{\n  const auto key_decrypt = &transforms[transform::type::rolling_key];\n  const auto generic_decrypt_1 = &transforms[transform::type::generic1];\n  const auto generic_decrypt_2 = &transforms[transform::type::generic2];\n  const auto generic_decrypt_3 = &transforms[transform::type::generic3];\n  const auto update_key = &transforms[transform::type::update_key];\n  // apply transformation with rolling decrypt key...\n  operand = transform::apply(key_decrypt->operands[0].size,\n    key_decrypt->mnemonic, operand, rolling_key);\n  // apply three generic transformations...\n  {\n    operand = transform::apply(\n      generic_decrypt_1->operands[0].size,\n      generic_decrypt_1->mnemonic, operand, \n      // check to see if this instruction has an IMM...\n      transform::has_imm(generic_decrypt_1) ? \n        generic_decrypt_1->operands[1].imm.value.u : 0);\n    operand = transform::apply(\n      generic_decrypt_2->operands[0].size,\n      generic_decrypt_2->mnemonic, operand,\n      // check to see if this instruction has an IMM...\n      transform::has_imm(generic_decrypt_2) ?\n        generic_decrypt_2->operands[1].imm.value.u : 0);\n    operand = transform::apply(\n      generic_decrypt_3->operands[0].size,\n      generic_decrypt_3->mnemonic, operand,\n      // check to see if this instruction has an IMM...\n      transform::has_imm(generic_decrypt_3) ?\n        generic_decrypt_3->operands[1].imm.value.u : 0);\n  }\n  // update rolling key...\n  rolling_key = transform::apply(key_decrypt->operands[0].size,\n    key_decrypt->mnemonic, rolling_key, operand);\n  return { operand, rolling_key };\n}\n\n```\n**Extracting Transformations - Static Analysis Continued**\n\nThe ability to reimplement transformations is important, however, being able to parse the\ntransformations out of vm handlers and calc_jmp is another problem to be solved by itself. In\norder to determine where transformations are we must first determine if there is a need for\n\n\n-----\n\ntransformations. Transformations are only applied to operands of virtual instructions. The first\noperand of a virtual instruction is always transformed in the same place, this code is known\nas calc_jmp which I explained earlier. The second place which transforms will be found is\ninside of vm handlers which handle immediate values. In other words if a virtual instruction\nhas an immediate value there will be a unique set of transformations for that operand.\nImmediate values are read out of VIP (RSI) so we can use this key detail to determine if\nthere is an immediate value as well as the size of the immediate value. It’s important to note\nthat the immediate value read out of VIP does not always equal the size allocated for the\ndecrypted value on the stack for instructions such as LCONST. This is because of sign\nextended and zero extended virtual instructions. Let’s examine an example virtual instruction\nwhich has an immediate value. This virtual instruction is called LCONSTWSE which stands\nfor “load constant value of size word but sign extended to a DWORD”. The deobfuscated vm\nhandler for this virtual instruction looks like so:\n```\n.vmp0:0000000140004478 66 0F B7 06      movzx  ax, word ptr [rsi]\n.vmp0:0000000140004412 66 29 D8        sub   ax, bx\n.vmp0:0000000140004416 66 D1 C0        rol   ax, 1\n.vmp0:0000000140004605 66 F7 D8        neg   ax\n.vmp0:000000014000460A 66 35 AC 21      xor   ax, 21ACh\n.vmp0:000000014000460F 66 29 C3        sub   bx, ax\n.vmp0:0000000140004613 98           cwde\n.vmp0:0000000140004618 48 83 ED 04      sub   rbp, 4\n.vmp0:0000000140006E4F 89 45 00        mov   [rbp+0], eax\n.vmp0:0000000140007E2D 48 8D 76 02      lea   rsi, [rsi+2]\n\n```\nAs you can see there are two bytes read out of VIP. It’s the first instruction. This is something\nwe can look for in zydis. Any MOVZX, MOVSX, or MOV where RAX is the destination and\nRSI is the source shows that there is an immediate value and thus we know that five\ntransformations are expected in the instruction stream. We can then search for an instruction\nwhere RAX is the destination and RBX is the source. This will be the first transformation. In\nthe above example, the first subtraction instruction is what we are looking for.\n```\n.vmp0:0000000140004412 66 29 D8        sub   ax, bx\n\n```\nNext we can look for three instructions which have a write dependency on RAX. These three\ninstructions will be the generic transformations applied to the operand.\n```\n.vmp0:0000000140004416 66 D1 C0        rol   ax, 1\n.vmp0:0000000140004605 66 F7 D8        neg   ax\n.vmp0:000000014000460A 66 35 AC 21      xor   ax, 21ACh\n\n```\nAt this point the operand is completely decrypted. The only thing left is a single\ntransformation done to the rolling decryption key (RBX). This last transformation updates the\nrolling decryption key.\n```\n.vmp0:000000014000460F 66 29 C3        sub   bx, ax\n\n```\n\n-----\n\nAll of these transformation instructions can now be re-implemented by C++ lambdas on the\nfly. Using std::find_if is very useful for these types of searching algorithms as you can take it\none step at a time. First locate the key transformations, then find the next three instructions\nwhich write to RAX.\n\n\n-----\n\n```\nbool vm::handler::get_transforms(const zydis_routine_t& vm_handler, transform::map_t&\ntransforms)\n{\n  auto imm_fetch = std::find_if(\n    vm_handler.begin(), vm_handler.end(),\n    [](const zydis_instr_t& instr_data) -> bool\n    {\n      // mov/movsx/movzx rax/eax/ax/al, [rsi]\n      if (instr_data.instr.operand_count > 1 &&\n        (instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOV ||\n          instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOVSX ||\n          instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOVZX) &&\n        instr_data.instr.operands[0].type == ZYDIS_OPERAND_TYPE_REGISTER &&\n        util::reg::compare(instr_data.instr.operands[0].reg.value,\nZYDIS_REGISTER_RAX) &&\n        instr_data.instr.operands[1].type == ZYDIS_OPERAND_TYPE_MEMORY &&\n        instr_data.instr.operands[1].mem.base == ZYDIS_REGISTER_RSI)\n        return true;\n      return false;\n    }\n  );\n  if (imm_fetch == vm_handler.end())\n    return false;\n  // this finds the first transformation which looks like:\n  // transform rax, rbx <--- note these registers can be smaller so we to64 them...\n  auto key_transform = std::find_if(imm_fetch, vm_handler.end(),\n    [](const zydis_instr_t& instr_data) -> bool\n    {\n      if (util::reg::compare(instr_data.instr.operands[0].reg.value,\nZYDIS_REGISTER_RAX) &&\n        util::reg::compare(instr_data.instr.operands[1].reg.value,\nZYDIS_REGISTER_RBX))\n        return true;\n      return false;\n    }\n  );\n  // last transformation is the same as the first except src and dest are\nswapped...\n  transforms[transform::type::rolling_key] = key_transform->instr;\n  auto instr_copy = key_transform->instr;\n  instr_copy.operands[0].reg.value = key_transform->instr.operands[1].reg.value;\n  instr_copy.operands[1].reg.value = key_transform->instr.operands[0].reg.value;\n  transforms[transform::type::update_key] = instr_copy;\n  if (key_transform == vm_handler.end())\n    return false;\n  // three generic transformations...\n  auto generic_transform = key_transform;\n  for (auto idx = 0u; idx < 3; ++idx)\n  {\n\n```\n\n-----\n\n```\n    generic_transform std::find_if(++generic_transform, vm_handler.end(),\n      [](const zydis_instr_t& instr_data) -> bool\n      {\n        if (util::reg::compare(instr_data.instr.operands[0].reg.value,\nZYDIS_REGISTER_RAX))\n          return true;\n        return false;\n      }\n    );\n    if (generic_transform == vm_handler.end())\n      return false;\n    transforms[(transform::type)(idx + 1)] = generic_transform->instr;\n  }\n  return true;\n}\n\n```\nAs you can see above, the first transformation is the same as the last transformation except\nthe source and destination operands are swapped. VMProtect 2 takes some creative liberties\nwhen applying the last transformation and can sometimes push the rolling decryption key\nonto the stack, apply the transformation, then pop the result back into RBX. This small, but\nsignificant inconvenience can be handled by simply swapping the destination and source\nregisters in the ZydisDecodedInstruction variable as demonstrated in the above code.\n\n## Static Analysis Dilemma - Static Analysis Conclusion\n\nThe dilemma with trying to statically analyze virtual instructions is that branching operations\ninside of the virtual machine are very difficult to handle. In order to calculate where a virtual\nJMP is jumping to, emulation is required. I will be pursuing this in the near future (unicorn).\n\n## vmtracer - Tracing Virtual Instructions\n\nVirtual instruction tracing is trivially achievable by patching every single vm handler table\nentry to an encrypted value which when decrypted points to a trap handler. This will allow for\ninter-instruction inspection of registers as well as the possibility to alter the result of a vm\nhandler. In order to make good usage of this feature it’s important to understand what\nregisters contain what values. You can refer to the “Overview Section” of this post.\n\n\n-----\n\nThe first and foremost important piece of information to log when intercepting virtual\ninstructions is the opcode value which is located in AL. Logging this will tell us all of the\nvirtual instructions executed. The next value which must be logged is the rolling decryption\nkey value which is located in BL. This will allow vmprofiler to decrypt operands statically.\n\nSince we are able to, logging all scratch registers after every single virtual instruction is an\nimportant addition to the logged information as this will paint an even bigger picture of what\nvalues are being manipulated. Lastly, logging the top five QWORD values on the virtual stack\nis done to provide even more information as again, this virtual instruction set architecture is\nbased off of a stack machine.\n\nTo conclude the dynamic analysis section of this post, I have created a small file format for\nthis runtime data. The file format is called “vmp2” and contains all runtime log information.\nThe structures for this file format are very simple, they are listed below.\n\n\n-----\n\n```\nnamespace vmp2\n{\n  enum class exec_type_t\n  {\n    forward,\n    backward\n  };\n  enum class version_t\n  {\n    invalid,\n    v1 = 0x101\n  };\n  struct file_header\n  {\n    u32 magic; // VMP2\n    u64 epoch_time;\n    u64 module_base;\n    exec_type_t advancement;\n    version_t version;\n    u32 entry_count;\n    u32 entry_offset;\n  };\n  struct entry_t\n  {\n    u8 handler_idx;\n    u64 decrypt_key;\n    u64 vip;\n    union\n    {\n      struct\n      {\n        u64 r15;\n        u64 r14;\n        u64 r13;\n        u64 r12;\n        u64 r11;\n        u64 r10;\n        u64 r9;\n        u64 r8;\n        u64 rbp;\n        u64 rdi;\n        u64 rsi;\n        u64 rdx;\n        u64 rcx;\n        u64 rbx;\n        u64 rax;\n        u64 rflags;\n      };\n      u64 raw[16];\n    } regs;\n\n```\n\n-----\n\n```\n    union\n    {\n      u64 qword[0x28];\n      u8 raw[0x140];\n    } vregs;\n    union\n    {\n      u64 qword[0x20];\n      u8 raw[0x100];\n    } vsp;\n  };\n}\n\n## vmprofile-cli - Static Analysis Using Runtime Traces\n\n```\nProvided a “vmp2” file, vmprofiler will produce pseudo virtual instructions including\nimmediate values as well as affected scratch registers. This is not devirtualization by any\nmeans, nor does it provide a view of multiple code paths, however it does give a very useful\ntrace of executed virtual instructions. Vmprofiler can also be used to statically locate the vm\nhandler table and determine what transformation is used to decrypt these vm handler entries.\n\nAn example output of vmprofiler will produce all information about every vm handler including\nimmediate value bit size, virtual instruction name, as well as the five transformations applied\nto the immediate value if there is an immediate value.\n```\n==========[vm handler LCONSTCBW, imm size = 8]=======\n================[vm handler instructions]============\n> 0x00007FF65BAE5C2E movzx eax, byte ptr [rsi]\n> 0x00007FF65BAE5C82 add al, bl\n> 0x00007FF65BAE5C85 add al, 0xD3\n> 0x00007FF65BAE6FC7 not al\n> 0x00007FF65BAE4D23 inc al\n> 0x00007FF65BAE5633 add bl, al\n> 0x00007FF65BAE53D5 sub rsi, 0xFFFFFFFFFFFFFFFF\n> 0x00007FF65BAE5CD1 sub rbp, 0x02\n> 0x00007FF65BAE62F8 mov [rbp], ax\n=================[vm handler transforms]=============\nadd al, bl\nadd al, 0xD3\nnot al\ninc al\nadd bl, al\n=====================================================\n\n```\nThe transformations, if any, are extracted as well from the vm handler and can be executed\ndynamically to decrypt operands.\n\n\n-----\n\n```\n> SREGQ 0x0000000000000088 (VSP[0] 0x00007FF549600000) (VSP[1] \n0x0000000000000000)\n> LCONSTDSX 0x000000007D361173 (VSP[0] = 0x0000000000000000) (VSP[1] =\n0x0000000000000000)\n> ADDQ (VSP[0] = 0x000000007D361173) (VSP[1] = 0x0000000000000000)\n> SREGQ 0x0000000000000010 (VSP[0] = 0x0000000000000202) (VSP[1] =\n0x000000007D361173)\n> SREGQ 0x0000000000000048 (VSP[0] = 0x000000007D361173) (VSP[1] =\n0x0000000000000000)\n> SREGQ 0x0000000000000000 (VSP[0] = 0x0000000000000000) (VSP[1] =\n0x0000000000000100)\n> SREGQ 0x0000000000000038 (VSP[0] = 0x0000000000000100) (VSP[1] =\n0x00000000000000B8)\n> SREGQ 0x0000000000000028 (VSP[0] = 0x00000000000000B8) (VSP[1] =\n0x0000000000000246)\n> SREGQ 0x00000000000000B8 (VSP[0] = 0x0000000000000246) (VSP[1] =\n0x0000000000000100)\n> SREGQ 0x0000000000000010 (VSP[0] = 0x0000000000000100) (VSP[1] =\n0x000000892D8FDA88)\n> SREGQ 0x00000000000000B0 (VSP[0] = 0x000000892D8FDA88) (VSP[1] =\n0x0000000000000000)\n> SREGQ 0x0000000000000040 (VSP[0] = 0x0000000000000000) (VSP[1] =\n0x0000000000000020)\n> SREGQ 0x0000000000000030 (VSP[0] = 0x0000000000000020) (VSP[1] =\n0x0000000000000000)\n> SREGQ 0x0000000000000020 (VSP[0] = 0x0000000000000000) (VSP[1] =\n0x2AAAAAAAAAAAAAAB)\n// ...\n\n## Displaying Trace Information - vmprofiler-qt\n\n```\nIn order to display all traced information such as native register values, scratch register\nvalues and virtual stack values I have created a very small Qt project which will allow you to\nstep through a trace. I felt that a console was way too restrictive and I also found it hard to\nprioritize what needs to be displayed on the console, thus the need for a GUI.\n\n\n-----\n\n## Virtual Machine Behavior\n\nAfter the vm_entry routine executes, all registers that were pushed onto the stack are then\nloaded into virtual machine scratch registers. This also extends to the module base and\nRFLAGS which was also pushed onto the stack. The mapping of native registers to scratch\nregisters is not respected.\n\n\n-----\n\nAnother behavior which the virtual machine architecture exhibits is that if a native instruction\nis not implemented with vm handlers a vmexit will happen to execute the native instruction.\nIn my version of VMProtect 2 CPUID is not implemented with vm handlers so an exit\nhappens.\n\nPrior to a vmexit, values from scratch registers are loaded onto the virtual stack. The vmexit\nvirtual instruction will put these values back into native registers. You can see that the\nscratch registers are different from the ones directly after a vmentry. This is because like I\nsaid before scratch registers are not mapped to native registers.\n\n\n-----\n\n## Demo - Creating and Inspecting A Virtual Trace\n\nFor this demo I will be virtualizing a very simple binary which just executes CPUID and\nreturns true if AVX is supported, else it returns false. The assembly code for this is displayed\nbelow.\n```\n.text:00007FF776A01000 ; int __fastcall main()\n.text:00007FF776A01000         public main\n.text:00007FF776A01000         push  rbx\n.text:00007FF776A01002         sub   rsp, 10h\n.text:00007FF776A01006         xor   ecx, ecx\n.text:00007FF776A01008         mov   eax, 1\n.text:00007FF776A0100D         cpuid\n.text:00007FF776A0100F         shr   ecx, 1Ch\n.text:00007FF776A01012         and   ecx, 1\n.text:00007FF776A01015         mov   eax, ecx\n.text:00007FF776A01017         add   rsp, 10h\n.text:00007FF776A0101B         pop   rbx\n.text:00007FF776A0101C         retn\n.text:00007FF776A0101C main      endp\n\n```\n\n-----\n\nWhen protecting this code I have opted out of using packing for simplicity of the\ndemonstration. I have protected the binary with “Ultra'' settings, which is just obfuscation +\nvirtualization. Looking at the PE header of the output file, we can see that the entry point\nRVA is 0x1000, the image base is 0x140000000. We can now give this information to\nvmprofiler-cli and it should give us the vm handler table RVA as well as all of the vm handler\ninformation.\n\n\n-----\n\n```\n> vmprofiler cli.exe vmpbin vmptest.vmp.exe vmentry 0x1000 imagebase\n0x140000000\n> 0x00007FF670F2822C push 0xFFFFFFFF890001FA\n> 0x00007FF670F27FC9 push 0x45D3BF1F\n> 0x00007FF670F248E4 push r13\n> 0x00007FF670F24690 push rsi\n> 0x00007FF670F24E53 push r14\n> 0x00007FF670F274FB push rcx\n> 0x00007FF670F2607C push rsp\n> 0x00007FF670F24926 pushfq\n> 0x00007FF670F24DC2 push rbp\n> 0x00007FF670F25C8C push r12\n> 0x00007FF670F252AC push r10\n> 0x00007FF670F251A5 push r9\n> 0x00007FF670F25189 push rdx\n> 0x00007FF670F27D5F push r8\n> 0x00007FF670F24505 push rdi\n> 0x00007FF670F24745 push r11\n> 0x00007FF670F2478B push rax\n> 0x00007FF670F27A53 push rbx\n> 0x00007FF670F2500D push r15\n> 0x00007FF670F26030 push [0x00007FF670F27912]\n> 0x00007FF670F2593A mov rax, 0x7FF530F20000\n> 0x00007FF670F25955 mov r13, rax\n> 0x00007FF670F25965 push rax\n> 0x00007FF670F2596F mov esi, [rsp+0xA0]\n> 0x00007FF670F25979 not esi\n> 0x00007FF670F25985 neg esi\n> 0x00007FF670F2598D ror esi, 0x1A\n> 0x00007FF670F2599E mov rbp, rsp\n> 0x00007FF670F259A8 sub rsp, 0x140\n> 0x00007FF670F259B5 and rsp, 0xFFFFFFFFFFFFFFF0\n> 0x00007FF670F259C1 mov rdi, rsp\n> 0x00007FF670F259CB lea r12, [0x00007FF670F26473]\n> 0x00007FF670F259DF mov rax, 0x100000000\n> 0x00007FF670F259EC add rsi, rax\n> 0x00007FF670F259F3 mov rbx, rsi\n> 0x00007FF670F259FA add rsi, [rbp]\n> 0x00007FF670F25A05 mov al, [rsi]\n> 0x00007FF670F25A0A xor al, bl\n> 0x00007FF670F25A11 neg al\n> 0x00007FF670F25A19 rol al, 0x05\n> 0x00007FF670F25A26 inc al\n> 0x00007FF670F25A2F xor bl, al\n> 0x00007FF670F25A34 movzx rax, al\n> 0x00007FF670F25A41 mov rdx, [r12+rax*8]\n> 0x00007FF670F25A49 xor rdx, 0x7F3D2149\n> 0x00007FF670F25507 inc rsi\n> 0x00007FF670F27951 add rdx, r13\n> 0x00007FF670F27954 jmp rdx\n> located vm handler table... at = 0x00007FF670F26473, rva = 0x0000000140006473\n\n```\n\n-----\n\nWe can see that vmprofiler-cli has flattened and deobfuscated the vm_entry code as well as\nlocated the vm handler table. We can also see the transformation done to decrypt vm\nhandler entities, it’s the XOR directly after mov rdx, [r12+rax*8].\n```\n> 0x00007FF670F25A41 mov rdx, [r12+rax*8]\n> 0x00007FF670F25A49 xor rdx, 0x7F3D2149\n\n```\nWe can also see that VIP advanced positively as RSI is incremented by the INC instruction.\n```\n> 0x00007FF670F25507 inc rsi\n\n```\nArmed with this information we can now compile a vmtracer program which will patch all vm\nhandler table entries to our trap handler which will allow us to trace virtual instructions as well\nas alter virtual instruction results.\n```\n// lambdas to encrypt and decrypt vm handler entries\n// you must extract this information from the flattened \n// and deobfuscated view of vm_entry…\nvm::decrypt_handler_t _decrypt_handler =\n[](u64 val) -> u64\n{\n  return val ^ 0x7F3D2149;\n};\nvm::encrypt_handler_t _encrypt_handler =\n[](u64 val) -> u64\n{\n  return val ^ 0x7F3D2149;\n};\nvm::handler::edit_entry_t _edit_entry =\n[](u64* entry_ptr, u64 val) -> void\n{\n  DWORD old_prot;\n  VirtualProtect(entry_ptr, sizeof val,\n    PAGE_EXECUTE_READWRITE, &old_prot);\n  *entry_ptr = val;\n  VirtualProtect(entry_ptr, sizeof val,\n    old_prot, &old_prot);\n};\n// create vm trace file header...\nvmp2::file_header trace_header;\nmemcpy(&trace_header.magic, \"VMP2\", sizeof \"VMP2\" - 1);\ntrace_header.epoch_time = time(nullptr);\ntrace_header.entry_offset = sizeof trace_header;\ntrace_header.advancement = vmp2::exec_type_t::forward;\ntrace_header.version = vmp2::version_t::v1;\ntrace_header.module_base = module_base;\n\n```\n\n-----\n\nI have omitted some of the other code such as the ofstream code and vmtracer class\ninstantiation, you can find that code here. The main purpose of displaying this information is\nto show you how to parse a vm_entry and extract the information which is required to create\na trace.\n\nIn my demo tracer I simply LoadLibraryExA the protected binary, initialize a vmtracer class,\npatch the vm handler table, then call the entry point of the module. This is far from ideal,\nhowever for demonstration purposes it will suffice.\n```\n// patch vm handler table...\ntracer.start();\n// call entry point...\nauto result = reinterpret_cast<int (*)()>(\n  NT_HEADER(module_base)->OptionalHeader.AddressOfEntryPoint + module_base)();\n// unpatch vm handler table...\ntracer.stop();\n\n```\nNow that a trace file has been created we can now inspect the trace via vmprofiler-cli or\nvmprofiler-qt. However I would suggest the latter as the program has been explicitly created\nto view trace files.\n\nWhen loading a trace file into vmprofiler-qt, one must know the vm_entry RVA as well as the\nimage base found in the optional header of the PE file. Given all of this information as well as\nthe original protected binary, vmprofiler-qt will display all virtual instructions in a trace file and\nallow for you to “single step” through it.\n\nLet’s look at the trace file and see if we can locate the original instructions which have now\nbeen converted to a RISC, stack machine based architecture. The first block of code that\nexecutes after vm_entry seems to contain no code pertaining to the original binary. It is here\nsimply for obfuscation purposes and to prevent static analysis of virtual instructions as to\nunderstand where the virtual JMP instruction is going to land would require emulation of the\nvirtual instruction set. This first jump block is located inside of every single protected binary.\n\n\n-----\n\nThe next block following the virtual JMP instruction does a handful of interesting math\noperations pertaining to the stack. If you look closely you can see that the math operation\nbeing executed is: `sub(x, y) = ~((~(x) & ~(x)) + y) & ~((~(x) & ~(x)) + y);`\n```\nsub(VSP, 10) .\n\n```\nIf we simplify this math operation we can see that the operation is a subtraction done to VSP.\n```\nsub(x, y) = ~((~x) + y) . This is equivalent to the native operation sub rsp, 0x10 . If\n\n```\nwe look at the original binary, the one that is not virtualized, we can see that there is in fact\nthis instruction.\n\n\n-----\n\nThe mov eax, 1 displayed above can be seen in the virtual instructions closely after the\nsubtraction done on VSP. The MOV EAX, 1 is done via a LCONSTBSX and a SREGDW. The\nSREG bitsize matches the native register width of 32bits, as well as the constant value being\nloaded into it.\n\nNext we see that a vmexit happens. We can see where code execution will continue outside\nof the virtual machine by going to the last ADDQ prior to the vmexit. The first two values on\nthe stack should be the module base address and 32bit relative virtual address to the routine\nthat will be returned to. In this trace the RVA is 0x140008236. If we inspect this address in\nIDA we can see that the instruction “CPUID” is here.\n```\n.vmp0:0000000140008236 0F A2                     cpuid\n.vmp0:0000000140008238 0F 81 88 FE FF FF               jno  \nloc_1400080C6\n.vmp0:000000014000823E 68 05 02 00 79                push  \n79000205h\n.vmp0:0000000140008243 E9 77 FD FF FF                jmp  \nloc_140007FBF\n\n```\nAs you can see, directly after the CPUID instruction, code execution enters back into the\nvirtual machine. Directly after setting all virtual scratch registers with native register values\nlocated on the virtual stack a constant is loaded onto the stack with the value of 0x1C. The\nresulting value from CPUID is then shifted to the right by this constant value.\n\n\n-----\n\nThe AND operation is done with two NAND operations. The first NAND simply inverts the\nresult from the SHR; `invert(x) = ~(x) & ~(x) . This is done by loading the DWORD`\nvalue twice onto the stack to make a single QWORD.\n\nThe result of this AND operation is then set into virtual scratch register seven (SREGDW\n0x38). It is then moved into scratch register 16. If we look at the vmexit instruction and the\norder in which LREGQ’s are executed we can see that this is indeed correct.\n\nLastly, we can also see the ADD instruction and LVSP instruction which adds a value to VSP.\nThis is expected as there is an ADD RSP, 0x10 in the original binary.\n\nFrom the information above we can reconstruct the following native instructions:\n```\nsub rsp, 0x10\nmov eax, 1\ncpuid\nshr ecx, 0x1C\nand ecx, 1\nmov eax, ecx ; from the LREGDW 0x38; SREGDW 0x80...\nadd rsp, 0x10\nret\n\n```\nAs you can see there are a few instructions which are missing, particularly the push’s and\npop’s of RBX, as well as the XOR to zero the contents of ECX. I assume that these\ninstructions are not converted to virtual instructions directly and are instead implemented in a\n\n\n-----\n\nroundabout way.\n\n## Altering Virtual Instruction Results\n\nIn order to alter virtual instructions one must reimplement the entire vm handler first. If the\nvm handler decrypts a second operand one must remember the importance of the decryption\nkey validity. Thus the original immediate value must be computed and applied to the\ndecryption key via the original transformation. However this value can be subsequently\ndiscarded after updating the decryption key. An example of this could be altering the\nconstant value from the LCONST prior to the SHR in the above section.\n\nThis virtual instruction has two operands, the first being the vm handler index to execute and\nthe second being the immediate value which in this case is a single byte. Since there are two\noperands there will be five transformations inside of the vm handler.\n\nWe can recode this vm handler and compare the decrypted immediate value with 0x1C, then\nbranch to a subroutine to load a different value onto the stack. This will then result in the\nSHR computing a different result. Essentially we can spoof the CPUID results. An alternative\nto this would be recreating the SHR handler, however for simplicity sake i’m just going to shift\nto a bit that is set. In this case bit 5 in ECX after CPUID is set if VMX is supported and since\nmy CPU supports virtualization this bit will be high. Below is the new vm handler.\n\n\n-----\n\n```\n.data\n  __mbase dq 0h\n  public __mbase\n.code\n__lconstbzx proc\n  mov al, [rsi]\n  lea rsi, [rsi+1]\n  xor al, bl\n  dec al\n  ror al, 1\n  neg al\n  xor bl, al\n  pushfq      ; save flags...\n  cmp ax, 01Ch\n  je swap_val\n          ; the constant is not 0x1C\n  popfq      ; restore flags...   \n  sub rbp, 2\n  mov [rbp], ax\n  mov rax, __mbase\n  add rax, 059FEh  ; calc jmp rva is 0x59FE...\n  jmp rax\nswap_val:      ; the constant is 0x1C\n  popfq      ; restore flags...\n  mov ax, 5    ; bit 5 is VMX in ECX after CPUID...\n  sub rbp, 2\n  mov [rbp], ax\n  mov rax, __mbase\n  add rax, 059FEh  ; calc jmp rva is 0x59FE...\n  jmp rax\n__lconstbzx endp\nend\n\n```\nIf we now run the vm tracer again with this new vm handler being set to index 0x55 we\nshould be able to see a change in LCONSTBZX. In order to facilitate this hook, one must set\nthe virtual address of the new vm handler into a `vm::handler::table_t object.`\n```\n// change vm handler 0x55 (LCONSTBZX) to our implimentation of it…\nauto _meta_data = handler_table.get_meta_data(0x55);\n_meta_data.virt = reinterpret_cast<u64>(&__lconstbzx);\nhandler_table.set_meta_data(0x55, _meta_data);\n\n```\nIf we run the binary now it will return 1. You can see this below.\n\n\n-----\n\n## Encoding Virtual Instructions - Inverse Transformations\n\nSince VMProtect 2 generates a virtual machine which executes virtual instructions encoded\nin its own bytecode one could run their own virtual instructions on the VM if they can encode\nthem. The encoded virtual instructions must also be within a 4gb address space range\nthough as the RVA to the virtual instructions is 32bits wide. In this section I will encode a very\nsimple set of virtual instructions to add two QWORD values together and return the result.\n\nTo begin, encoding virtual instructions requires that the vm handlers for said virtual\ninstructions are inside of the binary. Locating these vm handlers is done by ‘vmprofiler’. The\nvm handler index is the first opcode and the immediate value, if any, is the second.\nCombining these two sets of operands will yield an encoded virtual instruction. This is the\nfirst stage of assembling virtual instructions, the second is encrypting the operands.\n\nOnce we have our encoded virtual instructions we can now encrypt them using the inverse\noperations of vm handler transformations as well as the inverse operations for calc_jmp. It’s\nimportant to note that the way in which VIP advances must be taken into consideration when\nencrypting as the order of operands and virtual instructions depends on this advancement\ndirection.\n\n\n-----\n\nIn order to execute these newly assembled virtual instructions, one must put the virtual\ninstructions within a 32bit address range of the vm_entry routine, then put the encrypted rva\nto these virtual instructions onto the stack, and lastly call into vm_entry. I would suggest\nusing VirtualAllocEx to allocate a RW page directly below the protected module. An example\nfor running virtual instructions is displayed below.\n\n\n-----\n\n```\nSIZE_T bytes_copied;\nSTARTUPINFOA info = { sizeof info };\nPROCESS_INFORMATION proc_info;\n// start the protected binary suspended...\n// keep in mind this binary is not packed...\nCreateProcessA(\"vmptest.vmp.exe\", nullptr, nullptr,\n  nullptr, false,\n  CREATE_SUSPENDED | CREATE_NEW_CONSOLE,\n  nullptr, nullptr, &info, &proc_info);\n// wait for the system to finish setting up...\nWaitForInputIdle(proc_info.hProcess, INFINITE);\nauto module_base = get_process_base(proc_info.hProcess);\n// allocate space for the virtual instructions below the module...\nauto virt_instrs = VirtualAllocEx(proc_info.hProcess,\n  module_base + vmasm->header->offset,\n  vmasm->header->size,\n  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n// write the virtual instructions...\nWriteProcessMemory(proc_info.hProcess, virt_instrs,\n  vmasm->data, vmasm->header->size, &bytes_copied);\n// create a thread to run the virtual instructions...\nauto thandle = CreateRemoteThread(proc_info.hProcess,\n  nullptr, 0u,\n  module_base + vm_entry_rva,\n  nullptr, CREATE_SUSPENDED, &tid);\nCONTEXT thread_ctx;\nGetThreadContext(thandle, &thread_ctx);\n// sub rsp, 8...\nthread_ctx.Rsp -= 8;\nthread_ctx.Rip = module_base + vm_entry_rva;\n// write encrypted rva onto the stack...\nWriteProcessMemory(proc_info.hProcess, thread_ctx.Rsp,\n  &vmasm->header->encrypted_rva,\n  sizeof vmasm->header->encrypted_rva, &bytes_copied);\n// update thread context and resume execution...\nSetThreadContext(thandle, &thread_ctx);\nResumeThread(thandle);\n\n## Conclusion - Static Analysis, Dynamic Analysis\n\n```\nTo conclude, my dynamic analysis solution is not the most ideal solution, however It should\nallow for basic reverse engineering of protected binaries. With more time static analysis of\nvirtual instructions will become possible, however for the time being dynamic analysis will\n\n\n-----\n\nhave to do. In the future I will be using unicorn to emulate the virtual machine handlers.\n\nAlthough I have documented a handful of virtual instructions there are many more that I have\nnot documented. The goal of documenting the virtual instructions that I have is to allow the\nreader of this article to obtain a feel for how vm handlers should look as well as how one\ncould alter the results of these vm handlers. The documented virtual instructions in this\narticle are also the most common ones. These virtual instructions will most likely be inside of\nevery virtual machine.\n\nI have added a handful of reference builds inside of the repository for you to try your hand at\nmaking them return 1 by altering vm handlers. There is also a build which uses multiple\nvirtual machines in a single binary.\n\nLastly, I would like to restate that this research has most definitely already been done by\nprivate entities, and I am not the first to document some of the virtual machine architecture\ndiscussed in this post. I have credited those whom I have studied the research of already,\nhowever there are probably many more people that have done research on VMProtect 2 that\nI have not listed simply because I have not come across their work.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-17 - VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture.pdf"
    ],
    "report_names": [
        "2021-05-17 - VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536179,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653788015,
    "ts_modification_date": 1653788015,
    "files": {
        "pdf": "https://archive.orkl.eu/997a6e29e5c9d0f2d225976264e4abb70e04af75.pdf",
        "text": "https://archive.orkl.eu/997a6e29e5c9d0f2d225976264e4abb70e04af75.txt",
        "img": "https://archive.orkl.eu/997a6e29e5c9d0f2d225976264e4abb70e04af75.jpg"
    }
}