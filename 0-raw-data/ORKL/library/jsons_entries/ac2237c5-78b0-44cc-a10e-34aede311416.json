{
    "id": "ac2237c5-78b0-44cc-a10e-34aede311416",
    "created_at": "2022-10-25T16:48:22.504246Z",
    "updated_at": "2025-03-27T02:05:24.959042Z",
    "deleted_at": null,
    "sha1_hash": "54abf2a1c6ac25c1122b96d09ece47692e481c30",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-02-23T11:00:24Z",
    "file_modification_date": "2022-02-23T11:00:24Z",
    "file_size": 8943162,
    "plain_text": "# A Detailed Analysis of The LockBit Ransomware\n\n### Prepared by:   Vlad Pasca, LIFARS, LLC\n\n Date:  02/14/2022\n\n\n**www.LIFARS.com**\n\n[info@lifars.com](mailto:info@lifars.com)\n\n©2022 SecurityScorecard Inc.\n\n244 Fifth Avenue, Suite 2035,\n\nNew York, NY 10001\n\n1.212.222.7061\n\n\n-----\n\n## Table of Contents\n\n#### Executive Summary .............................................................................................................. 2\n\n Analysis and Findings .......................................................................................................... 2\n\n Thread activity – sub_4DF310 function ........................................................................ 10\n\n Thread activity – sub_4C3430 function ....................................................................... 14\n\n Thread activity – sub_4A2EC0 function ....................................................................... 19\n\n Thread activity – sub_45C960 function....................................................................... 28\n\n Thread activity – sub_497060 function ....................................................................... 34\n\n Thread activity – sub_49E730 function ....................................................................... 39\n\n Printing ransom notes ...................................................................................................... 44\n\n LockBit Wallpaper Setup ................................................................................................. 46\n\n Extract and save the HTA ransom note to Desktop .............................................. 52\n\n Indicators of Compromise ............................................................................................... 59\n\nRegistry Keys ................................................................................................................................................................................... 59\n\nFiles Created .................................................................................................................................................................................... 59\n\nProcesses spawned ..................................................................................................................................................................... 59\n\nMutex ................................................................................................................................................................................................... 60\n\nLockBit 2.0 Extension ................................................................................................................................................................ 60\n\nLockBit 2.0 Ransom Note ....................................................................................................................................................... 60\n\n#### Appendix ................................................................................................................................. 61\n\nList of processes to be killed ................................................................................................................................................... 61\n\nList of services to be stopped ................................................................................................................................................. 61\n\n**LIFARS** | 1\n\n\n-----\n\n## Executive Summary \n\nLockBit 2.0 ransomware is one of the most active families in the wild and pretends to implement\nthe fastest encryption algorithms using multithreading with I/O completion ports. The malware\ndoesn’t encrypt systems from CIS countries and can perform UAC bypass on older Windows\nversions if running with insufficient privileges. A hidden window that logs different actions\nperformed by LockBit is created and might be activated using the Shift+F1 shortcut. The\nransomware mounts all hidden volumes and stops a list of targeted processes and services. The\nmalware generates a pair of ECC (Curve25519) session keys, with the private key being encrypted\nusing a hard-coded ECC public key and stored in the registry. The binary deletes all Volume\nShadow Copies using vssadmin and clears the Windows security application and system logs.\nLockBit obtains a list of physical printers used to print multiple ransom notes. The encrypted files\nhave the “.lockbit” extension, and only the first 4KB of the file will be encrypted using the AES\nalgorithm. A unique AES key is generated for each file, encrypted using the session ECC public\nkey, and stored in each encrypted file.\n\n## Analysis and Findings\n\nSHA256: 9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af\n\nThe malware verifies whether it’s being debugged by checking the NtGlobalFlag field from the\nPEB (process environment block). If the debugger is detected, the process jumps to an infinite\nloop:\n\nFigure 1\n\n**LIFARS** | 2\n\n\n-----\n\nThe encrypted strings are stored as stack strings and will be decrypted using the XOR operator.\nAn example of a decryption algorithm is shown in figure 2, along with the decrypted DLL name:\n\nFigure 2\n\nThe binary implements the API hashing technique to hide the API functions used. As we can see\nbelow, the malware computes a 4-byte hash value and compares it with a hard-coded one\n(0xA3E6F6C3 in this case):\n\nFigure 3\n\nThe malicious executable loads multiple DLLs into the address space of the process using the\nLoadLibraryA API:\n\n**LIFARS** | 3\n\n\n-----\n\nFigure 4\n\nThe following DLLs have been loaded: \"gdiplus.dll\", \"ws2_32.dll\", \"shell32.dll\", \"advapi32.dll\",\n\"user32.dll\", \"ole32.dll\", \"netapi32.dll\", \"gpedit.dll\", \"oleaut32.dll\", \"shlwapi.dll\", \"msvcrt.dll\",\n\"activeds.dll\", \"mpr.dll\", \"bcrypt.dll\", \"crypt32.dll\", \"iphlpapi.dll\", \"wtsapi32.dll\", \"win32u.dll\",\n\"Comdlg32.dll\", \"cryptbase.dll\", \"combase.dll\", \"Winspool.drv\".\n\nGetSystemDefaultUILanguage is utilized to retrieve the language identifier for the system default\nUI language of the OS. The return value is compared with multiple identifiers that correspond to\nCIS countries (LockBit doesn’t encrypt these systems):\n\nFigure 5\n\nFigure 6\n\nThe following language identifiers have been found:\n\n  - 0x82c - Azerbaijani (Cyrillic)\n\n  - 0x42c - Azerbaijani (Latin)\n\n  - 0x42b – Armenian\n\n**LIFARS** | 4\n\n\n-----\n\n  - 0x423 – Belarusian\n\n  - 0x437 – Georgian\n\n  - 0x43F – Kazakh\n\n  - 0x440 – Kyrgyz\n\n  - 0x819 - Russian (Moldova)\n\n  - 0x419 – Russian\n\n  - 0x428 – Tajik\n\n  - 0x442 – Turkmen\n\n  - 0x843 - Uzbek (Cyrillic)\n\n  - 0x443 - Uzbek (Latin)\n\n  - 0x422 – Ukrainian\n\nThe GetUserDefaultUILanguage routine extracts the language identifier for the user UI language\nfor the current user. The extracted value is compared with the same identifiers from above:\n\nFigure 7\n\nThe NtQuerySystemInformation function is utilized to retrieve the number of processors in the\nsystem (0x0 = SystemBasicInformation):\n\nFigure 8\n\nThe binary opens a handle to the current process (0x60000 = WRITE_DAC | READ_CONTROL):\n\nFigure 9\n\n**LIFARS** | 5\n\n\n-----\n\nThe GetSecurityInfo API is utilized to retrieve a pointer to the DACL in the returned security\ndescriptor (0x6 = SE_KERNEL_OBJECT, 0x4 = DACL_SECURITY_INFORMATION):\n\nFigure 10\n\nRtlAllocateAndInitializeSid is used to allocate and initialize a SID (security identifier) structure:\n\nFigure 11\n\nThe file extracts the ACL size information via a function call to RtlQueryInformationAcl (0x2 =\n**AclSizeInformation):**\n\nFigure 12\n\nThe executable allocates memory by calling the ZwAllocateVirtualMemory routine (0x3000 =\n**MEM_COMMIT | MEM_RESERVE, 0x4 = PAGE_READWRITE). It’s also important to mention that**\nLockBit frees memory previously allocated using ZwFreeVirtualMemory:\n\nFigure 13\n\n**LIFARS** | 6\n\n\n-----\n\nThe RtlCreateAcl function is utilized to create and initialize an access control list (0x4 =\n**ACL_REVISION_DS):**\n\nFigure 14\n\nThe RtlAddAccessDeniedAce routine is used to add an access-denied access control entry (ACE)\nto the ACL created earlier (0x4 = ACL_REVISION_DS, 0x1 = FILE_READ_DATA):\n\nFigure 15\n\nThe malicious file obtains a pointer to the first ACE in the ACL via a function call to RtlGetAce:\n\nFigure 16\n\nThe process adds an ACE to the ACL previously created using RtlAddAce (0x4 =\n**ACL_REVISION_DS):**\n\nFigure 17\n\nLockBit sets the DACL of the current process to the ACL modified earlier by calling the\nSetSecurityInfo API (0x6 = SE_KERNEL_OBJECT, 0x4 = DACL_SECURITY_INFORMATION):\n\n**LIFARS** | 7\n\n\n-----\n\nFigure 18\n\nThe malware modifies the hard error mode in a way that some error types are not displayed to\nthe user (0xC = **ProcessDefaultHardErrorMode, 0x7 =** **SEM_FAILCRITICALERRORS** |\n**SEM_NOGPFAULTERRORBOX | SEM_NOALIGNMENTFAULTEXCEPT):**\n\nFigure 19\n\nThe ransomware enables the SeTakeOwnershipPrivilege privilege in the current process token\n(0x9 = SeTakeOwnershipPrivilege):\n\nFigure 20\n\nLockBit decrypts a list of processes and services that will be stopped during the infection (the\nentire list can be found in the appendix):\n\nFigure 21\n\n**LIFARS** | 8\n\n\n-----\n\nFigure 22\n\nThe malware calls the ZwOpenProcessToken API in order to open the access token associated\nwith the current process (0x8 = TOKEN_QUERY):\n\nFigure 23\n\nGetTokenInformation is utilized to extract the user account of the token (0x1 = TokenUser):\n\nFigure 24\n\nThe AllocateAndInitializeSid routine is used to allocate and initialize a security identifier (SID) with\na single subauthority:\n\nFigure 25\n\nThe executable compares two security identifier (SID) values using the EqualSid API:\n\n**LIFARS** | 9\n\n\n-----\n\nFigure 26\n\nThere is a recurrent function call to GlobalMemoryStatusEx that retrieves information about the\ncurrent usage of both physical and virtual memory:\n\nFigure 27\n\nLockBit creates a new thread using the CreateThread API, which will run the sub_4DF310\nfunction:\n\nFigure 28\n\nZwSetInformationThread is used to hide the thread from our debugger however, the x32dbg’s\nplugin called ScyllaHide can circumvent its effect (0x11 = HideThreadFromDebugger):\n\nFigure 29\n\n## Thread activity – sub_4DF310 function\n\nThe shutdown priority for the current process relative to other processes in the system is set to 0,\nwhich means that it’s set to be the last process to be shut down:\n\nFigure 30\n\n**LIFARS** | 10\n\n\n-----\n\nGetSystemDirectoryW is utilized to retrieve the path of the system directory:\n\nFigure 31\n\nThe process creates an activation context and activates it using the CreateActCtxW and\nActivateActCtx routines:\n\nFigure 32\n\nFigure 33\n\nThe binary registers and initializes specific common control window classes using the\nInitCommonControls API:\n\nFigure 34\n\nGdiplusStartup is used to initialize Windows GDI+:\n\nFigure 35\n\nThe malicious file initializes the COM library on the current thread:\n\nFigure 36\n\nThe GetVersion routine is used to retrieve the operating system version:\n\n**LIFARS** | 11\n\n\n-----\n\nFigure 37\n\nCreateStreamOnHGlobal is utilized to create a stream object that uses an HGLOBAL memory\nhandle to store the content:\n\nFigure 38\n\nThe stream content is modified, and the process uses the GdipCreateBitmapFromStream\nfunction to create a Bitmap object based on the stream:\n\nFigure 39\n\nThe malware loads the standard arrow cursor resource via a function call to LoadCursorW\n(0x7F00 = IDC_ARROW):\n\nFigure 40\n\nGdipAlloc is utilized to allocate memory for a Windows GDI+ object:\n\nFigure 41\n\nThere is another call to GdipCreateBitmapFromStream followed by a call to GdipDisposeImage,\nwhich releases resources used by the Image object:\n\nFigure 42\n\n**LIFARS** | 12\n\n\n-----\n\nLockBit registers a window class called LockBit_2_0_Ransom using the RegisterClassExW API:\n\nFigure 43\n\nCreateWindowExW is used to create a window called \"LockBit 2.0 Ransom\" that will track the\nprogress of the ransomware, such as the identified drives and different logs:\n\nFigure 44\n\nThe new window is hidden using the ShowWindow routine (0x0 = SW_HIDE):\n\nFigure 45\n\nThe UpdateWindow function is utilized to update the client area of the specified window by\nsending a WM_PAINT message to the window:\n\nFigure 46\n\nThe process creates a new thread by calling the CreateThread function:\n\nFigure 47\n\n**LIFARS** | 13\n\n\n-----\n\nLockBit defines a Shift+F1 hot key for the new window that can be used to unhide it (0x70 = VK_F1,\n0x4 = MOD_SHIFT):\n\nFigure 48\n\nFigure 49\n\nGetMessageW is used to retrieve a message from the thread’s message queue:\n\nFigure 50\n\nThe malicious file translates virtual-key messages into character messages via a call to\nTranslateMessage:\n\nFigure 51\n\nDispatchMessageW is utilized to dispatch a message retrieved by the GetMessage function:\n\nFigure 52\n\n## Thread activity – sub_4C3430 function\n\nThe process sends the **LVM_GETITEMCOUNT message to the newly created window (0x1004 =**\n**LVM_GETITEMCOUNT):**\n\n**LIFARS** | 14\n\n\n-----\n\nFigure 53\n\nThe malware calls the InvalidateRect API many times to add multiple rectangles to the window’s\nupdate region:\n\nFigure 54\n\nWe continue with the analysis of the main thread.\n\nThe CommandLineToArgvW routine obtains an array of pointers to the command line\narguments:\n\nFigure 55\n\nThe file tries to see if the access token is elevated by calling the NtQueryInformationToken API\n(0x14 = TokenElevation):\n\nFigure 56\n\nDepending on the result, the malware proceeds by decrypting the \"[+] Process created with\nadmin rights\" or \"[-] Process created with limited rights\" strings. We know that this sample is\nsupposed to perform UAC bypass in the case of low-level privileges however, this method wasn’t\nemployed on our Windows 10 analysis machine (it’s supposed to be used on older Windows\nversions).\n\nThe process sends the \"[+] Process created with admin rights\" message to the hidden window by\ncalling the SendMessageA API:\n\n**LIFARS** | 15\n\n\n-----\n\nFigure 57\n\nThe binary creates a mutex called \"\\\\BaseNamedObjects\\\\{3FE573D4-3FE5-DD38-399C886767BD8875}\" to ensure that only one instance of the malware is running at one time\n(0x1F0001 = MUTEX_ALL_ACCESS):\n\nFigure 58\n\nThe NetBIOS name of the local computer is extracted using GetComputerNameW:\n\nFigure 59\n\nThe malicious executable retrieves the name of the primary domain controller by calling the\nNetGetDCName function. LockBit has the ability to propagate on the network and kill processes\nand services via malicious GPOs (group policy objects); however, these features weren’t activated\nin this sample:\n\nFigure 60\n\nThe process opens the Run registry key using RegCreateKeyExA (0x80000001 =\n**HKEY_CURRENT_USER, 0x2001F = KEY_READ | KEY_WRITE):**\n\n**LIFARS** | 16\n\n\n-----\n\nFigure 61\n\nThe file is looking for a registry value called \"{9FD872D4-E5E5-DDC5-399C-396785BDC975}\":\n\nFigure 62\n\nThe malware establishes persistence by creating the above registry value:\n\nFigure 63\n\nFigure 64\n\nCreateThread is used to create a new thread within the address space of the process:\n\nFigure 65\n\n**LIFARS** | 17\n\n\n-----\n\nAs in the case of every thread creation, the binary tries to hide it from the debugger using the\nZwSetInformationThread API.\n\nA file called \"C:\\windows\\system32\\2ED873.ico\" is created via a function call to ZwCreateFile\n(0x40000000 = **GENERIC_WRITE,** 0x80 = **FILE_ATTRIBUTE_NORMAL,** 0x5 =\n**FILE_OVERWRITE_IF):**\n\nFigure 66\n\nThe ICO file is populated using the ZwWriteFile routine:\n\nFigure 67\n\nThe executable creates the “HKCR\\.lockbit” registry key using ZwCreateKey (0x2000000 =\n**MAXIMUM_ALLOWED):**\n\nFigure 68\n\n**LIFARS** | 18\n\n\n-----\n\nLockBit creates the DefaultIcon subkey and sets its value to the newly created ICO file, as\nhighlighted below:\n\nFigure 69\n\nFigure 70\n\n## Thread activity – sub_4A2EC0 function\n\nThe FindFirstVolumeW API is utilized to begin scanning the volumes of the computer:\n\nFigure 71\n\nQueryDosDeviceW is used to obtain the current mapping for the above volume:\n\nFigure 72\n\nThe malware retrieves a list of drive letters for the specified volume via a call to\nGetVolumePathNamesForVolumeNameW:\n\nFigure 73\n\n**LIFARS** | 19\n\n\n-----\n\nThe drive type of the volume is extracted using GetDriveTypeW:\n\nFigure 74\n\nThe malicious process sends a message regarding the identified volume to the LockBit hidden\nwindow, as displayed in figure 75.\n\nFigure 75\n\nThe malicious file continues the volume search via a function call to FindNextVolumeW:\n\nFigure 76\n\nThe purpose of the malware is to find unmounted volumes and mount them.\n\nLockBit tries to open the BOOTMGR file from the volume (0x80000000 = GENERIC_READ, 0x3 =\n**FILE_SHARE_READ** | **FILE_SHARE_WRITE,** 0x3 = **OPEN_EXISTING,** 0x80 =\n**FILE_ATTRIBUTE_NORMAL):**\n\nFigure 77\n\nAn unmounted volume is mounted by calling the SetVolumeMountPointW routine:\n\n**LIFARS** | 20\n\n\n-----\n\nFigure 78\n\nFigure 79\n\nLockBit sends a message regarding the successful mount operation to the hidden window (see\nfigure 80). After the enumeration is complete, the thread exits by calling the RtlExitUserThread\nfunction.\n\nFigure 80\n\nThe binary calls the SHChangeNotify API with the SHCNE_ASSOCCHANGED parameter\n(0x8000000 = SHCNE_ASSOCCHANGED):\n\nFigure 81\n\nA new thread is created by the malware using CreateThread:\n\nFigure 82\n\nIntel and AMD CPUs implement a functionality called “AES-NI” (Advanced Encryption Standard\nNew Instructions), which can be used for high-speed AES encryption processing. The binary uses\nthe cpuid instruction in order to retrieve the CPU type of the machine and the vendor of the CPU:\n\n**LIFARS** | 21\n\n\n-----\n\nFigure 83\n\nWhether the CPU supports “AES-NI” the process sends the \"[+] AES-NI enabled\" message to the\nhidden window using SendMessageA.\n\nThe malicious process generates 16 random bytes by calling the BCryptGenRandom routine (0x2\n= BCRYPT_USE_SYSTEM_PREFERRED_RNG):\n\nFigure 84\n\nThe ransom note is also stored in an encrypted form as a stack string that will be decrypted using\na custom algorithm:\n\nFigure 85\n\n**LIFARS** | 22\n\n\n-----\n\nFigure 86\n\nThe process creates a registry key called \"HKCU\\SOFTWARE\\2ED873D4E5389C\" (0x80000001 =\n**HKEY_CURRENT_USER, 0xF003F = KEY_ALL_ACCESS):**\n\nFigure 87\n\nLockBit is looking for two registry values called “Private” and “Public” under the registry key\nabove, which don’t exist at this time:\n\nFigure 88\n\nFigure 89\n\nThe malware sends the \"[+] Generate session keys\" message to the hidden window. It will\ncompute a public ECC (Curve25519) key and a private ECC (Curve25519) key.\n\nThe file generates 32 random bytes via a function call to BcryptGenRandom:\n\n**LIFARS** | 23\n\n\n-----\n\nFigure 90\n\nThe malicious process implements a Curve25519 wrapper in the sub_4300C0 function. Based on\nthe above buffer, it generates a session ECC public key:\n\nFigure 91\n\nThe above operation of generating random bytes is repeated one more time:\n\nFigure 92\n\n**LIFARS** | 24\n\n\n-----\n\nThe same Curve25519 wrapper is used again to transform the above buffer:\n\nFigure 93\n\nThe executable embedded an ECC public key that we call Master ECC public key (highlighted in\nfigure 94). Based on the implementation of the Curve25519 algorithm, it is used to generate a\nshared secret (32-byte value):\n\nFigure 94\n\nThe Master ECC public key is utilized to encrypt the session ECC private key computed above:\n\nFigure 95\n\nWe have utilized the capa tool in order to confirm that the above function is used to encrypt data\nusing Curve25519:\n\nFigure 96\n\n**LIFARS** | 25\n\n\n-----\n\nLockBit stores the encrypted session ECC private key in the\n“HKCU\\Software\\2ED873D4E5389C\\Private” registry value:\n\nFigure 97\n\nLockBit stores the session ECC public key in the “HKCU\\Software\\2ED873D4E5389C\\Public”\nregistry value:\n\nFigure 98\n\nFigure 99 reveals both registry values with their content:\n\nFigure 99\n\nThe malware uses I/O completion ports to improve the encryption speed. It creates an I/O\ncompletion object by calling the NtCreateIoCompletion API (0x1F0003 =\n**IO_COMPLETION_ALL_ACCESS):**\n\nFigure 100\n\nThe binary creates 2 (# of processors/cores) that will handle the files encryption:\n\n**LIFARS** | 26\n\n\n-----\n\nFigure 101\n\nThe thread affinity mask is set to 1 via a function call to ZwSetInformationThread (0x4 =\n**ThreadAffinityMask):**\n\nFigure 102\n\nGetLogicalDrives is used to retrieve the available disk drives:\n\nFigure 103\n\nThe malicious binary determines the disk drive type using the GetDriveTypeW routine:\n\nFigure 104\n\nThe process is looking for type 2 (DRIVE_REMOVABLE), type 3 (DRIVE_FIXED) and type 6\n(DRIVE_RAMDISK) drives:\n\n**LIFARS** | 27\n\n\n-----\n\nFigure 105\n\nFor each targeted drive, the malware creates a new thread that will traverse it and locate all files\nselected for encryption:\n\nFigure 106\n\n## Thread activity – sub_45C960 function\n\nThe file compares the drive name with the tsclient (Terminal Server Client) share:\n\nFigure 107\n\nThe CreateFileW function is utilized to create a file called “2ED873D4.lock” (0xC0000000 =\n**GENERIC_READ** | **GENERIC_WRITE,** 0x1 = **CREATE_NEW,** 0x04000100 =\n**FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY):**\n\n**LIFARS** | 28\n\n\n-----\n\nFigure 108\n\nSHEmptyRecycleBinW is used to empty the Recycle Bin on the drive (0x7 =\n**SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND):**\n\nFigure 109\n\nThe executable retrieves information about the total amount of space and the total amount of\nfree space on the drive by calling the GetDiskFreeSpaceW and GetDiskFreeSpaceExW APIs:\n\nFigure 110\n\nFigure 111\n\nThe user interface language for the current thread is set to “English - United States”:\n\nFigure 112\n\nThe numeric values extracted above are converted into a string that represents the size values in\nbytes, kilobytes, megabytes, or gigabytes, depending on their size:\n\n**LIFARS** | 29\n\n\n-----\n\nFigure 113\n\nThe drive name and the information regarding its size are sent to the hidden window via\nSendMessageW.\n\nThe FindFirstFileExW API is utilized to enumerate the drive:\n\nFigure 114\n\nThe following directories will be skipped:\n\n  - system volume information\n\n  - windows photo viewer\n\n  - windows powershell\n\n  - internet explorer\n\n  - windows security\n\n  - windows defender\n\n  - microsoft shared\n\n  - application data\n\n  - windows journal\n\n  - $recycle.bin\n\n  - $windows~bt\n\n  - windows.old\n\nThe files enumeration is continued via a function call to FindNextFileW:\n\n**LIFARS** | 30\n\n\n-----\n\nFigure 115\n\nFile extensions are extracted using the PathFindExtensionW routine:\n\nFigure 116\n\nThe binary is looking for a “.lockbit” file that would suggest the targeted file has already been\nencrypted:\n\nFigure 117\n\nZwCreateFile is utilized to open the targeted file (0x10003 = **FILE_READ_DATA |**\n**FILE_WRITE_DATA |** **DELETE, 0x80 =** **FILE_ATTRIBUTE_NORMAL, 0x1 =** **FILE_OPEN, 0x48 =**\n**FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING):**\n\nFigure 118\n\nThe targeted file is bound to the I/O completion port created earlier via a function call to\nNtSetInformationFile (0x1E = FileCompletionInformation):\n\n**LIFARS** | 31\n\n\n-----\n\nFigure 119\n\nThe NtQueryInformationFile routine is used to query file information (0x5 =\n**FileStandardInformation):**\n\nFigure 120\n\nNtSetInformationFile is utilized to set end-of-file information for the file (0x14 =\n**FileEndOfFileInformation):**\n\nFigure 121\n\nThe following extensions list has been found:\n\n  - \".rar\" \".zip\" \".ckp\" \".db3\" \".dbf\" \".dbc\" \".dbs\" \".dbt\" \".dbv\" \".frm\" \".mdf\"\n\n  - \".mrg\" \".mwb\" \".myd\" \".ndf\" \".qry\" \".sdb\" \".sdf\" \".sql\" \".tmd\" \".wdb\" \".bz2\"\n\n  - \".tgz\" \".lzo\" \".db\" \".7z\" \".sqlite\" \".accdb\" \".sqlite3\" \".sqlitedb\" \".db-shm\"\n\n  - \".db-wal\" \".dacpac\" \".zipx\" \".lzma\"\n\nLockBit only encrypts the first 4KB of the file. It uses the ZwReadFile API in order to read 0x1000\n(4096) bytes:\n\n**LIFARS** | 32\n\n\n-----\n\nFigure 122\n\nThe GetFileAttributesW function is used to get file system attributes for the ransom note called\n“Restore-My-Files.txt”:\n\nFigure 123\n\nThe ransomware creates the ransom note via a call to ZwCreateFile (0x10003 = FILE_READ_DATA\n| FILE_WRITE_DATA | DELETE, 0x80 = FILE_ATTRIBUTE_NORMAL, 0x2 = FILE_CREATE, 0x40 =\n**FILE_NON_DIRECTORY_FILE):**\n\nFigure 124\n\nThe ransom note is bound to the I/O completion port previously created via a function call to\nNtSetInformationFile (0x1E = FileCompletionInformation):\n\nFigure 125\n\n**LIFARS** | 33\n\n\n-----\n\nThe note is populated using the ZwWriteFile routine:\n\nFigure 126\n\nThe “.lock” file created earlier is deleted after the drive enumeration is complete:\n\nFigure 127\n\nThe content of the ransom note is displayed below:\n\nFigure 128\n\nThe main thread sends the \"Scan done, waiting handles…\" message to the hidden window.\n\n## Thread activity – sub_497060 function\n\nThe malware retrieves the locally unique identifier (LUID) for the SeDebugPrivilege privilege\nusing the LookupPrivilegeValueA routine:\n\nFigure 129\n\nThe privileges of the access token are adjusted to include the SeDebugPrivilege privilege via a\nfunction call to ZwAdjustPrivilegesToken:\n\n**LIFARS** | 34\n\n\n-----\n\nFigure 130\n\nOpenSCManagerA is used to establish a connection to the service control manager and to open\nthe service control manager database (0xF003F = SC_MANAGER_ALL_ACCESS):\n\nFigure 131\n\nA targeted service is opened using the OpenServiceA API (0x2c =\n**SC_MANAGER_MODIFY_BOOT_CONFIG** | **SC_MANAGER_LOCK** |\n**SC_MANAGER_ENUMERATE_SERVICE):**\n\nFigure 132\n\nQueryServiceStatusEx is used to extract the current status of the service:\n\nFigure 133\n\nThe EnumDependentServicesA routine is utilized to retrieve the name and status of each service\nthat depends on the targeted service (see figure 134). These services will be stopped as well (0x1\n= SERVICE_ACTIVE):\n\nFigure 134\n\n**LIFARS** | 35\n\n\n-----\n\nEvery chosen service is stopped by calling the ControlService function (0x1 =\n**SERVICE_CONTROL_STOP):**\n\nFigure 135\n\nA confirmation message that the service was successfully stopped is sent to the hidden window:\n\nFigure 136\n\nThe ransomware takes a snapshot of all processes in the system (0x2 = TH32CS_SNAPPROCESS):\n\nFigure 137\n\nThe malicious file retrieves information about the first process from the snapshot via a function\ncall to Process32First:\n\nFigure 138\n\nInterestingly, the malware removes the extension of the process name (if present) before the\ncomparison with the targeted list:\n\nFigure 139\n\nAn example of such a comparison is shown in figure 140.\n\n**LIFARS** | 36\n\n\n-----\n\nFigure 140\n\nThe process enumeration continues by calling the Process32Next routine:\n\nFigure 141\n\nOpenProcess is used to open a targeted process (0x1FFFFF = PROCESS_ALL_ACCESS):\n\nFigure 142\n\nA process is killed by calling the NtTerminateProcess API:\n\nFigure 143\n\nLockBit initializes the COM library for apartment threading using the CoInitializeEx function (0x6\n= COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE):\n\nFigure 144\n\nThe ransomware deletes all volume shadow copies on the system by calling the ShellExecuteEx\nfunction and running the commands shown below:\n\nFigure 145\n\n**LIFARS** | 37\n\n\n-----\n\nFigure 146\n\nThe malware also creates multiple processes twice in order to delete (again) all shadow copies\nand Windows logs. An example of process creation is shown in figure 147 (0x08000000 =\n**CREATE_NO_WINDOW):**\n\nFigure 147\n\nThe following processes have been spawned:\n\n  - cmd.exe /c vssadmin Delete Shadows /All /Quiet – delete all shadow copies\n\n  - cmd.exe /c bcdedit /set {default} recoveryenabled No – disable automatic repair\n\n  - cmd.exe c bcdedit set {default} bootstatuspolicy ignoreallfailures – ignore errors in the\ncase of a failed boot / shutdown / checkpoint\n\n  - cmd.exe /c wmic SHADOWCOPY /nointeractive – invalid syntax\n\n  - cmd.exe /c wevtutil cl security – clear security log\n\n  - cmd.exe /c wevtutil cl system – clear system log\n\n  - cmd.exe /c wevtutil cl application – clear application log\n\nThe ransomware forwards the \"Volume Shadow Copy & Event log clean\" message to the hidden\nwindow:\n\nFigure 148\n\n**LIFARS** | 38\n\n\n-----\n\n## Thread activity – sub_49E730 function\n\nThe NtRemoveIoCompletion function is utilized to wait for at least a file to be available for\nencryption:\n\nFigure 149\n\nThe following file extensions will be skipped:\n\n  - .386 .cmd .ani .adv .msi .msp .com .nls .ocx .mpa .cpl .mod .hta\n\n  - .prf .rtp .rdp .bin .hlp .shs .drv .wpx .bat .rom .msc .spl .msu\n\n  - .ics .key .exe .dll .lnk .ico .hlp .sys .drv .cur .idx .ini .reg\n\n  - .mp3 .mp4 .apk .ttf .otf .fon .fnt .dmp .tmp .pif .wav .wma .dmg\n\n  - .iso .app .ipa .xex .wad .msu .icns .lock .lockbit .theme .diagcfg\n\n  - .diagcab .diagpkg .msstyles .gadget .woff .part .sfcache .winmd\n\nThe files that can be found in the following directories will not be encrypted:\n\n  - \"$windows.~bt\" \"intel\" \"$recycle.bin\" \"to.msstyles\" \"boot\" \"msbuild\" \"system volume\ninformation\"\n\n  - \"google\" \"application data\" \"windows\" \"windows.old\" \"appdata\" \"mozilla\"  \"microsoft\nshared\" \"internet explorer\"\n\n  - \"opera\" \"windows journal\" \"windows defender\" \"windowspowershell\" \"windows security\"\n\"windows photo viewer\"\n\nThe following specific files will also be skipped:\n\n  - \"iconcache.db\" \"ntuser.dat.log\" \"restore-my-files.txt\" \"autorun.inf\" \"bootsect.bak\"\n\"thumbs.db\"\n\nLockBit uses multiple aeskeygenassist operations in order to assist in AES round key generation,\nas we can see below:\n\n**LIFARS** | 39\n\n\n-----\n\nFigure 150\n\nFigure 151\n\nThe file content is encrypted using the AES128 algorithm. Basically, the malware uses aesenc\ninstructions to perform one round of an AES encryption flow:\n\nFigure 152\n\n**LIFARS** | 40\n\n\n-----\n\nFigure 153\n\nFigure 154\n\nAs we mentioned before, only the first 4KB of the file is encrypted. The encrypted content is\nwritten to the file using ZwWriteFile:\n\nFigure 155\n\nThe BcryptGenRandom routine is utilized to generate 32 random bytes:\n\nFigure 156\n\n**LIFARS** | 41\n\n\n-----\n\nThe buffer generated above is transformed using the Curve25519 wrapper and then copied to a\nnew buffer together with the session ECC public key (see figure 157). Based on the\nimplementation of the Curve25519 algorithm, it is used to generate a shared secret (32-byte\nvalue).\n\nFigure 157\n\nThe AES128 key and IV (initialization vector) are encrypted using Curve25519 with the session ECC\npublic key, as highlighted below:\n\nFigure 158\n\nEach encrypted file has a 512-byte footer that will be explained in detail. It’s written to the\nencrypted file by calling the ZwWriteFile API:\n\nFigure 159\n\nNtSetInformationFile is used to append the “.lockbit” extension to encrypted files (0xA =\n**FileRenameInformation):**\n\nFigure 160\n\nAs we can see below, the files are partially encrypted, which is enough to make them useless\nwithout decrypting them:\n\n**LIFARS** | 42\n\n\n-----\n\nFigure 161\n\nOut of the 512 bytes from the footer, we can highlight the following bytes:\n\n  - last 8 bytes - first 8 bytes from the session ECC public key\n\n  - previous 8 bytes - hard-coded bytes that correspond to this particular LockBit sample\n\n  - 112 bytes - session ECC private key that was encrypted using the Master ECC public key\n(also stored in the Private registry value)\n\n  - 96 bytes – AES key + IV that were encrypted using the session ECC public key\n\nFigure 162\n\n**LIFARS** | 43\n\n\n-----\n\nWe can observe the icon of the encrypted files in figure 163:\n\nFigure 163\n\nWe continue with the analysis of the main thread.\n\nThe binary sends the \"Cleanup\" message to the hidden window via a function call to\nSendMessageA.\n\n## Printing ransom notes\n\nThe process enumerates the local printers using the EnumPrintersW function (0x2 =\n**PRINTER_ENUM_LOCAL):**\n\nFigure 164\n\nThe ransomware avoids the following values that don’t correspond to physical printers: \"Microsoft\nXPS Document Writer\" and \"Microsoft Print to PDF\".\n\nThe OpenPrinterW routine is utilized to retrieve a handle to the printer:\n\nFigure 165\n\nStartDocPrinterW is used to notify the print spooler that a document is to be spooled for printing:\n\nFigure 166\n\n**LIFARS** | 44\n\n\n-----\n\nThe StartPagePrinter API notifies the spooler that a page will be printed on the printer:\n\nFigure 167\n\nThe ransom note is printed via a function call to WritePrinter:\n\nFigure 168\n\nThe EndPagePrinter routine notifies the print spooler that the application is at the end of a page\nin the print job:\n\nFigure 169\n\nThe printing operation is effected 10000 times, as displayed in figure 170:\n\nFigure 170\n\nThe print job operation is completed by calling the EndDocPrinter and ClosePrinter APIs.\n\nLockBit continues the printer enumeration by searching for network printers in the computer’s\ndomain, network printers and print servers in the computer’s domain, and the list of printers to\nwhich the user has made previous connections. These function calls can be seen below (0x40 =\n**PRINTER_ENUM_NETWORK,** 0x10 = **PRINTER_ENUM_REMOTE,** 0x4 =\n**PRINTER_ENUM_CONNECTIONS):**\n\n**LIFARS** | 45\n\n\n-----\n\nFigure 171\n\nFigure 172\n\nFigure 173\n\n## LockBit Wallpaper Setup\n\nThe ransomware sends the \"[+] Setup wallpaper\" message to the hidden window.\n\nThe GdiplusStartup API is utilized to initialize Windows GDI+:\n\nFigure 174\n\nThe file retrieves the width of the screen of the primary display monitor via a function call to\nGetSystemMetrics:\n\n**LIFARS** | 46\n\n\n-----\n\nFigure 175\n\nThe malware allocates memory for Windows GDI+ objects using GdipAlloc:\n\nFigure 176\n\nA Bitmap object is created based on an array of bytes by calling the\nGdipCreateBitmapFromScan0 function (0x26200a = PixelFormat32bppARGB):\n\nFigure 177\n\nCreateStreamOnHGlobal is utilized to create a stream object:\n\nFigure 178\n\nThe binary creates a Bitmap object based on the above stream using\nGdipCreateBitmapFromStream:\n\nFigure 179\n\nA new private font collection is created via a call to GdipNewPrivateFontCollection:\n\nFigure 180\n\nThe malicious process adds a memory font to the private font collection:\n\n**LIFARS** | 47\n\n\n-----\n\nFigure 181\n\nThe GdipGetImageGraphicsContext function is used to create a Graphics object that is associated\nwith an image object:\n\nFigure 182\n\nThe malware creates multiple SolidBrush objects based on different colors using the\nGdipCreateSolidFill routine:\n\nFigure 183\n\nAll SolidBrush objects are used to fill the interior of multiple rectangles using GdipFillRectangle.\nThe GdipSetPageUnit API is utilized to set the unit of measure for a Graphics object:\n\nFigure 184\n\nGdipCreatePen1 is used to create a Pen object:\n\nFigure 185\n\nLockBit creates a GraphicsPath object via a function call to GdipCreatePath:\n\n**LIFARS** | 48\n\n\n-----\n\nFigure 186\n\nThe process performs multiple GdipAddPathArcI calls in order to add elliptical arcs to the current\nfigure of the path:\n\nFigure 187\n\nThe ransomware performs function calls such as GdipFillPath and GdipDrawPath in order to\ntransform the path. It creates a FontFamily object based on the Proxima Nova Font family:\n\nFigure 188\n\nA Font object is created based on the above object via GdipCreateFont:\n\nFigure 189\n\nThe GdipDrawImageRect function is utilized to draw an image:\n\nFigure 190\n\nThe malware measures the extent of the strings that will appear in the wallpaper by calling the\nGdipMeasureString API:\n\n**LIFARS** | 49\n\n\n-----\n\nFigure 191\n\nThe process draws the strings based on a font, a layout rectangle, and a format via a call to\nGdipDrawString:\n\nFigure 192\n\nThe file extracts the path of the %TEMP% directory:\n\nFigure 193\n\nGetTempFileNameW is utilized to create a temporary file:\n\nFigure 194\n\nThe GdipGetImageEncoders function is used to retrieve an array of ImageCodecInfo objects\ncontaining information about the available image encoders:\n\nFigure 195\n\n**LIFARS** | 50\n\n\n-----\n\nThe image constructed in memory is saved to the disk in the temporary file created earlier:\n\nFigure 196\n\nFigure 197 shows the wallpaper that will be set:\n\nFigure 197\n\nThe RegOpenKeyA API is utilized to open the \"Control Panel\\Desktop\" registry key (0x80000001\n= HKEY_CURRENT_USER):\n\nFigure 198\n\nThe “WallpaperStyle” registry value is set to 2, and the “TileWallpaper” value is set to 0 by calling\nthe RegSetValueExA routine (0x1 = REG_SZ):\n\nFigure 199\n\n**LIFARS** | 51\n\n\n-----\n\nFigure 200\n\nThe Desktop wallpaper is set by calling the SystemParametersInfoW function (0x14 =\n**SPI_SETDESKWALLPAPER, 0x3 = SPIF_UPDATEINIFILE | SPIF_SENDCHANGE):**\n\nFigure 201\n\nAs we can see in the next picture, the registry values were successfully modified:\n\nFigure 202\n\n## Extract and save the HTA ransom note to Desktop\n\nLockBit sends the \"[+] Extract *.hta file\" message to the hidden window. The HTA ransom note is\nstored in an encrypted form in the executable. It is decrypted using the XOR operator (key = 0x38).\n\nThe malicious binary creates a file called “LockBit_Ransomware.hta” on the user Desktop\n(0x40000000 = GENERIC_WRITE, 0x2 = CREATE_ALWAYS, 0x80 = FILE_ATTRIBUTE_NORMAL):\n\nFigure 203\n\n**LIFARS** | 52\n\n\n-----\n\nThe WriteFile API is used to populate the HTA file:\n\nFigure 204\n\nThe ZwCreateKey API is utilized to open the “HKCR\\.lockbit” registry key (0x2000000 =\n**MAXIMUM_ALLOWED):**\n\nFigure 205\n\nThe (Default) registry value is set to \"LockBit\" by calling the ZwSetValueKey function (0x1 =\n**REG_SZ):**\n\nFigure 206\n\nThe malware creates the “HKCR\\Lockbit” registry key by calling the ZwCreateKey API (0x2000000\n= MAXIMUM_ALLOWED):\n\n**LIFARS** | 53\n\n\n-----\n\nFigure 207\n\nThe DefaultIcon registry value is set to “C:\\windows\\SysWow64\\2ED873.ico” using\nZwSetValueKey (0x1 = REG_SZ):\n\nFigure 208\n\nThe process creates the following registry subkeys: \"shell\", \"Open\", and \"Command\". The (Default)\nvalue is set to \"LockBit Class\" using ZwSetValueKey (0x1 = REG_SZ):\n\nFigure 209\n\nThe (Default) registry value under the Command key is set to open the HTA ransom note:\n\nFigure 210\n\n**LIFARS** | 54\n\n\n-----\n\nFigure 211\n\nThe NtOpenKey routine is utilized to open the “HKCR\\.hta” registry key (0x2000000 =\n**MAXIMUM_ALLOWED):**\n\nFigure 212\n\nThe malicious binary retrieves the (Default) registry value via a function call to NtQueryValueKey\n(0x2 = KeyValuePartialInformation):\n\nFigure 213\n\nNtOpenKey is used to open the “HKCR\\htafile” key (0x2000000 = MAXIMUM_ALLOWED):\n\nFigure 214\n\nThe DefaultIcon registry value is set to “C:\\windows\\SysWow64\\2ED873.ico” (0x1 = REG_SZ):\n\n**LIFARS** | 55\n\n\n-----\n\nFigure 215\n\nThe file opens the Run registry key using RegCreateKeyExW (0x80000001 =\n**HKEY_CURRENT_USER, 0x2001F = KEY_READ | KEY_WRITE):**\n\nFigure 216\n\nThe ransomware creates a value called \"{2C5F9FCC-F266-43F6-BFD7-838DAE269E11}\", which\ncontains the path to the HTA note (0x1 = REG_SZ):\n\nFigure 217\n\nShellExecuteW is utilized to open and display the above ransom note:\n\nFigure 218\n\n**LIFARS** | 56\n\n\n-----\n\nFigure 219\n\nLockBit deletes the registry value used for persistence named \"{9FD872D4-E5E5-DDC5-399C396785BDC975}\". We believe this value was created to resume the encryption process in the case\nof a reboot:\n\nFigure 220\n\nThe executable sends the \"[+] Removed autorun key\" message to the hidden window using\nSendMessageA. There is a call to ZwSetIoCompletion afterward:\n\nFigure 221\n\nThe malware deletes itself when the system restarts by calling the MoveFileExW function (0x4 =\n**MOVEFILE_DELAY_UNTIL_REBOOT):**\n\n**LIFARS** | 57\n\n\n-----\n\nFigure 222\n\nThere is also a second process that will handle the executable deletion:\n\n\"cmd.exe /C ping 127.0.0.7 -n 3 > Nul & fsutil file setZeroData offset=0 length=524288\n\\\"C:\\\\Users\\\\<User>\\\\Desktop\\\\lockbit.exe\\\" & Del /f /q \\\"C:\\\\Users\\\\<User>\\\\Desktop\\\\lockbit.exe\\\"\"\n\nBy pressing Shift+F1, we can access the hidden window:\n\nFigure 223\n\nFigure 224\n\n**LIFARS** | 58\n\n\n-----\n\n## Indicators of Compromise\n\n#### Registry Keys\n\nKey: HKEY_CLASSES_ROOT\\Lockbit\\shell\\Open\\Command\n\nData: \"C:\\Windows\\system32\\mshta.exe\" \"C:\\Users\\<User>\\Desktop\\LockBit_Ransomware.hta\"\n\nKey: HKEY_CLASSES_ROOT\\Lockbit\\DefaultIcon\n\nKey: HKEY_CLASSES_ROOT\\.lockbit\\DefaultIcon\n\nKey: HKEY_CLASSES_ROOT\\htafile\\DefaultIcon\n\nData: C:\\windows\\SysWow64\\2ED873.ico\n\nKey: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\{2C5F9FCC-F266-43F6-BFD7838DAE269E11}\n\nData: C:\\Users\\<User>\\Desktop\\LockBit_Ransomware.hta\n\nKey: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\{9FD872D4-E5E5-DDC5-399C396785BDC975}\n\nData: <LockBit 2.0 file path>\n\nKey: HKCU\\Software\\2ED873D4E5389C\\Private\n\nKey: HKCU\\Software\\2ED873D4E5389C\\Public\n\nKey: HKCU\\Control Panel\\Desktop\n\nData: Wallpaper = %AppData%\\Local\\Temp\\<wallpaper>.tmp.bmp\n\nData: TileWallpaper = 0\n\nData: WallpaperStyle = 2\n\n#### Files Created\n\nC:\\Users\\<User>\\Desktop\\LockBit_Ransomware.hta\n\nC:\\windows\\SysWow64\\2ED873.ico\n\nC:\\Users\\<User>\\AppData\\Local\\Temp\\<wallpaper>.tmp.bmp\n\nC:\\2ED873D4.lock (or any drive)\n\n#### Processes spawned\n\ncmd.exe /c vssadmin Delete Shadows /All /Quiet\n\ncmd.exe /c bcdedit /set {default} recoveryenabled No\n\n**LIFARS** | 59\n\n\n-----\n\ncmd.exe /c bcdedit /set {default} bootstatuspolicy ignoreallfailures\n\ncmd.exe /c wmic SHADOWCOPY /nointeractive\n\ncmd.exe /c wevtutil cl security\n\ncmd.exe /c wevtutil cl system\n\ncmd.exe /c wevtutil cl application\n\ncmd.exe /c vssadmin delete shadows /all /quiet & wmic shadowcopy delete & bcdedit /set\n{default} bootstatuspolicy ignoreallfailures & bcdedit /set {default} recoveryenabled no\n\ncmd.exe /C ping 127.0.0.7 -n 3 > Nul & fsutil file setZeroData offset=0 length=524288\n\\\"C:\\Users\\<User>\\Desktop\\lockbit.exe\\\" & Del /f /q \\\"C:\\Users\\<User>\\Desktop\\lockbit.exe\\\"\n\n#### Mutex\n\n\\BaseNamedObjects\\{3FE573D4-3FE5-DD38-399C-886767BD8875}\n\n#### LockBit 2.0 Extension\n\n.lockbit\n\n#### LockBit 2.0 Ransom Note\n\nRestore-My-Files.txt\n\nLockBit_Ransomware.hta\n\n**LIFARS** | 60\n\n\n-----\n\n## Appendix\n\n#### List of processes to be killed\n\nwxServer wxServerView sqlmangr RAgui supervise Culture Defwatch winword QBW32\nQBDBMgr qbupdate axlbridge httpd fdlauncher MsDtSrvr java 360se 360doctor wdswfsafe\nfdhost GDscan ZhuDongFangYu QBDBMgrN mysqld AutodeskDesktopApp acwebbrowser\nCreative Cloud Adobe Desktop Service CoreSync Adobe CEF Helper node AdobeIPCBroker\nsync-taskbar sync-worker InputPersonalization AdobeCollabSync BrCtrlCntr BrCcUxSys\nSimplyConnectionManager Simply.SystemTrayIcon fbguard fbserver ONENOTEM wsa_service\nkoaly-exp-engine-service TeamViewer_Service TeamViewer tv_w32 tv_x64 TitanV Ssms\nnotepad RdrCEF sam oracle ocssd dbsnmp synctime agntsvc isqlplussvc xfssvccon\nmydesktopservice ocautoupds encsvc tbirdconfig mydesktopqos ocomm dbeng50\nsqbcoreservice excel infopath msaccess mspub onenote outlook powerpnt steam thebat\nthunderbird visio wordpad bedbh vxmon benetns bengien pvlsvr beserver raw_agent_svc\nvsnapvss CagService DellSystemDetect EnterpriseClient ProcessHacker Procexp64 Procexp\nGlassWire GWCtlSrv WireShark dumpcap j0gnjko1 Autoruns Autoruns64 Autoruns64a\nAutorunsc Autorunsc64 Autorunsc64a Sysmon Sysmon64 procexp64a procmon procmon64\nprocmon64a ADExplorer ADExplorer64 ADExplorer64a tcpview tcpview64 tcpview64a avz\ntdsskiller RaccineElevatedCfg RaccineSettings Raccine_x86 Raccine Sqlservr RTVscan\nsqlbrowser tomcat6 QBIDPService notepad++ SystemExplorer SystemExplorerService\nSystemExplorerService64 Totalcmd Totalcmd64 VeeamDeploymentSvc\n\n#### List of services to be stopped\n\nwrapper DefWatch ccEvtMgr ccSetMgr SavRoam Sqlservr sqlagent sqladhlp Culserver\nRTVscan sqlbrowser SQLADHLP QBIDPService Intuit.QuickBooks.FCS QBCFMonitorService\nmsmdsrv tomcat6 zhudongfangyu vmware-usbarbitator64 vmware-converter dbsrv12\ndbeng8 MSSQL$MICROSOFT##WID MSSQL$VEEAMSQL2012 SQLAgent$VEEAMSQL2012\nSQLBrowser SQLWriter FishbowlMySQL MSSQL$MICROSOFT##WID MySQL57\nMSSQL$KAV_CS_ADMIN_KIT MSSQLServerADHelper100 SQLAgent$KAV_CS_ADMIN_KIT\nmsftesql-Exchange MSSQL$MICROSOFT##SSEE MSSQL$SBSMONITORING\nMSSQL$SHAREPOINT MSSQLFDLauncher$SBSMONITORING\nMSSQLFDLauncher$SHAREPOINT SQLAgent$SBSMONITORING SQLAgent$SHAREPOINT\nQBFCService QBVSS YooBackup YooIT vss sql svc$ MSSQL MSSQL$ memtas mepocs sophos\nveeam backup bedbg PDVFSService BackupExecVSSProvider BackupExecAgentAccelerator\nBackupExecAgentBrowser BackupExecDiveciMediaService BackupExecJobEngine\nBackupExecManagementService BackupExecRPCService MVArmor MVarmor64\nstc_raw_agent VSNAPVSS VeeamTransportSvc VeeamDeploymentService VeeamNFSSvc\nAcronisAgent ARSM AcrSch2Svc CASAD2DWebSvc CAARCUpdateSvc WSBExchange\nMSExchange MSExchange$\n\n**LIFARS** | 61\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://lifars.com/wp-content/uploads/2022/02/LockBitRansomware_Whitepaper.pdf"
    ],
    "report_names": [
        "LockBitRansomware_Whitepaper.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716502,
    "ts_updated_at": 1743041124,
    "ts_creation_date": 1645614024,
    "ts_modification_date": 1645614024,
    "files": {
        "pdf": "https://archive.orkl.eu/54abf2a1c6ac25c1122b96d09ece47692e481c30.pdf",
        "text": "https://archive.orkl.eu/54abf2a1c6ac25c1122b96d09ece47692e481c30.txt",
        "img": "https://archive.orkl.eu/54abf2a1c6ac25c1122b96d09ece47692e481c30.jpg"
    }
}