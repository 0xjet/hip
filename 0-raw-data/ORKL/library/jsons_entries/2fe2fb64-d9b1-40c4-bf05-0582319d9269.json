{
    "id": "2fe2fb64-d9b1-40c4-bf05-0582319d9269",
    "created_at": "2023-01-12T15:10:50.827572Z",
    "updated_at": "2025-03-27T02:05:57.739558Z",
    "deleted_at": null,
    "sha1_hash": "1904dcde2300bfd552bb34ad910360568eac676a",
    "title": "2016-11-10 - Floki Bot and the stealthy dropper",
    "authors": "",
    "file_creation_date": "2022-05-28T04:56:01Z",
    "file_modification_date": "2022-05-28T04:56:01Z",
    "file_size": 415133,
    "plain_text": "# Floki Bot and the stealthy dropper\n\n**[blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the-stealthy-dropper/](https://blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the-stealthy-dropper/)**\n\nMalwarebytes Labs November 10, 2016\n\n[Floki Bot, described recently by Dr. Peter Stephenson from SC Magazine, is yet another bot](https://www.scmagazine.com/floki-bot--a-zeus-wannabe-with-delusions-of-grandeur/article/569329/)\nbased on the leaked Zeus code. However, the author came up with various custom\nmodifications that makes it more interesting.\n\nAccording to the advertisements announced on the black market, this bot is capable of\nmaking very stealthy injections, evading many mechanisms of detection. We decided to take\na look at what are the tricks behind it. It turned out, that although the injection method that\nthe dropper uses is not novel by itself, but it comes with few interesting twists, that are not so\ncommonly used in malware.\n\n## Analyzed sample\n\n**[5649e7a200df2fb85ad1fb5a723bef22 – dropper <- main focus of this analysis](https://www.virustotal.com/en/file/5e1967db286d886b87d1ec655559b9af694fc6e002fea3a6c7fd3c6b0b49ea6e/analysis/)**\n\n[e54d28a24c976348c438f45281d68c54 – core module – bot 32bit](https://www.virustotal.com/en/file/5d2ee0440314f7229a126baa152e43473d771591e818f8317275c175fd888f23/analysis/1478618090/)\n[d4c5384da41fd391d16eff60abc21405 – core module – bot 64bit](https://www.virustotal.com/en/file/0522bfea61ab0db154cde9c1217c90547bd46ba1be0fc6a17bfb4b52e8241a63/analysis/1478618112/)\n\n_NOTE: The core modules depend on a data prepared by the dropper and they crash while_\n_run independently._\n\n## The Floki Dropper\n\n\n-----\n\nThe Floki dropper looks simple and it has been found in wild without any outer protection\nlayer. It has 3 resources with descriptive names – bot32, bot64, and key:\n\nWhen we try to observe its activity, we can see it making an injection into explorer.\n\nIndeed, when we attach the debugger to the newly created explorer process, we can see\nsome alien code implanted – it is written on three additional memory areas with full\npermissions (RWE):\n\nHowever, when we trace the API calls, we cannot find any reference to a function that will\nwrite the code into the explorer process. Fragment of the trace:\n\n\n-----\n\n```\n[...]\n28a8;called module: C:\\Windows\\system32\\kernel32.dll:CreateProcessW\n210f;called module: C:\\Windows\\system32\\kernel32.dll:IsWow64Process\n1d94;called module: C:\\Windows\\SYSTEM32\\ntdll.dll:ZwClose\n210f;called module: C:\\Windows\\system32\\kernel32.dll:IsWow64Process\n1d94;called module: C:\\Windows\\SYSTEM32\\ntdll.dll:ZwClose\n292c;called module: C:\\Windows\\system32\\kernel32.dll:DuplicateHandle\n210f;called module: C:\\Windows\\system32\\kernel32.dll:IsWow64Process\n1d94;called module: C:\\Windows\\SYSTEM32\\ntdll.dll:ZwClose\n2a1e;called module: C:\\Windows\\system32\\kernel32.dll:GetThreadContext\n2a37;called module: C:\\Windows\\system32\\kernel32.dll:SetThreadContext\n210f;called module: C:\\Windows\\system32\\kernel32.dll:IsWow64Process\n2aa1;called module: C:\\Windows\\system32\\kernel32.dll:WaitForSingleObject\n1818;called module: C:\\Windows\\system32\\kernel32.dll:IsBadReadPtr\n182a;called module: C:\\Windows\\SYSTEM32\\ntdll.dll:RtlFreeHeap\n2aad;called module: C:\\Windows\\system32\\kernel32.dll:ExitProcess\n\n```\nWe can see that a new process is created, and it’s context is being changed – that suggests\nmanipulation – but where is the write? In order to find an answer to this question, we will take\na deep dive inside the code.\n\n## Inside\n\nAt the beginning, the dropper dynamically loads some of the required imports:\n\nThe used approach depicts, that the author was trying not to leave any artifacts that could\nallow for easy detection of what modules and functions are going to be used. Instead of\nloading DLLs by their names, it picks them enumerating all the DLLs in the system32\ndirectory:\n\n\n-----\n\nFor the sake of obfuscation, it doesn’t use string comparison. Instead, it calculates a\nchecksum of each found name. The checksum is created by CRC32 from the name XORed\nwith some hardcoded value, that is constant for a particular sample (in the described sample\nit is 0x58E5):\n\nThe resulting checksums are compared with the expected value, till the appropriate module\nis found and loaded. In similar way the export table of a particular module is enumerated and\nthe required functions are being resolved.\n\nAfter the initial imports load, exactly the same method is used to search NTDLL.DLL.\n\nAs we know, NTDLL.DLL provides an interface to execute native system calls. Every version\nof Windows may use a different number of a syscall in order to do the same thing. That’s why\nit is recommended to use them via wrappers, that we can find among functions exported by\nNTDLL. For example, this is how the implementation of the NtAllocateVirtualMemory may\nlook on Windows 7:\n\n\n-----\n\nAnother variant, from Windows 8 looks a bit different:\n\nThe common part is, that the number of the syscall to be executed is moved into the EAX\nregister.\nThe dropper loads NTDLL into the memory and extracts syscalls from selected functions:\n```\n0 : NtCreateSection\n1 : NtMapViewOfSection\n2 : ZwAllocateVirtualMemory\n3 : ZwWriteVirtualMemory\n4 : NtProtectVirtualMemory\n5 : NtResumeThread\n6 : ZwOpenProcess\n7 : NtDuplicateObject\n8 : NtUnmapViewOfSection\n\n```\nIt checks a beginning of each function’s code by comparing it with 0xB8, that is a bytecode\nfor moving a value into EAX:\n\nIf the check passed, the syscall value, that was moved into EAX, is extracted and stored in a\nbuffer:\n\n\n-----\n\nThen, when the dropper wants to call some of the functions, it uses those extracted values.\nThe number of the syscall is fetched from the array where it was saved, and copied to EAX.\nParameters of the function are pushed on the stack. The pointer to the parameters is loaded\ninto EDX – and the syscall is triggered by with the help of an interrupt – INT 0x2E:\n\nThat’s how the functions NtCreateSection, NtMapViewOfSection and NtResumeThread are\nbeing called. Those were the missing elements of the API calls’ trace, so it explains a lot!\n\nExample 1 – dropper makes a call that is the equivalent of calling the function\n_NtCreateSection:_\n\nExample 2 – the dropper mapped a section by using a syscall – it is an equivalent of calling\nthe function NtMapViewOfSection:\n\n\n-----\n\nOnce the memory is prepared, the shellcode is copied there:\n\nAfter the preparations, those sections are mapped into the context of the explorer process,\nthat has been created as suspended. Using SetThreadContext, it’s Entry Point is being\nredirected to the injected memory page. When the explorer process is being resumed, the\nnew code executes and proceeds with unpacking the malicious core.\n\nAt this point of the injection, it’s malicious core is not yet revealed – it’s decryption process\ntakes place inside the shellcode implanted in the explorer. This is also additional\ncountermeasure that this dropper takes against detection tools.\n\nAnother trick that this bot uses, is a defense against inline hooking – a method utilized by\nvarious monitoring tools. All the mapped DLLs are compared with their raw versions, read\nfrom the disk by the dropper. If any anomaly is detected, the dropper overwrites the mapped\nDLL by the code copied from it’s raw version. As a results, the functions are getting\n\n\n-----\n\nunhooked and the monitoring programs are loosing the trace on the executed calls.\nExample from Cuckoo – the unhooking procedure was executed after calling\n_NtGetThreadContext – as a result the sandbox lost control over executed calls:_\n\n## Conclusion\n\nThe illustrated concept is not novel, however it was utilized in an interesting way. Many\nprograms detect malicious activity by monitoring API calls, that are most often misused by\nmalware. Also, applications used for automated analysis hooks API functions, in order to\nmonitor where and how they are being used. The presented method allows to bypass them –\nat the same time being relatively easy to implement.\n\nIn this case, the author didn’t use the full potential of the technique, because he could have\nimplement all the injection-related functions via direct syscalls – instead, he chose to use\nonly some subset, related to writing into remote memory area. Some other syscalls has been\nloaded but not used – it may suggest that the product is still under development. Creation of\nthe new process and changing it’s context still could be detected via API monitoring – and it\nwas enough to rise alerts and make the dropper less stealthy than it was intended.\n\n## Appendix\n\n\n-----\n\nhttps://www.evilsocket.net/2014/02/11/on-windows-syscall-mechanism-and-syscall-numbersextraction-methods/ – On Windows Syscall Mechanism and Syscall Numbers Extraction\nMethods\n\n_This was a guest post written by Hasherezade, an independent researcher and programmer_\n_with a strong interest in InfoSec. She loves going in details about malware and sharing threat_\n_[information with the community. Check her out on Twitter @hasherezade and her personal](https://twitter.com/hasherezade)_\n_[blog: https://hshrzd.wordpress.com.](https://hshrzd.wordpress.com/)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-11-10 - Floki Bot and the stealthy dropper.pdf"
    ],
    "report_names": [
        "2016-11-10 - Floki Bot and the stealthy dropper.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536250,
    "ts_updated_at": 1743041157,
    "ts_creation_date": 1653713761,
    "ts_modification_date": 1653713761,
    "files": {
        "pdf": "https://archive.orkl.eu/1904dcde2300bfd552bb34ad910360568eac676a.pdf",
        "text": "https://archive.orkl.eu/1904dcde2300bfd552bb34ad910360568eac676a.txt",
        "img": "https://archive.orkl.eu/1904dcde2300bfd552bb34ad910360568eac676a.jpg"
    }
}