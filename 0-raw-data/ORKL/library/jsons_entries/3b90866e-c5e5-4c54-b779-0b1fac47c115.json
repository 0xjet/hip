{
    "id": "3b90866e-c5e5-4c54-b779-0b1fac47c115",
    "created_at": "2023-01-12T15:01:47.463739Z",
    "updated_at": "2025-03-27T02:05:39.085178Z",
    "deleted_at": null,
    "sha1_hash": "6af777d814c15d2f09d0cc95dd1d0713af8db600",
    "title": "2017-03-13 - Zeus Panda Webinjects- Don’t trust your eyes",
    "authors": "",
    "file_creation_date": "2022-05-28T03:48:45Z",
    "file_modification_date": "2022-05-28T03:48:45Z",
    "file_size": 270674,
    "plain_text": "# Zeus Panda Webinjects: Don’t trust your eyes\n\n**[cyber.wtf/2017/03/13/zeus-panda-webinjects-dont-trust-your-eyes/](https://cyber.wtf/2017/03/13/zeus-panda-webinjects-dont-trust-your-eyes/)**\n\nMarch 13, 2017\n\n[In our last blog article Zeus Panda Webinjects: a case study, we described the functionality](https://cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/)\nof current Zeus Panda webinject stages and gave some insight into the corresponding\nadministration panel. As we only scratched the surface of the target specific second\nwebinject attack stage (in the following we reference this as 2nd attack stage), we would like\nto share more details about this part.\n\nBasically, the 2nd attack stage already includes the complete code needed for the attack.\nThe different code branches are triggered by setting status variables, especially the branch\nvariable already introduced in our previous article on that topic. Last time we also introduced\nthe send() function, which is used to exfiltrate data. send() isn’t entirely unidirectional: the\nHTTP response of this request includes further code that is evaluated as JavaScript.\nThereby the backend is able to set the different status variables to trigger the existing code\nbranches of the 2nd attack stage. Let’s dive into the details of this communication protocol:\n\n## Communication protocol and status variables\n\n\n-----\n\nFigure 1: Communication\n\nprotocol\nFigure 1 illustrates the communication protocol between the 2nd attack stage and the\nbackend server. We see the different steps of the communication, the branches triggered,\nand the website on which the step occurs. Before going into details, the concept behind the\ncommunication is the following:\n\n1. The current attack state is sent from the client to the backend server.\n2. The backend checks for the current attack state and sets the right response\n\nparameters to initiate the next attack stage.\n\n\n-----\n\n3. The backend response contains variables to notify the 2nd attack stage (client), which\n\nattack branch should be executed next.\n4. The 2nd attack stage evaluates the response variables and triggers the next branch.\n5. This procedure is repeated until the final state of the protocol is reached.\n\n## Time to branch\n\nLet’s take a detailed look into the different branches now.\n\n**Step** **Action**\n\n1 The SL branch is triggered at the beginning of the attack, when an infected victim\naccesses the login page of the targeted online banking, inserts the login credentials\nand clicks on the submit button. (NOTE: The low level Trojan functions need to\ntrigger an the initial webinject (generic loader) on that website and therefore the\nURL of the online banking website has to be listed in the trojan config file). The\nsubmitted login credentials are intercepted, exfiltrated to the backend (see previous\nblog post), then the 2nd stage code calls the original login function of the banking\nor payment website. The backend now registers the new victim, identified by the\nbotid. It returns an empty response to the webinject.\n\n2 At this point, the victim has successfully logged in and has been redirected to the\naccount balance overview page. This triggers the 2nd branch: CP. The CP branch\nis called multiple times during the attack and transmits general status information of\nthe victim to the attacker. The response of the backend contains status flags to\ntrigger the next step of the attack. At this point here, the backend signals to initiate\nthe attack.\n\n3 The attack signal triggers the 3rd step shown in Figure 1: The TL branch. This\nbranch is used to collect details from all available accounts by using the grabber\nmodule. Furthermore, a flag is set to indicate a page reload after the response of\nthe send function has been received. The collected data is then exfiltrated\nagain. The botid is used to correlate transmitted data to existing victim entries in\nthe backend and therefore works as unique identifier for the victim. The server\nresponse is empty, but the previously set reload flag now triggers the CP branch\nagain.\n\n4 The CP branch now sends the some information to the backend as described in\nStep 2. As the backend has stored a different state for the botid already, the\nresponse is different now. It signals the 2nd attack stage that the grabber module\nhas finished and the ats module should start now. This module is used to\nmanipulate account details like the account balance or transaction details. Also\nsome status flags are set to trigger the next branch.\n\n5 The GD branch: This branch is used to collect and exfiltrate account details of the\nvictim. As already described in step 3, the reload flag is used to trigger the CP\nbranch again.\n\n\n-----\n\n**Step** **Action**\n\n6 The CP branch again submits status information, and the backend now triggers the\nnext step of the attack. Besides some status flags, details about the target account\nand some fake data is provided. The data is used by the CP branch to display a\nfake overlay with a message and/or images, to trick the victim into starting a\ntransaction. To that end, the fake overlay is used like in a normal phishing attack.\nWe could observe different kinds of messages, which could be categorized into\ndifferent modi operandi. (see below).\nIf the victim fell for the scam, the previously provided data is used to pre-fill the\ntransaction form. Naturally, this data contains a target account for the transaction.\nThis account will be controlled by the attacker somehow, i.e., it most likely belongs\nto a money-mule.\n\nAdditionally, the response from the backend contains fake information to be\ndisplayed. Depending on the modus operandi, this information is used to display\ndifferent transaction details to the victim, then the ones used for the transaction in\nbackground.\n\n7 Now the victim is redirected to the overview page for a successful transaction. In\ncombination with the current flag state, this page visit triggers the TL branch of the\n2nd stage code. The TL branch is used to collect details from the transaction\noverview page and exfiltrates them to the backend. This indicates a successful\ntransaction to the attacker. The backend response is empty. The webinject transits\ninto the next state, without the need for further communication with the backend.\n\n8 The last triggered branch is called CG. It creates a copy of the complete DOM of\nthe successful transaction overview page and exfiltrates it to the backend. There is\nno indication that this data is displayed in the admin panel, thus we assume it is\ntransmitted for debug purposes only.\n\n## Modi Operandi\n\nIn the following we detail two different exemplary modi operandi, which we could observe\nduring our analysis. The real visible appearance is different, as the webinject makes heavy\nuse of the style-sheets provided by the target website. This is a very straight-forward way to\nproperly brand fraudulent content to match the corporate design of target banks or payment\nproviders. We focus on the content shipped to banking customers.\n\n### Charity Fraud: SOS-Kinder\n\n\n-----\n\nThe victim is asked to donate 1€ to an non-profit organization, in this case for SOS children.\nThis mimics the well know internationally active “SOS-Kinderdorf” organization. The German\ntext is well written and does not contain the obvious indications for phishing that we all love\nand know from the occasional phishing mail, like contorted grammar and a more than flowery\nvocabulary. No Google Translate in sight, here. To leverage this scam vector, the webinject\nmakes use of the data provided by the backed in Step 6 as detailed above. Using an overlay,\nthe victim is made believe he/she is transferring 1€, but under the hood the amount is\nchange to a much higher value.\n\nThe attackers follow a very classic social engineering approach for our part of the world and\nappeal to the victims helpfulness: Who doesn’t want to help children in need by spending\n1€? We refer to this kind of attack as charity fraud.\n\n### Refund Fraud: Finanzpolizei\n\n\n-----\n\nThe overlay presents a message to the victim, indicating a transaction has been made to\ntheir account. As the victim sees a manipulated version of his account balance, he really\nbelieves the transaction has had happen. Furthermore the text indicates a preliminary\ninvestigation by the “Finanzpolizei” against the initiator of the transaction. If the victim is not\ntransferring the money back, the text threatens with prosecution by law enforcement for\nparticipating in a money laundering scheme.\n\nFinally, all the Google Translate and contextual cluelessness we came to love in the scams\nout there! Regrettably for the attacker, not all German-speaking countries are actually\nGermany. (We tried that once, partially, and it was a horrible idea.) An institution called\n“Finanzpolizei” does indeed exist — but not in Germany. The valid target audience for this\n\n\n-----\n\nscam is thus supposedly to be found in Austria, however, the scam is also actively used in\nGermany. The German text includes some mistakes and is not as well written as the first\nmodus operandi we have shown above.\n\nIn the case at hand, the attackers try to make the victim follow through with a classic refund\nscam, by threatening legal consequences. As the story works without the need to manipulate\nthe transferred amount under the hood, the fake data needed in the first described modus\noperandi is not used in this kind of attack. Nevertheless the attack is kind enough to prefill\nthe transaction form with the correct details to ease the transaction for the victim.\n\n## Return of the victim\n\nNow let’s assume the victim has been tricked into initiating a transaction by themselves to\nsend their money to the attacker. What happens, if the victim takes a look into his online\nbanking account some time later? As expected, the 2nd attack stage is also prepared for that\ncase: The user is presented the “temporarily unavailable” notification (see Figures 1 and 2\nfrom our [previous post) and the login function of the target website is disabled. As long as](https://cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/)\nthe status variables are set to the finale state of the described communication protocol, the\nvictim is thus unable to access their account again as long as the backend server is\nreachable. Even when disabling this blocking functionality, account information like\ntransaction details and total balance are still manipulated. As this manipulations use the\noriginally provided style cheets (CSS) from the target institute, a victim has no way to\nvisibility distinguish between a fake entry and an original one.\n\n## Conclusion\n\nNowadays almost all financial institutes make use of two-factor authentication to protect their\nusers from fraud. The modi operandi used by current banking trojan attacks successfully\ncircumvent this by using social engineering techniques. The victim is tricked into initiating the\ntransaction willingly and happily provides all information needed to confirm the transaction.\nThis is achieved by visible modifications of the website that are indistinguishable from the\noriginal website content. The success rate of these attacks is still quite high.\n\nBy using a multi-layered attack, it’s also cumbersome for analysts to get an complete insight\ninto the technical details. As soon as the backend server is not available anymore, only the\n1st stage of a webinject is accessible on an infected machine. Without the backend server,\nmost of the attack code is not available and therefore some pieces of the puzzle are missing.\n\nThese kind of multi-layered attacks have become more and more complex and sophisticated.\nHowever, beyond the visual appearance, the code of the original website is modified heavily\nto make this attacks work and these modifications necessarily leave a footprint. In our fraud\ndetection solutions, we provide our customers with instant visibility into these modification\nsymptoms so they can fare better at protecting their customers’ assets.\n\n\n-----\n\nAuthors: Manuel Körber-Bilgard and Karsten Tellmann\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-03-13 - Zeus Panda Webinjects- Don’t trust your eyes.pdf"
    ],
    "report_names": [
        "2017-03-13 - Zeus Panda Webinjects- Don’t trust your eyes.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535707,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653709725,
    "ts_modification_date": 1653709725,
    "files": {
        "pdf": "https://archive.orkl.eu/6af777d814c15d2f09d0cc95dd1d0713af8db600.pdf",
        "text": "https://archive.orkl.eu/6af777d814c15d2f09d0cc95dd1d0713af8db600.txt",
        "img": "https://archive.orkl.eu/6af777d814c15d2f09d0cc95dd1d0713af8db600.jpg"
    }
}