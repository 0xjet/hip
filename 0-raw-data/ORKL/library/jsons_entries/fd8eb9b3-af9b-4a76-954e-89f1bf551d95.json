{
    "id": "fd8eb9b3-af9b-4a76-954e-89f1bf551d95",
    "created_at": "2023-01-12T15:09:14.428713Z",
    "updated_at": "2025-03-27T02:05:17.900455Z",
    "deleted_at": null,
    "sha1_hash": "74c7d26cfbc8ac45be2d49fcaeaa70ae730b602b",
    "title": "2020-11-19 - Purgalicious VBA- Macro Obfuscation With VBA Purging",
    "authors": "",
    "file_creation_date": "2022-05-28T17:06:19Z",
    "file_modification_date": "2022-05-28T17:06:19Z",
    "file_size": 95359,
    "plain_text": "# Purgalicious VBA: Macro Obfuscation With VBA Purging\n\n**[fireeye.com/blog/threat-research/2020/11/purgalicious-vba-macro-obfuscation-with-vba-purging.html](https://www.fireeye.com/blog/threat-research/2020/11/purgalicious-vba-macro-obfuscation-with-vba-purging.html)**\n\nThreat Research\n\nAndrew Oliveau, Alyssa Rahman, Brett Hawkins\n\nNov 19, 2020\n\n9 mins read\n\nThreat Research\n\nMalicious Office documents remain a favorite technique for every type of threat actor, from red teamers to FIN groups to\nAPTs. In this blog post, we will discuss \"VBA Purging\", a technique we have increasingly observed in the wild and that was\nfirst [publicly documented by Didier Stevens in February 2020. We will explain how VBA purging works with Microsoft Office](https://blog.nviso.eu/2020/02/25/evidence-of-vba-purging-found-in-malicious-documents/)\ndocuments in Compound File Binary Format (CFBF), share some detection and hunting opportunities, and introduce a new\ntool created by Mandiant’s Red Team: [OfficePurge.](https://github.com/mandiant/OfficePurge)\n\n**MS-OVBA File Format**\n\n[Before diving into VBA Purging, it is important to understand certain components of Microsoft’s specifications on VBA macros](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/575462ba-bf67-4190-9fac-c275523c75fc)\n(MS-OVBA). We focus on MS-OVBAs in Microsoft Office 97 documents that use the CFBF file format, instead of the modern\nOpen Office XML (OOXML) format used by Microsoft Excel “.xlsx” and Microsoft Word “.docx” documents.\n\nMS-OVBA’s file structure [stores all VBA data in a hierarchy, which consists of structured storage that contain different types of](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/005bffd7-cd96-4f25-b75f-54433a646b88)\nstreams. VBA code in an Office document is stored in various module streams that consists of two parts: the\nPerformanceCache (also known as P-code), and the CompressedSourceCode. The PerformanceCache section is an array of\nbytes that contains compiled VBA code. The CompressedSourceCode section contains VBA source code that is compressed\nwith Microsoft’s proprietary algorithm. The boundary between the two sections is determined by a MODULEOFFSET, which is\nstored in the dir stream. A diagram of a module stream is shown in Figure 1.\n\n\n-----\n\nModule stream diagram\n\n\nFigure 1: Module stream diagram\n\nWhen a VBA macro is added to a document, the VBA engine saves a compiled version in the PerformanceCache section of\nthe relevant module stream to increase performance. However, an Office application will only access the PerformanceCache\nif its version and architecture match what was used to compile the original VBA code. This version and implementation\ninformation is stored in the _VBA_PROJECT and __SRP_# streams. If the versions do not match, the compressed source\ncode is decompressed, compiled, and run instead.\n\n**VBA Purging vs VBA Stomping**\n\n[In 2018, research by the Walmart security team brought a technique known as “VBA Stomping” to wider public awareness.](https://vbastomp.com/)\n[Originally identified by Dr. Vesselin Bontchev in 2016, this technique allows attackers to remove compressed VBA code from](https://github.com/bontchev/pcodedmp)\nOffice documents and still execute malicious macros without many of the VBA keywords that AV engines had come to rely on\n[for detection. For an example of VBA stomping in-the-wild, check out “STOMP 2 Dis: Brilliance in the (Visual) Basics”.](https://www.fireeye.com/resources/stomp-2-dis-brilliance-in-the-visual-basics)\n\nVBA stomping takes advantage of how module streams are interpreted and exchanges malicious CompressedSourceCode\nwith non-malicious VBA source code, leaving the PerformanceCache untouched. However, the success of this technique is\nOffice-version dependent, implying that an attacker would have to do additional recon on their target and be aware of their\nvictims’ deployed Office versions.\n\nVBA purging modifies the module streams in the opposite way. Instead of changing the CompressedSourceCode, VBA\npurging completely removes the PerformanceCache data from the module stream and the _VBA_PROJECT stream, changes\nthe value of the MODULEOFFSET to 0, and removes all SRP streams (this is necessary because the _VBA_PROJECT and\nSRP streams contain version-dependent PerformanceCache data that will result in a runtime error when there is no\nPerformanceCache in the module stream). This removes strings usually found in PerformanceCache that many AV engines\nand YARA rules depend on for detection. Once removed, attackers are able to use more standard methodologies and\nexecute suspicious functions (i.e. CreateObject) without being detected.\n\n[Figure 2 shows the OLE streams for a normal and a purged document, extracted using oledump. In the original document,](https://blog.didierstevens.com/programs/oledump-py/)\nthe Module1 PerformanceCache is 1291 bytes, while it is 0 bytes in the VBA purged document. The purged document has no\nSRP streams and the _VBA_PROJECT stream has been reduced to 7 bytes.\n\n\n-----\n\nAnalyzing VBA purged document with oledump\n\n\nFigure 2: Analyzing VBA purged\n\ndocument with oledump\n\n**Testing the Effectiveness of VBA Purging**\n\n[Mandiant’s Red Team created a command line, C# tool called OfficePurge to test this technique. OfficePurge supports](https://github.com/mandiant/OfficePurge)\nMicrosoft Office Word, Excel and Publisher documents that follow the CFBF file format. In the following examples, we used\n[OfficePurge and a VBA payload from the public toolkit Unicorn to test the effectiveness of VBA purging a Microsoft Office](https://github.com/trustedsec/unicorn)\nWord document that contained a Base64 encoded PowerShell payload (Figure 3).\n\n\n-----\n\nMacro payload generated with Unicorn\n\n\nFigure 3: Macro payload generated\n\nwith Unicorn\nThe strings output (Figure 4) for the original Word document shows Unicorn’s Base64 encoded PowerShell payload, which is\ndetected by many security products. On the other hand, the output for the VBA purged document does not fully show the\nBase64 encoded payload because the PerformanceCache is removed. The CompressedSourceCode still contains the\nBase64 encoded payload, but Microsoft’s custom compression algorithm splits the strings, making it harder for static analysis\nto detect it.\n\n\n-----\n\nStrings output with a purged and non-purged document\n\n\nFigure 4: Strings output with a purged\n\nand non-purged document\nBoth documents were submitted to online sandboxes to test detection capabilities of various products. VirusTotal’s detection\n[rate of the original document (36/60) dropped by 67% after it was VBA purged (12/61). VirusTotal also categorized the non-](https://www.virustotal.com/gui/file/f4431f02fe1e624fdb7bf2243bb72f1899d7eccb1ed7b2b42ed86e001e8bff28/detection)\npurged document as “create-ole”, “doc”, and “macros”, whereas the purged document was only categorized as “doc”.\n\n\n-----\n\nVirusTotal detection results for non-purged Word document\n\n\nFigure 5: VirusTotal detection results\n\n\nVirusTotal detection results for purged Word document\n\n\nfor non-purged Word document\n\n\nFigure\n\n\n-----\n\n6: VirusTotal detection results for purged Word document\n\n**Detection and Hunting Opportunities**\n\nWith OfficePurge, we have the ability to quickly erase compiled VBA code and reduce security product detections in public\nsandboxes, but why stop there? Using this test data, our next step is to build conditional detection logic in formats such as\nYARA rules, which can identify VBA purged documents and allow us to hunt for previously undetected malicious documents.\nUnder the “sample-data” folder in the OfficePurge GitHub repo, we have added original and purged documents for each\nsupported file type with a macro that will spawn calc.exe. SHA256 hashes are included at the end of this post.\n\nAs mentioned before, this technique involves removing PerformanceCache data from the _VBA_PROJECT stream. MSDN\n[documentation shows that the minimum length for the _VBA_PROJECT stream is 7 bytes to fit the required fields in the](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/43531f35-2801-4cac-b6da-88dc975056da)\nstream header. The following YARA rule searches for CFBF files with a 7 byte _VBA_PROJECT stream:\n\nrule FEYE_OLE_VBAPurged_1 {\n\nmeta:\n\nauthor = \"Alyssa Rahman (@ramen0x3f)\"\n\ndescription = \"This file has a _VBA_PROJECT stream that has been cleared. This is evidence of VBA purging, a\ntechnique where the p-code (PerformanceCache data) is removed from Office files that have an embedded macro.\"\n\nstrings:\n$vba_proj = { 5F 00 56 00 42 00 41 00 5F 00 50 00 52 00 4F 00 4A 00 45 00 43 00 54 00 00 00 00 00 00 00 00 00 }\ncondition:\n\nuint32(0) == 0xe011cfd0 and ( uint32(@vba_proj[1] + 0x78) == 0x07 )\n\n}\n\nSearching with this logic on VirusTotal reveals a large number of malicious documents, meaning this is very prevalent in the\nwild and in use by attackers. This rule should identify most publicly documented examples of VBA purging, such as\n[9fd864e578d8bb985cf71a24089f5e2f (HornetSecurity). However, it may also identify some false positives. As previously](https://www.virustotal.com/gui/file/038e0a602ddf37976cde6f57007fcf5c3f5f235cc025637b40303db38c3b4ec2)\n[identified by Didier Stevens, some public libraries such as EPPlus may generate benign documents without](https://isc.sans.edu/forums/diary/Maldoc+VBA+Purging+Example/26342/)\nPerformanceCache data and appear to be purged.\n\nAnother important limitation of this rule is that the _VBA_PROJECT stream data doesn’t have to be completely removed. So\nwhile the stream size is 7 in all publicly documented examples of this technique, it doesn’t have to be exactly 7.\n\nOne solution to this is to compare the compressed and compiled versions of a document’s macros and look for unexpected\nvariations. Another potential option is a YARA rule that searches the _VBA_PROJECT stream for keywords or bytes, which\nshould appear if the p-code is valid.\n\nBut let’s take the easy path first and look for anomalies within OfficePurge. There’s a section within the code that overwrites\nthe _VBA_PROJECT stream with a static header:\n\n// Remove performance cache in _VBA_PROJECT stream. Replace the entire stream with _VBA_PROJECT header.\n\nbyte[] data = Utils.HexToByte(\"CC-61-FF-FF-00-00-00\");\n\n[A little bit of Googling shows this header was built based on Microsoft’s specifications. But if we compare a purged and](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-ovba/ef7087ac-3974-4452-aab2-7dba2214d239)\nunpurged document, it looks like that header actually varies from specifications in practice (Figure 7).\n\n\n-----\n\nComparison of purged and unpurged document\n\n\nFigure 7: Comparison of purged and\n\nunpurged document\nThis header isn’t necessarily proof that a document is malicious or was created with OfficePurge, but it could be a good\nindicator that the document was created programmatically versus with Office products. With anomalies such as this, we can\nstart building a rule similar to the following, which will search for documents with a “small” _VBA_PROJECT stream and this\nsuspicious stream header:\n\nrule FEYE_OLE_VBAPurged_2 {\nmeta:\nauthor = \"Michael Bailey (@mykill), Jonell Baltazar, Alyssa Rahman (@ramen0x3f), Joseph Reyes\"\ndescription = \"This file has a suspicious _VBA_PROJECT header and a small _VBA_PROJECT stream. This may be\nevidence of the VBA purging tool OfficePurge or a tool-generated document.\"\nstrings:\n$vba_proj = { 5F 00 56 00 42 00 41 00 5F 00 50 00 52 00 4F 00 4A 00 45 00 43 00 54 00 00 00 00 00 00 00 00 00 }\n$cc61 = {CC 61 FF FF 00 00 00}\ncondition:\nuint32(0) == 0xe011cfd0 and ( uint32(@vba_proj[1] + 0x78) >= 0x07 ) and ( uint32(@vba_proj[1] + 0x78) < 0xff ) and\n$cc61\n}\n\nSearching with the two rules shared here reveals a wide range of threat actors and malware types leveraging VBA purging, or\nat least some type of automated document generation. On VirusTotal, you’re likely to see a number of Emotet payloads\ncaught by this rule, which is understandable given how heavily it relies on malicious email attachments. Another top offender\nwe observed was AgentTesla.\n\nSince these rules both turn up benign documents as well, they aren’t ready for a production environment; however, they could\nbe useful as “weak signals” for more manual threat hunting. Many static detection engines may struggle for accuracy when\nidentifying the VBA purging technique. Dynamic analysis techniques, such as those used by FireEye’s MVX engine, will still\ndetonate the malicious document properly and be detected even if the VBA is purged.\n\n**Conclusion**\n\n\n-----\n\nFor as long as companies use Office documents, attackers will be trying to smuggle malicious macros into them. VBA purging\nrepresents a recent example of how threat actors continually invent new ways to evade defenders. The artifacts discussed in\nthis blog post should serve as a starting point for detecting VBA purging, and hopefully the tooling and indicators we have\n[shared will help you hunt for additional anomalies in malicious Office documents. Check out OfficePurge today!](https://github.com/mandiant/OfficePurge)\n\n**Indicators of Compromise**\n\n**File Name** **Description** **SHA256 Hash**\n\n\ntest.doc Unicorn\nmacro\npayload in\nWord\ndocument\nwithout VBA\npurging\n\ntest2.doc Unicorn\nmacro\npayload in\nWord\ndocument\nwith VBA\npurging\n\nexcel_calc.xls Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\nexcel_calc_PURGED.xls Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\npublisher_calc.pub Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\npublisher_calc_PURGED.pub Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\nword_calc.doc Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\nword_calc_PURGED.doc Sample\ndocument in\nOfficePurge’s\n“sample-data\nfolder”\n\n\nf4431f02fe1e624fdb7bf2243bb72f1899d7eccb1ed7b2b42ed86e001e8bff28\n\n98bd119f928e8db4ed45f5426f2c35c5f6d6ccc38af029e7ab4b9cfcc1447c53\n\nde6583d338a8061bb1fc82687c8f5bff9a36ba1e2a87172e696ffaeca32567af\n\n914a6cf78fe98e80b1dee87347adbc8f8b37a1dfe672aa5196885daa447e9e73\n\n4bce7c675edde20a3357bc1d0f25b53838ab0b13824ab7a5bbc09b995b7c832f\n\n36bdfaaf3ea228844507b1129b6927e1e69a2cd5e8af99d507121b1485d85e1e\n\n23fa4b77c578470c1635fe20868591f07662b998716c51fbb53d78189c06154f\n\na7eac98b3477fc97ccfe94f1419a859061ca944dc95372265e922992bd551529\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-19 - Purgalicious VBA- Macro Obfuscation With VBA Purging.pdf"
    ],
    "report_names": [
        "2020-11-19 - Purgalicious VBA- Macro Obfuscation With VBA Purging.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536154,
    "ts_updated_at": 1743041117,
    "ts_creation_date": 1653757579,
    "ts_modification_date": 1653757579,
    "files": {
        "pdf": "https://archive.orkl.eu/74c7d26cfbc8ac45be2d49fcaeaa70ae730b602b.pdf",
        "text": "https://archive.orkl.eu/74c7d26cfbc8ac45be2d49fcaeaa70ae730b602b.txt",
        "img": "https://archive.orkl.eu/74c7d26cfbc8ac45be2d49fcaeaa70ae730b602b.jpg"
    }
}