{
    "id": "b0f179ca-f665-421b-866a-a4f04d586d78",
    "created_at": "2023-01-12T15:00:09.526643Z",
    "updated_at": "2025-03-27T02:15:55.420046Z",
    "deleted_at": null,
    "sha1_hash": "4be0a88d4d9825547daf7401fd338aa43d8ee516",
    "title": "2022-08-03 - PART 3- How I Met Your Beacon – Brute Ratel",
    "authors": "",
    "file_creation_date": "2022-10-23T12:59:51Z",
    "file_modification_date": "2022-10-23T12:59:51Z",
    "file_size": 11393004,
    "plain_text": "# PART 3: How I Met Your Beacon – Brute Ratel\n\n**[mdsec.co.uk/2022/08/part-3-how-i-met-your-beacon-brute-ratel/](https://www.mdsec.co.uk/2022/08/part-3-how-i-met-your-beacon-brute-ratel/)**\n\nActiveBreach\n\n## Introduction\n\n\n3 August 2022\n\n\nIn [part one, we introduced generic approaches to performing threat hunting of C2](https://www.mdsec.co.uk/2022/07/part-1-how-i-met-your-beacon-overview/)\n[frameworks and then followed it up with practical examples against Cobalt Strike in part two.](https://www.mdsec.co.uk/2022/07/part-2-how-i-met-your-beacon-cobalt-strike/)\n\nIn part three of this series, we will analyse Brute Ratel, a command and control framework\n[developed by Dark Vortex. As the C2 is lesser known, we can see it describes itself as](https://bruteratel.com/)\nfollows:\n\n\n-----\n\nThe framework has come under close scrutiny in the past few months, having been allegedly\n[abused by APT29 and the ransomware group BlackCat in recent times. Having an](https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/)\nunderstanding of how we can generically detect this emerging C2 in our infrastructure is\ntherefore useful intelligence for defenders.\n\nOriginally, all analysis was performed on Brute Ratel v1.0.7; the latest at the time of original\nreview. However, a cursory update (contained at the end of this article) was performed\ndiscussing findings pertinent to v1.1 which was released shortly after our initial x33fcon\npresentation. One thing that should be noted with Brute Ratel is that the badger has only\nlimited malleability and primarily from the perspective of the c2 channels; with the exception\nof v1.1 which added malleability for the sleep obfuscation techniques. As such it makes it\npossible to create very specific detections for the tool.\n\n## Brute Ratel’s Loader\n\nBrute Ratel’s badger comes in a number of forms, including exe, DLL and shellcode. When\nthe badger is injected, its reflective loader will instantly load all dependencies required for the\nbadger. As the badger bundles a large amount of post-exploitation features, this leads to a\nsignificant number of DLLs being loaded on initialisation:\n\nAs we can see, the DLLs highlighted are all the DLLs that are loaded when the badger is\ninjected. This list includes the loading of winhttp.dll and wininet.dll, which are not necessarily\nnefarious but are traditional loads for an egress beacon. There are however a number of less\n\n\n-----\n\ncommon DLLs loaded, such as dbghelp.dll, credui.dll samcli.dll and logoncli.dll amongst\nothers.\n\nThis behaviour allows us to create a signature for the image loads and leads to a high signal\nindicator that can be hunted for through image load telemetry.\n\nFor example, using Elastic Query Language, we can search for the sequence of credui.dll,\ndbghelp.dll and winhttp.dll load events occurring in a process within 60 seconds of each\nother:\n```\nsequence by Image with maxspan=1m\n\n     [any where ImageLoaded == 'C:\\\\Windows\\\\System32\\\\credui.dll']\n\n     [any where ImageLoaded == 'C:\\\\Windows\\\\System32\\\\dbghelp.dll']\n\n     [any where ImageLoaded == 'C:\\\\Windows\\\\System32\\\\winhttp.dll']\n\n```\nUsing the EQL tool, or Elastic’s cloud, we can search our event data, such as the following\nwhich was extracted from sysmon logs. Note, we’re explicitly excluding the badger\nexecutable itself so we can only identify the injected badgers:\n```\neql query -f sysmon-data.json \"sequence by Image with maxspan=2m [any where\nImageLoaded == 'C:\\\\Windows\\\\System32\\\\credui.dll' and Image !=\n'C:\\\\Users\\\\bob\\\\Desktop\\\\badger_x64_aws.exe'] [any where ImageLoaded ==\n'C:\\\\Windows\\\\System32\\\\dbghelp.dll' and Image !=\n'C:\\\\Users\\\\bob\\\\Desktop\\\\badger_x64_aws.exe'] [any where ImageLoaded ==\n'C:\\\\Windows\\\\System32\\\\winhttp.dll' and Image !=\n'C:\\\\Users\\\\bob\\\\Desktop\\\\badger_x64_aws.exe']\"\n\n```\nThis leads to the following which shows the detection of the badger being injected in to\nnotepad.exe:\n\nThis query is particularly powerful as it allows us to retrospectively hunt for indicators of\nBrute Ratel badgers in the network, without directly running code on the endpoints.\n\n## Brute Ratel In Memory\n\nAs most beacons remain memory resident, it is important to understand the footprint that is\nleft behind in order to hunt for them. Reviewing the Brute Ratel documentation for the 1.0\nrelease, it details its own implementation of obfuscate and sleep:\n\n\n-----\n\nAccording to the release post, BRc4 uses a mixture of “Asynchronous Procedure Calls,\nWindows Event Creation, Wait Objects and Timers”. However, analysis of the badger was\nonly able to find evidence of APC based execution; more on this later.\n\nIn order to analyse the badger in memory, we first inject it to a process using the pcinject\ncommand, then put the badger to sleep using the sleep command:\n\nOnce the badger is sleeping, we can recover the strings from the process using Process\nHacker. Interestingly, while the badger is sleeping we can see strings such as the following:\n\nInitially this was quite surprising given the aforementioned purported sleep and obfuscate\nstrategies described on the Brute Ratel blog.\n\n\n-----\n\nDigging deeper, we can find that some interesting design decisions have been made where\nby many of the strings displayed in the operator’s UI, are populated from the badger itself.\nFor example, we can see the following in the memory of the badger while it is sleeping:\n\nAnd these strings are then returned to the UI as we can see below:\n\nDigging deeper in to the badger, it was quickly apparent that only the .text section was being\nobfuscated on sleep, leaving the badger susceptible to all manner of signatures against\nstrings and data.\n\nTo illustrate this, reversing the badger we can see the entry point for the loader as\n“bruteloader”:\n\n\n-----\n\nSearching for this string in memory while the badger is sleeping, we can quickly find it inside\nour notepad process:\n\nThese strings provide a good point on which to base a Yara rule for memory scanning on.\nFor example, the following rule will search for either the bruteloader or bhttp_x64.dll strings\nin memory of a process:\n```\nrule brc4_badger_strings\n\n{\n\nmeta:\n\n  author = \"@domchell\"\n\n  description = \"Identifies strings used in Badger v1.0.x rDLL, even while\nsleeping\"\n\nstrings:\n\n  $a = \"bruteloader\"\n\n  $b = \"bhttp_x64.dll\"\n\ncondition:\n\n  1 of them\n\n}\n\n```\nWe can test these against our notepad process while the badger is sleeping to evidence its\neffectiveness:\n\nIt is unlikely the strings will exist in other processes, and using a simple one liner we can\nquickly find all the injected badgers on our test system:\n\n\n-----\n\n[Plugging this Yara rule in to virus total, we can quickly find other samples, such as:](https://www.virustotal.com/gui/file/c70b1fd133737a21904159ed2a867e0105060ac74937472da5e4d0e1f6fa1645)\n\n## Page Permissions\n\nAnalysis of the Brute Ratel obfuscate and sleep strategy observed the badger to shuffle the\npage permissions for the badger during sleep in an attempt to evade prolonging executable\npermissions while the badger sleeps.\n\nBelow, we can see the badger operating on a sleep 0, the page permissions for the badger\nare PAGE_EXECUTE_READ on an unmapped page; this is necessary in order to perform\ntasking:\n\nPutting the badger to sleep, we can see that the obfuscate and sleep strategy obfuscates the\n.text section and resets the page permissions for the badger to to PAGE_READWRITE:\n\n\n-----\n\nInterestingly, we however note that this behaviour is not replicated while a SMB pivot is being\nperformed, that is when two badgers are linked. Here we can see our two badgers linked and\nboth on a 60 second sleep:\n\nAnalysis of the page permissions while two badgers are linked reveals that both remain\nPAGE_EXECUTE_READ, irrespective of the sleep time:\n\nThe conclusion is that the obfuscate and sleep strategy is only applicable to the .text section,\nand while no peer-to-peer pivot is present.\n\nCurious to how the obfuscate and sleep functionality worked, we began to reverse engineer\nit. Walking through the sleep routine in windbg, we can get an initial flavour of what’s\nhappening; the badger is using WaitForSingleObjectEx to delay execution during a series of\nasynchronous procedure calls (APC), and leveraging an indirect syscall to execute\nNtTestAlert and force an alert on the thread:\n\n\n-----\n\nDiving in to IDA, we can get a better feel for what is happening. First it creates a new thread\nwith the start address spoofed to a fixed location of TpReleaseCleanupGroupMembers+550:\n\n\n-----\n\nA series of context structures are then created for a number of function calls, to\nNtWaitForSingleObject, NtProtectVirtualMemory,, SystemFunction032, NtGetContextThread\nand SetThreadContext:\n\n\n-----\n\nNext, a number of APCs are queued against the NtContinue, with the intention of using it to\nproxy calls to the aforementioned context structures; this technique acts as a rudimentary\nform of ROP:\n\n\n-----\n\nHaving reverse engineered the sleeping technique, we soon realised that it it was very\n[similar to @ilove2pwn_’s](https://twitter.com/ilove2pwn_) [Foliage project, with the exception of the hardcoded thread start](https://github.com/SecIdiot/FOLIAGE/blob/master/source/sleep.c)\naddress.\n\nDespite extensive debugging and reverse engineering of the badger, we unable to reveal any\nevidence of the “Windows Event Creation, Wait Objects and Timers” techniques referenced\nin the v1.0 blog post; indeed the APIs required for these techniques did not appear to be\nimported via the badger’s hashed imports.\n\n## Brute Ratels Threads\n\nTo analyse how Brute Ratel threads look in memory, we injected the badger in to a fresh\ncopy of notepad. Immediately, we can see there are some suspicious indicators in the\nthreads used by the sleeping badger.\n\nFirstly, we note that there is a suspicious looking thread with a 0x0 start address, and a\nsingle frame calling WaitForSingleObjectEx in the call stack:\n\n\n-----\n\nWe can speculate that this thread is used for the HTTP comms based on analysis of the\nthread call stack while the badger is now sleeping:\n\nBased on the information we gained from reverse engineering the obfuscate and sleep\nstrategy, we noted that new threads were created with a hardcoded spoofed start address of\nntdll!TpReleaseCleanupGroupMembers+0x550:\n\nWe were unable to find any instances of this occurring as a start address naturally, and as\nsuch leads to a trivial indicator for hunting Brute Ratel threads. In practice this looks as\nfollows within our injected notepad process:\n\n\n-----\n\nThe call stack for the thread is also slightly irregular as it not only contains calls to delay\nexecution, but also the first frame points to ntdll.dll!NtTerminateJobObject+0x1f. A deeper\nlook at why NtNerminateJobObject is used highlights that this is simply a ROP gadget for\nNtTestAlert and is used to execute pending APCs on the thread:\n\n## Memory Hooks\n\nIn our first post in this series, we detailed two potential approaches for detecting in-memory\nbeacons based on memory hooks; by looking for signatures of known patches (e.g. ret to\nntdll.dll!EtwEventWrite) and by detecting copy on write operations.\n\nApplying these concepts to Brute Ratel, we note that the badger does not apply any memory\nhooks until its post-exploitation functionality is used by the operator. An example of this,\nwould be the sharpinline command, which runs a .NET assembly in the current process:\n\n\n-----\n\nOnce the assembly has completed and the beacon gone back to sleep, we can get a better\nunderstanding of whats going on by attaching a debugger and disassembling the values of\nntdll.dll!EtwEventWrite and amsi.dll!AmsiScanBuffer:\n\nAs shown above, these are simple and persistent patches to disable .NET ETW data and\ninhibit AMSI. As the patches are persistent, we can detect them by either of the\naforementioned techniques, since not only will we receive a high signal detection due to the\nfirst instruction of EtwEventWrite being a ret, but also an indicator that the pages where\nEtwEventWrite resides have been modified due to the clearing of the shared bit.\n\nUsing BeaconHunter, we can rapidly detect these hooks based on resolving the exports on\nthe modified pages, providing a strong indicator that malicious tampering has taken place:\n\n\n-----\n\n## Brute Ratel C2 Server\n\nMoving away from the endpoint, as hunters we also have an interest in detecting the\ncommand-and-control infrastructure as this may assist in providing us with sufficient\nintelligence to detect beaconing based on network telemetry.\n\nThe C2 server for Brute Ratel is developed in golang, and by default only allows the operator\nto modify the default landing page for the C2. To fingerprint the C2 server, we discovered it\nwas possible to generate an unhandled exception when sending a POST request containing\nbase64 to any URI. For example, consider the following base64 POST data compared with\nthe the plaintext:\n\n\n-----\n\nIt is likely this occurs as the expected input for the base64 decoded POST data should\nconform to the C2 traffic format. A simple Nuclei rule might help us in scanning for this kind\nof infrastructure:\n```\nid: brc4-ts\n\ninfo:\n\n name: Brute Ratel C2 Server Fingerprint\n\n author: Dominic Chell\n\n severity: info\n\n description: description\n\n reference:\n\n  - https://\n\n tags: tags\n\nrequests:\n\n - raw:\n\n   - |\n    POST / HTTP/1.1\n\n    Host: {{Hostname}}\n\n    Content-Length: 8\n\n    Zm9vYmFy\n\n```\nOutside of direct interaction with the C2, it is also possible to detect C2 infrastructure where\nthe operator has not manually redefined the default landing page based on a hash of the\n[HTML (http.html_hash=-1957161625).](https://www.shodan.io/search?query=http.html_hash%3A-1957161625)\n\n[Using a simple Shodan query, we can quickly find live infrastructure exposed to the Internet:](https://www.shodan.io/search?query=http.html_hash%3A-1957161625)\n\n\n-----\n\nAlthough only around 40 team servers were identified, we can get a better picture of where\nthese are located based on the geographical spread:\n\nIt is quite likely some of these techniques are already known, as based on reports against\nour test infrastructure, defenders are actively hunting these C2 servers:\n\n\n-----\n\n## Brute Ratel Configurations\n\nAnalysis of the Badger revealed that Brute Ratel maintains an encrypted configuration\nstructure in memory which includes details on the C2 endpoints. Being able to extract this\nfrom either artifacts or from running processes can prove helpful for defenders. Our analysis\nrevealed that this configuration is held in a base64 and RC4 encrypted blob using a fixed key\nof “bYXJm/3#M?:XyMBF” in the artifacts for the badger. While the configuration is stored\nplaintext in memory for the sleeping badger.\n\nWe developed the following config extractor that can be used against both on-disk artifacts\nfor BRC4 v1.0.x or injected sleeping badgers with Brute Ratel 1.0.x and 1.1.x:\n\n\n-----\n\n```\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <Windows.h>\n\n#include <string>\n\n#include <vector>\n\n#pragma comment(lib, \"Crypt32.lib\")\n\nstd::string HexDump(void* pBuffer, DWORD cbBuffer)\n\n{\n\n     PBYTE pbBuffer = (PBYTE)pBuffer;\n\n     std::string strHex;\n\n#define FORMAT_APPEND_1(a) { char szTmp[256]; sprintf(szTmp, a); strHex +=\nszTmp; }\n\n#define FORMAT_APPEND_2(a,b) { char szTmp[256]; sprintf(szTmp, a, b); strHex +=\nszTmp; }\n\n     for (DWORD i = 0; i < cbBuffer;)\n\n     {\n\n          FORMAT_APPEND_2(\"0x8x \", i);\n\n          DWORD n = ((cbBuffer - i) < 16) ? (cbBuffer - i) : 16;\n\n          for (DWORD j = 0; j < n; j++)\n\n          {\n\n              FORMAT_APPEND_2(\"%02X \", pbBuffer[i + j]);\n\n          }\n\n          for (DWORD j = 0; j < (16 - n); j++)\n\n          {\n\n              FORMAT_APPEND_1(\"  \");\n\n          }\n\n          FORMAT_APPEND_1(\" \");\n\n          for (DWORD j = 0; j < n; j++)\n\n          {\n\n              FORMAT_APPEND_2(\"%c\", (pbBuffer[i + j] < 0x20 || pbBuffer[i +\nj] > 0x7f) ? '.' : pbBuffer[i + j]);\n\n          }\n\n          FORMAT_APPEND_1(\"\\n\");\n\n          i += n;\n\n     }\n\n     return strHex;\n\n}\n\n\n```\n\n-----\n\n```\nBOOL ReadAllBytes(std::string strFile, PBYTE ppbBuffer, UINT puiBufferLength)\n\n{\n\n     BOOL bSuccess = FALSE;\n\n     PBYTE pbBuffer = NULL;\n\n     *ppbBuffer = NULL;\n\n     *puiBufferLength = 0;\n\n     FILE* fp = fopen(strFile.c_str(), \"rb\");\n\n     if (fp)\n\n     {\n\n          fseek(fp, 0, SEEK_END);\n\n          long lFile = ftell(fp);\n\n          fseek(fp, 0, SEEK_SET);\n\n          if (!(pbBuffer = (PBYTE)malloc(lFile)))\n\n              goto Cleanup;\n\n          if (fread(pbBuffer, 1, lFile, fp) != lFile)\n\n              goto Cleanup;\n\n          *ppbBuffer = pbBuffer;\n\n          *puiBufferLength = (UINT)lFile;\n\n          pbBuffer = NULL;\n\n          bSuccess = TRUE;\n\n     }\n\nCleanup:\n\n     if (fp) fclose(fp);\n\n     if (pbBuffer) free(pbBuffer);\n\n     return bSuccess;\n\n}\n\nvoid Brc4DecodeString(BYTE* pszKey, BYTE* pszInput, BYTE* pszOutput, int cchInput)\n\n{\n\n     BYTE szCharmap[0x100];\n\n     for (UINT i = 0; i < sizeof(szCharmap); i++)\n\n     {\n\n          szCharmap[i] = (char)i;\n\n     }\n\n     UINT cchKey = strlen((char*)pszKey);\n\n     BYTE l = 0;\n\n     for (UINT i = 0; i < sizeof(szCharmap); i++)\n\n     {\n\n          BYTE x = szCharmap[i];\n\n          BYTE k = pszKey[i % cchKey];\n\n          BYTE y = x + k + l;\n\n```\n\n-----\n\n```\n          l y;\n\n          szCharmap[i] = szCharmap[y];\n\n          szCharmap[y] = x;\n\n     }\n\n     l = 0;\n\n     for (UINT i = 0; i < cchInput; i++)\n\n     {\n\n          BYTE x = szCharmap[i + 1];\n\n          BYTE y = x + l;\n\n          l = y;\n\n          BYTE z = szCharmap[y];\n\n          szCharmap[i + 1] = z;\n\n          szCharmap[y] = x;\n\n          x = x + szCharmap[i + 1];\n\n          x = szCharmap[x];\n\n          x = x ^ pszInput[i];\n\n          pszOutput[i] = x;\n\n     }\n\n}\n\nBOOL MatchPattern(PBYTE pbInput, PBYTE pbSearch, DWORD cbSearch, BYTE byteMask)\n\n{\n\n     BOOL bMatch = TRUE;\n\n     for (DWORD j = 0; j < cbSearch; j++)\n\n     {\n\n          if (pbSearch[j] != byteMask && pbInput[j] != pbSearch[j])\n\n          {\n\n              bMatch = FALSE;\n\n              break;\n\n          }\n\n     }\n\n     return bMatch;\n\n}\n\nPBYTE FindPattern(PBYTE pbInput, UINT cbInput, PBYTE pbSearch, DWORD cbSearch, BYTE\nbyteMask, UINT* pcSkipMatches)\n\n{\n\n     if (cbInput > cbSearch)\n\n     {\n\n          for (UINT i = 0; i < cbInput - cbSearch; i++)\n\n          {\n\n              BOOL bMatch = MatchPattern(pbInput + i, pbSearch, cbSearch,\nbyteMask);\n\n              if (bMatch)\n\n              {\n\n                   if (!*pcSkipMatches)\n\n                   {\n\n```\n\n-----\n\n```\n                        return &pbInput[i];\n\n                   }\n\n                   (*pcSkipMatches)--;\n\n              }\n\n          }\n\n     }\n\n     return NULL;\n\n}\n\nBOOL LocateBrc4Config(PBYTE pbInput, UINT cbInput, PBYTE* ppbConfig)\n\n{\n\n#define XOR_RAX_RAX 0x48, 0x31, 0xC0,\n\n#define PUSH_RAX 0x50,\n\n#define MOV_EAX_IMM32 0xB8, 0xab, 0xab, 0xab, 0xab,\n\n#define MOV_RAX_IMM64 0x48, 0xB8, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,\n0xab,\n\n#define PUSH_IMM32 0x68, 0xab, 0xab, 0xab, 0xab,\n\n#define MOV_EAX_0 0xB8, 0x00, 0x00, 0x00, 0x00,\n\n     BYTE Pattern1[] =\n\n     {\n\n          XOR_RAX_RAX\n\n          PUSH_RAX\n\n          MOV_EAX_IMM32\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n     },\n\n     Pattern2[] =\n\n     {\n\n          XOR_RAX_RAX\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n```\n\n-----\n\n```\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n          MOV_RAX_IMM64\n\n     };\n\n     UINT cSkipMatches = 0;\n\n     if (cbInput < 100)\n\n     {\n\n          return FALSE;\n\n     }\n\n     PBYTE pbConfigStart = FindPattern(pbInput, cbInput, Pattern1,\nsizeof(Pattern1), 0xab, &cSkipMatches);\n\n     if (!pbConfigStart)\n\n     {\n\n          cSkipMatches = 0;\n\n          pbConfigStart = FindPattern(pbInput, cbInput, Pattern2,\nsizeof(Pattern2), 0xab, &cSkipMatches);\n\n          if (!pbConfigStart)\n\n          {\n\n              return FALSE;\n\n          }\n\n     }\n\n     BYTE Pattern3[] = {\n\n          PUSH_IMM32\n\n          MOV_EAX_0\n\n          PUSH_RAX\n\n          MOV_EAX_0\n\n          PUSH_RAX\n\n          MOV_EAX_0\n\n          PUSH_RAX\n\n     };\n\n     cSkipMatches = 0;\n\n     PBYTE pbConfigEnd = FindPattern(pbConfigStart, cbInput - (pbConfigStart pbInput), Pattern3, sizeof(Pattern3), 0xab, &cSkipMatches);\n\n     if (!pbConfigEnd)\n\n     {\n\n          return FALSE;\n\n     }\n\n     *ppbConfig = (PBYTE)malloc(pbConfigEnd - pbConfigStart);\n\n     if (!*ppbConfig)\n\n```\n\n-----\n\n```\n     {\n\n          return FALSE;\n\n     }\n\n     memset(*ppbConfig, 0, pbConfigEnd - pbConfigStart);\n\n     pbConfigStart += 4; // skip: XOR_RAX_RAX / PUSH_RAX\n\n     BYTE Pattern4[] = {\n\n          MOV_EAX_IMM32\n\n          PUSH_RAX\n\n     },\n\n     Pattern5[] = {\n\n          MOV_RAX_IMM64\n\n          PUSH_RAX\n\n     };\n\n     for (UINT uiIndex = 0, i = 0; i < pbConfigEnd - pbConfigStart;)\n\n     {\n\n          if (MatchPattern(pbConfigStart + i, Pattern4, sizeof(Pattern4),\n0xab))\n\n          {\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 4];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 3];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 2];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 1];\n\n              i += sizeof(Pattern4);\n\n          }\n\n          else if (MatchPattern(pbConfigStart + i, Pattern5, sizeof(Pattern5),\n0xab))\n\n          {\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 9];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 8];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 7];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 6];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 5];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 4];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 3];\n\n              (*ppbConfig)[uiIndex++] = pbConfigStart[i + 2];\n\n              i += sizeof(Pattern5);\n\n          }\n\n          else if (MatchPattern(pbConfigStart + i, Pattern3, sizeof(Pattern3),\n0xab))\n\n          {\n\n              break;\n\n          }\n\n          else\n\n          {\n\n              return FALSE;\n\n          }\n\n```\n\n-----\n\n```\n     }\n\n     std::string config = (char*)*ppbConfig;\n\n     std::reverse(config.begin(), config.end());\n\n     strcpy((char*)*ppbConfig, config.c_str());\n\n     return TRUE;\n\n}\n\nBOOL FromBase64(char* pszString, PBYTE* ppbBinary, UINT* pcbBinary)\n\n{\n\n     DWORD cbBinary = 0;\n\n     if (FAILED(CryptStringToBinaryA(pszString, 0, CRYPT_STRING_BASE64, NULL,\n&cbBinary, NULL, NULL)))\n\n     {\n\n          return FALSE;\n\n     }\n\n     *ppbBinary = (PBYTE)malloc(cbBinary + 1);\n\n     if (!*ppbBinary)\n\n     {\n\n          return FALSE;\n\n     }\n\n     if (FAILED(CryptStringToBinaryA(pszString, 0, CRYPT_STRING_BASE64,\n*ppbBinary, &cbBinary, NULL, NULL)))\n\n     {\n\n          return FALSE;\n\n     }\n\n     *pcbBinary = cbBinary;\n\n     return TRUE;\n\n}\n\nBOOL ScanProcessForBadgerConfig(HANDLE hProcess, std::string& badgerId,\nstd::vector<std::wstring>& configStrings)\n\n{\n\n     SIZE_T nBytesRead;\n\n     PBYTE lpMemoryRegion = NULL, pbBadgerStateStruct = NULL;\n\n     printf(\"[+] Searching process memory for badger state ...\\n\");\n\n     while (1)\n\n     {\n\n          MEMORY_BASIC_INFORMATION mbi = { 0 };\n\n          if (!VirtualQueryEx(hProcess, lpMemoryRegion, &mbi, sizeof(mbi)))\n\n          {\n\n```\n\n-----\n\n```\n              break;\n\n          }\n\n          if ((mbi.State & MEM_COMMIT) && !(mbi.Protect & PAGE_GUARD) &&\n\n              ((mbi.Protect & PAGE_READONLY) || (mbi.Protect &\nPAGE_READWRITE) || (mbi.Protect & PAGE_EXECUTE_READWRITE)))\n\n          {\n\n              //printf(\"[+] Searching process memory at 0x%p (size\n0x%x)\\n\", lpMemoryRegion, mbi.RegionSize);\n\n              PBYTE pbLocalMemoryCopy = (PBYTE)malloc(mbi.RegionSize);\n\n              if (!ReadProcessMemory(hProcess, lpMemoryRegion,\npbLocalMemoryCopy, mbi.RegionSize, &nBytesRead))\n\n              {\n\n                   //printf(\"[!] Unable to read memory at 0x%p\\n\",\nlpMemoryRegion);\n\n              }\n\n              else\n\n              {\n\n                   for (UINT i = 0; i < mbi.RegionSize - 128 &&\n!pbBadgerStateStruct; i++)\n\n                   {\n\n                        if (memcmp(pbLocalMemoryCopy + i, \"b-\", 2) ==\n0)\n                        {\n\n                             char* pszEndPtr = NULL;\n\n                             int badgerId =\nstrtoul((char*)pbLocalMemoryCopy + i + 2, &pszEndPtr, 10);\n\n                             if (pszEndPtr !=\n(char*)pbLocalMemoryCopy + i + 2 && pszEndPtr && *pszEndPtr == '\\\\' &&\nstrnlen(pszEndPtr, 100) > 16)\n\n                             {\n\n                                  pbBadgerStateStruct =\nlpMemoryRegion + i;\n\n                                  break;\n\n                             }\n\n                        }\n\n                   }\n\n              }\n\n              free(pbLocalMemoryCopy);\n\n              pbLocalMemoryCopy = NULL;\n\n          }\n\n          lpMemoryRegion += mbi.RegionSize;\n\n     }\n\n     if (!pbBadgerStateStruct)\n\n     {\n\n          printf(\"[!] Failed to find badger state\\n\");\n\n```\n\n-----\n\n```\n          return FALSE;\n\n     }\n\n     printf(\"[+] Found badger state at 0x%p\\n\", pbBadgerStateStruct);\n\n     BYTE BadgerState[0x1000];\n\n     memset(BadgerState, 0, sizeof(BadgerState));\n\n     if (!ReadProcessMemory(hProcess, pbBadgerStateStruct, BadgerState, 0x1000,\n&nBytesRead))\n\n     {\n\n          if (GetLastError() != ERROR_PARTIAL_COPY)\n\n          {\n\n              printf(\"[!] Unable to read badger state at 0x%p\\n\",\npbBadgerStateStruct);\n\n              return FALSE;\n\n          }\n\n     }\n\n     badgerId = (char*)BadgerState;\n\n     BYTE ConfigString[1024];\n\n     memset(ConfigString, 0, sizeof(ConfigString));\n\n     for (UINT i = 0x100 + (0x10 - ((DWORD64)pbBadgerStateStruct & 0xf)); i <\nsizeof(BadgerState); i += sizeof(DWORD64))\n\n     {\n\n          DWORD64 pMem = *(DWORD64*)(BadgerState + i);\n\n          if (pMem)\n\n          {\n\n              ConfigString[0] = 0;\n\n              if (!ReadProcessMemory(hProcess, (LPVOID)pMem, ConfigString,\n1024, &nBytesRead) || nBytesRead != 1024)\n\n              {\n\n                   continue;\n\n              }\n\n              BOOL bIsValid = ConfigString[0] != 0;\n\n              std::wstring badgerString;\n\n#define MIN_STRING_LENGTH 5\n\n              if (bIsValid)\n\n              {\n\n                   char* pszConfigString = (char*)ConfigString;\n\n                   for (UINT j = 0; j < nBytesRead && pszConfigString[j]\n!= 0; j++)\n\n```\n\n-----\n\n```\n                   {\n\n                        if (!isprint(pszConfigString[j]) && !\n(pszConfigString[j] == '\\t' || pszConfigString[j] == '\\r' || pszConfigString[j] ==\n'\\n'))\n\n                        {\n\n                             break;\n\n                        }\n\n                        badgerString.push_back(pszConfigString[j]);\n\n                   }\n\n                   bIsValid = badgerString.size() >= MIN_STRING_LENGTH;\n\n              }\n\n              if (!bIsValid)\n\n              {\n\n                   badgerString.clear();\n\n                   bIsValid = TRUE;\n\n                   WCHAR* pwszConfigString = (WCHAR*)ConfigString;\n\n                   for (UINT j = 0; j < nBytesRead / sizeof(WCHAR) &&\npwszConfigString[j] != 0; j++)\n\n                   {\n\n                        if (!iswprint(pwszConfigString[j]) && !\n(pwszConfigString[j] == '\\t' || pwszConfigString[j] == '\\r' || pwszConfigString[j] ==\n'\\n'))\n\n                        {\n\n                             break;\n\n                        }\n\n                        badgerString.push_back(pwszConfigString[j]);\n\n                   }\n\n                   bIsValid = badgerString.size() >= MIN_STRING_LENGTH;\n\n              }\n\n              if (bIsValid)\n\n              {\n\n                   configStrings.push_back(badgerString);\n\n              }\n\n          }\n\n     }\n\n     return TRUE;\n\n}\n\nint main(int argc, char *argv[])\n\n{\n\n     PBYTE key = (PBYTE)\"bYXJm/3#M?:XyMBF\";\n\n     printf(\"BruteRatel v1.x Config Extractor\\n\");\n\n```\n\n-----\n\n```\n     if (argc < 2)\n\n     {\n\n          printf(\n\n              \"Usage: Brc4ConfigExtractor.exe <file> [key]\\n\"\n\n              \"  <file|pid> - file to scan for config, or running process\nID\\n\"\n\n              \"  [key] - key if not default\\n\"\n\n          );\n\n          return 1;\n\n     }\n\n     if (argc > 2)\n\n     {\n\n          key = (PBYTE)argv[2];\n\n     }\n\n     if (atoi(argv[1]) == 0)\n\n     {\n\n          PBYTE pbBadger = NULL;\n\n          UINT cbBadger = 0;\n\n          if (!ReadAllBytes(argv[1], &pbBadger, &cbBadger))\n\n          {\n\n              printf(\"[!] Input file '%s' not found\\n\", argv[1]);\n\n              return 1;\n\n          }\n\n          printf(\"[+] Analysing file '%s' (%u bytes)\\n\", argv[1], cbBadger);\n\n          PBYTE pbConfigText = NULL;\n\n          if (!LocateBrc4Config(pbBadger, cbBadger, &pbConfigText))\n\n          {\n\n              printf(\"[!] Failed to locate BRC4 config\\n\");\n\n              return 1;\n\n          }\n\n          printf(\"[+] Located BRC4 config: %s\\n\", pbConfigText);\n\n          PBYTE pbBinaryConfig = NULL;\n\n          UINT cbBinaryConfig = 0;\n\n          if (!FromBase64((char*)pbConfigText, &pbBinaryConfig,\n&cbBinaryConfig))\n\n          {\n\n              printf(\"[!] Failed to decode BRC4 config from base64\\n\");\n\n              return 1;\n\n          }\n\n          Brc4DecodeString(key, pbBinaryConfig, pbBinaryConfig,\n\n```\n\n-----\n\n```\ncbBinaryConfig);\n\n          printf(\"[+] Decoded config: %.*s\\n\", cbBinaryConfig, pbBinaryConfig);\n\n     }\n\n     else\n\n     {\n\n          DWORD dwPid = atoi(argv[1]);\n\n          printf(\"[+] Analysing process with ID %u\\n\", dwPid);\n\n          HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);\n\n          if (!hProcess)\n\n          {\n\n              printf(\"[!] Failed to open process\\n\");\n\n              return 1;\n\n          }\n\n          std::string badgerId;\n\n          std::vector<std::wstring> configStrings;\n\n          if (!ScanProcessForBadgerConfig(hProcess, badgerId, configStrings))\n\n          {\n\n              printf(\"[!] Failed to locate badger configuration in\nmemory\\n\");\n\n              return 1;\n\n          }\n\n          printf(\"[+] Badger '%s' found...\\n\", badgerId.c_str());\n\n          for (auto configString : configStrings)\n\n          {\n\n              printf(\"  : %S\\n\", configString.c_str());\n\n          }\n\n          CloseHandle(hProcess);\n\n     }\n\n     return 0;\n\n}\n\n```\nRunning the extractor tool on either an artifact or a running process (even while sleeping),\nwill extract the Brute Ratel configuration state for the process or artifact:\n\n\n-----\n\n## Updated v1.1 Analysis\n\nShortly after our talk on this subject at x33fcon, Brute Ratel announced a new version of the\nsoftware. As such, it seemed appropriate to analyse this to ensure defenders have accurate\nadvice given the recent uptake in Brute Ratel by threat actors.\n\n## Analysis of Obfuscate and Sleep Techniques\n\nOne of the things that struck us about the v1.1 release, was the declaration that the author\n[had discovered new sleep and obfuscate techniques. As stated in this YouTube video “Brute](https://www.youtube.com/watch?v=nB5QHVtN9_g&t=267s)\n**Ratel C4 v/s Nighthawk and Open Source Sleep Obfuscation Techniques“, the author**\nsays “I didn’t even knew (SIC) about this technique until Austin released the blog post on\nthis. However, Brute Ratel does not use either of these two techniques that we have seen\n[over here.” in reference to the APC technique used in Foliage and the Timer based](https://github.com/SecIdiot/FOLIAGE)\n[technique as used in MDSec’s Nighthawk and as reverse engineered here and a proof of](https://suspicious.actor/2022/05/05/mdsec-nighthawk-study.html)\n[concept implementation released here. Noting that this video appeared a short time after the](https://github.com/Cracked5pider/Ekko/blob/main/Src/Ekko.c)\nEkko release.\n\nReverse engineering of the obfuscate in sleep techniques used within Brute Ratel v1.1\nreveal that three sleeping strategies are now available. The first, as we have previously\n[documented is an extremely similar implementation to @ilove2pwn_’s Foliage, if not an](https://twitter.com/ilove2pwn_)\nexact copy.\n\nThe second implementation, reverse engineering revealed to be an almost identical\n[implementation of @c5pider’s Ekko code (and originally discovered by Peter Winter-Smith](https://twitter.com/c5pider)\n[and used in MDSec’s Nighthawk). For example, consider the following taken from Ekko:](https://github.com/Cracked5pider/Ekko/blob/main/Src/Ekko.c#L97)\n\n\n-----\n\nCompare this with the technique implemented inside Brute Ratel:\n\n\n-----\n\nAs you can see, the code is almost identical; indeed the few changes include replacing the\nWinApi calls for CreateTimerQueueTimer with the Rtl wrapper RtlCreateTimer, noting that\nthe breakpoints for Rtl wrappers were avoided (likely intentionally) in the aforementioned\nvideo demonstration.\n\nThis brings us to the third technique used by Brute Ratel which is a variation of timers and is\nnot publicly documented. We can see here that this technique uses a subtle variation on\ntimers and instead proxies the timer through RtlRegisterWait:\n\nWhile this technique is not publicly documented, it has been available in Nighthawk for some\ntime, coincidentally with the same values used for many of the constants. Further\ncoincidences arise with other undocumented/unpublished features arising in the Brute Ratel\nv1.1 release.\n\nSo far, we have only discussed the sleeping techniques available in the x64 implementation\nof Brute Ratel. Analysis of the x86 implementation shows that the obfuscate and sleep\nstrategies are fixed to the aforementioned APC Foliage based implementation (noting the\nbreakpoints never hit):\n\n\n-----\n\nTo date there are no public or open source x86 implementations of obfuscate and sleep\nstrategies that use timers, limiting the available opportunities to easily integrate such code\nwithout custom development.\n\n## In Memory Detections\n\nOne of the updates in the v1.1 release implies that the .rdata section is now also obfuscated,\nin order to hide strings such as “[+] AMSI Patched” which were exposed in the memory of the\nsleeping badger. However, even cursory memory analysis shows there remains many\nexposed strings within the memory of the sleeping badger. As a result, this means there are\nmany opportunities to pluck out Brute Ratel processes on an endpoint, even while the\nbadger is sleeping. For example, consider the Brute Ratel C2 data which is stored in a JSON\nformat, simply searching for one of its unique parameters in memory such as “chkin” will\nallow us to spot a badger:\n\nOr simply searching for the badger identifier (e.g. b-) will find them scattered all over both the\nheap and the stack. As a bonus, this can act as simple mechanism to spot the thread that\nBrute Ratel is operating from, for example:\n\nHere we can see the presence of the “b-4\\” on the stack of thread 4344. We can confirm that\nis indeed the thread for Brute Ratel from the UI:\n\nWith this in mind, we’re able to build a simple but effective Yara rule to pluck sleeping Brute\nRatel processes from memory:\n\n\n-----\n\n```\nrule brc4_badger_strings\n\n{\n\nmeta:\n\n  author = \"@domchell\"\n\n  description = \"Identifies strings from Brute Ratel v1.1\"\n\nstrings:\n\n  $a = \"\\\"chkin\\\":\"\n\ncondition:\n\n  $a\n\n}\n\n```\nExecuting the Yara rule, we can spot the sleeping badger:\n\nThe detections documented in v1.0 for post-exploitation actions such as suspicious copy on\nwrite operations remain relevant and still offer an effective means of detection for BRC4 postexploitation.\n\n## Thread Stack Spoofing\n\nIn the v1.0 release of Brute Ratel, as we noted the start address of the thread is hardcoded\nto ntdll!TpReleaseCleanupGroupMembers+0x550. Version 1.1 proclaims to offer “full thread\nstack masquerading”. Analysis of the stack spoofing for Brute Ratel reveals a simplistic\nimplementation of rewriting the threads call stack. This process occurs just prior to the\nbadger going to sleep, using the aforementioned timer technique. In an attempt to make the\nthread appear more legitimate, a new thread stack is created with hardcoded addresses for\nthe first two frames. The addresses hardcoded are at offsets 0xa and 0x12 from\nRtlUserThreadStart and BaseThreadInitThunk respectively:\n\n\n-----\n\nWe were able to identify any other threads using these hardcoded start addresses, as such it\nbecomes trivial to identify any Brute Ratel threads on a system. To detect these threads, we\nupdated BeaconHunter accordingly to identify threads with the first two frames at\nRtlUserThreadStart+0xa and BaseThreadInitThunk+0x12:\n\n\n-----\n\n## Updated rDLL Extraction\n\nShortly after our analysis at x33fcon, Brute Ratel announced an update to the method in\nwhich the artifacts hide the reflective DLL. Analysis of these artifacts revealed that this is\nachieved using RC4 to encrypt the reflective DLL with a random key; the PE header is then\nstomped. The 8 byte RC4 key is appended to the encrypted reflective DLL, followed by 400\nbytes of base64 configuration file.\n\nWe developed the following tool targeting Brute Ratel v1.1 to extract the reflective DLL from\nDLL and EXE artifacts:\n\n\n-----\n\n```\n//\n// only works with BRC4 1.1 binaries.\n\n//\n#include <algorithm\n\n#include <windows.h>\n\n#include <cstdio>\n\n#include <string>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <sstream>\n\n#include <vector>\n\n#include <iomanip>\n\ntypedef struct _RC4_CTX {\n\n  BYTE    x, y;\n\n  BYTE    s[256];\n\n} RC4_CTX, *PRC4_CTX;\n\nstd::vector<BYTE>\n\nReadData(std::string path) {\n\n  std::ifstream instream(path, std::ios::in | std::ios::binary);\n\n  std::vector<BYTE> input((std::istreambuf_iterator<char>(instream)),\nstd::istreambuf_iterator<char>());\n\n  return input;\n\n}\n\nbool\n\nWriteData(std::string path, std::vector<BYTE> data) {\n\n  std::ofstream outstream(path, std::ios::out | std::ios::binary);\n\n  std::copy(data.begin(), data.end(), std::ostreambuf_iterator<char>(outstream));\n\n  return outstream.good();\n\n}\n\nBYTE\n\nstart_sig[]={\n\n#if defined(_WIN64)\n\n  0x55, 0x50, 0x53, 0x51, 0x52, 0x56, 0x57, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52,\n0x41, 0x53, 0x41,\n\n  0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xE4,\n0xF0, 0x48, 0x31,\n\n  0xC0, 0x50\n\n#else\n\n  0x60, 0x89, 0xE5, 0x83, 0xE4, 0xF8, 0x31, 0xC0, 0x50\n\n#endif\n\n};\n\nBYTE\n\nend_sig[]={\n\n#if defined(_WIN64)\n\n  0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41,\n0x59, 0x41, 0x58,\n\n  0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58, 0x5D, 0xC3\n\n```\n\n-----\n\n```\n#else\n\n  0x83, 0xC4, 0x10, 0x61, 0xC3\n\n#endif\n\n};\n\nvoid\n\nRC4_set_key(\n\n  PRC4_CTX c,\n\n  PVOID  key,\n\n  UINT   keylen)\n\n{\n\n  UINT i;\n\n  UCHAR j;\n\n  PUCHAR k=(PUCHAR)key;\n\n  for (i=0; i<256; i++) {\n\n    c->s[i] = (UCHAR)i;\n\n  }\n\n  c->x = 0; c->y = 0;\n\n  for (i=0, j=0; i<256; i++) {\n\n    j = (j + (c->s[i] + k[i % keylen]));\n\n    UCHAR t = c->s[i];\n\n    c->s[i] = c->s[j];\n\n    c->s[j] = t;\n\n  }\n\n}\n\nvoid\n\nRC4_crypt(\n\n  PRC4_CTX c,\n\n  PUCHAR  buf,\n\n  UINT   len)\n\n{\n\n  UCHAR x = c->x, y = c->y, j=0, t;\n\n  for (UINT i=0; i<len; i++) {\n\n    x = (x + 1);\n\n    y = (y + c->s[x]);\n\n    t = c->s[x];\n\n    c->s[x] = c->s[y];\n\n    c->s[y] = t;\n\n    j = (c->s[x] + c->s[y]);\n\n    buf[i] ^= c->s[j];\n\n  }\n\n  c->x = x;\n\n  c->y = y;\n\n}\n\nstd::vector<BYTE>\n\nextract_encrypted_rdll(PBYTE ptr, DWORD maxlen) {\n\n```\n\n-----\n\n```\n  std::vector<BYTE> outbuf;\n\n  printf(\"Searching %ld bytes.\\n\", maxlen);\n\n  for (DWORD i=0; i<maxlen;) {\n\n    if (!memcmp(&ptr[i], end_sig, sizeof(end_sig))) {\n\n      printf(\"Reached end of signature...\\n\");\n\n      break;\n\n    }\n\n  #if defined(_WIN64)\n\n    if ((ptr[i] & 0x40) == 0x40 && (ptr[i+1] & 0xB0) == 0xB0)\n\n    {\n\n      BYTE buf[8];\n\n      buf[0] = ptr[i + 9];\n\n      buf[1] = ptr[i + 8];\n\n      buf[2] = ptr[i + 7];\n\n      buf[3] = ptr[i + 6];\n\n      buf[4] = ptr[i + 5];\n\n      buf[5] = ptr[i + 4];\n\n      buf[6] = ptr[i + 3];\n\n      buf[7] = ptr[i + 2];\n\n      outbuf.insert(outbuf.end(), buf, buf + sizeof(buf));\n\n      i += (ptr[i + 10] == 0x41) ? 12 : 11;\n\n    } else i++;\n\n  #else\n\n    if ((ptr[i] & 0xB0) == 0xB0 && (ptr[i+5] & 0x50) == 0x50) {\n\n      BYTE buf[4];\n\n      buf[0] = ptr[i + 4];\n\n      buf[1] = ptr[i + 3];\n\n      buf[2] = ptr[i + 2];\n\n      buf[3] = ptr[i + 1];\n\n      outbuf.insert(outbuf.end(), buf, buf + sizeof(buf));\n\n      i += 6;\n\n    } else i++;\n\n  #endif\n\n  }\n\n     std::reverse(outbuf.begin(), outbuf.end());\n\n  return outbuf;\n\n}\n\nint\n\nmain(int argc, char *argv[]) {\n\n  if (argc != 2) {\n\n    printf(\"usage: decrypt_brc4 <DLL|EXE>\\n\");\n\n    return 0;\n\n  }\n\n  std::vector<BYTE> inbuf, infile = ReadData(argv[1]);\n\n  DWORD len=0, ptr=0;\n\n```\n\n-----\n\n```\n  if (infile.empty()) {\n\n    printf(\"Nothing to read.\\n\");\n\n    return 0;\n\n  }\n\n  do {\n\n    auto dos = (PIMAGE_DOS_HEADER)infile.data();\n\n    auto nt = (PIMAGE_NT_HEADERS)(infile.data() + dos->e_lfanew);\n\n    auto s = IMAGE_FIRST_SECTION(nt);\n\n    for (DWORD i=0; i<nt->FileHeader.NumberOfSections; i++) {\n\n      char Name[IMAGE_SIZEOF_SHORT_NAME + 1] = {0};\n\n      memcpy(Name, s[i].Name, IMAGE_SIZEOF_SHORT_NAME);\n\n      if (std::string(Name) == \".data\") {\n\n        len = s[i].SizeOfRawData;\n\n        ptr = s[i].PointerToRawData;\n\n        break;\n\n      }\n\n    }\n\n    if (!len) {\n\n      printf(\"Unable to locate .data section.\\n\");\n\n      break;\n\n    }\n\n    printf(\"Searching %ld bytes for loader...\\n\", len);\n\n    for (DWORD idx=0; idx<len - sizeof(start_sig); idx++) {\n\n      if(!memcmp(infile.data() + ptr + idx, start_sig, sizeof(start_sig))) {\n\n        printf(\"Found signature : %08lX\\n\", ptr + idx);\n\n        inbuf = extract_encrypted_rdll(infile.data() + ptr + idx, len - idx);\n\n        break;\n\n      }\n\n    }\n\n    if (inbuf.size()) {\n\n      printf(\"size : %zd\\n\", inbuf.size());\n\n      RC4_CTX c;\n\n      BYTE key[8+1] = {0};\n\n      memcpy((char*)key, inbuf.data() + inbuf.size() - 400 - 8, 8);\n\n      //\n\n      // Decrypt RDLL. The additional 400 bytes are base64 configuration.\n\n      //\n\n      RC4_set_key(&c, key, 8);\n\n      RC4_crypt(&c, inbuf.data(), inbuf.size() - 400);\n\n      //\n\n      // Fix DOS header.\n\n      //\n\n```\n\n-----\n\n```\n      inbuf[0] M ;\n\n      inbuf[1] = 'Z';\n\n      WriteData(std::string(argv[1]) + \".dll\", inbuf);\n\n    }\n\n  } while (FALSE);\n\n  return 0;\n\n}\n\n## Conclusion\n\n```\nIn summary, we’ve highlighted a number of techniques to detect Brute Ratel both in its\nartifacts, in-memory, through threat hunting and across the network. As this framework grows\nin popularity with threat actors, it is important to understand the many ways in which it can be\ndetected. As a side note, we have also illustrated how the framework takes close inspiration\nfrom the many available open source community tools; knowledge of these can assist in\nreverse engineering the framework and provide a better understanding of its capabilities (and\nby virtue its detection points).\n\n[This blog post was written Dominic Chell.](https://twitter.com/domchell)\n\nwritten by\n\n**MDSec Research**\n\n## Ready to engage\n with MDSec?\n\n[Get in touch](https://www.mdsec.co.uk/contact)\nStay updated with the latest\n\nnews from MDSec.\n\nNewsletter Signup Form\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-03 - PART 3- How I Met Your Beacon – Brute Ratel.pdf"
    ],
    "report_names": [
        "2022-08-03 - PART 3- How I Met Your Beacon – Brute Ratel.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5b748f86-ac32-4715-be9f-6cf25ae48a4e",
            "created_at": "2024-06-04T02:03:07.956135Z",
            "updated_at": "2025-03-27T02:05:17.407352Z",
            "deleted_at": null,
            "main_name": "IRON HEMLOCK",
            "aliases": [
                "ATK7 ",
                "Blue Kitsune ",
                "Cozy Bear ",
                "The Dukes",
                "UNC2452 ",
                "YTTRIUM ",
                "APT29 "
            ],
            "source_name": "Secureworks:IRON HEMLOCK",
            "tools": [
                " CozyCar",
                " CozyDuke",
                " DiefenDuke",
                " FatDuke",
                " HAMMERTOSS",
                " LiteDuke",
                " MiniDuke",
                " OnionDuke",
                " PolyglotDuke",
                " RegDuke",
                " RegDuke Loader",
                " SeaDuke",
                " Sliver",
                "CosmicDuke"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a241a1ca-2bc9-450b-a07b-aae747ee2710",
            "created_at": "2024-06-19T02:03:08.150052Z",
            "updated_at": "2025-03-27T02:05:17.409596Z",
            "deleted_at": null,
            "main_name": "IRON RITUAL",
            "aliases": [
                "Blue Dev 5 ",
                "BlueBravo ",
                "Cloaked Ursa ",
                "CozyLarch ",
                "Dark Halo ",
                "Midnight Blizzard ",
                "NOBELIUM ",
                "StellarParticle ",
                "UNC2452 ",
                "APT29"
            ],
            "source_name": "Secureworks:IRON RITUAL",
            "tools": [
                " Cobalt Strike",
                " EnvyScout",
                " GoldFinder",
                " GoldMax",
                " NativeZone",
                " RAINDROP",
                " SUNBURST",
                " Sibot",
                " TEARDROP",
                " VaporRage",
                "Brute Ratel C4"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535609,
    "ts_updated_at": 1743041755,
    "ts_creation_date": 1666529991,
    "ts_modification_date": 1666529991,
    "files": {
        "pdf": "https://archive.orkl.eu/4be0a88d4d9825547daf7401fd338aa43d8ee516.pdf",
        "text": "https://archive.orkl.eu/4be0a88d4d9825547daf7401fd338aa43d8ee516.txt",
        "img": "https://archive.orkl.eu/4be0a88d4d9825547daf7401fd338aa43d8ee516.jpg"
    }
}