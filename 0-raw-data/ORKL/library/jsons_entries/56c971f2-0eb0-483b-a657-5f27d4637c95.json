{
    "id": "56c971f2-0eb0-483b-a657-5f27d4637c95",
    "created_at": "2022-10-25T16:48:10.365411Z",
    "updated_at": "2025-03-27T02:05:32.555363Z",
    "deleted_at": null,
    "sha1_hash": "96c0fdd7ae2d5579404be846b077e1e64583ac57",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-07-10T10:26:05Z",
    "file_modification_date": "2020-07-10T10:26:16Z",
    "file_size": 3242318,
    "plain_text": "```\n |Sodinokibi\n  Malware report\n\n```\n```\nJorge Barelles Menes | Pablo Cardós Marqués\n\nAaron Jornet Sales | Javier Muñoz Alcázar\n\n```\n```\n19 | 06 | 2020\n\n```\n\n-----\n\n```\n|Index\n1. Executive report\n2. Features\n3. Entry vector\n4. Interaction with infected system\n   4.1. Privileges\n   4.2. Process Hollowing\n5. Sodinokibi\n   5.1. Obtaining Import Address Table (IAT)\n   5.2. Preparation and Mutex\n   5.3. Privilege escalation and CVE-2018-8453 Exploit\n   5.4. Process securing\n   5.5. TXT and JSON\n   5.6. List of excluded languages\n   5.7. List of processes to finalize\n   5.8. Deletion of ShadowCopies\n   5.9. Emptying of Folders\n   5.10. Encryption\n   5.11. Bitmap\n   5.12. Connection to C2 server\n6. Ransom\n7. IOC\n8. References\n\n```\n```\n2\n\n```\n\n-----\n\n```\n1. Executive report\n\n```\n**This document contains an analysis of a sample of the ransomware Sodinokibi.**\n\n**The ransomware Sodinokibi, also known as REvil, first appeared in the second half of 2019.**\nThis ransomware is characterized by its advanced evasion capacity and the large number of\n**measures that it takes to avoid being detected by antivirus engines.**\nIt has also been observed that this ransomware exploits a vulnerability in Oracle Weblogic servers.\nThis characteristic makes Sodinokibi something of an anomaly. However, like many other ransomware\nfamilies, Sodinokibi is a RaaS (ransomware as a service), which means that while one group\nmaintains and writes the code, another group delivers the malware. [3]\n**Throughout 2019, there was a progressive increase in the number of companies being attacked**\n**by cybercriminals using this ransomware.**\n\nFigure 1.1: Extract from Hoy Aragón about a Sodinokibi attack [Hackers take files hostage in\n\nZaragoza City Hall during a cyberattack] [1].\n\nFigure 1.2: Extract from noticiasseguridad.com about a Sodinokibi attack [Ransomware\n\ncloses a 100 year-old auto parts company; over 4,000 jobs lost] [2].\n```\n                                           3\n\n```\n\n-----\n\nSodinokibi has attacked a wide range of targets in a large number of countries [3]. However, the\nfocus of attacks with this ransomware has been Europe, the USA, and India.\n\nFigure 1.3: Map showing Sodinokibi attacks.\n\n**Spain is ninth on the list of most affected countries.**\n\nFigure 1.4: TOP 19 countries affected by Sodinokibi\n\n```\n4\n\n```\n\n-----\n\nDespite having been discovered in the first half of 2019, Sodinokibi was the most lucrative\n**ransomware in the last quarter of the year, earning almost 8% more than Ryuk [4].**\n\nFigure 1.5: Costs caused by ransomware in Q4 2019.\n\n```\n5\n\n```\n\n-----\n\n```\n2. Features:\n\n###### 2.1. General features JavaScript loader\n\n```\nJavaScript, which launches this ransomware, isn’t in our events, but the detection is registered on\nour systems, categorized as malware since 05/01/2019.\n\n###### MD5:3E974B7347D347AE31C1B11C05A667E2\n\nFigure 2.1: Characteristics of the MD5 referring to the JS loader.\n\nOn VirusTotal (VT), you can see that most engines classify it as a dropper. You can also see that\nother analysis platforms have detected it as the JS that launches Sodinokibi.\n\nFigure 2.2: Images from VT referring to Sodinokibi.\n```\n                                           6\n\n```\n\n-----\n\nThis JavaScript creates other Scripts and obfuscated DLLs, which it launches on the system. The\nmain aim of these is to bypass the UAC to obtain privileges and hollow the process in order to\nrun Sodinokibi. We go into more detail about this in point 4, “Interaction with infected system”.\n\n- In phase 1, it carries out this bypass using CompMgmtLauncher, which always searches for\n\na registry key, which, by default, does not exist.\n\nFigure 2.1.1. Failed registry search.\n\nThis means it will be be created with the content of one of the PowerShells (PS) that it\nwants to execute with administrator privileges.\n\nFigure 2.1.2. Creation of Key with PS content.\n\n- In phase 2, it will carrying out the process hollowing. It will try to do this on the Ahnlab\n\nantivirus.\n\nFigure 2.1.3. Structure of search of Ahnlab.\n\nGiven that it is likely that this process does not exist, another PS instance will be created\non another process to perform the action. In the image you can see how the strings are\nobtained in order, the in-memory processes are read, and how it tries to access one of\nthem.\n```\n                                        7\n\n```\n\n-----\n\nFigure 2.1.4. Search for another process.\n\n###### 2.2. Characteristics of the Sodinokibi payload\n\nThere are many variants of the payload, as well as of the loader, due to the fact that Sodinokibi\nis a RaaS (Ransomware as a Service). There are different versions of the ransomware since it is\nconstantly being updated..\nThis malware first appeared in 2019: On 04/26/2019 it was first seen in attacks on several\ncompanies.\n\nFigure 2.2: Characteristics of the MD5 referring to the Sodinokibi payload.\n\n###### 2.2.1. Technical characteristics of Sodinokibi payload\n\nis payload is an executable loaded in memory. Its main aim is to perform the most important\ntask of this ransomware: Encrypting the files and demanding a ransom for them. Within this\nexecutable there are distinct parts where you can see how it achieves all of this. We go into\nmore detail about this in section 5, “Sodinokibi”. Its most important characteristics are:\n\n  - Gathering the Import Address Table (IAT), where it will dynamically obtain all the imports\n\nthat it will use throughout the process. In the image are some of the libraries that it has\nloaded.\n\nFigure 2.2.1. Dynamically gathering IAT.\n```\n                                         8\n\n```\n\n-----\n\n**• Exploit for CVE 2018-8453, a vulnerability in Win32k, which will be used if administrator**\n\nprivileges still haven’t been achieved.\n\nFigure 2.2.2. CVE 2018-8453.\n\nIn the process, you can see how it obtains the files and attributes that it needs from\nWin32k. It then launches this exploit.\n\nFigure 2.2.3. Obtaining Win23k attributes.\n\n**• Json. This section may be the most important, as the malware relies on this file at all times**\n\nto make checks, such as: Where it has to send user information, what folders to check, what\nfiles to encrypt, etc. This file is stored in a section of Sodinokibi, as .grrr. It contains several\nways to monitor bugs, and if the Json is tampered with, the execution is aborted.\n\nFigure 2.2.4. Json in .grrr section.\n```\n                                        9\n\n```\n\n-----\n\n```\n3. Entry vector\n\n```\nThe most common way for Sodinokibi to get onto systems is through a malicious email sent as part\nof a phishing campaign. This email contains a link where the user will download a .zip file containing\nthe Sodinokibi loader. The attackers distribute the malware this way since it makes it easier to reach\nvictims. On the other hand, distributing the malware within a .zip file helps it to get around some\nmalware protections on the computer that is to be infected.\n\nThe .zip file normally contains an obfuscated JavaScript file, like the one to be analyzed in this report.\n```\n4. Interaction with infected system\n\n```\nFirstly, we can see the obfuscated JavaScript, which will be responsible for dropping, deobfuscating,\nand launching a PS script.\n\nFigure 4.1: Diagram of how the loader works.\n\nWhen executed, you can see that it launches a wscript.exe to launch the JavaScript (JS) which, in\nturn, will execute a PS that will perform a bypass to escalate privileges- This is carried out with a file\ngenerated in %temp%, called jurhrtcbvj.tmp.\n\nFigure 4.2: Execution of dropping in temp.\n```\n                                          10\n\n```\n\n-----\n\nFigure 4.3: Deobfuscation of tmp.\n\nWhen the PowerShell has finished executing, it will try to contact one of the 3 domains that can be\nseen in the following image, and will then finish.\n\nFigure 4.4: Connection to three domains\n\nThe dropped tmp jurhrtcbvj.tmp is also an obfuscated script, which first tries to deobfuscate with the\nsign “!” and then by loading a base64. You will see that it contains another string in base64, which will\nlaunch an install1() function, which will load a dll.\n\nFigure 4.5: First deobfuscation of the script.\n\nBy replacing the execution scrips with what was written in the file, we managed to deobfuscate the\nscript.\n\nFigure 4.6: Second deobfuscation\n```\n                                          11\n\n```\n\n-----\n\nand executes the content of an obfuscated variable in base64.\n\nFigure 4.7: Obfuscated Install1() containing first dll\n\n###### 4.1. Phase 1: Privileges\n\nOnce the bas64 is deobfuscated, a dll is obtained, which is responsible for bypassing the UAC seen in\nthe dynamic section in the previous point.\n\nFigure 4.1.1. Diagram of bypass\n\nFirstly, the dll checks the privileges that the processes have, since it will need administrator\npermissions to perform all the actions. To do this, by calling functions AllocateAndInitializeSid\nandCheckTokenMembership, it checks what group of users the token belongs to and, therefore, what\npermissions it has.\n\nIn the first image, you can see how an SID initializes. Once it is ready, it makes the check in step two.\nWith this, it will determine that the SID is available for the access token. As you can see, TokenHandle\nis called with the argument 0, that is, no string is specified, and the default string is used.\n```\n                                          12\n\n```\n\n-----\n\nis executed, it does not have sufficient permissions and must elevate them. This is the step before\nescalating UAC permissions.\n\nFigure 4.1.2. SID structure filling.\n\nAs mentioned above, if it does not have admin privileges, it will continue and will not reach the final\npart of the dll.\n\nFigure 4.1.3. Conditional that checks if there are admin privileges.\n\nWe reach the bypass and find two ways of carrying it out. The first function, which we have seen in the\nabove diagram, uses CompMgmtLauncher to carry out the privilege scaling if it hasn’t been able to\ncarrying out this scaling already. Since it could be patched, it will be carried out using DelegateExecute\nwith ComputerDefaults.exe, another very similar technique.\n\nIn steps, in the first function, which is the one that is carried out, it creates a new registry entry in\nSoftware\\Classes\\mscfile\\open\\command\\.\n```\n                                          13\n\n```\n\n-----\n\nFigure 4.1.4. New registry entry.\n\nThis is done since, by default, the dll searches for this registry and doesn’t find it. This is a commonly\nused technique in dll hijacking.\n\nFigure 4.1.5. Failed registry search\n\nIt then makes use of CompMgmtLauncher and explorer.exe. The aim is to create a new instance of\nexplorer.exe, which will launch CompMgmtLauncher. When it is launched, this dll will search for the\nMgmtLauncher registry. Having created a new registry entry with this name, and with the contents\nof the script, the PS will be executed with administrator permissions, given that, as you can see, this\nexecutable belongs to System32.\n\nFigure 4.1.6. CompMgmtLauncher procedure.\n```\n                                          14\n\n```\n\n-----\n\nOnce this procedure has been executed with RUNAS, it will delete the registry key to avoid being\ndetected on the system.\n**CompMgmtLauncher comes from Computer Management, i.e., mmc.exe (Microsoft Management**\nConsole), a component of Windows. This means that when the command is executed, it simply calls\nmmc.exe, and the vulnerability exploits the launcher.\n\nFigure 4.1.7. Call to mmc.exe\n\nCompMgmtLauncher has autoelevate characteristics, meaning that if an app is launched with\nthis executable, it will be launched with admin permissions. When it is executed, it seeks a registry\nkey by creating the key with a cmd and a PowerShell inside. When the system is told to execute\nCompMgmtLauncher, it will look for the key, find it, execute it, and launch the PS with admin\nprivileges.\n\nFigure 4.1.9. Characteristics of Autoelevate in CompMgmtLauncher\n\nThere is a second option: To escalate using DelegateExecute, i.e., scaling using a fileless method. In this\ncase, you can see how a key entry is carried out Software\\Classes\\ms-settings\\shell\\open\\command\\,\nwhich is done using a vulnerability where, by default, when it runs, ComputerDefaults tries to search\nfor a key Software\\Classes\\ms-settings\\shell\\open\\command\\DelegateExecute, which does not exist.\nHaving created it, when an attempt is made to execute ComputerDefaults, we get a shell with scaled\n```\n                                          15\n\n```\n\n-----\n\nIn both cases, you can see how it deletes the key once it has scaled privileges.\n\nFigure 4.1.10: Bypass DelegateExecute procedure.\n\nIf we continue to analyze the dll, you can see that in Resources, there is an encrypted PE called “Help”,\nwhich represents the process injection and process hollowing in phase 2.\n\nFigure 4.1.11: Encrypted Help function in Resources.\n\nThis PE is another dll, which is decrypted and executed again in memory. To do this, you can see that\nit uses a XOR to decrypt it. If a loop is launched, you can see how headings and the usual MZ of a PE\nappears.\n```\n                                          16\n\n```\n\n-----\n\nFigure 4.1.12: Decrypting the Help function.\n\nOnce deobfuscated in memory, we get the following dll, and can move on to phase 2.\n\n###### 4.2. Phase 2: Process Hollowing\n\nThe second loader is used to load the final payload, trying to hollow the process on the Ahnlab\nantivirus. If the computer doesn’t contain this process, the executable creates another instance of\nPowerShell where it will try to hollow another process.\nIn the red box you can see the main feature of the DLL. It first carries out a call to\n**_ServerStatusCheck with the parameters V3 Service and 0.**\n\nFigure 4.2.1. Structure of the second loader.\n\n```\n17\n\n```\n\n-----\n\nGetServerStatus with 4. We proceed to see what GetServerStatus does, which obtains “V3 Service”\nand 0 as parameters.\n\nFigure 4.2.2. Function ServerStatusCheck.\n\nThis subroutine makes a call to the function OpenSCManagerA, which carries out a connection with\nthe service manager and tries to access the“V3 Service”.\n\nIf it manages to gain access, with the function OpenServiceA it accesses the service again, and\nwith QueryServiceStatus it obtains the status of the service, which it will return as a result of\nthe subroutine. The status of the service corresponds to a numerical code, which checks that it\ncorresponds to 4, i.e., checks that the service is functioning. Once it checks that it is functioning\nand that the executable “autoup” is in the indicated path, it carries out a sleep, and finally, process\nhollowing on the service by calling StartProcessHollowing.\n\nFigure 4.2.3. Function StartProcessHollowing.\n\nIf the AV isn't installed, the call to EDRCheck launches an instance of PowerShell and tries to carry out\nprocess hollowing.\n\nFigure 4.2.4. Function EDRCheck\n```\n                                          18\n\n```\n\n-----\n\nUna vez se ha realizado el Process Hollowing, veremos, como de nuevo, vuelve a desofuscar mediante\nuna XOR, usando la misma técnica que hemos visto en la Fase 1, con el objetivo de extraer el payload\ndel Sodinokibi\n\nFigure 4.2.5. Dynamically deobfuscating the Sodinokibi payload.\n```\n5. Sodinokibi\n\n```\nOnce we have the payload, we are left with the last part of the ransomware. The main diagram of its\nphases, which we will follow in this section, and a brief summary of its parts, is the following:\n\nFigure 5.1: General diagram of Sodinokibi\n```\n                                          19\n\n```\n\n-----\n\n  - **CreateMutex: Creates a Mutex.**\n\n  - **CheckExp: Checks if it needs to escalate privileges. Exp is the value that it will check, which will**\n\nbe True or False on the Json, depending on whether or not it has sufficient privileges.\n\n  - **Exploit: Carries out Exploit CVE 2018-8453.**\n\n  - **GetProcessRun: Obtains and launches Explorer.exe.**\n\n  - **PrepareCipher: Carries out all of Sodinokibi’s tasks, obtains Json, executes language lists, lists**\n\nof processes to end, deleting ShadowCopies, etc.\n\n###### 5.1. Obtaining Import Address Table (IAT)\nAfter the two loader phases, we get the MD5 payload: B488BDEEAEDA94A273E4746DB0082841, which\nis the ransomware Sodinokibi, which is obfuscated and has no import. This means that the imports\nwill have to be obtained dynamically.\n\nFFigure 5.1.1. Imports of the sample\n\nIn the main function you can see that it carries out a call to two functions. The first of these has more\ncode, and the second carries out a dynamic call. This call is an ExitProcess, which means that the\nimportant actions are carried out in the first call.\n\nFigure 5.1.2. Function on the entrypoint.\n\nIn the first function, the first thing carried out is to dynamically import the functions of the system that\nit is going to use. To obtain them, it uses a loop to call a function, changing the entry parameters.\n\nFigure 5.1.3. Loop to obtain system functions.\n```\n                                          20\n\n```\n\n-----\n\ncorresponding library.\n\nThis function is divided into two parts; the first obtains the library and the second obtains the specific\nfunction.\n\nFigure 5.1.4. Structure of “_BuildIAT”\n\nFor the part where the library is obtained, it starts by carrying out operations on the entry parameter.\nThis number is used to go through the different nested ifs and finishes in the function that gives the\nlibrary what it has requested.\n\nFigure 5.1.5. Functions to obtain libraries.\n```\n                                          21\n\n```\n\n-----\n\nFigure 5.1.6. Function “_advapi32dll”.\n\nThis function calls odin_decrypt_string in order to get the name of the library that it wants to obtain,\nin this case advapi32.dll. Once it has the name of the library, it needs to load it in memory. For this it\nneeds the function kernel32.LoadLibrary, which is obtained by calling _BuildIAT” giving it the value\n57820074h.\n\nFigure 5.1.7 Deobfuscated string.\n\nOnce it has the address of the function kernel32.LoadLibrary, located in eax, it only has to call it,\nmoving the name of the library to the top of the stack. This will load the library in memory (if it isn’t\nalready loaded) and will return its position.\n\nFigure 5.1.8. Call to LoadLibraryA.\n```\n                                          22\n\n```\n\n-----\n\nobtained. To do this, it carries out operations using a list of functions as entry data, and obtains a\nnumber that is added to the base address of the library and obtains the function address.\n\nFigure 5.1.9. Entry data to obtain the function address.\n\nFigure 5.1.10: Obtaining the address.\n\nOnce we know how a function is obtained from a library, we can return to figure 5.1.3, where we can\nsee that it makes the loop to obtain all the system functions that it needs, and stores them, creating an\nIAT (Import Address Table).\n\nFigure 5.1.10: Creation of the IAT\n```\n                                          23\n\n```\n\n-----\n\n###### 5.2. Preparación y Mutex\n\nAlong the same lines, we see that where we had a dword, we now had an OpenProcessTokek. As you\ncan see, this brings us to all of the imports that it will run through.\n\nBefore:\n\nAfter:\n\nFigure 5.2.1. Change after obtaining the imports.\n```\n                                          24\n\n```\n\n-----\n\nAfter creating the IAT, it checks to see if it is executing in an instance of itself on the system. To do\nthis, it uses the Mutex function, using a string that it deobfuscates as an identifier. In this sample, the\nidentifier is:\n\n“Global\\\\3555A3D6-37B3-0919-F7BE-F3AAB5B6644A”.\n\nFigure 5.2.2: Mutex function\n\n###### 5.3. Privilege scaling Exploit CVE 2018-8453\n\n 5.3.1 Checking if it has to scale privileges\n\nOnce it has checked the Mutex, it checks its settings file to see whether or not it has to scale privileges.\nThis file is a Json that extracts one of its sections and will be explained below.\n\nThe parameter that indicates if it needs to scale privileges is exp. If it is false, it won’t scale privileges.\nTo know the value of exp, it processes the Json data, changing false and true into zero or one.\n\nFigure 5.3.1.1: Processed Json data\n\nThis sample doesn’t need to scale privileges because it has already scaled them, so exp:false. . It is\n**common for this kind of malware to make several checks and privilege scales in different phases**\n**in order to reach its target even without the loader, explained in point four. In this case, this**\n**exploit function was totally skipped in the execution since exp=false.**\n\n###### 5.3.2 Exploitation\n\nIn order to scale privileges, it uses the vulnerability CVE-2018-8453, which exploits a vulnerability in\nwin32k.\n\nFigure 5.3.2.1: Explanation of CVE-2018-8453\n\nIt starts by obtaining the folder containing the file needed for the exploitation, Win32k, so it needs to\nexploit the file in order to exploit it.\n```\n                                          25\n\n```\n\n-----\n\nfile containing the file via the functions Wow64DisableWow64Redirection and GetSystemDirectoryw.\n\nWow64DisableWow64Redirection makes sure the calls are not redirected to the 64bit folder and\nGetSystemDirectoryw of the system folder when it requests the system folder with a 32bit folder.\n\nFigure 5.3.2.2: Disbaling Wow64FsRedirection.\n\nThis gives the address “c:\\\\windows\\\\system32”. This joins the strings that deobfuscate win32kfull.sys\nand win32k.sys, thus obtaining the full name of the file needed to carry out the exploit.\n\nFigure 5.3.2.3: Getting the name via win32kfull.sys.\n```\n                                          26\n\n```\n\n-----\n\nexist, there is an error and it returns 0. In our case, the existing file is win32k.sys. It also checks that the\nfile is old enough to be exploited via CompareFileTime\n\nFigure 5.3.2.4: Checking files on the system.\n\nIn the following function, it will first check the architecture of the processor. The main aim is to find out\nhow much memory it needs to reserve to carry out the exploit, if it needs to do so. It reserves 38400\n(0x9600) space in memory, or if not, 13824 (0x3600).\n\nFigure 5.3.2.5: Checking architecture.\n```\n                                          27\n\n```\n\n-----\n\nexploit to the assigned space.\n\nFigure 5.3.2.6: Reserving memory.\n\nThe exploit is stored in the section .rdata, and will be copied to this section.\n\nFigure 5.3.2.7: Exploit stored in .rdata.\n\n```\n28\n\n```\n\n-----\n\nfunctions LoadLibrary and GetProcAddress. It then uses these functions to load and obtain the\naddresses of the functions that it will need to create its own IAT.\n\nFigure 5.3.2.8: Loading of libraries.\n\n```\n29\n\n```\n\n-----\n\nFigure 5.3.2.9: Diagram of the Exploit function in x32dbg.\n\n###### 5.4. Process securing\n\nWe then get to the function, renamed GetProcessRun. We can see that it obtains a process handle\n(GetCurrentProcess), given that there is a compare, before the token, to check if it already has the\ndata it needs from the process and can go to the final part. Otherwise, it opens the process token and\nobtains the information from the token with GetTokenInformation. It then closes the handle. It carries\nout all operations correctly, as, when it calls the functions, a 1 is returned. As this is NONZERO, this\nmeans that the processes are being opened correctly.\n```\n                                          30\n\n```\n\n-----\n\nFigure 5.4.1. Function to obtain a process.\n\nWe then see that it does the same, but does not check the SID dynamically. In the function, several\nsteps will have been skipped, and it will have reached the end without executing anything else. We can\nsee that it makes use of GetForegroundWindow and ShellSexecuteW, which, even dynamically, are not\nexecuted at this moment. They will later be used to capture a processes launched by the ransomware\nand to execute certain commands.\n\nFigure 5.4.2. ShellExecuteW function.\n\nIn the following function, it mainly carries out a deobfuscation. It will obtain an explorer.exe, which\nwill be used to check the SID later on, which will carry out the JMP, since, when comparing it with the\nEAX registry value, it is 3000 not 4000.\n```\n                                          31\n\n```\n\n-----\n\nFigure 5.4.3. Obtaining explorer.exe.\n\nAs a consequence of this, it skips everything else and goes straight to the XOR, which means, for now,\nwe only have one explorer.exe open, where an ID has been checked.\n\nFigure 5.4.3. Skipping to the end of the function\n\n###### 5.5. TXT and JSON\n\nn the following routine, one of the most important in the execution, we see the following:\n\nFigura 5.5.1: Función _JsonTxt.\n```\n                                          32\n\n```\n\n-----\n\nname.\n\nFigure 5.5.2. Deciphering the file extension and username.\n\nThe computer name, the domain, the language, which it will check whether it is a language like\nRussian, which we can see is FALSE, the version of the OS, disk space...\n\nFigure 5.5.3. Sample of several deciphered strings.\n\n```\n33\n\n```\n\n-----\n\nfolder, with the name info.txt and with instructions to recover encrypted files.\n\nFigure 5.5.4. Txt file.\n\nThis ransomware hides encrypted Json content in one of its sections. In this sample, the section is\ncalled “.grr”.\n\nFigure 5.5.5. Contents of the .grr section.\n\nWe can see an alphanumeric string in the first 32 bytes, which corresponds to the encryption key.\n\n```\n34\n\n```\n\n-----\n\nfollowing 2 bytes indicate the size of the contents, and the rest are part of the content itself.\n\nFigure 5.5.8. Checking the Json parameters.\n\nAs you can see, it stores the Json. After obtaining the deciphered contents, we can see that it contains\nseveral fields with different values assigned.\n\nFigure 5.5.9. Values assigned to the Json.\n\nThese values correspond to the ransomware configuration. In other words, the malware will consult\nthese fields to know what operations it can carry out, what files or directories it should carry out\noperations on, what processes it can act on...\n\nFigure 5.5.10: Values assigned to the Json.\n\nWe can see that in the “nname” field, we have {EXT}.info.txt. {EXT} will be replaced by the random\nstring generated during execution.\n```\n                                          35\n\n```\n\n-----\n\n|Field|Definition|\n|---|---|\n|pk|Attacker’s public key, obfuscated in Base64|\n|pid|Identifier for sending data to C2 servers. Only used if the“ net” field is set to“ true”.|\n|sub|Identifier for sending data to C2 servers. Only used if the“ net” field is set to“ true”.|\n|dbg|Value used by the malware author. Is referred to when trying to determine if the vic­ tim is Russian.|\n|fast|Value that determines how files bigger than 65535 should be encrypted.|\n|wipe|Value that determines whether the ransomware should delete directories specified in the“ wfld” field.|\n|wht|List of values that must not be encrypted. • ext - Extensions • fld - Directories • fls - Files|\n|wfld|Exclusion list for files to delete if the“ wipe” field contains the value“ true”.|\n|prc|Exclusion list for processes to terminate if they are running.|\n|dmn|List of C2 servers the ransomware can contact.|\n|net|Value that determines if the ransomware should send basic host and malware infor­ mation to the C2 servers.|\n|nbody|Text note obfuscated in Base64, which will be dropped in directories when the files are encrypted.|\n|nname|Name of file that will contain the note defined in the filed“ nbody”.|\n|exp|Value that determines if the ransomware needs to escalate privileges by exploiting the LPE vulnerability.|\n|img|Text obfuscated in Base64 containing the background image that will be set during encryption.|\n\n\n###### 5.6. List of excluded languages\n\nFor the keyboard, we can see that it uses a list of exclusions. It obtains a list with the identifiers for the\nkeyboard layouts using GetKeyboardLayoutList, where it will go through the languages to check that\nthey are allowed. To do this, it carries out a switch with all the languages, which will be used later for\nthe txt.\n```\n                                          36\n\n```\n\n-----\n\nFigure 5.6.1: Obtaining the exclusion list for languages.\n\nIf one of the list items coincides with one that we can see in the above image, the malware stops\nexecuting. This makes those victims with any of the observed keyboard layouts immune to the attack.\n\n###### 5.7. List of processes to terminate\n\nIn this case, we see that it takes a “photo” of the processes that are running on the system. It will\ngo through them and compare them with processes specified in the “prc” field on the JSON. If they\ncoincide, they are terminated. In our case, as we have seen in the previous point, we would only have\nmysql.exe.\n```\n                                          37\n\n```\n\n-----\n\nFigura 5.7.1: Obtención de la Lista de Procesos.\n\n###### 5.8. Deleting ShadowCopies\n\nHaving reached this point, it will carry out a function, renamed to _DeleteShadow.\n\nFigure 5.8.1. Sample of the function renamed _DeleteShadow.\n\nHere you can see how it deobfuscates interesting strings, which it will execute later on.\n\nThe most important string, already known in this ransomware family, is vssadmin.exe, which deletes\nsystem backups. This way, the victim cannot go back to a previous version of the operating system,\nand the attacker ensures that they have to pay.\n\n“0018FDE0 0018FDFC L”/c vssadmin.exe Delete Shadows /All /Quiet & bcdedit /set {default} recoveryenabled No & bcdedit /\n\nset {default} bootstatuspolicy ignoreallfailures””\n\nFigure 5.8.2. Deobfuscating the command to delete ShadowCopies.\n```\n                                          38\n\n```\n\n-----\n\nthat moment. Having carried out a new OpenProcess in explorer.exe that has enough permissions, it runs\nShellExecute as explorer.exe.\n\nFigure 5.8.3. Shows the function GetForegroundWindow.\n\nPIt will then launch the command that we have seen above.\n\nFigure 5.8.4. ShellExecute.\n\n###### 5.9. Emptying folders\n\nThis function that goes though the folders on our system, emptying them to later launch the .txt,\nleaving only encrypted files and a .txt with instructions in the folders. It will then begin encryption.\nThis function goes though the directories and compares them with those specified in the wfld field of\nthe Json. If they coincide, they are deleted.\n\n5.9.1: Function for emptying folders.\n```\n                                          39\n\n```\n\n-----\n\nThe encryption consists of four parts:\n\n1. Queue with CompletionIOPort\n2. Preparation of Keys\n3. Encryption of files (Salsa20)\n4. Release of file, key written at the end of file and renamed.\n\n5.10.1: Diagram of encryption routine.\n\nThis ransomware uses several strings at all times to carry out its tasks, streamlining encryption.\n\nFirstly, before beginning the encryption process, it adds CompletionRoutineStub to the stack, which is\nthe routine containing calls to encryption functions.\n\n5.10.2: Sample of the function that adds CompletionRoutineStub to the stack.\n\nOnce added, a queue structure is created with CreateIOCompletionPort. This queue allows it to\nmanage the file handles that are needed for the encryption. For this it receives the number of strings,\nthe key, and the handle. It then introduces the structure into a string.\n\n5.10.3: Sample of the function that creates the structure for the IOCompletionPorts.\n```\n                                          40\n\n```\n\n-----\n\nOnce added, it introduces the ransom file data in memory (CreateRescueFile) and the encryption\nroutine (CipherRoutine). It then goes through the disks on the system. This is done with the function\nrenamed EnumeraDisco, until it finds a valid one to begin encryption. This routine will go through the\ndirectories and will chose them to leave the ransom txt file in these folders and subfolders.\n\n5.10.4: Sample of the function to enumerate disks and directories.\n\nIt generates the encryption extension, which it will use to rename the encrypted files. As you can\nsee, it collects the parameter “*”, which means that it will collect all possible files, using the function\n_FindFile to do this.\n\n5.10.5: Sample of the function to change file extension.\n```\n                                          41\n\n```\n\n-----\n\nmemory all the information that it has already stored in the TXT. It will write it on each of the folders\nand subfolders.\n\n5.10.6: Sample of writing of encrypted file on execution.\n\nOnce it has all the folders with all the txts, it will enter the encryption routine, which contains functions\nlike the one that generates the keys. Before generating the keys, it will check if the file extension is\nvalid for encryption from among those in the Json settings file. Firstly, it will check that the size of the\nfile to encrypt is less than 1048576 bytes.\n\n5.10.7: Sample of the extensions, directories, and files that shouldn’t be encrypted.\n\n5.10.8: Sample of the function to check the file size.\n```\n                                          42\n\n```\n\n-----\n\nvalue is indicative of two attributes. The first corresponds to FILE_FLAG_OVERLAPPED (0x40000000),\nwhich indicates that the file will be treated asynchronously. This way the file buffer will be added to\nthe queue created by the IOCompletionPorts, where its contents will be encrypted. The second value\n(0x08000000) corresponds to FILE_FLAG_SEQUENTIAL_SCAN, which indicates the access to the file will\nbe sequential from start to end.\n\nThe ransomware will then generate a unique key for each file. The keys are generated using AES and\nelliptical Curve. It will generate Private/Public keys for both affiliate and developer. It will generate\nanother pair of keys for the user. The user’s private key will be encrypted the affiliate public key with\nAES. The user’s private key is again encrypted, but this time with the developer’s public key. The\nuser’s private key is deleted from the memory, and the 2 affiliate and developer public keys are saved.\nThe user’s public key will also remain.\n\nWhen encrypting a file, it will generate another pair of unique keys per file. Of these, only the private\nkey will be used. This key is used to generate a SharedKey using the user public key. It will carry out a\nSHA3 for the SharedKey and will encrypt the file. It will then save the PubKey of the file and the end\nwhen everything is encrypted.\n\nIt will then call the CompletionRoutineStub routine that was previously added to the stack. This\nroutine will use the CompletionIOPorts to encrypt by creating different strings, in which each file\nto be encrypted will be introduced in different threads using a POST method. This means there is a\nglobal string where there will be a structure with the file information. Several strings with different\nfile queues to encrypt will be created, meaning that, at all times, we’ll see how files are introduced\nasynchronously into stings on the one hand, and what they are called, and how they are encrypted\nand closed on the other hand.\n\n5.10.9: Sample of the function to execute the encryption function via CompletionIOPorts.\n```\n                                          43\n\n```\n\n-----\n\n5.10.10: Pseudo-code of the encryption algorithm.\n\nFinally, as we have discussed above, it introduces the file’s PubKey (unique for each file) at the end of\nall of them. It will release the file and finally modify its extension.\n```\n                                          44\n\n```\n\n-----\n\nThe function to prepare the bitmap that it sets as the computer’s background creates a compatible\nbitmap. It is created by choosing sources, pixels etc. It is constructed using a loop, adding characters\nand the final sentence that will send us to the ransom note.\n\nFigure 5.11.1. Creation of bitmap.\n```\n                                          45\n\n```\n\n-----\n\nthe path seen above, creating the object with CreateFileW and WriteFile\n\nFigure 5.11.2. Obtaining the path.\n\nThe end result will be seeing a background like this on our desktop, telling us to read the informative\ntxt that has already been dropped in all possible folders on our computer.\n\nFigure 5.11.3. Sample of desktop with bitmap.\n```\n                                          46\n\n```\n\n-----\n\nOnce it has changed the background, it will try to make connections to C2 servers. Its main aim will be\nto send information about the victim to these servers. We can see that it introduces the addresses of\nall the servers that we have previously seen on the loaded Json.\n\nFigure 5.12.1. List of C2 servers.\n\nOnce inside, it loads the URLs in memory.\n\nFigure 5.12.2. List of URLs loaded in memory.\n\nIt generates the paths for the URLs using a loop. We’ll see extensions like .jpg or .png, which will be the\nencrypted information about the victim.\n\nFigure 5.12.3. URLs and information about the encrypted computer.\n```\n                                          47\n\n```\n\n-----\n\nthe list has been added, which will be the target for sending all the data.\n\nFigure 5.12.4. Relevant information before being sent to the C2 server.\n\n```\n48\n\n```\n\n-----\n\n```\n6. Rescate\n\n```\nIn order to rescue our files, once we’ve read the note left in one of the files where the ransomware has\nbeen, we need to download a TOR browser, introduce the key left in the document, and we’ll be given\ninstruction on how to recover our files. To do this, we have to make a payment in bitcoins or Monero\nwithin 7 days.\n\nFigure 6.1: Instructions for recovering data.\n```\n                                          49\n\n```\n\n-----\n\n```\n7. IOC\n\n```\n**• MD5:**\n\n3E974B7347D347AE31C1B11C05A667E2\nB488BDEEAEDA94A273E4746DB0082841\nBED6FC04AEB785815744706239A1F243\n1CE1CA85BFF4517A1EF7E8F9A7C22B16\n1524B237E65D52AA7E2ADD5DBDCC7C05\nA81961697199A3F9524A0F874E281612\n512B538CE2C40112009383AE70331DCF\nE6566F78ABF3075EBEA6FD037803E176\n\n**• Ransom file:**\n\n<random_hash>info.txt\n\n**Example: zaoi6xao08r.bmp**\n\n**• Desktop bitmap file:**\n\n<random_hash>.bmp\n\n**Ejemplo: zaoi6xao08r.bmp**\n\n**• Examples of encrypted file extensions:**\n\n*.jpg.<random_hash>\n*.png.<random_hash>\n*.reg.<random_hash>\n*.xml.<random_hash>\n\n**Example: álbum.mp3.e4cqobv5o**\n\n**• Related URLs:**\n\nsuitesartemis.gr\nrename.kz\njefersonalessandro.com\nbanukumbak.com\npourlabretagne.bzh\nazerbaycanas.com\nlesyeuxbleus.net\nbrannbornfastigheter.se\nkryddersnapsen.dk\n\n```\n50\n\n```\n\n-----\n\n```\n8. References\n\n```\n[1] - “Unos hackers secuestran archivos del Ayuntamiento de Zaragoza en un ciberataque.” https://\nwww.hoyaragon.es/noticias-zaragoza-aragon/hackers-ayuntamiento-zaragoza/\nPublished 11/20/2019\n\n[2] - “RANSOMWARE CIERRA UNA EMPRESA FABRICANTE DE PIEZAS DE AUTO CON MÁS DE 100 AÑOS\nDE ANTIGÜEDAD; MÁS DE 4 MIL EMPLEOS PERDIDOS”  https://noticiasseguridad.com/hackingincidentes/ransomware-cierra-una-empresa-fabricante-de-piezas-de-auto-con-mas-de-100-anos-deantiguedad-mas-de-4-mil-empleos-perdidos/\nPublished 1/24/2020\n\n[3] - “McAfee ATR Analyzes Sodinokibi aka REvil Ransomware-as-a-Service – What The Code Tells Us”\nhttps://www.mcafee.com/blogs/other-blogs/mcafee-labs/mcafee-atr-analyzes-sodinokibi-aka-revilransomware-as-a-service-what-the-code-tells-us/\nPublished 10/2/2019\n\n[4] - “ThreatList: Ransomware Costs Double in Q4, Sodinokibi Dominates”\nhttps://threatpost.com/threatlist-ransomware-costs-double-in-q4-sodinokibi-dominates/152200/\nPublished 1/24/2020\n```\n                                          51\n\n```\n\n-----\n\n```\nMore information:\n\n###### https://www.pandasecurity.com/business/\n\n```\n**U.S. SALES  1.800.734.9905    INTERNATIONAL SALES +1.206.613.0895**\n\n\n**www.watchguard.com | pandasecurity.com**\n\n\nNo express or implied warranties are provided for herein. All specifications are subject to change and any expected future products, features, or functionality will be provided on an/if and when available\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.pandasecurity.com/emailhtml/2007-CAM-RANSOMWARE-AD360-WG/2006-Report-Sodinokibi-EN.pdf"
    ],
    "report_names": [
        "2006-Report-Sodinokibi-EN.pdf"
    ],
    "threat_actors": [
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716490,
    "ts_updated_at": 1743041132,
    "ts_creation_date": 1594376765,
    "ts_modification_date": 1594376776,
    "files": {
        "pdf": "https://archive.orkl.eu/96c0fdd7ae2d5579404be846b077e1e64583ac57.pdf",
        "text": "https://archive.orkl.eu/96c0fdd7ae2d5579404be846b077e1e64583ac57.txt",
        "img": "https://archive.orkl.eu/96c0fdd7ae2d5579404be846b077e1e64583ac57.jpg"
    }
}