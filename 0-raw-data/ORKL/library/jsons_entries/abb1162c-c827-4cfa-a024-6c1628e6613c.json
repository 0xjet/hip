{
    "id": "abb1162c-c827-4cfa-a024-6c1628e6613c",
    "created_at": "2023-01-12T15:09:24.112131Z",
    "updated_at": "2025-03-27T02:09:29.514422Z",
    "deleted_at": null,
    "sha1_hash": "914840bedddb9400d39ebf6d1db9f6a0668d0e82",
    "title": "2019-01-17 - Qealler — The Silent Java Credential Thief",
    "authors": "",
    "file_creation_date": "2022-05-27T22:55:07Z",
    "file_modification_date": "2022-05-27T22:55:07Z",
    "file_size": 2067155,
    "plain_text": "# Qealler — The Silent Java Credential Thief\n\n**[cyberark.com/threat-research-blog/qealler-the-silent-java-credential-thief/](https://www.cyberark.com/threat-research-blog/qealler-the-silent-java-credential-thief/)**\n\nJanuary 17, 2019\n\nQealler is a new type of malware that CyberArk Labs recently detected in a spam campaign\ntargeting corporate mailboxes in the UK. At first sight, it looks to be a simple, harmless file\nthat can be detected by antivirus software. However, our analysis shows that there’s more to\nit.\n\nQealler very efficiently hides a dropper and credential stealing script. Bypassing antivirus\nprotection, it can capture more than 20 third-party software and Windows credentials and\nuse them to access sensitive files.\n\nIn this blog, we’ll share our malware analysis – including insight into the information returned\nto the attacker. We’ll also share best practices for protecting against it.\n\n**Qealler in the Wild**\n\nFigure 1 Older Qealler samples found, only 5/61 positives on VirusTotal (VT).\n\n\n-----\n\n[Qealler was first detected in August 2018 by James_inthe_box[ ]](https://www.cyberark.com/#_edn1) [fig. 1] and determined to be\nmainly hosted on UK websites. Since it has a very low engine detection rate, as shown in the\nscreenshot above, a lot of antiviruses consider it to be a safe file and don’t block it. In short,\nthe door is open for the execution of this malware without any problems.\n\n[As seen in the detected samples in figure 2 from URLhaus,[ii]](https://www.cyberark.com/#_edn2) Qealler disguises itself as a\n[Remittance Advice File[iii].](https://www.cyberark.com/#_edn3) _URLhaus is a project by abuse.ch with the goal of sharing_\nmalicious URLs being used for malware distribution.\n\n\nFigure 2 URLs hosting the malware are from UK.\n\nMost recently, we detected Qealler in a spam campaign targeting UK users. As you can see\nin figure 1, it’s mostly present as a Jar file, which is a package file format typically used to\naggregate many Java class files and their associated metadata and resources (text, images,\netc.) into one file for distribution. It’s acting as an executable running in the Java Virtual\n[Machine[iv].](https://www.cyberark.com/#_edn4)\n\n**Technical Analysis**\n\nQealler can be difficult to detect because of its high-level and multi-layer self-encryption,\nwhich has different keys for each malware sample coupled with tricky obfuscation in every\nsub-file. This means that it can decrypt and compile itself in multiple steps. Basically, using a\nsignature-based approach, as most of the anti-viruses do for this kind of malware, would not\nprotect against other Qealler samples.\n\nHere we’ll examine the recent sample we found:\n[61a8b7f9260d163d0f20059bf21d6c55954ee77b0588610bfab4907dd964cf6a[v].](https://www.cyberark.com/#_edn5)\n\nThe first question is: how do we know it’s a malicious file? Some versions have a really low\ndetection rate on VirusTotal (VT) [fig. 1]. Moreover, when we ran it for the first time, nothing\nseemed to happen. If we run it a second time, a message box [fig. 3] appears. That’s strange\nfor remittance advice.\n\nLet’s see what we can learn from procmon logs about its behavior.\n\n\n-----\n\nFigure 3 What happens when Qealler is run more than two times.\n\nUsing procmon, we see that Qealler is trying to communicate with\n**146[.]185[.]139[.]123:7766, but fails. Indeed, this IP was already down the day of the**\nanalysis. Instead, we’ll try to use the first IP in the table in figure 2 (i.e.,\n**159[.]65[.]84[.]42:11530), which was online at the time of writing this. How can we redirect**\nall the packets sent to the active server?\n\nFigure 4 ProxyCap configuration to redirect IP.\n\n[In our case, we use ProxyCap[vi]. ProxyCap enables you to redirect your computer’s network](https://www.cyberark.com/#_edn6)\nconnections through proxy servers. You can tell ProxyCap which applications to connect to\nthe internet through a proxy and under what circumstances. This is done through a userfriendly interface without the need to reconfigure any of your internet clients.\n\n\n-----\n\nFigure 5 Successfully redirected packet and received packets!\n\nConfiguring ProxyCap is an easy game. You have to define two things: 1.) the proxy server\n– the destination IP address where redirected packets should be sent; and 2.) the rule – the\nindicator needed to spot, according to their initial destination IP addresses, which packets to\nredirect . After configuring ProxyCap [fig. 5], let’s try to open the Qealler file again and check\nthe behavior on procmon.\n\nCongratulations! The redirection was a success and, in return, we received a packet\ntriggering a new set of events from Qealler. Let’s dig into the huge procmon log for more\ngood stuff.\n\nOne thing we like to check before everything else when using procmon is the process create\nevent.\n\nFigure 6 Process created by Qealler.\n\nQealler created two processes [fig.6]:\n\n… executable, decompressing another file in the windows temporary folder referred as\n%TEMP%. The exact command executed by this executable is:\n```\n%TEMP%\\7z_<RANDOM_NB>.exe x %TEMP%\\_<RANDOM_NB>.tmp -o %TEMP% \n-p \"<PW>\" -mmt -aoa -y\n\n```\nexe executed with the following parameters:\n```\n%TEMP%\\qealler\\python\\Python.exe %TEMP%\\qealler\\qazagne\\main.py all\n\n```\nLooking at the first process created, it appears Qealler is decrypting a password-protected\nfile using 7z after receiving a packet from the server. Procmon logs give us more information:\nQealler has created four files: three related to 7zip executable (two dlls and one executable)\nand the password-protected archive So finally Qealler is either including those files (using a\n\n\n-----\n\npacker[ ]) or downloading them. The second option seems more logical if we look at the size\nof the malware. First, let’s dive deeper into this archive and then reverse Qealler to\nunderstand the exact way it works.\n\nFigure 7 File tree of the downloaded archive using TreeSize.\n\nThe password-protected archive contains two folders [fig. 7]. One contains a python script\ncalled Qazagne and the other contains the python software with all of the libraries required\nto run the script.\n\nThe script is not called Qazagne for nothing. Indeed, the script is a compact version of the\n[famous credential recovery tool Lazagne.[viii]](https://www.cyberark.com/#_edn8) The LaZagne project is an open source\napplication used to retrieve lots of passwords stored on a local computer [fig. 8]. Each\nsoftware stores its passwords using different techniques (plaintext, Windows APIs, custom\nalgorithms, databases, etc.). This tool was developed for the purpose of finding these\npasswords for the most commonly used software. The output is a list of credentials in JSON\nformat.\n\nWhy does Qealler steal all those credentials? Why is it bypassing AVs? Is it a dropper or a\npacked malware? Let’s dig deeper.\n\n\n-----\n\n[Figure 8 Lazagne credentials target very similar to Qazagne target [ix].](https://www.cyberark.com/#_edn9)\n\n**Reversing Qealler**\n\nIn order to learn more about Qealler’s inner workings, we decided to reverse it. A JAR\narchive can be easily decompressed using different tools (WinRAR, JarExplorer, Java\nDecompressor etc.). Once decompressed, you get all the compiled Java class files. The next\nstep is to decompile them with tools like JD-Eclipse, Cavaj Java Decompiler or JBVD. Let’s\napply this to our sample.\n\n\n-----\n\nFigure 9 Content inside the Jar archive decompressed with JavaDecompressor.\n\nAt a first look [fig. 9], the files obtained from JavaDecompressor seem weird. There’s only\none class file (com.aglyphodonta.naiadaceous.Piezoelectric) and other files with unknown\nextensions. In other words, the files seem to be encrypted.\n\n[Let’s focus on the Piezoelectric.class file and decompile it with JBVD[x]](https://www.cyberark.com/#_edn10) . The decompiled\nsource code obtained [fig. 10] is quite simple. It uses the ScriptEngineManager object\nconfigured in Javascript mode in order to execute the script defined in the abettors’ variable.\n\n\n-----\n\nFigure 10 Decompiled Piezoelectric file.\n\nThe serious part begins now. The JavaScript part [fig. 11] is our key to decrypt some of the\nencrypted files in the archive. As you can see in figure 11, it is obfuscated. Nonetheless, the\nmain function calls (purple) and their definitions in the java documentation suggest that it’s a\ndecryption process and you can identify the decryption key as well. The variable [fig. 11] in\ngreen contains everything:\n\nDecrypted class package name: enterprise.reaqtor.reaqtions.standartbootstrap\nDecrypted class name: Header\nFile to decrypt: com/agliphodonta/eparchies/Reticulatocoalescent.ski\nFile size in bytes: 6251\nDecryption key: xml1JzxHQcBFVSiJ\n\n\n-----\n\nFigure 11 JS script embedded in the main java class.\n\nSo, now we have everything. The script decrypted the file\n_com/agliphodonta/eparchies/Reticulatocoalescent.ski using AES-256 with the key_\nxml1JzxHQcBFVSiJ.\n\nThe decrypted file (with a file size of 6256 bytes) is saved in a file called Header (also the\nname of the class) in the package qua.enterprise.reaqtor.reaqtions.standartbootstrap. Finally,\nthe class is instantiated and executes the constructor and main function of the Header Class.\n\nNow that we understand the behavior, we can easily write a function that does the same\nthing and save the decrypted file in order to be able to read it.\n\n\n-----\n\nFigure 12 Script to decrypt the Reticulatocoalescent.ski file.\n\nThe output of our script [fig.12] is a java class called Header. It contains a map. By changing\nthe source code a little to look at the content stored in the map object, we discovered that it\nstores all the remaining encrypted files and their original file names. It was not clear at first\nbecause it uses the map to decrypt only three files (Head, Loader$1 and Loader$1$1) out of\na lot of files.\n\nAnother important point is that there are not only AES encrypted files this time (using a\ndifferent key than before), but also a Gzip compressed file. Even with the high obfuscation,\nwe can still identify the next decrypted class that will be instantiated afterwards (aka Head\nclass).\n\nNow that we know the map contains all of the remaining files, what happens if we can do it\nall over again, but this time add in some code to save all the files in the decryption function?\nWe tried and obtained something astonishing.\n\n\n-----\n\nFigure 13 Files obtained decrypting all the content of the map.\n\nThe result is, as you can see [fig. 12], very obfuscated. Moreover, a lot of obfuscation\nmechanisms are used: useless functions with long and closed names; functions that return\nthe object itself; filenames above 256 characters, which cause problems with a lot of\nsoftware (including Windows Explorer); etc.\n\n\n-----\n\nWe could have spent a lot of time refactoring and simplifying the code to have something\nthat can at least be compiled (though still obfuscated), but instead we chose to analyze the\nmalware’s behavior based on the static analysis (i.e., looking for static analysis’ indicators in\nthe reverse source code).\n\nFigure 14 Encrypted URL found in the source code.\n\nLet’s quickly look at those files to see if something can help us. In this type of malware, you’ll\nusually look for the next stage it will download from a URL or unpack from within. Indeed,\nfigure 13 contains the variables found in one of the obfuscated files. Clearly, we can detect\ntwo important variables: LIB_7Z_URL and LIB_QEALLER_URL, which prove that Qealler is\na dropper.\n\nThanks to our knowledge of the behavior so far, in the Head file, which is the real main class,\nwe easily spotted the part of the code responsible for downloading 7z and the Qealler\narchive from the server [fig. 13], decompressing it and executing the python Qazagne script.\nMoreover, after the execution of the script, Qealler is looking for #ff# and #fs# strings in the\noutput of the python script.\n\nInterestingly, that is exactly what we got: a JSON format output with those strings at the start\nand the end of the output. These are clearly not correct JSON syntax and so there must be a\ndifference between the original Lazagne script and this compressed and fake one. All the\nimportant information is between those tags.\n\nThe next step is to send them to the server. From there, we got everything from the script :\nthe JSON is encrypted using AES 256 bytes again with another key and the packet data will\ncontain “output=XXX” with XXX being the encrypted message. We found it on Wireshark and\nusing decryption on it with the key found by reversing Qealler gives you the exact content of\nthe JSON.\n\n**Mitigation**\nSo how do we protect against similar threats? A multi-layer protection strategy is best.\n\nAn updated and well-configured antivirus solution should be your first wall of defense. While\nan antivirus will detect and block some threats, dynamic, rapidly evolving and highly\nobfuscated threats like Qealler will likely go undetected.\n\nCase in point: In June, only 5 out of 61 well known and widely deployed AV engines detected\nit as a threat [fig.2]. As Qealler’s old samples signatures are being added to AV databases,\nQealler can still improve and reinforce its obfuscation mechanism so that it can continue to\nbypass AV signatures.\n\n\n-----\n\nMoreover, AVs and a lot of protection tools have been built to block known attacks and\nattacks using the same techniques, but cannot block new attacks. As a consequence, AVs\nare clearly not enough.\n\nQealler executes a python script targeting sensitive resources. Having defense in depth on\nthe endpoint is a good way to prevent this kind of new attack. For example, solutions like\nCyberArk’s Endpoint Privilege Manager (EPM) can protect endpoint credential stores that\nreside in memory, registry or files. EPM also has the ability to block lateral movement like\nPass-the-hash, Pass-the-ticket and more. With this product, it does not matter if the malware\nbypasses traditional security protections: you can rest assured that critical resources are\nprotected.\n\n[[i]](https://www.cyberark.com/#_ednref1) [https://twitter.com/James_inthe_box/status/1035190253697396737](https://twitter.com/James_inthe_box/status/1035190253697396737)\n\n[[ii]](https://www.cyberark.com/#_ednref2) [https://urlhaus.abuse.ch/browse/tag/Qealler/](https://urlhaus.abuse.ch/browse/tag/Qealler/)\n\n[[iii]](https://www.cyberark.com/#_ednref3) [https://en.wikipedia.org/wiki/Remittance_advice](https://en.wikipedia.org/wiki/Remittance_advice)\n\n[[iv]](https://www.cyberark.com/#_ednref4) https://www.javaworld.com/article/3272244/core-java/what-is-the-jvm-introducing-thejava-virtual-machine.html\n\n[[v]](https://www.cyberark.com/#_ednref5)\nhttps://www.virustotal.com/#/file/61a8b7f9260d163d0f20059bf21d6c55954ee77b0588610bfa\nb4907dd964cf6a/detection\n\n[[vi] http://www.proxycap.com/](https://www.cyberark.com/#_ednref6)\n\n[[vii] https://en.wikipedia.org/wiki/Executable_compression](https://www.cyberark.com/#_ednref7)\n\n[[viii] https://github.com/AlessandroZ/LaZagne](https://www.cyberark.com/#_ednref8)\n\n[[ix] https://github.com/AlessandroZ/LaZagne](https://www.cyberark.com/#_ednref9)\n\n[[x] https://github.com/Konloch/bytecode-viewer](https://www.cyberark.com/#_ednref10)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-01-17 - Qealler — The Silent Java Credential Thief.pdf"
    ],
    "report_names": [
        "2019-01-17 - Qealler — The Silent Java Credential Thief.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536164,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653692107,
    "ts_modification_date": 1653692107,
    "files": {
        "pdf": "https://archive.orkl.eu/914840bedddb9400d39ebf6d1db9f6a0668d0e82.pdf",
        "text": "https://archive.orkl.eu/914840bedddb9400d39ebf6d1db9f6a0668d0e82.txt",
        "img": "https://archive.orkl.eu/914840bedddb9400d39ebf6d1db9f6a0668d0e82.jpg"
    }
}