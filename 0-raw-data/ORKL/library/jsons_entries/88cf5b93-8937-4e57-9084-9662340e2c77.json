{
    "id": "88cf5b93-8937-4e57-9084-9662340e2c77",
    "created_at": "2023-03-03T02:06:24.726084Z",
    "updated_at": "2025-03-27T02:06:08.716892Z",
    "deleted_at": null,
    "sha1_hash": "50f9d81ff426402bb4450c0bc839efb5ae93c37a",
    "title": "2023-02-05 - Analysing A Sample Of Arechclient2",
    "authors": "",
    "file_creation_date": "2023-03-01T09:12:07Z",
    "file_modification_date": "2023-03-01T09:12:07Z",
    "file_size": 1786478,
    "plain_text": "# Analysing A Sample Of Arechclient2\n\n**[dr4k0nia.github.io/posts/Analysing-a-sample-of-ArechClient2/](https://dr4k0nia.github.io/posts/Analysing-a-sample-of-ArechClient2/)**\n\nPosted Feb 5, 2023 Updated Feb 5, 2023\nBy _[dr4k0nia](https://twitter.com/dr4k0nia)_\n_11 min read_\n\n\nFebruary 5, 2023\n\n\nIn this post, I will be going over my process of analyzing a sample of ArechClient2.\nIncluding initial analysis, deobfuscation and unpacking of the loader. Followed by the\nanalysis of the .NET payload revealing its config and C2 information.\n\n[It began with this tweet by](https://twitter.com/Gi7w0rm/status/1614440406405496836) [@Gi7w0rm. They mentioned me and a few others asking for help](https://twitter.com/Gi7w0rm)\nanalyzing this sample. I decided to look into the sample. After publishing some threat intel\nand a few updates on my re progress on Twitter, I decided to write this report for a more\n[detailed documentation of my analysis. The original sample can be found here.](https://tria.ge/230115-by7fcscb6w)\n\n## Initial Analysis\n\nThe sample consists of two files, an executable and an a3x file. After some quick research,\nI found that a3x is a “compiled” form of AutoIt script. The executables icon is the logo of\nAutoIt and the copyright information says it’s AutoIt. This leads me to believe that this\nexecutable is the runtime required to execute the a3x file.\n\nI ran the file in a Windows Sandbox, for some quick intel and immediately got a Windows\nDefender hit for MSIL:Trojan... which indicates that this AutoIt part is just a loader for a\nsecond stage .NET binary. In case you are not familiar with the terms, “MSIL” stands for\nMicrosoft Intermediate Language, which is the bytecode that .NET binaries are compiled to.\n\nThe a3x script is human-readable. So after putting it into Visual Studio Code I saw this.\n\n\n-----\n\nIt looks pretty messy at first but taking a closer look I found something that stuck out: The\ncalls to the function called DoctrineDrama look suspiciously like string decryption. So my\nnext step was to find that function, I used the search function to look for it’s name until I\nfound the actual implementation. All functions start with the keyword Func and end with the\nkeyword EndFunc, making it easy for us to identify them. I copied the code of the\n```\nDoctrineDrama function to a separate file. The code is obfuscated and seems to contain\n\n```\nquite some junk code. My first step was to indent the code, for easier readability.\n\nLooking at the code, specifically the switch cases inside the loops, I realized that only the\nbranches that use ExitLoop are of importance. Taking a look at the switch conditions\nconfirmed that suspicion. At the beginning of the function, the second variable is the loop\ncondition, it’s initialized with a value of 921021. Looking at the switch, it matches the case\nthat exits the loop, meaning the other cases are dead code and can be ignored. I removed\nthe dead branches, cleaned up the unnecessary loops and got rid of the unused variables:\n\n\n-----\n\nAfter cleaning up we are left with this code. Reading this we can deduce some more fitting\nvariable names, the first argument seems to be the encrypted input, and the second\nargument is the key. The first variable is the resulting string. So to understand the rest of the\ncode I looked at the documentation of AutoIt, the StringSplit function, takes the following\narguments: A string, a delimiter char and an optional argument for the delimiter search\nmode. So the second local variable in DoctrineDrama is an array of strings split from the\ninput. Next, the code iterates through all the elements of that array and appends a new\ncharacter to the output string with every iteration. We see a call to a function called Chr,\nwhich according to documentation converts a numeric between 0-255 value to an ASCII\ncharacter. But something is off, what is going on inside that call to Chr? subtraction on a\nstring, how does that work? I wondered about that but after a quick web search, I found out\nthat in AutoIt digit only strings seem to be auto-converted to a number if you perform any\narithmetic operation on them. Once the loop is finished, the output string is returned.\n\nLooking at this fully cleaned-up version, I reimplemented the decryption routine in C# to\nbuild a simple deobfuscator.\n\n\n-----\n\n```\n  static string Decrypt(string input, int key)\n\n  {\n\n    var buffer = input.Split('h');\n\n    var builder = new StringBuilder();\n\n    for (int i = 0; i < buffer.Length; i++)\n\n    {\n\n      builder.Append((char)(Convert.ToInt32(buffer[i])   key));\n\n    }\n\n    return builder.ToString();\n\n  }\n\n```\nThe deobfuscator uses a simple regex pattern to match every call to DoctrineDrama and\nreplace it with the decrypted string. It also outputs a list of all decrypted strings. The full\n[deobfuscator code can be found here.](https://gist.github.com/dr4k0nia/447fb1c5c7e8791ee877fd1090a6f5e5)\n\n## Dumping the payload\n\nAfter deobfuscating all the strings, I searched the string dump for some Windows API\nfunction names that I would expect from a loader. I found a few hits on NtResumeThread,\n```\nCreateProcessW and NtUnmapViewOfSection. These three in combination give a huge hint\n\n```\ntowards process hollowing. After searching the string dump for .exe I found the suspected\ninjection target \\Microsoft.NET\\Framework\\v4.0.30319\\jsc.exe, a utility of .NET\nFramework 4.x which comes with every standard Windows 10 install.\n\nMy next step was to debug the executable using x64Dbg. I set a breakpoint on\n```\nCreateProcessW, to ensure we break before the injection process is started. After running\n\n```\npast the entry point I was greeted with this nice little message.\n\n\n-----\n\nThe message box claims I violated a EULA which I never read nor agreed to. I guess we\ncan’t debug the malware any further how unfortunate. Luckily for us, x64Dbg has a built-in\nAutoIt EULA bypass, it’s called Hide Debugger (PEB). You can find it under\nDebug>Advanded>Hide Debugger (PEB). Make sure to run x64Dbg in elevated mode.\n\nAfter dealing with the rather simple anti-debug, we let it run. When debugged, the\nexecutable spawns a file dialog asking for an a3x file, when run without a debugger it\nautomatically finds the script file. After pointing it to the script file we let it run until the\nbreakpoint for CreateProcessW is hit. At this point, jsc.exe will be started in suspended\nmode. Checking Process Explorer confirms that the decrypted path from the AutoIt script\nwas indeed the injection target. We add another breakpoint on NtResumeThread which will\nbreak execution after the injection is finished but before the thread is resumed to execute\nthe malware.\n\nSince we already know the malware is .NET-based I will use ExtremeDumper to get the\nmanaged payload from the jsc.exe process. Run ExtremeDumper as admin and dump\n```\njsc.exe, if it does not show up make sure you are using the x86 version of\n\n```\nExtremeDumper. At the time of writing the loader does not run anymore but fails with an\nerror message about Windows updates. Sifting through the string dump I suspect there is\nsome sort of date check that prevents further execution. This was likely implemented to\nprevent future analysis. Luckily I had dumped the actual payload before.\n\n## The .NET Payload\n\n\n-----\n\nAfter dumping the loader, I had to deal with the managed payload. The image is heavily\nobfuscated. I started my hunt in the <Module> class also referred to as the global type. I\nstart by checking this class since its constructor is called before the managed entry point.\nMany obfuscators call their runtime protections or functions like string decryption here.\n\nMy guess was correct, I found a string decryption method c in <Module> (token\n```\n0x06000003). The method reads the encrypted string data from an embedded resource and\n\n```\nthen performs a single XOR operation decryption on it. The key used for decryption is\nsupplied via parameters, which leads me to believe that each string has a unique decryption\nkey.\n\nAfter checking references to c it turned out that the decryption relies on flow-dependent\nvariables. The calls to the decryption routine have encrypted arguments that are using\nseveral opaque predicates and global variables that are initialized and changed depending\non call flow.\n\nThis means we would have to emulate or solve all calculations required to obtain the local\nvariables and global fields that are used by the expressions that decrypt the arguments of\nthe call to our decryption method c. The additional dependency on call flow further\nincreases the effort required since we would need to solve all calculations in every method\nin the correct order. Considering all this I ditched the idea of writing a static string decryption\ntool.\n\n\n-----\n\nSifting through the binary I found quite a few similarities to Redline, both making use of\nDataContracts and async tasks for the separate stealer modules.\n\nOne class in particular seemed interesting. After looking for networking related functions I\nfound a class cj token 0x0200010C that connects to a server via .NET’s TcpClient. Looking\nat the code we can spot the use of another class called xj which seems to contain the IP\nand port number for the TCP connection. See line 155 tcpClient.Connect(xj.c,\n```\nConvert.ToInt32(xj.a.d)\n\n```\n\n-----\n\nApart from that xj also seems to contain a URL that the malware accesses and downloads\na string from, see line 168. Let’s take a closer look at xj token 0x02000107. It contains quite\na few properties but the most interesting is the constructor.\n\nThis looks like a potential config class. It initializes the properties used for the initial TCP\nconnection and the string download we saw in cj, which is a good indicator that we are\nindeed looking at the malwares config. I placed a breakpoint at the end of the constructor.\nSince the string decryption method was still an issue the easiest way to get the strings was\nto run the binary and have it decrypt the strings for me. I debugged the executable using\n\n\n-----\n\ndnSpy until I hit the breakpoint at the end of the constructor. After the breakpoint hit we can\nview all the properties and fields values in the Locals window by expanding the this\nparameter.\n\nHere we see the C2 IP 77.73.133.83 and port 15647. We can also see a Pastebin link, that\ncaught my interest: The paste contains another IP 34.107.35.186, potentially a fallback C2.\n\nBefore debugging, I modified the string decryption method by adding a few lines to write\nevery decrypted string to disk. This modification makes it so that instead of immediately\nreturning the string it’s first passed to AppendAllText and written to a file of our choice.\n\n\n-----\n\nThe dump revealed the same values that we found in the Locals window and a few more\nstrings of interest. For example, we got a list of the paths that the stealer checks for\npotential credentials. The main targets of this stealer seem to be browsers, mail clients and\ngame clients like Steam. This is similar to most mainstream stealers. You can view the fullstring dump [here.](https://pastebin.com/pjBNEQDw)\n\nSpeaking of strings, I noticed another similarity to Redline, the use of char array to string\nconversion at runtime. Although Redline in many cases does insert some additional junk\ninto these arrays that is removed from the constructed string, using the Replace or Remove\nmethod.\n\nDue to the heavy obfuscation and the rather similar behavior to existing stealers, I decided\nto not investigate this payload further. We revealed the most important IOCs and got a\npretty good understanding of the stealer’s targets.\n\n## Summary\n\nWe found that the initial loader was implemented in AutoIt and uses ProcessHollowing to\nload a .NET-based payload, we reconstructed the string decryption method enabling us to\npartially deobfuscate the loader. We dumped the managed payload using a debugger and\nExtremeDumper. We analyzed and debugged the managed payload to reveal the payload\nconfig, containing the C2 information.\n\nAfter analyzing the string dump, I found some indicators that could help with attribution to a\ncertain malware family. Although this sample does look very similar to Redline stealer, it is\nactually not part of that family. I found this blob of data that looked suspiciously like C2\ncommunication:\n\n\n-----\n\n```\n  {\"Type\":\"ConnectionType\",\"ConnectionType\":\"Client\",\"Session\n  ID\":\"\n\n  \",\"BotName\":\"\n\n  \",\"BuildID\":\"\n\n  \",\"BotOS\":\n\n  \"Caption\",\"URLData\":\"\n\n  \",\"UIP\":\"\n\n  \"}\n\n```\n[Referencing the above data and the port number to other writeups, like this one from](https://www.ironnet.com/blog/key-findings-from-defending-the-noc-at-black-hat-europe-2022)\nIronNet Threat Research, revealed similarities to a different malware family. The screenshot\nbelow shows a network capture of an active ArechClient2 sample performed by the\nresearchers from IronNet. Comparing this data we can conclude that our sample is also part\nof the ArechClient2 family.\n\n_[image source](https://www.ironnet.com/blog/key-findings-from-defending-the-noc-at-black-hat-europe-2022)_\n\nWith this we have reached the end of our analysis. Below, I have arranged all important\nIOCs, for the threat intel focused readers. I write these reports in my freetime and publish\n[them for free, if you want to support my work feel free to sponsor me on GitHub.](https://github.com/dr4k0nia)\n\n## IOCs\n\n\n-----\n\n**Description** **Indicator**\n\nC2 `77.73.133.83:15647`\n\n\nPotential\nFallback C2\n\nURL for\nfallback C2\n\n.NET\npayload\n```\nTest.exe\n\n```\nAutoIt\nloader\n```\n45.exe\n\n```\nAutoIt script\n```\nS.a3x\n\n```\n```\n34.107.35.186:15647\nhttps://pastebin.com/raw/NdY0fAXm\n\n```\nSHA256:\n```\na835602db71a42876d0a88cc452cb60001de4875a5e91316da9a74363f481910\n\n```\nSHA256:\n```\n237d1bca6e056df5bb16a1216a434634109478f882d3b1d58344c801d184f95d\n\n```\nSHA256:\n```\n8e289b8dfc7e4994d808ef79a88adb513365177604fe587f6efa812f284e21a3\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-05 - Analysing A Sample Of Arechclient2.pdf"
    ],
    "report_names": [
        "2023-02-05 - Analysing A Sample Of Arechclient2.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809184,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1677661927,
    "ts_modification_date": 1677661927,
    "files": {
        "pdf": "https://archive.orkl.eu/50f9d81ff426402bb4450c0bc839efb5ae93c37a.pdf",
        "text": "https://archive.orkl.eu/50f9d81ff426402bb4450c0bc839efb5ae93c37a.txt",
        "img": "https://archive.orkl.eu/50f9d81ff426402bb4450c0bc839efb5ae93c37a.jpg"
    }
}