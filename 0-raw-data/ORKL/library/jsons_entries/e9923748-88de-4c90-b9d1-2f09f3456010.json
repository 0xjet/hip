{
    "id": "e9923748-88de-4c90-b9d1-2f09f3456010",
    "created_at": "2023-01-12T15:06:09.363394Z",
    "updated_at": "2025-03-27T02:09:30.352218Z",
    "deleted_at": null,
    "sha1_hash": "4ba5020021731a8eec3ddf5b08d8b959e80a1a2b",
    "title": "2022-03-14 - Reversing Common Obfuscation Techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T02:35:33Z",
    "file_modification_date": "2022-05-28T02:35:33Z",
    "file_size": 542395,
    "plain_text": "# Reversing Common Obfuscation Techniques 14/03/2022\n\n**ferib.dev/blog.php**\n\n\n-----\n\nModern software often deploys obfuscation as part of its anti-tampering strategies to prevent\nhackers from reversing critical components of the software. They often use multiple\nobfuscation techniques to harden against hackers, kind of like a snowball. Adding more\nlayers of snow increases the size, making it a bigger pain in the ass to penetrate.\n\nIn this article, we will have a close look at two common obfuscation techniques to understand\nhow they work and figure out how to deobfuscate/undo them.\n\n## Project UnSnowman\n\nThat's right, we will be looking into the two different obfuscation techniques as listed below.\n\n## IAT Import Obfuscation\n\nBefore we start with the actual obfuscation of the IAT import table, let me explain what\nimports really are.\n\n\n-----\n\n### What are imports?\n\nOne of the first things I'd like to figure out about a program when I'm reversing is where it\ninvokes the Operating System. In our case, we will focus on Windows 10 as most video\ngames are only working on a Windows-based operating system. Anyway, for those who\ndidn't know yet, Windows provides a bunch of important Dynamic Linked Library (DLL) files\nthat almost every Windows executable uses. These DLLs contain functions that can be\n'imported' by Windows executables, allowing them to load and execute the function of a\ngiven DLL.\n\n### Why are they important?\n\nNtdll.dll for example is responsible for almost all memory-related functionality such as\nopening a handle to a process (NtOpenProcess), allocating a memory page (NtVirtualAlloc,\nNtVirtualAllocEx), querying memory pages (NtVirtualQuery, NtVirtualQueryEx), and a lot\nmore interesting stuff one may need.\n\nAnother such DLL is the ws2_32.dll, which is responsible for almost any network activity by\nusing one of the following functions:\n\nSocket\nConnect / WSAConnect\nSend / WSASend\nSendTo / WSASendTo\nRecv / WSARecv\nRecvFrom / WSARecvFrom\n\nNow you may ask, what's the point of knowing this? Well, if you take a binary and throw it\ninto a disassembler such as IDA, the first thing a person like me does is check all the\nimported functions to have a rough idea of what the binary is capable of. For example, when\nws2_32.dll is present in the imports then the binary may connect to the internet.\n\nWe may now want to take a deeper look and also check which ws2_32.dll functions are\nused. If we take the Socket function and find out where it's called we can check its\narguments, allowing us to easily figure out which protocol and type are used after we google\nthe function name.\n\n\n-----\n\n_NOTE: IDA has automatically added comments to the disassembly._\n\n### Obfuscated Imports\n\nAnyway, those Windows functions reveal quite a lot of information as they are welldocumented functions. Therefore one may want to hide its presence to hide what is going\non.\n\nAll these imports you may see in your disassembler are loaded from the Import Address\nTable (IAT), which is referenced somewhere inside the PE headers of the executable. Some\nmalware/games try to hide these import addresses by not pointing to the DLL function\ndirectly. Instead, a trampoline or detour function may be used.\n\n### Examining our Sample\n\nFor this example, we are looking at a sample that is using a trampoline-ish obfuscation, as\nyou can see below:\n\n\n-----\n\nThe address below, `0x7FF7D7F9B000 which references our function` `0x19AA1040FE1 is`\nlooking completely different. You may think this is junk code, but have a good look and you\nwill find out it's not.\n\nTake a good look at the first two instructions, starting with `mov rax, FFFF8000056C10A1`\nfollowed by `jmp 19AA1040738, except everything after that is complete junk. Anyway, let's`\ntake that jump and see where it takes us to:\n\nLook at that, 4 more valid instructions, this time it's an XOR and 2 ADDs followed by yet\nanother jump. Let's repeat this process a few more times...\n\n\n-----\n\nFinally, we reached a `jmp rax instruction! In case you didn't notice, all the XOR, SUB, and`\nADD instructions have been performed on that Rax register, meaning that this may contain\nthe actual pointer of our imported function. Let's do the math and find out.\n\n\n-----\n\nAnd indeed, after doing the math we obtain the pointer to `ADVAPI32.RegOpenKeyExA,`\ncheers!\n\nNow, all we have to do is repeat this a few hundred times and we have completely\ndeobfuscated the IAT import tables.\n\n### Automated IAT Deobfuscation\n\nI don't think any of you want to repeat this process by hand using the calculator, doing it once\nwas already a pain in the ass. From now on we will be using C# to automate the calculations\nfor us. As you may have seen we only faced ADD, SUB, and XOR operations that were done\non the same register. The reason for that is Rax is used as a return address whereas\nregisters such as Rcx, Rdx, R8, R9, and some others are not callee safe and may conflict\n\n\n-----\n\nwith the calling conventions. This means we won t even need a disassembler as we can\neasily differentiate these instructions ourselves thanks to the minimal usage of registers and\nopcodes.\n\nI'm afraid I won't go into any more details as I explained the obfuscation technique in much\ndetail.\n\n## Control-Flow Obfuscation\n\nAnother valuable source of information while reversing a binary is the assembly instructions\nthemselves. For humans, they may be hard to understand, but for decompilers such as IDA,\nwe can simply press F5 and IDA will generate that oh-so-sweet pseudo-code that we\nhumans can understand.\n\nOne easy way to obfuscate the actual instructions is by using a combination of junk-code\ntogether with opaque branching. What this means is that you put junk code right after a\nbranch instruction. The trick is that you use a conditional jump, however, you make sure that\nthe condition is always true so the branch is always taken. What the disassembler doesn't\nknow is that the conditional jump will always be true at runtime, making it believe both sides\nof the conditional jump can be reached during runtime.\n\nOkay if you're not quite following then let me show you some visuals to help you understand.\nThe first image shows `jbe which lands inside another instruction.`\n\n_NOTE: The red marked bytes are junk code._\n\n\n-----\n\nNow take a deep look at the second image below, all I did here was NOP the two bytes of\nthe last instruction so that my IDA reveals the hidden instruction underneath the `and`\n```\n[rdx+24448B48h], bh instruction.\n\n```\nWe may also patch the conditional jump with an unconditional one to make sure IDA won't\nfall for it again.\n\nBefore we continue I would like to show one last example as the previous one was a very\nbasic one. Things become a lot more complicated when you start chaining these obfuscated\njumps into each other, as you can see in the image below.\n\n\n-----\n\nThis image only shows the chaos it creates in the control flow, but just imagine how hard my\nCPU was suffering while IDA did its very best to create this graph based on junk instructions.\n\nNow you may wonder what the deobfuscated functions look like? I'm glad you asked!\n\n\n-----\n\nSee that little blue arrow I drew on the left side? that shows what the right part is zoomed in\non. Now have a look at the right side and you will see seven deobfuscated jumps in just that\nsmall part of the function. Just imagine how much time one would need to deobfuscate this\nmanually or semi-automated (IDA script to NOP jmp). Doing that one by hand using an IDA\nscript took me already 40 minutes... and that's just for one damn function. Imagine how many\nother functions I would need to do to find what I was actually looking for!\n\n### Automated Control-Flow Deobfuscation\n\nOkay, so now that we have a good understanding of how it works we just need to automate\nit. As I mentioned before, I used an IDA Script before to just patch the unconditional jumps\nand NOP slide the junk out.\n\nHowever, this still took me 40 minutes to clean as the hardest part was to identify the opaque\nbranches. So how do we solve this? You may think we should examine every conditional\njump and check if it's opaque, then NOP slide and repeat? WRONG!\n\n\n-----\n\nLet me tell you a secret, we don t give a shit about what s opaque or whatnot. All I really care\nabout is that my IDA can give me decompiled code when I hit F5, which indeed won't happen\nas long as these obfuscated jumps force junk to collide into real assembly instructions.\n\nBut does that mean we need to figure out if a conditional jump is opaque or not? nope, all we\nneed to do is check if the jump collides inside an existing instruction and then patch out that\ninstruction as seen in our first example.\n\n**DeFlow Deobfuscation Algorithm**\n\nNow that we know how to solve the issue we can start diving into the algorithm I came up\nwith to deobfuscate all instances for this kind of obfuscation.\n\n\n-----\n\n```\nList<ulong> _alreadyDiscovered;\n// Buffer is a copy of the .text section\nfunction Deflow(byte[] buffer, ulong[] functions)\n for(int i = 0; i < functions.Length; i++)\n  do\n   int newDiscovered = 0;\n   List<ulong> chunks = DeflowChunk(buffer, functions[i]);\n   while(chunks.Count != 0)\n    List<ulong> newChunks;\n    foreach(var c in chunks)\n     newChunks.AddRange(DeflowChunk(buffer, c));\n    newDiscovered += chunks.Count;\n    chunks = newChunks;\n  while (newDiscovered != 0)\nfunction DeflowChunk(address)\n List<ulong> newChunks;\n // 63th bit indicates if this address was extracted from a negative jump or not\n bool isNegative = address >> 63 == 1; \n address &= 1 << 63;\n // Check if already discovered\n if(_alreadyDiscovered.Contains(address))\n  return newChunks;\n _alreadyDiscovered.Add(address);\n ulong lastBranch = 0;   // Indicates our last conditional jump address\n ulong lastBranchSize = 0; // Size of the last conditional jump address\n ulong lastTarget = 0;   // Target location of the last conditional jump\n int stepsLeft = 0;     // Steps (bytes) left to reach lastTarget from current\naddress\n // Usage of SharpDisasm\n var disasm = new Disassembler(buffer, address - base); // NOTE: base = BaseAddress\n+ .text offset\n foreach(var insn in disasm.Disassemble())\n  ulong target = 0;\n  ulong lastAddrStart\n  bool isJmp = true;\n  switch(insn.Mnemonic)\n   // Stop analysing when we encounter a invalid or return instruction while we\nhave no lastTarget\n   case ud_mnemonic_code.Invalid:\n   case ud_mnemonic_code.Ret:\n    if(lastTarget == 0)\n     return newChunks; // Only accept when no lastTarget as we may be looking at\njunk code\n    break;\n   case ud_mnemonic_code.ConditionalJump: // all conditional jumps\n\n```\n\n-----\n\n```\n    if(lastTarget  0)\n     target = calcTargetJump(insn); // Helper to extract jump location from\ninstruction\n     if(!isInRange(target)) // Helper to see if target address is located in our\nBuffer\n      isJmp = false;\n      break;\n     // Check if instruction is bigger then 2, if so it wont be obfuscated but\nwe \n     // do want to analyse the target location \n     if(insn.Length > 2)\n      isJmp = false;\n      newChunks.Add(target);\n      break;\n    else\n     isJmp = false; // Do not this conditional jump accept while we already \n              // have a target (might be looking at junk code)\n    break;\n   case ud_mnemonic_code.UnconditionalJump:\n   case ud_mnemonic_code.Call:\n    if(lastTarget == 0)\n     ulong newAddress = calcTargetJump(insn); // Helper to extract jump location\nfrom instruction\n     if(!isInRange(newAddress))\n      isJmp = false;\n      break;\n     // Add target and next instruction IF not JMP (CALL does return, JMP not)\n     if(insn.Mnemonic == ud_mnemonic_code.Call)\n      newChunks.Add(address + insn.PC); \n     // Add instruction target for further analyses\n     newChunks.Add(newAddress);\n     return newChunks;\n    break;\n  // quick mafs\n  ulong location = (address+insn.Offset);\n  stepsLeft = (int)(lastTarget - location); // Only valid if we have a lastTarget!\n  // Setup a new target if current instruction is conditional jump while there is\nno lastTarget\n  if(lastTarget == 0 && isJmp)\n   lastBranch = loction;\n   lastBranchSize = insn.Length;\n   lastTarget = target;\n  else if (stepsLeft <= 0 && lastTarget != 0)\n   // if stepsLeft isn't zero then our lastTarget is located slighlt above us, \n   // meaning that we are partly located inside the previous instruction and thus\nwe are hidden (obfuscated)\n   if(stepsLeft != 0)\n\n```\n\n-----\n\n```\n    int count lastTarget lastBranch; // calculate how much bytes we are in\nthe next instruction\n    if(count > 0) \n     // making sure we are a positive jump\n     int bufferOffset = lastBranch - base; // subtract base from out address so\nwe can write to our local buffer\n     // NOP slide everything except our own instruction\n     if(int i = 0; i < count - lastBranchSize; i++) \n      buffer[bufferOffset + lastBranchSize + i] = isNegative ? 0x90 : 0xCC; //\nWe use NOP for negative jumps \n                                         //\nand int3 for positive\n     if(!isNegative)\n      buffer[bufferOffset] = 0xEB; // Force unconditional Jump \n     // add next instruction for analyses and exit current analysis\n     newChunks.Add(lastTarget);\n     return newChunks;\n    else \n     // we are a negative jump, set 63th bit to indicate negative jump\n     lastTarget = |= 1 << 63; \n     // add target to analyser and exit current analysis\n     newChunks.Add(lastTarget);\n     return newChunks;\n   else\n    // stepsLeft was zero, meaning there is no collision\n    // add both target address and next instruction address so we can exit\ncurrent analysis\n    newChunks.Add(lastBranch + lastBranchSize);\n    newChunks.Add(lastTarget);\n    return newChunks;\n return newChunks;\n\n```\n_NOTE: this is pseudo-code, I am aware it doesn't run! (seriously)_\nPretty big huh? little more difficult to understand than the IAT Import deobfuscation as we\nused an actual disassembler library to get the size and mnemonic of each instruction. Using\nthe disassembler is almost a must as we also had to figure out if an instruction collided with\neach other.\n\nThere are plenty of comments in the pseudo-code to give you a better understanding of how\nthings should work. You may now also take a look at the real (Deflow algorithm) used in the\nUnsnowman repo.\n\n**DeFlow Algorithm Explained**\n\nThe main function will keep track of already discovered chunks while it recursively invokes\n```\nDeflowChunk for the linear disassembly. Keeping track of newly discovered chunks is done\n\n```\nthrough lists and loops as it would trigger a StackOverflow due to the high amount of\n\n\n-----\n\nbranching instructions that can be done in a single block.\n\nThe `DeflowChunk will first check if we encounter a given branching instruction and perform`\none of the following actions if so\n```\n   Ret - Stop if no lastTarget is set\n   Invalid - Stop if no lastTarget is set\n   ConditionalJump - Calculate target address and follow if in range of our buffer\n   UnconditionalJump - Calculate target address and save for further analysis if in\n\n```\nrange of our buffer\n```\n   Call - Calculate target address and save for further analysis if in range of our buffer\n\n```\nIn case we don't have a `lastTarget set we will check if the current instruction is a`\n```\nConditionalJump that jumps within the range of our buffer ( isJmp flag) and set the\nlastTarget to the destination of the ConditionalJump .\n\n```\nOnce we have such `lastTarget we take our current instruction pointer and subtract it by`\n```\nlastTarget to calculate how many more bytes we need to disassemble ( stepsLeft ).\n\n```\nAfter calculating the `stepsLeft we check if the value equals zero. If the value is above`\nzero we will continue the linear disassembly.\n\nWhen the `stepsLeft is below zero it means that the assembly has collided with the next`\ninstruction. This most likely means that our last `ConditionalJump that was responsible for`\nsetting our `lastTarget is an opaque condition, meaning our current chunk will most likely`\nnever be executed and is instead used to overlap the next few legit assembly instructions.\n\nWe can fix this by patching the first byte of our `ConditionalJump to` `0xEB, making it an`\n```\nUnconditionalJump . To clean things up a little more we also patch all bytes between the\n\n```\nlast `ConditionalJump and` `lastTarget .`\n\nThis process is then repeated multiple times for every call or conditional jump it finds during\nits linear disassembly process.\n\n## Conclusion\n\nNot only malware but also legitimate software like video games tend to use these kinds of\nobfuscation techniques to hide as much valuable information in the hope to prevent the\nreversal of the software. However, as you have seen we have successfully deobfuscated\nthese two techniques and were able to reveal all hidden information.\n\nOriginally I was going to benchmark a popular video game where one instance is the original\nbinary and then benchmark again but with a deobfuscate binary - which should use fewer\nresources due to removal of junk and opaque branching - to then see how much of a\n\n\n-----\n\nperformance impact these obfuscation techniques have. But due to my legal history, I\ndecided not to do so.\n\nAnyway, we can still conclude that these obfuscation techniques do a very good job of\nwasting my valuable time, which is a good way to prevent people from reversing software.\nOn top of that, the Deflow algorithm itself takes several minutes/hours (depending on the file\nsize) to deobfuscate the complete control flow of a binary.\n\nWith that being said I hope you learned something from my journey.\nOh and for those who didn't notice, or in case you scrolled all the way down to find a\ndownload link... you can find the [Unsnowman source code at my GitHub, cheers!](https://github.com/ferib/Unsnowman)\n_You can study the DeFlow pseudo-code instead ;)_\n```\nHave something to say?\nContact me at admin@ferib.be\nMore Articles\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-14 - Reversing Common Obfuscation Techniques.pdf"
    ],
    "report_names": [
        "2022-03-14 - Reversing Common Obfuscation Techniques.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535969,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653705333,
    "ts_modification_date": 1653705333,
    "files": {
        "pdf": "https://archive.orkl.eu/4ba5020021731a8eec3ddf5b08d8b959e80a1a2b.pdf",
        "text": "https://archive.orkl.eu/4ba5020021731a8eec3ddf5b08d8b959e80a1a2b.txt",
        "img": "https://archive.orkl.eu/4ba5020021731a8eec3ddf5b08d8b959e80a1a2b.jpg"
    }
}