{
    "id": "4403bf71-5766-41d0-9c3d-27451a4c46da",
    "created_at": "2023-01-12T15:00:35.202391Z",
    "updated_at": "2025-03-27T02:05:41.386235Z",
    "deleted_at": null,
    "sha1_hash": "9e4e37d18fd55ca613fc2b7189ac01eea7ceec27",
    "title": "2021-05-05 - VB6 P-Code Disassembly",
    "authors": "",
    "file_creation_date": "2022-05-29T10:48:20Z",
    "file_modification_date": "2022-05-29T10:48:20Z",
    "file_size": 341477,
    "plain_text": "# VB6 P-Code Disassembly\n\n**decoded.avast.io/davidzimmer/vb6-p-code-disassembly/**\n\nby [David ZimmerMay 5, 202118 min read](https://decoded.avast.io/author/davidzimmer/)\n\n\nMay 5, 2021\n\n\nIn this article we are going to discuss the inner depths of VB6 P-Code disassembly and the\nVB6 runtime.\n\nAs a malware analyst, VB6 in general, and P-Code in particular, has always been a problem\narea. It is not well documented and the publicly available tooling did not give me the clarity I\nreally desired.\n\nIn several places throughout this paper there may be VB runtime offsets presented. All\noffsets are to a reference copy with md5: `EEBEB73979D0AD3C74B248EBF1B6E770` [1].\nMicrosoft has been kind enough to provide debug symbols with this version for the\n```\n.ENGINE P-Code handlers.\n\n```\nTo really delve into this topic we are going to have to cover several areas.\n\nThe general layout will cover:\n\nhow the runtime executes a P-Code stream\nhow P-Code handlers are written\nprimer on the P-Code instruction set\ninstruction groupings\ninternal runtime conventions\nhow to debug handlers\n\n## Native Opcode Handlers & Code Flow\n\nLet’s start with how a runtime handler interprets the P-Code stream.\n\n\n-----\n\nWhile in future articles we will detail how the transition is made from native code to P-Code.\nFor our purposes here, we will look at individual opcode handlers once the P-Code\ninterpretation has already begun.\n\nFor our first example, consider the following P-Code disassembly:\n\nHere we can see two byte codes at virtual address `0x401932 . These have been decoded`\nto the instruction `LitI2_Byte 255 .` `0xF4 is the opcode byte.` `0xFF is the hardcoded`\nargument passed in the byte stream.\n\nThe opcode handler for this instruction is the following:\n\nWhile in a handler, the `ESI register will always start as the virtual address of the next byte`\nto interpret. In the case above, it would be `0x401933 since the` `0xF4 byte has already`\nbeen processed to get us into this handler.\n\nThe first instruction at `0x66105CAB will load a single byte from the P-Code byte stream`\ninto the `EAX register. This value is then pushed onto the stack. This is the functional`\noperation of this opcode.\n```\nEAX is then cleared and the next value from the byte stream is loaded into the lower part\n\n```\nof `EAX (AL) . This will be the opcode byte that takes us to the next native handler.`\n\nThe byte stream pointer is then incremented by two. This will set `ESI past the one byte`\nargument, and past the next opcode which has already been consumed.\n\nFinally, the `jmp instruction will transfer execution to the next handler by using the opcode`\nas an array index into a function pointer table.\n\nNow that last sentence is a bit of a mouth full, so lets include an example. Below is the first\nfew entries from the `_tblByteDisp table. This table is an array of 4 byte function pointers.`\n\n\n-----\n\nEach opcode is an index into this table. The *4 in the jump statement is because each\nfunction pointer is 4 bytes (32 bit code).\n\nThe only way we know the names of each of these P-Code instructions is because\nMicrosoft included the handler names in the debug symbols for a precious few versions of\nthe runtime.\n\nThe snippet above also reveals several characteristics of the opcode layout to be aware of.\nFirst note, there are invalid slots such as opcode `0x01-InvalidExCode . The reason for`\nthis is unknown, but it also means we can have some fun with the runtime such as\nintroducing our own opcodes [5].\n\nThe second thing to notice is that multiple opcodes can point to the same handlers such as\nthe case with `lblEX_Bos . Here we see that opcode 0 leads to the same place as opcode`\n2. There are actually 5 opcode sequences which point to the `BoS (Beginning of`\nStatement) handler.\n\nThe next thing to notice is that the opcode names are abbreviated and will require some\ndeciphering to learn how to read them.\n\nFinally from the `LitI2_Byte handler we already analyzed, we can recognize that all of the`\nstubs were hand written in assembler.\n\nFrom here, the next question is how many handlers are there? If each opcode is a single\nbyte, there can only be a maximum of 256 handlers right? That would make sense, but is\nincorrect.\n\nIf we look at the last 5 entries in the `_tblByteDisp table we find this:`\n\nThe handler for each of these looks similar to the following:\n\n\n-----\n\nHere we see `EAX zeroed out, the next opcode byte loaded into` `AL and the byte code`\npointer ( ESI ) incremented. Finally it uses that new opcode to jump into an entirely different\nfunction pointer table.\n\nThis would give us a maximum opcode count of `(6*256)-5 or` `1531 opcodes.`\n\nNow luckily, not all of these opcodes are defined. Remember some slots are invalid, and\nsome are duplicate entries. If we go through and eliminate the noise, we are left with around\n```\n822 unique handlers. Still nothing to sneeze at.\n\n```\nSo what the above tells us is that not all instructions can be represented as a single\nopcode. Many instructions will be prefixed with a lead byte that then makes the actual\nopcode reference a different function pointer table.\n\nHere is a clip from the second `tblDispatch pointer table:`\n\nTo reach `lblEX_ImpUI1 we would need to encode` `0xFB as the lead byte and` `0x01 as`\nthe opcode byte.\n\nThis would first send execution into the `_lblBEX_Lead0 handler, which then loads the`\n```\n0x01 opcode and uses tblDispatch table to execute lblEX_ImpUI1 .\n\n```\nA little bit confusing, but once you see it in action it becomes quite clear. You can watch it\nrun live for yourself by loading a P-Code executable into a native debugger and setting a\nbreakpoint on the lead* handlers.\n\n## Byte stream argument length \n\nBefore we can disassemble a byte stream, we also need to know how many byte code\narguments each and every instruction takes. With `822 instructions this can be a big job!`\nLuckily other reversers have already done much of the work for us. The first place I saw this\ntable published was from Mr Silver and Mr Snow in the `WKTVBDE help file.`\n\nA codified version of this can be found in the Semi-VbDecompiler source [2] which I have\nused as a reference implementation. The opcode sizes are largely correct in this table,\nhowever some errors are still present As with any reversing task refinement is a process of\n\n\n-----\n\ntrial and error.\n\nSome instructions, 18 known to date, have variable length byte stream arguments. The\nactual size of the byte stream to consume before the next opcode is embedded as the two\nbytes after the opcode. An example of this is the `FFreeVar instruction.`\n\nIn this example we see the first two bytes decode as `0x0008 (little endian format), which`\nhere represents 4 stack variables to free.\n\n## Opcode Naming Conventions\n\nBefore we continue on to opcode arguments, I will give a brief word on naming conventions\nand opcode groupings.\n\nIn the opcode names you will often see a combination of the following abbreviations. The\nbelow is my current interpretation of the less intuitive specifiers:\n\nOpcode abbreviation Description\n\nImp Import\n\nAddress\n\nSt / Ld Store / Load\n\nI2 Integer/Boolean\n\nI4 Long\n\nUI1 Byte\n\nLit Literal(ie “Hi”,2,8 )\n\nCy Currency\n\nR4 Single\n\nR8 Double\n\nStr String\n\nFn Calls a VBA export function\n\nFPR Floating point register\n\nPR Uses ebp-4C as a general register\n\n\n-----\n\nVar Variant\n\nRf Reference\n\nVCall VTable call\n\nLateID Late bound COM object call by method ID\n\nLateNamed Late bound COM Object call by method name\n\nSpecifiers are often combined to denote meaning and opcodes often come in groups such\nas the following:\n\nAn opcode search interface such as this is very handy while learning the VB6 instruction\nset.\n\n## Opcode Groups\n\nThe following shows an example grouping:\n\nOpcode abbreviation Description\n\nForUI1 Start For loop with byte as counter type\n\nForI2 With integer counter, default step = 1\n\nForI4 Long type as counter\n\nForR4\n\n\n-----\n\nForR8\n\nForCy\n\nForVar\n\nForStepUI1 For loop with byte counter, user specified step\n\nForStepI2\n\nForStepI4\n\nForStepR4\n\nForStepR8\n\nForStepCy\n\nForStepVar\n\nForEachCollVar For each loop over collection using variant\n\nForEachAryVar For each loop over array using variant\n\nForEachCollObj For each loop over collection using object type\n\nForEachCollAd\n\nForEachVar\n\nForEachVarFree\n\nA two part series on the intricacies of how For loops were implemented is available [3] for\nthe curious.\n\nAs you can see, the opcode set can collapse down fairly well once you take into account\nthe various groupings. While I have grouped the instructions in the source, I do not have an\nexact number as the lines between them can still be a bit fuzzy. It is probably around 100\ndistinct operations once grouped.\n\nNow onto the task of argument decodings. I am not sure why, but most P-Code tools only\nshow you the lead byte, opcode byte, mnemonic. Resolved arguments are only displayed if\nit is fully handled.\n\nEverything except Semi-VBDecompiler [6] skips the display of the argument bytes.\n\nThe problem arises from the fact no tool decodes all of the arguments correctly for all of the\nopcodes yet. If you do not see the argument byte stream, there is no indication other than a\nsubtle jump in virtual address that anything has been hidden from you.\n\n\n-----\n\nConsider the following displays:\n\nThe first version shows you opcode and mnemonic only. You don’t even realize anything is\nmissing. The second version gives you a bigger hint and at least shows you no argument\nresolution is occurring. The third version decodes the byte stream arguments, and resolves\nthe function call to a usable name.\n\nObviously the third version is the gold standard we should expect from a disassembler. The\nsecond version can be acceptable and shows something is missing. The first version leaves\nyou clueless. If you are not already intimately familiar with the instruction set, you will never\nknow you are missing anything.\n\n## Common opcode argument types\n\nIn the Semi-VbDecompiler source many opcodes are handled with custom printf type\nspecifiers [4]. Common specifiers include:\n\nFormat specifier Description\n\n%a Local argument\n\n%l Jump location\n\n%c Proc / global var address stored in constant pool\n\n%e Pool index as P-Code proc to call\n\n%x Pool index to locate external API call\n\n%s Pool index of string address\n\n%1/2/4 Literal byte, int, or long value\n\n%t Code object from its base offset\n\n%v VTable call\n\n%} End of procedure\n\nMany opcodes only take one or more simple arguments, `%a and` `%s being the most`\ncommon.\n\n\n-----\n\nConsider `LitVarStr %a %s` which loads a variant with a literal `BSTR string, and then`\npushes that address to the top of the stack:\n\nThe `%a decoder will read the first two bytes from the stream and decode it as follows:`\n\nInterpreting `0xFF68 as a signed 2 byte number is` `-0x98 . Since it is a negative value, it is`\na local function variable at `ebp-0x98 . Positive values denote function arguments.`\n\nNext the `%s handler will read the next two bytes which it interprets as a pool index. The`\nvalue at pool index 0 is the constant `0x40122C . This address contains an embedded`\n```\nBSTR where the address points to the unicode part of the string, and the preceding 4\n\n```\nbytes denoting its length.\n\nA closer look at run time data for this instruction is included in the debugging section later\non.\n\nAnother common specifier is the `%l handler used for jump calculations. It can be seen in`\nthe following examples:\n\nIn the first unconditional jump the byte stream argument is `0x002C . Jump locations are all`\nreferenced from the function start address, not the current instruction address as may be\nexpected.\n\n```\n0x4014E4 + 0x2C = 0x401510\n\n```\n```\n0x4014E4 + 0x3A = 0x40151E\n\n```\n\nSince all jumps are calculated from the beginning of a function, the offsets in the byte\nstream must be interpreted as unsigned values. Jumps to addresses before the function\nstart are not possible and represent a disassembly error.\n\n\n-----\n\nNext lets consider the `%x handler as we revisit the` `ImpAdCallFPR4 %x` instruction:\n\nThe native handler for this is:\n\nLooking at the P-Code disassembly we can see the byte stream of `24001000 is actually`\ntwo integer values. The first `0x0024 is a constant pool index, and the second` `0x0010 is`\nthe expected stack adjustment to verify after the call.\n\nNow we haven’t yet talked about the constant pool or the house keeping area of the stack\nthat VB6 reserves for state storage. For an abbreviated description, at runtime VB uses the\narea between `ebp and` `ebp-94h as kind of a scratch pad. The meaning of all of these`\nfields are not yet fully known however several of the key entries are as follows:\n\nStack position Description\n\nebp-58 Current function start address\n\n\n-----\n\nebp-54 Constant pool\n\nebp-50 Current function raw address (RTMI structure)\n\nebp-4C PR (Pointer Register) used for Object references\n\nIn the above disassembly we can see entry `0x24 from the constant pool would be loaded.`\n\nA constant pool viewer is a very instructive tool to help decipher these argument byte\ncodes.\n\nIt has been found that smart decoding routines can reliably decipher constant pool data\nindependent of analysis of the actual disassembly.\n\nOne such implementation is shown below:\n\nIf we look at entry `0x0024 we see it holds the value` `0x4011CE . If we look at this address`\nin IDA we find the following native disassembly:\n\n`0x40110C is the IAT address of` `msvbvm60.rtcImmediateIf` import. This opcode is how\nVB runtime imports are called.\n\n\n-----\n\nWhile beyond the scope of this paper, it is of interest to note that VB6 embeds a series of\nsmall native stubs in P-Code executables to splice together the native and P-Code\nexecutions. This is done for API calls, call backs, inter-modular calls etc.\n\n## The Constant Pool\n\nThe constant pool itself is worth a bit of discussion. Each compilation unit such as a\nmodule, class, form etc gets its own constant pool which is shared for all of the functions in\nthat file.\n\nPool entries are built up on demand as the file is processed by the compiler from top to\nbottom.\n\nThe constant pool can contain several types of entries such as:\n\nstring values (BSTRs specifically)\nVB method native call stubs\nAPI import native call stubs\nCOM GUIDs\nCOM CLSID / IID pairs held in COMDEF structures\nCodeObject base offsets\nblank slots which represent internal COM objects filled out at startup by the runtime\n(ex: App.)\n\n## More advanced opcode processors\n\nMore complex argument resolutions require a series of opcode post processors. In the\ndisassembly engine I am working on there are currently 13 post processors which handle\naround 30 more involved opcodes.\n\nThings start to get much more complex when we deal with `COM object calls. Here we have`\nto resolve the `COM class ID,` `interface ID, and discern its complete` `VTable`\n```\nlayout to determine which method is going to be called. This requires access to the COM\n\n```\nobjects type library if its an external type, and the ability to recreate its function prototype\nfrom that information.\n\nFor internal types such as `user classes,` `forms and` `user controls, we also need to`\nunderstand their `VTable layout . For internal types however we do not receive the aid of`\ntlb files. Public methods will have their names embedded in the VB file format structures\nwhich can be of help.\n\nResolution of these types of calls is beyond the scope of what we can cover in an\nintroductory paper, but it is absolutely critical to get right if you are writing a disassembler\nthat people are going to rely upon for business needs.\n\n\n-----\n\n## More on opcode handler inputs\n\nBack to opcode arguments. It is also important to understand that opcodes can take\ndynamic runtime stack arguments in addition to the hard coded byte stream arguments.\nThis is not something that a disassembler necessarily needs to understand though. This\nlevel of knowledge is mainly required to write P-Code assembly or a P-Code decompiler.\n\nSome special cases however do require the context of the previous disassembly in order to\nresolve properly. Consider the following multistep operation:\n\nHere the `LateIdLdVar resolver needs to know which object is being accessed. Scanning`\nback and locating the `VCallAd instruction is required to find the active object stored in`\n```\nPR .\n\n## Debugging handlers\n\n```\nWhen trying to figure out complex opcode handlers, it is often helpful to watch the code run\nlive in a debugger. There are numerous techniques available here. Watching the handler\nitself run requires a native debugger.\n\nTypically you will figure out how to generate the opcode with some VB6 source which you\ncompile. You then put the executable in the same directory as your reference copy of the vb\nruntime and start debugging.\n\nSome handlers are best viewed in a native debugger, however many can be figured out just\nby watching it run through a P-Code debugger.\n\nA P-Code debugger simplifies operations showing you its execution at a higher level. In one\nstep of the debugger you can watch multiple stack arguments disappear, and the stack diff\nlight up with changes to other portions. Higher level tools also allow you to view complex\ndata types on the stack as well as examine TLS memory and keep annotated offsets.\n\nIn some scenarios you may actually find yourself running both a P-Code debugger and a\nnative debugger on the target process at the same time.\n\nOne important thing to keep in mind is that VB6 makes heavy use of COM types.\n\nGoing back to our `LitVarStr example:`\n\n\n-----\n\nYou would see the following after it executes:\n```\n0019FC28 ebp-120 0x0019FCB0 ; ebp-98 - top of stack\n...\n0019FCB0 ebp-98 0x00000008\n0019FCB4 ebp-94 0x00000000 \n0019FCB8 ebp-90 0x0040122C\n\n```\nA data viewer would reveal the following when decoding `ebp-98 as a variant:`\n```\nVariant 19FCB0\nVT: 0x8( Bstr )\nRes1: 0\nRes2: 0\nRes3: 0\nData: 40122C\nString len: 9 -> never hit\n\n```\nDebugging VB6 apps is a whole other ball of wax. I mention it here only in passing to give\nyou a brief introduction to what may be required when deciphering what opcodes are doing.\nIn particular recognizing `Variants and` `SafeArrays in stack data will serve you well`\nwhen working with VB6 reversing.\n\n## Conclusion\n\nIn this paper we have laid the necessary ground work in order to understand the basics of a\nVB6 P-Code disassembly engine. The Semi-VbDecompiler source is a good starting point\nto understand its inner workings.\n\nWe have briefly discussed how to find and read native opcode handlers along with some of\nthe conventions necessary for understanding them. We introduced you to how opcodes flow\nfrom one to the next, along with how to determine the number of byte stream arguments\neach one takes, and how to figure out what they represent.\n\nThere is still much work to be done in terms of documenting the instruction set. I have\nstarted a project where I catalog:\n\nVB6 source code required to generate an opcode\nbyte stream arguments size and meaning\nstack arguments consumed\nfunction outputs\n\n\n-----\n\nUnfortunately it is still vastly incomplete. This level of documentation is foundational and\nquite necessary for writing any P-Code analysis tools.\n\nStill to be discussed, is how to find the actual P-Code function blobs within the VB6\ncompiled executable. This is actually a very involved task that requires understanding a\nseries of complex and nested file structures. Again the Semi-VbDecompiler source can\nguide you through this maze.\n\nWhile VB6 is an old technology, it is still commonly used for malware. This research is\naimed at reducing gaps in understanding around it and is also quite interesting from a\nlanguage design standpoint.\n\n[1] – [VB6 runtime with symbols](http://sandsprite.com/vb-reversing/files/msvbvm60.zip)\n\n[2] – [Semi-VbDecompiler opcode table Source](https://github.com/VBGAMER45/Semi-VB-Decompiler/blob/master/Semi%20VB%20Decompiler/modPCode.bas#L653)\n\n[3] – [A closer look at the VB6 For Loop implementation](http://sandsprite.com/blogs/index.php?uid=7&pid=483&year=2020)\n\n[4] – [Semi-VBDecompiler opcode argument decodings](https://github.com/VBGAMER45/Semi-VB-Decompiler/blob/master/Semi%20VB%20Decompiler/modPCode.bas#L550)\n\n[5] – [Introducing a one byte NOP opcode](http://sandsprite.com/blogs/index.php?uid=7&pid=472&year=2019)\n\n[6] – [Semi-VBDecompiler](https://github.com/VBGAMER45/Semi-VB-Decompiler)\n\n[Tagged asdisassembly,](https://decoded.avast.io/tag/disassembly/) [P-Code,](https://decoded.avast.io/tag/p-code/) [Research,](https://decoded.avast.io/tag/research/) [series,](https://decoded.avast.io/tag/series/) [VB](https://decoded.avast.io/tag/vb/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-05 - VB6 P-Code Disassembly.pdf"
    ],
    "report_names": [
        "2021-05-05 - VB6 P-Code Disassembly.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535635,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1653821300,
    "ts_modification_date": 1653821300,
    "files": {
        "pdf": "https://archive.orkl.eu/9e4e37d18fd55ca613fc2b7189ac01eea7ceec27.pdf",
        "text": "https://archive.orkl.eu/9e4e37d18fd55ca613fc2b7189ac01eea7ceec27.txt",
        "img": "https://archive.orkl.eu/9e4e37d18fd55ca613fc2b7189ac01eea7ceec27.jpg"
    }
}