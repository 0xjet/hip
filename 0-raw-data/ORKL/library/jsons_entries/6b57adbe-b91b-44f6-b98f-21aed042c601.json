{
    "id": "6b57adbe-b91b-44f6-b98f-21aed042c601",
    "created_at": "2023-01-12T15:04:35.928031Z",
    "updated_at": "2025-03-27T02:08:40.410348Z",
    "deleted_at": null,
    "sha1_hash": "b80815587004244887c581a165928efe0d05d190",
    "title": "2019-04-22 - Analyzing Emotet with Ghidra — Part 1",
    "authors": "",
    "file_creation_date": "2022-05-27T21:07:34Z",
    "file_modification_date": "2022-05-27T21:07:34Z",
    "file_size": 798030,
    "plain_text": "# Analyzing Emotet with Ghidra — Part 1\n\n**[medium.com/@0xd0cf11e/analyzing-emotet-with-ghidra-part-1-4da71a5c8d69](https://medium.com/@0xd0cf11e/analyzing-emotet-with-ghidra-part-1-4da71a5c8d69)**\n\nCafe Babe April 22, 2019\n\n[Cafe Babe](https://medium.com/@0xd0cf11e?source=post_page-----4da71a5c8d69--------------------------------)\n\nApr 19, 2019\n\n\n6 min read\n\nThis post I’ll show how I used Ghidra in analyzing a recent sample of Emotet.\n\nIf you have read this, here is [Part 2.](https://medium.com/@0xd0cf11e/analyzing-emotet-with-ghidra-part-2-9efbea374b14)\n\n**SHA256:**\n\nThe analysis is done on the unpacked binary file. In this post I’m skipping how I unpacked\nthe file, since what I primarily want to show is how I used Ghidra’s python scripting manager\nto decrypt strings and API calls.\n\nSome short descriptions:\n\n_What is Ghidra?_\n\nIt is an open source reverse engineering tool suite. You can find out more here —\n\n_Why Emotet?_\n\nEmotet is a prevalent malware. Started out as a banking trojan. It is persistent and\nkeeps evolving its infection mechanisms. There are other existing analyses done. A\nsearch can lead you there —\n\n_Why Ghidra and Emotet?_\n\nFor starters, I am looking for a new gig (a.k.a unemployed) and hence cannot afford an\n. Plus I want to continue being a Malware Analyst.\nUsing the free version is still amazing, but I miss not being able to use IDA Python. I\ndid use IDA’s own scripting language IDC but…I like python. Implemented just one of\nthe functions of Emotet .\n\n\n-----\n\n## Opening up Emotet with Ghidra\n\nGhidra is about creating projects. Following the on-screen instructions, I created a project\nnamed “Emotet”. To add files to analyze into the project, simple type or go to .\n\n1. Imported Emotet binary\nGhidra displays properties regarding the file that gets imported. Double click on the file name\nand it opens it up in CodeBrowser which is a tool that disassembles the file.\n\n\n-----\n\n2. Emotet view in CodeBrowser\nUnder the Symbol Tree (usually on the left or you can go to ), I filtered for “entry” to get to the\nbinary’s entry point.\n\n3. Entry Point of Emotet\nUnder Listing we see the compiled code and on the right is its decompiled code. Since I’ve\nalready analyzed these binaries, some of the sub routine calls and offsets in these images\nwill have been renamed by me. To rename an offset, right-click an offset value and select (or\ntype ).\n\n\n-----\n\n## Emotet s Function Calls\n\nEmotet encrypts its strings and stores its API call names as hashes. So statically viewing this\nfile, is a pain to read.\n\nWithout going into much detail about Emotet’s payload (that would require another blog\nentry), I will show how to make this binary a bit more easy to follow. It does require to initially\ngo through each function and figure out the math (possibly using, or whichever debugger so\nto make it a little less painful).\n\nIn this case I wanted to figure 2 methods used by Emotet. The first function is a simple xor\nroutine that it uses to decrypt strings. It looked deceiving complex (because of the use of\nshift operators in the function), only till after running one iteration in that I realized what was\nhappening… . The second function finds which API name matches which hash (I will cover\nthis in [Part 2). This I felt was a bit more clever, but still easy to understand after running in .](https://medium.com/@0xd0cf11e/analyzing-emotet-with-ghidra-part-2-9efbea374b14)\n\nThen using Ghidra’s Script Manager, I’ll show how I implemented the python scripts to\ndecrypt the strings and resolve the API calls used in the binary.\n\n## How are the Strings encrypted?\n\nIn the binary, I’ve noticed a lot of references to the function call at . This call decrypts for the\nstrings. I renamed it to . To find references made to the function, right click the function and\nselect .\n\n\n-----\n\n4. References to decode_strings\n\n5. Call being made to decode_strings\nThe function takes in 2 arguments that are stored in and (Image 5). is the offset of the\nencrypted string. is the xor key. The decrypted string gets stored in memory allocated in the\nheap and the address gets passed to .\n\n(Side Track: I have added the string “ecx = offset \\n edx = key” as a repeatable comment to\nthe function. Right click the address and select or type )\n\nThe first dword at the offset xor’ed with the key returned the length of the string. The next\nsubsequent set of dwords were xor’ed up until the string’s length.\n\nNow for the more exiting part, automating this with a python script in Ghidra.\n\n\n-----\n\n## Using Python to Automate Decryption\n\n6. Script Manager Icon\nIn the top toolbar section of Ghidra, we see this icon in image 6. It takes us to the Script\nManager. Else you can select .\n\n7. Script manager\nThe Script Manager displays a list of scripts written in either Java or Python. They come with\nthe installation. The script manager also has some python script examples. So, I filtered for\n.py scripts to help me understand how to proceed in writing a python script. The Python\nInterpreter interacts with Ghidra’s Java API through [Jython. The documentation on the Java](https://www.jython.org/archive/21/docs/whatis.html)\nAPIs provided can be found in a zipped file in the docs directory of your Ghidra installation.\n\n8. Create new script icon\nTo create a new python script, select this icon — image 8. Select Python and enter a name\nyou’d like to give to your script.\n\n\n-----\n\n8. A sample test.py script created\nAdditionally, going through the help docs (under )and reading under, there is a description of\nthe metadata tags that gets generated when creating a new script.\n\nI’ve uploaded the script into my github repo and you can follow it here —\n[https://github.com/0xd0cf11e/ghidra/blob/master/ghidra_emotet_decode_strings.py](https://github.com/0xd0cf11e/ghidra/blob/master/ghidra_emotet_decode_strings.py)\n\n9. Decrypted string displayed as comment\nThe idea behind the script is to display the strings that get decrypted as comments next to\nthe instruction where its offset is moved to (Image 9).\n\n10. Bytes patched in the binary.\nAnd as well to patch the bytes in the binary (Image 10).\n\n\n-----\n\nFirst step, I wanted to find all the code references made to the function.\n\nIterating through each reference, the next step was locating for the opcode instructions and .\nThe instructions weren’t always immediately before the call to the function. So I iterated\nthrough a max of 100 instructions to search for the opcodes.\n\nAfter that I was all set to carry out the xor routine and patch the bytes and comment at the\ninstruction offset where was carried out.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-04-22 - Analyzing Emotet with Ghidra — Part 1.pdf"
    ],
    "report_names": [
        "2019-04-22 - Analyzing Emotet with Ghidra — Part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535875,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653685654,
    "ts_modification_date": 1653685654,
    "files": {
        "pdf": "https://archive.orkl.eu/b80815587004244887c581a165928efe0d05d190.pdf",
        "text": "https://archive.orkl.eu/b80815587004244887c581a165928efe0d05d190.txt",
        "img": "https://archive.orkl.eu/b80815587004244887c581a165928efe0d05d190.jpg"
    }
}