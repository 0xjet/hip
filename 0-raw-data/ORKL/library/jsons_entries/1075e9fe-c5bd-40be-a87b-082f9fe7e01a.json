{
    "id": "1075e9fe-c5bd-40be-a87b-082f9fe7e01a",
    "created_at": "2023-01-12T15:06:10.388172Z",
    "updated_at": "2025-03-27T02:05:41.996492Z",
    "deleted_at": null,
    "sha1_hash": "46993d8b73bd5cfe817f5459265038be1c143781",
    "title": "2015-04-13 - Analyzing Gootkit's persistence mechanism (new ASEP inside!)",
    "authors": "",
    "file_creation_date": "2022-05-28T01:27:30Z",
    "file_modification_date": "2022-05-28T01:27:30Z",
    "file_size": 355241,
    "plain_text": "# Analyzing Gootkit's persistence mechanism (new ASEP inside!)\n\n**[blog.cert.societegenerale.com/2015/04/analyzing-gootkits-persistence-mechanism.html](http://blog.cert.societegenerale.com/2015/04/analyzing-gootkits-persistence-mechanism.html)**\n\nMalware authors are quite known for their innovation. A couple of years back, we wouldn't\nhave imagined running into Node.js and JavaScript-based malware, yet that's exactly what\nGootkit does. Gootkit is a piece of banking malware that uses web-injects (just like ZeuS and\nits derivatives) to capture credentials and OTPs from infected users. It has other nifty\nfeatures such as TLS interception using a local proxy and fake certificates, keylogging,\nlibrary hooking, UAC bypass... you name it.\n\nA mandatory step in malware's execution process is ensuring persistence, or survival from\nreboots. The most popular persistence mechanisms include adding an entry to the wellknown \"Run key\" in the user's registry base, or creating a Windows service if the necessary\nprivileges are available. Malware can also use Scheduled Tasks, Winlogon, AppInit,\nActiveSetup... That was apparently not enough for the people behind Gootkit, since they use\na completely different persistence mechanism.\n\nWhen running dynamic analysis of recent Gootkit samples (MD5 at the end of the blogpost),\nwe noticed the creation of lots of .sdb files and just as many instances of sdbinst processes.\nA [blogpost pointed us towards a paper written in 2014 by Jon Erickson, explaining how](http://blog.trendmicro.com/trendlabs-security-intelligence/fake-judicial-spam-leads-to-backdoor-with-fake-certificate-authority/)\nMicrosoft's Fix it patches could be abused to ensure persistence. Gootkit is the first malware\nwe see that uses this persistence mechanism.\n\n\n-----\n\nFix-it patches are used by Microsoft to quickly issue patches without having to release entire\nbinaries. They don't modify the target binary itself but instead provide the Windows loader\nwith information allowing it to patch it once it has been loaded in memory. Patches range\nfrom performance improvements to security fixes and can be set on individual programs.\nThe information concerning these patches is contained in .sdb files. The Windows loader\nidentifies these files through the following registry keys:\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom\nHKLM\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\AppCompatFlags\\InstalledSDB\n\nThe Custom key designates the corresponding GUID in\nthe InstalledSDB key. InstalledSDB contains a pointer to the SDB file that will actually define\nwhere and how to apply the patch.\n\nSince creating this kind of patches imply writing to the HKLM registry key, administrator rights\nare required.\n\n\n-----\n\nThe file located at C:\\Windows\\AppPatch\\Custom\\{...}.sdb is a binary file. It can be read with\na tool like [sdb-explorer. sdb-explorer can be used to manipulate .sdb files in many ways, but](https://github.com/evil-e/sdb-explorer)\nwe'll show how to use it to recover the patch.\n\nsdb-explorer.exe -t file.sdb will generate a tree with the information contained in the SDB file.\nHere's the tree for patching myie.exe:\n\n\n-----\n\n```\nc TAG 7802 INDEXES\n 12 TAG 7803 - INDEX\n 18 TAG 3802 - INDEX_TAG: 28679 (0x7007)\n 1c TAG 3803 - INDEX_KEY: 24577 (0x6001)\n 20 TAG 4016 - INDEX_FLAGS: 1 (0x1)\n 26 TAG 9801 - INDEX_BITS\n45 58 45 2e 45 49 59 4d 62 1a 00 00 \n38 TAG 7001 - DATABASE\n 3e TAG 4023 - OS_PLATFORM: 0 (0x0)\n 44 TAG 6001 - NAME: myie.exe\n 4a TAG 9007 - DATABASE_ID: {5FA4B5F6-E2E3-4435-B56B-70A717FCFA61} NON-STANDARD\n 60 TAG 7002 - LIBRARY\n 66 TAG 7009 - SHIM_REF\n  6c TAG 7005 - PATCH\n  72 TAG 6001 - NAME: patchdata0\n  78 TAG 9002 - PATCH_BITS\n 1a62 TAG 7007 - EXE\n 1a68 TAG 6001 - NAME: myie.exe\n 1a6e TAG 6006 - APP_NAME: myie.exe\n 1a74 TAG 9004 - EXE_ID: {7BFBEB30-D6BB-4CC1-BD6A-E30E8AE75BDA}\n 1a8a TAG 7008 - MATCHING_FILE\n  1a90 TAG 6001 - NAME: myie.exe\n 1a96 TAG 700a - PATCH_REF\n  1a9c TAG 6001 - NAME: patchdata0\n  1aa2 TAG 4005 - PATCH_TAGID: 108 (0x6c)\n1aa8 TAG 7801 - STRINGTABLE\n 1aae TAG 8801 - STRINGTABLE_ITEM: myie.exe\n 1ac6 TAG 8801 - STRINGTABLE_ITEM: patchdata0\n\n```\nThe interesting part is 1aa2 TAG 4005 - PATCH_TAGID: 108 (0x6c). You can dump the patch\ncorresponding to PATCH_TAGID: 108 by issuing the command sdb-explorer.exe -p {...}.sdb\n1aa2 > file.txt\nfile.txt will have contents similar to this:\n\n\n-----\n\n```\nTrying to process patch by tag type: PATCH_TAGID\n 00000000: 02 00 00 00 2a 17 00 00 d6 16 00 00 00 80 0c 00 \n [snip] \n 000019D0: 00 00 00 00 e8 33 71 07 00 eb f9 00 00 00 00 00 \n 000019E0: 00 00 00 \nmodule   : kernel32.dll\nopcode   : 2 REPLACE\nactionSize : 5930\npatternSize: 5846\nRVA    : 0x000c8000\nBytes: 55 8b ec 83 e4 f8 [snip] 5f 5e 5b 8b e5 5d c3 \nCode:\n 00000000 55        push ebp\n 00000001 8bec       mov ebp, esp\n 00000003 83e4f8      and esp, 0xfffffff8\n    [snip]\n 000016cf 5f        pop edi\n 000016d0 5e        pop esi\n 000016d1 5b        pop ebx\n 000016d2 8be5       mov esp, ebp\n 000016d4 5d        pop ebp\n 000016d5 c3        ret\nmodule   : kernel32.dll\nopcode   : 4 MATCH\nactionSize : 92\npatternSize: 8\nRVA    : 0x000c5f4b\nBytes: 00 00 00 00 00 00 00 00 \nCode:\n 00000000 0000       add [eax], al\n 00000002 0000       add [eax], al\n 00000004 0000       add [eax], al\n 00000006 0000       add [eax], al\nmodule   : kernel32.dll\nopcode   : 2 REPLACE\nactionSize : 227\npatternSize: 143\nRVA    : 0x000c5f4b\nBytes: 55 8b ec 51 51 [snip] 5f 5e 8b e5 5d c3 \nCode:\n 00000000 55        push ebp\n 00000001 8bec       mov ebp, esp\n 00000003 51        push ecx\n 00000004 51        push ecx\n    [snip]\n 00000089 5f        pop edi\n 0000008a 5e        pop esi\n 0000008b 8be5       mov esp, ebp\n\n```\n\n-----\n\n```\n 0000008d 5d        pop ebp\n 0000008e c3        ret\nmodule   : kernel32.dll\nopcode   : 4 MATCH\nactionSize : 92\npatternSize: 8\nRVA    : 0x000c5f3d\nBytes: 00 00 00 00 00 00 00 00 \nCode:\n 00000000 0000       add [eax], al\n 00000002 0000       add [eax], al\n 00000004 0000       add [eax], al\n 00000006 0000       add [eax], al\nmodule   : kernel32.dll\nopcode   : 2 REPLACE\nactionSize : 98\npatternSize: 14\nRVA    : 0x000c5f3d\nBytes: 83 04 24 02 60 9c e8 03 00 00 00 9d 61 c3 \nCode:\n 00000000 83042402     add dword [esp], 0x2\n 00000004 60        pushad\n 00000005 9c        pushfd\n 00000006 e803000000    call 0xe\n 0000000b 9d        popfd\n 0000000c 61        popad\n 0000000d c3        ret\nmodule   : kernel32.dll\nopcode   : 4 MATCH\nactionSize : 89\npatternSize: 5\nRVA    : 0x0004ee05\nBytes: 90 90 90 90 90 \nCode:\n 00000000 90        nop\n 00000001 90        nop\n 00000002 90        nop\n 00000003 90        nop\n 00000004 90        nop\nmodule   : kernel32.dll\nopcode   : 2 REPLACE\nactionSize : 91\npatternSize: 7\nRVA    : 0x0004ee05\nBytes: e8 33 71 07 00 eb f9 \nCode:\n\n```\n\n-----\n\n```\n 00000000 e833710700    call 0x77138\n 00000005 ebf9       jmp 0x0\n\n```\nThe MATCH instruction will check that the sequence of bytes are present (e.g. it is the\ncorrect version of the PE they are about to patch), and the REPLACE instruction will actually\ndo the replacement.\nThe 90 90 90 90 90 snippet allows for code to be inserted right before the entry point (or\nother function prologues) without breaking everything. The jmp instruction in our patch\nreplaces a dummy instruction (mov edi, edi) and jumps to the call defined just before it,\nentering our code. It is then up to the code to jump back to the correct location after the\npatch.\nThis process is somewhat similar to \"hooking\" functions in DLLs, except it is being done\nsystematically by the Windows loader if the conditions match.\n\nIn this case, the inserted snippet is responsible for loading Gootkit's main executable from\nthe registry and launching it.\n\nThe patch will look for a couple of registry keys in HKCU\\Software\\AppDataLow. They are\nnamed according to the system architecture: on a 32-bit Windows 7 system, the studied\nsample generated keys named BinaryImage32_[\\d]:\n\nThe loader concatenates all the key's values, and proceeds to decrypt the blob using a\nrotating XOR algorithm and uncompresses it using RtlDecompressBuffer (LZNT1). The file\nitself is Gootkit's bulky ~4,5 MB DLL which contains the Node.js engine to launch the\nmalware. The loader then loads the PE, resolves imports, and DllMain, ensuring that the\nmalicious payload is up and running.\n\nDropper MD5 / SHA-1: a28a620b41f852cf7699a7218fe62c69 /\n4095c19435cad4aed7490e2fb59c538b1885407a\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-04-13 - Analyzing Gootkit's persistence mechanism (new ASEP inside!).pdf"
    ],
    "report_names": [
        "2015-04-13 - Analyzing Gootkit's persistence mechanism (new ASEP inside!).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535970,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1653701250,
    "ts_modification_date": 1653701250,
    "files": {
        "pdf": "https://archive.orkl.eu/46993d8b73bd5cfe817f5459265038be1c143781.pdf",
        "text": "https://archive.orkl.eu/46993d8b73bd5cfe817f5459265038be1c143781.txt",
        "img": "https://archive.orkl.eu/46993d8b73bd5cfe817f5459265038be1c143781.jpg"
    }
}