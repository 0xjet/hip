{
    "id": "b074ff33-cd9e-45a1-ae2a-a3563d0a69db",
    "created_at": "2023-01-12T15:00:49.37028Z",
    "updated_at": "2025-03-27T02:08:41.022056Z",
    "deleted_at": null,
    "sha1_hash": "6f00654c113433aebcb288dc6c0c26b58733b7b7",
    "title": "2020-12-21 - TrickBot- A Closer Look",
    "authors": "",
    "file_creation_date": "2022-05-29T01:08:26Z",
    "file_modification_date": "2022-05-29T01:08:26Z",
    "file_size": 2523673,
    "plain_text": "# TrickBot: A Closer Look\n\n**[blogs.keysight.com/blogs/tech/nwvs.entry.html/2020/12/21/trickbot_a_closerl-TpQ0.html](https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2020/12/21/trickbot_a_closerl-TpQ0.html)**\n\n2020-12-21 |  11 min read\n\n[In early November, the Cybersecurity and Infrastructure Security Agency (CISA) released an advisory](https://us-cert.cisa.gov/ncas/alerts/aa20-302a)\nwarning administrators in the healthcare and public sector that TrickBot is being used to disturb\n[healthcare services by launching ransomware attacks and by stealing data. This month, Threat](https://blogs.keysight.com/blogs/tech/nwvs.entry.html/2020/12/15/simulating_trickyma-Yjn5.html)\nSimulator released a TrickBot assessment covering the malware's kill chain. In this post, we'll take a\nclose look at the installation phase of the TrickBot infected document that inspired the assessment.\n\n\n-----\n\nProcess tree for the sample under analysis.\n\n## Sample.doc Analysis (SHA-1: c2f948d866ff4dfa8aaebda5507c7d606ac9fb28)\n\nThe sample is a .doc file, an older file type for Microsoft Word, also known as Microsoft Word 97-2003\nformat. This file type may contain Visual Basic for Applications (VBA) macros.\n\nThe document convinces the target to click Enable Editing and Enable Content. This is common for\nmalicious macro enabled documents to bypass security prompts and run the macro code embedded\nwithin it.\n\nThe document contains the Document_Close event procedure. Upon closing of the document, the\nDocument.Close event will fire and the Document_Close procedure will be called. This will evade\nsandboxes that do not close the document during analysis.\n\n\n-----\n\nThe Document_Close procedure will delay execution for 2 seconds and then proceed to call the\nfunction ResetCalcD. ResetCalcD will call another function named UniqueValues.\n\nThe UniqueValues function will first create the directory \"C:\\Artrite\\Final_Joana\\\"\nThen, UniqueValues will create the file \"C:\\Artrite\\SarilumabSAR153191.part\" and fill it with VBScript\ncomments.\n\n\n-----\n\nFinally, UniqueValues will create the file C:\\Artrite\\SarilumabSAR153191.vbe and fill it with VBScript\ncomments along with the value of the caption \"luinpedrnass.dados.Caption.\" The caption contains the\nnext stage payload, a VBScript file.\n\nAfter the call to ResetCalcD, the Document_Close procedure will create an Excel.Application object.\nAs a result, svchost.exe will spawn a process for excel.exe. This will mask the calling process,\nwinword.exe in this case, and will make tracking the process tree and kill chain of the malware more\ndifficult.\nNext, the DisplayAlert property is set to False. This will prevent UI pop-ups from being presented to\nthe user.\nFinally, the DDEInitiate method is called. This method will launch an application if the target system\nhas the Dynamic Data Exchange Server Launch Trust Center setting enabled. This setting is no\nlonger enabled by default.\nIf configured to do so, DDEInitiaite will cause excel.exe to launch cmd.exe with the command-line:\n\ncmd /c C:\\Artrite\\SarilumabSAR153191.vbe\n\nFinally, wscript.exe will execute the next stage, C:\\Artrite\\SarilumabSAR153191.vbe.\n\n**tl;dr: The malicious document will use the Document_Close VBA macro to drop and execute a VBE**\nfile upon closing the document.\n\n## SarilumabSAR153191.vbe Analysis\n\nThe script file contains double base64 encoded data in a variable named tData.\n\ntData is decoded using the function DecodeBase64_1.\n\nDecodeBase64_1 uses the Microsoft.XMLDOM object to decode base64 encoded data and uses the\nAdodb.Stream object to write the decoded contents to “C:\\Artrite\\Final_Joana\\WhatAreTopFacts.rtc”\n\nThere is minor obfuscation using the Chr function to hide the strings \"b64\" and \"bin.base64\"\n\n\n-----\n\nThe data is then decoded a second time with a similar base64 decoding function and once again\nsaved to “C:\\Artrite\\Final_Joana\\WhatAreTopFacts.rtc”\n\nFinally, an Excel DDE is used once again to launch the next stage, WhatAreTopFacts.rtc (a 32-bit DLL\nfile), using rundll32.exe\n\n**tl;dr: SarilumabSAR153191.vbe will drop and execute a 32-bit DLL file using rundll32.exe.**\n\n## WhatAreTopFacts.rtc Analysis\n\nWhatAreTopFacts.rtc is a DLL that exports the function DllRegisterServer.\n\nIt is odd that the malware author chose to name the exported function DllRegisterServer while not\n[taking advantage of the LoLBins that utilize that exported function. (msiexec.exe,](https://blog.talosintelligence.com/2019/11/hunting-for-lolbins.html) [odbcconf.exe)](https://lolbas-project.github.io/lolbas/Binaries/Odbcconf/)\n\nThe DllRegisterServer function will deobfuscate the strings \"LdrFindResource_U\" and\n\"LdrAccessResource\".\n\n\n-----\n\nNext, DllRegisterServer will dynamically resolve the API functions ntdll!LdrFindResource_U and\nntdll!LdrAccessResource before calling LdrFindResource_U and LdrAccessResource to fetch the\ncontents of a resource embedded within the resource section of the binary.\n\nThe embedded resource has an entropy value of 7.99613 bits per byte. The high entropy suggests\nthat the resource is encrypted data.\n\nDllRegisterServer will then copy the resource data into freshly allocated\nPAGE_EXECUTE_READWRITE memory.\n\n\n-----\n\nDllRegisterServer will go onto decrypt the resource data using a dynamically derived key and an XOR\nbased encryption/decryption routine.\n\n\n-----\n\nFinally, DllRegisterServer will execute the decrypted resource data. The resource data turns out to be\nencrypted shellcode.\n\n\n-----\n\n**tl;dr: WhatAreTopFacts.rtc will decrypt and execute encrypted shellcode embedded as a resource.**\n\n## WhatAreTopFacts.rtc Shellcode Analysis\n\nAt the tail end of the shellcode there is an embedded Portable Executable (PE) file. The embedded\nPE is a DLL.\n\nThe shellcode begins by using the (JMP)/CALL/POP technique to get the base address of the\nshellcode. The base address is then used to calculate the start and end address of the embedded PE.\n\n[In the shellcode, there is a function that gets a pointer to the PEB and walks the linked list of loaded](https://www.geoffchappell.com/studies/windows/win32/ntdll/structs/peb/index.htm)\nmodules.\n\nIn the same function, the [ror instruction is used within a loop.](https://c9x.me/x86/html/file_module_x86_id_273.html)\n\n[This function implements a common shellcode technique that resolves Windows API functions by](https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html)\nusing a precomputed value using a ROR 13 based hash function.\n\n\n-----\n\nThe shellcode will then use the above function to resolve the APIs necessary to load a PE from\nmemory.\n\nThese APIs will be used to load the PE in memory.\n\n**tl;dr: The shellcode will load and execute a DLL from memory.**\n\n## WhatAreTopFacts.rtc Embedded DLL 1 Analysis\n\nThere is an embedded PE within this DLL. The embedded PE is a DLL.\n\nFirst, this DLL dynamically resolves the API function kernel32!GetNativeSystemInfo.\n\nNext, the DLL parses the embedded PE's headers and calculates the PE’s size.\n\n\n-----\n\nAfterwards, VirtualAlloc is used to allocate memory at the PE's preferred base address. If memory\nallocation fails, then memory is allocated again, this time letting the OS decide the allocated memory\naddress.\n\nNext, the DLL allocates heap memory for a custom struct and initializes it.\n\n\n-----\n\nNext, the DLL copies the PE's headers into the allocated memory region.\n\nThe headers are then used to load the PE's sections into memory.\n\nThe DLL will then go onto perform base relocation, if necessary.\n\nNext, the libraries in the PE's import table will be loaded.\n\nAfterwards, the image base address in the PEB is set to the base address of the next stage PE.\n\n\n-----\n\nFinally, the entry point of the next stage PE will be called.\n\n[This DLL is a reflective loader.](https://www.exploit-db.com/docs/english/13007-reflective-dll-injection.pdf)\n\nThe custom struct from earlier can be used to find the source of this reflective loader implementation.\n[Googling the following will lead to a fork of the MemoryModule project:](https://github.com/fancycode/MemoryModule)\n\nsite:github.com \"VirtualAlloc\" \"VirtualFree\" \"LoadLibraryA\" \"GetProcAddress\" \"FreeLibrary\" \"HeapAlloc\"\n\n[The simularity struct definitions suggests that this DLL uses a derivative of the MemoryModule](https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c#L80)\nproject.\n\nStruct definition from MemoryModule\n\nReversed struct definition\n\nThe only significant differences between reflective loader implementations were:\n\n\n-----\n\nA custom implementation of the C Run-time Library s (CRT) realloc function is used. This is a\nnecessary since the CRT's realloc function requires that the CRT is initialized, which it will not\nbe in this case.\nGetNativeSystemInfo is dynamically resolved instead of imported\nThe image base addresses in the PEB is updated\n\n**[tl;dr: This DLL will load and execute the next stage DLL from memory using MemoryModule.](https://github.com/fancycode/MemoryModule)**\n\n## WhatAreTopFacts.rtc Embedded DLL 2 Analysis\n\nThis DLL is similar but slightly different to the DLL from the previous stage. The custom struct no\nlonger has a field for VirtualAlloc and VirtualFree. This correlates with revisions of MemoryModule\nprior to commit [d88817fb.](https://github.com/fancycode/MemoryModule/tree/d88817fbf7debbd0a0c2f5cc6e193f3a38f1d114)\n\nIt is odd that two different versions of the same project are used within the same sample.\n\nThe next stage DLL is launched by calling its DllRegisterServer exported function.\n\n**[tl;dr: This DLL will load and execute the next stage DLL from memory using MemoryModule (again).](https://github.com/fancycode/MemoryModule)**\n\n## WhatAreTopFacts.rtc Embedded DLL 3 Analysis\n\nFirst, the DLL will allocate PAGE_EXECUTE_READWRITE memory using obfuscated values for the\nconstants: MEM_COMMIT and PAGE_EXECUTE_READWRITE.\n\nThen, encrypted shellcode is decrypted using an XOR based encryption/decryption routine.\n\n\n-----\n\nAfter decryption, the shellcode will be executed using the API function CreateThread.\n\nFinally, the DLL waits 3 seconds for the shellcode to finish before exiting the rundll32 process.\n\n**tl;dr: this DLL will decrypt and execute shellcode using the CreateThread.**\n\n## WhatAreTopFacts.rtc Embedded DLL 3 Shellcode Analysis\n\nIn the last part of the installation phase, self-unpacking shellcode is used to create a new 64-bit\nwermgr.exe process in the suspended state using kernel32!CreateProcessInternalW.\n\nThen, the shellcode transitions the current 32-bit process (rundll32.exe) context into a 64-bit context.\nThis context switch will bypass popular API monitoring tools that only hook 32-bit ntdll APIs for\nWoW64 processes.\n\n[After switching context, code is injected into the suspended process using the Process Hollowing](https://attack.mitre.org/techniques/T1055/012/)\ntechnique.\n\nFinally to complete installation, the main thread of the wermgr.exe process is resumed.\n\n© Keysight Technologies 2000–2022\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-21 - TrickBot- A Closer Look.pdf"
    ],
    "report_names": [
        "2020-12-21 - TrickBot- A Closer Look.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535649,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653786506,
    "ts_modification_date": 1653786506,
    "files": {
        "pdf": "https://archive.orkl.eu/6f00654c113433aebcb288dc6c0c26b58733b7b7.pdf",
        "text": "https://archive.orkl.eu/6f00654c113433aebcb288dc6c0c26b58733b7b7.txt",
        "img": "https://archive.orkl.eu/6f00654c113433aebcb288dc6c0c26b58733b7b7.jpg"
    }
}