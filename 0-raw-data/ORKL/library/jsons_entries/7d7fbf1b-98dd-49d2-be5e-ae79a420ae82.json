{
    "id": "7d7fbf1b-98dd-49d2-be5e-ae79a420ae82",
    "created_at": "2023-01-12T15:04:24.036523Z",
    "updated_at": "2025-03-27T02:05:54.267064Z",
    "deleted_at": null,
    "sha1_hash": "64bb2f6da54223da60e6d5e50bab2f343bb66a76",
    "title": "2011-09-27 - Debugging Injected Code with IDA Pro",
    "authors": "",
    "file_creation_date": "2022-05-28T15:34:51Z",
    "file_modification_date": "2022-05-28T15:34:51Z",
    "file_size": 539751,
    "plain_text": "# Debugging Injected Code with IDA Pro\n\n**[malwarereversing.wordpress.com/2011/09/27/debugging-injected-code-with-ida-pro/](https://malwarereversing.wordpress.com/2011/09/27/debugging-injected-code-with-ida-pro/)**\n\nSeptember 27, 2011\n\nHello all! Today I wanted to talk about how you go about debugging/analyzing injected\ncode. In todayâ€™s malware environment a lot of malicious code doesnâ€™t sit resident in memory\nin the context of itâ€™s own process. Back in the day you could look at task manager and\nrecognize some weird executable that didnâ€™t belong. Those days are mostly over. The\nnew(er) malware classes will typically inject malicious code and hook dllâ€™s in legitimate\nlooking processes (explorer.exe, winlogon.exe, svchost.exe, etc.) to evade detection. This\nmakes analyzing malware trickier as you need a wider skill set than opening up a bad binary\nin IDA. Iâ€™m going to shed some light on that process when you run into this type of malware.\n\nFirst off we need to find some malware that uses code injection. Code injection is usually\n[done through the WriteProcessMemory API call through Windows. Iâ€™ve provided a sample](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\n[here which just happens to be the shylock malware that was posted recently at Contagio.](http://www.mediafire.com/?0vowzbf40gp9s8f)\nDownload to follow along (the password is infected). This executable injects code into the\nexplorer.exe process of the target machine (xp sp3 os running on virtualbox). This is what\nwe will be working with if you want to follow along. Now I havenâ€™t done a complete in depthanalysis on this yet (itâ€™s coming) but I suspect there isnâ€™t any VM breakout that will totally\nhose your host OS. If there is well sorry bout that! ðŸ˜› You need to also make sure your vm\n[is accessible from your host machine. I used â€˜Host-Only Networkingâ€˜ and made sure the](http://www.virtualbox.org/manual/ch06.html)\nguest was accessible from my host box.\n\nSo once you have your vm up (and it has an IP you can reach from your host box). Youâ€™ll\nneed to copy over to the share a file that exists in your IDA Pro file to enable remote\ndebugging. The file is â€œwin32_remote.exeâ€. This is a server that allows IDA to connect up to\na port on a [remote server debugging to debug across the world or across memory in the](http://www.hex-rays.com/idapro/idadoc/1463.shtml)\nsense of a VM. Now one caveat with this program is that it only allows one debugging\nsession per server (depending on version, newer versions of IDA support multiple\ndebugging sessions over the same port). So if you want to debug 2 programs at the same\ntime (which we will be doing) you need two instances of this running on different ports. You\nspecify the port with the -p flag and there is NO SPACES after the -p switch so if you want to\n[set it up on port 1000 youâ€™d run â€œwin32_remote -p1000â€ from the command line. Tiga also](http://www.woodmann.com/TiGa/)\n[has posted a video tutorial about remote debugging with IDA. His entire tutorial series is](http://www.woodmann.com/TiGa/)\nvery good.\n\n[Open up a IDA Pro and Run -> Remote Win32 Debugger](http://www.hex-rays.com/idapro/idadoc/1463.shtml)\n\n\n-----\n\nMake sure your connection/paths are correct.\n\nClick ok and youâ€™ll break at the entry point of the module\n\n\n-----\n\n[Now weâ€™re going to set a breakpoint at WriteProcessMemory() (In IDA that equates to](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\n[kernel32_WriteProcessMemory. From here on out it will be referred to as](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\n[WriteProcessMemory)](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\n\nHit f9 to go and it breaks on [WriteProcessMemory() (How did I know how to break here? I](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\nreversed the program roughly to get a feel for the program from the beginning up until this\npoint.)\n\n[Now the code injection routine is a separate link here. shows why we want to break on](http://pastebin.com/wzMMxF8q)\n[WriteProcessMemory(). There are a few basic methods on how to inject code into a process](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\nthat is not yours on Windows. [Here is a good breakdown describing those methods. Most](http://www.codeproject.com/KB/threads/winspy.aspx)\n[of the tactics revolve around WriteProcessMemory system call. This particular piece of](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\nmalware uses the third type of injection mentioned in the code project article. Before this\nspecific function was reached the malware took a snapshot of the system state and iterated\nthrough the processes until it found explorer.exe then called this function. So the short\n\n\n-----\n\nversion of the disassembly is that it opens the target process, allocates some memory inside\nthe process, writes memory that was allocated (repeats 3 times), then starts a remote thread\nto execute this new code, wait for thread to exit then cleanup handles. The reason 3\nsections of memory are mapped into the target process is there is a loader there that\nreconstructs a dll in memory that is allocated inside Explorer. This happens all before the\nexit status code is returned from the thread and the code is successfully injected.\n\nLetâ€™s fire up another IDA instance and use the Attach -> Remote Win32 Debugger and put in\nthe port for the second server that was different than the first. Hit ok then we should see a\nprocess listing and letâ€™s choose our injected process (explorer.exe) from the menu. If you\n[took note of the injected code locations from CreateRemoteThread structure.](http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx)\n```\nHANDLE WINAPI CreateRemoteThread(\n __in  HANDLE hProcess,\n __in  LPSECURITY_ATTRIBUTES lpThreadAttributes,\n __in  SIZE_T dwStackSize,\n __in  LPTHREAD_START_ROUTINE lpStartAddress,\n __in  LPVOID lpParameter,\n __in  DWORD dwCreationFlags,\n __out LPDWORD lpThreadId\n);\n __in  LPTHREAD_START_ROUTINE lpStartAddress,\n\n```\n**_lpStartAddress [in]_**\nA pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be\nexecuted by the thread and represents the starting address of the thread in the remote\nprocess. The function must exist in the remote process. For more information, see\n**[ThreadProc.](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686736%28v=vs.85%29.aspx)**\n\nWe can mark this location with a breakpoint once we attach to explorer.exe (before the\nthread is started but after the memory was written). Then we hit run in the shylock.exe\n(injector process) and then we should have a breakpoint hit in explorer.exe and sure enough\nwe do. We can continue on reversing from here but letâ€™s dump this segment and save it so\nwe can annotate our debugging sessions and build on this previous knowledge. The way we\ncan do this in IDA is take a memory snapshot. We have to View -> Open Subviews ->\nSegments so that we can view a memory map. Noting our addresses from\n[WriteProcessMemory we need to change those segments to Loader segments. Next up go](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\nto Debugger and take memory snapshot and choose only Loader Segments. If you notice in\nour column our only dump will be of the three sections we marked â€˜Loaderâ€™ segment. If you\ndonâ€™t mark them as Loader segments IDA will ignore them and exclude from putting them\ninto the database/idb. Here you have it and thatâ€™s how you dump injected code from any\nprocess with IDA Pro. Hope you enjoyed reading this article.\n\nReferences:\n\n[1] â€“ [Tigaâ€™s IDA video tutorials](http://www.woodmann.com/TiGa/)\n\n\n-----\n\n[2] â€“ [CodeProject Code Injection methods](http://www.codeproject.com/KB/threads/winspy.aspx)\n\n[3] â€“ [Contagio malware dump](http://contagiodump.blogspot.com/)\n\n[4] â€“ [IDA Docs Page](http://www.hex-rays.com/idapro/idadoc/)\n\n[5] â€“ [Virtualbox Networking Doc](http://www.virtualbox.org/manual/ch06.html)\n\n~ by malwareninja on September 27, 2011.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2011/2011-09-27 - Debugging Injected Code with IDA Pro.pdf"
    ],
    "report_names": [
        "2011-09-27 - Debugging Injected Code with IDA Pro.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535864,
    "ts_updated_at": 1743041154,
    "ts_creation_date": 1653752091,
    "ts_modification_date": 1653752091,
    "files": {
        "pdf": "https://archive.orkl.eu/64bb2f6da54223da60e6d5e50bab2f343bb66a76.pdf",
        "text": "https://archive.orkl.eu/64bb2f6da54223da60e6d5e50bab2f343bb66a76.txt",
        "img": "https://archive.orkl.eu/64bb2f6da54223da60e6d5e50bab2f343bb66a76.jpg"
    }
}