{
    "id": "8606ac2b-e8f5-4767-b7ed-0d75cd9c005a",
    "created_at": "2023-01-12T15:05:08.721569Z",
    "updated_at": "2025-03-27T02:05:26.416731Z",
    "deleted_at": null,
    "sha1_hash": "b70af9dfb7033f0b9b28a12a6aff482e9bc8957c",
    "title": "2019-02-16 - Spoofing in the reeds with Rietspoof",
    "authors": "",
    "file_creation_date": "2022-05-28T21:58:56Z",
    "file_modification_date": "2022-05-28T21:58:56Z",
    "file_size": 776684,
    "plain_text": "# Rietspoof Malware Family Increases Activity\n\n**blog.avast.com/rietspoof-malware-increases-activity**\n\n[Threat Intelligence Team 16 Feb 2019](https://blog.avast.com/author/threat-intelligence-team)\n\nWe’re tracking a new cyberthreat that combines file formats to create a more versatile\nmalware.\n\n_Authored by: Luigino Camastra, Jan Širmer, Adolf Středa and Lukáš Obrdlík_\n\nSince August 2018, we have been monitoring a new malware family we’re calling\n**Rietspoof. Rietspoof is a new multi-stage malware that exhibits some very striking features**\nand capabilities. When we began tracking Rietspoof, it was updated about once a month.\nHowever, in January 2019, we noticed the update cadence change to daily.\n\nRietspoof utilizes several stages, combining various file formats, to deliver a potentially more\nversatile malware. Our data suggests that the first stage was delivered through instant\nmessaging clients, such as Skype or Live Messenger. It delivers a highly obfuscated Visual\nBasic Script with a hard-coded and encrypted second stage — a CAB file. The CAB file is\nexpanded into an executable that is digitally signed with a valid signature, mostly using\nComodo CA. The .exe installs a downloader in Stage 4.\n\n\n-----\n\nWhat s interesting to note, is that the third stage uses a simple TCP protocol to communicate\nwith its C&C, whose IP address is hardcoded in the binary. The protocol is encrypted by AES\nin CBC mode. In one version we observed the key being derived from the initial handshake,\nand in a second version it was derived from a hard-coded string. In version two, the protocol\nnot only supports its own protocol running over TCP, but it also tries to leverage\nHTTP/HTTPS requests. It is uncommon to see a C&C communication protocol being\nmodified to such an extent, given the level of effort required to change the communication\nprotocol. While it is common to change obfuscation methods, C&C communication usually\nremains relatively constant in most malware.\n\nThis downloader uses a homegrown protocol to retrieve another stage (Stage 4) from a hardcoded address. While Stage 3 protocol includes bot capabilities, Stage 4 acts as a\ndesignated downloader only.\n\nAdditionally, the C&C server communicates only with IP addresses set to USA which leads us\nto the hypothesis that we are working with a specifically targeted attack or the attackers are\nusing the USA IP range only for testing reasons. And, it is possible that there are more\nstages that haven’t been revealed yet. Here are the results of our full analysis to date.\n\n## VBS deobfuscate & drop embedded file\n\nThe first part of the Visual Basic script is a function for reading and deobfuscating embedded\nbinaries.\n\nFrom this snippet, it is immediately obvious that the script starts reading code at a specific\noffset deobfuscating the CAB file and readying it for the next stage. The code is, character by\ncharacter, converted to its ANSI value and added to the counter variable. At every step, the\n_counter is XORed with val_01 (hard-coded to 15) and appended to already decoded bytes._\nInterestingly, at every step, the string var_str_01 is also appended to var_str_02.\n\nAfter this step,\n\nthe var_str_02 is used as a parameter for a new function. The second parameter is\nTempPath with the following filename:\n\n\n-----\n\nIn this stage, the CAB file is saved to the machine’s Temp folder under the name\n“JSWdhndk.sjk.” The following stage needs to be extracted from it, which is accomplished by\nusing expand.exe:\n\n## Executing PE and covering tracks\n\nThe script first checks if the logged user is an Admin by simply reading the registry key\n_\"HKEY_USERS\\S-1-5-19\\Environment\\TEMP\". In case of success it set func_read_Registry_\nto True\n\nWhen this flag is set to True, the VBS changes the date to 01-01-2109, deletes the CAB file\nfrom %TEMP%, runs the expanded executable file, and deletes the original script to cover its\ntracks. And, then, it change the date back to the actual date. This interim date with the year\n2109 is not used in the script not dropped files. At the beginning, we thought this was just a\ntypo and the intended interim date was 01-01-2019 but this hypothesis was not confirmed.\n\nAn interesting move from the malware authors is to use cmd /c to run commands from the\ncommand line. Look at the description of this command:\n\n\n-----\n\nThis is most likely an attempt to break behavior detections by spawning more command lines\nwith carried out commands.\nEven if the previous step is skipped, if the current user is not the admin, the next step is to\nrun the expanded PE file. At first, the script deletes a scheduled task Microsoft Windows\n_DOM object helper. This is done by the malware authors to be sure that they can create a_\nnew value in schedule tasks pointing to the expanded PE file which was expanded from the\nprevious stage; it is set to execute after one minute. Then the CAB file is deleted from\n_%TEMP% directory._\n\n## Adding persistence\n\nIn the new version of the VBS,, the malware authors added a new function for persistence\nstarting on January 22, 2019. The script creates a new LNK file in startup with the name\n_WindowsUpdate.lnk. This lnk file runs an expanded PE file after startup to ensure the_\nexecutable will run if the machine is rebooted.\n\n## Signature\n\nAlmost every version of the VBS file contains a new certificate, for example:\n\nWhen we simply transform this block of code from base64 to hex, and then parse this ASN.1\nhex string, we obtain the serial number of this certificate:\n\n\n-----\n\n_Most certificates are issued by COMODO or Sectigo_\n\n## Stage 3 - Dropped bot\n\nSo far, we have seen two versions of the third stage of Rietspoof, observing they differ mostly\nin terms of communication protocol. This stage has the capabilities of a simple bot: it can\ndownload/upload files, start processes, or initiate a self-destruct function. The C&C server\n\n\n-----\n\nalso seems to have implemented basic geofencing based on IP address. We didn t receive\nany “interesting” commands when we tried to communicate with it from our lab network;\nhowever, when we virtually moved our fake client to the USA, we received a command\ncontaining the next stage.\n\nWe noticed that development of this third stage is rapidly evolving, sometimes running two\ndifferent branches at once. During our analysis, the communication protocol was modified\nseveral times and new features were added. For example, string obfuscation was supported\nin earlier versions, implemented several days later, and then on the 23rd of January, we saw\nsamples that rolled back some of these changes. Newer versions also support the command\nline switch “/s,” used to install themselves as a service named “windmhlp”.\n\n### Timeline\n\n15.1. Obfuscation placeholders, communication protocol v1\n\n18.1. Implemented obfuscation, service installation, communication protocol v2\n\n22.1. Obfuscation scrapped, communication protocol v1\n\n23.1. Obfuscation scrapped, communication protocol v1, service installation\n\nThe bot is either blocked by geofencing or there’s currently no ongoing distribution. The\ncommunication has a simple structure:\n\nReq: client_hello (Deprecated in version 2)\nRes: client_hello (Deprecated in version 2)\n\nReq: ID\n\nRes: OK or HARDWARE\n\nReq: HW (if previous response was HARDWARE)\n\nRes: OK\n\nThe command “HARDWARE” is sent only if the sent client ID is seen for the first time. The\ncommand “OK” always results in communication termination. This simple protocol is executed\nperiodically every several minutes.\n\n### Communication protocol v1\n\nThe first version of the third-stage communication uses a rather simplistic protocol. At first, a\nkey and initialization vector is generated by a handshake that consists of a message and a\nresponse, both 32 random bytes and a 4-byte CRC32 checksum. Afterwards, the random\n\n\n-----\n\nbytes are xor-ed together, and applying SHA256 on the result yields the key. Similarly,\napplying MD5 on the SHA256 digest yields the initialization vector. From now on, these\nparameters are used to encrypt messages by AES-CBC. Note that the padding function is\nstrangely designed: the last block is padded to 16 bytes, if necessary, and another 16 zerobytes are always appended after the last block.\n\n_Initial handshake and the subsequent key generation: there’s a_\n_check for port array, which is not shown, overflow in-between these two blocks._\n\n\n-----\n\n_String “HELLO\\n” that is obfuscated and subsequently_\n_deobfuscated - obfuscation placeholder_\n\nThe communication starts with client_hello, a message simply containing “HELLO\\n” that\nexpects “HELLO\\n” as a reply (actually “HELLO\\n\\n\\n\\n\\n\\n…” was always the reply). Then,\nthe client sends a command “ID:<MD5 of adapter MAC address>2.10\\n”. Either a response\n“OK”, “HARDWARE”, or a more powerful command is received. In the former, the\ncommunication ends and the communication loop sleeps for two to five minutes. The\nresponse “HARDWARE” induces a request “HW:<OS info> CPU<CPU info> RAM: <RAM\n_info> USER: <process privileges>”, process privileges being either “admin” (the process has_\nadministrator privileges) or “user” (otherwise). Again, after this message a response “OK” is\nreceived, similarly ending the communication.\n\nOne of six alternative commands may follow instead of OK:\n\n\n-----\n\nDEL:\n<filename>\n\nRUN:\n<filename>\n\nDWN:\n<filename>\n\nUPL:\n<filename>\n\nDAR:\n<filename>\n\n\nDelete file, the filename is prefixed by the location of %TEMP%\n\nCreate process with the file as lpCommandLine, the filename is prefixed by\nthe location of %TEMP%\n\nDownload a file, if the filename has suffix .upgrade then dump VBS update\nscript which replaces the malware with a newer version.\n\nUpload file from %TEMP%\n\nDownload, save to %TEMP%/<filename> and execute\n\n\nDSF:\\n Delete itself\n\n### Communication protocol v2\n\nThe second version of the third stage of Rietspoof also uses a rather similar protocol with a\nfew new additions. The second version tries to communicate over HTTP/HTTPS, unless a\nproxy is set up, in which case it resorts to raw TCP. This new version also eschews the initial\nhandshake, as it uses a hardcoded string “M9h5an8f8zTjnyTwQVh6hYBdYsMqHiAz” instead\nof XORing two random strings. Again, this string is put through SHA256, yielding a key, and\nSHA256 composed with MD5, yielding an initialization vector. These parameters are used to\nencrypt messages by AES-CBC.\n\n_Obfuscated “HELLO\\n” string_\n\n\n-----\n\nThe HTTP GET requests, generated by the malware, are more or less ordinary with the\nexception of three headers that may be present. An example of the HTTP request is below.\nNote that Content-MD5 header is not mandatory; moreover, the Content-MD5 header is used\nin a custom and standard non-compliant way. Also, the User-agent string is hard-coded in the\nbinary.\n\n_GET /<path>?<GET data> HTTP/1.1_\n_Host:<domain>_\n_Connection:close_\n_Content-MD5:<base64 encoded message>_\n_User-agent:Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204_\n_Firefox/2.0.0.1_\nFortunately for us, the old protocol is still present for cases when an HTTP proxy is used. We\nbelieve that this may serve as a protection against trivial man-in-the-middle attacks that could\nbe utilized during analysis of the malware. However, in our case, it allows us to deploy a new\ntracking script with very few modifications, as only the key agreement protocol has been\nchanged.\n\n## Stage 4 - Downloader\n\nThis stage tries to establish an authenticated channel through NTLM protocol over TCP with\nits C&C whose IP address is hardcoded.\n\n_Initiate NTLM authentication_\n\n\n-----\n\n_Main loop of authentication and receiving data from C&C server_\n\nAfterwards it starts communicating with the C&C over the aforementioned channel with the\nintent of recovering either another stage or possibly the final payload.\n\n## Conclusion\n\nAs you have read above, this new malware, Rietspoof, has had a significant increase in its\nactivity during January 2019. During this time, the developer has used several valid\ncertificates to sign related files. Also, the payloads went through development, namely\nchanging the implementation of the Stage 3 communication protocol several times. While the\ndata on Rietspoof is extensive, motives and modus operandi are still unknown, as are the\nintended targets. And, to date, the malware-infected files are rarely being detected by most\nantivirus software.\n\nOur research still cannot confirm if we’ve uncovered the entire infection chain. While the\nmalware has bot capabilities, it seems to have been primarily designed as a dropper.\nAdditionally, the low prevalence and use of geofencing signifies other possible unknowns. For\ninstance, we may have missed other samples that are distributed only to a specific IP\naddress range.\n\n\n-----\n\nWe are not sharing IoCs publicly, but, if you are able to prove to Avast that you are an antimalware analyst or researcher, we will make the IoCs available to you. In this case feel free\nto contact [@n3ph8t3r,](https://twitter.com/n3ph8t3r) [@StredaAdolf and](https://twitter.com/StredaAdolf) [@sirmer_jan on Twitter.](https://twitter.com/sirmer_jan)\n\n## Update 2/20/19:\n\nThanks to the [Malware Hunter Team, we received information about the first stage of](https://twitter.com/malwrhunterteam/status/1097568650507284483)\nRietspoof. It seems that Rietspoof was spread using a Microsoft Word document with\nmacros. The document acts as a dropper and a runner for the aforementioned VBS. Upon\ninitial inspection the document shows an almost traditional image that is used to persuade\nusers to enable macros, as can be seen below:\n\nOnce macros are enabled, the information regarding the protected document is deleted and a\ntitle “Emergency exit map” is shown.\n\n\n-----\n\nAfterwards, this part of the script deobfuscates the VBS and saves it onto the machine,\nexecuting wscript.exe with a parameter\n\n_c:\\users\\NAME\\appdata\\roaming\\microsoft\\word\\startup\\.\\.\\\\Windows\\Cookies\\wordTemplate.vbs,_\nthat is a path leading to the dropped VBS, to execute the payload.\n\nThe Visual Basic script, that we described earlier, is embedded in the document as a base64\nstring encoded in hex.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-02-16 - Spoofing in the reeds with Rietspoof.pdf"
    ],
    "report_names": [
        "2019-02-16 - Spoofing in the reeds with Rietspoof.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535908,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653775136,
    "ts_modification_date": 1653775136,
    "files": {
        "pdf": "https://archive.orkl.eu/b70af9dfb7033f0b9b28a12a6aff482e9bc8957c.pdf",
        "text": "https://archive.orkl.eu/b70af9dfb7033f0b9b28a12a6aff482e9bc8957c.txt",
        "img": "https://archive.orkl.eu/b70af9dfb7033f0b9b28a12a6aff482e9bc8957c.jpg"
    }
}