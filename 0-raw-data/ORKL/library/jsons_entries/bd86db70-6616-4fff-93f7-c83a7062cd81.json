{
    "id": "bd86db70-6616-4fff-93f7-c83a7062cd81",
    "created_at": "2023-05-06T02:09:02.352942Z",
    "updated_at": "2025-03-27T02:08:33.299858Z",
    "deleted_at": null,
    "sha1_hash": "4860acc9a0f3bf8296cc01aaa33b64319110780a",
    "title": "2023-04-08 - Dcrat - Manual De-obfuscation of .NET Malware",
    "authors": "",
    "file_creation_date": "2023-05-05T01:52:31Z",
    "file_modification_date": "2023-05-05T01:52:31Z",
    "file_size": 5612521,
    "plain_text": "# Dcrat Deobfuscation - How to Manually Decode a 3-Stage .NET Malware\n\n**embee-research.ghost.io/dcrat-manual-de-obfuscation/**\n\nMatthew April 8, 2023\n\n[dnspy\nFeatured](https://embee-research.ghost.io/tag/dnspy/)\nManual analysis and deobfuscation of a .NET based Dcrat. Touching on Custom Python\nScripts, Cyberchef and .NET analysis with Dnspy.\n\n\n-----\n\nAnalysis of a 3-stage malware sample resulting in a dcrat infection. The initial sample\ncontains 2 payloads which are hidden by obfuscation. This analysis will demonstrate\nmethods for manually uncovering both payloads and extracting the final obfuscated C2.\n\nIf you've ever wondered how to analyse .net malware - this might be the blog post for you.\n\n**Tooling**\n\n## Samples\n\n[The malware file can be found here](https://bazaar.abuse.ch/sample/fd687a05b13c4f87f139d043c4d9d936b73762d616204bfb090124fd163c316e/?ref=embee-research.ghost.io)\n\n[And a copy of the decoding scripts here](https://github.com/embee-research/Decoders/tree/main/2023-April-dcrat?ref=embee-research.ghost.io)\n\n## Initial Analysis.\n\n[The initial file can be downloaded via Malware Bazaar and unzipped it using the password](https://bazaar.abuse.ch/sample/fd687a05b13c4f87f139d043c4d9d936b73762d616204bfb090124fd163c316e/?ref=embee-research.ghost.io)\n```\ninfected\n\n```\n[detect-it-easy is a great tool for initial analysis of the file.](https://github.com/horsicq/Detect-It-Easy?ref=embee-research.ghost.io)\n\n[Pe-studio is also a great option but I personally prefer the speed and simplicity of](https://www.winitor.com/download?ref=embee-research.ghost.io)\n```\n  detect-it-easy\n\n```\nDetect-it-easy revealed that the sample is a 32-bit .NET-based file.\n\n- The protector Confuser(1.X) has also been recognized.\n\n\n-----\n\nInitial analysis using Detect-it-easy\n\nBefore proceeding, I checked the entropy graph for signs of embedded files.\n\nI used this to determine if the file was really dcrat, or a loader for an additional payload\ncontaining dcrat.\nIn my experience, large and high entropy sections often indicate an embedded payload.\nIndicating that the file being analyzed is a loader.\n\n\n-----\n\nEntropy Analysis of the Initial .exe file - Showing a large section of high entropy\nThe entropy graph revealed that a significant portion of the file has an entropy of 7.98897\n(This is very high, the maximum value is 8).\n\nThis was a strong indicator that the file is a loader and not the final dcrat payload.\n\nIn order to analyze the suspected loader, I moved on to Dnspy\n\n## Dnspy Analysis\n\nUtilizing Dnspy, I saw that the file had been recognized as rewrwr.exe and contained\n[references to confuserEx. Likely this means the file is obfuscated using ConfuserEx and](https://mkaring.github.io/ConfuserEx/?ref=embee-research.ghost.io)\nmight be a pain to analyze.\n\n\n-----\n\nDnspy overview of the initial file\nIn order to peek at the code being executed - I right-clicked on the rewrwr.exe name and\nselected go to entry point\n\nThis would give me a rough idea of what the actual executed code might look like.\n\nThe file immediately creates an extremely large array of unsigned integers. This could be an\nencrypted array of integers containing bytecodes for the next stage (further suggested by a\npost-array reference to a Decrypt function)\n\nViewing Encrypted Arrays using Dnspy\n\nUsing Dnspy to locate and view the Decryption function\n\n[The initial array of uints was so huge that it was too large to display in Dnspy.](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/52ddd4c3-55b9-4e03-8287-5392aac0627f?ref=embee-research.ghost.io)\n\n\n-----\n\nGiven the size, I suspected this array was the reason for the extremely high entropy\npreviously observed with detect-it-easy\nAfter the array, there is again code that suggests the array's contents are decrypted, then\nloaded into memory with the name koi\n\nGiven the relative simplicity of the code so far - I suspected the encryption was not complex,\nbut still, I decided not to analyze it this time.\n\nInstead, I considered two other approaches\n\nSet a breakpoint after the Decrypt call and dump the result from memory.\nSet a module breakpoint to break when the new module decrypted and loaded. Then\ndump the result into a file.\n\nI took the second approach, as it is reliable and useful for occasions where the location of\ndecryption and loading isn't as easy to find. (Typically it's more complicated to find the\nDecryption function, but luckily in this case it was rather simple)\n\nEither way, I decided to take the second approach.\n\n## Extracting Stage 2 using Module Breakpoints\n\nTo extract stage 2 - I first created a module breakpoint which would break on all module\nloads.\n\nTo do this, I first opened the module breakpoints window.\n```\nDebug -> Windows -> Module Breakpoints\n\n```\n\n-----\n\nHow to set a module breakpoint using Dnspy\nI then created a module breakpoint with two wildcards. This will break on all new modules\nloaded by the malware.\n\nModule breakpoint to break on all loaded modules\nI then executed the malware using the start button\n\nDnspy button to Start or Continue execution\nI accepted the default options.\n\n\n-----\n\nDefault options for Dnspy Debugging are ok\n\n[Immediately, a breakpoint was hit as mscorelib.dll was being loaded into memory. This is a](https://www.processlibrary.com/en/directory/files/mscorlib/28337/?ref=embee-research.ghost.io)\ndefault library and I ignored it by selecting Continue\n\nDnspy alert when a module breakpoint has been triggered\n\nOnce executing - the Continue button can be used to resume execution\nThe next module loaded was the original file being analyzed, which in this case can be safely\nignored.\n\nAfter that, a suspicious-looking koi module was loaded into memory. (If you don't have a\n```\nmodules window, go to debug -> windows -> modules)\n\n```\n\n-----\n\nHow to View Currently Loaded Modules in Dnspy\nHere I could see the koi module had been loaded.\n\nExample of a suspicious module being loaded into memory\nAt this point, I saved the koi module to a new file using Right-Click -> Save Module.\n\n\n-----\n\nDnspy Option for Saving a Loaded Module\nI then exited the debugger and moved on to the koi.exe file.\n\n## Analysis of koi.exe\n\nThe koi.exe file is another 32-bit .net file. Containing references to ConfuserEx\n\nInitial Analysis of a .NET file using Detect-it-easy\nThis time it does not seem to contain any large encrypted payloads.\n\nAlthough the overall entropy is low, large portions of the graph are still suspiciously flat.\nThis can sometimes be an indication of text-based obfuscation.\n\n\n-----\n\nEntropy Analysis when a text based obfuscation is used\nI moved on and opened koi.exe using dnspy.\n\nThis time there was another rewrwr.exe name and references again to ConfuserEx\n\nFile Overview with Dnspy\n\n\n-----\n\nThere was no Entry point available, so I started analysis with the rewrwr namespace in the\nside panel. This namespace contained one Class named Form1\n\nThe Form1 class immediately called Form1_Load, which itself immediately referenced a large\nstring that appears to be base64 encoded.\n\nExample of Entry Point Containing Obfuscated Data\nDespite appearing to be base64 - the text does not successfully code using base64. This\nwas an indicator that some additional tricks or obfuscation had been used.\n\nAttempting to Decode Base64 Using Cyberchef - Initially fails due to additional obfuscation\nI decided to jump to the end of the base64-looking data - Noting that there were about 50\nlarge strings in total. Each titled Str1 `str2 ... all the way to Str49`\n\nIt was very likely these strings were the cause of the flat entropy graph we viewed\nearlier. Text based obfuscation tends to produce lower entropy than \"proper\" encryption\n\n\n-----\n\nExample of another \"base64\" obfuscated string in Dnspy\nAt the end of the data was the decoding logic. Which appeared to be taking the first\ncharacter from each string and adding it to a buffer.\n\nDecoding Logic Utilised by the Dcrat Loader - Viewed with Dnspy\nAfter the buffer had been filled, it was base64 decoded and loaded into memory as an\nadditional module.\n\nExample of Decoded Contents being loaded into Memory\nIn order to confirm the theory on how the strings were decoded, I took the first character from\nthe first 5 strings and base64 decoded the result.\n\n\n-----\n\nBrief Overview of the Additional obfuscation used\n\nExample of this decodes using\n\nbase64\n\nThis confirmed my theory on how the malware was decoding the next stage.\n\nIn order to extract the next module, I copied out the strings and put them into a Python script.\n\n\n-----\n\nPython Script to Decode the Dcrat Encoded Strings\nRunning this script created a third file. Which for simplicity's sake was named output.bin\n\nThe file was recognized as a 32-bit .NET file. So the decoding was successful.\n\nInitial Analysis of Third .NET File using Detect-it-easy\n\n## Stage 3 - Analysis\n\nNow I had obtained a stage 3 file - which again was a 32-bit .net executable.\n\n\n-----\n\nThis time - no references to ConfuserEx\n\nInitial Analysis of Third .NET File using Detect-it-easy\nThe entropy was reasonably normal - and did not contain any large flat sections that may\nindicate a hidden payload.\n\n\n-----\n\nThe lack of ConfuserEx and relatively normal entropy - was an indication that this may be the\nfinal payload.\n\nMoving on to Dnspy, the file is recognized as IvTdur2zx\n\nDespite the lack of ConfuserEx, the namespaces and class names look terrible.\n\n\n-----\n\nDnspy view of Obfuscated Functions in Final Payload\nI then went to the Entry-point to see what was going on\n\nThe first few functions were mostly junk - but there were some interesting strings referenced\nthroughout the code.\n\nFor example - references to a .bat script being written to disk\n\n\n-----\n\nDnspy Overview of Strings in The .NET File\nSince the strings were largely plaintext and not-obfuscated - At this point I used detect-it```\neasy to look for more interesting strings contained within the file.\n\n```\nThis revealed a reference to DCrat - as well as some potential targeted applications (discord,\nsteam, etc)\n\nOverview of some plaintext strings contained in the malwar.e\nAt that point, you could probably assume the file was DCrat and an info stealer - but I wanted\nto continue my analysis until I'd found the C2.\n\nIn the above screenshot - I noticed there were some interesting strings that looked like\nbase64 encoding + gzip (the H4sIAA* is a base64 encoded gzip header).\n\n[So I attempted to analyze these using CyberChef.](https://gchq.github.io/CyberChef/?ref=embee-research.ghost.io)\n\nThe first resulted in what appeared to be a base64 encoded + reversed string.\n\nThis was strongly hinted by the presence of == at the start.\n\n\n-----\n\nCyberchef - Base64 + Gzip + Additional Obfuscation\n\nAfter applying a character reverse + base64 decode. I was able to obtain a strange\ndictionary as well as a mutex of Wzjn9oCrsWNteRRGsQXn + some basic config.\n\nThis was cool but still no C2.\n\nCyberchef - Decoding the \"base64\" strings\nI then tried to decode the second base64 blob shown by detect-it-easy.\n\nBut the result was largely junk.\n\n\n-----\n\nCyberchef - Failed Decoding of Additional \"base64\" strings\nAttempting to reverse + base64 decode returned no results.\n\nCyberchef - Additional failures when decoding strings\nAt this point - I decided to search for the base64 encoded string to see where it was\nreferenced in the .net code.\n\nUsing Dnspy to search for string cross references (x-refs)\nThis revealed an interesting function showing multiple additional functions acting on the\nbase64 encoded data.\n\nIn total, there are 4 functions ( M2r.957, M2r.i6B, M2r.1vX, M2r.i59 ) which are acting on\nthe encoded data.\n\n\n-----\n\nViewing Additional layers of string obfuscation using Dnspy\nThe first function M2r.957 is a wrapper around another function M2r.276 which performed\nthe base64 and Gzip decoding.\n\nDelving Deeper into an \"obfuscation\" function.\nThe next function M2r.i6B took the previously obtained string and then performed a Replace\noperation based on a Dictionary\n\nCyberchef View of Obfuscated String\n\nInteresting to note - is that the Value is replaced with the Key and not the other way\naround as you might expect.\n\n\n-----\n\nDnspy - Overview of Dictionary based String Replace\nBased on the previous code, the input dictionary was something to do with a value of SCRT\n\nAnalysing additional string obfuscation using Dnspy\nSuspiciously - there was an SCRT that looked like a dictionary in the first base64 string that\nwas decoded.\n\nCyberchef - locating the dictionary used for decoding\nSo I obtained that dictionary and prettied it up using Cyberchef to remove all of the \\\nescapes.\n\n\n-----\n\nCleaning up escape characters with Cyberchef\nI then created a partial Python script based on the information I had so far. (I'll post a link at\nthe end of this post)\n\nPython Script used to decode the string\nExecuting this result and printing the result - I was able to obtain a cleaner-looking string\nthan before.\n\nHere's a before and after\n\nBefore applying additional text-replacement\n\nAfter applying additonal text-replacement\nIt was probably safe to assume this string was reversed + base64 encoded, but I decided to\ncheck the remaining two decoding functions just to make sure.\n```\nM2r.1vX was indeed responsible for reversing the string.\n\n```\n\n-----\n\nDnspy - Analysis of additional obfuscation (string reverse)\n```\nM2r.i59 was indeed responsible for base64 decoding the result.\n\n```\nDnspy - Analysis of additional obfuscation (base64 encoding)\nSo I then added these steps to my Python script.\n\nUpdated Python Script for decoding Dcrat\nAnd executed to reveal the results - successful C2!\n```\nhttp://battletw[.]beget[.]tech/\n\n```\n\n-----\n\nSuccessfully obtaining the decoded C2 using python.\n(The URL's contained some base64 reversed/encoded strings and were not very interesting)\n\nThis C2 domain had only 2/85 hits on VirusTotal\n\nAt this point, I had obtained the C2 and decided to stop my analysis.\n\nIn a real environment - it would be best to block immediately this domain in your security\nsolutions. Additionally, you could review the previous string dumps for process-based\n\n\n-----\n\nindicators that could be used for hunting signs of successful execution.\n[Additionally - you could try and derive some Sigma rules from the string dumps. Or](https://github.com/SigmaHQ/sigma?ref=embee-research.ghost.io)\npotentially use the C2 URL structure to hunt through proxy logs.\n\n## Links:\n\nCopies of the decoding scripts - https://github.com/embeeresearch/Decoders/tree/main/2023-April-dcrat\n\nLink to the original malware https://bazaar.abuse.ch/sample/fd687a05b13c4f87f139d043c4d9d936b73762d616204bfb09\n0124fd163c316e/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-08 - Dcrat - Manual De-obfuscation of .NET Malware.pdf"
    ],
    "report_names": [
        "2023-04-08 - Dcrat - Manual De-obfuscation of .NET Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1683338942,
    "ts_updated_at": 1743041313,
    "ts_creation_date": 1683251551,
    "ts_modification_date": 1683251551,
    "files": {
        "pdf": "https://archive.orkl.eu/4860acc9a0f3bf8296cc01aaa33b64319110780a.pdf",
        "text": "https://archive.orkl.eu/4860acc9a0f3bf8296cc01aaa33b64319110780a.txt",
        "img": "https://archive.orkl.eu/4860acc9a0f3bf8296cc01aaa33b64319110780a.jpg"
    }
}