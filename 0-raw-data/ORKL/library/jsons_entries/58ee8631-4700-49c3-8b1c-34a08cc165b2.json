{
    "id": "58ee8631-4700-49c3-8b1c-34a08cc165b2",
    "created_at": "2022-10-25T16:48:22.396038Z",
    "updated_at": "2025-03-27T02:05:36.3747Z",
    "deleted_at": null,
    "sha1_hash": "d246e3075bbd31f04b2a6efb53ad7d9e9faa0e96",
    "title": "Derusbi (Server Variant) Analysis",
    "authors": "Novetta",
    "file_creation_date": "2014-10-28T02:31:15Z",
    "file_modification_date": "2014-10-28T02:31:15Z",
    "file_size": 578512,
    "plain_text": "# Derusbi (Server Variant) Analysis \n\n## Overview\nThere are two types of Derusbi malware: a client-server model and a server-client model. Both\ntypes provide basic RAT functionality with the distinction between the two being largely the\ndirectionality of the communication. This report will focus on the server-client variant (or simply,\nthe “server variant”) of Derusbi, which acts as a server on a victim’s machine and waits for\ncommands from a controlling client.\n\nIn and of itself, the Derusbi server variant is a largely unremarkable RAT when viewed from the\nperspective of functional capabilities. The server variant supports basic RAT functionality such\nas file management (uploading and downloading), network tunneling and remote command\nshell. What makes the server variant interesting is the device driver that the variant installs.\n\nThe server variant utilizes a device driver in order to hook into the Windows firewall by either\nusing largely undocumented Windows Firewall hooking techniques found in Windows XP and\nolder or by using the documented Windows Filtering Platform found in Windows Vista and later.\nThe driver, after hooking the firewall using either of the two mentioned interfaces, will inspect\nincoming network packets. If a specific handshake occurs between the client and the server\nvariant, the remainder of the communication session for the established session will be\nredirected to the server variant. If the driver does not detect the appropriate handshake, then\nthe network traffic is allowed to pass unobstructed. This allows an attacker to hide their\ncommunication within a cluster of network sessions originating from a single IP such as would\nbe the case for a client performing multiple HTTP requests against a web server.\n\n## Startup Sequence\nThe server variant runs as a svchost dependent service. While the server variant binary does\nhave exports related to the standard service DLL (e.g. ServiceMain, DllRegisterService,\netc.), the startup sequence truly begins in the DllEntryPoint function.\n\nWhen loaded into memory via a LoadLibrary or equivalent function call, the server variant will\ndetermine the name of the host binary (presumably svchost.exe) as well as its own DLL’s\nname. The binary then spawns a new thread that contains the main server variant code in order\nto allow the DllEntryPoint routine to return to the calling function.\n\nWithin the main server variant function (dubbed mainThread), the server variant loads a\npointer to the API function GetCommandLineW, locates the pointer in memory to the command\nline string, and then locates the first space within the command line string and terminates the\nstring by placing a NULL character at the location.\n\nThe server variant then attempts to determine if it has suitable access rights within the system in\norder to operation. The check for access rights effectively checks to see if the server variant\nprocess is running under the NT Authority. If the check is unsuccessful, then the server\nvariant terminates.\n\nWith the command line patched and authority verified, the server variant sleeps for 5 seconds\nbefore verifying that the fShutdown flag is not set. The fShutdown flag can become set by the\n\n\n-----\n\nprocess loading the server variant calling the DllRegisterServer export. The\n```\nDllRegisterServer function, among other tasks, will attempt to install the server variant as a\n\n```\nserver on the victim’s machine. Therefore, by waiting 5 seconds before continuing the\n```\nmainThread functionality, the server variant is giving the DllRegisterServer time to\n\n```\nactivate and perform the necessary operations to ensure that the server variant is properly\ninstalled and activated as a service.\n\nThe mainThread calls the mainLoop function of the server variant. The mainLoop function\nbegins by loading the unique infection ID for the victim’s machine from the registry (under the\nkey value located at HKLM\\SOFTWARE\\Microsoft\\Rpc\\Security). The infection ID, if\npresent, must be decoded by XOR’ing each byte of the string with a static byte value (typically\n```\n0x5F). If the infection ID does not exist within the registry, the server variant will attempt to load\n\n```\nthe configuration from an encoded buffer located immediately after the static string\n```\nXXXXXXXXXXXXXXX, decode the buffer by starting at the last byte and XORing each previous\n\n```\nbyte by the current byte value in reverse order; the server variant will then use a specific portion\nof the configuration blob as the infection ID’s base. Next, the server variant will append a\nhyphen and a four digit value to the end of the infection ID to generate the unique infection ID\nfor the victim’s machine. The newly generated infection ID is then saved to the registry location\nstated previously.\n\nThe mainLoop attempts to get the privileges for SeDebugPrivilege,\n```\nSeLoadDriverPrivilege, SeShutdownPrivilege, and SeTcbPrivilege in order to\n\n```\nperform the necessary operations to load the driver portion of the server variant. The mainLoop\nwill attempt to open a handle to the driver (if it is already installed) by calling CreateFile with\nthe filename of \\Device\\{93144EB0-8E3E-4591-B307-8EEBFE7DB28F}. Failing this, the\n```\nmainLoop determines if the victim’s machine is running the 360 antivirus product by looking for\n\n```\na process with the name ZhuDongFangYu.exe. If the process is running, the driver is not\ninstalled but the mainLoop continues regardless. If the process is not found, however, the\n```\nmainLoop will extract the driver binary from an encoded buffer within itself, decode the file in\n\n```\nmemory (using a rotating 4-byte XOR key), and install the driver on the victim’s machine as\n```\n%SYSDIR%\\Drivers\\{93144EB0-8E3E-4591-B307-8EEBFE7DB28F}.sys. \n\n```\nWith the driver present (or recently installed), the mainLoop spawns another thread (dubbed\n```\nDerusbiThread::DerusbiThread) that acts as the primary communication loop.\nDerusbiThread::DerusbiThread begins by generating a PCC_SOCK object. PCC_SOCK is\n\n```\nan abstraction for the communication subsystem. The prototype for PCC_SOCK appears in\nFigure 1.\n\n\n-----\n\n```\nclass BD_SOCK\n{\n // members\n ~BD_SOCK(); // destructor\n BD_SOCK* Copy(bool fCopySocket); // duplicate object\n // member variables\n DWORD dwLastError;\n char szHostName[256];\n DWORD dwListeningPortNumber;\n SOCKET sktRemoteEndpoint;\n SOCKET hListeningSocket;\n };\nclass PCC_SOCK: BD_SOCK\n{\n ~PCC_SOCK(); // destructor\n // virtual members\n PCC_SOCK * Copy(bool fCopyListeningSocket);\n SOCKET ConnectToRemoteEndpointByNameAndAttemptChannelByPOSTOrHandshake(int\na2, int a3, int a4, int a5, char *pszHostname, int wHostPort);\n SOCKET ConnectToRemoteEndpointByNameAndHandshake(char *pszHostname, int\nwHostPort);\n SOCKET ConnectToRemoteEndpointByNameAndPerformPOSTLogin(char *pszHostname,\nint wHostPort);\n SOCKET WaitForClient();\n int SendEncodedData(int dwPktType, void *payload, size_t dwPayloadSize);\n int RecvEncodeData(DWORD *pdwPktType, char **pvPayload, DWORD\n*pdwPayloadSize);\n void freeMemory(void *pMemory);\n // member functions\n int SendVictimInfo();\n int WaitForReadEvent(int dwTimeout);\n int SOCKSConnectWithRandomLocalPort(int dwEndPointIP, u_short hostshort);\n int BindToRandomPort(SOCKET s);\n int SendBuffer(SOCKET s, char *buf, int len);\n SOCKET AcceptIncomingConnection();\n SOCKET ConnectToRemoteEndpointByName(char *szHostName, int hostshort);\n SOCKET ConnectToRemoteEndpoint(int dwIP, u_short wPort);\n int ReadFromRemoteEndpoint(char *buf, int len);\n SOCKET NewSocket();\n int BindSocket(SOCKET s, int dwLowPort, int dwHighPort);\n int SendAuthenicationResponse(void *pvResponse);\n int SendHTTP200ResponseIfViaHeaderFound (char *Str);\n // member variables\n char compressionBuffer[65536];\n};\n\n```\n_Figure 1: PCC_SOCK Declaration in Pseudo-C++_\n\nWith a new PCC_SOCK object allocates, DerusbiThread::DerusbiThread selects a port\nbetween 40,000 and 45,000 to use as a listening port. The port number is sent to the driver (via\nIOCTL 0x220200) in order to inform the driver where to redirect incoming traffic. The “Windows\n\n\n-----\n\nDevice Driver (Firewall Hook)” section explains the functionality of the driver in greater detail.\n```\nDerusbiThread::DerusbiThread binds to the specified port and opens the port as a\n\n```\nlistener. At this point DerusbiThread::DerusbiThread enters an infinite loop of waiting for\nnew connections to the listening socket and dispatching a new thread (dubbed CommLoop) to\nhandle the traffic for the socket until fShutdown is set. At this point, the startup sequence for\nDerusbi is complete and the server variant moves into a communication and command dispatch\nphase.\n\n## Windows Device Driver (Firewall Hook)\nThe communication between the controlling client and the Derusbi server variant depends on\nthe device driver being in place. The authors of the device driver designed the driver to work on\nWindows 2000 and later versions of the Windows operating system. Depending on the version\nof the victim’s OS, the driver will hook the Windows Firewall by either using the surprisingly\nundocumented IOCTL_IP_SET_FIREWALL_HOOK command of the \\\\Device\\IP device for\nWindows XP or older machines or by using the documented Windows Filtering Platform (WFP)\nfound in Windows Vista and later. The device driver inspects incoming network traffic from any\nclient connecting to the victim machine, determines if an appropriate handshake packet occurs\nat the beginning of a new TCP session, and then makes the decision to reroute the network\ntraffic to the Derusbi malware or let the traffic continue unaltered to its original service.\n\n_Figure 2: Device Driver Traffic Redirection_\n\nOnce a session has been established by means of a valid handshake, any subsequent packets\nfrom the client for the given TCP session will automatically be directed by the device driver to\nthe Derusbi server variant. The device driver does not capture or store any network traffic\noutside of the initial handshake inspection.\n\n\n-----\n\n## Communication and Command Dispatch\nThe Derusbi server variant will select an available, random port between the range of 40,000\nand 45,000 on the victim’s machine upon which to listen. After selecting the port, the server\nvariant will wait for incoming connections and instruct the driver to redirect appropriate TCP\nsessions to the listening port.\n\nIn order to establish a valid communication channel between the server variant and a controlling\nclient, a specific handshake is required. The handshake between a client and the server variant\nis well defined and consisting of 64 bytes, the data within the handshake is entirely random with\nthe exception of the 3[rd] and 8[th] DWORD. The handshake begins when the client sends a 64\nbyte random buffer with the 3[rd] (offset 12) and 8[th] (offset 32) DWORDs defined as:\n```\n                DWORD3 == ~DWORD0\n              DWORD8 == ROR(DWORD0, 7)\n\n```\nThe server will acknowledge the handshake by sending a 64 byte random buffer with the same\npattern for the 3[rd] and 8[th] DWORDs based on the new, randomly generated 1[st] DWORD (offset\n0). It is the client’s handshake that the driver for the server variant triggers off of.\n\nSome older versions of the server variant use a different set of DWORDs to validate the\nhandshake, also the tests are the same. These other versions have been observed to use the\nfollowing DWORDs:\n```\n                DWORD1 == ~DWORD0\n              DWORD2 == ROR(DWORD0, 7)\n\n```\nIf the handshake fails, the server variant provides a secondary means to authenticate a client.\nPresumably a failsafe if the driver is unable to load, the secondary method requires the client to\nsend a POST request with the following form:\n```\n           POST /forum/login.cgi HTTP/1.1\\r\\n\n\n```\nIn addition, the POST request must contain a Via field. If the request and the Via field exist,\nthe server variant authenticates the client and responds with\n```\n           HTTP/1.0 200\n           Server: Apache/2.2.3 (Red Hat)\n           Accept-Ranges: bytes\n           Content-Type: text/html\n           Proxy-Connection: keep-alive\n\n```\n\n-----\n\nIf the client’s request does not meet the appropriate authentication criteria, the server variant\nsends:\n```\n            HTTP/1.0 400 Bad Request\n            Server: Apache/2.2.3 (Red Hat)\n            Connection: close\n\n```\nWith a communication channel between the server variant and the client established, the server\nsends information about the victim’s computer. Consisting of a 180 byte data structure (Figure\n3), the server variant provides the client with a variety of details about the victim’s machine. The\n```\nVictimInfoPacket has an identifier of 2 (see the dwPktType explanation below). The\n\n```\ncommunication between the server and the client at this point, and for the remainder of the\nsession, is encrypted.\n```\n#pragma pack(push, 1)\nstruct VictimInfoPacket\n{\n int magicValue;\n char szInfectionID[64];\n char szComputerName[64];\n char szSelfIP[16];\n char unknownArray[16];\n int dwOSandSPVersionInfo;\n int dwBuildNumber;\n char unknownValue;\n char OemId;\n __int16 unused_align2;\n int fCampaignCodeMatch;\n};\n#pragma pack(pop)\n\n```\n_Figure 3: VictimInfoPacket Structure Definition_\n\nCommunication between the client and the server variant exists in the form of a sequence of\nencrypted datagrams. Each datagram consists of a 24 byte header followed by an optional\npayload section. The header is not encrypted but if the optional payload is attached, the payload\nis encrypted using a DWORD XOR. The format of the header is as follows:\n```\nstruct PacketHeader\n{\n   DWORD dwTotalPacketSize;\n   DWORD dwPktType;\n   DWORD dwChecksum;\n   DWORD dwEncryptionKey;\n   DWORD fCompressedPayload;\n   DWORD dwDecompressedSize;\n};\n\n```\n\n-----\n\nThe dwTotalPacketSize field defines the total size of the datagram including both the size of\nthe header and the size of the optional payload. The `dwPktType` field correlates to the module\nID which allows the server variant to route the datagram to the appropriate module without\nfurther inspection of the payload data. The `dwChecksum` value is sum of all of the bytes within\nthe optional header (the field is ignored, but present, if there is no payload section). The\ndwEncryptionKey is the 32-bit XOR encryption key for the payload section. If the\n`fCompressedPayload` field is non-zero, then the data within the payload is compressed using\nLZO compression (prior to XOR encoding) and the dwDecompressedSize field represents the\nfinal size of the payload data after decompression. The payload section can have up to three\ndifferent presentations depending on if compression is used. The first presentation is the original\npayload data as generated by the client or server, the second presentation is the LZO\ncompressed form, and the final presentation (the presentation that exists going across the\nnetwork) is the 32-bit XOR encoded data blob. Figure 4 provides a graphical representation of\nthe presentation types of the payload section.\n\n_Figure 4: Possible Presentations of the Payload Section of a Derusbi Server Variant's Datagram_\n\nAfter sending the server information via the VictimInfoPacket, the server variant spins off a\n```\nCommLoop thread for the connection and returns to waiting for new connections from clients to\n\n```\nappear.\n\nThe CommLoop thread begins by establishing the set of internal command handlers available to\nthe server variant. With the exception of the administrative command handler (which is built into\nthe CommLoop), each of the internal commands consists of an object derived from a base object\n```\nPCC_BASEMOD.\n\n```\n\n-----\n\n```\nclass PCC_BASEMOD\n{\n    ~PCC_BASEMOD(); // destructor\n    // virtual member functions\n    void *return1(); // always returns 1\n    void Cleanup(void);\n    void ProcessPacket(void *pkt, DWORD dwPktSize);\n    int ReadWaitingData(void **pPacket, DWORD *dwPktSize);\n    int MallocWithClear(size_t Size);\n    int Free(void *Memory);\n    // member variables\n    DWORD dwPacketIdentifierCode;\n};\n\n```\n_Figure 5: PCC_BASEMOD Pseudo-C++ Declaration_\n\nThe server variant appears to have a modular design allowing an attacker to compile only the\ncomponents that are necessary for any given operation. The malware supports up to 8 different\nmodules per sample with each module designating its own ID code. Novetta has observed the\nfollowing modules:\n\n**ID** **Class Name** **Module Description**\n`0x81` PCC_CMD Remote command shell\n`0x82` PCC_PROXY Network tunneling\n`0x84` PCC_FILE File management\n`0xF0` n/a Derusbi administrative [built-in module that does not count\nagainst the maximum of 8 modules per variant sample]\n\nGiven the spacing in ID numbers (as noted in the gap between 0x82 and 0x84 in an otherwise\nsequential ID scheme), it is conceivable that additional modules exist.\n\nAfter establishing the tools, an infinite loop (CommLoop) is entered in which the server variant\nwill wait for up to 1/100 of a second for input from the network; if such input arrives, the server\nroutes the packet to the appropriate handler. If the network input does not arrive, the CommLoop\nqueries each of the command handlers for any packets they may have queued (by calling each\ncommand handler’s ReadWaitingData function) and transmits the packets the handlers have\ngenerated. Additionally, if more than 60 seconds passes between network inputs from the client\nor network outputs from the server variant, the CommLoop will send out a beacon packet\n(dwPktType = 4).\n```\nCommLoop routes packets to the appropriate command handler object by locating the\ndwPacketIdentifierCode within each of the registered command handlers that matches the\n\n```\nincoming packets dwPktType. When the appropriate command handler is found,\n```\nCommLoop passes the payload of portion of the packet to the command handler’s\nProcessPacket function. \nPCC_CMD\n\n```\nThe PCC_CMD object contains the remote shell functionality of the server variant along with the\nability to execute arbitrary programs. Derived from the PCC_BASEMOD class, the PCC_CMD\n\n|ID Class Name Module Description|Col2|Col3|\n|---|---|---|\n|0x81|PCC_CMD|Remote command shell|\n|0x82|PCC_PROXY|Network tunneling|\n|0x84|PCC_FILE|File management|\n|0xF0|n/a|Derusbi administrative [built-in module that does not count against the maximum of 8 modules per variant sample]|\n\n\n-----\n\nclass’s operations are focused largely in the ProcessPacket and ReadWaitingData\nfunctions. The PCC_CMD::ProcessPacket function works as a stub function that merely\npasses the packet’s payload data (pkt) data to PCC_CMD::ProcessPacketEx while ignoring\nthe dwPktSize parameter. The packet’s payload data is, in and of itself, another datagram with\na header and optional payload section. The payload of each PCC_CMD destined packet contains\nthe following header:\n```\nstruct PCCCMDPacketHeader\n{\n DWORD dwPacketSize;\n DWORD field_4; // purpose unknown, seemingly unused.\n DWORD dwCommandType;\n DWORD dwLastError;\n};\n\n```\nThe dwCommandType field specifies the specific PCC_CMD command that the client is\nrequesting the server variant perform. There are four commands that PCC_CMD supports:\n\n`dwCommandType` **Functionality**\n`0x04` Activate the remote shell\n`0x08` Execute the specified file\n`0x0C` Send input to remote shell\n`0x10` Terminate the remote shell\n\nFor each of the commands, any output from or acknowledgement of the commands comes in\nthe form of another packet consisting of a PacketHeader followed by a\n```\nPCCCMDPacketHeader and any optional payload data. The dwCommandType of the newly\n\n```\nconstructed packet matches the command’s original dwCommandType value (e.g. responses\nfrom 0x04 commands will reply with dwCommandType set to 0x04).\n```\nPCC_CMD::ProcessPacketEx will queue the response packets in an internal buffer.\n\n```\nThe PCC_CMD::ReadWaitingData member function is responsible for transmitting any of the\npreviously queued packets from PCC_CMD::ProcessPacketEx. If there are no queued\npackets, PCC_CMD::ReadWaitingData will perform a queue of the console output pipe for the\nremote shell process (if it is active); the function will also attempt to read the entirety of the\nwaiting data, which then becomes the payload of a PacketHeader/PCCCMDPacketHeader\nbased packet with the dwCommandType set to 0x0C. If the read is unsuccessful, the function\nreturns a PacketHeader/PCCCMDPacketHeader based packet with the dwCommandType set\nto 0x10 indicating an error and terminating the remote shell session.\n```\nPCC_FILE\n\n```\nThe PCC_FILE object provides a large range of file system administration functions.\n```\nPCC_FILE is derived from the PCC_BASEMOD class meaning that the processing of commands\n\n```\nshould be contained within the PCC_FILE::ProcessPacket member function with some\nadditional processing done in the PCC_FILE::ReadWaitingData member function. This is\nnot necessarily the case, however.\n\n|dwCommandType Functionality|Col2|\n|---|---|\n|0x04|Activate the remote shell|\n|0x08|Execute the specified file|\n|0x0C|Send input to remote shell|\n|0x10|Terminate the remote shell|\n\n\n-----\n\nThe PCC_FILE::ProcessPacket member function, much like PCC_CMD::ProcessPacket,\nis little more than a stub function that passes only a copy of the payload data (pkt) to\n```\nPCC_FILE::ProcessPacketEx. PCC_FILE::ProcessPacketEx performs no file\n\n```\nmanagement operations but instead adds any incoming command packets to a queue for\nprocessing by PCC_FILE::ReadWaitingData if the packet is not already within the queue\n(thus avoiding duplication of commands).\n\nThe PCC_FILE::ReadWaitingData member function is a stub function that calls\n```\nPCC_FILE::ProcessQueue and returns the resulting packet from the queue processing. This\n\n```\nmeans that file operations are surprisingly low priority, and potentially, high latency operations.\n\nEach packet that arrives within the packet queue of PCC_FILE contains a standard header\nfollowed by a (quasi-optional) payload data blob. The header for the PCC_FILE command\npackets takes the following form:\n```\nstruct PCCFilePacketHeader\n{\n DWORD dwTotalPayloadSize;\n DWORD dwCommandType;\n};\n\n```\nThe dwCommandType field specifies the specific PCC_FILE command that the client is\nrequesting the server variant to perform. PCC_FILE supports 17 (of which 15 are unique)\ncommands. While the general form within the Derusbi server variant communication model is to\nreturn a packet with the same dwCommandType as the original command, many of the\n```\nPCC_FILE commands return a status packet type (dwCommandType = 0x04).\n\n```\n`dwCommandType` **Functionality** **Response**\n```\n                                  dwCommandType\n\n#### 0x0C Purge PCC_FILE Commands from Queue (no response)\n\n```\n|dwCommandType Functionality Response dwCommandType|Col2|Col3|\n|---|---|---|\n|0x0C|Purge PCC_FILE Commands from Queue Based on dwCommandType|(no response)|\n|0x10|Enumerate Attached Drives|0x10|\n|0x14|Get File Attributes|0x14|\n|0x18|File Search|0x18|\n|0x1C|Rename File|0x04|\n|0x20|Delete File|0x04|\n|0x24|Create Directory|0x04|\n|0x28|Upload File to Client|0x28 and 0x04|\n|0x2C|Recursively Enumerate Directory|0x2C|\n|0x30|Download File from Client|0x04|\n|0x34|Copy File|0x04|\n|0x38|Move File|0x04|\n|0x3C|Duplicate File Timestamp|0x04|\n|0x40|Execute File|0x04|\n|0x44|Recursively Enumerate Directory|0x44|\n|0x48|Recursively Enumerate Directory|0x48|\n|0x4C|Enumerate All Drives and Files|0x4C|\n\n\n-----\n\nCommands 0x2C, 0x44, and 0x48 all appear to be the exact same base command with only\nslight variations in their response format. It is unclear why this particular command is included\nthree times in PCC_FILE.\n```\nPCC_PROXY\n\n```\nThe PCC_PROXY object provides the platform for a tunneling network traffic to and from the\nclient to a specific endpoint (or endpoints if multiple tunnels are activated by the client). Derived\non the PCC_BASEMOD class, the PCC_PROXY class performs very little network tunneling within\nthe CommLoop interactive PCC_PROXY::ProcessPacket and\n```\nPCC_PROXY::ReadWaitingData member functions. The PCC_PROXY::ProcessPacket\n\n```\nmember function queues incoming PCC_PROXY packets into a received queue while\n```\nPCC_PROXY::ReadWaitingData returns packets from a transmit queue, with the\n\n```\ndirectionality from the perspective of the server variant. The core of the PCC_PROXY’s network\ntunneling comes from a spawned processing thread (PCC_PROXY::MainThread) that is\ngenerated when the PCC_PROXY object is instantiated.\n\nThe PCC_PROXY::MainThread function consist an infinite loop that only terminates when the\n```\nPCC_PROXY::fShutdown flag is set. Otherwise, the loop will inspect another internal flag\n\n```\n(PCC_PROXY::fNetworkEnabled) to determine if the network tunneling is currently active. If\nthe PCC_PROXY::fNetworkEnabled flag is set to false, then tunneling is disabled but\ncommand processing continues.\n\nIt is possible to have more than one tunnel active at any given time. In order to firewall tunnels\nfrom each other over the backbone of the server variant’s command channel, each tunnel is\nassigned a specific channel identifier. This allows the client to specify which specific tunnel data\nis transmitted to as well as telling the client which tunnel is returning data. If the\n```\nPCC_PROXY::fNetworkEnabled flag is set to true, PRC_PROXY::MainThread will loop\n\n```\nthrough all active channels, perform a select on the socket connected to the endpoint and -- if\nthe select indicates that there is data waiting on a particular socket -- the data is read. A new\n```\nPCC_PROXY based packet is then generated and the packet is queued for delivery to the client. \n\n```\nAfter processing each of the channels for new data, PCC_PROXY::MainThread processes\nincoming command packets from the client (an operation usually handled by the\n```\nPCC_BASEMOD::ProcessPacket function). Packets belonging to the PCC_PROXY subsystem\n\n```\nhave a common header, much like the other PCC_BASEMOD derived classes. To this end, the\n```\nPCC_PROXY packets have the same packet header as the PCCFilePacketHeader packet\n\n```\nheader.\n\n\n-----\n\nThe PCC_PROXY supports five commands:\n\n`dwCommandType` **Functionality**\n`0x04` Connect to Specified Endpoint (Creates New Channel)\n`0x08` Send Data to Endpoint\n`0x0C` Terminate Channel\n`0x10` Enable Network Tunneling (PCC_PROXY::fNetworkEnabled set\n#### to true)\n`0x14` Disable Network Tunneling (PCC_PROXY::fNetworkEnabled set\n#### to false)\n\n## Administrative Commands\nThe administrative commands are built-in to the server variant and are not derived from the\n```\nPCC_BASEMOD class. Each of the administrative command packets contains the same header\n\n```\nstructure as the PCCFilePacketHeader structure followed by an optional payload data blob.\n\nThe administrative commands consist of the following five commands:\n\n`dwCommandType` **Functionality**\n`0x08` Terminate the current network connection between the client and the\nserver variant.\n`0x10` Run the Cleanup member function of each of the registered\n```\n          PCC_BASEMOD derived objects, effectively resetting the state of each of\n\n```\nthe modules.\n`0x14` Write infection ID to the registry and immediately terminate the server\nvariant.\n`0x18` Shutdown the server variant (set fShutdown to true)\n`0x1C` Drop a new DLL to %TEMP%\\tmp1.dat, load the DLL into memory and\ncall DllRegisterServer to install a new server variant binary on the\nvictim’s system.\n\n## Detection\nGiven the encrypted, and potentially compressed, nature of Derusbi server variant network\ntraffic, detecting the traffic on a network can be problematic using traditional IDS signatures.\nUsing a heuristic approach, it would be possible to detect the handshake of a possible Derusbi\nserver variant session by looking for the following pattern:\n\n|dwCommandType Functionality|Col2|\n|---|---|\n|0x04|Connect to Specified Endpoint (Creates New Channel)|\n|0x08|Send Data to Endpoint|\n|0x0C|Terminate Channel|\n|0x10|Enable Network Tunneling (PCC_PROXY::fNetworkEnabled set to true)|\n|0x14|Disable Network Tunneling (PCC_PROXY::fNetworkEnabled set to false)|\n\n|dwCommandType Functionality|Col2|\n|---|---|\n|0x08|Terminate the current network connection between the client and the server variant.|\n|0x10|Run the Cleanup member function of each of the registered PCC_BASEMOD derived objects, effectively resetting the state of each of the modules.|\n|0x14|Write infection ID to the registry and immediately terminate the server variant.|\n|0x18|Shutdown the server variant (set fShutdown to true)|\n|0x1C|Drop a new DLL to %TEMP%\\tmp1.dat, load the DLL into memory and call DllRegisterServer to install a new server variant binary on the victim’s system.|\n\n|Client Server|Col2|\n|---|---|\n|Exactly 64 bytes transmitted||\n||Exactly 64 bytes transmitted|\n|First 8 bytes taking the pattern of 0x28 0x00 0x00 0x00 0x02 0x00 0x00 0x00||\n\n\n-----\n\nDetecting Derusbi server variants on disk is possible using the following YARA signature:\n```\nrule Derusbi_Server \n{\n   strings:\n       $uuid = \"{93144EB0-8E3E-4591-B307-8EEBFE7DB28F}\" wide ascii\n       $infectionID1 = \"-%s-%03d\"\n       $infectionID2 = \"-%03d\"\n       $other = \"ZwLoadDriver\"\n   condition:\n       $uuid or ($infectionID1 and $infectionID2 and $other)\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/t3h83k7pfdyzoi3hrhfl7k5o33sk1fwk",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.10.14.Derusbi_Analysis/Derusbi_Server_Analysis-Final.pdf",
        "http://www.novetta.com/wp-content/uploads/2014/11/Derusbi.pdf"
    ],
    "report_names": [
        "Derusbi_Server_Analysis-Final",
        "Derusbi.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716502,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1414463475,
    "ts_modification_date": 1414463475,
    "files": {
        "pdf": "https://archive.orkl.eu/d246e3075bbd31f04b2a6efb53ad7d9e9faa0e96.pdf",
        "text": "https://archive.orkl.eu/d246e3075bbd31f04b2a6efb53ad7d9e9faa0e96.txt",
        "img": "https://archive.orkl.eu/d246e3075bbd31f04b2a6efb53ad7d9e9faa0e96.jpg"
    }
}