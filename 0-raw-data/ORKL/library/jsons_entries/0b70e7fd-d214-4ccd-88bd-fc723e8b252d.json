{
    "id": "0b70e7fd-d214-4ccd-88bd-fc723e8b252d",
    "created_at": "2023-01-12T15:00:20.938816Z",
    "updated_at": "2025-03-27T02:08:41.102642Z",
    "deleted_at": null,
    "sha1_hash": "efeabdccc06334a47b9cbb387060a5aa5553e482",
    "title": "2021-04-12 - Deep Analysis- New FormBook Variant Delivered in Phishing Campaign – Part I",
    "authors": "",
    "file_creation_date": "2022-05-29T10:46:44Z",
    "file_modification_date": "2022-05-29T10:46:44Z",
    "file_size": 272909,
    "plain_text": "# Deep Analysis: New FormBook Variant Delivered in Phishing Campaign – Part I\n\n**[fortinet.com/blog/threat-research/deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I](https://www.fortinet.com/blog/threat-research/deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I)**\n\nThreat Research\n\nBy [Xiaopeng Zhang | April 12, 2021](https://www.fortinet.com/blog/search?author=Xiaopeng+Zhang)\n\n**[FortiGuard Labs Threat Research Report](https://www.fortinet.com/fortiguard/labs.html?utm_source=blog&utm_medium=campaign&utm_campaign=FortiGuardLabs)**\n\nAffected platforms: Microsoft Windows\n\nImpacted parties:  Windows Users\n\nImpact:          Collect Sensitive Information from Victim’s Device.\nSeverity level:     Critical\n\n\nApril 12, 2021\n\n\n[FortiGuard Labs captured a phishing campaign that was sending a Microsoft PowerPoint document as an email attachment to spread the new](https://www.fortinet.com/resources/cyberglossary/phishing?utm_source=blog&utm_campaign=phishing)\nvariant of the FormBook malware. FormBook is a well-known commercial malware, so dubbed because it has been sold “as-a-service” on\nhacking forums since 2016. It is designed to steal personal information from victims' devices and manipulate their devices using control\ncommands from a C2 server. FormBook, which has been detected in the wild for over five years, is designed to steal personal information\nthrough the use of [keyloggers and form grabbers to collect victim input along with the data of some software, such as browsers, IM, Email](https://www.fortinet.com/resources/cyberglossary/what-is-keyloggers.html%20?utm_source=blog&utm_campaign=keylogger)\nclients, and FTP clients.\n\nI recently conducted in-depth research on the latest campaign we captured, starting with the phishing email and the attached PowerPoint\ndocument that delivers the malware. This is the first part of that analysis. In it, I will demonstrate all my findings from the research, including but\nnot limited to how the malicious VBA code is executed in the PowerPoint file; how the FormBook payload file is downloaded by the PowerPoint\nfile; as well as how the FormBook main file (module) is finally extracted from a .Net module. In part II, I will look at what the FormBook malware\ndoes once loaded, and in particular, the new functions and features in this latest variant.\n\n## Phishing Email and PowerPoint Document\n\nThe phishing email used to deliver the FormBook malware looks like a reply to a request for a purchase order. Of course, this is simply a\ncrafted fake message to the victim. Figure 1.1 shows the email content. It is designed to lead the victim to open the attached PowerPoint file to\nview the details of “brochures and prices” in a video.\n\nFigure 1.1 - The phishing email captured by FortiGuard Labs\n\nThe PowerPoint file is delivered with a “.pps” file extension, which tells PowerPoint to open it directly in “slide show” view (not in “edit” view,\nwhich is the default for other file extensions like “.ppt”) once the recipient double-clicks on the file.\n\n\n-----\n\ngu e s t e sc ee s ot o t e s de co te t o ce t beg s e t e ct s o g t e ouse a ou d t e s de s o o c c g o\nitems, the malicious VBA code is being executed in background. Through my analysis, it sets two actions (“Mouse Click” and “Mouse Over”) to\nrun the Macro function MRmgEG() once triggered. Figure 1.3 only shows the “Action Settings” for the “Mouse Over” event. These are the\nsame as the settings for the “Mouse Click” event.\n\nFigure 1.2 – Beginning of the slide show after double-clicking on the PowerPoint file\n\nFigure 1.3 - The Mouse Over action is set to execute the Macro MRmgEG()\n\nOnce MRmgRE() is called, it then calls several methods and finally runs a piece of PowerShell code by calling the function RPUJob() (which is\nan alias of API WinExec()), as displayed in Figure 1.4. I have deobfuscated the PowerShell command at the bottom of the Figure for you to\nclearly observe it.\n\nFigure 1.4 - Macro executing a PowerShell code\n\nThe method Invoke-RestMethod() requests a PowerShell code from “hxxps[:]//bit[.]ly/2NDvCoG”. “bit.ly” is a website that provides a URL\nshortening service. In this case, the short URL links to “hxxp[:]//kiibra[.]com/images/index.jpg”. “index.jpg” is not a real picture file, but a\nPowerShell file that will be executed by IEX().\n\nI manually downloaded the file “index.jpg” and my static analysis found that the PowerShell code would extract two files (“item1.gif” and\n“item2.png”) into the system’s temporary folder from two variables with base64 encoded data. Below is a key piece of the PowerShell code that\nI copied from “index.jpg”.\n\n[IO.FIlE]::WRiTeAlLBYtES(\"$Env:TMP\\item1.gif\",\n[SySTeM.ConveRT]::frOMbaSe64CHArARRay($SAKeLtXeLERX, 0,\n\n$SAKeLtXeLERX.LENgTH));\n\n[IO.FilE]::WrItEALLByTeS(\"$Env:TMP\\item2.png\",\n[SyStem.CONVErt]:: fROmbaSe64ChaRaRrAy($vVXFiQawOSBg, 0,\n$vVXFiQawOSBg.LENGthh));\n\ncMd.exe /C COPy /B '%TMP%\\item1.gif' + '%TMP%\\item2.png'\n'%TMP%\\item3.jpg';\n\ndel \"$Env:TMP\\item1.gif\";\n\ndeL \"$Env:TMP\\item2.png\";\n\nCmD.eXe /c '%TMP%\\item3.jpg'\n\nThese two variables, with huge amounts of base64 encoded data, are “$SAKeLtXeLERX” (that saves to “item1.gif”) and “$vVXFiQawOSBg”\n(that saves to “item2.png”). The two files are actually pieces of an executable file, which then are combined into a single file called “item3.jpg”\n(by executing the “Copy” command), which is eventually run by calling the command “cmd.exe /c %TMP%\\item3.jpg”. Figure 1.5 is a\nscreenshot of the files residing in my testing environment’s %TEMP% folder.\n\nFigure 1.5 - Generated files used to execute the PowerShell code\n\n## Initial Static Analysis on item3.jpg in Phishing Campaign\n\nI then dragged the file into a PE analysis tool, as shown in Figure 2.1 below. We can see that it is a 32-bit executable file that was developed in\nMicrosoft Visual C#.\n\nFigure 2.1 - “item3.jpg” in PE analysis tool\n\nUsing the view provided in the .Net analysis tool “dnSpy”, shown in Figure 2.2, I noticed that the code of “item3.jpg” is fully obfuscated,\nincluding classes, methods, properties, and code flow. All the names are totally randomly generated and meaningless so you cannot obtain\nany clues from them. In addition, an obfuscated code-flow can confuse the code order so you cannot easily know where the next code goes.\nAll of these techniques are a huge challenge for an analyst trying to comprehend the code and trace the code-flow. Since the module name is\n“Li7f”, I will refer to it using the module name in following content.\n\nFigure 2.2 - The obfuscated code of “item3.jpg” and its entry point function\n\n## Analyzing the “Li7f” Module in Debugger\n\nThe malware developers not only obfuscated the code, but also encrypted all constant strings. However, there is a special method that can be\nused for dynamically decrypting constant strings by their string ID from a large string array, just before the constant string is being used. Just\nas you can see in Figure 3.1, it decrypts two strings: “https://www.bing.com” and “https://www.google.com”. You may have noticed that the\n\n\n-----\n\na es o c ass a d et od a e bee e a ed to be ea g u o bette t ac g a d to bette u de sta d ts code e e a ed et od s\nnow “cls_x2C.decrypt_string_g4J()”, while its original name was “x2C.g4J()”. During my analysis, I renamed many other classes, methods, and\nvariables, which you will see in this blog, to make them easier to track.\n\nFigure 3.1 - Decrypting two Host strings\n\nTo confirm that the victim’s device is connecting to the internet, the “Li7f” module sends normal “Get” requests to the two hosts, as shown\nabove in Figure 3.1. It then continues its task only when it can receive responses from both of the two host servers.\n\nThere are twenty-three .Net resources in “item3.jpg” that are used to save encrypted data. “Li7f” retrieves the data of “d4R.Resources” into\nmemory, which is Dictionary data (key/value). To finish this, it creates a ResourceManager object with a resource name and\na [ResourceSet object (Dictionary object). It then obtains the value of the key \"LoginDataBase\", which is an encrypted PE file. Figure 3.2 shows](https://docs.microsoft.com/en-us/dotnet/api/system.resources.resourceset?view=net-5.0)\nall of the .Net resources of “item3.jpg” and the encrypted PE (value of key “LoginDataBase”) in the resource “d4R.Resources”.\n\nFigure 3.2 - .Net Resources and the encrypted PE in “d4R.Resources”\n\nFigure 3.3 - The decrypted value of the key “LoginDataBase”\n\nFigure 3.3 is the decrypted PE file in the memory from the key “LoginDataBase” of the resource “d4R.Resources”. The PE file is a .Net DLL\nmodule that is dynamically deployed by the “Li7f” module. I will refer to this .Net module as “zOAI” in this blog, according to its project name.\n\nThe “zOAI” module’s entry method is invoked in the “Li7f” module, which defines a delegate type “Fx7” and assigns it to link to the entry\nmethod “CaCl.aXt()“ of the “zOAI” module. So, calling a delegate method defined by “Fx7” type in the “Li7f” module is equivalent to calling\n“CaCl.aXt()“ in the “zOAI” module.\n\nAn “Fx7” type is defined in the class “cls_form_m3N” in the “Li7f” module as follows:\n\ninternal delegate void Fx7(); //It is similar to the function pointer in C and C++ language.\n\nIt is assigned by calling “obj = Delegate.CreateDelegate (A_0, A_1, A_2, A_3, A_4);”, where “A_0” is the type (“cls_form_m3N.Fx7”) of\ndelegate to create; “A_1” is a target class name(“zOAI!Cacl”) that develops the target method; “A_2” is the target method “aXt”.\n\nAfter that, the variable “obj” is linked to the method “zOAI!Cacl.aXt()”.\n\nAnd finally, “Li7f” invokes the “zOAI”’s entry method “zOAI!Cacl.aXt()” using the pseudo code “((cls_form_m3N.Fx7)(delegate)obj)();”.\n\n## Deep Dive into “zOAI” Module\n\nThe “zOAI” module is same as the “Li7f” module that is fully obfuscated. As you can see in Figure 4.1, the names of classes and methods are\nrandom strings, and the code-flow is also obfuscated.\n\nFigure 4.1 – The obfuscated “zOAI” module and entry method “aXt()”\n\nThe “zOAI” module retrieves the current call back frame by calling StackFrame Last<StackFrame>(). Through the last one (which is\n“Li7f!Zx4.m3N.Rt7()”—refer to Figure 2.2), “zOAI” obtains the image of the module “Li7f”. Furthermore, it proceeds to retrieve another .Net\nresource from “Li7f” (item3.jpg). It parses the TimeStamp value from the PE structure of item3.jpg to generate the name\n(“83130d5d1439.Resources”) of the .Net resource to read, which is shown in Figure 4.2. Looking back at Figure 3.2, you will find that\n“83130d5d1439.Resources” is the last of the .Net resources.\n\nFigure 4.2 - Generated resource name from the TimeStamp value\n\nThe data of this resource that is also encrypted contains a dictionary data structure with many key/value pairs. Figure 4.3, below, is the\ndecrypted and loaded dictionary.\n\nFigure 4.3 – The Dictionary data that is read from “83130d5d1439.Resources”\n\nIt contains many switches explaining what “aOZI” module is able to do. For example,\n\nHow to perform startup persist (%StartupPersist%)\nHow to show up a fake message to victim (%Message%)\nHow to do the anti-VM environment (%VM%) and anti-sandbox detection (%SB%)\nAnd so on\n\nAs shown in Figure 4.3, all of them above are set to false; hence, the “zOAI” module will bypass those operations and detections. The most\nsignificant data is %MainFile%, which is a decrypted PE file (file size 0x2d600). It is the payload file of this variant of FormBook, which I’ll talk\nabout later.\n\nIt then decrypts a constant string, \"AddInProcess32.exe\", with the index 2444184564U. This file belongs to the Microsoft® .NET Framework\nand is located in the .Net Framework installation folder. It then copies this file from\n\"C:\\Windows\\Microsoft NET\\Framework\\v4 0 30319\\AddInProcess32 exe\" (in my testing environment) to \"%Temp%\\AddInProcess32 exe\" by\n\n\n-----\n\nca g a po ted at e Copy e, de ed be o odu e O\n\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, EntryPoint = \"CopyFileEx\", SetLastError = true)]\n\n[return: MarshalAs(UnmanagedType.Bool)]\ninternal static extern bool FO18xSYnaRX8DJ59Xlc280GJqLA([MarshalAs(UnmanagedType.VBByRefStr)] ref string, [MarshalAs(UnmanagedType\nVeQ.MAN5S2ZmxZ35Z7m3YKy0VksroQA, IntPtr, ref int, VeQ.Qs6h1EUA15Rsz9R5qN5eapIAj63);\n\nThe last thing that the “zOAI” module does is to decrypt another .Net module from a local array variable and then deploys it in the memory as\nwell as invokes its entry method with parameters. Again, this module is fully obfuscated. Its name is “AMe8” and the entry method is\n“AMe8!eUI.C74()”.\n\nFigure 4.4 – Invoking the entry method of the “AMe8” module\n\nIt breaks in “Invoke()”, as shown in Figure 4.4, and is going to call method “AMe8!eUI.C74()” with parameters, which contains the full path of\nthe copied “AddInProcess32.exe” and a buffer address of the FormBook payload (the same data in %MainFile%, shown in Figure 4.3).\n\nLet’s move on to next section for more information about the module “AMe8”.\n\n## Using the “AMe8” Module to Run FormBook\n\nThe entry method “AMe8!eUI.C74()” parses the parameters passed from the “zOAI” module and it then runs the “AddInProcess32.exe” that\nhas copied into the %temp% folder. As I explained earlier, “AddInProcess32.exe\" is an official program of the Microsoft .Net Framework. Why\ndoes “AMe8” module run it? Actually, it is a puppet program, because the “AMe8” module will inject the FormBook payload into it and then\nperform malicious tasks on its behalf.\n\nTo implement this, it creates the process \"%Temp%\\AddInProcess32.exe\". This is a code segment of the “AMe8” module, shown in Figure 5.1,\nwhich calls an imported native API CreateProcessAsUser() with a CreationFlag “4U” that refers to CREATE_SUSPENDED.\n\nFigure 5.1 – The API CreateProcessAsUser() used to create a suspended process\n\nAfter calling this API, the “AddInProcess32.exe” process is created and entered into a suspended state before executing any instructions.\nNext, the “AMe8” module calls a group of imported native APIs, such as GetThreadContext(), ReadProcessMemory(), VirtualAllocEx(),\nWriteProcessMemory(), SetThreadContext(), and ResumeThread().\n\nIt also allocates memory space in the “AddInProcess32.exe” process for the FormBook payload by calling the API VirtualAllocEx() and\ninjecting the FormBook payload into it by calling the API WriteProcessMemory() and modifying the process’s registers using the API\nSetThreadContext(), so that it runs the FormBook payload’s entry point function when it resumes to run by calling the API ResumeThread().\nFigure 5.2 is a screenshot of the Process Tree, which shows the process of “AddInProcess32.exe” just after it is created.\n\nFigure 5.2 - Process tree view of the newly-created “AddInProcess32.exe”\n\n## Conclusion on Phishing Campaign\n\nThis is the first part of my analysis of the FormBook [phishing campaign. In this part, I have elaborated how the PowerPoint document runs its](https://www.fortinet.com/resources/cyberglossary/phishing?utm_source=blog&utm_campaign=phishing)\nVBA code to download PowerShell code, which extracts the .Net file “item3.jpg”.\n\nIn order to execute the main file (payload) of FormBook, it is transferred through three .Net modules, ”Li7f”, “zOAI”, and “AMe8”, and is finally\nexecuted by “AMe8”. I also explained the relationship between these modules and how they connect to each other. I also displayed the antianalysis technique they use – including the full obfuscation, which really takes a significant amount analyst time to defeat.\n\nWe know that the payload file of FormBook is injected into a newly-created “AddInProcess32.exe” process and is executed on its behalf to\nsecretly perform malicious tasks. In Part II of this blog, I will provide additional analysis to explain what malicious things it is going to do and\nhow, including what data it can steal from a victim’s device and how it controls the victim via control commands. Please stay tuned.\n\n## Fortinet Protections\n\nFortinet customers are already protected from this FormBook variant with FortiGuard’s Web Filtering and AntiVirus services, as follow:\n\nThe download URL launched from the PowerPoint sample is rated as \"Malicious Websites\" by the FortiGuard Web Filtering service.\n\nThe attached PowerPoint file is detected as “VBA/FormBook.C393!tr” and the “item3.jpg” file is detected as \"MSIL/FormBook.ZXL!tr\" and\nblocked by the FortiGuard AntiVirus service.\n\n[The FortiGuard AntiVirus service is supported by FortiGate,](https://www.fortinet.com/products/next-generation-firewall.html?utm_source=blog&utm_campaign=fortigate-main-page) [FortiMail, FortiClient, and](https://www.fortinet.com/products/email-security/fortimail.html?utm_source=blog&utm_campaign=2018-q2-fortimail-main-page) [FortiEDR. The Fortinet AntiVirus engine is a part of each](https://www.fortinet.com/products/endpoint-security/fortiedr.html?utm_source=blog&utm_campaign=fortiedr)\nof those solutions as well. As a result, customers who have these products with up-to-date protections are protected.\n\n[We also suggest our readers to go through the free NSE training --](https://training.fortinet.com/?utm_source=blog&utm_campaign=nse-institute) [NSE 1 – Information Security Awareness, which has a module on Internet](https://training.fortinet.com/local/staticpage/view.php?page=nse_1&utm_source=blog&utm_campaign=nse-1)\nthreats designed to help end users learn how to identify and protect themselves from phishing attacks.\n\n\n-----\n\n## IOCs:\n\n**URLs**\n\nhxxp[:]//kiibra[.]com/images/index[.]jpg\n\n**Sample SHA-256**\n\n[Video Drawing P.O.#4210020253.pps]\n\n82BE061B2BFE48EE3A9F76EE99CF6F3ED712C0C1393AD4A9F064CFC4D11CB53D\n\n[item3.jpg, module name “Li7f”]\n\nF45A363A86D38E5814D41908C0EA5A13F8A89AF2AFEA931472F9905B87FB2ADC\n\n_[Learn more about FortiGuard Labs threat research and the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n\n_Learn more about Fortinet’s_ _[free cybersecurity training initiative or about the Fortinet](https://www.fortinet.com/blog/business-and-technology/fortinet-offers-free-cybersecurity-training-courses?utm_source=blog&utm_campaign=free-cybersecurity-training-courses)_ _[NSE Training program,](https://training.fortinet.com/?utm_source=blog&utm_campaign=nse-institute)_ _[Security Academy program,](https://training.fortinet.com/local/staticpage/view.php?page=fnsa&utm_source=blog&utm_campaign=fnsa)_\n_[and Veterans program.](https://www.fortinet.com/corporate/careers/vets.html?utm_source=blog&utm_campaign=fortivet)_\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-12 - Deep Analysis- New FormBook Variant Delivered in Phishing Campaign – Part I.pdf"
    ],
    "report_names": [
        "2021-04-12 - Deep Analysis- New FormBook Variant Delivered in Phishing Campaign – Part I.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d8dff631-87b0-4320-8352-becff28dbcf1",
            "created_at": "2022-10-25T16:07:24.565038Z",
            "updated_at": "2025-03-27T02:02:10.282132Z",
            "deleted_at": null,
            "main_name": "ShinyHunters",
            "aliases": [],
            "source_name": "ETDA:ShinyHunters",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535620,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653821204,
    "ts_modification_date": 1653821204,
    "files": {
        "pdf": "https://archive.orkl.eu/efeabdccc06334a47b9cbb387060a5aa5553e482.pdf",
        "text": "https://archive.orkl.eu/efeabdccc06334a47b9cbb387060a5aa5553e482.txt",
        "img": "https://archive.orkl.eu/efeabdccc06334a47b9cbb387060a5aa5553e482.jpg"
    }
}