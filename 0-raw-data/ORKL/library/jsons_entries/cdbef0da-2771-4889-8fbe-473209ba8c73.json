{
    "id": "cdbef0da-2771-4889-8fbe-473209ba8c73",
    "created_at": "2023-01-12T15:06:50.737651Z",
    "updated_at": "2025-03-27T02:05:36.294102Z",
    "deleted_at": null,
    "sha1_hash": "3a32e295784ea052e01b7d0a8a95309c96e481c8",
    "title": "2021-04-03 - Hubnr Botnet",
    "authors": "",
    "file_creation_date": "2022-05-27T21:55:01Z",
    "file_modification_date": "2022-05-27T21:55:01Z",
    "file_size": 771047,
    "plain_text": "# Hubnr Botnet\n\n**[github.com/carbreal/Malware_Analysis/tree/master/Hubnr_botnet](https://github.com/carbreal/Malware_Analysis/tree/master/Hubnr_botnet)**\n\ncarbreal\n\nToday, april 3rd of 2021, I found the following sample in my honeypot:\n```\narm7: ELF 32-bit LSB executable, ARM, EABI4 version 1 (SYSV), statically linked, not\nstripped\nhash: fe7fb996b997877216d782a7adbcbe6a37bc585d459c6d0d452a346b078157c6\n\n```\nAt first sight, it seems like a Mirai variant but has some interesting stuff. First, it doesn't\nencode the strings with an XOR function. It has two functions that do the job: util_encrypt()\nand util_decrypt() and they just apply a 3 character rotation to the strings.\n\n\n-----\n\nIn the main function, we see the first util_decrypt() call. It decodes the variable proc_name,\nthat returns \"/dev/hubnr\".\n\nThen, it runs the two main functions: hakka_con() and parse_buf().\n\n_hakka_con() connects to the server and runs scanner_init(). In order to get the master IP, it_\ncalls again util_decrypt() with the variable bot_host. This sample connects to the IP:\n**194.113.107.243**\n\n\n-----\n\n_scanner_init() is the function that propagates itself. I don't fully understand the entire logic_\nbehind this huge function, but I'd say that it works like a state machine. It has a for loop that\niterates through a variable and a switch-case function that goes through each state.\n\n\n-----\n\nIt has a state that runs a telnet scan and performs a bruteforce with a few stored credentials:\n\n\n-----\n\n-----\n\n-----\n\n-----\n\nThen, if the login is successful, it runs some recon commands and depending on the output it\ngets the appropiate binary for the architecture.\n\nIt has a few ways of getting the binary into the victim's machine: with a wget, a tftp or echoing\nit into the machine.\n\nBasically, this are the commands used in the different states:\n\nIt has 5 different droppers embedded targeting 5 different architectures. It has a payloads\nvariable that points to the memory direction of each dropper and it's used in the\n_get_retrieve_binary() function inside the state._\n\n\n-----\n\nThe dropper is a very small binary that only retrieves the sample from the master.\n\n\n-----\n\nThe other main function is parse_buf(). This one gets the command from the master. At the\nmoment, it has 4 different options. A PING option, that just updates the master with the alive\nbots. \"killproc\" that kills the process. And two different attack capabilities: \"udpflood\" and\n**\"tcpflood\".**\n\n\n-----\n\nIt's very interesting that it has also a http_send()+http_attack() function with 5 different useragent in memory and the HTTP request is also stored. It's used in the http_attack() function\nand it uses 4 different variables that are empty at the moment. I asume that when the new\n\n\n-----\n\nfunctionality is implemented, the master will be able to select different payloads but it s not\npossible yet.\n\n\n-----\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-03 - Hubnr Botnet.pdf"
    ],
    "report_names": [
        "2021-04-03 - Hubnr Botnet.pdf"
    ],
    "threat_actors": [
        {
            "id": "ea34919f-9093-4e34-b9de-a37ab9b4d5c4",
            "created_at": "2022-10-25T16:07:24.35727Z",
            "updated_at": "2025-03-27T02:02:10.188555Z",
            "deleted_at": null,
            "main_name": "UNC215",
            "aliases": [],
            "source_name": "ETDA:UNC215",
            "tools": [
                "AdFind",
                "CHINACHOPPER",
                "China Chopper",
                "FOCUSFJORD",
                "HighShell",
                "HyperBro",
                "HyperSSL",
                "HyperShell",
                "Mimikatz",
                "NBTscan",
                "ProcDump",
                "PsExec",
                "SEASHARPEE",
                "SinoChopper",
                "SysUpdate",
                "TwoFace",
                "WHEATSCAN",
                "WinRAR",
                "certutil",
                "certutil.exe",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536010,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653688501,
    "ts_modification_date": 1653688501,
    "files": {
        "pdf": "https://archive.orkl.eu/3a32e295784ea052e01b7d0a8a95309c96e481c8.pdf",
        "text": "https://archive.orkl.eu/3a32e295784ea052e01b7d0a8a95309c96e481c8.txt",
        "img": "https://archive.orkl.eu/3a32e295784ea052e01b7d0a8a95309c96e481c8.jpg"
    }
}