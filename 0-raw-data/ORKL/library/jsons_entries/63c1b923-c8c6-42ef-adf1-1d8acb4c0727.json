{
    "id": "63c1b923-c8c6-42ef-adf1-1d8acb4c0727",
    "created_at": "2022-10-25T16:48:20.349148Z",
    "updated_at": "2025-03-27T02:16:59.284432Z",
    "deleted_at": null,
    "sha1_hash": "116309e7121bc8b0e66e4166c06f7b818e1d3629",
    "title": "Threat Spotlight: Group 72, Opening The Zxshell",
    "authors": "Cisco",
    "file_creation_date": "2014-10-29T19:22:53Z",
    "file_modification_date": "2014-10-29T19:22:53Z",
    "file_size": 1059552,
    "plain_text": "_[This post was authored by Andrea Allievi, Douglas Goddard, Shaun Hurley, and Alain Zidouemba.](http://blogs.cisco.com/author/AndreaAllievi)_\n\n[Recently, there was a blog post on the takedown of a botnet used by threat actor group known as Group 72 and their](http://blogs.cisco.com/talos/threat-spotlight-group-72/)\n\ninvolvement in Operation SMN. This group is sophisticated, well funded, and exclusively targets high profile organizations\n\nwith high value intellectual property in the manufacturing, industrial, aerospace, defense, and media sector. The primary\n\nattack vectors are watering-hole, spear phishing, and other web-based attacks.\n\nFrequently, a remote administration tool (RAT) is used to maintain persistence within a victim’s organization. These tools\n\nare used to further compromise the organization by attacking other hosts inside the targets network.\n\nZxShell (aka Sensocode) is a Remote Administration Tool (RAT) used by Group 72 to conduct cyber-espionage operations.\n\nOnce the RAT is installed on the host it will be used to administer the client, exfiltrate data, or leverage the client as a pivot to\n\nattack an organization’s internal infrastructure. Here is a short list of the types of tools included with ZxShell:\n\nKeylogger (used to capture passwords and other interesting data)\n\nCommand line shell for remote administration\n\nRemote desktop\n\nVarious network attack tools used to fingerprint and compromise other hosts on the network\n\nLocal user account creation tools\n\nFor a complete list of tools please see the MainConnectionIo section.\n\nThe following paper is a technical analysis on the functionality of ZxShell. The analysts involved were able to identify\n\ncommand and control (C2) servers, dropper and installation methods, means of persistence, and identify the attack tools that\n\nare core to the RAT’s purpose. In addition, the researchers used their analysis to provide detection coverage for Snort,\n\nFireamp, and ClamAV.\n\n## Table of Contents\n\n1. Background\n\n2. Distribution and Delivery\n\n3. Analysis of the main ZxShell module\n\nDllMain\n\nInstall\n\nServiceMain\n\nShellMain\n\nShellMainThread\n\nGetIpListAndConnect\n\nMainConnectionIo\n\nUninstall\n\nZxFunction001\n\nZxFunction002\n\n4. Command and Control server\n\n5 Malware Package\n\n\n-----\n\n8. Conclusion\n\n9. Protecting Users From These Threats\n\n10. Appendix A: Snort rules\n\n11. Appendix B: ClamAV signatures\n\n12. Appendix C: List of Memory Offsets for Some ZxShell Functions\n\n13. Appendix D: Other Collateral\n\n## Background\n\nZxShell has been around since 2004. There are a lot of versions available in the underground market. We have analyzed the\n\nmost common version of ZxShell, version 3.10. There are newer versions, up to version 3.39 as of October 2014.\n\n## Distribution and Delivery\n\nAn individual who goes by the name LZX in some online forums is believed to be the original author of ZxShell. Since ZxShell\n\nhas been around since at least 2004, numerous people have purchased or obtained the tools necessary to set up ZxShell\n\ncommand and control servers (C&C) and generate the malware that is placed on the victim’s network. ZxShell has been\n\nobserved to be distributed through phishing attacks, dropped by exploits that leverage vulnerabilities such as CVE-2011\n[2462, CVE-2013-3163, and CVE-2014-0322.](http://tools.cisco.com/security/center/viewAlert.x?alertId=29886)\n\n## Analysis of the Main ZxShell Module\n\nTo illustrate the functionality of main ZxShell module, Let’s take a look at the following sample:\n\nMD5: e3878d541d17b156b7ca447eeb49d96a\n\nSHA256: 1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26c\n\nIt exports the following functions, which are examined in greater detail below:\n\nDllMain\n\nInstall\n\nUnInstall\n\nServiceMain\n\nShellMain\n\nShellMainThread\n\nzxFunction001\n\nzxFunction002\n\n## DllMain\n\nDllMain performs the initialization of ZxShell. It allocates a buffer of 0x2800 bytes and copies the code for the\n\nZxGetLibAndProcAddr function. To copy memory, the memcpy function is invoked. It is not directly used from msvcrt.dll but\n\nis instead copied to another memory chunk before being called. Finally, the trojan Import Address Table (IAT) is resolved\n\nand the file path of the process that hosts the dll is resolved and saved in a global variable.\n\n\n-----\n\nZxShell.dll is injected in a shared SVCHOST process. The Svchost group registry key\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost is opened and the netsvc group value data is queried\n\nto generate a name for the service.\n\nBefore the malware can be installed a unique name must to be generated for the service. The malware accomplishes this\n\nthrough querying the netsvc group value data located in the svchost group registry key which is\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost.\n\nAt startup, Svchost.exe checks the services part of the registry and constructs a list of services to load. Each Svchost session\n\ncan contain multiple shared services that are organized in groups. Therefore, separate services can run, depending on how\n\nand where Svchost.exe is started.\n\nImage 1. Svchost Groups registry key\n\nSvchost.exe groups are identified in the above registry key. Each value under this key represents a separate Svchost group\n\nand appears as a separate instance when you are viewing active processes. Each value is a REG_MULTI_SZ value and\n\ncontains the services that run under that Svchost group. Each Svchost group can contain one or more service names that are\n\nextracted from the following registry key, whose Parameters key contains a ServiceDLL value:\n\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Service\n\nOn a Windows machine, the netsvc group contains names of both existing and non-existing services. ZxShell exploits this fact\n\nby cycling between each of the names, verifying the existence of the real service. The service’s existence is verified with the\n\nServiceExists function, which attempts to open the relative registry sub-key in HKLM\\SYSTEM\\CurrentControlSet\\Services.\n\nThe first service name that is not installed on the system becomes the ZxShell service name.\n\nA new service is then created using the service parser function ProcessScCommand. ZxShell implemented its own version of\n\nthe Windows SC command. There are minor differences between the ZxShell implementation of this command and the\n\noriginal Windows one, but they are irrelevant for the purpose of the analysis The command used to install the service is:\n\nsc create <service name> <service name> “%SystemRoot%\\System32\\svchost.exe -k netsvcs”\n\nwhere <service name> is the chosen infected service name.\n\n\n-----\n\nImage 2. “SC” command used to create the target service,and parsed by “ProcessScCommand” routine\n\nThe installed service registry key is opened and the 2 values under its Parameter subkey are created. These 2 values,\n\n_ServiceDll and ServiceDllUnloadOnStop are needed for services that run in a shared process._\n\nBefore the service is started ChangeServiceConfig is called to modify the service type to shared and interactive. If the service\n\nfails to start then a random service name formatted as netsvc_xxxxxxxx, where xxxxxxxx represent an 8-digit random hex\n\nvalue, is added to the netsvc group and the entire function is repeated.\n\n## ServiceMain\n\nThis function is the entry point of the service. It registers the service using the RegisterServiceCtrlHandler Windows API\n\nfunction. The ZxShell service handler routine is only a stub: it responds to each service request code, doing nothing, and\n\nfinally exits. It sets the service status to RUNNING and finally calls the ShellMain function of ZxShell.\n\n## ShellMain\n\nThe ShellMain function is a stub that relocates the DLL to another buffer and spawns a thread that starts from\n\n_ShellMainThreadInt at offset +0xC0CD. The ShellMainThreadInt function gets the HeapDestroy Windows API address and_\n\nreplaces the first 3 bytes with the RET 4 opcode. Subsequently, it calls the FreeLibrary function to free its own DLL buffer\n\nlocated at its original address. Because of this, the allocated heaps will not be freed. It re-copies the DLL from the new buffer\n\nto the original one using the memcpy function. Finally, it spawns the main thread that starts at the original location of\n\n_ShellMainThread procedure, and terminates. At this point, the ZxShell library is no longer linked in the module list of the_\n\nhost process. This is important because if any system tool tries to open the host process it will never display the ZxShell DLL.\n\n## ShellMainThread\n\nThis thread implements the main code, responsible for the entire botnet DLL. First, it checks if the DLL is executed as a\n\nservice. If so, it spawns the service watchdog thread. The watchdog thread checks the registry path of the ZxShell service\n\nevery 2 seconds, to verify that it hasn’t been modified. If a user or an application modifies the ZxShell service registry key, the\n\ncode restores the original infected service key and values.\n\n\n-----\n\nImage 3. The watchdog thread of ZxShell service\n\nThe buffer containing the ZxShell Dll in the new location is freed using the VirtualFree API function. A handle to the DLL file\n\nis taken in order to make its deletion more difficult. The ZxShell mutex is created named @_ZXSHELL_@.\n\nZxShell plugins are parsed and loaded with the AnalyseAndLoadPlugins function. The plugin registry key\n\n_HKLM\\SYSTEM\\CurrentControlSet\\Control\\zxplug is opened and each value is queried. The registry value contains the_\n\nplugin file name. The target file is loaded using the LoadLibrary API function, and the address of the exported function\n\n_zxMain is obtained with GetProcAddress._\n\nIf the target filename is incorrect or invalid the plugin file is deleted and the registry value is erased. That is performed by the\n\nfunction DeleteAndLogPlugin. Otherwise, the plugin is added to an internal list. Here is the data structure used to keep track\n\nof the plugins:\n\ntypedef struct _ZX_PLUGINS_STRUCT {\n\nLPSTR lpStrRegKey;    // + 0x00 - ZxShell Plugins registry key string\n\n// (like 'SYSTEM\\CurrentControlSet\\Control\\zxplug')\n\nDWORD dwUnknown2;    // + 0x04 - Unknown DWORD value\n\nLPVOID lp138hBuff;    // + 0x08 - Plugins list\n\nDWORD dwZero;      // + 0x0C - Always zero\n\nHANDLE hReg; // + 0x10 - Handle to plugin registry key\n\n\n-----\n\nThe thread KeyloggerThread is spawned and is responsible for doing keylogging on the target workstation. We will take a\n\nlook at the keylogger later on. Finally the main network communication function GetIpListAndConnect is called.\n\n## GetIpListAndConnect\n\nThis function is at the core of the RAT’s network communication. It starts by initializing a random number generator and\n\nreading 100 bytes inside the ZxShell Dll at a hardcoded location. These bytes are XOR encrypted with the byte-key 0x85 and\n\ncontains a list of remote hosts where to connect. The data is decrypted, the remote host list is parsed and verified using the\n\n_BuildTargetIpListStruct function. There are 3 types of lists recognized by ZxShell: plain ip addresses, HTTP and FTP_\n\naddresses.\n\nIf the list does not contain any item, or if the verification has failed, the ZxShell sample tries to connect to a hardcoded host\n\nwith the goal of retrieving a new updated list.\n\nOtherwise, ZxShell tries to connect to the first item of the list. If ZxShell successfully connects to the remote host, the\n\nfunction DoHandshake is called. This function implements the initial handshake which consists of exchanging 16 bytes,\n\n0x00001985 and 0x00000425, with the server. The function GetLocalPcDescrStr is used to compose a large string that\n\ncontains system information of the target workstation. That information is the following:\n\nlocal hostname\n\norganization\n\nowner\n\noperating system details\n\nCPU speed\n\ntotal physical memory\n\nThe string is sent to the remote host and the response is checked to see if the first byte of the response is 0xF4, an arbitrary\n\nbyte. If it is, the botnet connection I/O procedure is called through the MainConnectionIo function.\n\nImage 4. The GetLocalPcDescrStr and DoHandshake functions called beforestarting the command processing\n\nOtherwise the ZxShell code closes the socket used and sleeps for 30 seconds It will then retry the connection with the next\n\n\n-----\n\nIt is noteworthy that this function includes the code to set the ZxShell node as a server: if one of the hardcoded boolean value\n\nis set to 1, a listening socket is created. The code waits for an incoming connection. When the connection is established a new\n\nthread is spawned that starts with the MainConnectionIo function.\n\n## MainConnectionIo\n\nThe MainConnectionIo function checks if the Windows Firewall is enabled, sets the Tcp Keep Alive value and Non-blocking\n\nmode connection options and receives data from the remote host through the ReceiveCommandData function. If the\n\ncommunication fails, ZxShell disables the firewall by modifying the registry key:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\n\nThen the connection is retried. The received command is then processed by the ZxShell function with the ProcessCommand\n\nfunction.\n\nThe command processing function starts by substituting the main module name and path in the hosting process PEB, with\n\nthe one of the default internet browser. The path of the main browser of the workstation is obtained by reading the registry\n\nvalue:\n\nHKLM\\SOFTWARE\\Classes\\HTTP\\shell\\open\\command\n\nImage 5. Our test workstation use Windows Internet Explorer as default browser\n\nThis trick renders identification by firewall more cumbersome. A host firewall will recognize the outgoing connection as\n\noriginated by the browser instead of the ZxShell service host process. The browser process always performs outgoing\n\nconnections and the firewall shouldn’t block them.\n\nThe command processing is straightforward. Here is the list of common commands:\n\nCOMMAND MEANING\n\nHelp / ? Get help\n\nExit / Quit Exit and shut down the botnet client\n\nSysInfo Get target System information\n\nSYNFlood Perform a SYN attack on a host\n\nPs Process service Unix command implementation\n\nCl E t Cl S t E t l\n\n|COMMAND|MEANING|\n|---|---|\n|Help / ?|Get help|\n|Exit / Quit|Exit and shut down the botnet client|\n|SysInfo|Get target System information|\n|SYNFlood|Perform a SYN attack on a host|\n|Ps|Process service Unix command implementation|\n\n\n-----\n\n|FindDialPass|List all the dial-up accounts and passwords|\n|---|---|\n|User|Account Management System|\n|TransFile|Transfer file in or from remote host|\n|Execute|Run a program in the remote host|\n|SC|Service control command, implemented as the Windows one|\n|CA|Clone user account|\n|RunAs|Create new process as another User or Process context.|\n|TermSvc|Terminal service configuration (working on Win Xp/2003)|\n|GetCMD|Remote Shell|\n|Shutdown|Logout, shutdown or restart the target system|\n|ZXARPS|Spoofing, redirection, packet capture|\n|ZXNC|Run ZXNC v1.1 -- a simple telnet client|\n|ZXHttpProxy|Run a HTTP proxy server on the workstation|\n|ZXSockProxy|Run a Sock 4 & 5 Proxy server|\n|ZXHttpServer|Run a custom HTTP server|\n|PortScan|Run TCP Port MultiScanner v1.0|\n|KeyLog|Capture or record the remote computer’s keystrokes. The implementation is a userland keylogger that polls the keymap with each keystroke.|\n|LoadDll|Load a DLL into the specified process|\n|End|Terminate ZxShell DLL|\n|Uninstall|Uninstall and terminate ZxShell bot DLL|\n|ShareShell|Share a shell to other|\n|CloseFW|Switch off Windows Firewall|\n|FileMG|File Manager|\n|winvnc|Remote Desktop|\n|rPortMap|Port Forwarding|\n|capsrv|Video Device Spying|\n|zxplug|Add and load a ZxShell custom plugin|\n\n\nThis set of functionality allows the operator complete control of a system. Being able to transfer and execute files on the\n\ninfected system means the attacker can run any code they please. Further, the keylogging and remote desktop functionality\n\nallows the operator to spy on the infected machine, observing all keystrokes and viewing all user actions.\n\n## Uninstall\n\nUnloads ZxShell and deletes all of the active components. This simply deletes the ZxShell service key from the Windows\n\nregistry (using SHDeleteKey Api) and all of the subkeys. Finally, it marks ZxShell main Dll for deletion with the MoveFileEx\n\nWindows API.\n\n## ZxFunction001\n\nThis function is the supporting functionality for WinVNC. To allow the VNC session to connect, the current network socket\n\n[WSAProtcol_Info structure is written to a named pipe prior to calling zxFunction001. Once the named pipe has been created,](http://msdn.microsoft.com/en-us/library/windows/desktop/ms741675%28v=vs.85%29.aspx)\n\nCreateProcessAsUserA is called with the following as the CommandLine parameter :\n\n<systemroot>\\\\rundll32 exe <zxshell dll name> zxFunction001 <name of NamedPipe>\n\n\n-----\n\n## ZxFunction002\n\nThis function will either bind the calling process to a port or has the calling process connect to a remote host. The function is\n\ncalled in the following manner:\n\n<systemroot>\\\\rundll32.exe <zxshell dll name>,zxFunction002 <name of NamedPipe>\n\nThe functionality (connect or bind) depends on the data contained within the named pipe. Unlike zxFunction001, this is not\n\nused by any of the RAT commands in the zxshell.dll.\n\n## Kernel Device Driver LoveUSD\n\nApart from user-mode ZxShell droppers mentioned earlier, there is a file (SHA256:\n\n1e200d0d3de360d9c32e30d4c98f07e100f6260a86a817943a8fb06995c15335) that installs a kernel device driver called\n\n_loveusd.sys. The architecture of this dropper is different from the others: it starts extracting the main driver from itself. It_\n\nadds the SeLoadDriver privilege to its access token and proceeds to install the driver as a fake disk filter driver. ZxShell opens\n\nthe registry key that describes the disk class drivers:\n\nSYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E967-E325-11CE-BFC1-08002BE10318}\n\nIt then adds the “Loveusd.sys” extracted driver name to the upper filter list. In our analysed sample the “Loveusd.sys” driver\n\nis installed with the name “USBHPMS”. Finally the driver is started using the ZwLoadDriver native API.\n\nThe ZxShell driver starts by acquiring some kernel information and then hooking “ObReferenceObjectByHandle” API. Finally\n\nit spawns 2 system threads.\n\nThe first thread is the “communication” thread. ZxShell employs a strange method for communication: it hooks the\n\nNtWriteFile API and recognizes 5 different special handle values as commands:\n\n0x111111111 -- Hide “Loveusd” driver from the system kernel driver list\n\n0x22222222 -- Securely delete an in-use or no-access target file-name\n\n0x44444444 -- Unhook the ZwWriteFile API and hook KiFastCallEntry\n\n0x55555555 -- Remove the ZxShell Image Load Notify routine\n\n0x88888888 -- Set a special value called “type” in Windows registry key\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DriverMain\n\nThe second Loveusd system thread does a lot of things. Its principal duties are to create the ZxShell main DLL in\n\n“c:\\Windows\\System32\\commhlp32.dll” and to install the Kernel “Load Image Notify routine”. The code then tries to kill\n\neach process and service that belongs to the following list of AV products:\n\nSymantec Firewall\n\nNorton\n\nESET\n\nMcAfee\n\nAvast\n\n\n-----\n\nMalwarebytes\n\nNext, the ZxShell Load-Image Notify function prevents the AV processes from restarting.\n\nThe installation procedure continues in the user-mode dropper. The ZxShell service is installed as usual, and the in-execution\n\ndropper is deleted permanently using the special handle value 0x22222222 for the WriteFile API call. This handle value is\n\ninvalid: all the windows kernel handle values are by design a multiple of 4. The ZxShell hook code knows that and intercept\n\nit.\n\nObReferenceObjectByHandle is a Kernel routine designed to validate a target object and return the pointer to its object body\n\n(and even its handle information), starting from the object handle (even the user-mode one). The hook installed by ZxShell\n\nimplements one of its filtering routine. It filters each attempt to open the ZxShell protected driver or the main DLL, returning\n\na reference to the “netstat.exe” file. The protection is enabled to all processes except for ones in the following list:\n\nSvchost.exe, Lsass.exe, Winlogon.exe, Services.exe, Csrss.exe, ctfmon.exe, Rundll32.exe, mpnotify.exe, update.exe.\n\nIf the type of the object that the system is trying to validate is a process, the hook code rewrites again the configuration data\n\nof the ZxShell service in the windows registry.\n\nImage 6. Our test Windows XP workstation trying to open the sys file of ZxShell LOVEUSD driver\n\nThe last type of Kernel modification that ZxShell rootkit performs is the system call dispatcher (KiFastCallEntry) hook. In\n\nthis manner, ZxShell is able to completely hide itself, intercepting the following Kernel API calls: ZwAllocateVirtualMemory,\n\n_ZwOpenEvent, ZwQueryDirectoryFile, ZwWriteFile, ZwEnumerateKey, and ZwDeviceIoControlFile._\n\n## Command and Control Server\n\nSample (SHA256: 1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26c) is configured to act as a server.\n\nThe symbol “g_bCreateListenSck” is set to 1. This means that, as seen above, the ZxShell Dll is started in listening mode. It\n\n\n-----\n\n7 ( p ) ( g )\n\n## Malware Package\n\nWe used the ZxShell package for version 3.10 (SHA256:\n\n1622460afbc8a255141256cb77af61c670ec21291df8fe0989c37852b59422b4).The convenient thing about this is that the CNC\n\npanel worked with any version, 3.10 and above. The buttons are all in Chinese, with the help of Google Translate and keen\n\ndetective skills (read: button clicking), we’ve deciphered the functionality.\n\nWhen you start the controller, you need to set the port you want to listen on and if you’ve set a password, add it here.\n\nOnce an infected machine connects, you see its information displayed in a selection box at the top. There are some built in\n\nfunctions on the side for the more common features. These include remote desktop, webcam spying, remote shell, and file\n\nmanagement. You can also select a host and type help for a full list of commands.\n\n\n-----\n\nI have the same machine infected with two different version of ZxShell. Sending the help command for each, you can see the\n\nextra features added between version 3.1 and 3.2.\n\nKeylogging, ZXARPS (IP and URL spoofing), and SYNFlood are some of the interesting features added to version 3.2.\n\n\n-----\n\nWe wrote a script to extract version info from the binaries we have.\n\n3.100 : 914\n\n3.200 : 152\n\n3.210 : 118\n\n3.220 : 14\n\n3.390 : 3\n\nIn versions 3.1 -- 3.21, the configuration info is xor encoded with 0x85. This configuration info can be changed with a tool\n\nincluded in the ZxShell package.\n\nIn versions 3.22 and 3.39 the routine changes. The new xor encoding byte is 0x5B. The data is stored in the last 0x100 bytes\n\nof the file. The first 8 bytes of data are static. Then there is the dll install name, the domain, and the port.\n\n## Extracted URL Analysis\n\nKnowing the obfuscation routines for this data we wrote a script to extract the URLs / IPs and ports stored.\n\nThe most common ports used are, 80, 1985, 1986, and 443. 1985 is the default port for the malware, 1986 is the lazy variation\n\nof that port. Port 80 and 443 are the default ports for HTTP and HTTPS traffic. The next most common is port 53. This is\n\nused in some of the newer 3.22 and 3.39 samples. After that, the count for each port starts declining sharply. The choices are\n\ninteresting though, many correspond to what looks like the birth year of the controller (ie. years in the late 1980s and early\n\n1990s), and others seem to match what year the malware was launched in (ie. in the 2000s, relatively close to the current\n\nyear).\n\nSince this malware dates back to around 2004, there are many samples containing CNC URLs from the 3322.org page. This\n\npage used to offer no-ip type hosting and was widely used by malware authors. So much so that Microsoft did a takedown in\n\n2012. A similar service, vicp.net, is also seen in many of the domains.\n\nIn the malware, if a domain is configured, it will retrieve domain.tld/myip.txt. This file contains a list of IP addresses for the\n\ninfected machine to connect back to. Otherwise, if an IP address is configured, it will connect directly to that IP address.\n\n\n-----\n\nWe have written a simple C++ ZxShell Server that implements the communication and the handshake for the version 3.10\n\nand 3.20 of the ZxShell DLL. The implementation is quite simple: After the handshake, 2 threads that deal with data transfer\n\nare spawned. Here we have some screenshots that show the Server and the ZxShell Keylogger in action:\n\nOur server has accepted a connection from a remote host\n\nThe ZxShell keylogger has captured 2 user passwords(gmail.com and amazon.com)\n\nThe last image shows a very interesting feature of the ZxShell keylogger: once installed and activated, the keylogger is able to\n\ncatch each password that the user inserts in the login box of each website (like Google, Amazon and so on…). This makes the\n\nkeylogger a perfect weapons for the attackers. They will be able to steal and resell in the underground market the sensitive\n\ndata of each victim.\n\n## Conclusion\n\nAdvanced persistent threats will remain a problem for companies and organizations of all sizes, especially those with high\n\nfinancial or intellectual property value. Group 72’s involvement in Operation SMN is another example of what sort of\n\ndamage that can be done if organizations are not diligent in their efforts to secure their networks. ZxShell is one sample\n\namongst several tools that Group 72 used within their campaign.\n\nZxShell is a sophisticated tool employed by Group 72 that contains all kinds of functionality. Its detection and removal can\n\nbe difficult due to the various techniques used to conceal its presence, such as disabling the host anti-virus, masking its\n\n\n-----\n\nRemote Administration Tool (RAT), allowing the threat actor to have continuous backdoor access on to the compromised\n\nmachine.\n\nAs our analysis demonstrates, ZxShell is an effective tool that can be ultimately used to steal user credentials and other highly\n\nvaluable information. The threat posed by ZxShell to organizations is one that cannot be ignored. Organizations with high\n\nfinancial or intellectual property value should take the time to ensure their security requirements are met and that\n\nemployee’s are educated about the security threats their organizations face.\n\n[For additional information, please see our blog post.](http://blogs.cisco.com/talos/threat-spotlight-group-72/)\n\n## Protecting Users from These Threats\n\n[Advanced Malware Protection (AMP) is ideally suited to detect the sophisticated malware](http://www.cisco.com/c/en/us/support/security/amp-firepower-software-license/tsd-products-support-series-home.html)\n\nused by this threat actor.\n\n[CWS or WSA web scanning prevents access to malicious websites, including watering hole](http://www.cisco.com/c/en/us/products/security/cloud-web-security/index.html)\n\nattacks, and detects malware used in these attacks.\n\n[The Network Security protection of IPS and NGFW have up-to-date signatures to detect](http://www.cisco.com/c/en/us/products/security/intrusion-prevention-system-ips/index.html)\n\nmalicious network activity by threat actors.\n\n[ESA can block spear phishing emails sent by threat actors as part of their campaign.](http://www.cisco.com/c/en/us/products/security/email-security-appliance/index.html)\n\n## Appendix A: Snort Rules\n\nInitial connection from the infected computer’s perspective -- after it connects to the controller \nRECV: 85190000250400000000404000000000\n\nSEND: 86190000040100006666464000000000\n\nRECV: 4edf9340780100000000000000000000\n\nSEND: 00000000000000000000000000000000\n\nThe rules are on the first 8 bytes of the first two packets. They are hard coded in the binaries. The rest of the bytes are\n\nvariable (for example, 66664640 is a floating point version number of ZxShell).\n\nSnort rules:\n\nsid:32180\n\nsid:32181\n\n[These rules have been released in our community ruleset and can be downloaded and used directly, or via pulledpork from](https://www.snort.org/downloads)\n\nSnort.org\n\n## Appendix B: ClamAV Signatures\n\nWin.Trojan.ZxShell-11\n\nWin.Trojan.ZxShell-12\n\n\n-----\n\nWin.Trojan.ZxShell-15\n\nWin.Trojan.ZxShell-16\n\nWin.Trojan.ZxShell-17\n\nWin.Trojan.ZxShell-18\n\nWin.Trojan.ZxShell-19\n\nWin.Trojan.ZxShell-20\n\nWin.Trojan.ZxShell-21\n\nWin.Trojan.ZxShell-22\n\nWin.Trojan.ZxShell-23\n\nWin.Trojan.ZxShell-24\n\nWin.Trojan.ZxShell-25\n\nWin.Trojan.ZxShell-26\n\nThese signatures are available within the ClamAV database. Please run freshclam to ensure you stay updated with the latest\n\ncoverage.\n\n## Appendix C: List of Memory Offsets for Some ZxShell Functions\n\nHere’s a list for some ZxShell functions for sample SHA256:\n\n1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26c:\n\nFUNCTION NAME BRIEF DESCRIPTION OFFSET\n\nZxGetLibAndProcAddr ZxShell GetProcAddress implementation 0x12CDA\n\nCopyMemoryFromNewMsvcrt ZxShell memory copy routine 0x12C4C\n\nServiceExists Get if a service is installed in the system or not 0x0A7C7\n\nProcessScCommand ZxShell “SC” command implementation 0x0E3EF\n\nAnalyseAndLoadPlugins Parse the installed plugin list and load each one of them 0x0127B7\n\nDeleteAndLogPlugin Delete a corrupted plugin and log the problem 0x012597\n\nKeyloggerThread ZxShell keylogger implementation 0x0D591\n\nGetIpListAndConnect Analyse the IP list inside the ZxShell PE and tries to connect 0x011496\n\nBuildTargetIpListStruct Build remote server Ip list structure 0x11419\n\nDoHandshake Perform initial connection handshake 0xB8E8\n\nGetLocalPcDescrStr Build a string containing the target workstation data 0x0B627\n\nMainConnectionIo ZxShell main connection I/O routine 0x1126C\n\nReceiveCommandData Receive each byte from the socket until a newline char 0x016DF\n\nProcessCommand Main ZxShell command processing routine 0x10C2B\n\n## Appendix D: Other Collateral\n\n[Here is a non-exhaustive list of ZxShell samples that were analyzed for this report.](http://blogs.cisco.com/wp-content/uploads/zxshell-hash-list.txt)\n\n[Here is a list of Domains organized by port.](http://blogs.cisco.com/wp-content/uploads/zxshell-domains-by-port.txt)\n\n[Tags: APT, Group 72, malware, Operation SMN, security, SMN, Talos, threats](http://blogs.cisco.com/tag/apt/)\n\n|FUNCTION NAME|BRIEF DESCRIPTION|OFFSET|\n|---|---|---|\n|ZxGetLibAndProcAddr|ZxShell GetProcAddress implementation|0x12CDA|\n|CopyMemoryFromNewMsvcrt|ZxShell memory copy routine|0x12C4C|\n|ServiceExists|Get if a service is installed in the system or not|0x0A7C7|\n|ProcessScCommand|ZxShell “SC” command implementation|0x0E3EF|\n|AnalyseAndLoadPlugins|Parse the installed plugin list and load each one of them|0x0127B7|\n|DeleteAndLogPlugin|Delete a corrupted plugin and log the problem|0x012597|\n|KeyloggerThread|ZxShell keylogger implementation|0x0D591|\n|GetIpListAndConnect|Analyse the IP list inside the ZxShell PE and tries to connect|0x011496|\n|BuildTargetIpListStruct|Build remote server Ip list structure|0x11419|\n|DoHandshake|Perform initial connection handshake|0xB8E8|\n|GetLocalPcDescrStr|Build a string containing the target workstation data|0x0B627|\n|MainConnectionIo|ZxShell main connection I/O routine|0x1126C|\n|ReceiveCommandData|Receive each byte from the socket until a newline char|0x016DF|\n|ProcessCommand|Main ZxShell command processing routine|0x10C2B|\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/89uahki8m2ksfgc8pysjw6utcqjp4q9u",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.10.28.Group_72_ZxShell/Group72_Opening_ZxShell.pdf"
    ],
    "report_names": [
        "Group72_Opening_ZxShell"
    ],
    "threat_actors": [
        {
            "id": "cea5ceec-0f14-4e34-bd0e-4074bc1a707d",
            "created_at": "2022-10-25T15:50:23.629983Z",
            "updated_at": "2025-03-27T02:00:55.509459Z",
            "deleted_at": null,
            "main_name": "Axiom",
            "aliases": [
                "Group 72"
            ],
            "source_name": "MITRE:Axiom",
            "tools": [
                "ZxShell",
                "gh0st RAT",
                "Zox",
                "PlugX",
                "Hikit",
                "PoisonIvy",
                "Derusbi",
                "Hydraq"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "4b076dcb-516e-42fb-9c8f-f153902cd5e9",
            "created_at": "2022-10-25T16:07:23.708745Z",
            "updated_at": "2025-03-27T02:02:09.935617Z",
            "deleted_at": null,
            "main_name": "Hidden Lynx",
            "aliases": [
                "Aurora Panda",
                "Group 8",
                "Hidden Lynx",
                "Operation SMN"
            ],
            "source_name": "ETDA:Hidden Lynx",
            "tools": [
                "AGENT.ABQMR",
                "AGENT.AQUP.DROPPER",
                "AGENT.BMZA",
                "AGENT.GUNZ",
                "BlackCoffee",
                "HiKit",
                "MCRAT.A",
                "Mdmbot.E",
                "Moudoor",
                "Naid",
                "PNGRAT",
                "Trojan.Naid",
                "ZoxPNG",
                "gresim"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5c74936a-79d1-41b8-81eb-01d03c90a26b",
            "created_at": "2022-10-25T16:07:23.371052Z",
            "updated_at": "2025-03-27T02:02:09.766782Z",
            "deleted_at": null,
            "main_name": "Axiom",
            "aliases": [
                "Group 72",
                "Operation SMN"
            ],
            "source_name": "ETDA:Axiom",
            "tools": [
                "9002 RAT",
                "Agent.dhwf",
                "AngryRebel",
                "BlackCoffee",
                "BleDoor",
                "Chymine",
                "Darkmoon",
                "DeputyDog",
                "Derusbi",
                "Destroy RAT",
                "DestroyRAT",
                "Farfli",
                "Fexel",
                "Gen:Trojan.Heur.PT",
                "Gh0st RAT",
                "Ghost RAT",
                "Gresim",
                "HOMEUNIX",
                "HiKit",
                "HidraQ",
                "Homux",
                "Hydraq",
                "Kaba",
                "Korplug",
                "McRAT",
                "MdmBot",
                "Moudour",
                "Mydoor",
                "PCRat",
                "PNGRAT",
                "PlugX",
                "Poison Ivy",
                "RbDoor",
                "RedDelta",
                "RibDoor",
                "Roarur",
                "SPIVY",
                "Sensocode",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Winnti",
                "Xamtrav",
                "ZXShell",
                "Zox",
                "ZoxPNG",
                "ZoxRPC",
                "gresim",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a7aefdda-98f1-4790-a32d-14cc99de2d60",
            "created_at": "2023-01-06T13:46:38.281844Z",
            "updated_at": "2025-03-27T02:00:02.792526Z",
            "deleted_at": null,
            "main_name": "APT17",
            "aliases": [
                "G0025",
                "AURORA PANDA",
                "Group 72",
                "G0001",
                "HELIUM",
                "Group 8",
                "Hidden Lynx",
                "Tailgater Team",
                "BRONZE KEYSTONE"
            ],
            "source_name": "MISPGALAXY:APT17",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "1edcac0b-efd9-47b1-9aca-33827d5bd085",
            "created_at": "2024-05-01T02:03:07.964773Z",
            "updated_at": "2025-03-27T02:05:17.273595Z",
            "deleted_at": null,
            "main_name": "BRONZE KEYSTONE",
            "aliases": [
                "Aurora Panda ",
                "DeputyDog ",
                "Group 72 ",
                "Hidden Lynx ",
                "Shell Crew",
                "TG-8153 ",
                "Tailgater Team",
                "APT17 "
            ],
            "source_name": "Secureworks:BRONZE KEYSTONE",
            "tools": [
                " BlackCoffee",
                " DeputyDog",
                " Derusbi",
                " Gh0stHTTPSDropper",
                " HiKit",
                " InternalCMD",
                " PlugX",
                " PoisonIvy",
                " ZxShell",
                "9002"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716500,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1414610573,
    "ts_modification_date": 1414610573,
    "files": {
        "pdf": "https://archive.orkl.eu/116309e7121bc8b0e66e4166c06f7b818e1d3629.pdf",
        "text": "https://archive.orkl.eu/116309e7121bc8b0e66e4166c06f7b818e1d3629.txt",
        "img": "https://archive.orkl.eu/116309e7121bc8b0e66e4166c06f7b818e1d3629.jpg"
    }
}