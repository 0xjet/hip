{
    "id": "4da57e88-784b-456c-81b4-e2e9492fb987",
    "created_at": "2023-06-05T02:06:18.819657Z",
    "updated_at": "2025-03-27T02:17:02.412933Z",
    "deleted_at": null,
    "sha1_hash": "cebc5e90adb5e22e87245eb022c2aae0d611bad2",
    "title": "2023-05-14 - Fun with the new bpfdoor (2023)",
    "authors": "",
    "file_creation_date": "2023-06-04T12:56:12Z",
    "file_modification_date": "2023-06-04T12:56:12Z",
    "file_size": 740610,
    "plain_text": "# Fun with the new bpfdoor (2023)\n\n**unfinished.bike/fun-with-the-new-bpfdoor-2023**\n\n## unfinished.bike\n\n\nMay 14, 2023\n\n\n#### May 14, 2023 I was recently provided a sample of the recently announced stealthier variant of bpfdoor, malware targeting Linux that is almost certainly a state-funded Chinese threat actor (Red Menshen). The sample analyzed was a8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7, detectable by 11 of 62 detectors on VirusTotal.\n\n I was particularly curious what the bpfdoor surface area looked like, and if it was easy it was to detect using existing open-source tools and common Linux command-line utilities.\n\n To experiment, I used my favorite VM manager on macOS or Linux for this analysis: Lima, with the default Ubuntu 22.10 image.\n\n## Running bpfdoor as a regular user\n\n#### I first ran bpfdoor as an unprivileged user to see what system calls would be executed:\n```\nstrace -o /tmp/st.user -f ./x.bin\n\n```\n\n-----\n\n#### I ve removed the less interesting lines of output, but the program does astonishingly little:\n```\n2655 execve(\"./x.bin\", [\"./x.bin\"], 0x7fff9dad6ff8 /* 23 vars */) = 0\n\n2655 openat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\n\n2655 openat(AT_FDCWD, \"/var/run/initd.lock\", O_RDWR|O_CREAT, 0666) = -1 EACCES\n(Permission denied)\n\n2655 flock(-1, LOCK_EX|LOCK_NB)    = -1 EBADF (Bad file descriptor)\n\n2655 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,\nchild_tidptr=0x7ff8d1b39a10) = 2656\n\n2655 +++ exited with 0 +++\n\n2656 close(0)             = 0\n\n2656 close(1)             = 0\n\n2656 close(2)             = 0\n\n2656 setsid()             = 2656\n\n2656 getrandom(\"\\xa4\\xd5\\x9d\\x71\\xb3\\xe0\\x98\\xe1\", 8, GRND_NONBLOCK) = 8\n\n2656 socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = -1 EPERM (Operation not\npermitted)\n\n2656 exit_group(0)           = ?\n\n2656 +++ exited with 0 +++\n\n The only noteworthy things here are:\n\n It tries to create /var/run/initd.lock but fails because it requires root It tries to set up a raw socket to listen to all protocols but fails because it requires root. It forks into the background via clone() and setsid().\n\n It's not unusual to see a bug with the flock() call to fd=-1 because openat() returned an error rather than a file handle.\n\n## Running as root\n\n```\n\n-----\n\n```\n2669 openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) 3\n\n2669 flock(3, LOCK_EX|LOCK_NB)     = 0\n\n2669 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,\nchild_tidptr=0x7fb6d948ba10) = 3319\n\n2669 exit_group(0 <unfinished ...>\n\n3319 close(0 <unfinished ...>\n\n2669 +++ exited with 0 +++\n\n3319 close(1)             = 0\n\n3319 close(2)             = 0\n\n3319 setsid()             = 3319\n\n3319 getrandom(\"\\x6c\\x07\\x1c\\x75\\x6b\\xae\\xfe\\xdf\", 8, GRND_NONBLOCK) = 8\n\n3319 socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = 0\n\n3319 setsockopt(0, SOL_SOCKET, SO_ATTACH_FILTER, {len=30, filter=0x7ffd2270fa90},\n16) = 0\n\n3319 recvfrom(0,\n\"RUU\\341\\314\\22RU\\300\\250\\5\\2\\10\\0E\\0\\0Lp\\220\\0\\0@\\6~\\272\\300\\250\\5\\2\\300\\250\"...,\n65536, 0, NULL, NULL) = 90\n\n3319 recvfrom(0,\n\"RUU\\341\\314\\22RU\\300\\250\\5\\2\\10\\0E\\0\\0(p\\221\\0\\0@\\6~\\335\\300\\250\\5\\2\\300\\250\"...,\n65536, 0, NULL, NULL) = 54\n\n3319 recvfrom(0,\n\"RUU\\341\\314\\22RU\\300\\250\\5\\2\\10\\0E\\0\\0Lp\\222\\0\\0@\\6~\\270\\300\\250\\5\\2\\300\\250\"...,\n65536, 0, NULL, NULL) = 90\n\n3319 recvfrom(0,\n\"RUU\\341\\314\\22RU\\300\\250\\5\\2\\10\\0E\\0\\0(p\\223\\0\\0@\\6~\\333\\300\\250\\5\\2\\300\\250\"...,\n65536, 0, NULL, NULL) = 54\n\n#### First, it opens a lock, which works this time:\n-rw-r--r-- 1 root root 0 May 13 12:45 /run/initd.lock\n\n As mentioned in the bpfdoor analysis by deep instinct, we can see that it sets a BPF filter via\nsetsockopt(), and loops waiting for the magic byte sequence:\n\\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66.\n\n One thing I find fascinating is how simple the initialization is: the previous iteration of bpfdoor did so much more in the name of “stealth”:\n\n copies itself to /dev/shm renaming itself in the process table via prctl deletes itself from disk timestomping\n\n Red Menshen must have noticed that every method for achieving stealth is also a reliable detection method. So, the new bpfdoor keeps it simple by not trying to be stealthy. In fact, this binary does so little that it's suspicious. In 2023, most advanced evasion methods are not worth it on Linux: it is good enough to hide in plain sight.\n\n## Detection\n\n```\n\n-----\n\n#### Using the make detect rule from osquery-detection-kit, I examined which existing rules would alert on the presence of the latest bpfdoor. 3 of them did:\n\n unexpected raw socket: unexpected packet sniffers, just like this one! Near-zero false- positive rate.\n\n recently created executables: programs executed within 45 seconds of when it likely landed on disk, based on ctime and btime. This catch-all has found every malware it's encountered, but it requires a comprehensive exception list.\n\n unexpected /var/run file: Inspired by reading the bpfdoor technical analysis, it's good to see this fired when faced with the real thing.\n\n That said, I think we can do better. Let's see what the malware looks like from /proc.\n\n## Exploring bpfdoor using /proc\n\n#### To get an idea of what I can use for further detecting bpfdoor, I wanted to see how it was seen via /proc. First, what libraries does it link against? Based on the report, I'm not expecting anything other than libc:\n\n\n-----\n\n```\n% sudo cat /proc/3319/maps\n\n00400000-00448000 r-xp 00000000 fc:01 3210                /tmp/x.bin\n\n00648000-00649000 r--p 00048000 fc:01 3210                /tmp/x.bin\n\n00649000-0064a000 rw-p 00049000 fc:01 3210                /tmp/x.bin\n\n0064a000-0066a000 rw-p 00000000 00:00 0\n\n00c36000-00c57000 rw-p 00000000 00:00 0                 [heap]\n\n7fb6d9200000-7fb6d9222000 r--p 00000000 fc:01 3648           \n/usr/lib/x86_64-linux-gnu/libc.so.6\n\n7fb6d9222000-7fb6d939b000 r-xp 00022000 fc:01 3648           \n/usr/lib/x86_64-linux-gnu/libc.so.6\n\n7fb6d939b000-7fb6d93f2000 r--p 0019b000 fc:01 3648           \n/usr/lib/x86_64-linux-gnu/libc.so.6\n\n7fb6d93f2000-7fb6d93f6000 r--p 001f1000 fc:01 3648           \n/usr/lib/x86_64-linux-gnu/libc.so.6\n\n7fb6d93f6000-7fb6d93f8000 rw-p 001f5000 fc:01 3648           \n/usr/lib/x86_64-linux-gnu/libc.so.6\n\n7fb6d93f8000-7fb6d9405000 rw-p 00000000 00:00 0\n\n7fb6d948b000-7fb6d948e000 rw-p 00000000 00:00 0\n\n7fb6d9495000-7fb6d9497000 rw-p 00000000 00:00 0\n\n7fb6d9497000-7fb6d9498000 r--p 00000000 fc:01 3645           \n/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n\n7fb6d9498000-7fb6d94c1000 r-xp 00001000 fc:01 3645           \n/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n\n7fb6d94c1000-7fb6d94cb000 r--p 0002a000 fc:01 3645           \n/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n\n7fb6d94cb000-7fb6d94cd000 r--p 00034000 fc:01 3645           \n/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n\n7fb6d94cd000-7fb6d94cf000 rw-p 00036000 fc:01 3645           \n/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\n\n7ffd226f0000-7ffd22711000 rw-p 00000000 00:00 0             [stack]\n7ffd22720000-7ffd22724000 r--p 00000000 00:00 0             [vvar]\n\n7ffd22724000-7ffd22726000 r-xp 00000000 00:00 0             [vdso]\n\nffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0         [vsyscall]\n\n#### What about open file handles?\n% sudo lsof -p 3319\n\nCOMMAND PID USER  FD  TYPE DEVICE SIZE/OFF NODE NAME\n\nx.bin  3319 root cwd  DIR  0,52   200  9 /tmp/lima/osquery-defense-kit/out\n\nx.bin  3319 root rtd  DIR 252,1   4096  2 /\n\nx.bin  3319 root txt  REG 252,1  302576 3210 /tmp/x.bin\n\nx.bin  3319 root mem  REG 252,1 2072888 3648 /usr/lib/x86_64-linuxgnu/libc.so.6\n\nx.bin  3319 root mem  REG 252,1  228720 3645 /usr/lib/x86_64-linux-gnu/ldlinux-x86-64.so.2\n\nx.bin  3319 root  0u pack 33049   0t0 ALL type=SOCK_RAW\n\nx.bin  3319 root  3u  REG  0,25    0 1322 /run/initd.lock\n\n lsof is handy, but to see the raw socket from /proc, we need to do a little bit more digging:\n\n```\n\n-----\n\n```\n# cat /proc/net/packet\n\nsk        RefCnt Type Proto Iface R Rmem  User  Inode\n\nffff92d346ba6800 3   3  88cc  2   1 0   100  19458\n\nffff92d34631d800 3   3  0003  0   1 241920 0   33089\n\n#### The Inode field is misleading, but you can use it to find the associated process ID via:\n$ sudo find /proc -type l -lname \"socket:\\[33089\\]\" 2>/dev/null\n\n/proc/3319/task/3319/fd/0\n\n/proc/3319/fd/0\n\n Alternatively, you can use this to see all filehandles for the process ID:\n$ ls -la /proc/3319/fd\n\ntotal 0\n\ndr-x------ 2 root root 0 May 13 13:03 .\n\ndr-xr-xr-x 9 root root 0 May 13 13:03 ..\n\nlrwx------ 1 root root 64 May 13 13:03 0 -> 'socket:[33089]'\n\nlrwx------ 1 root root 64 May 13 13:03 3 -> /run/initd.lock\n\n Once you have a process ID, you can resolve the path to the program:\nsudo ls -lad /proc/3319/exe\n\nlrwxrwxrwx 1 root root 0 May 14 00:48 /proc/3319/exe -> /tmp/x.bin\n\n\n## Exploring bpfdoor using strings\n\n#### Running strings <path> reveals some interesting messages:\n[-] Execute command failed\n\n/var/run/initd.lock\n\n libtom/libtomcrypt has been bundled in, so we see lines such as:\nLTC_ARGCHK '%s' failure on line %d of file %s\n\nX.509v%i certificate\n\n Issued by: [%s]%s (%s)\n\n Issued to: [%s]%s (%s, %s)\n\n Subject: %s\n\n Validity: %s - %s\n\n OCSP: %s\n\n Serial number:\n\n...\n\nLibTomCrypt 1.17 (Tom St Denis, tomstdenis@gmail.com)\n\nLibTomCrypt is public domain software.\n\nBuilt on Oct 4 2022 at 16:09:32\n\n```\n\n-----\n\n#### That last string is important: this iteration of bpfdoor could have been wandering around Cyberspace since October 2022 (7 months ago) without detection. It also appears that the bad guys used Red Hat Enterprise Linux 7.0 (nearly 10 years old!) to build the binary:\n```\nGCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)\n\n\n## New detection possibilities\n\n#### After looking at /proc, a couple of new detection ideas came up:\n\n Programs with /var/run lock files open Root processes with a socket and no shared libraries World-readable lock files in /var/run Minimalist socket users with few open files Processes where fd 0 is a non-UNIX socket\n\n There are certainly more possibilities depending on how this backdoor is launched: for example, based on cwd or cgroup. I have not yet seen information published on how this backdoor is actually executed.\n\n I implemented each of these detection ideas: once for osquery to use in production, and once in shell just for fun. The osquery queries have been tested across Ubuntu, Fedora, Arch Linux, and NixOS, and the shell scripts have only been tested on Ubuntu.\n\n### Programs with /run lock files left open\n\n#### It's unusual for a program to have an open file in /var/run, but I suspect this may eventually find a false positive. Here's an osquery and a shell script to find these:\nSELECT p.* FROM processes p JOIN process_open_files pof ON p.pid = pof.pid AND\npof.path LIKE \"/run/%.lock\";\n\nsudo find /proc -lname \"/run/*.lock\" 2>/dev/null\n\n\n### Root processes with a socket and no shared libraries\n\n#### Most programs that use a socket are either fully static, or import a library like OpenSSL. bpfdoor isn't either. Here is another osquery and shell pair:\n\n```\n\n-----\n\n```\nSELECT p.,\n\n  COUNT(DISTINCT pmm.path) AS pmm_count\n\nFROM processes p\n\n  JOIN process_open_sockets pos ON p.pid = pos.pid\n\n  LEFT JOIN process_memory_map pmm ON p.pid = pmm.pid\n\n  AND pmm.path LIKE \"%.so.%\"\n\n  -- Yes, this is a weird performance optimization\n\nWHERE p.pid IN (\n\n    SELECT pid\n\n    FROM processes\n\n    WHERE p.euid = 0\n\n      AND p.path NOT IN (\n\n        '/usr/bin/containerd',\n\n        '/usr/bin/fusermount3',\n\n        '/usr/sbin/acpid',\n\n        '/usr/sbin/mcelog',\n\n        '/usr/bin/docker-proxy'\n\n      )\n\n  )\n\nGROUP BY pos.pid -- libc.so, ld-linux\n\nHAVING pmm_count = 2;\n\ncd /proc || exit\n\nfor pid in *; do\n\n  [[ ! -f ${pid}/exe || ${pid} =~ \"self\" ]] && continue\n\n  euid=$(grep Uid /proc/${pid}/status | awk '{ print $2 }')\n\n  [[ \"${euid}\" != 0 ]] && continue\n\n  sockets=$(sudo find /proc/${pid}/fd -lname \"socket:*\" | wc -l)\n\n  [[ \"${sockets}\" == 0 ]] && continue\n\n  libs=$(sudo find /proc/${pid}/map_files/ -type l -lname \"*.so.*\" -exec readlink\n{} \\; | sort -u | wc -l)\n\n  [[ \"${libs}\" != 2 ]] && continue\n\n  path=$(readlink /proc/$pid/exe)\n\n  name=$(cat /proc/$pid/comm)\n\n  echo \"euid=0 process with sockets and no libs: ${name} [${pid}] at ${path}\"\n\ndone\n\n### World readable lock files in /var/run\n\n#### Typically lock files are readable only by the root user. Malware often uses very relaxed file permissions.\nSELECT * FROM file WHERE path LIKE \"/tmp/%.lock\" AND mode = \"0644\";\n\nfind /run/*.lock -perm 644\n\n\n### Minimalist socket users with few open files\n\n```\n\n-----\n\n#### This creative query reveals minimalist programs that behave like a backdoor might:\n\n have 0-1 open files have 1-2 sockets open\n\n It's an uncommon situation, but it is bound to have false positives in software that is designed in a way that each process has a specific role:\n```\nSELECT p.pid,\n\n  p.path,\n\n  p.name,\n\n  p.start_time,\n\n  GROUP_CONCAT(DISTINCT pos.protocol) AS protocols,\n\n  pof.path AS pof_path,\n\n  COUNT(DISTINCT pos.fd) AS scount,\n\n  COUNT(DISTINCT pof.path) AS fcount,\n\n  GROUP_CONCAT(DISTINCT pof.path) AS open_files,\n\n  p.cgroup_path\n\nFROM processes p\n\n  JOIN process_open_sockets pos ON p.pid = pos.pid\n\n  AND pos.protocol > 0\n\n  LEFT JOIN process_open_files pof ON p.pid = pof.pid\n\nWHERE p.start_time < (strftime('%s', 'now') -60)\n\nAND p.path NOT IN (\n\n  '/bin/registry',\n\n  '/usr/bin/docker-proxy',\n\n  '/usr/sbin/chronyd',\n\n  '/usr/sbin/cups-browsed',\n\n  '/usr/sbin/cupsd',\n\n  '/usr/sbin/sshd'\n\n)\n\nAND p.path NOT LIKE '/nix/store/%-openssh-%/bin/sshd'\n\nGROUP BY p.pid\n\nHAVING scount <= 2\n\n  AND fcount <= 1;\n\n```\n\n-----\n\n```\ncd /proc || exit\n\nfor pid in *; do\n\n  [[ ! -f ${pid}/exe || ${pid} =~ \"self\" ]] && continue\n\n  fds=$(find /proc/${pid}/fd -lname \"/*\" | wc -l)\n\n  [[ \"${fds}\" == 0 ]] && continue\n\n  [[ \"${fds}\" -gt 1 ]] && continue\n\n  # WARNING: ss -xp will print two fds on the same line if connected. Use grep -o\ninstead of -c\n\n  #ss -xp | grep -v \"^u_\" | grep -o pid=${pid},\"\n\n  all_sockets=$(find /proc/${pid}/fd -lname \"socket:*\" | wc -l)\n\n  [[ \"${all_sockets}\" -gt 2 ]] && continue\n\n  # this isn't exactly what we want - ss doesn't show TYPE=sock of protocol=UNIX :(\n\n  unix_sockets=$(ss -ap | grep \"^u_\" | grep -o \"pid=${pid},\" | wc -l)\n\n  sockets=$(($all_sockets - $unix_sockets))\n\n  [[ \"${sockets}\" == 0 ]] && continue\n\n  [[ \"${sockets}\" -gt 2 ]] && continue\n\n  path=$(readlink /proc/$pid/exe)\n\n  [[ \"${path}\" == \"/usr/sbin/sshd\" ]] && continue\n\n  name=$(cat /proc/$pid/comm)\n\n  echo \"minimalist socket user (${sockets} sockets and ${fds} files): ${name}\n[${pid}] at ${path}\"\n\ndone\n\n\n### fd0 is a socket\n\n#### I've saved my favorite for last. File descriptor 0 is usually stdin, but in bpfdoors case, it is actually the socket it uses to listen to traffic on. I've never seen this behavior before outside of bpfdoor:\nSELECT * FROM process_open_sockets WHERE fd=0 AND family != 1;\n\n```\n\n-----\n\n```\ncd /proc || exit\n\nfor pid in *; do\n\n  [[ ! -f ${pid}/exe || ${pid} =~ \"self\" ]] && continue\n\n  ino=$(readlink /proc/$pid/fd/0 | grep -o 'socket:.*' | cut -d\"[\" -f2 | cut -d\"]\"\n-f1)\n\n  grep -q \" ${ino}\" /proc/$pid/net/unix && continue\n\n  path=$(readlink /proc/$pid/exe)\n\n  name=$(cat /proc/$pid/comm)\n\n  echo \"fd0 is a socket: ${name} [${pid}] at ${path}\"\n\ndone\n\n## Final Thoughts\n\n#### Ultimately, I was happy to see that this variant was detectable using osquery-defense-kit, and even happier that I could add additional rules to find future similar malware. Two philosophical viewpoints are critical to success in detection:\n\n Knowing what is considered normal in your environment Evasion is a means of detection\n\n If you are interested in open-source queries that can find bpfdoor and other unusual programs, check out:\n\n https://github.com/chainguard-dev/osquery-defense-kit/ https://github.com/tstromberg/sunlight\n\n Thanks to Kevin Beaumont for providing the bpfdoor sample for analysis.\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-14 - Fun with the new bpfdoor (2023).pdf"
    ],
    "report_names": [
        "2023-05-14 - Fun with the new bpfdoor (2023).pdf"
    ],
    "threat_actors": [
        {
            "id": "9c8a7541-1ce3-450a-9e41-494bc7af11a4",
            "created_at": "2023-01-06T13:46:39.358343Z",
            "updated_at": "2025-03-27T02:00:03.06082Z",
            "deleted_at": null,
            "main_name": "Red Menshen",
            "aliases": [
                "Red Dev 18"
            ],
            "source_name": "MISPGALAXY:Red Menshen",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1685930778,
    "ts_updated_at": 1743041822,
    "ts_creation_date": 1685883372,
    "ts_modification_date": 1685883372,
    "files": {
        "pdf": "https://archive.orkl.eu/cebc5e90adb5e22e87245eb022c2aae0d611bad2.pdf",
        "text": "https://archive.orkl.eu/cebc5e90adb5e22e87245eb022c2aae0d611bad2.txt",
        "img": "https://archive.orkl.eu/cebc5e90adb5e22e87245eb022c2aae0d611bad2.jpg"
    }
}