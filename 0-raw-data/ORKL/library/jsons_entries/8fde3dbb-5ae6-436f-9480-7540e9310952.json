{
    "id": "8fde3dbb-5ae6-436f-9480-7540e9310952",
    "created_at": "2023-01-12T14:59:36.197984Z",
    "updated_at": "2025-03-27T02:06:12.296024Z",
    "deleted_at": null,
    "sha1_hash": "78ae731f1cdcd4d989b016dbb33763fe551f0e9b",
    "title": "2019-08-10 - SELECT code_execution FROM  USING SQLite;",
    "authors": "",
    "file_creation_date": "2022-05-28T02:16:18Z",
    "file_modification_date": "2022-05-28T02:16:18Z",
    "file_size": 5978732,
    "plain_text": "# SELECT code_execution FROM * USING SQLite;\n\n**[research.checkpoint.com/2019/select-code_execution-from-using-sqlite/](https://research.checkpoint.com/2019/select-code_execution-from-using-sqlite/)**\n\nAugust 10, 2019\n\n### Gaining code execution using a malicious SQLite database\n\n**Research By: Omer Gull**\n\n## tl;dr\n\n\nAugust 10, 2019\n\n\nSQLite is one of the most deployed software in the world. However, from a security\nperspective, it has only been examined through the lens of WebSQL and browser\nexploitation. We believe that this is just the tip of the iceberg.\n\nIn our long term research, we experimented with the exploitation of memory corruption\nissues within SQLite without relying on any environment other than the SQL language. Using\nour innovative techniques of Query Hijacking and Query Oriented Programming, we proved it\nis possible to reliably exploit memory corruptions issues in the SQLite engine. We\ndemonstrate these techniques a couple of real-world scenarios: pwning a password stealer\nbackend server, and achieving iOS persistency with higher privileges.\n\n\n-----\n\nWe hope that by releasing our research and methodology, the security research community\nwill be inspired to continue to examine SQLite in the countless scenarios where it is\navailable. Given the fact that SQLite is practically built-in to every major OS, desktop or\nmobile, the landscape and opportunities are endless. Furthermore, many of the primitives\npresented here are not exclusive to SQLite and can be ported to other SQL engines.\nWelcome to the brave new world of using the familiar Structured Query Language for\nexploitation primitives.\n\n## Motivation\n\n[This research started when omriher and I were looking at the leaked source code of some](https://twitter.com/omriher?lang=en)\n[notorious password stealers. While there are plenty of password stealers out there (Azorult,](https://malpedia.caad.fkie.fraunhofer.de/details/win.azorult)\n[Loki Bot, and](https://securelist.com/loki-bot-stealing-corporate-passwords/87595/) [Pony to name a few), their modus operandi is mostly the same:](https://www.acunetix.com/blog/articles/pony-malware-credential-theft/)\n\nA computer gets infected, and the malware either captures credentials as they are used or\ncollects stored credentials maintained by various clients.\n\nIt is not uncommon for client software to use SQLite databases for such purposes.\n\nAfter the malware collects these SQLite files, it sends them to its C2 server where they are\nparsed using PHP and stored in a collective database containing all of the stolen credentials.\n\nSkimming through the leaked source code of such password stealers, we started speculating\nabout the attack surface described above.\n\nCan we leverage the load and query of an untrusted database to our advantage?\n\nSuch capabilities could have much bigger implications in countless scenarios, as SQLite is\none of the most widely deployed pieces of software out there.\n\nA surprisingly complex code base, available in almost any device imaginable. is all the\nmotivation we needed, and so our journey began.\n\n## SQLite Intro\n\nThe chances are high that you are currently using SQLite, even if you are unaware of it.\nTo quote its authors:\n\n_SQLite is a C-language library that implements a small, fast, self-contained, high-reliability,_\n_full-featured, SQL database engine. SQLite is the most used database engine in the world._\n_SQLite is built into all mobile phones and most computers and comes bundled inside_\n_countless other applications that people use every day._\n\nUnlike most other SQL databases, SQLite does not have a separate server process. SQLite\nreads and writes directly to ordinary disk files. A complete SQL database with multiple tables,\nindices, triggers, and views is contained within a single disk file.\n\n### Attack Surface\n\n\n-----\n\nThe following snippet is a fairly generic example of a password stealer backend.\n\nGiven the fact that we control the database and its content, the attack surface available to us\ncan be divided into two parts: The load and initial parsing of our database, and the SELECT\nquery performed against it.\n\nThe initial loading done by sqlite3_open is actually a very limited surface; it is basically a lot\n[of setup and configuration code for opening the database. Our surface is mainly the header](https://www.sqlite.org/fileformat.html#the_database_header)\nparsing which is battle-tested against AFL.\n\nThings get more interesting as we start querying the database.\n\nUsing SQLite authors‚Äô words:\n\n_‚ÄúThe SELECT statement is the most complicated command in the SQL language.‚Äù_\n\nAlthough we have no control over the query itself (as it is hardcoded in our target), studying\nthe SELECT process carefully will prove beneficial in our quest for exploitation.\n\nAs SQLite3 is a virtual machine, every SQL statement must first be compiled into a byte[code program using one of the sqlite3_prepare* routines.](https://www.sqlite.org/c3ref/prepare.html)\n\nAmong other operations, the prepare function walks and expands all SELECT subqueries.\n\n\n-----\n\nPart of this process is verifying that all relevant objects (like tables or views) actually exist\nand locating them in the master schema.\n\n### sqlite_master and DDL\n\nEvery SQLite database has a `sqlite_master table that defines the schema for the`\ndatabase and all of its objects (such as tables, views, indices, etc.).\n\nThe sqlite_master table is defined as:\n\nThe part that is of special interest to us is the sql column.\n\nThis field is the DDL (Data Definition Language) used to describe the object.\n\nIn a sense, the DDL commands are similar to C header files. DDL commands are used to\ndefine the structure, names, and types of the data containers within a database, just as a\nheader file typically defines type definitions, structures, classes, and other data structures.\n\nThese DDL statements actually appear in plain-text if we inspect the database file:\n\n\n-----\n\nDuring the query preparation, sqlite3LocateTable() attempts to find the in-memory structure\nthat describes the table we are interested in querying.\n\nsqlite3LocateTable() reads the schema available in sqlite_master, and if this is the first time\ndoing it, it also has a callback for every result that verifies the DDL statement is valid and\nbuild the necessary internal data structures that describe the object in question.\n\n## DDL Patching\n\nLearning about this preparation process, we asked, can we simply replace the DDL that\nappears in plain-text within the file? If we could inject our own SQL to the file perhaps we can\naffect its behaviour.\n\nBased on the code snippet above, it seems that DDL statements must begin with ‚Äúcreate ‚Äú.\n\nWith this limitation in mind, we needed to assess our surface.\n\nChecking SQLite‚Äôs documentation revealed that these are the possible objects we can\n\n\n-----\n\ncreate:\n\nThe CREATE VIEW command gave us an interesting idea. To put it very simply, VIEWs are\njust pre-packaged SELECT statements. If we replace the table expected by the target\nsoftware with a compatible VIEW, interesting opportunities reveal themselves.\n\n### Hijack Any Query\n\nImagine the following scenario:\n\nThe original database has a single TABLE called dummy that is defined as:\n\nThe target software queries it with the following:\n\nWe can actually hijack this query if we craft dummy as a VIEW:\n\n\n-----\n\nThis ‚Äútrap‚Äù VIEW enables us to hijack the query ‚Äì meaning we generate a completely new\nquery that we totally control.\n\nThis nuance greatly expands our attack surface, from the very minimal parsing of the header\nand an uncontrollable query performed by the loading software, to the point where we can\nnow interact with vast parts of the SQLite interpreter by patching the DDL and creating our\nown views with sub-queries.\n\nNow that we can interact with the SQLite interpreter, our next question was what exploitation\nprimitives are built into SQLite? Does it allow any system commands, reading from or writing\nto the filesystem?\n\nAs we are not the first to notice the huge SQLite potential from an exploitation perspective, it\nmakes sense to review prior work done in the field. We started from the very basics.\n\n### SQL Injections\n\nAs researchers, it‚Äôs hard for us to even spell SQL without the ‚Äúi‚Äù, so it seems like a\nreasonable place to start. After all, we want to familiarize ourselves with the internal\nprimitives offered by SQLite. Are there any system commands? Can we load arbitrary\nlibraries?\n\n[It seems that the most straightforward trick involves attaching a new database file and writing](https://atta.cked.me/home/sqlite3injectioncheatsheet)\nto it using something along the lines of:\n\n\n-----\n\nWe attach a new database, create a single table and insert a single line of text. The new\ndatabase then creates a new file (as databases are files in SQLite) with our web shell inside\nit.\n\nThe very forgiving nature of the PHP interpreter parses our database until it reaches the PHP\nopen tag of ‚Äú<?‚Äù.\n\nWriting a webshell is definitely a win in our password stealers scenario, however, as you\nrecall, DDL cannot begin with ‚ÄúATTACH‚Äù\n\n[Another relevant option is the load_extension function. While this function should allow us to](https://www.sqlite.org/c3ref/load_extension.html)\nload an arbitrary shared object, it is disabled by default.\n\n### Memory Corruptions In SQLite\n\nLike any other software written in C, memory safety issues are definitely something to\nconsider when assessing the security of SQLite.\n\nIn his great [blog post, Micha≈Ç Zalewski described how he fuzzed SQLite with AFL to achieve](https://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html)\nsome impressive results: 22 bugs in just 30 minutes of fuzzing.\n\nInterestingly, SQLite has since started using AFL as an integral part of their remarkable test\nsuite.\n\nThese memory corruptions were all treated with the expected gravity (Richard Hip and his\nteam deserve tons of respect). However, from an attacker‚Äôs perspective, these bugs would\nprove to be a difficult path to exploitation without a decent framework to leverage them.\n\nModern mitigations pose a major obstacle in exploiting memory corruption issues and\nattackers need to find a more flexible environment.\n\nThe Security Research community would soon find the perfect target!\n\n### Web SQL\n\nWeb SQL Database is a web page API for storing data in databases that can be queried\nusing a variant of SQL through JavaScript.The W3C Web Applications Working Group\nceased working on the specification in November 2010, citing a lack of independent\nimplementations other than SQLite.\n\nCurrently, the API is still supported by Google Chrome, Opera and Safari.\n\nAll of them use SQLite as the backend of this API.\n\n\n-----\n\nUntrusted input into SQLite, reachable from any website inside some of the most popular\nbrowsers, caught the security community‚Äôs attention and as a result, the number of\nvulnerabilities began to rise.\nSuddenly, bugs in SQLite could be leveraged by the JavaScript interpreter to achieve reliable\nbrowser exploitation.\n\nSeveral impressive research reports have been published:\n\n[Low hanging fruits like CVE-2015-7036](https://nvd.nist.gov/vuln/detail/CVE-2015-7036)\n\nUntrusted pointer dereference fts3_tokenizer()\n[More complex exploits presented in Blackhat 17 by the Chaitin team](https://www.blackhat.com/docs/us-17/wednesday/us-17-Feng-Many-Birds-One-Stone-Exploiting-A-Single-SQLite-Vulnerability-Across-Multiple-Software.pdf)\n\nType confusion in fts3OptimizeFunc()\n[The recent Magellan bugs exploited by Exodus](https://blog.exodusintel.com/2019/01/22/exploiting-the-magellan-bug-on-64-bit-chrome-desktop)\n\nInteger overflow in fts3SegReaderNext()\n\nA clear pattern in past WebSQL research reveals that a virtual table module named ‚ÄùFTS‚Äù\nmight be an interesting target for our research.\n\n## FTS\n\nFull-Text Search (FTS) is a virtual table module that allows textual searches on a set of\ndocuments.\n\nFrom the perspective of an SQL statement, the virtual table object looks like any other table\nor view. But behind the scenes, queries on a virtual table invoke callback methods on\nshadow tables instead of the usual reading and writing on the database file.\n\nSome virtual table implementations, like FTS, make use of real (non-virtual) database tables\nto store content.\n\nFor example, when a string is inserted into the FTS3 virtual table, some metadata must be\ngenerated to allow for an efficient textual search. This metadata is ultimately stored in real\ntables named ‚Äú%_segdir‚Äù and ‚Äú%_segments‚Äù, while the content itself is stored in\n‚Äú‚Äù%_content‚Äù where ‚Äú%‚Äù is the name of the original virtual table.\n\nThese auxiliary real tables that contain data for a virtual table are called ‚Äúshadow tables‚Äù\n\n\n-----\n\nDue to their trusting nature, interfaces that pass data between shadow tables provide a fertile\nground for bugs. CVE-2019-8457,- a new OOB read vulnerability we found in the RTREE\nvirtual table module, demonstrates this well.\n\nRTREE virtual tables, used for geographical indexing, are expected to begin with an integer\ncolumn. Therefore, other RTREE interfaces expect the first column in an RTREE to be an\ninteger. However, if we create a table where the first column is a string, as shown in the\nfigure below, and pass it to the rtreenode() interface, an OOB read occurs.\n\nNow that we can use query hijacking to gain control over a query, and know where to find\nvulnerabilities, it‚Äôs time to move on to exploit development.\n\n\n-----\n\n## SQLite Internals For Exploit Development\n\nPrevious publications on SQLite exploitation clearly show that there has always been a\nnecessity for a wrapping environment, whether it is the PHP interpreter seen in this\n[awesome blog post on abusing SQLite tokenizers or the more recent work on Web SQL from](https://medium.com/0xcc/bypass-php-safe-mode-by-abusing-sqlite3s-fts-tokenizer-256ee2555607)\nthe comfort of a JavaScript interpreter.\n\nAs SQLite is pretty much everywhere, limiting its exploitation potential sounded like lowballing to us and we started exploring the use of SQLite internals for exploitation purposes.\nThe research community became pretty good at utilizing JavaScript for exploit development.\nCan we achieve similar primitives with SQL?\n\n[Bearing in mind that SQL is Turing complete ([1], [2]), we started creating a primitive wish-list](https://assets.en.oreilly.com/1/event/27/High%252520Performance%252520SQL%252520with%252520PostgreSQL%252520Presentation.pdf)\nfor exploit development based on our pwning experience.\nA modern exploit written purely in SQL has the following capabilities:\n\nMemory leak.\nPacking and unpacking of integers to 64-bit pointers.\nPointer arithmetics.\nCrafting complex fake objects in memory.\nHeap Spray.\n\nOne by one, we will tackle these primitives and implement them using nothing but SQL.\n\nFor the purpose of achieving RCE on PHP7, we will utilize the still unfixed 1-day of CVE2015-7036.\n\nWait, what? How come a 4-year-old bug has never been fixed? It is actually an interesting\nstory and a great example of our argument.\nThis feature was only ever considered vulnerable in the context of a program that allows\n\n\n-----\n\narbitrary SQL from an untrusted source (Web SQL), and so it was mitigated accordingly.\nHowever, SQLite usage is so versatile that we can actually still trigger it in many scenarios\nüôÇ\n\n### Exploitation Game-plan\n\nCVE-2015-7036 is a very convenient bug to work with.\n\nIn a nutshell, the vulnerable fts3_tokenizer() function returns the tokenizer address when\ncalled with a single argument (like ‚Äúsimple‚Äù, ‚Äúporter‚Äù or any other registered tokenizer).\n\nWhen called with 2 arguments, fts3_tokenizer overrides the tokenizer address in the first\nargument with the address provided by a blob in the second argument.\n\nAfter a certain tokenizer has been overridden, any new instance of the fts table that uses this\ntokenizer allows us to hijack the flow of the program.\n\nOur exploitation game-plan:\n\nLeak a tokenizer address\nCompute the base address\nForge a fake tokenizer that will execute our malicious code\nOverride one of the tokenizers with our malicious tokenizer\nInstantiate an fts3 table to trigger our malicious code\n\nNow back to our exploit development.\n\n## Query Oriented Programming ¬©\n\nWe are proud to present our own unique approach for exploit development using the familiar\nstructured query language. We share QOP with the community in the hope of encouraging\nresearchers to pursue the endless possibilities of database engines exploitation.\n\nEach of the following primitives is accompanied by an example from the sqlite3 shell.\n\n\n-----\n\nWhile this will give you a hint of what want to achieve, keep in mind that our end goal is to\nplant all those primitives in the sqlite_master table and hijack the queries issued by the target\nsoftware that loads and queries our malicious SQLite db file\n\n### Memory Leak ‚Äì Binary\n\nMitigations such as ASLR definitely raised the bar for memory corruptions exploitation. A\ncommon way to defeat it is to learn something about the memory layout around us.\n\nThis is widely known as Memory Leak.\n\nMemory leaks are their own sub-class of vulnerabilities, and each one has a slightly different\nsetup.\n\nIn our case, the leak is the return of a BLOB by SQLite.\n\nThese BLOBs make a fine leak target as they sometimes hold memory pointers.\n\nThe vulnerable fts3_tokenizer() is called with a single argument and returns the memory\naddress of the requested tokenizer. [hex() makes it readable by humans.](https://www.sqlite.org/lang_corefunc.html#hex)\n\nWe obviously get some memory address, but it is reversed due to little-endianity.\n\nSurely we can flip it using some SQLite built-in string operations.\n\n[substr() seems to be a perfect fit! We can read little-endian BLOBs but this raises another](https://www.sqlite.org/lang_corefunc.html#substr)\nquestion: how do we store things?\n\n### QOP Chain\n\n\n-----\n\nNaturally, storing data in SQL requires an INSERT statement. Due to the hardened\nverification of sqlite_master, we can‚Äôt use INSERT as all of the statements must start with\n‚ÄúCREATE ‚Äú. Our approach to this challenge is to simply store our queries under a meaningful\nVIEW and chain them together.\nThe following example makes it a bit clearer:\n\nThis might not seem like a big difference, but as our chain gets more complicated, being able\nto use pseudo-variables will surely make our life easier.\n\n### Unpacking of 64-bit pointers\n\nIf you‚Äôve ever done any pwning challenges, the concept of packing and unpacking of pointers\nshould not be foreign.\n\nThis primitive should make it easy to convert our hexadecimal values (like the leak we just\nachieved) to integers. Doing so allows us to perform various calculations on these pointers in\nthe next steps.\n\nThis query iterates a hexadecimal string char by char in a reversed fashion using substr().\n\n\n-----\n\n[A translation of this char is done using this clever trick with the minor adjustment of instr()](https://gist.github.com/ChiChou/97a53caa2c0b49c1991e)\nwhich is 1-based.\nAll that is needed now is the proper shift that is on the right of the * sign.\n\n### Pointer arithmetics\n\nPointer arithmetics is a fairly easy task with integers at hand. For example, extracting the\nimage base from our leaked tokenizer pointer is as easy as:\n\n### Packing of 64-bit pointers\n\nAfter reading leaked pointers and manipulating them to our will, it makes sense to pack them\nback to their little-endian form so we can write them somewhere.\n\nSQLite [char() should be of use here as its documentation states that it will ‚Äúreturn a string](https://www.sqlite.org/lang_corefunc.html%23char)\ncomposed of characters having the Unicode code point values of an integer.‚Äù\n\nIt proved to work fairly well, but only on a limited range of integers\n\n\n-----\n\nLarger integers were translated to their 2-bytes code-points.\n\nAfter banging our heads against SQLite documentation, we suddenly had a strange\nepiphany: our exploit is actually a database.\n\nWe can prepare beforehand a table that maps integers to their expected values.\n\nNow our pointer packing query is the following:\n\n### Crafting complex fake objects in memory\n\nWriting a single pointer is definitely useful, but still not enough. Many memory safety issues\nexploitation scenarios require the attackers to forge some object or structure in memory or\neven write a ROP chain.\n\n\n-----\n\nEssentially, we will string several of the building blocks we presented earlier.\n[For example, let‚Äôs forge our own tokenizer, as explained here.](https://www.sqlite.org/fts3.html#custom_application_defined_tokenizers)\nOur fake tokenizer should conform to the interface expected by SQLite defined here:\n\nUsing the methods described above and a simple JOIN query, we are able to fake the\ndesired object quite easily.\n\nVerifying the result in a low-level debugger, we see that indeed a fake tokenizer object was\ncreated.\n\n### Heap Spray\n\nNow that we crafted our fake object, it is sometimes useful to spray the heap with it.\n\nThis should ideally be some repetitive form of the latter.\n\nUnfortunately, SQLite does not implement the REPEAT() function like MySQL.\n\nHowever, [this thread gave us an elegant solution.](https://stackoverflow.com/questions/11568496/how-to-emulate-repeat-in-sqlite)\n\n\n-----\n\nThe [zeroblob(N) function returns a BLOB consisting of N bytes while we use replace() to](https://www.sqlite.org/lang_corefunc.html#zeroblob)\nreplace those zeros with our fake object.\n\nSearching for those 0x41s shows we also achieved a perfect consistency. Notice the\nrepetition every 0x20 bytes.\n\n### Memory Leak ‚Äì Heap\n\nLooking at our exploitation game plan, it seems like we are moving in the right direction.\n\nWe already know where the binary image is located, we were able to deduce where the\nnecessary functions are, and spray the heap with our malicious tokenizer.\n\nNow it‚Äôs time to override a tokenizer with one of our sprayed objects. However, as the heap\naddress is also randomized, we don‚Äôt know where our spray is allocated.\n\nA heap leak requires us to have another vulnerability.\n\n\n-----\n\nAgain, we will target a virtual table interface.\nAs virtual tables use underlying shadow tables, it is quite common for them to pass raw\npointers between different SQL interfaces.\n\n[Note: This exact type of issue was mitigated in SQLite 3.20. Fortunately, PHP7 is compiled](https://www.sqlite.org/bindptr.html)\nwith an earlier version. In case of an updated version, CVE-2019-8457 could be used here\nas well.\n\nTo leak the heap address, we need to generate an fts3 table beforehand and abuse its\nMATCH interface.\n\nJust as we saw in our first memory leak, the pointer is little-endian so it needs to be\nreversed. Fortunately, we already know how to do so using SUBSTR().\n\nNow that we know our heap location, and can spray properly, we can finally override a\ntokenizer with our malicious tokenizer!\n\n## Putting It All Together\n\nWith all the desired exploitation primitives at hand, it‚Äôs time to go back to where we started:\nexploiting a password stealer C2.\n\nAs explained above, we need to set up a ‚Äútrap‚Äù VIEW to kickstart our exploit. Therefore, we\nneed to examine our target and prepare the right VIEW.\n\n\n-----\n\nAs seen in the snippet above, our target expects our db to have a table called Notes with a\ncolumn called BodyRich inside it. To hijack this query, we created the following VIEW\n\nAfter Notes is queried, 3 QOP Chains execute. Let‚Äôs analyze the first one of them.\n\n### heap_spray\n\nOur first QOP chain should populate the heap with a large amount of our malicious tokenizer.\n\np64_simple_create, p64_simple_destroy, and p64_system are essentially all chains\nachieved with our leak and packing capabilities.\n\n\n-----\n\nFor example, p64_simple_create is constructed as:\n\n[As these chains get pretty complex, pretty fast, and are quite repetitive, we created QOP.py.](https://github.com/CheckPointSW/QueryOrientedProgramming/)\n\nQOP.py makes things a bit simpler by generating these queries in pwntools style.\n\nCreating the previous statements becomes as easy as:\n\n\n-----\n\n## Demo\n\nhttps://youtu.be/cPfYoxLOi1M\n\n### COMMIT;\n\n\nWatch Video At:\n\n\nNow that we have established a framework to exploit any situation where the querier cannot\nbe sure that the database is non-malicious, let‚Äôs explore another interesting use case for\nSQLite exploitation.\n\n## iOS Persistency\n\nPersistency is hard to achieve on iOS as all executable files must be signed as part of\nApple‚Äôs Secure Boot. Luckily for us, SQLite databases are not signed.\n\nUtilizing our new capabilities, we will replace one of the commonly used databases with a\nmalicious version. After the device reboots and our malicious database is queried, we gain\ncode execution.\n\n\n-----\n\nTo demonstrate this concept, we replace the Contacts DB AddressBook.sqlitedb . As done\nin our PHP7 exploit, we create two extra DDL statements. One DDL statement overrides the\ndefault tokenizer ‚Äúsimple‚Äù, and the other DDL statement triggers the crash by trying to\ninstantiate the overridden tokenizer. Now, all we have to do is re-write every table of the\noriginal database as a view that hijacks any query performed and redirect it toward our\nmalicious DDL.\n\nReplacing the contacts db with our malicious contacts db and rebooting results in the\nfollowing iOS crashdump:\n\nAs expected, the contacts process crashed at 0x4141414141414149 where it expected to\nfind the xCreate constructor of our false tokenizer.\n\n\n-----\n\nFurthermore, the contacts db is actually shared among many processes. Contacts,\nFacetime, Springboard, WhatsApp, Telegram and XPCProxy are just some of the processes\nquerying it. Some of these processes are more privileged than others. Once we proved that\nwe can execute code in the context of the querying process, this technique also allows us to\nexpand and elevate our privileges.\n\nOur research and methodology have all been responsibly disclosed to Apple and were\nassigned the following CVEs:\n\nCVE-2019-8600\nCVE-2019-8598\nCVE-2019-8602\nCVE-2019-8577\n\n## Future Work\n\nGiven the fact that SQLite is practically built-in to almost any platform, we think that we‚Äôve\nbarely scratched the tip of the iceberg when it comes to its exploitation potential. We hope\nthat the security community will take this innovative research and the tools released and\npush it even further. A couple of options we think might be interesting to pursue are\n\nCreating more versatile exploits. This can be done by building exploits dynamically by\nchoosing the relevant QOP gadgets from pre-made tables using functions such as\n[sqlite_version() or](https://www.sqlite.org/lang_corefunc.html#sqlite_version) [sqlite_compileoption_used().](https://www.sqlite.org/lang_corefunc.html#sqlite_compileoption_used)\nAchieving stronger exploitation primitives such as arbitrary R/W.\nLook for other scenarios where the querier cannot verify the database trustworthiness.\n\n## Conclusion\n\nWe established that simply querying a database may not be as safe as you expect. Using\nour innovative techniques of Query Hijacking and Query Oriented Programming, we proved\nthat memory corruption issues in SQLite can now be reliably exploited. As our permissions\nhierarchies become more segmented than ever, it is clear that we must rethink the\nboundaries of trusted/untrusted SQL input. To demonstrate these concepts, we achieved\nremote code execution on a password stealer backend running PHP7 and gained\npersistency with higher privileges on iOS. We believe that these are just a couple of use\ncases in the endless landscape of SQLite.\n\nCheck Point IPS Product Protects against this threat: ‚ÄúSQLite fts3_tokenizer Untrusted\nPointer Remote Code Execution (CVE-2019-8602).‚Äù\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-10 - SELECT code_execution FROM  USING SQLite;.pdf"
    ],
    "report_names": [
        "2019-08-10 - SELECT code_execution FROM  USING SQLite;.pdf"
    ],
    "threat_actors": [
        {
            "id": "1dadf04e-d725-426f-9f6c-08c5be7da159",
            "created_at": "2022-10-25T15:50:23.624538Z",
            "updated_at": "2025-03-27T02:00:55.508759Z",
            "deleted_at": null,
            "main_name": "Darkhotel",
            "aliases": [
                "Darkhotel",
                "DUBNIUM",
                "Zigzag Hail"
            ],
            "source_name": "MITRE:Darkhotel",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2b4eec94-7672-4bee-acb2-b857d0d26d12",
            "created_at": "2023-01-06T13:46:38.272109Z",
            "updated_at": "2025-03-27T02:00:02.790029Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "DUBNIUM",
                "Fallout Team",
                "Luder",
                "Tapaoux",
                "Shadow Crane",
                "APT-C-06",
                "SIG25",
                "Karba",
                "Nemim",
                "Nemin",
                "G0012",
                "ATK52",
                "T-APT-02",
                "TUNGSTEN BRIDGE",
                "Zigzag Hail"
            ],
            "source_name": "MISPGALAXY:DarkHotel",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535576,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1653704178,
    "ts_modification_date": 1653704178,
    "files": {
        "pdf": "https://archive.orkl.eu/78ae731f1cdcd4d989b016dbb33763fe551f0e9b.pdf",
        "text": "https://archive.orkl.eu/78ae731f1cdcd4d989b016dbb33763fe551f0e9b.txt",
        "img": "https://archive.orkl.eu/78ae731f1cdcd4d989b016dbb33763fe551f0e9b.jpg"
    }
}