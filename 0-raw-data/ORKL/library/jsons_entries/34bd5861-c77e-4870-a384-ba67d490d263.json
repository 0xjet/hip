{
    "id": "34bd5861-c77e-4870-a384-ba67d490d263",
    "created_at": "2023-01-12T15:01:03.739044Z",
    "updated_at": "2025-03-27T02:08:40.35115Z",
    "deleted_at": null,
    "sha1_hash": "c584e4805eb10b6242c1f79ded7300281245e74b",
    "title": "2021-09-16 - Analysis of CVE-2021-30860 the flaw and fix of a zero-click vulnerability, exploited in the wild",
    "authors": "",
    "file_creation_date": "2022-05-28T15:49:51Z",
    "file_modification_date": "2022-05-28T15:49:51Z",
    "file_size": 1057585,
    "plain_text": "# The Patch\n\n**objective-see.com/blog/blog_0x67.html**\n\nAnalysis of CVE-2021-30860\n\nthe flaw and fix of a zero-click vulnerability, exploited in the wild\n\nby: Tom McGuire / September 16, 2021\n\nThis guest blog post, was written by Tom McGuire, a senior instructor and cybersecurity\nfocus area coordinator at Johns Hopkins and tech editor of my upcoming The Art of Mac\nMalware: Analysis book.\n\nHere, he shares his analysis of reversing Apple's patch for CVE-2021-30860 (a zero-click\niOS/macOS vulnerability exploited in the wild) ...highlighting both the underlying flaw, and\nApple's fix.\n\nMahalo for sharing Tom! ü§©\n\n‚Ñπ For another write-up on this bug, see Mickey Jin's excellent post:\n\n[\"Analyzing The ForcedEntry Zero-Click iPhone Exploit Used By Pegasus.\"](https://www.trendmicro.com/en_us/research/21/i/analyzing-pegasus-spywares-zero-click-iphone-exploit-forcedentry.html)\n\n## Wild, wild west - Quick Initial Analysis of CVE-2021-30860\n\n[Recently, Apple released iOS/iPadOS 14.8 and](https://support.apple.com/en-us/HT212807) [macOS Big Sur 11.6 which fixes both an](https://support.apple.com/en-us/HT212804)\n[integer overflow and a use after free vulnerability (the watchOS platform was also patched to](https://support.apple.com/en-us/HT212806)\nfix the integer overflow issue). This blog post will analyze the integer overflow in\nCoreGraphics, `CVE-2021-30860 . After examining the modified .dylib, it appears that there`\nwere other issues that were resolved as well, related to imaging processing. We will focus in\non the `JBIG2 processing, specifically in the` `JBIG2::readTextRegionSeg .`\n\nI could not find information about Apple‚Äôs use of `JBIG2 libraries. However, as we will see`\nthere is a likely chance there was some collaboration with open source software (see:\n[https://gitlab.freedesktop.org/poppler/poppler/-/blob/master/poppler/JBIG2Stream.cc). The](https://gitlab.freedesktop.org/poppler/poppler/-/blob/master/poppler/JBIG2Stream.cc)\nsource code shown is from poppler, but as shown in the header file the origin is ‚ÄúCopyright\n2002-2003 Glyph & Cog, LLC‚Äù.\n\n\n-----\n\nAn integer overflow can lead to a variety of issues. A common result with an integer overflow\nis to cause a dynamic memory allocation (e.g. malloc(), calloc() etc..) to be too small. Later,\ndata is copied from a source that is larger than the allocated size, resulting in a heap buffer\noverflow. (Not all integer overflows will manifest this way, but it is a common occurrence and\nrelevant to this discussion.)\n```\nCVE-2021-30860 is an integer overflow in the CoreGraphics component, specifically the\n\n```\ndecoding of a `JBIG2 data.` `JBIG2 (Joint Bi-level Image Experts Group) is an image`\ncompression format which can be embedded as a stream in a PDF or PSD document, or\n[potentially other formats as well. You can read more about it here.](https://en.wikipedia.org/wiki/JBIG2)\n\nBefore we dive into the assembly and uncover the vulnerability and how it was fixed, we\n[want to look at the discovery. CitizenLab reported this vulnerability, which they dubbed](https://citizenlab.ca/2021/09/forcedentry-nso-group-imessage-zero-click-exploit-captured-in-the-wild/)\nFORCEDENTRY (a knock at Apple‚Äôs recent security component, BlastDoor!), to Apple after\nthey had done some analysis on journalist‚Äôs phones suspected of being hacked. In their\nreporting, CitizenLab attributes the attacks to the NSO group, due to the Pegasus software\nthat was seen on these infected devices:\n\nCitizenLab thoughts on Pegaus\nDuring their analysis, they uncovered crash logs and noticed quite a few image files that\nseemed to crash the `IMTranscoderAgent .` `IMTranscoderAgent is one of the`\ncomponents related to processing of iMessage data, including upon sending/receiving\nimages!\n\nAccording to CitizenLab, they reported the vulnerability to Apple on Tuesday, September 7,\n2021 and Apple confirmed and released the patches for the issue on Monday, September\n13, 2021. That is a quick turnaround, so let‚Äôs see how well they did with the patching!\n\nImage file formats are notorious for having vulnerabilities that can lead to arbitrary remote\ncode execution (RCE) on devices (CVE-2009-1858, CVE-2015-6778, CVE-2020-1910, etc..).\n\n\n-----\n\nImaging parsing issues are not new!\nIt is not surprising that such an issue existed here. With this `JBIG2 processing vulnerability`\n(which exists in the `readTextRegionSeg method), I will note that another very similar`\nvulnerability was previously patched. This issue is nearly the same logic as the one in\nFORCEDENTRY. The method `readSymbolDictSeg contains integer overflow checks that`\nhelp prevent the scenario that we will examine in this post! (Don‚Äôt worry, we will get back to\nthis and do a quick look to see this in assembly).\n\nOf particular note to the attacks reported by CitizenLab, the file formats were PDF files, with\nembedded `JBIG2 streams. Zero-click iMessage vulnerabilities have existed before (see,`\n[here and](https://citizenlab.ca/2020/12/the-great-ipwn-journalists-hacked-with-suspected-nso-group-imessage-zero-click-exploit/) [here).](https://blog.zecops.com/research/the-recent-ios-0-click-cve-2021-30860-sounds-familiar-an-unreleased-write-up-one-year-later/)\n\nIn an effort to help reduce this attack surface, Apple recently (iOS14) introduced the\n[‚ÄúBlastDoor‚Äù feature. Samuel Gro√ü, of Google‚Äôs Project 0, posted an excellent write-up about](https://googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html)\nthis new feature:\n\n\n-----\n\nBlastDoor analysis by Google P0\nFor our purposes, what we need to understand is that the BlastDoor feature is meant to\n‚Äúsandbox‚Äù processing in the iMessage chain. In other words, when an image or document is\nreceived via iMessage and automatically parsed, it is done in a sandboxed environment. The\nintent is that, if a vulnerability exists in some of the processing engine, the exploitation will be\nlimited to this sandboxed environment, keeping the rest of the system ‚Äòsafe‚Äô. This is true for\ncertain file formats, but it appears that Apple did not sandbox all potential automatically\nparsed formats (looking at you PSD files, and likely other raster formats).\n\nThough I have not gone through and analyzed any changes to BlastDoor since this patch, I\ncan only hope that Apple has increased the robustness of BlastDoor and has prevented PDF,\nPSD and other raster file format parsing from going through the `IMTranscoderAgent . That`\nis, going forward, the hope is these other notoriously prone formats are processed in the\nBlastDoor sandboxed environment‚Ä¶perhaps we can look at that in a future blog post!\n\nWith the background out of the way, let‚Äôs get to reversing and find out what happened and\nhow it was fixed!\n\nIn order to examine this, we first need to grab a vulnerable version of the `.dylib (we will`\nbe using macOS 11.5.2) and a fixed version (macOS 11.6). I had Hopper and IDA for\nanalysis as well, so for the sake of time, I utilized them both. First, we need to grab the\n\n\n-----\n\n```\nCoreGraphics.dylib from the two systems. At first, I was looking in the usual spot\n\n```\n( /System/Library/Frameworks/CoreGraphics ) and quickly noticed this was not the\ncorrect library. It turns out that on recent versions of macOS, many of the core frameworks\nare located in the dyld cache! This is a very large file, but is located in\n```\n/System/Library/dyld/dyld_shared_cache_x86_64 . (I‚Äôm using the x86_64 version).\n\n```\ndyld cache from the respective folders\n\nArmed with the knowledge of where the dyld cache is located, we need to extract the\n```\nCoreGraphics.dylib from it. One of the simplest ways is to use the Hopper disassembler.\n\n```\nOpening the `dyld_shared_cache_x86_64 file in Hopper presents you with myriad of`\nFrameworks to examine. Of course, we will filter on the ‚ÄúCoreGraphics‚Äù one to open it up.\n\nHopper opening dyld_cache\nFrom here, I was most interested in learning the differences between the 11.5.2 version and\nthe 11.6 version. At this point, I decided to use Hopper to output the `CoreGraphics.dylib`\nto its own dedicated Mach-O file. To do this, we can use the ‚ÄúFile->Produce New Executable‚Äù\n(or `cmd+shift+e ). Doing this for both the 11.5.2` `dyld_cache and the 11.6` `dyld_cache`\nyields us the two `CoreGraphics.dylib that we can easily analyze.`\n\n\n-----\n\nHopper producing\n\nnew executable\nIn order to diff these quickly, I decided to utilize IDA and BinDiff (we certainly can use other\ntools as well). So let‚Äôs open both `CoreGraphics-11_5_2.dylib and` `CoreGraphics-`\n```\n11_6.dylib in IDA, saving the corresponding .i64 files. After closing both databases, I\n\n```\nre-opened the `CoreGraphics-11_5_2.dylib and launched BinDiff ( ctrl + 6 ). After`\nchoosing ‚ÄúDiff Database‚Ä¶‚Äù and selecting the `CoreGraphics-11_6.i64 database, we wait`\nfor BinDiff to do its magic! It‚Äôs not that bad actually. If you‚Äôve not used BinDiff, the matching\nfunctions is quite useful. It also gives a guide for what has changed within a function. The\n[BinDiff manual, from Zynamics site, gives a good description of the ‚ÄúMatched Functions](https://www.zynamics.com/bindiff/manual/)\nSubview‚Äù and explains the ‚Äúchange‚Äù column.\n\nBinDiff\n\n\n-----\n\nOpen BinDiff from the 11.5.2 version (primary) and use the `.i64 db for the 11.6 version`\n(secondary)\n\nWe notice that there are 10 functions that have changed. It turns out that there was an API\nchange or parameter size change to one of them (one of the parameters was removed), thus\n4 of these functions aren‚Äôt as ‚Äúdifferent‚Äù as they first appear. In Figure 8 below, the left most\ncolumn is the similarity. 1.00 is identical* while lower values are less similar. We notice that\nthere are a few entries with 0.99 similarity. These functions are mostly similar up to variance\nof some number of Instructions (I). The 0.92 similar function is the one of interest to us\n(some of the other functions are also worth examining‚Ä¶perhaps for another blogpost!). The\n‚ÄúG‚Äù, in the 3rd column (change) indicates there is a graph change (number of basic blocks or\nnumber of edges differ). There are also differences in the branch inversion, indicated by the\n‚ÄúJ‚Äù. The ‚ÄúL‚Äù indicates the number of loops has changed. The graph structure is an important\nchange to look at, as this could indicate a new branch condition was added or altered!\n\nShowing the differences to focus our analysis!\nFor this post, the most interesting function related to the `JBIG2 processing that differs`\nbetween the 2 versions is located at: `00007FFF252466E0 (11.5.2 version) and`\n```\n00007FFF25247710 (11.6 version) (In Figure 8, this is the readTextRegionSeg_0 named\n\n```\nroutine).\n\nThis is the `JBIG2::readTextRegionSeg function. As you can see, I didn‚Äôt have symbols`\nwhen doing this, however, I did notice some interesting strings present in the\n```\nCoreGraphics.dylib, which turned out to be very useful in piecing together the code\n\n```\npaths (obviously symbols would greatly help here, but even without them, we can identify the\nroot cause‚Ä¶with a little help from open source software!)\n\n[Utilizing the strings located in the dylib, and the source code for a](https://gitlab.freedesktop.org/poppler/poppler/-/blob/master/poppler/JBIG2Stream.cc) `JBIG2Stream`\n```\nprocessor, we can match up some of the code!\n\n```\nUsing source code as a guide, we can look at the issue in source and then match it to the\ndisassembled version confirming the existence of the vulnerability in the 11.5.2 version.\n\nAs we can see below, the numSyms variable (an unsigned 32-bit integer), is incremented by\nthe size of the currently processed segment. Thus, if there is more than one\n```\njbig2SegSymbolDict segment, numSyms will be updated with the size of that segment.\n\n```\nThis can lead to an integer overflow as there is no checking surrounding this area.\n\n\n-----\n\n```\n 1966  // get symbol dictionaries and tables\n 1967  numSyms = 0;\n 1968  for (i = 0; i < nRefSegs; ++i) {\n 1969   if ((seg = findSegment(refSegs[i]))) {\n 1970     if (seg->getType() == jbig2SegSymbolDict) {\n 1971         numSyms += ((JBIG2SymbolDict *)seg)->getSize();\n 1972     } else if (seg->getType() == jbig2SegCodeTable) {\n 1973         codeTables.push_back(seg);\n 1974     }\n 1975   } else {\n 1976     error(errSyntaxError, curStr->getPos(), \n          \"Invalid segment reference in JBIG2 text region\");\n 1977     return;\n 1978   }\n 1979  } \n\n```\nAs you can see from the disassembly below from the vulnerable version (11.5.2), the `add`\n```\neax, [rbx+0ch] (which is a 32-bit calculation), has no checking to ensure this hasn‚Äôt\n\n```\nwrapped. Thus, we have an integer overflow in which `numSyms could wrap around.`\n```\n__text:00007FFF25246A56 nRefSegs_loop:            \n__text:00007FFF25246A56         mov   esi, [r13+r12*4+0]\n__text:00007FFF25246A5B         mov   rdi, r14\n__text:00007FFF25246A5E         call  findSegment\n__text:00007FFF25246A63         test  rax, rax\n__text:00007FFF25246A66         jz   loc_7FFF25246CDD\n__text:00007FFF25246A6C         mov   rbx, rax\n__text:00007FFF25246A6F         mov   rax, [rax]\n__text:00007FFF25246A72         mov   rdi, rbx\n__text:00007FFF25246A75         call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25246A78         cmp   eax, 1        ;\njbig2SegSymbolDict\n__text:00007FFF25246A7B         jnz   short loc_7FFF25246A8E\n__text:00007FFF25246A7D         mov   eax, dword ptr [rbp+numSyms]\n__text:00007FFF25246A83         add   eax, [rbx+0Ch]    ; numSyms +=\ngetSize()\n__text:00007FFF25246A83                        ; no overflow\ncheck here!\n__text:00007FFF25246A86         mov   dword ptr [rbp+numSyms], eax\n__text:00007FFF25246A8C         jmp   short loc_7FFF25246AA7\n__text:00007FFF25246A8E ; ------------------------------------------------------------__text:00007FFF25246A8E\n__text:00007FFF25246A8E loc_7FFF25246A8E:            \n__text:00007FFF25246A8E         mov   rax, [rbx]\n__text:00007FFF25246A91         mov   rdi, rbx\n__text:00007FFF25246A94         call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25246A97         cmp   eax, 3        ;\njbig2SegCodeTable\n__text:00007FFF25246A9A         jnz   short loc_7FFF25246AA7\n__text:00007FFF25246A9C         mov   rdi, r15\n__text:00007FFF25246A9F         mov   rsi, rbx\n__text:00007FFF25246AA2         call  push_back\n\n```\n\n-----\n\nAs we noted earlier, an integer overflow is often paired with 1 or more other mistakes. For\nexample, it is used in an allocation routine to allocate dynamic memory. That is exactly the\ncase here!\n\nIn the assembly below, we can see the `numSyms being moved into` `EDI (prepping for the`\nfirst argument to `gmallocn ). The` `numSyms value is controlled by the attacker. For`\nexample, we could have one segment be `0xFFFFFFFF and the other be 2. We could also`\nuse `0x80000000 and` `0x80000001 . The goal, of course, is to get` `numSyms to be a small`\nnumber so the allocator, `gmallocn, will create a small allocation.`\n```\n__text:00007FFF25246AC1         mov   edi, dword ptr [rbp+numSyms]\n__text:00007FFF25246AC7         cmp   edi, 2\n__text:00007FFF25246ACA         jb   short loc_7FFF25246ADB\n__text:00007FFF25246ACC         xor   ecx, ecx\n__text:00007FFF25246ACE         mov   eax, 1\n__text:00007FFF25246AD3\n__text:00007FFF25246AD3 loc_7FFF25246AD3:            \n__text:00007FFF25246AD3         inc   ecx\n__text:00007FFF25246AD5         add   eax, eax\n__text:00007FFF25246AD7         cmp   eax, edi\n__text:00007FFF25246AD9         jb   short loc_7FFF25246AD3\n__text:00007FFF25246ADB\n__text:00007FFF25246ADB loc_7FFF25246ADB:            \n__text:00007FFF25246ADB         mov   [rbp+var_2C4], ecx\n__text:00007FFF25246AE1         mov   esi, 8\n__text:00007FFF25246AE6         call  gmallocn\n__text:00007FFF25246AEB         mov   r8, rax\n__text:00007FFF25246AEE         xor   ebx, ebx\n\n```\nIf we assume the `numSyms was 1 following the overflow,` `gmallocn will allocate an 8-byte`\nregion for this. But where does this small allocation get used? And can we get more data to\nbe copied into this buffer than was allocated?\n\nLuckily we don‚Äôt have far to go to see where there is an issue! First, we will look at the\nsource code. We notice that this loop has similar processing to the vulnerable overflow one.\nIn particular, it processes the `jbig2SegSymbolDict segment. In this code path, we can see`\nthat the `getSize method is called again and the bounds of the loop are tied to this. Since`\n```\ngetSize returns an unsigned int (and k is already an unsigned int), this comparison is\n\n```\nunsigned. Thus, even if `getSize is` `0x80000000, this portion will execute.`\n\nAs you can see on line 2004, the `syms variable receives the bitmap. This` `syms was the`\nresult of the `gmallocn allocation. Recall that only 8-bytes were allocated, in our example.`\nBut the `getSize could be much larger, resulting in a heap buffer overflow!`\n\n\n-----\n\n```\n 1998   kk 0;\n 1999   for (i = 0; i < nRefSegs; ++i) {\n 2000     if ((seg = findSegment(refSegs[i]))) {\n 2001       if (seg->getType() == jbig2SegSymbolDict) {\n 2002         symbolDict = (JBIG2SymbolDict *)seg;\n 2003         for (k = 0; k < symbolDict->getSize(); ++k) {\n 2004           syms[kk++] = symbolDict->getBitmap(k); <-- overflow!\n 2005         }\n 2006       }\n 2007     }\n 2008   }\n 2009 \n\n```\nLet‚Äôs confirm the existence of this in the 11.5.2 code as well. From the code below, we can\nsee that the `getBitmap_copyloop is unbounded! Thus, a heap buffer overflow exists!`\n```\n__text:00007FFF25246AF0\n__text:00007FFF25246AF0 loc_7FFF25246AF0:           \n__text:00007FFF25246AF0         mov   r15, r8\n__text:00007FFF25246AF3         mov   esi, [r13+rbx*4+0]\n__text:00007FFF25246AF8         mov   rdi, r14\n__text:00007FFF25246AFB         call  findSegment\n__text:00007FFF25246B00         test  rax, rax\n__text:00007FFF25246B03         jz   short loc_7FFF25246B53\n__text:00007FFF25246B05         mov   r12, rax\n__text:00007FFF25246B08         mov   rax, [rax]\n__text:00007FFF25246B0B         mov   rdi, r12\n__text:00007FFF25246B0E         call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25246B11         cmp   eax, 1         ;\njbig2SegSymbolDict\n__text:00007FFF25246B14         jnz   short loc_7FFF25246B53\n__text:00007FFF25246B16         mov   eax, [r12+0Ch]     ; getSize()\n__text:00007FFF25246B1B         test  rax, rax\n__text:00007FFF25246B1E         mov   r8, r15\n__text:00007FFF25246B21         jz   short loc_7FFF25246B56\n__text:00007FFF25246B23         mov   r9, [rbp+var_2C0]\n__text:00007FFF25246B2A         mov   edx, r9d\n__text:00007FFF25246B2D         xor   ecx, ecx\n__text:00007FFF25246B2F\n__text:00007FFF25246B2F getBitmap_copyloop:           \n__text:00007FFF25246B2F         lea   esi, [rdx+rcx]\n__text:00007FFF25246B32         mov   rdi, [r12+10h]\n__text:00007FFF25246B37         mov   rdi, [rdi+rcx*8]\n__text:00007FFF25246B3B         mov   [r8+rsi*8], rdi  ; leads to a heap\noverflow\n__text:00007FFF25246B3F         inc   rcx\n__text:00007FFF25246B42         cmp   rax, rcx\n__text:00007FFF25246B45         jnz   short getBitmap_copyloop\n\n```\nUnfortunately, I did not have a sample to examine, so I could not confirm how the specific\nsample that CitizenLab had performed the attack.\n\n\n-----\n\nIn order to examine the fix, we need to look at the 11.6 version of the\n```\nCoreGraphics.dylib . I would‚Äôve expected to see an integer overflow check in the\n\n```\ncalculation of `numSyms in the first loop. However, that is not the case. Below is the 11.6`\nversion of the processing loop which is identical to 11.5.2! Maybe Apple will send out a\nproper fix soon :-)\n```\n__text:00007FFF25247A79 nRefSegs_loop:             \n__text:00007FFF25247A79         mov   esi, [r12+r14*4]\n__text:00007FFF25247A7D         mov   rdi, r13\n__text:00007FFF25247A80         call  findSegment\n__text:00007FFF25247A85         test  rax, rax\n__text:00007FFF25247A88         jz   loc_7FFF25247D1D\n__text:00007FFF25247A8E         mov   rbx, rax\n__text:00007FFF25247A91         mov   rax, [rax]\n__text:00007FFF25247A94         mov   rdi, rbx\n__text:00007FFF25247A97         call  qword ptr [rax+10h] ; getType()\n__text:00007FFF25247A9A         cmp   eax, 1        ;\njbig2SegSymbolDict\n__text:00007FFF25247A9D         jnz   short loc_7FFF25247AB0\n__text:00007FFF25247A9F         mov   eax, [rbp+numSyms]\n__text:00007FFF25247AA5         add   eax, [rbx+0Ch]    ; numSysm +=\ngetSize()\n__text:00007FFF25247AA5                       ; still no\noverflow check!\n__text:00007FFF25247AA5                       ; even in\npatched/11.6!\n__text:00007FFF25247AA8         mov   [rbp+numSyms], eax\n__text:00007FFF25247AAE         jmp   short loc_7FFF25247ACD\n__text:00007FFF25247AB0 ; ------------------------------------------------------------__text:00007FFF25247AB0\n__text:00007FFF25247AB0 loc_7FFF25247AB0:            \n__text:00007FFF25247AB0         mov   rax, [rbx]\n__text:00007FFF25247AB3         mov   rdi, rbx\n__text:00007FFF25247AB6         call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25247AB9         cmp   eax, 3        ;\njbig2SegSodeTable\n__text:00007FFF25247ABC         jnz   short loc_7FFF25247ACD\n__text:00007FFF25247ABE         mov   rdi, [rbp+var_2F0]\n__text:00007FFF25247AC5         mov   rsi, rbx\n__text:00007FFF25247AC8         call  push_back\n\n```\nHrmm‚Ä¶not quite what I was expecting to see, but that‚Äôs OK..there are other changes in this\nfunction. Recall that we noted that the integer overflow itself doesn‚Äôt always lead to an issue,\nbut it is usually paired with 1 or more other conditions. In this case, there are 2 other\nconditions that lead to the exploitable case. First, as we saw, the small `numSyms value is`\nused to allocate a memory region. With a small allocated buffer and the second issue of the\ncopy loop using the larger values for its bounds (i.e. `getSize ), we have a recipe for the`\nheap buffer overflow!\n\n\n-----\n\nBased on that, and so far the fact that neither the `numSyms calculation, nor the` `gmallocn`\narea were changed, we can hope that this is fixed in the copy loop! And this is exactly what\nhappened.\n\nWe can see below that we only go into the `getBitmap_copyloop for the` `numSyms times.`\nBut this is only half of the problem. Since `getBitmap is called in a loop, they also need to`\nmake sure that they stop the loop early there as well!\n\nYou can see that change in the `getBitmap_copyloop, where they are now checking not`\nonly against the size of the segment (seen at `00007FFF25247B6B ), but they are also`\nchecking to ensure that the data copied to that point won‚Äôt exceed the allocated buffer size\n(seen at `00007FFF25247B5B and` `00007FFF25247B7F )`\n\n\n-----\n\n```\n__text:00007FFF25247B23 loc_7FFF25247B23:            \n__text:00007FFF25247B23   mov   esi, [r12+r14*4]\n__text:00007FFF25247B27   mov   rdi, r13\n__text:00007FFF25247B2A   call  findSegment\n__text:00007FFF25247B2F   test  rax, rax\n__text:00007FFF25247B32   jz   short loc_7FFF25247B87\n__text:00007FFF25247B34   mov   rbx, rax\n__text:00007FFF25247B37   mov   rax, [rax]\n__text:00007FFF25247B3A   mov   rdi, rbx\n__text:00007FFF25247B3D   call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25247B40   cmp   eax, 1         ; jbig2SegSymbolDict\n__text:00007FFF25247B43   jnz   short loc_7FFF25247B87\n__text:00007FFF25247B45   cmp   r15d, [rbp+numSyms]  ; new check to make sure\nwe aren't\n__text:00007FFF25247B45                  ; going beyond the number\nof symbols\n__text:00007FFF25247B45                  ;\n__text:00007FFF25247B45                  ; r15 is the 'counter' for\nthat\n__text:00007FFF25247B45                  ; originally set to 0\n__text:00007FFF25247B4C   jnb   short loc_7FFF25247B87\n__text:00007FFF25247B4E   mov   ecx, [rbx+0Ch]     ; effectively ecx =\ngetSize();\n__text:00007FFF25247B51   mov   r15d, r15d\n__text:00007FFF25247B54   mov   rdx, [rbp+orig_numSyms]\n__text:00007FFF25247B5B   sub   rdx, r15        ; keep track of symbols\ncopied\n__text:00007FFF25247B5E   mov   rax, [rbp+var_318]\n__text:00007FFF25247B65   lea   rsi, [rax+r15*8]\n__text:00007FFF25247B69   xor   eax, eax        ; copy loop counter\n__text:00007FFF25247B6B\n__text:00007FFF25247B6B getBitmap_copyloop:           \n__text:00007FFF25247B6B   cmp   rcx, rax        ; normal getSize() check \n__text:00007FFF25247B6E   jz   short loc_7FFF25247B84\n__text:00007FFF25247B70   mov   rdi, [rbx+10h]\n__text:00007FFF25247B74   mov   rdi, [rdi+rax*8]\n__text:00007FFF25247B78   mov   [rsi+rax*8], rdi\n__text:00007FFF25247B7C   inc   rax\n__text:00007FFF25247B7F   cmp   rdx, rax       ; this check ensures they\nwon't write\n__text:00007FFF25247B7F                  ; out of bounds in the\ncopy loop!\n__text:00007FFF25247B82   jnz   short getBitmap_copyloop\n__text:00007FFF25247B84\n__text:00007FFF25247B84 loc_7FFF25247B84:            \n__text:00007FFF25247B84   add   r15d, eax\n__text:00007FFF25247B87\n__text:00007FFF25247B87 loc_7FFF25247B87:          \n__text:00007FFF25247B87   inc   r14\n__text:00007FFF25247B8A   cmp   r14, [rbp+nRefSegs]\n__text:00007FFF25247B91   jnz   short loc_7FFF25247B23\n\n```\n\n-----\n\nThis was certainly not the expected patch path when I first recognized the vulnerability. I\nwould‚Äôve thought the overflow would‚Äôve been fixed at the point of calculation of numSyms.\nThere may be a reason this is not the case. Perhaps that they still want the processing to\noccur even in the case of some ‚Äòmalformed‚Äô PDFs for whatever reason. Who knows!\n```\nreadSymbolDictSeg and Differences in the Patch\n\n```\nAs we alluded to earlier, another method has a very similar processing loop, but it was\nactually protected from the integer overflow before this release! In fact, the fix in this code\nchecks for the integer overflow when calculating the number of symbols!\n\nUsing our `JBIG2 source code as an example, we can see the following processing. On`\nlines 1536-1539, we see the integer overflow check to ensure that when the statement on\nline 1540 is executed, it won‚Äôt overflow!\n\nIn addition, they are checking to ensure the number of new symbols hasn‚Äôt exceeded the\nbounds (lines 1548-1549)\n```\n 1527   // get referenced segments: input symbol dictionaries and code tables\n 1528   numInputSyms = 0;\n 1529   for (i = 0; i < nRefSegs; ++i) {\n 1530     // This is need by bug 12014, returning false makes it not crash\n 1531     // but we end up with a empty page while acroread is able to render\n 1532     // part of it\n 1533     if ((seg = findSegment(refSegs[i]))) {\n 1534       if (seg->getType() == jbig2SegSymbolDict) {\n 1535         j = ((JBIG2SymbolDict *)seg)->getSize();\n 1536         if (numInputSyms > UINT_MAX - j) {\n 1537           error(errSyntaxError, curStr->getPos(), \n                \"Too many input symbols in JBIG2 symbol dictionary\");\n 1538           goto eofError;\n 1539         }\n 1540         numInputSyms += j;\n 1541       } else if (seg->getType() == jbig2SegCodeTable) {\n 1542         codeTables.push_back(seg);\n 1543       }\n 1544     } else {\n 1545       return false;\n 1546     }\n 1547   }\n 1548   if (numInputSyms > UINT_MAX - numNewSyms) {\n 1549     error(errSyntaxError, curStr->getPos(), \n          \"Too many input symbols in JBIG2 symbol dictionary\");\n 1550     goto eofError;\n 1551   }\n\n```\nIn the assembly from 11.5.2, we can see the overflow check at addresses\n```\n00007FFF2524576D - 00007FFF25245774, with the branch at 00007FFF25245774 going\n\n```\ndown the error path:\n\n\n-----\n\n```\n__text:00007FFF25245748 loc_7FFF25245748:            \n__text:00007FFF25245748         mov   rax, [rbp+var_68]\n__text:00007FFF2524574C         mov   esi, [rax+rbx*4]\n__text:00007FFF2524574F         mov   rdi, r14\n__text:00007FFF25245752         call  findSegment\n__text:00007FFF25245757         test  rax, rax\n__text:00007FFF2524575A         jz   short loc_7FFF25245791\n__text:00007FFF2524575C         mov   r12, rax\n__text:00007FFF2524575F         mov   rax, [rax]\n__text:00007FFF25245762         mov   rdi, r12\n__text:00007FFF25245765         call  qword ptr [rax+10h]  ; getType()\n__text:00007FFF25245768         cmp   eax, 1         ;\njbig2SegSymbolDict\n__text:00007FFF2524576B         jnz   short loc_7FFF25245776\n__text:00007FFF2524576D         add   r13d, [r12+0Ch]\n__text:00007FFF25245772         jnb   short loc_7FFF25245791 ; integer\noverflow check\n__text:00007FFF25245774         jmp   short integer_overflow\n\n```\nAs you can see, this overflow check was done during the calculation of the number of\nsymbols. This is due to the `jnb instruction. The add instruction will perform both signed`\nand unsigned operation and adjust the `Overflow Flag ( OF ) and/or` `Carry Flag ( CF )`\nfor signed and unsigned respectively. The `jnb instruction (a pseudonym for` `jnc )`\nindicates to jump if the carry flag is 0 (i.e. no integer wrapping occurred). In this case, this is\nthe ‚Äògood‚Äô path, whereas if the `CF was set, this would indicate an integer wrapping and the`\ncorresponding error path is taken!\n\nOn the other hand, the `readTextRegionSeg method, the` `numSyms can still overflow,`\nhowever, in the processing loop when the `getBitmp method is copying to the allocated`\nregion, there is a check to ensure that this data is not overflowed.\n\nBased on the analysis and the abundance of common strings, it seems that Apple is likely\nusing an opensource version of the `JBIG2 processing, and making their own modifications.`\n(Admittedly, I did search for their notes on this, but didn‚Äôt find it‚Ä¶if anyone confirms that they\nare using that would be awesome). It does seem that a different developer implemented the\nfix in `CVE-2021-30860 than the one found in the` `readSymbolDictSeg method.`\n\n## Concluding Thoughts\n\nThere were other functions that were patched as well. For example, in the 11.6 version, it is\nworth analyzing the functions at address `00007FFF24EF2684 and` `00007FFF250F6301 .`\nPerhaps for another blog post‚Ä¶\n\nAs we noted, this vulnerability is (well prior to the patch) exploitable through a crafted\niMessage without any user-interaction. In other words, a specially crafted PDF file could be\nsent to an iMessage recipient, and the victim‚Äôs `IMTranscoderAgent begins processing the`\n\n\n-----\n\nmalicious payload outside of the BlastDoor sandbox. As noted in the beginning of this post,\nhopefully Apple will also update BlastDoor and prevent these dangerous file formats from\nbeing processed outside the Sandbox environment!\n\nApple‚Äôs iDevices have gotten more secure especially from allowing their system to be\nmodified upon reboot. Thus, a good practice for iOS users is to a) update when updates are\navailable and b) reboot the phone every so often! Of course this won‚Äôt stop these 0day\n[attacks, but it is at least a good security practice. It would be worth downloading iVerify to](https://www.iverify.io/)\nhelp test for common infections as well as for recommendations to increase the security\nposture of your device!\n\niVerify\n\n## Part 0x2\n\n‚Ä¶stay tuned! üßê\n\nThis website uses cookies to improve your experience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-16 - Analysis of CVE-2021-30860 the flaw and fix of a zero-click vulnerability, exploited in the wild.pdf"
    ],
    "report_names": [
        "2021-09-16 - Analysis of CVE-2021-30860 the flaw and fix of a zero-click vulnerability, exploited in the wild.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535663,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653752991,
    "ts_modification_date": 1653752991,
    "files": {
        "pdf": "https://archive.orkl.eu/c584e4805eb10b6242c1f79ded7300281245e74b.pdf",
        "text": "https://archive.orkl.eu/c584e4805eb10b6242c1f79ded7300281245e74b.txt",
        "img": "https://archive.orkl.eu/c584e4805eb10b6242c1f79ded7300281245e74b.jpg"
    }
}