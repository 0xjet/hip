{
    "id": "7e47520f-525d-4c04-8eb9-1e8148eb508b",
    "created_at": "2023-01-12T14:59:32.320183Z",
    "updated_at": "2025-03-27T02:08:40.287688Z",
    "deleted_at": null,
    "sha1_hash": "d5963f6d4211a05b97741c193a624c1595cb7c7d",
    "title": "2021-03-11 - Playing in the (Windows) Sandbox",
    "authors": "",
    "file_creation_date": "2022-05-28T03:10:44Z",
    "file_modification_date": "2022-05-28T03:10:44Z",
    "file_size": 1553828,
    "plain_text": "# Playing in the (Windows) Sandbox\n\n**research.checkpoint.com/2021/playing-in-the-windows-sandbox/**\n\nMarch 11, 2021\n**Research By: Alex Ilgayev**\n\n## Introduction\n\n\nMarch 11, 2021\n\n\nTwo years ago, Microsoft released a new feature as a part of the Insiders build 18305 – Windows\n**Sandbox.**\n\nThis sandbox has some useful specifications:\n\nIntegrated part of Windows 10 (Pro/Enterprise).\nRuns on top of Hyper-V virtualization.\nPristine and disposable – Starts clean on each run and has no persistent state.\nConfigurable through a configuration file that has a dedicated format (WSB format). You can configure\nnetworking, vGPU, mapped folders, an automated script to run at user login, and many other options.\nThe deployment is based on Windows Containers technology.\n\n[Judging by the accompanying technical blog post, we can say that Microsoft achieved a major technical](https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849)\nmilestone. The resulting sandbox presents the best of both worlds: on the one hand, the sandbox is based\non Hyper-V technology, which means it inherits Hyper-V’s strict virtualization security. On the other hand,\nthe sandbox contains several features which allow sharing resources with the host machine to reduce CPU\nand memory consumption.\n\nOne of the interesting features is of particular importance and we will elaborate on it here\n\n\n-----\n\n**Dynamically Generated Image**\n\nThe guest disk and filesystem are created dynamically, and are implemented using files in the host\nfilesystem.\n\n**Figure 1 – Dynamically generated image (from Microsoft official documentation).**\n\nWe decided to dig deeper into this technology for several reasons.\n\n**Lack of documentation on its internal technicalities, both official and community-based. While it**\ncombines two widely documented technologies (Windows Containers and Hyper-V), we are still\n[missing on how it all works together. For example, the technical blog refers to the Windows Containers](https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/)\ntechnology, but in the official documentation, the creation and management of Windows Containers is\ndone using the Docker utility for Windows, which isn’t used in Windows Sandbox.\nUnfortunately, Microsoft does not allow any customization to the sandbox other than tweaking the\nWSB file. This means we can’t install any program that requires a reboot, or create our own base\nimage for the sandbox.\n\nIn this article, we break down several of the components, execution flow, driver support, and the\nimplementation design of the dynamic image feature. We show that several internal technologies are\ninvolved, such as NTFS custom reparse tag, VHDx layering, container configuration for proper isolation,\nvirtual storage drivers, vSMB over VMBus, and more. We also create a custom [FLARE VM sandbox for](https://github.com/fireeye/flare-vm)\nmalware analysis purposes, whose startup time is just 10 seconds.\n\n## General Components\n\nThe complex ecosystem of Hyper-V and its modules has already been researched extensively. Several\n[vulnerabilities were found, such as the next VmSwitch RCE which can cause a full guest-to-host escape. A](https://www.youtube.com/watch?v=025r8_TrV8I)\nfew years ago, Microsoft introduced Windows Containers (mainly for servers), a feature which allowed\nrunning Docker natively on Windows to ease software deployment.\n\nBoth these technologies were also introduced to the Windows 10 endpoint platform in the form of two\ncomponents: WDAG (Windows Defender Application Guard), and most recently, Windows Sandbox.\nLately, WDAG and another exciting feature for Office isolation were combined as MDAG – Microsoft\nDefender Application Guard.\n\nIn the POC2018 conference, [Yunhai Zhang had a](https://twitter.com/_f0rgetting_) [presentation where he dived into the WDAG architecture](https://www.powerofcommunity.net/poc2018/yunhai.pdf)\nand internals. As we demonstrate, Windows Sandbox shares the same technologies for its underlying\nimplementation.\n\n\n-----\n\nThe sandbox can be divided into three components: two services – `CmService.dll and` `vmcompute.exe`\n– and the created worker process, `vmwp.exe .`\n\n**Figure 2 – Windows Sandbox general components.**\n\n## Preparing the Sandbox\n\nBehind every Hyper-V based VM there is a VHDx file, a virtual disk which is used by the machine. To\nunderstand how the disk is created, we looked at the working folder of an actively running sandbox:\n```\n%PROGRAMDATA%\\Microsoft\\Windows\\Containers . Surprisingly, we found more than 8 VHDx files.\n\n```\n\n-----\n\n**Figure 3 – Working folder structure.**\n\nWe can track the main VHDx file by its dynamic size at the next path – `Sandboxes\\29af2772-55f9-4540-`\n```\n970f-9a7a9a6387e4\\sandbox.vhdx, where the GUID is randomly generated on each sandbox run.\n\n```\nWhen we manually mount the VHDx file, we see that most of its filesystem is missing (this phenomenon is\nalso visible in Zhang’s WDAG research, mentioned previously).\n\n**Figure 4 – Mounted sandbox VHDx.**\n\nWe can immediately observe the “X” sign on the folder icon. If we turn on the “attributes” column in File\n[Explorer, we can see two unusual NTFS attributes. These are explained here:](https://www.urtech.ca/2017/11/solved-all-ntfs-attributes-defined/)\n\n**O – Offline**\n\n**L – Reparse Point**\n\n[Reparse Point is an extension to NTFS which allows it to create a “link” to another path. It also plays a role](https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-points)\nin other features, such as volume mounting. In our case, it makes sense that this feature is used as most of\nthe files aren’t “physically” present in the VHDx file.\n\nTo understand where the reparse points to and what’s there, we delve deeper into the NTFS structure.\n\n## Parsing MFT Record\n\n\n-----\n\nThe Master File Table (MFT) stores the information required to retrieve files from an NTFS partition. A file\nmay have one or more MFT records, and can contain one or more attributes. We can run the popular\nforensic tool, Volatility, with the `mftparser option to parse all MFT records in the underlying file system.`\nThis can be done using the following command line:\n```\nvolatility.exe -f sandbox.vhdx mftparser --output=body -D output --outputfile=sandbox.body\n\n```\nWhen we search the `kernel32.dll (a sample system file) record in the output, we encounter the`\nfollowing text:\n```\n0|[MFT FILE_NAME] Windows\\System32\\kernel32.dll (Offset: 0x3538c00)|1251|---a---S--o---|0|0|764456|1604310972|1596874670|1603021550|1596874670\n0|[MFT STD_INFO] Windows\\System32\\kernel32.dll (Offset: 0x3538c00)|1251|---a---Sr-o---|0|0|764456|1606900209|1596874670|1603021550|1596874670\n\n```\nWe can see similar reparse (“S“) and offline (“o“) attributes as we did earlier, but Volatility doesn’t give us\nany additional information. We can use the offset of the MFT record, `0x3538c00, to launch our own`\nmanual parse.\n\n[We used the next NTFS documentation for the parsing process. We do not provide a full specification of the](https://dubeyko.com/development/FileSystems/NTFS/ntfsdoc.pdf)\nMFT format, but to put it simply, MFT records contain a variable number of attributes, and each one has its\nown header and a payload. We are looking for the `$REPARSE_POINT attribute, which is identified by the`\nordinal `0xC0 .`\n\n**Figure 5 – MFT attribute header structure.**\n\n**Figure 6 –** `$REPARSE_POINT attribute payload structure.`\n\n\n-----\n\nOur parsing effort with the structures listed above yields the following data:\n```\n$REPARSE_POINT Attribute\n--------------- Attribute Header --------------- \nC0 00 00 00 - Type ($REPARSE_POINT)\n78 00 00 00 - Length\n00     - Non-resident flag\n00     - Name length\n00 00    - Offset to the name\n00 00    - Flags\n03 00    - Attribute Id (a)\n5C 00 00 00 - Length of the attribute\n18 00    - Offset to the attribute\n00     - Indexed flag\n00     - Padding\n---------------- Attribute Data ---------------- \n18 10 00 90 - Reparse tag\n54 00    - Reparse data length\n00 00    - Padding\n----------------- Reparse Data ----------------- \n01 00 00 00 - Version ?\n00 00 00 00 - Reserved ?\n77 F6 64 82 B0 40 A5 4C BF 9A 94 4A C2 DA 80 87 - Referenced GUID \n3A 00    - Path string size\n57 00 69 00 6E 00 64 00 6F 00 77 00 73 00 5C 00 \n53 00 79 00 73 00 74 00 65 00 6D 00 33 00 32 00 \n5C 00 6B 00 65 00 72 00 6E 00 65 00 6C 00 33 00 \n32 00 2E 00 64 00 6C 00 6C 00 - Path string\n\n```\nA few important notes:\n\nWe didn’t find any public documentation for Microsoft’s reparse data structure, but it wasn’t too difficult\nto reverse-engineer.\nThe reparse tag `0x90001018 is defined` [here as](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea-2b9d423b1ee4) `IO_REPARSE_TAG_WCI_1 with the next description:`\n\n“Used by the Windows Container Isolation filter. Server-side interpretation only, not meaningful over the\nwire.”\n\nWhile reverse-engineering Windows modules in this research, several times we came across the\nreferenced GUID `77 F6 64 82 B0 40 A5 4C BF 9A 94 4A C2 DA 80 87 as a hardcoded value.`\nThis value indicates a reference to the host base layer, which we talk about it later.\nThe path in the reparse data shows the relative path of our sample file:\n\n```\nWindows\\System32\\kernel32.dll\n\n```\n\nBased on the above information, we can conclude that files are “linked” by the underlying file system\n(probably to a designated FS filter), but many questions are still unanswered: how is the VHDx constructed,\nwhat is the purpose of other VHDx’s, and what component is responsible for linking to the host files.\n\n## VHDx Layering\n\nIf we track Procmon logs during the sandbox creation, we notice a series of VHDx access attempts:\n\n\n-----\n\n**Figure 7 – VHDx layering lead.**\n\nWhile the first one is the “real” VHDx which we parsed previously, it is followed by 3 other VHDx accesses.\nWe suspect that Microsoft used some sort of layering for the virtual disk templates.\n\nOur theory is easily verified by inspecting the VHDx files using the binary editor:\n\n**Figure 8 –** `parent_linkage tag in 010 Editor.`\n\nThe parent locator in VHDx format can be given using multiple methods: absolute path, relative path, and\n[volume path. The documentation can be found here.](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-vhdx/b6332a98-624d-46b8-bd0e-b77b573662f9)\n\nWith that knowledge, we can build the next layering:\n```\n   Sandboxes\\<new_sandbox_guid>\\sandbox.vhdx – The “real” VHDx.\n   Sandboxes\\<constant_guid_per_installation>\\sandbox.vhdx – Created once per sandbox\n\n```\ninstall.\n```\n   BaseImages\\0949cec7-8165-4167-8c7d-67cf14eeede0\\Snapshot\\SnapshotSandbox.vhdx –\n\n```\nProbably relevant to the base layer snapshot.\n```\n   PortableBaseLayer\\SystemTemplateBase.vhdx – Base template.\n\n```\nWhen we browse these virtual disks, we notice files are still missing; some system folders are empty, as\nwell as folders for Users/Program Files and various other files.\n\n\n-----\n\nPlaying with Procmon leads us to understand that another important layer is missing: the OS base layer.\n\n## OS Base Layer\n\nThe OS base layer main file exists in the sandbox working folder in the next path: `BaseImages\\0949cec7-`\n```\n8165-4167-8c7d-67cf14eeede0\\BaseLayer.vhdx . By looking at the installation process through\n\n```\nProcmon, we can see that the next `.wim (Windows Imaging Format) file,`\n```\nC:\\Windows\\Containers\\serviced\\WindowsDefenderApplicationGuard.wim, is extracted into the\nPortableBaseLayer folder by the same name, and is copied and renamed into the base layer file above.\n\n```\nThis shows yet another similarity between WDAG and Windows Sandbox.\n\nWhen we browsed the `BaseLayer.vhdx disk, we could see the complete structure of the created`\nsandbox, but system files were still “physically” missing. Parsing the MFT record for `kernel32.dll like we`\ndid previously results in the same `$REPARSE_POINT attribute but with a different tag:` `0xA0001027 :`\n```\nIO_REPARSE_TAG_WCI_LINK_1 . Remember this tag for later.\n\n```\n**Figure 9 – Base layer user folders.**\n\nIn addition, when we run `mountvol command, we see that the base layer VHDx is mounted to the same`\ndirectory where it exists:\n\n**Figure 10 – Mounted OS base layer.**\n\nThe service in charge of mounting that volume, and all previous functionality we mentioned up to this point,\nis the Container Manager Service `CmService.dll .`\n\nThis service runs an executable named `cmimageworker.exe, with one of the next command line`\nparameters, `expandpbl/deploy/clean, to perform these actions.`\n\n\n-----\n\n**Figure 11 –** `CmService base layer creation.`\n\nWe can observe the call to `computestorage!HcsSetupBaseOSLayer in` `cmimageworker.exe, and part`\nof the actual creation of the base layer in `computestorage.dll .`\n\n**Figure 12 –** `cmimageworker!Container::Manager::Hcs::ProcessImage initiates base layer creation.`\n\n**Figure 13 – Part of the base layer creation in** `computestorage!OsImageUtilities::ProcessOsLayer .`\n\nMicrosoft issued the following statement regarding the sandbox:\n\n**Part of Windows – everything required for this feature ships with Windows 10 Pro and Enterprise. No**\nneed to download a VHD!\n\nSo far, we understand crucial implementation details regarding that feature. Let’s continue to see how the\ncontainer is executed.\n\n## Running the Sandbox\n\n\n-----\n\nRunning the Windows Sandbox application triggers an execution flow which we won t elaborate on here. We\njust mention that the flow leads to `CmService executing` `vmcompute!HcsRpc_CreateSystem through an`\nRPC call. Another crucial service, `vmcompute.exe, runs and orchestrates all compute systems`\n(containers) on the host.\n\nIn our case, the CreateSystem command also receives the next configuration JSON which describes the\ndesired machine:\n\n**Note – The JSON is cut for readability. You can access the full JSON in Appendix A.**\n```\n{\n  \"Owner\": \"Madrid\",\n          ...\n  \"VirtualMachine\": {\n                   ...\n    \"Devices\": {\n      \"Scsi\": {\n        \"primary\": {\n          \"Attachments\": {\n            \"0\": {\n              \"Type\": \"VirtualDisk\",\n              \"Path\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\Sandboxes\\\\025b00c8-849a-4e00-bcb2c2b8ec698bab\\\\sandbox.vhdx\",\n...\n            }\n          }\n        }\n      },\n                             ...\n      \"VirtualSmb\": {\n        \"Shares\": [{\n          \"Name\": \"os\",\n          \"Path\": \"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\BaseImages\\\\0949cec78165-4167-8c7d-67cf14eeede0\\\\BaseLayer\\\\Files\",\n                                                ...\n        }],\n`      },\n                             ...\n    },\n                   ...\n    \"RunInSilo\": {\n      \"SiloBaseOsPath\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\BaseImages\\\\0949cec7-8165-4167-8c7d67cf14eeede0\\\\BaseLayer\\\\Files\",\n      \"NotifySiloJobCreated\": true,\n      \"FileSystemLayers\": [{\n        \"Id\": \"8264f677-40b0-4ca5-bf9a-944ac2da8087\",\n        \"Path\": \"C:\\\\\",\n        \"PathType\": \"AbsolutePath\"\n      }]\n    },\n                   ...\n  },\n          ...\n}\n\n```\nThis JSON is created at\n```\nCmService!Container::Manager::Hcs::Details::GenerateCreateComputeSystemJson . We didn’t\n\n```\nmanage to track any file which helps build that configuration\n\n\n-----\n\n[Before we start analyzing the interesting fields in the JSON, we want to mention this article by Palo Alto](https://unit42.paloaltonetworks.com/what-i-learned-from-reverse-engineering-windows-containers/)\nNetworks. The article explains the container internals, and how Job and Silo objects are related.\n\nThe first interesting configuration tag is `RunInSilo . This tag triggers a code flow in` `vmcompute which`\nleads us to the next stack trace:\n```\n3: kd> k\n # Child-SP     RetAddr        Call Site\n00 ffff9a00`8da57648 fffff806`85d2b7fb   wcifs!WcPortMessage\n01 ffff9a00`8da57650 fffff806`85d63499   FLTMGR!FltpFilterMessage+0xdb\n... (REDUCTED)\n0b 0000004d`4218dbf0 00007ffa`08c5363d   FLTLIB!FilterSendMessage+0x31\n0c 0000004d`4218dc40 00007ffa`08c48686   wc_storage!WciSetupFilter+0x195\n0d 0000004d`4218dcf0 00007ffa`22e06496   wc_storage!WcAttachFilterEx+0x156\n0e 0000004d`4218dee0 00007ffa`22de5a66   container!container::FilesystemProvider::Setup+0x15e\n0f 0000004d`4218dfc0 00007ffa`22ded4ad   container!container_runtime::CreateContainerObject+0x106\n10 0000004d`4218e010 00007ffa`22decf3c   container!container::CreateContainer+0x10d\n11 0000004d`4218e4a0 00007ff6`fcf0bc7f   container!WcCreateContainer+0x1c\n12 0000004d`4218e4d0 00007ff6`fcf0c5c4  \nvmcompute!ComputeService::JobUtilities::ConvertJobObjectToContainer+0xcb\n13 0000004d`4218e590 00007ff6`fce8573f  \nvmcompute!ComputeService::JobUtilities::CreateSiloForIsolatedWorkerProcess+0x4dc\n14 0000004d`4218e8c0 00007ff6`fce875c5  \nvmcompute!ComputeService::Management::Details::PrepareJobForWorkerProcess+0x17b\n15 0000004d`4218e9a0 00007ff6`fcee6cbb  \nvmcompute!ComputeService::Management::Details::ConstructVmWorker+0xfd5\n... (REDUCTED)\n\n```\nFrom the stack, we can understand that whenever the compute system receives the silo configuration, it\ncreates and configures a container through a `container!WcCreateContainer call. As part of its`\nconfiguration, it also communicates with the `wcifs.sys driver through` `FLTLIB!FilterSendMessage . We`\nexplain this driver and its purpose shortly.\n\nThe second interesting feature is the `VirtualSmb tag for creating the respective shares for the mounted`\nbase layer path we mentioned previously. We’ll get back to this shortly as well.\n\n## Container Isolation\n\nAs we can see in the stack trace, the container creation includes opening the filter communication channel\non port `\\WcifsPort with the` `wcifs.sys driver, Windows Container Isolation FS Filter Driver. This is a`\n[common method for a user mode code to communicate with filter drivers.](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-and-kernel-mode)\n\nThis mini-filter driver has an important part in the implementation of the container filesystem virtualization.\nThis driver fills this role in both the guest and the host.\n\nFile system filter drivers are usually quite complex, and this one isn’t an exception. Luckily, [James Forshaw](https://twitter.com/tiraniddo)\n[of Google Project Zero recently wrote a great article which explains the low-level design of Windows FS](https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html)\nfilter drivers, which helps us understand the logic in our case.\n\nWe can divide the driver logic into 2 parts:\n\nDriver configuration – The configuration depends on whether the driver runs on the guest or on the\nhost system.\nHandling the operation callbacks, such as `WcPreCreate,` `WcPostCreate,` `WcPreRead, and`\n```\n   WcPostRead . These callbacks contain the main logic, data manipulation and proper redirections.\n\n```\n\n-----\n\nWe ll explain some of the methods this driver uses to understand the ecosystem of the sandbox.\n\n### Initial Configuration\n\n**Guest Configuration**\n\nAs we said previously, both the host, and the guest use this driver but in different ways.\n\nThe guest receives a set of parameters via the registry for its initial configuration. Some of these params are\nat `HKLM\\SYSTEM\\CurrentControlSet\\Control and`\n```\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\BootContainer as we can see below:\n\n```\n**Figure 14 –** `HKLM\\SYSTEM\\CurrentControlSet\\Control config values.`\n\n**Figure 15 –** `HKLM\\SYSTEM\\CurrentControlSet\\Control\\BootContainer config values.`\n\nYou might notice the `IO_REPARSE_TAG_WCI_1 (code` `0x90001018 ), which we saw earlier in the “real”`\nVHDx file. This tag, together with `IO_REPARSE_TAG_WCI_LINK_1, which we saw as a reparse tag in`\n```\nBaseLayer.vhdx, are hardcoded into the wcifs!WcSetBootConfiguration method:\n\n```\n**Figure 16 – Hardcoded reparse tag values in** `WcSetBootConfiguration .`\n\nThe second, more important part of the guest configuration is in `wcifs!WcSetupVsmbUnionContext,`\nwhere it sets up a virtualized layer known as a Union Context. Behind the scenes, the driver stores\ncustomized data on several context objects and accesses them with the proper NT API –\n```\nFltGetInstanceContext, PsGetSiloContext, and FltGetFileContext . These custom objects\n\n```\ncontain AVL trees and hash tables to efficiently look up the virtualized layers.\n\nThe `WcSetupVsmbUnionContext method has two more interesting artifacts. One is a vSMB path which is`\npart of the layer, and another is the `HOST_LAYER_ID GUID which we saw previously in the parsed MFT`\nand in the JSON that describes the virtual machine:\n\n\n-----\n\n**Figure 17 – Hardcoded vSMB path in** `WcSetupVsmbUnionContext .`\n\n**Figure 18 – Hardcoded GUID for** `HOST_LAYER_ID .`\n\nAs we delve deeper, we see signs that a Virtual SMB method is used to share files between the guest and\nthe host. Soon we’ll see that vSMB is the main method for the base layer implementation and mapped\nfolder sharing.\n\n**Host Configuration**\n\nFor the host system, the main configuration happens when the parent compute process, `vmcompute,`\ninitiates the container creation, and sends a custom message to `\\WcifsPort . This triggers`\n```\nwcifs!WcPortMessage which is a callback routine for any message sent to that specific port.\n\n```\nBelow is a partial reconstruction of the message sent by the service to the filter driver:\n```\nstruct WcifsPortMsg\n{\n DWORD MsgCode;\n DWORD MsgSize;\n WcifsPortMsgSetUnion Msg;\n};\nstruct WcifsPortMsgSetUnion\n{\n DWORD MsgVersionOrCode;\n DWORD MsgSize;\n DWORD NumUnions;\n wchar_t InstanceName[50];\n DWORD InstanceNameLen;\n DWORD ReparseTag;\n DWORD ReparseTagLink;\n DWORD NotSure;\n HANDLE Job;\n BYTE ContextData[1];\n};\n\n```\nThe `ContextData field also contains the device paths the union should map.`\n\n### Operation Callbacks\n\nDuring the registration, the filter driver supplies a set of callbacks for each operation it wants to intercept.\nThe filter manager invokes these callbacks pre/post each file operation, as we can see below.\n\n\n-----\n\n**[Figure 19 – Mini-filter architecture, courtesy of James Forshaw.](https://twitter.com/tiraniddo)**\n\nWithout diving too much into the technical details, the driver defines and takes care of two custom reparse\ntags:\n\n**IO_REPARSE_TAG_WCI_1 – This is the main tag that indicates the file instance on the disk is virtual,**\nand the real path can be found in its internal structures. Example uses of this “conversion”:\n\nThe guest converts files from its native path `C:\\Windows\\system32\\kernel32.dll to vSMB`\npath `\\Device\\vmsmb\\VSMB-{dcc079ae-60ba-4d07-847c-`\n```\n      3493609c0870}\\os\\Windows\\System32\\kernel32.dll .\n\n```\nThe host converts files from the base layer device path\n```\n      C:\\ProgramData\\Microsoft\\Windows\\Containers\\BaseImages\\0949cec7-8165-4167      8c7d-67cf14eeede0\\BaseLayer\\Files\\Windows\\System32\\en-US\\apphelp.dll.mui to the\n\n```\nreal path `C:\\Windows\\System32\\en-US\\apphelp.dll.mui .`\n\nThis conversion is quite interesting, as it happens mainly in empty system folders in the base\nlayer which contain this reparse tag (like the `en-US folder).`\n**IO_REPARSE_TAG_WCI_LINK_1 – This tag is used only on the host as far as we could tell, and**\nlinks the system files from the base layer device path\n```\n   C:\\ProgramData\\Microsoft\\Windows\\Containers\\BaseImages\\0949cec7-8165-4167-8c7d   67cf14eeede0\\BaseLayer\\Files\\Windows\\System32\\kernel32.dll to the real path\n   C:\\Windows\\System32\\kernel32.dll . Compared to the previous point, this example DLL file entry\n\n```\ndoes exist in the base layer, and has this reparse tag.\n\nThe discovery that vSMB is the primary method for the OS base layer sharing was quite surprising. Now\nthat we know it is a crucial communication method in the ecosystem the natural next step is to dig further\ninside.\n\n## (v)SMB File Sharing\n\n\n-----\n\nDuring the sandbox installation, we noticed `vmcompute creates several virtual shares by invoking`\n```\nCreateFileW to the storage provider device, and sends IOCTL 0x240328 . A sample path for such an\n\n```\ninvoke might look like this: `\\??\\STORVSP\\VSMB\\??`\n```\n\\C:\\ProgramData\\Microsoft\\Windows\\Containers\\BaseImages\\0949cec7-8165-4167-8c7d67cf14eeede0\\BaseLayer\\Files .\n\n```\nThe method that creates these shares is `vmcompute!ComputeService::Storage::OpenVsmbRootShare .`\nWe can see its flow in the next stack trace:\n```\n3: kd> k\n # Child-SP     RetAddr        Call Site\n00 ffff9a00`8d48a178 fffff806`85fd6af8   storvsp!VspFileCreate\n01 (Inline Function) --------`--------   Wdf01000!FxFileObjectFileCreate::Invoke+0x29\n[minkernel\\wdf\\framework\\shared\\inc\\private\\common\\FxFileObjectCallbacks.hpp @ 58] \n... (REDUCTED)\n11 0000004d`4210d690 00007ff6`fcf33700   KERNELBASE!CreateFileW+0x66\n12 0000004d`4210d6f0 00007ff6`fceb8180  \nvmcompute!ComputeService::Storage::OpenVsmbRootShare+0x3ac\n13 0000004d`4210d850 00007ff6`fceba0fc  \nvmcompute!ComputeService::VirtualMachine::Details::ConfigureVSMB+0x598\n14 0000004d`4210da30 00007ff6`fceba908  \nvmcompute!ComputeService::VirtualMachine::Details::InitializeDeviceSettings+0x918\n15 0000004d`4210eb90 00007ff6`fce86abd  \nvmcompute!ComputeService::VirtualMachine::CreateVirtualMachineConfiguration+0x68\n16 0000004d`4210ebe0 00007ff6`fcee6cbb  \nvmcompute!ComputeService::Management::Details::ConstructVmWorker+0x4cd\n... (REDUCTED)\n\n```\nIn addition, when we map host folders to the guest using the WSB file configuration, the same method is\ncalled. For example, mapping the Sysinternals folder results in the next call to the driver: `\\??`\n```\n\\STORVSP\\VSMB\\??\\C:\\Users\\hyperv-root\\Desktop\\SysinternalsSuite .\n\n### Accessing Files via (v)SMB\n\n```\nAfter creating these shares, we can access them within the guest through the created alias. We can use the\n```\ntype command to print the kernel32.dll of the host with the next path \\\\.\\vmsmb\\VSMB-{dcc079ae60ba-4d07-847c-3493609c0870}\\os\\Windows\\System32\\kernel32.dll :\n\n```\n**Figure 20 – Accessing the vSMB share.**\n\nTo serve the vSMB files, the `vmusrv module, which is part of the VM worker process, creates a worker`\nthread. This module is a user mode vSMB server which requests packets directly from the VMBus at the\n```\nvmusrv!VSmbpWorkerRecvLoop routine, and then proceeds to process the packets.\n\n```\n\n-----\n\n### Serving Create File Operation\n\nWhenever `vmusrv receives a Create SMB request, it initiates a new request to the storage provider driver.`\nSuch a call might look like this:\n```\n2: kd> k\n # Child-SP     RetAddr        Call Site\n... (REDUCTED)\n0c ffff9a00`8d9522e0 fffff806`892c4741   storvsp!VspVsmbCommonRelativeCreate+0x369\n0d ffff9a00`8d952510 fffff806`892c3b7e   storvsp!VspVsmbHandleRelativeCreateFileRequest+0x321\n0e ffff9a00`8d952790 fffff806`892c0f85   storvsp!VspVsmbDispatchIoControlForProcess+0x11e\n0f ffff9a00`8d9527e0 fffff806`8100e522   storvsp!VspFastIoDeviceControl+0x175\n... (REDUCTED)\n13 000000ae`9c0ff298 00007ffa`110c0c0a   ntdll!NtDeviceIoControlFile+0x14\n14 000000ae`9c0ff2a0 00007ffa`110c0456   vmusrv!CShare::OpenFileRelativeToShareRootInternal+0x306\n15 000000ae`9c0ff3e0 00007ffa`110b9381   vmusrv!CShare::OpenFileRelativeToShareRoot+0x356\n16 000000ae`9c0ff510 00007ffa`110b4451   vmusrv!CFSObject::CreateFileW+0x185\n17 000000ae`9c0ff690 00007ffa`1109a568   vmusrv!CShare::Create+0x91\n18 000000ae`9c0ff740 00007ffa`1109d74d   vmusrv!ProviderCallback_Create+0x30\n19 000000ae`9c0ff780 00007ffa`1109c299   vmusrv!SrvCreateFile+0x331\n1a 000000ae`9c0ff860 00007ffa`1109c6f0   vmusrv!Smb2ExecuteCreateReal+0x111\n1b 000000ae`9c0ff940 00007ffa`110a08da   vmusrv!Smb2ExecuteCreate+0x30\n1c 000000ae`9c0ff970 00007ffa`11098907   vmusrv!Smb2ExecuteProviderCallback+0x7e\n1d 000000ae`9c0ff9d0 00007ffa`11088311   vmusrv!Smb2PacketProcessing+0x97\n1e 000000ae`9c0ffa40 00007ffa`11087225   vmusrv!Smb2PacketProcessingCallback+0x11\n... (REDUCTED)\n\n```\nThe communication with the storage provider is done through an IOCTL with the code `0x240320, while`\nthe referenced handle is the vSMB path opened on the initialization phase:\n\n**Figure 21 – The handle in which the IOCTL is referred.**\n\nIf we look closely at `storvsp!VspVsmbCommonRelativeCreate, we see that every execution is followed`\nby a call to `nt!IoCreateFileEx . This call contains the relative path of the desired file with an additional`\n```\nRootDirectory field which represents the \\Files folder in the mounted base layer VHDx:\n\n```\n\n-----\n\n**Figure 22 – Execution of** `IoCrateFileEx by` `storvsp.sys .`\n\n### Serving Read/Write Operation\n\nRead/Write operations are executed by the worker thread in\n```\nvmusrv!CFSObject::Read/vmusrv!CFSObject::Write . If the file is small enough, the thread simply\n\n```\nexecutes `ReadFile/WriteFile on the handle. Otherwise it maps the file to the memory, and transfers it`\n[efficiently through RDMA on top of VMBus. This transfer is executed at](https://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v-virtual-switch/rdma-and-switch-embedded-teaming)\n```\nvmusrv!SrvConnectionExecuteRdmaTransfer, while the RDMA communication is done with the\nRootVMBus device (host VMBus device name) using IOCTL 0x3EC0D3 or 0x3EC08C .\n2: kd> k\n... (REDUCTED)\n06 ffffad0e`3bee7650 fffff800`36225b62   vmbusr!RootIoctlRdmaFileIoHandleMappingComplete+0x10f\n07 ffffad0e`3bee7690 fffff800`361fee21   vmbusr!RootIoctlRdmaFileIo+0xf2\n08 ffffad0e`3bee76f0 fffff800`339da977   vmbusr!RootIoctlDeviceControlPreprocess+0x191\n... (REDUCTED)\n12 00000009`ae27f7e8 00007ffe`281ce773   ntdll!NtDeviceIoControlFile+0x14\n13 00000009`ae27f7f0 00007ffe`281dcbd2   vmusrv!SrvConnectionExecuteRdmaTransfer+0x24f\n14 00000009`ae27f940 00007ffe`281d4874   vmusrv!CFile::ReadFileRdma+0xc2\n15 00000009`ae27f9c0 00007ffe`281c218e   vmusrv!CFSObject::Read+0x94\n16 00000009`ae27fa00 00007ffe`281c08da   vmusrv!Smb2ExecuteRead+0x1be\n17 00000009`ae27fa60 00007ffe`281b8907   vmusrv!Smb2ExecuteProviderCallback+0x7e\n18 00000009`ae27fac0 00007ffe`281a6a4e   vmusrv!Smb2PacketProcessing+0x97\n19 00000009`ae27fb30 00007ffe`3bba6fd4   vmusrv!SmbWorkerThread+0xce\n... (REDUCTED)\n\n```\n\n-----\n\n**Figure 23 – Communication with** `\\Device\\RootVmBus\\rdma\\494 for the read/write operation.`\n\n## Guest-to-Host Flow\n\n[Based on a few insights from this article explaining the](https://www.linkedin.com/pulse/hyper-v-architecture-internals-pravin-gawale/) `Storvsc.sys/Storvsp.sys relationship, we can`\ncombine all previous technical blocks to the next file access flow.\n\n**Figure 24 – File access flow.**\n\n1. We use the command `type to open and print the content of the` `kernel32.dll file. This is a`\n\nsystem file, and therefore the sandbox doesn’t own its copy, but uses the host’s copy.\n\n\n-----\n\n2. The guest is not aware that the file doesn t exist, so it performs a normal file access through the\n\nfilesystem driver stack up to the storage driver stack.\n3. The Hyper-V storage consumer `Storvsc.sys is a miniport driver, meaning it acts as the virtual`\n\nstorage for the guest. It receives and forwards SCSI requests over the VMBus.\n4. The storage provider `Storvsp.sys has a worker thread listening for new messages over the VMBus`\n\nat `storvsp!VspPvtKmclProcessingComplete .`\n5. The provider parses the VMBus request, and passes it to\n```\n   vhdparser!NVhdParserExecuteScsiRequestDisk, which executes vhdmp.sys, the VHD parser\n\n```\ndriver.\n6. Eventually, `vhdmp.sys accesses the physical instance of` `sandbox.vhdx through the filter`\n\nmanager, and performs read/write operation. In this case, it reads the data requested by the guest\nfilesystem filter manager. That data is returned to the filter manager for further analysis.\n7. As explained previously, the returned entry is tagged with a WCI reparse tag and with the host layer\n\nGUID. When `wcifs.sys executes its post-create operation on the file, it looks for the union context`\nfor that device, and replaces the file object with the next one: `\\Device\\vmsmb\\VSMB-{dcc079ae-`\n```\n   60ba-4d07-847c-3493609c0870}\\os\\Windows\\System32\\kernel32.dll\n\n```\n8. The `\\Device\\vmsmb device was created as an SMB share, so the filter manager accesses it like any`\n\nother normal share. Behind the scenes, it performs SMB requests over VMBus to the host.\n9. The vSMB user-mode server `vmusrv.dll polls the` `\\\\.\\VMbus\\ device for new messages in its`\n\nworker thread method `vmusrv!SmbWorkerThread .`\n10. As we showed previously, in a create operation, the server communicates with the storage provider\n\nthrough IOCTL on the handle of mounted OS base layer: `\\Device\\STORVSP\\VSMB\\??`\n```\n   \\C:\\ProgramData\\Microsoft\\Windows\\Containers\\BaseImages\\0949cec7-8165-4167-8c7d   67cf14eeede0\\BaseLayer\\Files\n\n```\n11. The storage provider executes the file request through `IoCreateFileEx . That request is relative,`\n\nand contains the `RootDirectory of the mounted OS layer. This triggers the filter manager to open`\nthe file in the mounted OS layer.\n12. Similar to step (7), the returned entry contains a WCI reparse tag, which causes `wcifs.sys to`\n\nchange the file object in the post-create method. It changes the file object to its physical path:\n```\n   C:\\Windows\\System32\\kernel32.dll\n\n```\n13. Access the host `kernel32.dll file, and return back to the guest.`\n14. For a `ReadFile operation, the` `wcifs.sys driver saves a context state on top of the file object to`\n\nhelp it perform a read/write operation. In addition, the worker thread `vmusrv executes the read`\nrequest either with direct access to the file, or through RDMA on top VMBus.\n\nThe actual process is much more complex, so we tried to focus on the components crucial to the\nvirtualization.\n\nThe sandbox also allows mapping folders from host to guest through its configuration. Such folders receive\na unique alias for the vSMB path, and the access is similar to the OS layer. The only difference is that the\npath is altered in the guest filter manager by `bindflt.sys .`\n\nFor example, if we map the SysinternalsSuite folder to the guest Desktop folder, the path\n```\nC:\\Users\\WDAGUtilityAccount\\Desktop\\SysinternalsSuite\\Procmon.exe is altered into\n\\Device\\vmsmb\\VSMB-{dcc079ae-60ba-4d07-847c3493609c0870}\\db64085bcd96aab59430e21d1b386e1b37b53a7194240ce5e3c25a7636076b67\\Procmon.exe,\n\n```\nwhich leaves rest of the process the same.\n\n## Playing with the Sandbox\n\n\n-----\n\nOne of our targets in this research was to modify the base layer content according to our needs. Now that\nwe understand the ecosystem, it appears to be quite easy.\n\nThe modification has a few simple steps:\n\n1. Stop `CmService, the service that creates and maintains the base layer. When the service is`\n\nunloaded, it also removes the base layer mounting.\n2. Mount the base layer (it is in the\n\n```\nC:\\ProgramData\\Microsoft\\Windows\\Containers\\BaseImages\\0949cec7-8165-4167-8c7d\n```\n```\n   67cf14eeede0\\BaseLayer.vhdx file). This can be done by double clicking, or using the\n   diskmgmt.msc utility.\n\n```\n3. Make modifications to the base layer. In our case, we added all FLARE post-installation files.\n4. Unmount the base layer.\n5. Start `CmService .`\n\nThe moment we start the sandbox, we have our awesome FLARE VM!\n\n**Figure 25 – FLARE VM on top of the Windows Sandbox.**\n\n## Summary\n\nWhen we started researching Windows Sandbox, we had no idea that such a “simple” operation boils down\nto a complex flow with several Microsoft internal undocumented technologies such as vSMB and Container\nIsolation.\n\nWe hope this article will help the community with further information gathering and bug hunting. For us, this\nwas a big first step into researching and understanding virtualization related technologies.\n\n[For any technical feedback, feel free to reach out on twitter.](https://twitter.com/_alex_il_)\n\n## Links\n\n**Hyper-V VmSwitch RCE Vulnerability**\n\n\n-----\n\n[https://www.youtube.com/watch?v=025r8_TrV8I](https://www.youtube.com/watch?v=025r8_TrV8I)\n\n**Windows Sandbox**\n\n[https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849](https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849)\n\n**Windows Sandbox WSB Configuration**\n\nhttps://docs.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandboxconfigure-using-wsb-file\n\n**Windows Containers**\n\n**NTFS Attributes**\n\n[https://www.urtech.ca/2017/11/solved-all-ntfs-attributes-defined/](https://www.urtech.ca/2017/11/solved-all-ntfs-attributes-defined/)\n\n**Reparse Point**\n\n[https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-points](https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-points)\n\n**NTFS Documentation**\n\n[https://dubeyko.com/development/FileSystems/NTFS/ntfsdoc.pdf](https://dubeyko.com/development/FileSystems/NTFS/ntfsdoc.pdf)\n\n**NTFS Reparse Tags**\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea2b9d423b1ee4\n\n**VHDx Parent Locator**\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-vhdx/b6332a98-624d-46b8-bd0eb77b573662f9\n\n**FS Filter Driver – Communication between User Mode and Kernel Mode**\n\nhttps://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/communication-between-user-mode-andkernel-mode\n\n**Hunting for Bugs in Windows Mini-Filter Drivers**\n\n[https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html](https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html)\n\n**Hyper-V Storvsp.sys-Strovsc.sys Flow**\n\n[https://www.linkedin.com/pulse/hyper-v-architecture-internals-pravin-gawale/](https://www.linkedin.com/pulse/hyper-v-architecture-internals-pravin-gawale/)\n\n**RDMA Explained by Microsoft**\n\nhttps://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v-virtual-switch/rdma-and-switchembedded-teaming\n\n## Appendix A\n\n\n-----\n\n**Windows Sandbox JSON configuration for vmwp**\n\n\n-----\n\n```\n{\n  \"Owner\": \"Madrid\",\n  \"SchemaVersion\": {\n    \"Major\": 2,\n    \"Minor\": 1\n  },\n  \"VirtualMachine\": {\n    \"StopOnReset\": true,\n    \"Chipset\": {\n      \"Uefi\": {\n        \"BootThis\": {\n          \"DeviceType\": \"VmbFs\",\n          \"DevicePath\": \"\\\\EFI\\\\Microsoft\\\\Boot\\\\bootmgfw.efi\"\n        }\n      }\n    },\n    \"ComputeTopology\": {\n      \"Memory\": {\n        \"SizeInMB\": 1024,\n        \"Backing\": \"Virtual\",\n        \"BackingPageSize\": \"Small\",\n        \"FaultClusterSizeShift\": 4,\n        \"DirectMapFaultClusterSizeShift\": 4,\n        \"EnablePrivateCompressionStore\": true,\n        \"EnableHotHint\": true,\n        \"EnableColdHint\": true,\n        \"SharedMemoryMB\": 2048,\n        \"SharedMemoryAccessSids\": [\"S-1-5-21-2542268174-3140522643-1722854894-1001\"],\n        \"EnableEpf\": true,\n        \"EnableDeferredCommit\": true\n      },\n      \"Processor\": {\n        \"Count\": 4,\n        \"SynchronizeHostFeatures\": true,\n        \"EnableSchedulerAssist\": true\n      }\n    },\n    \"Devices\": {\n      \"Scsi\": {\n        \"primary\": {\n          \"Attachments\": {\n            \"0\": {\n              \"Type\": \"VirtualDisk\",\n              \"Path\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\Sandboxes\\\\025b00c8-849a-4e00-bcb2c2b8ec698bab\\\\sandbox.vhdx\",\n              \"CachingMode\": \"ReadOnlyCached\",\n              \"NoWriteHardening\": true,\n              \"DisableExpansionOptimization\": true,\n              \"IgnoreRelativeLocator\": true,\n              \"CaptureIoAttributionContext\": true\n            }\n          }\n        }\n      },\n      \"HvSocket\": {\n        \"HvSocketConfig\": {\n          \"DefaultBindSecurityDescriptor\": \"D:P(A;;FA;;;SY)\",\n          \"DefaultConnectSecurityDescriptor\": \"D:P(A;;FA;;;SY)\",\n          \"ServiceTable\": {\n            \"befcbc10-1381-45ab-946e-b1a12d6bce94\": {\n              \"BindSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n\n```\n\n-----\n\n```\n            },\n            \"7d2e0620-034a-4438-b0fd-ae27fc0172a1\": {\n              \"BindSecurityDescriptor\": \"D:P(A;;FA;;;SY)(A;;FA;;;S-1-5-83-0)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\"\n            },\n            \"a715ac94-b745-4889-9a0f-772d85a3cfa4\": {\n              \"BindSecurityDescriptor\": \"D:P(A;;FA;;;LS)\",\n              \"ConnectSecurityDescriptor\": \"D:P(A;;FA;;;LS)\",\n              \"AllowWildcardBinds\": true\n            },\n            \"7b3014c3-284a-40d4-a97f-9d23a75c6a80\": {\n              \"BindSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"AllowWildcardBinds\": true\n            },\n            \"e97910d9-55bb-455e-9170-114fdfce763d\": {\n              \"BindSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"AllowWildcardBinds\": true\n            },\n            \"e5afd2e3-9b98-4913-b37c-09de98772940\": {\n              \"BindSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\",\n              \"AllowWildcardBinds\": true\n            },\n            \"abd802e8-ffcc-40d2-a5f1-f04b1d12cbc8\": {\n              \"BindSecurityDescriptor\": \"D:P(A;;FA;;;SY)(A;;FA;;;BA)(A;;FA;;;S-1-153-3)(A;;FA;;;S-1-5-21-2542268174-3140522643-1722854894-1001)\",\n              \"ConnectSecurityDescriptor\": \"D:P(D;;FA;;;WD)\"\n            },\n            \"f58797f6-c9f3-4d63-9bd4-e52ac020e586\": {\n              \"BindSecurityDescriptor\": \"D:P(A;;FA;;;SY)\",\n              \"ConnectSecurityDescriptor\": \"D:P(A;;FA;;;SY)\",\n              \"AllowWildcardBinds\": true\n            }\n          }\n        }\n      },\n      \"EnhancedModeVideo\": {\n        \"ConnectionOptions\": {\n          \"AccessSids\": [\"S-1-5-21-2542268174-3140522643-1722854894-1001\"],\n          \"NamedPipe\": \"\\\\\\\\.\\\\pipe\\\\025b00c8-849a-4e00-bcb2-c2b8ec698bab\"\n        }\n      },\n      \"GuestCrashReporting\": {\n        \"WindowsCrashSettings\": {\n          \"DumpFileName\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\Dumps\\\\025b00c8-849a-4e00-bcb2-c2b8ec698bab.dmp\",\n          \"MaxDumpSize\": 4362076160,\n          \"DumpType\": \"Full\"\n        }\n      },\n      \"VirtualSmb\": {\n        \"Shares\": [{\n          \"Name\": \"os\",\n          \"Path\": \"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\BaseImages\\\\0949cec78165-4167-8c7d-67cf14eeede0\\\\BaseLayer\\\\Files\",\n          \"Options\": {\n            \"ReadOnly\": true,\n            \"TakeBackupPrivilege\": true,\n            \"NoLocks\": true,\n            \"ReparseBaseLayer\": true,\n\n```\n\n-----\n\n```\n                   p,\n            \"PseudoDirnotify\": true,\n            \"SupportCloudFiles\": true\n          }\n        }],\n        \"DirectFileMappingInMB\": 2048\n      },\n      \"Licensing\": {\n        \"ContainerID\": \"00000000-0000-0000-0000-000000000000\",\n        \"PackageFamilyNames\": []\n      },\n      \"Battery\": {},\n      \"KernelIntegration\": {}\n    },\n    \"GuestState\": {\n      \"GuestStateFilePath\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\Sandboxes\\\\025b00c8-849a-4e00-bcb2c2b8ec698bab\\\\sandbox.vmgs\"\n    },\n    \"RestoreState\": {\n      \"TemplateSystemId\": \"97d51d87-c49d-488f-bc29-33017f7703b9\"\n    },\n    \"RunInSilo\": {\n      \"SiloBaseOsPath\":\n\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Containers\\\\BaseImages\\\\0949cec7-8165-4167-8c7d67cf14eeede0\\\\BaseLayer\\\\Files\",\n      \"NotifySiloJobCreated\": true,\n      \"FileSystemLayers\": [{\n        \"Id\": \"8264f677-40b0-4ca5-bf9a-944ac2da8087\",\n        \"Path\": \"C:\\\\\",\n        \"PathType\": \"AbsolutePath\"\n      }]\n    },\n    \"LaunchOptions\": {\n      \"Type\": \"None\"\n    },\n    \"GuestConnection\": {}\n  },\n  \"ShouldTerminateOnLastHandleClosed\": true\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-11 - Playing in the (Windows) Sandbox.pdf"
    ],
    "report_names": [
        "2021-03-11 - Playing in the (Windows) Sandbox.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535572,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653707444,
    "ts_modification_date": 1653707444,
    "files": {
        "pdf": "https://archive.orkl.eu/d5963f6d4211a05b97741c193a624c1595cb7c7d.pdf",
        "text": "https://archive.orkl.eu/d5963f6d4211a05b97741c193a624c1595cb7c7d.txt",
        "img": "https://archive.orkl.eu/d5963f6d4211a05b97741c193a624c1595cb7c7d.jpg"
    }
}