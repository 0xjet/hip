{
    "id": "0c90c503-3809-4444-80f4-eed72b3d5a85",
    "created_at": "2023-01-12T15:05:19.433943Z",
    "updated_at": "2025-03-27T02:05:58.393543Z",
    "deleted_at": null,
    "sha1_hash": "5ae984b4e98ff93e4278ac159fb180ff06a250d9",
    "title": "2008-05-18 - Rustock.C – Unpacking a Nested Doll",
    "authors": "",
    "file_creation_date": "2022-05-28T19:29:53Z",
    "file_modification_date": "2022-05-28T19:29:53Z",
    "file_size": 349143,
    "plain_text": "# Rustock.C – Unpacking a Nested Doll\n\n**[blog.threatexpert.com/2008/05/rustockc-unpacking-nested-doll.html](http://blog.threatexpert.com/2008/05/rustockc-unpacking-nested-doll.html)**\n\nUnpacking Rustock.C is a challenging task. If you are tired of boring crosswords or Sudoku\npuzzles and feel like your brain needs a real exercise, think about reversing Rustock.C satisfaction (or dissatisfaction, depending on the result) is guaranteed.\n\n[Rustock.C story began a week ago – when one AV vendor has publicly disclosed the new](http://www.drweb.com/upload/6c5e138f917290cb99224a8f8226354f_1210062403_DDOCUMENTSArticales_PRDrWEB_RustockC_eng.pdf)\ndetails about the latest variant of Rustock. As soon as the sample of Rustock.C has been\nobtained, many researchers started their journey into the center of the rootkit.\n\nFirst quick look at the driver code reveals a simple decoder. In spite of being simple, it is still\na good idea to debug it to see what exactly it produces on its output.\n\nIn order to debug a driver, different malware researchers prefer different tools – in our case\nlet’s start from WinDbg configured to debug a VMWare session running in debug mode. For\n[more details of this set up, please read this article.](http://silverstr.ufies.org/lotr0/windbg-vmware.html)\n\nThe very first question one might ask is how to put a breakpoint into the very beginning of the\ndriver code?\n\nSome researchers would hook IopLoadDriver() in the kernel to intercept the code before it\njumps into the driver, in order to step in it by slowly tracing single instructions.\n\n\n-----\n\nA simple known trick however, is to build a small driver (and keep it handy) with the first\ninstruction being “int 3”. Once such driver is loaded, the debugger will pop up with the Debug\nBreakpoint exception. Stepping out from that place leads back into the kernel’s\nIopLoadDriver() function – right into the point that follows the actual call to the driver. Now,\nthe actual call instruction address is known - a new breakpoint needs to be placed in it.\n\nWith the new breakpoint in place, it is time to load Rustock.C driver in the virtual environment\ncontrolled by the debugger. Once loaded, the debugger breaks at the call instruction in\nkernel’s IopLoadDriver(). Stepping into the driver, placing a new breakpoint at the end of its\ndecoder and letting it run until it hits that breakpoint allows to unpack the code that was\nhidden under that decoder.\n\nThe first-layer decoder reveals us a code with a myriad of fake instructions, blocks of code\nthat do nothing, random jumps from one place to another – a huge maze created with only\none purpose – to complicate threat analysis by obfuscating and hiding the truly malicious\ncode.\n\nTracing that code within debugger might be easier with the disassembly listing of that code in\nthe user mode.\n\nOne way to get that listing is to reconstruct the driver as a PE-executable by resetting the\nDLL bit in its PE-header characteristics and changing its subsystem from Native (0x01) to\nWindows GUI (0x02) to make debugger happy to load it. Another way is to reconstruct a\nnormal PE-executable by building and compiling an Assembler program that includes the\ntop-level Rustock’s decryptor followed by a large stub of encoded data simply copied from\nthe original driver code.\n\nBuidling a PE-executable equivalent of the Rustock.C driver helps to study the code behind\nthe first-layer decoder. Such program can now be loaded into a user-mode debugger, such\nas OllyDbg, the first-layer decoder can now be debugged in the user mode to unpack the\ncode behind it. Once unpacked, the entire process can be dumped and reloaded into the\ndisassembler.\n\nAt this point of analysis, the code behind the first-layer decoder reveals interesting\noccurrences of DRx registers manipulations, IN/OUT instructions, “sidt/lidt” instructions, and\nsome other interesting code pieces - for example a code that parses an MZ/PE header:\n\n00011C0A cmp word ptr [eax], ‘ZM’\n00011759 mov bx, [eax+3Ch]\n00011E31 cmp dword ptr [eax+ebx], 'EP'\n\nThe code in general now looks like “spaghetti” – and still, it’s just a second-layer decryptor.\nThe picture below shows you its execution flow – every grey “box” in it represents a standalone function:\n\n\n-----\n\nPlacing the breakpoints for all the “interesting” instructions in the driver code is a good idea.\nThe addresses need to offset by a difference between the driver’s entry point reported with a\nkernel debugger and the entry point of the driver’s PE-executable equivalent, as reported by\nthe user mode debugger.\n\nWith the new breakpoints in place, the code will firstly break on the instruction that searches\nfor an MZ-header of the ntkrnlpa.exe:\n\ncmp word ptr [eax], ‘ZM’\n\nIn order to find the image base of ntkrnlpa.exe, Rustock.C looks up the stack to find the\nreturn address inside ntkrnlpa.exe. It rounds that address up and starts sliding it backwards\nby the amount of the section alignment until it reaches the image base of ntkrnlpa.exe.\n\nOnce the start of ntkrnlpa.exe is found, the driver then parses its PE-header, locates and\nparses the export table.\n\nPrevious variants of Rustock contained explicit imports from ntkrnlpa.exe. This time,\nRustock.C obtains kernel’s exports dynamically, by parsing its memory image – the same\ntrick was widely used by the user-mode malware in the past, when the kernel32.dll’s exports\nwere dynamically obtained during run-time by using the hash values of the export names.\n\nThe fragment of Rustock’s second-layer decryptor below parses kernel’s export table:\n\n\n-----\n\nNow that it knows kernel exports, the driver calls ExAllocatePoolWithQuotaTag() to allocate\n228,381 bytes in the non-paged pool ( tagged as “Info@”).\n\nThe rootkit code then copies itself into that pool and jumps in it to continue its execution from\nthat place.\n\nDuring the execution, Rustock.C repeats the same trick again – it allocates another 278,528\nbytes in the non-paged pool, copies itself into it and transfers there control. This way, the\ncode of the driver \"migrates\" from one memory location to another. While the \"abandoned\"\nareas preserve the severely permutated code, and thus, not easily suitable for scanning, the\naddresses of the newly allocated areas in the non-paged pool cannot be predicted. Thus,\neven if the infected driver and its address range in the kernel are established, it is still not\nclear where the final \"detectable\" form of Rustock.C code is located.\n\nFollowing memory allocation tricks, Rustock employs “lidt/sidt” instructions to patch IDT.\nExecuting “lidt” in WinDbg might crash the operating system in the virtual machine.\nTherefore, “lidt” instruction needs to be skipped (by patching EIP with the address of the next\ninstruction).\n\nAnother set of instructions that are better to be skipped with the debugger, are DRx-registers\nmanipulations. By zeroing the debug registers Dr0-Dr3 and the debug control register DR7,\nthe rootkit might attempt to cause trouble for SoftIce – any suspicious instructions need to be\nskipped for safety reasons.\n\nFollowing that, Rustock.C driver reads the configuration of devices on a PCI bus by using\nIN/OUT instructions with the PCI_CONFIG_ADDR and PCI_CONFIG_DATA constants. It\nthen starts a few nested loops to read certain data from the devices attached to a PCI bus.\n\n\n-----\n\nThe read data is then hashed with the purpose of creating a footprint that uniquely identifies\nhardware of the infected host.\n\nDebugging the Rustock.C driver is easier if the successful code execution path is saved into\na map (e.g. a hand-written one). Every successfully terminated loop should be reflected in\nthat map. The relative virtual addresses recorded in it allow skipping long loops when the\ncode is analysed again from the beginning – they should be considered “the milestones” of\nthe code flow. If a wrong move crashes the system – the virtual machine needs to be\nreverted to a clean snapshot, debugger restarted, and the entire debugging process\nrepeated by using the successful “milestones” from the map.\n\nThe map of the execution “milestones” should tell what to skip, when to break, what to patch,\nwhere to jump – in order to navigate the code successfully through all the traps that the\nauthors of Rustock has set against emulators, debuggers, run-time code modifications, etc.\n\nWhenever the driver attempts to access data at a non-existing address, the code needs to\nbe unwound backwards to establish the reason why the address is wrong. In most cases,\nfollowing the logics of the code helps to understand what values should replace the wrong\naddresses.\n\nFor example, at one point of execution, Rustock.C driver crashes the session under WinDbg\nby calling the following instruction while the contents of ESI is not a valid address:\n\nmov esi, dword ptr [esi]\n\nIn order to “guide” the code through this crash, the driver needs to be re-analysed from the\nvery beginning to check if this instruction is successfully called before the failure and if it\ndoes, what the valid contents of ESI is at that moment of time.\n\nAs stated above, the PE-executable equivalent of the driver loaded into the user-mode\ndebugger and disassembler helps to navigate through the code, search instructions in it,\nsearch for the code byte sequences, place comments - a good helper for the kernel\ndebugging.\n\nThe code of Rustock.C debugged at this stage is a 2nd-layer decryptor that will eventually\nallocate another buffer in the non-paged pool where it will decrypt the final, but still,\nridiculously permutated “spaghetti” code of the driver – this time, with the well-recognizable\nstrings, as shown in the following dumps:\n\n\n-----\n\n-----\n\n[PS: Special thanks to Frank Boldewin for exchanging his tips and ideas with me.](http://www.reconstructer.org/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2003 - 2009/2008-05-18 - Rustock.C – Unpacking a Nested Doll.pdf"
    ],
    "report_names": [
        "2008-05-18 - Rustock.C – Unpacking a Nested Doll.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535919,
    "ts_updated_at": 1743041158,
    "ts_creation_date": 1653766193,
    "ts_modification_date": 1653766193,
    "files": {
        "pdf": "https://archive.orkl.eu/5ae984b4e98ff93e4278ac159fb180ff06a250d9.pdf",
        "text": "https://archive.orkl.eu/5ae984b4e98ff93e4278ac159fb180ff06a250d9.txt",
        "img": "https://archive.orkl.eu/5ae984b4e98ff93e4278ac159fb180ff06a250d9.jpg"
    }
}