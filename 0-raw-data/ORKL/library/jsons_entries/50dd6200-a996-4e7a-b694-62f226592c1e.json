{
    "id": "50dd6200-a996-4e7a-b694-62f226592c1e",
    "created_at": "2023-01-12T15:06:55.128092Z",
    "updated_at": "2025-03-27T02:05:57.764615Z",
    "deleted_at": null,
    "sha1_hash": "d554e80f6f12a7b9ea6ec8ffd1c745a3760fbdcc",
    "title": "2019-05 - Hancitor's Packer Damystified",
    "authors": "",
    "file_creation_date": "2022-05-29T01:27:52Z",
    "file_modification_date": "2022-05-29T01:27:52Z",
    "file_size": 1378963,
    "plain_text": "# Hancitor's packer demystified\n\n**uperesia.com/hancitor-packer-demystified**\n\n\n-----\n\nPosted by Felix Weyne, May 2019.\nAuthor contact: [Twitter |](https://www.uperesia.com/referer.php?id=twitter) LinkedIn\nTags: Hancitor, Chanitor, packer, unpacking, spaghetti code, shellcode, control flow\nobfuscation, import table reconstruction, reflective PE loading, YARA\n\n[It has been a while since I have written a blog - I have been working on some tools and other](https://github.com/felixweyne/)\nprojects instead - so I decided to have another go at it . A while ago, the Twitter users\n[0verfl0w_ and](https://0ffset.net/reverse-engineering/malware-analysis/reversing-hancitor-again/) [Vitali published some nice blogs on the Hancitor malware. This made me](https://www.vkremez.com/2018/11/lets-learn-in-depth-reversing-of.html)\ncurious to also have a look at the malware family.\n\nThe Hancitor malware family has been around for a while and its core job is to download and\nexecute additional malware. In order to succeed at its job, the malware must succeed in\nbeing run undetected on the machine and thus effectively stay under the radar of security\nsoftware such as an antivirus. One of Hancitor's endeavors to bypass antivirus is by making\nuse of a booby trapped Office document and to instruct Office to inject the Hancitor binary in\na legitimate Windows process. This method has been documented well by the Airbus\nsecurity team and has been used untill approximately the summer of 2018. Around that time,\nthe Hancitor crew has shifted its infection mechanism by making their spammed Office\ndocuments download a packed executable to disk. An executable written to disk usually gets\ninspected/scanned by antivirus, yet the Hancitor malware has been reasonably successful in\nevading being detected (initially) as malicious.\n\n\n-----\n\nHancitor s evasive success can be partly attributed to the packer/crypter being used. In this\n**blog I will do a (technical) deep dive into Hancitor's packer, which has not changed**\n**much since the summer of 2018. I will discuss how the packer protects its payload**\n**and how it tries to thwart analysis. At the end of this blog, I'll demonstrate how this**\n**packer has also been used by many other malware families in the past.**\nThe packer\n\n[The below image gives an overview of the sample which I'll discuss in this blog. Although I](https://www.virustotal.com/#/file/e4ad65ade2f04e05a886b398ef08261f5858b15cc822ef29b604cecaac3036b5/detection)\nwill be discussing a specific packed Hancitor sample, the information in this blog is\napplicable to many other packed Hancitor samples, as the packer has not changed much\nbetween the many SPAM campaigns (particularly the first layer of the packer has been very\nconsistent). In [this archive (password=infected) a collection of many packed Hancitor](https://www.uperesia.com/resources/hancitor_packer_samples.zip)\n[samples can be found (many thanks to Brad and](https://twitter.com/malware_traffic) [James for sharing the samples on Twitter!).](https://twitter.com/James_inthe_box)\n\n\n-----\n\nImage one: Overview of the packed Hancitor sample\n\n**In order to keep the analysis organized, I have a divided the packed sample into**\n**\"modules\" (pieces) based on functionality. For each module I have added the address**\n**of the first and last relevant assembly instruction, such that interested readers can**\n**use this blog as a reference when unpacking the sample themselves in a debugger.**\nFor those who are interested in the disassembled code, but don't want to plow through the\nentire sample in a debugger, I have added a commented assembly output per module.\nLastly, for the malware hunters among us, I have added a YARA rule for the packer in the\nblog's addendum.\n\nModule 0: [link to commented disassembled code (start address: 0x0040266D)](https://www.uperesia.com/resources/packer_module0.html)\nModule 1: [link to commented disassembled code (start address: 0X00405177)](https://www.uperesia.com/resources/packer_module1.html)\nModule 2: [link to commented disassembled code (start address: 0X004087A1)](https://www.uperesia.com/resources/packer_module2.html)\n\n\n-----\n\nModule 3: [link to commented disassembled code (start address:](https://www.uperesia.com/resources/packer_module3.html)\nstart_mem_region+0x3E4)\nModule 4: [link to commented disassembled code (start address: 0X004015F0)](https://www.uperesia.com/resources/packer_module4.html)\nModule 5: [link to commented disassembled code (start address: 0X00401520)](https://www.uperesia.com/resources/packer_module5.html)\nModule 6: [link to commented disassembled code (start address:](https://www.uperesia.com/resources/packer_module6.html)\nstart_mem_region+0x2BF0)\n\nSpaghetti code\n\nThe packed Hancitor executables always start by executing random, non-dodgy functions.\n[We will define this code region as module zero (disassembled code). Putting random code](https://www.uperesia.com/resources/packer_module0.html)\nnear the executables' entrypoint makes them look unique, that is to say, for security products\nwhich (understandably) only parse/emulate executables partially because of performance\nreasons. The random code ends by jumping to the next module, module one (disassembled\ncode).\n\nThe disassembled output of the module one section is hard to interpret. The packer's\n**author has broken the linear sequence of assembly instructions by reordering the**\n**instructions and connecting them to each other via JUMP instructions, as can be seen**\n**in image two. Additionally, between each instruction random instructions - which will**\n**never be executed - are placed.**\n\nImage two: Spaghetti code which decrypts the next module\n\n\n-----\n\nThis technique, known as spaghetti code, bypasses static detection techniques which rely on\nthe malicious instructions being placed consecutively on each other. The goal of the\nspaghetti code is to change the memory protection of a part of the executable (to which we\nwill referrer as module two) and then to decrypt said part via a simple XOR loop. Once the\nrelevant part is decrypted, the code execution is transferred to that part via a simple JMP\nEAX instruction.\n\nResolving APIs\n\n[Module two (disassembled code) has three tasks: resolve the addresses of APIs which will](https://www.uperesia.com/resources/packer_module2.html)\nbe used in the next module, map itself and the next module in a newly allocated memory\nregion and hunt for the start of the next module in the new memory region (delimited by the\n70C5BA88 byte marker).\n\nI will not discuss how the API addresses are resolved, as the packer will use a similar\ntechnique in a later module, at which point I'll discuss the technique in depth (see paragraph:\nreconstruct import table). The most important part of the API resolving code is the list of APIs\nwhich are resolved:\n\nkernel32_GetProcAddress\nkernel32_GetModuleHandleA\nkernel32_LoadLibraryA\nkernel32_VirtualAlloc\nkernel32_VirtualFree\nkernel32_OutputDebugStringA\nntdll_memset\nntdll_memcpy\n\nThe APIs in the list will be used to map DLLs into the packer's process memory, to resolve\nadditional API addresses and to allocate and free memory regions. The thing in module\n**two that stands out the most is the way (API) strings are embedded inline with the**\n**assembly code, as can be seen on image three.**\n\n\n-----\n\nImage three: Data (API names) inline with the assembly code\n\nMost compilers will place strings in a region which is different from the region where the\nassembly code resides. To get the memory address of the inline string, the assembly\n**code makes use of a simple trick: it will execute a CALL $+5 instruction (a procedure**\n**call where the destination is the subsequent instruction).**\n\nExecuting a CALL instruction will result in the return address (i.e. the address of the\ninstruction that follows the call instruction) being pushed on the stack. The return address is\nimmediately retrieved by executing a POP EAX instruction (pop the top of the stack into the\nEAX register). The return address is thus pointing to the location of the POP instruction.\nBecause the assembly is interested in the start address of the inline placed string, three\nbytes needs to be added to return address (skip the POP and JMP short instructions). We\ncan see the assembly code performing this action as follows: ADD EAX, 3. It is useful to\nremember this little trick in your short-term memory, because it will also be used in the next\nmodule.\n\n\n-----\n\nDecrypt next layer\n\n[Module three (disassembled code) starts by overwriting code at three locations, as can be](https://www.uperesia.com/resources/packer_module3.html)\nseen on image four. These locations correspond with the packed executable's entrypoint\n(module zero), the start of the spaghetti code (module one) and the start of module two (the\naddresses are described on image one).\n\nImage four: Overwriting three previous modules\n\nThe code then continues by decrypting the next layer (the next modules), by making use of\nthe APIs listed in the previous paragraph. Once the next layer has been decrypted, the\nmodule resolves the addresses of the APIs which will be used in the next layer (image five),\nto which we will refer as layer two.\n\n\n-----\n\nImage five: addresses of resolved APIs in memory\n\nAfter having resolved the API addresses, the code does something somewhat odd: it\npatches values in the PE header and it overwrites the section header. This action doesn't\nmake much sense to me, because I believe these values are of no use once the executable\nhas been mapped into memory ? Nevertheless, this action helps us in our efforts to dump\nthe second layer executable from memory, as it seems like we have the correct PE header\nas well as the decrypted code.\n\n\n-----\n\nImage six: overwriting section headers bug\n\nUpon inspecting the dumped second layer executable, I noticed that the section headers\nwere shifted. When we look at the code responsible for overwriting the section\n**headers, we can notice an interesting bug in the packer. Remember the inline data trick I**\ndiscussed in the previous paragraph? It looks like the packer's author made a small mistake\nwhile using it to overwrite the section header .\n\nBecause the JMP instruction following the POP EAX instruction in module three consists of\nfive bytes (it consisted of only three bytes in module two), the start address of the section\nheader data is off by three bytes (image six). Instead of adding three bytes to the EAX\nregister, the code should've added six bytes. If we correct this mistake while debugging, we\n[get a correct dump of layer two (which I have added here).](https://www.uperesia.com/resources/hancitor_packer_samples.zip)\n\nModule three ends by destroying its own code. The destruction is performed via a simple\nloop which overwrites every address in the module with zero valued bytes (image seven).\n\n\n-----\n\nImage seven: self destruction code in action (as seen via IDA debugger)\n\nGiven the fact that the module is mapped in a newly allocated memory region (image one),\none can only guess why the packer's author didn't just free the region. Maybe (s)he wanted\nto avoid analysis techniques which dump code by hooking VirtualFree calls? Maybe (s)he\nwanted to keep the modules nicely separated (VirtualFree can not be called before execution\nis transferred to another region/module, as a VirtualFree call would destroy the code\nresponsible for said execution transferring)? After destroying everything, a jump is made to\nthe entrypoint of the second layer executable, to which I will refer as module four.\n\nDecrypt Hancitor binary\n\n[Module four (disassembled code) contains a debug-thwarting trick which can be confusing if](https://www.uperesia.com/resources/packer_module4.html)\nyou are not aware of what is happening. The module makes use of a technique called control\nflow obfuscation. The goal of the trick is to make use of a Windows API call in such a\n**way that the main code flow does not continue on the code following the API call.**\n**Instead the main code flow is transferred to a callback function which is executed**\n**during the API call. If you are not aware of this trick, you would probably jump over**\n**each instruction in module four which would result in loosing control over the**\n**execution, since no debugger points are set in the registered callback function. Image**\neight shows how the Hancitor packer makes use of this technique.\n\n\n-----\n\nImage eight: Control flow obfuscation by making use of Window Procedures\n(RegisterClassExA & CreateWindowExA)\n\n[The callback function is registered as part of a Windows Class Ex structure, which is passed](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassexa)\nas an argument to the RegisterClassExA API call. When a call is made to the\nDispatchMessageA API, the callback function gets executed. The callback function contains\na jump to the fifth module.\n\n[Module five (disassembled code) does not contain many interesting functions. The most](https://www.uperesia.com/resources/packer_module5.html)\nimportant function is a function which decrypts and decompresses the Hancitor executable (if\nyou are still reading at this point, you probably wondered when we would ever get to this\nstage ). The encrypted executable is stored as data inside layer two, the decryption is\nperformed by three simple XOR loops, as can be seen on the decompiled function code on\nimage nine.\n\n\n-----\n\nImage nine: decompiled decryption code\n\nThe decompression is performed via a function call to RtlDecompressBuffer (note that the\naddress of this API was resolved in module three, the puzzle pieces are starting to come\ntogether!). The decrypted executable is mapped into a newly allocated memory region, to\nwhich we will refer to as module six.\n\nReconstruct import table\n\n[Module six (disassembled code) contains the last functionality of the packer. The goal of the](https://www.uperesia.com/resources/packer_module6.html)\n**module is to emulate behavior which normally is performed by the Windows Loader:**\n**map libraries (DLLs) into the process' address space, resolve the addresses of APIs**\n**and store those addresses in the executable's Import Address Table (IAT). This**\nbehavior needs to be emulated by the packer because it has loaded the Hancitor executable\ndirectly into memory. If the Hancitor executable were to have been loaded from disk, the\nWindows Loader would have done its job. Obviously, loading the malware from disk is not\nfeasible, as it would be detected quickly by security products. Code similar to the code in this\nmodule is frequently present in malware and greyhat tools which load an executable\nreflectively. As the reader will notice, the reverse engineered code discussed below for\n[example looks very similar to a leaked Gozi/IFSB code part (mirror) which is described by](https://github.com/gbrindisi/malware/blob/667b44f64edcd1c5e8c42489b8e767813a589158/windows/gozi-isfb/AcDll/stubs.c#L30-L132)\nthe author as: 'a routine used to create, initialize and execute [a] PE-image without a file'.\n\n\n-----\n\nI am not a suitable person to write referral material about PE structures . However, for the\nsake of giving some background information on the actions which are performed in module\nsix, I'll try to briefly write down some pointers about the PE's import tables.\n\nThe IAT is a table of pointers to function (API) addresses which is used as a lookup table\nwhen an application is calling a function. The addresses of functions inside a library (DLL)\nare not static but change when updated versions of the DLL are released, so applications\ncannot be built using hardcoded function addresses. In order for the Windows Loader to\nknow which libraries and functions it needs to import, they obviously need to be defined\ninside the executable. This is where the Import Directory Table (IDT) comes into play.\n\nThe IDT contains structures which contain information about a DLL which a PE file imports\nfunctions from. Two important fields in those structures are FirstThunk: a relative virtual\naddress (RVA) inside the IAT, and OriginalFirstThunk: a RVA of the Import Lookup Table\n(ILT). The Import Lookup Table contains an array of RVAs, each RVA points to a hint/name\ntable (source: [PE format, Microsoft). As the name suggests, the hint/name table contains the](https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format)\nname of a function which needs to be imported.\nModule six starts by calculating the in-memory start address of the Import Directory Table. It\ncalculates said address by parsing the PE header of the in-memory mapped Hancitor\nexecutable, as can be seen on image ten. First, the executable searches for the start offset\nof the PE header, a value which is stored at the e_lfanew field (ref: [PE offsets). The module](https://www.aldeid.com/wiki/PE-Portable-executable)\nthen jumps to a certain offset from the start of the PE header to locate a field whose value\ncontains the RVA of the Import Directory. Because this value is a relative offset, the value\nneeds to be added to the in-memory start of the mapped executable. This resulting\ncalculation contains the in-memory start of the Import Directory Table.\n\n\n-----\n\nImage ten: Resolve address of kernelbase & find address of import directory table\n\nFor module six to be able to map libraries (used by Hancitor) into the process' address\nspace, it needs the memory location of kernel32's LoadLibrary and GetProcAddress\nfunctions. To retrieve the function addresses, the packer needs to figure out at which address\n(inside its own process address space) the kernel32 library is mapped. For this hunt the\npacker relies on a small piece of shellcode which reads the Process Environment Block\n[(PEB). The below slide from a fifteen-years-old presentation about shellcode explains how](https://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-chong.pdf)\nthe PEB is used to resolve kernel32's base address.\n\n\n-----\n\nImage eleven: Fifteen-year-old presentation discussing shellcode which retrieves the\nkernel32 base memory address\n\nAfter having resolved the in-memory location of the LoadLibrary and GetProcAddress\nfunctions, module six reads the FirstThunk and the OriginalFirstThunk field values inside the\nImport Directory Table (image twelve, image thirteen).\n\nImage twelve: Parsing Import Directory Table for OriginalFirstThunk & FirstThunk fields\n\n**By enumerating these fields, the module knows via the corresponding hint/name**\n**tables which functions need to be imported. The libraries are imported via calls to the**\n**LoadLibrary function, the function addresses are resolved via calls to the**\n**GetProcAddress function. The module writes the function addressess into Hancitor's**\nImport Address Table. The result of this action can be seen on image fourteen (note that the\n[Import Directory field values can be nicely visualised via Hasherezade's PE bear). A](https://hshrzd.wordpress.com/pe-bear/)\ngraphical overview of the relation between the fields and import tables discussed in this\nparagraph can be seen on image thirteen.\n\nThis action is the last action by the packer, the execution can now *finally* be transferred to\nHancitor's code\n\n\n-----\n\nImage thirteen: Graphical overview of the relations between the import tables.\n\nSource: [dematte.org.](http://www.dematte.org/2006/03/04/InterceptingWindowsAPIs.aspx)\n\n\n-----\n\nImage fourteen: Parsing the Import Directory Table (IDT) with the ultimate goal of filling the\nImport Address Table (IAT)\n\nOld packer, still does the job\n\nDuring the hunt for additional packed Hancitor samples (using the below YARA rule), I\nnoticed that some of the packed samples were protecting a malware family which didn't look\nlike Hancitor at all . [One sample protected some kind of Delphi malware which embedded](https://www.virustotal.com/#/file/cd3cff88a9be3624de40018397b4844d7da3be67f959de2d271bde98b5674ce8/detection)\nthe names of Turkish banks. The malware looked very similar to the ATMZombie malware,\n[which Kaspersky blogged about (mirror). When we look at an ATMZombie sample which is](https://securelist.com/atmzombie-banking-trojan-in-israeli-waters/73866/)\n[explicitly mentioned in the Kaspersky blog, we can see that the packer of the mentioned](https://www.virustotal.com/#/file/8662e3c0c564b85ee4af656dcf76fdafdacb41a2f13a3de509bca16b2e8928c7/detection)\nsample is the same packer as the one which is discussed in this blog. Another packed\nsample which I noticed during my hunt protected a shellcode loader. The sample is\n[mentioned in a Proofpoint blog (mirror) as a Metasploit Stager which in turn downloaded](https://www.uperesia.com/img/articles/hancitor/proofpoint_wmi_intruder.png)\nCobalt Strike.\n\n\n-----\n\n**At this point it became clear to me that this packer has been around for a time, and**\n**that it isn't exclusively used by Hancitor. In fact, when I kept digging, I found many**\n**samples of (old) malware families which were packed by this packer. Some examples**\n**[are: Zeus/Panda banker,](https://www.virustotal.com/#/file/b8ce490bc146c058abad4b6593d9e08adcf0b9d374616bca25df78e92ae7d753/detection)** **[Cryptowall,](https://www.virustotal.com/#/file/bf352825a70685039401abde5daf1712fd968d6eee233ea72393cbc6faffe5a2/detection)** **[Ramnit,](https://www.virustotal.com/#/file/e64ffc50c920105c03a1f0cf40dc015bdba23db13021bf12321b5145fc21485c/detection)** **[PoSeidon and](https://www.virustotal.com/gui/file/50524041df82a17a0e28d1e6ed7cb205e4c427e552c25cb36cc4dfab13c121df/detection)** **[Gootkit. All packed and](https://www.virustotal.com/gui/file/c839f4cca442547096bad395e58eee579f6d73e31d6549ee0859ff2a64a1304e/detection)**\n[unpacked malware samples can be found here (password=infected). When I launched a](https://www.uperesia.com/resources/hancitor_packer_samples.zip)\n[YARA search on parts of the encrypted module two bytes (there are 255 variations, as a](https://www.uperesia.com/resources/hancitor_packer_like_YARA.txt)\nsingle byte XOR key is used in the spaghetti code of module one), I found older versions of\n[the packer. One example is a packed Qadars sample. The sample is mentioned as an IOC in](https://www.virustotal.com/#/file/04f0feb7ab6b68dabbebc3da2082afabacbe488bca3464f3da985a9b4d9c7c2c/detection)\nan [ESET article (mirror) from 2013. This suggests that the packer has been around for at](https://www.welivesecurity.com/2013/12/18/qadars-a-banking-trojan-with-the-netherlands-in-its-sights/)\nleast five years already.\n\nAddendum: YARA Rule\n\n\n-----\n\n```\nimport pe \nrule hancitor_packer\n{\n meta:\n  author = \"Felix Weyne, 2019\"\n  description = \"Hancitor packer spaghetti code (loose match)\"\n  hash1= \"37f6f1f59bf7952fd7182deeb07d4cd0d367dd59\"\n  hash2= \"2508b3211b066022c2ab41725fbc400e8f3dec1e\"\n  hash3= \"3855f6d9049936ddb29561d2ab4b2bf26df7a7ff\"\n  hash4= \"e9ec4a4fb6f5d143b304df866bba4277cd473843\"\n strings:\n  //E9=JMP, EB=JMP SHORT, 71/0F=JNO\n  $change_sp={89 EC (E9|EB|71|0F)} //mov  esp,ebp\n  $2={5D (E9|EB|71|0F)} //pop  ebp\n  $3={BF ?? ?? ?? 00 (E9|EB|71|0F)} //mov  edi, 274C67h\n  $4={81 ?? ?? ?? ?? 00 (E9|EB|71|0F)} //add  edi, 17E792h\n  $5={57 (E9|EB|71|0F)} //push  edi\n  $6={BE ?? ?? 00 00 (E9|EB|71|0F)} //mov  esi, 88Bh\n  $7={6A 00 (E9|EB|71|0F)} //push  0\n  $8={54 (E9|EB|71|0F)} //push  esp\n  $9={6A 40 (E9|EB|71|0F)} //push  40h\n  $mov_eax={B8 ?? ?? ?? 00 (E9|EB|71|0F)} //mov  eax, 5ADBh\n  $add_eax={05 ?? ?? ?? 00 (E9|EB|71|0F)} //add  eax, 0E525h\n  $12={8B 00 (E9|EB|71|0F)} //mov  eax, [eax]\n  $13={FF D0 (E9|EB|71|0F)} //call  eax\n  $ecx_zero={B9 00 00 00 00 (E9|EB|71|0F)} //mov  ecx, 0\n  $xor={30 07 (E9|EB|71|0F)}  //xor  [edi], al\n  $18={41 (E9|EB|71|0F)} //inc  ecx\n  $19={47 (E9|EB|71|0F)} //inc  edi   \n  $20={39 F1 (E9|EB|71|0F)} //cmp  ecx, esi \n  $21={58 (E9|EB|71|0F)} //pop  eax\n condition:\n  filesize < 110KB\n  and pe.is_32bit()\n  and #add_eax >= 3\n  and #mov_eax >= 3\n  and all of them\n  and for any i in (1..#xor):($change_sp in (@xor[i][email protected][i]+400))\n  and for any i in (1..#xor):($ecx_zero in (@xor[i][email protected][i]+300))\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-05 - Hancitor's Packer Damystified.pdf"
    ],
    "report_names": [
        "2019-05 - Hancitor's Packer Damystified.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536015,
    "ts_updated_at": 1743041157,
    "ts_creation_date": 1653787672,
    "ts_modification_date": 1653787672,
    "files": {
        "pdf": "https://archive.orkl.eu/d554e80f6f12a7b9ea6ec8ffd1c745a3760fbdcc.pdf",
        "text": "https://archive.orkl.eu/d554e80f6f12a7b9ea6ec8ffd1c745a3760fbdcc.txt",
        "img": "https://archive.orkl.eu/d554e80f6f12a7b9ea6ec8ffd1c745a3760fbdcc.jpg"
    }
}