{
    "id": "70294ba7-f443-4ffe-a1da-61bab1350210",
    "created_at": "2023-02-02T02:08:56.533209Z",
    "updated_at": "2025-03-27T02:12:11.074799Z",
    "deleted_at": null,
    "sha1_hash": "f3ba31b89a6b9c515901bcfa141be8907f9a372a",
    "title": "2014-02-03 - Needle in a haystack",
    "authors": "",
    "file_creation_date": "2023-02-01T07:40:21Z",
    "file_modification_date": "2023-02-01T07:40:21Z",
    "file_size": 2333022,
    "plain_text": "# Needle in a haystack\n\n**virusbulletin.com/virusbulletin/2014/02/needle-haystack**\n\n2014-02-03\n\n### Gabor Szappanos\n\nSophos, Hungary\nEditor: Helen Martin\n**Abstract**\n\nSometimes what looks like a genuine MP3 encoder library, and even works as a functional\nencoder, actually hides malicious code deep amongst a pile of clean code. Gabor\nSzappanos reveals the lengths to which one piece of malware goes to hide its tracks.\n\nMalware authors engaged in Advanced Persistent Threat (APT) operations put great effort\ninto making sure their creations live up to their name and achieve persistence over the\ncourse of months or years; in order to do so, the threats must remain undetected by security\nproducts.\n\nThe authors try both to conceal the presence of the threats on infected systems and to hide\ntheir code from analysis and detection. Most crimeware authors achieve the latter by\napplying sophisticated execryptors and protectors to their code.\n\nOver the past year, however, we have spotted a different approach: malicious code is\ncompiled into an open source library, hidden among a large pile of clean library code, with\nonly a single export pointing to the trojan functionality. The deployment and progression of\nthis malware spans about two years now – however its versioning suggests that its\ndevelopment started longer ago than that.\n\nThis malware doesn’t take anything for granted: even common system tools like rundll32.exe\nand wscript.exe, which are present on all Windows systems, are carried with the installer and\ndropped when needed.\n\nThe malware goes to great lengths to cover its tracks. All of the string constants that could\nreveal the nature of the backdoor are protected with strong encryption. Additionally, the\nbackdoor itself is disguised as a legitimate MP3 encoder library. In fact, it is a legitimate and\nfunctional MP3 library – and a bit more besides.\n\n## Exploited carrier workbook\n\n\n-----\n\nIn a handful of cases we have been able to identify the original exploited document that\nleads to the system infection. At the time of finalizing this paper, three exploited workbooks\nhave been found that install this threat.\n\nAll of them are protected Excel workbooks with the default password (for more details see\n\n[1]). In short: the workbooks are password protected (that is, checked before opening). It is\npossible to leave the password field blank – in which case Excel encrypts the content using\nthe default password: ‘VelvetSweatshop’. On the other hand, if a workbook is protected with\nexactly this password, Excel assumes that there is no password, and opens the document\ntransparently. As a result, the document content is encrypted and hidden from normal\nanalysis, but opening it will execute the shellcode without further prompting.\n\nThe workbooks exploit the CVE-2012-0158 vulnerability, which triggers the execution of\nshellcode within the document.\n\nAfter the workbooks are opened, the intended operation is to open a decoy workbook – a\nclean file that grabs the attention of the user while malicious activities proceed in the\nbackground. The themes of the decoys give us some idea as to the areas of interest of the\ntarget audience of this malware distribution.\n\n### Workbook 1\n\n**Filename: 300** .xls (rough translation: ‘300 petitioners cosigned.xls’)\n\n**File size: 839756 bytes**\n\n**SHA1: 066998e20ad44bc5f1ca075a3fb33f1619dd6313**\n\n**MD5: 5c370923119f66e64a5f9accdd3d5fb**\n\nThis does not display any decoy document, just closes the Excel window. Nevertheless, the\nshellcode execution proceeds.\n\nIf the file was opened, it would display a workbook with a list of names, gender, region and\nphone numbers of Chinese individuals.\n\n\n-----\n\n**Figure 1. Decoy content for 066998e20ad44bc5f1ca075a3fb33f1619dd6313.**\n\n### Workbook 2\n\n**Filename: sample.xls**\n\n**File size: 638912 bytes**\n\n**SHA1: e5e183e074d26416d7e6adfb14a80fce6d9b15c2**\n\n**MD5: 2066462274ed6f6a22d8275bd5b1da2b**\n\n\n-----\n\n**Figure 2. Decoy content for e5e183e074d26416d7e6adfb14a80fce6d9b15c2.**\n\n### Workbook 3\n\n**Filename: LIST OF KEY OFFICIALS IN THE DND PROPER.xls**\n\n**File size: 638912 bytes**\n\n**SHA1: d80b527df018ff46d5d93c44a2a276c03cd43928**\n\n**MD5: 80857a5541b5804895724c5d42abd48f**\n\nThis decoy workbook contains information about key officials in the Philippines Department\nof National Defense (DND).\n\n\n-----\n\n**Figure 3. Decoy content for d80b527df018ff46d5d93c44a2a276c03cd43928.**\n\nIn the rest of this article, unless specified otherwise, we refer to the operation resulting from\ninfection via Workbook 1 – but the overall operations (dropped filenames, registry keys,\nbackdoor functions) are the same in each case.\n\nWhen mining our sample collection for related samples we were able to spot other examples\n– however, in these instances the initial dropper was not available for our analysis, only the\ntemporary dropper executables or the final payloads could be located. In these cases we\ndon’t have complete information about the system infection, but it is safe to assume that\nsimilar exploitation schemes were utilized.\n\n## Shellcode\n\nThe shellcode features an interesting anti-debugging trick that I have come across quite\nregularly in APT samples lately. Most of the Windows API functions are resolved and called\nnormally, but some of the critical ones (such as WinExec and CreateFile) are not entered at\nthe entry address (as stored in the kernel32.dll export table), but five bytes after it instead.\n\n\n-----\n\nThese functions are responsible for the most critical operations of the code (dropping the\npayload executable and executing it), which would reveal unusual activity in the scope of an\nordinary Excel process.\n\nAs most tracers and debuggers would place the breakpoint or hijack function right at the\nentry of the API function, skipping the first few bytes is a good way to avoid API tracing and\ndebugging.\n\n**Figure 4. Anti-tracing trick.**\n\n[(Click here to view a larger version of Figure 4.)](https://www.virusbulletin.com/uploads/images/figures/2014/02/Lame-4-large.jpg)\n\nThe same happens with WriteFile and GlobalAlloc, but this time, depending on whether or\nnot there is a call right at the entry of the function, the displacement will be either five or\nseven bytes.\n\n\n-----\n\n**Figure 5. Anti-tracing hook initialization.**\n\nAs a result of the functions not being entered at their usual entry points, the first few\ninstructions are missed. As these are still essential for the stack management, the code is\ncompensated within the shellcode, where a standard function prologue (stack frame creation\npush ebp, move ebp,esp) is executed.\n\nFor system functions compiled with standard compilers, the first few instructions are fixed on\nthe entry point, but anything after that can’t be taken for granted. The shellcode can’t enter\nfurther than five or seven bytes into the API function, otherwise it could end up in the middle\nof a multi byte instruction, easily crashing the application.\n\n**Figure 6. Anti-tracing used in practice.**\n\nIn order to extract the embedded executable, the shellcode needs to find the carrier\nworkbook. It does this using the fact that, at the time of the exploitation, the workbook must\nremain open in Excel. The code enumerates all possible handles and tries to call GetFileSize\non each of them. If the function fails, because the handle does not belong to an open file (it\n\n\n-----\n\ncould belong to many other objects such as directory, thread, event or registry key), or the\nfile size is smaller than the expected size of the workbook (minus the appended encrypted\nEXE), 1de10h bytes, it skips to the next handle value.\n\nNext, it reads four bytes from offset 0x1de00; the value found there should be equal to the\nsize of the carrier workbook (this time including the appended EXE).\n\nAt this position, in the appended content following the OLE2 document structure, a short\nheader is stored that contains the full carrier workbook size, the embedded EXE size and the\nembedded decoy workbook size. These values are used by the shellcode. The encrypted\nEXE content follows.\n\nOrganizing the code and structure in this manner makes the carrier/dropper workbook\ncomponent and the dropped payload executable completely independent – it is possible to\nreplace the payload with a new variant without changing a bit in the carrier encrypted\nworkbook.\n\n**Figure 7. Appended header and payload.**\n\nOnce the hosting workbook is found, the code proceeds with decoding the embedded\nexecutable (using a one byte XOR algorithm with running key plus an additional one byte\nXOR with a fixed key), saving it to a file named ‘Winword.exe’ in the %TEMP% directory,\nthen executing it. At this point, the decoy workbook content is dropped (using the same\nalgorithm: one byte XOR with running key plus one byte XOR with fixed key, only this key\ndiffers from the one used in decoding the EXE).\n\n## Temporary dropper\n\nThis file is the dropper and installer for the final payload. It has an initial anti-debug layer.\n\nThe address of the GetVersion function is patched in the import table, to contain an internal\nfunction virtual address instead of an imported function address, which is normally expected\nat that position. The code around the entry point uses the stored value to redirect execution:\n\n\n-----\n\n```\nmov large fs:0, esp\n\nsub esp, 58h\n\npush ebx\n\npush esi\n\npush edi\n\nmov [ebp-18h], esp\n\ncall ds:dword_41A188\n\n```\nThe execution actually goes to the address stored at dword_41A188, which is the memory\nlocation 00402440.\n\nThe program has only one export, LoadLibrary, thus when the operating system loads the\nprogram and resolves the external dependencies, this value, stored within the import table\nregion, remains intact. The trick completely fools IDA Pro, which can’t be convinced that the\nlocation is an internal position and not an external import. This makes static analysis a bit\nmore complicated. The necessary imported function addresses are later resolved\ndynamically by the initialization code of the dropper.\n\nThe major procedures of the dropper program are not called directly; instead, the trojan\nbuilds a function pointer table, and calls to procedures are performed via indexing into this\ntable, as shown in Figure 8.\n\n**Figure 8. Building the function pointer table.**\n\nThe key procedures are identified by having the following instruction sequence near the\nprologue:\n\n\n-----\n\n```\npush ebp\n\nmov ebp, esp\n\npush eax\n\nmov eax, 12547908h\n\npop eax\n\n```\nThe value stored in the EAX register is a combination of two elements: 1254 is the marker;\n7908 is the numeric ID for the function.\n\nThe entry is located by searching backwards for the standard prologue:\n```\npush ebp\n\nmov ebp, esp\n\n\n```\nThe procedures are later invoked by calling indexes from the function pointer table (see\nFigure 9).\n\n**Figure 9. Using the function pointer table.**\n\nWinword.exe normally drops three major components into the system:\n\n%PROGRAM FILES%\\Common Files\\ODBC\\AppMgmt.dll – the final payload\n(Windows DLL file)\n\n%PROGRAM FILES%\\Common Files\\DBEngin.EXE – a copy of rundll32.exe (a clean\n_Windows system file, used for executing the payload)_\n\n%PROGRAM FILES%\\Common Files\\WUAUCTL.EXE – another rundll32.exe (a clean\n_Windows system file, used for executing the payload)._\n\nAdditionally, two registry export files named jus*.tmp (with a random number added after jus)\nare dropped into %TEMP%. These are the old and new hives of the\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\AppMgmt registry location – a location at which\n\n\n-----\n\nthe trojan registers itself in order to execute automatically upon each system boot. Saving\nthe hives to a file makes it possible to modify the registry in one shot using RegRestoreKey.\n\nAlso dropped is a 301,445 byte long jus*.tmp file, which is a CAB archive containing the\npayload DLL.\n\nThe execution flow takes a different route if the presence of running security products is\ndetected. The following process names are checked: KVMonXP.exe, RavMonD.exe,\nRsTray.exe, ccsvchst.exe, QQPCTray.exe, zhudongfangyu.exe, 360sd.exe, 360Tray.exe,\nzatray.exe, bdagent.exe, ksafetray.exe, kxetray.exe and avp.exe. However, not all of the\nsecurity processes are checked at the same time – only a couple of selected ones are\nchecked before each major operation.\n\nAs an example, if zatray.exe, RsTray.exe or RavMonD.exe is running, then AppMgmt.dll is\nnot dropped and instead, the 400MB vbstdcomm.nls is created (the large size is due to an\nenormous amount of junk appended at the end of the file). Finally, a VBScript file is created\nand executed with the help of a dropped copy of wscript.exe (both files are saved to the\n%TEMP% folder, as lgt*.tmp.vbs and lgt*.tmp.exe, respectively). An encrypted copy of\nWinword.exe is created in %CommonProgramFiles%\\ODBC\\odbc.txt, using a one byte XOR\nalgorithm with key 0xCC. Vbstdcomm.nls, which serves as a backup installer, takes the\nencrypted copy of Winword.exe, decodes it and simply executes.\n\nThe dropper registers AppMgmt.dll as a service. This is not achieved by creating a new\nservice entry, rather by taking over the role of an already installed service, AppMgmt,\nredirecting the service DLL from the clean library to the dropped malware payload:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\AppMgmt\\Parameters: ServiceDll\n\n%SystemRoot%\\System32\\appmgmts.dll -> C:\\Program Files\\Common\nFiles\\ODBC\\AppMgmt.dll\n\nIn addition, the start up mode is changed from auto to demand in the location:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\AppMgmt: Start\n\nThen it changes the error control settings in the registry key\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\AppMgmt:ErrorControl from normal (this would\nmean that if the driver fails to load, the start up process proceeds, but a warning is displayed)\nto ignore (in this case if the driver fails to load, start up proceeds, and no warning is\ndisplayed). The change is designed to avoid raising suspicion, should start up fail for any\nreason.\n\nFinally, it executes the dropped DLL by executing net start AppMgmt.\n\n\n-----\n\n## Payload\n\nWe have identified five different versions of the final payload. Two of them were replicated\nfrom the exploited workbooks detailed earlier; the other three were found when we were\ndigging through our sample collection searching for samples with similar characteristics.\n\nThe main characteristics of the five variants are summarized in Table 1 shown below\n(detailed descriptions of the columns are provided later in this section).\n\n[(Click here to view a larger version of Table 1.)](https://www.virusbulletin.com/uploads/images/figures/2014/02/Lame-Table1-large.jpg)\n\nThis DLL is built from the LAME MP3 encoder source [2]. The full library has been compiled,\nand in addition, a couple of malicious exports have been added to the code:\nlame_set_out_sample and lame_get_out_sample.\n\n\n-----\n\n**Figure 10. Additional malicious imports.**\n\nNote that the names of the additional exports are strikingly similar to the legitimate exports,\nlame_set_out_samplerate and lame_get_out_samplerate, which are present in the LAME\nsource – thus it is not very obvious that the additional exports belong to something\ncompletely different.\n\nOne of the extra exports, lame_get_out_sample, is missing from newer versions of the\nmalware. However, the function that would invoke this export is still present in the code.\nClearly, the code was not cleaned up properly when the export was removed.\n\n\n-----\n\nThe backdoor contains many encrypted strings, one of which serves as an internal version\nnumber. In Table 1 we list the version numbers as they appear in the code. Collected\ninformation suggests that the most widely distributed was version 2.3(UDP), making its\nrounds in the wild in early December 2012.\n\nTable 1 also lists the date when we first saw each particular backdoor variant – either arriving\nin our collection, reported in cloud look ups or seen elsewhere on the Internet. Additionally,\nthe compilation date is listed, as taken from the PE header.\n\nAn interesting quirk comes from the usage of the LAME source: one of the original source\nfunctions, beVersion(), inserts the compilation date into the data section of the executable.\n\n**Figure 11. Compilation date in code.**\n\nThis provides an independent method of determining the creation date of the variant aside\nfrom the PE time stamp. There was no trick, however – the two dates matched in all cases.\n\nIt is notable that there is always a large gap between the compilation date and the date of the\nfirst observation of each variant. There are several possible reasons for this:\n\nSmall-scale targeted attacks don’t provide much telemetry information; the smaller the\nnumber of targets, the slimmer our chances of finding out about their infection.\n\nThe trojan looks very similar to a real LAME encoder library; infected victims are\nreluctant to submit it for analysis.\n\nThere may be an intentional delay (some sort of testing period) in the release process\nof the malware.\n\n\n-----\n\nThe backdoor uses different approaches for handling C&C communication. Earlier versions\nused the standard Windows socket communication functions (send, recv) to exchange data\nwith the C&C server. The newer versions linked the UDT data transfer library (available from\nudt.sourceforge.net) for communication. The versioning of the variants suggests that some\ntime around March 2012, the code forked into a socket communication branch (TCP) and a\nUDT powered communication branch (UDP).\n\nThe backdoor features all the basic functionality that is expected from a piece of malware of\nits class. It is able to:\n\nCreate screenshots\n\nGet drive type (FAT, FAT32, NTFS, CDFS) and free space\n\nEnumerate files and directories and send the list to the server\n\nRename files\n\nCreate directories\n\nDelete files.\n\nThe last character of the ModuleFileName (without extension) is checked on execution: if it is\nnot of one of the expected values – ‘T’, ‘t’ (executed via net.exe), ‘R’, ‘r’, ‘N’, ‘n’ (executed via\nDBEngin.EXE), ‘2’ (rundll32.exe), ‘L’ or ‘l’ – it builds and injects a simple piece of code to\nload AppMgmt.dll properly.\n\nFor this purpose, it creates a new suspended process (with command line:\nc:\\windows\\system32\\svchost.exe), calls GetThreadContext on it, and gets EAX from the\nCONTEXT structure, using the fact that in the case of a suspended process the EAX register\nalways points to the entry point of the process. Then it writes the starter code to this entry\npoint and resumes the thread. The suspended thread is not visible in the process list at that\npoint. This way, the trojan can escape analysis, if not executed in a natural form, and still\nexecute.\n\nConfiguration data is stored in a file named DbTrans.db, XOR encrypted with key 0x58.\n\nThe string constants (API names, DLL names, process names) are all stored in encrypted\nform using a strong encryption algorithm. The strings are stored aligned (Unicode strings to\n0x90 bytes, ASCII strings to 0x38 bytes boundary), decrypted in eight byte chunks using the\nDES ECB algorithm, and referenced by IDs that index into this name pool. The encrypted\nstrings contain padding bytes at the end, where zeros are encoded.\n\n\n-----\n\nThe strings are decrypted on the fly before being used and filled with zeros after use. This\nway there are no visible strings in the memory that would give away more information about\nthe internals of the backdoor.\n\nThere are three nearly identical encryption functions (and accompanying encrypted string\ntables and encryption keys) in all variants: one is for the Unicode strings, one for the ordinary\nASCII constants, and a third one for the Windows API function names (also stored as ASCII\nstrings) that are used in the code. We found that only the encryption keys were different for\nthe three cases. The following key seeds remain the same throughout the variants:\n\nFor ASCII strings: 82 C5 D3 59 2B 38 00 00\n\nFor Unicode strings: 5E 97 CC 42 8E CD 00 00\n\nFor API function names: 5B 5F CB 8D E5 F5 00 00\n\nIn the last version, the two ASCII functions are merged into a single function.\n\nThe C&C addresses are hard coded into the backdoor, and protected with a simple byte wise\nXOR (key:0x58) encryption. This is an interesting choice, given that all other string constants\nare protected with a string DES algorithm – perhaps the server addresses are changed more\nfrequently (indeed, there is a minimal overlap between the different versions’ C&C\naddresses) than the authors are comfortable with re-encrypting the strings – but no evidence\nwas found for it in the few samples we have found.\n\nThe string constants of the code are referenced by IDs and decrypted on the fly. However,\nthere are strings that are never used in the code. These could belong to an earlier or internal\nversion, and simply have not been cleaned up from the string pool, as illustrated in this\nexample:\n\n\n-----\n\n```\npush 9  ;,lame_set_out_sample\n\ncall Get_String_A\n\npush 0Ah ;,\n\ncall Get_String_A\n\npush 1Eh ; DBEngin.exe\n\ncall Get_String_A\n\npush 8  ; EXPL.EXE\n\npop eax\n\ncall Get_String_W\n\npush offset s_expl_exe\n\npush [ebp+var_254]\n\ncall StrCpyW\n\npush 8\n\npop eax\n\nxor ecx, ecx\n\ncall set_mem\n\npush ebx\n\npush 2\n\ncall CreateToolhelp32Snapshot\n\n```\nSome of these strings could be internal configuration options for the development\nenvironment (I suspect these are access details to an internal server):\n```\nkazafei\n\n192.168.1.98\n\n80\n\n```\nOther strings provide status information about the current operation of the backdoor:\n```\nClient RecvData Complete\n\nA File Search Task has start already !!!\n\nFile Search Task Success\n\nFile Search Task Failed, Please Check\n\nUpload Client Failed\n\nUpload Client Success\n\nDelete File Success\n\nDelete File Failed\n\nRename File Success\n\nRename File Failed\n\nCreate Folder Success\n\nCreate Folder Failed\n\n\n```\nA few constants indicate undocumented or debug functionality:\n```\nX:\\Windows\\System32\\rundll32.exe\n\nX:\\Windows\\msacm32.drv\n\nMagicMutex\n\nD:\\Resume.dll\n\nD:\\delete.dll\n\nD:\\delete2.dll\n\n```\n\n-----\n\n## Conclusion\n\nWhen looking into APT attack scenarios, one has to be extra careful. Often we see that clean\nprograms and libraries are dropped onto systems to hide the operation of malicious\napplications [3]. But sometimes, what looks to be a genuine MP3 encoder library, and even\nworks as a functional encoder, actually hides malicious additions buried deep in a large pile\nof clean code. One has to be very thorough when it comes to targeted attacks, and one\ncannot afford to make any assumptions.\n\n### Bibliography\n\n[1] Baccas, P. When is a password not a password? When Excel sees “VelvetSweatshop”.\n[http://nakedsecurity.sophos.com/2013/04/11/password-excel-velvet-sweatshop/.](https://nakedsecurity.sophos.com/2013/04/11/password-excel-velvet-sweatshop/)\n\n[2] LAME (Lame Aint an MP3 Encoder). [http://sourceforge.net/projects/lame/.](https://sourceforge.net/projects/lame/)\n\n[3] Szappanos, G. Targeted malware attack piggybacks on Nvidia digital signature.\n[http://nakedsecurity.sophos.com/2013/02/27/targeted-attack-nvidia-digital-signature/.](https://nakedsecurity.sophos.com/2013/02/27/targeted-attack-nvidia-digital-signature/)\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner In this article he explains how he recompiled\n\n\n-----\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2014 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2014/2014-02-03 - Needle in a haystack.pdf"
    ],
    "report_names": [
        "2014-02-03 - Needle in a haystack.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1675303736,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1675237221,
    "ts_modification_date": 1675237221,
    "files": {
        "pdf": "https://archive.orkl.eu/f3ba31b89a6b9c515901bcfa141be8907f9a372a.pdf",
        "text": "https://archive.orkl.eu/f3ba31b89a6b9c515901bcfa141be8907f9a372a.txt",
        "img": "https://archive.orkl.eu/f3ba31b89a6b9c515901bcfa141be8907f9a372a.jpg"
    }
}