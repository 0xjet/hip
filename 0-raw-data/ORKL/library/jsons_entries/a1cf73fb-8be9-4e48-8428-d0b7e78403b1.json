{
    "id": "a1cf73fb-8be9-4e48-8428-d0b7e78403b1",
    "created_at": "2023-01-12T15:08:28.055099Z",
    "updated_at": "2025-03-27T02:09:18.114914Z",
    "deleted_at": null,
    "sha1_hash": "1a1b9b964f86bc84a65dcabe1e77f530ae4e6a6d",
    "title": "2021-09-02 - Anatomy and Disruption of Metasploit Shellcode",
    "authors": "",
    "file_creation_date": "2022-05-28T23:37:00Z",
    "file_modification_date": "2022-05-28T23:37:00Z",
    "file_size": 1114086,
    "plain_text": "# Anatomy and Disruption of Metasploit Shellcode\n\n**[blog.nviso.eu/2021/09/02/anatomy-and-disruption-of-metasploit-shellcode/](https://blog.nviso.eu/2021/09/02/anatomy-and-disruption-of-metasploit-shellcode/)**\n\nSeptember 2, 2021\n\n[In April 2021 we went through the anatomy of a Cobalt Strike stager and how some of its](https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/)\nsignature evasion techniques ended up being ineffective against detection technologies. In\nthis blog post we will go one level deeper and focus on Metasploit, an often-used framework\ninteroperable with Cobalt Strike.\n\nThroughout this blog post we will cover the following topics:\n\n1. The shellcode’s import resolution – How Metasploit shellcode locates functions from\n\nother DLLs and how we can precompute these values to resolve any imports from\nother payload variants.\n2. The reverse-shell’s execution flow – How trivial a reverse shell actually is.\n3. Disruption of the Metasploit import resolution – A non-intrusive deception technique (no\n\nhooks involved) to have Metasploit notify the antivirus (AV) of its presence with high\nconfidence.\n\nFor this analysis, we generated our own shellcode using Metasploit under version `v6.0.30-`\n```\ndev . The malicious sample generated using the command below had as resulting SHA256\n\n```\nhash of `3792f355d1266459ed7c5615dac62c3a5aa63cf9e2c3c0f4ba036e6728763903 and`\n[is available on VirusTotal for readers willing to have a try themselves.](https://www.virustotal.com/gui/file/3792f355d1266459ed7c5615dac62c3a5aa63cf9e2c3c0f4ba036e6728763903/detection)\n```\nmsfvenom -p windows/shell_reverse_tcp -a x86 > shellcode.vir\n\n```\nThroughout the analysis we have renamed functions, variables and offsets to reflect their\nrole and improve clarity.\n\n## Initial Analysis\n\nIn this section we will outline the initial logic followed to determine the next steps of the\nanalysis (import resolution and execution flow analysis).\n\n\n-----\n\nWhile a typical executable contains one or more entry-points (exported functions, TLScallbacks, …), shellcode can be seen as the most primitive code format where initial\nexecution occurs from the first byte.\n\nAnalyzing the generated shellcode from the initial bytes outlines two operations:\n\n1. The first instruction at ① can be ignored from an analytical perspective. The `cld`\n\noperation clears the direction flag, ensuring string data is read on-wards instead of\nback-wards (e.g.: `cmd vs` `dmc ).`\n2. The second `call operation at ② transfers execution to a function we named` `Main,`\n\nthis function will contain the main logic of the shellcode.\n\nFigure 1: Disassembled shellcode calling the `Main function.`\nWithin the `Main function, we observe additional calls such as the four ones highlighted in`\nthe trimmed figure below (③, ④, ⑤ and ⑥). These calls target a yet unidentified function\nwhose address is stored in the `ebp register. To understand where this function is located,`\nwe will need to take a step back and understand how a `call instruction operates.`\n\nFigure 2: Disassembly of the `Main function.`\nA `call instruction transfers execution to the target destination by performing two`\noperations:\n\n1. It pushes the return address (the memory address of the instruction located after the\n```\n   call instruction) on the stack. This address can later be used by the ret instruction\n\n```\nto return execution from the called function (callee) back to the calling function (caller).\n\n\n-----\n\n2. It transfers execution to the target destination (callee), as a `jmp instruction would.`\n\nAs such, the first `pop instruction from the` `Main function at ③ stores the caller’s return`\naddress into the `ebp register. This return address is then called as a function later on,`\namong others at offset `0x99,` `0xA9 and` `0xB8 (④, ⑤ and ⑥). This pattern, alongside the`\npresence of a similarly looking `push before each` `call tends to suggest the return`\naddress stored within `ebp is the dynamic import resolution function.`\n\n[Without diving into unnecessary depth, a “normal” executable (e.g.: Portable Executable on](https://en.wikipedia.org/wiki/Portable_Executable)\nWindows) contains the necessary information so that, once loaded by the Operating System\n(OS) loader, the code can call imported routines such as those from the Windows API (e.g.:\n```\nLoadLibraryA ). To achieve this default behavior, the executable is expected to have a\n\n```\ncertain structure which the OS can interpret. As shellcode is a bare-bone version of the code\n(it has none of the expected structures), the OS loader can’t assist it in resolving these\nimported functions; even more so, the OS loader will fail to “execute” a shellcode file. To\ncope with this problem, shellcode commonly performs a “dynamic import resolution”.\n\nOne of the most common techniques to perform “dynamic import resolution” is by hashing\neach available exported function and compare it with the required import’s hash. As\nshellcode authors can’t always predict whether a specific DLL (e.g.: `ws3_32.dll for`\nWindows Sockets) and its exports are already loaded, it is not uncommon to observe\nshellcode loading DLLs by calling the `LoadLibraryA function first (or one of its`\nalternatives). Relying on `LoadLibraryA (or alternatives) before calling other DLLs’ exports`\nis a stable approach as these library-loading functions are part of `kernel32.dll, one of`\nthe few DLLs which can be expected to be loaded into each process.\n\nTo confirm our above theory, we can search for all `call instructions as can be seen in the`\nfollowing figure (e.g.: using IDA’s `Text... option under the` `Search menu). Apart from the`\nfirst call to the `Main function, all instances refer to the` `ebp register. This observation,`\nalongside well-known constants we will observe in the next section, supports our theory that\nthe address stored in `ebp holds a pointer to the function performing the dynamic import`\nresolution.\n\nFigure 3: All\n```\ncall instructions in the shellcode.\n\n```\n\n-----\n\nThe abundance of calls towards the `ebp register suggests it indeed holds a pointer to the`\nimport resolution function, which we now know is located right after the first call to `Main .`\n\n## Import Resolution Analysis\n\nSo far we noticed the instructions following the initial call to `Main play a crucial role as what`\nwe expect to be the import resolution routine. Before we analyze the shellcode’s logic, let us\nanalyze this resolution routine as it will ease the understanding of the remaining calls.\n\n## From Import Hash to Function\n\nThe code located immediately after the initial call to `Main is where the import resolution`\nstarts. To resolve these imports, the routine first locates the list of modules loaded into\nmemory as these contain their available exported functions.\n\nTo find these modules, an often leveraged shellcode technique is to interact with the Process\nEnvironment Block (shortened as `PEB ).`\n\nIn computing the Process Environment Block (abbreviated PEB) is a data structure in\nthe Windows NT operating system family. It is an opaque data structure that is used by\nthe operating system internally, most of whose fields are not intended for use by\nanything other than the operating system. […] The PEB contains data structures that\napply across a whole process, including global context, startup parameters, data\nstructures for the program image loader, the program image base address, and\nsynchronization objects used to provide mutual exclusion for process-wide data\nstructures.\n\n_[wikipedia.org](https://en.wikipedia.org/wiki/Process_Environment_Block)_\n\nAs can be observed in figure 4, to access the `PEB, the shellcode accesses the Thread`\nEnvironment Block ( TEB ) which is immediately accessible through a register (⑦). The `TEB`\nstructure itself contains a pointer to the `PEB (⑦). From the` `PEB, the shellcode can locate`\nthe `PEB_LDR_DATA structure (⑧) which in turn contains a reference to multiple double-`\nlinked module lists. As can be observed at (⑨), the Metasploit shellcode leverages one of\nthese double-linked lists ( InMemoryOrderModuleList ) to later iterate through the\n```\nLDR_DATA_TABLE_ENTRY structures containing the loaded module information.\n\n```\nOnce the first module is identified, the shellcode retrieves the module’s name\n( BaseDllName . Buffer ) at ⑩ and the buffer’s maximum length (\n```\nBaseDllName . MaximumLength ) at ⑪ which is required as the buffer is not guaranteed to\n\n```\nbe `NULL -terminated.`\n\n\n-----\n\nFigure 4: Disassembly of the initial module retrieval.\nOne point worth highlighting is that, as opposed to usual pointers\n( TEB.ProcessEnvironmentBlock, `PEB.Ldr, …), a double-linked list points to the next`\nitem’s list entry. This means that instead of pointing to the structures’ start, a pointer from the\nlist will target a non-zero offset. As such, while in the following figure the\n```\nLDR_DATA_TABLE_ENTRY has the BaseDllName property at offset 0x2C, the offset from\n\n```\nthe list entry’s perspective will be `0x24 ( 0x2C-0x08 ). This can be observed in the above`\nfigure 4 where an offset of `8 has to be subtracted to access both of the` `BaseDllName`\nproperties at ⑩ and ⑪.\n\nFigure 5: From `TEB to` `BaseDllName .`\nWith the DLL name’s buffer and maximum length recovered, the shellcode proceeds to\n[generate a hash. To do so, the shellcode performs a set of operations for each ASCII](https://en.wikipedia.org/wiki/ASCII#Printable_characters)\ncharacter within the maximum name length:\n\n1. If the character is lowercase, it gets modified into an uppercase. This operation is\n\nperformed according to the character’s ASCII representation meaning that if the value\nis `0x61 or higher ( a or higher),` `0x20 gets subtracted to fall within the uppercase`\nrange.\n2. The generated hash (initially `0 ) is rotated right (ROR) by 13 bits ( 0x0D ).`\n3. The upper-cased character is added to the existing hash.\n\n\n-----\n\nFigure 6: Schema depicting the hashing loops of `KERNEL32.DLL ‘s first character ( K ).`\nWith the repeated combination of rotations and additions on a fixed registry size (32 bits in\n```\nedi ‘s case), characters will ultimately start overlapping. These repeated and overlapping\n\n```\ncombinations make the operations non-reversible and hence produces a 32-bit\nhash/checksum for a given name.\n\nOne interesting observation is that while the `BaseDllName in` `LDR_DATA_TABLE_ENTRY is`\nUnicode-encoded (2 bytes per character), the code treats it as ASCII encoding (1 byte per\ncharacter) by using `lodsb (see ⑫).`\n\nFigure 7: Disassembly of the module’s name hashing routine.\nThe hash generation algorithm can be implemented in Python as shown in the snippet below.\nWhile we previously mentioned that the `BaseDllName ‘s buffer was not required to be`\n```\nNULL -terminated per Microsoft documentation, extensive testing has showed that NULL \n```\ntermination was always the case and could generally be assumed. This assumption is what\nmakes the `MaximumLength property a valid boundary, similarly to the` `Length property.`\nThe following snippet hence expects the data passed to `get_hash to be a Python` `bytes`\nobject generated from a `NULL -terminated Unicode string.`\n\n\n-----\n\n```\n# Helper function for rotate right on 32 bit architectures\ndef ror(number, bits):\n  return ((number >> bits) | (number << (32 - bits))) & 0xffffffff\n# Define hashing algorithm\ndef get_hash(data):\n  # Initialize hash to 0\n  result = 0\n  # Loop each character\n  for b in data:\n    # Make character uppercase if needed\n    if b < ord('a'):\n      b -= 0x20\n    # Rotate DllHash right by 0x0D bits\n    result = ror(result, 0x0D)\n    # Add character to DllHash\n    result = (result + b) & 0xffffffff\n  return result\n\n```\nThe above functions could be used as follows to compute the hash of `KERNEL32.DLL .`\n```\n# Define a NULL-terminated base DLL name\nname = 'KERNEL32.DLL\\0'\n# Encode it as Unicode\nencoded = name.encode('UTF-16-LE')\n# Compute the hash\nvalue = hex(get_hash(encoded))\n# And print it ('0x92af16da')\nprint(value)\n\n```\nWith the DLL name’s hash generated, the shellcode proceeds to identify all exported\nfunctions. To do so, the shellcode starts by retrieving the `LDR_DATA_TABLE_ENTRY ‘s`\n```\nDllBase property (⑬) which points to the DLL’s in-memory address. From there, the\nIMAGE_EXPORT_DIRECTORY structure is identified by walking the Portable Executable’s\n\n```\nstructures (⑭ and ⑮) and adding the relative offsets to the DLL’s in-memory base address.\nThis last structure contains the number of exported function names (⑰) as well as a table of\npointers towards these (⑯).\n\nFigure 8: Disassembly of the export retrieval.\nThe above operations can be schematized as follow, where dotted lines represent addresses\ncomputed from relative offsets increased by the DLL’s in-memory base address.\n\n\n-----\n\nFigure 9: From `LDR_DATA_TABLE_ENTRY to` `IMAGE_EXPORT_DIRECTORY .`\nOnce the number of exported names and their pointers are identified, the shellcode\nenumerates the table in descending order. Specifically, the number of names is used as a\ndecremented counter at ⑱. For each exported function’s name and while none matches, the\nshellcode performs a hashing routine ( hash_export_name at ⑲) similar to the one we\nobserved previously, with as sole difference that character cases are preserved\n( hash_export_character ).\n\nThe final hash is obtained by adding the recently computed function hash ( ExportHash ) to\nthe previously obtained module hash ( DllHash ) at ⑳. This addition is then compared at ㉑\nto the sought hash and, unless they match, the operation starts again for the next function.\n\nFigure 10: Disassembly of export’s name hashing.\nIf none of the exported functions match, the routine retrieves the next module in the\n```\nInMemoryOrderLinks double-linked list and performs the above operations again until a\n\n```\nmatch is found.\n\nFigure 11: Disassembly of the loop to the next module.\nThe above walked double-linked list can be schematized as the following figure.\n\n\n-----\n\nFigure 12: Walking the `InMemoryOrderModuleList .`\nIf a match is found, the shellcode will proceed to call the exported function. To retrieve its\naddress from the previously identified `IMAGE_EXPORT_DIRECTORY, the code will first need to`\nmap the function’s name to its ordinal (㉒), a sequential export number. Once the ordinal is\nrecovered from the `AddressOfNameOrdinals table, the address can be obtained by using`\nthe ordinal as an index in the `AddressOfFunctions table (㉓).`\n\nFigure 13: Disassembly of the import “call”.\nFinally, once the export’s address is recovered, the shellcode simulates the `call behavior`\nby ensuring the return address is first on the stack (removing the hash it was searching for,\nat ㉔), followed by all parameters as required by the default Win32 API `__stdcall calling`\n[convention (㉕). The code then performs a](https://docs.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-160) `jmp operation at ㉖ to transfer execution to the`\ndynamically resolved import which, upon return, will resume from where the initial `call`\n```\nebp operation occurred.\n\n```\nOverall, the dynamic import resolution can be schematized as a nested loop. The main loop\nwalks modules following the in-memory order (blue in the figure below) while, for each\nmodule, a second loop walks exported functions looking for a matching hash between\ndesired import and available exports (red in the figure below).\n\n\n-----\n\nFigure 14: The import resolution flow.\n\n## Building a Rainbow Table\n\nIdentifying which imports the shellcode relies on will provide us with further insight into the\nrest of its logic. Instead of dynamically analyzing the shellcode, and given that we have\nfigured out the hashing algorithm above, we can build ourselves a rainbow table.\n\nA rainbow table is a precomputed table for caching the output of cryptographic hash\nfunctions, usually for cracking password hashes.\n\n_[wikipedia.org](https://en.wikipedia.org/wiki/Rainbow_table)_\n\nThe following Python snippet computes the “Metasploit” hashes for DLL exports located in\nthe most common system locations.\n\n\n-----\n\n```\nimport glob\nimport os\nimport pefile\nimport sys\nsize = 32\nmask = ((2**size) - 1)\n# Resolve 32- and 64-bit System32 paths\nroot = os.environ.get('SystemRoot')\nif not root:\n  raise Exception('Missing \"SystemRoot\" environment variable')\nglobs = [f\"{root}\\\\System32\\\\*.dll\", f\"{root}\\\\SysWOW64\\\\*.dll\"]\n# Helper function for rotate-right\ndef ror(number, bits):\n  return ((number >> (bits % size)) | (number << (size - (bits % size)))) & mask\n# Define hashing algorithm\ndef get_hash(data):\n  result = 0\n  for b in data:\n    result = ror(result, 0x0D)\n    result = (result + b) & mask\n  return result\n# Helper function to uppercase data\ndef upper(data):\n  return [(b if b < ord('a') else b - 0x20) for b in data]\n# Print CSV header\nprint(\"File,Function,IDA,Yara\")\n# Loop through all DLLs\nfor g in globs:\n  for file in glob.glob(g):\n    # Compute the DllHash\n    name = upper(os.path.basename(file).encode('UTF-16-LE') + b'\\x00\\x00')\n    file_hash = get_hash(name)\n    try:\n      # Parse the DLL for exports\n      pe = pefile.PE(file, fast_load=True)\n      pe.parse_data_directories(directories =\n[pefile.DIRECTORY_ENTRY[\"IMAGE_DIRECTORY_ENTRY_EXPORT\"]])\n      if hasattr(pe, \"DIRECTORY_ENTRY_EXPORT\"):\n        # Loop through exports\n        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n          if exp.name:\n            # Compute ExportHash\n            name = exp.name.decode('UTF-8')\n            exp_hash = get_hash(exp.name + b'\\x00')\n            metasploit_hash = (file_hash + exp_hash) & 0xffffffff\n            # Compute additional representations\n            ida_view = metasploit_hash.to_bytes(size/8,\n\n```\n\n-----\n\n```\nbyteorder big ).hex().upper() + h \n            yara_view = metasploit_hash.to_bytes(size/8,\nbyteorder='little').hex(' ')\n            # Print CSV entry\n            print(f\"\\\"{file}\\\",\\\"{name}\\\",\\\"{ida_view}\\\",\\\"\n{{{yara_view}}}\\\"\")\n    except pefile.PEFormatError:\n      print(f\"Unable to parse {file} as a valid PE, skipping.\",\nfile=sys.stderr)\n      continue\n\n```\nAs an example, the following PowerShell commands generate a rainbow table, then\nsearches it for the `726774Ch hash we observed first in figure 2. For everyone’s`\n[convenience, we have published our rainbow.csv version containing 239k hashes.](https://github.com/NVISOsecurity/blogposts/blob/master/anatomy-and-disruption-of-metasploit-shellcode/rainbow.csv?raw=true)\n```\n# Generate the rainbow table in CSV format\nPS > .\\rainbow.py | Out-File .\\rainbow.csv -Encoding UTF8\n# Search the rainbow table for a hash\nPS > Get-Content .\\rainbow.csv | Select-String 726774Ch\n\"C:\\Windows\\System32\\kernel32.dll\",\"LoadLibraryA\",\"0726774Ch\",\"{4c 77 26 07}\"\n\"C:\\Windows\\SysWOW64\\kernel32.dll\",\"LoadLibraryA\",\"0726774Ch\",\"{4c 77 26 07}\"\n\n```\nAs can be observed above, the first import resolved and called by the shellcode is\n```\nLoadLibraryA, exported by the 32- and 64-bit kernel32.dll .\n\n## Execution Flow Analysis\n\n```\nWith the import resolving sorted-out, understanding the remaining code becomes a lot more\naccessible. As we can see in figure 15, the shellcode starts by performing the following calls:\n\n1. `LoadLibraryA at ㉗ to ensure the` `ws3_32 library is loaded. If not yet loaded, this`\n\nwill map the `ws3_32.dll DLL in memory, enabling the shellcode to further resolve`\n[additional functions related to the Windows Socket 2 technology.](https://docs.microsoft.com/en-us/windows/win32/api/_winsock/)\n2. `WSAStartup at ㉘ to initiate the usage of sockets within the shellcode’s process.`\n3. `WSASocketA at ㉙ to create a new socket. This one will be a stream-based`\n\n( SOCK_STREAM ) socket over IPv4 ( AF_INET ).\n\n\n-----\n\nFigure 15: Disassembly of the socket initialization.\nOnce the socket is created, the shellcode proceeds to call the `connect function at ㉝ with`\nthe `sockaddr_in structure previously pushed on the stack (㉜). The` `sockaddr_in`\nstructure contains valuable information from an incident response perspective such as the\nprotocol ( 0x0200 being `AF_INET, a.k.a. IPv4, in little endianness), the port ( 0x115c`\nbeing the default `4444 Metasploit port in big endianness) as well as the C2 IPv4 address at`\n㉛ ( 0xc0a801ca being `192.168.1.202 in big endianness).`\n\nIf the connection fails, the shellcode retries up to 5 times (decrementing at ㉞ the counter\ndefined at ㉚) after which it will abort execution using `ExitProcess (㉟).`\n\nFigure 16: Disassembly of the socket connection.\nIf the connection succeeds, the shellcode will create a new `cmd process and connect all of`\nits Standard Error, Output and Input (㊱) to the established C2 socket. The process itself is\nstarted through a `CreateProcessA call at ㊲.`\n\n\n-----\n\nFigure 17: Execution of the reverse-shell.\nFinally, while the process is running, the shellcode performs the following operations:\n\n1. Wait indefinitely at ㊳ for the remote shell to terminate by calling\n```\n   WaitForSingleObject .\n\n```\n2. Once terminated, identify the Windows operating system version at ㊴ using\n```\n   GetVersion and exit at ㊵ using either ExitProcess or RtlExitUserThread .\n\n```\nFigure 18: Termination of the shellcode.\nOverall, the execution flow of Metasploit’s `windows/shell_reverse_tcp shellcode can be`\nschematized as follows:\n\n\n-----\n\nFigure 19: Metasploit’s TCP reverse-shell execution flow.\n\n## Shellcode Disruption\n\nWith the execution flow analysis squared away, let’s see how we can turn the tables on the\nshellcode and disrupt it. From an attacker’s perspective, the shellcode itself is considered\ntrusted while the environment it runs in is hostile. This section will build upon the\n**assumption that we don’t know where shellcode is executing in memory and, as such,**\n**hooking/modifying the shellcode itself is not an acceptable solution.**\n\nIn this section we will firstly focus on the theoretical aspects before covering a proof-ofconcept implementation.\n\n## The Weaknesses\n\n### CWE-1288: Improper Validation of Consistency within Input\n\nThe product receives a complex input with multiple elements or fields that must be\nconsistent with each other, but it does not validate or incorrectly validates that the input\nis actually consistent.\n\n_[cwe.mitre.org](https://cwe.mitre.org/data/definitions/1288.html)_\n\nFrom the shellcode’s perspective only two external interactions provide a possible attack\nsurface. The first and most obvious surface is the C2 channel where some security solutions\ncan detect/impair either the communications protocol or the surrounding API calls. This\nattack surface however has the massive caveat that security solutions have to make the\ndistinction between legitimate and malicious behaviors, possibly resulting in some\nmedium/low-confidence detection.\n\n\n-----\n\nA second less obvious attack surface is the import resolution itself which, from the\nshellcode’s perspective, relies on external process data. Within this import resolution routine,\nwe observed how the shellcode relied on the `BaseDllName property to generate a hash for`\neach module.\n\nFigure 20: The hashing routine retrieving both `Buffer and` `MaximumLength to hash a`\nmodule’s `BaseDllName .`\nWhile the module’s exports were UTF-8 `NULL -terminated strings, the` `BaseDllName`\nproperty was a `UNICODE_STRING structure. This structurecontains multiple properties:`\n```\ntypedef struct _UNICODE_STRING {\n USHORT Length;\n USHORT MaximumLength;\n PWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;\n   Length : The length, in bytes, of the string stored in Buffer .\n   MaximumLength : The length, in bytes, of Buffer .\n   Buffer : Pointer to a buffer used to contain a string of wide characters.\n\n```\n[…]\n\nIf the string is null-terminated, `Length` does not include the trailing null character.\n\nThe `MaximumLength` is used to indicate the length of Buffer so that if the string is\npassed to a conversion routine such as `RtlAnsiStringToUnicodeString` the\nreturned string does not exceed the buffer size.\n\n_[docs.microsoft.com](https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string)_\n\nWhile not explicitly mentioned in the above documentation, we can implicitly understand that\nthe buffer’s `MaximumLength property is unrelated to the actual string’s` `Length property.`\nThe Unicode string does not need to consume the entire `Buffer, neither is it guaranteed to`\nbe `NULL -terminated. Theoretically, the Windows API should only consider the first` `Length`\n\n\n-----\n\nbytes of the `Buffer for comparison, ignoring any bytes between the` `Length and`\n```\nMaximumLength positions. Increasing a UNICODE_STRING ‘s buffer ( Buffer and\nMaximumLength ) should not impact functions relying on the stored string.\n\n```\nAs the shellcode’s hashing routine relies on the buffer’s `MaximumLength, similar strings`\nwithin differently-sized buffers will generate different hashes. This flaw in the hashing routine\ncan be leveraged to neutralize potential Metasploit shellcode. From a technical perspective,\nas security solutions already hook process creation and inject themselves, interfering with\nthe hashing routine without knowledge of its existence or location can be achieved by\nincreasing the `BaseDllName buffer for modules required by Metasploit (e.g.:`\n```\nkernel32.dll ).\n\n```\nThis hash-input validation flaw is what we will leverage next as initial vector to cause a\nDenial of Service as well as an Execution Flow Hijack.\n\n### CWE-823: Use of Out-of-range Pointer Offset\n\nThe program performs pointer arithmetic on a valid pointer, but it uses an offset that\ncan point outside of the intended range of valid memory locations for the resulting\npointer.\n\n_[cwe.mitre.org](https://cwe.mitre.org/data/definitions/823.html)_\n\nOne observation we made earlier is how the shellcode loops modules indefinitely until a\nmatching export is found. As we found a flaw to alter hashes, let us analyze what happens if\nall hashes fail to match.\n\nWhile walking the double-linked list could loop indefinitely, the shellcode will actually\ngenerate an “Access Violation” error once all modules have been checked. This exception is\nnot generated explicitly by the shellcode but rather occurs as the code doesn’t verify the list’s\nboundaries. Given that for each item in the list the `BaseDllName.Buffer pointer is loaded`\nfrom offset `0x28, an exception will occur once we access the first non-`\n```\nLDR_DATA_TABLE_ENTRY item in the list. As shown in the figure below, this will be the case\n\n```\nonce the shellcode loops back to the first `PEB_LDR_DATA structure, at which stage an out-`\nof-bounds read will occur resulting in an invalid pointer being de-referenced.\n\n\n-----\n\nFigure 21: An out-of-bounds read when walking the `InMemoryOrderModuleList double-`\nlinked list.\nAlthough from a defensive perspective causing a Denial of Service is better than having\nMetasploit shellcode execute, let’s see how one could further exploit the above flaw to the\ndefender’s advantage.\n\n## Abusing CWE-1288 to Hijack the Execution Flow\n\nOne module of interest is `kernel32.dll which, as previously analyzed in the “Execution`\nFlow Analysis” section, is the first required module in order to call the `LoadLibraryA`\nfunction. During the hashing routine, the `kernel32.dll hash is computed to be`\n```\n0x92af16da . By applying the above buffer-resize technique, we can ensure the shellcode\n\n```\nloops additional modules since the original hashes won’t match. From here, a security\nsolution has a couple of options:\n\nOur injected security solution’s DLL could be named `kernel32.dll . While its hashes`\nwould match, having two modules named `kernel32.dll might have unintended`\nconsequences on legitimate calls to `LoadLibraryA .`\nSimilarly, as we are already modifying buffers in `LDR_DATA_TABLE_ENTRY structures,`\nwe could easily save the original values of the `kernel32.dll buffer and assign them`\nto our security solution’s injected module. While this would theoretically work, having a\nsecond buffer in memory called `kernel32.dll isn’t a great idea as previously`\nmentioned.\nAlternatively, our security solution’s injected module could have a different name, as\nlong as there is a hash-collision with the original hash. This technique won’t impact\nlegitimate calls such as `LoadLibraryA as these rely on value-based comparisons, as`\nopposed to the shellcode’s hash-based comparisons.\n\nWe previously observed how the Metasploit shellcode performed hashing using additions\nand rotations on ASCII characters (1-byte). As a follow-up on figure 6, the following schema\ndepicts the state of `KERNEL32.DLL ‘s hash on the third loop, where the ASCII characters` `K`\nand `E overlap. As one might observe, the` `NULL character is a direct consequence of`\nperforming 1-byte operations on what initially is a Unicode string (2-byte).\n\n\n-----\n\nFigure 22: The first and third ASCII characters overlapping.\nTo obtain a hash collision, we need to identify changes which we can perform on the initial\n```\nKERNEL32.DLL string without altering the resulting hash. The following figure highlights how\n\n```\nthere is a 6-bit relationship between the first and third ASCII character. By subtracting the\nsecond bit of the first character, we can increment the eighth bit (2+6) of the third character\nwithout affecting the resulting hash.\n\nFigure 23: A hash collision between the first and third ASCII characters.\nWhile the above collision is not practical (the ASCII or Unicode character `0xC5 is not within`\nthe alphanumeric range), we can apply the same principle to identify acceptable\nrelationships. The following Python snippet brute-forces the relationships among Unicode\ncharacters for the `KERNEL32.DLL string assuming we don’t alter the string’s length.`\n\n\n-----\n\n```\nname KERNEL32.DLL\\0 \nfor i in range(len(name)):\n  for j in range(len(name)):\n    # Avoid duplicates\n    if j <= i:\n      continue\n    # Compute right-shift/left-shift relationships\n    # We shift twice by 13 bits due to Unicode being twice the size of ASCII.\n    # We perform a modulo of 32 due to the registers being, in our case, 32 bits\nin size.\n    relation = ((13*2*(j-i))%32)\n    if relation > 16:\n      relation -= 32\n    # Get close relationships (0, 1, 2 or 3 bit-shifts)\n    if -3 <= relation <= 3:\n      print(f\"Characters at index {i} and {j:2d} have a relationship of\n{relation} bits\")\n# \"Characters at index 0 and 5 have a relationship of 2 bits\"\n# \"Characters at index 0 and 11 have a relationship of -2 bits\"\n# \"Characters at index 1 and 6 have a relationship of 2 bits\"\n# \"Characters at index 1 and 12 have a relationship of -2 bits\"\n# \"Characters at index 2 and 7 have a relationship of 2 bits\"\n# \"Characters at index 3 and 8 have a relationship of 2 bits\"\n# \"Characters at index 4 and 9 have a relationship of 2 bits\"\n# \"Characters at index 5 and 10 have a relationship of 2 bits\"\n# \"Characters at index 6 and 11 have a relationship of 2 bits\"\n# \"Characters at index 7 and 12 have a relationship of 2 bits\"\n\n```\nAs observed above, multiple character pairs can be altered to cause a hash collision. As an\nexample, there is a 2-bit left-shift relation between the characters at Unicode position 0 and\n11.\n\nGiven [a 2-bit left-shift is similar to a multiplication by 4, incrementing the Unicode character](https://en.wikipedia.org/wiki/Logical_shift)\nat position 0 by any value requires decrementing the character at position 11 by 4 times the\nsame value to keep the Metasploit hash intact. The following Python commands highlight the\ndifferent possible combinations between these two characters for `KERNEL32.DLL .`\n\n\n-----\n\n```\n# The original hash (0x92af16da)\nprint(hex(get_hash(upper('KERNEL32.DLL\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n# Decrementing 'K' by 3 requires adding 12 to 'L'\nprint(hex(get_hash(upper('HERNEL32.DLX\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n# Decrementing 'K' by 2 requires adding 8 to 'L'\nprint(hex(get_hash(upper('IERNEL32.DLT\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n# Decrementing 'K' by 1 requires adding 4 to 'L'\nprint(hex(get_hash(upper('JERNEL32.DLP\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n# Incrementing 'K' by 1 requires substracting 4 from 'L'\nprint(hex(get_hash(upper('LERNEL32.DLH\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n# Incrementing 'K' by 2 requires substracting 8 from 'L'\nprint(hex(get_hash(upper('MERNEL32.DLD\\0'.encode('UTF-16-LE')))))\n# \"0x92af16da\"\n\n```\nThis hash collision combined with the buffer-resize technique can be chained to ensure our\ncustom DLL gets evaluated as `KERNEL32.DLL in the hashing routine. From here, if we`\nexport a `LoadLibraryA function, the Metasploit import resolution will incorrectly call our`\nimplementation resulting in an execution flow hijack. This hijack can be leveraged to signal\nthe security solution about a high-confidence Metasploit import resolution taking place.\n\n### Building a Proof of Concept\n\nTo demonstrate our theory, let’s build a proof-of-concept DLL which will, once loaded, make\nuse of CWE-1288 to simulate how an EDR (Endpoint Detection and Response) solution\ncould detect Metasploit without prior knowledge of its in-memory location. As we want to\nexploit the above hash collisions, our DLL will be named `hernel32.dlx .`\n\n[The proof of concept has been published on NVISO’s GitHub repository.](https://github.com/NVISOsecurity/blogposts/tree/master/anatomy-and-disruption-of-metasploit-shellcode)\n\n**The Process Injection**\n\nTo simulate how a security solution would be injected into most processes, let’s build a\nsimple function which will run our DLL into a process of our choosing.\n\nThe `Inject function will trick the targeted process into loading a specific DLL (our`\n```\nhernel32.dlx ) and execute its DllMain function from where we’ll trigger the buffer\n```\nresizing. While multiple techniques exist, we will simply write our DLL’s path into the target\nprocess and create a remote thread calling `LoadLibraryA . This remote thread will then`\nload our DLL as if the target process intended to do it.\n\n\n-----\n\n```\nMETASPLOP_API\nvoid\nInject(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)\n{\n  #pragma EXPORT\n  int PID;\n  HMODULE hKernel32;\n  FARPROC fLoadLibraryA;\n  HANDLE hProcess;\n  LPVOID lpInject;\n  // Recover the current module path\n  char payload[MAX_PATH];\n  int size;\n  if ((size = GetModuleFileNameA(hPayload, payload, MAX_PATH)) == NULL)\n  {\n    MessageBoxError(\"Unable to get module file name.\");\n    return;\n  }\n  // Recover LoadLibraryA \n  hKernel32 = GetModuleHandle(L\"Kernel32\");\n  if (hKernel32 == NULL)\n  {\n    MessageBoxError(\"Unable to get a handle to Kernel32.\");\n    return;\n  }\n  fLoadLibraryA = GetProcAddress(hKernel32, \"LoadLibraryA\");\n  if (fLoadLibraryA == NULL)\n  {\n    MessageBoxError(\"Unable to get LoadLibraryA address.\");\n    return;\n  }\n  // Open the processes\n  PID = std::stoi(lpszCmdLine);\n  hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);\n  if (!hProcess)\n  {\n    char message[200];\n    if (sprintf_s(message, 200, \"Unable to open process %d.\", PID) > 0)\n    {\n      MessageBoxError(message);\n    }\n    return;\n  }\n  // Allocated memory for the injection\n  lpInject = VirtualAllocEx(hProcess, NULL, size + 1, MEM_COMMIT, PAGE_READWRITE);\n  if (lpInject)\n  {\n    wchar_t buffer[100];\n    wsprintfW(buffer, L\"You are about to execute the injected library in process\n%d.\", PID);\n    if (WriteProcessMemory(hProcess, lpInject, payload, size + 1, NULL) &&\n\n```\n\n-----\n\n```\nIDCANCEL ! MessageBox(NULL, buffer, L NVISO Mock AV, MB_ICONINFORMATION |\nMB_OKCANCEL))\n    {\n      CreateRemoteThread(hProcess, NULL, NULL,\n(LPTHREAD_START_ROUTINE)fLoadLibraryA, lpInject, NULL, NULL);\n    }\n    else\n    {\n      VirtualFreeEx(hProcess, lpInject, NULL, MEM_RELEASE);\n    }\n  }\n  else\n  {\n    char message[200];\n    if (sprintf_s(message, 200, \"Unable to allocate %d bytes.\", size+1) > 0)\n    {\n      MessageBoxError(message);\n    }\n  }\n  CloseHandle(hProcess);\n  return;\n}\n\n```\nAs one might notice, the above code relies on the `hPayload variable. This variable will be`\ndefined in the `DllMain function as we aim to get the current DLL’s module regardless of its`\nname, whereas `GetModuleHandleA would require us to hard-code the` `hernel32.dlx`\nname.\n```\nHMODULE hPayload;\nBOOL APIENTRY DllMain( HMODULE hModule,\n            DWORD ul_reason_for_call,\n            LPVOID lpReserved\n           )\n{\n  switch (ul_reason_for_call)\n  {\n  case DLL_PROCESS_ATTACH:\n    hPayload = hModule;\n    break;\n  case DLL_THREAD_ATTACH:\n  case DLL_THREAD_DETACH:\n  case DLL_PROCESS_DETACH:\n    break;\n  }\n  return TRUE;\n}\n\n```\nWith our `Inject method exported, we can now proceed to build the logic needed to trigger`\nCWE-1288.\n\n**The Buffer-Resizing**\n\n\n-----\n\nResizing the `BaseDllName buffer from the` `kernel32.dll module can be accomplished`\nusing the logic below. Similar to the shellcode’s technique, we will recover the `PEB, walk the`\n```\nInMemoryOrderModuleList and once the KERNEL32.DLL module is found, increase its\n\n```\nbuffer by 1.\n```\nvoid\nMetasplop() {\n  PPEB pPeb = NULL;\n  PPEB_LDR_DATA pLdrData = NULL;\n  PLIST_ENTRY pHeadEntry = NULL;\n  PLIST_ENTRY pEntry = NULL;\n  PLDR_DATA_TABLE_ENTRY pLdrEntry = NULL;\n  USHORT MaximumLength = NULL;\n  // Read the PEB from the current process\n  if ((pPeb = GetCurrentPebProcess()) == NULL) {\n    MessageBoxError(\"GetPebCurrentProcess failed.\");\n    return;\n  }\n  // Get the InMemoryOrderModuleList\n  pLdrData = pPeb->Ldr;\n  pHeadEntry = &pLdrData->InMemoryOrderModuleList;\n  // Loop the modules\n  for (pEntry = pHeadEntry->Flink; pEntry != pHeadEntry; pEntry = pEntry->Flink) {\n    pLdrEntry = CONTAINING_RECORD(pEntry, LDR_DATA_TABLE_ENTRY,\nInMemoryOrderModuleList);\n    // Skip modules which aren't kernel32.dll\n    if (lstrcmpiW(pLdrEntry->BaseDllName.Buffer, L\"KERNEL32.DLL\")) continue;\n    // Compute the new maximum length\n    MaximumLength = pLdrEntry->BaseDllName.MaximumLength + 1;\n    // Create a new increased buffer\n    wchar_t* NewBuffer = new wchar_t[MaximumLength];\n    wcscpy_s(NewBuffer, MaximumLength, pLdrEntry->BaseDllName.Buffer);\n    // Update the BaseDllName\n    pLdrEntry->BaseDllName.Buffer = NewBuffer;\n    pLdrEntry->BaseDllName.MaximumLength = MaximumLength;\n    break;\n  }\n  return;\n}\n\n```\nThis logic is best triggered as soon as possible once injection occurred. While this could be\ndone through a TLS hook, we will for simplicity update the existing `DllMain function to`\ninvoke `Metasplop on` `DLL_PROCESS_ATTACH .`\n\n\n-----\n\n```\nHMODULE hPayload;\nBOOL APIENTRY DllMain( HMODULE hModule,\n            DWORD ul_reason_for_call,\n            LPVOID lpReserved\n           )\n{\n  switch (ul_reason_for_call)\n  {\n  case DLL_PROCESS_ATTACH:\n    hPayload = hModule;\n    Metasplop();\n    break;\n  case DLL_THREAD_ATTACH:\n  case DLL_THREAD_DETACH:\n  case DLL_PROCESS_DETACH:\n    break;\n  }\n  return TRUE;\n}\n\n```\n**The Signal**\n\nAs the shellcode we analyzed relied on `LoadLibraryA, let’s build an implementation which`\nwill simply raise the Metasploit alert and then terminate the current malicious process. The\nfollowing function will only be triggered by the shellcode and is itself never called from within\nour DLL.\n```\n_Ret_maybenull_\nHMODULE\nWINAPI\nLoadLibraryA(_In_ LPCSTR lpLibFileName)\n{\n  #pragma EXPORT\n  // Raise the error message\n  char buffer[200];\n  if (sprintf_s(buffer, 200, \"The process %d has attempted to load \\\"%s\\\" through\nLoadLibraryA using Metasploit's dynamic import resolution.\\n\", GetCurrentProcessId(),\nlpLibFileName) > 0)\n  {\n    MessageBoxError(buffer);\n  }\n  // Exit the process\n  ExitProcess(-1);\n}\n\n```\nThe above approach can be performed for other variations such as `LoadLibraryW,`\n```\nLoadLibraryExA and others.\n\n```\n**The Result**\n\n\n-----\n\nWith our emulated security solution ready, we can proceed to demonstrate our technique. As\nsuch, we’ll start by executing `Shellcode.exe, a simple shellcode loader (show on the left`\nin figure 24). This shellcode loader mentions its process ID (which we’ll target for injection)\nand then waits for the shellcode path it needs to execute.\n\nOnce we know in which process the shellcode will run, we can inject our emulated security\nsolution (shown on the right in figure 24). This process is typically performed by the security\nsolution for each process and is merely done manually in our PoC for simplicity. Using our\ncustom DLL, we can inject into the desired process using the following command where the\npath to `hernel32.dlx and the process ID have been picked accordingly.`\n```\n# rundll32.exe <dll_path>,Inject <target_pid>\nrundll32.exe C:\\path\\to\\hernel32.dlx,Inject 6780\n\n```\nFigure 24: Manually emulating the AV injection into the future malicious process.\nOnce the injection is performed, the `Shellcode.exe process has been staged (module`\nbuffer resized, colliding DLL loaded) for exploitation of the CWE-1288 weakness should any\nMetasploit shellcode run. It is worth noting that at this stage, no shellcode has been loaded\nnor has there been any memory allocation for it. This ensures we comply with the\nassumption that we don’t know where shellcode is executing.\n\nWith our mock security solution injected, we can proceed to provide the path to our initially\ngenerated shellcode ( shellcode.vir in our case) to the soon-to-be malicious\n```\nShellcode.exe process (left in figure 25).\n\n```\n\n-----\n\nFigure 25: Executing the malicious shellcode as would be done by the stagers.\nOnce the shellcode runs, we can see how in figure 26 our `LoadLibraryA signalling`\nfunction gets called, resulting in a high-confidence detection of shellcode-based import\nresolution.\n\nFigure 26: The input-validation flaw and hash collision being chained to signal the AV.\n\n## Disclosure\n\nAs a matter of courtesy, NVISO delayed the publishing of this blog post to provide Rapid7,\nthe maintainers of Metasploit, with sufficient review time.\n\n## Conclusion\n\nThis blog post highlighted the anatomy of Metasploit shellcode with an additional focus on\nthe dynamic import resolution. Within this dynamic import resolution we further identified two\nweaknesses, one of which can be leveraged to identify runtime Metasploit shellcode with\nhigh confidence.\n\nAt NVISO, we are always looking at ways to improve our detection mechanisms.\nUnderstanding how Metasploit works is one part of the bigger picture and as a result of this\nresearch, we were able to build Yara rules identifying Metasploit payloads by fingerprinting\n\n\n-----\n\nboth import hashes and average distances between them. A subset of these rules is\navailable upon request.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-02 - Anatomy and Disruption of Metasploit Shellcode.pdf"
    ],
    "report_names": [
        "2021-09-02 - Anatomy and Disruption of Metasploit Shellcode.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536108,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653781020,
    "ts_modification_date": 1653781020,
    "files": {
        "pdf": "https://archive.orkl.eu/1a1b9b964f86bc84a65dcabe1e77f530ae4e6a6d.pdf",
        "text": "https://archive.orkl.eu/1a1b9b964f86bc84a65dcabe1e77f530ae4e6a6d.txt",
        "img": "https://archive.orkl.eu/1a1b9b964f86bc84a65dcabe1e77f530ae4e6a6d.jpg"
    }
}