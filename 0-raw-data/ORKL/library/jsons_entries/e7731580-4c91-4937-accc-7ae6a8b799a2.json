{
    "id": "e7731580-4c91-4937-accc-7ae6a8b799a2",
    "created_at": "2023-03-03T02:05:50.28536Z",
    "updated_at": "2025-03-27T02:05:32.985436Z",
    "deleted_at": null,
    "sha1_hash": "bed189cc1b2d6086fd9e32045c19eca1bac84be5",
    "title": "2023-02-02 - Malware analysis- part 7. Yara rule example for CRC32. CRC32 in REvil ransomware",
    "authors": "",
    "file_creation_date": "2023-03-01T09:13:18Z",
    "file_modification_date": "2023-03-01T09:13:18Z",
    "file_size": 2125176,
    "plain_text": "# Malware analysis: part 7. Yara rule example for CRC32. CRC32 in REvil ransomware\n\n**[cocomelonc.github.io/malware/2023/02/02/malware-analysis-7.html](https://cocomelonc.github.io/malware/2023/02/02/malware-analysis-7.html)**\n\nFebruary 2, 2023\n\n6 minute read\n\n﷽\n\nHello, cybersecurity enthusiasts and white hackers!\n\nThis post is the result of my own research on Yara rule for CRC32 hashing. How to use it for\nmalware analysis in practice.\n\nAt first I wanted to focus on the WinAPI hashing method by CRC32 at malware development.\nBut then this article would differ from [this one only in the hashing algorithm. Then I decided](https://cocomelonc.github.io/tutorial/2022/03/22/simple-av-evasion-5.html)\nto see how to create a Yara rule which indicate using this algorithm at malware samples. I\nalso consider the implementation of this algorithm in the REvil ransomware.\n\n## CRC32\n\n\n-----\n\nIn short, this is one of the checksum calculation methods. CRC32 (Cyclic Redundancy\nCheck 32) is a type of hashing algorithm used to generate a small, fixed-size checksum\nvalue from any data. It is used to detect errors in data stored in memory or transmitted over a\nnetwork or other communication channel. The checksum is calculated using a polynomial\nfunction and is often expressed as a 32-bit hexadecimal number.\n\nIn fact, CRC is not a sum, but the result of dividing a certain amount of information\n(information message) by a constant, or rather, the remainder of dividing a message by a\nconstant.\n\nAlgorithm of the simplest calculation method is:\n\n1. initialize a remainder r to be 0xFFFFFFFF\n2. for each byte in the message, do the following:\n\na. divide the current remainder r by the polynomial x^8 + x^7 + x^6 + x^4 + x^2 +\n```\n   1 (0xEDB88320)\n\n```\nb. store the remainder in an 8-bit register.\nc. XOR the 8-bit register with the next byte of the message.\nd. replace the current remainder with the 8-bit register\n3. after the last byte of the message has been processed, the final remainder is the CRC\n\nresult.\n\n## practical example\n\nAnd, where can this be applied in the malware development? This algorithm is often used for\n[hashing function names.](https://cocomelonc.github.io/tutorial/2022/03/22/simple-av-evasion-5.html)\n\nI used my [example from the previous article and just replaced the hashing algorithm to](https://github.com/cocomelonc/2022-03-22-malware-av-evasion-5)\n```\nCRC32:\n\n```\n\n-----\n\n```\n/\n * hack.cpp - hashing Win32API functions via CRC32. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/malware/2023/01/27/malware-analysis-7.html\n\n*/\n#include <windows.h>\n\n#include <stdio.h>\n\ntypedef UINT(CALLBACK* fnMessageBoxA)(\n\n HWND  hWnd,\n\n LPCSTR lpText,\n\n LPCSTR lpCaption,\n\n UINT  uType\n\n);\n\nunsigned int crc32(const char *data, size_t len) {\n\n unsigned int crc_table[256], crc;\n\n for (int i = 0; i < 256; i++) {\n\n  crc = i;\n\n  for (int j = 0; j < 8; j++) crc = (crc >> 1) ^ (crc & 1 ? 0xEDB88320 : 0);\n\n  crc_table[i] = crc;\n\n };\n\n crc = 0xFFFFFFFF;\n\n while (len--) crc = (crc >> 8) ^ crc_table[(crc ^ *data++) & 0xFF];\n\n return crc ^ 0xFFFFFFFF;\n\n}\n\nstatic LPVOID getAPIAddr(HMODULE h, unsigned int myHash) {\n\n PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;\n\n PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header>e_lfanew);\n\n PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(\n\n  (LPBYTE)h + img_nt_header>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\n PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);\n\n PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);\n\n PWORD fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);\n\n for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {\n\n  LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);\n\n  if (crc32(pFuncName, strlen(pFuncName)) == myHash) {\n\n   printf(\"successfully found! %s - %x\\n\", pFuncName, myHash);\n\n   return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);\n\n  }\n\n }\n\n return nullptr;\n\n}\n\nint main() {\n\n```\n\n-----\n\n```\n HMODULE mod LoadLibrary( user32.dll );\n\n //LPVOID addr = getAPIAddr(mod, 0x572d5d8e);\n\n LPVOID addr = getAPIAddr(mod, 1462590862);\n\n printf(\"0x%p\\n\", addr);\n\n fnMessageBoxA myMessageBoxA = (fnMessageBoxA)addr;\n\n myMessageBoxA(NULL, \"Meow-meow!\",\"=^..^=\", MB_OK);\n\n return 0;\n\n}\n\n```\nAs you can see, I just used this constant 0xEDB88320 and also hardcoded MessageBoxA\nstring:\n```\nimport zlib\n\n# crc32\n\ndef crc32(data):\n\n  hash = zlib.crc32(data)\n\n  print (\"0x%08x\" % hash)\n\n  print (hash)\n\n  return hash\n\ncrc32(b\"MessageBoxA\")\n\n\n## yara rule\n\n```\nSo in the simplest implementation, the Yara rule will look like this:\n```\nrule crc32_hash\n\n{\n\n meta:\n\n  author = \"cocomelonc\"\n\n  description = \"crc32 constants\"\n\n strings:\n\n  $c = { 2083B8ED }\n\n condition:\n\n  $c\n\n}\n\n\n```\nAs you can see, we just add algorithm’s constant for identity:\n```\nhexdump -C ./hack.exe | grep \"20 83 b8 ed\"\n\n```\n\n-----\n\nLet s check it:\n```\nyara -w ./crc32.yar ./hack.exe\n\n\n```\nDespite the fact that this rule may provide a large number of false-positive matches, it is\nuseful to be aware that a sample may have implemented CRC32, since this can speed up\nmalware sample analysis.\n\n## demo\n\nFirst of all, compile our “malware”:\n```\nx86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -I/usr/share/mingw-w64/include/ -s ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive\n\n\n```\nRun it at victim’s machine (Windows 10 x64):\n```\n.\\hack.exe\n\n```\n\n-----\n\nAs you can see, everything is worked perfectly! =^..^=\n\nLet’s go to upload our “malware” to VirusTotal:\n\n\n-----\n\n**So, 4 of 70 AV engines detect our file as malicious.**\n\nhttps://www.virustotal.com/gui/file/f2d076786b061b771f945243dbf755539b8170963cf89aadc\nccfb6e62acd4083/details\n\n[This is trick is used for example by REvil and](https://attack.mitre.org/software/S0496/) [MailTo ransomwares in the wild.](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/an-in-depth-look-at-mailto-ransomware-part-one-of-three/)\n\n## practical example 2. REvil ransomware\n\nREvil generates a unique identifier (UID) for the host using the following process. The UID is\npart of the payment URL referenced in the dropped ransom note:\n\nobtains the volume serial number for the system drive\ngenerates a CRC32 hash of the volume serial number using the hard-coded seed value\nof 0x539\ngenerates a CRC32 hash of the value returned by the CPUID assembly instruction using\nthe CRC32 hash for the volume serial number as a seed value\nappends the volume serial number to the CPUID `CRC32 hash.`\n\nIn the simplest implementation, it is look like (hack2.cpp):\n\n\n-----\n\n```\n/\n * hack2.cpp - get UID via CRC32 as REvil ransomware. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/malware/2023/01/27/malware-analysis-7.html\n\n*/\n#include <stdio.h>\n\n#include <windows.h>\n\n#include <intrin.h>\n\n#include <wincrypt.h>\n\nDWORD crc32(DWORD crc, const BYTE *buf, DWORD len) {\n\n DWORD table[256];\n\n DWORD i, j, c;\n\n for (i = 0; i < 256; i++) {\n\n  c = i;\n\n  for (j = 0; j < 8; j++) {\n\n   if (c & 1)\n\n    c = 0xEDB88320 ^ (c >> 1);\n\n   else\n\n    c = c >> 1;\n\n  }\n\n  table[i] = c;\n\n }\n\n crc = ~crc;\n\n while (len--)\n\n  crc = table[(crc ^ *buf++) & 0xFF] ^ (crc >> 8);\n\n return ~crc;\n\n}\n\nint main(void) {\n\n DWORD volumeSerial, cpuidHash, uid, i;\n\n char volumePath[MAX_PATH];\n\n BYTE cpuidData[16];\n\n DWORD cpuidDataSize = sizeof(cpuidData);\n\n DWORD hashBuffer[4];\n\n HCRYPTPROV hCryptProv;\n\n if (!GetVolumeInformation(NULL, NULL, 0, &volumeSerial, NULL, NULL, NULL, 0)) {\n\n  printf(\"failed to get the volume serial number.\\n\");\n\n  return 1;\n\n }\n\n volumeSerial = crc32(0x539, (BYTE *)&volumeSerial, sizeof(volumeSerial));\n\n __cpuid(hashBuffer, 0);\n\n for (i = 0; i < 4; i++)\n\n  cpuidData[i] = (BYTE)(hashBuffer[i] & 0xff);\n\n __cpuid(hashBuffer, 1);\n\n for (i = 0; i < 4; i++)\n\n  cpuidData[4 + i] = (BYTE)(hashBuffer[i] & 0xff);\n\n```\n\n-----\n\n```\n cpuidHash crc32(volumeSerial, cpuidData, cpuidDataSize);\n\n uid = volumeSerial;\n\n uid = (uid << 32) | cpuidHash;\n\n printf(\"UID: %llx\\n\", uid);\n\n return 0;\n\n}\n\n```\nThis implementation calls GetVolumeInformation to retrieve the volume serial number for\nthe system drive, crc32 to build the CRC32 hash, and __cpuid to obtain the value returned by\nthe CPUID assembly instruction.\nThe resulting uid is a 64-bit value that combines the serial number of the volume and the\n```\nCPUID hash.\n\n## demo 2\n\n```\nLet’s go to see in action. Compile it:\n```\nx86_64-w64-mingw32-g++ -O2 hack2.cpp -o hack2.exe -I/usr/share/mingw-w64/include/ -s\n-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive\n\n\n```\nRun it at victim’s machine (Windows 10 x64):\n```\n.\\hack2.exe\n\n```\n\n-----\n\nAs you can see, everything is worked perfectly!\n\nOf course, this is just “dirty PoC” of part of the REvil ransomware’s logic.\n\nLet’s go to upload this to VirusTotal:\n\n**In this example, 3 of 70 AV engines detect our file as malicious.**\n\nhttps://www.virustotal.com/gui/file/871257db59da7bfb9346b120ba165924b60dafb45f3f940c9\nfb0a739504b29c5/details\n\nLet’s check it via YARA:\n```\nyara -w ./crc32.yar -r ./\n\n```\n\n-----\n\nI hope this post spreads awareness to the blue teamers of this interesting hashing technique,\nand adds a weapon to the red teamers arsenal.\n\nThis is a practical case for educational purposes only.\n\n[AV engines evasion techniques - part 5](https://cocomelonc.github.io/tutorial/2022/03/22/simple-av-evasion-5.html)\n[CRC32](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)\n[Novel Approach for Worm Detection using Modified Crc32 Algorithm](https://research.ijcaonline.org/ncipet/number14/ncipet1105.pdf)\n[REvil/Sodinokibi](https://attack.mitre.org/software/S0496/)\n[MailTo](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/an-in-depth-look-at-mailto-ransomware-part-one-of-three/)\n[GetVolumeInformation](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa)\n[source code in github](https://github.com/cocomelonc/2023-01-27-malware-analysis-7)\n\nThanks for your time happy hacking and good bye!\n\n_PS. All drawings and screenshots are mine_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-02 - Malware analysis- part 7. Yara rule example for CRC32. CRC32 in REvil ransomware.pdf"
    ],
    "report_names": [
        "2023-02-02 - Malware analysis- part 7. Yara rule example for CRC32. CRC32 in REvil ransomware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809150,
    "ts_updated_at": 1743041132,
    "ts_creation_date": 1677661998,
    "ts_modification_date": 1677661998,
    "files": {
        "pdf": "https://archive.orkl.eu/bed189cc1b2d6086fd9e32045c19eca1bac84be5.pdf",
        "text": "https://archive.orkl.eu/bed189cc1b2d6086fd9e32045c19eca1bac84be5.txt",
        "img": "https://archive.orkl.eu/bed189cc1b2d6086fd9e32045c19eca1bac84be5.jpg"
    }
}