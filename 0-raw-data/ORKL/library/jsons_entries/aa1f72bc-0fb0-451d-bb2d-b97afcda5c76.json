{
    "id": "aa1f72bc-0fb0-451d-bb2d-b97afcda5c76",
    "created_at": "2022-10-27T08:36:19.660524Z",
    "updated_at": "2025-03-27T02:05:40.655082Z",
    "deleted_at": null,
    "sha1_hash": "f83c6d6181c1bc9ca666c7397de0ff6832603e60",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-10-27T12:54:11Z",
    "file_modification_date": "2021-10-27T14:39:18Z",
    "file_size": 42505655,
    "plain_text": "-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n2021 年10 月22 日\n\n# はじめに\n\n2021 年10 月22 日現在、すでに多くのニュースや公開記事で言及されているように､｢LockBit2.0｣はリー\n\nクサイトを持つ暴露型ランサムウェア攻撃グループの中で現在(2021 年後半)最も活発である攻撃グループで\n\nす｡LockBit2.0 のリークサイト上では､いきなり窃取データが暴露されるのではなく､｢被害組織名｣とともに\n\n｢暴露までの残り時間｣をリアルタイムでカウントし被害組織に圧力をかけます｡そのため､リークサイトに初め\n\nて掲載された時点においては被害組織と攻撃者間で金銭の支払いに関する交渉が行われているかもしくは交渉\n\n前の段階にあるケースが多いものと考えられます｡\n\nLockBit2.0 の開発者は自身のサイト上で､LockBit2.0 のランサムウェアが世界で最も暗号化速度が速く他の\n\nランサムウェアよりも優れていると､攻撃の実働部隊であるアフィリエイトに向け詳細にアピールしており､加\n\nえて他のランサムウェアには無い新しい技術も搭載しているという趣旨のコメントを掲載しています｡(それを\n\n補足する関連情報として､海外で行われたLockBit2.0 の代表者へのインタビューでは｢攻撃が速く実行される\n\nほど､攻撃が撃墜されるリスクは少なくなる｣と答えています｡)\n\n今回我々はこうした点を踏まえ、当該攻撃グループが使用するランサムウェア「LockBit2.0」本体に着目し詳\n\n細解析を実施、本記事でその全ての解析結果を共有します。\n\nなお、LockBit2.0 ランサムウェアに関する解析記事については海外ベンダーなどからすでに幾らか公開され\n\nていますが、それらの記事において言及されていない事実や、解析が及んでいない挙動などが多くあることを\n\n確認しました。\n\n本記事では、そうした他の解析記事では触れられていない詳細情報や、全世界初となる情報なども多数盛り込\n\nみ、“世界で最も詳細なLockBit2.0 ランサムウェアの解析記事”(※)となるよう意識しました。\n\n（※本記事執筆時点(2021 年10 月)かつ公開されている範囲において）\n\nまた、海外のみでなく日本国内においても多くの被害が出ていると想定される状況下において、LockBit2.0 ラ\n\nンサムウェアに関する日本語オリジナルによる詳細解析記事自体が依然ほとんど存在しない状況であるため、\n\n今回公開した本記事が幾らか国内を中心とした皆様の、お役に立てば幸いです。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## 目次\n\n    - 要 .......................................................................................................................................... 4\n\n    - 層解析 ................................................................................................................................... 5\n\n   - 解析機能（解析を妨害する機能） ............................................................................................ 6\n\n   - 染環境の言語チェック .......................................................................................................... 13\n\n   - AC Bypass による権限昇格 .................................................................................................. 15\n\n   - 重起動を防ぐミューテックス（Mutex）の作成 ........................................................................ 28\n\n   - 意のシャットダウンに備えた暗号化の再開手口 ..................................................................... 28\n\n   - ャットダウン時に最後まで居残る手口 ................................................................................... 29\n\n   - ロセスの強制終了とサービスの停止 .................................................................................... 30\n\n   - ミ箱を空にする ................................................................................................................... 34\n\n  - しパーティションのスキャンと強制ドライブマッピング .......................................................... 35\n\n   - ァイル暗号化処理の高速化 ................................................................................................... 36\n\n   - I/O 完了ポート」の採用による処理の高速化 .......................................................................... 37\n\n   - AES-NI」の活用による暗号化処理の高速化 ........................................................................... 40\n\n   - ァイルの先頭部分のみの暗号化による高速化 ....................................................................... 41\n\n   - ockBit2.0 のファイル暗号化ロジックの詳細 ........................................................................... 43\n\n   - き込みが禁止されているファイルの属性変更 ....................................................................... 53\n\n   - ァイルの暗号化から除外する対象 ......................................................................................... 55\n\n   - ockBit2.0 に暗号化されたファイルのアイコン ........................................................................ 55\n\n   - ockBit2.0 のバグ（暗号化が途中で失敗するミス） .................................................................. 58\n\n   - ockBit2.0 のバグ（多重暗号化を発生させるミス） .................................................................. 58\n\n   - ockBit2.0 のバグ（「.lock」ファイルのチェックミス） ................................................................. 62\n\n   - メインコントローラでの動作 ................................................................................................. 66\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n   - ockBit2.0 のバグ（作成されたタスクのミス） .......................................................................... 85\n\n   - スクトップ壁紙の変更 .......................................................................................................... 88\n\n   - 迫文が記述されたテキストファイルの作成 ........................................................................... 94\n\n   - TA ファイルによる脅迫文の表示 .......................................................................................... 95\n\n  - リンタを利用した脅迫文の物理的な印刷（約一万枚） ............................................................ 99\n\n   - ンシデント対応や復旧作業を妨害する処理 ......................................................................... 107\n\n   - ォレンジックを意識した自身の抹消処理 ............................................................................. 107\n\n   - &D（drag and drop）に対応 ................................................................................................. 110\n\n  - ockBit2.0 が隠し持つ GUI(隠しウインドウ)の発見 .............................................................. 112\n\n※以降の文中において「LockBit2.0」と記載した場合、攻撃グループ名ではなくランサムウェアを指します。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■概要\n\nはじめにLockBit2.0 の特徴をまとめると、以下のような項目があげられます。\n\n・ I/O 完了ポートの採用による暗号化処理の高速化\n\n・ ファイルの一部のみを暗号化することによる暗号化処理の高速化\n\n・ AES-NI が利用可能なCPU 認識＆活用による暗号速度の高速化\n\n・ 楕円曲線暗号（ECC）方式を採用したことによる暗号速度の高速化\n\n・ プリンタを利用した物理的な脅迫文の印刷（プリンタ一台当たり約1 万枚）\n\n・ デスクトップ壁紙を利用したインサイダー（内部者）募集\n\n・ グループポリシーによるドメイン配下の全端末への自動展開\n\n・ 全ローカルドライブのネットワーク共有化\n\n・ 効果的な解析妨害（難読化、デバッガ検知、スレッドのステルス化など）\n\n・ あまり詳細が知られていないUAC Bypass による権限昇格\n\n・ 入念なフォレンジック対策（単純な削除ではなく自身をハードディスクから抹消）\n\n・ 入念な感染継続性（暗号化中に端末がシャットダウンされることに備えた再開処理）\n\n・ 隠しパーティションのスキャンと強制ドライブマッピング\n\nなど\n\nLockBit2.0 が自身のサイト上で自負しているランサムウェアの高速性については、詳細解析の結果、実際に\n\nファイルの暗号化を高速化させる複数の高度なテクニックが実装されていることを確認しました。\n\nまた、様々な手口のアイデアが機能として盛り込まれており、特に、ドメインコントローラ感染時に特別に発\n\n生させる「グループポリシーによる自身の拡散」という仕組みは、暴露系ランサムウェアとしては史上初の新\n\n機能であり、従来のアフィリエイト（攻撃の実働部隊）が手動で行っていた作業を置き換えることで、攻撃能\n\n力に個人差があるアフィリエイトの手動作業をできるだけ自動化し攻撃の質を平準化させる試みが感じられま\n\nす。\n\nまた今回の解析で、LockBit2.0 が世界的に知られていないグラフィカルなインターフェイス（GUI）である\n\n「隠しウインドウ」を実装していることや、LockBit2.0 が複数の致命的なバグを抱えており、検体や被害環\n\n境によっては多重暗号化が発生することで、たとえ復号ツールが入手できたとしても復号が困難となるシチュ\n\nエーションが存在することなど、多くの新事実も発見しました。\n\nこれらを含む、LockBit2.0 詳細解析の全貌は以下の解説をご覧ください。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■表層解析\n\nLockBit2.0 はVisual Studio 2017 で作成され、構造上はGUI アプリケーションとしてビルドされていま\n\nす。ただし実際には実行されても画面上には何も表示されずサイレントに感染が行われます。\n\nまた、単純な表層解析の範囲では一般的なGUI コンポーネントなどのリソースデータはEXE ファイルから確\n\n認することはできません。\n\n図 1 LockBit2.0 の開発情報\n\nセクションとしては以下の2 つの構造を持ち、一般的なGUI アプリケーションにみられるリソースセクショ\n\nンなども存在しません。\n\n図 2 LockBit2.0 のセクション情報\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nアドレス空間配置のランダム化であるASLR は無効化された状態でビルドされています。\n\n図 3 LockBit2.0 のEXE 設定情報\n\nその他、デジタル署名やプロパティ情報などは基本的に付与されていません。\n\n## ■耐解析機能（解析を妨害する機能）\n\nLockBit2.0 は解析を困難とするためにいくつかの耐解析機能（解析妨害テクニック）を実装しています。\n\nLockBit2.0 は起動すると、すぐに自身がデバッグされていないかどうかをチェックし、デバッグ中であると\n\n判断すると無限ループし動的解析を妨害します。\n\n具体的には、プロセス内に存在する様々な情報が格納されたPEB（Process Environment Block）という\n\n構造体の中の「NtGlobalFlag」という項目をチェックします。プロセスがデバッグ中の場合はこのNtGlobal\n\nFlag が0x70 という値になるため、LockBit2.0 はNtGlobalFlag の値を取得し、「0x70」と比較すること\n\nでデバッグ中であるかを判断します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 4 NtGlobalFlag による解析妨害\n\nまた、LockBit2.0 は動作中、複数のスレッド（マルチスレッド）により処理を行っていきますが、その際にデ\n\nバッガからスレッドを解析できないよう、スレッドをステルス化することで解析を妨害します。\n\nこのテクニックは新しいものではありませんが、非常に効果的な解析妨害方法であり、このアンチデバッグテ\n\nクニックはBlackMatter 等の高度なランサムウェアでも確認されています。\n\n具体的には、NtSetInformationThread 関数を使用し、指定したスレッドに ThreadHideFromDebugger\n\n（0x11 という値）という特殊なフラグを設定する文書化されていない呼び出し方法により実現します。この\n\n値が設定されると、デバッガは該当フラグが設定されたスレッドからの情報を取得できなくなるため該当ス\n\nレッド上のコードの解析ができなくなり、実質的にデバッガからスレッドを隠すのと同じ効果を得られます（該\n\n当スレッドを解析しようとしてもデバッガが素通りしてしまう上、無理やり解析を進めようとするとクラッ\n\nシュします）（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 5 ThreadHideFromDebugger による解析妨害\n\nまたLockBit2.0 は、Windows API を名前ではなくハッシュ値で求める手法を採用し、Windows API を隠\n\n蔽することで静的解析を妨害するテクニックも実装しています（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 6 WindowsAPI のハッシュ比較による解析妨害\n\n例えば、「Kernel32.dll」のアドレスは、以下のようにPEB のInLoadOrderModuleList から辿りハッシュ\n\n値をチェックすることにより導き出します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 7 Kernel32.dll のアドレスの割り出し処理\n\n例えば、「gdiplus.dll」というDLL を「LoadLibraryA」でロードする際の一連の処理は、以下のような流れ\n\nになります（下図参照）。LoadLibraryA のアドレスがハッシュ値で導き出された後、難読化されていた「gd\n\niplus.dll」という文字列が復号され、引数に渡されます。\n\nつまり、API はアドレスをハッシュ値で参照し、API で使用する文字列などは毎回復号して使用します。\n\nその他、動作中に使用する全ての文字列についても同様に難読化されており、都度復号して使用します。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 8 gdiplus.dll をLoadLibraryA でロードする際の処理例\n\n文字列の復号は一つの関数で行われるわけではなく、文字列ごとにそれぞれ異なる復号方法を使用しています。\n\n以下の図は例として「Advapi32.dll」というDLL 名の復号と、「user32.dll」というDLL 名の復号処理の一\n\n部を抜粋したものです（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 9 それぞれの文字列の復号は複数の異なる復号方法を使用する\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n以上のような複数の対策により、動的解析・静的解析の両面の観点からの解析を妨害します。決して数多くの\n\n耐解析機能が実装されているわけではありませんが、少ない中でより効果的な耐解析テクニックを組み合わせ\n\nて利用しているといえます。\n\n## ■感染環境の言語チェック\n\nLockBit2.0 は感染端末の言語設定を取得し、CIS（独立国家共同体）を含むロシアを中心とした旧ソ連諸国の\n\n言語が設定されていないかどうかをチェックし、設定されている場合は感染せずに終了します（下図参照）。\n\nこの点については、開発者も自身のサイト上で”LockBit2.0 はポスト・ソビエト国家には感染しない”と明言\n\nしています。\n\n言語チェックは、GetSystemDefaultUILanguage 関数とGetUserDefaultLangID 関数が用いられます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 10 特定の言語環境かどうかをチェックする処理とチェックする言語の一覧\n\nなお一般的にあまり知られていませんが、こうした言語チェックを行わないLockBit2.0 の個体も一部存在す\n\nることを今回の調査の中で確認しています。つまり、検体によっては言語チェックの機能自体が実装されてい\n\nないケースがあり、ロシア語などの言語が設定された端末であっても以下の図のように感染してしまいます（下\n\n図参照）。\n\nこれは攻撃の実働部隊であるアフィリエイトがランサムウェアを攻撃対象組織に合わせチューニングしたうえ\n\nで簡単にEXE を生成できるような仕組みを提供するRaaS(Ransomware as a Service)において、ランサ\n\nムウェアに持たせる各機能の有効化/無効化をビルド時の設定で選択できる仕組みが背景にあるものと考えら\n\nれ、そうした中で言語チェックを有効にしない状態でビルドされた検体が一部存在するものと推測しています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 11 ロシア語端末でLockBit2.0 が感染した様子\n\n## ■UAC Bypass による権限昇格\n\nLockBit2.0 は、自身が管理者権限を持っていない状態で起動した場合、UAC(ユーザーアカウント制御)の昇\n\n格プロンプトを回避し管理者権限に昇格するテクニックである「UAC Bypass」を行います。\n\nコード上では、以下のように管理者権限で実行された場合と、ユーザ権限で実行された場合で異なる遷移を取\n\nる分岐点があります（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 12 UAC Bypass に関わる処理の分岐箇所と終了処理の構造\n\nなお、この分岐点を解析作業時に容易に見つけ出すためには、実行時に通過したコード領域の差分分析を行う\n\nカバレッジログ分析が有効です。\n\n以下のように「管理者権限で動作したコード領域」と「ユーザ権限で動作したコード領域」の差分を取り、「ユー\n\nザ権限でのみ動作したコード領域」を抽出させることで、UAC Bypass のコード箇所が抽出され特定できま\n\nす（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 13 カバレッジログを用いたUAC Bypass 処理箇所の抽出と特定\n\nLockBit2.0 は、上記のカバレッジログ分析において明らかとなった「ユーザ権限でのみ動作するコード領域」\n\nにおいて、あまり広く詳細が知られておらず文書化されていない特定のCOM(Component Object Model)\n\nインターフェイスを悪用するUAC Bypass テクニックを用います。\n\n以降では、そのUAC Bypass の流れを詳細解説します。\n\nまずLockBit2.0 は自身が管理者権限で実行されているかどうかを確認します。\n\n具体的には以下の方法で行います。\n\nZwOpenProcessToken 関数にTOKEN＿QUERY(0x8)アクセス権を指定した上でNtQueryInformation\n\nToken 関数を呼び出しプロセストークンの構造体(TokenInformation)を取得、その際TokenInformationCl\n\nass の「TokenElevation(0x14=20)」を引数に指定することでTOKEN_ELEVATION 構造体を取得しま\n\nす。\n\nその後、取得したTOKEN_ELEVATION 構造体のメンバ変数である「TokenIsElevated」の値が0 かどうか\n\nをチェックすることで管理者権限かどうかを判断します（下図参照）。\n\n（自身が管理者権限で実行されていると判断した場合、[Process created with admin rights]という難読\n\n化された文字列をメモリ上に復号したのち、メインの処理を継続します）\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 14 管理者権限かどうかを確認するためにプロセストークを取得\n\n自身が管理者権限で起動していないと判断した場合、自身がUAC Bypass を行うことができる環境にあるか\n\nを確認する作業を行います。\n\nまず先ほどと同様、ZwOpenProcessToken 関数にTOKEN_QUERY(0x8)アクセス権を指定した上でNtQ\n\nueryInformationToken 関数を呼び出し、プロセストークンの構造体(TokenInformation)を取得します。\n\n続いてCreateWellKnownSid 関数に「WinBuiltinAdministratorsSid」(0x1A=26)という引数を指定する\n\nことで「BUILTIN\\Administrators」グループに対応するSID(セキュリティ識別子)を取得(作成)したのち、C\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nheckTokenMembership 関数を利用して、呼び出し元のプロセストークン内で「BUILTIN\\Administrator\n\ns」グループのSID が有効になっているかどうかを確認することで、Administrators グループに属している\n\nかどうかをチェックします（属していない場合は本処理を終了します）。\n\nつまりこの時点で、現在のユーザが”管理者権限を持たずAdministrators グループに属しているユーザであ\n\nる”と判断できることになります。\n\nなお、Windows ではAdministarators グループに属しているユーザがログオンする際、対となる2 つのトー\n\nクン（管理者としてのフルアクセストークンと制限されたユーザのトークン）が発行されます。\n\nこの2 つのトークンのうち、現在の対となるトークンをTokenLinkedToken 関数で取得することができま\n\nす。\n\nLockBit2.0 は自身のプロセスが管理者権限を持たず、かつ実行したユーザがAdministrators グループに属\n\nしていると判断すると、NtQueryInformationToken 関数の引数に「TokenLinkedToken」(0x13=19)を\n\n指定することで、対となるトークン、つまり、フルアクセストークンを取得できるか確認します。\n\n(この処理が失敗した場合、つまり対となるフルアクセストークンが存在しない場合は「Process created w\n\nith limited rights」という文字列を復号しメモリ上に展開し、UAC Bypass の処理を終了します)\n\n図 15 Administrators グループに属しているかどうかをチェック\n\n次に、LockBit2.0 はこれから行うUAC Bypass が利用できるOS バージョンであるかを確かめるため、G\n\netVersion 関数でWindows のメジャーバージョンを取得し、「5」(Windows XP/2000/Server2003/\n\nServer2000)という値と比較、Windows のメジャーバージョンが「5」ではない場合のみ処理を継続します\n\n（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n（もし「5」に該当した場合は「Process created with limited rights」という文字列を復号しメモリ上に\n\n展開し、UAC Bypass の処理を終了します)\n\n図 16 Windows のメジャーバージョンを「5」と比較\n\n以上の処理により、LockBit2.0 は自身がUAC Bypass を行うことができる環境にあると判断し、UAC By\n\npass の主たる処理に遷移します。\n\n今回UAC Bypass にも利用される「COM」(Component Object Model)は、Process Status API（P\n\nSAPI）を使用して、プロセスのPEB という構造体のprocessParameters に含まれる実行パスに関する情\n\n報を読み取ることでCOM の呼び出し元プロセスを識別します。\n\nそのため前準備として、LockBit2.0 は自身のプロセスが持っている実行パス情報を、以降で解説する方法に\n\nより信頼できるプロセスの一つである「Explorer」の実行パスに強制的に書き換えることで偽装します。\n\n（こうしたプロセスの偽装処理を「マスカレード」と呼びます）\n\nそのため、まず以下のようにExplorer.exe のフルパス文字列を生成します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 17 マスカレード処理で使用するExplorer のパスを生成\n\n続いて、LockBit2.0 はRtlInitUnicodeString 関数を使用し、”C:¥Windows¥Explorer.exe”という文字\n\n列を自身のPEB のprocessParameters 項目にあるImagePathName に、また、“Explorer.exe”という\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n文字列を自身のPEB のprocessParameters 項目にあるCommandLine の項目に上書きします（下図参\n\n照）。\n\nPEB のprocessParameters の各項目はUNICODE_STRING という構造体の形式を取りますが、この際、\n\nLockBit2.0 はPEB の書き換えにRtlInitUnicodeString 関数をそのまま使用することでUNICODE_STRI\n\nNG に変換しつつ直接書き換えるという二つの作業を同時に行います。\n\n図 18 LockBit2.0 が行う「マスカレード」（プロセス情報偽装）処理\n\nつまり、これにより以下のようにLockBit2.0 のPEB にあるプロセスパラメータのパス情報がExplorer のパ\n\nスに偽装（マスカレード）されます（下図参照）。\n\nまたこのマスカレード処理を、自身がロードしている全てのモジュール(DLL)に対しても同様に行います。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 19 マスカレード処理によって改変されExplorer に偽装したLockBit2.0 のプロセス情報\n\n続いてLockBit2.0 は、CoInitializeEx 関数でCOM インターフェイスの使用準備をしたのち、CoGetObjec\n\nt 関数で以下2 つの特定のCLSID を指定し、対応するオブジェクト名を作成します（下図参照）。\n\n 指定されるCLSID： {3E5FC7F9-9A51-4367-9063-A120244FBEC7}\n\n 作成されるオブジェクト名(COM 昇格モニカ)：”Elevation:Administrator!new:{3E5FC7F9-9A51-4\n\n367-9063-A120244FBEC7}”\n\n 指定されるCLSID： {D2E7041B-2927-42fb-8E9F-7CE93B6DC937}\n\n 作成されるオブジェクト名(COM 昇格モニカ)：”Elevation:Administrator!new:{D2E7041B-2927\n42fb-8E9F-7CE93B6DC937}”\n\nこれらのCLSID はUAC Bypass の観点で脆弱であることが一部で知られている、それぞれCMSTPLUA と\n\nIColorDataProxy という自動昇格が有効なCOM インターフェイスに紐づいています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 20 COM 昇格モニカの作成\n\n上記のオブジェクト名(COM 昇格モニカ)がCoGetObject 関数の引数に渡され呼び出されることで、COM の\n\nホストプロセス（COM サロゲートプロセス）である「Dllhost.exe」（正規プロセス）が以下の引数で起動し\n\nます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 21 COM サロゲートプロセスが起動する様子\n\nその後、LockBit2.0 は（Dllhost.exe を経由し）以下のレジストリ(今回利用するCOM に関連したDisplay\n\nCalibrator というレジストリ)を書き換えることで、LockBit2.0 のEXE がUAC Bypass を行える状態にし\n\nます（下図参照）。\n\n図 22 LockBit2.0 がUACbypass のために書き換えるレジストリ場所\n\n以下は、書き換える処理と、書き換え前後のDisplayCalibrator のレジストリ値を比較した様子です（下図参\n\n照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 23 LockBit2.0 により書き換えられる前後のレジストリ値「DisplayCalibrator」\n\nその後上記設定が反映される関連されたCOM 処理を呼び出すことで管理者権限に昇格したdllhost.exe がL\n\nockBit2.0 を起動させます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 24 DllHost.exe がLockBit2.0 を起動する様子\n\nその際管理者権限が継承され、結果的にLockBit2.0 が自動的に権限昇格した状態で新たなプロセスとして起\n\n動することになります（下図参照）。\n\n図 25 UAC Bypass により権限昇格が行われた瞬間の様子\n\n以上が、LockBit2.0 が用いる、あまり広く詳細が知られておらず文書化されていない特定のCOM インター\n\nフェイスを悪用したUAC Bypass のテクニックの仕組みです。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■多重起動を防ぐミューテックス（Mutex）の作成\n\nLockBit2.0 は、アプリケーションが多重起動を防止する際によく使用するミューテックス（Mutex）を作成\n\nすることで、自身のプロセスが多重に起動することを防ぎます（下図参照）。\n\n図 26 LockBit2.0 が作成するミューテックス\n\n## ■不意のシャットダウンに備えた暗号化の再開手口\n\nLockBit2.0 は、ユーザがインシデントに気付き端末を急いで強制的にシャットダウンするケースに備え、端\n\n末が再起動された際も暗号化が再開できるよう、レジストリにあるHKCU のRun キーに自身のパスを登録す\n\nることで、自動起動設定を行います。この自動起動のためのレジストリ設定は、暗号化がすべて完了すると削\n\n除されます。つまり、暗号化の途中でシャットダウンされても端末の再起動後に暗号化が再開できるようにし\n\nており、念を入れて執拗にすべてを暗号化しようとする攻撃者の意図が垣間見えます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 27 再起動時に再開できるようにRun キーを一時的に設定\n\n## ■シャットダウン時に最後まで居残る手口\n\nまたLockBit2.0 は、ユーザが端末をシャットダウンしようとした際に最後まで居残ることができるようにし\n\nます。\n\n具体的には、SetProcessShutdownParameters 関数を使用し、自身のプロセスがシャットダウン時に終了\n\nするプロセスの中で最後となるよう、シャットダウン時の終了順序を設定します。\n\nこれにより、端末のシャットダウン時に最後までシステムに居残ることで、できるだけ多くのファイルを暗号\n\n化しようとします。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 28 シャットダウンパラメータの変更\n\n## ■プロセスの強制終了とサービスの停止\n\nLockBit2.0 は動作中、繰り返し実行されるスレッドの中でプロセスの強制終了を定期的に行います。\n\n強制終了の対象プロセス名となる137 個の文字列をメモリ上に復号/展開して用意します（下図参照）。\n\n図 29 強制終了対象プロセスの展開\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nプロセスの強制終了は、ネイティブAPI であるZwTerminateProcess が利用されます。\n\n図 30 プロセスの強制終了処理\n\n以下は、LockBit2.0 が強制終了対象とする137 個のプロセス名一覧となります（下図参照）。\n\nこれらには、インシデント調査に使用されるプロセスや、業務アプリケーション、データベース系アプリケー\n\nションなどのプロセスが含まれており、これらのプロセスを強制終了させることでLockBit2.0 の暗号化作業\n\nがスムーズに行われるようにします。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 31 LockBit2.0 が強制終了する対象プロセス名リスト\n\nまた、サービスの停止も行いますが、その際ControlService 関数にSERVICE_CONTROL_STOP を引数と\n\nして渡すことで実施します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 32 サービスの強制停止処理\n\nLockBit2.0 が停止させるサービス名は以下の79 個であり、データベース系アプリケーション、バックアッ\n\nプ系アプリケーション、セキュリティ製品などのサービスが含まれています（下図参照）。\n\n図 33 停止対象となる79 個のサービス名一覧\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■ゴミ箱を空にする\n\nLockBit2.0 にはごみ箱を空にする挙動があり、全てのドライブにあるごみ箱をSHEmptyRecycleBin 関数\n\nで空にしていきます（下図参照）。\n\n図 34 全てのごみ箱を空にする処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■隠しパーティションのスキャンと強制ドライブマッピング\n\nLockBit2.0 は、FindFirstVolumeW およびFindNextVolumeW で、ローカルドライブにマッピングされて\n\nいない隠しパーティションを含むコンピュータ上の全てのボリュームをスキャンし、マウントされていない場\n\n合はSetVolumeMountPointW で空きのあるドライブ名を指定しドライブマッピングしていきます。\n\nこれにより以下のように通常は論理ドライブとして見えない隠しパーティション領域も強制的に論理ドライブ\n\nとしてマウントされてしまいます。この結果、隠しパーティションであってもLockBit2.0 の暗号化対象とし\n\nて認識されるようになります（下図参照）。\n\n図 35 隠しパーティションの強制ドライブマッピング\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■ファイル暗号化処理の高速化\n\n冒頭で触れた通り、LockBit2.0 の開発者は自身のサイト上で、ほかのランサムウェアと比較しLockBit2.0\n\nが世界で最も高速であると自負しアピールしています（下図参照）。\n\n図 36 最も高速であると自負するLockBit2.0 のサイト上のアピール文\n\nそのため、LockBit2.0 のファイルの暗号化に関わる処理を詳しく調べたところ、実際にファイルの暗号化処\n\n理を高速化するための複数のテクニックが実装されていることを確認しました。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■「I/O 完了ポート」の採用による処理の高速化\n\nまず一つ目に挙げられるのは、「I/O 完了ポート」（I/O Completion Port, IOCP）の採用によるマルチス\n\nレッドの高速化です。\n\n「I/O 完了ポート」とは、マルチスレッドの処理において、ファイルの読み書きなどCPU の範囲外での待機が\n\n発生するような、CPU から見ると時間を要する入出力処理(I/O)でCPU を無駄に待機させず、空き時間でほか\n\nの処理に効率的にリソースを割り振り管理するための仕組みで、サーバアプリケーションなどで採用されてい\n\nる高速化の仕組みです（下図参照）。\n\n図 37 LockBit2.0 で使用されている「I/O 完了ポート」の概念と仕組み\n\n従来の一般的なマルチスレッドによる並列方法ではスレッドが消費するリソースやスレッドの開始・終了に伴\n\nうコスト（OS にイベントが飛ぶなど）、スレッドの切り替えに伴うコストなどがあり、CPU に対する負担が\n\n大きく、また特に、CPU の世界よりも圧倒的に遅いハードディスクへのアクセスなどの入出力処理(I/O)にお\n\nいて、処理を待機している時間CPU を占領させることが非効率であるとも言えます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nそこでLockBit2.0 は、そうした観点が考慮された仕組みである「I/O 完了ポート」を採用することで効率化\n\nを図っています。I/O 完了ポートを利用することで、CPU の世界から見て時間の要する入出力処理（I/O）が\n\n完了するまでCPU リソースを他の処理のために一旦開放し、入出力処理（I/O）が完了したタイミングでスレッ\n\nドプール（複数のスレッドを待機させつつ空いたスレッドに適宜処理させる仕組み）に処理依頼(キュー)を渡す\n\nという流れでCPU に処理を再開させることができ、CPU の占有を抑えることで効率的にCPU リソースを活\n\n用したマルチスレッドを実現できます。また、同時にアクティブとなるスレッドの数を指定することができる\n\nため、プロセッサ数以上のスレッドを動作させないといった制御が可能です。\n\nこのため、多数のI/O を並行発生させることで高速化したい「ランサムウェア」というプログラムにとってI/\n\nO 完了ポートの採用は効果的な選択であると言えるでしょう。\n\n具体的には、ネイティブWindows API であるNtCreateIoCompletion、NtSetInformationFile、ZwRem\n\noveIoCompletion、ZwSetIoCompletion という関数群を呼び出すことで実現しています。\n\n下図は、実際にLockBit2.0 がファイルを暗号化する際に使用するI/O 完了ポートの利用流れを図示したもの\n\nです。ファイルを暗号化する際の入出力処理（I/O）において、I/O 完了ポートが一元管理することでCPU の\n\n処理が効率化されます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 38 I/O 完了ポートを利用したLockBit2.0 のファイル暗号化処理の高速化の仕組み\n\nつまり、I/O 完了ポートの採用により、実際に暗号化処理の高速化が期待できるといえます。\n\nまた、LockBit2.0 はファイルの暗号化処理だけでなくその他の機能においてもマルチスレッドでサブルーチ\n\nン化しておりそれぞれにおいてI/O 完了ポートを活用した高速化を行なっています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■「AES-NI」の活用による暗号化処理の高速化\n\nインテルとAMD の一部のCPU には、AES の暗号処理を高速に行う為の「AES-NI」（Advanced Encrypt\n\nion Standard New Instructions）という仕組みが実装されています。AES-NI は、AES の暗号化/復号処\n\n理のために特別に用意された専用の命令セットをハードウェアに実装することで大幅な高速化が行われる機能\n\nです。\n\nLockBit2.0 はファイルの暗号化にAES を使用するため、AES-NI を活用することでファイルの暗号化処理を\n\n高速化しています。\n\n具体的には、LockBit2.0 はまず感染端末のCPU の種類を示す「CPUID」やCPU の製造ベンダーを示す「ベ\n\nンダーID」を確認することで、AES-NI に対応したCPU であるかを確認します。さらにAES-NI をサポート\n\nしているCPU であるかどうかをチェックします。\n\nこれらのチェックの結果、AES-NI に対応していると判断した場合は、LockBit2.0 はAES-NI 専用に用意さ\n\nれた命令セットである「aesenc」命令を使用して暗号化します（下図参照）。\n\n図 39 AES-NI を活用したLockBit2.0 のファイル暗号化処理の高速化\n\nつまりこのAES-NI の利用により、実際に暗号化処理の高速化が期待できるといえます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■ファイルの先頭部分のみの暗号化による高速化\n\nLockBit2.0 は、暗号化する対象ファイルの中身全てを暗号化せず、ファイルの先頭部分4KB のみを暗号化す\n\nることでファイルの暗号化を高速化しています。以下の図は、LockBit2.0 に暗号化される前のファイルと暗\n\n号化された後のファイルの先頭部分を比較した様子ですが、先頭4KB のみが暗号化されていることがわかり\n\nます（下図参照）。\n\n図 40 LockBit2.0 に暗号化される前後のファイルの先頭部分の比較\n\nまた別の例として1GB のファイルサイズを持つ巨大なファイルを用意し実験した結果が以下ですが、LockBi\n\nt2.0 によって暗号化された後のファイルを確認すると、先頭4KB しか暗号化されていません（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 41 LockBit2.0 により暗号化された1GB のファイルの状態\n\n確かに、他のランサムウェアにおいて、多数の大きなサイズのファイルが暗号化されるようなシチュエーショ\n\nンでは、暗号化スピードが大幅に減速することをこれまでしばしば目にしてきました。Conti の解析記事 (詳\n\nしくは [ここをクリック してご覧ください) においても、ファイルの拡張子やサイズによって暗号化処理を分](https://www.mbsd.jp/research/20210413/conti-ransomware/)\n\nけていることが分かっており、ランサムウェアにとってこの減速が課題であることは明らかです。LockBit2.0\n\nが採用したこの方法のように、ファイルの先頭4KB のみを暗号化するという割り切りは、暗号化スピードの向\n\n上の観点においては非常に効果的なアイデアであると感じます。\n\nまた、4KB とはいえ、プレーンテキストの種類のファイルでない限り、ファイルの先頭4KB を暗号化された\n\n場合は元の状態に復元することは非常に困難であり、結果的にファイル全体を暗号化された場合と同等の影響\n\nを被害組織に与えられる手口であるともいえます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■LockBit2.0 のファイル暗号化ロジックの詳細\n\nここでは、LockBit2.0 が行うファイルの暗号化のロジックを詳細解説します。\n\nLockBit2.0 のファイル暗号化のロジックを次の図にまとめましたので、図に沿って解説します（下図参照）。\n\nまず、LockBit2.0 の攻撃者側は公開鍵暗号方式である「ECC」（楕円曲線暗号）鍵のペア（これを「マスター\n\nECC 公開鍵」と「マスターECC 秘密鍵」と呼びます）を生成し、「マスターECC 秘密鍵」を攻撃者側の手元\n\nで管理しています。\n\nそして、LockBit2.0 のEXE 本体にこの「マスターECC 公開鍵」がハードコードされています。\n\n次に、LockBit2.0 は感染時、感染端末ごとに一意となる別のECC 鍵のペア（これを「セッションECC 公開\n\n鍵」と「セッションECC 秘密鍵」と呼びます）をローカルで生成します（※）。\n\n（※）なおLockBit2.0 はECC（楕円曲線暗号）の楕円曲線に「Curve25519」を使用しています。RSA よ\n\nり処理速度の早いECC を採用している点で高速化を狙った意図等が考えられます。\n\n一方で、LockBit2.0 は暗号化対象のファイルを暗号化する際AES 暗号で暗号化しますが、その際に使用され\n\nるAES 鍵（暗号鍵＆IV）はファイルごとに動的生成されます。つまり、AES 鍵（暗号鍵＆IV）はファイルご\n\nとに異なります。\n\nではファイルを暗号化する際のロジックを見ていきましょう。\n\nLockBit2.0 はあるファイルを暗号化する際、そのファイルのフッタに、「セッションECC 公開鍵」で暗号化\n\nした「AES 鍵（暗号鍵＆IV）」と、「マスターECC 公開鍵」で暗号化した「セッションECC 秘密鍵」を追記\n\nして書き込みます。\n\nしたがって、「マスターECC 秘密鍵」があれば、対となる「マスターECC 公開鍵」で暗号化された「セッショ\n\nンECC 秘密鍵」が抽出でき、さらにその「セッションECC 秘密鍵」があれば、対となる「セッションECC\n\n公開鍵」で暗号化された「AES 鍵（暗号鍵＆IV）」を取り出すことができます。\n\nつまり、ファイルの復号は「マスターECC 秘密鍵」を持った攻撃者のみが行えることを意味します。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 42 LockBit2.0 の暗号化ロジック図\n\n上図にも一部記載していますが、LockBit2.0 はセッション鍵のペア（「セッションECC 公開鍵」と「セッ\n\nションECC 秘密鍵」）を生成した際にレジストリに書き込むことで記録します（下図参照）。\n\nなお、レジストリに記録されるセッションECC 秘密鍵は暗号化された状態で書き込まれ、メモリ上に生成され\n\nていたセッションECC 秘密鍵はすぐに0xFF で上書きされ消去されます。\n\n図 43 レジストリに書き込むセッション鍵のペア\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nこの背景ですが、LockBit2.0 は起動した際、上記レジストリが存在した場合は前回の暗号化処理が途中であ\n\nると判断し、これらのセッション鍵のペアを読み込むことで続きの暗号化に利用します。つまり、途中で端末\n\nがシャットダウンされるなどで中断された場合においても同じセッション鍵で暗号化が再開できるようにして\n\nいると考えられます（下図参照）。\n\n図 44 起動時にセッション鍵を読み込む処理\n\nなお、ファイルを暗号化する際のAES 暗号鍵の作成方法ですが、BcryptGenRandom 関数を使用し32 バイ\n\nトのランダムなバイト列を生成します。この時点で鍵長が32 バイト＝256 ビットである可能性が考えられま\n\nしたが、BcryptGenRandom を使用し生成した32 バイトのランダムなバイト列のうち、最初の16 バイト\n\nをIV(初期化ベクトル)として、残りの16 バイトをAES 暗号鍵として使用することが確認され、この時点で1\n\n28 ビットの鍵長であることがわかりました（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 45 AES 暗号鍵の作成方法\n\nさらにファイルの暗号化に使用するAES のアルゴリズムにおいて、10 個のラウンド定数による10 回のラウ\n\nンド処理が確認でき、これも鍵長が128 ビット（128 ビットはラウンド10 回）であることを意味します。\n\nまた、前回暗号化した列との排他的論理和の処理が確認されるため、この特徴はCBC モードを意味します（後\n\n述）。暗号化するデータを16 バイトごとに暗号化（異なる暗号化鍵で10 回処理）し、それを256 回繰り返\n\nします。この結果、16*256=4096 バイト暗号化することとなり、前述したとおりファイルの先頭を4KB\n\nしか暗号化しないことを意味します。\n\n初期化ベクトル（IV）としての利用部分と上記のラウンド処理が確認できたことから、暗号アルゴリズムは「A\n\nES128 ビット」「CBC モード」であると断定できます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 46 ファイルの暗号化に使用するAES のアルゴリズム\n\nなお、上記で「前回暗号化した列との排他的論理和の処理」がAES 暗号におけるCBC モードの特徴であるこ\n\nとに触れましたが、CBC モードの具体的な処理の流れは以下のようになります。暗号化するデータの最初の1\n\n6 バイトは、IV(初期化ベクトル)と暗号鍵が使用されますが、2 ブロック目以降の16 バイトは、1 つ目の暗\n\n号化ブロックをIV(初期化ベクトル)の代わりに使用します（下図参照）。\n\nこのように前回暗号化した列を入力値とする排他的論理和の処理があれば、CBC モードと判別できる一つの特\n\n徴であるといえます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 47 AES 暗号／CBC モードの仕組みと特徴\n\n以上の暗号化処理により、LockBit2.0 が暗号化したファイルのフッタ構造は以下の図のようになります。51\n\n2 バイトあるフッタ全体のうち、後方に「セッションECC 公開鍵」で暗号化した「AES 鍵（暗号鍵＆IV）」\n\nと、「マスターECC 公開鍵」で暗号化した「セッションECC 秘密鍵」を追記します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 48 LockBit2．0 に暗号化されたファイルのフッタの全体構造\n\n上記図にも記載した通り、フッタの末尾にはランサムウェアの「検体」を識別するための8 バイトのマーカー\n\nが記載されます。この8 バイトの値はLockBit2.0 の本体（EXE ファイル）のバイナリ部分にハードコード\n\nされており、検体に依存する値であるため、検体識別用に使用可能なデータであるといえます。使用した検体\n\nが特定できれば、攻撃者側で使用されているマスター鍵の識別が可能であると想定されます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 49 フッタの末尾に含まれる「検体」識別用マーカー\n\nそしてもう一つ、フッタの末尾には「端末」を識別するための8 バイトのマーカーが記載されます。この8 バ\n\nイトの値は、LockBit2.0 が作成したレジストリの「Public」に格納されたセッションECC 公開鍵の先頭8\n\nバイトとなっており、セッションECC 公開鍵はLockBit2.0 が最初に実行された際に生成されるものである\n\nため、攻撃者側で端末を識別する際の目安として使用できるデータであるといえます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 50 フッタの末尾に含まれる「端末」識別用マーカー\n\nなお、上記レジストリキーの命名規則は、LockBit2.0 の実行ファイルにハードコードされたバイナリ値から\n\n特定の場所をピンポイントで抽出したものが使用されています（下図参照）。\n\n図 51 レジストリキーの命名規則\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nLockBit2.0 はこうしたファイルの暗号化を、GetDriveTypeW 関数で書き込み可能と判別した全てのドライ\n\nブ配下のファイルに対して実施していきます（下図参照）。\n\n図 52 書き込み可能な全ドライブのチェック\n\nなお、LockBit2.0 はネットワーク共有に設定されたリソース先もアクセスし暗号化する能力を持っています。\n\nWNetOpenEnumW 関数およびWNetEnumResourceW 関数を使用して感染端末からアクセス可能な全て\n\nのネットワーク共有を列挙し、発見されたネットワーク共有ごとに新しいスレッドを作成しリソース先に存在\n\nする全てのファイルに対し暗号化を行っていきます（下図参照）。また、WNetAddConnection2W 関数を利\n\n用したネットワーク共有へのアクセスについても試みます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 53 ネットワークリソースの暗号化処理\n\n## ■書き込みが禁止されているファイルの属性変更\n\nLockBit2.0 はできるだけ多くのファイルを暗号化するために、「読み取り専用」属性がついているファイル\n\n（つまり書き込みが禁止されているファイル）を発見した場合、該当の属性を削除します。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 54 読み取り専用属性が削除される様子\n\n具体的には、個々のファイルを暗号化する際GetFileAttributes 関数でファイルの属性をチェックし「読み取\n\nり専用」属性が設定されているファイルであると判断すると、SetFileAttributes 関数に「0x80=FILE_ATT\n\nRIBUTE_NORMAL」の引数を渡し、属性が設定されていない状態に変更します。\n\nこれによりたとえ「読み取り専用」属性が付与され書き込みが禁止されているファイルであっても、書き込み\n\n可能な状態にしたうえで暗号化を行うことが可能となっています。\n\n図 55 SetFileAttributes 関数による属性変更の処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■ファイルの暗号化から除外する対象\n\nファイルを暗号化する際、以下に挙げる「ファイル名」「フォルダ名」「拡張子」を暗号化対象から除外しま\n\nす。これらにはシステムが動作するために最低限必要なファイルやフォルダ、および攻撃者とコミュニケーショ\n\nンするためのブラウザなどが含まれています（下図参照）。\n\n図 56 LockBit2.0 がファイルの暗号化から除外する対象\n\n## ■LockBit2.0 に暗号化されたファイルのアイコン\n\nLockBit2.0 は、以下のレジストリを改変することで「.lockbit」という拡張子（暗号化したファイルにつける\n\n拡張子）を持つファイルのデフォルトアイコンを、自身が作成したLockBit2.0 のデザインのアイコンに設定\n\nします。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 57 アイコンファイルの作成と設定\n\nそして、設定したアイコンをすぐにシステムに適用させるため、SHChangeNotify 関数を呼び、システムのア\n\nイコン描画をリフレッシュさせます。\n\n図 58 登録したアイコンのシステムへの即時反映の処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nその結果、LockBit2.0 に暗号化されたファイルは全てアイコンが以下のように変化します。\n\n図 59 LockBit2.0 に暗号化されアイコンが変化したファイルの一覧\n\nただし、一部の検体において、アイコンが変化しないケースが存在することが複数の検体を解析することで明\n\nらかとなりました。そのため、LockBit2.0 の検体によっては、感染したアイコンが変化しない場合も存在し\n\nます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■LockBit2.0 のバグ（暗号化が途中で失敗するミス）\n\nLockBit2.0 には、環境によってファイルの暗号化処理が途中で失敗してしまうバグを持つ検体が存在するこ\n\nとが今回の調査の結果新たに判明しました。これは本検証時において最新のWindows Update を適用した後\n\nのWindows 10 で確認されており、LockBit2.0 がシステムに関わる特定の特殊フォルダへのアクセス権が\n\nないことで、該当のシステムフォルダへアクセスした時点でファイルの暗号化スレッドがクラッシュし無限\n\nループに陥るか、LockBit2.0 のプロセス自体がクラッシュして終了します。\n\nこのシチュエーションに該当する環境では、ファイルが途中まで暗号化されているものの、LockBit2.0 の後\n\n半の挙動で行う処理である「デスクトップの壁紙変更」、「デスクトップ上の脅迫文(HTA)の作成」などが発生\n\nしません。\n\nそのため、実際の被害組織の中にはデスクトップ壁紙がLockBit2.0 を示すわかりやすい画像に変更されず、\n\nまた脅迫文も目が届くデスクトップなどに作成されないことから、LockBit2.0 という種類のランサムウェア\n\nに感染したこと自体を把握できていないケースがあるものと推測されます。\n\nこの場合、C ドライブ直下のアルファベット順で比較的前方にあるフォルダ内を確認し、ファイルの拡張子が\n\n「.lockbit」のものが存在するかどうかで、LockBit2.0 に感染し一部のファイルが暗号化されたかどうかを判\n\n別することが可能です。\n\n## ■LockBit2.0 のバグ（多重暗号化を発生させるミス）\n\nLockBit2.0 には、シチュエーションによってファイルを多重に暗号化してしまうバグを持つ検体が一部存在\n\nします。\n\nLockBit2.0 は、暗号化済みのファイルかどうかをチェックする際、ファイル内部のフッタなどは確認せず単\n\n純に「.lockbit」という拡張子の有無でのみ判別しますが、ネットワーク共有フォルダなどネットワーク経由で\n\n暗号化を行う場合に限り、暗号化したファイルの拡張子を「.lockbit」に変更しないというバグを抱える検体が\n\n存在します。\n\nそのため、感染端末が存在するローカルネットワーク上には、拡張子が「.lockbit」でないにも関わらず暗号化\n\nされたファイルが存在する可能性があり、状況によっては多重に暗号化される可能性があります（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 60 ネットワーク越しで暗号化されたファイルの拡張子は変化しない\n\n多重に暗号化されることを確かめるため、実際に次の検証を行いました。\n\n以下はネットワーク共有したフォルダを持つ端末α上でLockBit2.0 に感染させた際の検証結果を図示したも\n\nのです。端末α上の共有フォルダには「ファイルB」が配置しており、「ファイルB」はすでに他の端末β上\n\nの”バグを持つ検体”により暗号化されている状況となります。上記で述べた通り、バグを持つ検体によりネッ\n\nトワーク経由で暗号化された「ファイルB」は、暗号化されているものの拡張子が「.lockbit」ではない状態に\n\nなっています。\n\nこの状況下で、端末αをLockBit2.0 に感染させたところ、「ファイルB」は想定通り2 重に暗号化されるこ\n\nとが確かめられました（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 61 バグを持つ検体の動作\n\n上記の検証結果を踏まえると、例えば以下のように、多数の感染端末からアクセス可能な共有フォルダが存在\n\nする状況下でバグを持つLockBit2.0 に感染した場合、3 重4 重と感染端末の数だけ多重に暗号化されてしま\n\nう可能性があるといえます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 62 LockBit2.0 に多重暗号化される可能性とシチュエーション\n\nこのバグを抱えるLockBit2.0 の個体に感染し、ファイルが多重に暗号化されてしまっていた場合、たとえ攻\n\n撃者から復号ツールを提供され復号しようとしても、実際は復号できないという状況が発生すると想定されま\n\nす（復号ツールも拡張子で判別すると考えられるため）。\n\nもちろん理論上、ファイルフッタの構造を都度判別し多重に暗号化されていることを想定して元のファイルに\n\nなるまで繰り返し復号するツールを作れないわけではないですが、そこまで煩雑な復号ツールを作るのであれ\n\nば、はじめから多重暗号化が発生しないようにランサムウェア側を実装したほうが現実的といえます。\n\nつまり、ファイルが多重に暗号化されてしまうシチュエーションがあるというこの事実は、LockBit2.0 の攻\n\n撃者が想定しているとは考えられず、ファイルの復元が困難となる致命的なバグの一つであると考えられます。\n\nただし、比較的新しくビルドされたLockBit2.0 において、このバグが修正されている個体も存在することを\n\nその後確認しました。以下の図の通り、バグが修正された個体ではネットワーク経由で暗号化した場合も正常\n\nにファイルの拡張子を「.lockbit」に変更するように修正されているため、多重に暗号化されるという上記問題\n\nが解消されています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 63 バグが修正された検体の動作\n\nバグを持つ個体とバグが修正された個体はビルド日時が比較的近いため、現時点でLockBit2.0 に攻撃されて\n\nいる被害組織の中には、多重暗号化により復元を困難とさせてしまうバグを持つ個体が実際に使用されている\n\nケースも少なくないものと想定され、注意が必要です。\n\n## ■LockBit2.0 のバグ（「.lock」ファイルのチェックミス）\n\nLockBit2.0 は多重暗号化を防ぐため、プロセスの起動中はドライブ直下に「.lock」というファイルを作成し\n\n常に開いた状態にします。「.lock」のファイル名部分の文字列は「セッションECC 鍵」のペアを記録したレ\n\nジストリキー名の最初の4 バイトが使用されます。\n\nLockBit2.0 は起動時に該当の「.lock」ファイルがCreateFile で開けるか（ハンドルがとれるか）をチェッ\n\nクし、直前のエラーコードを「0xB7」(ERROR_ALREADY_EXISTS)と比較、該当した場合は自身を終了さ\n\nせます。\n\nもしエラーコードが「0xB7」に該当しなかった場合は、処理を継続し「.lock」ファイルのハンドルを動作中\n\nは常に開いたままの状態にします。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nローカルにおける多重感染防止は前述のとおりミューテックスで実現されていることから、この「.lock」ファ\n\nイルの役割は該当ドライブがネットワーク越しで暗号化される場合を想定した多重暗号化防止の役割を持つこ\n\nとが想定されます。つまり、「.lock ファイルのハンドルが開けない」＝「すでに該当の端末（ドライブ）では\n\n他のLockBit2.0 が動作し暗号化している最中である」と判断し、ファイルが多重に暗号化されることを防ぎ\n\nたいのだろうと考えられます（下図参照）。\n\n図 64 「.lock」ファイルのハンドルオープン処理\n\nしかし、今回の解析の結果、ここにもバグが存在することが発見されました。\n\nLockBit2.0 は直前のエラーコードを「0xB7」(ERROR_ALREADY_EXISTS)と比較していますが、「.loc\n\nk」ファイルのハンドルが開かれた状態で感染させると、実際にはOS から「0x50」(ERROR_FILE_EXIST\n\nS)というエラーコードが応答されます。そのため、実検証では「.lock」ファイルのハンドルが開かれた状態で\n\nあっても処理は止まらず暗号化は継続されてしまいました。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nまた、一部のLockBit2.0 には前述した通り、ネットワーク越しで暗号化したファイルの拡張子を「.lockbit」\n\nに変更しないというバグも存在します。\n\nつまり、これらのバグが組み合わさることで、他の端末上のLockBit2.0 からネットワーク越しで並行して暗\n\n号化が行われた場合、結果的に排他制御ができず、共有フォルダのみでなく共有化された各端末のドライブに\n\nおいても多重の暗号化が発生してしまう可能性があることを意味します。\n\nこの結果はコードの実装を見る限り開発者にとって想定外である可能性が高く、「多重暗号化を防ぎたい」と\n\nいう本来の意図を推し量るとLockBit2.0 の開発者はこの比較対象のエラーコードを「0xB7」ではなく「0x\n\n50」という値にしたかった可能性があります（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 65 LockBit2.0 のエラーコードの比較処理に含まれるバグ\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■ドメインコントローラでの動作\n\nLockBit2.0 にはドメインコントローラで行う特別な挙動が存在します。以降ではその挙動を解説します。\n\nLockBit2.0 は感染時、GetComputerName 関数を使用してコンピュータ名を取得したのち、NetGetDCN\n\name 関数によりプライマリドメインコントローラの名前を取得できるか確かめます。もしプライマリドメイン\n\nコントローラの名前が取得できた場合、その名前の先頭から”¥¥”（バックスラッシュ）を2 つ削除した文字\n\n列と、先ほど取得したコンピュータ名の文字列を比較することで、感染した端末がドメインコントローラであ\n\nるかどうかをチェックします（下図参照）。\n\n図 66 ドメインコントローラの名前を取得し判別する処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nドメインコントローラであると判断した場合、以下の処理を継続します。\n\nLockBit2.0 は自身のプロセスの実行アカウントが「DomainAdmins」(ドメイン管理者グループ)に属してい\n\nるかどうかをチェックします。\n\n具体的には次の方法で行います。\n\nZwOpenProcessToken 関数にTOKEN＿QUERY(0x8)アクセス権を渡すことで現在のプロセスのトーク\n\nンを取得したのちNtQueryInformationToken 関数で現在のSID を取得、取得した現在のSID から、GetW\n\nindowsAccountDomainSid 関数を使用してドメインSID を取得します（下図参照）。\n\n図 67 ドメインSID を取得する処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n取得したドメインSID とWellKnownSidType として知られる「WinAccountDomainAdminsSid」（0x2\n\n9=41）という値をCreateWellKnownSid 関数に渡すことでDomainAdmins(ドメイン管理者グループ)の\n\nSID を取得(作成)、最後にCheckTokenMembership 関数を利用して、呼び出し元のトークン内でDomain\n\nAdmins(ドメイン管理者グループ)のSID が有効になっているかどうかをチェックします（下図参照）。\n\n(※もしDomainAdmins に属していないと判断すると「Don’t have admin rights」という文字列をログ\n\n用にメモリ上に作成します)\n\n図 68 DomainAdmins に属しているかどうかのチェック処理\n\nDomainAdmins に属していると判断すると、LockBit2.0 はDomainAdmins のアカウント名（ドメイン管\n\n理者）を取得します。\n\n具体的には次の方法で行います。\n\n先ほどと同じくZwOpenProcessToken 関数にTOKEN＿QUERY(0x8)アクセス権を渡すことで現在のプ\n\nロセスのトークンを再度取得したのち、NtQueryInformationToken 関数で現在のSID を取得、LookupAcc\n\nountSidW 関数を使用し、取得したSID に対するアカウント名（Administrator）とアカウント名が見つかっ\n\nたドメイン名（例：ADTEST）を取得します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 69 DomainAdmins のアカウント名とドメイン名を取得する処理\n\n以上により、ドメインコントローラであることの確認およびドメインコントローラの情報を取得できた後、Lo\n\nckBit2.0 は、グループポリシーを作成し、ドメイン配下の全てのクライアント端末にランサムウェアを配布す\n\nる挙動を行います。\n\nこのグループポリシーによる自身の拡散という仕組みは、暴露系ランサムウェアとしては史上初の新機能であ\n\nると考えられます。\n\nLockBit2.0 がドメイン内の各端末に配布するグループポリシーは以下に挙げる6 つです（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 70 LockBit2.0 が配布するグループポリシー\n\nそれぞれについて、以降で詳細解説していきます。\n\nLockBit2.0 は、まずCreateFile でグループポリシー設定ファイルである「GPT.ini」を作成します（下図参\n\n照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 71 LockBit2.0 により作成される「GPT.INI」\n\n続いてCreateGPOLink 関数により、指定したGPO（グループポリシーオブジェクト）とOU(Active Dire\n\nctory でアカウント管理の最小単位となるアカウント・コンピュータ・リソースの集合)をリンクさせグループ\n\nポリシーの適応先を設定（下図参照）、ADSI 関数(Active Directory サービスインターフェイス)であるAD\n\nSGetObject 関数を使用した上でグループポリシーの属性(gPCMachineExtensionNames やgPCUserEx\n\ntensionNames などの拡張属性)の設定を行います。ADSGetObject 関数はアプリケーションがActive Di\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nrectory(AD)にアクセスするための専用API であり、この関数によりAD 内のオブジェクトの検索・閲覧・編\n\n集・削除などが実行できるようになります。\n\n図 72 グループポリシーをOU にリンクさせる処理\n\nその後、ドメイン内のクライアントに配布するための複数のグループポリシーファイルを作成していきます。\n\nまずは、「LockBit2.0 本体をドメイン配下に一斉配布するグループポリシー」を作成します。\n\nあらかじめ、ドメインコントローラにあるSYSVOL フォルダ内scripts フォルダに自身のコピーを作成した\n\n上で、「Files.xml」というグループポリシー設定ファイル(xml)を作成します。\n\n作成された「Files.xml」には、ドメインコントローラのscripts フォルダに作成したLockBit2.0 の本体EX\n\nE を、ドメイン配下の各クライアント端末のデスクトップ上にコピーするよう指示するポリシーが記述されて\n\nいます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 73 LockBit2.0 の本体をドメイン配下に一斉配布するポリシー\n\n上記のグループポリシーをより分かりやすく表示し直したものが以下です（下図参照）。\n\nつまり、この「File.xml」のグループポリシーが適用された瞬間に、ドメイン配下の全ての端末のデスクトップ\n\nにLockBit2.0 のEXE ファイルがコピーされます。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 74 ドメイン配下端末へのLockBit2.0 のEXE ファイルの一斉配布が指定されたポリシー\n\n続いて、「ScheduledTasks.xml」というグループポリシー設定ファイル(xml)を作成します。\n\nこの「ScheduledTasks.xml」には、2 つのスケジュールタスクがまとめて記述されています。「Schedule\n\ndTasks.xml」の前方に「①プロセスの強制終了」に関するスケジュールタスクが、「ScheduledTasks.xm\n\nl」の後方に「②EXE ファイルの実行」に関するスケジュールタスクが設定されています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 75 LockBit2.0 が作成する「ScheduledTasks.xml」\n\n上記のグループポリシーをより分かりやすく表示し直したものが以下です。\n\n「プロセスの強制終了」に関するスケジュールタスクには、インシデント調査ツールや、データベースアプリ\n\nケーション、サーバアプリケーションなど、暗号化の邪魔となるプロセスの名前が並び、taskkill コマンドによ\n\nり即時強制終了されるよう設定されていることがわかります（下図参照）。\n\n図 76 指定した多数のプロセスを強制終了させるスケジュールタスク\n\nまた、「ScheduledTasks.xml」にある「EXE ファイルの実行」に関するスケジュールタスクには、さきほど\n\nの「File.xml」によってあらかじめ作成されたデスクトップ上のEXE ファイル（LockBit2.0 本体のコピー）\n\nを即時実行するルールが記述されています（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 77 配布したEXE を実行させるためのスケジュールタスク\n\n以下は、上記のグループポリシーにより、クライアント端末上に実際に配布されたスケジュールタスクの中身\n\nですが、上記で解説したものと同じものがスケジュールタスクとして設定されていることがわかります（下図\n\n参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 78 実際にクライアント端末側に作成されたスケジュールタスク\n\nまた、クライアント端末上のタスクスケジューラから確認したものが以下ですが、「プログラムの開始」とし\n\nてデスクトップ上のLockBit2.0 の本体のEXE パスが設定されていることがわかります（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 79 タスクスケジューラで確認した様子\n\n続いて、「Services.xml」と「NetworkShares.xml」という2 つのグループポリシー設定ファイル(xml)を\n\n作成します（下図参照）。\n\n図 80 作成されるサービスとネットワーク共有に関するポリシー設定ファイル\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n上記で作成された「Services.xml」には、クライアント端末上の複数のサービス（暗号化の邪魔となるサービ\n\nスなど）を停止させる処理が記述されています（下図参照）。\n\n図 81 LockBit2.0 が作成した「Services.xml」\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nもう一つ作成される「NetworkShares.xml」には、クライアント端末上の全てのドライブドライブをネット\n\nワーク共有に設定するためのポリシーが記述されています（下図参照）。この結果、他の感染端末からネット\n\nワーク越しに、それらのネットワーク共有されたドライブ内のファイルが暗号化されてしまう状況に陥ります。\n\n図 82 LockBit2.0 が作成した「NetworkShares.xml」\n\n続いて、「Registry.pol」というグループポリシーファイルを作成します（下図参照）。\n\nこの「Registry.pol」には、Windows Defender を無効化するための複数のレジストリ設定が記述されてい\n\nます。このポリシーが配布され適用されることにより、ドメイン配下の全てのクライアント端末上でWindow\n\ns Defender が無効化される可能性があります。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 83 LockBit2.0 が作成した「Registry.pol」\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nそして最後に、LockBit2.0 はPowerShell コマンドにより、強制的にグループポリシーをドメイン配下の全\n\n端末へ一斉配布します（下図参照）。\n\n図 84 PowerShell コマンドによりグループポリシーが一斉配布される様子\n\n上記のPowerShell のコマンドは以下のような構成となっており、「指定したOU に存在する全ての端末を取\n\n得」し、見つかった各端末に「グループポリシーを即時強制適用させる」コマンドであることがわかります（下\n\n図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 85 グループポリシーを一斉配布させるPowerShell コマンドの構成\n\n上記のPowerShell が実行された瞬間に、ドメインコントローラ上ではコマンドプロンプトが開き、グループ\n\nポリシーが更新される旨のメッセージが表示されます。またその直後、ドメイン配下にあるクライアント端末\n\n上でも同様にグループポリシーが更新されるプロンプトが表示されます（下図参照）。\n\n（この際、LockBit2.0 は自身の内部で「Run on all domain(waiting 1 min)」というログをメモリ上に展\n\n開します。）\n\n図 86 ドメインコントローラおよびクライアント端末上でグループポリシーが更新される様子\n\n上記のポリシーが強制的に適用された瞬間、クライアント端末上のデスクトップにはコピーされたLockBit2.\n\n0 のEXE ファイルが作成され実行されます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 87 グループポリシーの適用後デスクトップ上に作成されるEXE（LockBit2.0 の本体）\n\nグループポリシーによる不正処理の一斉展開の仕組みは以上となります。\n\nドメインコントローラでのグループポリシーを利用したランサムウェアの展開の様子を動画に収録し、以下の\n\nYouTube で公開していますので併せてご覧ください。\n\n[https://www.youtube.com/watch?v=Co8mRfd0iPM](https://www.youtube.com/watch?v=Co8mRfd0iPM)\n\n## ■LockBit2.0 のバグ（作成されたタスクのミス）\n\nなお、「ScheduledTasks.xml」に記載されていたデスクトップ上のEXE ファイルを実行させるタスクです\n\nが、調査の結果、複数の検体において、グループポリシーで配布されたEXE の実行が、クライアント端末側で\n\n失敗する個体が存在することを確認しました。\n\nLockBit2.0 は、各クライアント端末に「ドメイン管理者アカウント」（Administrator）が前提条件として\n\n「ログオンしている必要がある」タスクを設定してしまっており、現実的にはこの起動条件が満たさせること\n\nは通常はあまり起こりえません。\n\nただし、このタスク内の権限設定が「ドメイン管理者アカウント」（Administrator）ではなく「SYSTEM ア\n\nカウント」または「ユーザアカウント」が指定されていれば、攻撃者の意図する状況が成功していたものと考\n\nえらえます。実際に、LockBit2.0 が作成した「ScheduledTasks.xml」の中の権限設定の記述を手動で書き\n\n換え、「SYSTEM アカウント」を指定したものを配布するようにした場合、ポリシーが配布された直後にLo\n\nckBit2.0 がタスクにより実行され自動感染することが確認されました（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 88 LockBit2.0 のスケジュールタスクに発見されたバグと想定される設定\n\nただし、一連の調査を進めた後、新しく出現したLockBit2.0 の検体において、このバグが修正されている個\n\n体を発見しました。\n\n古い検体と新しい検体によって作成された「ScheduledTasks.xml」の記述をそれぞれ比較すると、上記でバ\n\nグであると推測していた部分の記述が以下のようにしっかりとピンポイントで修正されていることがわかりま\n\nす（下図参照）。\n\nそのため、この新しいLockBit2.0 の個体においては、ドメイン配下のクライアント端末上でスケジュールタ\n\nスクによってEXE が正常に実行され、自動的に感染が発生することも確認されました。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 89 新しいLockBit2.0 の検体でタスクのバグが修正されていることが確認された様子\n\nこのように、LockBit2.0 の開発者はバグを随時修正しながら攻撃に使用していることが明確に確認できたた\n\nめ、検体の挙動における個体差（揺れ）があり、挙動にバグがあったとしても既に修正されたバージョンが出\n\n回っている可能性は高く、安心できる状況ではありません。\n\nLockBit2．0 がグループポリシーで自身を拡散させる様子は動画に収録し以下のYouTube リンクで公開し\n\nていますのでご覧ください。\n\n[https://www.youtube.com/watch?v=Co8mRfd0iPM](https://www.youtube.com/watch?v=Co8mRfd0iPM)\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■デスクトップ壁紙の変更\n\nLockBit2.0 は、感染した端末のデスクトップの壁紙を脅迫文が記載されたものに変更する挙動がありますが、\n\n他のランサムウェアにみられるように単純にあらかじめ用意された画像を取り出して使用するのではなく、感\n\n染端末のディスプレイサイズに合わせたデザインとなるように、わざわざ「Windows GDI+」（Graphics D\n\nevice Interface）を用いて、一から画像を描画して壁紙を動的に生成します（下図参照）。\n\n図 90 壁紙を一から描画して生成\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n以下のように壁紙に表示させる文字列も復号して用意し、Windows GDI+のAPI を用いてテキストとして描\n\n画します（下図参照）。\n\n図 91 復号したテキスト文字列（脅迫文）を生成した画像に描画する処理\n\nLockBit2.0 は一時フォルダ（%temp%）内に、上記の流れで生成した画像を一時ファイルとして作成します\n\n（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 92 壁紙に設定する画像の出力\n\n作成した画像のフルパスを壁紙の設定に関わるレジストリ値を書き換えることで設定します。またその際、ディ\n\nスプレイサイズに合わせて壁紙が見やすくなるように、いくつかの設定を行います（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 93 生成した画像パスなどをレジストリに設定する処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n上記の操作により、設定された壁紙に関わるレジストリ設定は以下となります（下図参照）。\n\n図 94 LockBit2.0 により改変された壁紙に関わるレジストリ設定\n\n上記のレジストリを設定しただけではすぐに壁紙の変更がシステムに反映されないため、LockBit2.0 はSys\n\ntemParametersInfoW 関数を使用することで即時壁紙の変更を反映させます（下図参照）。\n\n図 95 SystemParametersInfoW による壁紙変更の即時反映\n\n以上により、動的に生成した壁紙がデスクトップに反映されます。\n\nなお、このデスクトップの壁紙には、インサイダー（内部者）を募集する記載が書き込まれるタイプの検体が存在し\n\nます（この壁紙を設定しない検体も存在します）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nインサイダーを募集する壁紙には「あなたも数百万ドルを稼ぎませんか？」と記載されており、この壁紙を見た人物\n\nに、どこかの会社の内部情報を知っている場合は攻撃者に提供すれば金銭を得られることを示唆する文章が並びます\n\n（下図参照）。\n\nこうしてインサイダーを募集する壁紙を設定するという挙動は他のランサムウェアに見られないため、LockBit2.0\n\nが持つ新規性の高い挙動の一つといえます。\n\nこれまでのRaaS においてはアフィリエイトなどが初期アクセスブローカーからの認証情報の購入に頼っていた側\n\n面もありますが、新しい攻撃手口のアイデアとしてインサイダーからの情報提供を初期アクセスのきっかけにしよう\n\nとする企みが垣間見えます。この企みが成功した場合、攻撃者の侵入経路として非常に効果的な手段を提供する新た\n\nな脅威となる可能性があります。\n\n図 96 インサイダーを募集する壁紙が設定された感染端末の様子\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■脅迫文が記述されたテキストファイルの作成\n\nLockBit2.0 は、暗号化したファイルが含まれるすべてのフォルダの中に、脅迫文が記述された「Restore-M\n\ny-Files.txt」というテキストファイルを作成します。この脅迫文には、組織内のデータが盗まれてすでに暗号\n\n化されている旨と、身代金を支払わなければデータがダークウェブ上に暴露されるリスクがある点などが記述\n\nされています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 97 全てのフォルダに作成されるテキスト形式の脅迫文\n\n## ■HTA ファイルによる脅迫文の表示\n\nLockBit2.0 は、脅迫文を提示する別の方法として、デスクトップにHTML で記述されたアプリケーションで\n\nあるHTA（HTML Application）ファイルを作成し利用します（下図参照）。このHTA ファイルには”ファ\n\nイルを復元するには攻撃者へコンタクトを取るしか道はない”という趣旨のコメントと、どのような手順でコ\n\nンタクトを取れば良いかが記載されています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 98 デスクトップに作成され脅迫文を表示するHTA ファイル\n\nまた、作成したHTA ファイルが端末の再起動時に常に自動的に起動するようにレジストリのRun キーに設定\n\nします（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 99 HTA ファイルを自動起動に関わるレジストリに設定する様子\n\n続いて、「.lockbit」という拡張子を持つファイルをユーザが開いた場合、該当のHTA ファイルが自動的に開\n\nくようにレジストリに設定を行います（下図参照）。\n\n図 100 暗号化されたファイルを開くとHTA ファイルが開くように設定されたレジストリ\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nそして、ShellExecuteW でHTA ファイルを起動し表示させます（下図参照）。\n\n図 101 感染後にHTA ファイルを自動的に開く処理\n\nこれにより、以下のように自動的にHTA ファイルが開かれます。画面サイズいっぱいに開かれるため、一見デ\n\nスクトップの壁紙に見えますが、これはHTA が表示するウインドウです（下図参照）。なお、このウインドウ\n\nは[Alt]+[F4]キーで閉じることができます。\n\n図 102 感染後にモニター上に表示されるHTA ファイルが生成するウインドウ\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■プリンタを利用した脅迫文の物理的な印刷（約一万枚）\n\nLockBit2.0 の特徴的な挙動の一つが、プリンタを利用した脅迫文の物理的な「印刷」です。\n\n印刷を行うランサムウェアの出現は初めてではなくEgregor という別のランサムウェアが過去に実装しては\n\nいたものの、ランサムウェア全体から見るとほとんど存在せず非常に珍しい挙動といえます。\n\nLockBit2.0 は「あなたのデータは盗まれた上に暗号化された。身代金を支払わなければデータが公開される」\n\nという文言が並んだ脅迫文を、感染端末からアクセス可能なネットワークプリンタを含む全てのプリンタで印\n\n刷しようとします。\n\n図 103 LockBit2.0 に感染し脅迫文をプリンタで印刷される様子\n\n＜余談＞\n\n以下の記事で解説していくように、ランサムウェアの解析結果を通した理論上においては、プリンタの印刷機\n\n能が特定され印刷機能を持っていることが把握できたのですが、実際にプリンタで印刷されるのか実検証した\n\nところ、想像以上に行き詰りました。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nまた、こうした物理的なデバイスに絡む挙動は仮想解析環境+仮想プリンタなどでは実機とは異なった結果と\n\nなる場合があり、実際に「仮想プリンタ」を用いた検証ではLockBit2.0 に感染させても印刷が発生しません\n\nでした。\n\nそのため、プリンタの実機を使用した検証を行うことにしました。プリンタ実機を感染端末に接続すればすん\n\nなり印刷されるものと想定していましたが実際には印刷が発生せず、複数台のプリンタを用いての数日間をま\n\nたいだ長い検証の結果、LockBit2.0 が送信する印刷データに対応しているプリンタ実機と、対応していない\n\nプリンタ実機があるという結論に達しました。\n\n他社の解析記事においてはLockBit2.0 の印刷機能に触れているもの自体が少ないですが、記載されている場\n\n合も「LockBit2.0 は脅迫文を印刷する」という程度にしか触れられておらず、実際には印刷されるプリンタ\n\nとされないプリンタがあるという新たな事実が今回の検証を通して判明したことになります。\n\n静的解析でコードを見ただけでは「印刷する」という挙動は判るものの、印刷されないプリンタが存在すると\n\nいう事実は実際に実機を用いて検証しないとわかり得ない結果であるといえます。以上の検証結果から、実際\n\nの被害組織においても印刷が発生した環境と、印刷が発生しなかった環境があるものと考えられます。\n\nLockBit2.0 は、プリンタ関連のAPI を使用するため、それらのAPI を提供する「Winspool.drv」をロード\n\nします（下図参照）。\n\n図 104 Winspool.drv をロードする処理の一部\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nその後、EnumPrinters 関数で感染端末からアクセス可能な全てのプリンタを列挙し取得します（下図参照）。\n\n図 105 感染端末上で利用可能な全てのプリンタを列挙する処理\n\n見つかった全てのプリンタに対し、それぞれOpenPrinter 関数で開き操作可能な状態にした上で、StartDoc\n\nPrinter 関数でページの印刷を通知します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 106 見つかったプリンタを開き印刷するページを通知する処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nその後、プリンタで印刷するための脅迫文の文字列を復号しメモリ上に展開します（下図参照）。\n\n図 107 全てのプリンタに印刷させる脅迫文の文字列を復号する処理\n\nそして、WritePrinter 関数で指定したプリンタに上記のデータを送信し印刷を指示します（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 108 指定したプリンタにデータを送る処理\n\n1 ページ分のデータの送信が完了したのち、EndDocPrinter 関数で指定されたプリンタの印刷ジョブを終了\n\nした上で、ClosePrinter 関数でプリンタオブジェクトを閉じます（下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 109 印刷終了の処理\n\n以上が1 ページ分の処理ですが、LockBit2.0 はこの処理を約1 万枚（9,999 ページ）分繰り返します（下\n\n図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 110 約一万枚印刷されるようにこれまで解説した一連の印刷処理を繰り返す\n\nつまり、プリンタ一台当たり9,999 枚印刷するよう指定されており、この操作を感染端末からアクセス可能\n\nなネットワークプリンタを含む全てのプリンタに対して行うため、途中でプリンタを急いで停止しない限り、\n\n延々と大量に脅迫文が印刷され続けてしまうことになります。\n\n従来のランサムウェアが行ってきたようにモニター上で提示する脅迫文だけでなく、物理的なデバイスを用い\n\nて脅迫するというこの手法は、やはり被害組織に与える恐怖やインパクトはより大きいものになるだろうと想\n\n像します。\n\nLockBit2.0 が実機プリンタで脅迫文を印刷する様子は動画に収録し、以下のYouTube で公開していますの\n\nで併せてご覧ください。\n\n[https://www.youtube.com/watch?v=zfh-FqPdXI4](https://www.youtube.com/watch?v=zfh-FqPdXI4)\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■インシデント対応や復旧作業を妨害する処理\n\nLockBit2.0 は以下のコマンドをcmd の引数として実行することで、システムのバックアップ（ボリューム\n\nシャドウコピー）や、イベントログを削除し、インシデント対応や復旧作業を妨害する処理を行います。\n\nなお、以下のうち上から4 つ目のコマンドには実効性がありませんが、他の一部のランサムウェアやマルウェ\n\nアでも同コマンドが確認されているため、開発者が参照した際に記述ミスのままコピーして使用しているもの\n\nと推測されます。\n\n図 111 LockBit2.0 がインシデント対応や復旧作業を妨害する処理\n\n## ■フォレンジックを意識した自身の抹消処理\n\nLockBit2.0 は全ての活動が終了すると、自身のEXE ファイルを削除しますが、その際、単純な削除（Delet\n\ne）ではなく、LockBit2.0 のEXE ファイルが存在するハードディスクの位置の先頭から512KB 分のハード\n\nディスク領域を直接0 で埋め尽くすことでファイルを破損させ完全に破壊した上で削除します。具体的には、\n\nfsutil コマンドを使用し「Data offset」と「length」によってサイズ範囲を指定した上で0 埋めした後De\n\nl コマンドによってファイルを削除します。（※なお、これらのコマンド処理は外部プロセスであるcmd.exe\n\nに依頼するため、実際にはLockBit2.0 のプロセスが終了した後で実施されます）\n\nこのことから、フォレンジック調査時にランサムウェア本体が正常に復元されないよう意識し、念入りに自身\n\nを抹消していることがわかります（以下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 112 ハードディスク上から自身のファイルの一部を破壊した上で消去するLockBit2.0\n\n加えて、上記のDel コマンドが失敗した場合に備え、Windows の再起動時に自動的にOS によってLockBit\n\n2.0 のEXE ファイルが削除されるよう、システムに予約設定を行います。具体的には、MoveFileExW 関数に\n\nMOVEFILE_DELAY_UNTIL_REBOOT の引数を渡すことでシステムに予約を行います（以下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 113 システム起動時に自動的にOS によって削除されるように設定するLockBit2.0\n\nこれらの2 つの方法で執拗に、不要になった自身のEXE を抹消しようとするランサムウェアは珍しい部類で\n\nあるといえ、復旧作業でランサムウェアを入手させないように入念な隠蔽工作を行おうとする意図が感じられ\n\nます。\n\nこれら一連の処理を行った後、LockBit2.0 はExitProecss により自身の処理を終了させます（以下図参照）。\n\n図 114 全ての処理を終えた後に自身を終了する処理\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nLockBit2.0 の挙動は以上となります。\n\n以降では、LockBit2.0 が実装しているその他の機能をご紹介します。\n\n## ■D&D（drag and drop）に対応\n\nLockBit2.0 のEXE ファイルは、ファイルやフォルダのD&D(drag and drop)に対応しています。この点に\n\n触れた解析記事は確認した範囲においては存在せず、世界的にも知られていないようです。\n\nLockBit2.0 は起動した際、CommandLineToArgW 関数を使用し実行引数の数が「2」であるかどうかを\n\nチェックします。引数の数が「2」である場合はD&D(drag and drop)の処理に遷移し、指定されたファイル\n\nまたは指定されたフォルダ内にあるすべてのファイルに対する暗号化処理のみを行います（以下図参照）。\n\nつまり、LockBit2.0 は、自動的に動作するランサムウェアとしてだけでなく、攻撃者が指定した対象（ファイ\n\nルやフォルダ）のみを暗号化したい、というシチュエーションでも活用できるよう、「暗号化ツール」として利\n\n用できるようにも開発されていることがわかります。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 115 D＆D に対応したLockBit2.0 のEXE 本体\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n## ■LockBit2.0 が隠し持つGUI(隠しウインドウ)の発見\n\n冒頭の表層解析で解説した通り、LockBit2.0 のEXE がGUI アプリケーションとしてビルドされていたのに\n\nも関わらず、一般的な表層解析の範囲ではGUI コンポーネントなどのリソースデータが確認できなかったこと\n\nが筆者は気がかりになっており、その観点でLockBit2.0 の起動中のプロセスを念入りに調査しました。\n\nその結果、起動中のプロセス内には表層解析では見えなかったリソースが出現しており、button やListView\n\nなどのGUI コンポーネントを持った非表示の”隠しウインドウ“が作成されていることを発見しました。隠し\n\nウインドウは「LockBit2.0 Ransom」という文字列を持っており、「LockBit_2_0_Ransom」というウイ\n\nンドウクラスを持つことがわかります（以下図参照）。\n\n図 116 LockBit2.0 のプロセスに隠されたGUI コンポーネントの発見\n\nまた、該当の隠しウインドウの状態を調べるとStyle が「4CF0000」(hidden,enabled)となっていることか\n\nら、ウインドウの作成はされているが非表示になっているということがわかります（以下図参照）。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 117 ウインドウが隠し状態に設定されている様子\n\nこの結果から改めて静的解析したところ、確かにCreateWindowExW 関数でウインドウを生成している処理\n\nが確認されました（以下図参照）。\n\n図 118 LockBit2.0 がウインドウを生成する処理\n\nまた、作成したウインドウをShowWindow 関数で表示する際、引数として非表示を意味する「0」が渡され\n\nていることも確認できました（以下図参照）。つまり、ウインドウが生成されてはいるものの非表示になって\n\nいるという先ほどの動的解析結果と一致することがわかります。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 119 生成したウインドウを非表示状態で表示させる処理\n\nそのため、非表示となっている隠しウインドウを無理やり表示させるようLockBit2.0 ランサムウェアのバイ\n\nナリを変更したところ、これまで世界的にも公に知られていなかったLockBit2.0 の隠しウインドウが表示さ\n\nれ姿を現しました（以下図参照）。\n\n表示されたウインドウは、複数のタブを持ちGUI コンポーネントが整然と並ぶグラフィカルなインターフェイ\n\nスとなっており、感染端末上のドライブ一覧や現在暗号中の状況がリアルタイムに表示される様子がわかりま\n\nす。また、右クリックメニューも用意され、暗号化処理の停止や再開などが選択できるようになっています。\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 120 姿を現したLockBit2.0 のGUI （本来隠されたウインドウ）\n\n以下は、「Log」タブを表示させた様子ですが、動作に関わる細かなログがリアルタイムに出力されていきま\n\nす。\n\n（これらのログ文字列は、該当する各処理の中で随時にメモリ上に展開されSendMessage 関数で送信され\n\nます）\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\n図 121 LockBit2.0 のGUI におけるLog タブの様子\n\n先ほど解説した通り､ShowWindow 関数の引数は変数ではなく0 で固定化(ハードコード)されているため､そ\n\nれはLockBit2.0 のEXE ファイルがコンパイルされた後に該当の値を動的に変更する仕組みを持たない可能\n\n性が高いということを意味します｡つまり､RaaS(Ransomware as a Service)の中で､アフィリエイトに提\n\n供されるLockBit2.0 のバイナリのビルド画面にこのGUI の表示に関わるオプションが用意されていると推\n\n測され､画面の表示/非表示があらかじめアフィリエイトによって設定された上でビルド(コンパイル)されてい\n\nるものと考えられます｡\n\n攻撃者がランサムウェアを被害組織内に展開し感染させる際は基本的にGUI 画面が表示されるべきではないた\n\nめ､このGUI オプションが有効になったバイナリが出回ることはほとんどないと想定され､そうした背景がLo\n\nckBit2.0 の隠しウインドウの存在が一般的に知られていない理由の一つであるといえます｡\n\n以上､今回弊社の解析により公で初めて明らかとなったLockBit2.0 のGUI が実際に動作する様子は､動画で\n\n収録し以下のYouTube にて公開しています｡\n\n[https://www.youtube.com/watch?v=-LEKTd4rJTU](https://www.youtube.com/watch?v=-LEKTd4rJTU)\n\n\n-----\n\nA deep-dive analysis of LockBit2.0 Ransomware\n\nその他､ドメインコントローラでのグループポリシーを利用したランサムウェアの展開の様子や､プリンタによ\n\nる印刷動画についても､それぞれ動画に収録し､以下のYouTube で公開していますので併せてご覧ください｡\n\n[https://www.youtube.com/watch?v=Co8mRfd0iPM](https://www.youtube.com/watch?v=Co8mRfd0iPM)\n\n[https://www.youtube.com/watch?v=zfh-FqPdXI4](https://www.youtube.com/watch?v=zfh-FqPdXI4)\n\n※動画が記事の理解のお役に立てた際はぜひ｢いいね!｣を押してフィードバックいただけますと幸いです｡\n\n※本記事で解析に使用した全てのLockBit2.0 のハッシュ値:\n\n0545f842ca2eb77bcac0fd17d6d0a8c607d7dbc8669709f3096e5c1828e1c049\n\n0906a0b27f59b6db2a2451a0e0aabf292818e32ddd5404d08bf49c601a466744\n\n4bb152c96ba9e25f293bbc03c607918a4452231087053a8cb1a8accb1acc92fd\n\n4edbf2358a9820e030136dc76126c20cc38159df0d8d7b13d30b1c9351e8b277\n\nbcbb1e388759eea5c1fbb4f35c29b6f66f3f4ca4c715bab35c8fc56dcf3fa621\n\n717585e9605ac2a971b7c7537e6e311bab9db02ecc6451e0efada9b2ff38b474\n\n73406e0e7882addf0f810d3bc0e386fd5fd2dd441c895095f4125bb236ae7345\n\na7591e4a248c04547579f014c94d7d30aa16a01bb2a25b77df36e30a198df108\n\nacad2d9b291b5a9662aa1469f96995dc547a45e391af9c7fa24f5921b0128b2c\n\nb3faf5d8cbc3c75d4c3897851fdaf8d7a4bd774966b4c25e0e4617546109aed5\n\nd089d57b8b2b32ee9816338e96680127babc5d08a03150740a8459c29ab3ba78\n\nf32e9fb8b1ea73f0a71f3edaebb7f2b242e72d2a4826d6b2744ad3d830671202\n\n3cbdd9250d50cf9e5c9aa6c0ade4dde2995e1319e96a160ba6730e063e86f5bc\n\n6edbe66b81f7168fa9d4b087c28409d6dfc98d560760369da4ed4ca2262abd33\n\n【ご注意】 - ホワイトペーパーは2021 年10 月19 日に公開した弊社ブログ記事（https://www.mbsd.jp/rese\n\narch/20211019/blog/）を再編集したものです。● このホワイトペーパーに掲載されている情報、画\n\n像、デザイン、レイアウト、ロゴマーク、商標等に関する全ての知的財産権は、三井物産セキュアディレク\n\nション株式会社(MBSD)又はMBSD にその利用を認めた権利者に帰属しています。● 不許複製\n\n### 三井物産セキュアディレクション株式会社\n\nhttps://www.mbsd.jp\n\n© 2021 Mitsu Bussan Secure Directions, Inc. All Rights Reserved.\n\n\n-----",
    "language": "JA",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.mbsd.jp/2021/10/27/assets/images/MBSD_WhitePaper_A-deep-dive-analysis-of-LockBit2.0_Ransomware.pdf"
    ],
    "report_names": [
        "MBSD_WhitePaper_A-deep-dive-analysis-of-LockBit2.0_Ransomware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666859779,
    "ts_updated_at": 1743041140,
    "ts_creation_date": 1635339251,
    "ts_modification_date": 1635345558,
    "files": {
        "pdf": "https://archive.orkl.eu/f83c6d6181c1bc9ca666c7397de0ff6832603e60.pdf",
        "text": "https://archive.orkl.eu/f83c6d6181c1bc9ca666c7397de0ff6832603e60.txt",
        "img": "https://archive.orkl.eu/f83c6d6181c1bc9ca666c7397de0ff6832603e60.jpg"
    }
}