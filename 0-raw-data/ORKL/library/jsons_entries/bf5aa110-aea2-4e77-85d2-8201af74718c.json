{
    "id": "bf5aa110-aea2-4e77-85d2-8201af74718c",
    "created_at": "2023-01-12T15:09:14.170656Z",
    "updated_at": "2025-03-27T02:06:01.83875Z",
    "deleted_at": null,
    "sha1_hash": "43cdf1dc7a0489c1b4fd857cef5ac7b96f5d2f8b",
    "title": "2016-12-07 - Floki Bot Strikes, Talos and Flashpoint Respond",
    "authors": "",
    "file_creation_date": "2021-03-13T04:21:31Z",
    "file_modification_date": "2021-03-13T04:21:31Z",
    "file_size": 107909,
    "plain_text": "# Changing memory protection in an arbitrary process.\n\n**[perception-point.io/changing-memory-protection-in-an-arbitrary-process](https://perception-point.io/changing-memory-protection-in-an-arbitrary-process/)**\n\nNovember 28, 2018\n\nRecently, we faced this very specific task: changing the protection flags of memory regions in\nan arbitrary process. As this task may seem trivial, we encountered some obstacles and\nlearned new things in the process, mostly about Linux mechanisms, memory protection and\nkernel development. Here is a brief overview of our work, including three approaches we\ntook and what made us seek for a better solution each time.\n\n## Introduction to mprotect.\n\nIn modern operating systems, each process has its own virtual address space (a mapping\nfrom virtual addresses to physical addresses). This virtual address space consists of memory\npages (contiguous memory chunks of some fixed size), and each page has protection flags\nwhich determine the kind of access allowed to this page (Read, Write & Execute). This\nmechanism relies on the architecture page tables (fun fact: in the x64 architecture, you can’t\nmake a page write-only, even if you specifically request it from your operating system – it will\nalways be readable as well).\n\nIn Windows, you can change the protection of a memory region with the API\nfunctions VirtualProtect or VirtualProtectEx. The latter makes our task very easy: its\nfirst argument, hProcess, is “a handle to the process whose memory protection is to be\n[changed” (from MSDN).](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366899(v=vs.85).aspx)\n\n**Linux Memory Protection**\n\nIn Linux, on the other hand, we’re not so lucky: the API to change memory protection is the\nsystem calls mprotect or pkey_mprotect, and both always operate on the current process’\naddress space. We’ll review now our approaches to solve this task in Linux on x64\narchitecture (we assume root privileges).\n\n**APPROACH ONE**\n\n## mprotect Code Injection.\n\nWell, if mprotect always acts on the current process, we need to make our target process call\nit from its own context. This is called code injection, and it’s achievable in many different\nways. We chose to implement it with the ptrace mechanism, which lets one process “observe\nand control the execution of another process” (from the man page), including the ability to\n\n\n-----\n\nchange the target process memory and registers. This mechanism is used in debuggers (like\ngdb) and tracing utilities (like strace). An outline of the steps required to inject code using\nptrace:\n\n1. Attach to the target process with ptrace. If there are multiple threads in the process, it\n\nmay be wise to stop all the other threads as well.\n2. Find an executable memory region (by examining /proc/PID/maps) and write there the\n\nopcode syscall (hex: 0f 05).\n3. Modify the registers according to the calling convention: first, change rax to the system\n\ncall number of mprotect (which is 10). Then, the first three arguments (which are the\nstart address, the length and the protection desired) are stored in rdi, rsi, and rdx\nrespectively. Finally, change rip to the address used in step 2.\n4. Resume the process until the system call returns (ptrace allows you to trace enters and\n\nexits of system calls).\n5. Recover the overridden memory and registers, detach from the process and resume its\n\nnormal execution.\n\nThis approach was our first and most intuitive one, and worked great until we discovered\n[another mechanism in Linux which completely ruined it: seccomp. Basically, it’s a security](https://en.wikipedia.org/wiki/Seccomp)\nfacility in the Linux kernel which allows a process to enter itself into some kind of a “jail”,\nwhere it can’t call any system call besides read, write, _exit and sigreturn. There is also an\noption to specify arbitrary system calls and their arguments to filter only them.\n\nTherefore, if a process enabled seccomp mode and we try inject a call to mprotect into it, then\nthe kernel will kill the process as it is not allowed to use this system call. We wanted to be\nable to act on these processes as well, so the search for a better solution continues…\n\n**APPROACH TWO**\n\n## Imitate mprotect in a kernel module.\n\nThe seccomp problem eliminated every solution from the process’ user mode, hence the next\napproach certainly resides in kernel mode. In the Linux kernel, each thread (both user\nthreads and kernel threads) is represented by a structure named task_struct, and the current\nthread (task) is accessible through the pointer current. The internal implementation of\nmprotect in the kernel uses the pointer current, so our first thought was – let’s just copypaste the code of mprotect to our kernel module, and replace each occurrence of current with\na pointer to our target thread’s task_struct. Right?\n\nWell, as you may have guessed, copying C code is not so trivial – there’s a heavy use of\nunexported functions, variables and macros which we just cannot access. Some functions\ndeclarations are exported in the header files, but their actual addresses aren’t exported by the\nkernel. This specific problem can be solved if the kernel was compiled with kallsyms support,\nand then it exports all of its internal symbols through the file /proc/kallsysm.\n\n\n-----\n\nDespite these problems, we tried to implement only the essence of mprotect, even solely for\neducational purposes. So we headed to write a kernel module which gets the target PID and\nthe parameters to mprotect, and imitates its behaviour. First, we need to obtain the desired\nmemory mapping object, which represents the address space of the thread:\n```\n  /* Find the task by the pid */\n  pid_struct = find_get_pid(params.pid);\n  if (!pid_struct)\n     return -ESRCH;\n  task = get_pid_task(pid_struct, PIDTYPE_PID);\n  if (!task) {\n    ret = -ESRCH;\n    goto out;\n  }\n  /* Get the mm of the task */\n  mm = get_task_mm(task);\n  if (!mm) {\n    ret = -ESRCH;\n    goto out;\n  }\n  …\n  …\nout:\n  if (mm) mmput(mm);\n  if (task) put_task_struct(task);\n  if (pid_struct) put_pid(pid_struct);\n\n```\nNow that we have the memory mapping object, we need to dig deeper. The Linux kernel\nimplements an abstraction layer to manage memory regions, each region is represented by\nthe structure vm_area_struct. To find the correct memory region, we use the\nfunction find_vma which searches the memory mapping by the desired address.\n\nThe vm_area_struct contains the field vm_flags which represents the protection flags of the\nmemory region in an architecture-independent manner, and vm_page_prot which\nrepresents it in an architecture-dependent manner. Changing these fields alone won’t really\naffect the page table (but will affect the output of /proc/PID/maps, we tried it!). You can read\n[more about it here.](https://manybutfinite.com/post/how-the-kernel-manages-your-memory/)\n\nAfter some reading and digging into the kernel code, we detected the most essential work\nneeded to really change the protection of a memory region:\n\n1. Change the field vm_flags to the desired protection.\n2. Call the function vma_set_page_prot_func to update the field vm_page_prot\n\naccording to the vm_flags field.\n\n\n-----\n\n3. Call the function change_protection_func to actually update the protection bits in\n\nthe page table.\n\nThis code works, but it has many problems – first, we implement only the essential parts of\nmprotect, but the original function does much more than we did (for example, splitting and\njoining memory regions by their protection flags). Second, we use two internal functions\nwhich are not exported by the kernel (vma_set_page_prot_func and\nchange_protection_func). We can call them using kallsyms, but this is prone to troubles\n(perhaps their names will be changed in the future, or maybe the whole internal\nimplementation of memory regions will be altered). We wanted a more generic solution\nwhich doesn’t take internal structures into consideration, so the search for a better solution\ncontinues…\n\n**APPROACH THREE**\n\n## Using the target process’s memory mapping.\n\nThis approach is very similar to the first one – there, we wanted to execute code in the\ncontext of the target process. Here, instead, we execute code in our own thread, but we use\nthe “memory context” of the target process, meaning: we use its address space.\n\nChanging your address space is possible in kernel mode through several API functions, of\nthem we will use use_mm. As the documentation clearly specifies, “this routine is intended\nto be called only from a kernel thread context”. These are threads which are created in the\nkernel and do not need any user address space, so it’s fine to change their address space (the\nkernel’s region inside the address space is mapped the same way in every task).\n\nOne easy way to run your code in a kernel thread is the work queue interface of the kernel,\nwhich allows you to schedule a work with a specific routine and specific arguments. Our work\nroutine is very minimal – it gets the memory mapping object of the desired process and the\nparameters to mprotect, and does the following (do_mprotect_pkey is the internal function\nin the kernel that implements the mprotect and pkey_mprotect system calls):\n```\nuse_mm(suprotect_work->mm);\nsuprotect_work->ret_value = do_mprotect_pkey(suprotect_work->start,\n                       suprotect_work->len,\n                       suprotect_work->prot, -1);\nunuse_mm(suprotect_work->mm);\n\n```\nWhen our kernel module gets a request to change protection in some process (through a\nspecial IOCTL), it first finds the desired memory mapping object (as we explained in the\nprevious approach) and then just schedules the work with the right parameters.\n\n\n-----\n\nThis solution still has one minor problem – the function do_mprotect_pkey_func isn t\nexported by the kernel and needs to be fetched using kallsyms. Unlike the former solution,\nthis internal function is not very prone to changes as it’s tied to the system call\npkey_mprotect, and we don’t handle internal structures, hence we can call it only a “minor\nproblem”.\n\nWe hope you found some interesting information and techniques in this post. If you’re\ninterested, the source code of this proof-of-concept kernel module is available in our\n[github here.](https://github.com/perceptionpoint/suprotect)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/Changing memory protection in an arbitrary process.pdf"
    ],
    "report_names": [
        "Changing memory protection in an arbitrary process.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536154,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1615609291,
    "ts_modification_date": 1615609291,
    "files": {
        "pdf": "https://archive.orkl.eu/43cdf1dc7a0489c1b4fd857cef5ac7b96f5d2f8b.pdf",
        "text": "https://archive.orkl.eu/43cdf1dc7a0489c1b4fd857cef5ac7b96f5d2f8b.txt",
        "img": "https://archive.orkl.eu/43cdf1dc7a0489c1b4fd857cef5ac7b96f5d2f8b.jpg"
    }
}