{
    "id": "26d3d373-49c1-4499-aa13-794069bc4fb4",
    "created_at": "2023-01-12T15:07:25.860343Z",
    "updated_at": "2025-03-27T02:15:35.754276Z",
    "deleted_at": null,
    "sha1_hash": "c592f50119f5148bca86ba994bc417e11176b786",
    "title": "2021-01-28 - A Look at iMessage in iOS 14",
    "authors": "",
    "file_creation_date": "2022-05-28T02:07:56Z",
    "file_modification_date": "2022-05-28T02:07:56Z",
    "file_size": 265009,
    "plain_text": "# A Look at iMessage in iOS 14\n\n**googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html**\n\nPosted By Samuel Groß, Project Zero\n\n[On December 20, Citizenlab published “The Great iPwn”, detailing how “Journalists [were] Hacked with Suspected NSO Group iMessage](https://citizenlab.ca/2020/12/the-great-ipwn-journalists-hacked-with-suspected-nso-group-imessage-zero-click-exploit/)\n‘Zero-Click’ Exploit”. Of particular interest is the following note: “We do not believe that [the exploit] works against iOS 14 and above, which\nincludes new security protections''. Given that it is also now almost exactly one year ago since we published the Remote iPhone\nExploitation blog post series, in which we described how an iMessage 0-click exploit can work in practice and gave a number of suggestions\non how similar attacks could be prevented in the future, now seemed like a great time to dig into the security improvements in iOS 14 in more\ndetail and explore how Apple has hardened their platform against 0-click attacks.\n\nThe content of this blog post is the result of a roughly one-week reverse engineering project, mostly performed on a M1 Mac Mini running\nmacOS 11.1, with the results, where possible, verified to also apply to iOS 14.3, running on an iPhone XS. Due to the nature of this project and\nthe limited timeframe, it is possible that I have missed some relevant changes or made mistakes interpreting some results. Where possible,\nI’ve tried to describe the steps necessary to verify the presented results, and would appreciate any corrections or additions.\n\nThe blog post will start with an overview of the major changes Apple implemented in iOS 14 which affect the security of iMessage. Afterwards,\nand mostly for the readers interested in the technical details, each of the major improvements is described in more detail while also providing a\nwalkthrough of how it was reverse engineered. At least for the technical details, it is recommended to briefly review the blog post series from\nlast year for a basic introduction to iMessage and the exploitation techniques used to attack it.\n\n## Overview\n\nMemory corruption based 0-click exploits typically require at least the following pieces:\n\n1. A memory corruption vulnerability, reachable without user interaction and ideally without triggering any user notifications\n2. A way to break ASLR remotely\n3. A way to turn the vulnerability into remote code execution\n4. (Likely) A way to break out of any sandbox, typically by exploiting a separate vulnerability in another operating system component (e.g. a\n\nuserspace service or the kernel)\n\nWith iOS 14, Apple shipped a significant refactoring of iMessage processing, and made all four parts of the attack harder. This is mainly due to\nthree central changes:\n\n## 1. The BlastDoor Service\n\nOne of the major changes in iOS 14 is the introduction of a new, tightly sandboxed “BlastDoor” service which is now responsible for almost all\n[parsing of untrusted data in iMessages (for example, NSKeyedArchiver payloads). Furthermore, this service is written in](https://bugs.chromium.org/p/project-zero/issues/detail?id=1858) [Swift, a (mostly)](https://developer.apple.com/swift/)\nmemory safe language which makes it significantly harder to introduce classic memory corruption vulnerabilities into the code base\n\n\n-----\n\ne o o g d ag a s o s t e oug e essage p ocess g p pe e, t t e a e o t e espect e se ce p ocess s o at t e top\nof each box.\n\nAs can be seen, the majority of the processing of complex, untrusted data has been moved into the new BlastDoor service. Furthermore, this\ndesign with its 7+ involved services allows fine-grained sandboxing rules to be applied, for example, only the IMTransferAgent and\napsd processes are required to perform network operations. As such, all services in this pipeline are now properly sandboxed (with the\nBlastDoor service arguably being sandboxed the strongest).\n\n## 2. Re-randomization of the Dyld Shared Cache Region\n\n[Historically, ASLR on Apple’s platforms had one architectural weakness: the shared cache region, containing most of the system libraries in a](https://iphonedevwiki.net/index.php/Dyld_shared_cache)\nsingle prelinked blob, was only randomized per boot, and so would stay at the same address across all processes. This turned out to be\nespecially critical in the context of 0-click attacks, as it allowed an attacker, able to remotely observe process crashes (e.g. through timing of\nautomatic delivery receipts), to infer the base address of the shared cache and as such break ASLR, a prerequisite for subsequent exploitation\nsteps.\n\nHowever, with iOS 14, Apple has added logic to specifically detect this kind of attack, in which case the shared cache is re-randomized for the\ntargeted service the next time it is started, thus rendering this technique useless. This should make bypassing ASLR in a 0-click attack context\nsignificantly harder or even impossible (apart from brute force) depending on the concrete vulnerability.\n\n## 3. Exponential Throttling to Slow Down Brute Force Attacks\n\nTo limit an attacker’s ability to retry exploits or brute force ASLR, the BlastDoor and imagent services are now subject to a newly introduced\nexponential throttling mechanism enforced by launchd, causing the interval between restarts after a crash to double with every subsequent\ncrash (up to an apparent maximum of 20 minutes). With this change, an exploit that relied on repeatedly crashing the attacked service would\nnow likely require in the order of multiple hours to roughly half a day to complete instead of a few minutes.\n\nThe remainder of this blog post will now look at each of these three changes in greater depths.\n\n## The BlastDoor Service\n\nThe new BlastDoor service and its role in the processing of iMessages can be studied by following the flow of an incoming iMessage. On the\n[wire, a simple text iMessage would look something like this, encoded as binary plist:](https://en.wikipedia.org/wiki/Property_list)\n\n{\n\n// Group UUID\n\ngid = \"008412B9-A4F7-4B96-96C3-70C4276CB2BE\";\n\n// Group protocol version\n\ngv = 8;\n\n\n-----\n\n// C at pa t c pa ts\n\np =   (\n\n\"mailto:sender@foo.bar\",\n\n\"mailto:receiver@foo.bar\"\n\n);\n\n// Participants version\n\npv = 0;\n\n// Message being replied to, usually the last message in the chat\n\nr = \"6401430E-CDD3-4BC7-A377-7611706B431F\";\n\n// The plain text content\n\nt = \"Hello World!\";\n\n// Probably some other version number\n\nv = 1;\n\n// The rich text content\n\nx = \"<html><body>Hello World!</body></html>\";\n\n}\n\nAs such, the minimal steps required to parse it are:\n\n1. If necessary, decompress the binary data\n2. Decode the plist from its binary serialization format\n3. Extract its various fields and ensure they have the correct type\n4. Decode the `x` key if present, using an XML decoder\n\nPreviously, all of this work happened in imagent. With iOS 14, however, it all moved into the new BlastDoor service. While the main processing\nflow still starts in imagent, which receives the raw but unencrypted payload bytes from identityservicesd (part of the IDS framework) in \n[IMDiMessageIDSDelegate service:account:incomingTopLevelMessage:fromID:messageContext:], messages are then more or less\nimmediately forwarded to the BlastDoor service through +[IMBlastdoor sendDictionary:withCompletionBlock:] which creates the reply handler\nblock and then calls -[IMMessagesBlastDoorInterface diffuseTopLevelDictionary:resultHandler:]. At that point processing ends up in Swift code\nthat deserializes the binary payload and sends it to the BlastDoor service over XPC.\n\nInside BlastDoor, the work mostly happens in BlastDoor.framework and MessagesBlastDoorService. As most of it is written in Swift, it is fairly\nunpleasant to statically reverse engineer it (no symbols, many virtual calls, swift runtime code sprinkled all over the place), but fortunately, that\nis also not really necessary for the purpose of this blog post. However, it is worth noting that while the high level control flow logic is written in\nSwift, some of the parsing steps still involve the existing ObjectiveC or C implementations. For example, XML is being parsed by libxml, and\nthe NSKeyedArchiver payloads by the ObjectiveC implementation of NSKeyedUnarchiver.\n\nThe responses from BlastDoor can be seen by breaking on the reply handler function in imagent (the function can be found in +[IMBlastdoor\nsendDictionary:withCompletionBlock:] or by searching for XREFs to the string “Blastdoor response %p received (command: %hhu, guid: %@)”\nin IMDaemonCore.framework). A typical BlastDoor response for a simple text message is shown below:\n\n(lldb) po $x2\n\nTextMessage(\n\nmetadata: BlastDoor.Metadata(\n\nmessageGUID: D391CC96-9CC6-44C6-B827-1DEB0F252529,\n\ntimestamp: Optional(1610108299117662350),\n\nwantsDeliveryReceipt: true,\n\nwantsCheckpointing: false,\n\nstorageContext: BlastDoor.Metadata.StorageContext(\n\n\n-----\n\ns o Sto age a se, s ast o Sto age a se\n\n)\n\n),\n\nmessageSubType: MessageType.textMessage(BlastDoor.Message(\n\nplainTextBody: Optional(\"Hello World\"),\n\nplainTextSubject: nil,\n\ncontent: Optional(BlastDoor.AttributedString(\n\nattributes: [\n\nBlastDoor.BaseWritingDirectionAttribute(\n\nrange: Range(0..<11), direction: WritingDirection.natural\n\n),\n\nBlastDoor.MessagePartAttribute(\n\nrange: Range(0..<11), partNumber: 0\n\n)\n\n],\n\nstring: \"Hello World\"\n\n)),\n\n_participantDestinationIdentifiers: [\n\n\"mailto:sender@foo.bar\",\n\n\"mailto:receiver@foo.bar\"\n\n],\n\nattributionInfo: []\n\n)),\n\nencryptionType: BlastDoor.TextMessage.EncryptionType.pair_ec,\n\nreplyToGUID: Optional(6401430E-CDD3-4BC7-A377-7611706B431F),\n\n_threadIdentifierGUID: nil,\n\n_expressiveSendStyleIdentifier: nil,\n\n_groupID: Optional(\"008412B9-A4F7-4B96-96C3-70C4276CB2BE\"),\n\ncurrentGroupName: nil,\n\ngroupParticipantVersion: Optional(0),\n\ngroupProtocolVersion: Optional(8),\n\ngroupPhotoCreationTime: nil,\n\nmessageSummaryInfo: nil,\n\nnicknameInformation: nil,\n\ntruncatedNicknameRecordKey: nil\n\n)\n\nOne can roughly associate every field in this data structure with parts of the on-wire iMessage format. For example, the plainTextBody field\ncontains the content of the `t` field while the content field corresponds to the content of the `x` field\n\n\n-----\n\nes des s p e te t essages, essages ca add t o a y co ta attac e ts (esse t a y a b t a y es c a e e c ypted a d te po a y\n[uploaded to iCloud) as well as rather complex serialized NSKeyedArchiver archives, which have been the source of bugs in the past.](https://developer.apple.com/documentation/foundation/nskeyedarchiver)\n\nFor these types of iMessages, the following additional parsing steps are necessary:\n\n1. Unpack attachment metadata (NSKeyedArchiver format)\n2. Download attachments from iCloud server\n3. Deserialize NSKeyedArchiver plugin archives and generate a preview for the notification\n\nAs an example, consider what happens when a user sends a link to a website over iMessage. In that case, the sending device will first render\na preview of the webpage and collect some metadata about it (such as the title and page description), then pack those fields into an\nNSKeyedArchiver archive. This archive is then encrypted with a temporary key and uploaded to the iCloud servers. Finally, the link as well as\nthe decryption key are sent to the receiver as part of the iMessage. In order to create a useful user notification about the incoming iMessage,\nthis data has to be processed by the receiver on a 0-click code path. As that again involves a fair amount of complexity, it is also done inside\nBlastDoor: after receiving the BlastDoor reply from above and realizing that the message contains an attachment, imagent first instructs\nIMTransferAgent to download and decrypt the iCloud attachment. Afterwards, it will call into -[IMTranscodeController\ndecodeiMessageAppPayload:bundleID:completionBlock:blockUntilReply:] which forwards the relevant data to the IMTranscoderAgent, which\nthen proceeds into +[IMAttachmentBlastdoor sendBalloonPluginPayloadData:withBundleIdentifier:completionBlock:] and finally calls \n[IMMessagesBlastDoorInterface defuseBalloonPluginPayload:withIdentifier:resultHandler:].\n\nIn the BlastDoor service, the plugin data decoding is then again performed in Swift, and dispatched to the corresponding plugin type, as\ndetermined by the plugin id. For RichLinks (plugin id com.apple.messages.URLBalloonProvider), processing ends up in\nLinkPresentation.MessagesPayload.init(dataRepresentation:), which deserializes the NSKeyedArchiver payload and to extract the preview\nimage and URL metadata from it in order to generate a preview message.\n\n## Sandboxing\n\nThe sandbox profile can be found in System/Library/Sandbox/Profiles/blastdoor.sb and is also attached at the end of this blog post. It appears\nto be identical on iOS and macOS. The profile can be studied statically, and for that purpose is attached at the bottom of this blogpost, or\ndynamically, for example by using the sandbox-exec tool:\n\n- echo \"(allow process-exec (literal \\\"$(pwd)/test\\\"))\" >> ./blastdoor.sb\n\n- clang -o test test.c  # try to open files, network connections, etc.\n\n- sandbox-exec -f ./blastdoor.sb ./test\n\nThe sandbox profile states:\n\n;;; This profile contains the rules necessary to make BlastDoor as close to\n\n;;; compute-only as possible, while still remaining functional.\n\nAnd indeed, the sandbox profile is quite tight:\n\nonly a handful of local IPC services, namely diagnosticd, logd, opendirectoryd, syslogd, and notifyd, can be reached\nalmost all file system interaction is blocked\nany interaction with IOKit drivers (historically a big source of vulnerabilities) is forbidden\noutbound network access is denied\n\nFurthermore, the profile makes use of syscall filtering to restrict the interactions with the core kernel. However, as of now the syscall filter\nseems to be in “permissive” mode:\n\n;; To be uncommented once the system call whitelist is complete...\n\n;; (deny syscall-unix (with send-signal SIGKILL))\n\nAs such, the BlastDoor service is still allowed to perform any syscall, but it is to be expected that the syscall filtering will soon be put into\n“enforcement mode”, which would further boost its effectiveness.\n\n## Crash Monitoring?\n\nAn interesting side effect of the new processing pipeline is that imagent is now able to detect when an incoming message caused a crash in\nBlastDoor (it will receive an XPC error). Even more interesting is the fact that imagent appears to be informing Apple’s servers about such\nevents, as can be seen by setting a breakpoint on -[APSConnectionServer handleSendOutgoingMessage:] in apsd, the daemon responsible\nfor implementing Apple’s push services (on top of which iMessage is built). Displaying the outgoing message will show the following:\n\n(lldb) po [$x2 dictionaryRepresentation]\n\n\n-----\n\n{\n\nAPSCritical = 1;\n\nAPSMessageID = 543;\n\nAPSMessageIdentifier = 1520040396;\n\nAPSMessageTopic = \"com.apple.madrid\";\n\nAPSMessageUserInfo =   {\n\nc = 115;\n\nfR = 13500;\n\nfRM = \"c-100-BlastDoor.Explosion-1-com.apple.BlastDoor.XPC-ServiceCrashed\";\n\nfU = {length = 16, bytes = 0x3a4912626c9645f98cb26c7c2d439520};\n\ni = 1520040396;\n\nnr = 1;\n\nt = {length = 32, bytes = ... };\n\nua = \"[macOS,11.1,20C69,Macmini9,1]\";\n\nv = 7;\n\n};\n\nAPSOutgoingMessageSenderTokenName = 501;\n\nAPSPayloadFormat = 1;\n\nAPSTimeout = 120;\n\nAPSTimestamp = \"2021-01-06 19:52:10 +0000\";\n\n}\n\nAs can be seen, imagent is apparently informing the iMessage servers that the message with the UUID\n0x3a4912626c9645f98cb26c7c2d439520 (fU key) has caused a crash in BlastDoor.\n\nIt is unclear what the purpose of this is without access to the server’s code. While these notifications may simply be used for statistical\npurposes, they would also give Apple a fairly clear signal about attacks against iMessage involving brute-force and a somewhat weaker signal\nabout any failed exploits against the BlastDoor service.\n\nIn my experiments, after observing one of these crash notifications, the server would start directly sending delivery receipts to the sender for\nmessages that hadn't actually been processed by the receiver yet. Possibly this is another, independent effort to break the crash oracle\ntechnique by confusing the sender, but that is hard to verify without access to the code running on the server. In any case, it is worth noting\nthat this “spoofing” of delivery receipts by the server is generally possible as the message UUID, which is more or less the only content of a\ndelivery receipt, is part of the non-end2end encrypted payload and is thus known to the server (break on -[APSConnectionServer\nhandleSendOutgoingMessage:] and inspect outgoing iMessages to verify this, the UUID will be in the U key, while the e2e-encrypted data will\nbe in the P key). This is most likely necessary so the server can track which messages have already been delivered and which ones it still\nneeds to keep around for delivery in the future.\n\n## Shared Cache Resliding\n\nPreviously, when exploiting an iMessage memory corruption bug, a “crash oracle” could be used to reveal the location of the shared cache\nregion in memory: the attacker would trigger the memory corruption bug in a way that would cause an access to a memory location\nsomewhere in the region 0x180000000 - 0x280000000 (where the shared cache can be mapped). If the memory was valid, no crash would\noccur and imagent would then send a delivery receipt to the attacker. However, If a crash occurred, no such receipt would be delivered,\ninforming the attacker that the address was unmapped. Through clever selection of the queried addresses, the location of the shared cache\ncould be revealed in logarithmic time, with only about 20 messages.\n\nHowever, with iOS 14 Apple has added a mechanism to re-randomize the location of the shared cache region for an “attacked” process, thus\nbreaking a fundamental assumption of this technique and rendering it ineffective. This is significant as the crash oracle technique was one of\nvery few, if not the only, fairly generic ASLR bypass techniques usable in 0-click iMessage attacks.\n\n\n-----\n\no u de sta d o t e s a ed cac e es d g o s, o e ca sta t by oo g at t e e e OS, t e e e ca o a e t o act e\n[shared cache regions: the “regular” region and a “reslided” region. During an attack, the following then happens:](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/osfmk/vm/vm_shared_region.h#L224)\n\n1. When an attacker attempts to use a crash-oracle-based technique, the attacked process would quickly end up accessing unmapped\n\nmemory in the range 0x180000000 - 0x280000000 (where the shared cache is mapped) and crashes\n[2. The kernel handles the segmentation fault generated by the CPU, and sets a specific flag in the crash info that signals that the crash](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/bsd/kern/kern_sig.c#L2009)\n\nhappened inside the shared cache region\n[3. At the same time, the kernel will mark the currently active reslided shared cache region (if one exists) as stale, causing it to be recreated](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/bsd/kern/kern_sig.c#L2040)\n\nand thus re-randomized the next time it is used\n4. launchd (as the parent process of the crashed service) receives the crash info, notices the\n\nOS_REASON_FLAG_SHAREDREGION_FAULT flag, and sets the ReslideSharedCache property on the service associated with the\ncrashed process (see `launchctl procinfo $pid` and search for `reslide shared cache = 1`)\n[5. The next time the service is restarted, launchd then adds the POSIX_SPAWN_RESLIDE attribute for](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/bsd/sys/spawn.h#L78) [posix_spawn due to the](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/posix_spawn.2.html)\n\nReslideSharedCache property\n[6. In the kernel, this flag now causes the newly created process to be given the reslided shared cache image. However, as no active](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/osfmk/vm/vm_shared_region.h#L224)\n\nreslided region currently exists (the previous one was marked as stale in step 3.), a new one is created at a newly randomized address.\n\nThe result of this is that whenever an attacker attempts to use a crash-oracle to break ASLR, the attacked service would receive a different\nshared cache region every time it is launched, thus preventing the attack from succeeding. For the time being, this feature appears to only be\nactive on iOS though, but it would be expected to come to macOS as well.\n\nWhile this mechanism would in principle also protect 3rd party apps from similar attacks, protection for those is currently somewhat weaker,\nlikely in order to first evaluate the real-world performance impact of this change (the shared cache is a significant performance optimization of\n[the OS). In particular, step 3 is currently only performed if the crashing process is a platform binary (essentially binaries that ship with the OS](https://developer.apple.com/documentation/endpointsecurity/es_process_t/3228979-is_platform_binary)\nand are directly signed by Apple) such as the services handling iMessages. However, for 3rd party processes, it would only happen if the\n[global vm_shared_region_reslide_restrict is set to zero:](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/bsd/kern/kern_exec.c#L217)\n\n/*\n\n- Flag to control what processes should get shared cache randomize resliding\n\n- after a fault in the shared cache region:\n\n\n- 0 - all processes get a new randomized slide\n\n- 1 - only platform processes get a new randomized slide\n\n*/\n\nWhich is [controlled by the vm_shared_region_reslide_restrict bootarg. This currently seems to be set to one. In essence, for 3rd party apps](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/bsd/kern/kern_exec.c#L6397)\nthis means:\n\n1. When the attacked process first crashes, the kernel will still set the OS_REASON_FLAG_SHAREDREGION_FAULT flag, and\n\nlaunchd will add the ReslideSharedCache property, but the current reslided region won’t be invalidated\n2. The restarted service is then restarted and now uses the “reslided” shared cache region\n3. When the service crashes the next time, and if that service is the only one currently using the reslided shared cache region (which should\n\nusually be the case, but could possibly be influenced by the attacker), the region’s refcount drops to zero, and the shared cache region is\nmarked for removal.\n[4. However, removal will only actually happen after two minutes. As such, if the service is restarted within two minutes, it will receive the](https://github.com/apple/darwin-xnu/blob/d4061fb0260b3ed486147341b72468f836ed6c8f/osfmk/vm/vm_shared_region.c#L144)\n\nsame shared cache region at the same location in memory.\n\nAs a result, a third-party app could still be attacked through a crash-oracle technique if it automatically sends some form of delivery receipt to\nthe sender and restarts quickly enough after a crash. This could, however, be prevented for example by enabling ExponentialThrottling for\nthese services. Ideally, and assuming that the performance penalty is reasonable, Apple would enable re-randomization for all apps in the\nfuture.\n\n## Exponential Throttling\n\nAnother thing we suggested back in 2019 was to limit the number of attempts an attacker gets when attempting to exploit a vulnerability. This\nwas mostly important to defend against the crash-oracle technique, but would also help to prevent brute force attacks (e.g., given enough\nattempts, one could simply brute force the location of the shared cache region). The new ExponentialThrottling feature in launchd seems to\nachieve just that.\n\nTo use it, a system daemon or agent has to opt-in by setting \"_ExponentialThrottling = 1” in its Info.plist (essentially the service metadata), as\ncan be seen below for the BlastDoor service:\n\n\n-----\n\np ut p\n/System/Library/PrivateFrameworks/MessagesBlastDoorSupport.framework/Versions/A/XPCServices/MessagesBlastDoorService.xpc/Contents/Inf\n\n{\n\n\"CFBundleDisplayName\" => \"MessagesBlastDoorService\"\n\n\"CFBundleExecutable\" => \"MessagesBlastDoorService\"\n\n\"CFBundleIdentifier\" => \"com.apple.MessagesBlastDoorService\"\n\n...\n\n\"XPCService\" => {\n\n\"_ExponentialThrottling\" => 1\n\n}\n\n}\n\nApart from the BlastDoor service, it is also used for imagent:\n\n- plutil -p /System/Library/LaunchAgents/com.apple.imagent.plist\n\n{\n\n\"_ExponentialThrottling\" => 1\n\n...\n\nbut doesn’t appear to be used for any other service, as can, for example, be seen by looking at the output of the launchctl\ndumpstate command, which will only show “exponential throttling = 1” for com.apple.imagent and com.apple.MessagesBlastDoorService.\n\nPresumably, the _ExponentialThrottling property instructs launchd (the macOS and iOS init process), to delay subsequent restarts of a\ncrashing service. While it is somewhat challenging to statically reverse engineer launchd due to the lack of source code or binary symbols, it is\nfortunately fairly easy to experimentally determine the impact of the _ExponentialThrottling property, for example by installing a custom\ndaemon that writes the current timestamp to a file before crashing. By default, so without ExponentialThrottling, one would see the following:\n\nService started on Wed Jan 6 13:56:03 2021\n\nService started on Wed Jan 6 13:56:13 2021\n\nService started on Wed Jan 6 13:56:23 2021\n\nService started on Wed Jan 6 13:56:33 2021\n\nAs can be seen, by default, a service is, at the earliest, restarted ten seconds after it was previously started. However, using the following\nservice plist which enables ExponentialThrottling:\n\n- # Start service with\n\n- # launchctl bootstrap system /Library/LaunchDaemons/net.saelo.test.plist\n\n- plutil -p /Library/LaunchDaemons/net.saelo.test.plist\n\n{\n\n\"_ExponentialThrottling\" => 1\n\n\"KeepAlive\" => 1\n\n\"Label\" => \"net.saelo.test\"\n\n\"POSIXSpawnType\" => \"Interactive\"\n\n\"Program\" => \"/path/to/program\"\n\n}\n\nOne can observe the following:\n\nService started on Wed Jan 6 10:42:43 2021\n\n\n-----\n\nSe ce sta ted o ed Ja 6 0 53 0 ( 0s)\n\nService started on Wed Jan 6 10:43:03 2021 (+10s)\n\nService started on Wed Jan 6 10:43:13 2021 (+10s)\n\nService started on Wed Jan 6 10:43:33 2021 (+20s)\n\nService started on Wed Jan 6 10:44:13 2021 (+40s)\n\nService started on Wed Jan 6 10:45:33 2021 (+80s)\n\nService started on Wed Jan 6 10:48:13 2021 (+160s [~2.5m])\n\nService started on Wed Jan 6 10:53:33 2021 (+320s [~5m])\n\nService started on Wed Jan 6 11:04:13 2021 (+640s [~10m])\n\nService started on Wed Jan 6 11:24:13 2021 (+20m)\n\nService started on Wed Jan 6 11:44:13 2021 (+20m)\n\nService started on Wed Jan 6 12:04:13 2021 (+20m)\n\nHere, the exponential increase in the time between subsequent restarts is clearly visible, and goes up to an apparent maximum of 20 minutes.\nAnd indeed, launchd does contain the following bit of code in a function presumably responsible for computing the next restart delay (search\nfor XREFs to the string \"%s: service throttled by %llu seconds\"):\n\nif ( delay >= 1200 )\n\nresult = 1200LL;         // 20 minutes\n\nelse\n\nresult = delay;\n\nWith this change, an exploit that relied on brute force would now only get one attempt every 20 minutes instead of every 10 seconds.\n\n## (Upcoming?) ObjectiveC ISA PAC\n\nThe PoC exploit against iMessage on iOS 12.4 relied heavily on faking ObjectiveC objects to gain a form of arbitrary code execution despite\nthe presence of [pointer authentication (PAC). This was mainly possible because the ISA field, containing the pointer to the Class object and](https://support.apple.com/guide/security/pointer-authentication-codes-seca5759bf02/web)\nthus making a piece of memory appear like a valid ObjectiveC object, was not protected through PAC and could thus be faked. With iOS 14,\nthis now seems to be changing: while previously, the [top 19 bits of the ISA value contained the inline refcount, it now appears that this field has](https://github.com/opensource-apple/objc4/blob/cd5e62a5597ea7a31dccef089317abb3a661c154/runtime/objc-private.h#L93)\nbeen reduced to 9 bits (of which the LSB appears to be reserved for some purpose, leaving an 8-bit inline refcount, see the bit shifting logic in\nobjc_release or objc_retain), while the freed-up bits now hold a PAC, as can be seen in objc_rootAllocWithZone in libobjc.dylib:\n\n; Allocate the object\n\nBL       j__calloc_3\n\nCBZ       X0, loc_1953DA434\n\nMOV       X8, X0\n\n; “Tag” the address with a constant to get a PAC modifier value\n\nMOVK      X8, #0x6AE1,LSL#48\n\nMOV       X9, X19\n\n; Compute PAC of Class pointer with tagged object address as modifier\n\nPACDA      X9, X8\n\n; Clear top 9 bits (inline refcnt) and bottom 3 bits (other bitfields)\n\nAND       X8, X9, #0x7FFFFFFFFFFFF8\n\n; Set LSB and inline refcount to one\n\nMOV       X9, #0x100000000000001\n\n\n-----\n\nO 9, 8, 9\n\n; Presumably, the refcnt isn’t used for all types of classes...\n\nTST       W20, #0x2000\n\nCSEL      X8, X9, X8, EQ\n\n; Store the resulting value into the ISA field\n\nSTR       X8, [X0]\n\nHowever, currently the ISA PAC appears to never be checked, as such, it doesn’t yet affect any exploits. The most likely reason for this is that\nthe ISA PAC feature is being rolled out in multiple phases, with the current implementation meant to allow in-depth performance evaluation, in\nparticular of the reduced size of the inline refcount, which will likely cause more objects to use the more expensive out-of-line refcounting (used\n[once the inline refcount saturates). With that, it can be expected that, in the absence of major performance issues, future releases of iOS and](https://github.com/opensource-apple/objc4/blob/cd5e62a5597ea7a31dccef089317abb3a661c154/runtime/objc-object.h#L392)\nmacOS will use PAC for the ObjC ISA field, thus likely breaking exploits that have to rely on faking ObjectiveC objects to achieve arbitrary code\nexecution.\n\n## Conclusion\n\nThis blog post discussed three improvements in iOS 14 affecting iMessage security: the BlastDoor service, resliding of the shared cache, and\nexponential throttling. Overall, these changes are probably very close to the best that could’ve been done given the need for backwards\ncompatibility, and they should have a significant impact on the security of iMessage and the platform as a whole. It’s great to see Apple putting\naside the resources for these kinds of large refactorings to improve end users’ security. Furthermore, these changes also highlight the value of\noffensive security work: not just single bugs were fixed, but instead structural improvements were made based on insights gained from exploit\ndevelopment work.\n\nAs for the alleged NSO iMessage exploit, it may have been prevented from working against iOS 14 by any of the following:\n\nThe bug was fixed in iOS 14, for example due to the rewrite of large parts of the iMessage processing pipeline in Swift\n\nThe mere fact that processing happens in a different process, which could for example break a heap layouting primitive\nThe shared cache resliding would break their exploit if their exploit relied on some form of crash oracle to break ASLR\nThe stronger sandbox of the BlastDoor service, which could prevent the exploitation of a privilege escalation vulnerability after\ncompromising the BlastDoor process\n\nWhile these are some possible scenarios, and it could be the case that the exploit “just” needs some re-engineering to function again, the fact\nthat these security improvements were shipped is certainly a positive outcome.\n\n## Attachment 1: blastdoor.sb\n\n;;; This profile contains the rules necessary to make BlastDoor as close to\n\n;;; compute-only as possible, while still remaining functional.\n\n;;;\n\n;;; For all platforms:\n/System/Library/PrivateFrameworks/MessagesBlastDoorSupport.framework/XPCServices/MessagesBlastDoorService.xpc/MessagesBlastDoorSe\n\n(version 1)\n\n;;; -------------------------------------------------------------------------------------------- ;;;\n\n;;; Basic Rules\n\n;;; -------------------------------------------------------------------------------------------- ;;;\n\n;; Deny all default rules.\n\n(deny default)\n\n(deny file-map-executable process-info* nvram*)\n\n(deny dynamic-code-generation)\n\n;; Rules copied from system.sb. Ones that we've deemed overly permissive\n\n;; or unnecessary for BlastDoor have been removed.\n\n\n-----\n\n;; o ead access to sta da d syste pat s\n\n(allow file-read*\n\n(require-all (file-mode #o0004)\n\n(require-any (subpath \"/System\")\n\n(subpath \"/usr/lib\")\n\n(subpath \"/usr/share\")\n\n(subpath \"/private/var/db/dyld\"))))\n\n(allow file-map-executable\n\n(subpath \"/System/Library/CoreServices/RawCamera.bundle\")\n\n(subpath \"/usr/lib\")\n\n(subpath \"/System/Library/Frameworks\"))\n\n(allow file-test-existence (subpath \"/System\"))\n\n(allow file-read-metadata\n\n(literal \"/etc\")\n\n(literal \"/tmp\")\n\n(literal \"/var\")\n\n(literal \"/private/etc/localtime\"))\n\n;; Allow access to standard special files.\n\n(allow file-read*\n\n(literal \"/dev/random\")\n\n(literal \"/dev/urandom\"))\n\n(allow file-read* file-write-data\n\n(literal \"/dev/null\")\n\n(literal \"/dev/zero\"))\n\n(allow file-read* file-write-data file-ioctl\n\n(literal \"/dev/dtracehelper\"))\n\n;; TODO: Don't allow core dumps to be written out unless this is on a dev\n\n;; fused device?\n\n(allow file-write*\n\n(require-all (regex #\"^/cores/\")\n\n(require-not (file-mode 0))))\n\n;; Allow IPC to standard system agents.\n\n(allow mach-lookup\n\n(global-name \"com.apple.diagnosticd\")\n\n(global-name \"com.apple.logd\")\n\n(global-name \"com.apple.system.DirectoryService.libinfo_v1\")\n\n(global-name \"com.apple.system.logger\")\n\n\n-----\n\n(g oba a e co app e syste ot cat o _ce te ))\n\n;; Allow mostly harmless operations.\n\n(allow signal process-info-dirtycontrol process-info-pidinfo\n\n(target self))\n\n;; Temporarily allow sysctl-read with reporting to see if this is\n\n;; used for anything.\n\n(allow (with report) sysctl-read)\n\n;; We don't need to post any darwin notifications.\n\n(deny darwin-notification-post)\n\n;; We shouldn't allow any other file operations not covered under\n\n;; the default of deny above.\n\n(deny file-clone file-link)\n\n;; Don't deny file-test-existence: <rdar://problem/59611011>\n\n;; (deny file-test-existence)\n\n;; Don't allow access to any IOKit properties.\n\n(deny iokit-get-properties)\n\n(deny mach-cross-domain-lookup)\n\n;; Don't allow BlastDoor to spawn any other XPC services other than\n\n;; ones that we can intentionally whitelist later.\n\n(deny mach-lookup (xpc-service-name-regex #\".*\"))\n\n;; Don't allow any commands on sockets.\n\n(deny socket-ioctl)\n\n;; Denying this should have no ill effects for our use case.\n\n(deny system-privilege)\n\n;; To be uncommented once the system call whitelist is complete...\n\n;; (deny syscall-unix (with send-signal SIGKILL))\n\n(allow syscall-unix\n\n(syscall-number SYS_exit)\n\n(syscall-number SYS_kevent_qos)\n\n(syscall-number SYS_kevent_id)\n\n(syscall-number SYS_thread_selfid)\n\n(syscall-number SYS_bsdthread_ctl)\n\n(syscall-number SYS_kdebug_trace64)\n\n(syscall-number SYS_getattrlist)\n\n(syscall-number SYS_sigsuspend_nocancel)\n\n(syscall-number SYS_proc_info)\n\n\n-----\n\n(sysca u be S S___d sab e_t eads g a )\n\n(syscall-number SYS___pthread_sigmask)\n\n(syscall-number SYS___mac_syscall)\n\n(syscall-number SYS___semwait_signal_nocancel)\n\n(syscall-number SYS_abort_with_payload)\n\n(syscall-number SYS_access)\n\n(syscall-number SYS_bsdthread_create)\n\n(syscall-number SYS_bsdthread_terminate)\n\n(syscall-number SYS_close)\n\n(syscall-number SYS_close_nocancel)\n\n(syscall-number SYS_connect)\n\n(syscall-number SYS_csops_audittoken)\n\n(syscall-number SYS_csrctl)\n\n(syscall-number SYS_fcntl)\n\n(syscall-number SYS_fsgetpath)\n\n(syscall-number SYS_fstat64)\n\n(syscall-number SYS_fstatfs64)\n\n(syscall-number SYS_getdirentries64)\n\n(syscall-number SYS_geteuid)\n\n(syscall-number SYS_getfsstat64)\n\n(syscall-number SYS_getgid)\n\n(syscall-number SYS_getrlimit)\n\n(syscall-number SYS_getuid)\n\n(syscall-number SYS_ioctl)\n\n(syscall-number SYS_issetugid)\n\n(syscall-number SYS_lstat64)\n\n(syscall-number SYS_madvise)\n\n(syscall-number SYS_mmap)\n\n(syscall-number SYS_munmap)\n\n(syscall-number SYS_mprotect)\n\n(syscall-number SYS_mremap_encrypted)\n\n(syscall-number SYS_open)\n\n(syscall-number SYS_open_nocancel)\n\n(syscall-number SYS_openat)\n\n(syscall-number SYS_pathconf)\n\n(syscall-number SYS_pread)\n\n(syscall-number SYS_read)\n\n\n-----\n\n(sysca u be S S_ ead )\n\n(syscall-number SYS_shm_open)\n\n(syscall-number SYS_socket)\n\n(syscall-number SYS_stat64)\n\n(syscall-number SYS_statfs64)\n\n(syscall-number SYS_sysctl)\n\n(syscall-number SYS_sysctlbyname)\n\n(syscall-number SYS_workq_kernreturn)\n\n(syscall-number SYS_workq_open)\n\n)\n\n;; Still allow the system call but report in log.\n\n(allow (with report) syscall-unix)\n\n;; For validating the entitlements of clients. This is so only entitled\n\n;; clients can pass data into a BlastDoor instance.\n\n(allow process-info-codesignature)\n\n;;; -------------------------------------------------------------------------------------------- ;;;\n\n;;; Reading Files\n\n;;; -------------------------------------------------------------------------------------------- ;;;\n\n;; Support for BlastDoor receiving sandbox extensions from clients to either read files, or\n\n;; write to a target location.\n\n;; com.apple.app-sandbox.read\n\n(allow file-read*\n\n(extension \"com.apple.app-sandbox.read\"))\n\n;; com.apple.app-sandbox.read-write\n\n(allow file-read* file-write*\n\n(extension \"com.apple.app-sandbox.read-write\"))\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-28 - A Look at iMessage in iOS 14.pdf"
    ],
    "report_names": [
        "2021-01-28 - A Look at iMessage in iOS 14.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536045,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1653703676,
    "ts_modification_date": 1653703676,
    "files": {
        "pdf": "https://archive.orkl.eu/c592f50119f5148bca86ba994bc417e11176b786.pdf",
        "text": "https://archive.orkl.eu/c592f50119f5148bca86ba994bc417e11176b786.txt",
        "img": "https://archive.orkl.eu/c592f50119f5148bca86ba994bc417e11176b786.jpg"
    }
}