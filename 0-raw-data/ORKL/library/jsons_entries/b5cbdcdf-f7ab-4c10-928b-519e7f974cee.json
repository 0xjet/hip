{
    "id": "b5cbdcdf-f7ab-4c10-928b-519e7f974cee",
    "created_at": "2023-01-12T15:09:58.731422Z",
    "updated_at": "2025-03-27T02:05:42.875776Z",
    "deleted_at": null,
    "sha1_hash": "c45e633e1317b5c2240a59f4ec104d4899129ada",
    "title": "2021-07-24 - Quack Quack- Analysing Qakbot’s Browser Hooking Module – Part 1",
    "authors": "",
    "file_creation_date": "2022-05-27T22:03:49Z",
    "file_modification_date": "2022-05-27T22:03:49Z",
    "file_size": 2401277,
    "plain_text": "# Quack Quack: Analysing Qakbot’s Browser Hooking Module – Part 1\n\n**[0ffset.net/reverse-engineering/malware-analysis/qakbot-browser-hooking-p1/](https://www.0ffset.net/reverse-engineering/malware-analysis/qakbot-browser-hooking-p1/)**\n\nJuly 24, 2021\n\n\n-----\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n24th July 2021\nNo Comments\n\nQakbot is one of the most notorious malware families currently operating, and dates back to\naround 2007. It is primarily focused around stealing banking information and user\ncredentials, however with the huge jump in ransomware popularity among threat actors,\nQakbot has been seen to drop Egregor and the ProLock ransomware. As it is primarily\noperated with an affiliate based business model, a number of threat actors have used it to\ntarget different industry sectors, all with varying tactics, techniques, and procedures.\n\nQakbot is highly modular, with the core payload acting as a loader for additional modules\nsent by the command and control server. Modules include a hidden VNC plugin, an email\ncollector, a password grabber, and a browser hooking module, which is the main focus of this\npost.\n\nI have previously covered Qakbot’s browser hooking module, with a focus on the fairly simple\nInternet Explorer hooking functionality. In the next few posts, we’ll be analysing how the\nmodule hooks Google Chrome API, and what the malicious replacement functions do in\norder to modify the contents of a web-page, all while supporting both HTTP and HTTP2\ntraffic. In this first post, we’ll be looking at leveraging IDA Python to speed up our analysis of\nthis binary, by developing 3 main scripts; a string decryptor, an API resolver, and a structure\nresolver for the target API to be hooked. Want to jump straight in? You can find the scripts\n**[here!](https://github.com/0ffsetTrainingSolutions/QakbotTools)**\n\n**Browser Hooking Module MD5 Hash:** **02ca3e9c06b2a9b2df05c97a8efa03e7**\n\n## Table of Contents\n\n\n-----\n\n## String Decryption\n\nThe string decryption function is fairly simple to replicate, all that entails is a basic XOR\nalgorithm. Our goal however, is not just to replicate it. This module has two core string\ndecryption functions, which appear in four function wrappers. The four function wrappers are\ncalled a total of 66 times, which would make manual decryption quite tedious.\n\nAdditionally, each of the four wrappers utilise different arguments. The core string decryption\nfunction accepts four arguments in total; a string offset, an encrypted data blob, the\nencrypted data blob size, and a key blob. All but one of the function wrappers accept one\nargument, which is the string offset – the other wrapper accepts no arguments, and uses a\nhardcoded offset.\n\n\n-----\n\nLuckily for us, there are minimal differences across the function wrappers, with the important\ndata pushed to the string decryption function in a similar fashion. In order to get the string\nblob address, we need to query the address before the call to the string decryption function.\nWe then need to query the address before that, and check for a push instruction. If there is\nnot one, we’re dealing with the wrapper using a hardcoded offset, so we need to handle it\ndifferently. If there is, we can grab the string blob size, and jump back one more address to\nlocate the address of the key blob.\n\nSo, we will be writing a script to accept the addresses of the two core string decryption\nfunctions, locate the function wrappers, gather the relevant arguments from the wrappers,\nbefore finding all cross references to the wrappers, and locating the string offset.\n\nThe main IDA API we’ll be using for this are:\n\n\n-----\n\n```\nidc.prev_head() # get the previous address\nidc.get_operand_value() # get operand value\nidc.print_insn_mnem() # print instruction\nidc.get_operand_type() # get operand type\nidautils.XrefsTo() # get cross references to address\n\n```\nLocating the cross references is as simple as returning a list of addresses gathered from the\nidautils.XrefsTo() function call, as seen below.\n```\ndef locateFunctionCrossReferences(functionAddress):\n     return [addr.frm for addr in idautils.XrefsTo(functionAddress)]\n\n```\nThen, we need to pass these addresses into a function for retrieving the string blob address,\nstring blob size, and key blob address. Again, this is fairly simple to do. We will get the\naddress before the cross reference, using idc.prev_head(), and use idc.get_operand_value()\nin order to retrieve the address of the string blob. Then, use idc.prev_head() to get the\naddress before, check if it corresponds to a push instruction, and if so grab the string blob\nsize, and the address of the key blob using idc.get_operand_value(). If it doesn’t, then we will\nlocate the hardcoded string offset, move the current address pointer back, and then extract\nthe string blob size and key blob address.\n\nWe now have the three arguments, we just need the string offset. The string offset retrieving\nfunction will accept an address (cross reference to the function wrappers), and iterate over\nthe addresses before the call, in order to find a mov instruction, where the operand type of\nthe second argument is of idc.o_imm. As almost all calls to the wrapper functions use a\nregister to hold the string offset, we will have very few errors with this function, and the errors\nwe do have we can “manually” decrypt.\n\n\n-----\n\nAt this point, we have now grabbed all of the four values that we need, so now to wrap it\ntogether in one function, and implement the string decryption function. I won’t be covering\nthe reversing of the string decryption function, as it is already widely documented.\n\nWith the relevant functions all wrapped into one, we need to add a final function that will add\n[comments to the IDB in the relevant locations. OALabs have a brilliant snippet here that we](https://www.youtube.com/channel/UC--DwaiMV-jtO-6EvmKOnqg)\nwill be using, passing in the cross reference to the function wrapper calls in order to add\n\n\n-----\n\ncomments at that specific address.\n\nNext, we need to add one more function responsible for reading bytes from the IDB. We will\npass the addresses of the string blob and key blob, along with the respective sizes, and have\nit return the read bytes back to our main function. This is simple to do, and we can use the\nidaapi.get_bytes() function to do just that.\n```\ndef readBytesFromFile(dataOffset, bytesToRead):\n     return idaapi.get_bytes(dataOffset, bytesToRead)\n\n```\nFrom here, all that needs to be done is to add a “main” function that will accept a nonhardcoded amount of offsets, in case we have more than 2 string decryption functions. That’s\nsimple to do as well, all we need is to use an asterisk!\n```\ndef stringAutomation(*coreFunctionList):\n     locateStringFunctions(coreFunctionList)\n\n```\nAnd we’re finished! All that we need to do now is import it into IDA, pass the offsets of the\ncore string decryption functions to the “main” function, and hit enter!\n\nIf all goes well, you should immediately notice strings have been added as comments next to\nmost of the calls to the function wrappers.\n\nIn order to create a “manual” decrypt function, we will set up a new function that accepts 3\narguments: the offset of the function wrapper in question, the address where the function\nwrapper is called, and the string offset. We then just pass this into the relevant functions to\ngrab the correct arguments, decrypt the string itself, and then add the comments!\n\n\n-----\n\nWith the automation of the string decryptor complete, it’s time to move onto resolving the API\ncalls!\n\n## Resolving Hashed API\n\nThe browser hooking module uses an interesting method of storing resolved APIs. Rather\nthan resolve all APIs when necessary like Dridex, or resolving at startup and assign each\nAPI to a variable, Qakbot uses structures in memory to hold API loaded from different\nlibraries, meaning there will be a kernel32 structure, a wininet structure, and so on. This can\ncause some issues as it is not as simple as renaming variables, or adding comments next to\neach call. Instead we will have to recreate these structures, and change the type of the\nvariable responsible for pointing to the structures.\n\nThe API structures are resolved on startup, and use 3 pieces of information; a pointer to the\nlist of hashed APIs, the size of the list in bytes, and a string offset corresponding to the target\nDLL. This string offset is passed into a string decryption function, which luckily we have\nalready implemented, so we are already 35% done.\n\n\n-----\n\nThe arguments we need are pushed to the stack immediately before calling the API resolving\nfunction, so extracting them will be fairly simple. All we need to search for are 2 integers and\nan offset in memory that are pushed to the stack. It will be structured very similarly to our\nstring decryption function, except we will use idc.is_off0() and idc.get_full_flags() to locate\nthe offset.\n\nNow we have the 3 arguments, there is one more offset we need to locate: the offset in\nmemory that will point to the API structure. The return value will be stored in EAX, and in\nevery instance it is moved into a variable. This variable is then referenced whenever an API\nis called, so we will set up the automation to change the type of the variable to a pointer to\nthe API structure, saving us some time.\n\n\n-----\n\nIn order to do this, we will loop through every address after the call to the API resolving\nfunction, and check for a mov instruction that has EAX as the second operand, and an offset\nin memory as the first operand. Once we have located a valid instruction, we can return all 4\nof the discovered values.\n\nWith the address of the hashed APIs list, and the size, we need to read the list from the IDB,\nand split it up into chunks of 4 bytes, before converting each chunk to a 32 bit integer using\nthe struct module. Each chunk will be XORed with a 32 bit integer, as can be seen in the\ncode below. In this case, that integer is 0x218FE95B.\n\nThen, we just need to figure out what DLL is being targeted, which we can find by passing\nthe string offset to a string decryption function. With the list of hashes in hand, and the target\nDLL, we can now start “brute forcing” the APIs.\n\n\n-----\n\nEssentially what we will do is open the target DLL using the pefile module, parse the exports\nfrom the export directory, and proceed to CRC32 hash each export using the zlib module, to\nlocate a match. Once a match has been discovered, we will return a string similar to the one\nbelow:\n```\nkernel32::CreateProcessW\n\n```\nWe will then pass this string into a local type we create in IDA, before assigning it to the\ncorrect variable. Before doing so, we need to create a local type first. Both of these\nprocesses can be done with the following functions:\n```\n// create struct and add struct members\nidc.add_struc()\nidc.add_struc_member()\n// assign to variable\nidc.set_name()\nidc.SetType()\n\n```\nPutting these calls into a few functions, we get the code that you can see below.\n\nAnd that’s pretty much all the important functions we need to write! All we need to do is set\nup a main function that accepts the xorValue we found in the API resolver, the address of\nthe string decryption function used inside the API resolver, and the address of the API\nresolving routine. We then pass this into a function that will find all cross references to the\nAPI resolving function, retrieve the required arguments for the string decryption function, and\n\n\n-----\n\nthen locate the arguments needed to resolve the API. This is then passed into the respective\nfunctions, and once the correct API has been found, we add it to a local type structure, and\nassign the filled structure to the correct variable.\n\nIf all goes smoothly, you should have something similar to below!\n\n\n-----\n\n## Internal Hooking Structures\n\n_As this post is already quite long, I won’t be going into much depth on the hooking structures,_\n_so we will only focus on the basics of it and how the IDA Python script works._\n\nWith the string decryption and API resolving functions automated, we can now move our\nfocus to the structures used by the module with regards to hooking. These structures contain\nfour pieces of information; two string offsets linked to the target DLL and the target API, a\npointer to the function that will be executed whenever the target API is called (replacement\nfunction), and a variable that will point to the trampoline setup during hooking.\n\n\n-----\n\nOutside of the structure, we need to locate two more values; the address of the list of\nstructures (obviously), and the number of structures in the list. In most calls to the function\nresponsible for parsing these structures and setting up the hooks, the value corresponding to\nthe amount of structures in the list is pushed onto the stack, before being popped off into\n**EAX. The list address is then moved into ECX, so extracting this information will be quite**\nsimple to do.\n\nAs we already have the string decryption function, all we need to do is extract the list of\nstructures, parse it into individual structures, decrypt the relevant strings, and then rename\nthe respective pointers. For example, if the hook structure is targeting PR_Read, we would\nrename the replacement function to replacePR_Read, and the trampoline pointer to\n**originalPR_Read, making it easier to pick out in a function.**\n\n\n-----\n\nWith the relevant functions setup, we just need to wrap it together, import into IDA, pass the\naddress of the hooking function, and run it!\n\nUnfortunately this does not work with the Google Chrome API, as we will discover in the next\npost, but this is basically due to Chrome not exposing it’s internal API in the export table of\nthe core DLLs. As a result, the browser hooking module will have to do some pretty inventive\n\n\n-----\n\nparsing of the internal Chrome libraries in order to locate the target APIs, but that is\nsomething we will explore in the next part!\n\nFor now though, that brings an end to this fairly long post. We’ve developed the 3 main\nscripts that will allow us to analyse the module a lot easier, and in the next post we will start\nexploring the parsing of the Chrome DLLs, and most likely analyse the replacement function\nfor the Chrome equivalent of HTTPSendRequest and PR_Write. That post is currently under\nworks, so you should expect it to come out very soon!\n\nAny questions? Feel free to drop a comment with your question, or you can drop me a DM\n[via Twitter (@0verfl0w_)!](https://twitter.com/0verfl0w_)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-24 - Quack Quack- Analysing Qakbot’s Browser Hooking Module – Part 1.pdf"
    ],
    "report_names": [
        "2021-07-24 - Quack Quack- Analysing Qakbot’s Browser Hooking Module – Part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "6c4e4b91-1f98-49e2-90e6-435cea8d3d53",
            "created_at": "2022-10-25T16:07:23.693797Z",
            "updated_at": "2025-03-27T02:02:09.924056Z",
            "deleted_at": null,
            "main_name": "Gorgon Group",
            "aliases": [
                "ATK 92",
                "Pasty Draco",
                "Subaat",
                "TAG-CR5"
            ],
            "source_name": "ETDA:Gorgon Group",
            "tools": [
                "AgenTesla",
                "Agent Tesla",
                "AgentTesla",
                "Atros2.CKPN",
                "Bladabindi",
                "CinaRAT",
                "Crimson RAT",
                "ForeIT",
                "Jorik",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "MSIL",
                "MSIL/Crimson",
                "Nancrat",
                "NanoCore",
                "NanoCore RAT",
                "Negasteal",
                "NetWeird",
                "NetWire",
                "NetWire RAT",
                "NetWire RC",
                "NetWired RC",
                "Origin Logger",
                "Quasar RAT",
                "QuasarRAT",
                "Recam",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Revenge RAT",
                "RevengeRAT",
                "Revetrat",
                "SEEDOOR",
                "Scarimson",
                "Socmer",
                "Yggdrasil",
                "ZPAQ",
                "Zurten",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "18278778-fa63-4a9a-8988-4d266b8c5c1a",
            "created_at": "2023-01-06T13:46:38.769816Z",
            "updated_at": "2025-03-27T02:00:02.914024Z",
            "deleted_at": null,
            "main_name": "The Gorgon Group",
            "aliases": [
                "ATK92",
                "G0078",
                "Pasty Gemini",
                "Gorgon Group",
                "Subaat"
            ],
            "source_name": "MISPGALAXY:The Gorgon Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "97fdaf9f-cae1-4ccc-abe2-76e5cbc0febd",
            "created_at": "2022-10-25T15:50:23.296989Z",
            "updated_at": "2025-03-27T02:00:55.432751Z",
            "deleted_at": null,
            "main_name": "Gorgon Group",
            "aliases": [
                "Gorgon Group"
            ],
            "source_name": "MITRE:Gorgon Group",
            "tools": [
                "NanoCore",
                "QuasarRAT",
                "Remcos",
                "njRAT"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536198,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653689029,
    "ts_modification_date": 1653689029,
    "files": {
        "pdf": "https://archive.orkl.eu/c45e633e1317b5c2240a59f4ec104d4899129ada.pdf",
        "text": "https://archive.orkl.eu/c45e633e1317b5c2240a59f4ec104d4899129ada.txt",
        "img": "https://archive.orkl.eu/c45e633e1317b5c2240a59f4ec104d4899129ada.jpg"
    }
}