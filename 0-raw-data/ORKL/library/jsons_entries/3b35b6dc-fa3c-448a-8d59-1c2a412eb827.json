{
    "id": "3b35b6dc-fa3c-448a-8d59-1c2a412eb827",
    "created_at": "2023-01-12T15:02:24.957099Z",
    "updated_at": "2025-03-27T02:16:28.854314Z",
    "deleted_at": null,
    "sha1_hash": "743d880b0a59a5081661c287bdc551606604e91c",
    "title": "2019-04-24 - Deobfuscating APT32 Flow Graphs with Cutter and Radare2",
    "authors": "",
    "file_creation_date": "2022-05-27T22:55:09Z",
    "file_modification_date": "2022-05-27T22:55:09Z",
    "file_size": 980643,
    "plain_text": "# Deobfuscating APT32 Flow Graphs with Cutter and Radare2\n\n**[research.checkpoint.com/deobfuscating-apt32-flow-graphs-with-cutter-and-radare2/](https://research.checkpoint.com/deobfuscating-apt32-flow-graphs-with-cutter-and-radare2/)**\n\nApril 24, 2019\n**Research by: Itay Cohen**\n\n\nApril 24, 2019\n\n\nThe Ocean Lotus group, also known as APT32, is a threat actor which has been known to\ntarget East Asian countries such as Vietnam, Laos and the Philippines. The group strongly\nfocuses on Vietnam, especially private sector companies that are investing in a wide variety\nof industrial sectors in the country. While private sector companies are the group’s main\ntargets, APT32 has also been known to target foreign governments, dissidents, activists, and\njournalists.\n\nAPT32’s toolset is wide and varied. It contains both advanced and simple components; it is a\nmixture of handcrafted tools and commercial or open-source ones, such as Mimikatz and\nCobalt Strike. It runs the gamut from droppers, shellcode snippets, through decoy documents\nand backdoors. Many of these tools are highly obfuscated and seasoned, augmented with\ndifferent techniques to make them harder to reverse-engineer.\n\n\n-----\n\nIn this article, we get up and close with one of these obfuscation techniques. This specific\ntechnique was used in a backdoor of Ocean Lotus’ tool collection. We’ll describe the\ntechnique and the difficulty it presents to analysts — and then show how bypassing this kind\nof technique is a matter of writing a simple script, as long as you know what you are doing.\n\n[The deobfuscation plugin requires Cutter, the official GUI of the open-source reverse](https://github.com/radareorg/cutter)\nengineering framework – radare2. Cutter is a cross-platform GUI that aims to expose\nradare2’s functionality as a user-friendly and modern interface. Last month, Cutter\nintroduced a new Python plugin system, which figures into the tool we’ll be constructing\nbelow. The plugin itself isn’t complicated, and neither is the solution we demonstrate below. If\nsimple works, then simple is best.\n\n**Downloading and installing Cutter**\n\nCutter is available for all platforms (Linux, OS X, Windows). You can download the latest\n[release here. If you are using Linux, the fastest way to get a working copy of Cutter is to use](https://github.com/radareorg/cutter/releases)\nthe AppImage file.\n\nIf you want to use the newest version available, with new features and bug fixes, you should\nbuild Cutter from source. If you are up for that detour, follow [this tutorial.](https://cutter.re/docs/building.html)\n\n**_Fig 1: Cutter interface_**\n\n**The Backdoor**\n\n\n-----\n\nFirst, let s have a look at the backdoor itself. The relevant sample\n( 486be6b1ec73d98fdd3999abe2fa04368933a2ec ) is part of a multi-stage infection chain,\nwhich we have lately seen employed in the wild. All these stages are quite typical for Ocean\nLotus, especially the chain origin being a malicious document\n( 115f3cb5bdfb2ffe5168ecb36b9aed54 ). The document purports to originate from Chinese\nsecurity vendor Qihoo 360, and contains a malicious VBA Macro code that injects a\nmalicious shellcode to `rundll32.exe. The shellcode contains decryption routines to`\ndecrypt and reflectively load a DLL file to the memory. The DLL contains the backdoor logic\nitself.\n\nFirst, the backdoor decrypts a configuration file which is pulled from the file resource. The\nconfiguration file stores information such as the Command and Control servers. The binary\nthen tries to load an auxiliary DLL to the memory using a custom-made PE loader. This DLL\nis called `HTTPProv.dll and is capable of communicating with the C2 servers. The`\nbackdoor can receive dozens of different commands from the Command and Control\nservers, including shellcode execution, creation of new processes, manipulation of files and\ndirectories, and more.\n\nMany obfuscation techniques are used by Ocean Lotus in order to make their tools harder to\nreverse engineer. Most noticeable, Ocean Lotus is using an enormous amount of junk code\nin their binaries. The junk code makes the samples much bigger and more complicated,\nwhich distracts researchers trying to pry into the binary. Trying to decompile some of these\nobfuscated functions is a lost cause; the assembly often plays around with the stack pointer,\nand decompilers are not well-equipped to handle this kind of pathological code.\n\n**The Obfuscation**\n\nUpon analysis of the backdoor, one obfuscation technique can be immediately noticed. It is\nthe heavy use of control flow obfuscation which is created by inserting junk blocks into the\nflow of the function. These junk blocks are just meaningless noise and make the flow of the\nfunction confusing.\n\n\n-----\n\n**_Fig 2: An example of a junk block_**\n\nAs you can see in the image above, the block is full of junk code which has nothing to do\nwith what the function actually does. It’s best to ignore these blocks, but that’s easier said\nthan done. A closer look at these blocks will reveal something interesting. These junk blocks\nare always being fail-jumped to by a conditional jump from a previous block. Furthermore,\nthese junk blocks will almost always end with a conditional jump which is the opposite of the\nconditional jump of the previous block. For example, if the condition above the junk block\n\n\n-----\n\nwas `jo <some_addr>, the junk block will most likely end with` `jno <some_addr> . If the`\nblock above ended with `jne <another_addr>, the junk block will then end with… you`\nguessed right – `je <another_addr> .`\n\n**_Fig 3: Opposite conditional jumps_**\n\n\n-----\n\nWith this in mind, we can begin structuring the characteristics of these junk blocks. The first\ncharacteristic of the obfuscation is the occurrence of two successive blocks which end\n**with opposite conditional jumps to the same target address. The other characteristic**\nrequires the second block to contain no meaningful instructions such as string\n**references or calls.**\n\nWhen these two characteristics are met, we can say with a high chance that the second\nblock is a junk block. In such a case, we would want the first block to jump over the junk\nblock so the junk block would be removed from the graph. This can be done by patching the\nconditional jump with an unconditional jump, aka a simple `JMP instruction.`\n\n**_Fig 4: Modifying the conditional jump to a JMP instruction will ignore the junk block_**\n\n**Writing the Plugin**\n\nSo here is a heads up for you – the plugin we present below is written for Cutter, but was\ndesigned to be compatible with radare2 scripts, for those of you who are CLI gurus. That\n[means that we are going to use some nifty radare2 commands through r2pipe – a Python](https://github.com/radare/radare2-r2pipe/tree/master/python)\nwrapper to interact with radare2. This is the most effective and flexible way for scripting\nradare2.\n\n\n-----\n\nIt s not trivial to get the plugin to support both Cutter and radare2, since one is a GUI\nprogram and the other is a CLI. That means that GUI objects would be meaningless inside\nradare2. Luckily, Cutter supports r2pipe and is able to execute radare2 commands from\ninside its Python plugins.\n\n**Writing the Core Class**\n\nThe first thing we are going to do is to create a Python class which will be our core class.\nThis class will contain our logic for finding and removing the junk blocks. Let’s start by\ndefining its `__init__ function. The function will receive a pipe, which will be either an`\n```\nr2pipe (available from import r2pipe ) object from radare2 or a cutter (available\n\n```\nfrom `import cutter ) object from Cutter.`\n```\nclass GraphDeobfuscator:\n  def __init__(self, pipe):\n    \"\"\"an initialization function for the class\n    Arguments:\n      pipe {r2pipe} -- an instance of r2pipe or Cutter's wrapper\n    \"\"\"\n    self.pipe = pipe\n\n```\nNow we can execute radare2 commands using this pipe. The pipe object contains two major\nways to execute r2 commands. The first is `pipe.cmd(<command>) which will return the`\nresults of the command as a string, and the second is `pipe.cmdj(<command>j) which will`\nreturn a parsed JSON object from the output of radare2’s command.\n\n**Note: Almost every command of radare2 can be appended with a** `j to get the output`\n_as JSON._\n\nThe next thing we would want to do is to get all the blocks of the current function and then\niterate over each one of them. We can do this by using the `afbj command which stands`\nfor Analyze Function Blocks and will return a Json object with all the blocks of the function.\n```\n  def clean_junk_blocks(self):\n    \"\"\"Search a given function for junk blocks, remove them and fix the flow.\n    \"\"\"\n    # Get all the basic blocks of the function\n    blocks = self.pipe.cmdj(\"afbj @ $F\")\n    if not blocks:\n      print(\"[X] No blocks found. Is it a function?\")\n      return\n    modified = False\n    # Iterate over all the basic blocks of the function\n    for block in blocks:\n      # do something\n\n```\n\n-----\n\nFor each block, we want to know if there is a block which fails-to in a case where the\nconditional jump would not take place. If a block has a block to which it fails, the second\nblock is an initial candidate to be a junk block.\n```\n  def get_fail_block(self, block):\n    \"\"\"Return the block to which a block branches if the condition is fails\n    Arguments:\n      block {block_context} -- A JSON representation of a block\n    Returns:\n      block_context -- The block to which the branch fails. If not exists,\nreturns None\n    \"\"\"\n    # Get the address of the \"fail\" branch\n    fail_addr = self.get_fail(block)\n    if not fail_addr:\n      return None\n    # Get a block context of the fail address\n    fail_block = self.get_block(fail_addr)\n    return fail_block if fail_block else None\n\n```\n**Note: Since our space is limited, we won’t explain every function that appears here.**\n_Functions as_ `get_block (addr) or` `get_fail_addr (block) that are used in the`\n_snippet above are subroutines we wrote to make the code cleaner. The function_\n_implementations will be available in the final plugin that is shown and linked at the end_\n_of the article. Hopefully, you’ll find the function names self-explanatory._\n\nNext, we would like to check whether our junk block candidate comes immediately after the\nblock. If no, this is most likely not a junk block since from what we inspected, junk blocks are\nlocated in the code immediately after the blocks with the conditional jump.\n```\n  def is_successive_fail(self, block_A, block_B):\n    \"\"\"Check if the end address of block_A is the start of block_B\n    Arguments:\n      block_A {block_context} -- A JSON object to represent the first block\n      block_B {block_context} -- A JSON object to represent the second block\n    Returns:\n      bool -- True if block_B comes immediately after block_A, False otherwise\n    \"\"\"\n   return ((block_A[\"addr\"] + block_A[\"size\"]) == block_B[\"addr\"])\n\n```\nThen, we would want to check whether the block candidate contains no meaningful\ninstructions. For example, it is unlikely that a junk block will contain `CALL instructions or`\nreferences for strings. To do this, we will use the command `pdsb which stands for Print`\n\n\n-----\n\n**Disassembly Summary of a Block. This radare2 command prints the interesting instructions**\nthat appear in a certain block. We assume that a junk block would not contain interesting\ninstructions.\n```\n  def contains_meaningful_instructions (self, block):\n    '''Check if a block contains meaningful instructions (references, calls,\nstrings,...)\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      bool -- True if the block contains meaningful instructions, False\notherwise\n    '''\n    # Get summary of block - strings, calls, references\n    summary = self.pipe.cmd(\"pdsb @ {addr}\".format(addr=block[\"addr\"]))\n    return summary != \"\"\n\n```\nLast, we would like to check whether the conditional jumps of both blocks are opposite. This\nwill be the last piece of the puzzle to determine whether we are dealing with a junk block. For\nthis, we would need to create a list of opposite conditional jumps. The list we’ll show is partial\nsince the x86 architecture contains many conditional jump instructions. That said, from our\ntests, it seems like the below list is enough to cover all the different pairs of opposite\nconditional jumps that are presented in APT32’s backdoor. If it doesn’t, adding additional\ninstructions is easy.\n\n\n-----\n\n```\n  jmp_pairs [\n    ['jno', 'jo'],\n    ['jnp', 'jp'],\n    ['jb', 'jnb'],\n    ['jl', 'jnl'],\n    ['je', 'jne'],\n    ['jns', 'js'],\n    ['jnz', 'jz'],\n    ['jc', 'jnc'],\n    ['ja', 'jbe'],\n    ['jae', 'jb'],\n    ['je', 'jnz'],\n    ['jg', 'jle'],\n    ['jge', 'jl'],\n    ['jpe', 'jpo'],\n    ['jne', 'jz']]\n  def is_opposite_conditional(self, cond_A, cond_B):\n    \"\"\"Check if two operands are opposite conditional jump operands\n    Arguments:\n      cond_A {string} -- the conditional jump operand of the first block\n      cond_B {string} -- the conditional jump operand of the second block\n    Returns:\n      bool -- True if the operands are opposite, False otherwise\n    \"\"\"\n    sorted_pair = sorted([cond_A, cond_B])\n    for pair in self.jmp_pairs:\n      if sorted_pair == pair:\n        return True\n    return False\n\n```\nNow that we defined the validation functions, we can glue these parts together inside the\n```\nclean_junk_blocks() function we created earlier.\n\n```\n\n-----\n\n```\n  def clean_junk_blocks(self):\n    \"\"\"Search a given function for junk blocks, remove them and fix the flow.\n    \"\"\"\n    # Get all the basic blocks of the function\n    blocks = self.pipe.cmdj(\"afbj @ $F\")\n    if not blocks:\n      print(\"[X] No blocks found. Is it a function?\")\n      return\n    modified = False\n    # Iterate over all the basic blocks of the function\n    for block in blocks:\n      fail_block = self.get_fail_block(block)\n      if not fail_block or \\\n      not self.is_successive_fail(block, fail_block) or \\\n      self.contains_meaningful_instructions(fail_block) or \\\n      not self.is_opposite_conditional(self.get_last_mnem_of_block(block),\nself.get_last_mnem_of_block(fail_block)):\n        continue\n\n```\nIn case that all the checks are successfully passed, and we can say with a high chance that\nwe found a junk block, we would want to patch the first conditional jump to `JMP over the`\njunk block, hence removing the junk block from the graph and thus, from the function itself.\n\nTo do this, we use two radare2 commands. The first is `aoj @ <addr> which stands for`\n**Analyze Opcode and will give us information on the instruction in a given address. This**\ncommand can be used to get the target address of the conditional jump. The second\ncommand we use is `wai <instruction> @ <addr> which stands for Write Assembly`\n**Inside. Unlike the** `wa <instruction> @ <addr> command to overwrite an instruction with`\nanother instruction, the `wai command will fill the remaining bytes with` `NOP instructions.`\nThus, in a case where the `JMP <addr> instruction we want to use is shorter than the`\ncurrent conditional-jump instruction, the remaining bytes will be replaced with `NOP s.`\n```\n  def overwrite_instruction(self, addr):\n    \"\"\"Overwrite a conditional jump to an address, with a JMP to it\n    Arguments:\n      addr {addr} -- address of an instruction to be overwritten\n    \"\"\"\n    jump_destination = self.get_jump(self.pipe.cmdj(\"aoj @\n{addr}\".format(addr=addr))[0])\n    if (jump_destination):\n      self.pipe.cmd(\"wai jmp 0x{dest:x} @ {addr}\".format(dest=jump_destination,\naddr=addr))\n\n```\nAfter overwriting the conditional-jump instruction, we continue to loop over all the blocks of\nthe function and repeat the steps described above. Last, if changes were made in the\nfunction, we re-analyze the function so that the changes we made appear in the function\ngraph.\n\n\n-----\n\n```\n  def reanalize_function(self):\n    \"\"\"Re-Analyze a function at a given address\n    Arguments:\n      addr {addr} -- an address of a function to be re-analyze\n    \"\"\"\n    # Seek to the function's start\n    self.pipe.cmd(\"s $F\")\n    # Undefine the function in this address\n    self.pipe.cmd(\"af- $\")\n    # Define and analyze a function in this address\n    self.pipe.cmd(\"afr @ $\")\n\n```\nAt last, the `clean_junk_blocks() function is now ready to be used. We can now also`\ncreate a function, `clean_graph(), that cleans the obfuscated function of the backdoor.`\n```\n  def clean_junk_blocks(self):\n    \"\"\"Search a given function for junk blocks, remove them and fix the flow.\n    \"\"\"\n    # Get all the basic blocks of the function\n    blocks = self.pipe.cmdj(\"afbj @ $F\")\n    if not blocks:\n      print(\"[X] No blocks found. Is it a function?\")\n      return\n    # Have we modified any instruction in the function?\n    # If so, a reanalyze of the function is required\n    modified = False\n    # Iterate over all the basic blocks of the function\n    for block in blocks:\n      fail_block = self.get_fail_block(block)\n      # Make validation checks\n      if not fail_block or \\\n      not self.is_successive_fail(block, fail_block) or \\\n      self.contains_meaningful_instructions(fail_block) or \\\n      not self.is_opposite_conditional(self.get_last_mnem_of_block(block),\nself.get_last_mnem_of_block(fail_block)):\n        continue\n      self.overwrite_instruction(self.get_block_end(block))\n      modified = True\n    if modified:\n      self.reanalize_function()\n  def clean_graph(self):\n    \"\"\"the initial function of the class. Responsible to enable cache and start\nthe cleaning\n    \"\"\"\n    # Enable cache writing mode. changes will only take place in the session and\n    # will not override the binary\n    self.pipe.cmd(\"e io.cache=true\")\n    self clean junk blocks()\n\n```\n\n-----\n\nThis concludes the core class.\n\n**Cutter or Radare2?**\n\nAs mentioned earlier, our code will be executed either as a plugin for Cutter, or straight from\nthe radare2 CLI as a Python script. That means that we need to have a way to understand\nwhether our code is being executed from Cutter or from radare2. For this, we can use the\nfollowing simple trick.\n```\n# Check if we're running from cutter\ntry:\n  import cutter\n  from PySide2.QtWidgets import QAction\n  pipe = cutter\n  cutter_available = True\n# If no, assume running from radare2\nexcept:\n  import r2pipe\n  pipe = r2pipe.open()\n  cutter_available = False\n\n```\nThe code above checks whether the `cutter library can be imported. If it can, we are`\nrunning from inside Cutter and can feel safe to do some GUI magic. Otherwise, we’re\nrunning from inside radare2, and so we opt to import `r2pipe . In both statements, we are`\nassigning a variable named `pipe which will be later passed to the` `GraphDeobfuscator`\nclass we created.\n\n**Running from Radare2**\n\nThis is the simplest way to use this plugin. Checking if `__name__ equals “__main__” is a`\ncommon Python idiom that checks if the script was run directly or imported. If this script was\nrun directly, we simply execute the `clean_graph() function.`\n```\nif __name__ == \"__main__\":\n  graph_deobfuscator = GraphDeobfuscator(pipe)\n  graph_deobfuscator.clean_graph()\n\n```\n**Running from Cutter**\n\n[Cutter’s documentation describes how to go about building and executing a Plugin for Cutter,](https://cutter.re/docs/plugins)\nand we follow its lead. First, we need to make sure that we are running from inside Cutter.\nWe already created a boolean variable named `cutter_variable . We simply need to`\ncheck whether this variable is set to `True . If it does, we proceed to define our plugin class.`\n\n\n-----\n\n```\nif cutter_available:\n  # This part will be executed only if Cutter is available.\n  # This will create the cutter plugin and UI objects for the plugin\n  class GraphDeobfuscatorCutter(cutter.CutterPlugin):\n    name = \"APT32 Graph Deobfuscator\"\n    description = \"Graph Deobfuscator for APT32 Samples\"\n    version = \"1.0\"\n    author = \"Itay Cohen (@Megabeets_)\"\n    def setupPlugin(self):\n      pass\n    def setupInterface(self, main):\n      pass\n  def create_cutter_plugin():\n    return GraphDeobfuscatorCutter()\n\n```\nThis is a skeleton of a Cutter plugin — it contains no proper functionality at all. The function\n```\ncreate_cutter_plugin() is called by Cutter upon loading. At this point, if we will place\n\n```\nour script in Cutter’s plugins directory, Cutter will recognize our file as a plugin.\n\nTo make the plugin execute our functionality, we need to add a menu entry that the user can\npress to trigger our deobfuscator. We chose to add a menu entry, or an Action, to the\n“Windows -> Plugins” menu.\n\n\n-----\n\n```\nif cutter_available:\n  # This part will be executed only if Cutter is available. This will\n  # create the cutter plugin and UI objects for the plugin\n  class GraphDeobfuscatorCutter(cutter.CutterPlugin):\n    name = \"APT32 Graph Deobfuscator\"\n    description = \"Graph Deobfuscator for APT32 Samples\"\n    version = \"1.0\"\n    author = \"Megabeets\"\n    def setupPlugin(self):\n      pass\n    def setupInterface(self, main):\n      # Create a new action (menu item)\n      action = QAction(\"APT32 Graph Deobfuscator\", main)\n      action.setCheckable(False)\n      # Connect the action to a function - cleaner.\n      # A click on this action will trigger the function\n      action.triggered.connect(self.cleaner)\n      # Add the action to the \"Windows -> Plugins\" menu\n      pluginsMenu = main.getMenuByType(main.MenuType.Plugins)\n      pluginsMenu.addAction(action)\n    def cleaner(self):\n      graph_deobfuscator = GraphDeobfuscator(pipe)\n      graph_deobfuscator.clean_graph()\n      cutter.refresh()\n  def create_cutter_plugin():\n    return GraphDeobfuscatorCutter()\n\n```\nThe script is now ready, and can be placed in the Python folder, under Cutter’s plugins\ndirectory. The path to the directory is shown in the Plugins Options, under “Edit ->\n**_Preferences -> Plugins“. For example, on our machine the path is:_**\n“~/.local/share/RadareOrg/Cutter/Plugins/Python“.\n\nNow, when opening Cutter, we can see in “Plugins -> Preferences” that the plugin was\nindeed loaded.\n\n**_Fig 5: The plugin was successfully loaded_**\n\n\n-----\n\nWe can also check the **_Windows -> Plugins menu to see if the menu item we created is_**\nthere. And indeed, we can see that the “APT32 Graph Deobfuscator” item now appears in\nthe menu.\n\n**_Fig 6: The menu item we created was successfully added_**\n\nWe can now choose some function which we suspect for having these junk blocks, and try to\ntest our Plugin. In this example, We chose the function `fcn.00acc7e0 . Going to a function`\nin Cutter can be done either by selecting it from the left menu, or simply pressing “g” and\ntyping its name or address in the navigation bar.\n\nMake sure you are in the graph view. Feel free to wander around and try to spot the junk\nblocks. We highlighted them in the image below which shows the Graph Overview (minigraph) window.\n\n\n-----\n\n**_Fig 7: Junk block highlighted in_** `fcn.00acc7e0`\n\nSince we have a candidate suspicious function, we can trigger our plugin and see if it\nsuccessfully removes them. To do this, click on “Windows -> Plugins -> APT32 Graph\n**_Deobfuscator“. After a second, we can see that our plugin successfully removed the junk_**\nblocks.\n\n\n-----\n\n**_Fig 8: The same function after removing the junk blocks_**\n\nIn the following images, you can see more pairs of function graphs before and after the\nremoval of junk blocks.\n\n\n-----\n\n**_Fig 9: Before and After of_** `fcn.00aa07b0`\n\n\n-----\n\n**_Fig 10: Before and After of_** `fcn.00a8a1a0`\n\n**Final Words**\n\nOcean Lotus’ obfuscation techniques are in no way the most complicated or hard to beat. In\nthis article we went through understanding the problem, drafting a solution and finally\nimplementing it using the python scripting capabilities of Cutter and Radare2. The full script\n[can be found in our Github repository, and also attached to the bottom of this article.](https://github.com/CheckPointSW/Cyber-Research/blob/master/Malware/APT32/APT32GraphDeobfuscator.py)\n\n\n-----\n\nIf you are interested in reading more about Ocean Lotus, we recommend this high-quality\n[article published by ESET’s Romain Dumont. It contains a thorough analysis of Ocean Lotus’](https://www.welivesecurity.com/wp-content/uploads/2018/03/ESET_OceanLotus.pdf)\ntools, as well as some exposition of the obfuscation techniques involved.\n\n**Appendix**\n\n**Sample SHA-256 values**\n\nBe6d5973452248cb18949711645990b6a56e7442dc30cc48a607a2afe7d8ec66\n8d74d544396b57e6faa4f8fdf96a1a5e30b196d56c15f7cf05767a406708a6b2\n\n**APT32 Graph Deobfuscator – Full Code**\n\n\n-----\n\n```\n  A plugin for Cutter and Radare2 to deobfuscate APT32 flow graphs\nThis is a python plugin for Cutter that is compatible as an r2pipe script for\nradare2 as well. The plugin will help reverse engineers to deobfuscate and remove\njunk blocks from APT32 (Ocean Lotus) samples.\n\"\"\"\n__author__ = \"Itay Cohen, aka @megabeets_\"\n__company__ = \"Check Point Software Technologies Ltd\"\n# Check if we're running from cutter\ntry:\n  import cutter\n  from PySide2.QtWidgets import QAction\n  pipe = cutter\n  cutter_available = True\n# If no, assume running from radare2\nexcept:\n  import r2pipe\n  pipe = r2pipe.open()\n  cutter_available = False\nclass GraphDeobfuscator:\n  # A list of pairs of opposite conditional jumps\n  jmp_pairs = [\n    ['jno', 'jo'],\n    ['jnp', 'jp'],\n    ['jb', 'jnb'],\n    ['jl', 'jnl'],\n    ['je', 'jne'],\n    ['jns', 'js'],\n    ['jnz', 'jz'],\n    ['jc', 'jnc'],\n    ['ja', 'jbe'],\n    ['jae', 'jb'],\n    ['je', 'jnz'],\n    ['jg', 'jle'],\n    ['jge', 'jl'],\n    ['jpe', 'jpo'],\n    ['jne', 'jz']]\n  def __init__(self, pipe, verbose=False):\n    \"\"\"an initialization function for the class\n    Arguments:\n      pipe {r2pipe} -- an instance of r2pipe or Cutter's wrapper\n    Keyword Arguments:\n      verbose {bool} -- if True will print logs to the screen (default:\n{False})\n    \"\"\"\n    self.pipe = pipe\n    self.verbose = verbose\n\n```\n\n-----\n\n```\n  def is_successive_fail(self, block_A, block_B):\n    \"\"\"Check if the end address of block_A is the start of block_B\n    Arguments:\n      block_A {block_context} -- A JSON object to represent the first block\n      block_B {block_context} -- A JSON object to represent the second block\n    Returns:\n      bool -- True if block_B comes immediately after block_A, False otherwise\n    \"\"\"\n    return ((block_A[\"addr\"] + block_A[\"size\"]) == block_B[\"addr\"])\n  def is_opposite_conditional(self, cond_A, cond_B):\n    \"\"\"Check if two operands are opposite conditional jump operands\n    Arguments:\n      cond_A {string} -- the conditional jump operand of the first block\n      cond_B {string} -- the conditional jump operand of the second block\n    Returns:\n      bool -- True if the operands are opposite, False otherwise\n    \"\"\"\n    sorted_pair = sorted([cond_A, cond_B])\n    for pair in self.jmp_pairs:\n      if sorted_pair == pair:\n        return True\n    return False\n  def contains_meaningful_instructions (self, block):\n    '''Check if a block contains meaningful instructions (references, calls,\nstrings,...)\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      bool -- True if the block contains meaningful instructions, False\notherwise\n    '''\n    # Get summary of block - strings, calls, references\n    summary = self.pipe.cmd(\"pdsb @ {addr}\".format(addr=block[\"addr\"]))\n    return summary != \"\"\n  def get_block_end(self, block):\n    \"\"\"Get the address of the last instruction in a given block\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      The address of the last instruction in the block\n\n```\n\n-----\n\n```\n    # save current seek\n    self.pipe.cmd(\"s {addr}\".format(addr=block['addr']))\n    # This will return the address of a block's last instruction\n    block_end = self.pipe.cmd(\"?v $ @B:-1\")\n    return block_end\n  def get_last_mnem_of_block(self, block):\n    \"\"\"Get the mnemonic of the last instruction in a block\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      string -- the mnemonic of the last instruction in the given block\n    \"\"\"\n    inst_info = self.pipe.cmdj(\"aoj @\n{addr}\".format(addr=self.get_block_end(block)))[0]\n    return inst_info[\"mnemonic\"]\n  def get_jump(self, block):\n    \"\"\"Get the address to which a block jumps\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      addr -- the address to which the block jumps to. If such address doesn't\nexist, returns False \n    \"\"\"\n    return block[\"jump\"] if \"jump\" in block else None\n  def get_fail_addr(self, block):\n    \"\"\"Get the address to which a block fails\n    Arguments:\n      block {block_context} -- A JSON object which represents a block\n    Returns:\n      addr -- the address to which the block fail-branches to. If such address\ndoesn't exist, returns False \n    \"\"\"\n    return block[\"fail\"] if \"fail\" in block else None\n  def get_block(self, addr):\n    \"\"\"Get the block context in a given address\n    Arguments:\n      addr {addr} -- An address in a block\n    Returns:\n      block_context -- the block to which the address belongs\n\n```\n\n-----\n\n```\n    block = self.pipe.cmdj(\"abj. @ {offset}\".format(offset=addr))\n    return block[0] if block else None\n  def get_fail_block(self, block):\n    \"\"\"Return the block to which a block branches if the condition is fails\n    Arguments:\n      block {block_context} -- A JSON representation of a block\n    Returns:\n      block_context -- The block to which the branch fails. If not exists,\nreturns None\n    \"\"\"\n    # Get the address of the \"fail\" branch\n    fail_addr = self.get_fail_addr(block)\n    if not fail_addr:\n      return None\n    # Get a block context of the fail address\n    fail_block = self.get_block(fail_addr)\n    return fail_block if fail_block else None\n  def reanalize_function(self):\n    \"\"\"Re-Analyze a function at a given address\n    Arguments:\n      addr {addr} -- an address of a function to be re-analyze\n    \"\"\"\n    # Seek to the function's start\n    self.pipe.cmd(\"s $F\")\n    # Undefine the function in this address\n    self.pipe.cmd(\"af- $\")\n    # Define and analyze a function in this address\n    self.pipe.cmd(\"afr @ $\")    \n  def overwrite_instruction(self, addr):\n    \"\"\"Overwrite a conditional jump to an address, with a JMP to it\n    Arguments:\n      addr {addr} -- address of an instruction to be overwritten\n    \"\"\"\n    jump_destination = self.get_jump(self.pipe.cmdj(\"aoj @\n{addr}\".format(addr=addr))[0])\n    if (jump_destination):\n      self.pipe.cmd(\"wai jmp 0x{dest:x} @ {addr}\".format(dest=jump_destination,\naddr=addr))\n  def get_current_function(self):\n    \"\"\"Return the start address of the current function\n    Return Value:\n      The address of the current function. None if no function found.\n\n```\n\n-----\n\n```\n    function_start = int(self.pipe.cmd(\"?vi $FB\"))\n    return function_start if function_start != 0 else None\n  def clean_junk_blocks(self):\n    \"\"\"Search a given function for junk blocks, remove them and fix the flow.\n    \"\"\"\n    # Get all the basic blocks of the function\n    blocks = self.pipe.cmdj(\"afbj @ $F\")\n    if not blocks:\n      print(\"[X] No blocks found. Is it a function?\")\n      return\n    # Have we modified any instruction in the function?\n    # If so, a reanalyze of the function is required\n    modified = False\n    # Iterate over all the basic blocks of the function\n    for block in blocks:\n      fail_block = self.get_fail_block(block)\n      # Make validation checks\n      if not fail_block or \\\n      not self.is_successive_fail(block, fail_block) or \\\n      self.contains_meaningful_instructions(fail_block) or \\\n      not self.is_opposite_conditional(self.get_last_mnem_of_block(block),\nself.get_last_mnem_of_block(fail_block)):\n        continue\n      if self.verbose:\n        print (\"Potential junk: 0x{junk_block:x}\n(0x{fix_block:x})\".format(junk_block=fail_block[\"addr\"], fix_block=block[\"addr\"]))\n      self.overwrite_instruction(self.get_block_end(block))\n      modified = True\n    if modified:\n      self.reanalize_function()\n  def clean_graph(self):\n    \"\"\"the initial function of the class. Responsible to enable cache and start\nthe cleaning\n    \"\"\"\n    # Enable cache writing mode. changes will only take place in the session and\n    # will not override the binary\n    self.pipe.cmd(\"e io.cache=true\")\n    self.clean_junk_blocks()\nif cutter_available:\n  # This part will be executed only if Cutter is available. This will\n  # create the cutter plugin and UI objects for the plugin\n  class GraphDeobfuscatorCutter(cutter.CutterPlugin):\n    name = \"APT32 Graph Deobfuscator\"\n    description = \"Graph Deobfuscator for APT32 Samples\"\n    version = \"1.0\"\n    author = \"Itay Cohen (@Megabeets_)\"\n\n```\n\n-----\n\n```\n    def setupPlugin(self):\n      pass\n    def setupInterface(self, main):\n      # Create a new action (menu item)\n      action = QAction(\"APT32 Graph Deobfuscator\", main)\n      action.setCheckable(False)\n      # Connect the action to a function - cleaner.\n      # A click on this action will trigger the function\n      action.triggered.connect(self.cleaner)\n      # Add the action to the \"Windows -> Plugins\" menu\n      pluginsMenu = main.getMenuByType(main.MenuType.Plugins)\n      pluginsMenu.addAction(action)\n    def cleaner(self):\n      graph_deobfuscator = GraphDeobfuscator(pipe)\n      graph_deobfuscator.clean_graph()\n      cutter.refresh()\n  def create_cutter_plugin():\n    return GraphDeobfuscatorCutter()\nif __name__ == \"__main__\":\n  graph_deobfuscator = GraphDeobfuscator(pipe)\n  graph_deobfuscator.clean_graph()\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-04-24 - Deobfuscating APT32 Flow Graphs with Cutter and Radare2.pdf"
    ],
    "report_names": [
        "2019-04-24 - Deobfuscating APT32 Flow Graphs with Cutter and Radare2.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "870f6f62-84f5-48ca-a18e-cf2902cd6924",
            "created_at": "2022-10-25T15:50:23.303818Z",
            "updated_at": "2025-03-27T02:00:55.435309Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "APT32",
                "SeaLotus",
                "OceanLotus",
                "APT-C-00",
                "Canvas Cyclone"
            ],
            "source_name": "MITRE:APT32",
            "tools": [
                "Mimikatz",
                "ipconfig",
                "Kerrdown",
                "Cobalt Strike",
                "SOUNDBITE",
                "OSX_OCEANLOTUS.D",
                "KOMPROGO",
                "netsh",
                "RotaJakiro",
                "PHOREAL",
                "Arp",
                "Denis",
                "Goopy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "af509bbb-8d18-4903-a9bd-9e94099c6b30",
            "created_at": "2023-01-06T13:46:38.585525Z",
            "updated_at": "2025-03-27T02:00:02.866727Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "TIN WOODLAWN",
                "OceanLotus Group",
                "OceanLotus",
                "Sea Lotus",
                "G0050",
                "Cobalt Kitty",
                "SeaLotus",
                "ATK17",
                "Ocean Lotus",
                "Ocean Buffalo",
                "POND LOACH",
                "Canvas Cyclone",
                "APT-C-00",
                "APT-32",
                "APT 32"
            ],
            "source_name": "MISPGALAXY:APT32",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f1518ac1-4710-4dd1-a422-e3801e4806cb",
            "created_at": "2024-05-01T02:03:08.147856Z",
            "updated_at": "2025-03-27T02:05:17.421275Z",
            "deleted_at": null,
            "main_name": "TIN WOODLAWN",
            "aliases": [
                "Cobalt Kitty",
                "OceanLotus",
                "WOODLAWN ",
                "APT32 "
            ],
            "source_name": "Secureworks:TIN WOODLAWN",
            "tools": [
                " Denis",
                " Goopy",
                " JEShell",
                " KerrDown",
                " Mimikatz",
                " Ratsnif",
                " Remy",
                " Rizzo",
                " RolandRAT",
                "Cobalt Strike"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2439ad53-39cc-4fff-8fdf-4028d65803c0",
            "created_at": "2022-10-25T16:07:23.353204Z",
            "updated_at": "2025-03-27T02:02:09.749502Z",
            "deleted_at": null,
            "main_name": "APT 32",
            "aliases": [
                "APT 32",
                "APT-C-00",
                "APT-LY-100",
                "ATK 17",
                "Lotus Bane",
                "Ocean Buffalo",
                "OceanLotus",
                "Operation Cobalt Kitty",
                "Operation PhantomLance",
                "Pond Loach",
                "SeaLotus",
                "SectorF01",
                "Tin Woodlawn"
            ],
            "source_name": "ETDA:APT 32",
            "tools": [
                "Agentemis",
                "Android.Backdoor.736.origin",
                "AtNow",
                "Backdoor.MacOS.OCEANLOTUS.F",
                "BadCake",
                "CACTUSTORCH",
                "CamCapture Plugin",
                "CinaRAT",
                "Cobalt Strike",
                "CobaltStrike",
                "Cuegoe",
                "DKMC",
                "Denis",
                "Goopy",
                "HiddenLotus",
                "KOMPROGO",
                "KerrDown",
                "METALJACK",
                "MSFvenom",
                "Mimikatz",
                "Nishang",
                "OSX_OCEANLOTUS.D",
                "OceanLotus",
                "PHOREAL",
                "PWNDROID1",
                "PhantomLance",
                "PowerSploit",
                "Quasar RAT",
                "QuasarRAT",
                "RatSnif",
                "Remy",
                "Remy RAT",
                "Rizzo",
                "Roland",
                "Roland RAT",
                "SOUNDBITE",
                "Salgorea",
                "Splinter RAT",
                "Terracotta VPN",
                "Yggdrasil",
                "cobeacon",
                "denesRAT",
                "fingerprintjs2"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535744,
    "ts_updated_at": 1743041788,
    "ts_creation_date": 1653692109,
    "ts_modification_date": 1653692109,
    "files": {
        "pdf": "https://archive.orkl.eu/743d880b0a59a5081661c287bdc551606604e91c.pdf",
        "text": "https://archive.orkl.eu/743d880b0a59a5081661c287bdc551606604e91c.txt",
        "img": "https://archive.orkl.eu/743d880b0a59a5081661c287bdc551606604e91c.jpg"
    }
}