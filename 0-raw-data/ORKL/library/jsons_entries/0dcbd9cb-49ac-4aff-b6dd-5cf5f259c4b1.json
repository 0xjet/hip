{
    "id": "0dcbd9cb-49ac-4aff-b6dd-5cf5f259c4b1",
    "created_at": "2023-01-12T15:00:29.647566Z",
    "updated_at": "2025-03-27T02:16:17.091484Z",
    "deleted_at": null,
    "sha1_hash": "028d70adc029235a70185cb28ab2d46e1e41ce9c",
    "title": "2021-12-13 - Now You Serial, Now You Don’t — Systematically Hunting for Deserialization Exploits",
    "authors": "",
    "file_creation_date": "2022-05-26T02:49:26Z",
    "file_modification_date": "2022-05-26T02:49:26Z",
    "file_size": 4124302,
    "plain_text": "# Now You Serial, Now You Don’t — Systematically Hunting for Deserialization Exploits\n\n**mandiant.com/resources/hunting-deserialization-exploits**\n\nBlog\n\nAlyssa Rahman\n\nDec 13, 2021\n\n17 mins read\n\nVulnerabilities\n\nThreat Research\n\nDeserialization vulnerabilities are a class of bugs that have plagued multiple languages and applications over the years. These include\n[Exchange (CVE-2021-42321), Zoho ManageEngine (CVE-2020-10189), Jira (CVE-2020-36239), Telerik (CVE-2019-18935), Jenkins](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42321)\n[(CVE-2016-9299), and](https://nvd.nist.gov/vuln/detail/CVE-2016-9299) [more. Fundamentally, these bugs are a result of applications placing too much trust in data that a user (or](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)\nattacker) can tamper with.\n\nAttackers have leveraged these vulnerabilities for years to upload files, access unauthorized resources, and execute malicious code on\n[targeted servers. Within the past 2 years, Mandiant has particularly observed APT41 using .NET ViewState and Java deserialization](https://www.mandiant.com/resources/apt41-initiates-global-intrusion-campaign-using-multiple-exploits)\nexploits to target companies and government entities within North America.\n\nGiven the prevalence and impact of these vulnerabilities, our goal was to create a process to systematically hunt for exploitation attempts.\n[In this blog post, we will share our new rule generation (HeySerial.py) and validation (CheckYoself.py) tools and walk through the](https://github.com/mandiant/heyserial/blob/main/heyserial.py)\nresearch process we used to create them.\n\nWhile this blog post mainly focuses on deserialization exploits, the tools and processes presented here can help with hunting for the\nexploitation of other types of zero-days. For example, we can use HeySerial to generate hunting rules for the JNDI code injection zero[day released last week for log4j (CVE-2021-44228). For more details, check the “A Note on CVE-2021-44228” section later in the post.](https://www.lunasec.io/docs/blog/log4j-zero-day/)\n\n## Understanding the Problem\n\n### What is a Deserialization Vulnerability?\n\n“Serialized” data is just an object or data structure that has been encoded in a way that can be transferred easily – for example over the\nnetwork. Developers do this regularly to pass objects between different parts of an application or between a client and server to maintain\nstate. Once it’s transferred, it can be \"deserialized\" and used like it never left the original function.\n\nDeserialization vulnerabilities result from applications putting too much trust in data that a user (or attacker) can modify. Deserialization\ncan become dangerous when 3 conditions are met:\n\nThe serialized object is provided by or can be modified by a user.\nAn application attempts to deserialize and use the object without validation.\nThe object is deserialized by a portion of the application with valuable libraries in the \"class path\".\n\n\n-----\n\nExploiting a deserialization issue involves crafting a payload that replaces what should be a benign object or data structure such as a\nsession token or a ViewState – with code in the targeted language that executes something malicious for the attacker.\n\nIf dangerous classes or libraries are imported and accessible in the application “class path”, an attacker can reference useful functions or\nobject types (also referred to as “gadgets”) to execute their payload. Due to how applications are structured, the dangerous functions may\nnot be directly accessible, so successful exploitation often requires chaining several gadgets together.\n\nProjects such as YSoSerial (Java) and YSoSerial .NET (C#) consolidate public research on successful gadget chains for common\nlibraries and make it easy for anyone to generate a payload with one of these chains. This is then encoded and can be passed to servers\nwith deserialization bugs. When an application with these gadgets imported unsafely deserializes the payload, the chain will automatically\nbe invoked and execute the embedded command on the affected server.\n\n### What Does Successful Exploitation Look Like?\n\nDeserialization issues in HTTP servers can appear in many places – session/state data, Cookies, HTML form inputs, etc. In one recent\n[example (CVE-2019-18211), the C1 CMS application unsafely deserialized objects passed through certain SOAP requests, leading to](https://medium.com/@frycos/yet-another-net-deserialization-35f6ce048df7)\nremote code execution.\n\nAn HTTP SOAP request with a malicious payload is shown in Figure 1, and the server response is shown in Figure 2. In this case, the\nserver returned a simple HTTP 200 OK response after deserializing and executing the provided object.\n\nFigure 1: CVE-2019-18211 Exploit - Request\n\nFigure 2: CVE-2019-18211 Exploit - Response\n\n### Problem Surface Area\n\nAs mentioned, deserialization vulnerabilities can affect a wide variety of languages and libraries which results in a very large surface area\nfor attackers. Before we can develop a comprehensive hunting strategy, we need a thorough understanding of the problem space.\n\n**Varying Protocols**\n\nThis class of vulnerabilities is most commonly discussed in the context of web applications, but they’re not the only applications affected.\n\nIn 2017, [Google Project Zero demonstrated how to use .NET deserialization to target systems over Managed DCOM instead of HTTP.](https://googleprojectzero.blogspot.com/2017/04/exploiting-net-managed-dcom.html)\n[While not specifically deserialization, in 2016, two different Black Hat talks outlined ways to exploit the Java Messaging Service (JMS) and](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities-wp.pdf)\n[Java Naming and Directory Interface (JNDI) APIs through object/command injection. Just last week, a JNDI command injection 0-day was](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf)\n[released for the log4j Java logging package (CVE-2021-44228).](https://www.lunasec.io/docs/blog/log4j-zero-day/)\n\nFor this blog post, we will limit our scope to attacks that occur over HTTP. This will allow us to focus our initial research while targeting the\nmajority of deserialization exploitation attempts.\n\n**Languages and Objects**\n\n\n-----\n\nWhile any language can theoretically be at risk, some of the common languages/object types exploited with this class of vulnerability are\nserialized Java objects, .NET ViewStates, pickled Python objects, and serialized PHP objects. The following table details the header\nvalues used as a prefix for each of these object types.\n\n**Object Type** **Header (Hex)** **Header (Base64)**\n\n**Java Serialized** AC ED rO\n\n**.NET ViewState** FF 01 /w\n\n**Python Pickle** 80 04 95 gASV\n\n**PHP Serialized*** 4F 3A Tz\n\n*PHP serialized objects start with the ASCII O:LENGTH_OF_NAME: where LENGTH_OF_NAME is an integer. 4F 3A is the hex encoding\nof O:, but further tuning with a regular expression like O:[0-9]+: is necessary to avoid false positives.\n\n[Objects may also be serialized using language-specific formatters. For example, .NET applications may use formatters such as the](https://github.com/pwntester/ysoserial.net#usage)\nBinaryFormatter, LosFormatter, NetDataContractSerializer, Json.NET, or SoapFormatter depending on the vulnerable gadget. Of note,\nYSoSerial.NET generates UTF-16LE objects for most of its supported formatters, so many of these payloads start with 0xFFFE.\n\n**Encoding**\n\nWhile serialized objects can be transferred using the raw bytes, more frequently they will be encoded or encrypted in some way to make\nnetwork transfer simpler. Base64 is very common as it is language agnostic and simple to implement.\n\nEncoding methods can also be layered—for example by GZIP compressing and then Base64 encoding an object. For this blog post, we\nwill focus on simple Base64 encoding due to its prevalence.\n\n**Known vs Unknown Chains**\n\nFinally, this problem space includes a lot of unknowns. Deserialization vulnerabilities are regularly disclosed and, as mentioned, can affect\nany part of an application. Attackers are much more limited in how they can weaponize these vulnerabilities, and as defenders, we have\nan opportunity to hunt for novel exploitation by looking for the gadget chains and keywords that attackers must use to execute their final\npayload.\n\nSecurity researchers (and attackers) are constantly looking for new dangerous gadget chains in common libraries or applications. Several\nwell-known projects that centralize this research are listed in the following table, although this is by no means a comprehensive list. For\nthis blog post, we’ll start with the ysoserial Java project, which was the first major tool and research to be released for this class of bugs.\n\n**Project Name** **Language/Software Affected** **GitHub URL**\n\n**ysoserial** Java [https://github.com/frohoff/ysoserial](https://github.com/frohoff/ysoserial)\n\n**ysoserial (forked)** Java [https://github.com/wh1t3p1g/ysoserial](https://github.com/wh1t3p1g/ysoserial)\n\n**ysoserial.net** .NET 3.5 [https://github.com/pwntester/ysoserial.net](https://github.com/pwntester/ysoserial.net)\n\n**ysoserial.net v2 branch** .NET 2 (currently only chains for v3.5) [https://github.com/pwntester/ysoserial.net/tree/v2](https://github.com/pwntester/ysoserial.net/tree/v2)\n\nFor this research effort we want to identify a way to generate rules for known gadget chains, but we also want a more generalized\napproach that can let us proactively identify exploitation attempts for novel vulnerabilities and/or gadget chains. One method here could\nbe looking for the payload vs the chain used to execute the payload. For example, we could hunt for serialized objects with DOS headers,\nmalicious commands, or suspicious binaries.\n\n### Solution Surface Area\n\nNow that we understand what we are trying to hunt for, we need to determine how we will hunt for it. The available detection surface area\nvaries depending on your goals and visibility, but hunting opportunities typically fall into three categories:\n\nNetwork\n\nThe most direct method for detecting this method of attack is to observe the exploitation attempt as the requests are made.\nEndpoint - Dynamic\n\nThis may involve looking for uncommon process execution or behavior from web servers. (For example, IIS servers running\ncmd.exe /c whoami.) This will limit us to observing successful exploitation attempts only, though, and it will be biased towards\nexploitation for remote code execution (RCE). We may have limited visibility into exploitation for other objectives like file\nupload or remote URL inclusion\n\n\n-----\n\nEndpoint Static (Log/File)\n\nDepending on your network traffic visibility, using YARA rules to look at decrypted requests in server logs may provide the\nsame (or better) visibility into exploitation attempts than a network IOC. One limitation here is that logs may not include the full\nserver response, so we will have incomplete evidence.\n\nFor this blog post, we will focus on network hunting (through Snort rules) with some static log file hunting (through YARA rules).\n\n## Make or Break\n\nNow that we have a grasp of the problem space we want to address, we can define a hunting plan. We need an approach that will let us\ngenerate hunting logic and translate it into a variety of detection rule formats for both suspicious gadget chains and suspicious keywords.\nWe also need to account for variability in object type and encoding method.\n\n### Tools\n\n[Since this is a complex class of bugs, we started out by creating HeySerial, a Python tool for rule generation. This lets us rapidly prototype](https://github.com/mandiant/heyserial/blob/main/heyserial.py)\ndetection logic, and it will let us keep up with new vulnerabilities as they are found.\n\nAs of publishing, HeySerial supports the following options:\n\n**Flag** **Description** **Options (Defaults Bolded)** **Format**\n\n**-k** Keyword(s) N/A Space delimited list of strings\n\n**-c** Gadget Chain(s) N/A Space delimited list of chains\n\nChain format – <Name>::<key1>+<key2>…\n\n**-t** Object Type(s) **JavaObj, PythonPickle, PHPObj, …** Space delimited list of strings\n\nSee help (-h) for full list.\n\n**-e** Encoding Method(s) **base64, raw, utf8, utf16le** Space delimited list of strings\n\nSingle method and/or chain.\n\nChain format – <method1>+<method2>\n\n**-o** Rule Output Type(s) **snort, yara** Space delimited list of strings\n\n**-r** Report Type(s) **bar, tsv** Space delimited list of strings\n\nTo generate rules for ViewState objects with a known vulnerable chain:\n\n```\npython3 heyserial.py -c 'ExampleChain::mscorlib+ActivitySurrogateSelector' -t NETViewState\n\n```\n\nTo generate rules for all object types with suspicious keywords:\n\n```\npython3 heyserial.py -k cmd.exe whoami ‘This file cannot be run in DOS mode’\n\n```\n\nTo generate rules for ViewState objects with UTF-16LE encoded Base64 encoded keywords:\n\n```\npython3 heyserial.py -k Process.Start -t NETViewState -e “base64+utf16le”\n\n```\n\nAlthough HeySerial supports a limited number of initial encoding and object types, it was designed to be extensible. For more details on\n[how to extend HeySerial and add new encoding methods, object types, or rule formats, check out the Developer Guide.](https://github.com/mandiant/heyserial/blob/main/DEVELOPERS.md)\n\n### Solve for Ex(ploits)\n\nThe next step is gathering (or creating) payloads to test our rules against. There are many public projects, as mentioned, but we will focus\non the ysoserial Java gadget chains. YSoSerial lists the supported chains in the README, but the list is more than three items so let’s\nautomate it!\n\n\n-----\n\nFigure 3: YSoSerial Java payload options\n\nThe following command generates a payload that launches “calc.exe” using the CommonsCollections1 chain. The raw hex bytes of the\npayload are shown in Figure 4. If we print the file contents directly, we will see some interesting strings mixed in with other non-printable\n(non-ASCII) characters, as seen in Figure 5.\n```\n java -jar utils/ysoserial.jar CommonsCollections1 calc.exe > commonscollections1.bin\n\n```\nFigure 4: CommonsCollections1 payload\n\nFigure 5: Inspecting a CommonsCollections1 YSoSerial payload\n\nWe can use a simple Bash script to loop through the list of supported chains and output them to a file. Some chains require different\n[payload inputs than others, so check out generate_payloads.sh to see how we can handle that with a switch-case block. For](https://github.com/mandiant/heyserial/blob/main/utils/generate_payloads.sh)\n[YSoSerial.NET payloads, try the](https://github.com/pwntester/ysoserial.net) [generate_payloads.ps1 script on a Windows system.](https://github.com/mandiant/heyserial/blob/main/utils/generate_payloads.ps1)\n\nSince we want to test Base64 rules, we can also add a command to the payload generation script that will save the Base64 encoded\npayloads to a separate file for us.\n```\n base64 -w 0 “$filename.bin” > “$filename.base64”\n\n### PCAPs or It Didn’t Happen\n\n```\n[Now that we have our generated payloads, we can simply run YARA against the files to validate our rules. However, to test our Snort](https://github.com/mandiant/heyserial/tree/main/payloads)\nrules, we’ll need to generate a PCAP with the payloads demonstrating a “malicious” web request.\n\n\n-----\n\n[For that we can start a basic HTTP server using this server.py script, and we can execute the following Bash commands in a separate](https://github.com/mandiant/heyserial/blob/main/utils/server.py)\nterminal. This will do a plain HTTP POST request to our local server with each payload in the body of the request.\n\n```\nfor sample in `ls *.bin`; do curl -m 3 --data-binary “@$sample” http://127.0.0.1:12345; done;\n\n```\n```\nfor sample in `ls *.base64`; do curl -m 3 --data “@$sample” http://127.0.0.1:12345; done;\n\n```\n\nFor testing purposes, we don’t need to exploit an actual vulnerability or web server. We just need network traffic that looks like an\n[attempted exploit. Using these PCAPs and the payload files we already generated, we will be able to test both Snort and YARA rules.](https://github.com/mandiant/heyserial/tree/main/pcaps)\n\n### The Golden Rules\n\nOk we have payloads, and we have a script. It’s finally time to make our hunting rules! There are many ways to identify the list of\nkeywords we want to include for each chain. The YSoSerial repo includes details of the classes and functions that make up a payload, but\nthis is\n\n1. Scattered in different files\n2. Not necessarily an exact match for what will be in the final serialized object\n\nAnother simple method for bulk extracting imported classes or functions is looping through all (raw hex) payloads and getting the first 5\nstrings with a “\\..*\\.” pattern. We can accomplish this by adding the following line to our Bash script:\n\n```\nstrings “$filename.bin” | grep -E ‘\\..*\\.’ | head -5 > “$filename.strings”\n\n```\n\n[This approach requires a bit of manual cleanup on the strings, but once we’re done, we can generate rules knowing these classes or](https://github.com/mandiant/heyserial/tree/main/rules/javaobj)\nfunctions are included in a default YSoSerial Java payload.\n\n(Please note, these—especially YARA—are all hunting rules for research purposes, not detections. Do not deploy these to production\n_systems without testing and tuning for your environment.)_\n\nThe following command generates Snort and YARA rules with both raw and Base64 encoded chains for some common payloads in\nYSoSerial (Java).\n```\n python3 heyserial.py -t JavaObj -e base64 raw -o snort yara -c \"AspectJWeaver::HashSet+TiedMapEntry+org.apache.com\n \"BeanShell1::java.util.PriorityQueue+Comparator+java.lang.reflect.Proxy+Hashtable+Vector\"\n \"C3P0::com.mchange.v2.c3p0.PoolBackedDataSource+AbstractPoolBackedDataSource+PoolBackedDataSourceBase+com.mchange.v\n \"Click1::java.util.PriorityQueue+org.apache.click.control.Column+Column+Table+AbstractControl\" \"Clojure::HashMap+cl\n \"CommonsBeanutils1::java.util.PriorityQueue+org.apache.commons.beanutils+BeanComparator+ComparableComparator+com.su\n \"CommonsCollections1_3::sun.reflect.annotation.AnnotationInvocationHandler+Map+Proxy+org.apache.commons.collections\n \"CommonsCollections2::java.util.PriorityQueue+org.apache.commons.collections4.comparators.TransformingComparator+Co\n \"CommonsCollections4::java.util.PriorityQueue+org.apache.commons.collections4.comparators.TransformingComparator+Co\n \"CommonsCollections5::javax.management.BadAttributeValueExpException+org.apache.commons.collections.keyvalue.TiedMa\n \"CommonsCollections6::java.util.HashSet+org.apache.commons.collections.keyvalue.TiedMapEntry+org.apache.commons.col\n \"CommonsCollections7::java.util.Hashtable+org.apache.commons.collections.map.LazyMap+ChainedTransformer+ConstantTra\n \"Groovy1::sun.reflect.annotation.AnnotationInvocationHandler+Map+Proxy+org.codehaus.groovy.runtime.ConvertedClosure\n \"Hibernate1_2::java.util.HashMap+org.hibernate.engine.spi.TypedValue+org.hibernate.type+ComponentType+AbstractType+\n \"JavassistWeld1::org.jboss.weld.interceptor.proxy.InterceptorMethodHandler+org.jboss.weld.interceptor.builder.Inter\n \"JBossInterceptors1::org.jboss.interceptor.proxy.InterceptorMethodHandler+org.jboss.interceptor.builder.Interceptio\n \"Jdk7u21::java.util.LinkedHashSet+HashSet+com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl+javax.xml.tran\n \"JRMPClient::java.rmi.registry.Registry+java.lang.reflect.Proxy+java.rmi.server.RemoteObjectInvocationHandler\"\n \"JRMPListener::sun.rmi.server.ActivationGroupImpl+java.rmi.activation.ActivationGroup+java.rmi.server.UnicastRemote\n \"Jython1::java.util.PriorityQueue+java.util.Comparator+java.lang.reflect.Proxy+org.python.core.PyFunction+org.pytho\n \"MozillaRhino1::org.mozilla.javascript.NativeError+org.mozilla.javascript.NativeJavaObject+org.mozilla.javascript.M\n \"MozillaRhino2::org.mozilla.javascript.NativeJavaObject+org.mozilla.javascript.tools.shell.Environment+org.mozilla.\n \"Myfaces1_2::java.util.HashMap+org.apache.myfaces.view.facelets.el.ValueExpressionMethodExpression+javax.el.MethodE\n \"ROME::java.util.HashMap+com.sun.syndication.feed.impl.ObjectBean+com.sun.syndication.feed.impl.CloneableBean+java.\n \"Spring1_2::org.springframework.core.SerializableTypeWrapper+MethodInvokeTypeProvider+TypeProvider+java.lang.reflec\n \"Vaadin1::javax.management.BadAttributeValueExpException+com.vaadin.data.util.PropertysetItem+com.vaadin.data.util.\n \"Wicket1::org.apache.wicket.util.upload.DiskFileItem+java.io.File\"\n\n## Putting It to the Test\n\n```\nNow for the exciting part—seeing it all in action!\n\n### YARA Rules\n\n[Testing YARA rules on files is really simple with YARA installed. We can save our generated rules to a file, and then run the following](https://yara.readthedocs.io/en/stable/gettingstarted.html)\ncommand:\n\n```\nyara ysoserial_CommonsCollections1.yar ysoserial_CommonsCollection1.bin\n\n```\n\nIf it works, we will see a line with the rule name and the file it matched on. The very last line of Figure 6 shows that our YARA rule\nmatches!\n\n\n-----\n\nFigure 6: Testing a YARA rule\n\n### Snort Rules\n\n[We can also test out our Snort rules using a local installation of Snort. Snort will throw an error if you have invalid (or duplicate) signature](https://snort.org/#get-started)\nIDs, so we can bulk edit our rules with this command. (Please update the SIDs to valid values if you deploy them in your environment.)\n\n```\nperl -pe 'BEGIN{$A=100;} s/<REPLACE_SID>/$A++/ge' -i rules/*/*snort\n\n```\n\nThe following command will run a specific rule file against a test PCAP:\n\n```\nsudo snort -A console -k none -q -r ysoserial_java_rawbase64.pcap -c CommonsCollections1_3.snort\n\n```\n\nThe “-k none” option tells Snort to disable checksum mode, because our test data was generated with localhost as the source/destination\nand will be ignored by Snort otherwise. We can also set this by changing “config checksum_mode: all” to “none” in the\n/etc/snort/snort.conf configuration file. As shown in Figure 7, our Snort rule matches on the PCAP!\n\nFigure 7: Testing a Snort rule\n\n### Another Tool??\n\nWe can validate our rules manually, but that doesn’t serve our goal of rapidly prototyping a bunch of hunting and detection ideas. To that\n[end, we made CheckYoself, a Python script that accepts file or directory paths to Snort and YARA rules and runs it against specified data](https://github.com/mandiant/heyserial/blob/main/utils/checkyoself.py)\nfiles. By default it prints a TSV of the results to the screen, but we can save this to a file as well.\n\nThis command will run all generated JavaObj rules against our JavaObj payloads and PCAPs.\n\n```\npython3 utils/checkyoself.py -y rules/javaobj -s rules/javaobj -d payloads/javaobj pcaps/ -o java_all\n\n```\n\nAdding the --misses flag will filter our results to show only the files (for YARA) or rules (for Snort) that had 0 matches.\n\n```\npython3 utils/checkyoself.py -y rules/javaobj -s rules/javaobj -d payloads/javaobj pcaps/ -o java_all --misses\n\n```\n\n## What Else?\n\nThe research process and the tool we’ve discussed today are a great starting point, but as with any detection there are both limitations\nand opportunities to be aware of.\n\n### Fine Tuning Our Snort Rules\n\nOne issue with our Snort rules is that, in their current state, we have no way of knowing if the exploit attempt was successful or not which\nmeans we could get a lot of noisy alerts for internet facing systems that get scanned.\n\nTo account for this, we can use Snort flowbits. By adding flowbits:set,heyserial; to our Snort rules, we can deploy another rule like the\nfollowing that looks for server responses. This example is looking for any HTTP traffic with the flowbit set from our previous HeySerial\ngenerated rules except for HTTP responses with a 301 (redirect) or 404 (not found) status code.\n```\n alert tcp any any -> any any ( msg:\"M.Methodology.HTTP.SerializedObject.[ServerResponse]\"; content:\"HTTP\";\n depth:4; content:!\"301\"; offset:9; depth:3; content:!\"404\"; offset:9; depth:3; flowbits:isset,heyserial;\n threshold:type limit,track by_src,count 1,seconds 1800; sid: <REPLACE_SID>; rev:1; )\n\n```\nFor production deployment, this will require additional testing and tuning to get higher fidelity results. Once we have more strict conditions\naround what we consider successful exploitation (or close enough that we want to review it), we will only need to monitor the\nServerResponse rule.\n\nSome examples of tuning opportunities to explore include:\n\nIgnoring certain HTTP status codes\nFiltering out known default pages (such as your company home page)\nCreating separate flowbits per language. This could allow us to verify that server responses match the requests. For example, a\nJava exploit chain request with a response from an IIS server is unlikely to be successful exploitation.\n\n### Encryption\n\n\n-----\n\nWe have tested these rules on unencrypted objects so far, but there are two cases where encryption may come into play and reduce the\nefficacy.\n\nFirst, some objects may be encrypted. Multiple widely exploited CVEs resulted from applications encrypting .NET ViewState objects either\nusing a static/default encryption key or by allowing users to brute force the encryption key. Attackers can use [public tools to encrypt their](https://github.com/0xacb/viewgen)\npayloads with known keys if they’re able to discover or brute force one.\n\nSecond, the network traffic itself will likely be encrypted. If your network appliances are not intercepting and decrypting traffic, then you’ll\nhave to rely on other static or endpoint detections.\n\n### Opportunities are Endless!\n\nHeySerial currently only supports network rules for HTTP traffic, but this isn’t the only protocol that can be affected. Expanding these\nhunting rules to other protocols such as COM is likely a fruitful area for further research.\n\nFinally some language specific formatters will still leave strings that can be detected with Hex or Base64 rules, but some may require\ncustomized encoders.\n\n### A Note on CVE-2021-44228\n\n[On December 9, 2021, a zero-day exploit was released for log4j, a Java log library. While this is an example of JNDI code injection, not](https://mbechler.github.io/2021/12/10/PSA_Log4Shell_JNDI_Injection/)\nnecessarily deserialization, this tool and the concepts we’ve discussed also apply here. By adding a JNDI object prefix of “${jndi:”, we can\ngenerate hunting rules for this type of command injection using the following HeySerial command.\n\n```\npython3 heyserial.py -t JNDIObj -e raw base64 -k dns:/ ldap:/ ldaps:/ rmi:/\n\n```\n\nThese rules look for any objects that follow the unobfuscated format: ${jndi:ldap://<example>.com/a}. However, due to the ease of\nobfuscating this initial stage of exploitation, it will likely be more robust to focus detection on the stage two and post-exploitation stages of\n[these attacks—such as the remote loading of serialized Java classes.](https://github.com/veracode-research/rogue-jndi)\n\nHunting rules, sample payloads, and a test PCAP for the unobfuscated POC are provided in the HeySerial repository for your testing.\nPlease note, these are not production/blocking ready detections.\n\n## Conclusion\n\nIn this blog post, we explored deserialization vulnerabilities and developed a process and tools to rapidly prototype detections for in-thewild exploitation. Although this type of bug has been around for years, Mandiant continues to observe threat actors, including advanced\ngroups like APT41, using publicly disclosed exploit “chains” in their intrusions.\n\nOur tool, HeySerial.py, is intended to be an extensible framework that can be expanded to support additional object types, encoding\n[methods, and rule formats. To find out more, check out our Developer Guide.](https://github.com/mandiant/heyserial/blob/main/DEVELOPERS.md)\n\n## Mandiant Security Validation Content\n\n[Mandiant Security Validation includes Actions for the YSoSerial Java payloads shared in the HeySerial repository. Please see actions with](https://app.validation.mandiant.com/)\n[VID A102-150 through A102-205 in Mandiant Advantage for more details.](https://app.validation.mandiant.com/)\n\n## Acknowledgements\n\nSpecial thanks to James Hovious for sharing his expertise (and exploits), Ashley Zaya for her review, and to Gregory LeBlanc and William\nBallenthin for code review. Extra special thanks to Evan Reese for being a Snort guru, because otherwise this blog post would probably\nonly include YARA.\n\n## Prior Work / Additional Resources\n\n### Tools\n\n[Deserialization-Cheat-Sheet – @GrrrDog](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet)\n[Ysoserial - @frohoff](https://github.com/frohoff/ysoserial)\n[Ysoserial (forked) - @wh1t3p1g](https://github.com/wh1t3p1g/ysoserial)\n[Ysoserial.NET and](https://github.com/pwntester/ysoserial.net) [v2 branch- @pwntester](https://github.com/pwntester/ysoserial.net/tree/v2)\n[ViewGen – 0xacb](https://github.com/0xacb/viewgen)\n[Rogue-JNDI – @veracode-research](https://github.com/veracode-research/rogue-jndi)\n\n### Vulnerabilities\n\n[Log4J (CVE-2021-44228)](https://www.lunasec.io/docs/blog/log4j-zero-day/)\n[Exchange (CVE-2021-42321)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42321)\n[Zoho ManageEngine (CVE-2020-10189)](https://nvd.nist.gov/vuln/detail/CVE-2020-10189)\n[Jira (CVE-2020-36239)](https://oxalis.io/atlassian-jira-data-centers-critical-vulnerability-what-you-need-to-know/)\n[Telerik (CVE-2019-18935)](https://bishopfox.com/blog/cve-2019-18935-remote-code-execution-in-telerik-ui)\n\n\n-----\n\n[C1 CMS (CVE 2019 18211)](https://medium.com/@frycos/yet-another-net-deserialization-35f6ce048df7)\n[Jenkins (CVE-2016-9299)](https://nvd.nist.gov/vuln/detail/CVE-2016-9299)\n[What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability. –](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)\n@breenmachine, FoxGloveSecurity (2015)\n\n### Talks and Write-Ups\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-13 - Now You Serial, Now You Don’t — Systematically Hunting for Deserialization Exploits.pdf"
    ],
    "report_names": [
        "2021-12-13 - Now You Serial, Now You Don’t — Systematically Hunting for Deserialization Exploits.pdf"
    ],
    "threat_actors": [
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "4d5f939b-aea9-4a0e-8bff-003079a261ea",
            "created_at": "2023-01-06T13:46:39.04841Z",
            "updated_at": "2025-03-27T02:00:02.985296Z",
            "deleted_at": null,
            "main_name": "APT41",
            "aliases": [
                "G0096",
                "Grayfly",
                "BARIUM",
                "BRONZE ATLAS",
                "BRONZE EXPORT",
                "Red Kelpie",
                "HOODOO",
                "Brass Typhoon",
                "TA415",
                "WICKED SPIDER",
                "WICKED PANDA",
                "G0044",
                "Earth Baku"
            ],
            "source_name": "MISPGALAXY:APT41",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e698860d-57e8-4780-b7c3-41e5a8314ec0",
            "created_at": "2022-10-25T15:50:23.287929Z",
            "updated_at": "2025-03-27T02:00:55.43005Z",
            "deleted_at": null,
            "main_name": "APT41",
            "aliases": [
                "APT41",
                "Wicked Panda",
                "Brass Typhoon",
                "BARIUM"
            ],
            "source_name": "MITRE:APT41",
            "tools": [
                "ASPXSpy",
                "BITSAdmin",
                "PlugX",
                "Impacket",
                "gh0st RAT",
                "netstat",
                "PowerSploit",
                "ZxShell",
                "KEYPLUG",
                "ipconfig",
                "sqlmap",
                "China Chopper",
                "ShadowPad",
                "MESSAGETAP",
                "Mimikatz",
                "certutil",
                "njRAT",
                "Cobalt Strike",
                "pwdump",
                "BLACKCOFFEE",
                "ROCKBOOT",
                "dsquery",
                "Winnti for Linux",
                "DUSTTRAP",
                "Derusbi",
                "ftp"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535629,
    "ts_updated_at": 1743041777,
    "ts_creation_date": 1653533366,
    "ts_modification_date": 1653533366,
    "files": {
        "pdf": "https://archive.orkl.eu/028d70adc029235a70185cb28ab2d46e1e41ce9c.pdf",
        "text": "https://archive.orkl.eu/028d70adc029235a70185cb28ab2d46e1e41ce9c.txt",
        "img": "https://archive.orkl.eu/028d70adc029235a70185cb28ab2d46e1e41ce9c.jpg"
    }
}