{
    "id": "c851fdc2-5a3a-4199-9fbe-bd7829a534e4",
    "created_at": "2023-01-12T15:06:58.624006Z",
    "updated_at": "2025-03-27T02:09:18.055219Z",
    "deleted_at": null,
    "sha1_hash": "77af043874aaadb6f95792d91fd11ea026922296",
    "title": "2020-11-20 - Detecting Cobalt Strike Default Modules via Named Pipe Analysis",
    "authors": "",
    "file_creation_date": "2022-05-27T19:05:56Z",
    "file_modification_date": "2022-05-27T19:05:56Z",
    "file_size": 447211,
    "plain_text": "# Detecting Cobalt Strike Default Modules via Named Pipe Analysis\n\n**[labs.f-secure.com/blog/detecting-cobalt-strike-default-modules-via-named-pipe-analysis](https://labs.f-secure.com/blog/detecting-cobalt-strike-default-modules-via-named-pipe-analysis)**\n\n## Introduction\n\nDuring recent years, the Cobalt Strike framework has gained significant popularity amongst\nred teamers and threat actors alike. Its functionality, flexibility and stability make it the state of\nthe art when it comes to commercially available Command & Control frameworks.\n\nConsiderable efforts have been made to build robust signatures for Cobalt Strike and its\nimplant, Beacon. The aim of this post is to examine some previously unknown Indicators of\nCompromise (IoCs). This post is not going to cover signatures for the default Cobalt Strike\n[configuration - other papers offer an in-depth look at this. Instead, we will focus our attention](https://talos-intelligence-site.s3.amazonaws.com/production/document_files/files/000/095/031/original/Talos_Cobalt_Strike.pdf)\non some of the built-in modules that provide Cobalt Strike's post exploitation capability, such\nas the keylogger, Mimikatz and the screenshot modules.\n\nIt must be noted that the IoC/behaviour was raised with the Cobalt Strike's author and\nsubsequently exposed to operators as a customisable setting in the 4.2 malleable profile.\n\nThe hope is that this post will help both defenders in strengthening their detection\ncapabilities, and force red teamers to use more sophisticated and customised techniques.\n\n## Analysis\n\nCobalt Strike is known to use a specific pattern, known as \"Fork-n-Run\", when executing\nsome of [its commands. The \"Fork-n-Run\" pattern comprises the spawning of a new process](https://www.cobaltstrike.com/help-opsec)\n(also referred to as a sacrificial process) and injecting capabilities into it. This pattern offers a\nnumber of benefits, one being the ability to execute long running tasks, the \"keylogger\" being\na prime example, without blocking the main Beacon thread. Often, these capabilities are\nimplemented as Reflective DLLs.\n\n[Recent versions of the framework have given operators great flexibility in how to customise](https://blog.cobaltstrike.com/2020/06/25/cobalt-strike-4-1-the-mark-of-injection/)\n[the capability injection process. However, some general aspects haven't changed much, and](https://www.cobaltstrike.com/help-malleable-postex)\nthat's what we are going to focus on.\n\nMore specifically, a characteristic that remained unchanged was the ability to retrieve the\noutput of an injected module. The \"keylogger\" module, for example, is able to send the\npressed keys back to the main beacon process. But since the \"keylogger\" module is fully\nfileless, how does the communication with the main beacon process happen?\n\nThe answer: pipes!\n\n\n-----\n\nPipes are shared memory used for processes to communicate between each other.\nFundamentally there are two types of pipe: named and unnamed.\n\nNamed pipes, as the name implies, have a name and can be accessed by referencing\nthis.\nUnnamed pipes, that need their handle to be passed to the other communicating\n[process in order to exchange data. This can be done in a number of ways.](https://docs.microsoft.com/en-us/Windows/win32/ipc/pipe-handle-inheritance)\n\nCobalt Strike uses both named and unnamed pipes to exchange data between the beacon\nand its sacrificial processes.\n\n## Named Pipes\n\nF-Secure observed that when using some of the Cobalt Strike's modules that injected a\nreflective DLL into a sacrificial process, a named pipe was created with a predictable pattern.\n\nNote that these named pipes are not the SMB named pipes used for lateral movement that\ncan be customised via the malleable profiles. Prior to version 4.2, this named pipe's name\ncould not be modified by operators.\n\nMore specifically, it was observed that once a \"job\" was launched, the beacon created a\nnamed pipe; the name of the pipe comprised only hexadecimal characters, and its length\nwas found to be equal to the length of the module name (e.g. 10 characters for the\nscreenshot module) . Some of the modules that were found to have this behaviour:\n\nKeylogger\nScreenshot\nMimikatz (dcsync, dpapi, logonpasswords)\nPowerpick\nNet (netview)\n\nThe screenshot below shows an example of Sysmon event ID 17 and 18 (pipe created and\naccessed, respectively) after the \"keylogger\" command was executed:\n\n\n-----\n\nA limited number of experiments were made, but no other legitimate application was found to\ncreate named pipes with the same naming convention. We will use this information later to\ncreate Splunk searches that use Sysmon and a Yara rule to scan the processes memory.\n\n## Anonymous Pipes\n\nNot every Cobalt Strike command creates a named pipe, some of them will use anonymous\n(unnamed) pipes to achieve the same result. The image below shows an instance of a pipe\ncreated after issuing the \"execute-assembly\" command:\n\n\n-----\n\nWe can confirm that by debugging the sacrificial process spawned after launching a longrunning assembly:\n\nA breakpoint was set on the \"ntdll!NtWriteFile\" function, and as it is possible to see, the\nhandle where the sacrificial process was trying to write to was associated with an unnamed\nfile that belonged to the pipe filesystem (Npfs):\n\n\n-----\n\nAs we can see, spotting commands such as \"execute-assembly\" is not as trivial as the\nexamples above. Is there anything that we can do using pipes?\n\nIn theory, we could baseline processes that use anonymous pipes. The interesting result is\nthat native Windows processes do not use anonymous pipes that often. So we could look for\nWindows processes that connect to an anonymous pipe and investigate from there.\n\nWe mention \"Windows processes\" because, more often than not, attackers use native\nWindows binaries as sacrificial processes within their malleable profiles. Examples of such\n[are the binaries listed in the C2Concealer repository, a project used to create randomised](https://github.com/FortyNorthSecurity/C2concealer/blob/master/C2concealer/data/post_ex.py)\nmalleable profiles. We can see the executables from the C2Concealer default configuration\nbelow:\n```\n''\n#################################################\nData set containing post_ex block data, including\nspawn-to processes.\n#################################################\n'''\n#CUSTOMIZE THIS LIST#\nspawn_processes = ['runonce.exe','svchost.exe','regsvr32.exe','WUAUCLT.exe']\n\n```\nAs it is possible to see, the above-mentioned processes are used for post exploitation jobs.\nNone of them usually use anonymous pipes to communicate with different processes; it\nwould therefore be possible to use this to perform hunting and eventually create detection\nrules.\n\n\n-----\n\nDuring experiments, the following Windows binaries were found to be using anonymous\npipes for interprocess communication:\n\nwsmprovhost.exe\nngen.exe\nsplunk.exe\nsplunkd.exe\nfirefox.exe\n\nThe same applies to custom reflective DLLs that are executed via Cobalt Strike's dllspawn\nAPI, as the underlying mechanism for communication is the same. An example of such is the\nOutflank's [Ps-Tools repository. Ps-Tools is a collection of rDLL fully compatible with Cobalt](https://github.com/outflanknl/Ps-Tools)\n[Strike that allow operators to monitor process activity. Let's execute the \"psw\" module, used](https://outflank.nl/blog/2020/03/11/red-team-tactics-advanced-process-monitoring-techniques-in-offensive-operations/)\nto enumerate the active Windows, as shown below:\n\nExecuting this module, we can identify the same anonymous pipe behaviour we've seen\nbefore:\n\n\n-----\n\n## Detection Rules\n\nDetection of the anomalous named pipes can be achieved in a number of ways. As a proofof-concept, we developed a Yara signature that could be used to scan process memory and\nfind live instances, and a Splunk search that could be used in conjunction with Sysmon.\n\nThe Yara rule is shown below:\n\n\n-----\n\n```\nrule cs_job_pipe\n{\n  meta:\n    description = \"Detects CobaltStrike Post Exploitation Named Pipes\"\n    author = \"Riccardo Ancarani & Jon Cave\"\n    date = \"2020-10-04\"\n  strings:\n    $pipe = /\\\\\\\\\\.\\\\pipe\\\\[0-9a-f]{7,10}/ ascii wide fullword\n    $guidPipe = /\\\\\\\\\\.\\\\pipe\\\\[0-9a-f]{8}\\-/ ascii wide\n  condition:\n    $pipe and not ($guidPipe)\n}\n\n```\nAn example of execution against a sacrificial process:\n```\n.\\yara64.exe .\\cs-job-pipe.yar -s 9908\ncs_job_pipe 9908\n0x13372b7b698:$pipe: \\\\.\\pipe\\928316d80\n0x13372bf3940:$pipe:\n\\\\x00\\\\x00.\\x00\\\\x00p\\x00i\\x00p\\x00e\\x00\\\\x009\\x002\\x008\\x003\\x001\\x006\\x00d\\x008\\x000\n\n```\nThe Splunk search below can be used to alert on the creation of named pipes that match the\naforementioned pattern:\n```\nindex=\"YOUR_INDEX\" source=\"XmlWinEventLog:Microsoft-Windows-Sysmon/Operational\"\nEventCode=17 PipeName!=\"&lt;Anonymous Pipe&gt;\"  | regex PipeName=\"^\\\\\\\\[a-f0-9]\n{7,10}$\"\n\n```\nIn regards to using anonymous pipes for automatic detection, this approach can be more\nprone to false positives. However, it can be used in conjunction with other IOCs to achieve\nbetter results.\n\nAn example of a Splunk search that can be used to obtain the processes that created an\nanonymous pipe, sorted by least frequency:\n```\nindex=\"YOUR_INDEX\" source=\"XmlWinEventLog:Microsoft-Windows-Sysmon/Operational\"\nEventCode=17 PipeName=\"&lt;Anonymous Pipe&gt;\"| rare limit=20 Image\n\n## Opsec Considerations\n\n```\nFrom a red teaming perspective, Cobalt Strike version 4.2 gives operators the ability to\nmodify the aforementioned named pipe naming convention. In fact, it would be possible to\nconfigure the \"pipename\" parameter within the \"post-ex\" block with a name that would,\nideally, blend-in with the pipes used in the environement.\n\n\n-----\n\nAn example of a post-ex block is shown below:\n```\npost-ex {\n  set spawnto_x86 \"%windir%\\\\syswow64\\\\dllhost.exe\";\n  set spawnto_x64 \"%windir%\\\\sysnative\\\\dllhost.exe\";\n  set obfuscate \"true\";\n  set smartinject \"true\";\n  set amsi_disable \"true\";\n  set pipename \"pipe\\\\CtxSharefilepipe###,\";\n  }\n\n```\nAdditionally, choosing binaries that legitimately use anonymous pipes in the \"spawnto_x86\"\nand \"spawnto_x64\" parameters will decrease the chances of being detected.\n\nThe [official malleable command reference and](https://www.cobaltstrike.com/help-malleable-c2) [ThreatExpress' jQuery example profile are](https://github.com/threatexpress/malleable-c2/blob/master/jquery-c2.4.2.profile)\ngreat resources for learning more about Cobal Strike's malleable profile options.\n\n## Closing Thoughts\n\nThis post showed two different strategies for identifying Cobalt Strike usage within an\nendpoint: we started by analysing anomalous named pipes associated with default modules\nand then we shifted our focus on a more statistical approach to identify even more\nsophisticated attacks.\n\nFor attackers, we have reinforced the importance of staying away from default settings and\nmodules. While for defenders, we hope we gave some practical advice on how to spot this\nspecific tool and more generally, monitor pipe anomalies using tools such as Sysmon.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-20 - Detecting Cobalt Strike Default Modules via Named Pipe Analysis.pdf"
    ],
    "report_names": [
        "2020-11-20 - Detecting Cobalt Strike Default Modules via Named Pipe Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536018,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653678356,
    "ts_modification_date": 1653678356,
    "files": {
        "pdf": "https://archive.orkl.eu/77af043874aaadb6f95792d91fd11ea026922296.pdf",
        "text": "https://archive.orkl.eu/77af043874aaadb6f95792d91fd11ea026922296.txt",
        "img": "https://archive.orkl.eu/77af043874aaadb6f95792d91fd11ea026922296.jpg"
    }
}