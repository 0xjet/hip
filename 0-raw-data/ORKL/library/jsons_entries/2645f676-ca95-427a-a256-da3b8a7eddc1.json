{
    "id": "2645f676-ca95-427a-a256-da3b8a7eddc1",
    "created_at": "2023-01-12T15:08:28.23153Z",
    "updated_at": "2025-03-27T02:06:03.38743Z",
    "deleted_at": null,
    "sha1_hash": "fe6ed8264cc31296f7697d78276afaab8c16000c",
    "title": "2021-01-06 - A Deep Dive into Lokibot Infection Chain",
    "authors": "",
    "file_creation_date": "2022-05-28T16:16:07Z",
    "file_modification_date": "2022-05-28T16:16:07Z",
    "file_size": 3133614,
    "plain_text": "# A Deep Dive into Lokibot Infection Chain\n\n**[blog.talosintelligence.com/2021/01/a-deep-dive-into-lokibot-infection-chain.html](https://blog.talosintelligence.com/2021/01/a-deep-dive-into-lokibot-infection-chain.html)**\n\nBy Irshad Muhammad, with contributions from Holger Unterbrink.\n\n## News summary\n\n[Lokibot is one of the most well-known information stealers on the malware landscape.](https://blog.talosintelligence.com/2020/07/current-events-lures.html)\nIn this post, we'll provide a technical breakdown of one of the latest Lokibot campaigns.\nTalos also has a new script to unpack the dropper's third stage.\n\n\n-----\n\nThe actors behind Lokibot usually have the ability to steal multiple types of credentials\nand other sensitive information. This new campaign utilizes a complex, multi-stage,\nmulti-layered dropper to execute Lokibot on the victim machine.\n\n**What's new?**\n\nThis sample is using the known technique of blurring images in documents to encourage\nusers to enable macros. While quite simple this is fairly common and effective against users.\nThis write up is intended to be a deep dive for reverse engineers into the latest tricks Lokibot\nis using to infect user machines.\n\n**How did it work?**\n\nThe attack starts with a malicious XLS attachment, sent in a phishing email, containing an\nobfuscated macro that downloads a heavily packed second-stage downloader. The second\nstage fetches the encrypted third-stage, which includes three layered encrypted Lokibot.\nAfter a privilege escalation, the third stage deploys Lokibot. The Image below shows the\ninfection chain.\n\n**So what?**\n\nDefenders need to be constantly vigilant and monitor the behavior of systems within their\nnetwork. This blog provides a detailed overview of how complex the infection chain is for\nLokibot and which tricks the adversaries are using to bypass common security features and\ntools of modern operating systems.\n\n\n-----\n\n## First-stage analysis\n\nWhen the user opens the phishing email, it presents a Spanish social engineering message\n(\"Payment: Find scheduled payment dates attached\"). The figure below shows a screenshot\nof one of the emails we looked at.\n\nThe Excel sheet uses another common social engineering technique by showing a blurredout image of a table with the text \"Changing the size of this document, please wait,\" in\nSpanish. If the victim clicks the \"Enable Content\" button, thinking it will make the image\nvisible, a malicious macro is executed.\n\nThe macro is mainly obfuscated by using long hexadecimal variable names. The screenshot\nbelow shows a portion of the `Workbook_Open` function of this macro.\n\n\n-----\n\nThe deobfuscated macro is shown below.\n\nIt decrypts the URL for the second-stage from hardcoded bytes, saves it to the \"Templates\"\nfolder, and executes it. The traffic generated from the macro is shown below.\n\n\n-----\n\n## Second-stage analysis\n\nThe second-stage executable is packed with a Delphi-based packer.\n\n### Packer analysis\n\nThe packer contains a timer `xvv` timer under `Form_main`, which unpacks the payload. The\ntimer and its handler code are shown below.\n\nThe unpacking function performs the following steps:\n\n1. Loads the image resource with name `T__6541957882` into memory.\n2. Finds the anchor `WWEX` and copies data following to the new buffer.\n\n\n-----\n\n3. Adds 0xEE to the bytes to decode the DLL.\n4. Reflectively loads decoded DLL into memory and executes it.\n\nThe figure below shows the resource image that contains the encoded executable.\n\nThe following image shows the location of the embedded executable following anchor\n`WWEX`.\n\n\n-----\n\nThe following code shows the code and decoded DLL.\n\n### Unpacked DLL analysis\n\nThe unpacked DLL is also written in Delphi. It fetches the third payload from the hardcoded\nURL.\n\nThe DLL sets a timer, as shown below, which will execute the downloader function\nperiodically.\n\n\n-----\n\nThe `Download3rdStage` will first decode `https://discord.com` and try to connect to it. Then,\nit performs a time-based anti-debug check, as shown in the code below. If any of these\nchecks fail, the DLL will not download the third stage.\n\nOnce the checks have passed, DLL will decrypt the hardcoded third-stage URL, as shown in\nthe code below, and send the HTTP request.\n\n\n-----\n\nIn response to the request, the server sends a ~618KB long hex string, as shown below.\n\nThe DLL decodes the hex string using the following steps:\n\n1. Reverse the hex string.\n2. Convert hexadecimal digits to bytes (unhexlify).\n3. XOR decode with hardcoded key \"ZKkz8PH0\".\n\n[We have written a small Python script to decrypt the third stage. The same decryption](https://gist.github.com/irshadqemu/68a4db9b3f8f4f205e17f6050ffbb652#file-unpack_3rdstage_lokibot-py)\nmethod was also used to decrypt the hardcoded command and control (C2).The resulting file\nis also a DLL, which the second stage reflectively loads.\n\n\n-----\n\n## Third-stage analysis\n\nThe third stage is also written in Delphi. At the start, it loads a sizable binary resource named\n`DVCLAL` into memory. It then generates the key `7x21zoom8675309` from hard coded\nbytes. The key is then used to decrypt the resource data using a custom encryption\nalgorithm. The malware then recovers the configuration structure from decrypted resource\ndata. The structure fields are delimited by string `*()%@5YT!@#G__T@#$%^&*\n()__#@$#57$#!@`.\n\nThe decryption algorithm is shown below.\n\n\n-----\n\nThe hex dump below shows a structure field highlighted separated by delimiters.\n\nThe configuration structure layout is shown below.\n\n\n-----\n\nInjecting malicious DLL to Notepad.exe\n\nThen, the malware will check if `InjectDLLToNotepadFlag` is set and `reverse_str(FileName)\n+ \".url\"` (mheX.url) file doesn't exist in C:\\Users\\<username>\\AppData\\Local\\`. If yes, it will\ninject malicious DLL into Notepad.exe using the following steps:\n\n1. Launch a Notepad.exe in the suspended state (dwCreationFlag =\n\nCREATE_SUSPENDED).\n2. Get the imported DLL name from the malicious DLL's import table (the first one is\n\n\"kernel32.dll\") and write to the suspended process.\n3. Write the following 12-byte structure containing addresses of kernel32: LoadLibrary,\n\nkernel32.sleep, and DLL string.\n\n\n-----\n\n4. Write a 210-bytes shellcode to Notepad.exe.\n\n5. Execute this shellcode in Notepad.exe using `CreateRemoteThread` and pass the\n\npointer to the 12-byte structure shown above. This shellcode loads the DLL\n(\"kernel32.dll\") and then goes into an infinite sleep loop.\n6. Write DLL (\"kernel32.dll\") string again to notepad.exe.\n7. Write the 20-byte structure to Notepad.exe containing pointers to important APIs and\n\ntwo strings: imported DLL name and imported API name.\n\n8.\n\nWrite 144 bytes of shellcode to Notepad.exe.\n\n9. Execute this shellcode in Notepad.exe using `CreateRemoteThread` and pass the\n\npointer to the 20-byte structure from step 7 as param. This shellcode will resolve the\nimport pointed by the last variable of the structure in step 7, and then exits using\n`RtlExistUserThread`.\n10. Repeat Steps 2 - 9 for all of the imported DLLs and imported functions in the malicious\n\nDLL's import table.\n11. Write malicious DLL to Notepad.exe.\n\n\n-----\n\n12. Write an eight-byte structure to Notepad.exe containing Malicious DLL base address\n\nand entry point.\n\n13. Write 122 bytes of shellcode to notepad.exe.\n\n14. Execute the shellcode in Notepad.exe using `CreateRemoteThread` by passing the\n\npointer to structure from step 12 as param. The shellcode calls the entry-point point of\nthe malicious DLL.\n\n**Injected DLL analysis (UAC bypass using two techniques)**\n\nIt checks if `C:\\Windows\\Finex` exists. If not, it will drop the following file at path\n`C:\\Users\\Public\\cde.bat`:\n\n\n-----\n\nThen, it drops C:\\Users\\Public\\x.bat containing the following content.\n\nThen, it drops C:\\Users\\Public\\x.vbs.\n\n\n-----\n\nThen it drops, C:\\Users\\Public\\Natso.bat.\n\n[Then, it executes `Natso.bat`, which is a \"fileless\" UAC bypass found by James Forshaw.](https://twitter.com/tiraniddo)\n[More details here.](https://www.tiraniddo.dev/2017/05/exploiting-environment-variables-in.html)\n\nIf C:\\Windows\\Finex still doesn't exist (which means the UAC bypass failed), it will update the\nNasto.bat and execute it using the code shown below.\n\n[This is another UAC bypass technique based on fodhelper exe More details here On our](https://gist.github.com/netbiosX/a114f8822eb20b115e33db55deee6692)\n\n\n-----\n\ntest machine, the last bypass was successful, and C:\\Windows\\Finex was successfully\ncreated. After that, the DLL deletes the dropped file and exits.\n\n### Decrypting and executing Lokibot\n\nAfter attempting to bypass the UAC, the third-stage DLL will check if `AutoRunKeyFlag` is\nset. For this DLL, it is not set. It will then jump to code that decrypts the Lokibot executable\nusing decryption keys from the configuration structure. The first two layers are decrypted\nusing `DecryptionKeyA` and `DecryptionKeyB`, and reverses all the data. After that, the final\nlayer is decrypted using the same decryption method used to decrypt resource data at the\nstart of the third stage.\n\nThe DLL contains multiple ways to execute a PE file. The execution method is decided\nbased on the values of ExecutionFlag A, B, C. Their values will lead to the following code for\nthe current configuration, which will decrypt the shellcode from the configuration using\nDecryptionKeyB, pass it three parameters: pointer to decrypted Lokibot .exe, a pointer to an\narray of string and a pointer to current command line.\n\n\n-----\n\nThe shellcode will create a suspended process using the third parameter as a command line\n[command and injects Lokibot into it using process hollowing.](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/analyzing-malware-hollow-processes/)\n\n## Conclusion\n\nThreat actors are getting more sophisticated when it comes to hiding their final payload. This\ndropper uses three stages and three layers of encryption to hide its final payload. The\ndropper also injects code into a suspended process to bypass UAC and uses process\nhollowing to execute its final payload. The majority of malware is getting more and more\nsophisticated. They are constantly improving their social engineering techniques to trick the\nuser into opening malicious attachments and running malicious code. The malware code and\nits infection techniques is also improving constantly like we have described in this blog The\n\n\n-----\n\nadversaries combine clever techniques to make detection harder. More than ever it is\nimportant to have a multi layered security architecture in place to detect these kinds of\nattacks. It isn't unlikely that the adversaries will manage to bypass one or the other security\nmeasures, but it is much harder for them to bypass all of them. These campaigns and the\nrefinement of the TTPs being used will likely continue for the foreseeable future.\n\n## Coverage\n\nWays our customers can detect and block this threat are listed below.\n\n**Advanced Malware Protection** [(AMP) is ideally suited to prevent the execution of the](https://www.cisco.com/c/en/us/products/security/advanced-malware-protection)\nmalware detailed in this post. Below is a screenshot showing how AMP can protect\ncustomers from this threat. Try AMP for free [here.](https://cisco.com/go/tryamp)\n\n**Cisco Cloud Web Security** [(CWS) or Web Security Appliance (WSA) web scanning](https://www.cisco.com/c/en/us/products/security/cloud-web-security/index.html)\nprevents access to malicious websites and detects malware used in these attacks.\n\nNetwork Security appliances such as Next-Generation Firewall [(NGFW), Next-Generation](https://www.cisco.com/c/en/us/products/security/firewalls/index.html)\n[Intrusion Prevention System (NGIPS), and](https://www.cisco.com/c/en/us/products/security/intrusion-prevention-system-ips/index.html) [Meraki MX can detect malicious activity](https://meraki.cisco.com/products/appliances)\nassociated with this threat.\n\n[Threat Grid helps identify malicious binaries and build protection into all Cisco Security](https://www.cisco.com/c/en/us/solutions/enterprise-networks/amp-threat-grid/index.html)\nproducts.\n\n[Umbrella, our secure internet gateway (SIG), blocks users from connecting to malicious](https://umbrella.cisco.com/)\ndomains, IPs, and URLs, whether users are on or off the corporate network.\n\nAdditional protections with context to your specific environment and threat data are available\nfrom the [Firepower Management Center.](https://www.cisco.com/c/en/us/products/security/firepower-management-center/index.html)\n\n\n-----\n\nOpen Source Snort Subscriber Rule Set customers can stay up to date by downloading the\n[latest rule pack available for purchase on Snort.org.The following SIDs have been released](https://www.snort.org/products)\nto detect this threat: 56578 and 56577.\n\n## IOC\n\n**Hashes**\n\nd5a68a111c359a22965206e7ac7d602d92789dd1aa3f0e0c8d89412fc84e24a5 (First stage\nXLS file)\n\n6b53ba14172f0094a00edfef96887aab01e8b1c49bdc6b1f34d7f2e32f88d172 (2nd stage\npacked downloader)\n\nb36d914ae8e43c6001483dfc206b08dd1b0fbc5299082ea2fba154df35e7d649 (2nd stage\nunpacked DLL)\n\n93ec3c23149c3d5245adf5d8a38c85e32cda24e23f8c4df2e19e1423739908b7 (3rd Stage\nDLL)\n\n21e23350b05a4b84cdf5c93044d780558e6baf81b2148fdda4583930ab7cb836 (DLL used to\nbypass UAC)\n\nc9038e31f798119d9e93e7eafbdd3e0f215e24ee2200fcd2a3ba460d549894ab ( Lokibot )\n\n**URL**\n\nhxxp://millsmiltinon[.]com/ojHYhkfkmofwendkfptktnbjgmfkgtdeitobregvdgetyhsk/Xehmigm.exe\n\n**Domains**\n\nmillsmiltinon.com (Hosts 2nd and 3rd Stage)\n\n**IP**\n\n104.223.143[.]132 (Lokibot C2)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-06 - A Deep Dive into Lokibot Infection Chain.pdf"
    ],
    "report_names": [
        "2021-01-06 - A Deep Dive into Lokibot Infection Chain.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536108,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1653754567,
    "ts_modification_date": 1653754567,
    "files": {
        "pdf": "https://archive.orkl.eu/fe6ed8264cc31296f7697d78276afaab8c16000c.pdf",
        "text": "https://archive.orkl.eu/fe6ed8264cc31296f7697d78276afaab8c16000c.txt",
        "img": "https://archive.orkl.eu/fe6ed8264cc31296f7697d78276afaab8c16000c.jpg"
    }
}