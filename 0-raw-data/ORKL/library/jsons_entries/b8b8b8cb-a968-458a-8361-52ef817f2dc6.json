{
    "id": "b8b8b8cb-a968-458a-8361-52ef817f2dc6",
    "created_at": "2023-01-12T15:00:40.707542Z",
    "updated_at": "2025-03-27T02:05:23.657746Z",
    "deleted_at": null,
    "sha1_hash": "f954bd752940a191a816e545f30965796756bc1f",
    "title": "2020-02-02 - Defeating Sodinokibi-REvil String-Obfuscation in Ghidra",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:21Z",
    "file_modification_date": "2022-05-29T01:19:21Z",
    "file_size": 152728,
    "plain_text": "# Defeating Sodinokibi/REvil String-Obfuscation in Ghidra\n\n**blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/**\n\nborn\n\nThis post describes the memory layout as well as the method used by the Sodinokibi (or REvil) ransomware to protect its strings. It will then list\na few Java snippets to interact with the Ghidra scripting API and finally explain a working script to deobfuscate all strings within a REvil\n[sample. If you don't care about the explaination, you can find the most recent version of the script you can simply import into Ghidra on github.](https://github.com/nullteilerfrei/reversing-class/blob/master/scripts/java/SodinokibiREvilStrings.java)\n## Some Thank-You Notes I'd like to thank the lovely people at OALabs to bring this sample to my attention once again! If you haven't notice,\n[definitly take a look at the automated unpacking service UnpacMe. They just relaesed it into Beta and it is working perfectly for me so far. You](https://www.unpac.me/)\n[can find a very expensive commercial for their unpacking service in the references of this blag post. Oh and that video also contains a full](https://www.youtube.com/watch?v=l2P5CMH9TE0&t=1m19s)\nanalysis of the string obfuscation in REvil including the same things I'm doing in this blog post but for IDA. A tip to the hat towards Thomas\nRoth, who almost certainly doesn't know me but published a lot of details about the Ghidra scripting API. And, last but not least, thanks to my\nbuddy [Jesko for figuring out Pcode traversal with me. ## Memory Layout The Sodinokibi (or REvil) ransomware leverages string obfuscation to](https://twitter.com/huettenhain)\nhinder analysis1. Like [all the other coolkids, we will use the sample with SHA256 hash](https://www.youtube.com/watch?v=l2P5CMH9TE0)\n```\n5f56d5748940e4039053f85978074bde16d64bd5ba97f6f0026ba8172cb29e93\n\n```\nas an example. In uses calls like the following to deobfuscated strings before usage:\n```\nFUN_00404e03(&DAT_0041c040, 0x256, 6, 8, local_14);\n\n```\nThe call involves five arguments: The first argument `DAT_0041c040 is the same for all calls and references a global buffer containing data`\nthat doesn't look like anything. The next argument `0x256 is an offset into that buffer and the next two arguments` `6 and` `8 are length`\nvalues. The fifth and last parameter `local_14 is a variable that will contain a deobfuscated string after the function returns. The two length`\nvalues specified lengths of a key buffer and of buffer containing encrypted data respectively. These two buffers are located consecutively\ndirectly after the specified offset in the referenced global buffer. ## Decryption Algorithm The malware uses the RC4 algorithm to decrypt the\nobfuscated string with the above-described key. As always, this algorithm can easily be identified by three consecutive loops where the first\nloop initializes the cells of an array of length 256 by their indices, the second references to key and the third references the encrypted data.\nThe following is a slightly annotated version Ghidra's decompiled output for the RC4 algorithm:\n```\ndo {\n  sbox[k] = (byte)k;\n  k = k + 1;\n} while (k < 0x100);\nk = 0\ndo {\n  Tmp = sbox[k];\n  i = Tmp + Key[k % KeyLength] + i & 0xff;\n  sbox[k] = sbox[i];\n  k = k + 1;\n  sbox[i] = Tmp;\n} while (k < 0x100);\n\n```\n[As always, I don't recommend reverse engineering the algorithm but instead guess that it is RC4 and then use Cyberchef, Python or](https://cyberchef.nullteilerfrei.de/) Binary\nRefinery to confirm your guess. For completeness, here is a BinRef pipeline for one of the calls:\n```\n> emit\n\"36423605a96002d7e5af770baecc2d2ec1a69b7e6b1e47a95f1fbb840b96ebb5d69fe1053e7f7266bb29215d5f8ec74406561b881b2509a1b2369796e8787ca9607\n | hex | rc4 \"H:485a8eeef3041ae753246740a753ff\" | recode utf-16 | peek\n43 Bytes, 50.29% entropy, ASCII text, with no line terminators\n------------------------------------------------------[PEEK]-Global\\206D87E0-0E60-DF25-DD8F-8E4E7D1E3BF0\n-------------------------------------------------------------\n```\n## Scripting Snippets In this section, I will share a few useful snippets when using Java to write scripts for Ghidra for malware reverse\nengineering. The first one is a helper function that accepts a function name, assumes there is only one function with that name and returns a\nlist of addresses where this function is called. We will also use the `getOriginalBytes function from a` [previous blag post.](https://blag.nullteilerfrei.de/2020/02/02/ghidra-scripts-in-java-a-snippet-to-getoriginalbytes/)\n```\n     private List<Address> getCallAddresses(Function deobfuscator) {\n          List<Address> addresses = new ArrayList<Address>();\n          for (Reference ref : getReferencesTo(deobfuscator.getEntryPoint())) {\n              if (ref.getReferenceType() != RefType.UNCONDITIONAL_CALL)\n                   continue;\n              addresses.add(ref.getFromAddress());\n          }\n          return addresses;\n     }\n\n```\nThe function `setComment will set a comment in both the disassembly view and the decompiled view:`\n\n\n-----\n\n```\n     setPlateComentToDisassembly(address, comment);\n     setCommentToDecompiledCode(address, comment);\n}\nprivate void setPlateComentToDisassembly(Address address, String comment) {\n     currentProgram.getListing().getCodeUnitAt(address).setComment(CodeUnit.PLATE_COMMENT, comment);\n}\nprivate void setCommentToDecompiledCode(Address address, String comment) {\n     currentProgram.getListing().getCodeUnitAt(address).setComment(CodeUnit.PRE_COMMENT, comment);\n}\n\n```\nFinally, the following function is my Q&D approach to convert a byte array to an ASCII string (even if it is a wide string). A more experienced\nJava developer may be able to implement it in a more beautiful way, but that's simply not me.\n```\nprivate String AsciiDammit(byte[] data, int len) {\n     boolean isWide = true;\n     byte[] nonWide = new byte[len / 2];\n     for (int i = 0; i < len / 2; i++) {\n          if (data[i * 2 + 1] != '\\0') {\n              isWide = false;\n              break;\n          }\n          nonWide[i] = data[i * 2];\n     }\n     return new String(isWide ? nonWide : data);\n}\n\n```\n## Function Arguments As described in the \"Layout\" section above, we will need to get the values passed to a function call. This is a bit more\ninvolved: the `getConstantCallArgument function below accepts a memory address of a function call and a list of integers in the variable`\n```\nargumentIndices . These integers should specify the indices of function arguments the caller wants the value of (starting with 1). The\n\n```\nfunction will return an array of optional longs: it has the same length as `argumentIndices and contains the determined value if possible. To`\ndetermine the value, `getConstantCallArgument decompiles the function that contains the call ( caller in the Java code), retrieves a so-`\ncalled \"high-level function structure\" via `getHighFunction and then uses the function` `traceVarnodeValue to retrieve the values of the`\nrequested parameters. This `traceVarnodeValue function is an incomplete implementation of a Pcode traversal. In at least two samples, it`\nworked though, so I still think it is worth sharing.\n\n\n-----\n\n```\n     public UnknownVariableCopy(PcodeOp unknownCode, Address addr) {\n          super(String.format(\"unknown opcode %s for variable copy at %08X\", unknownCode.getMnemonic(), addr.getOffset()));\n     }\n}\nprivate OptionalLong[] getConstantCallArgument(Address addr, int[] argumentIndices) throws IllegalStateException,\nUnknownVariableCopy {\n     int argumentPos = 0;\n     OptionalLong argumentValues[] = new OptionalLong[argumentIndices.length];\n     Function caller = getFunctionBefore(addr);\n     if (caller == null)\n          throw new IllegalStateException();\n     DecompInterface decompInterface = new DecompInterface();\n     decompInterface.openProgram(currentProgram);\n     DecompileResults decompileResults = decompInterface.decompileFunction(caller, 120, monitor);\n     if (!decompileResults.decompileCompleted())\n          throw new IllegalStateException();\n     HighFunction highFunction = decompileResults.getHighFunction();\n     Iterator<PcodeOpAST> pCodes = highFunction.getPcodeOps(addr);\n     while (pCodes.hasNext()) {\n          PcodeOpAST instruction = pCodes.next();\n          if (instruction.getOpcode() == PcodeOp.CALL) {\n              for (int index : argumentIndices) {\n                   argumentValues[argumentPos] = traceVarnodeValue(instruction.getInput(index));\n                   argumentPos++;\n              }\n          }\n     }\n     return argumentValues;\n}\nprivate OptionalLong traceVarnodeValue(Varnode argument) throws UnknownVariableCopy {\n     while (!argument.isConstant()) {\n          PcodeOp ins = argument.getDef();\n          if (ins == null)\n              break;\n          switch (ins.getOpcode()) {\n          case PcodeOp.CAST:\n          case PcodeOp.COPY:\n              argument = ins.getInput(0);\n              break;\n          case PcodeOp.PTRSUB:\n          case PcodeOp.PTRADD:\n              argument = ins.getInput(1);\n              break;\n          case PcodeOp.INT_MULT:\n          case PcodeOp.MULTIEQUAL:\n              // known cases where an array is indexed\n              return OptionalLong.empty();\n          default:\n              // don't know how to handle this yet.\n              throw new UnknownVariableCopy(ins, argument.getAddress());\n          }\n     }\n     return OptionalLong.of(argument.getOffset());\n}\n\n```\n## Automated Deobfuscation Equipped with ways to retrieve all calls to a specific function, get values of parameters to this calls and also be\nable to add annotations to Ghidra, we are only missing the actual deobfuscation function. As described above in the \"Decryption\" section, it is\nRC4. Instead of doing it the enterprise way2, we will use a [random implementation by some guy on github. I even found myself an excuse for](https://gist.github.com/vbevans94/8182647)\nthis: If one, at some point in the future, encounters a modified version of RC4, it is easily possible to do similar modifications in the code. So\nputting all the pieces together, we end up with the following `run method, which I will explain a bit below:`\n\n\n-----\n\n```\n     String deobfuscatorName;\n     try {\n          deobfuscatorName = askString(\"Enter Name\", \"Enter the name of the deobfuscation function below:\",\ngetFunctionBefore(currentAddress.next()).getName());\n     } catch (CancelledException X) {\n          return;\n     }\n    Function deobfuscator = getGlobalFunctions(deobfuscatorName).get(0);\n     OUTER_LOOP: for (Address callAddr : getCallAddresses(deobfuscator)) {\n          monitor.setMessage(String.format(\"parsing call at %08X\", callAddr.getOffset()));\n          int arguments[] = { 1, 2, 3, 4 };\n          OptionalLong options[] = getConstantCallArgument(callAddr, arguments);\n          for (OptionalLong option : options) {\n              if (option.isEmpty()) {\n                   println(String.format(\"Argument to call at %08X is not a constant string.\", callAddr.getOffset()));\n                   continue OUTER_LOOP;\n              }\n          }\n          long blobAddress = options[0].getAsLong();\n          int keyOffset = (int) options[1].getAsLong();\n          int keyLength = (int) options[2].getAsLong();\n          int dataLength = (int) options[3].getAsLong();\n          if (dataLength == 0 || keyLength == 0)\n              continue;\n          byte[] key = getOriginalBytes(toAddr(blobAddress + keyOffset), keyLength);\n          byte[] data = getOriginalBytes(toAddr(blobAddress + keyOffset + keyLength), dataLength);\n          byte[] decrypted = new RC4(key).encrypt(data);\n          String deobfuscated = AsciiDammit(decrypted, dataLength);\n          println(String.format(\"%08X : %s\", callAddr.getOffset(), deobfuscated));\n          setComment(callAddr, String.format(\"Deobfuscated: %s\", deobfuscated));\n          createBookmark(callAddr, \"DeobfuscatedString\", deobfuscated);\n     }\n}\n\n```\nThe function first asks the user for a function name. It pre-populates the field with the currently selected function or, if the script was called\nbefore, with the previous input. Even though simple, this feels surprisingly good from a user experience (UX) perspective. The function then\niterates over all calls to this deobfuscation function and retrieves values for arguments 1-4. If all of them are set, they are assigned to the\nfollowing variables: * `blobAddress reference to the address of the blob of encrypted data in the malware *` `keyOffset offset into that blob *`\n```\nkeyLength length of the key buffer starting at the offset into the blob * dataLength length of the data buffer starting directly after the key\n\n```\nbuffer The function then retrieves the key and the encrypted data and uses the `RC4 class to deobfuscate it. The result is then passed to the`\n```\nAsciiDammit function, which will also take care of decoding wide-strings. It then prints the address of the call and the deobfuscated string to\n\n```\nthe console, sets a comment in the disassembly and the decompile views and, creates a bookmark to the call, so we can easily look at a list of\nall deobfuscated strings enabling buttom-up analysis. The [full script without explanation can be found on github. ## Decrypted strings For](https://github.com/nullteilerfrei/reversing-class/blob/master/scripts/java/SodinokibiREvilStrings.java)\ngoogle-ability, here is a list of all deobfuscated strings in the analysed sample: | Address | Deobfuscated String |--- |--- | `0x00401B2F |` `exp |`\n```\n0x0040151E | pk | 0x00401538 | pid | 0x00401552 | sub | 0x0040156C | dbg | 0x00401589 | wht | 0x004015A4 | wfld |\n0x004015BF | wipe | 0x004015D9 | prc | 0x004015F6 | dmn | 0x00401610 | net | 0x0040162B | nbody | 0x00401646 |\nnname | 0x00401664 | img | 0x0040167B | fast | 0x00401838 | none | 0x00401851 | true | 0x0040186D | false |\n0x004019BE | -nolan | 0x00401B9C | SOFTWARE\\recfg | 0x00401BB5 | rnd_ext | 0x00401EA7 | {UID} | 0x00401EC0 | {KEY} |\n0x00401ED9 | {EXT} | 0x00401EF5 | {USERNAME} | 0x00401F14 | {NOTENAME} | 0x00401F30 | SYSTEM | 0x00401F46 | USER |\n0x00401CCF | SOFTWARE\\recfg | 0x00401CE8 | stat | 0x00401D71 |\n{\"ver\":%d,\"pid\":\"%s\",\"sub\":\"%s\",\"pk\":\"%s\",\"uid\":\"%s\",\"sk\":\"%s\",\"unm\":\"%s\",\"net\":\"%s\",\"grp\":\"%s\",\"lng\":\"%s\",\"bro\":%s,\"os\n\"dsk\":\"%s\",\"ext\":\"%s\"} | 0x00401FF4 | .lock | 0x004020D1 | {UID} | 0x004020EA | {KEY} | 0x00402103 | {EXT} |\n0x00402184 | {EXT} | 0x00402216 | SOFTWARE\\recfg | 0x00402232 | sub_key | 0x0040224B | pk_key | 0x00402264 | sk_key\n\n```\n| `0x00402280 |` `0_key |` `0x00403933 |` `.bmp |` `0x00403E5F |` `cmd.exe |` `0x00403E7E |` `/c vssadmin.exe Delete Shadows /All`\n```\n/Quiet & bcdedit /set {default} recoveryenabled No & bcdedit /set {default} bootstatuspolicy ignoreallfailures |\n0x00404085 | SYSTEM\\CurrentControlSet\\services\\Tcpip\\Parameters | 0x0040409E | Domain | 0x004040FA | WORKGROUP |\n0x00404199 | Control Panel\\International | 0x004041B2 | LocaleName | 0x004042A6 | %08X%08X | 0x0040432F |\nSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion | 0x00404348 | productName | 0x004043E0 | explorer.exe | 0x004048B5 |\nGlobal\\206D87E0-0E60-DF25-DD8F-8E4E7D1E3BF0 | 0x00404BF9 | runas | 0x004058B3 | qJiQmi65SC9GfVbj | 0x0040660D | \\\\?\n\\A:\\ | 0x00406547 | \\\\?\\UNC | 0x00405C02 | CreateStreamOnHGlobal | 0x00405D3B | ole32.dll | 0x00406B6A |\nwin32kfull.sys | 0x00406B83 | win32k.sys | 0x004012A0 | fld | 0x004012B7 | fls | 0x004012CE | ext | 0x004030B7 |\nhttps:// | 0x004030F7 | wp-content | 0x0040311B | static | 0x00403140 | content | 0x00403162 | include | 0x00403185\n\n```\n| `uploads |` `0x004031A4 |` `news |` `0x004031C0 |` `data |` `0x004031DF |` `admin |` `0x00403264 |` `images |` `0x00403287 |` `pictures`\n| `0x004032AA |` `image |` `0x004032CC |` `temp |` `0x004032E8 |` `tmp |` `0x00403308 |` `graphic |` `0x00403327 |` `assets |`\n```\n0x00403345 | pics | 0x00403360 | game | 0x00403441 | jpg | 0x00403457 | png | 0x00403470 | gif | 0x00406849 |\nMozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0 | 0x00406919 | POST | 0x0040697E | ContentType: application/octet-stream\\nConnection: close | 0x004027BC | program files | 0x004027D5 | program files (x86) |\n0x0040281F | sql | 0x00405C40 | advapi32.dll | 0x00405C79 | crypt32.dll | 0x00405CB2 | gdi32.dll | 0x00405CF6 |\n\n```\n\n-----\n\n`p` `d` | 0 00 05 `0 | s e` `3` `d` | 0 00 05 59 | s `ap` `d` | 0 00 05 9 | use 3 `d` | 0 00 05 C | `ttp d` |\n\n`0x00406004 |` `winmm.dll ## References *` [OALabs - IDA Pro Automated String Decryption For REvil Ransomware *](https://www.youtube.com/watch?v=l2P5CMH9TE0) Python Scripting\nCheat Sheet by Thomas Roth\n\n1. more precisely: to slow down a bottom-up approach starting with interesting strings [↩]\n2. by calling `Cipher.getInstance(\"RC4\"); I guess [↩]`\n\nTags: [reverse engineering](https://blag.nullteilerfrei.de/tag/reverse-engineering/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-02 - Defeating Sodinokibi-REvil String-Obfuscation in Ghidra.pdf"
    ],
    "report_names": [
        "2020-02-02 - Defeating Sodinokibi-REvil String-Obfuscation in Ghidra.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535640,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653787161,
    "ts_modification_date": 1653787161,
    "files": {
        "pdf": "https://archive.orkl.eu/f954bd752940a191a816e545f30965796756bc1f.pdf",
        "text": "https://archive.orkl.eu/f954bd752940a191a816e545f30965796756bc1f.txt",
        "img": "https://archive.orkl.eu/f954bd752940a191a816e545f30965796756bc1f.jpg"
    }
}