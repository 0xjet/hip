{
    "id": "93b0045d-c289-4698-8a23-b1327e6762ce",
    "created_at": "2023-05-06T02:08:58.46538Z",
    "updated_at": "2025-03-27T02:05:19.004073Z",
    "deleted_at": null,
    "sha1_hash": "40ec5c6cd98f1a4c15cfdd300819bba8d55bf90e",
    "title": "2015-05-22 - The DGA of Ranbyus",
    "authors": "",
    "file_creation_date": "2023-05-05T01:55:08Z",
    "file_modification_date": "2023-05-05T01:55:08Z",
    "file_size": 455571,
    "plain_text": "# The DGA of Ranbyus\n\n**bin.re/blog/the-dga-of-ranbyus/**\n\nRanbyus is a trojan that steals banking information — among other personal data. End of\nApril 2015 I first noticed samples of Ranbyus that use a Domain Generation Algorithm (DGA)\nto generate the domains for its command and control (C2) traffic:\n```\nhcfoopojnuqxho.su \nundrdsbhivryqn.tw \ndkehliueofdued.net \nmpuakxjqpscfpj.com \neelolbwmfmtkae.pw \nnoppsmyiijqujh.in \njoxrsxwdybbgqb.me \n(...)\n\n\n```\nIn this post I show how the DGA works by reversing the following sample:\n\n**filename**\n\n\n-----\n\n```\n_RANDOMNUM_6_11__vozvrat.exe\n\n```\n**filetype**\nPE32 executable (GUI) Intel 80386, for MS Windows\n\n**md5**\nfa57f601402aab8168dea94c7c5f029f\n\n**sha256**\ndc4f3340ca8e623a5a77eb95411696fc25a7e6f5ef657ac9fd76eb4bc11c16b4\n\n**malwr**\n[link](https://malwr.com/analysis/NDY5NzFhNjUxMzA3NDExYjlhMzhjYzEyN2IyNDM5ZTQ/)\n\nI focused my efforts exclusively on the domain generation part of Ranbyus. Refer to the blog\n[posts of Aleksandr Matrosov here and](http://www.welivesecurity.com/2012/06/05/smartcard-vulnerabilities-in-modern-banking-malware/) [here for an in-depth analysis of Ranbyus.](http://www.welivesecurity.com/2012/12/19/win32spy-ranbyus-modifying-java-code-in-rbs/)\n\n## Algorithm\n\nThis section shows the algorithm behind the domains of Ranbyus and its seeding and\nparametrization.\n\n### Callback Loop\n\nThe next image represents the part of the Ranbyus that tries to find a valid C2 target. It\nconsists of an outer loop (month_loop) and an inner loop. The register edi holds the index of\nthe outer loop. It runs from 0 down to -30. The number of iterations for the inner loop is\nspecified by a parameter of the DGA (set to 40 in all analysed samples):\n\n\n-----\n\nThe first act of the outer loop is to get the current time:\n\n\n-----\n\nRanbyus then subtracts days from the current date according to the index of the outer loop:\n\n\n-----\n\nThe resulting date will be used to seed the DGA with a granularity of one day. In the first\niteration, the DGA uses the current date. In the next iteration — when the index is -1 —\nyesterday’s date is used. This continues up to 30 days in the past if need be. So even though\nthe DGA generates a fresh set of domains every day, it also checks the domains of past\ndays. This gives the DGA the benefit of fast changing domains in case domains get blocked\nor sinkholed, while at the same time enabling older domains to be used for up to one month\nif they still work.\n\nThe inner loop generates the domains for the day with the_dga and makes the callback. In\ncase of failure, Ranbyus sleeps for wait_time milliseconds (500 in my samples) and retries\nup to nr_of_domains (40) different domains.\n\n### DGA Parameters and Seed\n\nApart from the current date, the DGA is seeded with a hardcoded magic number:\n\n\n-----\n\nThe number of domains per day is hardcoded to 40:\n\nThe wait time after a failed callback attempt is set to 500 ms:\n\nRanbyus also uses a hard-coded list of top level domains:\n\nThe top level domains are: .in, .me, .cc, .su, .tw, .net, .com, .pw, and .org. The last domain\n_.org is never used due to a bug of the DGA. The top level domains are tested one after_\nanother (except the last one), starting at a day-dependent offset:\n\nThe error of subtracting 1 from the modulus is repeated also when picking the letters of the\nsecond level domain.\n\n### The DGA\n\nThis is the disassembly of the DGA routine:\n\n\n-----\n\nThe subroutine generates domains in two independent parts:\n\n1. the top level domain is picked from the hardcoded list shown above\n2. the second level domain is generated.\n\nThe following disassembly shows how the top level domain is picked:\n\n\n-----\n\nStarting at the day dependent offset determined earlier, the algorithm picks the domains in a\ncircular fashion, omitting the last domain because the DGA wrongly subtracts one from the\nmodulus.\n```\n[\".in\", \".me\", \".cc\", \".su\", \".tw\", \".net\", \".com\", \".pw\", \".org\"][offset % (9-1)]\n\noffset++\n\n\n```\nThe disassembly for the second level domain looks as follows. It generates 14 different\nletters based on the DGA’s seed, and the value of day, month and year. Note that these\nnames are misleading: although theses values are initialized with the current or past dates,\nthe values are modified by each call to the routine.\n\n\n-----\n\n-----\n\nThis pseudo-code summarizes the algorithm:\n```\nFOR i = 0 TO 13\n\n  day = (day >> 15) ^ 16 * (day & 0x1FFF ^ 4 * (seed ^ day))\n\n  year = ((year & 0xFFFFFFF0) << 17) ^ ((year ^ (7 * year)) >> 11)\n\n  month = 14 * (month & 0xFFFFFFFE) ^ ((month ^ (4 * month)) >> 8)\n\n  seed = (seed >> 6) ^ ((day + 8 * seed) << 8) & 0x3FFFF00\n\n  int x = ((day ^ month ^ year) % 25) + 'a'\n\n  domain[i] = x;\n\n\n```\nThe malware authors repeated their modulus error: like for the tld, the modulus needed to be\nincreased by one. As it stands, ‘z’ is no reachable. Ranbyus shares this bug with the DGAs\nof [Ramnig and](https://bin.re/blog/the-dga-of-ramnit/) [Necurs.](https://bin.re/blog/the-dgas-of-necurs/)\n\nSeed the end of this blog post for a C-implementation of the DGA.\n\n## Observed Seeds\n\nThe following tables lists some of the samples from malwr.com that are Ranbyus with the\ndescribed DGA. All samples use the same parametrization, only the seed varies.\n\n**md5** **seed**\n\n4b04f6baaf967e9c534e962c98496497 65BA0743\n\n087b19ce441295207052a610d1435b03 65BA0743\n\n\n-----\n\n**md5** **seed**\n\n28474761f28538a05453375635a53982 65BA0743\n\nb309eab0277af32d7a344b8a8b91bd73 C5F128F3\n\n4c7057ce783b2e4fb5d1662a5cb1312a C5F128F3\n\nb309eab0277af32d7a344b8a8b91bd73 C5F128F3\n\n7cbc671bcb97122e0ec5b448f0251dc0 C5F128F3\n\n437028f94ceea4cab0d302d9ac6973eb C5F128F3\n\nb309eab0277af32d7a344b8a8b91bd73 C5F128F3\n\n6378b7af643e87c063f69ddfb498d852 B6354BC3\n\nfa57f601402aab8168dea94c7c5f029f B6354BC3\n\n9f2c89ad17e9b6cf386028a8c9189264 0478620C\n\n## Summary\n\n### DGA Characteristics\n\nThe characteristics of Ranbyus’ DGA are:\n\n**property** **value**\n\nseed magic number and current date\n\ngranularity 1 day, with a 31 day sliding window\n\ndomains per seed and day 40\n\ndomains per sliding window 1240\n\nsequence sequential\n\nwait time between domains 500 ms\n\ntop level domains .in, .me, .cc, .su, .tw, .net, .com, .pw\n\nsecond level characters lower case letters except ‘z’\n\nsecond level domain length 14 letters\n\n### Decompiled Code\n\n\n-----\n\nThe following C code generates the domains for a given day and seed. In order to generate\nall domains that the malware can generate for any given seed and date, one would also\nneed to run the code for all dates going 30 days in the past.\n\n**Edit 23.5.2015: The following code had contained a bug that led to a wrong sequence of top**\nlevel domains, thanks to Anthony Kasza for sharing that with me.\n```\n#include <stdio.h>\n\n#include <stdlib.h>\n\nchar* dga(unsigned int day, unsigned int month, unsigned int year,\n\n    unsigned int seed, unsigned int nr)\n\n{\n\n  char *tlds[] = {\"in\", \"me\", \"cc\", \"su\", \"tw\", \"net\", \"com\", \"pw\", \"org\"};\n\n  char domain[15];\n\n  int d;\n\n  int tld_index = day;\n\n  for(d = 0; d < nr; d++)\n\n  {\n\n    unsigned int i;\n\n    for(i = 0; i < 14; i++)\n\n    {\n\n      day = (day >> 15) ^ 16 * (day & 0x1FFF ^ 4 * (seed ^ day));\n\n      year = ((year & 0xFFFFFFF0) << 17) ^ ((year ^ (7 * year)) >> 11);\n\n      month = 14 * (month & 0xFFFFFFFE) ^ ((month ^ (4 * month)) >> 8);\n\n      seed = (seed >> 6) ^ ((day + 8 * seed) << 8) & 0x3FFFF00;\n\n      int x = ((day ^ month ^ year) % 25) + 97;\n\n      domain[i] = x;\n\n    }\n\n    printf(\"%s.%s\\n\", domain, tlds[tld_index++ % 8]);\n\n  }\n\n}\n\nmain (int argc, char *argv[])\n\n{\n\n  if(argc != 5) {\n\n    printf(\"Usage: dga <day> <month> <year> <seed>\\n\");\n\n    printf(\"Example: dga 14 5 2015 b6354bc3\\n\");\n\n    exit(0);\n\n  }\n\n  dga(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]),\n\n      strtoul(argv[4], NULL, 16), 40);\n\n}\n\n\n## Archived Comments\n\n```\n**_Note: I removed the Disqus integration in an effort to cut down on bloat. The following_**\n_comments were retrieved with the export functionality of Disqus. If you have comments,_\n_please reach out to me by Twitter or email._\n\n\n-----\n\nSandor Nemes Aug 26, 2015 07:42:01 UTC\nIn the C code the strtoul function should be used instead as strtol will limit the seed to\n0x7fffffff.\n\n[Johannes Bader Aug 26, 2015 09:36:08 UTC](https://disqus.com/by/baderj/)\nThanks, fixed it.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-05-22 - The DGA of Ranbyus.pdf"
    ],
    "report_names": [
        "2015-05-22 - The DGA of Ranbyus.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1683338938,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1683251708,
    "ts_modification_date": 1683251708,
    "files": {
        "pdf": "https://archive.orkl.eu/40ec5c6cd98f1a4c15cfdd300819bba8d55bf90e.pdf",
        "text": "https://archive.orkl.eu/40ec5c6cd98f1a4c15cfdd300819bba8d55bf90e.txt",
        "img": "https://archive.orkl.eu/40ec5c6cd98f1a4c15cfdd300819bba8d55bf90e.jpg"
    }
}