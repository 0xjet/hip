{
    "id": "f216c975-1e15-41fb-8ef9-e948c9207af0",
    "created_at": "2023-01-12T15:10:10.513356Z",
    "updated_at": "2025-03-27T02:08:40.661426Z",
    "deleted_at": null,
    "sha1_hash": "b28d75659a5e83750528147db2d3b2edb1a02ceb",
    "title": "2019-03-13 - Analysing ISFB - The First Loader",
    "authors": "",
    "file_creation_date": "2022-05-25T14:14:22Z",
    "file_modification_date": "2022-05-25T14:14:22Z",
    "file_size": 12092348,
    "plain_text": "# Analysing ISFB – The First Loader\n\n**[0ffset.net/reverse-engineering/malware-analysis/analysing-isfb-loader](https://www.0ffset.net/reverse-engineering/malware-analysis/analysing-isfb-loader/)**\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n13th March 2019\n2 Comments\n\n\n13 March 2019\n\n\nI’m finally getting round to writing this post – for the past few months I have been analysing\ndifferent versions of ISFB/Ursnif/Gozi to gain a deeper understanding in the functionality\nof this specific malware. In this post, I will be detailing how to unpack and then analyse the\nfirst stage loader executable, and then use that information to extract the second stage\nloader DLL, known as rpcrt4.dll, which we will analyse in a later post.\n\nIn a nutshell, ISFB is a banking trojan used to steal financial information from unsuspecting\nvictims. It utilizes several methods to do so, from stealing saved passwords to injecting\nJavaScript into predetermined websites. This specific sample of ISFB is version 2.14.60, and\ncan be attributed to a specific ISFB v2 group based on the infection routine used –\nspecifically the macros that execute a powershell command that is simply Base64 encoded.\nThe group behind this sample also reuse the encryption key for different campaigns (the\ndefault key), making their samples easily identifiable compared to other large groups\nutilizing ISFB. I have been unable to locate specific threat actor names, and as a result, I will\n[be referring to this group as Group 53, based off of this presentation by FireEye.](https://www.botconf.eu/wp-content/uploads/2018/12/2018-J-Wyke-Tracking-actors-through-their-webinjects-.pdf)\n\nSimilarly to other groups utilizing ISFB for financial gain or simply as a stager, Group 53\ngains a foothold on the target’s system using a malicious Word document containing\nembedded macros, which in turn lead to the execution of a Powershell script responsible for\ndownloading the first stage executable. Certain groups “partner” with other groups that are\n\n\n-----\n\nable to distribute malicious spam (malspam) on a large scale, such as the group behind\nHancitor. This could potentially result in larger infection numbers, compared to those\ngroups that are relying on their own distribution methods. I would assume “renting” a spot\nfrom the group behind Hancitor would be quite expensive as a result of its enormous\noutreach, which is why a lot of groups, including Group 53, have to distribute their own\nmalicious documents. I will be focusing on the unpacker executable and the first stage\nexecutable loader in this post, rather than the Word Document itself, as its functionality is\n[quite straightforward. As always, the samples have been uploaded to VirusBay. So, let’s](https://beta.virusbay.io/)\ncrack it open!\n\n**But, before I do I’d like to thank all of the people who helped me out in analysing the**\n[different samples of ISFB, including @VK_Intel,](https://twitter.com/VK_Intel) **[@Nazywam, and](https://twitter.com/nazywam)** **[@Maciekkotowicz](https://twitter.com/maciekkotowicz)**\n(for his great papers on ISFB). Anyway, let’s get on with the reversing!\n\n**Part 1: Unpacking the first stage executable**\n```\nMD5 of First Stage Executable: bc72604061732a9280edbe5e2c1db33b\n\n```\nTypically I would open it up in PEStudio or perhaps perform some static analysis, however\nat this point I have already determined that it is highly likely to be a sample of ISFB, based\non the Word Macro, although we still want to unpack the first EXE to be 100% sure that it is\nin fact ISFB. First, let’s open it in IDA to try and find a call (or jmp) to a memory region or\nregister – this could possibly be a call to the unpacked stage.\n\nIt definitely looks like there is some unpacking going on here (based on the length and\nintricate flow shown in the image above), and upon looking at the strings in the binary we\ncan see that there aren’t many that are legible, or meaningful. Normally when unpacking a\n\n\n-----\n\nsample, I start at the bottom and work my way up – most unpackers exit once the file has\nbeen unpacked – although this depends. In this case, the unpacker performs Self**Injection, and overwrites itself with the unpacked file. This is not unusual for ISFB, and if**\nyou analyse some other samples (even from other groups), you will most likely find this\noccurring too. This means that the unpacker does not exit until the unpacked file does,\nalthough we can assume that the last function called will transfer execution over to the\nunpacked executable.\n\nIn this specific file, there is no call or jmp to a register or memory region – however, there is\na call to loc_42A880. It’s the last call in WinMain, so as mentioned before, this function is\nmost likely responsible for transferring execution over to the EXE.\n\nWhen we jump into this function, it is clear that it hasn’t been converted to a function yet,\nand so we are unable to view it as a graph. Sometimes, you are able to turn it into a function\nby pressing “P”, although it doesn’t seem to work in this case. So, we will have to deal with\nthe text mode. It is definitely possible to follow the jumps and conditional jumps to try and\nfind the call or jump to our executable, but we can speed this up a bit. Locate a call\ninstruction and click it – this should highlight the instruction and other instances of it. This\ndoesn’t work for every sample, but it is worth a try to speed things up. Simply scroll down or\nup from where you are, looking for other instances of call. The last call I located took\n**lpAddress as the first argument, so let’s take a look at this. lpAddress indicates that it**\ncontains an address to a region of memory, meaning it could contain the address of our\nunpacked executable.\n\n\n-----\n\nInside this function, if we jump straight to the end, we can see a call to ESI. Hit space to\njump from the Graph view back to Text view in order to get the address of this call. This\ncould be the call to our unpacked EXE, and so we need the address of it to view it in x32dbg\nand put a breakpoint on it.\n\nSo the memory address to this call is 0x0042A653, so let’s now open this up in x32dbg\nand jump to this address. Simply push CTRL-G in x32dbg and type in 0042A653, and then\nhit enter – this will jump to that address, allowing you to put a breakpoint on it. Whilst\n\n\n-----\n\nattempting to unpack a sample, I prefer to open up Process Hacker alongside it, so that if I\nput a breakpoint on the wrong address and the unpacked process executes, I can easily\ndetect it, either through the Network tab or through the Processes tab.\n\nOnce the breakpoint has been hit, step into ESI and in this sample there is what seems to be\na second unpacking “stage” – this code was not here originally, in fact if we try and view it in\nIDA, you will simply see a lot of question marks and the variable unk_58FC08.\n\n\n-----\n\nAs it is difficult to statically analyse this section without dumping it and opening it up in\nIDA, I will be jumping over functions, rather than stepping through them manually. This\nwill also help to speed things up, but make sure your network adapter is not attached, as one\nof these functions may execute the executable.\n\nIn the GIF below, you can see there is some form of loop going on, with XOR being used to\nXOR a byte at the memory address stored in EAX, with the value in DL. You might also\nnotice that the assembly is changing as each loop goes on – this is another example of the\nsecond unpacking stage. We can simply put a breakpoint on the jmp and then run the\nprogram until it hits it.\n\nOnce we follow the jump, we are met with several calls to [ebx+xxxxxx]. Each of these\ncould jump to the unpacked EXE, however as we progress further on, it is clear that these\nare simply calls to Windows API functions. Notice the call to EDI? EDI is pointing to a\nfunction that dynamically imports these APIs so that they can be called by the unpacking\nstub. The result is stored in EAX, and as seen in the image below, this specific call imported\nthe API RtlExitUserThread.\n\n\n-----\n\nScrolling down a bit, we can see a jmp eax, so let’s put a breakpoint on that and run to it,\nand then follow the jump.\n\nThis jump takes us to a newly allocated region of memory, with more code. I didn’t want to\nexamine each function, so I scrolled down until the ret instruction, and started examining\nthe (local – not API calls) functions backwards. The last function did not seem likely to be\nthe executable “executor”, as there was no call or jump instruction to a different region of\nmemory, however the second last function had some calls to [ebp+14] and [ebp+C], so\nlet’s put a few breakpoints on those.\n\n\n-----\n\nHowever, upon executing the program and hitting the breakpoint, it is clear that they are\nsimply calling LoadLibrary and GetProcAddress.\n\n\n-----\n\nTherefore, we can simply return from this function, as it is just importing API’s, which isn’t\nextremely important to us yet. After exiting the function, there are several calls to API’s, in\nparticular VirtualProtect. VirtualProtect is responsible for changing the\npermissions/protection of different memory regions, so that they are readable, writable, or\nexecutable (can be one, two, or all three). In this case, we can see that VirtualProtect is\nbeing used to change the protection of the memory region at 0x00406000, which is the\n**.BSS section. As I mentioned before, this unpacker overwrites itself with the unpacked**\nexecutable, so it is safe to say that we are extremely close to the unpacked EXE. We could\ndump it now, but there could be some extra unpacking going on, so let’s wait until we jump\nto the 0x00400000 memory region.\n\n\n-----\n\nAt this point, there isn t much going on in the function, so we can simply put a breakpoint\non the ret instruction and return from this function.\n\nUpon exiting the function, you’ll notice the memory address is in the 0x00401000 region.\nThis is the unpacked program! Now we can dump it out, so make sure you have Process\nHacker open, although you can dump it from x32dbg.\n\nTo dump it from memory, simply double click the process in Process Hacker, and right click\nthe 0x400000 region of memory, and select Save.\n\n\n-----\n\nNow we can open it up in PEBear and unmap the dumped file. Upon doing so, you can see\nthat the imports have not been successfully resolved by PEBear. This is why we need to\nunmap the file. When a program is about to be executed, it needs to be mapped in memory,\nso that it can be interpreted correctly. Therefore, PEBear is unable to resolve the imports\nuntil we unmap it.\n\nTo do so, we simply change the Raw Addr. so that it matches the Virtual Addr., and then\nchange the Raw Size accordingly. This should result in something looking like the image\nbelow.\n\n\n-----\n\nWe can check the imports and sure enough, there are 4 imported DLL’s, meaning we have\nthe correctly unmapped file. We can now save this to the desktop and congratulations! You\nhave now successfully unpacked the first stage! Let’s open it up in IDA for further analysis!\n\n**Part 2: Analysing the Dumped Executable**\n```\nMD5 of Dumped Executable: 0063316975e55c765cd12e3d91820478\n\n```\nUpon opening the file in IDA, we can see that the main function only calls one local function\nand then exits, so it’s not too difficult to find the malicious code. If you’re not sure if a\ncertain sample is ISFB or not, one telltale sign can be found in the strings window. Most, if\n\n\n-----\n\nnot all, ISFB payloads (version 2 – haven t taken\na look at version 3 yet so not sure) store a\ncompile/campaign start date in plaintext that is\nused for string decryption. In this sample, the\ndate is Jan 28 2019, so a relatively new sample\nat the time of writing this. I will go over the\nstring decryption method soon, but first let’s\ntake a look at what happens first in the function.\n\nStrings\n\nThere are several functions called inside this function, so let’s take it section by section, so\nfirst let’s take a look at the first four functions. From the image below, it is clear that the\nreturn value of sub_401C69 (stored in eax) needs to match the value in esi, otherwise it\nwill jump to the exit. The second called function – sub_401E4F – seems to do the same\nthing. The third function seems to be a check for something, as 1 is moved into a DWORD\nbased on the result of a bit-wise AND (test performs a bit-wise AND on the two values,\nhowever it just sets flags based on the result, which is not stored) on eax. Finally, the fourth\nfunction seems to act in the same way as the first and second function, in the sense that the\nreturned value is compared to the value in esi, and it will exit if the conditions are not met.\nAnyway, enough assuming, let’s actually take a look at these functions.\n\n\n-----\n\n-----\n\nTaking a look at the first function (the main bit), we can see that the malware is opening it’s\nown process and storing the handle in a DWORD, which is set to -1 if the malware failed to\nopen the process. This then returns back to the main function, where the returned result is\ncompared against the value in ESI.\n\n\n-----\n\n-----\n\nThe second function is where things start to get interesting. In the image below, you’ll notice\nthe compile date being moved into ESI, which, as I mentioned before, is used for string\ndecryption. You might already know this, but for those that don’t, ISFB contains a .BSS\nsection, which contains multiple strings that are all encrypted using a ROR-XOR algorithm.\nThe XOR key is calculated based on a given date, and in order to decrypt the strings, ISFB\nneeds to perform the calculations again to get the correct key, allowing us to easily reverse\nit. But first, let’s take a look at the two functions called beforehand.\n\n\n-----\n\nLooking at the first function, you’ll notice ssb. (endian issues, as it is stored as hex –\nactually is .bss) being compared to the value at [ECX], inside a loop. In order to decrypt\nthe strings in the .BSS section, ISFB must first locate the .BSS section, and in order to do so,\nit simply reads it’s own PE header and gets the size and address of the required section. If\nthe value at [ECX] doesn’t match .bss, 40 is added the the memory address in ECX, due\nto the fact that the spacing between the section descriptors/structures (.text, .data, etc.) is\n40 bytes. The loop will the continue. If there is a match, the length of the string is checked,\nmaking sure that it is not longer than 4 bytes. The malware does this by checking the byte\nafter the string, and comparing it to zero. If the string is the correct length, the memory\naddress pointing to “.bss” is moved into EDX. If everything is successful, ISFB will get the\naddress and size of the .BSS section and store it in memory. In this case, the address is\n**0x6000 (add this to the image base and you will be able to locate it), and the size is**\n\n\n-----\n\n**0x1000. If this is still difficult to understand, there is an image of what the section table**\nlooks like in x32dbg – this should help you to understand how it is able to get the address\nand size.\n\n\n-----\n\nFunction: sub_401C0F #2\n\n\n-----\n\nWith that function analysed, let’s move onto the next one. The main purpose of this function\nis to add a vectored exception handler using AddVectoredExceptionHandler. The\nsecond argument is a pointer to the handler function that will be executed when the\nprogram runs into an exception, so lets take a look at the function\n**Exception_Handle_Function.q**\n\nThis function checks the value of the exception – whether it is an\n**EXCEPTION_ACCESS_VIOLATION or EXCEPTION_SINGLE_STEP, however**\nthey both end up executing the same function, so lets move into that function.\n\n\n-----\n\nThe important part of this function happens soon after it is executed. In the image below,\nyou’ll be able to make out a loop, as well as two XOR instructions and a ROR instruction.\nThis is the BSS section decryption – the XOR key that is created later on is actually arg_8,\nso take note of that. So, now we know that there will be an exception that is caused at some\npoint, which will in turn execute the BSS string decryption function. Now we have this\ninformation, we can move onto reversing how the XOR key is created from the\ncompilation/campaign date.\n\n\n-----\n\nAs the XOR key is based off of the date, thats where we need to look. First, the address of\nthe BSS section (0x6000) is moved into EAX, and the size of it (0x1000) is moved into\nEDX. Then, the memory address of the compile date is moved into ESI, and a memory\naddress (pointing to an empty section of memory) is moved into EDI. The compile date is\nthen moved into that empty region of memory, using MOVSD, which moves a DWORD\nfrom the memory address in ESI to the memory address in EDI. Next, the first DWORD of\nthe compile date is moved into ECX, and this is XOR’ed against the second DWORD of the\ncompile date. Then, the result of this is added to the address of the BSS section (0x6000\nhere) and the value 0xE. This is then pushed as the first argument for the next function that\nwill be called.\n\n\n-----\n\nTaking a look at the function, arg_0 (the XOR key) is used in a Rotate Left instruction.\nHere, we see BL being moved into CL, which is incremented by 1 and used to rotate the XOR\nkey left by 1. This results in the final XOR key that is used to decrypt the BSS strings.\n\n\n-----\n\nOnce we have performed these calculations, we get this as the key: 0x249d730c. Whilst it\nis possible to get the strings from a debugger and copy it over to an IDA instance, I prefer to\nreplicate custom routines using Python. I’m currently polishing up the decryption script I\nhave been using, and when it is complete, you can get it here (my GitHub). Simply put, the\nalgorithm decrypts the data in DWORDs, using a mixture of XOR’s and rotate right (ROR)\ninstructions. First, we’re going to want to copy out the data in the BSS section. View it in the\nhex editor mode, select the entire section (where there is data), and then go Edit**>Export Data, and you can copy the unspaced data. Next, we need to parse this blob of**\ndata so that we can decrypt it.\n\n\n-----\n\nTo parse it, I will be using python. All we need to do is split the hex bytes by 4, and store\nthat in a list. This means each value will be a DWORD. If you follow the commands below,\nyou should be able to get the output seen in the image.\n\n\n-----\n\nNext, we’re going to use CyberChef to do a bit more fixing, although we will be replacing\ndifferent characters, so that there is an 0x before every DWORD, and so Python won’t treat\nthe list as a list of strings.\n\nSo now you should have a suitable list of hex DWORDs which we can then decrypt. In order\nto decrypt it, you simply have to copy it into the script and make sure the key is correct, and\nthen it will decrypt and spit out the raw data, as well as a list of integers, and you will see\nwhy just now. In the image below, you can see the decryption part of my script, which isn’t\ntoo complicated, so if it hasn’t gone up on my GitHub yet, it shouldn’t be too difficult to\nreplicate.\n\n\n-----\n\nOnce the script has decrypted the data, the output looks like this:\n\nSo now we can copy the decrypted strings over to IDA. There is an extremely basic IDA\nPython script in the image below, which overwrites bytes at dest with bytes of data in data.\nThe list data will contain the integer values that our script printed to the terminal, so you\ncan simply copy it from there and paste it into the document.\n\n\n-----\n\nFrom there, we need to import it as a script/module in IDA, so you can do that either by\nimporting the file, or by copying the text and pasting it into the box as shown below. All you\nneed to do then is click Run, and it should be imported – although we physically have to\ncall the script, Run won’t execute it – at least not in this case.\n\nUpon typing PatchArr() into the console and hitting enter, the script should overwrite all\nbytes in the BSS section with our decrypted strings, so you should see something similar to\nthe image below.\n\n\n-----\n\nWe can then reanalyse the payload, by going Options->General->Analysis**>Reanalyze Program, and it should recognize most of the strings, although there will be**\nthe occasional error.\n\nWith the newly decrypted BSS section, we should be able to analyse the rest of the payload\nwithout issues.\n\nOnce the strings have been decrypted, ISFB then calls a function that utilizes one of the\ndecrypted strings – IsWow64Process. As you probably have guessed, this checks to see if\nthe architecture of the system is 64 bit or not. The result (stored in EAX – 1 if x64, 0 if not)\nis then tested If the system is not 64 bit the variable var 4 in the graph below is used in\n\n\n-----\n\nan AND operation with EAX, which would be equal to 0, meaning the value in var_4 would\nbe 0. If the system is 64 bit, this is skipped. Then, regardless of the system architecture, the\nvalue in var_4 is moved into EAX, which is the return value.\n\nIf we back out of the function, we can see\nEAX is tested again, and if the result is not\nzero, the value 1 will be moved into the\nDWORD dword_405478. As the system I\nam running on is 64 bit, dword_405478\nwill contain the value 1. If we search for\ncross references to this DWORD, we can\nfind test instructions that use it. Therefore\nwe can determine this is an indicator of the\narchitecture.\n\n\n-----\n\nThe next function that is called is quite complex. In a nutshell, this function is responsible\nfor getting the address to a select few API calls. To do this, it uses a list of predefined values,\na “key”, and a hashing routine. First, let’s take a look at the key and find out what it is.\nLooking at the image below, just before the value in hModule is moved into ECX, EAX is\nXOR’d with a DWORD inside the binary, however upon viewing this DWORD, it is empty –\nthis means it is resolved dynamically.\n\n\n-----\n\nTo find out what this DWORD will contain, we need to find cross references to it –\nspecifically, we are looking for a reference to it being used as the destination in a MOV\ninstruction. Luckily enough for us, it only appears once as the destination, inside the BSS\nDecrypt function. From the image below, we can see that a DWORD from a string is moved\ninto ECX, which is then used in a subtraction and addition instruction. In this case, it may\nbe much easier to understand what is going on by looking at it in a decompiler.\n\n\n-----\n\nSo, from the looks of it, we can get the key used by performing a simple operation, as seen\nbelow:\n```\nkey = (dword string[4] + dword string[0]) - dword string[12]\nkey = (\"ion=\" + \"vers\") - \"oft=\"\nWe need to convert these values to hex to perform addition and subtraction:\nkey = (0x696f6e3d + 0x76657273) - 0x6f66743d\nkey = 0x706E6C73\nConvert the key from hex and we get this: \"pnls\"\n\n```\nWe can double check this by looking at the binary in a debugger, as shown in the image\nbelow.\n\n\n-----\n\nNow we have the key, let’s take a look at the values used for determining which API to\nimport. This is quite simple to find, as it is already inside the executable. We can also see\nthat EDI is being used as a counter, as each loop it is incremented by 4, until the value\nreaches 20, where it returns. This means there are 5 API’s in total that are looked up using\nthis method. The values in the embedded list are all XOR’d by the key, which results in the\nhash lookup value used for comparison. So, from this, we can start examining the hashing\nalgorithm to see how it functions and to locate what API’s are lookup up and stored.\n\n\n-----\n\nAs the function is quite large, I will focus on the section that calls the hashing function. The\nthree arguments passed to this function are; the address of the DLL, the value 0, and the\ncorrect hash for comparison. The function uses the base address to perform some\ncalculations in order to get to the export table inside the DLL. From there, it loops through\neach of the exports and hashes the name of the export, which is then compared to the\npredefined hash. If the hashes match, the function retrieves the address to the exported API,\nand overwrites the predefined hash with the address for later use. If they do not match, the\nfunction simply continues onto the next export, until a match is finally discovered.\n\n\n-----\n\n-----\n\nTaking a look at the actual hashing function, it is quite difficult to come to the conclusion\n(especially for a beginner) that the function is responsible for hashing, until it is run in a\ndebugger. There is definitely something happening in this function from a static analysis\nperspective, as there are multiple logic instructions, but we can’t know for sure until we\nanalyse it further.\n\nTaking a look in a debugger, it is clear that [edx*4+404108] and [ecx*4+404108] are values\nfrom a lookup table, as the XOR values used constantly change, however the values are\nrepeated, and therefore we can determine that they are not randomized. Base64\nencoding/decoding use lookup tables as well, so if you have looked at that before (or at least\nthe psuedocode), you might be able to recognize the lookup table aspect here. When we take\n\n\n-----\n\na look at the memory region where the lookup table is located, it is easy to see where it\nbegins and ends. So, now we know that there is a lookup table, how do we find out the\nhashing mechanism in use?\n\nTypically, custom encryption and hashing implementations are quite difficult to determine,\nunless you know what you are looking for. As long as the algorithm is publicly available\n(such as AES or Serpent), and not a custom developed one by the author, there will almost\nalways be specific values or instructions that stick out to those who have looked at crypto\nbefore – these are known as Constants. We will revisit these later (in the next post) when\nlooking at the other encryption methods used in this sample, however to sum it up, it\nbasically refers to values that must be used in the algorithm to achieve the correct results. In\nthis case, let’s take one value from the lookup table: 0xA00AE278. We can run a quick\nsearch for this value online, and as you can see from the image below, this is definitely\nlinked to CRC-32, although it is more of a variant – we just need to find out which variant.\n\n\n-----\n\nIn this specific sample, the program loops through the NTDLL.DLL export functions and\nhashes them all until it finds a matching hash. What makes hashing worse is that hashes are\nirreversable, meaning the only way you can find the matching hash is by brute forcing – to\ndo this you could hash each API exported by NTDLL until you found the matching hashes,\nbut this is too time consuming, and it is quite simple to find the matching API anyway – all\nyou have to do is put a breakpoint on the instruction that is hit if a match is found, and\nexecute the program. Once the breakpoint is hit, you’ll be able to locate the correct API.\nFrom the image below, you can see the first API call that matches is ZwGetContextThread.\nWe can now use this to get the variant of CRC-32 used.\n\n\n-----\n\n[In order to do so, we can use this site, which is extremely useful. It hashes the input using](https://crccalc.com/)\nseveral different variants of CRC-8, CRC-16, and CRC-32, allowing us to compare the value\nfrom the debugger to the output of the different variants. With the API name,\nZwGetContextThread, and the required output, 0x5A3D66E4, we can find the variant used:\nCRC-32/JAMCRC.\n\n\n-----\n\nAs we can find out the matching APIs, there is no need to write a brute force script, although\n[for families such as GootKit, this is sometimes necessary. So, the 5 APIs imported are:](https://r3mrum.wordpress.com/2018/02/15/string-hashing-reverse-engineering-an-anti-analysis-control/)\nZwGetContextThread, ZwSetContextThread, ZwReadVirtualMemory,\nZwWriteVirtualMemory, and ZwAllocateVirtualMemory. With that, we can move out of this\nfunction, and onto the next.\n\nThe next function simply retrieves the file name to store in memory, potentially for use later\non in the sample. The next function gets much more interesting, so lets move onto that.\n\n\n-----\n\nIf you’ve looked at ISFB or read anything about it before, you might be aware of an\nembedded FJ, F1, or JJ structure that is located just after the section table. This structure\ncontains pointers to appended (also known as joined) data, such as configuration\ninformation, an RSA public key, or even another executable. There are differences between\nFJ, F1, and JJ, although they are quite small changes. In this case, the sample is using an\nembedded JJ structure, identifiable from the magic value 0x4A4A (“JJ”).\n\n\n-----\n\nThe format of this structure is shown below:\n```\nJoined Resource Structure {\n     WORD Magic Value\n     WORD Flags\n     DWORD XOR Key\n     DWORD CRC-32 Hash\n     DWORD Address\n     DWORD Size\n}\n\n```\nThe parsed structure in this binary can be seen below:\n```\nJoined Resource Structure {\n     WORD 0x4A4A\n     WORD 0x0001\n     DWORD 0xD4B1C68F\n     DWORD 0x9E154A0C\n     DWORD 0x00008400\n     DWORD 0x0000B600\n}\n\n```\nThe function we are looking at is responsible for parsing this structure and locating the\nneeded data. The main argument for this function is the third one, which is the result of an\nXOR between the “pnls” string and an embedded hex value. The first and second arguments\nare simply the start and end of an empty region of memory, so they are not that important\nright now.\n\n\n-----\n\nThe first half of the parsing function traverses through the MZ and PE header until it has\nreached the resource structure located just after the section table. It then checks that the\nmagic value is in fact “JJ” (0x4A4A), otherwise it will add 0x14 to the current address and\ntry again.\n\n\n-----\n\nOnce the structure has been located successfully, the function compares the third argument\n(0x9E154A0C) with the embedded CRC-32 hash, which is also 0x9E154A0C. If these do not\nmatch, the function will return or loop around again. If they do match, the function\nperforms a bitwise AND on the structure flag and 0x2, which must return 0, otherwise the\nfunction will loop or return. If 0 is returned, a heap is allocated based on the size value\nstored in the structure. From there, it will get the full memory address of the joined data by\nadding the address in the structure to the base address of the executable, and then a bitwise\nAND is performed on the structure flag and 0x1. If the result is 0 the joined data is not\ncompressed and is encoded, and if the result is not 0 (which in this case it is 1), the joined\ndata is compressed. As the joined data is compressed in this binary, we will focus on the\ncompression method.\n\n\n-----\n\nThe two arguments pushed to the function are the location of the compressed data, and the\naddress of the newly allocated heap.\n\n\n-----\n\nLooking at an overview of the function, you can see it is quite intricate and difficult to\nfollow. Remember what I was saying about crypto constants earlier? They are also present\nin some, if not all, (de)compression routines, although it is much more difficult to identify\nthe algorithm compared to encryption algorithms.\n\nSearching through the graph, there are calls to the same functions several times over, but we\nare looking for a hardcoded value that is not stored in memory. Sure enough, after searching\nthrough the right branch, we can see a CMP instruction being used, comparing the value in\nesi to the value 0x7D00. Using this, we can search “0x7d00 compression” on Google and\n[after scrolling down a bit, come across this site. Comparing this python code:](https://searchcode.com/codesearch/view/11902540/)\n\n\n-----\n\n```\ndef lengthdelta(offset):\n  if offset < 0x80 or 0x7D00 <= offset:\n    return 2\n  elif 0x500 <= offset:\n    return 1\n  return 0\n\n```\nTo a section of the assembly:\n\nWe can see some clear similarities. From this, we can deduce that the decompression\nalgorithm used here is APLib, and with this knowledge we can write a simple extraction\nscript to extract any joined data from the binary and decompress it using the great Python\nlibrary **[Mlib, created by Mak. You might be wondering how I was able to determine if](https://pypi.org/project/mLib/)**\nsomething was decompressed before even looking at the function. I have read up on ISFB\nand have also analysed it quite frequently, however it is quite easy to figure out that the\njoined data is compressed by simply looking at it. Opening up the binary in a hex editor and\ngoing to the location of the joined data, you might be able to recognize the string “This\nProgram Cannot Be Run In DOS Mode”, although part of it is obfuscated. Recognizing\ncompression also depends on the level of compression, however for the ISFB malware\nstrain, APLib is the defacto compression method for now, so it is relatively simple.\n\n\n-----\n\n-----\n\nBacking out from the decompression function, the program makes sure that the size of the\ndecompressed executable is the same size as the value stored in the JJ structure. If the sizes\ndo not match, the decompressed executable is cleared from memory, using HeapFree().\nThen, the malware XORs the first DWORD of the decompressed data with the XOR key\nstored in the structure. Taking a look at the decompressed data, we can see that the first\nDWORD of the executable is not valid – it should look like 00009000, but instead looks like\n54205BD4. After the XOR, the valid value can be seen. The function cleans up after itself,\nand then returns back to the calling function. If you were to dump the executable at this\nstage and add “MZ” to the start, you would be unable to open it in PE Bear – this is due to\nthe fact that not only is “MZ” missing, “PE” is also missing from the header, so make sure\nyou add that as well.\n\n\n-----\n\nBack in the calling function, the malware then overwrites the decompressed executable\nusing a rolling XOR algorithm. I’m not exactly sure why it does this, as the executable is\nlater decrypted, so if someone could let me know that would be great! Anyway, once the\nexecutable has been encrypted, the function carries on.\n\n\n-----\n\nFirst, it creates a new file mapping, and calls MapViewOfFile, and then copies it’s filename\nto the newly mapped region, before calling UnmapViewOfFile. Again, I’m not too sure why\nthis is being called, as it doesn’t seem to do anything, but if someone could drop an answer\nto this that would be great, and I can incorporate it into the post.\n\n\n-----\n\nMoving on, the final function in this sample is called. This is quite a large function, so I will\nattempt to summarize the main points. Firstly, the function begins by moving different\npointers around, and then compares the first 2 bytes of the encrypted executable to the\nvalue 0x5A4D (MZ) to check if the data is encrypted or not. As it is encrypted, the result will\nnot be 0, and so it will allocate a heap based on the size seen in the embedded JJ structure.\nNext, it will call another function responsible for performing another rolling XOR\nalgorithm, that will decrypt the data. This is a bit different to the last one, but should return\nthe same executable that was decompressed earlier. Then, it will locate the value in the PE\nheader that indicates the architecture of the executable, which in this case is 0x14C,\nmeaning it is x86 based.\n\n\n-----\n\n-----\n\nNext, the malware will allocate a brand new section of memory using NtCreateSection(),\nwhich will be set to Read-Write-eXecute. Eventually, this will contain the decompressed\nexecutable.\n\n\n-----\n\nFrom there, an address located inside the newly created section of memory will be formed,\npointing to 0x0022EC50, which will be used later. The created section of memory is\nreplicated, to the address 0x00240000. Next, the program begins to copy over the\nexecutable to the new addresses, however it skips the entire MZ header and simply copies\neverything from the PE header.\n\n\n-----\n\nThen, a function is called that imports some more API calls from NTDLL, however this time\nit is not done using CRC hashes, and the name is simply passed as an argument. The\nimported API calls are; LdrLoadDll, LdrGetProcedureAddress, and\nZwProtectVirtualMemory. The pointers to the addresses are stored in the same region of\nmemory, split by 4 null bytes each. These addresses are then copied over to the executable\nat 0x00220000 for usage during it’s execution. Next, a region of code is copied over to the\nexecutable in memory, just 40 bytes after the loaded APIs. This is what will be called before\nthe next stage is completely executed.\n\n\n-----\n\nContinuing on, the next function is responsible for passing execution over to the executable.\nThere are 2 functions that pass over execution to the executable, however they depend on\nthe architecture. In this case, I will be looking at the x64 version. It is quite simple, as all it\ndoes is call the function at the address 0x0022E040, which will prepare the next stage.\nTherefore, you can think of this stage as another “unpacker”, as all it does is unpacks the\nexecutable, however there are many functions that carry over to the next stage, making it\nmuch easier to analyse.\n\n\n-----\n\nWhen we step into the function, there is an int3 waiting for us, which acts as a breakpoint\nthat raises an exception, stopping us from stepping over it. To fix this, we can put a\nbreakpoint on the previous call, restart the debugger and then run it until the breakpoint is\nhit. This should hopefully remove the int3.\n\nAs it didn’t remove it in my case, I will use Immunity Debugger to carry on this section. The\ncode is responsible for importing DLLs using the previously imported API’s – First, there is\na loop which stores a DLL name in memory that will be loaded using LdrLoadDll. Then, a\nlist of hardcoded APIs are looped over, with each being passed to LdrGetProcedureAddress.\nThe DLLs that are loaded are; NTDLL.DLL, KERNEL32.DLL, AND OLEAUT32.DLL.\n\n\n-----\n\n-----\n\nOnce the APIs have been imported, ZwProtectVirtualMemory is called several times in a\nloop to alter the protections on several regions of memory.\n\nIn order to jump to where the execution of the payload happens, we want to put a\nbreakpoint on a call to a register, which in this instance is EBX. Run to that, and then step\ninto it, and you should find yourself in the next stage of ISFB!\n\n\n-----\n\nAll we need to do now is to dump it out, add “MZ” and “PE” to the header, unmap and\nrebase it using PE Bear, and then we can start analysing the next stage!\n\n\n-----\n\n-----\n\n```\nMD5 of Dumped DLL: 52b4480de6f4d4f32fba2b535941c284\n\n```\nCongratulations! You have managed to analyse the loader and “unpack” the next stage,\nwhich I will be analysing in the next post (because this one has now amassed over 6,000\nwords which is much longer than I planned). So, feel free to ask any questions you have\n[down below, or over Twitter (@0verfl0w_) and I will be glad to answer them! I apologize](https://twitter.com/0verfl0w_)\nagain for the lack of posts recently, I’ve been working on my course as well, so I’ve had a lot\nof stuff to do! Hopefully the next post on ISFB shouldn’t take too long to do, so make sure to\nsign up to my mailing list to stay updated whenever I post! Thanks again\n\n## 2 Comments\n\n\n-----\n\nComments are closed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-03-13 - Analysing ISFB - The First Loader.pdf"
    ],
    "report_names": [
        "2019-03-13 - Analysing ISFB - The First Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536210,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653488062,
    "ts_modification_date": 1653488062,
    "files": {
        "pdf": "https://archive.orkl.eu/b28d75659a5e83750528147db2d3b2edb1a02ceb.pdf",
        "text": "https://archive.orkl.eu/b28d75659a5e83750528147db2d3b2edb1a02ceb.txt",
        "img": "https://archive.orkl.eu/b28d75659a5e83750528147db2d3b2edb1a02ceb.jpg"
    }
}