{
    "id": "217095e1-9ced-4fa2-ae0f-04d97eae30b4",
    "created_at": "2023-01-12T15:10:50.660452Z",
    "updated_at": "2025-03-27T02:08:41.244755Z",
    "deleted_at": null,
    "sha1_hash": "8a07bd029d9e6ae91ec93a7dcf0e3a0e8eb472c7",
    "title": "2022-01-07 - Unpacking CVE-2021-40444- A Deep Technical Analysis of an Office RCE Exploit",
    "authors": "",
    "file_creation_date": "2022-05-27T23:17:21Z",
    "file_modification_date": "2022-05-27T23:17:21Z",
    "file_size": 7828268,
    "plain_text": "# Unpacking CVE-2021-40444: A Deep Technical Analysis of an Office RCE Exploit\n\n**[billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/](https://billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/)**\n\nBill Demirkapi January 7, 2022\n\n[Security Research](https://billdemirkapi.me/tag/security-research/)\n\n**[Bill Demirkapi](https://billdemirkapi.me/author/bill/)**\n\nJan 7, 2022 • 22 min read\n\n\n-----\n\n[In the middle of August 2021, a special Word document was uploaded to VirusTotal by a user](https://www.virustotal.com/gui/file/3bddb2e1a85a9e06b9f9021ad301fdcde33e197225ae1676b8c6d0b416193ecf/)\nfrom Argentina. Although it was only detected by a single antivirus engine at the time, this\nsample turned out to be exploiting a zero day vulnerability in Microsoft Office to gain remote\ncode execution.\n\n[Three weeks later, Microsoft published an advisory after being notified of the exploit by](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444)\nresearchers from Mandiant and EXPMON. It took Microsoft nearly a month from the time the\nexploit was first uploaded to VirusTotal to publish a patch for the zero day.\n\nIn this blog post, I will be sharing my in-depth analysis of the several vulnerabilities abused\nby the attackers, how the exploit was patched, and how to port the exploit for a generic\nInternet Explorer environment.\n\n## First Look\n\n\n-----\n\nA day after Microsoft published their advisory, I saw a tweet from the malware collection\ngroup [@vxunderground offering a malicious payload for CVE-2021-40444 to blue/red teams.](https://twitter.com/vxunderground)\n\nI reached out to receive a copy, because why not? My curiosity has generally lead me in the\nright direction for my life and I was interested in seeing a Microsoft Word exploit that had\nbeen found in the wild.\n\nWith the payload in hand, one of the first steps I took was placing it into an isolated virtual\nmachine with basic dynamic analysis tooling. Specifically, one of my favorite network\n[monitoring utilities is Fiddler, a freemium tool that allows you to intercept web requests](https://www.telerik.com/fiddler/fiddler-classic)\n(including encrypted HTTPS traffic).\n\nAfter I opened the malicious Word document, Fiddler immediately captured strange HTTP\nrequests to the domain, \"hidusi[.]com\". For some reason, the Word document was making a\nrequest to \"http://hidusi[.]com/e8c76295a5f9acb7/side.html\".\n\n\n-----\n\nAt this point, the hidusi[.]com domain was already taken down. Fortunately, the side.html\nfile being requested was included with the sample that was shared with me.\n\nUnfortunately, the HTML file was largely filled with obfuscated JavaScript. Although I could\nimmediately decrypt this JavaScript and go from there, this is generally a bad idea to do at\nan early stage because we have no understanding of the exploit.\n\n## Reproduction\n\nWhenever I encounter a new vulnerability that I want to reverse engineer, my first goal is\nalways to produce a minimal reproduction example of the exploit to ensure I have a working\ntest environment and a basic understanding of how the exploit works. Having a reproduction\ncase is critical to reverse engineering how the bug works, because it allows for dynamic\nanalysis.\n\nSince the original \"hidusi[.]com\" domain was down, we needed to host our version of\nside.html. Hosting a file is easy, but how do we make the Word document use our domain\ninstead? It was time to find where the URL to side.html was hidden inside the Word\ndocument.\n\nRaw Bytes of \"A Letter before court 4.docx\"\n\n\n-----\n\nExtracted Contents of \"A Letter before court 4.docx\"\nDid you know that Office documents are just ZIP files? As we can see from the bytes of the\nmalicious document, the first few bytes are simply the magic value in the ZIP header.\n\nOnce I extracted the document as a ZIP, finding the URL was relatively easy. I performed a\nstring search across every file the document contained for the domain \"hidusi[.]com\".\n\nHidusi[.]com found under word/_rels/document.xml.rels\nSure enough, I found one match inside the file \"word/_rels/document.xml.rels\". This file is\nresponsible for defining relationships associated with embedded objects in the document.\n\n[OLE objects are part of Microsoft's proprietary Object Linking and Embedding technology,](https://en.wikipedia.org/wiki/Object_Linking_and_Embedding)\nwhich allows external documents, such as an Excel spreadsheet, to be embedded within a\nWord document.\n\nStrange Target for OLE Object\nThe relationship that contained the malicious URL was an external OLE object with a strange\n\"Target\" attribute containing the \"mhtml\" protocol. Let's unpack what's going on in this value.\n\n1. In red, we see the URL Protocol \"mhtml\".\n2. In green, we see the malicious URL our proxy caught.\n3. In blue, we see an interesting \"!x-usc\" suffix appended to the malicious URL.\n4. In purple, we see the same malicious URL repeated.\n\nLet's investigate each piece one-by-one.\n\n\n-----\n\n### Reproduction: What s MHTML ?\n\n[A useful tool I've discovered in past research is URLProtocolView from Nirsoft. At a high](https://www.nirsoft.net/utils/url_protocol_view.html)\nlevel, URLProtocolView allows you to list and enumerate the URL protocols installed on your\nmachine.\n\nThe MHTML Protocol in URLProtocolView\nThe MHTML protocol used in the Target attribute was a Pluggable Protocol Handler, similar\nto HTTP. The inetcomm.dll module was responsible for handling requests to this protocol.\n\nThe HTTP* Protocols in URLProtocolView\nUnlike MHTML however, the HTTP protocol is handled by the urlmon.dll module.\n\n\n-----\n\nWhen I was researching past exploits involving the MHTML protocol, I came across an\n[interesting article all the way back from 2011 about CVE-2011-0096. In this case, a Google](https://www.exploit-db.com/exploits/16071)\nengineer publicly disclosed an exploit that they suspected malicious actors attributed to\nChina had already discovered. Similar to this vulnerability, CVE-2021-0096 was only found to\nbe used in \"very targeted\" attacks.\n\nWhen I was researching implementations of exploits for CVE-2011-0096, I came across an\n[exploit-db release that included an approach for abusing the vulnerability through a Word](https://www.exploit-db.com/exploits/16071)\ndocument. Specifically, in part #5 and #6 of the exploit, this author discovered that CVE2011-0096 could be abused to launch executables on the local machine and read the\ncontents of the local filesystem. The interesting part here is that this 2011 vulnerability\ninvolved abusing the MHTML URL protocol and that it allowed for remote code execution via\na Word document, similar to the case with CVE-2021-4044.\n\n### Reproduction: What about the \"X-USC\" in the Target?\n\nGoing back to our strange Target attribute, what is the \"!x-usc:\" portion for?\n\nI found [a blog post from 2018 by](http://10.10.0.46/mhtml:http://google.com/whatever!x-usc:http://bing.com) [@insertScript which discovered that the x-usc directive was](https://twitter.com/insertScript)\nused to reference an external link. In fact, the example URL given by the author still works on\nthe latest version of Internet Explorer (IE). If you enter \"mhtml:http://google.com/whatever!xusc:http://bing.com\" into your IE URL bar while monitoring network requests, there will be\nboth a request to Google and Bing, due to the \"x-usc\" directive.\n\nIn the context of CVE-2021-40444, I was unable to discover a definitive answer for why the\nsame URL was repeated after an \"x-usc\" directive. As we'll see in upcoming sections, the\nJavaScript in side.html is executed regardless of whether or not the attribute contains the \"xusc\" suffix. It is possible that due to some potential race conditions, this suffix was added to\nexecute the exploit twice to ensure successful payload delivery.\n\n### Reproduction: Attempting to Create my Own Payload\n\n\n-----\n\nNow that we know how the remote side.html page is triggered by the Word document, it was\ntime to try and create our own. Although we could proceed by hosting the same side.html\npayload the attackers used in their exploit, it is important to produce a minimal reproduction\nexample first.\n\nInstead of hosting the second-stage side.html payload, I opted to write a barebone HTML\npage that would indicate JavaScript execution was successful. This way, we can understand\nhow JavaScript is executed by the Word document before reverse engineering what the\nattacker's JavaScript does.\n\nTest Payload to Prove JS Execution\n[In the example above, I created an HTML page that simply made an XMLHttpRequest to a](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\nnon-existent domain. If the JavaScript is executed, we should be able to see a request to\n\"icanseethisrequestonthenetwork.com\" inside of Fiddler.\n\nBefore testing in the actual Word document, I verified as a sanity check that this page does\nmake the web request inside of Internet Explorer. Although the code may seem simple\nenough to where it would \"obviously work\", performing simple sanity checks like these on\nfundamental assumptions you make can greatly save you time debugging future issues. For\nexample, if you don't verify a fundamental assumption and continue with reverse\nengineering, you could spend hours debugging the wrong issue when in fact you were\nmissing a basic mistake.\n\nModified Relationship with Barebone Payload\n\n\n-----\n\nNetwork Requests After Executing Modified Document\nOnce I patched the original Word document with my modified relationship XML, I launched it\ninside my VM with the Fiddler proxy running. I was seeing requests to the send_request.html\npayload! But... there were no requests to \"icanseethisonthenetwork.com\". We have\ndemonstrated a flaw in our fundamental assumption that whatever HTML page we point the\nMHTML protocol towards will be executed.\n\nHow do you debug an issue like this? One approach would be to go in blind and try to\nreverse engineer the internals of the HTML engine to see why JavaScript wasn't being\nexecuted. The reason this is not a great idea is because often these codebases can be\n_massive, and it would be like finding a needle in a haystack._\n\nWhat can we do instead? Create a minimally viable reproduction case where the JavaScript\nof the HTML is executed. We know that the attacker's payload must have worked in their\nattack. What if instead of writing our own payload first, we tried to host their payload instead?\n\n\n-----\n\nNetwork Requests After Executing with Side.html Payload\nI uploaded the attacker’s original \"side.html\" payload to my server and replaced the\nrelationship in the Word document with that URL. When I executed this modified document in\nmy VM, I saw something extremely promising- requests for \"ministry.cab\". This means that\nthe attacker's JavaScript inside side.html was executed!\n\nWe have an MVP payload that gets executed by the Word document, now what? Although\nwe could ignore our earlier problem with our own payload and try to figure out what the CAB\nfile is used for directly, we'd be skipping a crucial step of the exploit. We want to understand\nCVE-2021-40444, not just reproduce it.\n\nWith this MVP, we can now try to debug and reverse engineer the question, \"Why does the\nworking payload result in JavaScript execution, but not our own sample?\".\n\n### Reproduction: Reverse Engineering Microsoft’s HTML Engine\n\nThe primary module responsible for processing HTML in Windows is MSHTML.DLL, the\n\"Microsoft HTML Viewer\". This binary alone is 22 MB, because it contains almost everything\nfrom rendering HTML to executing JavaScript. For example, Microsoft has their own\nJavaScript engine in this binary used in Internet Explorer (and Word).\n\nGiven this massive size, blindly reversing is a terrible approach. What I like to do instead is\nuse [ProcMon to trace the execution of the successful (document with side.html) and failing](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon)\npayload (document with barebone HTML), then compare their results. I executed the\nattacker payload document and my own sample document while monitoring Microsoft Word\nwith ProcMon.\n\n\n-----\n\nMicrosoft Word Loading JScript9.dll in Success Case\nWith the number of operations an application like Microsoft Office makes, it can be difficult to\nsift through the noise. The best approach I have for this problem is to use my context to find\nrelevant operations. In this case, since we were looking into the execution of JavaScript, I\nlooked for operations involving the word “script”.\n\nYou might think, what can we do with relevant operations? An insanely useful feature of\nProcMon is the ability to see the caller stack for a given operation. This lets you see what\nexecuted the operation.\n\nStack\n\nTrace of JScript9.dll Module Load\n\n\n-----\n\nIDA Pro Breakpoint on PostManExecute\nIt looked like the PostManExecute function was primary responsible for triggering the\ncomplete execution of our payload. Using IDA Pro, I set a breakpoint on this function and\nopened both the successful/failing payloads.\n\nI found that when the success payload was launched, PostManExecute would be called, and\nthe page would be loaded. On the failure case however, PostManExecute was not called and\nthus the page was never executed. Now we needed to figure out why is PostManExecute\nbeing invoked for the attacker’s payload but not ours?\n\nPartial Stack Trace of JScript9.dll Module Load\nGoing back to the call stack, what’s interesting is that PostManExecute seems to be the\nresult of a callback that is being invoked in an asynchronous thread.\n\nX-Refs to CDwnChan::OnMethodCall from Call Stack\nLooking at the cross references for the function called right after the asynchronous\ndispatcher, CDwnChan::OnMethodCall, I found that it seemed to be queued in another\nfunction called CDwnChan::Signal.\n\nAsynchronous Execution of CDwnChan::OnMethodCall inside CDwnChan::Signal\n\n\n-----\n\nX-Refs to CDwnChan::Signal\nCDwnChan::Signal seemed to be using the function \"_GWPostMethodCallEx\" to queue the\nCDwnChan::OnMethodCall to be executed in the asynchronous thread we saw.\nUnfortunately, this Signal function is called from many places, and it would be a waste of time\nto try to statically reverse engineer every reference.\n\nX-Refs to Asynchronous Queue'ing Function __GWPostMethodCallEx\nWhat can we do instead? Looking at the X-Refs for _GWPostMethodCallEx, it seemed like it\nwas used to queue almost everything related to HTML processing. What if we hooked this\nfunction and compared the different methods that were queued between the success and\nfailure path?\n\n\n-----\n\nWhenever __GWPostMethodCallEx was called, I recorded the method being queued for\nasynchronous execution and the call stack. The diagram above demonstrates the methods\nthat were queued during the execution of the successful payload and the failing payload.\nStrangely in the failure path, the processing of the HTML page was terminated\n(CDwnBindData::TerminateOnApt) before the page was ever executed.\n\nCallstack for CDwnBindData::TerminateOnApt\nWhy was the Terminate function being queued before the OnMethodCall function in the\nfailure path? The call stacks for the Terminate function matched between the success and\nfailure paths. Let’s reverse engineer those functions.\n\n\n-----\n\nPartial Pseudocode of CDwnBindData::Read\nWhen I debugged the CDwnBindData::Read function, which called the Terminate function, I\nfound that a call to CDwnStm::Read was working in the success path but returning an error\nin the failure path. This is what terminated the page execution for our sample payload!\n\nThe third argument to CDwnStm::Read was supposed to be the number of bytes the client\nshould try to read from the server. For some reason, the client was expecting 4096 bytes and\nmy barebone HTML file was not that big.\n\nAs a sanity check, I added a bunch of useless padding to the end of my HTML file to make\nits size 4096+ bytes. Let’s see our network requests with this modified payload.\n\nModified Barebone HTML with Padding to 4096 bytes\n\nNetwork Requests of Barebone Word Document\nWe had now found and fixed the issue with our barebone HTML page! But our work isn't over\nyet. We wouldn’t be great reverse engineers if we didn’t investigate why the client was\nexpecting 4096 bytes in the first place.\n\nPartial Pseudocode of CHtmPre::GetReadRequestSize\nI traced back the origin of the expected size to a call in CHtmPre::Read to\nCHtmPre::GetReadRequestSize. Stepping through this function in a debugger, I found that a\nfield at offset 136 of the CHtmPre class represented the request size the client should\n\n\n-----\n\nexpect. How can we find out why this value is 4096? Something had to write to it at some\npoint.\n\nPartial Pseudocode of CHtmPre Constructor\nSince we were looking at a class function of the CHtmPre class, I set a breakpoint on the\nconstructor for this class. When the debugger reached the constructor, I placed a write\nmemory breakpoint for the field offset we saw (+ 136).\n\nPartial Pseudocode of CEncodeReader Constructor when the Write Breakpoint Hit\nThe breakpoint hit! And not so far away either. The 4096 value was being set inside of\nanother object constructor, CEncodeReader::CEncodeReader. This constructor was\ninstantiated by the CHtmPre constructor we just hooked. Where did the 4096 come from\nthen? It was hardcoded into the CHtmPre constructor!\n\nPartial Pseudocode of CHtmPre Constructor, Highlighting Hardcoded 4096 Value\nWhat was happening was that when the CHtmPre instance was constructed, it had a default\nread size of 4096 bytes. The client was reading the bytes from the HTTP response before\nthis field was updated with the real response size. Since our barebone payload was just a\nsmall HTML page under 4096 bytes, the client thought that the server hadn’t sent the\nrequired response and thus terminated the execution.\n\nThe reason the attacker's payload worked is because it was above 4096 bytes in size. We\njust found a bug still present in Microsoft’s HTML processor!\n\n### Reproduction: Fixing the Attacker's Payload\n\n\n-----\n\nNetwork Requests After Executing with Side.html Payload\nWe figured out how to make sure our payload executes. If you recall to an earlier section of\nthis blog post, we saw that a request to a \"ministry.cab\" file was being made by the attacker's\nside.html payload. Fortunately for us, the attacker’s sample came with the CAB file the\nserver was originally serving.\n\nThis CAB file was interesting. It had a single file named \"../msword.inf\", suggesting a relative\npath escape attack. This INF file was a PE binary for the attacker’s Cobalt Strike beacon. I\nreplaced this file with a simple DLL that opened Calculator for testing. Unfortunately, when I\nuploaded this CAB file to my server, I saw a successful request to it but no Calculator.\n\nOperations involving msword.inf from CAB file\n\n\n-----\n\nCall stack of msword.inf Operation\nI monitored Word with ProcMon once again to try and see what was happening with the CAB\nfile. I filtered for \"msword.inf\" and found interesting operations where Word was writing it to\nthe VM user's %TEMP% directory. The \"VerifyTrust\" function name in the call stack\nsuggested that the INF file was written to the TEMP directory while it was trying to verify its\nsignature.\n\nLet's step through these functions to figure out what's going on.\n\nPartial Pseudocode of Cwvt::VerifyTrust\nAfter stepping through Cwvt::VerifyTrust with a debugger, I found that the function attempted\nto verify the signature of files contained within the CAB file. Specifically, if the CAB file\nincluded an INF file, it would extract it to disk and try to verify its digital signature.\n\n\n-----\n\nWhat was happening was that the extraction process didn t have any security measures,\nallowing for an attacker to use relative path escapes to get out of the temporary directory that\nwas generated for the CAB file.\n\nThe attackers were using a zero-day with ActiveX controls:\n\n1. The attacker’s JavaScript (side.html) would attempt to execute the CAB file as an\n\nActiveX control.\n2. This triggered Microsoft’s security controls to verify that the CAB file was signed and\n\nsafe to execute.\n3. Unfortunately, Microsoft handled this CAB file without care and although the signature\n\nverification fails, it allowed an attacker to extract the INF file to another location with\nrelative path escapes.\n\nIf there was a user-writable directory where if you could put a malicious INF file, it would\nexecute your malware, then they could have stopped here with their exploit. This isn’t a\npossibility though, so they needed some way to execute the INF file as a PE binary.\n\nStrange control.exe Execution with INF File in Command Line\n\nStrange rundll32.exe Execution with INF File in Command Line\nGoing back to ProcMon, I tried to see why the INF file wasn’t being executed. It looks like\nthey were using another exploit to trigger execution of \"control.exe\".\n\n\".cpl\" Used as a URL Protocol\nThe attackers were triggering the execution of a Control Panel Item. The command line for\ncontrol.exe suggested they were using the \".cpl\" file extension as a URL protocol and then\nused relative path escapes to trigger the INF file.\n\nWhy wasn’t my Calculator DLL being executed then? Entirely my mistake! I was executing\nthe Word document from a nested directory, but the attackers were only spraying a few\nrelative path escapes that never reached my user directory. This makes sense because this\n\n\n-----\n\ndocument is intended to be executed from a victim s Downloads folder, whereas I was\nhosting the file inside of a nested Documents directory.\n\nI placed the Word document in my Downloads folder and… voila:\n\nCalculator being Executed by Word Document\n\n## Reversing the Attacker's Payload\n\nWe have a working exploit! Now the next step to understanding the attack is to reverse\nengineer the attacker’s malicious JavaScript. If you recall, it was somewhat obfuscated. As\nsomeone with experience with JavaScript obfuscators, it didn’t seem like the attacker’s did\ntoo much, however.\n\nCommon JavaScript String Obfuscation Technique seen in Attacker's Code\n\n\n-----\n\nA common pattern I see with attempts at string obfuscation in JavaScript is an array\ncontaining a bunch of strings and the rest of the code referencing strings through an\nunknown function which referenced that array.\n\nIn this case, we can see a string array named \"a0_0x127f\" which is referenced inside of the\nglobal function \"a0_0x15ec\". Looking at the rest of the JavaScript, we can see that several\nparts of it call this unknown function with an numerical index, suggesting that this function is\nused to retrieve a deobfuscated version of the string.\n\nString Deobfuscation Script\nThis approach to string obfuscation is relatively easy to get past. I wrote a small script to find\nall calls to the encryption function, resolve what the string was, and replace the entire call\nwith the real string. Instead of worrying about the mechanics of the deobfuscation function,\nwe can just call into it like the real code does to retrieve the deobfuscated string.\n\n**Before String Deobfuscation**\n\n\n-----\n\n**After String Deobfuscation**\nThis worked extremely well and we now have a relatively deobfuscated version of their\nscript. The rest of the deobfuscation was just combining strings, getting rid of \"indirect\" calls\nto objects, and naming variables given their context. I can’t cover each step in detail because\nthere were a lot of minor steps for this last part, but there was nothing especially notable. I\ntried naming the variables the best I could given the context around them and commented\nout what I thought was happening.\n\nLet’s review what the script does.\n\n\n-----\n\nPart #1 of Deobfuscated JavaScript: Create and Destroy an IFrame\nIn this first part, the attacker's created an iframe element, retrieved the ActiveX scripting\ninterface for that iframe, and destroyed the iframe. Although the iframe has been destroyed,\nthe ActiveX interface is still live and can be used to execute arbitrary HTML/JavaScript.\n\n\n-----\n\nPart #2 of Deobfuscated JavaScript: Create Nested ActiveX HTML Documents\nIn this next part, the attackers used the destroyed iframe's ActiveX interface to create three\nnested HTML documents. I am not entirely sure what the purpose of these nested\ndocuments serves, because if the attackers only used the original ActiveX interface without\nany nesting, the exploit works fine.\n\nPart #3 of Deobfuscated JavaScript: Create ActiveX Control and Trigger INF File\nThis final section is what performs the primary exploits.\n\n\n-----\n\nThe attackers make a request to the exploit CAB file ( ministry.cab ) with an\nXMLHttpRequest. Next, the attackers create a new ActiveX Control object inside of the third\nnested HTML document created in the last step. The class ID and version of this ActiveX\ncontrol are arbitrary and can be changed, but the important piece is that the ActiveX Control\npoints at the previously requested CAB file. URLMON will automatically verify the signature\nof the ActiveX Control CAB file, which is when the malicious INF file is extracted into the\nuser's temporary directory.\n\nTo trigger their malicious INF payload, the attackers use the \".cpl\" file extension as a URL\nProtocol with a relative path escape in a new HTML document. This causes control.exe to\nstart rundll32.exe, passing the INF file as the Control Panel Item to execute.\n\n[The fully deobfuscated and commented HTML/JS payload can be found here.](https://gist.github.com/D4stiny/1692ded337b67bfbeea10f2269af81fe)\n\n## Overview of the Attack\n\nWe covered a significant amount in the previous sections, let's summarize the attack from\nstart to finish:\n\n1. A victim opens the malicious Word document.\n2. Word loads the attacker's HTML page as an OLE object and executes the contained\n\nJavaScript.\n3. An IFrame is created and destroyed, but a reference to its ActiveX scripting surface\n\nremains.\n4. The CAB file is invoked by creating an ActiveX control for it.\n5. While the CAB file's signature is verified, the contained INF file is written to the user's\n\nTemp directory.\n6. Finally, the INF is invoked by using the \".cpl\" extension as a URL protocol, using\n\nrelative path escapes to reach the temporary directory.\n\n\n-----\n\n## Reversing Microsoft's Patch\n\nWhen Microsoft released its advisory for this bug on September 7th, they had no patch! To\nsave face, they claimed Windows Defender was a mitigation, but that was just a detection for\nthe attacker's exploit. The underlying vulnerability was untouched.\n\nIt took them nearly a month from when the first known sample was uploaded to VirusTotal\n(August 19th) to finally fix the issue on September 14th with a Patch Tuesday update. Let’s\ntake a look at the major changes in this patch.\n\nA popular practice by security researchers is to find the differences in binaries that used to\ncontain vulnerabilities with the patched binary equivalent. I updated my system but saved\nseveral DLL files from my unpatched machine. There are a couple of tools that are great for\nfinding assembly-level differences between two similar binaries.\n\n[1. BinDiff by Zynamics](https://www.zynamics.com/bindiff.html)\n[2. Diaphora by Joxean Koret](https://github.com/joxeankoret/diaphora)\n\n\n-----\n\nI went with Diaphora because it is more advanced than BinDiff and allows for easy pseudocode level comparisons. The primary binaries I diff'd were:\n\n1. IEFRAME.dll - This is what executed the URL protocol for \".cpl\".\n2. URLMON.dll - This is what had the CAB file extraction exploit.\n\n### Reversing Microsoft's Patch: IEFRAME\n\nOnce I diff’d the updated and unpatched binary, I found ~1000 total differences, but only ~30\nmajor changes. One function that had heavy changes and was associated with the CPL\nexploit was _AttemptShellExecuteForHlinkNavigate.\n\nPseudocode Diff of _AttemptShellExecuteForHlinkNavigate\n[In the old version of IEFRAME, this function simply used ShellExecuteW to open the URL](https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutew)\nprotocol with no verification. This is why the CPL file extension was processed as a URL\nprotocol.\n\nIn the new version, they added a significant number of checks for the URL protocol. Let’s\ncompare the differences.\n\n\n-----\n\nPatched _AttemptShellExecuteForHlinkNavigate Pseudocode\n\nNew IsValidSchemeName Function\nIn the patched version of _AttemptShellExecuteForHlinkNavigate, the primary addition that\nprevents the use of file extensions as URL Protocols is the call to IsValidSchemeName.\n\nThis function takes the URL Protocol that is being used (i.e \".cpl\") and verifies that all\ncharacters in it are alphanumerical. For example, this exploit used the CPL file extension to\ntrigger the INF file. With this patch, \".cpl\" would fail the IsValidSchemeName function\nbecause it contains a period which is non-alphanumerical.\n\nAn important factor to note is that this patch for using file extensions as URL Protocols only\napplies to MSHTML. File extensions are still exposed for use in other attacks against\nShellExecute, which is why I wouldn't be surprised if we saw similar techniques in future\nvulnerabilities.\n\n### Reversing Microsoft's Patch: URLMON\n\n\n-----\n\nI performed the same patch diffing on URLMON and found a major change in catDirAndFile.\nThis function was used during extraction to generate the output path for the INF file.\n\nPatched catDirAndFile\n\nPseudocode\nThe patch for the CAB extraction exploit was extremely simple. All Microsoft did was replace\nany instance of a forward slash with a backslash. This prevents the INF extraction exploit of\nthe CAB file because backslashes are ignored for relative path escapes.\n\n## Abusing CVE-2021-40444 in Internet Explorer\n\nAlthough Microsoft's advisory covers an attack scenario where this vulnerability is abused in\nMicrosoft Office, could we exploit this bug in another context?\n\nSince Microsoft Office uses the same engine Internet Explorer uses to display web pages,\ncould CVE-2021-40444 be abused to gain remote code execution from a malicious page\nopened in IE? When I tried to visit the same payload used in the Word document, the exploit\ndid not work \"out of the box\", specifically due to an error with the pop up blocker.\n\nIE blocks .cpl popup\nAlthough the CAB extraction exploit was successfully triggered, the attempt to launch the\npayload failed because Internet Explorer considered the \".cpl\" exploit to be creating a pop\nup.\n\nFortunately, we can port the .cpl exploit to get around this pop up blocker relatively easily.\nInstead of creating a new page, we can simply redirect the current page to the \".cpl\" URL.\n\n\n-----\n\n```\nfunction redirect() {\n  //\n  // Redirect current window without creating new one,\n  // evading the IE pop up blocker.\n  //\n  window.location = \".cpl:../../../AppData/Local/Temp/Low/msword.inf\";\n  document.getElementById(\"status\").innerHTML = \"Done\";\n}\n//\n// Trigger in 500ms to give time for the .cab file to extract.\n//\nsetTimeout(function() {\n  redirect()\n}, 500);\n\n```\nWith the small addition of the redirect, CVE-2021-40444 works without issue in Internet\n[Explorer. The complete code for this ported HTML/JS payload can be found here.](https://gist.github.com/D4stiny/4fd437bad4233856a7cebd42fb3057e5)\n\n## Conclusion\n\nCVE-2021-40444 is in fact compromised of several vulnerabilities as we investigated in this\nblog post. Not only was there the initial step of extracting a malicious file to a predictable\nlocation through the CAB file exploit, but there was also the fact that URL Protocols could be\nfile extensions.\n\nIn the latest patch, Word still executes pages with JavaScript if you use the MHTML protocol.\nWhat’s frightening to me is that the entire attack surface of Internet Explorer is exposed to\nattackers through Microsoft Word. That is a lot of legacy code. Time will tell what other\nvulnerabilities attacker's will abuse in Internet Explorer through Microsoft Office.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-07 - Unpacking CVE-2021-40444- A Deep Technical Analysis of an Office RCE Exploit.pdf"
    ],
    "report_names": [
        "2022-01-07 - Unpacking CVE-2021-40444- A Deep Technical Analysis of an Office RCE Exploit.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536250,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653693441,
    "ts_modification_date": 1653693441,
    "files": {
        "pdf": "https://archive.orkl.eu/8a07bd029d9e6ae91ec93a7dcf0e3a0e8eb472c7.pdf",
        "text": "https://archive.orkl.eu/8a07bd029d9e6ae91ec93a7dcf0e3a0e8eb472c7.txt",
        "img": "https://archive.orkl.eu/8a07bd029d9e6ae91ec93a7dcf0e3a0e8eb472c7.jpg"
    }
}