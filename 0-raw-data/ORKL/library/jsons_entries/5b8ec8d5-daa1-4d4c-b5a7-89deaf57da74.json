{
    "id": "5b8ec8d5-daa1-4d4c-b5a7-89deaf57da74",
    "created_at": "2022-10-25T16:48:16.738108Z",
    "updated_at": "2025-03-27T02:13:57.135297Z",
    "deleted_at": null,
    "sha1_hash": "ecbed95d0006c27f040e1e371a8bc71084ae425d",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-06-15T11:26:43Z",
    "file_modification_date": "2020-06-15T13:55:07Z",
    "file_size": 2489298,
    "plain_text": "# INVISIMOLE: THE HIDDEN PART OF THE STORY\n### UNEARTHING INVISIMOLE’S ESPIONAGE TOOLSET AND STRATEGIC COOPERATIONS\n\n###### Authors: Zuzana Hromcová Anton Cherepanov\n\n\n-----\n\n#### CONTENTS\n\n1 EXECUTIVE SUMMARY\b����������������������������������������������������������������������������������������������������������������4\n\n2 ATTACKS AND INVESTIGATION \b��������������������������������������������������������������������������������������������������4\n\n2.1 InvisiMole’s toolset\b������������������������������������������������������������������������������������������������������������������������5\n\n2.2 Cooperation between InvisiMole and Gamaredon\b��������������������������������������������������������������5\n\n3 BUILDING BLOCKS\b������������������������������������������������������������������������������������������������������������������������6\n\n3.1 Structure\b������������������������������������������������������������������������������������������������������������������������������������������6\n\n3.1.1 InvisiMole blobs\b��������������������������������������������������������������������������������������������������������������6\n\n3.1.2 Execution guardrails with DPAPI\b���������������������������������������������������������������������������������7\n\n3.2 Payload\b��������������������������������������������������������������������������������������������������������������������������������������������8\n\n3.2.1 TCP downloader\b��������������������������������������������������������������������������������������������������������������9\n\n3.2.2 DNS downloader\b������������������������������������������������������������������������������������������������������������9\n\n3.2.3 RC2CL backdoor\b�������������������������������������������������������������������������������������������������������������13\n\n3.2.4 RC2FM backdoor\b�����������������������������������������������������������������������������������������������������������14\n\n4 DELIVERY METHOD\b���������������������������������������������������������������������������������������������������������������������16\n\n5 LATERAL MOVEMENT\b�����������������������������������������������������������������������������������������������������������������18\n\n5.1 Network vulnerabilities\b���������������������������������������������������������������������������������������������������������������18\n\n5.1.1 EternalBlue exploit chain\b���������������������������������������������������������������������������������������������18\n\n5.1.2 BlueKeep exploit chain\b������������������������������������������������������������������������������������������������20\n\n5.2 Trojanized software and documents\b���������������������������������������������������������������������������������������21\n\n6 EXECUTION CHAINS\b�������������������������������������������������������������������������������������������������������������������23\n\n6.1 Control Panel misuse chain\b������������������������������������������������������������������������������������������������������24\n\n6.1.1 Installation\b����������������������������������������������������������������������������������������������������������������������25\n\n6.1.2 Stage 1—Control Panel.lnk\b������������������������������������������������������������������������������������������25\n\n6.1.3 Stage 2—Control.js\b������������������������������������������������������������������������������������������������������25\n\n6.1.4 Stage 3—Control Panel\b������������������������������������������������������������������������������������������������26\n\n6.1.5 Stage 4—infocardadd.cpl\b��������������������������������������������������������������������������������������������27\n\n6.2 SMInit exploit chain\b��������������������������������������������������������������������������������������������������������������������27\n\n6.2.1 Installation\b����������������������������������������������������������������������������������������������������������������������27\n\n6.2.2 Stage 0—scheduled task\b��������������������������������������������������������������������������������������������28\n\n6.2.3 Stage 1—SMinit.exe\b������������������������������������������������������������������������������������������������������28\n\n6.2.4 Stage 2—SyncData entry\b��������������������������������������������������������������������������������������������29\n\n6.3 Speedfan exploit chain \b��������������������������������������������������������������������������������������������������������������30\n\n6.3.1 Installation\b����������������������������������������������������������������������������������������������������������������������30\n\n6.3.2 Stage 1—mscorscvs.exe\b�����������������������������������������������������������������������������������������������31\n\n6.3.3 Stage 2—NGEN.exe\b�������������������������������������������������������������������������������������������������������31\n\n6.3.4 Stage 3—Ngen.cab \b������������������������������������������������������������������������������������������������������32\n\n6.3.5 Stage 4—speedfan.sys exploit \b����������������������������������������������������������������������������������32\n\n\n-----\n\n6.3.6 Stage 5—kernel-mode inject \b�������������������������������������������������������������34\n\n6.3.7 Stage 6—loader\b�������������������������������������������������������������������������������������34\n\n6.3.8 Previous versions\b�����������������������������������������������������������������������������������36\n\n6.4 Wdigest exploit chain\b������������������������������������������������������������������������������������������37\n\n6.4.1 Installation\b������������������������������������������������������������������������������������������������37\n\n6.4.2 Stage 0—scheduled task\b���������������������������������������������������������������������39\n\n6.4.3 Stage 1—setupSNK.exe\b�������������������������������������������������������������������������39\n\n6.4.4 Stage 2—wdigest.dll\b������������������������������������������������������������������������������41\n\n6.4.5 Stage 3—M loader\b���������������������������������������������������������������������������������42\n\n6.4.6 Stage 4—A loader \b���������������������������������������������������������������������������������42\n\n6.4.7 Stage 5—B loader\b�����������������������������������������������������������������������������������45\n\n7 CONCLUSION\b����������������������������������������������������������������������������������������������������������45\n\n8 ACKNOWLEDGEMENTS \b����������������������������������������������������������������������������������������46\n\n9 INDICATORS OF COMPROMISE (IOCS) \b��������������������������������������������������������������46\n\n10 MITRE ATT&CK TECHNIQUES\b��������������������������������������������������������������������������������55\n\n10.1 InvisiMole\b���������������������������������������������������������������������������������������������������������������56\n\n10.2 RC2CL backdoor\b���������������������������������������������������������������������������������������������������58\n\n10.3 RC2FM backdoor \b������������������������������������������������������������������������������������������������60\n\nAuthors:\n\nZuzana Hromcová\n\nAnton Cherepanov\n\nJune 2020\n\n\n-----\n\n#### 1 EXECUTIVE SUMMARY\n\n[The InvisiMole group is a threat actor operating since at least 2013, whose malware was first reported by ESET](https://www.welivesecurity.com/2018/06/07/invisimole-equipped-spyware-undercover/)\n\nin 2018 in connection with targeted cyberespionage operations in Ukraine and Russia.\n\nWe previously documented its two feature-rich backdoors, RC2CL and RC2FM, that provide extensive\n\nespionage capabilities such as recording from the victim’s webcam and microphone, tracking the\n\ngeolocation of the victims, and collecting recently accessed documents.\n\nHowever, little was known about the rest of the group’s tactics, techniques and procedures (TTPs).\n\nIn late 2019, the InvisiMole group resurfaced with an updated toolset, targeting a few high-profile\n\norganizations in the military sector and diplomatic missions, both in Eastern Europe.\n\nESET researchers conducted an investigation of these attacks in cooperation with the affected organizations\n\nand were able to uncover the extensive, sophisticated toolset used for delivery, lateral movement and\n\nexecution of InvisiMole’s backdoors—the missing pieces of the puzzle in our previous research. The\n\n[investigation also uncovered previously unknown cooperation between the InvisiMole group and Gamaredon,](https://www.welivesecurity.com/2020/06/11/gamaredon-group-grows-its-game/)\n\na highly active threat group also operating since at least 2013, and mainly targeting Ukrainian institutions.\n\nAnalyzing InvisiMole’s updated toolset, we discovered that:\n\n- The changes in the InvisiMole malware (compared to versions analyzed in 2018) aim to prevent\n\nrevealing and reconstructing the operation\n\n- The updated InvisiMole toolset relies heavily on so-called “living off the land” techniques, abusing\n\nlegitimate applications to perform malicious operations while flying under the radar\n\n- InvisiMole utilizes a variety of vulnerable executables and exploits them for covert code execution and\n\nlong-term persistence\n\n- Apart from exploiting vulnerable executables it introduces to victims’ machines, InvisiMole also uses\n\nEternalBlue and BlueKeep exploits for lateral movement in its victims’ networks\n\n- InvisiMole employs long execution chains, crafted by combining legitimate tools and encrypted\n\nshellcode stored in the registry\n\n- The components are encrypted per-victim using a Windows feature named Data Protection API,\n\nwhich ensures that the payload can only be decrypted and executed on the affected computer, thus\n\nprotecting it from analysis by security researchers\n\n- The updated InvisiMole toolset features a new component that uses DNS tunneling for stealthier\n\nC&C communication\n\nIn this white paper, we will provide an in-depth technical analysis of the newest InvisiMole toolset, offering\n\na unique look into the TTPs of the elusive InvisiMole group.\n\n#### 2 ATTACKS AND INVESTIGATION\n\nIn our tracking of InvisiMole activity, we detected a new campaign using updated versions of InvisiMole’s\n\nRC2FM and RC2CL backdoors.\n\nAccording to our telemetry, the campaign was ongoing from late 2019 to the time of writing this report\n\nand targeted high-profile organizations in Eastern Europe, including military organizations and diplomatic\n\nmissions. Like in the previously reported InvisiMole campaign, the attacks were highly targeted, with naught\n\nbut a few dozen computers affected.\n\n\n-----\n\n##### 2.1 InvisiMole’s toolset\n\nOur telemetry suggests that the attackers were actively developing their malware throughout the\n\ncampaign, redesigning and recompiling its components, as well as introducing new ones.\n\nFor example, we detected several versions of InvisiMole’s loader and RC2FM backdoor, with one of the\n\nsamples[1] apparently freshly compiled before being deployed and detected by ESET. We also found that later\n\nin the operation, the attackers abandoned the use of the PE format for their files, in an attempt to avoid\n\ndetection. As for the newly introduced components, we discovered a previously unreported TCP downloader\n\nand a DNS downloader, the latter using DNS tunneling to communicate with the C&C server. These are\n\ndescribed in detail in the TCP downloader and DNS downloader sections.\n\nOverall, the campaign is characterized by long execution chains with multiple layers of per-victim\n\nencryption, making it difficult to reconstruct the attack. However, thanks to cooperating directly with the\n\naffected organizations, we were able to recover the payloads and reconstruct four execution chains, which\n\nare described in detail in the Execution chains section.\n\nIn these chains, the attackers used several interesting living off the land techniques—they abuse legitimate\n\n[applications (also called living off the land binaries or LOLBins) to execute their own code, set up persistence,](https://github.com/LOLBAS-Project/LOLBAS/blob/master/README.md)\n\nperform lateral movement and other operations, aiming to bypass application whitelisting and fly under the\n\nradar. More information on this tactic can be found in the Delivery method and Execution chains sections.\n\nFurthermore, we found that InvisiMole delivers vulnerable executables to compromised computers and\n\nexploits them for covert code execution and long-term persistence.\n\nSpecifically, the attackers brought a vulnerable speedfan.sys driver onto a compromised computer and\n\nexploited it in order to inject InvisiMole into a legitimate process from kernel mode (see the Speedfan exploit\n\n_[chain section). This technique previously was used, for example, by the Slingshot APT and has been referred to](https://securelist.com/apt-slingshot/84312/)_\n\n[as Bring Your Own Vulnerable Driver (BYOVD) by fellow researchers.](https://medium.com/@gorkemkaradeniz/defeating-runasppl-utilizing-vulnerable-drivers-to-read-lsass-with-mimikatz-28f4b50b1de5)\n\nBesides the driver, the attackers delivered a vulnerable Windows component from Windows XP\n\nand exploited its input validation vulnerability (see the Wdigest exploit chain section), or a vulnerable\n\nthird‑party software package and exploited its stack overflow vulnerability (see the SMInit exploit chain\n\nsection)—a technique we named Bring Your Own Vulnerable Software (BYOVS).\n\nFor lateral movement, we observed that the InvisiMole group steals documents or software installers\n\nfrom the compromised organization, and replaces them in the original locations with their own trojanized\n\nversions (see the Trojanized software and documents section), or uses EternalBlue and BlueKeep exploits to\n\nspread to vulnerable hosts within the network (see the Network vulnerabilities section).\n\n##### 2.2 Cooperation between InvisiMole and Gamaredon\n\nDuring our investigation, we discovered evidence of collaboration between the InvisiMole group and the\n\nGamaredon group.\n\nIn February 2020, we detected attempts to deploy the InvisiMole malware using server infrastructure that\n\n[is known to be used by the Gamaredon group. Specifically, we identified samples of Gamaredon group’s .NET](https://www.welivesecurity.com/2020/06/11/gamaredon-group-grows-its-game/)\n\ndownloader (detected as MSIL/Pterodo) that download and execute an InvisiMole TCP downloader (see\n\ndetails in the Delivery method section).\n\nOur research showed that this component was used only against a small number of Gamaredon victims,\n\nwhich may suggest that targets considered particularly significant by the attackers are “upgraded” from\n\nGamaredon’s relatively simple .NET downloader to the advanced InvisiMole malware.\n\n1 SHA-1: 27FC1DCB1B3DCA3E496F799A2944E4FB070AF39C\n\n\n-----\n\nWe previously suspected that InvisiMole is only deployed after the attackers have infiltrated the network,\n\nand possibly gained administrative privileges, as many of InvisiMole’s execution methods require elevated\n\nrights. This newly discovered delivery method supports that assumption, and allows the attackers to devise\n\nmore creative and stealthier ways to install and execute their malware.\n\nThis discovery also reveals a previously unreported cooperation between the Gamaredon and InvisiMole\n\ngroups. However, it should be noted these two groups use different TTPs and a varying level of\n\nsophistication—the Gamaredon group seems to make no effort in trying to stay under the radar, in contrast\n\nwith the stealthiness of InvisiMole demonstrated in the recent campaign.\n\nDespite the evidence of collaboration, we consider them to be two distinct groups with different TTPs,\n\nrather than a single threat actor.\n\n#### 3 BUILDING BLOCKS\n\nBefore we explain various scenarios of how InvisiMole is executed, installed and spread within the network,\n\nwe introduce the basic building blocks of these execution chains:\n\n- Payload components delivered in the final stages\n\n- The techniques used to avoid detection of these components\n\nOther specifics of the execution chains, including legitimate tools misused for persistence and vulnerable\n\ncomponents exploited for covert execution of the chains, will be discussed throughout the paper.\n\n##### 3.1 Structure\n\nTo thwart detection and analysis, InvisiMole uses a specific structure for its components, and execution\n\n**guardrails to ensure the malicious payload can only be decrypted on the victim’s computer.**\n\n###### 3.1.1 InvisiMole blobs\n\nInvisiMole’s characteristic shellcode-like structure is used for most of its components, including its RC2CL\n\nbackdoor, downloaders and many intermediate stages. We refer to this structure as an InvisiMole blob.\n\nAs Figure 1 shows, an InvisiMole blob starts with a magic value:\n\n- `64 DA 11 CE for 64-bit payloads`\n\n- `86 DA 11 CE for 32-bit payloads`\n\nwith the offset to the entry point located at a fixed address:\n\n- `0x45 for 64-bit payloads`\n\n- `0x3D for 32-bit payloads`\n\nInvisiMole’s loaders are able to recognize and load this structure. The loaders write the addresses of the\n```\nGetProcAddress and LoadLibraryA functions to specific offsets (0x04 and 0x0C for 64-bit blobs; 0x04\n\n```\nand 0x08 for 32-bit blobs). Next, they pass execution to the blob, which then resolves its other imports.\n\nThe reason for using a custom executable file format, rather than the common PE format, is likely\n\nan attempt to prevent detection and make analysis more difficult.\n\nOn the other hand, the parameters of this structure helped us identify InvisiMole components and link them\n\ntogether, in particular to link InvisiMole with the Gamaredon threat group and reconstruct InvisiMole’s\n\nexecution chains (see the Delivery method and Execution chains sections).\n\n\n-----\n\nFigure 1 // Part of 32-bit InvisiMole blob (left) and InvisiMole loader handling the blob (right)\n\nNote that older InvisiMole backdoors used a different structure, but it was also shellcode starting with\n\na specific magic value—F9 FF D0 DE for 32-bit, 64 FF D0 DE for 64-bit payloads.\n\n###### 3.1.2 Execution guardrails with DPAPI\n\nA notable change in the newest InvisiMole toolset is the introduction of execution guardrails. InvisiMole\n\nindividually encrypts its components per-victim, directly on the compromised computer, to make sure the\n\npayload can only be decrypted (and executed) on the target computer.\n\nTo place these execution guardrails, it uses a Windows feature called Data Protection API (DPAPI).\n\nDPAPI uses a symmetric encryption scheme with a key derived from user’s login secrets.\n\nTwo API functions are critical for this process:\n\n- `CryptProtectData for data encryption`\n\n- `CryptUnprotectData for data decryption`\n\n_[The decryption must be done on the same computer where the data were encrypted.](https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata)_\n\nThe legitimate, intended use of DPAPI is local storage of credentials, such as login or Wi-Fi passwords,\n\nfor example by web browsers or mail applications. InvisiMole uses it to protect its payload from\n\n**security researchers—even if they find InvisiMole’s components in telemetry or on malware**\n\n**sharing platforms, they can’t decrypt it outside of the victim’s computer.**\n\nWe were able to overcome this obstacle by cooperating directly with the targeted organizations and having\n\nthe payload decrypted on the exact computers. This allowed us to analyze the decrypted payloads and\n\nfind further clues and components. Typically, a decrypted InvisiMole blob led to another DPAPI-encrypted\n\ncomponent, and so we worked iteratively to recover InvisiMole’s stages one by one. We present the\n\nresults of these efforts in the Execution chains section.\n\n\n-----\n\nFigure 2 // InvisiMole’s loader uses CryptUnprotectData API to decrypt the next stage, and then checks the decrypted\nblob for InvisiMole magic value 64 DA 11 CE\n\nNote that the use of execution guardrails and long execution chains is a feature new to the latest InvisiMole\n\nversion. Previously, its backdoors were embedded in the binary resources of the loader, encrypted with\n\na simple XOR cipher using a hardcoded key.\n\n##### 3.2 Payload\n\nInvisiMole uses a combination of four payload components:\n\n- Updated versions of the previously known RC2CL and RC2FM backdoors\n\n- Two new downloaders—TCP- and DNS-based\n\nInvisiMole’s flagship RC2CL backdoor has been adapted to the new structure and is deployed on the\n\ncompromised machines as the final stage.\n\nIn some instances, we observed InvisiMole’s second, smaller backdoor RC2FM deployed along with the RC2CL\n\nbackdoor, or within a short time span. However, the feature-rich RC2CL seems to be used more prominently.\n\nA notable addition to InvisiMole’s toolset is a DNS downloader, with its C&C communication built on top\n\n**of the DNS protocol. Along with the new TCP downloader, its function is to download and execute updates**\n\nfrom the server, or to deploy additional components or external tools.\n\nFigure 3 illustrates C&C servers used by these four InvisiMole payload components.\n\n\n-----\n\nFigure 3 // C&C servers used by InvisiMole’s components\n\n###### 3.2.1 TCP downloader\n\nThe new TCP downloader is a simple component used to download further InvisiMole modules. Notably,\n\nInvisiMole uses this component as the first payload delivered to a newly-compromised computer—see the\n\n_Delivery method and Lateral movement sections for how this component is used when InvisiMole gains the_\n\ninitial foothold to and moves across the network.\n\nThe downloader uses a simple TCP protocol where it sends the name of the compromised PC to InvisiMole’s\n\nC&C server and expects an XOR-encrypted InvisiMole blob as the response.\n\nThis blob is then decrypted and loaded in a new thread.\n\n###### 3.2.2 DNS downloader\n\nThe more notable addition to InvisiMole’s arsenal is its DNS downloader. Like the TCP downloader, this\n\nplugin is used to download additional components from the remote server and execute them. However,\n\nwhile the former is used to obtain the next stage after InvisiMole has infiltrated a new computer, the DNS\n\n**downloader is deployed as one of the final stages and used in the long run, allowing the attackers to**\n\n**push updates. That’s why it uses DNS tunneling—a stealthier way to perform C&C communications.**\n\nWith DNS tunneling, the compromised client does not directly contact the C&C server; it only communicates\n\nwith a benign DNS server where it sends requests to resolve a domain to IP address. The DNS server then\n\ncontacts the name server responsible for that domain, which is an attacker-controlled server, and relays its\n\nresponse back to the client, as illustrated in Figure 4.\n\n**The actual C&C communication is embedded in the DNS requests and DNS replies, unbeknownst to**\n\n**the benign DNS server that serves as a middleman in the communication.**\n\n\n-----\n\nFigure 4 // Overview of DNS tunneling\n\nUnrelated to its DNS tunneling functionality, this component also serves as a loader for previously installed\n\nInvisiMole blobs stored under registry values HKCU\\Software\\Microsoft\\EventSystem\\AutoEx{A,B,C}.\n\n###### Communication protocol\n\nFor C&C communication, the DNS downloader uses a custom implementation of DNS tunneling, building\n\nits own protocol on top of the DNS protocol. The downloader sends DNS NULL and DNS AAAA requests for\n\nsubdomains of attacker-controlled domain names, such as 153[.]re.\n\nThe downloader encodes the clientserver part of the protocol in the subdomain. The subdomain is\n\n**generated for each request from information such as the request type, current timestamp, PC name,**\n\nsystem volume serial number and other identifiers, using the following domain encoding algorithm:\n\n1. The binary message is converted to bit strings, with LSB first, e.g. 0xC0  “00000011”\n\n2. The resulting long bit string is padded to multiples of 5.\n\n3. The bit string is encoded using a modified base32 encoding, with the custom conversion table\n```\n abcdefghiklmnopqrstvxyz123456789 and no padding.\n\n```\nExample of a generated subdomain with encoded message:\n\na8y3g5f2h2aaybyfplr4xcbaaaaaaaaaaaaaahoraaaaaaaaaaaaaaaagiacaa.aaaaaaaaaaaae.153[.]re\n\nFor the serverclient part of the protocol, the attacker-controlled name server encodes the response\n\n**in DNS NULL records or in DNS AAAA records, instead of what normally would be a list of IPv6 addresses.**\n\nThe size of a DNS record is limited, so a typical communication between the DNS downloader and the C&C\n\nserver consists of a series of DNS requests and replies, with the command or file transmitted in chunks.\n\nTo keep track of such a pseudo-connection, both client- and server-side requests have embedded type and\n\ntransmission ID. All possible request types are listed in Table 1.\n\n\n-----\n\nTable 1 // InvisiMole’s DNS tunneling protocol request types\n\n**ID** **Sender** **Comment**\n\nD7C0 Client Start of communication\n\nD7C2 Server No operation\n\nD7C3 Server Start of transmission (of blob)\n\nD7C4 Client/server Data transmission\n\nD7C5 Server Start of transmission (of EXE file)\n\nD7C6 Server Start of transmission (of DLL file)\n\nD7C7 Server Sleep for 30 minutes\n\nD7C8 Server Sleep for 2 hours\n\nD7C9 Server\n\nD7CA Server Load blob from the specified registry key\n\nD7CB Server\n\nEach pseudo-connection consists of the following steps, with one of the possible scenarios being illustrated\n\nin Figure 5:\n\n1. The client sends a 0xD7C0 request to the server to initiate the pseudo-connection.\n\n2. The server replies with a command to:\n\na. sleep for a configured amount of time (0xD7C2/0xD7C7/0xD7C8 requests),\n\nb. load InvisiMole blob from a specified registry key/value (0xD7C9/0xD7CA/0xD7CB\n\nrequests), or\n\nc. start transmission of a new module (0xD7C3/0xD7C5/0xD7C6 requests).\n\n1. In case a transmission is started, the server sends the module size, transmission ID and then the server\n\nand client continue to communicate using the 0xD7C4 request type, until the full module is transmitted.\n\n2. Finally, the DNS downloader executes the module or loads it in a new thread. If the transmitted module\n\nis a DLL or EXE file, it is first dropped under a randomly generated name in the %APPDATA%\\Microsoft\\\n```\n AddIns\\ folder.\n\n```\n**DNS uses UDP as a transport protocol in most cases, which is not reliable, and so the DNS**\n\n**downloader can repeat each DNS request for up to 4 times, to provide better stability for the**\n\n**pseudo-connection.**\n\n\n-----\n\nFigure 5 // Example of how the DNS downloader retrieves an InvisiMole blob from the server\n\n###### Detection prevention\n\nTo make sure the C&C communication stays unnoticed, the DNS downloader refrains from contacting the\n\nserver if it suspects it is executed in an analytical environment.\n\nBefore it contacts the C&C server, it checks whether the compromised computer has network connectivity\n\nand access to a DNS server, by sending DNS A queries (using DnsQuery_A API) for these legitimate domains:\n\n- time.windows.com\n\n- crl.microsoft.com\n\n- download.windowsupdate.com\n\n- cdn.globalsign.com\n\nIt also checks for presence of selected network sniffers, by looking for artifacts listed in Table 2 on the\n\nsystem. If detected, the downloader waits 60 seconds until the next network activity attempt.\n\n\n-----\n\nTable 2 // Artifacts associated with network sniffers scanned by the DNS downloader\n\n**Object type** **Object name** **Associated network sniffer**\n```\n              Wireshark-is-running-{9CA78EEA-EA4D-4490-9240\n```\nMutex Wireshark\n```\n              FC01FCEF464B}\n\n```\n`TCPViewClass` TCPView\nWindow name\n\n`PROCMON_WINDOW_CLASS` ProcMon\n\n`procmon.exe` ProcMon\n\n\nRunning process\n\n\n`wireshark.exe` Wireshark\n\n`dumpcap.exe` Dumpcap (Wireshark)\n\n\n###### 3.2.3 RC2CL backdoor\n\nRC2CL is the larger of InvisiMole’s backdoors, with extensive espionage capabilities. Depending on the\n\nversion, this backdoor supports up to 87 commands, with capabilities such as:\n\n- Turning on webcam and microphone devices to capture photos, record video and sound;\n\n- Capturing screenshots of display or individual windows;\n\n- Collecting network configuration information, including information about wireless networks (MAC\n\naddress, SSID, beacon interval), that can be used for geo-location of the victims;\n\n- Collecting information about installed software, about software used by specific users, and about\n\nsoftware executed on user login;\n\n- Monitoring, sorting and collecting specific documents, such as recently accessed documents.\n\n[Please refer to our earlier blogpost for the full list of RC2CL backdoor’s commands.](https://www.welivesecurity.com/2018/06/07/invisimole-equipped-spyware-undercover/)\n\nIn this recent campaign, the backdoor continues to support these capabilities, with added functionality to\n\n**scan the compromised network for hosts that support the vulnerable SMBv1.0 protocol. InvisiMole**\n\nuses this capability to spread in the network via the EternalBlue exploit, as detailed in the EternalBlue exploit\n\n_chain section._\n\nThe backdoor also continues to use a central staging location for collected data prior to the exfiltration.\n\nUpdated were the magic values used as markings for various types of data, as listed in Table 3, as well as\n\nspecific file and folder name prefixes:\n\n- Filename prefixes: “T0Q2_”, “~S0PM”, “~A0FM”, “~N031E”, “~E070C”, “70zf_”\n\n- Subfolder name prefixes: “~T0QM”, “MT0”, “CE55”, “~70Z63”, “~D0E5”\n\n\n-----\n\nTable 3 // Magic values—the first four bytes of the files, storing various types of collected data.\n\n**Magic value** **File content**\n\n`91 89 01 DD` Unknown\n\n`93 21 01 DA` Audio recordings\n\n`93 89 01 DA` Webcam photos\n\n`95 89 01 DA` Audio recordings\n\n`A1 CA F1 08` Data from removable drives\n\n`A1 CE F2 24` Unknown\n\n`A2 CA F1 08` Data from removable drives\n\n`B1 CB F2 18` zlib-compressed packages\n\n`BA AB 00 19` Data from removable drives\n\n`C0 AF F2 08` Internal data\n\n`C0 CC F1 08` Data from removable drives\n\n`DF E4 3A 08` Screenshots\n\nFor C&C communication, RC2CL mimics HTTP protocol with custom HTTP “verbs”—HIDE, ZVVP and NOP.\n\nThe new versions of the RC2CL backdoor also have added measures to avoid detection—the backdoor\n\ninjects itself into another process, rather than running directly, if Bitdefender firewall is detected running,\n\nthat is, if any of these artifacts is found on the system:\n\n- Loaded driver named bdfwfpf.sys\n\n- Running process with bitdefender substring in name\n\n- Substring enabled=”1” in any of these Bitdefender settings files:\n\n%PROGRAM_FILES%\\Bitdefender\\Bitdefender\\settings\\firewall\\settings.xml\n```\n      %PROGRAM_FILES%\\Bitdefender\\Bitdefender 2010\\Firewall\\settings.xml\n\n```\n%PROGRAM_FILES%\\Bitdefender\\Bitdefender 2013\\settings\\firewall\\settings.xml\n\n%PROGRAM_FILES%\\Bitdefender\\Bitdefender 2015\\settings\\firewall\\settings.xml\n\n%PROGRAM_FILES%\\Bitdefender\\Bitdefender 2016\\settings\\firewall\\ig_settings.xml\n\n%PROGRAM_FILES%\\Bitdefender\\Bitdefender 2017\\settings\\firewall\\ig_settings.xml\n\n###### 3.2.4 RC2FM backdoor\n\nRC2FM is the smaller of InvisiMole’s backdoors, supporting up to 19 commands depending on the version.\n\n[Several commands of the older version were used to collect and exfiltrate documents—in specific folders,](https://www.welivesecurity.com/2018/06/07/invisimole-equipped-spyware-undercover/)\n\non mapped drives or network shares. In the new version, the backdoor can also exfiltrate jpeg images from\n\nconnected devices using the WPD interface. The attackers probably use this capability to exfiltrate photos\n\n**from Media Transport Protocol (MTP) devices, e.g. mobile devices. Many people take photos with**\n\n**their smartphones, so it indeed makes sense for an espionage actor to collect information not only**\n\n**from laptop or desktop computers, but also from smartphones.**\n\nThis functionality is achieved using functions such as IPortableDeviceValues and\n```\nIPortableDeviceConnector; a fragment is illustrated in Figure 6.\n\n```\n\n-----\n\nFigure 6 // Part of decompiled RC2FM backdoor responsible for opening a connected device via the WPD interface\n\nOther added capabilities include keylogging, process discovery, UAC bypass, and ability to create and operate\n\na reverse shell.\n\nSimilar to the RC2CL backdoor, the newest version of RC2FM has added means to avoid detection.\n\n- It modifies its behavior if selected AV products are detected. More specifically, it suppresses the\n\nkeylogging functionality or injects itself into another process if these processes are found running:\n\n**Process name** **Associated AV**\n\n`qhsafetray.exe` 360 Total Security\n\n`avastsvc.exe` Avast Free Antivirus\n\n`bdagent.exe` Bitdefender Total Security\n\n- It terminates itself if a virtualized environment is detected.\n\na. VirtualBox is assumed if the HKEY_LOCAL_MACHINE\\HARDWARE\\ACPI\\DSDT\\VBOX__\n\nregistry key exists\n\nb. [Virtual PC environment is tested using vpcext instruction](https://shasaurabh.blogspot.com/2017/07/virtual-machine-detection-techniques.html)\n\nc. [VMware environment is tested using cpuid instruction, searching for VMwareVMware signature](https://kb.vmware.com/s/article/1009458)\n\n\n-----\n\n#### 4 DELIVERY METHOD\n\n[When we first reported on InvisiMole’s capabilities in 2018, we didn’t know how it gained its initial foothold in](https://www.welivesecurity.com/2018/06/07/invisimole-equipped-spyware-undercover/)\n\n\nthe network:\n\n\n## “\n\n\n_All infection vectors are possible, including installation facilitated by_\n\n_physical access to the machine._\n\n\nHowever, there were hints the attackers had already obtained administrative privileges before InvisiMole\n\nwas installed on the system—InvisiMole’s loader was placed in the Windows directory. Similarly, most of the\n\n\nexecution methods used in the recent campaign require elevated privileges, as documented in the Execution\n\n_chains section._\n\n\nWe solved the mystery in 2020 when we observed InvisiMole being delivered by network\n\n**[infrastructure used by the Gamaredon threat group—specifically by Gamaredon’s .NET downloader[2] that](https://attack.mitre.org/groups/G0047/)**\n\n\nESET detects as MSIL/Pterodo.\n\nThis Gamaredon .NET downloader delivers a 7-Zip SFX package[3], which unpacks to a legitimate tool\n\n\n_[winapiexec[4]—a small tool that enables running Windows API functions through command line parameters.](https://rammichael.com/winapiexec)_\n\nThe attackers execute the tool using a batch script shown in Figure 7, with shellcode in the command line.\n\n\nFigure 7 // Batch script that passes InvisiMole’s shellcode to the legitimate winapiexec tool\n\nWinapiexec interprets the command line arguments as Windows API calls, and so it allocates new memory,\n\n\ncopies the supplied shellcode into that memory and creates a new thread to execute it. The shellcode is\n\nthe InvisiMole TCP downloader, connecting to 80.255.3[.]66:443 to download and then execute a 64-bit\n\n\nInvisiMole blob (with 64 DA CE 11 magic).\n\n2 SHA-1: 857EEB37DB2B666981779005DD5E55CEA7A53233\n3 SHA-1: 303A63CE12AD42900DA257428E2FD4DE4F9829DC\n4 ESET classifies this tool as a potentially unsafe application, with detection names Win{32,64}/Winapiexec.A potentially unsafe application\n\n\n-----\n\nThe components used in InvisiMole’s delivery chain are illustrated in Figure 8.\n\nFigure 8 // Overview of InvisiMole’s delivery chain\n\nLater, we observed a variation of this delivery method, where the Gamaredon .NET downloader delivered\n\nInvisiMole’s TCP downloader[5] with added support for user-configured proxies. The downloader was probably\n\nupdated after an unsuccessful attempt to use a direct internet connection without using the proxy.\n\nTable 4 // InvisiMole’s components delivered by Gamaredon’s .NET downloader\n\n**SHA-1** **Filename** **Comment**\n```\n 303A63CE12AD42900DA257428E2FD4DE4F9829DC \n```\ndroppers\n```\n 4B8E11E0734D3109627FF8871EF7DB14C0DE9C41 \n```\n`4A6DC6A32A777DC5DD47221BF79604BC0258A987` `intel_log64.exe` winapiexec tool\n```\n 6F98B12C98DA1FCFF078256970E9B8EF12139640 api64.cmd\n\n```\nbatch scripts\n```\n 76FC2E29524C6AD58B0AF05251C419BB942CCED0 intel_log64.cmd\n\n```\nNote that the Gamaredon group typically uses spearphishing emails as the initial vector, attaching documents\n\nwith malicious macros—which is likely how the network was first compromised in this case as well.\n\n[As previously reported, this group is known for using simple tools, with the main objective to infiltrate the](https://www.welivesecurity.com/2020/06/11/gamaredon-group-grows-its-game/)\n\ntarget organization and spread as far as possible in the target’s network. Now we know they are paving\n\n**the way for the more sophisticated InvisiMole toolset.**\n\nThis tactic of using a simpler backdoor to infiltrate the target network, and only then deliver the more\n\nsophisticated tool, has several benefits for the attackers. In this case, the Gamaredon toolset is used for\n\nreconnaissance—to confirm the target is of special interest, to collect information about security products\n\nor security policies and to use this information to customize the next steps—for example, to choose which of\n\nInvisiMole’s execution chains should be used.\n\nThis all minimizes the risk that the more advanced infiltration—InvisiMole’s toolset—will be discovered.\n\nNote that we were able to trace the cooperation between Gamaredon and InvisiMole groups back to 2018,\n\nbut only after the publication of our first blogpost about InvisiMole. This discovery is thus only relevant for\n\nthe recent campaign, and does not invalidate our earlier hypothesis about possible physical access.\n\n5 SHA-1: 4B8E11E0734D3109627FF8871EF7DB14C0DE9C41\n\n\n-----\n\n#### 5 LATERAL MOVEMENT\n\nOnce in the compromised network, InvisiMole uses two methods to move laterally—actively by exploiting\n\nvulnerabilities in network protocols, and passively by deploying trojanized applications and documents, while\n\nrelying on them to be shared and executed by the victims themselves.\n\n##### 5.1 Network vulnerabilities\n\n[We have observed InvisiMole using the BlueKeep and EternalBlue vulnerabilities (CVE-2019-0708 and](https://en.wikipedia.org/wiki/BlueKeep)\n\nCVE‑2017‑0144, respectively) to spread within the network and deploy InvisiMole’s backdoors or downloaders.\n\nThree of InvisiMole’s components assist by scanning the compromised network:\n\n- The Portscan plugin searches for open ports; see Figure 9 for examples of strings extracted from the plugin.\n\n- The BlueKeep plugin searches for hosts vulnerable to the BlueKeep vulnerability in the RDP protocol.\n\n- The RC2CL backdoor searches for hosts vulnerable to the EternalBlue vulnerability in the SMB protocol.\n\nFigure 9 // Selected strings extracted from the Portscan plugin\n\n###### 5.1.1 EternalBlue exploit chain\n\nInvisiMole deploys its RC2CL backdoor and TCP downloader on hosts vulnerable to EternalBlue, using\n\ncomponents shown in Figure 10.\n\nFigure 10 // InvisiMole’s lateral movement via the EternalBlue exploit\n\n###### Reconnaissance\n\nTo identify vulnerable hosts in the compromised network, InvisiMole uses the added functionality in the\n\nRC2CL backdoor. Its command 222 was previously used for controlling backdoor configuration values—now\n\nthe attackers use it to send a range of IP addresses to the compromised computer.\n\nThe backdoor first tests whether these addresses are active by sending them ICMP echo requests, and\n\nretrieves their MAC addresses using the SendARP API.\n\n\n-----\n\nTo determine whether the host supports the vulnerable SMBv1.0 protocol, the backdoor:\n\n- Opens SMB session on port 445 (and optionally on another port).\n\n- Sends SMB_COM_NEGOTIATE packet (0x72) to negotiate the SMB protocol (see Figure 11). It only\n\nlists “NT LM 0.12” as a supported dialect, forcing the server to choose SMBv1.0 protocol for the session,\n\nas long it is supported by the server.\n\nFigure 11 // SMB_COM_NEGOTIATE packet\n\n- Sends SMB_COM_SESSION_SETUP_ANDX packet (0x73) to setup the SMB session (see Figure 12).\n\nThe only command in the packet is No further commands (0xFF). The backdoor doesn’t send any more\n\ncommands within the session.\n\nFigure 12 // SMB_COM_SESSION_ANDX packet\n\n- Logs off the session by sending SMB_COM_LOGOFF_ANDX packet (0x74) with the command\n\n_No further commands (0xFF), as shown in Figure 13._\n\nFigure 13 // SMB_COM_LOGOFF_ANDX packet\n\nThe results of this scan are reported back to the C&C server.\n\nAfter identifying vulnerable hosts, we assume the attackers push a tool that tries to exploit the vulnerability\n\nvia the same backdoor—RC2CL already has mechanisms in place to download and execute additional code.\n\n\n-----\n\n###### Exploit\n\nWe haven’t seen the actual code used by the attackers to exploit the vulnerability. However, on multiple\n\n[computers within one of the targeted networks, we detected DoublePulsar, a backdoor typically deployed by](https://en.wikipedia.org/wiki/DoublePulsar)\n\nthe EternalBlue exploit.\n\nMoreover, we reviewed Windows Security Logs from the network and identified the following sequence\n\nof events:\n\n- An SMB session was created.\n\n- A few seconds later, InvisiMole’s loader[6] was executed.\n\nAs shown in Figure 14, the loader’s internal name is PULSAR_LOADER.DLL, likely referring to being deployed\n\nby the DoublePulsar backdoor.\n\nFigure 14 // InvisiMole’s component with internal name `PULSAR_LOADER.dll`\n\n###### Payload\n\nThe loader deployed by the DoublePulsar backdoor is bundled with an InvisiMole blob that is the\n\n**TCP downloader, used to download and execute additional InvisiMole blobs.**\n\nWe also detected another loader[7] with the same internal name PULSAR_LOADER.DLL, this time bundled\n\nwith InvisiMole’s RC2CL backdoor.\n\n###### 5.1.2 BlueKeep exploit chain\n\nAs another lateral movement technique, InvisiMole exploits the BlueKeep vulnerability in the RDP protocol\n\nto deploy InvisiMole’s TCP downloader on the target machines, as illustrated in Figure 15. In this case, all\n\nparts of the exploit—from identifying the vulnerable hosts to deploying the malicious payload—are bundled\n\nin a single component, the BlueKeep plugin, which is implemented as a 64-bit InvisiMole blob. Figure 16\n\nshows a fragment of the strings extracted from the plugin, referring to exploiting the vulnerability.\n\nFigure 15 // Three parts of BlueKeep plugin\n\n6 SHA-1: 02F4242F7CA7289C8EDFA7B4F465C62C7A6815E2\n7 SHA-1: `00EA86AAB3D616A24A5E13D592FABC26416DFDBD`\n\n\n-----\n\n###### Reconnaissance\n\nReconnaissance is implemented in the first part of the BlueKeep plugin, which scans the network for hosts\n\nvulnerable to the BlueKeep vulnerability.\n\n###### Exploit\n\n[The main part is ported from the open-source Metasploit implementation of the BlueKeep exploit.](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb)\n\n###### Payload\n\nAs the user-mode code, the plugin finally executes the embedded InvisiMole TCP downloader.\n\nFigure 16 // Selected strings hardcoded in the BlueKeep plugin\n\n##### 5.2 Trojanized software and documents\n\nApart from exploiting network vulnerabilities, the attackers also use a more passive approach to move\n\nlaterally. They use trojanized files—SFX archives bundling InvisiMole malware with a benign software\n\ninstaller or, in one instance, a PDF document.\n\nWhen executed, the SFX archive drops and executes or opens the benign file, while it also loads an\n\nembedded InvisiMole blob that drops InvisiMole components and installs them on the system. Trojanized\n\nfiles are used to distribute two of InvisiMole’s execution chains, as illustrated in Figure 17 and described in the\n\n_Control Panel misuse chain and SMInit exploit chain sections._\n\n\n-----\n\nFigure 17 // Two InvisiMole execution chains delivered by trojanized files\n\nWe have detected almost 30 different trojanized applications—among them Bitdefender USB Immunizer, 7-Zip,\n\nremote desktop and employee monitoring utilities, but also region-specific software and software specific\n\nto the organization’s sector. Along with the PDF document, the benign versions of these applications were\n\nclearly stolen from the compromised organization.\n\n**InvisiMole replaces the original files on the compromised computer with the trojanized versions,**\n\n**while preserving their names, icons and metadata. This is both a lateral movement and persistence**\n\n**technique, as users naturally open and share their own documents.**\n\nThis technique is especially powerful if the trojanized file happens to be a software installer placed on\n\na central server—a common way to deploy software in larger organizations. That way, InvisiMole is\n\norganically distributed to many computers that use this server.\n\n\n-----\n\nTable 5 // Examples of trojanized software, stolen from the compromised organization and bundled with InvisiMole.The\nlist excludes documents and software specific to the affected organization.\n\n**SHA-1** **Filename** **Application**\n\n`125FCA6EBD82682E51364CF93C9FFA8EB4F6CA5F` `WebComponents.exe` Web Components (Hikvision)\n\n`3B923FA1E5DCB4F65DAA138BECEB123D7C431D1B` `AIDA64.exe` AIDA64 Network Audit\n\n`3BB2C05DEA077835A79499A0BB81410D27EEBFAF` `poweriso6-full.exe` PowerISO Setup\n\n`4C13AD9AD9C134DE15F3AE5E2F0D2EC1E290DEE8` `SamsungUniversalPrintDriver3.exe` Samsung Universal Print Driver\n\n`728386C6D6EAF43148FE25F86E6AF248019D9842` `Daemon.Tools.Lite.v5.0.1.0407.exe` DAEMON Tools\n\n`793F4DD2B765ECD962A053246646ED0D6144D249` `adberdr11000_ru_ru.exe` Adobe Reader\n\nUltraVNC (remote desktop\n```\n 8147E85E13B3624FA290F1F218647A0D1FD70204 UltraVNC_1_2_24_X86_Setup.exe\n```\nsoftware utility)\n\n`8C5F463FA79601DE38D0A77808226B1A8E67459A` `7-Zip.exe` 7-Zip\n\n`9B1E0A22DEB124FF36FCF7ED2EA82E799B49B070` `lanscope_setup.exe` LanScope (employee monitoring)\n\nUltraVNC (remote desktop\n```\n 9B48090704C3F62D6B768780845E2D04862F5219 UltraVNC_1_2_24_X64_Setup.exe\n```\nsoftware utility\n\n`CD3419B4B3958BE5BE1CAEA60A4EE98E4D427A6D` `epson373260eu.exe` Epson (printer driver)\n\n`D5D3A01A5944D55E5DDF1F915E88043691BE6F58` `putty.exe` Putty\n\n`D8EB2429253E82729F34373068EC350D1B2DA8AB` `WinSetupFromUSB-1-6.exe` WinSetupFromUSB\n\nBitDefender USB Immunizer\n```\n DDB871AD5823BE31F5176F2B0CE149D4B6E44F24 BDUSBImmunizerLauncher.exe\n```\nLauncher\n\nGeovision DMmultiview Software\n```\n E936E857A812690178ED049FD4A1766E281B9F1D DMMultiView.exe\n```\nfor Remote Monitoring\n\n#### 6 EXECUTION CHAINS\n\nFor execution and persistence, InvisiMole’s operators use long execution chains and rely on living-off-the\n‑land. We have observed the attackers using a BYOVD technique, and the aforementioned BYOVS technique,\n\nto deliver vulnerable components to the system and then exploit their vulnerabilities—not to gain initial\n\n**access to the system, but to achieve covert code execution and long-term persistence.**\n\n**Their tactic is exclusively to install legitimate tools, and reserve malicious components for later**\n\n**stages within the execution chain.**\n\nMoreover, the later stages are encrypted using DPAPI, to make it harder to reconstruct the full chain outside\n\nthe victim’s computer. Despite these issues, we were able to reconstruct four distinct types of InvisiMole\n\nexecution chains in cooperation with the compromised organizations, as illustrated in Figure 18.\n\nWe named the four chains by the component that InvisiMole misuses or exploits to achieve covert\n\nexecution. Attackers use these methods in various situations:\n\n- _Control Panel misuse chain is the least elaborate, possibly used in earlier stages of development, when_\n\nthe attackers tested the use of DPAPI and InvisiMole blob structure. This is the only chain where the\n\nattackers used a malicious PE file—all the other chains were crafted by combining legitimate tools\n\nand encrypted shellcode stored in registry keys.\n\n- _SMInit exploit chain exploits a vulnerability in Total Video Player software, and is used on systems where_\n\nthe attackers don’t have administrative privileges.\n\n- _Speedfan exploit chain exploits a vulnerability in Windows speedfan.sys driver, and is used on older_\n\n32‑bit systems where the attackers have managed to gain administrative privileges.\n\n\n-----\n\n- _Wdigest exploit chain exploits a vulnerability in Windows wdigest.dll library. This is InvisiMole’s_\n\nflagship chain, the most elaborate, used on the newest versions of Windows, where the attackers\n\nhave administrative privileges.\n\nFigure 18 // Four reconstructed InvisiMole execution chains\n\n_5Note we haven’t observed InvisiMole’s RC2FM backdoor executed by these chains. On the other hand,_\n\nwe were not able to obtain one of the three final stages in the Speedfan exploit chain, and it is possible the\n\nunknown component is precisely RC2FM backdoor.\n\nThis backdoor may also be is executed by another, yet undiscovered execution chain. As seen in Figure 19,\n\nthe debug artifacts in one of InvisiMole’s components reveal other possible execution methods.\n\nFigure 19 // Debug artifact suggesting other possible execution methods\n\n##### 6.1 Control Panel misuse chain\n\nThe specialty of the Control Panel misuse chain is a rare technique known from Vault 7 leaks, used to achieve\n\ncovert execution. InvisiMole installs one of its components as a control panel item, thus forcing Control Panel\n\nto load it every time it is executed. The malicious control panel item then loads InvisiMole’s TCP downloader.\n\nOverview of the chain is illustrated in Figure 20.\n\n\n-----\n\nFigure 20 // Control Panel misuse chain\n\n###### 6.1.1 Installation\n\nThe chain is set up by a patched RAR SFX dropper with an added InvisiMole blob. As a decoy, it uses a\n\nsoftware installer, or a document previously stolen from the victim.\n\nThe dropper encrypts the final stage—InvisiMole’s TCP downloader—with CryptProtectData API and\n\ndrops it along with Stage 4. Then, it registers Stage 4 as a control panel item under this registry key:\n\n```\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs\n  “infocard” = “%APPDATA%\\Microsoft\\AddIns\\infocardadd.cpl”\n\n```\n\nand opens the Control Panel which (as detailed in Stage 3 part) triggers execution of Stage 4 for the first time.\n\nOn the first execution, Stage 4 sets up persistence for the chain, so it subsequently starts from Stage 1.\n\nTable 6 // Components used in InvisiMole’s Control Panel misuse chain\n\n**SHA-1** **File path** **Comment**\n\nN/A `%STARTUP%\\Control Panel.lnk` Stage 1—LNK file\n\n`2402765EA67E04F151D32BF2B749B150BBD3993E` `%APPDATA%\\Control\\Control.js` Stage 2—JavaScript\n```\n 9F64FEC50D4447175459AAB33BC9126F9A3370D8\n                             %APPDATA%\\Microsoft\\AddIns\\\n\n```\nStage 4—InvisiMole blob loader\n```\n                             infocardadd.cpl\n A3AFF8CE55907DAA1F3360DED01BCF3F6F9D0CF2\n\n```\n`%APPDATA%\\Microsoft\\AddIns\\` Stage 5—InvisiMole’s TCP\nN/A (unique per victim)\n`imageapplet.dat` downloader\n\n###### 6.1.2 Stage 1—Control Panel.lnk\n\nThe first stage is an LNK file dropped in the Startup folder, pointing to the file %APPDATA%\\Control\\\n```\nControl.js.\n\n###### 6.1.3 Stage 2—Control.js\n\n```\nStage 2 is a malicious JavaScript file with this script:\n\n```\nWScript.CreateObject(“WScript.Shell”).Run(“::{20d04fe0-3aea-1069a2d8-08002b30309d}\\\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}”, 0)\n\n```\n\nAlthough it is not clear at first glance, this script opens the Control Panel in a new hidden window, as the\n\nCLSIDs used in the script refer to the This PC[8] folder and the Control Panel, respectively.\n\n\n-----\n\n###### 6.1.4 Stage 3—Control Panel\n\nIn Stage 3, the legitimate, preinstalled Control Panel is misused to automatically load Stage 4, which is\n\nmasked as a CPL file.\n\nCPL files are a special type of Windows executable file—a DLL file with .cpl extension, exporting a function\n\nnamed CPlApplet that matches a specific prototype. Unlike standard DLL files, CPL files can be executed\n\ndirectly. When a CPL file is executed, Windows automatically executes the Control Panel (control.exe)\n\nwith this file as an argument, and Control Panel loads the CPL and calls its CPlApplet function.\n\nThis feature made CPL files popular among malware authors in the past—as a way to disguise DLL files and\n\n[to bypass simple email filters. For example, massively distributed banking trojans in a campaign targeting Brazil](https://www.welivesecurity.com/wp-content/uploads/2015/05/CPL-Malware-in-Brasil-zx02m.pdf)\n\nhave been delivered as CPL files with deceptive names (e.g. Invoice.cpl), attached to malicious emails, in\n\nan attempt to trick potential victims into executing them.\n\nAnother method attackers have used to leverage CPL files is to register a malicious CPL file as a control\n\npanel item, under the HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs\n\nregistry key. Whenever the Control Panel is executed, it automatically loads all such CPL files and calls their\n```\nCPlApplet functions. This technique is described in the MITRE ATT&CK knowledge base and is also used by\n\n```\nInvisiMole—but with a surprising twist.\n\nInvisiMole takes advantage of an anomaly in how Windows handles files with .cpl extensions that don’t\n\n**comply with the CPL specification. Stage 4 is registered as a control panel item, but it is not a genuine**\n\nCPL file—instead, it is a standard DLL with its extension changed to .cpl. If the user executes the InvisiMole\n\n.cpl file directly, it won’t be loaded because of the missing CPlApplet function, and an error may be\n\ntriggered, as seen in Figure 21.\n\nFigure 21 // As InvisiMole’s .cpl file does not support the CPL interface, on Windows 7, it triggers an error when double-clicked\n\nHowever, when the Control Panel is executed, the same file is loaded successfully, and thus InvisiMole is able\n\nto execute any DLL file under the context of the Control Panel. This trick has been briefly documented in the\n\n_[Vault 7 leak of CIA capabilities.](https://wikileaks.org/ciav7p1/cms/page_13763468.html)_\n\nOverall, the benefit of this persistence technique for the attackers is that there is no obvious connection\n\nbetween the LNK file dropped in the Startup folder and the malicious file that is ultimately loaded—\n\nseemingly, only the Control Panel is executed on system startup.\n\n\n-----\n\n###### 6.1.5 Stage 4—infocardadd.cpl\n\nStage 4 is a malicious control panel item dropped under the name infocardadd.cpl, which mimics the\n\nname of its legitimate infocard.cpl counterpart.\n\nOn its first execution, this component drops Stages 1 and 2 to set up persistence for the chain.\n\nSubsequently, it is used to load the final stage of the chain, which is InvisiMole’s TCP downloader[9]. It obtains\n\nthe downloader from the imageapplet.dat file, decrypts it using CryptUnprotectData and loads it in a\n\nnew thread.\n\n##### 6.2 SMInit exploit chain\n\nIn the SMInit exploit execution chain, the attackers bring a legitimate, but vulnerable piece of software to the\n\ncompromised system and then exploit its vulnerability to load InvisiMole’s TCP downloader.\n\nThis technique can help avoid application whitelisting or detection, as the malware is running under the\n\ncontext of a legitimate process.\n\nFor the exploitation, the attackers use the quite outdated Total Video Player[10] software by EffectMatrix Inc. This\n\nsoftware was released back in 2007 and has a stack overflow vulnerability. The attackers deploy it under the\n\nname SMInit.exe; thus the name of this execution chain, illustrated in Figure 22.\n\nFigure 22 // InvisiMole’s SMinit exploit chain\n\nNote that this execution method does not require administrative privileges, so the attackers can use it on\n\ncompromised computers where they didn’t manage to obtain those rights.\n\n###### 6.2.1 Installation\n\nThis chain is set up by a dropper, which is a patched RAR SFX archive with an added InvisiMole blob. As a\n\ndecoy, it uses a software installer previously stolen from the compromised organization. This decoy software\n\ninstaller is unrelated to the Total Video Player software.\n\nThe dropper delivers a set of files related to the vulnerable software, as listed in Table 7, and drops them in\n\nthe %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Sessions folder.\n\nApart from that, it uses CryptProtectData to encrypt Stage 2 and 3, and stores the encrypted blobs in the\n\nregistry, as listed in Table 8.\n\nTable 7 // Files related to Total Video Player software misused by InvisiMole\n\n**SHA-1** **Filename** **Comment**\n```\n 2161A471B598EA002FC2A1CC4B65DBB8DA14A88E SMInit.exe\n\n```\n`355F026D6F8C43956B8D326026038BF809F7350D` `hskin.dll` Legitimate Total Video Player software\n```\n 9091BE6630AD170D15CA6A6722CE53619AC61229 TVPSkin.dll\n\n```\n`E85D7F0564771C9396FDCDB9877DB0FF61C1D515` `Settings.ini` File with exploit\n\n9 SHA-1 of decrypted InvisiMole blob: `DBD21EF03CCC3A985D808B0C5EC7AC54DED5D1C9`\n10 The full name of the software is E.M. Total Video Player\n\n\n-----\n\nTable 8 // Registry entries with stages of SMInit exploit chain\n\n**Registry key** **Comment**\n\n`HKCU\\Software\\Microsoft\\Feeds\\SyncData` Stage 2—task scheduler\n\n`HKCU\\Software\\Microsoft\\Feeds\\SyncImage` Stage 3—InvisiMole’s TCP downloader\n\nOn the first execution, the chain starts from Stage 1 and sets up persistence, so that it is triggered on each\n\nsystem start by a scheduled task.\n\n###### 6.2.2 Stage 0—scheduled task\n\nThis chain is installed as a task named MSST. This task executes the first stage—SMInit.exe—using this\n\nuncommon command line:\n\n```\nrundll32.exe shell32.dll,ShellExec_RundDLL “C:\\Users\\Admin\\AppData\\\nRoaming\\Microsoft\\Sessions\\SMInit”\n\n```\n\n[This combination of rundll32.exe and shell32.dll tricks Sysinternals Autoruns tool into hiding this task from the](https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns)\n\nlist of programs configured to run during system bootup when the Hide Windows Entries option is enabled\n\nin the tool. This option is part of the default settings.\n\n###### 6.2.3 Stage 1—SMinit.exe\n\nStage 1 is the legitimate Total Video Player software, deployed under the SMInit.exe[11] filename (see Figure 23).\n\nFigure 23 // `SMInit.exe file properties show E.M. Total Video Player as the original name`\n\n11 SHA-1: `2161A471B598EA002FC2A1CC4B65DBB8DA14A88E`\n\n\n-----\n\nOnce the software is started, it attempts to parse the Settings.ini file, shown in Figure 24. The parsing\n\nfunction allocates a 256-byte buffer on the stack and reads a value from the file. InvisiMole uses a specifically\n\ncrafted Settings.ini file, where the length of this value exceeds the length of the allocated buffer. This\n\nis how the stack overflow vulnerability is exploited and how the shellcode placed in the crafted settings file\n\ngets executed.\n\nFigure 24 // `Settings.ini file with the stack overflow exploit`\n\nBy triggering this vulnerability, InvisiMole is able to force the application to execute InvisiMole shellcode\n\nunder its context. The shellcode reads the registry value HKCU\\Software\\Microsoft\\Feeds\\SyncData,\n\ndecrypts it and passes execution flow to the decrypted code.\n\n###### 6.2.4 Stage 2—SyncData entry\n\nThe Stage 2 shellcode is used to decrypt and load the final stage of this chain from HKCU\\Software\\\n```\nMicrosoft\\Feeds\\SyncImage, which is InvisiMole’s TCP downloader[12].\n\n```\nTo decrypt Stage 3, and also to decrypt one part of itself, it uses the CryptUnprotectData API.\n\nDuring the first execution, this stage also schedules the Stage 0 task for the current user, to ensure\n\npersistence for the whole chain. To make the task scheduling functionality stealthier, it doesn’t utilize\n\nAPI calls; instead, it is implemented using the COM interface of the task scheduler (ITaskService,\n\nITaskDefinition, ITaskSettings COM interfaces).\n\n12 SHA-1 of decrypted InvisiMole blob: `2E7F737CAEB56716ACE36FADEB74EE610705283F`\n\n\n-----\n\n##### 6.3 Speedfan exploit chain\n\nIn the Speedfan exploit execution chain, InvisiMole uses the Bring Your Own Vulnerable Driver technique\n\nto load the speedfan.sys driver on the compromised system, and then exploit local privilege escalation\n\nvulnerability (CVE-2007-5633) to gain code execution in kernel mode.\n\n[To get this exploit up and running, InvisiMole misuses two legitimate tools: srvany-ng and winapiexec.](https://github.com/birkett/srvany-ng)\n\nOnce running in the context of the kernel, InvisiMole injects its code into a legitimate process and covertly\n\nloads the final stages. We have seen InvisiMole’s RC2CL backdoor and DNS downloader being loaded this way.\n\nThis execution method, illustrated in Figure 25, is used on older 32-bit Windows systems, for the cases when\n\nthe attackers were able to get admin privileges.\n\nFigure 25 // Execution chain exploiting vulnerability in the speedfan.sys driver\n\n###### 6.3.1 Installation\n\nWe don’t know exactly how this chain is set up, whether by using an InvisiMole dropper, or possibly by a\n\nhuman operator using Gamaredon’s toolset in the early stages of the attack—either way, administrative\n\nprivileges are required for this execution method.\n\nBased on our post-attack analysis, we know the (unknown) installer must register the Windows service\n\nstarting up Stage 1 and drop legitimate utilities misused in Stages 1 and 2.\n\nFinally, it must encrypt the rest of the components in the chain using CryptProtectData, to make sure\n\nthey can only be decrypted on the victim’s computer.\n\nSome of the filenames used in the Speedfan exploit chain are listed in Table 9; others are discussed later in\n\nthe section.\n\nTable 9 // Files used in InvisiMole’s Speedfan exploit chain\n\n**SHA-1** **File path** **Comment**\n\n`9987c0b97cb6a0239d3af6e5a70b552e1c38810f` `C:\\Windows\\system32\\mscorscvs.exe` Stage 1\n```\n                               C:\\Windows\\system32\\drivers\\NGEN\n\n```\n`4a6dc6a32a777dc5dd47221bf79604bc0258a987` Stage 2\n```\n                               Framework\\NGEN.exe\n                               C:\\Windows\\system32\\drivers\\NGEN\n\n```\nN/A (unique per victim) Stages 3-6\n```\n                               Framework\\NGEN.cab\n\n```\n\n-----\n\n###### 6.3.2 Stage 1—mscorscvs.exe\n\n[This execution chain starts with a legitimate utility srvany-ng[13], installed in C:\\Windows\\system32\\](https://github.com/birkett/srvany-ng)\n```\nmscorscvs.exe and registered as a Windows service under the name clr_optimization_v2.0.51527_\nX86, as shown in Figure 26. This name is used to mimic Microsoft.NET Framework NGEN (Native Image\n\n```\n_Generator service)._\n\nFigure 26 // Properties of clr_optimization_v2.0.51527_X86 service starting up InvisiMole’s Speedfan exploit chain\n\nThis utility is designed to run any Windows application as a service—for that, the parameters of the\n\n[application must be specified under the service parameters. InvisiMole configures this tool so that it loads](https://github.com/birkett/srvany-ng)\n```\nC:\\Windows\\system32\\drivers\\NGEN Framework\\NGEN.exe with the parameters specified under the\nAppParameters registry value, as shown in Figure 27.\n\n```\nFigure 27 // srvany-ng is configured to execute the winapiexec tool with InvisiMole’s shellcode\n\n###### 6.3.3 Stage 2—NGEN.exe\n\nThe NGEN.exe name of Stage 2 is used to mimic a legitimate Windows Native Image Generator tool. The file\n\n[itself is a copy of a legitimate tool winapiexec[14]—the same tool that is misused to upgrade Gamaredon’s](https://rammichael.com/winapiexec)\n\ntargets to InvisiMole (see the Delivery method section).\n\nFor this execution chain, winapiexec is executed with the following command line:\n\n```\nC:\\Windows\\system32\\drivers\\NGEN Framework\\NGEN.exe VirtualAlloc 0\n0x20000 0x3000 0x40, CreateFileW ‘Ngen.cab’ 0x80000000 0 0 3 0 0,\nSetFilePointer $$:7 64 0 0, ReadFile $$:7 $$:1 0x20000 $b:4 0,\nCloseHandle $$:7, EnumUILanguagesA $$:1 4 $$:1”\n\n```\n\n13 SHA-1: `9987C0B97CB6A0239D3AF6E5A70B552E1C38810F`\n14 SHA-1: `4A6DC6A32A777DC5DD47221BF79604BC0258A987`\n\n\n-----\n\nWith these parameters, winapiexec reads shellcode from the C:\\Windows\\system32\\drivers\\NGEN\n```\nFramework\\Ngen.cab file, starting at offset 0x40, and calls the EnumUILanguagesA API with the shellcode\n\n```\nas a parameter. EnumUILanguagesA enumerates the user interface languages that are available on the\n\noperating system and calls the specified callback function with every language in the list—this is how the\n\nshellcode gets executed.\n\n###### 6.3.4 Stage 3—Ngen.cab\n\nStage 3 is a multilayer shellcode, serving as a container for Stages 4-6.\n\nIt decrypts the first layer using a XOR cipher with this DWORD key:\n\n```\nkey = 0x1D709CA2 + (i << 4) + (i << 0x12) // i starts at 0x80 and\nincrements for each subsequent dword\n\n```\n\nThen, it uses CryptUnprotectData to decrypt the second layer with two embedded InvisiMole blobs, and\n\npasses execution to one of them—Stage 4.\n\n###### 6.3.5 Stage 4—speedfan.sys exploit\n\nStage 4 is a 32-bit shellcode[15] running in the context of the winapiexec tool.\n\nThis component exploits a local privilege escalation vulnerability in the speedfan.sys driver to get code\n\nexecution in kernel space, and uses this access to execute Stage 5 in the kernel context.\n\nA design flaw in speedfan.sys allows local users to issue privileged IOCTLs to read or write arbitrary MSRs\n\nvia the IOCTL_RDMSR (0x9C402438) and IOCTL_WRMSR (0x9C40243C). InvisiMole uses this vulnerability\n\n**to replace the value of the IA32_SYSENTER_EIP MSR register, which holds the address of the**\n\n**SYSENTER handler.**\n\nThen, it issues a system call to ensure the SYSENTER instruction is called from the user space, and thus the\n\npatched SYSENTER handler is triggered. Figure 28 illustrates the steps the patched handler takes.\n\nFigure 28 // Patched SYSENTER handler\n\n15 SHA-1 of decrypted shellcode: 10C548992567A04DA199D09E3CA4B0C47B7A136C\n\n\n-----\n\n1. It uses the wrmsr instruction to restore the value of the IA32_SYSENTER_EIP MSR register (not to\n\ndisturb the normal operation of the kernel), which restores the original address of the SYSENTER handler.\n\n2. It clears the write protection bit to allow writing to read-only memory pages (when the WP bit is set, the\n\nCPU can’t write to read-only pages when privilege level is 0).\n\n3. It patches the code section in speedfan.sys; more specifically it patches the handler for IOCTL_GET_\n```\n DRIVER_VER (0x9C402434), as shown in Figure 29.\n\n```\nFigure 29 // Original and patched handler for IOCTL_GET_DRIVER_VER in speedfan.sys\n\nThe esi register in this case holds Irp->AssociatedIrp.SystemBuffer; that is, when\n```\n    IOCTL 0x9C402434h is called on \\\\.\\speedfan with code as an argument, this code is\n\n```\nexecuted in kernel mode.\n\n4. It restores the original value of CR0 (reenabling read-only protection, if applicable).\n\n5. It passes control to the original SYSENTER handler, to properly process the original SYSENTER request.\n\nThis patched SYSENTER handler is thus only executed once, to patch a code section in speedfan.sys; after\n\nthat the original handler is restored.\n\nInvisiMole then leverages the created backdoor in the speedfan.sys driver by issuing IOCTL\n```\n0x9C402434h with Stage 5 as a parameter, as illustrated in Figure 30. As a result, Stage 5 is executed\n\n```\n**under the kernel context.**\n\n\n-----\n\nFigure 30 // InvisiMole issues the hijacked IOCTL with Stage 5 as an argument\n\nThis exploit works on x86 systems where it is possible to execute user-mode addresses from kernel mode—\n\n[it would be more difficult on x64 systems with SMEP mitigation in place. SMEP was launched in 2011 and](https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention)\n\nenabled by default since Windows 8, so the exploit should work on Windows 7 or older.\n\n[Note that the IA32_SYSENTER_EIP MSR register is separate per core, or per logical processor, so in order for](https://software.intel.com/sites/default/files/managed/22/0d/335592-sdm-vol-4.pdf)\n\nthis exploit to work on processors with multiple logical units, the part of the exploit that triggers the patched\n\nSYSENTER handler must be executed on the same unit as the part patching the handler. To ensure this,\n\nInvisiMole takes further steps ensuring the full exploit is executed without interruption, on a single unit:\n\n- Before running the exploit, InvisiMole temporarily adjusts scheduling priority of the current thread\n\nto the highest possible priority by setting the priority class of the current process to REALTIME_\n```\n PRIORITY_CLASS (SetPriorityClass API) and priority level of the thread to THREAD_PRIORITY_\n TIME_CRITICAL (SetThreadPriority API), to prevent the scheduler from interrupting it with\n\n```\n**some other task.**\n\n- Then it adjusts the processor affinity mask of the current process so that it can be executed on all\n\nlogical processors, by retrieving the affinity mask for the system with the GetProcessAffinityMask\n\nAPI, and then setting this mask to the current process with the SetProcessAffinityMask API.\n\n- Finally, if there are multiple logical processors, InvisiMole starts a number of new threads and spreads\n\nthem over the other logical processors using the SetThreadAffinityMask API. By this, InvisiMole\n\nmakes sure the shellcode is executed on one execution unit, while the other threads keep the other\n\n**units busy by looping until triggered by the main thread that the exploit has been completed**\n\n###### 6.3.6 Stage 5—kernel-mode inject\n\nStage 5 is shellcode executed in the context of the kernel, after the driver exploit has been completed.\n\nThis component creates a new thread (in kernel space), attaches this thread to a svchost.exe process,\n\nand inserts Stage 6 into the thread APC queue of this process using the KeInsertQueueApc API.\n\nAs a result, Stage 6 is executed asynchronously the next time the thread is scheduled.\n\nThis technique is used in an attempt to avoid detection, as it is stealthier to do process injection from\n\nkernel mode.\n\n###### 6.3.7 Stage 6—loader\n\nStage 6 is a loader[16] of the final stages of this execution chain—InvisiMole’s payloads. It searches for\n\nencrypted InvisiMole blobs, decrypts them using a combination of the CryptUnprotectData API and the\n\ntwo-key triple DES algorithm, and loads these payloads.\n\n16 SHA-1 of decrypted InvisiMole blob: B988F107E5F20CDC424EC9F470D157435FC03966\n\n\n-----\n\nThe tricky part is that the loader doesn’t contain the full path to the encrypted files with these components;\n\ninstead it searches for files or registry values by a list of hardcoded SHA-1 hashes of filenames and\n\n**registry value names.**\n\nThe SHA-1 values are calculated using Microsoft CryptoAPI from lowercase versions of the names and—to\n\nmake detection even more difficult—stored as binary data, rather than strings, as illustrated in Figure 31.\n\nFigure 31 // InvisiMole’s loader uses a hardcoded list of binary SHA-1 values instead of filenames\n\nMore specifically, InvisiMole stores its final stages in registry values under specific subkeys of the HKLM\n\nregistry key, and in files in the %TEMP% or %SYSTEM% folder, the root folder of a system drive, or any\n```\nprogramdata subfolder under this drive.\n\n```\nThanks to the cooperation of the affected organizations, we were able to recover some of the obfuscated\n\nlocations, and obtain and decrypt the corresponding InvisiMole components—InvisiMole’s RC2CL backdoor[17]\n\nand DNS downloader[18]. The recovered names of registry subkeys and values are listed in Table 10 and\n\nTable 11, with one of the components yet to be uncovered.\n\nNeither have we recovered the names of files concealed behind the SHA-1 values, as listed in Table 12.\n\nHowever, from the artifacts in the InvisiMole loader, we assume these files would contain the same three\n\ncomponents as are loaded from the registry keys—the RC2CL backdoor, DNS downloader and the third,\n\nunknown, component.\n\nIt remains a mystery whether the third loaded component is one of the known InvisiMole payloads (RC2FM\n\nbackdoor or TCP downloader, Portscan or BlueKeep component), or some unknown component, or whether\n\nit is reserved for some yet-to-be-implemented payload.\n\nTable 10 // Registry keys used to store InvisiMole components. SHA-1 values were calculated from lowercase, ASCII\nversions of the registry key names\n\n**SHA-1 of registry key name** **Recovered registry key name**\n\n`40D02DDB8BE27726135C4A0E20E2BBABDA84D0FF` software\\microsoft\\drm\n\n`5D69782FFF60365FE81C58D5887C151D326CF731` software\\microsoft\\windows\\currentversion\n\n`7AE0CA52F4690CA09558A94D4CE5B521B3A3E3FF` software\\microsoft\\windows\\currentversion\\ext\n\n`B7FEE003B413AF3297DB60D0FC845A054FE080D2` software\\microsoft\\function discovery\\registrystore\\publication\\explorer\n\n17 SHA-1 of decrypted InvisiMole blob: `094DAEA5B97C510A8E9CFE3585B39B78522A2C61`\n18 SHA-1 of decrypted InvisiMole blob: `F67300541D769C5AA071C766198F0B7E25476B23`\n\n\n-----\n\nTable 11 // Properties of registry values used to store InvisiMole components. The SHA-1 values were calculated from\nlowercase, Unicode versions of registry value names.\n\n**SHA-1 of registry value name** **Recovered value name** **Component type**\n```\n C0E73E522D09344A278D45A524A50CF4FCC87817 1Extylc8fC5X1PL\n\n```\n`D0A769119F628FF0D5110A1E17864036FCB8BE6B` `1Extylc8fC5X1HK` Unknown\n```\n 065DEB443AAE29700D09CB395C928C919C3A7352 1Extylc8fC5X1RK\n 6AA50BAE4D9529A60FE566115068E6BDF418786D 1Extylc8fC5X2PL\n\n```\n`5126A83A9D9B29598B36540647FFBA2834C82AE3` `1Extylc8fC5X2HK` DNS downloader\n```\n 371971130EE56AB5B7FEA61A80054F5E81E4027D 1Extylc8fC5X2RK\n 3E49B3DD812AAE4997C4C9FF2843EAAC32F55A94 1Extylc8fC5X3PL\n\n```\n`12EBD779D5BB416D05550D9ECBADF5A9EF89436C` `1Extylc8fC5X3HK` RC2CL backdoor\n```\n 80D48821135D904CAF2DF0FE2883A6F104BE1639 1Extylc8fC5X3RK\n\n```\nTable 12 // Properties of names of the files storing InvisiMole components\n\n**SHA-1 of filename** **Filename** **Component type**\n```\n F4A60039D7C9FC337AE2F59D09F6F6F3D1FF7DE3 Unknown\n\n```\n`2F13F5DD481FB251991E0CC05DB9C06A4C1D6ED8` `Unknown` Unknown\n```\n 798AF02CA0C8F92B1623A1F1CF25DA4916C04A74 Unknown\n 6ECF2532A8E3AB1888088A503D4A7CA57A7BAA82 Unknown\n\n```\n`0197D794FA28B189B3B938FB384CC94E5F1D1733` `Unknown` Unknown\n```\n 60197B570D2ACF93A6F92B548D08A3CAF80A1579 Unknown\n F4F06C73A4D8091CE0C7229555921F58E735849D Unknown\n\n```\n`A203A7EEF726473911031578ADBF17CB83FE214B` `Unknown` Unknown\n```\n C5DE2BF0E13E741508A7EB4C67DED301ABA391CE Unknown\n\n###### 6.3.8 Previous versions\n\n```\nNote that we detected a number of InvisiMole’s loaders similar to the Stage 6 loader. While the latter loader\n\nis an InvisiMole blob loaded by a chain of other components, the former are standalone DLLs.\n\nWe identified three versions of these loaders, all sharing the same functionality as the Stage 6 loader, even\n\nusing the same list of SHA-1 hashes of final stage locations. These versions, however, vary in the level of\n\nobfuscation, showing a continuous development.\n\nWe assume these loaders are the predecessors of the elaborate Speedfan exploit execution chain. The attackers\n\nwere probably first experimenting with using execution guardrails and obfuscating the payload location,\n\nbefore they developed the full chain.\n\nInterestingly, most of these files have language in resources set to LANG_RUSSIAN, SUBLANG_RUSSIAN_\n\nRUSSIA—we don’t have this type of metadata for the rest of the InvisiMole’s toolset, developed after the\n\ntransition to elaborate execution chains using InvisiMole blob shellcodes.\n\nThe filenames and SHA-1 hashes of the older loaders are provided in the IoCs section.\n\n\n-----\n\n##### 6.4 Wdigest exploit chain\n\nFinally, in the most elaborate Wdigest exploit execution chain, InvisiMole uses another variation of\n\nthe BYOVS technique. The attackers bring wdigest.dll, a vulnerable Windows component from\n\nWindows XP, and misuse its input validation vulnerability to run shellcode, crafted to use code\n\n**gadgets from the library.**\n\nRunning under the context of a Windows component helps the attackers avoid application whitelisting\n\nand adds legitimacy to the malicious code. Despite being vulnerable, the library can’t be cleaned by security\n\nproducts, as it could break the OS in previous Windows versions.\n\nLater in the chain, InvisiMole uses an improved version of ListPlanting, an interesting injection technique,\n\nto run the DNS downloader and the RC2CL backdoor within a trusted process.\n\nThis is InvisiMole’s most recent and most elaborate execution method, used on computers with the newest\n\nversions of the OS, where the attackers were able to obtain administrative privileges previously. An overview\n\nof the chain is illustrated in Figure 32.\n\nFigure 32 // Execution chain exploiting wdigest.dll\n\n###### 6.4.1 Installation\n\nWe analyzed multiple instances of the installer component that sets up this chain. The installer is a 64-bit\n\nInvisiMole blob, probably delivered and executed by one of InvisiMole’s downloaders.\n\n[The installer decrypts an embedded zlib blob, reusing the decryption routine previously used by InvisiMole.](https://github.com/eset/malware-research/blob/master/invisimole/invisimole_decrypt.py)\n\nAfter decryption, the installer decompresses eight embedded blobs with stages of this execution chain and\n\ninstalls them. Finally, it schedules and executes Stage 0 using Windows Task Scheduler.\n\nAs you can see from Table 13 and Table 14, the only files used in this execution chain are legitimate\n\nWindows utilities, with all the malicious components stored in the registry. Even the small shellcode stored\n\nunder the FlashConfigEnrollee registry value is designed to live off the code gadgets from the legitimate\n```\nwdigest.dll library. Thus, all the malicious components are encrypted and stored in the registry\n\n```\n**[(a technique some categorize](https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats#type-iii-files-required-to-operate)** **as fileless), which adds to the stealthiness of this execution chain.**\n\nTable 13 // Legitimate Windows utilities used in InvisiMole’s Wdigest exploit chain\n\n**SHA-1** **File path**\n```\n B61A277719359582071DB4CD448D3E9D0A460B1D %WINDIR%\\SysWOW64\\drivers\\Rundll32.exe\n 7752BD1C02E5DC7B0975FC6A1C73145A2A83D079 %WINDIR%\\SysWOW64\\drivers\\wdigest.dll\n EE7D06FC93D3C608B48823D1444148327330015A %WINDIR%\\SysWOW64\\wbem\\setupSNK.exe\n\n```\n\n-----\n\nTable 14 // Registry entries used in InvisiMole’s Wdigest exploit chain. Registry keys are given for both 32-bit and 64-bit OS\nversions.\n\n**Registry key** **Value name** **Component** **Encryption method**\n```\n HKLM\\SOFTWARE\\Microsoft\\\n\n```\nFlashConfig or\n\nFlashConfigEnrollee Exploit used in Stage 2 `-`\n```\n HKLM\\SOFTWARE\\WOW6432Node\\\n\n```\nMicrosoft\\FlashConfig\n\nM Stage 3 `XOR 0x7E8B103C`\n\nA Stage 4 `CryptProtectData`\n\n```\n HKLM\\SOFTWARE\\ODBC or\n HKLM\\SOFTWARE\\WOW6432Node\\ODBC\n\n###### UAC Bypass\n\n```\n\nB Stage 5 `CryptProtectData`\n\nC Stage 6 / RC2CL backdoor `CryptProtectData`\n\nD Stage 6 / DNS downloader `CryptProtectData`\n\n\nNote that the installer for this chain expects to be executed with System or Administrator privileges.\n\nOptionally, if it is executed as a non-elevated Administrator, it can use fileless UAC bypass to obtain elevated\n\nAdministrator privileges.\n\nIn that case, the installer creates a shared memory object named XVD21x9DC with a copy of itself and uses\n\nthe legitimate winapiexec tool to read from the shared memory and execute the installer in a new thread.\n\nIt first drops a copy of the winapiexec tool in %APPDATA%\\Microsoft\\Installer\\kb043921.exe.\n\n[To execute it as an elevated process, the installer uses a registry hijacking trick for UAC bypass:](https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/)\n\n1. It sets this registry key to register a new file type association with a malicious command line:\n\n```\nHKCU\\SOFTWARE\\Classes\\.zeros\\shell\\open\\command = “%APPDATA%\\Microsoft\\\nInstaller\\kb043921.exe” OpenFileMappingW 0xF003F 0 “XVD21x9DC”,\nMapViewOfFile $$:1 0xF003F 0 0 %installer_size%, CreateThread 0 0 $$:6\n$$:6 0 0, WaitForSingleObject $$:13 -1\n\n```\n\nIt sets this registry key:\n\n```\nHKCU\\SOFTWARE\\Classes\\ms-settings\\Curver = “.zeros”\n\n```\n\n2. It executes %SYSTEMDIR%\\fodhelper.exe, which is an auto-elevated application. Once executed,\n```\n fodhelper.exe reads file type association set in HKCU\\SOFTWARE\\Classes\\ms-settings\\Curver key\n\n```\nand executes the associated command line.\n\nAs a result, the dropped winapiexec is executed as elevated process, then it reads the installer blob from\n\nshared memory and starts it in a new elevated thread.\n\nThis technique works on Windows 10. For Windows 7, the installer uses a similar trick, except it uses\n```\n%SYSTEMDIR%\\CompMgmtLauncher.exe as the auto-elevated application and HKCU\\SOFTWARE\\Classes\\\n\n```\nlnkfile\\Curver as the hijacked registry key.\n\n\n-----\n\n###### 6.4.2 Stage 0—scheduled task\n\nFor this execution chain, InvisiMole achieves persistence using a standard scheduled task, scheduled on each\n\nsystem start and registered under the name \\Microsoft\\Windows\\Autochk\\Scheduled.\n\nFigure 33 // Part of XML specification of the scheduled task starting up InvisiMole’s Wdigest exploit chain\n\nAs shown in Figure 33, this task creates a hidden system directory C:\\SMRTNTKY\\MessageB.txt (not a file)\n\nand executes setupSNK.exe[19].\n\nThe directory is created to force a specific execution path within the setupSNK.exe tool.\n\n###### 6.4.3 Stage 1—setupSNK.exe\n\nStage 1 is a copy of a legitimate Windows component—Wireless Network Setup Wizard—designed to share\n\nwireless connection settings on USB Flash drives.\n\nWhen launched, setupSNK.exe restores these settings by executing the default Flash Config Enrollee DLL\n\n(wzcdlg.dll). However, it has an undocumented feature that allows execution of a custom Flash Config\n\n_Enrollee DLL instead of the default one. This undocumented feature is abused by InvisiMole._\n\nWhen executed, setupSNK.exe checks for the presence of the C:\\SMRTNTKY\\MessageB.txt directory.\n\nIf it exists, it attempts to load the FlashConfigEnrollee value from HKLM\\SOFTWARE\\Microsoft\\\n\nFlashConfig on 32-bit systems, or from HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\FlashConfig on 64\nbit systems, and uses that value to build a command line in this format:\n\n```\nrundll32.exe %s %s\\SMRTNTKY\\WSETTING.WFC\n\n```\n\nNote that WSETTING.WFC refers to a file stored in the SMRTNTKY folder in the root of a USB drive, which is\n\nused to store the wireless connection settings.\n\nAs Figure 34 depicts, this command line is then executed via the CreateProcessA API that, in a legitimate\n\nrun of setupSNK.exe, opens a benign Wizard Dialog DLL.\n\n19 SHA-1: `EE7D06FC93D3C608B48823D1444148327330015A`\n\n\n-----\n\nFigure 34 // Decompiled function of setupSNK.exe tool\n\nHowever, InvisiMole hijacks this function to execute its own code. On InvisiMole-compromised computers,\n\nthe FlashConfigEnrollee value in the registry is changed to the following value, including a 119-byte\nshort shellcode:\n\n```\nshell32 ShellExec_RunDLL “C:\\Windows\\SysWOW64\\drivers\\Rundll32.exe”\n“C:\\Windows\\SysWOW64\\drivers\\wdigest.dll”,SpInitialize %SHELLCODE_BYTES%\n\n```\n\nAs a result, setupSNK.exe builds and executes this command line:\n\n```\nrundll32.exe shell32 ShellExec_RunDLL “C:\\Windows\\SysWOW64\\drivers\\\nRundll32.exe” “C:\\Windows\\SysWOW64\\drivers\\wdigest.dll”,SpInitialize\n%SHELLCODE_BYTES%\\SMRTNTKY\\WSETTING.WFC\n\n```\n\nThe rundll32.exe[20] and wdigest.dll[21], whose properties are shown in Figure 35, are both legitimate files\n\nfrom Windows XP. InvisiMole brings these versions to the compromised computer, so this execution chain\n\nworks even on Windows 10.\n\nFigure 35 // Properties of wdigest.dll and setupSNK.exe files—two Windows components misused by InvisiMole in\nthis chain\n\n20 SHA-1: B61A277719359582071DB4CD448D3E9D0A460B1D\n21 SHA-1: `7752BD1C02E5DC7B0975FC6A1C73145A2A83D079`\n\n\n-----\n\n###### 6.4.4 Stage 2—wdigest.dll\n\nThe wdigest.dll library is a legitimate Windows component that contains an implementation of a digest\n\nauthentication protocol. When some third-party application needs to use this protocol, this library is loaded\n\ninto the process.\n\n**However, the attackers discovered the possibility of running wdigest.dll from the command line**\n\n**using rundll32.exe with shellcode as a parameter.**\n\nWhen executed by Stage 1 with the given parameters, InvisiMole’s shellcode is copied to the g_LsaFunctions\n\nglobal variable in the SpInitialize function, shown in Figure 36.\n\nFigure 36 // Decompiled SpInitialize function of wdigest.dll library\n\nThe shellcode is constructed in a way so that it uses different parts of wdigest.dll’s code (gadgets) to\n\nhijack its control flow, in order to load the next stage of this InvisiMole execution chain.\n\nAs shown in Figure 37, the following code is executed later after the SpInitialize function:\n\n1. `wdigest.dll calls [eax+14], with eax pointing to g_LsaFunctions, which passes control to the`\n\nshellcode.\n\n2. `[eax+14] points to the 0x7E8BC063 value within the shellcode, which is an address within wdigest.dll.`\n\n3. This address points to a jmp eax instruction, which passes control back to the start of the shellcode.\n\n4. The shellcode then uses other gadgets of wdigest.dll, such as the resolved address of the\n```\n RegQueryValueExW API (always 0x7e8B1040), to read the next stage from value M under either the\n HKLM\\SOFTWARE\\ODBC or HKLM\\SOFTWARE\\WOW6432Node\\ODBC registry key and to pass control to it.\n\n```\n\n-----\n\nFigure 37 // InvisiMole’s shellcode is crafted to use gadgets of wdigest.dll\n\n**The shellcode can reference hardcoded addresses within wdigest.dll, because it is a Windows XP**\n\n**[binary, so it doesn’t use ASLR and is always loaded in the same address space.](https://en.wikipedia.org/wiki/Address_space_layout_randomization)**\n\n###### 6.4.5 Stage 3—M loader\n\nStage 3 is 32-bit shellcode[22] loaded from the M registry key. Just like Stage 2, it uses imports from wdigest.dll,\n\nusing hardcoded addresses.\n\nThis component reads the A value from the registry, decrypts it using the CryptUnprotectData API and\n\npasses execution flow to the blob.\n\n###### 6.4.6 Stage 4—A loader\n\nStage 4 is a 32-bit InvisiMole blob[23] that uses an interesting technique to inject the shellcode from the B\n\nregistry value to a trusted process.\n\nIt also creates a shared memory with content of C and D registry values and injects names of the shared\n\nobjects to the trusted process, so that B shellcode can access and load C and D payloads. The B, C and D\n\nvalues are all encrypted with DPAPI, so Stage 4 first decrypts them using CryptUnprotectData before they\n\nare injected/loaded.\n\n22 SHA-1: `B894F320569286B56F4272D0CBBA4DB10C645AE0`\n23 SHA-1 of decrypted InvisiMole blob: `AA5E8E21C79B0B4A02726233B9F5EB4994C87AD3`\n\n\n-----\n\nTable 15 // Shared objects created by Stage 4\n\n**Name format** **Object type** **Name for C payload** **Name for D payload**\n\n`ExMp00%.2X` shared memory `ExMp0043` ExMp0044\n\n`ExMpOK%.2X` event name for success `ExMpOK43` ExMpOK44\n\n`ExMpER%.2X` event name for error `ExMpER43` ExMpER44\n\nFor process injection, this component uses a technique called ListPlanting[24]. This technique has been\n\nalready documented online, but InvisiMole improves it to add even more stealthiness.\n\nListPlanting is based on the possibility of providing a callback to customize the sorting algorithm in a\n\n**ListView structure. To display a ListView structure, InvisiMole misuses a legitimate Windows library**\n```\nFXSCOMPOSE.dll, which displays contacts stored in the %USERPROFILE%\\Contacts folder in such\n\n```\na structure.\n\nIt first drops three XML files into this folder—only to create data for the list. Then it executes the\n```\nFXSCOMPOSE.dll library with the HrSelectEmailRecipient function.\n\n```\n- If running without admin privileges, it executes this library directly using rundll32.exe.\n\n- Otherwise it creates a service named CsPower, with the registry content shown in Figure 38, that\n\nexecutes the same library.\n\nFigure 38 // Properties of CsPower service in the registry\n\nWhen FXSCOMPOSE.dll starts, it creates a window filled with information from %USERPROFILE%\\\n```\nContacts files, as shown in Figure 39. This window is displayed for so short a period of time that it may well\n\n```\ngo unnoticed by the user.\n\n24 See _[https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/#listplanting, http://www.hexacorn.com/blog/2019/04/25/](https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/#listplanting,%20http://www.hexacorn.com/blog/2019/04/25/listplanting-yet-another-code-injection-trick/)_\n_[listplanting-yet-another-code-injection-trick/](https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/#listplanting,%20http://www.hexacorn.com/blog/2019/04/25/listplanting-yet-another-code-injection-trick/)_\n\n\n-----\n\nFigure 39 // Window with a contact list created when FXSCOMPOSE.dll starts\n\nInvisiMole enumerates windows and child windows to get the handle of the SysListView32 child\n\nof this window (the handle to the ListView). Then it allocates memory inside the new process using\n```\nVirtualAllocEx, copies malicious code to the target process and triggers the shellcode by sending a\n\n```\n**LVM_SORTITEMS** message to the ListView. Using this technique, InvisiMole is able to inject shellcode into a\n\ntrusted process.\n\nIt is important to add that unlike in the standard ListPlanting technique, InvisiMole does not use the\n```\nWriteProcessMemory API to write malicious code to the target process, as this API could be monitored by\n\n```\nsecurity solutions. InvisiMole takes this technique one step further to make the code injection stealthier.\n\nInstead of calling WriteProcessMemory, it achieves the same result by using a pair of LVM_SETITEMPOSITION\n\nand LVM_GETITEMPOSITION messages sent to SysListView32, as shown in Figure 40.\n\n- It first sends an LVM_SETITEMPOSITION message to SysListView32, which moves an item to a\n\nspecified position in a ListView. InvisiMole provides XXYY as the new position, where XX and YY are\n\nbytes of shellcode.\n\n- Then it sends an LVM_GETITEMPOSITION message to retrieve the position of the same item\n\nThe trick is that the return buffer (POINT structure) points to an offset in a newly allocated memory, and so\n\nInvisiMole is able to copy two bytes at a time to the allocated memory within the legitimate FXSCOMPOSE.dll.\n\n\n-----\n\nFigure 40 // Improved part of ListPlanting technique used by InvisiMole\n\nAfter Stage 4 has successfully injected Stage 5 in a trusted process, it clears traces by removing the XML files\n\nfrom the %USERPROFILE%\\Contacts folder, and deleting the C:\\SMRTNTKY\\MessageB.txt directory.\n\nMoreover, Stage 5 later deletes the CsPower service from the registry, if it was executed that way.\n\n###### 6.4.7 Stage 5—B loader\n\nStage 5 is a small InvisiMole blob[25] that is injected into a trusted process. It opens already existing shared\n\nmemory objects with shellcodes from C and D registry values, copies them to a newly allocated memory and\n\nexecutes using the CreateThread API.\n\nNote that the C and D shellcodes could be injected directly into the trusted process, instead of the small\n\nStage 5 loader. However, the modified ListPlanting technique requires a lot of operations—a pair of\n\n**LVM_SETITEMPOSITION and LVM_GETITEMPOSITION messages sent for each pair of copied bytes.**\n\nFor larger payloads, such as the RC2CL backdoor, it is possible the window shown in Figure 39 would be\n\nvisible for a short time. This extra stage is used to make sure the user won’t spot the window.\n\n**As a result of this execution chain, InvisiMole’s RC2CL backdoor[26] and DNS downloader[27] are covertly**\n\n**executed under the context of a trusted process.**\n\n#### 7 CONCLUSION\n\nWhen we first reported about InvisiMole in 2018, we highlighted its covert workings and complex range of\n\ncapabilities. However, a large part of the picture was missing.\n\nAfter discovering new activity in late 2019, we gained the opportunity to take a proper look under the hood\n\nof InvisiMole’s operations and piece together the hidden parts of the story.\n\nAnalyzing the group’s updated toolset, we observed continuous development and substantial improvements,\n\nwith special focus on staying under the radar.\n\n25 SHA-1 of decrypted InvisiMole blob: `D8B101B588DA6DA3CBE3E161C91986E64D6DD290`\n26 SHA-1 of decrypted InvisiMole blob: `0AAB85DDD4E25ADD24E9ECD83C8DD635B3A7C2F3`\n27 SHA-1 of decrypted InvisiMole blob: `E9AF42C4CF0299EEA7B405F9E3E925BCAFAB9F2B`\n\n\n-----\n\nNotably, we identified four different execution chains misusing legitimate tools for persistence, and user\nand kernel-mode exploits for covert execution. We described how the malware uses per-victim encryption\n\nto prevent defenders from obtaining its payloads; and detailed the workings of a new component used for\n\nDNS tunneling.\n\nOur investigation also revealed a previously unknown cooperation between InvisiMole and the Gamaredon\n\ngroup, with Gamaredon’s malware used to infiltrate the target network and deliver the sophisticated\n\nInvisiMole malware to targets of special interest.\n\nHaving provided a detailed report on InvisiMole’s TTPs, we will continue to track the group’s malicious activities.\n\n_[Indicators of Compromise can also be found on our GitHub respository. For any inquiries, or to make sample submissions](https://github.com/eset/malware-ioc/tree/master/invisimole)_\n\n_related to the subject, contact us at threatintel@eset com._\n\n#### 8 ACKNOWLEDGEMENTS\n\nAcknowledgements to Matthieu Faou, Ladislav Janko and Michal Poslušný for their work on this investigation.\n\n#### 9 INDICATORS OF COMPROMISE (IOCS)\n\n##### 9.1 ESET detection names\n\nWin32/InvisiMole\n\nWin64/InvisiMole\n\n##### 9.2 SHA-1\n\n**File / registry key /**\n**SHA-1** **Note**\n**decrypted blob[28]**\n\n```\n125FCA6EBD82682E51364CF93C9FFA8EB4F6CA5F\n\n```\n\nFile\n\n\n`3B923FA1E5DCB4F65DAA138BECEB123D7C431D1B` File\n\n`3BB2C05DEA077835A79499A0BB81410D27EEBFAF` File\n\n`4C13AD9AD9C134DE15F3AE5E2F0D2EC1E290DEE8` File\n\n`728386C6D6EAF43148FE25F86E6AF248019D9842` File\n\n`793F4DD2B765ECD962A053246646ED0D6144D249` File\n\n`8147E85E13B3624FA290F1F218647A0D1FD70204` File\n\n`8C5F463FA79601DE38D0A77808226B1A8E67459A` Trojanized software File\n\n`9B1E0A22DEB124FF36FCF7ED2EA82E799B49B070` File\n\n`9B48090704C3F62D6B768780845E2D04862F5219` File\n\n`CD3419B4B3958BE5BE1CAEA60A4EE98E4D427A6D` File\n\n`D5D3A01A5944D55E5DDF1F915E88043691BE6F58` File\n\n`D8EB2429253E82729F34373068EC350D1B2DA8AB` File\n\n`DDB871AD5823BE31F5176F2B0CE149D4B6E44F24` File\n\n`E936E857A812690178ED049FD4A1766E281B9F1D` File\n\n28 Decrypted blobs are recovered using the CryptUnprotectData API. We present SHA-1 hashes of these versions, as the encrypted versions are different per victim.\n\n\n-----\n\n```\n09821EB9F2B79501B3928FBA2F313C723FEBB1B3\n\n```\n\nFile\n\n\n`16E9B0ADBD53849E7F3A04FA8A5BF78E73A86841` File\n\n`21F320DEBDD4D97FA5420AF31A55FBC77B923819` File\n\n`240C8157E5E053B70C4D301D852C609C212F85F3` File\n\n`32A9FF262649623CBFF4C6B29BD8ED7F803E75E3` File\n\n`3EF0D0278DB40F6116645B0B915D56374EB77004` File\n\n`42086128F7213931D438BF127CC61D3F9483014A` File\n\n`4BBED6E307D214CAB9AE395E1F49104446B54D5A` File\n\n`55F6185AD64997756ADF03BC2D4CC4ABF5C64E4E` File\n\n`652991303B319F5DE440C18A0F14DF65B82265FB` File\n\n`66F9EA8017CD899AB146DED2E341201B51A9CE9F` File\n\n`6A6D956A8108E0D5339751927D5576369C0E2C34` File\n\n`6C49BF35116A147C7F3C5CE15ABA041F272E60B5` File\n\n`6DECBFCA132364CBD66DD07118959BCE95F83168` File\n\n`6DEF96407F52B3C82D665B2C6A9B230B3D080CD1` File\n\n`7901AD25A3673AC9CB1B6AE1FC9DC57A4B53383E` File\n\n`7BA31B83B2ADF7A9B43C56F4882D217512F333AF` Loaders File\n\n`82D653D71DC024C19894C2B2207D6C3414CA1B01` File\n\n`96D5E7C32AC299770E11DF521F867538361D9A8B` File\n\n`A27BB3E5F1CF56C89E5F9816CF8C5796D2FBB09E` File\n\n`A419F091723A5632DA85B0930F3B260599672C00` File\n\n`A527B41D60028BE24BE8CAC69DE9445401F280CD` File\n\n`A695FA12F97971A065FED927A30278C94C78C722` File\n\n`B1B3E88494F7C27354E68D83E16EB65BBEFC7FB3` File\n\n`B7712BBE5DE4386BAB11F61F1731C358648DECE6` File\n\n`BFEF295D375A60A2EEFE416709DE73F14AC1416C` File\n\n`CC595AAE9573BEEF92DE12C3DE9C85F7E9E1CD6D` File\n\n`DBEA8DAF48CC54C7CFB0DCC689D4C9549D3DD23F` File\n\n`DE6D8B66BE01934D672C04E92EA2EDC0210BF00E` File\n\n`E0B9C24DD5620FF70CB80002A4A772E16EB331F2` File\n\n`E489C4D6CA1DAFA034F7FADBF27DEEB202189833` File\n\n`F7EF9A3501EEBCFFA4615CC3BD473F65A203A1D6` File\n\n`FB4401DEA8911BEAB788E87A576EF5568DA82ED5` File\n\n```\n27FC1DCB1B3DCA3E496F799A2944E4FB070AF39C\n\n```\n\nFile\n\n\n`E1599FB73DDE78531BBF65063F10F239AEF29D70` RC2FM backdoor File\n\n`E3BF27F1303BFDB877D1699D5B480342A9A2FE58` File\n\n`7FE30CA69E6631CB9333C37F72E3CABBE8CE366C` RC2FM helper DLL File\n\n\n-----\n\n```\n00EA86AAB3D616A24A5E13D592FABC26416DFDBD\n\n```\n\nFile\n\n\n`094DAEA5B97C510A8E9CFE3585B39B78522A2C61` Decrypted\n\n`0AAB85DDD4E25ADD24E9ECD83C8DD635B3A7C2F3` Decrypted\n\n`0B57CD2393E29084D545300D1749AA50EB23A8AB` Decrypted\n\n`11EBA9E198C458A8D86D70BD64B3FDB0163A38C4` Decrypted\n\n`20FF1A290A53B39C4E54A670E8C27852BE8BCFF4` RC2CL backdoor Decrypted\n\n`554AA9A39CC241AAD5FBDC5FD39CECCB1EB9E7D0` Decrypted\n\n`7114B2E031D8853434028D39873338C33CE67C16` Decrypted\n\n`A1FFFB96415CF4146B056C9A847DC6EECD882DBB` Decrypted\n\n`AF67F640F33D1A46719056B66F45B91B2D56910A` Decrypted\n\n`FFB74AF734453973FED6663C16FB001D563FAF1C` Decrypted\n\n```\n02F4242F7CA7289C8EDFA7B4F465C62C7A6815E2\n\n```\n\nFile\n\n\n`303A63CE12AD42900DA257428E2FD4DE4F9829DC` File\n\nTCP downloader\n\n`DBD21EF03CCC3A985D808B0C5EC7AC54DED5D1C9` Decrypted\n\n`2E7F737CAEB56716ACE36FADEB74EE610705283F` Decrypted\n\n`4B8E11E0734D3109627FF8871EF7DB14C0DE9C41` A variation of the TCP downloader File\n\n```\n31FAE273942A1E432DE91400F5D625F88101B966\n\n```\n\nDecrypted\n\n\n`5F09DF19232E0A77495EEDB1B715D9EF0B909634` File\n\n`E9AF42C4CF0299EEA7B405F9E3E925BCAFAB9F2B` DNS downloader Decrypted\n\n`F67300541D769C5AA071C766198F0B7E25476B23` Decrypted\n\n`F8CAA729C28EF6B0EC8AA74399CE4EE7A59B895C` Decrypted\n\n```\n6F98B12C98DA1FCFF078256970E9B8EF12139640\n\n```\n\nFile\nBatch scripts (Delivery chain)\n\n\n`76FC2E29524C6AD58B0AF05251C419BB942CCED0` File\n\n`2402765EA67E04F151D32BF2B749B150BBD3993E` Stage 2 (Control Panel misuse chain) File\n\n```\n9F64FEC50D4447175459AAB33BC9126F9A3370D8\n\n```\n\nFile\nStage 4 (Control Panel misuse chain)\n\n\n`A3AFF8CE55907DAA1F3360DED01BCF3F6F9D0CF2` File\n```\nE85D7F0564771C9396FDCDB9877DB0FF61C1D515\n\n```\nTotal Video Player exploit File\n```\n10C548992567A04DA199D09E3CA4B0C47B7A136C\n\n```\nStage 4 (Speedfan exploit chain) Decrypted\n\n`B988F107E5F20CDC424EC9F470D157435FC03966` Stage 6 (Speedfan exploit chain) Decrypted\n\n`B894F320569286B56F4272D0CBBA4DB10C645AE0` Stage 3 (Wdigest exploit chain) Registry value\n\n```\n66B7DB6E755EC648AEE210F163655A5662562DEE\n\n```\n\nDecrypted\n\n\n`7E8B99968C59FDE046DF3ECECED6049E4DFA7225` Decrypted\n\n`81BD3140F222FAC2DC6610E0CE79EDF34B599D47` Stage 4 (Wdigest exploit chain) Decrypted\n\n`9A3E870B61C4F37514F6E3E3FAB4D4506D3B50DB` Decrypted\n\n`AA5E8E21C79B0B4A02726233B9F5EB4994C87AD3` Decrypted\n\n```\nA42FA8FB11DA669124AC7968838427BF8E998872\n\n```\n\nDecrypted\nStage 5 (Wdigest exploit chain)\n\n\n`D8B101B588DA6DA3CBE3E161C91986E64D6DD290` Decrypted\n\n\n-----\n\n##### 9.3 Filenames and paths\n\n###### 9.3.1 Delivery chain\n\napi64.cmd\n\nintel_log64.cmd\n\nintel_log64.exe\n\n###### 9.3.2 EternalBlue exploit chain\n\nstg0D0CE03.dll\n\nstg0D33E0A.dll\n\n###### 9.3.3 Control Panel misuse chain\n\n%APPDATA%\\Control\\Control.js\n\n%APPDATA%\\Microsoft\\AddIns\\imageapplet.dat\n\n%APPDATA%\\Microsoft\\AddIns\\infocardadd.cpl\n\n%STARTUP%\\Control Panel.lnk\n\n###### 9.3.4 SMInit exploit chain\n\n%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Sessions\\hskin.dll\n\n%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Sessions\\Settings.ini\n\n%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Sessions\\SMInit.exe\n\n%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Sessions\\TVPSkin.dll\n\n###### 9.3.5 Speedfan exploit chain\n\nC:\\Windows\\system32\\drivers\\NGEN Framework\\NGEN.cab\n\nC:\\Windows\\system32\\drivers\\NGEN Framework\\NGEN.exe\n\nC:\\Windows\\system32\\mscorscvs.exe\n\n###### 9.3.6 Wdigest exploit chain\n\n%APPDATA%\\Microsoft\\Installer\\kb043921.exe\n\n%WINDIR%\\SysWOW64\\drivers\\Rundll32.exe\n\n%WINDIR%\\SysWOW64\\drivers\\wdigest.dll\n\n%WINDIR%\\SysWOW64\\wbem\\setupSNK.exe\n\n###### 9.3.7 InvisiMole loaders\n\nNlsModels0019.dll\n\nNLSModels0022.dll\n\nosppc.dll\n\nosppcext.dll\n\nWptsExtensions.dll\n\n\n-----\n\n###### 9.3.8 RC2FM backdoor\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\0IOQ61KI\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\4AINFWUJ\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\6FFT03MB\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\74BWF9JV\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\7KWRPZWK\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\AMB6HER8\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\CZPOL9V4\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\KQP70AQV\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\MX0ROSB1\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\NI8NKODB\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\OUB1N96O\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\V2JMDODG\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\W9U2CJ6T\n\n%APPDATA%\\Microsoft\\Internet Explorer\\Cache\\Y68JG1TH\n\n%APPDATA%\\Microsoft\\Windows\\Iconcache.db\n\n%APPDATA%Realtek\\Drivers\\Drv7\\DP_Sound_Realtek_wnt\\A6305_WDM\\alcrmv.exe\n\n%TEMP%\\~log\n\n%TEMP%\\vsfilter_%random%.dll\n\n##### 9.4 Registry keys / values / data\n\n###### 9.4.1 Control Panel misuse chain\n```\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs\n“infocard” = %APPDATA%\\Microsoft\\AddIns\\infocardadd.cpl\n\n 9.4.2 Speedfan exploit chain\nHKLM\\SYSTEM\\ControlSet001\\services\\clr_optimization_v2.0.51527_X86\n    “Type”=dword:00000010\n    “Start”=dword:00000002\n    “ErrorControl”=dword:00000000\n    “ImagePath”= “C:\\Windows\\system32\\mscorscvs.exe”\n    “DisplayName”=”Microsoft .NET Framework NGEN v2.0.51527_X86”\n    “ObjectName”=”LocalSystem”\n    “Description”=”Microsoft .NET Framework NGEN v.2”\nHKLM\\SYSTEM\\ControlSet001\\services\\clr_optimization_v2.0.51527_X86\\Parameters\n    “Application”=”C:\\Windows\\system32\\drivers\\NGEN Framework\\NGEN.exe”\n    “AppDirectory”=”C:\\Windows\\system32\\drivers\\NGEN Framework”\n    “AppParameters”=”VirtualAlloc 0 0x20000 0x3000 0x40, CreateFileW “Ngen.\n    cab” 0x80000000 0 0 3 0 0, SetFilePointer $$:7 64 0 0, ReadFile $$:7 $$:1\n    0x20000 $b:4 0, CloseHandle $$:7, EnumUILanguagesA $$:1 4 $$:1”\nHKLM\\software\\microsoft\\drm or HKLM\\software\\microsoft\\windows\\currentversion or\nHKLM\\software\\microsoft\\windows\\currentversion\\ext or HKLM\\software\\microsoft\\\nfunction discovery\\registrystore\\publication\\explorer\n    “1Extylc8fC5X1PL”\n    “1Extylc8fC5X1HK”\n    “1Extylc8fC5X1RK”\n\n```\n\n-----\n\n```\n    “1Extylc8fC5X1PL”\n    “1Extylc8fC5X1HK”\n    “1Extylc8fC5X1RK”\n    “1Extylc8fC5X1PL”\n    “1Extylc8fC5X1HK”\n    “1Extylc8fC5X1RK”\n\n###### 9.4.3 Wdigest exploit chain\n\n```\nHKCU\\SOFTWARE\\Classes\\lnkfile\n```\n    “Curver” = “.zeros”\nHKCU\\SOFTWARE\\Classes\\ms-settings\n    “Curver” = “.zeros”\nHKCU\\SOFTWARE\\Classes\\.zeros\\shell\\open\n    “command” = “”%APPDATA%\\Microsoft\\Installer\\kb043921.exe” OpenFileMappingW\n    0xF003F 0 “XVD21x9DC”, MapViewOfFile $$:1 0xF003F 0 0 %installer_size%,\n    CreateThread 0 0 $$:6 $$:6 0 0, WaitForSingleObject $$:13 -1”\n\n```\nHKLM\\SOFTWARE\\Microsoft\\FlashConfig or HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\FlashConfig\n\n“FlashConfigEnrollee” = “shell32 ShellExec_RunDLL “C:\\Windows\\SysWOW64\\\n```\n    drivers\\Rundll32.exe” “C:\\Windows\\SysWOW64\\drivers\\wdigest.dll”,SpInitialize\n    %SHELLCODE_BYTES%”\nHKLM\\SOFTWARE\\ODBC or HKLM\\SOFTWARE\\WOW6432Node\\ODBC\n    “A”\n    “B”\n    “C”\n    “D”\n    “M”\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\CsPower\n    “Type”=dword:00000020\n    “Start”=dword:00000004\n    “ErrorControl”=dword:00000000\n    “ImagePath”= “%SystemRoot%\\System32\\svchost.exe -k DComLaunch” (translated\n    from hex)\n    “DisplayName”=”System Group”\n    “Group”=”Plugplay”\n    “ObjectName”=”LocalSystem”\n    “RequiredPrivileges”=SeTcbPrivilege\n        SeSecurityPrivilege\n        SeAssignPrimaryTokenPrivilege\n        SeTakeOwnershipPrivilege\n        SeLoadDriverPrivilege\n        SeBackupPrivilege\n        SeRestorePrivilege\n        SeImpersonatePrivilege\n        SeAuditPrivilege\n        SeChangeNotifyPrivilege\n        SeUndockPrivilege\n\n```\n\n-----\n\n```\n        SeDebugPrivilege\n        SeSystemEnvironmentPrivilege (translated from hex)\n    “DeleteFlag”=dword:00000001\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\CsPower\\Parameters\n    “ServiceDll”= “%SystemRoot%\\System32\\FXSCOMPOSE.dll” (translated from hex)\n    “ServiceMain”=”HrSelectEmailRecipient”\n\n###### 9.4.4 DNS downloader\nHKCU\\Software\\Microsoft\\EventSystem\n    “AutoExA”\n    “AutoExB”\n    “AutoExC”\nHKCU\\Software\\Microsoft\\EventSystem\n    “KeyA”\n    “KeyB”\n    “KeyC”\n\n 9.4.5 RC2FM backdoor\nHKCU\\Software\\Microsoft\\IE\\Cache\n    “Index”\nHKCU\\Software\\Microsoft\\IE\n    “SecureProtocols”\nHKCU\\Software\\Microsoft\\IE\\Thumbnails\n\n 9.4.6 RC2CL backdoor\nHKCU\\Software\\Microsoft\\Direct3D or HKLM\\Software\\Microsoft\\Windows NT\\\nCurrentVersion\\Console\n    “BSKS”\n    “Common”\n    “Current”\n    “DisableFM”\n    “Edit”\n    “ENC”\n    ”ENCEx”\n    “ENCEx2”\n    “FFLT”\n    “Flag1”\n    “FlagLF”\n    “FlagLF2”\n    “IfData”\n    “INFO”\n    “InstallA”\n\n```\n\n-----\n\n```\n“InstallB”\n“LastFD”\n“LegacyImpersonationNumber”\n“LM”\n“MachineAccessStateData”\n“MachineAT”\n“MachineDataUM”\n“MachineNW”\n“MachineState 0”\n“MFLT”\n“OverMin”\n“RPT”\n“SettingsFM”\n“SettingsMC”\n“SettingsSR1”\n“SettingsSR2”\n“SP2”\n“SP3”\n“UseDFlag”\n(Unknown registry key)\n“Value_Bck”\n“Value_Cmnm”\n“Value_CMS”\n“Value_DFl”\n“Value_DFM”\n“Value_FAT”\n“Value_FGL”\n“Value_FPP_ZC”\n“Value_LastL”\n“Value_LgsD”\n“Value_LM”\n“Value_LNM”\n“Value_LsFl1”\n“Value_LsFl2”\n“Value_M1”\n“Value_MD”\n“Value_MF”\n“Value_MFV”\n“Value_MIN”\n“Value_MMc”\n“Value_MNL”\n“Value_MRP”\n“Value_MSS”\n“Value_onFPL”\n“Value_OvMin”\n“Value_PEIP_ZC”\n\n```\n\n-----\n\n```\n    “Value_PtS”\n    “Value_SlF”\n    “Value_SR1”\n    “Value_SR2”\n    “Value_SRC”\n    “Value_uLA”\n    “Value_uLB”\n    “Value_Ulcf”\n    “Value_UM”\n    “Value_WDSP_ZC”\n    “Value_WPDF_ZC”\n    “Value_WSFX_ZC”\n\n##### 9.5 Synchronization objects\n\n###### 9.5.1 Mutex names\n\n```\nMSO~2\n\nMSO~4\n\nMutex_sync\n\nwkssvmtx\n\n###### Semaphore names\n\nGlobal\\BrLK\n\nGlobal\\GtLK\n\nGlobal\\M6Br\n\nGlobal\\M6Gt\n\nGlobal\\M6Nx\n\nGlobal\\M6St\n\nGlobal\\MBrT\n\nGlobal\\MMGt\n\nGlobal\\MMNx\n\nGlobal\\MMSt\n\nGlobal\\NxLK\n\nGlobal\\StLK\n\nGlobal\\TsLK\n\nGlobal\\TsM5\n\nGlobal\\TsM6\n\n###### 9.5.2 Shared memory names\n\nExMp0043\n\nExMp0044\n\nXVD21x9DC\n\n\n-----\n\n###### 9.5.3 Event names\n\nEvMExM2ER\n\nEvMExM2OK\n\nExMpER43\n\nExMpER44\n\nExMpOK43\n\nExMpOK44\n\n##### 9.6 C&C servers\n\n###### 9.6.1 IP addresses\n\n46.165.220[.]228\n\n80.255.3[.]66\n\n85.17.26[.]174\n\n185.193.38[.]55\n\n194.187.249[.]157\n\n195.154.255[.]211\n\n###### 9.6.2 Domain names\n\n153[.]re\n\nadstat[.]red\n\nadtrax[.]net\n\nakamai.sytes[.]net\n\namz-eu401[.]com\n\nblabla234342.sytes[.]net\n\nmx1[.]be\n\nstatad[.]de\n\ntime.servehttp[.]com\n\nupd[.]re\n\nupdate[.]xn--6frz82g (update[.]移动)\n\nupdatecloud.sytes[.]net\n\nupdchecking.sytes[.]net\n\nwlsts[.]net\n\n#### 10 MITRE ATT&CK TECHNIQUES\n\n_Note: For better readability, we have separated the RC2FM and RC2CL backdoors into their respective ATT&CK_\n\n_mapping tables, because of their rich capabilities. The first mapping pertains to InvisiMole’s supporting components_\n\n_used for delivery, lateral movement, execution chains, and for downloading additional payloads._\n\n\n-----\n\n##### 10.1 InvisiMole\n\n**Tactic** **ID** **Name** **Description**\n\nInvisiMole’s loader is masked as a CPL file, misusing control panel\n_[T1196](https://attack.mitre.org/techniques/T1196/)_ Control Panel Items\nitems for execution.\n\nInvisiMole has used ShellExecuteW and CreateProcessW APIs\n_[T1106](https://attack.mitre.org/techniques/T1106/)_ Execution through API\nto execute files.\n\nExecution through Module InvisiMole implements a custom loader for its components\n_[T1129](https://attack.mitre.org/techniques/T1129/)_\nLoad (InvisiMole blobs).\n\n\nExploitation for Client\n_[T1203](https://attack.mitre.org/techniques/T1203/)_\nExecution\n\n\nInvisiMole has delivered vulnerable Total Video Player\nsoftware and wdigest.dll library and exploited their stack\noverflow and input validation vulnerabilities, respectively, to gain\ncovert code execution.\n\n\nExecution\n\nPersistence\n\nPrivilege\nEscalation\n\n\nExploitation for Privilege\n_[T1068](https://attack.mitre.org/techniques/T1068/)_\nEscalation\n\n\n_[T1085](https://attack.mitre.org/techniques/T1085/)_ Rundll32 InvisiMole has used rundll32.exe as part of its execution chain.\n\nInvisiMole has used Windows task scheduler as part of its\n_[T1053](https://attack.mitre.org/techniques/T1053/)_ Scheduled Task\nexecution chains.\n\nInvisiMole has used a JavaScript file named Control.js as part of\n_[T1064](https://attack.mitre.org/techniques/T1064/)_ Scripting\nits execution chain.\n\nInvisiMole has registered a Windows service as one of the ways to\n_[T1035](https://attack.mitre.org/techniques/T1035/)_ Service Execution\nexecute its malicious payload.\n\nInvisiMole has been delivered as trojanized versions of software\n_[T1204](https://attack.mitre.org/techniques/T1204/)_ User Execution and documents, using deceiving names and icons and relying on\nuser execution.\n\nInvisiMole has registered a Windows service named\n_[T1050](https://attack.mitre.org/techniques/T1050/)_ New Service\n```\n                      clr_optimization_v2.0.51527_X86 to achieve persistence.\n\n```\nRegistry Run Keys / Startup InvisiMole has placed a LNK file in Startup Folder to achieve\n_[T1060](https://attack.mitre.org/techniques/T1060/)_\nFolder persistence.\n\n\n_[T1053](https://attack.mitre.org/techniques/T1053/)_ Scheduled Task\n\n\nInvisiMole has scheduled tasks under names MSST and\n```\n\\Microsoft\\Windows\\Autochk\\Scheduled to achieve\n\n```\npersistence.\n\n\nInvisiMole has placed a LNK file in Startup Folder to achieve\n_[T1023](https://attack.mitre.org/techniques/T1023/)_ Shortcut Modification\npersistence.\n\n_[T1088](https://attack.mitre.org/techniques/T1088/)_ Bypass User Account Control InvisiMole can bypass UAC to obtain elevated privileges.\n\n\nInvisiMole has exploited CVE-2007-5633 vulnerability in\n```\nspeedfan.sys driver to obtain kernel mode privileges.\n\n```\n\n-----\n\nDeobfuscate/Decode Files or\n_[T1140](https://attack.mitre.org/techniques/T1140/)_\nInformation\n\n_[T1480](https://attack.mitre.org/techniques/T1480/)_ Execution Guardrails\n\n\nInvisiMole decrypts strings using variations of XOR\ncipher. InvisiMole decrypts its components using the\n```\nCryptUnprotectData API and two-key triple DES.\n\n```\nInvisiMole has used Data Protection API to encrypt its\ncomponents on the victim’s computer, to evade detection and\nmake sure the payload can only be decrypted (and then loaded)\non one specific compromised computer.\n\n\nDefense\nEvasion\n\nDiscovery\n\nLateral\nMovement\n\n\nInvisiMole has executed legitimate tools in hidden windows and\n_[T1143](https://attack.mitre.org/techniques/T1143/)_ Hidden Window\nused them to execute malicious InvisiMole components.\n\nInvisiMole has undergone technical improvements in attempt to\n_[T1066](https://attack.mitre.org/techniques/T1066/)_ Indicator Removal from Tools\nevade detection.\n\n[InvisiMole has used winapiexec tool for indirect execution of](https://rammichael.com/winapiexec)\n_[T1202](https://attack.mitre.org/techniques/T1202/)_ Indirect Command Execution\nWindows API functions.\n\nObfuscated Files or InvisiMole has obfuscated strings and code to make analysis more\n_[T1027](https://attack.mitre.org/techniques/T1027/)_\nInformation difficult, and encrypted its components to thwart detection.\n\nInvisiMole has injected its code into trusted processes using an\n_[T1055](https://attack.mitre.org/techniques/T1055/)_ Process Injection\nimproved ListPlanting technique and via APC queue.\n\nInvisiMole has deployed multiple backdoors on a single\n_[T1108](https://attack.mitre.org/techniques/T1108/)_ Redundant Access\ncompromised computer.\n\n_[T1085](https://attack.mitre.org/techniques/T1085/)_ Rundll32 InvisiMole has used rundll32.exe as part of its execution chain.\n\nInvisiMole’s loader uses a JavaScript script as a part of setting up\n_[T1064](https://attack.mitre.org/techniques/T1064/)_ Scripting\npersistence.\n\nInvisiMole’s DNS plugin avoids connecting to the C&C server if\n_[T1063](https://attack.mitre.org/techniques/T1063/)_ Security Software Discovery\nselected network sniffers are detected running.\n\nInvisiMole has modified timestamps of files that it creates or\n_[T1099](https://attack.mitre.org/techniques/T1099/)_ Timestomp\nmodifies.\n\nInvisiMole has attempted to disguise its droppers as legitimate\n_[T1036](https://attack.mitre.org/techniques/T1036/)_ Masquerading software or documents, and to conceal itself by registering under\na seemingly legitimate service name.\n\n\nInvisiMole’s DNS downloader attempts to detect selected network\n_[T1518](https://attack.mitre.org/techniques/T1518/)_ Software Discovery sniffer tools, and pauses its network traffic if any are detected\nrunning.\n\nInvisiMole’s DNS downloader collects computer name and system\n_[T1082](https://attack.mitre.org/techniques/T1082/)_ System Information Discovery\nvolume serial number.\n\n_[T1124](https://attack.mitre.org/techniques/T1124/)_ System Time Discovery InvisiMole can collect the timestamp from the victim’s machine.\n\nExploitation of Remote InvisiMole has exploited EternalBlue and BlueKeep vulnerabilities\n_[T1210](https://attack.mitre.org/techniques/T1210/)_\nServices for lateral movement.\n\nInvisiMole has replaced legitimate software or documents in\n_[T1080](https://attack.mitre.org/techniques/T1080/)_ Taint Shared Content the compromised network with their trojanized versions, in an\nattempt to propagate itself within the network.\n\n\n_[T1046](https://attack.mitre.org/techniques/T1046/)_ Network Service Scanning\n\n\nInvisiMole has performed network scanning within the\ncompromised network using its Portscan and BlueKeep\ncomponents, in order to search for open ports and for hosts\nvulnerable to the BlueKeep vulnerability.\n\n\n-----\n\nCommand and\nControl\n\n\nInvisiMole’s downloader uses port 443 for C&C communication.\n_[T1043](https://attack.mitre.org/techniques/T1043/)_ Commonly Used Port\nInvisiMole’s DNS plugin uses port 53 for C&C communication.\n\nInvisiMole’s TCP downloader is able to utilize user-configured\n_[T1090](https://attack.mitre.org/techniques/T1090/)_ Connection Proxy\nproxy servers for C&C communication.\n\nCustom Cryptographic InvisiMole’s TCP and DNS downloaders use a custom\n_[T1024](https://attack.mitre.org/techniques/T1024/)_\nProtocol cryptographic protocol for encrypting network communication.\n\nInvisiMole’s DNS downloader uses a variation of base32 encoding\n_[T1132](https://attack.mitre.org/techniques/T1132/)_ Data Encoding\nto encode data into the subdomain in its requests.\n\nInvisiMole’s TCP and DNS downloaders are configured with\n_[T1008](https://attack.mitre.org/techniques/T1008/)_ Fallback Channels\nseveral C&C servers.\n\nInvisiMole’s TCP and DNS downloaders can download additional\n_[T1105](https://attack.mitre.org/techniques/T1105/)_ Remote File Copy\nfiles to be executed on the compromised system.\n\nStandard Application Layer InvisiMole’s DNS downloader uses DNS protocol for C&C\n_[T1071](https://attack.mitre.org/techniques/T1071/)_\nProtocol communication.\n\nStandard Non-Application InvisiMole’s TCP downloader uses TCP protocol for C&C\n_[T1095](https://attack.mitre.org/techniques/T1095/)_\nLayer Protocol communication.\n\nInvisiMole’s TCP downloader uses port 1922 for C&C\n_[T1065](https://attack.mitre.org/techniques/T1065/)_ Uncommonly Used Port\ncommunication.\n\n\n##### 10.2 RC2CL backdoor\n\n**Tactic** **ID** **Name** **Description**\n\n_[T1059](https://attack.mitre.org/techniques/T1059/)_ Command-Line Interface RC2CL backdoor can create a remote shell to execute commands.\n\n\nExecution\n\nPrivilege\nEscalation\n\nDefense\nEvasion\n\n\nRC2CL backdoor uses CreateProcess and CreateProcessAsUser\n_[T1106](https://attack.mitre.org/techniques/T1106/)_ Execution through API\nAPIs to execute files.\n\nRC2CL backdoor can use CreateProcessAsUser API to start a new\n_[T1134](https://attack.mitre.org/techniques/T1134/)_ Access Token Manipulation\nprocess under context of another user or process.\n\nRC2CL backdoor can disable and bypass UAC to obtain elevated\n_[T1088](https://attack.mitre.org/techniques/T1088/)_ Bypass User Account Control\nprivileges.\n\nRC2CL backdoor can be configured as a proxy relaying\n_[T1090](https://attack.mitre.org/techniques/T1090/)_ Connection Proxy communication between other compromised computers and C&C\nserver.\n\nDeobfuscate/Decode Files or\n_[T1140](https://attack.mitre.org/techniques/T1140/)_ RC2CL backdoor decrypts strings using variations of XOR cipher.\nInformation\n\n_[T1089](https://attack.mitre.org/techniques/T1089/)_ Disabling Security Tools RC2CL backdoor is able to disable Windows firewall.\n\n\n_[T1107](https://attack.mitre.org/techniques/T1107/)_ File Deletion\n\n\nRC2CL backdoor can delete dropped artifacts, and various files ondemand following a delete command.\n\nRC2CL backdoor can safely delete files to thwart forensic analysis.\n\n\n_[T1112](https://attack.mitre.org/techniques/T1112/)_ Modify Registry RC2CL backdoor hides its configuration within registry keys.\n\nObfuscated Files or RC2CL backdoor obfuscates/encrypts strings and code to make\n_[T1027](https://attack.mitre.org/techniques/T1027/)_\nInformation analysis more difficult.\n\nRC2CL backdoor modifies timestamps of files that it creates/\n_[T1099](https://attack.mitre.org/techniques/T1099/)_ Timestomp\nmodifies.\n\n_[T1497](https://attack.mitre.org/techniques/T1497/)_ Virtualization/Sandbox Evasion RC2CL backdoor is able to detect virtualized environments.\n\n\n-----\n\nDiscovery\n\nCollection\n\nCommand and\nControl\n\nExfiltration\n\n\nRC2CL backdoor can list account information and session\n_[T1087](https://attack.mitre.org/techniques/T1087/)_ Account Discovery\ninformation.\n\n_[T1010](https://attack.mitre.org/techniques/T1010/)_ Application Window Discovery RC2CL backdoor can list information about active windows.\n\nRC2CL backdoor can list files, and specifically recently opened files,\n_[T1083](https://attack.mitre.org/techniques/T1083/)_ File and Directory Discovery\nand list information about mapped/unmapped drives.\n\nRC2CL backdoor is able to scan the compromised network for hosts\n_[T1046](https://attack.mitre.org/techniques/T1046/)_ Network Service Scanning\nvulnerable to EternalBlue vulnerability.\n\n_[T1057](https://attack.mitre.org/techniques/T1057/)_ Process Discovery RC2CL backdoor can list running processes.\n\nRC2CL backdoor can query registry to obtain information about\n_[T1012](https://attack.mitre.org/techniques/T1012/)_ Query Registry installed software, applications accessed by users, applications\nexecuted on user login/system start, recently opened files,\n\nRC2CL backdoor modifies its behavior if Bitdefender firewall is\n_[T1063](https://attack.mitre.org/techniques/T1063/)_ Security Software Discovery\nenabled, or if selected AV processes are detected running.\n\nRC2CL backdoor can list installed software, recently accessed\n_[T1518](https://attack.mitre.org/techniques/T1518/)_ Software Discovery software by users, software executed on each user login and/or\neach system start.\n\nRC2CL backdoor can list information about loaded drivers, computer\n_[T1082](https://attack.mitre.org/techniques/T1082/)_ System Information Discovery name, OS version, memory status, local time, system and process\nDEP policy, …\n\n\n_[T1007](https://attack.mitre.org/techniques/T1007/)_ System Service Discovery RC2CL backdoor can list system service information.\n\nRC2CL backdoor can record the sounds from microphones on a\n_[T1123](https://attack.mitre.org/techniques/T1123/)_ Audio Capture computer. RC2FM misuses a legitimate lame.dll for MP3 encoding of\nthe recordings.\n\nRC2CL backdoor can collect data from the system, and can monitor\n_[T1005](https://attack.mitre.org/techniques/T1005/)_ Data from Local System\nchanges in specified directories.\n\nRC2CL backdoor can store collected data in a central location for a\n_[T1074](https://attack.mitre.org/techniques/T1074/)_ Data Staged\nlater exfiltration.\n\nRC2CL backdoor can capture screenshots of the victim’s screen.\n_[T1113](https://attack.mitre.org/techniques/T1113/)_ Screen Capture\nRC2CL backdoor can also capture screenshots of separate windows.\n\nRC2CL backdoor can access victim’s webcam and capture photos/\n_[T1125](https://attack.mitre.org/techniques/T1125/)_ Video Capture\nrecord videos.\n\nRC2CL backdoor is configured with several C&C servers. Via a\n_[T1008](https://attack.mitre.org/techniques/T1008/)_ Fallback Channels backdoor command, it is possible to extend the list and change\nwhich C&C server is used.\n\nInvisiMole can download additional files to be executed on the\n_[T1105](https://attack.mitre.org/techniques/T1105/)_ Remote File Copy\ncompromised system.\n\n_[T1065](https://attack.mitre.org/techniques/T1065/)_ Uncommonly Used Port RC2CL backdoor uses port 1922 for C&C communication.\n\nRC2CL backdoor can create zlib and SFX archives. It misuses a copy\n_[T1002](https://attack.mitre.org/techniques/T1002/)_ Data Compressed\nof the legitimate WinRAR tool for compression and decompression.\n\n_[T1022](https://attack.mitre.org/techniques/T1022/)_ Data Encrypted RC2CL backdoor uses variations of XOR cipher to encrypt data.\n\nExfiltration Over Command RC2CL backdoor exfiltrates collected information over its C&C\n_[T1041](https://attack.mitre.org/techniques/T1041/)_\nand Control Channel channel.\n\n\nSystem Network Configuration\n_[T1016](https://attack.mitre.org/techniques/T1016/)_\nDiscovery\n\n\nRC2CL backdoor can list IP table; configured proxy information;\ninformation about enabled wireless networks for geolocation of the\nvictims.\n\n\n-----\n\n##### 10.3 RC2FM backdoor\n\n**Tactic** **ID** **Name** **Description**\n\n_[T1059](https://attack.mitre.org/techniques/T1059/)_ Command-Line Interface RC2FM backdoor can create a remote shell to execute commands.\n\n\nExecution\n\n\nRC2FM backdoor supports a command that uses ShellExecute and\n_[T1106](https://attack.mitre.org/techniques/T1106/)_ Execution through API\n```\n                      CreateProcess APIs to execute files.\n\n```\n\nPrivilege\n_[T1088](https://attack.mitre.org/techniques/T1088/)_ Bypass User Account Control RC2FM backdoor can bypass UAC to obtain elevated privileges.\nEscalation\n\nDeobfuscate/Decode Files or\n_[T1140](https://attack.mitre.org/techniques/T1140/)_ RC2FM backdoor decrypts strings using variations of XOR cipher.\nInformation\n\nRC2FM backdoor can delete dropped artifacts, and various files on_[T1107](https://attack.mitre.org/techniques/T1107/)_ File Deletion\ndemand following a delete command.\n\nRC2FM backdoor uses CREATE_NO_WINDOW creation flag to execute\n_[T1143](https://attack.mitre.org/techniques/T1143/)_ Hidden Window\nmalware in hidden window.\n\n_[T1112](https://attack.mitre.org/techniques/T1112/)_ Modify Registry RC2FM backdoor hides its configuration within registry keys.\n\n\nDefense\nEvasion\n\nDiscovery\n\nCollection\n\nCommand and\nControl\n\n\nObfuscated Files or RC2FM backdoor obfuscates/encrypts strings and code to make analysis\n_[T1027](https://attack.mitre.org/techniques/T1027/)_\nInformation more difficult.\n\nRC2FM backdoor can inject itself into ctfmon.exe, dwm.exe, sihost.exe\n_[T1055](https://attack.mitre.org/techniques/T1055/)_ Process Injection\nand taskhost.exe processes.\n\nRC2FM backdoor uses rundll32.exe to load a stub DLL to which it then\n_[T1085](https://attack.mitre.org/techniques/T1085/)_ Rundll32\ninjects itself.\n\n_[T1099](https://attack.mitre.org/techniques/T1099/)_ Timestamp RC2FM backdoor modifies timestamps of files that it creates/modifies.\n\n_[T1497](https://attack.mitre.org/techniques/T1497/)_ Virtualization/Sandbox Evasion RC2FM backdoor is able to detect virtualized environments.\n\nRC2FM backdoor collects information about mapped drives. It can list\n_[T1083](https://attack.mitre.org/techniques/T1083/)_ File and Directory Discovery\nfiles in a specific folder.\n\n_[T1135](https://attack.mitre.org/techniques/T1135/)_ Network Share Discovery RC2FM backdoor can list connected network shares.\n\n_[T1057](https://attack.mitre.org/techniques/T1057/)_ Process Discovery RC2FM backdoor can list running processes.\n\nRC2FM backdoor collects computer name and system volume serial\n_[T1082](https://attack.mitre.org/techniques/T1082/)_ System Information Discovery\nnumber.\n\nSystem Network Configuration\n_[T1016](https://attack.mitre.org/techniques/T1016/)_ RC2FM backdoor lists information about configured proxy servers.\nDiscovery\n\nRC2FM backdoor can record the sounds from microphones on a\n_[T1123](https://attack.mitre.org/techniques/T1123/)_ Audio Capture computer. It misuses a legitimate lame.dll for MP3 encoding of the\nrecordings.\n\n_[T1025](https://attack.mitre.org/techniques/T1025/)_ Data from Removable Media RC2FM backdoor can collect jpeg files from connected MTP devices.\n\n_[T1056](https://attack.mitre.org/techniques/T1056/)_ Input Capture RC2FM backdoor can collect keystrokes.\n\n_[T1113](https://attack.mitre.org/techniques/T1113/)_ Screen Capture RC2FM backdoor can capture screenshots of the victim’s screen.\n\n_[T1043](https://attack.mitre.org/techniques/T1043/)_ Commonly Used Port RC2FM backdoor uses port 80 for C&C communication.\n\nRC2FM backdoor can use proxies configured on the local system, for\n_[T1090](https://attack.mitre.org/techniques/T1090/)_ Connection Proxy various installed and portable browsers, if direct connection to the C&C\nserver fails.\n\nRC2FM backdoor is configured with several C&C servers. It is possible to\n_[T1008](https://attack.mitre.org/techniques/T1008/)_ Fallback Channels\nupdate the C&C server by a backdoor command.\n\nInvisiMole can download additional files to be executed on the\n_[T1105](https://attack.mitre.org/techniques/T1105/)_ Remote File Copy\ncompromised system.\n\nStandard Application Layer\n_[T1071](https://attack.mitre.org/techniques/T1071/)_ RC2FM backdoor uses HTTP for C&C communication.\nProtocol\n\n\n-----\n\nExfiltration\n\n\n_[T1022](https://attack.mitre.org/techniques/T1022/)_ Data Encrypted RC2FM backdoor uses variations of XOR cipher to encrypt data.\n\nExfiltration Over Command\n_[T1041](https://attack.mitre.org/techniques/T1041/)_ RC2FM backdoor exfiltrates collected information over its C&C channel.\nand Control Channel\n\n\n-----\n\n#### ABOUT ESET\n\n[For 30 years, ESET® has been developing industry-leading IT security software and services for](http://www.eset.com/int/)\n\nbusinesses and consumers worldwide. With solutions ranging from endpoint and mobile security,\n\nto encryption and two-factor authentication, ESET’s high-performing, easy-to-use products give\n\nconsumers and businesses the peace of mind to enjoy the full potential of their technology. ESET\n\nunobtrusively protects and monitors 24/7, updating defenses in real time to keep users safe and\n\nbusinesses running without interruption. Evolving threats require an evolving IT security company.\n\n[Backed by R&D centers worldwide, ESET becomes the first IT security company to earn 100 Virus](https://www.eset.com/int/about/newsroom/awards/eset-first-to-break-magical-100-vb100-awards-threshold/)\n\n_[Bulletin VB100 awards, identifying every single “in-the-wild” malware without interruption since 2003.](https://www.eset.com/int/about/newsroom/awards/eset-first-to-break-magical-100-vb100-awards-threshold/)_\n\n[For more information, visit www.eset.com or follow us on LinkedIn, Facebook and Twitter.](https://cz.linkedin.com/company/eset)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.06.18.InvisiMole_hidden_arsenal/ESET_InvisiMole.pdf",
        "https://www.welivesecurity.com/wp-content/uploads/2020/06/ESET_InvisiMole.pdf"
    ],
    "report_names": [
        "ESET_InvisiMole",
        "ESET_InvisiMole.pdf"
    ],
    "threat_actors": [
        {
            "id": "81bd7107-6b2d-45c9-9eea-1843d4b9b308",
            "created_at": "2022-10-25T15:50:23.320841Z",
            "updated_at": "2025-03-27T02:00:55.441723Z",
            "deleted_at": null,
            "main_name": "Gamaredon Group",
            "aliases": [
                "Gamaredon Group",
                "IRON TILDEN",
                "Primitive Bear",
                "ACTINIUM",
                "Armageddon",
                "Shuckworm",
                "DEV-0157",
                "Aqua Blizzard"
            ],
            "source_name": "MITRE:Gamaredon Group",
            "tools": [
                "QuietSieve",
                "Pteranodon",
                "PowerPunch"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c91e335e-42be-48d9-96b5-ba56749a723b",
            "created_at": "2022-10-25T16:07:23.458346Z",
            "updated_at": "2025-03-27T02:02:09.813395Z",
            "deleted_at": null,
            "main_name": "CIA",
            "aliases": [
                "Central Intelligence Agency"
            ],
            "source_name": "ETDA:CIA",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "11f52079-26d3-4e06-8665-6a0b3efdc41c",
            "created_at": "2022-10-25T16:07:23.736987Z",
            "updated_at": "2025-03-27T02:02:09.954078Z",
            "deleted_at": null,
            "main_name": "InvisiMole",
            "aliases": [
                "UAC-0035"
            ],
            "source_name": "ETDA:InvisiMole",
            "tools": [
                "InvisiMole"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d5156b55-5d7d-4fb2-836f-861d2e868147",
            "created_at": "2023-01-06T13:46:38.557326Z",
            "updated_at": "2025-03-27T02:00:02.861124Z",
            "deleted_at": null,
            "main_name": "Gamaredon Group",
            "aliases": [
                "Aqua Blizzard",
                "Actinium",
                "DEV-0157",
                "Blue Otso",
                "G0047",
                "PRIMITIVE BEAR",
                "Shuckworm",
                "Trident Ursa",
                "UAC-0010",
                "Winterflounder",
                "ACTINIUM",
                "BlueAlpha",
                "IRON TILDEN"
            ],
            "source_name": "MISPGALAXY:Gamaredon Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "12b5d602-4017-4a6f-a2a3-387a6e07a27b",
            "created_at": "2023-01-06T13:46:39.095233Z",
            "updated_at": "2025-03-27T02:00:02.995336Z",
            "deleted_at": null,
            "main_name": "InvisiMole",
            "aliases": [],
            "source_name": "MISPGALAXY:InvisiMole",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "61940e18-8f90-4ecc-bc06-416c54bc60f9",
            "created_at": "2022-10-25T16:07:23.659529Z",
            "updated_at": "2025-03-27T02:02:09.912404Z",
            "deleted_at": null,
            "main_name": "Gamaredon Group",
            "aliases": [
                "Actinium",
                "Aqua Blizzard",
                "Armageddon",
                "Blue Otso",
                "BlueAlpha",
                "Callisto",
                "DEV-0157",
                "Iron Tilden",
                "Operation STEADY#URSA",
                "Primitive Bear",
                "SectorC08",
                "Shuckworm",
                "Trident Ursa",
                "UAC-0010",
                "Winterflounder"
            ],
            "source_name": "ETDA:Gamaredon Group",
            "tools": [
                "Aversome infector",
                "BoneSpy",
                "DessertDown",
                "DilongTrash",
                "DinoTrain",
                "EvilGnome",
                "FRAUDROP",
                "Gamaredon",
                "GammaDrop",
                "GammaLoad",
                "GammaSteel",
                "Gussdoor",
                "ObfuBerry",
                "ObfuMerry",
                "PlainGnome",
                "PowerPunch",
                "Pteranodon",
                "Pterodo",
                "QuietSieve",
                "Remote Manipulator System",
                "Resetter",
                "RuRAT",
                "SUBTLE-PAWS",
                "UltraVNC"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "236a8303-bf12-4787-b6d0-549b44271a19",
            "created_at": "2024-06-04T02:03:07.966137Z",
            "updated_at": "2025-03-27T02:05:17.410356Z",
            "deleted_at": null,
            "main_name": "IRON TILDEN",
            "aliases": [
                "Aqua Blizzard ",
                "Armageddon",
                "Blue Otso ",
                "BlueAlpha ",
                "Dancing Salome ",
                "Gamaredon",
                "Gamaredon Group",
                "Hive0051 ",
                "Primitive Bear ",
                "Shuckworm ",
                "Trident Ursa ",
                "UAC-0010 ",
                "UNC530 ",
                "WinterFlounder ",
                "ACTINIUM "
            ],
            "source_name": "Secureworks:IRON TILDEN",
            "tools": [
                "Pterodo"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041637,
    "ts_creation_date": 1592220403,
    "ts_modification_date": 1592229307,
    "files": {
        "pdf": "https://archive.orkl.eu/ecbed95d0006c27f040e1e371a8bc71084ae425d.pdf",
        "text": "https://archive.orkl.eu/ecbed95d0006c27f040e1e371a8bc71084ae425d.txt",
        "img": "https://archive.orkl.eu/ecbed95d0006c27f040e1e371a8bc71084ae425d.jpg"
    }
}