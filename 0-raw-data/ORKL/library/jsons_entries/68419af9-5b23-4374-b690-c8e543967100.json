{
    "id": "68419af9-5b23-4374-b690-c8e543967100",
    "created_at": "2023-01-12T15:06:35.091467Z",
    "updated_at": "2025-03-27T02:05:52.571428Z",
    "deleted_at": null,
    "sha1_hash": "8a6af616dc560e96db993075fb8ccd23019d87f7",
    "title": "2022-03-04 - HermeticWiper- A detailed analysis of the destructive malware that targeted Ukraine",
    "authors": "",
    "file_creation_date": "2022-05-28T03:20:19Z",
    "file_modification_date": "2022-05-28T03:20:19Z",
    "file_size": 9544281,
    "plain_text": "# HermeticWiper: A detailed analysis of the destructive malware that targeted Ukraine\n\n**blog.malwarebytes.com/threat-intelligence/2022/03/hermeticwiper-a-detailed-analysis-of-the-destructive-malware-that-**\ntargeted-ukraine/\n\nThreat Intelligence Team March 4, 2022\n\n_This blog post was authored by Hasherezade, Ankur Saini and Roberto Santos_\n\nDisk wipers are one particular type of malware often used against Ukraine. The\nimplementation and quality of those wipers vary, and may suggest different hired developers.\n\n[The day before the invasion on Ukraine by Russian forces on February 24, a new data wiper](https://twitter.com/ESETresearch/status/1496581903205511181?s=20&t=5Zz6kStjdzGh2bRaH32DCA)\nwas found to be unleashed against a number of Ukrainian entities. This malware was given\nthe name “HermeticWiper” based on a stolen digital certificate from a company called\nHermetica Digital Ltd.\n\nThis wiper is remarkable for its ability to bypass Windows security features and gain write\naccess to many low-level data-structures on the disk. In addition, the attackers wanted to\nfragment files on disk and overwrite them to make recovery impossible.\n\n\n-----\n\nAs we were analyzing this data wiper, [other research has come out detailing additional](https://www.welivesecurity.com/2022/03/01/isaacwiper-hermeticwizard-wiper-worm-targeting-ukraine/)\ncomponents were used in this campaign, including a worm and typical ransomware\nthankfully [poorly implemented and decryptable.](https://www.crowdstrike.com/blog/how-to-decrypt-the-partyticket-ransomware-targeting-ukraine/)\n\n[We obtained samples and in this post we will take apart this new malware.](https://samples.vx-underground.org/APTs/2022/2022.02.23(2)/Samples/)\n\n## Behavioral analysis\n\nFirst, what we see is a 32 bit Windows executable with an icon resembling a gift. It is not a\ncynical joke of the attackers, but just a standard icon for a Visual Studio GUI project.\n\n_Icon used by HermeticWiper_\n\nIt has to be run as Administrator in order to work, and does not involve any UAC bypass\ntechniques. As we will later find out, the name of the sample also (slightly) affects its\nfunctionality; if the name starts with “c” (or “C”, as it is automatically converted to lowercase)\nthe system will also reboot after execution.\n\nOnce run, the sample works silently in the background. For several minutes we may not\nnotice anything suspicious.\n\nOnly if we watch the sample using tools like Process Explorer, we can notice some unusual\nactions. It calls various IOCTLs, related to retrieving details about the disks:\n\n_Example of actions performed by HermeticWiper, seen in ProcessMonitor_\n…including `FSCTL_GET_RETRIEVAL_POINTERS and` `FSCTL_MOVE_FILE which can` remind\nof files defragmentation*.\n\n[*] Note, that at the low-level, files may not be kept in a filesystem in one continuous chunk\n_(as we see them at high-level), but in multiple chunks, stored in the various sectors of the_\n_disk. Defragmentation is related to consolidating those chunks, and fragmentation – to_\n_splitting them_\n\n\n-----\n\nHowever, further examination has shown that the effect here is the opposite of\ndefragmentation. In fact, the data gets more fragmented as a result of the malware\nexecution.\n\nThe disk status regarding data fragmentation, before and after the malware execution, can\nbe checked in the following images:\n\n_Disk status before fragmentation_\n\n_Disk status after fragmentation_\n\n\n-----\n\nThis is probably made in order to escalate the created damage: the more fragmented the file\nis, the more difficult it is to carve it out from the raw disk image, and reconstruct it\nforensically.\n\nAs the execution progresses, at some point, we may realize that some applications stopped\nworking. It is because of the fact that some files, including system DLLs, have been\noverwritten with random data.\n\nExample: an application failed to run because of a system DLL being trashed:\n\n_Example of an error_\n\n_caused by the wiper_\nIf we now view the raw image of the disk (i.e. using HxD), we can notice that some sectors\nhave been also overwritten with random data:\n\n_Sector overwritten by HermeticWiper, seen in HxD_\nNot surprisingly, on reboot our Windows OS will no longer work:\n\n\n-----\n\n_Message shown to the user after the reboot of the corrupt system_\nBut what exactly happened underneath? Let’s have a closer look…\n\n## Used components\n\nThe initial sample:\n[1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591 – comes with](https://www.virustotal.com/gui/file/1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591)\nseveral PE files in its resources:\n\n_Resources of the malware_\nThe names chosen for the resources ( DRV_X64, `DRV_X86,` `DRV_XP_X86,` `DRV_XP_X64 )`\nsuggest that they are a version of the same driver, dedicated to different versions of\nWindows: appropriately 32 or 64 bit version, or a legacy version for Windows XP. Each of\nthem is in compressed form. By checking the dumped files by the Linux `file command,`\nwe can see the following output:\n```\nfile DRV_XP_X86\nDRV_XP_X86: MS Compress archive data, SZDD variant, original size: 13896 bytes\n\n```\n\n-----\n\nTo find out how they are loaded, we need to have a look at the sample that carries them.\n\nFortunately, the sample is not obfuscated. We can easily find the fragment that is responsible\nfor finding the appropriate version of the driver:\n\n_HermeticWiper_\n\n_selecting which driver will load_\nThe buffers are then decompressed with the help of the LZMA algorithm:\n\n\n-----\n\n_Code responsible of decompress drivers compressed by LZMA algorithm and driver_\n_installation_\nThis format of compression is supported by a popular extraction tool, 7zip. We can also\n[make our own decoding tool, basing on the malware code (example).](https://gist.github.com/hasherezade/2c7837874f7adf0f73192f4d861d83c6)\n\nAs a result we get 4 versions of legitimate drivers from the EaseUS Partition Master – just as\n[reported by ESET (source).](https://twitter.com/ESETresearch/status/1496581912940396551?s=20&t=wAz5sfT7pTIN-F0aqFaXTg)\n\n[2c7732da3dcfc82f60f063f2ec9fa09f9d38d5cfbe80c850ded44de43bdb666d](https://www.virustotal.com/gui/file/2c7732da3dcfc82f60f063f2ec9fa09f9d38d5cfbe80c850ded44de43bdb666d)\n[23ef301ddba39bb00f0819d2061c9c14d17dc30f780a945920a51bc3ba0198a4](https://www.virustotal.com/gui/file/23ef301ddba39bb00f0819d2061c9c14d17dc30f780a945920a51bc3ba0198a4)\n[8c614cf476f871274aa06153224e8f7354bf5e23e6853358591bf35a381fb75b](https://www.virustotal.com/gui/file/8c614cf476f871274aa06153224e8f7354bf5e23e6853358591bf35a381fb75b)\n[96b77284744f8761c4f2558388e0aee2140618b484ff53fa8b222b340d2a9c84](https://www.virustotal.com/gui/file/96b77284744f8761c4f2558388e0aee2140618b484ff53fa8b222b340d2a9c84)\n\nBased on the timestamps in the PE headers, the builds of the drivers are pretty old. Probably\nthey have been stolen by the attackers from an original, legitimate software bundle. Each of\nthem comes with a Debug directory, including a PDB path. Example:\n\n\n-----\n\n## Driver overview\n\nThe drivers leveraged by HermeticWiper are part of the Suite from EaseUS, a legitimate\nsoftware that brings to the user disk functionalities like partitioning and resizing. As told, this\ntool is legitimate so no one was detecting the sample in VirusTotal at the time of the attack:\n\n_VirusTotal showed 0 detections for used drivers_\nLooking inside the driver, we can see typical functions. The driver creates the required\ndevice and establishes some Dispatch Routines, as can be seen in the following image:\n\n\n-----\n\n_DriverEntry routine_\nThe internals of the driver are quite straightforward. In order to access the driver from\nusermode we need to use `CreateFile API function and the name of the device under`\nwhich the driver was installed ( \\\\.\\EPMNTDRV ) along with the partition ID. Example shown\nbelow:\n\n_Usermode component, building the string that will be used to open a HANDLE to the device_\n\n\n-----\n\nThis string is important to understand the driver capabilities. As you can see, this drivers\ncode will convert this sent string from usermode to integer and will use that integer as an\ninput to the `saveReferenceHardDisk` helper function. As it can be extracted from the\nimages, this helper function will save a reference to the physical disk\n(\\Device\\Harddisk[num]\\Partition0) in FsContext attribute:\n\nIRP_MJ_CREATE function\n\nDetail of helper function\nThis behaviour can has been tested also in real time. We can see how the leading\nbackslash is removed prior to convert this value to integer type:\n\n_Parameter handling shown in a kernelmode live debugging session_\nIRP_MJ_CREATE function will save a Device Object pointer for the hard disk in FsContext2\nattribute, returned by getDeviceObject helper function. The DeviceObject pointer in\ngetDeviceObject is used to find IRP_MJ_CREATE function will save a Device Object pointer\nfor the hard disk in FsContext2 attribute (returned by getDeviceObject helper function). The\nDeviceObject pointer in getDeviceObject is used to find the disk.sys associated device object\n\n\n-----\n\nby traversing to the lowest device object leveraging IoGetLowerDeviceObject function. To\nconfirm that the lower device object is indeed the one we are looking for we check the\nServiceKeyName of the object with “Disk” which indicates that its looking for the disk.sys\nobject as the ServiceKeyName for that object is “Disk”. These objects will be used later in\nread and write operations. That means that, when different operations are requested to the\ndriver from usermode, the real operation will be performed over the machine physical disks.\n\nDetail of getDiskDeviceObject helper function\nNext images show how the driver builds the incoming requests and forwards them to the\nlower level devices:\n\n_Example of EaseUS driver handling IOCTL requests_\n\n\n-----\n\n_Example of EaseUS driver handling read operations_\n\n_Example of EaseUS driver handling IOCTL write operations_\nBy using FsContext2 field saved by a CreateFile operation performed from usermode, this\ndriver could be seen as a proxy driver where IRPs are handled by underlying devices. In a\nnutshell, this legitimate driver lets the attackers bypass some windows security mechanisms\nwhich would ideally be forbidden from usermode such as writing to certain sectors of the raw\ndisk.\n\n## Implementation of the Wiper\n\nThis malware is designed to maximize damage done to the system. It does not only\noverwrite the MBR, but goes further: walking through many structures of the filesystem and\ncorrupting all of them, also trashing individual files.\n\nWe know that this executable is going to somehow abuse those drivers in order to implement\nthe wiper functionality. Yet, the question arises, how exactly is it implemented?\n\nIt is worth to note that Windows (since Vista) introduced limitations, thanks to which only the\nsectors at the beginning of the disk can be written to from usermode (with the help of the\nstandard windows drivers). If we want to write to further sectors, i.e. overwrite MFT (Master\n\n\n-----\n\n[File Table) we need some custom workarounds. (More explanation given here.)](https://community.osr.com/discussion/101522/vista-rtm-writing-to-raw-disk-sectors)\n\n[In case of Petya (as well as NotPetya, which used the same component), this workaround](https://blog.malwarebytes.com/threat-analysis/2016/04/petya-ransomware/)\nwas implemented by an alternative “kernel” that was booting (instead of Windows) on\nmachine restart, and doing the overwrite. In case of the HermeticWiper, the authors decided\nfor an easier way: they used another driver, that was able to do such overwrites.\n\nFirst, the malware parses NTFS structures, and stores information about them in the internal\nstructures. For implementing the reads, standard system devices being used. After the\nneeded data is collected, the additional (EaseUS) driver comes into play: it is used as a\nproxy to write into the collected sectors.\n\nThe attack can be divided into several phases:\n\n1. Preparation, including:\n\nInstallation of the additional driver (EaseUS)\nDisabling system features that may help in recovery, or in noticing of the attack\n2. Data collection: walking through NTFS structure, collecting sectors and files that are\n\ngoing to be overwritten. Also, the random data of appropriate size is generated for the\nfurther overwrite.\n3. Trashing (at this stage the EaseUS driver is utilized): the collected sectors are being\n\noverwritten by the previously generated random data\n\nAt the end, the system may be automatically rebooted.\n\n## Execution flow\n\nLet’s now have a look at the malware sample, to see how those phases are implemented in\ndetail.\n\n### Preparations\n\nFirst the sample parses command line arguments. They will have minor impact on the\nexecution – may just alter how long the sample is going to sleep between the execution of\nthe particular phases.\n\nThen, the sample proceeds to set privileges that are needed in order to execute the actions\nthat are going to be performed. Two privileges are being set in the main function of the\nmalware: `SeShutdownPrivilege (that allows to reboot the system) and`\n```\nSeBackupPrivilege (that allows to manipulate system backups):\n\n```\n\n-----\n\n_Hermetic Wiper adjusting required privileges_\nHere comes and interesting twist: the string defining `SeShutDownPrivilege is composed`\non the stack, and one chunk in between is missing:\n\n_Detail of uncompleted SeShutdownPrivilege string_\nThis missing chunk `wnPr is then being filled at the position that is calculated depending on`\nthe first character of the current executable name. Due to this, the string becomes complete\n(and the privilege is set properly) only in the case if the sample has a name starting from “c”.\n\n\n-----\n\n_SeShutdownPrivilege completed in later steps_\nThe reason why the authors decided for such unusual alteration of the flow is not sure. It\nmay be just to obfuscate this particular, suspicious string. It is also common for malware\nauthors to use a name check as an anti-sandbox technique (since sandboxes may assign to\nsamples some predictable names: in the case if such name was detected, sample may exit,\nso that its behavior cannot be tracked by the Sandbox). However, here the change in the\nsample behavior is very minor – it affects only the reboot functionality, not the main mission\nof the malware.\n\n**Driver Installation**\n\nAfter that, the malware proceeds to the installation of the driver:\n\n_Driver installation_\nThe installation function takes several steps.\n\nFirst, the system is fingerprinted, so that the malware can select the most appropriate\nversion of the driver to be used. Depending on the Windows version, and the bitness (32 or\n64 bit), the resource is selected.\n\n\n-----\n\n_Different drivers available to load_\nBefore installing the driver, the crash dump mechanism is being disabled:\n\n_HermeticWiper disabling Crash Dumps_\nCrash Dumps are usually being made if the full system crashes, possibly because of a\nbug/instability in a driver. They contain information about the full status of the system, and on\nwhat exactly happen, in order to help debugging. Disabling crashes before the installation\nsuggests that the authors of the malware have some level of distrust in the used drivers, or\n\n\n-----\n\nbelieve that the executed operation posses some risk of crashing the system. That s why\nthey want to be extra sure that if it eventually happens, the Administrators will have a harder\ntime to find the reason.\n\nThen, they check if the driver is already installed. They do it by sending there and IOCTL,\nthat is supposed to retrieve information about the drive geometry. If this operation has failed,\nit means the driver is not there, and they can proceed with the installation.\n\n_EaseUS device object reference_\nThe installation is done by first generating a pseudorandom, 4-character long name for the\ndriver, from the hardcoded charset. The function also makes sure that the file with the\ngenerated name does not exist yet.\n\n_Generation of driver name_\nThen, the compressed version of the file is being dropped. And finally, the driver is\ndecompressed from it.\n\n_Dropped EaseUS_\n\n_driver shown in explorer_\nThe decompressed driver is installed as a service:\n\n\n-----\n\n_EasyUs driver installation_\n_At this point, the newly dropped files are also added to the structures that will be further_\n_passed to the wiping functions – so that the files can be overwritten at low level. More about_\n_it is described in section “Data collection”._\n\nThe installation function (denoted as `create_driver_svc ) first enables yet another`\nprivilege: `SeLoadDriverPrivilege (which is required to allow loading drivers):`\n\n_SeLoadDriverPrivilege_\nThen the driver is added as a system service, and started:\n\n\n-----\n\n_Detail driver service being created_\n\nThis triggers execution of the `DriverEntry function, and since that point, the driver is`\nresiding in memory.\n\nAfter the successful installation, the registry keys related to the service, as well as the\ndropped files, are deleted, to make the new driver more difficult to spot:\n\n_Deletion of dropped files_\n\nWe must note, that file deletion does not interfere in the functionality of the driver. It is still\nloaded in memory (till the next reboot) and will be available for the further use.\n\n### Disabling shadow copies\n\nIt is a common action done by ransomware to delete shadow copies. It is supposed to\ndestroy system backups, and paralyze the recovery. In this case, we can see the sample\ndisabling the Shadow copy Service:\n\n\n-----\n\n_Shadow Copies being disabled_\n\n## Data Fragmentation\n\nDuring our analysis, we noticed that the malware fragments the files present on the disk (as\nopposite of defragmentation).\n\nBefore the fragmentation routine, it changes some settings related to explorer:\n\n_Registry changes to make it harder to spot NTFS operations_\nThis is probably to hide the information about the file status to the user, to keep them in blind\nfor as long time as possible.\n\nBelow function shows how the fragmentation routine is executed:\n\n\n-----\n\n_Wrapper function used for fragmentation purposes_\nThe standard windows directories are being excluded:\n\n_Folder list that will be skipped_\nThis can be done both to save time (by not corrupting standard files), and to avoid the\ninterference with system stability.\n\nThe file fragmentation process can be seen in next images:\n\n_Fragmentation detail (1)_\n\n\n-----\n\n_Fragmentation detail (2)_\nThe fragmentation algorithm implementation is achieved by using different IOCTL_CODES\n(FSCTL) as FSCTL_GET_RETRIEVAL_POINTERS and FSCTL_GET_MOVE_FILES. The\ncode looks pretty similar to a defragmentation code. But in this case, is being modified in\norder to fragment, where file chunks are splitted and moved to free clusters in the disk.\n\n## Data collection\n\nAfter those preparations, malware enters the second stage of the execution: data collection.\nIn casual ransomware cases, we may see sometimes that prior to the encryption, malware\niterates through various directories, and makes a list of files that it is going to attack. This\ncase is analogous, but much more interesting, because the authors iterate not through\ndirectories (at high level, using windows API), but at low level, through NTFS file system,\nreading various structures and parsing them manually. To enumerate them, they send\nIOCTLs through standard Windows devices (the newly installed driver is not used yet).\n\n### Data storage\n\n\n-----\n\nThe output of this parsing is stored in custom structures which we managed to reconstruct,\nand defined in the following way:\n```\nstruct elemStr\n{\n elemStr *fLink;\n elemStr *bLink;\n chunkStr *chunkPtr;\n DWORD diskNumber;\n BYTE *randomBufToWrite;\n DWORD sizeBuffer;\n};\nstruct chunkStr\n{\n chunkStr *fLink;\n chunkStr *bLink;\n LARGE_INTEGER offset;\n QWORD chunk_size;\n};\n\n```\nThey both are linked lists.\n\nThe first one `elemStr defines the element that will be overwritten. Its size is retrieved, and`\nthe random buffer dedicated for its overwrite is generated:\n\n\n-----\n\n_Random_\n\n_data being generated for later trashing action_\nThe “chunk” represents a continuous block of physical addresses to be overwritten.\n\nSo in general, the malware will use these structures in a 2 step process. First step will collect\nall the data. The second step will wipe this data, using the previous created structure.\n\n### Collected elements\n\nAs seen before, these structures will be sent to functions that will perform the data\ncorruption, at a very low level. The elements that are collected for later destruction are\npresented below.\n\n**_Own executable and the dropped drivers_**\n\nWe have seen that the attackers were interested in cleaning their trace. To accomplish that,\nthey will delete their own executable from disk, even tough the binary itself keeps running\nand in memory. As any other task performed in the filesystem by HermeticWiper, the way of\ndeleting their binary is slightly different as other malwares do. The attackers first manage to\nfind which offset the binary occupies in raw, and finally they will overwrite that specific offset.\n\n\n-----\n\n_HermeticWiper file will be destroyed, along with other elements_\nThe dropped files (compressed and uncompressed driver) were added to the same structure,\njust after the the installation.\n\n**_The Boot Sector_**\n\nOne of the attackers motivation is making devices incapable of loading the OS. The first step\nfollowed is enumerating all physical devices, as well as partitions. For that, a simple loop is\nused that tries to open a handle to HardDisk[num], where num is iterated from 0 to 100:\n\n_Loop_\n\n_showing how attackers will iterate through HardDisk0 to HardDisk100_\nAll this information is then stored into a `elemStr structure that contains data as the disk`\nnumber. In this case, chunkElement will describe raw addresses of boot sectors. In that\nregard, an especial mention is made to `C:\\System Volume Information . The attackers`\nwill add to boot_sectors structure this folder contents:\n\n_Calls to parse_NTFS_AND_execute_callback function_\nAccording to Microsoft, “The Mount Manager maintains the Mount Manager remote database\n_on every NTFS volume in which the Mount Manager records any mount points defined for_\n_that volume. The database file resides in the directory System Volume Information on the_\n_NTFS volume” (Windows Internals, 6th edition). So this technique is also created for_\nincreasing damage. Finally, all these collected offsets will be overwritten as the malicious\nbinary was, leveraging the EasyUS driver.\n\n**_Reserved Sectors and MFT_**\n\n\n-----\n\nAs before, the malware will brute-force again against the PhysicalDrive ID to find valid drive\nIDs. Then it uses IOCTL_DISK_GET_DRIVE_LAYOUT_EX to retrieve information about all\nthe primary partitions present on the drive and reads the first sector from that partition. Other\ninformation required to read one sector from the disk is retrieved by using the\nIOCTL_DISK_GET_DRIVE_GEOMETRY_EX.\n\n_Retrieving information about each disk_\nOnce the first sector of a partition is read then the callback function passed by the malware is\ninvoked on this sector.\n\n\n-----\n\nDepending on the filesystem type if its FAT then it wipes all the Reserved Sectors, the boot\nrecord sectors in FAT filesystem are part of Reserved Sectors. In case of NTFS the malware\nwipes the MFT and MFTMirror (backup MFT) present on the disk, the purpose of which is to\nmake the recovery of the data harder.\n\n_Routine for FAT filesystem_\n\n\n-----\n\n_Routine for NTFS filesystem_\nEach file on an NTFS volume is represented by a record in a special file called the master\nfile table (MFT). In case the MFT becomes corruptible then MFT mirror is read in an attempt\nto recover the original MFT, whose first record is identical to the first record of the MFT. MFT\ntable is the index on which the filesystem relies, having information like where a file resides.\nWithout MFT, the system will be unable to know were folders and files are, or modification\ndates, etc.\n\n**_Bitmap and LogFile_**\n\nIn an attempt to hinder the recovery, Bitmap and LogFile are overwritten as well for all the\nlogical drives present on the system. The logical drives are retrieved by\nGetLogicalDriveStringsW in this case. These structures are also important when doing\nrecovery and postmortem investigation. $Bitmap contains information about free and\noccupied clusters and $Logfile contains a log of transactions that happened in the filesystem.\n\n\n-----\n\nAlso user files will be impacted by data destruction. We have discovered that the malware\nwill overwrite as well almost everything inside C:/Documents and settings. In modern\nWindows, Documents and Settings will point to C:/Users. This folder contains users data\nfolders (for example, My Documents or Desktop are located in these folders). Some files are\nskipped in this process, as the ones under APPDATA but in general, every file that is\ncontained under these folders will be overwritten.\n\n**_Collecting clusters to erase the whole disk_**\n\nThe final part of the data collection is to get information required to wipe all the occupied\nclusters on the disk. To get this information the malware uses\nFSCTL_GET_VOLUME_BITMAP IOCTL which gives us information about all the occupied\nand free clusters on the disk. The malware traverses all the logical disks and uses\nFSCTL_GET_VOLUME_BITMAP to retrieve the bitmap, every bit in the bitmap denotes a\ncluster, a value of 1 implying that the cluster is occupied and 0 meaning that the cluster is\nfree. The bitmap retrieved with the IOCTL is traversed bit by bit and all the occupied clusters\nare added to the wiping structure which is described above in the post, one thing to note\nhere is that malware combines all the contiguous clusters and these contiguous multiple\nclusters are denoted by a single chunk structure opposed to earlier usages where one chunk\nstructure denoted a single cluster.\n\n\n-----\n\nFinally, all occupied clusters will be collected in a `elemStr typed structure for its`\ndestruction.\n\n### How is this all performed?\n\nThrough the entire post its been told that some NTFS properties (like attributes, indexes, etc)\nare being used in order to collect data, that will be wiped after. We will like to show an\nexample of how attackers implemented that functionality and show the level of sophistication.\n\nFor that, we will take as example the code responsible in collecting the Windows log files:\n\n_Code responsible in collecting Windows log files_\nAfter this call, some data structures are filled, containing data regarding physical disk\nproperties and the folder name itself. Our first reference to the NTFS filesystem is found in\nthe way that the HANDLE is retrieved. This folder is opened as a NTFS stream:\n\n_HANDLE to the default directory stream_\n\n\n-----\n\nEventually, the code will reach the following point. The first call will parse $INDEX_ROOT\nattribute, and the functionality is relatively similar and simpler than the second one, where\n$INDEX_ALLOCATION attribute is used. Additional information about these NTFS attributes\n[can be found here. We will assume that the list of elements is long enough to have an](http://inform.pucp.edu.pe/~inf232/Ntfs/ntfs_doc_v0.5/attributes/)\n$INDEX_ALLOCATION and we will deep into this call:\n\n_NTFS wrapping callback functions_\nIt is important to have in mind the parameters sent for a better understanding of the whole\nprocess. First two parameters (nFileIndexLow and nFileIndexHigh) are used for calling the\n[function FSCTL_GET_NTFS_FILE_RECORD, which will retrieve a NTFS record. After some](https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_get_ntfs_file_record)\nchecks (for example, the magic value), we will pop out in a function that we have called\n_callback_when_attribute_is_found. Note that the first parameter sent to this function will be_\nthe $INDEX_ALLOCATION (0x20) value that was previously sent:\n\n_Call to_\n\n_callback_when_attribute_is_found function_\nWhat this function will do is to iterate through all NTFS attributes that are part of the record.\nTo do that, the code will have to find the offset to the first attribute. This offset is just 2 bytes\nlong, as is relative to the structure. The layout of the header is demonstrated below:\n\n\n-----\n\n_NTFS RECORD HEADER layout –_\n\n_[source](http://inform.pucp.edu.pe/)_\nA NTFS File record will follow this structure:\n\nRecord Header\n\nAttribute\n\nAttribute\n\nAttribute\n\nNTFS record layout\nIf we still remember the $INDEX_ALLOCATION (0x20), it becomes handy now. Attributes will\nstart with a specific TypeCode, as $INDEX_ALLOCATION is. So, if one of the attributes\nmatches the selected type that was required, the first callback function (the one sent steps\nbefore as a parameter) will be triggered:\n\n\n-----\n\n_Code showing matching attribute and callback_\n_In the case there is not matching TypeCode but an $ATTRIBUTE_LIST is found, that will_\n_mean that exists more attributes, but these cannot fit into $MFT table. In this rare case, the_\n_malware will continue processing these extra attributes and will call recursively the first_\n_function._\n\nLets check what this callback will do. Remember that this callback function, in our case is\n_indexAllocation_Callback_CollectAllfiles. The first step will be recovering the stream that this_\nattribute points to. As $INDEX_ALLOCATION is an attribute meant for directories, makes\nsense this stream being an index array (block indexes):\n\n_Block Indexes array being recovered using raw disk offsets_\nAs this is an index array, these indexes will point to something. This something is, as you\nwould imagine, NTFS records. In raw disk, these type of indexes look like that:\n\n\n-----\n\n_Example of an index block found in a raw disk image file_\nAs indexes point to records, all of these records will be sent, recursively, once more to the\ninitial function. But this time the callback function will be different, also the typecode:\n\n_$DATA_\n\n_callback function call_\nSo this time, every record sent will behave differently. $DATA attributes will be looked for\ninstead of $INDEX_ALLOCATION ($DATA contains file data). Also, the executed callback\nfunction will be different (named now dataExecuting). By using the disk properties that were\nsent in the first call combined with information gathered from indexes, this callback will locate\nthe exact location of the file in disk. The last step for these files, as for all the ones that we\nhave summarized in this report is being added as a member to a `elemStr * structure. The`\noffsets contained in this structures, as stated, will be overwritten by the malware in the last\nsteps:\n\n_Call to the function that will add the file’s offset to a elemStr typed structure, for later data_\n\n\n-----\n\n_destruction_\n\n## Data overwriting\n\nFinally, after all data is collected, the malware starts overwriting. The `elemStr structure is`\npassed into the function, and all the elements on the linked list are being processed:\n\n_to_overwrite_collected_sectors function overview_\nThe overwriting function uses the installed driver in order to gain the write access to the\nsectors. It opens the device, and then walks through all the collected chunks, by their offsets.\nIt uses `WriteFile to fill it with the previously prepared, random data.`\n\n\n-----\n\n_Final detail of data destruction_\nExample below shows a fragment of a log from our experiments, when we dumped the\ncontent of particular structures during malware execution: first data collection, and then\nusage of the filled structures to wipe out the sectors on the disk:\n\n## Conclusion\n\n\n-----\n\nAs can be seen, by leveraging legitimate but flawless signed code, the attackers are capable\nof bypassing some Windows security mechanisms. This is extremely harmful because user\napplications are not meant to have this level of control in kernel space, for security reasons.\n\nAlso, we would like to state that recovery in this case is complicated. The attackers first\nfragment files on disk, and finally, will overwrite all of these fragments. Even without the last\nstep (indiscriminate disk trashing), the combination of fragmentation and wiping of required\nstructures (like $MFT) would be enough to make recovery almost impossible.\n\nOur final thoughts are about the special focus that cybercriminals put in hiding their tracks.\nMaybe, that part is the final stage of a bigger operation. In fact, ESET recently described\nother related artifacts [here, and they connect them to the same actor and campaign. Being](https://www.welivesecurity.com/2022/03/01/isaacwiper-hermeticwizard-wiper-worm-targeting-ukraine/)\npart of a bigger picture can explain why attackers are so much interested in corrupting files\nlike $LogFile and Windows events.\n\nMalwarebytes detects this disk wiper as Trojan.HermeticWiper.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-04 - HermeticWiper- A detailed analysis of the destructive malware that targeted Ukraine.pdf"
    ],
    "report_names": [
        "2022-03-04 - HermeticWiper- A detailed analysis of the destructive malware that targeted Ukraine.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535995,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1653708019,
    "ts_modification_date": 1653708019,
    "files": {
        "pdf": "https://archive.orkl.eu/8a6af616dc560e96db993075fb8ccd23019d87f7.pdf",
        "text": "https://archive.orkl.eu/8a6af616dc560e96db993075fb8ccd23019d87f7.txt",
        "img": "https://archive.orkl.eu/8a6af616dc560e96db993075fb8ccd23019d87f7.jpg"
    }
}