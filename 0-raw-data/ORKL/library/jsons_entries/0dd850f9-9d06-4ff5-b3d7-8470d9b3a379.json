{
    "id": "0dd850f9-9d06-4ff5-b3d7-8470d9b3a379",
    "created_at": "2023-01-12T15:10:36.038656Z",
    "updated_at": "2025-03-27T02:05:20.822711Z",
    "deleted_at": null,
    "sha1_hash": "a98f7b0b624fbacd0d3d5ade08fb41e4d379adfc",
    "title": "2020-12-01 - Using Speakeasy Emulation Framework Programmatically to Unpack Malware",
    "authors": "",
    "file_creation_date": "2022-05-27T21:29:00Z",
    "file_modification_date": "2022-05-27T21:29:00Z",
    "file_size": 109273,
    "plain_text": "# Using Speakeasy Emulation Framework Programmatically to Unpack Malware\n\n**fireeye.com/blog/threat-research/2020/12/using-speakeasy-emulation-framework-programmatically-to-unpack-**\nmalware.html\n\nThreat Research\n\nJames T. Bennett\n\nDec 01, 2020\n\n13 mins read\n\nThreat Research\n\nTTPs\n\nUncategorized Groups (UNC Groups)\n\n\n-----\n\n[Andrew Davis recently announced the public release of his new Windows emulation](https://www.fireeye.com/resources/emulation-of-malicious-shellcode-with-speakeasy)\n[framework named Speakeasy. While the introductory blog post focused on using Speakeasy](https://github.com/mandiant/speakeasy)\nas an automated malware sandbox of sorts, this entry will highlight another powerful use of\nthe framework: automated malware unpacking. I will demonstrate, with code examples, how\nSpeakeasy can be used programmatically to:\n\nBypass unsupported Windows APIs to continue emulation and unpacking\nSave virtual addresses of dynamically allocated code using API hooks\nSurgically direct execution to key areas of code using code hooks\nDump an unpacked PE from emulator memory and fix its section headers\nAid in reconstruction of import tables by querying Speakeasy for symbolic information\n\n**Initial Setup**\n\nOne approach to interfacing with Speakeasy is to create a subclass of Speakeasy’s\n[Speakeasy class. Figure 1 shows a Python code snippet that sets up such a class that will](https://github.com/mandiant/speakeasy/blob/master/speakeasy/speakeasy.py)\nbe expanded in upcoming examples.\n\nimport speakeasy\n\nclass MyUnpacker(speakeasy.Speakeasy):\n\ndef __init__(self, config=None):\n\nsuper(MyUnpacker, self).__init__(config=config)\n\nFigure 1: Creating a Speakeasy subclass\n\nThe code in Figure 1 accepts a Speakeasy configuration dictionary that may be used to\n[override the default configuration. Speakeasy ships with several configuration files. The](https://github.com/mandiant/speakeasy/tree/master/speakeasy/configs)\nSpeakeasy class is a wrapper class for an underlying emulator class. The emulator class is\nchosen automatically when a binary is loaded based on its PE headers or is specified as\nshellcode. Subclassing Speakeasy makes it easy to access, extend, or modify interfaces. It\nalso facilitates reading and writing stateful data before, during, and after emulation.\n\n**Emulating a Binary**\n\nFigure 2 shows how to load a binary into the Speakeasy emulator.\n\nself.module = self.load_module(filename)\n\nFigure 2: Loading the binary into the emulator\n\nThe load_module function returns a PeFile object for the provided binary on disk. It is an\n[instance of the PeFile class defined in speakeasy/windows/common.py, which is subclassed](https://github.com/mandiant/speakeasy/blob/master/speakeasy/windows/common.py)\nfrom [pefile’s PE class. Alternatively, you can provide the bytes of a binary using the data](https://github.com/erocarrera/pefile/blob/master/pefile.py)\n\n\n-----\n\nparameter rather than specifying a file name. Figure 3 shows how to emulate a loaded\nbinary.\n\nself.run_module(self.module)\n\nFigure 3: Starting emulation\n\n**API Hooks**\n\nThe Speakeasy framework ships with support for hundreds of Windows APIs with more\nbeing added frequently. This is accomplished via Python API handlers defined in appropriate\n[files in the speakeasy/winenv/api directory. API hooks can be installed to have your own](https://github.com/mandiant/speakeasy/tree/master/speakeasy/winenv/api)\ncode executed when particular APIs are called during emulation. They can be installed for\nany API, regardless of whether a handler exists or not. An API hook can be used to override\nan existing handler and that handler can optionally be invoked from your hook. The API\nhooking mechanism in Speakeasy provides flexibility and control over emulation. Let’s\nexamine a few uses of API hooking within the context of emulating unpacking code to\nretrieve an unpacked payload.\n\n**Bypassing Unsupported APIs**\n\nWhen Speakeasy encounters an unsupported Windows API call, it stops emulation and\nprovides the name of the API function that is not supported. If the API function in question is\nnot critical for unpacking the binary, you can add an API hook that simply returns a value that\nallows execution to continue. For example, a recent sample’s unpacking code contained API\ncalls that had no effect on the unpacking process. One such API call was to GetSysColor. In\norder to bypass this call and allow execution to continue, an API hook may be added as\nshown in Figure 4.\n\nself.add_api_hook(self.getsyscolor_hook,\n\n'user32',\n\n'GetSysColor',\n\nargc=1\n\n)\n\nFigure 4: Adding an API hook\n\nAccording to [MSDN, this function takes 1 parameter and returns an RGB color value](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsyscolor)\nrepresented as a DWORD. If the calling convention for the API function you are hooking is\nnot stdcall, you can specify the calling convention in the optional call_conv parameter. The\n[calling convention constants are defined in the speakeasy/common/arch.py file. Because the](https://github.com/mandiant/speakeasy/blob/master/speakeasy/winenv/arch.py)\nGetSysColor return value does not impact the unpacking process, we can simply return 0.\nFigure 5 shows the definition of the getsyscolor_hook function specified in Figure 4.\n\n\n-----\n\ndef getsyscolor_hook(self, emu, api_name, func, params):\n\nreturn 0\n\nFigure 5: The GetSysColor hook returns 0\n\nIf an API function requires more finessed handling, you can implement a more specific and\nmeaningful hook that suits your needs. If your hook implementation is robust enough, you\nmight consider contributing it to the Speakeasy project as an API handler!\n\n**Adding an API Handler**\n\nWithin the [speakeasy/winenv/api directory you'll find usermode and kernelmode](https://github.com/mandiant/speakeasy/tree/master/speakeasy/winenv/api)\nsubdirectories that contain Python files for corresponding binary modules. These files contain\nthe API handlers for each module. In usermode/kernel32.py, we see a handler defined for\nSetEnvironmentVariable as shown in Figure 6.\n\n1: @apihook('SetEnvironmentVariable', argc=2)\n\n2: def SetEnvironmentVariable(self, emu, argv, ctx={}):\n\n3:   '''\n\n4:   BOOL SetEnvironmentVariable(\n\n5:     LPCTSTR lpName,\n\n6:     LPCTSTR lpValue\n\n7:     );\n\n8:   '''\n\n9:   lpName, lpValue = argv\n\n10:  cw = self.get_char_width(ctx)\n\n11:  if lpName and lpValue:\n\n12:    name = self.read_mem_string(lpName, cw)\n\n13:    val = self.read_mem_string(lpValue, cw)\n\n14:    argv[0] = name\n\n15:    argv[1] = val\n\n16:    emu.set_env(name, val)\n\n17:  return True\n\nFigure 6: API handler for SetEnvironmentVariable\n\nA handler begins with a function decorator (line 1) that defines the name of the API and the\nnumber of parameters it accepts. At the start of a handler, it is good practice to include\nMSDN's documented prototype as a comment (lines 3-8).\n\nThe handler's code begins by storing elements of the argv parameter in variables named\nafter their corresponding API parameters (line 9). The handler's ctx parameter is a dictionary\nthat contains contextual information about the API call. For API functions that end in an ‘A’ or\n‘W’ (e.g., CreateFileA), the character width can be retrieved by passing the ctx parameter to\nthe get_char_width function (line 10). This width value can then be passed to calls such as\nread_mem_string (lines 12 and 13), which reads the emulator’s memory at a given address\nand returns a string.\n\n\n-----\n\nIt is good practice to overwrite string pointer values in the argv parameter with their\ncorresponding string values (lines 14 and 15). This enables Speakeasy to display string\nvalues instead of pointer values in its API logs. To illustrate the impact of updating argv\nvalues, examine the Speakeasy output shown in Figure 7. In the VirtualAlloc entry, the\nsymbolic constant string PAGE_EXECUTE_READWRITE replaces the value 0x40. In the\nGetModuleFileNameA and CreateFileA entries, pointer values are replaced with a file path.\n\nKERNEL32.VirtualAlloc(0x0, 0x2b400, 0x3000, \"PAGE_EXECUTE_READWRITE\") ->\n0x7c000\nKERNEL32.GetModuleFileNameA(0x0, \"C:\\\\Windows\\\\system32\\\\sample.exe\", 0x104) ->\n0x58\nKERNEL32.CreateFileA(\"C:\\\\Windows\\\\system32\\\\sample.exe\", \"GENERIC_READ\", 0x1,\n0x0, \"OPEN_EXISTING\", 0x80, 0x0) -> 0x84\n\nFigure 7: Speakeasy API logs\n\n**Saving the Unpacked Code Address**\n\nPacked samples often use functions such as VirtualAlloc to allocate memory used to store\nthe unpacked sample. An effective approach for capturing the location and size of the\nunpacked code is to first hook the memory allocation function used by the unpacking stub.\nFigure 8 shows an example of hooking VirtualAlloc to capture the virtual address and amount\nof memory being allocated by the API call.\n\n1: def virtualalloc_hook(self, emu, api_name, func, params):\n\n2:   '''\n\n3:   LPVOID VirtualAlloc(\n\n4:    LPVOID lpAddress,\n\n5:    SIZE_T dwSize,\n\n6:    DWORD flAllocationType,\n\n7:    DWORD flProtect\n\n8:   );\n\n9:   '''\n\n10:  PAGE_EXECUTE_READWRITE = 0x40\n\n11:  lpAddress, dwSize, flAllocationType, flProtect = params\n\n12:  rv = func(params)\n\n13:  if lpAddress == 0 and flProtect == PAGE_EXECUTE_READWRITE:\n\n14:    self.logger.debug(\"[*] unpack stub VirtualAlloc call, saving dump info\")\n\n15:    self.dump_addr = rv\n\n16:    self.dump_size = dwSize\n\n17:  return rv\n\nFigure 8: VirtualAlloc hook to save memory dump information\n\n\n-----\n\nThe hook in Figure 8 calls Speakeasy s API handler for VirtualAlloc on line 12 to allow\nmemory to be allocated. The virtual address returned by the API handler is saved to a\nvariable named rv. Since VirtualAlloc may be used to allocate memory not related to the\nunpacking process, additional checks are used on line 13 to confirm the intercepted\nVirtualAlloc call is the one used in the unpacking code. Based on prior analysis, we’re\nlooking for a VirtualAlloc call that receives the lpAddress value 0 and the flProtect value\nPAGE_EXECUTE_READWRITE (0x40). If these arguments are present, the virtual address\nand specified size are stored on lines 15 and 16 so they may be used to extract the\nunpacked payload from memory after the unpacking code is finished. Finally, on line 17, the\nreturn value from the VirtualAlloc handler is returned by the hook.\n\n**Surgical Code Emulation Using API and Code Hooks**\n\nSpeakeasy is a robust emulation framework; however, you may encounter binaries that have\nlarge sections of problematic code. For example, a sample may call many unsupported APIs\nor simply take far too long to emulate. An example of overcoming both challenges is\ndescribed in the following scenario.\n\n**Unpacking Stubs Hiding in MFC Projects**\n\nA popular technique used to disguise malicious payloads involves hiding them inside a large,\n[open-source MFC project. MFC is short for Microsoft Foundation Class, which is a popular](https://docs.microsoft.com/en-us/cpp/mfc/mfc-desktop-applications?redirectedfrom=MSDN&view=vs-2019)\nlibrary used to build Windows desktop applications. These MFC projects are often arbitrarily\nchosen from popular Web sites such as [Code Project. While the MFC library makes it easy](https://www.codeproject.com/)\nto create desktop applications, MFC applications are difficult to reverse engineer due to their\nsize and complexity. They are particularly difficult to emulate due to their large initialization\nroutine that calls many different Windows APIs. What follows is a description of my\nexperience with writing a Python script using Speakeasy to automate unpacking of a custom\npacker that hides its unpacking stub within an MFC project.\n\nReverse engineering the packer revealed the unpacking stub is ultimately called during\ninitialization of the CWinApp object, which occurs after initialization of the C runtime and\nMFC. After attempting to bypass unsupported APIs, I realized that, even if successful,\nemulation would take far too long to be practical. I considered skipping over the initialization\ncode completely and jumping straight to the unpacking stub. Unfortunately, execution of the\nC-runtime initialization code was required in order for emulation of the unpacking stub to\nsucceed.\n\nMy solution was to identify a location in the code that fell after the C-runtime initialization but\nwas early in the MFC initialization routine. After examining the Speakeasy API log shown in\nFigure 9, such a location was easy to spot. The graphics-related API function\nGetDeviceCaps is invoked early in the MFC initialization routine. This was deduced based on\n1) MFC is a graphics-dependent framework and 2) GetDeviceCaps is unlikely to be called\nduring C-runtime initialization.\n\n\n-----\n\n0x43e0a7: 'kernel32.FlsGetValue(0x0)' -> 0x4150\n\n0x43e0e3: 'kernel32.DecodePointer(0x7049)' -> 0x7048\n\n0x43b16a: 'KERNEL32.HeapSize(0x4130, 0x0, 0x7000)' -> 0x90\n\n0x43e013: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001\n\n0x43e02a: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001\n\n0x43e02c: 'kernel32.FlsGetValue(0x0)' -> 0x4150\n\n0x43e068: 'kernel32.EncodePointer(0x44e215)' -> 0x44e216\n\n0x43e013: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001\n\n0x43e02a: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001\n\n0x43e02c: 'kernel32.FlsGetValue(0x0)' -> 0x4150\n\n0x43e068: 'kernel32.EncodePointer(0x704c)' -> 0x704d\n\n0x43c260: 'KERNEL32.LeaveCriticalSection(0x466f28)' -> None\n\n0x422151: 'USER32.GetSystemMetrics(0xb)' -> 0x1\n\n0x422158: 'USER32.GetSystemMetrics(0xc)' -> 0x1\n\n0x42215f: 'USER32.GetSystemMetrics(0x2)' -> 0x1\n\n0x422169: 'USER32.GetSystemMetrics(0x3)' -> 0x1\n\n**0x422184: 'GDI32.GetDeviceCaps(0x288, 0x58)' -> None**\n\nFigure 9: Identifying beginning of MFC code in Speakeasy API logs\n\nTo intercept execution at this stage I created an API hook for GetDeviceCaps as shown in\nFigure 10. The hook confirms the function is being called for the first time on line 2.\n\n1: def mfc_init_hook(self, emu, api_name, func, params):\n\n2:   if not self.trigger_hit:\n\n3:     self.trigger_hit = True\n\n4:     self.h_code_hook =  self.add_code_hook(self.start_unpack_func_hook)\n\n5:     self.logger.debug(\"[*] MFC init api hit, starting unpack function\")\n\nFigure 10: API hook set for GetDeviceCaps\n\nLine 4 shows the creation of a code hook using the add_code_hook function of the\nSpeakeasy class. Code hooks allow you to specify a callback function that is called before\neach instruction that is emulated. Speakeasy also allows you to optionally specify an address\nrange for which the code hook will be effective by specifying begin and end parameters.\n\nAfter the code hook is added on line 4, the GetDeviceCaps hook completes and, prior to the\nexecution of the sample's next instruction, the start_unpack_func_hook function is called.\nThis function is shown in Figure 11.\n\n1: def start_unpack_func_hook(self, emu, addr, size, ctx):\n\n2:   self.h_code_hook.disable()\n\n3:   unpack_func_va = self.module.get_rva_from_offset(self.unpack_offs) +\nself.module.get_base()\n\n4:   self.set_pc(unpack_func_va)\n\nFigure 11: Code hook that changes the instruction pointer\n\n\n-----\n\nThe code hook receives the emulator object, the address and size of the current instruction,\nand the context dictionary (line 1). On line 2, the code hook disables itself. Because code\nhooks are executed with each instruction, this slows emulation significantly. Therefore, they\nshould be used sparingly and disabled as soon as possible. On line 3, the hook calculates\nthe virtual address of the unpacking function. The offset used to perform this calculation was\nlocated using a regular expression. This part of the example was omitted for the sake of\nbrevity.\n\nThe self.module attribute was previously set in the example code shown in Figure 2. It being\nsubclassed from the PE class of pefile allows us to access useful functions such as\nget_rva_from_offset() on line 3. This line also includes an example of using\nself.module.get_base() to retrieve the module's base virtual address.\n\nFinally, on line 4, the instruction pointer is changed using the set_pc function and emulation\ncontinues at the unpacking code. The code snippets in Figure 10 and Figure 11 allowed us to\nredirect execution to the unpacking code after the C-runtime initialization completed and\navoid MFC initialization code.\n\n**Dumping and Fixing Unpacked PEs**\n\nOnce emulation has reached the original entry point of the unpacked sample, it is time to\ndump the PE and fix it up. Typically, a hook would save the base address of the unpacked\nPE in an attribute of the class as illustrated on line 15 of Figure 8. If the unpacked PE does\nnot contain the correct entry point in its PE headers, the true entry point may also need to be\ncaptured during emulation. Figure 12 shows an example of how to dump emulator memory\nto a file.\n\nwith open(self.output_path, \"wb\") as up:\n\nmm = self.get_address_map(self.dump_addr)\n\nup.write(self.mem_read(mm.get_base(), mm.get_size()))\n\nFigure 12: Dumping the unpacked PE\n\nIf you are dumping a PE that has already been loaded in memory, it will not have the same\nlayout as it does on disk due to differences in section alignment. As a result, the dumped\nPE's headers may need to be modified. One approach is to modify each section's\n[PointerToRawData value to match its VirtualAddress field. Each section's SizeOfRawData](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header)\n[value may need to be padded in order conform with the FileAlignment value specified in the](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32)\nPE’s optional headers. Keep in mind the resulting PE is unlikely to execute successfully.\nHowever, these efforts will allow most static analysis tools to function correctly.\n\nThe final step for repairing the dumped PE is to fix its import table. This is a complex task\ndeserving of its own blog post and will not be discussed in detail here. However, the first step\ninvolves collecting a list of library function names and their addresses in emulator memory. If\n\n\n-----\n\nyou know the GetProcAddress API is used by the unpacker stub to resolve imports for the\nunpacked PE, you can call the get_dyn_imports function as shown in Figure 13.\n\napi_addresses = self.get_dyn_imports()\n\nFigure 13: Retrieving dynamic imports\n\nOtherwise, you can query the emulator class to retrieve its symbol information by calling the\nget_symbols function as shown in Figure 14.\n\nsymbols = self.get_symbols()\n\nFigure 14: Retrieve symbol information from emulator class\n\nThis data can be used to discover the IAT of the unpacked PE and fix or reconstruct its\nimport related tables.\n\n**Putting It All Together**\n\nWriting a Speakeasy script to unpack a malware sample can be broken down into the\nfollowing steps:\n\n1. Reverse engineer the unpacking stub to identify: 1) where the unpacked code will\n\nreside or where its memory is allocated, 2) where execution is transferred to the\nunpacked code, and 3) any problematic code that may introduce issues such as\nunsupported APIs, slow emulation, or anti-analysis checks.\n2. If necessary, set hooks to bypass problematic code.\n3. Set a hook to identify the virtual address and, optionally, the size of the unpacked\n\nbinary.\n4. Set a hook to stop emulation at, or after, execution of the original entry point of the\n\nunpacked code.\n5. Collect virtual addresses of Windows APIs and reconstruct the PE’s import table.\n6. Fix the PE’s headers (if applicable) and write the bytes to a file for further analysis.\n\n[For an example of a script that unpacks UPX samples, check out the UPX unpacking script](https://github.com/mandiant/speakeasy/blob/master/examples/upx_unpack.py)\nin the Speakeasy repository.\n\n**Conclusion**\n\nThe [Speakeasy framework provides an easy-to-use, flexible, and powerful programming](https://github.com/mandiant/speakeasy)\ninterface that enables analysts to solve complex problems such as unpacking malware.\nUsing Speakeasy to automate these solutions allows them to be performed at scale. I hope\nyou enjoyed this introduction to automating the Speakeasy framework and are inspired to\nbegin using it to implement your own malware analysis solutions!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-01 - Using Speakeasy Emulation Framework Programmatically to Unpack Malware.pdf"
    ],
    "report_names": [
        "2020-12-01 - Using Speakeasy Emulation Framework Programmatically to Unpack Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536236,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1653686940,
    "ts_modification_date": 1653686940,
    "files": {
        "pdf": "https://archive.orkl.eu/a98f7b0b624fbacd0d3d5ade08fb41e4d379adfc.pdf",
        "text": "https://archive.orkl.eu/a98f7b0b624fbacd0d3d5ade08fb41e4d379adfc.txt",
        "img": "https://archive.orkl.eu/a98f7b0b624fbacd0d3d5ade08fb41e4d379adfc.jpg"
    }
}