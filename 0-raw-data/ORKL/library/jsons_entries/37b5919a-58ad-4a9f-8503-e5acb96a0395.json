{
    "id": "37b5919a-58ad-4a9f-8503-e5acb96a0395",
    "created_at": "2023-01-12T15:07:59.09151Z",
    "updated_at": "2025-03-27T02:05:21.313074Z",
    "deleted_at": null,
    "sha1_hash": "ca84f06e19601a53cd2dede074d640829710c28c",
    "title": "2020-06-17 - Detecting PoshC2 – Indicators of Compromise",
    "authors": "",
    "file_creation_date": "2022-05-27T21:46:57Z",
    "file_modification_date": "2022-05-27T21:46:57Z",
    "file_size": 767919,
    "plain_text": "# Detecting PoshC2 – Indicators of Compromise\n\n**[labs.nettitude.com/blog/detecting-poshc2-indicators-of-compromise/](https://labs.nettitude.com/blog/detecting-poshc2-indicators-of-compromise/)**\n\nRob Bone June 17, 2020\n\nAs a counterpart to the [release of PoshC2 version 6.0 we are providing a list of some of its](https://labs.nettitude.com/blog/introducing-poshc2-v6-0/)\nIndicators of Compromise (IoCs), particularly as used out-of-the-box, as well as some other\neffective methods for detecting it in your environment.\n\nWe also introduce the new PoshC2 Detections GitHub repository at\n[https://github.com/nettitude/PoshC2_IOCs that will be continually updated as development](https://github.com/nettitude/PoshC2_IOCs)\ncontinues, in order to assist blue teams with detecting PoshC2, particularly when used by\nless sophisticated attackers that do not alter or configure it to change the default IoCs. We\nencourage the community to contribute to and help update and improve this repository.\n\nIt is worth noting that PoshC2 is open source, so while these are IoCs for PoshC2 if used it\nits default state, ultimately it can be altered either through configuration or by changing the\nsource code itself. The default configuration is subject to change, however where possible\nthe location of that value is pointed out to the reader in order to allow these values to be\nmonitored and updated, in addition to providing the GitHub repository.\n\n## Communications\n\n\n-----\n\nOne way to detect PoshC2 is to focus on the communications. Compromised hosts have to\ncommunicate with the C2 server somehow in order to pick up tasks and return task output.\nThis is unavoidable and PoshC2 can currently only do this through the use of HTTP(S)\nrequests.\n\nThat isn’t to say this this makes it easy to detect; a huge amount of HTTP traffic is present in\nmost environments and the flexibility of the protocol allows for traffic to be hidden and routed\nthrough legitimate websites using techniques such as Domain Fronting and reverse proxies.\n\nAn example of HTTP comms when domain fronting.\n\nSomething very helpful for catching C2 communications is SSL Inspection. By being able to\ninspect SSL traffic leaving the perimeter, the contents of that traffic can be checked and\nstatistics acquired for detecting C2 communications. Without this, network defenders are\nlargely blind, particularly against domain fronted communications which travel via legitimate\nthird-party websites.\n\nIf SSL Inspection is implemented then the HTTP traffic can be viewed, and while PoshC2\nencrypts the contents of the HTTP bodies, the HTTP URLs and headers can still be viewed.\n\n### URLs\n\n\n-----\n\nPoshC2 has two different ways of generating URLs to use for communications. Operators\ncan either use a static list of URLs or provide a wordlist from which random URLs will be\ngenerated, and these files are stored at `resources/urls.txt and`\n```\nresources/wordlist.txt respectively, with the static URL list being the default option.\n\n```\nThese URLs are then loaded into the database when the project is first created, and a\nrandom URL is chosen by each implant each time it beacons. The default URL list is below:\n```\n/adsense/troubleshooter/1631343/\n/adServingData/PROD/TMClient/6/8736/\n/advanced_search?hl=en-GB&fg=\n/async/newtab?ei=\n/babel-polyfill/6.3.14/polyfill.min.js=\n/bh/sync/aol?rurl=/ups/55972/sync?origin=\n/bootstrap/3.1.1/bootstrap.min.js?p=\n/branch-locator/search.asp?WT.ac&api=\n/business/home.asp&ved=\n/business/retail-business/insurance.asp?WT.mc_id=\n/cdba?ptv=48&profileId=125&av=1&cb=\n/cisben/marketq?bartype=AREA&showheader=FALSE&showvaluemarkers=\n/classroom/sharewidget/widget_stable.html?usegapi=\n/client_204?&atyp=i&biw=1920&bih=921&ei=\n/load/pages/index.php?t=\n/putil/2018/0/11/po.html?ved=\n/qqzddddd/2018/load.php?lang=en&modules=\n/status/995598521343541248/query=\n/TOS?loc=GB&hl=en&privacy=\n/trader-update/history&pd=\n/types/translation/v1/articles/\n/uasclient/0.1.34/modules/\n/usersync/tradedesk/\n/utag/lbg/main/prod/utag.15.js?utv=\n/vfe01s/1/vsopts.js?\n/vssf/wppo/site/bgroup/visitor/\n/wpaas/load.php?debug=false&lang=en&modules=\n/web/20110920084728/\n/webhp?hl=en&sa=X&ved=\n/work/embedded/search?oid=\n/GoPro5/black/2018/\n/Philips/v902/\n\n```\nWhile these URLs were originally copied from legitimate requests, if you see several of them\nbeing repeated to a site, particularly if they do not seem relevant to that site and if the\nresponse does not make sense, then it could be PoshC2 beacon traffic.\n\n### HTTP Responses\n\nPoshC2 also has static HTML responses that it responds with. The default is six HTTP 200\nresponses and one 404 response. These are stored in files at `resources/responses/ and`\nalso loaded into the database when the server is first created. The server responds with a\n\n\n-----\n\nrandom 200 response to POST requests that do not error or require a specific response, and\nwith the single 404 response to all unexpected URLs or when the C2 server errors. Other\nresponses return context relevant data, such as tasks, implant code and so on.\n```\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>404 Not Found</title>\n</head><body>\n<h1>Not Found</h1>\n<p>The requested URL was not found on this server.</p>\n<hr>\n<address>Apache (Debian) Server</address>\n</body></html>\n\n```\nThis static HTML file then at `resources/responses/404_response.html is an IoC and if`\nreturned from a webserver that you are investigating is suggestive of PoshC2. Similarly, the\n_200_response* files in the same directory are IoCs if returned by POST requests._\n\nNote however, that it is recommended that operators change these files before creating a\nPoshC2 project, as is the use of a C2 proxy, so as with the other indicators the absence of\nthis particular response is not unexpected for a PoshC2 installation.\n\n### SSL Certificate\n\nPoshC2 by default creates a self-signed certificate for its HTTP server, the values for which\nare stored in `poshc2/server/Config.py file. These values are not in the ‘normal’`\nconfiguration file `config.yml and are less documented and are therefore harder to`\nchange.\n```\nCert_C = \"US\"\nCert_ST = \"Minnesota\"\nCert_L = \"Minnetonka\"\nCert_O = \"Pajfds\"\nCert_OU = \"Jethpro\"\nCert_CN = \"P18055077\"\nCert_SerialNumber = 1000\nCert_NotBefore = 0\nCert_NotAfter = (10 * 365 * 24 * 60 * 60)\n\n```\nAn experienced operator will not expose their C2 server to the internet, but will instead use a\nproxy server with a valid certificate and filter firewall traffic to the C2 server that is not from\nthat proxy, however if these steps are not taken and a certificate with the below values is\npresented then it is another strong indicator that PoshC2 is in use, likely by less\nsophisticated adversaries.\n\n\n-----\n\nThe issuer data can be viewed using Chrome and the default values suggest this is a PoshC2 server.\n\n### JA3 Signatures\n\nAnother method for signaturing C2 traffic without SSL Inspection is to fingerprint the Client\n_Hello packet that initialises the TCP connection. The specific bytes that make up the packet_\nare dependent upon the type of connection being formed and the underlying packages and\nmethods used to do so.\n\nAs these packets are sent before encryption has been established they are cleartext and can\nbe intercepted and read. It turns out that the packet contents are quite unique and can be\n[fingerprinted. Salesforce have an excellent blog post on JA3 fingerprinting, but essentially](https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967)\nthe details are extracted from the packets that make up this TCP handshake and hashed to\ncreate a quick and easy signature, that can be used to identify not only that PoshC2 is in\nuse, but also the specific implant type.\n\n\n-----\n\nThe current Windows 10 PoshC2 signatures are below:\n\n```\nSharp: fc54e0d16d9764783542f0146a98b300\n\n```\n\nJA3 fingerprinting has been incorporated into security products such as Splunk and\nDarktrace to provide quick and easy identification of C2 traffic, and can be utilised with these\nfingerprints. These fingerprints are available and will be maintained in the PoshC2\nDetections GitHub repository.\n\n### Telemetry\n\nAnother mechanism for detecting C2 traffic, with or without SSL Inspection, is through the\nuse of telemetry.\n\nPoshC2’s default values for beacon time and jitter in the `config.yml file are 5 seconds`\nand a 20% jitter, as can be seen below, which is both a fast beacon rate and a small jitter,\nmaking it relatively easy to detect using this method.\n```\nDefaultSleep: \"5s\"\nJitter: 0.20\n\n```\nWith these values the implants are going to beacon every 4-6 seconds by default, with an\naverage of 5 seconds.\n\nAfter capturing some traffic, filtering by the C2 server host and only checking TLS Client\nHello packets, we can see that the TLS connection is created roughly every five seconds,\nconfirming what we expect.\n\n\n-----\n\nWe can see the difference between each session initialisation is between 4 and 6 seconds.\n\nBy exploring this small sample of data, we can determine that the average time between the\nrequests is 5.05 seconds, with a standard deviation of 0.81 or 16%, close to the 5 second\nbeacon with the 20% jitter we expect from PoshC2’s defaults.\n\nSecurity products that can provide telemetry data, e.g. Splunk can be used to detect C2\ntraffic in this way by checking for repetitive beacons at a relatively fixed frequency, whether\nit’s at the above defaults for PoshC2 or at any frequency, given that it is configurable.\n\n## PowerShell Implant\n\nPoshC2 has three implant types; PowerShell, C#, and Python, with the latter being a\nlightweight implant type mostly intended for compromising *nix hosts.\n\nThe PowerShell Implant runs by loading `System.Management.Automation.dll, the`\nengine behind `PowerShell.exe, into the desired process and executing PowerShell`\ncommands directly using this DLL.\n\n\n-----\n\nThe PowerShell implant supports full PowerShell execution from any process (here netsh.exe) by\n\nloading System.Management.Automation.dll.\n\nWhile this does not utilise `PowerShell.exe, bypassing many restrictions and controls, it is`\nstill subject to PowerShell specific constraints such as Constrained Language mode and\nScriptBlock logging. The latter, in particular, can be used to detect PoshC2 and any other\nmalicious PowerShell commands, whether via `PowerShell.exe or otherwise.`\n\nNote, however, that ScriptBlock logging was only enabled in PowerShell v5.0 and above, so\nif PowerShell v2.0 is available on the target then a downgrade attack can be performed and\nPowerShell 2.0 used, bypassing Constrained Language mode, ScriptBlock logging, AMSI\nand other controls added in v5.0.\n\n### PS Logging\n\nEnabling ScriptBlock logging and Transcript Logging for PowerShell allows logging of\nprocesses running PowerShell commands.\n\nThere are multiple IoCs here, not least that the Host Application is not `PowerShell.exe, as`\nshould be expected, but instead `netsh.exe .`\n\n\n-----\n\nPowerShell transcripts provide valuable information. Alerting on Host Applications that are not\n\nPowerShell.exe is a good way to find PowerShell implants from any C2 framework.\n\nSimilarly in the Event Viewer for ScriptBlock logging:\n\nPowerShell ScriptBlock logging can reveal a wealth of information, here including the beacon URLs\n\nfor PoshC2 and again netsh.exe as a host process.\n\nThis also includes the ‘command line’ of the ScriptBlock being executed, which includes the\nbeacon URLs from which a random element is being chosen, therefore listing all the C2\nURLs that are in use by this implant.\n\n\n-----\n\nAside from the wealth of information ScriptBlock logging provides for any threat hunter, an\nevent command line specific to PoshC2 that can be used to identify the PowerShell implant\nis below:\n\nThe $ServerClean variable is specific to PoshC2 and a clear IoC.\n\n```\nCommandLine= $ServerClean = Get-Random $ServerURLS\n\n```\n\nThis ScriptBlock is part of the beaconing process and will be repeated frequently in the Event\nViewer making it easy to identify.\n\n### System.Management.Automation.dll\n\nAs mentioned earlier, the PowerShell implant does not function by invoking\n```\nPowerShell.exe, but instead by loading System.Management.Automation.dll into the\n\n```\nimplant process.\n\nThis means that this is an IoC, and if we find a process that should not have this DLL loaded,\nparticularly if it is an unmanaged code binary (so not .NET) then it is highly likely that this is a\nprocess that has been injected into by a PowerShell implant, PoshC2 or otherwise.\n\n\n-----\n\nSystem.Management.Automation.dll, the engine behind PowerShell, is a .NET library.\n\nnetsh.exe is a C++ binary and should not be loading .NET libraries.\n\nWe can see this DLL loaded into an implant process using Process Hacker:\n\n\n-----\n\nSystem.Management.Automation.dll loaded into netsh.exe.\n\nSimilarly we can view the .NET Assemblies in the process:\n\n\n-----\n\nWe can view the .NET Assemblies in the netsh.exe process and see PowerShell is loaded.\n\nThis tab shouldn’t even be present for a genuine `netsh.exe process as it is unmanaged`\ncode!\n\n\n-----\n\nThe module is not loaded in a genuine netsh process and the .NET tabs are not available.\n\nAn operator can be smarter about their migration by injecting into .NET processes, however\nit is still unlikely that a legitimate process (that isn’t `PowerShell.exe ) would load`\n```\nSystem.Management.Automation.dll, so this is a great IoC to look out for in your\n\n```\nenvironment.\n\nThis can be implemented at scale by searching for loaded modules in an EDR product, for\nexample in CarbonBlack with a query of:\n```\nmodload:System.Management.Automation* AND -process_name:powershell.exe AND\n–process_name:powershell_ise.exe\n\n```\nThis searches for process with `System.Management.Automation.dll or`\n```\nSystem.Management.Automation.ni.dll (the Native Image version) loaded into a\n\n```\nprocess when that process is not `PowerShell.exe or` `PowerShell_ISE.exe . Other`\nlegitimate exclusions may need to be added for your particular environment.\n\n\n-----\n\nHere we can see various processes that have loaded System.Management.Automation.dll into\n\nmemory that are likely implants.\n\n## C# Implant\n\nThe C# or Sharp implant is PoshC2’s ‘next gen’ implant, written (unsurprisingly) in C#. The\nkey difference from a detection perspective is that this implant does not require loading\n```\nSystem.Management.Automation.dll in order to function. Most of the functionality of the\n\n```\nC# implant is custom-written and while it can load `System.Management.Automation.dll`\nin order to execute PowerShell, this is an operator decision and is by no means necessary.\n\nA similar process to the above can be applied, but is a little harder to implement. .NET\nprocesses load the `mscoree.dll library which is the core library behind the .NET CLR`\n(Command Language Runtime), so again any unmanaged code processes that are loading\nthis library could have been migrated into. The issue here is finding these processes, as it’s\nnot as simple as searching for just ‘module loaded and process name is not powershell.exe’.\n\nA blacklist can be created of common target processes that are unmanaged, always\navailable and should not be loading the .NET runtime, and these can be monitored, as well\nas noting this during manual triage.\n\n\n-----\n\nA C# implant loads mscoree.dll if it is not already present in the process – another IoC if the process\n\nis supposed to be unmanaged.\n\nNote that the PowerShell implant will also load this library as it is also a .NET process,\nhowever the presence of `System.Management.Automation.dll marks it as an implant`\nthat can run PowerShell.\n\nThe C# implant has the ability to load compiled binaries into memory over C2 and run them,\nwhich is extremely powerful. There are indicators of this however, as a new virtual runspace\nis created for each module and their namespace is listed in the AppDomain to which they are\nloaded.\n\nViewing the .NET Assemblies in Process Explorer or Process Hacker for example then\nreveals what modules have been run.\n\n\n-----\n\nIn the C# implant loaded modules have their namespace visible in the AppDomain, making it clear\n\nwhat has been loaded into the implant.\n\nAbove we can see the Core and dropper_cs modules that make up the core functionality of\nthe C# implant, as well as some native modules from Microsoft that are required to run.\nThese modules will always be present in the PoshC2 C# implant and are a clear IoC. We\nalso see [Seatbelt and](https://github.com/GhostPack/Seatbelt) [SharpUp, two common C# offensive modules from SpectreOps, and](https://github.com/GhostPack/SharpUp)\nwe can surmise that they have been on the target.\n\n## In General\n\n### Migration\n\nWe have used `netsh.exe as the example implant process in this post and that is for a`\ngood reason. The default migration process for PoshC2 in the C# and PowerShell implants is\n```\nC:\\Windows\\System32\\netsh.exe, so when the migrate or inject-shellcode\n\n```\ncommands are used and a specific process ID or name is not set, then a new `netsh.exe`\nprocess is spawned and migrated into.\n\nThis itself is a common IoC for PoshC2, as `netsh.exe is not typically frequently run in`\nenvironments, and certainly not on most end user’s hosts. Therefore, if there is a sudden\nuptick in the number of these processes being run in the environment or if several are\nrunning on a host then it could be worth investigating.\n\n### Persistence\n\n\n-----\n\nPoshC2 has three quick persistence commands available to the PowerShell implant. Each of\nthese installs a `PowerShell.exe one liner payload to the registry in the key at`\n```\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\themes with a name\n\n```\n_Wallpaper777, Wallpaper555 or Wallpaper666, depending on the command being run._\n\nThis payload is then triggered by either:\n\nA registry key at `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\run with`\nthe name `IEUpdate`\nA Scheduled Task, also with the name `IEUpdate`\nA shortcut file placed at `%APPDATA%\\Microsoft\\Windows\\Start`\n\n```\nMenu\\Programs\\Startup\\IEUpdate.lnk\n\n```\n\nAll of these can be alerted upon and used to determine that the adversary using PoshC2, in\naddition to alerting on the invocation of `PowerShell.exe with encoded parameters, and so`\non.\n\n### Binary payloads\n\nSome of the more common payloads that are dropped on targets are the PoshC2\nexecutables and DLLs that can be run using `rundll32.exe .`\n\nFor the DLLs, there are different versions for PowerShell and Sharp implants across versions\n2 and 4 of PowerShell and x86 and x64 bit architectures, however all the DLLs have a single\nentry-point common to all: `VoidFunc .`\n\n\n-----\n\nAll the DLL payloads have the same single entry point of VoidFunc.\n\nThis entry-point is hard-coded in PoshC2 and cannot be changed without hacking the\ncompiled binary itself.\n\nFor the common executable and DLL payloads we’ve also added Yara rules for detecting\nthem. These are based on signaturable parts of the binaries that will not change across\ndifferent installs of PoshC2, for example with different comms options. These are also\n[available in the new PoshC2 Detections GitHub repository.](https://github.com/nettitude/PoshC2_IOCs)\n\n## In Summary\n\nWe’ve looked at a few different detections for catching PoshC2 when used out-of-the-box.\nUsing these in your environment will help protect against the less sophisticated users of\nPoshC2 in addition to further understanding how the tool works.\n\nAny new detections or amendments can be added to the\n[https://github.com/nettitude/PoshC2_IOCs repository and we encourage the community to](https://github.com/nettitude/PoshC2_IOCs)\nadd their own detections or rules and configurations for other security tools to help build a\ncentralised data store for everyone.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-17 - Detecting PoshC2 – Indicators of Compromise.pdf"
    ],
    "report_names": [
        "2020-06-17 - Detecting PoshC2 – Indicators of Compromise.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536079,
    "ts_updated_at": 1743041121,
    "ts_creation_date": 1653688017,
    "ts_modification_date": 1653688017,
    "files": {
        "pdf": "https://archive.orkl.eu/ca84f06e19601a53cd2dede074d640829710c28c.pdf",
        "text": "https://archive.orkl.eu/ca84f06e19601a53cd2dede074d640829710c28c.txt",
        "img": "https://archive.orkl.eu/ca84f06e19601a53cd2dede074d640829710c28c.jpg"
    }
}