{
    "id": "7c6256df-da9d-44b7-8aa3-e7124706084a",
    "created_at": "2023-01-12T15:03:14.619413Z",
    "updated_at": "2025-03-27T02:09:18.666733Z",
    "deleted_at": null,
    "sha1_hash": "cb463aa24631473e284f08acbb89ee85cb2a0338",
    "title": "2022-03-12 - Analyzing Malware with Hooks, Stomps, and Return-addresses",
    "authors": "",
    "file_creation_date": "2022-05-28T17:28:50Z",
    "file_modification_date": "2022-05-28T17:28:50Z",
    "file_size": 621341,
    "plain_text": "# Analyzing Malware with Hooks, Stomps, and Return- addresses\n\n**arashparsa.com/catching-a-malware-with-no-name/**\n\nArash's Security Thoughts n Stuff March 12, 2022\n\nMar 12, 2022\n\n### Table of Contents\n\n## Introduction\n\nThis is the second post in my series on developing robust malware and their relevant\ndetection's. This post will focus on an interesting observation I made when creating my heap\nencryption and how this could be leveraged to detect arbitrary shell-code as well as tools like\ncobalt strike, how those detections could be bypassed and even newer detections can be\nmade.\n\nEDITED: Forgot the POC! Here it is [https://github.com/waldo-irc/MalMemDetect](https://github.com/waldo-irc/MalMemDetect)\n\n## The First Detection\n\nIf you recall in the first post, our method at targeting Cobalt Strikes heap allocations was to\nhook the process space and manage all allocations made by essentially what was a module\nwith no name. Here is the code we had used as a refresher:\n\n\n-----\n\n```\n#include <intrin.h>\n#pragma intrinsic(_ReturnAddress)\nGlobalThreadId = GetCurrentThreadId(); We get the thread Id of our dropper!\nHookedHeapAlloc (Arg1, Arg2, Arg3) {\n  LPVOID pointerToEncrypt = OldHeapAlloc(Arg1, Arg2, Arg3);\n  if (GlobalThreadId == GetCurrentThreadId()) { // If the calling ThreadId matches\nour initial thread id then continue\n     HMODULE hModule;\n     char lpBaseName[256];\n          if (::GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n(LPCSTR)_ReturnAddress(), &hModule) == 1) {\n          ::GetModuleBaseNameA(GetCurrentProcess(), hModule, lpBaseName,\nsizeof(lpBaseName));\n     }\n    std::string modName = lpBaseName;\n    std::transform(modName.begin(), modName.end(), modName.begin(),\n        [](unsigned char c) { return std::tolower(c); });\n    if (modName.find(\"dll\") == std::string::npos && modName.find(\"exe\") ==\nstd::string::npos) {\n           // Insert pointerToEncrypt variable into a list\n    }\n  }\n}\n\n```\nThe magic lines lie here:\n```\n          if (::GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n(LPCSTR)_ReturnAddress(), &hModule) == 1) {\n          ::GetModuleBaseNameA(GetCurrentProcess(), hModule, lpBaseName,\nsizeof(lpBaseName));\n     }\n\n```\nWhat we are trying to do here is take the current address our function will be returning to and\nattempting to resolve it to a module name using the function GetModuleHandleExA with the\nargument GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS. With this flag the\nimplication is the address we are passing is: \"an address in the module\"\n(https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapigetmodulehandleexa). The module name will get returned and stored in the lpBaseName\nvariable.\n\nWith the case of our thread targeted heap encryption this function actually returns 0, as it\ncannot resolve the return address to a module! This also means lpBaseName ends up\ncontaining nothing.\n\n\n-----\n\nAs always, let s see what this looks like in our debugger. First, we ll start with a legitimate\ncall. I've gone ahead and hooked HeapAlloc using MinHook\n[(https://github.com/TsudaKageyu/minhook) and am tracing the return address of all callers.](https://github.com/TsudaKageyu/minhook)\nLet's see who the first function to call our hooked malloc is:\n\nfig 1. Usage of _ReturnAddress intrinsic\nHere we can see within our code we use the Visual C++ _ReturnAddress() intrinsic\n[(https://docs.microsoft.com/en-us/cpp/intrinsics/returnaddress?view=msvc-160) and store the](https://docs.microsoft.com/en-us/cpp/intrinsics/returnaddress?view=msvc-160)\nvalue in a variable named \"data\". We then pass this variable to GetModuleHandleExA in\norder to resolve the module name we will be returning to.\n\nfig 2.\n\nReturn address value\nTaking a look at data we can see it seems to have stored a valid address. Now let's look at\nthis address in our disassembler.\n\nfig 3. Return address location\nAs you can see we are right at that \"mov rbx,rax\" instruction at the end of the screenshot\nbased on the address. That means when our hooked function completes this is where it will\nreturn, and we can further validate this as the correct assembly instruction we will return to\nas right before this is a call to RtlAllocateHeap, our hooked function! Using this we now\n\n\n-----\n\nknow we are in the function LdrpGetNewTlsVector, that our hooked RtlAllocateHeap was just\nran, and on completion it'll continue within LdrpGetNewTlsVector right after the call as usual.\nIf we attempt to identify what module this function comes from we can clearly see it is from\nntdll.dll.\n\nfig 4. Return\n\naddress module resolved\nThis works because the function maps to a DLL we appear to have loaded from disk.\nBecause of this, Windows knows how to identify what module the function comes from.\nWhat about our shellcode though? Let's see what that looks like.\n\nfig 5. Shellcode\n\nreturn address and failed resolution\nSo our base name is empty because the function fails to resolve the address to a module.\nLets see what that address looks like in the disassembler:\n\n\n-----\n\nfig 6. Shellcode return address location\nThere's our address at \"test rax,rax\". We actually know this is our shell-code based on the\naddress:\n\n\n-----\n\nShellcode in process hacker\n\n\nfig 7.\n\nfig 8.\n\n\nShellcode region in process hacker\nWithin process hacker we can see our MZ header and that the location we are returning to is\nwithin the address space of our shellcode. We can also see unlike other modules like\nntdll.dll, in ProcessHacker the \"use\" column is empty for our shellcode:\n\nfig 9. Use section for shellcode is empty\n\n\n-----\n\nfig 10. Use section for DLL's is filled\nThis is because our arbitrarily allocated memory does not map to anything on disk. Because\nof this, when we attempt to resolve the return address to a module we get nothing returned\nas a result.\n\nThat being said, we can see instances of RWX memory that don't map to disk in processes\nthat use JIT compilers such as C# and browser processes as well. You can see in stage 3 of\nthe Managed Execution Process (https://docs.microsoft.com/enus/dotnet/standard/managed-execution-process) that an additional compiler takes the C#\ncode a user creates and turns it into native code (which means our C# IL now becomes\nnative assembly). For this process to take place a RWX region needs to be allocated for it to\nbe able to write the new code and also be able to execute it. We can see these RWX\nregions in C# processes with ProcessHacker.\n\n\n-----\n\nfig 11. JIIT Compiler RWX sections\nAbove you can see a small sample of these RWX sections within my\nMicrosoft.ServiceHug.Controller.exe process. This means in theory we could see false\npositives from JIT compiler based languages that run any of our hooked functions from these\nmemory regions. Additionally, this means these sorts of processes can also be great spaces\nto hide your RWX malware, as Private Commit RWX regions are otherwise considered\nsuspicious (as we have executable memory that doesn't map to anything on disk).\n\nOutside of blending in with JIT processes though, let's discuss another simple bypass to this,\none that exists within Cobalt Strikes own C2 profile even.\n\n## The Module Stomp Bypass\n\nIf we think back to the original detection, we were able to observe exectuable memory calling\nour hooked functions that couldn't resolve to any module name. A first thought may be \"what\nis a mechanism to bypass this\" as one must exist. Several exist in fact, but we can start with\n[a simple one, a mechanism called \"Module Stomping\" (https://www.forrest-](https://www.forrest-orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing)\n\n\n-----\n\n[orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing as well as](https://www.forrest-orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing)\nhttps://www.ired.team/offensive-security/code-injection-process-injection/modulestomping-dllhollowing-shellcode-injection).\n\nWhat this technique effectively does is load a DLL that our process doesn't currently have\nloaded and hollow out its memory regions to instead contain the data for a malicious DLL of\nours instead. This would make it so all our calls now appear to be coming from this\nlegitimate module!\n\nThe section in your malleable C2 profile (for Cobalt Strike) that you would have to edit is the\nfollowing:\n```\n  set allocator \"VirtualAlloc\"; # HeapAlloc,MapViewOfFile, and VirtualAlloc.\n  # Ask the x86 ReflectiveLoader to load the specified library and overwrite\n  # its space instead of allocating memory with VirtualAlloc.\n  # Only works with VirtualAlloc\n  set module_x86 \"xpsservices.dll\";\n  set module_x64 \"xpsservices.dll\";\n\n```\nThese settings can be observed in the old reference profile here:\n[https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile. By](https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile)\nchanging your allocator to \"VirtualAlloc\" and enabling the set module_x86 and x64 settings\nyou can now allocate your Cobalt Strike payload to arbitrary modules you load instead of\narbitrarily allocated exectuable memory space.\n\nLet's change the setting and see what this looks like. We will simply run an unstaged Cobalt\nStrike EXE and observe for this experiment.\n\n\n-----\n\nfig 12. Cobalt Strike module stomp\nLet's go ahead and run this with our module name resolver and see what it looks like. Since\nthe name should always resolve now we will change the logic a bit to monitor only\nxpsservices.dll.\n\n\n-----\n\nfig 13. New code to monitor xpsservices\n\nfig 14. Name\n\nresolved properly\nHere we can see the new stomped DLL calling our hooked malloc, and that our code can\nsuccessfully resolve calls to this module. If we look at the print statements we would also\nsee all the calls from anything that dont't map to modules have dissapeared.\n\n\n-----\n\nfig 15. Only module callers\n\nAnd finally we can see in the above screenshot that no callers without module names are\nobserved anymore as all of Cobalt Strike's calls now map to a module on disk, a simple\nbypass. So now we ask if this technique can be detected as well, and of course, there's a\nfew ways.\n\n## The Module Stomp Detection\n\nThere are several detections but we will delve into 2 here for module stomping. One is due\nto a side effect of how Cobalt Strike implements module stomping as well as general IOCs\nthat can be observed when module stomping is performed.\n\n[The first is a detection created by Slaeryan (https://github.com/slaeryan/DetectCobaltStomp).](https://github.com/slaeryan/DetectCobaltStomp)\nIn short, this detection works becasue a side effect of Cobalt Strike's implementation is that\nwhen loaded in memory, the region appears to be marked as a EXE internally and not a DLL.\nFor those that don't have cobalt strike, he also created a tool to mimic the implementation\nfor people to play with and observe the detection. I won't go into this one too much as he\nalready has a POC and discusses this detection.\n\n\n-----\n\nThe other detection is a much more basic one. Within any executable file, the section where\nexecutable code lives is the .TEXT section. If we walk the .TEXT section of a DLL on disk\nand compare it to the .TEXT section of its equivalent offload in memory the sections in theory\nshould always match, as the code should not change unless the file is polymorphic. The\ncode for this is fairly basic.\n```\n  HMODULE lphModule[1024];\n  DWORD lpcbNeeded;\n  // Get a handle to the process.\n  HANDLE = hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |\n    PROCESS_VM_READ,\n    FALSE, processID);\n  // Get a list of all the modules in this process.\n  if (EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded))\n  {\n    for (i = 0; i < (lpcbNeeded / sizeof(HMODULE)); i++)\n    {\n      char szModName[MAX_PATH];\n      // Get the full path to the module's file.\n      if (K32GetModuleFileNameExA(hProcess, lphModule[i], szModName,\n        sizeof(szModName) / sizeof(char)))\n      {\n        // Do stuff\n      }\n    }\n   }\n\n```\nHere we simply start by iterating every module in the process.\n\n\n-----\n\n```\n        // Get file Bytes\n        FILE* pFile;\n        long lSize;\n        //SIZE_T lSize;\n        BYTE* buffer;\n        size_t result;\n        pFile = fopen(szModName, \"rb\");\n        // obtain file size:\n        fseek(pFile, 0, SEEK_END);\n        lSize = ftell(pFile);\n        rewind(pFile);\n        // allocate memory to contain the whole file:\n        buffer = (BYTE*)malloc(sizeof(BYTE) * lSize);\n        // copy the file into the buffer:\n        result = fread(buffer, 1, lSize, pFile);\n        fclose(pFile);\n        BYTE* buff;\n        buff = (BYTE*)malloc(sizeof(BYTE) * lSize);\n        _ReadProcessMemory(hProcess, lphModule[i], buff, lSize, NULL);\n        PIMAGE_NT_HEADERS64 NtHeader = ImageNtHeader(buff);\n        PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeader);\n        WORD NumSections = NtHeader->FileHeader.NumberOfSections;\n        for (WORD i = 0; i < NumSections; i++)\n        {\n          std::string secName(reinterpret_cast(Section->Name), 5);\n          if (secName.find(\".text\") != std::string::npos) {\n            break;\n          }\n          Section++;\n        }\n\n```\nWe then load the relevant module file on disk and store the bytes for comparing memory in\nthe var buffer. We then also read from the base address of the module located in\n\"lphModule[i]\" and store all the bytes within the var buff. We then enumerate all the sections\nin the loaded module until we find the .TEXT section and break the loop. At this point the\n\"Section\" variable will contain all our relevant section data.\n\nTo be able to match the on disk file to the one in memory we need to use the Section offsets\nto find the .TEXT section location on disk and in memory. This actually will not match\n(usually). The offset to the .TEXT section in memory generally gets relocated down a page,\n4096 bytes. The offset to the section on disk is usually 1024 bytes in comparison.  But we\nsay usually so we of course will simply use \"Section->PointerToRawData\" to get the offset on\ndisk and \"Section->VirtualAddress\" to get its offloaded address in memory to be 100% sure.\n```\n        LPBYTE txtSectionFile = buffer + Section->PointerToRawData;\n        LPBYTE txtSectionMem = buff + Section->VirtualAddress;\n\n```\n\n-----\n\nAt this point all you d have to do is compare each memory region byte for byte and make\nsure they match.\n```\n          int inconsistencies = 0;\n          for (int i = 0; i < Section->SizeOfRawData; i++) {\n            if ((char*)txtSectionFile[i] != (char*)txtSectionMem[i]) {\n              inconsistencies++;\n            }\n          }\n\n```\nNow of course we need to account for things like hooks and such, as we know many AV and\nEDR will perform hooks we know these will provide false positives. As a result we take the\namount of the differences and if it's greater than a certain number only do we get concerned.\n```\n          if (inconsistencies > 10000) {\n          printf(\"FOUND DLL HOLLOW.\\nNOW MONITORING: %s with %f changes\nfound. %f%% Overall\\n\\n\", szModName, inconsistencies, icPercent);\n          CHAR* log = (CHAR*)malloc(256);\n          snprintf(log, 255, \"FOUND DLL HOLLOW.\\nNOW MONITORING: %s with %f\nchanges found. %f%% Overall\\n\\n\", szModName, inconsistencies, icPercent);\n          LogDetected(&log);\n          free(log);\n          std::string moduleName(szModName, sizeof(szModName) /\nsizeof(char));\n          std::transform(moduleName.begin(), moduleName.end(),\nmoduleName.begin(),\n            [](unsigned char c) { return tolower(c); });\n          dllMonitor = moduleName;\n          break;\n        }\n\n```\nWe arbitrarily pick 10000 as our amount simply because we know it'll certainly be a larger\nnumber than any number of hooks any utility would alter for the hooks as well as being small\nenough we know most raw malware payloads at least are much bigger. This should reduce\nfalse positives substantially while finding any altered DLLs in memory. The only caveat to\nthis would be additional false positives from polymorphic DLLs who alter themselves in\nmemory.\n\nLet's run our new detector against our Cobalt Strike payload and the hollowed DLL and\nobserve the results.\n\n\n-----\n\nfig 16. DLL Hollow Detection\nHere we can see a few false positives from our own hooks actually, where we alter 5 bytes to\nthe prologue of each function, 2 functions being altered in each DLL. Finally at the end we\ncan see our hollowed xpsservices.dll and the detection is observed with over 300k bytes\naltered.\n\nLet's go ahead and turn our tool into a DLL and inject it into everything to observe false\npositives:\n\nInjecting into everything and logging all data to files we can observe our detection:\n\n\n-----\n\nfig 17. Detection\nBUT! Interestingly enough we do observe 1 false positive on what appears to be a\npolymorphic DLL after all...\n\nfig 18. False positive\nUnfortunately not enough bytes are altered to be useful for a hollow target though!\n\nHow do you bypass this detection? Now the simple obvious solution is to restore the DLL\nbytes (per [https://twitter.com/solomonsklash's idea) on sleep to prevent this sort of detection](https://twitter.com/solomonsklash)\nand next steps would be hooking those calls and detecting the restores if possible or the\nconstant file reads etc. As we all know Cyber Security is a never ending cat and mouse.\n\n## Final Thoughts\n\nAs red teamers work on malware often we make discoveries that can lead to new detections\ntoo. These observations can be tremendously useful to the community while also pushing\nresearchers to the cutting edge and forcing them to think outside of the box if they'd like this\ngame to continue longer.\n\nAs we see above we find detections, make bypasses, find more detections, and the game\nwill never end. Hopefully some interesting new insights could be made to make our\ndefensive industry far more robust overall as we work together towards a goal of secure\ninternet usage.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-12 - Analyzing Malware with Hooks, Stomps, and Return-addresses.pdf"
    ],
    "report_names": [
        "2022-03-12 - Analyzing Malware with Hooks, Stomps, and Return-addresses.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535794,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653758930,
    "ts_modification_date": 1653758930,
    "files": {
        "pdf": "https://archive.orkl.eu/cb463aa24631473e284f08acbb89ee85cb2a0338.pdf",
        "text": "https://archive.orkl.eu/cb463aa24631473e284f08acbb89ee85cb2a0338.txt",
        "img": "https://archive.orkl.eu/cb463aa24631473e284f08acbb89ee85cb2a0338.jpg"
    }
}