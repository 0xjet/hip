{
    "id": "c79f010e-3e83-4de1-8a47-c6c5cb478a2c",
    "created_at": "2023-01-12T15:01:48.799626Z",
    "updated_at": "2025-03-27T02:06:10.893415Z",
    "deleted_at": null,
    "sha1_hash": "7de419e13ba326ab60c2369fc7678f49f196f683",
    "title": "Using process creation properties to catch evasion techniques",
    "authors": "",
    "file_creation_date": "2022-06-30T23:45:52Z",
    "file_modification_date": "2022-06-30T23:45:52Z",
    "file_size": 729030,
    "plain_text": "# Using process creation properties to catch evasion techniques\n\n**[microsoft.com/security/blog/2022/06/30/using-process-creation-properties-to-catch-evasion-techniques](https://www.microsoft.com/security/blog/2022/06/30/using-process-creation-properties-to-catch-evasion-techniques/)**\n\nJune 30, 2022\n\n[We developed a robust detection method in Microsoft Defender for Endpoint that can catch](https://www.microsoft.com/microsoft-365/security/endpoint-defender)\nknown and unknown variations of a process execution class used by attackers to evade\ndetection. This class of stealthy execution techniques breaks some assumptions made by\nsecurity products and enables attackers to escape antimalware scans by circumventing\nprocess creation callbacks using a legacy process creation syscall. Publicly known variations\nof this class are process doppelganging, process herpaderping, and process ghosting.\n\nEvasion techniques used by attackers often involve running malware within the context of a\ntrusted process or hiding code from filesystem and memory scanners. More sophisticated\nattackers even carefully choose their process host so that their actions are run by a process\nthat often performs these actions for benign reasons. For example, a browser process\ncommunicating with the internet seems completely normal, while an instance of cmd.exe\ndoing the same sticks out like a sore thumb. This class of stealthy execution techniques,\nhowever, allows malware to create its own malicious process and prevent antimalware\nengines from detecting it.\n\nThis blog post presents our detailed analysis of how this process execution class works and\nhow it takes advantage of Windows functionalities to evade detection. It also presents a peek\ninto the research, design, and engineering concerns that go into the development of a\ndetection method aiming to be as robust and future-proof as possible.\n\n## Common classes of stealthy process execution\n\nOn Windows systems, most methods attackers use to run code within another process fall\nwithin two classes: process injection and process hollowing. These classes allow attackers to\nrun their code within another process without explicitly creating it from an executable, or\nmaking it load a dynamic link library (DLL). Similar classes of techniques are often also\ncalled process injection, but this term will be used in a more specific definition for clarity.\n\n### Process injection\n\nProcess injection, the widest and most common class, consists of different techniques that\nintroduce attacker-supplied executable memory into an already running process. Techniques\nin this class consist of two main parts:\n\n**Write primitive: A Windows API function, or a set of APIs, used to introduce**\nmalware into the target process.\n\n\n-----\n\n**Execution primitive: A Windows API method to redirect the execution of the**\nprocess to the code provided by the attacker.\n\nAn example of a classic process injection flow is malware using the VirtualAllocEx API to\nallocate a buffer within a target process, WriteProcessMemory to fill that buffer with the\ncontents of a malware module, and CreateRemoteThread to initiate a new thread in the\ntarget process, running the previously injected code.\n\n### Process hollowing\n\nIn process hollowing, instead of abusing an already running process, an attacker might start\na new process in a suspended state and use a write primitive to introduce their malware\nmodule before the process starts running. By redirecting the entry point of the process before\nunsuspending, the attacker may run their code without using an explicit execution primitive.\n\nVariants (and sometimes combinations) of both classes exist and differ from each other\nmostly by the APIs being used. The APIs vary because a different function used to achieve\nthe goal of one of the steps may not go through the numerous points at which an endpoint\nprotection product intercepts such behavior, which can break detection logic.\n\n## New stealth techniques\n\nIn the past few years, stealth techniques from a process execution class have emerged that\ndon’t strictly fit into any of the previously mentioned classes. In this class, instead of\nmodifying the memory of an already created (but perhaps not yet executing) process, a new\nprocess is created from the image section of a malware. By the time a security product is\nready to scan the file, the malware bits aren’t there anymore, effectively pulling the rug from\nunder antimalware scanners. This technique requires defenders to use a different detection\nmethod to catch attacks that use it. As of today, the following variations of this class are\nknown publicly as the following:\n\n**Process doppelganging :1** Abusing transactional NTFS features to create a volatile\nversion of an executable file used for process creation, with the file never touching the\ndisk.\n**Process herpaderping :2** Utilizing a writable handle to an executable file to overwrite\nthe malware bits on disk before antimalware services can scan the executable, but after\na process has already been created from the malicious version.\n**Process ghosting :3** Abusing a handle with delete permissions to the process\nexecutable to delete it before it has a chance to be scanned.\n\n\nThis process execution class, including the variations mentioned above, takes advantage of\nthe way the following functionalities in the operating system are designed to evade detection\nby security products:\n\n\n-----\n\nAntimalware engines don t scan files after every single modification.\nProcess creation callbacks, the operating system functionality that allows antimalware\nengines to scan a process when it’s created, is invoked only when the first thread is\ninserted into a process.\n_NtCreateProcessEx, a legacy process creation syscall, allows the creation of a process_\nwithout populating it with any thread.\n\nThe following sections explain in more detail how these functionalities are abused.\n\n### When are files scanned?\n\nA key feature of this process execution class is circumventing a file scan. Ideally, files are\nscanned whenever they’re modified. Otherwise, an attacker could simply modify an existing\nfile into a malicious one, use it to create a process, and then either revert the file or delete it.\nSo, why aren’t files scanned on every file change?\n\nThe answer lies in performance concerns. Consider a scenario in which a 1MB file is opened,\n[and it’s overwritten by calling an API like WriteFile for every byte that needs to be](https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-writefile)\noverwritten. While only 1MB would be written to disk, the file would have to be scanned one\nmillion times, resulting in ~1 terabyte of data being scanned!\n\nWhile the example is a good way to assure no detectably malicious content is written to disk,\nthe amount of computing power it will use up makes it an unviable solution. Even a caching\nsolution would simply shift the high resource usage to memory, as a product would need to\nkeep information about the content of every single open file on the machine to be useful.\n\nTherefore, the most common design for file scanning engines ignores the various transient\nstates of the file content and initiates a scan whenever the handle to the file is closed. This is\nan optimal signal that an application is done modifying a file for now, and that a scan would\nbe meaningful. To determine what the file is about to execute as a process, the antimalware\nengine scans the file’s content at the time of process creation through a process creation\ncallback.\n\nProcess creation callbacks in the kernel, such as those provided by the\n_[PsSetCreateProcessNotifyRoutineEx API, is the functionality in the operating system that](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex)_\nallows antimalware engines to inspect a process while it’s being created. It can intercept the\ncreation of a process and perform a scan on the relevant executable, all before the process\nruns.\n\nProcess creation notification isn’t invoked right when a process creation API is called, but\nrather when the first thread is inserted into a process. But since NtCreateUserProcess, the\nsyscall used by all common high-level APIs to create a process, is designed to do a lot of the\nwork required to create a process in the kernel, the insertion of the initial thread into the\n\n\n-----\n\ncreated process happens within the context of the syscall itself. This means that the callback\nlaunches while the process is still being created, before user mode has a chance to do\nanything.\n\nFigure 1. Process creation callbacks being invoked from NtCreateUserProcess\n\nThe call stack indicates that in this scenario, PspCallProcessNotifyRoutines, the function\nresponsible for invoking process creation callbacks, is called from PspInsertthread during\nthe insertion of the initial thread into the process. It also indicates that the subsequent\nprocess creation callbacks are all called from within NtCreateUserProcess, and that they both\nfinish executing before the syscall returns. This enables the antimalware to scan the process\nfor malware activity as it’s created. This works if the process is created using\n_NtCreateUserProcess. However, as researchers have found, there are other ways to create a_\nprocess apart from this syscall.\n\n### How are processes created?                                            \n\nThe syscall NtCreateUserProcess has only been available since the release of Windows Vista.\nProcesses created by the CreateProcess API or any API using the NtCreateUserProcess\nsyscall only provide the path to the executable. Meanwhile, the kernel opens the file without\nany share access that could allow modification (no SHARE_WRITE/SHARE_DELETE),\ncreates an image section, and returns to user mode with the process pretty much ready to run\n(most legitimate Windows processes would require additional work to be done in user mode\nto operate correctly, but the NtCreateUserProcess syscall does the minimum work needed for\na process to execute some code). This means that an attacker doesn’t have the time or the\ncapability to modify an executable file after calling NtCreateUserProcess, but only before it’s\nscanned.\n\nVersions of the NT kernel prior to the release of Windows Vista used a different syscall called\n_NtCreateProcessEx. This function doesn’t adhere to the principle of doing a lot of the work in_\nthe kernel and in fact delegates a lot of the work normally associated with process creation on\nmodern Windows platforms to user mode.\n\n\n-----\n\nFigure 2. The function signature of NtCreateProcessEx. Note the absence of a path argument and the\n\npresence of SectionHandle.\n\nOne difference between the two is that NtCreateProcessEx doesn’t receive a path to the\nprocess executable as an argument, as is the case with NtCreateUserProcess.\n_NtCreateProcessEx expects the application to open the file on its own and create an image_\nsection from that file, which will be used as the main image section of the process, and the\nhandle to which will be passed to NtCreateProcessEx.\n\nAlso, unlike NtCreateUserProcess, NtCreateProcessEx creates a process object without\npopulating the process with any threads, and the user application needs to explicitly insert\nthe initial thread into the process using an API like NtCreateThread.\n\nFigure 3. In this callstack, the invocation of PspCallProcessNotifyRoutine and PspInsertThread happens\n\nfrom within NtCreateThreadEx, not from within a process creation syscall.\n\nCombining this information with what we know about process creation callbacks allows us to\ncome up with a generic flow for this stealthy process creation technique:\n\n1. The attacker opens the malware file and brings it into a transient modifiable state\n\n(writable without closing a handle, delete pending or an uncommitted transaction, and\nsome other unpublished ones) while having malware content. The attacker doesn’t\nclose the file yet.\n2. The attacker creates an image section from the file handle using NtCreateSection(Ex).\n3. The attacker creates a process using the image section handle as input.\n\n\n-----\n\n4. The attacker reverts the file s transient state to a benign state (the file is deleted or\n\noverwritten, or a transaction is rolled back), and the handle is closed. At this point, the\nbits of the malware still exist in memory as the image section object is still there, but\nthere is no trace of the malware content on the disk.\n5. The attacker inserts the initial thread into the process, and only then will the process\n\ncreation notification callback for that process be launched. At that point, there is no\nmalware content left to scan.\n6. The attacker now runs the malware process without its backing file ever being scanned.\n\nIn this generalized flow, a security product should be able to detect any variation of the\ntechnique if it can recognize that the process was created using the legacy NtCreateProcessEx\nsyscall, which allows an adversary to run the process from a file in a transient state.\n\nOf course, one could circumvent the need for NtCreateProcessEx by performing a similar\ntrick with loading DLLs. However, in this scenario, the adversary can either load a new DLL\ninto a process they already have full code execution capabilities without changing its identity,\nor remotely place the offending DLL into another process, performing what is essentially\nprocess injection. In both cases, the technique’s effectiveness as an evasion method is greatly\ndiminished.\n\n## Detecting legacy process creation\n\nThe first anomaly to recognize to detect attacks using this technique is to find out whether a\nprocess was created using the legacy NtCreateProcessEx syscall.\n\nThe simplest way to do so would be to utilize user-mode hooking on the appropriate function\nin the NTDLL library. However, this approach would be easy to bypass, as it’s assumed that\nthe adversary has arbitrary execution capabilities in the process calling the syscall. This\nmeans they would be able to unhook any functions intercepted by a security product, or\nsimply directly call the syscall from their own assembly code. Even if the security product was\nto traverse the user-mode call stack from a process creation callback and check the return\naddress against known values, the product would still be subject to evasion since an attacker\ncould employ some creative pushes and jumps in assembly code to construct a spoofed usermode call stack to their liking.\n\nTo create a robust detection for this behavior, information that can’t be modified or spoofed\nby a user-mode adversary should be used. A good example of this is a Windows file system\n[concept called extra create parameters (ECPs).](https://docs.microsoft.com/windows-hardware/drivers/ifs/introduction-to-extra-create-parameters)\n\nECPs are concepts that allow the kernel or a driver to attach some key-value information to a\nfile create/open operation. The idea is very similar to extended file attributes, but instead of\napplying to an entire file on disk, ECPs are a transient property related to a specific instance\nof an open file. This mechanism allows the operating system and drivers to respond to a file\nbeing opened under some special circumstances.\n\n\n-----\n\nAn example of such special circumstances is a file being opened via Server Message Block\n[(SMB). When this happens, an SRV_OPEN_ECP_CONTEXT structure is added to the](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_srv_open_ecp_context)\n_[IRP_MJ_CREATE IRP with GUID_ECP_SRV_OPEN as a key.](https://docs.microsoft.com/windows-hardware/drivers/kernel/end-user-i-o-requests-and-file-objects)_\n\nThis ECP context contains information on the socket used for the communication with the\nSMB client, the name of the share which has been accessed, and some oplock information. A\ndriver would then be able to use this information to appropriately handle the open operation,\nwhich might need some special treatment since the operation happened remotely.\n\n[Interestingly, an exported, documented function named FsRtlIsEcpFromUserMode exists to](https://docs.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltisecpfromusermode)\ndetermine whether an ECP originated in user mode or kernel mode. This raises the concern\nthat forgetting to use this function in a driver or the OS would cause potential security issues,\nas a user mode adversary could spoof an ECP. That isn’t the case, though, as there is no\nfunctionality in the OS which allows a user to directly supply any ECP from user mode. The\nfunction itself checks whether a specific flag is set in the opaque ECP header structure, but\nthere exists no code in the OS which can modify this flag.\n\n### Using ECPs for process creation API recognition\n\nStarting with Windows 10, a very interesting ECP has been added to the operating system\nwhenever a new process is created using NtCreateUserProcess. The\n_GUID_ECP_CREATE_USER_PROCESS ECP and its related_\n_CREATE_USER_PROCESS_ECP_CONTEXT context are applied to the IRP_MJ_CREATE_\noperation when the Windows kernel opens the process executable file. This ECP contains the\ntoken of the process to be created. In fact, the function used to open the executable path was\nchanged from ZwOpenFile to IoCreateFileEx specifically to support ECPs on this operation.\n\nFigure 4. The CREATE_USER_PROCESS_ECP_CONTEXT\n\nOn the other hand, as covered earlier, NtCreateProcessEx doesn’t open the process\nexecutable on its own but instead relies on the user to supply a section handle created from a\nfile opened by the user themselves. Seeing as there is no way for the user to set the process\ncreation ECP on their own handle, any process created using NtCreateProcessEx would be\nmissing this ECP on the IRP_MJ_CREATE for its main image. Some cases exist in which the\nECP wouldn’t be present even when the legacy API wasn’t used, but those can still be\n\n\n-----\n\nrecognized. Barring those cases, the existence of the CREATE_USER_PROCESS ECP in the\n_IRP_MJ_CREATE operation of the file object related to the main image of the process can_\nnow be used to precisely differentiate between processes created by NtCreateUserProcess\nand those created by NtCreateProcessEx.\n\n## Detecting processes created from files in a transient state\n\nSince it’s now possible to check when the legacy process creation API has been used, the next\nstep would be to check if the usage of the legacy process creation API was used to abuse the\ntime-of-check-time-of-use (TOCTOU) issue involving process creation callbacks. This means\nthat the executable image used to create the process has been opened and used in a transient\nstate, which would already be rolled back when it’s to be scanned by an antimalware engine.\nTo identify if TOCTOU was abused, it is important to examine the image section of the main\nexecutable of the process.\n\nWindows loads executable images into memory and shares their memory between processes\n[using memory sections (also called memory-mapped files). Each FILE_OBJECT structure for](https://docs.microsoft.com/dotnet/standard/io/memory-mapped-files)\nan open file contains a member called SectionObjectPointers, which contains pointers to the\ndata and image section control areas relevant to the file, depending on whether if it has been\nmapped as a data file or an executable. The bits described by such a section may be backed\neither by a file on disk or by the page file (in which case the bits of the section won’t persist\non disk). This property determines whether the mapped section can be flushed and recovered\nfrom a file or disk, or simply paged out.\n\nHowever, an interesting thing happens when the connection between an image section and\nits backing file is severed. This can happen if, for example, the file is located on a remote\nmachine or some removable storage, Copy-on-Write has been triggered, or most\nimportantly, if the file has been somehow modified after the section has been created or\ncould be modified in the future. During such cases, the image section becomes backed by the\npage file instead of the original file from which it was created.\n\n\n-----\n\nFigure 5. The control area of a section breaking coherency with disk. Note the WritableUserReferences\n\nmember being set.\n\nThe _[MmDoesFileHaveUserWritableReferences function provides the caller with the number](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmdoesfilehaveuserwritablereferences)_\nof writable (or, more correctly, modifiable) references to the file object of a section and is\nused by the kernel transaction manager to preserve the atomicity of transactions. Otherwise,\na file can be written, deleted, or simply gone when a transaction is to be committed. This\nfunction can be used for detection because a non-zero return value means that section\ncoherency has been broken, and the logic switching the backing of the section to the page file\nhas been triggered. This can help determine that the file is in one of the same transient states\nneeded to abuse TOCTOU and evade detection.\n\n## Detection through Microsoft Defender for Endpoint\n\nThe two primitives discussed earlier can now be combined into detection logic. First, the\nabsence of the GUID_ECP_CREATE_USER_PROCESS ECP will verify if the process was\ncreated using the legacy API NtCreateProcessEx. Then, the function\n_MmDoesFileHaveUserWritableReferences checks if the file’s image section is backed by the_\npage file, confirming that the process was created while the file is in a transient state.\nMeeting both conditions can determine that TOCTOU has been abused, whether by any of\nthe published techniques, or a variation of it that uses similar concepts but abuses a\nfunctionality built into a driver to create a similar effect.\n\n\n-----\n\n[Microsoft Defender for Endpoint can detect each of the known techniques in this class of](https://www.microsoft.com/microsoft-365/security/endpoint-defender)\nstealthy process execution and gives out a specific alert for variations of process ghosting,\nherpaderping, and doppelganging found in the wild. Apart from the specific alerts for each\nvariation, detections exist for the generalized flow and any abuse of the legacy process\ncreation API, including unpublished variations.\n\nFigure 6. Microsoft Defender for Endpoint detections for variations of process\n\nghosting, herpaderping, and doppelganging.\n\nThis blog post shares Windows internals knowledge and showcases a new detection method\nin Microsoft Defender for Endpoint that can help prevent detection evasion. Since data and\n[signals from Microsoft Defender for Endpoint also feed into Microsoft 365 Defender, this](https://www.microsoft.com/security/business/threat-protection/microsoft-365-defender)\nnew detection method further enriches our protection technologies, providing customers a\ncomprehensive and coordinated threat defense against threats.\n\nThe stealth execution techniques discussed further prove that the threat landscape is\nconstantly evolving, and that attackers will always look for new avenues to evade detection.\nThis highlights the importance of continuous research on potential attack vectors, as well as\nfuture-proof solutions. We hope that the principles presented in this blog post can be used by\nother researchers in developing similar solutions.\n\n**_Philip Tsukerman, Amir Kutcher, and Tomer Cabouly_**\n_Microsoft 365 Defender Research Team_\n\n\n-----\n\nhttps://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-TransactionProcess-Doppelganging.pdf\n\n2 https://jxy-s.github.io/herpaderping/\n\n\n3 https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Using process creation properties to catch evasion techniques.pdf"
    ],
    "report_names": [
        "Using process creation properties to catch evasion techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535708,
    "ts_updated_at": 1743041170,
    "ts_creation_date": 1656632752,
    "ts_modification_date": 1656632752,
    "files": {
        "pdf": "https://archive.orkl.eu/7de419e13ba326ab60c2369fc7678f49f196f683.pdf",
        "text": "https://archive.orkl.eu/7de419e13ba326ab60c2369fc7678f49f196f683.txt",
        "img": "https://archive.orkl.eu/7de419e13ba326ab60c2369fc7678f49f196f683.jpg"
    }
}