{
    "id": "c40972ab-2bf0-4298-919a-7aba9cbc68c5",
    "created_at": "2023-01-12T15:10:58.696326Z",
    "updated_at": "2025-03-27T02:05:39.80278Z",
    "deleted_at": null,
    "sha1_hash": "3b928b3d43d5add096d3577e2491aee7bb12165a",
    "title": "2018-04-05 - Analysis of New Agent Tesla Spyware Variant",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:59Z",
    "file_modification_date": "2022-05-29T10:40:59Z",
    "file_size": 143021,
    "plain_text": "# Analysis of New Agent Tesla Spyware Variant\n\n**[fortinet.com/blog/threat-research/analysis-of-new-agent-tesla-spyware-variant.html](https://www.fortinet.com/blog/threat-research/analysis-of-new-agent-tesla-spyware-variant.html)**\n\nThreat Research\n\nBy [Xiaopeng Zhang | April 05, 2018](https://www.fortinet.com/blog/search?author=Xiaopeng+Zhang)\n\n\nApril 5, 2018\n\n\nRecently, FortiGuard Labs captured a new malware sample that was spread via Microsoft\nWord documents. After some quick research, I discovered that this was a new variant of the\nAgent Tesla spyware. I analyzed another sample of this spyware last June and published a\n[blog about it. In this blog, I want to share what’s new in this new variant.](https://www.fortinet.com/blog/threat-research/in-depth-analysis-of-net-malware-javaupdtr.html)\n\nThis malware was spread via a Microsoft Word document that contained an embedded exe\nfile. Figure 1 below shows what it looks like when you open the Word document.\n\nFigure 1. Opening the malicious Word document\n\nAs you can see, it asks the victim to double click the blue icon to enable a “clear view.” Once\nclicked, it extracts an exe file from the embedded object into the system’s temporary folder\nand runs it. In this case, the exe file is called “POM.exe”.\n\n\n-----\n\nFigure 2. POM.exe is created in a temporary folder\n\n## Analysis of POM.exe\n\nFigure 3. Looking at POM.exe in an analysis tool\n\nIn figure 3 we can see that the malware is written in the MS Visual Basic language. Based on\nmy analysis, it’s a kind of installer program. When it runs, it drops two files: “filename.exe”\nand “filename.vbs” into the “%temp%\\subfolder”. It then exits the process after executing the\nfile “filename.vbs”. Below, in figure 4, is the content of “filename.vbs”.\n\nFigure 4. The content of filename.vbs\n\nTo make it run automatically when the system starts, it adds itself (runs filename.vbs) to the\nsystem registry as a startup program. It then runs “%temp%\\filename.exe”.\n\nFigure 5. The malware adds itself into the system registry as “RunOnce” item\n\n## Analysis of filename.exe\n\nWhen “filename.exe” starts, like most other malware it creates a suspended child process\nwith the same name to protect itself. It then extracts a new PE file from its resource to\noverwrite the child process memory. Afterwards, it resumes the execution of the child\nprocess. This is when it executes the code of that new PE file, which is the main part of this\nmalware.\n\nFigure 6. Checking to see if the module mscorjit.dll is loaded\n\nLet’s go on to the analysis of the child process. It first checks to see if the environment value\nof \"Cor_Enable_Profiling\" is set to 1, and if the modules \"mscorjit.dll\" and \"clrjit.dll\" have\nbeen loaded (see figure 6). If one of these checks is true, it exits the process without doing\nanything. So far, I have no idea what the purpose of doing that is, but it is likely antisomething.\n\nIf the process doesn’t exit, it loads a named resource. The resource name is \"__\", which is a\nstring decrypted from a local variable. Afterwards, by calling the API functions\n“FindResource” and “LoadResource”, it can read the resource data to the process memory.\nFigure 7 shows the “__” resource in CFF Explorer. For sure, the data is encrypted.\n\nFigure 7. Encrypted “__” resource\n\nBy decrypting the “__” data, we obtain another PE file, which is a .Net framework program.\nThis is to be loaded into the child process memory. It reads sections of the .Net program into\nmemory according to the PE file headers, imports APIs defined in the import table for .Net\nprograms, relocates offset of the function “_CorExeMain”, as well as builds the .Net\n\n\n-----\n\nframework running environment by calling several APIs. Finally, it jumps to the entry point of\nthe .Net program where it later jumps to “_CorExeMain” – which is the entry point of all .Net\nprograms – to execute this .Net program. You can see in figure 8 how it jumps to the\n“_CorExeMain” function.\n\nFigure 8. Jumping to the entry point of the .Net program\n\nIn order to further analyze the .Net program, I dumped it from the child process memory into\na local file. This allowed me to launch it independently rather than running it within the child\nprocess. This also allowed me to load it into the .Net program analysis tools to analyze it.\n\n## Deep analysis of the .Net program\n\nThe dumped file has an incorrect PE header. I manually repaired it so that it can be\nexecuted, debugged, and parsed by .Net program analysis tools. Figure 8 shows the main\nfunction of the .Net program in an analysis tool.\n\nFigure 9. The main function of the .Net program\n\nAs you may have already noticed, it uses some kind of code obfuscation technique to\nincrease the difficulty of code analysis. In the following parts, you may see that some of the\nnames of method, class, variable, etc. have been modified to make them understandable.\n\nAll the constant strings in the .Net program are encoded and saved within a large buffer, and\nevery string is assigned an index. Whenever it needs to use the string, it calls a function with\nits string index to get the string. If the string is encoded, it throws the encoded string into\nanother function to get it decoded. In figure 10 we can see that it reads the huge string into\nthe big buffer—“Pkky9noglfauhKN1Fjq.QOZ4uWBaWw”.\n\nHere is an example:\n“XtL6rF5GoidQVxdCxi.R6ybT342I(Pkky9noglfauhKN1Fjq.Y3LpEpC6nY(3172));”\n\n“3172” is the string index.\n\nThe “Pkky9noglfauhKN1Fjq.Y3LpEpC6nY” function picks up the string of index 3172 from\nthat large buffer. In this case, it’s \"hyNN5z+7qAsS695lDXLuHg==\".\n\n“XtL6rF5GoidQVxdCxi.R6ybT342I” is the decoding function. After decoding, we get the string\n“True\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00”. i.e. “True”.\n\nFigure 10. Reading strings in the large buffer\n\nWhen the main function is called, it first pauses 15 seconds by calling “Thread::Sleep()”\nfunction. This allows it to potentially bypass sandbox detection.\n\n\n-----\n\nAs my analysis in the [previous blog showed, Agent Tesla is a spyware. It monitors and](https://www.fortinet.com/blog/threat-research/in-depth-analysis-of-net-malware-javaupdtr.html)\ncollects the victim’s keyboard inputs, system clipboard, screen shots of the victim’s screen,\nas well as collects credentials of a variety of installed software. To do that it creates many\ndifferent threads and timer functions in the main function. So far, through my quick analysis,\nthis version is similar to the older one. As I did not find much change, I won’t talk about it\nmore here but simply refer you to the previous blog analysis.\n\nHowever, the way of submitting data to the C&C server has changed. It used to use HTTP\nPOST to send the collected data. In this variant, it uses SMTPS to send the collected data to\nthe attacker’s email box.\n\nBased on my analysis, the commands used in the SMTP method include “Passwords\nRecovered”, “Screen Capture”, and “Keystrokes”, etc. The commands are identified within\nthe email’s “Subject” field. For example:\n\n_“System user name/computer name Screen Capture From: victim’s IP”_\n\nHere’s an example to show you how it sends the collected credential data to the attacker’s\nemail address. Figure 10 shows the email content that will be sent out with my PC\ninformation along with the collected credentials. It enables an SSL function and uses TCP\nport 587. The “Body” field is the collected data in HTML format. The “Subject” field contains\nthe command “Passwords Recovered\" which tells the recipient that this email contains\ncredentials.\n\nFigure 11. Email content with collected data\n\nThe attacker registered a free zoho email account for this campaign to receive victims’\ncredentials. Figure 11, below, shows the SMTP server and its login information. You can see\nthe attacker’s SMTP credential “UserName” and “Password” as well as the SMTP server.\n\nFigure 12. Attacker’s SMTP credential\n\nWhen the email is sent out through the Wireshark tool, we were able to capture the packets\nshown in figure 12, below.\n\nFigure 13. Collected data submission using SMTPS in wireshark\n\nAs I explained above, the collected data in the mail body is in html format. I copied the html\ncontent into a local html file and was able to open it in the IE brower to see what the malware\nhad harvested from my test enviroment. In figure 13, you can see the screenshot of my PC\ninformation along with the related credentials in an IE browser.\n\nFigure 14 Harvested Credentials\n\n## Daemon program\n\n\n-----\n\nIt also drops a daemon program from the .Net program s resource named Player into the\n“%temp%” folder and run it up to protect “filename.exe” from being killed.\n\nFigure 15. Dropping the daemon program and running it\n\nThe daemon program’s name is made up of three random letters, as you can see in figure\n15. It’s also a .Net program and its main purpose is very clear and simple. Figure 16 shows\nthe daemon program’s entire code in an analysis tool.\n\nYou can see that the main function receives a command line argument (for this sample, it’s\nthe full path to “filename.exe”.) and saves it to a string variable called “filePath”. It creates a\nthread, and in the thread function it checks to see if the file “filename.exe” is running in each\n900 millisecond. It runs it again whenever the “filename.exe” is killed.\n\nFigure 16. Daemon program code\n\n## Solution\n\nThe file “PPSATV.doc” has been detected as “W32/VBKrypt.DWSS!tr”, and “POM.exe” has\nbeen detected as “W32/VBKrypt.DWSS!tr” by FortiGuard AntiVirus service.\n\nWe have informed Zoho of the email account which is being used in this AgentTesla\ncampaign.\n\n## IoC:\n\n**Sample SHA256:**\n\nPPSATV.doc\n\n_13E9CDE3F15E642E754AAE63259BB79ED08D1ACDA93A3244862399C44703C007_\n\nPOM.exe\n\n_A859765D990F1216F65A8319DBFE52DBA7F24731FBD2672D8D7200CC236863D7_\n\nfilename.exe\n\n_B4F81D9D74E010714CD227D3106B5E70928D495E3FD54F535B665F25EB581D3A_\n\nRandom name daemon program\n\n_C2CAE82E01D954E3A50FEAEBCD3F75DE7416A851EA855D6F0E8AAAC84A507CA3_\n\n_Check out our latest_ _[Quarterly Threat Landscape report for Q4 of 2017 for more details about](http://go.fortinet.com/LP=4272?utm_source=social&utm_medium=blog&utm_campaign=GEN-WP-Q4-2017-Fortinet-Threat-Landscape-)_\n_recent threats._\n\n\n-----\n\n_[Sign up for our weekly FortiGuard intel briefs](https://fortiguard.com/resources/threat-brief)_ _or_ _to be a part of our_ _[open beta of Fortinet s](https://tis.fortiguard.com/signup/)_\n_FortiGuard Threat Intelligence Service._\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-04-05 - Analysis of New Agent Tesla Spyware Variant.pdf"
    ],
    "report_names": [
        "2018-04-05 - Analysis of New Agent Tesla Spyware Variant.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536258,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653820859,
    "ts_modification_date": 1653820859,
    "files": {
        "pdf": "https://archive.orkl.eu/3b928b3d43d5add096d3577e2491aee7bb12165a.pdf",
        "text": "https://archive.orkl.eu/3b928b3d43d5add096d3577e2491aee7bb12165a.txt",
        "img": "https://archive.orkl.eu/3b928b3d43d5add096d3577e2491aee7bb12165a.jpg"
    }
}