{
    "id": "73a14ea5-414d-4359-bba6-96264a00c578",
    "created_at": "2023-01-12T15:00:30.548269Z",
    "updated_at": "2025-03-27T02:05:41.471333Z",
    "deleted_at": null,
    "sha1_hash": "9233e630e5cc0474aa532b280781b862343c3cb5",
    "title": "2019-08-15 - The Hidden Bee infection chain, part 1- the stegano pack",
    "authors": "",
    "file_creation_date": "2022-05-28T02:32:52Z",
    "file_modification_date": "2022-05-28T02:32:52Z",
    "file_size": 1579005,
    "plain_text": "# The Hidden Bee infection chain, part 1: the stegano pack\n\n**[blog.malwarebytes.com/threat-analysis/2019/08/the-hidden-bee-infection-chain-part-1-the-stegano-pack/](https://blog.malwarebytes.com/threat-analysis/2019/08/the-hidden-bee-infection-chain-part-1-the-stegano-pack/)**\n\nhasherezade August 15, 2019\n\nAbout a year ago, we described the Hidden Bee miner delivered by the Underminer Exploit\nKit.\n\nHidden Bee has a complex and multi-layered internal structure that is unusual among\ncybercrime toolkits, making it an interesting phenomenon on the threat landscape. That’s\nwhy we’re dedicating a series of posts to exploring particular elements and updates made\nduring one year of its evolution.\n\nRecently, we decided to revisit this interesting miner, [describing its loader that starts the](https://blog.malwarebytes.com/threat-analysis/2019/05/hidden-bee-lets-go-down-the-rabbit-hole/)\ninfection from a single malicious executable. This post will present an alternative loader that\nis deployed when the infection starts from the Underminer Exploit Kit. It is analogous to the\n[loader we described in the following posts from 2018: [1] and [2].](https://blog.malwarebytes.com/threat-analysis/2018/07/hidden-bee-miner-delivered-via-improved-drive-by-download-toolkit/)\n\n## The dropped payloads: an overview\n\nThe first time we spotted Hidden Bee, it started the infection from a flash exploit. It\ndownloaded and injected two elements with WASM extensions that in reality were\n[executable modules in a custom format. We described them in detail here.](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)\n\n\n-----\n\nThe files with WASM extensions, observed a year ago\nThose elements were the initial loaders, responsible for initiating the infection chain that at\nthe end installed the miner.\n\nNowadays, those elements have changed. If we take a look at the elements dropped by the\nsame EK today, we will no longer find those WASM extensions. Instead, we encounter\nvarious multimedia files: a WAV (alternatively two WAVs), a JPEG, and a PNG.\n\nThe elements downloaded nowadays: WAV, JPG, PNG\nThe WAV files are downloaded by iexplore.exe, the browser where the exploit is run. In\ncontrast, the images are downloaded at later stages of infection. For example, the JPG is\nalways downloaded from the dllhost.exe process. The PNG is often downloaded from yet\nanother process.\n\nIn some runs, we observed the PNG to be downloaded instead of the JPG:\n\nAlternative: PNG being downloaded after WAV\nWe will start our journey of Hidden Bee analysis by looking at these files. Then, we will move\nto see the code responsible for processing them in order to reveal their hidden purpose.\n\nThe roadmap of the full described package:\n\n\n-----\n\nDiagram showing the transitions between the elements\n\n**The downloaded WAV**\n\nThe WAV file sounds like grey noise, and we suspect that it is meant to hide some binary\nbelonging to the malware.\n\n\n-----\n\nAn oscillogram of the WAV file\nThe data is unreadable, probably encrypted or obfuscated:\n\nWe also found a repeating pattern inside, which looks like an encrypted padding. The size of\nthe chunk is 8 bytes.\n\nThe\n\nrepeating pattern inside the file: 8 bytes long\nThis time, using the repeating pattern as an XOR key didn’t help in getting a readable result,\nso probably some more complex block cipher was used.\n\n**The JPG**\n\nBelow is a sample JPG, downloaded from the URL in the format:\n\n```\n/views/[unique_string].jpg\n\n```\n\nIn contrast to the WAV content, the JPG always looks like a valid image. (Interestingly, all the\nJPGs we observed have a consistent theme of manga-styled girls.) However, if we take a\ncloser look at the image, we can see that some data is appended at the end.\n\n\n-----\n\nLet’s analyze the JPG and try to extract the payload.\n\nFirst, I opened the image in a hexeditor (i.e. HxD). The size of the full image is 156,005\nbytes. The last 118,762 bytes belong to the malware. So, we need remove the first 37,243\nbytes (156,005-118,762=37,243) in order to get the payload.\n\nThe appended part of the JPG\nThe payload does not look like a valid code, so it is probably obfuscated. Let’s try the easiest\noption first and see if there are any candidates for the XOR key. We can see that the payload\nhas padding at the end:\n\n\n-----\n\nLet’s try to apply the repeating character (in the given example it is 0xE5) as an XOR key.\n[This is the result (1953032199142ea8c5872107da8f2297):](https://malshare.com/sample.php?action=detail&hash=1953032199142ea8c5872107da8f2297)\n\nRepeating the experiment on various payloads, we can see that the result always start from\nthe keyword `!rcx . As we know from analyzing other elements of Hidden Bee, the authors`\n[of this malware decided to use various custom formats named after 64-bit Intel registers. We](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture)\nalso encountered packages starting from `!rbx and` `!rsi at different layers. So, this is the`\nfirst element in the chain that uses this convention.\n\nWhen we load the `!rcx module into IDA, we can confirm that it contains valid code. More`\ndetailed explanation about the `!rcx format will be given later on in this article.`\n\n**The PNG**\n\nLet’s have a look at a sample PNG, download from the “captcha.png” (URL format:\n```\n/images/captcha.png?mod=attachment&u=[unique_id] ):\n\n```\n\n-----\n\nAlthough it is a PNG in a valid format, it looks like noise. It probably represents bytes of\nsome encrypted data. An attempt of converting PNG to raw bytes didn’t give any readable\nresults. We need to analyze the code in order to discover what it hides.\n\n## Code analysis: the initial SWF file\n\nThe initial SWF file is embedded on the website and responsible for serving the exploit. If we\nlook inside it, we will not find anything malicious at first. However, among the binary data we\ncan find another suspicious WAV as an audio asset:\n\nThe beginning of the file:\n\nThis SWF file also contains a decoder for it:\n\n\n-----\n\nThe function “decode” takes four parameters. The first of them is the byte array containing\nthe WAV asset: That is the content to be decoded. The second argument is an MD5 (the\n“setup” function is an MD5 implementation) made of concatenation of the AppId and the\nAppToken: That is probably the encryption key. The third parameter is a salt (probably the\ninitialization vector of the crypto).\n\nThe salt is fetched from the HTML page, where the Flash component is embedded:\n\n\n-----\n\n**Alternative case: two WAV files**\n\nSometimes, rather than embedding the WAV containing the Flash exploit, authors use\nanother model of delivering it. They store the URL to the WAV, and then they retrieve the file.\n\nIn the below example, we can see how this model is applied to Hidden Bee. The salt, along\nwith the WAV URL, are both stored in the Javascript embedded in the HTML:\n\nThe Flash file first loads it and then decodes as the next step:\n\nLooking at the traffic capture, we can see that in this case, not one, but two WAV files are\ndownloaded:\n\n\n-----\n\nA case when two WAV files were downloaded (and none embedded in the Flash)\nThe algorithms used to encrypt the content of the first WAV may vary and sometimes the\nalgorithm is supplied as one of the parameters. After the content is fetched, the data from the\nWAV files is decoded using one of the available algorithms:\n\nWe can see that the expected content is a Flash file that is then loaded:\n\n**The “decode” function**\n\nThe function “decode” is imported from the package “com.google”:\n\n[The full decompiled code is available here.](https://gist.github.com/malwarezone/3aea44e1d4c66821f92b1092461fb815)\n\nWhen we look inside, we see that the code is slightly obfuscated:\n\n\n-----\n\nLooking at the decompiled code, we see some interesting constants. For example, –\n889275714 in hex is 0xCAFEBABE. As we found during analysis of other Hidden Bee\nelements, this DWORD was used by the same authors before as a magic number identifying\none of the custom formats.\n\nInternally, there are references to a function from another module:\nE_ENCRYPT_process_bytes(). Inside this function, we see calls suggesting that the Rabbit\nCipher has been used:\n\n\n-----\n\nRabbit uses a 128-bit key (the same length as the MD5 hash that was mentioned before)\nand a 64-bit initialization vector. (In different runs, a different encryption algorithm may be\nselected.)\n\nAfter the decoding process is complete, the revealed content is loaded:\n\n\n-----\n\n**The first WAV: a Flash exploit**\n\nThe decoded WAV contains a package with two elements embedded: a Flash file\n(movies.swf) and the configuration file (config.cfg). The decrypted data starts from the magic\nDWORD 0xCAFEBABE, which we noticed in the code of the previous SWF.\n\nThe Flash file (movies.swf) contains an embedded exploit. In the analyzed case, the exploit\n[used is CVE-2015-5122, however, a different exploit may be used on a different machine:](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5122)\n\nThe payload (shellcode) is stored in form of an array (binary version available here:\n[9aec11ff93b9df14f060f78fbb1b47a2):](https://malshare.com/sample.php?action=detail&hash=9aec11ff93b9df14f060f78fbb1b47a2)\n\n\n-----\n\nThe configuration file (config.cfg) contains the URL to another WAV file.\n\nThe payload is padded with NOP (0x90) bytes, and the parameters, including the\nconfiguration, are filled there before the payload runs.\n\nThe fragment of the code\n\nfeeding the configuration into the payload\n\n**The shellcode: downloading the second WAV**\n\nThe second WAV, in contrast to the first one, is always downloaded and never embedded. It\n[is retrieved by the “PayloadWin32” shellcode (9aec11ff93b9df14f060f78fbb1b47a2),](https://malshare.com/sample.php?action=detail&hash=9aec11ff93b9df14f060f78fbb1b47a2)\ndeployed after the successful exploitation.\n\nLooking inside this shellcode, we find the function that is responsible for downloading and\ndecrypting another WAV. The shellcode uses parameters that were filled by the previous\nlayer. This buffer contains the URL that will be queried and the key that will be used for\ndecryption of the payload. It loads functions from wininet.dll using their checksums. After the\ninitialization steps, it queries the supplied URL. The expected result is a buffer with a header\ntypical for WAV files.\n\n\n-----\n\nAs we already suspected, the data of the WAV (starting from the offset 0x2C) contains the\nencrypted content. Indeed, blocks that are 8 bytes long are decrypted in a loop:\n\nAfter the decryption is complete, the next module will be revealed. It is interesting to take a\nlook at the expected header of the payload to learn which format is used for the output\nelement. This time, the decoded data is supposed to start with the following magic numbers:\n0x01, 0x04, …, 0x10.\n\n\n-----\n\n**The second WAV: an executable in proprietary format**\n\nOn the illustration below, we can see how the data of the WAV looks after being decrypted\n[(9b37c9ec19a53007d450b9b9c8febbe2):](https://malshare.com/sample.php?action=detail&hash=9b37c9ec19a53007d450b9b9c8febbe2)\n\nThis is an executable component that is loaded into Internet Explorer. After it decodes the\nimports, it starts to look much more familiar:\n\nWe can see that it follows an analogical structure to the one described in last year’s article.\n\n\n-----\n\nThis module is first executed within Internet Explorer. Then, it creates another process\n(dllhost.exe) in a suspended state:\n\n[It injects its original copy there (769a05f0eddd6ef2ebdd13618b244758):](https://malshare.com/sample.php?action=detail&hash=769a05f0eddd6ef2ebdd13618b244758)\n\nThen it redirects execution to its loading function. Below, we can see the Entry Point of the\nimplanted module within dllhost.exe.\n\n\n-----\n\nA detailed analysis of the execution flow of this module and its format will be given later in\nthe article.\n\nAt this point, it is important to note that the dllhost.exe is the module that further downloads\nthe aforementioned images.\n\n## The modules with the custom format\n\n[The module with the custom format is analogous to the one described before. However, we](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)\ncan see that it has significantly evolved.\n\nThere are changes in the header, as well as improvements in the implementation.\n\n**Changes in the custom format**\n\n[The new header is similar to the previous one. The few details that have changed are: the](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/#)\nmagic number at the beginning (from 0x10000301 to 0x10000401), and the format in which\nthe DLLs are stored (the length of a DLL name has been added). That’s why we will refer to\nthis format as “0x10000401 format.”\n\nAnother change is that now the names of the DLLs are obfuscated by a simple XOR with 1\nbyte character. They are deobfuscated just before being loaded.\n\n\n-----\n\nSumming up, we can visualize the new format in the following way:\n\n\n-----\n\n**Obfuscation used**\n\nThis time, authors decide to obfuscate all the strings used inside the module. Now all the\nstrings are decoded just before use.\n\nExample: decoding the string before the use\n\nThe decoding algorithm is simple, based on XOR:\n\nThe string-decoding algorithm\n\n## Inside the images downloader\n\nLet’s look inside the first module in the 0x10000401 format that we encountered. This\nmodule is an initial stage, and its role is to download and unpack the other components. One\nsuch component is in a CAB format (that’s why we can see the Cabinet.dll among the\nimported DLLs).\n\nThe role of this module is similar to the first “WASM” mentioned in our post a year ago.\nHowever, the current version is not only better protected, but also comes with some\nimprovements. This time the downloaded content is hidden in the images. So, analyzing this\nelement can help us to understand how the used stenography works.\n\nFirst, we can see that the URLs are retrieved from their Base64 form:\n\n\n-----\n\nThis string decodes to a list containing URLs of the PNG and JPG files that are going to be\ndownloaded. For each sample, this set is unique. None of the URLs can be reused: the\nserver gives a response only once. An example of a URL set:\n```\nhttp://38.75.137.9:9088/pubs/wiki.php?id=937a4eadd6f5a94b3738a58dcc79ca13\nhttp://38.75.137.9:9088/images/captcha.png?\nmod=attachment&u=357e27e8af72925144ec1db2421d0cc5&lt\nhttp://38.75.137.9:9088/views/q5ul78uv4b4q8bg8d95canrsns.jpg\n\n```\nSo, we can confirm that this module is the one responsible for downloading and processing\nthe observed images. Indeed, inside we can find the functions responsible for their decoding.\n\n**Decoding the JPG**\n\nAfter the payload is retrieved, the JPG header is validated.\n\nThen, the payload is decoded by simply using an XOR with the last byte. The decoded\ncontent is expected to start from the !rcx magic ID.\n\n\n-----\n\nAfter decoding the content, the hash of the !rcx module is validated with the help of SHA256\nhash. The valid hash is stored in the module’s header and compared with the calculated\nhash of the file content.\n\n\n-----\n\nIf the validation passed, the shellcode stored in the !rcx module is loaded. More details about\nthe execution flow will be given later.\n\nThe !rcx package has a simple header:\n\n**Decoding the PNG**\n\nRetrieving the content from the PNG is more complex.\n\n“captcha.png” – the encrypted CAB file\n\nFirst, after downloading, the PNG header is checked:\n\n\n-----\n\nThe function decoding the PNG has the following flow:\n\n[It converts the PNG into byte content and decrypts it with the help of ARIA cipher. The result](https://en.wikipedia.org/wiki/ARIA_(cipher))\nshould be a CAB format. The unpacked CAB is supposed to contain a module\n“bin/i386/core.sdb” that also occurred in our previous encounters with Hidden Bee.\n\n\n-----\n\nThe authors are careful not to reuse URLs as well as encryption keys. That s why the Aria\nkey is different for every unique payload. It is stored just after the end of the 0x10000401\nmodule :\n\nKey\n\nformat: WORD key length; BYTE key_bytes[];\nDuring the module’s loading, the key is rewritten into another memory area, from which it is\nused to decrypt the downloaded module.\n\nThe CAB file retrieved from the PNG is available here:\n[001bdc26b2845dcf839f67a8760c6839](https://malshare.com/sample.php?action=detail&hash=001bdc26b2845dcf839f67a8760c6839)\n\n[It contains core.sdb (d1a2fdc79c154b120a0e52c46a73478d). That is a second module in](https://malshare.com/sample.php?action=detail&hash=d1a2fdc79c154b120a0e52c46a73478d)\nHidden Bee’s custom format.\n\n\n-----\n\n## Inside core.sdb\n\nThis module (retrieved from the PNG) is a second downloader component in the\n0x10000401 format. This time, it uses a custom TCP-based protocol, referenced by the\nauthors as SLTP. (This protocol was also used by the analogical component seen one year\nago). The embedded links:\n```\nsltp://dns.howtocom.site:1108/minimal.bin?id=998\nsltp://bbs.favcom.space:1108/setup.bin?id=999\n\n```\n**Execution flow**\n\n1. Checks for blacklisted processes. If any are detected, exits.\n2. Removes functions: `DbgBreakPoint,` `DbgUserBreakPoint by overwriting their`\n\nbeginning with the RET instruction.\n3. Checks if the malware is already installed. If yes, exits.\n4. Creates an installation mutex `{71BB7F1C-D700-4487-B9C6-6DD9863DFE91}-ins.`\n5. If the module was run with the flag==1:\n\n1. Connects to the first address:\n```\n      sltp://dns.howtocom.site:1108/minimal.bin?id=998\n\n```\n2. Sets an environment variable `INSTALL_SOURCE to the value given as an`\n\nargument.\n3. Runs the downloaded next stage module.\n6. If the module was run with the flag!=1:\n\n1. Performs checks against VM. If detected, exits.\n2. Connects to the second address:\n```\n      sltp://bbs.favcom.space:1108/setup.bin?id=999 . This time, appends the\n\n```\nvictim’s fingerprint to the URL. Format: `<URL>&sid=<INSTALL_SID>&sz=<unique`\n```\n      machine ID: 16 bytes hex>&os=<Windows version number>&ar=\n      <architecture>\n\n```\n3. Runs the downloaded next stage module.\n\n\n-----\n\n**Defensive checks**\n\nAt this stage, many anti-analysis checks are deployed. First, there are checks to detect if any\nof the blacklisted processes are running. The enumeration of the processes is implemented\nusing a low-level function: `NtQuerySystemInformation with a parameter 5`\n( SystemProcessInformation ).\n\nThe blacklist contains popular debuggers and sniffers:\n\n“devenv.exe”, “wireshark.exe”, “vmacthlp.exe”, “procmon.exe”, “ollydbg.exe”, “idag.exe”,\n“ImmunityDebugger.exe”, “windbg.exe”\n\n“EHSniffer.exe”, “iris.exe”, “procexp.exe”, “filemon.exe”, “fiddler.exe”\n\nThe names of the processes are obfuscated, so they are not visible on the strings list. If any\nof those processes are detected, the execution of the module terminates.\n\nAnother function deploys a set of anti-VM checks. The anti-VM checks include:\n\n\n-----\n\n[CPUID with EAX=40000000 (a check for Hypervisor’s Brand):](https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/)\n\n[The VMWAre I/O Port (more details [here]):](https://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf)\n\n[VPCEXT instruction (more details [here])](https://shasaurabh.blogspot.com/2017/07/virtual-machine-detection-techniques.html)\n\n[Checking the list of common VM vendors:](https://wiki.osdev.org/CPUID)\n\n\n-----\n\nChecking the BIOS versions typical for virtual environments:\n\nDetection of any of the features suggesting a VM results in termination of the component.\n\n**Downloading new modules**\n\n\n-----\n\nThe next elements of HiddenBee are downloaded over the custom “STLP” protocol.\n\nThe raw TCP socket created to communicate using the SLTP protocol:\n\nThe communication is encrypted. We can see that the expected output is a shellcode that is\nloaded and executed:\n\n\n-----\n\nThe way in which it is loaded reminds me of the elements we described recently in “Hidden\nBee: Let’s go down the rabbit hole“. The current module loads a list of functions that will be\npassed to the next module. It is a minimalistic, custom version of Import Table. It also passes\nthe memory with the downloaded filesystem to be used for further loading of components.\n\n## The !rcx package\n\nThis element retrieves the custom filesystem used by this malware. As we know from\nprevious analysis, Hidden Bee uses its own, custom filesystems that are mounted in the\nmemory of the malware and passed to its components. This filesystem is important for the\nexecution flow because it contains many other components that are supposed to be installed\non the attacked system in order to continue the infection.\n\nAs mentioned before, unpacking the JPG gave us an !rcx package. After this package is\ndownloaded, and its SHA256 checksum is validated, it is repackaged. First, at the end of the\n!rcx package, the list of URLs (JPG, PNG) from the previous module is copied. Then, the\nARIA key is copied. The size of the module and its SHA256 hash are updated. Then, the\nexecution is redirected to the first stage shellcode fetched from the !rcx.\n\n\n-----\n\nThis shellcode was the one that we saw at first, after decoding the !rcx package from the\nJPG. Yet, looking at this part, we do not see anything malicious. The elements that are more\nimportant are well protected and revealed at the next execution stages.\n\nThe shellcode from the !rcx package is executed in two stages. The first one unpacks and\nprepares the second. First, it loads its own imports using hardcoded names of libraries.\n\nThe checksums of the functions that are going to be used are stored in the module and\ncompared with the names calculated by the function:\n\nThe checksum calculation\n\nalgorithm\nIt uses the functions from kernel32.dll: GetProcessHeap, VirtualAlloc, VirtualFree, and from\nntdll.dll: RtlAllocateHeap, RtlFreeHeap, NtQueryInformationProcess.\n\nThe repackaged !rcx module is supposed to be supplied as one of the arguments at the\nEntry Point of the first shellcode. It is most important because the second stage shellcode\nwill be unpacked from the supplied !rcx package.\n\n\n-----\n\nChecking the !rcx magic (first stage shellcode)\n\nA new memory area is allocated, and the second stage shellcode is unpacked there.\n\nDecoding and calling next module\nInside the second shellcode, we see strings referencing further components of the Hidden\nBee malware:\n\n```\n/bin/i386/preload\n\n```\n```\n/bin/i386/coredll.bin\n\n```\n\nThe role of the second stage is unpacking another part from the !rcx: an !rdx package.\n\n\n-----\n\nChecking the !rdx magic (second stage\n\nshellcode)\nFrom our previous experience, we know that the !rdx package is a custom filesystem\ncontaining modules. Indeed, after the decryption is complete, the custom filesystem is\nrevealed:\n\n\n-----\n\nSo the part that was hidden in the JPG is, in reality, a package that decrypts the custom\nfilesystem and deploys the next stage modules: `/bin/i386/preload and`\n```\n/bin/i386/coredll.bin . This filesystem has even more elements that are loaded at later\n\n```\nstages of the infection. Their full functionality will be described in the next article in our\nseries.\n\n## Even more hidden\n\n\n-----\n\nFrom the beginning, Hidden Bee malware has been well designed and innovative. Looking at\none year of its evolution, we can be sure that the authors are serious about making it even\nmore stealthy—and they don’t stop improving it.\n\nAlthough the initial dropper uses components analogous to ones observed in the past,\nrevealing their encrypted content now takes many more steps and much more patience. The\nadditional difficulty in the analysis is introduced by the fact that the URLs and encryption\nkeys are never reused, and work only for a single session.\n\nThe team behind this malware is skilled and determined. We expect that the Hidden Bee\nmalware won’t be going extinct anytime soon.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-15 - The Hidden Bee infection chain, part 1- the stegano pack.pdf"
    ],
    "report_names": [
        "2019-08-15 - The Hidden Bee infection chain, part 1- the stegano pack.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535630,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1653705172,
    "ts_modification_date": 1653705172,
    "files": {
        "pdf": "https://archive.orkl.eu/9233e630e5cc0474aa532b280781b862343c3cb5.pdf",
        "text": "https://archive.orkl.eu/9233e630e5cc0474aa532b280781b862343c3cb5.txt",
        "img": "https://archive.orkl.eu/9233e630e5cc0474aa532b280781b862343c3cb5.jpg"
    }
}