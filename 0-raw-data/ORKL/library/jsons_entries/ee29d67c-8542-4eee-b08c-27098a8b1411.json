{
    "id": "ee29d67c-8542-4eee-b08c-27098a8b1411",
    "created_at": "2023-01-12T15:05:16.39162Z",
    "updated_at": "2025-03-27T02:16:39.916759Z",
    "deleted_at": null,
    "sha1_hash": "d46f508accffe761007c2d7cf7242f9040016ff9",
    "title": "2021-07-27 - Collecting and operationalizing threat data from the Mozi botnet",
    "authors": "",
    "file_creation_date": "2022-05-28T23:14:06Z",
    "file_modification_date": "2022-05-28T23:14:06Z",
    "file_size": 2577334,
    "plain_text": "# Collecting and operationalizing threat data from the Mozi botnet\n\n**[elastic.co/blog/collecting-and-operationalizing-threat-data-from-the-mozi-botnet](https://www.elastic.co/blog/collecting-and-operationalizing-threat-data-from-the-mozi-botnet)**\n\nJuly 27, 2021\n\nDetecting and preventing malicious activity such as botnet attacks is a critical area of focus\nfor threat intel analysts, security operators, and threat hunters. Taking up the Mozi botnet as\na case study, this blog post demonstrates how to use open source tools, analytical\nprocesses, and the Elastic Stack to perform analysis and enrichment of collected data\nirrespective of the campaign. This will allow you to take the lessons and processes outlined\nbelow to your organization and apply them to your specific use cases.\n\nThe Mozi botnet has been leveraging vulnerable Internet of Things (IoT) devices to launch\ncampaigns that can take advantage of the force multiplication provided by a botnet\n(Distributed Denial of Service (DDoS), email spam, brute-force, password spraying, etc.).\n[Mozi was first reported by the research team at 360Netlab in December 2019 and has](https://blog.netlab.360.com/mozi-another-botnet-using-dht/)\ncontinued to make up a large portion of IoT network activity across the Internet-at-large.\n\nAs reported by 360Netlab, the botnet spreads via the use of weak and default remote access\npasswords for targeted devices as well as through multiple public exploits. The Mozi botnet\ncommunicates using a Distributed Hash Table (DHT) which records the contact information\nfor other nodes in the botnet. This is the same serverless mechanism used by file sharing\n\n\n-----\n\npeer-to-peer (P2P) clients. Once the malware has accessed a vulnerable device, it executes\nthe payload and subsequently joins the Mozi P2P network. The newly infected device listens\nfor commands from controller nodes and also attempts to infect other vulnerable devices.\n\nMozi targets multiple IoT devices and systems, mainly focused on Small Office Home Office\n(SOHO) networking devices, Internet-connected audio visual systems, and theoretically any\n32-bit ARM device.\n\n## Collection\n\nWhen performing data analysis, the more data that you have, the better. Analysis of malware\ncampaigns are no different. With a paid subscription to VirusTotal, you can collect huge\namounts of data for analysis, but we wanted an approach for independent researchers or\nsmaller organizations that may not have this premium service. To do that, we decided to\nkeep to our roots at Elastic and leverage open source datasets to avoid a paywall that could\nprevent others from using our processes.\n\n[To begin, we started with a handful of Mozi samples collected from ThreatFox. ThreatFox is](https://threatfox.abuse.ch/browse.php?search=tag%3Amozi)\n[an open source platform from Abuse.ch with the goal of sharing malware indicators with the](https://abuse.ch/)\nsecurity research community.\n\nUsing cURL, we queried the ThreatFox API for the `Mozi tag. This returned back JSON`\ndocuments with information about the malware sample, based on the tagged information.\n```\ncurl -X POST https://threatfox-api.abuse.ch/api/v1/ -d '{ \"query\": \"taginfo\", \"tag\":\n\"Mozi\", \"limit\": 1 }'\n\n```\nCode block 1 - cURL request to ThreatFox API\n```\n   -X POST - change the cURL HTTP method from GET (default) to POST as we’re\n\n```\ngoing to be sending data to the ThreatFox API\n```\n   https://threatfox-api.abuse.ch/api/v1/ - this is the ThreatFox API endpoint\n   -d - this is denoting that we’re going to be sending data\n   query: taginfo - the type of query that we’re making, taginfo in our example\n   tag: Mozi - the tag that we’ll be searching for, “Mozi” in our example\n\n```\nlimit: 1 - the number of results to return, 1 result in our example, but you can return up\nto 1000 results\n\nThis returned the following information:\n\n\n-----\n\n```\n{\n  \"query_status\": \"ok\", \n  \"data\": [ \n    { \n      \"id\": \"115772\", \n      \"ioc\": \"nnn.nnn.nnn.nnn:53822\", \n      \"threat_type\": \"botnet_cc\", \n      \"threat_type_desc\": \"Indicator that identifies a botnet command&control\nserver (C&C)\", \n      \"ioc_type\": \"ip:port\", \n      \"ioc_type_desc\": \"ip:port combination that is used for botnet\nCommand&control (C&C)\", \n      \"malware\": \"elf.mozi\", \n      \"malware_printable\": \"Mozi\", \n      \"malware_alias\": null, \n      \"malware_malpedia\":\n\"https:\\/\\/malpedia.caad.fkie.fraunhofer.de\\/details\\/elf.mozi\", \n      \"confidence_level\": 75, \n      \"first_seen\": \"2021-06-15 08:22:52 UTC\", \n      \"last_seen\": null, \n      \"reference\":\n\"https:\\/\\/bazaar.abuse.ch\\/sample\\/832fb4090879c1bebe75bea939a9c5724dbf87898febd425f9\n      \"reporter\": \"abuse_ch\", \n      \"tags\": [ \n        \"Mozi\" \n      ] \n    } \n  ]\n\n```\nCode block 2 - Response from ThreatFox API\nNow that we have the file hashes of several samples, we can download the samples using\nthe Malware Bazaar API. Malware Bazaar is another open source platform provided by\nAbuse.ch. While ThreatFox is used to share contextual information about indicators, Malware\nBazaar allows for the actual collection of malware samples (among other capabilities).\n\nJust like with ThreatFox, we’ll use cURL to interact with the Malware Bazaar API, but this\ntime to download the actual malware samples. Of note, the Malware Bazaar API can be used\nto search for samples using a tag (“Mozi”, in our example), similar to how we used the\nThreatFox API. The difference is that the ThreatFox API returns network indicators that we’ll\nuse later on for data enrichment.\n```\ncurl -X POST https://mb-api.abuse.ch/api/v1 -d\n'query=get_file&sha256_hash=832fb4090879c1bebe75bea939a9c5724dbf87898febd425f94f7e03ee\n -o 832fb4090879c1bebe75bea939a9c5724dbf87898febd425f94f7e03ee687d3b.raw\n\n```\n_Code block 3 - cURL request to Malware Bazaar API_\n```\n   -X POST - change the cURL HTTP method from GET (default) to POST as we’re\n\n```\ngoing to be sending data to the Malware Bazaar API\n```\n   https://mb-api.abuse.ch/api/v1 - this is the Malware Bazaar API endpoint\n\n```\n\n-----\n\n```\n   -d - this is denoting that we re going to be sending data\n   query: get_file - the type of query that we’re making, get_file in our example\n   sha256_hash - the SHA256 hash we’re going to be collecting,\n   “832fb4090879c1bebe75bea939a9c5724dbf87898febd425f94f7e03ee687d3b” in\n\n```\nour example\n```\n   -o - the file name we’re going to save the binary as\n\n```\nThis will save a file locally named\n```\n832fb4090879c1bebe75bea939a9c5724dbf87898febd425f94f7e03ee687d3b.raw . We\n\n```\nwant to make a raw file that we’ll not modify so that we always have an original sample for\narchival purposes. This downloads the file as a Zip archive. The passphrase to extract the\narchive is infected. This will create a local file named\n```\n832fb4090879c1bebe75bea939a9c5724dbf87898febd425f94f7e03ee687d3b.elf . Going\n\n```\nforward, we’ll use a shorter name for this file, `truncated-87d3b.elf, for readability.`\n\n### Unpacking\n\nNow that we have a few samples to work with we can look at ripping out strings for further\n[analysis. Once in our analysis VM we took a stab at running Sysinternals Strings over our](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)\nsample:\n```\n$ strings truncated-87d3b.elf \nELF \n*UPX! \nELF \n$Bw \n(GT \n...\n\n```\nCode block 3 - Strings output from the packed Mozi sample\n[Right away we see that we have a UPX packed ELF binary from the “ELF” and “UPX!” text.](https://upx.github.io/)\nUPX is a compression tool for executable files, commonly known as “packing”. So the next\nlogical step is to decompress the ELF file with the UPX program. To do that, we’ll run upx\nwith the `-d switch.`\n```\n$ upx -d truncated-87d3b.elf \n            Ultimate Packer for eXecutables \n             Copyright (C) 1996 - 2020 \nUPX 3.96w Markus Oberhumer, Laszlo Molnar & John Reiser Jan 23rd 2020 \n    File size     Ratio   Format   Name \n  --------------------  ------  -----------  ----------- \nupx.exe : upx: truncated-87d3b.elf : CantUnpackException: p_info corrupted\n\n```\nCode block 4 - UPX output from corrupted Mozi sample\nAnother road-block: the `p_info section of the file appears to be corrupted. p_info is the`\nsum of two sections from a file, `p_blocksize and` `p_filesize . After a quick search for`\n[the error message, we landed on a CUJOAI Anti-Unpacking blog explaining the header](https://cujo.com/upx-anti-unpacking-techniques-in-iot-malware/)\n\n\n-----\n\ncorruptions commonly used in IoT malware to disrupt automated analysis tools.\n\n[Using this information, we cracked open our binary in xxd, a HEX dumper, to see which](https://linux.die.net/man/1/xxd)\ncorruption we were dealing with. As described in the CUJOAI blog, the `p_info blocks`\nrepresent the sum of the `p_filesize blocks and the` `p_blocksize blocks. This section`\nbegins with the 8 bytes after the `UPX! text, and has been overwritten with zeros (the 8`\nbytes starting at `0x84 ).`\n```\n$ xxd truncated-87d3b.elf\n00000000: 7f45 4c46 0101 0161 0000 0000 0000 0000 .ELF...a........\n00000010: 0200 2800 0100 0000 1057 0200 3400 0000 ..(......W..4...\n00000020: 0000 0000 0202 0000 3400 2000 0200 2800 ........4. ...(.\n00000030: 0000 0000 0100 0000 0000 0000 0080 0000 ................\n00000040: 0080 0000 0de0 0100 0de0 0100 0500 0000 ................\n00000050: 0080 0000 0100 0000 b07a 0000 b0fa 0600 .........z......\n00000060: b0fa 0600 0000 0000 0000 0000 0600 0000 ................\n00000070: 0080 0000 10f1 8f52 5550 5821 1c09 0d17 .......RUPX!....\n00000080: 0000 0000 0000 0000 0000 0000 9400 0000 ................\n00000090: 5e00 0000 0300 0000 f97f 454c 4601 7261 ^.........ELF.ra\n000000a0: 000f 0200 28dd 0001 0790 b681 0334 ee07 ....(........4..\n000000b0: ec28 04db 1302 0bfb 2000 031b be0a 0009 .(...... .......\n...\n\n```\nCode block 5 - HEX view of the corrupted Mozi sample\nThe CUJOAI blog states that if you manually update the values of the `p_filesize blocks`\nand the `p_blocksize blocks with the value of the` `p_info, this will fix the corruption`\nissue. Below we can see the `p_info section in HEX, and we can use that to manually`\nupdate the `p_filesize and` `p_blocksize sections, which will allow us to unpack the`\nbinary (the 4 bytes starting at `0x1e110 ).`\n```\n$ xxd truncated-87d3b.elf\n...\n0001e0c0: 1914 a614 c998 885d 39ec 4727 1eac 2805 .......]9.G'..(.\n0001e0d0: e603 19f6 04d2 0127 52c9 9b60 00be 273e .......'R..`..'>\n0001e0e0: c00f 5831 6000 0000 0000 90ff 0000 0000 ..X1`...........\n0001e0f0: 5550 5821 0000 0000 5550 5821 0d17 0308 UPX!....UPX!....\n0001e100: 5199 6237 591c 321c d001 0000 b800 0000 Q.b7Y.2.........\n0001e110: 7c2a 0400 5000 0011 8000 0000      |*..P.......\n\n```\nCode block 6 - p_info HEX data from the corrupted Mozi sample\nFirst, let’s open the file with Vim. As we can see, it is just a UPX file as denoted by the UPX!.\n```\n$ vim truncated-87d3b.elf\n^?ELF^A^A^Aa^@^@^@^@^@^@^@^@^B^@(^@^A^@^@^@^PW^B^@4^@^@^@^@^@^@^@^B^B^@^@4^@\n^@^B^@(^@^@^@^@^@^A^@^@^@^@^@^@^@^@<80>^@^@^@<80>^@^@^Mà^A^@^Mà^A^@^E^@^@^@^@<80>^@^@^\n\n```\nCode block 7 - Corrupted Mozi sample in Vim\n\n\n-----\n\nUsing the xxd plugin for Vim, we can convert this to HEX so that we can make our\nmodifications. This is achieved by typing `:%!xxd, which will show us the HEX output for the`\nfile.\n```\n00000000: 7f45 4c46 0101 0161 0000 0000 0000 0000 .ELF...a........\n00000010: 0200 2800 0100 0000 1057 0200 3400 0000 ..(......W..4...\n00000020: 0000 0000 0202 0000 3400 2000 0200 2800 ........4. ...(.\n00000030: 0000 0000 0100 0000 0000 0000 0080 0000 ................\n00000040: 0080 0000 0de0 0100 0de0 0100 0500 0000 ................\n00000050: 0080 0000 0100 0000 b07a 0000 b0fa 0600 .........z......\n00000060: b0fa 0600 0000 0000 0000 0000 0600 0000 ................\n00000070: 0080 0000 10f1 8f52 5550 5821 1c09 0d17 .......RUPX!....\n00000080: 0000 0000 0000 0000 0000 0000 9400 0000 ................\n00000090: 5e00 0000 0300 0000 f97f 454c 4601 7261 ^.........ELF.ra\n000000a0: 000f 0200 28dd 0001 0790 b681 0334 ee07 ....(........4..\n000000b0: ec28 04db 1302 0bfb 2000 031b be0a 0009 .(...... .......\n\n```\nCode block 8 - Corrupted Mozi sample in Vim with XXD plugin\nNext, we can just update bytes `0x84 - 0x8b (that we identified as having the zero’d out`\n```\np_filesize and p_blocksize ) with the HEX value for p_info ( 7c2a 0400 ).\n00000080: 0000 0000 7c2a 0400 7c2a 0400 9400 0000 ....|*..|*......\n\n```\nCode block 9 - Updated p_filesize and p_blocksize HEX values\nLet’s reset the file back using `:%!xxd -r, save the file and exit Vim ( :wq ).`\n\nFinally, let’s try to unpack the file now that we’ve manually adjusted the HEX values.\n```\n$ upx -d truncated-87d3b.elf\n            Ultimate Packer for eXecutables\n             Copyright (C) 1996 - 2020\nUPX 3.96    Markus Oberhumer, Laszlo Molnar & John Reiser  Jan 23rd 2020\n    File size     Ratio   Format   Name\n  --------------------  ------  -----------  ----------  273020 <-  123165  45.11%  linux/arm  truncated-87d3b.elf\nUnpacked 1 file.\n\n```\nCode block 10 - Successfully unpacked Mozi sample\nWe now have successfully unpacked the file. Let’s check to see what kind of file this is now\nby using the `file command.`\n```\n$ file truncated-87d3b.elf\ntruncated-87d3b.elf: ELF 32-bit LSB executable, ARM, version 1 (ARM), statically\nlinked, stripped\n\n```\nCode block 11 - File type identification of the Mozi sample\nNow, we can again use the strings command to see if there is any useful information that we\ncan use (truncated for readability).\n\n\n-----\n\n```\n$ strings truncated 87d3b.elf\n...\niptables -I OUTPUT -p udp --source-port %d -j ACCEPT\niptables -I PREROUTING -t nat -p udp --destination-port %d -j ACCEPT\niptables -I POSTROUTING -t nat -p udp --source-port %d -j ACCEPT\niptables -I INPUT -p udp --dport %d -j ACCEPT\niptables -I OUTPUT -p udp --sport %d -j ACCEPT\niptables -I PREROUTING -t nat -p udp --dport %d -j ACCEPT\niptables -I POSTROUTING -t nat -p udp --sport %d -j ACCEPT\n0.0.0.0\n[idp]\nThis node doesn't accept announces\nv2s\ndht.transmissionbt.com:6881\nrouter.bittorrent.com:6881\nrouter.utorrent.com:6881\nbttracker.debian.org:6881\nnnn.nnn.nnn.nnn:6881\nabc.abc.abc.abc:6881\nxxx.xxx.xxx.xxx:6881\nyyy.yyy.yyy.yyy:6881\nNfZ\nOo~Mn\ng5=\nN]%\nRange: bytes=\nUser-Agent: \n...\n\n```\nCode block 12 - Strings output from the unpacked Mozi sample\nRunning Strings, we can see, among other things, network indicators and changes to the\nlocal firewall, `iptables . There is a lot of great information in this file that we can now`\nreview which can be used to search for infected devices.\n\nNext, let’s enrich the ThreatFox data, store it in Elasticsearch, and visualize it with Kibana.\n\n## Storing threat data in the Elastic Stack\n\nLooking at what we’ve collected so far, we have rich threat data provided by ThreatFox that\nincludes both network and file information. Additionally, we have actual malware samples\ncollected from Malware Bazaar. Finally, we have performed static file analysis on the\nmalware to identify additional indicators that could be of use.\n\nFor the next steps, we’re going to parse the data from ThreatFox and store that in the Elastic\nStack so that we can leverage Kibana to visualize data to identify clusters of activity.\n\n### Create the Ingest Node Pipeline\n\n\n-----\n\nWe re going to create an Ingest Node Pipeline to transform the data from ThreatFox into\nenriched Elasticsearch data. When making a pipeline, it's useful to make a table to lay out\nwhat we're going to do.\n\n**ThreatFox field** **ECS-style field**\n```\n id event.id\n ioc threat.indicator.ip and threat.indicator.port\n threat_type threat.software.type\n threat_type_desc threat.indicator.description\n ioc_type threat.indicator.type. Set threat.indicator.type\n               to \"ipv4-addr\"\n malware threat.software.name\n malware_printable threat.threatfox.malware_printable\n malware_alias threat.software.alias (if non-null)\n malware_malpedia threat.software.reference\n confidence_level threat.indicator.confidence\n first_seen threat.indicator.first_seen\n last_seen threat.indicator.last_seen\n reference event.reference\n reporter event.provider\n tags tags\n\n```\n\n-----\n\n```\n <enrichment> threat.indicator.geo. Enriched by our geoip\n               processor.\n <parsed-sha256> file.hash.sha256 and related.hash\n <copy related.ip\n threat.indicator.ip>\n\n```\nTable 1 - Elasticsearch Ingest Node Pipeline for ThreatFox data\nTo create the pipeline, go to Kibana Stack Management -> Ingest Node Pipelines, then\nclick Create pipeline.\n\nFigure 1 - Creating Ingest Node Pipeline for ThreatFox data\nNext, we’ll give our pipeline a name, optionally a version, and a description.\n\nFrom this view you can manually add processors and configure them to your liking. To give\n[you a head start, we've provided the ThreatFox pipeline definition here you can paste in.](https://github.com/elastic/examples/blob/master/blog/mozin-about/ingest-node-pipeline.json)\n\n[Click Import processors and paste the contents of this pipeline definition: pipeline.json.](https://github.com/elastic/examples/blob/master/blog/mozin-about/ingest-node-pipeline.json)\n\nWhen you click Load and overwrite, you'll have each processor listed there as we've\nconfigured it. From here you can tweak it to your needs, or just scroll down and click Create\n**pipeline.**\n\n\n-----\n\nFigure 2 - Ingest Node Processors for ThreatFox data\n[Alternatively, if you’d like to use a turnkey approach, the collection.sh script will allow you to](https://github.com/elastic/examples/blob/master/blog/mozin-about/collection.sh)\ncollect the ThreatFox Mozi data, create the Elasticsearch ingest pipeline, the indicators\nIndex, the Index Pattern, and send the data from ThreatFox directly into Elasticsearch.\n```\n$ git clone https://github.com/elastic/examples\n$ cd examples/blog/mozin-about\n$ sh collection.sh\n\n```\nCode block 13 - Using the Mozi sample collection script\nUsing the provided collection script, we can see the Threat Fox data is converted into the\nElastic Common Schema (ECS) and sent to Elasticsearch for analysis.\n\n\n-----\n\nFigure 3 - ThreatFox data in Kibana\n\n## Analysis\n\nNow that we’ve collected our samples, enriched them, and stored them in Elasticsearch, we\ncan use Kibana to visualize this data to identify clusters of activity, make different\nobservations, and set up different pivots for new research.\n\nAs a few quick examples, we can identify some ports that are used and countries that are\nincluded in the dataset.\n\nLet’s start with identifying high-density network ports. Make a Lens visualization in Kibana by\nclicking on Visualization Library → Create visualization → Lens. We can make a simple\ndonut chart to highlight that the `threat indicator port of 6000 makes up over 10% of`\n\n\n-----\n\nthe network ports observed. This could lead us to explore other network traffic that is using\nport `6000 to identify other potentially malicious activity.`\n\nFigure 4 - Port layout for Mozi network traffic\nOf note, port `0 and` `4000 are also observed and are interesting. Ports` `6000,` `4000, nor`\n```\n0 are overly common on the Internet-at-large and could be used to identify other\n\n```\ncompromised hosts. It should be noted that while transient network indicators like IP and port\nare useful, they should not be used as the sole source to identify malicious activity\nirrespective of the intrusion set being investigated.\n\nNext, we can use a Kibana Maps visualization to identify geographic clusters of activities,\nand include associated context such as indicator confidence, provider, and type.\n\n\n-----\n\nFigure 5 - Geographic data from Mozi command & control infrastructure\nSimilar to the commentary above on IP and ports, geographic observations should not be the\nsole source used to take action. These are simply indicators for observed samples and\nrequire organizational-centric analysis to ascertain their meaning as it relates to the specific\nnetwork.\n\nThis is useful information we can make the following analytical assertions based on our\nsampling:\n\nMozi botnet is currently active and maintaining steady infection rates\nPort 6000 is a dominant port used for command & control\nAt least 24 countries impacted suggests global threat with no specific targeting\nClusters of specific ASNs in Bulgaria and India stand out with highest volumes\n\nAs the analysis process starts to flow, it ends up providing additional avenues for research.\nOne example an analyst may pursue is a propagation mechanism through the use of HTTP\nfingerprinting.\n\n### Exploring the propagation mechanism\n\n\n-----\n\nIn the same manner as criminal fingerprints are tracked and logged in a database, a similar\ntechnique can be applied to publicly facing network infrastructure. An HTTP request can be\nsent to a webserver and the HTTP response that is returned can be used to identify possible\nweb applications hosted on the server; even the ordering of the fields in the HTTP response\ncan be used as an identifier.\n\nOne thing we learned about Mozi and how it contributes to its spreading power is that each\ncompromised device contributes to the infection of future victims. The compromised device\nstarts an HTTP server that hosts a Mozi payload on a random TCP port. Knowing this\ninformation, we can collect content from an infected system to generate a fingerprint using\ncURL.\n```\ncurl -I nnn.nnn.nnn.nnn:53822\nHTTP/1.1 200 OK\nServer: nginx\nContent-Length: 132876\nConnection: close\nContent-Type: application/zip\n\n```\nCode block 14 - HTTP response from a compromised device\nBased on the observed response back, we can pull back some interesting information such\nas:\n\nThe use of an NGINX web server\nNo HTTP Date Header provided\nThe size of the file returned is close to 133 kilobytes\n\nWith this small amount of data, we can pivot to different search engines that store response\n[data from these kinds of devices all over the world. By leveraging tools like Shodan, we can](https://www.shodan.io/)\nperform a search using the information obtained in the HTTP response. We’ll wildcard the\nContent-Length but use the same order for all of the HTTP response elements:\n```\nHTTP/1.1 200 OK Server: nginx Content-Length: * Connection: close Content-Type:\napplication/zip\n\n```\nCode block 15 - HTTP header for Mozi propagation\nWe can see a number of hits where this same response was captured on other devices and\nstart to pinpoint additional machines. Below are a few examples from a Shodan search:\n\n\n-----\n\nFigure 6 - Additional impacted devices\nOther search examples over response data could be used as well such as the actual bytes of\nthe malicious Mozi file that was returned in the response.\n\n\n-----\n\n## Mitigation\n\nThe Mozi botnet propagates through the abuse of default or weak remote access passwords,\nexploits and outdated software versions. To defend devices from exploitation, we\nrecommend:\n\nChanging the device default remote access passphrases\nUpdating devices to the latest firmware and software version supported by the vendor\nSegmenting IoT devices from the rest of your internal network\nNot making IoT devices accessible from the public Internet\n\n## Detection logic\n\nUsing [YARA, we can write a signature for the corrupted UPX header. Similar to rules that](https://virustotal.github.io/yara/)\nlook for specific types of PowerShell obfuscation, the obfuscation mechanism itself can\noccasionally be a better indicator of maliciousness than attempting to signature the\nunderlying activity. It is extremely important to note that zeroing out part of the header\nsections was the technique that we observed with our samples. There are a litany of other\nobfuscation and anti-analysis techniques that could be used with other samples. MITRE\n[ATT&CK® describes additional subtechniques for the Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027/)\n[technique from the Defense Evasion tactic.As noted above, the observed anti-analysis](https://attack.mitre.org/tactics/TA0005)\ntechnique used by the analyzed Mozi samples consists solely of zeroing out the 8 bytes after\nthe “UPX!” magic bytes, and the 4 bytes before that are always zero, so let's use a YARA\n[signature derived from the work by Lars Wallenborn (expanded for readability).](https://blag.nullteilerfrei.de/2019/12/26/upx-packed-elf-binaries-of-the-peer-to-peer-botnet-family-mozi/)\n```\nrule Mozi_Obfuscation_Technique\n{\n meta:\n  author = \"Elastic Security, Lars Wallenborn (@larsborn)\"\n  description = \"Detects obfuscation technique used by Mozi botnet.\"\n strings:\n  $a = { 55 50 58 21\n      [4]\n      00 00 00 00\n      00 00 00 00\n      00 00 00 00 }\n condition:\n  all of them\n}\n\n```\nCode block 16 - YARA signature detecting Mozi obfuscation\n```\n   55 50 58 21 - identifies the UPX magic bytes\n   [4] - offset by 4 bytes, the l_lsize, l_version & l_format\n   00 00 00 00 - identifies the program header ID\n   00 00 00 00 - identifies the zero’d out p_filesize\n   00 00 00 00 - identifies the zero’d out p_blocksize\n\n```\n\n-----\n\n```\n   condition - requires that all of the above strings exist for a positive YARA signature\n\n```\nmatch\n\nThe above YARA signature can be used to identify ELF files that are packed with UPX and\nhave the header ID, `p_filesize, and` `p_blocksize elements zero’d out. This can go a`\nlong way in identifying obfuscation techniques in addition to Mozi samples. In our testing, we\nused this YARA signature with a 94.6% efficiency for detecting Mozi samples.\n\n## Summary\n\nThe Mozi botnet has been observed targeting vulnerable Internet of Things (IoT) devices to\nlaunch seemingly non-targeted campaigns that can take advantage of the force multiplication\nprovided by a botnet. Mozi has been in operation since at least December 2019.\n\nWe covered techniques to collect, ingest, and analyze samples from the Mozi botnet. These\nmethodologies can also be leveraged to enhance and enable analytical processes for other\ndata samples.\n\n## Additional resources\n\nBlog artifacts and scripts, Elastic:\n[https://github.com/elastic/examples/tree/master/blog/mozin-about](https://github.com/elastic/examples/tree/master/blog/mozin-about)\nThreatFox Indicator of Compromise Database, Abuse.ch:\n[https://threatfox.abuse.ch/browse](https://threatfox.abuse.ch/browse)\nUPX Anti-Unpacking Techniques in IoT Malware, CUJOAI: https://cujo.com/upx-antiunpacking-techniques-in-iot-malware\nCorrupted UPX Packed ELF Repair, vcodispot.com: https://vcodispot.com/corruptedupx-packed-elf-repair\nUPX PACKED ELF BINARIES OF THE PEER-TO-PEER BOTNET FAMILY MOZI, Lars\nWallenborn: https://blag.nullteilerfrei.de/2019/12/26/upx-packed-elf-binaries-of-thepeer-to-peer-botnet-family-mozi\nMozi, Another Botnet Using DHT, 360 Netlab: https://blog.netlab.360.com/mozianother-botnet-using-dht\nMozi Botnet Accounts for Majority of IoT Traffic, Tara Seals:\n[https://threatpost.com/mozi-botnet-majority-iot-traffic/159337](https://threatpost.com/mozi-botnet-majority-iot-traffic/159337)\nNew Mozi P2P Botnet Takes Over Netgear, D-Link, Huawei Routers, Sergiu Gatlan:\nhttps://www.bleepingcomputer.com/news/security/new-mozi-p2p-botnet-takes-overnetgear-d-link-huawei-routers\n[Kibana Maps, Elastic: https://www.elastic.co/guide/en/kibana/current/maps.html](https://www.elastic.co/guide/en/kibana/current/maps.html)\n[Kibana Lens, Elastic: https://www.elastic.co/guide/en/kibana/current/lens.html](https://www.elastic.co/guide/en/kibana/current/lens.html)\n\n\n-----\n\n**We re hiring**\n\nWork for a global, distributed team where finding someone like you is just a Zoom\nmeeting away. Flexible work with impact? Development opportunities from the start?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-27 - Collecting and operationalizing threat data from the Mozi botnet.pdf"
    ],
    "report_names": [
        "2021-07-27 - Collecting and operationalizing threat data from the Mozi botnet.pdf"
    ],
    "threat_actors": [
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535916,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653779646,
    "ts_modification_date": 1653779646,
    "files": {
        "pdf": "https://archive.orkl.eu/d46f508accffe761007c2d7cf7242f9040016ff9.pdf",
        "text": "https://archive.orkl.eu/d46f508accffe761007c2d7cf7242f9040016ff9.txt",
        "img": "https://archive.orkl.eu/d46f508accffe761007c2d7cf7242f9040016ff9.jpg"
    }
}