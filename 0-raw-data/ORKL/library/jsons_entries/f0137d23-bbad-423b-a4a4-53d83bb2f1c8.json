{
    "id": "f0137d23-bbad-423b-a4a4-53d83bb2f1c8",
    "created_at": "2023-01-12T15:06:01.040434Z",
    "updated_at": "2025-03-27T02:06:10.43905Z",
    "deleted_at": null,
    "sha1_hash": "ce68c88450ede03ed38670d2c6e28a11d54fbff8",
    "title": "2022-12-12 - Pulling the Curtains on Azov Ransomware- Not a Skidsware but Polymorphic Wiper",
    "authors": "",
    "file_creation_date": "2022-12-29T00:28:35Z",
    "file_modification_date": "2022-12-29T00:28:35Z",
    "file_size": 1505141,
    "plain_text": "# Pulling the Curtains on Azov Ransomware: Not a Skidsware but Polymorphic Wiper\n\n**[research.checkpoint.com/2022/pulling-the-curtains-on-azov-ransomware-not-a-skidsware-but-polymorphic-wiper/](https://research.checkpoint.com/2022/pulling-the-curtains-on-azov-ransomware-not-a-skidsware-but-polymorphic-wiper/)**\n\n**Research by: Jiri Vinopal.**\n\n## Highlights:\n\n**_Check Point Research (CPR) provides under-the-hood details of its analysis of_**\n**_the infamous Azov Ransomware_**\n**_Investigation shows that Azov is capable of modifying certain 64-bit executables_**\n**_to execute its own code_**\n**_Azov is designed to inflict impeccable damage to the infected machine it runs on_**\n**_CPR sees over 17K of Azov-related samples submitted to VirusTotal_**\n\n## Introduction\n\nDuring the past few weeks, we have shared the preliminary results of our investigation of the\n[Azov ransomware on social media, as well as with Bleeping Computer. The below report](https://twitter.com/_CPResearch_/status/1587837524604465153)\ngoes into more detail regarding the internal workings of Azov ransomware and its technical\nfeatures.\n\n## Background & Key Findings\n\nAzov first came to the attention of the information security community as a payload of the\n[SmokeLoader botnet, commonly found in fake pirated software and crack sites.](https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader)\n\nOne thing that sets Azov apart from your garden-variety ransomware is its modification of\ncertain 64-bit executables to execute its own code. Before the advent of the modern-day\ninternet, this behavior used to be the royal road for the proliferation of malware; because of\nthis, to this day, it remains the textbook definition of “computer virus” (a fact dearly beloved\nby industry pedants, and equally resented by everyone else). The modification of\nexecutables is done using polymorphic code, so as not to be potentially foiled by static\nsignatures, and is also applied to 64-bit executables, which the average malware author\nwould not have bothered with.\n\n\n-----\n\nThis aggressive polymorphic infection of victim executables has led to a deluge of publicly\navailable files infected with Azov. Every day, hundreds of new Azov-related samples are\nsubmitted to VirusTotal, which as of November 2022, has already exceeded 17,000. Using a\nhand-crafted query, it is possible to search for only proper Azov samples, without the\ntrojanized binaries.\n\nVirusTotal query to search for Azov-related samples:\n```\n(behaviour:'Local\\\\\\\\Kasimir_*' OR behaviour:'Local\\\\\\\\azov') AND\n(behaviour_files:'RESTORE_FILES' OR behaviour_registry:'rdpclient.exe')\n\n\n```\nFigure 1: VirusTotal query – Azov-related samples\n\nVirusTotal query to search for only proper Azov samples, without the trojanized binaries:\n```\n(behaviour:'Local\\\\\\\\Kasimir_*' OR behaviour:'Local\\\\\\\\azov') AND\n(behaviour_files:'RESTORE_FILES' OR behaviour_registry:'rdpclient.exe') AND\ndetectiteasy:\"Compiler: FASM*\"\n\n\n```\nFigure 2: VirusTotal query – only original Azov samples\n\nThe abundance of samples has allowed us to distinguish two different versions of Azov, one\nolder and one slightly newer. These two versions share most of their capabilities, but the\nnewer version uses a different ransom note, as well as a different file extension for destroyed\nfiles (.azov).\n\n\n-----\n\n-----\n\nFigure 3: Ransom note of the newer version of Azov\n\n\n-----\n\n-----\n\nFigure 4: Ransom note of the older version of Azov\n\nThe text on the left is remarkable for its stealth delivery of various Kremlin talking points (in\nparticular, the threat of nuclear war). For any readers feeling compelled by the text on the\nright, we recommend Nicky Case’s [The Evolution of Trust.](https://ncase.me/trust/)\n\n### Technical Analysis: Highlights\n\nManually crafted in assembly using FASM\nUsing anti-analysis and code obfuscation techniques\nMulti-threaded intermittent overwriting (looping 666 bytes) of original data content\nPolymorphic way of backdooring 64-bit “.exe” files across the compromised system\n“logic bomb” set to detonate at a certain time. The sample analyzed below was set to\ndetonate at 10-27-2022 10:14:30 AM UTC\nNo network activity and no data exfiltration\nUsing the SmokeLoader botnet and trojanized programs to spread\nEffective, fast, and unfortunately unrecoverable data wiper\n\n## Full Technical analysis\n\nWe focus on the original sample of the newer Azov version (SHA256:\n650f0d694c0928d88aeeed649cf629fc8a7bec604563bca716b1688227e0cc7e — as pointed\nout above, there is no major difference in functionality compared to the older version). This is\na 64-bit portable executable file that has been assembled with FASM (flat assembler), with\nonly 1 section .code (r+x), and without any imports.\n\nFigure 5: Detection of FASM compiler\n\n\n-----\n\nFigure 6: Only 1 section “.code” and no Imports\n\nWhen we think of a person writing code directly in assembly language, we think of a\nvulnerability researcher carefully piecing together a payload, a hard-boiled engineer creating\na real-time application, or maybe an undergraduate student undergoing a rite of passage.\nWe certainly do not immediately think of a ransomware author creating ransomware (indeed,\nwe suspect most ransomware authors would go the opposite direction and write it all in\nPython, [if they feasibly could). We assume this began with the author having to deal with](https://research.checkpoint.com/2019/malware-against-the-c-monoculture/)\ncode at the assembly level anyway to carry out their “infect executables” plan, and then spun\nout of control.\n\nThe .code section has three parts, which are most easily seen by looking at its entropy. First,\nthere is a high-entropy part containing the encrypted shellcode. It is followed by plain code\nimplementing the unpacking routine, and then the last part, with very low entropy, appears to\nconsist of plain strings used to construct the ransom note.\n\nFigure 7: Entropy of the “.code” section\n\n### Unpacking Routine\n\nAs the whole code of Azov is assembly manually crafted for the purpose of being obtuse, it is\nnecessary to do some IDA magic and cleanup to shape the code into a state where it can be\ndecompiled and understood. Once this is done, the procedure start_0() becomes visible.\nThis code unpacks shellcode into newly allocated memory and then transfers execution to it.\n\n\n-----\n\nFigure 8: Entry function start_0\n\nThe unpacking routine in the function AllocAndDecryptShellcode() is intentionally created\nto look more sophisticated than it is. But in reality, it is a simple seeded decryption algorithm\nusing a combination of xor and rol, where key = 0x15C13.\n\nFigure 9: Unpacking routine in the function AllocAndDecryptShellcode\n\nWe provide below a Python implementation of the simplified routine logic:\n\n\n-----\n\n```\nimport pefile, malduck\n\npe = pefile.PE('Azov_Ransomware.exe')\n\nencrypted_shellcode = pe.sections[0].get_data()[5:0x4615+5]\n\ndecrypted_shellcode = bytearray(encrypted_shellcode)\n\nkey = 0x15C13\n\nfor j in range(0x3FDF,-1,-1):\n\n  decrypted_shellcode[j] ^= malduck.BYTE(key)\n\n  key = malduck.rol(key + 0x92819200, 1, 32)\n\nprint(decrypted_shellcode)\n\n```\nThe next stage is split into two main routines: one in charge of wiping files and the other in\ncharge of backdooring executables.\n\nFigure 10: Transferring of execution to wiping and backdooring logic\n\n### Wiping Routine\n\nThe wiping routine begins by creating a mutex (Local\\\\\\\\azov) to verify that two instances\nof the malware are not running concurrently.\n\nFigure 11: Wiping routine – mutex creation\n\n\n-----\n\nIf the mutex handle is successfully obtained, Azov creates persistence by trojanizing (similar\nto the backdooring routine) the 64-bit Windows system binary msiexec.exe or perfmon.exe\nand saving it as rdpclient.exe. A registry entry at\n```\nSOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Run is created pointing to the\n\n```\nnewly created file.\n\nFigure 12: Persistence creation\n\nThe wiping procedure uses a trigger time – there is a loop where the analyzed sample\nchecks system time, and if it is not equal to or larger than the trigger time, it sleeps 10s and\n[loops again. Regarding the analyzed sample in the Twitter post, the trigger time was](https://twitter.com/_CPResearch_/status/1587837524604465153)\n10/27/2022 at 10:14:30 AM UTC.\n\n\n-----\n\nFigure 13: Trigger time set to 10/27/2022 10:14:30 AM UTC\n\nOnce this logic bomb triggers, the wiper logic iterates over all machine directories and\nexecutes the wiping routine on each one, avoiding certain hard-coded system paths and file\nextensions.\n\nFigure 14: System paths omitted from wiping and backdooring\n\n\n-----\n\nFigure 15: File extensions omitted from wiping\n\nEach file is wiped “intermittently”, by which we mean a block of 666 bytes is overwritten with\nrandom noise, then an identically-sized block is left intact, then a block is overwritten again,\nand so on — until the hard limit of 4GB is reached, at which point all further data is left intact.\nAs a random source, the sample uses an uninitialized local variable (e.g., char\n```\nbuffer[666];) which in practice means random stack memory content.\n\n```\nFigure 16: Intermittent data wiping\n\n\n-----\n\nFigure 17: Example trace of data wiping routine\n\nOnce the wiping is finished, the new file extension .azov is added to the original filename.\nThe typical file structure of a wiped file can be seen below.\n\n\n-----\n\nFigure 18: Example structure of a wiped file\n\n### Backdooring Routine\n\nBefore traversing the filesystem to search for files to be backdoored, a mutex named\n```\nLocal\\\\\\\\Kasimir_%c is created, with the %c replaced with the letter of the drive being\n\n```\nprocessed.\n\nFigure 19: Backdooring routine – mutex creation\n\nThe function TryToBackdoorExeFile() is responsible for backdooring 64-bit “.exe” files that\nmeet certain conditions.\n\nFigure 20: Files passing pre-processing conditions go to the TryToBackdoorExeFile function\n\nThese specific conditions could be simplified as follows:\n\n1. Pre-processing conditions:\n\nIt is not a part of the exclude list of filesystem locations\nThe file extension is “.exe”\nThe file size is less than 20MB\n\n\n-----\n\n2. Processing conditions:\n\nThe file is a 64-bit executable file\nThe PE section containing the Entry Point has enough space for the shellcode\nimplant to be injected in the way of preserving the original Entry Point of PE (the\nshellcode start address will be placed at the address of the original Entry Point)\nFile size == PE size (PE size is manually calculated)\n\nThe processing conditions are all checked in the function TryToBackdoorExeFile().\n\nFigure 21: Function TryToBackdoorExeFile\n\nOnce the file meets all pre-processing and processing conditions, it is considered suitable for\nbackdooring and pushed to function BackdoorExeFile().\n\nFigure 22: Proximity graph of function TryToBackdoorExeFile\n\nThe function BackdoorExeFile() is responsible for the polymorphic backdooring of\nexecutable files. It first obtains the address of the original code section (usually the .text\nsection) and randomly modifies its content in several locations. Before injecting the main\nblob of shellcode into the modified code section, certain constant values are changed, and\nthe whole shellcode is re-encrypted with the same encryption algorithm and key as used\nduring the unpacking of the malware, described earlier. After the backdoored file is written\nback to disk, three encoded data structures are appended to its end, which are effectively\nresources needed for the ransomware to function (for instance, an obfuscated form of the\nransom note).\n\n\n-----\n\nFigure 23: Proximity graph of function BackdoorExeFile\n\nDespite the polymorphic backdooring, the encryption/decryption algorithm used during the\nunpacking and backdooring is consistent and can be used for Azov detection.\n\nFigure 24: Re-encryption of the main blob of shellcode using the same algorithm and key as\nduring unpacking\n\n## Anti-analysis and code obfuscation techniques\n\nPreventing usage of software breakpoints – using routines that copy already decrypted and\ncurrently executing parts of shellcode to newly allocated memory and later transferring\nexecution to it will sooner or later result in an exception if software breakpoints are set. In\nsuch situations, it is necessary to use hardware breakpoints.\n\n\n-----\n\nFigure 25: Anti-analysis technique preventing usage of software breakpoints\n\nOpaque constants – replacing constants with a code routine producing the same resulting\nconstant’s value. (This can be repeatedly seen in routines responsible for calculating\nconstant offsets rather than using them directly so that a direct call can be replaced with an\nindirect call)\n\n\n-----\n\nFigure 26: Opaque constants\n\nSyntactic confusion – replacing an instruction with semantically equivalent instruction(s) that\nare not idiomatic, or are outright bloat. One example of this is found in the routine\nresponsible for parsing the export directory; another is the repeated replacement of a call\nwith a direct or indirect jmp. Both are pictured below.\n\n\n-----\n\nFigure 27: Syntactic bloat\n\nFigure 28: Usage of indirect and direct jumps in place of calls\n\nA simplified version of the assembly that parses the export directory can be seen below.\n```\nand   rdx, 0\n\nmov   edx, [rax]\n\nmov   rax, [rbp+moduleBase]\n\nadd   rdx, rax\n\nmov   [rbp+addressOfNames], rdx\n\nmov   rcx, [rbp+exportDirectory]\n\nadd   rcx, _IMAGE_EXPORT_DIRECTORY.AddressOfFunctions\n\nxor   rdx, rdx\n\nmov   edx, [rcx]\n\nadd   rdx, rax\n\nmov   [rbp+addressOfFunctions], rdx\n\n```\n\n-----\n\nDead (junk) code – insertion of garbage bytes which results in no meaningful instructions or\neven no instructions at all.\n\nOpaque predicates – a jz/jnz that at first sight appears to be a conditional jump in practice\nhas the condition always met (or always not met) and effectively functions as an\nunconditional jump, confusing static analysis.\n\nThese two obfuscations can both be seen in the function FindGetProcAddress().\n\nFigure 29: Garbage bytes insertion and Opaque predicate obfuscations\n\nCall-Return Abuse – using push `ret or call instead of a jmp.`\n\nFigure 30: Control indirection\n\nVolatile Homebrew IAT – A dynamically allocated structure containing API function\naddresses being used as nested structure, pushed as an argument to functions that need to\nuse certain WIN API routines instead of using normal imports.\n\n\n-----\n\nFigure 31: Dynamically created IAT-like structure being used as nested structure\n\n## Conclusion\n\nAlthough the Azov sample was considered skidsware when first encountered (likely because\nof the strangely formed ransom note), when probed further one finds very advanced\ntechniques — manually crafted assembly, injecting payloads into executables in order to\nbackdoor them, and several anti-analysis tricks usually reserved for security textbooks or\n[high-profile brand-name cybercrime tools. Azov ransomware certainly ought to give the](https://www.checkpoint.com/cyber-hub/threat-prevention/ransomware/)\ntypical reverse engineer a harder time than the average malware.\n\nIt is not our place to confidently ascribe a motive to the production and dissemination of this\nmalware, though obviously, we can rule out the idea that anything in the newer ransom note\nwas written in good faith (we shouldn’t have to say this, but none of the listed people or\norganizations had anything to do with creating this ransomware). One might simply write it off\nas the actions of a disturbed individual; though if one wanted to see this as an egregious\nfalse flag meant to incite anger at Ukraine and troll victims more generally, they certainly\nwould have a lot of evidence for that hypothesis, too. The number of already detected Azovrelated samples is so large that if there was ever an original target, it has long since been\nlost in the noise of indiscriminate infections.\n\nThe only thing we can say with certainty, and what has been confirmed by all this analysis, is\nthat Azov is an advanced malware designed to destroy the compromised system.\n\n**_Check Point customers remain protected from the threats described in this blog,_**\n_[including all its variants. Anti-Ransomware is offered as part of Harmony Endpoint, Check](https://www.checkpoint.com/solutions/ransomware-protection/anti-ransomware/)_\n_[Point’s complete endpoint security solution. Check Point Provides](https://www.checkpoint.com/solutions/endpoint-security/)_ _[Zero-Day Protection](https://www.checkpoint.com/infinity/zero-day-protection/)_\n_Across its Network, Cloud, Users and Access Security Solutions._\n\n## IOCs\n\n Original Azov samples\n\n\n-----\n\n**SHA256** **Description**\n\nb102ed1018de0b7faea37ca86f27ba3025c0c70f28417ac3e9ef09d32617f801 The old\nversion of\nAzov\n\n650f0d694c0928d88aeeed649cf629fc8a7bec604563bca716b1688227e0cc7e The new\nversion of\nAzov\n\n## Yara\n```\nimport \"pe\"\n\nrule ransomware_ZZ_azov_wiper {\n\n     meta:\n\n              description = \"Detects original and backdoored files with new\nand old versions of azov ransomware - polymorphic wiper\"\n\n   author = \"Jiri Vinopal (jiriv)\"\n\n   date = \"2022-11-14\"\n\n       hash_azov_new =\n\"650f0d694c0928d88aeeed649cf629fc8a7bec604563bca716b1688227e0cc7e\"\n\n              hash_azov_old =\n\"b102ed1018de0b7faea37ca86f27ba3025c0c70f28417ac3e9ef09d32617f801\"\n\n     strings:\n\n     // Opcodes of allocating and decrypting shellcode routine\n\n          $unpacking_azov_new = { 48 83 ec ?? 58 48 01 c8 48 81 ec ?? ?? ?? ??\n48 83 ec ?? 40 80 e4 ?? c6 45 ?? 56 c6 45 ?? 69 c6 45 ?? 72 c6 45 ?? 74 c6 45 ?? 75\nc6 45 ?? 61 c6 45 ?? 6c c6 45 ?? 41 c6 45 ?? 6c c6 45 ?? 6c c6 45 ?? 6f c6 45 ?? 63\nc6 45 ?? 00 48 89 74 24 ?? 48 83 ec ?? 48 83 c4 ?? 48 8b 4c 24 ?? 48 8d 55 ?? ff d0\n48 83 ec ?? 48 c7 04 24 ?? ?? ?? ?? 48 83 c4 ?? 48 8b 4c 24 ?? 48 c7 c2 ?? ?? ?? ??\n49 c7 c0 ?? ?? ?? ?? 49 c7 c1 ?? ?? ?? ?? ff d0 48 c7 c1 ?? ?? ?? ?? 4c 8d 0d ?? ??\n?? ?? 48 ff c9 41 8a 14 09 88 14 08 48 85 c9 75 ?? 48 c7 c1 ?? ?? ?? ?? 41 b9 ?? ??\n?? ?? 41 ba ?? ?? ?? ?? 48 ff c9 8a 14 08 44 30 ca 88 14 08 41 81 ea ?? ?? ?? ?? 45\n01 d1 41 81 c1 ?? ?? ?? ?? 41 81 c2 ?? ?? ?? ?? 41 d1 c1 48 85 c9 }\n\n          $unpacking_azov_old = { 48 01 c8 48 05 ?? ?? ?? ?? 48 81 c1 ?? ?? ??\n?? 48 81 ec ?? ?? ?? ?? 48 83 ec ?? 40 80 e4 ?? c6 45 ?? 56 c6 45 ?? 69 c6 45 ?? 72\nc6 45 ?? 74 c6 45 ?? 75 c6 45 ?? 61 c6 45 ?? 6c c6 45 ?? 41 c6 45 ?? 6c c6 45 ?? 6c\nc6 45 ?? 6f c6 45 ?? 63 c6 45 ?? 00 48 83 e1 ?? 48 01 f1 48 8d 55 ?? ff d0 48 83 ec\n?? 48 c7 04 24 ?? ?? ?? ?? 48 83 c4 ?? 48 8b 4c 24 ?? 48 c7 c2 ?? ?? ?? ?? 49 c7 c0\n?? ?? ?? ?? 49 c7 c1 ?? ?? ?? ?? ff d0 48 c7 c1 ?? ?? ?? ?? 4c 8d 0d ?? ?? ?? ?? 48\nff c9 41 8a 14 09 88 14 08 48 85 c9 }\n\n     condition:\n\n          uint16(0) == 0x5a4d and pe.is_64bit() and\n\n          any of ($unpacking_azov_*)\n\n}\n\n References\n\n```\n\n-----\n\n1. Twitter – Check Point Research:\n\n[https://twitter.com/_CPResearch_/status/1587837524604465153](https://twitter.com/_CPResearch_/status/1587837524604465153)\n2. Bleeping Computer: https://www.bleepingcomputer.com/news/security/azov\nransomware-is-a-wiper-destroying-data-666-bytes-at-a-time/\n3. Bleeping Computer: https://www.bleepingcomputer.com/news/security/new-azov-data\nwiper-tries-to-frame-researchers-and-bleepingcomputer/\n4. Twitter – MalwareHunterTeam:\n\n[https://twitter.com/malwrhunterteam/status/1586713979514224643](https://twitter.com/malwrhunterteam/status/1586713979514224643)\n\nGO UP\n[BACK TO ALL POSTS](https://research.checkpoint.com/latest-publications/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-12 - Pulling the Curtains on Azov Ransomware- Not a Skidsware but Polymorphic Wiper.pdf"
    ],
    "report_names": [
        "2022-12-12 - Pulling the Curtains on Azov Ransomware- Not a Skidsware but Polymorphic Wiper.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535961,
    "ts_updated_at": 1743041170,
    "ts_creation_date": 1672273715,
    "ts_modification_date": 1672273715,
    "files": {
        "pdf": "https://archive.orkl.eu/ce68c88450ede03ed38670d2c6e28a11d54fbff8.pdf",
        "text": "https://archive.orkl.eu/ce68c88450ede03ed38670d2c6e28a11d54fbff8.txt",
        "img": "https://archive.orkl.eu/ce68c88450ede03ed38670d2c6e28a11d54fbff8.jpg"
    }
}