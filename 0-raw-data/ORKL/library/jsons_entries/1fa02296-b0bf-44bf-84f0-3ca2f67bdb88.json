{
    "id": "1fa02296-b0bf-44bf-84f0-3ca2f67bdb88",
    "created_at": "2023-01-12T15:02:45.49853Z",
    "updated_at": "2025-03-27T02:09:30.167992Z",
    "deleted_at": null,
    "sha1_hash": "fab7a63e34a35178f20d247d6e4f033eaab83677",
    "title": "2021-09-05 - BlackMatter Ransomware v2.0",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:05Z",
    "file_modification_date": "2022-05-27T23:24:05Z",
    "file_size": 2462850,
    "plain_text": "# BlackMatter Ransomware v2.0\n\n**[chuongdong.com/reverse engineering/2021/09/05/BlackMatterRansomware/](https://chuongdong.com/reverse%20engineering/2021/09/05/BlackMatterRansomware/)**\n\nChuong Dong September 5, 2021\n\n[Reverse Engineering · 05 Sep 2021](https://chuongdong.com/categories/#reverse%20engineering)\n\n## Contents\n\n Overview\n\nThis is my analysis for the BlackMatter Ransomware version 2.0.\n\nIn this analysis, I only cover BlackMatter’s ransomware functionalities and leave out details about the antianalysis and obfuscation stuff. The main reason for this is because I’m just really lazy.\n\n**BlackMatter uses a hybrid-cryptography scheme of RSA-1024 and modified ChaCha20 similar to encrypt**\nfiles and protect its ChaCha20 matrix.\n\nLike Darkside, its configuration is encrypted and aPLib-compressed in memory.\n\nWhen servers’ URLs are provided in the configuration, the malware encrypts informations about the victim’s\nmachine and encryption stats using a hard-coded AES key and sends them to the remote servers.\n\nSimilar to REvil, BlackMatter’s child threads use a shared structure to divide the work into multiple states\nwhile encrypting a file.\n\nBy basing its multithreading architecture on REvil’s, BlackMatter’s encryption is relatively fast.\n\n_Figure 1: BlackMatter leak site._\n\n\n-----\n\n## IOCS\n\nThis sample is a 32-bit Windows executable.\n\n**MD5: 50c4970003a84cab1bf2634631fe39d7**\n\n**SHA256: 520bd9ed608c668810971dbd51184c6a29819674280b018dc4027bc38fc42e57**\n\n**Sample:**\nhttps://bazaar.abuse.ch/sample/520bd9ed608c668810971dbd51184c6a29819674280b018dc4027bc38fc42e57/\n\n_Figure 2: BlackMatter victim portal._\n\n## Ransom Note\n\nThe content of the ransom note is encrypted in BlackMatter’s configuration, and it’s dynamically decrypted\nand written to the ransom note file in every directory.\n\nThe ransom note filename is in the form of **.README.txt**.\n\n\n-----\n\n_Figure 3: BlackMatter ransom note._\n\n## Static Code Analysis\n\n Anti-Analysis: Dynamic API Resolving\n\nSince BlackMatter is a combination between LockBit, Darkside, and REvil, it’s not suprising that the\nransomware obfuscates its API calls from static analysis.\n\nThe obfuscation is pretty cool, but I won’t analyze it here. I highly suggest fellow analysts to check out how it\nworks if they have time!\n\n\n-----\n\n_Figure 3: Dynamic API resolve._\n\n[Check out my IDAPython scripts dll_exports.py and](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Blackmatter/dll_exports.py) [revil_api_resolve.py if you want to automate resolving](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Blackmatter/API_resolve.py)\nthese APIs in IDA Pro and speed up your analysis.\n\nThese scripts are inspired by the REVil scripts from this [OALabs’s Youtube video.](https://www.youtube.com/watch?v=R4xJou6JsIE)\n\n[Jan G. has a really good blog post explaining the BlackMatter’s API hashing and obfuscation through](https://twitter.com/jan6ru)\n[trampoline pointers. If you’re interested in the technical analysis of this, feel free to check their work out.](https://blog.digital-investigations.info/2021-08-05-understanding-blackmatters-api-hashing.html)\n\n## Anti-Analysis: String Encryption\n\nLike with other major ransomware out there, most strings in BlackMatter are encrypted and resolved during\nrun-time.\n\nThe strings that are not encrypted are stored on the stack as stack strings. For each encrypted ones, the\nencrypted bytes/DWORDs are pushed on the stack and decrypted by XOR-ing with a constant.\n\nThis implementation is really similar to that of Conti ransomware, and there is probably a good way to\nautomate resolving these with an IDAPython script.\n\nSince I’m lazy during my analysis, I just use x32dbg to execute and resolve these stack strings dynamically.\n\n\n-----\n\n_Figure 5: Stack string decryption._\n\n## Anti-Analysis: String Comparison\n\nIn ransomware specifically, string comparison is crucial for tasks such as checking the name of processes and\nservices to terminate, files and folders to avoid encrypting, searching for names of DLLs and Windows APIs,\netc.\n\nAs a result, it helps tremendously if analysts can look at the strings being compared to quickly identify certain\nfunctionalities of the ransomware.\n\n**BlackMatter obfuscates this with a one-way hash function and only compares the strings’ hashes instead of**\nthe strings themselves. The hash of a string is just the summation of each byte rotated right by 13 with an\ninitial seed.\n\n_Figure 6: String hashing algorithm._\n\nThe summation makes it impossible to work backward from the hash to produce a string, so resolving these\nhashes requires heuristic analysis, cracking dictionary, and bruteforcing.\n\n\n-----\n\n[I use and contribute this tool by](https://github.com/sisoma2/malware_analysis/tree/master/blackmatter) [@sisoma2 to look up the hashes that BlackMatter uses! His tool has a great](https://twitter.com/sisoma2)\ndictionary to crack the hashes, so make sure to use it to aid your analysis!\n\nBelow is the list of hashes used by BlackMatter v2 and their strings.\n\n\n-----\n\n```\n          p\n0x5366e694 -> perflogs\n0xe7681bc0 -> rom\n0xdd481cc0 -> msi\n0xd9c81940 -> key\n0xef3a37b3 -> default\n0xd57818c0 -> ico\n0x67b00e00 -> 386\n0xcd2e9b7a -> theme\n0x6b66f975 -> intel\n0xdd081c00 -> mpa\n0xdd101900 -> mdb\n0xe9981a00 -> shs\n0x267078f5 -> $windows.~bt\n0xcd101900 -> edb\n0xc6ce6958 -> appdata\n0xeb869d00 -> http\n0x85aa57e4 -> ntuser.dat.log\n0x4a6bb7db -> msstyles\n0x4cca7837 -> nomedia\n0x49164931 -> accdb\n0xc9101840 -> cab\n0xe1c018c0 -> ocx\n0xdb301900 -> ldf\n0x12018c0 -> c$\n0xfcc8ab56 -> bootsect.bak\n0xdf981b00 -> nls\n0xe99018c0 -> scr\n0xa6f2d1a7 -> application data\n0x4c4b25d4 -> tor browser\n0xe7801d00 -> rtp\n0xdd201bc0 -> mod\n0xf00cae96 -> bootfont.bin\n0x846bec00 -> iconcache.db\n0xd4aaebb2 -> admin$\n0xc7a01840 -> bat\n0xc8cef7d1 -> thumbs.db\n0xdd301900 -> mdf\n0xf1c01c00 -> wpx\n0xe1a63bc0 -> boot\n0xcbb01c80 -> drv\n0xc5481b80 -> ani\n0xcbe2aa35 -> ntuser.ini\n0x2e75e394 -> programdata\n0x4ae29631 -> diagcfg\n0xba22623b -> all users\n0x4aba94f1 -> diagcab\n0xd5c01900 -> idx\n0xdd801cc0 -> msp\n0xdd181cc0 -> msc\n0xeb9f5c34 -> https\n0x3907099b -> boot.ini\n0x64e29771 -> diagpkg\n0x86ccaa15 -> autorun.inf\n0xb7e02438 -> svchost.exe\n0xe3301c80 -> prf\n0xe9601c00 -> spl\n0xc5b01900 -> adv\n0x452f4997 -> -safe\n0xe1881cc0 -> ps1\n0xaf16c593 -> themepack\n0xe3101900 -> pdb\n0xd59818c0 -> ics\n0xdb975937 -> ntldr\n0xc23aa6f5 -> ntuser dat\n\n```\n\n-----\n\n```\n          p\n0xb7ea3892 -> msocache\n0xe15ed8c0 -> lock\n0xcb601b00 -> dll\n0xe3426cd7 -> windows\n0xc7701a40 -> bin\n0xc9601c00 -> cpl\n0x5cde3a7b -> public\n0xc99eab80 -> icns\n0xdf301900 -> ndf\n0xd3081d00 -> hta\n0x7f07935 -> windows.old\n0x45678b17 -> -wall\n0xdda81cc0 -> msu\n0xe9981e40 -> sys\n0x30a212d -> $recycle.bin\n0x45471d17 -> -path\n0x52cb0b38 -> google\n0xdccab8dd -> mozilla\n0xc9201b40 -> cmd\n0xa1fccbfe -> deskthemepack\n0x26687e35 -> $windows.~ws\n0xc9901d40 -> cur\n0xae018eae -> system volume information\n0xdb581b80 -> lnk\n0xcd281e00 -> exe\n0x82d2a252 -> desktop.ini\n0x8cf281cd -> config.msi\n0xfe9e7c10 -> runonce.exe\n0x36004e4e -> program files\n0xd56018c0 -> icl\n0xab086595 -> program files (x86)\n0xc9681bc0 -> com\n\n## Configuration\n\n```\nThe configuration of BlackMatter samples is encrypted and compressed in memory similar to that of\n**Darkside.**\n\nDuring my analysis, I dynamically execute to decrypt it using x32dbg and decompress the configuration using\n**aPLib in Python.**\n\n\n-----\n\n_Figure 7: BlackMatter config extraction._\n\nBelow is the list of configuration fields that BlackMatter supports and their description.\n\n**RSA_PUBLIC_KEY (128 bytes): RSA key to encrypt ChaCha20 Key.**\n\n**COMPANY_VICTIM_ID (16 bytes): Company ID used in data being sent back to remote server to**\nidentify victim.\n\n**AES_KEY (16 bytes): AES key to encrypt data being sent to remote servers.**\n\n**ENCRYPT_LARGE_FILE_FLAG (1 byte): Enable chunking to encrypt large files.**\n\n**ATTEMPT_LOGON_FLAG (1 byte): Enable attempting to log in using user credentials given in the**\nconfiguration.\n\n**MOUNT_VOL_AND_ENCRYPT_FLAG (1 byte): Enable encrypting Exchange mailbox, mounting all**\nvolumes, and encrypting them.\n\n**NETWORK_ENCRYPT_FLAG (1 byte): Enable retrieving DNS host names and encrypting their network**\nshares\n\n**TERMINATE_PROCESSES_FLAG (1 byte): Enable terminating processes specified by the**\n**PROCESSES_TO_KILL config field.**\n\n**STOP_SERVICES_AND_DELETE_FLAG (1 byte): Enable stopping and deleting services specified by**\nthe SERVICES_TO_KILL config field.\n\n**CREATE_MUTEX_FLAG (1 byte): Enable creating and checking RunOnce mutex.**\n\n**PRINTER_PRINT_RANSOM_NOTE_FLAG (1 byte): Enable printing ransom note using the local user’s**\ndefault printer\n\n\n-----\n\n**SEND_DATA_TO_SERVER_FLAG (1 byte): Enable sending victim s info and encrypting stats to remote**\nservers specified by the REMOTE_SERVER_URLS config field.\n\n**FOLDER_HASHES_TO_AVOID: Base64-encoded list of 4-byte hashes of folder names to avoid**\nencrypting.\n\n**FILE_HASHES_TO_AVOID: Base64-encoded list of 4-byte hashes of filenames to avoid encrypting.**\n\n**EXTENSION_HASHES_TO_AVOID: Base64-encoded list of 4-byte hashes of extensions to avoid**\nencrypting.\n\n**COMPUTERNAMES_TO_AVOID: Base64-encoded list of computer names to avoid encrypting (not**\nused in this sample).\n\n**PROCESSES_TO_KILL: Base64-encoded list of processe to kill.**\n\n**SERVICES_TO_KILL: Base64-encoded list of services to kill.**\n\n**REMOTE_SERVER_URLS: Base64-encoded list of remote servers to contact.**\n\n**LOGIN_CREDENTIALS: List of credentials to try logging into the machine (not used in this sample).**\n\n**RANSOM_NOTE_CONTENT: Base64-encoded and encrypted content of the ransom note.**\n\n**RANSOM_NOTE_CONTENT_HASH: Checksum of ransom note content.**\n\n[Here is the configuration of this v2 sample in JSON form. I generate this using this auto config extracting tool](https://github.com/advanced-threat-research/DarkSide-Config-Extract)\nand fix up the configuration field names according to my analysis. Huge shoutout to the guys at McAfee\n**Advanced Threat Research for this!**\n\n\n-----\n\n```\n{\n \"RSA_PUBLIC_KEY\": \n\"4FDB27F0D5F8A0741EBE1A8C08E5B98ABECE2C281166A7FFDCF239A8A77FD2A4FC6B8828A5F3F9F5FA4B245CC90386953D646\n \"COMPANY_VICTIM_ID\": \"24483508BCCFE72E63B26A1233058170\",\n \"AES_KEY\": \"196387BAD88422E3F08474FA8F7E796E\",\n \"ENCRYPT_LARGE_FILE_FLAG\": \"false\",\n \"ATTEMPT_LOGON_FLAG\": \"false\",\n \"MOUNT_VOL_AND_ENCRYPT_FLAG\": \"true\",\n \"NETWORK_ENCRYPT_FLAG\": \"true\",\n \"TERMINATE_PROCESSES_FLAG\": \"true\",\n \"STOP_SERVICES_AND_DELETE_FLAG\": \"true\",\n \"CREATE_MUTEX_FLAG\": \"true\",\n \"SEND_DATA_TO_SERVER_FLAG\": \"true\",\n \"PRINTER_PRINT_RANSOM_NOTE_FLAG\": \"true\",\n \"PROCESSES_TO_KILL\": [{\n   \"\": \"encsvc\"\n  }, {\n   \"\": \"thebat\"\n  }, {\n   \"\": \"mydesktopqos\"\n  }, {\n   \"\": \"xfssvccon\"\n  }, {\n   \"\": \"firefox\"\n  }, {\n   \"\": \"infopath\"\n  }, {\n   \"\": \"winword\"\n  }, {\n   \"\": \"steam\"\n  }, {\n   \"\": \"synctime\"\n  }, {\n   \"\": \"notepad\"\n  }, {\n   \"\": \"ocomm\"\n  }, {\n   \"\": \"onenote\"\n  }, {\n   \"\": \"mspub\"\n  }, {\n   \"\": \"thunderbird\"\n  }, {\n   \"\": \"agntsvc\"\n  }, {\n   \"\": \"sql\"\n  }, {\n   \"\": \"excel\"\n  }, {\n   \"\": \"powerpnt\"\n  }, {\n   \"\": \"outlook\"\n  }, {\n   \"\": \"wordpad\"\n  }, {\n   \"\": \"dbeng50\"\n  }, {\n   \"\": \"isqlplussvc\"\n  }, {\n   \"\": \"sqbcoreservice\"\n  }, {\n   \"\": \"oracle\"\n  }, {\n    \"\": \"ocautoupds\"\n\n```\n\n-----\n\n```\n  }, {\n   \"\": \"dbsnmp\"\n  }, {\n   \"\": \"msaccess\"\n  }, {\n   \"\": \"tbirdconfig\"\n  }, {\n   \"\": \"ocssd\"\n  }, {\n   \"\": \"mydesktopservice\"\n  }, {\n   \"\": \"visio\"\n  }],\n \"SERVICES_TO_KILL\": [{\n   \"\": \"mepocs\"\n  }, {\n   \"\": \"memtas\"\n  }, {\n   \"\": \"veeam\"\n  }, {\n   \"\": \"svc$\"\n  }, {\n   \"\": \"backup\"\n  }, {\n   \"\": \"sql\"\n  }, {\n   \"\": \"vss\"\n  }, {\n   \"\": \"msexchange\"\n  }],\n \"REMOTE_SERVER_URLS\": [{\n   \"\": \"hxxps://mojobiden[.]com\"\n  }, {\n   \"\": \"hxxp://mojobiden[.]com\"\n  }],\n \"RANSOM_NOTE_CONTENT\": [{\n   \"\": \"   ~+                    \n           *    +\n        '   BLACK    |\n      ()  .-.,='``'=.  - o -     \n         '=/_    \\\\   |      \n       *  | '=._  |        \n          \\\\   `=./`,    '  \n        .  '=.__.=' `='   *\n    +       Matter    +\n      O   *    '    .\n   >>> What happens?\n     Your network is encrypted, and currently not operational. \n     We need only money, after payment we will give you a decryptor for the entire network and\nyou will restore all the data.\n   >>> What guarantees? \n     We are not a politically motivated group and we do not need anything other than your money. \n     If you pay, we will provide you the programs for decryption and we will delete your data. \n     If we do not give you decrypters or we do not delete your data, no one will pay us in the\nfuture, this does not comply with our goals. \n     We always keep our promises.\n   >>> How to contact with us? \n     1. Download and install TOR Browser (hxxps://www[.]torproject[.]org/).\n     2. Open hxxp://supp24yy6a66hwszu2piygicgwzdtbwftb76htfj7vnip3getgqnzxid[.]onion/<REDACTED>\n   >>> Warning! Recovery recommendations. \n     We strongly recommend you to do not MODIFY or REPAIR your files that will damage them \"\n\n```\n\n-----\n\n```\n  }],\n  \"RANSOM_NOTE_CONTENT_HASH\": \"38E73655\"\n}\n\n## Command-line Arguments\n\n```\n**BlackMatter can run with or without command-line arguments.**\n\nBelow is the list of arguments that can be supplied by the operator.\n\n**Argument** **Description**\n\n**-path <target>** Path to a directory to be encrypted specifically\n\n**<target>** Path to a directory to be encrypted specifically\n\n**-safe** Enable safe mode reboot\n\n**-wall** Sets up wallpaper and print ransom note\n\n## Pre-Encryption Setup\n\n### UAC Bypass\n\nDuring setup, BlackMatter checks if it currently runs with Admin credentials.\n\nFirst, it calls SHTestTokenMembership to check if its process’s token is a member of the administrators’\ngroup in the built-in domain.\n\n_Figure 8: Checking token membership._\n\nNext, after querying the system’s OS version from the PEB, the ransomware checks if the current OS is\n**Windows 7 and above.**\n\n\n-----\n\n_Figure 9: Checking OS version._\n\nFinally, it checks the current process’s token belongs to the built-in system domain groups used for\nadministration.\n\n\n-----\n\n_Figure 10: Checking token authority._\n\nIf the checks pass and the process has admin privilege, the malware does not attempt UAC bypass.\n\nFor UAC bypass, using LdrEnumerateLoadedModules, it registers “dllhost.exe” in System32 as the\n**ImagePathName and CommandLine field in the ProcessParameters field of the process’s PEB. This initial**\nsetup allows it to host and execute COM Objects as “dllhost.exe”.\n\n_Figure 11: Setup execution as dllhost.exe._\n\n**BlackMatter then calls CoGetObject with the object name below to retrieve the COM interface ICMLuaUtil,**\nwhich is commonly used for UAC bypass.\n```\n Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}\n\n```\nThe malware then executes the ShellExec function from the ICMLuaUtil interface to relaunch itself with its\noriginal command-line arguments, which elevates the new process to a higher privilege.\n\n_Figure 12: UAC bypass and relaunch._\n\nFinally, it terminates itself by calling NtTerminateProcess.\n\n### Generate Encrypted Extension\n\n\n-----\n\nThe encrypted extension is dynamically generated using the victim s machine GUID, which makes it unique on\nevery system.\n\nFirst, BlackMatter queries the value of the registry key below to get the machine GUID.\n```\n HKLM\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid\n\n```\nNext, the malware puts the machine GUID through 3 rounds of hashing, byte swaps, and Base64-encode the\nfinal hash to generate the encrypted extension.\n\nBecause the ASCII characters ’+’, ‘/’, and ‘=’ in a Base64 string does not work really well in a file extension,\n**BlackMatter replaces ’+’ with ‘x’, ’/’ with ‘i’, and ’=’ with ‘z’.**\n\n_Figure 13: Generating encrypted file extension._\n\nThe malware reuses this file extension as the ransom note name by appending it in front of “.README.txt”.\n\n\n-----\n\n_Figure 14: Generating ransom note filename._\n\n### Retrieving Token To Impersonate With Process Injection\n\n**BlackMatter attempts to retrieve and duplicate the token of an elevated process running on the system. The**\nmalware later launches threads and has them impersonate the target process using this token.\n\nFirst, it checks if the current process’s user is LocalSystem, a special account used by the operating system.\nThen, it calls NtQueryInformationToken to query the token user information and checks if the first sub\nauthority of the process’s SID is SECURITY_LOCAL_SYSTEM_RID.\n\n\n-----\n\n_Figure 15: Checking for LocalSystem._\n\nIf the process is running as LocalSystem, BlackMatter uses the current user’s token as its elevated token.\n\nIf not, the malware calls NtQuerySystemInformation to query information about processes on the system.\nFor each process entry, it checks if the process’s name is explorer.exe and retrieves its unique process ID.\n\n_Figure 16: Retrieving Explorer’s process ID._\n\nNext, it calls NtOpenProcess with the process ID to get the process’s handle and retrieves the process’s\ntoken with NtOpenProcessToken.\n\nFinally, BlackMatter calls NtDuplicateToken to duplicate the Explorer’s token.\n\nIf this fails but the current process’s token is a member of the administrators’ group in the built-in domain,\n**BlackMatter pulls some process injection shenaningans to retrieve a token of a svchost.exe process.**\n\nFirst, it uses the same trick in Figure 16 to retrieve the process ID and handle of a svchost.exe process.\n\n\n-----\n\n_Figure 17: Retrieving svchost.exe process ID and handle._\n\nNext, it checks if the svchost.exe process is running as a 64-bit process.\n\n[If it is 64-bit, the malware decrypts two different shellcodes in memory. The raw shellcodes can be found here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Blackmatter/blackmattershellcode.7z)\n\nAfter allocating memory in the svchost.exe process using NtAllocateVirtualMemory, BlackMatter writes the\nfirst shellcode into the memory region of the second shellcode before setting up and executing the second\nshellcode.\n\n_Figure 18: Injecting 64-bit shellcodes into Svchost._\n\nAfter being injected, the second shellcode allocates virtual memory in the svchost process using\n**NtAllocateVirtualMemory, writes the first shellcode in using NtWriteVirtualMemory, and create a new thread**\nto execute the first shellcode using NtCreateThreadEx.\n\n\n-----\n\n_Figure 19: Second shellcode launching first shellcode As Svchost._\n\nThe first shellcode calls WTSQueryUserToken to obtain the primary access token of the logged-on user and\ncalls NtDuplicateObject to duplicate that token. This token is passed back into the main ransomware thread.\n\n_Figure 20: First shellcode retrieving the primary access token of the logged-on user._\n\nIf the svchost process is running as a 32-bit process instead, the malware decrypts the third shellcode and\nmanually creates a remote thread using CreateRemoteThread to launch it. This shellcode is basically just the\n32-bit version of the first shellcode.\n\n\n-----\n\n_Figure 20: Launching the third shellcode._\n\n### Parsing Login Credentials\n\nIf the ATTEMPT_LOGON_FLAG is true and LOGIN_CREDENTIALS are provided in the configuration, the\nmalware parses those credential data before attempting authentication.\n\nThe LOGIN_CREDENTIALS field is a Base64-encoded and encrypted buffer of strings, and each credential\nstring is in the form below.\n```\n<username>@<domain>:password\n\n```\nSince this v2 sample doesn’t have this field in its configuration, I just base the analysis on its code and others’\nreports for BlackMatter v1.\n\nAfter decoding and decrypting the credentials, the malware iterates through each credential’s username and\npassword and calls LogonUserW to log in the local machine.\n\nIf the logging in is successful, BlackMatter allocates heap buffers and stores the valid credential’s username,\npassword, and domain name in there for later usage.\n\n\n-----\n\n_Figure 22: Parsing credentials._\n\nNext, it calls NtQueryInformationToken to query the authentication token’s group information and checks if\nthe token belongs to the DOMAIN_ADMINS group.\n\n\n-----\n\n_Figure 23: Check if account is in domain admins._\n\nIf the token belongs to the DOMAIN_ADMINS group, the malware calls SHTestTokenMembership to check if\nthe token has DOMAIN_ALIAS_RID_ADMINS privilege.\n\nIf it does not have enough privilege, BlackMatter frees all the heap buffers storing the credential and does not\nuser it later.\n\n_Figure 24: Skip if credential doesn’t have proper privilege._\n\n\n-----\n\n### Cryptographic Keys Setup\n\n**BlackMatter has multiple key buffers to use depending on the size of the file being encrypted.**\n\nBelow is the layout of these buffers.\n```\nstruct KeyBuffer {\n DWORD RSA_encrypted_ChaCha20_matrix_Checksum;\n BYTE RSA_encrypted_ChaCha20_matrix[128];\n BYTE ChaCha20_Matrix[124];\n}\n\n```\nTo populate each of these, BlackMatter first randomly generates the ChaCha20 matrix.\n\n_Figure 25: ChaCha20 matrix generation._\n\nFor BlackMatter v2, the matrix is 124-byte or 31-DWORD in length. The first 29 DWORDs in the buffer is\nrandomly generated using assembly instructions cpuid, rdrand, rdseed, and __rdtsc. The 30th DWORD is\nthe first 4 bytes in the RSA Public Key from the configuration, and the last DWORD contains 3 randomly\ngenerated bytes.\n\nThe raw matrix is copied to the last 124 bytes of the RSA_encrypted_ChaCha20_matrix buffer, and\nBlackMatter puts the encryption skipped size in the first DWORD of this buffer (0 if chunking is not enabled).\n\n\n-----\n\nThis buffer is then encrypted by the RSA public key from the configuration, and the malware generates and\nwrites the encrypted result to the RSA_encrypted_ChaCha20_matrix field. It also generates the checksum of\nthis encrypted buffer and writes it in the RSA_encrypted_ChaCha20_matrix_Checksum field.\n\n_Figure 26: Key buffer generation._\n\n**BlackMatter randomly generates 11 different key buffers that are used depending on the size of the file to be**\nencrypted.\n\nBelow is the list of skipped sizes BlackMatter uses.\n\n0x0\n0x200000\n0x400000\n0x800000\n0x1000000\n0x2000000\n0x4000000\n0x8000000\n0x10000000\n0x20000000\n0x40000000\n\n\n-----\n\n_Figure 27: Key buffer generation 2._\n\n## Safe Mode Reboot\n\nIf the command-line argument -safe is provided and the process’s token belongs to\n**DOMAIN_ALIAS_RID_ADMINS, BlackMatter attempts to force the system to reboot into safe mode in order**\nto gain more privilege to execute itself.\n\n### Checking Computer Name\n\nThe malware gets the computer name with GetComputerNameW and compares its hash with the list of\nhashes from the COMPUTERNAMES_TO_AVOID field in the configuration. If the hash is in the list,\n**BlackMatter skips this operation.**\n\n\n-----\n\n_Figure 28: Checking computer name._\n\nPrior to activating safe mode, BlackMatter retrieves proper user credentials to modify the Winlogon registry\nkey.\n\nFirst, if ATTEMPT_LOGON_FLAG is true and the username, password, and domain name are properly\nparsed from the configuration, then the malware just uses those credentials.\n\nIf not, it calls NetUserEnum with a filter for normal accounts. BlackMatter iterates through user information\nentries until it finds one with the user ID of 500, which is the ID for normal users. If the account corresponding\nto this entry is disabled, the malware enables it manually by setting the flags in the user information entry.\n\n_Figure 29: Enumerating for normal user account._\n\nNext, BlackMatter generates a new password for this account. The format of the password string is 3 random\nuppercase letters, 1 random character of ’#’ or ‘&’, 3 random numbers, 1 random character of ’#’ or ‘&’, and 4\nrandom lowercase letters.\n\n\n-----\n\nThe malware updates the user account entry with this new password and calls NetUserSetInfo to udate the\nuser account with the updated entry.\n\n_Figure 30: Generating new password and updating account._\n\nNext, BlackMatter sets the following registry keys to these values.\n```\n- SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AutoAdminLogon: \"1\"\n- SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DefaultUserName: Account username\n- SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DefaultDomainName: Account domain name\n- SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DefaultPassword: Account password\n\n```\nThis sets the default credentials to the account that BlackMatter has control over (with the password from\nconfiguration or the newly generated password) and enables automatic admin logon upon reboot.\n\nIt also calls LsaStorePrivateData to store and protect the account’s password locally.\n\n_Figure 31: Setting logon credentials and enabling auto admin logon._\n\n### RunOnce Registry Persistence\n\n\n-----\n\n**BlackMatter sets the value of the registry key SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce**\nto its own executable path to automatically launch itself upon reboot in safe mode.\n\nThe registry key name is randomly generated in the format of 3 random uppercase letters, 3 random numbers,\nand 3 random lowercase letters.\n\n_Figure 32: Persistence through registry._\n\n### Safe Boot Command Execution\n\nPrior to executing commands to enable safe boot, BlackMatter sets up wallpaper operations that are\ndocumented here without calling SystemParametersInfoW to change the wallpaper.\n\nIf the enable flag being passed as a parameter is true, BlackMatter executes one of these commands with\n**WinExec based on the OS version to enable safe mode reboot.**\n```\n- Below Windows Vista: bootcfg /raw /a /safeboot:network /id 1\n- Windows Vista and above: bcdedit /set {current} safeboot network\n\n```\nIf the enable flag being passed as a parameter is false, BlackMatter executes one of these commands with\n**WinExec based on the OS version to disable safe mode reboot.**\n```\n- Below Windows Vista: bootcfg /raw /fastdetect /id 1\n- Windows Vista and above: bcdedit /deletevalue {current} safeboot\n\n```\nFinally, it calls NtShutdownSystem to reboot the system.\n\n\n-----\n\n_Figure 33: Configuring system to boot into Safe Mode._\n\n## Setting Ransom Wallpaper\n\nIf the command-line argument -wall is provided, BlackMatter generates a Bitmap file and sets it as the\nwallpaper on the victim’s computer.\n\nFirst, using NtQuerySystemInformation, it queries all processes’ information on the system and terminates\nall Run Once Wrapper Utility processes with the image name runonce.exe using NtTerminateProcess.\n\n\n-----\n\n_Figure 34: Terminating runonce.exe._\n\nNext, the malware calls GetShellWindow(if the OS is Windows Vista or above) or GetDesktopWindow to\nretrieve a handle to the desktop window. It continues to do this until it gets a valid handle and the window is\ncurrently visible.\n\n\n-----\n\n_Figure 35: Retrieving desktop window._\n\nFinally, BlackMatter sets up the wallpaper to display the ransom instruction.\n\nThe malware sets the following registry keys.\n```\n- HKLM\\SOFTWARE\\<ENCRYPTED_EXTENSION>\\hScreen: Window screen height\n- HKLM\\SOFTWARE\\<ENCRYPTED_EXTENSION>\\wScreen: Window screen width\n\n```\n\n-----\n\n_Figure 36: Setting window screen registry Keys._\n\nNext, it creates a handle to the Times New Roman font and writes the ransom instruction using the font into a\nBitmap.\n\nThe content of the ransom instruction is documented below.\n```\nBlackMatter Ransomware encrypted all your files!\nTo get your data back and keep your privacy safe,\nyou must find <Ransom note filenam> file\nand follow the instructions!\n\n```\n\n-----\n\n_Figure 37: Generating ransom wallpaper._\n\nAfter creating the Bitmap in memory, the malware writes it to disk at the path below.\n```\n<special folder path>/<encrypted extension>.bmp\n\n```\n\n-----\n\n_Figure 38: Writing bitmap content to disk._\n\nUsing the elevated token it has, BlackMatter retrieves the token’s process’s SID and create the following\nregistry key.\n```\n- HKU\\<Process SID>\\Control Panel\\Desktop\n\n```\nIt sets the following registry key.\n```\n- HKU\\<Process SID>\\Control Panel\\Desktop\\WallPaper: Bitmap file path\n- HKU\\<Process SID>\\Control Panel\\Desktop\\WallpaperStyle: \"10\"\n\n```\nTo set the victim’s machine’s wallpaper to the generated Bitmap, BlackMatter calls SystemParametersInfoW\nto set SPI_SETDESKWALLPAPER to the Bitmap disk path if the enable flag from the function’s parameter is\ntrue.\n\n_Figure 39: Setting ransom wallpaper._\n\n### Ransom Note Printing\n\nWhen the command-line argument -wall is provided, BlackMatter also prints the ransom note using the\nsystem’s default printer.\n\nIf the PRINTER_PRINT_RANSOMNOTE_FLAG in the configuration is 1, the malware retrieves the current\ndirectory of the ransomware executable with GetCurrentDirectoryW and drops a ransom note file in there.\n\n\n-----\n\n_Figure 40: Function to drop ransom note file._\n\nThen, it calls GetDefaultPrinterW to retrieve the system’s default printer and calls ShellExecuteW to execute\nthe print command to print the ransom note.\n\n\n-----\n\n_Figure 41: Function to print ransom note file._\n\n## Run-Once Mutex\n\nIf the CREATE_MUTEX_FLAG in the configuration is 1, the malware checks if there is another instance of\nitself running by checking if the mutex below already exists using CreateMutex.\n```\n- Global\\<MD4 hash of machine GUID>\n\n```\n\n-----\n\n_Figure 42: Generating mutex name._\n\nIf there is another instance, the malware returns immediately and does not encrypt anything.\n\n_Figure 43: Existing when mutex can’t be opened._\n\nIf there is no other instance running, BlackMatter keeps the mutex opened until it finishes encrypting to\nprevent any other instance of itself from running.\n\n## Wiping Recycle Bins\n\nPrior to file encryption, BlackMatter wipes the recycle bin folder of every drive on the system.\n\nFor each drive, the malware manually iterates through folders in the first layer of the drive and stops when it\nfinds the first folder with “recycle” in the name.\n\n\n-----\n\n_Figure 44: Finding Recycle Bin in drives._\n\nAfterward, it uses FindFirstFileEx and FindNextFileW to iterate through the Recycle Bin folder and looks for\nall folders that begins with “S-“. Once found, the folders and their contents are recursively deleted using\n**DeleteFileW.**\n\n\n-----\n\n_Figure 45: Wiping Recycle Bin._\n\nThis function to wipe Recycle Bin is called on every fixed and removable logical drives on the system.\n\n\n-----\n\n_Figure 46: Wiping all Recycle Bins._\n\n## Shadow Copies Deletion Through WMI\n\nThe malware calls CoCreateInstance to create an IWbemLocator object using the IID {DC12A687-737F_11CF-884D-00AA004B2E24} and CLSID {CB8555CC-9128-11D1-AD9B-00C04FD8FDFF}._\n\nIt then calls CoCreateInstance to create an IWbemContext object using the CLSID {674B6698-EE92-11D0_AD71-00C04FD8FDFF}._\n\nIf the system architecture is x64, it calls the IWbemContext::SetValue function to set the value of\n**“__ProviderArchitecture” to 64.**\n\n**BlackMatter calls the IWbemLocator::ConnectServer method to connect with the local ROOT\\CIMV2**\nnamespace and obtain the pointer to an IWbemServices object.\n\n\n-----\n\n_Figure 47: Connecting to ROOT\\CIMV2 for IWbemServices Object._\n\nNext, it calls IWbemServices::ExecQuery to execute the WQL query below to get the\n**IEnumWbemClassObject object for querying shadow copies.**\n```\nSELECT * FROM Win32_ShadowCopy\n\n```\nThe malware calls IEnumWbemClassObject::Next to enumerate through all shadow copies on the system,\n**IEnumWbemClassObject::Get to get the ID of each shadow copies, and IWbemServices::DeleteInstance**\nto delete them.\n\n_Figure 48: Deleting shadow copies through WMI._\n\n\n-----\n\n## Terminating Services through Service Control Manager\n\nIf the STOP_SERVICES_AND_DELETE_FLAG field is set to true in the configuration, BlackMatter\nterminates and deletes all services whose name’s hash is in the SERVICES_TO_KILL list in the configuration.\n\nFirst, the malware calls OpenSCManagerW to get a service control manager handle for active services.\n\nIt then calls EnumServicesStatusExW to enumerate the name of all Win32 services. If the hash of the\nservice name is in the list, the malware terminates it by calling ControlService to send the\n**SERVICE_CONTROL_STOP control code to the service handle.**\n\nThen, it calls DeleteService to completely delete the service.\n\n_Figure 49: Enumerating and deleting services._\n\n## Terminating Processes\n\nIf the TERMINATE_PROCESSES_FLAG field is set to true in the configuration, BlackMatter terminates all\nprocesses whose name’s hash is in the PROCESSES_TO_KILL list in the configuration.\n\nThe malware calls NtQuerySystemInformation to query and enumerate through all system’s processes.\n\nIf the hash of the process’s name is in the list, BlackMatter terminates it by calling NtOpenProcess using the\nprocess’s ID to retrieve the process handle and NtTerminateProcess to terminate it.\n\n\n-----\n\n_Figure 50: Terminating target processes._\n\n## File Encryption\n\nLike REvil and Darkside, BlackMatter uses multithreading with I/O completion port to communicate between\na parent thread- (check and send files) and the child threads (encrypt files) to speed up encryption.\n\n### Multithreading: Parent Thread\n\nIn BlackMatter multithreading setup, the parent thread is spawned after the child threads.\n\nThis parent thread function receives a parameter of a file/directory path. It first checks if this path is a directory\nor not.\n\nIf the path is a directory, the malware escalates the parent thread’s base priority level to\n**THREAD_PRIORITY_HIGHEST.**\n\nNext, it allocates memory for an array to store sub-directories inside of the target directory to encrypt.\n\n\n-----\n\n_Figure 51: Parent thread: Processing directory._\n\nThe parent thread proceeds to drop a ransom note in the target directory and begins enumerating through the\ndirectory using FindFirstFileExW and FindNextFileW.\n\nIt avoids all files and sub-directories with names ”.” and ”.” and with the attributes\n**FILE_ATTRIBUTE_REPARSE_POINT and FILE_ATTRIBUTE_SYSTEM.**\n\n_Figure 52: Parent thread: Processing sub-files and sub-directories._\n\nIf BlackMatter finds a sub-directory, it checks if the hash of the name of the directory is in the\n**FOLDER_HASHES_TO_AVOID list or if the name is “windows.**\n\n\n-----\n\n_Figure 53: Parent thread: Checking directory names._\n\nBelow is the list of folder names whose hash is in FOLDER_HASHES_TO_AVOID.\n```\nsystem volume information\nintel\n$windows.~ws\napplication data\n$recycle.bin\nmozilla\nprogram files (x86)\nprogram files\n$windows.~bt\npublic\nmsocache\nwindows\ndefault\nall users\ntor browser\nprogramdata\nboot\nconfig.msi\ngoogle\nperflogs\nappdata\nwindows.old\n\n```\nIf the sub-directory is valid to encrypt, BlackMatter adds it to the back of the directory array.\n\nAfter finish enumerating the target directory, BlackMatter walks through the directory array and enumerates\nthe directories listed in there. This allows multilayered traversal through directories without using recursion,\nwhich significantly improves performance by eliminating the stack overhead from recursive calls.\n\n\n-----\n\n_Figure 54: Parent Thread: Multilayered directory traversal._\n\nIf it finds a file, the filename is checked against the FILE_HASHES_TO_AVOID list and the file extension is\nchecked against the EXTENSION_HASHES_TO_AVOID list.\n\n_Figure 55: Parent Thread: Checking filenames and extensions._\n\nBelow is the list of filenames whose hash is in the FILE_HASHES_TO_AVOID list.\n\n\n-----\n\n```\n    p\nautorun.inf\nntldr\nbootsect.bak\nthumbs.db\nboot.ini\nntuser.dat\niconcache.db\nbootfont.bin\nntuser.ini\nntuser.dat.log\n\n```\nBelow is the list of extensions whose hash is in the EXTENSION_HASHES_TO_AVOID list.\n```\nthemepack\nnls\ndiagpkg\nmsi\nlnk\nexe\ncab\nscr\nbat\ndrv\nrtp\nmsp\nprf\nmsc\nico\nkey\nocx\ndiagcab\ndiagcfg\npdb\nwpx\nhlp\nicns\nrom\ndll\nmsstyles\nmod\nps1\nics\nhta\nbin\ncmd\nani\n386\nlock\ncur\nidx\nsys\ncom\ndeskthemepack\nshs\nldf\ntheme\nmpa\nnomedia\nspl\ncpl\nadv\nicl\nmsu\n\n```\n\n-----\n\nIf the file passes these checks, the parent thread will send it to the child threads to be encrypted.\n\nIf the file is a link with .lnk extension, BlackMatter manually resolves the link to get the full path to the file\nbefore encrypting it.\n\nFirst, using the LinkCLSID of {00021401-0000-0000-C000-000000000046} and the IShellLinkW RIID of\n**{000214F9-0000-0000-C000-000000000046}, the malware retrieves an IShellLinkW interface.**\n\nUsing the QueryInterface function of the IShellLinkW interface with the IPersistFile RIID {0000010b-00000000-C000-000000000046}, the malware retrieves the IPersistFile interface.\n\nIt calls the IPersistFile->Load function to load the link file to read.\n\nAfter loading, BlackMatter calls IShellLinkW->GetPath to retrieves the full file path from the link.\n\n_Figure 56: Resolving full path from link._\n\n### Multithreading: Parent Thread Communication\n\n**File Owner Termination**\n\nBefore sending a file to child threads to be encrypted, the parent thread terminates all processes/services that\nare currently accessing the file using the Windows Restart Manager.\n\n**BlackMatter first calls RmStartSession to start a new Restart Manager session, RmRegisterResources to**\nregister the target file with the Restart Manager as a resource, and RmGetList to get a list of all applications\nand services that are currently using it.\n\n\n-----\n\n_Figure 57: Parent thread: Registering file with Restart Manager._\n\nIt iterates through the list of processes and services and terminates all whose application type is not\n**RmCritical and RmExplorer**\n\n_Figure 58: Parent thread: Iterating and terminating file owners._\n\nTo terminate a service, BlackMatter calls OpenSCManagerW to establishes a connection to the service\ncontrol manager, OpenServiceW to obtain a handle to the target service, ControlService to send the control\nstop code to the service to stop it, and DeleteService to delete it.\n\n\n-----\n\n_Figure 59: Service deletion._\n\nTo terminate a process, BlackMatter calls NtOpenProcess to obtain a handle to the target process and\n**NtTerminateProcess to terminate it.**\n\n_Figure 60: Process termination._\n\n**Check If File Is Already Encrypted**\n\nAt the end of the encryption, the RSA_encrypted_ChaCha20_matrix_Checksum and\n**RSA_encrypted_ChaCha20_matrix fields in the KeyBuffer structure from** Cryptographic Keys Setup are\nappended to the file footer.\n\n\n-----\n\nWhen BlackMatter needs to check if a file is encrypted, it extracts the memory buffer where the\n**RSA_encrypted_ChaCha20_matrix field is supposed to be, generates its checksum, and compares it to the**\nvalue at where the RSA_encrypted_ChaCha20_matrix_Checksum field is supposed to be.\n\n_Figure 61: Check if file is already encrypted._\n\n**Checking Large File**\n\nA feature to process large files is added to BlackMatter v2.0.\n\nWhen the ENCRYPT_LARGE_FILE_FLAG is true in the configuration, the malware checks if the file is a large\nfile through its extension.\n\nIf the file’s extension is in the list below, then the file is classified as large.\n```\nmdf\nndf\nedb\nmdb\naccdb\n\n```\nThe lengths of these are quite short and predictable, so I just bruteforce them with a Python script.\n\n\n-----\n\n_Figure 62: Check if file is large._\n\n**Thread Shared Structure**\n\nPrior to populating the shared structure between parent and child threads, the malware appends the encrypted\nextension to the file path and calls MoveFileExW to move the original file’s content to this new filename.\n\nIn the case where the new filename already exists, the malware manually adds -[number] to the filename\nbefore the extension where number is incremented from 0 until the filename does not exist in the folder.\n\n_Figure 63: Create file with encrypted extension._\n\nThe shared structure is used by threads to communicate with each other.\n\nBelow is my rough recreation of this structure based on the offset of the fields.\n\n\n-----\n\n```\n{\n LONGLONG errorCode;\n DWORD originalfilePointerLow;\n DWORD originalfilePointerHigh;\n int padding;\n DWORD filePointerLow;\n DWORD filePointerHigh;\n DWORD skippedBytesLow;\n DWORD skippedBytesHigh;\n HANDLE fileHandle;\n DWORD threadCurrentState;\n BYTE rawChaCha20Matrix[124];\n DWORD fileSize;\n BYTE padding2[368];\n BYTE fileFooter[132];\n DWORD *bytesToRead;\n BYTE *bufferToReadData;\n};\n\n```\nFirst, the parent thread checks the file size to populate the bytesToRead field. If the file size is 0x100000\nbytes or more, the bytesToRead value is maxed out at 0x100000. This means file data is read and encrypted\nin 0x100000-byte chunks.\n\n_Figure 64: Setting encrypting size._\n\n**BlackMatter then populates the rawChaCha20Matrix and fileFooter field with the buffers generated in**\nCryptographic Keys Setup.\n\nEach of these buffers is dedicated to a specific skipped size between chunks.\n\nBelow is the conversion between the file size the skipped size between chunks.\n\n**File Type** **File Size** **Skipped Size**\n\nSmall Any size 0 byte\n\nLarge Less than 0x8000000 bytes 0x200000 bytes\n\nLarge Between 0x8000000 and 0x20000000 - 1 bytes 0x400000 bytes\n\nLarge Between 0x20000000 and 0x80000000 - 1 bytes 0x800000 bytes\n\nLarge Between 0x80000000 and 0x200000000 - 1 bytes 0x1000000 bytes\n\nLarge Between 0x200000000 and 0x800000000 - 1 bytes 0x2000000 bytes\n\nLarge Between 0x800000000 and 0x2000000000 - 1 bytes 0x4000000 bytes\n\nLarge Between 0x2000000000 and 0x8000000000 - 1 bytes 0x8000000 bytes\n\n\n-----\n\n**File Type** **File Size** **Skipped Size**\n\nLarge Between 0x8000000000 and 0x20000000000 - 1 bytes 0x10000000 bytes\n\nLarge Between 0x20000000000 and 0x80000000000 - 1 bytes 0x20000000 bytes\n\nLarge Equal or greater than 0x80000000000 0x40000000 bytes\n\nFrom looking up the size of the file on the table above, BlackMatter chooses the appropriate ChaCha20\nmatrix used to encrypt files.\n\n_Figure 65: Populating Encryption Fields In Shared Structure._\n\nFinally, the parent thread registers the target file handle with the global I/O completion port using\n**CreateIoCompletionPort, sets the fileHandle field in the structure to the file handle and the**\n**threadCurrentState field to the initial state, and sends the shared structure to child threads using**\n**PostQueuedCompletionStatus to begin encryption.**\n\n\n-----\n\n_Figure 66: Sending shared structure to child threads._\n\n### Multithreading: Child Threads Encryption\n\nChild threads communicate with each other and the main thread using GetQueuedCompletionStatus and\n**PostQueuedCompletionStatus.**\n\nEach thread constantly polls for an I/O completion packet from the global I/O completion port. The packet\nreceived from GetQueuedCompletionStatus contains an file’s BlackmatterFileStruct structure to be\nprocessed.\n\n_Figure 67: Sending shared structure to child threads._\n\nThe encryption process is divided into four states. The file’s current state is recorded in the\n**threadCurrentState of the shared structure.**\n\n**I. State 0: Reading File**\n\nThe first state reads a number of bytes specified by the bytesToRead field into the buffer at the\n**bufferToReadData field using ReadFile.**\n\nIf ReadFile throws the error ERROR_IO_PENDING, the malware enters an infinite loop of sleeping for 100ms\nand calling ReadFile until it succeeds.\n\nIf ReadFile throws the error ERROR_HANDLE_EOF, the malware sets the encryption state to 2, else the\nencryption state is set to 1.\n\n\n-----\n\n_Figure 68: State 0: Reading file._\n\n**II. State 1. Encrypt and Write File**\n\nThe second state encrypts the buffer at the bufferToReadData field using its modified ChaCha20\nimplementation.\n\nAfter the encryption, the malware calls WriteFile to write the encrypted data back into the file.\n\nIf ReadFile throws the error ERROR_IO_PENDING, the malware enters an infinite loop of sleeping for 100ms\nand calling WriteFile until it succeeds.\n\nIf the skipped size is not zero, BlackMatter moves the file pointer ahead to the next chunk by adding that\nskipped size to the current pointer.\n\n\n-----\n\n_Figure 69: State 1: Encrypting and writing file._\n\nIf the skipped size is zero, the malware stops encrypting after the first 0x100000 bytes and moves to state 2.\n\nBlackMatter Custom ChaCha20\n\nI want to discuss a bit about the customized ChaCha20 implementation of BlackMatter, instead of just\nglancing over it and calling it “customized”.\n\n[Full credit of this section goes to Michael Gillespie for figuring out this crypto implementation and helping me](https://twitter.com/demonslay335)\nunderstand it!\n\nIt seems like the implementation of BlackMatter v2 is the modified version of CryptoPP’s ChaCha20\n[implementation that can be found here.](https://github.com/weidai11/cryptopp/blob/bc7d1bafa1e8ac732396374f0bca94ab9f396f1c/chacha_simd.cpp#L569)\n\nUnlike a lot of ChaCha implementation, this one utilizes the __m128i type to store the states in xmm regiters.\n\nDespite allocating 124 bytes for the “matrix”, BlackMater only uses the first 64 bytes and turns it into a 128byte state by mirroring the first 64 bytes with the last 64 bytes.\n\nAfter performing 20 rounds of flipping and rotating using that state, the malware generates a 128-byte stream\nto encrypt the data coming in.\n\n\n-----\n\n_Figure 69: Custom ChaCha20 implementation._\n\n**III. State 2. Write File Footer**\n\nThis state is executed only when the file encryption is complete.\n\n\n-----\n\n_Figure 70: State 2: Write file footer._\n\nThe malware calls WriteFile to write the 132-byte buffer from the fileFooter field in the shared structure to the\nend of the file.\n\nThis buffer contains the RSA_encrypted_ChaCha20_matrix_Checksum and the\n**RSA_encrypted_ChaCha20_matrix fields in the structure from** Cryptographic Keys Setup, which are used to\ncheck if a file is encrypted and to decrypt it.\n\nAfter this state, the malware moves to state 3.\n\n**IV. State 3. Clean Up**\n\nThis is the last state in the file encryption process.\n\nIn this state, BlackMatter calls NtClose to close the file handle, calls RtlFreeHeap to free the shared structure\nbuffer from memory, and increments the global TOTAL_NUM_FILE_ENCRYPTED value.\n\n_Figure 71: State 3: Clean up._\n\n**Child Thread Communication**\n\n\n-----\n\nIn BlackMatter s multithreading setup, each child thread only handles one state in the encryption process.\n\nAfter each state (beside the final state), the malware calls PostQueuedCompletionStatus to post the shared\nstructure to the global I/O completion port with the updated encryption state. The next thread who receives it\nthen processes that state before moving it forward.\n\n_Figure 72: Child thread communication._\n\n### Exchange Mailbox Traversal\n\nIf the MOUNT_VOL_AND_ENCRYPT_FLAG in the configuration is set to true, BlackMatter encrypts the\nExchange mailbox of the local user.\n\nFirst, it calls GetEnvironmentVariableW to retrieve the Exchange installation path.\n\n_Figure 73: Retrieving Exchange installation path._\n\n\n-----\n\nAfter retrieving the path, the malware checks to make sure it is in the Program Files directory (64-bit\nExchange installation) and append /Mailbox to the path.\n\n_Figure 74: Building full Exchange mailbox path._\n\nFinally, BlackMatter spawns threads to encrypt this path using the encryption scheme described above.\n\n_Figure 75: Traversing and encrypting Exchange mailbox path._\n\n### Logical Drives Traversal\n\nIf the MOUNT_VOL_AND_ENCRYPT_FLAG in the configuration is set to true, BlackMatter mounts and\nencrypts all logical drives.\n\nFirst, the malware enumerates through all volumes on the computer using FindFirstVolumeW and\n**FindNextVolumeW. It calls GetVolumePathNamesForVolumeNameW to retrieve the path of the volume and**\nprocesses the drive at that path.\n\n\n-----\n\n_Figure 76: Volume enumeration._\n\nIt only processes and encrypts drives with type DRIVE_FIXED or DRIVE_REMOVABLE.\n\nIf the current OS is Windows 7 or above, the malware calls DeviceIoControl to get the partition information of\nthe target drive.\n\nIf the partition type of the drive is PARTITION_STYLE_GPT, BlackMatter sets some check with the partition\ntype data and calls SetVolumeMountPointW to mount it.\n\nIf the partition type of the drive is PARTITION_STYLE_MBR, BlackMatter calls SetVolumeMountPointW to\nmount it.\n\n_Figure 77: Mounting drives._\n\n\n-----\n\nIf the current OS is earlier than Windows 7, the malware appends /bootmgr to the end of the drive path and\ncalls SetVolumeMountPointW to mount it.\n\n_Figure 78: Mounting bootmgr._\n\nNext, BlackMatter calls GetLogicalDriveStringsW to get the list of all logical drives on the system.\n\nFor each of these drives that are DRIVE_REMOTE, DRIVE_FIXED, or DRIVE_REMOVABLE, the malware\nspawns threads to encrypt this path using the encryption scheme described above.\n\nIf the drive type is DRIVE_REMOTE, BlackMatter impersonates the parent thread with the obtained token.\n\n_Figure 79: Traversing and encrypting logical drives._\n\n### Network Shares Traversal\n\n\n-----\n\nIf the NETWORK_ENCRYPT_FLAG in the configuration is set to true, BlackMatter encrypts all network\nshares.\n\nFirst, it retrieves the list of all DNS hostnames on the network through domain controllers.\n\n**BlackMatter calls DsGetDcNameW to obtain the domain controller information and DsGetDcOpenW to open**\na new domain controller enumeration operation.\n\n_Figure 80: Open domain controller enumeration operation._\n\nBy calling DsGetDcNextW, the malware enumerates through all domain controller on the network and adds it\nto an array.\n\n\n-----\n\n_Figure 81: Enumerating domain controllers._\n\nNext, for each domain controller, BlackMatter calls ADsOpenObject(“LDAP://rootDSE”, 0, 0, 1u,\n**“{FD8256D0-FD15-11CE-ABC4-02608C9E7553}”, &IADs_object) to retrieve the IADs COM interface.**\n\nUsing the Get function of the IADs interface, it gets the default naming context of the domain.\n\n_Figure 82: Get domain default naming context._\n\nWith the default naming context, BlackMatter builds the string “LDAP://CN=Computers,[default naming\n**context]” and calls ADsOpenObject to retrieve an IADsContainer interface.**\n\nUsing that interface, it calls ADsBuildEnumerator to create an enumerator object for the specified ADSI\ncontainer object. Finally, using the enumerator, the malware calls ADsEnumerateNext to enumerate through\nall DNS hostnames from the domain controller.\n\n\n-----\n\n_Figure 83: Enumerating DNS hostnames._\n\nWith a list of DNS hostnames on the network, the malware calls NetShareEnum to start enumerating through\neach of them.\n\nIf the network share type is not special share reserved for interprocess communication (IPC$) or remote\nadministration of the server (ADMIN$), the malware skips it and does not add it to the share list to encrypt.\n\n_Figure 84: Checking network share type._\n\nIf the network share type is special, the malware performs an additional check and skips the share if the\nnetwork name is “admin$“ or ”$c”.\n\n\n-----\n\n_Figure 85: Checking network name._\n\nFinally, BlackMatter fixes up the network paths and spawns threads to encrypt these paths using the\nencryption scheme described above.\n\n_Figure 86: Traversing and encrypting network share._\n\n## Network Communication\n\nIf the SEND_DATA_TO_SERVER_FLAG in the configuration is set to true, BlackMatter sends data twice to\nremote servers, once prior to the encryption and once after the encryption.\n\nPrior to the encryption, the malware sends information about the victim’s machine to the servers.\n\nIt extracts information about the host and different disks on the system and builds the string using the format\nbelow.\n\n\n-----\n\n```\n{\n  \"bot_version\":\"%s\",\n  \"bot_id\":\"%s\",\n  \"bot_company\":\"%.8x%.8x%.8x%.8x%\",\n  \"host_hostname\":\"%s\",\n  \"host_user\":\"%s\",\n  \"host_os\":\"%s\",\n  \"host_domain\":\"%s\",\n  \"host_arch\":\"%s\",\n  \"host_lang\":\"%s\",\n  \"disks_info\":[\n   {\n     \"disk_name\":\"%s\", // for each disk\n     \"disk_size\":\"%u\",\n     \"free_size\":\"%u\"\n   }\n  ]\n}\n\n```\nBelow is an example of the payload generated on my VM.\n```\n{\n  \"bot_version\":\"2.0\",\n  \"bot_id\":\"e6175d544e3816664c0c6297cf8bcb18\",\n  \"bot_company\":\"00000000000000000000000000000000\",\n  \"host_hostname\":\"MSEDGEWIN10\",\n  \"host_user\":\"IEUser\",\n  \"host_os\":\"Windows 10 Enterprise Evaluation\",\n  \"host_domain\":\"WORKGROUP\",\n  \"host_arch\":\"x64\",\n  \"host_lang\":\"en-US\",\n  \"disks_info\":[\n   {\n     \"disk_name\":\"C\",\n     \"disk_size\":\"40957\",\n     \"free_size\":\"17290\"\n   },\n   {\n     \"disk_name\":\"Z\",\n     \"disk_size\":\"487290\",\n     \"free_size\":\"304117\"\n   }\n  ]\n}\n\n```\n\n-----\n\n_Figure 87: Host format string._\n\nThis buffer is encrypted and sent to remote servers specified in the REMOTE_SERVER_URLS field in the\nconfiguration.\n\nAfter the file encryption, the malware sends encryption stats to the servers.\n\nThe information about encryption stats is built into a string using the format below.\n```\n{\n  \"bot_version\":\"%s\",\n  \"bot_id\":\"%s\",\n  \"bot_company\":\"%.8x%.8x%.8x%.8x%\",\n  \"stat_all_files\":\"%u\",\n  \"stat_not_encrypted\":\"%u\",\n  \"stat_size\":\"%s\",\n  \"execution_time\":\"%u\",\n  \"start_time\":\"%u\",\n  \"stop_time\":\"%u\"\n}\n\n```\n\n-----\n\n_Figure 88: Encryption stats format string._\n\nWhen sending these data to remote servers, BlackMatter first encrypts it using the AES key from the\nconfiguration and Base64-encodes it.\n\n_Figure 89: Data encryption and encoding._\n\nNext, it randomly generates HTTP object names and POST request data.\n\n**BlackMatter uses the following user agent.**\n```\nAppleWebKit/587.38 (KHTML, like Gecko)\n\n```\nIt also decrypts and uses this POST request header.\n\n\n-----\n\n```\n  p\nConnection: keep-alive\nAccept-Encoding: gzip, deflate, br\nContent-Type: text/plain\n\n```\nFinally, the malware uses the typical HTTP WinAPI calls such as InternetOpenW to obtain an internet handle,\n**InternetConnectW to obtain a connection handle with a target URL, HttpOpenRequestW to open a POST**\nrequest, and HttpSendRequestW to send the encrypted data.\n\n_Figure 90: Sending data to remote servers._\n\n## Weird Threading Stuff\n\nI want to dedicate a section to talk about this because it annoys the hell out of me.\n\nIt seems like BlackMatter loves to use this one trick to spawn a single thread to execute a single WinAPI call.\n\n\n-----\n\n_Figure 91: Single threading with extra steps._\n\nI must admit that this does work, and I can definitely see the reason behind this. The malware wants to make\nAPI calls while impersonating as a different process using the token it gets from here to be stealthier.\n\nSo why am I annoyed? It’s just really extra.\n\nThis whole part of code can be reduced to a single GetUserNameW call, which is why it is so inefficient.\nMoreover, they have a ransomware running that encrypts a system in less than a minute. Trying to be stealthy\nto call things like GetUserNameW and GetDriveTypeW might just be an overkill.\n\nOr maybe this method is fine and I’m just grumpy cause this ransomware is so damn long to fully analyze\nlmao.\n\n## References\n\nhttps://github.com/weidai11/cryptopp/blob/bc7d1bafa1e8ac732396374f0bca94ab9f396f1c/chacha_simd.cpp#L569\n\nhttps://github.com/sisoma2/malware_analysis/tree/master/blackmatter\n\nhttps://github.com/advanced-threat-research/DarkSide-Config-Extract\n\nhttps://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/wp-ransomware-protection-andcontainment-strategies.pdf\n\nhttps://www.installsetupconfig.com/win32programming/networkmanagementapis16_41.html\n\nhttps://www.youtube.com/watch?v=R4xJou6JsIE\n\nhttps://blog.digital-investigations.info/2021-08-05-understanding-blackmatters-api-hashing.html\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-05 - BlackMatter Ransomware v2.0.pdf"
    ],
    "report_names": [
        "2021-09-05 - BlackMatter Ransomware v2.0.pdf"
    ],
    "threat_actors": [
        {
            "id": "d18fe42c-8407-4f96-aee0-a04e6dce219a",
            "created_at": "2023-01-06T13:46:38.275292Z",
            "updated_at": "2025-03-27T02:00:02.79092Z",
            "deleted_at": null,
            "main_name": "APT12",
            "aliases": [
                "Calc Team",
                "IXESHE",
                "BRONZE GLOBE",
                "BeeBus",
                "DynCalc",
                "DNSCalc",
                "Crimson Iron",
                "NUMBERED PANDA",
                "TG-2754",
                "Group 22"
            ],
            "source_name": "MISPGALAXY:APT12",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c5f79f58-db78-4cd7-88cf-c029a2199360",
            "created_at": "2022-10-25T16:07:23.325227Z",
            "updated_at": "2025-03-27T02:02:09.738383Z",
            "deleted_at": null,
            "main_name": "APT 12",
            "aliases": [
                "APT 12",
                "BeeBus",
                "Bronze Globe",
                "CTG-8223",
                "Calc Team",
                "Crimson Iron",
                "DNSCalc",
                "DynCALC",
                "Group 22",
                "Numbered Panda"
            ],
            "source_name": "ETDA:APT 12",
            "tools": [
                "AUMLIB",
                "ETUMBOT",
                "Exploz",
                "Graftor",
                "HIGHTIDE",
                "IHEATE",
                "IXESHE",
                "RIPTIDE",
                "RapidStealer",
                "Specfix",
                "THREEBYTE",
                "bbsinfo",
                "mswab",
                "yayih"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535765,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653693845,
    "ts_modification_date": 1653693845,
    "files": {
        "pdf": "https://archive.orkl.eu/fab7a63e34a35178f20d247d6e4f033eaab83677.pdf",
        "text": "https://archive.orkl.eu/fab7a63e34a35178f20d247d6e4f033eaab83677.txt",
        "img": "https://archive.orkl.eu/fab7a63e34a35178f20d247d6e4f033eaab83677.jpg"
    }
}