{
    "id": "71942c10-5b7b-4cdd-9a45-c80b3cba34a3",
    "created_at": "2022-10-25T16:48:19.346593Z",
    "updated_at": "2025-03-27T02:16:25.496954Z",
    "deleted_at": null,
    "sha1_hash": "cff91247e1bd92689e2da874dd1b357b45705c63",
    "title": "",
    "authors": "",
    "file_creation_date": "2016-11-26T16:18:25Z",
    "file_modification_date": "2016-11-26T16:18:25Z",
    "file_size": 374646,
    "plain_text": "##### How Anywhere Computing Just Killed Your Phone-Based Two-Factor Authentication\n\nRadhesh Krishnan Konoth[†], Victor van der Veen[†], and Herbert Bos\n\n_†Equal contribution joint first authors_\n\nVrije Universiteit Amsterdam, The Netherlands\n```\n         r.k.konoth@vu.nl,{vvdveen,herbertb}@cs.vu.nl\n\n```\n**Abstract. Exponential growth in smartphone usage combined with re-**\ncent advances in mobile technology is causing a shift in (mobile) app\nbehavior: application vendors no longer restrict their apps to a single\nplatform, but rather add synchronization options that allow users to\nconveniently switch from mobile to PC or vice versa in order to access\ntheir services. This process of integrating apps among multiple platforms\nessentially removes the gap between them. Current, state of the art, mobile phone-based two-factor authentication (2FA) mechanisms, however,\nheavily rely on the existence of such separation. They are used in a variety of segments (such as consumer online banking services or enterprise\nsecure remote access) to protect against malware. For example, with\n2FA in place, attackers should no longer be able to use their PC-based\nmalware to instantiate fraudulent banking transactions.\nIn this paper, we analyze the security implications of diminishing gaps\nbetween platforms and show that the ongoing integration and desire\nfor increased usability results in violation of key principles for mobile\nphone 2FA. As a result, we identify a new class of vulnerabilities dubbed\n_2FA synchronization vulnerabilities. To support our findings, we present_\npractical attacks against Android and iOS that illustrate how a Manin-the-Browser attack can be elevated to intercept One-Time Passwords\nsent to the mobile phone and thus bypass the chain of 2FA mechanisms\nas used by many financial services.\n\n**Keywords: Two-Factor Authentication, Smartphone Security, Finan-**\ncial Trojans, Synchronization, Anywhere Computing\n\n###### 1 Introduction\n\nApproaching an impressive 1.25 billion sales in 2014 with an expected audience of over 1.75 billion, smartphones have become an important factor in many\npeople’s day-to-day life [35, 17]. Daily activities performed on these mobile devices include those that can be done on PC as well: accessing e-mail, searching\nthe web, social networking, or listening to music [19]. To enhance usability, both\napplication developers and platform vendors are making an effort to blur boundaries between the two platforms. This is reflected in synchronization features like\n\n\n-----\n\nFirefox Sync and Samsung SideSync or sophisticated market places like Google\nPlay and Microsoft’s Windows Store that allow users to manage their mobile\nphone remotely.\nA second important trend in web computing is the increasing number of applications that provide the possibility to harden user accounts by enabling 2 Factor\n_Authentication (2FA) for them. 2FA is a form of multi-factor authentication and_\nprovides unambiguous identification of users by means of the combination of\ntwo different components, i.e., something the user knows (PIN code, password)\nand something the user possesses (bank card, USB stick token). With 2FA enabled, if attackers steal a user’s password, they still require access to the second\ncomponent before they can impersonate the victim.\nNot surprisingly, software vendors often embody the second component of\n2FA in the form of a mobile phone. To authenticate, the web application sends\na one-time-valid, dynamic passcode to the user’s mobile phone (for instance via\nSMS, e-mail, or a dedicated application), which must then be entered along\nwith the user’s credentials in order to complete the authentication. Since users\nusually carry their phone all the time, Mobile Phone 2FA does not introduce\nadditional costs and can be implemented relatively easy. Examples of well-known\ncompanies that provide mobile phone 2FA include Amazon, Apple, Dropbox,\nGoogle, Microsoft, Twitter, Yahoo, and many more, including a large number of\nfinancial institutions[1]. The latter is represented by many of the biggest financial\norganisations in the world such as Bank of America, Wells Fargo, JP Morgan\nChan, ICBC in China, and ING in The Netherlands.\nIn this paper, we analyze the security implications of Anywhere Computing\nand show that seamless platform integration comes at the cost of weakening the\n(commonly perceived) strong mobile phone 2FA mechanism. We define a new\nclass of vulnerabilities dubbed 2FA synchronization vulnerabilities and show how\nthese can be exploited by an attacker. In particular, we present reliable attacks\nagainst both Android and iOS, two platforms that represent a combined market\nshare of over 90% [6]. Our threat model is the same as that of 2FA: we assume that a victim’s PC has been compromised, allowing an attacker to perform\nMan-in-the-Browser (MitB) attacks. In this scenario, mobile phone 2FA should\nguarantee that the attacker cannot perform authorized operations without having also access to the user’s phone. By exploiting certain 2FA synchronization\nvulnerabilities, however, we show that mobile phone 2FA as used by many online\nservices for secure authentication, including financial institutions, can be easily\nbypassed.\nIn more detail, our first attack utilizes Google Play’s remote app installation\nfeature to install a specifically crafted vulnerable app onto registered Android\ndevices of the victim which is then silently activated and used to hijack OneTime Passwords (OTPs). Our iOS attack, on the other hand, exploits a new\nOS X feature that enables the synchronization of SMS messages between iPhone\nand Mac.\n\n1 http://twofactorauth.org\n\n\n-----\n\nAlthough the security of 2FA implementations has been subject of prior\nwork [16], we believe that our work is the first to address weaknesses relating to\nongoing synchronization and usability enhancement efforts.\n\n**Contributions. In summary, our contributions are the following:**\n\n1. We identify a new class of vulnerabilities, 2FA synchronization vulnerabili_ties, that weaken the security guarantees of mobile phone 2FA._\n2. We present practical attacks against Android and iOS that exploit multiple 2FA synchronization vulnerabilities and show how these can be used to\nsuccessfully bypass mobile phone 2FA.\n3. We discuss the security implications of our findings and provide recommendations for various stakeholders. Based on our findings, we conclude that\nSMS-based 2FA should be considered unsafe.\n\nThe remainder of this paper is organized as follows. In Section 2, we outline\ncurrent efforts deployed by vendors that ease platform integration and provide\na definition of 2FA synchronization vulnerabilities. Section 3 details our attacks\nagainst Android and iOS which can be used to bypass mobile phone 2FA. We\ndiscuss security implications and recommendations in Section 4, followed by a\nrelated work study on the evolution of Man-in-the-Browser attacks and 2FA in\nSection 5. We conclude in Section 6.\n\n###### 2 Synchronization\n\nTo maximize connectivity and to ensure that users never miss another status\nupdate, vendors continuously come up with ways to close the gap between PC\nand mobile devices. In this section, we separate these integration techniques\ninto two categories: (i) remote services as provided by mobile operating system\nvendors and (ii) integration of applications across the different platforms using\nsynchronization features. Finally, we define 2FA synchronization vulnerabilities\nin detail and show example vulnerabilities that we later use to break mobile\nphone 2FA.\n\n**2.1** **Remote Services**\n\nMobile operating system market leader Google provides a remote install service\nin its Play Store that allows users to install Android applications on any of their\nphones or tablets, from a desktop computer. The process is painless and straightforward: a user (i) logs into the Google Play store, (ii) picks an app of his interest,\n(iii) hits the install button, (iv) accepts the app’s permissions, (v) chooses the\ndevice on which this app should be installed, and (vi) confirms installation. The\napp is now automatically pushed and installed onto the selected phone—as soon\nas it has connectivity. Since all the app’s permissions are requested and confirmed in the browser already, the only trace left on the phone is a <app name>\n\n\n-----\n\n_successfully installed notification message. Similar features have been deployed_\nin app stores of both Microsoft (Windows Phone) and Apple (iOS).\nNaturally, platform vendors have adopted security policies to prevent exploitation of this feature. Focussing on Android, for example, Google, deployed\ntwo: (i) silent remote install only works for apps on Google Play, which is actively monitored for malware by Google Bouncer; and (ii) newly installed apps\ndefault to a deactivated state which means that even if the app defines specific event receivers (e.g., on BOOT COMPLETED to start a service at boot-time, or\n```\nSMS RECEIVED to listen for incoming SMS text messages), it cannot use these un\n```\ntil the app is explicitly activated by the user. Activation is triggered by starting\nthe app for a first time, either by selecting it from the launcher or by sending it\nan intent from another app (e.g., by opening a link from the mobile browser) [1].\nIn addition to remote install, platform vendors also provide features that help\nusers in locating or wiping a lost device [2, 7, 5].\n\n**2.2** **App Synchronization**\n\nBesides remote services, developers try to increase usability even further by incorporating cross-platform synchronization features in their applications. This\nis best illustrated by looking at recent changes in browsers. Browsers once were\nself-contained software pieces that ran on a single device. Popular browsers like\nGoogle Chrome or Mozilla Firefox, however, nowadays offer integrated synchronization services. By using these features, users no longer have to configure\nbrowsers individually, but can automatically synchronize all their saved passwords, bookmarks, open tabs, browser history and settings across multiple devices [8, 4]. It is expected that Microsoft’s Edge introduces similar functionality\nsoon [32].\nAnother example of application synchronization is Apple’s Continuity which\nfeatures, among others, synchronization of SMS text messages between iOS (8.1\nand up) and Mac OS X (10.10 Yosemite and later): “with Continuity, all the\nSMS and MMS text messages you send and receive on your iPhone also appear\non your Mac, iPad, and iPod touch” [9].\n\n**2.3** **2FA Synchronization Vulnerabilities**\n\nGiven the ongoing efforts by both platform vendors and application developers to\nbridge the gap between the end-user’s desktop and his or her mobile devices, we\nidentify a new class of vulnerabilities that, while increasing usability, jeopardize\n2FA security guarantees.\n\n**Definition A 2FA synchronization vulnerability is a usability feature that delib-**\n_erately blurs the boundaries between devices, but, potentially combined with other_\n_vulnerabilities, inadvertently weakens the security guarantees of 2FA._\n\nAs an example, consider the previously discussed remote app installation feature: a clear product of a design decision aiming to enhance usability. Although\n\n\n-----\n\nsuch option successfully improves usability indeed—users can conveniently manage their mobile device from their browser—it comes with an obvious security\nrisk: if attackers manage to get control over a user’s browser, they can extend\ncontrol to the user’s mobile devices as well by pushing arbitrary apps to them.\nWe thus identify the remote install feature as a 2FA synchronization vulnerability.\nFocussing again on Android, Google’s deployed security measures make that\nwithout additional vulnerabilities, attackers cannot abuse this synchronization\nvulnerability alone to bypass mobile phone 2FA. Finding such vulnerabilities is\neasy though. First, fundamental weaknesses in Google Bouncer expose multiple ways to bypass malware detection, giving attackers a sufficient time window\nto push malicious apps to Google Play and thus to mobile devices. Second, we\nidentify numerous ways to activate apps after installation, either by exploiting\nend-users’ curiosity (hey, what is this app? ) or by relying on additional synchronization vulnerabilities, for example in browser apps: previously discussed features can be used by an attacker to synchronize malicious bookmarks or browser\ntabs that, when opened on the mobile device, can activate deactive apps.\nA second attack exploits the clear 2FA synchronization vulnerability introduced in recent Mac OS X releases. If Continuity is enabled, there is no need\nfor attackers to control a victim’s phone: they can read SMS messages from an\ninfected Mac directly.\nIt is important to realize that 2FA synchronization vulnerabilities are not\nnecessarily caused by bad developer habits or configuration mistakes. More often,\nthey will be the result of a design decision-making process. This means that it\nis much harder to convince vendors of their mistakes: a 2FA synchronization\nvulnerability does not leak data or enable code execution, but must be considered\nwithin the mobile phone 2FA threat model before it becomes a threat.\n\n###### 3 Exploiting 2FA Synchronization Vulnerabilities\n\nBy exploiting the synchronization vulnerabilities discussed in Section 2, we can\nconstruct attacks that break mobile phone 2FA. In this section, we present practical implementations of such attacks against the two major mobile operating\nsystems: Google Android and Apple iOS. Additionally, we show that synchronization vulnerabilities also imperil mobile phone 2FA implementations that use\na dedicated app to transfer the OTP.\nOur attacks operate on the basic threat model of 2FA: we assume that the\nattacker already has control over the victim’s PC, possibly including a MitB,\nand is specifically interested in bypassing mobile phone 2FA.\n\n**3.1** **Android**\n\nThe intention of our Android attack is to exploit the remote install feature of\nGoogle Play to push a malicious app onto the user’s mobile device. This app\ncan then intercept and forward OTPs sent as SMS messages to a server that is\n\n\n-----\n\ncontrolled by the attacker. Given that the attackers have control over the user\ncredentials (stolen by the MitB), this gives them sufficient means to bypass 2FA.\nGoogle’s deployed mitigation techniques slightly complicate our scenario. In\norder to successfully break 2FA, we need to address two defenses: (i) we need to\nbypass Google Bouncer before we can publish our SMS stealing app in Google\nPlay, and (ii) we need the user to activate the app before it can intercept and\nforward SMS messages.\n\n**Bypassing Google Bouncer Since Google’s remote install feature only allows**\napp installation from trusted sources, attackers first need to get an SMS stealing\napp published in Google Play. For this, they need to bypass Bouncer, Google’s\nautomated malware analysis tool that uses both static and dynamic analysis to\nidentify malicious behavior [26]. Once an application is uploaded to Google Play,\nBouncer starts analyzing it for known malware, spyware and trojans.\nAlthough the inner workings of Bouncer are kept confidential, prior work has\nshown that it is easily circumvented [29, 30]. This is confirmed by a recent case\nstudy where Avast identified a number of popular Play Store apps that had over\na million downloads to be in fact malware [15].\nOrthogonal to recent work, our approach to trick Bouncer into accepting\nrogue apps is publishing a vulnerable application [36]. By pushing a poorly coded\n```\nWebView application, for example, attackers no longer have to hide malicious code\n\n```\nfrom Bouncer, but can simply move it to a web server that will be contacted\nby the app to display regular data [28]. An alternative, even harder to detect\nscheme, involves exposing a backdoor in native code via a memory corruption\nvulnerability [11].\nTo show the practicality of our attack, we successfully published an SMS\n‘backup’ app in Google Play. Upon SMS reception, our app first writes the message content to a file, followed by loading a remote webpage inside a hidden\nwebview component. The prepared webview component, however, is made vulnerable by exposing a ProcessBuilder class via the addJavascriptInterface\nAPI. This allows the remote webpage to execute arbitrary commands within the\napp’s context using JavaScript.\nRemoving malicious code from the app makes it undetectable for Google\nBouncer’s static analysis. To also hide from dynamic analysis, we construct the\nremote webpage in such a way that it does not serve malicious commands when\nthe incoming connection is made from a Google machine. In practice, to avoid\naccidental misuse, we instructed the webpage to only serve malicious code if\naccessed from an IP address that is under our control.\n\n**App Activation Once installed, Android puts new apps in a deactivated state.**\nWhile deactivated, an app will not run for any reason, except after (i) a manual\nlaunch of its main activity via the launcher, or (ii) an explicit intent from another\napp (e.g., a clicked link from the mobile browser) [22]. Attackers must thus\nsomehow steer their victim into starting the app manually. We identify two\nreliable approaches to achieve this.\n\n\n-----\n\nUser click on:\n\n                                                  - notification\nSynchronization                       - bookmark\n\n                                                                          - ...\n\nFig. 1: Malicious app installation process. Attackers (i) use their deployed MitB to\nrequest the installation of a vulnerable app, stored in Google Play, and replace all the\nbrowser’s bookmarks with malicious variants. Google then (ii) pushes the app onto the\nmobile phone of the victim. Finally (iii) the user is steered into activating the app.\nActivation is achieved by exploiting browser synchronization features to synchronize\nthe malicious bookmarks to the phone, or by exploiting the user’s curiosity (a click on\nthe app is installed notification message).\n\n1. The most naive method is to hide the malicious activity inside an attractive\ncontainer. By using a challenging or even provocative app name or icon, a\nuser may be tempted into opening the app manually, simply out of curiosity.\n2. Armed with both synchronization vulnerabilities and the victim’s Google\ncredentials obtained by the MitB, an attacker can manipulate saved bookmarks, recent tabs, or URLs used in e-mail, cloud documents, social media,\netcetera, in such a way that, when clicked, they redirect to a malicious webpage. This page, controlled by the attacker, can then send the aforementioned\nintent to activate the malicious app.\n\nTo prevent a user from detecting the rogue app after it has been activated, we\ncomplement it with stealth features. Strictly abiding to the Android developers\nguidelines, we constructed our app in such a way that, once activated, it removes\nit’s main icon from the launcher. Additionally, we use a name masquerading\ntechnique to maximize discretion: (i) the app name shown in the notification\nbar is different from (ii) the name of the app as found in the launcher, which\nin its turn differs from (iii) the official app name as shown in the app overview\n(accessible from the settings view). This works because (i) during app submission, the Google Developers Console does not check whether the provided app\nname matches the official app name as found in the uploaded .apk, and (ii) the\n```\n<activity-alias> tag inside the app’s manifest allows us to declare additional\n\n```\nactivity names.\nThe process of installing a vulnerable app and activating it is shown in Figure 1. The stealthy installation via bookmarks (or recent tabs or some other\nobject of synchronization) combined with name obfuscation makes it hard to\ntell that an app is malicious, even for experienced users.\n\n\n-----\n\n|Col1|www.mal.icio.us|Col3|\n|---|---|---|\n\n\nFig. 2: Completing fraudulent transactions while bypassing 2FA. After our app processes the TAN code, it loads a remote webpage into a WebView component that allows\nthe attacker to perform Remote Code Execution (RCE). This way, attackers can hide\ntheir malicious activity from Google Play.\n\n**Breaking 2FA With the malicious/vulnerable app and activation methods in**\nplace, attackers can start their attack from the hijacked browser by requesting\nremote installation for the rogue app. We implemented a MitB trojan for the\nGoogle Chrome browser that can do this. Once installed, our extension can\nuse Google session cookies to start remote app installation and prepare app\nactivation. The plugin basically consists of three phases:\n\n1. Hijack a Google session. Our plugin waits for a Google authentication\ncookie to become available. This happens when the user logs into a Google\ncomponent (e.g., Gmail, YouTube, Drive, etcetera). Optionally, it forwards\nthe typed credentials or cookies over the network to the attacker.\n2. Remote install. Using the hijacked Google session, the trojan sends a request to Google Play to retrieve a list of Device IDs of all Android devices\nlinked to this particular Google account. Next, for each device, the plugin\nrequests remote installation of the vulnerable app. Since app permissions are\napproved from within the PC-based browser only, the app will be silently\ninstalled, leaving only a <app name> successfully installed installation notification on the device.\n3. Activation. In order to allow app activation, our extension rewrites all\nstored bookmarks and recent tabs so that they point to an attacker-controlled\npage while the original URL is provided as parameter: http://mal.icio.us/\n```\n  proxy.php?url=<original url>. When opened using the mobile Chrome\n\n```\nbrowser, this page performs a redirect to rogueapp://<original url>\nwhich triggers activation of the rogue app. The app then immediately fires\nanother intent that redirects the mobile browser to <orignal url>, leaving\npractically no footprint.\n\nOnce activated, the malicious app can be used in conjunction with the PCbased trojan to successfully bypass mobile phone 2FA. Fraudulent financial\ntransactions, for example, can be initiated by attackers once their PC-based\ntrojan has captured banking credentials of their victims. To confirm such transaction, the mobile component intercepts the OTP sent via SMS, and forwards\nit to the attacker. This attack scenario is depicted in Figure 2.\n\n\n-----\n\nFig. 3: Breaking 2FA on Apple Continuity. If enabled, Mac OS X 10.10 automatically synchronizes SMS messages between different Apple devices, breaking the second\nfactor.\n\n**3.2** **iOS**\n\nSimilar to our Android attack, mobile phone 2FA on the iOS platform can be bypassed by publishing a rogue app to Apple’s App Store and installing it from an\ninfected PC via the iTunes remote-install feature. Wang et. al., already demonstrated how a vulnerable app could slip through Apple’s strict review process\nand how such app can be used to access private APIs reserved for system apps to\nread SMS messages [36, 3]. Additionally, Bosman and Bos showed how a vulnerable app and sigreturn oriented programming allow to execute any set of system\ncalls needed to pull of any attack [11].\nAs of iOS 8.3, released in April 2015, however, it is no longer possible to\nreceive a so-called kCTMessageReceivedNotification to let an app act on incoming text messages without using a specific entitlement (similar to the Android\n```\nRECEIVE SMS permission). Since this functionality stems from a so-called private\n\n```\nAPI, requesting such permission violates the App Store Review Guidelines and\nwill result in an app rejection, effectively breaking this type of attack. The recent\nrelease of Mac Os X 10.10 Yosemite, however, opens up a new attack scenario.\nAs outlined in Section 2, Mac OS X Continuity features options to synchronize SMS and MMS text messages between multiple Apple devices. When\nenabled, SMS messages that are received on a linked iPhone, are forwarded and\nstored in plain-text in the ˜/Library/Messages/chat.db file on the Mac.\n\n**Breaking 2FA With Continuity enabled, attackers can break 2FA by instruct-**\ning their MitB to monitor the chat.db database for changes and forward new\nmessages to a remote server immediately after receipt. To show the practicality\nof this attack, we implemented a Firefox extension that uses the FileUtils.jsm\nAPI to read contents of synchronized SMS messages as soon as they are delivered\nto the iPhone.\nThe Continuity attack is illustrated in Figure 3.\n\n\n-----\n\nFig. 4: Bypassing dedicated 2FA apps. The screenshot on the left shows Google 2SV\nrequesting a verification code from the Google Authenticator. Note the Try another\n_way to sign in option near the bottom of the window. When clicked, the right-hand_\nfigure shows the fallback option to get a text message with an OTP sent over SMS. An\nattacker in control of the PC-browser is therefore able to dicate what 2FA technique is\nused.\n\n**3.3** **Dedicated 2FA Apps**\n\nMany online and offline applications are in the process of complementing their\nauthentication mechanism with an optional 2FA step, often dubbed Two-Step\nVerification (2SV). Open source implementations are provided by Google (Google\nAuthenticator) and Microsoft (Azure Authenticator) and can already be enabled\nfor dozens of popular services, including Google, Microsoft Online, Amazon Web\nServices, Dropbox, Facebook, WordPress, Joomla, and KeePass.\nDue to sandboxing techniques, our previously described attacks cannot access OTPs that are generated by 2SV authenticator apps. During the process\nof setting up an authenticator app, however, users are advised to provide the\nunderlying system a backup phone number. The rationale behind this is that if,\nfor some reason, users fail to access the authenticator app, they can fallback to\nrequesting an OTP sent over SMS.\nAssuming that many users provide a backup phone number that is used by\nthe same smartphone that runs the authenticator app, an attacker can easily bypass these dedicated 2FA apps: (i) having access to stolen credentials harvested\nby the MitB, an attacker initiates the login procedure; (ii) for logins via the\nGoogle Authenticator, for example, when prompted to enter a verification code,\nthe attacker instructs the login page to try another way to sign in, followed by selecting the Send a text message to your phone option. From here, our previously\ndescribed attacks can be used to completely bypass the 2FA mechanism.\nFigure 4 illustrates how an attacker can fallback to SMS based OTPs when\nusing Google Authenticator.\n\n\n-----\n\n###### 4 Discussion\n\nIn the previous sections, we showed how an attacker can bypass a variety of mobile phone 2FA mechanisms by exploiting synchronization vulnerabilities. We\nnow study feasibility and practicalities of our attacks in more detail. Additionally, we discuss our efforts regarding responsible disclosure, as well as recommendations for involved parties.\n\n**4.1** **Feasibility**\n\nReviewing our Android attack described in Section 3.1, we conclude that exploiting synchronization vulnerabilities to bypass 2FA can be done in a reliable and\nstealthy way on Google’s mobile operating system. Attackers can reduce their\nfootprint to a bare minimum by breaking the attack down in different steps: (i)\na preparation phase wherein attackers acquire access to infected PCs, possibly via a Malware as a Service-provider [14]; (ii) an app-installation phase\nwherein attackers push a vulnerable app to Google Play and instruct their victims to remotely install it. Depending on the target audience of the attacker,\nthis can be done within a time window of only a couple of hours, after which the\nrogue app can again be removed from Google’s servers; (iii) an app-activation\n**phase wherein attackers gracefully wait until victims activate the malicious**\napp. Our app-hiding tricks make that attackers can safely wait days so that a\nlarge group of victims get to activate the rogue app; and (iv) an attack phase\nwherein attackers perform an automated attack that requires access to OTPs\nsent over SMS. One typical example of such attack is transferring funds from\nsaving accounts to an account that is controlled by the attackers.\nAlthough more prerequisites must be met for our iOS attacks described in\nSection 3.2, they complement each other nicely: the vulnerable app approach\ndoes not work on iPhones running the latest iOS version, while our Continuity\nattack requires that victims do use more up to date versions of iOS and Mac\nOS X. The latter, however, also requires that (i) victims have enabled message\nsynchronization (which setup process requires interaction with both Mac and\niPhone), and (ii) both devices are connected to the same wireless network. Although this does not necessarily make the attack less feasible, it may slightly\nreduce its scalability given that synchronization is off by default and increase\nthe detection rate by attentive users (the content of received SMS messages will\npop up on both devices).\nFinally, although the remote-install 2FA synchronization vulnerability is also\nprevalent on the Windows Phone (WP) platform, Microsoft does not (yet) provide an API for reading received SMS messages programmatically. Additionally,\nto the best of our knowledge, WP does not provide SMS synchronization features like Apple’s Continuity. It is because of this that we were unable to break\nmobile phone 2FA on WP.\n\n\n-----\n\n**4.2** **Recommendations and Future Work**\n\nAn important step towards preventing the presented sophisticated MitB-based\nattacks against mobile phone 2FA, is to raise awareness among the various stakeholders. Mobile platform vendors should be aware that the release of new synchronization features may introduce security risks for their end-users. As such,\nvendors should be extremely careful when enabling new features by default instead of making them optional. It is their obligation to inform end-users that enabling or using certain synchronization features might jeopardize security guarantees of mobile phone 2FA. Only then can the user make a considered decision\nto give up security in favor of usability.\nReviewing our proposed attacks, this means that Apple, for example, should\nwarn users about potential security risks when they set up Continuity. Moreover, if the user decides to enable this feature, synchronizing only messages sent\nby trusted phone numbers — those that are found in the user’s contact list —\nwould eliminate our attack scenario, assuming that TAN codes are sent by an\nunknown sender or SMS gateway. Additionally, we recognize a major task for\nplatform vendors to safeguard their remote-install features. In our view, users\nshould always be forced to explicitly approve new app installations on their mobile device. This way, attackers can no longer silently push apps, but always\nrequire manual user-interaction. Ignorant users may still be phished into approving unknown install requests, of course, but such change would eradicate\nour completely automated attack scenario. We believe that the current appactivation security policy alone as deployed by vendors is too weak, given that\nadditional synchronization vulnerabilities can be used to achieve activation.\nStartled users who do not want to wait for a fix from their vendor, can protect\nthemselves from exploitation by using a separate account for each device. This\nway, remote-install features have zero knowledge about which devices an app\ncan be pushed to. Naturally, the downside of such approach is losing the ability\nto use synchronization features at all. Authenticator users, in addition, should\nupdate their settings so that their backup is a phone number that is attached\nto a dumb phone. These phones are remarkably harder to get infected.\nBesides raising user-awareness, future work should focus on the detection of\nSMS stealing apps at runtime, given that existing mobile Anti-Virus apps are\nuseless to this respect—they are confined to their own filesystem sandbox and\nthus cannot access directories of other apps, monitor the phone’s file system, or\nanalyze dynamic behavior of installed applications [31]. Instead, system modifications that can monitor the global smartphone state are required. To this,\nthe redesigned permission model of Android Marshmallow in which apps are\nno longer automatically granted all of their specified permissions at install time,\nbut rather prompt users to grant individual permissions at runtime, is promising.\nUnfortunately, this model will only be used by applications that are specifically\ncompiled for Marshmallow and can thus still be bypassed.\nAs an ultimate resort, we recommend that financial institutions consider the\nremoval of mobile 2FA from their business processes and switch to token based\n2FA instead—such token must of course be able to show transaction details, so\n\n\n-----\n\nthat Man-in-the-Middle attacks can be detected by the user during transaction\nprocessing. Naturally, such switch will cause large expenses; each institution will\nhave to consider whether moving away from mobile 2FA is feasible by comparing\ncosts, gained security, and risk analysis results. Even so, given the attack scenarios we conclude that 2FA on smartphones is currently entirely compromised\nand no safer than single factor authentication.\n\n**4.3** **Responsible Disclosure**\n\nTo show the practicality of bypassing Google Bouncer, we uploaded a first version\nof our SMS stealing app to Google Play on July 8, 2015, where it has been\npublicly available for over two months. The app got removed on September 10,\n2015, only a few hours after we had shared its name and a video demonstration\nof our attack with the head of Android Platform Security, while we already\nreported our attack scenario and recommendations to the Android security team\nmonths before the initial publication. Responses so far, unfortunately, indicate\nthat Google believes that our proposed attack is not feasible in practice, despite\nall evidence to the contrary (including actual demos[2]).\nWe notified Apple about our findings on November 30, 2015, but we did not\nreceive a technical response.\n\n###### 5 Background and Related Work\n\nIn this section, we provide a brief historical overview and related work discussion\nof the two fundamental components covered in this paper: Man-in-the-Browser\nattacks and Two-Factor Authentication. Additionally, we discuss current, stateof-the-art attacks against mobile-phone 2FA which rely on cross-platform infection. We focus on online banking schemes in particular, as this always was, and\nstill is, one of the services subject to a vast amount of criminal activity.\n\n**5.1** **Man-in-the-Browser**\n\nAt first, online financial services depended completely on single-factor authentication (e.g., by using a secret key). For attackers, keyloggers were enough to\nsteal credentials of associated users. However, they also generated vast amount\nof useless data, forcing the attacker to parse a huge amount of log output in\norder to retrieve meaningful credentials. Parsing keylog data was considered a\nchallenging and time consuming task for an attacker, as it is hard to automate.\nAs an alternative, cyber criminals deployed phishing campaigns, followed quickly\nby form grabbing attacks. The latter proved to be an effective and robust mechanism to steal useful information.\nWell known banking trojans like Zeus and SpyEye were the first to implement\nform grabbing by hooking web browser APIs [24, 38]. The fundamental idea\n\n2 https://youtu.be/k1v rQgS0d8\n\n\n-----\n\nbehind form grabbing is to intercept all form information before it is sent to\nthe network via HTTP requests. Form grabbing can be implemented in different\nways: (i) sniffing all outgoing requests using a PCAP-based library—something\nthat has the disadvantage of only working for unencrypted data [34]; (ii) API\n_hooking the browser’s dynamic library to steal all the requests and responses_\nmade by the user before they get encrypted [34]; and (iii) using a malicious\n_plugin to easily register callbacks within the browser for events like page load or_\n_file download in order to intercept any request or response._\nMalicious plugins and API hooking techniques can be used to do more than\njust form grabbing. Using a plugin, an attacker can modify HTTP responses\nreceived by the browser or covertly perform illegitimate operations on behalf of\nthe user. This is commonly known as a Man-in-the-Browser (MitB) attack [21].\nGuhring has identified various ways of which a trojan can perform a MitB\nattack and discusses pros and cons of various countermeasures that could be\ntaken [21]. Boutin studies how webinjects are used by a trojan in the browser\nand discusses the underground economy behind selling webinjects [12]. Buescher\net al., analyzed different types of hooking methods as used by financial trojans [13]. They propose an approach for detecting and classifying trojans by\nlooking at the manipulations they perform on a browser. However, their approach is mainly based on detecting API hooks. As a consequence, MitB attacks\nthat are implemented using plugins cannot be detected using this technique.\n\n**5.2** **Two-Factor Authentication**\n\nMost account fraud and identity theft relate to accounts that use only singlefactor authentication [20]. To defend against MitB attacks, financial services\nstarted using different types of multi-factor authentication mechanisms. The\nmost elementary mechanism is that of a list of Transaction Authorization Numbers (TAN codes) as provided by the online service, from which the user can\nchoose one to perform a secure transaction. A more convenient method that has\nbeen adopted by a majority of financial services is generating a new TAN code\nfor each transaction and sending this via an out-of-band channel to the user.\nNaturally, SMS is a cheap and efficient candidate channel: almost everybody\nowns a mobile phone.\nTo defend against MitB attacks that hijack an ongoing transaction by modifying its details (receiver’s bank account number or the amount of money transferred), financial services are starting to include transaction details along with\nthe TAN code in the out-of-band SMS message. Users can then verify the transaction by inspecting these details in the SMS and only confirm if these match\ntheir expectation.\nOn August 8, 2001, the Federal Financial Institutions Examination Council agencies (FFIEC) issued guidance entitled Authentication in an Electronic\n_Banking Environment [20]. FFIEC encourages financial institutions to use mo-_\nbile phone-based 2FA as described above to secure their user’s transactions.\nAloul et al., show how an app on a trusted mobile device can be used for\ngenerating one-time passwords, or how a mobile device itself can be used as a\n\n\n-----\n\nmedium for out-of-band communication to financial services [10]. This is what\nmost current deployed 2FA implementations use today. Mulliner analyzes attacks\nthat target SMS interception in general and shows how a smartphone trojan can\nsteal OTPs received via SMS. He proposes to use a dedicated channel which\ncannot be controlled by normal applications for receiving the OTP [27]. This is\nbased on the assumption that mobile trojans do not have root privileges. Schartner et al., describe an attack against SMS based OTPs in the scenario where\na transaction is made from the mobile device itself [33]. Since the transaction\ninvolves a single device (smartphone), a malware in the device can sniff both\ncredentials and OTPs received via SMS.\nKonoth et al., describe how Google’s 2FA implementation can be bypassed\nusing a MitB attack on an untrusted device [25]. Dmitrienko et al., analysed\n2FA implementations of major online service providers such as Google, Twitter,\nDropbox and Facebook [16]. Their work identifies various weaknesses in existing\nimplementations that allow an attacker to bypass 2FA and also illustrates a\ngeneral attack against 2FA. However, unlike ours, their attack relies on complex\ncross-platform infection.\n\n**5.3** **Cross-platform infection**\n\nCardtrap.A is the first discovered malware that features a cross-platform infection implementation. The trojan first infects a symbian smartphone. When the\nuser inserts the memory card of the mobile phone into a Windows PC, it attempts to infect the PC [23]. In 2006, researchers found that it is possible for PC\nmalware to infect a smartphone by exploiting Microsoft’s ActiveSync synchronization software [18]. Furthermore, Wang et al., explain how a sophisticated\nadversary can spread malware to another device through a USB connection [37].\nFinally, Dmitrienko et al., demonstrated via prototypes the feasibility of both\nPC-to-mobile and mobile-to-PC cross platform attacks [16].\n\n###### 6 Conclusion\n\nWith the ongoing integration of platforms—the result of a strong desire for\nenhanced usability—keeping our web accounts safe has become increasingly\nchallenging. In this paper, we showed how synchronization features and crossplatform services can be used to elevate a regular PC-based Man-in-the-Browser\nto an accompanying Man-in-the-Mobile threat which can be used to successfully\nbypass mobile phone 2FA. The root cause is that imprudent synchronization\nfunctionality has obliterated the security boundaries on which 2FA solutions\ndepend.\nDue to the large number of financial institutions that rely on mobile phone\n2FA for secure transaction processing, we expect that cyber criminals extend\ntheir activities by implementing attacks similar to ours, putting those institutions and their customers at risk. We hope that this paper helps in identifying\nissues with respect to cross-platform integration and that both software and\n\n\n-----\n\nplatform vendors adopt our recommendations in order to prevent these types of\nattacks from becoming a major threat in the near future.\n\n###### Acknowledgements\n\nWe would like to thank the anonymous reviewers for their valueable comments\nand input to improve the paper. This work was supported by the MALPAY\nproject and by the Netherlands Organisation for Scientific Research through\ngrants NWO 639.023.309 VICI “Dowsing” and NWO CSI-DHS 628.001.021.\n\n###### References\n\n1. Android intents with chrome. https://developer.chrome.com/multidevice/\n```\n  android/intents\n\n```\n2. Find a lost phone. http://www.windowsphone.com/en-us/how-to/wp8/settings```\n  and-personalization/find-a-lost-phone\n\n```\n3. Get SMS broadcast with text body without Jailbreak BUT private frameworks\nin IOS. http://stackoverflow.com/questions/26642770/get-sms-broadcast```\n  with-text-body-without-jailbreak-but-private-frameworks-in-ios\n\n```\n4. How do I set up Sync on my computer? http://support.mozilla.org/kb/how```\n  do-i-set-sync-my-computer\n\n```\n5. iCloud: Erase your device. https://support.apple.com/kb/PH2701\n6. Mobile/tablet operating system market share. https://www.netmarketshare.com/\n```\n  operating-system-market-share.aspx?qprid=8&qpcustomd=1\n\n```\n7. Remotely ring, lock or erase a lost device. https://support.google.com/accounts/\n```\n  answer/6160500\n\n```\n8. Sync tabs across devices. http://support.google.com/chrome/answer/2591582\n9. Use Continuity to connect your iPhone, iPad, iPod touch, and Mac. http:\n```\n  //support.apple.com/HT204681\n\n```\n10. Aloul, F., Zahidi, S., Hajj, W.E.: Two Factor Authentication Using Mobile Phones.\nIn: Proceedings on the International Conference on Computer Systems and Applications (AICCA) (2009)\n11. Bosman, E., Bos, H.: Framing Signals - A Return to Portable Shellcode. In: Proceedings of the Symposium on Security and Privacy (S&P) (2014)\n12. Boutin, J.I.: The evolution of webinjects (September 2014)\n13. Buescher, A., Leder, F., Siebert, T.: Banksafe Information Stealer Detection Inside the Web Browser. In: Proceedings on the International Conference on Recent\nAdvances in Intrusion Detection (RAID) (2011)\n14. Caballero, J., Grier, C., Kreibich, C., Paxson, V.: Measuring Pay-per-install: The\nCommoditization of Malware Distribution. In: Proceedings of the USENIX Security Symposium (USENIX Sec) (2011)\n15. Chytry, F.: Apps on Google Play Pose As Games and Infect Millions of Users with\nAdware (February 2015)\n16. Dmitrienko, A., Liebchen, C., Rossow, C., Sadeghi, A.R.: On the (In)Security of\nMobile Two-Factor Authentication. In: Proceedings of the International Conference on Financial Cryptography and Data Security (2014)\n17. eMarketer: Smartphone Users Worldwide Will Total 1.75 Billion in 2014 (January\n2014)\n\n\n-----\n\n18. Evers, J.: Virus makes leap from PC to PDA (Feburary 2006)\n19. Exact Target: 2014 Mobile Behavior Report (February 2014)\n20. Federal Financial Institutions Examination Council: Authentication in an Internet\nBanking Environment (2005)\n21. G¨uhring, P.: Concepts against Man-in-the-Browser Attacks (September 2006)\n22. inazaruk: “Activating” Android applications (December 2011)\n23. Kawamoto, D.: Cell phone virus tries leaping to PCs (September 2005)\n24. Kharouni, L.: Automating Online Banking Fraud (2012)\n25. Krishnan, R., Kumar, R.: Securing User Input as a Defense Against MitB. In: Proceedings of the International Conference on Interdisciplinary Advances in Applied\nComputing (ICONIAAC) (2014)\n26. Lockheimer, H.: Android and Security (February 2012)\n27. Mulliner, C., Borgaonkar, R., Stewin, P., Seifert, J.P.: SMS-Based One-Time Passwords: Attacks and Defense. In: Proceedings of the Conference on Detection of\nIntrusions and Malware & Vulnerability Assessment (DIMVA) (2013)\n28. Neugschwandtner, M., Lindorfer, M., Platzer, C.: A View to a Kill: WebView\nExploitation. In: Proceedings of the USENIX Workshop on Large-Scale Exploits\nand Emergent Threats (LEET) (2013)\n29. Oberheide, J., Miller, C.: Dissecting the Android Bouncer (Jun 2012)\n30. Poeplau, S., Fratantonio, Y., Bianchi, A., Kruegel, C., Vigna, G.: Execute This! Analyzing Unsafe and Malicious Dynamic Code Loading in Android Applications. In:\nProceedings of the Network and Distributed System Security Symposium (NDSS)\n(2014)\n31. Rafael Fedler, M.K., Schutte, J.: An Antivirus API for Android Malware Recognition. In: Proceedings of Malicious and Unwanted Software: ”The Americas” (MALWARE), 2013 8th International Conference (2013)\n32. Sams, B.: Microsoft confirms Edge will sync passwords, bookmarks, tabs, and\nmore. http://www.neowin.net/news/microsoft- confirms- edge- will- sync```\n  passwords-bookmarks-tabs-and-more\n\n```\n33. Schartner, P., B¨urger, S.: Attacking mTAN-Applications like e-Banking and mobile\nSignatures. Tech. rep., Univeristy of Klagenfurt (2011)\n34. Sood, A.K., Enbody, R.J., Bansal, R.: The art of stealing banking information —\nform grabbing on fire (November 2011)\n35. Statista: Global smartphone sales to end users 2007–2014 (2015)\n36. Wang, T., Lu, K., Lu, L., Chung, S., Lee, W.: Jekyll on iOS: When Benign Apps\nBecome Evil. In: Proceedings of the USENIX Security Symposium (USENIX Sec)\n(2013)\n37. Wang, Z., Stavrou, A.: Exploiting Smart-Phone USB Connectivity For Fun And\nProfit. In: Proceedings of the Computer Security Applications Conference (ACSAC) (2010)\n38. Wyke, J.: What is zeus? Sophos (May 2011)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://www.vvdveen.com/publications/BAndroid.pdf"
    ],
    "report_names": [
        "BAndroid.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716499,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1480177105,
    "ts_modification_date": 1480177105,
    "files": {
        "pdf": "https://archive.orkl.eu/cff91247e1bd92689e2da874dd1b357b45705c63.pdf",
        "text": "https://archive.orkl.eu/cff91247e1bd92689e2da874dd1b357b45705c63.txt",
        "img": "https://archive.orkl.eu/cff91247e1bd92689e2da874dd1b357b45705c63.jpg"
    }
}