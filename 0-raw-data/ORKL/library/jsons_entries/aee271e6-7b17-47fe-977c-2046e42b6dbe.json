{
    "id": "aee271e6-7b17-47fe-977c-2046e42b6dbe",
    "created_at": "2023-01-12T15:00:19.75107Z",
    "updated_at": "2025-03-27T02:05:41.439882Z",
    "deleted_at": null,
    "sha1_hash": "5ce5b785cf502b050d74f3bed21f013655334b56",
    "title": "2021-12-07 - Critical Hit- How DoppelPaymer Hunts and Kills Windows Processes",
    "authors": "",
    "file_creation_date": "2022-05-28T02:49:00Z",
    "file_modification_date": "2022-05-28T02:49:00Z",
    "file_size": 1414253,
    "plain_text": "# How DopplePaymer Hunts & Kills Windows Processes\n\n**[crowdstrike.com/blog/how-doppelpaymer-hunts-and-kills-windows-processes/](https://www.crowdstrike.com/blog/how-doppelpaymer-hunts-and-kills-windows-processes/)**\n\nShaun Hurley December 7, 2021\n\n[In a July 2019 blog post about DoppelPaymer, Crowdstrike Intelligence reported that](https://www.crowdstrike.com/blog/doppelpaymer-ransomware-and-dridex-2/)\nProcessHacker was being hijacked to kill a list of targeted processes and gain access,\ndelivering a “critical hit.” Although the blog is now a couple of years old, the hijacking\ntechnique is interesting enough to dig into its implementation.\n\nThe hijack occurs when ProcessHacker loads a malicious stager DLL designed to exploit\nlegitimate behavior. Once the process has been hijacked, the stager DLL is able to terminate\n[processes, including those protected by Protected Process Light (PPL). To accomplish this](https://www.crowdstrike.com/blog/evolution-protected-processes-part-1-pass-hash-mitigations-windows-81/)\ntask, it leverages ProcessHacker’s kernel driver, KProcessHacker, that has been registered\nunder the service name KProcessHacker3. This blog delves into the details about how\nDoppelPaymer hijacks ProcessHacker and exploits KProcessHacker to kill a list of\nprocesses, including both antivirus (AV) and endpoint detection and response (EDR)\napplications.\n\n\n-----\n\nFigure 1. Architecture diagram to kill a target process\n\n## Launching Process Hacker\n\nTo start ProcessHacker, DoppelPaymer writes the ProcessHacker executable, the\nKProcessHacker driver, and the malicious stager DLL into a subdirectory of `%APPDATA% .`\nBoth the subdirectory name and the file names for the executable and driver are a unique\nstring of alphanumeric characters. Once those two files have been written, one of the DLLs\nloaded by ProcessHacker has to be hijacked using a technique called “DLL search order\nhijacking.”\n\n### DLL Search Order Hijacking\n\nSimilar to Dridex, DoppelPaymer uses DLL search order hijacking to exploit the DLL loading\nbehavior for Windows processes. As the operating system PE loader loads a binary, it also\nneeds to load the DLL files required for the PE to function. By default, MS Windows has a\nspecific path it takes when looking for the DLL files to load. Windows checks for Windows\n\n\n-----\n\nsystem DLLs in the same directory as the target binary before it checks the Windows system\ndirectories. A malicious process, in this case DoppelPaymer, can drop a malicious version of\na DLL in that directory and it will be loaded by the target application.\n\nTo determine which DLL to hijack, DoppelPaymer walks the module name list in the Import\nAddress Table (IAT) of the ProcessHacker binary. Each name is hashed with a CRC32\nalgorithm and compared against a hardcoded list of hashes (Table 1), and if a match occurs,\nthe name is added to a list data structure. A random number generator is used to pick one of\nthe three names out of the list.\n\n**CRC32** **Filename**\n```\n 0xd8946922 VERSION.dll\n 0x020da855 WINSTA.dll\n 0x3c55abe2 UxTheme.dll\n\n```\nTable 1. Mapping DLL name to CRC32 hash for search order hijacking\n\nOnce a DLL has been picked, the legitimate Windows version of the DLL is read into a\nmemory buffer. This DLL is used as a template to build the malicious stager DLL. The file is\nwritten to the same subdirectory as the ProcessHacker executable with the same file name\nas the hijacked DLL.\n\n### Creating the Process\n\nDoppelPaymer passes two arguments to the ProcessHacker process: The first is the name\nof the KProcessHacker.sys driver, and the second is an integer that will be used for interprocess communication (IPC) between the DoppelPaymer and ProcessHacker processes.\n\n```\nC:\\Users\\ducksoup\\AppData\\Roaming\\M28fPT\\ibOLR 2LEQV0 161604546\n\n```\n\nFigure 2. ProcessHacker command line\n\n**Setting Up the IPC Objects**\n\nEvent handlers and section objects are used to communicate between the two processes.\nThese objects allow DoppelPaymer to communicate directly with the stager DLL that is\nloaded inside the ProcessHacker process. The example handle values in Table 2 are used\nthroughout the rest of this post when referencing these objects. These values vary with\ndifferent executions of DoppelPaymer.\n\n\n**Object Type** **Handle**\n**Value**\n\n\n**Purpose**\n\n\nEvent Object `0x120` Notify data in queue\n\n\n-----\n\nEvent Object `0x11C` Notify data processed\n\n\nSection\nObject\n\nSection\nObject\n\n\n`0x124` Queue used to send process information to the stager\nDLL\n\n`0x128` Contains the three events\n\n\nTable 2. IPC handles with concrete values from testing\n\nFor each section object, a view is mapped into process memory, so that DoppelPaymer is\nable to write data to the objects. The `0x124 object is the queue where the process`\ninformation of the processes to terminate will be written. The other object, `0x128, will`\ncontain the handle values of the other three objects: `0x120,` `0x11C and` `0x124 . For the`\nstager DLL to access those three handles, DoppelPaymer needs to provide the `0x128`\nhandle value to ProcessHacker.\n\nSticking with the example command line in Figure 1, the second argument to ProcessHacker\nis the section object handle `0x128 XORd against the same constant value (unique per`\nbinary) used throughout the lifetime of DoppelPaymer. For this binary, the constant is\n```\n0x9a1e2ea . XORing 0x128 with 0x9a1e2ea gives us the decimal value 161604546 .\n\n```\nAfter these IPC objects are created, and the second argument to ProcessHacker has been\ngenerated, `CreateProcessW is called to launch ProcessHacker. Now DoppelPaymer has to`\nwait for the stager DLL to initialize inside of the ProcessHacker process prior to establishing\ninter process communication. `NtWaitForSingleObject is called for event handle` `0x120,`\nand DoppelPaymer waits for that event to be signaled.\n\n## Loading the Stager DLL\n\nThe stager DLL is loaded into ProcessHacker. Several initialization steps have to occur\nbefore the stager DLL can leverage KProcessHacker to kill processes:\n\nProcessHacker’s entry point needs to be modified to ensure that none of the startup\nroutines for ProcessHacker execute\nThe KProcessHacker service has to be initialized\nProcessHacker and the stager DLL have to be verified as a valid client for the\nKProcessHacker service\nThe IPC objects necessary for DoppelPaymer to communicate with the stager DLL\nneed to be duplicated\n\nAfter all four of these steps have been successfully completed, the stager DLL can start\nkilling target processes provided by DoppelPaymer.\n\n### Reaching ProcessHacker’s Code Entrypoint Address\n\n\n-----\n\nOnce the process starts to load the stager DLL, the malicious code will start to execute, but if\ncontrol isn’t passed back to the OS to finish loading ProcessHacker, it will not be usable by\nDoppelPaymer. The loading process completes when the entry-point address of\nProcessHacker is reached. To determine when the entry point is reached, the stager DLL will\noverwrite the entry point of ProcessHacker with the code in Figure 3.\n```\n.rdata:10006120       mov   eax, 94A351BBh\n.rdata:10006125       push  0\n.rdata:10006127       push  8FF4B5ACh ; Event handle\n.rdata:1000612C       call  eax    ; NtSetEvent\n.rdata:1000612E loc_1000612E:              \n.rdata:1000612E       push  0\n.rdata:10006130       push  1\n.rdata:10006132       push  0FFFFFFFEh\n.rdata:10006134       mov   eax, 1DCB264Eh\n.rdata:10006139       call  eax    ; NtWaitForSingleObject\n.rdata:1000613B       jmp   short loc_1000612E\n\n```\nFigure 3. Entrypoint template code\n\nThis code is copied from the .rdata section of the stager DLL and is modified to represent the\ncurrent process environment. Placeholders exist for the event handle and for the two\nWindows API functions used for the notification routines. The event used to signal that the\nentry point has been reached is created and copied to the `8FF4B5ACh placeholder. The`\naddresses for `NtSetHandle and` `NtWaitForSingleObject are resolved and written to`\n```\n94A351BBh and 1DCB264Eh, respectively.\n\n```\nOnce the template is complete, `VirtualProtect is called to set ProcessHacker’s entry`\npoint to write-able, the entry point code is overwritten, and the original protection restored.\nThe new entry-point code, in C, is shown in Figure 4.\n```\n//\n// Signal entrypoint reached\n//\nNtSetEvent(entryPointReachedHdl, NULL);\nwhile (1) {\n  //\n  // Entrypoint thread will loop indefinitely\n  //\n  NtWaitForSingleObject(-2, 1, NULL);\n}\n\n```\nFigure 4. ProcessHacker entry point infinite loop\n\nThe code in Figure 4 signals to the stager DLL thread that the entry point has been reached,\nand it continues in an infinite loop that calls `NtWaitForSingleObject . Not only will this`\ninfinite loop let the stager DLL know when the entry point is reached, it also prevents\n\n\n-----\n\nProcessHacker from interfering with the stager DLL and prevents the ProcessHacker window\nfrom being displayed.\n\nNow that the entry point is overwritten, the stager DLL spawns a new thread that initializes\nthe KProcessHacker driver and sets the stage for killing AV processes. First, the thread calls\n```\nNtWaitForSingleObject and waits for the entry point to be reached.\n\n### Initializing the KProcessHackerDriver\n\n```\nThe “entry point reached” event is signaled, and this thread can continue and initialize the\nKProcessHacker driver. The stager DLL has to create the KProcessHacker service and\nregister the driver. The code to accomplish this task is essentially the same code used by the\n[two ProcessHacker functions that can be found in the kph.c source code:](https://github.com/processhacker/processhacker/blob/master/phlib/kph.c)\n```\n   KphConnect2Ex\n   KphConnect\n\n```\nThe code opens the service control manager in Windows and creates the KProcessHacker\nservice under the name `KProcessHacker3 . The stager DLL passes the following`\narguments to the `CreateService procedure:`\n```\nCreateService(\n   scmHandle,\n   L”kprocesshacker3”,\n   L”kprocesshacker3”,\n   SERVICE_ALL_ACCESS,\n   SERVICE_KERNEL_DRIVER,\n   SERVICE_DEMAND_START,\n   SERVICE_ERROR_IGNORE,\n   //\n   //  Path to kprocesshacker.sys driver file\n   //\n   L”C:\\Users\\ducksoup\\AppData\\Roaming\\M28fPT\\2LEQV0”, \n   NULL,\n   NULL,\n   NULL,\n   NULL,\n   L\"\"\n);\n\n```\nThe KProcessHacker service has been created and started and is ready to receive requests\nfrom the client ProcessHacker process. Before a client can make a request to the service, it\nneeds to be verified.\n\n### Kernel Verification of the KProcessHacker Client\n\nEvery time an IOCTL is sent to the KProcessHacker service, it is checked to ensure that the\ncaller is a verified KProcessHacker client that is allowed to communicate with the service. All\nattempts to communicate with KProcessHacker are validated using an IOCTL request key\n\n\n-----\n\nthat is generated by sending a `KPH_RETRIEVEKEY request from the user-mode process.`\nThe importance of this key is discussed in the “KProcessHacker IOCTL Request Keys and\nAPC” section below. Attached to the `KPH_RETRIEVEKEY request is an Asynchronous`\nProcedure Call (APC) routine, `KphpWithKeyApcRoutine, which will be executed upon`\ncompletion.\n\nKProcessHacker initializes a `KPH_CLIENT structure that needs to be populated with the`\ncorrect values to distinguish the caller as verified. This initialization occurs when the stager\nDLL opens a handle to the KProcessHacker driver file. As this occurs, the Windows kernel\nsends an `IRP_MJ_CREATE request to the KProcessHacker driver, and the handler,`\n```\nKphDispatchCreate, is called.\ntypedef struct _KPH_CLIENT\n{\n  struct\n  {\n    ULONG VerificationPerformed : 1;\n    ULONG VerificationSucceeded : 1;\n    ULONG KeysGenerated : 1;\n    ULONG SpareBits : 29;\n  };\n  FAST_MUTEX StateMutex;\n  NTSTATUS VerificationStatus;\n  PVOID VerifiedProcess; // EPROCESS (for equality checking only - do not access\ncontents)\n  HANDLE VerifiedProcessId;\n  PVOID VerifiedRangeBase;\n  SIZE_T VerifiedRangeSize;\n  // Level 1 and 2 secret keys\n  FAST_MUTEX KeyBackoffMutex;\n  KPH_KEY L1Key;\n  KPH_KEY L2Key;\n} KPH_CLIENT, *PKPH_CLIENT;\n\n```\nFigure 5. KPH_CLIENT data structure from the Kph.h source code\n\nThis `KphDispatchCreate function allocates kernel memory to store this data structure.`\nDue to it being kernel memory, the stager DLL is unable to manipulate the data structure\nfrom user mode, even from inside the ProcessHacker process. Instead, the stager DLL can\nsend a `KPH_VERIFYCLIENT IOCTL request to the driver. The handler function,`\n```\nKphVerifyClient, for this IOCTL will set the necessary fields once the client is verified.\n\n```\n**IOCTL** **Request Name** **Description**\n```\n 0x99992007 KPH_VERIFYCLIENT Verify the client process\n 0x999200B KPH_RETRIEVEKEY Retrieve the verification key\n 0x999920CB KPH_OPENPROCESS Opens a process\n\n```\n\n-----\n\n```\n 0x999920DF KPH_TERMINATEPROCESS Terminate a process\n\n```\nTable 3. KProcessHacker IOCTLs used by the stager DLL\n\nThe `KphVerifyClient function first checks to see if verification has already occurred by`\nchecking the boolean value, `Client->VerificationPerformed . If this field is false, the`\nfollowing checks are made by KProcessHacker:\n\n1. Verify that the start address of the APC routine is a user-space address and not a\n\nkernel address\n2. Compare the process image file name against the mapped PE image name where the\n\nAPC routine resides\n3. Verify that the APC routine address came from an area of memory that is type\n\nMEM_IMAGE and in a MEM_COMMIT state\n\n1. These states ensure that the memory where the APC routine resides is both\n\ncommitted memory and a mapped view of an image section\n4. Verify the PE file backing the process making the request by hashing the file’s contents\n\nand comparing it against a digital signature:\n\n1. The 256-bit Elliptic Curve Digital Signature is a hash of a known valid\n\nProcessHacker PE file that was signed using KProcessHacker’s private key\n2. The digital signature is decoded from the stager DLL and sent with the\n```\n      KPH_VERIFYCLIENT request\n\n```\n3. The contents of the file backing the process that made the request is hashed\n\nusing SHA-256\n4. The signed hash is decrypted using KProcessHacker’s public key\n5. If the decrypted signed hash and the generated hash match, then the PE file is\n\nverified\n\nOnce verification passes, the code in Figure 6 is executed to populate several fields that will\nbe used for verification when the stager DLL attempts to send the `KPH_OPENPROCESS and`\n```\nKPH_TERMINATEPROCESS IOCTL requests.\nstatus = KphVerifyFile(processFileName, Signature, SignatureSize);\nif (NT_SUCCESS(status))\n{\n  Client->VerifiedProcess = PsGetCurrentProcess();\n  Client->VerifiedProcessId = PsGetCurrentProcessId();\n  Client->VerifiedRangeBase = memoryBasicInfo.BaseAddress;\n  Client->VerifiedRangeSize = memoryBasicInfo.RegionSize;\n}\nClient->VerificationStatus = status;\nClient->VerificationSucceeded = NT_SUCCESS(status);\nClient->VerificationPerformed = TRUE;\n\n```\nFigure 6. KphVerifyClient sets verified fields of a KPH_CLIENT structure\n\n\n-----\n\nThe hijacked ProcessHacker process is now a verified client of the KProcessHacker service.\nA new thread is spawned to duplicate the IPC objects from DoppelPaymer into the\nProcessHacker process space.\n\n### Duplicating the IPC Objects Inside ProcessHacker\n\nFrom Figure 2, the second argument, `161604546, is decoded, yielding the handle ID of`\n```\n0x128 . The section object that this handle references is duplicated in the ProcessHacker\n\n```\nprocess. The section object is duplicated with the same access rights as the original.\nDuplicating objects generate new handle values, but to keep it simple, this post reuses the\noriginal values.\n```\n//\n// Duplicating DoppelPaymer’s section object handle.\n//\nNtDuplicateObject(\n   DoppelPaymerProcHandle, // Process handle for source process\n   0x128,          // Handle for the source section object\n   0xFFFFFFFF,       // ProcessHacker process handle\n   duplicateHdl,      // New section object handle\n   NULL,\n   NULL,\n   DUPLICATE_SAME_ACCESS\n);\n\n```\nA view of the duplicated section object is mapped to local process memory using\n```\nNtMapViewOfSection . It contains the same handles from Table 2 that were written to the\n\n```\nsection object in the DoppelPaymer process: `0x120,` `0x11C and` `0x124 . Each of these`\nhandles is duplicated, and a view of the `0x124 section object is mapped into`\nProcessHacker’s process memory.\n\nDoppelPaymer is now in a state where it is waiting for an event to be signaled that notifies it\nthat the stager DLL has completed initialization and is ready to process requests in the\nqueue. This notification is sent by calling `NtSetEvent with the` `0x120 event handle, and`\nthe stager DLL waits for requests.\n\n## Killing Blocklisted Applications\n\nOnce DoppelPaymer receives the signaled event, it starts enumerating both service and\nprocess names, and hashes them with the CRC32 algorithm. These hashes are compared\nagainst a list of blocklisted hashes in DoppelPaymer’s process memory. The complete list\nwas covered in the previous DoppelPaymer blog post. This section discusses what happens\nwhen an application matches one of the blocklisted items.\n\nDoppelPaymer writes the process ID associated with the service, along with a command to\nthe mapped section object, `0x124 . The command will tell the stager DLL which steps to`\ntake.\n\n\n-----\n\n```\nAntiAV {\n   +0x00  Command\n   +0x08  Process ID\n   +0x10  errorCodeResponse  // Response code from ProcessHacker\n}\n\n```\nFigure 7. Blocklisted process information written to IPC section\n\nProcess termination occurs in two steps: a process is opened, then it is killed. The first\ncommand sent, `1, will tell the stager DLL to open a handle to the process. Table 4 contains`\na list of valid commands.\n\n**Command** **Action**\n\n`0` Terminate ProcessHacker\n\n`1` Open the process\n\n`2` Kill the process\n\nOther value Invalid, wait for the next command\n\nTable 4. IPC handles with concrete values from testing\n\nThe command is written to the queue, along with the process ID, and DoppelPaymer signals\nthe event to notify the stager DLL that data is in the queue. Once that event is signaled, it\nwaits for a response.\n\n### KProcessHacker IOCTL Request Keys and APC\n\nCertain IOCTL requests to the KProcessHacker service require the verification of an IOCTL\nrequest key. To ensure that the key cannot be tampered with, the key is generated by the\ndriver and stored in the `KPH_CLIENT structure. The following IOCTL requests require a key:`\n\nKPH_OPENPROCESS\nKPH_OPENPROCESSTOKEN\nKPH_TERMINATEPROCESS\nKPH_READVIRTUALMEMORY\nKPH_OPENTHREAD\n\nPrior to making any of these requests, ProcessHacker has to send a `KPH_RETRIEVEKEY`\nrequest using `NtDeviceIoControlFile . Along with this request, the user-mode address of`\nan APC routine, `KphpWithKeyApcRoutine, and the user-mode address of a function called`\nby the APC are sent as parameters. This routine to be called by the APC will end up making\none of the IOCTL requests mentioned in the above bulleted list.\n\n\n-----\n\n```\nNtDeviceIoControlFile(\n   PhKphHandle,\n   NULL,\n   KphpWithKeyApcRoutine, // Called after NtDeviceIoControlFile \n               // returns\n   NULL,\n   &context.Iosb,     // Receives the status code\n   KPH_RETRIEVEKEY,    // IOCTL\n   &input,         // Parameters passed to IOCTL\n   sizeof(input),\n   NULL,\n   0\n);\n\n```\nThe `KPH_RETRIEVEKEY request is handled by` `KphRetrieveKeyViaApc . Prior to`\ngenerating the request key, several checks are performed to ensure that the client\n(ProcessHacker, in this case) making the request is verified and that the APC parameter is\nvalid:\n\nEnsure the client has been verified by checking the `KPH_CLIENT-`\n```\n   >VerificationSucceeded field\n\n```\nEnsure that the process information for the client matches what was set during the\nverification process\n```\n      KPH_CLIENT->VerifiedProcess\n      KPH_CLIENT->VerifiedProcessId\n\n```\nEnsure that the instruction address of the APC routine falls within the executable\nsection of the verified client\n\nOnce those checks are passed, a request key is generated and stored in the `KPH_CLIENT`\nstructure. This key will also be passed as argument to the APC routine. So now, both the\nclient and the server have independent copies of the same request key. The APC routine,\n```\nKphpWithKeyApcRoutine, executes. \n\n```\nAs noted earlier, the APC routine receives a function pointer that will be used to execute a\nspecific action (kill process, open process, etc.). To restrict which requests can be made via\nthis APC routine, it makes sure that only the following functions can be called from the APC:\n```\n   KphpGetL1KeyContinuation\n   KphpOpenProcessContinuation\n   KphpOpenProcessTokenContinuation\n   KphpTerminateProcessContinuation\n   KphpReadVirtualMemoryUnsafeContinuation\n   KphpOpenThreadContinuation\n\n```\nThis check prevents DLLs from being injected into ProcessHacker and leveraging the\n```\nKphpWithKeyApcRoutine APC as a method to execute its own routines under the guise of\n\n```\nbeing a valid `KPH_CLIENT . Once this check passes, the function passed to the APC is`\n\n\n-----\n\ncalled and the client copy of the request key is passed to that function.\n\nBoth this check and the checks made in the `KphRetrieveKeyViaApc procedure pose a`\nchallenge for the stager DLL. The author of the stager DLL scraps the original\n```\nKphpWithKeyApcRoutine routine and passes their own APC routine, StagerAPCRoutine .\n\n```\nThe code for this is written directly after ProcessHacker’s overwritten entry-point code. This\nbypasses both of the function pointer checks and passes the checks performed by\n```\nKphRetrieveKeyViaApc .\n000000013f5b2f2c  jmp cs:CallFunctionPointerRoutine\n000000013f5b2f3a  push  rax\n000000013f5b2f3b  retn\n\n```\nFigure 8. StagerAPCRoutine\n\nThe `StagerAPCRoutine (Figure 8) shortcuts the entire process and jumps directly to a`\nprocedure, `CallFunctionPointerRoutine, that calls the DLL stager versions of`\n```\nKphpOpenProcessContinuation and KphpTerminateProcessContinuation procedures\n\n```\nand passes the client copy of the request key as a parameter.\n\n### Opening a Process Handle\n\nAs outlined in the previous section, to open a process handle, a `KPH_RETRIEVEKEY request`\nis sent to the KProcessHacker service. Along with this request, the `StagerAPCRoutine`\naddress and the address of the function called by the APC open a process,\n```\nStagerOpenProcess . A new request key is generated, saved to KPH_CLIENT and passed\n\n```\nto `StagerAPCRoutine . Once everything has been validated, the` `StagerAPCRoutine calls`\n```\nStagerOpenProcess where a KPH_OPENPROCESS request is sent to the KProcessHacker\n\n```\nservice. Both the client copy of the request key and the process ID of the target are sent with\nthe request.\n\n\n-----\n\nFigure 9. Process diagram to open a process\n\nThe service handles this request by calling `KpiOpenProcess . Before a handle to the`\nprocess can be opened, the client’s request key is validated by calling `KphValidateKey,`\nwhere the client copy of the key is compared against the copy stored in `KPH_CLIENT . If`\nthese match, a handle to the target process is opened.\n```\nPsLookupProcessByProcessId is called to get a pointer to the process object in kernel\n\n```\nmemory. That pointer is used to open a handle to the object by calling\n```\nObOpenObjectByPointer . This handle can now be referenced by the stager DLL.\n\n```\nThe stager DLL signals the `0x120 event handle, notifying DoppelPaymer that a handle has`\nsuccessfully been opened to the target process. Now the process can be killed.\n\n### Killing a Process\n\n\n-----\n\nDoppelPaymer verifies that the process was successfully opened, and then takes the\nappropriate action. If an error occurred, it continues checking for blocklisted applications;\notherwise, another notification is sent, this time with the command `2 to terminate the`\nprocess.\n\nTerminating a process follows the same procedure as opening a process with one difference:\nThe `StagerKillProcess function pointer is passed to the` `StagerAPCRoutine . The`\n```\nStagerKillProcess function sends a KPH_TERMINATEPROCESS request to the\n\n```\nKProcessHacker service. This is handled by the `KpiTerminateProcess kernel-mode`\nfunction. The request key is validated before process termination can occur. The target\nprocess is reopened to get a kernel handle, and `ZwTerminateProcess is called to kill the`\nprocess. Note that using this procedure ignores PPL, so even protected processes will be\nkilled.\n\n## Conclusion\n\nDoppelPaymer’s usage of ProcessHacker to kill AV services is part of a larger trend of\nvarious actors leveraging legitimate tools to disable AV/EDR functionality. DoppelPaymer’s\nmethod is a testament to how innovative malware authors can be when it comes to\nneutralizing the defenses of their target.\n\n_Many thanks to Bill Demirkapi for helping to sort out how digital signature verification is used_\n_to validate the PE._\n\n**Additional Resources**\n\n_[Discover how CrowdStrike Falcon X combines automated analysis with human](https://www.crowdstrike.com/endpoint-security-products/falcon-x-threat-intelligence/)_\n_intelligence, enabling security teams, regardless of size or skill, to get ahead of the_\n_attacker’s next move._\n_Find out how to stop adversaries targeting your industry — schedule a free 1:1 intel_\n_briefing with a CrowdStrike threat intelligence expert today._\n_Learn about the powerful, cloud-native CrowdStrike Falcon® platform by visiting the_\n_product webpage._\n_[Get a full-featured free trial of CrowdStrike Falcon Prevent™ to see for yourself how](https://go.crowdstrike.com/try-falcon-prevent.html)_\n_true next-gen AV performs against today’s most sophisticated threats._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-07 - Critical Hit- How DoppelPaymer Hunts and Kills Windows Processes.pdf"
    ],
    "report_names": [
        "2021-12-07 - Critical Hit- How DoppelPaymer Hunts and Kills Windows Processes.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535619,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1653706140,
    "ts_modification_date": 1653706140,
    "files": {
        "pdf": "https://archive.orkl.eu/5ce5b785cf502b050d74f3bed21f013655334b56.pdf",
        "text": "https://archive.orkl.eu/5ce5b785cf502b050d74f3bed21f013655334b56.txt",
        "img": "https://archive.orkl.eu/5ce5b785cf502b050d74f3bed21f013655334b56.jpg"
    }
}