{
    "id": "de2b85f5-8e09-4414-bbe7-bfc1421e6347",
    "created_at": "2023-01-12T15:01:04.750843Z",
    "updated_at": "2025-03-27T02:14:13.69674Z",
    "deleted_at": null,
    "sha1_hash": "c82ccdda045495783968b39125725eb22de03c01",
    "title": "2022-10-04 - Remove All The Callbacks – BlackByte Ransomware Disables EDR Via RTCore64.sys Abuse",
    "authors": "",
    "file_creation_date": "2022-11-28T18:53:24Z",
    "file_modification_date": "2022-11-28T18:53:24Z",
    "file_size": 3303301,
    "plain_text": "# Remove All The Callbacks – BlackByte Ransomware Disables EDR Via RTCore64.sys Abuse\n\n**[news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/)**\n\nAndreas Klopsch October 4, 2022\n\nWith [reports of a new data-leak site published by actors behind the BlackByte ransomware,](https://www.bleepingcomputer.com/news/security/blackbyte-ransomware-gang-is-back-with-new-extortion-tactics/)\nwe decided to take another look at the most recent variant written in Go.\n\nWe found a sophisticated technique to bypass security products by abusing a known\nvulnerability in the legitimate vulnerable driver RTCore64.sys. The evasion technique\nsupports disabling a whopping list of over 1,000 drivers on which security products rely to\nprovide protection. Sophos products provide mitigations against the tactics discussed in this\narticle.\n\n“Bring Your Own [Vulnerable] Driver” is the name given to this technique — exploiting a\ntargeted system by abusing a legitimate signed driver with an exploitable vulnerability. In July\n[2022, Trend Micro reported on the abuse of a vulnerable anti-cheat driver for the game](https://www.trendmicro.com/en_us/research/22/h/ransomware-actor-abuses-genshin-impact-anti-cheat-driver-to-kill-antivirus.html)\nGenshin Impact, named mhyprot2.sys, to kill antivirus processes and services for mass[deploying ransomware. In May 2022, another report showcased how an AvosLocker](https://www.trendmicro.com/en_us/research/22/e/avoslocker-ransomware-variant-abuses-driver-file-to-disable-anti-Virus-scans-log4shell.html)\nransomware variant likewise abused the vulnerable Avast anti-rootkit driver aswarpot.sys to\nbypass security features.\n\n\n-----\n\nNow that the actors behind BlackByte ransomware and this sophisticated technique are back\nfrom a brief hiatus, chances are good that they will continue abusing legitimate drivers to\nbypass security products. To help the industry proactively prevent such attacks, we share our\nfindings in this report.\n\n**Glancing At CVE-2019-16098**\n\nRTCore64.sys and RTCore32.sys are drivers used by Micro-Star’s MSI AfterBurner\n4.6.2.15658, a widely used graphics card overclocking utility that gives extended control over\ngraphic cards on the system. CVE-2019-16098 allows an authenticated user to read and\nwrite to arbitrary memory, which could be exploited for privilege escalation, code execution\nunder high privileges, or information disclosure.\n\nThe I/O control codes in RTCore64.sys are directly accessible by user-mode processes. As\nstated by Microsoft’s [guideline on securing IOCTL codes in drivers, defining IOCTL codes](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/security-issues-for-i-o-control-codes)\nthat allow callers to read or write nonspecific areas of kernel memory is considered\ndangerous. No shellcode or exploit is required to abuse the vulnerability — just accessing\nthese control codes with malicious intent. Later in this article, we will explain how BlackByte\nabuses this vulnerability to disable security products.\n\n\n-----\n\n_Figure 1: Unprotected control codes in RTCore64.sys allowing read and write operations to_\n_kernel memory_\n\n**Kernel Notify Routines**\n\nKernel Notify Routines are used by loaded drivers to be notified by the kernel of system\nactivity. Some of these notified system activities include:\n\n[Whether a thread is created, registered via PsSetCreateThreadNotifyRoutine](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine)\n[Whether a process is created, registered via PsSetCreateProcessNotifyRoutine](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine)\n[Whether an image is loaded, registered via PsSetLoadImageNotifyRoutine](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine)\n\n\n-----\n\nWhen a callback function is registered, the address of the callback function address is added\nto an array. For example, the array containing all registered callbacks via\nPsSetCreateProcessNotifyRoutine is called PspCreateProcessNotifyRoutine.\n\nTo envision this, imagine a process A.EXE, which tries to create a new process B.EXE.\nA.EXE will notify the windows kernel NTOSKRNL.EXE that a new process should be\ncreated. The Windows kernel will assign a new process ID to the soon-to-be created\nprocess, but will not allow executing the user-mode code of B.EXE yet. Process B.EXE stays\nin a suspended state first.\n\nIf a driver has registered a callback via PsSetCreateProcessNotifyRoutine, the kernel will\nhand over control and execute the registered driver callback function. After the driver routine\nis finished, the control will be transferred back to the kernel, and allow continuation of the\nuser-mode code. This entire process is illustrated below.\n\n_Figure 2: How Kernel Notify Routines work at a high level_\n\nThese routines are often used by drivers related to security products to collect information\nabout system activity. One goal of an attacker might be to remove these callbacks from\nkernel memory. However, modern OS mitigations like Driver Signature Enforcement mean\nthat attackers cannot simply load their own rootkit or driver onto the target system to read\nfrom or write to kernel memory. In order to bypass this security feature, the attacker has the\nfollowing options:\n\n\n-----\n\n1. Steal valid code signing certificates or acquire them anonymously\n2. Abuse existing signed drivers to read, write, or execute code in kernel memory\n\nThe easier option is the second one, as there is a wide range of legitimate drivers available\nand blacklisting all of them is simply not possible. Hence, the “Bring Your Own [Vulnerable]\n[Driver” technique has been abused often in the past by adversaries [1][2][3].](https://www.trendmicro.com/en_us/research/22/e/avoslocker-ransomware-variant-abuses-driver-file-to-disable-anti-Virus-scans-log4shell.html)\n\n**Diving Into BlackByte’s EDR Bypass**\n\nOur analysis targeted the BlackByte sample with the sha256\n\n9103194d32a15ea9e8ede1c81960a5ba5d21213de55df52a6dac409f2e58bcfe\n\nThe sample was already analyzed by other researchers; thus, we focus solely on the EDR\n(endpoint detection and response) bypass technique we found. However, we encountered\nmultiple anti-analysis measurements during our investigation, which we list in the appendix\nbelow. The list is not complete, but it should ease fellow reverse engineers’ work to reach the\nEDR bypass.\n\nFurthermore, we have also identified routines to deactivate the ETW (Event Tracing for\nWindows) Microsoft-Windows-Threat-Intelligence provider, a feature that provides logs about\nthe use of commonly maliciously abused API calls such as NtReadVirtualMemory to inject\ninto another process’s memory. This renders every security feature that relies on this\nprovider useless.\n\nThis article focuses solely on how the kernel callback removal is implemented. However, the\nimplementation to disable the Microsoft-Windows-Threat-Intelligence provider is almost\ncompletely copied from EDRSandblast’s implementation. If readers are interested in how this\n[method works, we recommend reading this article by slaeryan of CNO Development Labs.](https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider)\n\nOnce the anti-analysis checks finish, BlackByte attempts to retrieve a file handle of the\nMaster Boot Record, as seen in Figure 3. If failed, the ransomware tries to at least bypass\nUser Access Control and restart itself with higher privileges via CMLUA or CMSTPLUA UAC\nBypass.\n\n\n-----\n\n_Figure 3: CreateFile on PHYSICALDRIVE0, showing the retrieval attempt_\n\nOnce restarted with higher privileges, it will now enter the EDR Bypass routine. We can\ndivide this process in two phases:\n\n1. Kernel Identification and Service Install\n2. Removal Of Kernel Notify Routines\n\n**Phase 1: Kernel Identification and Service Install**\n\nFirst, it will extract the version information of ntoskrnl.exe via GetFileVersionInfoW. The\nversion information is concatenated to a ntoskrnl_ prefix. The built string is compared against\na list of supported kernel version IDs. The list is embedded into the binary and decrypted via\na simple combination of base64-decoding and 8-byte XOR key decryption. Determining the\nkernel version is essential to select the correct offsets to the structures in kernel memory that\nare supposed to be patched. Figure 4 illustrates the entire process of phase 1.\n\n\n-----\n\n_Figure 4: Matching kernel version identifier and extracting offsets from decrypted kernel_\n_offset list_\n\nOverall, for each kernel version ID, the following offsets are provided:\n\n**Field** **Description**\n\nntoskrnlVersion Unique identifier for ntoskrnl.exe version, built\nby concatenating as described in text block\nabove\n\nPspCreateProcessNotifyRoutineOffset Offset to array holding registered driver\ncallbacks via PsSetCreateProcessNotifyRoutine\n\nPspCreateThreadNotifyRoutineOffset Offset to array holding registered driver\ncallbacks via PsSetCreateThreadNotifyRoutine\n\nPspLoadImageNotifyRoutineOffset Offset to array holding registered driver\ncallbacks via PsSetLoadImageNotifyRoutine\n\n_PS_PROTECTIONOffset Offset to _PS_PROTECTION field in\nEPROCESS structure, defining the protection\nlevel of a process\n\n\n-----\n\nEtwThreatIntProvRegHandleOffset Offset to structure holding GuidEntry and\nProviderEnableInfo fields below, needed to\nremove the ETW Microsoft-Windows-ThreatIntelligence provider\n\nEtwRegEntry_GuidEntryOffset Offset to GuidEntry in structure above\n\nEtwGuidEntry_ProviderEnableInfoOffset Offset to ProviderEnableInfo in structure above\n\n_Table 1: Matching offsets for each kernel ID_\n\nOnce the kernel version is identified and the offsets are determined, BlackByte continues by\ndropping RTCore64.sys into the AppData\\Roaming folder. The filename is hardcoded into\nthe binary and omits the file extension.\n\nA service is created via CreateServiceW and finally started. The service name and the\ndisplay name are both hardcoded into the binary. While the service name is always the\nsame, the display name is randomly selected from a list of very depressing strings, listed\nbelow.\n\n**Hardcoded Display Names (Randomly Selected)**\n\nI’m so lonely, help me.\n\nStop doing this, go away, they are waiting for you at home.\n\nYou laugh a lot, because you simply don’t have the strength to cry.\n\nWhen will it end? I want this.\n\nAAAAAAAAAAAAAA!!!!!!!!!!!!!!!\n\nIf I had feelings, then I would probably be happy and scared at the same time.\n\nWho are you? However, it doesn’t matter. Nobody ever cares about you.\n\nThe routine dragged on.\n\nI’m at a dead end, help me.\n\nI’m empty inside, help me.\n\nMay be enough?\n\nBad ending.\n\n_Table 2: A selection of frankly concerning display names_\n\n**Phase 2: Removal of Kernel Notify Routines**\n\n\n-----\n\nAfter the offsets are determined and the service installed, the sample continues to remove\nthe callbacks from kernel memory. In this phase, BlackByte abuses the arbitrary read and\nwrite vulnerability in RTCore64.sys. Thus, all mentioned read and write operations to kernel\nmemory are via the exploitable driver.\n\nAs explained in the section “Kernel Notify Routine,” there are at least three different arrays\nthat can contain addresses to callback functions:\n\nPspCreateProcessNotifyRoutine for process creation, filled by\nPsSetCreateProcessNotifyRoutine\nPspCreateThreadNotifyRoutine for thread creation, filled by\nPsSetCreateThreadNotifyRoutine\nPspLoadImageNotifyRoutine for image loading, filled by PsSetLoadImageNotifyRoutine\n\nFor the sake of simplicity, we will focus on how the process creation callbacks are removed.\nThe process for the other two events is the same, even though different offsets are used.\n\nGenerally speaking, in order to remove these callbacks BlackByte needs to complete the\nfollowing three phases:\n\n2a. Identify the address of the array PspCreateProcessNotifyRoutine\n\n2b. Identify to which driver the corresponding callback function belongs\n\n2c. Overwrite the callback function inside the array with zeros\n\n**2a. Identify the address of the array PspCreateProcessNotifyRoutine**\n\nThe sample identified the kernel version and fetched the corresponding needed offsets from\nthe hardcoded list. Depending on the array we are iterating, a different offset is used. In this\ncase, offset 0xCEC3A0 leads to PspCreateProcessNotifyRoutine.\n\nIt retrieves the base address of ntoskrnl.exe via EnumDeviceDrivers and adds the offset to\nPspCreateProcessNotifyRoutine. This will retrieve the pointer to\nPspCreateProcessNotifyRoutine holding all callbacks registered via\nPsSetCreateProcessNotifyRoutine.\n\n\n-----\n\n_Figure 5: Retrieving the address for the PspCreateProcessRoutine array_\n\n**2b. Identify to which driver the corresponding callback function belongs**\n\nNext, BlackByte needs to identify whether the callback function belongs to a driver used by\nEDR products. To achieve this, BlackByte uses a procedure to calculate the most likely driver\nfrom the callback address itself.\n\nAt the start of the procedure, all base addresses are fetched via EnumDeviceDrivers. Each\nbase address is compared against the callback function address. From all fetched\naddresses, the base address with the smallest delta to the callback function address is\nchosen and passed to GetDeviceDriverBaseNameW, which will return the name of the\ncorresponding driver.\n\nThe driver’s name is then compared against a list of over 1000 driver names. If the driver’s\nname matches one of the names in the list, the binary will continue to remove the callback.\n\n**2c. Remove the callback function from array**\n\n\n-----\n\nIn the final step, the malware will remove the callback entry from the\nPspCreateProcessRoutine array. Overwriting the entry is done by calling DeviceIoControl to\ninteract with RTCore64.sys again. The element that holds the address to the callback\nfunction of the driver is simply overwritten with zeros.\n\n**Similarities between EDRSandblast and BlackByte’s EDR Bypass**\n\nDuring our analysis, we have found multiple similarities between the open-source tool\n[EDRSandblast and the EDR Bypass implementation we’ve just covered. EDRSandblast is a](https://github.com/wavestone-cdt/EDRSandblast)\ntool written in C to weaponize vulnerable signed drivers to bypass EDR detections via\nvarious methods. Thus, we believe that the group behind BlackByte have at least copied\nmultiple code snippets from the open-source tool and reimplemented it into the ransomware.\nBelow is a list of similarities between the open-source tool and BlackByte’s implementation:\n\nThe list of known drivers related to security software is almost if not completely\nidentical.\nEDRSandblast’s github repository contains a list of supported kernel offsets and\nversions in a CSV file. If we decrypt the kernel offset list from BlackByte, it is almost if\nnot completely identical to the list in the GitHub repository, except that the CSV file\nheader is missing.\nMultiple functions defined in EDRSandblast can be found almost if not completely\nidentical in the implementation of BlackByte.\n\nTo conclude, we suggest the following to proactively defend against such type of attacks:\n\nThreat actors rarely deploy legitimate drivers with zero-day vulnerabilities. Usually, the\nvulnerabilities in the attacks are well-known and documented. By keeping track of the\nlatest security news, you can prepare beforehand and investigate which legitimate\ndrivers are currently exploited by threat actors, for example by blocklisting drivers\nknown to be exploitable.\nAlways keep track of the drivers installed on your systems. Vulnerable legitimate\ndrivers can also be installed on the target system beforehand, such that there is no\nneed for threat actors to drop it on the target system. Thus, you should always keep\nyour system updated.\n\n[For a list of IoCs associated with this threat, please see our GitHub.](https://github.com/sophoslabs/IoCs/blob/master/Ransomware-BlackByte.csv)\n\n**Appendix: BlackByte’s anti-analysis tricks**\n\nBlackByte calls the IsDebuggerPresent and CheckRemoteDebuggerPresent API. If a\ndebugger is detected, execution will quit.\n\n\n-----\n\nThe sample tries to hide the main thread from debugger by calling\nNetSetInformationThreadW with undocumented value\nTHREAD_INFORMATION_CLASS::ThreadHideFromDebugger to prevent a debugger\nfrom being attached to a running process.\nBlackByte tries to detect whether a hardware breakpoint is set via GetThreadContext.\nWhile we did not fully confirm, we believe that this API call is used to detect hardware\nbreakpoints being set by a debugger. GetThreadContext is known to be used to by\nmalware to detect such breakpoints.\nThe sample performs a simple filename length check. If longer than 10 characters,\nexecution will quit.\nSimilarly, as explained in ZScaler’s [article about BlackByte, the sample performs a](https://www.zscaler.com/blogs/security-research/analysis-blackbyte-ransomwares-go-based-variants)\ncheck as to whether any known hooking DLL is injected into the binary. If a blacklisted\nDLL is found, execution will quit. The list is consistent with the ones provided by the\nlinked article.\nBlackByte ransomware requires a seed to be passed via the “-s” parameter. The\ncorrect seed is hardcoded into the binary as an encrypted string. If the seed does not\nmatch, execution will quit.\n\n**Further reading**\n\n[bs [handle]. “Removing Kernel Callbacks Using Signed Drivers.” GitHub, August 2,](https://br-sn.github.io/Removing-Kernel-Callbacks-Using-Signed-Drivers/)\n2020. Link retrieved October 4, 2022\n[Hand, Matt. “Mimidrv In Depth: Exploring Mimikatz’s Kernel Driver.” SpecterOps (via](https://posts.specterops.io/mimidrv-in-depth-4d273d19e148)\nMedium), January 13, 2020. Link retrieved October 4, 2022\nVicente, Javier; Stone-Gross, Brent. “Analysis of BlackByte Ransomware’s Go-Based\nVariants.” ZScaler, May 3, 2022. Link retrieved October 4, 2022\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-10-04 - Remove All The Callbacks – BlackByte Ransomware Disables EDR Via RTCore64.sys Abuse.pdf"
    ],
    "report_names": [
        "2022-10-04 - Remove All The Callbacks – BlackByte Ransomware Disables EDR Via RTCore64.sys Abuse.pdf"
    ],
    "threat_actors": [
        {
            "id": "4e453d66-9ecd-47d9-b63a-32fa5450f071",
            "created_at": "2024-06-19T02:03:08.077075Z",
            "updated_at": "2025-03-27T02:05:17.381141Z",
            "deleted_at": null,
            "main_name": "GOLD LOTUS",
            "aliases": [
                "Hecamede ",
                "BlackByte"
            ],
            "source_name": "Secureworks:GOLD LOTUS",
            "tools": [
                " Cobalt Strike",
                " ExByte",
                " MEGA",
                " RDP",
                " SoftPerfect Network Scanner",
                "BlackByte"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535664,
    "ts_updated_at": 1743041653,
    "ts_creation_date": 1669661604,
    "ts_modification_date": 1669661604,
    "files": {
        "pdf": "https://archive.orkl.eu/c82ccdda045495783968b39125725eb22de03c01.pdf",
        "text": "https://archive.orkl.eu/c82ccdda045495783968b39125725eb22de03c01.txt",
        "img": "https://archive.orkl.eu/c82ccdda045495783968b39125725eb22de03c01.jpg"
    }
}