{
    "id": "d4b6f167-5b2e-4481-aade-58572dcfda12",
    "created_at": "2023-01-12T15:03:05.427431Z",
    "updated_at": "2025-03-27T02:06:08.978407Z",
    "deleted_at": null,
    "sha1_hash": "2c66b8877f6a88f01fd866ac55ad50cab37db5ef",
    "title": "2017-02-22 - Dissecting the Qadars Banking Trojan",
    "authors": "",
    "file_creation_date": "2022-05-27T21:30:35Z",
    "file_modification_date": "2022-05-27T21:30:35Z",
    "file_size": 528988,
    "plain_text": "# Related Insights\n\n**[info.phishlabs.com/blog/dissecting-the-qadars-banking-trojan](https://info.phishlabs.com/blog/dissecting-the-qadars-banking-trojan)**\n\n## By Stacy Shelley | February 22, 2017\n\n\nFebruary 23, 2017\n\n\nQadars is a sophisticated and dangerous trojan used for crimeware-related activities\nincluding banking fraud and credential theft. Qadars targets users through exploit kits and is\ninstalled using Powershell Scripts. We have observed Qadars targeting multiple well-known\nbanks in UK and Canada and is capable of stealing infected users’ two-factor authentication\n[codes and banking credentials through the deployment of webinjects. While not as well](https://securityintelligence.com/meanwhile-britain-qadars-v3-hardens-evasion-targets-18-uk-banks/)\nknown or widespread as other Trojans, the operators have shown commitment to\ndevelopment of Qadars’ on-board evasion techniques and its advanced and adaptable\nprivilege escalation module. This emphasis on persistence alongside the frequent shifts in\nboth industry and geographic targeting indicate Qadars will remain a potent threat through\n2017.\n\n_List of_\n\n_webinject targets from a Qadars configuration file_\n\nIn this technical blog post, we will analyze a Qadars binary file and provide code and a Yara\nrule to aid in the analysis and detection of this banking Trojan. First, we will examine Qadars’\nmethods of thwarting reverse engineering through the utilization of a dynamically resolved\nImport Address Table with obfuscated functions and strings. We then will detail the trojan’s\nbehaviour and dynamically-generated command and control centers with which it\ncommunicates. The C2s are not utilized solely for the collection of stolen credentials. We\nhave also observed them delivering a module to Qadars samples operating in a low privilege\nenvironment that employs social engineering to trick the user into allowing higher level\naccess.\n\n### Import Address Table (IAT) and String Obfuscation\n\n\n-----\n\nIn its pure form, Qadars has built-in protection to make reverse engineering difficult, such as\ndynamic resolution of the Import Address Table (IAT) and obfuscation of the IAT functions\nand strings. At the beginning of execution, it calls a subroutine responsible for resolving and\nconcealing IAT entries.\n\nIt locates API entries using a well-known hashing method. For example, in the code depicted\nbelow, 9B102E2Dh corresponds to LoadLibraryA:\n\n_Resolving API Calls via Hashing Mechanism_\n\nDynamic Link Libraries (DLLs) are loaded using LoadLibrary and API names are located by\nparsing the export address table as show in the trace file below:\n\n\n-----\n\n_Loading DLLs Using LoadLibrary_\n\n_Function_\n\nFurthermore, Qadars conceals an API function by XORing the address of an API call with a\n4-byte XOR-Key. Wherever there is a call to a particular API function, the original value is\nreverted back to its XOR-encoded value.\n\n\n-----\n\n_Decoding_\n\n_XOR-encoded API Call_\n\nIn order to simplify the analysis, we can utilize one of two methods: create an IDA script to\nstatically resolve the import addresses, or create an IDA script to rebuild the IAT. We will\nutilize the latter method.\n\n### Reconstructing Imports by Instruction Patching\n\nIn order to restore the imported function, we would need our instructions to specify CALL\n\n[APIPointer] instead of CALL . However, patching an indirect call would not be allowed\nbecause the size of an indirect call is only 2 bytes, while the size of a referenced call is 6\nbytes. We could accommodate these additional 4 bytes by NOP’ing the previous XOR\noperation which is used to retrieve the original value. In this manner, we could keep the\noffsets at their specified and original locations. The following code comparison (also known\nas diff) illustrates this concept:\n\n_Maintaining Memory Offsets by Inserting NOP Instructions_\n\nAll resolved entries are stored in an array 748 bytes in size consisting of 187 total API calls.\n\n\n-----\n\n_Resolved API Function Calls_\n\nWe will use the following script to XOR the API address array with the original global XOR\nkey. This allows us to patch and relocate the instructions.\n\n\n-----\n\n```\n# Raashid Bhat\n# (C) PhishLabs 2017\n# IAT Patch Script Qadars Banking Trojan\nXORKey = 0x43B9A447 # 2017 v3\nLoadLibException = 0x004196F0\nApiResolvRange = 0x00406150\nApiResolvRangeLen = 0x00409ACC - 0x00406150        \nfrom capstone import *\nimport struct\nDebug = 1\ndef ReadMem(addr, n):\nglobal Debug\nif Debug:\nreturn DbgRead(addr, n)\nelse:\nreturn GetManyBytes(addr, n)\ndef WriteMem(addr, buff):\nglobal Debug\nif Debug:\n    DbgWrite(addr, buff)\nelse:\nfor i in buff:\n      PatchByte(addr, ord(i))\n      addr = addr + 1\nreturn\ndef PatchIndirectCall(MemAddr, Addrs, CallDst):\n  Reg = ''\n  md = Cs(CS_ARCH_X86, CS_MODE_32)\nfor i in md.disasm(MemAddr, Addrs):\nprint \"0x%x:t%st%s\" %(i.address, i.mnemonic, i.op_str)\nif i.mnemonic == 'xor' and Reg == '':\nprint i.op_str[0:3]\n      Reg = i.op_str[0:3]\nif i.mnemonic == 'call':\nif i.op_str == Reg:\n                             print \"0x%x:t%st%s\" %(i.address,\ni.mnemonic, i.op_str)\n          print \"Size = %d\" % (i.address - ( Addrs + 6))\n        Inst = ReadMem(Addrs + 6, (i.address - ( Addrs + 6))) # read\nremaining instructions\n        WriteMem( Addrs, 'x90' * (i.address - ( Addrs) + 2)) # write NOPS\n        WriteMem(Addrs, Inst)\n        Inst = \"xffx15\" + struct.pack(\"\n\n```\n\n-----\n\n```\n        WriteMem(i.address  6, Inst)\nreturn\nfor i in range(0x004193DC, 0x004196F0, 4):\n  PatchDword(i, DbgDword(i) ^ XORKey) \nif i == LoadLibException:\ncontinue\n  x = XrefsTo(i) \n  for j in x:\n    addr = j.frm\n     print addr\n     if addr > ApiResolvRange and addr       print \"[] API Patch Subroutine\nSkipping... \"\n       continue\n     print hex(j.frm)\n    PatchIndirectCall(ReadMem(addr, 0x32), addr, i)\n\n```\n_Script to Patch API Address Array_\n\n_Patching_\n\n_Import Address Table_\n\nUpon opening this file in IDA, we are presented with an annotated Import Address Table:\n\n\n-----\n\n_Patched Import Address Table in IDA_\n\nSimilarly, we can use an IDA script to deal with Qadars string obfuscation which is simply a\nXOR-based decoding algorithm in which each of the encoded strings has the following\nstructure:\n```\nstruct EncodedString\n{\n     DWORD len;\nchar Encodedbuf[len]; // XOR encoded with a key\n}\nXORKEY = “4B57A7E012368BE9AA48” // found in sample\n  while ( v12   {\n   *(_BYTE *)(v12++ + v13) ^= v15[v14];\n   v14 = (v14 + 1) % v11;\n  }\n  result = v13;\n\n```\n\n-----\n\nThe code can be simply represented in Python as follows:\n```\ndef DecodeString(Ea):\n  XORBuff = \"4B57A7E012368BE9AA48\".decode(\"hex\") \n  BuffLen = Dword(Ea)\nprint \"[] Buffer Len = %d \" % BuffLen\n  dst = \"\nfor i in range(0, BuffLen):\n    dst = dst + chr( (Byte(Ea + 4 + i) & 0xff) ^ ord(XORBuff[i % (10)]))\nprint len(dst)\n  j = 0\nfor i in dst:\n    PatchByte(Ea + j, ord(i))\n    j = j + 1\n\n```\nWe will use the following IDA Python script to help us with decoding all encoded strings\npresent in Qadars:\n\n\n-----\n\n```\n# IDAPython String Decoder For Qadars\n# Raashid Bhat\n# (C) PhishLabs 2017\nimport struct\nprocesed = []\ndef DecodeString(Ea):\n  XORBuff = \"4B57A7E012368BE9AA48\".decode(\"hex\") #xorkey \n  BuffLen = Dword(Ea)\nprint \"[] Buffer Len = %d \" % BuffLen\n  dst = \"\nfor i in range(0, BuffLen):\n    dst = dst + chr( (Byte(Ea + 4 + i) & 0xff) ^ ord(XORBuff[i % (10)]))\nprint len(dst)\n  j = 0\nfor i in dst:\n    PatchByte(Ea + j, ord(i))\n    j = j + 1\nfor i in CodeRefsTo(ScreenEA(),1):\nprint hex(i)\n  ea = PrevAddr(i)\nwhile \"push  offset\" notin GetDisasm(ea):\n    ea = PrevAddr(ea)\nprint GetDisasm(ea)[19:]\nif \"asc_\" in GetDisasm(ea):\n    addr = GetDisasm(ea)[19:].split(\";\")[0]\nelse:\n    addr = GetDisasm(ea)[19:]\nif int(addr, 16) in procesed:\ncontinue\n  DecodeString(int(addr, 16))\n  procesed.append(int(addr, 16))\nfor i in procesed:\n  MakeStr(i, BADADDR)\n\n```\nRunning this script on the sample decodes all strings and makes them visible in the Strings\nwindow.\n\n\n-----\n\n_Deobfuscated_\n\n_Strings_\n\n### Privilege Escalation / Social Engineering and Spoofing Adobe Update\n\nIf Qadars is not presented with a specific set of privileges, it tries to contact and download a\nmodule from the command and control center. This module is then loaded in memory and an\nexport, aptly named “Exploit” is invoked to complete the privilege escalation. Currently, a\nknown vulnerability in how the Win32k.sys kernel-mode driver handles objects in memory is\n[exploited for this purpose (CVE-2015-1701).](https://www.cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2015-1701)\n\n_Decoding ‘Exploit’ Module_\n\n\n-----\n\n_Debugging Symbols for ‘Exploit’ Module_\n\n_‘Exploit’ Module in DLL Exports_\n\n\n-----\n\n_Elevated Permissions Following_\n\n_Invocation of ‘Exploit’ Module_\n\nIf the privilege escalation code does not work, Qadars attempts to socially engineer the\nvictim with a fake Windows security update prompt. This executes code that allows Qadars\nto run with higher privileges using the “runas” verb:\n\n\n-----\n\n_Fake Windows Security Prompt_\n\nUpon execution of the malware, it loads a fake window with a progress bar masquerading as\nan Adobe Updater application to provide a sense of legitimacy.\n\n_Fake Adobe Flash Update_\n\n### Communication and DGA\n\nQadars locates the command and control center by generating a list of 200 domains using a\n[combination of a time seed and some constants. On February 1st, Qadars started using a](https://johannesbader.ch/2016/04/the-dga-of-qadars/)\nnew seed value 0xE1F1, replacing the previous seed, 0xE1F2.\n\n\n-----\n\nQadars Domain Generation 2.png\nQadars Domain Generation 1.png\n\n_Generation_\n\n\n_Domain_\n\n\nInitially, two information packets are generated and concatenated. They consist of a chunk of\ninformation serialized in the following format: botid, version, operation type, etc.\n\nThis information is packed together and fed to another subroutine which generates a MD5\nhash of a 9-byte random string. This string will be used as an AES-128 encryption key which\nis then appended in the beginning of the encoded packet for command and control traffic\ndecoding.\n\nInformation is serialized in each entry in the following format:\n```\nstruct InfoStructEntry\n{\nunsigned int len;\nunsigned char Buffer[len];\n}\n\n```\nThe response is encrypted using AES-128 and the first 16 bytes consist of the MD5 hash of\nthe command and control buffer. This hash is used for verification before processing.\n```\nStruct c2packet\n{\nBYTE MD5Hash[16];\nBYTE []AESEncryptedBuffer;\n}\n\n```\nAfter decryption, the base packet consists of metadata information which is used to\ndetermine the parameters and type of block to be processed. Multiple entries consist of\neither modules, updates, or a web inject file which is APLIB compressed.\n\n\n-----\n\nQadars Base Packet.png\n\n\n### Yara rule\n\nThe following Yara rule can be used to identify this Qadars variant:\n```\nrule Qadars\n {\n   strings:\n     $dga_function = { 69 C9 93 B1 39 3E BE F1 E1 00 00 2B F1 81 E6 FF FF FF 7F\nB8 56 55 55 55 F7 EE 8B C2 C1 E8 1F 03 C2 8D 04 40 }\n   condition:\n     $dga_function\n }\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-02-22 - Dissecting the Qadars Banking Trojan.pdf"
    ],
    "report_names": [
        "2017-02-22 - Dissecting the Qadars Banking Trojan.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535785,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1653687035,
    "ts_modification_date": 1653687035,
    "files": {
        "pdf": "https://archive.orkl.eu/2c66b8877f6a88f01fd866ac55ad50cab37db5ef.pdf",
        "text": "https://archive.orkl.eu/2c66b8877f6a88f01fd866ac55ad50cab37db5ef.txt",
        "img": "https://archive.orkl.eu/2c66b8877f6a88f01fd866ac55ad50cab37db5ef.jpg"
    }
}