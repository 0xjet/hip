{
    "id": "8687617d-c236-4b91-b7a9-287f11a9566e",
    "created_at": "2023-01-12T15:01:41.805715Z",
    "updated_at": "2025-03-27T02:17:00.450141Z",
    "deleted_at": null,
    "sha1_hash": "504159f996e289c7e777d6bbf3006170c5ebfda3",
    "title": "2022-08-18 - From Ramnit To Bumblebee (via NeverQuest)- Similarities and Code Overlap Shed Light On Relationships Between Malware Developers",
    "authors": "",
    "file_creation_date": "2022-09-01T10:22:11Z",
    "file_modification_date": "2022-09-01T10:22:11Z",
    "file_size": 6752614,
    "plain_text": "# From Ramnit To Bumblebee (via NeverQuest): Similarities and Code Overlap Shed Light On Relationships Between Malware Developers\n\n**[securityintelligence.com/posts/from-ramnit-to-bumblebee-via-neverquest](https://securityintelligence.com/posts/from-ramnit-to-bumblebee-via-neverquest)**\n\n[Home&nbsp/](https://securityintelligence.com/) [Malware](https://securityintelligence.com/category/x-force/malware-threat/)\nFrom Ramnit To Bumblebee (via NeverQuest): Similarities and Code Overlap Shed Light On\nRelationships Between Malware Developers\n\n\n-----\n\n[Malware\nAugust 18, 2022](https://securityintelligence.com/category/x-force/malware-threat/)\nBy [Charlotte Hammond co-authored by\nOle Villadsen\n26 min read](https://securityintelligence.com/author/charlotte-hammond/)\nA comparative analysis performed by IBM Security X-Force uncovered evidence that\nsuggests Bumblebee malware, which first appeared in the wild last year, was likely\ndeveloped directly from source code associated with the Ramnit banking trojan. This newly\ndiscovered connection is particularly interesting as campaign activity has so far linked\n[Bumblebee to affiliates of the threat group ITG23 (aka the Trickbot/Conti group), who are not](https://securityintelligence.com/posts/trickbot-gang-doubles-down-enterprise-infection/)\nknown to have had a previous connection with Ramnit.\n\nThis year has so far proven tumultuous for ITG23 – the group suffered a series of high profile\nleaks, referred to as the ContiLeaks and TrickLeaks, which resulted in the publication of\nthousands of chat messages and the doxxing of numerous group members. In addition, the\ngroup have seemingly retired two of their most high-profile malware families, Trickbot and\nBazar, and shutdown their Conti ransomware operation.\n\nVarious reports have suggested that a significant reshuffling of personnel may be occurring,\nwith ITG23 splitting into several factions and some members moving on entirely. The\nappearance of Ramnit code within Bumblebee may be indicative of this flux and a sign that\nnew alliances are being formed, which could be a prelude to new types of attack campaigns.\n\nThis research highlights previously unreported similarities and code overlaps between the\nBumblebee and Ramnit malware families. It also examines the links between these two\nmalware families, ITG23’s Trickbot malware, and the retired NeverQuest banking trojan.\n\nThe findings include:\n\nSignificant code overlap between Bumblebee and Ramnit, suggesting they may share\nthe same developer\n\n\n-----\n\nA custom code library used in both the Bumblebee/Ramnit malware and Trickbot trojan,\nindicating possible historical code sharing\nEvidence of potential collaboration between the developers of NeverQuest and Trickbot\nin the early days of Trickbot’s development\n\nThe analysis below provides further detail and explanations on the unique aspects observed\nbetween Bumblebee and Ramnit, and how they can be connected back to Trickbot and\nfinally traced to their suspected origins within the retired NeverQuest banking trojan.\n\n## From Ramnit to Bumblebee\n\n[Ramnit is an older malware that originated in 2010 as a worm and swiftly evolved into a](https://exchange.xforce.ibmcloud.com/malware-analysis/guid:7680268ad009c082847e5dd9062549d8)\nmodular backdoor and banking trojan. Ramnit spread prolifically over the next few years,\ngrowing into a botnet with several million systems infected worldwide until it was subject to a\n[takedown by Europol in early 2015. The impact of the takedown did not last long and by the](https://thehackernews.com/2015/02/europol-takes-down-ramnit-botnet-that.html)\n[end of 2015 Ramnit returned and was once again in active development. The malware](https://securityintelligence.com/the-return-of-ramnit-life-after-a-law-enforcement-takedown/)\nstruggled to regain its previous momentum, however, and the following years were\n[characterised by campaigns of activity followed by periods of quiet.](https://securityintelligence.com/ramnit-rears-its-ugly-head-again-targets-major-uk-banks/)\n\n[A notable development occurred in mid-2018, when Ramnit relaunched, infecting 100,000](https://securityintelligence.com/news/ramnit-infects-more-than-100000-machines-in-two-months/)\n[devices in two months, and demonstrating significant code updates. This included the](https://www.vkremez.com/2018/08/lets-learn-in-depth-into-latest-ramnit.html)\naddition of new loader modules which made extensive use of a custom hooking library for\nboth payload execution and AV evasion; web injects were updated from Zeus-style to Luastyle; and a new name ‘Camellia’ appeared, replacing the original ‘Demetra’ designation. The\n[reason for this overhaul is unknown, but some researchers noted that the code style had](https://securityintelligence.com/the-business-of-organized-cybercrime-rising-intergang-collaboration-in-2018/)\nchanged and speculated that it may have new developers.\n\nRamnit went through another quieter period during 2019 and 2020, with no significant\ndevelopments observed. Then in early 2021, new Ramnit samples were observed using the\ninternal name ‘hooker2.dll’, which matched several of the samples observed during Ramnit’s\nresurgence in August 2018. The sample code was similar to its 2018 counterparts but had\ngone through several updates, which included the addition of the OpenSSL library.\n\nIn August 2021, X-Force spotted a new malware that we shall now refer to as ‘Bumblebee\nBeta’ being deployed during a campaign exploiting the CVE-2021-4044 Microsoft Office\nvulnerability. This activity was attributed to the [initial access broker “Exotic Lily”, which X-](https://blog.google/threat-analysis-group/exposing-initial-access-broker-ties-conti/)\nForce tracks as Hive0110, and who have previously distributed BazarLoader. This new\nmalware primarily operated as a downloader and was capable of receiving payloads, such as\nCobalt Strike, from the C2, which it would inject into a process randomly chosen from a\nhardcoded list. It was notable for using the user-agent string ‘bumblebee‘, which overlaps\nwith the full version and is how the malware’s eventual name was derived. During our\nanalysis at the time, we observed a number of significant code overlaps with Ramnit,\nincluding identical lists of inject targets, similar hooking and unhooking code, use of the\n\n\n-----\n\nOpenSSL library and the presence of two unused intermediary loader binaries stored in the\nmalware data section, which were almost identical to those used in the 2018 and 2021\nvariants of Ramnit.\n\nIn March 2022, the full version of Bumblebee was released and quickly used in a number of\n[large scale campaigns by distribution affiliates of threat group ITG23 (also known as the](https://www.bleepingcomputer.com/news/security/new-bumblebee-malware-replaces-contis-bazarloader-in-cyberattacks/)\nTrickbot/Conti group), such as Exotic Lily, TA579, and TA578 (tracked by X-Force as\nHive0107). The malware appeared to be being used as a replacement for ITG23’s\n[BazarLoader which had not been seen since February and has been observed downloading](https://www.proofpoint.com/us/blog/threat-insight/bumblebee-is-still-transforming)\npayloads including Cobalt Strike, Sliver, and Meterpreter. Bumblebee has also since been\n[linked to ransomware operations involving Conti and MountLocker/Quantum.](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/bumblebee-loader-cybercrime)\n\n[Bumblebee had received several updates over the prior six months and now has full C2](https://research.nccgroup.com/2022/04/29/adventures-in-the-land-of-bumblebee-a-new-malicious-loader/)\ncommunication and task functionality implemented, as well as the inclusion of anti-AV and\nanti-analysis code. It is capable of gathering system information, installing itself for\npersistence, and receiving and loading payloads including DLLs and shellcode. The\npreviously unused intermediary loader binaries, observed in Bumblebee Beta, are now used\nas part of the fully implemented payload injection process.\n\nBumblebee still bears significant resemblance to Ramnit and in addition to the previously\nmentioned similarities, such as the inject and hooking functionality, Bumblebee was also\nfound to contain the string ‘Z:\\hooker2\\Common\\md5.cpp‘ suggesting it may have used\ncode from a project called ‘hooker2‘ which is the internal name used in several of the 2018\nand 2021 Ramnit samples. An identical string was also then found in a 2021 Ramnit sample.\n\n## The NeverQuest Connection\n\nWhile investigating the potential links between Ramnit and ITG23 in an effort to understand\n[the relationship between the groups, we — like several other researchers — also noted the](https://elis531989.medium.com/the-chronicles-of-bumblebee-the-hook-the-bee-and-the-trickbot-connection-686379311056)\ncode overlap between Ramnit/Bumblebee and the Trickbot WebInject modules which may\nindicate that some code sharing has occurred between the two groups. Finally, we were\neventually able to trace a significant portion of the code back to an old, now defunct, banking\ntrojan called NeverQuest – also known as Vawtrak.\n\n[NeverQuest was a major player in the field of banking trojans from 2013 through to early](https://securityintelligence.com/new-neverquest-variant-spotted-in-the-wild/)\n[2017 when one of its developers was arrested in Spain. It is thought that the IcedID malware,](https://securityintelligence.com/neverquest-gang-takes-leave-is-it-the-end-of-the-quest/)\n[which was discovered by IBM in September 2017, is likely to be the successor of](https://securityintelligence.com/new-banking-trojan-icedid-discovered-by-ibm-x-force-research/)\nNeverQuest. The NeverQuest group reportedly had a close relationship with Dyre, aka\n[Dyreza, the predecessor of Trickbot, potentially explaining the close relationship between the](https://securityintelligence.com/the-business-of-organized-cybercrime-rising-intergang-collaboration-in-2018/)\nTrickbot and IcedID groups today.\n\n\n-----\n\nDyre was another older banking trojan that operated around the same time as NeverQuest,\nuntil it suffered a [takedown at the hands of Russian law enforcement at the end of 2015. Its](https://securityintelligence.com/dyre-straights-group-behind-the-dyre-trojan-busted-in-moscow/)\n[successor Trickbot was released less than a year later, along with a module responsible for](https://securityintelligence.com/news/trickbot-malware-resurrects-the-ghost-of-dyre/)\n[performing browser injects. Analysis of module samples reveals that even in its earliest](https://securityintelligence.com/tricks-of-the-trade-a-deeper-look-into-trickbots-machinations/)\nstages of development in 2016, the Trickbot web inject module already contained code\nassociated with NeverQuest. Given the close relationship between NeverQuest and Dyre, it\nis not hard to imagine that NeverQuest may have offered to share code with their associates\nin order to help get Trickbot off the ground.\n\nThe link between the Trickbot group and Ramnit is less clear, as there has been less\nobservable cooperation between the two groups. However, during our investigation we did\nnote that the NeverQuest code did not seem to be present in any of the older Ramnit\nsamples we analysed; it seems that code may have only been added during Ramnit’s\nrevamp in 2018. It was speculated at the time that the revamp may suggest that Ramnit had\nnew developers, and it’s possible those developers may have had some sort of link with the\nTrickbot group. Notably, during its upgrade, Ramnit also switched to using LUA-style web\ninjects which is a language favoured by IcedID.\n\nOne challenge we faced during this exercise was tracking the provenance of the code used\nin the myriad of samples analysed. Many banking trojans today are based on the publicly\navailable leaked source code of several older trojans including Zeus, Carberp, and Gozi.\nWhen assessing code overlap between malware families, it’s therefore important to\ndetermine whether the code in question comes from a public source, as in that instance its\npresence in both malware families may just be a coincidence rather than indicating any sort\nof significant relationship.\n\nNeverQuest borrows code heavily from the leaked Gozi source, and parts of this code have\nalso made their way into Ramnit and Bumblebee, so when doing our comparison we were\ncareful to focus on areas that couldn’t be attributed to a public source. To this end, much of\nour research focuses on a hooking library that is shared across all the malware families\nanalysed in this report, but that we have not been able to trace back to any public source.\nOur research findings indicate that this library may have been originally created by the\ndevelopers of NeverQuest, and then later shared with the Trickbot group – eventually ending\nup in Ramnit and Bumblebee.\n\n## Analysis Details\n\nA number of samples were analysed for the purpose of this research, the full details of which\nare presented in the Sample Hashes table at the end of this report. This includes sets of\nRamnit samples dating back to 2018 and 2021, Bumblebee Beta samples from 2021, and\nBumblebee samples from 2022. In addition, samples including NeverQuest, Karius, and\nTrickbot’s inject modules, were analysed for the purposes of comparison and provenance\ntracking.\n\n\n-----\n\n## Ramnit s Revamp\n\nIn 2018, after a brief hiatus, Ramnit relaunched with great potency, infecting 100,000 devices\n[in two months and boasting new loaders and an upgraded code base. Campaigns involving](https://www.vkremez.com/2018/08/lets-learn-in-depth-into-latest-ramnit.html)\nthe [sLoad dropper were widely reported on and attributed to TA554. At this point, Ramnit](https://www.cybereason.com/blog/research/banking-trojan-delivered-by-lolbins-ramnit-trojan)\nwas demonstrating a complex multi-component loading mechanism, including a\ndropper/installer utilising VBS and Powershell scripts.\n\nThis research focuses on the unpacked components of Ramnit outlined in the diagram\nbelow, specifically the Camellia Loaders, Hook Loaders, and Hooker2 module. The\nfunctionality of the Ramnit Core binary, rmnsoft.dll, did not change significantly and is not\ncovered in this report.\n\n_Figure 1 — Diagram showing the relationship between different Ramnit components_\n_including the Hook Loaders, Ramnit Core, Hooker2 module, and WebInject module._\n\n### The Hook Loaders\n\nRamnit’s Hook Loaders are small binaries with the primary function to load a payload by\nhooking the Windows API functions ZwOpenFile, ZwCreateSection, ZwOpenSection and\n**ZwMapViewOfFile. The process of function hooking, as used in this example, involves**\naccessing the target library module in memory and overwriting the code at the start of the\ntarget function such that the flow of execution is redirected to a function supplied by the\nmalware.\n\nIn this instance, the functions ZwOpenFile, ZwCreateSection, and ZwOpenSection are\nhooked and redirected to functions within the loader which check the parameters being\npassed for a file named ‘wups.dll‘, before directing execution back to the original API\nfunction.\n\nIn the hook function for ZwMapViewOfSection, if the call is determined to be related to the\nloading of file ‘wups.dll’, then the payload data is retrieved, and a new memory section is\ncreated and the payload binary mapped into it. The address of this new section is then\ncopied to the BaseAddress variable which is an output parameter for ZwMapViewOfSection.\nThe result of this is that when ZwMapViewOfSection is called in relation to file ‘wups.dll’, the\naddress of the loaded payload will be returned instead of that of wups.dll.\n\n\n-----\n\nOnce these hooks have been set, the loader calls the Windows API function LdrLoadDll with\n‘wups.dll’ as the parameter. The function LdrLoadDll is used for loading DLLs, and it makes\nuse of the APIs ZwOpenFile, ZwCreateSection, ZwOpenSection and ZwMapViewOfFile as\npart of its loading process. So, when the loader calls LdrLoadDll, this triggers the hooked\nfunctions and results in the loading of the payload in place of wups.dll, as described above.\nAs part of the standard DLL loading process LdrLoadDll will also call the loaded DLL’s\nentrypoint which in this case results in the execution of the payload.\n\nDifferent versions of the Hook Loader may use DLL names other than wups.dll, and samples\nusing names such as sbe.dll, dimsroam.dll and dimsjob.dll have also been observed.\n\nThe main function for the Hook Loader showing the installation of the hooks and execution of\nLdrLoadDll can be seen in the image below.\n\n\n-----\n\n_Figure 2 — Main function for the Ramnit Hook Loader showing the installation of the hooks_\n_and execution of LdrLoadDll_\n\nTwo variations of the Hook Loader appear to be in use. One is used as a standalone loader\nand has its payload stored within its data section. The second type we have referred to in\nthis report as an intermediary loader, which is used by a parent loader during the loading\nprocess, and require the payload details to be supplied as parameters during execution. The\nparent executes the intermediary loader and passes the memory address of the payload to it\nusing the DllEntrypoint function’s ‘Reserved’ parameter, and the intermediary loader, in turn,\nloads the given payload.\n\n\n-----\n\nUpgraded versions of the intermediary Hook Loaders were observed in the 2021 Ramnit\nsample set, which could receive an RC4 encrypted payload that the loader decrypted just\nprior to loading into the allocated memory section. A 4-byte RC4 key would be passed to the\nintermediary loader by the parent along with the payload address.\n\nThis updated variant of the Hook Loader was also observed in Bumblebee samples.\n\n### The Hooking Library\n\nMany of the samples analysed throughout this report all make use of the same custom\nhooking library for the process of setting hooks and storing information about set hooks. We\nhave not been able to trace this hooking code back to any public source and the code does\nnot match the hooking functions found in the leaked source code for trojans such as Gozi,\nCarberp, and Zeus. Our analysis indicates that this hooking library was likely developed by\nNeverQuest, aka Vawtrak in 2013, and since then it has shown up in Trickbot inject modules\nstarting in 2016, Ramnit binaries from 2018, and Bumblebee from 2021.\n\nThe hooking library is easily recognisable. It makes use of a hook store that contains\ninformation about installed hooks including function addresses and the original code so the\nfunction can be restored once the hook is no longer needed. An initialization function, usually\nrun during the start of the malware’s execution, will allocate space for the hook store using\nVirtualAlloc. The size of each hook store object is 71 bytes in most 32-bit implementations\nand this constant can be useful in identifying the hook library code. The size of the hook\nstore object in 64-bit implementations appears to be 60 bytes.\n\n_Figure 3 — Hook library initialization function, referencing notable 32-bit hook object size of_\n_71 bytes._\n\n\n-----\n\n_Figure 4 — The hook creation function within a 2021 Ramnit sample. At this point several of_\n_the library’s other functions have been updated to use control flow flattening code_\n_obfuscation, which was not present in the 2018 samples._\n\n### Ramnit’s Unhooking Code\n\nHooking is not just confined to malware – it has many different applications and is often used\nby security software to examine the behaviour of processes and look for malicious activity.\nOne piece of code which is seen repeatedly throughout the Ramnit binaries checks a\nhardcoded list of API functions for any hooks that might already be set, for instance by\nsecurity applications, and removes them by restoring the code at the start of the function with\nthe original code as found in the corresponding DLL file stored on disk. Note, this\nfunctionality does not seem to make use of hooking library referenced above.\n\nSimilar code can also be seen within the Hook Loaders used within the Bumblebee samples.\n\n\n-----\n\n_Figure 5 — Ramnit’s API unhooking function_\n\n### The Camellia Loader\n\nThe Camellia Loader is usually found as a second or third stage loader in the Ramnit loading\nprocess and is generally loaded by the standalone version of the Hook Loader such as that\ndescribed above. The purpose of the Camellia Loader is to load and execute its payload via\nprocess injection. A significant amount of the code base of the Camellia Loader can be\ntraced back to source code from the leaked Gozi malware, specifically Gozi’s ‘activdll’\nmodule which contains process injection functions.\n\nUpon execution, the Camellia loader creates a new thread to run its main functionality and\nuses the same unhooking function described above to check a hardcoded list of APIs for\nhooks and restore them to their original states. The loader then selects a random process\nfrom the following hardcoded list, which will be used as the process injection target. It should\nbe noted that this process list does not appear within the Gozi source and so seems to\noriginate from Ramnit.\n\n%PROGRAMFILES%\\Windows Photo Viewer\\ImagingDevices.exe\n\n%PROGRAMFILES%\\Windows Mail\\wab.exe\n\n%PROGRAMFILES%\\Windows Mail\\wabmig.exe\n\n%PROGRAMFILES%\\Windows Media Player\\wmplayer.exe\n\n%PROGRAMFILES%\\Windows NT\\Accessories\\wordpad.exe\n\n\n-----\n\nThe loader uses the Windows Management Instrumentation (WMI) interface to create a new\ninstance of the selected process in suspended mode. It then gets a handle on the newly\ncreated process and parses it to identify the address of the process entrypoint or first TLS\ncallback function, if applicable, which will be the address of the first function executed by the\nprocess. The loader then patches the code at this address, replacing it with the following\ncode, which calls the Sleep API in an infinite loop.\n\n31 c0          xor  eax,eax\n\n31 db          xor  ebx,ebx\n\n31 c9          xor  ecx,ecx\n\n68 e8 03 00 00     push  0x3e8\n\nb8 ?? ?? ?? ??     mov  eax,<Sleep_Address>\n\nff d0          call  eax\n\neb ec          jmp  0x0\n\nAt this point the loader enters code that closely matches Gozi’s [ProcessInjectDll function.](https://github.com/t3rabyt3-zz/Gozi/blob/master/AcDll/activdll.c#L824)\nThe comments in the code for this function also provide a concise explanation for why the\nprocess needed to be patched to enter an infinite loop prior to injection:\n\n//  Injects current DLL into the process described by lpProcessInformation structure.\n\n//  We cannot just inject a DLL into the newly-creted process with main thread\nsuspended. This is because the main thread\n\n//   suspends BEFORE the process initializes. Injecting a DLL will fail within LoadLibrary\nfunction.\n\n//  So we have to make sure the process is completely initialized. To do that we put an\ninfinitive loop into the processes OEP.\n\n//  Then we resume the main thread and wait until it reaches OEP. There we inject a DLL,\nrestore the OEP and resume the main thread.\n\nThe code resumes the created process and waits until it is fully initialized, before suspending\nit again. It then creates a new memory section and maps a view of the memory section in\nboth the current process and the target process. This makes the memory section available to\nboth the loader process and the newly created target process. The loader then takes its\npayload, which is a DLL file stored within its data section and loads it into the new memory\nsection.\n\nIt also copies into the memory section a structure containing information about the payload,\nas well as a ‘LoaderStub’ function which is responsible for performing the rest of the steps to\nproperly load the payload DLL in the target process. The loader then gets the context for the\n\n\n-----\n\ntarget thread and updates it to execute an InjectStub function, which in turn executes the\ncopied LoaderStub function. The target process is resumed and the LoaderStub function\nexecutes within the target process. The LoadStub function finishes loading the payload DLL\nwithin the target process, and finally executes the payload at its entry point.\n\nThe payload for the Camellia Loader is often the Ramnit Core module, rmnsoft.dll.\n\n_Figure 6 — The main function for the Camellia Loader_\n\n### Hooker2\n\nHooker2 is the controller module for Ramnit’s web injection modules. These modules are\ninjected into web browser processes where they can monitor and intercept web requests\nmade through the browser. They may be configured to steal information such as credentials\nand banking and payment information.\n\nHooker2 acts as the controller and loader for the web injection binaries, and it is primarily\ndesigned to target the web browsers Internet Explorer, Microsoft Edge, Firefox, and Google\nChrome. It has two binaries stored within its resources which are the 32 and 64 bit web\ninjection modules. It also contains 32 and 64 bit binaries within its data section, which are\nintermediary hook loaders, as described earlier in this report.\n\nHooker2 starts by checking and adjusting the settings for the above listed browsers in order\nto weaken their security; this includes modifying registry settings and updating command line\narguments in shortcut files. It then monitors running processes on the system for any\n\n\n-----\n\ninstances of the target web browsers – if found, it proceeds to inject its payloads into the\nbrowser process.\n\nSimilar to the Camellia Loader, Hooker2 also makes use of code based on the Gozi\nProcessInjectDll and AdInjectImage functions in order to accomplish the injection of its\npayloads into the target browser process. In this case, however, it is injecting two binaries\ninto the target process – the intermediary hook loader and the web inject module (either the\n32-bit or 64-bit versions depending on the target process architecture).\n\nHooker2 goes through the same steps as the Camellia Loader, creating a new memory\nsection, mapping a view of the memory section in both the current process and the target\nprocess, and then building the Hook Loader binary within the created memory section. It then\nrepeats this process for the webinject payload.\n\nThis procedure is illustrated in the screenshot below.\n\n_Figure 7 — Image showing the creation of memory sections and views in current and target_\n_processes, and copying payloads into the sections_\n\nHooker2 then creates a ‘Loader Context’ structure which is stored directly after the hook\nloader in memory and contains information about the web inject payload, as well as a copied\nLoader Stub function. Finally, a function is called which executes the Loader Stub function\nwithin the target process, which in turn loads and executes the Hook Loader binary. The\nHook Loader binary then uses its hooking technique, described earlier in this report, to load\nand execute the final Web Inject module payload.\n\n\n-----\n\n_Figure 8 — Population of Loader Context structure and execution of code within target_\n_process._\n\n### Ramnit’s 2021 Updates\n\nIn addition to the 2018 samples, we analysed two sets of Ramnit binaries compiled in early\n2021. Overall the structure and functionality of these newer samples hadn’t changed\nsignificantly, but we noted the following updates:\n\nHooker2 module updated to target the Thunderbird email application in addition to web\nbrowsers, and includes code targeting email clients. The web browser targeting code is\nalso updated.\nAddition of the OpenSSL library, which was not included in the 2018 samples.\nInclusion of string Z:\\hooker2\\Common\\md5.cpp in the Hooker2 binary.\nThe LoaderStub function is updated with control-flow flattening obfuscation.\nSeveral of the functions within the hooking library are also updated to use control-flow\nflattening obfuscation.\n\n\n-----\n\nThe Intermediary Hook Loaders are updated with the ability to decrypt the supplied\npayload using RC4, and now have the internal name RapportGP.dll.\nThe list of process injection targets in the Camellia Loader is reduced to the following:\n\n**%PROGRAMFILES%\\Windows Photo Viewer\\ImagingDevices.exe**\n**%PROGRAMFILES%\\Windows Mail\\wab.exe**\n**%PROGRAMFILES%\\Windows Mail\\wabmig.exe**\n\nAt this point, it starts to become noticeable how the state of the malware is shifting closer\ntowards Bumblebee, which contains all the above listed features, except the first.\n\n## The Birth of Bumblebee\n\n[In August 2021, we observed an unusual campaign exploiting the CVE-2021-4044 Microsoft](https://www.microsoft.com/security/blog/2021/09/15/analyzing-attacks-that-exploit-the-mshtml-cve-2021-40444-vulnerability/)\nOffice vulnerability, which involved the distribution of specially crafted Microsoft Office\ndocuments via phishing emails. The malicious document contained an OLEObject linking to\nan external, malicious HTML file, which was downloaded upon opening the document, or\neven previewing it in Explorer. The HTML file contained malicious, obfuscated Javascript\nwhich is parsed within Microsoft Office by the MSHTML engine. The code creates an ActiveX\ncontrol constructed to download a malicious .cab file from an external site, which is saved\nwith a name such as championship.inf, then located by the javascript via directory traversal\nand executed as a CPL file.\n\nThe downloaded file was a previously unknown backdoor but now recognised as an early\nversion of Bumblebee. It incorporates the OpenSSL and Boost libraries and is also notable\nfor using the user-agent bumblebee. Upon execution, it connects to its C2 and receives a\nJSON-formatted command containing a base64 encoded shellcode payload, which it injects\ninto a process and executes.\n\nUpon first glance, this early version of Bumblebee does not resemble the Ramnit binaries\nmuch at all as its main function is almost entirely taken up by large chunks of code from the\nOpenSSL and JSON libraries used by Bumblebee for connecting to the C2 and generating or\nparsing the JSON-formatted data being sent and received. However, closer inspection\nreveals several notable similarities.\n\nFirstly, immediately after entering the DllMain function, Bumblebee initialises a hook store\nobject very similar to those used in the Ramnit samples, indicating that it is likely using the\nsame hooking library.\n\n\n-----\n\n_Figure 9 — Hook store initialisation code indicates Bumblebee is likely using the same_\n_hooking code as Ramnit_\n\nLater on in the code, once Bumblebee has received its payload from the C2, it selects a\nprocess to inject the payload into a hardcoded list that matches exactly the list used in the\n2021 version of the Ramnit Camellia Loader.\n\n_Figure 10 — The list of process injection targets in Bumblebee Beta_\n\nOnce a process has been selected, Bumblebee creates a new instance of the process in\nsuspended mode using the Windows Management Instrumentation (WMI) interface, and\nthen patches the entrypoint of the process, replacing it with code that calls the SleepEx API\nin an infinite loop. This chain of events is also almost identical to that performed by the\nCamellia Loader.\n\n\n-----\n\n_Figure 11 — Patching code from 64-bit Bumblebee sample (left) compared with the_\n_equivalent 32-bit code from a Camellia Loader sample (right)_\n\nThe function to inject the payload into the target process has some similarities to that used in\nCamellia Loader and Hooker2 in that it still injects the payload into the target process by\ncreating and mapping views of a shared memory section in both the current and target\nprocesses. However, it is much simpler than the version of the injection function used by\nRamnit, it does not use the LoaderStub code or loader context structures, and instead\nexecutes the payload code by calling the NtQueueApcThread API. This difference may be a\nresult of the payload being shellcode rather than a full DLL binary which requires more\ncomplex loading mechanisms.\n\n\n-----\n\nA final, significant observation is that the Bumblebee Beta binary contains 32 and 64-bit\nHook Loader binaries within its data section, despite not using them within its injection\nfunction. These Hook Loaders are almost identical to those found in the 2021 Ramnit\nsamples; they include the ability to decrypt a provided payload using RC4 and use the name\nRapportGP.dll also seen in the 2021 Ramnit versions.\n\n### Bumblebee 1.0\n\nIn March 2022, the full version of Bumblebee was released, with full C2 communication and\ntask functionality implemented, as well as the inclusion of anti-AV and anti-analysis code\ntaken from the [Al-Khaser Project. It is capable of gathering system information, installing](https://github.com/LordNoteworthy/al-khaser)\nitself for persistence, and receiving and loading payloads including DLLs and shellcode. The\nintermediary Hook Loaders are still present and are now used as part of the fully\nimplemented payload injection process.\n\nA full analysis of the campaigns involving Bumblebee is outside the scope of this report but\n[detailed write-ups can be found here,](https://elis531989.medium.com/the-chronicles-of-bumblebee-the-hook-the-bee-and-the-trickbot-connection-686379311056) [here and](https://www.proofpoint.com/us/blog/threat-insight/bumblebee-is-still-transforming) [here.](https://research.nccgroup.com/2022/04/29/adventures-in-the-land-of-bumblebee-a-new-malicious-loader/)\n\nLike its predecessor, the full version of Bumblebee still uses the OpenSSL library for network\ncommunication, and requests and responses between itself and the C2 are JSON formatted,\nalbeit with a much more detailed structure. Bumblebee gathers basic system information\nabout the infected host which it converts to JSON and sends to the C2, and in return\nreceives a JSON formatted response containing task data.\n\nBumblebee is currently capable of carrying out the following tasks:\n\n**Task Name** **Description**\n\n**ins** Install persistence\n\n**shi** Inject Shellcode payload\n\n**dij** Inject DLL payload\n\n**dex** Save payload to disk and execute\n\n**sdl** Delete self\n\nThe shi command instructs Bumblebee to inject a shellcode payload, and this procedure is\nvery similar to the one seen in Bumblebee Beta. Bumblebee selects a target process from\nthe following hardcoded list of processes, which is noted to be the same as Bumblebee Beta\n\n\n-----\n\nand Ramnit:\n\n**%PROGRAMFILES%\\Windows Photo Viewer\\ImagingDevices.exe**\n**%PROGRAMFILES%\\Windows Mail\\wab.exe**\n**%PROGRAMFILES%\\Windows Mail\\wabmig.exe**\n\nIt then uses the same injection and execution method observed in Bumblebee Beta to inject\nthe payload into the target process and execute it using the NtQueueApcThread API.\n\nThe dij command instructs Bumblebee to inject a DLL payload into a process chosen from\nthe same hardcoded list as above. This method more closely resembles the Gozi-based\ninjection method used in the Ramnit Hooker2 module, including the use of the intermediary\nhook loader binary and loader stub code. The injection function first creates a new memory\nsection for the hook loader, maps views to the section in both the current and target process,\nand then builds the hook loader within the section. A second memory section is created and\nthe payload DLL copied into it. The function then creates the ‘Loader Context’ structure\ndirectly after the hook loader in memory and populates it with information about the payload,\nas well as the copied Loader Stub function. Finally, the Loader Stub function is executed\nwithin the target process using the NtQueueApcThread API, which in turn loads and\nexecutes the Hook Loader binary. The Hook Loader binary then uses its hooking technique,\ndescribed earlier in this report, to load and execute the final payload.\n\nThe below image shows the DLL injection function within Bumblebee and similarities can be\nseen with the equivalent function within Hooker2, illustrated previously.\n\n\n-----\n\n_Figure 12 — Bumblebee DLL Injection function showing similarities to the Gozi-based_\n_injection function used in Hooker2_\n\nThe LoaderStub function used by Bumblebee is very similar to that used in the 2021 Ramnit\nsamples and also includes the control flow flattening obfuscation. The below image shows\nthe execution of the Hook Loader by the Loader Stub function. Information about the payload\nis passed as a parameter to the Hook Loader, including the payload address, size, entrypoint\nexport name, and RC4 key for decryption.\n\n_Figure 13 — Execution of the Hook Loader within the Loader Stub function._\n\nThe dex command saves the received payload to disk at the path\n**%LocalAppData%\\wab.exe and then executes it using the WMI interface. The use of WMI**\nfor process creation was also observed in Ramnit.\n\nFor persistence, Bumblebee copies itself to the %AllUsersAppData% folder and creates a\nVBS file using WScript designed to execute the copied binary. Finally, a scheduled task is\ncreated which executes the VBS script when run.\n\nFor deletion, Bumblebee executes a Powershell command designed to delete itself from disk\nand then exits.\n\n### Comparisons with Ramnit\n\nOverall, the similarities between Bumblebee and Ramnit appear quite stark, despite the\nfunctional differences. They both make use of the same hooking library and injection code,\nand they both contain the same lists of injection targets. Even though the injection code can\nbe traced back to the publicly available Gozi source, both Bumblebee and Ramnit use a\ncustomised version of it which includes control flow flattening obfuscation within the\nLoaderStub function.\n\nBoth malware families make use of the intermediary Hook Loader binaries, and both\nspecifically use the same version of the Hook Loader which has the internal name\nRapportGP.dll and the ability to decrypt the payload using RC4.\n\n\n-----\n\nThe string Z:\\hooker2\\Common\\md5.cpp appears in the 2021 Ramnit Hooker2 binary and\nBumblebee, and the Ramnit samples also use the internal name hooker2.dll. Based on\nanalysis of the code, it appears that Bumblebee is likely derived from the Ramnit Hooker2\nproject but combined with code from the Camellia Loader.\n\nWe also looked at the PE Rich Headers present within the headers of the Bumblebee and\n[Ramnit binaries and found some interesting similarities. The Rich Header is a chunk of data](https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/)\npresent near the start of every PE binary built using Microsoft Visual Studio; it contains\ninformation about the build environment and the products and versions used during the\ncompilation of the malware. This can be used as a fingerprint for the malware’s build\nenvironment and provide interesting insights during comparison between samples.\n\nComparing the Rich Headers of the Bumblebee samples with the Ramnit Hooker2 samples\nshowed a remarkably similar collection of compiler products and versions, despite the\nsignificant functional differences, indicating that both may have been built in the same\nenvironment.\n\n_Figure 14 — A comparison of the PE Rich Header contents for a Ramnit Hooker2 sample_\n_(left) and Bumblebee (right)_\n\n## Following the Hooks\n\nAs previously discussed, much of the injection related code within Ramnit and Bumblebee\ncan be traced back to the leaked source code for the Gozi trojan. However, we were curious\nabout the hooking library used in both, as it did not seem to match the hooking code found\nwithin Gozi nor any other publicly available code we could find. It does share some\nsimilarities with the hooking code from the leaked Zeus trojan code, and may have been\nbased on that originally, but has been modified significantly since.\n\n\n-----\n\nSearching for the hooking code within malware repositories such as VirusTotal revealed\nsome interesting connections.\n\n### Trickbot\n\nThe Trickbot banking trojan was released towards the end of 2016, less than a year after the\ntake down of its predecessor Dyre. Trickbot was originally released in conjunction with two\nmodules, GetSystemInfo and InjectDLL, with the former gathering information about the\ninfected system, and the latter providing web inject functionality.\n\nExamination of Trickbot samples relating to its injectDLL or browsers_engine module\nuncovered use of the same hooking library found within Bumblebee and Ramnit samples.\nThese hooking functions are found even in the very earliest iterations of the modules dating\nback to 2016. The version of the code used in the Trickbot modules is almost identical to that\nused in Ramnit/Bumblebee, and some examples are shown in the images below.\n\n_Figure 15 — The hook store initialisation function used in an early version of the Trickbot web_\n_inject module_\n\n\n-----\n\n_Figure 16 — The hook creation function within an early version of the Trickbot web inject_\n_module bears a strong resemblance to the version used in Ramnit and Bumblebee_\n\n### NeverQuest\n\nInterestingly our investigations also led us to several NeverQuest, aka Vawtrak samples, and\nit is here that we finally reach the end of our trail and potentially the origin of this hooking\nlibrary.\n\nNeverQuest is an older banking trojan which was active from 2013 through to early 2017 and\nis thought to be the predecessor of IcedID. The group behind NeverQuest were thought to\nhave close ties to the Dyre/Dyreza group, which was the predecessor of Trickbot, and IcedID\nand the Trickbot group continue to share that close relationship.\n\nWe analysed a cross section of NeverQuest samples generated in 2013, 2014, and 2016,\nand were able to observe the active development and evolution of the hooking library. The\nlatest NeverQuest sample we analysed was created in May 2016, five months prior to the\nrelease of Trickbot and its web inject module. The state of the hooking code in this 2016\nNeverQuest sample is a very close match to that then used in the Trickbot modules several\n\n\n-----\n\nmonths later. Several other code overlaps were also observed between the two, which can t\neasily be explained by coincidence or traced to publicly available code. This suggests that\nthere may have been some code sharing, or potentially even a sharing of developers\nbetween the two groups at this time. Given the reported ties between NeverQuest and Dyre\nat the time, it’s possible that the former may have shared code or resources with the latter in\norder to help get Trickbot up and running after Dyre’s takedown.\n\nThe below images show an example of the evolution of one of the functions within the\nhooking library from 2013 to 2016. The version found in the 2016 sample bears close\nresemblance to the Trickbot equivalent above, and to the versions used in Ramnit and\nBumblebee later on. The size of the 32-bit hook item structure used by library also changes\nover this time, from 75 bytes in the earlier NeverQuest samples to 71 bytes in the 2016\nsample. The size remains at 71 bytes throughout its later use in Trickbot, Ramnit, and\nBumblebee.\n\n\n-----\n\n_Figure 17 — The hook creation version as found within a 2013 variant of NeverQuest. At this_\n_point the hooking library was still in development._\n\n_Figure 18 — The hook creation version as found within a 2014 variant of NeverQuest. At this_\n_point the function appears to have been expanded to manage different use cases._\n\n\n-----\n\n_Figure 19 — The hook creation version as found within a 2016 variant of NeverQuest. Here_\n_the function has been simplified again, and the hook item structure size reduced to 71 bytes._\n_This version of the code closely resembles that used in Trickbot, Ramnit and Bumblebee._\n\n### Karius\n\n[In June 2018, CheckPoint reported on a new banking Trojan named Karius that was under](https://research.checkpoint.com/2018/banking-trojans-development/)\ndevelopment and noted code overlap between Karius and Ramnit, Trickbot and Vawtrak\n(NeverQuest). We analysed a Karius sample as part of this investigation and found it to\ncontain the same hooking code as the other samples discussed in this report. The structure\nof the code was also observed to bear a striking resemblance to that of the Trickbot web\ninject module, and it seems likely that Karius was developed by someone who had access to\nthat source code.\n\n## Sample Hashes\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\nRamnit 2018 Packed sample 436aaa1014e8528ed72c89c4bf74d14c Sun, Jul 22\n2018,\n8:11:25 – 32\nBit EXE\n\nRamnit 2018 Dropper 6f62fbb377b834f06971754ea13d5809 Wed, Jul 18\n2018,\n8:35:48 – 32\nBit EXE\n\nRamnit 2018 Hook Loader c65289331a7ccb58131e6bce5a144d91 Tue, Jul 3\n2018,\n14:19:03 –\n32 Bit DLL\n\nRamnit 2018 Camellia Loader 4fc3b7c8ac3fc178386549ef859f5b40 Tue, Jul 3\n2018,\n14:18:59 –\n32 Bit DLL\n\n\nRamnit 2018 Rmnsoft Ramnit\nCore\n\nRamnit 2018 Hooker2\nWebInject\nController\n\nRamnit 2018 WebInject\nModule 32-bit\n\nRamnit 2018 WebInject\nModule 64-bit\n\n\n81e3f4dd945a172a2283b6bc720a1f89 Tue, Jul 3\n2018,\n14:18:57 –\n32 Bit DLL\n\n625db8cd9536c91f5ee044c318a80fec Wed, Jul 4\n2018,\n8:36:42 – 32\nBit DLL\n\n73c95a2a9c9348f0b65de23a17f1790c Wed, Jul 4\n2018,\n8:36:34 – 32\nBit DLL\n\nf836f4949483071d80b59d47d8ce2bd9 Wed, Jul 4\n2018,\n8:36:41 – 64\nBit DLL\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\nRamnit 2018 Intermediary\nHook Loader 64bit\n\nRamnit 2018 Intermediary\nHook Loader 32bit\n\n\n8db81f83fa7cb790b11695d65c46406c Thu, Apr 19\n2018,\n12:11:06 –\n64 Bit DLL\n\n3db90477a4f14ca2270c21df2e510a54 Thu, Apr 19\n2018,\n12:11:05 –\n32 Bit DLL\n\n\nRamnit 2018 Packed sample a27b84ff5fa08138f87dfb0d14bf9f76 Thu, Nov 8\n2018,\n14:34:09 –\n32 Bit DLL\n\nRamnit 2018 Hook Loader 0948c9d8df7690f0741aedea20fbea3f Thu, Nov 8\n2018,\n14:34:09 –\n32 Bit DLL\n\n\nRamnit 2018 Hooker2\nWebInject\nController\n\nRamnit 2018 WebInject\nModule 32-bit\n\nRamnit 2018 WebInject\nModule 64-bit\n\nRamnit 2018 Intermediary\nHook Loader 64bit\n\n\n2b8ea6cbf125dc75b85cbc21e98aade4 Thu, Nov 8\n2018,\n14:34:02 –\n32 Bit DLL\n\n06d371f2fa5c19bda78788bff1d5e9ca Thu, Nov 8\n2018,\n14:33:05 –\n32 Bit DLL\n\ne17e9ea60aacfff5db740116113aae3b Thu, Nov 8\n2018,\n14:33:41 –\n64 Bit DLL\n\n17ef1264fb78b91a6c4df6b99253ae43 Thu, Nov 8\n2018,\n14:21:06 –\n64 Bit DLL\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\nRamnit 2018 Intermediary\nHook Loader 32bit\n\n\n79dd566a814ceef1547e60c84d6561bb Thu, Nov 8\n2018,\n14:21:02 –\n32 Bit DLL\n\n\nRamnit 2018 Packed sample 93aa15605b86c41a5ba37107dd5d7ac1 Mon, Nov 12\n2018,\n8:13:53 – 32\nBit EXE\n\nRamnit 2018 Dropper c556cb430cdf197d14f4d768ac166565 Wed, Nov 7\n2018,\n16:01:22 –\n32 Bit EXE\n\nRamnit 2018 Hook Loader c0775d6bb5c10caf9e9bbcbe3f26cf65 Wed, Nov 7\n2018,\n15:51:48 –\n32 Bit DLL\n\nRamnit 2018 Camellia Loader ba4b3691bbc24fde556e5ad1f48be0d7 Wed, Nov 7\n2018,\n15:51:47 –\n32 Bit DLL\n\n\nRamnit 2018 Rmnsoft Ramnit\nCore\n\n\n73ed96ffb519ca117684e89ecfd469a2 Wed, Nov 7\n2018,\n15:51:46 –\n32 Bit DLL\n\n\nRamnit 2021 Hook Loader c76c74ad012fe03fa48b124a13849473 Wed, Jan 27\n2021,\n10:57:49 –\n32 Bit DLL\n\nRamnit 2021 Camellia Loader 8ecd3b0505c241d79166f3f003a3b5ce Wed, Jan 27\n2021,\n10:57:48 –\n32 Bit DLL\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\nRamnit 2021 RmnSoft Ramnit\nCore\n\nRamnit 2021 Intermediary\nHook Loader 32bit\n\nRamnit 2021 Intermediary\nHook Loader 64bit\n\nRamnit 2021 Hooker2\nWebInject\nController\n\nRamnit 2021 WebInject\nModule 32-bit\n\nRamnit 2021 WebInject\nModule 64-bit\n\nRamnit 2021 Intermediary\nHook Loader 32bit\n\nRamnit 2021 Intermediary\nHook Loader 64bit\n\n\n0e5bbaccc1507a8d7175555fd86c6070 Wed, Jan 27\n2021,\n10:56:56 –\n32 Bit DLL\n\n909fa5b56ddb1050800c3f010f20c2d7 Wed, Jan 27\n2021,\n10:55:27 –\n32 Bit DLL\n\ne522a2e480c20e9e305ea5806516e7d5 Wed, Jan 27\n2021,\n10:55:32 –\n64 Bit DLL\n\nc1e4f0c34b6e8cb4a5c2170af7a96a43 Wed, Feb 3\n2021,\n15:05:27 –\n32 Bit DLL\n\n5c85e27dbf5c6d1960fdaed8d1c8e3da Wed, Feb 3\n2021,\n15:05:13 –\n32 Bit DLL\n\nab242db433611209238dd61ecf332445 Wed, Feb 3\n2021,\n15:04:57 –\n64 Bit DLL\n\nf9c89f8aeee639249b8ba0352038bfee Wed, Feb 3\n2021,\n15:01:36 –\n32 Bit DLL\n\n04e0945f442ae6a67f822445f83c2737 Wed, Feb 3\n2021,\n15:01:40 –\n64 Bit DLL\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\nBumblebee\nBeta 2021\n\nBumblebee\nBeta 2021\n\nBumblebee\nBeta 2021\n\nBumblebee\n2022\n\nBumblebee\n2022\n\nBumblebee\n2022\n\nBumblebee\n2022\n\nComparison\nSamples\n\n\nBumblebee Beta 0b7da6388091ff9d696a18c95d41b587 Fri, Aug 20\n2021,\n9:59:17 – 64\nBit DLL\n\n\nIntermediary\nHook Loader 32bit\n\nIntermediary\nHook Loader 64bit\n\nTrickbot 2016\nInject Module\n\n\nIntermediary\nHook Loader 32bit\n\nIntermediary\nHook Loader 64bit\n\n\na27a4388a51077840a0c731bb7ae0638 Fri, Aug 20\n2021,\n9:56:21 – 32\nBit DLL\n\n1cd00b8a55b335512773a652c856a5d1 Fri, Aug 20\n2021,\n9:56:25 – 64\nBit DLL\n\n\nPacked sample 052c8b8d48cc2337516ea39ef85e2b06 Thu, Mar 24\n2022,\n11:19:12 –\n64 Bit EXE\n\nBumblebee c66759399e6047a2d17e029f0d8c5b55 Tue, Mar 22\n2022,\n15:47:49 –\n64 Bit DLL\n\n\n0bdd60d8c791dcbd0866958ae2cb5732 Tue, Mar 22\n2022,\n15:44:25 –\n32 Bit DLL\n\n54d6fde71047dd31f4525c03fa180a18 Tue, Mar 22\n2022,\n15:44:29 –\n64 Bit DLL\n\n17f5cc7b7396f6f5c8c72728e3f413c9 Mon, Oct 10\n2016,\n13:08:15 –\n32 Bit DLL\n\n\n-----\n\n**Category** **Description** **Hash** **Compilation**\n**Date**\n\n\nComparison\nSamples\n\nComparison\nSamples\n\nComparison\nSamples\n\nComparison\nSamples\n\n\nNeverQuest\n2013\n\nNeverQuest\n2014\n\nNeverQuest\n2016\n\n\nKarius 2018 b0992f8c36cd8a09efd0fb034530f1b9 Sat, Feb 10\n2018,\n20:32:59 –\n32 Bit DLL\n\n\n1164310a00dbeab0caaea36d8e8eb4db Fri, Aug 16\n2013,\n15:47:42 –\n32 Bit DLL\n\n27635ba59b3c0eed7baf589dfc7b56e8 Tue, Sep 9\n2014,\n14:49:55 –\n32 Bit DLL\n\n0fd80bc95ea6579ed176a880fd929620 Mon, May 23\n2016,\n11:46:20 –\n32 Bit DLL\n\n\n## Recommendations\n\nEnsure anti-virus software and associated files are up to date.\nSearch for existing signs of the indicated IOCs in your environment.\nKeep applications and operating systems running at the current released patch level.\nDo not install unapproved apps on a device that has access to the corporate network.\nExercise caution with attachments and links in emails.\n\n[Charlotte Hammond](https://securityintelligence.com/author/charlotte-hammond/)\nMalware Reverse Engineer, IBM Security\n\nCharlotte is a malware reverse engineer for IBM Security's X-Force IRIS team. She has been\nworking in the security industry for more than 7 years with a focu...\n\n\n-----\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-18 - From Ramnit To Bumblebee (via NeverQuest)- Similarities and Code Overlap Shed Light On Relationships Between Malware Developers.pdf"
    ],
    "report_names": [
        "2022-08-18 - From Ramnit To Bumblebee (via NeverQuest)- Similarities and Code Overlap Shed Light On Relationships Between Malware Developers.pdf"
    ],
    "threat_actors": [
        {
            "id": "4594f985-865e-4862-8047-2e80226e246a",
            "created_at": "2022-10-27T08:27:12.984825Z",
            "updated_at": "2025-03-27T02:00:55.424827Z",
            "deleted_at": null,
            "main_name": "EXOTIC LILY",
            "aliases": [
                "EXOTIC LILY"
            ],
            "source_name": "MITRE:EXOTIC LILY",
            "tools": [
                "Bazar"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9be98f84-4a93-41c7-90bd-3ea66ba5bfd7",
            "created_at": "2022-10-25T16:07:24.581954Z",
            "updated_at": "2025-03-27T02:02:10.287921Z",
            "deleted_at": null,
            "main_name": "TA554",
            "aliases": [
                "TH-163"
            ],
            "source_name": "ETDA:TA554",
            "tools": [
                "DarkVNC",
                "Godzilla",
                "Godzilla Loader",
                "Gootkit",
                "Gootloader",
                "Gozi ISFB",
                "ISFB",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Nimnul",
                "Pandemyia",
                "PsiX",
                "PsiXBot",
                "Ramnit",
                "StarsLord",
                "Waldek",
                "Xswkit",
                "sLoad",
                "talalpek"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a3808e4f-c7fd-4d25-aa84-aacc27061826",
            "created_at": "2023-01-06T13:46:39.316216Z",
            "updated_at": "2025-03-27T02:00:03.049128Z",
            "deleted_at": null,
            "main_name": "TA554",
            "aliases": [
                "TH-163"
            ],
            "source_name": "MISPGALAXY:TA554",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "62585174-b1f8-47b1-9165-19b594160b01",
            "created_at": "2023-01-06T13:46:39.369991Z",
            "updated_at": "2025-03-27T02:00:03.065156Z",
            "deleted_at": null,
            "main_name": "TA578",
            "aliases": [],
            "source_name": "MISPGALAXY:TA578",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "63061658-5810-4f01-9620-7eada7e9ae2e",
            "created_at": "2022-10-25T15:50:23.752974Z",
            "updated_at": "2025-03-27T02:00:55.538582Z",
            "deleted_at": null,
            "main_name": "Wizard Spider",
            "aliases": [
                "Wizard Spider",
                "UNC1878",
                "TEMP.MixMaster",
                "Grim Spider",
                "FIN12",
                "GOLD BLACKBURN",
                "ITG23",
                "Periwinkle Tempest",
                "DEV-0193"
            ],
            "source_name": "MITRE:Wizard Spider",
            "tools": [
                "TrickBot",
                "AdFind",
                "BITSAdmin",
                "Bazar",
                "LaZagne",
                "Nltest",
                "GrimAgent",
                "Dyre",
                "Ryuk",
                "Conti",
                "Emotet",
                "Rubeus",
                "Mimikatz",
                "Diavol",
                "PsExec",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e6a21528-2999-4e2e-aaf4-8b6af14e17f3",
            "created_at": "2022-10-25T16:07:24.422115Z",
            "updated_at": "2025-03-27T02:02:10.216817Z",
            "deleted_at": null,
            "main_name": "Wizard Spider",
            "aliases": [
                "DEV-0193",
                "Gold Blackburn",
                "Gold Ulrick",
                "Grim Spider",
                "ITG23",
                "Operation BazaFlix",
                "Periwinkle Tempest",
                "TEMP.MixMaster",
                "Wizard Spider"
            ],
            "source_name": "ETDA:Wizard Spider",
            "tools": [
                "AdFind",
                "Agentemis",
                "Anchor_DNS",
                "BEERBOT",
                "BazarBackdoor",
                "BazarCall",
                "BazarLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "Conti",
                "Diavol",
                "Dyranges",
                "Dyre",
                "Dyreza",
                "Dyzap",
                "Gophe",
                "Invoke-SMBAutoBrute",
                "KEGTAP",
                "LaZagne",
                "LightBot",
                "PowerSploit",
                "PowerTrick",
                "PsExec",
                "Ryuk",
                "SessionGopher",
                "TSPY_TRICKLOAD",
                "Team9Backdoor",
                "The Trick",
                "TheTrick",
                "Totbrick",
                "TrickBot",
                "TrickLoader",
                "TrickMo",
                "Upatre",
                "bazaloader",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bc119938-a79c-4e5f-9d4d-dc96835dfe2e",
            "created_at": "2024-06-04T02:03:07.799286Z",
            "updated_at": "2025-03-27T02:05:17.337094Z",
            "deleted_at": null,
            "main_name": "GOLD BLACKBURN",
            "aliases": [
                "Periwinkle Tempest ",
                "Wizard Spider ",
                "ITG23 "
            ],
            "source_name": "Secureworks:GOLD BLACKBURN",
            "tools": [
                " Buer Loader",
                " Dyre",
                " Team9",
                " TrickBot",
                "BazarLoader"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "52eb5fb6-706b-49c0-9ba5-43bea03940d0",
            "created_at": "2024-11-01T02:00:52.694476Z",
            "updated_at": "2025-03-27T02:00:55.51014Z",
            "deleted_at": null,
            "main_name": "TA578",
            "aliases": [
                "TA578"
            ],
            "source_name": "MITRE:TA578",
            "tools": [
                "Latrodectus",
                "IcedID"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "56384d06-abc2-4853-8440-db4d7b7d1b5f",
            "created_at": "2023-01-06T13:46:39.367122Z",
            "updated_at": "2025-03-27T02:00:03.064071Z",
            "deleted_at": null,
            "main_name": "EXOTIC LILY",
            "aliases": [
                "DEV-0413"
            ],
            "source_name": "MISPGALAXY:EXOTIC LILY",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1f87ac52-682a-4bc7-b7ce-fac8d79815fa",
            "created_at": "2023-01-06T13:46:39.373008Z",
            "updated_at": "2025-03-27T02:00:03.066186Z",
            "deleted_at": null,
            "main_name": "TA579",
            "aliases": [],
            "source_name": "MISPGALAXY:TA579",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535701,
    "ts_updated_at": 1743041820,
    "ts_creation_date": 1662027731,
    "ts_modification_date": 1662027731,
    "files": {
        "pdf": "https://archive.orkl.eu/504159f996e289c7e777d6bbf3006170c5ebfda3.pdf",
        "text": "https://archive.orkl.eu/504159f996e289c7e777d6bbf3006170c5ebfda3.txt",
        "img": "https://archive.orkl.eu/504159f996e289c7e777d6bbf3006170c5ebfda3.jpg"
    }
}