{
    "id": "25578126-7c43-44ee-9ace-565ccde1cb34",
    "created_at": "2023-02-19T02:05:08.200581Z",
    "updated_at": "2025-03-27T02:16:59.298433Z",
    "deleted_at": null,
    "sha1_hash": "51aead123abd4e157b086cfd84223aae4c2f50f8",
    "title": "2022-02-25 - Behavior Anomaly on Linux Systems to Detect Zero-day Malware Attacks",
    "authors": "",
    "file_creation_date": "2022-04-06T19:24:16Z",
    "file_modification_date": "2022-05-02T12:10:10Z",
    "file_size": 2417839,
    "plain_text": "## Behaviour Anomaly on Linux Systems to\n\n Detect Zero-day Malware Attacks\n\n### Ovais Ahmed\n\nA thesis submitted to the Faculty of Design and Creative Technologies Auckland\n\nUniversity of Technology\n\nIn partial fulfilment of the requirements for the degree of Master of Information Security\n\nand Digital Forensics\n\nSchool of Engineering, Computer and Mathematical Sciences\n\nAuckland, New Zealand, 25 February 2022\n\n\n-----\n\n# Declaration\n\nI hereby declare that this submission is my own work and that, to the best of my knowledge and\n\nbelief, it contains no material previously published or written by another person nor material which\n\nto a substantial extent has been accepted for the qualification of any other degree or diploma of\n\na University or other institution of higher learning except where due acknowledgement is made in\n\nthe acknowledgements.\n\nOvais Ahmed\n\n29-11-2021\n\n1\n\n\n-----\n\n# Abstract\n\nInternet-connected devices have been the subject of cyber threats due to the gain\n\nmalicious actors can get by compromising these systems. Endpoint protection is\n\navailable on these systems, protecting if the malware signature is available for the\n\nmalicious software. The challenge is that if the signature is not available on the endpoint\n\nprotection, as in the case of zero-day malware, the endpoint will not detect or protect the\n\nsystem. The system follows the file analysis of zero-day malware in the sandbox\n\nenvironment for file identification, creating the signature and updating the endpoint\n\ndatabase. The process of zero-day can generate a delay which can result in substantial\n\ndamage to the systems by the time signature is updated. The research examines the\n\nabnormal behaviour on a Linux-based operating system and evaluates the method to\n\nexplore the zero-day malware build for the platform.\n\nMalware samples are sourced from the available public repositories. The sample files\n\nused include known malicious and known non-malicious files. The known malicious files\n\nhave the signatures available on the antivirus tool. Therefore, the setup removes the\n\nnecessary signatures for the known malware sample files to treat them as zero-day\n\nmalware. Total twenty-two malware has been used to test the method to detect the zero\nday malware, out of which few have been tried without signature information on endpoint\n\nantivirus to determine the consistency of the test results.\n\nThe research examines the malware behaviour on the Linux based system. It monitors\n\nthe process in the two different situations where non-malicious and known malware is\n\nexecuted at different intervals. The abnormal process behaviour detects the malicious\n\nfile. The second phase of the research explores the methods to act on the file after the\n\ndetection. It discusses YARA rules and programable interface integration across the\n\nplatform to automate the file quarantine feature.\n\n2\n\n\n-----\n\n# Table of Contents\n\n**Declaration .................................................................................................................. 1**\n\n**Abstract ....................................................................................................................... 2**\n\n**Table of Contents ....................................................................................................... 3**\n\n**List of Figures ............................................................................................................. 6**\n\n**List of Tables .............................................................................................................. 8**\n\n**1.** **Introduction ......................................................................................................... 9**\n\n**1.1.** **Background and Motivation ......................................................................... 9**\n\n**1.2.** **Thesis Structure ......................................................................................... 12**\n\n**2.** **Literature Review .............................................................................................. 14**\n\n**2.1.** **Malware Analysis ........................................................................................ 14**\n\n**2.2.** **End-Point Protection .................................................................................. 16**\n\n**2.3.** **Cyber Threat intelligence ........................................................................... 17**\n\n**2.4.** **Linux operating System ............................................................................. 18**\n\n2.4.1 System Architecture ................................................................................... 18\n\n2.4.2.1 Memory Management ........................................................................... 20\n\n2.4.2.1.1 Virtual Memory ............................................................................... 20\n\n2.4.2.1.2 Abstract model of virtual memory ................................................... 22\n\n2.4.2.2 Process Management ........................................................................... 28\n\n2.4.2.2.1 Signal Management ....................................................................... 28\n\n2.4.2.2.2 Process Representation ................................................................. 29\n\n2.4.2.2.3 Thread and Tasks .......................................................................... 30\n\n**2.5.** **Related Work............................................................................................... 31**\n\n3\n\n\n-----\n\n2.5.1 Malware Analysis Methods ......................................................................... 31\n\n2.5.1.1 Basic Malware Analysis Method ........................................................... 31\n\n2.5.1.2 Analysis System Components .............................................................. 34\n\n2.5.2 Indicators of Compromise .......................................................................... 35\n\n2.5.3 YARA ......................................................................................................... 36\n\n2.5.4 Sample Malware Analysis on Linux System ............................................... 37\n\n2.5.5 Zero Day Malware Detection ...................................................................... 38\n\n**2.6 Research Questions ....................................................................................... 41**\n\n**3.** **Research Design ............................................................................................... 43**\n\n**3.1 Research Approach ........................................................................................ 43**\n\n3.1.1 Sample Malware ........................................................................................ 43\n\n3.1.2 Design Setup ............................................................................................. 44\n\n3.1.2.1 End Point Details .................................................................................. 46\n\n3.1.2.2 Programming API ................................................................................. 49\n\n3.1.2.3 Data Acquisition ................................................................................... 51\n\n3.1.2.5 YARA Rules Update ............................................................................. 54\n\n3.1.3 Analysis Method ......................................................................................... 55\n\n3.1.3.1 Sample files .......................................................................................... 57\n\n3.1.3.2 Monitoring Process ............................................................................... 57\n\n3.1.3.3 Maintaining Database ........................................................................... 58\n\n3.1.3.4 Abnormal Behaviour ............................................................................. 58\n\n3.1.3.5 File verification ..................................................................................... 59\n\n3.1.3.6 Action ................................................................................................... 59\n\n**3.2 Conclusion ...................................................................................................... 60**\n\n4\n\n\n-----\n\n**4.** **Results ............................................................................................................... 61**\n\n**4.1.** **Sample Files................................................................................................ 61**\n\n**4.2.** **Process Monitoring .................................................................................... 67**\n\n**4.3.** **File Analysis................................................................................................ 68**\n\n**4.5. Conclusion ..................................................................................................... 89**\n\n**5.** **Discussion ......................................................................................................... 91**\n\n**5.1.** **Sample Data Sets ....................................................................................... 91**\n\n**5.2.** **Research Questions ................................................................................... 94**\n\nQuestion 1 (Q1) ................................................................................................ 95\n\nDiscussion: ................................................................................................... 95\n\nQuestion 2 (Q2)- ............................................................................................ 101\n\nDiscussion: ................................................................................................. 101\n\n**5.3.** **Automate Threat Intelligence ................................................................... 105**\n\n**5.4.** **Conclusion ................................................................................................ 105**\n\n**6.** **Conclusion ...................................................................................................... 107**\n\n**6.1.** **Summary of Research .............................................................................. 107**\n\n**6.2.** **Contribution .............................................................................................. 108**\n\n**6.3.** **Limitation .................................................................................................. 108**\n\n6.4.1 System Requirements ......................................................................... 109\n\n6.4.2 End-Point Protection ............................................................................ 109\n\n6.4.3 Sample Malware for Data Set .............................................................. 110\n\n6.4.4. Detection Criteria .................................................................................... 110\n\n**6.4.** **Future Work .............................................................................................. 111**\n\n**References .............................................................................................................. 113**\n\n5\n\n\n-----\n\n# List of Figures\n\n**Figure 2. 1. Linux System Architecture. ...................................................................... 19**\n\n**Figure 2. 2. Memory Address Table ........................................................................... 20**\n\n**Figure 2. 3. Map Table .............................................................................................. 21**\n\n**Figure 2. 4. Virtual Address Space ............................................................................. 23**\n\n**Figure 2. 5. Virtual and Physical Pages ...................................................................... 24**\n\n**Figure 2. 6. Memory Zones ........................................................................................ 27**\n\n**Figure 2. 7. Malware Analysis .................................................................................... 32**\n\n**Figure 3. 1. Design Setup .......................................................................................... 45**\n\n**Figure 3. 2. Programmable Interface .......................................................................... 51**\n\n**Figure 3. 3. Process Flow ......................................................................................... 56**\n\n**Figure 4. 1- Sample File 1 Details From VirusTotal .................................................... 62**\n\n**Figure 4. 2 - Sample File 2 Details From VirusTotal ................................................... 63**\n\n**Figure 4. 3 - Sample File 3 Details From VirusTotal ................................................... 63**\n\n**Figure 4. 4 - Sample File 4 Details From VirusTotal ................................................... 64**\n\n**Figure 4. 5 - Sample File 5 Details From VirusTotal ................................................... 65**\n\n**Figure 4. 6 - % CPU Usage During Normal Situation ................................................. 67**\n\n**Figure 4. 7 - % CPU Usage When Sample File 1 Was Executed ............................... 68**\n\n**Figure 4. 8 - Sample File 1 PIDs Map ........................................................................ 69**\n\n**Figure 4. 9 – Sample File 1 Execution Count ............................................................. 71**\n\n**Figure 4. 10 - Sample File 1 Hex dump ...................................................................... 71**\n\n**Figure 4. 11 - Sample File 1 AV Directory Listing Before Signature Update ............... 72**\n\n**Figure 4. 12 - Sample File 1 AV Directory Listing After Signature update ................... 73**\n\n6\n\n\n-----\n\n**Figure 4. 13 - Sample File 1 AV Scan Result ............................................................. 73**\n\n**Figure 4. 14 - % CPU Usage When Sample File 2 Was Executed ............................. 74**\n\n**Figure 4. 15 - Sample File 2 PIDs Map ...................................................................... 74**\n\n**Figure 4. 16 – Sample File 2 Execution Count ........................................................... 75**\n\n**Figure 4. 17 - Sample File 2 Hex dump ...................................................................... 76**\n\n**Figure 4. 18 - Sample File 2 AV Directory Listing Before Signature Update ............... 77**\n\n**Figure 4. 19 - Sample File 2 AV Directory Listing After Signature update ................... 77**\n\n**Figure 4. 20 - Sample File 2 AV Scan Result ............................................................. 78**\n\n**Figure 4. 21 - % CPU Usage When Sample File 3 Was Executed ............................. 79**\n\n**Figure 4. 22 - Sample File 3 PIDs Map ...................................................................... 79**\n\n**Figure 4. 23 – Sample File 3 Execution Count .......................................................... 80**\n\n**Figure 4. 24 - Sample File 3 Hex dump ...................................................................... 81**\n\n**Figure 4. 25 - Sample File 3 AV Directory Listing Before Signature Update ............... 82**\n\n**Figure 4. 26 - Sample File 3 AV Directory Listing After Signature update ................... 82**\n\n**Figure 4. 27 - Sample File 3 AV Scan Result ............................................................. 82**\n\n**Figure 4. 28 - % CPU Usage When Sample File 4 Was Executed ............................. 83**\n\n**Figure 4. 29 - Sample File 4 PIDs Map ...................................................................... 84**\n\n**Figure 4. 30 – Sample File 4 Execution Count ........................................................... 85**\n\n**Figure 4. 31 - Sample File 4 Hex dump ...................................................................... 85**\n\n**Figure 4. 32 - Sample File 4 AV Directory Listing Before Signature Update ............... 86**\n\n**Figure 4. 33 - Sample File 4 AV Directory Listing After Signature update ................... 86**\n\n**Figure 4. 34 - Sample File 4 AV Scan Result ............................................................. 87**\n\n**Figure 4. 35 - Other Sample Files % CPU Usage and Execution Count ..................... 88**\n\n7\n\n\n-----\n\n# List of Tables\n\n**Table 2. 1 Virtual Address MAP .................................................................................. 22**\n\n**Table 3. 1. Endpoint Hardware Architecture ............................................................... 46**\n\n**Table 3. 2. Wireless Network Details .......................................................................... 46**\n\n**Table 3. 3. Firewall Security Policy ............................................................................. 47**\n\n**Table 4. 1 List of Other Sample Malware Used in the Lab Setup ................................ 65**\n\n**Table 4. 2 - Sample File 1 PID .................................................................................... 69**\n\n**Table 4. 3 - Sample File 1 Path .................................................................................. 70**\n\n**Table 4. 4 - Sample File 2 PID .................................................................................... 74**\n\n**Table 4. 5 - Sample File 2 Path .................................................................................. 75**\n\n**Table 4. 6 - Sample File 3 PID .................................................................................... 79**\n\n**Table 4. 7 - Sample File 3 Path .................................................................................. 80**\n\n**Table 4. 8 - Sample File 4 PID .................................................................................... 83**\n\n**Table 4. 9 - Sample File 4 Path .................................................................................. 84**\n\n**Table 4. 10 - Sample File 5 PID .................................................................................. 87**\n\n**Table 5. 1 - Sample Malware Rating ........................................................................... 92**\n\n**Table 5. 2 - Sample Categorization ............................................................................ 93**\n\n**Table 5. 3 - Sample 1 Process ID and the Execution Count ....................................... 96**\n\n**Table 5. 4 - Process ID and the Execution Count ....................................................... 97**\n\n**Table 5. 5 - Sample YARA Rule ............................................................................... 103**\n\n8\n\n\n-----\n\n# 1. Introduction\n\n## 1.1. Background and Motivation\n\n_Malware is a computer code that is designed to disrupt, disable, or take control of_\n\ncomputer systems. It is usually hidden in a regular file disguised as a harmless\n\napplication (Christodorescu et al., 2007). It takes advantage of technical flaws and\n\nvulnerabilities in the hardware, operating systems, and software. The spread of such\n\nmalicious software has become very common with easy access to the Internet, especially\n\nwhen business services are moving towards the public cloud (Joseph & Mukesh, 2019).\n\nAs the business services head to an online platform, malicious actor canvas is increasing\n\nvery rapidly. The threat vector has risen sharply. The online payment systems, including\n\nonline credit card usage, phishing attacks for credential leaks, ransomware, and tools\n\nlike key loggers that can be downloaded while browsing compromised websites, are a\n\nfew types of attack vectors. The protection of such attacks is based not only on the\n\nsecurity controls but also on end-user awareness. Many users unknowingly click a\n\nmalicious link or browse a malicious site that may download malware in the background\n\nwithout user knowledge. The malicious code can execute in the background without the\n\nend-user noticing the behaviour. The processes are executed behind the legitimate\n\napplication. Therefore end-point protection is desirable to prevent users from being\n\nvictims of malicious activity.\n\nWindows and Linux are two platforms that are used for client-server connectivity. In\n\nprevious days popular platforms, due to their more significant presence, were more\n\nvulnerable to malware attacks, such as the end-point market is pretty much dominated\n\nby Microsoft based operating systems. Now Linux systems malware are getting popular\n\nas Linux operating systems are becoming more familiar with technology like IoT. The\n\nworld is moving towards an intelligent world. More and more IoT devices will become\n\n9\n\n\n-----\n\npart of our daily use. It will increase the risk of the malicious actor taking advantage of\n\nunprotected systems. The Windows operating system is always considered more\n\nvulnerable to malware than Linux systems, and engineers do not tend to run the OS\n\npatching like windows considering it is more secure (Wu et al., 2012). It is not valid\n\nanymore as there is sample malware like PHP backdoor, rootkit and many others\n\navailable for Linux based systems due to its widespread usage in IoT systems (Dmitry &\n\nElena, 2020). Linux servers are also becoming part of the more extensive ecosystem\n\nwhere connected end-points are comprised of Linux and Microsoft operating systems.\n\nThe Linux machine can store the malicious code, which can be exploited on the Windows\n\nmachine. The attack techniques like server-side attack forgery where the request is sent\n\nto one machine to compromise the connected machines; hence, an ecosystem where all\n\nsystems are interconnected requires serious protection from malware. Though the Linux\n\nsystem has more security control than the Windows system, like file permission directory\n\npermission, attackers can still bypass these controls to execute malware (Yaswinski et\n\nal., 2019). Security practices like Linux server patch management, regular security audits\n\nand logs monitoring, along with security hardening (Yaswinski et al., 2019), even cannot\n\ndetect the malicious code. Antivirus software installed on Linux systems helps detect and\n\nremove the malware for files with signatures available for those malicious files (Mohanta\n\net al., 2020). The way traditional antivirus system works is based on the signature\n\nupdates, which gets the feeds from multiple threat intelligence (Martin et al., 2018).\n\nRecent ransomware attacks are an excellent example of compromising an end-point\n\nwhere the executable file encrypts the hard disk of the user machine. If such malware\n\ndoes not have known signature patterns, then the end-point protection will not be able to\n\ndetect or remove it from the machine. The challenge is that if a new malware or malicious\n\ncode or zero-day malware code is sitting on the system, which is not executed yet,\n\ntraditional antivirus tools will not detect due to signature unavailability (Shah & Singh,\n\n2016).\n\n10\n\n\n-----\n\nThe lack of detecting zero-day malware poses a considerable threat for a single end\npoint and the entire ecosystem for connected end-points.\n\nHence the objective is to find a method to detect the execution of the malicious code and\n\nfind the abnormal behaviour to protect the system. Documentation is available for\n\ntraditional signature-based detection for the malicious code. The methods and\n\ntechniques are available to handle the variant of the existing malicious file; however,\n\nconsiderable work is required to detect zero-day malware. This research thesis aims to\n\nanalyse the gap in the detection of known and zero-day malware. The malicious file can\n\ncause a threat when it is executed. The point when the file is executed can be addressed\n\nto detect the zero-day malware. The research on the understanding of the malicious file\n\nbehaviour is kept as the objective of the thesis. The motivation is to understand the\n\nbehaviour and apply the control mechanism to limit the activity by quarantining the\n\nmalicious file. The work focuses on methods and processes using multiple tools to\n\nidentify the system processes initiated by the malicious code. In order to support the\n\nthesis work, a lab setup is prepared to experiment with the known malware sources and\n\nsimulated that malware as zero-day malware. The malware file execution monitors the\n\nbehaviour of the files and compares the activities with the expected behaviour. The thesis\n\ndoes not include the machine learning techniques for abnormal behaviours or the\n\ndetection of false positives but focuses on the technique to detect zero-day malware due\n\nto abnormal behaviour. Open-source tools are used during the research for the Linux\n\noperating systems. Tools are readily available and customisable as per the experiment\n\nrequirements. The environment is kept very controlled to avoid the spread of malware\n\nwhen executed. The toolsets used are customizable as per the lab environment. The\n\nselection of database and programming language to build the setup is only to support\n\nthe method and technique discussed in chapter 3.\n\nThe research questions are raised to determine if the processes behaviour can detect\n\nthe zero-day malware, and the second phase answers the automated method to act on\n\nthe malicious file. The focus of the research is on abnormal behaviour of the processes\n\n11\n\n\n-----\n\non the Linux based operating systems. The technique discussed in chapter 3 applies to\n\nthe Windows based systems as well. However, the architecture of the Windows\n\noperating system needs to be considered while applying the same technique, which is\n\nnot part of the thesis.\n\n## 1.2. Thesis Structure\n\nThe thesis is divided into six parts. The first chapter has given the introduction of the\n\nthesis topic and discusses its background details. The motivation for conducting this\n\nresearch was briefed, and the reason for this research is emphasised. It gives a brief\n\noverview of the threat posed by zero-day malware on the system. Also, set the scope of\n\nthe thesis work.\n\nChapter 2 presents the literature review and details the concepts involved with the Linux\n\noperating system internal architecture. The internal architecture is a critical component\n\nto study as the behaviour of the file is detected through processor utilisation. It provides\n\nthe details for the malware and its analysis techniques to prevent the end-point with the\n\nmalicious code. YARA rule concept is discussed. Challenges are identified in the\n\nliterature, which elaborates the problems with the malware, which is zero-day.\n\nChapter 3 details the research questions, which are to be answered by the end of the\n\nthesis. The chapter details the method and technique used to build the lab setup to\n\nprovide answers to the research question.\n\nChapter 4 provides the details of the test results-driven for the environment built in\n\nchapter 3. It includes step by step output for the method and technique defined in the\n\nprevious chapter. Results of some of the sample malware have been presented in\n\nchapter 4 and provide an overview of the sample malware used for the experiment.\n\n12\n\n\n-----\n\nThe discussion around the test results is presented in chapter 5. It also highlights the\n\nrelation between the challenges highlighted in the literature view and the research\n\nquestion raised for this thesis.\n\nThe summary of the finding, limitations of the thesis and possible future areas are\n\ndiscussed in chapter 6.\n\n13\n\n\n-----\n\n# 2. Literature Review\n\nThis chapter discusses the components which are involved during the research. The first\n\nsection provides the details for the existing malware analysis techniques and the\n\nvariations. It also discusses the available mechanism for the protection on the endpoint\n\nwith antivirus tools. It covers current tools to protect the malware and how multiple threat\n\nintelligence collaborates to update signatures for new malicious code. Different methods\n\nused by multiple vendors to update the database is discussed. The primary research\n\nfocuses on zero-day malware detection on Linux operating system; therefore, this\n\nsection contains a brief description of the internal architecture for the Linux operating\n\nsystem. Linux is an open-source platform with multiple vendor-specific variations;\n\nhowever, the base internal kernel and architecture is the same. The chapter ends with\n\nan overview of the related work for the detection of zero-day malware protection.\n\n## 2.1. Malware Analysis\n\nMalware breaches cost companies of all sizes. IBM security cost of Data Breach\n\nResearch Report shows that the average accumulated cost is $3.86 million and alone in\n\nthe United States is $8.64 million (Klaus & Elzweig, 2020).\n\nMalware is malicious code designed to install covertly and target systems as undetected.\n\nIt can be designed to destroy the data or install additional programs or exfiltrate it (Or\nMeir et al., 2019). It may include all the above three depending on the target agenda, like\n\nespionage, cyber terrorism, or others. It is to compromise the confidentiality, integrity and\n\navailability of a victim’s data. Malware has been evolving, and historically these malicious\n\ncodes were designed to take immediate action and were easy to notice. Previously, such\n\nmalware was easy to categorise depending on the various type of infection to follow the\n\nhandling procedure. Such malware is designed for stealth and stays in the system silently\n\nor dormant for weeks or months; hence tough to be noticed and spread slowly over time\n\n14\n\n\n-----\n\n(Radhakrishnan et al., 2019). This way, it gets more time to gather more information to\n\nexfiltration. These attack types usually need one procedure, and most attacks are\n\nblended and use multiple methods. There are multiple transmission methods, including\n\nphysical access to the system, social engineering, phishing, or visiting a malicious site.\n\nAlso, there are multiple forms of malware like viruses, worms, Trojan horses, mobile\n\nattacks and blended attacks. Viruses are self-replicating and install themselves into\n\ncompiled viruses and interpreted viruses. Compiled viruses are executed by the OS and\n\ncan be an infected file or boot sector virus. This category can trigger during the system\n\nboot and hence can cause harm even before starting the antivirus program (Mohanta et\n\nal., 2020). An application like macro and scripts executes the interpreted viruses. Worms\n\nare also self-replicating programs like viruses and are usually self-contained, which can\n\nexecute and spread without user interaction (Christodorescu et al., 2007). There are two\n\nmain categories of worms, network service worms and mass-mailing worms. Network\n\nservice worms exploit network vulnerability to propagate and infect others. Mass mailing\n\nworms only particularly to email systems to spread and target others. Trojan horse\n\nprograms are different from viruses or malware as they cannot be replicated. These\n\ntrojan horses have hidden payloads. Such malware is usually disguised in a program\n\nand application which seems to be legit. Such software replaces legitimate files with\n\nmalicious files or adds additional components to track the host, like keyloggers. The last\n\nattack vector to consider is the malicious mobile code. It is delivered remotely and\n\nexecuted on a local host without its intervention. Java, ActiveX and VB scripts languages\n\nare primarily used for such types of attacks. Blended attacks use a combination of\n\nviruses, worms or trojan horses (Gandotra et al., 2017).\n\nThere are different types of malware analysis; static analysis is analysing malware\n\nwithout executing or running it. The purpose of static analysis is to extract as much\n\nmetadata from the malware as possible. In the dynamic analysis, malware is executed\n\nto understand the functionality and its behaviour. It is also performed in a containerised\n\nway to avoid exploitation. Code analysis is the process of reviewing the code. The review\n\n15\n\n\n-----\n\nof code can be accompanied either using the static or dynamic method. Behavioural\n\nanalysis monitors the process execution, registries update and look for abnormal network\n\nbehaviours (Or-Meir et al., 2019).\n\nThe goal of malware analysis is to prepare with the available toolsets, and these tools\n\ncan help identify the malware. The next step after identification is to contain the malware\n\nand limit its impact. The mitigation is performed to reduce the risk and recover the\n\nservices affected by the malware. It is always advisable to document the analysis and\n\nimplement a plan to control such malware to exploit the vulnerability. The open-source\n\nplatforms are more vulnerable to malware due to being publicly available. The malware\n\ndefence on the system is protected by endpoint protection which involves anti-virus tools.\n\nDue to the reliance on signature-based alerts, the analyst will need to manually analyse\n\nand update the signature after investigation. There are several malware analysis tools\n\navailable, like Cuckoo and Joe Sandbox.\n\n## 2.2. End-Point Protection\n\nAntivirus software provides end-points protection, which connects to the centralized\n\nrepositories and downloads the signatures for the known malware. The software\n\nprograms scan the end-point and match the files against those signatures. If files are\n\nfound with the matching condition, the files are quarantined or removed from the system\n\n(Mohanta et al., 2020). The file removal process is also critical, as in the case that the\n\nfile is already executed or engaged in some other processes, the file will not delete\n\n(Mcafee, 2021). However, such software tools are capable of alerting if the malicious\n\nfiles cannot be deleted. The limitation of these end-point protection methods is the\n\ndependency on malware's signature (Gandotra et al., 2017). If the vendor-specific does\n\nnot have the updated database for signature, the client will not have details for the\n\nmalicious file. If the malicious file with no signature update executes codes, then its\n\nimpact will be zero-day malware. The zero-day malware will not be blocked by traditional\n\n16\n\n\n-----\n\nantivirus software (Crowdstrike, 2021). The attacker uses multiple dynamic techniques,\n\nwhich are challenging to block if the antivirus tool does not have available information. It\n\nleaves a security gap for the end-point protection if the malware is zero-day.\n\n## 2.3. Cyber Threat intelligence\n\nIt is gathering, evaluating, and analysing data on threats that are being faced. It then\n\nallows strategizing the defence, which can assist in entirely preventing the threat or\n\nreducing the impact of the damage caused. Finally, understand the full details of the\n\nthreat, including the tools used during the attack, what information is compromised, the\n\nmethod used for the malware communication, and others. This information is used to\n\ncreate a threat profile that can assist in the model of the impact of a specific attack that\n\ncan be used to prevent and reduce the impact of attacks (Baker, 2019). It enables to get\n\nthe multiple feeds from the public, private, dark web and aggregate the data on the threat\n\nATP which impacts the business. There is malware information sharing platform\n\navailable like virustotal, MISP and others. Such platforms exchange and share threat\n\nintelligence, an indicator of compromise (IoCs) about the targeted malware and attacks,\n\nor any intelligence within the community (Baker, 2019). Threat intelligence is the\n\ncollection of databases maintained by the different security vendors. It ensures that if the\n\none vendor marks the file malicious, it generates the hash, MD5 or SHA, and shares the\n\ninformation with the partners. It also validates the authenticity of the malicious file. As\n\nmore vendor marks the file malicious, the more the confirmation of its malicious nature\n\nis verified. Threat intelligence is a process that transforms the file collected for the\n\nanalyses till the final intelligence decision. It provides a guide to the cybersecurity team\n\n(Crowdstrike, 2021).\n\n17\n\n\n-----\n\n## 2.4. Linux operating System\n\nThis section covers the architecture of a Linux based system. It will include the\n\ndependencies of the operating system with the hardware, services, API and system\n\nprocess. These areas are essential to understand as vulnerabilities in these components\n\ncan be utilized to exploit the operating system. Assessing the abnormal behaviour of the\n\nfiles that have dependencies on the system's architecture is critical to understand.\n\nMemory, CPU usage, and file location are the essential parts of detecting abnormal\n\nbehaviour. These components can be monitored to contain zero-day malware.\n\n### 2.4.1 System Architecture\n\nAs shown in figure 2.1., Linux operating system has three major components. Kernel,\n\nkernel modules and system libraries. The kernel is the core of the operating system, and\n\nit enables the communication between the device and the software, which is also\n\nresponsible for managing the system resources. It includes four significant\n\nresponsibilities device management, memory management, manages processor for\n\nsystem handling call. The Device management involves managing any Input-Output (I/O)\n\ndevice where devices include Graphics cards, Sound cards, and others. The kernel\n\nstores and use device drivers to manage the hardware. It also enables communication\n\nbetween different sets of hardware. Memory and process management has been\n\ndescribed in more detail in section 2.5.2.1 and 2.5.2.2, respectively. Any query made by\n\na programmer to the kernel is handled by the function called system handling call. The\n\nprogrammer needs system libraries to pass the message to the kernel. There are\n\nvariations of system libraries available for different kernels.\n\n18\n\n\n-----\n\n**_Figure 2. 1. Linux System Architecture._**\n\n(Ko et al., 2008)\n\nKernel modules manage the hardware layer, which includes memory, CPU and\n\nperipheral devices. The kernel module manages physical memory using a memory\n\nmanagement unit. It uses virtual memory construct to use memory address space which\n\nis more than the physical memory. It is responsible for mapping virtual memory to\n\nphysical memory, memory cache, and during the context switching, it manages the table\n\nof process pages.\n\nKernel module manages CPU resources by scheduling access to resources from\n\nprocesses. It is performed by enforcing the scheduling method to access the CPU while\n\nkeeping the programs transparent for the CPU resource usage. As part of the algorithm,\n\nit creates, executes, suspends, and destroys the process. This component also works\n\nwith the memory management to give CPU resource access for active requests in the\n\nmemories.\n\n19\n\n\n-----\n\n##### 2.4.2.1 Memory Management\n\n**2.4.2.1.1 Virtual Memory**\n\nPhysical memory has a limited resource, and the hardware limits the memory size that\n\ncan be installed on the system. The address range for the physical memory may not be\n\ncontiguous, and these ranges vary with different system architecture (Stazi et al., 2017).\n\nVirtual memory is used to overcome the complexity. It provides large address spaces,\n\nwhich means that the system appears to have more memory than the actual available\n\naddress. It enables the protection as it makes each process have dedicated virtual\n\nmemory address space (Kim et al., 2014). Figure 2.2 depicts the impact of the system\n\nwithout virtual memory and how virtual memory overcomes the problem.\n\n**_Figure 2. 2. Memory Address Table_**\n\n(Ko et al., 2008)\n\nThe process allocated for each application is separate due to the complete virtual\n\nisolation of address space from one another. This segregation protects memory areas if\n\nthe rogue application tries to overwrite the data on another legitimate application (Kim et\n\nal., 2014). It manages virtual memory for shared processes as well. This situation keeps\n\n20\n\n\n-----\n\nthe shared process in the physical memory and logically shares the virtual address\n\nspace. It does the memory mapping in which the file's content is linked to the address\n\nspace of the virtual memory used by the process. Virtual memory also plays an essential\n\nrole if the memory address is not contiguous. The map table can adjust the non\ncontinuous address space by splitting the data content (Ko et al., 2008). The program\n\nwill still see it as a single address. The figure 2.3 depicts the map table.\n\n**_Figure 2. 3. Map Table_**\n\n(Kim et al., 2014)\n\n21\n\n\n-----\n\n**2.4.2.1.2 Abstract model of virtual memory**\n\nWhen the processor executes the program, it takes the instruction from memory and\n\nthen decodes it. The data is fetched or stored from or in the memory during decoding\n\n(Ewais et al., 2016). The memory location is accessed via a virtual address which is\n\nmapped with the physical address. The processor is responsible for converting the virtual\n\naddress to a physical address using the table maintained by the Linux operating system.\n\nThe mapping is divided into pages to make it easier to maintain virtual and physical\n\nmemory. The pages' size may vary depending on the operating systems and preferred\n\nthe same page size to reduce the complexity. On the intel x86 system, the page size is\n\n4K bytes. The page frame number is used to assign a unique number to each page\n\n(PFN). On the intel system, the virtual address contains two components, bits 0 to 11 (12\n\nbits = 4096B (4KB)) makes the offset and the remaining bits represent the virtual page\n\nframe numbers. Table 2.1 shows a page table with a page of 4KB. It shows that if the\n\nprogram accesses the address 20, then it is in the address range of 0-4069, which set\n\nthe offset of 0+20; hence on the virtual table, it maps as 20. Similarly, it adds 20 offsets\n\nfor the corresponding physical address. In this case, the physical address will be 4100,\n\nas shown in figure 2.4.\n\n**_Table 2. 1 Virtual Address MAP_**\n\n22\n\n\n-----\n\n**_Figure 2. 4. Virtual Address Space_**\n\n_(Stazi et al., 2017)_\n\nFor a 32-bit machine with a physical memory of 256 MB and 4KB page size, the offset\n\nbits of 12 bits makes the page size 4KB (2^12 = 4K).\n\nThe virtual address is 20 bits which excludes the 12 offset bits. The physical address of\n\n16 bits is formed for 256MB of physical memory, equivalent of 2^28 by excluding the 12\n\noffset bits.\n\nOffset bit 12 bits with a page size of 4KB (2^12 = 4K). Figure 2.5 illustrates the page map\n\ntable where the offset value remains the same.\n\n23\n\n\n-----\n\n**_Figure 2. 5. Virtual and Physical Pages_**\n\n(Ko et al., 2008)\n\nVirtual memory is more than physical memory; hence the operating system must use the\n\nphysical memory efficiently. It is done by only loading the required data in the memory.\n\nThis way, physical memory is utilized efficiently, and the technique is called demand\n\npaging (Nothaas et al., 2019).\n\nThe operating system marked it as a page fault when the process attempts to access a\n\nvirtual address, which is currently not available in the physical memory and hence\n\nprocessor could not find the page table entry in the mapping table for that virtual address.\n\nIn such a scenario, the operating system may end processing the program as it may\n\nconsider it a rogue application that might be accessing the system in the wrong way (Kim\n\net al., 2014). On the other hand, if the virtual address is valid and does not have a valid\n\nphysical memory address, it may look for the address on the disk. Due to the slow nature\n\nof the disk, it takes more time to fetch data and hence take more time to execute the\n\nprocess. If it has another job during the waiting period, execute that program to avoid\n\nany idle period. Once the access is made from the disk, the content is added to the free\n\navailable physical address, and the map table is updated. Next time when the virtual\n\naddress is called, it can directly access it from the physical address as updated in the\n\nmap table (Chen et al., 2016). Linux uses demand paging to load executable images into\n\n24\n\n\n-----\n\nprocesses virtual memory. Whenever a command is executed, the file containing it is\n\nopened, and its contents are mapped into the process virtual memory. It is done by\n\nmodifying the data structures describing this processes memory map and is known as\n\nmemory mapping. However, only the first part of the image is brought into physical\n\nmemory. The rest of the image is left on the disk. As the image executes, it generates\n\npage faults, and Linux uses the processes memory map to determine which parts of the\n\nimage to bring into memory for execution (Chen et al., 2016).\n\nWhen there is no space available on the physical memory, the operating system must\n\nmake space for the new page by removing the page from the physical memory. If the\n\ndiscarded page in the physical memory is from an image or a data file that does not need\n\nto be written, the page is not saved. Moreover, if it again requires the image and data\n\nfile, it can be brought again to memory from the disk. In case of page modification, the\n\noperating system must preserve the data to access later. The modified pages are\n\nreferred to as dirty pages (Yildiz Cavdar et al., 2019). These modified files are temporarily\n\nremoved from the memory and stored in a particular file called the swap file. As these\n\nswap files are stored on the disk, it takes a longer time to process. Its operating system\n\nmanages the swap file and content in the memory to avoid long access time for the active\n\nfiles. If the algorithm to operate swap files is non-efficient, like moving the swap file on\n\ndisk and the physical memory, it keeps the processor busy (Liu et al., 2016).\n\nAny file which requires more regular access is not the ideal candidate for swap files. The\n\nset of pages that a process is currently using is called the working set. An efficient swap\n\nscheme would make sure that all processes have a working set in physical memory.\n\nLinux operating system uses the Least Recently Used (LRU) technique for page aging.\n\nIt is to keep track of which pages may need to be removed from the memory. The age of\n\nthe page depends on the time it is accessed. The age of the page decreases when it is\n\naccessed and increases when not. The old-age page file has more probably to move into\n\nthe swap file (Chen et al., 2016).\n\n25\n\n\n-----\n\nDifferent processes use different map tables to maintain the translation between virtual\n\nand physical addresses, and some processes share the same physical address. In this\n\ncase, two different process map tables with different virtual addresses point to the same\n\nphysical address.\n\nThe Linux operating system runs on the physical address mode. Physical address mode\n\ndoes not require any page table, and the processor does not look for the map table to do\n\nthe address translation.\n\nThe memory access to look for address translation is prolonged as compared to CPU\n\nspeed. To overcome the waiting time for the CPU process cycle, the CPU maintains a\n\ncache of translation known as Translation Lookaside Buffer (TLB). Even though TLB is\n\nnot efficient if the TLB cycle is missed, to overcome this modern inefficiency CPU, allow\n\nmapping the memory pages directly at the high hierarchy level in the page table. Such\n\npages in Linux operating system is called massive, and it helps improve the TLB hit rate\n\nand enhance system performances.\n\nAccess control is also applied to ensure that the process does not take any other action\n\nthat it does not intend to.\n\nThe physical memory can be divided into zones and allocations depending on the\n\nmemory system used by I/O hardware and the processing unit. There are four categories\n\nof zones; the first one is ZONE_DMA, which uses lower 16MB of the physical memory.\n\nThe second zone uses 32 bits address and is known as ZONE_DMA32. Due to the limit\n\nof 32bits address, it has a limit of 4GB. On x86 intel, the first 896MB, which is the direct\n\nmemory access by the kernel, is referred to as the LOW_MEM zone, which the kernel\n\nuses for logical addressing. This region uses the \"k-malloc\" and \"k-free\" library functions\n\nfor requesting and deallocating the kernel memory in this zone. This region also has a\n\nmapping to the physical memory and hence does not use the swap. The high memory\n\nzone is from 1GB to 4GB address region on a 32-bit system. This zone is only available\n\n26\n\n\n-----\n\non the 32 bits system and 64, but systems only low memory zone is applicable figure\n\n2.6.\n\n**_Figure 2. 6. Memory Zones_**\n\n(Wu et al., 2012)\n\nThe pointer uses the address range from 896MB to 1 GB is reserved in 32 bits systems\n\nto reference the memory address in areas beyond the kernel logical address.\n\nThe address allocation/deallocation outside the LOW_MEM zone is done through \"v\nmalloc\" and \"v-free\" library functions. The difference between \"v-malloc\" and \"k-malloc\"\n\nis that \"v-malloc\" does not need to have contiguous memory in the virtual address and\n\nphysical address mapping. It also uses more entries in the TLB because of non\ncontiguous allocation. The fragmentation is reduced using the memory zone allocator.\n\nThe user-mode process uses the buddy system, where it keeps track of the adjacent\n\nmemory block or splits the memory block by a power of 2. In this case, if a request\n\nrequires additional blocks, the buddy system identifies the adjacent blocks that can\n\nhandle that big request and place it accordingly to avoid the fragmentation or splitting of\n\n27\n\n\n-----\n\nlarge block spread in multiple blocks. On the other side, if the size is small, it repeatedly\n\nreduces the size of the block by two till it gets to the defined lower limit, which can handle\n\nthe request.\n\n##### 2.4.2.2 Process Management\n\nThis section will brief the kernel process management. The systems call and signals\n\nmanagement is essential in identifying any process initiated by the malicious software.\n\nIn this section, scheduling, task and kernel synchronization is discussed\n\n**2.4.2.2.1 Signal Management**\n\nProcess ID (PID) is a unique identifier assigned to each process. There is a fork system\n\ncall that is used by the process to create another process in Linux. The process that calls\n\nor creates the process is called the parent process, and the new process is known as\n\nthe child process. It allows the image in the memory and variables associated with the\n\nparent process to be called into the child process, enabling the child process to access\n\nthe open files used by the parent process (Tanenbaum & Bos, 2014). Multiple child\n\nprocesses can be associated with the parent process, whereas the child process has\n\nonly a single parent process. When the fork() call is executed if successful, the PID of\n\nthe child is returned in the parent process, and 0 is returned in the child process. Due to\n\nany process failure in the call, the parent process gets the value -1, and the child process\n\nis not created. The child process generates a SIGCHLD signal to the parent process if\n\nits interrupts or exits the process. The only condition when a child process has no parent\n\nprocess is if the kernel creates it. The child process can spawn more child processes\n\nwhich can create a complex process tree; hence \"get-PID\" system call is used by the\n\nchild process to get the process identifier of the parent process (Kerrisk, 2010).\n\nThe exec system call is used to execute a file that is residing on the active process.\n\nWhen this is called, a file is executed, which replaces the previous executable. Therefore,\n\nwhen the shell command is launched, it replaces the image of the environment's memory\n\n28\n\n\n-----\n\nand variable with the values that initiated the process. The WAITPID system call is used\n\nif it is required to suspend the calling process. This suspension of the child process\n\nremains till the child process state is changed. By default, if no argument is given, the\n\nsuspended process remains suspended until the child process returns the terminated\n\nprocess identifier, which is -1. If the child process is completed but does not send the\n\nexit status to the parent process, then the WAITPID system calls initiated by the parent\n\nprocess will remain in the process table. Such open processes are termed Zombie\n\nprocesses (Love, 2010).\n\nAs the process identifiers are unique, multiple processes send the communication signal\n\namong the processes. The process which belongs to the same process group, also\n\nreferred to as the process family tree, can send signals to another process in the same\n\ngroup. Signals can be used for multiple instructions like SIGHUP (terminate gracefully),\n\nSIGTERM (terminate unconditionally and immediately), SIGKILL (suspend itself) (Shotts\n\nJr, 2012).\n\nSIGACTION system call is used to change the action taken by a process by the receipt\n\nof a specific signal. To kill the process immediately, SIGKILL is used and does not wait\n\nlike SIGTERM. It is not handled by SIGACTION and directly goes to the kernel\n\n(Tanenbaum & Bos, 2014).\n\n**2.4.2.2.2 Process Representation**\n\nThe task_struck data structure represents each process in the Linux system. The task\n\n_struck has the array of pointers known as task vectors. The necessary process\n\ninformation like state, memory-related information, files, process details for parent and\n\nchild processes are found in this structure. The kernel manages these pointers, and all\n\nthe active processes are double linked in the task_struck. Process identifiers are used\n\nas the critical value of the task_struck (Tanenbaum & Bos, 2014). The size of the task\n\nvector also represents the allowed number of maximum processes in the system. As\n\nprocesses are created, a new task_struct is allocated from system memory and added\n\n29\n\n\n-----\n\ninto the task vector. The current pointer points to the currently running process to make\n\nit easy to find.\n\nWhen the parent process creates the child process, both these processes share the\n\nsame pages in the memory. Shared pages are marked as \"copy on write\", which creates\n\nthe page copy before writing to the process. It protects the pages modification, which\n\ncould impact another process. It also helps in reducing the memory overhead and\n\nrequirement during the creation of the process. It also improves the efficiency as the child\n\nprocess may not use the resources of the parent process, which may be terminated after\n\nspawn or may call another program which replaces its memory image and pages (Love,\n\n2010).\n\n**2.4.2.2.3 Thread and Tasks**\n\nThe research is based on detecting the malware on the abnormal behaviour due to the\n\nunusual process. Each process has a basic unit of execution which is known as thread\n\n(Fox, 2014). It implies that each process has multiple threads. It is essential to\n\nunderstand the components of threads to identify and stop them if it finds malicious\n\nactivity. This capability can enable the run-time analysis of the behaviour of the program\n\nbeing executed successfully. The information in the kernel structure of a process can\n\ndifferentiate between malicious and benign processes (Shahzad et al., 2011).\n\nThe task structure as maintained by the kernel of the operating system contains has the\n\nrecord of each action and the amount of resource used by the process; hence this pattern\n\nof records must be different for the malicious process and benign process (Shahzad et\n\nal., 2011). The challenge for detecting malware on the processor threads is the accuracy\n\nrate. Hence modelling of such threads is essential to reduce the false alarm.\n\n30\n\n\n-----\n\n## 2.5. Related Work\n\nThis section discusses existing work done related to the detection and analysis of\n\nmalware. This section also contains a few sandbox methods and reviews some sample\n\nmalware on the Linux system.\n\n### 2.5.1 Malware Analysis Methods\n\nThe following section reviews the current literature available on numerous methods for\n\nmalware analysis.\n\n##### 2.5.1.1 Basic Malware Analysis Method\n\nMalware analysis is a method to examine the malware component, its behaviour, and if\n\nan attacker can be identified. Figure 2.7 shows the flow of the basic malware analysis\n\nmethod.\n\n31\n\n\n-----\n\n**_Figure 2. 7. Malware Analysis_**\n\n(Kara, 2019)\n\nInvestigation of all analysis is done on the image (copy), and the hash method is used to\n\ndetect the integrity failure. The image includes all currently available data, deleted data or\n\nany other data available in the storage. Image processing is the fundamental step for the\n\nanalysis (Kara, 2019).\n\nA dedicated and isolated virtual machine is created to mount the copy of the image to analyse\n\nthe behaviour.\n\nThe behaviour analysis of malware includes registry activity, network operations, file and\n\ndirectory transfers. Sometimes unintentional bugs are introduced when creating malware.\n\nHence, debugging can be performed with behaviour analysis. This error information is\n\nessential. In some cases, debugging can provide information about the attacker (Kara, 2019).\n\n32\n\n\n-----\n\nThe code analysis is performed with static, dynamic or reviewing the packaging techniques.\n\nThe static analysis includes viewing the text, function used, file directory, compressed file\n\nstatus, hash values and since it is activated in the system. Many attackers compressed the\n\nmalware file to escape the detection from antivirus tools; hence, it is critical to understand\n\nmalware packaging techniques (Vasilescu et al., 2014). Finally, the code is executed in a\n\ncontrolled and isolated environment to observe the activities. Attackers implement\n\nconcealment methods (such as anti-sandbox, anti-VM and anti-debug) to prevent malware\n\nfrom being detected by antivirus programs in the system before its execution. Therefore, the\n\ndata obtained from running malware is more critical than static analysis (Christodorescu et\n\nal., 2007).\n\nMemory analysis is critical as processes in computer systems need to be loaded into memory\n\nto be executed. Even though malware might use different methods, such as hiding in the\n\nmemory of other running processes, they cannot be caught by antivirus programs but still\n\nneed to be loaded into the system.\n\nAll the activities of different processes working in the system will be in the memory. Therefore,\n\nmemory analysis allows a better option to detect all the current activities. The current state\n\nof the system can be saved using the snapshot feature of the virtual machine. In the memory\n\nanalysis, the list of processes running in the system at the time of the memory dump, the\n\nactive or previous network connections, .dll files or codes injected into the memory areas of\n\nthe processes can be dumped.\n\nMalicious software hides from conventional detection methods and, in some cases, can\n\nchange the way it behaves to deceive analysts. However, even in this case, they are still\n\nresident in the memory.\n\nHowever, the memory dump contains only a snapshot of the computer’s state. It is necessary\n\nto take continuous dumps to understand what has changed after the memory dump. It is\n\nlimited by the time available for analysis. The memory dump can be retrieved on the live\n\nsystem, but this poses several risks. If malware is present in the system, it may intervene in\n\n33\n\n\n-----\n\nthis process. Data in memory is volatile. Hence make sure that the system is not shut down\n\nas it may lose the data in the volatile memory (Gandotra et al., 2017).\n\n##### 2.5.1.2 Analysis System Components\n\nThe Two components provided by (Wagner et al., 2015) for malware analysis systems\n\nare data provider and analysis environment. The data provider includes the toolset or\n\npackages used for dynamic or static analysis of the malware samples. The Static tools\n\nlike IDA, GDB, Radare2 and others, whereas Rekall volatility, are used for dynamic\n\nanalysis. The environment to do the necessary analysis are tools like the cuckoo, threat\n\nanalyser and others. A dedicated or isolated environment is essential for the dynamic\n\nanalysis, set up on the virtual machine, bare metal or emulated environment (Wagner et\n\nal., 2015).\n\nMachine learning libraries can be used as well to extend the capability of malware\n\nanalysis. It helps in the learning system for the classification and detection of malware.\n\nThe output collected from the data provider is used with the machine learning algorithm\n\nto build a more robust system (Shah & Singh, 2016)\n\n(Boukhtouta et al., 2016) in his trial utilised the dynamic examination of malware tests\n\nand documents to prepare the frameworks for mechanised malware recognition and\n\ncharacterisation. In (Shah & Singh, 2016), the extraction of prominent API calls from\n\nbenign and malicious files was used as input to linear support vector machine (SVM).\n\n(Boukhtouta et al., 2016) using the Threat track online sandbox for deep packet analysis\n\nand examination of flow packet headers in malicious network traffic, trained a system\n\nusing ML algorithm. Benign traffic was sought from the Internet service provider edge\n\nand customer traffic.\n\n(Shah & Singh, 2016) did the malware analysis use multiple modes? Modes include user\n\nmode, kernel mode, full system simulation or emulation, virtual machines and others.\n\nAPI is used to call to collect the relevant information for the data.\n\n34\n\n\n-----\n\n### 2.5.2 Indicators of Compromise\n\nAs per the National Institute of Standards and Technology (NIST) publication on Intrusion\n\ndetection and prevention, one of the primary purposes of using IDS and IPS is to detect\n\nattacks (Kizza & Migga Kizza, 2011) and other security breaches which cannot be\n\ndetected or prevented with the usual security methods. Abuse detection and anomaly\n\ndetections are the two standard methods to analyse the detection. In abuse detection,\n\nif any attack occurs with the pre-defined method or warning, then such characteristic of\n\nabuse detection is an indicator of compromise (IoC). One of the methods to determine\n\nthe IoC is to do the malware analysis (Akram & Ogi, 2020)\n\nIoC can be determined by using the reverse engineering technique while doing the\n\nmalware analysis. It is a forensic artefact of an attack that exist either on the machine or\n\non the network. The data collected during the malware analysis is termed the artefact. It\n\nmay include files, URL, IP, process, and registrations that would have been used to\n\nexecute malware. The artefact collected is used to set the indicator of compromise. All\n\nthe data collected during malware analysis is not included in the indicator of compromise.\n\nArtefacts are classified into two categories which are network and host-based artefacts.\n\nData collected from the network includes ports, servers, and proxies used. Tools like\n\npacket capture are used to collect this data. The host-based can include the files,\n\nmemory, or process usage (Boukhtouta et al., 2016).\n\nReverse engineering for malware requires a disassembler that converts code to the\n\nassembly language. The other component is the decompilers which convert machine\n\nlanguage to the high level for the easy understanding of engineers doing the reverse\n\nengineering for the malware analysis to find the indicator of compromise (Mohanta et al.,\n\n2020).\n\n35\n\n\n-----\n\n### 2.5.3 YARA\n\nThe rapid growth of malware incidents indicates a problem in malware analysis. This\n\npace of malware growth poses a challenge for malware analysts. There are multiple\n\ntechniques available for malware analysis concerning specific security incidents. In\n\npresent times YARA rules have come up as the widely accepted technique for malware\n\nanalysis due to their flexibility and customizable nature. As per (Naik, Jenkins, Cooke, et\n\nal., 2020) It allows the analyst to create YARA rules as per the specific requirements to\n\nhandle the specific threat. It is also based on the reverse engineering technique of\n\ndifferent malware to include the standard indicator of compromise strings from those\n\nsamples and use this data to find similar types of malware.\n\nThe effectiveness of YARA rules determines which types of IoC strings and the numbers\n\nof these strings in the rule. Therefore, the biggest challenge is to create an effective\n\nYARA rule for malware analysis. These rules can be created either manually or\n\nautomatically. The manual creation of YARA rules requires much skill in specific security\n\nareas. The automatic rules generations can be created using specific tools hence\n\nrelatively easy. The challenge with the automatic method is the optimization of\n\nrequirements and less effectiveness with multiple threats (Naik, Jenkins, Cooke, et al.,\n\n2020). When YARA rules are triggered, it generates a malware alert if the malware\n\nmatches the string condition. If the sample condition does not match, it does not trigger\n\nan alert and requires the rule to be updated. Note that the malware string is created using\n\nIoC from the sample, which means the classification of the malware being analyzed is\n\nnot the same as the sample. These issues can be remedied by adding more strings;\n\nhowever, size increases adversely impact the YARA rules performance. Secondly,\n\nadding or modifying the string needs expertise in computer security (Naik, Jenkins,\n\nSavage, et al., 2020).\n\nMultiple open-source tools are available: python-based like YarGen, YARA generator,\n\nYabin, and others. Fuzzy hashing aided is one of the techniques available to improve\n\n36\n\n\n-----\n\nthe effectiveness of the YARA rules without adding complexities. The hashing method is\n\napplied alongside YARA rules which complement each other. Hence if the malware alert\n\nis not triggered by one, the other method can detect it.\n\nThe Fuzzy hash method is used to find the similarity of the digital files. This assists in\n\nmaking a valuable method for malware analysis because many malware and variants\n\ncontain similarities. It is different from the cryptographic hash as the variant will make the\n\nhash of the two files differ. In the fuzzy hashing technique, the file to analyze is divided\n\ninto chunks, and it calculates the hash against each block. Then these individual hashes\n\nare merged to form a concatenated hash called the fuzzy hash of a file. The fuzzy hash\n\nvalue depends on the size of the block, the size of the file and the output size of the hash\n\nmethod used. The malware analysis needs a deep knowledge of the similarity of the\n\nknown sample malware and the file being assessed for malware. It becomes crucial\n\nwhen work is done to identify the variant.\n\n### 2.5.4 Sample Malware Analysis on Linux System\n\nMany machine learning methods were used to detect malware in Linux systems (Mehdi,\n\nS.B., Tanwani, A.K., Farooq, 2009) and (Shahzad et al., 2013). Different structures were\n\nused for these detections like (Mehdi, S.B., Tanwani, A.K., Farooq, 2009) used task\n\nstruct for the classification, whereas (Shahzad et al., 2013) worked on the ELF file\n\nstructure. The (Mehdi, S.B., Tanwani, A.K., Farooq, 2009) technique was able to get\n\n99% accuracy using multiple malware samples, which is an excellent method to detect\n\nzero-day malware. As per (Shahzad et al., 2013), the used system calls when ELF files\n\nwere executed, which produced 96% of accuracy.\n\n(Damri & Vidyarthi, 2016) used dynamic analysis of malware to identify five approaches.\n\nThese uses system call, process control block, ELF, kernel and hybrid investigation,\n\nwhich uses four methods. Different tools were used for the investigation of the system\n\ncalls. Some components of the ELF header were used in the research to identify the\n\n37\n\n\n-----\n\ndifference between benign and malicious programs. Proc and memory files were used\n\nto collect the kernel state to determine any malicious activity by the program.\n\n(Cozzi et al., 2018) used the sample collected from the virustotal. They identified the\n\nchallenge associated with the behaviour of malware with different CPU architecture,\n\ndifferent obfuscation techniques. Dynamic linking and shared libraries were also\n\nhighlighted as one of the challenges for malware detection.\n\n### 2.5.5 Zero Day Malware Detection\n\nZero-day malware is an unknown vulnerability that has been exploited and has not been\n\ndetected by anti-malware tools (AMT’s) (Ciancioso et al., 2018). The expanding volume\n\nand assortment of malware postures a genuine security danger to all the computer these\n\ndays and is one of the most worries for the security community for the final few a long\n\ntime (Or-Meir et al., 2019). The conventional security frameworks like Interruption\n\nLocation System/Intrusion Avoidance Framework and Anti-Virus (AV) computer\n\nprograms cannot identify unknown malware as they utilize signatures-based strategies.\n\nIn arrange to illuminate this issue, static and dynamic malware analysis is being utilized\n\nin conjunction with machine learning calculations for malware discovery and\n\nclassification. The biggest issue with these frameworks is that they have elevated wrong\n\nfavourable and wrong negative rates, and the method of building classification\n\ndemonstrated takes time (due to colossal highlight set) which ruins the early discovery\n\nof malware (Gandotra et al., 2017). Hence, the challenge is to choose a significant set\n\nof highlights so that the classification show can be built in less time with more accuracy.\n\nDue to the pros and cons of both static and dynamic malware analysis approaches, it is\n\napparent to know about malware classification. Besides large numbers of false positives,\n\nthe classification modelling takes a long time and thus preventing the early discovery of\n\nmalware. Hence, a pertinent set of features should be selected to build the classification\n\nin less time with more exactness. Feature choice could be a strategy of recognizing best\n38\n\n\n-----\n\npositioned highlights. It identifies the critical features hence making it simple to dispose\n\nof the insignificant ones.\n\nThe anti-malware tool relies on the malware database and, as per the stats, misses one\nthird of malware without having prevention measures (Ciancioso et al., 2018). A method\n\nthat combines rule and algorithm are also challenging to identify zero-day malware. Such\n\nmethods are known as heuristic-based scans, and these methods do not rely on\n\nsignatures. As this method also relies on finding a specific code piece, such a method is\n\nnot adequate for future and evolving malware. If the inquiry does not contain the\n\ninstruction and is unable to read the file or code due to encryption, the malware will be\n\nundetected. There is complex malware that can remain dormant for a specific time before\n\nconducting any damaging work. These days most anti-virus programs use both methods,\n\nincluding traditional signature matching and the heuristic-based, to detect the malware\n\n(Ciancioso et al., 2018).\n\nSandboxing method is also used, which keeps the malicious code in the contained area.\n\nIt is also termed a virtual cage that prevents malware from infecting the existing operating\n\nsystem. The detection of malware activities detected in the sandbox environment is kept\n\nin a centralized database which assists in identifying the variant of the malware. Hence\n\nan application is designed to automatically create a new variant of the malware based\n\non the results of previous malware. It helps in detecting zero-day malware. Hence the\n\nmore variants of malware created in a sandbox increase the possibility of zero-day\n\nmalware detection (Ciancioso et al., 2018). Sandbox alone cannot provide the complete\n\nfoolproof solution for zero-day malware detection; hence, it needs to use other invasion\n\nmethods like stalling code and blind spots. The stalling code runs after the timeout period\n\nand hence help in detecting the malware, which keeps dormant for some time. Sandbox\n\nalso introduces a method called hooking. In this, a notification is generated whenever\n\nany function or library is called. The challenge with this method is that modification is\n\nrequired every time to make it effective.\n\n39\n\n\n-----\n\nFurthermore, to zero-day detection, there is malware that has evolving capabilities such\n\nas polymorphic and metamorphic. Polymorphic malware is difficult to be detected as they\n\nmutate by themselves and also uses encryption techniques has cause challenges in\n\nbeing detected. Metamorphic malware can reprogram automatically each time they are\n\nexecuted or spread in the system. Hence in such categories, signatures will not be\n\ndetected or, due to encryption, the payload cannot be read to detect the malware (Comar\n\net al., 2013).\n\nA supervised classification also uses the known instance of the malware and set the\n\nclassification. It has the same limitation as to the signature-based approach for detecting\n\nthe malware as both cannot detect the new or evolving malware. Also, making a\n\nclassification table is challenging due to diverse malware classes, imbalanced\n\ndistribution and data loss issues. The unsupervised method uses the anomaly detection\n\ntechnique. The significant benefit of this method is the ability to detect zero-day attacks.\n\nThe challenge with this method is the high number of false positives. Hence white\n\nlistening must be applied for the wrongly identified applications (Comar et al., 2013).\n\nNetwork traffic flow can also detect malware behaviour on layer 3 / layer 4 of the OSI\n\nlayer. This method is based on the traffic features such as bytes per second, packets\n\nper-flow and inter-arrival times. The approach is that the statistical flow level features at\n\nlevel 3 or 4 remain the same even if the payload is encrypted. The challenge with this\n\nmethod is that the malware must be detected during the network flow. It also possesses\n\nthe challenge of any new zero-day malware which is not detected as an anomaly.\n\nThe rise of artificial intelligence has also been involved in the cybersecurity space to\n\ndetect malware and reduce false positives. One of the studies proposed a custom log\n\nloss function with beta parameters to the GDBT algorithm to solve the malware detection\n\nproblem. Using a rational approach to evaluate the proposal, they extracted 27 valuable\n\nfeatures from the PE surface analysis FFRI data set. The result shows that the custom\n\nlog loss function can reduce many false positives than a normal log loss function.\n\n40\n\n\n-----\n\nHowever, the custom log loss function increases false negatives compared to the\n\nstandard log loss function, so a hybrid model was used to keep the balance. The\n\nreduction of FPR value with custom log loss function could reduce the priority of false\n\npositives (Gao et al., 2021).\n\n## 2.6 Research Questions\n\nZero-day malware poses a considerable risk as signatures are not available for the anti\nvirus tools to block or remove the malicious files (Gandotra et al., 2017), as elaborated\n\nin the literature review. Multiple techniques are available which requires sandboxing and\n\ninclude dynamic or static malware file analysis techniques. Sandbox technique executes\n\nthe code in the isolated environment to analyse the behaviour of the files and, based on\n\nit, marks it as malicious (Vasilescu et al., 2014). The need is to design a solution to\n\nidentify the malicious files and create a process that shows anomaly behaviour.\n\nHence the research is seeking to answer the following questions:\n\n**Question 1 (Q1) – Which system process on Linux system can detect anomaly**\n\nbehaviour?\n\nUnderstanding the tactics, techniques and procedures of the malicious file to perform\n\nmalware analysis requires a sandbox to analyse the pattern of the file execution (Li &\n\nLiu, 2017). This method identifies the malicious file, which creates the signature for the\n\nfile. The signature update is shared with the threat intelligence available publicly or\n\nprivately through paid subscriptions, leading to multiple anti-viruses to update the\n\ndatabase to block the file in the future. The current signature-based approach will not be\n\nable to detect exploitation by the malicious software for which signatures are not\n\navailable, and hence a process is needed to detect the zero-day malware. One source\n\nof information that detects the malicious file when it executes is the abnormal activity\n\ndetected by active processes. Hence there is a need to create a flow process in which\n\n41\n\n\n-----\n\nthe system process is monitored to detect such anomaly behaviour to identify the\n\nmalware and can be blocked on the run time.\n\n**Question 2 (Q2)- How can YARA rules and antivirus software be integrated after the**\n\nzero-day malware is detected?\n\nAfter the process is detected to identify the malicious file, the next step is to update the\n\nendpoint signature. The most common technique is to triage a malware and then\n\nseparate the likely and unlikely malware. YARA rules are one of the everyday use of\n\nsuch triaging techniques. It identifies using the pattern or string matching, which triggers\n\nthe rule on the matching condition. There are multiple methods available for the YARA\n\nrules detection to reduce the false positive, and one of them is fuzzy hashing (Naik,\n\nJenkins, Savage, et al., 2020). There is a need to make a process that updates the\n\nmalware string and pattern to update the anti-virus signature on the endpoint.\n\nThe literature review leads to a concern to detect zero-day malware analysis, and the\n\nfollowing hypothesis has been generated.\n\n**Hypothesis (H1):**\n\nAbnormal activities on the Linux operating system with the combination of unusual\n\nprocesses and the number of times it repeats is used to detect the anomaly behaviour\n\nof the malicious software exploitation.\n\nThe detection method of the malicious file can be used to integrate YARA rules and\n\nendpoint antivirus tool to update the signature to detect or block the zero-day malware.\n\n.\n\n42\n\n\n-----\n\n# 3. Research Design\n\nThis chapter discusses the design methodology and the purpose of the design decisions.\n\nTo analyse the malware for zero-day detection, it needs to acquire data samples for the\n\nmultiple processes for testing purposes (Jicha et al., 2016). This chapter covers the\n\ntechnique used for collecting the data for zero-day malware detection, and the research\n\nobjective is discussed. This section highlights the method which is used for the detection\n\nof zero-day malware. It also highlights the role of individual components used in the\n\nsetup.\n\n# 3.1 Research Approach\n\nThe following section discusses the approach for setting up the environment to collect\n\nthe data for the investigation to determine the answer to the research questions. The\n\napproach includes collecting the sample malware, briefing the suitable setup\n\nenvironment and the analysis techniques.\n\n### 3.1.1 Sample Malware\n\nMalware researchers look for the sample malware to analyse the threat. One of the\n\nsources is collecting samples of the malware available in the public or private\n\nrepositories. Researchers, anti-malware vendors and different security vendors can\n\nshare the threat intelligence through multiple public available portals. Malware is added\n\nin the portal, which is performed a cryptographic fuzzy hash function to identify if the\n\nnewly added malware is the same as the previously added malware. Few available\n\nrepositories are free to download malware; however, lots of them require some\n\nregistration. Few available repositories include (Zeltser, 2021), (Shipp, 2020) and (Virus\nShare, 2020).\n\n43\n\n\n-----\n\nVirus Share has more than 38,000 malware samples available (Virus-Share, 2020) in the\n\nrepository, which can be used for training or demonstration purposes.  Here the\n\nsignificance is of detecting zero-day malware attacks on the Linux operating system\n\nrather than the number of the malware. The other approach to acquire the sample\n\nmalware is the use of honeypots. In this approach, a dedicated system is configured to\n\nattract the attacker, which gives a good understanding of the recent attacks using the\n\nmalware (Guarnizo et al., 2017). The classification of these malware depends upon the\n\ninteraction permitted (Mairh, Barik, Verma, & Jena, 2011). The level of the malware is\n\ndecided on the level of the interaction with the honeypots. This approach requires a\n\nsandbox technique after the malware is uploaded by the attacker on the honeypot.\n\nSandbox provides the malware analysis of the file and helps to provide the details of the\n\nfile, which help in writing the YARA rule.\n\n### 3.1.2 Design Setup\n\nThe setup involves the following components as shown in the figure 3.1.\n\n44\n\n\n-----\n\n**_Figure 3. 1. Design Setup_**\n\nThe following section elaborates on the components involved in the Lab setup. It details\n\neach component's role in providing the answers to the research questions and testing\n\nthe hypothesis. It provides the details for the components installed on the end-point. It\n\nalso discusses the APIs which interconnects multiple segments of the Lab setup. The\n\nsetup includes the role of the YARA rule and its integration with the end-point. After\n\nhighlighting the roles of different segments, the section analytical method will provide the\n\ncomplete flow process by joining multiple roles throughout the process. At the end of the\n\nchapter summary of the design is presented in the concluding section of this chapter.\n\n45\n\n\n-----\n\n##### 3.1.2.1 End Point Details\n\nThe Linux operating system has multiple different distributions available. For the lab\n\nsetup, CentOS Linux distribution is used. This distribution of Linux is manageable, stable\n\nand predictable (CentOS-Org, 2021). Following table 3.1 shows the operating system\n\nand hardware specs of the test endpoint.\n\n**_Table 3. 1. Endpoint Hardware Architecture_**\n\n**Name** **Version/Model/Size**\nCentos Version 7.6.1810\nCPU Architecture x86_64\nCPU Count 4\nThreads per Core 2\nCore per socket 2\nSocket 1\nVendor ID Genuine Intel\n\nIntel ® Core ™ I5-4300U CPU @\n\nModel Name 1.90GHz\n\nMemory 8GB\n\nThe endpoint is connected to the wireless network with the following local network\n\ndetails:\n\n**_Table 3. 2. Wireless Network Details_**\n\n**Wireless Lan** wlo1\n**Endpoint IP** 192.168.20.19\n**Mask** 255.255.255.0\n**Gateway** 192.168.20.1\n\nThe gateway is the device that provides dual services, including the wireless access\n\npoint, and is also connected to the service provider that connects to the Internet.\n\nThe setup does not have a firewall in front of the Internet-bound traffic; therefore host\nbased firewall is enabled. The CentOS supports the FirewallD service to enable the\n\nfirewall services. The firewall is critical for controlling the traffic flow in and out of the\n\nLinux machine on the network (Carrigan, 2020).\n\n46\n\n|Name|Version/Model/Size|\n|---|---|\n|Centos Version|7.6.1810|\n|CPU Architecture|x86_64|\n|CPU Count|4|\n|Threads per Core|2|\n|Core per socket|2|\n|Socket|1|\n|Vendor ID|Genuine Intel|\n|Model Name|Intel ® Core ™ I5-4300U CPU @ 1.90GHz|\n|Memory|8GB|\n\n|Wireless Lan|wlo1|\n|---|---|\n|Endpoint IP|192.168.20.19|\n|Mask|255.255.255.0|\n|Gateway|192.168.20.1|\n\n\n-----\n\nThe setup is connected to a shared network hence not inherently safe while doing the\n\nmalware testing; therefore, it is mandatory to enable the firewall services on the end\npoint host. Firewalld service provides multiple security levels for different zones. A zone\n\nmust be connected to at least one network interface. The end-point in the setup\n\ncomprises a single wireless LAN card; hence does not require multiple zoning. However,\n\nthe network traffic is controlled by allowing and denying multiple services. Following\n\nfirewall policies are applied on the end-point setup.\n\n**_Table 3. 3. Firewall Security Policy_**\n\n**Source** **Destination** **Destination host /**\n**Zone** **Source host** **Zone** **Network** **Application Policy**\n\nout 192.168.20.19 out any HTTP\nout 192.168.20.19 out any HTTPS\nout 192.168.20.19 out 192.168.20.1 DNS\nout any in 192.168.20.19 all\n\nOnly Internet traffic for HTTP and HTTPS traffic can access the Internet. The DNS is\n\nconfigured to access the local DNS server on the network. All the other inbound traffic is\n\nblocked, including remote management. These controls are strictly applied to avoid any\n\ncompromised attack on the end-point while working on test malware. The deep packet\n\ninspection to check the header of the application is not applicable as the end-point\n\nencrypts and decrypts the HTTPS packet (Carrigan, 2020).\n\nFor the test setup, an open-source end-point antivirus is installed ClamAV AntiVirus. It\n\nis an open-source (GPLv2) antivirus toolkit that has been designed especially for\n\nscanning the emails on the mail gateway, but this antivirus engine provides sufficient\n\nend-point protection for the lab setup. The core engine for the antivirus is the use of the\n\nshared library to update the signature packages. The utilities include a scalable and\n\nflexible multi-thread daemon, which supports the command line to run the scanner. It is\n\nalso equipped with advanced tools to update the databases automatically. It is designed\n\nto scan files, and the real-time protection option, which is only available for the Linux\n\n47\n\n|Source Zone|Source host|Destination Zone|Destination host / Network|Application|Policy|\n|---|---|---|---|---|---|\n|out|192.168.20.19|out|any|HTTP|Allow|\n|out|192.168.20.19|out|any|HTTPS|Allow|\n|out|192.168.20.19|out|192.168.20.1|DNS|Allow|\n|out|any|in|192.168.20.19|all|deny|\n\n\n-----\n\nsystem, made it the first choice to use in the setup. It blocks the file access until the\n\nscanning is completed (Clam-AntiVirus, 2020). This functionality is required to update\n\nthe antivirus signature database. Due to such a feature, this open-source antivirus tool\n\nis used. The antivirus supports the detection of complex malware as it allows to use\n\nbytecode interpreter, which helps the writer of the ClamAV signatures enhance the\n\nremote scanner’s functionality remotely. One of the reasons to choose ClamAV is that\n\nthe platform is available to build and support CentOS7, and the following is the minimum\n\nrequirement for the setup.\n\nMinimum recommended RAM for ClamAV for Linux system includes 2GB of memory\n\nand 1 CPU with a minimum storage of 5GB.\n\nClamAV CVD and CLD database databases have been unpacked in the existing main\n\ninstalled directory. The database archives, including CVD and CLD databases, are\n\nconfigured to work with the custom database. CVD is referred to the database for the\n\nClamAV, whereas CLD files are the uncompressed version of the CVD, which is not\n\nassigned. A custom database is required, which will be used by the interface to update\n\nthe signature of the malicious file. The custom database exists at the location\n\n/usr/local/share/ClamAV. The default location is used to maintain simplicity. Otherwise,\n\nthe alternate path is to be added to run the clamscan. The end-point configuration file is\n\nalso tuned to work as per the setup environment. The file is referred to as DCONF\n\n(Dynamic Configuration). These settings are spread in multiple daily.cfg files. The\n\ncategories which are opened for the test of files includes PE, ELF, DOCUMENT and\n\nPCRE. The other available sample files MACHO, ARCHIVE, MAIL, PHISHING,\n\nBYTECODE, and STATS are not used for testing purposes. ClamAV is also enabled to\n\nuse the Magic number mechanism to determine the type of the file. The file daily.ftm on\n\nthe end-point is adjusted to enable the File Type Magic Signature feature.\n\nThe custom signature created have used these naming conventions, -zipped suffix in the\n\nsignature of the malware file for the file type zmd. For the file type rmd the suffix of \n48\n\n\n-----\n\nrarpwd is used to name the malware signature. The system only allowed to use of\n\nalphanumeric. A dot (.), underscore ( _ ), dash ( - ) and does not have any space, quote\n\nmark or apostrophe. (Clamav-signature-update, 2020). Another important file while\n\nwriting the efficient signature file is the file containing the debug information from\n\nlibclamav. The library is called by calling clamscan debug and leave-temps flags. CASC\n\n(ClamAV Signature Creator) tool is also used to perform reverse engineering in creating\n\nClamAV signatures (The-Talos-Group-AT-Cisco, 2018). The product is not integrated\n\ninto the setup however used for references. This product is a compatible IDA Pro plug\nin.\n\nHTML and Text files are also normalized using “sigtool” for the respective format. The\n\nsigtool is used to pull the libclamv and provides the clamscan, which executes at the\n\nback end.\n\n##### 3.1.2.2 Programming API\n\nAs shown in figure 3.2, different components are interconnected, including database,\n\nantivirus, Virustotal and YARA rules. These components are retrieving and sending data\n\nto interconnected components. Application Programming Interfaces are most commonly\n\nused to collect or send data. The setup is based on the language which is easily\n\naccessible and has readily available interfaces with different components involved in the\n\nsetup. Python is used to perform these tasks, and the version used for the setup is 3.6.8.\n\nThe zero-day malware detection for the setup is based on reading the active process\n\nand doing the necessary recording. For fetching the process details, Python has the built\nin library known as “psutil”. This utility provides the process and system utilities, and it is\n\na cross-platform library for collecting the information for the running processes and the\n\nutilization of systems. The system utilization includes CPU, memory, disk, network,\n\nsensor. The utility also provides monitoring of the system, setting the profiling and limiting\n\nthe process resources. The management of a running process is managed by this utility\n\n(Pypi-org, 2020). The setup is prepared to detect the zero-day malware based on\n\n49\n\n\n-----\n\ndetecting the abnormal process; hence, the prime focus is on the process monitoring\n\nand management. The following essential component is to record the process details. A\n\nprogramming interface is required to update the database tables. Details for the\n\ndatabase table can be referred to in section 3.3.2.3. Python library, which interfaces with\n\nMySQL, is “MySQLdb”. This utility can write again the DB-API compliant MySQL module,\n\nwhich can increase performance. The other component that enables Python is to install\n\nthe MYSQL Python driver (Engel, 2017). Authentication is required for the\n\nPythonaccessing the database. For the lab setup, a local username and password are\n\nused. The integration to threat intelligence is to verify the signatures of the existing\n\nmalware. The Python application programmable interface supports the virustotal. The\n\nlibrary Python uses to integrate virustotal is “virustotal-API”. The integration allows\n\nPython to verify the existing software malware signature using the cryptographic hash\n\nfunction. The integration of the programming interface has a critical component with the\n\nantivirus tool. In the setup, ClamAV integration with the Python API is used. The available\n\nlibrary for antivirus is “pyClamd”. The interface is used to detect the virus for the python\nbased software. The interface is used to update the local database signature of the\n\nantivirus on the end-point after the detection process, as detailed in section 3.3.3. Once\n\nthe signature is updated, the malicious software is deleted or blocked for execution. To\n\ndetect malware and file-based threats, ClamAV relies on the signatures to separate the\n\nclean and malicious files (Clamav-signature-update, 2020). ClamAV signatures are\n\nbased on the text and have to be in a specific signature format. These formats are\n\nsupported and written in the YARA format. The YARA rule is used to automate the\n\nsignature update.\n\nAn API is created using Python to set up the interface. The library used for YARA from\n\nthe Python is (Alvarez, 2021). It covers all the YARA features from compiling, saving and\n\nloading the rules from the scanning files, strings and processes (Alvarez, 2021). The\n\nlibrary is “Yara-python”, which is imported to update the YARA signature. The ClamAV\n\ncollects the signatures in CVD (ClamAV virus Database) files (Clam-AntiVirus, 2020).\n\n50\n\n\n-----\n\nThe CVD file format delivers a digitally signed container that encapsulates the signatures\n\nand confirms that any malicious third party cannot modify them. The signature in the\n\nsetup is actively verified in the public available threat intelligence Talos intelligence.\n\n**_Figure 3. 2. Programmable Interface_**\n\n##### 3.1.2.3 Data Acquisition\n\nThe setup requires a database to save the process information of the operating system.\n\nThe test environment is set up using an open-source version of MySQL under the\n\ngeneral public license. MySql version 8 is installed on the end-point, which is currently\n\nsupported on the OS version of the end-point. The network complexity is avoided by\n\ninstalling the database server on the same end-point. However, the methodology would\n\nwork even with a separate machine. MySQL was available from the portal (MySQL-Dev,\n\n2021). The package name is “mysql80-community-release-el7-3.noarch.rpm”. For\n\nsecurity purposes, default settings like changing the default root password, removing the\n\nanonymous user, disabling remote access for the root user as the DB is installed on the\n\nsame end-point. The process to monitor the data acquisition are system, daemon and\n\nbatch processes, interactive processes and zombie processes. Note that the system is\n\nthe parent of all the processes and is managed by the systemctl.\n\nDaemons are the process that runs continuously in the background and ends with the ‘d’\n\nlike httpd. Batch processes are in the spooler area, where it is executed on a first-in, first\nout basis. The terminal sessions are initialized and control the interactive session. The\n\n51\n\n\n-----\n\nprocess which is closed but still possesses the process ID is referred to as the Zombie.\n\nMultiple commands are considered, including “top” (Table of Process) and “ps” (Process\n\nStatus) to view the process ID (PID) of the active process. Though the top command\n\nruns continuously in the background, it is used as part of the Python script ps command\n\nwith the flag involved “-aux”. The flag provides the information for the user, process ID,\n\nthe percentage of CPU and memory used, start time, and the command execution. The\n\nprogramming interface “psutil” is executed from python. The PS utility is the interactive\n\ncommand that is to be given each time the process is read from the system; therefore, a\n\nrepetitive loop is configured. The selection of schedule is also important after successive\n\ntesting. Keeping large intervals results in losing the critical process information, whereas\n\nkeeping small intervals causes a large number of data. Hence 2 min interval is kept,\n\nwhich executes the PS utility and get the necessary update to populate the information\n\nin the database. The database is created with the table that contains the field for user\n\ndetail, process id, CPU, memory, vs2, RSS, tty, stat, start, time, command, which\n\nincludes all the fields output for the ps -aux output. The insert operation for MySQL\n\ndatabase through Python needs to import the package for MySQL.connector package.\n\nAfter the package is imported, the first step is to establish the connection using\n\nMySQL.connector.connect() method. Username and password are required for the\n\nauthentication, and for this setup, the same root account is used to access the database.\n\nThe database name created is “processed”, which is also called during the connection\n\nphase. A cursor object is created by calling the cursor() method with the connector\n\ndetails. The information is collected from the psutility. The output is inserted into the\n\ndatabase by executing the cursor. Each time values are added to the table, a commit is\n\nrequired in the database.\n\n. 3.1.2.4 VirusTotal Integration\n\nVirustotal integration provides following two services for the setup\n\n52\n\n\n-----\n\n  - Verify the signature of the files which is creating anomaly activity.\n\n  - Update the virustotal if the anomaly detection by the file execution is malicious.\n\nThe programmable interaction with the virustotal is through API version 3. Initially, the\n\nconnectivity test was conducted via version 2, which was updated to version 3 due to\n\nfunctional limitations. The setup has used the premium version of the API integration,\n\nwhich allows the option to give the request rate and the daily quota of 100 requests per\n\nday. Signature files are downloaded from the virusshare site in the JSON format to\n\nvalidate the existing file. The virustotal hunting is included for the retrieval of the YARA\n\nrule notification. The integration has enabled performance property to sample queries\n\nalong with the reverse searches. In the first use case for the setup, to upload the file\n\nlibraries os.path and pprint are also imported. The OS path gives the ability to the Python\n\nto access the file structure of the operating system. The file which is to be tested for the\n\nsignature validation is given to the API call. It returns the JSON response, which details\n\nthe threat intelligence response from the virustotal accumulated from the known vendors\n\nmarking as the threat. Another method used to validate the file is to only send the file ID\n\nin the form of the hash and collect the response in the same way as uploading the file.\n\nThe hash values such as MD5, SHA1, SHA256 and the fuzzy hash of the samples can\n\nbe uploaded. The second use case is to report the file to the virustotal portal, approved\n\nby the admin to be added to the threat intelligence portal. The submitted sample file to\n\nvirustotal automatically go to the sandbox environment, and after doing the analyses, a\n\nverdict is assigned to the file with undetected or suspicious (Virus-total, 2021). The\n\nsample submission date indicates the life cycle of the selected malware. The addition of\n\ndate gives a good indication of the age of the reported malicious software. VirusTotal is\n\nalso used as a threat hunting in this setup, which differs from standard threat\n\nmanagement measures where the approach is reactive than threat hunting (Alvarez,\n\n2021). The report generated by the virustotal has the details with the finding like\n\nundetected, Suspicious, unable to process the file and timeout. The undetected refers to\n\nthe fact that the engine cannot detect any malicious content in the file. The suspicious\n\n53\n\n\n-----\n\nbehaviour raises the flag that the uploaded file is malicious. If the file is not able to\n\nrecognize, then it returns the unable to process response. In unable to process and\n\nTimeout responses virustotal unable to make any verdict (Virus-total, 2021).\n\n##### 3.1.2.5 YARA Rules Update\n\nAfter detecting zero-day malware, the setup is required to answer one of the questions\n\nto integrate the YARA rules and antivirus software, ClamAV. YARA version 3.11.0 is\n\nused for setting up the test environment. This section will discuss the YARA integration\n\nwith the programming API and the signature update procedure for the ClamAV. YARA is\n\naccessed from Python using the Yara-Python library. To support the YARA feature for\n\nthe SSL OpenSSL library is also installed. The Python API is used to verify if the unknown\n\nmalicious instance causing anomaly behaviour belongs to a known malware family or is\n\na novel malware. It also verifies the behaviour feature used to differentiate the instance\n\nof one malware family from those of other families. To differentiate the existing strain\n\nwith the zero-day malware detection listed, the list of existing malware types includes\n\nTrojan, Rootkit, Backdoor, Xfil, Worms, Ransomware and keylogger. It allows the\n\nclassification of the database to identify the category and help mark the category as zero\nday. YARA rules for the existing strain are referred to the GitHub library for the YARA\n\nrules (Yararules, 2021). For the setup, the list of existing malware types is downloaded\n\nfrom the respective git-hub repository and for the initial test manual YARA command was\n\nexecuted to verify the detection of the random dummy files with and without sample\n\nmalware. The exercise is mandatory to validate the impact of the false positive for the\n\nYARA signature. The sample malware and the YARA rules for the signatures are\n\npresented in chapter 4. This validation was also required to justify the load on the end\npoint as YARA rule verification is also performed on the same end-point, which has SQL\n\ndatabase and the Python API interfaces. For the setup, Python is used to call YARA\n\nlibraries to match the identified file with the existing malware families. If the signatures\n\nare not identified, and the file is not classified as malware from the existing matching\n\nrules Python interface is called again to create a YARA rule by analysing the file. The file\n\n54\n\n\n-----\n\nanalysis identifies the critical string to match the signature of the file. Once the signature\n\nmatching patterns are identified Python interface is called again to create the file for the\n\nmatching YARA rule. The last step for YARA rule integration is to update the ClamAV\n\nsignatures. After the rule is created, the ClamAV scan is reinitiated to delete the\n\nmalicious file. A new file is created with the corresponding signature for the specific\n\nsignature type, e.g. .ldb extension for the logical signatures. Then a new own line is\n\nadded for the new signature in the same file. Clamscan is called using the Python\n\ninterface to load the newly added signature. The clamscan is called again using the\n\nPython interface, which updates the local signature database. The format for the\n\nsignature is essential as, during the testing, it will throw an error with the display error in\n\nthe debug file output.\n\n### 3.1.3 Analysis Method\n\nThis section discusses the analysis method used to evaluate if the process flow of the\n\nzero-day malware detection and explains the integration of individual components as\n\nmentioned in the sections on the Linux systems against the sample Linux malware. The\n\nzero-day malware detection process is evaluated against the malware sample collected\n\nfrom the repositories at virustotal and virus share.\n\nFigure 3.3 illustrates the steps in detecting the zero-day malware process.\n\n55\n\n\n-----\n\n**_Figure 3. 3. Process Flow_**\n\nThe process flow was tested to detect the malware behaviour technique by monitoring\n\nthe malicious activity on the end-point. For the analysis of the process for zero-day\n\ndetection, some malware signatures were deliberately removed from the signature\n\ndatabase of the ClamAV tool. The malware was known to be the malicious file, but the\n\naction was taken to verify the effectiveness of the process and to validate the false\n\nnegative of the file detection.\n\n56\n\n\n-----\n\n##### 3.1.3.1 Sample files\n\nSample malware was downloaded from the virus share and virustotal repositories. These\n\nsamples were first downloaded on a sandbox machine with only an Internet connection.\n\nThe files were executed to analyse the behaviour of the malicious file. There are multiple\n\nsandbox solutions available. However, for the setup, the only cuckoo sandbox was used.\n\nCuckoo is also based on the Python library that executes the test sequentially for the\n\nanalysed malware. Its integration with open-source tools like YARA, virustotal, volatility\n\nand support on multiple virtual machine platforms like VirtualBox made it the only choice\n\nfor this setup.\n\nThe identified malware are verified with the YARA rules configuration and the available\n\nsignatures in the ClamAV antivirus. For the setup, the signatures of a few malware files\n\nwere removed from the ClamAV database. This action is required to make the signature\n\nof these malicious files unavailable so that the traditional antivirus is unable to detect\n\nthese files. After going through the process, when the system detects the malicious\n\nbehaviour, the YARA rules can be written, and the programable interface can update the\n\nsignature.\n\n##### 3.1.3.2 Monitoring Process\n\nThe program, when executed, creates a process and has the associated process ID. The\n\nprocess can be a parent or a child process that needs to be monitored when the program\n\nis executed. For the setup, the PS utility is used to identify the usage of the active\n\nprocesses. Python API is calling the ps utility. The sample malware which is identified in\n\nsection 3.3.3.1 is executed as part of the program. The malware was executed one at a\n\ntime to observe the process activities. The process ID, CPU utilization and files execution\n\nthat creates the process is being recorded. The PS utility is the interactive utility therefore\n\niterative script is executed to send the process details at regular intervals. The interval is\n\nscheduled in such a way is to avoid the period when the malicious activity by the process\n\nis skipped during that interval session.\n\n57\n\n\n-----\n\n##### 3.1.3.3 Maintaining Database\n\nThe information is collected in the database to maintain the state of the system\n\nprocesses. The interface is set up to send the process details to the database. The two\n\ncomponents are essential for deployment. First is the database, and second is the\n\ninterface that can collect the details from the system and store them in the database.\n\nMysql is deployed to receive the data input via Python API. Only a single database is\n\ncreated which records the data in a tabular form, and each different field includes process\n\nID, user details, CPU utilization, file path for the executable. The setup has been\n\nexecuted for a limited number of days when the test is to be conducted; therefore,\n\ndatabase purging and achieving is not considered.\n\nThe Logs are flushed regularly with the regular internal command to keep the database\n\nrunning efficiently. The database role is to maintain the information inserted via API for\n\nthe process details. The second API role is to read the data from the same database to\n\npopulate the data for checking the abnormal behaviour, as discussed in section 3.3.3.4.\n\nPython executes the “select” statement to fetch the details. The select statement uses\n\nthe connection.cursor() moreover, cursor.execute() method to retrieve the information.\n\nThe setup authentication is also maintained through the local username-password\n\ndatabase of MySQL. To avoid complexity root account is configured on the API call to\n\naccess the database.\n\n##### 3.1.3.4 Abnormal Behaviour\n\n\nThe data was collected and maintained in the database to detect the abnormal\n\n\nbehaviour in the endpoint. It gives an understanding of the standard machine process\n\n\nbehaviour. In the setup, the data collection was not more than 2 hours. It is a controlled\n\n\nenvironment hence data collection for standard scenarios is not critical. The sample\n\n\nmalware files were executed for both scenarios, scenario1 when known malware is\n\n\nexecuted, and signatures for the ClamAV is available. In this case, the file was blocked\n\n\nby the anti-virus. In the scenario2, known malicious files were executed for which\n\n\n58\n\n\n-----\n\nsignatures were disabled. Different malware had different behaviour on the process IDs\n\nand different abnormal behaviour. The behaviour includes the detection of downloading\n\n\nor installing a trojan which enables the backdoor for remote access. It includes stealing\n\n\nthe credential by downloading software that can install the key logger and transfer the\n\n\nkeylogging to the remote user. The anomaly behaviour may include process injection,\n\n\nwhich can create a copy of the legit application and share the privilege and the memory\n\n\ndetails to the remote attacker. When it comes to analysing the behaviour of malware,\n\n\nthe network activity is also monitored. Because it can be challenging for malicious\n\n\nsoftware to significantly modify its network behaviour and still achieve its objectives,\n\n\nanalysing malware network behaviour may provide an opportunity to identify malware\n\n\non affected hosts. The process requires extracting features from network records and\n\n\nthen creating patterns that help identify malware intrusions. The anomaly behaviour\n\n\ndetects the files and, as per the process, send the file for the verification purpose.\n\n\n##### 3.1.3.5 File verification\n\nThe file verification is first performed by the public threat intelligence repository such as\n\nvirustotal. The API calls uploads the malicious file and validate the malicious content. If\n\nthe file is identified as clean, then the file is requested to virustotal for the sandbox. The\n\nnext step is to update the signature of the identified malicious file. The YARA rule is\n\ncreated for the malicious file, but first, file analysis is done to identify the matching criteria\n\nfor the file. The file analysis includes the identification of the critical pattern which are\n\nrequired to be matched. The pattern varies with the different types of malware files, which\n\nalso depend on the artefact of possible exploits by the malware.\n\n##### 3.1.3.6 Action\n\nThe signature update required the ClamAV to update the database. The clamscan is\n\nexecuted using the API, which detects the malicious file. The action for the setup is to\n\n59\n\n\n-----\n\nkill the associated processes, including parent and child. It then deletes the files from the\n\npath identified in the ps utility output stored in the database.\n\n# 3.2 Conclusion\n\nThe research design was designed to elaborate the process to identify the zero-day\n\nmalware if the signature is not available on the traditional antivirus. It delineated the main\n\nresearch questions and explained the data source of the malware. The sample malware\n\nwas taken from a public repository and signature database. It explained the requirement\n\nto remove signatures from known malware from the local antivirus tool. It has discussed\n\nthe testing procedure and highlighted the research goals in the form of the hypothesis.\n\nThe results-driven in this chapter are presented in chapter 4. The output and the\n\nextracted process are also explained. The analysis results drive the process for zero-day\n\nmalware detection by analysing the process id of multiple program execution and the\n\nupdate of the local antivirus signature using the YARA rule.\n\n60\n\n\n-----\n\n# 4. Results\n\nThe research questions were raised based on the literature review undertaken in chapter\n\n2, highlighting the challenges of detecting zero-day malware files. This chapter presents\n\nthe observations during the experiments conducted as per the design setup in chapter\n\n3. The first section of the chapter provides the details of malware samples used in\n\ninvestigating the process for zero-day malware. The following section provides the\n\ndetails of the sample system process utilisation during the normal scenario. The normal\n\nscenario is referred to as the time when no sample files are executed and the lab setup\n\nmachine is in an idle state. Then, the sample malware files are analysed, and the system\n\nprocess's behaviour with the known and unknown signatures in the antivirus tool. The\n\nsection will also cover the results for the signature update on the antivirus with the\n\nintegration of YARA rules. The last section presents the conclusion driven from the\n\nexperiment results and answers the questions related to the research questions. The\n\nsample files used are known files to observe the method and techniques defined in\n\nchapter 3, and it does not include the detection of false positives.\n\n## 4.1. Sample Files\n\nA total of seventeen (17) sample malware files were extracted from the public portal\n\nhttps://github.com/MalwareSamples/Linux-Malware-Samples.\n\nAnother set of five (5) non-malicious files were also used for the experiment purposes.\n\nThe following section gives an overview of the top five (5) malicious files which were\n\nverified on the virustotal to validate the signature.\n\nFigure 4.1 shows the details of the file when it was uploaded on the virustotal. The file\n\ntype is ELF (Executable and Linkable Format), which is the output of a compiler, and the\n\n61\n\n\n-----\n\nfile format is binary. The file aae58bfd4ad444e778fc71aca23e8ddd.virus was first\n\nsubmitted to virustotal on 15/01/2021, which shows that the malware is relatively new.\n\n**_Figure 4. 1- Sample File 1 Details From VirusTotal_**\n\nFigure 4.2. shows the file details when it was uploaded on the virustotal. The second\n\nsample file type is ELF, and the file was first submitted on 01/17/2021, which is relatively\n\nnew.\n\n62\n\n\n-----\n\n**_Figure 4. 2 - Sample File 2 Details From VirusTotal_**\n\nFigure 4.3. shows the file details when it was uploaded on the virustotal. The third sample\n\nfile type is ELF, and the file was first submitted on 01/11/2021, which is a relatively new.\n\n**_Figure 4. 3 - Sample File 3 Details From VirusTotal_**\n\n63\n\n\n-----\n\nFigure 4.4. shows the file details when it was uploaded on the virustotal. The fourth\n\nsample file type is ELF, and the file was first submitted on 01/12/2021, which is relatively\n\nnew.\n\n**_Figure 4. 4 - Sample File 4 Details From VirusTotal_**\n\nFigure 4.5. shows the file details when it was uploaded on the virustotal. The fifth sample\n\nfile type is ELF, and the file was first submitted on 01/17/2021, which is a relatively new.\n\n64\n\n\n-----\n\n**_Figure 4. 5 - Sample File 5 Details From VirusTotal_**\n\nTable 4.1. summarizes the details of the remaining sample files used during the\n\nexperiment to verify the process for detecting malicious files due to abnormal behaviour.\n\n**_Table 4. 1 List of Other Sample Malware Used in the Lab Setup_**\n\n65\n\n\n-----\n\n|File Name|File Name Used in Experiment|MD5 File Hash|File Size|\n|---|---|---|---|\n|Upx|Sample 6|0b9d850ad22de9ed4951984456e777897 93017e9df41271c58f45f411ef0c3d2|4.97 MB|\n|xor2.exe|Sample 7|10995106e8810a432ebc487fafcb7e4211 00eb8ac60031e6d27c8770f6686b4e|16.8 4 KB|\n|Ybf|Sample 8|1328f1c2c9fe178f13277c18847dd9adb94 74f389985e17126fcb895aac035f2|20.5 3 KB|\n|Roblox|Sample 9|2023eafb964cc555ec9fc4e949db9ba3ec2 aea5c237c09db4cb71abba8dcaa97|25.6 2 KB|\n|eicarstrongp assword.exe|Sample 10|2f0b2160470e2253dc6a5c9cf950962c599 9ee209d0eb0db237a4c630cb34e7a|470. 69 KB|\n|Andy|Sample 11|2f331c4e9e33c2afb8050a9a81a6775542 000e2be810104691eb9fff4981bc56|2.18 MB|\n|Dns|Sample 12|9a7f32e59380deaedad632f1a40697d5ef4 03349f322c502599e99d81bc6dca3|512. 00 KB|\n|XMRIG|Sample 13|00ae07c9fe63b080181b8a6d59c6b3b6f9 913938858829e5a42ab90fb72edf7a|7.71 MB|\n|real_live|Sample 14|03bb1cfd9e45844701aabc549f530d56f16 2150494b629ca19d83c1c696710d7|2.49 MB|\n|Help|Sample 15|04b5e29283c60fcc255f8d2f289238430a1 0624e457f12f1bc866454110830a2|5.47 MB|\n|view_list|Sample 16|0e492a3be57312e9b53ea378fa09650191 ddb4aee0eed96dfc71567863b500a8|49.2 5 KB|\n|unlucky|Sample 17|1ea3dc626b9ccee026502ac8e8a98643c6 5a055829e8d8b1750b2468254c0ab1|37.9 0 KB|\n|keepass|Sample 18|785565ac4cf379c857f97890070e7f82afdf 72f9e65e1a71902732af0fc00110|3.2 MB|\n|harden.bin|Sample 19|9582fec10e6ca488ab506a96dfeb5da56c 9425ca32a8481e060bd06893fb1b3e|250 KB|\n|Npee|Sample 20|61dc901b9962d392d781e07977852d2cbf db8bb58ca337fdc6f12081f33518dc|190 KB|\n|abc.tar|Sample 21|d0711f6d1fd8592385999f7ade4353a695f 802fd96501df6a3e985ca195ab0d2|6.5 MB|\n|unknown|Sample 22|8ea9fc21543e30c773adbcfac3759e8787d e315ac25e2da7f8580cb670f68424|5.5 MB|\n\n\nSelected Sample malware files [Sample 1 – Sample 17] used in the experiment are\n\nalready identified as known malware. The ClamAV antivirus tool used in the lab setup\n\nhas the signature updates available for all the selected samples except sample 5; hence,\n\nit considered all these files malicious. Signatures were removed from the antivirus\n\nsignature database to treat these files as zero-day malware. The only malicious file name\n\n“sample4” signature is kept in the antivirus tool to verify if the process detects the other\n\nmalicious file. Sample files from 18 to 22 are confirmed non-malicious files. Therefore,\n\nno change is required on the antivirus signature database. Files used to experiment\n\n66\n\n\n-----\n\nprocess defined in the research design covers zero-day malware [Sample 1-3, Sample\n\n5-17], known malware [Sample 4] and normal file [Sample 17-22]. The purpose of the\n\nexperiment does not include the detection of false-positive, and the range of samples\n\nare used to verify the effectiveness of the process.\n\n## 4.2. Process Monitoring\n\nIt is essential to record the current usage of the processes in normal situations to detect\n\nthe system's unusual behaviour. The process monitoring is initially required to maintain\n\nthe process information before the manual execution of the malicious file. The process\n\ndetails are stored in the SQL database, which is then used to compare any unusual\n\nprocess usage due to any malicious activity. The baseline usage is set for the experiment\n\nphase. Figure 4.6 is the sample percentage of CPU usage during the usual situation with\n\nthe time interval of 5 min.\n\n#### CPU % Usage\n\n1510:0010:0510:1010:1510:2010:2510:3010:3510:4010:4510:5010:5511:00\n\n10\n\n5\n\n0\n\n**_Figure 4. 6 - % CPU Usage During Normal Situation_**\n\nThe database maintains the process ID, CPU usage and path location for each entry.\n\nThe abnormal usage of CPU utilization for the process ID triggers the alarm to the client\n\nantivirus, which marks the file as malicious. As per the test results in section 4.4, the file\n\nis deleted after the detection. The data collection is for a very limited duration and does\n\nnot include any machine learning capabilities.\n\n67\n\n\n-----\n\nThe process to detect abnormal behaviour requires a baseline to be set. The scope of\n\nthe thesis does not cover the machine learning capability. Therefore, two components\n\nare considered for the abnormal behaviour of the system, which deviates from the\n\nbaseline. These include CPU usage and the number of times the specific file is executed\n\nin a certain time frame. As the purpose of the work does not include any specific machine\n\nlearning technique for abnormal behaviour; therefore, detection of false positives is also\n\nnot considered.\n\n## 4.3. File Analysis\n\n**File 1 – The sample file Y0hWhAUBjQ.virus was copied on the client machine and**\n\nexecuted. During the execution, the CPU utilization went high and figure 4.7 shows the\n\nutilization during the execution. The utilization went high at approx. 10:55 when the file\n\nwas executed.\n\n#### CPU % Usage\n\n10010:4010:4510:5010:5511:0011:0511:1011:1511:2011:2511:30\n\n50\n\n0\n\n**_Figure 4. 7 - % CPU Usage When Sample File 1 Was Executed_**\n\nTable 4.2 shows the process IDs which were active during the file execution phase.\n\n68\n\n\n-----\n\n**_Table 4. 2 - Sample File 1 PID_**\n\n**PID** **Path**\n4586 /tmp/Y0hWhAUBjQ.virus\n4599 New Fork\n4599 bin/sh -e /proc/self/fd/9\n4600 New Fork\n4600 Date\n4601 New Fork\n4601 /usr/bin/python3 /usr/share/abrt/abrt-checkreports --system\n4626 New Fork\n4626 /bin/sh -e /proc/self/fd/9\n4630 New Fork\n4630 Date\n4636 New Fork\n4636 /usr/bin/python3 /etc/libreport\n4653 /bin/sh -e /proc/self/fd/9\n4654 New Fork\n4654 Date\n4663 New Fork\n4663 /usr/bin/python3 /usr/share/abrt\n\nFigure 4.8 refers to the list of process IDs which were generated and forked by the\n\nparents process.\n\n**_Figure 4. 8 - Sample File 1 PIDs Map_**\n\nThe process analysis indicates that the program is executing the directory enumeration.\n\nThe process IDs show the execution of ABRT (automatic bug detecting tool) on the user\n\n69\n\n|PID|Path|\n|---|---|\n|4586|/tmp/Y0hWhAUBjQ.virus|\n|4599|New Fork|\n|4599|bin/sh -e /proc/self/fd/9|\n|4600|New Fork|\n|4600|Date|\n|4601|New Fork|\n|4601|/usr/bin/python3 /usr/share/abrt/abrt-checkreports --system|\n|4626|New Fork|\n|4626|/bin/sh -e /proc/self/fd/9|\n|4630|New Fork|\n|4630|Date|\n|4636|New Fork|\n|4636|/usr/bin/python3 /etc/libreport|\n|4653|/bin/sh -e /proc/self/fd/9|\n|4654|New Fork|\n|4654|Date|\n|4663|New Fork|\n|4663|/usr/bin/python3 /usr/share/abrt|\n\n\n-----\n\nmachine. The tool helps in creating the information of the directory. The malicious file\n\nexecutes the python, which runs the enumeration to identify the list of directories.\n\nSequence of file path were detected during the time of the file execution. The file path\n\nindicates Python distributed package was accessed /usr/local/lib/python3.5/dist\npackages which executed the file path /usr/bin/python3 /usr/share/abrt/abrt-checkreports\n\n–system and started running the report for /usr/bin/python3 /etc/libreport.\n\nTable 4.3 shows the number of times the file paths were executed, which has the\n\nmalicious file.\n\n**_Table 4. 3 - Sample File 1 Path_**\n\n**File Path** **Mode** **Status** **Count**\n/tmp/Y0hWhAUBjQ.virus bits: - usr: -x grp: all: - successful 8\n\n/tmp/Y0hWhAUBjQ.virus bits: - usr: -x grp: all: - successful 10\n\nFigure 4.9 shows the comparison of other file paths accessed while the malicious file\n\nwas executed. The high count of the file execution and the high CPU utilization can be\n\nseen in Figure 4.9 and Figure 4.7.\n\n70\n\n|File Path|Mode|Status|Count|\n|---|---|---|---|\n|/tmp/Y0hWhAUBjQ.virus|bits: - usr: -x grp: all: -|successful|8|\n|/tmp/Y0hWhAUBjQ.virus|bits: - usr: -x grp: all: -|successful|10|\n\n\n-----\n\n**_Figure 4. 9 – Sample File 1 Execution Count_**\n\nAfter the malicious file activity is detected, the next step is to write the YARA rule for the\n\nidentified file. The file location is identified in the/tmp folder. The tool used to detect the\n\nfile type is the hex dump. Figure 4.10 shows the file type information. As mentioned in\n\nsection 4.1 the file type of the first sample is ELF which is confirmed by the hex dump\n\noutput in figure 4.9. The hex value 7f 45 4c 46 confirms the file type (Kessler, 2021).\n\n**_Figure 4. 10 - Sample File 1 Hex dump_**\n\nFigure 4.10 also has the information used from the magic number to set the content to\n\nmatch the YARA rule condition. The following configuration shows three variables\n\nassigned the values: ‘a’, ‘b’ and ‘c’. The first variable, ‘a’ contains the magic number,\n\nwhereas variables ‘b’ and ‘c’ are assigned other values based on the hex dump of the\n\n71\n\n\n-----\n\nremainder of the file. The condition applied that if all the values match in a file that put\n\nthe description as “Sample1 virus file”.\n\n{\n\nMeta:\n\ndesc = “Sample 1 virus file”\n\nstrings:\n\n$a = {7f 45 4c 46 02 01 01 00}\n\n$b= {07 78 49 4d 20 55 7a 49}\n\n$c= {69 31 f6 fd 24 0d 2a 2e}\n\nCondition:\n\n$a and $b and $c\n\n}\n\nThe signature of “sample file 1” is removed from the anti-virus signature database. Figure\n\n4.11 shows the Clam-AV database directory listing to ensure that signature is not\n\navailable before the file execution. Current files shown in the directory are not relevant\n\nand It is only to provide the comparison of the results for the automatic generation of the\n\nsignature before and after the execution of the malicious file.\n\n**_Figure 4. 11 - Sample File 1 AV Directory Listing Before Signature Update_**\n\nThe next step after the YARA rule is created to update the signature of the anti-virus tool.\n\nFigure 4.12 shows the ClamAV database after the YARA signature is updated. An API\n\nis executed written in the Python the to normalize the YARA Rule file automatically and\n\nthen uses the command clamscan --leave-temps --tempdir=mytempdir (Alvarez, 2021).\n\nThe file name Y0hwhAUBjQ.yara is created under the anti-virus signature database.\n\n72\n\n\n-----\n\n**_Figure 4. 12 - Sample File 1 AV Directory Listing After Signature update_**\n\nThe next step is to remove the malicious file from the identified location. API is executed\n\nto run the scan. It is executed on the folder's location, which in this case is at /tmp\n\nlocation. The anti-virus tool has the signature written as a YARA rule to detect the file as\n\nmalicious and remove it from the location. Figure 4.12 shows the scan output, which\n\nindicates that one infected file has been deleted. The end time is the time when the scan\n\nwas completed and the malicious file was deleted. The size of the file indicated in figure\n\n4.13 is the same as the file of the malicious file.\n\n**_Figure 4. 13 - Sample File 1 AV Scan Result_**\n\nIn summary, the malicious sample file one was executed while the process usage, file\n\nand CPU utilization behaviour were monitored. The database contains the information of\n\nprocess ID, CPU utilization, and the file's path executed before and after the malicious\n\nfile execution. The abnormal behaviour of the processor utilization of the file marked the\n\nfile as malicious. The identification allowed to creation of a YARA rule specific to the file.\n\nThe magic number of the file is taken for file identification using the hexdump utility. The\n\nYARA rule signature updated the antivirus signature database. In the end, an antivirus\n\n73\n\n\n-----\n\nscan was executed for the identified malicious path to delete the malicious file. The file\n\nwas removed, and the process monitoring was put back to the normal situation.\n\n**File 2: The sample file pXdN91.x68 was copied on the client machine and executed.**\n\nDuring the executions, the CPU utilization went high and figure 4.14 shows the utilization\n\nduring the execution. The utilization went high at approx. 17:55 when the file was\n\nexecuted.\n\n#### CPU % Usage\n\n100\n\n80\n\n60\n\n40\n\n20\n\n0\n\n17:40 17:45 17:50 17:55 18:00 18:05 18:10 18:15 18:20 18:25 18:30\n\n**_Figure 4. 14 - % CPU Usage When Sample File 2 Was Executed_**\n\nTable 4.4 shows the process IDs which were active during the file execution phase.\n\n**_Table 4. 4 - Sample File 2 PID_**\n\n**PID** **Path**\n4582 /tmp/pXdN91.x68\n4597 New Fork\n4598 New Fork\n\nFigure 4.15 refers to the list of process IDs that were generated and forked by the\n\nparent's process.\n\n**_Figure 4. 15 - Sample File 2 PIDs Map_**\n\n74\n\n|PID|Path|\n|---|---|\n|4582|/tmp/pXdN91.x68|\n|4597|New Fork|\n|4598|New Fork|\n\n\n-----\n\nThe process analysis indicates that the malicious software is trying to get the remote\n\ndiscovery of the system. The remote discovery enables the lateral movement such that\n\nmalicious actors can hop from the compromised machine to the other machine in the\n\nnetwork. The use of the/net/route process identifies that the Remote discovery technique\n\nis used (Stepanic, 2017).\n\nThe sequence of file paths was detected during the time of the file execution. The file\n\npath indicates that multiple processes for route /proc/4582/net/route.\n\nTable 4.5 shows the number of times the file paths were executed, which has the\n\nmalicious file.\n\n**_Table 4. 5 - Sample File 2 Path_**\n\n**File Path** **Mode** **Status** **Count**\n/tmp/pXdN91.x68 bits: - usr: - grp: - all: - successful 1\n\nsuccessful 256\n/tmp/pXdN91.x68 bits: - usr: - grp: - all: \nFigure 4.16 shows the comparison of other file paths accessed while the malicious file\n\nwas executed. The other file was executed only once. That is why not visible in figure\n\n4.16. The high count of the file execution and the high CPU utilization can be verified in\n\nFigure 4.16 and Figure 4.14.\n\n#### Count\n\n300/proc/4582/net/route/proc/4582/net/route/proc/4582/net/route/proc/4582/net/route/proc/4582/net/route/proc/4582/net/route/tmp/pXdN91.x68/tmp/pXdN91.x68/proc/4582/net/route/proc/4582/net/route/proc/4582/net/route\n250\n200\n150\n100\n50\n0\n\n**_Figure 4. 16 – Sample File 2 Execution Count_**\n\n75\n\n|File Path|Mode|Status|Count|\n|---|---|---|---|\n|/tmp/pXdN91.x68|bits: - usr: - grp: - all: -|successful|1|\n|/tmp/pXdN91.x68|bits: - usr: - grp: - all: -|successful|256|\n\n\n-----\n\nAfter the malicious file activity is detected, the next step is to write the YARA rule for the\n\nidentified file. The file location is identified in the/tmp folder. The tool used to detect the\n\nfile type is the hex dump. Figure 4.17 shows the file type information. As mentioned in\n\nsection 4.1, the file type of the second sample file is ELF which is confirmed by the hex\n\ndump output in figure 4.17. The hex value 7f 45 4c 46 confirms the file type (Kessler,\n\n2021).\n\n**_Figure 4. 17 - Sample File 2 Hex dump_**\n\nFigure 4.17 also has the information used from the magic number to set the content to\n\nmatch the YARA rule condition. The following configuration shows three variables\n\nassigned the values: ‘a’, ‘b’ and ‘c’. The first variable, ‘a’ contains the magic number,\n\nwhereas variables ‘b’ and ‘c’ are assigned other values based on the hex dump of the\n\nremainder of the file. The condition applied if all the values match in a file that put the\n\ndescription as “Sample 2 virus file”.\n\nRule sample2\n\n{\n\nMeta:\n\ndesc = “Sample 2 virus file”\n\nstrings:\n\n$a ={7f 45 4c 46 02 01 01 00}\n\n$b={5f 5f 47 49 5f 5f 5f 65 }\n\n$c={74 73 69 64 00 5f 5f 47}\n\n76\n\n\n-----\n\nCondition:\n\n$a and $b and $c\n\n}\n\nThe signature of “sample file 2” is removed from the anti-virus signature database. Figure\n\n4.18 shows the Clam-AV database directory listing to ensure that signature is not\n\navailable before the file execution. Current files shown in the directory are not relevant\n\nand It is only to provide the comparison of the results for the automatic generation of the\n\nsignature before and after the execution of the malicious file.\n\n.\n\n**_Figure 4. 18 - Sample File 2 AV Directory Listing Before Signature Update_**\n\nThe next step after the YARA rule is to update the signature of the anti-virus tool. Figure\n\n4.19 shows the ClamAV database after the YARA signature is updated. The API calls\n\nthe YARA rule file to normalize it automatically and then uses the command clamscan \n-leave-temps --tempdir=mytempdir (Alvarez, 2021). The file name pXdN91.yara is\n\ncreated under the anti-virus signature database.\n\n**_Figure 4. 19 - Sample File 2 AV Directory Listing After Signature update_**\n\n77\n\n\n-----\n\nThe next step is to remove the malicious file from the identified location. API is executed\n\nto execute the scan. It is executed on the folder's location, which in this case is at /tmp\n\nlocation. The anti-virus tool has the signature written as a YARA rule to detect the file as\n\nmalicious and remove it from the location. Figure 4.20 shows the scan output, which\n\nindicates that one infected file has been deleted. The end time is the time when the scan\n\nwas completed and the malicious file was deleted. The file size indicated in figure 4.20\n\nis the same as the file of the malicious file.\n\n**_Figure 4. 20 - Sample File 2 AV Scan Result_**\n\nIn summary, malicious \"sample file two\" was executed while the process usage, file and\n\nCPU utilization behaviour were monitored. The database contains the information of\n\nprocess ID, CPU utilization, and the file's path executed before and after the malicious\n\nfile execution. The abnormal behaviour of the processor utilization of the file marked the\n\nfile as malicious. The identification allowed to creation of a YARA rule specific to the file.\n\nThe magic number of the file is taken for file identification using the hex dump utility. The\n\nYARA rule signature updated the antivirus signature database. In the end, an antivirus\n\nscan was executed for the identified malicious path to delete the malicious file.\n\n**File 3: The sample file bash was copied on the client machine and executed. During the**\n\nexecution, the CPU utilization went high and figure 4.21 shows the utilization during the\n\nexecution. The utilization went high at approx. 20:05 when the file was executed.\n\n78\n\n\n-----\n\n**_Figure 4. 21 - % CPU Usage When Sample File 3 Was Executed_**\n\nTable 4.6 shows the process IDs which were active during the file execution phase.\n\n**_Table 4. 6 - Sample File 3 PID_**\n\n**PID** **Path**\n4582 /tmp/bash\n4596 New Fork\n4597 New Fork\n\nFigure 4.22 refers to the list of process IDs which were generated and forked by the\n\nparents process.\n\n**_Figure 4. 22 - Sample File 3 PIDs Map_**\n\nThe process analysis indicates that the malicious software is trying to get the remote\n\ndiscovery of the system and the masquerading and non-standard port for command and\n\ncontrol tactics of an attack. The remote discovery enables the lateral movement such\n\nthat malicious actors can hop from the compromised machine to the other machine in\n\nthe network. The malicious software sends the traffic to the public IP address on a non\nstandard port. From the details collected from process IDs, the type of attack detected in\n\nthe remote discovery.\n\n79\n\n|PID|Path|\n|---|---|\n|4582|/tmp/bash|\n|4596|New Fork|\n|4597|New Fork|\n\n\n-----\n\nThe sequence of file paths was detected during the time of the file execution. The file\n\npath indicates that multiple processes for route /proc/net/route.\n\nTable 4.7 shows the number of times the file paths were executed, which has the\n\nmalicious file.\n\n**_Table 4. 7 - Sample File 3 Path_**\n\n**File Path** **Mode** **Status** **Count**\n/tmp/bash bits: - usr: - grp: - all: - successful 256\n\nFigure 4.23 shows the comparison of other file paths accessed while the malicious file\n\nwas executed. The high count of the file execution and the high CPU utilization can be\n\ncompared in Figure 4.23 and Figure 4.21.\n\n#### Count\n\n120/proc/net/route/tmp/bash/proc/net/route/proc/net/route/proc/net/route/proc/net/route/proc/net/route/proc/net/route/proc/net/route/proc/net/route/proc/net/route\n\n100\n\n80\n\n60\n\n40\n\n20\n\n0\n\n.\n\n**_Figure 4. 23 – Sample File 3 Execution Count_**\n\nAfter the malicious file activity is detected, the next step is to write the YARA rule for the\n\nidentified file. The file location is identified in the/tmp folder. The tool used to detect the\n\nfile type is the hex dump. Figure 4.24 shows the file type information. As mentioned in\n\nsection 4.1, the file type of the third sample file is ELF which is confirmed by the hex\n\ndump output in figure 4.17. The hex value 7f 45 4c 46 confirms the file type (Kessler,\n\n2021).\n\n80\n\n|File Path|Mode|Status|Count|\n|---|---|---|---|\n|/tmp/bash|bits: - usr: - grp: - all: -|successful|256|\n\n\n-----\n\n**_Figure 4. 24 - Sample File 3 Hex dump_**\n\nFigure 4.24 also has the information used from the magic number to set the content to\n\nmatch the YARA rule condition. The following configuration shows three variables\n\nassigned the values: ‘a’, ‘b’ and ‘c’. The first variable, ‘a’ is assigned the file type hex\n\nvalue, whereas variables ‘b’ and ‘c’ are assigned other random values from the magic\n\nnumber. The condition applied that if all the values match in a file that put the description\n\nas “Sample 3 virus file”.\n\nRule sample3\n\n{\n\nMeta:\n\ndesc = “Sample 3 virus file”\n\nstrings:\n\n$a = {7f 45 4c 46 02 01 01 00}\n\n$b= {6e 65 74 5f 60 64 64 72}\n\n$c= {6e 61 6d 65 00 63 6c 6f}\n\nCondition:\n\n$a and $b and $c\n\n}\n\nThe signature of “sample file 3” is removed from the anti-virus signature database. Figure\n\n4.25 shows the Clam-AV database location to ensure that signature is not available\n\nbefore the file execution. It is to provide the comparison of the results for the automatic\n\ngeneration of the signature before and after the execution of the malicious file.\n\n.\n\n81\n\n\n-----\n\n**_Figure 4. 25 - Sample File 3 AV Directory Listing Before Signature Update_**\n\nThe next step after the YARA rule is created to update the signature of the anti-virus tool.\n\nFigure 4.26 shows the ClamAV database after the YARA signature is updated. The API\n\ncalls the YARA rule file to normalize it automatically and then uses the command\n\nclamscan --leave-temps --tempdir=mytempdir (Alvarez, 2021). The file name bash. Yara\n\nis created under the anti-virus signature database.\n\n**_Figure 4. 26 - Sample File 3 AV Directory Listing After Signature update_**\n\nThe next step is to remove the malicious file from the identified location. API is executed\n\nto execute the scan. It is executed on the folder's location, which in this case is at /tmp\n\nlocation. The anti-virus tool has the signature written as a YARA rule to detect the file as\n\nmalicious and remove it from the location. Figure 4.27 shows the scan output, which\n\nindicates that one infected file has been deleted. The end time is the time when the scan\n\nwas completed and the malicious file was deleted. The file size indicated in figure 4.27\n\nis the same as the file of the malicious file.\n\n**_Figure 4. 27 - Sample File 3 AV Scan Result_**\n\n82\n\n\n-----\n\nIn summary, malicious sample file three was executed while the process usage, file and\n\nCPU utilization behaviour were monitored. The database contains the information of\n\nprocess ID, CPU utilization, and the file's path executed before and after the malicious\n\nfile execution. The abnormal behaviour of the processor utilization of the file marked the\n\nfile as malicious. The identification allowed to creation of a YARA rule specific to the file.\n\nThe magic number of the file is taken for file identification using the hex dump utility. The\n\nYARA rule signature updated the antivirus signature database. In the end, an antivirus\n\nscan was executed for the identified malicious path to delete the malicious file.\n\n**File 4: The sample file x86 was copied on the client machine and executed. During the**\n\nexecution, the CPU utilization went high and figure 4.28 shows the utilization during the\n\nexecution. The utilization went high at approx. 20:05 when the file was executed.\n\n#### CPU % Usage\n\n90\n80\n70\n60\n50\n40\n30\n20\n10\n0\n\n19:4019:4519:5019:5520:0020:0520:1020:1520:20\n\n**_Figure 4. 28 - % CPU Usage When Sample File 4 Was Executed_**\n\nTable 4.8 shows the process IDs which were active during the file execution phase.\n\n**_Table 4. 8 - Sample File 4 PID_**\n\n**PID** **Path**\n4583 /tmp/x86\n4592 New Fork\n4593 New Fork\n4594 New Fork\n4597 New Fork\n\n83\n\n|PID|Path|\n|---|---|\n|4583|/tmp/x86|\n|4592|New Fork|\n|4593|New Fork|\n|4594|New Fork|\n|4597|New Fork|\n\n\n-----\n\n4598 New Fork\n4595 New Fork\n4596 New Fork\n\nFigure 4.29 refers to the list of process IDs which were generated and forked by the\n\nparents process.\n\n**_Figure 4. 29 - Sample File 4 PIDs Map_**\n\nThe process analysis indicates that the malicious software enabled multiple processes,\n\nwhich led to masquerading, operating system credential dumping, remote discovery, and\n\nthe non-standard ports and application layers. The process ID could not track the non\nstandard port and the credential dumping for the operating system. The /proc/net/route\n\nindicates the use of remote discovery, and the execution of /dev/watchdog indicates that\n\nthe code execution was to know about the system details. The /proc/410/maps lead to\n\nmasquerading the ports mapping at the application layer.\n\n**_Table 4. 9 - Sample File 4 Path_**\n\n**File Path** **Mode** **Status**\n\nbits: - usr: - grp: - all: - successful 10\n\n/tmp/x86\n\nFigure 4.30 shows the comparison of other file paths accessed while the malicious file\n\nwas executed. The high count of the file execution and the high CPU utilization can be\n\ncompared in Figure 4.30 and Figure 4.28.\n\n84\n\n|4598|New Fork|\n|---|---|\n|4595|New Fork|\n|4596|New Fork|\n\n|File Path|Mode|Status|Count|\n|---|---|---|---|\n|/tmp/x86|bits: - usr: - grp: - all: -|successful|10|\n\n\n-----\n\n.\n\n**_Figure 4. 30 – Sample File 4 Execution Count_**\n\nAfter the malicious file activity is detected, the next step is to write the YARA rule for the\n\nidentified file. The file location is identified in the/tmp folder. The tool used to detect the\n\nfile type is the hex dump. Figure 4.31 shows the file type information. As mentioned in\n\nsection 4.1, the file type of the second sample file is ELF which is confirmed by the hex\n\ndump output in figure 4.17. The hex value 7f 45 4c 46 confirms the file type (Kessler,\n\n2021).\n\n**_Figure 4. 31 - Sample File 4 Hex dump_**\n\nFigure 4.31 also has the information used from the magic number to set the content to\n\nmatch the YARA rule condition. The following configuration shows three variables\n\nassigned the values: ‘a’, ‘b’ and ‘c’. The first variable, ‘a’ is assigned the file type hex\n\nvalue, whereas variables ‘b’ and ‘c’ are assigned other random values from the magic\n\nnumber. The condition applied that if all the values match in a file that put the description\n\nas “Sample 4 virus file”.\n\nRule sample4\n\n{\n\n85\n\n\n-----\n\nMeta:\n\ndesc = “Sample 4 virus file”\n\nstrings:\n\n$a = {7f 45 4c 46 02 01 01 00}\n\n$b= {6c 30 30 64 00 66 63 6e}\n\n$c= {70 65 5f 74 6f 6c 6f 77}\n\nCondition:\n\n$a and $b and $c\n\n}\n\nThe signature of “sample file 4” is removed from the anti-virus signature database. Figure\n\n4.32 shows the Clam-AV database location to ensure that signature is not available\n\nbefore the file execution. This is to provide the comparison of the results for the automatic\n\ngeneration of the signature before and after the execution of the malicious file.\n\n**_Figure 4. 32 - Sample File 4 AV Directory Listing Before Signature Update_**\n\nThe next step after the YARA rule is created to update the signature of the anti-virus tool.\n\nFigure 4.12 shows the ClamAV database after the YARA signature is updated. The API\n\ncalls the YARA rule file to normalize it automatically and then uses the command\n\nclamscan --leave-temps --tempdir=mytempdir (Alvarez, 2021). The file name x66.yara is\n\ncreated under the anti-virus signature database.\n\n**_Figure 4. 33 - Sample File 4 AV Directory Listing After Signature update_**\n\n86\n\n\n-----\n\nThe next step is to remove the malicious file from the identified location. API is executed\n\nto execute the scan. It is executed on the folder's location, which in this case is at /tmp\n\nlocation. The anti-virus tool has the signature written as a YARA rule to detect the file as\n\nmalicious and remove it from the location. Figure 4.34 shows the scan output, which\n\nindicates that one infected file has been deleted. The end time is the time when the scan\n\nwas completed, and the malicious file was deleted. The file size indicated in figure 4.34\n\nis the same as the file of the malicious file..\n\n**_Figure 4. 34 - Sample File 4 AV Scan Result_**\n\nIn summary, malicious sample file two was executed while the process usage, file and\n\nCPU utilization behaviour were monitored. The database contains the information of\n\nprocess ID, CPU utilization, and the file's path executed before and after the malicious\n\nfile execution. The abnormal behaviour of the processor utilization of the file marked the\n\nfile as malicious. The identification allowed to creation of a YARA rule specific to the file.\n\nThe magic number of the file is taken for file identification using the hexdump utility. The\n\nYARA rule signature updated the antivirus signature database. In the end, an antivirus\n\nscan was executed for the identified malicious path to delete the malicious file.\n\n**File 5: The file execution of the sample4 creates the following process IDs.**\n\n**_Table 4. 10 - Sample File 5 PID_**\n\n**PID** **Path**\n4567 /tmp/sample4\n4576 New Fork\n4576 /tmp/sample4\n\n87\n\n|PID|Path|\n|---|---|\n|4567|/tmp/sample4|\n|4576|New Fork|\n|4576|/tmp/sample4|\n\n\n-----\n\nThe signature of the files was kept on the anti-virus signature database. Therefore, as\n\nsoon as the file was executed, the file was detected and deleted. The file execution of\n\nthe sample file was run in a controlled way in such a way that the anti-virus scan was not\n\nexecuted before the file run. Hence during the run phase, the anti-virus detects the\n\nmalicious behaviour and deletes the file.\n\n**Other Sample Files:**\n\nFigure 4.35 depicts the relationship between the CPU usage and the number of times\n\nthe file is executed. The details of the malicious files is shown in Table 4.1.\n\n**_Figure 4. 35 - Other Sample Files % CPU Usage and Execution Count_**\n\nMultiple files were executed to observe the results to experiment with the automated\n\nprocess as defined in chapter 3. Sample files from 18 to 22 are known non-malicious\n\nfiles. Therefore, no changes were required to update the signature of the endpoint anti\nvirus tool. These results also underwent the same automatic process where the file\n\nexecution detects the abnormal activity, identifies the file, creates the YARA rule to\n\nupdate the antivirus tool. And in the end, the automated API call runs the scan to\n\nquarantine the file.\n\n88\n\n\n-----\n\nThe experiment results above help in answering the following research question.\n\n**Question 1 (Q1) – Which system process on Linux system can detect anomaly**\n\nbehaviour?\n\nDifferent sample files on the Linux system were executed in different time intervals. Two\n\ncategories of sample files were executed. The first category of sample files was known\n\nmalicious; however, signatures were removed from the antivirus tool. Each malicious file\n\nwas executed to analyse the behaviour of the system. It was observed that most of the\n\nfiles in the first category were detected with high CPU utilisation and the number of times\n\nfiles were executed. It followed the same detection criteria as it is defined in section 4.3.\n\nThe abnormal behaviour marked the file as malicious. The next set of sample files was\n\nnormal, and most of the files were undetected as the CPU utilisation did not change\n\ndrastically, nor was the file execution count was high. Discussion on the experiment\n\nresults is explained in chapter 5 which also provides the briefing of the unsuccessful\n\nresults.\n\n**Question 2 (Q2)- How can YARA rules and antivirus software be integrated after the**\n\nzero-day malware is detected?\n\nYARA rules and antivirus tool were integrated to act, so if the file was detected due to\n\nanomaly behaviour could be actioned as the zero-day malicious file. The process flow in\n\nfigure 3.3 indicates that the YARA rule is written automatically using Python script. The\n\nsignature for the antivirus tool is then updated using the YARA rule API integration. The\n\nlast step is to automate the execution of the on-demand antivirus scan, which detects\n\nand delete the malicious file.\n\n# 4.5. Conclusion\n\nThe result has reported multiple processes IDs and the sample file paths executed during\n\nthe experiment phase. The automation process involving API calls at different stages\n\n89\n\n\n-----\n\nwas also presented with the test output. The research questions were also answered\n\nwith the results. The next chapters will focus on the dataset collected during the\n\nexperiment phase and the method's effectiveness to use anomaly process detection to\n\nfind the zero-day malware.\n\n90\n\n\n-----\n\n# 5. Discussion\n\nIn chapter 4, the output of the experiment results was presented driven from the setup\n\nas briefed in chapter 3. This chapter provides the analysis of results collected in chapter\n\n4 and discusses the challenges of zero-day malware detection as outlined in chapter 2.\n\nThe findings in chapter 4 are used to answer the research questions as raised in chapter\n\n3.\n\nThis chapter is divided into two main sections, section 5.2 discusses the sample data\n\nset, and section 5.3 discusses the output of the test results and analyses if the output is\n\nadvanced or contradict as presented in chapter 2. It answers the main research\n\nquestions hence justifying the need for the study.\n\n## 5.1. Sample Data Sets\n\nThe sample malware used in the lab setup is for Linux-based machines' x86 and 64 bits\n\nCPU architecture. The results depend on the types of malware used in chapter 4, as it\n\nhas relied on detecting abnormal behaviour. A range of malware was considered during\n\nthe experiment. Some sample malware were known malware. However, the signatures\n\nof these samples were removed from the antivirus tool due to the lab setup. The other\n\nset of samples were known non-malware to see the effect of the process as defined in\n\nchapter 3. Table 5.1 indicates the score rating for this malware across different threat\n\nintelligence tools which are publicly available. The list indicates the last five sample files\n\nare normal as these files were found to be clean on the threat intelligence websites.\n\n91\n\n\n-----\n\n**_Table 5. 1 - Sample Malware Rating_**\n\n**Reversing**\n**Sample Malware** **JoeSandbox** **VirusTotal** **Metadefender**\n**Lab**\nY0hWhAUBjQ.virus 48/100 24/63 7/37 10/29\n\npXdN91.x68 56/100 31/63 17/37 16/29\n\nbash 64/100 40/63 18/37 20/29\n\nx86 100/100 34/63 17/37 17/29\n\nupx 76/100 61/63 19/37 22/29\n\nxor2.exe 88/100 54/63 27/37 29/29\n\nybf 100/100 45/63 28/37 15/29\n\nroblox 78/100 31/63 14/37 18/29\n\neicarstrongpassword.exe 96/100 33/63 35/37 17/29\n\nandy 86/100 59/63 16/37 21/29\n\ndns 72/100 63/63 18/37 23/29\n\nXMRIG 84/100 57/63 19/37 29/29\n\nreal_live 40/100 45/63 36/37 21/29\n\nhelp 90/100 61/63 14/37 25/29\n\nview_list 76/100 42/63 29/37 29/29\n\nunlucky 68/100 39/63 25/37 13/29\n\nno\nkeepass no record no record no record\nrecord\n\nno\nharden.bin no record no record no record\nrecord\n\nno\nnpee no record no record no record\nrecord\n\nno\nabc.tar no record no record no record\nrecord\n\nno\nunknown no record no record no record\nrecord\n\nThe complex behaviour of the malicious sample files had to be verified with the security\n\nframework mitre att&ck. The following section discusses the behaviour of the malicious\n\nactivity detected by the threat intelligence. The initial discussion explains sample file\n\nbehaviour from third-party malware analysis tools and not the output collected from\n\nchapter 4. The information about the known malware is essential to set the baseline for\n\nthe behaviour. The action ensures that the malicious activity detected by the process\n\ndefined in chapter 3 detects this known malware as malicious files. This security\n\nframework is a publicly available database based on the adversaries of tactics and\n\ntechniques based on real-world examples. The knowledge base is used as a foundation\n\nfor developing specific threat models and methodologies in different security\n\n92\n\n|Sample Malware|JoeSandbox|VirusTotal|Metadefender|Reversing Lab|\n|---|---|---|---|---|\n|Y0hWhAUBjQ.virus|48/100|24/63|7/37|10/29|\n|pXdN91.x68|56/100|31/63|17/37|16/29|\n|bash|64/100|40/63|18/37|20/29|\n|x86|100/100|34/63|17/37|17/29|\n|upx|76/100|61/63|19/37|22/29|\n|xor2.exe|88/100|54/63|27/37|29/29|\n|ybf|100/100|45/63|28/37|15/29|\n|roblox|78/100|31/63|14/37|18/29|\n|eicarstrongpassword.exe|96/100|33/63|35/37|17/29|\n|andy|86/100|59/63|16/37|21/29|\n|dns|72/100|63/63|18/37|23/29|\n|XMRIG|84/100|57/63|19/37|29/29|\n|real_live|40/100|45/63|36/37|21/29|\n|help|90/100|61/63|14/37|25/29|\n|view_list|76/100|42/63|29/37|29/29|\n|unlucky|68/100|39/63|25/37|13/29|\n|keepass|no record|no record|no record|no record|\n|harden.bin|no record|no record|no record|no record|\n|npee|no record|no record|no record|no record|\n|abc.tar|no record|no record|no record|no record|\n|unknown|no record|no record|no record|no record|\n\n\n-----\n\norganisations, including vendors who develop the security products (Stepanic, 2017).\n\nTable 5.2 shows the reference of the sample malware categorisation.\n\n**_Table 5. 2 - Sample Categorization_**\n\n**Sample** **Defense** **Credential** **Command** **Lateral**\n\n**Discovery** **Exfilteration**\n\n**Malware** **Evasion** **Access** **and Control** **Movement**\n\nSecurity\n\nY0hWhAUBj\n\nSoftware\n\nQ.virus\n\nDiscovery\n\nRemote Non\npXdN91.x68 System Standard\n\nDiscovery1 Port1\n\nRemote Non\nbash Masquerading System Standard\n\nDiscovery1 Port1\n\nNonStandard\n\nOS Port11\n\nx86 Masquerading Credential Non\nDumping1 Application\n\nLayer\nProtocol1\n\nData Transfer\n\nupx\n\nSize Limits\n\nInternal\n\nxor2.exe Spearphishi\n\nng\n\nProtocol\n\nybf Impersonati\n\non\n\nFile and\n\nroblox Directory RDP\n\nDiscovery Hijacking\n\nInternal\n\neicarstrongp\n\nSpearphishi\n\nassword.exe\nMasquerading ng\n\nData\n\nandy\n\nObfuscation\n\ndns DNS\n\nExfiltration\n\nXMRIG Over Web\n\nService\n\nInternal\n\nreal_live Spearphishi\n\nng\n\nBypass User\n\nhelp Account\n\nControl\n\nPassword\n\nview_list\n\nCracking\n\nData Transfer\n\nunlucky\nMasquerading Size Limits\n\nkeepass\n\nharden.bin\n\nnpee\n\nabc.tar\n\nunknown\n\nMasquerading may attempt to manipulate their artifact features to make them appear\n\nlegitimate to users and security tools. Masquerading occurs when the name or location\n\nof an object, legitimate or malicious, is manipulated or abused for the sake of evading\n\n93\n\n|Sample Malware|Defense Evasion|Credential Access|Discovery|Command and Control|Lateral Movement|Exfilteration|\n|---|---|---|---|---|---|---|\n|Y0hWhAUBj Q.virus|||Security Software Discovery||||\n|pXdN91.x68|||Remote System Discovery1|Non- Standard Port1|||\n|bash|Masquerading||Remote System Discovery1|Non- Standard Port1|||\n|x86|Masquerading|OS Credential Dumping1||Non- Standard Port11|||\n|||||Non- Application Layer Protocol1|||\n|upx||||||Data Transfer Size Limits|\n|xor2.exe|||||Internal Spearphishi ng||\n|ybf||||Protocol Impersonati on|||\n|roblox|||File and Directory Discovery||RDP Hijacking||\n|eicarstrongp assword.exe|Masquerading||||Internal Spearphishi ng||\n|andy||||Data Obfuscation|||\n|dns||||DNS|||\n|XMRIG||||||Exfiltration Over Web Service|\n|real_live|||||Internal Spearphishi ng||\n|help|Bypass User Account Control||||||\n|view_list||Password Cracking|||||\n|unlucky|Masquerading|||||Data Transfer Size Limits|\n|keepass|||||||\n|harden.bin|||||||\n|npee|||||||\n|abc.tar|||||||\n|unknown|||||||\n\n\n-----\n\ndefences and observation. It may include manipulating file metadata, tricking users into\n\nmisidentifying the file type, and giving legitimate task or service names.\n\nOS Credential Dumping Adversary may attempt to dump credentials to obtain account\n\nlogin and credential material, generally in the form of a hash or a clear text password,\n\nfrom the operating system and software. Credentials can then be used to perform the\n\nlateral movement, and access restricted information.\n\nSecurity software adversary may attempt to get a listing of software and software\n\nversions installed on a system or in a cloud environment. It may use the information from\n\nSoftware discovery during automated discovery to shape follow-on behaviours, including\n\nwhether the adversary thoroughly infects the target and attempts specific actions.\n\nAdversaries may attempt to enumerate software for various reasons, such as figuring\n\nout what security measures are present or if the compromised system has a software\n\nversion that is vulnerable to exploitation for privilege escalation.\n\nNon-application adversaries may use a non-application layer protocol to communicate\n\nbetween host and server or among infected hosts within a network. Examples include\n\nthe use of network-layer protocols, such as the Internet Control Message Protocol\n\n(ICMP), transport layer protocols, such as the User Datagram Protocol (UDP), session\n\nlayer protocols, such as Socket Secure (SOCKS).\n\nThe behaviour of the sample file is essential to understand the technique explained in\n\nchapter 3. It is to confirm the behaviour of the file and the test conducted by the file in\n\nchapter 4 to support the same result. Sample file 5, “sample4”, is used to validate the\n\nmethod explained in chapter 3. It is achieved by keeping the signature of the sample in\n\nthe antivirus to allow it to quarantine the file immediately as it is placed on the end-point.\n\n## 5.2. Research Questions\n\nThe main objective of this study was to get the answers for the following questions:\n\n94\n\n\n-----\n\n##### Question 1 (Q1) – Which system process on Linux system can detect anomaly\n\nbehaviour?\n\n**Answer:**\n\nMultiple processes which create malicious activity on the system can detect anomaly\n\nbehaviour.\n\n**Discussion:**\n\nSample malware was taken, which contains the binaries which targeted the CPU\n\nutilization of the client machine. The CPU utilization was monitored before and after\n\ndifferent sample files were executed during different intervals. Figure 5.1. shows the\n\ncomparison of the CPU utilization compared when different sample files were executed.\n\n**_Figure 5. 1 - Compare % CPU Utilization_**\n\nAs addressed in the literature review, the traditional antivirus uses the signatures-based\n\nsystem to detect the malware on the end-points (Mohanta et al., 2020). In a traditional\n\nenvironment, the malicious software analysis must be completed using static or dynamic\n\ntechniques (Kara, 2019). The results in that setup lead to the creation of the signatures\n\n95\n\n\n-----\n\npopulated on the threat intelligence system. Different vendors utilise feeds to update the\n\ndatabase of the antivirus client installed on the end-point (Mohanta et al., 2020) from the\n\nthreat intelligence. Chapter 2 elaborates the challenge faced by the delay caused in\n\ncreating the signature database of the malicious file as it must go through the entire\n\nanalysis technique. A new malicious file, which does not have the signature, remains\n\nundetected as the antivirus does not have the mechanism to detect the file and treat it\n\nas a threat (Radhakrishnan et al., 2019). It is the risk of zero-day malware, which is new\n\nand do not have the artefact. Chapter 2 elaborates on other techniques as well for the\n\ndetection of zero-day malware. The challenges with the techniques require the\n\nsandboxing technique and analysis of the behaviour. Chapter 3 details the method that\n\ndoes not require a sandbox environment and relies on detecting the malicious activity by\n\ntracking the process behaviour concerning the CPU utilisation, active processes, and the\n\nnumber of times the malicious file was executed. The detection of abnormal behaviour\n\nis based on specific criteria. For the experiment purpose, the CPU usage and the\n\nexecution of a specific count of a particular process would mark the file as malicious. The\n\nfindings of chapter 3 show that if the setup flow is used to implement the track of the\n\nmalicious activity, it will answer question 1 as raised as part of the thesis. When the\n\nsample file was executed Y0hWhAUBjQ.virus, the utilisation of the CPU went high,\n\nFigure 4.7 for reference, during the window, the malicious file was observed to be\n\nexecuted multiple times, and the series of the processes were detected. Table 5.3.\n\nshows the relationship of the process IDs, the file path, and the count section show the\n\nnumber of times the process and the file path were reported during the execution of the\n\nmalicious file.\n\n**_Table 5. 3 - Sample 1 Process ID and the Execution Count_**\n\n**PID** **Path** **Count**\n4586 /tmp/Y0hWhAUBjQ.virus 18\n4599 New Fork 18\n4599 bin/sh -e /proc/self/fd/9 18\n\n96\n\n|PID|Path|Count|\n|---|---|---|\n|4586|/tmp/Y0hWhAUBjQ.virus|18|\n|4599|New Fork|18|\n|4599|bin/sh -e /proc/self/fd/9|18|\n\n\n-----\n\n4626 New Fork 18\n4626 /bin/sh -e /proc/self/fd/9 18\n4630 New Fork 18\n4630 date 18\n4636 New Fork 18\n4636 /usr/bin/python3 /etc/libreport 18\n4653 /bin/sh -e /proc/self/fd/9 18\n4654 New Fork 18\n4654 date 18\n4663 New Fork 18\n4663 /usr/bin/python3 /usr/share/abrt 18\n\nThe test result shows that process IDs are essential, but the way the process is executed\n\nmakes the file malicious. The process analysis indicates that the program is executing\n\nthe directory enumeration. The process ID 4601 show the execution of ABRT (automatic\n\nbug detecting tool) on the user machine. The tool helps in creating the information of the\n\ndirectory. The malicious file executes the Python, which runs the enumeration to identify\n\nthe list of directories. The process ID 4636 indicates execution of the report collection of\n\nthe data gathered by the execution of the ABRT also indicates that information is being\n\ngathered. The process ID associated with this action can be executed in the normal\n\nsituation for locating the file by a regular program and running a report at a specific time\n\nusing the date function; however, the combination of the malicious behaviour, which is\n\ncomprised of the CPU utilization and the number of times the execution of the same\n\nprogram makes it malicious. The abnormal behaviour detected due to the process\n\nexecution has identified the malicious file execution. Table 5.4 shows the summarized\n\nresults for the other sample files used in chapter 4.\n\n**_Table 5. 4 - Process ID and the Execution Count_**\n\nSample File 2 pXdN91.x68\n**PID** **Path** **Count**\n4582 /tmp/pXdN91.x68 257\n4597 New Fork 257\n\n97\n\n|4600|New Fork|18|\n|---|---|---|\n|4600|date|18|\n|4601|New Fork|18|\n|4601|/usr/bin/python3 /usr/share/abrt/abrt-checkreports -- system|18|\n|4626|New Fork|18|\n|4626|/bin/sh -e /proc/self/fd/9|18|\n|4630|New Fork|18|\n|4630|date|18|\n|4636|New Fork|18|\n|4636|/usr/bin/python3 /etc/libreport|18|\n|4653|/bin/sh -e /proc/self/fd/9|18|\n|4654|New Fork|18|\n|4654|date|18|\n|4663|New Fork|18|\n|4663|/usr/bin/python3 /usr/share/abrt|18|\n\n|Sample File 2 pXdN91.x68|Col2|Col3|\n|---|---|---|\n|PID|Path|Count|\n|4582|/tmp/pXdN91.x68|257|\n|4597|New Fork|257|\n\n\n-----\n\n|4598|New Fork|257|\n|---|---|---|\n|Sample File 3 bash|||\n|4582|/tmp/bash|256|\n|4596|New Fork|256|\n|4597|New Fork|256|\n|Sample File 4 x86|||\n|4583|/tmp/x86|10|\n|4592|New Fork|10|\n|4593|New Fork|10|\n|4594|New Fork|10|\n|4597|New Fork|10|\n|4598|New Fork|10|\n|4595|New Fork|10|\n|4596|New Fork|10|\n|Sample File 6 upx|||\n|4569|/tmp/upx|20|\n|Sample File 7 xor2.exe|||\n|4588|/tmp/xor2.exe|30|\n|Sample File 8 ybf|||\n|4859|/tmp/ybf|45|\n|Sample File 9 roblox|||\n|4587|/tmp/roblox|60|\n|Sample File 10 eicarstrongpassword.exe|||\n|4592|/tmp/eicarstrongpassword.exe|12|\n|Sample File 11 andy|||\n|4855|/tmp/andy|35|\n|Sample File 12 dns|||\n|4798|/tmp/dns|11|\n|Sample File 13 XMRIG|||\n|4888|/tmp/XMRIG|55|\n|Sample File 14 real_live|||\n|4898|/tmp/real_live|30|\n|Sample File 15 help|||\n|4987|/tmp/help|55|\n|Sample File 16 view_list|||\n|4590|/tmp/view_list|11|\n|Sample File 17 unlucky|||\n|4592|/tmp/unlucky|60|\n|Sample File 18 keepass|||\n|4000|/tmp/keepass|1|\n|Sample File 19 harden.bin|||\n|4792|/tmp/harden.bin|3|\n|Sample File 20 npee|||\n|4789|/tmp/npee|10|\n|Sample File 21 abc.tar|||\n|4772|/tmp/abc.tar|5|\n\n\n98\n\n\n-----\n\n4789 /tmp/unknown 3\n\nSample File 2 process IDs, file path, and timely execution do not give enough\n\ninformation. The process IDs only indicates the association of the process with the path.\n\nThe process IDs 4597 and 4598 create the new fork and execute the /net/route command\n\neach time. The excessive use of /net/route process as noticed in the sample 2 execution\n\nidentifies that the Remote discovery technique is used (Stepanic, 2017).\n\nAs shown in Figure 5.4, the process opened the path /proc/4582/net/route multiple times\n\nduring the execution of the malicious sample file 2. The process ID 4582 opened multiple\n\nprocesses that run/net/route while utilisation reached approximately 90%. Therefore, the\n\ndata shows that the Table 5.4 sample test with file two can identify the malicious activity\n\nwith the combined activity of CPU usage, process utilisation, and execution count. It\n\nleads to the detection of the zero-day malware with the anomaly behaviour detected by\n\nthe process. The only difference compared to sample 1 is that the process IDs do not\n\ndirectly indicate the abnormal behaviour but the fork processes that initiate the /net/route.\n\nThe /net/route process can be used in the normal situation; however, the execution with\n\nthat large number and the high CPU utilisation marked this file as malicious.\n\nSample file three, same as sample file two, does not give enough information when\n\nexecuted. The execution indicates that the malicious software is trying to get the remote\n\ndiscovery of the system and the masquerading and non-standard port for command and\n\ncontrol tactics of an attack. The remote discovery enables the lateral movement such\n\nthat malicious actors can hop from the compromised machine to the other machine in\n\nthe network. The malicious software sends the traffic to the public IP address on a non\nstandard port. From the details collected from process IDs, the type of attack detected in\n\nthe remote discovery. The process IDs only indicates the association of the process with\n\nthe path. The process IDs 4596 and 4597 creates the new fork and execute the /net/route\n\n99\n\n|Sample File 22 unknown|Col2|Col3|\n|---|---|---|\n|4789|/tmp/unknown|3|\n\n\n-----\n\ncommand each time. As shown in figure 5.4, process ID 4582 opened multiple processes\n\nthat run /net/route while utilisation reached approximately 100%.\n\nTherefore, the data shows that the Table 5.4 sample test with file two can identify the\n\nmalicious activity with the combined activity of CPU usage, process utilisation, and\n\nexecution count. It leads to the detection of the zero-day malware with the anomaly\n\nbehaviour detected by the process. The only difference compared to sample 1 is that the\n\nprocess IDs do not directly indicate the abnormal behaviour but the fork processes that\n\ninitiate the /net/route. It is the same behaviour as seen in the sample file two execution.\n\nThe /net/route process can be used in the normal situation; however, the execution with\n\nthat large number and the high CPU utilisation marked this file as malicious.\n\nThe sample file four execution initiates the process ID 4583, which results in creating\n\nmultiple new forks. The process ID 4592, 4593 and 4595 enables the /net/route, enabling\n\nremote discovery. The process ID 4598 along with /net/route opens the /dev/watchdogs,\n\nwhich supports the remote discovery of the system information. To disguise the\n\noperation, the process IDs 4596 shows that the masquerading is performed with the\n\n/proc/410/maps, which hides the malicious software to be executed in the legitimate\n\nprogram, as shown in figure 4.30. The route, watchdog, and map can be executed in\n\nnormal circumstances, but the combination of the processes, CPU utilisation, and event\n\ncount treated the file as malicious activity.\n\nOverall results from the study indicate that the system's process utilisation can detect\n\nmalicious activities. There are no specific processes to detect zero-day malware.\n\nHowever, the processes which lead to access different file execution as sample1 file\n\nprocesses use ABRT and the libre report with excessive usage which impacts CPU\n\nutilisation, sample file 2 and 3 uses /net/route to executes the remote discovery and\n\nsample file 4 runs the /net/route, watchdog and maps. The impact of the processes\n\ntriggers the malicious activity. The usage of the processes initiated by the files identifies\n\nthe file as malware.\n\n100\n\n\n-----\n\nUnexpected results were detected in two sample files, numbers 9 and 20. It was\n\nobserved that sample file 9 was a confirmed malicious file, as per multiple threat\n\nintelligent repositories, but it did not fall under the abnormal file behaviour. The same\n\nresult was noticed when the confirmed non-malicious sample file 20 was executed. The\n\nutilisation and the process count went high for this non-malicious file. The reason for the\n\nfailed results was due to the detection criteria of the abnormal behaviour. For the lab\n\nsetup, the abnormal behaviour was based on the combination of CPU usage and file\n\nexecution count, but these two sample files did not follow the expected pattern.\n\nThe above discussion derived from the test results in chapter 4 as designed in the setup\n\nexplained in chapter 3 shows that the system can detect zero-day malware by observing\n\nthe anomaly behaviour. The detection can lead to contains zero-day malware. It was\n\nalso observed that a robust mechanism is required to monitor the processes to avoid\n\nfalse positives.\n\n##### Question 2 (Q2)- How can YARA rules and antivirus software be integrated after the\n\nzero-day malware is detected?\n\n**Answer:**\n\nThe detection of the malicious file leads to classifying the file with the information used\n\nto write the relevant YARA rules. The YARA rules can be integrated with the end-point\n\nprotection tool using a programmable application interface to update the signatures. The\n\nprogrammable interface can enable the scan to remove the zero-day malicious file. The\n\nobservation assures that the programmable interface automates the containment of the\n\nmalicious file.\n\n**Discussion:**\n\nThis research question looks for what method is used to remediate the malicious file after\n\nsuch a file is detected. The malicious file detection is performed by the method presented\n\nin the above section in answering question 1. The integration involves the programable\n\n101\n\n\n-----\n\ninterface between the anti-virus tool and the program which writes the YARA rule. The\n\nsolution is to write the YARA tool and the procedure to update the anti-virus signature\n\nlocally on the client machine, as shown in figure 3.3. The first step after identifying the\n\nfile is to take the information of the file, which can be used to identify it. The method used\n\nfor the file classification is the hex dump that runs using a programmable interface which\n\ncalls the Python script. The magic number of the file and other random hex values of the\n\nfiles are used. The information is then called in writing the YARA rules. The steps\n\nexplained in the coming section for the top 4 malware are performed automatically\n\nwithout any manual changes.\n\nTable 5.5 shows the summarized sample YARA rules configured for the first 4 sample\n\nfiles. The variable information $a, $b and $c is extracted from the hex dump tool,\n\nreferenced in Figures 4.10, 4.17, 4.24 and 4.31, respectively.\n\n102\n\n\n-----\n\n**_Table 5. 5 - Sample YARA Rule_**\n\n**Sample 1** **Sample 2** **Sample 3** **Sample 4**\n\n{ {\nMeta: Meta: {\ndesc = “Sample 2 virus desc = “Sample 3 virus Meta:\nfile” file” desc = “Sample 4 virus file”\nstrings: strings: strings:\n$a = {7f 45 4c 46 02 01 01 $a = {7f 45 4c 46 02 01 01 $a = {7f 45 4c 46 02 01 01\n00} 00} 00}\n$b={5f 5f 47 49 5f 5f 5f 65 $b= {6e 65 74 5f 60 64 64 $b= {6c 30 30 64 00 66 63\n} 72} 6e}\n$c={74 73 69 64 00 5f 5f $c= {6e 61 6d 65 00 63 6c $c= {70 65 5f 74 6f 6c 6f\n47} 6f} 77}\nCondition: Condition: Condition:\n$a and $b and $c $a and $b and $c $a and $b and $c\n} } }\n\nThe traditional malware detection tool detects the malicious file based on the availability\n\nof the signatures (Christodorescu et al., 2007), which are prepared by the threat\n\nintelligence by doing the sandboxing of the file (Joseph & Mukesh, 2019). It updates the\n\nsignature database of the antivirus tool. However, the zero-day malware will not have\n\nthe signature updated when detected the first time. The method explained in chapter 3\n\nalso relies on the signature, which is updated using the YARA rule; however, the file\n\ndetection is detected by the abnormal behaviour of the system doing the malicious file\n\nexecution. The research shows that rather than sandbox detects the malicious file the\n\nclient installed on the user machine integrated by the API using the Python in the lab\n\nsetup can write the signatures and update them on the end-point antivirus tool.\n\nAs highlighted the challenge in the literature review section, malware analyst uses the\n\nYARA rule for threat hunting purposes. It allows them to create the YARA rule conditions\n\nmanually and then match them against the malicious files. The process is slow as all the\n\nwork is manual, whereas the technique explained in chapter 3 enables automation. This\n\nexisting technique is part of the static malware analysis where the sample malware is\n\nexamined without the sample file execution and then hash values updates on the threat\n\nintelligent system. The information is then used by the end-point protection tool to act on\n\nthe file accordingly. Chapter 4 results confirm the use of the hex dump to identify the file\n\n103\n\n|Sample 1|Sample 2|Sample 3|Sample 4|\n|---|---|---|---|\n|{ Meta: desc = “Sample 1 virus file” strings: $a = {7f 45 4c 46 02 01 01 00} $b= {07 78 49 4d 20 55 7a 49} $c= {69 31 f6 fd 24 0d 2a 2e} Condition: $a and $b and $c }|{ Meta: desc = “Sample 2 virus file” strings: $a = {7f 45 4c 46 02 01 01 00} $b={5f 5f 47 49 5f 5f 5f 65 } $c={74 73 69 64 00 5f 5f 47} Condition: $a and $b and $c }|{ Meta: desc = “Sample 3 virus file” strings: $a = {7f 45 4c 46 02 01 01 00} $b= {6e 65 74 5f 60 64 64 72} $c= {6e 61 6d 65 00 63 6c 6f} Condition: $a and $b and $c }|{ Meta: desc = “Sample 4 virus file” strings: $a = {7f 45 4c 46 02 01 01 00} $b= {6c 30 30 64 00 66 63 6e} $c= {70 65 5f 74 6f 6c 6f 77} Condition: $a and $b and $c }|\n\n\n-----\n\ntype and use specific parameters in Table 5.3 for the file identification. A similar\n\nchallenge is faced in the case of existing dynamic analysis. The discovery of the file is\n\ntaken place by executing the file in a sandbox environment. The malicious activity\n\nmarking it as malware, the file identification is again used to write the YARA rules, which\n\nmanually helps in either writing the antivirus signature or finding the malicious file\n\nmanually on the system. Compared to the static and dynamic analysis and the file\n\ndetection and action method, the approach explained in chapter 3 is fast to react due to\n\nthe automated API integration with the end-point antivirus tool. The steps explained in\n\nchapter 3 after the file identification include the malicious file classification, writing the\n\nYARA rules using the file classification details, integrating with the end-point antivirus\n\ntool, and using the API call to execute the scan to detect and quarantine the malicious\n\nfile. Python has been used as the application programming interface to execute the list\n\nof steps mentioned above. Other programming tools, node js and ruby language, have\n\nbeen used for the API for the end-point antivirus tool, but these have slower responses\n\nthan Python. They have more computational requirements and security issues.\n\n(Salterwaterc, 2021). The Python library for ClamAV integration gives more flexibility in\n\nterms of usage and the available module as per the required testing in chapter 4\n\n(Grainger, 2021). The main advantage discovered during the lab setup is the availability\n\nof the libraries for Python. The usage has been fast in responsiveness and less memory\n\nintensive. The significant difference with the YARA rule usage with static and dynamic\n\nfile analysis is detecting the zero-day malicious code. The time utilized by the static and\n\ndynamic analysis technique and the manual effort for the file search does not contain the\n\nzero-day malicious file. In contrast, the proposed setup results in chapter 4 use the\n\nabnormal file behaviour by executing the file and marking the file as malicious. Based on\n\nunusual behaviour, in this case, as in chapter 4, high CPU utilization and the count\n\ndetected files can be automatically searched via API and quarantined..\n\n104\n\n\n-----\n\n## 5.3. Automate Threat Intelligence\n\nThe flow for detecting the zero-day malicious file also specifies the action to update the\n\nvirustotal threat intelligence if the file is malicious. The test results have used the existing\n\nknown malware, known to the virustotal threat intelligence as mentioned in section 5.2;\n\ntherefore, the step is not included in the chapter 4 test results. However, the thesis gives\n\nthe functionality to automatically update the virustotal threat intelligence using the\n\nprogramable interface and Python libraries. As per the other techniques mentioned in\n\nchapter 2, the malware analysis techniques have been used to update the signature after\n\ndoing static or dynamic malware analysis, which updates the threat intelligence site,\n\nincluding virustotal. The study shows the framework can be integrated with multiple\n\ncomponents to automate the process from detecting the malicious file execution based\n\non the processor usage. The process usage can cause anomaly activities on the system,\n\nwhich can vary. In our lab set up in chapter 4, the abnormal behaviour comprised the\n\nhigh resource usage and the execution of files not required in a typical scenario. The first\n\nphase of detecting the file and the second phase action on the detected file can be\n\nautomated to quarantine zero-day malware.\n\n## 5.4. Conclusion\n\nChapter 5 has discussed the result collected from the testing as completed in chapter 4.\n\nIt also answered the research questions posed by this study. The result depicts the\n\nmethod and technique to detect zero-day malicious software. The method to integrate\n\nthe YARA rules and the end-point protection was also discussed. The sample malware\n\nused to provide the test results in chapter 4 uses the setup as discussed in chapter 3.\n\nThe chapter concludes the discussion by detecting the abnormal activity on the Linux\n\nsystem for zero-day malware and displays the technique using an application\n\n105\n\n\n-----\n\nprogramable interface to update the YARA rule and end-point anti-virus signature to\n\nremove the zero-day malware.\n\n106\n\n\n-----\n\n# 6. Conclusion\n\nThis chapter concludes the discussion on the technique to evaluate a process to detect\n\nzero-day malware files. The following section gives a brief overview of the previous\n\nchapters. The following section highlight approach's contribution, followed by discussing\n\nsome of the limitations of the research that could have caused some change in the result.\n\nThe last section of the chapter discusses the activities for the following up of this work.\n\n## 6.1. Summary of Research\n\nChapter 1 introduced the topic of zero-day malware detection from the abnormal\n\nbehaviour of the process when the malicious file is executed. It briefly overviews the\n\ncurrent challenges in the existing system to protect end-point from malicious software.\n\nIt also provides an initial discussion about the zero-day malware and the known malicious\n\nfile, which has gone through the proper analysis. It also highlighted the structure of the\n\nthesis work and set the base for the motivation behind this work. Chapter 2 details the\n\nliterature review and the current challenges and security concerns while handling the\n\ncurrent mode of controlling zero-day malware on the Linux systems. It also deep dive\n\ninto the architecture of the Linux operating system and its underlying concepts. It covered\n\nmultiple process calls, including forks, memory architecture and briefly covered the\n\nforensic artefacts. Chapter 2 also discussed the malware and its analysis techniques.\n\nThe current signature-based approach for the end-point protection was detected, and\n\nthe cyber threat intelligence role was overviewed. Chapter 2 ends with the current\n\ntechnology for zero-day malware detection and the challenges highlighted in the current\n\nmodel. It set the foundation to raise the research questions. The research questions were\n\ndriven by the challenges and concerns as indicated in chapter 2.\n\nThe study of similar research work and industry-based framework was assessed to\n\ndefine the methodology and the design. The research design in chapter 3 describes the\n\n107\n\n\n-----\n\nmethod and technique. It reviews the procedure, malware source and the test setup\n\nenvironment. Chapter 3 provides the details for setting up the environment. The\n\napproach defined the test flow and defined the lab setup environment to answers the\n\nresearch question.\n\nIn chapter 4, the test results were presented based on the approach defined in chapter\n\n3. Those test results demonstrated the expected outcome in a controlled environment.\n\nThe result analysis and the finding were discussed in chapter 5. It continued to link the\n\nliterature review and explained the answers to the research questions.\n\n## 6.2. Contribution\n\nThe thesis discusses the method to resolve the problem due to the unavailability of\n\nsignatures for the zero-day malware. Instead of sandboxing the malware for further\n\nanalysis, the technique monitors the operating system malicious file's abnormal activity\n\nand identifies the malware on the system. The deviation of the monitoring data during\n\nthe normal situation and at the time of malicious file execution and the processes\n\nutilisation triggers the malicious file and its location on the system. The second phase of\n\nthe thesis covers the procedure to remove the malicious file after detection using multiple\n\nprogramable interfaces. The malicious file signature is written after detecting the\n\nabnormal behaviour method using YARA rules which automatically remove the malware\n\nfrom the system by integrating with the anti-virus tool.\n\n## 6.3. Limitation\n\nThis section discusses some of the items which have impacted the outcome of the\n\nresearch. Some of the factors might have changed the result and the techniques which\n\ncould have been improved.\n\n108\n\n\n-----\n\n### 6.4.1 System Requirements\n\nThe client endpoint is based on the specific distribution of the Linux operating system.\n\nDifferent distribution has different system files and libraries, which can impact the\n\ndetection mechanism of the processes that generate abnormal behaviour on the system.\n\nPython program is written based on the operating system's libraries and the dependency\n\nlimits the scope of the testing. The programmable interfaces will vary depending on the\n\nCPU architecture as different CPUs have different opcodes for the instruction set. Hence\n\nthe bytes to be detected in the YARA rule might be different. The programmable\n\ninterfaces created for the monitoring of the processes on the systems would have been\n\ndifferent. The coding language has to use different libraries for the integration to collect\n\nthe information as different versions of Operating System may use different system\n\nlibraries. If multiple distributions were used and variations of programmable interfaces\n\nwritten in multiple programming languages, then detecting the zero-day malware based\n\non the abnormal process execution would have been a more successful result.\n\n### 6.4.2 End-Point Protection\n\nThe open-source version of end-point protection is used, which supported the\n\nprogramable interface to integrate signature updates on the anti-virus installed on the\n\nclient machine. The YARA rule used on the end-point has a simplistic approach and\n\nmight have impacted complex file types. The configuration of the programable interface\n\nto push the signatures generated by the YARA rule to automate the process to remove\n\nthe malicious file would vary on the supported version of the end-point. It has a\n\ndependency on the available supporting library of the programming language used to\n\nwrite the API. The open-source version supported removing the available signature set\n\nfrom the client machine, which enabled the test setup. The lab environment would not\n\nhave provided the test result with the existing sample malware data set if the client end\n109\n\n\n-----\n\npoint would not have allowed updating the signature. However, the other option of honey\npot setup to collect the malicious malware would have required a strict environment.\n\n### 6.4.3 Sample Malware for Data Set\n\nA different set of malwares might have impacted the outcome of the test results. The\n\nselected malware resulted in the system's high CPU utilisation and the execution of\n\nmultiple processes. The result was tested only on the limited numbers of sample files.\n\nMore samples would have provided a different variation of how they operate and might\n\nhave impacted the test result outcome. The malware selected in the test setup is known\n\nmalware and is used in the test setup by disabling the signatures on the existing anti\nvirus tool. The malware used was not zero-day malware as the signatures were already\n\navailable. Due to this reason, a programable interface to update the virustotal could not\n\nbe tested. The sample malware is also limited to the specific operating system\n\narchitecture, and different variations would have generated different results..\n\n### 6.4.4. Detection Criteria\n\nThe detection criteria to monitor the processor utilization does not include the machine\n\nlearning. The lab setup monitors the CPU usage and the number of times the file is\n\nexecuted to detect abnormal behaviour. Even though two results failed from the expected\n\ndetection behaviour, the result might have been different with more tests. Also,\n\nconsidering the memory utilization as the detection criteria and the CPU would have\n\nimpacted the lab results. However, the detection process would have been more\n\neffective if the detection criteria included the combined monitoring of CPU, memory, and\n\nmachine learning component.\n\n110\n\n\n-----\n\n## 6.4. Future Work\n\nDifferent areas can be driven forward from this research. One of the areas is IoT systems\n\nsecurity. IoT systems architecture needs to be explored to detect abnormal malware\n\nactivities. The research will also be required to understand the malware behaviour for a\n\ndifferent variation of IoT architecture. The abnormal behaviour on the system processes\n\ncan impact network performance for the devices connected to the same network. Hence,\n\nthe thesis can also enhance the work on analysing abnormal network behaviour if\n\nmultiple systems are involved in an abnormal activity.\n\nThe other area which can be focused on is the study of false-positive detection using the\n\napproach for detecting and removing the malicious file based on the abnormal behaviour.\n\nThe action taken is based on the active device and not on the sandbox. This work will\n\nstrengthen the method and technique used in this research.\n\nMultiple programmable interfaces are configured to perform the different tasks at\n\ndifferent stages. A work to consolidate the diverse task in one client agent can\n\nconsolidate and increase the efficiency of the method.\n\nThe chapter concludes that the detection of zero-day malware is essential with the\n\nemerge of new techniques to exploit the vulnerabilities of the Linux based operating\n\nsystem. The sample malware was tested on the active client machine, which was not\n\nsandboxed, and observed abnormal behaviour. The deviation of the client machine from\n\nthe expected behaviour detects the malicious file. The detection is also based on the\n\nprocessor utilization and the undesired process file execution. The detection of the file\n\nand updating the end-point protection to remove the malicious file also enables the\n\nautomated process.\n\nTotal twenty-two sample malware was used to test the method and technique to detect\n\nthe zero-day malware activity, and most of the time, the system was able to detect the\n\nmalicious file. The method and technique defined in chapter 3 can determine the zero\n111\n\n\n-----\n\nday malware by robust monitoring detection processes to identify abnormal behaviour,\n\nwhich can be automated to remove the malicious file.\n\n112\n\n\n-----\n\n# References\n\nAkram, B., & Ogi, D. (2020). The Making of Indicator of Compromise using Malware\n\nReverse Engineering Techniques. 7th International Conference on ICT for Smart\n_Society: A IoT for Smart Society, ICISS 2020 - Proceeding, 2–7._\nhttps://doi.org/10.1109/ICISS50791.2020.9307581\n\nAlvarez, V. M. (2021). VirusTotal/ yara-python. Github. Retrieved from\n\nhttps://github.com/VirusTotal/yara-python\n\nStepanic, D. (2017). Remote System Discovery. Mitre Attack. Retrieved from\n\nhttps://attack.mitre.org/techniques/T1018/\n\nBaker, K. (2019). What is Cyber Threat Intelligence? [Beginner’s Guide]. Crowdstrike.\n\nRetreived from https://www.crowdstrike.com/epp-101/threat-intelligence/\n\nBoukhtouta, A., Mokhov, S. A., Lakhdari, N. E., Debbabi, M., & Paquet, J. (2016).\n\nNetwork malware classification comparison using DPI and flow packet headers.\n_Journal of Computer Virology and Hacking Techniques, 12(2), 69–100._\nhttps://doi.org/10.1007/s11416-015-0247-x\n\nCarrigan, T. (2020). A beginner’s guide to firewalld in Linux. Redhat. Retrieved from\n\nhttps://www.redhat.com/sysadmin/beginners-guide-firewalld\n\nCentOS-Org. (2021). CentOS. Retrieved from https://www.centos.org/about/\n\nChen, X., Sha, E. H. M., Jiang, W., Zhuge, Q., Chen, J., Qin, J., & Zeng, Y. (2016). The\n\ndesign of an efficient swap mechanism for hybrid DRAM-NVM systems.\n_Proceedings of the 13th International Conference on Embedded Software,_\n_EMSOFT 2016. https://doi.org/10.1145/2968478.2968497_\n\nChristodorescu, M., Jha, S., Maughan, D., Song, D., & Wang, C. (2007). Malware\n\nDetection [book]. In Journal of Chemical Information and Modeling (Vol. 53, Issue\n9).\n\nCiancioso, R., Budhwa, D., & Hayajneh, T. (2018). A framework for zero day exploit\n\ndetection and containment. Proceedings - 2017 IEEE 15th International\n_Conference on Dependable, Autonomic and Secure Computing, 2017 IEEE 15th_\n_International Conference on Pervasive Intelligence and Computing, 2017 IEEE 3rd_\n_International Conference on Big Data Intelligence and Compu, 2018-Janua, 663–_\n668. https://doi.org/10.1109/DASC-PICom-DataCom-CyberSciTec.2017.116\n\nClam-AntiVirus. (2020). ClamAV. Retrieved from\n\nhttps://www.clamav.net/documents/introduction\n\nClamav-signature-update. (2020). Creating signatures for ClamAV. ClamAV. Retrieved\n\nfrom https://www.clamav.net/documents/creating-signatures-for-clamav#creatingsignatures-for-clamav\n\nComar, P. M., Liu, L., Saha, S., Tan, P. N., & Nucci, A. (2013). Combining supervised and\n\nunsupervised learning for zero-day malware detection. Proceedings - IEEE\n_INFOCOM, 2022–2030. https://doi.org/10.1109/INFCOM.2013.6567003_\n\n113\n\n\n-----\n\nCozzi, E., Graziano, M., Fratantonio, Y., & Balzarotti, D. (2018). Understanding Linux\n\nMalware. Proceedings - IEEE Symposium on Security and Privacy, 2018-May,\n161–175. https://doi.org/10.1109/SP.2018.00054\n\nCrowdstrike. (2021). Zero-day Attack Explained. Crowdstrike. Retrieved from\n\nhttps://www.crowdstrike.com\n\nDamri, G., & Vidyarthi, D. (2016). Automatic Dynamic Malware Analysis Techniques For\n\n_Linux Environment. 67, 825–830._\n\nDmitry, M., & Elena, P. (2020). Linux Privilege Increase Threat Analysis. Proceedings \n_2020 Ural Symposium on Biomedical Engineering, Radioelectronics and_\n_Information Technology, USBEREIT 2020, 579–581._\nhttps://doi.org/10.1109/USBEREIT48449.2020.9117739\n\nEngel, D. (2017). Configure development environment for pymssql Pythondevelopment.\n\nhttps://docs.microsoft.com/en-us/sql/connect/python/pymssql/step-1-configuredevelopment-environment-for-pymssql-python-development?view=sql-serverver15\n\nEwais, M. A., Omran, M. A., Raafat, A., & Alkabani, Y. (2016). A virtual memory\n\narchitecture to enhance STT-RAM performance as main memory. Canadian\n_Conference on Electrical and Computer Engineering, 2016-Octob._\nhttps://doi.org/10.1109/CCECE.2016.7726657\n\nFox, R. (2014). Linux with Operating System Concepts. In Linux with Operating System\n\n_Concepts. https://doi.org/10.1201/b17269_\n\nGandotra, E., Bansal, D., & Sofat, S. (2017). Zero-day malware detection. Proceedings \n_2016 6th International Symposium on Embedded Computing and System Design,_\n_ISED 2016, 171–175. https://doi.org/10.1109/ISED.2016.7977076_\n\nGao, Y., Hasegawa, H., Yamaguchi, Y., & Shimada, H. (2021). Malware Detection Using\n\nGradient Boosting Decision Trees with Customized Log Loss Function.\n_International Conference on Information Networking, 2021-Janua, 273–278._\nhttps://doi.org/10.1109/ICOIN50884.2021.9333999\n\nGrainger, T. (2021.). Clamd 1.0.2. pypi. Retrieved from https://pypi.org\n\nJicha, A., Patton, M., & Chen, H. (2016). SCADA honeypots: An in-depth analysis of\n\nConpot. IEEE International Conference on Intelligence and Security Informatics:\n_Cybersecurity and Big Data, ISI 2016, 196–198._\nhttps://doi.org/10.1109/ISI.2016.7745468\n\nJoseph, L., & Mukesh, R. (2019). To Detect Malware attacks for an Autonomic Self-Heal\n\nApproach of Virtual Machines in Cloud Computing. 5th International Conference\n_on Science Technology Engineering and Mathematics, ICONSTEM 2019, 220–_\n231. https://doi.org/10.1109/ICONSTEM.2019.8918909\n\nKara, I. (2019). A basic malware analysis method. Computer Fraud and Security, 2019(6),\n\n11–19. https://doi.org/10.1016/S1361-3723(19)30064-8\n\nKerrisk, M. (2010). The Linux Programming Interface.\n\nKessler, G. (2021). GCK File Signature Table. Garykessler. Retrieved from\n\n114\n\n\n-----\n\nhttps://www.garykessler.net\n\nKim, J., Min, C., Kim, J., Kang, D. H., Kim, I., & Eom, Y. I. (2014). Page allocation scheme\n\nfor anti-fragmentation on smart devices. 2014 IEEE 3rd Global Conference on\n_Consumer Electronics, GCCE 2014, 512–513._\nhttps://doi.org/10.1109/GCCE.2014.7031168\n\nKlaus, T., & Elzweig, B. (2020). The impact of data breaches on corporations and the\n\nstatus of potential regulation and litigation. Law and Financial Markets Review,\n_14(4), 255–260. https://doi.org/10.1080/17521440.2020.1833432_\n\nKo, S., Jun, S., Ryu, Y., Kwon, O., & Koh, K. (2008). A new Linux swap system for flash\n\nmemory storage devices. Proceedings - The International Conference on\n_Computational Sciences and Its Applications, ICCSA 2008, 151–156._\nhttps://doi.org/10.1109/ICCSA.2008.54\n\nLi, M., & Liu, J. (2017). How can Advanced Sandboxing Techniques Thwart Elusive\n\n_Malware? Trend Micro Security News._\nhttps://www.trendmicro.com/vinfo/us/security/news/security-technology/how-canadvanced-sandboxing-techniques-thwart-elusive-malware\n\nLiu, L., Li, Y., Ding, C., Yang, H., & Wu, C. (2016). Rethinking Memory Management in\n\nModern Operating System: Horizontal, Vertical or Random? IEEE Transactions on\n_Computers, 65(6), 1921–1935. https://doi.org/10.1109/TC.2015.2462813_\n\nLove, R. (2010). Linux Kernel Development.\n\nLungana-Niculescu, A. M., Colesa, A., & Oprisa, C. (2018). False positive mitigation in\n\nbehavioral malware detection using deep learning. Proceedings - 2018 IEEE 14th\n_International Conference on Intelligent Computer Communication and Processing,_\n_ICCP 2018, 197–203. https://doi.org/10.1109/ICCP.2018.8516611_\n\nMartin, I., Hernandez, J. A., De Los Santos, S., & Guzman, A. (2018). Analysis and\n\nevaluation of antivirus engines in detecting android malware: A data analytics\napproach. Proceedings - 2018 European Intelligence and Security Informatics\n_Conference, EISIC 2018, 7–14. https://doi.org/10.1109/EISIC.2018.00010_\n\nMcafee. (2021). What Is Endpoint Security?. Mcafee. Retrieved from\n\nhttps://www.mcafee.com/\n\nMehdi, S.B., Tanwani, A.K., Farooq, M. (2009). IMAD: In-execution malware analysis and\n\n_detection._\n\nMohanta, A., Saldanha, A., Mohanta, A., & Saldanha, A. (2020). Antivirus Engines. In\n\n_Malware Analysis and Detection Engineering. https://doi.org/10.1007/978-1-4842-_\n6193-4_22\n\nMySQL-Dev. (2021). MySQL Community Downloads. Retreived from\n\nhttps://dev.mysql.com/downloads/repo/yum/\n\nNaik, N., Jenkins, P., Cooke, R., Gillett, J., & Jin, Y. (2020). Evaluating Automatically\n\nGenerated YARA Rules and Enhancing Their Effectiveness. 2020 IEEE\n_Symposium Series on Computational Intelligence, SSCI 2020, 1146–1153._\nhttps://doi.org/10.1109/SSCI47803.2020.9308179\n\nNaik, N., Jenkins, P., Savage, N., Yang, L., Naik, K., Song, J., Boongoen, T., & Iam-On,\n\nN. (2020). Fuzzy Hashing Aided Enhanced YARA Rules for Malware Triaging.\n\n115\n\n\n-----\n\n_2020 IEEE Symposium Series on Computational Intelligence, SSCI 2020, 1138–_\n1145. https://doi.org/10.1109/SSCI47803.2020.9308189\n\nNothaas, S., Beineke, K., & Schoettner, M. (2019). Optimized memory management for a\n\nJava-based distributed in-memory system. Proceedings - 19th IEEE/ACM\n_International Symposium on Cluster, Cloud and Grid Computing, CCGrid 2019,_\n668–677. https://doi.org/10.1109/CCGRID.2019.00086\n\nOr-Meir, O., Nissim, N., Elovici, Y., & Rokach, L. (2019). Dynamic malware analysis in the\n\nmodern era—A state of the art survey. ACM Computing Surveys, 52(5).\nhttps://doi.org/10.1145/3329786\n\nPypi-org. (2020). psutil. https://pypi.org/project/psutil/\n\nRadhakrishnan, K., Menon, R. R., & Nath, H. V. (2019). A survey of zero-day malware\n\nattacks and its detection methodology. IEEE Region 10 Annual International\n_Conference, Proceedings/TENCON, 2019-Octob, 533–539._\nhttps://doi.org/10.1109/TENCON.2019.8929620\n\nSalterwaterc, K. (2021.). NodeJS Clamscan Virus Scanning Utility. Npmjs. Retrieve from\n\nhttps://www.npmjs.com\n\nShah, K., & Singh, D. K. (2016). A survey on data mining approaches for dynamic\n\nanalysis of malwares. Proceedings of the 2015 International Conference on Green\n_Computing and Internet of Things, ICGCIoT 2015, 495–499._\nhttps://doi.org/10.1109/ICGCIoT.2015.7380515\n\nShahzad, F., Bhatti, S., Shahzad, M., & Farooq, M. (2011). In-execution malware\n\ndetection using task structures of Linux processes. IEEE International Conference\n_on Communications, 0–5. https://doi.org/10.1109/icc.2011.5963012_\n\nShahzad, F., Shahzad, M., & Farooq, M. (2013). In-execution dynamic malware analysis\n\nand detection by mining information in process control blocks of Linux OS.\n_Information Sciences, 231, 45–63. https://doi.org/10.1016/j.ins.2011.09.016_\n\nShipp, R. (2020). Online Scanners and Sandboxes. https://github.com/rshipp/awesome\nmalware-analysis#online-scanners-and-sandboxes\n\nShotts Jr, W. E. (2012). The linux command line: {A} complete introduction.\n\nStazi, G., Menichelli, F., Mastrandrea, A., & Olivieri, M. (2017). Introducing approximate\n\nmemory support in Linux Kernel. PRIME 2017 - 13th Conference on PhD\n_Research in Microelectronics and Electronics, Proceedings, 97–100._\nhttps://doi.org/10.1109/PRIME.2017.7974116\n\nTanenbaum, A. S., & Bos, H. (2014). Modern Operating Systems. In Education (Vol. 2).\n\nhttp://www.amazon.com/dp/0136006639\n\nThe-Talos-Group-AT-Cisco. (2018). ClamAV Signature Creator. Retrieved from\n\nhttps://github.com/Cisco-Talos/CASC\n\nVasilescu, M., Gheorghe, L., & Tapus, N. (2014). Practical malware analysis based on\n\nsandboxing. Proceedings - RoEduNet IEEE International Conference, 1–6.\nhttps://doi.org/10.1109/RoEduNet-RENAM.2014.6955304\n\nVirus-Share. (2020). Virus Share. https://virusshare.com/\n\n116\n\n\n-----\n\nVirus-total. (2021). VirusTotal Reports. Retrieved from\n\nhttps://support.virustotal.com/hc/en-us/articles/115002719069-Reports\n\nWagner, M., Fischer, F., Luh, R., Haberson, A., Rind, A., Keim, D. A., & Aigner, W.\n\n(2015). A Survey of Visualization Systems for Malware Analysis. Eurographics\n_Conference on Visualization (EuroVis), 105–125._\nhttp://mc.fhstp.ac.at/sites/default/files/publications/wagner_2015_eurovis_star_mal\nwarevis_postprint_reduced.pdf\n\nWu, K., Ge, Y., Chen, W., & Zhang, T. (2012). The research and implementation of the\n\nLinux process real-time monitoring technology. Proceedings - 4th International\n_Conference on Computational and Information Sciences, ICCIS 2012, 1046–1049._\nhttps://doi.org/10.1109/ICCIS.2012.342\n\nYararules. (2021). Yara Rules Project. Retrieved from https://github.com/Yara-Rules/\n\nYaswinski, M. R., Chowdhury, M. M., & Jochen, M. (2019). Linux security: A survey. IEEE\n\n_International Conference on Electro Information Technology, 2019-May, 357–362._\nhttps://doi.org/10.1109/EIT.2019.8834112\n\nYildiz Çavdar, Z., AVCI, İ., KOCA, M., & SERTBAŞ, A. (2019). A Survey of Hybrid Main\n\nMemory Architectures. Sakarya University Journal of Science, 1–1.\nhttps://doi.org/10.16984/saufenbilder.334645\n\nZeltser, L. (2021). Free Automated Malware Analysis Sandboxes and Services.\n\nKizza, J., & Migga Kizza, F. (2011). Intrusion Detection and Prevention Systems.\n\nSecuring the Information Infrastructure, 239–258. https://doi.org/10.4018/978-159904-379-1.ch012\n\n117\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/2022-02-25 - Behavior Anomaly on Linux Systems to Detect Zero-day Malware Attacks.pdf"
    ],
    "report_names": [
        "2022-02-25 - Behavior Anomaly on Linux Systems to Detect Zero-day Malware Attacks.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1676772308,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1649273056,
    "ts_modification_date": 1651493410,
    "files": {
        "pdf": "https://archive.orkl.eu/51aead123abd4e157b086cfd84223aae4c2f50f8.pdf",
        "text": "https://archive.orkl.eu/51aead123abd4e157b086cfd84223aae4c2f50f8.txt",
        "img": "https://archive.orkl.eu/51aead123abd4e157b086cfd84223aae4c2f50f8.jpg"
    }
}