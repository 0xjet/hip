{
    "id": "6d860dd2-d2f5-44bf-b04b-01e4de9b23a3",
    "created_at": "2022-10-25T16:48:18.798946Z",
    "updated_at": "2025-03-27T02:05:48.112803Z",
    "deleted_at": null,
    "sha1_hash": "c5355707644b6948069345e2e8bac429e39f882d",
    "title": "W64/Regin, Stage #1",
    "authors": "F-Secure",
    "file_creation_date": "2014-12-09T07:34:51Z",
    "file_modification_date": "2014-12-09T07:34:52Z",
    "file_size": 400883,
    "plain_text": "# Malware Analysis  Report\n\n## W64/Regin, Stage #1\n\n### TLP: WHITE\n\n\n###### Contents\n1. Introduction\b 2\n2. General information\b 2\n3. Hiding technique\b 3\n3.1 Mimicking a valid Microsoft Dynamic Link Library\b 3\n3.2 The certificate\b 4\n4. Malware analysis\b 6\n4.1 Deployment and startup\b 6\n4.2 Content retrieval\b 6\n4.2.1 The virtual machine and its meta-language\b 7\n4.3 Content loading and mapping\b 11\n4.3.1 The QuickPeParse64 function\b 12\n4.3.2 Headers, Sections and Imports\b 13\n4.3.3 Relocations\b 14\n4.4 Payload invocation\b 14\n4.5 Cleanup\b 15\n5. Conclusions\b 16\n\n\n#### ABSTRACT\n\nIn this document we describe the inner\nworkings of the stage #1 of the complex\nmalware threat by the name of Regin,\nspecifically the version targeted at 64-bit\nmachines running the Microsoft Windows\noperating system.\n\nPaolo Palumbo\nSenior Researcher\nSecurity Response\nF-Secure Labs\nTwitter: @paolo_3_1415926\n\nContact\nF-Secure Incident Response\n[irt@f-secure.com](mailto:irt@f-secure.com)\n\n\n-----\n\n##### 1. Introduction\n\nIn this document we present the results of our analysis of a sample of Regin’s stage #1 for 64-bit machines; the document\nwill focus on a number of different items, both high and low level in nature. We will cover items such as the main purpose\nof the sample; the virtual machine used to retrieve and process the raw payload, with its implementation and its metalanguage; the sample’s strategy to remain unnoticed and avoid raising suspicions.\n\n##### 2. General information\n\nThe analysis in this document is based on the a sample received by F-Secure Labs with the following SHA1:\n\n**SHA1: 5191d7e28ffd1bc76ec7ed02d861679a77f2c239**\n\nAn examination of the static properties of the file reveals that the file is a 64-bit Dynamic Link Library for the Microsoft\nWindows operating system. The file’s PE headers provide also the following interesting information:\n\n1. The creation time of the file is 19:37:07, 25.11.2011 according to the PE header’s TimeDateStamp field.\n\n2. The linker version is set to 9.00. This is consistent with Visual Studio 2008 Orcas, initially released in 2007.\nDespite not being the latest version of Microsoft’s development tools available at the moment of the\n(suspected) compilation of the DLL, Visual Studio 2008 is able to generate x64 binaries. This might hint at the\nfact that this binary was produced using an existing development framework as part of an existing operation.\n\n3. The binary appears to be digitally signed by Microsoft. The digital signature will be further considered in\nsection 4, but it is at this point interesting to note that the validity range of the certificate does encompass the\nbinary creation date as specified in the PE header. Keeping in mind that the adversary has done a tremendous\neffort in camouflaging this binary, it is reasonable to assume that the binary was indeed produced at the time\nspecified by the PE header.\n\n4. The DLL exports 16 functions, which are simply forwarders for functions exported by wshtcpip.dll, a standard\ncomponent of Microsoft Windows. These exports will be considered again in section 4.\n\nThe analysis of the sample’s strings, in combination with the symbols specifically imported from other modules, hint at the\nfact that the sample we have analyzed might interact at a low level with physical drives of the machine it is running on. For\nexample, the string PRIVHEAD is a strong indicator that the sample might have some knowledge of Microsoft Windows’\nLogical Disk Manager (LDM); in fact, such PRIVHEAD is the expected magic value for LDM’s PRIVATE_HEADER structures.\nProper malware analysis presented in section 4 will confirm these suspicions.\n\nFinally, the string ’\\\\.\\<WINDOWS>’ is particularly interesting. The format of the string, specifically the ’WINDOWS’\nsubstring between angular brackets, is an indication of a strong connection between this sample and 32-bit samples\nof stage #1 of the complex threat named Regin; in fact, samples of Regin’s 32-bit stage #1 used a similar format to mark\nstrings that needed expansion.\n\n\n-----\n\n###### /,\n\n##### 3. Hiding technique\n\nWe could simply say that the 64-bit version of Regin’s stage #1 hides in plain sight. In fact, in contrast with most malicious\nsoftware, this component is not packed or protected in any way from code inspection and reverse engineering. Instead,\nits structure is designed to fool investigators and users of a victim machine into believing that the malware is simply\nanother standard component of the operating system. Two particular aspects of the sample structure will be covered in\ndetail in sections 3.1 and 3.2.\n\n###### 3.1 Mimicking a valid Microsoft Dynamic Link Library\n\nFrom the DLL’s export table and version information, we can see that the original name of the module is wshnetc.dll.\nThis name is strongly reminescent of the other winsock-related system libraries that can be found on a clean Windows\ncomputer, in the system folder. Moreover, a victim would not be surprised to see that the description of this particular\nmodule is Winsock 2 Helper DLL (TL/IPv4).\n\nIn general, the characteristics highlighted above in conjunction with the remainder of the file properties would make up\nfor a very convincing decoy even for a technically astute victim. The file properties as they would be presented to the user\nare shown in Figure 1.\n\nFigure 1: Visualizing the properties of the sample\n\nLooking again at the export table, we notice that the sample exports 16 different functions, which are exactly the same\nthat are exported by Windows’ own wshtcpip.dll. The sample does not provide the implementation of these functions, but\nit simply forwards the exports to wshtcpip.dll in the remote case that someone would try using these functions. The list of\nsymbols exported by the sample is reported in Listing 1.\n\nListing 1: Symbols exported by the sample\n\nwshnetc.dll : WSHAddressToString\nwshnetc.dll : WSHEnumProtocols\nwshnetc.dll : WSHGetBroadcastSockaddr\nwshnetc.dll : WSHGetProviderGuid\n\nContinues overleaf\n\n\n-----\n\nContinued\n\nwshnetc.dll : WSHGetSockaddrType\nwshnetc.dll : WSHGetSocketInformation\nwshnetc.dll : WSHGetWSAProtocolInfo\nwshnetc.dll : WSHGetWildcardSockaddr\nwshnetc.dll : WSHGetWinsockMapping\nwshnetc.dll : WSHIoctl\nwshnetc.dll : WSHJoinLeaf\nwshnetc.dll : WSHNotify\nwshnetc.dll : WSHOpenSocket\nwshnetc.dll : WSHOpenSocket2\nwshnetc.dll : WSHSetSocketInformation\nwshnetc.dll : WSHStringToAddress\n\nIt is then clear that the authors of this malware have spent a considerable amount of time camouflaging their creation as a\nsystem file. If we consider that it is probable that the sample would be located inside the system folder on a compromised\nsystem, it is very easy to see how its techniques might be very effective. Moreover, effectively stealing the exported\nfunctionalities from a different system module might deceive even a victim with a strong technical background.\n\n###### 3.2 The certificate\n\nThe authors of this sample have also digitally signed the malware, with the intent to give it additional credibility and to\nmake it look as if it was a Microsoft file. Keeping in mind the what was said about sample’s exports in section 3.1, it is even\nmore likely that with the digital signature they were trying to camouflage the sample as a legitimate Microsoft Windows\nsystem file.\n\nThe Authenticode signature is, in itself, valid, but the certificate properties (shown in Figure 2), highlight the inability of\nthe system to find and validate the issuer of this certificate. The certificate’s validity period is from 15/7/2011 to 14/10/2012;\nthe fact that the compilation timestamp from the file’s PE header is inside this range makes us believe that the binary was\nindeed built on November 25th, 2011. Moreover, combining the alleged compilation time and the certificate validity range,\nwe can speculate that this binary was probably updated regularly.\n\nThe issuer of the certificate is an alleged Microsoft Root Authority. This name resembles a valid Microsoft issuer, but if we\nfocus on the KeyID we find that such entry does not match any of the known Microsoft Root Authority IDs. Details about\nthe supposed issuer of the certificate are presented below.\n\nKeyID=41 68 26 6a 16 60 0f 36 41 19 af 06 f9 54 4d 06\nCertificate Issuer:\nCN=Microsoft Root Authority\nOU=Microsoft Corporation\nOU=Copyright (c) 1997 Microsoft Corp\nCertificate SerialNumber=0c ea ea 19 bb bd 4f 86 4e b7 e9 47 97 cf 74 a8\n\nIt is also interesting to notice that, while the malware claims to be signed by Microsoft, the certification path does not\nshow the same structure of proper Microsoft-signed binaries; specifically, there is a lack of an intermediary before\nMicrosoft’s Root Certificate Authority (CA). The certification path for the malware versus the one from a valid Microsoftsigned binary is shown in Figure 3. It is likely that the authors of this threat have used standard signing tools to create such\na certificate hierarchy; they then deployed the signed binary in combination with the root certificate.\n\n\n-----\n\n###### /,\n\nFigure 2: Inspecting the certificate properties\n\nFigure 3: The certificate (left) does not follow the customary approach followed by Microsoft. A proper Microsoftsigned binary is shown on the right for comparison\n\nRegin’s 64-bit stage #1 component is not the first piece of malware pretending to be signed by Microsoft. What is more\ninteresting to consider is how this particular certificate might have been useful to keep the sample operating under the\nradar on a compromised machine.\n\n\n-----\n\n##### 4. Malware analysis\n\nIn this section we will detail the results of the analysis of Regin’s 64-bit stage #1 component. Based on our analysis of the\nmalware’s functionalities, the sample can be considered a support module — its sole purpose is to facilitate the operation\nof additional user-mode, 64 bit modules by loading and transferring control to them.\n\nThe malware’s payload is stored on the disk of the infected machine, in a specific location among the gap between the\nend of the last partition [[1]] and the end of the disk itself. Such payload is read by the malware, possibly decrypted and\ndecompressed, mapped into memory and given control to. To be usable, the payload must be another 64-bit usermode\nDLL, with at least a symbol exported by ordinal. Once the payload completes its duty, Regin’s 64-bit stage #1 component\ncarefully removes all traces of its presence by overwriting memory areas before freeing them.\n\nFrom our analysis of the sample, it is clear that whoever has created this piece of malware is a professional developer with\na solid experience, with detailed knowledge of low-level and Windows’ security concepts.\n\nIt is also clear that Regin is a complex threat. What we have seen of Regin hints strongly at capabilities that extend beyond\nthe realm of normal malware: support for basically the whole set of Microsoft NT-based operating systems, including\nnewer, 64 bit versions; appropriately selected techniques to remain unseen on compromised systems; ability to support\ngeneric payloads; professional code. Everything from these samples leads us to believe that Regin is been used as part of\nan extensive operation.\n\n###### 4.1 Deployment and startup\n\nAt the time of writing, it is not known how the Regin 64-bit samples are deployed to target systems; our analysis of the\nsample’s interactions with the system show that the the sample is no different from any other Dynamic Link Library. We\ntherefore believe that Regin’s 64-bit stage #1 samples are installed and made persistend as any other Dynamic Link Library.\n\n###### 4.2 Content retrieval\n\nThe malware will attempt to retrieve the its payload from the victim computer’s hard drive. The retrieval is performed\naccording to the specifications contained in a meta-program embedded in the malware’s body, which initially lies\nencrypted inside the malware body. Very early in the execution the malware will decrypt the retrieval program, and\nexecute it to fetch the possible payload from the infected system.\n\nThe reconstructed program for the malware’s virtual machine is presented in Algorithm 1, while the details of the virtual\nmachine implementation and of its language will be presented in detail in section 4.2.1.\n\nAlgorithm 1: Payload retrieval program embedded in the analyzed sample\n\n**begin**\nid = 1;\ndecryption_key = [0xA4, 0x4B, 0xAE, 0xF0, 0x98, 0x4C, 0x56, 0x33];\noutput_buffer_size = 0xB600;\nOPERATION_TYPE_LOAD(id);\nOPERATION_TYPE_DECRYPT(decryption_key);\nOPERATION_TYPE_DECOMPRESS(output_buffer_size);\n**end**\n\n\n-----\n\n###### /,\n\n 4.2.1 The virtual machine and its meta-language\n\nThe sample is designed to retrieve, map and execute a payload from a previously infected system; the payload is a PE32+\nDLL for Microsoft Windows. How such payload is retrieved and what transformations are applied to it are controlled by\na meta program for a simple virtual machine that is embedded in the malware. The malware will locate and decrypt this\nprogram from its own body as the first step in attempting to find and load its payload.\n\nThe structure of a program written for this Virtual Machine is presented in Listing 2.\n\nListing 2: Structure of a program for the virtual machine\n\ntypedef struct VMProgram {\nQWORD dqField_0 ;\nDWORD ddField_8 ;\nDWORD ddPayloadSize ;\nDWORD ddField_10 ;\nDWORD ddSizeOfCode ;\nVM_OPCODE voProgramCode [ ] ; // Variable sized array containing\n// the sequence of operations that\n// the VM needs to execute\n} VMProgram;\n\nThe structure of a program for this custom virtual machine is relatively simple, as it consists of what we believe to be a\nsmall header and of a sequence of operations. While the program’s header is still largely undocumented [[2]], the purpose\nof each of the opcodes has been completely discovered. The set of virtual machine operations in the code embedded\nin the sample we analyzed does not include any conditional instruction, which partially accounts for the simplicity of the\nprogram structure.\n\nEach instruction of the virtual machine is characterized by a few fields and is optionally followed by enough space to hold\na variable sized input argument. The format of an opcode is presented in Listing 3.\n\nListing 3: Structure of an individual operation for the virtual machine\n\n#define OPERATION_TYPE_LOAD 1\n#define OPERATION_TYPE_DECRYPT 2\n#define OPERATION_TYPE_DECOMPRESS 3\n#define OPERATION_TYPE_CLEAN 4\n\ntypedef struct VMOpcode {\nBYTE dbOperationType ;\nBYTE dbField_1 ;\nDWORD ddVe r s ionInformat ion ; // Suspected\nDWORD ddSizeOfIncomingArguments ;\nBYTE dbArgument [ ] ; // Variable sized array containing the\n// (optional) argument to the opcode\n} VMOpcode ;\n\n[2] The sample we analyzed neither accessed most of this header at any point during execution nor referenced it anywhere in its\ncode,making it impossible to completely reconstruct this structure's fields. We were however able to infer the meaning of some\n\n\n-----\n\nThe Virtual Machine in itself is also very simple. Beside the handlers, the virtual machine provides only a few facilities:\n\n1. A counter that gets decreased as the program’s various opcodes are consumed.\n\n2. A pointer to the payload, which is what will be returned in case of termination of the program. This pointer\nalways points towards the current state of the payload.\n\n3. A pointer to an auxiliary memory buffer that is used when performing transformations over the payload. This\npointer can be imagined as pointing to the previous version of the payload\n\n4. A variable that holds the current size of the payload.\n\nEach handler is responsible for performing its own parsing of the (possible) input arguments, executing the operation\nand advancing to the next operand by skipping the appropriate amount of bytes. The main virtual machine loop has been\nhighlighted in Figure 4.\n\nFigure 4: Overall structure of the main loop for the virtual machine\n\nBelow we present the description of the operations supported by the virtual machine.\n\n**OPERATION_TYPE_LOAD**\nThe most important operation carried out by the Virtual Machine is OPERATION_TYPE_LOAD. Such operation is the only\nmandatory operation, as it is the only moment in which the malware accesses any form of storage on the infected system;\nthis means that OPERATION_TYPE_LOAD provides the malware’s only way to retrieve its payload. OPERATION_TYPE_\nLOAD receives as an argument an id which is used to verify the payload possibly hidden on the disk.\n\nThe retrieval of the content begins with the malware trying to retrieve the physical location of the volume that\ncontains the operating system, specifically the %WINDOWS% directory. The retrieval of the path to the Windows\nfolder is performed through the Windows’ API GetWindowsDirectoryA and before that, via a convoluted custom\nstring expansion subroutine. Specifically, the malware contains code that parses entries between angular brackets\n(’<’ and ’>’) and tries to replace the item between these markers with the appropriate value. The particular sample\ndescribed in this document supports the following strings: <system>, <temp>, <windows>, <common> and <program>.\nIn addition to the items specified above, the malware has the abilities of passing entries between ’%’ characters to the\n**ExpandEnvironmentStrings Windows API. This same string expansion routine was encountered in samples of Regin’s 32-**\nbit stage #1 samples, further confirming the link between these malware samples.\n\n\n-----\n\n###### /,\n\nOnce the correct disk has been identified, the malware proceeds to obtain a handle to it and starts looking for its payload.\nOn infected systems, the payload will be stored in the gap area between the end of the partition that is physically farthest\nfrom the beginning of the disk and the end of the disk itself. To move to the right location, the malware needs to have an\nunderstanding of those low-level structures that allow calculating start and end offsets of the various partitions; examples\nof these structures are MBR, EBR and GPT. Some systems and partitions are not supported, like those that implement\nlogical disk management (LDM).\n\nOnce the malware has identified the correct location on the disk, it will attempt to find a marker structure at the\nbeginning of the gap space. The format of this structure is presented in Listing 4. The field Id of MarkerStructure is\nmatched against OPERATION_TYPE_LOAD’s operand to partially ensure the validity of the block. Once this has been\nverified, a ddSize number of bytes is read; the CRC32 of the read bytes is calculated and its value matched against the value\nof the field CRC32 contained in the marker structure. If both checks are successful, then the buffer is considered valid, and\nis made available to the virtual machine for further processing.\n\nListing 4: Marker structure for Regin’s 64-bit stage #1 payload\n\n/* \u0003 size of (MarkerStruct ) = 0xC \u0003* /\ntypedef struct MarkerStruct {\nDWORD ddId ;\nDWORD ddSize ;\nDWORD ddCRC32 ;\n}   MarkerStruct ;\n\n**OPERATION_TYPE_DECRYPT**\nThe payload that the malware needs to retrieve and load might need to be decrypted. In order to support this scenario,\nthe virtual machine that handles the retrieval and transformation of the payload into a PE file image provides an\nOPERATION_TYPE_DECRYPT opcode. The pseudo-code for the decryption algorithm is provided in Listing 5.\n\nListing 5: Reconstructed C version of the decryption routine\n\nbool __fastcall DecryptBuffer (BYTE \u0003* pdbKey, BYTE \u0003* pdbBuffer, DWORD ddBufferLength,\nBYTE \u0003\u0003\u0003* \u0003* ppdbBufferOut, DWORD \u0003\u0003* pddBufferOutLen,\nbool \u0003\u0003* pbSuccess )\n{\nbool bResult ;  // r10@1\nDWORD ddInitialBackOffset ; // eax@7\nunsigned __int64 i ; // r8@9\nBYTE \u0003* pdbRoundKey ; // rsi@10\nunsigned int ddInnerCounter ; // ebp@12\nDWORD p8ByteBlockIterator ; // edi@12\nchar dbOffsetsLowByte ; // cl@14\nBYTE \u0003* pByteToDecrypt ; // rdx@14\n__int64 ddInKeyCounter ; // rax@14\n\nbResult = 0 ;\n\nContinues overleaf\n\n\n-----\n\nContinued\n\n// Check pointer validity\nif ( pdbKey && pdbBuffer && pdbSuccess &&\nddBufferLength > 0 && bDecryptedMalwareConfig )\n{\n// Check the length of the encrypted buffer to calculate\n// the initial starting position for the decrypted loop\nif ( ddBufferLength & 7 )\nddInitialBackOffset = ddBufferLength & 7 ;\nelse\nddInitialBackOffset = 8 ;\n\n// Begin decryption of the buffer\nfor ( i = ddBufferLength - ddInitialBackOffset ;\n( unsigned int ) i < ddBufferLength ;\ni = ( unsigned int ) ( i - 8 )  )\n{\npdbRoundKey = pdbKey ;\n\nif ( i & 0xFFFFFFF8 )\npdbRoundKey = &pdbBuffer [ i - 8 ] ;\n\nddInnerCounter = 0 ;\np8ByteBlockIterator = i ;\n\ndo\n{\n// If out of buffer boundaries, exit loop\nif ( p8ByteBlockIterator >= ddBufferLength )\nbreak ;\n\ndbOffsetsLowByte = i + ddInnerCounter++ ;\n\npByteToDecrypt = &pdbBuffer [ p8ByteBlockIterator ] ;\n\nddInKeyCounter = p8ByteBlockIterator++ & 7 ;\n\n       - pByteToDecrypt ^= dbOffsetsLowByte ^ pdbRoundKey [ ddInKeyCounter ] ;\n}\nwhile ( ddInnerCounter < 8 ) ;\n}\n\n     - [ppdbBufferOut = pdbBuffer ; ]\nbResult = TRUE ;\n\n     - [pddBufferOutLen = ddBufferLength ;]\n\n     - [pbSuccess = TRUE ;]\n}\nreturn bResult ;\n}\n\n\n-----\n\n###### /,\n\nOPERATION_TYPE_DECRYPT receives as input argument the decryption key to be used. The length of the decryption key\nis hardcoded to 8 bytes.\n\nIt might be of interest to the reader that the decryption functionality is not exclusively used for the payload, but also by\nRegin’s 64-bit stage #1 itself to decrypt the virtual machine program that it carries in its own body, albeit with a different\ndecryption key.\n\n**OPERATION_TYPE_DECOMPRESS**\nOne of the commands of the virtual machine is used to decompress data from one buffer into another. In the sample that\nwas analyzed, only a single compression algorithm was supported, specifically NRV2E with an 8-bit buffer. Such algorithm\nis part of the UCL data compression library.\n\nThe pseudo code for the handler OPERATION_TYPE_DECOMPRESS is provided in Algorithm 2. The OPERATION_TYPE_\nDECOMPRESS command receives as input argument the size of the output buffer.\n\nAlgorithm 2: Pseudo code representation of the OPERATION_TYPE_DECOMPRESS handler\n\n**Data: output_buf_size**\n**begin**\ntemp_pointer = payload_pointer;\npayload_pointer = AllocateMemory(output_buf_size);\n**if output_buffer == NULL then**\nexit_vm(error);\n**end**\nresult = decompress_NRV2E_8(temp_pointer, output_buf_size, payload_pointer, &payload_size);\n**if result != 0x0 then**\nWipeAndFreeMemory(payload_pointer, payload_size);\nWipeAndFreeMemory(temp_pointer, output_buf_size);\nexit_vm(error);\n**end**\nFree_Memory(temp_buffer);\ntemp_buffer = NULL;\nraw_byte_pointer += sizeof(VMOpcode) + sizeof(DWORD); return;\n**end**\n\n**OPERATION_TYPE_VM_CLEAN**\nThis particular opcode is responsible for shutting down the virtual machine in a clean manner. The handler carefully\noverwrites the contents of both the payload buffer and auxiliary memory buffer if they are available and terminates the\nexecution of the virtual machine program. While it would seem logical that this operation would be performed at the end\nof a VM execution, the program embedded in the sample does not make use of it.\n\n###### 4.3 Content loading and mapping\n\nOnce the payload has been located and extracted from the compromised machine and all the necessary transformations\nhave been applied to it, Regin’s 64-bit stage #1 component will attempt to load the image. The loading process is\nquite generic and well coded, providing a further confirmation that the authors of this particular family of malware are\nknowledgeable when it comes to the operating system’s internals and with low level structures and concepts. The various\naspects of the loading process will be individually detailed in sections 4.3.1, 4.3.2 and 4.3.3.\n\n\n-----\n\n###### 4.3.1 The QuickPeParse64 function\n\nThroughout the code of its loader the malware uses extensively the QuickPeParse64 subroutine to quickly get information\nabout key elements of the PE structure. Code for the QuickPeParse64 subroutine is presented in Listing 7, while the format\nof its output is described in Listing 6.\n\nListing 6: Format of QuickPeParse64’s output\n\n**typedef struct PePointers {**\nIMAGE_DOS_HEADER \u0003* pDosHeader ;\nIMAGE_NT_HEADERS \u0003* pNtHeader ;\nIMAGE_SECTION_HEADER \u0003 * pSectionHeaders [ ] ;\nIMAGE_DATA_DIRECTORY \u0003 * pDataDirectories [ ] ;\n} PePointers ;\n\nListing 7: The QuickPeParse64 subroutine\n\n; bool __fastcall QuickPeParse64 ( void \u0003* pPeFile, PePointers \u0003* pParsedPe )\nQuickPeParse64 proc near\n\narg_8 = word ptr 10h\narg_10 = word ptr 18h\narg_18 = dword ptr 20h\n\nxor r8d, r8d\nmov r9, rdx\ncmp rdx, r8\njz short @@exit_func\n\ncmp rcx, r8\njz short @@exit_func\n\nmov eax, 7777h\nmov edx, 2D3Ah\nmov [ rsp+arg_8 ], ax\nmov [ rsp+arg_18 ], 77777777h\nmov [ rsp+arg_10 ], ax\nmovzx eax, [ r sp+arg_8 ]\n\nxor ax, dx\n\n; ; DOS header magic check (“MZ”)\ncmp ax, [ rcx+IMAGE_DOS_HEADER.e_magic ]\njnz short @@exit_func\n\nmov eax, [ r sp+arg_18 ]\nmovsxd rdx, [ rcx+IMAGE_DOS_HEADER.e_lfanew]\nxor eax, 77773227h\n\nContinues overleaf\n\n\n-----\n\n###### /,\n\n\nContinued\n\n; ; COFF header magic check ( “PE” )\ncmp eax, dword ptr [ rdx+rcx+IMAGE_OPTIONAL_HEADER64.Magic ]\njnz short @@exit_func\n\nmovzx eax, [ rsp+arg_10 ]\nmov r10d, 757Ch\nxor ax, r10w\n\n; ; Verify that the file is a PE32+\ncmp ax, [ rdx+rcx+IMAGE_NT_HEADERS.OptionalHeader.Magic ]\njnz short @@exit_func\n\n; ; Prepare output by filling the result structure\nmov [ r9+PePointers .pDosHeader ], rcx\nmovsxd rdx, [ rcx+IMAGE_DOS_HEADER.e_lfanew]\nmov r8b, TRUE\nadd rdx, rcx\nmov [ r9+PePointers .pPeHeader ], rdx\nmovzx eax, [ rdx+IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader ]\nlea rcx, [ rax+rdx+18h ]\nadd rdx, 88h\nmov [ r9+PePointers .pSectionHeaders ], rcx\nmov qword ptr [ r9+PePointers .pDataDirectories ], rdx\n\n@@exit_func :\nmov al, r8b\nretn\n\nQuickPeParse64    endp\n\nThe QuickPeParse subroutine is not an exclusive characterstic of this malware. In fact, samples of Regin’s 32-bit stage #1\nsamples also included a version of this subroutine; the main differences lie in the fact that the 64-bit version of the code\nuse “encrypted” constants and that the code has been produced using a different toolchain. This particular aspect not\nonly allows us to link together samples of the 32 and 64-bit version of Regin’s stage #1 components, but also to mark the\n64-bit version as the evolution of its 32-bit counterpart.\n\n###### 4.3.2 Headers, Sections and Imports\n\nIn order to map the payload, the malware will allocate a segment of memory that is big enough to hold the memory\nmapped image of the payload. The mapping subroutine allows for client code to specify a preferred address to map the\npayload at; if the client specifies a loading address of 0x0, then the mapping function will use the preferred imagebase\nspecified in the PE file image’s PE header as a preferred allocation base; this is the case for the sample that has been\nanalyzed[ [3]]. Would the allocation with any of these specific addresses fail, the code will fall back to let the system allocate\nenough memory at an address of its choice.\n\n\n-----\n\nOnce the memory has been allocated, the code maps first the headers then each of the sections in a loop. The code\nresponsible to map each of the sections is shown in Figure 5.\n\nFigure 5: The code responsible for mapping the sections\n\nOnce the headers and sections are in place, the malware focuses on the dependencies of the payload and begins\nprocessing its import directory. The loader code will take care not only of resolving symbols, but also of loading additional\nmodules as required. The malware supports symbols exported by name and by ordinal.\n\n###### 4.3.3 Relocations\n\nAfter the previous stages of the mapping are complete, the malware will continue the loading process by applying\nrelocations in case there would be need. The fact that the PE file loader implemented supports relocations makes the\nloader more flexible and allows to the malware to load a wider variety of payloads. The following relocation items are\nsupported explicitly by the malware:\n\n - IMAGE_REL_BASED_ABSOLUTE\n\n - IMAGE_REL_BASED_HIGHLOW\n\n - IMAGE_REL_BASED_DIR64\n\nIf relocation entries of a type different from the ones above are encountered, the relocation process will fail gracefully.\nThis is yet another indication that the authors of this family of malwares are experienced developers that take time to\ncreate code that is well engineered and fault tolerant.\n\n###### 4.4 Payload invocation\n\nAfter the payload has been retrieved and loaded into memory alongside its dependencies, Regin’s 64-bit stage #1 will first\ntransfer control to the entrypoint of the payload. Once execution of the payload’s entrypoint is completed, the malware\nwill process the payload’s export table, retrieve the address for the entry exported with ordinal 1, and execute it. The\nrelevant code portion, appropriately edited, is presented in Listing 8. The way the payload is handled and control is passed\nto it, makes it clear that the next stage of this complex threat is also a 64-bit Dynamic Link Library.\n\n\n-----\n\n###### /,\n\nListing 8: Invocation of the next stage\n\nmov rcx, [ rsp+28h+pPayload ] ; pPe64File\nxor edx, edx\ncall CustomLoadDll ; Completely loads the input PE\n; and invokes its entrypoint\n\nmov rbx, rax\ntest rax, rax\njz short @@cleanup_1\n\nmov edx, 1 ; dqOrdinal\nmov rcx, rax ; hModule\ncall GetAddressOfSymbolExportedByOrdinal\n\ntest rax, rax\njz short @@cleanup_2\n\nmov rcx, r d i ; Pass needed parameter to the function\ncall rax ; Invoke Ordinal #1 of the payload\n\nxor esi, es i\njmp short @@cleanup_1\n\nWith the information extracted by analyzing the code of the sample, it is possible to reconstruct the type of parameters\npassed to the payload’s export #1. The reconstructed prototype of the exported entry is presented in Listing 9.\n\nListing 9: Reconstructed prototype for Ordinal #1 of the payload\n\ntypedef struct PayloadInputStructure {\n\nHMODULE hSelf ;\n\nHTHREAT hThread ;\n\n/* \u0003 Loaded by LoadLibraryEx ( . . ., DONT_RESOLVE_DLL_REFERENCES) * \u0003/\nHMODULE hSelfNoDep ;\n} PayloadInputStructure ;\n\n// Reconstructed prototype\nvoid __fastcall ordinal_1 ( PayloadInputStructure * pInput ) ;\n\n###### 4.5 Cleanup\n\nAfter the invocation of the payload’s export number 1, Regin’s 64-bit stage #1 component will proceed to unload the\npayload and terminate operations. The malware will first invoke the payload’s entry point passing the DLL_PROCESS_\nDETACH parameter, to notify the payload of the impending unload. After this, stage #1 will start removing the artifacts\n\n\n-----\n\nthat were associated to the execution. Each item that was associated with the payload and its interactions with stage #1 is\ncarefully first overwritten then, where applicable, deallocated.\n\nIn this final part of the execution, we also find references to the a value of 0xFEDCBAFF; such value is just one off from the\nvalue of 0xFEDCBAFE, which was observed in samples of Regin’s 32-bit stage #1 component.\n\n##### 5. Conclusions\n\nOur analysis of the Regin’s 64-bit stage #1 component, as detailed in this document, shows that the malware is designed\nto retrieve a payload from an already infected system, map it into memory and transfer control to it. The utilitarian\nnature of the rootkit makes it obvious that this a support module, designed to enable the presence of something surely\nmore meaningful. Most of the malware’s code is fairly generic, therefore allowing it to load any kind of payload as long\nas it satisfies a minimum number of constraints mostly related to how it is stored on the disk. This is a sign that Regin is\ndesigned as a platform rather than an individual entity.\n\nGiven the support nature of Regin’s 64-bit stage #1 component, precise attribution is fairly challenging. The similarities\nwith the 32-bit version of Regin’s stage #1 are very strong, starting from the fact the two different versions of the malware\nhave the same high level purpose, to the fact that they share code like the QuickPeParse subroutine and the string\nexpansion functionalities. We are quite confident in claiming that this 64-bit version of Regin’s stage #1 component is an\nevolution of the 32-bit version, designed to work on more modern versions of the Windows operating system.\n\nLike with the 32-bit version, we have observed a great care put into this malware by its authors. The code of the malware is\ntidy and safe, making it less likely to malfunction or crash during operations. Its camouflage is similarly done with a great\nattention to details, effectively making the malware blend seamlessly with the rest of Windows’ standard system files. All\nof this supports us in confirming our suspicion that the authors of Regin are skilled developers, experienced in the ways of\nsoftware design and implementation.\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/2ifpyh8kjoxsvrj9dnqfxfrb2go1pu3a",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.12.10.W64_Regin/w64_regin_stage_1.pdf"
    ],
    "report_names": [
        "w64_regin_stage_1"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716498,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1418110491,
    "ts_modification_date": 1418110492,
    "files": {
        "pdf": "https://archive.orkl.eu/c5355707644b6948069345e2e8bac429e39f882d.pdf",
        "text": "https://archive.orkl.eu/c5355707644b6948069345e2e8bac429e39f882d.txt",
        "img": "https://archive.orkl.eu/c5355707644b6948069345e2e8bac429e39f882d.jpg"
    }
}