{
    "id": "12e09c59-467c-4056-9df2-5293175fea4c",
    "created_at": "2023-03-03T02:06:19.07166Z",
    "updated_at": "2025-03-27T02:06:02.187452Z",
    "deleted_at": null,
    "sha1_hash": "9de1320ca0ad20720a5f272d031179ce787520b4",
    "title": "2023-02-20 - Vidar Stealer H&M Campaign",
    "authors": "",
    "file_creation_date": "2023-03-01T09:30:46Z",
    "file_modification_date": "2023-03-01T09:30:46Z",
    "file_size": 1957702,
    "plain_text": "# Vidar Stealer H&M Campaign\n\n**[0xtoxin-labs.gitbook.io/malware-analysis/malware-analysis/vidar-stealer-h-and-m-campaign](https://0xtoxin-labs.gitbook.io/malware-analysis/malware-analysis/vidar-stealer-h-and-m-campaign)**\n\nIn this blog I'll be covering a recent phishing campaign that was targeting content creators while impersonating to a\nbrand offering a collaboration offer to those creators.\n\n## The Phish\n\nThe email that the user receives includes a short explanation that the company wants to be his partner, they explain\nto him when and for how long to put the promo video and of course how much money he will receive as a payment.\n\nAt the bottom of the email the user will find a link to the promotion materials and his personal password:\n\n\n-----\n\nPhishing Mail\n\nThe promotion materials link leads to Google Drive, there the User will need to download an archive with the name\nof: H&M Corporation Advertising Contract.zip\n\nThe archive contains inside of it several decoy files that are associated with H&M, and a 600MB .scr file with the\nname: H&M Advertising contract and Payment information.pdf.scr\n\nArchive Content\n\n## .NET Loader\n\nOpening the loader in DiE,we can see that the loader is 32bit .NET assembly protected with Smart Assembly:\n\n\n-----\n\nDiE Information\n\nI've opened the loader in DnSpy to further analyze it. The first thing I see is the confirmation that the loader is\nprotected with Smart Assembly, I can see the PoweredBy section in the static information fields:\n\nSmartAssembly Signature\n\nLooking at the entry point we can understand that working with the loader in this state won't be efficient:\n\nLoader Entry Point (with SmartAssembly)\n\n[I will be using SAE (Simple Assembly Explorer) in order to deobfuscate the code, we can use the deobfuscator](https://github.com/wickyhu/simple-assembly-explorer)\nfeature in SAE:\n\n\n-----\n\nSAE deobfuscator feature\n\nI'm using the default settings as it's fits my needs:\n\nDeobfuscator Settings\n\nOpening the deoubfuscated output file in Dnspy, we can now see a clearer code:\n\nPost Deobfuscation Entry Point\n\n## Payload Extraction\n\nThere are several interesting actions that happens in the loader:\n\n\n-----\n\n1. 1.\n```\n c000009 instance creation with internal field that will contain a path to the injected process.\n\n```\nc000009 Instance\n\n2. 2.\n\nThe instance then will be passed to the method c000066.m000022. this method will have several things in it,\nthe first one being a call to the method: c000066.m00007b, passing the string: fInckSommmenn twice.\n\n3. 3.\n\nThe method c000066.m00007b will simply fetch resource content from the binary resources:\n\nResource Fetching Method\n\n4. 4.\n\nThen a call to the method c000066.m000019 will be invoked passing the extracted resource content, the string:\n**fInckSommmenn and the instance of c000009**\n\n\n-----\n\n5. 5.\n\nThis method will be in charge of decrypting the payload with some Xor routine and it will return the decrypted\nbinary.\n\nDecrypting Method\n\n6. 6.\n\nAfter the decryption was done the decrypted binary will be passed alongside with the full path to the injected\nprocess to c000066.m00002a method which will do a process injection to the desired process with the\ndecrypted binary content.\n\nLoader Main Functionality\n\nI've created a powershell script that extract the decrypted binary by invoking the necessary methods:\n\n# Load the file.\n\n$assembly = [System.Reflection.Assembly]::LoadFile(\"C:\\Users\\igal\\Desktop\\loader.exe\")\n\n​\n\n#Initialize \"NS005.c000009\" object.\n\n$ini = [Activator]::CreateInstance($assembly.Modules[0].GetType(\"NS005.c000009\"),@())\n\n​\n\n#Retrieve the resource fetching method and invoke it.\n\n$classType2 = $assembly.GetType(\"NS004.c000066\")\n\n$array = $classType2.GetMethod(\"m00007b\").Invoke($null,@(\"fInckSommmenn\", \"fInckSommmenn\"))\n\n​\n\n#Invoke the decryption method with the necessary arguments.\n\n$fixedArray = $classType2.GetMethod(\"m000019\").Invoke($null,@($array, \"fInckSommmenn\", $ini))\n\n\n-----\n\n​\n\n#Write the output to a file.\n\n[io.file]::WriteAllBytes('C:\\Users\\igal\\Desktop\\payload.bin',$fixedArray)\n\n## Vidar Payload\n\nIn this part of the blog I will be going through some of the Vidar stealer capabilities, evasion techniques and some\nanti analysis tricks. Opening the payload in DiE we can see that it's a 32bit C/C++ binary:\n\nDiE Information\n\n### Anti-Analysis Nightmare\n\nI've opened the payload in IDA and the first thing that happens is that WinMain was not recognized as a function\nand rather as instruction:\n\nUnrecognized WinMain\n\nI've tried to convert it to function by pressing P but this wasn't helpful, so I've scrolled a bit down and found out a\nchunk of data that wasn't converted as supposed:\n\n\n-----\n\nData Chunk\n\nThen I pressed C to convert that data to code and now that we have instructions instead of data I've marked all the\ninstruction from the beginning of WinMain until the relevant mov - pop - return instructions that marks the end of\na function (in my case the instructions range was 0x4156B0 - 0x415891)\n\nNow I start to work with the decompiler view, I've noticed that the decompilation process is a bit broken:\n\n\n-----\n\nWinMain In Decompiler\n\nOne thing that was done here to confuse the decompiler is Opaque Predicate.\n\n**_\"Opaque predicate is a term used in programming to refer to decision making where there is only one_**\n**_possible outcome. This can be achieved through the use of complex or hard-to-understand logic, such as_**\n**_calculating a value that will always return True. Opaque predicates are often used as anti-disassembling_**\n**_techniques, as they can make it difficult for an analyst to understand the code and determine its intent. By_**\n**_using opaque predicates, malware authors can make their code more difficult to reverse engineer, which_**\n**_can help to evade detection and analysis.\"_** [(Unprotect Project definition)](https://unprotect.it/technique/opaque-predicate/)\n\nOpaque Predicate\n\n[We can use @_n1ghtw0lf script for it:](https://n1ght-w0lf.github.io/malware%20analysis/smokeloader/#opaque-predicates)\n\nimport idc\n\n​\n\nea = 0\n\nwhile True:\n\nea = min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"74 ? 75 ?\"), # JZ / JNZ\n\nidc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"75 ? 74 ?\")) # JNZ / JZ\n\nif ea == idc.BADADDR:\n\nbreak\n\nidc.patch_byte(ea, 0xEB) # JMP\n\nidc.patch_byte(ea+2, 0x90) # NOP\n\nidc.patch_byte(ea+3, 0x90) # NOP\n\nAfter running the script the Decompiler looks a bit better:\n\n\n-----\n\nNon Opaque Predicate in WinMain\n\nBut there is still some code missing because we can see a JUMPOUT instruction, looking at the referenced address\nin the instruction, we can see that the instruction is:\n\nmov eax, 0FEB912E8h\n\nclearly that's wrong and nothing to do with the actual code (and this is caused because the conversation of all the\ndata to code), it can be repaired by simply undefining the instruction. But after that we still can see a unclear\njumpout:\n\nJumpout instructions\n\nagain same strange mov instrcution to eax:\n\nmov eax, 0FEB9C8E8h\n\nit can be fixed by the same approach as before.\n\nAfter clearing the code we have a \"clear\" function:\n\n\n-----\n\nPost Cleaning WinMain\n\nThe Author added a lot of junk calls to the code to make our life a bit harder but we can just ignore them and follow\nthe function calls.\n\n### Self Termination Triggers\n\nThis Vidar payload has several triggers that can occur and lead to self termination of the payload.\n\nThe first one being usage of VirtualAllocExNuma which is a way for the payload to understand whether he\nruns on a system with one or more physical CPU:\n\nVirtualAllocExNuma Function\n\n\n-----\n\nThe second check the payload does is checking the physical memory of the computer (whether it s above\n769MB or not) if it's less then the defined size the payload will terminate:\n\nCheck Physical Memory Function\n\nThe last check will occur after the strings and api resolving functions(which will be covered in a moment), it will\nretrieve the computer name and compare it to HAL9TH, it will also retrieve the user name and compare it to\n```\n   JohnDoe. if one of the retrieved values matches one of the strings the payload will terminate itself:\n\n```\nCheck Computer Name Function\n\n### Strings Decryption\n\nAs most variants of Vidar, the strings are simply xor'ed. The function receives 3 parameters:\n\n1. 1.\n\nLength\n\n2. 2.\n\nXor key\n\n3. 3.\n\nEncrypted string\n\n\n-----\n\nStrings Decryption Function\n\nI've used the script written by [@eln0ty and modified it a bit to fit my needs:](https://twitter.com/eln0ty)\n\nimport idc\n\n​\n\nSTART = 0x401190\n\nEND = 0x40134D\n\nTEMP = 0x0\n\nFLAG = True\n\n'''\n\n[0] = Encrypted String.\n\n[1] = Xor Key.\n\n[2] = Length.\n\n\n-----\n\nVALUES = []\n\n​\n\nea = START\n\n​\n\n# XOR decryption helper function.\n\ndef xorDecrypt(encString, xorKey, keyLen):\n\ndecoded = []\n\nfor i in range(0,len(encString)):\n\ndecoded.append(encString[i] ^ xorKey[i % keyLen])\n\nreturn bytes(decoded)\n\n​\n\n​\n\n​\n\nwhile ea <= END:\n\n# get argument values\n\nif idc.get_operand_type(ea, 0) == idc.o_imm:\n\nVALUES.append(idc.get_operand_value(ea, 0))\n\nif len(VALUES) == 2:\n\nif idc.get_operand_type(ea, 0) == idc.o_reg:\n\nVALUES.append(idc.get_operand_value(ea, 1))\n\nif idc.print_insn_mnem(ea) == \"call\":\n\nlength = VALUES[2]\n\ndata = idc.get_bytes(VALUES[0], length)\n\nkey = idc.get_bytes(VALUES[1], length)\n\nVALUES = []\n\nTEMP = ea\n\nwhile FLAG:\n\nea = idc.next_head(ea, END)\n\nif (idc.print_insn_mnem(ea) == \"mov\") and (idc.get_operand_type(ea, 0) == idc.o_mem) and\n(idc.get operand type(ea, 1) == idc.o reg):\n\n\n-----\n\ndec xorDecrypt(data, key, length).decode( ISO 8859 1 )\n\nprint(f'current location:{hex(ea)}, value will be: {dec}')\n\ndwordVar = idc.get_operand_value(ea, 0)\n\nidc.set_cmt(ea, dec, 1)\n\nidc.set_name(dwordVar, \"STR_\" + dec, SN_NOWARN)\n\nFLAG = False\n\nea = TEMP\n\nbreak\n\n​\n\n​\n\n# move to next instruction\n\nFLAG = True\n\nea = idc.next_head(ea, END)\n\n**quick note: some of the names wont be assigned properly due to IDA syntax, so I've added the plain string as**\ncomment in the dissembler. For example:\n\nDecrypted String Comment\n\nDecoded strings output:\n\nDecoded Strings\n\n### Dynamic API Resolving:\n\nVidar will user LoadLibraryA and GetProcAddress to resolve the necessary API's alongside with the strings it\ndecrypted:\n\n\n-----\n\nAPI Resolve Function\n\n[Once again I used the script written by @eln0ty to replace the name of the variables for easier analysis:](https://twitter.com/eln0ty)\n\nimport idc\n\n​\n\nstart = 0x420874\n\nend = 0x420901\n\nea = start\n\n​\n\napi_names = []\n\n​\n\nwhile ea <= end:\n\n# get GetProcAddress API name\n\nif (idc.print_insn_mnem(ea) == \"mov\") and (idc.get_operand_type(ea, 0) == idc.o_reg) and\n(idc.get_operand_type(ea, 1) == idc.o_mem):\n\naddr = idc.get_operand_value(ea, 1)\n\nname = idc.get_name(addr)\n\nif name.startswith(\"STR_\"):\n\napi_names.append(name)\n\n​\n\n\n-----\n\n# assign GetProcAddress result to global var\n\nif (idc.print_insn_mnem(ea) == \"mov\") and (idc.get_operand_type(ea, 0) == idc.o_mem) and (idc.print_operand(ea,\n1) == \"eax\"):\n\naddr = idc.get_operand_value(ea, 0)\n\nname = api_names.pop(0)\n\nidc.set_name(addr, \"API_\" + name[4:])\n\n​\n\n# move to next instruction\n\nea = idc.next_head(ea, end)\n\n### C2 Communication - Init Communication\n\nIn order to harvest all the data Vidar looking for, Vidar will need to utilize some DLL's which it will fetch from a C2\nserver, below is a short explanation of the DLL's Vidar will retrieve from the C2:\n\n**DLL Name** **Description**\n\nfreebl3.dll Network Security Services (NSS) from Mozilla Foundation\n\nmozglue.dll Memory management for Mozilla applications\n\nmsvcp140.dll Microsoft Visual C++ library for C++ programming\n\nnss3.dll Network security services for SSL/TLS encryption\n\nsoftokn3.dll Cryptographic library for key management and encryption/decryption\n\nsqlite3.dll Accessing and managing SQLite databases\n\nvcruntime140.dll Microsoft Visual C++ library for memory management and I/O\n\nIn my case the Vidar C2 was hosted on 2 different sites:\n\n\n-----\n\n**Telegram:**\n\nTelegram C2 URL Func\n\n​\n\nTelegram Channel Preview\n\n\n-----\n\n**Steam:**\n\nSteam C2 URL Func\n\n​\n\nSteam Profile Preview\n\nAnd in case both of them are down, a plain C2 is presented as a backup:\n\nPlain C2 Function\n\nAfter retrieving the C2 Vidar will send a POST request to the URI:\n\n{C2}/{BOT_ID}\n\nIn my case the bot id is: 907 which is also assigned a plain string:\n\n\n-----\n\nBotnet ID Function\n\nAfter that first request was made the client will receive a response from the server that looks like that:\n\n1,1,1,1,1,b36abae611984b4404a903d57724b39e,1,1,1,1,0,123;%DOCUMENTS%\\;*.txt;50;true;movies:music:mp3:exe;\n\nEach operation is splitted with ; delimiter\n\n### C2 Communication - Operations Configuration\n\nAs mentioned, each operation is splitted by ; delimiter. First Section:\n\n1,1,1,1,1,b36abae611984b4404a903d57724b39e,1,1,1,1,0,123\n\nMost of those values are flags that says what data should be harvested:\n\n**Index** **Flag** **Description**\n\n1 1 Local Passwords\n\n2 1 Cookies\n\n3 1 Crypto Wallets\n\n4 1 Browser History\n\n5 1 Telegram Data\n\n6 b36abae611984b4404a903d57724b39e Exfil Token\n\n7 1 Steam Data\n\n8 1 Discord Data\n\n9 1 Screenshot\n\n10 1 Possible Grabber\n\n11 0 File Size Limit\n\n12 123 Profile ID\n\n**Second Section:**\n\n%DOCUMENTS%\\\n\nThe grabber activity folder.\n\n**Third Section:**\n\n- txt\n\n\n-----\n\nFiles extensions the grabber will harvest.\n\n**Fourth Section:**\n\n50\n\nFile size limit in KB.\n\n**Fifth Section:**\n\ntrue\n\nRecursive harvesting.\n\n**Sixth Section:**\n\nmovies:music:mp3:exe\n\nExcluded file extensions.\n\nAdditionally Vidar will create a profile for the user by harvesting the OS info, RAM, CPU, active processes etc... and\nwill send out infromation.txt alongside with the harvested data:\n\nVersion: 2.4\n\n​\n\nDate: 12/2/2023 11:15:46\n\nMachineID: 4cfb5922-b036-4c14-9ed1-03c0dad19fbd\n\nGUID: {d6dc608d-2a27-11ed-a0e3-806e6f6e6963}\n\nHWID: 12ac9eab3d083674480464-4cfb5922-b036-4c14-9ed1-a0e3-806e6f6e6963\n\n​\n\nPath: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\vbc.exe\n\nWork Dir: In memory\n\n​\n\nWindows: Windows 10 Pro [x64]\n\nInstall date: 8/12/2021 0:18:31\n\nAV: Unknown\n\nComputer Name: IYMUGYHL\n\nUser Name: Admin\n\nDisplay Resolution: 1280x720\n\nDisplay Language: en-US\n\nKeyboard Languages: English (United States)\n\nLocal Time: 12/2/2023 11:15:47\n\n\n-----\n\nTimeZone: UTC 0\n\n​\n\n[Hardware]\n\nProcessor: Intel Core Processor (Broadwell)\n\nCores: 2\n\nThreads: 2\n\nRAM: 4095 MB\n\nVideoCard: Microsoft Basic Display Adapter\n\n​\n\n[Processes]\n\n- System [4]\n\n- Registry [92]\n\n- smss.exe [348]\n\n- csrss.exe [436]\n\n- wininit.exe [512]\n\n- csrss.exe [520]\n\n- winlogon.exe [604]\n\n- services.exe [644]\n\n- lsass.exe [656]\n\n- fontdrvhost.exe [764]\n\n- fontdrvhost.exe [772]\n\n- svchost.exe [780]\n\n- svchost.exe [884]\n\n- svchost.exe [932]\n\n- dwm.exe [1016]\n\n- svchost.exe [60]\n\n- svchost.exe [720]\n\n- svchost.exe [640]\n\n- svchost.exe [1044]\n\n- svchost.exe [1052]\n\n\n-----\n\nsvchost.exe [1140]\n\n- svchost.exe [1192]\n\n- svchost.exe [1208]\n\n- svchost.exe [1232]\n\n- svchost.exe [1316]\n\n- svchost.exe [1384]\n\n- svchost.exe [1432]\n\n- svchost.exe [1452]\n\n- svchost.exe [1504]\n\n- svchost.exe [1572]\n\n- svchost.exe [1604]\n\n- svchost.exe [1616]\n\n- svchost.exe [1712]\n\n- svchost.exe [1740]\n\n- svchost.exe [1840]\n\n- svchost.exe [1876]\n\n- svchost.exe [1900]\n\n- svchost.exe [1952]\n\n- svchost.exe [1968]\n\n- spoolsv.exe [1296]\n\n- svchost.exe [1944]\n\n- svchost.exe [2064]\n\n- svchost.exe [2100]\n\n- sihost.exe [2288]\n\n- svchost.exe [2296]\n\n- taskhostw.exe [2436]\n\n- svchost.exe [2488]\n\n- svchost.exe [2496]\n\n- OfficeClickToRun.exe [2552]\n\n- svchost.exe [2560]\n\n\n-----\n\nsvchost.exe [2616]\n\n- svchost.exe [2656]\n\n- svchost.exe [2668]\n\n- svchost.exe [2676]\n\n- svchost.exe [2976]\n\n- explorer.exe [3048]\n\n- svchost.exe [2832]\n\n- dllhost.exe [3248]\n\n- StartMenuExperienceHost.exe [3356]\n\n- RuntimeBroker.exe [3416]\n\n- dllhost.exe [3456]\n\n- SearchApp.exe [3568]\n\n- RuntimeBroker.exe [3688]\n\n- RuntimeBroker.exe [4652]\n\n- svchost.exe [4340]\n\n- svchost.exe [1892]\n\n- svchost.exe [3392]\n\n- svchost.exe [4424]\n\n- svchost.exe [4680]\n\n- sppsvc.exe [1096]\n\n- svchost.exe [1260]\n\n- svchost.exe [2544]\n\n- WmiPrvSE.exe [1348]\n\n- SppExtComObj.Exe [2532]\n\n- svchost.exe [2596]\n\n- svchost.exe [3020]\n\n- upfc.exe [4400]\n\n- svchost.exe [1632]\n\n- H&M Advertising contract and Payment information.pdf.scr [4396]\n\n- vbc.exe [1684]\n\n\n-----\n\n​\n\n[Software]\n\nGoogle Chrome [89.0.4389.114]\n\nMicrosoft Edge [92.0.902.67]\n\nMicrosoft Edge Update [1.3.167.21]\n\nMicrosoft Visual C++ 2012 Redistributable (x86) - 11.0.61030 [11.0.61030.0]\n\nJava Auto Updater [2.8.66.17]\n\nMicrosoft Visual C++ 2015-2022 Redistributable (x86) - 14.30.30704 [14.30.30704.0]\n\nMicrosoft Visual C++ 2015-2022 Redistributable (x64) - 14.30.30704 [14.30.30704.0]\n\nMicrosoft Visual C++ 2013 Redistributable (x86) - 12.0.40660 [12.0.40660.0]\n\nMicrosoft Visual C++ 2013 x86 Additional Runtime - 12.0.40660 [12.0.40660]\n\nMicrosoft Visual C++ 2008 Redistributable - x86 9.0.30729.6161 [9.0.30729.6161]\n\nAdobe Acrobat Reader DC [19.010.20069]\n\nMicrosoft Visual C++ 2012 x86 Additional Runtime - 11.0.61030 [11.0.61030]\n\nMicrosoft Visual C++ 2012 x86 Minimum Runtime - 11.0.61030 [11.0.61030]\n\nMicrosoft Visual C++ 2022 X86 Additional Runtime - 14.30.30704 [14.30.30704]\n\nMicrosoft Visual C++ 2012 Redistributable (x64) - 11.0.61030 [11.0.61030.0]\n\nMicrosoft Visual C++ 2013 x86 Minimum Runtime - 12.0.40660 [12.0.40660]\n\nMicrosoft Visual C++ 2013 Redistributable (x64) - 12.0.40660 [12.0.40660.0]\n\nMicrosoft Visual C++ 2010 x86 Redistributable - 10.0.40219 [10.0.40219]\n\nMicrosoft Visual C++ 2022 X86 Minimum Runtime - 14.30.30704 [14.30.30704]\n\n### C2 Communication - Data Exfiltration\n\nAfter harvesting all the data Vidar will compress all harvested data to as a zip encode it to base64 and send it out\nalongside with some more data in the next format:\n\n------{random_generated_delimiter}\n\nContent-Disposition: form-data; name=\"profile\"\n\n​\n\n{BOT_ID}\n\n------{random_generated_delimiter}\n\nContent-Disposition: form-data; name=\"profile_id\"\n\n\n-----\n\n{PERSONAL_ID}\n\n------{random_generated_delimiter}\n\nContent-Disposition: form-data; name=\"hwid\"\n\n​\n\n{COMPUTER_HWID}\n\n------{random_generated_delimiter}\n\nContent-Disposition: form-data; name=\"token\"\n\n​\n\n{EXFIL_TOKEN}\n\n------{random_generated_delimiter}\n\nContent-Disposition: form-data; name=\"file\"\n\n{BASE64_ENCODED_ARCHIVE}\n\n\n-----\n\nExfiltration Function\n\n### Post Exfiltration Self Termination\n\nAfter Vidar exfiltrated the data it will create a self termination task using cmd command and by this will end the\nexecution of itself:\n\n\"C:\\Windows\\System32\\cmd.exe\" /c timeout /t 6 & del /f /q Vidar.exe & exit\n\n\n-----\n\nSelf Termination Function\n\n## Summary\n\nVidar is a well known stealer that was active for the past years and keeps on constantly updated by its developers.\n\nIn this blog we've covered most Vidar functions and how it was delivered to it's victims.\n\nQuick note that it's my first \"In Depth\" writeup for a malware so any feedback would be appreciated, you can always\n[PM me on twitter (0xToxin)](https://twitter.com/0xToxin)\n\n## Yara Rule\n\n[The rule is updated up to version 2.4 which was recently revamped from version 5X.X (more info can be found here)](https://twitter.com/AnFam17/status/1626659725709398016)\n\nrule win_Vidar\n\n{\n\nmeta:\n\nauthor = \"0xToxin\"\n\ndescription = \"Vidar stealer strings and functions\"\n\nDate = \"20-02-2023\"\n\nstrings:\n\n\n-----\n\n$dll1 vcruntime140.dll ascii wide\n\n$dll2 = \"softokn3.dll\" ascii wide\n\n$dll3 = \"nss3.dll\" ascii wide\n\n$dll4 = \"msvcp140.dll\" ascii wide\n\n$dll5 = \"mozglue.dll\" ascii wide\n\n$dll6 = \"freebl3.dll\" ascii wide\n\n$dll7 = \"sqlite3.dll\" ascii wide\n\n$c2Fetch1 = \"t.me\" ascii wide\n\n$c2Fetch2 = \"steamcommunity.com\" ascii wide\n\n$stringDec = {\n\n68 ?? ?? ?? 00\n\n68 ?? ?? ?? 00\n\nB9 ?? ?? 00 00\n\nE8 ?? ?? ?? ??\n\n68 ?? ?? ?? 00\n\n68 ?? ?? ?? 00\n\nB9 ?? ?? 00 00\n\nA3 ?? ?? ?? ??\n\n}\n\ncondition:\n\nuint16(0) == 0x5a4d and 3 of ($dll*) and 1 of ($c2Fetch*) and #stringDec >= 15\n\n}\n\n[You can see also the Yara Hunt result on UnpackMe.](https://www.unpac.me/yara/results/17be75d5-e9cc-43e3-991a-ff05fefed65f)\n\n## IOC's\n\n**Samples:**\n\nH&M Corporation Advertising Contract.zip [4d9697358936b516ecd2dd96687649fc1a8b1e8fd4529961dfa49513c85b42c5​](https://bazaar.abuse.ch/sample/4d9697358936b516ecd2dd96687649fc1a8b1e8fd4529961dfa49513c85b42c5/)\nH&M Advertising contract and Payment information.pdf.scr [203b08962eba219761690043281f81fc2d6e1fa26702bfa4ad30d9849b267309​](https://bazaar.abuse.ch/sample/203b08962eba219761690043281f81fc2d6e1fa26702bfa4ad30d9849b267309)\nvidar.bin - [dd15f493fc13d00bb1abc0ac20bb0f7dc44632e71b4fcde1c2889fc34dff6c14​](https://bazaar.abuse.ch/sample/dd15f493fc13d00bb1abc0ac20bb0f7dc44632e71b4fcde1c2889fc34dff6c14/)\n\n\n-----\n\n**Fetching URL s:**\n\nhttps://steamcommunity.com/profiles/76561199476091435\n\nhttps://t.me/gurutist\n\n**C2's:**\n\n195.201.44.125\n\n23.88.36.149:80\n\n95.216.164.28:80\n\n## References\n\nMalware Analysis - Previous\n\nAsyncRAT OneNote Dropper\n\nLast modified 8d ago\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-20 - Vidar Stealer H&M Campaign.pdf"
    ],
    "report_names": [
        "2023-02-20 - Vidar Stealer H&M Campaign.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809179,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1677663046,
    "ts_modification_date": 1677663046,
    "files": {
        "pdf": "https://archive.orkl.eu/9de1320ca0ad20720a5f272d031179ce787520b4.pdf",
        "text": "https://archive.orkl.eu/9de1320ca0ad20720a5f272d031179ce787520b4.txt",
        "img": "https://archive.orkl.eu/9de1320ca0ad20720a5f272d031179ce787520b4.jpg"
    }
}