{
    "id": "a33809fb-f2f2-4fd0-b2a7-dd2090c32c66",
    "created_at": "2023-01-12T15:03:40.462553Z",
    "updated_at": "2025-03-27T02:05:50.720182Z",
    "deleted_at": null,
    "sha1_hash": "f9b0e44c80e026b8a836ad1370f46694779ee11b",
    "title": "2020-06-11 - API Hashing in the Zloader malware",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:29Z",
    "file_modification_date": "2022-05-29T01:19:29Z",
    "file_size": 128530,
    "plain_text": "# API Hashing in the Zloader malware\n\n**[blag.nullteilerfrei.de/2020/06/11/api-hashing-in-the-zloader-malware/](https://blag.nullteilerfrei.de/2020/06/11/api-hashing-in-the-zloader-malware/)**\n\nborn\n\nDirecting your attention as a reverse engineer is key for not wasting your life looking at irrelevant\ncode. This blag post will use an anti-analysis technique used in the Zloader malware as an example\nto practice this art. We will also take a short detour into code-level obfuscation and are going to reimplement the API hashing function from Zloader in Python. This post is aimed towards reverse\nengineering beginners that have already heard about API hashing. If you don't know, what Ghidra is\nor how to use it, you will need to brush over some parts of this post. ## What is API Hashing In case,\nyou don't follow this blag closely, I'll quickly summarize, what I mean with API hashing: if a malware\nauthor doesn't want to include API function names in the malware - neither in the import address\ntable nor as strings somehow passed to `GetProcAddress for example - they can use API hashing.`\nThis involves calculating some sort of hash for each combination of DLL file name and API function\nname (often only the latter) and inclusion of those hashes in the malware instead. Given an API\nhash, the malware can enumerate all loaded DLLs and their exported functions to calculate hashes\nwith the same custom algorithm and compare the result to the given hash, ultimately enabeling\nresolution of the corresponding API function. The topic is covered more thoroughly in the post about\nAPI hashing in the REvil ransomware. ## Identifying the API Resolution Function We will be looking\nat the Zloader sample with SHA256 hash\n```\n4029f9fcba1c53d86f2c59f07d5657930bd5ee64cca4c5929cbd3142484e815a\n\n```\n[In another blag post about string obfuscation, we stumbled upon the API hashing function of Zloader:](https://blag.nullteilerfrei.de/2020/05/24/zloader-string-obfuscation/)\nThe function `FUN_030a3170 is called in $190$ places and each time, it receives some small`\nintegral number and a larger value fitting into a `DWORD . This alone slightly smells like API hashing`\nbut a dead give-away is the fact that the returned value of the function is always `CALL ed shortly`\nafter:\n```\npcVar1 = (code *)FUN_030a3170(0,0x6aa0e84);\niVar2 = (*pcVar1)(2,0);\n\n```\nSo let us rename `FUN_030a3170 to` `ev_ResolveApi and take note of a few argument`\ncombinations: | First Argument | Second Argument | Call |--- |--- |--- | `0 |` `0x6aa0e84 |` `f(2,0) |`\n```\n1 | 0xf3c7b77 |\nf(0,puVar5,puVar4,0xcf0000,0x80000000,0x80000000,0x80000000,0x80000000,0,0,uVar3,0);\n\n```\n| `9 |` `0xabc78f7 |` `f(puVar1,1,&local_14,0) A quick look at the decompiled code of the`\nfunction should instantly make you loose interested in reverse engineering it top to bottom: It looks\nvery convoluted and long. But let us not give up but leap our way to the goal. # The First Argument\nSo let's skip over everything and only realize that the first argument is used to index the array named\n```\nPTR_DAT_030bc2ec . The data PTR_DAT_030bc2ec[param_1] is then passed to the string\n\n```\ndeobfuscation function, analyzed in a previous blag post. Double clicking the array will show the\nfollowing in the assembly listing view:\n\n\n-----\n\n```\n        PTR_DAT_030bc2ec                XREF[1]:  \nFUN_030a3170:030a3224(R) \n030bc2ec e8 c3 0b 03              addr    DAT_030bc3e8           \n= 32h  2\n030bc2f0 f5 c3 0b 03              addr    DAT_030bc3f5           \n= 2Ch ,\n030bc2f4 00 c4 0b 03              addr    DAT_030bc400           \n= 37h  7\n...\n030bc348 e8 c3 0b 03              addr    DAT_030bc3e8           \n= 32h  2\n030bc34c db c4 0b 03              addr    DAT_030bc4db           \n= 3Bh  ;\n\n```\nGhidra identified each of the array entries as a pointer. So let's interpret each entry of this array as\nan obfuscated string and decrypt it: | Index | DLL Name |--- |--- | 0 | `kernel32.dll | 1 |`\n```\nuser32.dll | 2 | ntdll.dll | 3 | shlwapi.dll | 4 | iphlpapi.dll | 5 | urlmon.dll | 6 |\nws2_32.dll | 7 | crypt32.dll | 8 | shell32.dll | 9 | advapi32.dll | 10 | gdiplus.dll |\n\n```\n11 | `gdi32.dll | 12 |` `ole32.dll | 13 |` `psapi.dll | 14 |` `cabinet.dll | 15 |` `imagehlp.dll |`\n16 | `netapi32.dll | 17 |` `wtsapi32.dll | 18 |` `mpr.dll | 19 |` `wininet.dll | 20 |`\n```\nuserenv.dll | 21 | bcrypt.dll Hence the first argument to the function is an index into the\n\n```\nabove listed array of DLL names and hence almost certainly used to specify the DLL to use when\nresolving an API function. Note the choice of words here: I did not say that I am sure that the\nargument is used to specify the DLL which is used to resolve a function; but only, that I am almost\ncertain. When reverse engineering like this, you should keep the amount of certainty for every\nstatement in the back of your head. So if something doesn't make sense anymore, you can track\nback and more easily assess, where to dig deeper. In this case, I don't see a lot of other possibilities,\nwhat this DLL name will be used for otherwise. ## The second argument Let us do a similar trick with\nthe second argument: don't reverse engineer the whole function but just look at the four places,\nwhere the second argument appears while keeping in mind that we believe it to specify an API hash\nof the function to be resolved:\n```\nuVar1 = param_2 % uVar1;\n...\nuVar2 = FUN_030b9a70(uVar2,param_2,0,0);\n...\npcVar5 = FUN_030a3620(iVar4,param_2);\n...\n*local_14 = param_2;\n\n```\nThe alleged API hash is passed into the two functions `FUN_030b9a70 and` `FUN_030a3620 . We will`\nnow take a look at the two, keeping an eye out for code that calculates an API hash to then compare\nit to the passed argument. On first glance, the first of the two functions looks promising: it contains\nsome arithmetic operations and calls a few other functions. But looking at the return value, one can\ninstantly see that it either returns `0xa1 or` `0 . So these are probably not the droids we are looking`\nfor. The second function - `FUN_030a3620 - looks at least as promising as the first one: it contains`\nthe two constants `0x60 and` `0x18 at the very top and also uses a few (nested) loops. So if`\nsomeone would point a gun to my head and ask me for an opinion, which of the two you should\ninvestigate further, I'd definitely choose the second. And you should always imagine that someone is\npointing a gun to your head while reverse engineering. We don't have no time for anything else. I\n[nearly forgot to repeat a life hack from the very same blag post already referenced a few times,](https://blag.nullteilerfrei.de/2020/06/11/api-hashing-in-the-zloader-malware/2019/11/09/api-hashing-why-and-how/)\n\n\n-----\n\nwhich should clear up, why I got so excited about the two constants `0x60 and` `0x18 :` `0x18 is the`\noffset of the _Optional Header_ within the _PE header_ and `0x60 is the offset of the _Data`\nDirectories_ within that Optional Header. We don't need to understand everything here but can\nsimply assume that there is some sort of PE parsing going on (that is parsing of the Windows\n_Portable Executable_ file format). And you need PE parsing to list exports from loaded DLLs, hence\nyou need PE parsing to calculate API hashes of loaded functions. Lucky for us, the API hash passed\nin as an argument is only used in one single line:\n```\nif (uVar3 == param_2) {\n\n```\nAnd since it does not make much sense to compare an API hash with anything else but another API\nhash, it is reasonable to assume that `uVar3 also contains an API hash. It is also plausible that it`\ncontains the API hash calculated by the malware based on loaded DLL names and their exported\nfunctions. Since the value of `uVar3 comes out of` `FUN_030a3140 let's rename that function to`\n```\npr_ApiHash . It receives local_90 and -1 as arguments. So let's just assume for now that\nlocal_90 is somehow derived from DLL and function names and dive into pr_ApiHash . ## The\n\n```\nAPI Hashing Function Lazy time is over now. We finally need to understand some code and what\nexactly, `pr_ApiHash does with its arguments to arrive at an API hash. Since we already assumed`\nthat the first argument contains some data derived from DLL and function names, let us focus on the\nsecond argument for now: It is first compared with `-1 - which makes sense because we already`\nobserved this value as an argument - and another function, `FUN_030a2fe0, is called with the`\nalleged DLL and function names as arguments. Let's look into `FUN_030a2fe0 and retype its`\nargument to `BYTE * :`\n```\nint __cdecl FUN_030a2fe0(BYTE *param_1) {\n int iVar1;\n int iVar2;\n if (param_1 != (BYTE *)0x0) {\n  iVar2 = -1;\n  do {\n   iVar1 = iVar2 + 1;\n   iVar2 = iVar2 + 1;\n  } while (param_1[iVar1] != '\\0');\n  return iVar2;\n }\n return 0;\n}\n\n```\nIf the passed data is the `NULL pointer, the function will return` `0 . Otherwise, it will initialize the`\nvariable `iVar2 with` `-1 and increase value passed into the function until it is the` `NULL`\nterminator. During each iteration, the return variable `iVar2 is incremented by one. Since this is a`\ndo-while loop, this incrementation happens at least one time. Staring at this code a bit more, you can\nsee that this function will interpret the passed argument as a string and return its length. This is huge\nbecause we can now guess the type of the argument and also the type of the variable passed into\nthis function: it probably is just `char * as opposed to some complex data structure derived from`\nDLL and function names. So let us rename `FUN_030a2fe0 to` `strlen and retype the two`\narguments to `pr_ApiHash according to what we just learned. While we are at it, realize that`\n```\nuVar4 is the value returned from pr_ApiHash and rename that variable to ApiHash .\n\n```\n\n-----\n\n```\nuint __cdecl pr_ApiHash(char SomeString,int StrLen) {\n byte bVar1;\n uint uVar2;\n uint uVar3;\n uint ApiHash;\n if (StrLen == -1) {\n  StrLen = strlen(SomeString);\n }\n ApiHash = 0;\n if ( (SomeString != (char *)0x0) && (0 < StrLen) ) {\n  ApiHash = 0;\n  do {\n   bVar1 = FUN_030a5260();\n   ApiHash = (uint)(byte)*SomeString + (ApiHash << (bVar1 & 0x1f));\n   if ( (ApiHash & 0xf0000000) != 0 ) {\n    uVar3 = (ApiHash & 0xf0000000) >> 0x18;\n    uVar2 = FUN_030a9b90(0xfffffff,0xffffffff,0);\n    ApiHash = FUN_030aeef0(~(uVar2 | ~ApiHash | uVar3),(uVar2 | ~ApiHash) & uVar3,\n(HINSTANCE)0x0);\n   }\n   SomeString = (char *)( (byte *)SomeString + 1);\n   StrLen = StrLen + -1;\n  } while (StrLen != 0);\n }\n return ApiHash;\n}\n\n```\n## Code-Level Obfuscation Now we need to get _really_ un-lazy. There are three functions used\nduring calculation of the API hash with names `FUN_030a5260,` `FUN_030a9b90 and,`\n```\nFUN_030aeef0 . Each of these functions needs special attention. * Even though the return value of\nFUN_030a5260 is used, Ghidra did not correctly guess the function signature and somehow\n\n```\ndetermine that it is a `void function. Change the signature (Hotkey` `F ), check \"Use Custom`\nStorage\" and change the returned data type to `int and the storage location to` `EAX . Choosing`\n```\nEAX is often correct and I suggest to just try it and justify later if the resulting decompiled code\n\n```\nmakes sense. Again, purely for time-efficiency reasons. The result will be a convoluted function that\nends with `return _DAT_030be374 ^ 0xa2df808b . Follow` `_DAT_030be374 and change the type`\nto `ddw (Hotkey` `D three times). This reveals that this global variable contains the value`\n```\n0xA2DF808F . Xor-ing with 0xa2df808b results in 4 . Hence, we can rename FUN_030a5260 to\nReturn4 . * Similarly, FUN_030a9b90 is identified to be a void function. Performing the same\n\n```\nprocedure as above (adapt the signature to return an `int in` `EAX ) will lead to a very simple`\ndecompiled function that only Xors the first two arguments. Hence you can rename it to `Xor (and`\nalso remove the last parameter if you feel tidy). * Finally, `FUN_030aeef0 only seems to calculate`\nthe binary or of the two parameters, hence rename it to `Bor (and, again, remove the third`\nparameter if you like). The above three functions are probably caused by anti-analysis techniques\nemployed by the malware author. The technique used in the first function is called \"constant\n[unfolding\" because it is the opposite of the compiler optimization technique called constant folding.](https://en.wikipedia.org/wiki/Constant_folding)\nConstant folding evaluates constant expressions during compile time to avoid unnecessary\ncalculations during run time. Constant unfolding does the reverse: it identifies constants - `4 in this`\ncase - and replaces them with some sort of calculation - `_DAT_030be374 ^ 0xa2df808b in this`\ncase - during compile/build time. Similarly, the other two function employ the opposite of the compiler\n[optimization technique called inlining: Instead of performing the arithmetic operation in-line (here, a](https://en.wikipedia.org/wiki/Inline_expansion)\n\n\n-----\n\nsimple Xor / Binary Or), a function is called that performs this operation. In addition to that,\nunnecessary instructions where inserted into this un-in-lined function that make the code harder to\nread. Specifically the condition of a branch like\n```\nif ( ( ( (param_2 == 0xb4c6d61) && (fuLoad != param_1)) &&\n  (in_stack_0000000c != (HINSTANCE)0xb4c6d61)) &&\n  ( ( (int)in_stack_0000000c << 7 | (uint)in_stack_0000000c) == 0)) {\n\n```\n[that is never taken is called opaque predicate. In addition to that, both function contain some jung](https://en.wikipedia.org/wiki/Opaque_predicate)\ninstructions without any side effects. A lot of them have been removed by the Ghidra decompiler, but\nsince identifying those is hard - even heuristically - some still remain. ## Re-Implementing the\nHashing Function Offentimes you want to emulate API hashing in a different language because it\nenables you to annotate API resolution calls during static analysis. Re-implementing an algorithm will\noften also get rid of any implementational details that may have even been introduces by a compiler\nor obfuscator during built. This in turns eases identification of overlaps in the hashing method\nbetween different malware families, which in turn may indicate a link between the families. After\nperforming the above-described steps and some minor adjustments to variable names in the\n```\npr_ApiHash function, we end up with the following:\nuint __cdecl pr_ApiHash(char *SomeString,int StrLen) {\n byte Four;\n uint Mask;\n uint HighNibble;\n uint ApiHash;\n if (StrLen == -1) {\n  StrLen = strlen(SomeString);\n }\n ApiHash = 0;\n if ( ( SomeString != (char *)0x0 ) && (0 < StrLen) ) {\n  ApiHash = 0;\n  do {\n   _Four = Return4();\n   ApiHash = (uint)(byte)*SomeString + (ApiHash << ( (byte)_Four & 0x1f ));\n   if ( (ApiHash & 0xf0000000) != 0 ) {\n    HighNibble = (ApiHash & 0xf0000000) >> 0x18;\n    Mask = Xor(0xfffffff,0xffffffff);\n    ApiHash = Bor(~(Mask | ~ApiHash | HighNibble),(Mask | ~ApiHash) & HighNibble);\n   }\n   SomeString = (char *)( (byte *)SomeString + 1 );\n   StrLen = StrLen + -1;\n  } while (StrLen != 0);\n }\n return ApiHash;\n}\n\n```\nYou can just copy this into a text editor and change the syntax a bit until it is valid code of your\nlanguage of choice. If your language natively supports bigints (like Python), better make sure to\nsprinkle it with enough `& 0xffffffff . I decided to use Python for now and since I very much`\nenjoy totally unnecessary optimizations, I ended up with the following:\n\n\n-----\n\n```\ndef calc_hash(function_name):\n  mask = 0xf0000000\n  ret = 0\n  for c in function_name:\n    ret = ord(c) + (ret << 0x4)\n    if ret & mask:\n      ret = (~ret | mask) ^ (~ret | ~mask) >> 0x18\n  return ret & 0xffffffff\n\n```\n## API Hash Lookup We already know that the API hash `0x6aa0e84 from the` `kernel32.dll`\nshould resolve to a function that accepts two arguments like so `f(2,0) . So let us plug all exports`\nfrom the `kernel32.dll into the hashing function and check the result:`\n```\nimport pefile\npe = pefile.PE(data=open('C:\\\\Windows\\\\SysWOW64\\\\kernel32.dll', 'rb').read())\nexport = pe.DIRECTORY_ENTRY_EXPORT\ndll_name = pe.get_string_at_rva(export.struct.Name)\nfor pe_export in export.symbols:\n  export_name = pe_export.name.decode('utf-8')\n  if calc_hash(export_name) == 0x6aa0e84:\n    print(export_name)\n\n```\nWhich ... fails by giving no result. Since I was pretty sure about everything _but_ the data actually\npassed into `pr_ApiHash, I decided to do some reversing around that next: Ghidra determined the`\ntype of variable `local_90 to be` `undefined2 local_90 [50] . This is Ghidra's way of telling you`\nthat it thinks it is an array with $50$ entries where each entry has a length of 2 bytes. Since we\nalready established that the array is actual a string, I decided to retype it to `char[100] :`\n```\n...\nFUN_0309ea50(local_90, uVar3);\ncVar1 = *(char *)(iVar5 + param_1);\nif (cVar1 != '\\0') {\n  i = 0;\n  do {\n  local_90[i] = FUN_0309a690(cVar1);;\n  cVar1 = *(char *)(iVar5 + param_1 + 1 + i);\n  i = i + 1;\n  } while (cVar1 != '\\0');\n}\nuVar4 = pr_ApiHash(local_90,-1);\n...\n\n```\nSo the values of that array come out of the function `FUN_0309a690 . Let's take a close look at it: the`\nfunction receives a value and either returns it or adds `0x20 and returns the result. Because the`\ncondition looks complicated and was hit pretty hard by the obfuscator the author probably uses, I\nwas just lucky to know what adding the number `0x20 in the context of strings may mean:`\nconverting upper-case characters to lower-case characters. So my leap of faith was to assume that\n```\nFUN_0309a690 actually is pr_toLower . And heureca! Running the above Python code with lower\n```\ncased `export_name results in a single hit, namely` `CreateToolhelp32Snapshot which accepts`\ntwo `DWORD arguments according to the documentation. This is in-line with our observation from the`\ntable at the start of this post. ## Summary What can you take away from this post? Maybe it is that\nI'm just as lazy as a sloth and don't even reverse engineer. Maybe, that adding or subtracting `0x20`\nmeans converting between upper and lower case strings. Maybe, that offsets `0x18 and` `0x60`\n\n\n-----\n\nindicate PE parsing. Or maybe, that it is sometimes possible to understand a lot of about a malware\nwithout going into every single line of code and understanding everything.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-11 - API Hashing in the Zloader malware.pdf"
    ],
    "report_names": [
        "2020-06-11 - API Hashing in the Zloader malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535820,
    "ts_updated_at": 1743041150,
    "ts_creation_date": 1653787169,
    "ts_modification_date": 1653787169,
    "files": {
        "pdf": "https://archive.orkl.eu/f9b0e44c80e026b8a836ad1370f46694779ee11b.pdf",
        "text": "https://archive.orkl.eu/f9b0e44c80e026b8a836ad1370f46694779ee11b.txt",
        "img": "https://archive.orkl.eu/f9b0e44c80e026b8a836ad1370f46694779ee11b.jpg"
    }
}