{
    "id": "0b056c16-d3f1-435e-b5d9-b5535f11f35e",
    "created_at": "2023-01-12T15:07:51.148813Z",
    "updated_at": "2025-03-27T02:05:43.549862Z",
    "deleted_at": null,
    "sha1_hash": "9a6990cbddb1381c573660226af44e12ba0b1be5",
    "title": "2022-03-27 - A Case of Vidar Infostealer - Part 1 (Unpacking)",
    "authors": "",
    "file_creation_date": "2022-05-27T21:16:44Z",
    "file_modification_date": "2022-05-27T21:16:44Z",
    "file_size": 987249,
    "plain_text": "# A Case of Vidar Infostealer - Part 1 (Unpacking)\n\n**[0x00-0x7f.github.io/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/](https://0x00-0x7f.github.io/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/)**\n\n0x00-0x7F blog March 27, 2022\n\nMar 27, 2022\n\nHi, in this post, I’ll be unpacking and analyzing Vidar infostealer from my BSides Islamabad\n**2021 talk. Initial stage sample comes as .xll file which is Excel Add-in file extension. It allows**\nthird party applications to add extra functionality to Excel using Excel-DNA, a tool or library\nthat is used to write .NET Excel add-ins. In this case, xll file embeds malicious downloader dll\nwhich further drops packed Vidar infostealer executable on victim machine, investigating\nwhole infection chain is out of scope for this post, however I’ll be digging deep the dropped\nexecutable (Packed Vidar) in Part1 of this blogpost and final infostealer payload in Part2.\n\n**SHA256:** [5cd0759c1e566b6e74ef3f29a49a34a08ded2dc44408fccd41b5a9845573a34c](https://bazaar.abuse.ch/sample/5cd0759c1e566b6e74ef3f29a49a34a08ded2dc44408fccd41b5a9845573a34c/)\n\n**Technical Analysis**\n\nI usually start unpacking general malware packers/loaders by looking it first into basic static\nanalysis tools, then opening it into IDA and taking a bird’s eye view of different sections for\nvariables with possible encrypted strings, keys, imports or other global variables containing\nimportant information, checking if it has any crypto signatures identified and then start\ndebugging it. After loading it into x64dbg, I first put breakpoint on memory allocation APIs\nsuch as LocalAlloc, GlobalAlloc, VirtualAlloc and memory protection API: VirtualProtect, and\nhit run button to see if any of the breakpoints hits. If yes, then it is fairly simple to unpack it\nand extract next stage payload, otherwise it might require in-depth static and dynamic\nanalysis. Let’s hit run button to see where it takes us next.\n\n**Shellcode Extraction**\n\nHere we go, the first breakpoint hits in this case, is VirtualProtect, being called on a stack\nmemory region of size 0x28A to grant it Execute Read Write (0x40) protection, strange\nenough right!\n\n\n-----\n\n_Figure1_\n\nfirst few opcodes E9, 55, 8B in dumped data on stack correspond to jmp, push and mov\ninstructions respectively, so it can be assumed it is shellcode being pushed on stack and\nthen granted Execute protection to later execute it, If I hit execute till return button on\nVirtualProtect and trace back from it into disassembler, I can see shellcode stored as stack\n**strings right before VirtualProtect call and list of arguments are pushed as shown in the**\nfigure below\n\n\n-----\n\nfollowing few statements are preparing to execute shellcode on stack by retrieving a handle\nto a device context (DC) object and passing this handle to GrayStringA to execute shellcode\nfrom stack (ptr value in eax taken from Figure1)\n\nlet’s now start exploring the shellcode.\n\n**Debugging shellcode to extract final payload**\n\nAs soon as, GrayStringA executes, it hits on VirtualAlloc breakpoint set in the debugger,\nwhich is being called to reserver/commit 0xAA3CE size of memory with MEM_COMMIT |\n**MEM_RESERVE (0x3000) memory allocation type**\n\n\n-----\n\nreturning control from VirtualAlloc and stepping over one more time from ret, leads us to the\nshellcode, next few statements after VirtualAlloc call are pushing pointer to newly created\nbuffer, size of the buffer and the file handle for currently loaded process on stack to call\n**ReadFile**\n\nwhich reads 0xAA3CE bytes of data from parent process image into the buffer, let’s say it\n**buffer1**\n\n\n-----\n\nfurther execution again hits at VirtualAlloc breakpoint, this time allocating 0x14F0 bytes of\nmemory, I’ll now put a write breakpoint in the memory region reserved/committed by second\nVirtualAlloc API call to see what and how data gets dumped into second buffer, buffer2.\nHitting Run button once more will break at instruction shown in the figure below\n\nthis loop is copying 0x14F0 bytes of data from a certain offset of buffer1 into buffer2, next\nfew statements are agaian calling VirtualAlloc to allocate another 0x350DE bytes of memory\nsay buffer3, pushing returned buffer address along with an offset from buffer1 on stack to\ncopy 0x350DE bytes of data from buffer1 into buffer3\n\n\n-----\n\nloop in the following figure is decrypting data copied to buffer2, next push instruction is\npushing the buffer3 pointer on stack as an argument of the routine being called from buffer2\naddress in edx which is supposed to process buffer3 contents\n\nfigure below is showing final buffer2 decrypted contents\n\n\n-----\n\nstepping into edx starts executing buffer2 contents, where it seems to push stack strings for\nkernel32.dll first and then retrieves kernel32.dll handle by parsing PEB (Process\nEnvironment Block) structure\n\n\n-----\n\nretrieved kernel32.dll handle is passed to next call along with another argument with\nconstant FF7F721A value, a quick Google search for this constant results in some public\nsandbox links but not clear what is this exactly about. Let’s dig into it further, stepping over\nthis routine 0x0A4E results in GetModuleFileNameW API’s resolved address from\nKernel32.dll stored in eax which means this routine is meant to resolve hashed APIs\n\nsimilarly second call resolves 7F91A078 hash value to ExitProcess API, wrapper routine\n**0x0A4E iterates over library exports and routine 0x097A is computing hash against input**\nexport name parameter Shellcode seems to be using a custom algorithm to hash API\n\n\n-----\n\ncomputed hash value is retuned back into eax which is compared to the input hash value\nstored at [ebp-4], if both hash values are equal, API is resolved and its address is stored in\neax\n\nnext few instructions write some junk data on stack followed by pushing pointer to buffer3\nand total size of buffer3 contents (0x350C0) on stack and execute routine 0x0BE9 for\ndecryption - this custom decryption scheme works by processing each byte from buffer3\nusing repetitive neg, sub, add, sar, shl, not, or and xor set of instructions with hard-coded\nvalues in multiple layers, intermediate result is stored in [ebp-1]\n\n\n-----\n\nand final value overwrites the corresponding buffer3 value at [eax] offset\n\n\n-----\n\nonce buffer3 contents are decrypted, it continues to resolve other important APIs in next\nroutine 0x0FB6\n\n\n-----\n\nI wrote a simple POC python script for hashing algorithm implemented by decrypted\n[shellcode which can be found here](https://github.com/0x00-0x7F/RE_tips_and_tricks/blob/master/vidar_packer/api_hash_strings.py)\n\nafter all required APIs have been resolved, it proceeds to create a new process\n\nusing CreateProcessW in suspended mode\n\n\n-----\n\nand then final payload is injected into newly created process using SetThreadContext API,\n**CONTEXT structure for remote thread is set up with ContextFlag and required memory**\nbuffers and SetThreadContext API is called with current thread handle and remote thread\nCONTEXT structure for code injection\n\nmain process terminates right after launching this process, we can now take a dump of this\nprocess to extract final payload.\n\nThat’s it for unpacking! see you soon in the next blogpost covering detailed analysis of Vidar\ninfostealer.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-27 - A Case of Vidar Infostealer - Part 1 (Unpacking).pdf"
    ],
    "report_names": [
        "2022-03-27 - A Case of Vidar Infostealer - Part 1 (Unpacking).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536071,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1653686204,
    "ts_modification_date": 1653686204,
    "files": {
        "pdf": "https://archive.orkl.eu/9a6990cbddb1381c573660226af44e12ba0b1be5.pdf",
        "text": "https://archive.orkl.eu/9a6990cbddb1381c573660226af44e12ba0b1be5.txt",
        "img": "https://archive.orkl.eu/9a6990cbddb1381c573660226af44e12ba0b1be5.jpg"
    }
}