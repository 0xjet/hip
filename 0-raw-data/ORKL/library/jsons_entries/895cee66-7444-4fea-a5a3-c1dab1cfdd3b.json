{
    "id": "895cee66-7444-4fea-a5a3-c1dab1cfdd3b",
    "created_at": "2023-01-12T15:01:35.56519Z",
    "updated_at": "2025-03-27T02:05:57.861436Z",
    "deleted_at": null,
    "sha1_hash": "6f1d149b596452050f80a763985eee8c1bb82da2",
    "title": "Linux based inter-process code injection without ptrace",
    "authors": "",
    "file_creation_date": "2021-03-08T01:09:00Z",
    "file_modification_date": "2021-03-08T01:09:00Z",
    "file_size": 182412,
    "plain_text": "# Linux based inter-process code injection without ptrace(2)\n\n**[blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html](https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html)**\n\nTuesday, September 5, 2017 at 5:01AM\nUsing the default permission settings found in most major Linux distributions it is possible\nfor a user to gain code injection in a process, without using ptrace. Since no syscalls are\nrequired using this method, it is possible to accomplish the code injection using a language as\nsimple and ubiquitous as Bash. This allows execution of arbitrary native code, when only a\nstandard Bash shell and coreutils are available. Using this technique, we will show that the\n```\nnoexec mount flag can be bypassed by crafting a payload which will execute a binary from\n\n```\nmemory.\n\nThe /proc filesystem on Linux offers introspection of the running of the Linux system. Each\nprocess has its own directory in the filesystem, which contains details about the process and\nits internals. Two pseudo files of note in this directory are `maps and` `mem . The` `maps file`\ncontains a map of all the memory regions allocated to the binary and all of the included\ndynamic libraries. This information is now relatively sensitive as the offsets to each library\nlocation are randomised by ASLR. Secondly, the `mem file provides a sparse mapping of the`\nfull memory space used by the process. Combined with the offsets obtained from the `maps`\nfile, the `mem file can be used to read from and write directly into the memory space of a`\nprocess. If the offsets are wrong, or the file is read sequentially from the start, a read/write\nerror will be returned, because this is the same as reading unallocated memory, which is\ninaccessible.\n\nThe read/write permissions on the files in these directories are determined by the\n```\nptrace_scope file in /proc/sys/kernel/yama, assuming no other restrictive access\n\n```\ncontrols are in place (such as SELinux or AppArmor). The Linux kernel offers documentation\nfor the different values this setting can be set to. For the purposes of this injection, there are\ntwo pairs of settings. The lower security settings, 0 and 1, allow either any process under the\nsame uid, or just the parent process, to write to a processes `/proc/${PID}/mem file,`\nrespectively. Either of these settings will allow for code injection. The more secure settings, 2\nand 3, restrict writing to admin-only, or completely block access respectively. Most major\noperating systems were found to be configured with ‘1’ by default, allowing only the parent of\na process to write into its `/proc/${PID}/mem file.`\n\nThis code injection method utilises these files, and the fact that the stack of a process is\nstored inside a standard memory region. This can be seen by reading the `maps file for a`\nprocess:\n```\n$ grep stack /proc/self/maps\n7ffd3574b000-7ffd3576c000 rw-p 00000000 00:00 0             [stack]\n\n```\n\n-----\n\nAmong other things, the stack contains the return address (on architectures that do not use a\n‘link register’ to store the return address, such as ARM), so a function knows where to\ncontinue execution when it has completed. Often, in attacks such as buffer overflows, the\nstack is overwritten, and the technique known as ROP is used to assert control over the\ntargeted process. This technique replaces the original return address with an attacker\ncontrolled return address. This will allow an attacker to call custom functions or syscalls by\ncontrolling execution flow every time the `ret instruction is executed.`\n\nThis code injection does not rely on any kind of buffer overflow, but we do utilise a ROP\nchain. Given the level of access we are granted, we can directly overwrite the stack as present\nin `/proc/${PID}/mem .`\n\nTherefore, the method uses the `/proc/self/maps file to find the ASLR random offsets,`\nfrom which we can locate functions inside a target process. With these function addresses we\ncan replace the normal return addresses present on the stack and gain control of the process.\nTo ensure that the process is in an expected state when we are overwriting the stack, we use\nthe `sleep command as the slave process which is overwritten. The` `sleep command uses`\nthe `nanosleep syscall internally, which means that the` `sleep command will sit inside the`\nsame function for almost its entire life (excluding setup and teardown). This gives us ample\nopportunity to overwrite the stack of the process before the syscall returns, at which point we\nwill have taken control with our manufactured chain of ROP gadgets. To ensure that the\nlocation of the stack pointer at the time of the syscall execution, we prefix our payload with a\nNOP sled, which will allow the stack pointer to be at almost any valid location, which upon\nreturn will just increase the stack pointer until it gets to and executes our payload.\n\nA general purpose implementation for code injection can be found at\n[https://github.com/GDSSecurity/Cexigua. Efforts were made to limit the external](https://github.com/GDSSecurity/Cexigua)\ndependencies of this script, as in some very restricted environments utility binaries may not\nbe available. The current list of dependencies are:\n\nGNU grep (Must support `-Fao --byte-offset )`\ndd (required for reading/writing to an absolute offset into a file)\nBash (for the math and other advanced scripting features)\n\nThe general flow of this script is as follows:\n\nLaunch a copy of `sleep in the background and record its process id (PID). As mentioned`\nabove, the `sleep command is an ideal candidate for injection as it only executes one`\nfunction for its whole life, meaning we won’t end up with unexpected state when overwriting\nthe stack. We use this process to find out which libraries are loaded when the process is\ninstantiated.\n\n\n-----\n\nUsing `/proc/${PID}/maps we try to find all the gadgets we need. If we can t find a gadget`\nin the automatically loaded libraries we will expand our search to system libraries in\n```\n/usr/lib . If we then find the gadget in any other library we can load that library into our\n\n```\nnext slave using LD_PRELOAD. This will make the missing gadgets available to our payload.\nWe also verify that the gadgets we find (using a naive ‘grep’) are within the `.text section of`\nthe library. If they are not, there is a risk they will not be loaded in executable memory on\nexecution, causing a crash when we try to return to the gadget. This ‘preload’ stage should\nresult in a possibly empty list of libraries containing gadgets missing from the standard\nloaded libraries.\n\nOnce we have confirmed all gadgets can be available to us, we launch another sleep process,\n```\nLD_PRELOAD ing the extra libraries if necessary. We now re-find the gadgets in the libraries,\n\n```\nand we relocate them to the correct ASLR base, so we know their location in the memory\nspace of the target region, rather than just the binary on disk. As above, we verify that the\ngadget is in an executable memory region before we commit to using it.\n\nThe list of gadgets we require is relatively short. We require a NOP for the above discussed\nNOP sled, enough POP gadgets to fill all registers required for a function call, a gadget for\ncalling a syscall, and a gadget for calling a standard function. This combination will allow us\nto call any function or syscall, but does not allow us to perform any kind of logic. Once these\ngadgets have been located, we can convert pseudo instructions from our payload description\nfile into a ROP payload. For example, for a 64bit system, the line ‘syscall 60 0’ will convert to\nROP gadgets to load ‘60’ into the RAX register, ‘0’ into RDI, and a syscall gadget. This should\nresult in 40 bytes of data: 3 addresses and 2 constants, all 8 bytes. This syscall, when\nexecuted, would call `exit(0) .`\n\nWe can also call functions present in the PLT, which includes functions imported from\nexternal libraries, such as glibc. To locate the offsets for these functions, as they are called by\npointer rather than syscall number, we need to first parse the ELF section headers in the\ntarget library to find the function offset. Once we have the offset we can relocate these as with\nthe gadgets, and add them to our payload.\n\nString arguments have also been handled, as we know the location of the stack in memory, so\nwe can append strings to our payload and add pointers to them as necessary. For example,\nthe `fexecve syscall requires a` `char** for the arguments array. We can generate the array`\nof pointers before injection inside our payload and upon execution the pointer on the stack to\nthe array of pointers can be used as with a normal stack allocated `char** .`\n\nOnce the payload has been fully serialized, we can overwrite the stack inside the process\nusing `dd, and the offset to the stack obtained from the` `/proc/${PID}/maps file. To`\nensure that we do not encounter any permissions issues, it is necessary for the injection\nscript to end with the ‘exec dd’ line, which replaces the `bash process with the` `dd process,`\ntherefore transferring parental ownership over the `sleep program from` `bash to` `dd .`\n\n\n-----\n\nAfter the stack has been overwritten, we can then wait for the `nanosleep syscall used by`\nthe `sleep binary to return, at which point our ROP chain gains control of the application`\nand our payload will be executed.\n\nThe specific payload to be injected as a ROP chain can reasonably be anything that does not\nrequire runtime logic. The current payload in use is a simple\n```\nopen / memfd_create / sendfile / fexecve program. This disassociates the target\n\n```\nbinary with the filesystem `noexec mount flag, and the binary is then executed from`\nmemory, bypassing the `noexec restriction. Since the` `sleep binary is backgrounded on`\nexecution by `bash, it is not possible to interact with the binary to be executed, as it does not`\nhave a parent after `dd exits. To bypass this restriction, it is possible to use one of the`\nexamples present in the libfuse distribution, assuming `fuse is present on the target system:`\nthe `passthrough binary will create a mirrored mount of the root filesystem to the`\ndestination directory. This new mount is not mounted `noexec, and therefore it is possible`\nto browse through this new mount to a binary, which will then be executable.\n\nA proof of concept video shows this passthrough payload allowing execution of a binary in\nthe current directory, as a standard child of the shell.\n\nFuture work:\n\nTo speed up execution, it would be useful to cache the gadget offset from its respective ASLR\nbase between the preload and the main run. This could be accomplished by dumping an\nassociative array to disk using `declare -p, but touching disk is not necessarily always`\n\n\n-----\n\nappropriate. Alternatives include rearchitecting the script to execute the payload script in the\nsame environment as the main `bash process, rather than a child executed using` `$() . This`\nwould allow for the sharing of environmental variables bidirectionally.\n\nLimit the external dependencies further by removing the requirement for GNU grep. This\nwas previously attempted and deemed too slow when finding gadgets, but may be possible\nwith more optimised code.\n\nThe obvious mitigation strategy for this technique is to set `ptrace_scope to a more`\nrestrictive value. A value of 2 (superuser only) is the minimum that would block this\ntechnique, whilst not completely disabling `ptrace on the system, but care should be taken`\nto ensure that `ptrace as a normal user is not in use. This value can be set by adding the`\nfollowing line to `/etc/sysctl.conf :`\n\n```\nkernel.yama.ptrace_scope=2\n\n```\n\nOther mitigation strategies include combinations of Seccomp, SELinux or Apparmor to\nrestrict the permissions on sensitive files such as `/proc/${PID}/maps or`\n```\n/proc/${PID}/mem .\n\n```\nThe proof of concept code, and Bash ROP generator can be found at\n[https://github.com/GDSSecurity/Cexigua](https://github.com/GDSSecurity/Cexigua)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/Linux based inter-process code injection without ptrace.pdf"
    ],
    "report_names": [
        "Linux based inter-process code injection without ptrace.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535695,
    "ts_updated_at": 1743041157,
    "ts_creation_date": 1615165740,
    "ts_modification_date": 1615165740,
    "files": {
        "pdf": "https://archive.orkl.eu/6f1d149b596452050f80a763985eee8c1bb82da2.pdf",
        "text": "https://archive.orkl.eu/6f1d149b596452050f80a763985eee8c1bb82da2.txt",
        "img": "https://archive.orkl.eu/6f1d149b596452050f80a763985eee8c1bb82da2.jpg"
    }
}