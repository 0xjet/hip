{
    "id": "d471efb8-1843-4fce-bc24-f7712ccf1d0c",
    "created_at": "2022-10-25T16:48:11.87473Z",
    "updated_at": "2025-03-27T02:05:51.911843Z",
    "deleted_at": null,
    "sha1_hash": "6b24e5531b2f5114813a1a242bac8d51e6b12464",
    "title": "Makop Ransomware",
    "authors": "",
    "file_creation_date": "2021-08-13T16:04:12Z",
    "file_modification_date": "2021-08-27T10:48:36Z",
    "file_size": 11429271,
    "plain_text": "# Makop Ransomware\n\n### Prepared by:   LIFARS, LLC Date:  8/13/2021\n\n#### 1\n\n\n-----\n\n## EXECUTIVE SUMMARY \n\n\nMakop ransomware encrypts user’s files using the AES256 algorithm and advises the victims to contact the\nattackers via Tox (P2P instant-messaging protocol). The ransomware imports an AES256 key that is used\nto decrypt a lot of strings, including an RSA public key. There is a mutex called “m23071644” created by\nthe process to ensure that only one instance is running at a single time and a new process spawned by the\nmalware that encrypts network shares. The Windows Product ID is extracted from the registry and is used\nto generate a personal ID that will also be present in the ransom note. The ransomware deletes all volume\nshadow copies and kills specific processes that could lock different targeted file types. The malware\noperators are aware of other ransomware families because they don’t encrypt possibly encrypted files by\nransomware such as Shootlock, RAGA and origami. Two new AES256 keys are generated by the\nransomware, which will be used interchangeably to encrypt the content of the files. A new initialization\nvector (IV) that consists of 16 bytes is generated and stored in the encrypted file, and the AES key used\nfor encryption is encrypted using the RSA public key. There is no possibility to decrypt the files without\nknowing the RSA private key that corresponds to the hard-coded public one. Even if the operators pretend\nthat they exfiltrate data from the network, we didn’t observe any network communications.\n\n\n-----\n\n## ANALYSIS AND FINDINGS\n\n\nSHA256:9D90919B4434B9CAC736945384857209103FDF1A749671F190C947FDA8CC1681\n\nThe malware uses the GetVersion function to retrieve the major and minor version numbers of the OS\nalong with other information:\n\n\n###### Figure 1\n\n\nThe Get TokenInformation API is used to determine the elevation level of the token (0x14\n= TokenElevationType):\n\n\n-----\n\n###### Figure 2\n\n\nThe ransomware retrieves the command-line string for the current process and compares the number of\narguments with 2:\n\nFigure 3\n\n\n-----\n\nThe CryptAcquireContextW routine is utilized to acquire a handle to a key container within a\ncryptographic service provider (0x18 = PROV_RSA_AES):\n\n\n###### Figure 4\n\n\nThe following 32 bytes represent an AES256 key that will be used to decrypt a lot of strings at runtime:\n\n\n###### Figure 5\n\n\nThe AES key constructed earlier is imported by calling the CryptImportKey API, as shown in figure 6:\n\n\n-----\n\n###### Figure 6\n\n\nThe parameters of the blob are explained below:\n\n  - 08 - PLAINTEXTKEYBLOB – the key is a session key\n\n  - 02 – CUR_BLOB_VERSION\n\n  - 0x6610 – CALG_AES_256\n\n  - 0x20 – key size\nUsing the AES key, the binary decrypts data by calling the CryptDecrypt function:\n\n\n###### Figure 7\n\n\nThe result of the decryption is an RSA public key:\n\n\n###### Figure 8\n\n\nThe parameters of the blob are detailed below:\n\n  - 06 – PUBLICKEYBLOB – the key is a public key\n\n  - 02 – CUR_BLOB_VERSION\n\n  - 0xa400 – CALG_RSA_KEYX\n\n  - 0x0400 – key size\n\n  - 0x010001 – public key exponent\nOther strings are decrypted by the malicious process using the same hard-coded AES key:\n\n\n-----\n\n###### Figure 9\n\n\nThe malware retrieves the address of the following export functions by calling the GetProcAddress routine:\nWow64DisableWow64FsRedirection, Wow64RevertWow64FsRedirection and CreateProcessWithTokenW.\nGetLocaleInfoW is used to retrieve the LOCALE_FONTSIGNATURE value for the default locale of the OS\n(0x800 = LOCALE_SYSTEM_DEFAULT and 0x58 = LOCALE_FONTSIGNATURE):\n\n\n###### Figure 10\n\n\nThe ransomware decrypts even more strings, and their purpose will be explained later on:\n\n\n-----\n\n###### Figure 11\n\n\n###### Figure 12\n\n\n-----\n\nThe binary retrieves a handle to the Shell’s desktop window using the GetShellWindow API, as shown in\nthe next figure:\n\n\n###### Figure 13\n\n\nGetWindowThreadProcessId is utilized to extract the identifier of the thread and of the process that created\nthe window from above:\n\n\n###### Figure 14\n\n\nThe malware obtains the join status information for the local computer by calling the NetGetJoinInformation\nfunction:\n\n\n###### Figure 15\n\n\nSome directories names and a mutex name are decrypted by the executable, as shown in figure 16:\n\n\n###### Figure 16\n\n\nThe value of the “SystemDrive” environment variable is retrieved using the GetEnvironmentVariableW API:\n\n\n-----\n\n###### Figure 17\n\n\nThe ransomware creates a mutex called “m23071644” to ensure that only one instance of the executable\nis running at a single time:\n\n\n###### Figure 18\n\n\nThe process opens the “SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion” registry key using the\nRegOpenKeyExA routine:\n\n\n###### Figure 19\n\n\nThe Windows product ID is extracted from the registry and it will be used to compute a victim ID:\n\n\n###### Figure 20\n\n\nThe ransomware extracts the volume serial number of the C drive by calling the GetVolumeInformationW\nAPI:\n\n\n-----\n\n###### Figure 21\n\n\nThe malware uses a custom “hash” function to compute a 4-byte value that corresponds to the Product ID.\nA snippet of the implementation is shown below:\n\n\n###### Figure 22\n\n\nTwo more strings are decrypted by the ransomware using the AES key imported before:\n\n\n-----\n\n###### Figure 23\n\n\nThe binary disables the file system redirection for the calling thread using\nWow64DisableWow64FsRedirection:\n\n\n###### Figure 24\n\n\nAn open handle to the current process is obtained by calling the GetCurrentProcessId and OpenProcess\nAPIs:\n\n\n###### Figure 25\n\n\nThe malicious executable opens the access token associated with the current process:\n\n\n###### Figure 26\n\n\nDuplicateTokenEx is utilized to create a new access token that duplicates the existing token:\n\n\n-----\n\n###### Figure 27\n\n\nThe ransomware creates an anonymous pipe by calling the CreatePipe function:\n\n\n###### Figure 28\n\n\nThere is a new process spawned by the malware with the “-n<Process ID>” parameter. The new process\nhandles the encryption of the network shares, as will be detailed in the upcoming paragraphs:\n\n\n###### Figure 29\n\n\nThe process restores the file system redirection for the current thread:\n\n\n###### Figure 30\n\n\n-----\n\nThe file enforces the system to send critical errors to the calling process using the SetErrorMode API (0x1\n= SEM_FAILCRITICALERRORS). It obtains the currently available disk drives using GetLogicalDrives:\n\n\n###### Figure 31\n\n\nThe GetDriveTypeW API determines if a disk drive is a removable, fixed, CD-ROM, RAM or network drive.\nMakop doesn’t target CD-ROM drives and RAM disks:\n\n\n###### Figure 32\n\n\nThe malware opens the “C:\\” drive using the CreateFileW routine (0x80000000 = GENERIC_READ, 0x3\n= **FILE_SHARE_READ|FILE_SHARE_WRITE,** 0x3 = **OPEN_EXISTING** and 0x80 =\n**FILE_ATTRIBUTE_NORMAL):**\n\n\n###### Figure 33\n\n\nDeviceIoControl is utilized to retrieve the physical location of the specified volume (0x560000 =\n**IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS):**\n\n\n-----\n\n###### Figure 34\n\n\nMakop generates 2 buffers of 32 random bytes using the CryptGenRandom API (let’s call the first one\n**AESKey1 and the second one AESKey2):**\n\n\n###### Figure 35\n\n\n###### Figure 36\n\n\n4 bytes that will be used as a marker in the encrypted files are decrypted by the binary: “AD AD 6B A1”.\nThe RSA public key is imported using the CryptImportKey function:\n\n\n-----\n\n###### Figure 37\n\n\nThese 2 buffers are encrypted using the RSA public key and contain the following information: 4-byte\nmarker, 4-byte “hash” value of Product ID generated earlier, 4-byte the volume serial number, 4-byte value\nobtained from the result of the GetLocaleInfoW call, AESKey1 (or AESKey2) and 4-byte “hash” value of\nthis buffer, computed using the same function used for Product ID:\n\n\n###### Figure 38\n\n\n-----\n\n###### Figure 39\n\n\nThe ransomware decrypts the following strings and uses the GetProcAddress API to obtain the addresses\nof the export functions:\n\n\n###### Figure 40\n\n\nNtQueryObject is used to retrieve information about the system and the current process (0x3 =\n**ObjectAllTypesInformation):**\n\n\n###### Figure 41\n\n\nThe executable gets information about the OS using the RtlGetVersion API. It compares the major version\nnumber (0xa for Windows 10) of the OS with 0x6:\n\n\n-----\n\n###### Figure 42\n\n\nThere is a call to GetTokenInformation that obtains information about whether virtualization is enabled for\nthe token (0x18 = TokenVirtualizationEnabled):\n\n\n###### Figure 43\n\n\nThe malware decrypts even more data using the CryptDecrypt routine:\n\n\n###### Figure 44\n\n\nThe ComSpec environment variable points to the command line interpreter and its content is extracted\nusing the GetEnvironmentVariableW API:\n\n\n###### Figure 45\n\n\nThe CreatePipe routine is utilized to create an anonymous pipe that is used as an inter-process\ncommunication mechanism:\n\n\n-----\n\n###### Figure 46\n\n\nThe pipe created above will be inherited by child processes:\n\n\n###### Figure 47\n\n\nThere is a new cmd.exe process created by the ransomware:\n\n\n###### Figure 48\n\n\nAll volume shadow copies are deleted by the cmd.exe process using the following commands:\n\n  - vssadmin delete shadows /all /quiet\n\n  - wbadmin delete catalog -quiet\n\n  - wmic shadowcopy delete\n\n\n-----\n\n###### Figure 49\n\n\nThe output of the above operations is transmitted to our initial process via pipes:\n\n\n###### Figure 50\n\n\nA small part of the processes that will be killed by the malware is presented in figure 51 (the entire list can\nbe found in the appendix):\n\n\n###### Figure 51\n\n\n-----\n\nCreateToolhelp32Snapshot is utilized to take a snapshot of the processes (0x2 =\n**TH32CS_SNAPPROCESS):**\n\n\n###### Figure 52\n\n\nThe processes are enumerated using the Process32FirstW and Process32NextW functions:\n\n\n###### Figure 53\n\n\nThe following function is used to compare processes’ names with the targeted list:\n\n\n-----\n\n###### Figure 54\n\n\nAny targeted process found is killed using the TerminateProcess routine:\n\n\n###### Figure 55\n\n\n-----\n\nThe following extension will be appended to the encrypted files (note the “hash” of the Product ID):\n\n\n###### Figure 56\n\n\nA new thread is created to encrypt the current directory. Similar threads will be created to encrypt the\n“C:\\”, “C:\\ProgramData” and “C:\\Users” directories:\n\n\n###### Figure 57\n\n\nIt’s important to mention that the following folders will not be encrypted: “C:\\WINDOWS”, \"C:\n\\ProgramData\\microsoft\\windows\\caches\", “C:\\Users\\All Users\\Microsoft\\Windows\\Caches” and \"C:\n\\Users\\Public\". Also, the process doesn’t target directories that contain “windows” or “winnt” in their names.\n\n\n## THREAD ACTIVITY – START ADDRESS FUNCTION\n\n\nThe files are enumerated using the FindFirstFileW and FindNextFileW APIs:\n\n###### Figure 58\n\nThe files that have the following extensions will be skipped: \"makop\", \"CARLOS\", \"shootlock\",\n\"shootlock2\", \"1recoesufV8Sv6g\", \"1recocr8M4YJskJ7\", \"btc\", \"KJHslgjkjdfg\", \"origami\", \"tomas\", \"RAGA\",\n\"zbw\", \"fireee\", \"XXX\", \"element\", \"HELP\", \"zes\", \"lockbit\", \"captcha\", \"gunga\", \"fair\", \"SOS\", \"Boss\",\n\"moloch\", \"BKGHJ\", \"WKSGJ\", \"termit\", \"BBC\", \"dark\", \"id2020\", \"arch\", \"Raf\", \"ryan\", \"zxz\", \"XXL\", \"xakepz\",\n\"exe\", \"dll\", \"sphera\", \"Lookfornewitguy\", \"XHAMSTER\", \"xdqd\", \"BTCHORSEBORIS\", \"code\". Some of\nthese extensions like shootlock, origami, raga and others are the result of other ransomware infections\n(Shootlock, Origami and Raga ransomware). The following files are not encrypted by Makop: “boot.ini”,\n\n\n-----\n\n“bootfont.bin”, “ntldr”, “ntdetect.com”, “io.sys”, “readme-warning.txt”, “desktop.ini”. The ransomware\nopens a file for encryption using the CreateFileW API:\n\n\n###### Figure 59\n\n\nCryptGenRandom is utilized to generate 16 random bytes:\n\n###### Figure 60\n\nThe process imports AESKey1 using the CryptImportKey routine:\n\n###### Figure 61\n\n\n-----\n\nThe initialization vector (IV) is set to the 16-byte buffer generated above:\n\n\n###### Figure 62\n\n\nThe filename is encrypted using AESKey1:\n\nThe encrypted filename is written to the file:\n\n\n###### Figure 63\n\n\n-----\n\n###### Figure 64\n\n\nA 4-byte value that represents the encrypted filename size is also written to the file:\n\n\n###### Figure 65\n\n\nThe initialization vector that was generated earlier is added to the encrypted file:\n\n\n###### Figure 66\n\n\nThe encrypted buffer that also contains AESKey1 is written to the file:\n\n\n-----\n\n###### Figure 67\n\n\nMakop adds 8 NULL bytes after the encrypted content from above:\n\n\n###### Figure 68\n\n\nThe ransomware reads the content of the file by calling the ReadFile function:\n\n\n###### Figure 69\n\n\nThe file content is encrypted using AESKey1:\n\n\n-----\n\n###### Figure 70\n\n\nThe encrypted content is written to the file:\n\n\n###### Figure 71\n\n\n##### The file extension is changed to show that the file has been encrypted:\n\n\n###### Figure 72\n\n\nThe ransom note name and content are also decrypted at runtime:\n\n\n-----\n\n###### Figure 73\n\n\nThe ransom note that contains the personal ID is shown below:\n\n\n###### Figure 74\n\n\nIt's important to mention that AESKey1 and AESKey2 are successively used to encrypt files.\n\n\n## RUNNING WITH “-n” PARAMETER\n\n\nMakop verifies that the Process ID that comes with the “-n” parameter is composed of digits only:\n\n\n-----\n\n###### Figure 75\n\n\nThe binary creates a new thread that will enumerate the network resources:\n\n\n###### Figure 76\n\n\nThe WNetOpenEnumW and WNetEnumResourceW APIs are used to enumerate the network resources. The\nmalicious executable is looking for network shares that will also be encrypted:\n\n\n-----\n\n###### Figure 77\n\n\n-----\n\n## APPENDIX\n\n\n###### List of processes to be stopped\n\nmsftesql.exe\n\nsqlagent.exe\n\nsqlbrowser.exe\n\nsqlservr.exe\n\nsqlwriter.exe\n\noracle.exe\n\nocssd.exe\n\ndbsnmp.exe\n\nsynctime.exe\n\nagntsrvc.exe\n\nmydesktopqos.exe\n\nisqlplussvc.exe\n\nxfssvccon.exe\n\nmydesktopservice.exe\n\nocautoupds.exe\n\nencsvc.exe\n\nfirefoxconfig.exe\n\ntbirdconfig.exe\n\nocomm.exe\n\nmysqld.exe\n\nmysqld-nt.exe\n\nmysqld-opt.exe\n\n\n-----\n\ndbeng50.exe\n\nsqbcoreservice.exe\n\nexcel.exe\n\ninfopath.exe\n\nmsaccess.exe\n\nmspub.exe\n\nonenote.exe\n\noutlook.exe\n\npowerpnt.exe\n\nsteam.exe\n\nthebat.exe\n\nthebat64.exe\n\nthunderbird.exe\n\nvisio.exe\n\nwinword.exe\n\nwordpad.exe\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://lifars.com/wp-content/uploads/2021/08/Makop-Ransomware-Whitepaper-case-studyNEW-1.pdf"
    ],
    "report_names": [
        "Makop-Ransomware-Whitepaper-case-studyNEW-1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716491,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1628870652,
    "ts_modification_date": 1630061316,
    "files": {
        "pdf": "https://archive.orkl.eu/6b24e5531b2f5114813a1a242bac8d51e6b12464.pdf",
        "text": "https://archive.orkl.eu/6b24e5531b2f5114813a1a242bac8d51e6b12464.txt",
        "img": "https://archive.orkl.eu/6b24e5531b2f5114813a1a242bac8d51e6b12464.jpg"
    }
}