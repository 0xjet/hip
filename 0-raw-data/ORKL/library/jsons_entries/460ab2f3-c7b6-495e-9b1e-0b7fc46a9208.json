{
    "id": "460ab2f3-c7b6-495e-9b1e-0b7fc46a9208",
    "created_at": "2023-01-12T14:59:04.27392Z",
    "updated_at": "2025-03-27T02:16:01.108377Z",
    "deleted_at": null,
    "sha1_hash": "3cf4b7aea0e01603815d21ec96badf1047a8dde7",
    "title": "2021-04-26 - Anatomy of Cobalt Strike’s DLL Stager",
    "authors": "",
    "file_creation_date": "2022-05-28T23:36:56Z",
    "file_modification_date": "2022-05-28T23:36:56Z",
    "file_size": 2914125,
    "plain_text": "# Anatomy of Cobalt Strike’s DLL Stager\n\n**[blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/](https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/)**\n\nApril 26, 2021\n\nNVISO recently monitored a targeted campaign against one of its customers in the financial\nsector. The attempt was spotted at its earliest stage following an employee’s report\nconcerning a suspicious email. While no harm was done, we commonly identify any related\nindicators to ensure additional monitoring of the actor.\n\nThe reported email was an application for one of the company’s public job offers and\nattempted to deliver a malicious document. What caught our attention, besides leveraging an\n[actual job offer, was the presence of execution-guardrails in the malicious document.](https://attack.mitre.org/techniques/T1480/)\nAnalysis of the document uncovered the intention to persist a Cobalt Strike stager through\n[Component Object Model Hijacking.](https://attack.mitre.org/techniques/T1546/015/)\n\nDuring my free time I enjoy analyzing samples NVISO spots in-the-wild, and hence further\ndissected the Cobalt Strike DLL payload. This blog post will cover the payload’s anatomy,\ndesign choices and highlight ways to reduce both log footprint and time-to-shellcode.\n\n## Execution Flow Analysis\n\nTo understand how the malicious code works we have to analyze its behavior from start to\nend. In this section, we will cover the following flows:\n\n\n-----\n\n1. The initial execution through `DllMain .`\n2. The sending of encrypted shellcode into a named pipe by `WriteBufferToPipe .`\n3. The pipe reading, shellcode decryption and execution through `PipeDecryptExec .`\n\nAs previously mentioned, the malicious document’s DLL payload was intended to be used as\na [COM in-process server. With this knowledge, we can already expect some known entry](https://docs.microsoft.com/en-us/windows/win32/com/inprocserver32)\npoints to be exposed by the DLL.\n\nList\n\n[of available entry points as displayed in IDA.](https://www.hex-rays.com/)\nWhile technically the malicious execution can occur in any of the 8 functions, malicious code\ncommonly resides in the `DllMain function given, besides TLS callbacks, it is the function`\nmost likely to execute.\n```\n   DllMain : An optional entry point into a dynamic-link library (DLL). When the system\n\n```\nstarts or terminates a process or thread, it calls the entry-point function for each loaded\nDLL using the first thread of the process. The system also calls the entry-point function\nfor a DLL when it is loaded or unloaded using the `LoadLibrary and` `FreeLibrary`\nfunctions.\n\n_[docs.microsoft.com/en-us/windows/win32/dlls/dllmain](https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain)_\n\nThroughout the following analysis functions and variables have been renamed to reflect their\nusage and improve clarity.\n\n## The DllMain Entry Point\n\nAs can be seen in the following capture, the `DllMain function simply executes another`\nfunction by creating a new thread. This threaded function we named `DllMainThread is`\nexecuted without any additional arguments being provided to it.\n\n\n-----\n\nGraphed disassembly of `DllMain .`\nAnalyzing the `DllMainThread function uncovers it is an additional wrapper towards what`\nwe will discover is the malicious payload’s decryption and execution function (called\n```\nDecryptBufferAndExec in the capture).\n\n```\n\n-----\n\nDisassembly of\n```\nDllMainThread .\n\n```\nBy going one level deeper, we can see the start of the malicious logic. Analysts experienced\nwith Cobalt Strike will recognize the well-known `MSSE-%d-server pattern.`\n\n\n-----\n\nDisassembly of\n```\nDecryptBufferAndExec .\n\n```\nA couple of things occur in the above code:\n\n1. The sample starts by retrieving the tick count through `GetTickCount and then divides`\n\nit by `0x26AA . While obtaining a tick count is often a time measurement, the next`\noperation solely uses the divided tick as a random number.\n\n\n-----\n\n2. The sample then proceeds to call a wrapper around an implementation of the\n```\n   sprintf function. Its role is to format a string into the PipeName buffer. As can be\n\n```\nobserved, the formatted string will be `\\\\.\\pipe\\MSSE-%d-server where` `%d will be`\nthe result computed in the previous division (e.g.: `\\\\.\\pipe\\MSSE-1234-server ).`\nThis pipe’s format is a well-documented Cobalt Strike indicator of compromise.\n3. With the pipe’s name defined in a global variable, the malicious code creates a new\n\nthread to run `WriteBufferToPipeThread . This function will be the next one we will`\nanalyze.\n4. Finally, while the new thread is running, the code jumps to the `PipeDecryptExec`\n\nroutine.\n\nSo far, we had a linear execution from our `DllMain entry point until the`\n```\nDecryptBufferAndExec function. We could graph the flow as follows:\n\n```\nExecution flow from `DllMain until` `DecryptBufferAndExec .`\nAs we can see, two threads are now going to run concurrently. Let’s focus ourselves on the\none writing into the pipe ( WriteBufferToPipeThread ) followed by its reading counterpart\n( PipeDecryptExec ) afterwards.\n\n## The WriteBufferToPipe Thread\n\nThe thread writing into the generated pipe is launched from `DecryptBufferAndExec`\nwithout any additional arguments. By entering into the `WriteBufferToPipeThread`\nfunction, we can observe it is a simple wrapper to `WriteBufferToPipe except it`\nfurthermore passes the following arguments recovered from a global `Payload variable`\n(pointed to by the `pPayload pointer):`\n\n1. The size of the shellcode, stored at offset `0x4 .`\n2. A pointer to a buffer containing the encrypted shellcode, stored at offset `0x14 .`\n\n\n-----\n\nDisassembly of\n```\nWriteBufferToPipeThread .\n\n```\nWithin the `WriteBufferToPipe function we can notice the code starts by creating a new`\npipe. The pipe’s name is recovered from the `PipeName global variable which, if you`\nremember, was previously populated by the `sprintf function. The code creates a single`\ninstance, outbound pipe ( PIPE_ACCESS_OUTBOUND ) by calling `CreateNamedPipeA and`\nthen connects to it using the `ConnectNamedPipe call.`\n\n\n-----\n\nGraphed disassembly of `WriteBufferToPipe ‘s named pipe creation.`\nIf the connection was successful, the `WriteBufferToPipe function proceeds to loop the`\n```\nWriteFile call as long as there are bytes of the shellcode to be written into the pipe.\n\n```\n\n-----\n\nGraphed disassembly of `WriteBufferToPipe writing to the pipe.`\nOne important detail worth noting is that once the shellcode is written into the pipe, the\npreviously opened handle to the pipe is closed through `CloseHandle . This indicates that`\nthe pipe’s sole purpose was to transfer the encrypted shellcode.\n\nOnce the `WriteBufferToPipe function is completed, the thread terminates. Overall the`\nexecution flow was quite simple and can be graphed as follows:\n\n\n-----\n\nExecution flow from `WriteBufferToPipe .`\n\n## The PipeDecryptExec Flow\n\nAs a quick refresher, the `PipeDecryptExec flow was executed immediately after the`\ncreation of the `WriteBufferToPipe thread. The first task performed by`\n```\nPipeDecryptExec is to allocate a memory region to receive shellcode to be transmitted\n\n```\nthrough the named pipe. To do so, a call to `malloc is performed with as argument the`\nshellcode size stored at offset `0x4 of the global` `Payload variable.`\n\nOnce the buffer allocation is completed, the code sleeps for 1024 milliseconds ( 0x400 ) and\ncalls `FillBufferFromPipe with both buffer location and buffer size as argument. Should`\nthe `FillBufferFromPipe call fail by returning` `FALSE ( 0 ), the code loops again to the`\n```\nSleep call and attempts the operation again until it succeeds. These Sleep calls and\n\n```\nloops are required as the multi-threaded sample has to wait for the shellcode being written\ninto the pipe.\n\nOnce the shellcode is written to the allocated buffer, `PipeDecryptExec will finally launch`\nthe decryption and execution through `XorDecodeAndCreateThread .`\n\n\n-----\n\nGraphed disassembly of\n```\nPipeDecryptExec .\n\n```\nTo transfer the encrypted shellcode from the pipe into the allocated buffer,\n```\nFillBufferFromPipe opens the pipe in read-only mode ( GENERIC_READ ) using\nCreateFileA . As was done for the pipe’s creation, the name is retrieved from the global\nPipeName variable. If accessing the pipe fails, the function proceeds to return FALSE ( 0 ),\n\n```\nresulting in the above described `Sleep and retry loop.`\n\n\n-----\n\nDisassembly of `FillBufferFromPipe ‘s pipe access.`\nOnce the pipe opened in read-only mode, the `FillBufferFromPipe function proceeds to`\ncopy over the shellcode until the allocated buffer is filled using `ReadFile . Once the buffer`\nfilled, the handle to the named pipe is closed through `CloseHandle and`\n```\nFillBufferFromPipe returns TRUE ( 1 ).\n\n```\n\n-----\n\nGraphed disassembly of `FillBufferFromPipe copying data.`\nOnce `FillBufferFromPipe has successfully completed, the named pipe has completed its`\ntask and the encrypted shellcode has been moved from one memory region to another.\n\nBack in the caller `PipeDecryptExec function, once the` `FillBufferFromPipe call returns`\n```\nTRUE the XorDecodeAndCreateThread function gets called with the following parameters:\n\n```\n1. The buffer containing the copied shellcode.\n2. The length of the shellcode, stored at the global `Payload variable’s offset` `0x4 .`\n3. The symmetric XOR decryption key, stored at the global `Payload variable’s offset`\n```\n   0x8 .\n\n```\n\n-----\n\nOnce invoked, the `XorDecodeAndCreateThread function starts by allocating yet another`\nmemory region using `VirtualAlloc . The allocated region has read/write permissions`\n[( PAGE_READWRITE ) but is not executable. By not making a region writable and executable at](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants)\nthe same time, the sample possibly attempts to evade security solutions which only look for\n```\nPAGE_EXECUTE_READWRITE regions.\n\n```\nOnce the region is allocated, the function loops over the shellcode buffer and decrypts each\nbyte using a simple `xor operation into the newly allocated region.`\n\nGraphed disassembly of `XorDecodeAndCreateThread .`\nWhen the decryption is complete, the `GetModuleHandleAndGetProcAddressToArg`\nfunction is called. Its role is to place pointers to two valuable functions into memory:\n```\nGetModuleHandleA and GetProcAddress . These functions should enable the shellcode\n\n```\nto further resolve additional procedures without relying on them being imported. Before\n\n\n-----\n\nstoring these pointers, the `GetModuleHandleAndGetProcAddressToArg function first`\nensures a specific value is not `FALSE ( 0 ). Surprisingly enough, this value stored in a`\nglobal variable (here called `zero ) is always` `FALSE, resulting in the pointers never being`\nstored.\n\nGraphed disassembly\n\nof `GetModuleHandleAndGetProcAddressToArg .`\nBack in the caller function, `XorDecodeAndCreateThread changes the shellcode’s memory`\n[region to be executable ( PAGE_EXECUTE_READ ) using](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants) `VirtualProtect and finally creates`\na new thread. This final thread starts at the `JumpToParameter function which acts as a`\nsimple wrapper to the shellcode, provided as argument.\n\n\n-----\n\nDisassembly of\n```\nJumpToParameter .\n\n```\nFrom here, the previously encrypted Cobalt Strike shellcode stager executes to resolve\n[WinINet procedures, download the final beacon and execute it. We will not cover the](https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet)\nshellcode’s analysis in this post as it would deserve a post of its own.\n\nWhile this last flow contained more branches and logic, the overall graph remains quite\nsimple:\n\nExecution flow from `PipeDecryptExec until the shellcode.`\n\n## Memory Flow Analysis\n\nWhat was the most surprising throughout the above analysis was the presence of a wellknown named pipe. Pipes can be used as a defense evasion mechanism by decrypting the\nshellcode at pipe exit or for inter-process communications; but in our case it merely acted as\na `memcpy to move encrypted shellcode from the DLL into another buffer.`\n\n\n-----\n\nMemory flow from encrypted shellcode until decryption.\nSo why would this overhead be implemented? As pointed out by another colleague, the\nanswer lays in the Artifact Kit, a Cobalt Strike dependency:\n\nCobalt Strike uses the Artifact Kit to generate its executables and DLLs. The Artifact Kit\nis a source code framework to build executables and DLLs that evade some anti-virus\nproducts. […] One of the techniques [see: `src-common/bypass-pipe.c in the`\nArtifact Kit] generates executables and DLLs that serve shellcode to themselves over a\nnamed pipe. If an anti-virus sandbox does not emulate named pipes, it will not find the\nknown bad shellcode.\n\n_[cobaltstrike.com/help-artifact-kit](https://www.cobaltstrike.com/help-artifact-kit)_\n\nAs we can see in the above diagram, the staging of the encrypted shellcode in the `malloc`\nbuffer generates a lot of overhead supposedly for evasion. These operations could be\navoided should `XorDecodeAndCreateThread instead directly read from the initial encrypted`\nshellcode as outlined in the next diagram. Avoiding the usage of named pipes will\nfurthermore remove the need for looped `Sleep calls as the data would be readily available.`\n\n\n-----\n\nImproved memory flow from encrypted shellcode until decryption.\nIt seems we found a way to reduce the time-to-shellcode; but do popular anti-virus solutions\nactually get tricked by the named pipe?\n\n## Patching the Execution Flow\n\nTo test that theory, let’s improve the malicious execution flow. For starters we could skip the\nuseless pipe-related calls and have the `DllMainThread function call` `PipeDecryptExec`\ndirectly, bypassing pipe creation and writing. How the assembly-level patching is performed\nis beyond this blog post’s scope as we are just interested in the flow’s abstraction.\n\nDisassembly of the patched\n```\nDllMainThread .\n\n```\nThe `PipeDecryptExec function will also require patching to skip` `malloc allocation, pipe`\nreading and ensure it provides `XorDecodeAndCreateThread with the DLL’s encrypted`\nshellcode instead of the now-nonexistent duplicated region.\n\n\n-----\n\nDisassembly of the patched\n```\nPipeDecryptExec .\n\n```\nWith our execution flow patched, we can furthermore zero-out any unused instructions\nshould these be used by security solutions as a detection base.\n\nWhen the patches are applied, we end up with a linear and shorter path until shellcode\nexecution. The following graph focuses on this patched path and does not include the leaves\nbeneath `WriteBufferToPipeThread.`\n\n\n-----\n\nOutline of the patched (red) execution flow and functions.\nAs we also figured out how the shellcode is encrypted (we have the `xor key), we modified`\nboth samples to redact the actual C2 as it can be used to identify our targeted customer.\n\nTo ensure the shellcode did not rely on any bypassed calls, we spun up a quick Python\nHTTPS server and made sure the redacted domain resolved to `127.0.0.1 . We then can`\ninvoke both the original and patched DLL through `rundll32.exe and observe how the`\nshellcode still attempts to retrieve the Cobalt Strike beacon, proving our patches did not\naffect the shellcode. The exported `StartW function we invoke is a simple wrapper around`\nthe `Sleep call.`\n\nCapture of both the original and patched DLL attempting to fetch the Cobalt Strike beacon.\n\n## Anti-Virus Review\n\n\n-----\n\nSo do named pipes actually work as a defense evasion mechanism? While there are efficient\nways to measure our patches’ impact (e.g.: comparing across multiple sandbox solutions),\nVirusTotal does offer a quick primary assessment. As such, we submitted the following\nversions with redacted C2 to VirusTotal:\n```\n   wpdshext.dll.custom.vir which is the redacted Cobalt Strike DLL.\n   wpdshext.dll.custom.patched.vir which is our patched and redacted Cobalt\n\n```\nStrike DLL without named pipes.\n\nAs the original Cobalt Strike contains identifiable patterns (the named pipe), we would expect\nthe patched version to have a lower detection ratio, although the Artifact Kit would disagree.\n\n[Capture of the original Cobalt Strike’s detection ratio on VirusTotal.](https://www.virustotal.com/gui/file/a01ebc2be23ba973f5393059ea276c245e6cea1cd1dc3013548c059e810b83e6/detection)\n\n\n-----\n\n[Capture of the patched Cobalt Strike’s detection ratio on VirusTotal.](https://www.virustotal.com/gui/file/e9dc6d7ac7659e99d2149f4ee5f6fb9fb5f873efd424d5f5572d93dee7958346/detection)\nAs we expected, the named-pipe overhead leveraged by Cobalt Strike actually turned out to\nact as a detection base. As can be seen in the above captures, while the original version\n[(left) obtained only 17 detections, the patched version (right) obtained one less for a total of](https://www.virustotal.com/gui/file/a01ebc2be23ba973f5393059ea276c245e6cea1cd1dc3013548c059e810b83e6/detection)\n[16 detections. Among the thrown-off solutions we noticed ESET and Sophos did not manage](https://www.virustotal.com/gui/file/e9dc6d7ac7659e99d2149f4ee5f6fb9fb5f873efd424d5f5572d93dee7958346/detection)\nto detect the pipe-less version, whereas ZoneAlarm couldn’t identify the original version.\n\nOne notable observation is that an intermediary patch where the flow is adapted but unused\n[code is not zeroed-out turned out to be the most detected version with a total of 20 hits. This](https://www.virustotal.com/gui/file/f2458d8d9c86a8cb4a5ef09ad4213419f70728f69f207464c4b3c423ba7ae3c4/detection)\nhigher detection rate occurs as this patch allows pipe-unaware anti-virus vendors to also\nlocate the shellcode while pipe-related operation signatures are still applicable.\n\n\n-----\n\n[Capture of the intermediary patched Cobalt Strike’s detection ratio on VirusTotal.](https://www.virustotal.com/gui/file/f2458d8d9c86a8cb4a5ef09ad4213419f70728f69f207464c4b3c423ba7ae3c4/detection)\nWhile these tests focused on the default Cobalt Strike behavior against the absence of\nnamed pipes, one might argue that a customized named pipe pattern would have had the\nbest results. Although we did not think of this variant during the initial tests, we submitted a\nversion with altered pipe names ( NVISO-RULES-%d instead of `MSSE-%d-server ) the day`\n[after and obtained 18 detections. As a comparison, our two other samples had their](https://www.virustotal.com/gui/file/5f2b3f855ffb78d91fc2e35377f50c579d31956bf0e39d97e36fbec968fdb7aa/detection)\ndetection rate increase to 30+ over night. We however have to consider the possibility that\nthese 18 detections are influenced by the initial shellcode being burned.\n\n## Conclusion\n\n\n-----\n\nReversing the malicious Cobalt Strike DLL turned out to be more interesting than expected.\nOverall, we noticed the presence of noisy operations whose usage weren’t a functional\nrequirement and even turn out to act as a detection base. To confirm our hypothesis, we\npatched the execution flow and observed how our simplified version still reaches out to the\nC2 server with a lowered (almost unaltered) detection rate.\n\nSo why does it matter?\n\n## The Blue\n\nFirst and foremost, this payload analysis highlights a common Cobalt Strike DLL pattern\nallowing us to further fine-tune detection rules. While this stager was the first DLL analyzed,\nwe did take a look at other Cobalt Strike formats such as default beacons and those\n[leveraging a malleable C2, both as Dynamic Link Libraries and Portable Executables.](https://www.cobaltstrike.com/help-malleable-c2)\n[Surprisingly enough, all formats shared this commonly documented](https://blog.cobaltstrike.com/2021/02/09/learn-pipe-fitting-for-all-of-your-offense-projects/) `MSSE-%d-server pipe`\n[name and a quick search for open-source detection rules showed how little it is being hunted](https://grep.app/search?q=MSSE-&case=true)\nfor.\n\n## The Red\n\nBesides being helpful for NVISO’s defensive operations, this research further comforts our\noffensive team in their choice of leveraging custom-built delivery mechanisms; even more so\nfollowing the design choices we documented. The usage of named pipes in operations\ntargeting mature environments is more likely to raise red flags and so far does not seem to\nprovide any evasive advantage without alteration in the generation pattern at least.\n\nTo the next actor targeting our customers: I am looking forward to modifying your samples\nand test the effectiveness of altered pipe names.\n\nMaxime Thiebaut\n\n\n-----\n\nMaxime Thiebaut is a GCFA-certified intrusion analyst in NVISO s Managed Detection &\nResponse team. He spends most of his time investigating incidents and improving detection\ncapabilities. Previously, Maxime worked on the SANS SEC699 course. Besides his coding\ncapabilities, Maxime enjoys reverse engineering samples observed in the wild.\n\n[Twitter](https://twitter.com/0xThiebaut)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-26 - Anatomy of Cobalt Strike’s DLL Stager.pdf"
    ],
    "report_names": [
        "2021-04-26 - Anatomy of Cobalt Strike’s DLL Stager.pdf"
    ],
    "threat_actors": [
        {
            "id": "4b076dcb-516e-42fb-9c8f-f153902cd5e9",
            "created_at": "2022-10-25T16:07:23.708745Z",
            "updated_at": "2025-03-27T02:02:09.935617Z",
            "deleted_at": null,
            "main_name": "Hidden Lynx",
            "aliases": [
                "Aurora Panda",
                "Group 8",
                "Hidden Lynx",
                "Operation SMN"
            ],
            "source_name": "ETDA:Hidden Lynx",
            "tools": [
                "AGENT.ABQMR",
                "AGENT.AQUP.DROPPER",
                "AGENT.BMZA",
                "AGENT.GUNZ",
                "BlackCoffee",
                "HiKit",
                "MCRAT.A",
                "Mdmbot.E",
                "Moudoor",
                "Naid",
                "PNGRAT",
                "Trojan.Naid",
                "ZoxPNG",
                "gresim"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5a0483f5-09b3-4673-bb5a-56d41eaf91ed",
            "created_at": "2023-01-06T13:46:38.814104Z",
            "updated_at": "2025-03-27T02:00:02.925972Z",
            "deleted_at": null,
            "main_name": "MageCart",
            "aliases": [],
            "source_name": "MISPGALAXY:MageCart",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a7aefdda-98f1-4790-a32d-14cc99de2d60",
            "created_at": "2023-01-06T13:46:38.281844Z",
            "updated_at": "2025-03-27T02:00:02.792526Z",
            "deleted_at": null,
            "main_name": "APT17",
            "aliases": [
                "G0025",
                "AURORA PANDA",
                "Group 72",
                "G0001",
                "HELIUM",
                "Group 8",
                "Hidden Lynx",
                "Tailgater Team",
                "BRONZE KEYSTONE"
            ],
            "source_name": "MISPGALAXY:APT17",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535544,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1653781016,
    "ts_modification_date": 1653781016,
    "files": {
        "pdf": "https://archive.orkl.eu/3cf4b7aea0e01603815d21ec96badf1047a8dde7.pdf",
        "text": "https://archive.orkl.eu/3cf4b7aea0e01603815d21ec96badf1047a8dde7.txt",
        "img": "https://archive.orkl.eu/3cf4b7aea0e01603815d21ec96badf1047a8dde7.jpg"
    }
}