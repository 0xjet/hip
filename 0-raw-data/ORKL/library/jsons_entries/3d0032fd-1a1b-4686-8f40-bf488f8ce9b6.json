{
    "id": "3d0032fd-1a1b-4686-8f40-bf488f8ce9b6",
    "created_at": "2023-01-12T15:05:05.774914Z",
    "updated_at": "2025-03-27T02:05:29.628466Z",
    "deleted_at": null,
    "sha1_hash": "96a2e4bb8075d274c30fa258f0424df4eae99b67",
    "title": "2022-05-30 - Automatically Unpacking IcedID Stage 1 with Angr",
    "authors": "",
    "file_creation_date": "2022-06-01T12:26:44Z",
    "file_modification_date": "2022-06-01T12:26:44Z",
    "file_size": 645107,
    "plain_text": "# Automatically Unpacking IcedID Stage 1 with Angr\n\n**[matth.dmz42.org/posts/2022/automatically-unpacking-icedid-stage1-with-angr/](https://matth.dmz42.org/posts/2022/automatically-unpacking-icedid-stage1-with-angr/)**\n\n#### May 30, 2022\n\n\nMay 30, 2022\n\n\n#### It started with 0verfl0w posting a small challenge on the Zero 2 Automated discord server asking to automatically extract the configuration of an unpacked IcedID sample (0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7).\n\n Unpacking the sample was part of the exercise but could be done manually as a one shot, however the more I looked into the stager, the more i thought an automated unpacker would be a fun thing to do.\n\n I’ll skip over some details of the stager (like API hashing and injection) to focus only on the unpacking part.\n\n TL;DR: full code is available here: https://github.com/matthw/icedid_stage1_unpack.\n\n EDIT: it unpacks samples packed with SPLCrypt, including BazarLoader.\n\n## 1. Structure and Flow\n\n#### The packed data are really easy to identify: there’s a huge hex string in the data section, and by hex string i a mean littleral string of [0-9a-f] characters.\n```\n[...]\n000af670 33 62 36 64 34 39 61 61 36 35 33 36 31 34 64 65 |3b6d49aa653614de|\n000af680 33 31 62 32 66 64 37 31 65 64 38 66 61 30 37 63 |31b2fd71ed8fa07c|\n000af690 63 34 30 39 64 64 34 38 61 65 36 35 38 39 31 61 |c409dd48ae65891a|\n000af6a0 63 36 33 61 30 39 39 36 31 38 61 63 38 35 30 33 |c63a099618ac8503|\n000af6b0 62 34 32 37 39 31 36 63 66 36 31 66 31 31 33 30 |b427916cf61f1130|\n000af6c0 37 66 35 39 30 35 33 31 65 37 37 39 35 34 31 33 |7f590531e7795413|\n000af6d0 63 64 31 62 32 30 00 00 00 00 00 00 00 00 00 00 |cd1b20..........|\n\n The unpacking process is as follow:\n\n```\n\n-----\n\n```\n       ┌ ┐\n       │      │\n       │ Hex Decode │\n       │      │\n       └─────┬──────┘\n          │\n          │\n       ┌─────▼──────┐\n       │      │\n    ┌─────┤  RC4   │\n    │   │      │\n    │   └─────┬──────┘\n    │      │\n    │      │\n┌──────▼─────┐   │\n│      │   │\n│   XOR  │   │\n│ (optionnal)│   │\n│      │   │\n└─────┬──────┘   │\n   │      │\n   │      │\n   │   ┌─────▼──────┐\n   │   │      │\n   └──────► QuickLZ  │\n       │(decompress)│\n       │      │\n       └─────┬──────┘\n          │\n          │\n       ┌─────▼──────┐\n       │      │\n       │  Split  │\n       │      │\n       └────────────┘\n\n#### The control flow at assembly level is very obfuscated, so the decompiler comes handy even if it doesn’t produces perfect results.\n\n```\n\n-----\n\n## 1.1. Hex decode\n\n#### The first step is to decode the hex string:\n\n\n-----\n\n```\n      for (i 0; i < length; i i + 2) {\n        chr = hexencoded_data[i];\n        next_chr = hexencoded_data[i + 1];\n        v1 = is_valid_hex_chr(chr);\n        /* not an hex digit, ciao */\n        if ((v1 == 0) || (v1 = is_valid_hex_chr(next_chr), v1 == 0)) {\n          memset((ulonglong)destination,0,0x10,uVar2,chr,length);\n          get_TEB();\n          (*RtlFreeHeap)();\n          return 0;\n        }\n        /\n        /* convert 1st ascii chr to hex value, ex: 'a' -> 0xa */\n        v1 = hex_digit_to_int(chr);\n        /* 0xa -> 0xa0 */\n        high4 = (byte)(v1 << 4);\n        /* convert 2nd ascii chr to hex value '8' -> 0x8 */\n        low4 = hex_digit_to_int(next_chr);\n        /* make it a byte: 0xa0 | 0x8 == 0xa8 */\n        *(byte *)(*destination + (i >> 1)) = high4 | (byte)low4;\n      }\n\n#### this is a plain equivalent to python’s bytes.fromhex(...)\n\n## 1.2. RC4\n\n#### The RC4 routine is easily identified:\n\n```\n\n-----\n\n#### The parameters 4 and 5 are respectively a pointer to the key and the length of the key (which is always 4 apparently).\n\n## 1.3. XOR\n\n#### The XOR was not present in all samples i checked, but when applied, it reuses the RC4 key.\n\n It looks intimidating but in reality it can be translated to:\n\n\n-----\n\n```\n  for x in range(len(data) 1): \n    data[x] = ((data[x] ^ key[x % len(key)]) - data[x + 1]) & 0xff\n\n## 1.3. QuickLZ\n\n#### The QuickLZ part was harder to identify. On the first sample I analyzed, there was no compression applied, so at this point the decrypted data looked OK\n\n I could find a valid PE file inside the decrypted data:\n00000db0 7c 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 ||MZ.............|\n00000dc0 00 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 |.........@......|\n00000dd0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\n00000de0 00 00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 |................|\n00000df0 00 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 |.........!..L.!T|\n00000e00 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e |his program cann|\n00000e10 6f 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 |ot be run in DOS|\n00000e20 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 | mode....$......|\n00000e30 00 21 c9 10 93 65 a8 7e c0 65 a8 7e c0 65 a8 7e |.!...e.~.e.~.e.~|\n\n but i still noticed some kind of header at the very beginning of the extracted data, and that the dword starting at offset 1 was actually the size of the data blob\n\n I thought it was some kind of internal structure I could just ignore, until I started having issues with some samples where the embedded PE file seemed corrupt:\n\n```\n\n-----\n\n```\n00000c40 3e eb df 8f 46 03 4d 5a 90 00 03 f3 03 00 80 46 |>...F.MZ.......F|\n00000c50 8a 10 ff ff cd 17 20 c6 00 06 93 fb 01 00 0b f2 |...... .........|\n00000c60 03 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 |.........!..L.!T|\n00000c70 68 69 73 20 70 72 00 00 00 80 6f 67 72 61 6d 20 |his pr....ogram |\n00000c80 63 61 6e 6e 6f 74 20 62 65 20 72 75 6e 20 69 6e |cannot be run in|\n00000c90 20 44 4f 53 20 6d 6f 64 65 20 40 10 c4 2e 0d 0d | DOS mode @.....|\n00000ca0 0a 24 12 11 21 c9 10 93 65 a8 7e c0 16 01 42 6e |.$..!...e.~...Bn|\n00000cb0 05 c0 67 20 16 ca 7f c1 6e 0a 05 7f c0 4f 20 08 |..g ....n....O .|\n00000cc0 0a 07 88 83 cc 7a 0a 04 83 cc 7e c1 64 0a 02 7c |.....z....~.d..||\n00000cd0 0a 02 52 69 63 68 06 0e 16 25 8b 5e 03 64 86 07 |..Rich...%.^.d..|\n\n#### After some time staring at the code, it turned out that it’s using QuickLZ.\n\n Major pointers were:\n\n the header format, as described here:\n┌─────╥──╥──╥──╥──╥──╥──╥──╥──┐\n│Flags║ Comp size ║ Dec size │\n└─────╨──╨──╨──╨──╨──╨──╨──╨──┘\n\n finding code like this\n\n```\n\n-----\n\n#### looking very very similar to https://github.com/sergey-dryabzhinsky/python- quicklz/blob/master/quicklz.c#L630\n\n Luckily for us there’s python bindings for QuickLZ, which work just fine: https://pypi.org/project/pyquicklz/.\n\n## 1.4 Split\n\n\n-----\n\n#### The decrypted data blob can be split at every occurences of the |SPL| marker, the string is build on the stack:\n\n I kind of skipped the details in my analysis because i do not need them for now.\n\n## 2. Automating\n\n#### Right now we have everything we need for unpacking:\n\n the data blob is easy to grab from the data section, with a regex for example RC4 is vanilla the XOR is easy to implement QuickLZ has python bindings\n\n The only thing we need to be able to recover is the RC4/XOR key, and that’s where the fun begins.\n\n The key is not stored as data, instead it’s computed in the code and stored on the stack:\n\n so in this case the key is:\n```\n>>> p32(0x11c7425e + 0x68)\nb'\\xc6B\\xc7\\x11'\n\n## 2.1. Failed Approach\n\n#### my first approach was to match the bytes using a YARA rule like:\n\n```\n\n-----\n\n```\n      rule key {\n        strings:\n          // C74424 34 5E42C711    | mov dword ptr ss:[rsp+34],11C7425E\n          // 834424 34 68       | add dword ptr ss:[rsp+34],68\n          $instr = { C7 44 24 ?? ?? ?? ?? ?? 8? ?? 24 ?? ?? }\n        condition:\n          $instr\n      }\n\n#### emulate all the matches with unicorn, fetch the result from the stack and try all values as keys.\n\n The key grabbing looked like this and worked on some samples:\n\n```\n\n-----\n\n```\ndef emulate(code):\n  \"\"\" emulate the potential key instruction and return\n  whatever 4 byte value is on the stack (or None)\n  \"\"\"\n  ADDR_TEXT = 0x1000000\n  ADDR_STACK = 0x7000000\n  mu = Uc(UC_ARCH_X86, UC_MODE_64)\n  mu.mem_map(ADDR_TEXT, 0x1000)\n  mu.mem_map(ADDR_STACK, 0x1000)\n  # copy code\n  mu.mem_write(ADDR_TEXT, code)\n  # init rsp\n  mu.reg_write(UC_X86_REG_RSP, ADDR_STACK)\n  # emulate\n  try:\n    mu.emu_start(ADDR_TEXT, ADDR_TEXT + len(code))\n  except unicorn.UcError:\n    pass\n  # read stack\n  stack = mu.mem_read(ADDR_STACK, 0x100)\n  # assume there's no null byte\n  for v in [stack[i:i+4] for i in range(0, len(stack), 4)]:\n    if u32(v) != 0:\n      return bytes(v)\n  return None\ndef find_keys(pe):\n  ''' find potential instructions setting the key\n  '''\n  # find .text\n  data = get_section(pe, '.text')\n  rule = yara.compile(source=\"\"\"\n      rule key {\n        strings:\n          // C74424 34 5E42C711    | mov dword ptr ss:[rsp+34],11C7425E\n          // 834424 34 68       | add dword ptr ss:[rsp+34],68\n          $instr = { C7 44 24 ?? ?? ?? ?? ?? 8? ?? 24 ?? ?? }\n        condition:\n          $instr\n      }\"\"\")\n  finds = rule.match(data=data)\n\n```\n\n-----\n\n```\n  # potential code snippet setting the key\n  key_code = []\n  for find in finds['main'][0]['strings']:\n    offset = find['offset']\n    string = data[offset:offset+16]\n    if string[3] == string[11]:\n      #print(string)\n      key_code.append(string)\n  potential_keys = []\n  for code in key_code:\n    print(\"--- emulating:\")\n    #disasm(code)\n    key = emulate(code)\n    # assume no null byte in key\n    if key is not None and not b'\\x00' in key:\n      potential_keys.append(key)\n  return potential_keys\n\n```\n\n-----\n\n```\n ./unpack2.py 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x20], 4\n0x1008: add dword ptr [rsp + 0x20], 0\n0x100d: jmp 0x1067\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x34], 0x11c7425e\n0x1008: add dword ptr [rsp + 0x34], 0x68\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x14], 0xa6\n0x1008: add dword ptr [rsp + 0x14], 0x5a\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x20], 1\n0x1008: add dword ptr [rsp + 0x20], 0\n0x100d: jmp 0x101f\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x60], 0\n0x1008: add dword ptr [rsp + 0x60], 2\n0x100d: jmp 0xfda\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x50], 2\n0x1008: add dword ptr [rsp + 0x50], 2\n0x100d: cmp bl, bl\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x70], 0\n0x1008: add dword ptr [rsp + 0x70], 3\n0x100d: cmp bp, bp\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 0x800000e0\n0x1008: sub dword ptr [rsp + 0x28], 0xe0\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 0x800000e0\n0x1008: sub dword ptr [rsp + 0x28], 0xe0\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x44], 0\n0x1008: add dword ptr [rsp + 0x44], 3\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x24], 4\n0x1008: add dword ptr [rsp + 0x24], 0\n0x100d: jmp 0x1073\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 0x800000e0\n0x1008: sub dword ptr [rsp + 0x28], 0xe0\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x24], 3\n0x1008: add dword ptr [rsp + 0x24], 1\n0x100d: jmp 0x1086\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x24], 1\n0x1008: add dword ptr [rsp + 0x24], 0\n0x100d: jmp 0x100f\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 1\n0x1008: add dword ptr [rsp + 0x28], 0\n0x100d: jmp 0x1050\n\n```\n\n-----\n\n```\n0x100f: nop\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 3\n0x1008: add dword ptr [rsp + 0x28], 1\n0x100d: jmp 0xff6\n--- emulating:\n0x1000: mov dword ptr [rsp + 0x28], 0x7ffffa1\n0x1008: add dword ptr [rsp + 0x28], 0x5f\n0x100d: cmp di, di\nfound 1 potential keys: [b'\\xc6B\\xc7\\x11']\ngot 0x4c04b data blob\ndecrypted data\n- dump 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.dump\nfound 5 elements\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4\n\n#### until the flow obfuscation of some samples brought even more fun to the party by putting a jump right in the middle of the key setting:\n\n rendering my initial and pretty naive approach useless.\n\n## 2.2. Angr\n\n#### I only played with angr before to solve crackmes and CTF challenges, and I wanted to do something else with it to practice (because let’s face it, i’m pretty bad with angr).\n\n To quote their website:\nangr is an open-source binary analysis platform for Python.\nIt combines both static and dynamic symbolic (\"concolic\") analysis, providing tools\nto solve a variety of tasks.\n\n My new goal was:\n\n```\n\n-----\n\n#### Identify the RC4 function using some heuristics Walk the control-flow graph (CFG) up to find where it’s called from Execute the function(s) calling the RC4 function up to the actual call Get the key\n```\n               ┌────────────────────────────────────────────┐\n               │  FUNCTION WHATEVER            │\n               │                      │\n               ├────────────────────────────────────────────┤  \nstep5: emulate from\n               │                      ├────┐  \n0x0332 (function start)\n           ┌───────►│ 0x0332  INSTR1             │  │  \nto\nstep4: find function │    │ 0x0334  INSTR2             │  │  \n0x0456 (call rc4)\n     start addr │    │   etc...                 │  │\n      0x332  │    │   ...                  │  │\n           └────────┤   ...                  │  │\n               │   ...                  │  │\n           ┌───────►│ 0x0456  CALL POTENTIAL_RC4       │ ◄──┘\n           │    │   ...                  │  \nstep6: dump the key parameter\n           │    │   ...                  │\n           │    │   ...                  │\nstep3: find XREF   │    │                      │\n    for 0x1234  │    │                      │\n    -> 0x0456  │    │                      │\n           │    └────────────────────────────────────────────┘\n           │\n           │\n           │\n           │    ┌────────────────────────────────────────────┐\n           │    │  FUNCTION POTENTIAL_RC4          │\n           └────────┤                      │\n               ├────────────────────────────────────────────┤\n               │                      │\n           ┌──────► │ 0x1234   INSTR1             │\n           │    │ 0x1236   INSTR2             │\nstep2: find function │    │   etc...                 │\n     start addr │    │                      │  step1:\nfind offset with\n      0x1234  │    │  ─────┐ ◄────────────────────────────────┼──────── \nheuristic (0x1430)\n           │    │ 0x1430 │ xor   eax, ecx        │\n           └────────┤ 0x1432 │ movsxd rcx, dword [var_18h_2] │\n               │  ──────┘                 │\n               │                      │\n               │                      │\n               └────────────────────────────────────────────┘\n\n Luckily angr can provide a CFG and has a sense of “function”.\n\n```\n\n-----\n\n#### We can define a project and get the CFG:\n```\n    self.prj = angr.Project(filename, load_options={'auto_load_libs': False})\n    self.cfg = self.prj.analyses.CFGFast()\n\n### 2.2.1. Finding the RC4 Function\n\n#### I used some loosy heuristic to find the RC4 but it seems to work well:\n    # find .text\n    section = get_section(self.pe, '.text')\n    data = section.get_data()\n    # oddly enough this seems to match the rc4 function\n    # fairly accurately\n    # like\n    # 0x1800027c2   33c1          xor   eax, ecx\n    # 0x1800027c4   48634c2418       movsxd rcx, dword [var_18h_2]\n    # or\n    # 0x180004242   0fb68c0cd0000000    movzx  ecx, byte [rsp + rcx +\n0xd0]\n    # 0x18000424a   33c1          xor   eax, ecx\n    # 0x18000424c   e974feffff       jmp   0x1800040c5 ;\nfcn.180003bbf+0x506\n    rule = yara.compile(source=\"\"\"\n      rule rc4 {\n        strings:\n          //$s1 = { 33 c1 }\n          $s2 = { 33 c1 48 63 4c 24 ?? }\n          $s3 = { 33 c1 (e9 | 3a) }\n        condition:\n          $s2 or $s3\n      }\"\"\")\n    # get matching offsets\n    finds = rule.match(data=data)\n\n Then we just need to fix the offsets - which are relative to the start of .text, so they match the virtual address:\n    offsets = []\n    for find in finds['main'][0]['strings']:\n      # offset are relative to .text, rebase them\n      off = self.pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress +\nfind['offset']\n      offsets.append(off)\n\n Using these offsets, we can find the start of the function they live in:\n\n```\n\n-----\n\n```\n    for offset in offsets:\n      # find function containg the offset\n      func = self.find_func_addr(offset)\n      if func is None:\n        print(\"skip 0x%x: not part of a func...\"%offset)\n        continue\n      if not len(func.predecessors):\n        print(\"skip 0x%x: no predecessor...\"%offset)\n        continue\n      if len(func.predecessors) > 2:\n        print(\"skip 0x%s: too many predecessors (%d)\"%(func.addr,\nlen(func.predecessors)))\n        continue\n      print(\"found potential rc4 code: 0x%x\"%func.addr)\n\n#### We discard an offset if:\n\n it does not belong to a function it belongs to a function with no predecessors (meaning it’s not called) it belongs to a function with more than 2 predecessors (called from more than 2 different places)\n the RC4 function should only be called from one place - 2 is being conservative\n\n Now that we have the start address of a potential RC4 function, we need to:\n\n find the XREF (the CALL rc4 ) find the calling function start address\n\n Which is just repeating what we just did:\n      # list of (start_addr, stop_addr) to emulate\n      explorer = []\n      for pred in func.predecessors:\n        caller = self.find_func_addr(pred.addr)\n        # skip some cases where start_addr == stop_addr\n        if caller is not None and caller.addr != pred.addr:\n          explorer.append((caller.addr, pred.addr))\n          print(\" * found caller (0x%x -> 0x%x)\"%(caller.addr, pred.addr))\n\n At this stage, we should have a list in the form of:\n\n```\n\n-----\n\n```\nexplorer [\n  (addr_start_func1, addr_call_rc4_in_func1),\n  (addr_start_func2, addr_call_rc4_in_func2),\n  ...\n]\n\n#### We can just emulate from the function start address to the call rc4 function\n\n##### address and dump the key from register r9 (according to the x64 fastcall convention, r9\n#### holds the 4th parameter - the pointer to the key in our case).\n\n### 2.2.2. Emulation\n\n#### The emulation goes as follow:\n\n create an initial state simulating a function call at our start address\n we use the CALLLESS option to skip over function calls as they are not related to the key computation\nstate = self.prj.factory.call_state(addr=start_addr)\nstate.options.add(angr.options.CALLLESS)\n\n create a Simulation Manager and then step until one of the state reachs our destination address\nsimgr = self.prj.factory.simulation_manager(state)\nwhile True:\n  simgr.step()\n  for state in simgr.active:\n    key = self.check_state(state, stop_addr)\n    if key is not None:\n      return key\n\n with a few extra conditions to avoid looping when there’s no active path left or when the paths gets too complex (arbitrary pick), it looks like this:\n\n```\n\n-----\n\n```\n  def emulate(self, start_addr, stop_addr, max_iter 3000):\n    \"\"\" symbolic execution from start_addr to stop_addr.\n    max_iter is the maximum number of instructions\n    return None if failed, or [r9]\n    \"\"\"\n    print(\"emulating from 0x%x to 0x%x (max iter = %s)\"%(start_addr, stop_addr,\nmax_iter))\n    state = self.prj.factory.call_state(addr=start_addr)\n    # no function call\n    state.options.add(angr.options.CALLLESS)\n    simgr = self.prj.factory.simulation_manager(state)\n    while True:\n      # advance all states by one basic block\n      simgr.step()\n      max_iter -= 1\n      # very arbitrary picks\n      # we shouldnt run into too complex paths\n      if not max_iter or len(simgr.active) > 10 or not len(simgr.active):\n        return None\n      # check each active\n      for state in simgr.active:\n        key = self.check_state(state, stop_addr)\n        if key is not None:\n          return key\n    return None\n\n#### The check_state function will check if the current state address is the destination address, and if so, will dereference the value of the R9 register (4th parameter) and read a DWORD in there.\n\n I assume the key is always 4 bytes long, however should it not be the case, its length can be read from the stack (5th function parameter).\n  def check_state(self, state, stop_addr):\n    \"\"\" check if a state reached the expected address\n      hook potential calls with unconstrained destinations\n      returns the key if arrived at destination\n    \"\"\"\n    # final destination\n    #if state.addr in range(stop_addr, stop_addr+8):\n    if state.addr == stop_addr:\n      # dereference r9 register and read a DWORD\n      # we assume the key is 4 bytes, we could read its size off the stack\n      return p32(state.solver.eval(state.mem[state.regs.r9].uint32_t.resolved))\n\n```\n\n-----\n\n#### There s an extra twist in the check_state function.\n\n The sample uses API hashing to resolve api proc addresses, and we explicitly told angr to skip function calls (CALLLESS). The effect of the CALLLESS flag is that the return value of all function calls will be unconstrained (symbolic).\n\n So what should have been:\n```\naddress = get_proc_address(0x12345678) // return 0x18032323\n(*0x12345678)(arg1, arg2)\n\n becomes:\naddress = get_proc_address(0x12345678) // return some symbolic constant\n(*????????)(arg1, arg2)\n\n and basically angr stops because there’s too many possible paths (for some reason, even with the CALLLESS flag).\n\n call to resolved function (call to a stack address):\n\n My work around to that was to hook all CALL instructions to a temp address by:\n\n checking if the node successor is reached via a call:\nif block.vex.jumpkind == 'Ijk_Call':\n\n then checking if the call uses a temp value:\nif block.vex.next.tag == 'Iex_RdTmp':\n\n looping over the block instruction to find the actuall call and hooking it with something of ours:\n\n```\n\n-----\n\n```\n        for insn in self.prj.factory.block(block.addr).capstone.insns:\n          if insn.mnemonic == 'call':\n            if insn.address not in self.hooks:\n              print(\"hooking addr=0x%x size=%s\"%(insn.address,\ninsn.size))\n              self.prj.hook(insn.address, hook_api_hash,\nlength=insn.size)\n              # in order to avoid hook twice // angr would warn anyway\n              self.hooks.append(insn.address)\n\n#### The hook is very simple and looks like that:\ndef hook_api_hash(state):\n  \"\"\" hook register calls with this\n  \"\"\"\n  # symbolize return value\n  state.regs.rax = claripy.BVS('ret', 64)\n\n The full check_state function looks like this:\n\n```\n\n-----\n\n```\n  def check_state(self, state, stop_addr):\n    \"\"\" check if a state reached the expected address)\n      hook potential call with unconstrained destinatinations\n      returns the key if arrived at destination\n    \"\"\"\n    # final destination\n    #if state.addr in range(stop_addr, stop_addr+8):\n    if state.addr == stop_addr:\n      # dereference r9 register and read a DWORD\n      # we assume the key is 4 bytes, we could read its size off the stack\n      return p32(state.solver.eval(state.mem[state.regs.r9].uint32_t.resolved))\n    #\n    # hook registers calls (api hashing)\n    # we want to hook all \"call $tmp\", otherwise angr gets lost\n    # even with angr.options.CALLLESS\n    #\n    try:\n      block = state.block()\n    except angr.errors.SimEngineError:\n      return None\n    # verify that the block ends with a call\n    if block.vex.jumpkind == 'Ijk_Call':\n      # the next block is based on tmp value\n      if block.vex.next.tag == 'Iex_RdTmp':\n        # iterates over block instructions to find the call addr and size\n        for insn in self.prj.factory.block(block.addr).capstone.insns:\n          if insn.mnemonic == 'call':\n            if insn.address not in self.hooks:\n              print(\"hooking addr=0x%x size=%s\"%(insn.address,\ninsn.size))\n              self.prj.hook(insn.address, hook_api_hash,\nlength=insn.size)\n              # in order to avoid hook twice // angr would warn anyway\n              self.hooks.append(insn.address)\n    return None\n\n#### in the end we, we can just loop over the (start_addr, stop_addr) tupples, to get a list of potential RC4 keys:\n    # emulate all potential calls\n    potential_keys = []\n    for start, stop in explorer:\n      # emulate\n      key = self.emulate(start, stop)\n      if key:\n        potential_keys.append(key)\n     return potential keys\n\n```\n\n-----\n\n## 2.3. Decrypting\n\n#### now that we constructed a list of potential keys, we can just try them all. using the QuickLZ header, we can know that we found a correct one by matching the size of the data with what’s in the header:\n```\ndef try_to_decrypt(data, potential_keys):\n  ''' try all keys with xor and without\n    it seems the xor is not always applied\n  '''\n  for key in potential_keys:\n    for apply_xor in [True, False]:\n      print(\"trying key %r / xor=%r\"%(key, apply_xor))\n      dec = decrypt(data, key, apply_xor)\n      if dec is not None:\n        return dec\n  return None\ndef decrypt(data, key, apply_xor):\n  ''' decrypt + decompress data\n  '''\n  # RC4 decrypt\n  cipher = ARC4(key)\n  dec = bytearray(cipher.decrypt(data))\n  # dexor\n  if apply_xor:\n    for x in range(len(dec) - 1):\n      dec[x] = ((dec[x] ^ key[x % len(key)]) - dec[x + 1]) & 0xff\n  # Quick check we got valid data\n  # ref: quicklz format: https://github.com/ReSpeak/quicklz/blob/master/Format.md\n  # DWORD at decrypted data+1 should be the length\n  if u32(dec[1:5]) == len(data):\n    return quicklz.decompress(bytes(dec))\n\n The XOR pass doesn’t seem to always be applied, so we try with and without.\n\n## 3. C2 Extraction\n\n#### Extracting the C2 address and campain ID from the unpacked PE is pretty straight forward.\n\n We just need to XOR 2 32 bytes data blob (from the .d section) with each other:\n\n```\n\n-----\n\n```\ndef extract_c2(filename):\n  pe = pefile.PE(filename)\n  data = get_section(pe, \".d\").get_data()\n  key = data[:0x20]\n  conf = data[0x40:0x40+0x20]\n  data = xor(key, conf)\n  camp = u32(data[:4])\n  c2 = data[4:].split(b'\\x00')[0]\n  return {'campaign_id': camp, 'c2': c2}\n\n## 4. Showcase\n% ./icedid_stage1_unpack.py\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin\ngot data blob: 0x4c04b bytes\nfound potential rc4 code: 0x1800026b3\n * found caller (0x180001b77 -> 0x180001bc0)\nemulating from 0x180001b77 to 0x180001bc0 (max iter = 3000)\nfound 1 potential keys: [b'\\xc6B\\xc7\\x11']\ntrying key b'\\xc6B\\xc7\\x11' / xor=True\ndecrypted data: 0x4c042 bytes\nfound 5 elements\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2\n  looks like a PE... {'campaign_id': 109932505, 'c2': b'ilekvoyn.com'}\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3\n- dumped\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4\n\n```\n\n-----\n\n```\n% ./icedid_stage1_unpack.py\nsamples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin\ngot data blob: 0x3820 bytes\nfound potential rc4 code: 0x180003fc1\n * found caller (0x1800011c3 -> 0x180001507)\nemulating from 0x1800011c3 to 0x180001507 (max iter = 3000)\nfound 1 potential keys: [b'k\\xfe\\xfa\\x8b']\ntrying key b'k\\xfe\\xfa\\x8b' / xor=True\ntrying key b'k\\xfe\\xfa\\x8b' / xor=False\ndecrypted data: 0x5714 bytes\nfound 4 elements\n- dumped\nsamples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted\n- dumped\nsamples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted\n- dumped\nsamples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted\n  looks like a PE... {'campaign_id': 429479428, 'c2': b'arelyevennot.top'}\n- dumped\nsamples/17aeebe6c1098a312074b0fdeae6f97339f2d64d66a2b07496bfc1373694a4e3.bin.extracted\n\n```\n\n-----\n\n```\n% ./icedid_stage1_unpack.py\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin\ngot data blob: 0x16064 bytes\nskip 0x6442458550: too many predecessors (4)\nfound potential rc4 code: 0x180003bbf\n * found caller (0x1800016bf -> 0x180001980)\nemulating from 0x1800016bf to 0x180001980 (max iter = 3000)\nhooking addr=0x18000184b size=7\nhooking addr=0x180001c19 size=7\nhooking addr=0x180001c09 size=7\nhooking addr=0x180001bdc size=7\nfound 1 potential keys: [b',u\\xe2I']\ntrying key b',u\\xe2I' / xor=True\ndecrypted data: 0x179f7 bytes\nfound 5 elements\n- dumped\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted\n- dumped\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted\n- dumped\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted\n  looks like a PE... {'campaign_id': 3068011852, 'c2': b'yolneanz.com'}\n- dumped\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted\n- dumped\nsamples/12a692718d21b8dc3a8d5a2715688f533f1a978ee825163d41de11847039393d.bin.extracted\n\n#### The extracted data blobs are:\n\n 2 shellcodes 1 DLL 1 or 2 images:\n% file\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.*\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.0:\ndata\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.1:\ndata\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.2:\nPE32+ executable (DLL) (GUI) x86-64, for MS Windows\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.3:\nJPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length\n16, baseline, precision 8, 800x600, components 3\n0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.bin.extracted.4:\nJPEG image data, Exif Standard: [TIFF image data, big-endian, direntries=7,\nsoftware=Adobe Photoshop 21.2 (Windows), datetime=2021-03-25T08:49:36+07:00],\nbaseline, precision 8, 800x800, components 3\n\n```\n\n-----\n\n## 5. Conclusion\n\n#### While it is certainly not the most optimal method to unpack the samples, it was a fun exercise to do.\n\n The full code is available here: https://github.com/matthw/icedid_stage1_unpack.\n\n Older HackTheBox CTF Cyber Apocalypse 2022: Intergalactic Chase (Reverse)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-30 - Automatically Unpacking IcedID Stage 1 with Angr.pdf"
    ],
    "report_names": [
        "2022-05-30 - Automatically Unpacking IcedID Stage 1 with Angr.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535905,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1654086404,
    "ts_modification_date": 1654086404,
    "files": {
        "pdf": "https://archive.orkl.eu/96a2e4bb8075d274c30fa258f0424df4eae99b67.pdf",
        "text": "https://archive.orkl.eu/96a2e4bb8075d274c30fa258f0424df4eae99b67.txt",
        "img": "https://archive.orkl.eu/96a2e4bb8075d274c30fa258f0424df4eae99b67.jpg"
    }
}