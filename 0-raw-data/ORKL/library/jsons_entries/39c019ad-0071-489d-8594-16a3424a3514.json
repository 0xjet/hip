{
    "id": "39c019ad-0071-489d-8594-16a3424a3514",
    "created_at": "2023-01-12T15:10:42.789502Z",
    "updated_at": "2025-03-27T02:05:46.12166Z",
    "deleted_at": null,
    "sha1_hash": "71517384fcc59314b9cc70b68a08d8dc4f29bb98",
    "title": "2018-02-26 - Analyzing the nasty .NET protection of the Ploutus.D malware",
    "authors": "",
    "file_creation_date": "2022-05-28T17:14:22Z",
    "file_modification_date": "2022-05-28T17:14:22Z",
    "file_size": 321572,
    "plain_text": "# Analyzing the nasty .NET protection of the Ploutus.D malware.\n\n**[antonioparata.blogspot.co.uk/2018/02/analyzing-nasty-net-protection-of.html](http://antonioparata.blogspot.co.uk/2018/02/analyzing-nasty-net-protection-of.html)**\n\nTwitter: [@s4tan](https://twitter.com/s4tan)\n\nEDIT: The source code is now online:\n[https://github.com/enkomio/Conferences/tree/master/HackInBo2018](https://github.com/enkomio/Conferences/tree/master/HackInBo2018)\n\nRecently the ATM malware Ploutus.D reappeared in the news as being used to attack US\nATM ([1]). In this post I'll show a possible analysis approach aimed at understanding its main\nprotection. The protection is composed of different layers of protection, I'll focus on the one\nthat, in my hopinion, is the most annoying, leaving the others out. If you want a clear picture\nof all the implied protections, I strongly recommend you to take a look at the de4dot Reactor\ndeobfuscator code.\n\n## Introduction\n\nReversing .NET malware, in most cases, is not that difficult. This is mostly due to the\nawesome tool dnSpy ([2]), which allows debugging of the decompiled version of the\nAssembly. Most of the .NET malware use some kind of loader which decrypts a blob of data\nand then loads the result through a call to the Assembly.Load method ([3]).\n\nFrom time to time some more advanced protection are involved, like the one analysed by\nTalos in [4]. What the article doesn't say is that in this specific case the malware uses a multi\nfiles assembly ([5]).\n\nThis implies that instead of using the Assembly.Load method, it uses the way less known\n_Assembly.LoadModule method ([6]). This protection method is a bit more difficult to_\nimplement but I have to say that is way more effective as obfuscation. The malware also\n\n\n-----\n\nencrypt the method bodies and decrypt them only when necessary. This protection is easily\novercome by calling the \"Reload All Method Bodies\" command in dnSpy at the right moment\n(as also showed in the Talos article).\n\nPloutus.D is also protected with an obfuscator which encrypts the method bodies and\ndecrypts them only when necessary. The protector used is .NET Reactor ([7]) as also pointed\nout in a presentation by Karspersky ([8]). This particular protection is called NecroBit\n_Protection, and from the product website we can read that:_\n\nNecroBit is a powerful protection technology which stops decompilation. NecroBit\nreplaces the CIL code within methods with encrypted code. This way it is not possible\nto decompile/reverse engineer your method source code.\n\nThe difference with the previous case is that if we try to use the \"Reload All Method Bodies\"\nfeature in dnSpy, it will fail (this is not technically correct since there is nothing to reload as\nwe will see).\n\n## Reversing Ploutus.D obfuscation\n\nTo write this blog post I have reversed the sample with MD5\nae3adcc482edc3e0579e152038c3844e. When I start to analyse a .NET malware, as first\ntask I ran my tool **[Shed ([9]) in order to have a broad overview of what the malware does and](https://github.com/enkomio/shed)**\nto try to extract dynamically loaded Assemblies. In this case I was able to extract some\nuseful strings (like the configured backend usbtest[.]ddns[.]net) but not the Assembly with the\nmethod bodies decrypted (however this is not an error and as we will see it is the correct\nbehaviour).\n\nThe next step is to debug the program with dnSpy. If you run it the following Form will be\ndisplayed:\n\n\n-----\n\nI started to dig a bit on the classes that extend the Form class in order to identify which\ncommands are supported. Unfortunately most of the methods of these classes are empty, as\ncan be seen from the following screenshot:\n\nIt is interesting to note that all the static constructors are not empty. All of them are pretty\nsimple (in some cases they have just one instruction), what it is interesting is that all of them\ncall the same method: P9ZBIKXMsRMxLdTfcG.Nf9E3QXmJD();, which is marked as\n_internal unsafe static void Nf9E3QXmJD()._\n\nBy analysing it, the thing start to get interesting since this method is pretty huge, especially\nsince it implements a very annoying control flow obfuscation. It is interesting to notice that if\nwe set a breakpoint on this method and re-start the debugging session, it is amongst the first\nmethods invoked by the program. Scrolling through the code we can find the following\ninteresting statement:\n```\nif\n(P9ZBIKXMsRMxLdTfcG.Ax6OYTY7tiMf4Yu1B4(P9ZBIKXMsRMxLdTfcG.XnSi7dQe0TUTJbDcxg(P9ZBIKXMs\n \"clrjit.dll\"))\n\n```\nThis piece of code is particularly interesting, since it tries to identify the clrjit.dll module. Once\nfound, it identifies the CLR version, which in my case is 4.0.30319.0. Then, it extracts the\nresource m7fEJg2w6sBe9LM3D3.i4tjc9Xt0Vhu5G72Uh.\n\nAfter a while the getJit string appears in the execution. This function is exported by clrjit.dll\nand it is a very important method since it allows to get a pointer to the compileMethod\nmethod. To know more about it you could refer to my Phrack article about .NET program\ninstrumentation ([10]). We can also identify a call to the VirtualProtect method.\n\n\n-----\n\nWith these information we can start to make some assumption, like that the malware hook\nthe compileMethod method in order to force the compilation of the real MSIL bytecode. Let's\nverify our assumption, in order to do so we need to change tool, in particular we will use\n_WinDbg with the SOS extension (if you want to know more about debugging .NET_\napplications with WinDbg take a look at my presentaion [11]).\n\nIn order to inspect the program at the right moment, we will set an exception when the\n_clrjit.dll library is loaded. This is easily done with the command:_\n```\nsxe ld clrjit.dll\n\n```\nonce that this exception is raised let's inspect the clrjit module as showed in the following\nimage:\n\nThe getJit method is an exported by clrjit dll and returns the address of the VTable of an\n_ICorJitCompiler object, where the first item is a pointer to the compileMethod method, as can_\nbe seen from the source code ([12]). But, since we don't trust the source code, let's debug\nthe getJit method till the ret instruction and inspect the return value stored in eax:\n\nas can be seen from the image above, the address of the compileMethod is at 0x70f049b0.\nNow let's the program run until the main windows is displayed and then break the process in\nthe debugger. Let's display again the content of the VTable (which was 0x70f71420).\n\nAs can be seen from the image above the value of the first entry of the VTable changed to\n\n\n-----\n\nfrom 0x70f049b0 to 002a0000. So our assumption about the hooking of the compileMethod\nwas right :)\n\nNow we want to identify which method hooked the compileMethod method. To do this we will\nload the SOS extension (with the command .loadby SOS clrjit), set a breakpoint at the\n_compileMethod method and when the brakpoint hits, type !CLRStack command to see which_\nmethod was set as replacement. In order to trigger the compileMethod breakpoint I clicked\non a random button in the interface.\n\nfrom the image above we can spot that the interested method is qtlEIBBYuV. Find below the\ndecompiled code of the metohd (I have renamed the argument names and added some\ncomments):\n\nWhat is interesting from the code above is that:\n\nit reads the address of the COREINFO_METHOD_INFO structure at (1)\nwrites back the real MSIL bytecode at (2)\nupdates the fields ILCode and ILCodeSize at (3) and (4)\nfinally call the original compileMethod at (5)\n\nIn this way, it is sure that the correct MSIL code is compiled and executed (for more info on\nthis structure please refer to [10,12]).\n\nFinally, we have a pretty good understanding of how the real code is protected, now we can\ntry to implement a simple program which dumps the real MSIL bytecode and rebuilds the\nassembly. The de4dot tool, instead, uses a different approach, which is based on emulating\nthe decryption code of the method body and then rebuild the assembly.\n\n## Let's the code speak\n\nA possible approach to dump the real MSIL bytecode is:\n\nHook the compileMethod before the malware\nForce all static constructors to be invoked and force compilation of all methods via\n_RuntimeHelpers.PrepareMethod. This will ensure that we are able to grab all the_\nILCode of the various methods.\n\n\n-----\n\nWhen the hook is invoked store the values of the fields ILCode and ILCodeSize. We\nhave to record also which method is currently compiled, this is done with the code\n_getMethodInfoFromModule from [10]._\nRebuild the assembly by using Mono.Cecil or dnlib (my choice)\n\nHowever, for this specific case, I'll use a slightly different approach, which is not as generic\nas the previous one but it is simpler and more interesting imho :)\n\nAs we have seen from the code above, the P9ZBIKXMsRMxLdTfcG.k6dbsY0qhy is a\ndictionary of objects which contains the real MSIL bytecode as value and as key the address\nof the MSIL buffer. What we can do is to read the value of this object via reflection and\nrebuild the original binary. All this without implying the hooking of any methods :)\n\nI have implemented a simple program that extracts those values via reflection, calculates the\naddress of each method and rebuild the assembly. If you want to take a look it, here is the\ncode.\n\nAfter dumped the real MSIL, we can see that now the methods are not empty anymore:\n\n## Conclusion\n\nThe purpose of this post was to show how to analyse, in an effective way, a strongly\nobfuscate malware with the help of different tools and the knowledge of the internal working\nof the .NET framework.\n\nAs an alternative, if you want to obtain a de-obfuscated sample I encourage you to use the\nde4dot tool (and to read the code since this project is a gold mine of information related to\nthe .NET internals).\n\nAt the time of this writing the sample is not correctly deobfuscated by de4dot due to an error\nin the string decryption step. To obtain a deobfuscated sample with the real method body,\njust comment out the string decryption step in ObfuscatedFile.cs.\n\nToo often developers underestimate the power of reflection and as a result it is not\nuncommon to bypass protection (included license verification code) only by using reflection\nand nothing more :)\n\n## References\n\n\n-----\n\n[1] First ‘Jackpotting’ Attacks Hit U.S. ATMs - https://goo.gl/6WY14V\n\n[2] dnSpy - https://github.com/0xd4d/dnSpy\n\n[3] Assembly.Load Method (Byte[]) - https://goo.gl/owZtC1\n\n[4] Recam Redux - DeConfusing ConfuserEx - https://goo.gl/oKgj1k\n\n[5] How to: Build a Multifile Assembly - https://goo.gl/mVdHuU\n\n[6] Assembly.LoadModule Method (String, Byte[]) - https://goo.gl/D6N797\n\n[7] .NET REACTOR - http://www.eziriz.com/dotnet_reactor.htm\n\n[8] Threat hunting .NET malware with YARA.pdf - https://goo.gl/RxEw1G\n\n[9] Shed, .NET runtime inspector - https://github.com/enkomio/shed\n\n[10] http://www.phrack.org/papers/dotnet_instrumentation.html\n\n[11] .NET for hackers - https://www.slideshare.net/s4tan/net-for-hackers\n\n[12] getJit() - https://github.com/dotnet/coreclr/blob/master/src/inc/corjit.h#L241\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-26 - Analyzing the nasty .NET protection of the Ploutus.D malware.pdf"
    ],
    "report_names": [
        "2018-02-26 - Analyzing the nasty .NET protection of the Ploutus.D malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536242,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1653758062,
    "ts_modification_date": 1653758062,
    "files": {
        "pdf": "https://archive.orkl.eu/71517384fcc59314b9cc70b68a08d8dc4f29bb98.pdf",
        "text": "https://archive.orkl.eu/71517384fcc59314b9cc70b68a08d8dc4f29bb98.txt",
        "img": "https://archive.orkl.eu/71517384fcc59314b9cc70b68a08d8dc4f29bb98.jpg"
    }
}