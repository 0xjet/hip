{
    "id": "8c4b0275-21e6-4047-8e24-1920fafc6134",
    "created_at": "2023-01-12T15:07:02.828454Z",
    "updated_at": "2025-03-27T02:07:59.941145Z",
    "deleted_at": null,
    "sha1_hash": "c54e5d6cda744819302959fbb5932341396d6a9d",
    "title": "2018-02-27 - Dissecting Hancitor’s Latest 2018 Packer",
    "authors": "",
    "file_creation_date": "2022-05-29T01:28:48Z",
    "file_modification_date": "2022-05-29T01:28:48Z",
    "file_size": 453812,
    "plain_text": "# Dissecting Hancitor’s Latest 2018 Packer\n\n**[researchcenter.paloaltonetworks.com/2018/02/unit42-dissecting-hancitors-latest-2018-packer/](https://researchcenter.paloaltonetworks.com/2018/02/unit42-dissecting-hancitors-latest-2018-packer/)**\n\nJeff White February 27, 2018\n\nBy [Jeff White](https://unit42.paloaltonetworks.com/author/jeff-white/)\n\nFebruary 27, 2018 at 5:00 AM\n\n[Category: Unit 42](https://unit42.paloaltonetworks.com/category/unit42/)\n\nTags: [hancitor](https://unit42.paloaltonetworks.com/tag/hancitor/)\n\nSummary\n\nOver the past two years, the [Hancitor malware family has been a](https://blog.paloaltonetworks.com/2016/08/unit42-vb-dropper-and-shellcode-for-hancitor-reveal-new-techniques-behind-uptick/) [fairly regular nuisance that defenders on the front line of organizations have](https://blog.paloaltonetworks.com/2016/08/unit42-pythons-and-unicorns-and-hancitoroh-my-decoding-binaries-through-emulation/)\nto deal with on an almost weekly basis. The malware itself has gone through more than 80 variations during this time, sometimes just to define\nnew variables for campaigns and other times a complete rewrite of the malware’s core functionality by the code authors. Every now and then\nthough, they venture out into the unknown with techniques unlike what Hancitor has used before. These occasions tend to be short-lived and I\nlook at them more as “testing” phases. I suspect the malware authors monitor their infection rates and when they deviate from the tried and\ntrue, campaigns end up being less successful. For those interested in an overview of how a typical Hancitor malspam campaign operates, Unit\n[42 recently published a blog on the subject. In this post, I’ll be diving into the technical inner-workings of their latest malware packer.](https://blog.paloaltonetworks.com/2018/02/unit42-compromised-servers-fraud-accounts-recent-hancitor-attacks/)\n\nFor this particular instance, campaigns on January 24, 2018 and January 25, 2018 used a different document format, Rich Text Format (RTF),\n[that leveraged an exploit (CVE-2017-11882) to launch shellcode which executed a PowerShell command used to download the standard](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882)\nbinary which has been used for months. Usually, Hancitor is distributed through Microsoft Word documents utilizing macros but RTF\ndocuments typically require some kind of exploit to execute code. In the past, Hancitor has kept itself at arm’s length from exploitation and\ninstead relied entirely on social-engineering. This most likely helps evade against anti-virus (AV) and endpoint detection and response (EDR)\nsystems monitoring for that type of activity.\n\nThe first RTF variant on the 24 is fairly straightforward; however, on the 25th, the RTF now included an embedded PE file that was entirelyth\ndifferent than their standard binary. This PE file exhibited a new unpacking technique that the Hancitor developers have never employed before\nand this will be the meat of the blog post. My end goal is to identify the standard Hancitor command and control (C2) gate URL’s, which stayed\nthe same even with the new dropper in use.\n\nFor this analysis, I’ll be using the following sample:\n\n**SHA256** B489CA02DCEA8DC7D5420908AD5D58F99A6FEF160721DCECFD512095F2163F7A\n\nRTF Dropper\n\nI won’t be getting into the details of the exploit but suffice to say, they used the CVE-2017-11882 exploit in their RTF document to launch\nshellcode and execute a PowerShell command. The PowerShell command in this campaign will save a base64 encoded PE to disk and then\ncall the Start-Process cmdlet on it.\n\n1 $EUX4JTF7 = '';foreach($82OJU7FY3US in (1..12 | foreach{ '{0:X}' -f (Get Random -Max 235) })){$EUX4JTF7 += \"$82OJU7FY3US\"};$NR3M\n= \"$env:USERPROFILE\\\" + $EUX4JTF7 + \".exe\";\n\n[IO.File]::WriteAllBytes($NR3MNTAYNI, [System.Convert]::FromBase64String('TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAA AA\n<TRUNCATED>…AAAAAAAAAAAAA'));Start-Process $NR3MNTAYNI\n\nHancitor PE\n\nOnce the PE is launched, it will create a simple mutex called “e” and then begin to employ some anti-disassembly techniques that seek to\nhinder static analysis In general most popular disassemblers default to flow oriented disassembly as opposed to linear disassembly This\n\n\n-----\n\nea s t at e t e d sasse b e a a y es st uct o s, t e st uct o ou d s t t e e ecut o o t e p og a to a ot e ocat o, t e\nthe disassembler may follow the instructions to that location to continue analysis. All bytes which would come after the branching may go\nunanalyzed and won’t be disassembled. Abusing this functionality to confuse the disassembler is a very common technique.\nEffectively, this sample builds an address location into a register and then uses that register as the operand for a CALL instruction to shift\nexecution to a section of code that the disassembler hasn’t analyzed. Since the disassembler doesn’t know what value will be in that register\nupon analysis, assuming the code isn’t analyzed due to other reasons, then it just leaves it as ‘data’. In a debugger, this problem is fairly trivial\nto deal with as you can just instruct the debugger to re-analyze the code from any point you choose.\nAfter its initial jump into unanalyzed code, the malware begins to employ more anti-disassembly and anti-debugging techniques. Specifically, it\nstarts executing code where there will be one or two instructions immediately followed by a jump. Normally, you would be able to read\ninstructions linearly and get an understanding of the overall functionality, but with jumps interspersed between each instruction, the flow is\nobscured and harder to analyze as you only ever see one or two pieces of the overall function on your screen. This requires you keep track of\nwhat’s going on, step-by-step.\nIn this case, the first thing the code does is to load the address for VirtualProtect() into the EAX register and build the parameters on the stack\nfor a call to it. Again, using a call to the register further helps prevent static analysis. Once the call is made, it adjusts the privileges for all\nmemory space loaded by this PE to have read, write, and execute (RWE) bits set, shown below. This is also new to the Hancitor malware, but\nis specifically used within the packer which we will discuss shortly.\n\n\n1\n2\n3\n4\n5\n6\n\n\nAddress Size Owner Section Contains Type Access Initial Mapped as\n00400000 00001000 b489ca02 PE header Imag RWE CopyOnWr RWE\n00401000 00008000 b489ca02 .text code Imag RWE CopyOnWr RWE\n00409000 00002000 b489ca02 .rdata imports Imag RWE CopyOnWr RWE\n0040B000 00001000 b489ca02 .data data Imag RWE CopyOnWr RWE\n0040C000 00001000 b489ca02 .rsrc resources Imag RWE CopyOnWr RWE\n\n\nSetting all of the permissions to RWE allows for execution in the program to be transferred to any of the mapped memory regions, whereas\ntypically it’s limited to the “code” section. There is also no reason they couldn’t have contained all of this within the “code” section, so it’s a\ngood indicator for detection when everything is converted to RWE. This is commonly done when there will be code hidden outside of the\noriginally defined area; however, in this sample, they never actually execute code outside of this memory region so it’s a shotgun approach to\nadjusting privileges.\nThe next action it will take, still using the same instruction-jump obfuscation, begins to XOR 0xC80 bytes beginning at address 0x402185 with\nthe value 0xD1. One interesting oddity to their method here is that they move the value 0x5AF06AD1 to the EAX register, but only use the\nlower byte, AL (0xD1), for the XOR and ignore the other three bytes. It wouldn’t be the first time the Hancitor malware has intended to use a\nfull value but introduced errors in their code that caused it to only partially work as intended. The decoding routine looks like the following.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n004040EA  3007      XOR BYTE PTR DS:[EDI],AL\n004040EC  E9 8B000000   JMP b489ca02.0040417C\n-0040417C  41       INC ECX\n0040417D  EB DD      JMP SHORT b489ca02.0040415C\n-0040415C  47       INC EDI\n0040415D  EB D8      JMP SHORT b489ca02.00404137\n-00404137  39F1      CMP ECX,ESI\n00404139  0F81 24FFFFFF  JNO b489ca02.00404063\n-00404063  0F82 81000000  JB b489ca02.004040EA\n\n\nOnce this loop finishes decoding new shellcode, it will transfer execution to address 0x402185 with a JMP instruction.\nTo illustrate looking at assembly that hasn’t been analyzed yet, from a debugger perspective, you would see these bytes as data within the\n“code” section.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n00402185    55       DB 55                     ; CHAR 'U'\n00402186    8B       DB 8B\n00402187    EC       DB EC\n00402188    81       DB 81\n00402189    EC       DB EC\n0040218A    04       DB 04\n0040218B    02       DB 02\n0040218C    00       DB 00\n0040218D    00       DB 00\n0040218E    53       DB 53                     ; CHAR 'S'\n0040218F    56       DB 56                     ; CHAR 'V'\n00402190    57       DB 57                     ; CHAR 'W'\n00402191    60       DB 60                     ; CHAR '`'\n00402192    FC       DB FC\n\n\nSimply telling the debugger to reanalyze the code found will make it human readable.\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n00402185  . 55       PUSH EBP\n00402186  . 8BEC      MOV EBP,ESP\n00402188  . 81EC 04020000  SUB ESP,204\n0040218E  . 53       PUSH EBX\n0040218F  . 56       PUSH ESI\n00402190  . 57       PUSH EDI                   ; b489ca02.00402E05\n00402191  . 60       PUSHAD\n00402192  . FC       CLD\n\n\nInitial Shellcode\nOnce inside this new shellcode it begins to look up the address locations for a number of functions using GetProcAddress(). These functions\nwill be used throughout the unpacking routines. The function names are not obfuscated and, once decoded from the above, can be seen in\nplain text.\n\nSome of the functions and DLL names looked up are listed below:\n\nGetModuleHandleA\nLoadLibraryA\nVirtualAlloc\nVirtualFree\nOutputDebugStringA\nntdll.dll\n_stricmp\nmemset\nmemcpy\n\nThroughout the unpacking, VirtualAlloc(), memcpy(), and VirtualFree() are heavily used for moving data around and overwriting existing data.\n\nOnce it has all of the addresses, the sample will allocate a 0x1000 byte memory page and copy all of the decoded shellcode into it. Next, it will\nbegin to egg hunt for two DWORD values, 0x88BAC570 and 0x48254000 respectively, in which it will find the address four bytes from the start\nof the second egg. Egg hunting allows the code to be position independent and is a technique found in almost all Hancitor variants. After\nidentifying the address, it will be used in another “JMP EAX” instruction to transfer execution to a new function within the copied shellcode, at\noffset 0x3E4, in the newly allocated memory range.\n\nData Setup\n\nFrom a control flow perspective, the same code is being executed, albeit from a new location, which frees up the unpacking functions to\noverwrite the code in the main body of the Hancitor PE.\n\nThe first actions taken is to overwrite code in three locations by copying data toward the end of the “code” section to earlier areas, shown\nbelow.\n\n**Source memcpy()** **Size** **Dest Addr Range**\n\n0x407C9E 0x514 0x4058D4-0x405DE8\n\n0x4078B6 0x3E8 0x40400A-0x4043F2\n\n0x406C36 0xC80 0x402185-0x402E05\n\nDuring this operation, there is another good example that illustrates some of the anti-analysis tricks in use.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n001F0453  EB 10       JMP SHORT 001F0465\n001F0455  82EF 3D      SUB BH,3D\n001F0458  3C 5D       CMP AL,5D\n001F045A  53        PUSH EBX\n001F045B  C8 E8518D     ENTER 51E8,8D\n001F045F  FB        STI\n001F0460  D9D0       FNOP\n001F0462  231B       AND EBX,DWORD PTR DS:[EBX]\n001F0464  14 83       ADC AL,83\n001F0466  C003 89      ROL BYTE PTR DS:[EBX],89\n001F0469  8540 FF      TEST DWORD PTR DS:[EAX-1],EAX\n\n\n-----\n\neg g at t e top o t e code, you ot ce t e J S O 00 0 65 st uct o c s ot actua y t e add ess st g o t e e t\nside of this snippet. This is a common technique to obscure code flow because it was disassembled linearly at the instruction boundaries, but\nthe JMP instruction is redirecting execution outside of the boundary. Once this jump is actually taken and lands in the middle of the shown\ninstruction 0x1F0464, the code will be re-analyzed based on the instruction pointer location and change the meaning entirely.\n\n\n1\n2\n\n\n001F0465  83C0 03      ADD EAX,3\n001F0468  8985 40FFFFFF   MOV DWORD PTR SS:[EBP-C0],EAX\n\n\nUnpacking More Shellcode\nThis next phase is where the unpacking actually occurs and the main purpose of this blog. Before I get into it, I’ll preface it with if you know\nhow RC4 works, you may want to skip ahead as the first two sections will cover the RC4 key-scheduling algorithm (KSA) and the RC4 pseudorandom generation algorithm (PRGA), which are used as part of this unpacking algorithm.\nIn general, packers seek to modify data or code in such a way that it’s unlike the original content, effectively obfuscating it. Packers are not\ninherently bad but it adds another layer of evasion to malware, so they tend to go hand-in-hand. Each packer typically attempts to put their own\nspin on how to do this by coming up with unique algorithms; this makes it difficult to programmatically unpack malware at scale but also allows\nfor varying levels of protection. Code packing algorithms can be as simple as a one-byte XOR across the data to full-on encryption or\ncompression.\nIn the case of this malware, they’ve created an algorithm which initially uses RC4 KSA and incorporates the RC4 PRGA within a loop to\ngenerate a table of offsets that dictate the order in which to piece back together more shellcode.\n\nRC4 KSA\nTo kick things off, this sample creates the substitution box (S-box) used in RC4 KSA. First, it will allocate an array of incrementing values\nstarting from 0x0 to 0x100 (0-256) entirely on the stack.\nI’ve annotated the assembly below which covers building and modifying the S-box, which is heavily utilized throughout the rest of the\nunpacking.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# Counter Check\n001F04CA   8B4D F8      MOV ECX,DWORD PTR SS:[EBP-8]         ; Set ECX to counter value\n001F04CD   83C1 01      ADD ECX,1                   ; Increment counter by 0x1\n001F04D0   894D F8      MOV DWORD PTR SS:[EBP-8],ECX         ; Store counter on stack\n001F04D3   817D F8 00010000 CMP DWORD PTR SS:[EBP-8],100         ; Compare counter to 0x100\n001F04DA   74 61       JE SHORT 001F053D               ; End loop if counter is at 0x100\n# Add previous loop value to value found at index in array 2 and the counter\n001F04DC   8B45 F8      MOV EAX,DWORD PTR SS:[EBP-8]         ; Set EAX to counter value\n001F04DF   33D2       XOR EDX,EDX                  ; Zero-out EDX register\n001F04E1   F7B5 48FFFFFF   DIV DWORD PTR SS:[EBP-B8]           ; Divide counter by 0x10 to retrieve index value for array\n2\n001F04E7   8B85 40FFFFFF   MOV EAX,DWORD PTR SS:[EBP-C0]         ; Set EAX to value of array 2 offset\n001F04ED   0FB60410     MOVZX EAX,BYTE PTR DS:[EAX+EDX]        ; Set EAX to value at array 2 offset + counter\n001F04F1   0345 EC      ADD EAX,DWORD PTR SS:[EBP-14]         ; Add previous result to EAX (0 on first run)\n001F04F4   8B4D F8      MOV ECX,DWORD PTR SS:[EBP-8]         ; Set ECX to counter value\n001F04F7   0FB6940D FCFDFFFF MOVZX EDX,BYTE PTR SS:[EBP+ECX-204]      ; Set EDX to value of array 1 offset + counter\n001F04FF   03C2       ADD EAX,EDX                  ; Add the array 1 and array 2 values\n001F0501   33D2       XOR EDX,EDX                  ; Zero-out EDX register\n001F0503   B9 00010000    MOV ECX,100                  ; Set ECX 0x100\n001F0508   F7F1       DIV ECX                    ; Divide value in new value by 0x100\n001F050A   8955 EC      MOV DWORD PTR SS:[EBP-14],EDX         ; Copy remainder value to stack (now \"old\" value)\n001F050D   8B55 F8      MOV EDX,DWORD PTR SS:[EBP-8]          ; Set EDX to counter value\n# Swap the array 1 dereferenced values\n001F0510   8A8415 FCFDFFFF  MOV AL,BYTE PTR SS:[EBP+EDX-204]       ; Set AL to value of array 1 offset + counter\n001F0517   8845 F7      MOV BYTE PTR SS:[EBP-9],AL          ; Store original value on stack\n001F051A   8B4D F8      MOV ECX,DWORD PTR SS:[EBP-8]         ; Set ECX to counter value\n001F051D   8B55 EC      MOV EDX,DWORD PTR SS:[EBP-14]         ; Copy \"old\" value to EDX\n001F0520   8A8415 FCFDFFFF  MOV AL,BYTE PTR SS:[EBP+EDX-204]       ; Set AL to value of array 1 offset + old value\n001F0527   88840D FCFDFFFF  MOV BYTE PTR SS:[EBP+ECX-204],AL       ; Set first index in array 1 to new value\n001F052E   8B4D EC      MOV ECX,DWORD PTR SS:[EBP-14]         ; Set ECX to counter value\n001F0531   8A55 F7      MOV DL,BYTE PTR SS:[EBP-9]          ; Copy \"old\" value from stack\n001F0534   88940D FCFDFFFF  MOV BYTE PTR SS:[EBP+ECX-204],DL       ; Set second index in array 1 to old value\n001F053B  ^ EB 8D       JMP SHORT 001F04CA              ; Next iteration\n\n\nIn this case, there are two arrays, the S-box built on the stack and another 16-byte “key” array found at 0x455 into the new shellcode. This key\narray is used to modify values throughout the KSA. Effectively, it takes the counter and uses 0x10 to calculate its modulo, afterwards this is\nused as an index into the key array. The dereferenced value found at the index is added to the “final” value from the previous iteration. In the\ncase of the first iteration, this “final” value will be zero. Once those two values are added together, it will add the counter value to the sum and\nuse 0x100 to calculate its modulo, becoming the new “final” value for the next iteration.\nAfter completing that equation, it takes the “final” value as an index in the 256-byte S-box array and swaps the dereferenced value with the\ndereferenced value found at the index in the first array using the counter. This is the RC4 KSA in a nut shell.\nHere is an example of this on iteration 0x14 in the loop, after some of the data has been modified already. You can see that after 0xC6, at\noffset 0x13, there are incrementing values: 0x14, 0x15, 0x16, 0x17, etc.\n\n\n-----\n\nFor value 0x14, it retrieves the modulus of 0x4 by using 0x10 for the calculation, which is then used to find the additive value in the key\narray. The value at key[4] is 0x5D and this is added to the previous “final” value, 0xC6, which can be seen at offset 0x13.\n\n1 0x5D + 0xC6 = 0x123\n\nNext, it uses the counter as an index and dereferences the value to add into the equation. For the first couple of runs, the dereferenced value\nequates to the counter, but eventually these begin to overwrite and the values change accordingly.\n\n1 0x123 + 0x14 = 0x137 % 0x100 = 0x37\n\nNow the values at sbox1[0x37] and sbox1[0x14] are swapped, as can be seen below.\n\nOn the next iteration, with the key value being 0x53, it would look like this:\n\n1 (0x53 + 0x37 + 0x15) % 0x100 = 0x9F\n\nThe values at sbox1[0x9F] and sbox1[0x15] would be swapped.\n\nYou’ll see that at offset 0x1A in the example output above, the value is 0xC. On iteration 0x1A then, 0xC will be the value added to the key and\nthe previous “final” value. This happens for 256 iterations and every value gets shifted around from its original starting point. Talos has a nice\n[blog from 2014 that talks about S-box creation in malware and the RC4 entry on Wikipedia has a succinct overview as well.](http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html)\n\nI’ve recreated the logic shown previously Python as it may be easier to illustrate it with code.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ndef sbox1init():\nreturn [x for x in range(0, 0x100)]\ndef rc4ksa(sbox1, key):\noldValue = 0x0\nfor counter in range(0, len(sbox1)):\naddValue = key[counter % len(key)]\nfnlValue = (oldValue + addValue + sbox1[counter]) % 0x100\nsbox1[fnlValue], sbox1[counter] = sbox1[counter], sbox1[fnlValue]\noldValue = fnlValue\nreturn sbox1\nkey = [0x82, 0xEF, 0x3D, 0x3C, 0x5D, 0x53, 0xC8, 0xE8, 0x51, 0x8D, 0xFB, 0xD9, 0xD0, 0x23, 0x1B, 0x14]\nsbox1 = rc4ksa(sbox1init(), key)\n\n\nIn the Python codes first iteration, where the value in sbox1[0x0] is 0x00 and key[0x0] is 0x82, you would add 0x0 to 0x82 to 0x0 (the value at\nsbox1[counter]) and divide by 0x100. The remainder, 0x82, would then be placed in sbox1[0x0] and the value which was at sbox1[0x0] would\n[be swapped into sbox1[0x82]. There are a lot of cleaner examples of code available online for the RC4 KSA but for the sake of learning, along](https://en.wikipedia.org/wiki/RC4)\nwith making sure that if there were any errors introduced by the malware authors, I created everything based on their logic used.\n\nRC4 PRGA\n\nThe RC4 PRGA is used within the main unpacking loop specifically to generate a keystream value but how that value is used is where the\nmalware author begins to diverge from RC4.\n\nI’ll briefly cover PRGA and then move onto the parent unpacking loop, which will make reference back to this algorithm.\n\nUsing a loop counter as an index into the original S-box, PRGA will dereference the value at sbox1[counter] and add it to the previous\nkeystream value to create the second index. These values will then get swapped around in the S-box, similar to how the KSA does it. Finally, it\nwill retrieve the value at sbox1[counter] and sbox1[secondIndex], add them together, and then use them in a modulo calculation with 0x100 to\ngenerate the new keystream value.\n\nFor example, the first byte referenced (counter starting at 0x1 in this case) is sbox1[0x1], which is 0x7 after completing the KSA. The value at\nsbox1[0x7] is 0xA6 and they swap values so that sbox1[0x1] is 0xA6 and the value at sbox1[0x7] is 0x7. It then adds 0xA6 to 0x7 to make\n\n\n-----\n\n0 a d ta es t e de e e e ced a ue at sbo [0 ], t s case 0 58, as t e eyst ea a ue\nNow, at this point, in regular RC4, the new keystream value would be used in an XOR operation to decode or encode a byte of ciphertext or\nplaintext. As you can guess, that is not the case with this malware.\n\nOffset Table\nTaking a step back, once the S-box generation is complete, the next step is to allocate two more regions of memory. It fills the first region,\nagain, with incrementing values until it hits 0x5C36 but this time each value is a DWORD instead of a singular byte. This region will show itself\nto be yet another S-box in function.\nNext, it launches into the main unpacking loop, which is the meat of the operation. On each iteration of this loop, it will use an inner-loop (the\npreviously detailed RC4 PRGA) to retrieve a keystream byte – performed four times each parent loop iteration.\nAfter obtaining the four bytes of keystream values, it will combine them into a DWORD and use it in a modulo calculation with the loop counter\nfrom the parent loop, decrementing by one each iteration from the length of the data (0x5C36).\nFor example, the first four bytes of keystream values are 0x58, 0x58, 0xF2, and 0xEA, which is combined to form 0xEAF25858.\n\n1 0xEAF25858 % 0x5C36 = 0x5200\n\nIt takes the result of this operation and uses it as an index into the second S-Box of DWORD’s. Next, it takes the dereferenced value found at\nthe index and stores it in the third memory region, incrementing by an offset of 4 each time. Finally, it swaps the dereferenced values in the\nsecond memory region with the value found at the index into the second S-box.\nIn this case, the first DWORD in the third memory region will be 0x5200. It swaps the dereferenced values in the second memory region with\nthe counter value so the value at the offset for 0x5200 will become 0x5C35 (decremented by 4 bytes) and the value found at the offset for\n0x5C35 will be 0x5200.\nThis process continues until the parent loop finishes and, once complete, it will allocate another memory region wherein it copies 0x5C36 bytes\nfrom address 0x401000 in the main program.\nAlright, if you’ve stuck with me this long, what I want to convey is that all of the above is to create an elaborate table of DWORD offsets, used\nas indexes, that define how the data will be unshuffled, which is finally what happens next.\nFor each byte in the new memory region, which is the data just copied from address range 0x401000-0x406C36, it will add the corresponding\nDWORD value for the respective iteration to the base of 0x401000 and copy that byte over. As a reminder, the data being copied at this point\nis the same data initially moved into position by the first three memcpy() calls.\nThe first DWORD in the third memory region is 0x5200, as discussed previously, and the first byte at 0x401000 is 0x8B, thus at 0x406200\n(0x401000 + 0x5200) the value 0x8B will be placed. At no point are any of the bytes manipulated, as would be standard in an RC4\nimplementation, but instead are just rearranged into their respective order.\nTo help illustrate with code, below is the full implementation of the algorithm in Python. To save space, I’ve removed the data but this is\n[available in full on GitHub if you want to review further.](https://github.com/pan-unit42/public_tools/blob/master/hancitor/hancitor_offsetgen.py)\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\ndef sbox1init():\nreturn [x for x in range(0, 0x100)]\ndef sbox2init():\nreturn [x for x in range(0, 0x5C36)]\ndef rc4ksa(sbox1, key):\noldValue = 0x0\nfor counter in range(0, len(sbox1)):\naddValue = key[counter % len(key)]\nfnlValue = (oldValue + addValue + sbox1[counter]) % 0x100\nsbox1[fnlValue], sbox1[counter] = sbox1[counter], sbox1[fnlValue]\noldValue = fnlValue\nreturn sbox1\ndef offsetGen(sbox1, sbox2):\noffsetTable = []\ninnerCount = 1\noldValue = 0x0\nfor counter in range(len(sbox2), 0, -1):\nfnlValue = \"\"\nfor x in range(0, 4):\ninnerIdx = innerCount % len(sbox1)\noldValue = (sbox1[innerIdx] + oldValue) % 0x100\naddValue = (sbox1[oldValue] + sbox1[innerIdx]) % 0x100\nsbox1[innerIdx], sbox1[oldValue] = sbox1[oldValue], sbox1[innerIdx]\nfnlValue = \"%02X\" % sbox1[addValue] + fnlValue\ninnerCount += 1\nfnlValue = int(fnlValue, 16) % counter\noffsetTable.append(sbox2[fnlValue])\nsbox2[fnlValue], sbox2[counter-1] = sbox2[counter-1], sbox2[fnlValue]\nreturn offsetTable\ndef unshuffle(data, offsetTable):\nunshuffle = [0x0] * len(offsetTable)\ndata = [data[x:x+2] for x in range(0, len(data), 2)]\nfor counter, entry in enumerate(offsetTable):\nunshuffle[entry] = chr(int(data[counter], 16))\nreturn \"\".join(unshuffle)\nkey = [0x82, 0xEF, 0x3D, 0x3C, 0x5D, 0x53, 0xC8, 0xE8, 0x51, 0x8D, 0xFB, 0xD9, 0xD0, 0x23, 0x1B, 0x14]\ndata = \"\"\noffsetTable = offsetGen(rc4ksa(sbox1init(), key), sbox2init())\ndata = unshuffle(data, offsetTable)\n\n\nThus, concludes the unpacking algorithm. You’ll see familiar strings for the actual Hancitor malware once it finishes.\n\nHancitor\n\nBefore execution shifts back to the main program, they use more anti-debugging tricks by calling the OutputDebugStringA() function to check\nwhether or not the program is being debugged. Once that check is passed, it will begin executing the code found at 0x404000.\n\nI won’t spend too much time on the functionality of Hancitor as it has been blogged about endlessly but this is what this particular sample will\ndo.\n\nGet OS version\nGet adapter address\nGet Windows directory\nGet volume information\nCheck external IP with api[.]ipify[.]org\n\nOnce it has the information it needs, depending on whether you’re running on x86 or x64 architecture, it formats the following string used in the\ninitial POST to the Hancitor gate.\n\nAfter filling it out it will look similar to the below.\n\n\n-----\n\nGates\n\n[Going back to the entire reason I even delved into this was that I’ve maintained a Hancitor decoder for the past two years and, with each new](https://github.com/pan-unit42/public_tools/blob/master/hancitor/h_decrypt.py)\nvariant, I try to find a way to decode out the Hancitor gates so they can quickly be identified and blocked. This variant, even after all of the\nabove unpacking, still left me in the dark as to where the gates were.\n\nTo figure that out, we have to look a bit further into the code. At the address 0x402B51 in the unpacked shellcode we’ll find a series of\nWindows decryption calls that take a blob of encrypted data, decrypt it, and reveal the Hancitor gate URL’s and campaign code.\n\nCryptAcquireContextA\nCryptCreasteHash\nCryptHashData\nCryptDeriveKey\nCryptDecrypt\nCryptDestroyHash\nCryptDestroyKey\n\nThe algorithm in use here is SHA1 hashing with actual RC4 encryption. It uses an 8-byte value (0xAAE8678C261EC5DB) to derive the SHA1\nkey and then decrypts 0x2000 bytes.\n\nThe first entry is the campaign code which correlates to the date the campaign was ran on, in this case January 24, subsequently followed byth\nthe three Hancitor gates.\n\nConclusion\n\nWhile Hancitor continues to evolve, they stick to a fairly strict playbook. This sample diverged from that playbook quite heavily but only saw\nusage in one campaign before they reverted back to other, older, variants. This may be due to the way it’s packed being detected more\nfrequently or some other unknown reason that caused a drop in their infection rates that prompted removing it. Either way, it’s important to\ncontinue tracking their operation and documenting new techniques and tactics used by this adversary.\n\nPalo Alto Networks customers are protected from Hancitor by WildFire and Traps. This threat can be tracked within AutoFocus by using the\n[Hancitor tag.](https://autofocus.paloaltonetworks.com/#/tag/Unit42.Hancitor)\n\nIOCs\n\nHancitor Gates\n\nhxxp://naveundpa[.]com/ls5/forum[.]php\nhxxp://undronride[.]ru/ls5/forum[.]php\nhxxp://dingparjushis[.]ru/ls5/forum[.]php\n\nUser-Agent\n\nMozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko\n\n**Get updates from**\n\n**Palo Alto**\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy Statement.](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-27 - Dissecting Hancitor’s Latest 2018 Packer.pdf"
    ],
    "report_names": [
        "2018-02-27 - Dissecting Hancitor’s Latest 2018 Packer.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "b23e717c-0b27-47e0-b3c8-4defe6dd857f",
            "created_at": "2023-01-06T13:46:38.367369Z",
            "updated_at": "2025-03-27T02:00:02.815758Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "ATK35",
                "Peach Sandstorm",
                "TA451",
                "APT 33",
                "Elfin",
                "Refined Kitten",
                "MAGNALLIUM",
                "HOLMIUM",
                "COBALT TRINITY",
                "G0064"
            ],
            "source_name": "MISPGALAXY:APT33",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e5ff825b-0456-4013-b90a-971b93def74a",
            "created_at": "2022-10-25T15:50:23.824058Z",
            "updated_at": "2025-03-27T02:00:55.553346Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "APT33",
                "HOLMIUM",
                "Elfin",
                "Peach Sandstorm"
            ],
            "source_name": "MITRE:APT33",
            "tools": [
                "PowerSploit",
                "AutoIt backdoor",
                "PoshC2",
                "Mimikatz",
                "NanoCore",
                "DEADWOOD",
                "StoneDrill",
                "POWERTON",
                "LaZagne",
                "TURNEDUP",
                "NETWIRE",
                "Pupy",
                "ftp",
                "Shamoon"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536022,
    "ts_updated_at": 1743041279,
    "ts_creation_date": 1653787728,
    "ts_modification_date": 1653787728,
    "files": {
        "pdf": "https://archive.orkl.eu/c54e5d6cda744819302959fbb5932341396d6a9d.pdf",
        "text": "https://archive.orkl.eu/c54e5d6cda744819302959fbb5932341396d6a9d.txt",
        "img": "https://archive.orkl.eu/c54e5d6cda744819302959fbb5932341396d6a9d.jpg"
    }
}