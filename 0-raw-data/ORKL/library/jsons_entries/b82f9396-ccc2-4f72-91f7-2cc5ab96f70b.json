{
    "id": "b82f9396-ccc2-4f72-91f7-2cc5ab96f70b",
    "created_at": "2023-01-12T15:05:50.85881Z",
    "updated_at": "2025-03-27T02:06:06.475259Z",
    "deleted_at": null,
    "sha1_hash": "1742c10efe80de96deaf3ad40b820fb2954b838f",
    "title": "2019-08-29 - Gootkit Banking Trojan - Part 2- Persistence & Other Capabilities",
    "authors": "",
    "file_creation_date": "2022-05-27T22:00:59Z",
    "file_modification_date": "2022-05-27T22:00:59Z",
    "file_size": 1133930,
    "plain_text": "# Gootkit Banking Trojan | Part 2: Persistence & Other Capabilities\n\n**[sentinelone.com/blog/gootkit-banking-trojan-persistence-other-capabilities/](https://www.sentinelone.com/blog/gootkit-banking-trojan-persistence-other-capabilities/)**\n\nDaniel Bunce\n\n_[Following on from the previous post, Daniel continues exploring the Gootkit banking trojan,](https://www.sentinelone.com/blog/gootkit-banking-trojan-deep-dive-anti-analysis-features/)_\n_revealing its persistence techniques and other capabilities._\n\nThe Gootkit Banking Trojan was discovered back in 2014, and utilizes the Node.js library to\nperform a range of malicious tasks, from website injections and password grabbing, all the\nway up to video recording and remote VNC capabilities. Since its discovery in 2014, the\nactors behind Gootkit have continued to update the codebase to slow down analysis and\nthwart automated sandboxes.\nIn [the previous post, I explored Gootkit’s Anti-Analysis features. In this post, we’ll take a look](https://www.sentinelone.com/blog/gootkit-banking-trojan-deep-dive-anti-analysis-features/)\ninto the first stage of Gootkit and figure out how it achieves persistence on an infected\nsystem, as well as reveal some other tricks it has available.\n\n**MD5 of Packed Sample:** `0b50ae28e1c6945d23f59dd2e17b5632`\n\n## Onboard Configuration\n\nBefore we get into the persistence and C2 communication routines, let’s first take a look at\nthe onboard configuration, and how it is stored.\n\n\n-----\n\nThe first time that the configuration is “mentioned” in the sample is immediately after the antianalysis mechanisms that were covered in the previous post. A quick glance at the code may\n[leave you thinking that Gootkit is decrypting some shellcode to be used by the sample – but](https://www.sentinelone.com/blog/malicious-input-how-hackers-use-shellcode/)\nrunning this in a debugger shows otherwise. The decryption routine is fairly simple; a basic\n```\nXOR loop with a differentiating key based on imul and idiv calculations. The base key\n\n```\nvalue is `0x22, and the` `idiv and` `imul values are constant throughout each iteration;`\n```\n0x85 and 0x03 respectively. A Python script of this decryption routine can be seen in the\n\n```\nimage below.\n\n\n-----\n\nAfter decrypting the data manually, we can easily distinguish that this is in fact the\nconfiguration used by Gootkit to retrieve the next stage:\n```\nme.sunballast.fr koohy.top 2700 svchost.exe\n\n```\nEach value is split by multiple null bytes, meaning pretty much all of this configuration is null\nbytes. The first two values are obviously URLs, and the final value is the name of the\nprocess that the downloader could inject into. The last two values are also set as\nenvironment variables – specifically `vendor_id& nbsp;and` `mainprocessoverride . The`\n```\nvendor_id variable is given the value exe_scheduler_2700, and\nmainprocessoverride is given the value svchost.exe . These variables are not used in\n\n```\nthe downloader aside from setup, and so it can be assumed that it is used in the final stage.\nOnce the environment variables have been created and assigned values, four important\nthreads are kicked off; a C2 Retrieve thread, a Browser Injection thread, a Persistence\nthread, and a Kill Switch thread. Let’s start off with the Persistence thread.\n\n\n-----\n\n## Persistence Capabilities\n\nIn this sample of Gootkit, there are two persistence options available. First, there is the usual\nmethod of achieving persistence through a created service. In this case, Gootkit will generate\na random filename, using the Mersenne Twister, based off of filenames in `System32, and`\nthen proceed to create a file under the same name in the `%SystemRoot% . Upon testing this`\nfunction, a file called `msfearch.exe was created. A service is then created under the same`\nname, and then executed. Finally, the original executable cleans up by deleting itself from\ndisk and exiting, leaving the created service running.\n\n\n-----\n\nThe second persistence routine is a lot more interesting, and has been covered quite often\nbefore. This routine is most commonly used in Gootkit infections, as creating a service\nrequires administrator privileges – this does not.\n\nIt starts by creating a simple `.inf file, which is given the same name as the running`\nexecutable, and placed in the same directory. The contents of the file can be seen below:\n\nThen, the sample will create a registry key located at:\n```\nSoftwareMicrosoftIEAKGroupPolicyPendingGPOs\n\n```\n\n-----\n\nAnd then create three values inside this key: `Count,` `Path1, and` `Section1 .` `Count is`\nassigned the value `0x1, Path1 is assigned the path to the INF file, and` `Section1 is`\nassigned the string `[DefaultInstall], which is also present inside the INF file. And that`\nis the setup complete.\nThe way this functions is `explorer.exe will load Group Policy Objects (GPO) whenever it`\nis loaded – specifically at runtime. What Gootkit does is it creates a Pending GPO for the\nInternet Explorer Administration Kit (IEAK), which points directly at the INF file. When\n```\nexplorer.exe is loaded at runtime, it will execute the [DefaultInstall] inside the\n\n```\ncreated file, which will execute the Gootkit executable.\n\n## Loader Update Thread\n\nWith the persistence thread covered, let’s move onto analyzing the C2 Receive thread. This\nwas particularly difficult to analyze due to the fact that the command and control server went\noffline very quickly, and so at first glance it looked like the thread was responsible for\ndownloading the final stage and constantly updating it, but as I dug deeper, this was proven\nincorrect\n\n\n-----\n\nThe function is not extremely complex – to put simply, Gootkit will check if a variable is set to\n**0 or 1, and if it is set to 1, it will exit the thread. This variable is only activated inside the**\n```\nKill Switch function, which we will look at soon.\n\n```\nContinuing on, the sample appends `/rpersist4/-1531849038 to the URL, where the`\n```\n-1531849038 is the CRC32 hash of the binary – converted to decimal. Then, depending on\n\n```\nthe architecture, `rbody32 or` `rbody64 will be appended to the URL.`\n\n\n-----\n\nThen the actual connection takes place. Interestingly, there are two means of communication\nas well – it can either occur through WinInet functions such as `InternetOpenW, or it can`\noccur through WinHTTP functions such as `WinHttpOpen, although I have yet to see it call`\nthe WinHTTP functions – regardless of privileges.\n\nBefore reaching out to the C2, Gootkit will first add to the headers of the GET request. These\nadditions can be seen below:\n```\nX-File-Name:      Filename\nX-User-Name:      Username\nX-ComputerName:     Computername\nX-OSVersion:      6.1.7601|Service Pack 1 1.0|1|0x00000100\nX-VendorId:       2700\nX-IsTrustedComputer:  1\nX-HTTP-Agent:      WININET\nX-Proxy-Present:    False\nX-Proxy-Used:      False\nX-Proxy-AutoDetect:   False\n\n```\nThe X-IsTrustedComputer is only set to 1 if the `crackmeololo environment variable is`\nset, otherwise it is set to 0. This could be seen as another anti-analysis/anti-sandbox/anti-VM\nmechanism, although it’s difficult to say without seeing the backend.\n\n\n-----\n\nIf the connection between the sample and the C2 fails, it will attempt to connect to the other\nC2s found in the configuration. If the connection is successful and the server returns an\nexecutable, Gootkit will create a randomly named file in the Temporary directory, and execute\nit with the `--reinstall argument, using` `CreateProcessW . As a result of this, we can`\nfully understand that this thread is in fact an “updater” thread, which will continuously check\nin with the C2 server, waiting for any updates to the loader.\n\n\n-----\n\nNow that this function has been covered, let’s move over to the Kill Switch function briefly,\nbefore going onto the Browser Injection function.\n\n## Kill Switch\n\nThe Kill Switch thread is only triggered if `uqjckeguhl.tmp is located in` `.. AppDataLocal ‐`\n```\nTemp or .. Local Settings Temp . If the file exists, then Gootkit begins to clean up after\n\n```\nitself – it will kill all running threads, and restart the computer. It’s quite unclear as to why this\nis a feature, as persistence is established before the Kill Switch thread is executed, and so\nsimply restarting the computer will end up executing the loader again – however, if a loader\nupdate is issued and installed on the infected system, causing a reboot could be helpful in\npreventing several instances from running at once.\n\nAnd finally, on to the Browser Injection function.\n\n## Browser Injection\n\nThe Browser Injection function is quite interesting, as it is responsible for two tasks;\nexecuting itself with the `--vwxyz argument, and injecting two DLLs into running browsers.`\nWe’re going to focus on the second task.\n\nIn order to inject a DLL into a browser, there must already be a DLL residing somewhere –\nwhich there is. In fact, there are 2 encrypted DLLs stored in the binary; an x86 DLL and an\nx64 DLL, which are decrypted with a simple `XOR . What is also interesting is that there`\nseems to be possible placeholders in other variants, as this sample checks for\n```\n0x11223344 and 0x55667788 in both DLLs, in order to replace the values with\n0x12 and 0x13 respectively.\n\n```\n\n-----\n\nWith both executables decrypted, Gootkit alters the values to `0x3 for the following registry`\nkeys:\n```\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones02500\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones12500\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones22500\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones32500\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones42500\nSoftwareMicrosoftWindowsCurrentVersionInternet SettingsZones52500\n\n```\n\n-----\n\nThis results in disabling Internet Explorer Protected Mode for each security zone in use.\nFrom there, Gootkit will move onto scanning all running processes until it locates an active\nbrowser. In order to do this, it will import and call `NtQuerySystemInformation(),`\nrequesting System Process Information. This returns a list of running processes. Using this\nlist, Gootkit will open each process, check the process architecture using\n```\nIsWow64Process(), and then CRC-32 hash the (uppercase) process name. This hash is\n\n```\nthen passed onto a function responsible for detection and injection. A list of targeted\nbrowsers and their corresponding hashes can be seen below.\n\n\n-----\n\n```\nMicrosoft EdgeCP:   0x2993125A\nInternet Explorer:  0x922DF04\nFirefox:       0x662D9D39\nChrome:        0xC84F40F0\nOpera:        0x3D75A3FF\nSafari:        0xDCFC6E80\nUnknown:       0xEB71057E\n\n```\n\n-----\n\nThe injection technique used by Gootkit is nothing special, and is quite common. The sample\ncalls `NtCreateSection, and will then map that section into the Browser using`\n```\nNtMapViewOfSection . Both DLLs seem to be mapped into memory as well, regardless of\n\n```\narchitecture. Once the files have been injected, the function will return back to the Process\nSearching function, until another browser is detected. And that brings an end to the browser\ninjection!\n\n\n-----\n\n**MD5 of x86 DLL:** `57e2f2b611d400c7e26a15d52e63fd7f`\n**MD5 of x64 DLL:** `7e9f9b2d12e55177fa790792c824739a`\nFrom a quick glance at the injected DLLs, they seem to contain a few hooking functions that\nseem to hook `CertVerifyCertificateChainPolicy and` `CertGetCertificateChain,`\nas well as potentially acting as some form of proxy to intercept requests and redirect them\nbased on information from the C2 server or the Node.js payload – my main reasoning behind\n\n\n-----\n\nthis is that infecting a VM with Gootkit and trying to browse the internet using Internet\nExplorer is unsuccessful, as if connections were being prevented by a proxy, although this\ndoes require further analysis.\n\nIn the [next post, we will take a look at what happens when Gootkit is called with the](https://www.sentinelone.com/blog/gootkit-banking-trojan-retrieving-final-payload/) `--`\n```\nvwxyz argument, and then take a quick peek into the final Node.js payload that is retrieved\n\n```\nfrom the Command and Control server!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-29 - Gootkit Banking Trojan - Part 2- Persistence & Other Capabilities.pdf"
    ],
    "report_names": [
        "2019-08-29 - Gootkit Banking Trojan - Part 2- Persistence & Other Capabilities.pdf"
    ],
    "threat_actors": [
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535950,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1653688859,
    "ts_modification_date": 1653688859,
    "files": {
        "pdf": "https://archive.orkl.eu/1742c10efe80de96deaf3ad40b820fb2954b838f.pdf",
        "text": "https://archive.orkl.eu/1742c10efe80de96deaf3ad40b820fb2954b838f.txt",
        "img": "https://archive.orkl.eu/1742c10efe80de96deaf3ad40b820fb2954b838f.jpg"
    }
}