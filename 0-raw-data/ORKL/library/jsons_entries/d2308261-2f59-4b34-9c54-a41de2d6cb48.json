{
    "id": "d2308261-2f59-4b34-9c54-a41de2d6cb48",
    "created_at": "2023-01-12T15:08:24.032064Z",
    "updated_at": "2025-03-27T02:06:11.547573Z",
    "deleted_at": null,
    "sha1_hash": "fb726e7521c1aca8dd691e78c0d60e4885160659",
    "title": "2020-12-20 - A Look into SUNBURST’s DGA",
    "authors": "",
    "file_creation_date": "2022-05-27T19:02:00Z",
    "file_modification_date": "2022-05-27T19:02:00Z",
    "file_size": 649918,
    "plain_text": "# A Look into SUNBURST’s DGA\n\n**[medium.com/insomniacs/a-look-into-sunbursts-dga-ba4029193947](https://medium.com/insomniacs/a-look-into-sunbursts-dga-ba4029193947)**\n\nasuna amawaka December 22, 2020\n\n[asuna amawaka](https://medium.com/@asuna.amawaka?source=post_page-----ba4029193947--------------------------------)\n\nDec 20, 2020\n\n\n6 min read\n\nMany fellow researchers have written very good analysis on SUNBURST malware, so I shall\nnot do a walkthrough on reverse engineering it. But I’ve been intrigued by the domain\ngeneration algorithm. The RedDrip Team wrote a nice decoder [1]. Folks at NETRESEC has\nan improved version [2]. However, there are still some generated DGA strings that cannot be\ndecoded. I want to know what these are! *Edit: Just moments before I click on Publish for\nthis post, I saw that Kaspersky’s analysts wrote their code in C [3] with nice writeup [4] that\nalso handled decoding of all two types of DGA string. But hey, I got Python :)\n\nBefore I go on to explain what I did to decode these DGA strings, I would like to summarize\nthe related functions and variable names so you won’t be lost.\n\nVictims of SUNBURST are uniquely identified with a GUID that is created within\n_OrionImprovementBusinessLayer.GetOrCreateUserID(). This GUID is a 8-byte value made_\nup of the victim machine’s MAC address, MachineGUID value read from\nHKLM\\Software\\Microsoft\\Cryptography\\MachineGuid and the victim machine’s domain\nname. These three information are concatenated and MD5-hashed. The MD5 value is then\n“cut” into 2 and XORed (where 1st byte is XORed with the 9th byte; 8th byte is XORed with\n16th byte), hence we end up with a 8-byte irreversible unique identifier.\n\n_OrionImprovementBusinessLayer.Update() is the function that calls the respective functions_\nto generate the DGA strings and responsible for handling the stuff that happens after a DNS\nresponse is received.\n\n_OrionImprovementBusinessLayer.CryptoHelper.GetStatus() returns the concatenation of_\n“.appsync-api.<one of four below>.avsvmcloud.com”.\n\neu-west-1\nus-west-2\nus-east-1\n\n\n-----\n\nus-east-2\n\nFour functions within OrionImprovementBusinessLayer.CryptoHelper are the ones that are\ncalled upon to generate the DGA strings:\n\n_GetNextStringEx(), GetNextString(), GetPreviousString() and GetCurrentString()._\n\nWithin them, the functions CreateSecureString(), CreateString(), DecryptShort(),\n_Base64Decode() and Base64Encode() are responsible for the encoding process._\n\n(At this point, I would like to comment on the names of the functions and variables — geez\nmost of them are not in any way descriptive of the actual meaning of the task they perform or\nthe value they hold. If anything, they are there to mislead the analyst.)\n\n_CreateSecureString() does nothing to create secure strings. What it really does is XOR-_\nencode some data with a random byte as XOR key, prepend this byte to the data and then\nreturn a Base32-like encoded string of the data. The Base32-like encoding is performed by\n_Base64code(). Look at that nasty confusing name!_\n\nThe other related function, Base64code() is sort of a substitution cipher where by default the\ncharacters’ are shifted by 4 to the right according to a custom alphabet. If a special character\n“0”, “.”, “-“ or “_” is encountered, then a random shift value is selected. Either Base64code()\nand Base64code() is called within DecryptShort().\n\n_CreateString() creates a 1 byte value that encodes the index of the DGA string. In the event_\nthat multiple DGA strings are required to fully represent the victims’ domain, this index\nnumbering (I call it the “chunk index”, and it ranges from 0 to 35) will help the receiving end\nto piece back the domain. This is because the DGA string is capped at 32 bytes (excluding\nthe fixed “.appsync-api…avsvmcloud.com”), so encoded victim’s domain that is longer than\n16 bytes would have to be expressed across multiple DGA strings (the first 16 bytes in each\nof such DGA string is taken up by victim’s GUID and the chunk index). Having a chunk index\nof 35 means that this DGA string is the last piece.\n\nTo explain this concept of “index numbering”, let’s look at the output of my decoder. After\ndecoding the victim GUID and the index, I was able to link up two DGA strings (involving abit\nof manual searching) that makes up one victim’s domain. Chunk Index of “0” means it is the\nfirst piece, and Chunk Index of “35” means it is the last. If there had been another piece in\nthe middle, it would be index “1”.\n\n\n-----\n\nWhat made decoding the victims’ domain possible is because the malware generated the\nDGA string via GetPreviousString() and GetCurrentString(). The victims’ domain is encoded\nand included in the DGA string through the variables dnStr and dnStrLower. The decoders\nout there would try to reverse the DGA string to decode dnStrLower to retrieve the victim’s\ndomain.\n\nThis is how the DGA string would look like. I call this “Type 1” DGA string.\n\nNotice that in GetNextString() and GetNextStringEx(), dnStr and dnStrLower are not used.\nInstead, another function UpdateBuffer() is called.\n\n\n-----\n\nAs such, a different kind of DGA string is generated. I call this “Type 2” DGA string.\n\nWithin UpdateBuffer(), a 3-bytes time value is calculated through GetStringHash(). The last\ntwo bytes of this time value is going to be used as the XOR key to encode the 8-bytes victim\nGUID. UpdateBuffer() returns a 11-bytes value made up of 8-bytes encoded GUID and 3bytes time/XOR key. If data is provided to the function (data that describes the number of\nsecurity tools’ processes present somehow), then UpdateBuffer() returns a 13-bytes value,\nwith the additional 2 bytes appended behind the time/XOR key.\n\nThe value is then encoded through CreateSecureString(), which applies the Base32-like\nencoding. The ending DGA value is a 20 or 23 bytes string. Interesting. I can use this as a\ncondition to identify this form of DGA string.\n\n**Alright, stop talking. Let’s decode!**\n\nI made 2 assumptions to try to differentiate between the two types DGA strings.\n\n- If the decoded chunk index is 0, the length of the DGA string cannot be less than 32 bytes\n(which should not be happening, because if data is “overflowing” into another DGA string,\nthen the first should be filled up to the max length). Else, it could be a Type 2 DGA string.\n\n- If chunk index is successfully decoded to 35, then it is a Type 1 DGA string.(what are the\nchances of getting this exact value using the 16th byte and the 1st byte? I think low enough\nfor this assumption to work.)\n\nAlong with the expected length for Type 2 DGA strings, I’m able to come up with the\nfollowing if-else checks:\n\n\n-----\n\nWith the decoded Victim GUIDs from Type 1 and Type 2 DGA strings, we can identify the\nrelated DNS queries, and how many different machines are infected within the same domain.\n\nLet’s see some examples. I worked with data from here:\n[https://github.com/bambenek/research/blob/main/sunburst/uniq-hostnames.txt](https://github.com/bambenek/research/blob/main/sunburst/uniq-hostnames.txt)\n\nIf anyone has a list of all such DNS queries from within their network, I guess it would also be\nhelpful to be able to decode Type 2 DGA strings to identify all the different affected\nmachines.\n\nHere’s the link to the script on Github:\n\n[https://github.com/asuna-amawaka/SUNBURST-Analysis](https://github.com/asuna-amawaka/SUNBURST-Analysis)\n\nIf anyone is keen to discuss (or point out where I can improve in the code), DM me on\nTwitter!\n\nReferences:\n\n[1] [https://github.com/RedDrip7/SunBurst_DGA_Decode](https://github.com/RedDrip7/SunBurst_DGA_Decode)\n\n\n-----\n\n[2] https://www.netresec.com/?page=Blog&month=2020-12&post=Reassembling-VictimDomain-Fragments-from-SUNBURST-DNS\n\n[3] [https://github.com/2igosha/sunburst_dga](https://github.com/2igosha/sunburst_dga)\n\n[4] [https://securelist.com/sunburst-connecting-the-dots-in-the-dns-requests/99862/](https://securelist.com/sunburst-connecting-the-dots-in-the-dns-requests/99862/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-20 - A Look into SUNBURST’s DGA.pdf"
    ],
    "report_names": [
        "2020-12-20 - A Look into SUNBURST’s DGA.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536104,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1653678120,
    "ts_modification_date": 1653678120,
    "files": {
        "pdf": "https://archive.orkl.eu/fb726e7521c1aca8dd691e78c0d60e4885160659.pdf",
        "text": "https://archive.orkl.eu/fb726e7521c1aca8dd691e78c0d60e4885160659.txt",
        "img": "https://archive.orkl.eu/fb726e7521c1aca8dd691e78c0d60e4885160659.jpg"
    }
}