{
    "id": "e4cb49ac-5a32-4951-93ae-2347c72ac727",
    "created_at": "2023-01-12T15:01:42.890651Z",
    "updated_at": "2025-03-27T02:05:43.99267Z",
    "deleted_at": null,
    "sha1_hash": "11f432091f22d30ab0772239c2c9a6d6e796cd0d",
    "title": "2020-12-15 - Conti Ransomware v2",
    "authors": "",
    "file_creation_date": "2022-05-27T23:23:41Z",
    "file_modification_date": "2022-05-27T23:23:41Z",
    "file_size": 155096,
    "plain_text": "# Conti Ransomware v2\n\n**[chuongdong.com/reverse engineering/2020/12/15/ContiRansomware/](http://chuongdong.com/reverse%20engineering/2020/12/15/ContiRansomware/)**\n\nChuong Dong December 15, 2020\n\n[Reverse Engineering · 15 Dec 2020](http://chuongdong.com/categories/#reverse%20engineering)\n\n## Overview\n\nThis is my full analysis for the Conti Ransomware version 2. Over the last few months, I have seen quite a\nfew companies getting hit by this ransomware, so it’s been interesting analyzing and figuring how it works.\n\nAs one of the newer ransomware families, Conti utilizes multi-threading features on Windows to encrypt\nfiles on machines To the fullest extent, making itself a lot faster than most ransomware out there.\n\nFrom the analysis, it’s clear that Conti is designed to target and encrypt business environments that uses\nSMB for file sharing and other services. Similar to the Sodinokibi family, Conti has the ability to scan\nexisting ports and SMB shares on the network to spread its encryption, which can be a lot more impactful\nsince it is not limited to the local machine.\n\nBy the time this blog post comes out, researchers have found newer samples of the version 3. Even though\nthis is an old sample, I still think it’s beneficial to provide the community with a deeper understanding about\nthis malware.\n\nalt text\n\n_Figure 1: Conti overview_\n\n## IOCS\n\n**_Conti Ransomware version 2 comes in the form of a 32-bit PE file (either .exe or .dll)._**\n\n**MD5: 0a49ed1c5419bb9752821d856f7ce4ff**\n\n**SHA256: 03b9c7a3b73f15dfc2dcb0b74f3e971fdda7d1d1e2010c6d1861043f90a2fecd**\n\n**Sample:**\nhttps://bazaar.abuse.ch/sample/03b9c7a3b73f15dfc2dcb0b74f3e971fdda7d1d1e2010c6d1861043f90a2fecd/\n\n**Unpacked sample:**\nhttps://bazaar.abuse.ch/sample/d3c75c5bc4ae087d547bd722bd84478ee6baf8c3355b930f26cc19777cd39d4c/\n\nalt text\n\n_Figure 2: VirusTotal result_\n\n## Ransom Note\n\nalt text\n\n_Figure 3: Conti Ransom Note_\n\n\n-----\n\nThe ID appended at the end is actually hard-coded, so it s not a victim s ID. This ID is most likely just the ID\nof this particular Conti sample.\n\nBelow is the HTTPS version of the website for recovery service.\n\nalt text\n\n_Figure 4: Conti Website_\n\n## Dependencies\n\nThe ransomware only has Kernel32.dll, User32.dll, and WS2_32.dll as visible imported DLLs.\n\nHowever, it does dynamically resolve a lot of DLLs through decrypting stack strings and calling\n**LoadLibrary as seen here.**\n\nalt text\n\n_Figure 5: Conti resolving DLL string names (sub_571010)_\n\nHere is the full list of the imported DLLs.\n\n**Kernel32.dll**\n**Ntdll.dll**\n**Ole32.dll**\n**Shell32.dll**\n**Ws2_32.dll**\n**Shlwapi.dll**\n**Advapi32.dll**\n**Iphlpapi.dll**\n**Rstrtmgr.dll**\n**Netapi32.dll**\n**OleAut32_dll**\n**User32.dll**\n\n## PE Layout\n\nThe unpacked version of the malware is around 208 KB in size, which consists of the .text, .rdata, .data,\n**.rsrc, and .reloc sections.**\n\nOne of the main reasons why this executable is so big is because of the obsfucation method the developer\nuses. Instead of implementing a single string decryption function, they used one decrypting for loop for\neach encrypted string, which greatly increased the amount of raw code.\n\nalt text\n\n_Figure 6: Conti Layout_\n\n## Code Analysis\n\n### String Decryption\n\n\n-----\n\nAs mentioned above, Conti uses the method of building up a stack string that is encrypted and proceeds\nto decrypt it with a for loop. Every string is encrypted differently, so the for loop changes slightly for each of\nthem.\n\nalt text\n\n_Figure 7: String decryption of explorer.exe (sub_58B2D0)_\n\nMost of the decryption loops can be simplified to this single form where buffer is the encrypted string, a\nand b are positive numbers, and c is either 1 or -1.\n```\nfor i in range(len(buffer)):\n  buffer[i] = (a * (c * (buffer[i] - b)) % 127 + 127) % 127\n\n### Dynamically Resolve API\n\n```\nWhen resolving APIs, Conti calls a particular function that takes in an integer representing the DLL to find,\nan API hash value, and an offset into the API buffer.\n\nThe DLL name is retrieved from the given integer through a switch statement.\n\n15 ==> Kernel32.dll\n16 ==> Ws2_32.dll\n17 ==> Netapi32.dll\n18 ==> Iphlpapi.dll\n19 ==> Rstrtmgr.dll\n20 ==> User32.dll\n21 ==> Ws2_32.dll\n22 ==> Shlwapi.dll\n23 ==> Shell32.dll\n24 ==> Ole32.dll\n25 ==> OleAut32.dll\n26 ==> Ntdll.dll\n\nAfter getting the DLL name, Conti will manually locate the export directory of that DLL, loop through each\nAPI, hash the name, and compare it with the hash from the parameter. After finding the correct API with the\nright hash value, it will proceed to find the address to that function.\n\nalt text\n\n_Figure 8: Function looping through export table and hash API name (sub_5737C0)_\n\n[For the hashing algorithm, the constant 0x5BD1E995 gives this away that this is Murmur Hash](https://github.com/abrandoned/murmur2/blob/master/MurmurHash2.c)\n\nalt text\n\n_Figure 9: Conti’s Murmur Hashing implementation (sub_575970)_\n\nAfter finding the address of the API, the malware adds that into its API array at the provided offset. This\nhelps reducing the time to look up an API’s address if the malware has already resolved it before.\n\n### Run-once Mutex\n\n\n-----\n\nConti attempts to decrypt the string **jkbmusop9iqkamvcrewuyy777 and use that as the name of a**\nMutex object.\n\nThen, it checks if there is an instant of that Mutex running already. If there is, it will just wait until that thread\nexits before exiting.\n\nalt text\n\n_Figure 10: Checking for Mutex (sub_587E20)_\n\n### Command-line Arguments\n\nConti can only be ran with command-line arguments, so it must be launched by a loader. Upon execution, it\nwill process these arguments and behave accordingly.\n\n**CMD Args** **Functionality**\n\n-m local Encrypting the local machine’s hard drive with multiple threads\n\n-m net Encrypting network shares via SMB with mutiple threads\n\n-m all Encrypting both locally and on the network with multiple threads\n\n-p [directory] Encrypt a specific directory locally with 1 thread\n\n-size [chunk mode] Large encryption chunk mode\n\n-log [file name] Logging mode. Log everything to the file with the given name\n\nbackups Unimplemented for some reason\n\n### Encryption\n\nDespite having 3 different encrypting schemes, the main mechanism is relatively the same.\n\nFirst, it calls a function to populate a structure used to initialize information about the thread/threads of that\nencrypting schemes. These information includes the number of threads to spawn and a thread buffer that is\nused to store thread HANDLE objects.\n\nalt text\n\n_Figure 11: Function initializing thread struct (sub_58BDB0)_\n\nNext, it calls this function to launch child threads. It checks the thread struct to see if the encrypting flag is\nset. If it is, loop from 0 to thread_count - 1 and spawn a thread to encrypt each time. It also adds these\nthreads into the thread buffer for easy clean-up later.\n\nalt text\n\n_Figure 12: Function launching encrypting threads (sub_58BE30)_\n\n**Multi-threading**\n\nBeside when the argument -p is provided, multi-threading is involved for every other scheme of encryption.\nConti will call GetNativeSystemInfo to retrieve information about the running system.\n\n\n-----\n\nIf the argument **-m all is provided, the number of threads to spawn will be double the amount of**\nprocessors because it needs to encrypt both locally and on the network.\n\nFor everything else, the number of threads to spawn is the same as the number of processors.\n\nalt text\n\n_Figure 13: Determining how many threads to spawn from number of processor (sub_587E20)_\n\nBeing able to thread its encryption, Conti utilizes all of the CPU threads available to simultaneously go\nthrough and encrypt the file system with incredible speed.\n\nalt text\n\n_Figure 14: Realistic representation of what happens when Conti runs_\n\nThe most interesting information in the thread structure is the string of the path to be encrypted. After\nhaving launch the threads, Conti’s main program will continuously traverse the file system and provide the\nthread structure with directory names. All of these threads will check this information and encrypt the\nupdated path immediately. Because the workload is divided efficiently, Conti is able to speed up its\ntraversing and encryption to a great extent.\n\nalt text\n\n_Figure 15: Main thread providing the drives to be encrypted (sub_587E20)_\n\n### Encrypting Locally\n\n**RSA Public Key**\n\nFirst, each thread will call CryptAcquireContextA with the cryptographic provider type PROV_RSA_AES\nto retrieve a handle of a CSP for RSA encryption. Using that CSP, it will call CryptImportKey to import\nfrom the hard-coded RSA public key.\n\nalt text\n\n_Figure 16: RSA Public Key embedded in the .data section_\n\nalt text\n\n_Figure 17: CryptAcquireContextA and CryptImportKey called (sub_58BC20)_\n\nNext, it will enter an infinite loop to wait for the main thread to add a target drive path or to send a stop\nsignal. This is accomplished solely through the shared thread struct that was created before launching\nthese threads. Because the struct is shared between multiple threads, calls to EnterCriticalSection and\n**LeaveCriticalSection are critical to maintain a thread-safe environment during encryption.**\n\nalt text\n\n_Figure 18: Each thread continuously polling for a path name and encrypt it (sub_58BC20)_\n\nIn the main encrypting function, it will iteratively call FindFirstFile on the directory name to search for all\nfiles and folders inside, avoiding the two current path and parent path names ”.” and ”..” which can cause\nan infinite loop if processed.\n\n\n-----\n\n**Directory Check**\n\nIf the file being checked is a directory, it will check to see if the directory name is valid or not. If it is, then\nthe child thread will add that path to the thread struct for itself or any other available thread to encrypt.\n\nalt text\n\n_Figure 19: Checking if the path is a valid directory (sub_586340)_\n\nThese are the directory name that Conti will avoid encrypting.\n```\ntmp, winnt, temp, thumb, $Recycle.Bin, $RECYCLE.BIN, System Volume Information, Boot, Windows,\nTrend Micro\n\n```\n**Normal File Check**\n\nIf the file is just a normal file, Conti will check to see if the file name is valid before proceed to encrypt it.\n\nalt text\n\n_Figure 20: Checking if the path is a valid file (sub_586340)_\n\nConti will avoid encrypting any file with these names or extensions.\n```\nCONTI_LOG.txt, readme.txt, .msi, .sys, .lnk, .dll, .exe\n\n```\n**Normal File Encryption**\n\nFirst, Conti populates a structure in memory. I call this structure CONTI_STRUCT.\n```\nstruct CONTI_STRUCT\n{\n char *file_name;\n HANDLE hFile;\n LARGE_INTEGER file_size;\n int CHACHA8_const[4];\n int CHACHA8_256_KEY[8];\n int block_counter;\n int block_counter_ptr;\n int CHACHA8_none[2];\n int random1[2];\n int random2[8];\n BYTE encrypted_key[524]; // encrypted ChaCha8 key\n};\n\n```\nConti will call CryptGenRandom to generate 2 different random buffers and put them into the\n**CONTI_STRUCT. Then, it populates the ChaCha8 constants which is just “expand 32-byte k” in hex form.**\n\nThe first buffer is 256 bits, which is later used as the ChaCha8 encrypting key, and the second one is 64\nbits, which is used as the ChaCha8 nonce.\n\nNext, it will copy the key and nonce into the buffer at the end of the struct and encrypt it using the RSA key\nimported earlier. This is to ensure that the ChaCha key can not be recovered without the RSA private key.\n\nalt text\n\n_Figure 21: Generating random number (sub_5805A0)_\n\n\n-----\n\nalt text\n\n_Figure 22: Populating ChaCha8 constants and encrypt the random numbers with the RSA key_\n_(sub_5805A0)_\n\nConti has 3 file categories for encryption - small, medium, and large files. Small files are marked with the\nvalue of 0x24, medium with 0x26, and large with 0x25.\n\nBefore encryption, Conti will write the encrypted ChaCha8 key from CONTI_STRUCT, this mark, and the\nfile size to at the end of the to-be-encrypted file.\n\nalt text\n\n_Figure 23: Writing the encrypted random ChaCha8 key, mark, and size to file (sub_57E4B0)_\n\nalt text\n\n_Figure 24: The key at the end of an encrypted file_\n\n**1. Small File**\n\nSmall files are files that are potentially less than 1MB in size. Conti looks for all files that is smaller than\n1MB or by checking for these extensions below.\n```\n.4dd, .4dl, .accdb, .accdc, .accde, .accdr, .accdt, .accft, .adb, .ade, .adf, .adp, .arc, .ora, \n.alf, .ask, .btr, .bdf, .cat, .cdb, .ckp, .cma, .cpd, .dacpac, .dad, .dadiagrams, .daschema, .db, \n.db-shm, .db-wal, .db3, .dbc, .dbf, .dbs, .dbt, .dbv, .dbx, .dcb, .dct, .dcx, .ddl, .dlis, .dp1, \n.dqy, .dsk, .dsn, .dtsx, .dxl, .eco, .ecx, .edb, .epim, .exb, .fcd, .fdb, .fic, .fmp, .fmp12,\n.fmpsl, \n.fol, .fp3, .fp4, .fp5, .fp7, .fpt, .frm, .gdb, .grdb, .gwi, .hdb, .his, .ib, .idb, .ihx, .itdb,\n.itw, \n.jet, .jtx, .kdb, .kexi, .kexic, .kexis, .lgc, .lwx, .maf, .maq, .mar, .mas, .mav, .mdb, .mdf,\n.mpd, .mud, \n.mwb, .myd, .ndf, .nnt, .nrmlib, .ns2, .ns3, .ns4, .nsf, .nv, .nv2, .nwdb, .nyf, .odb, .oqy, .orx,\n.owc, \n.p96, .p97, .pan, .pdb, .pdm, .pnz, .qry, .qvd, .rbf, .rctd, .rod, .rodx, .rpd, .rsd, .sas7bdat,\n.sbf, .scx, \n.sdb, .sdc, .sdf, .sis, .spq, .sql, .sqlite, .sqlite3, .sqlitedb, .te, .temx, .tmd, .tps, .trc,\n.trm, .udb, \n.udl, .usr, .v12, .vis, .vpd, .vvv, .wdb, .wmdb, .wrk, .xdb, .xld, .xmlff, .abcddb, .abs, .abx,\n.accdw, .adn, \n.db2, .fm5, .hjt, .icg, .icr, .kdb, .lut, .maw, .mdn, .mdt\n\n```\nEncrypting small files are straightforward. Since these files are small enough, it typically does not require to\nloop and encrypt more than once. The file content is read into a buffer and encrypted directly. Just to be\nsafe, the malware author did limit the maximum buffer size to read to 5MB, but it’s unlikely that the files\ngoing into this function is that big.\n\nalt text\n\n_Figure 25: Small File Encrypting mechanism (sub_580460)_\n\n**2. Medium File**\n\nMedium files are files that are between 1MB to 5MB.\n\nFor these files, Conti only encrypts the first 1 MB of the files.\n\n\n-----\n\nalt text\n\n_Figure 26: Medium File Encrypting mechanism (sub_5805A0)_\n\n**3. Large file**\n\nLarge files are files that are larger than 5MB. Conti specifically looks for these by checking for these\nextensions.\n```\n.vdi, .vhd, .vmdk, .pvm, .vmem, .vmsn, .vmsd, .nvram, .vmx, .raw, .qcow2, .subvol, .bin, .vsv,\n.avhd, .vmrs, .vhdx,\n.avdx, .vmcx, .iso\n\n```\nThe large file encrypting function processes the -size chunk mode argument and uses it in a switch\nstatement to determine the encrypting offset and the encrypting size.\n\nAccording to [Michael Gillespie, here are the chunk mode values:](https://twitter.com/demonslay335)\n\n0x14 (default) ==> represent 3 chunks of (file_size / 100 * 7)\n0x32 ==> represent 5 chunks of (file_size / 100 * 10)\n\nThe mechanism of encrypting can be simplify to this. Basically, Conti will encrypt encrypt_length amount\nof bytes and skip the next encrypt_offset before encrypting again until it reaches the end of the file. This\nmakes encryption quicker for large files because it does not have to encrypt everything.\n\nAlso according to Michael, Conti has a bug where the keystream sometime goes out of sync in-between\nchunks during encryption because the encrypted buffer size is rounded up to the nearest 64 which is the\nChaCha state matrix size.\n\nalt text\n\n_Figure 27: Large File Encrypting mechanism (sub_57FFD0)_\n\n**4. ChaCha8 Encryption**\n\nThe ChaCha8 implementation is pretty straightforward. The 256-byte key that was randomly generated\nearlier is then used as the encrypting key.\n\nalt text\n\n_Figure 28: Conti’s ChaCha8 implementation (sub_575AC0)_\n\nIn order to be able to decrypt the files, we need to know the random key that Conti uses for each file, and\nthe only way to retrieve it is through the encrypted key buffer at the end of the file.\n\nSince that buffer is encrypted with a public RSA key, we need the private RSA key to decrypt this.\n\nNonetheless, since they are using a hard-coded public key, if anyone pays the ransom for this Conti\nversion, the private key can be retrieved. It will be simple to write a decrypting tool if that is the case, and all\nof the samples with this ID will become useless after.\n\nThis implementation clearly reflects how the Conti group mainly targets big companies instead of aiming to\nspread the malware to normal computer users. Once a company (or anyone) pays off the ransom, they\nhave to discard all of the samples that use the private key and develop newer samples to spread.\n\n\n-----\n\nalt text\n\n_Figure 29: Conti’s Encryption method_\n\n### Delete Shadow Copy with COM Objects\n\nBefore encrypting, Conti’s main thread calls CoInitializeEx, CoInitializeSecurity, and CoCreateInstance\nto creates a single object of the class IWbemLocator with the specified CLSID 4590F811-1D3A-11D0_891F-00AA004B2E24._\n\nalt text\n\n_Figure 30: Initializing COM Object (sub_576B80)_\n\nNext, it checks if the processor architecture of the machine is x86-64 . If it is, then Conti will call\n**CoCreateInstance to create a single object of the class IWbemContext with the specified CLSID**\n_674B6698-EE92-11D0-AD71-00C04FD8FDFF._\n\nWith this Call Context object, it can modify the __ProviderArchitecture to force load the specified\nprovider version which is 64-bit architecture.\n\nalt text\n\n_Figure 31: Force load 64-bit if needed (sub_576B80)_\n\nUsing the IWbemLocator object earlier, Conti calls its ConnectServer method to connect with the local\n_ROOT\\CIMV2 namespace and obtain the pointer to an IWbemServices object._\n\nalt text\n\n_Figure 32: Connecting to ROOT\\CIMV2 to get IWbemServices object (sub_576B80)_\n\nWith this IWbemServices object, it executes the SQL query “SELECT * FROM Win32_ShadowCopy” to\nretrieve a enumerator of all the shadow copies stored in the local server.\n\nBy enumerating through these informations, Conti extracts the ID of each shadow copy, add that to the\nformat string “cmd.exe /c C:\\Windows\\System32\\wbem\\WMIC.exe shadowcopy where “ID=’%s’”\n**delete”, and create a new process to execute. This will eventually deletes all the shadow copy storage**\nareas in the computer.\n\nalt text\n\n_Figure 33: Building cmd string to delete shadowcopy based on ID (sub_576B80)_\n\n### Network Encryption\n\nFor the network encryption, Conti calls CreateIoCompletionPort to spawn as many concurrently running\nthreads as there are processors in the system, and these threads waits for a list of network shares to start\nencryption.\n\nalt text\n\n_Figure 34: CreateIoCompletionPort to spawn network encrypting thread (sub_58A6F0)_\n\n\n-----\n\nThe main thread then calls NetShareEnum to get an enumerator to extract information about shared\nnetwork resources. This scans the system to see if there exists any existing SMB network shares.\n\nAfter getting this “ARP” cache, it will check if the IP addresses of hosts in the list start with “172.”,\n**“192.168.”, “10.”, and “169.”. Since it only cares about encrypting local systems, any other IP address**\nranges is ignored.\n\nIt will then scan and look for every shares with the name that is not “ADMIN$”, get the full path to the\nshares, and add it to an array of network shares.\n\nalt text\n\n_Figure 35: Scanning SMB for all existing SMB network shares (sub_5898D0)_\n\nAfter extracting this, it will loop through and call the function from Figure 15 to push these share names into\nthe thread struct so the child threads can begin encrypting.\n\nIf scanning SMB for network hosts fails, Conti will perform just a port scan using CreateIoCompletionPort\n**GetQueuedCompletionStatus, and PostQueuedCompletionStatus**\n\nalt text\n\n_Figure 36: Conti port scans (sub_58A370)_\n\nAfter this point, the encryption happens the same as the local encryption, with share names being pushed\ninto the shared thread struct for the child processes to encrypt.\n\n## Key findings\n\nOverall, Conti ransomware is a sophisticated sample with many unique functionalities. By sacrificing the\ntremendous increase in size, the Conti team has implement a really troublesome string encryption method,\nwhich ended up taking me a while to go through and resolve all of the strings.\n\nThe encryption scheme is a bit boring with a randomly generated key protected by a hard-coded public\nRSA key. However, the multi-threading encryption is implemented elegantly using a shared structure\nbetween all of the threads, which results in extreme encrypting speed. Conti also avoids encrypting large\nfiles entirely, so it’s obvious that the malware authors prioritize speed over encrypting quality. With its\nnetworking functionality, the ransomware actively looks for available shares on the network to spread its\nencryption. This mainly targets small business and enterprise fields that uses the SMB protocol for file\nsharing, as we have seen with Advantech, Riverside Community Care, Ixsight Technologies, Total Systems\nServices, …\n\n**NOTE: For anyone who wants to analyze this sample further, you should set up a folder on your machine**\nand runs the ransomware with the command line argument “-p [directory]” to test encryption on that\ndirectory only. It’s a pretty neat way to set up a small environment for testing and dynamic analysis that the\nauthors have provided us with, so huge shoutout to them for that!\n\n## YARA rule\n\n\n-----\n\n```\n        {\n     meta:\n          description = \"YARA rule for Conti Ransomware v2\"\n          reference =\n\"http://chuongdong.com/reverse%20engineering/2020/12/15/ContiRansomware/\"\n          author = \"@cPeterr\"\n          date = \"2020-12-15\"\n          rule_version = \"v2\"\n          malware_type = \"ransomware\"\n          malware_family = \"Ransom:W32/Conti\"\n          tlp = \"white\"\n     strings:\n          $str1 = \"polzarutu1982@protonmail.com\"\n          $str2 = \"http://m232fdxbfmbrcehbrj5iayknxnggf6niqfj6x4iedrgtab4qupzjlaid.onion\"\n          $str3 = \"expand 32-byte k\"\n          $string_decryption = { 8a 07 8d 7f 01 0f b6 c0 b9 ?? 00 00 00 2b c8 6b c1 ?? 99 f7\nfe 8d 42 7f 99 f7 fe 88 57 ff }\n          $compare_size = { ?? ?? 00 00 50 00 }\n     condition:\n          all of ($str*) and $string_decryption and $compare_size\n}\n\n## References\n\n```\nhttps://twitter.com/Arkbird_SOLG/status/1337565128561225728\n\nhttps://twitter.com/VK_Intel/status/1297252264126685185\n\nhttps://www.bleepingcomputer.com/news/security/conti-ransomware-shows-signs-of-being-ryukssuccessor/\n\nhttps://www.carbonblack.com/blog/tau-threat-discovery-conti-ransomware/\n\nhttps://id-ransomware.malwarehunterteam.com/identify.php?\ncase=2c61281154a1c9df22081099c5c36503a63e9b01\n\nhttps://twitter.com/demonslay335/status/1339975671817318400\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-15 - Conti Ransomware v2.pdf"
    ],
    "report_names": [
        "2020-12-15 - Conti Ransomware v2.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535702,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1653693821,
    "ts_modification_date": 1653693821,
    "files": {
        "pdf": "https://archive.orkl.eu/11f432091f22d30ab0772239c2c9a6d6e796cd0d.pdf",
        "text": "https://archive.orkl.eu/11f432091f22d30ab0772239c2c9a6d6e796cd0d.txt",
        "img": "https://archive.orkl.eu/11f432091f22d30ab0772239c2c9a6d6e796cd0d.jpg"
    }
}