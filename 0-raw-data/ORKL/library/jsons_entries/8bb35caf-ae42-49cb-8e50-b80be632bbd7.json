{
    "id": "8bb35caf-ae42-49cb-8e50-b80be632bbd7",
    "created_at": "2023-01-12T15:06:30.308806Z",
    "updated_at": "2025-03-27T02:05:48.202228Z",
    "deleted_at": null,
    "sha1_hash": "e9678a08b041e4d64eeb5f5099697b065ca0c0f6",
    "title": "2020-08-12 - Why Emotet’s Latest Wave is Harder to Catch than Ever Before",
    "authors": "",
    "file_creation_date": "2022-05-29T01:38:57Z",
    "file_modification_date": "2022-05-29T01:38:57Z",
    "file_size": 1004457,
    "plain_text": "# Why Emotet's Latest Wave is Harder to Catch than Ever Before\n\n**[deepinstinct.com/2020/08/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before/](https://www.deepinstinct.com/2020/08/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before/)**\n\nAugust 12, 2020\n\nAugust 12, 2020 | [Ron Ben Yizhak](https://www.deepinstinct.com/author/ron-ben-yizhak)\n\nAfter five months of inactivity, the prolific and well-known Emotet botnet re-emerged on July\n17 . The purpose of this botnet is to steal sensitive information from victims or provide anth\ninstallation base for additional malware such as TrickBot, which then in many cases will drop\nransomware or other malware. So far, in the current wave, it was observed delivering\nQakBot.\n\nIn this blog post, we reveal some novel evasion techniques which assist the new wave of\nEmotet to avoid detection. We discovered how its evasion techniques work and how to\novercome them. The first part of the malware execution is the loader which is examined in\nthis article, with an emphasis on the unpacking process. We also partition the current wave\ninto several clusters, each cluster has some unique shared properties among the samples.\n\n## Clustering the samples\n\n\n-----\n\n[A dataset of 38 thousand samples was created using data collected by the Cryptolaemus](https://paste.cryptolaemus.com/)\ngroup, from July 17th to July 28th. This group divides the samples into three epochs, which\nare separate botnets that operate independently from one another.\n\nStatic information was extracted from each sample in order to find consistent patterns across\nthe entire data set. The information that is relevant to identify patterns includes the size and\nentropy of the .text, .data, .rsrc sections, and the size of the whole file, so this information\nwas extracted from all the files. We started our analysis with two samples, an overview for\nwhich is provided in the image below. By looking at each file size we can see that the ratio of\nthese sections remains the same, and the entropy differs very little between the files.\n\nImage shows different Emotet samples having sections with the same size and entropy\n\nThis also results in completely identical code. The two samples presented above were\ncompared using the diaphora plugin for IDA, and all the functions were identical.\n\nComparing the code of the two samples shows they share the exact same subroutines\n\n\n-----\n\nGrouping the entire dataset by the size of the files resulted in 272 unique sizes of files. The\nfiles matching each size were then checked to see if they have the same static information.\nThis way we discovered 102 templates of Emotet samples.\n\nEach sample in the dataset that matched a template was tagged with a template ID and with\nan epoch number, as indicated by the Cryptolaemus group. This means that the operators\nbehind each epoch have their own Emotet loaders. The various templates might help reduce\nthe detection rate of the samples used by the entire operation. If a specific template has a\nunique feature that can be signed, it won’t affect samples belonging to other templates and\nepochs.\n\nMost packers today provide features such as various encryption algorithms, integrity checks\nand evasion techniques. These templates are most likely the result of different combinations\nof flags and parameters in the packing software. Each epoch has different configurations for\nthe packing software resulting in clusters of files that have the same static information.\n\n## Identifying benign code\n\nThe Emotet loader contains a lot of benign code as part of its evasion. A.I. based security\nproducts rely on both malicious and benign features when classifying a file. In order to\nbypass products like that, malware authors can insert benign code into their executable files\n[to reduce the chance of them being detected. This is called an adversarial attack and its](https://www.infosecurity-magazine.com/opinions/traditional-machine-learning/)\neffectiveness is seen in security solutions based on machine learning.\n\n[By looking at the analysis done by Intezer on a specific Emotet sample from the new wave,](https://analyze.intezer.com/analyses/049cf112-176b-47e1-b815-25cabfc381ed)\nwe can see that the benign code might be taken from Microsoft DLL files that are part of the\nVisual C++ runtime environment. Alternatively, the benign software could be completely\nunrelated to the functioning of the sample.\n\nThe following screenshot shows the similarities between the previous sample and a benign\nMicrosoft DLL file, using the diaphora plugin:\n\nThe Emotet loader contains benign code taken from a Microsoft DLL\n\n\n-----\n\nUnder the column Name there are functions from the malware, and under the column\n“Name 2” there are functions from the benign file. As we can see, the malware contains\nmuch benign code which isn’t necessarily needed.\n\nThe next step is to check how much of the code is actually used. This can be done using the\ntool drcov by DynamoRIO. This tool executes binary file and tracks which parts of the code\nare used. The log produced by this tool can later be processed by the lighthouse plugin for\nIDA. This plugin integrates the execution log into the IDA database in order to visualize\nwhich functions are used. The analysis was performed on the sample shown so far, the\nresult is that just 16.22% of the code is executed\n\nThe report produced by the lighthouse plugin showing which functions were executed\n\nAfter we filtered out benign code that was injected into the executable, we can compare the\ncode of different variants to locate the malicious functions which exist in every sample.\n\n\n-----\n\nDiagram shows code from different clusters sharing the same malicious functionality.\n\nFiltering out benign functions helps to reveal the malicious code, but it can also be found\nusing dynamic analysis, which will be discussed in the next section.\n\n## Finding the encrypted payload\n\nThe executable previously shown is an Emotet loader. The main purpose of the loader is to\ndecrypt the payload hidden in the sample and execute it. The payload consists of a PE file\nand a shellcode that loads it. The encrypted payload will cause the section it resides in to\nhave high entropy. Based on the dataset we collected, 87% of the files had the payload in\nthe .data section and 13% of the files had the payload in the .rsrc section. Tools like pestudio\nshow the entropy of each section and each resource. For example, the resources of a\nsample with the payload lies encrypted in the “9248” resource:\n\nIn order to find the code that decrypts the resource, we can put a hardware breakpoint at the\nstart of the resource.\n\nPestudio showing the resources with the highest entropy in the Emotet loader\n\n\n-----\n\nIn cases where the payload is inside the .data section, it s unclear where it starts. We can\napproximate it by calculating the entropy for small bulks of the section and find where the\nscore starts to rise.\n```\n<span style=\"color: #0000ff;\">import</span> sys \n<span style=\"color: #0000ff;\">import</span> math \n<span style=\"color: #0000ff;\">import</span> pefile \nBULK_SIZE = 256 \n<span style=\"color: #0000ff;\">def</span> <span style=\"color: #00ccff;\">entropy</span>\n(byteArr):\n    arrSize = <span style=\"color: #0000ff;\">len</span>(byteArr)\n    freqList = []\n    <span style=\"color: #0000ff;\">for</span> b in <span style=\"color:\n#0000ff;\">range</span>(256):\n       ctr = 0\n      <span style=\"color: #0000ff;\"> for</span> byte in byteArr:\n          <span style=\"color: #0000ff;\">if</span> byte == b:\n              ctr += 1\n       freqList.append(<span style=\"color: #00ccff;\">float</span>(ctr) /\narrSize)\n    ent = 0.0\n    <span style=\"color: #0000ff;\">for</span> freq in freqList:\n      <span style=\"color: #0000ff;\">if</span> freq > 0:\n        ent = ent + freq * math.log(freq, 2)\n    ent = -ent\n    <span style=\"color: #0000ff;\">return</span> ent\npe_file = pefile.PE(sys.argv[1])\ndata_section = <span style=\"color: #0000ff;\">next</span>(section <span style=\"color:\n#0000ff;\">for</span> section in pe_file.sections <span style=\"color:\n#0000ff;\">if</span> section.Name == b<span style=\"color:\n#993300;\">'.data\\x00\\x00\\x00'</span>)\ndata_section_buffer = data_section.get_data()\ndata_section_va = pe_file.OPTIONAL_HEADER.ImageBase + data_section.VirtualAddress \nbuffer_size = <span style=\"color: #0000ff;\">len</span>(data_section_buffer)\nbulks = [data_section_buffer[i:i+BULK_SIZE] <span style=\"color: #0000ff;\">for</span>\ni in <span style=\"color: #0000ff;\">range</span>(0, buffer_size, BULK_SIZE)] \n<span style=\"color: #0000ff;\">for</span> i, bulk in <span style=\"color:\n#0000ff;\">enumerate</span>(bulks):\n    <span style=\"color: #0000ff;\">print</span>(<span style=\"color:\n#0000ff;\">hex</span>(data_section_va + i*BULK_SIZE), entropy(bulk))\n\n```\nPython script that calculates the entropy of small portions of the .data section\n\nOnce we know where the payload is located, we’ll be able to find the code that decrypts it,\nand that is where the malicious action starts.\n\n## Analyzing the malicious code\n\nFor this part, we’ll look at the sample:\n\n249269aae1e8a9c52f7f6ae93eb0466a5069870b14bf50ac22dc14099c2655db\n\n\n-----\n\nIn this sample, the script indicates that the beginning of the data section contains the payload\nalthough it may vary in other samples. We will put the breakpoint at the address 0x406100.\nThe breakpoint was hit at the address 0x40218C which is in the function sub_401F80. After\nlooking at this function, we notice a few suspicious things:\n\n1. This function builds strings on the stack in order to hide its intents. It uses GetProcAddress\nto find the address of VirtualAllocExNuma and calls it to allocate memory for the payload.\n\nThe loader conceals suspicious API calls\n\n2. It calculates the parameters for VirtualAllocExNuma during runtime, to hide the allocation\nof RWX memory. The function atoi is being used to convert the string “64” to int, which is\nPAGE_EXECUTE_READWRITE. Also, the string “8192” is converted to 0x3000 which\nmeans the memory is allocated with the flags MEM_COMMIT and MEM_RESERVE.\n\n\n-----\n\nThe parameters were saved as strings to obfuscate the API call\n\nThe payload is then copied from the .data section to the RWX memory (that is where our\nbreakpoint hit). The decryption routine is being called and then the shellcode is being\nexecuted.\n\nThe loader decrypts the payload and continues to the next step in the execution of the\nmalware\n\nIn this blog post we looked at the static information of the new Emotet loader, revealed how\nto cluster similar samples, and found how to locate the malicious code and its payload. In\naddition, we exposed how the loader evades detection; primarily the loader hides the\nmalicious API calls using obfuscation, but it also injects benign code to manipulate the\nalgorithms of AI-based security products. Both processes have been shown to reduce the\nchance of the file being detected. The cumulative effect of these techniques makes the\nEmotet group one of the most advanced campaigns in the threat landscape.\n\n_Update_\n\n\n-----\n\n[Read more about the hidden payload in the Emotet loader that is decrypted and then](https://www.deepinstinct.com/2020/10/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before-part-2/)\nexecuted to successfully avoid being detected.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-12 - Why Emotet’s Latest Wave is Harder to Catch than Ever Before.pdf"
    ],
    "report_names": [
        "2020-08-12 - Why Emotet’s Latest Wave is Harder to Catch than Ever Before.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535990,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653788337,
    "ts_modification_date": 1653788337,
    "files": {
        "pdf": "https://archive.orkl.eu/e9678a08b041e4d64eeb5f5099697b065ca0c0f6.pdf",
        "text": "https://archive.orkl.eu/e9678a08b041e4d64eeb5f5099697b065ca0c0f6.txt",
        "img": "https://archive.orkl.eu/e9678a08b041e4d64eeb5f5099697b065ca0c0f6.jpg"
    }
}