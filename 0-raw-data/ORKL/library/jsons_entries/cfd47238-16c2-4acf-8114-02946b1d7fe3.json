{
    "id": "cfd47238-16c2-4acf-8114-02946b1d7fe3",
    "created_at": "2023-01-12T15:02:02.79657Z",
    "updated_at": "2025-03-27T02:05:18.535531Z",
    "deleted_at": null,
    "sha1_hash": "82c7eff5db67e41d8747c44b57f4f3cd9f8f7714",
    "title": "2021-07-19 - Evade Sandboxes With a Single Bit – the Trap Flag",
    "authors": "",
    "file_creation_date": "2022-05-28T15:14:07Z",
    "file_modification_date": "2022-05-28T15:14:07Z",
    "file_size": 249073,
    "plain_text": "# Evade Sandboxes With a Single Bit – the Trap Flag\n\n**[unit42.paloaltonetworks.com/single-bit-trap-flag-intel-cpu/](https://unit42.paloaltonetworks.com/single-bit-trap-flag-intel-cpu/)**\n\nMark Lim July 19, 2021\n\nBy [Mark Lim](https://unit42.paloaltonetworks.com/author/mark-lim/)\n\nJuly 19, 2021 at 3:30 PM\n\n[Category: Application Advisory/Analysis,](https://unit42.paloaltonetworks.com/category/application-analysis/) [Malware,](https://unit42.paloaltonetworks.com/category/malware-2/) [Unit 42](https://unit42.paloaltonetworks.com/category/unit-42/)\n\nTags: [Cortex,](https://unit42.paloaltonetworks.com/tag/cortex/) [Intel,](https://unit42.paloaltonetworks.com/tag/intel/) [Lampion,](https://unit42.paloaltonetworks.com/tag/lampion/) [Sandbox,](https://unit42.paloaltonetworks.com/tag/sandbox/) [threat prevention,](https://unit42.paloaltonetworks.com/tag/threat-prevention/) [Trap Flag,](https://unit42.paloaltonetworks.com/tag/trap-flag/) [WildFire](https://unit42.paloaltonetworks.com/tag/wildfire/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/single-bit-trap-flag-intel-cpu/)\n\n## Executive Summary\n\nUnit 42 has discovered a specific single bit (Trap Flag) in the Intel CPU register that can be\nabused by malware to evade sandbox detection in general purposes. Malware can detect\nwhether it is executing in a physical or virtual machine (VM) by monitoring the response of\nthe CPU after setting this single bit.\n\nSandboxing is a popular technique used to detect whether a sample is malicious. A sandbox\nanalyzes the behaviors of the binary as it executes inside a controlled environment. To\novercome the challenge of analyzing a large number of binaries with limited computing\nresources, virtual machines are used to build sandboxes. To evade detection, malware will\n\n\n-----\n\ntry to determine whether it is executing in a physical or virtual machine. When the malware\nfinds out it is executing in a virtual machine, it will terminate its execution or provide fake\noutputs to hide its real intentions.\n\nSome of the most common evasion techniques involve malware conducting various system\nchecks against the environment it is executing in. For example, malware will often look for\nabnormal screen resolution, hard disk and physical memory size. Sandboxes can build\ncountermeasures, such as returning fake information to the malware during these checks.\n\nThis blog documents how malware can detect the differences in CPU behaviors in a virtual or\nphysical machine with only a single bit in the CPU register.\n\nPalo Alto Networks customers are protected from malware families using similar sandbox\n[evasion techniques with Cortex XDR or the](https://www.paloaltonetworks.com/cortex/cortex-xdr) [Next-Generation Firewall with](https://www.paloaltonetworks.com/network-security/next-generation-firewall) [WildFire and](https://www.paloaltonetworks.com/products/secure-the-network/wildfire)\n[Threat Prevention security subscriptions.](http://paloaltonetworks.com/products/secure-the-network/subscriptions/threat-prevention)\n\n## Single-Step Mode With a Single Bit — the Trap Flag (TF)\n\nTo detect the use of a VM in a sandbox, malware could check the behavior of the CPU after\nthe trap flag is enabled.\n\nThe trap flag (TF) is the 8th single bit in the EFLAGs register of the Intel x86 CPU\narchitecture. If the TF is enabled before a single instruction is executed, the CPU will raise\nan exception (single-step mode) after the instruction is completed. This exception stops the\nCPU execution to allow the contents of the registers and memory location to be examined by\nthe exception handler. Before allowing code execution to continue, the CPU also has to clear\nthe TF.\n\nTo determine whether a VM is used, malware can check whether the single-step exception\nwas delivered to the correct CPU instruction, after executing specific instructions (e.g.\nCPUID, RDTSC, IN) that cause the VM to exit with the TF enabled. During VM exits, the\nhypervisor – also known as Virtual Machine Monitor (VMM) – will emulate the effects of the\nphysical CPU it encounters.\n\nThe following sequence of instructions explains the CPU’s behavior after enabling the TF in\na physical machine.\n\nFigure 1. CPU instructions to enable TF.\n\n\n-----\n\nThe first three instructions enable the TF bit in the EFLAGs register of the CPU. RDTSC is\nexecuted with the TF enabled. In a physical machine, the exception would be delivered to\nthe first no operation (NOP) instruction (0x00401073). Take note that the exception occurred\non the instruction immediately after the execution of the instruction with TF enabled.\n\nFigure\n\n2. Execution in a physical machine.\nExecuting the same sequence of instructions in a VM would have a different effect. In a VM,\nexecuting RDTSC would result in a VM exit. The hypervisor will carry out its usual tasks of\nemulating the behaviors of the RDTSC instruction. However, an implementation of the\nhypervisor with incorrect emulation of the TF would result in the TF being ignored and the\ncode execution will continue to the first NOP instruction. During the execution of the first\nNOP instruction, the TF is still enabled as the TF was not handled by the hypervisor. This\nresults in an exception occurring on the second NOP instruction (0x00401073). The correct\nimplementation will require the hypervisor to inject a debug exception after emulating the\ninstruction that caused the VM exit and clearing the TF.\n\nFigure\n\n3. Execution in a virtual machine.\nAs a sandbox evasion technique, malware will use an exception handler in addition to the\nabove instruction sequence to examine which instruction the exception occurred on. The\nnext section describes a real-world example of a malware family that made use of this\ntechnique to evade sandboxes.\n\n## Real-World Example\n\nLampion is a malware family that was targeting users in Portugal. Lampion employed\nmultiple system checks to evade sandbox detection. One of the techniques is making use of\nthe single-step mode with TF, as discussed in the previous section.\n\nLampion implemented all its system checks with x86 assembly instructions and minimal\nWindows API calls. This allowed the Lampion samples to conceal their behavior from the\nsandboxes. The Lampion samples would terminate if the malware determined it was\n\n\n-----\n\nexecuting inside a VM. The system checks are also intertwined with multiple anti-reverse\nengineering techniques to hide from human analysts.\n\nThe following screenshot shows a snippet of instructions hidden in the Lampion sample that\nconducts the system check.\n\nFigure 4. Instructions in Lampion used to evade sandboxes.\nThe following is pseudocode to demonstrate how Lampion carries out one of its sandbox\nsystem checks by enabling TF on an instruction that causes the VM to exit.\n\n\n-----\n\nFigure 5. Pseudocode of Lampion carrying out anti sandbox check using TF.\nThe instruction right after the instruction RDTSC is NOP. The byte code for the NOP\ninstruction is 0x90. The exception handler would traverse the ContextRecord structure to\nlocate the address of the instruction in the Extended Instruction Pointer register (EIP) when\nthe exception occurred. The instruction is then compared against the 0x90 byte and the\nmalware will exit if the check fails.\n\nThe following screenshot shows the EIP=0x7F0E4E when the exception happened.\n\n\n-----\n\nFigure 6. Address of the instruction where the exception occurred.\n\n## Malware vs Sandbox Authors\n\nFor many years, there has been an ongoing cat and mouse game between malware authors\ncrafting evasion techniques to prevent effective analysis, and sandbox authors who research\nnovel ways to defeat those evasions.\n\nThis is one of the main drivers that led us at Palo Alto Networks to build our own custom\nhypervisor for malware analysis. Since we have full control over the software stack, including\nthe virtualization layer, we can react to new and emerging threats. In this particular case,\nonce we had identified the issue with the incorrect emulation of the trap flag, our hypervisor\nteam was able to test and deploy a fix. This evasion issue has since been resolved for any\nmalware sample using this technique.\n\nPalo Alto Networks customers are further protected from malware families using similar\n[sandbox evasion techniques with Cortex XDR or the](https://www.paloaltonetworks.com/cortex/cortex-xdr) [Next-Generation Firewall with](https://www.paloaltonetworks.com/network-security/next-generation-firewall) [WildFire](https://www.paloaltonetworks.com/products/secure-the-network/wildfire)\n[and Threat Prevention security subscriptions. AutoFocus customers can track the malware](http://paloaltonetworks.com/products/secure-the-network/subscriptions/threat-prevention)\n[discussed here using the Lampion tag. Other similar sandbox evasion techniques that rely](https://autofocus.paloaltonetworks.com/#/tag/Unit42.Lampion)\non abusing Intel CPU instructions or registers will not work against WildFire.\n\n**Indicators of Compromise**\n\n**Lampion Sample**\n\nEB3F2BE571BB6B93EE2E0B6180C419E9FEBFDB65759244EA04488BE7C6F5C4E2\n\n**Get updates from**\n\n**Palo Alto**\n\n\n-----\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-19 - Evade Sandboxes With a Single Bit – the Trap Flag.pdf"
    ],
    "report_names": [
        "2021-07-19 - Evade Sandboxes With a Single Bit – the Trap Flag.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535722,
    "ts_updated_at": 1743041118,
    "ts_creation_date": 1653750847,
    "ts_modification_date": 1653750847,
    "files": {
        "pdf": "https://archive.orkl.eu/82c7eff5db67e41d8747c44b57f4f3cd9f8f7714.pdf",
        "text": "https://archive.orkl.eu/82c7eff5db67e41d8747c44b57f4f3cd9f8f7714.txt",
        "img": "https://archive.orkl.eu/82c7eff5db67e41d8747c44b57f4f3cd9f8f7714.jpg"
    }
}