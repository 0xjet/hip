{
    "id": "5cf2a088-c84e-4a8b-9fb4-217d4c10fc56",
    "created_at": "2023-04-05T02:08:22.49047Z",
    "updated_at": "2025-03-27T02:15:35.656846Z",
    "deleted_at": null,
    "sha1_hash": "9c638be7f36fee44806581a121e7fda0130ea3e6",
    "title": "2023-02-27 - Stealc- a copycat of Vidar and Raccoon infostealers gaining in popularity – Part 2",
    "authors": "",
    "file_creation_date": "2023-04-03T08:55:14Z",
    "file_modification_date": "2023-04-03T08:55:14Z",
    "file_size": 2765892,
    "plain_text": "# Stealc: a copycat of Vidar and Raccoon infostealers gaining in popularity – Part 2\n\n**[blog.sekoia.io/stealc-a-copycat-of-vidar-and-raccoon-infostealers-gaining-in-popularity-part-2/](https://blog.sekoia.io/stealc-a-copycat-of-vidar-and-raccoon-infostealers-gaining-in-popularity-part-2/)**\n\n27 February 2023\n\n[Threat & Detection Research Team\nFebruary 27 2023](https://blog.sekoia.io/author/tdr/)\n232\n0\n\nRead it later\nRemove\n\n16 minutes reading\n\n## Context\n\n[This report is a follow up of the previous blog post on Stealc. Stealc is an information stealer advertised on the underground forums XSS,](https://blog.sekoia.io/stealc-a-copycat-of-vidar-and-raccoon-infostealers-gaining-in-popularity-part-1/)\nExploit and BHF by the Plymouth threat actor. In this blog post, we focus on the technical analysis of a standalone sample. Similarities\nwere observed with Vidar, Raccoon and Mars stealers during the reverse engineering phase.\n\nFunctionalities implemented in Stealc, including environment detection, anti-analysis, strings obfuscation, dynamic API resolution, a significant\nlist of targeted browsers, extensions, wallets and installed software makes it a top-tier threat within the infostealer ecosystem.\n\n## Malware analysis\n\nThe next sections list the different techniques observed during the reverse engineering of Stealc to provide information and detailed\nexplanations on Stealc operations and behaviors.\n\n_[All details of the infection chain, distribution and tracking of this threat were provided in part 1.](https://blog.sekoia.io/stealc-a-copycat-of-vidar-and-raccoon-infostealers-gaining-in-popularity-part-1/)_\n\n[Stealc sample SHA-256 used for the analysis is: 77d6f1914af6caf909fa2a246fcec05f500f79dd56e5d0d466d55924695c702d](https://bazaar.abuse.ch/sample/77d6f1914af6caf909fa2a246fcec05f500f79dd56e5d0d466d55924695c702d/)\n\n[Stealc sample SHA-256 with a next stage configured is: 1587857ad744c322a2b32731cdd48d98eac13f8aa8ff2f2afb01ebba88d15359](https://bazaar.abuse.ch/sample/1587857ad744c322a2b32731cdd48d98eac13f8aa8ff2f2afb01ebba88d15359/)\n\n### Anti analysis\n\nThe malware implements anti-analysis techniques by adding unconditional jump to a nearby offset, confusing the decompiler that cannot grasp\nthe pointed function.\n\nAs shown in figure 1, the decompiler analyzed a function with multiple jump instructions (jz, jnz opcodes), with a destination address defined to\nthe next address plus an offset of 1 or 2 (depending on the case). This results in the decompiler not making a correct assumption and avoiding\ndecompiling the function.\n\n\n-----\n\nFigure 1. Wrong disassembly of the main function due to Stealc implemented anti-analysis technique\nRebuilding the function by setting the location to undefined and patching the previous byte of the location with a NOP instruction, decompilers\ncan work properly. When applying this technique, the decompiled opcodes are the following:\n\nFigure 2. Patched function that can be correctly decompiled by IDA\nHere, the instructions mov eax, 9DE9h (B8 E8 9D 00 00) are wrongly disassembled because of the location+1. Undefining the location,\nreplacing the B8 of the mov instruction by a NOP(0x90) and re-defining the beginning of the next instruction to E8 results in the correct\ndisassembly of this code section.\n\nFigure 3. Jump in the middle trick patching example\n\n\n-----\n\n### a u ct o o e e\n\n[Following the patching of the sample, the main function of Stealc shows similarities to the one analyzed in Raccoon and](https://blog.sekoia.io/raccoon-stealer-v2-part-2-in-depth-analysis/) **[Mars](https://blog.sekoia.io/mars-a-red-hot-information-stealer/)** **stealers**\nreverses, notably in terms of operation order and used techniques.\n\nFigure 4. Main function overview\n\nThe execution flow of Stealc is straightforward, it first deobfuscates strings used for further dynamic API resolution. Then, it performs\nvarious checks on the infected host to exit on particular conditions, it also checks the amount of RAM and whether it is executed by an\n**antivirus solution. Finally, it verifies that the current date is preceding the hardcoded one.**\nAfter this initial setup and detection, the malware goes to the function responsible for the C2 interaction, in which the stealer configuration is\ndownloaded, and data are exfiltrated.\n\n### Defeating string encryption\n\nThe malware stores its strings and part of its configuration is obfuscated. Stealc data are RC4-encrypted and base64-encoded. The key for\ndecryption is stored in the PE in cleartext, as seen in the first variable assignment in figure 5.\n\n\n-----\n\nFigure 5. Base64\n\ndecoding and RC4 decryption function\n_For further analysis, an IDA script to decrypt the strings and assign their value to the correct DWORD is provided in annex 2._\n\n### Dynamic API resolution\n\nTo reduce its detection rate by antivirus solutions, Stealc uses the Dynamic API Resolution (T1027.007) technique. To do so, the malware\nsearches for the kernel32 base address using the PE header structure and goes through LDR_DATA_TABLE_ENTRY. Then, it iterates over\nthe table until it matches the GetProcAddress function and returns the address of the dedicated entry.\n\nFigure 6. Debugging of\n\nthe search GetProcAddess of Kernel32.dll\nIn figure 6, register EAX is used to store kernel32 base address:\n\n1. Register fs:000030h is the address of the [ProcessEnvironmentBlock (PEB) member of the](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb) [ThreadEnvironmentBlock (TEB) structure ;](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb)\n2. The offset 0xC of the PEB structure is the [LDR_DATA structure member that contains a pointer to the InMemoryOrderModuleList](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data)\n\nmember;\n3. InMemoryOrderModuleList is a structure of type [LIST_ENTRY whose member DllBase is pointer to Kernel32 (see figure6)](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data#remarks)\n\nOnce the malware obtains the address of GetProcAddress, it loads the function LoadLibrary and other functions from kernel32 including\nOpenEventA, CreateEventA, Sleep, VirtualAlloc, etc.\n\nLoadLibrary is used to load advapi32 gdi32 user32 crypt32 and ntdll DLLs only specific functions of these libraries are loaded afterwards\n\n\n-----\n\nFigure 7.\n\nExtract of the function used to load extra libraries and their methods\n\n[Subscribe to our newsletters](https://www.sekoia.io/en/newsletter/)\n\n### Environment detection & checks\n\nStealc attempts to detect its environment for two purposes:\n\n1. Exit in particular conditions (sandbox environment, unwanted location, etc.)\n2. Host fingerprinting\n\nThe malware implements the following exit conditions:\n\nUsername is JohnDoe (Windows Defender emulator default username);\nHostname is HAL9TH (Windows Defender emulator default hostname);\nConfigured language is Russian;\nExpiration date is overdue, a date is hardcoded in the binary, if this date is passed, the malware exits. This is almost certainly a\nfunctionality added to the build by the developer(s) as part of their business model;\nSection .text should be writable (by default Stealc configures its .text with write permission).\nRAM capacity is below 1 GB;\nNo display is configured.\n\n### Miscellaneous functionalities\n\nStealc also implements functionalities common to other malware of the stealer family. It has the capability to take a screenshot of the infected\nhost and to fingerprint the infected machine. To retrieve this information, the sample queries the suitable registry keys and interacts with the\nWindows API.\n\nThe fingerprinted information are:\n\nPublic IP address;\nGeolocation;\nHardware ID;\nOperating System version;\nArchitecture;\nUsername;\nComputer name;\nLocal time;\nLanguage;\nKeyboard layout;\nPhysical resources: CPU (core, name), RAM, number of threads, display resolution and GPU driver;\nList of running processes;\nList of installed applications.\n\n### Command and Control communication\n\n\n-----\n\ne a a e co u cates o e, data a e se t OS equests t at use u t o st uctu e ose o s a e t e sto e data\nencoded in base64.\n\nIn the first interaction, the infected host sends its HWID (hardware ID) and its build name (the value is “default“).\n\nThe server responds with the following base64 string:\n\nMWZjZTYzMTFhZDg1NmUzYTVjNTQ5OTQ0NDU0NWJmOGJjNjc2MDc0YTY3ZWIwZDJiMmZiNTQwMWE4OTMxODM3Y2NiZDlhMTllfGlzZG9uZ\n\nThe decoded content from the base64 format is:\n\n1fce6311ad856e3a5c5499444545bf8bc676074a67eb0d2b2fb5401a8931837ccbd9a19e|isdone|docia.docx|1|1|0|1|1|1|1|1|\n\nThe first hash is, in fact, an identifier used as a token for all communications, and sent in a dedicated form for each message.\n\nThe early communications of the malware aim at downloading the configuration of the stealer, for instance the path and file patterns to look for\non the infected host, the wallets or extensions to search, etc.\n\nThe stealer gets its configuration from the C2, with a POST request whose two forms are sent. The form name “message” indicates which\ntype of data will be sent, it could be “browser“, “plugin“, “wallets” or “files“. The structure of the C2 response (for the configuration) is always the\nsame, data are concatenated with the pipe character | (see figure 9).\n\nIt repeats this same operation for each browser, their extensions, for the wallets and installed applications.\n\n[The list of targeted assets is provided in the part 1 of Stealc analysis in the annex 1 – Stealc capabilities.](https://blog.sekoia.io/stealc-a-copycat-of-vidar-and-raccoon-infostealers-gaining-in-popularity-part-1/)\n\nFigure 8. Downloaded configuration encoded in base64\nAfter downloading the bot configuration, the stealer sends the fingerprinted information (see section Miscellaneous functionalities for the list of\nfingerprinted information that are exfiltrated).\n\nThe table below displays communications between the infected host and Stealc C2.\n\n**Request** **Request forms** **Response** **Functionality**\n\nRegister infected host and download configuration\n\nPOST main URL hwid, build name token\n\n\nPOST main URL token, message=”browsers” browsers\nconfiguration\n\nPOST main URL token, message=”plugins” plugins\nconfiguration\n\n\nconfigure the browsers stealing\noperation\n\nconfigure the plugins stealing\noperation\n\n\n-----\n\nPOST main URL token, host fingerprint\n(RAM, OS, apps, etc)\n\nTarget Chromium-based browsers (e.g. Chrome,\nChromium, Edge)\n\nGET DLLs URL sqlite3.dll download\nsqlite3.dll\n\nPOST main URL token, file_name, file Chrome cookies\n\nPOST main URL token, file_name, file Chrome history\n\nPOST main URL token, file_name, file Chrome extensions (exfiltrated\neach file separately)\n\nGET DLLs URL freebl3.dll download\nfreebl3.dll\n\nGET DLLs URL mozglue.dll download\nmozglue.dll\n\nGET DLLs URL msvcp140.dll download\nmsvcp140.dll\n\nGET DLLs URL nss3.dll download\nnss3.dll\n\nGET DLLs URL softoknn3.dll download\nsoftokn3.dll\n\nGET DLLs URL vcrunctime140.dll download\nvcrunctime140.dll\n\nTarget Firefox-based browsers, repeat the actions\nexecuted for Chromium-based\n\nTarget Opera-based browsers, same actions\nexecuted for Chromium-based\n\n\nPOST main URL token, message=”wallets” list of targeted\nwallets\n\nPOST main URL token, message=”files” file grabber\nconfiguration\n\n\nconfigure the wallets stealing\noperation\n\nconfigure the file grabber\n\n\nPOST main URL token, file_name, file exfiltrate each file matching the\ngrabber configuration\n\nTarget desktop applications: Outlook, Steam, Tox,\nPidgin, Discord, Telegram\n\nPOST main URL token, file_name, file send the screenshot\n\nPOST main URL token, message=isdone Next stage URL Get the URL of the next stage to\nexecute\n\nGET unrelated URL to Stealc infrastructure Executable Download the next stage\n\n_Table 1. Table of Stealc’s HTTP communications with the C2_\n\nmain url: 752e382b4dcf5e3f.php\nDLLs url: /dbe4ef521ee4cc21/\n\nFor each browser, wallets, plugins, the same actions are repeated and the forms are the same. The last communication is optional, this\nrequest is sent only if Stealc has a next stage configured on its panel.\n\n**File grabber**\n\nAfter stealing data from targeted browsers and their extensions, the stealer uses its file grabber functionality. The grabber configuration is\nreceived from the C2 and is formatted as follow:\n\nstandart|%DESKTOP%\\\\|*.txt,*.doc,*.docx,*.xls|7000|1|0|\n\nThe structure of the configuration is the following one. First a name, then a directory or a shortcut to a directory (here the desktop), thirdly a list\nof file extensions that the malware wants to exfiltrate and finally the maximum size. We also identified 2 extra parameters that were not useful\nfor the analysis.\n\n\n-----\n\ncase t e e a e a d pat atc t e g abbe te s, t s e t ated a OS equest to t e C t t ee o s\n\n**Form ID** **Form name** **Form value**\n\n1 token The token value provided by the C2 in the earlier communication\n\n2 file_name The full file path to the stolen file encoded in base64\n\n3 file The file content encoded in base64\n\nTable 2. List of forms and their content when conditions for exfiltration are met\n\nFigure 9. Example of a file exfiltrated by the file grabber\n\n**DLLs loading**\n\nTo access particular files or data, Stealc requires external DLLs that are not embedded in the PE but rather downloaded from a specific URL\nhosted by the C2. The downloaded DLLs are:\n\n1. sqlite3.dll\n2. freebl3.dll\n3. mozglue.dll\n4. msvcp40.dll\n5. nss3.dll\n6. softokn3.dll\n7. vcruntime140.dll\n\nThe DLLS are all written in the C:\\ProgramData\\ directory and are then loaded (TTP: Shared Module: T1129). Of note, only specific functions\nare loaded by the malware.\n\nFigure 10.\n\nS lit 3 dll f ti l di\n\n\n-----\n\nte oad g t e equ ed u ct o a t es o t e s, Stea c e p o ts t e to access data o te est, S a y, e a ta geted data s ou d\non the infected host, it is sent to the C2 using a POST request and encoding data in base64.\n\nAs described in this section, Stealc can be noisy in case many files are exfiltrated to the C2.\n\n### Next Stage\n\nAs other analysed stealers observed upgrading their set of functionalities, Stealc is also able to download and execute a next stage payload.\nThe next stage is configured by the request containing the form “isdone” or “done”, depending on the sample. The C2 responds with a base64\ndata containing the URL of the next stage to download.\n\n[The sample (Stealc SHA-256: 1587857ad744c322a2b32731cdd48d98eac13f8aa8ff2f2afb01ebba88d15359) is configured to execute a next](https://bazaar.abuse.ch/sample/1587857ad744c322a2b32731cdd48d98eac13f8aa8ff2f2afb01ebba88d15359/)\nstage which is a Laplas Clipper, here is the response of Stealc C2 to configure the next stage, the next payload is configured by an URL that\nStealc download and execute (see figure 15).\n\nFigure 11. Next stage configuration\n\n\n-----\n\nFigure 12.\n\nDecompiled function for the execution and download of the next\n\n### Trace removal\n\nStealc attempts to reduce its infection traces by removing itself and its downloaded DLLs (T1070.004) with the following one-line command:\n```\ncmd.exe /c timeout /t 5 & del /f /q \"$STEALERPATH\" & del \"C:\\ProgramData\\*.dll\" & exit\n\n```\nThe command is executed with a basic ShellExecuteA function from Shell32.dll.\n\n## Conclusion\n\n**Stealc displays all functionalities and behaviors to be a viable tool in the information stealer catalog, and will almost certainly be incorporated**\nin multiple intrusion sets’ toolsets, either as a shift or an expansion of their capabilities. Based on observed similarities between Stealc and\nother malware of the infostealer family, notably Raccoon and Mars stealer, SEKOIA.IO analysts assess it is likely a confirmation of a\ntransmission and circulation of knowledge, including source code, and of human resources, in the Russian-speaking cybercriminal ecosystem.\n\nSEKOIA.IO analysts expect Stealc developer will almost certainly continue to update its stealer with new and / or improved features in the near\nterm to meet customers’ expectations and expand its customer base. To provide our customers with actionable intelligence, SEKOIA.IO\n[analysts will continue to monitor emerging and prevalent infostealers, including Stealc.](https://blog.sekoia.io/tag/stealer/)\n\n## Annex 1 – Configuration extraction\n\nAs introduced in the strings obfuscation section, Stealc embeds the address of the C2 and its different URLs in the rdata section of the PE.\n\nBased on our observation, the script should meet the following requirements:\n\n1. Retrieve the RC4 key in rdata;\n2. Deobfuscate the strings until all patterns related to the C2 are spotted.\n\n\n-----\n\ne C ey s a dcoded t e c ea te t a d by de t o C eys a e 0 bytes o g Stea c C o at o a e sto ed t t e\nfollowing structure:\n\nC2 base URL: http://<ip or domain> or https://<ip or domain>;\nC2 URL resource which is a random string ending by .php extension;\nC2 directory name where the DLLs are hosted (nss3.dll, sqlite3.dll, etc…).\n\nThe provided configuration extractor simply loops over that section to find the patterns described previously.\n\n\n-----\n\n```\nfrom pefile import PE, SectionStructure\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms\n\n\nclass Stealc:\n\n  \"\"\"Stealc configuration\"\"\"\n\n  rc4_key: bytes = b\"\"\n\n  base_url: str = \"\"\n\n  endpoint_url: str = \"\"\n\n  dlls_directory: str = \"\"\n\n  def __str__(self):\n\n    out = f\"Stealc RC4 key: {self.rc4_key}\\n\"\n\n    out += f\"SteaC Command and Control:\\n\"\n\n    out += f\"\\t- {''.join([self.base_url, self.endpoint_url])}\\n\"\n\n    out += f\"\\t- {''.join([self.base_url, self.dlls_directory])}\\n\"\n\n    return out\n\n  def rc4_decrypt(self, data: bytes) -> bytes:\n\n    \"\"\"decrypt RC4 data with the provided key.\"\"\"\n\n    algorithm = algorithms.ARC4(self.rc4_key)\n\n    cipher = Cipher(algorithm, mode=None)\n\n    decryptor = cipher.decryptor()\n\n    return decryptor.update(data)\n\n\ndef get_section(pe: PE, section_name: str) -> SectionStructure:\n\n  \"\"\"return section by name, if not found raise KeyError exception.\"\"\"\n\n  for section in filter(\n\n    lambda x: x.Name.startswith(section_name.encode()), pe.sections\n\n  ):\n\n    return section\n\n  available_sections = \", \".join(\n\n    [_sec.Name.replace(b\"\\x00\", b\"\").decode() for _sec in pe.sections]\n\n  )\n\n  raise KeyError(\n\n    f\"{section_name} not found in the PE, available sections: {available_sections}\"\n\n  )\n\n\ndef get_rdata(pe_path: str) -> SectionStructure:\n\n  \"\"\"Extract Stealc radata section\"\"\"\n\n  pe = PE(pe_path)\n\n  section_rdata = get_section(pe, \".rdata\")\n\n  return section_rdata\n\n\ndef is_valid_string(data: bytes) -> bool:\n\n  return True if all(map(lambda x: x >= 43 and x <= 122, data)) else False\n\n\ndef search_Command_and_Control(stealc: Stealc, rdata_section: SectionStructure):\n  \"\"\"\n\n  Search two types of strings in rdata section of Stealc:\n\n  1. The RC4 key which is 20 bytes long;\n\n  2. Strings matching the way Stealc stores its C2 configuration (these strings are decoded (base64 decode + RC4 decryption),\n\n    This works for the Stealc version at least until 15 Feb 2023 but could change in new versions...\n\n    2.1 base url (`http://something...` or `https://something...`)\n\n    2.2 endpoint which ends with `.php`\n\n    2.3 DLLs directory starts and ends with `/` (eg: `/something_random/`)\n\n  \"\"\"\n\n  for string in filter(\n\n    lambda x: x and is_valid_string(x), rdata_section.get_data().split(b\"\\x00\" * 2)\n\n  ):\n\n    if len(string) == 20 and not stealc.rc4_key:\n\n      # Hopefully the RC4 key is stored as the beginning of the rdata section\n\n      stealc.rc4_key = string\n\n      print(f\"[+] RC4 key found: {stealc.rc4_key}\")\n\n    if stealc.rc4_key and string != stealc.rc4_key:\n\n      try:\n\n          l l d (b d d ( i ))\n\n```\n\n-----\n\n```\n        if cleartext.startswith(b\"http://\") or cleartext.startswith(\n\n          b\"https://\"\n\n        ):\n\n          print(f\"[+] Found StealC Command and Control\")\n\n          stealc.base_url = cleartext.decode()\n\n        elif cleartext.startswith(b\"/\") and cleartext.endswith(b\"/\"):\n\n          print(f\"[+] Found DLLs URL directory name\")\n\n          stealc.dlls_directory = cleartext.decode()\n\n        elif cleartext.endswith(b\".php\"):\n\n          print(f\"[+] Found StealC endpoint\")\n\n          stealc.endpoint_url = cleartext.decode()\n\n      except Exception:\n\n        pass\n\n\nif __name__ == \"__main__\":\n\n  import sys\n\n  if len(sys.argv) < 2:\n\n    print(f\"not enough parameter, please provide as argument the path to stealc sample.\")\n\n  stealc = Stealc()\n\n  rdata = get_rdata(sys.argv[1])\n\n  search_Command_and_Control(stealc, rdata)\n\n  print(stealc)\n\n## Annex 2 – IDA script for string deobfuscation\n\n```\n\n-----\n\n```\nfrom ida_bytes import *\n\nfrom ida_name import *\n\nfrom base64 import b64decode\n\nfrom string import ascii_letters, digits\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\ndef read_rdata(name: str) -> str:\n\n  print(f\"read_rdata: {name}\")\n\n  addr = get_name_ea_simple(name)\n\n  size = get_max_strlit_length(addr, ida_nalt.STRENC_DEFAULT)\n\n  return get_bytes(addr, size - 1)\n\ndef rc4_decrypt(key: bytes, data: bytes) -> bytes:\n\n  algorithm = algorithms.ARC4(key)\n\n  cipher = Cipher(algorithm, mode=None)\n\n  decryptor = cipher.decryptor()\n\n  return decryptor.update(data)\n\ndef deobfuscate_string(base: int, end: int, KEY: bytes):\n\n  ea = base\n\n  size = 0\n\n  clear = []\n\n  addr = []\n\n  while ea <= end:\n\n    flags = ida_bytes.get_flags(ea)\n\n    if ida_bytes.is_code(flags):\n\n      instr_str = idc.generate_disasm_line(ea, 1)\n\n      instr_str = \" \".join(instr_str.split())\n\n      if instr_str.startswith(\"push offset a\") or instr_str.startswith(\"mov dword ptr [esp], offset a\"):\n\n        value = instr_str.split(\"offset\")[-1].split(';')[0].strip()\n\n        value = read_rdata(value)\n\n        clear.append(rc4_decrypt(KEY, b64decode(value)))\n\n      elif instr_str.startswith(\"mov dword_\"):\n\n        temp = instr_str.replace(\"mov dword_\", \"\")\n\n        temp = temp.split()[0].replace(\",\",\"\")\n\n        addr = int(temp, 16)\n\n        string = get_bytes(addr, size)\n\n        cleartext = clear.pop(-1)\n\n        cleartext = cleartext.decode()\n\n        idc.set_cmt(ea, cleartext, 0)\n\n        text = \"\"\n\n        for c in cleartext:\n\n          if c in f\"{ascii_letters}{digits}\":\n\n            text += c\n\n          else:\n\n            text += \"_\"\n\n        cleartext = f\"str_{text}\"\n\n        print(f\"replace dword_{addr:x} by `{cleartext}`\")\n\n        set_name(addr, cleartext)\n\n    ea += 1\n\n```\n[Subscribe to our newsletters](https://www.sekoia.io/fr/newsletter/)\n\nThank you for reading this blogpost. You can also consult other results of surveys carried out by our analysts on the ecosystem of infostealers :\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-27 - Stealc- a copycat of Vidar and Raccoon infostealers gaining in popularity – Part 2.pdf"
    ],
    "report_names": [
        "2023-02-27 - Stealc- a copycat of Vidar and Raccoon infostealers gaining in popularity – Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1680660502,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1680512114,
    "ts_modification_date": 1680512114,
    "files": {
        "pdf": "https://archive.orkl.eu/9c638be7f36fee44806581a121e7fda0130ea3e6.pdf",
        "text": "https://archive.orkl.eu/9c638be7f36fee44806581a121e7fda0130ea3e6.txt",
        "img": "https://archive.orkl.eu/9c638be7f36fee44806581a121e7fda0130ea3e6.jpg"
    }
}