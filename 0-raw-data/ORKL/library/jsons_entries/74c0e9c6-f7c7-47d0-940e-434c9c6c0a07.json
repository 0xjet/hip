{
    "id": "74c0e9c6-f7c7-47d0-940e-434c9c6c0a07",
    "created_at": "2023-01-12T15:00:49.064396Z",
    "updated_at": "2025-03-27T02:05:48.716792Z",
    "deleted_at": null,
    "sha1_hash": "c6a07391c101a027adf2ab303645c45ff431bf62",
    "title": "2020-06-08 - Dark Nexus- the old, the new and the ugly",
    "authors": "",
    "file_creation_date": "2022-05-28T15:21:09Z",
    "file_modification_date": "2022-05-28T15:21:09Z",
    "file_size": 433086,
    "plain_text": "# Dark Nexus: the old, the new and the ugly\n\n**[stratosphereips.org/blog/2020/6/8/dark-nexus-the-old-the-new-and-the-ugly](https://www.stratosphereips.org/blog/2020/6/8/dark-nexus-the-old-the-new-and-the-ugly)**\n\nStratosphere IPS June 8, 2020\n\nIn this blog post we will focus on an ARM7 Dark Nexus sample [1] and version v5 of this\nmalware to highlight its functionality, both old and new, and to explore more invasive (or\n_ugly) and innovative techniques. This sample was statically linked but not stripped making it_\neasy to reverse and analyze.\n\nDark Nexus is an IoT botnet found by Bitdefender at the end of 2019 and beginning of 2020\n\n[2]. According to their findings, this botnet had approximately 1,300 bots and was very\nprominent in Asia. Along with a white paper the company also released a list of 327 sample\nhashes related to this bot [3]. From this list, 231 sample files were actually found on Virus\nTotal, showing these binary architectures:\n\n\n-----\n\n## The Old\n\nPart of its code was based in Mirai. By comparing this unstripped sample to the codebase\nof Mirai we can see what was reused:\n\nstatic ipv4_t get_random_ip(void)\n\nvoid attack_udp_plain(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len,\nstruct attack_option *opts)\n\nBOOL killer_kill_by_port(port_t port)\n\nuint16_t checksum_generic(uint16_t *addr, uint32_t count)\n\nuint16_t checksum_tcpudp(struct iphdr *iph, void *buff, uint16_t data_len, int len)\n\nvoid resolv_entries_free(struct resolv_entries *entries)\n\nstruct resolv_entries *resolv_lookup(char *domain)\n\nThese functions were scrapped verbatim from the original Mirai source code and the\nmatches have been found by comparing the function symbols from both the source code\nand the binary sample. Other functions (eg. rand_port, retrieve_c2_server or\n**attack_tcp_raw) are based on original Mirai functions but modified to fit the necessities of**\nthe author.\n\n\n-----\n\nThe downside of reusing Mirai s codebase is that some of the favorable aspects of its code\nare often ignored. That’s the case of the encrypted data table. This table is the one in\ncharge of converting encrypted or obfuscated strings and data to its normal state, be it\nintegers or strings. Dark Nexus on the other hand shows passwords, usernames,\ncommand-and-control endpoints, etc. are in plain-text or deobfuscated. For example, the\nfunction retrieve_c2_server (Mirai’s retireve_cnc_addr) was adapted to resolve more\nthan one C&C address. These addresses are in plain-text in the main function of the bot\n(Figure 1).\n\n**Figure 1. Hardcoded C&C list populated to later be used by the bot.**\n\nAnother old method still used by this malware and many others is the Telnet brute forcing as\na method of growing its botnet. Insecure Telnet services are nothing new among IoT\nmalware and attacking them keeps being effective nowadays as devices with weak\ncredentials are accessible from the internet. Dark Nexus does this by calling spreader_init\nto populate its username/password structures and then init_syn_bruter. The latest will\nstart the attack against telnet services across the Internet and try to infect as many devices\nas possible under these CPU architectures:\n\n1. arm\n\n2. rce\n\n3. sh4\n\n4. arc\n\n5. ppc\n\n6. mk68\n\n7. spc\n\n8. x86\n\n9. i586\n\n10. mpsl / mips\n\n\n-----\n\n**Figure 2. Hardcoded domain name and IP address in init_syn_bruter function.**\n\n**Figure 3. The malware spreads on multiple architectures to have a wider range of infection.**\n\n## The New\n\n\n-----\n\nDark Nexus presents new techniques as well. Here we are going to mention two that we\nconsider interesting to show and describe: Reverse Proxy and Killer functions. These\nfunctions were already seen on other malware but have a twist that’s worth mentioning.\n\n## Reverse Proxy\n\nOne technique employed by this malware is reverse proxying requests to always be able to\ndeliver malware to new infections. It does this by first identifying who executed the malware,\nsaving the IP and port addresses from the command line used during the execution (Figure\n4). After this, the function init_reverse_proxy. This function is one improvement to\ncommon IoT malware, giving autonomy and self reliance to its bots. It starts by forking and\nconnecting to its C&C servers to download the multiple binaries that belong to each\nsupported architecture. If the malware wasn’t able to connect to any C&C server it will reach\nout to the IP and port registered during execution (Figure 4) to perform that action. After\narming itself with multiple bot variants, it will listen to a random port for GET requests to\nserve its binaries, acting as a pseudo-HTTP server (Figure 5).\n\n**Figure 4. IP and port reported by the bot that infected and ran the malware sample. This**\nwill later be used as a replacement for it’s C&Cs if needed.\n\n**Figure 5. User-Agent used by the malware is: hoho_fastflux/v5. The string “hoho” is**\ncommonly used throughout this malware.\n\n## Killer\n\nThe idea of a killer comes straight from its Mirai codebase. The purpose of the killer is to\nblock ports utilized by services like SSH and Telnet to avoid further invasion by other\nmalware or clients. Also, it kills any previous invasion in order to do a full takeover of the\n\n\n-----\n\ndevice.\n\nThe killer process is initialized by Dark Nexus by the killer function by forking into another\nprocess while saving its own process ID (PID) ina variable called lockdown_pid, which will\nbe discussed later. After that it will create an structure called suspect_list that will keep\ntrack of the processes being analyzed and judged by the malware (Figure 6). This structure\nis based on the PID of the analyzed process in the device and a “weight” which is an\nattribute that will define if the process is a threat to the bot and needs to be terminated. The\nThe function killer_run is then called and it will read all the process IDs from the /proc\ndirectory and weight the threat of the current process (PID) being analyzed by:\n\n1) Reading /proc/PID/exec and check if the executable of the process exists on the\nfilesystem. If it was deleted and appears as \"(deleted)\" then add +100 of weight\n\n2) Check /proc/PID/exec real path by using the readlink function. If binary is running in one\nof these paths to kill then add +90 of weight:\n\n/tmp/\n\n/var/\n\n/dev//var/tmp/\n\n/var/run/\n\n/\n\nThe paths to kill list is hardcoded in the binary.\n3) Open the directory /proc/PID/fd to read list of open files. If the list is greater than 250 then\nadd +10 weight.\n\n4) Open /proc/PID/cmdline to read the command line of the process. If starts with \"./\" it will\nadd +10 weight.\n\n5) Open /proc/PID/status and check if it has the string \"Groups:\\t0\". It will add +50 weight if\nit does.\n\n6) Open the process’ binary in /proc/PID/exe and read its strings. If \".dynamic\" was not\nfound meaning that is a possible static binary then add +50 weight. If the string \"UPX\" is\nfound then add +90 weight, as it is possible that the binary was also packed.\n\nAt the end of this process the malware will check the suspects list and, if the weight is\nabove 99 points it will kill the process as it imposes a threat to the bot (Figure 7).\n\n\n-----\n\n**Figure 6. Function (and process) killer is initialized along with the structure in charge of**\nkeeping track of the processes being analyzed.\n\n**Figure 7. Bot recursively checks all the processes’ weight and calls kill() to terminate**\nwhoever it finds threatening for its functioning.\n\n## The Ugly\n\nThe final purpose of an IoT malware is the complete take over of the device and to persist\nwithout intervention. Or digital intervention at least, as you can always just pull the plug in\nmost of the cases. Dark Nexus has a set of functions that ensure that no intervention is\nmade in order to stop the bot from doing its botmaster’s work.\n\n## Persistence\n\nIn case of the persistence, Dark Nexus chooses to disable all ways for an intruder or\nlegitimate user to reestablish the device normal behaviour by limiting execution of system\ncommands (Figure 8). It does this by changing the file permissions to 0, thus removing the\nread and execute permissions to avoid them being utilized (Figure 9).\n\nThe bot will also flush the iptables (firewall) rules and stop the “crond” daemon, the one in\ncharge of execute scheduled commands on the system. To ensure its correct functioning\nwhen scanning for victims, and also reading process IDs during the killer function, the bot\n\n\n-----\n\nwill set the limit of open file descriptors to 0x1000 (or 4096 in decimal numbers).\n\n**Figure 8. Methods used by the bot to impede the system from being restored.**\n\n**Figure 9. The bot removes all permissions on specific executables so no restoration of the**\ndevice is possible.\n\nOne interesting side note on this section is that, in the case of BusyBox [4], all those\nbinaries are symbolic links to /bin/busybox. Meaning that if the bot changes the\npermissions of any of those binaries it will be ultimately changing the permissions of the\nlatter. If that happens the whole system renders useless.\n\n## Lockdown\n\nDark Nexus performs a lockdown of the devices and ensures that it stays that way during its\nexecution. Lockdown is performed after the persistence procedure is in place to add an\nextra layer of control over the device. This lockdown phase starts with the init_lockdown\nfunction that counts the amount of PIDs currently existing in the device and then saves\nthose PIDs into a list called lockdown_pidlist. After the bot starts its normal execution and\nevery 2 seconds the function ensure_lockdown is called.\n\nThe ensure_lockdown function is the one in charge of killing any new process being\ncreated after the bot was executed. What it will do is to open the directory /proc and read\nthe existent PIDs, and kill those PIDs that match this criteria (Figure 10):\n\n1. Is not one of the attack processes.\n\n2. Is not the process ID of one of these processes: bot, lockdown, scanner and reverse\n\nproxy.\n\n\n-----\n\n3. PID is greater than 799.\n\n**Figure 10. Main part of the lockdown process. This ensures no intruder or legitimate**\nprocess is started as it gets killed if is not present in the lockdown PID list.\n\n## Conclusion\n\nIn this blog post we were able to take a sneak peek of what is Dark Nexus capable of and\nits details. We explored this by presenting it via three characteristics we named the old, the\n_new and the ugly. In The Old we showed how this malware imported a great deal of ideas_\nand code from a well-known IoT malware: Mirai. This is done regularly as Mirai source code\nwas made public since 2016 and its well structured, and easy to modify, code is the perfect\nfit for any new malware. A good side of this is that it makes the malware easy to identify as\nwell as to analyze.\n\nOn the other hand, in The New we presented new ideas that were adapted to work with this\n“old” code. Ideas like the reverse proxy that enables the bot to be more independent from\nit’s C&C or distribution endpoints. Or the killer function which evolved from it’s more\nprimitive variant seen in Mirai to a more intuitive one, analyzing and judging the processes\nbeing executed in the device by its characteristics.\n\n\n-----\n\nFinally, we present two functions that are of a questionable nature in The Ugly. These\nprocedures, like persistence and lockdown, turn the device being infected into a “brick”,\ninaccessible and unrecoverable from the outside world. And a device that cannot be\naccessed is a device that cannot be fixed.\n\nAll these characteristics show that IoT malware is improving while retaining its roots, and\nDark Nexus is the clear sign of this.\n\n## References\n\n[1] VirusTotal (2020, April 09).\n**_bc0457d7935e29aecb338756bde213cd18aa1b617b00d30c4deedd5eef9ba877._**\nhttps://www.virustotal.com/gui/file/bc0457d7935e29aecb338756bde213cd18aa1b617b00d3\n0c4deedd5eef9ba877/details\n\n[2] Liviu Arsene, Bitdefender (2020, April 08). New dark_nexus IoT Botnet Puts Others to\n**_Shame._** https://labs.bitdefender.com/2020/04/new-dark_nexus-iot-botnet-puts-others-toshame/\n\n[3] Bitdefender Investigations and Forensics Unit, Bitdefender (2020). New dark_nexus IoT\n**_Botnet Puts Others to Shame (Whitepaper)._**\nhttps://www.bitdefender.com/files/News/CaseStudies/study/319/Bitdefender-PRWhitepaper-DarkNexus-creat4349-en-EN-interactive.pdf\n\n[4] Denys Vlasenko. BusyBox: The Swiss Army Knife of Embedded Linux.\n[https://busybox.net/](https://busybox.net/)\n\n[5] jgamblin, GitHub (2020, October 23). Mirai-Source-Code.\n[https://github.com/jgamblin/Mirai-Source-Code](https://github.com/jgamblin/Mirai-Source-Code)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-08 - Dark Nexus- the old, the new and the ugly.pdf"
    ],
    "report_names": [
        "2020-06-08 - Dark Nexus- the old, the new and the ugly.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535649,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653751269,
    "ts_modification_date": 1653751269,
    "files": {
        "pdf": "https://archive.orkl.eu/c6a07391c101a027adf2ab303645c45ff431bf62.pdf",
        "text": "https://archive.orkl.eu/c6a07391c101a027adf2ab303645c45ff431bf62.txt",
        "img": "https://archive.orkl.eu/c6a07391c101a027adf2ab303645c45ff431bf62.jpg"
    }
}