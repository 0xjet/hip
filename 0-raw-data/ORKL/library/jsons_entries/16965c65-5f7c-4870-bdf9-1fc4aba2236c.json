{
    "id": "16965c65-5f7c-4870-bdf9-1fc4aba2236c",
    "created_at": "2023-01-12T15:03:01.493522Z",
    "updated_at": "2025-03-27T02:05:37.774965Z",
    "deleted_at": null,
    "sha1_hash": "773c6d30ab1def7294deaabe346e2dbccd835550",
    "title": "2021-08-25 - Reverse Engineering Crypto Functions- RC4 and Salsa20",
    "authors": "",
    "file_creation_date": "2022-05-28T17:38:13Z",
    "file_modification_date": "2022-05-28T17:38:13Z",
    "file_size": 868261,
    "plain_text": "# Reverse Engineering Crypto Functions: RC4 and Salsa20\n\n**[goggleheadedhacker.com/blog/post/reversing-crypto-functions](https://www.goggleheadedhacker.com/blog/post/reversing-crypto-functions)**\n\nJacob Pimental August 25, 2021\n\n### 25 August 2021\n\nMany malware samples use encryption for Command and Control (C2) communications,\nencrypting files, string obfuscation, and many other tasks. It can be challenging to know\nwhich encryption algorithm you are looking at when analyzing a sample. This post aims to\nteach newer analysts about common encryption algorithms, how they work, and how you can\nidentify them when reverse engineering.\n\n## RC4 Algorithm\n\n### How it Works\n\nRC4’s internal state is an array of 256 bytes, denoted as `S[], ranging from 0-255. RC4 will`\nuse its Key Scheduling Algorithm (KSA) to randomly swap the bytes in `S[] using the user`\ninputted key as the seed. `S[] is then used to generate a keystream via the Pseudo-`\nRandom Generation Algorithm (PRGA). This keystream, denoted as `KS[], is the same size`\nas the plaintext input. Finally, RC4 will XOR the keystream by the plaintext to create the\nencrypted ciphertext.\n\n\n-----\n\n**Key Scheduling Algorithm (KSA)**\n\nThe Key Scheduling Algorithm for RC4 will take the internal state referenced earlier, denoted\nas `S[], and permutate it based on a key the user inputs. For each index in` `S[], the`\nalgorithm will swap the value with another index of `S[] based on the value:` `(j +`\n```\nS[index] + key[index % keylength]) % 256, where j has a starting value of zero.\n\n```\nThis can be shown in the following Python code:\n```\ndef KSA(key):\n  \"\"\"Rearranges the values in an array of 256 bytes based on key.\n  Params:\n    key (str): Key used to permutate the bytes\n  Returns:\n    list: A permutation of 256 bytes used to generate keystream\n  \"\"\"\n  S = [i for i in range(256)] # Initialize array of 256 bytes\n  j = 0\n  for i in range(256):\n    k = ord(key[i % len(key)])\n    j = (j + S[i] + k) % 256 # Calculate index to swap\n    S[i], S[j] = S[j], S[i] # Swap values in the array based\n  return S\n\n```\n**Pseudo-Random Generation Algorithm (PRGA)**\n\nThe output from the Key Scheduling Algorithm is used to generate a keystream using RC4’s\nPRGA. This keystream will be the same size as the plaintext input and is generated by taking\nthe value at `S[i + 1], and swapping that with the value of` `(j + S[i + 1]) % 256 . For`\nthis example, `i is all numbers from zero to the length of the plaintext and` `j is zero. After`\nthis swap, the value `S[ (S[i] + S[j]) % 256 ] is appended to the keystream, thus`\ncreating a pseudo-random list of bytes. This can be shown in the following Python code:\n```\ndef PRGA(S, amount):\n  \"\"\"Pseudo-Random algorithm that creates the final keystream used to encrypt.\n  Params:\n    S (list): The 256 byte array generated by KSA\n    amount (int): Length the keystream needs to be (size of plaintext)\n  Returns:\n    list: The final keystream used for encryption\n  \"\"\"\n  j = 0\n  K = []\n  for i in range(amount):\n    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    S[i], S[j] = S[j], S[i]\n    K.append(S[(S[i] + S[j]) % 256])\n  return K\n\n```\n\n-----\n\n**Putting it All Together**\n\nOnce the keystream is generated, the RC4 algorithm will use it to encrypt the plaintext input\nby XORing the bytes together. Decryption works by deriving the same keystream using the\noriginal key and XORing that by the ciphertext. This entire process is shown in the following\nPython code:\n```\ndef XOR(pt, k):\n  \"\"\"XORs two arrays together.\n  Params:\n   pt (list): The plaintext array\n   k (list): The key to XOR by\n  Returns:\n   list: The ciphertext\n  \"\"\"\n  ct = []\n  for i in range(len(pt)):\n    ct.append(ord(pt[i]) ^ k[i])\n  return ct\ndef RC4(plaintext, key):\n  \"\"\"Main RC4 function.\n  Params:\n   plaintext (str): The plaintext to encrypt\n   key (str): The key used for encryption\n  Returns:\n   list: List of encrypted bytes\n  \"\"\"\n  S = KSA(key)\n  print(S)\n  K = PRGA(S, len(plaintext))\n  print(K)\n  ct = XOR(plaintext, K)\n  return ct\n\n### Identifying RC4 in Assembly\n\n```\nAn easy way of identifying that an application is using the RC4 algorithm is by looking for the\nvalue `256 when the algorithm is creating the initial state ( S[] ). This normally occurs in`\ntwo loops that run 256 times each and will be either creating or modifying an array.\n\n\n-----\n\n_Loop that creates initial S array of bytes from 0 to 255_\n\nIt is important to notice that in the second loop in RC4’s key scheduling algorithm the bytes in\n```\nS[] will be swapped around. You can see this in the following screenshot:\n\n```\n\n-----\n\n_Second loop in S array creation that swaps bytes_\n\nYou can also identify RC4 by its pseudo-random generation algorithm. Two important things\nto notice here are the use of the previously created `S[] variable and the XOR operand`\nbeing used. Keep in mind that this section will be looped by the length of the plaintext, not\n256 times like the KSA.\n\n\n-----\n\n_Main loop used for RC4 PRGA_\n\n\n-----\n\nBy identifying both functionalities in the code, it is safe to say that this is the RC4 algorithm.\nThis particular example was from my analysis of the Sodinokbi Ransomware in a previous\npost.\n\n## Salsa20 Algorithm\n\n### How it Works\n\nSalsa20 works by encrypting data in 64 bytes “blocks”. The algorithm is counter-based,\nmeaning that a counter variable is used when generating the key depending on which “block”\nof data is being encrypted. The internal state of Salsa20 consists of an array of 16 32-bit\nwords that can be shown as a 4x4 matrix:\n\n\n-----\n\n_Salsa20’s initial state_\n\nThis state then undergoes a “quarter-round” function which randomizes the values in the\nmatrix. Once the state is run through this function multiple times, normally 20, the final result\nis then added back to the initial state’s values. This becomes the keystream that will be\nXOR’d against 64 bytes of the plaintext data. Finally, the counter variable will be incremented\nand the process starts again with the next 64 bytes.\n\n**State Generation**\n\nThe initial state for Salsa20 consists of 16 32-bit words consisting of the following:\n\n**State**\n**variable** **Description**\n\n\n-----\n\n**State**\n**variable** **Description**\n\nKey 16 or 32 byte key defined by the user\n\nNonce Eight byte nonce value that can be randomly generated or given\n\nCounter The counter variable that denotes which “block” is being encrypted\n\nConstant Constant value of either “expand 32-byte k” or “expand 16-byte k” depending\non the length of the key\n\nIf the length of the key is 32 bytes, then it is split between the two sets of four 32-bit words in\nthe state with the first 16 bytes in the first set and the last 16 bytes in the second. Otherwise,\nif the length of the key is 16 bytes it is repeated between the two sets of four 32-bit words.\nThe state generation can be defined in the following Python code:\n```\ndef setup_keystate(self, key, nonce, counter=0):\n   \"\"\"Sets up initial keystate for Salsa20.\n   Params:\n     key (bytes): Key used to encrypt data (16 or 32 bytes)\n     nonce (bytes): One-time pad used to generate keystate\n     counter (int): Determines which blok is being encrypted\n   \"\"\"\n   nonce = list(struct.unpack('<2I', nonce)) # Splits nonce into 2 words\n   count = [counter >> 16, counter & 0xffff] # Generates high and low order words\nfor counter\n   if len(key) == 32:\n     const = list(struct.unpack('<4I', b'expand 32-byte k')) # Splits const\ninto 4 words\n     k = list(struct.unpack('<8I', key)) # Splits key into 8 words\n     self.state = [const[0], k[0],   k[1],   k[2],\n            k[3],   const[1], nonce[0], nonce[1],\n            count[1], count[0], const[2], k[4],\n            k[5],   k[6],   k[7],   const[3]]\n   elif len(key) == 16:\n     const = list(struct.unpack('<4I', b'expand 16-byte k'))\n     k = list(struct.unpack('<4I', key)) # Splits key into 4 words\n     self.state = [const[0], k[0],   k[1],   k[2],\n            k[3],   const[1], nonce[0], nonce[1],\n            count[1], count[0], const[2], k[0],\n            k[1],   k[2],   k[3],   const[3]]\n\n```\nAn example of how the state would look with a 16 byte and 32 byte key can be seen below:\n\n\n-----\n\n_Difference between 16 and 32 Byte key in Salsa20_\n\n**Generating Keystream**\n\nTo generate the keystream, Salsa20 uses a “quarter-round” function to randomize the data in\nits initial state. This function is called “quarter-round” as it is working on one column or row at\na time out of four, or one “quarter” at a time. The default number of “rounds” is 20, unless\notherwise specified. On even rounds, the algorithm will transform its column values using the\nquarter-round function and on odd rounds it will transform its rows. The quarter-round funtion\ncan be shown in the following Python code:\n```\ndef QR(self, x, a, b, c, d):\n   \"\"\"quarter-round function used in Salsa20.\n   Params:\n     x (array): Starting array to permutate\n     a (int): index value for array\n     b (int): index value for array\n     c (int): index value for array\n     d (int): index value for array\n   \"\"\"\n   x[b] ^= rol((x[a] + x[d]) & 0xffffffff, 7)\n   x[c] ^= rol((x[b] + x[a]) & 0xffffffff, 9)\n   x[d] ^= rol((x[c] + x[b]) & 0xffffffff, 13)\n   x[a] ^= rol((x[d] + x[c]) & 0xffffffff, 18)\n\n```\nOnce the initial state is run through this permutation function for the number of rounds\nspecified, it will then add the newly randomized state to its original values. This will ensure\nthat the process cannot be reversed and the key cannot be recovered. The entire keystream\ngeneration process looks like:\n\n\n-----\n\n```\ndef generate_ks(self):\n  \"\"\"Generates Keystream for Salsa20\n  Returns:\n    bytes: 64-byte keystream\n  \"\"\"\n  x = self.state[:]\n  for i in range(10):\n    self.QR(x, 0, 4, 8, 12)\n    self.QR(x, 5, 9, 13, 1)\n    self.QR(x, 10, 14, 2, 6)\n    self.QR(x, 15, 3, 7, 11)\n    self.QR(x, 0, 1, 2, 3)\n    self.QR(x, 5, 6, 7, 4)\n    self.QR(x, 10, 11, 8, 9)\n    self.QR(x, 15, 12, 13, 14)\n  out = []\n  for i in range(len(self.state)):\n    out.append((self.state[i] + x[i]) & 0xffffffff)\n  out = struct.pack('<16I',\n           out[0], out[1], out[2], out[3],\n           out[4], out[5], out[6], out[7],\n           out[8], out[9], out[10], out[11],\n           out[12], out[13], out[14], out[15])\n  return out\n\n```\n**Putting it All Together**\n\nAfter the keystream is generated, the Salsa20 algorithm will XOR it by the first 64 bytes, or\nless, of the plaintext. If there is more than 64 bytes in the plaintext data, then the counter\nvariable is incremented and a new keystream is generated for the next 64 byte block. This\nprocess continues until the entirety of the plaintext is encrypted. The Python code for this\nwould look like the following:\n```\ndef encrypt(self):\n   ct = []\n   print(len(self.data))\n   for i in range(0, len(self.data), 64):\n     block = self.data[i:i+64]\n     self.setup_keystate(self.key, self.nonce, i//64)\n     ks = self.generate_ks()\n     for x in range(len(block)):\n       ct.append(block[x] ^ ks[x])\n   return ct\n\n### Identifying Salsa20 in Assembly\n\n```\nThe easiest way to identify Salsa20 when analyzing a binary is to look for the constants\n```\nexpand 32-byte k or expand 16-byte k . These will almost always be present for\n\n```\nSalsa20 and are a guaranteed indicator.\n\n\n-----\n\n_Salsa20 constant value being moved into the state_\n\nHowever, in order to evade analysis, the author might change these constant values. If these\nvalues are changed, next thing to look for would be the quarter-round function that Salsa20\nuses to generate the keystream. To locate this, the analyst should be looking for the `rol`\noperands followed by the normal quarter-round values: 7, 9, 13, and 18.\n\n\n-----\n\n_Salsa20 quarter-round function showing the_ `rol operands`\n\nThe examples for this section were from an open source version of the Salsa20 algorithm\nwritten in C by [alexwebr.](https://github.com/alexwebr)\n\n## Conclusion\n\nHopefully this post will help newer analysts in identifying basic crypto functions that can be\nused by malware. By learning how the algorithms operate at a low level, it will make it easier\nto spot them in the wild and possibly be able to identify different variations of the same\nalgorithm that an author may use to evade detection. If you have any questions or comments\n[about this post, feel free to message me on my Twitter or](https://twitter.com/jacob_pimental) [LinkedIn.](https://www.linkedin.com/in/jacobpimental/)\n\nThanks for reading and happy reversing!\n\n**Tutorial, Encryption, RC4, Salsa20**\n\n## More Content Like This:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-25 - Reverse Engineering Crypto Functions- RC4 and Salsa20.pdf"
    ],
    "report_names": [
        "2021-08-25 - Reverse Engineering Crypto Functions- RC4 and Salsa20.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535781,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1653759493,
    "ts_modification_date": 1653759493,
    "files": {
        "pdf": "https://archive.orkl.eu/773c6d30ab1def7294deaabe346e2dbccd835550.pdf",
        "text": "https://archive.orkl.eu/773c6d30ab1def7294deaabe346e2dbccd835550.txt",
        "img": "https://archive.orkl.eu/773c6d30ab1def7294deaabe346e2dbccd835550.jpg"
    }
}