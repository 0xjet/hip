{
    "id": "c442926d-3fc4-4ed1-8a16-10f322b68116",
    "created_at": "2022-10-25T16:48:14.113608Z",
    "updated_at": "2025-03-27T02:08:40.438795Z",
    "deleted_at": null,
    "sha1_hash": "fc2c4a2eeaa0aff85762fd66e8ae7cc641f4ac82",
    "title": "Mactans: Injecting Malware into iOS Devices via Malicious Chargers",
    "authors": "",
    "file_creation_date": "2013-08-03T07:46:11Z",
    "file_modification_date": "2013-08-03T07:46:11Z",
    "file_size": 2299962,
    "plain_text": "# MACTANS: \r INJECTING \r MALWARE \r INTO \r \n IOS \r DEVICES \r VIA \r MALICIOUS \r \n CHARGERS \r \n\n## BILLY \r LAU, \r YEONGJIN \r JANG, \r CHENGYU \r SONG, \r  \r  TIELEI \r WANG, \r PAK \r HO \r CHUNG, \r AND \r PAUL \r ROYAL \r  GEORGIA \r INSTITUTE \r OF \r TECHNOLOGY, \r ATLANTA, \r GA, \r USA \r \n\n### BILLY@CC.GATECH.EDU, YEONGJIN.JANG@GATECH.EDU,\n CSONG84@GATECH.EDU, TIELEI@GATECH.EDU, PCHUNG34@MAIL.GATECH.EDU, \r PAUL@GTISC.GATECH.EDU\n\n## 1. ABSTRACT\n\nApple iOS devices are considered by many to be more secure than other mobile offerings. In\nevaluating this belief, we investigated the extent to which security threats were considered when\nperforming everyday activities such as charging a device. The results were alarming: despite the\nplethora of defense mechanisms in iOS, we successfully injected arbitrary software into currentgeneration Apple devices running the latest iOS software. All users are affected, as our approach\nrequires neither a jailbroken device nor user interaction.\n\nIn this paper, we show how an iOS device can be compromised within one minute of being\nplugged into a malicious charger. We first examine Apple’s existing security mechanisms to\nprotect against arbitrary software installation, and then describe how USB capabilities can be\nleveraged to bypass these defense mechanisms. To demonstrate persistence of the resulting\ninfection, we detail how an attacker can hide their software in the same way Apple hides its own\nbuilt-in applications.\n\nTo demonstrate practical application of these vulnerabilities, we built a proof-of-concept\nmalicious charger, called Mactans, using a BeagleBoard. This hardware was selected to\ndemonstrate the ease with which innocent-looking but malicious USB chargers can be\nconstructed. While Mactans was built with a limited amount of time and a small budget, we also\nbriefly consider what more motivated, well-funded adversaries could accomplish. Finally, we\nrecommend ways in which users can protect themselves and suggest security features Apple\ncould implement to make the attacks we describe substantially more difficult to pull off.\n\n1\n\n\n-----\n\n## 2. INTRODUCTION\n\nIn recent years, consumers have shifted their attention from traditional computing devices such as\nPCs and laptops to mobile devices such as smart phones and tablets. Although these devices come\nwith new security features, they are not bulletproof. Given the predominance of Apple’s iOS\ndevices, we set out to explore how well users are protected against various types of attacks when\nusing products such as the iPhone or iPad.\n\nCurrently, iOS is considered by many to be more secure than other mobile offerings, based on\nsecurity mechanisms such as mandatory code signing, app sandboxing, and a single, centralized\napp store. In evaluating this belief, we examined how Apple’s existing security mechanisms\nprotect against arbitrary software installation and execution. Specifically, we investigated the\nextent to which security threats were considered when performing everyday activities such as\ncharging a device. The results were alarming: despite the plethora of defense mechanisms in iOS,\nwe successfully injected arbitrary software (in a surreptitious manner) into current-generation\nApple devices running the latest operating system. So far, this attack works on devices equipped\nwith iOS versions up to and including iOS 6.\n\nTo demonstrate practical application of these vulnerabilities, we built a proof-of-concept\nmalicious charger, called Mactans, using a BeagleBoard. This hardware was selected to\ndemonstrate the ease with which innocent-looking but malicious USB chargers can be\nconstructed. The name was chosen to portray the characteristics of a species of spider commonly\nknown as the Black Widow, whose bite delivers potent neurotoxin that can be deadly to humans.\nWhile Mactans was built with a limited amount of time and a small budget, in Section \r 5.1 \r we\nalso briefly consider what more motivated, well-funded adversaries could accomplish.\n\nTo provide a defense against such attacks, in Section \r 5.3 \r we recommend mitigations that Apple\ncould implement to make the attacks we describe substantially more difficult to pull off.\nFollowing our disclosure to Apple, we received an email from Apple Product Security that\ninvited us to test iOS 7 Beta 2. Upon examination, we discovered that Apple had implemented\none of our recommendations to require user consent for an iOS device to be paired with an\nunknown host for the first time.\n\n2\n\n\n-----\n\n## 3. OBSERVATIONS\n\nWe begin by describing observations made during the course of our security research that enabled\nus to circumvent existing security features of iOS, install and execute arbitrary apps. The attack\nconsists of injecting an arbitrary app into an iOS device through a USB cable connected to a\ncustom-made malicious charger. Additional details are provided in Section \r 4, while possible\nmitigations are suggested in Section \r 5.\n\n### 3.1 PHYSICAL WEAKNESS DESCRIPTIONS\n\nThe weaknesses we describe affect iOS devices up to and including those running iOS 6.\nFollowing the client-server communication model, we refer to the iOS device as client, and the\nentity that attempts to communicate with the client as the host. Using this terminology, below is a\nlist of weaknesses we discovered.\n\n### 3.1.1 \r ANY \r HOST \r CAPABLE \r OF \r ESTABLISHING \r A \r SESSION \r WITH \r THE \r CLIENT \r IS \r IMPLICITLY \r \n TRUSTED BY THE CLIENT\n\nAs a result, without the user’s permission, any host that understands the proprietary RPC\ncommunications protocol like that used by iTunes to communicate with an iOS device can\nsimilarly and directly query or modify the state of the client. We note that this communication\nprotocol lacks proper authentication and assumes trust too broadly. The consequence of this\nweakness is further described in Section \r 4.\n\n### 3.1.2 \r THE \r CLIENT \r DOES \r NOT \r SEEK \r THE \r USER’S \r CONSENT \r FOR \r ACTIONS \r THAT \r WOULD \r \n ALTER \r ITS \r STATE \r AND \r PROVIDES \r NO \r INDICATION \r TO \r THE \r USER \r WHEN \r ITS \r STATE \r (I.E., \r \n UDID) \r IS \r QUERIED \r \n\nAs a result, the scenarios described in Section \r 4.2 \r through Section \r 4.4 \r can occur automatically\nwithout the user’s consent or knowledge. This weakness is a security problem with significant\nconsequences.\n\n3\n\n\n-----\n\n### 3.1.3 \r APPLICATIONS \r INSTALLED \r ON \r THE \r CLIENT \r CAN \r BE \r HIDDEN \r IN \r THE \r SAME \r WAY \r \n APPLE HIDES ITS OWN IOS SYSTEM APPLICATIONS (E.G., FIELDTEST.APP)\n\nAs a result, the execution (through a weakness described in **Section \r 3.1.4) of a hidden**\napplication installed by the host will not be visible (e.g., via SpringBoard or the iOS main screen)\nto the user. This characteristic contradicts the popular assumption that all installed apps are\nvisible and therefore enumerable from the SpringBoard. In addition, it permits malware-like apps\nto be installed without leaving any traces visible to the user.\n\n### 3.1.4 \r THE \r HOST \r CAN \r EXECUTE \r APPLICATIONS \r ON \r THE \r CLIENT \r (I.E., \r DEBUGSERVER) \r \n WITHOUT THE USER’S CONSENT\n\nAs a result, and in combination with the weaknesses described in the previous sections, the host\ncould mount an Apple-signed disk image (DeveloperDiskImage.dmg) and launch\n```\ncom.apple.debugserver to execute an installed application regardless of whether it is\n\n```\nhidden.\n\n### 3.1.5 \r THE \r USE \r OF \r THE \r APPLE \r PROVISIONING \r PORTAL \r CAN \r BE \r EASILY \r AUTOMATED \r TO \r \n OBTAIN A PROVISIONING PROFILE\n\nAs a result, provisioning profiles can be obtained automatically by submitting UDIDs of target\ndevices. Thus, potential attacks do not need to depend on availability of an Enterprise\nProvisioning Profile, which while imposing no cap on the number of devices, is more difficult to\nobtain.\n\n### 3.2 UNIFIED DATA, CONTROL, AND POWER INTERFACE\n\nDue to space and user-convenience considerations, iOS designers have built a unified hardware\ninterface that serves two primary functions:\n\n1. Charging the battery of the iOS device, and\n2. Facilitating data communications and device control.\n\nSuch choices can be seen in the form of Apple’s 30-Pin dock connector (for older devices) and\nLightning USB interfaces (for newer devices). This minimalism continues in software – we\nnoticed that there are no visual indicators on the screen when an iOS device is being plugged into\na host which can alter the state of a device. These observations motivated us to explore attacks\nthat exploit this absence of information.\n\n4\n\n\n-----\n\n## 4. IOS MALWARE INJECTION ATTACK\n\nUsing the observations described in the previous section, we chained together weaknesses and the\npotential threat vector mentioned in Section \r 3.2 to construct an end-to-end malware injection\nattack for iOS devices. As a proof-of-concept, we successfully injected a malicious app into a\ntarget iOS device that was plugged into a fake USB charger; this attack requires neither a\njailbroken device nor user interaction. While some users may already be aware that connecting a\nmobile device to a compromised computer could lead to a compromise of the device, there is\nusually little concern given when the connection for a mobile device appears to be simply a\ndevice charger. As a result, the charger is often trusted implicitly.\n\nWith the above context as a guide, we investigated the extent to which commodity USB-based\nfunctionalities can be miniaturized and arrived at the idea of integrating a computer into the space\nprofile of a charger, which we later called Mactans. With Mactans, the assumption that chargers\nare trustable does not hold. Using small financial and time budgets, we were able to build a proofof-concept charger out of inexpensive, commodity hardware, the BeagleBoard, which is a\nfunctional mini-computer on an 8cm x 7.5cm board.\n\n### 4.1 PROOF-­‐OF-­‐CONCEPT REQUIREMENTS\n\nBelow are the requirements for the proof-of-concept attack we describe in this section.\n\n-­‐ Apple 30-Pin or Lightning USB cable\n-­‐ Active iOS individual developer’s license\n-­‐ iOS device (target)\n-­‐ Internet connection (via Wi-Fi or cellular data connection)\n-­‐ Mactans charger, consisting of:\n`o` A USB port that can provide power\n`o` Small scale microprocessor/microcontroller\n`o` Linux operating system\n`o` iOS RPC communications library (e.g., libimobiledevice)\n\n### 4.2 OBTAINING UDID\n\nA Unique Device Identifier (UDID) is a 40 digit hexadecimal number that serves as a fingerprint\nof an iOS device. It was originally used by app developers to uniquely identify different devices\nfor various purposes. However, today the UDID is considered a sensitive piece of information\nand its use in regular apps has been deprecated since iOS 5.0[1]. Therefore, unauthorized access to\nthe UDID can be considered a privacy leak.\n\nIn our proof-of-concept attack, obtaining the UDID is an essential preliminary step in preparing\nthe target device for app injection. To obtain the UDID, we simply query the device’s USB\n\n1\n\nhttps://developer.apple.com/library/ios/#documentation/uikit/reference/UIDevice_Class/DeprecationAppen\ndix/AppendixADeprecatedAPI.html\n\n5\n\n\n-----\n\nidentifier using standard tools such as lsusb. The UDID can be obtained even if the device is\npasscode-locked.\n\n### 4.3 OBTAINING & INSTALLING A PROVISIONING PROFILE\n\nOnce obtained, the UDID can be used to create a provisioning profile for the target device, which\nwill allow the injection of attacker-decided applications. A provisioning profile is a\ncryptographically signed file that contains information about the developer who created the\nprofile as well as UDIDs of devices that can execute apps signed by this developer. To maintain\ncontrol of the walled garden model, all provisioning profiles are signed by Apple. Without an\nappropriate provisioning profile, the installation of arbitrary apps will be rejected by iOS on the\ntarget device.\n\nCreation of a provisioning profile introduces the requirement of a working internet connection for\nMactans. Specifically, the UDID must be submitted to developer.apple.com for profile\ngeneration. There are at least two ways to fulfill this requirement:\n\n1. Mactans can be equipped with 3G/4G cellular capabilities via a SIM card module.\nMoreover, there are SIM vendors that provide anonymous cellular activation; Mactans can thus\nbe on-air anonymously. Therefore, Mactans can directly connect to the Apple Provisioning\nPortal, submit the UDID of a target device, and then obtain a provisioning profile for that device.\n\n2. Mactans can be equipped with Wi-Fi capabilities via various wireless modules. Under\nthis option, connecting to the Internet will be a matter of scanning for unprotected access points,\ncracking weak access points[2], brute forcing wireless passwords, or tunneling over DNS.\n\nWith Internet connectivity, Mactans can generate a provisioning profile that is unique to the\nvictim device containing the UDID obtained previously. With a provisioning profile in hand,\nMactans can trivially install it onto the target device through communication with\n```\ncom.apple.misagent (via lockdownd).\n\n### 4.4 INJECT MALICIOUS APP\n\n```\nAfter the provisioning profile has been installed successfully, Mactans will proceed to inject an\narbitrary app into the iOS device. This step is performed via communication with\n```\ncom.apple.mobile.installation_proxy. In our proof-of-concept, we demonstrate the\n\n```\nsignificance of a Mactans attack by showing how it can be used to inject a Trojan horse Facebook\napp; please see the presentation slides that accompany this whitepaper for additional details.\n\n2\nAircrack & Reaver\n\n6\n\n\n-----\n\n### 4.5 PAYLOAD\n\nEven though Mactans can inject any app into the target device, another hurdle exists for the\npayload: app sandboxing. In our proof-of-concept, Mactans does not perform jailbreaking nor\ndoes it escape from the sandbox; the injected app has the same privileges as other regular apps\n(i.e., those of the ‘mobile’ account). However, a Mactans-injected app completely bypasses\nApple’s App Store review process. In combination with publicly available information about\nvarious private iOS APIs[3], attackers can create apps that would otherwise be rejected during the\napp review process.\n\nAs examples of private API abuses, we introduce two proof-of-concept capabilities of a potential\npayload app. First, as a live background process, such an app can take a screenshot of the current\nforeground screen by making a private API call. Second, an injected app could generate screen\ntouch events and simulate the hardware button presses by exploiting functionality available in\nprivate libraries present in DeveloperDisk.dmg after mounting it through communication\nwith com.apple.mobile_image_mounter.\n\n3\nhttps://github.com/nst/iOS-Runtime-Headers\n\n7\n\n\n-----\n\n## 5. DISCUSSION\n\n### 5.1 ATTACK SCENARIOS\n\nIn this section, we discuss possible scenarios in which an attack could be successful.\n\n### 5.1.1 GOVERNMENT TARGETED ATTACK\n\nIn this scenario, an attacker wishing to target a particular individual could provide a suitably\npackaged Mactans charger to the target. While this vector requires careful construction of a\nmalicious charger that looks indistinguishable from an original Apple accessory, such an\napproach by a nation state is well within the realm of plausibility.\n\nAlternatively, a priori knowledge of the target could be leveraged by a resourceful attacker to\nselectively modify the environment. Examples include installation of a custom, Mactans-like\ncharger in a specific airplane seat or hotel room (e.g., built into a console or desk).\n\n### 5.1.2 GENERAL ATTACK\n\nIn a more general scenario, a Mactans charger can be installed in a public waiting area. One\nexample of such a station is pictured in Figure \r 1. High-traffic areas, such as airports, could result\nin many hundreds of victims each day.\n\n8\n\n\n-----\n\n**Figure \r 1: A user replenishing the battery of his iPad at a**\n\npublic charging station while he continues to use it.\n\n### 5.2 SECURITY CONSEQUENCES\n\nAlthough we deliberately chose to implement weaker payloads as in our proof-of-concept, it is\nnot inconceivable that adversaries could easily engineer a payload with substantially higher\nimpact. In fact, Mactans may offer a new dimension to the phenomenon of espionage (if not\nalready present) and targeted attacks.\n\nHowever, the difficulty of attacks can be substantially increased if the weaknesses discussed in\n**Section \r 3.1 are addressed by the suggested mitigations proposed in Section \r 5.3. The authors are**\nthankful that after communication with the vendor, an update was released (iOS 7 Beta 2) that is\nnot susceptible to the attack described in Section \r 4.\n\n9\n\n\n-----\n\n### 5.3 MITIGATIONS\n\nPossible mitigations to overcome the weaknesses we describe in Section \r 3.1 are listed here. In\nparticular, we believe that any mobile OS should by default inform the user before the state of\ntheir device is queried or modified by a USB-connected host. More specifically, we think that it is\nimportant to require the user’s consent in the following cases:\n\n1) Prior to the process of USB device pairing, which enables additional capabilities,\nincluding those stated next in 2).\n\n2) Prior to installing a provisioning profile or side-loading an application associated with a\nprovisioning profile (as described in Section \r 3.1.2).\n\nA primary possible mitigation is to require the user’s consent (e.g., via introduction of a\ndebugging mode setting on the client) in order for the host to launch applications on the client (or\nperhaps to launch specific applications such as debugserver).\n\nIn the case of iOS, Apple could also prevent third party developers from setting the SBAppTags\nwith the value hidden in an app’s Info.plist so that side-loaded apps cannot be invisible.\nFurthermore, the process of obtaining provisioning profiles can be made less-automatable by\nrequiring iOS developers to solve a CAPTCHA prior to issuing a profile for a device specified by\na UDID.\n\n### 5.4 LIMITATIONS\n\nIf an iOS device is passcode-protected, Mactans requires the phone to be unlocked at least once\nafter being connected. While this requirement may seem to render Mactans impractical, we posit\nthat users will regularly create this situation while charging their device.\n\nGiven that our proof-of-concept relies on an individual developer license, a Mactans charger\nequipped with one individual license can accommodate only 100 devices. However, more\nresourceful adversaries are likely to have access to an enterprise developer license, which waives\nthis limit. Enterprise license possession also lowers the bar for provisioning profile injection, as a\nUDID need not be submitted to Apple’s Provisioning Portal to generate a provisioning profile.\n\nDiligent, security-minded users may detect attempts to compromise their iOS device if they check\ninstalled developer licenses in the Settings section of their device. However, we believe that\nregular users may not know of the existence or purpose of this information and therefore will not\ncheck or understand this setting. Furthermore, even if the provisioning profile is removed, the\ninjected app will continue to run until the device is rebooted. Upon a subsequent connection to a\nMactans charger, the attack can be repeated.\n\n10\n\n\n-----\n\n## 6. CONCLUSION\n\nIn this paper, we have shown that for iOS devices up to and including those running iOS 6,\narbitrary apps can be injected into a user’s mobile device when connected to a malicious host. We\ndemonstrated the potential danger of this capability through a proof-of-concept implementation of\na malicious charger that injects a Trojan horse app with a payload. The relevance of our work is\nrepresented by Apple’s release of an update to iOS 7 that implements a mitigation we\nrecommended in our disclosure; Figure \r 2 shows a screenshot of iOS 7 when an unknown host\ntries to communicate with the phone through a USB connection.\n\n**Figure \r 2: Screenshot of iOS 7 Beta 2 when the device is plugged into**\n\nan unknown host that tries to pair with the phone.\n\n11\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://media.blackhat.com/us-13/US-13-Lau-Mactans-Injecting-Malware-into-iOS-Devices-via-Malicious-Chargers-WP.pdf"
    ],
    "report_names": [
        "US-13-Lau-Mactans-Injecting-Malware-into-iOS-Devices-via-Malicious-Chargers-WP.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1375515971,
    "ts_modification_date": 1375515971,
    "files": {
        "pdf": "https://archive.orkl.eu/fc2c4a2eeaa0aff85762fd66e8ae7cc641f4ac82.pdf",
        "text": "https://archive.orkl.eu/fc2c4a2eeaa0aff85762fd66e8ae7cc641f4ac82.txt",
        "img": "https://archive.orkl.eu/fc2c4a2eeaa0aff85762fd66e8ae7cc641f4ac82.jpg"
    }
}