{
    "id": "50630515-9317-4cdb-995e-98115ad8a706",
    "created_at": "2023-01-12T15:00:49.67652Z",
    "updated_at": "2025-03-27T02:05:19.909135Z",
    "deleted_at": null,
    "sha1_hash": "232302a7a9aeb7eba0d296a5e846664efcb6ca4f",
    "title": "SMM Rootkits - A New Breed of OS Independent Malware",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 342644,
    "plain_text": "# SMM Rootkits: A New Breed of OS Independent Malware\n\n## Shawn Embleton Sherri Sparks Cliff Zou\n#### University of Central Florida  University of Central Florida  University of Central Florida \n## sembleton@cs.ucf.edu ssparks@cs.ucf.edu czou@cs.ucf.edu\n\n ABSTRACT\n 1. INTRODUCTION\n\nThe emergence of hardware virtualization technology has led to A rootkit consists of a set of programs that work to subvert\nthe development of OS independent malware such as the Virtual control of an Operating System from its legitimate users [16]. If\nMachine based rootkits (VMBRs). In this paper, we draw one were asked to classify viruses and worms by a single defining\nattention to a different but related threat that exists on many characteristic, the first word to come to mind would probably be\ncommodity systems in operation today: The System Management _replication. In contrast, the single defining characteristic of a_\nMode based rootkit (SMBR). System Management Mode (SMM) rootkit is stealth. Viruses reproduce, but rootkits hide. They hide\nis a relatively obscure mode on Intel processors used for low-level by compromising the communication conduit between an\nhardware control. It has its own private memory space and Operating System and its users. Secondary to hiding themselves,\nexecution environment which is generally invisible to code rootkits are generally capable of gathering and manipulating\nrunning outside (e.g., the Operating System). Furthermore, SMM information on the target machine. They may, for example, log a\ncode is completely non-preemptible, lacks any concept of victim user’s keystrokes to obtain passwords or manipulate the\nprivilege level, and is immune to memory protection mechanisms. system state to allow a remote attacker to gain control by altering\nThese features make it a potentially attractive home for stealthy security descriptors and access tokens.\nrootkits. In this paper, we present our development of a proof of\n\nSince the user’s view of the computer system and its resources is\n\nconcept SMM rootkit. In it, we explore the potential of System\n\nstrictly mediated by the information the Operating System\n\nManagement Mode for malicious use by implementing a chipset\n\nprovides to it via hardware and software interfaces, a malicious\n\nlevel keylogger and a network backdoor capable of directly\n\nprogram that controls the interfaces controls the entire system. A\n\ninteracting with the network card to send logged keystrokes to a\n\nrootkit hides its presence by intercepting and altering the interface\n\nremote machine via UDP. The rootkit hides its memory footprint\n\ncommunications of various Operating System or hardware\n\nand requires no changes to the existing Operating System. It is\n\ncomponents to hide files, processes, and network connections on\n\ncompared and contrasted with VMBRs. Finally, techniques to\n\nthe computers that it is installed upon. This hiding may be\n\ndefend against these threats are explored. By taking an offensive\n\nachieved either directly or indirectly using code modifications,\n\nperspective we hope to help security researchers better understand\n\ndata modifications, or a combination of both.\n\nthe depth and scope of the problems posed by an emerging class\nof OS independent malware. It is important to emphasize, however, that the nature of the\n\nrootkit compromise is not to escalate or circumvent privilege, but\n\n## Categories and Subject Descriptors rather to hide an attacker’s presence on an already compromised\nD.4.6 [Operating Systems]: Security and Protection – _Invasive_ system. The initial security breach that allows installation of the\n_software (e.g., viruses, worms, Trojan horses)_ rootkit may arise from social engineering attacks that trick an\n\nunsuspecting user into running a malicious application or from the\n\n## General Terms exploitation of unpatched vulnerabilities in the Operating System\nSecurity and other critical software.\n\nEarly rootkits relied upon system _file masquerade_ to hide their\n\n## Keywords presence. An attacker would replace a system file with a\nSystem Management Mode, Rootkit, Malware, Virtualization, subversive file that “masqueraded” as the original [19]. The login\nOperating System Security program was a common target for this type of attack as it could be\n\nreplaced by a malicious version which captured the passwords of\nusers as they attempted to log into a system. This motivated the\ndevelopment of file system integrity checkers like Tripwire [12].\n\nPermission to make digital or hard copies of all or part of this work for\n\nRootkit authors quickly developed execution path redirection,\n\npersonal or classroom use is granted without fee provided that copies are\n\nalso known as _hooking, techniques to counter detection by_\n\nnot made or distributed for profit or commercial advantage and that\ncopies bear this notice and the full citation on the first page. To copy integrity checkers. Hooking encompasses a class of techniques\notherwise, or republish, to post on servers or to redistribute to lists, whereby a program’s normal control flow is altered to execute a\nrequires prior specific permission and/or a fee. block of malicious code. It is important to note that execution\n_SecureComm 2008, September 22-25, 2008, Istanbul, Turkey._ path redirection is impervious to traditional integrity checkers like\nCopyright 2008 ACM ISBN# 978-1-60558-241-2. Tripwire which typically only check files stored on the hard disk\n\n\n-----\n\nfor modifications. This is because they make their changes to the\nloaded images in memory rather than to the disk images. Though\nmore difficult to detect than system file masquerade, hooking\nremains detectable by memory based integrity checkers and other\nheuristic techniques. Eventually, rootkit authors figured out how\nto evade hook detection by using Direct Kernel Object\nManipulation (DKOM) to modify dynamic kernel data structures\nfor which it is impossible to establish reliable heuristics or trusted\nbaseline values [21]. The idea is that by controlling the data used\nin a function, a rootkit can indirectly control the execution path.\n\nIt is clear that rootkit development has exhibited an adaptive, coevolutionary pattern in response to security software\nadvancements. The result has been an ongoing, sophisticated\ngame of ‘hide and seek’ between rootkit developers and detectors.\nAs rootkits seek ever better methods to hide their presence on\ninfected systems, defenders must develop newer, more advanced\ntechniques to find them. With the emergence of hardware\nvirtualization technology, the rootkit battle field has changed\ndramatically. Previous rootkits co-existed with the Operating\nSystem (OS). They exerted their influence by redirecting control\nflow within the OS to their own malicious code [20]. This was\naccomplished by making modifications to either static or dynamic\nOS data structures in memory. Security researchers responded by\ndeveloping integrity checkers and heuristics to detect these\nchanges [11].\n\nUnfortunately, these techniques are useless against Virtual\nMachine Based Rootkits (VMBRs) which have the ability to exist\nindependently of any OS. Such rootkits are able to exert an\nalarming degree of control without modifying a single byte in the\nOperating System [1]. A VMBR hoists the Operating System into\na virtual machine and exerts its controls over the machine from an\nexternal Virtual Machine Monitor (VMM). This process is\ninvisible to the OS. Once installed, the VMM is capable of\ntransparently intercepting and modifying states and events\noccurring in the virtualized OS. It can observe and modify\nkeystrokes, network packets, memory, and disk I/O. If the VMBR\nhas virtualized memory, its code footprint will also be invisible.\nThese things make a VMBR extremely difficult to detect.\n\nIn this paper, we draw attention to another, similar threat that\nexists on many commodity systems in operation today: The\nSystem Management Mode (SMM) based rootkit (SMBR). SMM\nis an abbreviation for Intel’s System Management Mode, a\nprocessor mode which has existed since the i386, yet still remains\nlargely obscure. Unlike the other processor modes, (e.g.\nprotected, real, virtual 8086) which are designed for running\nOperating Systems or user applications, SMM was developed\nexclusively for managing low level hardware operations like\npower and thermal regulation. SMM has its own private memory\nspace and execution environment which is generally invisible to\ncode running outside. Furthermore, SMM code is completely non\npreemptible, lacks any concept of privilege level, and is immune\nto memory protection mechanisms [4]. These features make it an\nattractive home for malicious rootkits.\n\nA System Management Mode Based Rootkit (SMBR) offers\ncomparable stealth to a VMBR while maintaining a potentially\nsmaller code footprint. Because the SMM execution\nenvironment’s isolation is enforced at the hardware level by the\nchipset, an SMBR gains the ability to conceal its memory\nfootprint by default without having to implement slow and\n\n\ncomplex memory virtualization code. Like the VMBR, the\nSMBR is able to exert control without requiring any visible\nchanges to the underlying operating system.\n\nIn this paper, we present our development of a proof of concept\nSMBR. In it, we explore the potential of System Management\nMode for malicious use. By taking an offensive perspective we\nhope to help security researchers better understand the depth and\nscope of the problems posed by an emerging class of OS\nindependent malware.\n\nOur SMM rootkit provides a high degree of stealth and control.\nWe demonstrate the construction of a chipset level keylogger by\nredirecting the keyboard Interrupt Request (IRQ) to System\nManagement Mode in the Advanced Programmable Interrupt\nController (APIC). Logged keystrokes are then encapsulated into\nUDP packets and sent out via the chipset LAN interface. This is\nall accomplished without making any visible changes to the target\nsystem. We also show that, once installed, the rootkit remains\nhidden in memory making it difficult to detect or remove.\nBecause they have somewhat similar traits, we also compare and\ncontrast VMBRs with SMBRs on several key characteristics\nincluding operating environment, size, complexity, stealth, and\ncontrol. Finally, we discuss countermeasures to detect and defend\nagainst these threats.\n\nThe rest of this paper is organized as follows. In section 2, we\ndiscuss some related work. In section 3, we give an overview of\nSystem Management Mode. We cover the design and\nimplementation of our proof of concept SMBR in section 4. We\nevaluate it in section 5 and provide a comparison and contrast\nwith virtual-machine based rootkits in section 6. Defense is\ndiscussed in section 7. Finally, we conclude in section 8.\n\n## 2. RELATED WORK\nOur research on SMM rootkits (SMBRs) is related to three areas\nof existing rootkit technology: memory management subversion,\nvirtualization, and BIOS exploitation.\n\nOnce a rootkit is publicly known, Anti-Virus software can\ndevelop a signature for it. Furthermore, rootkit changes to the OS\nare detectable using heuristic memory scans. It is, therefore,\nadvantageous for a rootkit to be able to hide its memory footprint.\nMemory subversion was first implemented in the Shadow Walker\nrootkit [10]. The Shadow Walker rootkit demonstrated that it was\npossible to control the view of memory regions seen by the\nOperating System and other processes by hooking the paging\nmechanism and exploiting the Intel split TLB architecture. Using\nthese techniques, it was capable of hiding both its own code and\nchanges to other Operating System components. This enabled it to\nfool both signature and heuristic based scans. Memory\nvirtualization support on Intel and AMD platforms with hardware\nvirtualization extensions can also be exploited to hide the memory\nfootprint of malicious code. The general idea behind memory\nvirtualization is that the Virtual Machine Monitor (VMM)\nmaintains its own set of page tables in addition to the virtualized\nguest OS’s paging structures.  The guest OS is free to manage its\nown page tables, however, physical translation occurs using the\nVMM’s page tables rather than the guest OS’s. Furthermore, the\nVMM page tables are inaccessible to the guest. As a result, the\nVMM has complete control over all of the physical memory the\nguest is allowed to access. Instructions which affect paging\nstructures and the cache are also virtualized to cause traps to the\n\n\n-----\n\nState Save Area\n\n\n**Figure 1: The physical memory map for the Intel 845 chipset showing location of the compatible SMRAM region and its layout on a**\n**32-bit system.**\n\n\nSMI Handler\n\n\nVMM.  The Blue Pill II rootkit demonstrated this capability [24].\nA SMM rootkit also has the ability to hide its code footprint, but\nit does not require the implementation of complex memory\nvirtualization code.\n\nVirtual-machine based rootkits have many characteristics in\ncommon with the System Management Mode based rootkit\npresented in this paper. They both operate at a layer below the\nOperating System and they both are capable of intercepting and\nemulating low level system events without needing to modify any\nexisting OS code or data structures. The VMBR threat was\nanalyzed by [1]. Using Vmware and Virtual PC, authors in [1]\nimplemented several malicious VMBR services to subvert both\nWindows and Linux. Their implementation, however, was\nprimarily theoretical. This is due to the fact that real world\nOperating Systems run on native hardware, not in software virtual\nmachines like Vmware. As real world attackers are unlikely to\nimplement their malicious code in Vmware, the malicious services\nimplemented by [1] are primarily simulations of real world\nscenarios. Joanna Rutkowska took the VMBR into the practical\ndomain with her development of the Blue Pill rootkit [3][24].\nThe Blue Pill rootkit exploits AMD hardware virtualization\nextensions to migrate a running Windows Operating System into a\nvirtual machine. It hides its code footprint using memory\nvirtualization, supports nested virtual machine monitors, and\nimplements countermeasures against timing based detections. [23]\nimplemented a similar proof of concept rootkit for MacOS X on\nthe Intel virtualization platform. This rootkit was code named\nVitriol. On the other hand, there has been very little research on\nSMM based rootkits.\n\nFinally, BIOS rootkits are related to SMM rootkits. The BIOS is\nthe first code that runs when a system is powered on. It performs\ndiagnostics and initializes the chipset, memory, and peripheral\ndevices. A rootkit that infects the BIOS is capable of controlling\nhardware at a level similar to an SMBR with the additional benefit\nof being able to survive reboots and reinstallations of a new OS.\nJohn Heasman developed a proof of concept BIOS rootkit that\nacts as a simple Windows NT backdoor [8]. He used the\nAdvanced Configuration and Power Interface (ACPI) to patch a\nkernel API in system memory. Because his rootkit changed code\nin the OS it was detectable using existing rootkit detection tools\n\n\nlike VICE, Blacklight, or Rootkit Revealer [11][17][18]. For\nmore advanced BIOS rootkits, suggested countermeasures include\ndisabling ACPI in the BIOS and auditing the ACPI tables. Further\nhardware mitigations include preventing BIOS reflashing or\nrequiring that the BIOS is signed [8]. These countermeasures,\nhowever, cannot defend against an SMM based rootkit.\n\nUsing SMM to escalate privilege was first discussed by Loic\nDuflot [9]. On OpenBSD, the superuser is granted limited\nprivileges. Duflot demonstrated an exploit against OpenBSD that\nallowed an attacker to arbitrarily extend superuser privileges.\nBecause SMM code has unrestricted access to physical memory,\nDuflot demonstrated that if attacker can run code in System\nManagement Mode and locate the internal variable in memory\nthat the OS uses to determine the current privilege level, then he /\nshe can modify it to circumvent the Operating System’s built in\nsecurity and obtain full privileges. To perform this exploit, the\nattacker must have the ability to read and write the programmed\nI/O registers and the legacy video memory range. Duflot’s\nexploit, however, was not a rootkit. His stated goal was privilege\nescalation, not stealth. The ability to read and write physical\nmemory is only one System Management Mode capability of\ninterest to a rootkit author. A potentially more advanced and\ninteresting capability lies in the ability of SMM code to exert\nunrestricted control over peripheral hardware. The fact SMM\ncode is non pre-emptible and communicates directly with the\nhardware makes it stealthy and relatively immune to detection. In\nthis paper, we build upon Duflot’s work to explore some of the\nadvanced capabilities of System Management Mode. The ability\nto control peripheral hardware could make SMM based malware,\nlike rootkits, a formidable security threat. Our successful\nconstruction of a SMM chipset level, rootkit keylogger and\nnetwork backdoor shows that SMM is a practical threat that could\nbe exploited by real world malware authors.\n\n## 3. OVERVIEW OF SMM\nThis section gives an overview of System Management Mode\n(SMM) and discusses how its features make it an ideal execution\nenvironment for stealthy malware.\n\n\n-----\n\nThe Intel architecture defines four processor modes of operation:\nReal Mode, Virtual-8086 Mode, Protected Mode, and System\nManagement Mode [4]. Real Mode and Virtual-8086 Mode are\nlegacy modes dating back to the 80286 / 80386 CPU. Real Mode\nis characterized by a segmented 20 bit addressable memory space\nand the lack of hardware memory protection. MS-DOS and early\nWindows OS versions ran in Real Mode. Current operating\nsystems run in either 32 or 64 bit protected mode. Protected mode\novercomes the limitations of Real Mode by extending the\naddressable memory space to 32/64 bits and adding support for\npaging, memory protection, and multi-tasking. Virtual 8086\nmode was designed to allow Real Mode and Protected Mode\nprograms to coexist; however, it is seldom used by modern\noperating systems. In contrast to the other modes, System\nManagement Mode (SMM) was not designed for running\noperating systems or user programs. Rather, it was intended for\nmanaging low level hardware operations (e.g. power management\nand thermal regulation) and is usually installed by the BIOS.\nSMM has its own memory space and execution environment\nwhich is generally invisible to code running outside of SMM.\nFurthermore, SMM code is completely non preemptible, lacks any\nconcept of privilege level, and is immune to memory protection.\nThese things clearly make SMM a potentially attractive home for\nstealthy rootkits. System Management Mode is entered when the\nprocessor receives a System Management Interrupt (SMI) [4].\n\n## 3.1 SMRAM – The SMM Memory Space\nThe System Management Memory Space (SMRAM) is used to\nhold the processor state information saved upon an entry to SMM,\nthe SMI handler, and its associated data [4]. The Intel chipset\ndocumentation defines three locations for SMRAM: Compatible,\nHigh Memory Segment (HSEG), and Top of Memory Segment\n(TSEG) [7]. The compatible region overlaps the legacy VGA\nmemory range from 0xA0000 to 0xBFFFF and is the default\nlocation for SMRAM. Normally, the contents of SMRAM are\nonly visible to code executing in System Management Mode. This\nisolation is ensured by the chipset’s re-routing of any non SMM\nmemory accesses to the VGA frame buffer. Compatible SMRAM\nis also limited to 128K. The HSEG and TSEG regions provide an\nextended, write-back, cacheable SMM memory space up to 256\nMB in size.\n\nStructurally, the SMRAM space consists of a state save area and\nthe System Management Interrupt (SMI) handler. The remaining\nspace is available for use by the handler for data and stack\nstorage. An internal processor register, called SMBASE, holds\nthe physical address pointer to the start of the SMRAM space.\nThe SMBASE value is also stored in the state save area.\nFurthermore, the state save area is located at an offset from the\nbeginning of SMRAM in physical memory. This area is used to\nstore the register context when a System Management Interrupt\n(SMI) occurs. The SMI handler is also located at an offset from\nthe start of SMRAM. Figure 1 illustrates the location and layout\nof compatible SMRAM.\n\n## 3.2 Entering & Exiting SMM\nThe processor enters System Management Mode when it receives\na System Management Mode Interrupt (SMI) [4]. When an SMI\nis received, execution context is saved into the SMRAM state\nsave map and execution of the SMI handler is commenced. The\nsaved state information includes the processor’s control registers,\nsegment registers, task register, general purpose registers, flags,\n\n\ninstruction and stack pointers. The SMM execution environment\nis similar to 16 bit real mode, with the difference that the full 32\nbit flat physical address space is accessible. Code executing in\nSMM is non preemptible because SMIs have greater priority than\nboth processor exceptions and external interrupts, including nonmaskable interrupts (NMI). When the SMI handler wishes to exit\nSystem Management Mode, it executes the Resume from System\nManagement Mode (RSM) instruction [5]. The RSM instruction\nrestores the previous execution context by copying the saved state\ninformation in SMRAM back into the processor’s registers and\nthen returns control back to the interrupted code. The I/O\nController chipset documentation defines a variety of events\ncapable of triggering an SMI. A few of them include: a power\nbutton press, real time clock (RTC) alarm, USB wake events,\nAdvanced Configuration and Power Interface (ACPI) timer\noverflows, periodic timer expiration, and a write to the Advanced\nPower Management Control (APM) register, 0xB2 [6]. In the next\nsection, we detail how some of these events might be exploited by\na stealthy rootkit.\n\n## 4. SMBR DESIGN & IMPLEMENTATION\nA successful SMBR must overcome two obstacles. First, it must\nwrite its code into the SMM handler portion of the SMRAM\nmemory space. This process should be capable of occurring from\nwithin a protected mode environment (e.g. Windows or Linux\noperating system) in order to give the rootkit its maximum\ninfection potential. Second, the rootkit must have some means of\nintercepting events in the host system and gaining control of\nexecution.\n\nIn this section, we discuss the design and implementation of an\nSMBR. We take a similar approach to [1] with our design and\ndevelopment; however, we opt to design a practical rootkit that\ncan be implemented on native hardware, as opposed to a\nsimulated virtualization platform like Vmware. Section 4.1\ndescribes how the SMBR can be installed on a running Operating\nSystem. We discuss our implementation of a SMM handler that\nfunctions as a chipset level keylogger and network backdoor in\nsection 4.2. Finally, we discuss the potential for other, related\nforms of malicious hardware subversion at the chipset level.\n\n## 4.1 Rootkit Installation\nThe rootkit can install a new SMM handler provided it has I/O\nport access privileges, the ability to map physical memory, and the\nSMRAM region has not been locked by the BIOS or other system\nsoftware. We used a Windows kernel driver to install the SMBR.\nThe Intel chipset documentation defines a System Management\nRAM Control Register (SMRAMC) which controls the\naccessibility and visibility of SMM space from other processor\nmodes [6]. The two relevant bits in this register are the D_LCK\nbit and the D_OPEN bit. D_OPEN controls the visibility of\nSMRAM. If D_OPEN is clear, SMRAM is only visible to code\nexecuting in SMM mode. Non SMM mode memory reads / writes\nare diverted by the chipset to the VGA frame buffer. Figure 2\nillustrates this process. D_LCK controls the accessibility of\nSMRAM by controlling access to the SMRAMC register. If\nD_LCK is set, the SMRAMC register becomes read-only and\nremains that way until a reset occurs.  Assuming that the D_LCK\nbit is clear, the rootkit is installed as follows:\n\n\n-----\n\n1. On a host machine, an attacker makes SMRAM visible from\nprotected mode for reading and writing by setting the\nD_OPEN bit.\n\n2. Once D_OPEN is set, the attacker copies the rootkit SMM\nhandler code to the handler portion of SMRAM as defined by\nthe Intel documentation [4].\n\n3. Finally, the attacker clears the D_OPEN bit and sets the\nD_LCK bit. This has the effect of making SMRAM invisible\nto everything other than the subverted (rootkit) SMI handler\nand of locking the SMRAMC register so that it can no longer\nbe modified. The addressing of the SMRAMC register is\nchipset specific.\n\n## 4.2 Rootkit SMM Handler Implementation\nIn the following section, we discuss the implementation of our\nproof of concept rootkit SMM handler. Our rootkit functions as a\nchipset level keylogger and network backdoor. First, we give an\noverview of the Intel APIC architecture. This is followed by a\ndescription of the APIC redirection technique that we use to trap\nkey presses and the procedure used to exfiltrate the key data over\nthe chipset LAN interface.\n\nThe Intel Advanced Programmable Interrupt Controller (APIC) is\nused to manage communication between the CPU, chipset, and\nexternal peripheral devices. It consists of two components: The\nI/O APIC and the Local APIC (LAPIC) [25]. The I/O APIC is\nlocated on the motherboard while the Local APIC is integrated\ninto the CPU. There is typically one I/O APIC for each peripheral\nbus and one Local APIC per CPU. The primary job of the I/O\nAPIC is to route the interrupts it receives from peripheral buses to\none or more Local APICs on the system. In turn, each local APIC\nis responsible for receiving and managing the external interrupts\nfor the CPU that it belongs to. When it receives interrupts, the\nLAPIC dispatches them to the processor, one at a time, based\nupon their priorities.\n\nThe processor looks up the handler for the interrupt in the\nInterrupt Descriptor Table (IDT) [5]. Each interrupt is assigned a\nunique identifier, called a vector. The processor uses this value as\nan index into the IDT. The Interrupt Descriptor Table is a\nprocessor specific data structure containing one entry for each of\n255 defined vectors. Kernel rootkits often use IDT _hooking to_\nintercept processor interrupts and exceptions [13]. This involves\n\n\nreplacing the Operating System handler contained in the IDT with\na pointer to a malicious _hook routine. Fortunately, such blatant_\nmodifications of the IDT are easily detectable. Detection simply\ninvolves enumerating each of the handler pointers and validating\nthat the address is within the range of either the OS kernel or a\nlegitimate system driver. If the address falls outside one of these\nknown ranges, it is flagged as suspicious and a security analyst\ncan conduct further investigations.\n\nDiffering from the Kernel rootkit described above, a rootkit\noperating in System Management Mode does not need to make\nany detectable changes to the IDT in order to intercept interrupts.\nRather than intercepting an interrupt at the processor handling\nlevel, the SMM rootkit can intercept it directly at the chipset level\nby re-routing the interrupt in the APIC. We demonstrate this\ntechnique in our rootkit by implementing a chipset keylogger.\nThere are three steps in this process. First, we must be able to\nintercept the keyboard interrupt. Second, we must be able to sniff\nthe keystrokes from the keyboard’s internal buffer. Finally, we\nshould forward the interrupt to the CPU for normal handling.\n\nWe accomplish the first step by rerouting the keyboard IRQ to\nSystem Management Mode. Thus, whenever a user presses a key,\nour SMM handler is called. In the handler, we are able to sniff\nthe key. Finally, we manually forward the interrupt to the CPU for\nnormal handling by taking advantage of the Local APIC’s Inter\nProcessor Interrupt (IPI) mechanism. We outline the\nimplementation details in the following section.\n\nAs mentioned previously, the I/O APIC’s primary function is to\nreceive and route peripheral hardware interrupts to the Local\nAPIC for delivery to the CPU. For this purpose, the I/O APIC\narchitecture defines a _Redirection Table_ [6]. The Redirection\ntable contains a dedicated entry for each interrupt pin. It is used\nto translate the physical, hardware signal into an APIC message\non the APIC bus. This table can be used to specify the destination\nof the interrupt, the vector, and the delivery mode.\n\nThe delivery mode is the primary field of interest for our rootkit.\nMost interrupts use the _Fixed delivery mode. This mode_\nautomatically forwards the interrupt to the LAPICs for all\nprocessors specified in the destination. Our rootkit changes the\ndelivery mode of the keyboard IRQ from _Fixed to_ _SMI. Now,_\nrather than automatically forwarding the interrupt, it will be\nredirected to our SMM handler. In our handler, we are free to\n\n\n-----\n\nIDT OS Handler\n\n|IRQ|Vector|\n|---|---|\n|0|-|\n|1|0x93|\n|2|-|\n|…||\n\n\nDescription\nThe normal operation (top-half)\nis subverted allowing the new\nSMM handler to log/transmit\nthe keycodes and then forward\nthe interrupt.\n\n|IRQ|Vector|\n|---|---|\n|0|-|\n|1|SMI #|\n|2|-|\n|…||\n\n|Col1|Col2|IDT|Col4|Col5|Col6|\n|---|---|---|---|---|---|\n|IRQ Vector Int 0 - 0x00 Key Msg Local Press 1 0x93 … 2 - 0x93 0x APIC … 23 - … I/O APIC SMM Handler IRQ Vector Log/Transmit the 0 - keycode and send a Msg 1 SMI # message to the local APIC to invoke the 2 - normal keyboard … handler. 23 -||||||\n|||Int||Handler||\n|||0x00||-||\n|||…||||\n|||0x93|0x|A8063044BB B||\n|||||||\n|||…||||\n||I/O APIC SMM Handler IRQ Vector Log/Transmit the 0 - keycode and send a Msg 1 SMI # message to the local APIC to invoke the 2 - normal keyboard … handler. 23 -|||||\n\n\n**Figure 3: Normal and SMBR keystroke handling paths**\n\n\nsniff the contents of the keyboard buffer and send it out in\nnetwork packets.\n\nWe can accomplish the second step of extracting the keyboard\ndata by reading the keyboard’s internal hardware registers. The\nkey press information is extracted by reading from the keyboard\n_data register. Unfortunately, this read is destructive. Therefore,_\nafter the key data has been read, it must be replaced so that it is\naccessible to other system software. We replace it by writing a\nspecific command byte to the keyboard _command register. This_\nbyte instructs the keyboard that the next byte written to the data\nregister should remain there as if placed there by a physical key\npress [15].\n\nOnce we have extracted the keyboard data, it is necessary to\nforward the interrupt to the CPU for normal user input handling.\nOtherwise, the keyboard will no longer function. We use the\nLocal APIC’s ability to issue inter processor interrupts (IPI) for\nthis purpose. The LAPIC documentation defines an Interrupt\nCommand Register (ICR) [5]. Using this register it is possible to\nsend an interrupt to one or more processors, including self. As in\nthe I/O APIC’s Redirection Table, the destination, vector, and\ndelivery mode are all specifiable. When the lower 4 bytes of the\nICR are written to, the LAPIC generates the IPI message and\nsends it out over the system bus. From within our SMM handler,\nwe re-issue the interrupt with a destination of self and a fixed\ndelivery mode by writing to the ICR. Therefore, the keyboard\ninterrupt is delivered to the processor in the normal manner as\nsoon as we exit from SMM mode. Figure 3 illustrates how the\nSMBR intercepts a keystroke signal and forwards it to the CPU.\n\nx\n\n\nAfter we have captured the keyboard data, we use the chipset\nLAN controller to transmit the key data collected by our SMM\nkeylogger to an external IP address. Thus, our SMM handler has 2\nfunctions: it logs keystrokes and then sends the logged data out\nover the chipset LAN interface. The transmit action is performed\nperiodically in the SMM handler when a defined keyboard data\nstorage buffer becomes full. Using a buffer as opposed to sending\nthe keystrokes immediately as they are received allows more\nvariability in when to send the data and could be exploited by a\nrootkit wishing to use traffic shaping techniques to stealthily\nblend in with existing network activity. This simulates the\nbehavior of a malicious attacker attempting to exfiltrate sensitive\nmaterial from a compromised system.\n\nThe LAN controller acts as both a master and a slave on the PCI\nbus. In the role of master, it interacts with system memory to\naccess transmit and receive data buffers. As a slave, the host\nprocessor accesses the LAN controller’s internal structures to read\nand write information to its on-chip registers. These registers may\nbe either I/O mapped or memory mapped. The method to use is\ndetermined by system software. The basic process for transmitting\na packet of data follows:\n\n1) We first check the LAN controller to ensure that it’s in an idle\nstate and not in the midst of transmitting or receiving.\n\n2) Next, we build a Transmit Command Block.\n\n3) Then, we build a data packet containing the keyboard buffer\ndata. For simplicity, we chose to use the UDP and TFTP\nprotocols. Thus, the basic packet structure consists of an\nEthernet header followed by an IP header, followed by a UDP\nheader, followed by a TFTP header, followed by the key data.\n\n\n-----\n\n|Manufacturer|Model|Chipset|Purchase Date|Locked?|\n|---|---|---|---|---|\n|DELL|Inspiron 8100|i815EP|2001|NO|\n|DELL|Dimension 4500|i845E|2002|NO|\n|DELL|Inspiron 1100|i845GL|2003|NO|\n|DELL|Dimension 2400|i845GV|2003|NO|\n|DELL|Dimension 4600|i865PE|2004|NO|\n|Custom Built|N/A|i845PE|2004|NO|\n|IBM|T42|i855PM|2005|YES|\n|DELL|Precision 390|i975X|2006|YES|\n|DELL|Dimension 9200|i965P|2006|YES|\n|DELL|Dimension 9150|i945P|2006|YES|\n|DELL|Inspiron 9400|i945GM|2006|YES|\n|DELL|Inspiron 530|iP35|2007|YES|\n|Sony|VAIO|i945GM|2007|YES|\n|Custom Built|N/A|i945X|2007|YES|\n\n\n**Figure 4: System Vulnerability Assessment**\n\n\n4) We load the LAN controller with the physical address of the\nTransmit Command Block.\n\n5) Finally, we initiate execution of the LAN controller. This\nwill cause it to begin executing the Transmit Command\nBlock constructed in step 2 and will send the packet\nconstructed in step 3 out over the network.\n\n## 4.3 Real World SMM Rootkits\nAlthough we have only implemented a proof of concept\nkeylogger and network backdoor, a real-world SMM rootkit\ncould implement an unlimited number of malicious services.\nVirtually every peripheral hardware device can be subverted\nusing these techniques. Some of these devices include the USB\nports, Mouse, and Hard Disks. We can envision an extended\nversion of our rootkit that not only transmits exfiltrated data, but\nalso receives malicious commands from an attacker and relays\nall manner of sensitive materials stealthily out over the network.\nAn SMM rootkit can also gain control on non hardware events\nlike periodic timer expiration. This would allow for SMIs to be\ngenerated at regular intervals, a potentially useful feature for a\nmalicious rootkit wishing to periodically gain control to inspect\nthe state of the system.\n\nFurthermore, such malicious activities are difficult to detect.\nThe SMM handler code is completely inaccessible to the host\nsystem and there are no changes to processor or Operating\nSystem data structures. Indeed, the only potentially detectable\nchanges are the modification to the I/O APIC redirection table\nand network activity. As there are legitimate reasons to change\nthe delivery mode to SMI (i.e., the change of I/O APIC\nredirection table by an SMM rootkit) that in itself is unlikely to\nbe a sufficient heuristic to identify a stealthy rootkit. One such\nlegitimate use is to provide legacy keyboard and mouse support\nfor USB devices [29]. Finally, the network transmission, which\noccurs inside of SMM at the chipset level will bypass any host\n\n\nx\n\nbased intrusion detection systems or firewalls. The network\nactivity could be further concealed by using traffic shaping\ntechniques.\n\n## 4.4 Limitations\nOur proof of concept rootkit has a number of implementational\nlimitations. It only works on PS/2 keyboards, a subset of\nnetwork cards, and it is limited to single processor systems. All\nof these limitations could be addressed with additional time and\nresearch. First, it is likely possible to extend our PS/2\nimplementation to intercept events from more modern USB\nkeyboards. The chipset I/O Controller Hub documentation\ndefines a legacy keyboard handling mechanism for USB\nkeyboards which may be exploitable. This legacy operation is\nperformed through SMM space and provides an area for future\nresearch.\n\n_“When a USB keyboard is plugged into the system, and a_\n_standard keyboard is not, the system may not boot, and DOS_\n_legacy software will not run, because the keyboard will not be_\n_identified. The ICH4 implements a series of trapping operations_\n_which will snoop accesses that go to the keyboard controller,_\n_and put the expected data from the USB keyboard into the_\n_keyboard controller. This legacy operation is performed_\n_through SMM space [6].”_\n\nSecond, network card support could be extended provided that\nchipset documentation is available. Intel provides developer\ndocumentation for most of their LAN cards. Finally, our rootkit\ncould probably be extended to work on the newer multiprocessor and multi-core systems. We don’t have a multi-core\ntest machine with SMM unlocked, however, the documentation\nindicates that any processor in a multiprocessor system can\nrespond to an SMI event and that two processors can be\nexecuting in SMM at the same time. Furthermore, the manual\nstates that SMM is not re-entrant and that each processor should\n\n\n-----\n\nXXX\n\nXXX\n\n\n**Figure 5: Our test driver opening SMRAM space and displaying the original SMM handler.**\n\n\nhave its own dedicated SMRAM space. Based upon this\ndocumentation, it should be possible to extend our rootkit to\nhandle SMI’s on more than processor; however, it will require\nadditional research and development.\n\nIn general, the architectural limitations that will apply to an\nSMM based rootkit include weather or not the SMRAMC\nregister is locked, the chipset specific nature of an SMBR, and\nthe size limitation of the SMM memory space. Clearly, the\nbiggest limitation is the fact that an SMBR can be installed only\nif the SMRAMC register is unlocked. The hardware specific\nnature of the SMBR is probably the second biggest limitation.\nBecause many of the register offsets vary based on chipset, an\nattacker would need to both know the hardware of the target\nmachine or hardcode a table of register offsets for every chipset\nand do detection on the fly. There may also be other subtle\ndiscrepancies in the chipset and/ or hardware implementation\nthat would require additional code to detect and handle. This\ncoupled with the fact that SMRAM is limited in size may render\na generic approach impractical. Finally, an SMBR is nonpersistent [26]. It exists only in volatile memory and must be reinstalled after a system reboot.\n\nBeyond the architectural limitations, there are also several other\nimplementational limitations. First, there is no Operating\nSystem driver support for the SMBR to rely upon. Hardware\naccess therefore requires implementation of rudimentary low\nlevel drivers inside the SMM handler. Second, the handler must\nbe written in 16 bit assembly [5]. It is at least mildly reassuring\nthat writing chipset level hardware device drivers in 16 bit\nassembly is beyond the reach of all but the most sophisticated\nattackers. As a result, it is unlikely that SMM will appear in\ncommon malware, but will instead remain limited to\nsophisticated, targeted attacks.\n\n\n## 5. TESTING\nWe conducted four different tests. The first one was a\nvulnerability assessment. We wanted to get an idea of how\nwide-spread the SMBR threat might be and the types of systems\nthat were most likely to be affected. Our other experiments\ninvolved testing our proof of concept SMM rootkit on a live\nsystem. We sought to validate its invisibility to other system\nsoftware and its functionality as a keylogger network backdoor\ncapable of exfiltrating sensitive data.\n\n## 5.1 Vulnerability Assessment\nThe goal of our first experiment was to perform a system\nvulnerability assessment. We wrote a Windows device driver to\nquery the SMRAMC register for the values of the D_OPEN,\nD_CLOSED, and D_LCK bits. We ran this program on 14\ndifferent systems and recorded the manufacturer, chipset, BIOS\nversion, BIOS date, and whether or not the system was locked.\nFigure 5 shows debug output from the test driver we wrote. Out\nof these 14 systems, we found 6 were unlocked and vulnerable\nto the SMBR threat. Because a majority of the unlocked\nsystems had BIOS revision dates two years old or greater and\nmost of the locked systems had more recent BIOS revision\ndates, we concluded that newer BIOS were locking System\nManagement Mode. Nevertheless, a substantial percentage of\ncommodity hardware in use today is at least two years old. This\nstill makes SMBRs a significant threat. Figure 4 summarizes\nour preliminary results. We will conduct more comprehensive\nvulnerability assessment in the near future, especially testing a\nvariety of older Intel-based machines.\n\n## 5.2 Live Testing – Hiding In Memory\nOur next experiment involved testing our proof of concept\nSMBR. We installed it on an unlocked DELL Dimension 2400\n\n\n-----\n\n**Figure 6: Capturing the Key Logger Packet (TFTP Header is [00,03,00,00] for a data packet).**\n\n\nrunning an Intel 845 chipset. The system was installed with the\nMicrosoft Windows XP Operating system. We first sought to\nverify the invisibility of the installed rootkit. This was\naccomplished by using the WinDbg kernel debugger to view the\nphysical memory region where we loaded the rootkit code [28].\nAs expected, we were unable to read the code from this area\nbecause one of the functions of the rootkit installer is to close\nand lock System Management Mode by writing to the\nSMRAMC register. As shown in Figure 2, this will cause the\naccess to be routed to VGA memory.  This result is\nunsurprising when one considers that the chipset’s Memory\nController Hub (MCH) functions as a gatekeeper for all physical\nmemory accesses. All memory accesses, regardless of weather\nthey originate from software or hardware must pass through the\nMCH logic. The MCH logic snoops physical addresses on the\nbus and blocks unauthorized access to certain ranges like the\nSMM memory space.\n\n## 5.3 Live Testing – Key Logging\nNext, we validated the operation of the keylogger. Our proof of\nconcept code is currently limited to keyboards with a P/S 2\ninterface. Because it is impossible to read SMRAM once the\nrootkit is installed and the size of the SMRAM space is limited,\nwe needed a way to save and verify the logged keystrokes. We\nimplemented two different output methods: the serial port and\nsystem physical memory.\n\nIn the first method, we output the logged keystrokes over the\nserial port from inside the SMM handler. We use the Windows\nHyperterminal program to capture the serial output and verify it\n\n\nXXX\n\nagainst our key presses. This method is primarily useful for\ndebugging the SMM rootkit code.\n\nIn the second method, the SMM handler writes the keyboard\ndata to an allocated page of physical memory. Since this page is\noutside the SMRAM space, we were able to attach the WinDbg\nkernel debugger and read the recorded keyboard scan codes\nfrom the page. An attacker could use system memory in this\nmanner as a temporary storage for the key log file. To make it\neven stealthier, the attacker could encrypt the data in SMM\nmode before writing it out to system memory. Because\nSMRAM is not accessible outside SMM, it would be impossible\nto obtain a copy of the key to decrypt the stored data, even if one\nknew where to look. To an outsider the encrypted keyboard\ndata would simply appear as random bytes and would be\nunlikely to raise suspicion.\n\nIt should also be mentioned that our SMBR implementation\ndoesn’t adversely affect the performance of the target system.\nThat is, from a subjective, user’s perspective, our SMBR key\nlogger does not introduce any noticeable slow down or latency\nin keyboard input at the GUI level. We validated this at\ndifferent typing rates, but did not quantify the SMBR’s\nperformance using objective measures. This is an area of future\nresearch.\n\n## 5.4 Live Testing – Data Exfiltration\nFinally, we validated that our network backdoor was able to\nboth log keystrokes and transmit packets containing the logged\ndata successfully from inside the SMM rootkit handler. We\nused an Intel Pro 100B network card for development and tested\n\n\n-----\n\nXXX\n\n|Category|SMBR|VMBR|\n|---|---|---|\n|Vulnerable System Space|Mostly pre 2005 Systems|Post 2006 Systems|\n|Operational Environment|16 bit Mode w/o Paging|32 bit Protected Mode w/ Paging|\n|OS Independent|YES|YES|\n|Memory Footprint Hiding|YES|YES (with memory virtualization)|\n|Control|Chipset IRQs \u0001 Keyboard \u0001 Mouse \u0001 Network Card \u0001 USB \u0001 Disk|CPU \u0001 Processor Interrupts \u0001 Debug Register R/W \u0001 Control Register R/W \u0001 Privileged Instructions \u0001 Memory Access|\n|Defense|Set D_LCK in SMRAMC register either in BIOS or during early boot of OS.|OS or BIOS should install a secure virtual machine that prevents installation of 3rd party virtual machines.|\n\n\n**Figure 7: Comparison of VMBRs and SMBRsXXX**\n\n\nusing 2 machines connected to an an Ethernet network via a\nDLINK router. The first machine was the aforementioned Dell\nDimension 2400. We installed the SMBR on it. The second\nmachine was a Dell Precision 390 running Windows XP. We\ninstalled Microsoft Network Monitor 3.1 on it so that we could\nsniff incoming network traffic. We were able to validate that the\nkey press data was successfully received by the second machine\nby examining the sniffer output. The SMM network code,\nhowever, is card specific and would require modification to run\non other network cards. Figure 6 provides a screenshot showing\nthat the SMM keyboard data was packaged into a TFTP packet\nand sent out to the remote machine using UDP over IP. The\ndata payload following the TFTP header is highlighted.\n\n## 6. EVALUATION & DISCUSSION\nSMM and VMM based rootkits both operate at a level outside\nan existing operating system. Therefore it makes sense to\ncompare and contrast them. We compare and contrast the SMM\nand VMM rootkits based on 4 characteristics: Operating\nEnvironment, Complexity and Size, Control, and Stealth.\nFigure 7 summarizes the comparisons between SMBRs and\nVMBRs.\n\n## 6.1 Operating Environment\nSMBR and VMBR rootkits each have their own optimal target\nenvironment.  Both types of rootkits are hardware specific.\nVirtualization rootkits can only exist on processors supporting\nvirtualization extensions. This limits them to newer processors\nmostly less than 1-2 years old. In contrast, SMM rootkits are\nmore likely to exist on older processors containing older BIOS\nversions (greater than 1-2 years old as shown in Figure 7). This\nis due to the fact that many newer BIOS have set the D_LCK bit\nin the SMRAM control register rendering SMRAM inaccessible\noutside the BIOS.\n\nAdditionally, while virtualization rootkits are processor specific,\nSystem Management Mode based rootkits are chipset specific.\nThis makes them best suited for a sophisticated, targeted attack\n\n\nrather than a vector for widespread malware distribution. The\noperating environments are also very different because VMBRs\noperate in protected mode with paging enabled while SMBRs\noperate in a 16 bit environment similar to Real Mode without\npaging. Finally, both VMBR’s and SMBR’s can be classified as\nnon-persistent rootkits. Non persistent rootkits exist only in\nmemory and lack the ability to persist across reboots on the\nmachine they are installed on. Although on the surface this\nseems like a significant disadvantage, when one considers that\nmany server systems run for weeks or months at a time between\nreboots, it becomes less of an issue. Due to the complex nature\nof the SMBR, it is unlikely that such a rootkit will appear on the\nmore frequently rebooted systems (e.g. home user machines)\nanytime soon.\n\n## 6.2 Complexity & Size\nCompared with VMBRs, SMBRs have an advantage in terms of\nsize and complexity. While they have the added developmental\ncomplexity of having to deal with writing the SMM handler in\nlegacy 16 bit assembly, they expend little effort to conceal their\nmemory footprint as the chipset handles the memory access\nredirection once SMRAM has been closed and locked by the\nhandler. On the other hand, in order to provide similar stealth, a\nVMBR will likely have a larger code footprint. This is due to its\nneed to include complex paging code for memory virtualization\nsupport.\n\n## 6.3 Control\nBoth VMBR and SMBR rootkits are capable of efficiently\nexerting control over the system and neither needs to modify the\ntarget Operating System in order to obtain that control. With\nthat said, VMM rootkits might have the upper hand where\nflexibility is concerned. They can intercept a greater number of\nhigher level events like interrupts, memory access, debug and\ncontrol register reads / writes, and execution of specific\nprivileged instructions. Although SMBRs have considerable\ncontrol over peripheral hardware as we demonstrated in our\n\n\n-----\n\nproof of concept keylogger, in general, they tend to intercept\nlower level hardware events like power management, thermal\nregulation, and bus errors and will have limited control over\nprocessor specific events like memory access and instruction\nexecution.\n\n## 6.4 Stealth\nCompared with VMBRs, SMBRs are stealthier. Several\ndetections based upon cache and TLB discrepancies have been\nproposed for detecting virtualization rootkits [2]. Because a\nVMBR operates in protected mode with paging enabled, there is\nno easy way for it to prevent its execution from affecting the\nTLB. SMBRs are immune to these types of detection because\nthey operate in an environment without cacheing or paging\nenabled. Therefore, they should not have any detectable effects\nupon either the cache or the TLB.\n\nSMM rootkits may provide greater stealth with less overhead. A\nVMM rootkit is not hidden in memory unless it implements\nmemory virtualization. In contrast, the SMBR is hidden by\ndefault due to the MCH redirection of non SMM originated\nmemory accesses to the SMRAM region.\n\n## 7. DEFENSE\nIn this section, we consider the detection and prevention of both\nOS dependent and OS independent rootkits.  We feel that the\nemergence of OS independent rootkits necessitates a shift in\nfocus from detection to prevention.\n\n## 7.1 OS Dependant Rootkits\nTo date, most rootkit defense has focused on rootkit detection.\nThis is possibly because detecting an OS dependent rootkit may,\nin fact, be easier than preventing its installation. Prevention is\ndifficult and there are several reasons for this. These include\ndifficulty controlling end user behavior, multiple attack entry\npoints, and the presence of unpatched vulnerabilities.\n\nIt is difficult to control the behavior of an end user. End users\nare subject to social engineering attacks which may lead to them\ninadvertently install or run a malicious application. Assuming\nthat the malicious application has gotten past the user, security\nsoftware may attempt to prevent further damage by preventing\nor limiting access to the kernel. Unfortunately, there are many\nentry points into the kernel and it is difficult to guard them all.\nAdditionally, there are often undocumented entry points into a\nsystem. These usually take the form of exploits for unpatched\nvulnerabilities in the Operating System or critical software.\n\nWhile prevention is a difficult problem, detection may be\nslightly easier. OS dependent malware can be detected fairly\nreliably using signature or heuristic based scans. Clearly,\nmalware that coexists with an OS must make changes within the\nenvironment in order to exercise control over it and / or hide\nitself. Heuristics have been developed to detect many of these\nchanges [11][22].\n\n## 7.2 OS Independant Rootkits\nOS independent rootkits present a new dilemma. Both\nvirtualization and SMM rootkits are considerably more difficult\nto defend against than OS dependent malware. First, it is not\nnecessary for them to make any visible changes to the OS.\nThus, heuristics are not useful. Second, they have the capability\nto conceal their memory footprints making signatures useless.\n\n\nAs a result, indirect detection measures like timing or cache\ndiscrepancies have been suggested for virtualization rootkits [2].\n\nTiming attacks may provide a method of detecting an SMM\nrootkit. We have validated that the processor’s timestamp\ncounter is updated, even while executing in SMM. Thus, it may\nbe possible to devise a detection that reads the timestamp\ncounter before and after an SMI and compares it with the time it\ntakes to simply perform sequential reads of the counter.\nUnfortunately, it is also possible for an SMM rootkit to cheat\nthis form of detection. This is because the rootkit itself has\naccess to the counter and is capable of modifying it before\nreturning control back to the host Operating System.\n\nAnother class of detection for OS independent malware relies on\ncache or TLB discrepancies. For example, VMM rootkits may\nbe detected by their effects on the cache or TLB because they\nmust exist in cacheable, pageable memory. Unfortunately, this\nkind of timing attack is not valid against SMM rootkit. SMM\nrootkit does not influence the cache or TLB because it can exist\nin uncached memory and does not use paging.\n\nIt has also been suggested to move detection off the CPU onto\nanother hardware device that has access to physical memory\n\n[14]. The problem with this approach is that the chipset\narbitrates all external device communication / physical memory\naccess through the Memory Controller Hub (MCH). Therefore,\nSMRAM will remain inaccessible to any devices residing on the\nsystem bus.\n\nAs mentioned previously, one could check the IOAPIC\nredirection table for interrupts that have been routed to SMIs. A\nrerouted interrupt may be considered a “red flag”, but even that\nmay not be a sufficient heuristic. There are, in fact, legitimate\nreasons to route an interrupt to an SMI. One such legitimate\nuse is to provide legacy keyboard and mouse support for USB\ndevices [29]. Therefore, lacking other rootkit indicators, it may\nbe difficult to determine the illegitimacy of a re-routed interrupt\nand state with certainty that it was installed by a rootkit. It may,\nhowever, be possible to detect VMBR and SMBR malware\nduring installation if a signature is known. This is possible\nbecause an anti-malware kernel module can scan third party\ndrivers and processes as they are being loaded. On the other\nhand, if a signature for the malware is not known or the malware\ninstalls itself through an undocumented interface (e.g. exploit),\nit is unlikely to be detected.\n\nWe suggest that the emergence of OS independent malware like\nSMM and virtualization rootkits necessitates a shift in emphasis\nfrom detection to prevention. Virtualized rootkits may be\nprevented by installing a secure Virtual Machine Monitor\n(VMM) that prevents the installation of other virtual machines\n\n[27]. SMBRs can be prevented by locking down the SMRAM\nregister in the BIOS. Therefore, chipset manufacturers should\nbe encouraged to release BIOS updates to address this problem.\nand system administrators of older machines should ensure that\ntheir BIOS are up to date. In the interim, the Operating System\ncould greatly mitigate this problem by locking the register\nduring early boot before third party drivers are loaded. This\nwould prevent such rootkits from being installed by user mode\napplications or kernel drivers on a running system. Failing both\nof the aforementioned suggestions, a third party Anti Virus or\nHost Based Intrusion Prevention (HIPS) software application\n\n\n-----\n\ncould write a driver to lock the SMRAM control register that the\nOS installs during early boot. Unfortunately, it is difficult to\nguarantee that the protection driver will be loaded before\nanother malicious kernel driver.\n\nIn this paper, we have exposed a potential threat that has not\nbeen widely recognized. We have established that a SMM\nrootkit has chipset level control over peripheral hardware\nincluding the network controller, USB ports, mouse, keyboard,\nand disk. It has control of both the I/O and Local APIC, is able\nto easily conceal its memory footprint, and read / write\nindiscriminately to the 32 bit physical address space. Practical\ndevelopment of an SMM rootkit, however, is constrained by the\nfollowing limitations: the need for SMRAM to be unlocked, the\nneed to write the handler in assembly, and the lack of Operating\nSystem support. As a result, it likely that SMM rootkits will\nremain limited to sophisticated, targeted attacks.\n\nFinally, we note that the SMM rootkit can be viewed as a new\nbreed of OS independent malware related to VMBR and BIOS\nrootkits and that a significant number of older systems ( >2\nyears old) remain vulnerable to this threat. Furthermore, the\nSMBR provides a method of implementing an OS independent\nrootkit on processors that don’t support the new virtualization\nextensions. Thus, it may contribute to an effective multi-vector\nrootkit attack capable of targeting a large subset of current\nsystems on the market. We suggest that the emergence of such\nmalware necessitates a shift in perspective from detection to\nprevention and that a closer relationship between security\nresearchers and hardware developers should be fostered.\n\n## ACKNOWLEDGEMENT\nThis work was supported by NSF Cyber Trust Grant CNS0627318 and Intel Research Fund.\n\n## 8. REFERENCES\n\n[1] S.T. King, P.M. Chen, Y-M Wang, C. Verbowski, H.J.\nWang, and J.R. Lorch. Subvirt: Implementing malware\nwith virtual machines. In Proceedings of IEEE Symposium\n_on Security and Privacy_ _(S&P'06), pages 314{327,_\nWashington, DC, USA, 2006. IEEE Computer Society.\n\n[2] T. Garfinkel, K. Adams, A. Warfield, and J. Franklin.\nCompatibility is Not Transparency: VMM Detection\nMythis and Realities. In HotOS XI: 11[th] Workshop on Hot\n_Topics in Operating Systems, 2007. USENIX._\n\n[3] J. Rutkowska. Subverting Vista Kernel for Fun and Profit.\nPresented at Black Hat USA, Aug. 2006.\n\n[4] Intel Corporation. Intel 64 and IA-32 Architectures\n_Software Developer’s Manual Volume 3B: System_\n_Programming Guide, Part 2. May 2007._\n\n[5] Intel Corporation. Intel 64 and IA-32 Architectures\n_Software Developer’s Manual Volume 3A: System_\n_Programming Guide, Part 1. May 2007._\n\n[6] Intel Corporation. Intel 82801DB I/O Controller Hub 4\n_(ICH4). May 2002._\n\n[7] Intel Corporation.  Intel 845GE/845PE Chipset\n_Datasheet. Oct. 2002._\n\n[8] J. Heasman. Implementing and Detecting an ACPI BIOS\nRootkit. Presented at Black Hat Federal, 2006.\n\n\n\n[9] L. Duflot, D. Etiemble, and O. Grumelard. Using CPU\nSystem Management Mode to Circumvent Operating\nSystem Security Functions. In. DCSSI 51 bd. De la Tour\n_Maubourg 75700 Paris Cedex, France. 2007._\n\n[10] S. Sparks and J. Butler. Shadow Walker: Raising the Bar\nfor Windows Rootkit Detection. In Phrack Volume 0x0B,\n_Issue 0x3D, Phile #0x08 of 0x14. 2005._\n\n[11] J. Butler. VICE – Catch the Hookers. Presented at Black\n_Hat USA. Aug 2004._\n\n[12] G. Kim and E. Spafford. The design and implementation\nof tripwire: a file system integrity checker. In Proceedings\n_of the 2[nd] ACM Conference on Computer and_\n_communications security, 1994. ACM Press._\n\n[13] J. Butler and G. Hoglund. Rootkits: Subverting the\n_Windows Kernel. Addison-Wesley, 2005._\n\n[14] N. L. Petroni, T. Fraser, J. Molina, and W. A. Arbaugh.\nCopilot – A Coprocessor-based Kernel Runtime Integrity\nMonitor. In Proc. Usenix Security Symposium, Aug. 2004.\n\n[15] 8042 Keyboard Controller..\nhttp://heim.ifi.uio.no/~stanisls/helppc/8042.html\n\n[16] Rootkit. http://en.wikipedia.org/wiki/Rootkit. 2007.\n\n[17] B. Cogswell and M. Russinovich. RootkitRevealer v1.71.\nNov 1, 2006.      Http://www.microsoft.com/technet/\nsysinternals/Utilities/RootkitRevealer.mspx\n\n[18] F-Secure Black Light. http://www.f-secure.com/blacklight\n\n[19] Thimbleby, S. Anderson, P. Cairns. A Framework for\nModeling Trojans and Computer Virus Infections. The\n_Computer Journal, Vol. 41, No.7, pp. 444-458. 1998._\n\n[20] G. Hoglund. A *REAL* NT Rootkit, patching the NT\nKernel. In Phrack Magazine, Vol. 9, No 55, 1999.\n\n[21] Fuzen Op. The FU rootkit.\nhttp://www.rootkit.com/project.php?id=12.\n\n[22] J. Rutkowska. System Virginity Verifier – Defining the\nRoadmap for Malware Detection on Windows System.\nPresented at Hack In The Box. Sept 2005.\n\n[23] D. A. Zovi. Hardware Virtualization Rootkits. Presented at\n_Black Hat USA, Aug 2006. http://www.theta44.org/_\nsoftware/HVM_Rootkits_ddz_bh-usa-06.pdf\n\n[24] J. Rutkowska. New Blue Pill.\nhttp://www.bluepillproject.org/stuff/nbp-0.11.zip. 2007\n\n[25] J. Heasman. Implementing and Detecting an ACPI BIOS\nRootkit. Presented at Black Hat, Federal. 2006.\n\n[26] http://www.blackhat.com/presentations/bh-federal-06/BHFed-06-Heasman.pdf\n\n[27] J. Butler and S. Sparks. Windows rootkits of 2005, part\ntwo. http://www.securityfocus.com/infocus/1851. 2005.\n\n[27] J. Rutkowska. IsGameOver() Anyone?  Presented at\n_Black Hat, USA. Aug 2007._\n\n[28] Windbg. http://en.wikipedia.org/wiki/WinDbg. 2007.\n\n[29]  Support for USB and Legacy Keyboards and Mouse\nDevices. Dec 2001.\nhttp://microsoft.com/whdc/device/input/usbhost.mspx\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/System Components and Abuse/SMM Rootkits - A New Breed of OS Independent Malware.pdf"
    ],
    "report_names": [
        "SMM Rootkits - A New Breed of OS Independent Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535649,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/232302a7a9aeb7eba0d296a5e846664efcb6ca4f.pdf",
        "text": "https://archive.orkl.eu/232302a7a9aeb7eba0d296a5e846664efcb6ca4f.txt",
        "img": "https://archive.orkl.eu/232302a7a9aeb7eba0d296a5e846664efcb6ca4f.jpg"
    }
}