{
    "id": "9116f9a9-cad4-451d-bc87-c13fa7937776",
    "created_at": "2023-01-12T15:06:18.836532Z",
    "updated_at": "2025-03-27T02:06:13.037463Z",
    "deleted_at": null,
    "sha1_hash": "88d302bdb91c9580fe2edd61702d257b8c2c4b3c",
    "title": "2021-06-30 - Automation in Reverse Engineering- String Decryption",
    "authors": "",
    "file_creation_date": "2022-05-27T21:38:07Z",
    "file_modification_date": "2022-05-27T21:38:07Z",
    "file_size": 97667,
    "plain_text": "# Automation in Reverse Engineering: String Decryption\n\n**[synthesis.to/2021/06/30/automating_string_decryption.html](https://synthesis.to/2021/06/30/automating_string_decryption.html)**\n\nAutomation plays a crucial rule in reverse engineering, no matter whether we search for\nvulnerabilities in software, analyze malware or remove obfuscated layers from code. Once\nwe manually identify repeating patterns, we try to automate the process as far as possible.\n[For automation, it often doesn’t matter if you use Binary Ninja,](https://binary.ninja/) [IDA Pro or](https://hex-rays.com/ida-pro/) [Ghidra, as long as](https://ghidra-sre.org/)\nyou have the knowledge how to realize it in your tool of choice. As you will see, you don’t\nhave to be an expert to automate tedious reverse engineering tasks; sometimes it just takes\na few lines of code to improve your understanding a lot.\n\nToday, we take a closer look at this process and automate the decryption of strings for a\n[malware sample from the Mirai botnet. Mirai is a malware family that hijacks embedded](https://en.wikipedia.org/wiki/Mirai_(malware))\nsystems such as IP cameras or home routers by scanning for devices that accept default\nlogin credentials. To impede analysis, Mirai samples store those credentials in an encoded\nform and decode them at runtime using a simple XOR with a constant. In the following, we\nfirst manually analyze the string obfuscation. Afterward, we use Binary Ninja’s high-level\nintermediate language (HLIL) API to get all string references and decrypt them.\n\nIn static malware analysis, one of the first things to do is to have a closer look at the\nidentified strings, since they often reveal a lot of context. In this sample, however, we mostly\nsee strings like `PMMV,` `CFOKL,` `QWRRMPV and others. At first glance, they don’t make much`\nsense. However, if we have a closer look at how they are used in the code, we notice\nsomething interesting: They are repeatedly used as function parameters for the function\n```\nsub_10778 . (The corresponding function calls can be found here in the leaked source\n\n```\ncode.)\n```\nsub_10778(\"PMMV\", &data_1616c, 0xa)\nsub_10778(\"PMMV\", \"TKXZT\", 9)\nsub_10778(\"PMMV\", \"CFOKL\", 8)\nsub_10778(\"CFOKL\", \"CFOKL\", 7)\nsub_10778(\"PMMV\", &data_16184, 6)\nsub_10778(\"PMMV\", \"ZOJFKRA\", 5)\nsub_10778(\"PMMV\", \"FGDCWNV\", 5)\nsub_10778(\"PMMV\", 0x1619c, 5) {\"HWCLVGAJ\"}\nsub_10778(\"PMMV\", &data_161a8, 5)\nsub_10778(\"PMMV\", &data_161b0, 5)\nsub_10778(\"QWRRMPV\", \"QWRRMPV\", 5)\n\n```\n\n-----\n\n```\nsub_10778( root, xc3511, 0xa)\nsub_10778(\"root\", \"vizxv\", 9)\nsub_10778(\"root\", \"admin\", 8)\nsub_10778(\"admin\", \"admin\", 7)\nsub_10778(\"root\", \"888888\", 6)\nsub_10778(\"root\", \"xmhdipc\", 5)\nsub_10778(\"root\", \"default\", 5)\nsub_10778(\"root\", 0x1619c, 5) {\"juantech\"}\nsub_10778(\"root\", \"123456\", 5)\nsub_10778(\"root\", \"54321\", 5)\nsub_10778(\"support\", \"support\", 5)\ndef decrypt(address, already_decrypted):\n  # walk over string bytes until termination\n  while True:\n    # read a single byte from database\n    encrypted_byte = bv.read(address, 1)\n    # return if null byte or already decrypted\n    if encrypted_byte == b'\\x00' or address in already_decrypted:\n      return\n    # decrypt byte\n    decrypted_byte = chr(int(encrypted_byte[0]) ^ 0x22)\n    # write decrypted byte to database\n    bv.write(address, decrypted_byte)\n    # add to set of decrypted addresses\n    already_decrypted.add(address)\n    # increment address\n    address += 1\n\n```\n\n-----\n\n```\n# get function instance of target function\ntarget_function = bv.get_function_at(0x10778)\n# set of already decrypted bytes\nalready_decrypted = set()\n# 1: walk over all callers\nfor caller_function in set(target_function.callers):\n  # 2: walk over high-level IL instructions\n  for instruction in caller_function.hlil.instructions:\n    # 3: if IL instruction is a call\n    #  and call goes to target function\n    if (instruction.operation == HighLevelILOperation.HLIL_CALL and\n      instruction.dest.constant == target_function.start):\n      # 4: fetch pointer to encrypted strings\n      p1 = instruction.params[0]\n      p2 = instruction.params[1]\n      # 5: decrypt strings\n      decrypt(p1.value.value, already_decrypted)\n      decrypt(p2.value.value, already_decrypted)\n\n```\nBased on this, we can assume that the passed strings are decoded and further processed in\nthe called function. If we inspect the decompiled code of the function, we identify the\nfollowing snippet that operates on the first function parameter `arg1 . For the second`\nparameter `arg2, we can find a similar snippet.`\n```\nuint32_t r0_3 = sub_12c90(arg1)\nvoid* r0_5 = sub_14100(r0_3 + 1)\nsub_12d0c(r0_5, arg1, r0_3 + 1)\nif (r0_3 s> 0) {\n  char* r2_3 = nullptr\n  do {\n    *(r2_3 + r0_5) = *(r2_3 + r0_5) ^ 0x22\n    r2_3 = &r2_3[1]\n  } while (r0_3 != r2_3)\n}\n\n```\nThe code first performs some function calls using `arg1, goes into a loop and increments a`\ncounter until the condition `r0_3 != r2_3 no longer holds. Within the loop, we notice an`\nXOR operation `*(r2_3 + r0_5) ^ 0x22, where` `*(r2_3 + r0_5) seems to be an array-`\nlike memory access that is xored with the constant `0x22 . After performing a deeper`\nanalysis, we can clean up the code by assigning some reasonable variable and function\nnames.\n\n\n-----\n\n```\nuint32_t length strlen(arg1)\nvoid* ptr = malloc(length + 1)\nstrcpy(ptr, arg1, length + 1)\nif (length s> 0) {\n  char* index = nullptr\n  do {\n    *(index + ptr) = *(index + ptr) ^ 0x22\n    index = &index[1]\n  } while (length != index)\n}\n\n```\nNow, we have a better understanding of what the code does: It first calculates the length of\nthe provided string, allocates memory for a new string and copies the encrypted string into\nthe allocated buffer. Afterward, it walks over the copied string and decrypts it bytewise by\nxoring each byte with `0x22 . This is also in line with the decryption routine of the original`\nsource code.\n\nIn other words, strings are encoded using a bytewise XOR with the constant value `0x22 . If`\nwe want to decode the string `PMMV in Python, we can do this with the following one-liner.`\n\nWe walk over each byte of the string, get its corresponding ASCII value via `ord, xor it with`\n```\n0x22 and transform it back into a character using chr . In a final step, we join all\n\n```\ncharacters into a single string.\n\nAfter we manually analyzed how strings can be decrypted, we will now automate this with\nBinary Ninja.\n\nTo automate the decryption, we first have to find a way to identify all encoded strings. In\nparticular, we have to know where they start and where they end; in other words, we aim to\nidentify all encrypted bytes. In the second step, we can decrypt each byte individually.\n\nBeforehand, we noticed that the encoded strings are passed as the first two parameters to\nthe function `sub_10778 . To obtain the encoded strings, we can exploit this characteristic by`\nsearching for all function calls and parse all passed parameters. Using Binary Ninja’s highlevel intermediate language (HLIL) API, we can realize this within a few lines of code.\n\nAfter fetching the function object of the targeted function `sub_10778, we walk over all`\nfunctions calling `sub_10778 . For each of these calling functions (referred to as callers), we`\nneed to identify the instruction that performs the call to `sub_10778 . In order to do this, we`\nwalk over the caller’s HLIL instructions; for each instruction, we then check if its operation is\na call and if the call destination is the targeted function. If so, we access its first two\nparameters (the pointers to the encoded strings) and pass them to the decryption function.\nSince some strings—such as `PMMV —are used as parameters multiple times, we ensure`\nthat we only decrypt them once. Therefore, we collect the addresses of all bytes that we\nalready have decrypted in a set called `already_decrypted .`\n\n\n-----\n\nUp until now, we identified all parameters that flow into the decryption routine. The only thing\nleft to do is to identify all encrypted bytes and decrypt them. Since each parameter is a\npointer to a string, we can consider it as the string’s start address. Similarly, we can\ndetermine the string’s end by scanning for terminating null bytes.\n\nTaking the string’s start address as input, we sequentially walk over the string until we reach\na byte that terminates the string or that was already decrypted. For each byte, we then\ntransform it into an integer, xor it with `0x22, encode it as a character and write it back to the`\ndatabase. Afterward, we add the current address to the set `already_decrypted and`\nincrement the address.\n\nFinally, we have all parts together: We walk over all function calls of the string decryption\nfunction, parse the parameters for each call and decrypt all the strings in Binary Ninja’s\ndatabase. If we put everything into a Python script and execute it, the decompiled code from\nabove contains all strings in plain text.\n\nAutomation allows us to spend less time with tedious and repetitive reverse engineering\ntasks. In this post, I tried to emphasize the thought process behind automation on the\nexample of decrypting strings in malware. Starting with manual analysis, we first pinpointed\ninteresting behavior: encrypted strings used as function parameters. Then, we put it into\ncontext by digging into the function, and learned that the strings are decrypted inside. By\nnoticing a recurring pattern—that the function is called several times with different\nparameters—we developed an idea of how to automate the decryption. By using Binary\nNinja’s decompiler API, we walked over all relevant function calls, parsed the parameters\nand decrypted the strings. In the end, 20 lines of code sufficed to improve the decompilation\nand achieve a much better understanding of the malware sample.\n\nEven if you are just starting out, I encourage you to get familiar with the API that your tool of\nchoice exposes, and to automate some of the tedious tasks you encounter during your dayto-day reversing. It is not only fun; reverse engineering also becomes so much easier.\n\nFor questions, feel free to reach out via Twitter [@mr_phrazer, mail](https://twitter.com/mr_phrazer) [tim@blazytko.to or](http://10.10.0.46/mailto:tim@blazytko.to)\nvarious other channels.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-30 - Automation in Reverse Engineering- String Decryption.pdf"
    ],
    "report_names": [
        "2021-06-30 - Automation in Reverse Engineering- String Decryption.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535978,
    "ts_updated_at": 1743041173,
    "ts_creation_date": 1653687487,
    "ts_modification_date": 1653687487,
    "files": {
        "pdf": "https://archive.orkl.eu/88d302bdb91c9580fe2edd61702d257b8c2c4b3c.pdf",
        "text": "https://archive.orkl.eu/88d302bdb91c9580fe2edd61702d257b8c2c4b3c.txt",
        "img": "https://archive.orkl.eu/88d302bdb91c9580fe2edd61702d257b8c2c4b3c.jpg"
    }
}