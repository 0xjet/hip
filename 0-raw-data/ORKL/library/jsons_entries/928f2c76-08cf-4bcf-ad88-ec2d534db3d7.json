{
    "id": "928f2c76-08cf-4bcf-ad88-ec2d534db3d7",
    "created_at": "2023-01-12T15:10:03.944479Z",
    "updated_at": "2025-03-27T02:05:35.702077Z",
    "deleted_at": null,
    "sha1_hash": "552f745b95f2ac2110bd911bd512c44db210e4c0",
    "title": "2019-12-05 - Buer Loader, new Russian loader on the market with interesting persistence",
    "authors": "",
    "file_creation_date": "2022-05-28T04:06:13Z",
    "file_modification_date": "2022-05-28T04:06:13Z",
    "file_size": 1534827,
    "plain_text": "# Buer Loader, new Russian loader on the market with interesting persistence\n\n**[krabsonsecurity.com/2019/12/05/buer-loader-new-russian-loader-on-the-market-with-interesting-persistence/](https://krabsonsecurity.com/2019/12/05/buer-loader-new-russian-loader-on-the-market-with-interesting-persistence/)**\n\n[Posted on December 5, 2019](https://krabsonsecurity.com/2019/12/05/)\nIn the middle of November, a friend told me of a new malware being sold on Russian\nforums under the name “Buer Loader”. A translated copy of the thread where it is advertised\n[can be found here. A google search revealed no one having mentioned “Buer Loader”](https://pastebin.com/6C5V06tK)\nbefore, nor provided an analysis of it. However, a forum administrator had already provided\nan analysis of the malware, in which the following screenshot of strings was provided.\n\n\n-----\n\nWith this, we can now hunt for Buer Loader samples. Based on the strings, a variety of\nsamples that drop Buer Loader or is Buer Loader were found. Their hashes are listed\nbelow:\n\n\n-----\n\nddc4d9fa604cce434ba131b197f20e5a25deb4952e6365a33ac8d380ab543089\nfcdf29266f3508bd91d2446f20a73a811f53e27ad1f3e9c1f822458f1f30b5c9\n1db9d9d597636fb6e579a91b9206ac25e93e912c9fbfc91f604b7b1f0e18cc0a\n\nMalwareHunterTeam also [found a sample, though he did not refer to it by name. Strings for](https://twitter.com/James_inthe_box/status/1194358787513077766)\nthe file was posted by James_inthe_box.\n\nA large number of samples, such as\n0dd7e132fb5e9dd241ae103110d085bc4d1ef7396ca6c84a3b91dc44f3aff50f which was\n[spotted on November 12th multiple times, are packed with Themida. We thankfully found](https://www.hybrid-analysis.com/search?query=context:0dd7e132fb5e9dd241ae103110d085bc4d1ef7396ca6c84a3b91dc44f3aff50f)\none that wasn’t, with the hash of\n6c694df8bde06ffebb8a259bebbae8d123effd58c9dd86564f7f70307443ccd0.\n\nThe file in question is a VB6 file, and can be found on Hybrid-Analysis.\n\nAfter starting, the process executes a shellcode that is stored on the heap. Due to the\nprocess not having DEP enabled, the shellcode runs fine.\n\nThe shellcode does a typical process hollowing. The original image is unmapped below.\n\nNext NtWriteVirtualMemory is called using DllCallFunction to write the malicious payload.\n\n\n-----\n\nDumping it from memory and trimming the overlay, we have a 27kb executable file that\nappears to be compiled with Visual Studio 2017. This would seem to be our original Buer\nLoader file. The TimeDateStamp indicates that it was compiled on Thu, 29 Aug 2019\n05:48:03 UTC.\n\nThe file starts out with checking for debugger by reading PEB->BeingDebugged. If this\ncheck is passed, it checks for virtualization, and then enter the real code.\n\n\n-----\n\nHere, the code uses sidt/sgdt to detect the presence of virtualization. More details on that\n[can be found here.](http://charette.no-ip.com:81/programming/2009-12-30_Virtualization/www.offensivecomputing.net_vm.pdf)\n\nThe bot then enters the “real” main function.\n\n\n-----\n\nHere, APIs are resolved and strings are decrypted. String decryption is done in a slightly\npeculiar manner, rather than passing a string directly to the decryption function the pointer\nto the WORD before it is passed. The first WORD is then ignored, and the rest is decrypted.\nIn order to facilitate easy IDA reference searches, I opted to create a simple struct so that\nboth the call to decrypt and the reference to the strings are in one place.\n\nInterestingly, IDA did not detect the prototype of decrypt_str (and several other functions)\ncorrectly, and ignored the parameter passed in ECX. When the file was originally loaded,\nthe original prototype was “unsigned int __cdecl decrypt_str(int length)”. Changing it to “void\n__usercall decrypt_str(int length, strdec_header *encryptedStr)” is necessary for IDA to\ndecompile the function and calls to it successfully.\n\n\n-----\n\nI modified an IDAPython script for decrypting strings (a few strings will fail due to duplicates\n[or unicode, but the vast majority works fine). The script can be found on GitLab.](https://gitlab.com/krabsonsecurity/buer-loader-analysis/blob/master/stringdec.py)\n\nAPIs are resolved by hash. The hashing algorithm is the typical ror13 algorithm that is often\nused in shellcodes.\n\nAfter resolving the APIs and decrypting strings, the file checks to see whether it is operating\nin CIS countries. This is mandated as a part of the rule of the forum where the malware\noperates.\n\n\n-----\n\nAfter the check is passed, the file adds itself to startup using a peculiar method. It first\ngathers the command required to create a task that runs the bot every 2 minutes, and then\nadd that command to the RunOnce key.\n\n\n-----\n\nAfter this, it enters the main loop and attempts to ensure persistence. To prevent the file\nfrom being deleted (or opened), it performs an interesting technique of forcing open a\nhandle to the file inside the context of Explorer.exe. First, it gets a handle to explorer\nindirectly by first getting a handle with PROCESS_DUP_HANDLE privilege, and then using\nDuplicateHandle to create a handle with PROCESS_ALL_ACCESS. Thus far I have not\nseen this trick in malware but rather only in the cheating scene, perhaps indicative of the\nauthor’s involvement in such areas.\n\n\n-----\n\nAfter this, it creates a handle to it’s own file with dwSharing set to 0 (thus preventing any\nother process from accessing the file), and duplicates the handle into the explorer process.\n\nA rather unique choice of persistence that I have not observed before. Interestingly, it would\nappear that this effectively blocks Hybrid Analysis from reading the file (despite their\nanalysis operating primarily at ring 0), with reports not displaying the file icon. Possibly part\n\n\n-----\n\nof their analysis currently runs from usermode and as a result was blocked by this.\n\nAt this point in the analysis, I found out that ProofPoint published an analysis of the loader a\nfew hours before. As such, I’ll refer to their description of the HTTP requests and focus\ninstead on how commands are handled.\n\nThe command handling function is decompiled relatively unclean, due to it’s size and the\namount of switches and conditions IDA did not do a terrific job, however the decompilation\nserves it’s purposes. A few things of note:\n\nA lot of commands result in the process exiting, and as such SpawnInstanceOfSelf is\ncalled beforehand to create another instance of Buer before the command is\nexecuted. It is unclear why the loader could not perform the hollowing and continue\nexecution.\nmy_string_compare is equivalent to lstrcmpW and returns 0 if the string matches.\nStrings are duplicated a lot for unknown reasons.\n\n**Memload**\n\nMemload attempts a very basic process hollowing if the file successfully spawns another\ninstance of itself. API callchain: CreateProcessW->GetThreadContext>ZwUnmapViewOfSection (optional)->VirtualAllocEx->WriteProcessMemory>NtQueryIformationProcess->SetThreadContext->ResumeThread->CloseHandle>ExitProcess.\n\n\n-----\n\n**LoadDllMem**\n\n\n-----\n\nDepending on the option set and whether it is running under WoW64 or not, LoadDllMem\nwill either “inject” the DLL into itself (by using\nGetCurrentProcess/INVALID_HANDLE_VALUE as the handle) or repeat the trick of stealing\nexplorer’s handle from itself. The injection is fairly standard, if 64 bit is set it will use\nheaven’s gate and it will use the normal API otherwise.\n\nTo initialize the DLL, a bootstrap shellcode is injected and called. A structure with pointers\nto the DLL and function pointers are passed to it.\n\n\n-----\n\n**Update**\n\nThe update mechanism of Buer Loader is relatively simple, and there is not much to say\nabout it.\n\n\n-----\n\nIn conclusion, Buer is a new loader on the Russian malware scene and is relatively complex\n(especially when contrasted against certain bots such as Amadey). It still show\ninconsistencies that indicate a developer who is not experienced with low level development\nhowever, and it’s anti-analysis methods (such as API hashing or string encryption) are\neasily defeated with the use of IDAPython.\n\n## Comments ( 2 )\n\n1. Ftest95Posted on 9:34 am December 11, 2019\n\nHi, very nice writeup, but could you explain how GetHandleProcessStealth works?\nAfter getting handle to explorer why do we call duplicate handle? Wouldn't this call fail\nif explorer.exe doesn't already have handle to buer loader file ?\n\n_Mr. KrabsPosted on 11:33 am December 13, 2019_\nThe first handle does not have PROCESS_ALL_ACCESS, it only has\nPROCESS_DUP_HANDLE privilege. It probably is less likely to be seen as\nsuspicious than using OpenProcess directly with PROCESS_ALL_ACCESS.\nWith PROCESS_DUP_HANDLE, you can duplicate any handle that explorer\nhas, and since all processes have a pseudo-handle\n(INVALID_HANDLE_VALUE/0xffffffff/-1) which acts as a handle with all access\nto oneself, you can then duplicate that handle to get a full access handle to the\ntarget process. I am not so good at explaining this perhaps, so you can refer to\nMicrosoft here: \"A process that has some of the access rights noted here can\nuse them to gain other access rights. For example, if process A has a handle to\nprocess B with PROCESS_DUP_HANDLE access, it can duplicate the pseudo\nhandle for process B. This creates a handle that has maximum access to\nprocess B. For more information on pseudo handles, see GetCurrentProcess.\"\n(from https://docs.microsoft.com/en-us/windows/win32/procthread/processsecurity-and-access-rights)\n\nView Comments (2) ...\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-05 - Buer Loader, new Russian loader on the market with interesting persistence.pdf"
    ],
    "report_names": [
        "2019-12-05 - Buer Loader, new Russian loader on the market with interesting persistence.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536203,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1653710773,
    "ts_modification_date": 1653710773,
    "files": {
        "pdf": "https://archive.orkl.eu/552f745b95f2ac2110bd911bd512c44db210e4c0.pdf",
        "text": "https://archive.orkl.eu/552f745b95f2ac2110bd911bd512c44db210e4c0.txt",
        "img": "https://archive.orkl.eu/552f745b95f2ac2110bd911bd512c44db210e4c0.jpg"
    }
}