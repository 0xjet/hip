{
    "id": "3e161363-1dd8-4ed3-b427-58b484d0c544",
    "created_at": "2023-01-12T15:02:56.742351Z",
    "updated_at": "2025-03-27T02:06:14.343097Z",
    "deleted_at": null,
    "sha1_hash": "79a17fa7d4a267344989dd41b64229900bb341b5",
    "title": "2019-03-05 - Quick Analysis of a Trickbot Sample with NSA's Ghidra SRE Framework",
    "authors": "",
    "file_creation_date": "2022-05-28T17:43:14Z",
    "file_modification_date": "2022-05-28T17:43:14Z",
    "file_size": 690361,
    "plain_text": "# Quick Analysis of a Trickbot Sample with NSA's Ghidra SRE Framework\n\n**[peppermalware.com/2019/03/quick-analysis-of-trickbot-sample-with.html](http://www.peppermalware.com/2019/03/quick-analysis-of-trickbot-sample-with.html)**\n\nThis post is not a deep analysis of TrickBot. Here, I did a quick analysis of a TrickBot sample\nfrom early 2019 by using the Ghidra Software Reverse Engineering (SRE) Framework,\ndeveloped by the NSA, that was released some hours ago. This is not a deep analysis of\nTrickBot, I only wanted to learn a bit about Ghidra and I used this framework to find some\ninteresting parts of the code of TrickBot that were introduced in the newer versions of the\nmalware. Hope you enjoy it!\n\n## Starting with Ghidra Framework\n\nAbout Ghidra, when you start the framework, you should create a project and a workspace:\n\n\n-----\n\nThen, we can import files, for example PE files:\n\n## Ghidra CodeBrowser\n\nOnce PE file is imported, CodeBrowser can be launched:\n\n\n-----\n\nInitially, PE headers are parsed but code is not analyzed, the framework asks you if\nanalyzers should be launched, and what analyzers should be launched. This is the list of\nanalyzers (they are marked the analyzers that are marked by default):\n\nOnce analyzers finish, CodeBrowser interface is like this:\n\n\n-----\n\nCode is fully decompiled and while you browse each function, the decompiled code is\nshowed in the right window.\n\n## Browsing Code\n\nBrowsing code is similar to IDA, you can double-click a name to jump there (for example\ndouble-clicking the destination of a call <destination>, would take you to the destination\nfunction). You can move easily to the previous location with Alt+left (equivalent to Esc in IDA)\nand next location with Alt+right (equivalent to Ctrl+Enter in IDA).\n\nOther navigation options:\n\n\n-----\n\nYou can search for text, like IDA Alt+t, however (and I found this an interesting\ncharacteristic), you can select where do you want the text is going to be searched:\n\n\n-----\n\n## Find TrickBot Config Xor-layer Decryptor\n\nFor example, we can try to search for XOR instructions, and we get a list of matches:\n\n\n-----\n\nIn the analyzed sample (a trickbot from early 2019), if we look for XOR instructions, we can\nfind easily some XOR instructions modifying memory, and one of them belongs to the\nfunction that decrypts the XOR layer of the trickbot config:\n\n\n-----\n\n(Btw, as we can see in the image, when you select with the mouse a line in the disassembly\nwindow, the equivalent line is highlighted in the decompiled window).\n\n## Using references to find more interesting parts of the code\n\nOnce you have located an interesting point in the code, you can show a tree of calls to that\npoint:\n\nThe tree makes easy to follow the incoming or outgoing references to the interesting\nfunction:\n\n\n-----\n\nAdditionally, you could highlight (select) back or forward refs to an address in the\ndisassembly and decompiled windows.\n\n## TrickBot ECS signature and Config Xor Decryptor\n\nBy using the call trees, we can find easily the functions that decrypts the XOR layer of the\nelliptic curve signature or the XOR layer of the TrickBot Config:\n\nIn addition, you can open a function graph window, similar to IDA graphs. Here is the XOR\ndecryptor loop of TrickBot:\n\n\n-----\n\nYou can move easily on the graph, and zoom in/out with the mouse wheel:\n\n\n-----\n\n## TrickBot Strings Decryptor\n\nAbout strings.. All the strings used by the newer versions of TrickBot are encrypted. While\nIDA was able to construct a nice table of strings that makes easy to find the decryptor:\n\n\n-----\n\nGhidra were not able to identify all the strings and construct a nice table, it is much lesser\nintuitive:\n\nMaybe I missed something with Ghidra, but I selected the option Analysis->One shot->Ascii\nStrings, and these are the results. This makes difficult, for example, to find strings'\ndecryptors.\n\n\n-----\n\n## Conclussion\n\nin spite of the fact that I really love IDA (and WinDbg), I liked this framework, and I will\ncontinue using it.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-03-05 - Quick Analysis of a Trickbot Sample with NSA's Ghidra SRE Framework.pdf"
    ],
    "report_names": [
        "2019-03-05 - Quick Analysis of a Trickbot Sample with NSA's Ghidra SRE Framework.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535776,
    "ts_updated_at": 1743041174,
    "ts_creation_date": 1653759794,
    "ts_modification_date": 1653759794,
    "files": {
        "pdf": "https://archive.orkl.eu/79a17fa7d4a267344989dd41b64229900bb341b5.pdf",
        "text": "https://archive.orkl.eu/79a17fa7d4a267344989dd41b64229900bb341b5.txt",
        "img": "https://archive.orkl.eu/79a17fa7d4a267344989dd41b64229900bb341b5.jpg"
    }
}