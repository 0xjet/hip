{
    "id": "16aa6a56-c489-4ebc-aebd-5a8a1d184d3c",
    "created_at": "2023-01-12T15:08:20.834979Z",
    "updated_at": "2025-03-27T02:16:26.564413Z",
    "deleted_at": null,
    "sha1_hash": "1413cd06dad8334e2c6d4e8e86689d9a37e43d04",
    "title": "2016-01-29 - VB2015 paper- It's A File Infector... It’s Ransomware... It's Virlock",
    "authors": "",
    "file_creation_date": "2022-11-28T19:06:23Z",
    "file_modification_date": "2022-11-28T19:06:23Z",
    "file_size": 5219587,
    "plain_text": "# VB2015 paper: It's A File Infector... It’s Ransomware... It's Virlock\n\n**[virusbulletin.com/virusbulletin/2016/12/vb2015-paper-its-file-infector-its-ransomware-its-virlock/](https://www.virusbulletin.com/virusbulletin/2016/12/vb2015-paper-its-file-infector-its-ransomware-its-virlock/)**\n\n### Vlad Craciun, Andrei Nacu & Mihail Andronic\n\nBitdefender, Romania\n\n_Copyright © 2015 Virus Bulletin_\n\nTable of contents\n\nAbstract\n\nIntroduction\n\n1. Ransomware and file infector evolution\n\n1.1 Old file infectors, behaviour and purpose\n\nPurpose:\n\nBehaviour:\n\n1.2 Old screen-lockers: behaviour and purpose\n\nPurpose:\n\nBehaviour:\n\n2. Analysing Virlock, Refining Behaviour, Combining Purpose\n\n2.1 Analysing Virlock – refining behaviour\n\n2.1.1 Not embedding malware code, but embedding a clean file\n\n2.1.2 Anti-analysing techniques\n\n2.1.2.1 Code obfuscation\n\n2.1.2.2 Anti-debugger\n\nMulti-staged unpack\n\nStaged unpack\n\nChecking for the presence of a debugger\n\nRooting inside the execution environment\n\n2.1.2.3 Anti-emulation\n\nRandomly chosen API calls\n\nIncreasing the number of executed instructions\n\n2.1.3 Cheating users\n\n2.1.4 Polymorphic engine\n\n2.2 Analysing Virlock – Combining purpose\n2.2.1 File infector and screen-locker\n3. Getting to the Core of Virlock\n\n3.1 Revealing the core, inside different malware versions\n\n\n-----\n\n3.2 Searching for a match\n3.3 Cleaning infected files\n\n4. Statistics\n\n5. Conclusions\n\nAcknowledgements\n\n## Abstract\n\nWin32.Virlock, with all its variations, is both a new kind of file infector and a piece of\nransomware (screen-locker) at the same time. In this paper, we aim to cover the techniques\nused by this virus and discuss methods that can be used to detect and disinfect systems\naffected by it.\n\nVirlock uses several techniques, including code obfuscation, staged unpacking, random API\ncalls and large/redundant areas of decrypted code, to make it difficult to analyse. It also\nprotects its code by decrypting only the sequences that are going to be executed. After a\nsequence of code is executed, Virlock encrypts it again. By staggering the\ndecryption/encryption process, it ensures that a memory dump at a certain point will not\nreveal its features but only the piece of code that is being executed at that time.\n\nThere is also a moment in its first execution when it shifts its shape by changing certain\ninstructions and encryption keys so that new generations will look different. Each new\ninfection is different from any other, mostly because of the timestamps that play an important\nrole in computing the encryption keys. Having these protection methods will also make any\nclean-up attempt quite a challenge. The disinfection process for this virus involves searching\ninside malware code for specific instruction arrangements.\n\nWe will present some ideas that could help in detecting and disinfecting a Virlock-infected\nsystem.\n\n## Introduction\n\nMalware has grown significantly in the last decade, both in prevalence and complexity. It has\ndeveloped from innocent bad jokes and simple trojans to advanced polymorphic file\ninfectors, rootkits and ransomware. While security companies have studied all the types of\nmalware and built specific categories for them, it can be difficult, today, to categorize a\nmalicious application as a trojan, a piece of spyware, or even a file infector, as they tend to\nbe more complex and to embed several different kinds of behaviour at once.\n\nSecurity vendors have been forced to develop different kinds of engines to reach faster\nconclusions in malware analysis, be it static or dynamic, but security products by definition\nare usually a step behind the malware creators, even if we try to minimize that time-interval.\nThe security industry had tried to figure out better solutions and better engines to prevent\n\n\n-----\n\nmalware execution in advance by using artificial intelligence, but no matter how hard we try,\nor how much time we invest in research, there is always something new which doesn’t get\ncaught. There are many cases in which we reach the conclusion that an engine is not doing\nthe best to protect against a new piece of malware, or that making a small improvement will\nslow down the entire product. In some cases we reach the conclusion that a particular\ndetection method is simply not adequate for a specific piece of malware.\n\n## 1. Ransomware and file infector evolution\n\n### 1.1 Old file infectors, behaviour and purpose\n\nKnown categories: appenders, prependers, EPO, polymorphic, interleaved.\n\n**Purpose:**\n\nThe first file infectors were just bad jokes or proofs of concept. The earlier ones interleaved\nmalicious code with original application code or prepended malware code to a clean\napplication. By prepending the malicous code to a clean application, the authors increased\nthe time needed for analysis, and also gained time for their malware to spread while users\nwere searching for solutions. This is also a safe way to expose users’ computers to hackers;\nfile infectors act like agents, collecting confidential user data, or continuously delivering other\nkinds of malware to the infected system.\n\n**Behaviour:**\n\nMalicious code is executed first, infecting the system or ensuring it is running within another\nprocess or thread and eventually deploying any missing files, then it executes the original\napplication. When a portion of the clean application is executed, the malware will also be\nexecuted at some point, this being triggered by a patched API import or by malicious code\ninsertion. After the malicious code has finished running, the clean application’s code\ncontinues to be executed from where it was left off.\n\n\n-----\n\nFigure 1: Example of a common file infector (appended code to clean application).\n\n### 1.2 Old screen-lockers: behaviour and purpose\n\n**Purpose:**\n\nAn easy way to get money from users by blocking access to their working environment.\n(Childish play for grownups!!!)\n\n**Behaviour:**\n\nThis kind of malware creates an additional desktop and switches to the new environment,\njust as if another user had logged on. Some of them may encrypt user files, but most of them\ndon’t. The ones that do encrypt user files, like some CryptoLockers, do not lock the user’s\nscreen, because the damage is already at a stage where the user might wonder where the\nbackup is, or whether a decryption tool is worth paying for.\n\n\n-----\n\nFigure\n\n\n2: Ransomware blocking user screen and requesting payment.\n\n\n-----\n\nFigure 3: RSA1024 CryptoLocker displaying message to user.\n\nLet us mention some of the well known pieces of ransomware among both families:\n\nACCDFISA, PornoBlocker, Rannoh, IcePol, CryptoWall, CoinVault.\n\nIn the following chapters we will uncover the main features and components of Virlock;\nhowever we are not going to focus on the infection process. This type of malware has the\nvaccine within itself, but only applies it for each infected file at runtime. We will focus mainly\non its design and its abilities to sneak past some security solutions.\n\n## 2. Analysing Virlock, Refining Behaviour, Combining Purpose\n\nVirlock combines the technology of file infection with the screen-locking features of regular\nscreen-lockers. The authors embed both infection and disinfection tools, throwing away the\nmanagement system to bind infected users to some private decryption keys. Their remaining\nconcern is about users who are willing to pay their fee rated in bitcoins.\n\nThe screen-locking picture is very similar to that of those pieces of ransomware that pretend\nto be some higher authority with full rights to request certain amounts of money from homeusers – for example as fines (see Figure 4). Most texts appearing on the locked screen are\n\n\n-----\n\ntrying to scare the users, for example threatening them with prison for up to five years or\nmore if they do not pay the money.\n\nFigure 4: Virlock screen lock.\n\n### 2.1 Analysing Virlock – refining behaviour\n\nVirlock is changing the way in which the infection process takes place:\n\nIt has an ingenious polymorphic engine (most file infectors don’t come with such an\nengine), making the detection process more difficult with each infected system.\nIt doesn’t just insert a piece of code into the clean application as most file infectors do,\nbut the entire clean application becomes a small piece of the malware itself (similar to\nMorto/Sality/ACCDFISA).\nIt uses techniques to cheat users at first glance (seen in a few other pieces of\nmalware), to bypass users’ doubts that an infected file is really malicious.\nIt has a lot of features (not new, but different) that make the reverse-engineering\nprocess more difficult, overload the analysts and annoy them.\nIt has screen-locking (borrowed from screen-lockers) to increase the time taken to get\nto an infected sample – most home-users prefer to reinstall their operating system\nrather than trying to remove the malware.\n\n\n-----\n\nIt uses multi-threading and rooting into the environment to get full control over the\ninfected systems without the need for drivers, and to execute different paths inside the\nsame application, but from different points of view (running\nprocesses/services/threads).\n\n**2.1.1 Not embedding malware code, but embedding a clean file**\n\nThe infection process is somewhat different from the infection process of other known file\ninfectors. However, there are small similarities between Virlock and both the Sality file\ninfector and the ACCDFISA ransomware:\n\nVirlock and Sality: both replace the clean application with the malware which contains\nthe original application packed or modified.\nVirlock and ACCDFISA: ACCDFISA uses the RAR archiver to make all the infections\nself-extractable – this is very similar to Virlock’s behaviour but with the small difference\nthat Virlock uses its own techniques to accomplish the same behaviour.\n\n**2.1.2 Anti-analysing techniques**\n\nAt the moment we know about five different Virlock versions. They’re not too different but\nthey do differ in such a way that some simple checks will not catch them all.\n\n2.1.2.1 Code obfuscation\n\nOne of the main techniques used to harden the reverse engineering and analysis process is\nobfuscation.\n\nObfuscation is present in all five versions and is similar between some and different between\nothers. However, while obfuscation may contribute to detection, it is not a key-point in doing\nthat.\n\nFigure 5 shows some screenshots of obfuscated code from four different versions.\n\nFigure 5: Obfuscated code inside four different Virlock versions.\n\n\n-----\n\nIf we are going to trace the entropy of those pieces of code, or count the number of some\ntarget instructions which repeat excessively, we can create some checkpoint conditions that\nVirlock infections will not pass. Code can be obfuscated in lots of configurations, but some of\nthem are built based on some basic principles. It is not too difficult to observe the criteria with\nwhich an obfuscation engine was built.\n\nWe could also de-obfuscate some instruction blocks by following the true aim of an\nobfuscated piece of code. However, de-obfuscation becomes irrelevant when one can look at\nthe execution traces. They are still a plus when building documents to reveal the true\nmeaning of some code.\n\nObfuscation also contributes to making the static analysis procedure more difficult.\n\n2.1.2.2 Anti-debugger\n\nThere are lots of anti-debugger techniques, and usually, malware creators combine those\nfeatures with techniques to detect virtual machines, emulators or supervisor tools like PIN\nfrom Intel (which allows one to instrument an executed application), or API loggers which\ninject tracing modules or pieces of code into a target process.\n\nVirlock does not combine all of these, but it uses the strongest of them all, in order to bring\nthe analyst to a point where he/she could easily give up.\n\nMulti-staged unpack\n\nThis is a known technique for making the reverse engineering procedures harder, for both\nstatic and dynamic analysis. If a piece of code is unpacked piece by piece, one at a time,\nwhile it is executed, then performing a static analysis could be very difficult. Following the\nmodifications inside a debugger might also be tricky, as some debuggers simply refuse to\ndisassemble the code at the point where they think that there is no code in the first place. If\nwe add to that the fact that code might re-encrypt the previously executed code, then things\nget really interesting.\n\n\n-----\n\nFigure 6: Short example of execution flow, following the chunk encryption/decryption\ntemplate.\n\nStaged unpack\n\nStaged unpack is a feature which minimizes the ‘area’ of ‘plain-text’ code at any time. There\nis a piece of code, more like a template, which repeats itself along the execution of the\nmalware, and at each step:\n\nIt hashes the buffer to be unpacked\nIt decrypts the next piece of code, only if the hashes match\nIt executes the code inside the decrypted chunk (possible more function-templates)\nIt rehashes the unpacked code and alters the hash, inside the code\nIt re-encrypts the previously decrypted code.\n\nThe template follows the data structure of a linear linked list, where each node is itself a\nlinear linked list of many possible function calls. We are seeing linked lists inside linked lists\nmainly because each function call inside such a code-chunk calls another unpack-executerepack template.\n\nFigure 7 shows the code template for the mentioned trick inside a particular infection, which\nstarts by checking the integrity of the packed chunk-code at 40193F, decrypts the buffer at\n4019C0, jumps to unpacked code at 401A7E, and finally rebuilds the HASH for the unpacked\ncode which it overwrites at the beginning of the code template and re-encrypts the entire\ncode starting at 401A7E.\n\n\n-----\n\nFigure 7: Template-code for staged unpack (yellow square -> unpacked code).\n\nIf someone is trying to make some process-dumps to have a look at the code inside the\nmalware while it’s executing, they might be surprised to find that the malware is almost fully\npacked, just as it was in the first place. The surprise gets bigger, as one is thinking that the\nmalware might have some running threads which did not get dumped at the time of the\nprocess dump and while trying to grab all the memory pieces, one will obtain nothing more\nthan the first process dump.\n\nChecking for the presence of a debugger\n\nEvery infected sample checks for the presence of a debugger at some point. There is a\nstandard way to do that, which is by querying a flag inside PEB, called isDebuggerPresent at\n\n[fs:[30h]+2], bit 0 (see Figure 8).\n\nFigure\n\n8: Anti-debugger checking inside PEB.\n\nIn our example, if it’s being debugged, the code jumps to 0x495A2D . If we are taking a\ncloser look we can see in Figure 9 that the code is being executed in those conditions.\n\n\n-----\n\nFigure\n\n9: Code executed when debugger is found.\n\nEventually we find a piece of code looping on itself and calling Sleep.\n\nMost of the time, we can trick the application by changing the condition flags; and thus the\ncondition itself or the value being compared. However, the time spent getting one’s hands on\nthat piece of code is sometimes too much to continue with the dynamic analysis that way.\n\nRooting inside the execution environment\n\nWe mentioned earlier that the malware does not use all known methods to harden the\nanalysis procedure, but it uses the strongest of all methods gathered together to at least\ndiscourage analysts or to create problems for automated tools.\n\nThe technique described in this section does not refer to a behaviour that rootkits are using,\nbut rather to a behaviour which spreads the infection inside the infected system, making selfcopies and additional processes or services, each of them with a couple of threads. If the\nmalware gets to execute inside such a configuration, then the synchronization policies\nbetween processes and threads will enable it to do its main job, otherwise one will not get\nanything useful from it.\n\nAt the beginning of the execution, an infected sample will first create two copies (of the\noriginal infection core – morphed) inside hidden folders with random names but constant\nlength (eight characters), one located in %AllUsersProfile% and one inside %UserProfile%:\n\n[%UserProfile%\\[a-zA-Z]{8}\\[a-zA-Z]{8}.exe]\n\n[%AllUsersProfile%\\[a-zA-Z]{8}\\[a-zA-Z]{8}.exe]\n\nThe copy located in the %UserProfile% folder is executed first using CreateProcess and it is\nalso set as a starting point inside the startup key:\n\n\n-----\n\n[HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run].\n\nSecond and (in some cases) third copies are written in the %AllUserProfile% folder inside\ndifferent subfolders. One of them is executed like the first copy in order to work together with\nit (one of the copies ensures that the other is not killed, and if that happens then it just\nrecreates it), and the other is created as a service to supervise some tasks and gain\nprivileged access to operating system components.\n\nIt is important at that point to note that the malware copies are not only different from the first\none (using a polymorphic packer), but also have some key-flags changed. The changing of\nflags will enable, for example, one of the copies to execute a slightly different path inside the\nmalware just like a switch-case block. For example, the malware self-disinfects the file inside\nit, only if a certain flag located at a hard-coded address says that this can be done.\n\nA series of batch-files and VBS scripts are written on the disk temporarily to help the\nmalware infect files by first making a backup and then overwriting the target file. Scripts are\nalso used to change security policies inside the registry, in order to hide the malware or to\ndisable default security features.\n\nThe following is a list of commands altering registry entries:\n\nreg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced /f /v\nHideFileExt /t REG_DWORD /d 1\n\nreg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced /f /v Hidden\n/t REG_DWORD /d 2\n\nreg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v\nEnableLUA /d 0 /t REG_DWORD /f\n\nStraight after the installation, the malware tries to brute-force the user logon account\npassword with at least a few thousand common password templates, and straight after that\ncreates a new user with a random name and full administrator rights.\n\nFigure\n\n10: New account created by Virlock after successfully brute-forcing the administrator\npassword.\n\n\n-----\n\nThe following are just a few examples of passwords that had been tried by the malware:\n\npassword, [[email protected], 1234, Password1, 123456, admin, 12345, Passw0rd,](https://www.virusbulletin.com/cdn-cgi/l/email-protection)\n\n[[email protected], Pa$$w0rd, !QAZ2wsx, test, sunshine,](https://www.virusbulletin.com/cdn-cgi/l/email-protection) [[email protected],](https://www.virusbulletin.com/cdn-cgi/l/email-protection) [[email protected],](https://www.virusbulletin.com/cdn-cgi/l/email-protection)\n123456789, 12345678, abc123, qwerty, letmein, changeme, master, Password!, passw0rd,\n1q2w3e4r, Password01, password1, hunter, qazwsx, welcome, Welcome123, secret,\norig_Administrator, princess, dragon, pussy, baseball, football, monkey, 696969,\n[operator123, N0th1n9, [email protected], 1q2w3e4r5t6y7u8i, abcd12345, 7654321,](https://www.virusbulletin.com/cdn-cgi/l/email-protection)\nAdministrator, q1w2e3r4, q1w2e3r4t5.\n\nA process created with the following command line will discard any possible API-tracer or\ndebugger following the process execution. However, we can still trick such behaviours by\naltering the code at the entry-point and forcing a debugger to enter first, modifying the\nparameters for CreateProcess, or using some advanced environment emulators:\n```\nCreateProcessW(\"%TEMP%\\AccMwMEs.bat\", \" \"%TEMP%\\AccMwMEs.bat\"\n\"C:\\samples\\virlock.exe\" \", …………)\n[AccMwMEs.bat]\necho WScript.Sleep(50)>%TEMP%/file.vbs\ncscript %TEMP%/file.vbs\ndel /F /Q file.js\ndel /F /Q %1\ndel /F /Q %0\n\n```\nWhen an infected sample gets to execute on a clean system, we say that the sample is the\noriginal one which is the primary cause of the infection. This sample is almost like any other\nfresh infected sample, which was not executed after the infection. There are some flags\nhard-coded into the malware so that it knows, at runtime, whether the sample being\nexecuted is a fresh infection that has not been executed before, or a drop made by malware\ntargeted as a service or a malicious process running on the user’s system. Figures 11 and 12\nillustrate that behaviour.\n\n\nHard-coded\nvalue\n\n\nMeaning\n\n\n0 Installed malware process, usually two synchronized processes\n\n1 Original sample, installs malware components\n\n2 Intermediate actions (while rooting into environment), brute-force user\naccount password\n\n3 Multithreading and synchronization (screen-locking, online payment)\n\n4 Sample is running as service\n\nTable 1: Associations between hard-coded values and their meaning.\n\n\n-----\n\nFigure 11: First context switching actions.\n\nFigure 12: Last context switching actions.\n\n2.1.2.3 Anti-emulation\n\n\n-----\n\nMost malware creators integrate into their applications techniques to escape emulation\nand/or virtual machines. There are a number of known methods to accomplish that, we won’t\ndiscuss all of them, but mainly those used by Virlock.\n\nAmong all the techniques which can cause emulators not to work, there are time constraints\nand unimplemented emulated API calls. Some emulators which are at the beginning, might\nhave problems overcoming both of these, others might give up over time constraints (mainly\nbecause authors consider this a performance hit), and other advanced emulators could solve\nall of these in more efficient ways. However, most emulators are somewhere in the middle\nmost of the time. We have to consider the possibility that from time to time malware creators\nreverse our engines and create malware which might target some of these security engines.\nIf that is the case, then no matter how strongly an emulator is built, it might become useless\nif it’s being targeted by malware.\n\nRandomly chosen API calls\n\nIn an attempt to morph itself, Virlock rebuilds itself inside each infection, decorating the core\nof functionalities with things like random API calls from randomly chosen modules. The\nmalware uses some tables, meaning that it does not choose from a huge set of possibilities\nbut from a finite set. It chooses a random number of libraries which the future infection will\nimport, and from those libraries, some random APIs inside each of them are chosen as\nimports.\n\nIf emulators are only emulating a certain set of APIs, then that might impede their ability to\ncontinue at the point of an unknown API call, or an API call not implemented accordingly\n(Figure 13).\n\nFigure 13: Consecutive blocks of random API calls, trying to escape emulators from the\nbeginning.\n\nIncreasing the number of executed instructions\n\nMost malware, be it packed or unpacked, does not require more than a few million\ninstructions to be executed. At that point there are optimizations such as binary translation,\nwhich tries to improve performance over emulated loops like decryption blocks which get to\n\n\n-----\n\nbe executed by the real processor and not by the emulator. Binary translation is sometimes\ncombined with file-read operations – the best emulators will try to reduce the number of read\noperations and at the same time the maximum number of instructions allowed to be\nexecuted.\n\nAll versions of Virlock have a first stage decryption. Without it, any further code execution is\nbasically impossible. There is currently no version that executes fewer than 60M instructions\nfor that purpose, and the number of instructions increases for bigger files and larger\nobfuscated loops, to hundreds of millions of instructions. Some infections also spread the\nobfuscated loops over a large area of the infected file, thus passing to emulators the pain of\nconsecutive file reads, which also is a hit for performance.\n\nThere are many cases where the binary translation for loops is almost impossible if we are\nnot first going to de-obfuscate the code being executed by the loop. Figure 14 shows such a\ncase where just three calls to load more than 180 APIs from different modules is taking at\nleast 500k instructions.\n\nFigure\n\n14: Loading some APIs (calling is based on templates discussed in 2.1.2.2).\n\n**2.1.3 Cheating users**\n\nVery rarely seen in other pieces of malware of this kind (which embed the clean file into a\ntotally different file), Virlock tries to cheat users into thinking that an infected file is actually\nwhat its icon claims it to be. There is a stage in the infection process where the malware\nsearches inside the registry for the application associated with an extension type, in order to\nget to the file containing the icon of the associated application. This is a primary step for\ngrabbing the icon and embedding it into the final infected file as an icon-resource. At a first\nglance, there is no difference between the original file and the infected one.\n\nStraight after the infection, the malware will set a registry setting to hide extensions for\nknown filenames. That way users will see their original files with their relevant icons and no\nEXE extension, so no one will ever doubt the actions of the file.\n\n\n-----\n\nFigure 15: Infected files with extensions revealed.\n\n**2.1.4 Polymorphic engine**\n\nThe thing that makes Virlock so special is that it has a polymorphic engine which mutates its\nshape in future infections. In this section we reveal the techniques used by the malware to\naccomplish this task.\n\nStraight after the API-loading process, the malware allocates two buffers (one of them big\nenough to hold the core of the malware) to prepare the morphing process for the infections to\ncome. The core of the malware is somewhere inside the infected application, but only visible\nafter a few stages of successive decryption procedures. Figure 16 shows the schematics of\nthe core, which resides packed, layered inside any infected file.\n\n\n-----\n\nFigure 16:\n\nVirlock core with embedded clean application.\n\nA polymorphic engine is located in our example at 0x45E636 and it is called several times\nduring the installation of the malware into the newly infected system. Each new malware\ncopy will also have modified the flags discussed previously, accordingly.\n\nFigure 17:\n\nCode calling the polymorphic engine.\n\n\n-----\n\nThe process of shape-changing is accomplished in two steps, for each of the two dropped\nfiles which are going to do the real infection. Figure 18 shows the preparation for the\nreshaping of a self-copy.\n\nFigure 18: Preparing the reshape of a self-copy.\n\nThe first stage consists of preparing random file names, some random seeds, and the buffers\ninvolved in the morphing procedure (see Table 2).\n\nBuffer alias Buffer size Buffer ptr Description\n\nTAB1 0x200 0x970000 Randomization table 1\n\nTAB2 0x2300000 0x1100000 Working buffer for reshaping procedure\n\nTAB3 0x10000 0x9A0000 Intermediate table 1\n\nTAB4 0x10000 0xAA0000 Intermediate table 2\n\nTAB5 0x200 0x980000 Randomization table 2\n\nTable 2: Buffers involved in the morphing procedure.\n\nWe also see at this step the creation of two different MZPE file headers, originally packed\ninside the malware (see Figure 19). Their purpose is to fulfil the creation of the processes\nwhich will actually carry out the infection.\n\n\n-----\n\nFigure 19: Preparing headers for the files to be constructed.\n\nIn the beginning of the second stage, the malware creates a custom import table, also based\non time seeds (see Figure 20). The RDTSC instruction, which provides those time-seeds, is\ncalled very frequently, not only to randomize stuff, but also for choosing random locations in\nthe target application, where relevant data regarding decryption keys, buffer pointers, etc.,\nwill be placed.\n\nFigure\n\n20: Building a customized import table.\n\nIn Figure 21, we can see a sequence of instructions which progressively builds the\ndecoration of the new infection.\n\n\n-----\n\nFigure 21: Reshaping a new infection.\n\nAll the steps required for a full file creations are called in a sequence of three consecutive\ncalls, as shown in Figure 22 {reshape / append / recrypt}.\n\nFigure 22: Main reshape steps for self-copies.\n\n### 2.2 Analysing Virlock – Combining purpose\n\nWe have seen lots of malware categories that combine their powers with other malware\ncategories. The results of those combinations have, most of the time, been some kind of\nsurprise for security products. Not only do malware authors learn from security products how\nto improve their performance, but we also learn from malware authors that there is always\nsomething which we have not taken into account in the first place. This sounds like an\n\n\n-----\n\nevolving loop, where security products try to nullify malware actions, while on the other hand\nmalware authors try to nullify security products’ actions. Well, at least the loop is more like a\nthree-dimensional spiral, otherwise we would not exist at this moment in time.\n\nThe following is a brief history of combined malware actions including Virlock, which we find\nas a reference for this case:\n\nViking / Jadtre – rootkit and file infector\nCBDoorK – rootkit and backdoor\nSality – file infector, botnet, worm\nVirlock – ransomware, file infector.\n\n**2.2.1 File infector and screen-locker**\n\nUntil Virlock, no other malware combined these features. Malware authors who write\nransomware are doing it for the money – they say as much in their readme files appearing on\nthe infected computers. For example, a piece of ransomware using the Bitlocker feature from\n_Windows tells the infected users that ‘This is just how business works, pay and you’ll get_\nyour data back.’\n\nEarly versions of ransomware only locked users’ accounts, hoping that some of them would\nfall into their trap – and they succeeded, but there is always room for improvement. Some of\nthe next versions tried to encrypt users’ files with symmetric keys and locked the users’\naccounts, making it more difficult to revert the process. But as the security products improved\ntheir strategies and delivered rescue-CDs to users, malware authors improved their methods\nof cryptography, using asymmetric algorithms, and gave up the screen-locking. When\ninfecting users with those kinds of ransomware, malware creators need a management\nsystem in order to bind private-keys with malware versions. Maybe they did not expect their\nmethods to be so fruitful, but they seem to be overwhelmed by the number of infected users\nand public/private keys. It is not unusual for a user to try to pay, and get a decryptor which\nattempts to decrypt files from a different infection.\n\nVirlock tries somehow to escape the load produced by the key-infection management system\nwhile improving the old techniques used in locking files and user accounts by embedding the\nclean file and packing it safe inside the malware with random and hard-coded keys. It also\ntries to crack users’ account passwords, to lock their account in order to make it as difficult\nas possible for the users to recover their files. Using the presented technique for file\ninfection, security products have to consider an entire arsenal of variables in order to begin a\nclean method, because it would be very easy to miss a certain hard-coded-key and to\ndamage the file instead of recovering it.\n\n## 3. Getting to the Core of Virlock\n\n\n-----\n\nWe ve seen so far that Virlock uses a template-based reshape, so we can use that template\nas some kind of regular expression to find some inner pylons / code-blocks to start with.\nStudying the five different versions until now, there are certain similarities between them,\nwhich will lead us to classify a sample as infected.\n\nIn this chapter we will try to reveal the malware’s weak points and see how those\nweaknesses may contribute to studying it better in all its present forms.\n\n### 3.1 Revealing the core, inside different malware versions\n\nFirst, there is an initial layer of decryption which will end up by continuing the execution\nsomewhere at FirstSectionVA+0x400 or FirstSEctionVA+0x1000 with or without additional\nobfuscated code and possibly a short second decryption stage (Figure 23).\n\nFigure 23: First chunk of relevant code in all five versions.\n\nThere are two major switch sections inside the malware which choose a path of execution\ndepending on the hard-coded flag discussed in section 2.1.2.2. We will consider the two\nsections as the core of the malware, as they are present inside all versions, no matter how\nobfuscated the code is, and the path to those functionalities is unique if an emulator behaves\njust like a real operating system.\n\nNot all versions are as compact, as shown in Figure 24. There are some cases where junkcode might appear between relevant instructions in our target code, but ignoring them is not\nas difficult as one may think.\n\n\n-----\n\nFigure 24: A comparison between all five versions inside context-switch sections.\n\n### 3.2 Searching for a match\n\nMost detection algorithms will just try to find a relevant piece of code inside a piece of\nmalware. Looking at the code shown in Figure 25, we might be tempted to say that we found\nsomething relevant for our malware (a branching point where it chooses to execute as\ninstalled or as a fresh infection). However, in other malware versions we found other such\npieces of code, doing the same thing but with modified instructions. Considering this, the\ndetection cannot choose that sequence of instructions to follow, but we need some rules\ndepending mostly on the constant addresses given in the piece of code and the instruction\ntypes, which are not so different across different malware versions. This kind of matching\nseems to be as powerful as a regular expression-matching algorithm, but additional changes\nhave to be considered.\n\nFigure 25: Piece of malware code to decrypt clean file.\n\n\n-----\n\n### 3.3 Cleaning infected files\n\nTo recover the clean file from the malware, we need to follow the code until a point at which\nwe can check whether the infection contains a clean file (switch-flag == 1) or not (switch-flag\n!= 1). If we do have a clean file, we need to grab the hard-coded values inside the malware\n(different with each infected file) and to force the emulation of decryption functions.\n\nA simple clean procedure is to use the emulation to execute the decryption function. After\nthat, we can grab from memory, using the specified variables, the actual clean file. The\nstarting point of a particular clean file inside the malware is shown in Figure 26.\n\nFigure 26: Finding clean file using hard-coded variables.\n\n## 4. Statistics\n\nFigure 27 shows a graphic for the timeline of Win32.Virlock.Gen.1, which is the most\nwidespread version at the moment.\n\nFigure 27: Infection timeline for Win32.Virlock.Gen.1.\n\n\n-----\n\nIn Figure 28, we see how many systems have been infected since March 2015 for the three\nmost common detections. Almost 39,700 unique files were detected by Bitdefender on 148\nsystems in less than five months. The highest number of infections were detected in Canada\n– almost 30,000, representing 75% of all infections. We expect a small increase in the next\nfew months as the authors of the malware seem to still be working on it, and a total decrease\nby the middle of next year, by which time many security products will have solutions for it.\n\nFigure 28: Left: Win32.Virlock.Gen.1, Top-right: Win32.Virlock.Gen.3, Bottom-right:\nWin32.Virlock.Gen.4.\n\n## 5. Conclusions\n\nIt seems that malware creators are constantly learning from their mistakes and they always\nfind new ways to bypass security products, be it with a small improvement such that their\nsample will not be detected for a few days, combining technologies that could force certain\nsecurity products to redesign their engines (due to performance-hits) in order to come up\nwith a feature to successfully detect and clean the malicious application, or forcing security\ncompanies to search for better solutions or to give-up by not being able to keep up with\ndamages done by specific malware infections.\n\nVirlock is among the few malware applications which combines different technologies to\nharden the reverse engineering process and at the same time to make the creators of\nsecurity products question their technologies. The redesign process of certain engines is not\nalways an easy step, and most of the time this is not a solution. For example, to add some\nfeatures to emulators, in order to execute unimplemented APIs, to track a certain sequence\nof generic assembly instructions, or to increase the complexity of search algorithms near to\nthe complexity of strstr(), might result in performance hits which will impact the overall\n\n\n-----\n\nfunctionalities of the security product. Some designers being inspired in the first place might\nlaugh at the idea that an improvement could be made as a next step inside an already\nevolved tool, but that is not always the case.\n\nWith the advance of malware technologies in the last few years, we find it even harder to\nrevert malware, or to revert the infection process and to restore the system to a clean state.\nRansomware using asymmetric encryption algorithms is constantly destroying user-data\nrequiring money to get data back. More than ever, we need methods to automate dynamic\nanalysis and at the same time to extract relevant features from different infections along with\nimproving the prevention techniques. Model-checking and symbolic simulation may be a\nsolution from that point of view, and maybe combining that with time-line analysis and control\nof a running operating system environment, we might prevent, learn and successfully revert\nmuch more complex infections.\n\nThere is also a small chance that by using classifiers to extract common vector-features from\ntraces obtained from emulation of such malware, and then dynamically observing the\nmodifications which take place during the infection, one could generate the detection process\n(which resumes to a search problem in the space of files to be scanned), along with the\ndisinfection process, in just one click.\n\n## Acknowledgements\n\nThis work was co-funded by the European Social Fund through Sectoral Operational\nProgramme Human Resources Development 2007 – 2013, project number\nPOSDRU/187/1.5/S/155397, project title ‘Towards a New Generation of Elite Researchers\nthrough Doctoral Scolarships.’\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\n\n-----\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-01-29 - VB2015 paper- It's A File Infector... It’s Ransomware... It's Virlock.pdf"
    ],
    "report_names": [
        "2016-01-29 - VB2015 paper- It's A File Infector... It’s Ransomware... It's Virlock.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536100,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1669662383,
    "ts_modification_date": 1669662383,
    "files": {
        "pdf": "https://archive.orkl.eu/1413cd06dad8334e2c6d4e8e86689d9a37e43d04.pdf",
        "text": "https://archive.orkl.eu/1413cd06dad8334e2c6d4e8e86689d9a37e43d04.txt",
        "img": "https://archive.orkl.eu/1413cd06dad8334e2c6d4e8e86689d9a37e43d04.jpg"
    }
}