{
    "id": "38ed92e0-8f7a-4cbc-8bd5-307995b20229",
    "created_at": "2023-01-12T15:02:43.825084Z",
    "updated_at": "2025-03-27T02:15:41.743073Z",
    "deleted_at": null,
    "sha1_hash": "3c11fd4ba17376de4c0c80bcdc590b77a06b4ff0",
    "title": "2020-06-11 - The Return of the Higaisa APT",
    "authors": "",
    "file_creation_date": "2022-05-28T19:34:49Z",
    "file_modification_date": "2022-05-28T19:34:49Z",
    "file_size": 5785939,
    "plain_text": "# The Return of the Higaisa APT\n\n**zscaler.com/blogs/research/return-higaisa-apt**\n\nCybercriminals will often use LNK files attached in an email to launch an attack on\nunsuspecting victims. And we recently noticed another campaign using this technique.\n\nIn May 2020, we observed several LNK files in the wild, which we attribute to the same\nthreat actor based on the code overlap, similar tactics, techniques and procedures (TTPs)\nand similar backdoor. For those who are unfamiliar, an LNK file is a shortcut or \"link\" used\nby Windows as a reference to an original file, folder, or application similar to an alias on the\nMacintosh platform.\n\nThe final backdoor, to the best of our knowledge, has not been documented before in the\n[public domain. Recently, Malwarebytes published a blog about this attack, but the details of](https://blog.malwarebytes.com/threat-analysis/2020/06/higaisa/)\nthe backdoor were not mentioned in that blog. This backdoor uses sophisticated and\ndeceptive techniques, such as FakeTLS-based network communication over a duplicated\nsocket handle and a complex cryptographic key derivation routine.\n\nWe attribute this attack (with a moderate confidence level) to the South Korean advanced\npersistent threat (APT) actor Higaisa. The decoy files used in the two instances of the LNK\nattack targeted users of Chinese origin.\n\nThe infection chain used by the LNK files is very similar to the instance observed in March\n2020 by [Anomali. The C&C network infrastructure was correlated to Higaisa APT.](https://www.anomali.com/blog/covid-19-themes-are-being-utilized-by-threat-actors-of-varying-sophistication)\n\nIn this blog, we provide a detailed description of the distribution strategy, threat attribution,\nshellcode, anti-analysis techniques and the final backdoor of this campaign.\n\n## Distribution strategy\n\n\n-----\n\nThe LNK files used by this threat actor contain decoy files that are displayed to the user\nwhile the malicious activities are carried out in the background. The decoy content could be\nan internet shortcut file (.url file extension) or a PDF file. In this section, we will describe the\nvarious themes used in this campaign.\n\nOn May 12, 2020, we discovered two LNK files that used the Zeplin platform (zeplin.io) as\nthe decoy theme. Zeplin is a collaboration platform used by developers and designers in the\nenterprise industry. The details of the LNK files include:\n\n**MD5 hash: 45278d4ad4e0f4a891ec99283df153c3**\n\n**Filename: Conversations - iOS - Swipe Icons - Zeplin.lnk**\n\n**MD5 hash: c657e04141252e39b9fa75489f6320f5**\n\n**Filename: Tokbox icon - Odds and Ends - iOS - Zeplin.lnk**\n\nThese LNK files contain internet shortcut files that will be opened by the web browser\ninstalled on the system.\n\nThe URLs correspond to a project as shown below:\n\nProject URL for file with MD5 hash: 45278d4ad4e0f4a891ec99283df153c3\n\nhttps://app.zeplin.io/project/5b5741802f3131c3a63057a4/screen/5b589f697e44cee37e0e61\ndf\n\nProject URL for file with MD5 hash: c657e04141252e39b9fa75489f6320f5\n\nhttps://app.zeplin.io/project/5b5741802f3131c3a63057a4/screen/5b589f697e44cee37e0e61\ndf\n\nIf the user is not logged into the site, apps.zeplin.io, then it will redirect the user to the login\npage as shown in Figure 1.\n\n\n-----\n\n_Figure 1: The login page displayed by Zeplin._\n\nThe previously mentioned LNK files were present inside a RAR archive file format with the\nfollowing information:\n\n**MD5 hash of RAR archive: 2ffb817ff7ddcfa216da31f50e199df1**\n\n**Filename: Project link and New copyright policy.rar**\n\nThe contents of the RAR archive are shown below:\n\n├── Project link and New copyright policy\n\n│  ├── All tort's projects - Web lnks\n\n│  │  ├── Conversations - iOS - Swipe Icons - Zeplin.lnk\n\n│  │  └── Tokbox icon - Odds and Ends - iOS - Zeplin.lnk\n\n│  └── Zeplin Copyright Policy.pdf\n\nThe contents of the decoy PDF are related to Zeplin’s copyright policy as shown in Figure 2.\n\n\n-----\n\n_Figure 2: The decoy PDF displaying Zeplin’s copyright policy notice._\n\nOn May 30, 2020, we discovered two more LNK files, which we attribute to the same threat\nactor as described below.\n\n**MD5 hash: 4a4a223893c67b9d34392670002d58d7**\n\n**Filename:**\n\nCurriculum Vitae_WANG LEI_Hong Kong Polytechnic University.pdf.lnk\n\nThis LNK file drops a PDF file at runtime and opens it with the default PDF viewer on the\nsystem.\n\n\n-----\n\n**MD5 hash of the dropped PDF file: 4dcd2e0287e0292a1ad71cbfdf99726e**\n\n**Filename of decoy PDF: Curriculum Vitae_WANG LEI_Hong Kong Polytechnic**\nUniversity.pdf\n\nThe contents of this PDF file are shown in Figure 3.\n\n_Figure 3: The decoy PDF displaying the CV of a student from Hong Kong Polytechnic_\n_University_\n\nThe contents of the PDF correspond to the CV (curriculum vitae) of a student from Hong\nKong Polytechnic University include:\n\n**MD5 hash of the dropped PDF file: 28bfed8776c0787e9da3a2004c12b09a**\n\n**Filename of decoy PDF: International English Language Testing System certificate.pdf**\n\nThe second LNK file we observed on May 30, 2020 contained a PDF corresponding to the\nInternational English Language Testing System (IELTS) results of a student.\n\n\n-----\n\n_Figure 4: A student's IELTS examination results._\n\n## LNK metadata analysis\n\nThe LNK file format contains a wealth of metadata information that can be used for\nattribution and correlating the files to a particular threat actor. While most of the metadata\nfrom the LNK files in this attack was erased, we found the Security Identifier (SID) value\npreserved in the LNK files.\n\nUsing the LECmd tool, we extracted the SID value from the LNK files which are detailed in\nthe table below:\n\n**LNK file MD5 hash** **SID value**\n\n997ab0b59d865c4bd63cc55b5e9c8b48 S-1-5-21-1624688396-48173410-7563171851001\n\nc657e04141252e39b9fa75489f6320f5 S-1-5-21-1624688396-48173410-7563171851001\n\n4a4a223893c67b9d34392670002d58d7 S-1-5-21-1624688396-48173410-7563171851001\n\n45278d4ad4e0f4a891ec99283df153c3 S-1-5-21-1624688396-48173410-7563171851001\n\n\n-----\n\nWe wrote a YARA hunting rule to discover other LNK files in the wild with the same SID\nvalue as shown below:\n\nrule ZS_LNK_SID\n\n{\n\nstrings:\n\n$a = \"S-1-5-21-1624688396-48173410-756317185-1001\" wide\n\ncondition:\n\n$a\n\n}\n\nThe only instances we found were the above four LNK files. So, in addition to other\nindicators shared between these four LNK files, the common SID values helped us to\nfurther attribute them to the same threat actor.\n\n## Technical analysis\n\nFor the purpose of technical analysis, we will use the LNK file with MD5 hash:\n45278d4ad4e0f4a891ec99283df153c3.\n\nIf the Chrome browser is already installed on the machine, then the icon of the LNK file will\nappear to be the same as the Chrome browser icon. This is because the IconFileName\nproperty in the LNK file is set to the path of the Chrome browser as shown below:\n\nIconFileName - C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\n\nThe target property of the LNK file specifies the command that will be executed at runtime\nas shown in Figure 5.\n\n_Figure 5: The LNK command target._\n\nThis command starts the infection chain and involves multiple stages as detailed below :\n\nCopies the original LNK file to the temporary directory in the location:\n%temp%\\g4ZokyumB2DC.tmp\nIterates over the files in the C:\\Windows\\System32 directory to search for certutil.exe\nCopies certutil.exe to %temp%\\gosia.exe\n\n\n-----\n\nUses findstr.exe to search for the marker TVNDRgA inside the original LNK file.\nUsing the market, a base64 encoded blob is extracted to the temporary file:\n%temp%\\cSi1rouy.tmp\nUses certutil.exe to decode the base64 encoded blob to the file:\n%temp%\\o423DFDS.tmp\nThe resulting decoded file has the CAB file format.\nUses expand.exe to extract the contents of the CAB file to the %temp% directory.\n\nThe components of the cab file are shown in Figure 6.\n\n_Figure 6: The CAB file contents._\n\nHere is a brief description of each component of the CAB file. They are described in more\ndetails later in the blog.\n\n**3t54dE3r.tmp – Contains the shellcode that will be loaded and executed at runtime.**\n\n**34fDFkfSD32.js – The JavaScript that is used to initiate the infection chain after extraction**\nof CAB file contents.\n\n**Conversations - iOS - Swipe Icons – Zeplin.url – This is the internet shortcut file that will**\nbe used to open the URL:\nhttps://app.zeplin.io/project/5b5741802f3131c3a63057a4/screen/5b589f697e44cee37e0e61df\nwith Chrome browser on the machine.\n\n**Svchast.exe – This is the shellcode loader binary that spoofs the name of a legitimate**\nWindows binary called svchost.exe. Other details include:\n\nThe LNK file will open the internet shortcut file (which opens by default with the web\nbrowser and loads the URL).\nIt copies the CAB file component, 3t54dE3r.tmp to the location:\nC:\\Users\\Public\\Downloads\\3t54dE3r tmp\n\n\n-----\n\nIt uses wscript.exe to execute the JavaScript file: 34fDFkfSD32.js\n\n## JavaScript file analysis\n\n**MD5 hash of the JavaScript file: a140420e12b68c872fe687967ac5ddbe**\n\nThe contents of the JavaScript are shown in Figure 7.\n\n_Figure 7: The JavaScript file contents_\n\nBelow are the main operations performed by this JavaScript file.\n\nIt runs the ipconfig command to gather information about the machine's network\nadapter configuration. It then redirects the results of this command to the file:\nC:\\\\Users\\\\Public\\\\Downloads\\\\d3reEW.txt\nIt copies svchast.exe to the Startup directory in the location:\n%AppData%\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\officeupdate.exe\nfor persistence:\nIt copies svchast.exe to the location: C:\\\\Users\\\\Public\\\\Downloads\\\\officeupdate.exe\nIt uses schtasks.exe to create a scheduled task with the name: “Driver Bootser\nUpdate” which will be used to execute the officeupdate.exe binary\nIt executes svchast.exe binary.\nIt sends an HTTP POST request to the URL: [hxxp://zeplin.atwebpages.com/inter.php](http://zeplin.atwebpages.com/inter.php)\nand exfiltrates the ipconfig output gathered from the machine.\n\n## Shellcode loader analysis\n\n**MD5 hash: a29408dbedf1e5071993dca4a9266f5c**\n\n**Filename: svchast.exe**\n\n\n-----\n\nThe file svchast.exe is used to load the shellcode stored in the file 66DF3DFG.tmp in the\npath: C:\\Users\\Public\\Downloads\\66DF3DFG.tmp\n\nThis path is hardcoded in the loader.\n\nThe shellcode is loaded using the following steps:\n\n1. It reads the contents of the file, “C:\\Users\\Public\\Downloads\\66DF3DFG.tmp” into a\n\nnewly allocated memory region marked with PAGE_EXECUTE_READWRITE\npermission.\n2. It transfers the control to this memory region to start the execution of the shellcode.\n\n## Shellcode analysis\n\nIn this section, we have detailed the interesting code sections of the shellcode.\n\n**Anti-debugging technique**\n\nThe shellcode uses an anti-debugging technique to calculate a 32-bit hash of the code\nsection. This is done to detect the presence of any software breakpoints or tampering of\ncode done for the purpose of reverse engineering.\n\nWhen a software breakpoint is added in the debugger, a byte with the value 0xCC is added\nby the debugger in place of the original operation code (opcode). As a result of this, the\nhash calculation is corrupted.\n\nSuch anti-debugging techniques can be easily bypassed by using hardware breakpoints\ninstead of software breakpoints.\n\nAs an example, let us set a software breakpoint at the comparison instruction right after\nhash calculation and check the resulting hash calculated (shown in Figure 8).\n\n_Figure 8: The software breakpoint detection by anti-debugging techniques in the shellcode._\n\nAs can be seen in Figure 8, due to the software breakpoint, the computed hash was\ncorrupted. Because of this, the code can detect the presence of a debugger. The shellcode\nwill exit the execution if it detects a debugger.\n\n\n-----\n\nHowever, if we set a hardware breakpoint, the computed hash will be correct as shown in\nFigure 9.\n\n_Figure 9: The hardware breakpoint bypasses the anti-debugging technique in the shellcode._\n\nWe re-wrote the algorithm used by the shellcode to calculate the hash of the code section in\nPython and it can be found in Appendix I.\n\n**Decryption of data in the buffer**\n\nThe shellcode uses a 16-byte XOR key for decrypting the data as shown in Figure 10.\n\n_Figure 10: Decryption of the data in the buffer. XOR decryption used to decrypt the strings._\n\nThe 16-byte XOR key used for decryption is:\n\n\n-----\n\nkey = [0xE4, 0xFD, 0x23, 0x99, 0xA3, 0xE1, 0xD3, 0x58, 0xA6, 0xCC, 0xDB, 0xE8, 0xF2,\n0x91, 0xD2, 0xF8]\n\nWe re-wrote the decryption code in Python and can been seen in Appendix II.\n\nSince we believe this to be a new backdoor, we have shared the complete list of decrypted\nstrings in Appendix IV for reference.\n\n## Key generation routine\n\nIn the first thread created by the shellcode, it generates a cryptographic session key that will\nbe transmitted later to the C&C server to protect the communication channel between the\nbot and the server.\n\nIn this section, we detail the key generation routine.\n\nThere are multiple parts that are concatenated together to form the final key.\n\n**Part 1:**\n\nIt calls UUIDCreate() API to generate a UUID.\nIt uses the format string: “%08X....-%04X...-%0llX” to format the UUID using sprintf().\n\nExample UUID: DB7C6235-FD1A-45B6-224F868\n\n**Part 2:**\n\nIt calls UUIDCreate() to generate a 16-byte UUID.\nThe last byte of the UUID is used to generate a byte that will be used to perform the\nROR operation later.\nIt uses an ROR and ADD instruction-based algorithm to compute a 32-bit hash that\nwill be appended to first two steps (listed above). The algorithm used to compute the\n32-bit hash in this case is similar to the one used in the anti-debugging section. This\nalgorithm has been re-written in Python and can be found in Appendix I.\n\nFormat:\n\nuuid2 = [<--- 16 bytes of UUID --->] [ROR byte 0x00 0x00 0x00] [32-bit hash]\n\nIt uses CryptBinaryToStringA() to generate Base64 encoded data using UUID2.\n\n**Part 3:**\n\nIt uses Windows Crypto APIs to generate an MD5 hash using UUID1 (from Part 1).\nBefore the hash is calculated, the length of the UUID is extended to 0x48 bytes by\npadding with null bytes. This can be re-written in Python as:\n\n\n-----\n\ndata = uuid1 + \\x00  (0x48 - len(uuid1))\n\nmd5 = hashlib.md5()\n\nmd5.update(data)\n\nhash1 = md5.hexdigest()\n\nIt calculates an MD5 hash of the above-generated hash once again.\n\nhash2 = md5(hash1)\n\nIt uses CryptDeriveKey() to derive a 128-bit AES key.\n\n_Figure 11: The cryptographic session key derivation routine._\n\nIt appends hash2 with null bytes to extend the length to 0x48 bytes and then encrypts\nit using the AES-128 bit key derived in step 3 above. The encrypted hash is used to\nderive the AES key for encryption.\n\nAll these parts are concatenated together before transmitting to the C&C server for\nregistering the AES key for encrypted communication.\n\n## Initialization of a TLS session\n\nAfter decrypting the C&C server address, the shellcode proceeds to send an HTTP GET\nrequest to fetch the resource: “msdn.cpp” on the server.\n\n\n-----\n\nWinHTTPSetOption() is used to set the WINHTTP_OPTION_SECURITY_FLAGS value to\n0x3300, which allows it to ignore any certificate errors that might occur at the time of the\nrequest.\n\nFigure 12 shows that the content-length request header field in the HTTP GET request is\nset to: 0xffffffff manually at the time of invoking the WinHTTPSendRequest.\n\n_Figure 12: The initial request sent to the C&C server for deception purposes to make it look_\n_like a TLS session_\n\nThe HTTP GET request looks like:\n\nGET hxxps://45.76.6[.]149/msdn.cpp HTTP/1.1\n\nConnection: Keep-Alive\n\nUser-Agent: WinHTTP/1.1\n\nContent-Length: 4294967295 << this field was manually set to -1 by the shellcode\n\nHost: 45.76.6[.]149\n\nThis HTTP GET request was sent for deception purposes to make it look like a valid TLS\nsession. As we will see later, a FakeTLS session is used by the shellcode to perform C&C\ncommunication with the server.\n\n## Duplication of socket - ShadowMove similarity\n\nWe discovered an interesting code section in this shellcode which creates a duplicate\nsocket to connect to the C2 server. The method is very similar to the ShadowMove lateral\n[movement technique which was presented in Usenix 2020.](https://www.usenix.org/system/files/sec20summer_niakanlahiji_prepub.pdf)\n\nAt first glance, due to the high level of code overlap in this shellcode with the above\ntechnique, we believed it to be using the ShadowMove lateral movement\ntechnique. However on further inspection, we concluded that this technique was used to\n\n\n-----\n\ncreate a duplicate socket that will be used for FakeTLS communication as described in the\nnext section.\n\nBelow are the details of the steps used by the shellcode to create a duplicate socket used\nfor communication with the C2 server:\n\nIt calls the NtQuerySystemInformation() native API with the InfoClass parameter set\nto: SystemExtendedHandleInformation (0x40). This fetches detailed information for all\nthe handles and their corresponding object names.\nThe information is returned in the form of a\nSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX structure.\nIt uses a GetCurrentProcessID to find the process ID of the current process.\nIt compares the UniqueProcessID member of the\nSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX structure with the current process ID.\nIf they are equal, then it proceeds to the next step.\nIt compares the HandleValue member of the\nSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX structure with the socket handle. If\nthey are equal, then it proceeds to the next step.\nIt creates a new thread that calls the native API, NtQueryObject() to retrieve\ninformation about the object. The information is returned in the structure:\n__PUBLIC_OBJECT_TYPE_INFORMATION.\nIf the TypeName member of the\nstructure __PUBLIC_OBJECT_TYPE_INFORMATION is equal to “\\Device\\Afd”, then\nit proceeds to the next step. It is important to note that Windows sockets have the\nobject type “\\Device\\Afd”.\nIt calls getpeername() to get the IP address and port number corresponding to the\nabove socket.\nIt compares the IP address and port number with the expected values corresponding\nto the C&C server.\nIf the correct socket is found, then it calls DuplicateHandle() to duplicate this socket.\n\nFigure 13 shows the code section that locates the socket handle.\n\n\n-----\n\n_Figure 13: The subroutine that is used to iterate over system handles._\n\nFigure 14 shows the code section that checks if the socket handle corresponds to the\nsocket used to communicate with the C&C server.\n\n\n-----\n\n_Figure 14: The subroutine that used to locate the target socket handle used to communicate_\n_with the C&C server._\n\n## FakeTLS\n\nWe observed interesting use of the FakeTLS method in this shellcode. It creates a FakeTLS\nheader using the byte sequence: [0x17 0x03 0x01] as shown in Figure 15.\n\n_Figure 15: The subroutine used to craft the FakeTLS header._\n\nIt is important to note that this FakeTLS method has been used in the past by APT groups,\nsuch as Lazarus.\n\nThe reason for using this technique is to confuse network monitoring security systems that\ndo not perform proper SSL inspection and, as a result, allow the traffic to pass through.\n\nAlso, we noticed two requests sent by the bot using the FakeTLS header in the initialization\nphase.\n\n**Request 1 [Fake session key]**\n\nIn the first request, the routine:\n\nUses time() to get the current time.\nUses srand() to seed the pseudo-random number generator using the value obtained\nin step 1.\nUses rand() to generate a random number.\nGenerates a total of 0xC3 random bytes using the above method.\nAppends a total of 0x3C bytes with the value 0xAD to the data generated in step 4.\n\nSo a total of 0xFF bytes are generated in the format: [0xC3 bytes of random data][0x3C\nbytes with value 0xAD].\n\nThis data is appended to the FakeTLS header and sent using ws2_32.send() to the C&C\nserver as shown in Figure 16.\n\n\n-----\n\n_Figure 16: The FakeTLS packet appended with random data._\n\nIt is important to note that this memory chunk is freed using VirtualFree() after sending it in\na request to the C&C server. So we do not believe this was used as a session key because,\nin that case, the bot would have to preserve the key somewhere.\n\n**Request 2 [Real session key]**\n\nIn the second instance of the request sent to the C&C server, we noticed the FakeTLS\nheader appended with the cryptographic session key generated earlier as shown in Figure\n17.\n\n\n-----\n\n_Figure 17: FakeTLS header appended with cryptographic session key._\n\nThe data appended to the FakeTLS header has the following format:\n\n[command padded to 4 bytes][size padded to 4 bytes][base64-encoded data from Part2]\n\n[Hash2 - padded to 0x48 bytes][AES-128 bit Encrypted Key].\n\nBelow is an example of a packet with the FakeTLS Header and the data appended after it.\nThe structure of the packet is detailed in Figure 18.\n\n\n-----\n\n_Figure 18: The packet structure containing the FakeTLS header and custom format used for_\n_C&C communication._\n\nOther messages contain encrypted data right after the TLS header.\n\n## C&C communication\n\nThe shellcode creates two more threads that work together to handle the commands\nexchanged between the backdoor and the C&C server.\n\nBelow are the main steps used by the C&C command handler:\n\nIT creates a dispatch thread that will handle the commands posted to it by the worker\nthread.\nThe dispatch thread creates a message queue using the PeekMessageW() API.\nThe worker thread sends the message ID along with the command buffer to the\nmessage queue using PostThreadMessageW() API.\nOnce a message is posted to the dispatch thread by the worker thread, it is retrieved\nusing the GetMessageW() API. This message will be dispatched to the appropriate\ncommand handler based on the ID of the message as detailed below.\n\n\n-----\n\nThere are two sets of command IDs. One of them corresponds to commands from client to\nserver and the other set corresponds to commands from server to client. Corresponding to\neach command, there is a size of the command.\n\nAs an example,\n\nClient to server: The command ID 0x65 corresponds to the backdoor registering the system\nID (calculated using UUID) with the C&C server and the cryptographic session key as\nshown in Figure 18 above.\n\nServer to client: The command ID 0x64 is used to receive the encryption key that will be\nused by the client to encrypt the data sent to the server.\n\nAt the time of analysis, since the C2 server was not responding, we cannot conclusively\ndetermine the commands that were supported by this backdoor.\n\n## Zscaler Cloud Sandbox detection\n\nFigure 19 shows the Zscaler Cloud Sandbox successfully detecting this LNK-based threat.\n\n_Figure 19: The Zscaler Cloud Sandbox detection._\n\nIn addition to sandbox detections, Zscaler’s multilayered cloud security platform detects\nindicators at various levels:\n\n[LNK.Dropper.Higaisa](https://threatlibrary.zscaler.com/threats/afedef5b-2164-4ae1-8f2d-7fde74d556b4/)\n\n## Conclusion\n\n\n-----\n\nThis new instance of attack from the Higaisa APT group shows that they are actively\nupdating their tactics, techniques and procedures (TTPs) and incorporating new backdoors\nwith evasion techniques. The network communication protocol between the backdoor and\nthe C&C server is deceptive and complex, which was designed to evade network security\nsolutions.\n\nUsers are advised to take extra precaution while opening LNK files sent inside email\nattachments. LNK files can have the file icon of legitimate applications, such as Web\nbrowsers or PDF reader applications, so the source of the files should be verified before\nopening them.\n\nThe Zscaler ThreatLabZ team will continue to monitor this campaign, as well as others, to\nhelp keep our customers safe.\n\n## MITRE ATT&CK TTP Mapping\n\n**Tactic** **Technique**\n\n\nT1193 - Spearphishing\nAttachment\n\nT1059 - Command-Line\nInterface\n\n\nLNK files delivered inside RAR archives as an email\nattachment\n\nCommands run using cmd.exe to extract and run\npayload\n\n\nT1204 - User Execution LNK file is executed by user double click\n\nT1064 - Scripting Use of Visual Basic scripts\n\n\nT1060 - Registry Run Keys /\nStartup Folder\n\n\nCopies executable to the startup folder for persistence\n\n\nT1053 - Scheduled Task Creates scheduled task named “Driver Bootser\nUpdate” for persistence\n\n\nT1027 - Obfuscated Files or\nInformation\n\nT1140 - Deobfuscate/Decode\nFiles or Information\n\n\nParts of shellcode and its configuration is encrypted\nusing XOR encryption algorithm\n\nDecodes configuration at runtime\n\n\n-----\n\nT1036 - Masquerading Masquerades as legitimate documents, has\nembedded decoy documents\n\n\nT1033 - System Owner/User\nDiscovery\n\nT1016 - System Network\nConfiguration Discovery\n\nT1082 - System Information\nDiscovery\n\nT1094 - Custom Command and\nControl Protocol\n\n\nDiscovers username using GetUserNameA\n\nDiscovers network configuration using\nGetAdaptersInfoA\n\nDiscovers various information about system i.e.\nusername, computername, os version, etc\n\nUses custom protocol mimicking TLS communication\n\n\nT1043 - Commonly Used Port Uses port 443\n\nT1090 - Connection Proxy Discovers system proxy settings and uses if available\n\nT1008 - Fallback Channels Has code to communicate over UDP in addition to\nTCP\n\nT1132 - Data Encoding Uses base64 for encoding UUID\n\n\nT1032 - Standard Cryptographic\nProtocol\n\nT1095 - Standard NonApplication Layer Protocol\n\n\nUses AES-128 to encrypt network communications\n\nCommunicates over TCP\n\n\nT1002 - Data Compressed Can use LZNT1 compression\n\nT1022 - Data Encrypted Uses AES-128 for data encryption\n\nT1020 - Automated Exfiltration Automatically sends system information to CnC\nbased on configuration and CnC commands\n\n\n-----\n\nT1041 - Exfiltration Over\nCommand and Control Channel\n\n\nSends data over its CnC channel\n\n\n## Indicators of Compromise (IOCs)\n\n**LNK file MD5 hashes**\n\n21a51a834372ab11fba72fb865d6830e\n\naa67b7141327c0fad9881597c76282c0\n\nc657e04141252e39b9fa75489f6320f5\n\n45278d4ad4e0f4a891ec99283df153c3\n\n997ab0b59d865c4bd63cc55b5e9c8b48\n\n4a4a223893c67b9d34392670002d58d7\n\n**LNK file names**\n\nInternational English Language Testing System certificate.pdf.lnk\n\nTokbox icon - Odds and Ends - iOS - Zeplin.lnk\n\n20200308-sitrep-48-covid-19.pdf.lnk\n\nCurriculum Vitae_WANG LEI_Hong Kong Polytechnic University.pdf.lnk\n\nConversations - iOS - Swipe Icons - Zeplin.lnk\n\n**HTTP POST requests to register the bot**\n\nhxxp://sixindent[.]epizy[.]com/inter.php\n\nhxxp://goodhk[.]azurewebsites[.]net/inter.php\n\nhxxp://zeplin[.]atwebpages[.]com/inter.php\n\n**HTTP GET request to C&C server**\n\nhxxps://comcleanner[.]info/msdn.cpp\n\nhxxps://45[.]76[.]6[.]149/msdn.cpp\n\n**Appendix I**\n\n\n-----\n\n**Anti-debugging hash computation**\n\n# Hash of code section before decryption should be equal to 0x733C7595\n\n# Hash of code section after decryption should be equal to 0x6621A914\n\n# read the shellcode contents\n\ncontents = open(“shellcode.bin”, “rb”).read()\n\n# x86 ROR instruction re-written in Python\n\nror = lambda val, r_bits, max_bits: \\\n\n((val & (2**max_bits-1)) >> r_bits%max_bits) | \\\n\n(val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))\n\n# x86 movsx instruction re-written in Python\n\ndef SIGNEXT(x, b):\n\nm = 1 << (b - 1)\n\nx = x & ((1 << b) - 1)\n\nreturn (x ^ m) - m\n\n# limit = length of code section used for hash calculation\n\n# First 0xcb06 bytes are used to calculate the hash\n\nfor i in range(0xcb06):\n\nresult = ror(result, 0xa, 32)\n\nt = SIGNEXT(ord(contents[i]), 8) & 0xffffffff\n\nresult += t\n\nresult = result & 0xffffffff\n\nprint “final hash is: %x” %(result)\n\n**Appendix II**\n\n**XOR decryption code to extract plaintext strings and C&C server address**\n\nimport binascii, struct, sys\n\n\n-----\n\n# read the contents of shellcode\n\ncontents = open(sys.argv[1], \"rb\").read()\n\n# XOR decrypt the strings\n\ndef decrypt_data(encrypted, key):\n\ndecrypt = \"\"\n\nfor i in range(len(encrypted)):\n\ndb = encrypted[i]\n\nkb = key[i % len(key)]\n\nif(type(kb) == type(\"\")):\n\nkb = ord(kb)\n\nif(type(db) == type(\"\")):\n\ndb = ord(db)\n\ndecrypt += chr(db ^ kb)\n\nreturn decrypt\n\ndef extract_c2(contents):\n\nkey = contents[0xcb0e:0xcb1e]\n\nencrypted = contents[0xcb1e:]\n\ndecrypt = \"\"\n\ndecrypt = decrypt_data(encrypted, key)\n\nreturn \"{}:{}\".format(decrypt[432:].split(\"\\x00\")[0],struct.unpack(\"<h\",decrypt.encode()\n\n[422:424])[0])\n\nprint(\"==C2 Server==\\n{}\\n\".format(extract_c2(contents)))\n\n# Encrypted data is present at offset, 0xacc0 and has a total length of 0x12b0\n\nencrypted = contents[0xacc0:0xacc0+0x12b0]\n\n\n-----\n\n#16-byte XOR key\n\nkey = [0xE4, 0xFD, 0x23, 0x99, 0xA3, 0xE1, 0xD3, 0x58, 0xA6, 0xCC, 0xDB, 0xE8, 0xF2,\n0x91, 0xD2, 0xF8]\n\nprint(\"==Strings==\")\n\nfor item in decrypt_data(encrypted, key).split(\"\\x00\"):\n\nif item:\n\nprint(item)\n\n**Appendix III**\n\n**Script to generate AES key message**\n\nfrom wincrypto import CryptCreateHash, CryptHashData, CryptDeriveKey, CryptEncrypt,\nCryptImportKey, CryptExportKey, CryptGetHashParam, CryptDecrypt\n\nfrom wincrypto.constants import CALG_SHA1, CALG_AES_256, bType_SIMPLEBLOB,\nCALG_AES_128, CALG_MD5\n\nimport binascii, base64, struct, uuid\n\n### Hash functions ###\n\nror = lambda val, r_bits, max_bits: \\\n\n((val & (2**max_bits-1)) >> r_bits%max_bits) | \\\n\n(val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))\n\n# x86 movsx instruction re-written in Python\n\ndef SIGNEXT(x, b):\n\nm = 1 << (b - 1)\n\nx = x & ((1 << b) - 1)\n\nreturn (x ^ m) - m\n\ndef get_hash(uuid1):\n\nresult = 0\n\nfor i in range(len(uuid1)):\n\n\n-----\n\nresult = ror(result, 0xa, 32)\n\nt = SIGNEXT(uuid1[i], 8) & 0xffffffff\n\nresult += t\n\nresult = result & 0xffffffff\n\nreturn result\n\n### UUID convert from bytes to base64 ###\n\nuuid0 = uuid.uuid4().bytes\n\nuuid0_wh = uuid0 + b\"\\x00\\x00\\x00\" + struct.pack(\"<I\",get_hash(uuid0))#hash of uuuid1\n\nuuid0_enc = base64.b64encode(uuid0_wh) + b\"\\x0d\\x0a\" #append \"\\r\\n\" added by windows\nAPI\n\n### Derive key from UUID ####\n\n#Generate uuid\n\nuuid1 = str(uuid.uuid4())\n\n#Append NULL bytes to make length equal to 0x48\n\ndata = uuid1 + (b\"\\x00\" * (0x48 - len(uuid1)))\n\n#Generate MD5 hash\n\nhasher = CryptCreateHash(CALG_MD5)\n\nCryptHashData(hasher, data)\n\nuuid1_md5 = CryptGetHashParam(hasher,0x2)\n\n#Append NULL bytes to md5 and again generate md5 hash to make length equal to 0x48\n\nuuid1_md5_md5 = uuid1_md5 + (b\"\\x00\" * (0x48 - len(uuid1_md5)))\n\nhasher = CryptCreateHash(CALG_MD5)\n\nCryptHashData(hasher, uuid1_md5_md5)\n\n#Derive AES key\n\naes_key = CryptDeriveKey(hasher, CALG_AES_128)\n\n\n-----\n\n#Encrypt Send MD5 hash using AES\n\nencrypted_hash = CryptEncrypt(aes_key, uuid1_md5_md5)\n\n#append more NULL bytes to Encrypted hash to make length 0x90\n\nencrypted_hash_padded = encrypted_hash + (b\"\\x00\" * (0x90 - len(encrypted_hash)))\n\n#Again use encrypted hash to calculate its md5 and derive new AES key\n\nhasher = CryptCreateHash(CALG_MD5)\n\nCryptHashData(hasher, encrypted_hash_padded)\n\naes_key = CryptDeriveKey(hasher, CALG_AES_128)\n\n#generate message buffer to send to server to register key\n\nfake_tls_header = b\"\\x17\\x03\\x01\"\n\nclient_key_message_header = b\"\\x65\\x00\\x00\\x00\\xd8\\x00\\x00\\x00\"\n\nbuffer = client_key_message_header + uuid0_enc + b\"\\x00\\x00\" + uuid1_md5_md5 +\nencrypted_hash_padded\n\nbuffer = fake_tls_header + struct.pack(\">h\", len(buffer)) + buffer\n\nbinascii.hexlify(buffer)\n\nlen(buffer)\n\n**Appendix IV**\n\n**Decrypted strings from the shellcode**\n\nhttps://www.google.com\n\nWinHTTP /1.1\n\nGET /msdn.cpp\n\n\\Device\\Afd\n\nhttps://msdn.microsoft.com\n\nhttps://github.com\n\nhttps://www.google.com\n\n\n-----\n\nhttps://\n\njsproxy.dll\n\nInternetInitializeAutoProxyDll\n\nInternetDeInitializeAutoProxyDllInternetGetProxyInfo\n\nDIRECT\n\nszFmt:%dszS:%s\n\nszWS:%ws\n\nszD:%d\n\nszP:%p\n\nszX:%x\n\nszN:%d\n\nInit Error:%d\n\nconnect\n\n_CbConnect Over\n\nikcp_udp\n\nrecv in\n\nUninstall module:%d\n\nInitModule:%d\n\nContentLength :%d\n\nszHttpRecv :%d\n\n10.0.0.49\n\nszTunnel\n\nProxip:%s\n\nProxport:%d\n\nCurProxIp:%s\n\n\n-----\n\nCurProxPort:%d\n\nIeProxy ip:%s\n\nport:%d\n\ntype:%d\n\nProxyNumber:%d\n\nGET\n\nPOST\n\nhttp://%s/../...\n\n%s..%d\n\n200 OK\n\nHost:\n\nContent-Length:\n\nConnection: Keep-Alive\n\nHTTP/1.0\n\nHTTP/1.1Authorization: Basic\n\nDELETE\n\nnews\n\nQUERY\n\nSUBMIT\n\nen-us/msdn\n\nlibrary\n\n?hl=en-US\n\n?wd=http\n\n?lan=ja-jp\n\n10.0.0.208\n\n\n-----\n\ncbreover\n\ndispatch\n\n**Appendix V**\n\n**Structure of packet containing AES key**\n\nstruct Packet {\n\nstruct FakeTls {\n\nstruct AppDataHeader{\n\nbyte tls_header_app_data_constant;\n\nbyte tls_version_major;\n\nbyte tls_version_minor;\n\n} tls_app_data_header ;\n\nushort PacketSize;\n\n} FakeTlsHeader ;\n\nstruct PacketData {\n\nint Command ; //(0x65 Client to Server 0x64 Server to Client) AES key\n\nint DataSize ;\n\nchar SystemId[0x22];\n\nchar Padding[2];\n\nbyte data[DataSize] ;\n\n} command ;\n\n} packet;\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-11 - The Return of the Higaisa APT.pdf"
    ],
    "report_names": [
        "2020-06-11 - The Return of the Higaisa APT.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "873919c0-bc6a-4c19-b18d-c107e4aa3d20",
            "created_at": "2023-01-06T13:46:39.138138Z",
            "updated_at": "2025-03-27T02:00:03.005534Z",
            "deleted_at": null,
            "main_name": "Higaisa",
            "aliases": [],
            "source_name": "MISPGALAXY:Higaisa",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "30c9c492-afc6-4aa1-8fe6-cecffed946e0",
            "created_at": "2022-10-25T15:50:23.400822Z",
            "updated_at": "2025-03-27T02:00:55.461334Z",
            "deleted_at": null,
            "main_name": "Higaisa",
            "aliases": [
                "Higaisa"
            ],
            "source_name": "MITRE:Higaisa",
            "tools": [
                "PlugX",
                "certutil",
                "gh0st RAT"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535763,
    "ts_updated_at": 1743041741,
    "ts_creation_date": 1653766489,
    "ts_modification_date": 1653766489,
    "files": {
        "pdf": "https://archive.orkl.eu/3c11fd4ba17376de4c0c80bcdc590b77a06b4ff0.pdf",
        "text": "https://archive.orkl.eu/3c11fd4ba17376de4c0c80bcdc590b77a06b4ff0.txt",
        "img": "https://archive.orkl.eu/3c11fd4ba17376de4c0c80bcdc590b77a06b4ff0.jpg"
    }
}