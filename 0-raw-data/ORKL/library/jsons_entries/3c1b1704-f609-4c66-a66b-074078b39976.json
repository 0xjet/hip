{
    "id": "3c1b1704-f609-4c66-a66b-074078b39976",
    "created_at": "2023-01-12T15:09:27.805569Z",
    "updated_at": "2025-03-27T02:05:58.94571Z",
    "deleted_at": null,
    "sha1_hash": "b07440978cb947c7f07198e02427fe9932c021e5",
    "title": "2020-08-04 - WastedLocker’s techniques point to a familiar heritage",
    "authors": "",
    "file_creation_date": "2022-05-28T15:18:45Z",
    "file_modification_date": "2022-05-28T15:18:45Z",
    "file_size": 1050739,
    "plain_text": "# WastedLocker’s techniques point to a familiar heritage\n\n**[news.sophos.com/en-us/2020/08/04/wastedlocker-techniques-point-to-a-familiar-heritage/](https://news.sophos.com/en-us/2020/08/04/wastedlocker-techniques-point-to-a-familiar-heritage/)**\n\nAugust 4, 2020\n\nIt’s a lot easier to change a ransomware’s appearance (or obfuscate its code) than to change\nits underlying goals or behavior. After all, ransomware must necessarily reveal its intent\nwhen it strikes. But there are behavioral traits that ransomware routinely exhibits that security\nsoftware can use to decide whether the program is malicious. Some traits – such as the\nsuccessive encryption of documents – are hard for attackers to change.\n\nThe author of the WastedLocker ransomware cleverly constructed a sequence of maneuvers\nmeant to confuse and evade behavior based anti-ransomware solutions. We’ll discuss some\nof those tricks below, but it’s also worth mentioning that a code analysis we’ve performed on\nWastedLocker shows something else we didn’t expect: some of the specific techniques\nWastedLocker ransomware employs to obfuscate its code and perform certain tasks mirror\nthe subroutines we’ve seen previously used by another ransomware, Bitpaymer, and in the\nDridex trojan – too closely to have been a coincidence, in our opinion.\n\n## Evasion takes center stage\n\nRansomware creators are acutely aware that network or endpoint security controls pose a\nfatal threat to any operation, so they’ve developed a fixation on building complex logic for\ndetecting and subverting those controls. Modern ransomware spends an inordinate amount\nof time attempting to thwart security controls.\n\nMost of the advancements we observe in ransomware development can be categorized as\nsurvival skills, so the malware remains undetected just long enough to encrypt the target’s\nfiles. Survival demands that static and dynamic endpoint protection struggle to make a\n\n\n-----\n\ndetermination about a file based on the appearance of its code, and that behavioral detection\ntools are thwarted in their efforts to determine the root cause of the malicious behavior.\n\nMany malware families employ code obfuscation techniques, like runtime packers, as a way\nto thwart analysis, but a few have taken this a step further. Bitpaymer, for example, uses a\nunique method that calls Windows API functions using a hash of the function call, rather than\nthe call itself. WastedLocker appears to have adopted this technique and that adds an\nadditional layer of obfuscation by doing the entire thing in memory, where it’s harder for a\nbehavioral detection to catch it.\n\nOver the years, ransomware file system behaviors have, largely, remained consistent. (This\nyear’s Ryuk and REvil attacks exhibit the same file system behaviors as CryptoLocker from\n2013, for example.) Ransomware defenses based on behavior monitoring are typically\ntailored to detect this universal telltale activity. Now that things have changed a bit, the\ntactics we use to detect this behavior will have to change as well.\n\n## Memory tricks may thwart behavior monitoring\n\nBefore diving into the tricks, you need to know that ransomware defenses based on behavior\nmonitoring typically implement a minifilter driver. Minifilter drivers are kernel drivers that\nattach to the file system stack. Minifilters filter I/O operations in order to keep an eye on\neverything that happens to files. For example, the well-known Process Monitor utility from\nSysinternals uses a minifilter driver to create a real-time log of file system activity. Most antiransomware solutions use a similar approach to keep an eye on what happens to files.\n\nWastedLocker uses a trick to make it harder for behavior based anti-ransomware solutions to\nkeep track of what is going on: using memory-mapped I/O to encrypt a file. Although it is\nunnecessary for ransomware to access documents as a memory-mapped file (MMF), the\nmethod is more common nowadays, as Maze and Clop also employ the same tactic.\n\nThis technique allows the ransomware to transparently encrypt cached documents in\nmemory, without causing additional disk I/O. For behavior monitoring, this may be a problem.\nTools used to monitor disk writes may not notice that ransomware is accessing a cached\ndocument, because the data is served from memory instead of from disk.\n\nBut the kicker here is that WastedLocker is closing the file once it has mapped a file in\nmemory. You’d think this would result in an error, but the trick actually works because the\nWindows Cache Manager also opens a handle to the file once a file is mapped into memory.\n\n## Cache Manager’s lazy writer\n\nThe Cache Manager is a kernel component that sits between the file system and the Memory\nManager. If a process accesses the mapped memory, the memory manager will issue a page\nfault and the Cache Manager will read the necessary data from disk into memory. The more\n\n\n-----\n\nmemory is accessed, the more pages will be read from the disk into memory via so-called\npaging I/O.\n\nThe Memory Manager also keeps any eye on memory that has been modified, so-called dirty\npages. If a process encrypts the mapped memory, the memory manager knows which pages\nneed to be written back to disk. This writing is done by the Cache Manager’s Lazy Writer.\n\nThe Cache Manager implements a write-back cache with lazy write. This means that dirty\npages are allowed to accumulate for a short time and are then flushed to disk all at once,\nreducing the overall number of disk I/O operations. This also means that the writing is not\ndone in the context of the process but in the context of the system (PID 4). It’s this aspect\nthat can be troublesome for anti-ransomware solutions, as it becomes harder for an antiransomware tool to determine which process wrote to the file.\n\n## Complications\n\nThe WastedLocker ransomware closes its file handle right after it has mapped the file into\nmemory as can be seen in the following screenshot:\n\nClosing the file handle right after the file has been mapped into memory is allowed as the\n[documentation states:](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw)\n\n\n-----\n\n_Mapped views of a file mapping object maintain internal references to the object, and a_\n_file mapping object does not close until all references to it are released. Therefore, to_\n_fully close a file mapping object, an application must unmap all mapped views of the_\n_file mapping object by calling UnmapViewOfFile and close the file mapping object_\n_handle by calling CloseHandle. These functions can be called in any order._\n\nAnti-ransomware solutions that correlate activity based on CreateFile and CloseFile\noperations will miss all the disk I/O performed by the Cache Manager in response to mapped\nmemory operations. This can be observed by the following screenshot:\n\nUltimately, the Cache Manager will release its internal handle to the memory-mapped file.\nThis may happen after a few minutes, but we have observed that the Cache Manager closes\nthe handle only after several hours.\n\n(For more information on the Windows Cache Manager, refer to [Windows Internals, Part 2.)](https://www.microsoftpressstore.com/store/windows-internals-part-2-9780735665866)\n\n## Code evolution from an unexpected source\n\nInterestingly, an analysis of the WastedLocker code gave rise to a hypothesis that it may be\nan evolutionary descendent of Bitpaymer. Analysts familiar with both found noteworthy\nsimilarities (possibly even rewritten code) that seem to be more than a coincidence.\n\nAbuse of Alternate Data Streams (ADS)\n\nBoth Bitpaymer and WastedLocker abuse ADS in the same way: The malware finds a clean\nsystem file, copies itself to the clean file’s ADS, and then executes itself as a service\ncomponent of the clean file. This makes it appear that the clean file is the source of the\nransomware behavior. They both accomplish this using the same technique: They reset the\nprivileges of the targeted system file using icacls.exe in order to add the ADS component,\nand then copy the clean system file to the %APPDATA% folder.\n\nCustomized API resolving method\n\n\n-----\n\nBitpaymer uses custom API resolve functions to call Windows APIs using a hash value,\nrather than the API function’s name. The same code was also used by Dridex malware, and\nwas consistently seen in many earlier Bitpaymer variants. With WastedLocker, the author did\na major upgrade to the codebase by removing these functions. Instead, it calls the Windows\nAPI directly in memory.\n\nThe change it has improved the efficiency of the malware execution without spending much\ntime in computing the hash and calling the API dynamically. Since this custom API Resolve\nfunction gets called in every single API call, the similar-behaving function code looked totally\ndifferent during analysis.\n\nUAC bypass\n\nBoth ransomware use a similar User Account Controls bypass technique to elevate the\nclean, hijacked process to run the ransomware code (using the ADS technique, above).\nBitpaymer adds a .cmd file to the registry key\n(“HKCU\\Software\\Classes\\mscfile\\shell\\open\\command”), such that, when an elevated\neventvwr.exe file is executed, it checks the registry key (by default) and that, in turn,\nexecutes the .cmd file that runs the ransomware binary. With WastedLocker, it uses\nwinsat.exe and winmm.dll to run the ransomware binary (ADS component) by patching the\nwinmm.dll.\n\nEncryption methods\n\nBitpaymer has slowly over time improved the encryption method it uses. Initial variants of\nBitpaymer use an RC4 key for encrypting the file content, and it further encrypts the RC4 key\nusing a 1024-bit RSA public key. But later variants of Bitpaymer (as well as current versions\nof WastedLocker) made some improvements by using AES 256 bit CBC mode for encrypting\nthe files, along with a 4096-bit RSA public key. Both these ransomware also encodes the key\ninformation with Base64, and stores the encoded key in the ransom note.\n\nRansom note composition\n\nBoth customize the ransom note for each of the victim by adding the organization name in\nthe ransom note. WastedLocker also adds the organization name to the ransom note file\nname as a prefix.\n\n\n-----\n\nSimilar style of command line arguments\n\nWastedLocker can perform certain operations when its main executable is launched using\nspecific arguments, as did some earlier versions of BitPaymer. Both malware use numbers\nas arguments and the numbers they both use to indicate the operation the malware is\nsupposed to perform are the same (eg., -1 indicates the main/initial execution, -2 issues a\ncommand to copy the malware and run it using ADS, and -3 indicates that it will begin the file\nencryption process.\n\nWhile none of these alone, or even in combination, is enough to definitively say that, for\ninstance, the same creator was responsible for both ransomware, the number of similarities\nis so striking as to raise questions about whether the malware author(s) of Bitpaymer and\nWastedLocker are connected in some collaborative way.\n\n**Reference IoC**\n\nSample:\nBCDAC1A2B67E2B47F8129814DCA3BCF7D55404757EB09F1C3103F57DA3153EC8\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-04 - WastedLocker’s techniques point to a familiar heritage.pdf"
    ],
    "report_names": [
        "2020-08-04 - WastedLocker’s techniques point to a familiar heritage.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536167,
    "ts_updated_at": 1743041158,
    "ts_creation_date": 1653751125,
    "ts_modification_date": 1653751125,
    "files": {
        "pdf": "https://archive.orkl.eu/b07440978cb947c7f07198e02427fe9932c021e5.pdf",
        "text": "https://archive.orkl.eu/b07440978cb947c7f07198e02427fe9932c021e5.txt",
        "img": "https://archive.orkl.eu/b07440978cb947c7f07198e02427fe9932c021e5.jpg"
    }
}