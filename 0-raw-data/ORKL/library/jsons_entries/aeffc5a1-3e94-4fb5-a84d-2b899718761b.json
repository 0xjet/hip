{
    "id": "aeffc5a1-3e94-4fb5-a84d-2b899718761b",
    "created_at": "2023-01-12T15:10:18.130441Z",
    "updated_at": "2025-03-27T02:05:26.976966Z",
    "deleted_at": null,
    "sha1_hash": "a1a45d096096f328b81296defb34d02e71796e19",
    "title": "2020-04-26 - use Ghidra to Decrypt Strings of KPOTstealer Malware",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:24Z",
    "file_modification_date": "2022-05-29T01:19:24Z",
    "file_size": 202529,
    "plain_text": "# Use Ghidra to decrypt strings of KpotStealer malware\n\n**[blag.nullteilerfrei.de/2020/04/26/use-ghidra-to-decrypt-strings-of-kpotstealer-malware/](https://blag.nullteilerfrei.de/2020/04/26/use-ghidra-to-decrypt-strings-of-kpotstealer-malware/)**\n\nborn\n\nThis post will explain, how to identify a function responsible for string deobfuscation in a\nnative-PE malware sample. We will use a KpotStealer sample as a concrete example.\nKpotStealer (aka Khalesi or just Kpot) is a commodity malware family probably circulated in\nthe shadowy parts of the internet since 2018. It got its name from a string publicly present on\nthe Admin-Panel. After we found the function we will understand the data structure it uses\n[and emulate the decryption of a string with CyberChef and Binary Refinery. An interesting](https://github.com/binref/refinery)\ndetail here is that Ghidra currently does not guess the function signature correctly. Finally, we\nwill develop a Java script (hehe) for Ghidra to automatically deobfuscate all strings given the\ncorresponding obfuscation function. ## Motivation Malware authors use string obfuscation to\navoid inclusion of \"interesting\" strings as an entry point for bottom up analysis in the binary.\nSome time ago, I [blagged about string obfuscation and how one might implement it. Feel](https://blag.nullteilerfrei.de/2019/06/17/diy-string-obfuscation-for-plain-c/)\nfree to head over there for more details and context. The intention behind using string\nobfuscation is, to make assessments like \"this looks like an IP, maybe it's the Command &\nControl (C2) server\" or \" vssadmin.exe Delete Shadows looks as if the malware deletes\nshadow copies\" impossible. It would also hinder an analyst to find a reference to a `POST`\nstring, which may indicate the place in the code where the networking is implemented.\nObviously, an analyst wants to revert this process to be able to do exactly that. Especially if a\nmalware family uses lots of strings or if one wants to analyze multiple samples of the same\nfamily, this process should be as automated as possible. ## Identifying the String\nDeobfuscation Function Let's first assume that there is only one function responsible for\ndeobfuscating all strings. This is true for the KpotStealer sample we will be looking at and so\nit is for many other malware families. Often, malware authors do not distinguish between\nstrings requiring protection and generic strings and just apply string obfuscation to all strings\nin their code. This has two interesting implications for us as reverse engineers: * since\nstrings are generally quite important in software development, the string deobfuscation\nfunction is called from many different locations and probably also not far from the entry point\nof the executable. * all locations, the string deobfuscation function is called from, belong to\nmalware code and are not part of any static library. And we want to avoid reverse\nengineering static library code as a vampire wants to avoid garlic. The first of the two points\nabove suggest that starting off from the entry point top-down-style and systematically going\nthrough all functions may be feasible. To further speed up the process, I use the following\nheuristics: * Since strings are so common, the string deobfuscation function should be called\nfrom a lot of different places. * The string deobfuscation function should access at least one\nmemory region (containing the obfuscated string). This region may be represented by a\nglobal pointer reference from within the function or be passed to the function as an\nargument. If the first of the two is true, the string obfuscation method needs some sort of id to\ndistinguish different strings within that global buffer. * Similarly, the function further needs\n\n\n-----\n\naccess to a second buffer if it leverages cryptography to deobfuscate the string. This _key_\nmay be the same for all strings or may also vary on a per-string basis. If the second is true,\nthe function may either receive different strings every time it is called or, again, some sort of\nid to distinguish different strings. * The function needs some way to know, how large the\nobfuscated buffer is. Common ways of doing this in C are to use a terminating character (like\n```\n\\0 ) or a parameter explicitly stating the length. * Deobfuscated data needs to be returned\n\n```\nfrom the function. An obvious way would be to return a newly allocated buffer. Another way\nis, to write to a pointer passed as an argument to the function. * At the call locations the\ndeobfuscated data (somehow) returned from the function is often then used shortly after. The\nwhole point of all these heuristics is to be fast. Deobfuscating all strings normally is a huge\nstep forward in the analysis of a malware and gives a jump start by enabling bottom-up\nanalysis. On a different note, it sometimes even allows extraction of indicators of\ncompromise (IoC) like IPs or domains, if that's your heart's desire. ## Finding Nemo This and\nthe following section will describe how one would find the function responsible for string\ndeobfuscation in the KpotStealer sample with a SHA256 hash of\n```\n67f8302a2fd28d15f62d6d20d748bfe350334e5353cbdef112bd1f8231b5599d\n\n```\nWe will set a focus on the though processes itself and rational behind the decisions made\nduring analysis, hence this part is longer than necessary. Skip this and the following section\nif you are not interested in such fundamentals. Going through all functions called in the entry\npoint, the function at `0x004058fb sticks out because it is quite large and because it is`\nsetting a lot of global variables. It was only then, that I checked the number of import of the\nbinary and realized that there are almost none. This may mean that this sample uses some\nsort of dynamic API resolution and the function at `0x004058fb is a prime candidate for`\nbeing responsible of doing that: it is called relatively early during execution and sets a lot of\nglobal variables. Hence it is plausible (though not necessary), that it needs to reference\nstrings containing DLL names. Starting at `0x00405912, the function at` `0x0040c8f5 is`\ncalled multiple times. This function is also called at 69 other spots in the binary, which is a\ngood tell that this may be the string deobfuscation method (you can see this by pressing `X`\n[if you have the ghIDA key bindings for Ghidra configured). The weird thing is though, that](https://mal.re/tmp/ghIDA.kbxml)\nGhidra only shows\n```\nFUN_0040c8f5();\nFUN_0040c8f5();\nFUN_0040c8f5();\nFUN_0040c8f5();\nFUN_0040c8f5();\nFUN_0040c8f5();\n...\n\n```\nin the decompile view. It is pretty weird that there should be multiple calls to the same\nfunction without any arguments and without somehow using the return value. And as it will\nturn out, Ghidra needs some help here to effectively decompile this part. ### Become the\nMother of Dragons As much as we try to avoid looking at assembly, we have to take a look at\n\n\n-----\n\nit now. Good news though: you only need to know two and a half assembly instructions to\nunderstand, what is going on here: `CALL,` `MOV and,` `LEA . Let's first understand what`\nthese instructions to in general: `CALL branches off execution to a function. This is done by`\npushing the address immediately after the `CALL instruction onto the stack and then set`\n```\nEIP to the address of the function to be called - but we don't need to care about this level of\n\n```\ndetail here. The other one and a half assembly instructions `MOV and` `LEA have different`\nintended use-cases. But in principle, they both just move data around: `LEA copies the`\n_referenced_ data and `MOV the actual data. But this difference does not matter if you just`\nignore `[ and` `] characters. Let's move away from the general description to the concrete`\nusage of these instructions here. When clicking on one of the functions in the decompile\nview, the disassembly listing will also move to the corresponding position in memory:\n```\n00405907 8d bd 78 f9 ff ff           LEA    EDI=>local_68c,[EBP +\n0xfffff978]\n0040590d b8 a6 00 00 00             MOV    EAX,0xa6\n00405912 e8 de 6f 00 00             CALL    FUN_0040c8f5\n00405917 8d bd 84 f9 ff ff           LEA    EDI=>local_680,[EBP +\n0xfffff984]\n0040591d b8 a7 00 00 00             MOV    EAX,0xa7\n00405922 e8 ce 6f 00 00             CALL    FUN_0040c8f5\n00405927 8d bd cc f9 ff ff           LEA    EDI=>local_638,[EBP +\n0xfffff9cc]\n0040592d b8 a8 00 00 00             MOV    EAX,0xa8\n00405932 e8 be 6f 00 00             CALL    FUN_0040c8f5\n00405937 8d bd e4 f9 ff ff           LEA    EDI=>local_620,[EBP +\n0xfffff9e4]\n0040593d b8 a9 00 00 00             MOV    EAX,0xa9\n00405942 e8 ae 6f 00 00             CALL    FUN_0040c8f5\n00405947 8d bd 9c f9 ff ff           LEA    EDI=>local_668,[EBP +\n0xfffff99c]\n0040594d b8 aa 00 00 00             MOV    EAX,0xaa\n00405952 e8 9e 6f 00 00             CALL    FUN_0040c8f5\n00405957 8d bd 58 f9 ff ff           LEA    EDI=>local_6ac,[EBP +\n0xfffff958]\n0040595d b8 ab 00 00 00             MOV    EAX,0xab\n00405962 e8 8e 6f 00 00             CALL    FUN_0040c8f5\n\n```\nThe newlines are inserted for the sake of clearity. Each `CALL is preceded by a` `LEA and`\n```\nMOV . All LEA instructions above move an address into the EDI register and the MOV s\n\n```\ncopy an immediate value into `EAX . Before giving it any further thought, let's tell Ghidra to`\ntake `EAX and` `EDI into account when generating decompiled code for these calls. Edit the`\nfunction signature to \"Use Custom Storage\" and add two \"Function Variables\" stored in `EAX`\nand `EDI . This leads to the following decompiled code:`\n\n\n-----\n\n```\nFUN_0040c8f5(0xa6,local_68c);\nFUN_0040c8f5(0xa7,local_680);\nFUN_0040c8f5(0xa8,local_638);\nFUN_0040c8f5(0xa9,local_620);\nFUN_0040c8f5(0xaa,local_668);\nFUN_0040c8f5(0xab,local_6ac);\n\n```\nAnd one can easily confirm that the variables passed as a second argument are referenced\nin the code following the call. After checking a few other places, this function was called, I\nwas confident, that this is indeed the string deobfuscation function. ## Annotating the\nDebofuscation Function Until this point, we never even looked into the function. Let's change\nthat and let's further already rename and retype the arguments to `uint PrStringIndex`\nand `BYTE *RetVal :`\n```\nvoid FUN_0040c8f5(uint PrStringIndex, BYTE *RetVal)\n{\n int iVar1;\n uint uVar2;\n ushort uVar3;\n iVar1 = (PrStringIndex & 0xffff) * 8;\n uVar3 = 0;\n if (*(short *)(&DAT_0040128a + iVar1) != 0) {\n  do {\n   uVar2 = (uint)uVar3;\n   uVar3 = uVar3 + 1;\n   RetVal[uVar2] =\n      (&PTR_DAT_0040128c)[(PrStringIndex & 0xffff) * 2][uVar2] ^ (&DAT_00401288)\n[iVar1];\n  } while (uVar3 < *(ushort *)(&DAT_0040128a + iVar1));\n }\n RetVal[*(ushort *)(&DAT_0040128a + iVar1)] = '\\0';\n return;\n}\n\n```\nThe function contains several references to global variables. Namely `DAT_0040128a,`\n```\nPTR_DAT_0040128c and DAT_00401288 . Just by looking at the auto-generate names, one\n\n```\ncan tell that the distance in memory between those three is very small (i.e. 2 bytes). This is a\nsign that those are not actually three different variables but a structure with three fields. And\nwe also already know the sizes of two of them (and just assume 4 bytes for the last, mainly\nbecause that's the size of a pointer in 32 bit):\n```\nstruct DeobfuContext {\n  word field_0; // because 0x0040128a - 0x00401288 == 2\n  word field_1; // because 0x0040128c - 0x0040128a == 2\n  dword field_2; // because this is the size of a pointer in 32-bit\n}\n\n```\nLet's create this structure in Ghidra (by hitting \"Insert\" in the \"Data Type Manager\" if you use\nthe ghIDA key bindings). Let's call the struct `DeobfuContext and don't forget to hit that`\nother \"Save\" button in the \"Structure Editor\". Now let's retype the variable that comes first in\n\n\n-----\n\nmemory to a `DeobfuContext struct. Double clicking` `DAT_00401288 will move the Listing`\nview to the corresponding memory location. Since our structure is 8 bytes in size, we first\nneed to make some space by undefining `PTR_DAT_0040128c below (hit` `U if you - you`\nmight have guessed - have the ghIDA key bindings) and change the type of `DAT_00401288`\nto `DeobfuContext . This will lead Ghidra to show typecasts like` `(&DAT_00401288)`\n```\n[PrStringIndex].field_1, which tells us again that we made a mistake: The type is not\nDeobfuContext but an array of DeobfuContext . Since we don't know the size, we'll just\n\n```\nuse a size of 1 for now: Retype `DAT_00401288 to` `DeobfuContext[1] and also rename it`\nto `DEOBFU_CONTEXTS . I also took the liberty to rename two local variables to` `i and` `j`\nbecause they where used as counters in a loop:\n```\nvoid FUN_0040c8f5(uint PrStringIndex, BYTE *RetVal)\n{\n uint j;\n ushort i;\n PrStringIndex = PrStringIndex & 0xffff;\n i = 0;\n if (DEOBFU_CONTEXTS[PrStringIndex].field_1 != 0) {\n  do {\n   j = (uint)i;\n   i = i + 1;\n   RetVal[j] = *(byte *)(DEOBFU_CONTEXTS[PrStringIndex].field_2 + j) ^\n         *(byte *)&DEOBFU_CONTEXTS[PrStringIndex].field_0;\n  } while (i < DEOBFU_CONTEXTS[PrStringIndex].field_1);\n }\n RetVal[DEOBFU_CONTEXTS[PrStringIndex].field_1] = '\\0';\n return;\n}\n\n```\nReading this code now enables us to rename and retype the fields of the `DeobfuContext`\nstruct: Because `i counts up until` `field_1, it is probably some sort of length. The`\nexpression `*(byte *)(DEOBFU_CONTEXTS[PrStringIndex].field_2 + j) suggests, that`\n```\nfield_2 is in fact an array, i.e. BYTE *, which - coincidentally - is also four bytes in size.\n\n```\nAnd finally, `*(byte *)&DEOBFU_CONTEXTS[PrStringIndex].field_0 effectively shortens`\nthe field `field_0 to a size of one byte instead of two. One might also realized that this`\n```\nfield_0 is used in an XOR expression ^ so let's be brave and guess that it's a key and\n\n```\nchange the struct accordingly:\n\n\n-----\n\nAnd this finally enables Ghidra to show us the following decompiled version of the function,\nwhich I also renamed:\n```\nvoid EvStringDeobfuscate(uint PrStringIndex, BYTE *RetVal)\n{\n uint j;\n ushort i;\n PrStringIndex = PrStringIndex & 0xffff;\n i = 0;\n if (DEOBFU_CONTEXTS[PrStringIndex].Length != 0) {\n  do {\n   j = (uint)i;\n   i = i + 1;\n   RetVal[j] = DEOBFU_CONTEXTS[PrStringIndex].Buffer[j] ^\nDEOBFU_CONTEXTS[PrStringIndex].Key;\n  } while (i < DEOBFU_CONTEXTS[PrStringIndex].Length);\n }\n RetVal[DEOBFU_CONTEXTS[PrStringIndex].Length] = '\\0';\n return;\n}\n\n```\nSo after getting some help, Ghidra presents us with code that can almost be compiled as a C\nprogram. And for sure it can be easily understood! ## Understanding the Algorithm The\nstring obfuscation function accesses a global array of structs, each struct has three fields:\none byte XOR-key, the length of the string and a pointer to the obfuscated data. The function\nfurther accepts two arguments: an index into the global array and a pointer, where the\ndeobfuscated string will be written to. The function then iterates over the obfuscated data\n\n\n-----\n\nand XORes every byte with the key from the same struct. To now learn how large this global\narray really is, one could, for example, look at all references, write down the index and use\nthe larges one as the size of the array. We will later write a script to automatically do that, so\nif you want to set the size of the global struct array now, just feel free to retype it to\n```\nDeobfuContext[183] . But before we move on and write code to automate this, just to\n\n```\neventually realize that we made a mistake somewhere above, let's first confirm our\nunderstanding of the deobfuscation algorithm by emulating it. There are numerous ways of\ndoing that and I'll just explain, how to do it in Cyberchef and then, how to do it in Binary\nRefinery. Binary Refinery is the best set of command line tools for binary transformation out\nthere. You can also always write a Python script or try to compile the code with a C compiler.\nLet's take the first call that comes along (at `0x00405912 ):` `EvStringDeobfuscate(0xa6,`\n```\nlocal_68c) . It will access position 0xa6 (which is 166) of the global array. Double click\nDEOBFU_CONTEXTS and scroll down to position 166: | Field | Value |--- |--- | Key | B4 |\n\n```\nLength | `0B 00 | Buffer |` `5c 2a 40 00 Double clicking the global variable`\n```\nDAT_00402a5c, which corresponds to the Buffer pointer 5c 2a 40 00, will bring you to\n\n```\nthe memory location containing the obfuscated string. We know, that it should have the size\n```\n0x0b (which is 11). Create an Array of that size in memory there, select it and, finally \"Copy\n\n```\nSpecial...\" (or Shift-E) it. When choosing \"Byte String (No Spaces)\" the following data will be\nin your clipboard: `c3dddadddad1c09ad0d8d8 . Using` [CyberChef for example, you can](https://cyberchef.nullteilerfrei.de/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'C2'%7D,'Standard',false)&input=YzNkZGRhZGRkYWQxYzA5YWQwZDhkOA)\ndeobfuscate this with the \"From Hex\" and \"Xor\" operations to `wininet.dll . Alternatively,`\n[the following Binary Refinery pipeline will yield the same result:](https://github.com/binref/refinery)\n```\nemit c3dddadddad1c09ad0d8d8| hex | xor H:B4\n# alternatively, you can also read the string directly from the sample:\nemit 67f8302a2fd28d15f62d6d20d748bfe350334e5353cbdef112bd1f8231b5599d | peslice\n0x00402a5c -t 11 | xor H:B4\n\n```\nThat's good news! We seem to have understood the memory layout as well as the\nobfuscation technique correctly. ## Ghidra Script The envisioned user experience for a script\nis as follows: The scripts asks for a function name and will then find all calls, read the\nappropriate region from the global buffer, decrypt the string, print the location and the result\nto the console, add a comment of the decrypted string into the disassembly and the\ndecompiled view and, add a bookmark to the location. This will enable users to list all\ndecrypted strings as well as reduce friction during full analysis of the sample. Let's chop this\nup into small steps: 1. ask user to a function name, pre-populate the input field with the\ncurrently viewed function 2. read the address of the global buffer from the disassembly of the\nfunction 3. iterate over all calls to the function 4. read the value of the first argument for each\ncall 5. decrypt the string 6. set comments and bookmarks as well as print to the console If\nyou follow this blag closely, you may have noticed, that we already solved 1, 3, 4 and 6 in\nprevious posts. So I'll just go into detail for steps 2 and 5 and put a link to the full script in the\nend. Step 2: The following code will first call the `findGlobalBufferAddress function,`\nwhich I'll explain in a moment. If that's not successful, it will ask the user for the address\ninstead. To be honest, there is not much to see here:\n\n\n-----\n\n```\nlong globalBufferPtr;\nOptionalLong optionalGlobalBufferPtr = findGlobalBufferAddress(deobfuscator, 0x10);\nif (optionalGlobalBufferPtr.isEmpty()) {\n  try {\n    globalBufferPtr = askInt(\"Enter Global Buffer Address\",\n        \"Cannot automatically determine global buffer address, specify it\nmanually:\");\n  } catch (CancelledException X) {\n    return;\n  }\n} else {\n  globalBufferPtr = optionalGlobalBufferPtr.getAsLong();\n}\n\n```\nNow to the `findGlobalBufferAddress function, which is an example for parsing some`\nassembly in a Ghidra script:\n```\npublic Boolean isGlobalBufferAccess(Instruction instruction) {\n  return (instruction.getOperandType(0) & OperandType.REGISTER) ==\nOperandType.REGISTER\n      && (instruction.getOperandType(1) & OperandType.ADDRESS) ==\nOperandType.ADDRESS\n      && (instruction.getOperandType(1) & OperandType.DYNAMIC) ==\nOperandType.DYNAMIC;\n}\npublic OptionalLong findGlobalBufferAddress(Function func, int searchDepth) {\n  int i = 0;\n  for (Instruction instruction :\ncurrentProgram.getListing().getInstructions(func.getEntryPoint(), true)) {\n    if (instruction.getMnemonicString().equals(\"LEA\")) {\n      // the first operand of LEA is the target register, the second is the\naddress\n      if (isGlobalBufferAccess(instruction)) {\n        // this gets the \"objects\" for the second argument which. This is an\narray of\n        // values:\n        //\n        // LEA globalBufferIndex,[globalBufferIndex*0x8 + GLOBAL_BUFFER]\n        // Index 0: globalBufferIndex\n        // Index 1: 0x8\n        // Index 2: GLOBAL_BUFFER\n        String hexEncoded = instruction.getOpObjects(1)[2].toString();\n        return OptionalLong.of(Long.decode(hexEncoded));\n      }\n    }\n    i++;\n    if (i > searchDepth)\n      break;\n  }\n  return OptionalLong.empty();\n}\n\n```\n\n-----\n\nIterate over all instructions from the function up until a given search depth, this function will\nfilter out all `LEA instructions. We guess that it is in fact the instruction accessing the global`\nbuffer if its first operand is a register and the second a calculated address. For an assembly\ninstruction object, Ghidra exposes the \"operand objects\" which represent the values of the\ndifferent operands of an argument to an instruction. The second argument to this `LEA`\ninstruction is `[globalBufferIndex*0x8 + GLOBAL_BUFFER] and there, we are interested`\nin the third operand, the `GLOBAL_BUFFER . Feel free to read the comment in the function for`\na slightly different perspective. Step 5: The actual decryption of the string _should_ of course\nbe the interesting part but as it's always, everything else already took 80% of the time. But\nstill, here we go:\n```\nbyte structContent[] = getOriginalBytes(toAddr(globalBufferPtr + globalBufferIndex *\n8), 8);\nbyte xorKey[] = { structContent[0] };\nint dataLength = (structContent[2] & 0xff) | (structContent[3] & 0xff) << 8;\nint encryptedPtr = (structContent[4] & 0xff) | ((structContent[5] & 0xff) << 8)\n    | ((structContent[6] & 0xff) << 16) | ((structContent[7] & 0xff) << 24);\nbyte[] obfuscatedBuffer = getOriginalBytes(toAddr(encryptedPtr), dataLength);\nbyte decrypted[] = deobfuscateString(obfuscatedBuffer, xorKey);\n\n```\nThis snippet uses the `getOriginalBytes from previous blag posts and reads 8 bytes of`\nmemory from the correct location. The first byte is the `xorKey . Bytes at location 2 and 3 are`\ncombined little endian-style into an integer `dataLength and finally, the four following bytes`\nare combined in the same way into a pointer to the encrypted payload `encryptedPtr . We`\nthen use the `getOriginalBytes function again to read the encrypted data into`\n```\nobfuscatedBuffer and pass that together with the key to the deobfuscateString\n\n```\nfunction:\n```\nprivate byte[] deobfuscateString(byte[] data, byte[] key) {\n  final byte[] ret = new byte[data.length];\n  for (int k = 0; k < data.length; k++)\n    ret[k] = (byte) (data[k] ^ key[k % key.length]);\n  return ret;\n}\n\n```\nThe rest is just boilerplate you can copy and paste from other scripts. The ready-to-use-script\nis in our repository on github. ## Appendix: Decrypted Strings For google-ability and\noverview, here is a list of decrypted strings for the above sample: | `CALL Address | Offset |`\nDeobfuscated String |--- |--- |--- | `0x0040F6FE |` `0 |` `http[:]//bendes.co[.]uk |`\n```\n0x0040F709 | 1 | /lmpUNlwDfoybeulu | 0x0040FC5D | 2 | 4p81GSwBwRrAhCYK |\n0x00411D79 | 3 | SQLite format 3 | 0x00412C84 | 4 | 2|NordVPN||%s|%s |\n0x0040F714 | 19 | .bit | 0x00412A85 | 20 | %08lX%04lX%lu | 0x0040BB31 | 22\n\n```\n| `Hostname |` `0x00409FC0 |` `25 |` `TRUE |` `0x00409FCB |` `26 |` `FALSE |` `0x00410134 |`\n```\n27 | quit | 0x0040DF67 | 45 | Software | 0x0040DF72 | 46 | Microsoft |\n0x00412603 | 63 | pstorec.dll | 0x0041260E | 86 | Internet Explorer |\n0x00409FB5 | 89 | %s TRUE %s %s %d %s %s | 0x0040BB25 | 96 | logins |\n\n```\n\n-----\n\n```\n0x0040BB3D | 97 | encryptedUsername | 0x0040BB49 | 98 | encryptedPassword |\n0x0040C5CF | 89 | %s TRUE %s %s %d %s %s | 0x0040F83F | 119 | dotbit.me |\n0x0040F5DF | 122 | %S %s HTTP/1.1 %SContent-Length: %d | 0x0040FF36 | 140 |\n%FULLDISK% | 0x0040FF43 | 141 | %NETWORK% | 0x00410CCE | 143 | %02d-%02d%02d %d:%02d:%02d | 0x00410A5E | 144 | MachineGuid: %S | 0x00410ADD | 145 |\nIP: %s | 0x00410B0A | 146 | CPU: %s (%d cores) | 0x00410B91 | 147 | RAM: %s\nMB | 0x00410C03 | 148 | Screen: %dx%d | 0x00410CDB | 150 | LT: %s\n(UTC+%d:%d) | 0x00410D57 | 151 | GPU: | 0x00410E0A | 152 | Layouts: |\n0x00410E72 | 153 | Software: | 0x004096EA | 154 | PWD | 0x00409704 | 155 |\nCRED_DATA | 0x00409711 | 156 | CREDIT_CARD | 0x0040971E | 157 |\nAUTOFILL_DATA | 0x004096F7 | 158 | IMPAUTOFILL_DATA | 0x00410928 | 159 |\nSYSINFORMATION | 0x004097F3 | 160 | FFFILEE | 0x0040FF1C | 161 |\n__DELIMM__ | 0x0040FF29 | 162 | __GRABBER__ | 0x00405912 | 166 |\nwininet.dll | 0x00405922 | 167 | winhttp.dll | 0x00405932 | 168 |\nws2_32.dll | 0x00405942 | 169 | user32.dll | 0x00405952 | 170 |\nshell32.dll | 0x00405962 | 171 | advapi32.dll | 0x00405972 | 172 |\ndnsapi.dll | 0x00405982 | 173 | netapi32.dll | 0x00405992 | 174 |\ngdi32.dll | 0x004059A2 | 175 | gdiplus.dll | 0x004059B2 | 176 |\noleaut32.dll | 0x004059C2 | 177 | ole32.dll | 0x004059D2 | 178 |\nshlwapi.dll | 0x004059E2 | 179 | userenv.dll | 0x004059F2 | 180 |\nurlmon.dll | 0x00405A02 | 181 | crypt32.dll | 0x00405A12 | 182 | mpr.dll ##\n\n```\nConclusion In my experience, scripting in Ghidra is much easier when done with Java. Even\nthough you might not like the language, the documentation and eclipse integration is\nawesome which really speeds up the process. Apart from previously published snippets this\npost also covers parsing of assembly instructions. The KputStealer family yields yet another\ngood example for string obfuscation and a good exercise on how to find and reverse\nengineer it. This particular case also shows a situation where the decompiled failed and\nneeds some help from the analyst.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-26 - use Ghidra to Decrypt Strings of KPOTstealer Malware.pdf"
    ],
    "report_names": [
        "2020-04-26 - use Ghidra to Decrypt Strings of KPOTstealer Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536218,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653787164,
    "ts_modification_date": 1653787164,
    "files": {
        "pdf": "https://archive.orkl.eu/a1a45d096096f328b81296defb34d02e71796e19.pdf",
        "text": "https://archive.orkl.eu/a1a45d096096f328b81296defb34d02e71796e19.txt",
        "img": "https://archive.orkl.eu/a1a45d096096f328b81296defb34d02e71796e19.jpg"
    }
}