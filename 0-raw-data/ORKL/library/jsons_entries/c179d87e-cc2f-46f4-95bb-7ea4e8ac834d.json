{
    "id": "c179d87e-cc2f-46f4-95bb-7ea4e8ac834d",
    "created_at": "2023-01-12T15:10:41.15734Z",
    "updated_at": "2025-03-27T02:08:40.403597Z",
    "deleted_at": null,
    "sha1_hash": "58a4cd8bc6e2f5671fb1ec545a540b446e151497",
    "title": "2018-01-16 - Anatomy of the thread suspension mechanism in Windows (Windows Internals)",
    "authors": "",
    "file_creation_date": "2022-05-28T17:02:42Z",
    "file_modification_date": "2022-05-28T17:02:42Z",
    "file_size": 1227240,
    "plain_text": "# Anatomy of the thread suspension mechanism in Windows (Windows Internals)\n\n**[ntopcode.wordpress.com/2018/01/16/anatomy-of-the-thread-suspension-mechanism-in-windows-windows-internals/](https://ntopcode.wordpress.com/2018/01/16/anatomy-of-the-thread-suspension-mechanism-in-windows-windows-internals/)**\n\nJanuary 16, 2018\n\n## Introduction\n\nProcess suspension is a technique which is quite well-known, and it is used for a variety of reasons\n(even by malicious software sometimes). The term ‚Äúsuspension‚Äù means ‚Äústopping‚Äù something, and\nin-case you did not guess it yet, ‚Äúprocess suspension‚Äù is a technique to temporarily ‚Äústop‚Äù a running\nprocess. If you are suspended from school then you won‚Äôt be attending for the duration you‚Äôre\nsuspended for, and when the term is used with a process, the process won‚Äôt be carrying out any\noperations whilst it‚Äôs suspended.\n\nWhen you suspend a process, the threads of the process will be set to a suspended state; the\nthreads of a process are responsible for processing the code belonging to the process ‚Äì the CPU\nexecutes the instructions. Usually, a process will have more than one thread, and this will allow the\nprocess to execute several operations at the same time simultaneously. If we were to suspend one\nof the running threads, then the targeted thread would be postponed from carrying out any\noperations until it has been resumed. If we were to suspend each thread contained under the\nprocess object, then we would have successfully suspended the process! To cut it short, process\n\n\n-----\n\nsuspension is an operation which relies on suspending the threads of a process ‚Äì this cuts off code\nexecution until we resume the process, which consists of resuming each thread under the process\nwhich we put into a suspended state.\n\nWhen a process is being spawned, there will be a main thread for the process and it will be in a\nsuspended state until initialisation of the newly starting process has been completed. Even if the\nrequester of the process spawn operation does not specify the CREATE_SUSPENDED flags, the\nprocess will still be started with a suspended state by the Windows loader until initialisation has been\nsuccessfully completed. When the process is ready to start running it‚Äôs own code due to the\nWindows loader being finished, it will resume the main thread which is maintained with a suspended\nstate until this point (unless the CREATE_SUSPENDED flags were specified by the requester of the\nprocess spawn). The resume operation for the main thread at this point in time will lead to a routine\nknown as NtResumeThread (NTDLL) being invoked ‚Äì a system call is performed by the\nNtResumeThread stub present in NTDLL to get the real NtResumeThread routine invoked (which\nresides under kernel-mode memory ‚Äì NTOSKRNL which is the Windows Kernel to be precise).\n\nThis article will be broken into separated sections. The first section will be discussing user-mode,\nand the second section will be discussing kernel-mode. In both sections, suspending and resuming\na process‚Äô threads will be discussed.\n\n## Section 1 ‚Äì User-Mode\n\nWhen it comes down to suspending a process from user-mode, you have a few options.\n\nInvoke NtSuspendProcess (NTDLL) which is undocumented. [1]\nEnumerate the threads of the targeted process and invoke NtSuspendThread (NTDLL). [2]\n[Enumerate the threads of the targeted process and invoke SuspendThread (KERNEL32). [3]](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686345(v=vs.85).aspx)\n\n**[1] ‚Äì The first method noted, via NtSuspendProcess, is the most minimal solution. At the same**\ntime however, it is also one of the most unreliable. NtSuspendProcess is not officially documented\nby Microsoft (despite being documented by third-parties for several years), which can only make you\nwonder why they are yet to document it themselves considering it is so widely exposed to the public\nalready ‚Äì it would take them barely any time to document it over at the Microsoft Developer Network\n(MSDN).\n\nThe function takes in one parameter only which needs to be the handle to the process being\ntargeted for suspension, and thus the data-type of this singular parameter is of HANDLE (VOID*).\n\nI‚Äôve left a type-definition for the NtSuspendProcess routine below.\n```\ntypedef NTSTATUS(NTAPI *pNtSuspendProcess)(\n  HANDLE ProcessHandle\n);\n\n```\nWhen you invoke NtSuspendProcess (NTDLL), the system performs a transition operation via a\nsystem call to cause NtSuspendProcess (NTOSKRNL) to become invoked. We can verify these\nfindings by taking a look at NTDLL.DLL for the NtSuspendProcess exported routine.\n\n\n-----\n\nNtSuspendProcess function prologue under NTDLL.\nIf we remember back to what I have previously said at the start of this article, process suspension\nworks by suspending the threads of the targeted process. How does NtSuspendProcess work then?\nNtSuspendProcess will lead down a path which has one end-result only. The end-result is the\nthreads of the targeted process being enumerated and each found thread during the enumeration\nbeing applied for suspension.\n\nI‚Äôve created a very straight-forward user-mode snippet based in C on invoking NtSuspendProcess\n(NTDLL) for demonstration purposes. You‚Äôll need to include the <stdio.h> and <windows.h> libraries\nand add a main entry-point routine to compile and test it out.\n\n\n-----\n\n```\n#define STATUS_INSUFFICIENT_RESOURCES 0xC000009A\ntypedef _Return_type_success_(return >= 0) LONG NTSTATUS;\ntypedef NTSTATUS *PNTSTATUS;\n#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)\ntypedef NTSTATUS(NTAPI *pNtSuspendProcess)(\n  HANDLE ProcessHandle\n);\npNtSuspendProcess fNtSuspendProcess;\nBOOLEAN InitializeExports()\n{\n  HMODULE hNtdll = GetModuleHandle(\"NTDLL\");\n  if (!hNtdll)\n  {\n    return FALSE;\n  }\n  fNtSuspendProcess = (pNtSuspendProcess)GetProcAddress(hNtdll,\n    \"NtSuspendProcess\");\n  if (!fNtSuspendProcess)\n  {\n    return FALSE;\n  }\n  return TRUE;\n}\nNTSTATUS NTAPI NtSuspendProcess(\n  HANDLE ProcessHandle\n)\n{\n  if (!fNtSuspendProcess)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fNtSuspendProcess(ProcessHandle);\n}\nBOOLEAN WINAPI SuspendProcess(\n  HANDLE ProcessHandle\n)\n{\n  if (!ProcessHandle)\n  {\n    return FALSE;\n  }\n  return (NT_SUCCESS(NtSuspendProcess(ProcessHandle)))\n    ? TRUE : FALSE;\n}\n\n```\nHere is a break-down on how the snippet is supposed to be used/work.\n\n\n-----\n\n1. The InitializeExports routine (return-type of BOOLEAN) will setup NtSuspendProcess for\n\nusage via a dynamic import. pNtSuspendProcess is a type-definition for the function structure,\nand this is used with a global variable which gets pointed to the address of NtSuspendProcess.\nThis means we can simply treat fNtSuspendProcess like a normal function however it will lead\nto NtSuspendProcess (NTDLL) invocation since it points to NtSuspendProcess (NTDLL)\naddress.\n2. After opening a handle to a process (with at-least the PROCESS_SUSPEND_RESUME\n\naccess rights present), it can be passed as the parameter for the SuspendProcess routine.\nThis routine has the WINAPI macro however this simply represents __stdcall, and the NTAPI\nmacro also represents __stdcall ‚Äì __stdcall is a calling convention. Just to be clear and not\ncause potential confusion, SuspendProcess is not a Win32 API routine, I simply used the\nWINAPI macro to represent __stdcall because I prefer to do so.\n3. The SuspendProcess routine will call the NtSuspendProcess routine. The NtSuspendProcess\n\nroutine which is manually declared will call fNtSuspendProcess which points to the address of\nNtSuspendProcess (NTDLL) as previously noted.\n\n**[2] ‚Äì The second method noted, via enumeration of the targeted process‚Äô threads and then**\n**calling NtSuspendThread on each one, is also potentially unstable due to it being undocumented**\nlike the NtSuspendProcess method noted under [1], however it does the job.\n\nNtSuspendThread is not an ‚Äúofficially‚Äù documented routine in the same way that NtSuspendProcess\nisn‚Äôt either. However, NtSuspendThread does not have a complicated structure. The routine takes in\ntwo parameters: HANDLE, and ULONG* (PULONG). The former is for the handle of the thread\nbeing targeted by suspension (we must first acquire a handle to the thread we are targeting in the\nsame sense that we must have a handle to the target process before we can use\nNtSuspendProcess ‚Äì the handle must have at-least THREAD_SUSPEND_RESUME access rights),\nand the latter is to do with a counter of suspensions (as far as I am aware ‚Äì although it is entirely\noptional and whenever I‚Äôve needed to use this routine I‚Äôve never had to make use of the second\nparameter).\n\nI‚Äôve left a type-definition for the NtSuspendThread routine below.\n```\ntypedef NTSTATUS(NTAPI *pNtSuspendThread)(\n  HANDLE ThreadHandle,\n  PULONG PreviousSuspendCount OPTIONAL\n);\n\n```\nJust like with NtSuspendProcess (NTDLL), when we invoke NtSuspendThread (NTDLL), a system\ncall is performed by the system to transition from user-mode to kernel-mode; the end-result is\nNtSuspendThread (NTOSKRNL) being invoked. The handy thing about NtSuspendThread though is\nthat we can suspend only X amount of threads, and leave some threads resumed, a perk which\ndoes not come with NtSuspendProcess of course.\n\nA quick snippet of how you would go about using NtResumeThread is left below for you to take a\nquick peek at.\n\n\n-----\n\n```\ntypedef NTSTATUS(NTAPI pNtSuspendThread)(\n  HANDLE ThreadHandle,\n  PULONG PreviousSuspendCount OPTIONAL\n);\npNtSuspendThread fNtSuspendThread;\nBOOLEAN InitializeExports()\n{\n  HMODULE hNtdll = GetModuleHandle(\"NTDLL\");\n  if (!hNtdll)\n  {\n    return FALSE;\n  }\n  fNtSuspendThread = (pNtSuspendThread)GetProcAddress(hNtdll,\n    \"NtSuspendThread\");\n  if (!fNtSuspendProcess ||\n    fNtSuspendThread)\n  {\n    return FALSE;\n  }\n  return TRUE;\n}\nNTSTATUS NTAPI NtSuspendThread(\n  HANDLE ThreadHandle,\n  PULONG PreviousSuspendCount\n)\n{\n  if (!fNtSuspendThread)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fNtSuspendThread(ThreadHandle,\n    PreviousSuspendCount);\n}\nBOOLEAN WINAPI SuspendThreadWrapper(\n  HANDLE ThreadHandle\n)\n{\n  if (!ThreadHandle)\n  {\n    return FALSE;\n  }\n  return (NT_SUCCESS(NtSuspendThread(\n    ThreadHandle,\n    NULL))) ? TRUE : FALSE;\n}\n\n```\n\n-----\n\nIn case you re wondering why I took the leap with the routine naming and used\n‚ÄúSuspendThreadWrapper‚Äù instead of ‚ÄúSuspendThread‚Äù, it‚Äôs because there‚Äôs already a Win32 API\nroutine called ‚ÄúSuspendThread‚Äù. The SuspendThread routine is exported by KERNEL32.DLL and it\nwill do the same thing we are doing in our wrapper routine (more-or-less at-least) ‚Äì it will call\nNtSuspendThread (NTDLL).\n\nBear in mind that you will need to have at-least THREAD_SUSPEND_RESUME access rights on\nthe handle you attempt to use with NtSuspendThread. To acquire the handle to the thread, you could\nuse NtOpenThread (NTDLL), or preferably it‚Äôs Win32 API equivalent which would be OpenThread\n(KERNEL32).\n\nUnless you need to suspend a certain amount of threads of a process, it is likely going to be more\nconvenient to use NtSuspendProcess. The reason being that NtSuspendProcess (NTOSKRNL ‚Äì\ninvoked after the NTDLL system call) will call a kernel-mode routine to handle the process\nsuspension, and this routine will automatically enumerate through all the threads of the targeted\nprocess and call another kernel-mode routine to handle suspension. Whereas, if you are\nenumerating the threads and suspending them yourself, you‚Äôre doing more yourself to replicate the\nsame functionality. Unless a routine like NtOpenProcess/NtSuspendProcess has been hooked and\nyou don‚Äôt fancy bypassing the set hooks, and NtOpenThread/NtSuspendThread was forgotten\nabout, then you may as well use NtSuspendProcess if you need to suspend a process.\n\n**[3] ‚Äì The third method noted, via enumeration of the targeted process‚Äô threads and then**\n**calling SuspendThread on each one, is without a doubt the most stable technique. At the same**\ntime though, it‚Äôs a bit more ‚Äúobvious‚Äù. You‚Äôll neither be able to perform a manual transition from usermode to kernel-mode to bypass any hooks since it isn‚Äôt a Nt* routine which is one down-fall ‚Äì it is\nstill the most documented mechanism for accomplishing process suspension though, and for this\nreason, it is recommended that you use this technique unless you have specific requirements which\nprevents you from doing so.\n\nDespite SuspendThread being the most documented mechanism for accomplishing suspension\nfunctionality, NtSuspendProcess/NtSuspendThread have been around for an extremely long time,\nsince Windows 2000 I believe. The chances of these routines being deprecated are extremely small,\nit would be like making NtOpenProcess obsolete, which I am sure is not going to happen any-time\nsoon. They are core routines in the Windows Kernel, so whether you go down the undocumented\nand less-stable route for this or not, as long as you know how to use the routines properly you likely\nwon‚Äôt have any issues from patch updates any-time soon to say the least.\n\nFor the record, SuspendThread (KERNEL32) will call NtSuspendThread (NTDLL). As expected,\nNtSuspendThread (NTDLL) will perform a system call and then NtSuspendThread (NTOSKRNL) will\nbe invoked; NtSuspendThread is not exported by the Windows Kernel however it can still be\naccessed if you can find the address via pattern scanning or the System Service Descriptor Table\n(SSDT).\n\nSince SuspendThread is documented by Microsoft over at the Microsoft Developer Network\n(MSDN), I‚Äôve left the type definition for the routine below along with the link to the official\ndocumentation.\n\n\n-----\n\n```\ntypedef DWORD(WINAPI pSuspendThread)(\n  HANDLE ThreadHandle\n);\n\n```\n[https://msdn.microsoft.com/en-us/library/windows/desktop/ms686345(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686345(v=vs.85).aspx)\n\nThe routine can be used the same way as the SuspendThreadWrapper routine we saw earlier which\nwould call the NtSuspendThread proxy routine. The return value for SuspendThread (KERNEL32)\nwill be the value returned for the PreviousSuspendCount parameter which is the parameter we\npreviously ignored with the NtSuspendThread call.\n```\nDWORD Status = SuspendThread(GetCurrentThread());\nif (Status)\n{\n  printf(\"Thread suspended\\n\");\n}\n\n```\nIf the suspension operation is successful, you‚Äôll never reach the conditional statement because the\nthread which is supposed to be processing those instructions will be in a suspended state. The\nconditional statement won‚Äôt be reached until the suspended thread has been resumed (by another\nthread which is running or by another process).\n\nWe‚Äôve talked a bit about how we can suspend a process (and how this relies on targeting the\nthreads) or suspend specific threads, but what about resuming them? We‚Äôll move onto this now\nbefore progressing to the kernel-mode section of this article.\n\nWhen it comes down to resuming a process from user-mode, you have a few options.\n\nInvoke NtResumeProcess (NTDLL) which is undocumented. [1]\nEnumerate the threads of the targeted process and invoke NtResumeThread (NTDLL). [2]\nEnumerate the threads of the targeted process and invoke ResumeThread (KERNEL32). [3]\n\nIn-case you‚Äôre yet to notice, we are doing the same as when we are performing suspension, but inreverse. For example, our first option for process suspension would be by invoking\nNtSuspendProcess (NTDLL), and our first option for resuming a process would be to invoke\nNtResumeProcess (NTDLL). NtSuspendProcess, NtSuspendThread and SuspendThread all have a\n‚ÄúResume‚Äù variant; simply replace the ‚ÄúSuspend‚Äù key-word in the function routines with ‚ÄúResume‚Äù\nand bobs your uncle!\n\nAs noted with NtSuspendProcess and NtSuspendThread about stability, NtResumeProcess and\nNtResumeThread are in the same boat; they aren‚Äôt officially documented by Microsoft and there\nmust be a reason for this. However, worrying about it isn‚Äôt really something you should do,\nconsidering they are core routines used in Windows and the likelihood of them being made obsolete\nis very low.\n\nI‚Äôve left an example below for NtResumeProcess and NtResumeThread. It is more-or-less the same\nas the process suspension examples, except for resume instead. You can use ResumeThread the\nexact same way you use SuspendThread.\n\n\n-----\n\n```\ntypedef NTSTATUS(NTAPI pNtResumeProcess)(\n  HANDLE ProcessHandle\n);\ntypedef NTSTATUS(NTAPI *pNtResumeThread)(\n  HANDLE ThreadHandle,\n  PULONG PreviousSuspendCount OPTIONAL\n);\npNtResumeProcess fNtResumeProcess;\npNtResumeThread fNtResumeThread;\nBOOLEAN InitializeExports()\n{\n  HMODULE hNtdll = GetModuleHandle(\"NTDLL\");\n  if (!hNtdll)\n  {\n    return FALSE;\n  }\n  fNtResumeProcess = (pNtResumeProcess)GetProcAddress(hNtdll,\n    \"NtResumeProcess\");\n  fNtResumeThread = (pNtResumeThread)GetProcAddress(hNtdll,\n    \"NtResumeThread\");\n  if (!fNtResumeProcess ||\n    !fNtResumeThread)\n  {\n    return FALSE;\n  }\n  return TRUE;\n}\nNTSTATUS NTAPI NtResumeProcess(\n  HANDLE ProcessHandle\n)\n{\n  if (!fNtResumeProcess)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fNtResumeProcess(ProcessHandle);\n}\nNTSTATUS NTAPI NtResumeThread(\n  HANDLE ThreadHandle,\n  PULONG PreviousSuspendCount\n)\n{\n  if (!fNtResumeThread)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fNtResumeThread(ThreadHandle,\n\n```\n\n-----\n\n```\n    PreviousSuspendCount);\n}\nBOOLEAN WINAPI ResumeProcess(\n  HANDLE ProcessHandle\n)\n{\n  if (!ProcessHandle)\n  {\n    return FALSE;\n  }\n  return (NT_SUCCESS(NtResumeProcess(ProcessHandle)))\n    ? TRUE : FALSE;\n}\nBOOLEAN WINAPI ResumeThreadWrapper(\n  HANDLE ThreadHandle\n)\n{\n  if (!ThreadHandle)\n  {\n    return FALSE;\n  }\n  return (NT_SUCCESS(NtResumeThread(\n    ThreadHandle,\n    NULL))) ? TRUE : FALSE;\n}\n\n```\nWe can check to ensure that the following is true with some simple static reverse engineering.\n\n1. SuspendThread (KERNEL32) -> NtSuspendThread (NTDLL)\n2. ResumeThread (KERNEL32) -> NtResumeThread (NTDLL)\n\nThe first thing we are going to do is retrieve the address of SuspendThread (KERNEL32) and we‚Äôll\nset a break-point. I‚Äôm using Visual Studio 2017 and I‚Äôll be using the Visual Studio debugger for this\ntask.\n\nSnippet for obtaining the\n\naddress to SuspendThread (KERNEL32).\nWhen we debug and the break-point is hit, we can step into/over and then check the value stored\nunder the SuspendThreadAddress variable.\n\nDebugging the snippet from above and checking the value held under SuspendThreadAddress after\nstepping into w/ the debugger.\n\n\n-----\n\nIf you go to the top menu in Visual Studio and select Debug -> Windows -> Disassembly (Ctrl + Alt\n+ D short-key by default) then you can bring up the Disassembly view. This option won‚Äôt be possible\nunless you‚Äôre currently debugging the program.\n\nAn\n\nexample of what Visual Studio‚Äôs Disassembly view looks like.\nIf you notice at the top of the Disassembly view we have a text label saying ‚ÄúAddress‚Äù followed by a\ntext-box control. We can put in the address we got back for SuspendThread (KERNEL32) and it will\ntake us to the disassembly at that location; KERNEL32.DLL is loaded under the address space of\nour currently-debugged process and the SuspendThread address we got given back from\nGetProcAddress is present under memory for the loaded KERNEL32 module in our process ‚Äì we\ncan view the disassembly using the Visual Studio debugger.\n\nHighlight of the Address bar on the Disassembly view.\n\n\n-----\n\nDisassembly for SuspendThread (KERNEL32).\nNow we‚Äôre viewing the disassembly for the SuspendThread function prologue. Hey! What is going\non here? Why are we simply redirecting execution flow to another address via a JMP instruction?\n\n**The truth is that the real stub for SuspendThread is now located under another module,**\n**named KernelBase.dll (KERNELBASE) since Windows 8. On previous versions of Windows,**\nsuch as Windows Vista and 7, it would have been under KERNEL32 as it is known to be‚Ä¶ But many\nchanges were made in Windows 8 and those changes still haunt us to this day on the latest version\nof Windows 10. On 32-bit versions of Windows, a 32-bit compiled copy of kernelbase.dll can be\nfound under SystemDrive:\\WINDOWS\\System32\\, and on 64-bit versions of Windows, a 32-bit\ncompiled copy can be found under SystemDrive:\\WINDOWS\\SysWOW64\\ and a 64-bit compiled\ncopy can be found under SystemDrive:\\WINDOWS\\System32\\.\n\nSystem32 folder\n\nshow-casing the KernelBase.dll is present.\nWe‚Äôre going to take a quick peak at KernelBase.dll in Interactive Disassembler (IDA) for static\ndisassembly. We‚Äôll start by making sure there there‚Äôs an export available for the SuspendThread\nroutine.\n\nIDA\n\nExports tab showing that SuspendThread is an export of KernelBase.dll.\nWell would you look at that! There‚Äôs an export for SuspendThread under KernelBase.dll. We‚Äôll take a\nlook at it now.\n\n\n-----\n\nDisassembly for SuspendThread (KERNELBASE).\nLooking at the above function prologue, you may already have noticed the pink styled text which\ncontains the key-word ‚ÄúNtSuspendThread‚Äù. Yes, SuspendThread (KERNELBASE) does call\nNtSuspendThread (NTDLL); after all, NtSuspendThread (NTDLL) performs the system call so\nthe functionality (in-which resides in instructions under kernel-mode memory) can really be invoked.\nThe SuspendThread routine will do some other things aside from calling NtSuspendThread, and\nwe‚Äôll note these down now for educational purposes.\n\nPseudo-code of SuspendThread\n\n(KERNELBASE).\n\n1. Sets up two local variables.\n\n_result is returned at the end of the routine as the return value for the SuspendThread_\nroutine. The caller gets this value returned back to them to determine if the operation\nwas/wasn‚Äôt successful.\n_v2 is returned at the end of the routine and it will represent the ULONG return for the_\nsecond parameter of the NtSuspendThread call. If we remember back to\nNtSuspendThread, there was the PreviousSuspendCount parameter which we were\npassing as NULL; SuspendThread (KERNELBASE) will have this value returned to the\ncaller if the operation is successful.\n2. Invoke NtSuspendThread (NTDLL) and set the value of the <v2> local variable as the\n\nPreviousSuspendCount target (return that data to the <v2> variable).\n3. If the NtSuspendThread (NTDLL) call does not return STATUS_SUCCESS (which is the same\n\nas 0 ‚Äì 0x00000000) then invoke BaseSetLastNTError (Win32 API) and set the value of result\nto -1 (which will indicate failure to the caller).\n\n\n-----\n\n4. If the NtSuspendThread (NTDLL) call does return STATUS_SUCCESS (successful), then set\n\nthe value of result to be returned to the caller as the value held under the v2 variable.\n5. Return back the value of result\n\nNOTE: result and v2 aren‚Äôt the real variable names in the KernelBase.dll source-code. These names\nare generated automatically by IDA.\n\nIt‚Äôs more or less pretty straight forward and follows this routine for ResumeThread (KERNELBASE)\nalso but we‚Äôll look at this as well anyway.\n\nWe can see that the same process is being repeated except NtResumeThread (NTDLL) is being\ninvoked instead of NtSuspendThread (NTDLL).\n\nFor the record, the BaseSetLastNTError routine will invoke RtlSetLastWin32Error. The end-result is\nthe correct error code being set as the ‚Äúlast error‚Äù so the caller can invoke GetLastError if the\noperation fails and acquire additional information regarding what went wrong; this also means that\nthe NTSTATUS error code returned by NtSuspendThread/NtResumeThread is converted to a DOS\nerror code via RtlNtStatusToDosError.\n\n**We are going to end this section of the article here and progress on to discussing kernel-**\n**mode. The next section will show examples of how to suspend/resume a process from kernel-mode,**\nalong with explanations about how\nNtSuspendProcess/NtSuspendThread/NtResumeProcess/NtResumeThread actually work in the\nkernel.\n\n## Section 2 ‚Äì Kernel-Mode\n\nIn kernel-mode, things a lot different than in user-mode. For starters, you don‚Äôt have access to the\nWin32 API in kernel-mode; you can communicate to a user-mode process via Inter-Process\nCommunication (IPC) or perform kernel-mode code injection targeting a user-mode process to get\nWin32 API calls invoked but this is not the same as directly using such from kernel-mode, which you\ncannot do.\n\n\n-----\n\nWhen working in kernel-mode, you have access to the Native API (NTAPI). The Native API includes\nroutines with an Nt* prefix which are exported by NTDLL (and those routines exported by NTDLL will\nperform a system call ‚Äì whereas in kernel-mode you don‚Äôt need to perform a system call), however\nyou won‚Äôt have access to all of them by default ‚Äì there is also the kernel-mode only routines which\ndon‚Äôt follow the Nt* style.\n\nWhen a user-mode process directly or indirectly invokes an NTAPI routine and a system call is\nperformed for user-mode to kernel-mode transition, a kernel-mode routine such as\nKiSystemCall32/KiSystemCall64 (on the latest versions of Windows 10 after the recent patch\nupdates regarding Meltdown, there is now\nKiSystemCall32Shadow/KiSystemCall64Shadow/KiSystemCall32AmdShadow/KiSystemCall64Shadow)\nwill be invoked. These routines will call other routines, and a kernel-mode routine named\nKiSystemServiceRepeat will eventually be invoked. The KiSystemServiceRepeat routine will access\nthe System Service Descriptor Table (KeServiceDescriptorTable) which is nothing more than a\ndispatch table (another saying of an ‚Äúarray‚Äù) which contains pointer addresses ‚Äì each pointer\naddress represents the address of a Native API routine within the address space of NTOSKRNL (the\nWindows Kernel). There are routines which can be invoked from user-mode via a system call and\nthere are routines which are ‚Äúkernel-mode only‚Äù (and thus cannot be invoked from user-mode via a\nsystem call). The routines which can be invoked via a system call have an entry in the\nKeServiceDescriptorTable, and there‚Äôs also a ‚ÄúShadow‚Äù version which would be\nKeServiceDescriptorTableShadow to also allow access to pointer addresses of win32k.sys routines.\n\nThis article isn‚Äôt about going through the process of how a system call works and how the kernel\nhandles them, it‚Äôs about suspension of processes and how this mechanism works. However, this is\nall related to the topic because both NtSuspendProcess and NtSuspendThread are not exported by\nNTOSKRNL. What does this mean? It means that by default, you do not have access to either of\nthe routines in kernel-mode when developing a kernel-mode device driver. This can be irritating if\nyou have a genuine reason to suspend a process in kernel-mode, and you may not wish to\ncommunicate back down to a user-mode component to invoke NtSuspendProcess\n(NTDLL)/NtSuspendThread (NTDLL) for you.\n\nThere are two options in this scenario if you don‚Äôt wish to work with a user-mode component (which\nwould be the most stable option available at this moment in time ‚Äì and I suggest if you do have a\nuser-mode component such as a Windows Service, you should make use of such properly).\n\n1. Access the KeServiceDescriptorTable manually and use this as an entry-point to locating the\n\naddress of NtSuspendProcess/NtSuspendThread.\n2. Find out if there‚Äôs an exported kernel-mode routine which can be used for process/thread\n\nsuspension.\n\nThe first method is very straight forward on 32-bit systems because KeServiceDescriptorTable is\nactually exported by the Windows Kernel for 32-bit systems. This means you can find the address to\nKeServiceDescriptorTable effortlessly. Sadly, this isn‚Äôt the case for 64-bit systems; Microsoft\nimplemented a feature called PatchGuard for 64-bit versions of Windows only at the start of\nWindows Vista and PatchGuard contains a whole wide-range of functionality however one thing they\ndid when they introduced PatchGuard was not export the KeServiceDescriptorTable. Please do not\n\n\n-----\n\nbe confused, accessing the System Service Descriptor Table on a 64-bit system will not cause a\nBSOD as long as the calculations are correct, however it‚Äôs more hassle to make use of it due to the\nfact that it is no longer exported for 64-bit systems.\n\nIf you want to go down the route of accessing the System Service Descriptor Table on a 64-bit\nsystem, it isn‚Äôt all that complicated. You can find the address of\nKiSystemCall64/KiSystemCall64Shadow/KiSystemCall64AmdShadow via the IA32_LSTAR Model\nSpecific Register (MSR) and then you can locate the non-exported kernel-mode routine\nKiSystemServiceRepeat not far off from the address pointed to by IA32_LSTAR MSR. As we‚Äôve\nalready established earlier on, the address of the KeServiceDescriptorTable is exposed in the\nKiSystemServiceRepeat routine. People have been using this technique to locate the SSDT on 64bit systems for countless years now, but you should avoid doing this unless you really need to,\nbecause Microsoft can change something at any time and prevent your source code from working\non the updated systems.\n\nThankfully, the idea noted in our second option is a valid option for us when it comes to process\nsuspension from kernel-mode. As it turns out, there‚Äôs a routine exported by NTOSKRNL which is\ncalled by NtSuspendProcess. The sad part is that there is no exported routine for singular thread\nsuspension, but I suspect most people trying to suspend from kernel-mode will be targeting a whole\nprocess and not after suspending X amount of threads under a process only. The exported routine is\ncalled PsSuspendProcess, and it isn‚Äôt officially documented by Microsoft.\n\nExports of NTOSKRNL ‚Äì highlighting PsSuspendProcess.\nWe‚Äôre going to take a look at how PsSuspendProcess works but we‚Äôre going to take a look at\nNtSuspendProcess beforehand. As previously noted, NtSuspendProcess is not exported by\nNTOSKRNL, however it does have an entry under the System Service Descriptor Table, which will\nhave the pointer address to it‚Äôs routine within the address space of NTOSKRNL ‚Äì if this wasn‚Äôt the\ncase then the Windows Kernel wouldn‚Äôt know the location in-memory of the routine when a system\ncall was performed for it to be invoked.\n\n\n-----\n\nDisassembly for NtSuspendProcess (NTOSKRNL).\nIn the NtSuspendProcess routine, there are two important things which will happen.\n\n1. The handle is used to retrieve an object. The handle is passed in to the routine as the\n\nparameter which we learnt about during the user-mode section, however the routine doesn‚Äôt\nactually send the handle anywhere itself. Instead, it retrieves an object to the process using the\nhandle via an undocumented, non-exported kernel-mode only routine, named\nObpReferenceObjectByHandleWithTag. ObpReferenceObjectByHandleWithTag works by\naccessing an undocumented, non-exported table stored in the kernel; the routine will use other\nroutines such as ExpLookupHandleTableEntry. An object for a process in kernel-mode would\nbe a pointer structure to the EPROCESS (PEPROCESS) kernel-mode structure for that\nprocess ‚Äì the EPROCESS structure contains many fields which stores data about that\nprocess. There‚Äôs also the KPROCESS structure which is the first field of the EPROCESS\nstructure and contains a lot of data about the process in question.\n2. Invoke PsSuspendProcess. NtSuspendProcess doesn‚Äôt really do anything in itself, it just\n\nforwards execution control to PsSuspendProcess. The only reason it calls\nObpReferenceObjectByHandleWithTag in advance to retrieve an object to the process\n(PEPROCESS -> pointer structure of EPROCESS to be precise) is because\nPsSuspendProcess does not accept a handle as the parameter, but it accepts an object\ninstead.\n\nIf you go snooping around NtSuspendProcess with static disassembly and try to generate pseudocode for it, you‚Äôll likely get back a messy view which will appear ugly at first. I cleaned up the datatypes and variable names a bit so it is a bit more pleasant and understandable when looking at it.\n\n\n-----\n\nPseudo-code for NtSuspendProcess (NTOSKRNL).\nThe following is done in-order.\n\n1. Two local variables are setup. One has a data-type of NTSTATUS and the other has a data\ntype of PEPROCESS (pointer structure variant of EPROCESS). Of course the variable names\nin the screen-shot are not the same ones used in the Windows source code, I re-named them.\nEarlier in previous screen-shots, variable names like ‚Äúv2‚Äù are neither really from the source\ncode. IDA just sets it to these by default and you can change them while reversing.\n2. The local variable which has a data-type of NTSTATUS is assigned a value of the return value\n\nfrom the ObpReferenceObjectByHandleWithTag call. This routine is now invoked;\nObpReferenceObjectByHandleWithTag returns an NTSTATUS error code.\n3. The invocation of ObpReferenceObjectByHandleWithTag will assign a value to the local\n\nvariable which has a data-type of PEPROCESS (named Process as the variable name by\nmyself). If you look at the 6 parameter for the ObpReferenceObjectByHandleWithTag call,th\nwe‚Äôre passing a pointer to our PEPROCESS variable ‚Äì the routine will use this to set the value\nof our variable in the called routine.\n4. If the NtStatus value represents success (NT_SUCCESS -> >= 0) then the routine progresses\n\nto call PsSuspendProcess and it will perform a clean-up operation with the object to the\nprocess which was previously retrieved via ObfDerferenceObjectWithTag.\n5. The NtStatus value is returned by NtSuspendProcess back to the caller.\n\nI think it‚Äôs about time we take a look at the famous PsSuspendProcess routine, don‚Äôt you?\n\n\n-----\n\nPseudo-code for PsSuspendProcess (NTOSKRNL).\nHere‚Äôs a break-down of how the routine works, I‚Äôll stick to the core parts.\n\n1. The threads of the targeted process are enumerated via PsGetNextProcessThread and a while\n\nloop. The way it works is PsGetNextProcessThread will be called to return a PETHREAD\n(pointer to the ETHREAD structure) object for the first thread found within the targeted process\nand then an operation using the returned PETHREAD will be performed, followed by another\nPsGetNextProcessThread call and a re-start of the loop. PsGetNextProcessThread is an nonexported kernel-mode only routine. When there are no more threads to be found, the returned\nPETHREAD will be nothing (NULL) and this will be caught by the conditional statement which\nchecks if the variable which is supposed to be returned the next PETHREAD (of the next\nthread to be found), and at this point the break instruction is used to exit the while loop since\nthe operation will have no more business regarding thread enumeration.\n2. For each enumerated thread in which a PETHREAD object can be acquired for, the\n\nundocumented and non-exported kernel-mode only routine named PsSuspendThread will be\ncalled, passing the PETHREAD as a parameter.\n3. When an occurrence of a NULL PETHREAD returned value is returned, the operation exits\n\nbecause the loop is exited. Exiting the while loop is followed by the return of the NTSTATUS\nerror code (which could represent success or failure). The return status for PsSuspendProcess\nwill always be STATUS_SUCCESS unless the targeted process is in a state preparing for\ntermination.\n\nWe should see what routine PsSuspendThread will call.\n\n\n-----\n\nPseudo-code for PsSuspendThread (NTOSKRNL).\nPsSuspendThread will call KeSuspendThread, and KeSuspendThread returns a status which is set\nto the value of the second parameter passed in PsSuspendThread as the second parameter.\nHowever, PsSuspendProcess doesn‚Äôt care about the second parameter and thus it doesn‚Äôt check\nthe return status by KeSuspendThread. PsSuspendProcess will only return STATUS_SUCCESS or\nSTATUS_PROCESS_IS_TERMINATING.\n\nThe fuss regarding the acquisition of ‚Äúrun-down protection‚Äù is regarding to preventing the thread\nfrom being ‚Äúterminated‚Äù during the operation. Such would cause system instability and likely would\nbug-check the system because the kernel would then be operating with an object which would no\nlonger be deemed valid.\n\n\n-----\n\nPseudo-code for KeSuspendThread.\nNow here is a more interesting part, but it should get a bit more interesting when we move to\nKiSuspendThread.\n\nKeSuspendThread is invoking a routine called RtlRaiseStatus, but this is only happening depending\non a conditional statement. The conditional statement is put in place to determine whether a\nsuspension of a thread is being taken place in-which the maximum suspension count has already\nbeen met. If we remember back to NtSuspendThread invocation, we had a parameter regarding the\nprevious suspension count which could be returned to us ‚Äì SuspendThread\n(KERNEL32/KERNELBASE) was making use of it happily and returning it as the return value of the\nroutine. Well, it turns out that the maximum suspension count is 127. If the conditional statement is\nmet, a status error code is raised with RtlRaiseStatus. The error code being raised which is\ndisplayed as 0xC000004Ai64 actually translates to 0xC000004A which is the same as\n**STATUS_SUSPEND_COUNT_EXCEEDED.**\n\nThe KiSuspendThread routine is called towards the end of the KeSuspendThread routine. As\nexpected, KiSuspendThread is another undocumented and non-exported kernel-mode only routine.\nKiSuspendThread is actually a bit more interesting though, because it exposes how the whole\nsuspension mechanism in Windows actually works ‚Äì you may be very surprised at how minimal it\ntruly is, and it relies on a documented programming technique which most developers will have used\nboth in kernel-mode and user-mode at-least once in their development time.\n\n\n-----\n\nPseudo-code for KiSuspendThread (NTOSKRNL) 1/2.\n\n\n-----\n\nPseudo-code for KiSuspendThread (NTOSKRNL) 2/2.\nWell, would you look at that!\n\nWe have a call to KiInsertQueueApc which is a step involved in dispatching an Asynchronous\nProcedure Call (APC). Asynchronous Procedure Calls are used for communication all the time ‚Äì in\nfact they have also been abused for thread hijacking as an entry-point for code injection for\nnumerous of years now, and there‚Äôs a technique named Atom Bombing which relies on APC\ninjection as well ‚Äì and the way it works is you target a thread for the APC and you can force the\ntargeted thread to execute the callback routine for the APC event. This in turn, will force the targeted\nthread to execute the code which you wish it to execute. If we wanted to inject code into a usermode process from kernel-mode, we could rely on KeInitializeApc and KeInsertQueueApc ‚Äì of\ncourse this routine is using the non-exported variants though.\n\n**The KiInsertQueueApc does exactly what the routine name implies. It inserts an APC event into**\na queue. It pretty much sets up the PKAPC structure which is used for the APC dispatch operation ‚Äì\nthe PKAPC structure (pointer to KAPC structure) holds data such as the environment for the APC\nevent (e.g. KernelMode or UserMode), the targeted thread, among other data.\n\n**The KiSignalThreadForApc also does what the routine name implies. It will signal the thread for**\nthe APC event as far as I am aware, and this relies on KiSignalThread (another non-exported,\nundocumented kernel-mode routine). However, a flag named KiDisableLightWeightSuspend must be\n\n\n-----\n\nset to TRUE for the KiSignalThreadForApc operation to occur, among several other conditional\nstatements.\n\nThe KiSuspendThread routine will use the ETHREAD structure (PETHREAD because it‚Äôs a pointer\nto the ETHREAD structure) for the current thread being put into a ‚Äúsuspended‚Äù state.\n\nUnder the KTHREAD structure there is data regarding thread suspension, for example, a\nSuspendCount field. The kernel will update such data regarding thread suspension and then the\nthread will be held up waiting for the data to be updated again via KeWaitForSingleObject. An\nAsynchronous Procedure Call is performed so the KeWaitForSingleObject call can be made on the\ntargeted thread and this wait ends when the data is updated again to remove the suspend state.\n\nIf you were expecting some sort of super-human mechanism for ‚Äúthread suspension‚Äù then I am sorry\nfor letting you down. The suspension mechanism evolves around waiting for the semaphore data to\nbe updated to indicate the thread should be resumed ‚Äì the wait is executed in the address space of\nthe targeted process to hold the targeted thread via the APC which was dispatched. It is possible\nthat the semaphore part is not identically correct for the latest versions of Windows, because\nchanges may have been made and I initially remember hearing about this many years ago ‚Äì and\nhave been unable to completely verify that this operation works like this at-least still ‚Äì but it makes\ncomplete sense and I doubt it is inaccurate.\n\nWe have all this talk about thread suspension, but we‚Äôve forgotten all about thread resuming. It isn‚Äôt\nfair for us to give all the attention to PsSuspendProcess, KeSuspendThread and\nKiSuspendThread‚Ä¶ We need to give some love to PsResumeProcess! That‚Äôs right, there‚Äôs an\nexported kernel-mode routine named PsResumeProcess!\n\nExports for NTOSKRNL, show-casing that PsResumeProcess is an export.\nWell this is exciting‚Ä¶ I‚Äôm going to take a leap with my confidence and estimate what the\nPsResumeProcess routine will do.\n\n1. Enumerate through all the threads of the targeted process\n2. Invoke a routine named KeResumeThread\n3. Return an NTSTATUS error code (either STATUS_SUCCESS or\n\n**STATUS_PROCESS_IS_TERMINATING).**\n\n\n-----\n\nPseudo-code for PsResumeProcess (NTOSKRNL).\nLooks like my estimation was right. Some may call me a cheater but that will just be the jealousy\ntalking!\n\nThe PsResumeProcess routine will be called by NtResumeProcess, and we can verify these\nfindings by checking the routine disassembly.\n\n\n-----\n\nDisassembly of NtResumeProcess (NTOSKRNL).\nI highlighted in red the call instruction being used for ObpReferenceObjectByHandleWithTag and\nPsResumeProcess. The only difference between NtSuspendProcess and NtResumeProcess is that\nthe former will be calling PsSuspendProcess and the latter will be calling PsResumeProcess.\n\nSince we‚Äôre looking at those Nt* stubs, we may as well take a look at NtSuspendThread and\nNtResumeThread briefly to see if they will call.\n\n\n-----\n\nPseudo-code for NtSuspendThread (NTOSKRNL).\nNtSuspendThread will just lead down a path of PsSuspendThread, which is also called in\nPsSuspendProcess for each found thread during the enumeration operation. Nothing we‚Äôve not seen\ndone before.\n\nWhat about NtResumeThread though? We really need to stop giving all the attention and love to\nthread suspension and treat thread resuming the same or it might turn rogue out of anger! üòâ\n\n\n-----\n\nPseudo-code for NtResumeThread (NTOSKRNL).\nNtResumeThread will simply call PsResumeThread, which is also called by PsResumeProcess\nduring the thread enumeration operation. Nothing too interesting here either sadly because we‚Äôve\nalready seen it all.\n\nWe‚Äôve done a lot of discussing and not a lot of programming so it‚Äôs time we brought back some C\ncode. This time, the difference is that the example C source-code will be for kernel-mode software\nand not for user-mode software; there are some pre-requisites before you can start developing\nkernel-mode software (e.g. kernel-mode device drivers), however I shouldn‚Äôt have to lay these out\nbecause you shouldn‚Äôt be attempting such a task without having some background in Windows\nkernel-mode software engineering in the first place.\n\nFor tutorials sake, I will note the following.\n\n[1. Download the latest version of Visual Studio (Visual Studio 2017 at the time of writing this) and](https://www.visualstudio.com/)\n\ninstall it.\n[2. Download Windows 10 SDK (latest version) and install it.](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk)\n[3. Download Windows Driver Kit (WDK ‚Äì latest version) and install it.](https://developer.microsoft.com/en-us/windows/hardware/windows-driver-kit)\n\n\n-----\n\nYou can check the following resource to help get into kernel-mode development, and official from\n[Microsoft themselves: https://docs.microsoft.com/en-us/windows-hardware/drivers/develop/](https://docs.microsoft.com/en-us/windows-hardware/drivers/)\n\nThe example source code is going to more-or-less replicate NtSuspendProcess/NtResumeProcess;\nno access to the System Service Descriptor Table required.\n\n1. We do not have access to ObpReferenceObjectByHandle, but we do have access to\n\nObReferenceObjectByHandle. ObReferenceObjectByHandle will call\nObpReferenceObjectByHandle and it will allow us to obtain an object to the process by\nproviding a valid handle to it.\n2. PsSuspendProcess/PsResumeProcess.\n\n**Let‚Äôs get on with it!**\n\nFirst things first, we need to setup our type-definitions. I‚Äôm using a header file specifically for the C\nfile which is going to contain this.\n```\n#define PROCESS_SUSPEND_RESUME 0x0800\ntypedef NTSTATUS(NTAPI *pPsSuspendProcess)(\n  PEPROCESS Process\n);\ntypedef NTSTATUS(NTAPI *pPsResumeProcess)(\n  PEPROCESS Process\n);\n\n```\nThe reason I‚Äôve also defined PROCESS_SUSPEND_RESUME is because these ‚Äúspecific‚Äù access\nrights aren‚Äôt available in the WDK libraries by default, and we need that access right for process\nsuspension/resume operations. We don‚Äôt need to have more privileges therefore we shouldn‚Äôt try to\ngain such.\n\nI got the PROCESS_SUSPEND_RESUME definition from MSDN: https://msdn.microsoft.com/engb/library/windows/desktop/ms684880\n\nWe already know that PsSuspendProcess and PsResumeProcess take in only one parameter of\ndata-type PEPROCESS because of earlier when we took a look at the routines with static reverse\nengineering and saw what the NtSuspendProcess/NtResumeProcess routines were doing before\ninvoking the Ps* routines. Because of ObpReferenceObjectByHandleWithTag, we know that the\nparameter is of type PEPROCESS (EPROCESS*).\n\nThe next thing we need to do is retrieve the address to PsSuspendProcess and PsResumeProcess.\nSince PsSuspendProcess and PsResumeProcess are both exported by NTOSKRNL, this will be\n[very simple for us to do. There‚Äôs a routine named MmGetSystemRoutineAddress.](https://msdn.microsoft.com/en-us/library/windows/hardware/ff554563(v=vs.85).aspx)\n```\nPVOID MmGetSystemRoutineAddress(\n  _In_ PUNICODE_STRING SystemRoutineName\n);\n\n```\nAccording to the Microsoft documentation, this routine takes in one parameter which is of\nPUNICODE_STRING data-type.\n\n\n-----\n\nWe ll continue by doing the following.\n\n1. Setup a routine to return us the address via MmGetSystemRoutineAddress\n2. Setup the addresses for PsSuspendProcess and PsResumeProcess\n```\npPsSuspendProcess fPsSuspendProcess;\npPsResumeProcess fPsResumeProcess;\nPVOID ReturnSystemRoutineAddress(\n  WCHAR *RoutineName\n)\n{\n  UNICODE_STRING RoutineNameUs = { 0 };\n  if (!RoutineName)\n  {\n    return 0;\n  }\n  RtlInitUnicodeString(&RoutineNameUs,\n    RoutineName);\n  return MmGetSystemRoutineAddress(&RoutineNameUs);\n}\nNTSTATUS InitializeExports()\n{\n  fPsSuspendProcess = (pPsSuspendProcess)ReturnSystemRoutineAddress(\n    L\"PsSuspendProcess\");\n  fPsResumeProcess = (pPsResumeProcess)ReturnSystemRoutineAddress(\n    L\"PsResumeProcess\");\n  if (!fPsSuspendProcess ||\n    !fPsResumeProcess)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return STATUS_SUCCESS;\n}\n\n```\nThat should do the trick. Remember, you will need to make sure the InitializeExports routine is called\nbefore you attempt to make use of the fPsSuspendProcess/fPsResumeProcess variables being\nsetup, otherwise they will point to NULL and you‚Äôll cause a bug-check crash due to dereferencing a\nNULL pointer.\n\nThe next thing we need to do is setup our wrapper routines to invoke PsSuspendProcess and\nPsResumeProcess. This isn‚Äôt a necessity of course, you could just call\nfPsSuspendProcess/fPsResumeProcess or whatever you named those global variables to point to\nthe correct address with the function type-definition set to it, but I find it easier to manage when you\nhave a wrapper routine for each one ‚Äì this means if there is ever an issue with the call itself, you can\npatch the issue by changing one routine instead of many. It also looks more appealing to me to have\nwrapper routines, so this is what I‚Äôll be doing in this article.\n\n\n-----\n\nAll we need to do is have two routines which return an NTSTATUS error code (STATUS_SUCCESS\nor another error, this will be the value returned by PsSuspendProcess/PsResumeProcess). We will\nneed to check within the routine if the fPsSuspendProcess or fPsResumeProcess variable is NULL\nor not otherwise if the routine is accidentally called and the address truly is NULL, we‚Äôll be\ndereferencing a NULL pointer and end up bug-checking the system, which would be really silly. If the\naddress is NULL then we can return STATUS_INSUFFICIENT_RESOURCES since this implies we\ndo not have the required resources to complete the operation, which would be truthful because the\naddresses are a ‚Äúresource‚Äù which are needed to make the suspension/resume operation.\n```\nNTSTATUS NTAPI PsSuspendProcess(\n  PEPROCESS Process\n)\n{\n  if (!fPsSuspendProcess)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fPsSuspendProcess(Process);\n}\nNTSTATUS NTAPI PsResumeProcess(\n  PEPROCESS Process\n)\n{\n  if (!fPsResumeProcess)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  return fPsResumeProcess(Process);\n}\n\n```\nThe last thing we have to do to implement the process suspension/resume functionality in kernelmode is make our wrapper routines for NtSuspendProcess and NtResumeProcess. Why think about\n_locating the address to NtSuspendProcess (NTOSKRNL) or NtResumeProcess (NTOSKRNL) at all_\n_when you can have your own wrapper routine which does the same thing as the official one?_ **Well, I**\n**can think of a few reasons why regarding stability‚Ä¶ But don‚Äôt ruin the moment!**\n\nWe have a few approaches for the NtSuspendProcess/NtResumeProcess wrapper.\n\n1. We can use the documented, kernel-mode only routine named PsLookupProcessByProcessId\n\nto obtain an object to the targeted process and we can then pass this process object\n(PEPROCESS) to the PsSuspendProcess/PsResumeProcess wrapper routines.\n2. We can accept a handle parameter to the NtSuspendProcess/NtResumeProcess wrapper\n\nroutines the same way the official NtSuspendProcess/NtResumeProcess routines under\nNTOSKRNL do, and then we can use the handle to obtain an object to the process.\n\nWe‚Äôre going to go with the second option to keep it closer to the real\nNtSuspendProcess/NtResumeProcess, but either are fine. Personally, I‚Äôd go for using the process\nobject instead of a handle from the start if I was working in kernel-mode, but that‚Äôs just me.\n\n\n-----\n\nThankfully, we have the ability to make use of the ObReferenceObjectByHandle routine. It s also\nofficially documented. It isn‚Äôt the same one used in the NtSuspendProcess/NtResumeProcess\nroutines in the Windows Kernel but it leads down the same path so it‚Äôs perfectly fine.\n\n\n-----\n\n```\nNTSTATUS NTAPI NtSuspendProcess(\n  HANDLE ProcessHandle\n)\n{\n  NTSTATUS NtStatus = STATUS_SUCCESS;\n  PEPROCESS Process = 0;\n  if (!ProcessHandle)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  NtStatus = ObReferenceObjectByHandle(ProcessHandle,\n    PROCESS_SUSPEND_RESUME,\n    *PsProcessType,\n    KernelMode,\n    &Process,\n    NULL);\n  if (!NT_SUCCESS(NtStatus))\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  NtStatus = PsSuspendProcess(Process);\n  ObDereferenceObject(Process);\n  return NtStatus;\n}\nNTSTATUS NTAPI NtResumeProcess(\n  HANDLE ProcessHandle\n)\n{\n  NTSTATUS NtStatus = STATUS_SUCCESS;\n  PEPROCESS Process = 0;\n  if (!ProcessHandle)\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  NtStatus = ObReferenceObjectByHandle(ProcessHandle,\n    PROCESS_SUSPEND_RESUME,\n    *PsProcessType,\n    KernelMode,\n    &Process,\n    NULL);\n  if (!NT_SUCCESS(NtStatus))\n  {\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n  NtStatus = PsResumeProcess(Process);\n  ObDereferenceObject(Process);\n\n```\n\n-----\n\n```\n  return NtStatus;\n}\n\n```\nIf you‚Äôre conscious about sticking to as less code as possible for whichever reason, it may be nice\nfor me to comment that you could make another wrapper routine which takes in the process handle\nand a BOOLEAN flag to determine if the process should be suspended or resumed. Then,\ndepending on the flag, use the returned process object with the\nPsSuspendProcess/PsResumeProcess wrapper routines. This would prevent you from doing a\ncheck-up on the ProcessHandle parameter, calling ObReferenceObjectByHandle and checking the\nstatus codes in both routines which would cut down a few lines of code ‚Äì but the end-result would be\nidentical.\n\nI tested it out by opening a handle to notepad.exe with PROCESS_SUSPEND_RESUME access\nrights and then passing the handle to the NtSuspendProcess routine. I set my DriverUnload routine\nto call NtResumeProcess on the process so it would be resumed after the driver was unloaded\n(experimental purposes).\n\nTesting PsSuspendProcess with a remote kernel-debugger attached under an analysis environment\n1/2.\nAt this moment in time, notepad.exe had been suspended by the experimental kernel-mode device\ndriver.\n\n\n-----\n\nTesting PsSuspendProcess with a remote kernel-debugger attached under an analysis environment\n2/2.\nThis happened after unloading the driver, because the NtResumeProcess wrapper was called,\ntargeting the notepad.exe suspended process. The process was successfully resumed. =\n\nIf you look at the screen-shot in which notepad.exe was in a suspended state, you‚Äôll notice the\nthreads were suspended. If those threads weren‚Äôt suspended, then the process would not be\n‚Äúsuspended‚Äù. After the process has been resumed in the above screen-shot, the threads are\n‚Äúresumed‚Äù (aka. ‚Äúrunning‚Äù/‚Äùactive‚Äù).\n\nYou can even see in the screen-shot where the process is suspended that the ‚ÄúState‚Äù details in the\nProcess Hacker pop-up Properties window (-> Threads tab) is saying ‚ÄúWait:Suspended (1)‚Äù ‚Äì the\nthread is being held up the same way a normal developer may call WaitForSingleObject\n(KeWaitForSingleObject is the kernel-mode equivalent) on a thread of his own in user-mode.\n\n**That‚Äôs all for this post, I‚Äôd like to thank you for reading up to this point and hopefully this post**\n**was found to be useful!**\n\n‚Äì Opcode\n\nTwitter: [https://twitter.com/NtOpcode](https://twitter.com/NtOpcode)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-01-16 - Anatomy of the thread suspension mechanism in Windows (Windows Internals).pdf"
    ],
    "report_names": [
        "2018-01-16 - Anatomy of the thread suspension mechanism in Windows (Windows Internals).pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536241,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653757362,
    "ts_modification_date": 1653757362,
    "files": {
        "pdf": "https://archive.orkl.eu/58a4cd8bc6e2f5671fb1ec545a540b446e151497.pdf",
        "text": "https://archive.orkl.eu/58a4cd8bc6e2f5671fb1ec545a540b446e151497.txt",
        "img": "https://archive.orkl.eu/58a4cd8bc6e2f5671fb1ec545a540b446e151497.jpg"
    }
}