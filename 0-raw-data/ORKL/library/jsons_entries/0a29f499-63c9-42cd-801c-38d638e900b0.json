{
    "id": "0a29f499-63c9-42cd-801c-38d638e900b0",
    "created_at": "2023-02-16T02:07:42.940409Z",
    "updated_at": "2025-03-27T02:09:29.70502Z",
    "deleted_at": null,
    "sha1_hash": "7980bb6e62a20d609a92f02e0fd7cad98794f325",
    "title": "2022-10-12 - Code Injection",
    "authors": "",
    "file_creation_date": "2022-10-12T13:08:35Z",
    "file_modification_date": "2022-10-12T13:08:35Z",
    "file_size": 186912,
    "plain_text": "# Code Injection\n\n### G. Lettieri\n\n 12 October 2022\n\n## 1 Introduction\n\nProbably the most important attack vectors are opened by memory-corruption\nbugs in programs. Attackers can exploit these bugs to overwrite strategic locations in the victim process memory, and this often leads to a complete take-over\nof the process and its credentials.\nIn this lecture we explore a set of classical techniques that exploit stack\nmemory corruption to both inject new code into the victim process, and redirect\nthe process execution to the injected code.\nOur running example will be the stack-4.5 program from a set of exercises\nadapted from the Phoenix virtual machine[1]. The exercise is installed in VM\nwhich you can reach via ssh:\n\nssh -p 4422 stack4.5@lettieri.iet.unipi.it\n\nThe password is stack4.5. Your goal is to read the flag.txt file.\n\n## 2 Analyzing the bug\n\nThe attack is possible because the victim program contains a bug, which the\nattacker must identify. Bugs can be found by studying the source code, when\navailable, but it is also possible to find bugs in programs that are distributed in\nbinary-only form. The attacker can study the machine code with a disassembler\nor decompiler, or she can trying to feed input into the program and try to make it\ncrash. A “Segmentation Fault” error is a sure indication of a memory corruption\nbug, which can then be further analyzed to look for possible exploitation.\nIn our example we are given the source code and the bug is easy to spot: the\nstart_level() function uses the deprecated gets() function, which reads\nbytes from standard input and copies them into a buffer, stopping at the first\n“\\n” character. The function doesn’t know the size of the buffer, and therefore\nanybody who controls standard input can easily cause a write past the end of\nthe buffer. There is no way to use this function correctly, and this is why it has\nbeen deprecated in the C99 standard and then removed from the C11 standard.\n\n[1http://exploit.education/phoenix/](http://exploit.education/phoenix/)\n\n1\n\n\n-----\n\nModern libraries may still implement it, but you have to declare it by yourself,\nand the compiler will still issue a warning if you use it.\nLet’s analyze the situation from an attacker point of view. These kind of\nbugs allow us to overwrite the process memory, starting from the address of\nbuffer and going up, with almost any byte we want. I say “almost”, because\nthere may be limitations on the bytes that can be injected, depending on the\nexact nature of the bug. In our example, gets() will stop at the fist byte that\ncontains 0x0a (ASCII value of newline), replacing it with a null byte. Therefore,\nwe must avoid 0x0a bytes in the middle of the sequence of bytes that we want\nto inject. Note, however, that gets() will copy any other byte, including null\nbytes, verbatim into the process memory. Errors in string functions, instead,\nusually make it hard to inject null bytes.\nNote also that we cannot just overwrite any byte that we want: we can only\nmodify the bytes at non-negative offsets from buffer. Moreover, if we want to\nmodify a byte at offset o > 1, we also need to overwrite all the bytes at offsets\nbetween 0 and o − 1. We also cannot exploit address wrap-around to overwrite\nbytes at addresses lower than buffer, since the process address space contains\nnon-accessible pages at high addresses, reserved to the kernel. If gets() starts\nwriting into those addresses, the process is immediately killed. We also cannot\noverwrite the existing code of the process, both because it is located at lower\naddresses than the stack, and because it is write-protected. In essence, we can\nonly overwrite the process stack below buffer.\n\n## 3 The attack strategy\n\nWe want to keep the process alive and just change its program, so that we can\nexecute our code with the process credentials.\nThe classical attack that we are going to mount will exploit the gets() bug\nto both inject attacker code into the process stack, and to overwrite the return\n_address of start_level() with the address of the injected code. When the_\nprocess will execute the ret instruction to return from start_level() to its\ncaller, execution will instead jump to the attacker code.\nThere are several conditions that make this attack possible. Among them:\n\n  - start_level()’s return address is stored on the stack, at an address\nhigher than buffer (that is, within the memory that we can overwrite);\n\n  - the data contained on the stack between buffer and the return address\nis not important (therefore, we can overwrite it without worrying about\nits contents);\n\n  - the CPU must be able to fetch instructions from the addresses where the\ninjected code has been copied.\n\nWe will see that many modern mitigations try to block this attack by removing\nat least one of these necessary conditions. In particular, in order to simplify the\nsolution of the exercise, stack4.5 explicitly disables one of these mitigations\n\n2\n\n\n-----\n\nby marking the gbuf buffer as executable. In later lectures we will see both\nhow these mitigations work, and how attackers can bypass them without any\n“help” from the victim program.\nTo mount this attack we need a couple of data:\n\n  - The offset between the stored return address and buffer; we need this\nbecause we need to know how many bytes to inject before gets() will\nstart overwriting the stored return address;\n\n  - The absolute address of the injected code in the process memory; this is\nthe value we want to overwrite the stored return address with; we need\nan absolute address, since this is what ret needs.\n\n## 4 The shellcode\n\nWe also need to decide what code we want to inject. The most useful code is, as\nalways, one that gives us a shell. For this reason injected code is usually called\n“shellcode”, even when it doesn’t involve the shell at all.\nThe shellcode that we will inject will be equivalent to the following C snippet:\n\n**char *argv[] = { \"sh\", NULL };**\nexecve(\"/bin/sh\", argv, NULL);\n\nThere are tools that contain pre-build shellcodes for almost any need. The one\nin Figure 1 is obtained using the shellcraft command from the pwntools\nlibrary. The command used to obtain the code is\n\nshellcraft -n -f asm amd64.linux.sh\n\nThe last argument is the kind of shellcode that we want (a list of all available\nshellcodes can be obtained with shellcraft -l). In this case, it is the code\nto exec a shell on a 64 bit linux system. The first argument (-n) asks to select\na code that does not contain newline bytes[2]. The second argument (-f asm)\nselects the output format.\nThe code builds the argv vector and the necessary strings on the stack,\nthen calls the execve system call. In 64 bit systems, the Linux kernel can\nbe entered by putting the desired syscall number in rax and then issuing the\nsyscall instruction. Any parameters to the syscall must be left into the\nregisters, the first one in rdi, the second one in rsi, the third one in rdx.\nLine 17, for example, is passing NULL as the third parameter (the pointer to\nthe environment).\nThe code in Figure 1 is convoluted because it written to avoid null bytes,\neven if we could have allowed them in our gets() example. So, for instance,\nlines 19–20 are equivalent to “mov rax, 0x3b”, but this instruction contains\nnull bytes in its binary form and therefore cannot be used. As another example,\n\n2This can be omitted, since the default code is already safe with respect to the bytes that\nmust commonly be avoided.\n\n3\n\n\n-----\n\n1 /* push b’/bin///sh\\x00’ */\n2 **push 0x68**\n3 **mov rax, 0x732f2f2f6e69622f**\n4 **push rax**\n5 **mov rdi, rsp**\n6 /* push argument array [’sh\\x00’] */\n7 /* push b’sh\\x00’ */\n8 **push 0x1010101 ˆ 0x6873**\n9 **xor dword ptr [rsp], 0x1010101**\n10 **xor esi, esi /* 0 */**\n11 **push rsi /* null terminate */**\n12 **push 8**\n13 **pop rsi**\n14 **add rsi, rsp**\n15 **push rsi /* ’sh\\x00’ */**\n16 **mov rsi, rsp**\n17 **xor edx, edx /* 0 */**\n18 /* call execve() */\n19 **push SYS_execve /* 0x3b */**\n20 **pop rax**\n21 syscall\n\nFigure 1: An example shellcode for 64 bit Linux (Intel syntax).\n\n4\n\n\n-----\n\nlines 8–9 are pushing the null terminated \"sh\" string on the stack, but they\nneed to mask and unmask it with 0x01010101 to avoid null bytes in the byte\nstream.\n\n## 5 Obtaining the offset\n\nThe offset between the return address and the buffer can be obtained in\nseveral ways. An attacker should know all possible ways, since some of them\nmay not be applicable, or may not be convenient, in all scenarios.\n\n### 5.1 Running with the debugger\n\nA first option is to run the program in gdb, stopping at the instruction that\ncalls gets(), and then examine the contents of rbp and the the contents of\n**rdi (p/x $rdi). The latter one is the address of buffer, while the return**\naddress is at rbp + 8. The difference between the two is the offset we are\nlooking for (we can let gdb compute it for us: p $rbp+8-$rdi).\n\n### 5.2 Studying the code\n\nIf the code is simple, it may be much more convenient to just study the assembler, as obtained by objdump -d -M intel. For example, in this case the\ncode of start_level() starts with something like:\n\n080491e6 <start_level>:\n\n**push** rbp\n**mov** rbp,rsp\n**add** rsp,0xffffffffffffff80\n**lea** rax,[rbp-0x80]\n**mov** rdi,rax\n**call** 401040 <gets@plt>\n...\n\nWe can see that the argument that is passed in rdi before calling gets()\nis obtained by “lea rax, [rbp-0x80]”. We know that this is the address\nof buffer, which is therefore 0x80 bytes above rbp. Since rbp points one\nstack-line above the saved return address, the offset is\n\n8816 + 8 = 13610.\n\n### 5.3 Obtaining a crash dump\n\nIf we can inspect a crash dump of the program, however, we have a simpler way\nto obtain the offset. We can feed the program with a sequence of bytes, making\nsure that no subsequence corresponds to a valid address, until the program\ncrashes. If the program crashes, it means that a subsequence of our sequence of\nbytes overwrote the return address: we only need to know which subsequence\n\n5\n\n\n-----\n\nit was. The crash dump will easily reveal this information: assuming that no\nsubsequence corresponded to a valid address, the program must have crashed\neither immediately after the execution of the ret, while it was trying to jump to\nthe overwritten return address, or during the execution of ret, if the overwritten\naddress was not in canonical form. The subsequence, therefore, is either in the\n**rip register or still on the top of the stack.**\nThe pwntools library contains the cyclic program that helps in implementing this strategy: it prints on stdout a sequence of bytes that is non\n_repeating and very unlikely to contain valid addresses as subsequences. We can_\nfeed the output of cyclic into the victim process until it crashes, get the subsequence that overwrote the return address (by examining the crash dump), and\nfinally ask cyclic where the subsequence occurred in its output: this is the\noffset we are looking for.\nLet’s go back to our example. To obtain a crash dump (coredump or simply\n_core in Unix parlance) we need to enable them, since they are usually disabled_\nby default:\n\n**ulimit -c unlimited**\n\nIf the program that we want to examine is set-user-id or set-group-id we also\nneed to make a copy of it, since the kernel will not create crash dumps for these\nprograms, as a security measure. The information we are looking for, however,\ndoesn’t depend on the setuid/setgid privilege, so we can obtain it from the\ncopy. Since we cannot create files in the home directory in the VM, we move to\na temporary directory and copy the program there:\n\n**cd $(mktemp -d)**\ncp ˜/stack4.5 .\n\nNow we try to obtain the core file. This file is by default called core and is\ncreated in the current directory. It is a good idea to remove any pre-existing\ncore file, and to make sure that you have write permission in the current\ndirectory. Note that the location and the name of the core file can be customized\nby writing in the /proc/sys/kernel/core_pattern pseudo-file, so it is a\ngood idea to check this file contents if you don’t see the core file in the current\ndirectory. If the /proc/sys/kernel/core_uses_pid contains non-zero,\nthe pid of the crashed process will be appended to the name of the core file.\nNow we can feed the program with a sufficiently long sequence generated by\ncyclic. We don’t know how long the sequence should be, but we can try different\nvalues until we succeed[3]\n\ncyclic -n 8 200 | ./stack4.5\n\nFor 64 bit systems we use the -n 8 option to ask for a sequence made of 8bytes non-repeating subsequences. In this way each subsequence completely\n\n3Be careful, however, that if the sequence is too large you may cause a different crash in\nthe gets() itself, which will go past the last address on the stack and will start accessing\nreserved pages. A crash like this would be of no help.\n\n6\n\n\n-----\n\nfills a register or (if the buffer is stack-aligned) a complete stack line. This\nshould make it simpler to recognize the subsequence without being confused by\nsurrounding bytes.\nThe shell should reply with\n\nSegmentation fault (core dumped)\n\nNote the “(core dumped)” part of the message: the kernel has created a core\nfile, with the contents of all the registers and the memory of the process at the\ntime of the crash. We can examine the core with gdb:\n\ngdb stack4.5 core\n\nThe debugger will load the contents of the core and let us examine the registers\nand the memory at the time of the crash. The subsequences generated by\ncyclic are unlikely to be in canonical form, so the overwritten rip should\nstill be on the top of the stack. We can print it with x/xg $rsp, or with\ninfo frame, obtaining 0x6161616161616172. Now we can ask cyclic to\ntell us the offset of this subsequence in its -n 8 sequence:\n\ncyclic -n 8 -l 0x6161616161616172\n\nAnd we obtain 136, as before.\n\n## 6 Obtaining the absolute address\n\nThis is easy for stack4.5, since the program copies the injected code into the\nglobal gbuf array, whose address can be easily obtained from the (unstripped)\nbinary:\n\nnm stack4.5 | grep gbuf\n\nWe find that the address is 0x403440.\nEven if the binary is stripped, we can easily study the assembly code, or run\nthe program in the debugger, to discover the destination address of the memcpy\nin start_level().\n\n## 7 Obtaining a shell\n\nWe are now ready to attack the original stack4.5 program and turn it into a\nshell. We go back to our home and type:\n\n{\n\nshellcraft -n -f raw amd64.linux.sh\npython3 -c ’print(\"A\"*(136-48) + \"\\x40\\x34\\x00\"[::-1])’\n**cat**\n} | stack4.5\n\n7\n\n\n-----\n\nAll the commands between the curly braces are executed in a subshell. The\npipeline redirects the subshell output into the stdin of the process executing\nthe stack4.5 program. The first injected bytes come from shellcraft and\ncontain the binary code of the assembly shown in Figure 1. These bytes will\ngo at the beginning of buffer and will occupy 48 bytes (the number of bytes\nof the shellcode can be obtained by pipelining the shellcraft command into\n“wc -c”). After that, the python3 command will inject 136−48 more padding\nbytes, exactly enough to reach the saved return address, which will then be\noverwritten by the address of gbuf. The newline automatically printed by\npython3 will make the gets() in the target program return to its caller, the\nstart_level() function, which will then copy buffer into gbuf and then\nexecute the ret instruction on our overwritten return address. The processor\nwill then jump to the start of gbuf and start executing our shellcode. The\nshellcode will cause the process to stop executing stack4.5 and start executing\n/bin/sh. The process, however, is still the same and, in particular its standard\ninput is still connected, through the pipe, with our subshell. The subshell now\nexecutes cat, thereby connecting the subshell stdin (our terminal) to the stdin\nof the shell. Note that we don’t see the shell prompt: since the stdin of the\nshell is a pipe, the shell thinks that it has been called in “non interactive” mode\nand there is no need to prompt a human user. Nonetheless, if we type shell\ncommands at the terminal we can verify that they are actually executed.\n\n## 8 Obtaining a useful shell\n\nIn order for this kind of attack to be of any use to us attackers, the obtained\nshell should run with a user id or group id that was previously unavailble to us.\nOtherwise, we would have just taken a tortuous road to get a shell equivalent\nto the one we already had. This is why we are attacking a setgid program like\nstack4.5. In this case, we want a shell that runs in a process belonging to\nthe stack4.5_pwned group, so that we can read the secret flag.\nIf we try to read the flag using our new shell, though, we still get a “permission denied” error. If we type id in our newly obtained shell we can see that\nour group has not changed. This, of course, is due to the self-protection implemented in the shell, which has set its effective group id equal to its real group\nid before starting to accept commands. As we already know, this protection is\neasily circumvented if we do the reverse operation (setting the real gid equal\nto the effective gid) before executing the shell. The shellcraft tool has a\nshellcode that does just that (amd64.linux.setregid). We can thus inject\nthis code before injecting the shellcode proper:\n\n{\n\nshellcraft -n -f raw amd64.linux.setregid\nshellcraft -n -f raw amd64.linux.sh\npython3 -c ’print(\"A\"*(136-48-16) + \"\\x40\\x34\\x00\"[::-1])’\n**cat**\n} | stack4.5\n\n8\n\n\n-----\n\nThe new code contains 16 additional bytes, that we have subtracted from the\npadding generated in python3. This time the shell will keep the stack4.5_pwned\ngroup, allowing us to read the secret flag.\n\n9\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/2022-10-12 - Code Injection.pdf"
    ],
    "report_names": [
        "2022-10-12 - Code Injection.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1676513262,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1665580115,
    "ts_modification_date": 1665580115,
    "files": {
        "pdf": "https://archive.orkl.eu/7980bb6e62a20d609a92f02e0fd7cad98794f325.pdf",
        "text": "https://archive.orkl.eu/7980bb6e62a20d609a92f02e0fd7cad98794f325.txt",
        "img": "https://archive.orkl.eu/7980bb6e62a20d609a92f02e0fd7cad98794f325.jpg"
    }
}