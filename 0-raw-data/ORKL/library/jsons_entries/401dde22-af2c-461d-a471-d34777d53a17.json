{
    "id": "401dde22-af2c-461d-a471-d34777d53a17",
    "created_at": "2023-01-12T15:00:08.55481Z",
    "updated_at": "2025-03-27T02:06:10.060126Z",
    "deleted_at": null,
    "sha1_hash": "e063c8202de1bd49f3d4c6c0ca3fe204fc36330c",
    "title": "2020-07-09 - Threat Bulletin- Dissecting GuLoader’s Evasion Techniques",
    "authors": "",
    "file_creation_date": "2022-05-27T21:49:57Z",
    "file_modification_date": "2022-05-27T21:49:57Z",
    "file_size": 1326253,
    "plain_text": "# Threat Bulletin: Dissecting GuLoader’s Evasion Techniques\n\n**[vmray.com/cyber-security-blog/guloader-evasion-techniques-threat-bulletin/](https://www.vmray.com/cyber-security-blog/guloader-evasion-techniques-threat-bulletin/)**\n\n_Editor’s Note: This blog post was updated on August 10, 2020._\n\nOver the last couple of months, we observed a new downloader called GuLoader (also\n[known as CloudEyE) that has been actively distributed in 2020. In contrast to prototypical](https://research.checkpoint.com/2020/guloader-cloudeye/)\ndownloaders, GuLoader is known to use popular cloud services such as Google Drive,\nOneDrive and Dropbox to host its encrypted payloads. So far we have seen that GuLoader is\nbeing used to deliver Formbook, NanoCore, LokiBot and Remcos among others. We’ve\nobserved that GuLoader uses a combination of evasion techniques that evade sandboxes\nand slow down (manual) analysis.\n\nOn June 6th, 2020 the developers of GuLoader informed the public that they have shut down\ntheir service (Figure 1). Despite the suspension of service, we anticipate other malware\nfamilies will evolve and adapt some of these techniques in the near future. In this post, we\nwill highlight GuLoader’s techniques with a focus on sandbox evasion and anti-analysis.\n\n[View the VMRay Analyzer Report for GuLoader](https://www.vmray.com/analyses/evasive-guloader-cloudeye/report/overview.html)\n\n\n-----\n\n_Figure 1: Shut down announcement claiming that the service has been misused by criminals._\n\n## Overview and Shellcode\n\nIn our analysis, we can see that GuLoader creates another instance (in the following\nreferenced as the second instance) of itself and modifies its execution (Figure 2 and Figure\n3).\n\n_Figure 2: VMRay Analyzer – Process overview of the GuLoader sample._\n\n_Figure 3: VMRay Analyzer – Process injection into the second instance._\n\nThe second instance then performs further malicious activities, which includes network\nactivity to download the payload and the memory modification of other processes (Figure 4).\n\nOther [reports about GuLoader revealed the main functionality is implemented as shellcode,](https://blog.vincss.net/2020/05/re014-guloader-antivm-techniques.html)\nwhereby the sample is a 32-bit executable written in VB6 that contains the shellcode in\nencrypted form.\n\n\n-----\n\nDuring execution, the embedded shellcode is decrypted, executed and even injected as seen\nbefore (Figure 2).\n\n_Figure 4: VMRay Analyzer – Behavior Information showing the first instance with a host_\n_activity of 179 and the second instance with a host activity of 2564 and network activity._\n\nBy loading the shellcode in IDA Pro (we loaded the shellcode at offset 0x001A0000) or a\nsimilar disassembler, we can see that the code is heavily obfuscated. The code is split into\nsmaller code parts containing additional junk code (Figure 6) that are connected with controlflow changing instructions such as call, return and (indirect) jump. In contrast to compilergenerated code, the shellcode combines code instructions and data such as strings, which is\ntypical for position-independent code.\n\nThis makes the static control-flow analysis more difficult and causes the automatic analysis\nof IDA Pro to fail.\n\nFor example, the addresses of library names are pushed on the stack by using the call\ninstruction (Figure 5). In compiler-generated code, this instruction is used to transfer the\ncontrol flow to another function, and the return instruction transfers it back to the caller.\n\n_Figure 5: Call instructions that push the addresses of the strings “ntdll, “advapi32” and_\n_“user32” on the stack._\n\n\n-----\n\nGuLoader resolves the required functions during runtime and uses the hash algorithm djb2 to\nfind the desired functions.\n\n### Anti-Analysis and Evasion Techniques\n\nExpanding on the techniques mentioned above, the shellcode contains more techniques\nto obstruct automatic analysis. One of these techniques is the search for virtual machine\nartifacts, which are embedded as djb2 hash values. In Figure 6, we can see that these hash\nvalues are pushed on top of the stack and the successive call to the function tries to find the\ncorresponding artifacts in memory.\n\n_Figure 6: Hash values of virtual machine artifacts pushed on the stack._\n\nSince these values are calculated by a one-way function (djb2), their preimages are\nunknown. So far, the strings in Table 1 have been found to be possible preimages.\n\n**Hash** **Preimages** **Notes**\n\n7F21185B “HookLibraryx86.dll” ScyllaHide Plugin for x64dbg\n\nA7C53F01 “VBoxTrayToolWndClass” VirtualBox Guest Additions\n\nB314751D “vmtoolsdControlWndClass” [VMWare, see [1]](https://malpedia.caad.fkie.fraunhofer.de/details/win.cloudeye)\n\n\n-----\n\nIf one of these hashes is found in memory, the sample displays an error message (Figure 7)\nand terminates the process. Therefore, the sample shows no further malicious behavior, and\nit does not download the payload.\n\n_Figure 7: Message displayed to the user if a virtual environment was detected._\n\nIn addition to the virtual machine artifacts, GuLoader verifies the number of top-level\nWindows displayed on the current screen to exclude running in a sandbox (Figure 8.).\n\nFor each top-level Window, the callback function (Figure 9) increases a counter by one,\nwhich leads to the overall number of top-level Windows. This counter is used in the check at\n0x1A01A6 that validates if at least 12 top-level Windows are present.\n\n_Figure 8: Verification of the number of top-level windows on the screen._\n\n_Figure 9: Callback function that counts the top-level windows._\n\nIf the number is lower, the process terminates in which case no error message is displayed.\n\nTo further prevent the manual analysis with a debugger, GuLoader modifies functions related\nto debugging (Figure 10).\n\n\n-----\n\nGuLoader modifies the two functions DbgBreakPoint and DbgUiRemoteBreakin. For the first\nfunction, the first byte is replaced by a NOP instruction, and for the second function, the code\nis replaced by a call to ExitProcess (Figure 11).\n\n_Figure 10: VMRay Analyzer – Code modifications of the function DbgUiRemoteBreakin_\n\n_Figure 11: [Left] Before code modification of the function DbgUiRemoteBreakin._\n\n[Right] After code modification of the function DbgUiRemoteBreakin.\n\nAfter the code modifications of DbgUiRemoteBreakin, the attaching of a debugger to the\nrunning process results in its termination.\n\nIn addition to the modifications of the two functions mentioned above, GuLoader modifies\nfurther functions exported by Ntdll.dll (Figure 12). These functions are well-known candidates\nfor function hooking which allows intercepting function calls by redirecting the control flow.\nSome Antivirus Software and Sandboxes use function hooking to monitor the behavior of a\ngiven program.\n\n\n-----\n\n_Figure 12: VMRay Analyzer – Hook Information about modifications of Ntdll.dll functions._\n\nVerifying this suspicion in IDA Pro, GuLoader iterates through the code section of Ntdll.dll.\nWhile iterating GuLoader tries to undo modifications introduced through function hooking as\n[mentioned in Crowdstrike’s analysis and disables Turbo Thunks, see](https://www.crowdstrike.com/blog/guloader-malware-analysis/) [WoW64 Internals.](https://wbenny.github.io/2018/11/04/wow64-internals.html)\n\nTo find candidates for modification, GuLoader uses various byte patterns including “B8 00 00\n00 00 BA” (Figure 13).\n\n\n-----\n\n_Figure 13: Part of the decompiled function that modifies Ntdll.dll functions based on byte-_\n_pattern search._\n\nDisabling of Turbo Thunks is reported (Figure 12) and calls to these functions are still\n[monitored because VMRay Analyzer does not rely on hooking.](https://www.vmray.com/products/analyzer-malware-sandbox/)\n\nFurthermore, GuLoader hides threads by calling the function NtSetInformationThreadwith the\nvalue HideFromDebugger (0x11) for the parameter ThreadInformationClass(Figure 14).\n\n_Figure 14: VMRay function log that shows the hiding of threads with NtSetInformationThread_\n_and the ThreadInformationClass HideFromDebugger parameter._\n\nIn addition to the previously mentioned hash values of virtual machine artifacts, GuLoader\nchecks the presence of the Qemu Guest Agent on the filesystem. Both filesystem strings are\nvisible in the shellcode (Figure 15) and in the function log (Figure 14).\n\n_Figure 15: Strings related to the Qemu Guest Agent._\n\nBefore the second instance is created, or, in case of the second instance, before the payload\nis downloaded, it delays its execution by using the instructions cpuid and rdtsc frequently in a\nloop (Figure 16).\n\nThe instruction cpuid provides information about the processor and available features and\ncan be used to detect the presence of a hypervisor. In addition, rdtsc provides the number of\nCPU cycles since the last reset.\n\n\n-----\n\n_Figure 16: Usage of instructions cpuid and rdtsc._\n\nIf cpuid is executed in a virtual machine, the instruction causes the control flow to be\ntransferred to the hypervisor which resolves the request. Switching from the virtual machine\nto the hypervisor and back again introduces an overhead that can be used to detect a virtual\nmachine.\n\nIn case that a sandbox patches the rdtsc instruction to return a fixed value, the loop in Figure\n16 is an infinite loop since the register edx at 0x001A2506 has always the value 0 and the\nsubsequent conditional jump is always taken.\n\nNext, the sample performs the actions related to its stage. In the first stage, it creates a new\nprocess of itself, tries to unmap its base image, maps msvbvm60.dll instead, followed by the\npreviously mentioned code injection.\n\nIn the second stage, it downloads the payload using WinINet’s functions InternetOpenURLA\nand InternetReadFile. We inspected the behavior of both stages in the VMRay function log\n(Figure 17). We highlighted the fuction calls to NtGetContextThread in both figure because\ncalls to some specific functions including CreateProcessInternalW,\n_NTAllocateVirtualMemory, NTWriteVirtualMemory and NTResumeThread are preceded by a_\ncall to NtGetContextThreat.\n\n\n-----\n\n_Figure 17: [Left] VMRay function log that shows function calls with preceded debug checks to_\n_prepare the second instance._\n\n_[Right] VMRay function log that shows function calls with debug checks to download the_\n_payload from 5[.]206[.]227[.]100]._\n\nThese functions are well-known candidates for breakpoints during manual dynamic analysis,\nand GuLoader tries to detect the presence of these breakpoints (Figure 18). After a call to\n_NtGetContextThread, the values of the debug registers DR0, DR1, DR3, DR6, DR7 are_\n[investigated to detect hardware breakpoints (see the structure CONTEXT). Next, the code of](https://www.pinvoke.net/default.aspx/kernel32/GetThreadContext.html)\nthe desired function is checked against interrupts/software breakpoints (0xCC, 0x3CD,\n0x0B0F), which are typically set by debuggers, before the function is finally called (offset\n0x1A2E66).\n\n_Figure 18: Detection of hardware and software breakpoints before the dynamic function call._\n\nAfter all of these evasion and anti-analysis attempts, the second instance decrypts the\nreceived payload, maps it into memory, and transfers execution.\n\n\n-----\n\n### Conclusion\n\nWith the help of VMRay Analyzer, we can observe the complete behavior GuLoader, which\nautomates and accelerates the identification of important behavior for further analysis\n(Figures 19 & 20). This analysis is a good example of how malware evolves and adapts very\ntechnical sandbox evasion and anti-analysis techniques. The quick and widespread adoption\nof GuLoader confirms a growing demand for evasive malware loaders in the criminal\nunderground.\n\n_Figure 19: VMRay Analyzer – Network behavior that downloads the encrypted payload from_\n_5[.]206[.]227[.]100._\n\n\n-----\n\n_Figure 20: VMRay Analyzer – Memory dumps including the injected shellcode and the_\n_mapped decrypted payload._\n\n### References\n\n[https://malpedia.caad.fkie.fraunhofer.de/details/win.cloudeye](https://malpedia.caad.fkie.fraunhofer.de/details/win.cloudeye)\n\n[https://research.checkpoint.com/2020/guloader-cloudeye/](https://research.checkpoint.com/2020/guloader-cloudeye/)\n\n[https://www.crowdstrike.com/blog/guloader-malware-analysis/](https://www.crowdstrike.com/blog/guloader-malware-analysis/)\n\n[https://blog.vincss.net/2020/05/re014-guloader-antivm-techniques.html](https://blog.vincss.net/2020/05/re014-guloader-antivm-techniques.html)\n\n[https://wbenny.github.io/2018/11/04/wow64-internals.html](https://wbenny.github.io/2018/11/04/wow64-internals.html)\n\n### IOCs\n\n**Sample**\n```\nb240e52ea8a55a50760de6017d644d2d0fcc43fd8918abdf99964efb464c37b6\n\n### Server\n5[.]206[.]227[.]100\n\n Encrypted Payload\n5399f144876e276e8ee1ea206bb4599ca912d8ff42327bdbf08f588a0a836b4e\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-09 - Threat Bulletin- Dissecting GuLoader’s Evasion Techniques.pdf"
    ],
    "report_names": [
        "2020-07-09 - Threat Bulletin- Dissecting GuLoader’s Evasion Techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535608,
    "ts_updated_at": 1743041170,
    "ts_creation_date": 1653688197,
    "ts_modification_date": 1653688197,
    "files": {
        "pdf": "https://archive.orkl.eu/e063c8202de1bd49f3d4c6c0ca3fe204fc36330c.pdf",
        "text": "https://archive.orkl.eu/e063c8202de1bd49f3d4c6c0ca3fe204fc36330c.txt",
        "img": "https://archive.orkl.eu/e063c8202de1bd49f3d4c6c0ca3fe204fc36330c.jpg"
    }
}