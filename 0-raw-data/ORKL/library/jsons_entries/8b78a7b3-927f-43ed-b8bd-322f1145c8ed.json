{
    "id": "8b78a7b3-927f-43ed-b8bd-322f1145c8ed",
    "created_at": "2023-01-12T15:10:33.787866Z",
    "updated_at": "2025-03-27T02:09:06.521206Z",
    "deleted_at": null,
    "sha1_hash": "4137b5b156f6cd115e52723070eccfc9db600952",
    "title": "2019-12-24 - Gozi V3- tracked by their own stealth",
    "authors": "",
    "file_creation_date": "2022-05-28T18:08:06Z",
    "file_modification_date": "2022-05-28T18:08:06Z",
    "file_size": 380444,
    "plain_text": "# Gozi V3: tracked by their own stealth\n\n**[news.sophos.com/en-us/2019/12/24/gozi-v3-tracked-by-their-own-stealth/](https://news.sophos.com/en-us/2019/12/24/gozi-v3-tracked-by-their-own-stealth/)**\n\nSophosLabs Threat Research December 24, 2019\n\nGozi, also known as Ursnif or ISFB, is a banking trojan which has been around for a long\ntime and currently multiple variations of the trojan are circulating after its source code got\nleaked. Every variant that is distributed has interesting aspects, with Gozi version 3 the most\neye-catching in the field of detection evasion.\n\nIn this blog we will discuss some of the techniques which Gozi V3 uses in an attempt to\nbypass endpoint defense. Additionally we will also discuss how researchers can use these\nevasion techniques to their advantage, since they produce a unique and distinctive\nbehavioral pattern.\n\n### Gozi’s infection chain\n\nGozi V3 is distributed via spam mails which link to a malicious file, such as an obfuscated\nVisual Basic script, which acts as a dropper component. The dropper component downloads\nand executes an executable with a valid digital signature. We will refer to this executable as\nthe Gozi loader.\n\nThe function of this loader is to reach out to the command-and-control (C2) server to retrieve\nthe main Gozi executable. The threat actors behind Gozi try to prevent researchers from\ninteracting with the C2 and obtaining payloads.\n\n\n-----\n\nOne way the Gozi attackers do this is by restricting payload delivery at the server side: The\nGozi dropper only works if the IP address of the machine requesting the file geolocates to a\nregion targeted by the malspam (geo restriction), and if the request comes in within a\nrelatively short time frame relative to the start of the spam campaign. This strategy may\nresult in a smaller infection rate, but it avoids the chance that researchers obtain the payload\nand write detections against it.\n\nIf the victim’s machine gets a valid C2 response, the Gozi payload is stored in the registry in\nthe form of a PowerShell script. This fileless technique allows the Gozi threat actors to avoid\ntraditional static (file on disk) detection. Upon system startup the PowerShell script injects the\nGozi worker into the explorer process, at which point the infection chain is complete and\nGozi again reaches out to the C2 server.\n\nThe C2 server this time responds with components which aid Gozi in its money-stealing\nactivities, such as webinjects.\n\nThe Gozi payload stored in the Windows registry\nThese two stages are described in more detail below.\n\n### Hiding in memory\n\nWhen we take a look at a [Gozi V3 loader sample, we can see that it’s protected by a packer](https://www.virustotal.com/gui/file/6a5583f8b9b7a1dfc66ef6d439ec22a1850c5616ae80d300c33f37b2eff38d6f/details)\nin an effort to evade static detection. With the help of IDA’s graph view, we can unpack the\nGozi loader by following calls or jumps to registers, which usually are positioned at the\nbottom of each graph view. The below video illustrates how the loader can quickly be\nunpacked in IDA’s debugging mode in under a minute.\n\n[When we analyze the code at the beginning of the unpacked Gozi loader, we can notice a](https://www.virustotal.com/gui/file/827391fc1de934563e356396257abc79d9dbc6cb60a9b32053bc8ce101095bf1/detection)\nsecond stage PE executable being loaded into memory. Parts of the second stage\nexecutable have been removed, other parts have been overwritten with null bytes. The\n\n\n-----\n\nimage below shows a dump of the memory area after the second stage has been mapped to\nmemory.\n\nAs we can see from the image, the ‘DOS header’ has been removed and the PE magic value\nand section names have been nullified. Other parts of the PE header, such as the\ncompilation timestamp are still present in memory. By performing these actions, Gozi makes\nit harder to dump the unpacked executable from memory, as most dumping tools search for\nthe DOS header to determine where the executable has been mapped in memory. At the\nsame time, this evasion technique produces a fairly unique memory pattern which endpoint\ndefense solutions could target during a memory scan.\n\n### Executing the fileless component\n\n[The goal of the second stage loader is to reach out to the C2 server and to store a](https://www.virustotal.com/gui/file/606a5c5f9af86d4a1685a3a4f6d34ca5e6c99dc2e35669befd0091bd2e9747c4/details)\nPowerShell script in the registry. The PowerShell script is executed using forfiles.exe, a\nWindows component that can be abused to execute a shell instruction in the (process)\ncontext of another executable. The forfiles executable is executed with the following\nargument:\n```\nforfiles /p C:\\Windows\\system32 /s /c \"cmd /c @file -ec BASE_64_ENCODED_COMMAND\" /m\np*ll.*e\n\n```\nwhere the base64 encoded command decodes to:\n```\niex (gp 'HKCU:\\Identities\\{4EBA1D2A-127F-6AB1-EE6C-E4061B0483AD}').S\n\n```\n\n-----\n\nBy using the forfiles executable, Gozi may evade certain detection mechanisms which partly\nrely on the creation of persistency entry (e.g. a scheduled task) which points to a known\nscript engine such as PowerShell or MSHTA. At the same time, the launching of a forfiles\nexecutable with an argument to launch PowerShell with the goal of evaluating the contents of\na registry key as code makes for a unique pattern which is strong enough to block as a\nthreat.\n\nThe fileless PowerShell script which gets executed loads shellcode into memory and\nexecutes said shellcode via the QueueUserAPC injection mechanism. The script is slightly\nobfuscated via Base64 encoding, as can be seen on the following image:\n\nWhat is interesting to notice is that Base64 decoded contents aren’t passed to the ‘invokeexpression (iex)’ commandlet for evaluation in one go. Instead, the contents are passed in\ntwo iterations, which might be done intentionally as it influences the amount of script\ncontents which are passed to the Anti Malware Scan Interface (AMSI) for inspection.\n\n[The executed shellcode injects the Gozi worker binary into the explorer process, which](https://www.virustotal.com/gui/file/88086210f6e912e0b68f4ad04c499a9afc9c4e4a00c499e66d4c5a576b4c7040/details)\nresults in several new process threads being created inside Explorer. One of the newly\ncreated threads looks similar to the “PipeServerThread” which can be found in the leaked\nGozi sourcecode.\n\n\n-----\n\nGozi source code\n\nGozi thread code\n\n## Summary\n\n\n-----\n\nIn this blog post we have looked at some of the tricks the latest version of Gozi uses to try\nand bypass defenses:\n\nprotecting C2 assets\nfileless persistence\npatching of mapped executable in memory\ninventive LOLbin usage\nAMSI content chunking\n\nThe threat actors behind Gozi are clearly interested in keeping the latest version under the\nradar. By using the above techniques in addition to only targeting specific GEOs (GB, IT, AU)\nSophosLabs data shows V3 as less prevalent than V2. Importantly for the defender side the\nabove techniques can often be something of an Achilles heel, providing detection\nopportunities because of the distinctive characteristics they provide.\n\n### Detections\n\nComponents of the Gozi malware are reported as one or more of the following definitions in\nSophos endpoint detection products:\n\nHPmal/Gozi-*\nMal/Ursnif-A and -C\nMal/EncPk-AOY\n\n### Acknowledgments\n\n[SophosLabs would like to thank independent malware hunter JamesWT for his contributions](https://twitter.com/JAMESWT_MHT)\ntowards mapping local Gozi Version 3 campaigns.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-24 - Gozi V3- tracked by their own stealth.pdf"
    ],
    "report_names": [
        "2019-12-24 - Gozi V3- tracked by their own stealth.pdf"
    ],
    "threat_actors": [
        {
            "id": "f276b8a6-73c9-494a-8ab2-13e2f1da4c53",
            "created_at": "2022-10-25T16:07:24.441133Z",
            "updated_at": "2025-03-27T02:02:10.231958Z",
            "deleted_at": null,
            "main_name": "Achilles",
            "aliases": [],
            "source_name": "ETDA:Achilles",
            "tools": [
                "RDP",
                "Remote Desktop Protocol"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536233,
    "ts_updated_at": 1743041346,
    "ts_creation_date": 1653761286,
    "ts_modification_date": 1653761286,
    "files": {
        "pdf": "https://archive.orkl.eu/4137b5b156f6cd115e52723070eccfc9db600952.pdf",
        "text": "https://archive.orkl.eu/4137b5b156f6cd115e52723070eccfc9db600952.txt",
        "img": "https://archive.orkl.eu/4137b5b156f6cd115e52723070eccfc9db600952.jpg"
    }
}