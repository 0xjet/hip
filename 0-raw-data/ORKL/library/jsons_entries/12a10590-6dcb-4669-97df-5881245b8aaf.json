{
    "id": "12a10590-6dcb-4669-97df-5881245b8aaf",
    "created_at": "2023-01-12T15:08:43.951758Z",
    "updated_at": "2025-03-27T02:05:38.735978Z",
    "deleted_at": null,
    "sha1_hash": "194944b329af46c894ab71a00aa9f62cd5eac9e8",
    "title": "2020-07-30 - Dissecting Ragnar Locker- The Case Of EDP",
    "authors": "",
    "file_creation_date": "2022-05-28T04:58:18Z",
    "file_modification_date": "2022-05-28T04:58:18Z",
    "file_size": 5761324,
    "plain_text": "# Dissecting Ragnar Locker: The Case Of EDP\n\n**[blog.blazeinfosec.com/dissecting-ragnar-locker-the-case-of-edp/](https://blog.blazeinfosec.com/dissecting-ragnar-locker-the-case-of-edp/)**\n\nFederico Bento July 30, 2020\n\n**Introduction**\n\nOn April 13th 2020, news broke out on Portuguese media [1] that Energias de Portugal\n(EDP), the Portuguese multinational energy giant and one of the largest European operators\nin energy & wind sectors, had been hit by a highly targeted ransomware attack (later\nidentified as Ragnar Locker [2]), amid COVID-19 pandemic, while the country had been\nunder state of emergency. The attackers behind the ransomware were, supposedly (although\nnot confirmed), demanding 1580 BTC (9.9 million EUR) by threatening to leak all of the\nstolen data (10TB, according to the perpetrators themselves). It has since been considered\none of its worst cyber attacks.\n\nAs such, and as an information security consultancy company based in Porto, Portugal, we\nhave decided to take initiative in investigating the ransomware sample ourselves by getting\nour hands dirty and going right down to its truth. We were specifically interested in\nunderstanding how this ransomware was built, i.e., its technical details, its capabilities and\nsophistication. The analysis and its end results are therefore presented in this blog post, in a\ndetailed fashion, for all the curious readers who wish to know more about the final\n(destructive) part of the hack.\n\n**Analysis**\n\n\n-----\n\nOne of the very first steps an analyst should do when first interacting with a potentially\nmalicious executable is to perform basic static analysis on the PE, e.g., look at its PE\nheaders, sections, imports, strings, or any other information that can help him get an overall\ngeneral idea of what the binary might do or contain. In this particular case, when looking at\nits imports, we can see several windows APIs which are commonly (ab)used by malware in\norder to hide their deed. This includes (but not limited to) VirtualAlloc*(), LoadLibrary*() and\nGetProcAddress(). Something weird that stood out when looking at the imports is the\nexistence of several APIs that are only needed for thread synchronization\n(InitializeCriticalSectionAndSpinCount(), EnterCriticalSection(), LeaveCriticalSection() and\nDeleteCriticalSection()), yet, there are no imported APIs responsible for creating threads in\nthe first place, e.g., CreateThread().\n\nHex dumping our target shows several strings, of which some, after looking them up on\ngoogle, reveals pages related to malware and malware analysis services.\n\n\n-----\n\nOnce a more in depth analysis takes place, it becomes quite clear that the ransomware is, in\nsome way, obfuscated. For example, and for demonstration purposes, the following image\ndisplays a function that is called with the string\n\"EV_MMAC_OID_TERMINATE_CONNECTION\" as argument, where the string is never\nactually used for anything and an existing loop is never entered due to the result of the\ncomparison always leaving EFLAGS.ZF unset (opaque predicate).\n\n\n-----\n\nThe thread synchronization APIs mentioned earlier also take part of the obfuscation\n(essentially junk code), where a loop is concluded after being executed 2000000 times,\nperforming useless arithmetic operations and calling a function which always returns 0 along\nthe way.\n\nThe interesting parts, from a malware analysis point of view, will only take place once the\nransomware calls VirtualAllocEx() with PAGE_EXECUTE_READWRITE memory\npermissions (flProtect). The allocation of pages with such memory permissions is highly\nindicative that something interesting will be written into them that will later be treated as code\nto be executed, possibly taking part on the unpacking process.\n\n\n-----\n\nThe following image demonstrates the algorithm being used by the ransomware, where it\nstarts decompressing/decrypting and writing shellcode into the new memory area.\n\nWhen it is finished writing the shellcode, it will call GetModuleHandleW(L\"kernel32\") in order\nto obtain the base address of kernel32.dll that is mapped in the current process address\nspace. It will then transfer control-flow into the new RWX memory area containing the newly\ndecrypted shellcode, passing the pointer to the retrieved kernel32.dll base address as\nargument.\n\n\n-----\n\nAt this point, execution of the shellcode takes place. The following image demonstrates its\ninitial instructions.\n\n\n-----\n\nAs it can be seen from the above image, the shellcode starts by performing a series of MOV\nr/m8, imm8 instructions that are being used to construct on the stack, one byte at a time,\nstrings representing names of Windows APIs. After it is done placing them on the stack, it\nwill call a subroutine passing, again, the base address of kernel32.dll and the string\n\"GetProcAddress\" as argument.\n\nThe following image demonstrates the initial instructions of this subroutine.\n\nFor anyone that has done enough malware reversing, or simply to anyone familiar with the\nPE file format, it becomes clear that this function is being used to manually iterate through\nkernel32.dll's exports in order to dynamically resolve, at runtime, the address of\nGetProcAddress() so that it can be subsequently used. The giveaway is the fact that first, it\ngets the address of kernel32.dll's PE header by adding kernel32.dll's base address (DOS\nHeader) with the value stored in the e_lfanew field (at offset 0x3C). Then, it will obtain the\naddress of the Export Table by adding the Relative Virtual Address (RVA) located in pNtHdr\n\n-----\n\n>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress (at\noffset 0x78). After GetProcAddress() is resolved, it will then be used to dynamically resolve\nthe rest of the APIs whose names were constructed previously one byte at a time on the\nstack.\n\nThen, VirtualAlloc() is called, but this time the memory access permissions do not include\nexecution, allowing only reads and writes (PAGE_READWRITE).\n\nEventually, a relatively long series of operations are performed, resulting in writes to the\nnewly allocated memory region, where a full PE is decrypted at runtime into it. It is easily\nrecognizable through the MS-DOS MZ header. This particular point is the best time to dump\nthe memory region into disk, as the PE is in its unmapped (raw) format, i.e., how it is stored\non disk, versus its mapped (virtual) format, i.e., how it needs to be loaded into memory by\nthe loader for actual program execution.\n\n\n-----\n\nBy dumping the PE to disk, it can be further analyzed through the very same basic static\nanalysis steps in order to get a general idea of what this new binary might have (or do). As\nwe can see, it contains an interesting .keys section and its Time Date Stamp (compilation\ndate) is set to Monday, 06.04.2020 19:57:20 UTC. This date is particularly interesting as it's\njust a few days prior to the actual initial reports of the attack. Please note, however, that such\ndate can be easily modified.\n\nProceeding execution, the SizeOfImage (the size of the image, in bytes, including all\nheaders) of the newly decrypted PE is then obtained, via pNtHdr>OptionalHeader.SizeOfImage, as seen by the use of offset 0x3C to get the address of the\nPE header, and then by adding to that result 0x50. The SizeOfImage will be used as the\ndwSize argument of the VirtualAlloc() call that follows, with lpAddress being the base\naddress of the currently running process' binary image and memory access permissions set\nto PAGE_EXECUTE_READWRITE.\n\n\n-----\n\nAfter the VirtualAlloc() call, the main binary's image (of the currently running process) is\noverwritten with 0's, in a loop that ends after executing SizeOfImage (of the new decrypted\nPE) times.\n\n\n-----\n\nThen, the new PE's headers are copied into its place, as well as it loads its sections into the\ncorrect locations, not caring about their memory permissions. At this point, we can already\ntell that the ransomware performs self process injection.\n\n\n-----\n\nBy comparing the base address where the new PE was placed against its ImageBase\n(preferred base address), via pNtHdr->OptionalHeader.ImageBase (as seen by offset 0x34),\nit can decide whether base relocations need to take place or not. In this case, base\nrelocations do not need to be performed, but there is code inside the shellcode that could do\nit in case it was needed.\n\n\n-----\n\nThe Import Address Table (IAT) is then fixed up by first loading needed DLLs and then\nresolving needed imports by the PE. The following image demonstrates this initial process,\nas seen by accessing the Import Table, via pNtHdr>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress\n(offset 0x80).\n\n\n-----\n\nBy accessing AddressOfEntryPoint, via pNtHdr->OptionalHeader.AddressOfEntryPoint\n(offset 0x28), the Original Entry Point (OEP) is then obtained and subsequently called, thus\ntransfering execution to the newly unpacked executable, as it is now ready to be executed.\n\n\n-----\n\nOne of the very first things that is done after execution starts at the new PE s entry point is to\ncall a subroutine that eventually calls GetLocaleInfoW() with LCID\nLOCALE_SYSTEM_DEFAULT (default locale for the operating system), in order to compare\nit against a possible set of unicode strings previously constructed on the stack by mov\ninstructions. The constructed unicode strings are:\n\nBelorussian\nAzerbaijani\nUkrainian\nMoldavian\nGeorgian\nArmenian\nTurkmen\nRussian\nKyrgyz\nKazakh\nUzbek\nTajik\n\nIf the requested locale information matches any of those strings, as seen by the use of\nlstrcmpiW(), then the current process is terminated via TerminateProcess() with exit code\n666.\n\n\n-----\n\nIt then calls GetComputerNameW(), GetUserNameW() and some other function twice with\ndifferent arguments, the first time with \"SOFTWARE\\Microsoft\\Cryptography\" and\n\"MachineGuid\", while the second time with \"SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\" and \"ProductName\".\n\nThe function simply allocates a page via VirtualAlloc(), opens the provided subkey via\nRegOpenKeyExW() from the HKEY_LOCAL_MACHINE (HKLM) registry hive and\nKEY_READ access rights, and then retrieves the data for the provided value name\nassociated with the opened registry key via RegQueryValueExW(). The pointer to the\nretrieved data (the page returned from the VirtualAlloc() call) is then the return value of this\nfunction.\n\nFor each of the data obtained via the calls to the APIs (GetComputerNameW() and\nGetUserNameW()) and the function responsible for retrieving the data associated with the\nopened registry keys, it will perform a series of operations on them. Specifically, for each\n\n\n-----\n\ncharacter, it will XOR it the value 0xAB01FF3C, add the previous value to the next one,\nrotate it left 13 bits and subtract the result of the rotate operation with the value before the\nrotate. This is done so that unique IDs result from the operations, where they are later\nconcatenated.\n\nThe result of the previous operations (unique IDs) and their concatenation is so that it will be\nused as lpName (the name of the event object) passed to CreateEventW(). But first, it\nchecks if argc (argument count) is 1, if it's not, CreateEventW() is skipped entirely. However,\nif it is 1, a loop is entered where CreateEventW() is called each time and it only breaks out of\nit if the return value of the CreateEventW() API call differs from 183\n(ERROR_ALREADY_EXISTS). Otherwise, the loop is repeated 32768 times, at which point\nthe current process is terminated via TerminateProcess() with exit code 666.\n\n\n-----\n\nThen, it will enter another loop, executed 17 times, where it tries to open\n\\\\.\\PHYSICALDRIVE%d (a physical hard drive) via CreateFileW(), where %d is incremented\nfor each iteration in the loop, starting from 0. If the return value from CreateFileW() differs\nfrom 0xFFFFFFFF, it will then call DeviceIoControl() on the handle with control code\nIOCTL_DISK_SET_DISK_ATTRIBUTES, attempting to bring the disk online and allowing\nwrite operations (Attributes field in SET_DISK_ATTRIBUTES struct is set to 0, and\nAttributesMask field set to 0x3). It will also call DeviceIoControl() again, this time with control\ncode IOCTL_DISK_UPDATE_PROPERTIES, invalidating the cached partition table and\nsynchronizing the system view of the specified disk device, since at this point it would have\nbeen modified.\n\n\n-----\n\nFor every existing volume without an associated drive letter, it will then attempt to associate it\nan unused drive letter. This is done by scanning and iterating through existing volumes on\nthe system by making use of the FindFirstVolumeA()/FindNextVolumeA() combination and\ndetermining whether a drive letter is already associated with the volume via\nGetVolumePathNamesForVolumeNameA(). If no drive letter has been associated with the\nvolume, it will then obtain available drive letters via a call to GetLogicalDrives(), where the\nfirst unset bit from the returned bitmask (starting from the 4th) can be used.\n\nAt this point, the same routine will be called twice, one after the other, with different\narguments.\n\n\n-----\n\nThis routine is responsible for generating, via CryptGenRandom(), cryptographically random\nbytes of length specified as second argument to the routine, storing it at the address\nspecified in the first argument. These random bytes are subsequently modified by a relatively\nlong series of operations.\n\nAnother routine will be called, this time called thrice. One of the arguments to the function\nthat is always passed is a pointer to a suspiciously looking string.\n\n)\n\n\n-----\n\nIt turns out that this function is responsible for decrypting several data stored in the binary s\n.keys section. The first time the routine is called, it decrypts the Tor client chat ID used to\ncommunicate with the perpetrators.\n\nThe second time it is called, it is used to decrypt a series of strings, which will later be used\nas reference for substrings to look for in order to determine what services to stop, as we will\nsee. The strings are:\n\nvss\nsql\nmemtas\nmepocs\nsophos\nveeam\nbackup\n\n\n-----\n\npulseway\nlogme\nlogmein\nconnectwise\nsplashtop\nmysql\nDfs\n\nThe third time it is called, it is used to decrypt another series of strings, which will later be\nused as reference for substrings to look for in order to determine which processes to\nterminate, as we will also see. The strings are:\n\nsql\nmysql\nveeam\noracle\n\n\n-----\n\nocssd\ndbsnmp\nsynctime\nagntsvc\nisqlplussvc\nxfssvccon\nmydesktopservice\nocautoupds\nencsvc\nfirefox\ntbirdconfig\nmydesktopqos\nocomm\ndbeng50\nsqbcoreservice\nexcel\ninfopath\nmsaccess\nmspub\nonenote\noutlook\npowerpnt\nsteam\nthebat\nthunderbird\nvisio\nwinword\nwordpad\nEduLink2SIMS\nbengine\nbenetns\nbeserver\npvlsvr\nberemote\nVxLockdownServer\npostgres\nfdhost\nWSSADMIN\nwsstracing\nOWSTIMER\ndfssvc.exe\ndfsrs.exe\n\n\n-----\n\nswc_service.exe\nsophos\nSAVAdminService\nSavService.exe\n\nAfter some data has been decrypted, as seen in the previous steps, it will now attempt to\nestablish a connection to the service control manager (via OpenSCManagerA()) of the local\ncomputer (lpMachineName is set to NULL) and open the SERVICES_ACTIVE_DATABASE\ndatabase (lpDatabaseName set to NULL) with the dwDesiredAccess argument set to\nSC_MANAGER_ALL_ACCESS. The first call to EnumServicesStatusA() should fail, with the\nlast-error code set to ERROR_MORE_DATA, as cbBufSize (the size of the buffer pointed to\nby the lpServices parameter, in bytes) is set to a small value (36 bytes). If it does fail, then\npcbBytesNeeded will receive the number of bytes needed to return the remaining service\nentries (via the second call to EnumServicesStatusA()), where execution can now continue\nto the code path that will attempt to stop some services.\n\n\n-----\n\nFor every enumerated service that contains a substring (StrStrIA()) from the possible set of\nstrings existing in the previously decrypted data, it will call a subroutine.\n\n\n-----\n\nThis subroutine is responsible for calling GetTickCount(), opening the existing service via\nOpenServiceA() with dwDesiredAccess of SERVICE_STOP | SERVICE_QUERY_STATUS |\nSERVICE_ENUMERATE_DEPENDENTS, look up the status of the service via\nQueryServiceStatusEx() and:\n\nIf its dwCurrentState is SERVICE_STOPPED, it closes the service handle via\nCloseServiceHandle() and returns.\n\nIf its dwCurrentState is SERVICE_STOP_PENDING, then it will enter a loop where it\nsleeps via Sleep() for either 10000 or 1000 milliseconds, calls QueryServiceStatusEx()\nagain and exists the loop if dwCurrtentStats is SERVICE_STOPPED or if more than\n30000 milliseconds have passed (via another call to GetTickCount() and subtracting it\nits previous value).\n\nIf its dwCurrentState is SERVICE_RUNNING, it will then attempt to enumerate its\ndependent services via EnumDependentServicesA(), open the enumerated dependent\nservices via OpenServiceA() with dwDesiredAccess of SERVICE_STOP |\nSERVICE_QUERY_STATUS and call ControlService() on them with dwControl of\nSERVICE_CONTROL_STOP. After the enumerated dependent services are stopped, it\nwill finally call ControlService() on the initial opened service and stop it by using, again,\nthe dwControl of SERVICE_CONTROL_STOP.\n\n\n-----\n\nAfter the services are dealt with (stopped), it's now time for some process termination. As in\nthe services case, it loops through all the processes in the system and checks via StrStrIA()\nif a substring referred in the previous decrypted data is present in its name. It does this by\nfirst calling CreateToolHelp32Spanshot() with dwFlags TH32CS_SNAPALL (and\nth32ProcessID 0), then processes are iterated via the Process32FirstW()/Process32NextW()\ncombination.\n\n\n-----\n\nIf the process name contains any substring as indicated by the decrypted data, then the\nprocess is opened via OpenProcess() with dwDesiredAccess of PROCESS_TERMINATE\nand terminated via TerminateProcess() with exit code 666.\n\nAfter process termination, another routine is called. This routine first calls\nGetNativeSystemInfo() in order to check the value of\nDUMMYUNIONNAME.DUMMYSTRUCTNAME.wProcessorArchitecture stored in the\nSYSTEM_INFO struct. If wProcessorArchitecture is\nPROCESSOR ARCHITECTURE AMD64 (0x9) then LoadLibraryW(L\"kernel32 dll\") is called\n\n\n-----\n\nand the address of Wow64EnableWow64FsRedirection() is obtained via a call to\nGetProcAddress(). This WinAPI is then called with Wow64FsEnableRedirection set to\nFALSE, thus disabling WOW64 system folder redirection.\n\nWhen redirection is disabled, two unicode strings are built on the stack by a series of mov\ninstructions. These unicode strings will be used as lpCommandLine for subsequent calls to\nCreateProcessW(). The executed command lines are:\n\nwmic.exe shadowcopy delete\n\n\n-----\n\nvssadmin delete shadows /all /quiet\n\nRight after shadow copy deletion, LoadLibraryW(L\"kernel32.dll\") is called once again and\nWow64EnableWow64FsRedirection() is obtained via GetProcAddress(), this time in order to\nbe called with Wow64FsEnableRedirection set to TRUE, thus enabling WOW64 system\nfolder redirection. The routine then returns.\n\n\n-----\n\nIt is now time for some more data decryption from the .keys section. This time, the data that\nis decrypted is a 2048-bit RSA public key. We will see how it will be used later.\n\n\n-----\n\nOther data that is decrypted, by another call to the routine, is the final ransom note. Please\nrefer to the following image.\n\n\n-----\n\nThe 2048-bit RSA public key is then converted and its public key information imported via\nCryptImportPublicKeyInfo() into the provider.\n\n\n-----\n\nBy calling a subroutine twice that calls CryptEncrypt(), the previous two cryptographically\nrandom data that were generated by both calls to CryptGenRandom(), which were\nsubsequently modified through a series of operations, will be encrypted with the 2048-bit\npublic key.\n\n\n-----\n\nVia a call to GetComputerNameW(), and through the same series of operations that were\nused to generate unique IDs for the CreateEventW() even object name (lpName), an hex\nencoded ID is generated.\n\nThrough concatenation, by making use of lstrcatW(), and a call to\nSHGetSpecialFolderPathW() with csidl CSIDL_COMMON_DOCUMENTS, the path\nC:\\Users\\Public\\Documents\\RGNR_E354BDB6.txt is built.\n\n\n-----\n\nAlong the way, a block of heap memory allocated via RtlAllocateHeap() is called with\nHEAP_ZERO_MEMORY as Flags, which initializes it with 0's. For some reason, this memory\narea will be, again, zeroed out after the call to RtlAllocateHeap().\n\n\n-----\n\nThe Tor client chat ID previously decrypted is then converted to Base64, by making a call to\nCryptBinaryToStringA(), as seen by the use of dwFlags set to CRYPT_STRING_BASE64.\n\nThe previously decrypted specifically targeted ransom note that will be left in the attacked\nsystems is then written via WriteFile() to the\nC:\\Users\\Public\\Documents\\RGNR_E354BDB6.txt path that had been built moments prior,\nby first opening it via CreateFileW() with dwDesiredAccess of GENERIC_READ |\nGENERIC_WRITE.\n\nThen, through concatenation, the \"RAGNAR SECRET\" will be appended to the file, which is\nsimply the Base64 encoded version of the Tor client chat ID.\n\n\n-----\n\nAfter the file with the ransom note has been written to, the ransomware will check if argc\n(argument count) is higher than 1. The ransomware can be executed with \"-list\" or \"-force\"\ncommand line options. These are simply used to determine how the paths that will be used\nas base to start file encryption are obtained. The command line option \"-list\" gets the paths\nfrom a file given as argument, while \"-force\" starts file encryption from the path given as\nargument. Since the end goal is file encryption, and these command line options were\nprobably used solely during development for testing purposes by the attackers, we will\ncontinue examining as if no arguments are given, i.e., argc == 1.\n\n\n-----\n\nThrough the GetLogicalDrives() API call, a bitmask representing the currently available disk\ndrives is obtained. For every available disk drive, as indicated by the set bits, its\ncorresponding drive letter is retrieved by adding 0x41 ('A'). If GetVolumeInformationW()\nreturns successfully (non-zero) on the volume and its drive type (obtained via a call to\nGetDriveTypeW()) differs from DRIVE_CDROM, then it can proceed using it as a base to\nstart the file encryption process. The currently obtained drive letter is also compared against\nthe drive letter being used in the WindowsDirectory (e.g., C:\\Windows) gotten by the call to\nGetWindowsDirectoryW(), and if they match, an integer being treated as a flag will be set to\n1, otherwise it'll continue being 0.\n\n\n-----\n\nThe file containing the ransom note is then copied into this newly obtained path.\n\nAfter the file is copied, a subroutine will be called with this new path as argument. One of the\nother arguments to this subroutine is the integer being treated as a flag to indicate whether\nthe drive letter of the current path matches the drive letter being used where the\nWindowsDirectory is located. This subroutine starts by iterating through all files and\ndirectories existing in the path given as argument, via the FindFirstFileW()/FindNextFileW()\n\n\n-----\n\ncombination. At first, it only cares about directories and checks if it is not . or .. . If it s not\nany of those directories, then it checks whether the integer flag passed as argument is set or\nnot. If it is set, i.e., it's the drive letter being used by WindowsDirectory, then further checks\ntake place.\n\nThe checks that take place when the flag passed as argument is set occur so that certain\ndirectories are skipped and nothing will be done on them. The directories that are compared\nagainst the currently obtained directory are:\n\nWindows\nWindows.old\nTor Browser\nInternet Explorer\nGoogle\nOpera\nOpera Software\nMozilla\nMozilla Firefox\n$Recycle.bin\nProgramData\nAll Users\n\n\n-----\n\nIf the obtained directory is not any of those above mentioned directories, then the ransom\nnote file will be copied into this new directory, and the subroutine will be recursively called\nwith this new path. The integer being treated as a flag is still passed as set.\n\nWhen all files/directories have been iterated and went through the checks, i.e.,\nFindNextFileW() returns NULL, it will then start iterating again through all files/directories.\nThe goal, this time, is to look for files specifically. For every file encountered, it compares its\nname against a set of possible filenames These filenames are:\n\n\n-----\n\nThe ransom note filename\nautorun.inf\nboot.ini\nbootfont.bin\nbootsect.bak\nbootmgr\nbootmgr.efi\nbootmgfw.efi\ndesktop.ini\niconcache.db\nntldr\nntuser.dat\nntuser.dat.log\nntuser.ini\nthumbs.db\n\nIf the currently found file's name matches any of the above filenames, then nothing is done it\nwith and it is skipped.\n\nIf the currently found file's name does not match the above list of filenames, then extension\nchecks will also be performed. Specifically, the current file's extension is checked against:\n\n\n-----\n\n.db\n.sys\n.dll\n.lnk\n.msi\n.drv\n.exe\n\nIf the extension of the current file's name matches any of the above list of extensions, then\nnothing is done with it and it is skipped. If it doesn't match, however, the pointer to the file's\nname will be added into a stack array.\n\nIf 64 files in the current directory under examination have been added into the stack array\n(thus passing all of the above checks), then 64 threads will be created via CreateThread().\nEach of the 64 pointers in the stack array are passed as lpParameter and the routine that\nhandles file encryption is passed as lpStartAddress.\n\n\n-----\n\nIf, at the end of examination of the directory, the number of files in the stack array are less\nthan 64, then a thread will be created via CreateThread for each of the files. Each of the\npointers in the stack array are passed as lpParameter and the routine that handles file\nencryption is also passed as lpStartAddress.\n\nIn the thread that handles file encryption, it first reads via ReadFile() the 9 last bytes of the\nfile. If the marker string _RAGNAR_ is found, then this file will not be encrypted, as it is\nalready the result of previous encryption, as we will see.\n\n\n-----\n\nIf the marker is not found, a routine is called which performs a series of operations on both\ncryptographycally random bytes resulted from the calls to CryptGenRandom() (although\nimmediatly later modified by another series of operations). The call to this function is seen\nbelow. The result will later be used in the actual file encryption process.\n\nA teaser on these operations is demonstrated in the following image.\n\n\n-----\n\nThen, the actual routine that encrypts the file is called.\n\nThe encryption cipher used is based on add-rotate-xor (ARX) operations, appearing to be a\nmodified version of the Salsa20 stream cipher. The following image demonstrates what very\nclosely resembles it.\n\n\n-----\n\nWhen file encryption is complete, both cryptographycally random sequence of bytes that\nwere encrypted by the 2048-bit RSA public key will be appended into the encrypted file. The\nfile marker _RAGNAR_ is also appended.\n\n\n-----\n\nAfter everything is written into the new file as part of the encryption process, the file will be\nmoved via MoveFile(), essentially adding it a new extension: .ragnar_E354BDB6\n\nFinally, after everything is complete, the ransomware will end execution by:\n\nRetrieving the SessionID of the console session (the session that is currently attached\nto the physical console) via WTSGetActiveConsoleSessionId()\nOpening the current process token via OpenProcessToken() with DesiredAccess of\nTOKEN_ALL_ACCESS\n\n\n-----\n\nCreating a new access token that duplicates it via DuplicateTokenEx with\ndwDesiredAccess of TOKEN_ALL_ACCESS and TokenType of TokenPrimary\nSetting the console's SessionID on the new duplicated access token via\nSetTokenInformation()\nCreating a process using the new access token via CreateProcessAsUserW(), starting\nnotepad.exe with the ransom note file as its argument\nCalling ExitProcess(0)\n\nAnd now for the obligatory ransom note display.\n\n\n-----\n\n**Conclusion**\n\nFrom the thorough analysis of the Ragnar Locker ransomware that left a specifically targeted\nransom note to Energias de Portugal, a few things can therefore be concluded. First, it is\nentirely obvious that no inside or outside world connections are attempted by the\nransomware itself, proving that any stolen files must have had to be stolen and exfiltrated\nfrom their network before ransomware execution by the attackers. The unpacked executable\nhas a Time Date Stamp (compilation date) of \"Monday, 06.04.2020 19:57:20 UTC\", which is\n7 days earlier than that of actual deployment, possibly hinting that the perpetrators had\naccess into EDP's networks since at least that specific date.\n\nThe ransomware does not ship any anti-debugging or anti-VM techniques, nor does it really\ndo much in order to thwart or even slow down analysis from unintended prying eyes. Many of\nthe actions performed by the ransomware would require SYSTEM privileges, even though it\ndoes not contain any UAC \"bypassing\" capabilities (note the double quotes; UAC is not a\nsecurity boundary). However, since it has been manually executed by the attackers who\nmust have had prior access, such permissions could be easily identified (and possibly\nobtained) before deployment. It is the actual definition of ransomware, doing no more and no\nless. If the default locale of the systems where the ransomware is run has a specific set of\npossible settings, the process immediatly terminates.\n\nIn theory, the perpetrators can possess file decryption capabilities, as the cryptographycally\nsecure data used to then derive the symmetric key and nonce are appended to the newly\nencrypted files, in encrypted form, using the 2048-bit RSA public key that is embedded in the\n\n\n-----\n\nbinary (decrypted at runtime only). The ransomware could have most probably been\ndetected either via static analysis or at runtime as it were executing due to its heavy use of\nseemingly malicious WinAPIs.\n\nWe sincerely hope that you have enjoyed our deep dive into the technical side of the final\nstages of the attack.\n\nCheers and until next time,\nBlaze Information Security\n\n**IOC Hashes (SHA256)**\n\nPacked Sample:\n\n68eb2d2d7866775d6bf106a914281491d23769a9eda88fc078328150b8432bb3\n\nUnpacked Sample:\n\n1de475e958d7a49ebf4dc342f772781a97ae49c834d9d7235546737150c56a9c\n\n**References**\n\n[1] - https://observador.pt/2020/04/13/edp-alvo-de-ataque-informatico-que-bloqueousistemas-de-atendimento-aos-clientes/\n\n[2] - https://www.bleepingcomputer.com/news/security/ragnarlocker-ransomware-hits-edpenergy-giant-asks-for-10m/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-30 - Dissecting Ragnar Locker- The Case Of EDP.pdf"
    ],
    "report_names": [
        "2020-07-30 - Dissecting Ragnar Locker- The Case Of EDP.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536123,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1653713898,
    "ts_modification_date": 1653713898,
    "files": {
        "pdf": "https://archive.orkl.eu/194944b329af46c894ab71a00aa9f62cd5eac9e8.pdf",
        "text": "https://archive.orkl.eu/194944b329af46c894ab71a00aa9f62cd5eac9e8.txt",
        "img": "https://archive.orkl.eu/194944b329af46c894ab71a00aa9f62cd5eac9e8.jpg"
    }
}