{
    "id": "a178c1e1-25bb-4ee7-862c-a047b1968b91",
    "created_at": "2023-01-12T14:58:55.391898Z",
    "updated_at": "2025-03-27T02:05:36.768988Z",
    "deleted_at": null,
    "sha1_hash": "dba6f54a7f4e59d750d4dda09e9ebbb06e4460d7",
    "title": "2020-10-26 - Dropping the Anchor",
    "authors": "",
    "file_creation_date": "2022-05-28T19:47:59Z",
    "file_modification_date": "2022-05-28T19:47:59Z",
    "file_size": 391029,
    "plain_text": "# Dropping the Anchor\n\n**netscout.com/blog/asert/dropping-anchor**\n\nmalware\nBanking Trojans\nBot\n\n## Trickbot Anchor Analysis\n\nby [Suweera De Souza on October 26th, 2020](https://www.netscout.com/blog/asert/suweera-de-souza)\n\n## Executive Summary\n\n[Trickbot has long been one of the key banking malware families in the wild. Despite recent disruption events, the](https://www.washingtonpost.com/national-security/cyber-command-trickbot-disrupt/2020/10/09/19587aae-0a32-11eb-a166-dc429b380d10_story.html)\noperators continue to drive forward with the malware and have recently begun porting portions of its code to the\nLinux operating system As this technical deep dives shows the communication between the command and\n\n\n-----\n\ncontrol (C2) server and the bot are extremely complex. Additionally, we have analyzed the C2 communication\nprocess of the Linux2 version of Trickbots’ Anchor module.\n\n## Key Findings\n\nTrickbot operators leverage a complex communication schema to control infected machines.\n[Recent efforts show the operators moving portions of their code to Linux, thus increasing the portability and](https://medium.com/stage-2-security/anchor-dns-malware-family-goes-cross-platform-d807ba13ca30)\nrange of possible victims.\nThe Anchor module can implement techniques such as process hollowing and process doppelgänging to\nevade analysis.\nBoth Windows- and Linux -based bots have the ability to install additional modules in a victim’s system.\n\n## Communication Setup\n\nTrickbot’s Anchor framework is a backdoor module discovered in 2018. Unlike Trickbot’s typically broad-based\ncampaigns, Anchor is deployed exclusively on selected targets. Anchor’s communication with the C2 currently\nuses DNS tunneling, which we will break down later.\n\nThis communication involves a few different steps. The purpose of this blog is to make sense of this\ncommunication and understand how the C2 operates the bot.\n\nFigure 1: Parts of\n\ncommunication between Bot and C2\n\nFrom a high-level view, Figure 1 shows the flow of communication between the bot and the C2. Throughout the\ncommunication process; there are commands meant for the bot (which will be termed as bot_commands) as well\nas the C2 (termed as c2_commands). A description of the commands seen in Figure 1 is provided in Table 1\nbelow.\n\n1. Part 1 of the communication is the initial setup between the bot and the C2. The bot sends the c2_command\n\n_0 to the C2, which contains information about the client, including the bot ID (part 1 of Figure 1). Once the_\ninitial communication is established, the C2 responds with a message that contains the signal /1/.\n2. In part 2 of the communication, the bot sends back the same signal (which is also the c2_command 1), and\n\nthe C2 responds with a bot_command (part 2 of Figure 1).\n3. The bot may make further request for the C2 to send an executable file, depending on the initial bot\n\ncommand received (part 3 of Figure 1).\n4. Finally, the bot sends back the result of the execution to the C2 (part 4 of Figure 1).\n\nTable 1: Parts of communication between bot and C2\n\n\n-----\n\n**Bot**\n**Commands**\n**(Linux)** **Purpose**\n\n0 Execute instruction via\ncmd.exe in the Windows\nshares\n\n1 or 2 Execute file in Windows\nshare\n\n3 or 4 Execute DLL with\nexport control_RunDLL in\nWindows shares\n\n\n**C2**\n**Commands** **Purpose**\n\n0 Initial C2 Comms\nsetup/register bot\n\n1 Ask C2\nfor bot_command\n\n\n**Bot**\n**Commands**\n**(Windows)** **Purpose**\n\n0 execute instruction\nvia cmd.exe\n\n1 or 2 Execute EXE\nin %TEMP%\n\n\n5 Obtain PE file 3 or 4 Execute DLL\nin %TEMP%\n\n<filename> Obtain PE file 5 or 6 Execute PE file\nusing process\nhollowing\n\n\n10, 11, or\n12\n\n\nExecute Linux file\n\n\n10 Result of the\nexecution of\nthe bot_command\n\n## Creation of DNS queries\n\n\n7 or 8 Execute PE using\nprocess\ndoppelganging\n\n9 Execute instruction\nvia pipe object to\ncmd.exe\n\n10 Execute instruction\nvia pip object to\npowershell.exe\n\n11 or 12 Inject PE into\nmultiple process\n\n13 Change the bot's\nscheduled task\n\n14 Uninstall the bot\n\n\n100 Check bot GUID\n\n\nEvery part of communication (Figure 1) made to the C2 follows a sequence of 3 different DNS queries (Figure 2).\n[NTT previously published an article that explores how the DNS queries were created by the bot to the Anchor C2](https://hello.global.ntt/zh-cn/insights/blog/trickbot-variant-communicating-over-dns)\nserver. In this blog, we researched further into the protocol to better understand the role of each part of the DNS\nquery.\n\n\n-----\n\nFigure 2: High-level overview of the\n\nDNS queries\n\n**Figure 2 gives a high-level overview of what the DNS queries look like. Each of these queries have their own**\nformat on the type of data that is sent to the malware C2, as explained below:\n\n### Query 0\n\n**Bot DNS Query**\n```\n0<UUID bytes><current_part><total_parts>/anchor_dns/<Bot_GUID>/<c2_command>/<content>/\n\n```\n0 – Indicating type 0 query\nUUID – 16 bytes in length generated by the bot\ncurrent_part – The current part of the data being sent (this is further explained below)\ntotal_parts – Total number of parts the data is divided into\nanchor_dns – The type of Anchor bot that is communicating to the C2.\nBot_GUID – The GUID generated is different for Windows and Linux platforms\nc2_command – The command meant for the C2\ncontent – The content to send based on the type of command (Table 2)\n\nThe Anchor module generates a GUID which is different for each platform:\n\nWindows - <hostname_windowsVersion>.<32 bytes client id>\nLinux – <system_linnuxVersion>.<32 bytes client id>\n\nEach command sent to the C2 is followed by its own set of content (Table 2):\n\nTable 2: Content for c2_command\n\n**c2_command** **Content**\n\n0 /<Windows OS Info>/1001/<bot_IP><64 bytes random bytes><32 bytes random alphanumeric\ncharacters>/\n\n1 /<32 bytes random alphanumeric characters>/\n\n5 /<filename>/\n\n<filename> N/A\n\n10 /<bot_command>/<bot_command_ID>/<result of bot execution>/\n\n\n-----\n\nSince the maximum length of a DNS name is 255 bytes, the data sent for the first query gets sent in parts. This\nalso explain the fields current_path and total_parts seen in the type 0 query. Below is the pseudocode on how\nmany parts the data gets divided into:\n```\ndef get_total_parts(c2, data):\n  divider = ((0xfa - len(c2)) >> 1) - 0x18\n  size = len(data)\n  return (size / divider) + 1\n\n```\nThe data sent to the C2 is crafted as subdomains after it is xor’ed with the key. The key continues to remain 0xb9.\n\nThe example below shows what this data would look like with content sent to c2_command 0 and how many parts\nit gets divided into:\n\n0<GUID>\\x00\\x03/anchor_dns/WINCOMP_W617601.HGDJ3748EURIHDGV192873645672DFGW/0/Windows 7/1001/0.0.0.0/\n0<GUID>\\x01\\x03EAA477CDE0E29EF989E433E633F545A09FD31789937121144906202B0EFD32CB/Tb1i5Xc\n0<GUID>\\x02\\x03Zih0P1wW70rhjGp7G75WsFu69/\n\n**C2 Response**\n\nAfter every part of the query gets sent, the C2 responds with an IP. The bot uses this IP to obtain the identifier\nvalue that will be used in the next query sequence.\n```\ndef get_identifier(IP):\n  return inet_aton(IP) >> 6\n\n### Query 1:\n\n```\n**Bot DNS Query**\n\nBoth platforms have the same query for type 1. And similarly, the data is created as a subdomain after being xor’ed\nwith 0xb9.\n```\n1<UUID><dw_Identifier>\n\n```\ndw_Identifier – The same value that was sent by the C2 to the bot for query type 0\n\n**C2 Response**\n\nThe C2 responds with an IP. This IP is also passed through the same function routine as get_identifier in the\npseudocode above, and the resulting value is the size of the data to be expected from the final query type.\n\n### Query 2:\n\n**Bot DNS Query**\n\nBoth platforms have the same query for type 2.\n```\n2<UUID><dw_Identifier><dw_DataReceivedSize>\n\n```\ndw_Identifier – The same value that was sent by the C2 to the bot for query type 0\ndw_DataReceivedSize – The size of the data that has been received thus far.\n\nThe bot keeps sending a query type 2 request until the total size of the data received from the C2 matches that of\nthe value sent by C2 in response to query type 1.\n\n**C2 Response**\n\n\n-----\n\nWith each type 2 DNS query made by the bot, the C2 responds with a list of IP records. This list of IPs (Figure 3) is\na structure on how the data is constructed and is exactly as that mentioned by NTT.\n\nFigure 3: Records of IPs sent by the\n\nC2\n\nThe first dotted decimal number of the IP gives the order in which the list of IPs is parsed by the bot.\n\nIPs of this form 4.?.?.? show how much data has been sent by the C2, with the last 3 dotted decimal numbers\nof the IP indicating the size.\nIPs of this form 8.?.?.? show the size of data in the current record list, with the last 3 dotted decimal numbers\nof the IP indicating the value.\nThe additional IPs in Figure 3 are all data in which the last 3 dotted decimal numbers of the IP are\nconcatenated together.\n\nIn Figure 4 below, we see an example PE file payload of IP records sent by the C2.\n\nFigure 4: Example PE file payload\n\n## Windows Anchor\n\nThe final data received from the C2 has the following structure:\n```\n/<bot_command>/anchor_dns/<Bot_GUID>/<32_bytes_random_alphanumeric>/<bot_command_ID>/\\r\\n<base64_encoded_d\n\n```\nbase64_encoded_data: Information used by the resulting bot_command subroutine.\n\n## Bot_Command 0\n\n**base64_encoded_data from C2 – decodes to a series of arguments**\n\nExecutes a series of arguments through cmd.exe\n\n## Bot_Command 1 & 2\n\n**base64_encoded_data from C2 – decodes to filename and/or file arguments**\n\n\n-----\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 1 sends c2_command 5\nbot_command 2 sends c2_command <filename>\nThe EXE is created in the %TEMP% directory with a prefix tcp and executed.\n\n## Bot_Command 3 & 4\n\nbase64_encoded_data from C2 – decodes to filename and/or file arguments\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 3 sends c2_command 5\nbot_command 4 sends c2_command <filename>\nThe DLL is created in the %TEMP% directory with a prefix tcp and executed (Figures 5 and 6).\n\nFigure 5: 64bit Anchor PE run being run\n\nFigure 6: 64bit Anchor PE executing a\n\nDLL\n\n## Bot_Command 5 & 6\n\n**base64_encoded_data from C2 – decodes to filename and/or file arguments**\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 5 sends c2_command 5\nbot_command 6 sends c2_command <filename>\n[The PE file is injected into a process via process hollowing.](https://attack.mitre.org/techniques/T1055/012/)\n\n## Bot_Command 7 & 8\n\n**base64_encoded_data from C2 – decodes to filename and/or file arguments**\n\n-  The bot makes DNS queries to C2 for a PE file.\no  bot_command 5 sends c2_command 5\n\no  bot_command 6 sends c2_command <filename>\n\n[•  The PE file is injected into a process via process doppelgänging.](https://attack.mitre.org/techniques/T1055/013/)\n\n## Bot_Command 9\n\n**base64_encoded_data from C2 – decodes to a series of arguments**\n\nExecutes a series of arguments through a pipe object to cmd.exe\n\n## Bot_Command 10\n\n**base64_encoded_data from C2 – decodes to a series of arguments**\n\nExecutes a series of arguments through a pipe object to powershell.exe\n\n## Bot_Command 11 & 12\n\n\n-----\n\n**base64_encoded_data from C2 decodes to filename**\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 11 sends c2_command 5\nbot_command 12 sends c2_command <filename>\nThis PE file is injected into 3 different running processes that get created.\nThese processes are explorer.exe, mstsc.exe, and notepad.exe\n\n## Bot_Command 13\n\n**base64_encoded_data from C2 – decodes to a scheduled task string**\n\nThe bot changes the scheduled task of the bot\n\n## Bot_Command 14\n\nUninstall the Anchor\n\n## Linux Anchor\n\n[The Linux Anchor module was first discovered by Stage 2 Security. The analysis done by Stage 2 Security is](https://medium.com/stage-2-security/anchor-dns-malware-family-goes-cross-platform-d807ba13ca30)\nextensive, but we wanted to take a closer look at the C2 communications in the same way we did with the\nWindows version above.\n\nThe bot_commands from 0-4 contains smb2 information (which includes domain, user, and password) to be used\nby the Linux module when attempting to connect to any Windows shares. The module has an embedded PE file\nthat is used to execute commands or files on the Windows shares.\n\n## Bot_Command 0\n\n**base64_encoded_data from C2 - decodes to a series of arguments**\n\nExecutes a series of arguments through cmd.exe on the Windows shares.\n\n## Bot_Command 1 & 2\n\n**base64_encoded_data from C2 - decodes to filename and/or file arguments**\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 1 sends c2_command 5\nbot_command 2 sends c2_command <filename>\nThe file gets executed.\n\n## Bot_Command 3 & 4\n\n**base64_encoded_data from C2 - decodes to filename and/or file arguments**\n\nThe bot makes DNS queries to C2 for a PE file.\n\nbot_command 3 sends c2_command 5\nbot_command 4 sends c2_command <filename>\nThe DLL files export function Control_RunDLL gets executed.\n\n## Bot_Command 10 & 11 & 12\n\n**base64_encoded_data from C2**\n\n\n-----\n\nFor bot_command 10, the encoded data is a Linux file that is executed by the bot.\nBot_Commands 11 and 12 make DNS queries to C2 for a Linux file.\n\nbot_command 11 sends c2_command 5\nbot_command 12 sends c2_command <filename>\nThe bot sets the file’s permissions to 777 and executes it.\n\n## Bot_Command 100\n\n**base64_encoded_data from C2 - decodes to a GUID**\n\nThe bot checks whether the GUID sent by the C2 matches that of the bot’s GUID.\nIf the GUIDs do not match, the bot terminates C2 communication.\n\n## Conclusion\n\nThe complexity of Anchor’s C2 communication and the payloads that the bot can execute reflect not only a portion\nof the Trickbot actors’ considerable capabilities, but also their ability to constantly innovate, as evidenced by their\nmove to Linux. It is important to note that Trickbot operators aren’t the only adversaries to realize the value of\ntargeting other operation systems. Earlier this year, we analyzed a DDoS bot called Lucifer designed to run on both\nWindows and Linux platforms. As we see more adversaries building cross-compile malware families, it seems clear\nthat security professionals must re-evaluate security practices for Linux systems to ensure they are well-prepared\nto defend against these increasing threats.\n\n## Indicators of Compromise:\n\nAnchor C2s:\n\nwesturn[.]in\nonixcellent[.]com\nwonto[.]pro\nericrause[.]com\n\nAnchor PE 64bit\n\nSHA256 - c427a2ce4158cdf1f320a1033de204097c781475889b284f6815b6d6f4819ff8\nSHA256 - 4e5fa5dcd972170bd06c459f9ee4c3a9683427d0487104a92fc0aaffd64363b2\n\nAnchor ELF 64bit\n\nSHA256 - 4655b4b44f6962e4f9641a52c24373390766c50b62fcc222e40511c0f1ed91d2\n\nAnchor PE 32bit Helper file for Linux\n\nSHA256 - 7686a3c039b04e285ae2e83647890ea5e886e1a6631890bbf60b9e5a6ca43d0a\n\nPosted In\n\nMalware\n\n## Subscribe\n\n_Sign up now to receive the latest notifications and updates from NETSCOUT's ASERT._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-10-26 - Dropping the Anchor.pdf"
    ],
    "report_names": [
        "2020-10-26 - Dropping the Anchor.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535535,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653767279,
    "ts_modification_date": 1653767279,
    "files": {
        "pdf": "https://archive.orkl.eu/dba6f54a7f4e59d750d4dda09e9ebbb06e4460d7.pdf",
        "text": "https://archive.orkl.eu/dba6f54a7f4e59d750d4dda09e9ebbb06e4460d7.txt",
        "img": "https://archive.orkl.eu/dba6f54a7f4e59d750d4dda09e9ebbb06e4460d7.jpg"
    }
}