{
    "id": "a81d2d4b-2a24-4b0e-9015-9878a2aec34f",
    "created_at": "2023-01-12T15:05:50.405736Z",
    "updated_at": "2025-03-27T02:16:34.96803Z",
    "deleted_at": null,
    "sha1_hash": "652e45095f122e9f51f4fc73f72e1b1d08b21051",
    "title": "2022-12-02 - Blowing Cobalt Strike Out of the Water With Memory Analysis",
    "authors": "",
    "file_creation_date": "2022-12-29T00:24:16Z",
    "file_modification_date": "2022-12-29T00:24:16Z",
    "file_size": 1556012,
    "plain_text": "# Blowing Cobalt Strike Out of the Water With Memory Analysis\n\n**[unit42.paloaltonetworks.com/cobalt-strike-memory-analysis/](https://unit42.paloaltonetworks.com/cobalt-strike-memory-analysis/)**\n\nDominik Reichel, Esmid Idrizovic, Bob Jung December 2, 2022\n\nBy [Dominik Reichel,](https://unit42.paloaltonetworks.com/author/dominik-reichel/) [Esmid Idrizovic and](https://unit42.paloaltonetworks.com/author/esmid-idrizovic/) [Bob Jung](https://unit42.paloaltonetworks.com/author/bob-jung/)\n\nDecember 2, 2022 at 6:00 AM\n\n[Category: Malware](https://unit42.paloaltonetworks.com/category/malware-2/)\n\nTags: [Cloud-Delivered Security Services,](https://unit42.paloaltonetworks.com/tag/cloud-delivered-security-services/) [Cobalt Strike,](https://unit42.paloaltonetworks.com/tag/cobalt-strike/) [Cortex XDR,](https://unit42.paloaltonetworks.com/tag/cortex-xdr/) [Evasive Malware,](https://unit42.paloaltonetworks.com/tag/evasive-malware/)\n[KoboldLoader,](https://unit42.paloaltonetworks.com/tag/koboldloader/) [LithiumLoader,](https://unit42.paloaltonetworks.com/tag/lithiumloader/) [MagnetLoader,](https://unit42.paloaltonetworks.com/tag/magnetloader/) [memory detection,](https://unit42.paloaltonetworks.com/tag/memory-detection/) [Sandbox,](https://unit42.paloaltonetworks.com/tag/sandbox/) [WildFire](https://unit42.paloaltonetworks.com/tag/wildfire/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/cobalt-strike-memory-analysis/)\n\n## Executive Summary\n\nUnit 42 researchers examine several malware samples that incorporate Cobalt Strike\ncomponents, and discuss some of the ways that we catch these samples by analyzing\nartifacts from the deltas in process memory at key points of execution. We will also discuss\nthe evasion tactics used by these threats, and other issues that make their analysis\nproblematic.\n\n\n-----\n\n[Cobalt Strike is a clear example of the type of evasive malware that has been a thorn in the](https://www.cobaltstrike.com/)\nside of detection engines for many years. It is one of the most well-known adversary\nsimulation frameworks for red team operations. However, it’s not only popular among red\nteams, but it is also abused by many threat actors for malicious purposes.\n\nAlthough the toolkit is only sold to trusted entities to conduct realistic security tests, due to\nsource code leaks, its various components have inevitably found their way into the arsenal of\nmalicious actors ranging from ransomware groups to state actors. Malware authors abusing\n[Cobalt Strike even played a role in the infamous SolarWinds incident in 2020.](https://unit42.paloaltonetworks.com/solarstorm-supply-chain-attack-timeline/)\n\nRelated Unit 42 Topics [Cobalt Strike,](https://unit42.paloaltonetworks.com/tag/cobalt-strike/) [Sandbox](https://unit42.paloaltonetworks.com/tag/sandbox/)\n\n## Table of Contents\n\nOverview of Cobalt Strike\n\nKoboldLoader SMB Beacon\n\nIn-Memory Evasion\n\nMagnetLoader\n\nLithiumLoader\n\nLithiumLoader Detection Issues\n\nCatching Cobalt Strike Through Analyzing Its Memory\n\nAutomatic Payload Extraction\n\nFunction Pointer Data\n\nOS Structure Modifications\n\nPage Permissions\n\nConclusion\n\nIndicators of Compromise\n\nAppendix\n\n## Overview of Cobalt Strike\n\nThe main driver for the proliferation of Cobalt Strike is that it is very good at what it does. It\nwas designed from the ground up to help red teams armor their payloads to stay ahead of\nsecurity vendors, and it regularly introduces new evasion techniques to try to maintain this\nedge.\n\nOne of the main advantages of Cobalt Strike is that it mainly operates in memory once the\ninitial loader is executed. This situation poses a problem for detection when the payload is\nstatically armored, exists only in memory and refuses to execute. This is a challenge to many\nsecurity software products, as scanning memory is anything but easy.\n\n\n-----\n\nIn many cases, Cobalt Strike is a natural choice for gaining an initial footprint in a targeted\nnetwork. A threat actor can use a builder with numerous deployment and obfuscation options\nto create the final payload based on a customizable template.\n\nThis payload is typically embedded into a file loader in encrypted or encoded form. When the\nfile loader is executed by a victim, it decrypts/decodes the payload into memory and runs it.\nAs the payload is present in memory in its original form, it can be detected easily due to\nsome specific characteristics.\n\nAs malware researchers, we often see potentially interesting malicious samples that turn out\nto just be loaders for Cobalt Strike. It’s also often unclear if a loader was created by a red\nteam or a real malicious actor, thus making attribution even more challenging.\n\nIn the next few sections, we’re going to take a closer look into three different Cobalt Strike\nloaders that were detected out of the box by a new hypervisor based sandbox we designed\nto allow us to analyze artifacts in memory. Each sample loads a different implant type,\nnamely an SMB, HTTPS and stager beacon. We dubbed these Cobalt Strike loaders\nKoboldLoader, MagnetLoader and LithiumLoader. We will also discuss some of the methods\nwe can use to detect these payloads.\n\n## KoboldLoader SMB Beacon\n\nThe sample we’re looking at was detected during a customer incident.\n\nSHA256: 7ccf0bbd0350e7dbe91706279d1a7704fe72dcec74257d4dc35852fcc65ba292\n\nThis 64-bit KoboldLoader executable uses various known tricks to try to bypass sandboxes\nand to make the analysis process more time consuming.\n\nTo bypass sandboxes that hook only high-level user mode functions, it solely calls native API\nfunctions. To make the analyst's life harder, it dynamically resolves the functions by hash\ninstead of using plain text strings. The malware contains code to call the following functions:\n\nNtCreateSection\nNtMapViewOfSection\nNtCreateFile (unused)\nNtAllocateVirtualMemory (unused)\nRtlCreateProcessParameters\nRtlCreateUserProcess\nRtlCreateUserThread\nRtlExitUserProcess\n\nThe malware creates two separate tables of function hash/address pairs. One table contains\none pair for all native functions, while the second table only pairs for Nt* functions.\n\n\n-----\n\nFor the Rtl functions that were used, it loops through the first table and searches for the\nfunction hash to get the function address. For the Nt* functions that were used, it loops\nthrough the second table and simultaneously increases a counter variable.\n\nWhen the hash is found, it takes the counter value that is the system call number of the\ncorresponding native function, and it enters a custom syscall stub. This effectively bypasses\nmany sandboxes, even if the lower level native functions are hooked instead of the high-level\nones.\n\nThe overall loader functionality is relatively simple and uses mapping injection to run the\npayload. It spawns a child process of the Windows tool sethc.exe, creates a new section and\nmaps the decrypted Cobalt Strike beacon loader into it. The final execution of the Cobalt\nStrike loader that in turn loads an SMB beacon happens by calling RtlCreateUserThread.\n\nYou can find the decrypted beacon configuration data in the Appendix section.\n\n### In-Memory Evasion\n\nWith our new hypervisor-based sandbox, we were able to detect the decrypted Cobalt Strike\n[SMB beacon in memory. This beacon loader even uses some in-memory evasion features](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2-extend_pe-memory-indicators.htm#_Toc65482856)\nthat create a strange sort of chimeric file. While it’s actually a DLL, the “MZ'' magic PE bytes\nand subsequent DOS header are overwritten with a small loader shellcode as shown in\nFigure 1.\n\nFigure 1. Disassembled Cobalt Strike beacon loader shellcode.\nThe shellcode loader jumps to the exported function DllCanUnloadNow, which prepares the\nSMB beacon module in memory. To do this, it first loads the Windows pla.dll library and\nzeroes out a chunk of bytes inside its code section (.text). It then writes the beacon file into\nthis blob and fixes the import address table, thus creating an executable memory module.\n\nDuring the analysis of the file, we could figure out some of the in-memory evasion features\nthat were used, as shown in Table 1.\n\n\n-----\n\n**Evasion**\n**feature** **Description**\n\nallocator Set how beacon's ReflectiveLoader allocates memory for the\nagent. Options are: HeapAlloc, MapViewOfFile and\nVirtualAlloc.\n\ncleanup Ask beacon to attempt to free memory associated with the\nreflective DLL package that initialized it.\n\nmagic_mz_x64 Override the first bytes (MZ header included) of beacon's\nreflective DLL. Valid x86 instructions are required. Follow\ninstructions that change CPU state with instructions that undo\nthe change.\n\nmagic_pe Override the PE character marker used by beacon's\nReflectiveLoader with another value.\n\nmodule_x64 Ask the x86 reflective loader to load the specified library and\noverwrite its space instead of allocating memory with\nVirtualAlloc.\n\nobfuscate Obfuscate the reflective DLL’s import table, overwrite unused\nheader content, and ask ReflectiveLoader to copy beacon to\nnew memory without its DLL headers.\n\n\n**Used**\n**in our**\n**sample**\n\nNo\n\nYes\n\nYes\n\nNo\n\nYes\n\nYes\n\n\nsleep_mask Obfuscate beacon and its heap, in-memory, prior to sleeping. No\n\n\nsmartinject Use embedded function pointer hints to bootstrap beacon\nagent without walking kernel32 Export Address Table (EAT).\n\nstomppe Ask ReflectiveLoader to stomp MZ, PE and e_lfanew values\nafter it loads beacon payload.\n\nuserwx Ask ReflectiveLoader to use or avoid read, write or execute\n(RWX) permissions for Beacon DLL in memory.\n\n_Table 1. Cobalt Strike evasion techniques that were used._\n\n\nNo\n\nNo\n\nNo\n\n\nTo sum up, the beacon loader and the beacon itself are the same file. Parts of the PE header\nare used for a shellcode that jumps to an exported function, which in turn creates a module\nof itself inside a Windows DLL. Finally, the shellcode jumps to the entry point of the beacon\nmodule to execute it in memory.\n\nAs discussed, there is no way for us to detect this beacon of our KoboldLoader sample\nsuccessfully unless we can peer inside memory during execution.\n\n## MagnetLoader\n\n\n-----\n\nThe second loader we will look into is a 64-bit DLL that imitates a legitimate library.\n\nSHA256: 6c328aa7e0903702358de31a388026652e82920109e7d34bb25acdc88f07a5e0\n\nThis MagnetLoader sample tries to look like the Windows file mscms.dll in a few ways, by\nusing the following similar features:\n\nThe same file description\nAn export table with many of the same function names\nAlmost identical resources\nA very similar mutex\n\nThese features are also shown in Figure 2, where the malware file is contrasted with the\nvalid mscml.dll.\n\nFigure 2. Comparison of file description, export table and resources of MagnetLoader (left)\nand mscml.dll (right) as seen with EXE Explorer.\nMagnetLoader not only tries to mimic the legitimate Windows library statically, but also at\nruntime.\n\nAll of the exported functions of MagnetLoader internally call the same main malware routine.\nWhen one of them is called, the DLL entry point is run first. In the entry point, the malware\nloads the original mscms.dll and it resolves all the functions it fakes.\n\nThe addresses of these original functions are stored and called after a fake method is\nexecuted. Thus, whenever an exported function of MagnetLoader is called, it runs the main\nmalware routine and afterward calls the original function in mscms.dll.\n\n\n-----\n\nThe main malware routine is relatively simple. It first creates a mutex named\nSM0:220:304:WilStaging_02_p1h that looks very similar to the original one created by\nmscms.dll.\n\nThe Cobalt Strike beacon loader gets decrypted into a memory buffer and executed with the\nhelp of a known trick. Instead of calling the beacon loader directly, the loader uses the\nWindows API function EnumChildWindows to run it.\n\nThis function contains three parameters, one of which is a callback function. This parameter\ncan be abused by malware to indirectly call an address via the callback function and thus\nconceal the execution flow.\n\nYou can also find the decrypted beacon configuration data in the Appendix section.\n\n## LithiumLoader\n\nThis last Cobalt Strike sample is part of a DLL side-loading chain where a custom installer for\na type of security software was used. DLL side-loading is a technique that hijacks a\nlegitimate application to run a separate, malicious DLL.\n\nSHA256: 8129bd45466c2676b248c08bb0efcd9ccc8b684abf3435e290fcf4739c0a439f\n\nThis 32-bit LithiumLoader DLL is part of a custom attacker-created Fortinet VPN installation\npackage submitted to VirusTotal as FortiClientVPN_windows.exe (SHA256:\na1239c93d43d657056e60f6694a73d9ae0fb304cb6c1b47ee2b38376ec21c786).\n\nThe FortiVPN.exe file is not malicious or compromised. Because the file is signed, attackers\nused it to evade antivirus detection.\n\nThe installer is a self-extracting RAR archive that contains the following files:\n\n**File name** **Description**\n\nFortiVPN.exe Legit signed FortiClient VPN Online installer v7.0.1.83\n\nGUP.exe [Legit signed WinGup for Notepad++ tool v5.2.1.0](https://wingup.org/)\n\ngup.xml WinGup config file\n\nlibcurl.dll LithiumLoader\n\n_Table 2a. FortiClientVPN_windows.exe file contents._\n\nThe self-extracting script commands are as follows:\n\n\n-----\n\nTable 2b. List of self-extracting script commands.\nWhen the installer is run, all files get silently dropped to the local %AppData% folder and\nboth executable files get started. While the FortiClient VPN installer executes, the WinGup\ntool side-loads the libcurl.dll LithiumLoader malware. The malware does so because it\n[imports the following functions from a legit copy of the libcurl library as shown in Figure 3.:](https://curl.se/libcurl/)\n\nFigure 3. Import address table of WinGup.exe.\nThis threat also tries to add the %AppData% folder path to the exclusion list in Windows\nDefender via PowerShell.\n\nOn the startup of GUP.exe, the malicious libcurl.dll file is loaded into the process space as it\nstatically imports the functions shown in Figure 3, above. While all four libcurl functions are\nrun, only curl_easy_cleanup contains a malicious routine that was injected while compiling a\nnew version of the library. Thus, we’re not dealing with a patched version of the legitimate\nDLL. This is a cleaner solution that doesn’t break the code after the inserted malicious\nroutine, as is often seen in other malware.\n\nThis [curl_easy_cleanup function usually contains only one subroutine (Curl_close) and has](https://curl.se/libcurl/c/curl_easy_cleanup.html)\n[no return value (as shown in its source code on GitHub). The altered function is as shown in](https://github.com/curl/curl/blob/2610142139d14265ed9acf9ed83cdf73d6bb4d05/lib/easy.c#L727)\nFigure 4.\n\n\n-----\n\nFigure 4. Modified curl_easy_cleanup export function of libcurl.dll.\nThe load_shellcode function decrypts the shellcode via XOR and key 0xA as shown in Figure\n5.\n\nFigure 5. Shellcode loader function load_shellcode().\nThis function runs the Cobalt Strike stager shellcode indirectly via EnumSystemGeoID\ninstead of directly jumping to it. This Windows API function has three parameters, the last\none of which is a callback function abused by LithiumLoader.\n\nThe Cobalt Strike stager shellcode is borrowed from Metasploit and is the reverse HTTP\nshell payload, which uses the following API functions:\n\nLoadLibrary\nInternetOpenA\nInternetConnectA\nHttpOpenRequestA\n\n\n-----\n\nInternetSetOptionA\nHttpSendRequestA\nGetDesktopWindow\nInternetErrorDlg\nVirtualAllocStub\nInternetReadFile\n\nThe shellcode connects to the IP address of a university in Thailand.\n\n### LithiumLoader Detection Issues\n\nAt the time of writing this analysis, the Cobalt Strike beacon payload was no longer available.\nWithout a payload or any actionable information in the execution report of API calls, it’s often\nchallenging for a sandbox to determine whether the sample is malicious. This sample doesn’t\nhave any functionality that can be classified as malicious per se.\n\n## Catching Cobalt Strike Through Analyzing Its Memory\n\nIn all three of these examples there are some common detection challenges. These samples\ndo not execute in normal sandbox environments. But as we discussed, there is a wealth of\ninformation that we can use for detection if we look inside memory during execution, like\nfunction pointers, decoded stages of the loader, and other artifacts.\n\nFor many years now, it has been standard practice for sandbox systems to instrument and\nobserve the activity of executing programs. If our team has learned anything over the years,\nit’s that this alone is not enough for highly evasive malware. This is why we’ve been working\nhard the past few years on figuring out how we can add more thorough processing for this\ntype of highly evasive malware.\n\nFor accurate detection, one of the key features we’ve found to address highly evasive\nmalware is that we need to look at memory as samples execute in addition to using the\nsystem API to get a better understanding of what’s happening.\n\n\n-----\n\nFigure\n\n6. High level Advanced WildFire detection strategy.\nWe’ve found that, in malware detection, it’s useful to look at the deltas in memory at key\npoints of execution to extract meaningful information and artifacts. As our system processes\na vast number of samples, there have been a lot of challenges to make this work at scale.\nHowever, a lot of clever engineering built on top of our flagship custom hypervisor tailored for\nmalware analysis has helped make this idea a reality.\n\nIn these next few sections, we will detail some of the main types of data that we are currently\ncollecting from memory to aid detection. This data can be utilized by both our analysts for\nmanual signatures as well as machine learning pipelines, which we’ll be discussing in a\nfuture post.\n\nAlthough we are focusing on memory here, we are by no means suggesting that\ninstrumenting and logging API calls are not useful for detection. Our belief is that bringing\nexecution logs and memory analysis data together creates a sum greater than its parts.\n\n\n-----\n\n### Automatic Payload Extraction\n\nAs previously discussed, it is increasingly common for malware authors to obfuscate their\ninitial payloads. While using executable packers that can compress and obfuscate files to\naccomplish this is nothing new, it becomes problematic when it’s used in combination with\nevasion strategies, because there is no static or dynamic data that’s useful for an accurate\ndetection.\n\nThere are infinite combinations of strategies for encoding, compressing, encrypting or\ndownloading additional stages for execution. The ability to craft signatures for these\npayloads is obviously an important way that our analysts can catch lots of different malware\ncomponents from frameworks like Cobalt Strike. If we can catch them in memory, it ultimately\ndoesn’t matter if the malware decides not to execute.\n\nThe following simplified diagram in Figure 7 shows an example of what we might see in a\ncouple of stages that were never present in the initial executable file.\n\nFigure 7. Typical stages we might see in a packed malware executable.\nOn the left side of the diagram, we see an example of a shellcode stage. Although the term\n“shellcode” was originally coined for hand crafted assembly utilized in exploits to pop a shell\non a target system, the word has evolved to encompass any blobs of custom assembly\nwritten for nefarious purposes. Some malware stages are blobs of custom assembly with no\ndiscernable executable structure. A common pattern for malware authors taking this\napproach is to dynamically resolve all of the function pointers into a table for ease of access.\n\nOn the right side of the diagram, we see that the later stage is an example of a well-formed\nexecutable. Some malware stages or payloads are well-formed executables. These can be\nloaded by the OS via the system API, or the malware author might use their own PE loader if\nthey’re trying to be stealthy in avoiding calling any APIs to do this for them.\n\n### Function Pointer Data\n\n\n-----\n\nAnother rich set of data we can pull from memory that we ve begun to use for detection is\ndynamically resolved function pointers, as shown in Figure 8. Malware authors learned long\nago that if they explicitly call out all of the WINAPI functions they plan to use in the import\ntable, it can be used against them. It is now standard practice to hide the functions that will\nbe used by the malware or any of its stages.\n\nShellcode hashing is another common stealthy strategy used to resolve pointers for functions\nwithout needing their string.\n\nFigure 8. Examples of dynamically resolved WINAPI pointers we might see in a memory\nsegment.\nIn Advanced WildFire we have begun to selectively search for and use this information about\nwhich WINAPI function pointers were resolved in our detection logic.\n\n### OS Structure Modifications\n\nAnother useful source of detection data we’ve found from analyzing memory is to look for\nany changes to Windows bookkeeping structures (Malware authors love to mess with\nthese!). These structures are important for the OS to maintain state about the process, such\nas what libraries have been loaded, where the executable image was loaded, and various\nother characteristics about the process that the OS might need to know later. Given that\nmany of these fields should never be modified, it’s often useful to keep track of when and\nhow malware samples are manipulating them.\n\n\n-----\n\nThe diagram in Figure 9 shows how a sample might unhook a module it loaded from the LDR\nModule list. Unhooking a module would mean that there is no longer a record that the\nmodule exists. So, for example, after doing this the Task Manager in Windows would no\nlonger list it.\n\nThis diagram represents only one of many different OS Structure modifications we’ve seen,\nbut it shows that there are many different types of OS structure modifications that are useful\nfor the malware detection problem.\n\nFigure 9. An example of how a module might be unhooked from the LDR Modules List.\n\n### Page Permissions\n\nFinally, another useful source of detection data is a full log of all changes made to page\npermissions. Authors of packed malware often need to change memory permissions in order\nto properly load and execute further stages. Understanding which pages of memory had their\npermissions changed often provides important insights into where code was loaded and\nexecuted, which can be useful for detection.\n\n## Conclusion\n\nAlthough Cobalt Strike has been around for some years, detecting it is still a challenge to\nmany security software providers. That is because this tool works mostly in memory and\ndoesn’t touch the disk much, other than with the initial loader.\n\n\n-----\n\nWe ve looked into three new loaders and showed how they can be detected using a variety\nof techniques. These detection techniques are available within our new hypervisor based\nsandbox.\n\nFigure 10 illustrates our detection reasons for KoboldLoader.\n\nFigure 10. Internal KoboldLoader sample analysis report.\nPalo Alto Networks customers receive protections from these threats:\n\n## Indicators of Compromise\n\n**KoboldLoader**\n\n7ccf0bbd0350e7dbe91706279d1a7704fe72dcec74257d4dc35852fcc65ba292\n\n6ffedd98d36f7c16cdab51866093960fe387fe6fd47e4e3848e721fd42e11221\n\nfc4b842b4f6a87df3292e8634eefc935657edf78021b79f9763548c74a4d62b8\n\n062aad51906b7b9f6e8f38feea00ee319de0a542a3902840a7d1ded459b28b8d\n\na221c7f70652f4cc2c76c2f475f40e9384a749acd1f0dbaefd1a0c5eb95598d2\n\n**MagnetLoader**\n\n\n-----\n\n6c328aa7e0903702358de31a388026652e82920109e7d34bb25acdc88f07a5e0\n\n**LithiumLoader**\n\n8129bd45466c2676b248c08bb0efcd9ccc8b684abf3435e290fcf4739c0a439f\n\n82dcf67dc5d3960f94c203d4f62a37af7066be6a4851ec2b07528d5f0230a355\n\n**LithiumLoader Installer**\n\na1239c93d43d657056e60f6694a73d9ae0fb304cb6c1b47ee2b38376ec21c786\n\ncbaf79fb116bf2e529dd35cf1d396aa44cb6fcfa6d8082356f7d384594155596\n\n## Appendix\n\n**KoboldLoader beacon configuration data:**\n\nBeaconType - SMB\n\nPort - 4444\n\nSleepTime - 10000\n\nMaxGetSize - 1048576\n\nJitter - 0\n\nMaxDNS - 0\n\nPublicKey_MD5 - 633dc5c9b3e859b56af5edf71a178590\n\nC2Server UserAgent \nHttpPostUri \nMalleable_C2_Instructions - Empty\n\nPipeName - \\\\.\\pipe\\servicepipe.zo9keez4weechei8johR.0521cc13\n\nDNS_Idle - Not Found\n\nDNS_Sleep - Not Found\n\nSSH_Host - Not Found\n\nSSH_Port - Not Found\n\nSSH_Username - Not Found\n\nSSH_Password_Plaintext - Not Found\n\nSSH_Password_Pubkey - Not Found\n\nSSH_Banner - Not Found\n\nHttpGet_Verb - Not Found\n\nHttpPost_Verb - Not Found\n\nHttpPostChunk - Not Found\n\nSpawnto_x86 - %windir%\\syswow64\\dfrgui.exe\n\nSpawnto_x64 - %windir%\\sysnative\\dfrgui.exe\nCryptoScheme - 0\n\nProxy_Config - Not Found\n\n\n-----\n\nProxy_User - Not Found\nProxy_Password - Not Found\n\nProxy_Behavior - Not Found\n\nWatermark_Hash - Not Found\n\nWatermark - 666\n\nbStageCleanup - True\n\nbCFGCaution - True\nKillDate - 0\n\nbProcInject_StartRWX - True\n\nbProcInject_UseRWX - False\n\nbProcInject_MinAllocSize - 35485\n\nProcInject_PrependAppend_x86 - b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\n\nb'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\n\nProcInject_PrependAppend_x64 - b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\n\nb'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\n\nProcInject_Execute - ntdll.dll:RtlUserThreadStart\n\nNtQueueApcThread\n\nNtQueueApcThread-s\n\nSetThreadContext\n\nRtlCreateUserThread\n\nkernel32.dll:LoadLibraryA\n\nProcInject_AllocationMethod - NtMapViewOfSection\n\nbUsesCookies - Not Found\n\nHostHeader - Not Found\n\nheadersToRemove - Not Found\n\nDNS_Beaconing - Not Found\n\nDNS_get_TypeA - Not Found\n\nDNS_get_TypeAAAA - Not Found\n\nDNS_get_TypeTXT - Not Found\n\nDNS_put_metadata - Not Found\n\nDNS_put_output - Not Found\n\nDNS_resolver - Not Found\n\nDNS_strategy - Not Found\n\nDNS_strategy_rotate_seconds - Not Found\n\nDNS_strategy_fail_x - Not Found\n\nDNS_strategy_fail_seconds - Not Found\n\nRetry_Max_Attempts - Not Found\n\nRetry_Increase_Attempts - Not Found\n\nRetry_Duration - Not Found\n\n**MagnetLoader beacon configuration data:**\n\n\n-----\n\nBeaconType - HTTPS\nPort - 443\n\nSleepTime - 3600000\n\nMaxGetSize - 1402498\n\nJitter - 70\n\nMaxDNS - Not Found\n\nPublicKey_MD5 - 965fe5c869f3eea5e211fa7ee12130d3\nC2Server - tileservice-weather.azureedge[.]net,/en-au/livetile/front/\n\nUserAgent - Microsoft-WebDAV-MiniRedir/10.0.19042\n\nHttpPostUri - /en-CA/livetile/preinstall\n\nMalleable_C2_Instructions - Remove 1380 bytes from the end\nRemove 3016 bytes from the beginning\n\nBase64 URL-safe decode\n\nHttpGet_Metadata - ConstHeaders\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n\nCache-Control: max-age=0\n\nConnection: keep-alive\n\nHost: tileservice-weather.azureedge[.]net\n\nOrigin: https://tile-service-weather.azureedge[.]net\n\nReferer: https://tile-service.weather.microsoft[.]com/\n\nMetadata\n\nbase64url\n\nappend \"/45.40,72.73\"\n\nuri_append\n\nHttpPost_Metadata - ConstHeaders\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n\nCache-Control: max-age=0\n\nConnection: keep-alive\n\nHost: tileservice-weather.azureedge[.]net\n\nOrigin: https://tile-service-weather.azureedge[.]net\n\nReferer: https://tile-service.weather.microsoft[.]com/\n\nConstParams\n\nregion=CA\n\nSessionId\n\nbase64url\n\nparameter \"appid\"\n\nOutput\n\nbase64\n\nprint\n\nPipeName - Not Found\n\nDNS_Idle - Not Found\n\nDNS Sleep - Not Found\n\n\n-----\n\nSSH_Host - Not Found\nSSH_Port - Not Found\n\nSSH_Username - Not Found\n\nSSH_Password_Plaintext - Not Found\n\nSSH_Password_Pubkey - Not Found\n\nSSH_Banner \nHttpGet_Verb - GET\n\nHttpPost_Verb - POST\n\nHttpPostChunk - 0\n\nSpawnto_x86 - %windir%\\syswow64\\conhost.exe\n\nSpawnto_x64 - %windir%\\sysnative\\conhost.exe\n\nCryptoScheme - 0\n\nProxy_Config - Not Found\n\nProxy_User - Not Found\n\nProxy_Password - Not Found\n\nProxy_Behavior - Use IE settings\n\nWatermark_Hash - Not Found\n\nWatermark - 1700806454\n\nbStageCleanup - True\n\nbCFGCaution - False\n\nKillDate - 0\n\nbProcInject_StartRWX - False\n\nbProcInject_UseRWX - False\n\nbProcInject_MinAllocSize - 17500\n\nProcInject_PrependAppend_x86 - b'\\x90\\x90'\n\nEmpty\nProcInject_PrependAppend_x64 - b'\\x90\\x90'\n\nEmpty\nProcInject_Execute - CreateThread\n\nSetThreadContext\n\nProcInject_AllocationMethod - NtMapViewOfSection\n\nbUsesCookies - False\n\nHostHeader \nheadersToRemove - Not Found\n\nDNS_Beaconing - Not Found\n\nDNS_get_TypeA - Not Found\n\nDNS_get_TypeAAAA - Not Found\n\nDNS_get_TypeTXT - Not Found\n\nDNS_put_metadata - Not Found\n\nDNS_put_output - Not Found\n\nDNS_resolver - Not Found\n\nDNS strategy - round-robin\n\n\n-----\n\nDNS_strategy_rotate_seconds - -1\nDNS_strategy_fail_x - -1\n\nDNS_strategy_fail_seconds - -1\n\nRetry_Max_Attempts - Not Found\n\nRetry_Increase_Attempts - Not Found\n\nRetry_Duration - Not Found\n\nTo decrypt the configuration data we used SentinelOne’s [Cobalt Strike Parser.](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n## Additional Resources\n\n[EXE Explorer](https://www.mitec.cz/exe.html)\n\n[Cobalt Strike Parser](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n_Updated December 6, 2022, at 9:05 a.m. PT._\n\n**Get updates from**\n\n**Palo Alto**\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-02 - Blowing Cobalt Strike Out of the Water With Memory Analysis.pdf"
    ],
    "report_names": [
        "2022-12-02 - Blowing Cobalt Strike Out of the Water With Memory Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535950,
    "ts_updated_at": 1743041794,
    "ts_creation_date": 1672273456,
    "ts_modification_date": 1672273456,
    "files": {
        "pdf": "https://archive.orkl.eu/652e45095f122e9f51f4fc73f72e1b1d08b21051.pdf",
        "text": "https://archive.orkl.eu/652e45095f122e9f51f4fc73f72e1b1d08b21051.txt",
        "img": "https://archive.orkl.eu/652e45095f122e9f51f4fc73f72e1b1d08b21051.jpg"
    }
}