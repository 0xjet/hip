{
    "id": "37df24ce-ed0e-4589-b280-a83b92c26dc5",
    "created_at": "2023-02-21T02:07:51.718831Z",
    "updated_at": "2025-03-27T02:08:40.805064Z",
    "deleted_at": null,
    "sha1_hash": "95123547ae9e9779608209f482e3cf36450af295",
    "title": "2018-04-17 - Beyond Automated Tools and Frameworks - The Shellcode Injection Process",
    "authors": "",
    "file_creation_date": "2018-03-31T15:00:50Z",
    "file_modification_date": "2018-03-31T15:00:50Z",
    "file_size": 422887,
    "plain_text": "# Beyond automated tools and Frameworks: the shellcode injection process\n\nAuthor: Dr Craig S Wright GSE GSM LLM MStat\n\n## Abstract / Lead\n\nThis article is going to follow from previous articles as well as going into some of the fundamentals\nthat you will need in order to understand the shellcode creation process, how to use Python as a\nlaunch platform for your shellcode and that the various system components are. This is designed as a\nprecursor to the actual injection process where we will in a later article next month introduce the\nactual injection process and start to move from automatic exploit frameworks (such as Metasploit)\ninto being able to create and execute one’s own exploit successfully. In order to do this, we need to\nstart understanding just how code works and to know where to find the fundamentals of the Python\nprogramming language. This article will start a monthly series designed to take the reader from a\nnovice to being able to create and deploy their own shellcode and exploits.\n\n\n-----\n\n# Introduction \n\nAutomated frameworks (including Metasploit) have simplified the testing and exploitation process.\nThis of course comes with a price. Many penetration testers have become tool jockeys with little\nunderstanding of just how software functions. This script kiddie approach to code testing does have its\nplace. It has allowed us to drastically increase the number of people working on testing systems for\nvulnerabilities and in assessing the risks these pose. At the same time, if these individuals do not\nprogress further, simply relying on the ability to leverage the efforts of others, we will hit bottlenecks\nin the creation of new tests and processes.\n\nIn previous articles, we have covered a number of topics to do with the creation of shellcode. In this\none we shall start to introduce the means that will allow the tester to use that code without having to\nrely on an external framework. In subsequent articles this will be expanded into the creation of\nstandalone exploit kits.\n\nIn order to do this, we also need to take a step back and explain the system and the tools we will use\nin more detail. To achieve this, we will start with describing the various components that are used and\nto providing an introduction to the Python programming language. This will also extend into a simple\nmethod to analyse shellcode using GCC such that we can come to understand what the shellcode\nothers have created is designed to do. This is a useful skill when reversing malware as well as a good\nway to learn from the existing code base and even to leverage some of the various tools that are freely\navailable already.\n\n## What is shellcode again?\n\nFirst and foremost, shellcode is an essential part of any exploit. This does not really inform us as to\nwhat it is or how it functions. Simply put, shellcode is an array of hex values that are arranged in such\na way as to act as a set of assembly language instructions in order to make the machine it is run on do\nsome function. This function can be to spawn a shell or to execute arbitrary code of the testers design.\nIt is a fundamental part of any buffer overflow attack, but that is not all it is used for.\n\nJust about any exploit that you may discover in the wild or as a part of a framework will target\nvulnerabilities using shellcode. This can be as the payload of a buffer overflow attack, a heap spray or\nother form of injection.\n```\n    \"\\xeb\\x1a\\x5e\\x31\\xc0\\x88\\x46\\x07\\x8d\\x1e\\x89\\x5e\\x08\\x89\\x46\"\n    \"\\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\xe8\\xe1\"\n    \"\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x23\\x41\\x41\\x41\\x41\"\n    \"\\x42\\x42\\x42\\x42\";\n\n```\n_Code 1: Shellcode sample[1]_\n\nWe will start by analysing this small segment of shellcode (Code 1). To do this, we will start by\ncompiling this shellcode source into an executable file.\n\n1 This sample of shellcode has been taken from Zillion (2002). This page goes into detail as to the operation of\nthe shellcode and the reader is encouraged to step through this. The reader will find countless many examples\nonline with a simple Google search and many good examples are also included within the Metasploit\nframework.\n\n\n-----\n\n# Disassembling Shellcode\n\nWe will start by first compiling and then disassembling the shellcode sample we have introduced\nabove (Code 1). The debugger gdb, objdump or nasm[2] work well for this task. To do this, we take the\nshellcode from above and paste it into a file using vi. That is, “vi shellcode.c” as can be seen in figure\n1.\n\n_Figure 1:_ _Making our shellcode executable, “vi shellcode.c”._\n\nWe have added a main() statement and placed our shellcode sample into a character array to aid in\ncompiling it. We need to compile the sample so that we can load it into a disassembler or debugger.\nThese tools will interpret the hex instructions for us and return a series of assembly instructions for us\nto analyse. This C “skeleton program” can be compiled into a binary executable using gcc (see Code\n2).\n```\n    sudo gcc -g -o shellcode shellcode.c\n\n```\n_Code 2: Using GCC to compile the shellcode sample_\n\nWe can see in figure 2 that we have created an executable file called “shellcode”. I have used the\nSIFT binary image for this analysis, but there are many good pre-configured analysis images based on\nLinux that are freely available. In addition, using one of the standard Linux distributions and installing\ntools such as NASM will enable you to create a shellcode analysis system very easily.\n\nThe sample of shellcode used in this article is by no means the simplest, but it is well known. Many\nexamples of shellcode will actually be far smaller than this, but some can also be quite complex at the\nsame time.\n\n2 OllyDby, Immunity and IDA Pro all work well when analysing shellcode on a Windows host.\n\n\n-----\n\n_Figure 2:_ _Our compiled executable, “shellcode”._\n\nLoading the compiled code into GDB is simple. Just execute the command, “gdb shellcode”. Once it\nis loaded into GDB, we just have to use the gdb disassemble command with the “shellcode[]” array\nwe created as the object it will analyse as gdb will interpret the contents of the shellcode array as if it\nwas assembly code. This is displayed in figure 3.\n\n_Figure 3:_ _Our disassembled “shellcode”._\n\nAltering this shellcode sample can be as simple as changing the shell being called. In “Code 1”, we\ncan change the call to spawn “/bin/sh” to something such as a call to “/bin/ksh” by changing the hex\nentry, “\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68” to “x2f\\x62\\x69\\x6b\\x6e\\x2f\\x73\\x68”.\n\n\n-----\n\n_Figure 4:_ _Altering the “shellcode”._\n\nWith this simple change, we have altered the shellcode in a manner that allows us to control its\nobjective.\n\n## What if I use Windows?\n\nFor those of us who are more aligned to using Windows, we can load and disassemble our shellcode\nin the same way using IDA Pro or OllyDbg. Starting with a tool such as “Shellcode2Exe.py” (Zeltser,\n2011) or “ConvertShellcode” we can convert our shellcode sample into an executable in Windows\nand load it into IDA Pro.\n\nLoading the shellcode into IDA Pro (Fig 4) we see a visually simplified view of the same disassembly\nwe completed in GDB (Fig 3). This display can be of use to people who are less familiar with coding\nas it displays the jumps (and conditional jumps) in a more structured manner.\n\n\n-----\n\n_Figure 5:_ _IDA disassembled “shellcode”._\n\nNow we have to start learning to interpret what these assembly instructions actually mean.\n\n# Assembly Instructions\n\nIn the last article[3] we started to detail what a system register is. We need to extend this and to start to\nlook at other parts of the system. To understand assembly processing, we need to understand the\nconcept of LIFO or Last in First out. Think a stack of dishes when you think of the stack in memory.\nJust as you do not try to take a disk from the base of a large stack (well not without consequences),\nstack calls pull the last item entered and return that moving one by one to the previously added entries\nuntil the first to have been added to the stack is removed as the last item.\n\n3 “Starting to write your own shellcode” in Hakin9, Jan 23 2012.\n\n\n-----\n\nIn particular, when working with the stack, the two assembly commands that you need to have a\nstrong understanding of are push and pop.\n\n  - “PUSH” saves the contents of a register onto the stack.\n\n  - “POP” grabs the saved contents from the stack and puts it into a specific register.\n\nIn this, we can think of the stack as the endless tape in a turning machine[4]. As we move along the\nstack we are adding and removing values we have saved previously.\n\nA good and quick introduction to assembly coding is available in “Assembler: The Basics In\n_Reversing”[5]. In this you will find a small but critical list of instructions that you will need to know_\nwhen you start to create shellcode. It includes:\n\n  - ADD (addition)\n\n  - AND (logical AND)\n\n  - CMP (compare)\n\n  - TEST (test two values)\n\n  - DEC (decrement)\n\n  - DIV (division)\n\n  - INC (increment)\n\n  - INT (interrupt handler)\n\n  - LEA (load effective address)\n\n  - MOV (move)\n\n  - MUL (multiplication)\n\n  - NOP (no operation)\n\n  - OR logical OR)\n\n  - POP (See above in the stack section)\n\n  - PUSH (See above in the stack section)\n\n  - XOR (exclusive OR)\n\nFrom here we start to move to conditional statements and jumps. That is, we can branch to different\nfunctions based on the input or other values we have in the registers and flags. Changing the\nexecution path updates the value held in the EIP register. This is used to add jumps, calls and loops to\nyour code. The main jump statements and their uses are displayed in Table 1.\n\nJumps are enacted unconditionally (JMP, CALL, RET) when the code always branches to another\nlocation in memory. These are fixed controls that always behave in a set manner if the code reaches a\npoint where it will execute them.\n\nA conditional jump (JCC, JE, JZ etc.) are used to control execution branches (See Table 1). These\nforms of jumps are used to branch into different execution paths based on the values retuned to the\njump statement. That is, these control the branching of a code segment based on whether certain\nconditions have been fulfilled. Often, these conditionals are based on the returned value in a Boolean\nstatement (see Table 2).\n\nMost conditionals actually change the values held in a destination operand or register. There are some\nthat do not (CMP, TEST). CMP is an implied SUB and TEST an implied ADD function.\n\n4 Here we are of course ignoring the necessary memory and processor constraints.\n5 This paper is currently available online at http://flip-edesign.com/basics_of_assembler.pdf\n\n\n-----\n\n**Jump** **Action** **Flags**\n\nJA Jump if (unsigned) above CF = 0 and ZF = 0\n\nJB Jump if (unsigned) below CF = 1\n\nJC Jump if carry flag set CF = 1\n\nJE Jump if equal ZF = 1\n\nJG Jump if (signed) greater than ZF = 0 and SF=OF\n\nJGE Jump if (signed) greater than or equal to SF = OF\n\nJL Jump if (signed) less than SF != OF\n\nJLE Jump if (signed) less than or equal to ZF = 1 and SF != OF\n\nJMP Jump Always jumps\n\nJNE Jump if not equal ZF = 0\n\nJNZ Jump if not zero ZF = 0\n\nJZ Jump if zero ZF = 1\n\n_Table 1:_ _Jcc Assembly Jumps_\n\nThe effects of a conditional instruction are stored in the flags register. For instance, in “Code 3”, the\nstatement “Cmp EBX EAX” will not result in the ZF bit (zero flag in the flags register) being set as\nEBX and EAX are not equal. In this operation, the values stored in both EAX and EBX will not\nchange and will remain the same after the operation as before.\n\n…\n1 Mov EAX 04\n2 Mov EBX 10\n3 Mov ECX 04\n4 Cmp EBX EAX\n5 JZ EDX\n6 Cmp EBX EBX\n7 JZ EDX\n8 Sub EAX ECX\n9 JZ EDX\n…\n\n_Code 3: Testing conditionals_\n\nThe statement “Cmp EBX EBX” will result in the ZF bit (zero flag in the flags register) being set as\nEBX – EBX would equal zero (that is they are the same value). Conversely, statement “Cmp EAX\n_ECX” will result in ZF being set, but it will also result in the EAX register being modified._\n\nIn this example (Code 3), with the values set in lines 1 to 3, the statement at line 4 will not set ZF and\nas such the conditional at line 5 will not execute. The statement at line 6 will set the ZF flag and the\njump at line 7 would take the execution to the value held in the EDX register. Hence, the test at line 8\n\n\n-----\n\nand the conditional statement at line 9 will only execute if EDX contained the value referencing the\nmemory location for line 8[6].\n```\n    Logical Operation  Source  Destination  Result\n        AND      1    1     1\n               1    0     0\n               0    1     0\n               0    0     0\n        OR       1    1     1\n               1    0     1\n               0    1     1\n               0    0     0\n        XOR      1    1     0\n               1    0     1\n               0    1     1\n               0    0     0\n        NOT      0    N/A     1\n               1    N/A     0\n\n```\n_Table 2:_ _Logical Operations_\n\nThe TEST instruction is similar to the CMP instruction in that it does not change the values stored in\nthe registers but acts as an AND instruction (Table 2).\n\nIn the next article we will continue this process by converting “If-Else” and “If-Else-If-Else” loops to\nand from assembly code. In this, we will take C/C++ statements and write them as assembly code and\nvice versa. This will continue into examining loops and stack functions.\n\nLoops are important parts of any program code and in injected code are regularly deployed by\nattackers in order to:\n\n  - Encrypt and decrypt data and network traffic,\n\n  - Log keystrokes while checking for selected key codes,\n\n  - Port scan or ping sweep systems incrementally, and\n\n  - Connect to a C&C server by scrolling through a list of available systems.\n\n# Using Python to deliver shellcode\n\nIn next article we will start to use python to deliver your shellcode. Before you do this, you will need\nto have some experience with this scripting language. To do this, you need to start with a quick\nintroduction to learning more about Python if you do not already have this skill.\n```\n       python.exe <script_name.py> 127.0.0.1 80\n\n```\n_Code 4: Shellcode sample[7]_\n\n6 Interestingly, if the register EDX was to contain the memory location for statements 5, 7 or 9 this would result\nin an endless execution loop and a possible DoS against the system as the program looped endlessly to the same\ncall.\n7 This sample of shellcode has been taken from Zillion (2002). This page goes into detail as to the operation of\nthe shellcode and the reader is encouraged to step through this. The reader will find countless many examples\nonline with a simple Google search and many good examples are also included within the Metasploit\nframework.\n\n\n-----\n\nPython is a script interpreter and interactive interpreter at the same time allowing developers to either\nrun and test code samples or to create executable scripts. Once we have found a site, we can use\nPython to simply deploy our exploit and shellcode. We see in “Code 4” just how simple it is to deploy\nan exploit script written in Python against a web server running on the local host. What we need to do\nis learn just how to write this script so we can deploy the shellcode we are learning to both write and\nto alter.\n\n## Learning Python\n\nThere are many good resources available for those who want to learn Python. Some of the ones I have\nfound to really work are included below:\n\n  - Google Python Class http://www.youtube.com/watch?v=tKTZoB2Vjuk\n\n  - PythonLearn http://www.py4inf.com/\n\n  - The Python Tutorial http://docs.python.org/tutorial/\n\n  - Beginner's Guide to Python http://wiki.python.org/moin/BeginnersGuide\n\n  - Interactive Python tutorial http://www.learnpython.org/\n\nOnce you have the basic skills, we can take these and use them in developing deployment platforms.\nWith these skills, you will find yourself able to do far more than use a framework.\n\n# Conclusion\n\nGaining a comprehensive understanding of shellcode takes time, but it is well worth the effort. In\nfollowing articles, we will extend this process further as we start to detail how we can follow\nshellcode and interpret the jumps and calls made within it. In doing this, we will not only learn how to\nsuccessfully modify the shellcode we have copied from others, extending its use, but to also learn to\ncreate our own. More, we will be able to reverse engineer hostile shellcode and to understand what\npurposes it has been created for.\n\nShellcode can be said to have a shelf life. As samples become popular and are used more widely in\nthe underground community, they are slowly added into IDS and Anti-Malware signatures. Widely\ndeployed shellcode, including that used in the Metasploit project, has a particularly low shelf-life.\nThis is not to say that it will not be useful against many sites, but that it will be less likely to have\nvalue in testing highly secure sites.\n\nIn many cases, the alteration of small sections of the shellcode can result in the signatures that have\nbeen created to detect, alert and block it becoming ineffective. For instance, making small changes to\na piece of existing shellcode to run “/bin/csh” in place of the standard call to “/bin/sh” can increase\nthe useful life of the shellcode. As we start to learn how shellcode is created and formed, we can also\nstart to alter it and extend it running different payloads or changing its form to avoid detection.\n\nPython is a scripting language with a strong support for shellcode. A tester with a good understanding\nof Python and shellcode will be able to create their own exploit packages. This increases the value of\nthe tester immensely. Instead of being one of many people who have the capability to run Metasploit\nor some other automated framework, you become one of a select few people who can actually create\ntheir own tools and exploits.\n\nAnybody who desires to become an advanced pen-tester will find it essential to gain proficiency in at\nleast one scripting language. This of course will require dedicated effort as there is no replacement for\nreal world use in learning to code in any language (even a scripted language such as Python).\n\n\n-----\n\nPython is the language of choice for many penetration testers and there is a wide community within\nthe information security profession developing and extending it. For this reason, Python should be a\nhigh priority on any testers to learn list. There are innumerable examples of Python scripts, tools and\nmethodologies to enhance your own tools readily available with the ease of a Google search. More,\nthere are free tutorials and interactive lessons.\n\n# References\n\nFoster, J., Osipov, V., Bhalla, N., and Heinen, N. (2005) “Buffer Overflow Attacks: Detect, Exploit,\n_Prevent” Syngress, USA_\n\nZeltser, L (2011) “http://zeltser.com/reverse-malware/convert-shellcode.html” Online at:\nhttp://zeltser.com/reverse-malware/convert-shellcode.html\n\nzillion (2002) “Writing Shellcode” (safemode.org) Online at:\nhttp://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html\n\n# Author's bio\n\n### About the Author:\n\n Craig Wright (Charles Sturt University)is the VP of GICSR in Australia. He holds the GSE, GSE-Malware and GSE-Compliance certifications from GIAC. He is a perpetual student with numerous post graduate degrees including an LLM specializing in international commercial law and ecommerce law, A Masters Degree in mathematical statistics from Newcastle as well as working on his 4th IT focused Masters degree (Masters in System Development) from Charles Stuart University where he lectures subjects in a Masters degree in digital forensics. He is writing his second doctorate, a PhD on the quantification of information system risk at CSU.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/2018-04-17 - Beyond Automated Tools and Frameworks - The Shellcode Injection Process.pdf"
    ],
    "report_names": [
        "2018-04-17 - Beyond Automated Tools and Frameworks - The Shellcode Injection Process.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1676945271,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1522508450,
    "ts_modification_date": 1522508450,
    "files": {
        "pdf": "https://archive.orkl.eu/95123547ae9e9779608209f482e3cf36450af295.pdf",
        "text": "https://archive.orkl.eu/95123547ae9e9779608209f482e3cf36450af295.txt",
        "img": "https://archive.orkl.eu/95123547ae9e9779608209f482e3cf36450af295.jpg"
    }
}