{
    "id": "4ef12387-3272-499e-b20d-66c7d6c5ec0f",
    "created_at": "2023-01-12T14:59:56.159099Z",
    "updated_at": "2025-03-27T02:05:43.721861Z",
    "deleted_at": null,
    "sha1_hash": "00084124a0748fe08d2ccf04245339dad14287fe",
    "title": "2022-09-26 - DcDcrypt Ransomware Decryptor",
    "authors": "",
    "file_creation_date": "2022-10-02T12:27:27Z",
    "file_modification_date": "2022-10-02T12:27:27Z",
    "file_size": 1979493,
    "plain_text": "# DcDcrypt Ransomware Decryptor\n\n**[labs.k7computing.com/index.php/dcdcrypt-ransomware-decryptor/](https://labs.k7computing.com/index.php/dcdcrypt-ransomware-decryptor/)**\n\nBy Gaurav Yadav September 26, 2022\n\nWe at K7 Labs came across DcDcrypt ransomware sample, that had infected a user\nmachine and encrypted all user files. Usually the chances of getting back the encrypted\nfiles in such a scenario is 0, given the level of sophistication involved in the encryption.\nAlso paying up the ransomware does not guarantee the files be decrypted as “promised” in\nthe ransomware note. Usually the ransom notes and the encrypted are only left behind in a\nvictimized system, the ransomware sample usually gets self-deleted. This case wasn’t so,\nthe ransomware binary was available and naturally we had a closer look at it. Turns out we\nwere able to decrypt the user files after having looked at the malware. The malware and\nthe decryptor would be henceforth discussed.\n\n**Analysing Ransomware**\n\nThis is a basic ransomware written in C#. It encrypts the user files and writes a ransom\nnote in every directory. It does not delete backups, does not create persistence,does not\neven self-delete(like we mentioned earlier).\n\nUpon execution, this ransomware first checks for a file named “ID.cl”. If the file is not\npresent in the same directory, it creates the file and writes a randomly generated ID (used\nas Victim ID in this case) into it and also stores the ID for further use in a variable named\n**userID. If the ID.cl file is already present in the same directory it will read and store the**\ncontent (ID) into the same variable userID as shown in Figure 1.\n\n\n-----\n\nFigure 1: Creating a userID for the victim\nThis ransomware then asks the user to write yes and press enter to continue the\nencryption through the command line. Once obliged before the start of the encryption the\nransomware first uses the userID and a hardcoded salt to create a password. It uses the\nmethod GetHashCode of passwordHasher class which is then stored in a variable\nnamed password as shown in Figure 2.\n\nFigure 2: Generating a password\n**GetHashCode method just adds the userID and salt and sends it to another method called**\n**Hasher which will create a Sha512 hash of the added userID and salt. Then the sha512**\nhash is converted into base64 as shown in Figure 3. The resultant value is stored in the\nvariable named password of the class CoreEncrypter.\n\n\n-----\n\nFigure 3: GetHashCode and Hasher method\nAfter generating the password, the ransomware starts encrypting the contents of the\ncurrent directory as shown in Figure 4. Enc method takes the current directory path as an\nargument and starts encrypting the files within, traversing all the folders inside the current\ndirectory. This ransomware does not encrypt anything other than the contents of the\ncurrent directory it has been run from.\n\nFigure 4: Enc method being called with the current directory path as argument\nThe Enc method contains two “for” loops, Figure 4: Enc method being called with the\ncurrent directory path as argumentone to traverse the sub-directories within the current\ndirectory using recursive call to Enc method and the other one to encrypt the files of the\ncurrent directory. Before encrypting the file, it first checks if the file name contains any of\nthe following strings:\n\n‘.[Enc]’ which is present in the extension of the encrypted file.\n‘.hta’ which is the extension of ransom note,’ID.cl’ is the userID file that ransomware\ncreates in the beginning.\n’desktop.ini’ is a configuration file.\n‘Encrypter.exe’ is the name of ransomware.\n\nIf any one of these strings is present in the filename then the ransomware won’t encrypt\nthat file. Check Figure 5 for details.\n\n\n-----\n\nFigure 5: Implementation of Enc method\n**EncryptFile contains the encryption routine which is being called in the For loop 1 with the**\nfilename as an argument as shown in Figure 5. Let’s analyse this method so that we can\nfigure out how the encryption is done.\n\nAs we can see in Figure 6 EncryptFile method uses Rfc2898DeriveBytes to generate\nbytes using a password (generated previously using userID and salt) and a salt which can\nlater be used to derive the key and IV(Initialization Vector) for the encryption algorithm.\nThis ransomware uses Rijndael as encryption algorithm which is the predecessor of AES\nalgorithm, at default block size (128 bytes) and in cbc mode it works like AES itself.\n\n[Microsoft declared this algorithm as obsolete and suggests using AES instead.](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.rijndaelmanaged?view=net-6.0)\n\n\n-----\n\nFigure 6: Encryption routine and ransom note\nThe password that is generated using userID and hardcoded salt remains the same for the\nsame userID (check Figure 2 for reference) and since the password is the same, the key\nand IV generated using Rfc2898DeriveBytes also remains the same for the same userID.\n**Rijndael is a symmetric algorithm so the Key-IV pair used for encryption can be used for**\ndecryption also.\n\nAfter initialising all the variables related to encryption, it writes a ransom note in the current\ndirectory. Then the ransomware checks for the file size. If it is less than 1000000 bytes, it\nwill create a new file with the same name + encryption extension and then encrypt the\noriginal file and put the encrypted content in new file and deletes the original file but if it is\nlarger than the mentioned size it will just XOR the 1st byte of the file with 255 and renames\nthe file with original name + encryption extension, where the encryption extension is .[Enc]\n\n**[dc.dcrypt@cyberfear.com And dc.dcrypt@mailfence.com (send both) ATTACK ID =**\n**%userID% Telegram ID = @decryptionsupport1].**\n\n\n-----\n\nFigure 7: Checking file size encrypting file\n\nXORing 1st byte of large files\n\n\nFigure 8:\n\n\n-----\n\nFigure 9: Ransomware execution\n\n\n-----\n\nFigure 10: Ransom Note\n**Decryptor Internals**\n\nAs we already know the ransomware generates a password using userID that it created\nrandomly and a hardcoded salt, since every infected user have a unique userID and we\nknow it will be stored in a file called ID.cl so in our decryptor, instead of creating the userID\nwe would instead read ID.cl file to get the userID and use the same method for generating\nthe password (GetHashCode in Figure 3) as ransomware did to generate the password.\n\nFigure 11: Generating password with userID\n\n\n-----\n\nAfter that this tool would scan all the drives for any encrypted files, all the encrypted files\nhave .[Enc] in their extension hence identifying the encrypted file wouldn’t be too hard.\n\nFigure 12: Scanning all drives\n\nFigure 13:\n\nChecking file name for .[Enc] and sending it for decryption\nSince the ransomware used built-in classes and methods provided by .Net for encrypting\nthe files (RijndaelManaged) we can use the same for decrypting the files. We will generate\nthe Key and IV same way ransomware generated with the password using\n**Rfc2898DeriveBytes.**\n\n\n-----\n\nFigure 14: Initialising Key and IV for decryption\nIn order to decrypt the file size is checked if less than 1000000 bytes then the tool would\nproceed to decrypt it. Ransomware uses rijndaelManaged.CreateEncryptor to create\nencryption stream in the same manner we can use rijndaelManaged.CreateDecryptor to\ncreate thedecryption stream it would use the Key-IV generated before for decryption.\n\nFigure 15: Decrypting file\nAfter decryption, we will write the decrypted bytes into a new file and keep the encrypted\nfile as .[backup] in case the file is not decrypted correctly. For files above 1000000 bytes\nwe will XOR the 1st byte with 255 again to get the original byte and rename the file as the\noriginal name (without encryption extension).\n\n\n-----\n\nFigure 16:\n\nXORing 1st byte with 255 for larger files\n\nFigure 17: Decryption Tool\nWe at K7 Labs provide detection for the DcDcrypt ransomware and all the latest threats.\nUsers are advised to use a reliable security product such as “K7 Total Security” and\nkeep it up-to-date to safeguard their devices.\n\n**Indicators of Compromise (IOCs)**\n\nFilename Hash Detection Name\n\nEncrypter.exe 1A5C50172527D4F867951FF73AB09ED5 Trojan(0001140e1)\n\n**References**\n\n\n-----\n\nhttps://docs.microsoft.com/en-us/archive/blogs/shawnfa/the-differences-between-rijndaeland-aes\n\nhttps://docs.microsoft.com/enus/dotnet/api/system.security.cryptography.rijndaelmanaged?view=net-6.0\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-26 - DcDcrypt Ransomware Decryptor.pdf"
    ],
    "report_names": [
        "2022-09-26 - DcDcrypt Ransomware Decryptor.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535596,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1664713647,
    "ts_modification_date": 1664713647,
    "files": {
        "pdf": "https://archive.orkl.eu/00084124a0748fe08d2ccf04245339dad14287fe.pdf",
        "text": "https://archive.orkl.eu/00084124a0748fe08d2ccf04245339dad14287fe.txt",
        "img": "https://archive.orkl.eu/00084124a0748fe08d2ccf04245339dad14287fe.jpg"
    }
}