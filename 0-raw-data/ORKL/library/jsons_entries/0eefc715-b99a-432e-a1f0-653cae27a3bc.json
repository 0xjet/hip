{
    "id": "0eefc715-b99a-432e-a1f0-653cae27a3bc",
    "created_at": "2023-01-12T15:01:56.040621Z",
    "updated_at": "2025-03-27T02:05:29.142129Z",
    "deleted_at": null,
    "sha1_hash": "b73f1035060831ed1149dc08efa549a8f3bd3d5c",
    "title": "2022-09-12 - Raccoon Stealer v2 Malware Analysis",
    "authors": "",
    "file_creation_date": "2022-10-02T12:22:24Z",
    "file_modification_date": "2022-10-02T12:22:24Z",
    "file_size": 1232913,
    "plain_text": "# Raccoon Stealer v2 Malware Analysis\n\n**[infosecwriteups.com/raccoon-stealer-v2-malware-analysis-55cc33774ac8](https://infosecwriteups.com/raccoon-stealer-v2-malware-analysis-55cc33774ac8)**\n\nAaron Stratton September 29, 2022\n\nImage credit: Bleepingcomputer.com ()\n\n## Introduction\n\nRaccoon Stealer is an infostealer sold on underground hacker/cybercriminal forums, first\nobserved in early 2019. Raccoon Stealer v2 first appeared in June of 2022, after the\ndevelopers returned from a supposed “retirement” which they had announced in early 2022.\n\n[1] Just as with Raccoon Stealer v1, v2 is capable of stealing information to include cookies\nand other browser data, credit card data, usernames, and passwords.\n\n## Technical Analysis\n\nRaccoon Stealer v2 is written in C/C++, and coming in at only ~57kb, it is fairly lightweight.\nBelow are the hashes for the packed sample, and the unpacked sample. Based on my\nresearch, Raccoon Stealer is not sold packed by default, rather, any packing must be done\nby the customer who will deploy the malware.\n\nPacked SHA256:\n40daa898f98206806ad3ff78f63409d509922e0c482684cf4f180faac8cac273\nUnpacked SHA256:\n0123b26df3c79bac0a3fda79072e36c159cfd1824ae3fd4b7f9dea9bda9c7909\n\n## Unpacking\n\n\n-----\n\nUnpacking this sample is pretty straightforward. All I did was place breakpoints on a few API\ncalls of interest such as VirtualProtect, WriteProcessMemory, CreateProcessInternalW, and\nVirtualAlloc. Once the VirtualProtect breakpoint is hit, I followed the address in the EAX\nregister in the memory dump, then ran the program again until the next breakpoint. After that,\nI was able to dump the payload from memory and continue my analysis.\n\nFigure 1. Dumping the second stage payload from memory.\n\n## Resolving Imports\n\nTo start off, I opened the payload in PEstudio to perform some basic static analysis, which\nwill guide how I carry out the rest of the analysis. Opening the binary in PEstudio, the small\nnumber of imported functions (only 8) leads me to believe that the malware probably\nresolves its imports dynamically.\n\n\n-----\n\nFigure 2. Imported functions displayed in PEstudio.\nDisassembling the binary in Ghidra, I found the import resolver function early on in the\nbinary, as expected. This function simply uses the GetProcAddress API function to load the\naddress of the functions it will need. A few of these functions immediately catch my eye,\nthose being the internet related functions highlighted below in figure 3.\n\n\n-----\n\nFigure 3. Internet-related functions in the import resolver function.\n\n## Decrypting Strings and C2 IP Address\n\nThe malware also obfuscates its strings using Base64 encoding and RC4 encryption. The\nRC4 encrypted strings are stored in the Base64 encoded form. These strings are Base64\ndecoded, then decrypted using the RC4 key “edinayarossiya”, which means “United Russia”\nin Russian. Once the strings are decrypted, the malware then performs the same decryption\nroutine for the C2 IP address, but using a different RC4 key.\n\n\n-----\n\nFigure 4. Decoding and decrypting the C2 IP address.\nWith this RC4 key and Base64 encoded data, I could use cyberchef to get the IP address of\nthe C2 node.\n\n\n-----\n\nFigure 5. Extracting the C2 IP address in cyberchef.\n\n## Checking Mutex\n\nNext, the malware checks to see if another instance of it is already running on the infected\nmachine by opening a mutex with the value of 8724643052. If the OpenMutexW function fails\nand returns a 0, the malware creates a mutex with the value, then continues execution. If the\nfunction succeeds and returns 1 (true), the malware exits.\n\n\n-----\n\nFigure 6. Checking for open mutex.\n\n## SYSTEM Check and Process Enumeration\n\nThe malware also checks if it is running as SYSTEM by comparing the current process’s\ntoken to the SYSTEM SID, S-1–5–18.\n\n\n-----\n\nFigure 7. Malware checking if it is running with SYSTEM privileges.\nIf the malware is running as SYSTEM, it then calls a process enumeration function using\nCreateToolHelpSnapshot32, Process32First, and Process32Next.\n\n\n-----\n\nFigure 8. Enumerating the functions on the infected machine.\nIf the malware is not running with SYSTEM privileges, it simply skips over the process\nenumeration function and continues with its execution.\n\n## Host GUID and Username\n\nBefore connecting to the C2 node, the malware will retrieve the host’s GUID by querying the\nSOFTWARE\\Microsoft\\Cryptography registry key.\n\n\n-----\n\nFigure 9. Retrieving the host GUID from the registry.\nThe malware also retrieves the current user’s username, and moves it, along with the\nmachine ID onto the heap before contacting the C2 node.\n\n## C2 Communication\n\nFirst the malware uses the WideCharToMultiByte API function to form all of the parameters it\nneeds in order to connect to the C2 node, including the machineID, username, and configID\nparameters which will be sent to the C2 node via POST request. Of note, the configID\nparameter is just the RC4 key that was used to decrypt the C2 IP address earlier in the\nexecution.\n\n\n-----\n\nFigure 10. POST request to the C2 node containing the machineID, username, and configID\nparameters.\nThe malware then checks to see if the response from the C2 node is larger than 0x3f (63 in\ndecimal) characters long. If it is, the malware continues execution. If not, the malware breaks\nout of the loop and exits.\n\nFigure 11. Checking the length of the C2 node’s response.\nUnfortunately, at the time I performed my analysis, the C2 IP address did not appear to be up\nanymore, as Shodan showed that port 3389 (RDP) was the only listening port. Assuming that\nthe C2 node was still operational and able to communicate with the infected host, the C2\nnode would return several different DLL’s for download to the infected host. Those DLL’s\nwould then be placed in the “C:\\Documents and Settings\\Administrator\\Local\nSettings\\Application Data” folder.\n\n\n-----\n\nFigure 12. Note the function setting the folder path before moving the downloaded DLL’s to\nthat path (C:\\Documents and Settings\\Administrator\\Local Settings\\Application Data)\n\n\n-----\n\nFigure 13. Setting the folder path for the DLL’s to be placed into.\nIt is at this point that the malware would perform the bulk of it’s stealing functionality,\nincluding cookies, passwords, credit card data, passwords, browser history, etc. [2] Some of\nthis functionality would automatically be executed, and some would require a command from\nan operator in control of the C2 node.\n\n## Conclusion\n\nIn conclusion, Raccoon Stealer v2 is a relatively simple, yet very capable info stealer just like\nv1. Both versions of this stealer pose a threat to organizations of all types, as well as\nindividuals. The information stolen by this malware can be used to take over accounts of all\ntypes, financial, social media, corporate, etc.\n\nI hope you enjoyed this post, and that you’ll come back again! A follow and share would be\nsuper appreciated. Feedback is certainly welcome as well.\n\n\n-----\n\n## References\n\n[1] https://www.bleepingcomputer.com/news/security/raccoon-stealer-is-back-with-a-newversion-to-steal-your-passwords/\n\n[2] [https://blog.sekoia.io/raccoon-stealer-v2-part-2-in-depth-analysis/#h-mutex](https://blog.sekoia.io/raccoon-stealer-v2-part-2-in-depth-analysis/#h-mutex)\n\n## From Infosec Writeups: A lot is coming up in the Infosec every day that it’s hard to keep up with. Join our weekly newsletter to get all the latest Infosec trends in the form of 5 articles, 4 Threads, 3 videos, 2 Github Repos and tools, and 1 job alert for FREE!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-12 - Raccoon Stealer v2 Malware Analysis.pdf"
    ],
    "report_names": [
        "2022-09-12 - Raccoon Stealer v2 Malware Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535716,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1664713344,
    "ts_modification_date": 1664713344,
    "files": {
        "pdf": "https://archive.orkl.eu/b73f1035060831ed1149dc08efa549a8f3bd3d5c.pdf",
        "text": "https://archive.orkl.eu/b73f1035060831ed1149dc08efa549a8f3bd3d5c.txt",
        "img": "https://archive.orkl.eu/b73f1035060831ed1149dc08efa549a8f3bd3d5c.jpg"
    }
}