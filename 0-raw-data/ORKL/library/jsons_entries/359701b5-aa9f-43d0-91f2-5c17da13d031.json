{
    "id": "359701b5-aa9f-43d0-91f2-5c17da13d031",
    "created_at": "2023-01-12T15:09:29.06449Z",
    "updated_at": "2025-03-27T02:08:36.180274Z",
    "deleted_at": null,
    "sha1_hash": "dff084e45c1f8d2ecf1aeb80eceb674624d7bdf5",
    "title": "2020-05-26 - Know Your Enemy- Exploiting the Dell BIOS Driver Vulnerability to Defend Against It",
    "authors": "",
    "file_creation_date": "2022-05-28T15:49:40Z",
    "file_modification_date": "2022-05-28T15:49:40Z",
    "file_size": 2623775,
    "plain_text": "# CVE-2021-21551: Learning Through Exploitation | CrowdStrike\n\n**[crowdstrike.com/blog/cve-2021-21551-learning-through-exploitation/](https://www.crowdstrike.com/blog/cve-2021-21551-learning-through-exploitation/)**\n\nConnor McGarr May 26, 2021\n\nThere is a quote from Sun Tzu, “The Art of War,” that remains true to this day, especially in\ncybersecurity: “Know thy enemy and know yourself; in a hundred battles, you will never be\ndefeated.”\n\nAt CrowdStrike, we stop breaches — and understanding the tactics and techniques\nadversaries use helps us protect our clients from known and unknown threats. It allows us to\npre-mitigate threats before they happen and react quickly to new and previously unknown\nattacks and attack vectors.\n\nLooking at the recently published vulnerability in Dell’s firmware update driver (CVE-2021[21551) reported by CrowdStrike’s Yarden Shafir and Satoshi Tanda, it’s worth understanding](https://www.crowdstrike.com/blog/crowdstrike-falcon-detects-dell-driver-vulnerability-cve-2021-21551/)\nthat adversaries have more than one way of weaponizing it to achieve the same result:\nobtaining full control of the victim’s machine. For example, while CVE-2021-21551 can be\nexploited to overwrite a process’s token and directly elevate its privileges, this is a relatively\nwell-known technique that most endpoint detection and response (EDR) tools should detect.\n\n\n-----\n\nThe technique we re exploring in this research is already at the end of its lifecycle, with the\n[inception of Windows features such as Virtualization-Based Security. However, it speaks to](https://www.crowdstrike.com/blog/state-of-exploit-development-part-2/)\nthe fact that adversaries will constantly try to go a different path and use a more complex or\ndifferent technique to achieve a full administrative access over a system, avoiding the most\ncommon EDR detections and preventions, as well as operating systems mitigations not\navailable or enabled in some OS versions.\n\nTo protect against adversaries that could exploit this vulnerability, we have to dive into the\nmindset of an attacker to understand how they would craft and exploit this vulnerable driver\nto take control of a vulnerable machine. While a patch for this vulnerability has been\nreleased, patch management cycles in enterprises can take months before all systems are\nupdated.\n\nThe goal of this post is to understand how adversaries think when weaponizing\nvulnerabilities, what technologies may work best in mitigating some of these tactics, and how\nCrowdStrike Falcon® protects against these attacks, leveraging the type of research\nembodied in this blog post.\n\n## Exploitation Is a Never-ending Arms Race\n\nOS vendors patch vulnerable systems, and EDR vendors add detections and security\nmitigations as fast as possible. Meanwhile, attackers continuously find new bugs,\nvulnerabilities and novel exploitation techniques to take over targeted systems.Tactically\nmitigating the latest known driver is excellent, but that wins the battle, not the war.\n\n[Adversaries can create exploits for vulnerabilities using several different methods, giving](https://adversary.crowdstrike.com/)\nthem a wide range of options for crafting payloads exploiting patched or unpatched\nvulnerabilities to compromise endpoints, take full control over them and ultimately breach\nenterprise security. A vulnerability presents a possibility, but there is still a long way to go for\nan attacker to turn it into a functional weapon. And every new security mitigation and\nhardening becomes another hurdle that the attacker needs to overcome, leading to\nincreasingly complicated, multi-stage exploits.\n\nHowever, some things make exploitation slightly easier for attackers. Third-party drivers\nrunning on the machine, especially hardware drivers built to have direct access to all areas\nof the machine, may not always have a very high level of security awareness in their\ndevelopment process.\n\nSimilar vulnerabilities were disclosed and used in the wild in recent years, and every few\nmonths a new vulnerable driver is discovered and published, making headlines.\n\n## Building an Exploit for CVE-2021-21551\n\n\n-----\n\nThe quick synopsis of this vulnerability is that an IOCTL code exists that allows any user to\nwrite arbitrary data into an arbitrary address in kernel-mode memory. Any caller can trigger\nthis IOCTL code by invoking `DeviceIoControl to send a request to dbutil_2_3.sys while`\nspecifying the IOCTL code `0x9B0C1EC8 with a user-supplied buffer, allowing for an arbitrary`\nwrite primitive. Additionally, specifying an IOCTL code of `0x9B0C1EC4 allows for an`\narbitrary read primitive.\n\nTo allow user-mode callers to interact with kernel-mode drivers, drivers create device\nobjects. We can see the creation and initialization of this device object in the driver’s entry\npoint, named `DriverEntry .`\n\nThis is just the “official” entry point, which immediately calls the “actual” driver entry:\n\n\n-----\n\nAs shown, the \\Device\\DBUtil_2_3 string is used in the call to `IoCreateDevice to`\ncreate a DEVICE_OBJECT. This string is then used in a call to `IoCreateSymbolicLink,`\nwhich creates a symbolic link that is exposed to user-mode clients. In this case, the symbolic\nlink is `\\\\.\\DBUtil_2_3 . After identifying the symbolic link, CreateFile can be used to`\nobtain a handle to `dbutil_2_3.sys .`\n\n\n-----\n\n```\nDeviceIoControl can then be used to interact with the driver. The first step is to identify\n\n```\nwhere the IOCTL routines are handled in the driver. We can discover that through the\n```\nDriverEntry functions as well — handlers for all I/O operations are registered in the\n\n```\ndriver’s `DRIVER_OBJECT, in the` `MajorFunction field. This is an array of` `IRP_MJ_XXX`\ncodes, each matching one I/O operation.\n\nLooking at this, we can see that this driver uses one function for all of its operations, and\nwhen we open the function, we can easily tell that it is mostly dedicated to handling IOCTL\noperations (named `IRP_MJ_DEVICE_CONTROL in the driver object). The` `MajorFunction`\ncode is tested, and if it isn’t `IRP_MJ_DEVICE_CONTROL, it is handled separately at the end`\nof the function:\n\nThe vulnerable IOCTL code in this case is `0x9B0C1EC8, for the write primitive. If this check`\nis passed successfully, the handler will call the vulnerable function, which we chose to call\n```\nArbitraryWriteFunction for convenience:\n\n```\n\n-----\n\nThis is the function in which the vulnerable code resides in, which contains a call to\n```\nmemmove, whose arguments can be fully controlled by the caller:\nmemmove copies a block of memory into another block of memory via pointers. If we can\n\n```\ncontrol the arguments to `memmove, this gives us a vanilla arbitrary write primitive, as we will`\nbe able to overwrite any pointer in kernel mode with our own user-supplied buffer. Armed\nwith the understanding of the write primitive, the last thing needed is to make sure that from\nthe time the IOCTL code is checked and the final `memmove call is invoked that any`\nconditional statements that arise are successfully dealt with. This can be tested by sending\nan arbitrary QWORD to kernel mode to perform dynamic analysis.\n\n\n-----\n\nSetting a breakpoint on the routine that checks the IOCTL code and after running the POC,\nexecution hits the target IOCTL routine. After the comparison is satisfied, execution hits the\ncall to the function housing the call to `memmove, prior to the stack frame for this function`\nbeing created.\n\n\n-----\n\nThe test buffer is also accessible when dereferencing the value in RCX.\n\n\n-----\n\nAfter stepping through the `sub rsp, 0x40 stack allocation and the` `mov rbx, rcx`\ninstruction, the value 0x8 is then placed into ECX and used in the `cmp ecx, 0x18`\ncomparison.\n\nECX, after the mov instruction, actually contains the size of the buffer, which is currently one\nQWORD, or 8 bytes. This compare statement will fail and an NTSTATUS code is returned\nback to the client of `0xC0000000D ( STATUS_INVALID_PARAMETER ). This means clients`\nneed to send at least 0x18 bytes worth of data to continue.\n\nThe next step is to try and send a contiguous buffer of 0x18 bytes of data, or greater. A 0x20\nbyte buffer is ideal. This is because when the buffers are propagated before the `memmove`\ncall, the driver will index the buffer at an offset of 0x8 (the destination) and 0x18 (the source)\n\n\n-----\n\nfor the arguments. We will use `KUSER_SHARED_DATA, at an offset of 0x800`\n( 0xFFFFF78000000800 ) in `ntoskrnl.exe, which contains a writable code cave, as a`\nproof-of-concept (POC) address to showcase the write primitive.\n\nRe-executing the POC, and after stepping through the function that leads to the eventual call\nto memmove, the lower 32-bits of the third element of the array of QWORDs sent to the\ndriver are loaded into ECX.\n\n\n-----\n\nRSP+0x28 will then be added to RCX, which is a stack address that contains the address of\n```\nKUSER_SHARED_DATA+0x800 . The final result of the operation is 0xFFFFF78042424242 .\n\n```\n\n-----\n\nJust before the call to `memmove, the fourth element of the test array is placed into RDX. Per`\nthe `__fastcall calling convention, the value in RCX will serve as the destination address`\n(the “where”) and RDX will serve as the source address (the “what”), allowing for a classic\nwrite-what-where condition. These are the two arguments that will be used in the call to\n```\nmemmove, which is located at dbutil_2_3+0x1790 .\n\n```\nThe issue is, however, with the source address. The target specified was\n```\n0xFFFFF78000000800 but the address got mangled into 0xFFFFF78042424242 . This is\n\n```\nbecause of the addition of the lower 32-bits of the third element of the array to the second\nelement of the array, which was the destination address. Swapping `0x4242424242424242`\nwith `0x0000000000000000 allows clients to satisfy this issue by having a value of zero`\nadded to the target address, rendering it unmangled.\n\n\n-----\n\nAfter sending the POC again, the correct arguments are supplied to the `memmove call.`\n\n\n-----\n\nExecuting the call, the arbitrary write primitive has succeeded.\n\nWith a successful write primitive in hand, the next step is to obtain a read primitive for\nsuccessful exploitation.\n\n## Arbitrary Read Primitive\n\nSupplying arguments to the vulnerable `memmove routine used for the arbitrary write`\nprimitive, an adversary can supply the “what” (the data) and the “where” (the memory\naddress) in the write-what-where condition. It is worth noting that at some point between the\n```\nmemmove call and the invocation of DeviceIoControl, the array of QWORDs used for the\n\n```\n\n-----\n\nwrite primitive were transferred to kernel mode to be used by `dbutil_2_3.sys in the call to`\n```\nmemmove . Notice, however, that the target address, the value in RCX, is completely\n\n```\ncontrollable – meaning the driver doesn’t create a pointer to that QWORD, it can be supplied\ndirectly. Since `memmove will interpret the target address as a pointer, we can actually`\noverwrite whatever we pass as the target buffer in RCX, which in this case is any address we\nwant to corrupt.\n\nTo read memory, however, there needs to be a similar primitive. In place of the kernel mode\naddress that points to `0x4343434343434343 in RDX, we need supply our own value`\ndirectly, instead of the driver creating a pointer to it, identical to the level of control we have\non the target address we want write over.\n\nThis is what occurred with the write primitive:\n\n```\nFfffc60524e82998  4343434343434343\n\n```\n\nThis is what needs to occur with the read primitive:\n\n```\n4343434343434343   DATA\n\n```\n\nIf this happens, `memmove will interpret this address as a pointer and it will be dereferenced.`\nIn this case, whatever value supplied would first be dereferenced and then the contents\ncopied to the target buffer, allowing us to arbitrarily read kernel-mode pointers.\n\nOne option would be to write this data into a declared user-mode pointer in C. Since the\ndriver is taking the supplied buffer and propagating it in kernel mode before leveraging it, the\nbetter option would be to supply an output buffer to `DeviceIoControl and see if the`\n```\nmemmove data writes the read value to the output buffer.\n\n```\nThe latter option makes sense as this IOCTL allows any client to supply a buffer and have it\ncopied. This driver isn’t compensating for unauthorized clients to this IOCTL, meaning the\ninput and output buffers are more than likely being used by other components and legitimate\nclients that need an easy way to read and write data. This means there more than likely will\nbe another way to invoke the memmove routine that allows clients to do the inverse of what\noccurred with the write primitive, and to read memory instead. `KUSER_SHARED_DATA,`\n```\n0xFFFFF78000000000 will be used as a proof-of-concept.\n\n```\nAfter a bit more reverse engineering, it is clear there is more than one way to reach the\n```\nmemmove routine. This is through the IOCTL 0x9B0C1EC4 .\n\n```\n\n-----\n\nTo read memory arbitrarily, everything can be set to 0 or “filler” data, in the array of QWORDs\npreviously used for the write primitive, except the target address to read from. The target\naddress will be the second element of the array. Then, reusing the same array of QWORDs\nas an output buffer, we can then loop through the array to see if any elements are filled with\nthe read contents from kernel mode.\n\n\n-----\n\n-----\n\nAfter running the updated proof of concept, execution again reaches the function housing the\n```\nmemmove routine, dbutil_2_3+0x5294 .\n\n```\n\n-----\n\n```\nKUSER_SHARED_DATA is then moved into RCX and then finally loaded into RDX.\n\n```\nPer the `__fastcall calling convention,` `KUSER_SHARED_DATA, our target address to read`\nfrom, will be used as the second argument for the call to `memmove . Since` `memmove`\naccepts two pointers to a memory address, this means that this address in RCX will be\nwhere the buffer is written to and the address in RDX, which is a controlled value to be read\nfrom, will be dereferenced first and then its contents copied to the address currently in RCX,\nwhich will be returned in the output buffer parameter of `DeviceIoControl .`\n\n\n-----\n\nAfter the call to `memmove, the return value is set to the dereferenced contents of`\n```\nKUSER_SHARED_DATA .\n\n```\nThis results in a successful read primitive!\n\n\n-----\n\nWith a read/write primitive in hand, exploitation can be achieved in multiple fashions. We will\ntake a look at a method that involves hijacking the control flow of the driver’s execution and\ncorrupting page table entries to achieve code execution.\n\n## Exploitation\n\nThe goal for exploitation is as follows:\n\n1. Locate the base of the page table entries\n2. Calculate where the page table entry for the memory page where the shellcode resides\n\nand extract the PTE memory property bits\n3. Write shellcode, which will copy the `TOKEN member from the` `SYSTEM EPROCESS`\n\nobject to the exploit process, somewhere that is writable in the driver’s virtual address\nspace\n4. Corrupt the page table entry to make the shellcode page RWX and bypassing kernel\n\nno-eXecute (DEP)\n5. Overwrite `[nt!HalDispatchTable+0x8] and invoke`\n```\n   ntdll!NtQueryIntervalProfile, which will execute\n   [nt!HalDispatchTable+0x8]\n\n```\n6. Immediately restore `[nt!HalDispatchTable+0x8] in an attempt to avoid Kernel`\n\nPatch Protection, or KPP, which monitors the integrity of dispatch tables at certain\nintervals.\n\n### 1. Locate the base of the page table entries\n\nLooking for a writable code cave in kernel mode that can be reliably written to, the `.data`\nsection of `dbutil_2_3.sys, which is already writable, presents a viable option.`\n\n\n-----\n\n-----\n\nThe aforementioned shellcode is approximately 9 QWORDs, so this is a viable code cave in\nterms of size.\n\nThe shellcode will be written starting at `.data+0x10 . Since this has been decided and`\nsince this address space resides within the driver’s virtual address space, it is trivial to add a\nroutine to the exploit that can retrieve the load address of the kernel, for page table entry\n(PTE) indexing calculations, and the base address of `dbutil_2_3.sys, from a medium`\nintegrity process.\n\n\n-----\n\nSince the location the shellcode will be to written to is at an offset of 0x3000 (the offset to\n```\n.data ) + 0x10 (the offset to code cave) from the base address of dbutil_2_3.sys, we\n\n```\ncan locate the page table entry for this memory address, which already is a kernel-mode\npage and is writable. In order to perform the calculations to locate the page table entry we\nfirst need to bypass page table randomization, a mitigation of Windows 10 after 1607.\n\nThis is because we need the base of the page table entries in order to locate the PTE for a\nspecific page in memory (the page table entries are an array of virtual addresses for our\npurposes). The Windows API function `nt!MiGetPteAddress, at an offset of 0x13, contains,`\ndynamically, the base of the page table entries as this kernel-mode function is leveraged to\nfetch the PTE of a given page.\n\nThe read primitive can be used to locate the base of the page table entries (note the offset to\n```\nnt!MiGetPteAddress will change on a per-patch basis).\n\n```\n\n-----\n\n### 2. Calculate where the page table entry for the memory page where the shellcode resides and extract the PTE memory property bits\n\nThen, it’s possible to replicate what `nt!MiGetPteAddress does in order to fetch the correct`\nPTE from the PTE array for the page the shellcode resides in, programmatically.\n\nThis can also be verified in WinDbg.\n\n\n-----\n\nWe can then use the read primitive again in order to preserve what the PTE address points\nto, which is a set of bits which set properties and permissions of the page. These will be\ncorrupted later.\n\n\n-----\n\nThis can also be verified in WinDbg.\n\n\n-----\n\n### 3. Write shellcode, which will copy the TOKEN value from the SYSTEM EPROCESS object to the exploit process, somewhere that is writable in the driver’s virtual address space\n\nThe next step is to write the shellcode to `.data+0x10 ( dbutil_2_3+0x3010 ). This can be`\ndone by writing the following nine QWORDs to kernel mode using the write primitive.\n\nAfter leveraging the arbitrary write primitive, the shellcode is written to the `.data section of`\n```\ndbutil_2_3.sys .\n\n```\n\n-----\n\nThe above shellcode will programmatically perform a call to `nt!PsGetCurrentProcess to`\nlocate the current process’ `EPROCESS object, which would be the exploiting process. The`\nshellcode then accesses the `ActiveProcessLinks member of the` `EPROCESS object in`\norder to walk the doubly-linked list of active `EPROCESS objects until the` `EPROCESS object`\nfor the `SYSTEM process, which has a static PID of 4, is identified. When this is found, the`\nshellcode will then copy the `TOKEN member of the` `SYSTEM process’` `EPROCESS object`\nover the current unprivileged token of the exploiting process, essentially granting the process\ntriggering the exploit and any subsequent processes launched from the exploit process full\nkernel-mode privileges, allowing for full administrative access to the OS.\n\n### 4. Corrupt the page table entry to make the shellcode page RWX and bypassing kernel no-eXecute (DEP)\n\nNow that the shellcode is in kernel mode, we need to make it executable, since the `.data`\nsection is read/write only. Since we have the PTE bits already stored, we can clear the noeXecute bit and leverage the arbitrary write primitive to overwrite the current PTE and corrupt\nit to make the page read/write/execute (RWX).\n\n\n-----\n\n### 5. Overwrite [nt!HalDispatchTable+0x8] and invoke ntdll!NtQueryIntervalProfile, which will execute [nt!HalDispatchTable+0x8]\n\nThe shellcode now resides in a kernel-mode page which is RWX. The last step is to trigger a\ncall to this address. One option is to potentially identify a function pointer within the driver\nitself, as it does not contain any control-flow checking. However, we can also use a very well\ndocumented “system wide” method to trigger the shellcode’s execution, which would be to\noverwrite `[nt!HalDispatchTable+0x8] and call` `ntdll!NtQueryIntervalProfile . This`\nfunction call would eventually trigger a call to `[nt!HalDispatchTable+0x8], executing our`\nshellcode.\n\nBefore overwriting `[nt!HalDispatchTable+0x8], it is best practice to use the read`\nprimitive to preserve the current pointer so we can restore it back after executing our\nshellcode to ensure system stability, as the Hardware Abstraction Layer is very important on\n\n\n-----\n\nWindows and the dispatch table is referenced regularly. Additionally, Kernel Patch Protection\nperforms checks on dispatch tables, meaning we will want to try to restore everything as\nquickly as possible.\n\nAfter preserving [nt!HalDispatchTable+0x8] the write primitive can be used to overwrite\n```\n[nt!HalDispatchTable+0x8] with a pointer to our shellcode, which resides in kernel\n\n```\nmode memory.\n\n\n-----\n\nAt this point, if we invoke `[nt!HalDispatchTable+0x8], we will be calling our shellcode!`\nThe last step here, besides restoring `[nt!HalDispatchTable+0x8], is to resolve`\n```\nntdll!NtQueryIntervalProfile, which eventually performs a call to\n\n```\n\n-----\n\n### 6. Immediately restore [nt!HalDispatchTable+0x8] in an attempt to avoid Kernel Patch Protection, or KPP, which monitors the integrity of dispatch tables at certain intervals.\n\nThe exploit is then finished by adding in a routine to restore `[nt!HalDispatchTable+0x8] .`\n\n\n-----\n\nStepping through a few instructions inside of `nt!KeQueryIntervalProfile, after the call`\nto `ntdll!NtQueryIntervalProfile, we can see that we are not directly calling`\n```\n[nt!HalDispatchTable+0x8], but we are calling nt!guard_dispatch_icall . This is\n\n```\npart of KCFG, or Kernel Control-Flow Guard, which validates indirect function calls (e.g.\ncalling a function pointer).\n\n\n-----\n\nClearly, as we can see, the value of `[nt!HalDispatchTable+0x8] is pointing to the`\nshellcode, meaning that KCFG should block this activity. The reason why KCFG will not\nblock this attempt at an invalid call target is because KCFG is only enforced when Hyper-V is\nenabled on the machine and Virtualization-Based Security is active, which isn’t the case on\nthe machine we are testing this exploit on. The reason why VBS is needed to enforce KCFG\nis because if the KCFG bitmap was allocated in the kernel, one more arbitrary write(s) would\nallow an adversary to make a shellcode page a “valid” target as well, completely bypassing\nthe mitigation.\n\nSince VBS is not enabled we can actually see that all this routine does essentially is bitwise\ntest the target address to confirm it isn’t a user-mode address. If it is a user-mode address,\nthis results in a bug check and system crash.\n\n\n-----\n\nAfter passing the bitwise test, control-flow transfer is handed off to the shellcode.\n\n\n-----\n\nFrom here, we can see we have successfully obtained NT AUTHORITY\\SYSTEM privileges.\n\n## CrowdStrike Protection\n\nFalcon can detect and prevent kernel attacks, offering visibility into some of the most\ncommonly and uncommonly used IOCTLs abused in the real world through Additional UserMode Data (AUMD). This gives Falcon the ability to protect endpoints from the exploitation of\nvulnerable drivers and from adversaries attempting to exploit this particular Dell driver (CVE2021-21551) vulnerability using the technique described in this post.\n\nFalcon protects customers from exploitation attempts like the one described in this research\nin several ways. One is to block drivers from loading if declared malicious. Another is to\ndetect certain communication mechanisms to specific drivers, allowing the vulnerable driver\nto run but detecting if attackers communicate with said drivers and exploit these\nvulnerabilities, such as the exploit mentioned in this blog post.\n\n## Recommendations\n\nAdversarial tactics and techniques are becoming increasingly sophisticated, and\norganizations need to rely on security solutions that can protect them when it matters, that\noffer visibility into their infrastructure and have proven capabilities of disrupting sophisticated\nadversaries and adversarial tactics. It’s also essential to adhere to security hygiene and best\npractices stretching from patch management to security policies and procedures to reduce\nrisk.\n\nThis exercise of exploiting the Dell vulnerability proves that adversaries have different\nexploitation tactics at their disposal for exploiting vulnerabilities, whether they are patched or\nunpatched, meaning that there is usually more than one way to take advantage of a\nvulnerability. Updating operating systems to the newest version and enabling Hyper-V, VBS\nand HVCI will help to mitigate the demonstrated attack technique.\n\n\n-----\n\nA timely and effective patch management strategy is also recommended for identifying and\ndeploying software, firmware and hardware driver updates that fix known security\nvulnerabilities or technical issues, and for prioritizing patching efforts based on the severity of\nthe vulnerability.\n\nDriver inventorying throughout the organization can also help identify whenever suspicious\nprocesses attempt to communicate with them, determine whether the path they’re running\nfrom is legitimate, or even identify suspicious interaction between them. While malicious\ninteraction can be hard to attribute with high confidence, defenders need to constantly be\nvigilant for suspicious-looking telemetry events indicative of adversary activity.\n\n## Conclusion\n\nCrowdStrike is constantly aware of adversary thought processes and can detect and mitigate\n[attack tactics demonstrated here and in our previous blog post about this driver vulnerability.](https://www.crowdstrike.com/blog/crowdstrike-falcon-detects-dell-driver-vulnerability-cve-2021-21551/)\n\nThis interesting exploitation technique exercise demonstrates how a skilled attacker can\nleverage a vulnerability and gain full control over a machine in various ways. Organizations\nneed to run the latest builds for software, firmware and hardware drivers and enable the\nnecessary security features to close the window of opportunity for adversaries attempting to\nexploit similar vulnerabilities.\n\nOS developers and hardware developers are constantly adding new security features to\nmitigate these attacks. Enabling VBS, KCFG, CET and other technologies is critical for\nblocking similar attack vectors and preventing adversaries from successfully exploiting and\ncompromising enterprise machines.\n\nExploits taking advantage of legitimate yet vulnerable drivers may be difficult to detect, but\nnot for CrowdStrike. Our threat intelligence and Falcon OverWatch™ teams monitor all\nevents reported by the Falcon sensor to quickly identify suspicious behavior and react to it,\nkeeping our customers safe from breaches.\n\n**Additional Resources**\n\n_[Learn more about the CrowdStrike Falcon® platform by visiting the product webpage.](https://www.crowdstrike.com/endpoint-security-products/falcon-platform/)_\n_Learn more about CrowdStrike endpoint detection and response by visiting the Falcon_\n_[Insight™ webpage.](https://go.crowdstrike.com/try-falcon-prevent.html)_\n_See how you can continuously monitor and assess the vulnerabilities in your_\n_[environment with Falcon Spotlight.](https://www.crowdstrike.com/endpoint-security-products/falcon-spotlight-vulnerability-management/)_\n_[Test CrowdStrike next-gen AV for yourself. Start your free trial of Falcon Prevent™](https://go.crowdstrike.com/try-falcon-prevent.html)_\n_today._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-26 - Know Your Enemy- Exploiting the Dell BIOS Driver Vulnerability to Defend Against It.pdf"
    ],
    "report_names": [
        "2020-05-26 - Know Your Enemy- Exploiting the Dell BIOS Driver Vulnerability to Defend Against It.pdf"
    ],
    "threat_actors": [
        {
            "id": "77b28afd-8187-4917-a453-1d5a279cb5e4",
            "created_at": "2022-10-25T15:50:23.768278Z",
            "updated_at": "2025-03-27T02:00:55.5423Z",
            "deleted_at": null,
            "main_name": "Inception",
            "aliases": [
                "Inception Framework",
                "Cloud Atlas"
            ],
            "source_name": "MITRE:Inception",
            "tools": [
                "PowerShower",
                "VBShower",
                "LaZagne"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536169,
    "ts_updated_at": 1743041316,
    "ts_creation_date": 1653752980,
    "ts_modification_date": 1653752980,
    "files": {
        "pdf": "https://archive.orkl.eu/dff084e45c1f8d2ecf1aeb80eceb674624d7bdf5.pdf",
        "text": "https://archive.orkl.eu/dff084e45c1f8d2ecf1aeb80eceb674624d7bdf5.txt",
        "img": "https://archive.orkl.eu/dff084e45c1f8d2ecf1aeb80eceb674624d7bdf5.jpg"
    }
}