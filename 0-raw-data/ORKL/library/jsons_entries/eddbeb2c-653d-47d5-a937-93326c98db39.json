{
    "id": "eddbeb2c-653d-47d5-a937-93326c98db39",
    "created_at": "2023-01-12T15:09:02.706694Z",
    "updated_at": "2025-03-27T02:08:36.12758Z",
    "deleted_at": null,
    "sha1_hash": "9d2cf78e59a31d275ce6d78c6d146b2c46252b1e",
    "title": "2020-08-29 - Emulating NotPetya bootloader with Miasm",
    "authors": "",
    "file_creation_date": "2022-05-28T02:16:11Z",
    "file_modification_date": "2022-05-28T02:16:11Z",
    "file_size": 932634,
    "plain_text": "# Emulating NotPetya bootloader with Miasm\n\n**[aguinet.github.io//blog/2020/08/29/miasm-bootloader.html](https://aguinet.github.io//blog/2020/08/29/miasm-bootloader.html)**\n\n29 Aug 2020 in Blog\n\nNotPetya is a famous malware of the Petya family. It appeared in June 2017. The part\nrunning from the Master Boot Record (MBR) has been statically and dynamically studied,\nusing for instance the Bochs debugger from IDA. Is another approach possible? This article’s\ngoal is to show that we can emulate this bootloader using Miasm.\n\n_[This article has been written by Jordan Bouyat (@la_F0uin3) and](https://twitter.com/la_F0uin3)_ _Adrien Guinet_\n_[(@adriengnt). It has originally been published in the MISC magazine n°98 in French. This is](https://connect.ed-diamond.com/MISC/MISC-098/Emulation-du-bootloader-de-NotPetya-avec-Miasm)_\n_a slightly updated and English translation of this article._\n\n## Introduction\n\nThis Petya variant first appeared in June 2017 in Ukraine. According to Mikko Hyppönen,\nChief Research Officer at F-Secure, the infection vector would be the update mechanism of\nthe accountability software M.E.Doc, widely deployed within Eastern countries.\n\nThis malware family has the particularity of overwriting the bootloader of the compromised\nmachine in order to encrypt parts of the hard drive when it reboots. This article uses this\nbootloader as a pretext for a tutorial concerning the emulation and reverse engineering of\nthese little beasts thanks to the Miasm framework. The associated code is available here:\n[https://github.com/aguinet/miasm-bootloader/. It contains a Python implementation of a](https://github.com/aguinet/miasm-bootloader/)\nsubset of the interfaces of a classic x86 PC BIOS. The code was written in a way that is\neasily reusable for other cases, or even to help the development / debugging of bootloaders\nin general.\n\n## Related works\n\nMany articles have already studied the behaviour of the NotPetya MBR, as well as its various\ncryptographic implementations and mechanisms (and their faults). Here are some significant\nones:\n\nMISC n°86 : “Pleased to meet you, my name is Petya !”, written by Damien Schaeffer\nin July 2016\nMISC n°93 : “Petya or Not Petya, that is the question”, written by “Teddy and Benjamin”\nin September 2017, with a very thorough static reverse engineering of the bootloader.\n[Crowdstrike : Full Decryption of Systems Encrypted by Petya/NotPetya. Study of an](https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/)\nimplementation error within the Salsa20 algorithm embedded in the bootloader (more\non that subject later in the article).\n\n\n-----\n\n## NotPetya\n\nThis section deals only in a very general way with the malware’s cycle of life. It allows us to\nhighlight the part studied in this article.\n\nOnce NotPetya has run on the victim’s machine, it generates an AES encryption key that will\nbe used to achieve the first encryption phase. This key is itself encrypted with an RSA public\nkey.\n\nThe malware then checks that the system uses a classical partition scheme and, if it has\nadmin rights, enters its own data on the first sectors of the disc (from 1 to 18, then 32 to 34),\nwith its own MBR in the first sector. If the system uses UEFI (with a GPT partition scheme),\nthe malware skips this step. The machine then is restarted and the NotPetya bootloader\nexecuted: a Salsa20 key and a nonce are generated. These secrets are used to encrypt the\nMaster File Table (MFT) 1 of NTFS file system. This data structure contains the metadata\nneeded to find the data associated with each file. This operation looks like a classical\n“chkdsk”. Once this operation is done, the machine restarts one last time and then displays\nthe ransom message.\n\n## Miasm\n\nMiasm is a reverse engineering framework developed in Python. It has many features,\namong which:\n\nopen, modify and generate binaries in PE, ELF 32, 64 LE, BE.\nassemble/disassemble x86, ARM, MIPS, SH4, PPC and MSP430 code.\nlift instruction semantics into a custom intermediate representation.\nemulate this intermediate representation, with various JIT (Just-in-time) compilers to\nspeed things up.\nsimplify/modify this intermediate representation, to de-obfuscate code for instance.\n\n## Why emulate NotPetya with Miasm?\n\n\n-----\n\nThere are various ways to emulate a bootloader. A classical approach is to use QEMU (or\nany other virtualization/emulation solution) by writing the bootloader on a virtual hard disk,\nbut it makes it difficult to instrument the bootloader code. Such a thing is however possible\nvia IDA’s Bochs debugger. This approach was adopted by Teddy and Benjamin in MISC No.\n93, but also by Saurabh Sharma 2. This method usually works well and makes debugging a\nbootloader an easy task.\n\nIn the article associated with the presentation of his Miasm tool at SSTIC in 2012 3, Fabrice\nDesclaux showed Miasm possibilities. One of the proposed applications was the emulation of\na bootloader.\n\nThe ability to fully emulate a bootloader (until the BIOS interruption) with a framework like\nMiasm gives a sharper control over what’s happening, possibly allow de-obfuscation, and\nuse all the tools developed in Miasm for this task. It becomes for example very simple to\ninstrument the code in order to see the data read/written on the disk, the secrets generated,\netc.\n\nEventually, NotPetya’s bootloader code is succinct, non-obfuscated and extremely simple (it\nruns in real mode, in 16 bits and calls only a few BIOS interruptions), so it is a nice case\nstudy to play with Miasm!\n\n## PC/x86 bootloader\n\n Introduction\n\nWe will only discuss here the inner workings of “old-school” BIOS bootloaders. We will not\ntalk about UEFI\n\n\n-----\n\nOn x86 PCs, when the machine starts, the BIOS loads the first disk sector (named Master\nBoot Record, or MBR) at `0x7C00, and then jumps to this address. The MBR hence`\ncontains the bootloader code. At this moment, the processor only supports 16-bit instructions\nand can only address memory in real mode 4.\n\nAs a reminder, one disk sector contains 512 bytes. Therefore, it is not possible to store a lot\nof code on this sector only. That’s why bootloaders are usually designed in several stages.\nIndeed, the code in the first sector (the first stage) will load the stage 2 code from the hard\ndrive, and then jump into it.\n\nBelow is the MBR’s structure written by NotPetya:\n\n## NotPetya case\n\nNotPetya works exactly this way. The bootstrap code (in green in the figure above) is the\nassembly code below. The code at address `0x7C38 (that we named` `disk_read_stage2 ),`\nwrites data in sectors 2 to 34 (inclusive) in memory at `0x8000, and then jumps to this`\naddress:\n\n\n-----\n\n```\nseg000:7C00 cli\nseg000:7C01 xor ax, ax\nseg000:7C03 mov ds, ax\nseg000:7C05 mov ss, ax\nseg000:7C07 mov es, ax\nseg000:7C09 lea sp, start\nseg000:7C0D sti\nseg000:7C0E mov eax, 32\nseg000:7C14 mov byte ptr ds:word_7C93, dl\nseg000:7C18 mov ebx, 1\nseg000:7C1E mov cx, 8000h\nseg000:7C21 call disk_read_stage2\nseg000:7C24 dec eax\nseg000:7C26 cmp eax, 0\nseg000:7C2A jnz short loc_7C21\nseg000:7C2C mov eax, dword ptr ds:8000h\nseg000:7C30 jmp far ptr 0:8000h\n\n## Emulation with Miasm\n\n Installation\n\n```\nThe system used for these tests is Linux-based. Windows 10 users should be able to make it\nwork by using Windows Subsystem for Linux (WSL), by installing for example Ubuntu using\nthe Windows Store .5\n\nWe recommend using the version of Miasm specified in the `README file from the GitHub`\nrepository. At the time of writing lines, the version used is v0.1.1. To recover this specific\nversion, do:\n```\n$ git clone --depth=1 --branch=v0.1.1 https://github.com/cea-sec/miasm/\n\n```\nWe use the LLVM-based Miasm JIT engine, which needs the `llvmlite python package.`\nOther needed dependencies are installable directly through the provided\n```\nrequirements.txt file:\n$ cd /path/to/src && pip install -r requirements.txt\n\n```\nThen just install Miasm:\n```\n$ cd /path/to/miasm && pip install -r requirements.txt && python ./setup.py install\n\n## Implementation\n\n```\nAll the techniques described in this article can be tried thanks to the `src/emulate_mbr.py`\nscript in the aforementioned GitHub repository.\n\nMultiple options are provided, some of them could be used to win some time during your\nexperiments:\n\n\n-----\n\n```\n   --dry : simulates the success of disk writings, but actually writes nothing.\n   --skip-encryption : the encryption function (which is the hottest one) will be ignored\n\n```\n(actually transforming it into a function that does nothing).\n```\n   --verbose-bios-data : dumps log messages from our BIOS implementation, with a\n\n```\ndump of read and written disk data.\n```\n   --verbose-bios : same as --verbose-bios-data, without the read and written\n\n```\ndisk data.\n\nThe `--help flag can be used to have a more detailed list of available options.`\n\nThe activation of Miasm’s logs can considerably slow down the performances of the overall\nscript. The `--log-miasm-newblocks option only dumps blocks that have never been`\n“jitted” by Miasm.\n\n## Creation of a test disk\n\nWe performed our tests with virtual machines running Windows XP and Windows 10. The\nunderlying hypervisor does not matter (VMWare, VirtualBox), as long as the disk created has\na fixed size and is using VMDK. The emulation of the bootloader is done directly on the\nvirtual machine’s disk. An advantage to this method is that there is no need to extract the\nbootloader from the original malware DLL or from the generated VMDK.\n\nEmulation scenario\n\nThe test scenario is the following:\n\n1. voluntary infection of the virtual machine with NotPetya\n2. wait for at least 10s (the machine shouldn’t reboot by itself, or the bootloader will\n\nactually launch its encryption code)\n3. shutdown the virtual machine: the MBR has been replaced\n4. run the emulation: the MFT is encrypted by the bootloader which then displays the\n\nransom\n\n\n-----\n\nIf your virtual machine is not using a flat VMDK representation, you can convert it using\nQEMU:\n```\n$ qemu-img convert -f vmdk mydisk.vmdk -O raw mydisk.raw\n\n```\nWe also give a test image in the aforementioned Git repository (file `disk.raw.bz2 ). Once`\nunzipped, it is a 1GB file, and contains a simple NTFS partition with some test files.\n\nWe can now emulate the NotPetya bootloader. In order to do this, we need to emulate a\nBIOS capable of:\n\nreading/writing disk sectors\nshowing characters on the screen\ncapturing key strokes\nbooting on an MBR (“light” boot/reboot)\n\nWe are going to see how to implement this using Miasm.\n\n## System abstraction\n\nWe implement an abstraction of a simple system as seen by the BIOS. It contains:\n\na virtual disk (the `HardDrive class)`\na video screen, which goes through a classical Unix terminal, using the `stdout pipe`\na keyboard, which uses the `stdin pipe to gather key strokes (functions in`\n```\n   async_kb.py )\n\n```\nAbstraction is implemented in the `System class, of which one instance is used during the`\nemulation. This instance is initialized alongside the Miasm VM.\n\n## Miasm virtual machine initialization\n\nAs explained in the introduction, the MBR code is loaded and executed by the BIOS at the\naddress `0x7C00 . Then, this code will load and write its second stage at the address`\n```\n0x8000 . The left space is dedicated to the stack. It begins at the address 0x500 and ends\n\n```\nat the address `0x07C00 . Therefore, the corresponding space is`\n```\n[0x00000500:0x00007BFF] .\n\n```\nFirst, we need to declare these memory spaces to the Miasm virtual machine:\n\n\n-----\n\n```\nHD0 HardDrive(hd_path)\nsys_ = System([HD0])\nmbr = HD0.read_sector(0)\nstage1_addr = 0x07C00\nstage2_addr = 0x08000\njitter.vm.add_memory_page(stage1_addr, PAGE_READ | PAGE_WRITE | PAGE_EXEC, mbr,\n\"NotPetyaS1\")\njitter.vm.add_memory_page(stage2_addr, PAGE_READ | PAGE_WRITE | PAGE_EXEC,\n\"\\x00\"*SECTOR_LEN*32, \"NotPetyaS2\")\njitter.vm.add_memory_page(0x500, PAGE_READ | PAGE_WRITE, \"\\x00\"*(0x7C00-0x500+1),\n\"Stack\")\n# Pretty print of the memory layout\nprint(jitter.vm)\n\n```\nNow, the memory layout of the Miasm virtual machine is the following:\n```\nAddr        Size        Access Comment \n0x500       0x7700       RW_  Stack \n0x7C00       0x200       RWX  NotPetyaS1 \n0x8000       0x4000       RWX  NotPetyaS2\n\n```\nNotPetya loads 32 sectors from the disk to the memory when executing the first stage. This\nis why the allocated memory for the second stage is 32 sectors long (32*512 bytes).\n\n## BIOS interruption handling in Miasm\n\nMiasm allows us to specify an interruption handler which will be called whenever an `INT`\ninstruction is executed. To do so, we have to tell Miasm to call our BIOS interruption handler\n```\nexception_int with the help of add_exception_handler of the current used jitter:\njitter.add_exception_handler(EXCEPT_INT_XX, lambda jitter: exception_int(jitter,\nsys_))\n\n## Interruption support\n\n```\nNow, we have to implement the different BIOS interruption handlers. We can split them into\nfour main families :\n```\n   INT 10h : access to the screen (write characters, change colors…),\n   INT 13h : access to the disk (read/write sectors, get disk geometry…),\n   INT 16h : access to the keyboard (read keystroke…),\n   INT 19h : boot on the disk’s MBR.\n\n### INT 13h\n\n```\nHere is an example of the `INT 13h interruption, with the` `0x43 code function ( Extended`\n```\nRead Sectors From Drive ). This code implements the instruction to load multiple sectors\n\n```\nfrom the disk to the memory:\n\n\n-----\n\n```\n@func(disk_interrupts, 0x42)\ndef extended_read_sectors(jitter, sys_):\n  drive_idx = get_xl(jitter.cpu.DX)\n  print \"Extended read sectors, drive idx 0x%x\" % drive_idx\n  dap = jitter.vm.get_mem((jitter.cpu.DS << 4)+jitter.cpu.SI, 16)\n  dap_size, _, num_sect, buff_addr, abs_sect = struct.unpack(\"<BBHIQ\", dap)\n  hd = sys_.hd(drive_idx)\n  print(\" Read %d sectors from sector %d\" % (num_sect, abs_sect))\n  size = num_sect * SECTOR_LEN\n  data = hd.read(abs_sect * SECTOR_LEN, size)\n  jitter.cpu.cf = 0 # No error\n  # AL is the number of sectors read\n  # AH is the return code, 0 = successful completion\n  jitter.cpu.AX = set_16bit_reg(low=int(len(data) / SECTOR_LEN), high=0)\n  jitter.vm.set_mem(buff_addr, data)\n\n```\nNote: this Python code doesn’t include error management for readability reasons. The `sys_`\nobject is the system abstraction explained in System abstraction.\n\nSectors can be loaded from disk in two different ways by using a different kind of addressing\nmechanism for the same `INT 13h interruption:`\n\n1. CHS (Cylinder, Head, Sector) addressing mechanism, used by the `02h / 03h codes.`\n\nIt can read/write one or many sectors by specifying the index of the cylinder and the\nhead,\n\n2. LBA (Logical Bloc Addressing) addressing mechanism, used by the `42h / 43h codes.`\n\nIt can read/write one or several sectors by specifying the corresponding sector in a\nabsolute way, i.e. by specifying the offset from the first sector number on the disk\nregardless of heads/cylinders.\n\nNotPetya uses the LBA addressing mechanism. This method needs to fill a DAP (Disk\nAddress Packet) structure. This structure describes which sectors to read/write and where to\nread/write them into live memory.\n\nOne can see that an extended LBA structure exists to read or write multiple sectors at the\nsame time:\n\n0 1 Packet size\n\n1 1 Zeroed field\n\n2 2 Number of sectors to load\n\n4 4 Buffer address to load sectors to (seg:off)\n\n\n-----\n\n8 8 Absolute offset of the first sector to read\n\nTo sum up:\n\n1. the DAP is parsed,\n2. data is read from the virtual disk,\n3. the read data is stored in the corresponding memory page of the instantiated Miasm\n\nvirtual machine.\n\nThe writing mechanism is the exact opposite: the specified buffer address in the DAP\ncontains the data to write.\n\n### INT 19h\n\nThe second chosen example is the `INT 19h interruption (diskboot). It reboots the machine`\n\n67 and is used in two locations :\n\n1. at address `0x892E, which is called if a fatal error occurs,`\n2. at address `0x820D, when the machine reboots after the MFT encryption.`\n\nThe `INT 19h interruption is called right after the POST (Power On Self Test) procedure by`\nthe BIOS. After that, the MBR code is loaded into live memory at `Ox7C00 . Then, the BIOS`\njumps at this address.\n\nSo we can say here that it is used as a sort of soft reboot because the reboot is not a\ncomplete one. This instruction is part of the boot process after BIOS execution. Some BIOS\ncan handle boot medium priority while others just loop over available mediums and boot on\nthe first one it can.\n\nHere, we will emulate this instruction simply by loading again the MBR code into the memory\npage dedicated to it (stage 1), and then jump onto it (at address `0x7C00 ):`\n```\ndiskboot_interrupts = FuncTable(\"INT 19h (diskboot)\")\n@func(diskboot_interrupts, 0x02)\ndef reboot(jitter, sys_):\n  # Here, we assume only one bootable disk (index 0)\n  hd = sys_.hd(0)\n  mbr = hd.read_sector(0)\n  jitter.vm.set_mem(0x7C00, mbr)\n  jitter.pc = 0x7C00\n\n## For a few more hacks…\n\n```\nThe `STI (Set Interrupt Flag) instruction is used at address` `0x7C0D . It can activate masked`\ninterruptions (flag `IF and offset 9 of the` `FLAGS register). This flag doesn’t have any effect`\non non-maskable interruptions. Because hardware interruptions are fully emulated, Miasm\n\n\n-----\n\ndoesn t contain (legitimately) semantics for this instruction.\n\nSo we simply decided to ignore it by setting a breakpoint at its corresponding address:\n```\njitter.add_breakpoint(0x7C0D, handle_sti)\n\n```\nThen, we redirect the execution flow to the next instruction. Because this instruction is only 1\nbyte long, a simple incrementation of the program counter does the trick:\n```\ndef handle_sti(jitter):\n  jitter.pc += 1\n  return True\n\n## Yippie kay yay motherfucker !\n\n```\nNow that the useful handlers are implemented and the MBR code is loaded and mapped in\nMiasm virtual machine, emulation of NotPetya can begin:\n```\njitter.init_run(stage1_addr)\njitter.continue_run()\n\n```\nIf the `--verbose-bios-data flag is set (see` Implementation), output of the script prints the\ncontent of the various read and write operations on the disk. For example, here is the content\nof the second sector (of the 32 loaded sectors by the bootloader at `0x8000 ):`\n```\nExtended read sectors, drive idx 0x0\n Read 1 sectors from sector 2\n00000000: 50 FF 76 04 E8 91 0A 83 C4 0A E8 3B 07 CD 19 5E P.v........;...^\n00000010: C9 C3 6A 0E E8 39 07 5B 68 70 9C E8 C0 03 5B C3 ..j..9.[hp....[.\n00000020: C8 04 04 00 56 6A 00 6A 01 6A 00 6A 20 8D 86 FC ....Vj.j.j.j ...\n00000030: FD 50 8A 46 06 50 E8 21 0A 83 C4 0C 6A 00 68 8E .P.F.P.!....j.h.\n[...]\n\n```\nThe loaded code matchs stage 2. Also, one can easily see the content loaded from sector\n32:\n\n\n-----\n\n```\nExtended read sectors, drive idx 0x80\n Read 1 sectors from sector 32\n00000000: 00 AA 92 E7 82 11 15 D3 20 96 A7 75 51 C0 36 08 ........ ..uQ.6.\n00000010: E8 65 42 8C 73 9F 06 53 77 CB C5 95 60 C8 38 69 .eB.s..Sw...`.8i\n00000020: 9B 0D A4 99 E0 13 12 30 79 31 4D 7A 37 31 35 33 .......0y1Mz7153\n00000030: 48 4D 75 78 58 54 75 52 32 52 31 74 37 38 6D 47 HMuxXTuR2R1t78mG\n00000040: 53 64 7A 61 41 74 4E 62 42 57 58 00 00 00 00 00 SdzaAtNbBWX.....\n00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n000000A0: 00 00 00 00 00 00 00 00 00 48 34 79 5A 73 77 56 .........H4yZswV\n000000B0: 54 64 43 6B 43 77 55 68 72 31 4D 52 6D 4A 65 69 TdCkCwUhr1MRmJei\n000000C0: 76 31 34 46 4B 39 6A 5A 6A 4D 36 36 4C 44 79 65 v14FK9jZjM66LDye\n000000D0: 71 52 4C 64 6B 38 53 58 53 53 73 53 53 45 78 34 qRLdk8SXSSsSSEx4\n000000E0: 44 51 57 4E 47 00 00 00 00 00 00 00 00 00 00 00 DQWNG...........\n000000F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n[...]\n000001F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...............\n\n```\nThis sector is where NotPetya stores data. According to the description done in MISC 805\nn°93, we can deduct its content :\n```\n   0x00 is the encrypted disk flag,\n\n```\n```\nAA 92 E7 82 11 15 D3 20 96 A7 75 51 C0 36 08 E8 65 42 8C 73 9F 06 53\n\n```\n```\n   77 CB C5 95 60 C8 38 69 is the 32 bytes long Salsa20 key,\n   0D A4 99 E0 13 12 30 79 is a 8 bytes long nonce,\n\n```\nnext data is the random string printed when the malware was executed on Windows at\nthe beginning.\n\nAfter the encryption is done by the bootloader, key and nonce are erased from disk with 32\nsuccessive writings of zeros.\n\nMoreover, we can see that sector 35 is used to store the number of total encrypted MFT\nentries. For example, here is the content of sector 35 right after the MFT header encryption:\n```\nExtended write sectors, drive idx 0x80\n Write 1 sectors at offset 35 (from memory at 0x5C74)\n00000000: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n[...]\n\n## Retrieving secrets in memory\n\n```\nOne of the advantages of emulation is the ability to easily analyze memory pages. In our\ncase, it is possible to retrieve the Salsa20 key used, even after the MFT table has been\nencrypted (during the “false chkdsk”, see NotPetya).\n\n\n-----\n\nIn fact, as explained in section INT 19h; after the encryption is over, the bootloader executes\na “soft reboot” with the help of the interruption `INT 19h . It doesn’t reboot completely the`\ncomputer therefore the BIOS is not executed again. The data present in memory before the\n“soft reboot” is not tampered with. If the computer goes through hard reboot or reset, there\nwould be great chances for the BIOS to overwrite data present on the stack with its own,\nincluding the precious Salsa20 key.\n\nSo, if the computer has not been rebooted or reset, it is pretty interesting to see if the\nSalsa20 key is still in memory. To do so, we simply read the key written in sector 32 (see this\nsection) and store its value. Then, we place a breakpoint on the instructions in charge to\nshow the ransom message, at address `0x85AF :`\n```\nkey = HD0.read(32*SECTOR_LEN + 1, 32) \njitter.add_breakpoint(0x85AF, functools.partial(find_key_in_mem, key=key))\n\n```\nThe `find_key_in_mem function browses the virtual machine memory to find the key stored`\nin the previous step:\n```\ndef find_key_in_mem(jitter, key):\n  # Find if the salsa20 key is still in memory!\n  mem = jitter.vm.get_all_memory()\n   print >>sys.stderr, \"\\n[+] Looking for key %s in memory...\" % key.encode(\"hex\")\n  for addr,v in mem.iteritems():\n    idx = v['data'].find(key)\n    if idx == -1:\n      continue\n    print >>sys.stderr, \"[+] Key found at address %s!\" % hex(addr + idx)\n    break\n  else:\n    print >>sys.stderr, \"[-] Key not found in memory!\"\n  return True\n\n```\nThis operation can be activated in the script using `--hook=find_key option, like this:`\n```\n$ python ./emulate-mbr.py --hook=find_key disk.raw\nRepairing file system on C:\n[... encryption happends here ...]\n[+] Looking for key [your salsa20 key] in memory...\n[+] Key found at address 0x674a!\n\n```\nTo speed up the process, the `--skip-encryption option can be used (see`\nImplementation). Be careful, even if this option is used, the encryption flag in sector 32 is still\nset. The flag `--dry prevents this behaviour.`\n\nBecause we know the address where the key is stored ( 0x674A ), we can put a breakpoint\non a write access at this location, allowing us to know which part of the bootloader writes this\nkey:\n\n\n-----\n\n```\ndef print_ip(jitter):\n  print(hex(jitter.pc))\n  return False\njitter.exceptions_handler.callbacks[EXCEPT_BREAKPOINT_MEMORY] = []\njitter.add_exception_handler(EXCEPT_BREAKPOINT_MEMORY, print_ip)\njitter.vm.add_memory_breakpoint(0x674a, 1, PAGE_WRITE)\n\n```\nBecause there is no ASLR or equivalent mechanism, this address will always be the same!\n\n## Bootloader modification to decrypt the MFT\n\nIf we have a mechanism to write directly into the memory of the machine (for example by\nusing a PCI Express card 8, or other interfaces like FireWire or Thunderbolt 9), it is possible\nto decrypt the MFT data. The attack consists in patching the bootloader memory so that its\nuses the remaining key on the stack. This section simulates this attack using Miasm.\n\n\nTo do so, we will inject some code at address `0x82A8 . This function checks that the key`\nentered is the expected one. Given that it has been erased from the hard drive, and that the\nransom text is completely random 10, the bootloader has in theory no way to know if the\nentered key is the right one. This function will always return 0 (incorrect key). The injected\ncode will copy the key Salsa20 from the `0x674A address to a specific location on the stack,`\nso that the decryption function at `0x835A will use this key. We will then jump on this`\nfunction.\n\nAssociated assembly code is the following:\n```\n  ; Save registers on the stack\n  PUSHA\n  LEA DI, WORD PTR [BP-0x44]\n  LEA BX, WORD PTR [key_addr]\n  XOR CX,CX\n  ; Copy the key that remains on the stack to [bp-0x44]\nloop:\n  MOV EAX, DWORD PTR [BX]\n  MOV DWORD PTR [DI], EAX \n  ADD DI, 4\n  ADD BX, 4\n  INC CX\n  CMP CX,8\n  JNZ loop\n  ; Restore previously saved registers\n  POPA\n  ; Jump on the decryption function (CS:OFFSET => using an absolute address)\n  JMP 0000:0x835A\n\n```\nWe use Miasm to assemble it using the following function:\n\n\n-----\n\n```\ndef asm_shellcode(asm, labels None):\n  machine = Machine(\"x86_16\")\n  symbol_pool = asmblock.AsmSymbolPool()\n  # Assemble\n  blocks, symbol_pool = parse_asm.parse_txt(machine.mn, 16, asm, symbol_pool)\n  # Set custom labels\n  if not labels is None:\n    for name,value in labels.iteritems():\n      sym = symbol_pool.getby_name(name)\n      symbol_pool.set_offset(sym, value)\n  # Resolve all the labels\n  patches = asmblock.asm_resolve_final(machine.mn,\n                     blocks,\n                     symbol_pool)\n  # Patch the final code with the label values\n  shellcode = StrPatchwork()\n  for offset, raw in patches.items():\n    shellcode[offset] = raw\n  return str(shellcode)\n\n```\nLet’s take a look at this function. The code is first assembled using an x86 16-bit assembler.\nGiven labels are then associated to concrete values using the `symbol_pool.set_offset`\nfunction. Remaining labels (in our case `loop ) are resolved with the`\n```\nasmblock.asm_resolve_final function, which returns assembly code for each block. We\n\n```\nfinally use the `StrPatchwork function to assemble the final “shellcode”.`\n\nThe `read_key_and_patch function loads the key in memory, dumps it and writes the`\nfreshly assembled code in memory:\n```\ndef read_key_and_patch(jitter):\n  # Key is still in the stack, at 0x674A. You can find this value by activating the\n  # find_key_in_mem breakpoint!\n  key_addr = 0x674A\n  key = jitter.vm.get_mem(key_addr, 32)\n  print >>sys.stderr, \"\\n[+] Key from memory: %s\" % key.encode(\"hex\")\n  # Assemble our \"shellcode\" thanks to Miasm!\n  shellcode = \"\"\"\n...\n  \"\"\"\n  shellcode = asm_shellcode(shellcode, {\"key_addr\": key_addr})\n  # Patch the bootloader in memory to decrypt using the key\n  jitter.vm.set_mem(0x82A8, shellcode)\n  return True\n\n```\nThe remaining thing to do is to put a breakpoint at the same address as in section Retrieving\nsecrets in memory ( 0x85AF ) to call this function:\n\n\n-----\n\n```\njitter.add_breakpoint(0x85AF, read_key_and_patch)\n\n```\nEverything is now set up. When the bootloader asks for the decryption key, user will just\nhave to press `enter .` `--hook=patch_bootloader flag of the` `emulate_mbr script`\nperforms this attack.\n\nIt is worth mentioning that [we actually tried this at](https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf) [Synacktiv’s headquarters using](https://synacktiv.com/)\nvulnerabilities in HP’s iLO4 to gather the Salsa20 key from memory, patch the bootloader\nand decrypt MFT data.\n\n## Encryption keystream study\n\nThe encryption algorithm used is Salsa20 stream cipher. The general principle is: a random\ndata flow based on a key - commonly called the keystream - is generated, and this stream is\nXORed with the data which will be encrypted. An advantage of stream ciphers is that the\ndata to be encrypted do not need to be padded. On the other hand, one needs to be careful\nnot to use the same parts of this stream twice.\n\nData encryption with Salsa20\n\nWe can verify this using Miasm, by looking at the data before and after encryption, and by\nshowing their XOR difference.\n\nIn order to do this, we already know how to put breakpoints. The beginning of the encryption\nfunction is at address `0x9798, and the end at address` `0x9877 . We are going to out the`\nfirst breakpoint just after ‘enter instruction, and the second just before leave`\nstatement, in order to have the stack properly aligned to recover data before and after\nencryption. The associated code is the following:\n\n\n-----\n\n```\n_last_buf None\ndef encrypt_start(jitter, options):\n  global _last_buf\n  buf_ptr = upck16(jitter.vm.get_mem((jitter.cpu.SS << 4) + jitter.cpu.BP + 0xC,\n2))\n  buf_size = upck16(jitter.vm.get_mem((jitter.cpu.SS << 4) + jitter.cpu.BP + 0xE,\n2))\n  _last_buf = jitter.vm.get_mem((jitter.cpu.DS << 4) + buf_ptr, buf_size)\n  return True\ndef encrypt_end(jitter, options):\n  global _last_buf\n  buf_ptr = upck16(jitter.vm.get_mem((jitter.cpu.SS << 4) + jitter.cpu.BP + 0xC,\n2))\n  buf_size = upck16(jitter.vm.get_mem((jitter.cpu.SS << 4) + jitter.cpu.BP + 0xE,\n2))\n  encr_buf = jitter.vm.get_mem((jitter.cpu.DS << 4) + buf_ptr, buf_size)\n  keystream = ''.join(chr(ord(a)^ord(b)) for a,b in\nzip(_last_buf,encr_buf)).encode(\"hex\")\n  keystream = ' '.join(keystream[i:i+4] for i in xrange(0,len(keystream),4))\n  print >>sys.stderr, \"Keystream for next 2 sectors: %s\" % keystream\n  return True\njitter.add_breakpoint(0x979C, functools.partial(encrypt_start, options=options))\njitter.add_breakpoint(0x9876, functools.partial(encrypt_end, options=options))\n\n```\nThe `--dump-keystream flag of the` `emulate_mbr script enables this.`\n\nBy looking at the output, we can see that between two sectors ( 2*512 bytes), the\nkeystream is only shifted by two bytes, instead of the normally required `2*512 bytes. This`\nshift is schematized in the image below:\n\nWe can also see that on a screenshot of the output of the `emulate_mbr script below:`\n\n\n-----\n\nScreenshot of the keystream\n\nThus, parts of the keystream are reused between sectors, which may help to recover some\nof its original data.\n\nIndeed, if we consider `p to be the clear text, k the keystream and` `c the encrypted text,`\nthen the encryption function `E is defined as E (p) = p xor k = c . A part of the MFT`\nstructures being invariant and known, it is therefore possible, in two sectors, to find part of\nthe keystream used for these two sectors. This one is reused for the two following sectors by\nbeing simply shifted by two bytes, so some of the clear text from these other areas can be\nfound.\n\nThis vulnerability in the Salsa20 implementation of the bootloader has been exploited by\n[CrowdStrike to recover a large portion of MFT’s original data (between 98.10% and 99.97%](https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/)\ndepending on the method).\n\n## Conclusion\n\nEmulation of the NotPetya bootloader code allows the verification of various assumptions\nand the understanding, in a very tangible way, of the different steps related to the encryption\nof MFT entries. In addition, it allows to easily find the bias in the Salsa20 keystream\nimplementation (without having to statically reverse the algorithm), or to simulate the\nrecovery of the key, which remains in memory after the encryption.\n\nThis article only shows a small subset of Miasm’s possibilities, and we hope that the\napproach adopted in this article will encourage uninitiated readers to try and play with it :).\n\n## Acknowledgments\n\n\n-----\n\nWe would like to thank gapz for his initial encouragement. Big thanks also to Camille Mougey\nand Fabrice Desclaux for their help and thorough reviews of this article! Thanks to Thomas\nChauchefoin and zerk for their comments, and to Yseult for her help with the English\ntranslation.\n\n## Appendix: application using vulnerabilities in HP iLO 4\n\n[With Alexandre Gazet & Fabien Perigaud, we spent some time in Synacktiv’s offices to](https://twitter.com/0xf4b)\n[combine the attacks described in this article with vulnerabilities they found with](https://github.com/airbus-seclab/ilo4_toolbox) Joffrey\nCzarny on HP iLO 4’s management engine. These vulnerabilities allowed us to read and\nwrite the memory of an infected server stuck at NotPetya’s bootloader stage, so that we were\nable to recover the encryption key and patch the bootloader in order to decrypt the MFT.\n\n[A full write up of the experiment can be read on Airbus seclab website.](https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf)\n\n[1. https://fr.wikipedia.org/wiki/Master_File_Table](https://fr.wikipedia.org/wiki/Master_File_Table) ↩\n\n2. https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs\nemulator.html ↩\n\n[3. https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/](https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/)\n\n↩\n\n[4. https://fr.wikipedia.org/wiki/Mode_r%C3%A9el](https://fr.wikipedia.org/wiki/Mode_r%C3%A9el) ↩\n\n[5. https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10) ↩\n\n[6. https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))](https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))) ↩\n\n[7. http://webpages.charter.net/danrollins/techhelp/0243.HTM](http://webpages.charter.net/danrollins/techhelp/0243.HTM) ↩\n\n8. https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to\n[peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-](https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf)\npeer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf ↩\n\n[9. https://github.com/carmaa/inception](https://github.com/carmaa/inception) ↩\n\n10. https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple\nthreat-file-encryption-mft-encryption-credential-theft/ ↩\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-29 - Emulating NotPetya bootloader with Miasm.pdf"
    ],
    "report_names": [
        "2020-08-29 - Emulating NotPetya bootloader with Miasm.pdf"
    ],
    "threat_actors": [
        {
            "id": "77b28afd-8187-4917-a453-1d5a279cb5e4",
            "created_at": "2022-10-25T15:50:23.768278Z",
            "updated_at": "2025-03-27T02:00:55.5423Z",
            "deleted_at": null,
            "main_name": "Inception",
            "aliases": [
                "Inception Framework",
                "Cloud Atlas"
            ],
            "source_name": "MITRE:Inception",
            "tools": [
                "PowerShower",
                "VBShower",
                "LaZagne"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "7ea1e0de-53b9-4059-802f-485884180701",
            "created_at": "2022-10-25T16:07:24.04846Z",
            "updated_at": "2025-03-27T02:02:10.090459Z",
            "deleted_at": null,
            "main_name": "Patchwork",
            "aliases": [
                "APT-C-09",
                "ATK 11",
                "Capricorn Organisation",
                "Chinastrats",
                "Dropping Elephant",
                "Maha Grass",
                "Quilted Tiger",
                "TG-4410",
                "Thirsty Gemini",
                "Zinc Emerson"
            ],
            "source_name": "ETDA:Patchwork",
            "tools": [
                "AndroRAT",
                "Artra Downloader",
                "ArtraDownloader",
                "AutoIt backdoor",
                "BADNEWS",
                "BIRDDOG",
                "Bahamut",
                "Bozok",
                "Bozok RAT",
                "Brute Ratel",
                "Brute Ratel C4",
                "CinaRAT",
                "Crypta",
                "ForeIT",
                "JakyllHyde",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "NDiskMonitor",
                "Nadrac",
                "PGoShell",
                "PowerSploit",
                "PubFantacy",
                "Quasar RAT",
                "QuasarRAT",
                "Ragnatela",
                "Ragnatela RAT",
                "SocksBot",
                "TINYTYPHON",
                "Unknown Logger",
                "WSCSPL",
                "Yggdrasil"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c81067e0-9dcb-4e3f-abb0-80126519c5b6",
            "created_at": "2022-10-25T15:50:23.285448Z",
            "updated_at": "2025-03-27T02:00:55.42906Z",
            "deleted_at": null,
            "main_name": "Patchwork",
            "aliases": [
                "Hangover Group",
                "Dropping Elephant",
                "Chinastrats",
                "Operation Hangover"
            ],
            "source_name": "MITRE:Patchwork",
            "tools": [
                "NDiskMonitor",
                "QuasarRAT",
                "BackConfig",
                "TINYTYPHON",
                "AutoIt backdoor",
                "PowerSploit",
                "BADNEWS",
                "Unknown Logger",
                "Socksbot"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536142,
    "ts_updated_at": 1743041316,
    "ts_creation_date": 1653704171,
    "ts_modification_date": 1653704171,
    "files": {
        "pdf": "https://archive.orkl.eu/9d2cf78e59a31d275ce6d78c6d146b2c46252b1e.pdf",
        "text": "https://archive.orkl.eu/9d2cf78e59a31d275ce6d78c6d146b2c46252b1e.txt",
        "img": "https://archive.orkl.eu/9d2cf78e59a31d275ce6d78c6d146b2c46252b1e.jpg"
    }
}