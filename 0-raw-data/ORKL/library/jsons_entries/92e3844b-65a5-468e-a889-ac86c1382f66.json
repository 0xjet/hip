{
    "id": "92e3844b-65a5-468e-a889-ac86c1382f66",
    "created_at": "2023-01-12T14:59:32.806784Z",
    "updated_at": "2025-03-27T02:05:30.871698Z",
    "deleted_at": null,
    "sha1_hash": "3a09ee6fd90dfe6272b447a00dae1fddc5e4c260",
    "title": "2022-12-06 - Technical Analysis of DanaBot Obfuscation Techniques",
    "authors": "",
    "file_creation_date": "2022-12-29T00:28:28Z",
    "file_modification_date": "2022-12-29T00:28:28Z",
    "file_size": 1743701,
    "plain_text": "# Technical Analysis of DanaBot Obfuscation Techniques\n\n**[zscaler.com/blogs/security-research/technical-analysis-danabot-obfuscation-techniques](https://www.zscaler.com/blogs/security-research/technical-analysis-danabot-obfuscation-techniques)**\n\n## Key Points\n\nDanaBot is a malware-as-a-service platform discovered in 2018 that is designed to\nsteal sensitive information that may be used for wire fraud, conduct cryptocurrency\ntheft, or perform espionage related activities\n\nThe malware is heavily obfuscated which makes it very difficult and time consuming to\nreverse engineer and analyze\nZscaler ThreatLabz has reverse engineered the various obfuscation techniques used\nby DanaBot and developed a set of tools using IDA Python scripts to assist with binary\nanalysis\n\n[DanaBot, first discovered in 2018, is a malware-as-a-service platform that threat actors use](https://malpedia.caad.fkie.fraunhofer.de/details/win.danabot)\nto steal usernames, passwords, session cookies, account numbers, and other personally\nidentifiable information (PII). The threat actors may use this stolen information to commit\nbanking fraud, steal cryptocurrency, or sell access to other threat actors.\n\n[While DanaBot isn’t as prominent as it once was, the malware is still a formidable and](https://www.zscaler.com/blogs/security-research/spike-danabot-malware-activity)\n[active threat. Recently, version 2646 of the malware was spotted in the wild and also a](https://www.zscaler.com/blogs/security-research/danabot-launches-ddos-attack-against-ukrainian-ministry-defense)\n[researcher tweeted screenshots of Danabot’s advertisement website shown in Figure 1.](https://twitter.com/CryptoInsane/status/1592540701015052290)\n\n\n-----\n\n_Figure 1: DanaBot’s advertisement website_\n\nUnfortunately, the DanBot developers have done a very good job of obfuscating the\nmalware code. Therefore, it is very difficult and time consuming process to to reverse\nengineer and analyze. This is a companion blog post to a set of IDA Python scripts that\n[Zscaler ThreatLabz is releasing on our Github page. The goal of the scripts is to help peel](https://github.com/threatlabz/tools/tree/main/danabot)\naway some of the layers of DanaBot’s obfuscations and inspire additional research into not\nonly the obfuscation techniques, but the malware itself.\n\n## Technical Analysis\n\nThe following sections summarize the numerous techniques that the DanaBot developers\nhave implemented to obfuscate the malware binary code.\n\n## Junk Byte Jumps\n\nOne of the first anti-analysis techniques that DanaBot employs is a “junk byte jump”\ninstruction. This is an anti-disassembly technique where a jump instruction will always jump\nover a junk byte. The junk byte is skipped during normal program execution, but causes IDA\nPro to display an incorrect disassembly. An example of this technique is shown in Figure 2:\n\n\n-----\n\n_Figure 2: An example of a junk byte jump_\n\nThe _[01_junk_byte_jump.py IDA Python script searches for junk byte jump patterns and](https://github.com/threatlabz/tools/blob/main/danabot/01_junk_byte_jump.py)_\npatches them with NOP instructions. This operation fixes IDA Pro’s disassembly as shown\nin Figure 3.\n\n_Figure 3: An example of a patched junk byte jump_\n\n## Dynamic Returns\n\nThe next anti-analysis technique is a “dynamic return” operation. This technique calculates\na new return address at the end of a function, causing a change in the program’s control\nflow. In DanaBot’s implementation, they are used to “extend” a function–exposing additional\nhidden code. An example of a dynamic return is shown in Figure 4.\n\n_Figure 4: An example of a dynamic return_\n\n\n-----\n\nUsing the _[02_dynamic_return.py IDA Python script, these dynamic returns can be patched,](https://github.com/threatlabz/tools/blob/main/danabot/02_dynamic_return.py)_\nthe functions extended, and the hidden code exposed. An example of this is shown in\nFigure 5.\n\n_Figure 5: An example of a patched dynamic return_\n\n## Stack String Deobfuscation Preparation and Code Re-analysis\n\nBefore moving on to additional DanaBot anti-analysis techniques, we’ve included three IDA\nPython scripts:\n\n_[03_uppercase_jumps.py](https://github.com/threatlabz/tools/blob/main/danabot/03_uppercase_jumps.py)_\n_[04_letter_mapping.py](https://github.com/threatlabz/tools/blob/main/danabot/04_letter_mapping.py)_\n_[05_reset_code.py](https://github.com/threatlabz/tools/blob/main/danabot/05_reset_code.py)_\n\nThe first two scripts are preparation steps to help with stack string deobfuscation described\nin a later section. The first script patches out a code pattern that is used to uppercase\nletters (this removes a small function basic block that interferes with stack string\nreconstruction) and the second script renames variables that store the letters used in stack\nstrings.\n\nBefore running the third script, check that IDA Pro’s ”Options->Compiler…” is set to “Delphi”\n(see Figure 6.)\n\n\n-----\n\n_Figure 6: IDA Pro s Compiler options_\n\nSince the previous scripts patched a lot of existing code and exposed a bunch of new code,\nthe _[05_reset_code.py script helps reset and re-analyze the modified code in IDA Pro to get](https://github.com/threatlabz/tools/blob/main/danabot/05_reset_code.py)_\na cleaner IDB database. Once the script and analysis completes, some manual clean up\nmay be required. Our general method is:\n\nSearch → Sequence of bytes…\nSearch for the standard function prolog: 55 8B EC\nSort by Function\nFor each result without a defined function:\n\nRight click → Create function…\nLook for any addresses that are causing issues in the Output window\nRight click → Undefine\nRight click → Code\n\n## Junk StrAsg and StrCopy Function Calls\n\nDanaBot adds a lot of junk code to slow down and complicate reverse engineering. One of\nthe junk code patterns is adding extraneous StrAsg and StrCopy function calls. These\nfunctions are part of the standard Delphi library and are used to assign or copy data\nbetween variables. Figure 7 shows an example snippet of code with a number of these\ncalls. If we trace the variable arguments we can see that they are usually assigned to\nthemselves or a small set of other variables that aren’t used in actual malware code.\n\n\n-----\n\n_Figure 7: Example of junk StrAsg and StrCopy function calls_\n\nThe IDA Python script _[06_fake_UStrLAsg_and_UStrCopy.py tries to find and patch these](https://github.com/threatlabz/tools/blob/main/danabot/06_fake_UStrLAsg_and_UStrCopy.py)_\njunk calls. Figure 8 shows the result in the example from Figure 7.\n\n\n-----\n\n_Figure 8: Example of patched junk StrAsg and StrCopy function calls_\n\n## Stack Strings\n\nThe next obfuscation method is DanaBot’s version of creating “stack strings”. The malware\nassigns letters of the alphabet to individual variables and then uses those variables,\npointers to those variables, and various Delphi character/string handling functions to\nconstruct strings one character at a time. Figure 9 is an example construction of the string\n“wow64.dll”.\n\n\n-----\n\n_Figure 9: Example stack string of “wow64.dll”_\n\nThese stack strings litter most of the malicious functions in DanaBot and very easily lead to\nreverse engineering fatigue. On top of that, while some of the constructed strings are used\nfor malware purposes, most of them turn out to be junk strings. Figure 10 is a snippet of\noutput from a script that will be introduced below. As can be seen in the figure, most of the\nstrings are random DLL, executable, and Windows API names.\n\n\n-----\n\n_Figure 10: Example script output showing junk strings_\n\nThe best way to extract these stack strings is by emulating the construction code, but due to\nthe following reasons we experimented with another deobfuscation technique:\n\nThere are thousands of these strings\nThere are not clear start/end patterns to automatically extract the construction code\nThey rely on standard Delphi functions which aren’t particularly easy to emulate\nMost of them are junk strings\nThe sheer amount of construction code hinders malware analysis the most\n\n[The goal of the IDA Python scripts 07_stack_string_letters_to_last_StrCatN_call.py and](https://github.com/threatlabz/tools/blob/main/danabot/07_stack_string_letters_to_last_StrCatN_call.py)\n_[08_set_stack_string_letters_comments.py is not to extract a wholly accurate stack string,](https://github.com/threatlabz/tools/blob/main/danabot/08_set_stack_string_letters_comments.py)_\nbut enough of the string to determine whether the string is junk or not. After some trial and\nerror experimentation, the scripts also try their best to remove the stack string construction\ncode to allow for much easier analysis. If the string turns out to be legitimate, the original\nconstruction code is saved as comments so a proper extraction of the string can be done\nif/when needed.\n\n## Empty Loops and Junk Math Loops\n\nAfter removing the junk StrAsg and StrCopy function calls and the stack strings, there will\n[be a bunch of empty loops. The IDA Python script 09_empty_loops.py can be used to](https://github.com/threatlabz/tools/blob/main/danabot/09_empty_loops.py)\nremove these loops. There will also be loops left that just contain junk math code (see\n\n\n-----\n\nFigure 11.) The IDA Python script _[10_math_loops.py will remove these junk code math](https://github.com/threatlabz/tools/blob/main/danabot/10_math_loops.py)_\nloops.\n\n_Figure 11: Example junk math loops_\n\n## Junk Strings and Junk Global Variables\n\nAs we saw in the stack strings section above, there were a lot of DLL, executable, and\nWindows API name based junk strings. These junk strings exist as normal strings as well,\nsee Figure 12 as an example.\n\n_Figure 12: Example junk strings_\n\n\n-----\n\nWhile we haven t found good patterns to automatically remove references to these junk\nstrings, the IDA Python script _[11_rename_junk_variables.py renames them as “junk” to](https://github.com/threatlabz/tools/blob/main/danabot/11_rename_junk_variables.py)_\nease manual analysis.\n\nDanaBot also adds a lot of junk code involving global variables and various math\noperations, see Figure 13 for an example.\n\n_Figure 13: Example junk global variable math_\n\nThe IDA Python script _[12_rename_junk_random_variables.py attempts to locate and](https://github.com/threatlabz/tools/blob/main/danabot/12_rename_junk_random_variables.py)_\nrename these variables as “junk” to help with analysis.\n\n## Miscellaneous Tips and Tricks\n\nBased on our experience reverse engineering DanaBot over the years, we have found the\nfollowing miscellaneous tricks and tips to be helpful. The first is using the Interactive Delphi\nReconstructor (IDR) program to export standard Delphi library function and variable names.\nWe use Tools → MAP Generator and Tools → IDC Generator to export MAP and IDC files.\nWhile IDR creates an IDA IDC script, we don’t use it directly as it degrades the quality of the\n[IDA Pro disassembly/decompilation. Instead, we use the scripts idr_idc_to_idapy.py and](https://github.com/threatlabz/tools/blob/main/danabot/idr_idc_to_idapy.py)\n_[idr_map_to_idapy.py to extract the information from the generated IDC and MAP files and](https://github.com/threatlabz/tools/blob/main/danabot/idr_map_to_idapy.py)_\nuse the output scripts to import the naming information.\n\nDanaBot resolves some of its Windows API functions by hash, so we use OALabs’ HashDB\n[IDA Plugin (which recently added support for DanaBot’s hashing algorithm) to resolve the](https://github.com/OALabs/hashdb/pull/35)\nnames by hash.\n\nFinally, we make liberal use of IDA Pro’s right click → Collapse item feature to hide the\nremaining junk code, especially the renamed junk strings and global variables.\n\n## Before and After Example\n\nAs an overall example, Figure 14 is a screenshot for a section of DanaBot code before the\ndeobfuscation scripts have been applied. The details of the code don’t particularly matter for\nthis discussion, but the snippet shows DanaBot’s initialization of its 455-byte binary\n\n\n-----\n\nstructure used in its initial system information command and control beacon.\n\n_Figure 14: Example of code before deobfuscations_\n\nFigure 15 is an example of the same code snippet after applying the deobfuscation scripts.\n\n\n-----\n\n_Figure 15: Example of code after deobfuscations_\n\n## Conclusion\n\nWhile there is still room for improvement, the DanaBot malware code is much easier to\nanalyze and reason about. Expanding the scope to the entire binary, the deobfuscation\ntechniques significantly reduce the complexity and time spent while reverse engineering the\nmalware. We look forward to making further improvements/additions and welcome other\nresearchers’ contributions to the existing scripts to peel away more layers of DanaBot’s\nobfuscation.\n\n## Zscaler Detection Status\n\n[W32/Danabot](https://threatlibrary.zscaler.com/threats/780213b1-9cc5-4732-9565-9a3a5903adba)\n\n## Cloud Sandbox Detection\n\n\n-----\n\n-----\n\n## Indicators of Compromise\n\n**IOC** **Notes**\n\n8c6224d9622b929e992500cb0a75025332c9cf901b3a25f48de6c87ad7b67114 SHA256\nhash of\nDanaBot\nversion\n2646 main\ncomponent\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-06 - Technical Analysis of DanaBot Obfuscation Techniques.pdf"
    ],
    "report_names": [
        "2022-12-06 - Technical Analysis of DanaBot Obfuscation Techniques.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535572,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1672273708,
    "ts_modification_date": 1672273708,
    "files": {
        "pdf": "https://archive.orkl.eu/3a09ee6fd90dfe6272b447a00dae1fddc5e4c260.pdf",
        "text": "https://archive.orkl.eu/3a09ee6fd90dfe6272b447a00dae1fddc5e4c260.txt",
        "img": "https://archive.orkl.eu/3a09ee6fd90dfe6272b447a00dae1fddc5e4c260.jpg"
    }
}