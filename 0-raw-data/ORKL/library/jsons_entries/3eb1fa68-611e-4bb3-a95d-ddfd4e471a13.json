{
    "id": "3eb1fa68-611e-4bb3-a95d-ddfd4e471a13",
    "created_at": "2023-01-12T15:07:46.645942Z",
    "updated_at": "2025-03-27T02:16:25.849583Z",
    "deleted_at": null,
    "sha1_hash": "9fd5cb7a8d1bd8d8ed9df515f7d0c15df1de063c",
    "title": "2018-02-26 - Anatomy of the Process Environment Block (PEB) (Windows Internals)",
    "authors": "",
    "file_creation_date": "2022-05-28T17:02:44Z",
    "file_modification_date": "2022-05-28T17:02:44Z",
    "file_size": 489761,
    "plain_text": "# Anatomy of the Process Environment Block (PEB) (Windows Internals)\n\n**[ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/](https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/)**\n\nFebruary 26, 2018\n\nThe Process Environment Block (PEB) is a wonderful thing, and I’d be lying if I told you that I\ndidn’t love it. It has been present in Windows since the introduction of the Win2k (Windows\n2000) and it has been improved through newer versions of Windows ever since. On earlier\nversions of Windows, it could be abused to do some nasty things like hiding loaded modules\npresent within a process (to prevent them from being found – obviously this is not a beautiful\nthing though).\n\n**_What is this magic so-called “Process Environment (PEB)”?_** The PEB is a structure\nwhich holds data about the current process under it’s field values – some fields being\nstructures themselves to hold even more data. Every process has it’s own PEB and the\nWindows Kernel will also have access to the PEB of every user-mode process so it can keep\ntrack of certain data stored within it.\n\n**_Where does this sorcery come from? The PEB structure comes from the Windows Kernel_**\n(although is accessible in user-mode as well). The PEB comes from the Thread Environment\nBlock (TEB) which also happens to be commonly referred to as the Thread Information Block\n(TIB). The TEB is responsible for holding data about the current thread – every thread has\nit’s own TEB structure.\n\n**_Can the Thread Environment Block or the Process Environment Block be abused for_**\n**_malicious purposes? Of course they can! In fact, they have been abused for malicious_**\npurposes in the past but Microsoft has made many changes over the recent years to help\nprevent this. An example would be in the past where rootkits would inject a DLL into another\nrunning process, and then access the PEB structure of the current process they had injected\ninto (the PPEB structure is a pointer to the PEB structure) so they could locate the list of\nloaded modules and remove their own module from the list… Thus hiding their injected\nmodule from view when someone enumerates the loaded modules of the affected process.\nThis is known as memory patching because you would be modifying memory by patching the\nPEB. Microsoft’s mitigation for this behavior was to prevent the manual altering of the list\nwhich represents the loaded modules in user-mode – you can still access it for reading the\ndata in user-mode though and you can still patch the memory from kernel-mode.\n\n**This article will be split up into two different sections: theory and user-mode practical.**\n\n## Theoretical\n\n\n-----\n\nWe re going to take a look at the Thread Environment Block (TEB) structure using WinDbg.\nSince the TEB structure is available in user-mode, and used by user-mode Windows\ncomponents such as NTDLL and KERNEL32, we won’t require kernel-debugging to query\nabout the structure.\n\nBear in mind that you will need to have your symbols correctly setup otherwise you will fail\nwith the next upcoming steps, please see the following URL: https://msdn.microsoft.com/enus/library/windows/desktop/ee416588(v=vs.85).aspx\n\nWe’ll start by opening up WinDbg – I’ll be opening up the 64-bit version.\n\nWinDbg default view.\nNow we’ll open up notepad.exe. Once it is open, we can attach to notepad.exe in WinDbg by\ngoing to File -> Attach to a Process -> notepad.exe. Alternatively, you can use the default\nhot-key which should be F6.\n\nAttaching to a process via WinDbg. 1/2\n\n\n-----\n\nAttaching to a process via WinDbg. 2/2\nAfter doing this, the WinDbg command window will be displayed. The command window is\nthe work-space we will have to enter commands at our own discretion to get back various\ndesired results. For example, if we wish to manipulate something, or query information about\nsomething, we can do this with a command. WinDbg has a whole wide-range of commands\navailable and you can learn more about that here: http://windbg.info/doc/1-commoncmds.html\n\nWe’ll be using the dt instruction. “dt” stands for “Display Type” and can be used to display\ninformation about a specific data-type, including structures. In our case, it is more than\nappropriate because it supports structures and we need to find out information about the\nTEB structure.\n\nWe can use the following instruction to query information about the TEB structure.\n```\ndt ntdll!_TEB\n\n```\n\n-----\n\nWinDbg command (dt) for the _TEB structure.\nWe can see already that there are many fields of the structure, so many fields that they all\ndon’t fit on the singular image view. However, if we look towards the very top of the structure,\nwe’ll find the Process Environment Block’s field.\n\n\n-----\n\nHighlighting the ProcessEnvironmentBlock field of the _TEB structure.\nWe can see that WinDbg is labelling the data-type for the field as “Ptr64 _PEB”. This simply\nmeans that the data-type is a pointer to the PEB structure (PPEB). Since we are debugging\na 64-bit compiled program (notepad.exe since our OS architecture is 64-bit), the addresses\nare 8 bytes instead of 4 bytes like on a 32-bit environment, which is why “64” is appended to\nthe “Ptr”.\n\nWe can view the fields of the PEB structure with the following WinDbg command.\n```\ndt ntdll!_PEB\n\n```\n\n-----\n\nWinDbg command (dt) for the _PEB structure.\nThe WinDbg output is below.\n\n\n-----\n\n```\n0:007> dt ntdll!_PEB\n +0x000 InheritedAddressSpace : UChar\n +0x001 ReadImageFileExecOptions : UChar\n +0x002 BeingDebugged : UChar\n +0x003 BitField : UChar\n +0x003 ImageUsesLargePages : Pos 0, 1 Bit\n +0x003 IsProtectedProcess : Pos 1, 1 Bit\n +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit\n +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit\n +0x003 IsPackagedProcess : Pos 4, 1 Bit\n +0x003 IsAppContainer : Pos 5, 1 Bit\n +0x003 IsProtectedProcessLight : Pos 6, 1 Bit\n +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit\n +0x004 Padding0 : [4] UChar\n +0x008 Mutant : Ptr64 Void\n +0x010 ImageBaseAddress : Ptr64 Void\n +0x018 Ldr : Ptr64 _PEB_LDR_DATA\n +0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS\n +0x028 SubSystemData : Ptr64 Void\n +0x030 ProcessHeap : Ptr64 Void\n +0x038 FastPebLock : Ptr64 _RTL_CRITICAL_SECTION\n +0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER\n +0x048 IFEOKey : Ptr64 Void\n +0x050 CrossProcessFlags : Uint4B\n +0x050 ProcessInJob : Pos 0, 1 Bit\n +0x050 ProcessInitializing : Pos 1, 1 Bit\n +0x050 ProcessUsingVEH : Pos 2, 1 Bit\n +0x050 ProcessUsingVCH : Pos 3, 1 Bit\n +0x050 ProcessUsingFTH : Pos 4, 1 Bit\n +0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit\n +0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit\n +0x050 ReservedBits0 : Pos 7, 25 Bits\n +0x054 Padding1 : [4] UChar\n +0x058 KernelCallbackTable : Ptr64 Void\n +0x058 UserSharedInfoPtr : Ptr64 Void\n +0x060 SystemReserved : Uint4B\n +0x064 AtlThunkSListPtr32 : Uint4B\n +0x068 ApiSetMap : Ptr64 Void\n +0x070 TlsExpansionCounter : Uint4B\n +0x074 Padding2 : [4] UChar\n +0x078 TlsBitmap : Ptr64 Void\n +0x080 TlsBitmapBits : [2] Uint4B\n +0x088 ReadOnlySharedMemoryBase : Ptr64 Void\n +0x090 SharedData : Ptr64 Void\n +0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void\n +0x0a0 AnsiCodePageData : Ptr64 Void\n +0x0a8 OemCodePageData : Ptr64 Void\n +0x0b0 UnicodeCaseTableData : Ptr64 Void\n +0x0b8 NumberOfProcessors : Uint4B\n +0x0bc NtGlobalFlag : Uint4B\n +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER\n +0x0c8 HeapSegmentReserve : Uint8B\n +0x0d0 HeapSegmentCommit : Uint8B\n +0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B\n +0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B\n\n```\n\n-----\n\n```\n+0x0e8 NumberOfHeaps : Uint4B\n+0x0ec MaximumNumberOfHeaps : Uint4B\n+0x0f0 ProcessHeaps : Ptr64 Ptr64 Void\n+0x0f8 GdiSharedHandleTable : Ptr64 Void\n+0x100 ProcessStarterHelper : Ptr64 Void\n+0x108 GdiDCAttributeList : Uint4B\n+0x10c Padding3 : [4] UChar\n+0x110 LoaderLock : Ptr64 _RTL_CRITICAL_SECTION\n+0x118 OSMajorVersion : Uint4B\n+0x11c OSMinorVersion : Uint4B\n+0x120 OSBuildNumber : Uint2B\n+0x122 OSCSDVersion : Uint2B\n+0x124 OSPlatformId : Uint4B\n+0x128 ImageSubsystem : Uint4B\n+0x12c ImageSubsystemMajorVersion : Uint4B\n+0x130 ImageSubsystemMinorVersion : Uint4B\n+0x134 Padding4 : [4] UChar\n+0x138 ActiveProcessAffinityMask : Uint8B\n+0x140 GdiHandleBuffer : [60] Uint4B\n+0x230 PostProcessInitRoutine : Ptr64 void \n+0x238 TlsExpansionBitmap : Ptr64 Void\n+0x240 TlsExpansionBitmapBits : [32] Uint4B\n+0x2c0 SessionId : Uint4B\n+0x2c4 Padding5 : [4] UChar\n+0x2c8 AppCompatFlags : _ULARGE_INTEGER\n+0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER\n+0x2d8 pShimData : Ptr64 Void\n+0x2e0 AppCompatInfo : Ptr64 Void\n+0x2e8 CSDVersion : _UNICODE_STRING\n+0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA\n+0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP\n+0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA\n+0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP\n+0x318 MinimumStackCommit : Uint8B\n+0x320 FlsCallback : Ptr64 _FLS_CALLBACK_INFO\n+0x328 FlsListHead : _LIST_ENTRY\n+0x338 FlsBitmap : Ptr64 Void\n+0x340 FlsBitmapBits : [4] Uint4B\n+0x350 FlsHighIndex : Uint4B\n+0x358 WerRegistrationData : Ptr64 Void\n+0x360 WerShipAssertPtr : Ptr64 Void\n+0x368 pUnused : Ptr64 Void\n+0x370 pImageHeaderHash : Ptr64 Void\n+0x378 TracingFlags : Uint4B\n+0x378 HeapTracingEnabled : Pos 0, 1 Bit\n+0x378 CritSecTracingEnabled : Pos 1, 1 Bit\n+0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit\n+0x378 SpareTracingBits : Pos 3, 29 Bits\n+0x37c Padding6 : [4] UChar\n+0x380 CsrServerReadOnlySharedMemoryBase : Uint8B\n+0x388 TppWorkerpListLock : Uint8B\n+0x390 TppWorkerpList : _LIST_ENTRY\n+0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void\n+0x7a0 TelemetryCoverageHeader : Ptr64 Void\n+0x7a8 CloudFileFlags : Uint4B\n\n```\n\n-----\n\nAs we can see, there s a lot of fields for the PEB structure. We ll only be focusing on a select\nfew of them during the practical sections though.\n\nBefore we can continue, we need to briefly talk about how the Process Environment Block is\nactually found. It’s located at FS:[0x30] in the Thread Environment Block/Thread Information\nBlock for 32-bit processes, and it’s located at GS:[0x60] for 64-bit processes.\n\nTo start off, the third field of the PEB structure (“BeingDebugged”) can be read to determine if\nthe current process is attached to via a debugger – this is one vector which is commonly\nclosed by analysts who are debugging malicious software, because malicious software tends\nto keep a close-eye out for debuggers and other analysis tools to make things more difficult\nfor malware analysts. There’s a routine from the Win32 API called IsDebuggerPresent\n(KERNEL32) and the routine works by checking the BeingDebugged field of the PEB\nstructure. We can validate this by reverse-engineering kernel32.dll ourselves.\n\nIDA pseudo-code for IsDebuggerPresentStub (KERNEL32 – Windows 8+).\nAs we can see, kernel32.dll has a routine named IsDebuggerPresentStub which calls\nIsDebuggerPresent. This is because the environment I’m getting these images from is\nWindows 10 64-bit, and Microsoft moved to using KernelBase.dll (introduced starting\nWindows 8). However, for backwards-compatibility, kernel32.dll is still pushed for usage by\ntheir documentation – and if they had dropped support for it then they would have to have\nmoved more than they have across to a new module project, and there’d have been a lot of\nincompatible software for Windows 8+ at the time.\n\nTherefore, we need to take a look at KernelBase.dll.\n\nDisassembly for IsDebuggerPresent (KERNEL32 / KERNELBASE).\nPerfect! KernelBase.dll has an exported routine named IsDebuggerPresent. We’re going to\ndebunk what the above disassembly is telling us.\n\n\n-----\n\n1. The address of the Process Environment Block is being moved into the RAX register.\n\nSince we’re looking at the 64-bit compiled version of KernelBase.dll, 64-bit registers\nare being used. The Process Environment Block is located at + 0x60 for 64-bit\nprocesses.\n2. The value from the BeingDebugged field under the Process Environment Block is being\n\nextracted and put into the EAX register. The data-type for the BeingDebugged field is\nUCHAR (which is one byte), and it’s offset is 0x002 – the first field of the PEB structure\nis located at 0x000 which means the third field (which is the BeingDebugged field) is\nlocated +2 bytes from this address. Since the RAX register is holding the address to\nthe Process Environment Block, (RAX + 2) is performed to reach the address of the\nBeingDebugged field.\n3. Returning with the RETN instruction. Since the value for the BeingDebugged field of\n\nthe PEB structure is held within the EAX register, the caller of the routine is going to\nreturn the value stored within the BeingDebugged field.\n\nA routine like IsDebuggerPresent (KERNEL32 / KERNELBASE) might be an obvious sign for\na malware analyst who is taking a look at the API calls being made by a sample therefore\nsome malware samples will manually access the PEB structure to check – doing this is\nstealthier and usually less-expected.\n\nThe next fields we’re going to briefly talk about are the IsProtectedProcess and\nIsProtectedProcessLight fields of the Process Environment Block.\n\nThese fields can be used to determine if the current process is “protected” or not, hence the\n“ProtectedProcess” key-word in the field names. In Windows, there’s multiple process\nprotection mechanisms although the former (non-Light variant) has been around a lot longer\nthan the Process Protection Light (PPL) variant. Standard process protection mechanism in\nWindows has been around since Windows Vista, however the PPL feature came into play\nstarting Windows 8. Microsoft use these mechanisms to protect their own System processes\nfrom being abused by malicious software or forcefully shut-down by a third-party source\n(because for some Windows processes this can cause the system to bug-check/improperly\nfunction). If we can access these fields within the Process Environment Block, then we can\ncheck if the current process is protected or not by Windows. All of this is enforced from\nkernel-mode by the Windows Kernel using the undocumented and opaque EPROCESS\nstructure, and you cannot write to these fields in the PEB structure and have the changes\ntake effect because it won’t update the EPROCESS structure for the current process.\n\nThe standard process protection mechanism is used by Windows system processes. This\nmechanism is enforced from within the Windows Kernel and it’s not supposed to be used by\nthird-parties, and it helps prevent system processes from being exploited by attackers (or\nforcefully shut-down – the Operating System cannot function properly without it’s critical\nuser-mode components). On top of this, Windows will set the state of various system\nprocesses to “critical”, and this is flag-based and will cause the system to be forcefully\ncrashed (via a bug-check) if the “critical” processes become terminated There are two\n\n\n-----\n\ndifferent implementations for the critical state: critical processes and critical threads. Setting\na process as critical will cause the bug-check once the process has been terminated, and\nsetting a thread as critical will cause the bug-check once the thread has been terminated.\nUsually, the former is more appropriate because threads come and go regularly (e.g. spawn\na new thread to handle an operation simultaneously and then the thread will be terminated\nonce it returns back it’s status from the operation). Windows does not set “threads” as critical\nas far as I am aware, although it will set specific processes as critical (processes like\ncsrss.exe).\n\nWe’re going to take a look at how the process protection mechanism which is built-into\nWindows actually works very briefly using Interactive Disassembler and WinDbg.\n\n**We can easily check using the following routines.**\n\n1. PsIsProtectedProcess (NTOSKRNL)\n2. PsIsProtectedProcessLight (NTOSKRNL)\n\nBoth of the above routines are undocumented but they are still exported by the Windows\nKernel.\n\nDisassembly for PsIsProtectedProcess (NTOSKRNL).\nLooking at the disassembly of PsIsProtectedProcess, we can see that the TEST instruction\nis being used. The TEST instruction is used for a “bitwise operation”. However, we can also\nsee that [RCX+6CAh] is the target. The PsIsProtectedProcess routine takes in one\nparameter only and it returns a BOOLEAN (UCHAR) – the parameter’s data-type should be\na pointer to the EPROCESS structure for the target process being checked on. This tells us\nthat the value stored in the RCX register will be the address of the PEPROCESS\n(EPROCESS*) for the target process, and it’s accessing the structure to read the value\nstored under an unknown field which symbolises if the process is or is not protected. The\noffset for where the field under the EPROCESS structure is located is 6CAh. This means that\nif you add on 0x6CA from the base address of the EPROCESS* for a process, you will land\nyourself at the address in which the value being checked in this routine is located at (for this\nenvironment only because the offsets regularly shift around and will vary between\nenvironment – due to patch updates and separate OS versions).\n\nWe can check with WinDbg which field is for the 0xC6A offset.\n\n\n-----\n\nWinDbg command (dt) for the _EPROCESS structure, showing the Protection field.\nNice! The field in the EPROCESS structure which holds data regarding process protection is\nnamed Protection and has a data-type of _PS_PROTECTION (which is a structure) – atleast for the standard process protection mechanism, we are yet to check on the Light\nvariant. We can take a look at the _PS_PROTECTION structure with the dt instruction.\n\nWinDbg command (dt) for the _PS_PROTECTION structure.\nNow if we check the disassembly of the PsIsProtectedProcessLight routine, we can see if it\nuses the same mechanism to query the status.\n\nDisassembly for PsIsProtectedProcessLight (NTOSKRNL).\nIt’s targeting the Protection field of the EPROCESS structure as well – the same field of the\nstructure too. The only difference here is that PsIsProtectedProcess is and\nPsIsProtectedProcessLight are doing some different checks.\n\nIn the PEB structure, there’s an entry named Ldr which has a data-type of\n_PEB_LDR_DATA. Within this structure, we have a field named InMemoryOrderModuleList\nwhich has a data-type of _LIST_ENTRY. Double linked lists are very common in Windows\ncomponents such as in the Windows Kernel or lower-level user-mode components.\n\nThere’s an instruction in WinDbg named !peb which can be used to enumerate data for the\nPEB of the currently debugged process. Below is an image of what the output will look like,\nfocus only on the non-highlighted parts.\n\n\n-----\n\nWinDbg command (!peb) output.\nIf we go through the InMemoryOrderModuleList, we can extract each entry and assign to a\n[pointer of the LDR_DATA_TABLE_ENTRY structure using the CONTAINING_RECORD](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/mm-bad-pointer)\nmacro. Then we could view details about the current module enumerated using the linked\nlists… We will do this during the practical code section which is right about now.\n\nWe’re going to be using the PEB for practical use in the next section.\n\n**User-Mode**\n\nIn this section we’re going to be re-writing a few Win32 API routines in user-mode which rely\non the Process Environment Block.\n\n1. GetModuleHandle – using the Ldr field of the PEB structure\n2. GetModuleFileName – using the ProcessParameters field of the PEB structure\n\nWe need to make sure we’ve declared some structures. Depending on the header files\nyou’re using, you may not need them. However if you do need them…\n\n\n-----\n\n```\ntypedef struct _UNICODE_STRING {\n  USHORT Length;\n  USHORT MaximumLength;\n  WCHAR *Buffer;\n} UNICODE_STRING, PUNICODE_STRING;\ntypedef const UNICODE_STRING\n       *PCUNICODE_STRING;\ntypedef struct _CLIENT_ID {\n  PVOID UniqueProcess;\n  PVOID UniqueThread;\n} CLIENT_ID, *PCLIENT_ID;\ntypedef struct _RTL_USER_PROCESS_PARAMETERS {\n  BYTE Reserved1[16];\n  PVOID Reserved2[10];\n  UNICODE_STRING ImagePathName;\n  UNICODE_STRING CommandLine;\n} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;\ntypedef struct _PEB_LDR_DATA {\n  BYTE Reserved1[8];\n  PVOID Reserved2[3];\n  LIST_ENTRY InMemoryOrderModuleList;\n} PEB_LDR_DATA, *PPEB_LDR_DATA;\ntypedef struct _LDR_DATA_TABLE_ENTRY {\n  PVOID Reserved1[2];\n  LIST_ENTRY InMemoryOrderLinks;\n  PVOID Reserved2[2];\n  PVOID BaseAddress;\n  PVOID Reserved3[2];\n  UNICODE_STRING FullDllName;\n  UNICODE_STRING BaseDllName;\n  BYTE Reserved4[8];\n  PVOID Reserved5[3];\n#pragma warning(push)\n#pragma warning(disable: 4201) // we'll always use the Microsoft compiler\n  union {\n    ULONG CheckSum;\n    PVOID Reserved6;\n  } DUMMYUNIONNAME;\n#pragma warning(pop)\n  ULONG TimeDateStamp;\n} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;\ntypedef struct _PEB {\n  BYTE Reserved1[2];\n  BYTE BeingDebugged;\n  BYTE Reserved2[1];\n  PVOID Reserved3[2];\n  PPEB_LDR_DATA Ldr;\n  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;\n  PVOID Reserved4[3];\n\n```\n\n-----\n\n```\n  PVOID AtlThunkSListPtr;\n  PVOID Reserved5;\n  ULONG Reserved6;\n  PVOID Reserved7;\n  ULONG Reserved8;\n} PEB, *PPEB;\ntypedef struct _TEB {\n  NT_TIB NtTib;\n  PVOID EnvironmentPointer;\n  CLIENT_ID ClientId;\n  PVOID ActiveRpcHandle;\n  PVOID ThreadLocalStoragePointer;\n  PPEB ProcessEnvironmentBlock;\n} TEB, *PTEB;\n\n```\nThe next thing you might want is a global definition for NtCurrentPeb(). This isn’t mandatory\nbut it can be a bit helpful if you’d prefer to type NtCurrentPeb() instead of NtCurrentTeb()>ProcessEnvironmentBlock every-time you need to gain access to the PEB. I always\npreferred to type NtCurrentPeb() but that’s just me.\n```\n#define NtCurrentPeb() \\\n    NtCurrentTeb()->ProcessEnvironmentBlock\n\n```\n_What is NtCurrentTeb()?_\n\nNtCurrentTeb() is a function which is packed within winnt.h, and it’ll return a pointer to the\nTEB structure at the correct address of where the TEB is located.\n\nNtCurrentTeb() will change depending on the configuration however for a 32-bit compilation,\nit will locate the TEB by using the __readfsdword macro, targeting 0x18 as the location. This\nmeans that the target location is actually FS:[0x18]. For a 64-bit compilation, __readgsqword\nwill be used and the target location will be different.\n\nGetModuleHandle replacement\n\n\n-----\n\n```\nHMODULE GetModuleHandleWrapper(\n  WCHAR *ModuleName\n)\n{\n  PPEB ProcessEnvironmentBlock = NtCurrentPeb();\n  PPEB_LDR_DATA PebLdrData = { 0 };\n  PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = { 0 };\n  PLIST_ENTRY ModuleList = { 0 },\n        ForwardLink = { 0 };\n  if (ProcessEnvironmentBlock)\n  {\n    PebLdrData = ProcessEnvironmentBlock->Ldr;\n    if (PebLdrData)\n    {\n      ModuleList = &PebLdrData->InMemoryOrderModuleList;\n      ForwardLink = ModuleList->Flink;\n      while (ModuleList != ForwardLink)\n      {\n        LdrDataTableEntry = CONTAINING_RECORD(ForwardLink,\n          LDR_DATA_TABLE_ENTRY,\n          InMemoryOrderLinks);\n        if (LdrDataTableEntry)\n        {\n          if (LdrDataTableEntry->BaseDllName.Buffer)\n          {\n            if (!_wcsicmp(LdrDataTableEntry->BaseDllName.Buffer,\n              ModuleName))\n            {\n              return (HMODULE)LdrDataTableEntry->BaseAddress;\n            } \n           }\n         }\n         ForwardLink = ForwardLink->Flink;\n       }\n     }\n  }\n  return 0;\n}\n\n```\nThe above routine does the following.\n\n1. Retrieves the PPEB\n2. Checks if the PPEB could be acquired or not\n3. Enumerates the InMemoryOrderModuleList\n4. Retrieves a pointer to the LDR_DATA_TABLE_ENTRY structure for each entry\n5. Returns the BaseAddress of the module if its a match based on module name buffer\n\ncomparison with the parameter passed in\n\n\n-----\n\nGetModuleFileName wrapper\n```\nWCHAR *GetModuleFileNameWrapper()\n{\n  PPEB ProcessEnvironmentBlock = NtCurrentPeb();\n  if (ProcessEnvironmentBlock)if (ProcessEnvironmentBlock)\n  {\n    if (ProcessEnvironmentBlock->ProcessParameters)\n    {\n      if (ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Buffer)\n      {\n        if (ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Buffer)\n        {\n          return ProcessEnvironmentBlock->ProcessParameters>ImagePathName.Buffer;\n        }\n      }\n    }\n  }\n  return NULL;\n}\n\n```\nThe above routine does the following.\n\n1. Retrieves the PPEB (pointer to the PEB)\n2. Checks if the PPEB could be acquired or not\n3. Checks if it can access the ProcessParameters field\n4. Returns the ImagePathName buffer (it’s a UNICODE_STRING so the Buffer field is a\n\nwchar_t*)\n\nAll of this has been known for an extremely long time now but for those of you which have\nonly just got into Windows Internals and started studying areas like the Process Environment\nBlock, this could help clear things up for you quickly and put an end to some confusion.\n\nAs always, thanks for reading.\n\nNtOpcode\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-26 - Anatomy of the Process Environment Block (PEB) (Windows Internals).pdf"
    ],
    "report_names": [
        "2018-02-26 - Anatomy of the Process Environment Block (PEB) (Windows Internals).pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536066,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653757364,
    "ts_modification_date": 1653757364,
    "files": {
        "pdf": "https://archive.orkl.eu/9fd5cb7a8d1bd8d8ed9df515f7d0c15df1de063c.pdf",
        "text": "https://archive.orkl.eu/9fd5cb7a8d1bd8d8ed9df515f7d0c15df1de063c.txt",
        "img": "https://archive.orkl.eu/9fd5cb7a8d1bd8d8ed9df515f7d0c15df1de063c.jpg"
    }
}