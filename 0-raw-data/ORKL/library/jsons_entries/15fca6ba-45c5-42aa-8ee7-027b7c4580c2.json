{
    "id": "15fca6ba-45c5-42aa-8ee7-027b7c4580c2",
    "created_at": "2023-01-12T15:04:11.151957Z",
    "updated_at": "2025-03-27T02:05:37.842654Z",
    "deleted_at": null,
    "sha1_hash": "f6309f850fb7a6b45aa5c268b73d20714646f24b",
    "title": "2016-03-03 - Attack on Zygote- a new twist in the evolution of mobile threats",
    "authors": "",
    "file_creation_date": "2022-05-27T21:59:53Z",
    "file_modification_date": "2022-05-27T21:59:53Z",
    "file_size": 1064367,
    "plain_text": "# Attack on Zygote: a new twist in the evolution of mobile threats\n\n**[securelist.com/attack-on-zygote-a-new-twist-in-the-evolution-of-mobile-threats/74032/](https://securelist.com/attack-on-zygote-a-new-twist-in-the-evolution-of-mobile-threats/74032/)**\n\nAuthors\n\nNikita Buchka\n\nMikhail Kuzin\n\n## The story of the small Trojan that could!\n\n\n-----\n\nThe main danger posed by apps that gain root access to a mobile device without the user’s\nknowledge is that they can provide access to far more advanced and dangerous malware\nwith highly innovative architecture. We feared that Trojans obtaining unauthorized superuser\nprivileges to install legitimate apps and display advertising would eventually start installing\nmalware. And our worst fears have been realized: rooting malware has begun spreading the\nmost sophisticated mobile Trojans we have ever seen.\n\n## Rooting malware\n\nIn [our previous article we wrote about the increasing popularity of malware for Android that](https://securelist.com/blog/mobile/71981/taking-root/)\ngains root access to a device and uses it to install apps and display aggressive advertising.\nOnce this type of malicious program penetrates a device, it often becomes virtually\nimpossible to use it due to the sheer number of annoying ads and installed apps.\n\nSince the first article (August 2015), things have changed for the worse – the number of\nmalware families of this type has increased from four to 11 and they are spreading more\nactively and becoming much better at “rooting”. According to our estimates, Trojans with\nsuperuser privileges attacked about 10% of Android-based mobile devices in the second half\nof 2015. There were also cases of these programs being pre-installed on new mobile devices\ncoming from China.\n\n\n-----\n\nHowever, it s worth noting that Android-based devices running versions higher than 4.4.4\nhave much fewer vulnerabilities that can be exploited to gain root access. So basically, the\nmalware targets earlier versions of the OS that are still installed on the majority of devices.\nThe chart below shows the distribution of our product users by Android version. As can be\nseen from the chart, about 60% use a device on which these Trojans can gain root access.\n\n_Versions of Android OS used by users of our products_\n\nThe owners of the Trojans described above, such as Leech, Ztorg, Gorpo (as well as the\nnew malware family Trojan.AndroidOS.Iop) are working together. Devices infected by these\nmalicious programs usually form a kind of “advertising botnet” via which advertising Trojans\ndistribute each other as well as the advertised apps. Within a few minutes of installing one of\nthese Trojans, all other active malware on the “network” is enabled on the victim’s device.\nCybercriminals are cashing in on advertising and installing legitimate applications.\n\nIn 2015, this “advertising botnet” was used to distribute malware posing a direct threat to the\nuser. This is how one of the most sophisticated mobile Trojans we have ever analyzed was\nspread.\n\n## Unique Trojan\n\nThe “advertising botnet” mentioned above was used to distribute a unique Trojan with the\nfollowing features:\n\n\n-----\n\nModular functionality with active use of superuser privileges\nMain part of malicious functionality exists in device RAM only.\nTrojan modifies Zygote system process in the memory to achieve persistence.\nIndustrial approaches used in its development, suggesting its authors are highly\nqualified.\n\nThe Trojan is installed in the folder containing the system applications, under names that\nsystem applications are likely to have (e.g. AndroidGuardianship.apk,\n**GoogleServerInfo.apk, USBUsageInfo.apk etc.).**\n\nBefore starting work, the malicious program collects the following information:\n\nName of the device\nVersion of the operating system\nSize of the SD card\nInformation about device memory (from the file /proc/mem)\nIMEI\nIMSI\nList of applications installed\n\nThe collected information is sent to the cybercriminals’ server whose address the Trojan\nreceives from a list written in the code:\n\nbridgeph2.zgxuanhao.com:8088\nbridgeph2.zgxuanhao.com:8088\nbridgeph3.zgxuanhao.com:8088\nbridgeph3.zgxuanhao.com:8088\nbridgeph4.zgxuanhao.com:8088\nbridgeph2.viewvogue.com:8088\nbridgeph3.viewvogue.com:8088\nbridgeph3.viewvogue.com:8088\nbridgeph4.viewvogue.com:8088\n\nOr, if the above servers are unavailable, from a list of reserve command servers also written\nin the code:\n\nbridgecr1.tailebaby.com:8088\nbridgecr2.tailebaby.com:8088\nbridgecr3.tailebaby.com:8088\nbridgecr4.tailebaby.com:8088\nbridgecr1.hanltlaw.com:8088\nbridgecr2.hanltlaw.com:8088\nbridgecr3.hanltlaw.com:8088\nbridgecr4.hanltlaw.com:8088\n\n\n-----\n\nIn reply, an encrypted configuration file arrives and is stored as\n**/system/app/com.sms.server.socialgraphop.db. The configuration is regularly updated**\nand contains the following fields:\n\n**_mSericode – malware identifier_**\n**_mDevicekey – the device identifier generated on the server (stored in_**\n**/system/app/OPBKEY_< mDevicekey >);**\n**_mServerdevicekey – the current server identifier_**\n**_mCD – information used by cybercriminals to adjust the behavior of the modules;_**\n**_mHeartbeat – execution interval for the “heartbeatRequest” interface_**\n**_mInterval – interval at which requests are sent to the command server_**\n**_mStartInterval – time after which the uploaded DEX files (modules) are run_**\n**_mServerDomains – list of main domains_**\n**_mCrashDomains – list of reserve domains_**\n**_mModuleUpdate – links required to download the DEX files (modules)._**\n\nIf the mModuleUpdate field is not filled, the DEX files are downloaded and saved. Then\nthese files are downloaded in the context of the malicious program using\n**DexClassLoader.loadClass(). After that, the modules are removed from the disk, i.e. they**\nonly remain in device memory, which seriously hampers their detection and removal by\nantivirus programs.\n\nThe downloaded modules should have the following interface methods for proper execution:\n\n**_init(Context context) – used to initialize the modules_**\n**_exit(Context context) – used to complete the work of the modules_**\n**_boardcastOnReceive(Context context, Intent intent) – used to redirect broadcast_**\nmessages to the module;\n**_heartbeatRequest(Context context) – used to initiate the module request to the_**\ncommand server. It is needed in order to obtain the data module required by the server;\n**_heartbeatResponce(Context context, HashMap serverResponse) – used to deliver_**\nthe command server response to the module.\n\nDepending on the version, the following set of interfaces may be used:\n\n**_init(Context context) – used to initialize the modules_**\n**_exec() – used to execute the payload_**\n**_exit(Context context) – used to complete the work of the modules_**\n\nThis sort of mechanism allows the app downloader to execute modules implementing\ndifferent functionality, as well as coordinating and synchronizing them.\n\nThe apps and the loaded modules use the “android bin”, “conbb”, “configopb”, “feedback”\nand “systemcore” files stored in the folder /system/bin to perform various actions on the\nsystem using superuser privileges It goes without saying that a clean system does contain\n\n\n-----\n\nthese files.\n\nConsidering the aforementioned modular architecture and privileged access to the device,\nthe malware can create literally anything. The capabilities of the uploaded modules are\nlimited only by the imagination and skills of the virus writers. These malicious programs (the\napp loader and the modules that it downloads) belong to different types of Trojans, but all of\nthem were all included in our antivirus databases under the name Triada.\n\nAt the time of analysis the app downloader (detected by us as\n**Backdoor.AndroidOS.Triada) downloaded and activated the following modules:**\n\nOPBUpdate_3000/Calendar_1000 – two modules with duplicate functionality capable\nof downloading, installing and running an application (detected as Trojan**Downloader.AndroidOS.Triada.a).**\nRegistered_1000 – module capable of sending an SMS upon the request of the\ncommand server. Detected as Trojan-SMS.AndroidOS.Triada.a.\nIdleinfo_1000 – module that targets applications that use SMS to make in-app\npurchases (intercepts outgoing text messages). Detected as Trojan**Banker.AndroidOS.Triada.a.**\n\n## Use of the Zygote process\n\nA distinctive feature of the malicious application is the use of the Zygote process to\nimplement its code in the context of all the applications on the device. The Zygote process is\nthe parent process for all Android applications. It contains system libraries and frameworks\nused by almost all applications. This process is a template for each new application, which\nmeans that once the Trojan enters the process, it becomes part of the template and will end\nup in each application run on the device. This is the first time we have come across this\ntechnique in the wild; Zygote was only previously used in proof-of-concepts.\n\nThe chart below shows the architecture of the malicious program.\n\n\n-----\n\nLet us take a closer look at how the Zygote process is infected.\n\n### Preparatory stage and testing\n\nAll the magic starts in the crackZygoteProcess() function from the Trojan-Banker module.\nIts code is displayed in the screenshot below.\n\n\n-----\n\nFirst, the Trojan loads the shared library libconfigpppm.so and invokes the configPPP()\nfunction exported by this library (the first highlighted string on the screenshot). Second, if\n**configPPP() succeeds in calling System.getProperty() from Android API with the unusual**\nargument ‘pp.pp.pp’ (it will be explained later why this action is performed) and the returned\nvalue is not null, the Trojan runs the ELF-executable configpppi with the PID of the zygote\nprocess as an argument.\n\nLet’s go through the process in order. The first thing the Trojan does inside the configPPP()\nfunction from libconfigpppm.so is to obtain the load address (in the address space of its\nprocess) of the file that implements the ActivityThread.main() function from Android API.\nNext, using the load address and /proc/self/maps, the Trojan discovers the name and path to\nthe file on the disk. In most cases, it will be /system/framework/framework.odex.\n\nThe Trojan reads this file from disk and compares it with the file that is already loaded in the\naddress space. The comparison is performed as follows:\n\n1. The file is divided into 16 blocks;\n2. The first 8 bytes of each block are read;\n3. These 8-byte sequences are compared with the corresponding sequences from the file\n\nthat loaded in memory;\n\nIf the comparison fails, configPPP aborts its execution and returns a 103 error code. If the\ncomparison succeeds, the Trojan starts patching framework.odex in memory.\n\n\n-----\n\nThen, the malware obtains the Class structure of ActivityThread (which is defined in\n**framework.odex) by using dexFindClass and dexGetClassData functions. The authors of**\nthe malware copied these functions from Dalvik Virtual Machine. The structure contains\nvarious information about a dex class and is defined in AOSP. Using the structure, Triada\niterates through a list of methods implemented in this class looking for a method named\n“main”. After the method has been found, the Trojan obtains its bytecode with the help of the\n**dexGetCode function (also copied from open sources). When the bytecode is obtained, it is**\ncompared with the corresponding bytecode from the file on the disk, thereby checking if the\nframework has already been patched. If the method has already been patched, the malware\naborts its execution and returns a 103 error code.\n\nAfter that, the Trojan starts looking for the first string in the DEX strings table that are\nbetween 32 and 64 symbols long. After a string has been found, the Trojan replaces it with\n“/system/lib/libconfigpppl.so” and saves its ID.\n\nNext, Triada accesses the DEX methods table and tries to obtain a method with one of the\nfollowing names – “loop“, “attach” or “setArgV0“. It takes the first one that occurs in the\ntable, or, if there are no methods with these names, the penultimate method from the DEX\nmethods table, and replaces it with a standard System.load() method (one that loads shared\nlibraries to process address space) and saves its ID. The pseudocode that performs this\nmanipulation is shown below.\n\n\n-----\n\nAfter these actions, the preparatory stage is complete, and the Trojan performs the actual\npatching. It modifies the memory of the process, adding the following instructions to the\nbytecode of the “main” method of the ActivityThread class:\n\n**1A 00 [strID, 2 bytes]          //const-string v0, “/system/lib/libconfigpppl.so”**\n**71 10 [methID, 2 bytes] 00 00   //invoke-static {v0}, Ljava/lang/System;-**\n_>load(Ljava/lang/String;)V_\n**0E 00                       //return-void**\n\nwhere strID is thesaved ID of the replaced string, and methID is the saved ID of the\nreplaced method.\n\nAfter these modifications, when ActivityThread.main() is called, it will automatically load the\nshared library “/system/lib/libconfigpppl.so” to the context of the caller process. But\nbecause framework.odex is only patched in the context of the Trojan process, the library will\nonly be uploaded in the Trojan process. This seemingly meaningless action is performed in\norder to test the ability of the malicious program to modify the Zygote process. If the steps\ndescribed above do not cause errors in the context of the application, they will not cause\nerrors in the context of the system process. Such a complex operation as changing the\n\n\n-----\n\nZygote address space has been approached very carefully by the attackers, since the\nslightest error in this process can result in immediate system failure. That is why the “test\nrun” is performed to check the efficiency of the methods on the user’s device.\n\nAt the end configPPP() writes the following data to “/data/configppp/cpppimpt.db“:\n\nID of replaced string (4 bytes);\nContent of replaced string (64 bytes);\nID of replaced method (4 bytes);\nPointer to the Method structure for replaced method (4 bytes);\nContent of the Method structure for ActivityThread.main() (52 bytes);\nLoad address of framework.odex (4 bytes);\nList of structures that contain (previously used for comparison, 192 bytes):\n\n1. Pointer to the next block of framework.odex;\n2. First 8 bytes of the block:\n\nSize of framework.odex in memory (before patching) (4 bytes);\nPointer to the DexFile structure for framework.odex (4 bytes);\nContent of the DexFile structure for framework.odex (44 bytes);\nPointer to the Method structure for System.load() (4 bytes);\nSize of ActivityThread.main() bytecode before patching (4 bytes);\nBytecode of ActivityThread.main() before patching (variable);\nFinally, the Trojan calls the patched ActivityThread.main(), thus loading\n**/system/lib/libconfigpppl.so in its address space. We will describe the purpose of this**\nlibrary after explaining the functionality of the configpppi ELF-executable that performs the\nactual modification of Zygote’s address space.\n\n### Modification of the Zygote\n\nIn fact, configpppi also patches ActivityThread.main() from framework.odex, but unlike\n**libconfigpppm.so, it receives the PID of a process running on the system as an argument**\nand performs patching in the context of this process. In this case, the Trojan patches the\n**Zygote process. It uses information obtained at the previous stage (in libconfigpppm.so) and**\nstored in /data/configppp/cpppimpt.db to modify the Zygote process via ptrace system calls.\n\nThe Zygote process is a daemon whose purpose is to launch Android applications. It\nreceives requests to launch an application through /dev/socket/zygote. Every launch\nrequest triggers a fork() call. When fork() occurs the system creates a clone of the process\n– a child process that is a full copy of a parent. Zygote contains all the necessary system\nlibraries and frameworks, so every new Android application will receive everything it needs to\nexecute. This means every application is a child of the Zygote process and after patching,\nevery new application will receive framework.odex modified by the Trojan (with\n\n\n-----\n\n**libconfigpppl.so injected). In other words, libconfigpppl.so ends up in all new apps and**\ncan modify how they work. This opens up a wide range of opportunities for the\ncybercriminals.\n\n## Substitution of standard Android Framework features\n\nWhen the shared library /system/lib/libconfigpppl.so is loaded inside the Zygote by\n**System.load(), the system invokes its JNI_OnLoad() function. First, the Trojan restores the**\nstring and method replaced earlier by /system/lib/libconfigpppm.so or configpppi, using\nthe information from /data/configppp/cpppimpt.db. Second, Triada loads the DEX file\n**configpppl.jar. This is done with the help of a standard Android API via**\ndalvik.system.DexClassLoader.\n\nTo ensure that DEX is successfully loaded, the Trojan calls its method pppMain from the\n**PPPMain class. This method only outputs to logcat string “PPP main started”.**\n\nThe next stage is to prepare hooks for some methods from Android Framework\n(framework.odex). The malware checks if everything necessary for hook methods exist in\n**configpppl.jar (it uses the internal checkPackageMethodExits() method for this). The**\nTrojan then prepares hooks for the following methods:\n\n1. java.lang.System.getProperty()\n2. android.app.Instrumentation.newApplication()\n3. com.android.internal.telephony.SMSDispatcher.dispatchPdus()\n4. android.app.ActivityManager.getRunningServices()\n5. android.app.ActivityManager.getRunningAppProcesses()\n6. android.app.ApplicationPackageManager.getInstalledPackages()\n7 android app ApplicationPackageManager getInstalledApplications()\n\n\n-----\n\nThe hooks are placed using the standard RegisterNatives() function. This function is\ndesigned to perform binding Java methods with their native implementation (i.e. written with\nC/C++). Thus, the Trojan substitutes standard methods from Android Framework with\nmethods implemented in libconfigpppl.so.\n\n### Verifying the success of a Zygote modification\n\nThe function which substitutes the original getProperty() first checks its argument. If the\nargument is the “pp.pp.pp” string (which was mentioned earlier), then the function\nimmediately returns “true”. Otherwise, it calls the original getProperty() with its passed\nargument. Calling the hooked getProperty() with “pp.pp.pp” as an argument is used to\ncheck whether or not hooking of Android Framework functions was successful. If the hooked\n**getProperty() returned “true”, then the Trojan will start configpppi ELF with the PID of the**\n**Zygote process as an argument.**\n\nAfter that, the the Trojan “kills” processes of the applications: “com.android.phone”,\n“com.android.settings”, “com.android.mms”. These are the standard “Phone”, “Settings” and\n“Messaging” – applications that are the Trojan’s primary targets. The system starts these\napps automatically the next time the device is unblocked. After they start they will contain\n**framework.odex with all the hooks placed by libconfigpppl.so.**\n\n### Modification of outgoing text messages\n\nThe function which substitutes newApplication(), first calls the original function, and then\ninvokes two functions from configpppl.jar: onModuleCreate() and onModuleInit().\n\nThe function onModuleCreate() checks in the context of the application it is running and then\nsets the global variable mMainAppType according to the results of checking:\n\nIf function is running within com.android.phone, then mMainAppType set to 1;\nIf function is running within com.android.settings or com.android.mms, then\n**mMainAppType set to 2;**\nIf function is running within one of these apps:\n**com.android.system.google.server.info,**\n**com.android.system.guardianship.info.server, com.android.sys.op,**\n**com.android.system.op., com.android.system.kylin., com.android.kylines,**\n**com.android.email, com.android.contacts, android.process.media,**\n**com.android.launcher, com.android.browser, then mMainAppType set to -1;**\nIf function is running within any other application, then mMainAppType set to 0;\n\nDepending on the value of mMainAppType, the function onModuleInit() calls one of the\ninitialization routines:\n\n\n-----\n\nThus, the Trojan tracks its host application and changes its behavior accordingly. For\nexample, if mMainAppType is set to -1 (i.e. the host application is com.android.email,\n**com.android.contacts etc.), the Trojan does nothing.**\n\nIf the host application is com.android.phone, Triada registers broadcast receivers for the\nintents with actions com.ops.sms.core.broadcast.request.status and\n**com.ops.sms.core.broadcast.back.open.gprs.network. It first sets the global variable**\nmLastSmsShieldStatusTime to the current date and time, then turns on mobile network data\n(GPRS Internet).\n\nIf the host application is com.android.settings or com.android.mms, Triada registers\nbroadcast receivers for the intents with the following actions:\n\n**com.ops.sms.core.broadcast.request.status;**\n**com.ops.sms.core.broadcast.back.open.gprs.network;**\n**com.ops.sms.core.broadcast.back.send.sms.address.**\n\nThe first two are the same as in the previous case, and the third sends an SMS, which is\npassed off as extra intent data.\n\nIf the host application is any other app (apart from apps that trigger mMainAppType = -1),\nthen Triada first checks whether or not the application uses the shared library libsmsiap.so:\n\nDepending on the result, it calls one of the following functions: PISmsCore.invokeMMMain()\nor PISmsCore.invokeOtherMain().\n\nBoth functions invoke the PISmsCore.initInstance() method which performs the following\nactions:\n\n\n-----\n\n1. Initialization of the Trojan s global variables with various information about the infected\n\ndevice (IMEI, IMSI etc.);\n2. Substitution of the system binders “isms” and “isms2”, which are used by the parent\n\napplication along with its own ones;\n\n3. Creation of multiple directories /sdcard/Android/com/register/, used for write log and\n\nconfiguration files;\n4. Registration of broadcast receivers for intents with the actions\n\n**com.ops.sms.core.broadcast.responce.shield.status and**\n**com.ops.sms.core.broadcast.responce.sms.send.status, which simply set the**\ncorresponding variables to record the time of an event;\n5. If a function is invoked from PISmsCore.invokeMMMain(), then a new thread is\n\ncreated. This thread enters an endless loop and turns on mobile network data, and\nwon’t let the user turn it off.\n\nThe most interesting action among the above is the substitution of the system binders “isms”\nand “isms2”.\n\nBinder is an Android-specific inter-process communication mechanism, and remote method\ninvocation system. All communication between client and server applications within Binder\npass through a special Linux device driver – /dev/binder. The scheme of inter-process\ncommunication via the Binder mechanism is presented below.\n\n\n-----\n\nFor example, when an application wants to send an SMS it calls the sendTextMessage (or\nsendMultipartTextMessage) function, which in fact leads to the transact() method of an “isms”\n(or “isms2”) binder object being called.\n\nThe transact() method is redefined in the malicious “isms” binder realization, replacing the\noriginal. So, when the parent application of the Trojan sends an SMS it leads to the call of\nthe malicious transact() method.\n\nIn this method, the Trojan obtains SMS data (destination number, message text, service\ncenter number) from raw PDU. Then, if a network connection is available, it sends this data\nto a random C&C server from the following list:\n\nbridgeph2.zgxuanhao.com:8088\nbridgeph3.zgxuanhao.com:8088\nbridgeph3.zgxuanhao.com:8088\nbridgeph4.zgxuanhao.com:8088\nbridgeph2.viewvogue.com:8088\nbridgeph3.viewvogue.com:8088\nbridgeph3.viewvogue.com:8088\nbridgeph4.viewvogue.com:8088\n\nThe C&C server should respond with some data that, among other things, contains a new\nSMS destination address (number) and new SMS text.\n\n\n-----\n\nIf a network connection is not available, then the Trojan tries to find the appropriate data in\nthe local configuration files that are stored in the /sdcard/Android/com/register/localuseinfo/\ndirectory in encrypted form.\n\nThe Trojan then replaces the SMS destination address and the SMS text of the original\nmessage (obtained from C&C or local configuration files), and tries to send it in three\ndifferent ways (simultaneously):\n\n1. Via the standard Android API function sendTextMessage. It will lead to the same\n\nmalicious transact() method of the Trojan “isms” binder realization;\n2. By sending an intent with the action\n\n“com.ops.sms.core.broadcast.back.send.sms.address”. It will be received and\nprocessed by the same Trojan module but inside the “Messaging” or “Settings”\napplication;\n3. By passing the new SMS destination address and new SMS text to the original “isms”\n\nbinder transact() method.\n\nWhen the Trojan sends an SMS in one of these ways, it saves the new SMS destination\naddress and new SMS text in a special variable. And, before sending the new SMS, it\nchecks if it has not already been sent. This helps to prevent endless recursive calls of the\ntransact() method, meaning only one SMS will be sent per originally sent message (by the\nparent application).\n\nBesides the PISmsCore.initInstance() function, PISmsCore.invokeMMMain() calls another\nfunction – PIMMCrack.initInstance(). This method tries to determine which version of\nmm.sms.purchasesdk the host application is using (the Trojan knows for sure that the host\napplication is using this SDK, because it has checked for libsmsiap.so, which is part of this\nSDK). mm.sms.purchasesdk is the SDK of Chinese origin – it is used by app developers for\nenabling In-App purchasing via SMS.\n\nThus, the mechanism described in this chapter allows the Trojan to modify outgoing SMS\nmessages that are sent by other applications. We presume that the Trojan authors use this\nopportunity to secretly steal users’ money. For example, when a user buys something in\nsome Android game shop, and if this game uses SDK for in-app purchases via SMS (such\nas mm.sms.purchasesdk), the Trojan’s authors are likely to modify the outgoing SMS so as\nto receive the user’s money instead of the game developers. The user doesn’t notice that his\nmoney has been stolen; instead he presumes he hasn’t received the appropriate content and\nwill then complain to the game developers.\n\n\n-----\n\n### Filtration of incoming text messages\n\nThe original dispatchPdus() is used (as shown in the diagram below) to dispatch PDUs\n(Protocol Data Unit, low-level data entity used in many communication protocols) of incoming\nSMS messages to the corresponding broadcast intent. Then, all applications that subscribed\nfor the intent are able to receive and process, according to their needs, the text message that\nis contained in the form of PDUs inside of this intent.\n\nThe function which substitutes dispatchPdus() invokes the moduleDispatchPdus() method\nfrom configpppl.jar. It checks the host application and if the application is not\n**com.android.phone, it informs and broadcasts to all apps in the system intent with the**\naction android.provider.Telephony.SMS_RECEIVED (along with the received PDUs). This\nstandard intent informs all other applications (e.g. “Messaging” or “Hangouts” of the incoming\nSMS).\n\nIf the host for the malware is com.android.phone, then Triada checks the originating\naddress and message body of the incoming SMS. The information that the Trojan needs to\ncheck is contained within two directories: /sdcard/Android/com/register/infowaitreceive/\nand /sdcard/Android/com/register/historyInfo/. The names of the files that are stored in\nthese directories contain postfix, which signifies the date and time of the last response from\nthe C&C. If these files were updated earlier than the last response was received, the Trojan\ndeletes these files and aborts the checking of the incoming SMS. Otherwise, the malware\ndecrypts all the files from the directories mentioned above and extracts phone numbers and\nkeywords from them to perform filtering. If the SMS was received from one of these numbers\nor the message contains at least one keyword, the Trojan broadcasts an intent with the\naction android.provider.Telephony.SMS_RECEIVEDcom.android.sms.core along with the\nmessage. This is an intent with a custom action and only those applications that explicitly\nsubscribe to this intent, will receive it. There are no such applications on “clean” Android\ndevices. In addition, this method could be used to organize “exclusive” message distribution\nfor Triada modules. If some of the new modules subscribe to the intent with the action\n_android.provider.Telephony.SMS_RECEIVEDcom.android.sms.core, they will receive the_\nfiltered message exclusively, without any other applications on the system knowing about it.\n\n### Concealing Trojan modules from the list of running services\n\nThis function is used to obtain a list of all running services. The Trojan substitutes the\nfunction to hide its modules from this list. The following modules will be excluded from the list\nreceived from the original getRunningServices():\n\ncom.android.system.google.server.info\ncom.android.system.guardianship.info.server\ncom.android.sys.op\ncom.android.system.op.\ncom.android.system.kylin.\n\n\n-----\n\ncom.android.kylines.\n\n### Concealing Trojan modules from the list of running applications\n\nThis function is used to obtain a list of all running applications. The Trojan substitutes the\nfunction to hide its modules from this list. The following modules will be excluded from the list\nreceived from the original getRunningAppProcesses():\n\ncom.android.system.google.server.info\ncom.android.system.guardianship.info.server\ncom.android.sys.op\ncom.android.system.op.\ncom.android.system.kylin.\ncom.android.kylines.\n\n### Concealing Trojan modules from the list of installed packages\n\nThis function is used to obtain a list of all installed packages for applications. The Trojan\nsubstitutes the function to hide its modules from this list. The following modules will be\nexcluded from the list received from the original getInstalledPackages():\n\ncom.android.system.google.server.info\ncom.android.system.guardianship.info.server\ncom.android.sys.op\ncom.android.system.op.\ncom.android.system.kylin.\ncom.android.kylines.\n\n### Concealing Trojan modules from the list of installed applications\n\nThis function is used to obtain a list of all installed packages for applications. The Trojan\nsubstitutes the function to hide its modules from this list. The following modules will be\nexcluded from the list received from the original getInstalledPackages():\n\ncom.android.system.google.server.info\ncom.android.system.guardianship.info.server\ncom.android.sys.op\ncom.android.system.op.\ncom.android.system.kylin.\ncom.android.kylines.\n\n## Conclusion\n\n\n-----\n\nApplications that gain root access to a mobile device without the user s knowledge can\nprovide access to much more advanced and dangerous malware, in particular, to Triada, the\nmost sophisticated mobile Trojans we know. Once Triada is on a device, it penetrates almost\nall the running processes, and continues to exist in the memory only. In addition, all\nseparately running Trojan processes are hidden from the user and other applications. As a\nresult, it is extremely difficult for both the user and antivirus solutions to detect and remove\nthe Trojan.\n\nThe main function of the Trojan is to redirect financial SMS transactions when the user\nmakes online payments to buy additional content in legitimate apps. The money goes to the\nattackers rather than to the software developer. Depending on whether or not the user gets\nthe content he pays for, the Trojan either steals the money from the user (if the user does not\nreceive the content) or from the legitimate software developers (if the user receives the\ncontent).\n\nTriada has clearly been designed by cybercriminals who know the targeted mobile platform\nvery well. The range of techniques used by the Trojan is not found in any other known mobile\nmalware. The methods of concealing and achieving persistence used by Triada can\neffectively avoid detection and removal of all malware components after installation on the\ninfected device; the modular architecture allows attackers to extend and alter the\nfunctionality so they are limited only by the capabilities of the operating system and\napplications installed on the device. Since the malware penetrates all applications installed\non the system, the cybercriminals can potentially modify their logic to implement new attack\nvectors against users and maximize their profits.\n\nTriada is as complex as any malware for Windows, which marks a kind of Rubicon in the\nevolution of threats targeting Android. Whereas previously, the majority of Trojans for the\nplatform were relatively primitive, new threats with a high level of technical complexity have\nnow come to the fore.\n\n[Google Android](https://securelist.com/tag/google-android/)\n[Malware Statistics](https://securelist.com/tag/malware-statistics/)\n[Malware Technologies](https://securelist.com/tag/malware-technologies/)\n[Rooting Trojan](https://securelist.com/tag/rooting-trojan/)\n[Trojan Banker](https://securelist.com/tag/trojan-banker/)\n\nAuthors\n\nNikita Buchka\n\n\n-----\n\nMikhail Kuzin\n\nAttack on Zygote: a new twist in the evolution of mobile threats\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-03-03 - Attack on Zygote- a new twist in the evolution of mobile threats.pdf"
    ],
    "report_names": [
        "2016-03-03 - Attack on Zygote- a new twist in the evolution of mobile threats.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535851,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1653688793,
    "ts_modification_date": 1653688793,
    "files": {
        "pdf": "https://archive.orkl.eu/f6309f850fb7a6b45aa5c268b73d20714646f24b.pdf",
        "text": "https://archive.orkl.eu/f6309f850fb7a6b45aa5c268b73d20714646f24b.txt",
        "img": "https://archive.orkl.eu/f6309f850fb7a6b45aa5c268b73d20714646f24b.jpg"
    }
}