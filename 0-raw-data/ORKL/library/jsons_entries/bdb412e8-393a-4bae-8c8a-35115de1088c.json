{
    "id": "bdb412e8-393a-4bae-8c8a-35115de1088c",
    "created_at": "2023-01-12T15:03:43.98033Z",
    "updated_at": "2025-03-27T02:16:39.919446Z",
    "deleted_at": null,
    "sha1_hash": "62f4b4b7bf64eba4d1c9010b131c17860382c9d2",
    "title": "2020-06-19 - Further Evasion in the Forgotten Corners of MS-XLS",
    "authors": "",
    "file_creation_date": "2022-05-29T01:25:34Z",
    "file_modification_date": "2022-05-29T01:25:34Z",
    "file_size": 882218,
    "plain_text": "# Further Evasion in the Forgotten Corners of MS-XLS\n\n**[malware.pizza/2020/06/19/further-evasion-in-the-forgotten-corners-of-ms-xls/](https://malware.pizza/2020/06/19/further-evasion-in-the-forgotten-corners-of-ms-xls/)**\n\nJune 19, 2020\n\n[It’s been a few weeks since my last discussion of Excel 4.0 macro shenanigans and the1](https://malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/)\n[space continues to change. LastLine published a great report which summarized the2](https://www.lastline.com/)\nprogression of weaponized macros from February through May. The good folks at [InQuest](https://twitter.com/Inquest)\n[have continued 3](https://inquest.net/flash-alerts/IQ-FA004%3AMultiple_Actors_Abusing_New_Macro_Methods) [identifying 4](https://twitter.com/InQuest/status/1268568312499376130) [malicious 5](https://twitter.com/DissectMalware/status/1268491222299086854) [macro documents .6](https://twitter.com/Anti_Expl0it/status/1269895583633829888) [@DissectMalware‘s excellent](https://twitter.com/DissectMalware)\n[XLMMacroDeobfuscator has massively expanded its range of macro emulation, and7](https://github.com/DissectMalware/XLMMacroDeobfuscator)\n[FortyNorth Security released EXCELntDonut, a tool for converting Donut shellcode into8](https://twitter.com/FortyNorthSec) 9\nmulti-architecture Excel 4.0 macros.\n\n\nOver the past few weeks I’ve also started seeing some of the files generated by my tool\n[Macrome10 begin to trigger detections on VirusTotal . This is exactly the sort of thing I want11](https://github.com/michaelweber/Macrome)\nto see – besides the fact that it implies that AV is getting better signal on this attack vector, it\nalso provides an opportunity to improve my tool and take better guesses about what direction\n[attackers will pivot in the future. I’m a big believer in a @Mattifestation‘s approach to](https://twitter.com/mattifestation/)\n[detection engineering12 and detection from AV helps move the iterative development of](https://twitter.com/mattifestation/status/1263416936517468167)\ntooling further along.\n\nAfter realizing that some of my samples were being detected, I took several documents that\nhad been generated during testing and submitted each of them to VirusTotal – only the larger\ndocuments appeared to be matching virus signatures. I did a quick binary search of the\ndocument sizes between what was detected on VirusTotal and what wasn’t and discovered\nthat if a document had greater than 100 CHAR invocations, then it was considered\nmalicious.\n\n\n-----\n\nA “safe” document with exactly 100 =CHAR() expressions\n\nA document that has one too many =CHAR() expressions\n\n\n-----\n\nWhile my generated document had obfuscated the usage of the CHAR function, clearly there\nwas a signature that could detect these alternate CHAR invocations. For reference, here is\n[@DissectMalware’s macro_sheet_obfuscated_char rule13 that the generated document](https://pastebin.com/V8SGgdZL)\nattempted to avoid:\n```\nrule macro_sheet_obfuscated_char\n{\n meta:\n  description = \"Finding hidden/very-hidden macros with many CHAR functions\"\n  Author = \"DissectMalware\"\n  Sample = \"0e9ec7a974b87f4c16c842e648dd212f80349eecb4e636087770bc1748206c3b\n(Zloader)\"\n strings:\n  $ole_marker = {D0 CF 11 E0 A1 B1 1A E1}       \n  $macro_sheet_h1 = {85 00 ?? ?? ?? ?? ?? ?? 01 01}\n  $macro_sheet_h2 = {85 00 ?? ?? ?? ?? ?? ?? 02 01}  \n  $char_func = {06 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\n?? ?? ?? ?? 1E 3D 00 41 6F 00}\n condition:\n  $ole_marker at 0 and 1 of ($macro_sheet_h*) and #char_func > 10\n}\n\n```\nMy previous blog post discussed how to break the longer signature for `$char_func, but it`\ndidn’t address what to do if the signature for the CHAR function were more reliable. In this\n[case the signature was likely only the the three bytes of a PtgFunc14 invocation with the](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87ce512d-273a-4da0-a9f8-26cf1d93508d)\n**CHAR** **[Ftab value15 ( 41 6F 00 ) but repeatedly occurring enough times to avoid false](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/00b5dd7d-51ca-4938-b7b7-483fe0e5933b)**\npositives. This is likely the reason for the “high” minimum count requirement of 101+\ninstances versus the 11+ in the `macro_sheet_obfuscated_char rule.`\n\n\nAn\n\nobfuscated invocation of CHAR(65) that triggered results on VirusTotal after 101+ instances\nwere used\n[One “quick” hack to bypass this signature is to abuse the fact that PtgFuncVar16 can be](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/5d105171-6b73-4f40-a7cd-6bf2aae15e83)\nused instead of PtgFunc to invoke the CHAR function ( 42 01 6F 00 ). PtgFuncVar is\nlargely identical to PtgFunc except for the fact that PtgFuncVar must also be provided with\nthe number of arguments being passed into the called function. While PtgFunc is only used\nto call functions with a fixed number of arguments, there is nothing that stops us from\ninvoking PtgFuncVar and providing the correct argument count. PtgFunc(CHAR) is identical\nto PtgFuncVar(1,CHAR).\n\nHex\n\n\ndump of a **[FORMULA17BIFF8 record using the alternate PtgFuncVar(1,CHAR) invocation](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/8e3c6978-6c9f-4915-a826-07613204b244)**\n\n\n-----\n\nThis is a nice signature evasion trick, but it ultimately is vulnerable to the same method of\ndetection, just with a slightly different byte signature. Fundamentally, many tricks that macro\nsheets rely on in order to deobfuscate themselves will rely on invoking a handful of functions\nrepeatedly. Large macro payloads can require invoking some form of CHAR and FORMULA\nhundreds of times – what will adversaries do once there are better signatures put into place\nfor detecting suspiciously repeated usages of these functions?\n\n## Re-Enter the Subroutine\n\nIn normal programming, when we constantly call the same code over and over again, we\nwrite a function. Even in VBA macros, the idea of subroutines exist to allow for simple codereuse. While the [Excel 4.0 Macro Functions Reference18 mentions the idea of Excel 4.0](https://exceloffthegrid.com/using-excel-4-macro-functions/)\nmacro subroutines several times – it never actually details how these can be created.\n\nIn practice, Excel 4.0 macro subroutines are really just a sequence of RUN and RETURN\nfunctions. A subroutine is invoked by calling the RUN function with an argument referencing\nthe start cell of the sub-macro. Execution then starts at that cell and continues down the\ncolumn until a RETURN function is invoked. The argument passed to RETURN is what the\nreturn value of the function will be. For example, if we wanted to create a subroutine that\nwould eventually return the string “Hello World”, it would look something like this:\n\nA simple example of an Excel\n\n4.0 macro subroutine – it will eventually pop up an alert saying “Hello World”\nExcel actually even aliases the RUN command by letting users specify a cell reference or\ncell name and invoke it directly by appending () to the invocation as seen below:\n\nThis is functionally identical to\n\nthe previous Macro sheet\n\n\n-----\n\nThis is also the same, except\n\nB1 has been named MySub\nIt’s not a very common way to see macros used right now, but malware authors are clearly\n[already aware of this19 as can be seen from a sample shared by @JohnLaTwc and analyzed](https://www.twitter.com/JohnLaTwc)\nby [@DissectMalware:](https://www.twitter.com/DissectMalware)\n\n\n[Example behavior from a maldoc submitted to VirusTotal in March 201920 (Image from](https://www.virustotal.com/gui/file/a53be0bd2a838ffe172181f3953a2bc8a1b7c447fb56d885391921a7c3eac1f9/details)\n[@DissectMalware)](https://www.twitter.com/DissectMalware)\nWhile using subroutines in this way might be slightly helpful for slowing analysis of a\ndocument, it’s really only dipping its toes into the potential of “proper” subroutine usage in a\nmaldoc. For example, what if instead of having the byte sequence `41 6F 00 every time we`\ninvoked CHAR, we moved the CHAR expression into a subroutine and just invoked the\nsubroutine repeatedly? The predictable function invocation would only appear once, and it\nwould be much harder to claim that EVERY usage of CHAR is malicious. Even Windows\nDefender’s aggressive blocking of =CHAR(#) invocations requires other conditions beyond\nmatching three bytes. Here’s an example of what replacing the CHAR expression with a\nsubroutine looks like:\n\n\n-----\n\nWe can actually “create” our\n\nsubroutine at runtime using SET.NAME to specify the subroutine cell and its argument\nSo this is slightly different from our previous examples, but the main difference is that we are\ninvoking SET.NAME in order to specify two values:\n\n1. We are defining the value of InvokeCharSub to be equivalent to a reference to cell B1.\n\nLater we invoke it using InvokeCharSub(), though we could also use\n**RUN(InvokeCharSub).**\n2. We are setting the value of the name “arg” to 65. This is essentially how we pass\n\narguments to our subroutine. While there does appear to be an ARGUMENT function\nthat allows explicitly defining names to store arguments, I haven’t been able to make\nthis work any differently than just manually setting names or cell values. While porting\nEXCELntDonut macros into Macrome21 I also realized that you can simply write\n**arg=65 in an Excel cell, and it will automatically be interpreted as**\n**SET.NAME(“arg”,65)**\n\n\nWhat a User Defined Function invocation looks like in byte form\nUnder the covers when we call InvokeCharSub(), we are having Excel call a user defined\nfunction through the PtgFuncVar Parse Thing object. User defined functions are a\n**PtgFuncVar edge case – one of the arguments provided to the PtgFuncVar must be a**\n**[PtgName22. PtgName objects reference a Lbl23 entry stored within the Excel Workbook’s](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/5f05c166-dfe3-4bbf-85aa-31c09c0258c0)**\n[Globals Substream24. In this case, we are looking for the 3rd Lbl entry in the substream – it’s](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/ca4c1748-8729-4a93-abb9-4602b3a01fb1)\nalso worth noting that the index here starts at 1, rather than 0. We’ll come back to some “fun”\nthat malware authors can have with these labels later.\n\n\n-----\n\nThe Lbl list from our test document’s Globals Substream – the 3rd item is InvokeCharSub,\nour subroutine name\nSo we have a mechanism to replace our CHAR function invocations with SET.NAME\ninvocation followed by a call to a user defined function. This turns one very simple cell into\ntwo cells, but there’s a workaround for that as well. A final possible optimization to reduce the\nsize of our document is to combine our variable assignment with the invocation of our\nsubroutine by abusing the IF function to execute two expressions in a single cell – for\nexample:\n```\n=IF(SET.NAME(\"var\",65),invokeChar(),)\n\n```\nThe invocation of SET.NAME here saves us from having to use two cells to invoke our\nsubroutine and lets us use a single cell which cuts down on our FORMULA record count by\nabout half. This is the approach used by the CharSubroutine method in [Macrome10.](https://github.com/michaelweber/Macrome)\n\n[Going back to @Mattifestation‘s detection engineering approach – let’s think about how we](https://twitter.com/mattifestation/)\ncould detect this sort of approach and then analyze it. From a detection standpoint, a\nmassive number of invocations of SET.NAME and PtgFuncVar objects with a user defined\nfunction would likely stand out. For example, if we look at the above IF statement at the byte\nlevel we get something like:\n\nA\n\n\nsingle FORMULA record containing the SET.NAME and user defined function invocation\nWe can create a signature for this by keying on the presence of a PtgFuncVar invocation of\n**SET.NAME ( 42 02 58 00 ) with some arbitrary locality to a PtgFuncVar invoking a user**\ndefined function ( 42 ?? FF 00 – the Ftab value is `FF 00, but we need a wildcard since`\nwe can’t necessarily guess the argument count). Our signature doesn’t need to care if\n**SET.NAME comes before or after the user defined function, we just want to check for a large**\n[number of these instances. A Yara25 signature for this could look like:](https://virustotal.github.io/yara/)\n\n\n-----\n\n```\nrule msxls_set_name_and_invoke_udf\n{\n meta:\n  description = \"Finding XLS2003 documents with a suspicious number of SET.NAME and\nUser Defined Function invocations\"\n  Author = \"Michael Weber (@BouncyHat)\"\n strings:\n  $ole_marker = {D0 CF 11 E0 A1 B1 1A E1}\n  $setname_invokeudf = {42 02 58 00 [0-100] 42 ?? FF 00}\n  $invokeudf_setname = {42 ?? FF 00 [0-100] 42 02 58 00}\n condition:\n  $ole_marker at 0 and (#setname_invokeudf > 100 or #invokeudf_setname > 100)\n}\n\n```\nNote that the wildcard range `[0-100] probably makes this computationally expensive to`\nrun on a large dataset, but the upper bound of 100 wildcard bytes could be lowered as\nneeded.\n\nThis signature could still be avoided (as is true for most signatures) with a little additional\neffort on the part of the attacker. As demoed in [Outflank’s research26, we can use Excel’s](https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/)\n**WHILE functionality to iterate over a column of seemingly harmless numbers and use them**\nto build strings of binary data or additional macro statements to populate with the FORMULA\nfunction.\n\n_Here we have a Macro, starting_\n\n\n_at B1, that replaces our numerous CHAR() invocations with a subroutine at A1_\nBut let’s assume that there is a foolproof signature to identify our document and that our\ndocument has made its way into the hands of an analyst armed with a tool like\n[XLMMacroDeobfuscator or6](https://github.com/DissectMalware/XLMMacroDeobfuscator) [olevba27. Are there any weird behaviors that can be abused to](https://github.com/decalage2/oletools/wiki/olevba)\ntrick analysts attempting to examine our document? Thanks to Excel’s “flexibility” with Lbl\nrecords, the answer is yes.\n\n## (Ab)Using Names in Excel 4.0 Macros\n\nThe usage of Lbl record lookups when resolving names is another opportunity for malware\n[authors to frustrate analysis. In my previous blog post I discussed how Excel’s flexible1](https://malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/)\nhandling of the Auto_Open **Lbl record made signature creation extremely challenging. It**\n\n\n-----\n\nseems like similar issues would apply to variable and subroutine name invocation as well.\nFor example – what would you expect the output of the following macro sheet to be?\n\nAssuming case sensitivity\n\nwere used, the string “arg” should be displayed\n\nBut Excel Lbl records are\n\nmuch more flexible than that\nThis looks like a nice trick, but it doesn’t appear to do much to frustrate analysis – at a\nglance. Just HOW flexible is Excel’s interchangeability with upper case and lower case\nletters?\n\nWhat happens if we go into the Unicode character sets?\n\nObviously the lower case Zeta symbol (ζ)\n\nwas going to overwrite that capital Zeta (Ζ)\nIt’s pretty flexible. There are a surprising number of multi-case characters to confuse Excel,\n[just take a glance at the library of valid lower case Unicode characters28. Unfortunately, for](https://www.compart.com/en/unicode/category/Ll)\ndefenders, the **[PtgStr record29 used by Excel to invoke SET.NAME will happily allow](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87c2a057-705c-4473-a168-6d5fac4a9eba)**\nattackers to set arbitrary Unicode content for arguments, so this is a challenging situation to\navoid. The issues don’t stop at casing confusion either – Excel also respects Unicode\nEquivalence30. This behavior, which is part of the [Unicode specification31, is a](https://www.unicode.org/versions/Unicode13.0.0/UnicodeStandard-13.0.pdf) [consistent32](https://www.dionach.com/en-us/blog/fun-with-sql-injection-using-unicode-smuggling/)\n[source of pain33](https://hackernoon.com/%CA%BC-%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-how-unicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions-1224377f7b51) [in the security world34.](https://book.hacktricks.xyz/pentesting-web/unicode-normalization-vulnerability)\n\n\n-----\n\nOne example of how Unicode Equivalence can frustrate analysis is Decomposed Unicode.\nDecomposed Unicode values are alternate representations of Unicode characters that use a\nseries of characters instead of a single Unicode character. For example – consider the\n[Unicode character ḁ35. This can be represented as 2 bytes in UTF-16 (Excel’s Unicode](https://www.compart.com/en/unicode/U+1E01)\ninterpretation) as `1E 01 . Alternatively, we can represent it as the letter a and the` **��**\ncombining diacritical mark36 – or `00 61 03 25 . (Note: These diacritical marks are the`\nsame bit of fun that can be used to create [Zalgo monstrosities37)](https://zalgo.it/en/)\n\n[There also exist Unicode characters, like the Combining Graphene Joiner38 ( 03 4F ) which](https://en.wikipedia.org/wiki/Combining_Grapheme_Joiner)\nare essentially no-op characters for most Unicode strings. The Wikipedia article for the\ncharacter explicitly describes it as “default ignorable” in the first sentence:\n\n\n“The combining grapheme joiner (CGJ), U+034F  COMBINING GRAPHEME\nJOINER (HTML ) is a Unicode character that has no visible glyph and is “default\nignorable” by applications.”\n\n_[https://en.wikipedia.org/wiki/Combining_Grapheme_Joiner](https://en.wikipedia.org/wiki/Combining_Grapheme_Joiner)_\n\n[Finally, there are a sizable number of Unicode whitespace characters39 which can change](https://en.wikipedia.org/wiki/Whitespace_character)\nthe byte contents of a string without changing its appearance. The “most interesting” of these\nwhitespace characters are the zero-width Unicode characters. A zero-width character makes\nno visible change to the label. Some of these characters are ignored by Excel when\ncomparing strings (U+200C, U+200D, U+2060, and U+FFEF), but others (U+180E and\nU+200B) are not. These characters can be used to pad variable names, or create decoy\nnames that look the same but are not actually assigned when invoking SET.NAME.\n\nThere’s nothing fundamentally bad about following the Unicode specification, but combining\nsupport for Unicode equivalence with some of Excel’s other flexibility can lead to very\ncounter-intuitive equivalencies. For example, `1E 01 (ḁ) is considered the same as` `20 60`\n\n```\n00 41 03 25 03 4F 00 (a decomposed Ḁ with some ignored Unicode characters added to\n\n```\nthe string). Replacing some of those bytes with a `18 0E` or `20 0B would break the`\nequivalency as well, which allows us to create strings that look identical, but are not treated\n[as such by Excel. In practice this lets us create, using Macrome’s10](https://github.com/michaelweber/Macrome)\n**AntiAnalysisCharSubroutine method, the following content :**\n\n\n-----\n\nIt is random whether the first SET.NAME or second SET.NAME in each cell set the value\npassed to the subroutine\nAlthough the vḁr strings appear to be identical, they are in fact quite different on disk. This\nmeans that any analysis of the cell to figure out what will actually happen will require running\nExcel or manually reproducing Excel’s EXACT handling of Unicode characters. Reproducing\nthe behavior is going to require handling a lot of edge cases. If you want a sense of what\nanalysts could be up against, here’s what the above example looks like in binary:\n\nNote that both SET.NAME arguments are very different from the Lbl name used in\n**=RETURN(CHAR(‘vḀr’))**\nIn the above example the “Real” argument bytes are considered a match for the Lbl name\nbytes, but the “Decoy” argument bytes are not. The fact that Lbl record strings can be so\nwildly different from the PtgStr arguments passed to SET.NAME makes it challenging to\nfollow Excel’s data flow without actually running Excel. Even then, Excel isn’t consistent with\nhandling Unicode values – see what happens when null bytes are injected into the\n**Auto_Open label after the u character:**\n\n\n-----\n\nThe Name\n\nManager sees Au, but the cell label is AuTo_OpEn\nGiven the already low detection rate for Excel 4.0 macros in the wild, we may never see\nattackers need to rely on this level of trickery. If AV does start getting better signal with their\nsignatures though, I will not be surprised to see various forms of Unicode abuse begin to\ncrop up.\n\n## Updates to Macrome\n\nIn the process of digging deeper into Excel documents, I’ve often come across a need to\nexamine the byte content of specific records as a hex dump. While I don’t mind crawling\n[through a wall of hex text, I’ve managed to save some time by modifying my tool Macrome to](https://github.com/michaelweber/Macrome)\ndump the hex content of Lbl and Formula records. All of the hex examples from this post\nwere generated using this dump functionality. I’ve also implemented code for generating\nproof-of-concept documents using some of the subroutine and Unicode shenanigans that I\ndiscussed in this post. If you want to try generating some malicious documents to see how\nyour tooling will handle these kinds of documents I’d suggest heading over to\n[https://github.com/michaelweber/Macrome and grabbing the latest release.](https://github.com/michaelweber/Macrome)\n\nAs always, if folks have any suggestions for features or improvements, please let me know\nhere in the comments or open an issue on the Github project page.\n\n## References\n\n[1. https://malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/](https://malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/%E2%80%A8)\n[2. https://www.lastline.com/labsblog/evolution-of-excel-4-0-macro-weaponization/](https://www.lastline.com/labsblog/evolution-of-excel-4-0-macro-weaponization/%20%E2%80%A8)\n3. https://inquest.net/flash-alerts/IQ\nFA004%3AMultiple_Actors_Abusing_New_Macro_Methods\n[4. https://twitter.com/InQuest/status/1268568312499376130](https://twitter.com/InQuest/status/1268568312499376130)\n[5. https://twitter.com/DissectMalware/status/1268491222299086854](https://twitter.com/DissectMalware/status/1268491222299086854)\n[6. https://github.com/DissectMalware/XLMMacroDeobfuscator](https://github.com/DissectMalware/XLMMacroDeobfuscator%E2%80%A8)\n[7. https://twitter.com/Anti_Expl0it/status/1269895583633829888](https://twitter.com/Anti_Expl0it/status/1269895583633829888)\n[8. https://github.com/FortyNorthSecurity/EXCELntDonut/](https://github.com/FortyNorthSecurity/EXCELntDonut/%E2%80%A8)\n[9. https://github.com/TheWover/donut](https://github.com/TheWover/donut)\n[10. https://github.com/michaelweber/Macrome](https://github.com/michaelweber/Macrome)\n\n11. https://www.virustotal.com/gui/file/b159b25b80b1830acf40813c06a48f3e72666720b7ef\n\ncd406ea5031c7f214c31/detection\n\n\n-----\n\n[12. https://twitter.com/mattifestation/status/1263416936517468167](https://twitter.com/mattifestation/status/1263416936517468167)\n[13. https://pastebin.com/V8SGgdZL](https://pastebin.com/V8SGgdZL)\n14. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87ce512d-273a\n4da0-a9f8-26cf1d93508d\n15. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/00b5dd7d-51ca\n4938-b7b7-483fe0e5933b\n16. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/5d105171-6b73\n4f40-a7cd-6bf2aae15e83\n17. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/8e3c6978-6c9f\n4915-a826-07613204b244\n[18. https://exceloffthegrid.com/using-excel-4-macro-functions/](https://exceloffthegrid.com/using-excel-4-macro-functions/)\n[19. https://twitter.com/DissectMalware/status/1269535826813366273](https://twitter.com/DissectMalware/status/1269535826813366273)\n20. https://www.virustotal.com/gui/file/a53be0bd2a838ffe172181f3953a2bc8a1b7c447fb56\n\nd885391921a7c3eac1f9/details\n[21. https://github.com/michaelweber/Macrome/releases/tag/0.2.0](https://github.com/michaelweber/Macrome/releases/tag/0.2.0%E2%80%A8)\n22. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/5f05c166-dfe3\n4bbf-85aa-31c09c0258c0\n23. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/d148e898-4504\n4841-a793-ee85f3ea9eef\n24. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/ca4c1748-8729\n4a93-abb9-4602b3a01fb1\n[25. https://virustotal.github.io/yara/](https://virustotal.github.io/yara/%E2%80%A8)\n[26. https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/](https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/)\n[27. https://github.com/decalage2/oletools/wiki/olevba](https://github.com/decalage2/oletools/wiki/olevba)\n[28. https://www.compart.com/en/unicode/category/Ll](https://www.compart.com/en/unicode/category/Ll)\n29. https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87c2a057-705c\n4473-a168-6d5fac4a9eba\n[30. https://en.wikipedia.org/wiki/Unicode_equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n[31. https://www.unicode.org/versions/Unicode13.0.0/UnicodeStandard-13.0.pdf](https://www.unicode.org/versions/Unicode13.0.0/UnicodeStandard-13.0.pdf)\n[32. https://www.dionach.com/en-us/blog/fun-with-sql-injection-using-unicode-smuggling/](https://www.dionach.com/en-us/blog/fun-with-sql-injection-using-unicode-smuggling/)\n33. https://hackernoon.com/%CA%BC\n%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-howunicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions1224377f7b51\n[34. https://book.hacktricks.xyz/pentesting-web/unicode-normalization-vulnerability](https://book.hacktricks.xyz/pentesting-web/unicode-normalization-vulnerability)\n[35. https://www.compart.com/en/unicode/U+1E01](https://www.compart.com/en/unicode/U+1E01%E2%80%A8)\n[36. https://www.compart.com/en/unicode/U+0325](https://www.compart.com/en/unicode/U+0325%E2%80%A8)\n[37. https://zalgo.it/en/](https://zalgo.it/en/)\n[38. https://en.wikipedia.org/wiki/Combining_Grapheme_Joiner](https://en.wikipedia.org/wiki/Combining_Grapheme_Joiner)\n[39. https://en.wikipedia.org/wiki/Whitespace_character](https://en.wikipedia.org/wiki/Whitespace_character)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-19 - Further Evasion in the Forgotten Corners of MS-XLS.pdf"
    ],
    "report_names": [
        "2020-06-19 - Further Evasion in the Forgotten Corners of MS-XLS.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535823,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653787534,
    "ts_modification_date": 1653787534,
    "files": {
        "pdf": "https://archive.orkl.eu/62f4b4b7bf64eba4d1c9010b131c17860382c9d2.pdf",
        "text": "https://archive.orkl.eu/62f4b4b7bf64eba4d1c9010b131c17860382c9d2.txt",
        "img": "https://archive.orkl.eu/62f4b4b7bf64eba4d1c9010b131c17860382c9d2.jpg"
    }
}