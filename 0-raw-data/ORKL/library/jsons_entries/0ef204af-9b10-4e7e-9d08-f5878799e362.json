{
    "id": "0ef204af-9b10-4e7e-9d08-f5878799e362",
    "created_at": "2023-01-12T15:10:22.537364Z",
    "updated_at": "2025-03-27T02:06:12.9928Z",
    "deleted_at": null,
    "sha1_hash": "1c8b4db9c77e5c2afdb2b69de8b647da38afc6cd",
    "title": "2021-09-21 - BlackMatter Ransomware Technical Analysis and Tools from Nozomi Networks Labs",
    "authors": "",
    "file_creation_date": "2022-05-28T05:01:28Z",
    "file_modification_date": "2022-05-28T05:01:28Z",
    "file_size": 1433309,
    "plain_text": "# BlackMatter Ransomware Technical Analysis and Tools from Nozomi Networks Labs\n\n**[nozominetworks.com/blog/blackmatter-ransomware-technical-analysis-and-tools-from-nozomi-networks-labs/](https://www.nozominetworks.com/blog/blackmatter-ransomware-technical-analysis-and-tools-from-nozomi-networks-labs/)**\n\nBy September 21, 2021\n\n#### Over the last weekend, Iowa-based NEW Cooperative Inc. was the latest victim of the ransomware group BlackMatter. According to the company, which operates as a farmers’ cooperative, the incident has been actively handled, but at the time of this writing the full impact of the attack is not clear. In the media inquiries section of its website, BlackMatter explicitly lists a series of critical infrastructure targets that should not be targeted by its malicious operations. An organization the size of NEW Cooperative could very well be categorized as critical infrastructure. If that’s the case, this attack could have significant consequences. Modern supply chains are sometimes found to be vulnerable to sudden disruptions, with the full effects often understood only much later.\n\n In this blog, we describe the process that Nozomi Networks Labs took to analyze the BlackMatter ransomware executable, as well as ways the malware hinders analysis, and how we were able to overcome them. We provide some scripts that can help other researchers extract key information from other instances of this ransomware that surface in the wild.\n\n An Iowa-based farmers’ cooperative was hit by BlackMatter ransomware. Nozomi Networks Labs analyzes the executable.\n\n## Main Functionality\n\n#### The ransomware encrypts victims’ files with a version of the ChaCha20 and RSA algorithms. RSA is used to ensure that decryption is not possible without the private key stored on the attackers’ side. The malware leaves a note in the form of a README file with the steps to follow to decrypt them. In addition, it changes the wallpaper to bring attention to them:\n\n\n-----\n\n#### Wallpaper changed by the BlackMatter ransomware executable, drawing attention to a README file with decryption steps.\n (Click to enlarge) In addition, the malware performs various common ransomware actions such as:\n Deleting shadow copies (local backups) by first listing them using WMI query SELECT * FROM Win32_ShadowCopy Deleting files in the recycle bin Terminating processes and services specified in the configuration Changing the wallpaper to point to the README text file for decryption instructions\n```\n   Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7} is used for UAC (user account control) bypass\n\n Encrypted files will get a new file extension matching the victim id seen in the README file name prefix and also stored in the registry. This victim id is derived from the MachineGuid registry value.\n\n## Anti-debugging Techniques\n\n#### The malware attempts to thwart analysis by hiding which WinAPIs it relies on. To circumvent this, the malware resolves some of the required import functions by their hashes:\n\n```\n\n-----\n\n#### Identification of WinAPI function by hashed name To further complicate analysis, in case of bulk WinAPI address resolution by hashes, the malware uses a unique way of storing the addresses found. Instead of just storing them in a table, for every resolved WinAPI address, it randomly chooses one of five different ways to encode it (rol, ror, xor, xor+rol or xor+ror) and stores the encoded address together with a dynamically built code snippet that will decode it just before the call:\n\n Building code snippets to dynamically decrypt each API address and transfer control to it Here is one of the result proxy code snippets:\n\n Dynamically built code snippet to call the API Another anti-debugging trick used by malware is checking the presence of the 0xABABABAB sequence at the end of private heap blocks that it allocates to store these snippets. If the debugger is attached, this sequence will be added and the malware won’t store the address of the snippet in its custom import table, which will later result in the debugged sample crashing.\n\n\n-----\n\n#### Malware checks for the presence of the 0xABABABAB sequence revealing the debugger The strings are commonly decrypted on the fly, just before being used:\n\n With the help of IDAPython functionality, it is possible to automatically find and decrypt most of them:\n\n\n-----\n\n#### Here are some of the most important decrypted strings we pulled from the ransomware sample (see the script used below):\n```\nSOFTWARE\\Microsoft\\Cryptography\nMachineGuid\n__ProviderArchitecture\nROOT\\CIMV2\nID\nSELECT * FROM Win32_ShadowCopy\nWQL\nWin32_ShadowCopy.ID='%s'\nGlobal\\%.8x%.8x%.8x%.8x\nTimes New Roman\n.bmp\nControl Panel\\Desktop\nWallPaper\nWallpaperStyle\nZ:\\\ndllhost.exe\nElevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}\n%s.README.txt\nControl Panel\\International\nLocaleName\nsLanguage\nSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\nProductName\n%.8x%.8x%.8x%.8x%\nPOST\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n%s=%s\n%s=%s\n%.8x%.8x%.8x%.8x%\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n%u.%u\n%u.%u\n\\\\%s\\\nLDAP://rootDSE\nd f ltN i C t t\n\n```\n\n-----\n\n```\n        p,\ndNSHostName\n\\\\%s\\\nExchangeInstallPath\nProgram Files\nMailbox\nSOFTWARE\\%s\nhScreen\n\n## Configuration\n\n#### The sample’s encrypted configuration is stored in the .rsrc section, additionally compressed, and the individual fields are base64-encoded. The decrypted C2 configuration can be seen below. The sample can interact with both plain HTTP and HTTPS endpoints as evidenced by the set of C2.\n\n Configuration decryption and base64-encoded C2 Malware generates random HTTP query values when it communicates with these C2:\n\n Network communication with one of the C2 To secure communication, the AES algorithm is used.\n\n```\n\n-----\n\n#### Details of the targeted system in plaintext Here is the extracted configuration:\n```\n{\n    \"SHA256_SAMPLE\":    \"706F3EEC328E91FF7F66C8F0A2FB9B556325C153A329A2062DC85879C540839D\",\n    \"RSA_KEY\":   \n \"232FBA5316E1C9A3F0E603EF0ECB534A1FC1E8BA5F89DBD886D98FBF88EEDDE66CC65E00BBB827CD0262B65C505D95A008C48427A73AE6EB888EB4\n\n```\n```\n\"\" \" ti \"\n\n```\n\n-----\n\n```\n          }, {\n            \"\":    \"notepad\"\n        }, {\n            \"\":    \"ocomm\"\n        }, {\n            \"\":    \"onenote\"\n        }, {\n            \"\":    \"mspub\"\n        }, {\n            \"\":    \"thunderbird\"\n        }, {\n            \"\":    \"agntsvc\"\n        }, {\n            \"\":    \"sql\"\n        }, {\n            \"\":    \"excel\"\n        }, {\n            \"\":    \"powerpnt\"\n        }, {\n            \"\":    \"outlook\"\n        }, {\n            \"\":    \"wordpad\"\n        }, {\n            \"\":    \"dbeng50\"\n        }, {\n            \"\":    \"isqlplussvc\"\n        }, {\n            \"\":    \"sqbcoreservice\"\n        }, {\n            \"\":    \"oracle\"\n        }, {\n            \"\":    \"ocautoupds\"\n        }, {\n            \"\":    \"dbsnmp\"\n        }, {\n            \"\":    \"msaccess\"\n        }, {\n            \"\":    \"tbirdconfig\"\n        }, {\n            \"\":    \"ocssd\"\n        }, {\n            \"\":    \"mydesktopservice\"\n        }, {\n            \"\":    \"visio\"\n        }],\n    \"SERVICES_TO_KILL\":    [{\n            \"\":    \"mepocs\"\n        }, {\n            \"\":    \"memtas\"\n        }, {\n            \"\":    \"veeam\"\n        }, {\n            \"\":    \"svc$\"\n        }, {\n            \"\":    \"backup\"\n        }, {\n            \"\":    \"sql\"\n        }, {\n            \"\":    \"vss\"\n        }, {\n            \"\":    \"msexchange\"\n        }],\n    \"C2_URLS\":    [{\n            \"\":    \"https://mojobiden[.]com\"\n        }, {\n            \"\":    \"http://mojobiden[.]com\"\n        }, {\n            \"\":    \"https://nowautomation[.]com\"\n        }, {\n            \"\":    \"http://nowautomation[.]com\"\n\n```\n\n-----\n\n```\n          }],\n    \"LOGON_USERS_INFORMATION\":    [{\n            \"\":    \"<redacted>\"\n        }, {\n            \"\":    \"<redacted>\"\n        }, {\n            \"\":    \"<redacted>\"\n        }, {\n            \"\":    \"<redacted>\"\n        }, {\n            \"\":    \"<redacted>\"\n        }, {\n            \"\":    \"<redacted>\"\n        }],\n    \"RANSOM_NOTE\":    [{\n            \"\":    \"   ~+                    \\r\\n        *    +\\r\\n\n    '   BLACK    |\\r\\n   ()  .-.,='``'=.  - o -     \\r\\n      '=/_    \\\\   |     \n\\r\\n    *  | '=._  |        \\r\\n       \\\\   `=./`,    '  \\r\\n     .  '=.__.=' `='\n   *\\r\\n +       Matter    +\\r\\n   O   *    '    .\\r\\n\\r\\n>>> What happens?\\r\\n  Your\nnetwork is encrypted, and currently not operational. \\r\\n  We need only money, after payment we will give you a\ndecryptor for the entire network and you will restore all the data.\\r\\n\\r\\n>>> What data stolen?\\r\\n  From your\nnetwork was stolen 1000 GB of data.\\r\\n  If you do not contact us we will publish all your data in our blog and will\nsend it to the biggest mass media.\\r\\n  Blog post link: http://<redacted>.onion/<redacted>\\r\\n\\r\\n>>> What\nguarantees? \\r\\n  We are not a politically motivated group and we do not need anything other than your money. \\r\\n \nIf you pay, we will provide you the programs for decryption and we will delete your data. \\r\\n  If we do not give\nyou decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals.\n\\r\\n  We always keep our promises.\\r\\n\\r\\n>> How to contact with us? \\r\\n  1. Download and install TOR Browser\n(https://www.torproject.org/).\\r\\n  2. Open http://<redacted>.onion/<redacted>\\r\\n \\r\\n>> Warning! Recovery\nrecommendations. \\r\\n  We strongly recommend you to do not MODIFY or REPAIR your files, that will damage them.\"\n        }]\n}\n\n#### Overall, there are multiple similarities with the DarkSide ransomware family, including the way the victim id is derived from the MachineGuid value, the encryption techniques used, and the way the configuration is structured and protected. More information on the DarkSide executable can be found in our previous blog.\n\n## BlackMatter Ransomware Protection and Indicators of Compromise\n\n#### Nozomi Networks customers using our Threat Intelligence service are already covered against the described threat. In addition, Nozomi Networks Labs is monitoring this situation as it evolves and will extend coverage to customers and keep the community informed of major updates.\n\n For security professionals defending critical infrastructure operations, general recommendations for cyber resiliency against ransomware is found in our latest OT/IoT Security Report.\n\n For security researchers, the descriptions provided in this blog of how BlackMatter evades analysis, and how to extract key information from the code should be useful as the malware evolves.\n\n The indicators of compromise (IOC) that we learned from this analysis, as well as the scripts we used in the analysis are found below.\n\n## List of IOCs\n\n```\n```\nhash5 = \"f7b3da61cb6a37569270554776dbbd1406d7203718c0419c922aa393c07e9884\"\n\n```\n\n-----\n\n```\n        hash7 = \"e4a2260bcba8059207fdcc2d59841a8c4ddbe39b6b835feef671bceb95cd232d\"\n        nn_ts = \"1632088800.0\"\n        nn_sig = \"f7c69f3b527ffb3f0c2aa613e902d8d4f0e39966048bb6cfa57556115fa18ed9\"\n        nn_id = \"92f90d15-9392-4076-96b5-1e42ac9874c5\"\n    condition:\n        uint16(0)==0x5a4d and uint32( uint32(0x3c))==0x00004550 and filesize <100KB and\npe.imphash()==\"2e4ae81fc349a1616df79a6f5499743f\"\n}\n\n```\n\n## IDAPython Scripts\n\n#### Here is a script to restore the custom import table dynamically populated by malware. It defines the new hotkey Z that should be pressed when the cursor is located at the bulk decryption function (in case of this sample, at the RVA 0x78EC ).\n```\n# Author: Alexey Kleymenov (a member of Nozomi Networks Labs)\nimport os\nimport struct\nimport pefile\nimport ida_kernwin\nPATH_TO_DLLS = 'c:\\\\windows\\\\system32\\\\'\nHARDCODED_XOR_KEY = 0x17019FF8\ndef extract_api_hashes(start):\n  '''\n  Returns a dictionary where keys are import functions to write data and values are list of hashes\n  The first hash is the DLL name's hash, the rest are WinAPI names' hashes\n  '''\n  decryptor_address = start\n  print('Bulk API decryptor address: %x' % decryptor_address)\n  api_hashes = {}\n  for head in Heads():\n    flags = GetFlags(head)\n    if isCode(flags):\n      prev = prev_head(head)\n      prev_2 = prev_head(prev)\n      if print_insn_mnem(head) == 'call' and get_operand_value(head, 0) == decryptor_address:\n        print('Found the decryptor called: %x' % head)\n        if print_insn_mnem(prev) == 'push' and print_insn_mnem(prev_2) == 'push':\n          func_hashes = get_operand_value(prev_2, 0)\n          import_table = get_operand_value(prev, 0)\n          api_hashes[import_table] = []\n          for i in range(0, 0xffff, 4):\n            api_hash = struct.unpack(\"<I\", get_bytes(func_hashes + i, 4))[0]\n            if api_hash == 0xCCCCCCCC:\n              break\n            else:\n              api_hashes[import_table].append(api_hash ^ HARDCODED_XOR_KEY)\n        else:\n          print('Non-standard arguments %x' % head)\n  return api_hashes\ndef calculate_checksum(name, value):\n  '''\n  Standard ror 0x0D\n  '''\n  for symbol in name:\n    value = ((value >> 0x0D) | (value << (0x20 - 0x0D))) & 0xFFFFFFFF\n    value += ord(symbol) & 0xFFFFFFFF\n  return value\ndef build_mappings(dll_filepath, dll_hashes):\n  '''\n  This function calculates API checksums for the DLLs of interest\n  '''\n  dll_name = os.path.basename(dll_filepath)\n  dll_checksum = calculate_checksum(dll_name.lower() + '\\x00', 0)\n  result = {}\n  if dll_checksum in dll_hashes:\n    dll = pefile.PE(dll_filepath, fast_load=True)\n    dll.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']])\n    if hasattr(dll, 'DIRECTORY_ENTRY_EXPORT'):\n      dll_name = dll_name.replace('.', '_')\n\n```\n\n-----\n\n```\n           [ ] { }\n      export_directory = dll.DIRECTORY_ENTRY_EXPORT\n      for symbol in export_directory.symbols:\n        if symbol.name is not None:\n          api_name = symbol.name.decode('latin-1')\n          api_checksum = calculate_checksum(api_name + '\\x00', dll_checksum)\n          result[api_checksum] = {'dll_name': dll_name, 'api_name': api_name}\n  return result\ndef parse_dlls(path_to_dlls, dll_hashes):\n  '''\n  This function goes through all the files in the specified path and calculates export hashes for DLLs matching by\nname hashes\n  '''\n  list_dlls = os.listdir(path_to_dlls)\n  mappings = {}\n  for dll_filename in list_dlls:\n    full_path = os.path.join(path_to_dlls, dll_filename)\n    mappings.update(build_mappings(full_path, dll_hashes))\n  return mappings\ndef decrypt_all():\n  '''\n  The function expects the cursor to be located at the bulk decryption function\n  '''\n  start = get_screen_ea()\n  api_hashes = extract_api_hashes(start)\n  dll_hashes = []\n  for _, hashes in api_hashes.items():\n    dll_hashes.append(hashes[0])\n  dll_mappings = parse_dlls(PATH_TO_DLLS, dll_hashes)\n  for import_table, hashes in api_hashes.items():\n    dll_hash = hashes[0]\n    api_hashes = hashes[1:]\n    if dll_hash in dll_mappings:\n      print('Found DLL hash %x = %s' % (dll_hash, dll_mappings[dll_hash]['dll_name']))\n      for i, api_hash in enumerate(api_hashes):\n        if api_hash in dll_mappings:\n          addr = import_table + (i+1)*4\n          print('Found API hash for %x = %s (%s)' % (addr, dll_mappings[api_hash]['api_name'],\ndll_mappings[api_hash]['dll_name']))\n          set_name(addr, dll_mappings[api_hash]['api_name'])\n        else:\n          print('API hash %x not found' % api_hash)\n    else:\n      print('DLL hash %x not found' % dll_hash)\nida_kernwin.add_hotkey(\"z\", decrypt_all)\n\n#### In addition, here is a script to automatically search for and decrypt most of the encrypted strings:\n# Author: Alexey Kleymenov (a member of Nozomi Networks Labs)\nimport struct\nimport ida_kernwin\nHARDCODED_XOR_KEY = 0x17019FF8\ndef is_utf16_heur(string):\n  counter = 0\n  for val in string:\n    if val == 0:\n      counter += 1\n  if counter/float(len(string)) > 0.4:\n    return True\n  return False\ndef decrypt_string(start_addr):\n  addr = start_addr\n  result = b\"\"\n  for i in range(0xFFFF):\n    instr = print_insn_mnem(addr)\n    if instr != 'mov' or 'dword ptr' not in GetDisasm(addr):\n      break\n    value = get_operand_value(addr, 1)\n    decoded_value = value ^ HARDCODED_XOR_KEY\n    result += struct.pack(\"<I\", decoded_value)\n    addr = next_head(addr)\n  result_orig = result\n\n```\n\n-----\n\n```\n            ( )\n    result = result.decode('utf-16le')\n  else:\n    result = result.decode('latin-1')\n  if all(ord(c) < 128 for c in result):\n    result = result.rstrip('\\x00')\n  else:\n    result = 'hex: ' + result_orig.hex()\n  print('%x - %s' % (start_addr, result))\n  set_cmt(start_addr, result, 0)\ndef decrypt_string_manual():\n  start_addr = get_screen_ea()\n  decrypt_string(start_addr)\ndef search_for_encrypted_strings():\n  for head in Heads():\n    flags = GetFlags(head)\n    if isCode(flags):\n      if print_insn_mnem(head) == 'xor' and 'dword ptr' in GetDisasm(head) and get_operand_value(head, 1) ==\nHARDCODED_XOR_KEY:\n        next = next_head(head)\n        if print_insn_mnem(next) == 'add' and get_operand_value(next, 1) == 4:\n          prev = prev_head(head)\n          if 'mov   ecx' in GetDisasm(prev):\n            num = get_operand_value(prev, 1)\n            for i in range(num):\n              prev = prev_head(prev)\n            # print('Found the encryption string candidate: %x' % prev)\n            decrypt_string(prev)\nida_kernwin.add_hotkey(\",\", decrypt_string_manual)\nsearch_for_encrypted_strings()\n\n#### Related Content\n\n```\nRESEARCH REPORT\n\n### OT/IoT Security Report\n\n#### What You Need to Know to Fight Ransomware and IoT Vulnerabilities\n July 2021\n\n Why ransomware is a formidable threat Analysis of DarkSide, the malware that attacked Colonial Pipeline Latest ICS and medical device vulnerability trends Why P2P security camera architecture threatens confidentiality How security cameras are vulnerable Ten measures to take immediately to defend your systems\n\n\n-----\n\n#### o oad Related Links\n Blog: Colonial Pipeline Ransomware Attack: Revealing How DarkSide Works Blog: Responding to the Colonial Pipeline Breach and CISA Ransomware Alert Blog: OT and IoT Security: Adopt a Post-Breach Mindset Today Blog: Hard Lessons from the Oldsmar Water Facility Cyberattack Hack Executive Brief: The Cost of OT Cybersecurity Incidents and How to Reduce Risk Executive Brief: Business Leaders Need to Quickly Shift Focus to Industrial Cybersecurity\n\n Nozomi Networks Labs Nozomi Networks Labs is dedicated to reducing cyber risk for the world’s industrial and critical infrastructure organizations. Through our cybersecurity research and collaboration with industry and institutions, we’re helping defend the operational systems that support everyday life.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-21 - BlackMatter Ransomware Technical Analysis and Tools from Nozomi Networks Labs.pdf"
    ],
    "report_names": [
        "2021-09-21 - BlackMatter Ransomware Technical Analysis and Tools from Nozomi Networks Labs.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536222,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1653714088,
    "ts_modification_date": 1653714088,
    "files": {
        "pdf": "https://archive.orkl.eu/1c8b4db9c77e5c2afdb2b69de8b647da38afc6cd.pdf",
        "text": "https://archive.orkl.eu/1c8b4db9c77e5c2afdb2b69de8b647da38afc6cd.txt",
        "img": "https://archive.orkl.eu/1c8b4db9c77e5c2afdb2b69de8b647da38afc6cd.jpg"
    }
}