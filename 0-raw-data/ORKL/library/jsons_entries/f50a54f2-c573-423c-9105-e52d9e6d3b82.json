{
    "id": "f50a54f2-c573-423c-9105-e52d9e6d3b82",
    "created_at": "2023-01-12T15:08:31.092474Z",
    "updated_at": "2025-03-27T02:17:11.754561Z",
    "deleted_at": null,
    "sha1_hash": "3c0bafb92ba99a7b2c9e429d2627bf4fddeb930b",
    "title": "2022-01-11 - Signed kernel drivers – Unguarded gateway to Windows’ core",
    "authors": "",
    "file_creation_date": "2022-05-28T17:43:04Z",
    "file_modification_date": "2022-05-28T17:43:04Z",
    "file_size": 867485,
    "plain_text": "# Signed kernel drivers – Unguarded gateway to Windows’ core\n\n**[welivesecurity.com/2022/01/11/signed-kernel-drivers-unguarded-gateway-windows-core/](https://www.welivesecurity.com/2022/01/11/signed-kernel-drivers-unguarded-gateway-windows-core/)**\n\nJanuary 11, 2022\n\nESET researchers look at malware that abuses vulnerabilities in kernel drivers and outline\nmitigation techniques against this type of exploitation\n\n[Michal Poslušný](https://www.welivesecurity.com/author/mposlusny/)\n11 Jan 2022 - 11:30AM\n\nESET researchers look at malware that abuses vulnerabilities in kernel drivers and outline\nmitigation techniques against this type of exploitation\n\n\n-----\n\nThere are various types of kernel drivers; the first that come to mind are device drivers that\n[provide a software interface to hardware devices like plug and play interfaces or](https://en.wikipedia.org/wiki/Plug_and_play) _filter_\n_drivers. These low-level system components have a strict development process including_\nscrutiny regarding security. However, there are additional “software” drivers that are\ndesigned to run in Ring 0 and provide specific, non-hardware related features like software\ndebugging and diagnostics, system analysis, etc. As you can see below, these are prone to\nextend the attack surface significantly.\n\nWhile directly loading a malicious, unsigned driver is no longer possible in the newer\nversions of Windows (unless driver signature enforcement is explicitly disabled during boot)\nand kernel rootkits are considered to be a thing of the past, there are still ways to load\nmalicious code into the kernel. While actual vulnerabilities and exploits that achieve that get\na lot of attention, there is a much easier way: abusing legitimate, signed drivers. There are\nmany drivers from various hardware and software vendors lying around that offer\nfunctionality to fully access the kernel with minimal effort.\n\nVulnerabilities in signed drivers are mostly utilized by game cheat developers to circumvent\nanti-cheat mechanisms, but they have also been observed being used by several APT\ngroups and in commodity malware alike.\n\nThis paper discusses the types of vulnerabilities that commonly occur in kernel drivers,\nprovides several case studies of malware utilizing such vulnerable drivers, analyzes\nexamples of vulnerable drivers that we discovered during our research, and outlines\neffective mitigation techniques against this type of exploitation. While this problem is not\nnew and relevant research about the topic has been presented in the past, mainly during\n2018 and 2019 ([1], [2], [3]), it is still a problem as of this writing.\n\n## Common types of driver vulnerabilities\n\nWhile every vulnerability is different, similar types of vulnerabilities seem to be recurrent in\n[unrelated kernel drivers. This may be partially caused by (ancient) driver code samples that](https://github.com/LibreHardwareMonitor/LibreHardwareMonitor/blob/master/WinRing0/OpenLibSys.c)\nwere created back when access to kernel mode was not restricted to signed drivers and\ndevelopers did not take security into consideration (malware could simply load unsigned\nrootkit drivers instead). The following sections describe the vulnerabilities most frequently\nobserved in drivers from a large variety of, and even high-profile, hardware and software\nvendors.\n\n### MSR read/write\n\n_[Model-specific registers (MSRs) were introduced in Pentium 80586 CPUs in 1993. MSRs](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-software-developers-manual-volume-4-model-specific-registers.html)_\ncan be thought of as “global variables” of a CPU (or of a specific core). Some contain\nvarious information about the processor or specific CPU core – such as temperature,\npower, …. Additionally, there are also many MSRs that contain data critical for the working\nof a system, such as IA32_LSTAR (0xC0000082) for SYSCALL or IA32_SYSENTER_EIP\n\n\n-----\n\n(0x00000176) for SYSENTER, both of which contain pointers to an address in the kernel\nwhere the CPU jumps when a SYSCALL or SYSENTER instruction is executed. On newer\nWindows x64 platforms such as Windows 10 or 11, SYSCALL is used for both AMD and\nIntel CPUs where IA32_LSTAR should point to the KiSystemCall64 function found in\nntoskrnl.exe. The mechanism of the transition to Windows kernel when executing SYSCALL\nis displayed in Figure 1.\n\n_Figure 1. How SYSCALL is handled in x64 Windows_\n\n[MSRs are indexed by a number and accessed by the privileged RDMSR and](https://www.felixcloutier.com/x86/rdmsr) _[WRMSR](https://www.felixcloutier.com/x86/wrmsr)_\ninstructions, which can only be executed in kernel mode. Many commercial drivers\nimplement functionality for user-mode applications to access these instructions through an\nIOCTL mechanism. This is usually intended to be able to read or write a few specific\ninnocent MSRs (like CPU voltage, temperature, …), but developers sometimes do not add\nany additional checks to restrict access to critical MSRs, such as the example seen in\nFigure 2. This gives potential attackers an opportunity to, for example, patch the\nSYSCALL/SYSENTER entry point MSRs, which are pointers to a function that handles any\nsystem call from user mode.\n\n_Figure 2. Vulnerable MSR IOCTL handler in the AMDPowerProfiler.sys driver_\n\nOverwriting the system call pointer was trivial and very powerful on older CPUs and\nsystems before mitigations like Supervisor Mode Execution Prevention (SMEP) were\nintroduced. On such systems, simply changing the pointer to the address of an arbitrary\nuser-mode executable buffer containing malicious code, and then immediately executing a\nsystem call instruction on a same CPU core, was enough to gain kernel-level code\nexecution. This is no longer the case with newer systems due to modern exploitation\nmitigations. That being said, with clever use of various techniques, it is still possible to\nbypass most of these mitigations and achieve kernel-level code execution on Windows 10\nor even brand-new Windows 11 systems (as of December 2021).\n\n\n-----\n\nAll the mitigations in the following sections are in place on most modern machines and need\nto be bypassed to achieve successful kernel-mode exploitation.\n\n**_SMEP_**\n\nSMEP is a protection mechanism introduced in 2011 in Intel processors based on the Ivy\nBridge architecture and enabled by default since Windows 8.0. It prevents execution of\ncode in user-mode pages from Ring 0, and is implemented by assigning a user-mode or\nkernel-mode value to a flag bit on every virtual memory page in the page table. If a system\nattempts to execute code in a user-mode page from kernel space, a 0x000000FC error\n(ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY) will be triggered and cause a\nBSOD. SMEP can be dynamically toggled on and off during execution with its status saved\nin the CR4 register for each CPU core individually (see Figure 3).\n\n_Figure 3. CR4 register flags of a CPU (image credit: Wikipedia)_\n\nSMEP mitigates the naïve exploitation technique of abusing an MSR R/W IOCTL in order to\nchange the LSTAR MSR to point directly to malicious user-mode code. That being said,\nsince the attacker is in control of the stack that is passed to kernel mode on system calls,\n[they may utilize a technique called a ROP chain to manipulate the stack. By placing a chain](https://en.wikipedia.org/wiki/Return-oriented_programming)\n\n\n-----\n\nof return addresses on the stack, the attacker can arrange to execute a carefully picked set\nof instructions in kernel mode by changing the LSTAR MSR via a vulnerable IOCTL. With\nthe stack suitably prepared, executing the system call instruction results in the first “gadget”\nin the ROP chain executing and when complete its code will “return” to the next gadget in\nthe chain, which was supplied on the stack with the rest of the chain.\n\nThe functionality of such a ROP chain is limited by the availability of suitable code chunks,\ncalled gadgets, available in the kernel’s modules. Since an attacker can read kernel\nmodules from the file system and knows at which addresses the modules are loaded, the\ngadgets can be easily looked up and if those gadgets exist, a working ROP chain can then\nbe constructed.\n\nTo properly initialize the transition to kernel, the ROP chain needs to swap the GS register\nusing the SWAPGS instruction. On 64-bit Windows, the GS register holds the address of\nthe Thread Environment Block (TEB) in user mode, and the address of the Kernel\nProcessor Control Region (KPCR) in kernel mode. Therefore, it is crucial that those two\naddresses change before any operations happen in the kernel. It is no surprise that the\nSWAPGS instruction is also the first instruction in the Windows kernel KiSystemCall64\nfunction.\n\nThe next step is restoring the original value of the LSTAR MSR using the WRMSR\ninstruction, in order to avoid executing the ROP chain on the next execution of the\nSYSCALL instruction.\n\nAt this point, the malicious code properly executes in the kernel and the attacker can\nexecute whatever payload is desired. This can be additional ROP gadgets to, for example,\ndisable SMEP or SMAP protections by overwriting CR4, or even be direct calls to an\nexported ntoskrnl API function.\n\nThe attacker can overwrite CR4 utilizing a MOV CR4 gadget to disable SMEP and also\nSMAP, which is covered in the next section. They then can proceed to execute a user-mode\npayload directly. The only difficulty with this approach is precalculating a valid CR4 value.\nAlthough most of the CR4 values can be guessed from user mode by running the CPUID\ninstruction, there may be some inconsistencies between different versions of Windows.\n\nTo transition back to user mode safely, once the attacker’s ROP chain has run they need to\nexecute the SWAPGS instruction again and then execute the SYSRET instruction.\n\nOlder exploits bypassing SMEP are described in [4], (2015).\n\n**_SMAP_**\n\nSupervisor Mode Access Prevention (SMAP) is a newer mitigation that has been introduced\nto complement SMEP and further restrict access from the kernel to user-mode pages – it\ndisallows both reads and writes. Just as SMEP, its status is stored as a bit in the CR4\n\n\n-----\n\nregister (see Figure 3).\n\nSMAP should render the previously described ROP chain technique useless, since the\nstack containing the ROP chain is in fact a user-mode page. A system with SMAP active\nwill bluescreen the moment it tries to access the stack after transitioning to the kernel via\nthe system call.\n\nSMAP can also be temporarily disabled by setting the AC flag in the EFLAGS CPU register.\nThis feature is also the downfall of this mitigation in regard to MSR exploitation – it turns out\nthe AC flag can be set from user mode, right before transitioning to kernel mode, by utilizing\nthe POPF and PUSHF instructions. This is caused by the SFMASK MSR that controls\nwhich EFLAGS register bits are cleared when the SYSCALL instruction is executed. Even\non the newest Windows 11 machines, the mask does not have the AC flag bit set, which\nmeans it is not cleared upon transitioning to the kernel so SMAP can be disabled by the\nuser.\n\nAs the SFMASK is controlled by another MSR (0xC0000084), even if Microsoft changed\nSFMASK to implicitly clear the AC flag, theoretically the attacker could patch this MSR prior\nto the exploitation anyway.\n\nIt is worth noting that SMAP has only recently been enabled by default in Windows 10 x64\nwith newer hardware.\n\n**_KVA shadowing_**\n\n[KVA shadowing was introduced as a software mitigation for the Meltdown CPU vulnerability](https://meltdownattack.com/)\ndiscovered at the end of 2017.\n\nThe basic idea of this mitigation is that the virtual address space is split into two – user\nmode and kernel mode. The user-mode address space has access only to very restricted\nparts of the ntoskrnl module, specifically a single code section called .KVASCODE that is\nresponsible for low-level operations like entering and leaving the kernel when handling a\nsystem call. This is handled by implementing “Shadow” equivalents of the responsible\nfunctions, like KiSystemCall64Shadow that works as the original KiSystemCall64, but\ncontains differences responsible for handling KVA shadowing and switching the address\nspace context properly (see Figure 4). The rest of the kernel is completely separated and\nmapped to its own address space and cannot be accessed even directly by the CPU from\nuser-mode address space until the context is appropriately switched.\n\n\n-----\n\n_Figure 4. Comparison of KiSystemCall64 and KiSystemCall64Shadow versions of the system call_\n\n_handler – minor differences can be spotted at the beginning of the function_\n\nWhile KVA shadowing was designed as a fix for the Meltdown vulnerability, it also\npotentially causes trouble for other kinds of vulnerabilities, including the MSR one.\n\nThere are generally two approaches to disable the mitigation – one is to disable it as a\nsetting in the registry. This requires admin access and a reboot afterwards for the changes\nto take effect.\n\nAlternatively, when building a ROP chain for MSR exploitation, an attacker tries to find\ngadgets exclusively in the .KVASCODE section of the ntoskrnl module – since that section\nhandles the system call transition, it is possible to build a working ROP chain.\n\nSimilar mitigation was also introduced in Linux systems, where it is called Kernel Page\nTable Isolation (KPTI).\n\n### Physical memory read/write\n\n\n-----\n\nBeing able to directly read and write physical memory seems to be a common feature in\nmany low-level kernel drivers. This is achieved by mapping a specific range of physical\nmemory to a virtual memory buffer that can be read or written and even passed to a usermode application. There are several ways to achieve this, the most common one being an\nability to map the \\Device\\PhysicalMemory section to virtual memory, as shown in Figure 5.\n\n_Figure 5. Physical memory map vulnerability in Passmark DirectIO64.sys driver_\n\nA potential drawback for the attackers is that they first need to translate the virtual address\nto a physical one. Drivers that implement physical memory I/O sometimes also offer an\nIOCTL for physical to virtual address translation, but even if the driver does not have any\nsuch address conversion, there are still many ways to utilize this feature.\n\nThe most straightforward use case is simply to walk through all the physical memory\nlooking for specific artifacts that represent critical data structures that the attacker wants to\nfind. For example, the attacker might try to look for the EPROCESS structure of the\nmalicious process and elevate it to SYSTEM privileges by stealing a token from a more\n[privileged process or modifying its rights. Some of these strategies are demonstrated here](https://www.jackson-t.ca/lg-driver-lpe.html)\n[and here.](https://h0mbre.github.io/atillk64_exploit/)\n\nSince physical memory mappings disregard any virtual memory protection features, it is\nalso possible to write to executable memory pages. This gives the attacker an opportunity\nto look up specific kernel modules and chunks of code carefully modify them and if\n\n\n-----\n\npatched code can be executed via a system API or an IOCTL of a driver, to achieve\nmalicious kernel-level code execution.\n\n### Virtual memory read/write\n\nVirtual memory access IOCTLs are not as commonly found in these drivers as physical\nmemory ones, but they have very similar repercussions. Utilizing these is even easier, as\nthere is no address translation needed and all the virtual kernel addresses found from user\nmode can be accessed directly. A potential downside is that the access is limited by the\nmemory protection of the target address, so it is not possible to write read-only memory\npages without changing the protection first.\n\nTherefore, this vulnerability is commonly used to manipulate various kernel data structures\nto achieve things like elevating a malicious process to SYSTEM rights by stealing tokens\nfrom such kernel structures.\n\nThe most common way this vulnerability arises is via an IOCTL with a simple pointer\ndereference in kernel mode, so it can be hard to detect this vulnerability using heuristic\nmethods.\n\n## Case studies\n\nWhen malware actors need to run malicious code in the Windows kernel on x64 systems\nwith driver signature enforcement (DSE) in place, carrying a vulnerable signed kernel driver\nseems to be a viable option for doing so. This technique is known as Bring Your Own\nVulnerable Driver (BYOVD) and has been observed being used in the wild by both highprofile APT actors and in commodity malware.\n\nIn the following sections we present some examples.\n\n### Slingshot APT\n\nSlingshot is a cyberespionage platform that was uncovered by Kaspersky in 2018 [5] and is\nbelieved to have been active since at least 2012. The actors behind this malware decided to\nimplement their main module, called Cahnadr, as a kernel-mode driver. On older x86\nsystems, the driver would be loaded directly by the user-mode module. On newer systems\nwith active DSE, they decided to implement a custom driver loader that leverages the\n[following signed kernel drivers with MSR vulnerabilities: Goad, SpeedFan (CVE-2007-](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2018/03/09133534/The-Slingshot-APT_report_ENG_final.pdf)\n_[5633), Sandra (CVE-2010-1592), and ElbyCDIO (CVE-2009-0824). The exploitation](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1592)_\ntargeted pre-Windows 8 systems, so the exploitation was a simple modification of the\nLSTAR MSR to point to a malicious payload in a user-mode buffer.\n\nNote that the Kaspersky researchers estimated these threat actors to have been active from\n2012 to 2018, which means that these exploits were quite old and well known, but that was\nno reason for the attackers to stop using them as the certificates of those vulnerable drivers\n\n\n-----\n\nwere never revoked.\n\n### InvisiMole\n\nIn 2018, fellow ESET researchers uncovered a sophisticated APT actor that they named\nInvisiMole [6]. The group has been tracked by ESET ever since and in 2020 an extensive\n_[white paper about the group and its toolset was published. In that white paper, our](https://www.welivesecurity.com/wp-content/uploads/2020/06/ESET_InvisiMole.pdf)_\ncolleagues reported that InvisiMole used the BYOVD technique, exploiting the MSR\nvulnerability in the speedfan.sys driver (CVE-2007-5633) to load a malicious unsigned\ndriver. While this campaign was targeting older x86 systems and the exploitation using a\nmalicious driver was trivial from the modern standpoint, due to the fact there were no\nmitigations like SMEP in place, it was still an interesting case showing that the group behind\nthis malware is very technically capable.\n\nLater during that investigation, however, a newer variant of the InvisiMole malware using\nthe BYOVD technique was discovered. This variant is the only case to date that we have\nobserved of MSR exploitation on Windows 10 x64 systems being used in the wild by a\nmalicious actor. It employs advanced techniques to bypass mitigations like SMEP and even\nSMAP. That being said, the exploitation is mitigated by KVA shadowing, which the authors\nfailed to take care of. Coincidentally, MSR exploitation was used to deploy a malicious\ndriver that attempted to disable our security products. Although the whole compromise\nchain is more extensive, we will focus on a specific part of the malware that leverages the\nBYOVD technique and MSR exploitation that happens in the main user-mode module.\n\n**_User-mode module_**\n\nInvisiMole’s authors seem to have developed a sophisticated ROP chain exploitation\nframework that they use for MSR exploitation – although the sample contains many debug\nmessages in the code, we were not able to identify and link them to any known projects.\nThis leads us to believe the framework is an original work of these malware authors and\nthat non-negligible resources have been spent on developing it. The framework is an\nextensive C++ codebase with various classes.\n\nIt appears that InvisiMole’s authors did not know about the possibility of setting the AC flag\nwith the PUSHF and POPF instructions as described in the SMAP section, and instead\nchose a very complex ROP gadget found in the MiDbgCopyMemory kernel function that\nstarts with the privileged STAC instruction, which is dedicated to setting the AC flag (see\nFigure 6). On top of that, InvisiMole utilizes the IRETQ instruction after every gadget that\nexplicitly sets the RFLAGS register with the AC flag set, which stabilizes the exploit even\nfurther.\n\n\n-----\n\n_Figure 6. ROP gadget used by InvisiMole to disable SMAP mitigation_\n\nThe initial gadget jumps directly to the STAC instruction, which immediately disables SMAP\nby setting the AC flag. Since this gadget appears in the middle of the MiDbgCopyMemory\nfunction, the malware carefully prepares the stack and registers to safely leave the function.\nOnce the MiDbgCopyMemory function returns, the ROP chain proceeds to the SWAPGS\ngadget [7] in order to properly switch to kernel mode, followed by the WRMSR gadget to set\nthe LSTAR MSR back to its original value. At this point, InvisiMole will proceed with\nexecuting the payload, which may be an exported kernel function or the entry point of a\nloaded malicious driver.\n\n**Driver loader**\n\nThe driver loading technique is quite complex – InvisiMole will first install a “driver loader” –\nanother kernel driver module that is used to load the malicious payload (yet another driver)\npassed as an argument. To initialize the driver loader, InvisiMole executes several separate\nMSR exploitations, where every instance carries a dedicated ROP chain with a single API\ncall payload. The malware will start by executing ExAllocatePoolWithTag to allocate an\nexecutable kernel memory buffer for the loader, followed by preparing the image in user\nmode to reflect its future address in the kernel – sections are moved to their virtual offsets;\nimports are resolved, and relocations fixed. Once the image is ready, it is copied over from\nuser mode to the allocated kernel buffer using memcpy from the ntoskrnl module.\n\n\n-----\n\nTo transfer code execution to the loader once it is copied to the kernel, InvisiMole s authors\nalso leverage the MSR vulnerability and designed several dedicated PE exports in the\nloader (see Figure 7 for an example) that are intended to handle transitions from user-mode\nsystem calls. It works very similarly to the ROP chain gadgets – swap the GS register, swap\nthe user-mode and kernel-mode stacks, save all registers on the stack, restore the original\nLSTAR MSR value and then call the actual function. Once finished, this process is reversed.\n\n_Figure 7. Exported function in the driver loader module that is called by changing LSTAR MSR_\n\nWhen the loader is properly initialized in the kernel, an export named _Start64 is executed\nby changing LSTAR MSR to the export address in the kernel. After handling the transition to\nthe kernel, _Start64 registers a deferred routine that is responsible for loading the payload\ndriver, and returns to user mode. The deferred loader routine will attempt to initialize the\npayload driver in a “proper” fashion – creating registry keys and kernel driver objects,\nperforming all the necessary steps to register the driver in the system as if the operating\nsystem were loading the driver itself, and eventually calling IoCreateDriver. The proper\ninitialization approach was chosen so the loaded payload driver can process I/O request\npackets and communicate with a user-mode module using IOCTLs.\n\n**Payload driver**\n\nThe payload driver offers IOCTL functionality for disabling various notification callbacks (see\nFigure 8), mostly aimed at disarming third-party security solutions, and the possibility of\nprotecting a file in the file system. The specific commands are passed from the user-mode\nmodule. Interestingly, the user-mode module will attempt to disable various parts of ESET\nprotection in the kernel.\n\n\n-----\n\nFigure 8. IOCTL handler in the InvisiMole payload driver\n\n### RobbinHood\n\nSeeing a BYOVD technique in commodity malware that aims to reach as many people as\npossible is rare, but the RobbinHood ransomware family shows that it may still prove\nuseful [8].\n\nThis ransomware leverages a vulnerable GIGABYTE motherboard driver GDRV.SYS (CVE_2018-19320; see Figure 9 and Figure 10) to disable DSE in order to install its own malicious_\ndriver.\n\n\n-----\n\n_Figure 9. GIODrv driver exploitation in RobbinHood sample_\n\nThe way DSE is disabled depends on the Windows version – on Windows 7 and older, an\nnt!g_CiEnabled variable is modified directly in the ntoskrnl module. On newer Windows 8\nthrough Windows 11 systems, the variable ci!g_CiOptions in the ci.dll module is modified\ninstead. Finding this variable is slightly more complicated and it looks like the authors\n[adopted a method found in an open-source project called DSEFix that is available on](https://github.com/hfiref0x/DSEFix)\n[GitHub. Moreover, since Windows 8.1, the variables in ci.dll are protected by PathcGuard](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)\nand tampering with the module will eventually cause the system to BSOD, even if the\nvariable is changed back to an original value.\n\nThe malicious driver is then used to kill a long list of processes and delete their files, mainly\nfocusing on endpoint protection software and other utilities. Since the termination is done\nfrom kernel mode, most self-protection mechanisms employed by security software are\ncircumvented and the technique is more likely to succeed than attempting to disarm the\nprotections from user mode.\n\n\n-----\n\n_Figure 10. WriteVirtualMemory IOCTL handler in GIODrv_\n\n### LoJax\n\n[In 2018, ESET researchers discovered the first-ever UEFI rootkit used in the wild. In order](https://www.welivesecurity.com/2018/09/27/lojax-first-uefi-rootkit-found-wild-courtesy-sednit-group/)\nto have access to victims’ UEFI modules, the malware utilizes a powerful utility called\nRWEverything.\n\nThe RWEverything driver was recently disabled by Microsoft directly in Windows 10 and 11\nusing the HVCI memory integrity feature described in the Virtualization-based security\nsection.\n\n## Discovered vulnerabilities\n\nDuring our research we decided not only to catalog existing vulnerabilities, but also to look\nfor new ones. We set up YARA rules to hunt for kernel drivers with specific functionality and\nindicators of being potentially vulnerable. We also created a proof-of-concept exploitation\nframework for testing the newly found drivers and confirming that they are exploitable.\n\nWe went through hundreds of different kernel drivers that matched our criteria and aside\nfrom finding the already discovered drivers, we also found three drivers previously not\nknown to be vulnerable, some containing several unrelated bugs. The fact that even after\n\n\n-----\n\nseveral independent research groups tackled this area we were still able to find new\nvulnerabilities, even from reputable vendors, shows that Windows driver security is still an\nissue.\n\nWhile we were looking for all kinds of vulnerabilities described in previous sections, finding\nones with MSR access turned out to be the easiest, appearing most commonly due to the\nuse of special privileged instructions (RDMSR/WRMSR) that give away this functionality.\nInterestingly enough, in many cases it would turn out that this class of drivers also\ncontained other kinds of vulnerabilities like arbitrary physical or virtual memory read and\nwrite functions.\n\n### AMD μProf (CVE-2021-26334)\n\nWe have identified an MSR vulnerability in the AMDPowerProfiler.sys kernel driver, which is\na part of _[AMD μProf profiling software.](https://developer.amd.com/amd-uprof/)_\n\nWhat makes this driver stand out is that once the underlying software package is installed,\nthe driver runs on every system boot. The unfiltered MSR IOCTL access combined with the\nlack of FILE_DEVICE_SECURE_OPEN flags (see Figure 11) and on-boot presence gives\nthe attacker a good opportunity to exploit the driver even as an unprivileged user – this is an\nadvantage compared to the BYOVD approach when the attacker needs to load the driver\nthemselves.\n\n_Figure 11. AMD uProf kernel driver device creation without the FILE_DEVICE_SECURE_OPEN flag_\n\n_allowing non-admin access_\n\nOn the other hand, the software is a niche utility for developers and not a package\ndistributed to a large number of systems. We have not identified any other vulnerability in\nthe driver.\n\nThe vulnerable IOCTL is IOCTL_ACCESS_MSR (0x222030).\n\n[AMD acknowledged the vulnerability (CVE-2021-26334) and released a fix in the November](https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1016)\n2021 _[Patch Tuesday release.](https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1016)_\n\n### Passmark software\n\n\n-----\n\nPassmark is a company offering various computer benchmark and diagnostic tools. To\nachieve such functionality in user mode, a lot of low-level system features need to be\naccessed by leveraging a kernel-mode driver.\n\nPassmark’s DirectIo32.sys and DirectIo64.sys kernel drivers are a common framework\nshared and distributed among several of the vendor’s applications – namely BurnInTest,\nPerformanceTest and OSForensics.\n\n[The driver contains direct, unfiltered MSR R/W access (CVE-2020-15480), an ability to map](https://github.com/eset/vulnerability-disclosures/blob/master/CVE-2020-15480/CVE-2020-15480.md)\n[physical memory (CVE-2020-15481) for both reading and writing, and the IOCTL handler](https://github.com/eset/vulnerability-disclosures/blob/master/CVE-2020-15481/CVE-2020-15481.md)\n[also contains a buffer overflow (CVE-2020-15479) due to blindly copying, without any size](https://github.com/eset/vulnerability-disclosures/blob/master/CVE-2020-15479/CVE-2020-15479.md)\ncheck, an IOCTL input buffer of arbitrary size to a local variable on the stack.\n\nPassmark acknowledged these vulnerabilities and released a fixed version soon thereafter.\n\n**_CVE-2020-15479_**\n\nWhen the driver receives an IOCTL request from a user-mode program, it will first copy the\nrequested input buffer into a local buffer on the stack. The size of the memmove is based\nonly on the size of the input buffer (see Figure 12) and does not consider the capacity of the\nstack buffer. This may lead to a buffer overflow, if a large enough IOCTL buffer is provided.\nThere are multiple unchecked memmove calls in the IOCTL handler function and several\nIOCTLs can be used to leverage the buffer overflow.\n\n_Figure 12. Buffer overflows in the vulnerable Passmark drivers_\n\n**_CVE-2020-15480_**\n\nThis driver offers RDMSR and WRMSR functionality exposed via an IOCTL that allows an\nunprivileged user-mode program to read and write arbitrary CPU MSRs without any\nadditional checks. The vulnerable IOCTLs are IOCTL_READ_MSR (0x80112060) and\n\n\n-----\n\nIOCTL_WRITE_MSR (0x80112088).\n\n**_CVE-2020-15481_**\n\nPhysical memory mapping functionality is exposed via a single control code –\nIOCTL_MAP_PHYSICAL_MEMORY (0x80112044). The implementation is split into two\nparts: the primary version is done through the ZwMapViewOfSection API; if for some reason\nthis method fails, the function also implements a secondary approach as a backup, through\nthe MmMapIoSpace and MmMapLockedPages kernel APIs. Both are illustrated in Figure\n13.\n\n_Figure 13. Physical memory IOCTL implementation in Passmark’s drivers_\n\n### Devid Espenschied PC Analyser\n\nPC Analyser is another utility for inspecting various details about the machine. The\nPCADRVX64.sys kernel driver distributed with the application contains two separate\n[vulnerabilities – unfiltered MSR access (CVE-2020-28921) and ability to read from and write](https://github.com/eset/vulnerability-disclosures/blob/master/CVE-2020-28921/CVE-2020-28921.md)\n\n\n-----\n\n[to arbitrary physical memory addresses (CVE-2020-28922). When creating the driver](https://github.com/eset/vulnerability-disclosures/blob/master/CVE-2020-28922/CVE-2020-28922.md)\ndevice, the FILE_DEVICE_SECURE_OPEN flag is unspecified, allowing unprivileged users\nto retrieve a handle to the driver.\n\nDevid Espenschied acknowledged the vulnerabilities and released an updated version.\n\n**_CVE-2020-28921_**\n\nAs with previous drivers, MSR access is unrestricted (see Figure 14) and the IOCTL code\nhandler contains FILE_ANY_ACCESS flags allowing even an unprivileged user to leverage\nthe functionality.\n\n_Figure 14. MSR IOCTL implementation in PC Analyser driver_\n\n**_CVE-2020-28922_**\n\nThe driver’s physical memory read and write functionality is implemented with separate\nIOCTLs based on the size of the read or write request. It offers the following control codes,\nnone of which make any checks on the memory addresses targeted by the request:\n\n\n-----\n\nIOCTL_READ_PHYSICAL_MEMORY_BYTE (0x82002400)\nIOCTL_READ_PHYSICAL_MEMORY_WORD (0x82002500)\nIOCTL_READ_PHYSICAL_MEMORY_DWORD (0x82002600)\nIOCTL_WRITE_PHYSICAL_MEMORY_BYTE (0x82002700)\nIOCTL_WRITE_PHYSICAL_MEMORY_WORD (0x82002800)\nIOCTL_WRITE_PHYSICAL_MEMORY_DWORD (0x82002900)\n\n## Mitigations\n\nWhile we have already mentioned several mechanisms employed by the CPU and/or the\noperating system, most of them can be bypassed with some clever techniques and are not\nvery effective if the attacker prepares for them ahead of time. In this section we would like to\nmention some mitigation ideas that are actually effective at completely stopping the abuse\nof vulnerable drivers.\n\n### Virtualization-based security\n\n_[Virtualization-based security or VBS is a feature introduced in Windows 10 that leverages](https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs)_\nhardware virtualization and makes the kernel sandboxed by a hypervisor in order to secure\nthe operating system with various protections.\n\nVBS offers several protection features with the most prominent one being HypervisorProtected Code Integrity (HVCI), which also comes as a standalone feature. HVCI enforces\ncode integrity in the kernel and allows only signed code to be executed. It also employs\nblocklisting functionality, where a known piece of code signed by a specific, valid signature\ncan be blocklisted and not allowed to be run or to be loaded. One of the drivers that has\n_been blocklisted already via this method is the RWEverything utility._\n\nHVCI effectively prevents vulnerable drivers from being abused to execute unsigned kernel\ncode or load malicious drivers (regardless of the exploitation method used) and it seems\nthat malware abusing vulnerable drivers to load malicious code was one of the main\n_motivations behind Microsoft implementing this feature:_\n\nVBS provides significant security gains against practical attacks including several we saw\nlast year, including human-operated ransomware attacks like RobbinHood and\n_sophisticated malware attacks like Trickbot, which employ kernel drivers and techniques_\n_that can be mitigated by HVCI. Our research shows that there were 60% fewer active_\nmalware reports from machines reporting detections to Microsoft 365 Defender with HVCI\nenabled compared to systems without HVCI. The Surface Book 3 shipped in May 2020 and\nthe Surface Laptop Go shipped in October 2020, and users may not have noticed they are\nrunning VBS and are therefore better protected based on the work done under the hood.\n\n_[emphasis added]_\n\n\n-----\n\nAside from enforcing kernel code integrity, VBS also secures important MSRs and disallows\nany changes to them. Unsurprisingly, this protection also affects the LSTAR MSR and\nmitigates all of the exploitation possibilities described above.\n\nWhile VBS is an effective protection against MSR exploitation and running malicious code\nin the kernel in general, the adoption of this new feature is quite limited, as it has several\n_hardware requirements that only newer machines can fulfill. There are also some_\n[drawbacks with the most notable being a performance hit, which may be quite noticeable](https://www.tomshardware.com/news/windows-11-gaming-benchmarks-performance-vbs-hvci-security)\ndepending on the workload. While some benchmarks estimate the performance hit being as\n_[high as 25% in specific video games, the more detailed benchmarking by Tom’s Hardware](https://www.tomshardware.com/news/windows-11-gaming-benchmarks-performance-vbs-hvci-security)_\nestimates the performance hit being around 5% depending on the specific benchmarks and\nhardware configuration (see Figure 15), which is still not a negligible amount and may lead\nsome users to consider turning this feature off. There might also be some compatibility\nissues with legacy drivers and software. With the release of Windows 11, Microsoft has\ndecided to enable HVCI by default for all compatible devices.\n\n_[Figure 15. VBS benchmark results by Tom’s Hardware](https://www.tomshardware.com/news/windows-11-gaming-benchmarks-performance-vbs-hvci-security)_\n\n**_Third-party hypervisor_**\n\nSimilar to Microsoft’s VBS, with new enough hardware, a third-party security solution may\ndeploy its own custom hypervisor. Running the operating system under a hypervisor gives a\ndetailed oversight of the state of the machine and provides the possibility of inspecting and\nintercepting any event including execution of a specific instruction. As with VBS, this comes\nat a cost, namely performance and compatibility.\n\n### Certificate revocation\n\nOn modern Windows systems, drivers need to have a valid signature based on an\n“acceptable” certificate. Hence, revoking the certificate of a vulnerable driver would be an\neasy way to “disarm” it and render it useless in most cases.\n\n\n-----\n\nSadly, revocation rarely ever happens and of the vulnerable drivers documented in our\nresearch above, not a single one of them has had its signature revoked. There are probably\na multitude of reasons why such revocations are not happening, but the primary ones are\nlikely to be time and cost. As nobody requires the revocation, it does not make much sense\nfrom the vendor’s standpoint to ask for revocation, as this will be a costly and timeconsuming process. Moreover, a signing certificate is usually shared among other projects,\nso the potential revocation because of a single driver could hinder the development of every\nproject.\n\n[Further, during our research we learned that drivers with revoked certificates are not always](https://decoded.avast.io/martinchlumecky/dirtymoe-3/)\nblocked and that this problem is more complicated than it seemed at first. Revocation may\nnot be the easiest solution after all.\n\n### Driver blocklisting\n\nDriver blocklisting is a practice adopted by both Microsoft and various third-party security\nproduct vendors. Several of the most notorious vulnerable drivers are detected by ESET\nsecurity products and deleted when found on a system. Microsoft also opted to blocklist\ndrivers not only with its security solution, but also directly by the operating system utilizing\ntheir HVCI mitigation, which is part of virtualization-based security. While blocklisting is\neffective, it is not a proactive solution – only previously discovered vulnerable drivers can be\nblocklisted, and it must be done manually by each vendor. This means that this mitigation\nwill not be effective against previously unknown, zero-day driver vulnerabilities that may be\nused in a sophisticated APT attack.\n\nProbably the most prominent blocklisted driver is the Capcom “anti-cheat” driver\nCapcom.sys, which explicitly implements an IOCTL that simply executes the contents of the\nprovided buffer in kernel mode (see Figure 16). To be able to execute a buffer provided from\nuser mode, it even temporarily disables SMEP!\n\nWhen discovered, the driver made several headlines and many unsigned driver loader tools\nwere created based on abusing this function of the driver. Consequently, the driver was\n[eventually blocklisted by many security product vendors including Microsoft and ESET.](https://www.virustotal.com/gui/file/da6ca1fb539f825ca0f012ed6976baf57ef9c70143b7a1e88b4650bf7a925e24)\n\n\n-----\n\n_Figure 16. Code snippet from Capcom anti-cheat driver_\n\n## Conclusion\n\nVulnerable drivers have been a known problem for a long time and have been abused by\nthe game-cheating community and malware authors alike, and while some effort has been\nmade to mitigate the effects, it is still an ongoing battle. It seems that all the responsible\nparties involved want to solve this problem – the vendors we contacted were incredibly\nproactive during the disclosure process, eager to fix the vulnerabilities we uncovered.\nMicrosoft is trying to strengthen the operating system from the inside and last but not least,\nthird-party security vendors are trying to come up with clever ways to detect and mitigate\nsuch drivers themselves.\n\nHowever, it seems that there is still a piece missing – a common, unified way of handling\nthese issues including more thorough “disarming” of the drivers, whether by revoking or\nblocklisting their certificates, or some public, shared blocklists adopted by the security\ncompanies.\n\n## Bibliography\n\n[[1] J. Desimone and G. Landau, “BlackHat 2018: Kernel-mode Threats and Practical Defences,” 9 August 2018.](https://i.blackhat.com/us-18/Thu-August-9/us-18-Desimone-Kernel-Mode-Threats-and-Practical-Defenses.pdf)\n\n[Online].\n\n[[2] R. Warns and T. Harrison, “INFILTRATE 2019: Device Driver Debauchery and MSR Madness,” 2 May 2019.](https://downloads.immunityinc.com/infiltrate2019-slidepacks/ryan-warns-timothy-harrison-device-driver-debauchery-msr-madness/MSR_Madness_v2.9_INFILTRATE.pptx)\n\n[Online].\n\n[[3] J. Michael and M. Skhatov, “Defcon 27: Get off the Kernel if you can’t Drive,” 13 August 2019. [Online].](https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-Jesse-Michael-Get-off-the-kernel-if-you-cant-drive.pdf)\n\n[4] N. Economou and E. Nissim, “ekoparty 2015: [Windows SMEP bypass: U=S,” 2015. [Online].](https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf)\n\n[[5] A. Shulmin, S. Yunakovsky, V. Berdnikov and A. Dolgushev, “The Slingshot APT,” 6 March 2018. [Online].](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2018/03/09133534/The-Slingshot-APT_report_ENG_final.pdf)\n\n[6] Z. Hromcová and A. Cherepanov, “InvisiMole: The Hidden Part of the Story – Unearthing InvisiMole’s\nEspionage Toolset and Strategic Cooperations ” 18 June 2020 [Online]\n\n\n-----\n\n[7] A. Ionescu, UMPOwn: Ring 3 to Ring 0 in 3 acts, in PoC||GTFO, vol. 2, No Starch Press, 2018, p. 768.\n\n[8] A. Brandt and M. Loman, “Living off another land: Ransomware borrows vulnerable driver to remove security\nsoftware,” Sophos, 7 February 2020. [Online].\n\n11 Jan 2022 - 11:30AM\n\n### Sign up to receive an email update whenever a new article is published in our Ukraine Crisis – Digital Security Resource Center\n\n Newsletter\n\n Discussion\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-11 - Signed kernel drivers – Unguarded gateway to Windows’ core.pdf"
    ],
    "report_names": [
        "2022-01-11 - Signed kernel drivers – Unguarded gateway to Windows’ core.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "11f52079-26d3-4e06-8665-6a0b3efdc41c",
            "created_at": "2022-10-25T16:07:23.736987Z",
            "updated_at": "2025-03-27T02:02:09.954078Z",
            "deleted_at": null,
            "main_name": "InvisiMole",
            "aliases": [
                "UAC-0035"
            ],
            "source_name": "ETDA:InvisiMole",
            "tools": [
                "InvisiMole"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "12b5d602-4017-4a6f-a2a3-387a6e07a27b",
            "created_at": "2023-01-06T13:46:39.095233Z",
            "updated_at": "2025-03-27T02:00:02.995336Z",
            "deleted_at": null,
            "main_name": "InvisiMole",
            "aliases": [],
            "source_name": "MISPGALAXY:InvisiMole",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "392aed78-4ef6-46ac-afba-c3920ea05d28",
            "created_at": "2022-10-25T16:07:23.323349Z",
            "updated_at": "2025-03-27T02:02:09.737228Z",
            "deleted_at": null,
            "main_name": "APT 6",
            "aliases": [
                "1.php Group"
            ],
            "source_name": "ETDA:APT 6",
            "tools": [
                "Chymine",
                "Darkmoon",
                "Gen:Trojan.Heur.PT",
                "Poison Ivy",
                "SPIVY",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536111,
    "ts_updated_at": 1743041831,
    "ts_creation_date": 1653759784,
    "ts_modification_date": 1653759784,
    "files": {
        "pdf": "https://archive.orkl.eu/3c0bafb92ba99a7b2c9e429d2627bf4fddeb930b.pdf",
        "text": "https://archive.orkl.eu/3c0bafb92ba99a7b2c9e429d2627bf4fddeb930b.txt",
        "img": "https://archive.orkl.eu/3c0bafb92ba99a7b2c9e429d2627bf4fddeb930b.jpg"
    }
}