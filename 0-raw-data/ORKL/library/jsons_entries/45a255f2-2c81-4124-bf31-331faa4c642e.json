{
    "id": "45a255f2-2c81-4124-bf31-331faa4c642e",
    "created_at": "2023-01-12T15:10:44.096436Z",
    "updated_at": "2025-03-27T02:05:56.397204Z",
    "deleted_at": null,
    "sha1_hash": "3d18f46acacd5cfdaea9a474112c19ed7b282651",
    "title": "2022-03-01 - Python script to decrypt embedded driver used in Daxin",
    "authors": "",
    "file_creation_date": "2022-05-27T21:07:12Z",
    "file_modification_date": "2022-05-27T21:07:12Z",
    "file_size": 69131,
    "plain_text": "# usualsuspect/daxin_decrypt_embedded.py\n\n**[gist.github.com/usualsuspect/839fbc54e0d76bb2626329cd94274cd6](https://gist.github.com/usualsuspect/839fbc54e0d76bb2626329cd94274cd6)**\n\n#!/usr/bin/env python3\n\n#\n\n# Algorithm used by Daxin to decrypt embedded driver\n\n# Uses slightly modified RC4 (see comment in rc4() below)\n\n#\n\n# Constants fitting for sample\n\n# b0eb4d999e4e0e7c2e33ff081e847c87b49940eb24a9e0794c6aa9516832c427\n\n#\n\nimport hashlib\n\nimport struct\n\ndef gen_key(const1,const2):\n\n# hardcoded into function, might also change per sample\n\n\n-----\n\nkey_data = b\"\\x7C\\x4E\\xD0\\x68\\x20\\x4b\\x42\\xEB\\x08\\x4A\\xFE\\xA9\\xEB\\x50\\x30\\xa3\"\n\nd1 = struct.pack(\"<I\",const1)\n\nd2 = struct.pack(\"<I\",const2)\n\nkey_data = d1 + key_data + d2\n\nkey = hashlib.md5(key_data).digest()\n\nout = bytearray(struct.pack(\"<I\",const1^const2) + key[4:])\n\nh = const1 ^ const2\n\nfor i in range(16):\n\nif (i & 1):\n\nk = ((h << 11) & 0xFFFFFFFF) ^ ((h >> 5) & 0xFFFFFFFF)\n\nk ^= out[i]\n\nk ^= 0xFFFFFFFF # not\n\nelse:\n\nk = ((h >> 3) & 0xFFFFFFFF) ^ ((h << 7) & 0xFFFFFFFF)\n\nk ^= out[i]\n\nh ^= k\n\nout = struct.pack(\"<I\",h) + out[4:]\n\nreturn out\n\ndef rc4(data, key):\n\nx = 0\n\nbox = bytearray(range(256))\n\nfor i in range(256):\n\nx = (x + box[i] + key[i % len(key)]) % 256\n\nbox[i], box[x] = box[x], box[i]\n\n\n-----\n\ny = x # original RC4 sets both 0\n\nx = 0\n\nout = bytearray()\n\nfor char in data:\n\nx = (x + 1) % 256\n\ny = (y + box[x]) % 256\n\nbox[x], box[y] = box[y], box[x]\n\nout.append(char ^ box[(box[x] + box[y]) % 256])\n\nreturn out\n\ndata = open(\"driver\",\"rb\").read()\n\nkey = gen_key(0x4373F262,0x21B33EE9)\n\nplain = rc4(data,key)\n\nopen(\"out\",\"wb\").write(plain)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-01 - Python script to decrypt embedded driver used in Daxin.pdf"
    ],
    "report_names": [
        "2022-03-01 - Python script to decrypt embedded driver used in Daxin.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536244,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653685632,
    "ts_modification_date": 1653685632,
    "files": {
        "pdf": "https://archive.orkl.eu/3d18f46acacd5cfdaea9a474112c19ed7b282651.pdf",
        "text": "https://archive.orkl.eu/3d18f46acacd5cfdaea9a474112c19ed7b282651.txt",
        "img": "https://archive.orkl.eu/3d18f46acacd5cfdaea9a474112c19ed7b282651.jpg"
    }
}