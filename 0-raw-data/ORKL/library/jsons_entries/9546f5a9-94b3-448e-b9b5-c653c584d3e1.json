{
    "id": "9546f5a9-94b3-448e-b9b5-c653c584d3e1",
    "created_at": "2022-10-25T16:48:21.158251Z",
    "updated_at": "2025-03-27T02:09:29.38316Z",
    "deleted_at": null,
    "sha1_hash": "62d5fdb316ad5b0c5e3afb5919785df4c557f25b",
    "title": "W32/Regin, Stage #1",
    "authors": "F-Secure",
    "file_creation_date": "2014-12-09T07:31:56Z",
    "file_modification_date": "2014-12-09T07:31:58Z",
    "file_size": 666119,
    "plain_text": "# Malware Analysis  Report\n\n## W32/Regin, Stage #1\n\n### TLP: WHITE\n\n\n1. INTRODUCTION\b 2\n1.1 Sample Statistics\b 2\n\n2. MALWARE ANALYSIS\b 2\n2.1 Deployment and startup\b 3\n2.2 Sample selection\b 3\n2.3 Content retrieval\b 3\n2.4 Retrieval from the file system (Extended Attributes)\b 4\n2.5 Retrieval from the registry\b 4\n2.6 Decryption \b 4\n2.7 Content mapping\b 4\n2.8 The QuickPeParse function \b 5\n2.9 Header and sections\b 5\n2.10 Imports & Trampolines\b 6\n2.10.1 Embedded code templates\b 7\n2.10.2 Locating a safe location inside a trusted module\b 7\n2.10.3 Code template customization\b 8\n2.10.4 Trampolines\b 8\n2.11 The CodeProtection structure\b 8\n2.12 Relocations\b 8\n2.13 Finalizing the loading process\b 9\n2.14 Invocation of stage #2\b 10\n\n3. CONCLUSIONS\b 10\nAPPENDIX A: SAMPLE STATISTICS\b 11\nAPPENDIX B: MEMSET SYSTEM CALL TRANSITION\b 14\n\nPaolo Palumbo\nSenior Researcher\nSecurity Response\nF-Secure Labs\nTwitter: @paolo_3_1415926\n\nContact\nF-Secure Incident Response\n[irt@f-secure.com](mailto:irt@f-secure.com)\n\n\nIn this document we analyze a set of 32-bit samples\nwhich represents stage #1 of the complex threat that is\nknown as Regin. Based on our analysis of the malware’s\nfunctionalities, this part of the Regin threat can be\nconsidered just a support module — its sole purpose\nis to facilitate and enable the operations of stage #2\nby loading it and making it more difficult to detect by\nsecurity products.\n\nRegin’s stage #1 targets the Windows platform and\nsupport various versions of the operating system,\nbeginning with Windows NT 4.0. Based on our analysis,\nthe samples may be classified into two categories: “pure”\nsamples that do not feature any extra, non-malicious\ncode; and “augmented” ones which feature malware\ncode as part of another device driver. The existence of\n“augmented” samples indicates the intention of the\nattacker to remain undiscovered for as long as possible.\n\nWhen activated, samples of Regin stage #1 will\nretrieve encrypted content from specific locations of\nan already compromised system, map it into kernel\nmemory and transfer control to it. In terms of technical\nsophistication, stage #1’s import resolution process is\nof particular interest, as the malware uses the unusual\n“trampoline” technique to mask the payload’s access to\nAPI functions.\n\nIt is clear that this support component, that represents\nthe initial stage of a very complex threat, has been\ninstrumental in securing long-term persistence in the\nattacks that made use of this threat.\n\n\n-----\n\n#### 1. INTRODUCTION\n\nIn this document we describe the technical characteristics\nof a set of 27 32-bit samples of Regin’s stage #1 component.\n\nWe first extract and collect a set of high level information\nfrom these samples to obtain a general overview of their\nstructure. Based on this overview, we propose using two\ndistinct grouping criteria to facilitate working with these\nsamples. A single sample is then selected and analysed in\ndetail; its functionalities are isolated and presented here,\ntogether with relevant portions of its code.\n\n##### 1.1 Sample Statistics\n\nOur analysis covers a collected set of 27 32-bit Portable\nExecutable (PE) files for the Microsoft Windows operating\nsystem. All 27 samples are device drivers, designed to work\nat the kernel level.\n\nBased on the code structure of the samples, they can be\nroughly categorized into two groups:\n\nyy “Pure” — does not feature any extra code beside the\nmalicious one\nyy “Augmented” — the malware code is present in\ncombination with code from a legitimate device driver\n\nSome “augmented” samples seem to be derived from\nMicrosoft device drivers, with modifications to drive the\nexecution towards the malicious code.\n\nOf the 27 samples, 20 of them (or 74%) are “pure”; only 7\nsamples can be classified as are “augmented”. Despite the\nsmall amount of samples at our disposal, it is possible to\nspeculate that the disproportion between the number of\n“pure” and “augmented” samples reflects the additional\ncomplexity associated with creating the “augmented”\nsamples. Another possibility is that “augmented” samples\nrepresent a particular stage of development or have\nserved a particular purpose, and for this reason they are\nfewer in number; this suspicion might be confirmed by the\ncompilation date as extracted from the samples’ PE header.\n\nAnalysis of the resources also shows that the “augmented”\nbinaries are masked as binaries for Windows NT 5.2.3790,\nalso known as Windows Server 2003. This hints to the\nfact that the attackers might have used these samples to\nspecifically target machines running this particular version\nof Windows.\n\n\nIt also interesting to consider the filenames of the samples\nas they were observed in the wild or during submission for\nanalysis. In 12 cases (44% of samples), the decoy names used\nby the files was “usbclass.sys”.[ [1]] This particular name was\nused only for “pure” samples (though not all such samples\nused this name). It is our opinion that this particular name\nwas selected to allay any suspicions on the victim’s part, if\nthe file was discovered.\n\nFollowing detailed analysis of a selected reference sample\n(presented in later sections), we were able to group samples\nbased on differences in their code from the analysed\nsample. We define the distance function between our\nreference sample and other samples as:\n\nd(sample)□:∶= |〖functions〗sample reference ∩ functionssample |\n|〖functions〗sample〗reference |\n\nUsing this metric, we determined there were three\ncategories among the 27 samples at our disposal. A set of 13\nsamples out of 26 [[2]], which was assigned the label “variant\n#1”, alongside the reference sample, were extremely close\nto the reference, with distances between 89% and 100%. 7\nout of 26 samples (labelled “variant #2”) were very distant\nfrom the reference sample [[3]], with a consistent distance\nof 2.63%. Finally, the last 7 samples (labelled “variant #3”)\nshowed distances between 41% and 53% from the reference\nsample. While samples belonging to “variant #2” or “variant\n#3” were not analyzed in detail, preliminary analysis shows\nthat they all possess the same functionalities, but their code\nis notably different at the function level.\n\nA final observation is that all the “augmented” samples\nbelong to “variant #1”, according to this classification\nmethod. The full data matrix regarding the samples is\nprovided in Appendix A for the interested reader.\n\n#### 2. MALWARE ANALYSIS\n\nThis section presents a detailed analysis of a selected\nsample from the set of samples for Regin’s stage #1, which\nlater serves as a reference for further analysis of other\nsamples.\n\n\n1   There exists a small number of references to a Logitech device driver with the name “usbclass.sys”. Were these\nreferences to be correct, it could be speculated that the malware authors may have wanted to use a name that\n\n\n-----\n\nChart 1: Flowchart of content retrieval logic\n\n\n##### 2.1 Deployment and startup\n\nAt the time of writing, it is not known how the Regin\nstage #1 samples are deployed to the target system. Our\nanalysis of the samples’ system interactions showed no\nevidence to indicate that they are any different from other\ndevice drivers; we therefore believe that these samples are\ninstalled, registered and invoked as with any other device\ndriver.\n\n##### 2.2 Sample selection\n\nThe analysis in this section focuses on the sample with MD5\n26297dc3cd0b688de3b846983c5385e5, which was chosen\nfor two reasons: first, the sample was among the first few\n\n\nwe retrieved, and second, it was the only “pure” sample in\nthat particular set. A “pure” sample has the advantage of\nbeing self-contained, smaller in size and independent from\nany other code.\n\n##### 2.3 Content retrieval\n\nAlmost immediately after receiving control, the malware’s\ncode will attempt to locate its payload from the already\ninfected system. The malware will scan selected locations\nin both the file system and the registry. These locations\nare hardcoded inside the binary itself under a layer of\nsimple encryption. The logic for content retrieval can be\nrepresented by a simplified flowchart (Chart 1).\n\n\n2  The total number of samples is 26 because the reference sample has been excluded.\n3 It is clear that d (sample reference) = 1.\n\n\n-----\n\nImage 2: Payload verification code\n\n\n##### 2.4 Retrieval from the file system (Extended Attributes)\n\nRegin’s stage #1 component relies on the concept of\n‘Extended Attributes’ to store its payload on the file-system.\nExtended Attributes are a list of name-value pairs that can\nbe associated to New Technology File System (NTFS) files\nand directories.\n\nThe malware retrieves the list of extended attributes\nassociated with the provided full path to a directory or file.\nThis list is then iterated and each element is inspected. The\nmalware expects to retrieve the content from extended\nattributes named as “_”. If that condition is met, the value\nis then extracted. It should be noted that the content may\nbe split between extended attributes belonging to two\ndifferent NTFS objects. An example file-system location is\nthe following:\n\n<WINDOWS>\\Cursors\n\nThe use of Extended Attributes was not observed in\nmalware until the recent emergence of the ZeroAccess\nrootkit [[4]]. As the Regin threat appears to have emerged\nearlier than ZeroAccess however, we are convinced that\nsignificant skills, knowledge and resources were available to\nthe developers of Regin to enable earlier use of this unusual\ntechnique.\n\n##### 2.5 Retrieval from the registry\n\nIf Regin’s stage #1 is unable to retrieve payload content\nfrom the file-system, the malware will turn its attention to\nthe registry. Regin’s stage #1 malware samples contain a\nhardcoded registry path and value name to be used as a fallback location for content retrieval. In this case, the sought\n\n\nImage 1: Content decryption loop\n\n\nImage 2: Payload verification code\n\ncontent is simply the value of the provided key/value-name\ncombination.\n\nAn example registry location is:\n\n\\REGISTRY\\Machine\\System\\CurrentControlSet\\\nControl\\RestoreList:VideoBase\n\nIf both content retrieval attempts are unsuccessful, the\nmalware will not perform any additional operation until\nits next invocation, when it will again attempt to retrieve\ncontent from either the file-system or the registry.\n\n##### 2.6 Decryption\n\nThe encryption used to protect the content in the file\nsystem or registry is a XOR based algorithm, specific to\nthis malware family. Regin’s stage #1 body contains the key\nneeded for payload decryption. The code for the payload’s\ndecryption routine is presented in Image 1.\n\nAfter decryption, the malware quickly verifies the payload is\ncorrect, in order to avoid attempting to map something for\nexecution when it is obviously invalid (Image 2).\n\n##### 2.7 Content mapping\n\nOnce the payload is in clear text, Regin’s stage #1 proceeds\nto map it so that it can be executed. The mapping process\nfollows the logic of the operating system’s PE loader.\n\nRegin’s stage #1 PE loader is quite comprehensive;\nconsidering the suspected age of the threat, the generic\nnature of the PE loader and the fact that the PE loading\nhappens completely in kernel mode, we can speculate that\nthe authors of this threat are skilled and well-funded.\n\n\n4  Symantec Response blog; Mircea Ciubotariu; Trojan.Zeroaccess.C Hidden in NTFS EA; published 14 Aug 2012;\nhttp://www.symantec.com/connect/blogs/trojanzeroaccessc-hidden-ntfs-ea\n\n\n-----\n\nImage 3: Code recovered for the QuickPeParse function\n\n\nImage 3: Code recovered for the QuickPeParse function\n\n\n##### 2.8 The QuickPeParse function\n\nOf particular interest is a specific helper function that\nis widely used by Regin’s stage #1 in association with PE\nmanipulation.\n\nThe helper function quickly verifies the validity of a PE file,\nwhile at the same time recovering information (Image 3)\nuseful to anyone willing to load or programmatically process\na PE file.\n\nGiven the number of times Regin’s stage #1 needs to retrieve\nPE-related information, this subroutine is a great help in\n\n\nsimplifying the code and avoiding dangerous mistakes. This\nis, again, possibly additional confirmation of the attacker’s\nskills.\n\n##### 2.9 Header and sections\n\nThis part of the loading process is performed in a fairly\nstandard way. Regin’s stage #1 begins the loading process by\nverifying that its payload is a valid PE file. If this verification\nis successful, the malware retrieves the value of the\nSizeOfImage field from the OptionalHeader of the PE file,\nthen allocates a number of bytes equivalent to this value.\n\n\n-----\n\nImage 4: Calculating the delta\n\nImage 5: Missing replacements for mem* functions\n\n\nThe payload will be mapped to this memory region.\n\nBefore proceeding any further, Regin’s stage #1 calculates\nthe delta (Image 4) between the address of the memory\nregion it allocated for the memory mapped image and the\npreferred ImageBase retrieved from the OptionalHeader.\nThis information will be used later during the mapping\nprocess, in case relocations need to be processed.\n\nWith these operations completed, the headers are mapped\nfirst, followed sequentially by each of the PE file sections.\nThis process is relatively straightforward.\n\nIt is to be appreciated that the majority of the operations\ndescribed above rely at some level on QuickPeParse’s\nresults.\n\nOn another note, in this section of the code we begin to see\nreferences to missing replacements for mem* functions.\n\nThe absence of the mem* replacements does not affect\nthe malware’s ability to proceed with the execution, as the\ncode falls back to standard API functions (Image 5). Such\ncode constructs are encountered extensively throughout\nthe remainder of the code. Our opinion on this matter is\nthat the replacement functions would provide augmented\nlogging when dealing with memory operations; their\nabsence is possibly the result of conditional compilation.\nSuch an explanation would further the belief that the\nauthors of this malware are experienced developers.\n\n##### 2.10 Imports & Trampolines\n\nImport resolution is the crucial part for achieving Regin\nstage #1’s goal of hiding the originator of system calls\nfrom external observers. The loader will correctly resolve\nthe address of imported functions, but will embed these\naddresses in so-called ‘trampoline’ code. Addresses to\nthe trampolines are instead added to the Import Address\nTable (IAT). From there, the execution will traverse different\n\n\npieces of code, eventually triggering the requested external\nsubroutine before finally returning to the payload.\n\nBefore getting into details, it is important to have an idea of\nhow the trampolines work from a high-level perspective.\n\nA trampoline transition can be summarized as follows:\n\n1. Payload invokes “resolved” external subroutine\n2. Trampoline code receives control\na. Trampoline code retrieves the previouslyresolved real address of the external subroutine\nb. Trampoline invokes the pre-API call code\n\n3. Pre-API call code prepares the environment to make\nthe function call return to trusted location inside\ntrusted module\na. Pre-API call code invokes the external\nsubroutine\n\n4. External subroutine performs its duty\na. External subroutine returns\n\n5. Execution lands in appropriate part of trusted\nmodule\n6. Jump to post-API call code is executed\n7. Post-API call code receives control\na. Post-API call code restores the environment for\npayload\nb. Post-API call code transfers control back to\npayload, as would normally happen after a call\nto an external subroutine\n\n8. Payload continues its operations\n\nIn the following subsections we will discuss the details\nof how the malware retrieves and pieces together all the\ninformation required to produce and install the trampolines.\n\nAppendix B contains a diagram detailing a complete\ntransition between the payload and an external module\nexporting a function.\n\n\n-----\n\n###### 2.10.1 Embedded code templates\n\nThe stage #1 malware uses predefined code for pre-API-call\nand post-API-call operations. This code is embedded in\nthe binary and is almost ready for use, but it requires some\ncustomization to account for differences when it comes to\nmemory addresses.\n\nThe malware is aware of the start address of both pieces\nof code inside its own body, and has a rough idea of the\nsize of the two code portions. The builder code contains\nwrong values for the size of both templates. This is most\nlikely a remnant of a previous code version that contained\ntemplates that were bigger.\n\nWith this information, the malware scans those sections of\ncode looking for specific DWORDs that mark locations that\nneed customization.\n\nAs an example, we report a screenshot of the post-APIcall code (Image 6). The value of 0x99119911 as the second\noperand of the last instruction in this code portion is a\nplaceholder that acts as a marker for the builder code.\n\nThe offset of the values needing customization are marked\nby the values:\n\nyy pre-API-call code:\n\n  - 0x66116611\n\n  - 0x77117711\n\n  - 0x88118811\nyy post-API-call code:\n\n  - 0x99119911\n\nImage 6: Post-API-call code\n\nThe addresses of such markers relative to the beginning of\nthe owner code portion are recorded for later use. After all\nthe information is recorded, Regin’s stage #1 copies both\nthe pre-API-call and the post-API-call code portions to\nnewly allocated memory regions.\n\n\n###### 2.10.2 Locating a safe location inside a trusted module\n\nFor the trampolines to be successful, a safe location inside\na trusted kernel module needs to be found. After the\ntrampolines are in place, the affected module will be the\none that is seen and “blamed” by an external observer every\ntime the payload executes a call to an external subroutine.\n\nTo find this location, Regin’s stage #1 scans all the sections\nthat are executable and non pageable from a set of trusted\nmodules. This set of modules includes:\n\nyy NTOSKRNL.EXE\nyy HAL.dll\nyy Disk.sys\nyy Atapi.sys\n\nThese memory regions are scanned for a specific set of\nbytes. The sought after combinations are listed below,\ntogether with their assembly representation.\n\nyy 0xFF, 0x26: jmp dword ptr [esi]\nyy 0xFF, 0x27: jmp dword ptr [edi]\nyy 0xFF, 0x66: jmp dword ptr [esi+bb]\nyy 0xFF, 0x67: jmp dword ptr [edi+bb]\nyy 0xFF, 0xA6: jmp dword ptr [esi+dddddddd]\nyy 0xFF, 0xA7: jmp dword ptr [edi+dddddddd]\nyy 0xFF, 0xE6: jmp esi\nyy 0xFF, 0xE7: jmp edi\n\nThe assembler representations make the malware’s purpose\nquite clear. The malware will arrange for the system call to\nreturn to this particular location inside a trusted module,\nfooling any external observer who may be monitoring the\nreturn address to identify the module originating the call to\nthe external subroutine. Executing the code at this location\nwill make the CPU execute the jump operation, which will\neventually lead back to the payload’s code.\n\nIf any of the two bytes sequences presented above is found\nin the code of a trusted module, and if the surrounding\ncode passes further safety checks, its address is recorded.\n\nDepending on the specific byte combination found,\nadditional information may be retrieved or calculated; for\nexample, in the case of a jmp dword ptr [edi+xxxxxxxx], the\nimmediate part of the operand is retrieved for calculating\nthe delta between that value and the location containing\nthe address of the post-API-call. The calculated delta value\nwill be assigned to the EDI register so that the execution will\nflow smoothly.\n\n\nImage 6: Post-API-call code\n\n\n-----\n\nImage 7: Trampoline memory allocation\n\n\nIf none of these sequences are found, the search continues\nin other sections and trusted modules. If no suitable\nlocation is available, Regin’s stage #1 will simply terminate its\nexecution.\n\n###### 2.10.3 Code template customization\n\nOnce the safe location in a trusted module has been located\nand its address and type retrieved, Regin’s stage #1 can\ncustomize the copies of the pre- and post-API-call code\ntemplates.\n\nEach of the values is customized as follows:\n\nyy 0x66116611: delta value to be applied to ESI/EDI register\nso that the jump instruction at the safe location will lead\nthe execution back to the post-API-call code\nyy 0x77117711: address of the safe jump location\nyy 0x88118811: nothing, used only as an end marker\nyy 0x99119911: not specifically replaced, but parts of it are\noverwritten with the address of post-API-call code if the\nsafe location involves an indirect jump\n\n###### 2.10.4 Trampolines\n\nTrampolines are the mechanism that Regin’s stage #1 uses to\nreroute the execution through several pieces of code every\ntime the payload executes a call to an external function.\nThere exists a trampoline for each individual imported\nfunction, and the trampolines are stored sequentially in\nmemory and accessed as an array.\n\nEach trampoline is constructed from the following\ntemplate:\n\nmov eax, d1d1d1d1\njmp $+d2d2d2d2\n\nThe values “d1d1d1d1” and “d2d2d2d2” are placeholders that\nwill be replaced during actual import resolution with the\nrelevant information. In particular, the two values will be\nreplaced with the following information:\n\nyy d1d1d1d1: replaced with the address of the external\nfunction from the third party module (for example:\nNTOSKRNL.EXE!memcpy)\n\n\nyy d2d2d2d2: replaced with the offset of the pre-API-call\ncode segment, relative to the instruction after the jmp\n\nDuring import resolution, each item to resolve is fetched\nand its address retrieved. The address is then used to fill\na trampoline as described above. Finally, the address of\nthe trampoline is added to the IAT of the module being\nmapped in place of the resolved address. Please note that,\nas is logical, this process is only executed for symbols\nwhose address lies in a section that is flagged as executable.\nOther symbols are not protected by trampolines and their\naddresses are added directly to the IAT.\n\nThe described trampoline mechanism clearly provides\ntransparent protection to the payload.\n\n##### 2.11 The CodeProtection structure\n\nThis structure links together all the pieces involved with the\nprotection of the payload. It is added, for example, to the\npayload’s data directory information and it is used for most\nof the computations performed by Regin’s stage #1. The\nstructure is defined as follows:\n\nImage 8: CodeProtection structure\n\n##### 2.12 Relocations\n\nThe next step of the payload loading process is for the\nmalware to process the possible relocations of the mapped\npayload.\n\nTo carry out this operation, the dedicated code needs\nto process the base relocation table for the payload.\nAdditionally, it makes use of the previously calculated delta\nbetween the current image base and the preferred image\nloading address.\n\n\n-----\n\nImage 9: Scanning the payload’s DATA_DIRECTORIES\n\n\nThe PE loader supports only two specific base relocation\ntypes, IMAGE_REL_BASED_HIGHLOW and IMAGE_REL_\nBASED_DIR64. However, this level of support is enough\nto guarantee the loading of binaries produced by recent\ntoolchains.\n\nAs a matter of fact, the loader’s support of the relocation\ntype IMAGE_REL_BASED_DIR64 gives us the firsts hint\nthat a 64-bit version of the Regin framework may exist, in\ncombination with 64-bit additional stages.\n\n\n##### 2.13 Finalizing the loading process\n\nAs the final step in the loading process, the malware\nscans the payload’s DATA_DIRECTORIES to perform a final\nmodification to the mapped image.\n\nThe modification consists of setting the VirtualAddress\nof the selected DATA_DIRECTORY to the address of the\npreviously mentioned CodeInjection structure. Additionally,\nthe Size field of the selected DATA_DIRECTORY is set to a\n\n\n-----\n\nspecial value, 0xFEDCBAFE (renamed MALWARE_MARKER_\nDATA_DIR_SIZE in Image 9).\n\nA suitable DATA_DIRECTORY is one which satisfies the\nfollowing conditions:\n\nyy The particular data directory is not in use\n(VirtualAddress and Size must be 0)\nyy The directory should not be among the following\ndirectories:\n\n  - EXPORT\n\n  - IMPORT\n\n  - IMPORT ADDRESS TABLE (IAT)\n\n  - DELAY-LOAD IMPORT TABLE\n\nIt is clear that the malware selects the data directory\nwith special care, specifically to avoid interference\nwith interactions between the mapped payload and its\ndependencies.\n\n##### 2.14 Invocation of stage #2\n\nWith the payload fully mapped into memory and the\ntrampoline mechanism set up to mask the malware’s access\nto external subroutines, Regin’s stage #1 is ready to transfer\ncontrol to the next stage.\n\nThis is done by calculating the address of stage #2’s entry\npoint and calling that location.\n\n\n#### 3. CONCLUSIONS\n\nOur analysis of the Regin’s stage #1, as detailed in this\ndocument, shows that this component of the Regin\nframework is designed to retrieve an additional payload\n(stage #2) from an already compromised system, map it into\nkernel memory and execute it.\n\nDuring the loading process, Regin’s stage #1 will hide\nthe payload’s invocations of function exported by other\nmodules using an unusual ‘trampoline’ mechanism. In this\nway, the malware manages to effectively fool an external\nobserver into thinking that calls to API functions are being\nperformed by one of a set of ‘trusted’ modules, thereby\nallaying suspicion of the payload’s activities.\n\nThe utilitarian nature of the malware makes it obvious that\nthis is a support module, designed to hide the presence of\nan additional stage.\n\nAttempting attribution based on this single component\nis particularly challenging, as Regin’s stage #1 is purely\na support module, with very little content other than\nexecutable code. In the case of the “augmented” samples,\nthe benign device driver used as a base offers little to\nnothing in terms of information that could help identifying\nthe author(s).\n\nThat said, based on the code structure, we suspect that\nRegin’s developers may be experienced and skilled.\nStatistical analysis of the 27 samples in our collection\nsuggest that the three different types of stage #1 samples\nwe identified may have been the product of iterative\ndevelopment.\n\nThe fact that the malware supports even Windows NT4\ntargets suggests that this malware is designed to work\nagainst a wide set of targets, each running different versions\nof the Windows operating system in their environment. We\nbelieve however that at some point the attackers directed\ntheir efforts towards machines running Windows NT\n5.2.3790, also known as Windows Server 2003.\n\n\n-----\n\n#### APPENDIX A: SAMPLE STATISTICS\n\nBelow is the full data matrix for the 27 Regin samples collected.\n\n**no.** **MD5 HASH** **known filename** **type**\n\n1 26297DC3CD0B688DE3B846983C5385E5 plain\n\n\n2 47D0E8F9D7A6429920329207A32ECC2E abiosdsk.sys embedded\n\n3 01C2F321B6BFDB9473C079B0797567BA ser8uart.sys embedded\n\n4 4B6B86C7FEC1C574706CECEDF44ABDED usbclass.sys plain\n\n5 744C07E886497F7B68F6F7FE57B7AB54 floppy.sys, atdisk.sys embedded\n\n6 2C8B9D2885543D7ADE3CAE98225E263B usbclass.sys plain\n\n7 F3FFC2AAAA1E2AB55EC26FF098653347 atdisk.sys embedded\n\n8 E94393561901895CB0783EDC34740FD4 plain\n\n9 BFBE8C3EE78750C3A520480700E440F8 pcidump.sys plain\n\n10 89003E9A1AE635C97EBAD07AEBC67F00 usbclass.sys plain\n\n11 1800DEF71006CA6790767E202FAE9B9A abiosdisk.sys embedded\n\n12 90FECC6A89B2E22D82D58878D93477D4 atdisk.sys embedded\n\n13 DB405AD775AC887A337B02EA8B07FDDC parclass.sys embedded\n\n14 6662C390B2BBBD291EC7987388FC75D7 usbclass.sys plain\n\n15 06665B96E293B23ACC80451ABB413E50 rdpmdd.sys plain\n\n16 FFB0B9B5B610191051A7BDF0806E1E47 pciclass.sys plain\n\n17 187044596BC1328EFA0ED636D8AA4A5C usbclass.sys plain\n\n18 B29CA4F22AE7B7B25F79C1D4A421139D pciport.sys, usbclass.sys plain\n\n19 D240F06E98C8D3E647CBF4D442D79475 usbclass.sys plain\n\n20 8FCF4E53ECE6111758A1DD3139DC7CAD plain\n\n21 148C1BB9D405D717252C77593AFF4BD8 usbclass.sys plain\n\n22 1C024E599AC055312A4AB75B3950040A usbclass.sys plain\n\n23 B269894F434657DB2B15949641A67532 usbclass.sys plain\n\n24 BA7BB65634CE1E30C1E5415BE3D1DB1D usbclass.sys plain\n\n25 22BFC970F707FD775D49E875B63C2F0C plain\n\n26 B505D65721BB2453D5039A389113B566 usbclass.sys plain\n\n\n27 049436BB90F71CF38549817D9B90E2DA usbclass.sys plain\n\n\n-----\n\n**NO.** **config #1** **config #2** **config #3** **config #4**\n\n1 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{9B9A8ADB-8864-4BC4-8AD5-B17DFDBB9F58}\n\n\n2 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\security <WINDOWS>Temp\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n3 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\repair <WINDOWS>\\msagent\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n4 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n5 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\msapps <WINDOWS>\\Help\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n6 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n7 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\msagent <WINDOWS>\\msagent\\chars\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n8 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\msapps <WINDOWS>\\Help\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n9 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n10 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n11 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\security <WINDOWS>\\Temp\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n12 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\msagent <WINDOWS>\\msagent\\chars\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n13 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS>\\Temp <WINDOWS>\\inf\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n14 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n15 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ VideoBase <WINDOWS>\\Cursors <WINDOWS>\\fonts\nRestoreList\n\n16 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{9B9A8ADB-8864-4BC4-8AD5-B17DFDBB9F58}\n\n17 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n18 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n19 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n20 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n21 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n22 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n23 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n24 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n\n25 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ {5D42A36B-12C4Session DE7C-4BD10612BD1CF324}\n\n\n<WINDOWS>\\Spool\\ <SYSTEM>\\CertSrv\nPrinters\n\n\n26 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{4F20E605-9452-4787-B793-D0204917CA58}\n\n27 \\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\ Class <WINDOWS> <WINDOWS>\\fonts\nClass\\{9B9A8ADB-8864-4BC4-8AD5-B17DFDBB9F58}\n\n\n-----\n\n**number of**\n**no.** **resources?**\n**resources**\n\n\n**function**\n\n**match**\n\n\n**similarity**\n**variant** **notes**\n**score**\n\n\n1 No n/a 76 100 1 Analyzed sample\n\n\n2 Yes 2 68 89.47368421 1\n\n3 Yes 1 68 89.47368421 1\n\n4 Yes 1 72 94.73684211 1\n\n5 Yes 2 69 90.78947368 1\n\n6 Yes 1 68 89.47368421 1\n\n7 Yes 2 68 89.47368421 1\n\n8 Yes 1 68 89.47368421 1\n\n9 No n/a 76 100 1\n\n10 Yes 1 69 90.78947368 1\n\n11 Yes 2 69 90.78947368 1\n\n12 Yes 2 69 90.78947368 1\n\n13 Yes 1 69 90.78947368 1\n\n14 No n/a 2 2.631578947 2\n\n15 No n/a 2 2.631578947 2\n\n16 No n/a 2 2.631578947 2\n\n17 No n/a 2 2.631578947 2\n\n18 No n/a 2 2.631578947 2\n\n19 No n/a 2 2.631578947 2\n\n20 No n/a 2 2.631578947 2\n\n21 No n/a 37 48.68421053 3\n\n22 No n/a 31 40.78947368 3\n\n23 No n/a 40 52.63157895 3\n\n24 No n/a 31 40.78947368 3\n\n25 No n/a 31 40.78947368 3\n\n26 No n/a 40 52.63157895 3\n\n\n27 No n/a 40 52.63157895 3\n\n\n-----\n\n#### APPENDIX B: MEMSET SYSTEM CALL TRANSITION\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/358saagkwt3gqy6w62ed6xo33w175r0y",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.12.10.W32_Regin/w32_regin_stage_1.pdf"
    ],
    "report_names": [
        "w32_regin_stage_1"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1418110316,
    "ts_modification_date": 1418110318,
    "files": {
        "pdf": "https://archive.orkl.eu/62d5fdb316ad5b0c5e3afb5919785df4c557f25b.pdf",
        "text": "https://archive.orkl.eu/62d5fdb316ad5b0c5e3afb5919785df4c557f25b.txt",
        "img": "https://archive.orkl.eu/62d5fdb316ad5b0c5e3afb5919785df4c557f25b.jpg"
    }
}