{
    "id": "97212275-8df9-45ac-b571-8ab35af8f16a",
    "created_at": "2023-01-12T15:08:46.442093Z",
    "updated_at": "2025-03-27T02:05:38.513363Z",
    "deleted_at": null,
    "sha1_hash": "a14e65b0eb10033c5cc7b13c0b4ba932d03b60e8",
    "title": "Command Injection",
    "authors": "",
    "file_creation_date": "2021-03-08T01:13:53Z",
    "file_modification_date": "2021-03-08T01:13:53Z",
    "file_size": 110946,
    "plain_text": "# Command Injection\n\n**owasp.org/www-community/attacks/Command_Injection**\n\n**Author: Weilin Zhong**\n\n**Contributor(s): Wichers, Amwestgate, Rezos, Clow808, KristenS, Jason Li, Andrew Smith,**\nJmanico, Tal Mel, kingthorin\n\n## Description\n\nCommand injection is an attack in which the goal is execution of arbitrary commands on the\nhost operating system via a vulnerable application. Command injection attacks are possible\nwhen an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to\na system shell. In this attack, the attacker-supplied operating system commands are usually\nexecuted with the privileges of the vulnerable application. Command injection attacks are\npossible largely due to insufficient input validation.\n\n[This attack differs from Code Injection, in that code injection allows the attacker to add their](https://owasp.org/www-community/attacks/Code_Injection)\nown code that is then executed by the application. In Command Injection, the attacker\nextends the default functionality of the application, which execute system commands,\nwithout the necessity of injecting code.\n\n## Examples\n\n### Example 1\n\nThe following code is a wrapper around the UNIX command cat which prints the contents of\na file to standard output. It is also injectable:\n\n\n-----\n\n```\n#include <stdio.h>\n#include <unistd.h>\nint main(int argc, char **argv) {\n char cat[] = \"cat \";\n char *command;\n size_t commandLength;\n commandLength = strlen(cat) + strlen(argv[1]) + 1;\n command = (char *) malloc(commandLength);\n strncpy(command, cat, commandLength);\n strncat(command, argv[1], (commandLength - strlen(cat)) );\n system(command);\n return (0);\n}\n\n```\nUsed normally, the output is simply the contents of the file requested:\n```\n$ ./catWrapper Story.txt\nWhen last we left our heroes...\n\n```\nHowever, if we add a semicolon and another command to the end of this line, the command\nis executed by catWrapper with no complaint:\n```\n$ ./catWrapper \"Story.txt; ls\"\nWhen last we left our heroes...\nStory.txt        doubFree.c       nullpointer.c\nunstosig.c       www*          a.out*\nformat.c        strlen.c        useFree*\ncatWrapper*       misnull.c        strlength.c       useFree.c\ncommandinjection.c   nodefault.c       trunc.c        \nwriteWhatWhere.c\n\n```\nIf catWrapper had been set to have a higher privilege level than the standard user, arbitrary\ncommands could be executed with that higher privilege.\n\n### Example 2\n\nThe following simple program accepts a filename as a command line argument, and displays\nthe contents of the file back to the user. The program is installed setuid root because it is\nintended for use as a learning tool to allow system administrators in-training to inspect\nprivileged system files without giving them the ability to modify them or damage the system.\n```\nint main(char* argc, char** argv) {\n char cmd[CMD_MAX] = \"/usr/bin/cat \";\n strcat(cmd, argv[1]);\n system(cmd);\n}\n\n```\n\n-----\n\nBecause the program runs with root privileges, the call to system() also executes with root\nprivileges. If a user specifies a standard filename, the call works as expected. However, if an\nattacker passes a string of the form “;rm -rf /”, then the call to system() fails to execute cat\ndue to a lack of arguments and then plows on to recursively delete the contents of the root\npartition.\n\n### Example 3\n\nThe following code from a privileged program uses the environment variable $APPHOME to\ndetermine the application’s installation directory, and then executes an initialization script in\nthat directory.\n```\n...\nchar* home=getenv(\"APPHOME\");\nchar* cmd=(char*)malloc(strlen(home)+strlen(INITCMD));\nif (cmd) {\n strcpy(cmd,home);\n strcat(cmd,INITCMD);\n execl(cmd, NULL);\n}\n...\n\n```\nAs in Example 2, the code in this example allows an attacker to execute arbitrary commands\nwith the elevated privilege of the application. In this example, the attacker can modify the\nenvironment variable $APPHOME to specify a different path containing a malicious version\nof INITCMD. Because the program does not validate the value read from the environment, by\ncontrolling the environment variable, the attacker can fool the application into running\nmalicious code.\n\nThe attacker is using the environment variable to control the command that the program\ninvokes, so the effect of the environment is explicit in this example. We will now turn our\nattention to what can happen when the attacker changes the way the command is\ninterpreted.\n\n### Example 4\n\nThe code below is from a web-based CGI utility that allows users to change their passwords.\nThe password update process under NIS includes running make in the /var/yp directory.\nNote that since the program updates password records, it has been installed setuid root.\n\nThe program invokes make as follows:\n```\nsystem(\"cd /var/yp && make &> /dev/null\");\n\n```\nUnlike the previous examples, the command in this example is hardcoded, so an attacker\ncannot control the argument passed to system(). However, since the program does not\nspecify an absolute path for make, and does not scrub any environment variables prior to\n\n\n-----\n\ninvoking the command, the attacker can modify their $PATH variable to point to a malicious\nbinary named make and execute the CGI script from a shell prompt. And since the program\nhas been installed setuid root, the attacker’s version of make now runs with root privileges.\n\nThe environment plays a powerful role in the execution of system commands within\nprograms. Functions like system() and exec() use the environment of the program that calls\nthem, and therefore attackers have a potential opportunity to influence the behavior of these\ncalls.\n\nThere are many sites that will tell you that Java’s Runtime.exec is exactly the same as C’s\nsystem function. This is not true. Both allow you to invoke a new program/process. However,\nC’s system function passes its arguments to the shell (/bin/sh) to be parsed, whereas\nRuntime.exec tries to split the string into an array of words, then executes the first word in\nthe array with the rest of the words as parameters. Runtime.exec does NOT try to invoke the\nshell at any point. The key difference is that much of the functionality provided by the shell\nthat could be used for mischief (chaining commands using “&”, “&&”, “|”, “||”, etc,\nredirecting input and output) would simply end up as a parameter being passed to the first\ncommand, and likely causing a syntax error, or being thrown out as an invalid parameter.\n\n### Example 5\n\nThe following trivial code snippets are vulnerable to OS command injection on the\nUnix/Linux platform:\n\n**C:**\n```\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nint main(int argc, char **argv)\n{\n   char command[256];\n   if(argc != 2) {\n     printf(\"Error: Please enter a program to time!\\n\");\n     return -1;\n   }\n   memset(&command, 0, sizeof(command));\n   strcat(command, \"time ./\");\n   strcat(command, argv[1]);\n   system(command);\n   return 0;\n}\n\n```\n\n-----\n\nIf this were a suid binary, consider the case when an attacker enters the following: `ls; cat`\n```\n/etc/shadow . In the Unix environment, shell commands are separated by a semi-colon. We\n\n```\nnow can execute system commands at will!\n\n**Java:**\n\nThere are many sites that will tell you that Java’s `Runtime.exec is exactly the same as C’s`\nsystem function. This is not true. Both allow you to invoke a new program/process. However,\nC’s system function passes its arguments to the shell ( /bin/sh ) to be parsed, whereas\nRuntime.exec tries to split the string into an array of words, then executes the first word in\nthe array with the rest of the words as parameters. Runtime.exec does NOT try to invoke the\nshell at any point. The key difference is that much of the functionality provided by the shell\nthat could be used for mischief (chaining commands using `&,` `&&,` `|,` `||, etc, redirecting`\ninput and output) would simply end up as a parameter being passed to the first command,\nand likely causing a syntax error, or being thrown out as an invalid parameter.\n\n### Example 6\n\nThe following PHP code snippet is vulnerable to a command injection attack:\n\n<?php print(“Please specify the name of the file to delete”); print(“<p>”);\n$file=$_GET[‘filename’]; system(“rm $file”); ?>\n\nThe following request and response is an example of a successful attack:\n\nRequest `http://127.0.0.1/delete.php?filename=bob.txt;id`\n\nResponse\n```\nPlease specify the name of the file to delete\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\n```\nSanitizing Input\n```\nReplace or Ban arguments with “;”\nOther shell escapes available\nExample:\n– &&\n– |\n– ...\n\n## Related Controls\n\n```\nIdeally, a developer should use existing API for their language. For example (Java): Rather\nthan use `Runtime.exec() to issue a ‘mail’ command, use the available Java API located at`\n\n\n-----\n\nIf no such available API exists, the developer should scrub all input for malicious characters.\nImplementing a positive security model would be most efficient. Typically, it is much easier\nto define the legal characters than the illegal characters.\n\n## References\n\n[Category:Injection](https://owasp.org/www-community/Injection_Flaws)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/Command Injection.pdf"
    ],
    "report_names": [
        "Command Injection.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536126,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1615166033,
    "ts_modification_date": 1615166033,
    "files": {
        "pdf": "https://archive.orkl.eu/a14e65b0eb10033c5cc7b13c0b4ba932d03b60e8.pdf",
        "text": "https://archive.orkl.eu/a14e65b0eb10033c5cc7b13c0b4ba932d03b60e8.txt",
        "img": "https://archive.orkl.eu/a14e65b0eb10033c5cc7b13c0b4ba932d03b60e8.jpg"
    }
}