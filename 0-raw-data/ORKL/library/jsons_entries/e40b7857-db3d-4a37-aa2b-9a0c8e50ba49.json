{
    "id": "e40b7857-db3d-4a37-aa2b-9a0c8e50ba49",
    "created_at": "2023-01-12T15:02:47.383038Z",
    "updated_at": "2025-03-27T02:05:29.348913Z",
    "deleted_at": null,
    "sha1_hash": "64fe798e6ea3cd3479a3b31de3586030aa51b03f",
    "title": "2021-02-11 - Web shell attacks continue to rise",
    "authors": "",
    "file_creation_date": "2022-05-27T23:12:27Z",
    "file_modification_date": "2022-05-27T23:12:27Z",
    "file_size": 452095,
    "plain_text": "# Web shell attacks continue to rise\n\n**[microsoft.com/security/blog/2021/02/11/web-shell-attacks-continue-to-rise/](https://www.microsoft.com/security/blog/2021/02/11/web-shell-attacks-continue-to-rise/)**\n\nFebruary 11, 2021\n\nOne year ago, we reported the steady increase in the use of web shells in attacks worldwide.\nThe latest Microsoft 365 Defender data shows that this trend not only continued, it\naccelerated: every month from August 2020 to January 2021, we registered an average of\n140,000 encounters of these threats on servers, almost double the 77,000 monthly average\nwe [saw last year.](https://www.microsoft.com/security/blog/2020/02/04/ghost-in-the-shell-investigating-web-shell-attacks/)\n\n\n-----\n\n_Figure 1. Web shell encounters on servers_\n\nThe escalating prevalence of web shells may be attributed to how simple and effective they\ncan be for attackers. A web shell is typically a small piece of malicious code written in typical\nweb development programming languages (e.g., ASP, PHP, JSP) that attackers implant on\nweb servers to provide remote access and code execution to server functions. Web shells\nallow attackers to run commands on servers to steal data or use the server as launch pad for\nother activities like credential theft, lateral movement, deployment of additional payloads, or\nhands-on-keyboard activity, while allowing attackers to persist in an affected organization.\n\nAs web shells are increasingly more common in attacks, both commodity and targeted, we\ncontinue to monitor and investigate this trend to ensure customers are protected. In this blog,\nwe will discuss challenges in detecting web shells, and the Microsoft technologies and\ninvestigation tools available today that organizations can use to defend against these threats.\nWe will also share guidance for hardening networks against web shell attacks.\n\n## Web shells as entry point for attacks\n\nAttackers install web shells on servers by taking advantage of security gaps, typically\nvulnerabilities in web applications, in internet-facing servers. These attackers scan the\n[internet, often using public scanning interfaces like shodan.io, to locate servers to target.](https://www.shodan.io/)\nThey may use previously fixed vulnerabilities that unfortunately remain unpatched in many\nservers, but they are also known to quickly take advantage of newly disclosed vulnerabilities.\n\nFor example, on June 30, F5 Networks released a patch for CVE-2020-5902, a remote code\nexecution (RCE) vulnerability in Traffic Management User Interface (TMUI). The vulnerability\nis a [directory traversal bug with a CVSS score of 9.8 out of a possible 10. Just four days](https://owasp.org/www-community/attacks/Path_Traversal)\nlater, on July 4, exploit code was added to a Metasploit module.\n\n\n-----\n\n_Figure 2. CVE-2020-5902 exploit code_\n\nThe following day, Microsoft researchers started seeing the exploit being used by attackers\nto upload a web shell to vulnerable servers. The web shell was used to run common\ncryptocurrency miners. In the days that followed, industry security researchers saw the\nexploit being broadly used to deploy web shells, with multiple variants surfacing not long\nafter.\n\nThis incident demonstrates the importance of keeping servers up to date and hardened\nagainst web shell attacks. Web servers are frequently accessible from the internet and can\nbe used by attackers to gain access to a network.\n\n## Web shells as persistence mechanisms\n\nOnce installed on a server, web shells serve as one of the most effective means of\npersistence in an enterprise. We frequently see cases where web shells are used solely as a\npersistence mechanism. Web shells guarantee that a backdoor exists in a compromised\nnetwork, because an attacker leaves a malicious implant after establishing an initial foothold\non a server. If left undetected, web shells provide a way for attackers to continue to gather\ndata from and monetize the networks that they have access to.\n\nCompromise recovery cannot be successful and enduring without locating and removing\nattacker persistence mechanisms. And while rebuilding a single compromised system is a\ngreat solution, restoring existing assets is the only feasible option for many. So, finding and\nremoving all backdoors is a critical aspect of compromise recovery.\n\nAnd this brings us back to the challenge of web shell detection. As we mentioned earlier,\nweb shells can be generalized as a means of executing arbitrary attacker input by way of an\nimplant. The first challenge is dealing with just how many ways an attacker can execute\ncode. Web applications support a great array of languages and frameworks and, thus,\nprovide a high degree of flexibility and compatibility that attackers take advantage of.\n\nIn addition, the volume of network traffic plus the usual noise of constant internet attacks\nmeans that targeted traffic aimed at a web server can blend right in, making detection of web\nshells a lot harder and requiring advanced behavior-based detections that can identify and\nstop malicious activities that hide in plain sight.\n\n## Challenges in detecting web shells\n\nWeb shells can be built using any of several languages that are popular with web\napplications. Within each language, there are several means of executing arbitrary\ncommands and there are multiple means for arbitrary attacker input. Attackers can also hide\ninstructions in the user agent string or any of the parameters that get passed during a web\nserver/client exchange.\n\n\n-----\n\nAttackers combine all these options into just a couple of bytes to produce a web shell, for\nexample:\n\n_Figure 3. Example of web shell code_\n\nIn the example above, the only readable word in the web shell is “eval”, which can be easy to\nmiss or misinterpret. When analyzing script, it is important to leverage contextual clues. For\nexample, a scheduled task called “Update Google” that downloads and runs code from a\nsuspicious website should be inspected more closely.\n\nWith web shells, analyzing context can be a challenge because the context is not clear until\nthe shell is used. In the following code, the most useful clues are “system” and “cat\n/etc/passwd”, but they do not appear until the attacker interacts with the web shell:\n\n_Figure 4. Another example of web shell code_\n\nAnother challenge in detecting web shells is uncovering intent. A harmless-seeming script\ncan be malicious depending on intent. But when attackers can upload arbitrary input files in\nthe web directory, then they can upload a full-featured web shell that allows arbitrary code\nexecution—which some very simple web shells do.\n\n\n-----\n\nThese file-upload web shells are simple, lightweight, and easily overlooked because they\ncannot execute attacker commands on their own. Instead, they can only upload files, such as\nfull-featured web shells, onto web servers. Because of their simplicity, they are difficult to\ndetect and can be dismissed as benign, and so they are often used by attackers for\npersistence or for early stages of exploitation.\n\nFinally, attackers are known to hide web shells in non-executable file formats, such as media\nfiles. Web servers configured to execute server-side code create additional challenges for\ndetecting web shells, because on a web server, a media file is scanned for server-side\nexecution instructions. Attackers can hide web shell scripts within a photo and upload it to a\nweb server. When this file is loaded and analyzed on a workstation, the photo is harmless.\nBut when a web browser asks a server for this file, malicious code executes server side.\n\nThese challenges in detecting web shells contribute to their increasing popularity as an\nattack tool. We constantly monitor how these evasive threats are utilized in cyberattacks, and\nwe continue to improve protections. In the next section, we discuss how behavior-based\ndetection technologies help us protect customers from web shell attacks.\n\n## How Microsoft helps defend networks against web shell attacks\n\nGaining visibility into internet-facing servers is key to detecting and addressing the threat of\n[web shells. To tackle challenges in detecting these threats, Microsoft Defender for Endpoint](https://www.microsoft.com/en-us/microsoft-365/security/endpoint-defender)\nuses a combination of durable protections that prevent web shell installation and behaviorbased detections that identify related malicious activity. Microsoft Defender for Endpoint\nexposes malicious behavior by analyzing script file writes and process executions. Due to\nthe nature of web shells, static analysis is not effective—as we have shown, it is relatively\neasy to modify web shells and bypass static protections. To effectively deliver protection,\nMicrosoft Defender for Endpoint uses multiple layers of protection through behavior\ninspection.\n\n[Behavior-based blocking and containment capabilities, which use engines that specialize in](https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-atp/behavioral-blocking-containment)\ndetecting threats by analyzing behavior, monitor web-accessible directories for any new\nscript file creation. While file creation events alone cannot be treated as suspicious,\ncorrelating such events with the responsible process tree can yield more reliable signals and\nsurface malicious attempts. The engine can then remediate the script, neutralizing the\nprimary infection vector. For example, IIS instance (w3wp.exe) running suspicious processes\nsuch as ‘cmd.exe /c echo’, ‘certutil.exe’, or ‘powershell.exe’ that result in the creation of script\nfiles in web -accessible folders is a rare event and is, thus, typically a strong sign of web\nserver compromise and web shell installation.\n\n\n-----\n\nMicrosoft Defender for Endpoint also detects web shell installation attempts originating from\nremote systems within the organization using various lateral movement methods. For\nexample, attackers have been observed to drop web shells through Windows Remote\nManagement (WinRM) or use existing Windows commands to transfer web shells over SMB.\nOn the web server, these remote actions are carried by system processes, thus giving\nvisibility into the process tree. System privilege process dropping script files is another\nsuspicious event and provides the behavior inspection engines ways to remediate the script\nbefore the attackers can perform any malicious actions.\n\nBehavior-based protection also provides post-compromise defense in scenarios where\nattackers are already operating and running commands on web servers. Once attackers gain\naccess to a server, one of their first steps is to understand the privilege and the environment\nthey have access to by using built-in reconnaissance commands that are not typically used\nby web applications. IIS instance (w3wp.exe) running commands like ‘net’, ‘whoami’, ‘dir’,\n_‘cmd.exe’, or ‘query’, to name a few, is typically a strong early indicator of web shell activity._\n\nIIS servers have built-in management tools used by administrators to perform various\nmaintenance tasks. These platforms surface various PowerShell cmdlets that can expose\ncritical information to the attackers. IIS instances (w3wp.exe) that host various web-facing\nclient services such as Outlook on the web (formerly known as Outlook Web App or OWA) or\nExchange admin center (EAC; formerly known as the Exchange Control Panel or ECP)\n\n\n-----\n\naccessing the management platform or executing below cmdlets is a suspicious activity and\nsignifies a hands-on-keyboard attack. The behavior engine monitors execution of such\ncmdlets and the responsible process trees, for example:\n\nWith its behavior-based blocking and containment capabilities, Microsoft Defender for\nEndpoint can identify and stop behavior associated with web shell attacks. It raises alerts for\nthese detections, enabling security operations teams to use the rich investigation tools in\nMicrosoft Defender for Endpoint to perform additional investigation and hunting for related or\nsimilar threats.\n\n\n-----\n\n_Figure 5. Microsoft Defender for Endpoint alerts for behaviors related to web shell attacks_\n\nMicrosoft 365 Defender and Microsoft Defender for Endpoint customers can also run\nadvanced hunting queries to proactively hunt for web shell attacks:\n\n\n-----\n\nLook for suspicious process that IIS worker process (w3wp.exe), Apache HTTP server\nprocesses (httpd.exe, visualsvnserver.exe), etc. do not typically initiate (e.g., cmd.exe and\n_powershell.exe)_\n```\nDeviceProcessEvents\n| where InitiatingProcessCommandLine\nhas_any(\"beasvc.exe\",\"coldfusion.exe\",\"httpd.exe\",\"owstimer.exe\",\"visualsvnserver.exe\"\n or InitiatingProcessCommandLine contains 'tomcat'\n| where FileName != \"csc.exe\" // exclude csharp compiler\n| where FileName != \"php-cgi.exe\" //exclude php group, fast cgi\n| where FileName != \"vbc.exe\" //exclude Visual Basic Command Line Compiler\n| summarize by FileName\n\n```\nLook for suspicious web shell execution, this can identify processes that are associated with\nremote execution and reconnaissance activity (example: “arp”, “certutil”, “cmd”, “echo”,\n“ipconfig”, “gpresult”, “hostname”, “net”, “netstat”, “nltest”, “nslookup”, “ping”, “powershell”,\n“psexec”, “qwinsta”, “route”, “systeminfo”, “tasklist”, “wget”, “whoami”, “wmic”, etc.)\n```\nDeviceProcessEvents\n| where InitiatingProcessParentFileName in~\n(\"beasvc.exe\",\"coldfusion.exe\",\"httpd.exe\",\"owstimer.exe\",\"visualsvnserver.exe\",\"w3wp.\n or InitiatingProcessParentFileName startswith \"tomcat\"\n| where InitiatingProcessFileName in~\n(\"powershell.exe\",\"powershell_ise.exe\",\"cmd.exe\")\n| where FileName != 'conhost.exe'\n\n## Hardening servers against web shells\n\n```\nA single web shell allowing attackers to remotely run commands on a server can have farreaching consequences. With script-based malware, however, everything eventually funnels\nto a few natural chokepoints, such as cmd.exe, powershell.exe, and cscript.exe. As with\nmost attack vectors, prevention is critical.\n\nOrganizations can harden systems against web shell attacks by taking these preventive\nsteps:\n\nIdentify and remediate vulnerabilities or misconfigurations in web applications and web\nservers. Use Threat and Vulnerability Management to discover and fix these\nweaknesses. Deploy the latest security updates as soon as they become available.\nImplement proper segmentation of your perimeter network, such that a compromised\nweb server does not lead to the compromise of the enterprise network.\n[Enable antivirus protection on web servers. Turn on cloud-delivered protection to get](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-antivirus/enable-cloud-protection-windows-defender-antivirus)\nthe latest defenses against new and emerging threats. Users should only be able to\nupload files in directories that can be scanned by antivirus and configured to not allow\nserver-side scripting or execution.\nAudit and review logs from web servers frequently. Be aware of all systems you expose\ndirectly to the internet.\n\n\n-----\n\nUtilize the Windows Defender Firewall, intrusion prevention devices, and your network\nfirewall to prevent command-and-control server communication among endpoints\nwhenever possible, limiting lateral movement, as well as other attack activities.\nCheck your perimeter firewall and proxy to restrict unnecessary access to services,\nincluding access to services through non-standard ports.\nPractice good credential hygiene. Limit the use of accounts with local or domain admin\nlevel privileges.\n\nWeb shells and the attacks that they enable are a multi-faceted threat that require\n[comprehensive visibility across domains and platforms. Microsoft 365 Defender correlates](https://aka.ms/m365d)\nthreat data from endpoints, email and data, identities, and apps to coordinate cross-domain\nprotection. Learn how you can stop attacks through automated, cross-domain security and\nbuilt-in AI with Microsoft Defender 365.\n\n_Detection and Response Team (DART)_\n\n_Microsoft Defender Security Research Team_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-11 - Web shell attacks continue to rise.pdf"
    ],
    "report_names": [
        "2021-02-11 - Web shell attacks continue to rise.pdf"
    ],
    "threat_actors": [
        {
            "id": "8670f370-1865-4264-9a1b-0dfe7617c329",
            "created_at": "2022-10-25T16:07:23.69953Z",
            "updated_at": "2025-03-27T02:02:09.929725Z",
            "deleted_at": null,
            "main_name": "Hades",
            "aliases": [
                "Operation TrickyMouse"
            ],
            "source_name": "ETDA:Hades",
            "tools": [
                "Brave Prince",
                "Gold Dragon",
                "GoldDragon",
                "Lovexxx",
                "Olympic Destroyer",
                "Running RAT",
                "RunningRAT",
                "SOURGRAPE",
                "running_rat"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "0e03175d-b1fe-4d4e-bd3a-a8c0feb5eb43",
            "created_at": "2023-01-06T13:46:38.705578Z",
            "updated_at": "2025-03-27T02:00:02.896813Z",
            "deleted_at": null,
            "main_name": "APT6",
            "aliases": [
                "1.php Group"
            ],
            "source_name": "MISPGALAXY:APT6",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "392aed78-4ef6-46ac-afba-c3920ea05d28",
            "created_at": "2022-10-25T16:07:23.323349Z",
            "updated_at": "2025-03-27T02:02:09.737228Z",
            "deleted_at": null,
            "main_name": "APT 6",
            "aliases": [
                "1.php Group"
            ],
            "source_name": "ETDA:APT 6",
            "tools": [
                "Chymine",
                "Darkmoon",
                "Gen:Trojan.Heur.PT",
                "Poison Ivy",
                "SPIVY",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535767,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1653693147,
    "ts_modification_date": 1653693147,
    "files": {
        "pdf": "https://archive.orkl.eu/64fe798e6ea3cd3479a3b31de3586030aa51b03f.pdf",
        "text": "https://archive.orkl.eu/64fe798e6ea3cd3479a3b31de3586030aa51b03f.txt",
        "img": "https://archive.orkl.eu/64fe798e6ea3cd3479a3b31de3586030aa51b03f.jpg"
    }
}