{
    "id": "1aed04b2-4461-4271-9123-54ba7444bf37",
    "created_at": "2023-01-12T15:05:27.731973Z",
    "updated_at": "2025-03-27T02:09:18.737291Z",
    "deleted_at": null,
    "sha1_hash": "c02f59e161fa81afb9f57e483be55d2f37ad9623",
    "title": "2022-04-19 - BAZARLOADER- Unpacking An ISO File Infection",
    "authors": "",
    "file_creation_date": "2022-05-27T23:25:05Z",
    "file_modification_date": "2022-05-27T23:25:05Z",
    "file_size": 1566413,
    "plain_text": "# BAZARLOADER: Unpacking an ISO File Infection\n\n**[0ffset.net/reverse-engineering/bazarloader-iso-file-infection/](https://www.0ffset.net/reverse-engineering/bazarloader-iso-file-infection/)**\n\n[Chuong Dong](https://www.0ffset.net/author/chuong-dong/)\n19th April 2022\n1 Comment\n\n\nApril 19, 2022\n\n\nBAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through\nattachments in phishing emails. During an infection, the final loader payload typically\ndownloads and executes a Cobalt Strike beacon to provide remote access for the threat\nactors, which, in a lot of cases, leads to ransomware being deployed to the victim’s machine.\n\nIn this initial post, we will unpack the different stages of a BAZARLOADER infection that\ncomes in the form of an optical disk image (ISO) file. We will also dive into the obfuscation\nmethods used by the main BAZARLOADER payload.\n\nTo follow along, you can grab the sample as well as the PCAP files for it on Malware-TrafficAnalysis.net.\n\nSHA256: 0900b4eb02bdcaefd21df169d21794c8c70bfbc68b2f0612861fcabc82f28149\n\n\n-----\n\n## Step 1: Mounting ISO File & Extracting Stage 1 Executable\n\nRecent BAZARLOADER samples arrive in emails containing OneDrive links to download an\nISO file to avoid detection since most AVs tend to ignore this particular file type. With\nWindows 7 and above integrating the mounting functionality into Windows Explorer, we can\nmount any ISO file as a virtual drive by double-clicking on it.\n\nWhen we mount the malicious ISO file, we see that a drive is mounted on the system that\ncontains a shortcut file named “Attachments.lnk” and a hidden file named\n**“documents.log”.**\n\nThe shortcut file has to be run by the victim to begin the chain of infection. We can quickly\nextract the actual command being executed by this shortcut from its Properties window.\n```\nC:\\Windows\\System32\\rundll32.exe documents.log,vspa\n\n```\n\n-----\n\nOnce the victim double-clicks on the shortcut file, the command executes the Windows\n**rundll32.exe program to launch the “documents.log” file. This lets us know that the file**\nbeing launched is a DLL file, and the entry point is its export function vspa.\n\n## Step 2: Extracting Second Stage Shellcode\n\nTaking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it\nhas only a few functions and a really suspicious looking buffer of ASCII characters in its\ncustom .odata section.\n\n\n-----\n\nWith that in mind, we will just perform some quick static analysis to determine where we can\ndump the next stage.\n\nIn the first function of the vspa export, we see sub_1800045D6 takes a DWORD in as the\nparameter. This function returns a variable that contains an address to a function that is later\ncalled in the code.\n\nAt this point, we can safely guess that sub_1800045D6 is an API resolving function, and the\nparameter it takes is the hash of the API’s name. Because this is still the unpacking phase,\nwe won’t dive too deep into analyzing this function.\n\nInstead, I’ll just use OALabs’s **[HashDB IDA plugin to quickly reverse-lookup the hashing](https://github.com/OALabs/hashdb-ida)**\nalgorithm used from the hash. The result shows that the hash corresponds to an API name\n[hashed with Metasploit’s hashing algorithm ROR13.](https://github.com/OALabs/hashdb/blob/b3cc544fad41c749d04616663ac13f02bf1aaf37/algorithms/metasploit.py)\n\n\n-----\n\nAfter determining the hashing algorithm, we can use HashDB to quickly look up the APIs\nbeing resolved by this function. It becomes clear that this function resolves the\n**RtlAllocateHeap API, calls that to allocate a heap buffer and writes the encoded ASCII data**\nto it.\n\nFrom this point onward, we can guess that the packer will decode this buffer and launch it\nsomewhere later in the code. If we skip toward the end of the vspa export, we see a call\ninstructionon a variable that is not returned from the API resolving function, so it can\npotentially be our tail jump.\n\n\n-----\n\nThe last function to modify that v19 variable is sub_180003FE6, so we can quickly take a\nlook at that.\n\nIt turns out the sub_180003FE6 function just resolves and calls NtMapViewOfSection to\nmap a view of a section into the virtual address space and writes the base address of the\nview into the v19 variable. Then, it just executes qmemcpy to copy the data in the second\nvariable to the returned virtual base address.\n\n\n-----\n\nThis tells us two things. First, our guess that the v19 variable will contain the address to\nexecutable code is correct. Second, we know that the executable code is shellcode since the\ndata is mapped and executed directly at offset 0 from where it is written.\n\nFrom here, we can set up x64dbg, execute the DLL file at the vspa export, and break at the\ncall instruction. After stepping into the function, we will be at the head of the shellcode.\n\nWe can now dump this virtual memory buffer to retrieve the second stage shellcode for the\nnext unpacking step.\n\n## Step 3: Extracting The Final BAZARLOADER Payload\n\nWhen we examine the shellcode in IDA, we can quickly use the same trick with HashDB\nabove to see that the shellcode also performs API hashing with Metasploit’s ROR13.\n\n\n-----\n\nAt the entry point above, the shellcode resolves a set of functions that it will call, most\nnotably VirtualAlloc and VirtualProtect. These two functions are typically used by packers\nto allocate virtual memory to decode and write the next stage executable in before launching\nit.\n\nWith this in mind, our next step should be debugging the shellcode and setting breakpoints at\nthese two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or\nwe can launch the shellcode directly in our debugger using OALabs’s [BlobRunner or similar](https://github.com/OALabs/BlobRunner)\nshellcode launcher.\n\nOur first hit with VirtualAlloc is a call to allocate a virtual memory buffer at virtual address\n0x204140000 with the size of 0x2A000 bytes.\n\n\n-----\n\nWe can run until VirtualAlloc returns and start monitoring the memory at address\n0x204140000. After running until the next VirtualProtect call, we see that a valid PE\nexecutable has been written to this memory region.\n\nFinally, we can dump this memory region into a file to extract the BAZARLOADER payload.\n\n## Step 4: BAZARLOADER’s String Obfuscation\n\nAs we begin performing static analysis on BAZARLOADER, it is crucial that we identify\nobfuscation methods that the malware uses.\n\nOne of those methods is string obfuscation, where the malware uses encoded stack strings\nto hide them from static analysis.\n\n\n-----\n\nAs shown, a typical encoded string is pushed on the stack and decoded dynamically using\nsome multiplication, subtraction, and modulus operations.\n\nThere are different ways to resolve these stack strings, such as writing IDAPython scripts,\n[emulation, or just running the program in a debugger and dumping the stack strings when](https://github.com/mandiant/flare-emu)\nthey are resolved.\n\n## Step 5: BAZARLOADER’s API Obfuscation\n\nBAZARLOADER obfuscates most of its API calls through a few structures that it constructs\nin the DllEntryPoint function.\n\nFirst, the malware populates the following structure that contains a handle to Kernel32.dll\nand addresses to API required to load libraries and get their API addresses.\n\n\n-----\n\n```\nstruct API_IMPORT_STRUCT {\n  HANDLE kernel32_handle;\n  FARPROC mw_GetProcAddress;\n  FARPROC mw_LoadLibraryW;\n  FARPROC mw_LoadLibraryA;\n  FARPROC mw_LoadLibraryA2;\n  FARPROC mw_FreeLibrary;\n  FARPROC mw_GetModuleHandleW;\n  FARPROC mw_GetModuleHandleA;\n};\n\n```\nIt calls GetModuleHandle to retrieve the handle to Kernel32.dll, calls GetProcAddress to\nretrieve the address of the GetProcAddress API, and writes those in the structure.\n\nUsing the structure’s GetProcAddress API field, BAZARLOADER retrieves the rest of the\nrequired APIs to populate other fields in the structure. This API_IMPORT_STRUCT structure\nwill later be used to import other libraries’ APIs.\n\n\n-----\n\nNext, for each library to be imported, BAZARLOADER populates the following\n**LIBRARY_STRUCT structure that contains a set of functions to interact with the library and**\nthe library handle.\n```\nstruct LIB_FUNCS\n{\n  FARPROC free_lib;\n  FARPROC w_free_lib;\n  __int64 (__fastcall *get_API_addr)(API_IMPORT_STRUCT*, HANDLE, char*);\n};\nstruct LIBRARY_STRUCT\n{\n  LIB_FUNCS *lib_funcs;\n  HANDLE lib_handle;\n};\n\n```\nThe first 2 functions in the LIB_FUNCS structure just call the FreeLibrary API from the\nglobal API_IMPORT_STRUCT to free the library module.\n\nThe third function calls the GetProcAddress from the API_IMPORT_STRUCT’s field to\nretrieve the address of an API exported from that specific library.\n\n\n-----\n\nTo begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the\nlibrary name from a stack string and populates it with the corresponding set of functions and\nthe library handle retrieved from calling LoadLibraryA.\n\nBelow is the list of all libraries used by the malware.\n```\nkernel32.dll, wininet.dll, advapi32.dll, ole32.dll, rpcrt4.dll, shell32.dll,\nbcrypt.dll, crypt32.dll, dnsapi.dll, netapi32.dll, shlwapi.dll, user32.dll,\nktmw32.dll\n\n```\nThe LIBRARY_STRUCT structures corresponding to these are pushed into a global list in\nthe order below.\n```\nstruct LIBRARY_STRUCT_LIST\n{\n  LIBRARY_STRUCT *lib_struct_kernel32;\n  LIBRARY_STRUCT *lib_struct_wininet;\n  LIBRARY_STRUCT *lib_struct_advapi32;\n  LIBRARY_STRUCT *lib_struct_ole32;\n  LIBRARY_STRUCT *lib_struct_rpcrt4;\n  LIBRARY_STRUCT *lib_struct_shell32;\n  LIBRARY_STRUCT *lib_struct_bcrypt;\n  LIBRARY_STRUCT *lib_struct_crypt32;\n  LIBRARY_STRUCT *lib_struct_dnsapi;\n  LIBRARY_STRUCT *lib_struct_netapi32;\n  LIBRARY_STRUCT *lib_struct_shlwapi;\n  LIBRARY_STRUCT *lib_struct_user32;\n  LIBRARY_STRUCT *lib_struct_ktmw32;\n};\n\n```\n\n-----\n\nAfter this global list of LIBRARY_STRUCT is populated, an API can be called from a function\ntaking in its corresponding library’s LIBRARY_STRUCT structure and its parameters.\n\nThis function resolves the API name from a stack string, retrieves the API’s address using\nthe get_API_addr function from the library structure, and calls the API with its parameters.\n\n\n-----\n\nThe way the wrapper function is setup to call the actual API is really intuitive, making the\ncode simple to understand through static analysis. However, it’s a bit more difficult to\nautomate the process since there is no API hashing involved.\n\nFor my analysis, I just manually decode the stack strings in my debugger and rename the\nwrapper function accordingly.\n\nAt this point, we have fully unpacked BAZARLOADER and understood how the malware\nobfuscates its strings and APIs to make analysis harder.\n\nIn the next blog post, we will fully analyze how the loader downloads and launches a Cobalt\nStrike beacon from its C2 servers!\n\n## 1 Comment\n\nComments are closed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-19 - BAZARLOADER- Unpacking An ISO File Infection.pdf"
    ],
    "report_names": [
        "2022-04-19 - BAZARLOADER- Unpacking An ISO File Infection.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2d06d270-acfd-4db8-83a8-4ff68b9b1ada",
            "created_at": "2022-10-25T16:07:23.477794Z",
            "updated_at": "2025-03-27T02:02:09.824281Z",
            "deleted_at": null,
            "main_name": "Cold River",
            "aliases": [
                "Blue Callisto",
                "BlueCharlie",
                "Calisto",
                "Cobalt Edgewater",
                "Nahr Elbard",
                "Nahr el bared",
                "Seaborgium",
                "Star Blizzard",
                "TA446",
                "TAG-53",
                "UNC4057"
            ],
            "source_name": "ETDA:Cold River",
            "tools": [
                "Agent Drable",
                "AgentDrable",
                "DNSpionage",
                "SPICA"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535927,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653693905,
    "ts_modification_date": 1653693905,
    "files": {
        "pdf": "https://archive.orkl.eu/c02f59e161fa81afb9f57e483be55d2f37ad9623.pdf",
        "text": "https://archive.orkl.eu/c02f59e161fa81afb9f57e483be55d2f37ad9623.txt",
        "img": "https://archive.orkl.eu/c02f59e161fa81afb9f57e483be55d2f37ad9623.jpg"
    }
}