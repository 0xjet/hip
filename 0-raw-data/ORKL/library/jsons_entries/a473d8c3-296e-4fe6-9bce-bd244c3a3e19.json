{
    "id": "a473d8c3-296e-4fe6-9bce-bd244c3a3e19",
    "created_at": "2023-01-12T15:05:30.872208Z",
    "updated_at": "2025-03-27T02:16:39.942027Z",
    "deleted_at": null,
    "sha1_hash": "532d31f65aaeb7ea2268002d9969922d47a7bf26",
    "title": "2020-05-01 - The Many Paths Through Maze",
    "authors": "",
    "file_creation_date": "2022-05-28T02:48:56Z",
    "file_modification_date": "2022-05-28T02:48:56Z",
    "file_size": 1485483,
    "plain_text": "# The Many Paths Through Maze\n\n**crowdstrike.com/blog/maze-ransomware-deobfuscation/**\n\nShaun Hurley May 1, 2020\n\n[Maze ransomware is a recent addition to the ever-growing list of ransomware families. It](https://www.crowdstrike.com/epp-101/what-is-ransomware/)\nstands out from the others by leveraging a technique called control flow obfuscation to make\nstatic and dynamic analysis difficult for anyone attempting to reverse engineer the binary.\nMaze lives up to its name — anyone doing analysis will get lost through the endless amount\nof paths that can be taken through the code. But automated deobfuscation of Maze is not a\nterribly difficult task.\n\nCode obfuscations are legitimate techniques used to protect code from analysis by reverse\nengineers. The most common form of code obfuscation that a malware analyst will run into\ndaily is a packed binary. Various forms of anti-disassembly and control flow obfuscations are\nnext in line. Deobfuscation of these obfuscations range from trivial to bashing your head on\nthe keyboard and hoping for a miracle. For more information on code obfuscation, read\n_Surreptitious Software by Christian Collberg and Jasvir Nagra and Practical Binary Analysis_\nby Dennis Andriesse.\n\nThe primary purpose of this blog post is to present an approach to attack and deobfuscate\nthe various obfuscations leveraged by Maze’s author. The primary tools leveraged are the\nIDA Pro disassembler and Python. We cover some foundation material, the obfuscations, the\ndeobfuscated obfuscations, and how to accomplish deobfuscation using IDA’s Python API.\n\n\n-----\n\nFigure 1. IDA’s Navigation Bar Depicting Maze Ransomware\n\nOnce any binary is opened up in IDA, the analyst should take a look at the navigation bar.\nThis bar is a quick method to determine how difficult a binary may be to reverse engineer.\nThe bar depicted in Figure 1 is of Maze. The vast majority of the gray and brown areas are\nlegitimate code, junk code and undefined functions. The fact that there is so little blue\n(regular function code) lets an analyst know that they are about to have a rough day.\n\nThe approach taken in this blog post is blunt, effective and approachable by inexperienced\nreverse engineers. The primary method for identifying the obfuscations is to search for byte\npatterns and then deobfuscate all located patterns. The following section, “Understanding\nProgram Control Flow,” covers the basic technical details to pave the way for the rest of the\nblog.\n\n## Understanding Program Control Flow\n\nA program’s control flow is a path created out of the instructions that can be executed by the\nprogram. Disassemblers, like IDA, visualize control flow as a graph by creating a series of\nconnected blocks (called “basic blocks”). Each basic block has a single implicit entry point\nand a single implicit exit point. The entry points for a basic block are reached by jump\ninstructions, by call instructions or through the binary’s code entry point specified by the\nformat (PE, ELF, etc). This section can be skipped if the reader already understands program\ncontrol flow.\n\n\n-----\n\nFigure 2. Standard Control Flow Example\n\nFigure 2 is an example of visualizing a program’s control flow. To start, take the highlighted\nTEST instruction at address `004 . A TEST instruction will perform a bitwise AND operation`\non the two operands (EAX, EAX). If the result of the bitwise AND is zero, then the CPU’s\nZero Flag (ZF) is set to one; otherwise, the ZF is set to zero. The ZF is used by the JZ (“jump\nif zero”) instruction at address `006 to determine which path (left or right) to take. This is one`\nexample of something called a “conditional jump.” If the ZF is set to one, then the jump is\ntaken (right path), and instruction `020 will be executed next. Otherwise, the fall-through`\nside (left path) of the conditional branch is taken, and the instruction at address `00C is`\nexecuted.\n\nThere are two more instructions that need to be discussed: CALL and JMP. The CALL\ninstruction at `02A will jump to the address of` `Function001, execute the body of the`\nfunction and return the address following the call instruction ( 02F ). This is explained in\nmore detail in the section on function calls. A JMP instruction ( 01F, `040 ) is called an`\n“absolute jump” — the program will always jump to the specified target address.\n\n### Absolute Jumps, Conditional Jumps and Opcodes\n\nThis section is a quick overview of opcodes, jumps and conditional jumps. Before diving into\nthe different types of jumps, know that all assembly instructions are human-readable\nrepresentations of binary data. This binary data is put together into strings of bytes called\n\n\n-----\n\nopcode bytes. When patching code for binaries is discussed, what s being patched are the\nopcode bytes and not an operation on the readable assembly instruction.\n\nFigure 3. JZ Breakdown\n\nLet’s take the JZ from Figure 2, break it down and explain each component at address `006 .`\nThis is done in Figure 3. The first component is the instruction address, which indicates the\nlocation in process memory where an instruction exists. The opcode bytes are the machine\ncode that represent the mnemonic and the operand. The mnemonic is the human readable\nrepresentation of the operation going to be performed on the operand.\n\nIn this example, the kind of conditional jump being performed here is a relative jump if zero.\nThis can be determined based on the opcode bytes, `0F 84 (Figure 3). To calculate the`\njump target address for a relative jump, the last four bytes of the opcode are added to the\naddress of the next instruction ( 00C ). In this case, the value of the JZ operand is the four\nbytes following 0F `84 which are:` `14 00 00 00 . The operand value is little endian and will`\nbe reversed when the instruction is executed, that is `14 00 00 00 is actually` `00 00 00`\n```\n14 or 14h . So, the calculation to get a jump target address of 020 is 14h + 0Ch, which\n\n```\nadds up to `020h .`\n\n\n**Opcode (in**\n**hexadecimal)**\n\n\n**Mnemonic** **Operand Value**\n**Size**\n\n\n**Description**\n\n\nEB XX JMP 1 Byte Short relative jump\n\nE9 XX XX XX XX JMP 2 or 4 Bytes Near relative jump\n\n75 XX JNZ 1 Byte Short relative jump if ZF =\n0\n\n0F 85 XX XX XX XX JNZ 2 or 4 Bytes Near relative jump if ZF =\n0\n\n74 XX JZ 1 Byte Short relative jump if ZF =\n1\n\n0F 84 XX XX XX XX JZ 2 or 4 Bytes Near relative jump if ZF =\n1\n\nTable 1. Absolute and Conditional Jump Instructions\n\n\n-----\n\nA core part of deobfuscating Maze involves modifying the various jump instructions to\nremove control flow obfuscation. Table 1 describes the opcode, mnemonic and operand\nvalue size for each type of jump instruction that will be discussed.\n\n### How Function Calls Work\n\nThere are many different types of calling conventions for functions, but this section provides\na general explanation into how function calls work. The primary takeaway from this section\nshould be that a prologue sets up a function, an epilogue tears down a function, and a return\naddress is where execution resumes when a `RETN instruction is executed.`\n\nEvery function starts by executing a series of instructions designed to allocate space that will\ncontain the memory necessary for the function to complete its purpose. This is called a\n[“function prologue.” The allocated space is called a “stack frame,” and a function needs it to](https://en.wikipedia.org/wiki/Call_stack#Structure)\nstore and reference arguments, variables, and the return address. Two registers are used\nwhen referencing the stack: a stack pointer and a base pointer. On an x86 system, the stack\nand base pointers are called ESP and EBP, respectively.\n\nThe stack pointer (ESP) always points to the top of the stack. That means the value of ESP\nwill change when values are added or removed from the stack. This differs from EBP (the\nbase pointer), which remains the same throughout the lifetime of the function. By not being\nmodified, EBP can be used as a reference by the program’s code to know where local\nvariables (EBP-4), arguments (EBP+8) and the return address (EBP+4) are located on the\nstack.\n\nFigure 4. Function Prologue for Function_100\n\nFor example, in Figure 4, the Caller function (on the left) executes the CALL instruction at\naddress `002 . The CALL pushes the return address,` `008, to the stack and shifts ESP so`\nthat it points to the top of the stack. On the right is the prologue for Function_100 that will set\nup the function’s stack frame. Starting at address `100, the base pointer for Caller (current`\nvalue of EBP) is saved to the stack. The base pointer for `Function_100 is set to ESP. At`\n\n\n-----\n\naddress `102,` `13Ch bytes are reserved for use by` `Function_100 s local variables.`\nFinally, before anything else is done, the value stored in ECX is saved to the stack. This\nvalue will be restored in the function’s epilogue.\n\nFigure 5. Function Epilogue for Function_100\n\nThe epilogue in Figure 5 undoes everything that was done by the prologue. The original\nvalue of ECX is restored, local variable stack space is removed, both ESP and EBP are\nrestored to their original values, and the return instruction is executed. After the pop ebp\ninstruction (09B), ESP points to the stack space where the return address 008 is stored. The\nRETN instruction at 09C will return to whatever value is pointed to by ESP, in this case 008.\nAfter the RETN instruction is executed, control flow returns to 008, and ESP will point to the\ntop of the stack for Caller.\n\nThe information covered in this section can be a bit tricky to follow at first. However, a\ncomplete understanding is not necessary to follow along.\n\n## Absolute Jump Obfuscation\n\nA simple obfuscation is to insert extraneous control flow, and Maze does this quite a bit. On\nthe left side of Figure 6 is an absolute JMP instruction located at `004 . This will jump to`\nlocation `020 . However, on the right side, a series of conditional jumps is used to ultimately`\nend up at the same destination, loc_020. Walking through it, if the JZ instruction is followed,\n```\nloc_020 is reached. If it is not followed, however, the JNZ instruction will be followed, and\n\n```\nthe program jumps t0 `loc_010 . At` `010 is another JNZ that will jump to` `loc_020 . And, if`\nthe JNZ at `008 was followed because the zero flag is set to zero, then the JNZ instruction`\nat `010 is also going to be followed because the ZF is going to be the same. Therefore, the`\nprogram will always reach `loc_020 .`\n\n\n-----\n\nFigure 6: Absolute Jump Obfuscation\n\nThe fall-through branch for the JNZ instruction at `010 is the address 015 . This JZ`\ninstruction will never be reached because the JNZ will always jump. Conditional branches\nthat will never be executed are called “opaque predicates.” As IDA starts to identify what is\nand isn’t code, it reaches these opaque predicates and displays them in the GUI. IDA\nexpects the JZ instruction at `010 to have two branches: the code following` `015 and the`\ncode located at address `019 . Although none of this will be reached, all of it is displayed as`\ncode in IDA, creating a cluttered mess. The analyst has to sift through all of this and decide\nwhich instructions are pertinent.\n\nThe following subsections describe the types of conditional jump patterns and how they can\nbe deobfuscated.\n\n### JMP Type One: Absolute, Conditional Jump\n\nThis obfuscation takes an absolute jump and transforms it into a conditional jump that will\nalways end up at one of two jump target addresses. As can be seen in Figures 7, 8 and 9,\nthis obfuscation places the jump JZ and JNZ instructions in sequence. As mentioned\npreviously, each conditional jump has a fall-through branch and a jump target. In the case of\nFigure 7, if the fall-through branch of the JZ instruction is executed (address `000 ), that`\nmeans ZF is set to zero. The next instruction, JNZ, is executed and the jump target will\nalways be taken ( loc_004+4 ). This means that the address at `004 will never be reached.`\n\nFigure 7. Short JMP Type One Obfuscation, Incorrect JNZ Target Label in IDA\n\n\n-----\n\nIDA, however, expects the JNZ instruction at `002 to fall through if ZF is set to one. That`\nmeans the bytes located at `004 should be marked and displayed as valid x86 code. The`\nconsequence of displaying the binary data at 004 as code is that IDA ends up incorrectly\ndisplaying both the operand ( loc_004+4 ) for `002, and the code at jump target address`\n```\n008 . It is jumping to the last byte of the instruction at 004 . Confusing the disassembler in\n\n```\nthis manner is called “anti-disassembly.” In IDA, this can be resolved by undefining the\ninstruction at address `004 and marking the instruction at` `008 as code (Figure 8).`\nThroughout the rest of this post, each example will display the corrected code.\n\nFigure 8. Short JMP Type One Obfuscation, Correct JNZ Target Label in IDA\n\nFigure 9 is the same thing as Figure 7, but the instruction at `000 is a near (rather than a`\nshort) JZ. As expected, the bytecode starts with `0F 84 and the entire instruction length`\ngoes from two to six.\n\nFigure 9. Near JMP Type One Obfuscation\n\n**Deobfuscation**\n\nIf the instruction at 000 is not taken, then the instruction at 002 will always be taken. That\nmeans that the JNZ instruction at 002 is actually a short JMP. The transformation here is\nsimple — the JNZ instruction at address 002 (Figure 8) can be changed to a short JMP\ninstruction by modifying the first byte from 75 to EB.\n\n\n-----\n\nFigure 10. Short JMP Type One Obfuscation, Correct JNZ Target Label in IDA\n\n### JMP Type Two: Absolute, Multiple Conditional Short Jump\n\nThis obfuscation is similar to the JMP Type One obfuscation but with added JZ/JNZ blocks to\nfurther confuse IDA’s ability to visualize control flow. In Figure 11, either the JZ instruction at\n```\n000 will be taken, or the JNZ instruction at 002 will be executed. The JNZ instruction\n\n```\nat 002 jumps to the JNZ target at 008. A JNZ jumping to another JNZ is extraneous\nbecause the second JNZ jump will always be taken. In this example, one of two jump targets\nwill always be reached: `loc_6E456049 or` `loc_6E456049 .`\n\nFigure 11. Short JMP Type One Obfuscation, Correct JNZ Target Label in IDA\n\nThe instructions at `004,` `00A,` `00C and` `loc_6E456002 are all unreachable. This`\ntechnique multiplies the number of paths through Maze that IDA believes are accessible.\nEach one is a dead end.\n\nLike the JMP Type One obfuscation, the Type Two obfuscation has a short and a near\nversion.\n\n### Deobfuscation\n\n\n-----\n\nThe deobfuscation here is similar to the JMP Type One obfuscation. The JNZ instruction at\n002 (Figure 12) is changed to a short JMP by changing the first opcode byte `75 to` `EB .`\nThe JNZ instruction at `000 is not touched. The JNZ/JZ block at` `008 is zeroed out.`\n\nFigure 12. Near JMP Type Two Obfuscation, Correct JNZ Target Label in IDA\n\n## Call Instruction Obfuscation\n\nSimilar to the previous obfuscation types, Maze transforms CALL instructions into conditional\njumps. Not only will this confuse control flow, it combines multiple functions into a single\nfunction. This process is called “function inlining,” and it makes it difficult for IDA to properly\nidentify where functions begin and end. Figure 13 illustrates the obfuscation process.\n\n\n-----\n\nFigure 13. Obfuscated Function Call\n\nEach function follows a similar template. At instruction `000 in Figure 13, the return address,`\n```\nloc_020, for the function call is pushed to the stack. The next instruction jumps to the\n\n```\naddress of the function being called. The function prologue instructions preserve the state of\nregisters by pushing them on the stack and to allocate memory for local variables. After the\nprologue, the function body executes, and then the epilogue restores the state of the stack\nprior to the function being called. Once the state of the stack has been restored, control flow\nresumes to the address that was pushed at instruction `000 .`\n\nThere are multiple minor variations to the template, but the core part of the control flow\nremains intact. The following series of sections breaks down each variation of the control\nflow obfuscation into numbered types.\n\n### Call Type One: Indirect Absolute Jump\n\nThis obfuscation pushes the return address to the stack and then executes an indirect jump.\nAn indirect jump is a jump instruction where the operand of the JMP instruction is a register\nrather than the target address or the offset to a target address. The jump target address is\n\n\n-----\n\nstored in the register. In Figure 14, at address `005, the JMP instruction operand is the EDI`\nregister. To reach the destination of the JMP, the CPU needs to get the address from EDI.\nThis obfuscation breaks control flow, because IDA does not know where to jump and where\nto return.\n\nFigure 14. Call Type One Obfuscation\n\nIndirect jumps are a common instruction, and that on its own does not constitute control flow\nobfuscation. It’s the PUSH instruction followed by `jmp edi that makes this a Call Type One`\nobfuscation. In Maze, these obfuscations are often used to execute a Windows procedure\n( VariantClear, in this example). When a Windows procedure is called, it is more or less\nalways going to return to the instruction proceeding the call instruction. In this case, the\nreturn address for the function is pushed to the stack, and the JMP instruction is executed.\n\n**Deobfuscation**\n\nTo deobfuscate, the indirect jump at `005 (Figure 14) gets changed to a call by subtracting`\n```\n10h from the second opcode byte ( E7 ), the PUSH instruction at 000 gets changed to an\n\n```\nabsolute near jump, and the instructions are reordered so that the call instruction comes\nbefore the jump (Figure 15).\n\nFigure 15. Call Type One Deobfuscation\n\n### Call Type Two: Absolute, Conditional Jump\n\nThe primary difference between this obfuscation type and the JMP Type One obfuscation is\nthe addition of pushing the return address at `001 (Figure 16). The first instruction at` `000`\npushes whatever value is stored to ESI as an argument to the function.\n\nFigure 16. Call Type Two Obfuscation\n\n\n-----\n\n**Deobfuscation**\n\nThis deobfuscation is a case where the deobfuscation instructions don’t require as many\nopcode bytes as the original obfuscation instructions. There are a few different approaches\nto resolve this issue — in this case, no operation (NOP) instructions are used to overwrite\nthe original bytes. After overwriting the unnecessary bytes, the JZ/JNZ instructions are\nreplaced with a relative CALL instruction, and the return address pushed to the stack is used\nas the target for the absolute near jump at `00E .`\n\nFigure 17. Call Type Two Obfuscation\n\nA cleaner approach may be to move the CALL/JMP instruction sequence to address `001,`\njust after the PUSH instruction, and then zero out the unused bytes. This method would\nremove the extraneous NOP instructions from the basic block.\n\n### Call Type Three: Absolute, Multiple Conditional Jump\n\nOnce again, the primary difference between this obfuscation type and the JMP Type Two\nobfuscation is the addition of pushing the return address at `001 (Figure 16). The first`\ninstruction at `000 pushes whatever value is stored to EDI as an argument to the function.`\n\n\n-----\n\nFigure 18. Call Type Three Obfuscation, Correct JNZ Target Label in IDA\n\nThe example in Figure 18 is only a double jump, but there are variations where three of\nthese linked JNZ instructions ultimately end up in the same place. Deobfuscation has to be\nable to handle these cases.\n\n**Deobfuscation**\n\nThe deobfuscation for this type is similar to the method used in Call Type Two.\n\nFigure 19. Call Type Three Deobfuscation\n\n## Deobfuscation with IDA Python\n\nIDA Python is built on the [IDA SDK and this section will discuss how it can be leveraged to](https://www.hex-rays.com/products/ida/support/sdkdoc/index.html)\ndeobfuscate Maze. Deobfuscating the various control flow obfuscations discussed above\ngets redundant so the only case covered is the Call Type One obfuscation This example will\n\n\n-----\n\n[be enough to follow along in both the source code and in the later sections.](https://github.com/shamrockhoax/mazedecoder)\n\n### Locating Call Type One Obfuscations\n\nPrior to patching the IDA database (IDB) to remove the obfuscations, the locations for each\nobfuscation have to be identified. The simplest method for locating the obfuscations is by\nsearching the IDB for all instances of a specific opcode pattern.\n\nFigure 20. Call Type One Obfuscation\n\nIn Figure 20, the opcode pattern for address `000 is` `68 E8 52 44 6E . This instruction is`\npushing the four-byte address `6E4452E8 (little endian byte order) onto the stack. Because`\nthe four bytes following the `68 opcode byte are going to change based on which address is`\nbeing pushed, these will have to be excluded. This same issue pops up with the second\nopcode byte `E7 for the jump instruction at` `005 . The search string ends up looking like:`\n```\n68 ? ? ? ? FF . The ? is a wildcard match that will match any byte.\n\n```\nFigure 21. Opcode Searching for Call Type One Obfuscation\n\nThe loop in Figure 21 will iterate over each address where the opcode pattern was found.\nThe body of the loop (the snipped out code) will contain all of the logic used to verify that the\nfound byte pattern is a Type One Obfuscation.\n\n\n-----\n\nFigure 22. Verify PUSH Instruction for Call Type One Obfuscation\n\nOnce an opcode pattern has been found, the instruction at that address needs to be\ninterpreted. IDA may or may not have the correct instruction displayed here, but there is no\nway of knowing if that is the case. This blog post takes the approach of not trusting the\ncurrent state of the IDB. So, an `ida_ua.insn_t object is created and populated using the`\n```\nida_ua.decode_insn ( insn_t, ea ) method. The reference for this instruction can be\n\n```\nfound in the [online documentation. The key to success is using the online documentation](https://www.hex-rays.com/products/ida/support/sdkdoc/classinsn__t.html)\nalong with searching the IDA Python source located in IDAs installation directory. In short,\nthe `inst_t object gives us access to the following information about the instruction:`\n\nInstruction size\nOperand [type](https://www.hex-rays.com/products/ida/support/sdkdoc/group__o__.html#ga85e77bd8098a47465cd8e1193b6e154c)\nOperand [value](https://www.hex-rays.com/products/ida/support/sdkdoc/classop__t.html#a6baa38b521c143a794640d82df109ae2)\nOperand [address](https://www.hex-rays.com/products/ida/support/sdkdoc/classop__t.html#acaaeff517df0b7156b4b8521a3900cdc)\n\nThe two highlighted blue functions in Figure 22 are helper functions. The first retrieves the\ntarget address for the instruction (in this case, what is being pushed). The\n```\nCheckValidTargettingInstr() function validates that the PUSH instructions operand is\n\n```\nan `o_imm type,` `o_far type or` `o_near type. After the type has been validated, the code`\naddress being pushed — `6E4452E8 (Figure 20) — needs to be verified that the address`\npoints to executable code in the Maze binary.\n\nOnce this has been confirmed, the JMP instruction located at `005 can be validated. The`\nsteps are mostly the same, but instead of validating the address, the operand type will be\n```\no_reg, o_phrase or o_displ .\n\n### Patching Call Type One Obfuscations\n\n```\nOnce these instructions have been validated, the IDB can be patched to transform the\nobfuscation into the code in Figure 23. This is where things can get a bit frustrating. The goal\nis to get IDA to disassemble the code and present a cleaned-up version to whomever is\nanalyzing the Maze binary. To ensure that this occurs, the deobfuscation script takes the\nsteps discussed in this section.\n\n\n-----\n\nFigure 23. Call Type One Deobfuscation\n\nIn order to accurately patch the program, the deobfuscation script needs to know the address\nfor each of the obfuscated instructions, the address of the deobfuscated instructions, and the\naddress that is going to be the jump target. The first item is the address of the byte pattern\nmatch from the previous section.\n\nFigure 24. Getting the Deobfuscation Instruction Addresses\n\nFor all cases, the `call edi instruction is going to overwrite the` `push offset`\n```\nloc_6E4452E8 (Figure 20) instruction. In Figure 24, this is accomplished by the following\n\n```\ncode: `deobf_patch_call_addr = obf_push_instr_ea.`\n\nNow that the location of `call edi has been determined ( 000 ), the address for the` `jmp`\n```\nloc_6E4452E8 instruction needs to be calculated. Figure 23 shows that the JMP instruction\n\n```\nwill come after the two-byte CALL instruction, so the address is `002 . The question is, will`\nthat always be the case?\n\nFigure 25. Call Type One Obfuscation\n\n\n-----\n\nFigure 25 shows that the length of the CALL will not always be two. However, calculating the\ncorrect address is not difficult. Remember that the length of the deobfuscated CALL\ninstruction ( call edi ) will always be the same length as the obfuscated jump ( jmp edi ).\nThe address of the obfuscated jump is already known, so the instruction can be decoded into\nan `ida_ua.isn_t object. Once the instruction has been decoded, the address of the`\ndeobfuscated jump ( jmp loc_6E4452E8 ) can be calculated: `deobf_patch_jmp_addr =`\n```\nobf_push_instr_addr + obf_jmp_insn.size .\n\n```\nNow that the address of the deobfuscated jmp instruction is known, the JMP target address\ncan be calculated. Take a look at the JMP instruction at `003 in Figure 23. The` `E9 opcode`\nindicates that this is going to be a relative near jump. The four opcode bytes after the `E9`\nbyte are going to be the offset between the address of the next instruction and the return\naddress pushed by the PUSH instruction.\n\nFigure 26. Getting the JMP Target Address\n\nThe address of the next instruction is always going to be the address of the deobfuscated\nJMP instruction + five. This is known because a relative near JMP instruction has a size of\nfive bytes, and that is what will always be used in the Call Type One deobfuscation code.\nThe highlighted sections in Figure 26 show how the offset is calculated. The IDB can now be\npatched.\n\n\n-----\n\nFigure 27. Writing the Deobfuscated CALL Instruction\n\nWe start with the deobfuscated CALL instruction (Figure 27). First, the original PUSH\ninstruction is deleted using the IDA Python `del_items ( insn_addr, FLAG )procedure.`\nNext, the “for” loop walks over each byte of the obfuscated indirect JMP instruction ( jmp\n```\nedi ). It writes the first byte to the address of the CALL instruction, subtracts 16 from the\n\n```\nsecond byte to convert the JMP to a CALL, then writes the rest of the instruction. After the\nCALL instruction has been written, it is created using the `create_insn ( insn_addr )`\nprocedure.\n\nFigure 28. Writing the Deobfuscated Relative Near JMP Instruction\n\nIn Figure 28, the instruction that exists at this location is undefined using the\n```\nCleanupPatchArea ( addr, size ) function (see source code). The first opcode byte (E9)\n\n```\nis written to the location using `patch_byte ( addr, byte ). Next, the offset address for the`\nrelative near jump is written using `patch_dword(addr,` `dword) . The instruction is created,`\nand `plan_and_wait ( addr_start,` `addr_end ) is called to force IDA to reanalyze the`\ninstruction\n\n\n-----\n\nFigure 29. Ensure that the Code at the Jump Target is Recognized as Code\n\nThe instruction located at the jump target address may not be recognized as code by IDA. To\nensure that this will be interpreted not only as a valid instruction but the correct instruction,\nthe steps in Figure 29 are followed. Once this has completed, the Call Type One obfuscation\nis now deobfuscated.\n\n## Windows Procedure Call Obfuscation\n\nSome of the Windows API calls are obfuscated using the method outlined in this section.\nThis obfuscation connects all of the obfuscations covered in the previous sections and adds\na few twists. The purpose of this obfuscation is to call the\n```\nWinapi_LookupWindowsProcedure function. This function looks up the address of a\n\n```\nmodule name by hash and then executes the procedure. The method used to retrieve a\nMicrosoft Windows procedure address will not be covered in this blog.\n\n\n-----\n\nFigure 30. Windows Procedure Call Obfuscation, Incorrect IDA Rendering\n\nThe CALL instruction at address `010 in Figure 30 is doing something shifty. Recall that a`\nCALL instruction pushes the address of the next instruction to the stack — in this case, the\naddress is going to be `015 . Following the CALL instruction, the`\n```\nWinapi_LookupWindowsProcedure is immediately called using a Call Type Three\n\n```\nobfuscation (highlighted green). So the CALL pushes `015, and the Call Type Three pushes`\nthe return address `loc_050 . This is somewhat new, so let’s take a look at address` `015 .`\n\n\n-----\n\nFigure 31. Windows Procedure Call Obfuscation, Correct IDA Rendering\n\nFigure 31 shows what is actually located at address `015 . It is the name of a Microsoft`\nWindows DLL ( gdi32.dll, in this case). This DLL is going to be the first argument to the\n```\nWinapi_LookupWindowsProcedure function. The CALL instruction is used to push the first\n\n```\nargument. IDA interprets the bytes at `015 as code, and that makes it difficult to follow.`\n\n**Deobfuscation**\n\nIn Figure 30, instruction `01F is a Call Type Three obfuscation, and instruction` `050 is a`\nCall Type One obfuscation. Each obfuscation is deobfuscated using previously mentioned\nmethods.\n\nFigure 32. Windows Procedure Call Deobfuscation\n\nIn order to pass the first argument (module name) to `Winapi_LookupWindowsProcedure,`\nthe CALL instruction at `010 (Figure 31) will be replaced with a PUSH instruction. To`\naccomplish this, the module name is shifted from `015 to address` `01F (Figure 32). Now,`\nthe PUSH instruction can be added at `010 to be used as the first argument for the CALL to`\n```\nWinapi_LookupWindowsProcedure ( 015 ).\n\n## Function by the Slice\n\n```\nAll of the obfuscations that have been discussed turn the code into spaghetti. This confuses\ndisassemblers, like IDA, and makes it difficult to automatically identify and create functions.\nAfter deobfuscation has occurred, it may not be the case that IDA can automatically identify\nthe functions. This can be resolved by using IDA Python to identify and create functions\nbased on byte search patterns.The approach identifies an artifact from the prologue and an\nartifact from the epilogue, and then connects the two using a recursive descent parser.\n\n\n-----\n\nFigure 33. Function Epilogue\n\nThe function identification algorithm starts by locating a set of potential function epilogues.\nThe algorithm for epilogue identification:\n\nSearch for all `add esp,` `value opcodes ( 000 ):` `83 C4 or` `81 C4`\nTrack the amount being added to ESP (38h)\nStarting at `000, walk over the instructions until the return instruction is reached at`\n```\n   00A\n\n```\nTrack the registers being popped off the stack (ESI, EDI, EBP)\n\nThis algorithm can be repeated until all of the epilogues have been identified.\n\nFigure 34. Function Prologue\n\nTo locate a set of all of the potential prologues, the start address for each prologue ( 000, in\nthis case) needs to be identified. This is difficult because none of the functions that need to\nbe identified have a standard prologue (Figure 34). Since each prologue will have an\nequivalent epilogue and the epilogues are known, this can be used to identify the start\naddress for each prologue:\n\nSearch for all `sub esp,` `value opcodes` `(` `004): 83 EC` or `81 EC`\n\n\n-----\n\nStarting with the first SUB instruction located:\n\nCompare the number of bytes subtracted from ESP ( 38h ) to what was added to\nESP for each of the function epilogues that were found.\n\nThe expectation is that the same amount subtracted in the prologue will be\nadded in the epilogue.\nWalk backward, from `004 to` `000, and verify that each register being pushed to`\nthe stack is in the same order as what was popped from the stack in the set of\npotential epilogues for this function.\n\nIf the ESP manipulation value ( 38h ) and the register value PUSH/POP instructions match,\nthen it is safe to say that a function prologue has been identified and the start address has\nbeen located.\n\n### Control Flow Graph Recovery\n\nBoth the start address and the end address for the function have been identified, and now\nthe pieces in between, the basic blocks, need to be walked to confirm that the prologue and\nepilogue actually connect. A recursive descent parser is used to walk the control flow graph.\n[The implementation used in the source code is based on the example from the book](https://github.com/shamrockhoax/mazedecoder/blob/master/bytesearch/maze_function_analysis.py)\n_Practical Binary Analysis by Dennis Andriesse._\n\n### Function Creation\n\nThe only thing left to do is create the functions that were identified and cleaned up using the\nalgorithm outlined in the CFG Recovery section.\n\n1. Create the identified functions during the CFG Recovery process using IDA’s\n```\n   add_func ( start_address, end_address ) method.\n\n```\n2. Redefine functions that were undefined during the CFG Recovery process.\n\n## Conclusion\n\nAs demonstrated throughout this discussion, Maze’s obfuscated control flow can cause quite\na headache for an analyst, but with a little bit of planning (and Python), these obfuscations\ncan be removed. In the opening paragraphs of this blog post an IDA navigation bar of the\nobfuscated Maze binary was shown (Figure 1). The expectation is that this will be\nsignificantly different after deobfuscation.\n\nFigure 35. IDA Navigation Bar for Deobfuscated Maze Binary\n\n\n-----\n\nFigure 35 shows a significant improvement. Still, there is plenty of brown and gray space. It s\nto be expected. Not everything is going to be part of a regular function. The presented\nsolution is not going to deobfuscate 100% of the code. It will provide an analyst with enough\ndeobfuscated code that the control flow is both easier to follow and easier to manually\ncorrect.\n\nFor further reading on binary analysis and software obfuscation, both “Surreptitious\nSoftware” by Christian Collberg and Jasvir Nagra and “Practical Binary Analysis” are\nexcellent resources.\n\n[The source code has been published on GitHub.](https://github.com/shamrockhoax/mazedecoder/)\n\n**Additional Resources**\n\n_[Download the CrowdStrike® 2020 Global Threat Report.](https://www.crowdstrike.com/resources/reports/2020-crowdstrike-global-threat-report/)_\n_See the CrowdStrike Falcon® platform in action, and learn how true next-gen AV_\n_performs against today’s most sophisticated threats — get a full-featured free trial of_\n_CrowdStrike Falcon Prevent™ today._\n_To learn more about how to incorporate intelligence on threat actors and their tactics_\n_techniques and procedures (TTPs) into your security strategy, please visit the_ _Falcon_\n_X™ Threat Intelligence page._\n_For more information on the cellular automation depicted in the blog header image,_\n_read about_ _[John Conway’s Game of Life.](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-01 - The Many Paths Through Maze.pdf"
    ],
    "report_names": [
        "2020-05-01 - The Many Paths Through Maze.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535930,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653706136,
    "ts_modification_date": 1653706136,
    "files": {
        "pdf": "https://archive.orkl.eu/532d31f65aaeb7ea2268002d9969922d47a7bf26.pdf",
        "text": "https://archive.orkl.eu/532d31f65aaeb7ea2268002d9969922d47a7bf26.txt",
        "img": "https://archive.orkl.eu/532d31f65aaeb7ea2268002d9969922d47a7bf26.jpg"
    }
}