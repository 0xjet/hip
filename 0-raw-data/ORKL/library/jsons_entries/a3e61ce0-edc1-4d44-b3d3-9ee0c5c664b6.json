{
    "id": "a3e61ce0-edc1-4d44-b3d3-9ee0c5c664b6",
    "created_at": "2023-01-12T15:05:47.247329Z",
    "updated_at": "2025-03-27T02:16:25.484893Z",
    "deleted_at": null,
    "sha1_hash": "fd286900e2ef4649c51cb5f905b37423f72353c2",
    "title": "2022-03-11 - Part 1- LockBit 2.0 ransomware bugs and database recovery attempts",
    "authors": "",
    "file_creation_date": "2022-05-27T23:12:45Z",
    "file_modification_date": "2022-05-27T23:12:45Z",
    "file_size": 901361,
    "plain_text": "# Part 1: LockBit 2.0 ransomware bugs and database recovery attempts\n\n**techcommunity.microsoft.com/t5/security-compliance-and-identity/part-1-lockbit-2-0-ransomware-bugs-and-database-**\nrecovery/ba-p/3254354\n\nMarch 11, 2022\n\n_Research by: Nino (Detection and Response Team), Team Torstino (Detection and_\n_Response Team)_\n\n**_Disclaimer: The technical information contained in this article is provided for general_**\n_informational and educational purposes only and is not a substitute for professional advice._\n_Accordingly, before taking any action based upon such information, we encourage you to_\n_consult with the appropriate professionals. We do not provide any kind of guarantee of a_\n_certain outcome or result based on the information provided. Therefore, the use or reliance_\n_of any information contained in this article is solely at your own risk._\n\nLockBit 2.0 ransomware has been one of the leading ransomware strains over the last six\nmonths. Recently, the FBI [issued a flash alert outlining the technical aspects and tactics,](https://www.scmagazine.com/news/ransomware/fbi-issues-alert-for-lockbit-2-0-ransomware-group-enlists-public-for-help)\ntechniques, and procedures (TTPs) associated with the LockBit 2.0 affiliate-based\nransomware-as-a-service.\n\nSuffice it to say, a plethora of detailed research around this ransomware emerged as a result\n[of version \"2.0\", which surfaced back in the summer of 2021. All these public reports and](https://www.bleepingcomputer.com/news/security/lockbit-ransomware-now-encrypts-windows-domains-using-group-policies/)\ntechnical undertakings, however, fail to mention a critical aspect of this ransomware strain\nthat Microsoft Detection and Response Team (DART) researchers have discovered and is\nsomething often not discussed when bringing up the topic of ransomware: “buggy code”, and\nthe unpredictable consequences that it can induce.\n\n\n-----\n\nThis post illustrates a much more direct attempt at ransomware recovery targeting MSSQL\ndatabases, where we uncovered and further exploited bugs present in the LockBit 2.0\nransomware code, up to the point where we were able to revert the encryption process for\nthese database files and restore them back to a functioning state. This is often an impossible\ntask to carry out, given that it implies breaking decades of practical research into\ncryptography-- not simply in theory, but in actual implementation.\n\nThis two-part blog series will outline all the steps taken and challenges overcome, in order to\nrestore the damaged database files that served as a critical core of this customer’s\ninfrastructure.\n\n## Background\n\nWe uncovered critical inconsistencies with the logic of this ransomware upon our first\ninteraction with a LockBit 2.0 afflicted customer, who, incidentally, also purchased the\nsoftware capable of restoring the destruction the ransomware is known to wreak, known as\n\"the decryptor\" aspect of ransomware.\n\nThe unfortunate customer was soon to find out that the claims the affiliate-based\nransomware distributor made, about paying the ransom resolves to obtaining the decryptor\ncapable of restoring the effects of the encryption, were very dubious in their assertions. Upon\nattempting to use this purchased decryptor to restore critical database files, the customer\nwas met with very disappointing results and was perplexed as to why the restoration of these\ndatabase files was not going as expected, and what steps to take next.\n\nAt some point, DART became engaged with this customer, obtained access to both the\nencryptor and decryptor aspects of the ransomware, and with suspicions that \"faulty crypto”\nwas at play, analysis commenced.\n\n## Our observations on the encryptor and identifying its anomalies\n\nOne of the first things we can do to make our lives easier when suspecting faulty\nencryption/decryption is to first avoid the urge of digging into any literature regarding the\ndensely obtuse aspects of cryptography, or even more menacingly, modern cryptography.\nInstead, use the power that [Sysinternals handy-dandy Procmon provides in monitoring file](https://docs.microsoft.com/en-us/sysinternals/)\nI/O with the hopes of spotting any kind of anomalies or inconsistencies when either the\nencryptor or decryptor is running.\n\nThrough this monitoring we should get a quick (correct) picture of how the\nencryption/decryption algorithm is implemented, assuming that it is not doing all of this in\nmemory and indeed going through the I/O manager as is generally the case.\n\nFor instance, Figure 1 shows the encryptor in action on a test dummy file we created. It’s\nworth noting, when assuming faulty crypto algorithms are at play, to test on a variety of file\nsizes to see how/if they pan out differently. We often see a common mistake on larger sized\n\n\n-----\n\nfiles (at least 4GB or greater), especially in 32-bit encryptors, not understanding that the\nlarger the file size gets, the closer we get, and eventually cross, into signed territory. These\nmistakes can lead to incorrect checks on file sizes, how the internal file pointer is set, and so\non, that can introduce unintended corruption by the encryptor. Something to always keep an\neye out for.\n\nFigure 1. Test #1 of the encryptor in action\n\nTest #1: high-level observations\n\nIt increases the file size\nIt only encrypts the first 0x1000 bytes from the start of the header (in theory, enough to\nkill off any header metadata)\nAppends some data at the end of the original file size (0x200 bytes)\nAppends a .lockbit extension to the original filename\n\n**Spoiler: The data that it appends to the end of the encrypted file is the required decryption**\ninformation that the decryptor utilizes as part of its restoration process. Each file is encrypted\nwith a unique 16-byte initialization vector (IV) and AES256 key. Both are stored, encrypted\nwith a modified cha-cha dance, at the end of each individual encrypted file. The decryptor in\nturn knows how to find this “decryption blob”, extract the unique IV and AES256 key, and\nthen leverage them for the decryption. Other data is stored as well in these blobs, such as\nthe original file size and the AES block size.\n\nOur test #1 from the Procmon output in Figure 1 shows that the encryptor alters the original\nsize of the file it is about to corrupt, so it is only appropriate that it retains this original\ninformation somewhere when the decryptor begins to attempt its restoration process. At least\nthis is the theory. In practice, as we’re soon to find out, something quite different has the\npotential of happening.\n\nTesting the 1GB file was a good start, but let’s try a much larger file and again, observe the\nbehavior of the encryptor through Procmon.\n\n\n-----\n\nFigure 2. Test #2 for encryptor in action\n\nTest #2: high-level observations:\n\nStarts off like our first test but ends drastically different\nProcmon curiously does not generate a Result for the WriteFile operation when\nappending the decryption blob\nIt seems to further encrypt, at 65,536-byte intervals, more data\n\nHaving some clear differences from our first test run, the second one intrigues us enough to\ncontinue digging deeper with the suspicion that something is seriously not right here. It gets\neven more intriguing when we try to view the call stack for the WriteFile operations that\nfollow the instance where Procmon was unable to tell us the Result of appending the\ndecryption blob.\n\nFigure 3. Viewing the call stack for the WriteFile operations\n\nEvery WriteFile operation following the empty Result in the yellow highlighted row looks like\nthe Event Properties box on the right: empty. This is very strange indeed and requires a\ndeeper introspection than Procmon can give us. Before departing from the almighty\n\n\n-----\n\nProcmon, it continues to show its worth by providing us with a valuable vantage point of\nwhere to begin looking at: the call stack. We can see that at offset +0xA0842 is where we\npresumably never return from.\n\nNow feels like the right time to introduce our favorite toolset for any deep troubleshooting into\nthe picture: [Time Travel Debugging (TTD)](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview)\n\n## What exactly is the issue?\n\nPrior to introducing the TTD framework into the picture, we will first load the encryptor into\nIDA Pro and go to that offset identified by Procmon to observe the code at that location.\nDoing so, we can see that we are at the return address of what is a call to ntdll!NtWriteFile.\nDepending on what we can further spot in the disassembly or decompilation, the following\nplan is to re-run the encryptor again, but this time under the control of TTTracer to generate\nsome runtime data that we can work against.\n\nFigure 4. Code responsible for writing the encrypted contents back to disk\n\nLet’s also show the cleanup decompilation of this piece of code as well, to observe at a\nhigher level.\n\nFigure 5. Decompilation of Figure 4\n\nAs shown in both Figure 4 and 5, we can spot that something is off here; the NTSTATUS\nreturn value for the write file is not handled correctly. In fact, it’s flat-out wrong. One way that\nwe can demonstrate the consequence of this improper handling of the write file operation is\n\n\n-----\n\nto ask whether the encryptor operates asynchronously. The reasons for introducing this in\nour inquiry will be explained shortly.\n\nBut if we do dig a bit into the binary inside IDA, we can confirm the asynchrony of the\n[encryptor, implemented through I/O completion ports. The actual file encryption is done via a](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fwindows%2Fwin32%2Ffileio%2Fi-o-completion-ports&data=04%7C01%7Cdveluz%40microsoft.com%7C42b19698188843b7336e08d9e6819e5b%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637794266727598866%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&sdata=6j3WSpO%2FWM%2BILSG70uG9eiTF5LWcRQQINMNMtNTgKE0%3D&reserved=0)\ncallback routine executed as a thread, and very interestingly for the debugging enthusiasts,\n_hidden threads._\n\nFigure 6. Encryptor multi-threading initialization and using hidden threads that carry out the\nencryption\n\nWhat this call to NtSetInformationThread does is set the HideFromDebugger flag inside the\ninternal, executive thread structure, which guarantees that the debugger will never receive\nany debug events for this thread, effectively missing the controllable execution of these\nthreads. Something to be aware of when attempting to debug this encryptor in the traditional\nmanner. Since we plan to use TTTracer, these anti-debug shenanigans are moot, and we\ncan ignore them completely.\n\nThis is great and all, but what exactly is the issue here with the NTSTATUS value? First,\n[LockBit 2.0 devs mistakenly assume all unsuccessful NTSTATUS values are signed. For](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55)\ninstance, the following ones are very relevant to the encryptor given its asynchronous\nbehavior and are clearly not negative numbers.\n\n\n-----\n\nFigure 7. NTSTATUS values\n\nSecond, and more importantly, they entirely neglect the handling of pending I/O operations:\n**STATUS_PENDING. And given the asynchronous nature of I/O on Windows, this in theory**\ncould be every file I/O operation. Further, given that the encryption is carried out\nasynchronously as well through I/O completion ports, ntdll!NtWriteFile **can and will return**\n**STATUS_PENDING, which the caller must properly account for. How does one account for**\nit? Patience. (See [WaitForSingleObject and](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) [ZwWaitForSingleObject)](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwwaitforsingleobject)\n\nNot doing so will lead to unpredictable and potentially destructive behavior as LockBit 2.0 is\nmistakenly assuming success after each write operation when the return value is not signed.\nWhen multiple threads are at play, which they will be, you now create a situation that can\nresult in all these worker threads writing at unpredictable intervals. Seems like a minor\nordeal, but because of this mishandling, the entire stability of the encryptor is now in\nquestion. These effects naturally spill over to the decryptor as well.\n\n[IO_STATUS_BLOCK](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fwindows-hardware%2Fdrivers%2Fddi%2Fwdm%2Fns-wdm-_io_status_block&data=04%7C01%7Cdveluz%40microsoft.com%7C42b19698188843b7336e08d9e6819e5b%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637794266727598866%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&sdata=OOMfdiMc353bTHYAyLEUjBc9Ch6sFALDcwOZJuPqpF8%3D&reserved=0)\n```\nNtWriteFile(\nIN HANDLE      FileHandle,\nIN HANDLE      Event OPTIONAL,\nIN PIO_APC_ROUTINE ApcRoutine OPTIONAL,\nIN PVOID ApcContext OPTIONAL,\nOUTPIO_STATUS_BLOCK IoStatusBlock,\nIN PVOID       Buffer,\nIN ULONG       Length,\nIN PLARGE_INTEGER ByteOffset OPTIONAL,\nIN PULONG Key    OPTIONAL);\n);\n\n```\n_The operating system implements support routines that write IO_STATUS_BLOCK values to_\n_caller-supplied output buffers. For example, see ZwOpenFile or NtOpenFile. These routines_\n_return status codes that might not match the status codes in the IO_STATUS_BLOCK_\n\n\n-----\n\n_structures. If one of these routines returns STATUS_PENDING, the caller should wait_\n**_for the I/O operation to complete, and then check the status code in the_**\n**_IO_STATUS_BLOCK structure to determine the final status of the operation._**\n\n_If the routine returns a status code other than STATUS_PENDING, the caller should rely on_\n_this status code instead of the status code in the IO_STATUS_BLOCK structure._\n\n## About the broken decryptor (and decrypting files that it couldn’t)\n\nHaving now identified at least one critical flaw that can result in faulty crypto, let’s shift our\nattention to the decryption process itself, because our primary goal is to confirm, and then\nhopefully implement, a capacity to do what the purchased decryptor was supposed to do.\n\nFrom the customer, we were given several MSSQL encrypted database files which had the\npotential of being correctly decrypted. The reason that we can make such a claim is that the\nrequired decryption information (recall our earlier Procmon adventures) was still intact\nsomewhere in the file. Not where it’s supposed to be, but it’s there, nonetheless. This\nmisplacement, a direct result of the improper handling of the write file operation outlined\nabove, is what causes the decryptor to miss retrieving this blob of data. This mishandling can\neven unwittingly truncate or expand the original file size. Simply having the decryption blob\ninformation present in the encrypted binary does not really mean anything at this stage of\nwhat we’re trying to accomplish.\n\nOne of the first things that we tried to get the decryptor up and running accurately, was to\nremove all the data that follows the decryption blob in the encrypted database file, giving it\nthe appearance of being “correctly” appended, as it was originally intended to be. We then\nran the decryptor against it (under TTTracer) to see what would happen. We failed to decrypt\nthe file with this approach but with the resulting TTD trace, we have a window to peek into\nand identify the flaws in our wishful approach.\n\n\n-----\n\nFigure 8. The decryption blob was found,\n\nbut it’s not at the end/tail of the file as it’s supposed to be\n\nGoing through the generated trace file, we were able to identify that the decryptor does\nindeed find the decryption blob correctly now and furthermore, is able to successfully decrypt\nit to acquire the necessary IV and AES key for decryption. However, the file still does not get\ndecrypted. Digging deeper, we identified the issue being in how it tries to compare two\nLARGE_INTEGERs, that of the incoming, encrypted file size and the AES block size stored\nin the decryption blob data that it assumed it appended correctly.\n\nFigure 9. File size and the encrypted\n\ndatabase file we’re working against\n\n\n-----\n\n```\n// disassembly responsible for initiating this sequence, by storing the incoming file\nsize\n.text:00428721 mov esi, dword ptr [eax+lb_encrypt_file_t.og_filesz] ; fetch the\nLowerPart of the file size\n.text:00428724 mov eax, [eax+lb_encrypt_file_t.og_filesz.anonymous_0.HighPart] ;\nfetch the HighPart of the file size\n.text:00428727 mov [esp+1Ch], eax ; store the HighPart of the file size\n.text:0042872B lea eax, [esp+3E8h+var_268]\n.text:00428732 push eax\n.text:00428733 mov [esp+18h], esi ; save the LowerPart of the file size\n// in the TTD trace, looking at the incoming file size being stored as a\nLARGE_INTEGER\n00428724 8b4024 mov eax,dword ptr [eax+24h]\nds:002b:1c9e0024=00000013\n0:014> dd @eax\n1c9e0000 00000000 00000000 00000000 00000000\n1c9e0010 00000000 00000000 00000000 00000000\n1c9e0020 fffec200 00000013 00000000 00000001\n// size of the incoming file\n0:014> dt ntdll!_LARGE_INTEGER 1c9e0020 QuadPart\n0x00000013`fffec200\n+0x000 QuadPart : 0n85899264512\n// code that does the check after the offset has been calculated from the decryption\nblob\n.text:004288E6 mov eax, [esi+lb_encrypt_file_t.byte_offset.anonymous_0.HighPart]\n.text:004288E9 add edx, ecx\n.text:004288EB adc edi, eax\n.text:004288ED cmp [esp+1Ch], edx ; now check the LowerPart\n.text:004288F1 jnz __size_check_fail_cleanup\n.text:004288F7 cmp [esp+18h], edi ; now check the HigherPart\n.text:004288FB jnz __size_check_fail_cleanup\n__success_go_for_decryption_of_encrypted_content\n// go to the location where the check and “bug” is at\n0:014> dx @$calls(0x4288ED).First().TimeStart.SeekTo()\nTime Travel Position: 1CC3E8:F20 [Unindexed] Index\n0:014> u . l4\ndecryptor+0x288ed:\n004288ed cmpdword ptr [esp+1Ch],edx ; compare against LowerPart\n004288f1 jne __size_check_fail_cleanup ; they have to match, otherwise decryption is\nskipped\n004288f7 cmp dword ptr [esp+18h],edi ; compare against the HighPart\n004288fb jne __size_check_fail_cleanup ; they have to match, otherwise decryption is\nskipped\n0:014> r edx\nedx=00000200 ; AES block size calculated out of the data inside the decryption blob\n0:014> dd @esp+1c l1\n1a73fb9c fffec200 ; LowPart of incoming file size, failing when being compared to the\nsize of the decryption blob\n 0:014> r edi\nedi=00000014 ; very revealing, this tells us where the decryption blob should\n\n```\n\n-----\n\n```\nactually be (what the HighPart should be)\n0:014> dd @esp+18 l1\n1a73fba4 00000013 ; HighPart, we see our cutting off all the data after the\ndecryption blob breaks the logic here\n\n```\nBased on the TTD trace, simply cutting off all the data that follows the decryption blob won’t\nwork either, but we can spot what the issue is and even where the decryption blob is\noriginally supposed to be: minimum at offset 0x1400000000 in the file. The high part of the\nlarge integer for the incoming file is at offset 0x1300000000, but it fails when compared to\nthe original size that was calculated out of the decryption blob: 0x1400000000. But even\nbefore that, the comparison of 0xfffec200 and 0x200 also fails, since it’s expecting to have\ncorrectly calculated the AES block size, which it did not.\n\nRealizing this, we decided to “push” the decryption blob up to its proper offset, and then\nagain cut off all the data that followed it, to recreate the encrypted file once more into what\nshould be its originally intended structure. Once done, we re-run it through the decryptor and\nexcitedly await the results.\n\nFigure 10. Correctly aligning the decryption\n\nblob before we re-run the decryptor against it\n\nUpon running the decryptor this time around, we successfully decrypted the file!\n\n\n-----\n\n```\ndecryptor_pp+0x288ed:\n004288ed cmp   dword ptr [esp+0Ch],edx ss:002b:0271fb9c=00000200\n0:007> r edx\nedx=00000200// edx, as expected is 0x200\n0:007> dd @esp+c l1\n0271fb9c 00000200 // aes block size has correctly been calculated this time\n0:007> t         // step into, to validate the jne\ndecryptor_pp+0x288f1:\n004288f1 jne   decryptor_pp+0x28c0a (00428c0a)     [br=0]\n0:007> r zf\nzf=1\n0:007> t         // step into to compare the next check for the HighPart\ndecryptor_pp+0x288f7:\n004288f7 397c2414    cmp   dword ptr [esp+14h],edi ss:002b:0271fba4=00000014\n0:007> dd @esp+14 l1\n0271fba4 00000014    // we see that they're the same, and the decryptor works as\nexpected\n0:007> r edi\nedi=00000014\n0:007> t\n0:007> r zf\nzf=1\n\n```\nFigure 11. (L) Encrypted file; (R) Successfully decrypted file\n\nWhile this has the deceptive appearance of some kind of success, we must remain ever\ncognizant of the fatal bug that’s inside the encryptor. The critical flaw by these ransomware\ndevelopers in misunderstanding how NTSTATUS values work, and the consequences they\ncan have for naïve thread synchronization. Given that we don’t want to be unwitting victims\nof naivety ourselves, we quickly realized that the immensity of the problem was just now\nslowly starting to reveal itself.\n\n## Coming up in Part 2\n\nIn the [second part of this series, we will shift our focus to outlining the issues that the](https://techcommunity.microsoft.com/t5/security-compliance-and-identity/part-2-lockbit-2-0-ransomware-bugs-and-database-recovery/ba-p/3254421)\ndecryptor poses, uncover the file structure of the database files that we’re dealing with, throw\nin a little bit of crypto magic into play, and take the necessary steps to achieve our ultimate\ngoal: the successful restoration of all encrypted database files.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-11 - Part 1- LockBit 2.0 ransomware bugs and database recovery attempts.pdf"
    ],
    "report_names": [
        "2022-03-11 - Part 1- LockBit 2.0 ransomware bugs and database recovery attempts.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535947,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653693165,
    "ts_modification_date": 1653693165,
    "files": {
        "pdf": "https://archive.orkl.eu/fd286900e2ef4649c51cb5f905b37423f72353c2.pdf",
        "text": "https://archive.orkl.eu/fd286900e2ef4649c51cb5f905b37423f72353c2.txt",
        "img": "https://archive.orkl.eu/fd286900e2ef4649c51cb5f905b37423f72353c2.jpg"
    }
}