{
    "id": "d9457a86-eed4-44a9-a3a5-d238d439682a",
    "created_at": "2023-06-05T02:06:56.312442Z",
    "updated_at": "2025-03-27T02:06:12.87606Z",
    "deleted_at": null,
    "sha1_hash": "5fb6c94271b4c1ddadadfa2e7d94f3d383030624",
    "title": "2023-05-22 - Cloud-based Malware Delivery- The Evolution of GuLoader",
    "authors": "",
    "file_creation_date": "2023-06-04T12:54:00Z",
    "file_modification_date": "2023-06-04T12:54:00Z",
    "file_size": 1013821,
    "plain_text": "# Cloud-Based Malware Delivery: The Evolution of GuLoader\n\n**[research.checkpoint.com/2023/cloud-based-malware-delivery-the-evolution-of-guloader/](https://research.checkpoint.com/2023/cloud-based-malware-delivery-the-evolution-of-guloader/)**\n\n**Research by: Alexey Bukhteyev, Arie Olshtein.**\n\n## Key takeaways\n\n\nMay 22, 2023\n\n\nGuLoader is a prominent shellcode-based downloader that has been used in a large number of attacks to deliver a\nwide range of the “most wanted” malware.\nGuLoader has been active for more than three years and is still undergoing further development. The latest version\nintegrates new anti-analysis techniques, which results in it being significantly challenging to analyze. New GuLoader\nsamples receive zero detections on VirusTotal, ensuring its malicious payloads also remain undetected.\nGuLoader’s payload is fully encrypted, including PE headers. This allows threat actors to store payloads using wellknown public cloud services, bypass antivirus protections, and keep payloads available for download for a long period\nof time.\nEarlier versions of GuLoader were implemented as VB6 applications containing encrypted shellcode. Currently, the\nmost common versions are based on the VBScript and the NSIS installer. The VBScript variant stores the shellcode on\na remote server.\n\n## Introduction\n\nAntivirus products are constantly evolving to become more sophisticated and better equipped to handle complex threats. As\na result, malware developers strive to create new threats that can bypass the defenses of antivirus products. “Packing” and\n“crypting” services are specifically designed to resist analysis. GuLoader is one of the most prominent services\ncybercriminals use to evade antivirus detection.\n\n\n-----\n\nFigure 1 – The number of attacks using GuLoader in the past 6 months.\n\nIn addition to code encryption, GuLoader utilizes many other techniques including anti-debugging and sandbox evasion\ntechniques. A distinguishing feature of GuLoader is that the encrypted payload is uploaded to a remote server. The wouldbe attacker gets a highly protected shellcode-based loader that downloads the payload from a remote server, and decrypts\nand runs it in memory without dropping the decrypted data to the hard drive.\n\nDespite Google’s efforts to block GuLoader’s encrypted malicious payloads, GuLoader still downloads payloads from\nGoogle Drive in most cases. The following chart shows the statistics of the different hosting services used by GuLoader over\nthe past month.\n\nFigure 2 – Different hosting services used by GuLoader between March – April 2023.\n\nWe see evidence that GuLoader is currently being used to distribute the following malware:\n\nFormbook\nXLoader\nRemcos\n404Keylogger\nLokibot\nAgentTesla\nNanoCore\nNetWire\n\nEarly GuLoader samples managed to avoid detection by antivirus products, but later different security solutions became\ncapable of detecting this malware. However, in parallel with the ongoing development of antivirus software by cybersecurity\nvendors, the GuLoader developers also continued improving their product. In the absence of previous research findings and\n\n\n-----\n\nunderstanding of the anti analysis mechanisms employed in GuLoader, analyzing the code of the new version would be\nexceedingly challenging. You will discover the reasons for this below in our report.\n\n## Technical details\n\nThe earlier versions of GuLoader were implemented as VB6 applications containing encrypted shellcode. The shellcode\nperformed the main functions of loading the encrypted payload, decrypting it and launching it from memory.\n\nCurrently, the most common versions are based on the VBScript and the NSIS installer (Nullsoft Scriptable Install System).\n\n### VBScript variant\n\n[In the earlier version described at the end of 2022, the shellcode was stored inside the VBScript.](https://www.crowdstrike.com/blog/guloader-dissection-reveals-new-anti-analysis-techniques-and-code-injection-redundancy/)\n\nA distinctive feature of the new version is that the encrypted shellcode is hosted on a cloud service (usually Google Drive).\nVBScript itself contains only a small obfuscated PowerShell script and a lot of junk code. This allows GuLoader samples to\nmaintain a very low detection rate.\n\nHere is an example of an infection chain that uses the VBS variant of GuLoader:\n\nFigure 3 – Infection chain that uses VBS variant of GuLoader.\n\nLet’s consider a sample with SHA256 5fcfdf0e241a0347f9ff9caa897649e7fe8f25757b39c61afddbe288202696d5. At the\ntime of uploading to VirusTotal (VT) on March 3, 2023, it had 0 detections:\n\nFigure 4 – Zero detections of GuLoader sample in VT.\n\nTwo days after it was uploaded, only 17 out of 59 vendors flagged this sample as malicious.\n\nWe should note that at the time of writing this article, it has been 3 weeks since the specified sample was uploaded to VT,\nand the URLs for both downloading the GuLoader shellcode and for downloading the malicious payload (Remcos) were still\nactive:\n\nDescription MD5 URL\n\nShellcode 141da1d174041a32cc6a234d80d0b850 hxxps://drive.google.com/uc?\nexport=download&id=1BZ2BJVzqOMDwarpjiTzKEiwa42W1Dj9q\n\n\n-----\n\nPayload bcea24378a2134429ca82164827f1c25 hxxps://drive.google.com/uc?\nexport=download&id=1soTWv6y3rkBBbmMcBMOwovCqXxU4UQRB\n\nLet’s take a look inside the GuLoader VBScript. It contains a lot of pseudo-random comments and some useless\ncommands. After cleaning it up a bit, the code we got looks like this:\n\nFigure 5 – Cleaned GuLoader VBScirpt.\n\nThe purpose of this code is to call the PowerShell interpreter and pass it the code of the script collected in the “pa0” variable\nas a parameter.\n\nIf we look at the contents of the “pa0” variable after adding the omissions and hyphens, we get the following script:\n\nFigure 6 – GuLoader obfuscated PowerShell script.\n\nWe see that this new script contains the function “Gothites9“, which implements cutting the passed string starting from the\nsecond character with a step of 3. Therefore, the result for the command “$Tjene0 = Gothites9 ‘ OIUlEDiXSa ‘;” is “IEX ”.\n\nThe string $Parrotb is converted in the same way. Starting from position 2, taking every third character from this string gives\nus a string that is another PowerShell script:\n\n\n-----\n\nFigure 7 – GuLoader PowerShell script after removing the first layer of obfuscation.\n\nThis script is called either by using the IEX command (if the OS is 32-bit) or passed as a parameter to the PowerShell\ninterpreter called from the SysWOW64 folder (if the OS is 64-bit). This is because the GuLoader shellcode must run in a 32bit process.\n\nWe can already see that the script code contains the URL pointing to Google Drive.\n\nHowever, the resulting script is still heavily obfuscated. The script starts with a function that is used to decode strings:\n\nFigure 8 – Encoded strings in the GuLoader PowerShell script.\n\nIt is interesting that all lines in the nested script are stored in encoded form, except for the line with the URL.\n\nAfter deobfuscating the script, we got the following code:\n\nFigure 9 – Deobfuscated GuLoader PowerShell script.\n\nNow we can see that the script allocates 2 memory areas, downloads the data from the link to Google Drive, and saves it to\na temporary file “%APPDATA%\\Umig.For”. Next, the contents of the downloaded file are decoded using BASE64. The first\n654 bytes of the decoded data are placed in the first memory area (“$Gamme2483” in the example), and the rest in the\n\n\n-----\n\nsecond ( $Nulstille in the example). The first 654 bytes contain an obfuscated shellcode which is intended to decrypt the\nsecond copied area containing the main part of the shellcode in encrypted form.\n\nControl is transferred to the decryptor by using the CallWindowsProc callback function, which also receives the address of\nthe encrypted shellcode and the address of the NtProtectVirtualMemory function as arguments.\n\n### NSIS-installer based variant\n\nUnlike the VBS variant, samples based on the NSIS contain the GuLoader shellcode, albeit in encrypted form. This allows\nyou to run the sample in a sandbox and see the behavior of GuLoader even if the sandbox is not connected to the Internet.\nStatic analysis of NSIS script and encrypted shellcode is also possible.\n\nSuch samples now receive a consistent number of detections by antivirus products at the time of the first upload to\nVirusTotal.\n\nFigure 10 – Detection rate of NSIS-installer-based GuLoader variant.\n\n[We will not describe this variant in detail, as it was already analyzed in the article GuLoader: The NSIS Vantage Point.](https://www.trellix.com/en-us/about/newsroom/stories/research/guloader-the-nsis-vantage-point.html)\n\n## GuLoader shellcode\n\nThe same version of the shellcode is used in both the NSIS and VBS variants. As in previous GuLoader versions, the\nshellcode implements a large number of anti-analysis techniques:\n\nSandbox evasion techniques including:\n\nScanning memory for VM-related strings.\nChecking if the hypervisor bit is enabled, using CPUID instruction\n[(https://evasions.checkpoint.com/techniques/cpu.html#check-if-being-run-in-Hypervisor-via-cpuid).](https://evasions.checkpoint.com/techniques/cpu.html#check-if-being-run-in-Hypervisor-via-cpuid)\nMeasuring time, using RDTSC in combination with CPUID\n[(https://evasions.checkpoint.com/techniques/timing.html#rdtsc).](https://evasions.checkpoint.com/techniques/timing.html#rdtsc)\nSearching for QEMU related files: C:\\Program Files\\Qemu-ga\\qemu-ga.exe and C:\\Program Files\\qga\\qga.exe.\nCounting the number of Windows, using the EnumWindows API function\n[(https://evasions.checkpoint.com/techniques/ui-artifacts.html#check-number-of-top-level-windows).](https://evasions.checkpoint.com/techniques/ui-artifacts.html#check-number-of-top-level-windows)\nChecking if there are any VM-related drivers present, using the EnumDeviceDrivers API function.\nEnumerating installed software, using the MsiEnumProductsA and MsiGetProductInfoA.\n\nAnti-debugging techniques:\n\nHooking the functions DbgBreakPoint (https://anti-debug.checkpoint.com/techniques/processmemory.html#patch_ntdll_dbgbreakpoint) and DbgUiRemoveBreakIn (https://antidebug.checkpoint.com/techniques/process-memory.html#patch_ntdll_dbguiremotebreakin) to prevent the debugger\nfrom attaching.\nHiding the main thread from the debugger calling the NtSetInformationThread function with the\n[ThreadHideFromDebugger (https://anti-debug.checkpoint.com/techniques/interactive.html#ntsetinformationthread)](https://anti-debug.checkpoint.com/techniques/interactive.html#ntsetinformationthread)\nThreadInformationClass value.\n\nKnowing the techniques used by the GuLoader shellcode, it is quite easy to bypass them by using a debugger in the\nprocess of dynamic analysis. However, in the new version, we encountered a technique that makes both debugging and\nstatic analysis extremely difficult.\n\n### A new anti-analysis technique\n\n\n-----\n\nStarting from the end of 2022, the GuLoader shellcode uses a new anti analysis technique, which consists of breaking the\nnormal flow of code execution by deliberately throwing a large number of exceptions and handling them in a vector\nexception handler that transfers control to a dynamically calculated address.\n\nTo throw exceptions, the code uses the int3 instruction. It was possible to implement a script to automatically replace int3\ninstructions with jump instructions to the correct address:\n\nFigure 11 – Replacement of the int3 instruction with the jmp instruction.\n\nThis technique was first described in the article Malware Analysis: GuLoader Dissection Reveals New Anti-Analysis\nTechniques and Code Injection Redundancy. However, in the new version this technique has been improved. The shellcode\nstarted using three different patterns to throw exceptions and break the normal flow of code execution.\n\n**Accessing an invalid memory address to cause access violation.**\n\nThis pattern is quite straightforward. First, as a result of mathematical operations, one of the registers is set to zero value.\nThe shellcode then attempts to write data to the memory addressed by this register:\n\nFigure 12 – Accessing invalid memory address to raise the access violation exception.\n\nThis causes the access violation exception (0xC0000005). The exception is handled in GuLoader by the registered VEH\nwhich calculates the new address to continue the shellcode execution. The numbers used and the mathematical operations\nthat lead to the calculation of the zero value are always different.\n\n**Setting the Trap Flag to raise the single-step exception.**\n\nGuLoader uses the following combination of instructions to set TF in the EFALGS register:\n\nFigure 13 – Setting a Trap Flag to raise the single-step exception.\n\nAt first glance, it is unclear what happens in this piece of code. However, if we calculate the valued in the register EDI, we\nget the value 0x100. The combination of the next few instructions is intended to push the EFLAGS and set the TF (Trap\nFlag) bit to “1”. The modified value from the stack is then set back to the EFLAGS register.\n\nWhen the Trap flag is set in the EFLAGS register but no debugger is attached, the processor generates a single-step\nexception (0x80000004) after the execution of the next instruction. In GuLoader, the registered VEH is called in this case.\nHowever, if the debugger is attached, the GuLoader’s VEH is not called and execution follows the wrong path.\n\n\n-----\n\nThe code chunks in the GuLoader shellcode are always different; various combinations of registers can be used. As in the\ncase of invalid memory address, the numbers used and the mathematical operations that lead to the calculation of the value\n0x100 to set TF in the EFLAGS register are always different.\n\n**Using int3 to raise the breakpoint exception.**\n\nUsing int3 as instruction as an anti-analysis technique was already implemented in the previous version of GuLoader.\nHowever, it is still used in various parts of the GuLoader shellcode. When the CPU encounters the int3 instruction in the\nabsence of a debugger, it generates a breakpoint exception (0x80000003) and the registered VEH is called. However, if a\ndebugger is attached, the control is transferred to the debugger’s interrupt handler which typically pauses the program’s\nexecution.\n\nThe int3 instruction is usually followed by random bytes that break the normal execution of the shellcode:\n\nFigure 14 – Using int3 to raise the breakpoint exception.\n\nAs a result, we cannot determine the correct execution path without analyzing the code of the GuLoader VEH.\n\n### Exception handler\n\nTo calculate a new jump address in the case of one of the 3 specified exceptions, and direct the program to a new execution\npath, GuLoader registers a vector exception handler (VEH) using the RtlAddVectoredExceptionHandler function.\n\nTo see how the jump address is calculated, let’s look at the VEH code.\n\nLike other parts of the code, VEH code is obfuscated. It contains junk instructions, and important values are calculated\ndynamically using XOR operations:\n\nFigure 15 – Obfuscated VEH code.\n\nHowever, after the decompilation in IDA this code looks very simple:\n\n\n-----\n\nFigure 16 – Decompiled VEH code.\n\nAs you can see, VEH actions are slightly different depending on the exception code. In the case of exceptions 0x80000004\n(EXCEPTION_SIGNLE_STEP) and 0xC0000005 (EXCEPTION_ACCESS_VIOLATION), it gets the value of the byte at\noffset 2 from the instruction where the exception occurred and XORs that byte with some constant value (0x8B in the\nexample). In the case of exception 0x80000003 (EXCEPTION_BREAKPOINT), the byte at offset 1 is taken and also XORs\nwith the constant. It should be noted that the specified constant is different in all samples. The resulting value is then added\nto the EIP value in the exception context. Therefore, when exiting the exception handler, control is transferred to the new\naddress.\n\nIn all cases, the exception handler also checks the status of the debug registers:\n\nFigure 17 – Checking debug registers in VEH.\n\nIf any hardware breakpoints are set, the exception handler refers to the zero address instead of the ContextRecord address.\nThis eventually causes the application to crash.\n\nIn the case of EXCEPTION_BREAKPOINT, the exception handler also looks for software breakpoints in the address space\nbetween the old EIP and the calculated new EIP values.\n\nDespite the huge variety of code combinations that can be used to trigger the execution of the exception handler, they all\nfollow 3 patterns, and we can implement a regular expression to find most of them. However, we expect that the GuLoader\ndevelopers may change the patterns in new versions.\n\nTo patch one instruction on which an exception is raised and replace it with a jump to a correct address in x32dbg, you can\nuse the following script (you must replace 0x8B with a constant value from the sample you analyze):\n\n\n-----\n\n```\n     ,\ncmp 1:[eip], 0xCC\n\nje exception_breakpoint\n\nmov $x, 1:[eip + 2]\n\nxor $x, $const\n\njmp patch\n\nexception_breakpoint:\n\nmov $x, 1:[eip + 1]\n\nxor $x, $const\n\npatch:\n\nsub $x, 2\n\n1:[eip+1] = $x\n\n1:[eip] = 0xEB\n\n### URL decryption\n\n```\nAll the strings, including the URL for downloading the final payload, are encrypted and stored in a specific form in the\nshellcode:\n```\n; eax is set to the address of the allocated memory\n\n8B 44 24 04       mov   eax, [esp+target_enc_str_buffer]\n\n; first 4 bytes of the buffer contain the length of the encrypted string\n\n; the bytes are calculated using xor, add, and sub operations:\n\nC7 00 75 9B D5 11    mov   dword ptr [eax], 11D59B75h\n\n81 30 0E 84 7B 49    xor   dword ptr [eax], 497B840Eh\n\n81 28 1C 8B 75 41    sub   dword ptr [eax], 41758B1Ch\n\n81 00 B3 6B C7 E8    add   dword ptr [eax], 0E8C76BB3h ; 12 00 00 00\n\n; ...\n\n; increment eax by 4\n\n05 97 47 CD 01     add   eax, 1CD4797h\n\n2D 93 47 CD 01     sub   eax, 1CD4793h ; eax = eax + 4\n\n; ...\n\n; calculate next 4 bytes of the encrypted string\n\nC7 00 B9 FD D8 E0    mov   dword ptr [eax], 0E0D8FDB9h\n\n81 30 06 79 13 36    xor   dword ptr [eax], 36137906h\n\n81 30 AD 51 65 B7    xor   dword ptr [eax], 0B76551ADh\n\n81 30 81 FA 9D 8C    xor   dword ptr [eax], 8C9DFA81h ; 12 00 00 00 93 2F 33 ED\n\n; ...\n\n```\nFor the example above, we deobfuscated the code, clearing it of junk instructions and jumps. In reality, the code contains a\nlarge number of garbage and invalid instructions. To help understand the obfuscation complexity, this is part of the original\ncode corresponding to the previous example:\n\nFigure 18 – Composing encrypted strings in the heavily obfuscated GuLoader shellcode.\n\n\n-----\n\nUnlike strings, the decryption key is stored as a regular sequence of bytes following the decryption function:\n\nFigure 19 – Strings decryption XOR key.\n\nThis key is usually not very long, with a maximum of 64 bytes.\n\nThe strings are decrypted using an XOR operation with the decryption key. After decrypting the strings, we can find a string\nthat looks like a URL, but without a schema:\n```\nvgtirek34.138.169.8/wp-content/themes/seotheme/CbwPtnKqeAYGeixiNB73.inf\n\n```\nIt’s obvious that the GuLoader authors realized the way the research community managed to decrypt URLs in the previous\nversions of the shellcode using the strings “http://” or “https://” in the known-plaintext attack to detect the first bytes of the\ndecryption key. Therefore, in the new version, they replaced the URL scheme with random bytes.\n\nIf the 5 byte of the decrypted URL-string is equal to “s”, GuLoader replaces the first 8 bytes with “th **https://”. Otherwise, it**\nreplaces the first 7 bytes with “http://”.\n\nHere are examples of more URL-strings extracted from different samples:\n\n**Original string** **Schema**\n\nMatesIndgimiere.nl/XgSUmroHlWk92.bin https://\n\nKlshsShadrive.google.com/uc?export=download&id=1OSjh65P9X1Tx4cIemJXvrIa3Lt7pUc5C https://\n\nAppesNondrive.google.com/uc?export=download&id=1BMRiKvpSFYvKsNn6ilsl9DD3vFcz338C https://\n\nReseSyn45.88.66.147/kZDkFdCKTkJdSpwPQkKt70.bin http://\n\n### Payload decryption\n\nThe payload decryption key is also stored in the same way as the encrypted strings but the key is not encrypted. The key\nlength is usually in the range of 800-900 bytes.\n\nFor example, in a sample with MD5 40b9ca22013d02303d49d8f922ac2739, the length of the key is 844 bytes. However,\nanother length is used for the decryption routine, and is stored in the obfuscated form:\n\nFigure 20 – Key length used for decrypting the payload differs from the length stored with the key.\n\nGuLoader used a different size, rather than the size stored with the key, to deceive automated analysis. If we don’t take this\ninto account, we can only decrypt the first 843 bytes of the downloaded payload, and the rest of the data will be broken.\n\nThe payload decryption algorithm itself has not changed in comparison to the previous GuLoader versions. The first 64\nbytes of the downloaded data are skipped. Then, to get the final key, GuLoader assumes that the first 2 bytes of the\ndecrypted payload should be “MZ” and calculates the 2-bytes XOR key (rand_key). The payload decryption key is then\nXOR-ed with the calculated 2-bytes value:\n\n\n-----\n\nFigure 21 – Calculating the final key used for decrypting the payload.\n\nThe resulting key is finally used to decrypt the payload.\n\n## Conclusion\n\nSeveral years after its introduction, the threat posed by GuLoader continues to grow. This is primarily due to the fact that the\nGuLoader developers are continually working to improve their product. The advanced defense evasion of GuLoader made it\na favored tool among threat actors for delivering malware.\n\nGuLoader counteracts antivirus products using a variety of sandbox evasion techniques, code obfuscation, and multiple\nlayers of encryption. The GuLoader developers continually improve the anti-analysis and anti-debugging techniques. This\nyear we also saw the use of a new trick: moving the encrypted shellcode to the cloud, and using a VBScript to download the\nshellcode. As a result, victims receive a VBScript file, which is less suspicious than an .exe file and is less likely to trigger\nalerts.\n\nThe use of encryption and storing payloads in a raw binary format without any headers and separate from the loader makes\nthem totally invisible to antiviruses. This allows threat actors to use Google Drive to store malicious payloads and bypass its\nantivirus protection. In some cases download links to GuLoader malicious payloads stored in Google Drive remain active for\nvery long periods of time.\n\n## Appendix: Indicators of Compromise\n\nDescription MD5 ITW URL\n\n\nGuLoader\nVBScript\n\nGuLoader\nshellcode\n(base64)\n\nEncrypted\nRemcos\npayload\n\nDecrypted\nRemcos\npayload\n\nGuLoader\nNSIS\n\nGuLoader\nencrypted\nshellcode\n(NSIS)\n\n\n9623c946671c6ec7a30b7c45125d5d48\n\n141da1d174041a32cc6a234d80d0b850 https://drive.google.com/uc?\nexport=download&id=1BZ2BJVzqOMDwarpjiTzKEiwa42W1Dj9q\n\nbcea24378a2134429ca82164827f1c25 https://drive.google.com/uc?\nexport=download&id=1soTWv6y3rkBBbmMcBMOwovCqXxU4UQRB\n\nd5335a1ec161a8430e564bc66c16f894 https://drive.google.com/uc?\nexport=download&id=1soTWv6y3rkBBbmMcBMOwovCqXxU4UQRB\n\n40b9ca22013d02303d49d8f922ac2739\n\nc6e068ce04fb4959e2e6daaebac8d893\n\n\n-----\n\nDecrypted\nFormbook\npayload\n\n\n66274853e6f35e3fef0645a6587cb892 http://34.138.169.8/wpcontent/themes/seotheme/CbwPtnKqeAYGeixiNB73.inf\n\n\n_Check Point Threat Emulation provides protection against this threat:_\n\n_Dropper.Win.CloudEyE.*_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-22 - Cloud-based Malware Delivery- The Evolution of GuLoader.pdf"
    ],
    "report_names": [
        "2023-05-22 - Cloud-based Malware Delivery- The Evolution of GuLoader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930816,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1685883240,
    "ts_modification_date": 1685883240,
    "files": {
        "pdf": "https://archive.orkl.eu/5fb6c94271b4c1ddadadfa2e7d94f3d383030624.pdf",
        "text": "https://archive.orkl.eu/5fb6c94271b4c1ddadadfa2e7d94f3d383030624.txt",
        "img": "https://archive.orkl.eu/5fb6c94271b4c1ddadadfa2e7d94f3d383030624.jpg"
    }
}