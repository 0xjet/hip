{
    "id": "54e65d4b-6ab1-4533-a07e-af8425564653",
    "created_at": "2023-01-12T14:59:22.741681Z",
    "updated_at": "2025-03-27T02:09:18.664672Z",
    "deleted_at": null,
    "sha1_hash": "97a00a57e20b159224c70887968fde4a13722971",
    "title": "2020-06-15 - Striking Back at Retired Cobalt Strike- A look at a legacy vulnerability",
    "authors": "",
    "file_creation_date": "2022-05-28T02:08:51Z",
    "file_modification_date": "2022-05-28T02:08:51Z",
    "file_size": 1102127,
    "plain_text": "# Striking Back at Retired Cobalt Strike: A look at a legacy vulnerability\n\n**[research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability/](https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability/)**\n\nJune 15, 2020\n\n**This vulnerability applied to a 5 year old end of life version of CobaltStrike and is**\n**being published in the spirit of archaeological interest in the vulnerability.**\n\n## tl;dr\n\nThis blog looks at some of the communication and encryption internals of Cobalt Strike\nbetween Beacons and the Team Server in the 3.5 family. We then explore the subsequent\nexploitation of a vulnerability in Cobalt Strike 3.5 from 2016 to achieve remote\nunauthenticated code execution on the Team Server.\n\nWe hope that this post will help Blue Teams with detection engineering and provide a good\nunderstanding of the encryption fundamentals that underpin Cobalt Strike.\n\nFor the Red Team, we provide an example of why it is important to harden your Command\nand Control infrastructure.\n\n## Back Story\n\nIn Cobalt Strike there was a vulnerability fixed that existed in a number of versions:\n\n\n-----\n\nCobalt Strike <= 3.5\nCobalt Strike 3.5-hf1 (hot-fix addressing in-the-wild exploit chain)\nCobalt Strike 3.5-hf2 (further hardening)\n\nThe vulnerability was disclosed by the team at Cobalt Strike in 2016 as being actively\nexploited in September. [A patch was promptly released in the guise of 3.5.1.](https://blog.cobaltstrike.com/2016/10/03/cobalt-strike-3-5-1-important-security-update/)\n\n## Beacon Staging Primer\n\nBeacon staging is the process of downloading a beacon (DLL) shellcode blob, which will be\nexecuted via a smaller shellcode stager – typically as a result of an exploit or dropper\ndocument. The aim here being to work around size-constrained vulnerability exploitation, for\nexample where you only have a certain amount of space to hold your shellcode as the result\nof a buffer overflow or similar. That said, from a Red Team Operational perspective, fully\n[staged (a.k.a Stageless) payloads are always preferred where possible.](https://blog.cobaltstrike.com/2016/06/22/talk-to-your-children-about-payload-staging/)\n\nBy default, Cobalt Strike supports the Meterpreter staging protocol and exposes its stager\nURL via the [checksum8 format .](https://github.com/EmpireProject/Empire/blob/e37fb2eef8ff8f5a0a689f1589f424906fe13055/lib/common/http.py#L55)\n\nRetrieving stager via\n\nChecksum8\n\nSince Cobalt Strike 3.5.1, you can now also disable staging entirely using the “host_stage =\n_false” setting. This was added as a feature following the official fix for the vulnerability_\ndiscussed in this post.\n\nAfter the stager shellcode is downloaded, a custom XOR encoder is used to decode the rest\nof the shellcode, before execution is passed to the decoded beacon DLL. The XOR encoder\nused will not be discussed in the post as this is a feature of the licensed version of Cobalt\nStrike.\n\n\n-----\n\nAfter the DLL is extracted from the stager blob, the beacon settings can be extracted, along\nwith the public key, using a fixed XOR key of 0x69. This was recently published by the\n[SentinelOne team, who released the CobaltStrikeParser tool.](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n## The Internals of Cobalt Strike Beacon Comms\n\nOnce decoded and executed, the beacon then needs to communicate with the Team Server.\nThis involves various Cobalt Strike communications and encryption internals we need to\nunderstand prior to being able to build an exploit payload.\n\n### Beacon Checking In – 1..2..3 – Over: Keys Keys Keys..\n\nWhenever beacon checks in, it sends an encrypted metadata blob. This is encrypted using\nthe RSA public key, extracted from the stager. To aid in debugging you may also wish to\ndump the RSA private key from the Team Server.\n\nThis can be achieved using the following Java code, running on the Team Server. Private\nkeys are serialized in a file named “.cobaltstrike.beacon_keys”, in the same folder as the\nTeam Server files.\n\nTo compile/run this code, you will need set set your classpath to the cobaltstrike.jar file (e.g. cp cobaltstrike.jar)\nWhen run, the output will look like this:\n\nDumping Keys\n\nIt should be noted that this is strictly only to aid in debugging whilst writing an exploit. In a\nreal-world scenario it is not possible to decrypt existing Beacon communications as the keys\nare negotiated securely over RSA, with the beacon only having the public key. However, if\nyou are in possession of the public key (which can be retrieved via the checksum8 staging\nURL), then it is possible to encrypt and decrypt taskings via a fake session.\n\n### Beacon Communication Encryption and Metadata\n\n**Encryption, Decryption and Structure**\n\n\n-----\n\nMetadata from the beacon is sent according to the settings in the malleable C2 profile. This\nallows the operator to customise various properties of the traffic, such as where the metadata\nblob is sent (.e.g in a header, or a cookie), and how it is encoded. The following is from the\n[Cobalt Strike blog example.](https://www.cobaltstrike.com/help-malleable-c2)\n\nIn this example, the metadata will be sent Base64 encoded as a Cookie named “user”.\n```\nMalleable C2 Config\nhttp-get {\n  set uri \"/foobar\";\n  client {\n    metadata {\n     base64;\n     prepend \"user=\";\n     header \"Cookie\";\n  }\n}\n\n```\nThe following HTTP request capture shows a metadata blob being sent Base64 encoded in\nthe Cookie header, which is the default setting:\n\nBeacon\n\nMetadata Request\n\nBeacon metadata encryption uses RSA with PKCS1 padding, the following is an example in\nPython of encrypting beacon metadata using the stager public key:\n\nWhen decrypted (using the private key we extracted from our test Team Server) the\nmetadata looks like the below:\n\nDecrypted Metadata Blob\n\nAll decrypted metadata blobs are prepended with 8 bytes, which must always be present.\nThese 8 bytes are the magic number 48879 (0xBEEF), followed by the data size:\n\n\n-----\n\nBeacon Metadata Structure\n\nSo we can now encrypt / decrypt the metadata. Now onto the parsing..\n\n**Beacon Metadata Parsing**\n\nThe following Python code shows how the metadata from a Cobalt Strike beacon is parsed.\nOn Cobalt Strike < 4.0, the metadata fields (aside from the first 16-bytes) are made up of a\ntab-delimited string. This results in the IP address being treated as a (non sanity-checked)\nstring, which in version 3.5 leads to the directory traversal issue. However, on later versions\nthe IP address field is validated to ensure it is indeed a valid IP address using a regex.\n\nNote that this changed in Cobalt Strike 4.0, which added a number of new fields. The code\nbelow covers both 3.5 and 4.0 versions.\n\nWhen the parser is run on our decrypted metadata blob, it will result in the following output:\n\nMetadata Parsing\n\nWe now have enough information to generate and encrypt our own metadata.\n\n**Symmetric Encryption**\n\n\n-----\n\nCobalt Strike uses AES-256 in CBC mode with HMAC-SHA-256 for task encryption. For the\nversion of Cobalt Strike that the vulnerability existed in, this was included in the trial version,\nhowever from version 3.6 this is no longer enabled in non-licensed versions of Cobalt Strike.\nThis means that for some cracked or trial versions of Cobalt Strike used by adversaries,\nnetwork communications will be sent in cleartext. However, as we are looking at a version\nprior to 3.6, task encryption is always enabled.\n\nOnce the metadata is parsed, the Team Server will do a check to see whether this beacon is\na new beacon by checking whether the AES keys specified in the metadata are already\nregistered for the beacon ID value (also parsed from the metadata).\n\nIf no AES keys were previously registered for the beacon ID, then it goes ahead and sets the\nAES key for the beacon session. This is achieved by taking the first 16 bytes of the\ndecrypted beacon metadata. The first half (8 bytes) of which are used to derive the AES key,\nby calculating the SHA256 sum to create a 256 bit key. The same is done with the second\nhalf, which is used as the HMAC key. You may have noticed these parsed in the output\nabove. These keys can be used for task encryption and decryption.\nThe following Python script shows how the AES encryption/decryption works.\n\n**Beacon Tasking**\n\nSo far we have covered staging, metadata, checkins, asymmetric (RSA) and symmetric\n(AES) encryption. We can now stage fake beacons and decrypt taskings sent from the Team\nServer to the beacon. Next we will cover how to decrypt/encrypt beacon output back to the\nTeam Server.\n\nAfter the beacon has checked in (by including the encrypted metadata we previously\ncovered, within the request), if the Team Server has a task for the beacon it will send this as\nan encrypted response. As shown earlier, this is decrypted using the negotiated AES session\nkeys.\n\nWhat does the response to a tasking look like? In short, this response is also encrypted with\nAES in the same way that a tasking from the server is sent, however the beacon response\ndata is prepended with a length field.\n\nThe following screenshot shows an example of encrypted data sent by the beacon in\nresponse to a “ps” tasking:\n\n\n-----\n\nEncrypted Callback Response\n\nOnce the data is decrypted, we can see that it is prepended with 12 bytes, which indicate\nvarious properties of the output.\n```\n00 00 00 02 <- Counter (has to be higher than the previous one)\n00 00 0D 1B <- Size of the data\n00 00 00 11 <- Type of callback (in this case it's 17, which is OUTPUT_PS)\n5B 53 79 73 <- Data of size 0xD1B\n74 65 6D 20\n\n```\nThe following python code shows how to decrypt and decode beacon output\n\nRunning this code decrypts the output and shows the results of the “ps” command:\n\n\n-----\n\nDecrypting Beacon\n\nOutput\n\nSo at this point we can extract the keys we need, encrypt and decrypt communications so on\nto the vulnerability and exploitation.\n\n## The Vulnerability\n\n[The vulnerability itself was a directory traversal vulnerability (as the advisory states) in the](https://blog.cobaltstrike.com/2016/09/28/cobalt-strike-rce-active-exploitation-reported/)\nreported internal IP address of the beacon which was used to build a file path.\n\nWhen processing “download” responses, the Team Server would write these to the filesystem by re-creating the target system path on the Team Server filesystem, under the\n“downloads” folder within the working directory. The following screenshot shows an example\nof what this normally looks like. As shown, the downloaded file is stored within a folder\nnamed after the IP address of the beacon. Within this folder is the re-created filesystem\nstructure of the downloaded file.\n\n\n-----\n\nCS 3.5\n\nDownloads Folder\n\nAlthough traversal checks were carried out on the filename itself, the IP address field was\nnot checked, lading to a directory traversal vulnerability in the IP address field, which as we\ndemonstrated earlier, is set in the Beacon Metadata and controlled by the attacker.\n\nSo instead of reporting the beacons IP address as of 10.133.37.10 we report it as our target\nfolder, e.g. ../../../../etc/.\n\nNote: The vulnerable code uses the IP address value to build file paths, in various other\nplaces, including writing log files. Although log file poisoning is definitely an exploitable angle,\nwe chose to use the same method as the in-the-wild exploit – download callbacks.\n\n## Exploitation\n\nHaving a file system write primitive against typically against a Linux based server gives us\nvarious options for exploitation. We replicated the same technique employed by the in-thewild exploitation, that is:\n\nCheck in with a beacon with an internal IP address of ../../../../../[TARGET_FOLDER]/\nThen do a DOWNLOAD_START* callback which causes the file to get created\nThen do a DOWNLOAD_WRITE* callback which causes the contents to be written\n\n*Probably not the official term, but we will use these terms to refer to the task response types\nhere. Whereby, a DOWNLOAD_START is the initial response from a “download” tasking (this\ncauses the file to be created on the file-system), and DOWNLOAD_WRITE, is a response\n\n\n-----\n\ncontaining data to be written for the download task.\n\nBefore we can do this however, we need to understand the structure of both the\nDOWNLOAD_START and DOWNLOAD_WRITE callbacks. As previously explained, we\nknow that these are AES encrypted, prepended with an encrypted length, and also a counter\nand length once decrypted. But what is the structure of the decrypted data? This is explained\nbelow.\n\n**The DOWNLOAD_START callback structure.**\n\nThis callback type for the task is 2. The (decrypted) callback structure is as follows:\n\n**The DOWNLOAD_WRITE callback structure**\n\nThis callback type for the task is 8. The (decrypted) callback structure is as follows:\n\nTo actually achieve code execution we write a cronjob as the in-the-wild attacks did. Typically\nthis would involve sending the following values within the Metadata blob and task callback(s):\n\n\n-----\n\nAssuming we have written our functions to build the metadata blob (with the IP address\ntraversal string), and our chosen AES keys. We can stage a fake beacon and check in the\nDOWNLOAD_START and DOWNLOAD_WRITE callbacks with our crafted values. The\nfollowing example code demonstrates what this would look like:\n\nThe following video shows the exploit in action:\n\n## The Fix(es)\n\nAs described in the follow-up post by Cobalt Strike, the following fixes were added in 3.5.1\n\nA new SafeFile method was introduced, which takes the path that the file should be\nwritten to as the first argument, along with the filename to write as the second. It\nsubsequently ensures that, after canonicalisation, the file does not break out of the\ncanonicalised path passed in the first argument. This new method is used everywhere\na file write is carried out, including for writing log files and screenshots.\nThe host_stage malleable C2 configuration setting was added. When set to false, this\ncompletely disables payload staging, meaning that your Team Server will not host a\nstager via the checksum8 URL. This should be used whenever you do not require\npayload staging, however you should note that this may break some post-exploitation\nworkflows that you may be used to working with.\nDownloads are now stored using an ID value on the filesystem. This is mapped to the\nreal file-path in the data-model, which is what you see when you access the downloads\ntab via the Cobalt Strike GUI.\nThe Team Server now checks that the beacon has been tasked at least once before\nallowing most callback responses from the beacon. This ensures that an attacker can’t\nstage a fake beacon and start spoofing responses without the operator first interacting\nwith the beacon.\nIP address values reported in the Beacon Metadata are sanity checked against a regex\nto ensure that are actually an IP address.\n\n\n-----\n\nIn summary, the fixes applied in the 3.5.1 update are robust and address the vulnerability\nfrom multiple angles. As stated at the top of the post, this vulnerability existed in a legacy\n_version of Cobalt Strike and the vulnerability does not exist in the latest versions._\nNevertheless, we hope that this post provided some insight into Cobalt Strike internals, and\nprovides opportunities for both Blue and Red teams to improve in their fight against real\nadversaries.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-15 - Striking Back at Retired Cobalt Strike- A look at a legacy vulnerability.pdf"
    ],
    "report_names": [
        "2020-06-15 - Striking Back at Retired Cobalt Strike- A look at a legacy vulnerability.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535562,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653703731,
    "ts_modification_date": 1653703731,
    "files": {
        "pdf": "https://archive.orkl.eu/97a00a57e20b159224c70887968fde4a13722971.pdf",
        "text": "https://archive.orkl.eu/97a00a57e20b159224c70887968fde4a13722971.txt",
        "img": "https://archive.orkl.eu/97a00a57e20b159224c70887968fde4a13722971.jpg"
    }
}