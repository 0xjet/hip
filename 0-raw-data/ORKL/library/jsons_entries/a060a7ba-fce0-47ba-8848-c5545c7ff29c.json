{
    "id": "a060a7ba-fce0-47ba-8848-c5545c7ff29c",
    "created_at": "2023-01-12T15:06:48.554285Z",
    "updated_at": "2025-03-27T02:16:26.057552Z",
    "deleted_at": null,
    "sha1_hash": "2c6d03212bb5615960c3e76cb2792e523885536a",
    "title": "2022-09-03 - PLAY Ransomware",
    "authors": "",
    "file_creation_date": "2022-09-12T12:02:06Z",
    "file_modification_date": "2022-09-12T12:02:06Z",
    "file_size": 2046131,
    "plain_text": "# PLAY Ransomware\n\n**[chuongdong.com/reverse engineering/2022/09/03/PLAYRansomware/](https://chuongdong.com/reverse%20engineering/2022/09/03/PLAYRansomware/)**\n\nChuong Dong 3 September 2022\n\n[Reverse Engineering\n · 03 Sep 2022](http://10.10.0.46/categories/#reverse%20engineering)\n\n## Contents\n\n PLAY CTI\n\n**PLAY Ransomware (aka PlayCrypt) campaigns have been active since at least mid-July 2022. Up to five**\nransom notes of PLAY Ransomware have been uploaded to VirusTotal so far. In mid-August 2022, the first\npublic case of PLAY Ransomware was announced when a journalist uncovered that Argentina’s Judiciary of\nCórdoba was victimized.\n\nThe operators have been known to use common big game hunting (BGH) tactics, such as SystemBC RAT for\npersistence and Cobalt Strike for post-compromise tactics. They have also been known to use custom\nPowerShell scripts and AdFind for enumeration, WinPEAS for privilege escalation, and RDP or SMB for lateral\nmovement while inside a target network.\n\nThe group appends “.play” to encrypted files and its ransom note only includes the word “PLAY” and an email\naddress to communicate with the threat actors. The threat actors have been known to exfiltrate files using\nWinSCP but are not known to have a Tor data leak site like many other BGH ransomware campaigns.\n\nHuge thanks to my man [Will Thomas for this information!](https://twitter.com/BushidoToken)\n\n## Overview\n\nThis is my analysis for PLAY Ransomware. I’ll be solely focusing on its anti-analysis and encryption features.\nThere are a few other features such as DLL injection and networking that will not be covered in this analysis.\n\nDespite its simplicity, PLAY is heavily obfuscated with a lot of unique tricks that have not been used by any\nransomware that comes before.\n\nThe malware uses the generic RSA-AES hybrid-cryptosystem to encrypt files. PLAY’s execution speed is\npretty average since it uses a depth-first traversal algorithm to iterate through the file system. Despite\nlaunching a separate thread to encrypt each file, this recursive traversal hinders its performance significantly.\n\n## IOCS\n\nThe analyzed sample is a 32-bit Windows executable.\n\n**MD5: 223eff1610b432a1f1aa06c60bd7b9a6**\n\n**SHA256: 006ae41910887f0811a3ba2868ef9576bbd265216554850112319af878f06e55**\n\n**Sample:** [MalwareBazaar](https://bazaar.abuse.ch/sample/006ae41910887f0811a3ba2868ef9576bbd265216554850112319af878f06e55/)\n\n\n-----\n\n_Figure 2: VirusTotal Result._\n\n## Ransom Note\n\nThe content of the default ransom note is stored as an encoded string in PLAY’s executable, which contains\nthe string “PLAY” as well as an email address for the victim to contact the threat actor.\n\n**PLAY’s ransom note filename is “ReadMe.txt”.**\n\n_Figure 3: PLAY’s Ransom Note._\n\n## Anti Analysis\n\n### Anti-Analysis: Return-Oriented Programming\n\nUpon opening the executable in IDA, we can see that most of the assembly code does not make sense and is\nnot too meaningful. An example can be seen from WinMain, where there is no clear return statement with\ngarbage bytes popping up among valid code.\n\n\n-----\n\n_Figure 3: Anti-decompiling Feature in WinMain._\n\nAs shown in the disassembled code above, the control flow in WinMain calls sub_4142F5, and upon return,\n**edi is popped and we run into the garbage bytes at 0x4142F2. As a result, IDA fails to decompile this code**\nproperly.\n\n_Figure 4: Unpatched WinMain Decompiled Code._\n\nExamine sub_4142F5, we see that the value stored at the stack pointer is immediately added by 0x35 before a\n**retn instruction is executed.**\n\nWe know that the call instruction basically contains two atomic instructions, one pushing the address of the\nnext instruction (after the call instruction) onto the stack and one jumping to the subroutine being called. When\nthe code enter sub_4142F5, the return address (in this case, it is 0x4142F1) is stored at the stack pointer on\ntop of the stack. The subroutine adds 0x35 to this, changing the return address to 0x414326, and retn to jump\nto it.\n\nKnowing this, we can scroll down and try to disassembly the bytes at 0x414326 to get the next part of the\n**WinMain code.**\n\n\n-----\n\n_Figure 5: Disassembled Hidden Code._\n\nUsing this return-oriented programming approach to divert the regular control flow of the program, PLAY is able\nto bypass most static analysis through IDA’s disassembly and decompilation.\n\nWe can also quickly see that at 0x41433A, there is another call instruction followed by some garbage bytes.\nThis means that the obfuscation occurs multiple times in the code.\n\nMy approached to this was to programmatically patch all these call instructions up. A simple patch used in my\nanalysis is calculating the jump (the value added to the return address) and replacing the call instruction with a\n**jump instruction to the target address.**\n\nTo scan for all of this obfuscated code, I use 3 different (but quite similar) regexes(is this a word?) in IDAPython\n[to find and patch them. You can find my patching script here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/PLAY/script.py)\n\nAfter patching, the WinMain code looks something like this.\n\n\n-----\n\n_Figure 6: Patched WinMain._\n\nA little underwhelming, but now we have successfully deobfuscated the code, get a meaningful call instruction\nto sub_415110 and a proper returning statement in the decompiled code!\n\n### Anti-Analysis: Garbage Code\n\nBeside control flow obfuscation, PLAY also litters its code with random moving instructions that don’t contribute\nto the main functionality of the program.\n\n\n-----\n\n_Figure 7, 8: Garbage Code._\n\nThis makes the decompiled code looks a lot messier, and it is not simple to patch all of these ups since valid\ncode is usually stuffed in between of these garbage code. Patching by jumping over them would sometime\nbreak the program itself.\n\nThe only solution I have for this is to mentally ignore them while analyzing.\n\n### Anti-Analysis: API Hashing\n\nSimilar to most modern ransomware, PLAY obfuscates its API call through API name hashing. The API\nresolving function takes in a target hash and a DLL address.\n\n\n-----\n\nIt walks the DLLs export table to get the name of the exports. For each API name, the malware calls\n**sub_40F580 with the name as the parameter and adds 0x4E986790 to the result to form the final hash. This**\nhash is compared with the target hash, and if they match, the address of the API is returned.\n\n_Figure 9: API Hashing._\n\nAs shown below, the hashing function contains a lot of unique constants, which allows us to quickly look up that\nit is xxHash32. With this, we know that the full hashing algorithm is xxHash32 with the seed of 1 and the result\nadded to 0x4E986790.\n\n\n-----\n\n_Figure 10: xxHash32 Code._\n\nFrom here, I developed an IDAPython script to automatically resolve all APIs that the malware uses, which you\n[can find here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/PLAY/API_resolve.py)\n\n\n-----\n\n_Figure 11: Resolving APIs._\n\n### Anti-Analysis: String Encryption\n\nMost important strings in PLAY are encoded in memory. The decoding algorithm does not seem to be too clear,\nso I just dynamic-ed my way through these. School is whooping my ass right now, so I try to avoid analyzing\nstuff whenever I can.\n\n_Figure 12: PLAY’s String Decryption._\n\n## Static Code Analysis\n\n### Command-Line Arguments\n\n\n-----\n\n**PLAY can run with or without command line arguments.**\n\nBelow is the list of arguments that can be supplied by the operator.\n\n**Argument** **Description**\n\n**-mc** Execute normal functionality. Same as no command-line\nargument.\n\n**-d <drive path>** Encrypt a specific drive\n\n\n**-ip <shared resource path> <username>**\n**<password>**\n\n\nEncrypt network shared resource\n\n\n**-d <path>** Encrypt a specific folder/file\n\n_Figure 13: Checking Command-Line Arguments._\n\n### Crypto Initialization\n\nPrior to encryption, PLAY initializes and retrieves cryptographic algorithm providers.\n\nFirst, it calls BCryptOpenAlgorithmProvider to load and initialize a CNG provider for random number\ngeneration and BCryptImportKeyPair to import its hard-coded RSA public key.\n\n\n-----\n\n_Figure 14: Initializing & Importing Cryptographic Key._\n\nNext, the malware calls VirtualAlloc to allocate a buffer to store 128 file structures used for encrypting files.\nThe structure’s size is 0x48 bytes with its content listed below.\n```\n struct play_file_struct\n\n {\n\n  int struct_index;\n\n  char *filename;\n\n  int initialized_flag;\n\n  int padding1;\n\n  char *file_path;\n\n  int file_marker[2];\n\n  int chunk_count;\n\n  int chaining_mode_flag;\n\n  DWORD large_file_flag;\n\n  HANDLE AES_provider_handle;\n\n  HANDLE bcrypt_RNG_provider;\n\n  HANDLE RSA_pub_key_handle;\n\n  HANDLE file_handle;\n\n  LARGE_INTEGER file_size;\n\n  DWORD file_data_buffer;\n\n  DWORD padding2;\n\n };\n\n\n```\n**Field** **Description**\n\n**struct_index** Index of the structure in the global structure list\n\n**filename** The name of the file being processed\n\n**initialized_flag** Set to 1 when the structure is populated with a file to encrypt\n\n**file_path** Path of the file being processed\n\n**file_marker** Address of constants to write to file footer marking that it’s been encrypted\n\n**chunk_count** Number of chunks to encrypt in the file\n\n**chaining_mode_flag** Set to 1 to use chaining mode GCM, 0 to use chaining mode CBC\n\n**large_file_flag** Set to 1 when the processed file is large\n\n\n-----\n\n**Field** **Description**\n\n**AES_provider_handle** AES algorithm provider handle\n\n**bcrypt_RNG_provider** RNG algorithm provider handle\n\n**RSA_pub_key_handle** RSA public key handle\n\n**file_handle** File handle\n\n**file_size** File size\n\n**file_data_buffer** Address to virtual buffer to read file data in\n\n**PLAY iterates through this global structure list and populates each structure’s field. First, it sets the encrypted**\nfile markers in the struct to the following hard-coded values, which will later be written to the end of each\nencrypted file.\n\n_Figure 15: Encrypted File Markers._\n\n\n-----\n\nThen, the malware sets the RNG and AES provider handles as well as the RSA public key handle to the\nstructure. These will later be used to generate random AES key and IV to encrypt files.\n\n_Figure 16: Encrypted File Markers._\n\n### Check Existing Drives\n\nBefore iterating through all drives to encrypt, PLAY enumerates all volumes on the victim’s system by calling\n**FindFirstVolumeW and FindNextVolumeW. If the volume is not a CD-ROM drive or a RAM disk, the malware**\ncalls GetVolumePathNamesForVolumeNameW to retrieve a list of drive letters and mounted folder paths for\nthe specified volume.\n\nIf this list is empty, which means the volume is not mounted to any folder, PLAY calls GetDiskFreeSpaceExW\nto check if the volume’s free space is greater than 0x40000000 bytes. If it is, the malware calls\n**SetVolumeMountPointW to try mounting the volume to a drive path.**\n\n\n-----\n\n_Figure 17: Enumerating Volumes._\n\nFor each volume to be mounted, PLAY iterates through all characters to find a drive name that it can call\n**SetVolumeMountPointW to mount the volume to.**\n\n\n-----\n\n_Figure 18: Setting Mount Point for Volume._\n\nUsing the same trick to iterates through all possible drive names, PLAY calls GetDriveTypeW to check the\ntype of each drive.\n\nIt avoids encrypting CD-ROM drive or RAM disk. If it’s a remote drive, the malware calls\n**WNetGetUniversalNameW to retrieve the universal name of the network drive.**\n\n\n-----\n\n_Figure 19: Processing Network Drive._\n\nThe final drive path to be encrypted is set to the network drive’s universal name or connection name,\ndepending on which exists.\n\n_Figure 20: Retrieving Network Drive Name._\n\nIf the drive is a regular drive, its name remains the same. Each valid drive has its name added to the list of\ndrive names to be traversed and encrypted.\n\n### Recursive Traversal\n\nTo begin traversing drives, PLAY iterates through the list of drive names above and spawns a thread with\n**CreateThread to traverse each drive on the system.**\n\n\n-----\n\n_Figure 21: Spawning Threads to Traverse Drives._\n\nBefore processing a drive, the malware extracts the following ransom note content before dropping it into the\ndrive folder. This is the only place where the ransom note is dropped instead of in every folder like other\nransomware.\n```\nPLAY\n\nteilightomemaucd@gmx.com\n\n```\n\n-----\n\n_Figure 22, 23: Dropping Ransom Note in Drive._\n\nTo begin enumerating, the malware calls FindFirstFileW and FindNextFileW to enumerate subfolders and\nfiles. It specifically checks to avoid processing the current and parent directory paths ”.” and ”..”.\n\n\n-----\n\n_Figure 24: Enumerating Files._\n\nIf the file encountered is a directory, the malware checks to avoid encrypting the “Windows” directory. After\nthat, it concatenates the subdirectory’s name to the current file find path and recursively traverse through the\nsubdirectory by calling the traversal function on it.\n\n\n-----\n\n_Figure 25: Recursively Traverse Subdirectory._\n\nIf the file encountered is a regular file, the malware checks its name as well as its size to see if it’s valid for\nbeing encrypted.\n\n_Figure 26: Checking Files._\n\nIf its name/extension is in the list below or if its size is less than 6, PLAY avoids encrypting it.\n\n\n-----\n\n```\n ,,, y,, g,,,\n\n```\n_Figure 27: Checking Filename & Extension._\n\n**PLAY also performs an additional check to see if the file extension is that of typical large files to determine its**\nencryption type later. The file is classified as large if its extension is in the list below.\n```\nmdf, ndf, ldf, frm\n\n\n### Populating File Structure\n\n```\nFor each file to be encrypted, PLAY first populates the file structure with the appropriate data about the file.\n\n\n-----\n\nFirst, it starts iterating through the global file structure list to check if there is an available structure to process\nthe file.\n\n_Figure 28: Checking for Available File Structure._\n\nIf there is no available structure in the global list, PLAY calls Sleep to have the thread sleep and rechecks until\nit finds one.\n\nOnce the structure is found, the malware sets its initialized_flag field to 1 and the filename field to the target\nfilename. It also populates other fields such as the file size, large file flag, and file handle.\n\n\n-----\n\n_Figure 29, 30: Populating A File Structure To Encrypt File._\n\n### Child Thread Encryption\n\nAfter populating a file structure for a specific file, PLAY spawns a thread to begin encrypting a file.\n\nIf the file is not classified as a large file, the malware calculates how many chunks it needs to encrypt\ndepending on the file size. The number of encrypted chunks is 2 if the file size is less than or equal to 0x3fffffff\nbytes, 3 if the file size is less than or equal to 0x27fffffff bytes and greater than 0x3fffffff bytes, and 0 if the file\nsize is equal to 0x280000000. If the file size is greater than 0x280000000 bytes, then the number of encrypted\nchunks is 5.\n\n\n-----\n\n_Figure 32: Calculating Encrypted Chunks._\n\nThe default chaining mode is set to AES-GCM. However, if the file size is greater than 4025 times the\nencrypted size (which is the chunk size 0x100000 multiplied by the chunk count), the chaining mode is set to\nAES-CBC.\n\n[This is because AES-GCM has worst performance compared to AES-CBC. According to this post, AES-GCM](https://helpdesk.privateinternetaccess.com/kb/articles/what-s-the-difference-between-aes-cbc-and-aes-gcm#:~:text=AES%2DGCM%20is%20a%20more,mathematics%20involved%20requiring%20serial%20encryption.)\nis a more secure cipher than AES-CBC, because AES-CBC, operates by XOR’ing (eXclusive OR) each block\nwith the previous block and cannot be written in parallel. This affects performance due to the complex\n\n\n-----\n\nmathematics involved requiring serial encryption.\n\nFor file encryption, PLAY now introduces a new structure that represents the file footer content that gets written\nat each encrypted file.\n\nIt took me an eternity to fully understand and resolve this structure’s fields, which reminds me I’m probably just\nwashed up at malware analysis now rip.\n```\nstruct file_footer_struct\n\n{\n\n byte footer_marker_head[16];\n\n WORD last_chunk_size;\n\n WORD total_chunk_count;\n\n WORD large_file_flag;\n\n WORD small_file_flag;\n\n DWORD default_chunk_size;\n\n DWORD footer_marker_tail;\n\n QWORD encrypted_chunk_count;\n byte encrypted_symmetric_key[1024];\n\n};\n\n```\n**Field** **Description**\n\n**footer_marker_head** First index in the file_marker of file struct\n\n**last_chunk_size** Size of the last chunk at the end of the file\n\n**total_chunk_count** Total number of chunks to be encrypted\n\n**large_file_flag** Set to 1 if file is larger than 0x500000\n\n**small_file_flag** Set to 1 when file size high is less than 0\n\n**chunk_count** Number of chunks to encrypt in the file\n\n**default_chunk_size** 0x100000 bytes\n\n**footer_marker_tail** xxHash32 hash of footer_marker_head. Also the second index in the\n**file_marker of file struct**\n\n**encrypted_chunk_count** Total number of chunks successfully encrypted\n\n**encrypted_symmetric_key** encrypted AES key BLOB\n\nFirst, PLAY reads 0x428 bytes at the end of the file to check the file footer. If the file size is smaller than 0x428\nbytes, the file is guaranteed to not be encrypted, so the malware moves to encrypt it immediately.\n\nIf the last 0x428 bytes is read successfully, the malware then checks if the xxHash32 hash of the footer marker\nhead is equal to the footer marker tail. If they are, then the file footer is confirmed to be valid, and the file is\nalready encrypted.\n\nIf this is not the case, PLAY checks each DWORD in the footer marker head and compare it to the hard-coded\nvalues in the file structure. This is to check if the file footer is not encrypted, if the file footer is written but it has\nnot been encrypted, or if the file is already encrypted.\n\n\n-----\n\n_Figure 33, 34: Checking File Footer for Encryption State._\n\n### File Encryption\n\nTo encrypt a file from scratch, PLAY first generates an AES key to encrypt the file with.\n\n\n-----\n\nIt calls BCryptGenRandom to generate a random 0x20 byte buffer. Depending on the chaining mode specified\nin the file structure, the malware calls BCryptSetProperty to set the chaining properly for its AES provider\nhandle.\n\nNext, BCryptGenerateSymmetricKey is called on the randomly generated 0x20-byte buffer to generate the\nAES key handle.\n\n_Figure 35, 36, 37: Generating AES Key Handle._\n\nNext, to store the AES key in the file footer struct, PLAY calls BCryptExportKey to export the AES key into a\n0x230-byte key blob. It also calls BCryptGenRandom to randomly generate a 0x10-byte IV and appends it\nafter the key blob.\n\n\n-----\n\n_Figure 38, 39: Exporting AES Key Blob & IV._\n\nThen, it calls BCryptEncrypt to encrypt the exported key blob and the IV using the RSA public key handle and\nwrites the encrypted output to into a 0x400-byte buffer. This buffer is then copied to the\n**encrypted_symmetric_key field of the file footer structure.**\n\n_Figure 40: Encrypting AES Key Blob with RSA Public Key._\n\n**PLAY then populates the file footer’s other fields such as footer_marker_head, footer_marker_tail,**\n**small_file_flag, and large_file_flag with existing information from the file structure. The default chunk size is**\nalso set to 0x100000 bytes.\n\n\n-----\n\n_Figure 41: Populating File Footer Structure._\n\nOnce the file footer is fully populated, the malware calls SetFilePointerEx to move the file pointer to the end of\nthe file and calls WriteFile to write the structure there.\n\n\n-----\n\n_Figure 42: Writing File Footer Structure To End Of File._\n\nIf the file size is greater than 0x500000 bytes, PLAY only encrypts the first and last chunk in the file.\n\n\n-----\n\n_Figure 43, 44: Encrypting Large File’s First & Last Chunk._\n\n\n-----\n\nThe encrypting function consists of a ReadFile call to read the chunk data in the buffer in the file structure, a\n**BCryptEncrypt call to encrypt the file using the AES key handle and the generated IV. After encryption is**\nfinished, the malware calls WriteFile to write the encrypted output to the file as well as the index of the chunk\nbeing encrypted in the file footer. This is potentially used to keep track of how many chunks have been\nencrypted in the case where corruption or interruption occurs.\n\n_Figure 45, 46, 47: Data Encrypting Function._\n\nIf the file size is smaller than the default chunk size of 0x100000 bytes, the malware encrypts the entire file.\n\n\n-----\n\n_Figure 48: Encrypting Small File Whole._\n\nIf the file size is somewhere in between 0x100000 and 0x500000, the malware encrypts it in 0x100000-byte\nchunks until it reaches the end of the file.\n\n\n-----\n\n_Figure 49: Encrypting Mid-Size File._\n\nFinally, after the file is encrypted, the malware changes its extension to .PLAY by calling MoveFileW.\n\n_Figure 50: Appending Encrypted Extension._\n\n\n-----\n\nThere is a small bug in the code that it always changes the extension of a file despite if encryption is successful\nor not due to the return value of the file encrypting function.\n\n_Figure 51: Encrypting Mid Size File._\n\n## References\n\nhttps://www.bleepingcomputer.com/news/security/argentinas-judiciary-of-c-rdoba-hit-by-play-ransomwareattack/\n\nhttps://helpdesk.privateinternetaccess.com/kb/articles/what-s-the-difference-between-aes-cbc-and-aesgcm#:~:text=AES%2DGCM%20is%20a%20more,mathematics%20involved%20requiring%20serial%20encryption.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-03 - PLAY Ransomware.pdf"
    ],
    "report_names": [
        "2022-09-03 - PLAY Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536008,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1662984126,
    "ts_modification_date": 1662984126,
    "files": {
        "pdf": "https://archive.orkl.eu/2c6d03212bb5615960c3e76cb2792e523885536a.pdf",
        "text": "https://archive.orkl.eu/2c6d03212bb5615960c3e76cb2792e523885536a.txt",
        "img": "https://archive.orkl.eu/2c6d03212bb5615960c3e76cb2792e523885536a.jpg"
    }
}