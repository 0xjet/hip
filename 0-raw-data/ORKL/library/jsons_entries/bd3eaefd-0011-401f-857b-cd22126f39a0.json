{
    "id": "bd3eaefd-0011-401f-857b-cd22126f39a0",
    "created_at": "2022-10-25T16:48:15.561443Z",
    "updated_at": "2025-03-27T02:05:36.355358Z",
    "deleted_at": null,
    "sha1_hash": "e2ace107f8d2140b86150d76edd08cd1e14cfe56",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-07-26T03:13:54Z",
    "file_modification_date": "2022-07-26T03:13:54Z",
    "file_size": 918403,
    "plain_text": "# CosmicStrand: the discovery of a sophisticated UEFI firmware rootkit\n\n**[securelist.com/cosmicstrand-uefi-firmware-rootkit/106973](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/)**\n\nAuthors\n\nGReAT\n\n## Introduction\n\nRootkits are malware implants which burrow themselves in the deepest corners of the\noperating system. Although on paper they may seem attractive to attackers, creating them\nposes significant technical challenges and the slightest programming error has the\n[potential to completely crash the victim machine. In our APT predictions for 2022, we](https://securelist.com/advanced-threat-predictions-for-2022/104870/)\nnoted that despite these risks, we expected more attackers to reach the sophistication\nlevel required to develop such tools. One of the main draws towards malware nested in\nsuch low levels of the operating system is that it is extremely difficult to detect and, in the\ncase of firmware rootkits, will ensure a computer remains in an infected state even if the\noperating system is reinstalled or the user replaces the machine’s hard drive entirely.\n\nIn this report, we present a UEFI firmware rootkit that we called CosmicStrand and\nattribute to an unknown Chinese-speaking threat actor. One of our industry partners,\n[Qihoo360, published a blog post about an early variant of this malware family in 2017.](https://bbs.360.cn/thread-14959110-1-1.html)\n\n## Affected devices\n\n\n-----\n\nAlthough we were unable to discover how the victim machines were infected initially, an\nanalysis of their hardware sheds light on the devices that CosmicStrand can infect. The\nrootkit is located in the firmware images of Gigabyte or ASUS motherboards, and we\nnoticed that all these images are related to designs using the H81 chipset. This suggests\nthat a common vulnerability may exist that allowed the attackers to inject their rootkit\ninto the firmware’s image.\n\nIn these firmware images, modifications have been introduced into the CSMCORE DXE\ndriver, whose entry point has been patched to redirect to code added in the .reloc section.\nThis code, executed during system startup, triggers a long execution chain which results\nin the download and deployment of a malicious component inside Windows.\n\nLooking at the various firmware images we were able to obtain, we assess that the\nmodifications may have been performed with an automated patcher. If so, it would follow\nthat the attackers had prior access to the victim’s computer in order to extract, modify\nand overwrite the motherboard’s firmware. This could be achieved through a precursor\nmalware implant already deployed on the computer or physical access (i.e., an evil maid\nattack scenario). Qihoo’s initial report indicates that a buyer might have received a\nbackdoored motherboard after placing an order at a second-hand reseller. We were\nunable to confirm this information.\n\n## Overview of the infection process\n\nBefore getting into the various components that compose this rootkit, we would like to\nprovide a high-level view of what it tries to accomplish. The goal of this execution chain is\nto deploy a kernel-level implant into a Windows system every time it boots, starting from\nan infected UEFI component.\n\nUEFI malware authors face a unique technical challenge: their implant starts running so\nearly in the boot process that the operating system (in this case Windows) is not even\nloaded in memory yet – and by the time it is, the UEFI execution context will have\nterminated. Finding a way to pass down malicious code all the way through the various\nstartup phases is the main task that the rootkit accomplishes.\n\nThe workflow consists in setting hooks[1] in succession, allowing the malicious code to\npersist until after the OS has started up. The steps involved are:\n\nThe initial infected firmware bootstraps the whole chain.\nThe malware sets up a malicious hook in the boot manager, allowing it to modify\nWindows’ kernel loader before it is executed.\nBy tampering with the OS loader, the attackers are able to set up another hook in a\nfunction of the Windows kernel.\nWhen that function is later called during the normal start-up procedure of the OS,\nthe malware takes control of the execution flow one last time.\n\n\n-----\n\nIt deploys a shellcode in memory and contacts the C2 server to retrieve the actual\nmalicious payload to run on the victim’s machine.\n\nThese steps are summed up in the following graph:\n\n## UEFI implant – detailed analysis\n\n**MD5** [DDFE44F87FAC7DAEEB1B681DEA3300E9](https://opentip.kaspersky.com/DDFE44F87FAC7DAEEB1B681DEA3300E9/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n\n**SHA1** 9A7291FC90F56D8C46CC78397A6F36BB23C60F66\n\n**SHA256** 951F74882C1873BFE56E0BFF225E3CD5D8964AF4F7334182BC1BF0EC9E987A0A\n\n\n**Link**\n**time**\n\n\nWednesday, 12.08.2015 12:17:57 UTC\n\n\n-----\n\n**File**\n**type**\n\n**File**\n**size**\n\n\nEFI Boot Service DXE Driver\n\n96.84 KB\n\n\n**GUID** A062CF1F-8473-4AA3-8793-600BC4FFE9A8 (CSMCORE)\n\nHaving established what the malware implant tries to accomplish, we can now look into\nmore detail at how each of these steps is performed.\n\n1. The whole execution chain begins with an EFI driver. It appears to be a patched\n\nversion of a legitimate one named CSMCORE (intended to facilitate the boot of the\nmachine in legacy mode via the MBR), where the attackers have modified the\npointer to the HandleProtocol boot service function. Every time this function is\ncalled, the execution is redirected to attacker-supplied code that tries to determine\nwhich component called it (it is looking for a specific one to infect – efi). By\nexamining the function arguments as well as the bytes located at the return address,\nCosmicStrand can identify the exact “call” it is looking for.\n\n2. This specific point in the execution was chosen because at this stage the boot\n\nmanager is loaded in memory, but isn’t yet running. CosmicStrand seizes this\nchance to patch a number of bytes in its Archpx64TransferTo64BitApplicationAsm\n3. That function is later called during the normal OS startup process, also at a strategic\n\ntime: by then the Windows OS loader is also present in memory and can in turn be\nmodified.\n\n\n-----\n\n4. When it runs, Archpx64TransferTo64BitApplicationAsm locates a function from the\n\nOS loader (OslArchTransferToKernel) by looking for a specific byte pattern.\nCosmicStrand then adds a hook at the very end of it.\n\n5. OslArchTransferToKernel is called just before execution is transferred from the\n\nWindows loader to the Windows kernel, which makes it a traditional hooking point\nfor rootkits of that sort.\n\n\n-----\n\n6. Before the Windows kernel has had a chance to run, CosmicStrand sets up yet\n\nanother hook in the ZwCreateSection Malicious code is copied[2] into the image of\nntoskrnl.exe in memory, and the first bytes of ZwCreateSection are overwritten to\nredirect to it. We note that the attackers were careful to place the malicious code\ninside the slack space of ntoskrnl.exe’s .text section, which makes this redirection a\nlot less conspicuous in the eyes of possible security products.\n\n\n[At this point, CosmicStrand also seemingly attempts to disable PatchGuard, a](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)\nsecurity mechanism introduced to prevent modifications in key structures of the\nWindows kernel in memory. To do so, it locates ntoskrnl.exe’s KiFilterFiberContext\nfunction[3] and modifies it so it returns without performing any work. It is worth\nnoting that the localization of this function, also achieved by searching for\nhardcoded patterns, is very exhaustive and even contains patterns corresponding to\n[the Redstone 1 release from August 2016.](https://en.wikipedia.org/wiki/Windows_10_version_1607)\n\n7. The Windows kernel then starts, and ends up calling the hooked ZwCreateSection\n\nfunction while running normally. When that happens, CosmicStrand gains control\nof the execution again, and restores the original code before running more malicious\ncode.\n\n\n-----\n\n8. The ZwCreateSection hook’s primary purpose is to collect the addresses of API\n\nfunctions provided by the kernel, and create a sort of import table for the next\ncomponent. Using the resolved functions, it also allocates a buffer in the kernel’s\naddress space where it maps a shellcode, before calling it.\n\n## Kernel shellcode\n\nAll the steps described so far only served the purpose of propagating code execution from\nthe UEFI down to the Windows kernel. This shellcode is the first actually malicious\n[component of the chain so far. It sets up a thread notify routine that gets invoked each](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine)\ntime a new thread is created. CosmicStrand waits until one turns up in winlogon.exe, and\nthen executes a callback in this high-privilege context.\n\nThere, CosmicStrand sleeps for 10 minutes and tests the internet connectivity of the\ninfected machine. CosmicStrand doesn’t rely on high-level API functions to generate\n[network traffic, but instead interacts directly with the Transport Device Interface: it](https://www.codeproject.com/Articles/9974/Driver-Development-Part-5-Introduction-to-the-Tran)\ngenerates the needed IRPs (I/O request packets) and passes them to the network stack by\nsending IOCTLs to the TCP or UDP device object. DNS requests are performed in this\nfashion, using either Google’s DNS server (8.8.8[.]8) or a custom one (222.222.67[.]208).\n\nCosmicStrand retrieves its final payload by sending a specifically crafted UDP (preferably)\nor TCP packet to its C2 server, update.bokts[.]com. The reply is expected to return in one\nor several packets containing chunks of 528 bytes following this structure:\n\n**Offset (bytes)** **Description**\n\n0-4 Magic number\n\n4-8 Total length of the payload\n\n8-12 Length of the current chunk\n\n12-16 CRC32 checksum of the current chunk\n\n16-* Payload chunk\n\nThe various chunks are reassembled into a series of bytes that are mapped into kernel\nspace and interpreted as a shellcode. Unfortunately, we were not able to obtain a copy of\ndata coming from the C2 server. We did, however, find a user-mode sample in-memory\non one of the infected machines we could study, and believe it is linked with\nCosmicStrand. This sample is an executable that runs command lines in order to create a\nuser (“aaaabbbb”) on the victim’s machine and add it to the local administrators group.\n\n\n-----\n\nWe can infer from this that shellcodes received from the C2 server might be stagers for\nattacker-supplied PE executables, and it is very likely that many more exist.\n\n## Older CosmicStrand variants\n\nDuring the course of our investigation, we also discovered older versions of this rootkit.\nThey feature the same deployment process and their minute differences pertain to the\nkernel shellcode.\n\nIt attempts to hijack a thread from exe instead of winlogon.exe.\nThe C2 domain contacted to obtain additional shellcode in order to run is different\n(erda158[.]to).\nThe older variant printed debugging messages every time a new process was created\nin the system.\n\nBased on our analysis of the infrastructure used for the two variants, we estimate that the\nolder one saw use between the end of 2016 and mid-2017, and the current one was active\nin 2020.\n\n## Infrastructure\n\nWe are aware of two C2 servers, one for each variant. According to passive DNS data\navailable for them, these domains had a long lifetime and resolved to IP addresses during\nlimited timeframes – outside of which the rootkit would have been inoperative. It is\ntherefore interesting to note that while the attackers opted to deploy an extremely\npersistent implant, the actual exploitation of the victim machines may not have lasted\nmore than a few months. It is, however, possible that these domains were occasionally\nreactivated for very short durations, and that this information would not have been\nrecorded by passive DNS systems.\n\n\n**Domain** **IP** **First**\n**seen**\n\nwww.erda158[.]top 58.84.53[.]194 2016-1227\n\n115.239.210[.]27 2017-0430\n\nupdate.bokts[.]com 23.82.12[.]30 2020-0503\n\n23.82.12[.]31 2020-0725\n\n\n**Last**\n**seen**\n\n2017-0426\n\n2017-0624\n\n2020-0503\n\n2020-0725\n\n\n**ASN**\n\nAS48024\n(NEROCLOUD)\n\nAS58461 (CHINANET)\n\nAS30633 (Leaseweb\nUSA)\n\nAS30633 (Leaseweb\nUSA)\n\n\n-----\n\n23.82.12[.]32 2020-0309\n\n\n2020-0725\n\n\nAS30633 (Leaseweb\nUSA)\n\n\nCareful readers will notice the three-year gap between the activity periods of the two\ndomains. It is possible that during that time, the attackers were controlling the victim’s\nmachines using user-mode components deployed through CosmicStrand, or (more likely)\nthat other variants and C2 servers that we did not yet discover exist somewhere.\n\n## Victims\n\nWe were able to identify victims of CosmicStrand in China, Vietnam, Iran and Russia. A\npoint of interest is that all the victims in our user base appear to be private individuals\n(i.e., using the free version of our product) and we were unable to tie them to any\norganization or even industry vertical.\n\n## Attribution\n\nSeveral data points lead us to believe that CosmicStrand was developed by a Chinesespeaking threat actor, or by leveraging common resources shared among Chinesespeaking threat actors. Specifically, a number of code patterns featured in CosmicStrand\nwere also observed in another malware family, the MyKings botnet (e.g., MD5\n[E31C43DD8CB17E9D68C65E645FB3F6E8). This botnet, used to deploy cryptominers,](https://opentip.kaspersky.com/E31C43DD8CB17E9D68C65E645FB3F6E8/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[was documented by Sophos in 2020 where they noted the presence of several Chinese-](https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/sophoslabs-uncut-mykings-report.pdf)\nlanguage artifacts.\n\nSimilarities with CosmicStrand include:\n\nThe use of an MBR rootkit to establish stealthy persistence in MyKings.\n\n\n-----\n\nCosmicStrand and MyKings use identical tags when they allocate memory in kernel\nmode (Proc and GetM).\nBoth families generate network packets the same way, and leverage the UDP and\nTCP device objects directly.\nThe API hashing code used in the two of them is identical, as evidenced by the\nscreenshot below. As far as we know, this algorithm was only ever found in two\n[other rootkits, MoonBounce and xTalker – also tied to Chinese-speaking threat](https://securelist.com/moonbounce-the-dark-side-of-uefi-firmware/105468/)\nactors.\n\n\n-----\n\nIn addition to this code similarity, the fact that the hardcoded fallback DNS server used\nby CosmicStrand is located in CHINANET-BACKBONE (AS4134) could be perceived as a\nvery low-confidence sign that the attackers are part of the Chinese-speaking nexus.\nBeyond this tie, we have decided that we do not have sufficient information that would\nallow us to link CosmicStrand to an existing cluster.\n\n\n-----\n\n## Conclusions\n\nCosmicStrand is a sophisticated UEFI firmware rootkit that allows its owners to achieve\nvery durable persistence: the whole lifetime of the computer, while at the same time being\nextremely stealthy. It appears to have been used in operation for several years, and yet\nmany mysteries remain. How many more implants and C2 servers could still be eluding\nus? What last-stage payloads are being delivered to the victims? But also, is it really\npossible that CosmicStrand has reached some of its victims through package\n“interdiction”? In any case, the multiple rootkits discovered so far evidence a blind spot in\nour industry that needs to be addressed sooner rather than later.\n\nThe most striking aspect of this report is that this UEFI implant seems to have been used\nin the wild since the end of 2016 – long before UEFI attacks started being publicly\ndescribed. This discovery begs a final question: if this is what the attackers were using\nback then, what are they using today?\n\n**_The GReAT team would like to extend its special thanks to their former_**\n**_colleague, Mark Lechtik, for his key involvement in this research._**\n\n[1] A hook is a modification to the normal flow of execution of a program. It aims to\n\nexecute additional code provided by the attacker before or after a given function. In some\nenvironments, function hooking is provided for legitimate purposes and can be set up\neasily through conventional programming mechanisms. In other cases, where they are\nnot explicitly supported, attackers can still achieve hooking by overwriting (and later on,\nrestoring) the code that is about to be executed. Both cases are leveraged by this rootkit.\n\n\n\n[2] Here we skip the implementation details and shellcode tricks used by the rootkit in\n\norder to obtain the address of the malicious code. The precise workflow of this part is left\nas an exercise to the reader, and documented extensively in our private report on this\nactivity.\n\n[[3] More information about this function is available in research from other vendors.](https://blog.tetrane.com/downloads/Tetrane_PatchGuard_Analysis_RS4_v1.01.pdf)\n\nCosmicStrand: the discovery of a sophisticated UEFI firmware rootkit\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2022/2022.07.25.CosmicStrand/CosmicStrand_%20the%20discovery%20of%20a%20sophisticated%20UEFI%20firmware%20rootkit%20_%20Securelist.pdf"
    ],
    "report_names": [
        "CosmicStrand_ the discovery of a sophisticated UEFI firmware rootkit _ Securelist"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1658805234,
    "ts_modification_date": 1658805234,
    "files": {
        "pdf": "https://archive.orkl.eu/e2ace107f8d2140b86150d76edd08cd1e14cfe56.pdf",
        "text": "https://archive.orkl.eu/e2ace107f8d2140b86150d76edd08cd1e14cfe56.txt",
        "img": "https://archive.orkl.eu/e2ace107f8d2140b86150d76edd08cd1e14cfe56.jpg"
    }
}