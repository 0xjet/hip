{
    "id": "346d0501-8baa-4aff-98f7-b6887463faae",
    "created_at": "2023-01-12T15:08:19.557596Z",
    "updated_at": "2025-03-27T02:06:02.421804Z",
    "deleted_at": null,
    "sha1_hash": "ee9fc59843af3af3a277a4a3bcbced5e2e817672",
    "title": "2017-07-18 - Ten process injection techniques- A technical survey of common and trending process injection techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T02:45:05Z",
    "file_modification_date": "2022-05-28T02:45:05Z",
    "file_size": 1824687,
    "plain_text": "# Ten process injection techniques: A technical survey of common and trending process injection techniques\n\n**[endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)**\n\nJuly 18, 2017\n\n[18 July 2017Tech Topics](https://www.endgame.com/blog/category/technical-topics)\n\nBy\n[Ashkan Hosseini](https://www.endgame.com/blog/author/ashkan-hosseini)\nShare\n\n**Editor’s Note: Elastic** [joined forces with Endgame in October 2019, and has migrated](https://www.elastic.co/blog/introducing-elastic-endpoint-security)\n[some of the Endgame blog content to elastic.co. See Elastic Security to learn more about](https://www.elastic.co/security)\nour integrated security solutions.\n\nProcess injection is a widespread defense evasion technique employed often within\nmalware and fileless adversary tradecraft, and entails running custom code within the\naddress space of another process. Process injection improves stealth, and some\ntechniques also achieve persistence. Although there are numerous process injection\ntechniques, in this blog I present ten techniques seen in the wild that run malware code on\nbehalf of another process. I additionally provide screenshots for many of these techniques\nto facilitate reverse engineering and malware analysis, assisting detection and defense\nagainst these common techniques\n\n\n-----\n\n## 1. CLASSIC DLL INJECTION VIA CREATEREMOTETHREAD AND LOADLIBRARY\n\nThis technique is one of the most common techniques used to inject malware into another\nprocess. The malware writes the path to its malicious dynamic-link library (DLL) in the\nvirtual address space of another process, and ensures the remote process loads it by\ncreating a remote thread in the target process.\n\nThe malware first needs to target a process for injection (e.g. svchost.exe). This is usually\ndone by searching through processes by calling a trio of Application Program Interfaces\n(APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next.\nCreateToolhelp32Snapshot is an API used for enumerating heap or module states of a\nspecified process or all processes and it returns a snapshot Process32First retrieves\n\n\n-----\n\ninformation about the first process in the snapshot, and then Process32Next is used in a\nloop to iterate through them. After finding the target process, the malware gets the handle of\nthe target process by calling OpenProcess.\n\nAs shown in Figure 1, the malware calls VirtualAllocEx to have a space to write the path to\nits DLL. The malware then calls WriteProcessMemory to write the path in the allocated\nmemory. Finally, to have the code executed in another process, the malware calls APIs\nsuch as CreateRemoteThread, NtCreateThreadEx, or RtlCreateUserThread. The latter two\nare undocumented. However, the general idea is to pass the address of LoadLibrary to one\nof these APIs so that a remote process has to execute the DLL on behalf of the malware.\n\nCreateRemoteThread is tracked and flagged by many security products. Further, it requires\na malicious DLL on disk which could be detected. Considering that attackers are most\ncommonly injecting code to evade defenses, sophisticated attackers probably will not use\nthis approach. The screenshot below displays a malware named Rebhip performing this\ntechnique.\n\n\n-----\n\n-----\n\n**Figure 1: Rebhip worm performing a typical DLL injection**\n**Sha256: 07b8f25e7b536f5b6f686c12d04edc37e11347c8acd5c53f98a174723078c365**\n\n## 2. PORTABLE EXECUTABLE INJECTION (PE INJECTION)\n\nInstead of passing the address of the LoadLibrary, malware can copy its malicious code into\nan existing open process and cause it to execute (either via a small shellcode, or by calling\nCreateRemoteThread). One advantage of PE injection over the LoadLibrary technique is\nthat the malware does not have to drop a malicious DLL on the disk. Similar to the first\ntechnique, the malware allocates memory in a host process (e.g. VirtualAllocEx), and\ninstead of writing a “DLL path” it writes its malicious code by calling WriteProcessMemory.\nHowever, the obstacle with this approach is the change of the base address of the copied\nimage. When a malware injects its PE into another process it will have a new base address\nwhich is unpredictable, requiring it to dynamically recompute the fixed addresses of its PE.\nTo overcome this, the malware needs to find its relocation table address in the host\nprocess, and resolve the absolute addresses of the copied image by looping through its\nrelocation descriptors.\n\nThis technique is similar to other techniques, such as reflective DLL injection and memory\nmodule, since they do not drop any files to the disk. However, memory module and\nreflective DLL injection approaches are even stealthier. They do not rely on any extra\nWindows APIs (e.g., CreateRemoteThread or LoadLibrary), because they load and execute\nthemselves in the memory. Reflective DLL injection works by creating a DLL that maps itself\ninto memory when executed, instead of relying on the Window’s loader. Memory Module is\n\n\n-----\n\nsimilar to Reflective DLL injection except the injector or loader is responsible for mapping\n[the target DLL into memory instead of the DLL mapping itself. In a previous blog post, these](https://www.endgame.com/blog/technical-blog/hunting-memory)\ntwo in memory approaches were discussed extensively.\n\nWhen analyzing PE injection, it is very common to see loops (usually two “for” loops, one\nnested in the other), before a call to CreateRemoteThread. This technique is quite popular\namong crypters (softwares that encrypt and obfuscate malware). In Figure 2, the sample\nunit test is taking advantage of this technique. The code has two nested loops to adjust its\nrelocation table that can be seen before the calls to WriteProcessMemory and\nCreateRemoteThread. The “and 0x0fff” instruction is also another good indicator, showing\nthat the first 12 bits are used to get the offset into the virtual address of the containing\nrelocation block. Now that the malware has recomputed all the necessary addresses, all it\nneeds to do is pass its starting address to CreateRemoteThread and have it executed.\n\n\n-----\n\n**Figure 2: Example structure of the loops for PE injection prior to calls to**\nCreateRemoteThread\n\n\n-----\n\n**Sha256: ce8d7590182db2e51372a4a04d6a0927a65b2640739f9ec01cfd6c143b1110da**\n\n## 3. PROCESS HOLLOWING (A.K.A PROCESS REPLACEMENT AND RUNPE)\n\nInstead of injecting code into a host program (e.g., DLL injection), malware can perform a\ntechnique known as process hollowing. Process hollowing occurs when a malware unmaps\n(hollows out) the legitimate code from memory of the target process, and overwrites the\nmemory space of the target process (e.g., svchost.exe) with a malicious executable.\n\nThe malware first creates a new process to host the malicious code in suspended mode. As\nshown in Figure 3, this is done by calling CreateProcess and setting the Process Creation\nFlag to CREATE_SUSPENDED (0x00000004). The primary thread of the new process is\ncreated in a suspended state, and does not run until the ResumeThread function is called.\nNext, the malware needs to swap out the contents of the legitimate file with its malicious\npayload. This is done by unmapping the memory of the target process by calling either\nZwUnmapViewOfSection or NtUnmapViewOfSection. These two APIs basically release all\nmemory pointed to by a section. Now that the memory is unmapped, the loader performs\nVirtualAllocEx to allocate new memory for the malware, and uses WriteProcessMemory to\nwrite each of the malware’s sections to the target process space. The malware calls\n\n\n-----\n\nSetThreadContext to point the entrypoint to a new code section that it has written. At the\nend, the malware resumes the suspended thread by calling ResumeThread to take the\nprocess out of suspended state.\n\n\n-----\n\n**Figure 3: Ransom.Cryak performing process hollowing**\n**Sha256: eae72d803bf67df22526f50fc7ab84d838efb2865c27aef1a61592b1c520d144**\n\n## 4. THREAD EXECUTION HIJACKING (A.K.A SUSPEND, INJECT, AND RESUME (SIR))\n\nThis technique has some similarities to the process hollowing technique previously\ndiscussed. In thread execution hijacking, malware targets an existing thread of a process\nand avoids any noisy process or thread creations operations. Therefore, during analysis\nyou will probably see calls to CreateToolhelp32Snapshot and Thread32First followed by\nOpenThread.\n\nAfter getting a handle to the target thread, the malware puts the thread into suspended\nmode by calling SuspendThread to perform its injection. The malware calls VirtualAllocEx\nand WriteProcessMemory to allocate memory and perform the code injection. The code can\ncontain shellcode, the path to the malicious DLL, and the address of LoadLibrary.\n\nFigure 4 illustrates a generic trojan using this technique. In order to hijack the execution of\nthe thread, the malware modifies the EIP register (a register that contains the address of\nthe next instruction) of the targeted thread by calling SetThreadContext. Afterwards,\nmalware resumes the thread to execute the shellcode that it has written to the host process.\nFrom the attacker’s perspective, the SIR approach can be problematic because suspending\nand resuming a thread in the middle of a system call can cause the system to crash. To\navoid this, a more sophisticated malware would resume and retry later if the EIP register is\nwithin the range of NTDLL.dll.\n\n\n-----\n\n**Figure 4: A generic trojan is performing thread execution hijacking**\n**Sha256: 787cbc8a6d1bc58ea169e51e1ad029a637f22560660cc129ab8a099a745bd50e**\n\n## 5. HOOK INJECTION VIA SETWINDOWSHOOKEX\n\n\n-----\n\nHooking is a technique used to intercept function calls. Malware can leverage hooking\nfunctionality to have their malicious DLL loaded upon an event getting triggered in a specific\nthread. This is usually done by calling SetWindowsHookEx to install a hook routine into the\nhook chain. The SetWindowsHookEx function takes four arguments. The first argument is\nthe type of event. The events reflect the [range of hook types, and vary from pressing keys](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644959(v=vs.85).aspx)\non the keyboard (WH_KEYBOARD) to inputs to the mouse (WH_MOUSE), CBT, etc. The\nsecond argument is a pointer to the function the malware wants to invoke upon the event\nexecution.The third argument is a module that contains the function. Thus, it is very\ncommon to see calls to LoadLibrary and GetProcAddress before calling\nSetWindowsHookEx. The last argument to this function is the thread with which the hook\nprocedure is to be associated. If this value is set to zero all threads perform the action when\nthe event is triggered. However, malware usually targets one thread for less noise, thus it is\nalso possible to see calls CreateToolhelp32Snapshot and Thread32Next before\nSetWindowsHookEx to find and target a single thread. Once the DLL is injected, the\nmalware executes its malicious code on behalf of the process that its threadId was passed\nto SetWindowsHookEx function. In Figure 5, Locky Ransomware implements this\ntechnique.\n\n\n-----\n\n**Figure 5: Locky Ransomware using hook injection**\n\n**Sha256: 5d6ddb8458ee5ab99f3e7d9a21490ff4e5bc9808e18b9e20b6dc2c5b27927ba1**\n\n## 6. INJECTION AND PERSISTENCE VIA REGISTRY MODIFICATION (E.G. APPINIT_DLLS, APPCERTDLLS, IFEO)\n\n\n-----\n\nAppinit_DLL, AppCertDlls, and IFEO (Image File Execution Options) are all registry keys\nthat malware uses for both injection and persistence. The entries are located at the\nfollowing locations:\n\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Appinit_Dlls\nHKLM\\Software\\Wow6432Node\\Microsoft\\Windows\nNT\\CurrentVersion\\Windows\\Appinit_Dlls HKLM\\System\\CurrentControlSet\\Control\\Session\nManager\\AppCertDlls HKLM\\Software\\Microsoft\\Windows NT\\currentversion\\image file\nexecution options\n\n### AppInit_DLLs\n\nMalware can insert the location of their malicious library under the Appinit_Dlls registry key\nto have another process load their library. Every library under this registry key is loaded into\nevery process that loads User32.dll. User32.dll is a very common library used for storing\ngraphical elements such as dialog boxes. Thus, when a malware modifies this subkey, the\nmajority of processes will load the malicious library. Figure 6 demonstrates the trojan Ginwui\nrelying on this approach for injection and persistence. It simply opens the Appinit_Dlls\nregistry key by calling RegCreateKeyEx, and modifies its values by calling RegSetValueEx.\n\n\n-----\n\n**Figure 6: Ginwui modifying the AppIniti_DLLs registry key**\n\n**Sha256: 9f10ec2786a10971eddc919a5e87a927c652e1655ddbbae72d376856d30fa27c**\n\n### AppCertDlls\n\nThis approach is very similar to the AppInit_DLLs approach, except that DLLs under this\nregistry key are loaded into every process that calls the Win32 API functions\nCreateProcess, CreateProcessAsUser, CreateProcessWithLogonW,\nCreateProcessWithTokenW, and WinExec.\n\n### Image File Execution Options (IFEO)\n\n\n-----\n\nIFEO is typically used for debugging purposes. Developers can set the Debugger Value\nunder this registry key to attach a program to another executable for debugging. Therefore,\nwhenever the executable is launched the program that is attached to it will be launched. To\nuse this feature you can simply give the path to the debugger, and attach it to the\nexecutable that you want to analyze. Malware can modify this registry key to inject itself into\nthe target executable. In Figure 7, Diztakun trojan implements this technique by modifying\nthe debugger value of Task Manager.\n\n**Figure 7: Diztakun trojan modifying IFEO registry key**\n\n**Sha256: f0089056fc6a314713077273c5910f878813fa750f801dfca4ae7e9d7578a148**\n\n## 7. APC INJECTION AND ATOMBOMBING\n\n[Malware can take advantage of Asynchronous Procedure Calls (APC) to force another](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx)\nthread to execute their custom code by attaching it to the APC Queue of the target thread.\nEach thread has a queue of APCs which are waiting for execution upon the target thread\nentering alterable state. A thread enters an alertable state if it calls SleepEx,\nSignalObjectAndWait, MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx, or\nWaitForSingleObjectEx functions. The malware usually looks for any thread that is in an\n\n\n-----\n\nalterable state, and then calls OpenThread and QueueUserAPC to queue an APC to a\nthread. QueueUserAPC takes three arguments: 1) a handle to the target thread; 2) a\npointer to the function that the malware wants to run; 3) and the parameter that is passed to\nthe function pointer. In Figure 8, Amanahe malware first calls OpenThread to acquire a\nhandle of another thread, and then calls QueueUserAPC with LoadLibraryA as the function\npointer to inject its malicious DLL into another thread.\n\n[AtomBombing is a technique that was first introduced by enSilo research, and then used in](http://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current-security-solutions)\n[Dridex V4. As we discussed in detail in a previous post, the technique also relies on APC](https://www.endgame.com/blog/technical-blog/dropping-atombombs-detecting-dridexv4-wild)\ninjection. However, it uses atom tables for writing into memory of another process.\n\n**Figure 8: Almanahe performing APC injection**\n**Sha256: f74399cc0be275376dad23151e3d0c2e2a1c966e6db6a695a05ec1a30551c0ad**\n\n## 8. EXTRA WINDOW MEMORY INJECTION (EWMI) VIA SETWINDOWLONG\n\nEWMI relies on injecting into Explorer tray window’s extra window memory, and has been\nused a few times among malware families such as Gapz and PowerLoader. When\nregistering a window class, an application can specify a number of additional bytes of\n\n\n-----\n\nmemory, called extra window memory (EWM). However, there is not much room in EWM.\nTo circumvent this limitation, the malware writes code into a shared section of explorer.exe,\nand uses SetWindowLong and SendNotifyMessage to have a function pointer to point to the\nshellcode, and then execute it.\n\nThe malware has two options when it comes to writing into a shared section. It can either\ncreate a shared section and have it mapped both to itself and to another process (e.g.,\nexplorer.exe), or it can simply open a shared section that already exists. The former has the\noverhead of allocating heap space and calling NTMapViewOfSection in addition to a few\nother API calls, so the latter approach is used more often. After malware writes its shellcode\nin a shared section, it uses GetWindowLong and SetWindowLong to access and modify the\nextra window memory of “Shell_TrayWnd”. GetWindowLong is an API used to retrieve the\n32-bit value at the specified offset into the extra window memory of a window class object,\nand SetWindowLong is used to change values at the specified offset. By doing this, the\nmalware can simply change the offset of a function pointer in the window class, and point it\nto the shellcode written to the shared section.\n\nLike most other techniques mentioned above, the malware needs to trigger the code that it\nhas written. In previously discussed techniques, malware achieved this by calling APIs such\nas CreateRemoteThread, QueueUserAPC, or SetThreadContext. With this approach, the\nmalware instead triggers the injected code by calling SendNotifyMessage. Upon execution\nof SendNotifyMessage, Shell_TrayWnd receives and transfers control to the address\npointed to by the value previously set by SetWindowLong. In Figure 9, a malware named\n[PowerLoader uses this technique.](https://www.malwaretech.com/2013/08/powerloader-injection-something-truly.html)\n\n\n-----\n\n**Figure 9: PowerLoader injecting into extra window memory of shell tray window**\n**Sha256: 5e56a3c4d4c304ee6278df0b32afb62bd0dd01e2a9894ad007f4cc5f873ab5cf**\n\n## 9. INJECTION USING SHIMS\n\n\n-----\n\n[Microsoft provides Shims to developers mainly for backward compatibility. Shims allow](https://technet.microsoft.com/en-us/library/dd837644(v=ws.10).aspx)\ndevelopers to apply fixes to their programs without the need of rewriting code. By\nleveraging shims, developers can tell the operating system how to handle their application.\nShims are essentially a way of hooking into APIs and targeting specific executables.\nMalware can take advantage of shims to target an executable for both persistence and\ninjection. Windows runs the Shim Engine when it loads a binary to check for shimming\ndatabases in order to apply the appropriate fixes.\n\nThere are many fixes that can be applied, but malware’s favorites are the ones that are\nsomewhat security related (e.g., DisableNX, DisableSEH, InjectDLL, etc). To install a\n[shimming database, malware can deploy various approaches. For example, one common](https://www.blackhat.com/docs/eu-15/materials/eu-15-Pierce-Defending-Against-Malicious-Application-Compatibility-Shims-wp.pdf)\napproach is to simply execute sdbinst.exe, and point it to the malicious sdb file. In Figure\n10, an adware, “Search Protect by Conduit”, uses a shim for persistence and injection. It\nperforms an “InjectDLL” shim into Google Chrome to load vc32loader.dll. There are a few\nexisting tools for analyzing sdb files, but for the analysis of the sdb listed below, I used\n[python-sdb.](https://github.com/williballenthin/python-sdb)\n\n\n-----\n\n**Figure 10: SDB used by Search Protect for injection purposes**\n**Sha256: 6d5048baf2c3bba85adc9ac5ffd96b21c9a27d76003c4aa657157978d7437a20**\n\n## 10. IAT HOOKING AND INLINE HOOKING (A.K.A USERLAND ROOTKITS)\n\nIAT hooking and inline hooking are generally known as userland rootkits. IAT hooking is a\ntechnique that malware uses to change the import address table. When a legitimate\napplication calls an API located in a DLL, the replaced function is executed instead of the\noriginal one. In contrast, with inline hooking, malware modifies the API function itself. In\nFigure 11, the malware FinFisher, performs IAT hooking by modifying where the\nCreateWindowEx points.\n\n\n-----\n\n**Figure 11: FinFisher performing IAT hooking by changing where CreateWindowEx points to**\n\n**Sha256: f827c92fbe832db3f09f47fe0dcaafd89b40c7064ab90833a1f418f2d1e75e8e**\n\n## CONCLUSION\n\nIn this post, I covered ten different techniques that malware uses to hide its activity in\nanother process. In general, malware either directly injects its shellcode into another\nprocess or it forces another process to load its malicious library. In Table 1, I have classified\nthe various techniques and provided samples to serve as a reference for observing each\ninjection technique covered in this post. The figures included throughout the post will help\nthe researcher recognize the various techniques when reversing malware.\n\n\n-----\n\n**Table1: Process injection can be done by directly injecting code into another process, or by**\nforcing a DLL to be loaded into another process\nAttackers and researchers regularly discover new techniques to achieve injection and\nprovide stealth. This post detailed ten common and emerging techniques, but there are\nothers, such as [COM hijacking. Defenders will never be “done” in their mission to detect](https://www.endgame.com/blog/technical-blog/how-hunt-detecting-persistence-evasion-com)\nand prevent stealthy process injection because adversaries will never stop innovating.\n\nAt Endgame, we constantly research advanced stealth techniques and bring protections\ninto our product. We layer capabilities which detect malicious DLLs that load on some\npersistence (like AppInit DLLs, COM Hijacks, and more), prevent many forms of code\ninjection in real-time via our patented shellcode injection protection, and detect malicious\ninjected payloads running in memory delivered through any of the above techniques\nthrough our patent-pending fileless attack detection techniques. This approach allows our\nplatform to be more effective than any other product on the market in protecting against\ncode injection, while also maximizing resiliency against bypass due to emerging code\ninjection techniques.\n\n\n-----\n\n**We re hiring**\n\nWork for a global, distributed team where finding someone like you is just a Zoom\nmeeting away. Flexible work with impact? Development opportunities from the start?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-07-18 - Ten process injection techniques- A technical survey of common and trending process injection techniques.pdf"
    ],
    "report_names": [
        "2017-07-18 - Ten process injection techniques- A technical survey of common and trending process injection techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536099,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1653705905,
    "ts_modification_date": 1653705905,
    "files": {
        "pdf": "https://archive.orkl.eu/ee9fc59843af3af3a277a4a3bcbced5e2e817672.pdf",
        "text": "https://archive.orkl.eu/ee9fc59843af3af3a277a4a3bcbced5e2e817672.txt",
        "img": "https://archive.orkl.eu/ee9fc59843af3af3a277a4a3bcbced5e2e817672.jpg"
    }
}