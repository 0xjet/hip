{
    "id": "b919e9a2-6fdb-4c1d-9bc1-155da37c29f8",
    "created_at": "2023-01-12T15:10:50.519525Z",
    "updated_at": "2025-03-27T02:16:26.285194Z",
    "deleted_at": null,
    "sha1_hash": "a4cdee50fdca59043c343db93a3af02155677e3c",
    "title": "Preventing Ransomware Attacks Through File System Filter Drivers",
    "authors": "",
    "file_creation_date": "2021-02-19T01:43:06Z",
    "file_modification_date": "2017-12-14T12:10:26Z",
    "file_size": 758150,
    "plain_text": "## Preventing Ransomware Attacks Through File System Filter Drivers\n\n#### Giovanni Bottazzi, Giuseppe Italiano, Domenico Spera\n\n To cite this version:\n\n###### Giovanni Bottazzi, Giuseppe Italiano, Domenico Spera. Preventing Ransomware Attacks Through File System Filter Drivers. Second Italian Conference on Cyber Security, 2018, Milan, Italy. ￿hal-01925958￿\n\n#### HAL Id: hal-01925958\n\n https://hal.inria.fr/hal-01925958\n\n###### Submitted on 18 Nov 2018\n\n\n###### HAL is a multi-disciplinary open access archive for the deposit and dissemination of sci- entific research documents, whether they are pub- lished or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers.\n\n\n###### L’archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d’enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.\n\n\n-----\n\nAfter 30 years from the first release, Windows systems continue to maintain desktop market\ndominance with more than 80% of worldwide users as shown in Table 1. Such spreading makes\nWindows operating system the main target of cybercriminals. According to Symantec (Symantec,\nISR, 2016), only in 2015, more than 430 million of unique malware samples have been discovered,\n36% up from the year before and specially a new form of cyber extortion is growing: ransomware\ndetection has recorded 100 new families. Ransomware thread is the final evolution of criminal\nweapons (Savage et al., Symantec WP, 2015), using modern encryption algorithms and untraceable\npayment systems (Nakamoto, bitcoin.org, 2008), enciphering victim's files and demanding a fee to\nrestore usability. At the end of 2015, the average ransom demand has raised to 679$. A recent\nresearch (Osterman Research, 2016) reports that nearly 40% of all organizations surveyed,\nexperienced a ransomware attack in the same year. Even worst more than 600 million of attacks have\nbeen recorded in 2016 (SonicWall Report, 2017), well over 100 times compared to 2015.\n\nDespite these big numbers, home uses still rely to basic computer security solutions, completely\nignoring operating system security as well as third party vulnerabilities. Table 2 shows how they are\n\n\n# Preventing Ransomware Attacks Through\n File System Filter Drivers\n\n##### Giovanni Bottazzi, Giuseppe F. Italiano, Domenico Spera\n\nUniversity of Rome “Tor Vergata”\n```\n               gbottazzi73@gmail.com, giuseppe.italiano@uniroma2.it,\n                        speradomenico@gmail.com\n\n```\n**Abstract**\n\nOver the last years ransomware attacks have been widely spreading over the\nInternet, indiscriminately targeting home users as well as corporates and public\nagencies. Several approaches have been proposed to analyze and detect ransomware\nintrusions in literature, moving from combined heuristics, behavior analysis, sandbox-\nbased solutions and machine learning techniques to function calls monitoring. Our\napproach differs from the above by shifting the focus from removing the problem to\nmitigating damages, to ensure data availability despite malware attacks. The aim is not\nto detect new ransomware samples, but simply to protect integrity and availability of\nprivate data. In other words, we interfere with ransomware usual behavior, intercepting\nI/O request packets and denying operations on user's valuable data.\n\n### 1 Introduction\n\nAfter 30 years from the first release, Windows systems continue to maintain desktop market\ndominance with more than 80% of worldwide users as shown in Table 1. Such spreading makes\nWindows operating system the main target of cybercriminals. According to Symantec (Symantec,\nISR, 2016), only in 2015, more than 430 million of unique malware samples have been discovered,\n36% up from the year before and specially a new form of cyber extortion is growing: ransomware\ndetection has recorded 100 new families. Ransomware thread is the final evolution of criminal\nweapons (Savage et al., Symantec WP, 2015), using modern encryption algorithms and untraceable\npayment systems (Nakamoto, bitcoin.org, 2008), enciphering victim's files and demanding a fee to\nrestore usability. At the end of 2015, the average ransom demand has raised to 679$. A recent\nresearch (Osterman Research, 2016) reports that nearly 40% of all organizations surveyed,\n\n\n-----\n\nnot inclined in changing their habits: Windows XP is still used despite known security concerns and\nupdated versions like Windows 8 and Windows 8.1 have been avoided, probably due to a GUI “new\nlook”.\n\nSource Windows OS X Linux Others\nstatcounter 84.34% 11.68% 1.54% 2.44%\nnetmarketshare 91.59% 6.27% 2.14% 0.00%\n**Table 1. Desktop Operating System Market Share Worldwide. This**\nstatistic shows the operating system market share worldwide on\nDesktop PC during March 2017. It is based on aggregate data\ncollected by statcounter.com and netmarketshare.com.\n\nSource Win 10 Win 8.1 Win 8 Win 7 Win XP Others\nstatcounter 34.25% 9.62% 2.44% 47.06% 5.47% 1.16%\nnetmarketshare 26.53% 6.96% 5.83% 51.70% 7.78% 1.20%\n**Table 2. Desktop Windows Versions Market Share Worldwide.**\n\nMore than that, corporates as well as public agencies focus on security technical aspects, leaving\nout human aspects (Furnell et al, Computer & Security, 2012): while technology is still a necessary\ninvestment, however, training and education must be part of the solution. Too often employees have\nbeen the entry point for a successful attack (Choi et al., IJFP, 2016; Forand, NJ.com, 2015; Green,\nBecker’s Hospital Review, 2016). On the other side the ransomware spread, first appeared in 1980\nwith the AIDS Trojan, has dramatically increased over the last years. They moved from the first\nfamilies of Legacy Crypto Ransomware in 2005 (Gazet, JCV, 2010), lacking on accurate and strong\nencryption system implementation, through Fake Antivirus [Symantec, Report, 2009; Stone-Gross et\nal., Economics of Information Security and Privacy III, 2013), where payment is required to buy a\nlicense and solve nonexistent issues, to _Modern Crypto Ransomware (Symantec, Report, 2016;_\nDingledine et al., USENIX, 2004), whose business model has been incredibly refined in many ways:\nno fake warning messages or false claims, updated and combined crypto algorithms, anonymous\ncommunications even through TOR, payments made through crypto currency, etc. The purpose of the\npresent paper, aims to strongly mitigate ransomware attacks on Windows systems creating a mapping\nbetween mostly used private file types and referred default programs, not allowing other executables\nto modify such data. The focus on data protection from unwanted interactions, not taking into account\nthe evolution of ransomware, may result non-innovative in a first analysis. However, the key concept\non which we based the work is closely related to the high depth of the protection software layer\ndeveloped within the Windows File System I/O stack. In other words the software layer implemented\nis positioned at a lower level of abstraction than the antivirus, thus resulting highly effective and\ndifficult to bypass. Ideally, our solution could be used in enterprise environments, restricting access to\nprivate data only to known software as well as building a _totally locked down Windows System for_\nPOS, ATM and Kiosk Mode Environments.\n\n### 2 Related work\n\nMalware Analysis is the action of proving that a suspicious program represents a threat to users.\nNumerous techniques exist to precisely analyze malware and deeply understand its behavior (Egele et\nal., ACM Computer Surveys, 2012), a necessary task to update anti-virus software with a new\nsignature. New threads and variants over existing families give a trace of malware evolution: it’s a\nchess game where analysts play a defense strategy in order to give quick answers and to avoid wide\npropagation. In addiction malware authors use evasion techniques to avoid detection. Such a\n\n\n-----\n\ncondition, leads to a constant struggle between adversaries by using custom and joint evasion\ntechniques from both sides. Obviously, ransomware can be considered as malware to all intents and\npurposes. In this context two main streams can be taken into account: static and dynamic malware\nanalysis. Static analysis consists in software inspection without executing. When source code is\navailable, this technique permits a complete understanding of given software. In a real scenario,\nanalysts expect only a binary representation in order to extract useful information: a reverse\nengineering operation is necessary to obtain the assembly code. Furthermore, the malware authors\nhave designed different obfuscation techniques especially in countering static analysis (Moser et al.,\nACSAC, 2007). Dynamic analysis, instead, consists in behavioral monitoring of suspicious software\nwhile it is being executed. Different techniques have been developed to overcome static analysis\nlimitations. One of the most relevant is the **Function Call Monitoring. Functions are fundamental**\nbuilding blocks of every program. They permit code reusing and a clear code structure when properly\nwritten. A method to understand software behavior is monitoring function calls: a hook function is\ntriggered every time a monitoring function is called. Such hooks are responsible for the completion of\nrequired analysis functionality (e.g. a simple logging component). Hooking is the process of\nintercepting function calls. The main Windows System hooking points are:\n\n- **Application Programming Interface. Even simple program may make heavy use of operating**\n\nsystem: system can execute thousands of system calls without the programmer's knowledge. In\norder to design a program, developers need to master the application programming interface (API)\nfor the target systems, that is the set of functions available to an application programmer with a\ndetailed semantics about passed parameters and returned values. APIs are accessed through\nlibraries of code provided by the operating system.\n\n- **System Calls. A system call is a controlled entry point into the kernel, allowing a process to**\n\nrequest that the kernel performs a service made available by an operating system. While invoking\na system call could seem similar to a C function call, a system call performs some privileged\nactions as changing the processor state from user mode to kernel mode or specifying information\nto transfer between user and kernel mode. The system call interface is the run-time support of the\nsystem, it works as a bridge from API and system calls. Figure 1 shows the relationship between\nsystem calls, system call interface and API. Like benign process, malicious code running in userspace needs to invoke system calls: in this scenario hooking the system call interface points out\nevery interaction within the system.\n\n**Figure 1: Handling of user application invoking a system call.**\n\n- **Windows Native API. Windows Native API resides above system call interface and below**\n\nWindows API. Contrarily to Windows API, this interface is stable only at service pack level and it\ncan change over different updates. Native API gives an abstract view over system calls, managing\nall needed pre and post-processing operations. Such API allows deep control over the system calls,\nrequiring a specific knowledge for relative system version.\n\n\n-----\n\nA long term study is reported by Kharraz et al. (Kharraz et al., DIMVA, 2015). They analyze more\nthan a thousand samples covering main ransomware families seen from 2006 to 2014. They show how\nmalware interacts within a system and various strategy to mitigate it. Specifically they suggest\nmonitoring API calls or File System activities and using decoy resources as additional measure. Many\napproaches have been proposed to analyze and detect malware intrusion: usually combining heuristics\nwith behavior analysis to evade countermeasures (Dinaburg, CCS, 2008; Moser et al., S&P, 2007).\nScaife et al. propose a pattern-recognition method to mitigate ransomware attacks, through monitoring\nI/O requests, (Scaife et al., ICDCS, 2016). Despite they claim to detect all tested malware samples,\nfew files result encrypted during their experiments. Similarly Kharraz et al (Kharraz et al., Usenix,\n2016) presented an automated approach to generate an artificial user environment and monitor\nfilesystem activity. They add image analysis methods to detect typical ransom demand message.\nOther researchers included machine learning techniques to mitigate attacks from new family samples\n(Anderson et al., JCV, 2011; Kolter et al., JMLR, 2006; Rieck et al., JCS, 2011; Sgandurra et al.,\nCoRR, 2016). The mentioned approaches suffer of high cost of misclassification errors. Ransomware\ndetection do not permit false negative even minimally: compared to other domains, machine learning\ntechniques are not well suitable to intrusion detection (Sommer et al., S&P, 2010). Continella et al.\n(Continella et al., ACSAC, 2016) try to mask previous issue introducing an automatic backup system.\nExcept for few scenarios, they only introduced a work around. Finally Microsoft recently announced\nthe upcoming new feature within the Windows Defender Antivirus called “Controlled folder access”,\nable to monitor the changes that Apps make to files in certain protected folders. If an App attempts to\nmake a change to these files, and the App is blacklisted by the new feature, you will get a notification\nabout the attempt. The few information available seem to suggest an antivirus-like implementation\nthat, as we will see, relies on a software layer higher than the one we implemented and thus much\nexposed to possible bypass.\n\n**Figure 2: simplified I/O stack with the filter manager and three Minifilter drivers**\n\n### 3 The proposed Minifilter Driver\n\nWindows documentation discourage from creating a new File system. Conversely it suggests\nusing File System Driver and File System Filter Drivers to add new functionalities to existing File\nsystems. File System Filter Drivers can intercept requests to a File system driver. In such a way it is\npossible to log, modify or prevent I/O operations.\n\n\n-----\n\nFilter Manager is a kernel-mode driver adopting legacy file system filter model. It exposes a rich\nset of functionalities required for a File system filter driver. Writing a Minifilter driver consists to\nadopt these functions instead of implementing a legacy filter driver from scratch.\n\nThe Filter Manager is active only when a Minifilter driver is loaded in the operating system.\nMinifilter driver is indirectly attached to the file system stack for a target volume, registering its I/O\noperations to the Filter Manager. For each of them, a Minifilter driver can register functions to call at\ndifferent times: before the beginning (e.g., pre-operation callback routine), after completion (e.g.,\npost-operation callback routine) or both. Filter Manager is responsible to pass I/O Request Packets\n(IRPs) to Minifilter drivers with respect of a predefined order given by unique identifiers called\n**altitudes. When a callback routine returns, it calls, in order, the next registered Minifilter callback**\nroutine. To guarantee interoperability with legacy filter drivers, more instances of Filter Manager,\ncalled Frames, can coexist in the file system stack to comply with the order of altitude assignment. A\nsingle Frame represents an interval of contiguous altitudes.\n\nFor example, an antivirus filter driver should be higher in the stack than a replication filter driver,\nso it can detect viruses and disinfect files before they are replicated to remote servers. Therefore,\nFilter drivers in the “File System Filter Anti-Virus group” are loaded before the ones in the “File\nSystem Filter-Replication-group”. Each load-order-group has a corresponding system-defined class\nand GUID class, used in the INF file for the filter driver.\n\nA Minifilter driver’s altitude ensures that the instance of the Minifilter driver is always loaded at\nthe appropriate location relative to other Minifilter driver instances, and it establishes the order in\nwhich the Filter Manager calls the Minifilter driver to handle I/O. _Altitudes are allocated and_\n_managed by Microsoft. Figure 2 shows a simplified I/O stack with the Filter Manager and three_\nMinifilter drivers.\n\nFor example, assuming all three Minifilter drivers in Figure 2 registered for the same I/O\noperation, the Filter Manager would call their pre-operation callback routines in order of altitude from\nhighest to lowest (A, B, C), then forward the I/O request to the next-lower driver for further\nprocessing. When the Filter Manager receives the I/O request for completion, it calls each Minifilter\ndriver’s post-operation callback routines in reverse order, from lowest to highest (C, B, A).\n\nThe specific Minifilter group we addressed is the one that includes Filter drivers that prevent the\ncreation of specific files or file content, called “FSFilter Content Screener” whose altitude must be in\nthe range 260000-269999. Please note that the altitude of the group we addressed is lower than the\n_one used for antiviruses (range 320000 – 329998). Since the load order is regulated by the altitude,_\nwe can assume that the higher is the altitude the higher is the likelihood that a driver functionality can\nbe compromised by lower drivers.\n\nIn this context, the development of a Minifilter Driver must necessarily be performed through the\nAPIs and data structures provided by Microsoft. In general, the stages involved are:\n\n- **Driver Entry Routine. The system loads the driver automatically when DriverEntry is the entry**\n\npoint routine. Otherwise the developer must specify its name for the linker. In this case we\nadopted the given naming convention. Such routine is defined as:\n\nNTSTATUS\n(*PDRIVER_INITIALIZE) (\n\nIN PDRIVER_OBJECT DriverObject,\nIN PUNICODE_STRING RegistryPath\n) ;\n\nIn this stage there are three main sub-stages to address, that are:\n\n`o` **Registry management. Our driver global initialization consists in retrieving information from**\n\nour Registry parameter keys that are provided through the .INF file for creating Registry keys,\nand including, among others a registry key called \"Extensions\" containing all the file types to\n\n\n-----\n\nprotect. Each one of these extensions are then used by the system to retrieve registry values\ncontaining default executable for filtered operations. Specifically each entry only contains a\nreference to another registry key.\n\n`o` **Minifilter registration. A Minifilter driver needs to be registered to the Filter Manager. Such**\n\ntask is completed in the FltRegisterFilter routine also passing its required callback routines and\nother driver information.\n\nNTSTATUS  FltRegisterFilter (\n\n_In_ PDRIVER_OBJECT Driver,\n_In_ const FLT_REGISTRATION *Registration,\n_Out_ PFLT_FILTER *RetFilter\n) ;\n\n`o` **Minifilter filtering. Minifilter driver only needs to call FltStartFiltering routine to start**\n\nfiltering. Such method is really simple and only takes as argument the filter pointer returned by\nFltRegisterFilter. It is not possible to start filtering before registering the Minifilter.\n\n- **Callback Routines. All interesting callback routines are passed together, as an array of**\n\nFLT_OPERATION_REGISTRATION structures, to the filter manager. We do not use postoperation callback, so we explain in this section only pre-operation callback routine. It is defined\nas:\n\ntypedef   FLT_PREOP_CALLBACK_STATUS\n\n(*PFLT_PRE_OPERATION_CALLBACK) (\n\nIN OUT PFLT_CALLBACK_DATA Data,\nIN PCFLT_RELATED_OBJECTS FltObjects,\nOUT PVOID *CompletionContext\n) ;\n\nWe recognize two different patterns: Default Programs request access to relative files against nondefault Programs. Taking such simplified approach, it is possible to build a bullet-proof system\ndefense. Our Minifilter driver records a read request as pre-operation callback routine,\nimplementing three tasks: check the requested file extension, extract the process name and\ncompare it with the related default Program for granting the access.\n\nIn order to prevent the bypass of our Minifilter simply by changing the file extension, we\nclassified as unsafe all the renaming of the file extensions as well as the file-read requests from\nprograms other than the Default Programs.\n\n### 4 Experiments\n\nMalware analysis can be simply performed through _Cuckoo Sandbox (Cuckoo Foundation,_\ncuckoosandbox.org, 2016), an open source project, widely used in such a field, integrating an\nautomated submission system, anti-detection modules and automated user-interaction; it seems to be\nperfect fit to our problem. Despite such a good premises, performing few tests revealed that many\nmalware samples do not expose their malicious behavior although they have already shown it in a notsandboxed environment. Rossow et al. (Rossow et al., IEEE Symp. on S&P, 2012) shows guidelines\nto design and present scientifically rigorous experiments. They gather common pitfalls in four main\ngroups:\n\n- **correct datasets - choose correctly which samples should be in;**\n\n- **transparency - give all needed information to understand and replicate experiments;**\n\n- **realism - make experiments as real as possible;**\n\n\n-----\n\n- **safety - do not be dangerous to others.**\n\nTo test our driver we used VirtualBox 5.1 to setup a set of virtual machines containing different\nWindows versions: Windows 7 32-bit, Windows 8.1 32-bit and Windows 10 64-bit. We chose such\nconfiguration based on Desktop Operating System Market Share showed in Table 2. We tested our\nvirtual environment against _Paranoid Fish, the tool that employs several techniques to detect_\nsandboxes and analysis environments as malware families do (Ortega, Paranoid Fish, 2016). For\ninstance, it checks hardware limitations, debug-mode execution, virtualized environment detection\n(e.g., traces of Wine, VirtualBox or VMware), hooks detection and sandbox detection. An example of\ncommon Paranoid Fish output is given in Figure 3.\n\n**Figure 3: Paranoid Fish output on a generic virtual environment**\n\nIn order to make our laboratory as real as possible, we replaced default hardware components\ninstalled in virtual machine with our real components. We used an open source tool to address such\ntasks (Keri, WMI detection, 2016), performed through two scripts: a bash script to modify such\ninformation on the bare virtual machine and a powershell script to clean up VirtualBox residual\ninformation after Windows installation. Not having a wide compatibility, a custom script is sometime\nneeded to fix minor issues, as in our case. After installing Windows system, the following steps are\nrequired to hide the virtual machine environment. We disabled the following services:\n\n- **Windows Defender - we don’t want Windows real-time protection analyzing, and possibly**\n\nblocking, our malware sample;\n\n- **Windows Firewall - although it may identify a testing environment, some malicious codes are**\n\ninhibited when system firewall is activated;\n\n- **Windows Update - new updates may modify our configuration and may give an additional**\n\nprotection to the system;\n\n- **Address Space Layout Randomization - a feature that partially randomizes address space from**\n\nbuffer overflow attacks;\n\n- **No eXecute technology - another protection feature for specifying areas of memory that cannot be**\n\nused for execution.\nHence, running the previous generated powershell script, we cleaned the registry keys, changing\nthem to real system information, and performed some common tasks to mimic a basic user interaction\n(i.e. change user and computer name, create and delete some files). Further, we installed runtime\nlibraries for Visual C and .NET, that are often used by malware, and common utility as Adobe\nReader, Adobe Flash Player, VLC media player, Mozilla Firefox, OpenOffice and 7zip. Then we\npopulate web browsers with a dump of typical user data, including fake credentials and browser\nhistory. Finally, we developed a Python script to populate our system (Hop and Fork, 2016), an easyto-use open source software to create artificially directories and files. It takes as arguments the\nnumber of directories and files, the file extension list and the average file size. Randomly it generates\ncontents and creates required files with given extensions. As a last step we wait almost 6 hours before\nsaving virtual machine state, as it looks in a real working-section time. Taking that there is nothing\nmore unreal than a system without user interaction, we developed another Python script that interacts\nwith the system mimicking user behavior (e.g., open browsers and store a web page on the system,\ncontinually move cursor over the screen, etc.). After reproducing a real environment we took a\n\n\n-----\n\nsnapshot, that is a VirtualBox feature to save the current state of the entire virtual machine. In this\nway, each experiment can begin exactly in the same initial state. After granting the access to worldwide researcher repository of VirusShare, we downloaded a ransomware collection composed by\nabout 36K elements. Monitoring activities was the most difficult task to cover. The Cuckoo Sandbox\nlacks on those tasks, revealing its virtual environment. Since we are only interested in ransomware\nencryption activities, we just checked files and desktop background: usually a ransom message is\nshown after encrypting data. Two different strategies have been used to analyze malware sample. In\nearly stage we only collected desktop screenshots, a VirtualBox feature, every 30 seconds for 45 min\nper sample. In such a way it was possible to monitor changes over the virtual machine without any\nhook. Despite being an unusual technique, it resulted extremely effective, without revealing any\nmonitoring scheme. Once collected our active dataset, we tested the environment by installing our\ndriver. In this case there was no need of extra monitoring features: we manually checked the driver\noutput logs and the decoy-files, looking for changes.\n\nType Samples\nCrypto ransomware 111\nlocker ransomware 30\nfake antivirus 30\nother active malware 37\nothers 819\nTotal samples 1027\n**Table 3. Classification of used dataset.**\n\nTable 3 shows the results of dataset classification. Despite the entire data set belongs to a\nransomware repository publicly available, most of the samples resulted not compliant to our\nexperimentation. In particular, almost 80% of total samples has not manifested malicious behavior,\nincluding a small set (17% of total samples) terminating with error messages. Only 10.8% of analyzed\nmalware exhibited the typical crypto ransomware behavior. A second experiment has tested our driver\nagainst this threat: Table 4 shows the results. During ransomware attacks, our driver correctly\nprevented access to private data and _no valuable data have been encrypted. From the malware point_\nof view, errors generated during files interaction were managed in the simplest way, that is by\nskipping those files. Taking advantage of such generic exception handling, we have inhibited malware\nfrom running over protected files without being detected. In particular, none of analyzed samples\nchanged its behavior due to our driver presence, this is an encouraging step to continue implementing\nsolution directly in kernel mode. We do not discuss false positive cases, since our strategy classifies\nas suspicious all the software not included in whitelist. We believe that this is not a limitation, rather a\nstrength for a system requiring strong security measures.\n\nEvaluation Results\ntotal ransomware 111\ndetection rate 100%\nfalse negative 0.0%\nencrypted valuable data 0.0%\n**Table 4. Experimental results.**\n\n### 5 Conclusions and future work\n\nThere are limitations that we came across when developing our driver and we are perfectly aware\nthat some work still needs to be done. The main limitations are the likelihood of false positives and\n\n\n-----\n\nthe driver’s lack of flexibility. In the specific, the whitelist is statically configured during the initiation\nphase therefore it does not adapt to new demands or eventual user’s habit change. Despite this\nsolution fits perfectly in enterprise environments and in POS, ATM and Kiosk Mode Environments,\nproblems may arise in home environments. However, the lack of flexibility should not be\nmisunderstood as a lack of feasibility. On the other hand we believe that focusing on the protection of\nthe user’s valuable data as close as possible to the storage, is the only way to prevent ransomware\nattacks. Moreover, even if a kernel-mode approach might seem daunting, because a poorly written\ncode can cause the entire computer to crash unexpectedly, it could ensure, at least in theory, better\nperformances. In particular, the Filter Driver has been developed to trigger only when the file\nextension matches the white list, in order to be unperceived by home users or by systems not\nspecifically oriented to high performance computing.\n\nAs said previously, evading a security measure implemented through a File System Filter Driver\nrequires, generally, the development of a Filter Driver whose altitude is equal or less the one of the\nproposed solution. In addition, beyond the required skills (a File System Filter Driver is not a\ncommon executable), the correct installation of a Filter Driver on x64-based systems (starting from\nWindows Vista) requires administrative privileges and the .SYS file must be signed.\n\nHence, while not excluding a possible evolution of the threat, the current trend highlights that the\nmajority of ransomware launches relatively straight-forward attack payloads with a very distinct and\npredictable behavior (Kharraz et al., DIMVA, 2015).\n\n### References\n\nAnderson et al. (November 2011). _Graph-based malware detection using dynamic analysis. In:_\nJournal in Computer Virology, November 2011, Vol. 7, Issue 4, pp 247–258\n\nChoi et al. (July 2016). Ransomware Against Police: Diagnosis of Risk Factors via Application of\n_Cyber-Routine Activities Theory. In: International Journal of Forensic Science & Pathology, Vol. 4,_\nJuly 2016, pp. 253-258.\n\nContinella et al. (December 2016). _ShieldFS: a self-healing, ransomware-aware filesystem. In:_\nProceedings of the 32[nd] Annual Conference on Computer Security Applications, ACSAC 16, Los\nAngeles, CA, USA, December 05-08, 2016, pp 336-347.\n\nCuckoo Foundation (2016). Cuckoo Sanbox: Automated Malware Analysis. 2016. Retrieved from\nhttps://cuckoosandbox.org.\n\nDinaburg et al. (October 2008). _Ether: malware analysis via hardware virtualization extensions._\nIn: Proceedings of the 15th ACM conference on Computer and communications security, CCS,\nAlexandria, Virginia, USA, October 27-31, 2008, pp 51-62.\n\nDingledine et al. (2004). _Tor: The second-generation onion router. In: Proceedings of The 13[th]_\nUsenix Security Symposium, San Diego, CA, August 09-13, 2004.\n\nEgele et al. (February 2012). _A survey on automated dynamic malware-analysis techniques and_\n_tools. In: Journal ACM Computing Surveys (CSUR), Vol. 44, Issue 2, February 2012, Article No. 6._\n\nForand (March 2015). _PARCC postponed as N.J. school district's network 'held hostage' for_\n_bitcoins. Retrieved from http://www.nj.com/gloucester-county/index.ssf/2015/03/nj_school_districts_network_held_hostage_for_500_i.html_\n\nFurnell et al. (November 2012). Power to the people? The evolving recognition of human aspects\n_of security. In: Computers & Security, Vol. 31, Issue 8, November 2012, pp 983-988._\n\nGazet (February 2010). _Comparative analysis of various ransomware virii. In Journal in_\nComputer Virology, Vol. 6, Issue 1, february 2010, pp 77–90.\n\nGreen (July 2016). _Hospitals are hit with 88% of all ransomware attacks. Retrieved from_\nhttp://www.beckershospitalreview.com/healthcare-information-technology/hospitals-are-hit-with-88of-all-ransomware-attacks.html.\n\n\n-----\n\nHop and Fork (2016). vm-palm-tree. Retrieved from https://github.com/hopandfork/vm-palm-tree.\nKeri (2016). WMI detection prevented. Retrieved from https://github.com/nsmfoo/antivmdetection\nKharraz et al. (July 2015). _Cutting the Gordian Knot: A Look Under the Hood of Ransomware_\n_Attacks. In: Proceedings of the 12[th] International Conference on Detection of Intrusions and Malware,_\nand Vulnerability Assessment, (DIMVA), Milan, Italy, July 09-10, 2015, Vol. 9148, pp. 3-24.\n\nKharraz et al. (August 2016). _UNVEIL: A Large-Scale, Automated Approach to Detecting_\n_Ransomware. In: Proceedings of the 25[th] USENIX Security Symposium, Austin, TX, USA, August_\n10-12 2016, pp. 757-772.\n\nKolter et al. (December 2006). Learning to detect and classify malicious executables in the wild.\nIn: The Journal of Machine Learning Research, Vol. 7, pp 2721-2744.\n\nMoser et al. (May 2007). _Exploring Multiple Execution Paths for Malware Analysis. In:_\nProceedings of the 2007 IEEE Symposium on Security and Privacy, Berkeley, CA, USA, May 20-23,\n2007, pp 231-245.\n\nMoser et al. (December 2007). Limits of static analysis for malware detection. In: Proceedings of\nthe 23[rd] Annual Computer Security Applications Conference, ACSAC, Miami Beach, FL, USA, 10-14\nDec 2007.\n\nNakamoto (2008). _Bitcoin: A peer-to-peer electronic cash system. Retrieved from_\nhttps://bitcoin.org/bitcoin.pdf\n\nOrtega (2016). Paranoid Fish. Retrieved from https://github.com/a0rtega/pafish\nOsterman Research (August, 2016). _Understanding the Depth of the Global Ransomware_\n_Problem. Retrieved from https://www.malwarebytes.com/surveys/ransomware/?aliId=13242065_\n\nRieck et al. (December 2011). _Automatic analysis of malware behavior using machine learning._\nIn: Journal of Computer Security, Vol. 19, Issue 4, December 2011, pp 639-668.\n\nRossow et al. (May 2012). _Prudent Practices for Designing Malware Experiments: Status Quo_\n_and Outlook. In: Proceedings of the 2012 IEEE Symposium on Security and Privacy, SP 12, San_\nFrancisco, CA, USA, 20-23 May 2012, pp 65-79.\n\nSavage et al. (August, 2015). _The_ _evolution_ _of_ _ransomware._ Retrieved from\nhttp://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/the-evolution-of-ransomware.pdf\n\nScaife et al. (June 2016). CryptoLock (and Drop It): Stopping Ransomware Attacks on User Data.\nIn: Proceedings of the 36[th] International Conference on Distributed Computing Systems (ICDCS),\nNara, Japan, 27-30 June 2016.\n\nSgandurra et al. (2016). Automated Dynamic Analysis of Ransomware: Benefits, Limitations and\n_use for Detection. In: ArXiv e-prints, arXiv:1609.03020_\n\nSommer et al. (May 2010). Outside the Closed World: On Using Machine Learning for Network\n_Intrusion Detection. In: Proceedings of the 2010 IEEE Symposium on Security and Privacy, SP 10,_\nBerkeley/Oakland, CA, USA, May 16-19, 2010, pp 305-316.\n\nSonicWall (2017). _SonicWall_ _Annual_ _Threat_ _Report._ _SonicWall._ Retrieved from\nhttps://www.sonicwall.com/whitepaper/2017-sonicwall-annual-threat-report8121810/\n\nStone-Gross et al. (2013). The Underground Economy of Fake Antivirus Software. In: Schneier B.\n(eds) Economics of Information Security and Privacy III. Springer, New York, NY.\n\nSymantec Corporation (October 2009). Symantec Report on Rogue Security Software. Retrieved\nfrom http://eval.symantec.com/mktginfo/enterprise/white_papers/b-symc_report_on_rogue_security_software_WP_20100385.en-us.pdf.\n\nSymantec Corporation (April, 2016). _Internet Security Threat Report. Retrieved from_\nhttps://www.symantec.com/content/dam/symantec/docs/reports/istr-21-2016-en.pdf\n\nSymantec Corporation (August 2016). _Ransomware and Businesses 2016. Retrieved from_\nhttps://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/ISTR2016_\nRansomware_and_Businesses.pdf\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Preventing Ransomware Attacks Through File System Filter Drivers.pdf"
    ],
    "report_names": [
        "Preventing Ransomware Attacks Through File System Filter Drivers.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536250,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1613698986,
    "ts_modification_date": 1513253426,
    "files": {
        "pdf": "https://archive.orkl.eu/a4cdee50fdca59043c343db93a3af02155677e3c.pdf",
        "text": "https://archive.orkl.eu/a4cdee50fdca59043c343db93a3af02155677e3c.txt",
        "img": "https://archive.orkl.eu/a4cdee50fdca59043c343db93a3af02155677e3c.jpg"
    }
}