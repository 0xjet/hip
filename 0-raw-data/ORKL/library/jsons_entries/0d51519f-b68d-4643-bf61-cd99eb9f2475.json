{
    "id": "0d51519f-b68d-4643-bf61-cd99eb9f2475",
    "created_at": "2023-01-12T15:06:26.260373Z",
    "updated_at": "2025-03-27T02:06:11.180733Z",
    "deleted_at": null,
    "sha1_hash": "15b59a0d1057f6d367bdb7d5a37982a165f015e3",
    "title": "2018-09-27 - Torii botnet - Not another Mirai variant",
    "authors": "",
    "file_creation_date": "2022-05-28T21:57:41Z",
    "file_modification_date": "2022-05-28T21:57:41Z",
    "file_size": 739590,
    "plain_text": "# New Torii Botnet uncovered, more sophisticated than Mirai\n\n**blog.avast.com/new-torii-botnet-threat-research**\n\n[Threat Intelligence Team 27 Sep 2018](https://blog.avast.com/author/threat-intelligence-team)\n\nNew, more sophisticated IoT botnet targets a wide range of devices\n\n_written by Jakub Kroustek, Vladislav Iliushin, Anna Shirokova, Jan Neduchal and Martin Hron_\n\nDisclaimer: Analysis of the server content and samples was done on Thursday, September 20th. Follow the Avast Blog for further\nupdates.\n\n## Introduction\n\n2018 has been a year where the Mirai and QBot variants just keep coming. Any script kiddie now can use the Mirai source code, make\na few changes, give it a new Japanese-sounding name, and then release it as a new botnet.\n\nOver the past week, we have been observing a new malware strain, which we call Torii, that differs from Mirai and other botnets we\nknow of, particularly in the advanced techniques it uses.\n\nUnlike the aforementioned IoT botnets, this one tries to be more stealthy and persistent once the device is compromised, and it does\n**not (yet) do the usual stuff a botnet does like DDOS, attacking all the devices connected to the internet, or, of course, mining**\ncryptocurrencies.\n\nInstead, it comes with a quite rich set of features for exfiltration of (sensitive) information, modular architecture capable of fetching and\nexecuting other commands and executables and all of it via multiple layers of encrypted communication.\n\nFurthermore, Torii can infect a wide range of devices and it provides support for a wide range of target architectures, including MIPS,\nARM, x86, x64, PowerPC, SuperH, and others. Definitely, one of the largest sets we’ve seen so far.\n\nAs we’ve been digging into this strain, we’ve found indications that this operation has been running since December 2017, maybe even\nlonger.\n\n[We would like to give credit to @VessOnSecurity, who actually](https://twitter.com/vessonsecurity) [tweeted about a sample of this strain hitting his telnet honeypot last](https://twitter.com/VessOnSecurity/status/1042538889582444546)\nweek.\n\n\n-----\n\nAccording to this security researcher, telnet attacks have been coming to his honeypot from Tor exit nodes, so we decided to name this\nbotnet strain “Torii”.\n\nIn this post, we will describe what we know about this strain so far, how it is spreading, what are its stages, and we will depict some of\nits features.\n\nThe analysis is still ongoing and further findings will be included in blog post updates.\n\nNow, let’s start with the infection vector.\n\n## Analysis of the initial shell script\n\nThe infection chain starts with a telnet attack on the weak credentials of targeted devices followed by execution of an initial shell script.\nThis script looks quite different from typical scripts that IoT malware uses in that it is far more sophisticated.\n\nThe script initially tries to discover the architecture of the targeted device and then attempts to download the appropriate payload for that\ndevice.The list of architectures that Torii supports is quite impressive: including devices based on x86_64, x86, ARM, MIPS, Motorola\n68k, SuperH, PPC - with various bit-width and endianness. This allows Torii to infect a wide range of devices running on these very\ncommon architectures.\n\n\n-----\n\nThe malware uses several commands to download binary payloads by executing the following commands: \"wget\", \"ftpget\", \"ftp\",\n_\"busybox wget\", or \"busybox ftpget\". It uses multiple commands to maximize the likelihood that it can deliver the payload._\n\n\n-----\n\nIf the binaries cannot be downloaded via the HTTP protocol with “wget” or “busybox wget” commands, it will use FTP. When the FTP\nprotocol is being used, it requires authentication. Credentials are nicely provided in the script:\n\nUsername:   u=\"<redacted>\"\nPassword:   p=\"<redacted>\"\n\nPort for FTP: po=404\n\nIP of the FTP/HTTP server: 104 237 218 85 (This IP is still alive at the time of writing this post )\n\n\n-----\n\nBy connecting to the FTP server, there is quite a lot going on:\n\n_[Click to view full file](https://cdn2.hubspot.net/hubfs/4650993/avast-blog/torii_directory_structure.txt?t=1538008811323)_\n\nAmong other things, the server contains logs from the NGINX and FTP servers, payload samples, a bash script that directs the infected\ndevices to this very machine where the malware is hosted, and more. We’ll discuss what we found in these logs at the end of this post,\nbut first let’s take a look at all the samples that are hosted there.\n\n## Analysis of the 1st stage payload (dropper)\n\nOnce the script determines which architecture the target device it is running on, it downloads and executes the appropriate binary from\nthe server. All of these binary files are in the ELF file format. While analyzing these payloads, we found that they are all very similar and\nare “just” droppers of the second stage payload. What is notable is that they use several methods to make the second stage persistent\non the target device. Let’s look deeper into the details below.\n\nFor our description, we’ll focus on the x86 sample with the SHA256 hash:\n\n0ff70de135cee727eca5780621ba05a6ce215ad4c759b3a096dd5ece1ac3d378.\n\n### String Obfuscation\n\n\n-----\n\nFirst we tried to de obfuscate the sample, so we delved into some of the text strings to look for clues on how the malware works. The\nvast majority of text strings in the 1st and 2nd stage are encrypted by a simple XOR-based encryption and they are decrypted during\nruntime when a particular string is needed. You can use the following IDA Python script for decryption:\n\nsea = ScreenEA()\n\nmax_size = 0xFF\n\nfor i in range(0x00, max_size):\n\nb = Byte(sea+i)\n\ndecoded_byte = (b ^ (0xFEBCEADE >> 8 * (i % 4))) & 0xFF;\n\nPatchByte(sea+i,decoded_byte)\n\nif b == 0x00 or decoded_byte == 0x00:\n\nbreak\n\ne.g. F1 9A CE 91 BD C5 CF 9B B2 8C 93 9B A6 8F BC 00 → ‘/proc/self/exe’\n\n### Install 2nd Stage ELF File\n\nThe core functionality of the first stage is to install another ELF file, the second stage executable, which is contained within the first ELF\nfile.\n\nThe file is installed into a pseudo-random location that is generated by combining a predefined location from a fixed list:\n\n\"/usr/bin\"\n\"/usr/lib\"\n$HOME_PATH\n\"/system/xbin\"\n\"/dev\"\n$LOCATION_OF_1ST_STAGE\n\"/var/tmp\"\n\"/tmp\"\n\nand a filename from another list:\n\n“setenvi“\n“bridged“\n“swapper“\n“natd“\n“lftpd“\n“initenv“\n“unix_upstart“\n“mntctrd“\netc.\n\nPutting these two items together creates the destination file path.\n\n### Make the 2nd Stage Persistent\n\nAfterwards, the dropper makes sure that the second stage payload is executed and that it will remain persistent. It is unique in that it is\nremarkably thorough in how it achieves persistence. It uses at least six methods to make sure the file remains on the device and always\nruns. And, not just one method is executed – it runs all of them.\n\n1. Automatic execution via injected code into ~\\.bashrc\n2. Automatic execution via “@reboot” clause in crontab\n3. Automatic execution as a “System Daemon” service via systemd\n4. Automatic execution via /etc/init and PATH. Once again, it calls itself \"System Daemon\"\n5. Automatic execution via modification of the SELinux Policy Management\n6. Automatic execution via /etc/inittab\n\n\n-----\n\nAnd, finally, it executes the dropped inner ELF  the second stage payload.\n\n## Analysis of the 2nd stage payload (bot)\n\nThe second stage payload is a full-fledged bot capable of executing commands from its master (CnC). It also contains other features\nsuch as simple anti-debugging techniques, data exfiltration, multi-level encryption of communication, etc.\n\nFurthermore, many functions found in the second stage are the same as in the first, making it highly likely they are both created by the\nsame author(s).\n\nThe code inside of the first stage payload is almost identical in all the versions. This is however not true in the case of the second stage\nwhere we find differences among the binaries for various hardware architectures. To describe the core functionality that can be found in\nmost of the versions, we will once again take a look on x86 code found in the sample with SHA256 hash:\n5c74bd2e20ef97e39e3c027f130c62f0cfdd6f6e008250b3c5c35ff9647f2abe.\n\n### Anti-Analysis Methods\n\nThe anti-analysis methods in this malware are not as advanced as we are accustomed to seeing in Windows or mobile malware, but\nthey are improving.\n\nIt uses the simple anti-analysis method of a 60 seconds sleep() after execution, which probably tries to circumvent simple\nsandboxes.\n\nFurthermore, it tries to randomize the process name via prctl(PR_SET_NAME) call to something like “\\[[a-z]{12,17}\\]” (regular\nexpression) in order to avoid detection of blacklisted process names.\n\nFinally, the authors are trying to make the analysis harder by stripping the symbols from executables. When we first downloaded\nthe samples from the aforementioned server 104.237.218.85, they all contained symbols, which made their analysis easier. It is\ninteresting to note that a few days later these files were replaced by their stripped versions. No other differences were found\nbetween these two versions, leading us to believe that the authors are taking continual action to further protect their executables\nagainst analysis.\n\n### CnC Servers\n\nAs we already said, this component is a bot that communicates with a master CnC server. The addresses of the CnCs are once again\nencrypted by the aforementioned XOR-based cipher. It seems that each Torii version contains 3 CnC addresses. The campaign that is\ncurrently running tries to get commands from CnC servers running at:\n\ntop.haletteompson.com\ncloud.tillywirtz.com\ntrade.andrewabendroth.com\n\nIt tries to communicate with the first domain from the list and moves to the next one if it fails. In the case of failure, it also tries to resolve\nthe domain name via Google DNS 8.8.8.8.\n\n_Resolving CnC domain name_\n\nThese three domain names have resolved to IP 66.85.157.90 since September 15, 2018. Some other domains hosted on the same IP\nare also quite suspicious:\n\ncloud.tillywirtz.com\n\ndushe.cc\n\neditor.akotae.com\n\npress.eonhep.com\n\nweb.reeglais.com\n\npsoriasiafreelife.win\n\nq3x1u.psoriasiafreelife.win\n\nserver.blurayburnersoftware.com\n\ntop.haletteompson.com\n\ntrade.andrewabendroth.com\n\nwww.bubo.ccwww.dushe.cc\n\nThat so many strange looking domains are hosted at one IP address raises concern. Furthermore, the CnC domain names resolved to a\ndifferent IP address (184.95.48.12) before that.\n\n\n-----\n\n(History of resolving DNS names hardcoded in the sample)\n\nSome more digging turned up another set of ELF samples belonging to Torii with three different CnC addresses:\n\npress.eonhep.com\neditor.akotae.com\nweb.reeglais.com\n\nThey all resolved to the same IP (184.95.48.12) in the past and, for example “press.eonhep.com” was using this IP since December 8,\n**2017. Therefore, we think that this strain has been in existence since at least December 2017 and quite possibly longer.**\n\n### CnC Communication\n\nThe second stage communicates with these CnC servers via TCP port 443 as well as further encryption layers. It is interesting to note\nthat it uses port 443 as a deception, as it doesn’t communicate using TLS but takes advantage of common use of this port for HTTPS\ntraffic. Each message (including replies) forms a structure we call a “message envelope” and each envelope is AES-128 encrypted and\nthere is a MD5 checksum of the content to ensure it hasn’t been modified or corrupted. Furthermore, each envelope contains a stream\nof messages where each message is encrypted by a simple XOR-based encryption, which is different than the one used to obfuscate\nthe strings. It isn’t as strong as it looks as the decryption keys are included in the communication.\n\n_Algorithm used for encryption of CnC messages_\n\nTorii also exfiltrates the following information while connecting to a CnC server:\n\nHostname\n\nProcess ID\n\nPath to second stage executable\n\nAll MAC addresses found in /sys/class/net/%interface_name%/address + its MD5 hash - this forms some kind of unique victim ID,\nallowing the bad actor to fingerprint and catalog devices more easily. It is also stored in local files with strange names such as\nGfmVZfJKWnCheFxEVAzvAMiZZGjfFoumtiJtntFkiJTmoSsLtSIvEtufBgkgugUOogJebQojzhYNaqyVKJqRcnWDtJlNPIdeOMKP,\nVFgKRiHQQcLhUZfvuRUqPKCtcrjmhtKcYQorAWhqAuZuWfQqymGnWiiZAsljnyNlocePAOHaKHvGoNXMZfByomZqEMbtkOEzQkQq,\nXAgHrWKSKyJktzLCMcEqYqfoeUBtgodeOjLgfvArTLeOkPSyRxqrpvFWRhRYvVcLeNtMKTdgFhwrypsRoIiDeObVxTTuOVfSkzgx,\netc.\n\nDetails found by uname() call, including sysname, version, release, and machine.\n\nOutputs of the following commands designed to gain yet more information on the target device:\n\n\n-----\n\nid 2 /dev/null\nuname -a 2>/dev/null\nwhoami 2>/dev/null\ncat /proc/cpuinfo 2>/dev/null\ncat /proc/meminfo 2>/dev/null\ncat /proc/version 2>/dev/null\ncat /proc/partitions 2>/dev/null\ncat /etc/*release /etc/issue 2>/dev/null\n\n### CnC Commands\n\nWhile analyzing the code, we’ve found that the bot component is communicating with the CnC with active polling in an endless loop,\nalways asking its CnC whether there are any commands to execute. After receiving a command, it replies with the results of the\ncommand execution. Each message envelope has a value specifying which type of command it brings. The same value is used for\nreply. We have uncovered the following command types:\n\n**0xBB32 - Store a file from CnC to a local drive:**\n\nReceive:\n\n1. Filepath where to store content from CnC\n2. Content\n3. MD5 checksum of content\n\nReply:\n1. File path where the file was stored\n2. Error code\n\n**0xA16D - Receive value of timeout to be used for CnC polling:**\n\nReceive:\n\n1. DWORD with number of minutes to sleep between CnC contacts\n\nReply:\n1. Message with code 66\n\n**0xAE35 - Execute a given command in a desired shell interpreter and send outputs back to CnC:**\n\nReceive:\n\n1. Command to execute in shell (sh -c \"exec COMMAND\")\n2. WORD with execution timeout in seconds (max 60 seconds)\n3. String with a path to shell interpreter (optional)\n\nReply:\n1. String with outputs (stdout + stderr) of command execution\n\n**0xA863 - Store a file from CnC to a given path, change its flags to “rwxr-xr-x” to make it executable and then execute it:**\n\nReceive:\n\n1. File path where to store content from CnC\n2. Content\n3. MD5 checksum of content\n\nReply:\n1. File path where the file was stored\n2. Return code from execution of that file\n\n**0xE04B - Check that the given file exists on a local system and return its size:**\n\nReceive:\n\n1. Filepath to check\n\nReply:\n1. File path\n2 File si e\n\n\n-----\n\n**0xF28C** **Read N bytes from offset O of selected file F and send them to CnC:**\n\nReceive:\n\n1. File path to file (F) to read from\n2. QWORD offset (O) where to start reading\n3. DWORD number (N) of bytes to read\n\nReply:\n1. File content\n2. Offset\n3. Size of bytes read\n4. MD5 checksum of read content\n\n**0xDEB7 - Delete a specified file**\n\nReceive:\n\n1. Name of a file to delete\n\nReply:\n1. Error code\n\n**0xC221 - Download a file from the given URL**\n\nReceive:\n\n1. Path where to a store file\n2. URL\n\nReply:\n1. File path\n2. URL\n\n**0xF76F - Get address of a new CnC server and start communication with it.**\n\nReceive:\n\n1. ?\n2. New domain name\n3. New port\n4. ?\n\nReply:\n1. Repeat the received information\n\n**0x5B77, 0x73BF, 0xEBF0, and probably other codes - Some kind of communication to ping or get a heartbeat on the target**\n**device to ensure the communication partner that the communication channel is working):**\n\nReceive:\n\n1. Everything received is ignored\n\nReply:\n1. Repeat the received information\n\n## Analysis of the sm_packed_agent\n\nWhile we were investigating the server, we found another interesting binary we managed to get from the FTP server that is called\n“sm_packed_agent”. We don’t have any evidence that is has been used on the server, but its versatility suggests that it could be used to\nsend any remote command desired to the target device. It contains a GO-written application packed using UPX when unpacked, it has a\n\n\n-----\n\nfew interesting strings that suggests it has server like capabilities:\n\n### Underneath, it uses the following 3rd party libraries:Code Reuse\n\nhttps://github.com/shirou/gopsutil/host\n\nhttps://github.com/shirou/gopsutil/cpu\n\nhttps://github.com/shirou/gopsutil/mem\n\nhttps://github.com/shirou/gopsutil/net\n\n### Possible name of source code:\n\n/go/src/Monitor_GO/agent/agent.go\n\n/go/src/Monitor_GO/sm_agent.go\n\nSome of these libraries are abusing a BSD licence, which requires redistribution of copyright notice. Apparently Torii’s authors don’t care\nabout copyright infringement.\n\n### Functionality\n\nThe functionality of the sm_agent is as follows:\n\nTakes one parameter on cmdline -p with port number\nInitializes crypto, loads TLS and keys + cert\nCreates server and listening for TLS connection\nAwaits commands encoded in BSON format\nCommand handler inside knows these commands:\n\n1: Monitor_GO_agent__Agent_GetSystemInfo\n2: Monitor_GO_agent__Agent_GetPerformanceMetrics\n7: Monitor_GO_agent__Agent_ExecCmdWithTimeout\n\nthis command seems to be able to run any arbitrary OS command read from BSON payload.\n\nTLS encryption, certificates and keys:\n\nAgent uses ChaCha20-Poly1305 stream cipher for TLS\nKeys and certs in the same directory\nSelf signed certificate of authority ca.crt with name Mayola Mednick\nclient.crt issued by ca.crt for Dorothea Gladding\nserver.crt + server.key issued by ca.crt for Graham Tudisco\n\nCertificates are self-signed and obviously using fake names.\n\nStart agent sh\n\n\n-----\n\nThis script is to kill any previous instances of start sm_packed_agent and run it on TCP port 45709 and re run it again in case it fails.\n\n_A script which runs and keeps running sm_packed_agent_\n\nIt is not yet known how Torii authors are using this service, but it is incredibly versatile and could be used to run any command on the\ndevice. And because this application is written in GO, it can be easily recompiled to run on virtually any architecture. Taking into account\nthat this file is running on a malware distribution machine, it is quite possible that it is a backdoor or even a service to orchestrate\nmultiple machines.\n\n## Analysis of Logs From the Server 104.237.218.85\n\nFinally, we took a look at the logs we found for both the Nginx server and the FTP server. Such access log can help us understand how\nmany clients actually were infected by Torii or tried to download it.\n\nAs we write this blog, Torii authors have already disabled FTP and Nginx logging (more on that below), but looking at the logs that are\navailable, we can generate some simple statistics.\n\nA total of 206 unique IPs connected to the server on September 7th, 8th, 19th, and 20th according to the logs on the server.\n\nAccess-2018-09-07.log - 54 unique IPs\n\nAccess-2018-09-08.log - 20\n\nAccess-2018-09-19.log - 189\n\nAccess-2018-09-20.log - 10\n\nIt looks like one IP 38.124.61.111 connected to the server 1 056 393 times!\n\nBy looking into the logs, it seems that someone actually ran DirBuster-1.0-RC1, trying to figure out what is going on. Brute force\nDirBuster is used to guess directories/filenames on the web server and generates a large number of requests. It is quite unfortunate if\nthis scan originated from a researcher as there are more elegant approaches in the case of a sophisticated malware like Torii.\n\nBy scanning the ports of IP 38.124.61.111, we can see that there are a few ports open:\n\nOn port 27655, there is an SSH banner which states:\n\n“SSH-2.0-OpenSSH_7.4p1 Raspbian-10+deb9u3” It looks like this box is running Raspbian. If you are behind this, write us.\n\nOther logs that are available to us are FTP server logs.\n\n\n-----\n\nThere are a few clients that connected and downloaded some files that are not on the FTP server anymore:\n\nSat Sep 8 08:31:24 2018 1 128.199.109.115 6 /media/veracrypt1/nginx/md/zing.txt b _ o r md ftp 0 * c\n\nAccording to logs we were able to analyze, a total of 592 unique clients were downloading files from this server over a period of a few\ndays. It’s important to remember that once the target device receives the payload, it stops connecting to the download server and\nconnects to the CnC server. Therefore, we are likely seeing a snapshot of new devices that were recruited into this botnet over the\nperiod of time for which we have log files.\n\nAdditionally, there are 8 clients that were using both the HTTP server and the FTP server, which could be the case if downloading using\nHTTP failed for some reason, or if Torii authors were testing functionality of the bash script or a server set up\n\nWe cannot speculate about what we do not have evidence for, but this server could be just one of a number of servers infecting new\ntarget devices, and only further investigation will reveal the true scope of this botnet. Given the level of sophistication of the malware we\nresearched, it would seem likely that it is designed to map and control a large number of diverse devices.\n\n## Conclusion\n\nEven though our investigation is continuing, it is clear that Torii is an example of the evolution of IoT malware, and that its sophistication\nis a level above anything we have seen before. Once it infects a device, not only does it send quite a lot of information about the\nmachine it resides on to the CnC, but by communicating with the CnC, it allows Torii authors to execute any code or deliver any payload\nto the infected device. This suggests that Torii could become a modular platform for future use. Also, because the payload itself is not\nscanning for other potential targets, it is quite stealthy on the network layer.\n\nStay tuned for the follow ups.\n\n## IoC\n\n### CnC\n\ntop.haletteompson.com\n\nсloud.tillywirtz.com\n\ntrade.andrewabendroth.com\n\npress.eonhep.com\n\neditor.akotae.com\n\nweb.reeglais.com\n\n### IP\n\n184.95.48.12\n\n104.237.218.82\n\n104.237.218.85\n\n66.85.157.90\n\n### SHA256\n\n [click here to view SHA256 hashes]\n\nAvast is a global leader in cybersecurity, protecting hundreds of millions of users around the world. Protect all of your devices with\n[award-winning virus protection. Safeguard your privacy and encrypt your online connection with SecureLine VPN.](https://www.avast.com/free-antivirus-download)\n\n[Learn more about products that protect your digital life at avast.com. And get all the latest news on today's cyberthreats and how to beat](http://avast.com/)\nthem at [blog.avast.com.](https://blog.avast.com/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-09-27 - Torii botnet - Not another Mirai variant.pdf"
    ],
    "report_names": [
        "2018-09-27 - Torii botnet - Not another Mirai variant.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535986,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1653775061,
    "ts_modification_date": 1653775061,
    "files": {
        "pdf": "https://archive.orkl.eu/15b59a0d1057f6d367bdb7d5a37982a165f015e3.pdf",
        "text": "https://archive.orkl.eu/15b59a0d1057f6d367bdb7d5a37982a165f015e3.txt",
        "img": "https://archive.orkl.eu/15b59a0d1057f6d367bdb7d5a37982a165f015e3.jpg"
    }
}