{
    "id": "4bae4b8d-b0b8-49ef-a56f-e68f6462130e",
    "created_at": "2023-01-12T15:05:52.992947Z",
    "updated_at": "2025-03-27T02:08:40.49631Z",
    "deleted_at": null,
    "sha1_hash": "b2345a07fe7c5ec975b84d7467fe327b98c52f61",
    "title": "2022-04-12 - Ghidra script to handle stack strings",
    "authors": "",
    "file_creation_date": "2022-05-28T03:51:30Z",
    "file_modification_date": "2022-05-28T03:51:30Z",
    "file_size": 219043,
    "plain_text": "# Ghidra script to handle stack strings\n\n**[maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-handle-stack-strings/](https://maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-handle-stack-strings/)**\n\n### This article was published on the 12th of April 2022.\n\n The usage of stack strings within malware is frequent, especially when analysing shellcode or more advanced samples. This article will provide insight into stack strings, the endianness of values, how to handle (encrypted) stack strings, and the step-by-step creation of a Ghidra script which handles (wide) stack strings, which may or may not be encrypted. At last, the complete script is given.\n\n The analysis in this article is done with a self-built version of Ghidra 10.2, based on the publicly available source code of the first of February 2022. The samples have been analysed using all analysers.\n\n## Table of contents\n\n Stack strings explained\n\n### In general, strings are not stored within the text segment of the binary. When a string is used in a local variable in source code, the compiler generally places the string in a different segment. A pointer to the string’s location is used to access or alter the data.\n\n To obfuscate strings, one can create a string on the stack, character for character, or in small groups of characters. The concatenation of these characters lead to the existence of the complete string on the stack. When viewing the strings of a binary, the characters might not show up.\n\n As an example, GNU strings only shows human readable strings with a length of 4 or longer by default, meaning that smaller groups do not show up, or might show up in parts. The third crack me in this course is based on this technique. Note that Mandiant’s FLOSS also aims to detect stack strings in binaries.\n\n Additionally, stack strings can also be encrypted. This would make the use of tools harder, although FLOSS attempts to also decrypt stack strings if a simple encryption scheme is used.\n\n Note that the character set and size of the used encoding matters. To make the script more generic, the obtained stack string bytes will be printed out using multiple encodings. The wrong encoding is likely to be displayed as garbage, making it fairly easy for an analyst to pick the string that looks correct.\n\n\n-----\n\n## Endianness\n\n### The endianness defines where the most significant bit is, which is either the first or the last. The basic CPU architecture article explains the endianness in more detail. With stack strings, it is important to understand if several characters need to be read right-to-left, or left-to-right.\n\n## Stack string example: CaddyWiper\n\n### CaddyWiper is a wiper which was used by a pro-Russian actor against Ukrainian victims in March 2022, after the Russian invasion, as reported by ESET. It contains a lot of stack strings, including wide strings. The hashes of the sample are given below. The sample can be downloaded from Malware Bazaar and MalShare.\n```\nMD-5: 42e52b8daf63e6e26c3aa91e7e971492 \nSHA-1: 98b3fb74b3e8b3f9b05a82473551c5a77b576d54 \nSHA-256: a294620543334a721a2ae8eaaf9680a0786f4b9a216d75b55cfd28f39e9430ea\n\n The excerpt below shows a wide stack string, which can be seen due to the frequent occurrence of 0x00, and the double zero to terminate the string.\nMOV byte ptr [EBP + local_20],0x6b\nMOV byte ptr [EBP + local_1f],0x0\nMOV byte ptr [EBP + local_1e],0x65\nMOV byte ptr [EBP + local_1d],0x0\nMOV byte ptr [EBP + local_1c],0x72\nMOV byte ptr [EBP + local_1b],0x0\nMOV byte ptr [EBP + local_1a],0x6e\nMOV byte ptr [EBP + local_19],0x0\nMOV byte ptr [EBP + local_18],0x65\nMOV byte ptr [EBP + local_17],0x0\nMOV byte ptr [EBP + local_16],0x6c\nMOV byte ptr [EBP + local_15],0x0\nMOV byte ptr [EBP + local_14],0x33\nMOV byte ptr [EBP + local_13],0x0\nMOV byte ptr [EBP + local_12],0x32\nMOV byte ptr [EBP + local_11],0x0\nMOV byte ptr [EBP + local_10],0x2e\nMOV byte ptr [EBP + local_f],0x0\nMOV byte ptr [EBP + local_e],0x64\nMOV byte ptr [EBP + local_d],0x0\nMOV byte ptr [EBP + local_c],0x6c\nMOV byte ptr [EBP + local_b],0x0\nMOV byte ptr [EBP + local_a],0x6c\nMOV byte ptr [EBP + local_9],0x0\nMOV byte ptr [EBP + local_8],0x0\nMOV byte ptr [EBP + local_7],0x0\n\n```\n\n-----\n\n### If one were to rename and retype the first variable, originally named local_20, to a 26 character long array named s_kernel32.dll, the string’s memory lay-out becomes apparent, as can be seen below.\n```\nMOV byte ptr [EBP + s_kernel32.dll[0]],0x6b\nMOV byte ptr [EBP + s_kernel32.dll[1]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[2]],0x65\nMOV byte ptr [EBP + s_kernel32.dll[3]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[4]],0x72\nMOV byte ptr [EBP + s_kernel32.dll[5]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[6]],0x6e\nMOV byte ptr [EBP + s_kernel32.dll[7]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[8]],0x65\nMOV byte ptr [EBP + s_kernel32.dll[9]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[10]],0x6c\nMOV byte ptr [EBP + s_kernel32.dll[11]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[12]],0x33\nMOV byte ptr [EBP + s_kernel32.dll[13]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[14]],0x32\nMOV byte ptr [EBP + s_kernel32.dll[15]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[16]],0x2e\nMOV byte ptr [EBP + s_kernel32.dll[17]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[18]],0x64\nMOV byte ptr [EBP + s_kernel32.dll[19]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[20]],0x6c\nMOV byte ptr [EBP + s_kernel32.dll[21]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[22]],0x6c\nMOV byte ptr [EBP + s_kernel32.dll[23]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[24]],0x0\nMOV byte ptr [EBP + s_kernel32.dll[25]],0x0\n\n The generic stack string handling suffices to deal with these kind of (wide) stack strings.\n\n## Stack string example: PlugX\n\n### Talisman is a variant of PlugX, which is a remote access trojan which is generally used by Chinese related actors. This backdoor contains encrypted stack strings, of which the hashes are given below. The samples can be downloaded from Malware Bazaar and MalShare. Note that the referenced sample is dumped from memory, as it is initially encrypted. Details about the Talisman variant can be found in a corporate blog I co-authored.\nMD-5: c6c6162cca729c4da879879b126d27c0\nSHA-1: 80e5fd86127de526be75ef42ebc390fb0d559791\nSHA-256: 344fc6c3211e169593ab1345a5cfa9bcb46a4604fe61ab212c9316c0d72b0865\n\n One of the encrypted stack strings within the sample can be found at the offset of 0x100002401. The assembly instructions at the given offset is given below.\n\n```\n\n-----\n\n```\nMOV dword ptr [ESP + local_cc],0x55615596\nMOV dword ptr [ESP + local_c8],0x5573555e\nMOV dword ptr [ESP + local_c4],0x55615574\nMOV dword ptr [ESP + local_c0],0x55995571\nMOV dword ptr [ESP + local_bc],0x55615578\nMOV dword ptr [ESP + local_b8],0x55785582\nMOV dword ptr [ESP + local_b4],0x55775561\nMOV dword ptr [ESP + local_b0],0x5538553d\nMOV dword ptr [ESP + local_ac],0x551f552d\nMOV dword ptr [ESP + local_a8],0x558d552d\nMOV dword ptr [ESP + local_a4],0x5555553c\nMOV word ptr [ESP + local_a0],0x5555\n\n### The local variable named local_cc is the start of the stack string, where all of the encrypted characters are placed on the stack in order. The code below, as seen in the decompiled code, decrypts the given stack string.\ndo {\n bVar4 = (*(char *)((int)&local_cc + uVar2) + 0x22U ^ 0x33) + 0xbc;\n param_1 = param_1 & 0xffffff00 | (uint)bVar4;\n *(byte *)((int)&local_cc + uVar2) = bVar4;\n uVar2 = uVar2 + 1;\n} while (uVar2 < 0x2e);\n\n The decompiled code is a bit cluttered, but can easily be cleaned up. The variable named uVar2 is the loop’s counter, which can be renamed to i. The line with the reference to param_1 can be omitted, and the local variable bVar4 can be renamed to decryptedByte. Upon doing so, the code is becomes much more readable, as can be seen below.\ndo {\n decryptedByte = (*(char *)((int)&local_cc + i) + 0x22U ^ 0x33) + 0xbc;\n *(byte *)((int)&local_cc + i) = decryptedByte;\n i = i + 1;\n} while (i < 0x2e);\n\n There is, however, a mistake in the decompiled code. The decryption routine seems straight forward: add 0x22, xor with 0x33, and add 0xbc. However, when looking at the assembly instructions, one can easily spot the difference, as can be seen in the code below.\nADD param_1,0x22\nXOR param_1,0x33\nSUB param_1,0x44\n\n The used variable names in the decompiler differ somewhat from the disassembly view, but the param_1 variable in the code above, is the current byte in the loop. The last instruction subtracts 0x44, rather than adding 0xbc. Knowing this, the decryption routine can be re- made, as can be seen below.\n\n```\n\n-----\n\n```\n/\n * Decrypts the string based on the algorithm within the sample (SHA-256\n * 344fc6c3211e169593ab1345a5cfa9bcb46a4604fe61ab212c9316c0d72b0865, offset\n * 0x10002460)\n */\nprivate byte[] decrypt(List<Integer> input) {\n  // Initialise the output variable\n  byte[] output = new byte[input.size()];\n  // Loop over the input and decrypt the given byte\n  for (int i = 0; i < input.size(); i++) {\n    output[i] = (byte) (((input.get(i) + 0x22) ^ 0x33) - 0x44);\n  }\n  // Return the decrypted output\n  return output;\n}\n\n## Writing the Ghidra script\n\n### The script is based on Mich‘s Python based SimpleStackStrings Ghidra script. The script in this article is written in Java, as this is Ghidra’s native way of scripting.\n\n This script will use the currently selected address in Ghidra as a variable, rather than requesting input from the user to provide the address via one of the ask-related functions. The code for which is given below, where currentAddress is inherited from the GhidraScript class.\n\n Next, the script needs to iterate over all instructions that are part of the stack string. The Instruction object has a function which returns the instruction that is directly below it, which is getNext. This function returns null if there is no instruction. As such, a while-loop with the condition that the instruction is not null. The skeleton code is given below.\nwhile(instruction != null) {\n  //TODO: implement the logic\n  instruction = instruction.getNext();\n}\n\n Instructions can contain a value, known as a scalar value. The value can be in the first or second part of the instruction. The code below provides two examples.\nMOV dword ptr [ESP + local_var], 0x41414141\nPUSH 0x41414141\n\n In the first example, the value of 0x41414141 is the second scalar value, which resides at index 1. In the second example, there is no second scalar value, meaning the value resides at index 0.\n\n```\n\n-----\n\n### As such, one can attempt to obtain the second scalar value, using the getScalar(int index) function within the Instruction class, of the current instruction. If there is no such value, null is returned. As such, one can always attempt to fetch the second scalar value.\n\n If the returned value is null, an attempt needs to be made to fetch the first scalar value. If this also returns null, the instruction is not part of the stack string, at least not in a format that this script supports. The code below resembles the logic that is described above.\n```\nScalar scalar = instruction.getScalar(1);\n  if (scalar == null) {\n    scalar = instruction.getScalar(0);\n    if (scalar == null) {\n      println(\"Stack string ended, since no suitable scalar value could be\nfound at 0x\"\n              + Long.toHexString(instruction.getAddress().getOffset())\n+ \"!\");\n      break;\n     }\n  }\n\n Following on that, the scalar’s value needs to be obtained in hexadecimal format. The value then needs to be converted due to the endianness. The code is given below, where the convert function will be described afterwards.\nlong value = scalar.getValue();\nString valueString = Long.toHexString(value);\nvalueBytes.addAll(convert(valueString));\n\n The convert function, which is given below, takes a String as argument, and returns a list of boxed integers. Due to the endianness, the bytes need to be read from right-to-left. A byte is two characters from the string in size. To clarify, the value 0x41414141 consists of four bytes: 0x41 0x41 0x41 0x41. In this case, the string does not contain the leading 0x. To split the string up in bytes that are equal in value to their character counterpart (the value they portray, not their char value).\n\n```\n\n-----\n\n```\nprivate List<Integer> convert(String input) {\n  List<Integer> scalarValue = new ArrayList<>();\n  if (input == null || input.isEmpty()) {\n    return null;\n  }\n  int remainder = input.length() % 2;\n  if (remainder != 0) {\n    input = \"0\" + input;\n  }\n  for (int i = input.length(); i > 0; i = i - 2) {\n    int j = i - 2;\n    if (i == 0 || j < 0) {\n      break;\n    }\n    String b = input.substring(j, i);\n    Integer conversion = Integer.parseInt(b, 16);\n    scalarValue.add(conversion);\n  }\n  return scalarValue;\n}\n\n### If the amount of characters is not even, a leading zero needs to be added to the byte which is missing it, which is the least significant byte. The code responsible to do so is the within the if-body where the value of the remainder is checked.\n\n The decryption function takes a list of integers as input, and returns an array of bytes. The code is given below.\nprivate byte[] decrypt(List<Integer> input) {\n  byte[] output = new byte[input.size()];\n  for (int i = 0; i < input.size(); i++) {\n    output[i] = (byte) (((input.get(i) + 0x22) ^ 0x33) - 0x44);\n  }\n  return output;\n}\n\n In the generic script, which does not handle string decryption, the decrypt function signature is the same, but the body is not. Instead, it simply converts the given list of integers into an unboxed byte array. This leaves the decryption function as a template for future use-cases in the generic script. The code is given below.\nprivate byte[] decrypt(List<Integer> input) {\n  byte[] output = new byte[input.size()];\n  for (int i = 0; i < input.size(); i++) {\n    output[i] = input.get(i).byteValue();\n  }\n  return output;\n}\n\n```\n\n-----\n\n### At last, the returned unboxed byte array is converted into multiple strings, all of which are based on a different character set. Since the character set is unknown to the script itself, numerous types are included. The analyst can then easily see which of the strings are garbage, and which is the correct string. The strings are then printed, together with some identifying information with regards to the character set. Additionally, the amount of bytes of the stack string is printed. This helps when changing the data type into an array of (wide) characters, where one knows the number of characters that is required for the string.\n```\nString usAscii = new String(output, StandardCharsets.US_ASCII);\nString isoLatin1 = new String(output, StandardCharsets.ISO_8859_1);\nString utf16be = new String(output, StandardCharsets.UTF_16BE);\nString utf16le = new String(output, StandardCharsets.UTF_16LE);\nString utf8 = new String(output, StandardCharsets.UTF_8);\nprintln(\"------------------------------------------------------------------------------\");\nprintln(\"US-ASCII: \" + usAscii);\nprintln(\"ISO-LATIN-1: \" + isoLatin1);\nprintln(\"UTF-16BE: \" + utf16be);\nprintln(\"UTF-16LE: \" + utf16le);\nprintln(\"UTF-8: \" + utf8);\nprintln(\"Length in bytes: \" + output.length);\nprintln(\"------------------------------------------------------------------------------\");\n\n Do note that if the stack string consists of multiple strings before an invalid instruction is hit, all of them are shown at once. The analyst can see which string is what size, and rename and retype the variables accordingly. The following screenshots include such a case.\n\n When viewing this in Ghidra’s console, it is apparent that some spaces that should be there, are not properly shown in the console. Note that this might not be the case in future Ghidra versions.\n\n The images below show the output of Ghidra’s console, for one stack string from both CaddyWiper and PlugX Talisman respectively\n\n```\n\n-----\n\n### The script’s output in Ghidra’s console\n\n The script’s decrypted output in Ghidra’s console When viewing the same stack strings in Eclipse’s console, the missing spaces are clearly visible, which is a clear indication that some of the stack strings are wide strings, whereas others are not.\n\n The script’s output in Eclipse’s console\n\n The script’s decrypted output in Eclipse’s console\n\n## Conclusion\n\n\n-----\n\n### To conclude, the usage of encrypted stack strings is an efficient way to evade more generic detection, but does not slow analysis down much. The automation to swiftly see what the string is by selecting the string’s start in the assembly view, whose decrypted value is then printed when the script is executed via a hotkey takes very little time.\n\n Recreating the decryption routine might consume some time, but in most cases, encrypted stack strings are generally decrypted using the same routine within a single sample. As such, the time to recreate the decryption routine is likely to end up saving time overall.\n\n## Complete script\n\n### The complete script to handle encrypted (wide) stack strings is given below. The generic stack strings script is given first, after which the PlugX Talisman script is given.\n\n\n-----\n\n```\n//A script to recreate (wide) stack strings in PlugX Talisman samples, based on\nMich's SimpleStackStrings\n(https://github.com/0x6d696368/ghidra_scripts/blob/master/SimpleStackStrings.py)\n//@author Max 'Libra' Kersten\n//@category deobfuscation\n//@keybinding\n//@menupath\n//@toolbar\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.listing.Instruction;\nimport ghidra.program.model.scalar.Scalar;\npublic class StackStrings extends GhidraScript {\n  @Override\n  protected void run() throws Exception {\n    // Get the starting instruction\n    Instruction instruction = getInstructionAt(currentAddress);\n    // Check if there is an instruction at the current location\n    if (instruction == null) {\n      // Print the error message\n      println(\"No instruction found at 0x\" +\nLong.toHexString(currentAddress.getOffset()));\n      // Return, thus ending the execution of the script\n      return;\n    }\n    // If an instruction is found, print the starting offset\n    println(\"Stack string starting at 0x\" +\nLong.toHexString(currentAddress.getOffset()));\n    // Initialise the list to store the stack string bytes in\n    List<Integer> valueBytes = new ArrayList<>();\n    /*\n     * Loop over the current instructions (and the ones thereafter) until no\n     * instruction is found, or the loop is broken\n     */\n    while (instruction != null) {\n      /*\n       * Get the second scalar value from the instruction. When encountering\n       * instructions such as \"MOV dword ptr [ESP + local_var], 0x41414141\",\nthe\n       * second scalar value is the second value.\n       */\n      Scalar scalar = instruction.getScalar(1);\n      // If the second scalar value is null, revert to the value of the first\nscalar\n\n```\n\n-----\n\n```\n      if (scalar  null) {\n        /*\n         * Store the first scalar value, which is present instructions such\nas\n         * \"PUSH 0x41414141\"\n         */\n        scalar = instruction.getScalar(0);\n        /*\n         * If there is no scalar value, the encountered instruction is not\npart of the\n         * (wide) stack string\n         */\n        if (scalar == null) {\n          /*\n           * Print the error, along with the address of the instruction\nwhich contains no\n           * suitable scalar value\n           */\n          println(\"Stack string ended, since no suitable scalar value could\nbe found at 0x\"\n              + Long.toHexString(instruction.getAddress().getOffset())\n+ \"!\");\n          // Break the loop, continuing the decryption and string recreation process\n          break;\n        }\n      }\n      // Get the scalar's value\n      long value = scalar.getValue();\n      // Get the value in hexadecimal format\n      String valueString = Long.toHexString(value);\n      // Add all the bytes to the list once they are converted\n      valueBytes.addAll(convert(valueString));\n      // Gets the next instruction\n      instruction = instruction.getNext();\n    }\n    /*\n     * Decrypt the collected bytes. If no decryption is required when re-using\nthis\n     * script, simply convert the list of bytes into an unboxed byte array, after\n     * which the existing logic will handle the rest\n     */\n    byte[] output = decrypt(valueBytes);\n    /*\n     * Create a variety of strings, based on the given bytes. If multiple stack\n     * strings are present in sequence, it is possible that the strings represent\n     * more than a single stack string. This is left to the analyst's\n     * interpretation.\n     * \n     * To make the script more generic, the strings are recreated using a variety\n\n```\n\n-----\n\n```\nof\n     * character sets. Some stack strings might consist of wide strings, whereas\n     * others might be of a more unique format. Generally, the common formats\nsuch\n     * as UTF-8 and UTF-16 will be used, as the Windows API uses those.\n     */\n    String usAscii = new String(output, StandardCharsets.US_ASCII);\n    String isoLatin1 = new String(output, StandardCharsets.ISO_8859_1);\n    String utf16be = new String(output, StandardCharsets.UTF_16BE);\n    String utf16le = new String(output, StandardCharsets.UTF_16LE);\n    String utf8 = new String(output, StandardCharsets.UTF_8);\n    // Print all of the stack strings\n    println(\"------------------------------------------------------------------------------\");\n    println(\"US-ASCII: \" + usAscii);\n    println(\"ISO-LATIN-1: \" + isoLatin1);\n    println(\"UTF-16BE: \" + utf16be);\n    println(\"UTF-16LE: \" + utf16le);\n    println(\"UTF-8: \" + utf8);\n    println(\"Length in bytes: \" + output.length);\n    println(\"------------------------------------------------------------------------------\");\n  }\n  /**\n   * Converts the given input string to a list of bytes. The input string should\n   * be equal to hexadecimal values, without the leading \"0x\".\n   * \n   * @param input a string which contains the hexadecimal values, without the\n   *       leading \"0x\"\n   * @return a list of bytes, read as little endian (right from left, per byte)\n   */\n  private List<Integer> convert(String input) {\n    // Initialise the list of bytes\n    List<Integer> scalarValue = new ArrayList<>();\n    // If the input is null, or empty, null is returned\n    if (input == null || input.isEmpty()) {\n      return null;\n    }\n    // Check if the length input is a multitude of two\n    int remainder = input.length() % 2;\n    /*\n     * If the length of the string is not equal to one, add a leading zero to the\n     * last character\n     */\n    if (remainder != 0) {\n      int offset = input.length() - 1;\n      String partA = input.substring(0, offset);\n\n```\n\n-----\n\n```\n      String partB input.substring(offset, offset + 1);\n      input = partA + \"0\" + partB;\n    }\n    /*\n     * Iterate over the string in groups of two characters at a time, which\n     * represents a single byte every time. The string is iterated over starting\nin\n     * the end, due to the endianness\n     */\n    for (int i = input.length(); i > 0; i = i - 2) {\n      int j = i - 2;\n      // If i is zero or j is less than zero, the loop has to be broken\n      if (i == 0 || j < 0) {\n        break;\n      }\n      // Obtain the byte in string form\n      String b = input.substring(j, i);\n      // Convert the byte in string form to a boxed byte object\n      Integer conversion = Integer.parseInt(b, 16);\n      // Add the byte to the list of bytes, in sequential order\n      scalarValue.add(conversion);\n    }\n    // Return the obtained bytes\n    return scalarValue;\n  }\n  /*\n   * A function to hold the decryption routine for the given sample, if any\n   */\n  private byte[] decrypt(List<Integer> input) {\n    // Initialise the output variable\n    byte[] output = new byte[input.size()];\n    // Loop over the input and convert the given byte\n    for (int i = 0; i < input.size(); i++) {\n      output[i] = input.get(i).byteValue();\n    }\n    // Return the converted output\n    return output;\n  }\n}\n\n### The PlugX Talisman stack string decryption script is given below in full.\n\n```\n\n-----\n\n```\n//A script to recreate (wide) stack strings in PlugX Talisman variant, based on\nMich's SimpleStackStrings\n(https://github.com/0x6d696368/ghidra_scripts/blob/master/SimpleStackStrings.py)\n//@author Max 'Libra' Kersten (@Libranalysis, https://maxkersten.nl)\n//@category deobfuscation\n//@keybinding\n//@menupath\n//@toolbar\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.listing.Instruction;\nimport ghidra.program.model.scalar.Scalar;\npublic class TalismanStackStringDecryption extends GhidraScript {\n  @Override\n  protected void run() throws Exception {\n    // Get the starting instruction\n    Instruction instruction = getInstructionAt(currentAddress);\n    // Check if there is an instruction at the current location\n    if (instruction == null) {\n      // Print the error message\n      println(\"No instruction found at 0x\" +\nLong.toHexString(currentAddress.getOffset()));\n      // Return, thus ending the execution of the script\n      return;\n    }\n    // If an instruction is found, print the starting offset\n    println(\"Stack string starting at 0x\" +\nLong.toHexString(currentAddress.getOffset()));\n    // Initialise the list to store the stack string bytes in\n    List<Integer> valueBytes = new ArrayList<>();\n    /*\n     * Loop over the current instructions (and the ones thereafter) until no\n     * instruction is found, or the loop is broken\n     */\n    while (instruction != null) {\n      /*\n       * Get the second scalar value from the instruction. When encountering\n       * instructions such as \"MOV dword ptr [ESP + local_var], 0x41414141\",\nthe\n       * second scalar value is the second value.\n       */\n      Scalar scalar = instruction.getScalar(1);\n      // If the second scalar value is null, revert to the value of the first\nscalar\n\n```\n\n-----\n\n```\n      if (scalar  null) {\n        /*\n         * Store the first scalar value, which is present instructions such\nas\n         * \"PUSH 0x41414141\"\n         */\n        scalar = instruction.getScalar(0);\n        /*\n         * If there is no scalar value, the encountered instruction is not\npart of the\n         * (wide) stack string\n         */\n        if (scalar == null) {\n          /*\n           * Print the error, along with the address of the instruction\nwhich contains no\n           * suitable scalar value\n           */\n          println(\"Stack string ended, since no suitable scalar value could\nbe found at 0x\"\n              + Long.toHexString(instruction.getAddress().getOffset())\n+ \"!\");\n          // Break the loop, continuing the decryption and string recreation process\n          break;\n        }\n      }\n      // Get the scalar's value\n      long value = scalar.getValue();\n      // Get the value in hexadecimal format\n      String valueString = Long.toHexString(value);\n      // Add all the bytes to the list once they are converted\n      valueBytes.addAll(convert(valueString));\n      // Gets the next instruction\n      instruction = instruction.getNext();\n    }\n    /*\n     * Decrypt the collected bytes. If no decryption is required when re-using\nthis\n     * script, simply convert the list of bytes into an unboxed byte array, after\n     * which the existing logic will handle the rest\n     */\n    byte[] output = decrypt(valueBytes);\n    /*\n     * Create a variety of strings, based on the given bytes. If multiple stack\n     * strings are present in sequence, it is possible that the strings represent\n     * more than a single stack string. This is left to the analyst's\n     * interpretation.\n     * \n     * To make the script more generic, the strings are recreated using a variety\n\n```\n\n-----\n\n```\nof\n     * character sets. Some stack strings might consist of wide strings, whereas\n     * others might be of a more unique format. Generally, the common formats\nsuch\n     * as UTF-8 and UTF-16 will be used, as the Windows API uses those.\n     */\n    String usAscii = new String(output, StandardCharsets.US_ASCII);\n    String isoLatin1 = new String(output, StandardCharsets.ISO_8859_1);\n    String utf16be = new String(output, StandardCharsets.UTF_16BE);\n    String utf16le = new String(output, StandardCharsets.UTF_16LE);\n    String utf8 = new String(output, StandardCharsets.UTF_8);\n    // Print all of the stack strings\n    println(\"------------------------------------------------------------------------------\");\n    println(\"US-ASCII: \" + usAscii);\n    println(\"ISO-LATIN-1: \" + isoLatin1);\n    println(\"UTF-16BE: \" + utf16be);\n    println(\"UTF-16LE: \" + utf16le);\n    println(\"UTF-8: \" + utf8);\n    println(\"Length in bytes: \" + output.length);\n    println(\"------------------------------------------------------------------------------\");\n  }\n  /**\n   * Converts the given input string to a list of bytes. The input string should\n   * be equal to hexadecimal values, without the leading \"0x\".\n   * \n   * @param input a string which contains the hexadecimal values, without the\n   *       leading \"0x\"\n   * @return a list of bytes, read as little endian (right from left, per byte)\n   */\n  private List<Integer> convert(String input) {\n    // Initialise the list of bytes\n    List<Integer> scalarValue = new ArrayList<>();\n    // If the input is null, or empty, null is returned\n    if (input == null || input.isEmpty()) {\n      return null;\n    }\n    // Check if the length input is a multitude of two\n    int remainder = input.length() % 2;\n    /*\n     * If the length of the string is not equal to one, add a leading zero to the\n     * last character\n     */\n    if (remainder != 0) {\n      input = \"0\" + input;\n    }\n\n```\n\n-----\n\n```\n    /*\n     * Iterate over the string in groups of two characters at a time, which\n     * represents a single byte every time. The string is iterated over starting\nin\n     * the end, due to the endianness\n     */\n    for (int i = input.length(); i > 0; i = i - 2) {\n      int j = i - 2;\n      // If i is zero or j is less than zero, the loop has to be broken\n      if (i == 0 || j < 0) {\n        break;\n      }\n      // Obtain the byte in string form\n      String b = input.substring(j, i);\n      // Convert the byte in string form to a boxed integer object\n      Integer conversion = Integer.parseInt(b, 16);\n      // Add the byte to the list of bytes, in sequential order\n      scalarValue.add(conversion);\n    }\n    // Return the obtained bytes\n    return scalarValue;\n  }\n  /*\n   * Decrypts the string based on the algorithm within the sample (SHA-256\n   * 344fc6c3211e169593ab1345a5cfa9bcb46a4604fe61ab212c9316c0d72b0865, offset\n   * 0x10002460)\n   */\n  private byte[] decrypt(List<Integer> input) {\n    // Initialise the output variable\n    byte[] output = new byte[input.size()];\n    // Loop over the input and decrypt the given byte\n    for (int i = 0; i < input.size(); i++) {\n      output[i] = (byte) (((input.get(i) + 0x22) ^ 0x33) - 0x44);\n    }\n    // Return the decrypted output\n    return output;\n  }\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-12 - Ghidra script to handle stack strings.pdf"
    ],
    "report_names": [
        "2022-04-12 - Ghidra script to handle stack strings.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535952,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653709890,
    "ts_modification_date": 1653709890,
    "files": {
        "pdf": "https://archive.orkl.eu/b2345a07fe7c5ec975b84d7467fe327b98c52f61.pdf",
        "text": "https://archive.orkl.eu/b2345a07fe7c5ec975b84d7467fe327b98c52f61.txt",
        "img": "https://archive.orkl.eu/b2345a07fe7c5ec975b84d7467fe327b98c52f61.jpg"
    }
}