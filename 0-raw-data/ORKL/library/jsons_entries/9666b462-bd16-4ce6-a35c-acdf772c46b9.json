{
    "id": "9666b462-bd16-4ce6-a35c-acdf772c46b9",
    "created_at": "2023-01-12T15:03:03.937589Z",
    "updated_at": "2025-03-27T02:05:47.227113Z",
    "deleted_at": null,
    "sha1_hash": "a3087b636b82b81648ce24970ef4a1447164e8a4",
    "title": "2017-03-09 - Spora Ransomware- Understanding the HTA Infection Vector",
    "authors": "",
    "file_creation_date": "2022-05-27T23:25:28Z",
    "file_modification_date": "2022-05-27T23:25:28Z",
    "file_size": 227996,
    "plain_text": "# Spora Ransomware: Understanding the HTA Infection Vector\n\n**[linkedin.com/pulse/spora-ransomware-understanding-hta-infection-vector-kevin-douglas](https://www.linkedin.com/pulse/spora-ransomware-understanding-hta-infection-vector-kevin-douglas)**\n\nKevin Douglas\n\n[Kevin Douglas](https://www.linkedin.com/in/kdcybersec?trk=pulse-article_main-author-card)\n\n### Kevin Douglas\n\n**Technical Director at Tenable**\n\nPublished Mar 9, 2017\n\n[+ Follow](https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_main-author-card__cta-button)\n\n## ABSTRACT\n\nRecently, the [MalwareHunterTeam announced the discovery of new ransomware. This](http://id-ransomware.malwarehunterteam.com/index.php)\nransomware, Spora, is one of the most sophisticated examples seen to date. According to\n[BleepingComputer, Spora has “top notch encryption”, “has the most sophisticated payment](http://www.bleepingcomputer.com/news/security/spora-ransomware-works-offline-has-the-most-sophisticated-payment-site-as-of-yet/)\n_site as of yet” and a “professional decryption service”. Even its infection vector demonstrates_\na level of sophistication above and beyond its predecessors.\n\nOne of Spora's infection vectors is via an HTA email attachment. During the infection, no\nadditional network communication is needed – this malware dropper is completely selfcontained The HTA contains an embedded copy of Spora that is decrypted and installed on\n\n\n-----\n\nthe victim machine as the attachment is opened. If you have the attachment, you already\nhave Spora – network connection, or not.\n\nThis is the perfect opportunity for us to learn about HTA-based malware droppers. Lets take\na look at the Spora infection vector to learn why the authors chose HTA…\n\n## BACKGROUND\n\nMost of us are already familiar with typical infection vectors from droppers that leverage\nMicrosoft Office files, PDF documents, Flash files, etc. Spora has chosen to use HTA as the\n[malware dropper. Interesting choice… So, what is HTA?](http://technet.microsoft.com/en-us/library/ee692768.aspx)\n\nHTA stands for HTML Application. It is a technology that Microsoft created to allow graphical\nuser interfaces to be bundled directly with script logic. Scripting languages such as VBScript\ndo not have any native GUI capabilities. HTA leverages Internet Explorer to provide scripts\nwith a graphical interface. Even though they leverage Internet Explorer, they run outside of\nthe browser via MSHTA.exe. This means that they are free from the normal security\nrestrictions placed on scripts that run inside a web browser.\n\nTo illustrate, an existing HTML file can be renamed to an .hta extension and it would yield a\nworking example of HTA. The only difference being, the document would open via\nMSHTA.exe rather than a web browser.\n\n“ HTAs, by contrast, are not bound by the same security restrictions as Internet\n_Explorer; that’s because HTAs run in a different process than Internet Explorer. (HTAs_\n_run in the Mshta.exe process rather than the Iexplore.exe process.) Unlike HTML_\n_pages, HTAs can run client-side scripts and they have access to the file_\n_system. Among other things, this means that HTAs can run your system administration_\n_scripts, including those that use WMI and ADSI. Your scripts will run just fine, and you_\n_won’t receive any warnings about items that might be unsafe.” –_ [Microsoft TechNet](http://technet.microsoft.com/en-us/library/ee692768.aspx)\n\nFor a malware author targeting Microsoft Windows victims, HTA seems like a reasonable\nchoice. Its simple, it can (“among other things”) access the file system, and it is a preinstalled capability in Windows.\n\nNow, lets take a deep dive into how the authors of Spora leveraged HTA for their infection…\n\n## ANALYZING THE INFECTION VECTOR\n\n### OVERVIEW\n\nThe Spora infection begins as an HTA file.\n\n\n-----\n\n[Like many other malware droppers, it is reported that the Spora HTA file is initially delivered](http://www.virustotal.com/en/file/3fb2e50764dea9266ca8c20681a0e0bf60feaa34a52699cf2cf0c07d96a22553/analysis/1484122829/)\nto its target via an email attachment. The delivery mechanism doesn’t matter so much, as\nlong as the HTA file reaches a victim and the victim is likely to click on it.\n\nSpora disguises the HTA file name such that it includes two file extensions (e.g.,\n_<filename>.doc.hta). This is most likely an attempt by the malware author to hide the actual_\n.hta file extension from the victim. On Windows machines that are configured to hide file\nextensions, the actual file extension (.hta) would be hidden from the user, leaving only the\nfake file extension displayed (e.g., <filename>.doc appears rather than\n_<filename>.doc.hta). The intent is to deceive users into clicking on the file, thinking that they_\nare opening a Word document rather than the HTA file.\n\nOnce the HTA file is opened, the infection occurs through a series of five distinct stages as\nshown below. In stage one, the HTA dropper writes an embedded payload to a JScript file\n**(%temp%/close.js) and runs it. This JScript file contains the entire payload necessary for**\neach of the subsequent stages.\n\nStages two, three and four each decode an embedded JavaScript payload and run it. Stage\n[two is distinct in that it relies heavily on anonymous self-invoking functions as a form of](http://www.w3schools.com/js/js_function_definition.asp)\nobfuscation. Stage three is distinct in that it uses a custom decode logic to decode its\npayload prior to running it. Stage four is the most complex, leveraging AES encryption via\nCryptoJS to decode the final payload to run. Stage five runs the final JavaScript payload in\norder to create a Word Document (doc_6d518e.docx) and install/drop the Spora malware\n(81063163ded.exe). Stage five then opens the Word document and starts the Spora\nmalware.\n\nThe Word document serves no purpose other than to distract the victim from noticing that\nSpora was installed. When the victim sees a Word document opened from an email\nattachment with a .doc extension, he/she is more likely to think that nothing is\nwrong. Actually though… the infection is done. Spora is now encrypting precious files on the\nvictim’s hard drive and holding them for ransom.\n\nLets walk through this logic in detail to see how each of these stages work…\n\n### Stage 1: Create close.js and Run It\n\nIn the first stage of the infection, Spora uses an HTA file as a container for each component\nused during the infection process. As shown below, this infected HTA file is a simple file with\na single purpose - to write its embedded payload to a JavaScript file and run it.\n\nIn the first step of this stage, a JavaScript file (close.js) is created in the %TEMP% folder. As\nshown below, WScript.Shell and Scripting.FileSystemObject objects as are used to create\nthis file. Leveraging these components is a fairly common technique used by malware\ndroppers to gain read/write access to the local file system.\n\n\n-----\n\nThe next step is to write the infection payload to this file. As highlighted below, a payload is\nwritten to the file using the Scripting.FileSystemObject object. The highlighted payload was\nabbreviated in the screen shot for conciseness and readability. The actual payload is much\nlarger than what is shown.\n\nOnce the payload has been written to the file, the file is closed and then run using the\n**_WScript.Shell component. Highlighted below, we can see that %temp%\\close.js is being_**\nexecuted.\n\nThe first stage of the infection is now completed. As the victim opened the HTA email\nattachment, the embedded JavaScript payload has been extracted from the HTA file, written\nto a JScript dropper and started.\n\nIn stage two, lets see what was in the payload and step through what it does…\n\n### Stage 2: Decode JavaScript Payload and Run It\n\nThe screen shot below shows the partial content of the payload extracted during stage one\nand written to close.js. The beginning of the file appears to contain JavaScript. However,\nmuch of the file appears to be something other than JavaScript. Our hunch is that this is an\nadditional payload. Most likely, the JavaScript that we see is merely a thin wrapper that\ndecodes the payload and launches it.\n\nThis file is obviously formatted as ugly as possible by the author in an attempt to make it less\nreadable. Reading and understanding this file in its current form is a challenge. We will need\nto reformat it (add white-spacing, etc.) in order to be able to make any sense of it.\n\nAfter beautifying the code as shown below, we can start to see two distinct parts to the\nfile. The first part is obviously JavaScript. Most likely the Gr() function starting on line 5 is\ndecode logic. The second part, starting at line 28, appears to be payloads that are passed\ninto the Gr() and qP() functions.\n\nSo, lets abbreviate some of the payloads to allow us to get a better overall picture of the logic\nwithout being confused by the payload values themselves. Shown below, we can start to see\nthat many payloads are passed into the suspected Gr() decode function.\n\nLooking at the definition of qP highlighted below, we see that it is simply assigned to the\nJavaScript Function constructor. This is simply a form of obfuscation where the malware\nauthor is trying to hide each time Function is called by reassigning it to the qP variable. In\nother words, if the code invokes qP(), the net effect is that Function() is called. We will see\nthis in practice shortly…\n\nBased on our discovery above, lets replace all qP() references with Function() to make the\ncode more readable. Shown below is the resulting cleansed code.\n\n\n-----\n\nSo, is the Gr() function really a decode loop?\n\nLooking at the highlighted logic shown below, we can see that the variable x that is passed\ninto Gr(), is iterated over, its values are altered using some basic math formulas resulting in a\nnew value (variable b). The new array of values is joined back together into a string and\nreturned. Long story short, this is definitely a decode loop.\n\nBased on our analysis above, lets rename all the Gr() references to Decode() to make things\nmore readable as shown below.\n\nThe next thing to decipher is the (function() { … })() syntax highlighted in the abbreviated\n[screen shot below. This syntax indicates a JavaScript anonymous self-invoking function. The](http://www.w3schools.com/js/js_function_definition.asp)\nfunction is anonymous because it has no name specified. The function is self-invoking\nbecause it is wrapped in parenthesis and followed by a pair of parenthesis. Long story short,\nthis syntax makes it an anonymous self-invoking function, meaning it will automatically\ninvoke at startup without explicitly being called.\n\nNow that we know how to identify an anonymous self-invoking function, we can easily spot a\nsecond one as highlighted below. As close.js is started, the outermost self-invoking function\nshown above will automatically run. As it runs, this innermost self-invoking function shown\nbelow will automatically start.\n\nAs we look at the function shown above, we can see a difference between the innermost and\nthe outermost function syntax. The innermost function highlighted above is\n[capitalized. Why? This is an example of invoking a function constructor. The JavaScript](http://www.w3schools.com/js/js_function_definition.asp)\nfunction constructor allows a function to be defined and invoked in the same line of code.\n\nThe syntax for defining and invoking a function constructor is Function(arg1, arg2, argn,\n**_codeblock). The last argument passed into the Function constructor is the code block for the_**\nfunction itself. This means that the highlighted section of code below is the code block for\nthis innermost self-invoking function on line 28.\n\nSo far, we know that as close.js starts, it self-invokes the outermost function on line 2. It\nthen self-invokes the innermost function on line 28. The innermost function is a function\nconstructor, which means that the highlighted section of code is ultimately the code that\nautomatically runs at startup time. After the highlighted section of code finishes running, its\noutput becomes the code block argument to the innermost function as it starts.\n\nWe’re getting closer…\n\nLooking at the code highlighted above, we can see, similar to line 28, it is a function\nconstructor. This means that the highlighted section of code below represents its code block\n(since it is the last argument passed into the function constructor).\n\n\n-----\n\nIf the above highlighted line of code is the code block for the function constructor, then what\nis this similar looking section of code highlighted below? These are the arguments passed\ninto the code block highlighted above. If we decode the code block above, we should see\nlogic that references the arguments highlighted below.\n\nTime to decode the code block and see what this stage of infection actually does…\n\nIf we use the Decode()/Gr() logic shown earlier to decode the first payload, we can see the\ncode block as shown below. As we suspected, we can see references to inbound arguments\nin lines 11 and 12. The logic appears to iterate over each of the bytes in each of the\narguments, alter them with some basic math formulas and join the results back together.\n\nSound familiar? Yes, it’s another decode loop.\n\nBased on our understanding of the logic above, it appears to decode each argument passed\ninto it. Looking at the highlighted line below, we can see there are twenty-one arguments\npassed into this decode loop. These arguments are first decoded via the Decode()/Gr()\nfunction discussed earlier and then further decoded with this new decode loop shown\nabove.\n\nUltimately, this dual-decoded array of payloads shown below is the infection code that is run\nat the end of this stage.\n\nThis stage of the infection began with a series of nested self-invoking functions, which\nautomatically ran at startup time (innermost first, followed by the outermost). The innermost\nself-invoking function dynamically built and ran a function constructor. The code block for this\nfunction constructor was the result of decoding an embedded payload from\n**_close.js. Ironically, this code block turned out to be second decoding loop._**\n\nAs this function constructor ran, the second decode loop was passed twenty-one decoded\npayload chunks from close.js as arguments. The second decode loop decoded them once\nmore, resulting in the final payload to be run by the innermost self-invoking function.\n\nWe are getting closer. Lets take a look at what this new JavaScript payload does…\n\n### Stage 3: Decode JavaScript Payload and Run It\n\nIt looks like our analysis was correct. The resulting payload that was run at the end of stage\ntwo shown below is obviously JavaScript. The good news is that this stage appears to be\nfairly simple. There appears to be a payload, a decode loop and an eval() statement to\nlaunch the payload once it has been decoded.\n\n\n-----\n\nThe highlighted section shown below (abbreviated in the display for readability) appears to\nbe a payload along with some JavaScript function names (e.g., fromCharCode). Our hunch\nis that this payload will be decoded. The decoder will most likely reference the JavaScript\nfunctions in lines 4-6 in order to obfuscate the logic and avoid detection.\n\nSo, why do we think this is a decode loop?\n\nThe first hint is that the eval() statement at line 39 launches the results from our suspected\ndecode function 0x1c508(). This means that whatever is returned from 0x1c508() must be\nrunnable JavaScript. Otherwise, the eval() function would be useless.\n\nThe second hint is that the 0x1c508() function is littered with references to our payload\nvariable _0x1C4F5[]. It references both the suspected JavaScript payload section of\n**__0x1C4F5[] as well as the other artifacts (e.g., JavaScript function names). This is more_**\nevidence that this function most likely decodes a portion of the payload and uses the\nJavaScript references in the payload as part of this decode logic.\n\nThe third hint is that line 36 returns the variable _0x1C554. This variable is built inside a loop\nin lines 31-34. If the variable is built inside a loop, returned as the result of this function, and\nhas to be JavaScript (since the return value is passed into eval()), then this is definitely a\ndecode loop.\n\nAs compared to stage two, this stage of the infection was relatively simple. This stage\ncontained a payload, which was comprised of encoded JavaScript and JavaScript function\nnames. The decode logic was obfuscated through the use of these JavaScript function\nnames rather than invoking them directly. Once decoded, the payload was launched via the\n**_eval() function._**\n\nIts time to decode this payload to see if our analysis is correct so far…\n\n### Stage 4: Decode Final Payload and Run It\n\nThe payload decoded in stage 3 is definitely JavaScript as shown in the output below.\n\nSimilar to the previous stage, we can see an obvious payload at lines 2-3 and an eval()\nfunction at line 40 which will be used to run the payload. However, this time we don’t see a\ndecode loop. We do notice several references on lines 9 and 16 to CryptoJS, which is a\ncryptography package for JavaScript. Could CryptoJS be used to decode the payload rather\nthan our previously seen decode loop techniques?\n\nLets dig deeper to find out…\n\nOur suspected payload is highlighted in the screen shot below. This payload was\nabbreviated for conciseness and readability.\n\n\n-----\n\nExpanding the payload display as shown below gives us a better idea of the size of the\npayload contained in this infection stage. The payload is actually an array of hex encoded\nvalues (many separate payloads in a comma separated list). Since it is an array of payloads,\neach payload element in the list may be used for different purposes at different times during\nthis infection stage.\n\nPlease note that this is still only a representative clip of the overall payload.\n\nLooking at the highlighted section of the payload array shown above, the hexadecimal values\nfall within the printable character set range (e.g., 0x20 – 0x7E). We can easily convert them\nfrom hexadecimal to ASCII to gain a better understanding of the payload. Maybe its simply\nhexadecimal encoded JavaScript?\n\nConverting portions of the payload array yields some interesting results as shown below. Its\nnot JavaScript, but, its definitely interesting.\n\nLooking at the results above, we can see references to cryptography (e.g., AES,\nBlockCipher, encryptBlock, decryptBlock, OpenSSL, etc.). We can see references to\nADODB.stream, which is typically used by droppers to write malware to disk. We can see\nreferences to WScript.shell, which is typically used by droppers to run malware after its been\ninstalled on disk. We can also see references to what appears to be a Word document name\n(e.g., MP%\\doc_6d518e.docx).\n\nUsing the list of decoded hexadecimal values above, we can layer the actual values into the\noriginal code as shown below to gain more insight into the intent of this infection stage. In the\ncode below, references to the original payload (e.g., _0xee6f[]) were replaced with their\nhexadecimal decoded values. In some cases, lines of code that were performing simple\nstring concatenations were collapsed together to simplify the code shown.\n\nWe can now see a clearer picture of the infection. Analyzing the code, we see an obvious\npayload that appears to be decrypted via CryptoJS using AES in line 7 below. We can also\nsee the crypto key as shown (1C1614D7). Further analyzing the code, we can now see\nreferences in lines 13 and 14 to a Word Document (%TEMP%\\doc_6d518e.docx) and an\nEXE file (%TEMP%\\81063163ded.exe).\n\nWe are getting extremely close to the final stage of the infection. Lets push onward…\n\nThe payload shown above is UTF8 encoded and stored in the variable v998c9 as shown in\nline 15 below.\n\nThis AES decrypted payload is then run in line 40 shown below using the eval()\nfunction. This is the payload we need to see decoded. It appears to be the final stage of the\ninfection.\n\n\n-----\n\nIn this stage, we see a payload with sections of it that decode to reveal references to AES\ncryptography. We also see signs of well-known techniques used by droppers to write to disk\nand run/start files. We see references to a Word document and we see a reference to an\nEXE. We see a payload that is AES decrypted and ultimately run via an eval() function.\n\nLets decode the payload that is run in line 40 above and reveal the mystery…\n\n### Stage 5: Spora infection completes\n\nThe full decode of the JavaScript payload from stage four is shown below. There is a big\ndifference between the JavaScript in this stage and the previous stages. Each of the\nprevious stages were heavily obfuscated and focused on decoding payloads and running\nthem. This code is straightforward. It opens two files, writes data to each one, saves them to\ndisk, closes them and then runs them. Our hunch is that one of these files is the Word\ndocument and the other is the EXE referenced in stage four.\n\nLets take a look and see if we are correct…\n\nIn line 4 shown below, the contents of the variable v09bc6 are written to disk. If we reference\nthe cleansed code from stage four, we can see that v09bc6 contains the data bytes for the\nEXE file (%TEMP%\\81063163ded.exe).\n\nThe v3462e variable is pointing to a reference of Adodb.Stream. This means that the\nhighlighted line below is equivalent to Adodb.Stream.Write(v09cb6). As we suspected in\nstage four, Adodb.Stream is used by this infection to access and write to the local file\nsystem.\n\nOnce the data has been written, the file is saved to disk as shown below. Referencing the\ncleansed code in stage four, we can see that the v759c1 variable is set to\n**_%TEMP%\\81063163ded.exe in line 14 of the code. As the result, this line of code is used to_**\ncreate an EXE on the local file system.\n\nThis is the code that actually dropped the Spora malware to disk!! Without this line of code,\nno infection would occur.\n\nNow that Spora exists on disk, it needs to be started. The code shown below is the code that\nactually runs Spora.\n\nThe vefa30 variable is set to the same value as v759c1 in line 16 in the cleansed code from\nstage four. Both variables point to the file name %TEMP%\\81063163ded.exe. It may be\nconfusing that the variables are different in the above and below code fragments. Most likely,\nit is either due to poor programming style, or, intentional obfuscation.\n\nSimilar to the steps above, another file is created as shown below. This time, it is the Word\ndocument being created and saved.\n\n\n-----\n\nShown below is where the Word document is actually saved to disk. Referencing the cleanse\ncode from stage four, we can see that the v365ec variable is set to\n**_%TEMP%\\doc_6d518e.docx in line 13 of the code._**\n\nThe Word document is opened/run via the highlighted code shown below. Unlike the EXE\nexample above, the same variable v365ec was used in the SaveToFile and the Run logic.\n\n## CONCLUSION\n\nThe Spora infection vector using an HTA-based email attachment was more sophisticated\nand complex than what is seen in the typical malware dropper. Typically, a dropper may\nleverage several stages of payload decodes prior to ultimately dropping and running the\nmalware. Each of these stages would typically rely on simple hex encoding of the payload\ncombined with some lightweight custom decoding logic.\n\nSpora took infection vector obfuscation to a new level. Rather than one or two stages, Spora\nused five distinct stages to infect the victim. These stages leveraged hex encoded payloads,\ncustom encoded payloads and AES encrypted payloads. The infection vector transitioned\nfrom its initial HTA-based VBScript file to creating and running a Jscript file to complete the\ninfection. The decode loops themselves were obfuscated to leverage JavaScript function\nnames pulled directly from the payload rather than naming them directly. The dropper code\nleveraged esoteric capabilities of JavaScript, such as anonymous self-invoking functions, to\nobfuscate its intentions. Finally, the dropper was self-contained to include the Spora EXE as\nwell as a dummy Word Document to confuse the victim. No additional network connectivity\nwas needed once the victim received the dropper.\n\nOther droppers have used many of these techniques in the past. However, the combination\nof these techniques, combined with the degree to which the Spora dropper leveraged them,\ndefinitely set a new standard of sophistication and obfuscation.\n\n_Thanks for reading..._\n\n_You can also connect with me on Twitter at_ _[@kd_cybersec.](http://twitter.com/kd_cybersec)_\n\n[31](https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_social-details_social-action-counts_likes-text) [4 Comments](https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_social-details_social-action-counts_comments-text)\n[Like Comment Share](https://www.linkedin.com/signup/cold-join?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_social-details_like-cta)\n\n[➜ Peter Berson](https://www.linkedin.com/in/bersonpeter?trk=pulse-article_social-details_comment_actor-name)\nI feel that all new malware is about obfuscation and levels of encryption in the payloads to\ncircumvent most endpoint A/V engines. This is why a lot of them are trying sandboxing\napproaches. Machine Learning and Deep Learning will help in the next gen A/V endpoint\nclients to detect this better. The actual ransomware and command and control part is simple,\nit's more about getting the payloads to execute and evade A/V protection at all levels.\nFirewalls, Anti-Spam systems, and endpoint. Great job and explaining multi-stage approach.\n\n\n-----\n\nSign in to like this comment\n\nSign in to reply to this comment\n\n1 Like\n5y\n\n[Roger Cruz](https://www.linkedin.com/in/rogercruz?trk=pulse-article_social-details_comment_actor-name)\nGreat explanation. Thank you for taking the time to teach us these internal details. I learned\nquite a bit\nSign in to like this comment\n\nSign in to reply to this comment\n\n1 Like\n5y\n\n[Evgueni Loukipoudis](https://ca.linkedin.com/in/evgueni?trk=pulse-article_social-details_comment_actor-name)\nZ\nSign in to like this comment\n\nSign in to reply to this comment\n\n5y\n\n[Tim Wiser %](https://uk.linkedin.com/in/tim-wiser?trk=pulse-article_social-details_comment_actor-name)\nSuperb breakdown of infection. Fascinating read !!\nSign in to like this comment\n\nSign in to reply to this comment\n\n1 Like\n5y\n[See more comments](https://www.linkedin.com/login?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_comments_comment-see-more)\n[To view or add a comment, sign in](https://www.linkedin.com/login?session_redirect=https%3A%2F%2Fwww%2Elinkedin%2Ecom%2Fpulse%2Fspora-ransomware-understanding-hta-infection-vector-kevin-douglas&trk=pulse-article_social-details_feed-cta-banner-cta)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-03-09 - Spora Ransomware- Understanding the HTA Infection Vector.pdf"
    ],
    "report_names": [
        "2017-03-09 - Spora Ransomware- Understanding the HTA Infection Vector.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535783,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1653693928,
    "ts_modification_date": 1653693928,
    "files": {
        "pdf": "https://archive.orkl.eu/a3087b636b82b81648ce24970ef4a1447164e8a4.pdf",
        "text": "https://archive.orkl.eu/a3087b636b82b81648ce24970ef4a1447164e8a4.txt",
        "img": "https://archive.orkl.eu/a3087b636b82b81648ce24970ef4a1447164e8a4.jpg"
    }
}