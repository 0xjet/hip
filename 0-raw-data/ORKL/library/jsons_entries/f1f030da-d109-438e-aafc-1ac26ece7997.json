{
    "id": "f1f030da-d109-438e-aafc-1ac26ece7997",
    "created_at": "2023-01-12T15:00:24.915885Z",
    "updated_at": "2025-03-27T02:10:06.582683Z",
    "deleted_at": null,
    "sha1_hash": "63f445ace0f2ebc03bfa223c125d5182d6e01a01",
    "title": "2016-11-23 - Analysis- Ursnif - spying on your data since 2007",
    "authors": "",
    "file_creation_date": "2021-06-20T09:27:47Z",
    "file_modification_date": "2021-06-20T09:27:47Z",
    "file_size": 1156772,
    "plain_text": "### Degree in Computer Engineering\nComputer science\n\n##### End of degree work\n\n## Bagheera: an Advanced Polymorphic and Infection Engine for Linux\n\nAuthor\n\n### Diego Carballeda Martinez\n\n###### 2021\n\n\n-----\n\n-----\n\n### Degree in Computer Engineering\nComputer science\n\n##### End of degree work\n\n## Bagheera: an Advanced Polymorphic and Infection Engine for Linux\n\nAuthor\n\n### Diego Carballeda Martinez\n\nDirector(s)\nJose A. Pascual\n\n\n-----\n\n-----\n\n### Summary\n\nComputer viruses have been evolving since the ’80s, adopting new techniques with the\nintention of avoiding being detected by anti-virus programs. One of these techniques is\npolymorphism, which is used to change the virus’ structure each time an infection is\ncarried out. This technique was broadly adopted by the virus-writing community and led\nto the birth of Polymorphic Engines, which can grant polymorphism to any virus.\n\nThis project focuses on the study of those engines and, in particular, on exploring the\ntechniques used to avoid detection from anti-viruses. In addition, this project also focuses\non the analysis and development of techniques to infect ELF binaries on Linux platforms.\n\nThe final goal is to design and build a modern polymorphic and infection engine, namely\n_Bagheera, and to evaluate its effectiveness against a state of the art anti-virus in a Linux_\nplatform.\n\ni\n\n\n-----\n\n-----\n\n### Disclaimer\n\nThis thesis contains software that can be used as a viral threat. The author of this document\nis not responsible for possible damages that may be caused by using this software. The\ncontents of the document are purely academic and should not be used with any other\npurpose.\n\niii\n\n\n-----\n\n_Mila esker, nire familiari, uneoro nire alboan egotegatik_\n_eta nigan beraien konfiantza sendoena jartzeagatik._\n\n_Jon, Haizea, Aitor eta fakultateko lagun guztiei,_\n_azken 4 urteetan izandako beste ’familiari’,_\n_hain polita den etapa honetan bidelagun onenak izategatik._\n\n_Eta azkenik nire tutoreari, Jose, informatikako esparru politena_\n_esploratzera animatzeagatik eta emandako babesagatik._\n\n\niv\n\n\n-----\n\n### Contents\n\n**Summary** **i**\n\n**Disclaimer** **iii**\n\n**Contents** **v**\n\n**List of Figures** **vii**\n\n**List of Tables** **ix**\n\n**1** **Introduction** **1**\n\n**2** **Aims of the project** **3**\n\n**3** **Preliminaries** **5**\n\n**4** **Core Polymorphic Engine** **9**\n\n4.1 Overall Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\n4.2 Development Environment . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\n4.3 Engine Phases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n4.3.1 Create encryption function and key . . . . . . . . . . . . . . . . 13\n\n4.3.2 Encrypt the input data. . . . . . . . . . . . . . . . . . . . . . . . 15\n\n4.3.3 Create decryption function. . . . . . . . . . . . . . . . . . . . . . 15\n\n4.3.4 Generate final output . . . . . . . . . . . . . . . . . . . . . . . . 20\n\nv\n\n\n-----\n\nCONTENTS\n\n**5** **Advanced Techniques** **23**\n\n5.1 Encryption key concealing . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\n5.2 Dead code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n5.3 Pseudo-Random Number Generator . . . . . . . . . . . . . . . . . . . . 24\n\n5.4 General Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n**6** **Binary Infection** **27**\n\n6.1 `PT_NOTE to PT_LOAD infection . . . . . . . . . . . . . . . . . . . . . . .` 29\n\n**7** **Detection Avoidance** **33**\n\n**8** **Project management** **35**\n\n8.1 Description of the phases and their features . . . . . . . . . . . . . . . . 35\n\n8.1.1 Management phase . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\n8.1.2 Development phase . . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n8.1.3 Documentation phase . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n8.2 Estimations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\n8.3 Risk management plan . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\n8.4 Deviations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n\n**9** **Conclusions and future work** **41**\n\n**Bibliography** **43**\n\nvi\n\n\n-----\n\n### List of Figures\n\n4.1 Process of morphing an input I into various possible encrypted outputs Oi. 10\n\n4.2 Basic structure of the output generated by the polymorphic engine. . . . . 11\n\n4.3 Decryption process performed of a real output of the engine, from time t\nto time t + 1. Decryption function is shown in grey, the decrypted payload\nin green and the encrypted payload in white. . . . . . . . . . . . . . . . . 12\n\n4.4 Representation of the array of opcodes used for the encryption and decryption functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n4.5 Padding applied to an unaligned input data. Data is represented by ’D’\nand padding by ’P’. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n5.1 Execution flow of the decryption function with the advanced techniques\nmodifications. Green segments correspond to those added by the advanced\ntechniques and, white ones conform the segments that make up the core\nstructure of the decryption function. . . . . . . . . . . . . . . . . . . . . 26\n\n6.1 ELF file format perspective types. . . . . . . . . . . . . . . . . . . . . . 28\n\n6.2 ELF file infection using PT_NOTE technique. (a) is an un-infected file and\n(b) is an infected file. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\nvii\n\n\n-----\n\n-----\n\n### List of Tables\n\n8.1 Estimation of tasks and their final required time. . . . . . . . . . . . . . . 38\n\nix\n\n\n-----\n\n-----\n\n### List of source codes\n\n1 Decryption function prologue. . . . . . . . . . . . . . . . . . . . . . . . 18\n2 Delta offset calculation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3 Possible generation of decryption loop. . . . . . . . . . . . . . . . . . . . 21\n4 Creation of the decryption function. . . . . . . . . . . . . . . . . . . . . 22\n5 Execution of the decryption function. . . . . . . . . . . . . . . . . . . . 22\n6 Pseudo-Random Number Generator C algorithm. . . . . . . . . . . . . . 25\n\nxi\n\n\n-----\n\n-----\n\n# 1. CHAPTER\n\n### Introduction\n\nWhen it concerns computer security, there is no more well-known term as computer virus.\nAlthough the term is often misused when referring to worms or malware in general, a\nself-replicating program is the simplest form of a virus. For most users, these malicious\nprograms infringe unwanted and annoying damage to computer systems, and often antivirus (AV) software is the easiest and simplest solution to take care of them.\n\nFrom the virus writers’ perspective, there is no bigger enemy than a solid anti-virus. Starting back around the ’80s, a fierce fight has been fought through the years between them.\nBack in the day, virus writers had no anti-viral opposition and could make their work\nspread as freely as they wanted. Reacting to the dawn of viruses, anti-virus software appeared to appease this threat. There have been several battles over the last few years\nbetween the two of them, regarding virus encryption, signature-based scanning or code\nemulation based detection [1]. Nevertheless, the war still has continued to this day.\n\nIn the last part of the 1980s, the idea of using encryption to scramble the presence of a\nvirus was motivated by the fact that antivirus software could identify infections by examining executable files looking for unique viral footprints. As it will be detailed in Section\n4.1, this encryption has nothing to do with modern cryptography algorithms.\n\nMotivated by improvements in AVs to detect encryption, viruses adapted to this new\nenvironment, adopting a new technique: polymorphism. Polymorphic viruses are everchanging programs, which challenge signature-based scanning, through morphs[1] of dif\n1In biology, polymorphism is the occurrence of two or more different morphs or forms in the population\nof a species.\n\n1\n\n\n-----\n\n2 Introduction\n\nferent sizes and shapes. This ground-breaking technique fascinated the virus-exchange\nscene, gaining rapid popularity among virus writers.\n\nEvery hacker wanted to develop a polymorphic virus, so polymorphic engines (PE) emerged.\nThis tiny module, ready to be attached to any virus, could turn any virus into polymorphic. This new invention increased the popularity of polymorphic viruses. Contributions\nlike Dark Avenger’s Mutation Engine (DAME) [2, 3] made these new viruses more accessible and easy to create. As a consequence, their presence in the community increased\ndramatically.\n\nEven though the first polymorphic virus appeared in 1990, F. Cohen had already introduced the concept of evolution in viruses. In his work, Cohen also stated that the problem\nof virus detection is undecidable, concluding that: a program that precisely discerns a\nvirus from any other program by examining its appearance is infeasible [4]. With the actual implementation of polymorphic viruses, the problem defined by Cohen is taken to the\nnext level, generating more transformations than those contemplated in his work. Additionally, a recent investigation conducted by D. Spnellis showed that the identification of\npolymorphic viruses is NP-complete [5].\n\nThroughout history, most viruses have targeted Microsoft Windows family operating systems. Although UNIX-like operating systems are not immune to viruses, their sheer market share has prevented them from being attacked. It is believed that UNIX systems are\nnot susceptible to a virus, but the reality is that the almost non-existent presence of viruses\nfor this platform has led to its users believing that they cannot be attacked by this type of\nthreat.\n\nThis project aims to understand the inner workings of a polymorphic virus from a practical point of view, analyzing and developing the basic structure of a polymorphic engine,\ni.e. Bagheera. Furthermore, various advanced techniques are developed, used to provide\nadditional stealthiness to the engine. The project also ventures into the world of infecting\nsoftware, implementing a simple yet efficient infection algorithm for Linux machines. Finally, the effectiveness of Bagheera is put to the test against anti-virus software, analyzing\nif the engine is able of concealing the presence of a virus.\n\n\n-----\n\n# 2. CHAPTER\n\n### Aims of the project\n\nThe project aims to design and build a polymorphic engine that can be linked to any\npiece of software to evade anti-virus detection. To reach the final goal, the project must\nbe broken down into various steps.\n\nIn the first step of the project, a first core implementation of a polymorphic engine must be\ndeveloped. Future steps need a solid base to evolve correctly, so this basic implementation\nof the PE must cover all the necessary aspects an engine like this demands. Throughout\nrecent history, various engines have been published in the hacking community. All these\nimplementations share a common structure, which is known to be efficient and proper.\nTherefore, the PE this project comprehends will follow this common structure.\n\nThe second step in the project is the enhancement of the polymorphic engine, adding\nadvanced features to its core functionality. These features make the detection process of\nanti-virus software more complicated. Countless advanced techniques could be bound to\nthe engine to make it more robust against detection. Just a few of these techniques will\nbe developed since adding more would increase the level of complexity of the project.\nAdditionally, the third step of the project will focus on providing viral properties to the\nengine. This will be carried out by implementing an infection method for Linux binaries.\n\nLastly, the engines main purpose must be tested. It must be capable of evading anti-virus\ndetection in a real-world environment. Hence, an open-source antivirus, ClamAV, will\nbe protecting a system that the virus has to infect without being noticed by the AV. If\nthe detection software is capable of spotting the virus, the design and implementation\nof the PE must be revised so that polymorphic weaknesses can be solved. Custom virus\n\n3\n\n\n-----\n\n4 Aims of the project\n\nsignatures can be added to ClamAV to mimic a much more harsh environment in which\nthe virus has to spread. By doing this, the PE can be tested to the edge.\n\nOne of the main purposes of Bagheera is to be a lightweight addition to existing software\nto offer polymorphic capabilities. This is why the implementation of the engine must be\nsmall and concise. To ensure this goal is met, the engine could be implemented in assembler language. Although the performance of this programming language in this kind\nof tasks is unbeatable, some kind of abstraction is needed. Therefore, the polymorphic\nengine will be developed in C++, making use of the AsmJit library which offers the possibility to write executable code at execution time.\n\nIn conclusion, the main tasks that must be developed to reach the projects main purpose\nare the following:\n\n1. Development of a basic PE implementation\n\n2. Enhancement of the PE via advanced polymorphic techniques\n\n3. Linux binaries infection algorithm implementation\n\n4. Testing the PE against ClamAV\n\n\n-----\n\n# 3. CHAPTER\n\n### Preliminaries\n\nComputer viruses have been around for a long time. Since the first glimpses of modern\ncomputers were imagined, self-replicating pieces of software have been present. One of\nthe founders of today’s modern computer architecture, John von Neumann, apart from\ndefining the core of advanced computers [6] also contributed to the viral aspect of computation. In his essay back in 1949, he introduced the concept of self-replicating programs\nand how to design them [7]. That work can be considered as the first formal description\nof a computer virus, although it was a theoretical work.\n\nYears after von Neummans publication on self-replicating programs, the first computer\nviruses appeared in the 70’s decade. Although these programs followed von Neumann’s\napproach to self-replicating programs, the end goal of these pieces of code was not just\nmere replication, but to inflict some damage in the system they resided on. These malicious actions are carried out by the virus \"payload\". This part of the program is in charge\nof damaging the system. Also, once one system was infected, there was a need to spread\nand find another susceptible host. The part in charge of searching for a new host is the\nvirus infection algorithm. These two features are the key elements for computer viruses\n\n[8]. A clear example of this kind of virus is the primitive BRAIN released in 1986. This\nDOS-based malicious program was one of the first functional evil self-replicating software that emerged in the dawn of the virus era [1].\n\nThe computer community considered these pieces of software as a huge threat, and thus a\ncounter-movement occurred; the beginning of anti-virus software. Anti-virus or AV programs tried to detect the presence of previously known computer viruses in computer\n\n5\n\n\n-----\n\n6 Preliminaries\n\nsystems. This detection was performed using pattern recognition, also known as string\nsignatures.\n\nThese signatures are just a sequence of bytes stored in anti-virus databases that are extracted from an actual virus. When a program is suspicious of containing a virus, its code\nis analyzed and the part that is believed to carry out evil actions is the one that forms the\nseries of bytes that unequivocally identify the virus. This sequence is usually not found in\nnormal programs and yells the presence of malicious behaviour in the program that holds\nthese bytes.\n\nUsing this pattern, anti-virus software looks for this exact sequence inside binary files.\nWhen it finds a match, it tags the binary as a virus, taking the appropriate measures for\nits neutralization [9]. Similarly, heuristic rules are also used by these programs to try and\ndetect viruses that have yet not been discovered but behave in a similar way to a previously\nanalyzed virus. Although this method is quite accurate for detecting macro viruses[1] [10],\nthe amount of false positives it generates with binary viruses makes this technique not\nthat appropriate for this kind of viral threat. Although they are still used in modern AVs,\ndifferent virus types often require completely different heuristic rules, making this method\nquite ineffective [11].\n\nEven though hiding their presence was not a concern in the early stages of computer\nvirus development, the arising of anti-virus software made the virus community look for\nclever ways to avoid being detected. In this context, various concealment techniques, or\nself-protection techniques, bloomed and made virus detection way harder for anti-virus\nsoftware.\n\nAs mentioned, the earliest and most primitive technique was encryption [12]. Since basic\ndetection systems focus on analyzing unique patterns in the viruses binaries, encrypting\nthis information onto a nonsense collection of bytes cleared the problem away. The virus\nis divided into two main parts: a decryption function and the actual body of the virus.\nThe only piece of code that the virus leaves unencrypted is the decryption function. When\nthe virus is executed, the decryption function decodes and gives control to the encrypted\ncode. This way, the actual instructions that define the virus are encrypted until they need\nto be executed. The only piece of readable and sensible code is the decryption function,\nwhich normally is very small and simple to not raise suspicions.\n\nLater, anti-virus software also evolved to adapt to this new kind of viruses. Apart from\ntrying to find malicious behaviour patterns in binary files, lots of effort were put into\n\n1Computer viruses that use an application’s macro programming language to distribute themselves.\n\n\n-----\n\n7\n\nfinding basic decryption routines. The same detection method as for virus body signature\nscanning is applied, but in this case, spotting a decryption function is the goal [13]. These\nfunctions had a similar structure, which was easily detectable by scanners. In fact, most\nviruses have a unique decryption routine. This is the biggest flaw of encrypted viruses.\n\nMotivated by this sheer amount of decryption function variations, virus writers developed\nthe technique which this thesis focuses on: polymorphism.\n\nPolymorphic viruses are in some way, an advanced evolution of encrypted viruses. They\nmaintain the encrypted payload, but the decryption function no longer has a unique form.\nPolymorphic viruses are born aiming to avoid detection schemes based on string signatures. These systems are based on the idea that viruses always preserve several stable\nbytes in each generation, so the polymorphic virus changes its decryption function in every infection it performs, but still maintaining the same semantics. Every polymorphic\nvirus maintains its semantics intact whilst using different instructions to do so. Generally,\nthese instructions or opcodes are chosen at random. A polymorphic engine has to have a\nlarge number of possible random equivalences to have a solid structure.[14, 15, 16].\n\nAlthough this new virus type might look quite undetectable at first, anti-virus software\nhas evolved the same way viruses have done, adapting their detection mechanisms to this\nkind of techniques. A very common approach to detecting polymorphic viruses is quite\nsimple: let the virus decrypt its payload, and analyze this decrypted data [11].\n\nLetting the virus decrypt its malicious code and then analyzing it is a very effective technique, as well as costly in terms of computation. Although detecting an infected program\nis the main function of an antivirus, it cannot use the system resources to do so. The\ndetection has to be a light process that allows users of a system to use it without any\ninconvenience. In contrast, viruses do not have this restriction, as they have no limit on\nthe systems’ resource usage. Advanced techniques of stealthiness and polymorphism, entangle even more the decryption process. Thus, the complexity of the decryption function\nincreases, making anti-viruses unable to afford to analyze the decrypted code. The process\nis so long and tedious that the analysis aborts before the payload is available.\n\n\n-----\n\n-----\n\n# 4. CHAPTER\n\n### Core Polymorphic Engine\n\nThis chapter presents the core structure of the polymorphic engine named Bagheera[1], a\nmodule that can be added to any virus to give it polymorphic qualities. First, the basic\nstructure of the engine is defined, as well as the logical relationship between the different\nparts of the code it generates. Next, the development environment where the engine has\nbeen crafted is described, to finish by detailing the execution phases of the engine.\n\n#### 4.1 Overall Structure\n\nA polymorphic engine is a piece of code that can modify an input I into an altered version\nof it, namely Oi, with 1 ≤ _i ≤_ _n, being n a large integer value. Every conversion the engine_\nperforms generates a different output, unrelated to the rest of possible n − 1 outputs. As\na result, there is no feasible situation where for any given pair of outputs (Oi, _O j) with_\n1 ≤ _i, j ≤_ _n →_ that Oi = O _j. Figure 4.1 illustrates the differences between the morphs_\nBagheera creates.\n\nFor every Oi generated, the engine must also provide a method to retrieve the original I,\nsince the aim of the morphing is to evade plain sight detection and the original input will\nbe needed at some point in time. This method is often called a decryption function (also\nreferred as decrypt()). The decryption function generated for a specific output is tightly\nrelated to it, making also decrypt() unique the same way Oi is. Alternatively, the engine\n\n[1The source code for Bagheera is available at https://github.com/diegocarba99/bagheera.](https://github.com/diegocarba99/bagheera)\n\n9\n\n\n-----\n\n10 Core Polymorphic Engine\n\n#### O\n1\n\n#### O\n2\n\nI BAGHEERA\n\n#### O\n3\n\n#### O\n4\n\n**Figure 4.1: Process of morphing an input I into various possible encrypted outputs Oi.**\n\ntransforms the initial input using an encryption function (also refereed as encrypt()).\nThis function works inversely to decrypt(), as the result generated by the encryption\nfunction can be processed by the decryption function to retrieve the original I.\n\nGenerally, some basic obfuscation[2] is performed so that the output cannot be related to\nthe input data at a glance. This transformation although effective, does not require any\nhuge amount of computational effort, since it only consists of simple arithmetic or logic\noperations, described in more detail later on. Obfuscation is carried out by creating a\nunique encryption key (k), which is used as an operand in both the pseudo-encryption and\npseudo-decryption process. What gives the engine its polymorphic nature is the fact that,\ndespite the key is different in every morph, the generated functions are also different in\nevery conversion it is performed.\n\nIn consequence, it can be stated that:\n\n_I = decryptk(encryptk(I)) = decryptk(Oi)_\n\nAs mentioned in Chapter 3, the most common input a PE can receive is static binary code\n(also known as shellcode). Since the encryption process aims to obfuscate the meaning of\n\n2The deliberate act of creating code or modifying existing one so that is difficult for humans to understand. Code may be obfuscated to conceal its purpose and logic to prevent tampering or deter reverse\nengineering.\n\n\n#### O\n\n\n#### O\n\n\n#### O\n\n\n4\n\n\n2\n\n\n-----\n\n4.1 Overall Structure 11\n\n_I, the camouflaged data Oi generated by the engine maintains the same semantic meaning_\nas the original input.\n\n**mov  r11,rdi**\n**call  0x19**\n**xor  r11,r13**\n**leave**\n**ret  0x8** Decryption\n**pop  rcx**\n\nfunction\n\n**[ ... ]**\n\n**mov  rax,0x53**\n**pop  r15**\n\n**5553 4154 4155 4156 4157 4889 f8e8 0700**\n**0000 4d31 ebc9 c208 0041 5949 81c1 5e00**\n**0000 49c7 c3f0 24d7 1749 81c3 5bdb 28e8**\n**48c7 c60b 0000 004d 8b29 4d29 dd4d 31dd**\n**4d01 dd4d 29dd 4d01 dd4d 8929 4c89 2849**\n**83c1 0848 83c0 0848 ffce 75db 48c7 c053**\n**0000 0041 5f41 5e41 5d41 5c5b 5d90 9090**\n**9951 5256 5741 5341 99eb 255b 215d 2066**\n**9c61 7220 4261 6768 9c65 7261 2773 206d**\n**a067 6874 7920 636c a877 2020 5b21 5d0a**\n**0131 c048 83c0 0148 c0c7 488d 35ca ffff**\n**4a49 31d2 b225 0f05 0858 415b 5f5e 5a59**\n**e80b 0000 0049 c7c2 0100 0000 c9c2 0800** Encryption\n**5f48 81c7 4700 0000 48c7 c296 d61d c548**\n**81c2 d429 e23a 48c7 c00b 0000 004c 8b07** function\n**49f7 d049 01d0 4931 d049 29d0 4931 d04c**\n**8907 4883 c708 48ff c875 e290 9bae ada9**\n**a8be acbe 9b14 daa4 dea2 df99 569f 8ddf**\n**bd9e 9897 569b 8d9e d88c df92 6299 978b**\n**86df 9c93 4a89 dfdf a4de a2f5 83ce 3fb7**\n**7c3f feb7 4238 b772 ca35 0000 d4b7 ce2d**\n**4dda f0fa 6aa7 bea4 a0a1 a5a6 7314 ff6f**\n**e807 0000 004d 31eb c9c2 0800 5948 81c1**\n**4b00 0000 48c7 c2df c0c5 5648 81ea 6ac0**\n**3266 6874 7920 636c 2a76 2020 5b21 5d0a**\n**5330 c048 83c0 0148 12c7 488d 35ca ffff**\n**a047 31d2 b225 0f05 4a57 415b 5f5e 5a59**\n\n**Figure 4.2: Basic structure of the output generated by the polymorphic engine.**\n\nAs stated before, the generated output data and the decryption function are tightly related,\nso the engine provides both at the same time. Figure 4.2 illustrates this concept visualizing\nthe outcome created by Bagheera. PEs are used to create polymorphic code, which can\nbe created by supplying the mentioned executable instructions to the engine. Thus, all\nthe generated output can be interpreted as code instructions. The decryption function will\nconsist of benign code that just performs some operations on the data that follows it, i.e.\nthe encrypted payload.\n\nOn the other hand, the obfuscated data will presumably look like corrupted or bizarre\ninstructions. As the decryption function is executed, this gibberish will be translated into\nactual valid instructions, which correspond to the original input data the engine camouflaged. This decryption process is represented in Figure 4.3. The figure shows two snapshots of Bagheera’s output in a real decryption process, where the decrypted payload can\n\n\n-----\n\n12 Core Polymorphic Engine\n\nread the password of the user[3].\n\n**mov  r11,rdi** **mov  r11,rdi**\n**call  0x19** **call  0x19**\n**xor  r11,r13** **xor  r11,r13**\n**leave** **leave**\n**ret  0x8** **ret  0x8**\n**pop  rcx** **pop  rcx**\n\n**[ ... ]** **[ ... ]**\n\n**mov  rax,0x53** **mov  rax,0x53**\n**pop  r15** **pop  r15**\n\n**section .text** **section .text**\n**global _start** **global _start**\n\n**_start:** **_start:**\n**xor rsi, rsi** **xor rsi, rsi**\n**jmp string_1** **jmp string_1**\n**cont_1:** **cont_1:**\n**pop rdi** **pop rdi**\n**push 24** **push 24**\n\n**pop rcx**\n\n**0000 4d31 ebc9 c208 0041 5949 81c1** **decode:**\n**0000 49c7 c3f0 24d7 1749 81c3 5bdb** **xor byte [rdi+rcx], 0x32**\n**48c7 c60b 0000 004d 8b29 4d29 dd4d** **loop decode**\n**4d01 dd4d 29dd 4d01 dd4d 8929 4c89** **sub byte [rdi+11], 0x41**\n**83c1 0848 83c0 0848 ffce 75db 48c7** **sub byte [rdi+24], 0x41**\n**0000 0041 5f41 5e41 5d41 5c5b 5d90** **push 2**\n**9951 5256 5741 5341 99eb 255b 215d** **pop rax**\n**9c61 7220 4261 6768 9c65 7261 2773**\n**a067 6874 7920 636c a877 2020 5b21** **a067 6874 7920 636c a877 2020 5b21**\n**0131 c048 83c0 0148 c0c7 488d 35ca** **0131 c048 83c0 0148 c0c7 488d 35ca**\n**4a49 31d2 b225 0f05 0858 415b 5f5e** **4a49 31d2 b225 0f05 0858 415b 5f5e**\n**e80b 0000 0049 c7c2 0100 0000 c9c2** **e80b 0000 0049 c7c2 0100 0000 c9c2**\n**5f48 81c7 4700 0000 48c7 c296 d61d** **5f48 81c7 4700 0000 48c7 c296 d61d**\n**81c2 d429 e23a 48c7 c00b 0000 004c** **81c2 d429 e23a 48c7 c00b 0000 004c**\n**49f7 d049 01d0 4931 d049 29d0 4931** **49f7 d049 01d0 4931 d049 29d0 4931**\n**8907 4883 c708 48ff c875 e290 9bae** **8907 4883 c708 48ff c875 e290 9bae**\n**a8be acbe 9b14 daa4 dea2 df99 569f** **a8be acbe 9b14 daa4 dea2 df99 569f**\n**bd9e 9897 569b 8d9e d88c df92 6299** **bd9e 9897 569b 8d9e d88c df92 6299**\n\n#### t t+1\n\n**Figure 4.3: Decryption process performed of a real output of the engine, from time t to time t +** 1.\nDecryption function is shown in grey, the decrypted payload in green and the encrypted payload\nin white.\n\n#### 4.2 Development Environment\n\nBagheera has been developed using the C++ programming language. Polymorphic engines\ncan be created using programming languages with less abstraction level such as C or\n```\nAssembly.\n\n```\nThe main reason for choosing C++ has been dynamic code generation. The engine must\ngenerate a unique decryption function every time is executed, thus it must create executable instructions on run-time. This feature is present in Just-In-Time compilation.\nJust-In-Time or JIT compilation is a technique used to generate code and execute it during the execution of a program rather than before execution [17].\n\n3The whole payload is available at `http://shell-storm.org/shellcode/files/`\n```\nshellcode-891.php\n\n```\n\n-----\n\n4.3 Engine Phases 13\n\nThis project has made use of the AsmJit library [18] available for C++ to generate assembly code at run-time. The engine creates the executable code and the library stores it in\none of the CodeHolder class’ attributes. When the executable code is ready to be assembled, a specialized JIT run-time resolves all the jumps and offsets, adding the generated\ncode to a function pointer. This process is detailed in Section 4.3.4.\n\n#### 4.3 Engine Phases\n\nThe engine must complete certain execution phases to generate the output. These phases\nare executed by the engine in order of appearance. In the following sections, these phases\nare described.\n\n###### 4.3.1 Create encryption function and key\n\nIn this phase, the PE must obfuscate the input data that has received. Since the encrypted\ndata must later be retrieved using the decryption function, this phase is highly related to\nthe one described in Section 4.3.3.\n\nThe encryption key used for both functions is also created in this phase. As it will be\ndescribed in Chapter 5.1, the key will be concealed using advanced methods, but the\ncore functionality remains the same: store a certain value (the key itself) in a register for\nlater usage in the arithmetic and logical operations performed on both encryption and\ndecryption functions.\n\nAll the operations that are performed on the input data are cached so that they can be\nreversely applied by the decryption function. For this purpose, Bagheera creates an array\nthat will contain the opcodes of the operations that will be applied to the data.\n\nAll the operations must be reversible so that when they are reverse-applied, no information\nis lost. From the available set of operations present on most modern CPU’s Arithmetic\nLogic Unit (ALU), only a small set of them can be used for this purpose since not all of\nthem are reversible. Among this operation set, the following ones can be found: Addition\n(ADD), Subtraction (SUB), Negation (NEG), Bit-wise And (AND), Bit-wise Or (OR), Bit-wise\nexclusive Or (XOR), Bit-Wise negation (NOT) and rotation (ROT) [19].\n\nAlthough many other operations might be supported by specific architectures, only those\noperations stated in this chapter will be considered for the project. A possible series of\n\n\n-----\n\n14 Core Polymorphic Engine\n\n\nEncryption operations order\n\nAND\n\nDecryption operations order\n\n|ADD|SUB|AND|ADD|NEG|\n|---|---|---|---|---|\n\n\n**Figure 4.4: Representation of the array of opcodes used for the encryption and decryption func-**\ntions.\n\nopcodes stored in the array the engine creates is illustrated in Figure 4.4, where the order\nin which both encryption and decryption functions apply those operations to the data is\nrepresented.\n\nBasic PEs, encrypt the data using just one operation, making the obfuscation process\nquite simple. On the contrary, Bagheera uses multiple operations. This way, the level of\ncamouflage is higher, making the analysis of the generated data even more complex.\n\nAlgorithm 1 presents the basic structure of the encryption function the engine generates.\nEven though the encryption function will consist of different operations and key, the semantics of the initial input will not be altered. When decrypted, all the different morphs\nthat correspond to a certain input will be equal.\n\n**Algorithm 1: Encryption function algorithm.**\n**Input: Buffer containing the input data and encryption key**\n**Output: Buffer containing the encrypted data**\n\n**1 foreach Data Block do**\n\n**2** **foreach Encryption Operation do**\n\n**3** OutputBuffer = InputBuffer opcode EncryptionKey\n\n**4 return OutputBuffer;**\n\n\n-----\n\n4.3 Engine Phases 15\n\n###### 4.3.2 Encrypt the input data.\n\nOnce the encryption function has been constructed, the input data provided to the engine\ncan be morphed. This process is performed onto blocks of data taken from the input. The\nsize of these blocks will vary depending on the machine the engine is working on. For\n32-bit platforms, the maximum size the engine manages is 4 bytes, and 8 bytes for 64-bit\nplatforms.\n\nThe engine will iterate through the input, block by block, applying the operations defined\nin the opcode array to the data. This modified data will be stored in a temporary buffer\nuntil it can be appended to the output.\n\nSince the engine can only process blocks of data, the size of the buffer provided to the\nencryption function must be aligned with the block size. Bagheera does not impose any\nrestriction on the input size, so some sort of padding is added to the input aligning it to\nthe block size. This padding will fill the remaining space between the input data and the\nnext congruent block size as illustrated in Figure 4.5. As it has been mentioned before, the\nengine will process static binary code, so the padding consists of NOP operations. These\ninstructions are ignored by processors, leaving the initial data’s semantics unchanged.\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D D D D D\n\nD D D D D D D D D D D D P P P P\n\n**Figure 4.5: Padding applied to an unaligned input data. Data is represented by ’D’ and padding**\nby ’P’.\n\n###### 4.3.3 Create decryption function.\n\nIn this phase, the engine is responsible for creating the actual code that will retrieve the\ninitial input I from the obfuscated Oi. To achieve this, the function is divided into different\n\n|D D D D|P P P P|\n|---|---|\n\n\n-----\n\n16 Core Polymorphic Engine\n\nsegments. All the code and instructions mentioned in these segments are generated using\nthe Assembler class from the Asmjit library. This class offers an interface to generate the\ndesired instructions, storing them in the previously mentioned attribute in the CodeHolder\nclass. Through both of the classes, the library is in charge of storing all the instructions\nthat are emitted to it, so that later on the actual binary code can be generated.\n\nThe different segments that make up the decryption function are described next. These\nsegments appear in the document in the order in which they will be executed in the decryption function.\n\nFunction Prologue\n\nThe engine can store all the decrypted data into a buffer apart from executing it. This\nsection is responsible for obtaining the buffer’s address, which should be large enough to\nstore all the output.\n\nAlthough the pointer to the buffer is handed to the function as an argument, the way the\nengine gets access to it differs depending on the platform it’s been executed. More precisely, this access depends on the calling convention the machine uses. Historically, the\nway functions and function-callers have interacted has been defined by the platform the\nsoftware was developed. As multi-purpose machines arose, these diverse specifications\nmerged into various calling conventions, defined mainly by the Operating System the\nsoftware is run [20, 21].\n\nCalling conventions describe the interface of called code, stating the order of the parameters, how these are passed, which registers’ value must be preserved for the caller and\nhow the call is made. Since this area vastly wide, this document will not go into further\ndetail about the peculiarities of each aspect mentioned. However, considering Bagheera\nhas been developed targeting Linux machines, it will follow the calling convention used\nin this kernel, which is System V AMD64 ABI.\n\nFollowing the System V ABI [22] calling convention, we retrieve the pointer to the output\nbuffer via the RDI register. Since the engine just receives a single parameter, this register\nis the first in the list of 6 used for passing arguments before the stack is used. All the\nclean-up work is done by the caller of the engine, so Bagheera has no need for preserving\nthe values of the sensitive registers before the execution of the function, as this task is\nperformed by the caller.\n\nFinally, the decryption function must save the values of the registers RBX, RSP, RBP, and\n\n\n-----\n\n4.3 Engine Phases 17\n```\nR12–R15 so that it can restore their original values when the execution ends. This step is\n\n```\nperformed by pushing onto the stack the values of these registers. Later on, in the function\nepilogue described in Section 4.3.3, these values will be restored to their original registers.\n\nThis last step is crucial for the decryption function to fulfil its purpose. Throughout all\nthe function, various registers serve different purposes. All these different register types\nwill change from generation to generation, so all the sensible data described by the ABI\nmust be preserved. The different type of registers used throughout the function are listed\nbelow:\n\n  - regSrc: This register will hold a pointer to the memory location where the encrypted data is stored. This location will reside somewhere after the decryption\nfunction body.\n\n  - regDst: This register holds the pointer to the output buffer provided as an argument\nto the function.\n\n  - regSize: This register contains the number of blocks that make up the encrypted\ndata and the generated padding attached to it.\n\n  - regKey: This register holds the value of the decryption key. This value may be\ncalculated onto this register in various ways, but the final effective value used in the\nmain decryption loop is stored in this register.\n\n  - regData: This register will hold the block of data the function is treating in every\niteration of the decryption loop. Data will be temporally modified onto this register\nand then saved to the corresponding locations.\n\nAny of the available registers in the machine could be used for any of the above-listed\npurposes. Thus, all sensitive data is saved so no information is lost, and then the registers\nused by the function are randomly selected. This randomness contributes to the polymorphic nature of the function since most probably two different generations of the engine\nwill not share all the registers laid out the same way.\n\nListing 1 shows a possible function prologue generated by the function.\n\nDelta offset calculation\n\nThe dynamically generated code can be located anywhere in memory and launched from\nthere. In such cases, we cannot refer to parts of the function using absolute memory ad\n\n-----\n\n18 Core Polymorphic Engine\n```\nPUSH RBX\nPUSH RSP\nPUSH RBP\nPUSH R12\nPUSH R13\nPUSH R14\nPUSH R15\nMOV regDts, RDI\n\n```\n**Listing 1: Decryption function prologue.**\n\ndresses, because we simply do not know where the function will reside. This address\nlocation is stored onto the regSrc register, using the following calculation:\n\n_regSrc = @base_address_ + _of fset_to_encrypted_data_\n\nWhere the @base_address is unknown until run-time. The offset to the encrypted data\nvaries depending on the changing size of the decryption function, so its value remains\nunknown until all the function has been emitted. To overcome this restriction, an age-long\ntechnique is used to reference the data using relative addressing, namely the Delta Offset\ntechnique.\n\nThe base address where the decryption routine is located is calculated taking advantage\nof the behaviour of the call instruction. When a function is called using this instruction,\nthe return address is stored onto the stack before the actual jump is done. Precisely, this\nstored value is the base address the engine is looking for. To obtain it, Bagheera simply\nemits a call instruction that refers to an instruction after it. If the following instruction\nretrieves the pushed value from the stack, the base address is obtained. Using a simple\n```\npop instruction is enough to obtain this value.\n\n```\nThe delta offset technique is both simple and well known, so it is not stealthy at all. Regular programs do not need to perform this kind of calculations, so a sequence of call/pop\ninstructions is suspicious. To avoid triggering all the AV alarms, Bagheera simulates a\nlegit function call. Normally, after a function returns from a call, the caller performs some\noperations to obtain some information from the called function. Thus, between the call\nand the pop function, some non-suspicious code is inserted, emulating a normal program\n\n\n-----\n\n4.3 Engine Phases 19\n\nbehaviour.\n\nOn the other hand, when the instructions to calculate regSrc’s value are generated, the\nfinal size of the decryption function is unknown and so the offset to the encrypted data is\nalso. Thus, the of fset_to_encrypted_data value is not emitted yet, but a dummy-value\nis. Later on, when all the code corresponding to the decryption function has been emitted,\nthis dummy value is updated with the actual offset. In Listing 2 the code generated for the\nDelta Offset calculation is shown.\n```\n  CALL delta_offset\n  MOV R10, 0x3\n  LEAVE\n  RET 0x8\ndelta_offset:\n  POP regSrc\n  ADD regSrc, 0x000\n\n```\n**Listing 2: Delta offset calculation.**\n\nDecryption key setup\n\nAs mentioned in Section 4.3.1, the key is stored the regKey register. This process is quite\nstraightforward at its core, as the only action that needs to be carried out is storing a value\non a register. However, this is not the way Bagheera manages the key setup, as it consists\nof an advanced technique that will be described in Section 5.1. The details regarding this\nsegment will be extended in the mentioned section.\n\nDecryption loop\n\nThis section is the core of the decryption routine. Here, the function processes the data\nand restores the original input. The section consists of a main loop that iterates through\nthe encrypted data referred by regSrc, and stores it, decrypted, back into regSrc and\n```\nregDst.\n\n```\nBefore the loop starts, the register regsSize is initialized with the number of blocks\nthe loop has to go through. Next, the block pointed by regSrc is stored onto regData.\n\n\n-----\n\n20 Core Polymorphic Engine\n\nActually, this is where the loop starts. The following instructions operate the value in\n```\nregData with the encryption key located in regKey. The number of instructions used for\n\n```\nthis purpose depends on how the data was encrypted. Precisely, the number of instructions\nin this part of the program equals the number of entries in the array of opcodes presented\nin Section 4.3.1. The operations performed onto regData use the decryption key as an\noperand, although not all of them do. Operations like NOT or NEG do not make use of the\nkey.\n\nAfter the operations have been performed onto the value stored in the data register, the\ndecrypted data resides in it. The engine saves this value by moving it to the locations\npointed by the regSrc and regDst registers. Finally, these two pointers are updated to\npoint onto the next available block location, and the regSize register is decremented as\na loop index. The last instruction of this section is a conditional jump, which depending\non the value of regSize jumps to the beginning of the loop, or continues with the rest of\nthe decryption routine.\n\nAn example of the main decryption loop is available on Listing 3. At lines 14 and 15,\nthe data pointers are increment by 0x8, since this particular example is done in a 64-bit\nmachine where the biggest block size managed by Bagheera in this architecture is 8 bytes.\n\nFunction Epilogue\n\nFinally, the engine emits the final code relative to the decryption engine. Basically, the\nreturn value is set onto the RAX register, and the sensible registers’ values defined by the\n_System V ABI are restored._\n\nWhen this point is reached, the decryption routines final size is known, so the dummyvalue described in Section 4.3.3 is updated. The final value is the offset difference between\nthe instruction with dummy value and the beginning of the appended encrypted data.\n\n###### 4.3.4 Generate final output\n\nRight after the main decryption routines body is where the encrypted data resides. This\nsection is constructed embedding the bytes directly using the DB and DQ instructions, for\n32-bit and 64-bit platforms respectively.\n\nWhen all the instructions have been emitted to the Asmjit library, it is time for the engine\n\n\n-----\n\n4.3 Engine Phases 21\n\n1 `MOV regSize, numBlq`\n\n2\n\n3\n\n4 `decryption_loop:`\n\n5 `MOV regData, PTR[regSrc]`\n\n6\n\n7 `NOT regData`\n\n8 `XOR regData, regKey`\n\n9 `ADD regData, regKey`\n\n10 `SUB regData, regKey`\n\n11\n\n12 `MOV PTR[regSrc], regData`\n\n13 `MOV PTR[regDst], regData`\n\n14\n\n15 `ADD regSrc, 0x8`\n\n16 `ADD regDst, 0x8`\n\n17\n\n18 `DEC regSize`\n\n19 `JNE decryption_loop`\n\n**Listing 3: Possible generation of decryption loop.**\n\nto create the final output. Listing 4 shows the operations the engine performs to fulfill this\npurpose.\n\nAs it has been described throughout this chapter, the decryption function takes a buffer as\nan input so that the original data can be stored, and it returns the size of the data written\nto the buffer. Thus, a function pointer is created on line 5, which follows the mentioned\ndefinition. First, memory with execution permissions is reserved using the mmap function\non line 9. Then, the output generated by the AsmJit run-time on line 11 is copied onto\nthe executable memory using memcpy as shown on line 15. Finally, in line 17 the function\npointer is initialized with the executable output.\n\nFinally, the engine can be called using the function pointer defined in Listing 4. When\nthat function is invoked, the decryption function generated by the engine is executed,\nwhich decodes the \"payload\" that it has attached to itself. Finally, you give control to the\npayload, letting it run. An example of how the decryption function is called is available in\nthe Listing 5.\n\n\n-----\n\n22 Core Polymorphic Engine\n\n1\n\n2\n\n3\n\n4\n\n5 `typedef long(*DecryptionFn)(void *);`\n\n6\n\n7 `DecryptionFn non_executable_fn;`\n\n8\n\n9 `void *lib_output = mmap(0, outputsz,`\n\n10 `PROT_READ | PROT_WRITE,`\n\n11 `MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);`\n\n12\n\n13 `run_time.add(&non_executable_fn, &code);`\n\n14\n\n15 `memcpy(lib_output, (void *)non_executable_func, outputsz);`\n\n16\n\n17 `DecryptionFunc fn = reinterpret_cast<DecryptionFunc>(lib_output);`\n\n**Listing 4: Creation of the decryption function.**\n```\n  unsigned long buffer_size = fn(output_buffer);\n\n```\n**Listing 5: Execution of the decryption function.**\n\n\n-----\n\n# 5. CHAPTER\n\n### Advanced Techniques\n\nTo complicate the anti-viruses detection process, this chapter describes some advanced\nfunctionalities that have been implemented in Bagheera. Thanks to these, the engine can\navoid detection with a much higher probability. First, how the encryption key is further\nobfuscated is described, as well as how the engine generates dead code to increase the load\nin the system. Finally, the custom pseudo-random number generator used by Bagheera is\npresented.\n\n#### 5.1 Encryption key concealing\n\nThe \"sliding key encryption\" technique used in the metamorphic virus MetaPHOR developed by The Mental Driller [15], is also implemented in Bagheera. Since the encryption\nkey remains unchanged throughout the encryption process, the data is encrypted uniquely.\nThe encryption key is slightly modified as the decryption progresses, rotating it via a ROR\ninstruction. Applying this permutation makes the encrypted data change even more every\ntime is encrypted, making the generated morph even more distinct from the others [23].\n\nAdditionally, the actual value of the key is not stored directly into the regKey register.\nInstead, a key modifier is used to avoid having the literal value of the key in the code.\nFirst, the k − _key_modifier value is written onto the regKey register. Next, the modifier_\nis added to the register, leaving the encryption key in the register. All in all, the final value\nstored in the register is the following:\n\n23\n\n\n-----\n\n24 Advanced Techniques\n\n_regKey = (k −_ _modifier)+_ _modifier = k +(modifier −_ _modifier) = k +_ 0 = k\n\nAfter all, the key will be stored in the register. However, the actual value of the key\nwill not appear on the code. This makes reverse-engineering the engine even harder and\ncomplicates heuristic analysis from an AV looking for the encryption key.\n\n#### 5.2 Dead code\n\nIf the code generated by Bagheera was disassembled, a basic skeleton of a decryption\nroutine would be visible. To avoid having a predictable structure, the engine inserts dead\ncode between each instruction of the generated code. This dead code uses all the registers\nthat the engine does not use so that no relevant information is destroyed.\n\nAdditionally, these dead instructions can take up to 45 different forms, that combined with\nthe 9 registers the engine lefts unused, makes up to 405 different instructions. The engine\nwill insert a dead code instruction between useful instructions with a 0.8 probability,\nmaking this polymorphic process even more unpredictable.\n\n#### 5.3 Pseudo-Random Number Generator\n\nOne of the key components to obtaining solid and diverse morphs out of the engine is\nrandomness. The obvious approach when implementing random events in computing is\nto use a pseudo-random number generator (PRNG) [24]. Most modern operating systems\nprovide an interface to a PRNG [25], but the overuse of it can trigger the heuristic alarms\nof anti-virus software. Bagheera avoids this over-use by implementing its own PRNG. This\ngenerator is taken from MethaPHOR, a Mutation Engine[1] developed by the Mental Driller\nin 2002 [26, 27]. This PRNG uses seed1 and seed2, initialized with the UNIX date and\nthe code’s first bytes respectively. On the contrary, Bagheera initializes the seed2 with\nthe user id that is executing the engine. The PRNG follows the next algorithm described in\nListing 6.\n\n1Mutation Engines are an evolution of Polymorphic Engines, which apart from encrypting the payload,\nre-write all their code, even the engine itself, changing the semantics of the code.\n\n\n-----\n\n5.4 General Overview 25\n```\nint prng(){\n    seed1 ^= (seed2 + ror_13(seed1 + seed2));\n    seed2 = (seed1 + ror_17(seed2)) ^ (seed1 + seed2);\n    return seed1 + ror_17(seed1 ^ seed2);\n}\n\n```\n**Listing 6: Pseudo-Random Number Generator C algorithm.**\n\nThe ror_XX operation denotes a circular right rotation by XX bytes. This PRNG is believed\nto have a period[2] of 40.000, which is quite as much as glibc’s generator. The second\nseed, in both cases, has low randomness, and thus, its period might not be quite large.\nHowever, the number of calls to the function is not that high to perceive a cycle in the\nnumber generation.\n\nThe PRNG is used in various steps of the engine, like the selection of the registers, dead\ncode insertion, key generation, encryption operation number selection and general equivalent instruction selection.\n\n#### 5.4 General Overview\n\nThe advanced techniques described in this chapter add new segments to the output, changing the execution flow of the decryption function described in Chapter 4. Moreover, the\n_Create encryption function and key engine phase detailed in Section 4.3.1 is also modified_\nusing some of these techniques.\n\nFigure 5.1 shows the relation between the segments that make up the basis of the function,\nthe new segments added for the advanced techniques and the phases that exert these very\ntechniques.\n\nBetween every segment present in the core structure of the function, a Dead Code segment\nis inserted. This segment generates code unrelated to the rest of the decryption function,\nor it may not generate any code at all, so the custom PRNG is used to randomize it.\n\nAdditionally, both the Decryption key setup segment and Create encryption function and\n\n2A PRNG’s period is the number of steps at which the program starts to repeat itself and generates the\nsame numbers it has done before.\n\n\n-----\n\n26 Advanced Techniques\n\nFunction Prologue Start\n\nDead code\nCustom PRNG\n\nDelta-Offset calculation\n\nDead code\nCustom PRNG\n\nCreate encryption\n\nDecryption key setup function and key\n\nCreate encryption Key modifier Custom PRNG\nfunction and key\n\nDead code\nCustom PRNG\n\nDecryption loop\n\nCustom PRNG\nSliding key\n\nDead code\nCustom PRNG\n\nFunction Epilogue\n\n**Figure 5.1: Execution flow of the decryption function with the advanced techniques modifications.**\nGreen segments correspond to those added by the advanced techniques and, white ones conform\nthe segments that make up the core structure of the decryption function.\n\n_key engine phase use the custom PRNG, to generate the key and create the encryption/de-_\ncryption opcodes respectively.\n\nFurthermore, the Key modifier technique is applied in the segment the Decryption key\n_setup segment, concealing the actual value of the key from the raw code. Finally, the_\n_Decryption loop segment is enhanced thanks to the Sliding key advanced technique. The_\nremaining segments are left unaltered.\n\n\n-----\n\n# 6. CHAPTER\n\n### Binary Infection\n\nThe main use of a Polymorphic Engine is as an addition to computer viruses, to avoid\nbeing detected by anti-virus software. A computer virus is a piece of software that can\ninfect other programs in the same machine or can traverse a network and infect other\nbinaries in different machines. Viruses modify the host’s behaviour so that these infected\nprograms contain a copy of themselves [4]. Whenever an infected program executes, also\ndoes the virus, possibly infecting more programs in the machine is run at.\n\nIn a Linux environment, de facto binary programs follow the ELF structure. ELF stands\nfor Executable and Linkable Format, used by the Linux kernel to operate objects from a\nLinking or Executable perspective [28]. The ELF structure is the roadmap used in Linux\nto understand binary files. It details how the binary should be organized and describes\nthe semantics of the different attributes the structure has. Libraries and external linked\nprograms use the linking view of the ELF file, whereas programs that are run use the\n_execution view. ELF files support both views, thus following the same specification de-_\nscribed in [29]. A representation of both perspectives is shown in Figure 6.1. Although\nvarious CPU models have their ELF specifications, this project will consider the generic\nspecification present in [30].\n\nAny ELF file consists of an ELF header, followed by the file’s actual data. The data may\ninclude a Section Header Table detailing zero or more sections, a Program Header Table\ndetailing zero or more memory segments, and the actual data referred by both header\ntables. Sections hold information for linking and reallocation, whereas segments define\nthe regions of the executable that need to be loaded to create the process image associated\n\n27\n\n\n-----\n\n28 Binary Infection\n\nLinking view Execution view\n\nELF header ELF header\n\nProgram header Program header\n\ntable (optional) table\n\nSection 1\n\nSegment 1\n\n[ ... ]\n\nSection n\n\nSegment 2\n\n[ ... ]\n\n[ ... ] [ ... ]\n\nSection header Section header\n\ntable table (optional)\n\n**Figure 6.1: ELF file format perspective types.**\n\nwith the file. A segment may contain multiple Sections.\n\nThe ELF header holds information about the binary, i.e. the file type, the required architecture and the entry point of the generated process. This information is stored in the\n`ElfXX_Ehdr[1]` members, defined in /usr/include/elf.h. This header also specifies the\nlocation, size and number of entries of the header tables.\n\nFrom the Linking point of view, the Section Header Table lets one locate all the file’s sections. This table is an array of ElfXX_Shdr structures, describing the mentioned sections.\n\nWhen viewed from the Execution view, the Program Header Table describes an array of\nsegment entries described by the ElfXX_Phdr structure. The most significant member in\neach entry, for this project’s scope, is the p_type member, which tells what kind of segment the array element describes. Some entries describe process segments like PT_LOAD,\nwhilst others give supplementary information and do not contribute to the process image\nas PT_NOTE does.\n\nVarious ELF infection methods have been developed through the years, most of them\nshared by virus writers in the Virus eXchange (VX) scene. The techniques used in these\ninfection methods are quite diverse, from section corrupting [31], to shared library call\nredirections [32], and many other advanced techniques [33, 34].\n\n1XX can take 32 or 64 values, for 32-bit or 64-bit architectures respectively. It will be referred to this\nway throughout the document.\n\n\n-----\n\n6.1 PT_NOTE to PT_LOAD infection 29\n\nBagheera is capable of infecting an ELF file, hijacking the execution flow by changing\nthe entry point, and inserting its code into some of the supplementary segments using the\n**PT_NOTE infection method. This infection method will be explained in the following**\nSection.\n\n#### 6.1 PT_NOTE to PT_LOAD infection\n\nThis infection method is based on converting a PT_NOTE segment into a PT_LOAD segment\nto inject the viral code into a binary. Most ELF Executable files (ElfXX_Ehdr.e_type\n```\n= ET_EXEC) contain one or more PT_NOTE segments, whose mere function is to store\n\n```\nauxiliary information for the binary. This information is expendable, and any binary can\nexecute properly without it. The infection method re-writes the PT_NOTE entry in the\nProgram Header table for a PT_LOAD.\n\nLoadable segments are specified by PT_LOAD elements, whose content will be loaded\ninto memory and thus, available for execution. With the proper changes to the rest of\nthe members of the entry in the Program Header Table, this section can hold viral code\nwithout corrupting the binary it resides in.\n\nAfter the infection, the viral code is appended to the end of the file, and the PT_NOTE\nsegment is pointed to it, hence loading the viral code into memory. To maintain coherence\nbetween the Linking and Execution view, so that AV software does not spot the infection\nwith ease, one of the sections inside the PT_NOTE segments is also modified so that it\nresembles a valid code section.\n\nIt must be noted that the developed infection algorithm works only with no-Position Independent Executable (PIE) binaries, such as ET_EXEC type ELF files. PIE binaries are\nloaded into random memory locations [35]. This random memory addressing makes the\ncalculation of the offsets and jumps that give the ELF back the execution flow an arduous\njob. However, it is not impossible to infect this kind of binaries. In fact, RIP calculation algorithms offer a workaround to calculating at run-time the random memory where\nthe binary has been loaded [36]. However, this technique has not been implemented in\nBagheera, thus it is not capable of infecting this kind of programs.\n\nThe custom algorithm Bagheera uses for the PT_NOTE to PT_LOAD infection method is\nbased on the one described in [37]. The algorithm is modified to add the section infection,\nwhich was not contemplated in the original algorithm. The algorithm is the following:\n\n\n-----\n\n30 Binary Infection\n\n1. Open the ELF file to be injected. If the file is not an ELF file, exit the infection\nprocess.\n\n2. Check if the file is Executable type. exit infection process if ELF file type does not\nmatch.\n\n3. Save the original entry point, e_entry.\n\n4. Parse the program header table, looking for a PT_NOTE segment.\n\n(a) Convert the PT_NOTE segment to a PT_LOAD segment.\n\n(b) Change the memory protections for this segment to allow executable instructions.\n\n(c) Point the offset of this segment to the end of the original binary, where the\nviral code will be stored.\n\n(d) Adjust the size on disk and virtual memory size of this section to account for\nthe size of the injected code.\n\n(e) Modify this segment’s alignment to match PT_NOTE alignment.\n\n5. Parse the section header table, looking for a SHT_NOTE section.\n\n(a) Convert the SHT_NOTE section to a SHT_PROGBITS section.\n\n(b) Change the memory protections for this section to allow executable and writable\ninstructions.\n\n(c) Point the offset of the section to the end of the original binary, where the viral\ncode will be stored.\n\n(d) Adjust the size on disk and virtual memory size of this section to account for\nthe size of the injected code.\n\n6. Change the entry point to the end of the file using the modified segment’s virtual\nmemory offset.\n\n7. Write the modified elements back to disk, over the original file.\n\n8. Append viral code to the end of the file.\n\n9. Patch the end of the file with instructions to jump to the previously saved original\nentry point.\n\n\n-----\n\n6.1 PT_NOTE to PT_LOAD infection 31\n\nIn Figure 6.2 how the topology of the infected ELF file changes after the algorithm is\nrun is shown. The new entry point transfers control to the payload at the beginning of\nthe execution flow. After the viral code finishes, the patch at the end of the file gives the\ncontrol back to the ELF file, leaving the program’s behaviour unaltered. The conversion\nfrom PT_NOTE to PT_LOAD means the payload is loaded into memory, the same way legit\ncode segments are.\n\nEntry point: 0xD0777 Entry point: 0xE0666\n\nentry entry\n\nELF header ELF header\n```\n                  PT_LOAD PT_LOAD\n\n```\nProgram header table `PT_LOAD` `PT_LOAD` Program header table\n```\n                  PT_LOAD PT_LOAD\n      0xD0777 PT_LOAD 0xD0777\n\n```\n.text segment .text segment\n\n.data segment .data segment\n\n.got segment .got segment\n\n.note.gnu segment `0xE0666`\n\nPayload\n\njmp 0xD0777\n\n(a) (b)\n\n**Figure 6.2: ELF file infection using PT_NOTE technique. (a) is an un-infected file and (b) is an**\ninfected file.\n\nThis infection method is quite straightforward since it does not require any advanced parsing of the ELF file, like for example, the .text section infection does [34]. On the other\nhand, since the implementation is so elementary, a sharp eye could detect the infection\nwith ease in case the binary file is examined thoroughly. This trade-off between ease of\ninfection and detection must be taken into account. However, the infection is so simple\nand effective that it outnumbers the possible drawbacks it can have. If a virus is capable\nof infecting a huge amount of programs, detection may not be effective at all.\n\nIf a regular virus spreads rapidly inside a system, but the anti-virus can detect it after\nvarious infections, it will presumably take the appropriate actions to neutralize it, like\ndisinfecting the corrupted files. This neutralization of the viral threat is possible since the\nAV can look for the virus code in the file system.\n\nHowever, if a polymorphic virus also spreads at a swift speed in a certain system, a single\ndetection of one of the multiple infected files does not endanger the rest of the infections.\n\n|try|ELF header|\n|---|---|\n\n|en ELF header PT_LOAD Program header PT_LOAD table PT_LOAD PT_LOAD 0xD0777 .text segment .data segment .got segment 0xE0666 Payload jmp 0xD0777|ELF header|en|\n|---|---|---|\n\n\n-----\n\n32 Binary Infection\n\nAs the code of each of the infected files is different, the anti-virus cannot find the code of\nthe detected file. This way, detection is evaded thanks to polymorphic techniques.\n\n\n-----\n\n# 7. CHAPTER\n\n### Detection Avoidance\n\nOne of the main motivations for developing a Polymorphic Engine is the capacity to evade\nbeing detected by anti-virus software. To test if Bagheera fulfils its purpose, some of its\noutputs have been put to the test against an AV, the open-source ClamAV to be exact.\n\nSince the PE can generate standalone encrypted executable binary code and infect existing binary programs, both methods are tested against the AV. Using signature-based\nscanning, whether ClamAV can detect a virus payload is tested. Also, in the hypothetical\ncase where the engine’s output is marked as a virus, the various polymorphic generations\nare compared, to test if the function changes enough to not be detected.\n\nTo detect the presence of viral code inside certain files, first, a signature of it must be\nobtained. Two different signatures will be provided to the AV. The first will consist of\na raw byte-code sequence corresponding to the engine’s input I, referred from now on\nas \"sig-evil-payload\". In fact, this input I is a simple assembly program named \"evil_payload\" that prints a message onto stdout using the write system call. The second_\nsignature corresponds to the byte-code sequence of the decryption function of a Oi output,\nreferred as \"sig-decrypt-fn\".\n\nWhen AV software conducts a static scan, a virus database is compared against the contents of the scanned files. If there is a match between a database entry and a portion of a\nfile, this file is tagged as a threat and pertinent risk contention actions are performed.\n\nUsing the signatures mentioned before, the following test cases have been conducted:\n\n  - Input obscuring: Detect an input I using it’s signature sig-evil-payload against a\n\n33\n\n\n-----\n\n34 Detection Avoidance\n\nregular file containing the output Oi.\n\n  - Infection concealing: Detect an input I using it’s signature sig-evil-payload against\nan ELF file infected with the output Oi.\n\n  - Morph detection: Detect the presence of a Polymorphic decryption function Oi\nwith signature sig-decrypt-fn against m files containing each of them a different\noutput O j, with 0 ≤ _j ≤_ _m._\n\nIn all of the conducted test cases, the anti-virus failed to detect the input I. None of the\nscans were able to detect I or its morphs. This evasion is possible since the byte-code\nsequence used to construct the signature does not appear in the scanned files.\n\nIn a real-world scenario, the signature of a detected virus would be added to a virus\ndatabase. If an input I or one of its morphs Oi would be added to this database, it is highly\nunlikely that an AV would detect another morph of I contained in O j. Due to the high\npolymorphism degree Bagheera produces, the morphs are so distinct and the encryption\nis so efficient that there would not be any match.\n\n\n-----\n\n# 8. CHAPTER\n\n### Project management\n\nPlanning is a key component on large scale projects of this sort. Organizing all the different stages of the project and taking into account possible drawbacks is vital. Only\nwhen this is done, potential risks as well as different development phases can be detected\nand handled ahead of time, in order to manage the most valuable resource in this kind\nof projects, that is, time. The aim of this chapter is to accurately detect all the different\naspects of the project that must be finished within a deadline so that tasks can be efficiently distributed along the project lifetime. With that, potential setbacks and delays can\nbe prevented and the project can be successfully completed in time.\n\nThe management work will be divided into three main phases, namely: project management, project development and documentation of the project. These phases cover the major aspects and the crucial decisions, as well as how difficulties have been confronted\nthrough the entire process. To help outreach the main goal of each one of them, phases\nhave been divided into tasks. These tasks constitute the focus points of each phase that\nmust be accomplished for a correct achievement of the projects main objectives and landmarks.\n\n#### 8.1 Description of the phases and their features\n\nThe following sections show how the project has developed over time, detailing how each\nof the phases has evolved during the lifetime of the thesis. Each of the sections details all\n\n35\n\n\n-----\n\n36 Project management\n\nthe work that has been done for the attainment of the main goals, as well as a sharp-eyed\nobservation of the entire process as a whole.\n\n###### 8.1.1 Management phase\n\nThe main goal of the management phase is to correctly estimate all the tasks that must be\naccomplished to reach the objectives of the project, as well as estimate the cost of each\nof the tasks in order to efficiently foresee its evolution. Major issues and delays have also\nbeen taken into consideration. These deviations can transform the projects main course,\nso special attention must be placed on these. This estimation phase is vital for the correct\ndevelopment of the project since the main end goals must be accomplished on time. Also,\nbeing able to track all the major or minor deviation throughout the projects lifetime is\nuseful for estimating its productivity. During the project and after it is completed, these\nprior estimations can be used for a comprehensive view of the project’s efficiency.\n\nAfter choosing the specific tasks that have to be carried out, the most volatile part consists\non placing them in the correct moment and for the right amount of time. Additionally, the\nproject has to be tracked periodically to ensure that the milestones set for the project are\nbeing met or if there is need for some readjustments that allow to better handle tasks for\nthe best possible outcome.\n\nWhen each of the sub-tasks has been defined, the most essential part of this phase is to\naccurately arrange the tasks in order and to estimate their possible duration. Moreover,\nthe project must be tracked periodically to ensure that its final goals are reached. Besides,\nthis phase is useful for obtaining the best possible outcome from the tasks. This is done\nby revising the tasks if some readjustments are needed. The elasticity of the planning is\nvital for a project of this sort so that unexpected deviations do not ward it off from its\nmain goal\n\nThere are three main modules that define the management of the project to take into\naccount:\n\n  - Planning: The main points of the project have been covered estimating their possible duration and the resources needed for their realization, as well as searching for\nwhen these objectives can be fulfilled and the order in which they are completed.\nThe result is a set of activities ordered and placed across the time with their respective milestones and with a risk management plan to be ready for risks with prior\nknowledge on how to avoid them. Finally, the scope of the project is determined.\n\n\n-----\n\n8.1 Description of the phases and their features 37\n\n  - Tracking: In order to check whether the objectives are being completed under the\ngiven time and to counter the present risks that can cause unexpected delays, the\nproject is analyzed during its progression. Finding new risks, modifying the milestones and creating new objectives or replacing older ones is the main purpose.\n\n  - Communication: This part joins the previous two modules and an assessment is\nconducted to evaluate how is the project progressing and to identify which tasks are\ngoing according to plan and which others are not. All of this is explained in detail to\nthe directors of the project so that they can be up to date and informed of any kind\nof alterations in the plans. These issues are handled in periodical meetings when\ncertain milestones have been finished or when a new risk has emerged. In the end,\nthe tasks until the next meeting are decided, which are usually intentions for the\nshort term.\n\n###### 8.1.2 Development phase\n\nThe project is heavily oriented towards learning the insights of polymorphic engines and\nhow can a viral program be developed in a Linux environment. Most of the development\nphase is centred on learning and understanding how these engines work and how they\nfulfil their purpose, the additions that can be done to make them more robust against\ndetection and how a develop a viral behaving program. Additionally, advanced knowledge\nin assembly language must be obtained, so that the result obtained in the project is of\nquality and precise.\n\n###### 8.1.3 Documentation phase\n\nThe last part involves the report of the project, where the most relevant knowledge and\ninformation is gathered about the research conducted, both for the theoretical part and\nfor the practical application. The theoretical aspect is very relevant, but there is not much\nwork published around this topic, and most of the information comes from particular’s\npublications in blogs and e-zines[1].\n\n1Virtual magazines about viruses and viral techniques written by underground virus-writing groups,\npopular in the VX scene.\n\n\n-----\n\n38 Project management\n\n#### 8.2 Estimations\n\nAfter covering the three phases that compose the project, the initial estimation of time\nand the finally needed amount of time to complete the tasks will be displayed. In bold,\nthe estimation for a phase is registered, while below, for each phase, each specific task of\nthe project is broken down belonging to that phase. The estimated time and the final time\nof each task are summed for finding out how much time each phase has required in Table\n8.1.\n\n**Estimated time** **Final time**\n**Management phase** **65** **55**\nPlanning 30 20\nTracking 20 18\nCommunication 15 17\n**Development phase** **105** **101**\nCreation/use of a polymorphic engine 40 50\nAddition of advanced techniques to the PE 20 13\nBinary infection development in Linux platforms 40 36\nTesting of the PE against an anti-virus 5 2\n**Documentation phase** **152** **159**\nDocumentation of the project memory 100 109\nLearn about how Polymorphic engines work 10 10\nAnalyze anti-AV techniques used in common computer viruses 5 6\nResearch on advanced polymorphic techniques 10 7\nLearn about basic assembler language and advanced notation 5 9\nAnalyze common AV techniques to detect malware 10 4\nFind out about the development of PEs in history 7 6\nLearn about ELF file infection techniques and algorithms 5 8\n**Total amount of time** **322** **315**\n\n**Table 8.1: Estimation of tasks and their final required time.**\n\n#### 8.3 Risk management plan\n\nIn all projects, deviations and unforeseen events occur and therefore a risk plan must be\ndeveloped to deal with them. However, many times these unforeseen events are due to\nfactors that were not taken into consideration in the initial risk plan, so it is necessary to\nhave a plan that has both a preventive and a proactive basis.\n\nWith a view to avoiding most of the problems arising from the calculus of the costs of\ntasks, the most important or extensive tasks have been allocated a higher estimated time\n\n|Col1|Estimated time|Final time|\n|---|---|---|\n|Management phase|65|55|\n|Planning|30|20|\n|Tracking|20|18|\n|Communication|15|17|\n|Development phase|105|101|\n|Creation/use of a polymorphic engine|40|50|\n|Addition of advanced techniques to the PE|20|13|\n|Binary infection development in Linux platforms|40|36|\n|Testing of the PE against an anti-virus|5|2|\n|Documentation phase|152|159|\n|Documentation of the project memory|100|109|\n|Learn about how Polymorphic engines work|10|10|\n|Analyze anti-AV techniques used in common computer viruses|5|6|\n|Research on advanced polymorphic techniques|10|7|\n|Learn about basic assembler language and advanced notation|5|9|\n|Analyze common AV techniques to detect malware|10|4|\n|Find out about the development of PEs in history|7|6|\n|Learn about ELF file infection techniques and algorithms|5|8|\n|Total amount of time|322|315|\n\n\n-----\n\n8.4 Deviations 39\n\nthan could be estimated initially. This is because a task with a significant time cost will\nalways be more exposed to deviations.\n\nIn order to avoid problems derived from the documentation and report phase, the dates\navailable for the presentation of final degree projects have always been taken into account.\nHowever, in the development section, the first of these dates has been taken into account\nas the final date, in order to avoid time dilation and to prevent the problems overcome and\nthe knowledge acquired from falling into oblivion.\n\n#### 8.4 Deviations\n\nThere have not been any major deviations in the project development. In fact, the overall\ntime spent on the project has been less than what was initially estimated.\n\nRegarding management, the communication with the tutor has been very fluid, resulting\nin a reduction in planning and tracking time. Also, there have been unexpected meetings\ndue to minor problems, so the final communication time has suffered a little deviation.\n\nAdditionally, the required time for tasks in the development phase where not calculated\nvery accurately, since some of the main tasks were underestimated, and many other simpler ones overestimated. In general, the actual development of the core engine has required more time than expected. On the contrary, the advanced techniques additions and\nant-virus testing have demanded less workload than expected.\n\nFinally, the lack of experience writing technical documents and the need to revise concepts\nrelated to assembly language resulted in a minor deviation in the documentation phase.\nSome areas, like ELF infection, were wider than expected, which in the end consumed\nmore time than expected at the beginning of the project.\n\n\n-----\n\n-----\n\n# 9. CHAPTER\n\n### Conclusions and future work\n\nThe motivation for the first polymorphic viruses was to evade the powerful and effective\ntechniques anti-viruses used to detect their presence. Improvements in viral technology\nhave led to more complex detection systems. In the same way, this development in antiviruses has led to stealthier and more sophisticated evasion techniques. This cat and mouse\ngame push the area into much greater levels of finesse.\n\nEven though polymorphic viruses are capable of remaining undetected, the anti-virus\ncommunity reacted and developed techniques to try and spot them. These techniques,\nsuch as code emulation, or recent usage of machine learning, are capable of unmasking\npolymorphic viruses. The obvious reaction from the virus-writing community came with\nthe development of metamorphic viruses. These viruses use a mutation engine to mutate\ntheir whole body, even the engine itself.\n\nMetamorphic viruses are way more powerful than their polymorphic counterpart, but they\nalso require a higher level of complexity. Anti-viruses also evolved with metamorphic\nviruses, and are capable of detecting them, at the expense of a great computational cost.\nViruses can use as many resources as they wish, but anti-viruses must remain user friendly,\nand cannot afford a high CPU rate. This limitation is vital, since a delay in detection of a\nfew hours or a day, can lead to a full-system infection.\n\nVirus writers know this and do not put too much effort into the development of their work.\nVirus development is often done with not too much care, and the advanced techniques\nmentioned in this document as well as many others are left out of the equation. Laziness is\nthe biggest drawback in this community since anti-viruses are so constrained by resource\n\n41\n\n\n-----\n\n42 Conclusions and future work\n\nusage that simple viruses can fulfil their goal with very little effort.\n\nTherefore, by analyzing the most used techniques in virus writing, anti-viruses can take\na step forward onto tackling these new threats, and thus enhancing the area making virus\nwriters come up with new ideas to avoid being detected.\n\nOn the other hand, most of the computer viruses developed in history have targeted\nmass consumer operating systems, like Windows. There has been little research on Linux\nviruses since the outcome virus writers can take out from it is quite sheer. Virus writers\nseek some profit, so the focus on virus development is focused on the platform with more\nexploitable users. This is why Linux is believed to be a \"virus-free platform\", something\nthis project has demonstrated it is not. Further research in Linux viruses, like it has happened in the past, will bring more robust techniques in virus detection, thus securing the\noperating system even more.\n\nLooking ahead in time, there are various aspects of the project which could be enhanced\nin future work. First of all, the robustness of the engine could be increased including more\nadvanced obfuscation techniques. The management of the keys is an aspect to improve,\nbeing able to add techniques that increase the initial entropy of the keys. In this way,\nthe randomness of the engine could be higher, proportionally increasing the degree of\npolymorphism of the result.\n\nSubsequently, the data access profile is linear, something that could set off the alarms in\nan anti-virus. To avoid this, techniques like PRIDE implemented in MetaPHOR [23] could\nbe added to Bagheera. This technique protects the virus from detection using heuristics,\naccessing the encrypted data randomly, emulating the data access profile of a regular\nprogram.\n\nFinally, as mentioned in Chapter 6, the infection method is very simple but easily detectable at the same time. Other infection algorithms and techniques can be implemented\nto achieve a more stealthy binary hijacking. Although their stealthiness is bigger than\nthe one of the PT_NOTE infection, this method does not restrict the size of the payload,\nsomething to take into account with, for example, .text segment infection methods. As\nit has been shown, the PT_NOTE method, combined with Polymorphic techniques, is capable of providing a sturdy infection. On the other hand, expanding the type of files that\ncan be infected to PIE binaries is a very valuable addition, since it enlarges the number of\nbinaries susceptible to infection greatly.\n\n\n-----\n\n### Bibliography\n\n[1] T. Chen and J.-M. Robert, “The Evolution of Viruses and Worms,” 2004.\n\n[[2] G. Smith, “The Virus Creation Labs: A Journey into the Underground.” Available at: https:](https://vx-underground.org/zines/29a/29a3/29A-3.2_A.txt)\n\n`//vx-underground.org/zines/29a/29a3/29A-3.2_A.txt, 1994.` Last accessed 14\n\nJune 2021.\n\n[[3] Dark Avenger, “The Mutation Engine.” Available at: https://web.archive.org/web/](https://web.archive.org/web/20120204065804/http://vx.netlux.org/vx.php?id=em11)\n\n`20120204065804/http://vx.netlux.org/vx.php?id=em11, 1991.` Last accessed 14\n\nJune 2021.\n\n[4] F. Cohen, “Computer viruses: Theory and experiments,” Comput. Secur., vol. 6, pp. 22–35,\n\n1987.\n\n[5] D. Spinellis, “Reliable identification of bounded-length viruses is NP-complete,” IEEE\n\n_Transactions on Information Theory, vol. 49, no. 1, pp. 280–284, 2003._\n\n[6] J. von Neumann, “First Draft of a Report on the EDVAC,” tech. rep., June 1945.\n\n[7] J. von Neumann, Theory of Self-Reproducing Automata. Champaign, Illinois: University of\n\nIllinois Press, 1967. Edited and completed by Arthur W. Burks.\n\n[8] W. Schneider, “Computer viruses: What they are, how they work, how they might get you,\n\nand how to control them in academic institutions,” Behavior Research Methods, Instruments,\n\n_& Computers, vol. 21, no. 2, pp. 334–340, 1989._\n\n[9] B. B. Rad, M. Masrom, and S. Ibrahim, “Evolution of Computer Virus Concealment and\n\nAnti-Virus Techniques: A Short Survey,” 2011.\n\n[10] Microsoft Support, “WD: Frequently Asked Questions About Word Macro\n\nViruses.” Available at: `https://web.archive.org/web/20110604162558/http:`\n```\n  //support.microsoft.com/kb/187243/en, 2006. Last accessed 07 June 2021.\n\n```\n43\n\n\n-----\n\n44 BIBLIOGRAPHY\n\n[11] P. Szor, “The Art of Computer Virus Research and Defense,” 01 2005.\n\n[12] P. Szor, The Art of Computer Virus Research and Defense. Addison-Wesley Professional,\n\n2005.\n\n[13] C. Nachenberg, “Computer Virus-Antivirus Coevolution,” Commun. ACM, vol. 40, p. 46–51,\n\nJan. 1997.\n\n[14] Mister Sandman, Jacky Qwerty, and GriYo, “PE infection under Win32.” Available\n\n[at: https://vx-underground.org/zines/29a/29a2/29A-2.3_1.txt, 1998. Last ac-](https://vx-underground.org/zines/29a/29a2/29A-2.3_1.txt)\n\ncessed 14 March 2021.\n\n[[15] The Mentall Driller, “Advanced Polymorphic Engine construction.” Available at: https://](https://vx-underground.org/zines/29a/29a5/29A-5.204.txt)\n```\n  vx-underground.org/zines/29a/29a5/29A-5.204.txt, 2000. Last accessed 14 March\n\n```\n2021.\n\n[[16] Rajaat, “Polymorphism.” Available at: https://vx-underground.org/zines/29a/](https://vx-underground.org/zines/29a/29a3/29A-3.2_A.txt)\n```\n  29a3/29A-3.2_A.txt, 1998. Last accessed 14 March 2021.\n\n```\n[17] J. Aycock, “A brief history of Just-In-Time,” ACM Computing Surveys, vol. 35, pp. 97–113,\n\n2003.\n\n[[18] P. Kobalicek, “AsmJit Project official documentation.” Available at: https://asmjit.](https://asmjit.com/)\n```\n  com/, 2021. Last accessed 02 June 2021.\n\n```\n[19] F. Cesaroni, S. Di Marco, E. Gennari, and S. Gentile, “A general purpose arithmetic logic\n\nunit,” Nuclear Instruments and Methods in Physics Research Section A: Accelerators, Spec\n_trometers, Detectors and Associated Equipment, vol. 260, no. 2, pp. 425–429, 1987._\n\n[20] C. Lindig, “Random testing of C calling conventions,” in Proceedings of the sixth interna\n_tional symposium on Automated analysis-driven debugging, pp. 3–12, 2005._\n\n[21] M. C. Bolingbroke and S. L. Peyton Jones, “Types are calling conventions,” in Proceedings\n\n_of the 2nd ACM SIGPLAN symposium on Haskell, pp. 1–12, 2009._\n\n[22] H. Lu, M. Matz, M. Girkar, J. Hubiçka, A. Jaeger, and M. Mitchell, System V Application\n\n_Binary Interface, AMD54 Architecture Processor Suplpement, 2021._\n\n[23] P. Beaucamps, “Advanced Metamorphic Techniques in Computer Viruses,” in International\n\n_Conference on Computer, Electrical, and Systems Science, and Engineering - CESSE’07,_\n\n(Venice, Italy), Nov. 2007.\n\n[24] J. Eichenauer and J. Lehn, “A non-linear congruential pseudo random number generator,”\n\n_Statistische Hefte, vol. 27, no. 1, pp. 315–326, 1986._\n\n\n-----\n\nBIBLIOGRAPHY 45\n\n[25] P. Lacharme, A. Rock, V. Strubel, and M. Videau, “The linux pseudorandom number gener\nator revisited,” 2012.\n\n[26] The Mentall Driller, “Metamorphism in practice or \"How I made MetaPHOR and what\n\n[I’ve learnt\".” Available at: https://vx-underground.org/zines/29a/29a6/29A-6.](https://vx-underground.org/zines/29a/29a6/29A-6.205.txt)\n```\n  205.txt, 2002. Last accessed 14 June 2021.\n\n```\n[[27] The Mentall Driller, “MetaPHOR v1B.” Available at: https://vx-underground.org/](https://vx-underground.org/zines/29a/29a6/29A-6.602.txt)\n```\n  zines/29a/29a6/29A-6.602.txt, 2002. Last accessed 14 June 2021.\n\n```\n[28] M. Van Oers, “Linux Viruses–ELF File Format,” Virus Bulletin Conference, vol. 123, 2000.\n\n[29] Tool Interface Standard, Executable and Linking Format (ELF) Specification. 1995.\n\n[30] The Santa Cruz Operation Inc., System V application Binary Interface, ch. 4-5. 1997.\n\n[[31] Mayhem, “The Cerberus ELF Interface.” Available at: http://phrack.org/issues/61/](http://phrack.org/issues/61/8.html#article)\n```\n  8.html#article, 2003. Last accessed 05 June 2021.\n\n```\n[[32] S. Cesare, “Shared Library Redirection via ELF PLT Infection.” Available at: http://](http://phrack.org/issues/56/7.html#article)\n```\n  phrack.org/issues/56/7.html#article, 2000. Last accessed 05 June 2021.\n\n```\n[[33] S. Cesare, “UNIX Viruses.” Available at: https://ivanlef0u.fr/repo/madchat/](https://ivanlef0u.fr/repo/madchat/vxdevl/vdat/tuunix01.htm)\n```\n  vxdevl/vdat/tuunix01.htm, 1998. Last accessed 05 June 2021.\n\n```\n[[34] S. Cesare, “UNIX ELF Parasites and virus.” Available at: https://ivanlef0u.fr/repo/](https://ivanlef0u.fr/repo/madchat/vxdevl/vdat/tuunix02.htm)\n```\n  madchat/vxdevl/vdat/tuunix02.htm, 1998. Last accessed 05 June 2021.\n\n```\n[[35] Red Hat Inc., “Position Independent Executables (PIE).” Available at: https://access.](https://access.redhat.com/blogs/766093/posts/1975793)\n```\n  redhat.com/blogs/766093/posts/1975793, 2012. Last accessed 05 June 2021.\n\n```\n[36] S01den, “Return To Original Entry Point Despite PIE,” tmp.out, vol. 1, no. 11, 2021. Avail\n[able at: https://tmpout.sh/1/11.html. Last accessed 05 June 2021.](https://tmpout.sh/1/11.html)\n\n[37] Sblip, “Implementing the PT_NOTE Infection Method in x64 Assembly,” tmp.out, vol. 1,\n\n[no. 2, 2021. Available at: https://tmpout.sh/1/2.html. Last accessed 05 June 2021.](https://tmpout.sh/1/2.html)\n\n[[38] S. Pearce, “Viral Polymorphism.” Available at: https://vx-underground.org/archive/](https://vx-underground.org/archive/VxHeaven/lib/asp00.html)\n```\n  VxHeaven/lib/asp00.html, 2003. Last accessed 14 March 2021.\n\n```\n[[39] Rogue Warrior, “Guide to improving Polymorphic Engines.” Available at: https://](https://vx-underground.org/archive/VxHeaven/lib/vrw02.html)\n\n`vx-underground.org/archive/VxHeaven/lib/vrw02.html, 1996.` Last accessed 14\n\nMarch 2021.\n\n\n-----\n\n46 BIBLIOGRAPHY\n\n[40] The Black Baron, “A general description of the methods behind a polymorph engine.” Avail\n[able at: https://vx-underground.org/archive/VxHeaven/lib/vbb01.html, 2007.](https://vx-underground.org/archive/VxHeaven/lib/vbb01.html)\n\nLast accessed 14 March 2021.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/Bagheera - an Advanced Polymorphic and Infection Engine for Linux.pdf"
    ],
    "report_names": [
        "Bagheera - an Advanced Polymorphic and Infection Engine for Linux.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "03e8b0b5-c7fb-424a-a67b-f40c3ba3f51c",
            "created_at": "2023-10-14T02:03:14.454929Z",
            "updated_at": "2025-03-27T02:02:10.125199Z",
            "deleted_at": null,
            "main_name": "Sandman",
            "aliases": [],
            "source_name": "ETDA:Sandman",
            "tools": [
                "DreamLand",
                "LuaDream"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535624,
    "ts_updated_at": 1743041406,
    "ts_creation_date": 1624181267,
    "ts_modification_date": 1624181267,
    "files": {
        "pdf": "https://archive.orkl.eu/63f445ace0f2ebc03bfa223c125d5182d6e01a01.pdf",
        "text": "https://archive.orkl.eu/63f445ace0f2ebc03bfa223c125d5182d6e01a01.txt",
        "img": "https://archive.orkl.eu/63f445ace0f2ebc03bfa223c125d5182d6e01a01.jpg"
    }
}