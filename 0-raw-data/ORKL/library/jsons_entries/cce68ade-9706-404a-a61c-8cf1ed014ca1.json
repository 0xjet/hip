{
    "id": "cce68ade-9706-404a-a61c-8cf1ed014ca1",
    "created_at": "2023-01-12T15:01:40.9301Z",
    "updated_at": "2025-03-27T02:05:22.913739Z",
    "deleted_at": null,
    "sha1_hash": "e24542ccf02c26234c2cc0467225255813685d47",
    "title": "2021-10-27 - Wslink- Unique and undocumented malicious loader that runs as a server",
    "authors": "",
    "file_creation_date": "2022-05-28T02:45:46Z",
    "file_modification_date": "2022-05-28T02:45:46Z",
    "file_size": 404200,
    "plain_text": "# Wslink: Unique and undocumented malicious loader that runs as a server\n\n**[welivesecurity.com/2021/10/27/wslink-unique-undocumented-malicious-loader-runs-server/](https://www.welivesecurity.com/2021/10/27/wslink-unique-undocumented-malicious-loader-runs-server/)**\n\nOctober 27, 2021\n\nThere are no code, functionality or operational similarities to suggest that this is a tool from\na known threat actor\n\n[Vladislav Hrčka](https://www.welivesecurity.com/author/vhrcka/)\n27 Oct 2021 - 11:30AM\n\nThere are no code, functionality or operational similarities to suggest that this is a tool from\na known threat actor\n\n\n-----\n\nESET researchers have discovered a unique and previously undescribed loader for\nWindows binaries that, unlike other such loaders, runs as a server and executes received\nmodules in memory. We have named this new malware Wslink after one of its DLLs.\n\nWe have seen only a few hits in our telemetry in the past two years, with detections in\nCentral Europe, North America, and the Middle East. The initial compromise vector is not\nknown; most of the samples are packed with MPRESS and some parts of the code are\nvirtualized. Unfortunately, so far we have been unable to obtain any of the modules it is\nsupposed to receive. There are no code, functionality or operational similarities that suggest\nthis is likely to be a tool from a known threat actor group.\n\nThe following sections contain analysis of the loader and our own implementation of its\nclient, which was initially made to experiment with detection methods. This client’s source\ncode might be of interest to beginners in malware analysis – it shows how one can reuse\nand interact with existing functions of previously analyzed malware. The very analysis could\nalso serve as an informative resource documenting this threat for blue teamers.\n\n## Technical analysis\n\nWslink runs as a service and listens on all network interfaces on the port specified in the\nServicePort registry value of the service’s Parameters key. The preceding component that\nregisters the Wslink service is not known. Figure 1 depicts the code accepting incoming\nconnections to that port.\n\n\n-----\n\n_Figure 1. Hex-Rays decompilation of the loop accepting incoming connections_\n\nAccepting a connection is followed by an RSA handshake with a hardcoded 2048-bit public\nkey to securely exchange both the key and IV to be used for 256-bit AES in CBC mode (see\nFigure 2). The encrypted module is subsequently received with a unique identifier –\nsignature – and an additional key for its decryption.\n\nInterestingly, the most recently received encrypted module with its signature is stored\nglobally, making it available to all clients. One can save traffic this way – transmit only the\nkey if the signature of the module to be loaded matches the previous one.\n\n\n-----\n\n_Figure 2. Hex-Rays decompilation of receiving the module and its signature_\n\nAs seen in Figure 3, the decrypted module, which is a regular PE file, is loaded into memory\nusing the [MemoryModule library and its first export is finally executed. The functions for](https://github.com/fancycode/MemoryModule)\ncommunication, socket, key and IV are passed in a parameter to the export, enabling the\nmodule to exchange messages over the already established connection.\n\n_Figure 3. Hex-Rays decompilation of code executing the received module in memory_\n\n\n-----\n\n## Implementation of the client\n\nOur own implementation of a Wslink client, described below, simply establishes a\nconnection with a modified Wslink server and sends a module that is then decrypted and\nexecuted. As our client cannot know the private key matching the public key in any given\nWslink server instance, we produced our own key pair and modified the server executable\nwith the public key from that pair and used the private key in our Wslink client\nimplementation.\n\nThis client enabled us to reproduce Wslink’s communication and search for unique patterns;\nit additionally confirmed our findings, because we could mimic its behavior.\n\nInitially some functions for sending/receiving messages are obtained from the original\nsample (see Figure 4) – we can use them right away and do not have to reimplement them\nlater.\n\n_Figure 4. The code for loading functions from a Wslink’s sample_\n\nSubsequently, our client reads the private RSA key to be used from a file and a connection\nto the specified IP and port is established. It is expected that an instance of Wslink already\nlistens on the supplied address and port. Naturally, its embedded public key must also be\nreplaced with one whose private key is known.\n\nOur client and the Wslink server continue by performing the handshake that exchanges the\nkey and IV to be used for AES encryption. This consists of three steps, as seen in Figure 5:\nsending a client hello, receiving the symmetric key with IV, and sending them back to verify\nsuccessful decryption. From reversing the Wslink binary we learned that the only constraint\nof the hello message, apart from size 240 bytes, is that the second byte must be zero, so\nwe just set it to all zeroes.\n\n\n-----\n\n_Figure 5. Our client’s code for the RSA handshake_\n\nThe final part is sending the module. As one can see in Figure 6, it consists of a few simple\nsteps:\n\nreceiving the signature of the previously loaded module – we decided not to do\nanything with it in our implementation, as it was not important for us\nsending a hardcoded signature of the module\nreading the module from a file, encrypting it (see Figure 7) and sending it\nsending the encryption key of the module\n\n\n-----\n\n_Figure 6. Our client s code for sending the module_\n\n_Figure 7. Our client’s code for loading and encrypting the module_\n\n[The full source code for our client is available in our WslinkClient GitHub repository. Note](https://github.com/eset/wslink-client)\nthat the code still requires a significant amount of work to be usable for malicious purposes\nand creating another loader from scratch would be easier.\n\n## Conclusion\n\nWslink is a simple yet remarkable loader that, unlike those we usually see, runs as a server\nand executes received modules in memory.\n\nInterestingly, the modules reuse the loader’s functions for communication, keys and\nsockets; hence they do not have to initiate new outbound connections. Wslink additionally\nfeatures a well-developed cryptographic protocol to protect the exchanged data.\n\n## IoCs\n\n### Samples\n\n**SHA-1** **ESET detection name**\n\n01257C3669179F754489F92947FBE0B57AEAE573 Win64/TrojanDownloader.Wslink\n\nE6F36C66729A151F4F60F54012F242736BA24862\n\n39C4DE564352D7B6390BFD50B28AA9461C93FB32\n\n### MITRE ATT&CK techniques\n\n\n-----\n\n_[This table was built using version 9 of the ATT&CK framework.](https://attack.mitre.org/resources/versions/)_\n\n**Tactic** **ID** **Name** **Description**\n\n\nEnterprise [T1587.001](https://attack.mitre.org/techniques/T1587/001/) Develop Capabilities:\nMalware\n\n\nWslink is a custom PE\nloader.\n\n\nExecution [T1129](https://attack.mitre.org/techniques/T1129/) Shared Modules Wslink loads and executes\nDLLs in memory.\n\n\n[T1569.002](https://attack.mitre.org/techniques/T1569/002/) System Services:\nService Execution\n\n\nWslink runs as a\nservice.\n\n\nObfuscated\nFiles or\nInformation\n\nCommand\nand Control\n\n\n[T1027.002](https://attack.mitre.org/techniques/T1027/002/) Obfuscated Files or\nInformation: Software\nPacking\n\n[T1573.001](https://attack.mitre.org/techniques/T1573/001/) Encrypted Channel:\nSymmetric\nCryptography\n\n\nWslink is packed with\nMPRESS and its code\nmight be virtualized.\n\nWslink encrypts traffic with\nAES.\n\n\n[T1573.002](https://attack.mitre.org/techniques/T1573/002/) Encrypted\nChannel:\nAsymmetric\nCryptography\n\n27 Oct 2021 - 11:30AM\n\n\nWslink exchanges a\nsymmetric key with\nRSA.\n\n\n### Sign up to receive an email update whenever a new article is published in our Ukraine Crisis – Digital Security Resource Center\n\n\n-----\n\n### Newsletter\n\n Discussion\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-27 - Wslink- Unique and undocumented malicious loader that runs as a server.pdf"
    ],
    "report_names": [
        "2021-10-27 - Wslink- Unique and undocumented malicious loader that runs as a server.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535700,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653705946,
    "ts_modification_date": 1653705946,
    "files": {
        "pdf": "https://archive.orkl.eu/e24542ccf02c26234c2cc0467225255813685d47.pdf",
        "text": "https://archive.orkl.eu/e24542ccf02c26234c2cc0467225255813685d47.txt",
        "img": "https://archive.orkl.eu/e24542ccf02c26234c2cc0467225255813685d47.jpg"
    }
}