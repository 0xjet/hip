{
    "id": "181efb3f-923d-414b-a11b-b44c235014f1",
    "created_at": "2023-01-12T15:08:35.569998Z",
    "updated_at": "2025-03-27T02:05:37.252655Z",
    "deleted_at": null,
    "sha1_hash": "377a9dcaec7743900d95ee8f93430acde81679b4",
    "title": "2016-09-05 - Pokémon-themed Umbreon Linux Rootkit Hits x86, ARM Systems",
    "authors": "",
    "file_creation_date": "2022-05-28T15:56:45Z",
    "file_modification_date": "2022-05-28T15:56:45Z",
    "file_size": 244995,
    "plain_text": "# Umbreon Linux Rootkit Hits x86, ARM Systems\n\n**[blog.trendmicro.com/trendlabs-security-intelligence/pokemon-themed-umbreon-linux-rootkit-hits-x86-arm-systems/](http://blog.trendmicro.com/trendlabs-security-intelligence/pokemon-themed-umbreon-linux-rootkit-hits-x86-arm-systems/)**\n\nSeptember 5, 2016\n\nThe Trend Micro Forward Looking Threat Research team recently obtained samples of a\nnew rootkit family from one of our trusted partners. We are providing a detailed analysis of\nthe rootkit, and also making the samples available to the industry to help others block this\nthreat. This rootkit family called Umbreon (sharing the same name as the Pokémon) targets\nLinux systems, including systems running both Intel and ARM processors, expanding the\nscope of this threat to include embedded devices as well. (An aside: the rootkit does appear\nto be named after the Pokémon of the same name. This Pokémon is known for hiding in the\nnight, which is an appropriate characteristic for a rootkit.) We detect Umbreon under\nthe ELF_UMBREON family. The development of Umbreon began in 2011, and we’ve seen\n[discussions about it in the cybercriminal underground since at least 2013. It has been](http://www.trendmicro.com/vinfo/us/security/threat-intelligence-center/deep-web/)\nclaimed in underground forums and IRC channels by several underground actors that\nUmbreon is very hard to detect. Our research shows how this rootkit works, and how it is\ntries to achieve stealth within a Linux environment. Umbreon is manually installed onto an\naffected device or server by the attacker. This can be done either physically or remotely (if\nthe attacker has obtained remote access to the device). Once installed, it can be used by the\nattacker to take control of the affected device. What is a ring 3 rootkit? Rootkits are\npersistent threats intended to be hard to detect/observe. Its main purpose is to keep itself\n(and other malware threats) stealthed and totally hidden from administrators, analysts, users,\nscanning, forensic, and system tools. They may also open a backdoor and/or use a C&C\nserver and provide an attacker ways to control and spy on the affected machine. There are\nvarious execution modes where code can run, with corresponding levels of access. These\nare:\n\nUser mode (ring 3)\n\n\n-----\n\nKernel mode (ring 0)\nHypervisor (ring -1)\nSystem Management Mode – SMM (ring -2)\n\nResearch on running rookits within certain chips on motherboards or other devices has been\ncarried out; such a rootkit would run in ring -3. The lower the level a piece of code runs, the\nharder it is to detect and mitigate. However, this does not mean a ring 3 rootkit is simple or\neasy to remove. A ring 3 rootkit (or usermode rootkit) does not install kernel objects onto the\nsystem, but hooks functions from core libraries that are used by programs as interfaces to\nsystem calls that run important operations in a system such as reading/writing files,\nspawning processes, or sending packets over the network. It is perfectly possible to spy on\nand change the way things are done within an operating system, even from user mode. On\nLinux, when a program calls the printf() function there are other cascaded functions called by\nthis one like _IO_printf() and vprintf() that are in the same library. All of these end up calling\nthe write() system call. While a ring 0 rootkit would hook this system call in kernel mode (and\nthis require the insertion of a kernel object/module into the system), a ring 3 rootkit would\nhook one of the intermediary library functions in userland, removing the need for native code\nin the kernel (something which would be fairly difficult to achieve). Cross-platform features\nWe were able to successfully get Umbreon running on three different platforms: x86, x86-64\nand ARM (Raspberry Pi). The rootkit is very portable because it does not rely on platformspecific code: it is written in pure C, except for some additional tools that are written in\nPython and Bash scripting. Our analysis indicates that this was by design: Umbreon's did\nthis intentionally so that it could easily support the three platforms noted above. Backdoor\n**_authentication During installation, Umbreon creates a valid Linux user that the attacker can_**\nuse with a backdoor into the affected system. This backdoor account can be accessed via\nany authentication method supported by Linux via pluggable authentication modules (PAMs),\nincluding SSH. This user has a special GID (group ID) that the rootkit checks to see if the\nattacker is attempting to access the system. It is not possible to see this user in files\nlike /etc/passwd because libc functions are hooked by Umbreon. The picture below shows\nthe welcome screen shown when this backdoor account is accessed via SSH:\n\n_Figure 1. SSH login screen (Click to enlarge)_\n\n**_Espeon backdoor component This is a non-promiscuous libpcap-based backdoor written_**\nin C that spawns a shell when an authenticated user connects to it. (The attackers also\nnamed this component after a Pokémon - this time Espeon, which has pronounced ears.) It\ncan be instructed to establish a connection to an attacker machine, functioning as a reverse\nshell to bypass firewalls. Espeon captures all TCP traffic that reaches the main Ethernet\ninterface of the affected computer. Once it receives a TCP packet with some special field\nvalues, it then connects back to the source IP of this TCP packet. These are the values that\nEspeon watches out for:\n\nSequence number (SEQ) is 0xc4\nAcknowledgement number (ACK) is 0xc500\n\n\n-----\n\nIP Identification (ID) is 0x0fb1\n\nThese conditions would all be set by the attacker in a packet he would send to the affected\nmachine. If all three values match, the backdoor connects back to the sending IP\naddress. Here is the disassembled of got_packet() function, where this comparison is\nperformed:\n\n_Figure 2. Code sample (click to enlarge)_\n\n**_Hiding pre-loaded configuration files from system call tracing System call tracing is a_**\ntechnique used by a very popular Linux command line tool called strace. It uses the ptrace()\nsyscall to inspect the syscall parameters and return values of other executable files. As\nUmbreon uses an /etc/ld.so.<random> file to instruct the loader to load itself before any other\nlibrary used by ELF binaries, it can disguise itself from administrators that use strace by\nhooking vprintf(), __vfprintf_chk(), and fputs_unlocked(). These are used by different\nversions of strace to write to a given file descriptor. The following screenshot shows the code\nthat does this for vprintf() in the strace.so component:\n\n_Figure 3. Code sample(click to enlarge)_\n\n_wrapper_200da0_6b0 ends up in the strstr() function. Here, the pre-loaded configuration file_\nis /etc/ld.so.NfitFd2 so if any argument passed to vprintf() function contains this text, it will be\nreplaced by /etc/ld.so.preload. An analyst may then believe that this is the file being used by\nthe loader. The screenshot below shows the strings used by this routine:\n\n_Figure 4. Code sample_\n\nThis component also unsets the LD_PRELOAD environment variable so analysts can’t hook\nthe malicious functions. Hiding packets Umbreon also hooks the libpcap functions\n_got_packet() and pcap_loop() and prevents them from returning any information about TCP_\npackets with ports between the lowest port number and highest port number specified in its\nconfiguration file. An analyst capturing network traffic with tools like tcpdump on the\nmachine wouldn't be able to capture any backdoor traffic. Umbreon's implementation\nUmbreon acts as a library that imitates the glibc (GNU C Library). It creates a file called\n_/etc/ld.so.<random> that, according to the_ [official documentation, has the following function:](http://man7.org/linux/man-pages/man8/ld.so.8.html)\n```\n   /etc/ld.so.preload       File containing a whitespace-separated\n  list of ELF shared objects to be loaded before the program.\n\n```\nOriginally, the ELF loader will look for a /etc/ld.so.preload file as the documentation clearly\nstates. However, we found that Umbreon also patches the loader library (/lib/x86_64-linux_gnu/ld-2.19.so as an example) to use /etc/ld.so.<random> instead, where <random> is a 7-_\ncharacter-string, matching the length of \"preload\". Every library path in this file will be loaded\n\n\n-----\n\nbefore any other ELF program is launched. Inside this file, Umbreon puts the path for its own\nmain library, which contains lots of functions matching the names\nof glibc functions. The location of this main library is:\n\n/usr/share/libc.so.<random>.${PLATFORM}.ld-2.22.so\n\n${PLATFORM} is replaced by the loader with one of the following highlighted values,\ndepending on the target architecture:\n\n/usr/share/libc.so.<random>.v6l.ld-2.22.so (for ARM)\n/usr/share/libc.so.<random>.x86_64.ld-2.22.so (for x86-64)\n/usr/share/libc.so.<random>.i686.ld-2.22.so  (for x86)\n\nHowever, because Umbreon is manually installed onto a compromised machine, this default\npath may vary. The functions hooked and implemented by the main Umbreon library are:\n\n__fxstat\n__fxstat64\n__lxstat\n__lxstat64\n__syslog_chk\n__xstat\n__xstat64\naccess\naudit_log_acct_message\naudit_log_user_message\naudit_send\nchdir\ncheck_and_fix_ldso\ncheckpw\nchmod\nchown\ncleanup\ndlinfo\ndlsym\nesh\nexecve\nexecvp\nfake_preload_fail\nfchmod\nfchown\nfchownat\nfdopendir\nfilesize\nfind_dlsym\nfind_sym\n\n\n-----\n\nfopen\nfopen64\nfstat\nfstat64\nget_hideports\nget_my_procname\nget_procname\ngetpath\ngetpgid\ngetpriority\ngetpwnam\ngetpwnam_r\ngetpwuid\ngetsid\ngetspnam\nis_dynamic\nis_hideport\nis_ldso32\nis_ldso64\nis_really\nkill\nlchown\nlink\nlogin\nlstat\nlstat64\nnetstat\nopen\nopen64\nopenat\nopendir\npam_acct_mgmt\npam_authenticate\npam_open_session\npam_prompt\npam_vprompt\npcap_loop\nprocstatus\nprocstatus_o\npututline\npututxline\nrclocal\n\n\n-----\n\nread\nreaddir\nreaddir64\nreadlink\nrecover_dirname\nrecover_filename\nreinstall_self\nrename\nrmdir\nsched_getaffinity\nsched_getparam\nsched_getscheduler\nsched_rr_get_interval\nsetgid\nsetregid\nsetresgid\nsocket\nspoof_maps\nspoof_smaps\nstat\nstat64\nsxor\nsymlink\nsysinfo\nsyslog\nunfuck_linkmap\nunlink\nunlinkat\nwrite\n\nMany of these function names match existing libc function names. As Umbreon's library is\nloaded before any other user library when an executable in launched, the loader will resolve\nthese functions' addresses instead of the ones in libc. This way,an executable will call the\nmalicious functions invisibly. These malicious functions then inspect the arguments they\nreceive before calling the real ones. Similarly, the output of every command may have been\nmodified before the user sees it. It effectively functions as an in-the-middle attack, modifying\nboth the input and output of system functions. Users cannot trust the outputs of system\ncommands like ps, ls, top, and pstree (among others). Because they all use these libc\nfunctions, they will all produce modified outputs. How to detect Umbreon Most of the tools\nyou will find in Linux are written in C. Even programs written in Perl, Python, Ruby, PHP and\nother scripting languages end up calling GNU C Library wrappers as their interpreters are\nalso written in C. Because Umbreon library hooks glibc functions, creating a reliable tool to\ndetect Umbreon would require a tool that doesn't use glibc. One way is to develop a small\n\n\n-----\n\ntool to list the contents of the default Umbreon rootkit folder using Linux kernel syscalls\ndirectly. This bypasses any malicious C library installed by Umbreon. If the output contains\none or more files with names starting with libc.so followed by a random integer, this is the red\nflag that suggests Umbreon is installed in the machine. We have also created YARA rules\n[that detect Umbreon, which can be downloaded here. Removal Instructions Umbreon is a](http://documents.trendmicro.com/assets/20160905-umbreon-yara.txt)\nring 3 (user level) rootkit, so it is possible to remove it. However, it may be tricky and\ninexperienced users may break the system and put it into an unrecoverable state. If you are\nbrave enough to proceed, the easiest way is to boot the affected machine with Linux LiveCD\nand follow the steps:\n\n1. Mount the partition where the /usr directory is located; write privileges are required.\n2. Backup all the files before making any changes.\n3. Remove the file /etc/ld.so.<random>.\n4. Remove the directory /usr/lib/libc.so.<random>.\n5. Restore the attributes of the files /usr/share/libc.so.<random>.<arch>.*.so and remove\n\nthem as well.\n6. Patch the loader library to use /etc/ld.so.preload again.\n7. Umount the partition and reboot the system normally.\n\nHere is a real-life example (please notice file names will vary as they are randomly chosen\nby the malware). In the following case, /dev/sda1 is the partition containing the /usr directory.\n```\n   # mount /dev/sda1 /mnt # rm -f /mnt/etc/ld.so.khVrkEQ # rm -rf\n  /mnt/usr/lib/libc.so.41762810374176281037/ # chattr -ai\n  /mnt/usr/share/libc.so.4176281037.* # rm -f\n  /mnt/usr/share/libc.so.4176281037.* # sed -i\n  's:/etc/ld\\.so\\.khVrkEQ:/etc/ld.so.preload:' /lib/x86_64-linux-gnu/ld  2.19.so # umount /mnt # reboot\n\n```\nIn this case, the chattr command is necessary because Umbreon libraries have a (appendonly) and i (immutable) attributes set. Indicators of Compromise The following file samples\nare tied to this threat:\n\nb5e68f8e23115bdbe868d19d09c90eb535184acd — /.bashrc\n73ddcd21bf05a9edc7c85d1efd5304eea039d3cb — /bin/pkg\n48a6e43af0cb40d4f92b38062012117081b6774e — /bin/espeon-shell (detected\nas BKDR_UMREON.A)\n88aea4bb5e68c1afe1fb11d55a190dddb8b1586f —/bin/unhide-self\n73ddcd21bf05a9edc7c85d1efd5304eea039d3cb — /bin/zypper and ./bin/emerge\n42802085c28c0712ac0679c100886be3bcf07341 — /bin/umbreon.py\n66d246e02492821f7e5bbaeb8156ece44c101bbc — /bin/espeon (detected\nas ELF_UMREON.A)\n73ddcd21bf05a9edc7c85d1efd5304eea039d3cb —/bin/yum\n4f6c6d42bdf93f4ccf68d888ce7f98bcd929fc72 — /bin/spytty\n73ddcd21bf05a9edc7c85d1efd5304eea039d3cb — /bin/apt-get\n1f1ab0a8e9ec43d154cd7ab39bfaaa1eada4ad5e — /bin/.x\n\n\n-----\n\n81ad3260c0fc38a3b0f65687f7c606cb66c525a8 — /.init-append\n7b10bf8187100cdc2e1d59536c19454b0c0da46f — /.umbreon-ascii\n96d5e513b6900e23b18149a516fb7e1425334a44 — /.profile\n851b7f07736be6789cbcc617efd6dcb682e0ce54\n— /usr/share/libc.so.2284441204.i686.ld-2.22.so (detected as ELF_UMREON.A)\ne2bc8945f0d7ca8986b4223ed9ba13686a798446\n— /usr/share/libc.so.2284441204.x86_64.ld-2.22.so (detected as ELF_UMREON.A)\n17b42374795295f776536b86aa571a721b041c38 — /.ldso/strace.so (detected\nas ELF_UMREON.A)\n394fae7d40b0c54c16d7ff3c3ff0d247409bd28f —/promptlog\n738ac5f6a443f925b3198143488365c5edf73679 —/hideports\n022be09c68a410f6bed15c98b63e15bb57e920a9 — espeon (ARM version, detected\nas ELF_UMREON.B)\n3762c537801c21f68f9eac858ecc8d436927c77a — pkg (ARM version, detected as\nELF_UMREON.B)\n2cd24c5701a7af76ab6673502c80109b6ce650c6 — strace.so (ARM version, detected\nas ELF_UMREON.B)\n358afd4bd02de3ce1db43970de5e4cb0c38c2848 — umbreon.so (ARM version,\ndetected as ELF_UMREON.B)\n\n**_Update as of September 15, 2016, 8:00 PM PDT The developer of Umbreon has been in_**\ntouch with us since the publication of this post. He told us that he started work on Umbreon\nin 2011, basing it off three existing rootkits: Jynx, Jynx2, and Azazel. All three are publicly\nknown Linux rootkits. He has expressed his sadness and displeasure at how his code has\nsince been abused by various malicious threat actors.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-09-05 - Pokémon-themed Umbreon Linux Rootkit Hits x86, ARM Systems.pdf"
    ],
    "report_names": [
        "2016-09-05 - Pokémon-themed Umbreon Linux Rootkit Hits x86, ARM Systems.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536115,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1653753405,
    "ts_modification_date": 1653753405,
    "files": {
        "pdf": "https://archive.orkl.eu/377a9dcaec7743900d95ee8f93430acde81679b4.pdf",
        "text": "https://archive.orkl.eu/377a9dcaec7743900d95ee8f93430acde81679b4.txt",
        "img": "https://archive.orkl.eu/377a9dcaec7743900d95ee8f93430acde81679b4.jpg"
    }
}