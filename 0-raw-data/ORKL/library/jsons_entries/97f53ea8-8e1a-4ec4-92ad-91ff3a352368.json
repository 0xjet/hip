{
    "id": "97f53ea8-8e1a-4ec4-92ad-91ff3a352368",
    "created_at": "2023-01-12T15:05:15.769044Z",
    "updated_at": "2025-03-27T02:05:43.843811Z",
    "deleted_at": null,
    "sha1_hash": "cbc7044a9865cbfae44843df508e959a3719cd69",
    "title": "2022-06-09 - Finding Vulnerabilities with VulFi IDA Plugin",
    "authors": "",
    "file_creation_date": "2022-10-02T12:21:34Z",
    "file_modification_date": "2022-10-02T12:21:34Z",
    "file_size": 1111348,
    "plain_text": "# Finding Vulnerabilities with VulFi IDA Plugin\n\n**[accenture.com/us-en/blogs/security/finding-vulnerabilities-vulfi-ida-plugin](https://www.accenture.com/us-en/blogs/security/finding-vulnerabilities-vulfi-ida-plugin)**\n\nShare\n\nIn March, we published an IDA Pro plugin that Accenture Security teams use to find\nvulnerabilities and other potentially interesting issues in the compiled binaries. The plugin\nprovides a Python-based query language with which users can look for calls to specific\nfunctions that match criteria specified in the query. In this article, we will look at the highlevel theory behind this tool and demonstrate its use on a practical example of finding\nvulnerabilities identified as CVE-2022-26413 and CVE-2022-26414.\n\n**How the plugin works**\n\nWhen doing vulnerability research, it is quite common to look for a call to certain functions.\nAnd while cross-references shown by IDA are a good starting point, the idea for this plugin\ncame from the need to filter thousands of uninteresting calls to a function and find only\nthose that might be valuable from the security perspective.\n\nTo give a very generic example, imagine a binary file that calls a function like strcpy a\nthousand times. Out of all these occurrences, all use a static string as a second parameter,\nwith only 50 exceptions Without the way of filtering the function calls based on the\n\n\n-----\n\nproperties of the parameters that are passed to them (and their return value), the analyst\nwould have to investigate all 1,000 cross-references. The worst part about this is that most\nof them would have to be dismissed as uninteresting due to the use of static values in the\nsecond argument.\n\n[This is the kind of case that’s perfect for a plugin developed using the IDAPython API. The](https://www.hex-rays.com/products/ida/support/idapython_docs/)\ngoals for the plugin are quite easy to define. We want an architecture-agnostic way of\nfiltering function calls based on the properties of the parameters and returned values. The\nproperty could be, for example, whether the parameter is a constant value. In that case, we\nalso want a way to check for specific constant values.\n\nIDA offers a plethora of functions for processing disassembly as well as decompiler output.\nIn cases where the decompiler could be used, the plugin will work much better, because the\nHex-Rays processing that happens under the hood allows the VulFi plugin to access much\nmore accurate values for function call parameters. For the cases where the disassembly is\nthe only option, the task is a bit harder. If possible, the VulFi will try to apply function type for\n[all known functions as defined in this file prior to running the search. With this, it will](https://github.com/Accenture/VulFi/blob/main/vulfi_prototypes.json)\nleverage the possibility to locate the assembly instruction that is responsible for loading the\nparameter and try to deduce its value from it. In case that the type-system is not supported\nfor the architecture, the VulFi will just mark all the cross-references for the function and put\nthem in the table.\n\nWith the search concluded, the results are placed in VulFi view. Since the plugin was\ndeveloped with an assumption that search results will likely be numerous, a simple tracking\nand commenting feature was added to the plugin and will be demonstrated below in a\npractical walkthrough of the usage.\n\n**An example usage of the VulFi plugin**\n\n**1. Finding the right target**\n\nFor the practical example, I will use a firmware of the Zyxel VMG3312-T20A router that I\nhappen to have in my drawer. The manufacturer announced some time ago that this model\nhad reached the end of its life. Nonetheless, according to internal validations performed by\nZyxel, the discovered vulnerabilities also affect several products that are still supported, as\n[mentioned here.](https://www.zyxel.com/support/OS-command-injection-and-buffer-overflow-vulnerabilities-of-CPE-and-ONTs.shtml)\n\n[The firmware for the router could be downloaded from here. With the firmware image](https://www.zyxel.com/support/download_landing/product/vmg3312_t20a_14.shtml?c=gb&l=en&pid=20160824200000&tab=Firmware&pname=VMG3312-T20A)\ndownloaded, we can inspect its content. As shown below, the most interesting file is\n_V530ABFX5C0.bin (mainly because of its size, but also because of the filename extension)._\n\n\n-----\n\nThe V530ABFX5C0.bin file can be easily processed using a binwalk utility. This will\nsuccessfully detect and extract a SquashFS file system.\n\nThe extracted contents of the file system probably contain many interesting files, however,\nsince we know that the router in question has a feature-packed web interface, the best\nplace to try the plugin would be the file /bin/zhttpd. This file implements the logic of handling\nthe requests coming from the user browser and thus provides a convenient way for us to\ntest any potential issues.\n\n**2. Initial peek at the binary**\n\nThe initial analysis of the binary starts obviously by loading it in the IDA Pro. After the\nanalysis is completed, we can see that the binary is an ELF file for a 32-bit big-endian MIPS\narchitecture.\n\n\n-----\n\nAfter looking around the used functions, we can see that the binary is using function\n_[system, which is used for executing OS commands.](https://linux.die.net/man/3/system)_\n\nTo make life for VulFi easier, we must set the function type according to the official\ndocumentation (the dialog for type configuration can be invoked by pressing Y).\n\nWe can also check the current count of the cross-references to this function. As shown\nbelow, this binary contains a total of 69 unique calls to function system.\n\n\n-----\n\n**3. Using VulFi**\n\nLet’s see if VulFi can save us some time by only showing us those calls in which the first\nand only argument of the system function is set to a non-static value. To find out, we must\nset a custom rule that will look for such occasions (this rule is also in the default set,\nhowever, for the sake of the article, let us recreate it). To initiate a setup of the new rule, set\nIDA view to the body of the function that you want to look for, right-click anywhere in the\nbody (in this case we right-click the system label) and select the option “Add current\nfunction to VulFi”.\n\n\n-----\n\nSelecting this option will spawn a simple dialog with two required fields. The first field is the\nname of the new custom rule so that you can easily find it amongst other results that might\nalready be in the result list. The second field is where the magic happens; that is where you\nspecify the rule. Since we are looking for any occurrence of the call to system function\nwhere the first parameter is not constant value the rule will have a form as shown in the\nscreenshot below:\n\nA brief description of the above rule is likely required at this point. We start with the not\nkeyword to negate the expression. We are looking for the first parameter, that is why we use\nan array of parameters called param and we use the first item in the list ([0]). The state of\nthe parameter that we are interested in is whether it is a constant. This can be achieved by\ncalling a function is_constant() on the parameter object, the negation which we put in the\nbeginning will make sure that we only get results where the is_constant() function returned\n_False. As you may have noticed, the syntax is very similar to conditions as written in_\nPython. In fact, this is a Python code, it is just that several functions have been prepared for\nyou to build a sort-of query language. If you would like to find out more about available\n[functions, please see the README file in the official repository of this plugin.](https://github.com/Accenture/VulFi)\n\nLet us get back to the example now. When you press the Run button, VulFi will see if the\ndecompiler for the given architecture is available and if it is, it will automatically use it.\nTherefore, you will see progress pop-ups mostly linked to the decompiler processing the\nfunctions. After the process of searching is completed, you will be presented with VulFi\nresults view. In the case of the zhttpd binary and the search for the rule defined above, we\ncan see that thanks to VulFi, we are left with only 31 out of the original 69 cross-references.\n\n\n-----\n\n**4. Inspecting a vulnerable code (CVE-2022-26413)**\n\nTo answer the question in the subtitle for this section, we can just look at the VulFi results.\nAmongst all the detected calls to system function let’s have a look at function sub_40C3E8.\nThis can be easily done by double-clicking the line with this function in VulFi, this will\nautomatically make the main IDA view switch to the location where the call was identified.\n\n\n-----\n\nPlease note that for the sake of better readability, the remainder of this article uses the\ndecompiler in IDA. As you can see below, the marked call to system function does indeed\naccept dynamic argument.\n\nThe vulnerability occurs on line 74 in the above snippet. To reach to that code, you must\ninvoke action import_ca (not shown in here). This is done by sending a multipart request\nwith the CA file in the parameter called certImportFileName. As can be deduced from the\ncode on line 69, the name of the file sent in the multipart request will be used in the sprintf\n(CVE-2022-26414) function to build a command string (line 72) that is passed to the system\nfunction on line 74.\n\n\n-----\n\nSince we have identified a place that is most likely vulnerable, we can go back to VulFi view\nand use a right click on the given item to either set a custom comment or to set a status for\nthe item to one of the available options (False Positive, Suspicious or Vulnerable). This\nfeature was added to make tracking of the progress easier as it is assumed that larger\nbinaries will take multiple days to process.\n\n**5. Exploitation**\n\nFinally, we should prove the exploitability of the issue that we just found. That requires\ncapturing a request in the intercepting proxy of our choice (BurpSuite is used in the\nexample) and sending it with a modified filename parameter. The value set in this\nparameter in the below screen capture instructed the router to execute the ls -l command\nand pass the result of it to the attacker machine via nc connection. As can be seen by the\nhighlighted sections, this was successful and thus a possibility to inject OS commands was\nproven.\n\n\n-----\n\n**Vulnerability Disclosure Process**\n\nThe following dates are an important milestone related to the discovered vulnerabilities.\n\n13 January 2022 – Issues reported to Zyxel\n16 January 2022 – Vulnerabilities were acknowledged to be existent in the End-of-Life\nproduct\n12 April 2022 – Advisory published by Zyxel (https://www.zyxel.com/support/OScommand-injection-and-buffer-overflow-vulnerabilities-of-CPE-and-ONTs.shtml)\n\n**_Accenture Security is a leading provider of end-to-end cybersecurity services, including_**\n_advanced cyber defense, applied cybersecurity solutions and managed security operations._\n_We bring security innovation, coupled with global scale and a worldwide delivery capability_\n_through our network of Advanced Technology and Intelligent Operations centers. Helped by_\n_our team of highly skilled professionals, we enable clients to innovate safely, build cyber_\n_[resilience and grow with confidence. Follow us @AccentureSecure on Twitter,](https://twitter.com/accenturesecure)_ [LinkedIn or](https://www.linkedin.com/showcase/accenture_security/)\n_visit us at_ [accenture.com/security.](http://www.accenture.com/security)\n\nAccenture, the Accenture logo, and other trademarks, service marks, and designs are\nregistered or unregistered trademarks of Accenture and its subsidiaries in the United States\nand in foreign countries. All trademarks are properties of their respective owners. All\nmaterials are intended for the original recipient only. The reproduction and distribution of\nthis material is forbidden without express written permission from Accenture. The opinions,\nstatements, and assessments in this report are solely those of the individual author(s) and\n\n\n-----\n\ndo not constitute legal advice, nor do they necessarily reflect the views of Accenture, its\nsubsidiaries, or affiliates. Given the inherent nature of threat intelligence, the content\ncontained in this article is based on information gathered and understood at the time of its\ncreation. It is subject to change. Accenture provides the information on an “as-is” basis\nwithout representation or warranty and accepts no liability for any action or failure to act\ntaken in response to the information contained or referenced in this report.\n\nCopyright © 2022 Accenture. All rights reserved.\n\nMartin Petran\n\nAssociate Manager – Technology\n\nMartin is member of the Embedded Systems Security Assessment team specializing in\nreverse engineering and firmware exploitation.\n\nSubscription Center\n\nSubscribe to Security Blog\nSubscribe to Security Blog\n\nSubscribe\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-09 - Finding Vulnerabilities with VulFi IDA Plugin.pdf"
    ],
    "report_names": [
        "2022-06-09 - Finding Vulnerabilities with VulFi IDA Plugin.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535915,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1664713294,
    "ts_modification_date": 1664713294,
    "files": {
        "pdf": "https://archive.orkl.eu/cbc7044a9865cbfae44843df508e959a3719cd69.pdf",
        "text": "https://archive.orkl.eu/cbc7044a9865cbfae44843df508e959a3719cd69.txt",
        "img": "https://archive.orkl.eu/cbc7044a9865cbfae44843df508e959a3719cd69.jpg"
    }
}