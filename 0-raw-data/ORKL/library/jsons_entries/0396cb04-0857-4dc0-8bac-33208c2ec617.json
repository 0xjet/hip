{
    "id": "0396cb04-0857-4dc0-8bac-33208c2ec617",
    "created_at": "2023-03-03T02:05:33.239208Z",
    "updated_at": "2025-03-27T02:05:47.821277Z",
    "deleted_at": null,
    "sha1_hash": "4f8f174774e6c81f3cff03f17fc101e6ed06088d",
    "title": "2023-02-18 - TrueBot Analysis Part II - Static unpacker",
    "authors": "",
    "file_creation_date": "2023-03-01T09:33:16Z",
    "file_modification_date": "2023-03-01T09:33:16Z",
    "file_size": 1075066,
    "plain_text": "# TrueBot Analysis Part II - Static unpacker\n\n**[malware.love/malware_analysis/reverse_engineering/2023/02/18/analyzing-truebot-static-unpacking.html](https://malware.love/malware_analysis/reverse_engineering/2023/02/18/analyzing-truebot-static-unpacking.html)**\n\nFebruary 18, 2023\n\n18 Feb 2023 ¬ª [malware_analysis,](https://malware.love/category/malware_analysis) [reverse_engineering](https://malware.love/category/reverse_engineering)\nIn my [last post, I described how to identify the decryption key, the encrypted blob and how](https://malware.love/malware_analysis/reverse_engineering/2023/02/12/analyzing-truebot-packer.html)\nthe decryption algorithm works in a packed TrueBot sample. Doing this manually with help\nof your favorite Disassembler/Decompiler is quite easy, but I guess, that‚Äôs not why you are\nhere. What we want is a static unpacker, written in Python, without using any external tools\nor too many dependencies (except Malduck ü¶Ü).\n\nDepending on the sample you‚Äôre analyzing, writing a static unpacker can be a challenging\ntask, especially if you‚Äôre dealing with several layers of encryption, junk code, control-flow\nobfuscation and so on.\n\nFortunately, TrueBot doesn‚Äôt make it particularly difficult for us here. Nevertheless, the code\nwill end up looking a bit ugly since we want to write an unpacker for all samples available to\nus. But maybe that is just because of my programming style. By the way, I do not use a lot\nof error handling in my code so please be merciful.\n\nIn a nutshell, the basic methodology for our code looks as follows:\n\n1. Identify the encrypted blob, ideally with its length.\n2. Locate and parse the decryption key and the value for the AND operation.\n3. Decrypt and save the dump.\n\nAs I already described in Part I of my analysis, the most common variant in those packed\nsamples is a DLL Export which directly calls the decryption function with the offset of the\ndecrypted blob and the blob size as arguments.\n\nThis call can be identified easily and without false positives, at least in the samples I\nanalyzed. In order to accomplish this, we use Malduck, our ‚Äúducky companion in malware\nanalysis journeys‚Äù.\n\n\n-----\n\nTo find the call, we utilize Malduck s built-in Yara wrapper, looking for the two pushes and\nthe beginning of the call, see the green box in the screenshot above. Since we don‚Äôt know\nthe exact size of the blob, we‚Äôre using the wildcards ?? and estimate that the size is\nbetween 0x40000 and 0x6FFFF.\n```\npe = malduck.procmempe.from_file(filename=abs_file_path, image=True)\n\ns1 = YaraString('68 ?? ?? (04 | 05 | 06) 00 68 ?? ?? ?? ?? E8',\n\n          type=YaraString.HEX)\n\ndecrypt_blob_call = Yara(name=\"decrypt_blob_call\", strings={\"call\": s1},\ncondition=\"all of them\")\n\nmatch = pe.yarav(ruleset=decrypt_blob_call)\n\noffset = None\n\nif match:\n\n  for _, v in match.elements[\"decrypt_blob_call\"].elements.items():\n\n    offset = v[0] # there should only be one match (hopefully)\n\n```\nOur file is loaded as memory-mapped PE file, so we will use yarav() to perform yara\nmatching region-wise.\n\nThis will also help us to debug more easily because we can confirm matching offsets in our\nDisassembler (check the hex value against the virtual address in the screenshot above).\n\nSince we are now (0x10001620 in this example) near the position where the decryption\nfunction is called, we can determine the length and the virtual address of the encrypted blob\nand also get the virtual address of the decryption function.\nTo get the blob size, we need to read 4 bytes, starting from the identified address before +1\n(because of the push opcode), see the screenshot below.\n\n[You can either call pe.readv(addr, length) or just use Malduck‚Äôs handy helper functions](https://malduck.readthedocs.io/en/latest/string.html?highlight=uint32v#malduck.uint32)\nlike uint32v(addr) which for example reads an unsigned 32-bit value at the given address.\n```\nblob_size = pe.uint32v(vaddr + 1) #Read unsigned 32-bit value at address.\n\n```\n\n-----\n\nGetting the virtual address where the decrypted blob is stored, works similar.\n```\nblob_va = pe.uint32v(vaddr + 1 + 4 + 1)\n\n```\nNow we only need the key and the value for the ‚ÄúAND‚Äù operation to decrypt the blob. The\napproach is similar to the one already described above. We know the virtual address of the\ndecryption functions and have an approximate idea how big the function is. Therefore, we\ncan now search for the required information in between this function, see the code to find\nthe key [here and to find the value for the ‚ÄúAND‚Äù operation here.](https://github.com/lazydaemon/mw_analysis/blob/main/truebot/truebot_unpack.py#L9)\n\nAfter collecting the blob and the decryption material, we should be able to decrypt the blob\n[with help of the decryption function mentioned in Part I of this series.](https://malware.love/malware_analysis/reverse_engineering/2023/02/12/analyzing-truebot-packer.html)\n\n\n-----\n\n[I ve published the whole code on github and tested against all the samples available to me.](https://github.com/lazydaemon/mw_analysis/tree/main/truebot)\nWhen running the script on all samples, it should look like this.\n\nLike most static unpackers/config extractors/etc., this code might break easily if some bytes\nat specific positions change and you will probably have to continuously adapt the Unpacker\nto new samples. I am therefore very interested in new samples. If someone has some,\nplease get in touch with me.\nNow that we have a bunch of unpacked samples, the next post in this series will focus on\nTrueBot‚Äôs capabilities before we then write a Config Extractor using Python and Malduck.\n\n**Related Posts**\n\n[TrueBot Analysis Part I - A short glimpse into packed TrueBot samples (Categories:](https://malware.love/malware_analysis/reverse_engineering/2023/02/12/analyzing-truebot-packer.html)\n[malware_analysis,](https://malware.love/category/malware_analysis.html) [reverse_engineering)](https://malware.love/category/reverse_engineering.html)\n[Python stealer distribution via excel maldoc (Categories:](https://malware.love/malware_analysis/reverse_engineering/2021/05/19/unknown-python-stealer.html) [malware_analysis,](https://malware.love/category/malware_analysis.html)\n[reverse_engineering)](https://malware.love/category/reverse_engineering.html)\n[Having fun with an Ursnif VBS dropper (Categories:](https://malware.love/malware_analysis/reverse_engineering/2020/11/27/analyzing-a-vbs-dropper.html) [malware_analysis,](https://malware.love/category/malware_analysis.html)\n[reverse_engineering)](https://malware.love/category/reverse_engineering.html)\n[Trickbot tricks again [UPDATE] (Categories: malware_analysis,](https://malware.love/malware_analysis/reverse_engineering/2020/11/22/trickbot-fake-ips-part2.html) [reverse_engineering)](https://malware.love/category/reverse_engineering.html)\n[Trickbot tricks again (Categories:](https://malware.love/malware_analysis/reverse_engineering/2020/11/17/trickbots-latest-trick.html) [malware_analysis,](https://malware.love/category/malware_analysis.html) [reverse_engineering)](https://malware.love/category/reverse_engineering.html)\n\n[¬´ TrueBot Analysis Part I - A short glimpse into packed TrueBot samples](https://malware.love/malware_analysis/reverse_engineering/2023/02/12/analyzing-truebot-packer.html)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-18 - TrueBot Analysis Part II - Static unpacker.pdf"
    ],
    "report_names": [
        "2023-02-18 - TrueBot Analysis Part II - Static unpacker.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809133,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1677663196,
    "ts_modification_date": 1677663196,
    "files": {
        "pdf": "https://archive.orkl.eu/4f8f174774e6c81f3cff03f17fc101e6ed06088d.pdf",
        "text": "https://archive.orkl.eu/4f8f174774e6c81f3cff03f17fc101e6ed06088d.txt",
        "img": "https://archive.orkl.eu/4f8f174774e6c81f3cff03f17fc101e6ed06088d.jpg"
    }
}