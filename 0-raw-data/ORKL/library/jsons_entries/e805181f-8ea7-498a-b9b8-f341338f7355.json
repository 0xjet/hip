{
    "id": "e805181f-8ea7-498a-b9b8-f341338f7355",
    "created_at": "2023-01-12T15:10:04.977438Z",
    "updated_at": "2025-03-27T02:14:34.091363Z",
    "deleted_at": null,
    "sha1_hash": "5b7218ab53ce5efc137de821ba9e5e2f65de410d",
    "title": "2019-09-12 - The tangle of WiryJMPer’s obfuscation",
    "authors": "",
    "file_creation_date": "2022-05-28T19:52:38Z",
    "file_modification_date": "2022-05-28T19:52:38Z",
    "file_size": 473431,
    "plain_text": "# The tangle of WiryJMPer’s obfuscation\n\n**[decoded.avast.io/adolfstreda/the-tangle-of-wiryjmpers-obfuscation/](https://decoded.avast.io/adolfstreda/the-tangle-of-wiryjmpers-obfuscation/)**\n\nby [Adolf Středa and Luigino CamastraSeptember 12, 201913 min read](https://decoded.avast.io/adolfstreda/the-tangle-of-wiryjmpers-obfuscation/)\n\n\nSeptember 12, 2019\n\n\nThe story of how we conquered WiryJMPer’s obfuscation begins with a simple binary file\nposing as an ABBC Coinwallet. We found the file suspicious, as the file size was threetimes as big as it should be, and the strings in the file corresponded to other software\nWinBin2Iso(version 3.16) from SoftwareOK. ABBC Coin (originally Alibaba Coin, not\naffiliated with Alibaba Group) is an altcoin, one of many blockchain-based cryptocurrencies.\nWinBin2Iso, on the other hand, is software that converts various binary images of\nCD/DVD/Blu-ray media into the ISO format. Behavioral analysis revealed that the binary,\nposing as an ABBC Coin wallet, is a dropper, which we will, from now on, refer to as\nWiryJMPer. WiryJMPer hides a Netwire payload between two benign binaries.\n\nThe first stage of the payload innocently appears as a regular WinBin2Iso binary with a\nsuspiciously large .rsrc section. The JMP instruction, which is normally part of a loop\nhandling window messages, jumps into the .rsrc section where a roller-coaster of control\nflow begins. This causes an unresponsive WinBin2Iso window to appear briefly before\nbeing replaced by a ABBC Coin wallet window. This window is always shown at startup and\nthus it is a good indicator of infection.\n\nWhile this functionality isn’t novel in any sense and no sandbox evasion was utilized, the\nobfuscation was uncommon enough to gain our attention. The combination of control flow\nobfuscation and low level code abstraction made the analysis of the malware’s workflow\nrather tedious. This, in combination with the low detection rate on VirusTotal (6 out of 66 as\nof 7/8/2019), provided us a great excuse to rummage through our toolbox to perform the\nanalysis. Moreover, during the analysis, we found that the obfuscated loader also utilises a\n(possibly) custom stack-based virtual machine during the RC4 key schedule, which aroused\nour interest even more.\n\n\n-----\n\nDue to the aforementioned reasons and low overall prevalence, this analysis will focus on\nthe obfuscation itself. Resulting side-effects and the malware’s functionality, will be mostly\nmentioned as side-notes.\n\n## High-level overview\n\nThe malware starts in the WinBin2Iso binary that has a patched jump. This jump leads to\nthe .rsrc section, where a loader is decrypted, loaded into memory and relocations are\nmade.\n\n_Original_\n\n_WinBin2Iso_ _binary, note that the jump leads back to GetMessageA_\n\n\n-----\n\n_Patched WinBin2Iso_ _binary, notice that the jump leads to totally different address range_\nThis loader then handles everything until the control flow is redirected to Netwire. It loads\n_ntdll.dll into the memory, decrypts some auxiliary data such as LNK filename or RC4_\ndecryption password. Afterwards, it decrypts Netwire, which is also loaded into the memory,\nand the “decoy” binary (ABBC Coin wallet in this case), which is saved onto the disk.\n\n\n-----\n\n_High-level overview of WiryJMPer’s workflow_\nSubsequently, the control flow is redirected into Netwire. Netwire is a pretty much standard\nremote access tool, no significant modifications were made. The Netwire C&C lies at\n```\n46.166.160[.]158, this address was unfortunately unresponsive at the time we\n\n```\nperformed our analysis.\n\n\n-----\n\nThe loader also tries to achieve persistence by copying the original binary to\n```\n%APPDATA%\\abbcdriver.exe and by creating an LNK file, leading to this binary, in the\n\n```\nstartup folder.\n\n## Accessing the loader\n\nThe code following the patched jump consists of many small code blocks connected by a\nnetwork of jumps. This makes the binary rather hard to (statically) analyze without any\npreprocessing. With the help of an emulator, we are able to reconstruct the call graph and\nconcatenate some of these blocks. While this approach still yields rather unpleasant results,\nit allowed us to get rid of some dummy instructions and simplify the control flow. Note that\nthis obfuscation also utilises so called opaque predicates, i.e. conditional jumps with one\nbranch that will never be reached. If we wanted to keep the analysis static, we would have\nto employ e.g. symbolic execution or other heuristics to resolve these jumps. However, for\nthe purpose of our analysis, a simple heuristic, where the code following the conditional\nbranch should lead to “reasonable” instructions, was good enough.\n\n_Several concatenated consecutive blocks, note the_\n\n_conditional jump that has predetermined result._\nBrief inspection of the sandbox behavioral log reveals two calls of `RtlDecompressBuffer,`\nthe second one decompressing our Netwire payload. Unfortunately, addresses of the\ncompressed buffers lead to addresses allocated during the execution, meaning that we\ncannot access them directly during static analysis, and thus we will have to dive deeper in\norder to retrieve the payload.\n\n\n-----\n\n_Finding content of ESI is easy, we just have to dig under ESP. Note that superfluous jumps_\n_were removed._\nThe first RtlDecompressBuffer call takes data loaded by rep movsb at `0x01e6d44f . This`\ninstruction loads the data from the binary itself into an allocated memory (VirtualAlloc).\nSince user-space debuggers were probably detected by the sample, we decided to use a\nkernel debugger that got us to the offset that’s under ESI ( 0x004f9000 ), which leads to\ndata in the .rsrc section. A brief check whether this data matches the input to\n_RtlDecompressBuffer reveals that the data is encrypted. Fortunately, the decryption loop is_\nlocated right after the block with `rep movsb .`\n\n_Decryption routine._\n\nLooking at the XORing at `0x1e75ad6` we see that our key is hidden in EBX which is\ncoincidentally loaded just before our `rep movsb at` `0x01e727a5 . Furthermore, we can`\nsee that the key is static and thus the whole buffer is XORed by `0xca81c398 . This buffer`\nis then decompressed by the aforementioned RtlDecompressedBuffer.\n\nThis resolved our first question: where is the compressed loader located? Now two\nquestions remain unresolved: where can we find Netwire payload and where is the “decoy”\n(ABBC Coin wallet) binary that is launched at the end?\n\n## Loader relocation\n\n\n-----\n\nBefore the execution flow moves into the loader from the .rsrc section, the relocation has to\nbe made due to the undeterministic nature of VirtualAlloc (and the presence of absolute\njumps in the loader). The relocation is implemented in the same way as standard\nrelocations in PE files. The relocation table has the following structure:\n\nThe offset of the instruction to be patched is calculated in the following way:\n\n```\nreloc_high + reloc_low[i] & 0xfff + allocated_memory_base\n\n```\n\nUnsurprisingly, the difference between the original base ( 0x10000000 ) and the base of the\nVirtualAlloc-ed memory is added to the residing 32-bit value. The list of `reloc_low is`\niterated until the iterator points to the next row of the relocation table.\n\n## Accessing the payloads\n\nSince Netwire payload is unpacked using RtlDecompressBuffer, it should be easily\ntrackable using the very same tricks we used before. However, since there is other stuff\nbeing dropped or extracted, we used VirtualAlloc for our breakpoints instead.\n\nThe first VirtualAlloc, coming after the unpacked loader, prepares space for ntdll.dll that is\nloaded with NtReadFile. This is becoming a rather common anti-debugging trick as\ndebuggers mostly do not recognize calls into this manually copied DLL.\n\nNow this is where it gets more interesting. The second VirtualAlloc is made for some\ninternal configuration (LNK file name, RC4 key that will be used later on) that is located in\nthe .rsrc section ( 0x01e632ac ). Again, this binary blob is encrypted by a simple XOR\ncipher with a key `0x98c381ca . From now on, we’ll start with an assumption that`\neverything is encrypted by the XOR cipher with a hardcoded key, this may simplify the\nanalysis as it is straightforward to recover the key from the plaintext-ciphertext pair.\n\nOur assumption failed immediately on the next payload ( 0x004899B6 ), its decryption loop\ncontained the following instructions (note that we have removed superfluous jumps):\n\n\n-----\n\nThis is a keystream generation loop of the RC4 cipher. This brings us to another problem –\nwe would like to find the key that was used to instantiate the table at `0x09458248 .`\nUnfortunately, the key schedule for the RC4 cipher is obfuscated by a stack-based virtual\nmachine and thus we started to debug again. To illustrate the following process, we will\nrecall the RC4 key schedule algorithm (see Python implementation below).\n\n_RC4 key schedule in_\n\n_Python_\nThis time, we have set a breakpoint on the virtual machine’s instruction that is used to write\nto the table which allows us to recover the state of registers and thus access addresses of\n```\nS[i] and S[j] . By subtracting the RC4 table’s base address, we obtained the respective\n\n```\nindices `i and` `j . Now, it’s trivial to step through the RC4 key schedule and recover bytes`\nof the key from the index `j . More specifically, we obtain a sequence:`\n\n\n-----\n\n```\n105, 120, 89, 105, 77, 70, 82, 88, 56, 83, 78, 70, 68, 74, 112, 72, 104,\n85, 82, 121, 105, 120, 89, 105, 77, 70, 82, 88, 56, 83, 78, 70, 68, 74,\n112, 72, 104, 85, 82, 121, 105, 120, 89, 105, 77, 70, 82, 88, 56, 83,\n78, 70, 68, 74, 112, 72, 104, ...\n\n```\nThis sequence obviously has repetitions (highlighted in bold) and these values seem to fall\ninto the printable ASCII range. Using these observations, we recover the RC4 key:\n```\nixYiMFRX8SNFDJpHhURy . This key was loaded from the buffer, located in the second\n\n```\n_VirtualAlloc-ed memory (containing the internal configuration), into the loader. The_\ndecryption of this blob yields the ABBC Coin wallet binary.\n\n[Interestingly, the extracted binary matches the real ABBC Coin wallet (version 3.9.1). Later](https://github.com/abbc-foundation/abbc/tree/fa087fc3fcd9ed395c49fb70a3453a94ae09ad8e/binaries/Windows)\non, this binary will be extracted into the temporary directory under a name matching the\nfollowing regular expression: `[A-Za-z]{5}\\.exe, and executed right away. We suppose`\nthat this is intended to mask the real purpose of the original binary. This payload will not be\nexecuted if the original binary is already in the `%APPDATA% directory. Incidentally, this is the`\nlocation where the original binary is copied to and thus it won’t launch the ABBC Coin wallet\nif ran at startup (through the aforementioned LNK file).\n\nWhile we will discuss the virtual machine itself in the Virtual Machine section, we will have a\nbrief look at its part, which is called a dispatcher (actually WiryJMPer has three more similar\ndispatchers). You may notice one detail:\n\n_One of the four VM_\n\n_dispatchers that are used during RC4 key-schedule. The correspondence between_\n_highlighted parts is not accidental._\nRecall that the memory, where the loader resides, had been allocated by VirtualAlloc before\ncalling the RtlDecompressBuffer and the virtual machine is in the loader. Therefore, bytes at\nthe address `0x0034AF8C` couldn’t have been set with this offset from the beginning and\n\n\n-----\n\nhad to be patched during runtime as the address range for the loader is not known\nbeforehand. This also indicates the need for relocations.\n\nNow, we just need to find Netwire in the sample. We used the same approach to find\n_VirtualAlloc that allocates memory for Netwire, we set a breakpoint on the write and then_\nfound a location from which Netwire is copied (offset `0x01e585b6` in .rsrc section). Luckily\nfor us, it was encrypted using RC4 with the same key. The decryption yields a UPX packed\nNetwire, thus concluding the payload extraction and confirming its presence hinted by the\nsandbox behavioral log.\n\n## Virtual machine\n\nDuring the analysis, we discovered that the RC4 key schedule was implemented in a\ncustom stack-based virtual machine.\n\n\n-----\n\n_Schematic of common stack-based virtual machine_\nThe first part of every virtual machine is a dispatcher. WiryJMPer’s virtual machine uses\nfour distinct switch dispatchers. In general, switch dispatchers jump to the code\ncorresponding to the desired instruction via switch statements or similar constructions. The\ninstruction is translated into a specific address or offset via a jump table, pushed onto the\nstack and the instruction `ret is called, although other constructions are also possible. The`\ntypical setting is shown on the diagram below, but note that WiryJMPer’s virtual machine is\nmore complex as it has more dispatchers and the stack-overflow check does not follow all\ninstructions.\n\n\n-----\n\n_Another dispatcher of the_\n\n_virtual machine._\nSince every virtual instruction has to deterministically reach either the dispatcher or exit the\nvirtual machine, we tried to reach these instructions by tracking references leading to these\ndispatchers. As this virtual machine is stack-based, arguments are passed through stack\ninstead of registers. General purpose registers are mostly used locally, although some\nregisters, such ESI (instruction pointer), ESP (stack frame base) or EBP (stack top), have a\nglobal effect on the virtual machine.\n\n[Instructions are rather similar to, for instance, the WProtect virtual machine – arithmetic](https://github.com/xiaoweime/WProtect)\noperations, jumps, memory/stack writes and reads, etc. We assumed a typical setting\nwhere registers are put onto specific positions in the stack during the initialization and then\nloaded back from these positions on exit. Due to the amount of instructions (and some\nduplicities), we will only provide a few examples of these instructions.\n\n_Read DWORD from stack_\n\n\n-----\n\n_Jump_\n\nWrite DWORD to memory\n\n## Similar files\n\nWe found files utilising the same scheme – WinBin2Iso binary patched to unpack Netwire\nand another binary. For example, the decoy payload led to a different, yet legitimate,\ninstaller of Bitcoin Core (version 0.18.0). Others led to the Yoroi wallet, Neon wallet,\nZecWallet, DigiByte Core, OWallet, Verge core wallet and others. The common denominator\nseems to be cryptocurrency wallets.\n\n## Conclusion\n\nWhile the malware’s functionality isn’t very innovative, it has managed to pass under the\nradar for some time, probably due to obfuscation and rather low prevalence. The utilised\nobfuscation was easily overcome by behavioral analysis, nevertheless it served well in\nobfuscating details of the malware’s operation. Rather slow setup of the decoy showing\nmultiple windows with unrelated titles may be suspicious enough for power-users, on the\nother hand, providing the “decoy” binary might be comforting enough for ordinary users.\n\n## Indicators of Compromise (IoC)\n\nRepository: [https://github.com/avast/ioc/tree/master/WiryJMPer](https://github.com/avast/ioc/tree/master/WiryJMPer)\nList of SHA-256: [https://github.com/avast/ioc/blob/master/WiryJMPer/samples.sha256](https://github.com/avast/ioc/blob/master/WiryJMPer/samples.sha256)\n\n### Analyzed sample\n\n\n-----\n\nFile SHA-256\n\nWiryJMPer f1963b44a9c887f02f6e9574aea863974be57a033600047b8e0911f9dbcb9914\n\n\nABBC\nCoin\nWallet\n\nNetwire\npayload\n\n\n7477159797a7f06e3c153662bfef624d056e64b552f455fe53e80f0afb0a1860\n\n6daa1ff03fdbbb58b1f41d2f7dc550ee97fc5b957252b7f1703c81c50b3d406f\n\n\nNetwire payload C&C: `46.166.160[.]158`\n\n### Similar samples\n\nSHA-256\n\n6e1cfde5278d03c6df204d845d165673df89cfd047f4eda97816ee351115a652\n\n4b7bd8581b85bb33d4748aaeda6a3e5ec8f930751688ffb6854522411f3ad275\n\n81740ad6a3f0e5c1698132524e0d4b23b4f4773761bca68fdaef33748ef299e3\n\n880de7e64c0678a38ef6964b6ff2f48e426449426b58a516556285421c223374\n\n125cf6b01deb86df16e0961021a57b28177b8efedc6bf4f617bef940cf4b9d74\n\n04a92a7e171b583c40cee9d2760b20fa8324e45f3938f7d41f48065829103ebd\n\n4a3d3e85d09074ed1e1de5e48c97c4e42fbcb3cfb44b213c0224ffb191dcd1c2\n\n0631ace562e077814c7788b9fe10c865579a29cf180654658f30ab38387a13e3\n\nd1457c238b99ca8904693551f92310acae561c68c20a8caafe3391d927d7618e\n\nea855c2b53419dcd81e677520d4e55d41cb5ce2933f550edd6520cce15da93fc\n\n[Tagged asanalysis,](https://decoded.avast.io/tag/analysis/) [obfuscation,](https://decoded.avast.io/tag/obfuscation/) [reversing](https://decoded.avast.io/tag/reversing/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-09-12 - The tangle of WiryJMPer’s obfuscation.pdf"
    ],
    "report_names": [
        "2019-09-12 - The tangle of WiryJMPer’s obfuscation.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3fff98c9-ad02-401d-9d4b-f78b5b634f31",
            "created_at": "2023-01-06T13:46:38.376868Z",
            "updated_at": "2025-03-27T02:00:02.818071Z",
            "deleted_at": null,
            "main_name": "Cleaver",
            "aliases": [
                "Cobalt Gypsy",
                "G0003",
                "Operation Cleaver",
                "Op Cleaver",
                "Tarh Andishan",
                "Alibaba",
                "TG-2889"
            ],
            "source_name": "MISPGALAXY:Cleaver",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536204,
    "ts_updated_at": 1743041674,
    "ts_creation_date": 1653767558,
    "ts_modification_date": 1653767558,
    "files": {
        "pdf": "https://archive.orkl.eu/5b7218ab53ce5efc137de821ba9e5e2f65de410d.pdf",
        "text": "https://archive.orkl.eu/5b7218ab53ce5efc137de821ba9e5e2f65de410d.txt",
        "img": "https://archive.orkl.eu/5b7218ab53ce5efc137de821ba9e5e2f65de410d.jpg"
    }
}