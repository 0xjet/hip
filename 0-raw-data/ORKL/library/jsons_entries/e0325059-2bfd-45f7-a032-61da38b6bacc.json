{
    "id": "e0325059-2bfd-45f7-a032-61da38b6bacc",
    "created_at": "2023-01-12T14:59:29.747834Z",
    "updated_at": "2025-03-27T02:05:26.912203Z",
    "deleted_at": null,
    "sha1_hash": "db70aa82cc8afb0c94ab8f515b6d5ae0e6aaa9b9",
    "title": "2020-09-08 - Automated dynamic import resolving using binary emulation",
    "authors": "",
    "file_creation_date": "2022-05-27T21:07:19Z",
    "file_modification_date": "2022-05-27T21:07:19Z",
    "file_size": 397021,
    "plain_text": "# Automated dynamic import resolving using binary emulation\n\n**lopqto.me/posts/automated-dynamic-import-resolving**\n\nSep 8, 2020\n\nAnalyzing malwares is often not an easy task because there are lots of tricks and techniques\nthat malwares use to evade detection and classification or to make the post-analysis more\ndifficult. One such trick is to resolve windows API calls dynamically (called “dynamic import\nresolving”).\n\nIn this blog post, we will talk about dynamic import resolving and a pattern to detect it when\nreversing malwares, how to defeat this trick using binary emulation and Qiling framework\n(resolve API calls and extract function names), and finally we will integrate our emulation\nframework with Ghidra.\n\nIn the last section, we will talk about a solution to run Python version 3 and Qiling trough\nGhidra so we can see the result of our script inside the decompiler/disassembler view. It will\nmake post-analysis easier.\n\nAs a real-life example, we will analyze Netwalker which used this technique and we will\ndiscuss our idea around that sample.\n\n## What is dynamic import resolving\n\nLet’s talk about dynamic import resolving and indirect function calls. It’s a common technique\nthat malwares use to hide their intention, make the static analysis more difficult, bypass\nsome red flags, etc.\n\n[In this technique, the malware tries to create an IAT (Import Address Table) during the](https://en.wikipedia.org/wiki/Portable_Executable)\nexecution so there is no sign of used API calls in the PE header.\n\nThis technique often shows up in a specific pattern; At the beginning of the execution, the\nprogram will build an array of function pointers which works like an IAT and the malware can\nuse stored function pointers with indirect calls as shown below:\n\n\n-----\n\nIt’s rather difficult to determine which function would be called by these indirect function calls\nwithout actually executing the binary.\n\nTo dynamically make a function pointer, the two API calls `LoadLibraryA() and`\n```\nGetProcAddress() are often used.\n\n```\nAccording to the Microsoft docs, `LoadLibraryA() :`\n\nLoads the specified module into the address space of the calling process. The\nspecified module may cause other modules to be loaded.\n```\nHMODULE LoadLibraryA(\n LPCSTR lpLibFileName\n);\n\n```\nAnd `GetProcAddress() :`\n\nRetrieves the address of an exported function or variable from the specified dynamiclink library (DLL).\n```\nFARPROC GetProcAddress(\n HMODULE hModule,\n LPCSTR lpProcName\n);\n\n```\nLook at this pseudo-code as a demonstration:\n```\ntypedef ret_type (__stdcall *f_func)(param_a, param_b);\nHINSTANCE hLibrary = LoadLibrary(\"ntdll.dll\");\nf_func LocalNtCreateFile = (f_func)GetProcAddress(hLibrary, \"NtCreateFile\");\nLocalNtCreateFile is a function pointer which points to NtCreateFile, which can be\n\n```\nstored in an array a.k.a IAT.\n\n\n-----\n\nTo make things more spicy, sometimes malware authors also encrypt the strings passed to\n```\nLoadLibrary() and GetProcAddress() like what Netwalker did. It will be near to\n\n```\nimpossible to analyze malware without solving this problem first.\n\n## Choosing the approach\n\nTo solve these types of techniques and tricks there are a few approaches. For example, we\ncan sometimes decrypt passed strings statically or we can develop an IDA plugin (or any\ndisassembler and decompiler that supports plugins) but that would be a rather timeconsuming task. Alternatively, we can use debuggers to execute the malware step by step,\nand rename variables according to dynamically resolved functions but this is a lot of\nrepetition.\n\nI chose binary emulation because it gives us the best of both worlds, We can have the power\nof automation and the ease of debugging. It’s worth mentioning that emulating can be very\nslow at times, especially when dealing with encryption and decryption algorithms. Personally,\nI think this is an acceptable trade-off.\n\n[For binary emulation we will use Qiling. Read my previous post to see why.](https://lopqto.me/posts/automated-malware-unpacking#choosing-tools-and-solutions)\n\n## Analyzing Netwalker\n\nToday’s sample is NetWalker [link! . Netwalker used dynamic import resolving technique with](https://malpedia.caad.fkie.fraunhofer.de/details/win.mailto)\nencrypted strings so it is a good example for us to demonstrate our idea and approach\naround that.\n\nAs discussed before, most of the time malwares will try to build an IAT at the beginning of the\nexecution - and NetWalker does this.\n\nAfter disassembling the malware, we can see a function call right after the `entry .`\n\n\n-----\n\nJumping to that function, we can see the pattern mentioned above; A function is called\nmultiple times and the return value is stored in an array.\n\n\n-----\n\nThis pattern is a sign of dynamic import resolving. We can confirm our guess with a\ndebugger like below:\n\n\n-----\n\nLet s jump to the code and write a script to extract these function names.\n\nI’ve discussed the basics of the Qiling like `hook_code() and` `ql.mem.read in the`\n[previous post.](https://lopqto.me/posts/automated-malware-unpacking)\n\nIn such scenarios, we don’t need to emulate the entire malware, we just need to execute the\ndynamic import table resolution bit. So we need to find the start and the end of that section.\nThis is rather easy because our target is inside a function, so we only need to emulate that\nspecific function.\n```\nql.run(begin=0x0040c1a0, end=0x0040c1a5)\n\n```\nIn this process of analyzing malwares with binary emulation, you need only be creative. For\nexample, in this sample, there are plenty of approaches that you can use; however I chose\nthe easiest and fastest (specifically development time, this solution performs rather badly).\n\nLet’s talk about the approach. As you can see in the image below, the return value of the\n(probably) decrypter and resolver function is stored in the `eax register and then moved to`\n```\ndword ptr [ecx + int] . So we just need to hook the code and extract the value of eax\n\n```\nin the right location.\n\n\n-----\n\nWe can run the emulator and try to `hook_code() to catch every instruction that is going to`\nbe executed.\n```\nql.hook_code(extract_eax)\n\n```\nAs you may notice, `extract_eax() is a callback function that is designed to extract the`\nvalue of `eax . Qiling will pass the` `ql (sandbox) object, the` `address and the` `size of`\nthe instruction to this callback function.\n\nWe can extract the instruction inside `extract_eax() with` `mem.read() as below:`\n```\nbuf = ql.mem.read(address, size)\nbuf is a Python bytearray of our instruction. The next step is detecting the right location\n\n```\nto extract `eax . By looking at the disassembler we can see a pattern. the first part of the`\nopcode is similar.\n\n\n-----\n\nNext `if will detect the right location:`\n```\nif \"8941\" in buf.hex():\n\n```\nto extract `eax value we need to do this:`\n```\neax_value = ql.reg.eax\neax_value is an address that points to an API call. We can search that address inside\nimport_symbols to extract the API name.\nfunc = ql.loader.import_symbols[eax_value]\nfunc_dll = func[\"dll\"]\nfunc_name = func[\"name\"].decode(\"ascii\")\nprint(f\"found {func_dll}.{func_name} at {hex(address)}\")\n\n```\nFulll code will be:\n\n\n-----\n\n```\ndef extract_eax(ql, address, size):\n  buf = ql.mem.read(address, size)\n  if \"8941\" in buf.hex(): # dword ptr [ECX + hex],EAX\n    eax_value = ql.reg.eax\n    func = ql.loader.import_symbols[eax_value]\n    func_dll = func[\"dll\"]\n    func_name = func[\"name\"].decode(\"ascii\")\n    print(f\"found {func_dll}.{func_name} at {hex(address)}\")\n\n```\nThis was easy! right? Next, we need to integrate our scipt with Ghidra to actually use the\ninformation we got here. This will help us to see extracted API names inside Ghidra.\n\n## Integrating Qiling with Ghidra\n\nAs you probably know Ghidra uses Jython and Jython only supports Python version 2 but\nQiling is based on Python version 3. I found an interesting project called `ghidra_bridge`\n[link! that helps us solve this problem.](https://github.com/justfoxing/ghidra_bridge)\n\nSo Ghidra Bridge is an effort to sidestep that problem - instead of being stuck in\nJython, set up an RPC proxy for Python objects, so we can call into Ghidra/Jython-land\nto get the data we need, then bring it back to a more up-to-date Python with all the\npackages you need to do your work.\n\nAfter installing `ghidra_bridge you can find an example inside the installation directory`\ncalled `example_py3_from_ghidra_bridge.py . By opening this file we will have an idea`\nabout how to write scripts based on `ghidra_bridge . Let’s dissect it.`\n\nMost scripts should use this minimal template:\n\n\n-----\n\n```\ndef run_script(server_host, server_port):\n  import ghidra_bridge \n  with ghidra_bridge.GhidraBridge(namespace=globals(), response_timeout=500):\n    pass\nif __name__ == \"__main__\":\n  in_ghidra = False\n  try:\n    import ghidra\n    # we're in ghidra!\n    in_ghidra = True\n  except ModuleNotFoundError:\n    # not ghidra\n    pass\n  if in_ghidra:\n    import ghidra_bridge_server\n    script_file = getSourceFile().getAbsolutePath()\n    # spin up a ghidra_bridge_server and spawn the script in external python to\nconnect back to it\nghidra_bridge_server.GhidraBridgeServer.run_script_across_ghidra_bridge(script_file)\n  else:\n    # we're being run outside ghidra! (almost certainly from spawned by\nrun_script_across_ghidra_bridge())\n    parser = argparse.ArgumentParser(\n      description=\"py3 script that's expected to be called from ghidra with a\nbridge\")\n    # the script needs to handle these command-line arguments and use them to\nconnect back to the ghidra server that spawned it\n    parser.add_argument(\"--connect_to_host\", type=str, required=False,\n              default=\"127.0.0.1\", help=\"IP to connect to the\nghidra_bridge server\")\n    parser.add_argument(\"--connect_to_port\", type=int, required=True,\n              help=\"Port to connect to the ghidra_bridge server\")\n    args = parser.parse_args()\n    run_script(server_host=args.connect_to_host,\n          server_port=args.connect_to_port)\n\n```\nWe only need to focus on `run_script() function. The other part is static and probably`\nthere is no need to change. Only inside `run_script() you are allowed to use Python 3`\nsyntax and only here you are allowed to load Python 3 libraries (like Qiling). As you may\nnotice I added `response_timeout to the` `GhidraBridge object and sets it’s value to 500`\nseconds. Why? because as we discussed earlier emulating is a time-consuming task and\nemulating decryptor functions is likely more time-consuming because there is so much\ninstruction code that needs to be emulated. So we need to set `response_timeout to`\nprevent any timeout-related errors.\n\n\n-----\n\nLeaving aside the base template, we can now write our Qiling code inside `run_script() .`\n```\ndef run_script(server_host, server_port):\n  from qiling import Qiling\n  import ghidra_bridge \n  with ghidra_bridge.GhidraBridge(namespace=globals(), response_timeout=500):\n    ql = Qiling([\"/home/lopqto/w/automated/samples/netwalker.exe\"],\n\"/home/lopqto/w/automated/rootfs/x86_windows\", output = \"debug\")\n    ql.hook_code(extract_eax)\n    ql.run(begin=0x0040c1a0, end=0x0040c1a5)\n\n```\nBack to the `extract_eax() function, we need to integrate it with Ghidra and add extracted`\nAPI names as a comment into Ghidra. To add a comment from a script first of all we need an\naddress (location). We have the `address value from Qiling but we need to convert this`\nvalue to Ghidra’s `Address type.`\n\nTo do this we need `memory.blocks object from` `currentProgram API. But there is a`\nchallenge here. `currentProgram API only is accessible inside` `run_script() . But we`\nneed this API inside `extract_eax() callback. There is a cool trick to handle this situation.`\nYou need to pass things around with `ql object like below:`\n```\nql.target_block = currentProgram.memory.blocks[0]\n\n```\nNow we can access to `ql.target_block inside` `extract_eax() .` `target_block`\n( memory.blocks[0] ) points to the PE entrypoint at `0x00400000 . to convert` `address to`\n```\nAddress type we need to calculate offset and do something like this:\ntarget_address = ql.target_block.getStart()\ntarget_address = target_address.add(address - 0x00400000)\n\n```\nNow we have our `target_address so we need one more step. accessing comment API is`\nsimilar to above. First we need `getListring() object:`\n```\nql.listing = currentProgram.getListing()\n\n```\nAnd to add a comment we can do:\n```\ncodeUnit = ql.listing.getCodeUnitAt(target_address)\ncomment_message = \"{}.{}\".format(func_dll, func_name)\ncodeUnit.setComment(codeUnit.PRE_COMMENT, comment_message)\n\n```\nFull source code for `extract_eax() will be this:`\n\n\n-----\n\n```\ndef extract_eax(ql, address, size):\n  buf = ql.mem.read(address, size)\n  if \"8941\" in buf.hex(): # dword ptr [ECX + hex],EAX\n    eax_value = ql.reg.eax\n    func = ql.loader.import_symbols[eax_value]\n    func_dll = func[\"dll\"]\n    func_name = func[\"name\"].decode(\"ascii\")\n    target_address = ql.target_block.getStart()\n    target_address = target_address.add(address - 0x00400000)\n    codeUnit = ql.listing.getCodeUnitAt(target_address)\n    comment = \"{}.{}\".format(func_dll, func_name)\n    codeUnit.setComment(codeUnit.PRE_COMMENT, comment)\n\n```\nNow we have a Ghidra script that will use Python3 to run samples trough Qiling and extract\ndynamic resolved function names and comment them into Ghidra. See the final result:\n\nAnd we are done. :)\n\n## Tips and tricks\n\nTwo tricks helped me to make this script. First of all, tracing the binary and printing assembly\n[instructions can help a lot while debugging source!:](https://github.com/qilingframework/qiling/blob/master/examples/hello_x8664_linux_disasm.py)\n\n\n-----\n\n```\nmd Cs(CS_ARCH_X86, CS_MODE_64)\ndef print_asm(ql, address, size):\n  buf = ql.mem.read(address, size)\n  for i in md.disasm(buf, address):\n    print(\":: 0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\nql.hook_code(print_asm)\n\n```\nYou can compare emulation result with your disassembler to debug your program.\n\nThe second tip is when you try to run a time-consuming script and write something back to\nGhidra (like adding a comment) you may face with an error like this:\n```\nERROR (BackgroundCommandTask) Command Failure: An unexpected error occurred while\nprocessing the command: Auto Analysis java.lang.RuntimeException: Timed-out waiting\nto run a Swing task--potential deadlock!\n\n```\nIt’s because java closed the file and to solve this problem you need to increase timeout.\nOpen the file in `ghidra/support/launch.properties and add this line:`\n```\nVMARGS=-Dghidra.util.Swing.timeout.seconds=3600\n\n## Conclusion\n\n```\nThe idea described in this article can be extended and used to analyze any other malware\nfamilies that dynamically resolve imports. It’s not an ultimate general solution and you need\nto change things a little bit to match it against your target binary. I tried to explain my mindset\nbehind the scene as much as possible to help you in this process. Hope this post was\nhelpful.\n\nDon’t hesitate to ping me if there is something wrong or if you want to discuss about the post.\n[I dropped the final script and the malware sample here!.](https://github.com/lopqto/YaraRules/tree/master/malwares/netwalker)\n\n## Read more\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-08 - Automated dynamic import resolving using binary emulation.pdf"
    ],
    "report_names": [
        "2020-09-08 - Automated dynamic import resolving using binary emulation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535569,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653685639,
    "ts_modification_date": 1653685639,
    "files": {
        "pdf": "https://archive.orkl.eu/db70aa82cc8afb0c94ab8f515b6d5ae0e6aaa9b9.pdf",
        "text": "https://archive.orkl.eu/db70aa82cc8afb0c94ab8f515b6d5ae0e6aaa9b9.txt",
        "img": "https://archive.orkl.eu/db70aa82cc8afb0c94ab8f515b6d5ae0e6aaa9b9.jpg"
    }
}