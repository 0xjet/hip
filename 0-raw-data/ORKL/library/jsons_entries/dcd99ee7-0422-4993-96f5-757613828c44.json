{
    "id": "dcd99ee7-0422-4993-96f5-757613828c44",
    "created_at": "2023-01-12T15:10:46.361483Z",
    "updated_at": "2025-03-27T02:06:01.773909Z",
    "deleted_at": null,
    "sha1_hash": "4e73a99bc2c61493b36702b332f8846a59223e0d",
    "title": "2022-02-01 - Dumping WhisperGate’s wiper from an Eazfuscator obfuscated loader",
    "authors": "",
    "file_creation_date": "2022-05-28T03:51:21Z",
    "file_modification_date": "2022-05-28T03:51:21Z",
    "file_size": 193521,
    "plain_text": "# Dumping WhisperGate’s wiper from an Eazfuscator obfuscated loader\n\n**maxkersten.nl/binary-analysis-course/malware-analysis/dumping-whispergates-wiper-from-an-eazfuscator-obfuscated-**\nloader/\n\n_This article was published on the 1st of February 2022._\n\n[On the 15th of January 2022, Microsoft released a report which covers havoc wreaking wiper](https://www.microsoft.com/security/blog/2022/01/15/destructive-malware-targeting-ukrainian-organizations/)\nthat is targeting Ukraine. This goal of this article is to provide a step-by-step guide with\nregards to dumping the wiper sample from memory. At first, some observations regarding the\nsample will be made, and the execution chain will be explained.\n\n## Table of contents\n\n Technical sample information\n\nBelow, the information with regards to the initial loader, as well as it’s remote payload, is\ngiven.\n\n### Stage 2\n\n[The sample can be downloaded from Malware Bazaar or](https://bazaar.abuse.ch/sample/dcbbae5a1c61dbbbb7dcd6dc5dd1eb1169f5329958d38b58c3fd9384081c9b78/) [MalShare. The hashes are given](https://malshare.com/sample.php?action=detail&hash=14c8482f302b5e81e3fa1b18a509289d)\nbelow.\n```\nMD5: 14c8482f302b5e81e3fa1b18a509289d\nSHA-1: 16525cb2fd86dce842107eb1ba6174b23f188537\nSHA-256: dcbbae5a1c61dbbbb7dcd6dc5dd1eb1169f5329958d38b58c3fd9384081c9b78\nSize: 214944 bytes\n\n### Stage 3 (raw)\n\n```\n[The sample can be downloaded from Malware Bazaar or](https://bazaar.abuse.ch/sample/923eb77b3c9e11d6c56052318c119c1a22d11ab71675e6b95d05eeb73d1accd6/) [MalShare. The hashes are given](https://malshare.com/sample.php?action=detail&hash=b3370eb3c5ef6c536195b3bea0120929)\nbelow.\n```\nMD5: b3370eb3c5ef6c536195b3bea0120929\nSHA-1: b2d863fc444b99c479859ad7f012b840f896172e\nSHA-256: 923eb77b3c9e11d6c56052318c119c1a22d11ab71675e6b95d05eeb73d1accd6 \nSize: 280064 bytes\n\n### Stage 3 (DLL)\n\n```\n[The sample can be downloaded from Malware Bazaar or](https://bazaar.abuse.ch/sample/9ef7dbd3da51332a78eff19146d21c82957821e464e8133e9594a07d716d892d/) [MalShare. The hashes are given](https://malshare.com/sample.php?action=detail&hash=e61518ae9454a563b8f842286bbdb87b)\nbelow.\n\n\n-----\n\n```\nMD5: e61518ae9454a563b8f842286bbdb87b\nSHA-1: 82d29b52e35e7938e7ee610c04ea9daaf5e08e90\nSHA-256: 9ef7dbd3da51332a78eff19146d21c82957821e464e8133e9594a07d716d892d\nSize: 280064 bytes\n\n## Outline\n\n```\nThis blog will focus on the loader, and the stages that follow from it. In the initial attack, this\nloader was used as stage two. To remain consistent with other articles, this article will refer to\nthe loader as stage two, the payload as stage three, and the wiper as stage four. Stage one,\nthe master boot record wiping malware, is not covered in this article.\n\nThis blog will focus on the loader with respect to the process hollowing it performs, and how\nthis technique can be spotted. The loader’s additional capabilities are out of scope for this\n[article, but can be read in this corporate blog I co-authored.](https://www.trellix.com/en-us/about/newsroom/stories/threat-labs/return-of-pseudo-ransomware.html)\n\n[Another article in this course provides an in-depth explanation of debugging Dot Net binaries,](https://maxkersten.nl/binary-analysis-course/common-techniques/debugging-dot-net-binaries/)\nwhich provides further clarification on some of the concepts that are used within this article.\n\nDo not forget to make a snapshot of the machine prior to executing the malware, as the\nloader itself will alter your machine, even if the wiper isn’t executed in the end.\n\n## Observations\n\nUpon executing the sample, several processes are started. The purpose of some is directly\nobvious, such as the encoded PowerShell command that performs a ten second sleep. For\nthe execution of InstallUtil.exe from %TEMP%, the purpose is not as clear. These\nobservations might not mean much from the get-go, but they can come back as a key puzzle\npiece at a later stage. After a bit, the files on the machine are (partially) overwritten by the\nwiper.\n\n## Stage 2 – Analysing the loader\n\nThe second stage is written using the Dot Net Framework, and is obfuscated to make the\ncode harder to read. Using a debugger, such [dnSpyEx, one can go over the code as it is](https://github.com/dnSpyEx/dnSpy)\nexecuted. Additionally, or alternatively, one can statically go over the code to understand\nwhat is going on.\n\nIn short, stage 2 uses a WebClient object to download data from the Discord CDN. The\ndownloaded data seems to be an image when looking at the extension of the file in the URL,\nas it pretends to be a jpg file.\n\n\n-----\n\nThe code to download the third stage from the remote location\nThe downloaded data (as a byte array) is then reversed in order, after which it is loaded as\nan Assembly object. As such, the downloaded data is actually a Dot Net Framework based\nPE file, rather than an image. Next, the exported types from the Assembly object are\nobtained, after which a function named Ylfwdwgmpilzyaph is invoked without any arguments.\n\nThe name of the function\n\nwhich is to be invoked\nNormally, one would be able to continue the execution of this stage into the next, but the\npayload isn’t hosted on the given location anymore. As such, one has to either be able to\nresolve the URL, by using a custom response for the request, or by invoking the function in\nanother way. The latter way will be described in the next section.\n\nAs always, do note that there are multiple ways to solve this problem. Based on your own\narea of expertise and preference, a different option might be better suited.\n\n## Creating a custom loader\n\nStage 3 is a Dot Net Framework based DLL, meaning one cannot simply debug it from the\nget-go. One way to easily debug the DLL, is by writing a simple reflective loader which\ninvokes Ylfwdwgmpilzyaph. The code that is given below reads the original payload from the\ndisk, reverses the given array, and loads it as an Assembly object. The next step is to fetch\nthe class where the function resides in. This class is named Main, within the namespace\ncalled ClassLibrary1. At last, a member from the type is invoked, based on the given function\nname. Since this is a static function, there is no need to initialise the type prior to its\ninvocation.\n```\nbyte[] jpg =\nFile.ReadAllBytes(@\"C:\\WhisperGate\\stage3\\923eb77b3c9e11d6c56052318c119c1a22d11ab71675\nArray.Reverse(jpg);\nAssembly assembly = Assembly.Load(jpg);\nType type = assembly.GetType(\"ClassLibrary1.Main\");\ntype.InvokeMember(\"Ylfwdwgmpilzyaph\", BindingFlags.InvokeMethod, null, null, null);\n\n```\nWithin the Visual Studio project, one has to allow the project to load from remote sources,\nwhich can be done by editing the app.config file within the project. The snippet that is given\nbelow needs to be included in the file.\n\n\n-----\n\n```\n<runtime>\n  <loadFromRemoteSources enabled=\"true\"/>\n</runtime>\n\n```\nNote that one has to start dnSpyEx with administrator privileges for this specific sample, as\nthis is required later on!\n\n## Stage 3 – Dumping the wiper\n\n[Stage 3 is obfuscated using Eazfuscator, which is a commercial obfuscator and optimiser.](https://www.gapotchenko.com/eazfuscator.net)\nWhen digging in the code, one will encounter the inclusion of unmanaged functions, as the\nDot Net Framework’s [interoperability capability provides this feature. Additionally, during the](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interop/)\nexecution of the sample in a sandbox (or on your own analysis system), one will observe the\nstart of several processes that execute something directly, one being PowerShell.\n\nAdditionally, InstallUtil.exe is copied to, and executed from %TEMP%. This is an odd location\nfor the file to be in, but there is something more important: the process is created in a\nsuspended mode. This generally indicates process injection. In this case, process hollowing\nis used.\n\n[Since the process hollowing is performed using unmanaged functions, one can use x32dbg](https://x64dbg.com/)\nto debug the program. Do note the need to run the debugger with administrative privileges,\nas stage 3 requires these privileges later on.\n\nOne can launch the custom loader as a normal executable, break on the entry point, and set\nbreakpoints on CreateProcessA, CreateProcessW, and WriteProcessMemory. The\nbreakpoints on CreateProcessA and CreateProcessW will provide context as to when the\nprocess hollowing’s target will be started, instead of another process, as it is known that\nseveral process will be started by the loader. To see what data is written to the target\nprocess, a breakpoint on WriteProcessMemory is set, as this function is used to write data\ninto a given process.\n\nDuring the execution, one will see that the breakpoint on CreateprocessW will be hit when\n[PowerShell and AdvancedRun are launched. The breakpoint on CreateProcessA will be hit](https://www.nirsoft.net/utils/advanced_run.html)\nwhen InstallUtil.exe is launched, the only process which is created in a suspended state.\nAfter that, WriteProcessMemory is hit several times, once per section of the wiper, which it\nwill write in the targeted InstallUtil instance.\n\n### Dumping the wiper\n\nThe sections of stage 4 are written into the target process one at a time using\n_WriteProcessMemory. The function signature is given below, as taken from_ [MSDN.](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)\n\n\n-----\n\n```\nBOOL WriteProcessMemory(\n [in] HANDLE hProcess,\n [in] LPVOID lpBaseAddress,\n [in] LPCVOID lpBuffer,\n [in] SIZE_T nSize,\n [out] SIZE_T *lpNumberOfBytesWritten\n);\n\n```\nThe third argument points to the buffer that will be written into the target process. The\namount of bytes that will be read from this buffer, and written into the target process, is\nspecified in the fourth argument. When viewing this in x32dbg’s stack window, the arguments\nare given, as can be seen in the image below.\n\nWriteProcessMemory’s arguments as shown in x32dbg\n\nOne can right click on the third argument and display it in a specified dump window. To copy\nthe bytes, one can select nSize bytes from lpBuffer‘s location onwards. The amount of bytes\nis given in the fourth argument, which equals 0x400 for the first section. The image below\nshows most of the selected bytes. The line in the bottom shows how many bytes are\nselected in total, making it easy to see if the complete buffer is selected before copying the\ndata.\n\n\n-----\n\nThe first section\n\nof the wiper, as seen in x32dbg’s dump window\nTo easily copy the selected bytes, one can use SHIFT + C. This will copy all bytes, without\nthe ASCII representation or addresses. The image below shows the copy menu options.\n\n\n-----\n\nx32dbg’s\n\ncontext menu to copy the selected bytes\nOne can concatenate all copied buffers in a hex editor, such as [HxD. Once all sections are](https://mh-nexus.de/en/hxd/)\ncopied, one can save the newly created file as stage4.bin, as this is the wiper. One can\nanalyse the fourth stage with an analysis tool of their own choosing.\n\n[The wiper sample can be found on Malware Bazaar and](https://bazaar.abuse.ch/sample/191ca4833351e2e82cb080a42c4848cfbc4b1f3e97250f2700eff4e97cf72019/) [MalShare. The hashes are given](https://malshare.com/sample.php?action=detail&hash=343fcded2aaf874342c557d3d5e5870d)\nbelow.\n```\nMD5: 343fcded2aaf874342c557d3d5e5870d\nSHA-1: 8be3c66aecd425f1f123aadc95830de49d1851b5\nSHA-256: 191ca4833351e2e82cb080a42c4848cfbc4b1f3e97250f2700eff4e97cf72019 \nSize: 25092 bytes\n\n## Conclusion\n\n```\nEven though the sample is based on the Dot Net Framework, it does not mean that there’s\nnothing more to the sample. Additionally, this case serves as the perfect example as to why\nit’s not always important to focus on the complete deobfuscation of a sample, although that\nobviously depends on the goal of the analysis.\n\nThere are more ways to dump this stage, and some might be considered easier than others,\ncompared to the experience and background of the analysts. Be creative and use the\navailable tools to your advantage!\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-01 - Dumping WhisperGate’s wiper from an Eazfuscator obfuscated loader.pdf"
    ],
    "report_names": [
        "2022-02-01 - Dumping WhisperGate’s wiper from an Eazfuscator obfuscated loader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536246,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1653709881,
    "ts_modification_date": 1653709881,
    "files": {
        "pdf": "https://archive.orkl.eu/4e73a99bc2c61493b36702b332f8846a59223e0d.pdf",
        "text": "https://archive.orkl.eu/4e73a99bc2c61493b36702b332f8846a59223e0d.txt",
        "img": "https://archive.orkl.eu/4e73a99bc2c61493b36702b332f8846a59223e0d.jpg"
    }
}