{
    "id": "aaa0f3e9-e019-4676-b89f-c9d9478b4d0e",
    "created_at": "2023-05-06T02:09:22.214331Z",
    "updated_at": "2025-03-27T02:16:39.537563Z",
    "deleted_at": null,
    "sha1_hash": "e6f87a6cbe91f5ff7eb147daa7473305feeab7d7",
    "title": "2023-04-23 - exposing the internals of Aurora Stealer Builder",
    "authors": "",
    "file_creation_date": "2023-05-05T02:03:15Z",
    "file_modification_date": "2023-05-05T02:03:15Z",
    "file_size": 1847660,
    "plain_text": "# Aurora Stealer Builder\n\n**d01a.github.io/aurora-stealer-builder/**\n\nMohamed Adel April 23, 2023\n\n## Contents\n\n[Mohamed Adel included in Malware Analysis](https://d01a.github.io/)\n2023-04-23 4904 words\n 24 minutes\n views\n\n## Introduction\n\nin the previous article, I discussed what’s inside Aurora Stealer. After the release, [@Gi7w0rm](https://twitter.com/gi7w0rm)\nprovided me samples of some versions of Aurora Stealer builder, a new version that was created\nrecently and another one that was created in 2022. The newer version has some improvements in\nthe builder and new features we will discuss in this article. Before we start this article, it is\nimportant to note that the Builder also contains and creates the Web panel to control the bots. This\nmeans the binaries we are looking at are actually a hybrid between a builder and a panel.\n\n## Startup info\n\nIn main_main the first display page is prepared to accept the credentials of the user and start\nchecking them. It first displays an ASCII art of the word Aurora and provides communication\nchannels for contacting the Aurora developers.\n\n\n-----\n\nAfter the initial screen, it saves the UUID of the user, with the same function discussed before to\nmake sure that only one user is using the builder.\n\nThen it asks for the login and password of the user\n\n\n-----\n\n### Authentication method\n\nAfter the credentials where provided, it calls main_createAccess. it saves the string 123 It passes\nthe directory ./cache/Auth.aurora to a function called main_exists that checks if the file exists\nor not. If it existed it will ask for hand deleting it, if not it will create it.\n\nIt appends the UUID and the string AURORA_TECHNOLOGY and calculates the MD5 hash to it using\nthe form\n```\n<UUID>AURORA_TECNOLOGY\n\n```\nafter which it takes this hash to make a string in the following form:\n```\n123_aurora_<MD5_OF(<UUID>AURORA_TECNOLOGY)>_technology_123\n\n```\nThen the SHA1 hash is calculated for this string:\n\n\n-----\n\nIt generates the first string again and its MD5 hash. It uses the MD5 hash as a key for the AES\nGCM encryption routine. The generated bytes are then written to ./cache/Auth.aurora\n\nTo know what was written to the file, we can use this script:\n```\n  from Crypto.Cipher import AES\n\n  import binascii\n\n  # key is MD5 hash of <UUID>AURORA_TECHNOLOGY\n\n  key = b\"<KEY>\"\n\n  # Auth.aurora content\n\n  cipher = \"<CIPHER>\"\n\n  data = binascii.unhexlify(cipher)\n\n  nonce, tag = data[:12], data[-16:]\n\n  cipher = AES.new(key, AES.MODE_GCM, nonce)\n\n  cleartext = cipher.decrypt_and_verify(data[12:-16], tag)\n\n  print(cleartext)\n\n  # cleartext is SHA1 hash of the string\n  \"123_aurora_<MD5_OF(<UUID>AURORA_TECNOLOGY)>_technology_123 \"\n\n\n```\nwhich shows us the SHA-1 Hash of the string:\n```\n123_aurora_<MD5_OF(<UUID>AURORA_TECNOLOGY)>_technology_123\n\n```\n\n-----\n\n### Server Authentication check\n\nGoing back to main_main, where it creates yet another hash:\n\nThis time, the password and login is used to create a string using the following form\n```\n<LOGIN>_*Aurora_2023_Technology_<PASS>. then it calculates the SHA1 hash of it.*\n\n```\nThen, it calls main_server . This could be where the authentication of the user happens, just a\nhypothesis.\n\nit sleeps 1000000000 nanoseconds. Then it makes a TCP connection with\n```\n185.106.93.237:56763 which seems to be the server where user authentication is done.\n\n### Dynamic Key calculation\n\n```\n\n-----\n\nIf the connection is established, it calls main_DynamicKey which generates a key based on the\ncurrent minutes in the current time, In America/Los_Angeles time format.\n\nand calculate the SHA1 hash of it.\n\nBack in the main_Server function the builder then puts all the hashes in JSON format to be sent to\nthe server.\n\n### Server Response Info\n\nthe remote server then verifies the given data and response with one of the few response strings\nbelow:\n\n\n-----\n\n**Response** **Action**\n\nHWID_BAD [Aurora] HWID has a different value on the license server, write\nsupport\n\nNOT_FOUND_ACCOUNT [Aurora] Account has been not found, wrong login or password.\n\nLOST_LICENSE [Aurora] License expired.\n\nDYNAMIC_KEY [Aurora] Dynamic key wrong, check time your OS or write support.\n\n### Network emulation\n\nI tried to emulate the C2 communication with fakenet. After a very long time trying to do that. it\nworks to respond to it with the format of data it waits for, but there is something still missing.\n\nI edited the configs of the TCPListener of fakenet as can be seen below:\n\n1. In default.ini edit the default configs to the following:\n\n\n-----\n\n```\n  [RawTCPListener]\n\n  Enabled:   True\n\n  Port:    56763 # port it comm over\n\n  Protocol:  TCP\n\n  Listener:  RawListener\n\n  UseSSL:   No\n\n  Timeout:   100\n\n  Hidden:   False\n\n  # To read about customizing responses, see\n  docs/CustomResponse.md\n\n  Custom:  sample_custom_response.ini\n\n```\n1. Create or use the sample_custom_response.ini provided to contain the following, this is\n\nalready set by default:\n```\n  [ExampleTCP]\n\n  InstanceName:   RawTCPListener\n\n  TcpDynamic:   \n  CustomProviderExample.py\n\n\n```\n1. The builder waits for a JSON string delimited by the character 0x0A if this is not in the\n\nresponse it will wait forever.\n\nAs a result CustomProviderExample.py should contain a JSON string ending with 0x0A, I was\ntesting with the following code:\n\n\n-----\n\n```\ndef HandleTcp(sock):\n\n  \"\"\"Handle a TCP buffer.\n\n  Parameters\n\n  ---------\n  sock : socket\n\n    The connected socket with which to recv and send\ndata\n\n  \"\"\"\n\n  while True:\n\n    try:\n\n      data = None\n\n      data = sock.recv(1024)\n\n    except socket.timeout:\n\n      pass\n\n    if not data:\n\n      break\n\n    resp = b'{\"Test\":\"test\",\"Test2\":\"Test2\"}\\x0A'\n\n    sock.sendall(resp)\n\n```\n\n-----\n\nA value of the JSON string accepted must be the Dynamic key which is generated based on the\nlocal time of the user.\n\n### Anti-Debugging check\n\nThis Dynamic key is calculated again and the two values are compared in order to check if the\nsample is being debugged. Nice!\n\n### License info and IP used\n\nThe JSON strings also contain some other information about the User and the license\n\n\n-----\n\nAlso, it contains an IP that is used later in some other interesting functions. the author expects\nonly one IP to be used by the builder.\n\nIt calls convTstring which takes a generic value -any type- and converts it to a string. I don’t\nreally know why it calls convTstring as it is an IP it would be passed as a string in the JSON.\nmaybe later we realize what’s going on here.\n\n\n-----\n\nWe see some calls to runtime.newProc . This function generates a new go running function and\nput it in a running Queue of other go functions waiting to run. This is generated by the compiler\n[when using go keyword. Interested topic hah? Read more about it here. Sadly it makes debugging](https://www.golang-book.com/books/intro/10)\nmore difficult.\n\n### Why network emulation doesn’t work well\n\nBack to the JSON data, it’s decoded with json.Unmashal function which takes a structure as an\ninput and with the second parameter being the data in bytes. How is the data mapped to the\n[structure? Well, according to Go documentation](https://go.dev/blog/json)\n\n\n-----\n\nHow does Unmarshal identify the fields in which to store the decoded data? For a given\nJSON key \"Foo\", Unmarshal will look through the destination struct’s fields to find (in order\nof preference):\n\nAn exported field with a tag of \"Foo\" (see the [Go spec for more on struct tags),](https://go.dev/ref/spec#Struct_types)\nAn exported field named \"Foo\", or\nAn exported field named \"FOO\" or \"FoO\" or some other case-insensitive match\nof \"Foo\".\n\nWhat happens when the structure of the JSON data doesn’t exactly match the Go type?\n```\n  Unmarshal will decode only the fields that it can find in the destination type\n\n```\nSo, we should guess the names of the JSON data. One of them is Dynamic key but we should\nfigure out how it’s decoded.\n\nWe can use the pattern of the previously sent data, It was called DK . Sadly, this and other\nattempts didn’t work. So, I will continue the other things only static in IDA.\n\n## Main Functionality\n\nThe main functionality of the builder is invoked with a series of goroutine calls. Each called\nfunction is preparing some data to be used later or to start the server itself. This serves as the\nmain function of the builder.\n\n### IP Geolocation database\n\nThe first function of the series of newProc calls is main_LoadToDB which loads a very huge file\ncalled geo.aurora that contains a list of IP ranges all over the world.\n\n\n-----\n\nViewing the cross-reference we can deduce that it is used to identify the geo-location of a victim.\n\nA sample of the content of geo.Aurora can be seen below. The file contains ~380MB of data like\nthis.\n```\n  [\n\n   {\n\n    \"Country_short\":\n  \"AU\",\n\n    \"City\":\n  \"Queensland\",\n\n    \"Region\": \"\",\n\n    \"Zipcode\": \"\",\n\n    \"Timezone\": \"\",\n\n    \"In\": \"1.0.0.0\",\n\n    \"Out\":\n  \"1.0.0.255\"\n\n   },\n\n   {\n\n    \"Country_short\":\n  \"CN\",\n\n    \"City\": \"Fujian\"\n\n```\n\n-----\n\n```\n    g,\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.1.0\",\n\n  \"Out\":\n\"1.0.3.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"AU\",\n\n  \"City\":\n\"Victoria\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.4.0\",\n\n  \"Out\":\n\"1.0.7.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"CN\",\n\n  \"City\":\n\"Guangdong\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.8.0\",\n\n  \"Out\":\n\"1.0.15.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\": \"Tokyo\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.16.0\",\n\n  \"Out\":\n\"1.0.16.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\": \"Tokyo\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.17.0\",\n\n  \"Out\":\n\"1.0.31.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"CN\",\n\n  \"City\":\n\"Guangdong\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.32.0\",\n\n  \"Out\":\n\"1.0.63.255\"\n\n },\n\n {\n\n```\n\n-----\n\n```\n       y_\n\"JP\",\n\n  \"City\":\n\"Hiroshima\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.64.0\",\n\n  \"Out\":\n\"1.0.64.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\":\n\"Hiroshima\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.65.0\",\n\n  \"Out\":\n\"1.0.66.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\":\n\"Hiroshima\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.67.0\",\n\n  \"Out\":\n\"1.0.67.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\":\n\"Hiroshima\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\": \"1.0.68.0\",\n\n  \"Out\":\n\"1.0.68.127\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\": \"Miyagi\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\",\n\n  \"Timezone\": \"\",\n\n  \"In\":\n\"1.0.68.128\",\n\n  \"Out\":\n\"1.0.69.255\"\n\n },\n\n {\n\n  \"Country_short\":\n\"JP\",\n\n  \"City\":\n\"Hiroshima\",\n\n  \"Region\": \"\",\n\n  \"Zipcode\": \"\"\n\n```\n\n-----\n\n```\n          ,\n  \"In\": \"1.0.70.0\",\n\n  \"Out\":\n\"1.0.71.255\"\n\n },\n\n....\n\n]\n\n```\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n### Bot state\n\nThe second function is to get the status of the infected systems. This includes a check if the bot is\nactive, the last connection time of the bot, and the current time.\n\n### Clear old screenshots\n\nThe third function deletes all the screenshots stored in the bot directory!\n\nIt sorts the pictures to be deleted by _ in it, then it gets what has ACTUAL word in it, lastly, it deletes\nthe file extension .png from the string using strings.Trim and the new string should be a number\nas it calls strconv.atoi and then gets the current time. What a mess!\n\n\n-----\n\nIt then proceeds to finally delete the file.\n\n### Command Receiver\n\nThe next function is main_CommandReceiver. It queues the commands received by the builder.\n\n\n-----\n\nThe function map.Range has the definition:\n```\n  func (m *Map) Range(f func(key, value any)\n  bool)\n\n\n```\nwhere f is a function called for each <key,value> pair. So the variable CMD_QUEUE would contain the\nreceived commands.\n\nGoing through the function main_CommandReceiver_func2 we see that the software first checks if\nthe received command is STOP. If the STOP command is received, the builder exits.\n\n\n-----\n\nFor all other commands, it goes to another function main_CommandReceiver_func2_1 . It s\nexpecting a 3-character long command MIX .\n\nIt packs data about the victims with GZip and base64 encode it then, stores it back using\n```\nmap.store\n\n```\n\n-----\n\nThere were some log messages related to other commands here. However, I couldn’t figure out\nhow the commands are treated. Based on the sample I discussed in a previous article, I guess this\nis connected to the messages sent from the victim machine.\n\n### Main server functionality\n\nThe server is now ready to work and build the graphical interface of the builder to view the victim’s\ndata and state and further use the victims as Bots and Stealer hosting servers using SFTP.\n\n\n-----\n\n### server start!\n\nNext function is main_SERVER_func1 it calls main_ForwardPort with argument :7367\n\nThen this function calls aurora_core_server__Server_Start, this long value is passed with the\nport number passed to its driver function\n\nThis function starts the main server that displays the dashboard. I tried to adjust the execution to\ncontinue, but the program crashed.\n\nNote: SixSixSix is the author of the Stealer and not my username.\n\n### TCP listener\n\nBack to function main_Server_0 (main_Server).\n\n\n-----\n\nIt logs the start of the server in the main display.\n\nThe server is started using net.Listen function that takes the protocol = tcp and port = 456 .\n\n## Main Client\n\nAfter setting up the Server, the function main_server_func2 is called.\n\nThis function only calls the main_Client function.\n\n\n-----\n\n### Handling incoming data\n\nTo handle incoming data from the victim, the panel/builder reads the data on the listening port\nusing bufio__Reader_ReadString. This data must be delimited by 0x0A as discussed previously.\nIt comes in a compressed format, so the function main_uncompress is used to decompress it.\n\n\n-----\n\nTo do so, the function takes the base64 encoded data and decodes it, then it is decompressed\nusing GZip. You might remember from my last article, that this is the way the data was sent from\nthe victim’s device.\n\nThe data is in form of JSON so it’s extracted with a call to json.Unmarshal . The resulting data is\nthen stored in a victim database file. The last message is additionally stored in the map function.\n\n### Update victims DB\n\nOne of the first packets received from the victim is a large base64 blob. After decoding it using the\nabove-mentioned method, it can be seen that this blob is a screenshot from the victim’s machine.\n\n\n-----\n\nThis image is used to update the screenshot that contains _ACTUAL.png . The old one is then\ndeleted.\n\n\n-----\n\nThe other screenshots are stored in a similar way but the name is different.\n\nIt updates the stolen victim data as well, and the last response from each infected host is stored in\nthe previously created map.\n\n\n-----\n\n### The victim’s Location identification\n```\nmain_GetGeo is then called. If we remember, the loaded JSON string was referenced in this\n\n```\nfunction.\n\n\n-----\n\nIt parses the string IP to convert to IP to a Go IP type which is a decimal dotted IP address.\n\nThen it goes through a very large loaded JSON string that contains every IP range associated to\neach region all over the world.\n\nThe new victims will have an identifier is the string MIX that is checked to handle the new victims\n\n\n-----\n\nIf the victim is new, it will store the screenshot with _ACTUAL tag as discussed before but there is\nno old one to delete.\n\nAt the very end of the function, a call to main_Registration is made. This function just adds a\nnew entry to the victims’ list and gets the geolocation of the victim.\n\n## Main web server\n\nAt the beginning of the function main_Server there was a goroutine that I missed initially. It calls\n```\nmain_web before the call to net.Listen .\nmain_web initializes the web interface of the builder and the dashboard with all of its functionality.\n\n```\nthe server starts at port 8181 .\n\nThe function follows the same pattern to set the methods of the handler for APIs:\n\nThe following table contains all available APIs with their associated handlers:\n\n\n-----\n\n**APIHandlerAPIHandler** **APIHandlerAPIHandler**\n\n**APIAPI** **namename** **addressaddress** **DescriptionDescription**\n\ngetbots main_web_func1 0x7635A0 List all the victims by walking through\nmain_BOT_CONN map\n\ncallback main_web_func2 0x763800 get the callback message of each victim\nthrough the\nmain_BOT_LASTMESSAGE or\nQueriyng the raw query of the\nconnection address and get the\nmessage associated with victim IP\n\ncallback_STR main_web_func3 0x763A00 get the callback message string for\neach victim stored at\nmain_BOT_LASTMESSAGE_STRING\n\ncallback_ps main_web_func4 0x763C00 get the PowerShell response of each\nvictim through\nmain_BOT_POWERSHELL_MESSAGE\nor Queriyng the raw query of the\nconnection address and get the\nPowerShell message.\n\nStatistic main_web_func5 0x763E00 shows statistics about the victims stored\nin .Aurora file in ./bots/ folder and\nredirects to web/statistic.html html\ntemplate. The statistics show all the\nusers with their IP addresses and\ngeolocation\n\nsend_pw main_web_func6 0x764428 sends a base64 encoded PowerShell\ncommand to the victim using the json\nformat. The associated key in the query\nis argument string\n\nGiveMeBuild main_web_func7 0x7648E0 checks\\builds the executable file of the\nstealer .The build file is stored in .\\build\nit first checks if it exists on the system. if\nexists, tries to read it. If read is not\nsuccessfully done, it exits. If not, the\nauthor prepared the file to be sent as an\nattachment for another remote system.\nit’s sent in the Content-deposition as\nfollows: Content-Desposition:\nattachment = .exe\n\nsend main_web_func8 0x764E60 sends cmd \\ PowerShell commands to\nthe victims. They are sent through the\nargument key in the URL raw query\n\n\n-----\n\n**APIHandler**\n**address** **Description**\n\n\n**API**\n\n\n**APIHandler**\n**name**\n\n\nsftp_stop_reverse main_web_func9 0x7655A0 closes the SFTP connection with the\nvictims and closes the associated port\nforwarding functionality. Also, it deletes\nthe entry associated with the deleted\nvictim’s SFTP connection in\nmain_BOT_CLIENT_SFTP map\n\nsftp_reverse main_web_func10 0x765820 start a SFTP server with the victim. the\nconnection is done through port 7273 .\nThe successful connection is indicated\nby WORK string. the configuration and\ndata about the connection in the\nassociated maps\nmain_BOT_CLIENT_SFTP,\nmain_BOT_LASTMESSAGE . This\nreverse shell is then used to host the\nstealer. The infected Bots can be used\nin DoS attacks too.\n\nscreenshot main_web_func11 0x766540 Takes a screenshot of the victim, it first\nchecks if it’s active. SHA1 hash is\ncalculated to the png file to see if the\nscreenshot is the same as the stored or\nnot before updating the database of the\nvictims. the process is identified by Bad\nor Good statement.\n\nbot main_web_func12 0x766C00 displays the status of the bots and all\ninformation, online boots its geo\nlocation, SFTP connected bots in the\nweb/bot.html html template page. it also\nreads the content of ./core/scr_n_f.png\nbut I don’t see any use of it. It encodes\nthe data in it and then redirect to\nbot.html\n\nlogout main_web_func13 0x767680 Logs out!\n\nauth main_web_func14 0x767780 Authenticate the access of the client. It\nuses the file ./cache/Auth.Aurora to\ncompare its content with the newly\ncalculated hashes as discussed before.\n\ndashboard main_web_func15 0x767BA0 The dashboard of the stealer, which\nshows some data about the active and\noffline Bots.\n\ndel_cmd main_web_func16 0x768220 deletes a registered command from the\nmain_CMD_QUEUE assigned to the\nvictim\n\n\n-----\n\n**APIHandler**\n**address** **Description**\n\n\n**API**\n\n\n**APIHandler**\n**name**\n\n\ncommands main_web_func17 0x768380 display the command selection interface\nin the web/commands.html html\ntemplate\n\nAddCommand main_web_func18 0x768840 add a new command to the victim\ncommands list, it reads the assigned\ncommands JSON data and adds a new\ncommand to it buy calling\nmain_AddCommand that updates\nmain_CMD_QUEUE map assigned to\nthe victim.\n\nAddLoaderCommand main_web_func19 0x768B60 add loader command. reads the\nresponse of the Client.Get() method\nand then the associated JSON data and\nbase64 encode it. There are some\nstrings used in the identification like\nEXTERNAL_RUN_PE_X64 . the data\nthen stored in the associated map\n(main_CMD_QUEUE) and the victims\nDB\n```\n   net.Query in Go parses the raw query and returns the values.\n  u, err := url.Parse(\"https://example.com/?\n  a=1&b=2\")\n\n  q := u.Query()\n\n  // q will have the values associated to a & b\n\n  fmt.Println(q.Get(\"a\")) // print 1\n\n  fmt.Println(q.Get(\"b\")) // print 2\n\n\n## Older version of the builder\n\n```\nThere’s another sample provided to me, executable\nhash33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad\n\nThis sample looks like it was one of the first trials of the author to create a stealer in Go. It\ndepends on so many additional legitimate packages from GitHub to create the server and handle\nthe database manipulation and some other things. In the newer builder, it seems like he got more\nfamiliar with the Go Language and didn’t rely on the packages from GitHub.\n\n\n-----\n\nThe package used to grab the favicon (from the first GitHub account), create the GUI web\napplication (the second account), provide sqlite3 interface and provide a library like ReadLine in C.\n\nThe repositories are in the following table:\n\n**Old sample** **New sample**\n\n[http://github.com/adampresley/gofavigrab](http://github.com/adampresley/gofavigrab) [http://github.com/vmihailenco/tagparser](http://github.com/vmihailenco/tagparser)\n\n[http://github.com/asticode/go-astikit](http://github.com/asticode/go-astikit) [http://github.com/vmihailenco/msgpack](http://github.com/vmihailenco/msgpack)\n\n[http://github.com/chzyer/readline](http://github.com/chzyer/readline)\n\n[http://github.com/go-telegram-bot-api/telegram-bot-api](http://github.com/go-telegram-bot-api/telegram-bot-api)\n\n[http://github.com/gorilla/mux](http://github.com/gorilla/mux)\n\n[http://github.com/jroimartin/gocui](http://github.com/jroimartin/gocui)\n\n[http://github.com/manifoldco/promptui](http://github.com/manifoldco/promptui)\n\n[http://github.com/mattn/go-runewidth](http://github.com/mattn/go-runewidth)\n\n[http://github.com/nsf/termbox-go](http://github.com/nsf/termbox-go)\n\nThe old sample has some functions that were described before, which were extended in the 2023\nversion. The hash calculation method and dynamic key but instead of Aurora_Stealer_2023 it is\n```\nAurora_Stealer_2022. Then it connects to the remote server to authenticate the user data, to the\n\n```\nIP 185.106.93.237:6969 using TCP protocol.\n\n\n-----\n\nAnother dynamic key is used to authenticate with the server, based on the current time too\nhowever in the old sample the string Aurora_Stealer_SERVER is used.\n\n\n-----\n\nThis key is sent to the remote server and calculated later in the following code to verify the user\naccess and the dynamic key to make sure there is no debugging session started.\n\n\n-----\n\nIf the keys do not match, the function breaks and the program is terminated.\n\nAnother dynamic key is calculated but this time for the client, it uses the string\n```\nAurora_Stealer_2033 with the same timing method of calculation discussed.\n\n```\nThe hashes are stored then in ATX.Aurora in ./cache folder.\n\nIt then checks the existence of some files: ./cache/ATX.Aurora, ./cache/telegram.Aurora,\n```\n./cache/Config.Aurora and ./cache/Trash .\n./cache/Trash contains older Aurora executables, the older executables are auto-moved to this\n\n```\nfolder using PowerShell command, and the new version, which is expected to be in .zip format\nwith the name Update.zip, is then unzipped and replaces the older version. The program is then\nrestarted using PowerShell. This is all done in main_AutoUpdate function.\n\nThe function main_ReadTGData reads telegram data from the file ./cache/telegram.Aurora which\nis AES encrypted. The authentication is done using a telegram bot through the telegram API. This\nauthentication method is removed from the new version, where everything is done through\ncommunicating with the remote server.\n\nThe old builder additionally contains an important function called main_LoadStealer . This\nfunction calls two other goroutines. both two functions execute PowerShell commands that\nconfigure the firewall to allow it to receive incoming TCP connections through Port 80 and 8081.\n\n\n-----\n\n```\n  #function main_LoadStealer_func2 allow it on local port 80\n\n  netsh advfirewall firewall add rule name=”Port 80 dir=in action=allow protocol=TCP\n  localport=80\n\n  #function main_LoadStealer_func2 allow it on local port 80\n\n  netsh advfirewall firewall add rule name=”Port 8081 dir=in action=allow protocol=TCP\n  localport=8081\n\n```\nAt the end of the main function, it creates a new hidden instance of CMD and starts the Web\nservice of the stealer. using the function main_StartWeb\n\nThis function starts the web service on localhost http://127.0.0.1/dashboard . It has a different\nset of APIs and different associated handlers then the newer version.\n\nThe command strings are highlighted.\n\n\n**API** **APIHandler name**\n\n\n**APIHandler**\n**address** **Description**\n\n\n-----\n\n**API** **APIHandler name**\n\n\n**APIHandler**\n**address** **Description**\n\n\nreceive main_StartWeb_func1 0x140421B00 It receives the incoming\ncommands and connects to the\nremote server\n185.106.93.237:6969 to get\nmatch the stored hashes with\nthe calculated one in form of\n_Aurora<PASSWORD .this_\nfunction has a lot of other\nfunctionality. it reads the\ncommand from the response of\nthe server. It allows the user to\ndelete a directory Delete,\nremove file grabber RemoveG,\nor remove the loader\nRemoveL.GEO_URL to get the\ngeolocation of all victims.\nAddDmen Add a new domain\nname received from the\nserver.BuildGen builds a new\nversion of the stealer and the\nability to increase the file size\nPumbMB.DeleteTG,\nAddTelegram delete\\add\ntelegram configuration.DeleteAll\nDelete all the\nconfigs.ChangePassword,\nchange password and download\nall logs files Download_AllLogs.\nDownload_OnlyCrypto\ndownloads the crypto wallet\ninformation only.\n\napi.exe main_StartWeb_func2 0x140421B60 adds a new telegram API key to\nthe stealer and adds an icon\nusing resource hacker cmd\ncommand\n./resource/ResourceHacker.exe\n-open\n./builds/<STEALER_NAME>.exe\n-save\n./builds/<STEALER_NAME>.exe\n-action addskip -res\n./resource/main.ico -mask\nICONGROUP,MAIN .\n\n\n-----\n\n**API** **APIHandler name**\n\n\n**APIHandler**\n**address** **Description**\n\n\ndashboard/{id:\n\n[0-9]+}\n\n\nmain_productsHandler 0x14041D080 display the main window of the\nweb service displays information\nabout a specific victim ID:\nCookies, passwords, the\nGeolocation, and crypto wallet\ninformation. Logs are stored in\n./logs/ folder contain passwords\nin passwords.txt, cookies in\nfolder Cookies . All the\ninformation is shown through the\nHTML template\n./gui/Dashboard.html\n\n\ndownload_geo main_StartWeb_func3 0x140422100 retrieves the geolocation\ninformation, the same as the\nnew one.\n\ndownload_l main_StartWeb_func4 0x1404222A0 gets the logs in a .zip archive,\nuncompresses it and deletes the\narchive. the logs contain all the\nstolen data\n\n\napi/get-logbuild\n\n\nmain_StartWeb_func5 0x140422620 get the build logs from ./logs\nassociated with a specific API\nkey used\n\n\nbuild.exe main_StartWeb_func6 0x140422B60 gets a build executable of the\nstealer stored at ./builds\n\ndashboard main_StartWeb_func7 0x140422EA0 display the dashboard of the\nstealer, and shows some\nstatistics about the infected\nsystem. IPs, geo-location and\nthe stolen information\n\nloader main_StartWeb_func8 0x140422FE0 display information about the\nLoader and file grabber. the\nthreat actor can use this section\nto configure the loader and\nspecify the target file to grab. file\n./config/telegram.txt is used to\nextract the telegram connection\nconfiguration. The information is\nviewed by executing\ngui/Loader.html HTML template.\n\n\n-----\n\n**API** **APIHandler name**\n\n\n**APIHandler**\n**address** **Description**\n\n\nsetting main_StartWeb_func9 0x1404234A0 builder settings, display\ninformation about the subscribed\nplan and change the password\nand telegram configuration and\nAPI. and shows the used\ndomains\n\nauth main_StartWeb_func10 0000000140423A40 the AUTH page that the user\nsigns in to where the used\ncredentials and AUTH cache file\nin ./cache/AuthHash.Aurora are\nchecked. Whenever the user\nnavigates, the credentials and\nhashes are checked. if not valid,\nwill be redirected to this page\n\nbuilder main_StartWeb_func11 0x140423CC0 creates a new build through it.\nthe build target architecture\nvictims group is chosen.\n\nchecker main_StartWeb_func12 0x140424380 checks the wanted information\nfrom the victim DB. check the\nbuild used and get the\ngeolocation of the victim\nspecified.\n\nthen the server is started on port 80\n\nIn function main_AddNewClient, the victim entries on the data based are created by calling\n```\nmain_CreateDB data stored about the user in UserInformation.txt:\n\n```\nHWID\nBuild ID\nLog date\nIP\nCountry\nRegion\nCity\nPC INFORMATION\n\nCPU\nScreen Size\nScreen Size\nRAM\nDisplay Device (GPU)\n\nin addition to the stolen information the following credentials are received:\n\n\n-----\n\nSteam\nPasswords\ncookies\ncrypto wallets -stored in subdirectory /wallets\nTelegram info\nscreenshots\ngrabbed files -stored in subdirectory ./FileGrabber\nCards information\n\nBrowser cookies are stored in .db files in ./cache to be decrypted and the extracted data is\nstored in .txt file.\n\nThe end of the packet is checked by END_PACKET_ALL_SEND sentence. And the last packet sent to\nthe victim is Thanks, then, the data are zipped and sent to the telegram account configured.\n\nThe function main_DecryptLog_Card is used to decrypt the credit card information collected. It\nuses the following sqlite3 query to achieve that:\n```\n  select name_on_card, expiration_month, expiration_year, card_number_encrypted,\n  date_modified, use_date, use_count, nickname from credit_cards\n\n\n## Web service HTML templates\n\n```\n[You can find screenshots of the HTML templates in this tweet.](https://twitter.com/Gi7w0rm/status/1649899595307048966)\n\n## Yara Rules\n\n[all the rules can be found here.](https://github.com/d01a/yara-rules)\n\nnew builder version\n```\n  rule aurora_stealer_builder_new{\n\n    meta:\n\n    malware = \"Aurora stealer Builder new version 2023\"\n\n    hash =\n  \"ebd1368979b5adb9586ce512b63876985a497e1727ffbd54732cd42eef992b81\"\n\n    reference = \"https://d01a.github.io/\"\n\n    Author = \"d01a\"\n\n    description = \"detect Aurora stealer Builder new version 2023\"\n\n    strings:\n\n    $is_go = \"Go build\" ascii\n\n    $s1 = \"_Aurora_2023_Technology_\"  ascii\n\n    $s2 = \"AURORA_TECHNOLOGY\" ascii\n\n    $s3 = \"scr_n_f.png\" ascii\n\n    $s4 = \"EXTERNAL_RUN_PE_X64\" ascii\n\n    $s5 = \"[Aurora]\" ascii //log messages begin with [Aurora] __LOGMSG__\n\n    $fun1 = \"main.Server\" ascii\n\n```\n\n-----\n\n```\n    $\n    $fun3 = \"main.AddCommand\" ascii\n\n    $fun4 = \"main.GetGeoList\" ascii\n\n    $fun5 = \"main.GiveMeBuild\" ascii\n\n    condition:\n\n    uint16(0) == 0x5a4d and ( $is_go and (2 of ($s*)) and (2 of ($fun*))\n  )\n\n  }\n\n```\nold builder version\n\n\n-----\n\n```\n       _ _ _ {\n  meta:\n\n  malware = \"Aurora stealer Builder old version 2022\"\n\n  hash1 =\n\"33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad\"\n\n  reference = \"https://d01a.github.io/\"\n\n  Author = \"d01a\"\n\n  description = \"detect Aurora stealer Builder old version 2022\"\n\n  strings:\n\n  $is_go = \"Go build\" ascii\n\n  $s1 = \"ATX.Aurora\"  ascii\n\n  $s2 = \"Aurora_Stealer_2033\" ascii\n\n  $s3 = \"Aurora_Stealer_SERVER\" ascii\n\n  $s4 = \"[Aurora Stealer]\" //log messages\n\n  $fun1 = \"main.DecryptLog\" ascii\n\n  $fun2 = \"main.CreateDB\" ascii\n  $fun3 = \"main.GenerateKey\" ascii\n\n  $fun4 = \"main.TGParce\" ascii\n\n  condition:\n\n  uint16(0) == 0x5a4d and ( $is_go and (2 of ($s*)) and (2 of ($fun*))\n)\n\n}\n\n```\n\n-----\n\n## IOCs:\n\n**ebd1368979b5adb9586ce512b63876985a497e1727ffbd54732cd42eef992b81**\n\n\n**aurora.exe**\n**(2023 version)**\n\n\ne7aa0529d4412a8cee5c20c4b7c817337fabb1598b44efbf639f4a7dac4292ad builder archive\n(2023 version)\n\n33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad aurora.exe\n(2022 version)\n\n33b61eb5f84cb65f1744bd08d09ac2535fe5f9b087eef37826612b5016e21990 geo.Aurora\n\n1def6bdec3073990955e917f1da2339f1c18095d31cc12452b40da0bd8afd431 ds.html\n\nf1ba92ae32fcaeea8148298f4869aef9bcd4e85781586b69c83a830b213d3d3c statistic.html\n\n8b1abbb51594b6f1d4e4681204ed97371bd3d60f093e38b80b8035058116ef1d bot.html\n\ne9cf3e7d2826fa488e7803d0d19240a23f93a7f007d66377beb1849c5d51c0af commands.html\n\nd7829f17583b91fb1e8326e1c80c07fc29e0608f1ba836738d2c86df336ea771 rergister.html\n\n1b88624936d149ecdea6af9147ff8b2d8423125db511bdf1296401033c08b532 settings.html\n\n185.106.93.237:56763 Aurora server version 2023used in user\naccount\nverification\n\n185.106.93.237:6969 Aurora server version 2022used in user\naccount\nverification\n\nAuth.aurora locally created\nfor each Aurora\npanel user and\nused in account\nverification\n\nscr_n_f.png contains config\ninformation\n\n\n-----\n\n**ebd1368979b5adb9586ce512b63876985a497e1727ffbd54732cd42eef992b81**\n\n\n**aurora.exe**\n**(2023 version)**\n\n\nscreenshot/ a local folder\nthat contains\nvictims’\nscreenshots\n\n<*>_ACTUAL.png screenshot of\ncurrent state of\nonline bots\n\n<>_<>.png custom\nscreenshots\nformat\n\nThe following go files were identified in the binary, all starting with the path:\n“C:/Users/SixSixSix/Desktop/Botnet 2023/26.01.2023/new/”\n```\n  auth.go\n\n  crypt.go\n\n  command.go\n\n  compressor.go\n\n  core.go\n\n  geo.go\n\n  main.go\n\n  pfor.go\n\n  port.go\n\n  web.go\n\n  core/statistics/window.go\n\n  core/statistics/winfuns.g\n  o\n\n  core/statistics/queue.go\n\n  core/monitor/monitor.go\n\n  core/common/copy.go\n\n  core/common/udpconn.go\n\n  core/common/util.go\n\n  core/logger/logger.go\n\n  core/schema/monitor.go\n\n  core/schema/util.go\n\n  core/server/client.go\n\n  core/server/client_handle\n  rs.go\n\n  core/server/server.go\n\n  core/server/server_handle\n  rs.go\n\n```\n\n-----\n\nThere are similar files identified in the old version of the builder/panel.\n\nThe common path for this older sample is:\n“C:/Users/SixSixSix/Desktop/Aurora 2022/server”\n\n\n-----\n\n```\n  auth.go\n\n  compressor\n  .go\n\n  config.go\n\n  cryptograp\n  hy.go\n\n  favicon.go\n\n  geo.go\n\n  gui.go\n\n  main.go\n\n  notify.go\n\n  other.go\n\n  server.go\n\n  telegram.g\n  o\n\n  zip.go\n\n## Yara Seeds\n\n```\nTo create the Yara rules, the following strings were used. Those are all present in the builder:\n```\n  127.0.0.1:7273\n\n  POWR\n\n  WORK\n\n  PORT_FORWARD\n\n  FTP_RUN - REVESRE START\n\n  _*Aurora_2023_Technology_*\n\n  AURORA_TECHNOLOGY\n\n  ./cache/Auth.aurora\n\n```\n\n-----\n\n```\n_ACTUAL\n\n./bots/screenshot/\n\n./core/scr_n_f.png\n\nEXTERNAL_RUN_PE_X64\n\n[Aurora] Botnet - SERVER - RUN\n\n- old sample.\n\n  ./cache/Config.Aurora\n\n  ./cache/Aurora.Aurora\n\n  ./cache/telegram.Aurora\n\n  ./cache/ATX.Aurora\n\n  Aurora_Stealer_2033\n\n  Aurora_Stealer_SERVER\n\n  Aurora_Stealer_2022\n\nhttps://api.telegram.org/bot%s/%\ns\n\n  ./cache/AuthHash.Aurora\n\n  [Aurora Stealer]: Yes i am\nwork!\n\n```\n\n-----\n\n## Acknowledgments:\n\n\n-----\n\n[@gi7w0rm for providing me with the samples and helping me formatting the article to make it](https://twitter.com/gi7w0rm)\nbetter.\n\nUpdated on 2023-04-23 [80e2ac1](https://github.com/dillonzq/LoveIt/commit/80e2ac15859c0d0fb416bf36eca5a2c605158fbd)\n[Aurora Stealer](https://d01a.github.io/aurora-stealer/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-23 - exposing the internals of Aurora Stealer Builder.pdf"
    ],
    "report_names": [
        "2023-04-23 - exposing the internals of Aurora Stealer Builder.pdf"
    ],
    "threat_actors": [
        {
            "id": "f87ef0bf-0574-492f-aebc-63e5953938e2",
            "created_at": "2024-11-23T02:00:04.116692Z",
            "updated_at": "2025-03-27T02:00:03.465245Z",
            "deleted_at": null,
            "main_name": "Gorilla",
            "aliases": [],
            "source_name": "MISPGALAXY:Gorilla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1683338962,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1683252195,
    "ts_modification_date": 1683252195,
    "files": {
        "pdf": "https://archive.orkl.eu/e6f87a6cbe91f5ff7eb147daa7473305feeab7d7.pdf",
        "text": "https://archive.orkl.eu/e6f87a6cbe91f5ff7eb147daa7473305feeab7d7.txt",
        "img": "https://archive.orkl.eu/e6f87a6cbe91f5ff7eb147daa7473305feeab7d7.jpg"
    }
}