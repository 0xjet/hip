{
    "id": "c82ac0d4-e494-481a-9a92-450853e8f055",
    "created_at": "2023-01-12T15:02:15.494477Z",
    "updated_at": "2025-03-27T02:05:23.392093Z",
    "deleted_at": null,
    "sha1_hash": "d83061e1cf4e1561603f610ddd2b68fc219fceb9",
    "title": "2022-04-09 - Method of analyzing and unpacking compressed PE (Portable Executable) files",
    "authors": "",
    "file_creation_date": "2022-05-28T02:40:36Z",
    "file_modification_date": "2022-05-28T02:40:36Z",
    "file_size": 347466,
    "plain_text": "# Phương pháp phân tích và unpack các file PE (Portable Executable) bị nén\n\n**hackmd.io/@antoinenguyen09/Hy0a2mb0t**\n\n# Phương pháp phân tích và unpack các file PE (Portable Executable) bị nén ######\nAuthor: `HoangNCH` ## :rocket: I. Packed PE file và Packer là gì? **Packed PE (Portable\nExecutable) file** là một file mà mã thực thi gốc của nó sẽ bị ẩn đi khi ta load nó vào các\ntrình disassembler để phân tích và lưu lại bằng cách áp dụng các kỹ thuật như nén, mã hóa,\ntự động bổ sung một hoặc nhiều section và đoạn stub, cuối cùng là chèn thêm đoạn\n**Packed Data**. Trong **Packed Data** này có chứa mã thực thi gốc, do đó khi thực thi,\n**Entry Point** (EP) của chương trình sẽ được chuyển hướng vào vùng code này, gọi là\n**Original Entry Point** (OEP). OEP là mấu chốt để chúng ta unpack và lấy ra được packed\ndata từ file PE đã bị packed. ![](https://i.imgur.com/AxYWapZ.png) Các trình **packer** chính\nlà công cụ để tạo ra các file PE bị packed từ các file PE bình thường nhằm mục đích khiến\ncracker/reverser gặp khó khăn và tốn thời gian hơn trong việc bẻ khỏa hoặc đảo ngược\nphần mềm của họ. Nó cũng được sử dụng bởi những kẻ phát tán malware nhằm \"tăng sức\nđề kháng\" cho malware khi gặp phải sự \"truy quét\" của các phần mềm anti-virus được cài\nđặt trên hệ thống, bởi khi quét một file PE bị packed các phần mềm anti-virus thông thường\nsẽ quét theo tuyến tính, từ DOS MZ Header, PE Header rồi các section trong section table.\nMà section table của một file PE bị packed như đã nói ở trên sẽ được chèn thêm rất nhiều\nsection \"rác\", và các section \"rác\" này với các phần mềm anti-virus thì nó vô hại. Trong khi\nsection thực sự \"có hại\" nằm ở **Packed Data**, dữ liệu được nén trong **Packed Data** chỉ\n\n\n-----\n\nđược giải nén khi chạy chương trình (runtime). Các bạn có thể tìm hiểu sâu hơn về cấu trúc\nfile PE tại [đây](https://securitydaily.net/tim-hieu-ve-cau-truc-pe-file/), nguyên lý hoạt động\ncủa Packer hay nguyên lý unpack tại [đây](https://securitydaily.net/tong-quan-ve-pack-vaunpack/). Mình thì không thích nói lý thuyết suông nên trong bài viết này sẽ dùng các bài lab\nmình cho là tiêu biểu để nói về kỹ thuật Pack và Unpack. Pack mà mình sử dụng trong tất cả\ncác bài lab này là **UPX** vì nó khá là đơn giản và thân thiện với newbie khi nghiên cứu về\nunpacking. ## :rocket: II. Phân tích tĩnh (Static analysis) > UPX là một packer hoàn toàn\nmiễn phí và open-source, các bạn có thể tải nó về tại [đây]\n(https://github.com/upx/upx/releases/tag/v3.96). Ở đây ta sẽ dùng bản **upx-3.96-win64** để\npack một phần mềm khá là quen thuộc đó là [Putty]\n(https://samsclass.info/127/proj/putty.exe). Sau đó sử dụng một tool phân tích tĩnh là\n\n[Pestudio](https://www.winitor.com/features) (vì nó khá đa năng, cung cấp cho ta nhiều thông\ntin về một file thực thi) để so sánh 2 file **putty gốc** và file **putty bị pakced** xem có gì\nkhác biệt. Chạy command prompt với quyền admin, gõ lệnh `upx -o putty_packed.exe\nputty.exe` để pack file `putty.exe` và cho ra output là file `putty_packed.exe`. ![]\n(https://i.imgur.com/Ttgyc0m.png) Cho file `putty_packed.exe` và `putty.exe` vào [Pestudio]\n(https://www.winitor.com/features) để kiểm tra các [artifact]\n(https://nasbench.medium.com/windows-forensics-analysis-windows-artifacts-part-ic7ad81ada16c) có trong file PE này. Có thể thấy tất cả các giá trị hash của 2 file này đều\nkhác nhau, nhưng khi click vào để chạy thì cả 2 file này đều hoạt động như nhau không có\ngì khác biệt. Điều đó chứng tỏ sau khi packed thì nội dung của file `putty.exe` đã bị thay đổi.\nĐồng thời ở property **signature** của `putty.exe` có giá trị là `Microsoft Visual C++ 7.0\nMFC`cho chúng ta biết `putty.exe` được viết bằng C++, trong khi **signature** của\n`putty_packed.exe` chỉ cho biết packer mà nó sử dụng. Trả lời được câu hỏi \"nó được viết\nbằng ngôn ngữ lập trình gì?\" là bước đầu tiên và quan trọng trong quá trình dịch ngược, và\nđây rõ ràng là khó khăn đầu tiên khi phân tích một file bị packed. ![]\n(https://i.imgur.com/3YbAB8s.png) Không những vậy, khi kiểm tra mục **sections** của cả 2\nfile trên ta cũng thấy sự khác biệt rõ rệt: ![](https://i.imgur.com/Evjm8vt.png) Có thể tóm tắt\nnhững điểm khác nhau đó như sau: - `putty.exe`: \\+ Có [4 section]\n(https://keystrokes2016.wordpress.com/2016/06/03/pe-file-structure-sections/) đặc trưng của\nmột file PE là **Executable Code Section** (`.text`), 2 **Data Section** gồm`.rdata` và\n`.data`, cuối cùng là **Resources Section** (`.rsrc`). \\+ Khi so sánh **raw-size** (kích thước\ncủa file PE khi được lưu trên ổ đĩa) và **virtual-size** (kích thước của file PE khi được load\ntừ ổ đĩa vào bộ nhớ) ở từng section (ngoại trừ section `.data`), có thể thấy sự chênh lệch\n**raw size - virtual size** là không đáng kể, **raw size** nhỉnh hơn một chút so với **virtual\nsize**, tuân theo đúng cấu trúc của một file PE thông thường (xem giải thích tại [đây]\n(http://www.asmcommunity.net//forums/topic/?id=29605)). \\+ Về **phân quyền**, có thể thấy\nfile `putty.exe` đã tuân thủ đúng quy tắc bảo mật cơ bản của một file PE: **không cho phép**\n**quyền ghi** (writable) **và** **quyền thực thi** (executable) **nằm trên cùng một section**\n. Chỉ có section `.text` có **quyền thực thi** vì đây là nơi chứa toàn bộ các opcode và\nsystem call, trong khi đó chỉ section `.data` mới có **quyền ghi** vì nó là nơi chứa dữ liệu\nđầu vào và đầu ra của chương trình. \\+ **Entry point** - nơi chương trình bắt đầu chạy nằm\n\n\n-----\n\nở địa chỉ 0x000550F0, thuộc section .text (đúng chuẩn). Đây được gọi là OEP (Original\nEntry Point). \\+ **Entropy**: không có section nào có entropy vượt quá **6.7**, do đó file\n`putty.exe` không có section nào chứa packed data. 2 section có entropy cao nhất là `.text`\nvà `.rdata`, do `.text` là nơi tập trung mã thực thi và `.rdata` dữ liệu chính có thể đọc được\ndùng để nạp vào khi chương trình chạy. 2 section có entropy thấp nhất là `.data` và `.rsc` vì\nchứa các dữ liệu không được sử dụng, được chủ yếu là các bit 0. - `putty_packed.exe:` \\+\nChỉ có **3 section** là **UPX0**, **UPX1** và `.rsrc`, với **UPX0**, **UPX1** được sinh ra\nkhi UPX nén file. \\+ Khi so sánh **raw-size** và **virtual-size** ở từng section thì ta đã thấy\ncó sự chênh lệch bất thường ở section **UPX0** khi raw size là 0 bytes còn virtual size thì\nrất lớn, lên đến 294912 bytes. Từ đó kết luận section UPX0 không tồn tại trên ổ đĩa, và sẽ\nđược tự động lấp đầy khi chương trình chạy. \\+ Về **phân quyền**, có tới 2 section vừa có\nquyền ghi vừa có quyền thực thi là UPX0 và UPX1, không tuân theo quy tắc bảo mật. Quyền\nghi được cấp cho 2 section này có lẽ sẽ sử dụng cho việc khôi phục lại mã chương trình gốc\nban đầu ở các section trống như UPX0. \\+ **Entry point** nằm ở địa chỉ `0x000860E0` thuộc\nsection UPX1. Đây chỉ là Entry Point của một đoạn stub trong UPX1. \\+ **Entropy**: raw size\ncủa UPX0 là 0 bytes, nó không chứa một cái gì cả, do đó entropy của nó cũng không tồn\ntại.Section `.rsrc` thì có entropy vẫn ở mức bình thường, nhưng entropy của UPX1 lại lên\nđến `7.932`, lớn hơn **6.7**. **--> Giả thuyết đặt ra: UPX1 là nơi chứa packed data, còn\nUPX0 là không gian trống mà file `putty_packed.exe` dành ra nhằm phục vụ cho việc khôi\nphục lại mã chương trình gốc ban đầu. (1)** ## :rocket: III. Kiểm chứng giả thuyết, phân tích\nđộng và tách packed data ra khỏi file bị packed bằng công cụ OllyDbg > Ta sẽ \"đào sâu\" và\nkiểm chứng giả thuyết đặt ra ở mục II, từ đó tìm kiếm thêm các thông tin có ích cho việc\nphân tích động (bằng cách debug) và cuối cùng là tách packed data ra khỏi file bị packed.\nOllyDbg là một debugger sử dụng Assembly 32bit dành riêng cho Windows. Mặc dù hiện\nnay đã có rất nhiều tool hiện đại hơn như IDA (ta sẽ đề cập đến nó ở phần sau) hay x64dbg\nnhưng OllyDbg vẫn là một trong những debugger ra đời sớm nhất, không gây tình trạng bị\n\"ngợp\" vì quá nhiều tính năng như IDA. OllyDbg cũng hoàn toàn miễn phí và bạn có thể tải\nnó tại [đây](https://www.ollydbg.de/). ### 1. Kiểm chứng giả thuyết: Lưu ý luôn chạy OllyDbg\nvới quyền admin. Sau đó ta sẽ mở file `putty.exe`, cùng lúc đó bật thêm một cửa sổ OllyDbg\nnữa rồi mở file `putty_packed.exe`. Ở cửa sổ mở file `putty_packed.exe`, nếu có pop-up\n**Compressed code?** hiện lên thì click **No** để giữ nguyên trạng file bị packed. ![]\n(https://i.imgur.com/wVS9tqc.png) Maximum của sổ \"CPU\" lên, ta thấy các tham số thu được\ntrong quá trình phân tích tĩnh hoàn toàn trùng khớp với những gì thể hiện trên trình\ndisassembler của OllyDbg: ![](https://i.imgur.com/Xv9xdhb.png) Trong đó, file `putty.exe` bắt\nđầu với lệnh `PUSH 60` ở địa chỉ `004550F0` còn với file `putty_packed.exe` thì nó là\n`PUSHAD` ở địa chỉ `004860E0`. Lệnh `PUSHAD` sẽ đẩy giá trị của tất cả các thanh ghi\n(general registers) vào stack. Điều đó thể hiện khi tại `PUSHAD` ta ấn **F7** (step into) để\nchạy lệnh này: ![](https://i.imgur.com/Bo2wHbW.png) Trên cửa sổ OllyDbg, click **View ->\nMemory** để kiểm tra các vùng nhớ trên ổ đĩa mà 2 file PE này chiếm dụng khi thực thi. Cả\n2 chương trình khi chạy đều được nạp vào ổ đĩa tại địa chỉ gốc (base address) `400000`\ngiống như mọi chương trình Windows 32 bit khác. Ngoài ra có thể thấy các section quen\nthuộc `.text`, `.rdata`, `.data`, `.rsrc` của file `putty.exe` và `UPX0`, `UPX1`, `.rsrc` của file\n\n\n-----\n\nputty_packed.exe ở đây: ![](https://i.imgur.com/gM6Ynmh.png) Sử dụng Pestudio mới\nchỉ cho ta biết kích thước của từng section khi phân bố trên ổ đĩa như thế nào (raw size).\nOllyDbg còn cho ta biết bên trong từng section đó có cái gì. Click chuột phải vào section\n`.text` của `putty.exe` và `UPX0` của `putty_packed.exe` rồi chọn **Dump** để xem dữ liệu\ntrong các section này. Trong khi `.text` chứa mã assembly của chương trình thì `UPX0` chỉ\ntoàn là các bit `0`. ![](https://i.imgur.com/lP2XlEr.png) Đồng thời khi sử dụng **Pestudio** để\nxem xét **entropy** của từng section, ta có đặt giả thuyết \"section UPX1 là nơi chứa packed\ndata\" do entropy của section này lớn hơn **6.7**. Khi dump dữ liệu của section UPX1 ra như\ntrên thì đúng là như vậy: ![](https://i.imgur.com/RdRobHf.png) Dữ liệu trong section UPX1\ncủa `putty_packed.exe` bao gồm một đoạn stub có nội dung giống đến khoảng 60% mã\nassembly trong section `.text` của `putty.exe`, nhưng đoạn stub này hoặc là đã bị obfuscate,\nhoặc là bị chèn thêm một số đoạn dữ liệu \"trông có vẻ như\" là các lệnh assembly nhưng lại\nkhông phải vì OllyDbg không thể biên dịch được chúng, được đánh dấu là \"Unknown\ncommand\". Từ giá trị entropy thu được bằng **Pestudio** ta biết được đó chỉ là những dữ\nliệu được sinh ra ngẫu nhiên bởi packer. **--> Giả thuyết (1) đặt ra là đúng.** Không những\nvậy, tại dữ liệu được dump ra từ section `UPX1`, khi kéo chuột xuống dưới để tìm điểm kết\nthúc của section này thì thấy một loạt lệnh `ADD` như `ADD BYTE PTR DS:[EAX],AL`.\nNhưng điều đáng quan tâm là trước loạt lệnh `ADD` này có lệnh `JMP putty_pa.004550F0`.\nLệnh `JMP` sẽ bắt chương trình phải nhảy đến câu lệnh tại địa chỉ `004550F0`. Rõ ràng, ở\nđây sau khi thực thi toàn bộ mã lệnh tại Stub và tái tạo lại mã gốc ban đầu của chương trình,\nchương trình sẽ nhảy tới OEP tại địa chỉ `0x004550F0`. Địa chỉ này có một chút khác biệt so\nvới OEP mà ta thấy khi dùng **Pestudio** để kiểm tra ở mục II, đó là do Entry Point\n`0x000550F0` hiển thị trong **Pestudio** là địa chỉ trong bộ nhớ ảo (virtual address), khi mã\nđược nạp vào ổ đĩa tại địa chỉ gốc (base address) `0x00400000` thì địa chỉ thật (raw\naddress) của nó sẽ là: `base address + virtual address = 0x00400000 + 0x000550F0 =\n0x004550F0`. Suy cho cùng, tuy hai nhưng vẫn là một. ![](https://i.imgur.com/iCbIzOz.png)\n**--> Vậy OEP của file `putty_packed.exe` là chính là `0x004550F0`** ### 2. Phân tích động\n(dynammic analysis): Như đã đề cập ở mục I, OEP chính là mấu chốt để lấy ra được packed\ndata từ file PE đã bị packed. OEP thì đã có, để xem mã của chương trình gốc có được khôi\nphục sau lệnh `JMP` đến OEP như ta đã suy đoán ở cuối phần \"Kiểm chứng giả thuyết\"\nkhông, ta vào disassembler của OllyDbg rồi ấn **F2** đặt breakpoint tại lệnh `JMP\nputty_pa.004550F0`. ![](https://i.imgur.com/IiCMUbN.png) Ấn **F9** (Run) để chương trình\nchạy đến lệnh này, lưu địa chỉ của lệnh `JMP putty_pa.004550F0` vào thanh ghi EIP. ![]\n(https://i.imgur.com/4mBC9Gq.png) Tiếp tục ấn **F7** (Step into) để thực thi lệnh `JMP\nputty_pa.004550F0`. Chương trình sẽ nhảy tới lệnh `PUSH 60` tại OEP `0x004550F0`. ![]\n(https://i.imgur.com/N1GRi86.png) Từ đây, khối mã này chứa các lệnh nằm trong section\n`.text` \"thật\", rất giống với code tại cùng địa chỉ ở file gốc `putty.exe`. **Hay nói cách khác,\nchúng ta đã tìm ra được vị trí của packed data.** ### 3. Tách packed data thành một file PE\nmới: Sau khi tìm ra packed data của file `putty_packed.exe` nằm ở đâu, ta có thể chạy nó\nbằng Debugger của OllyDbg. Nhưng để tách hoàn toàn nó ra và tạo thành một file PE mới,\nta cần tập hợp các \"mảnh binary\" riêng lẻ lại với nhau đồng thời dựng lại PE header, vì UPX\npacker đã hủy mất import table ở trong đó. OllyDbg có một plugin cho phép chúng ta làm\n\n\n-----\n\nđược điều này đó là [OllyDump](http://www.openrce.org/downloads/details/108/OllyDump). !\n\n[](https://i.imgur.com/J4dDnre.png) Click **Plugins -> OllyDump -> Dump debugged\nprocess**. ![](https://i.imgur.com/ASIxyfr.png) Pop-up **OllyDump** hiện ra, hiển thị các\nsections của file PE, Entry Point và phương pháp OllyDump sử dụng để xây dựng lại import\ntable. ![](https://i.imgur.com/TilKkHI.png) Các thông số đều đúng với trạng thái của chương\ntrình tại OEP nên ta để mặc định không chỉnh sửa gì, chỉ việc click vào **Dump**. Lưu file\nđược dump ra với tên là `putty_unpacked.exe`. Kiểm tra file này bằng **Pestudio**, đối chiều\nvới file gốc `putty.exe`: ![](https://i.imgur.com/mst4Cta.png) Ngoại trừ một section mới thêm\nlà `.newIID` thì tên các section của `putty_unpacked.exe` vẫn giữ nguyên. Tuy nhiên các\nthông số của từng section đã thay đổi khi: - Section UPX0 không còn bị rỗng khi nạp vào ổ\nđĩa. - Chênh lệch giữa `raw-size` và `virtual-size` ở từng section hầu như đều bằng 0. Không còn section nào có entropy lớn hơn 6.7. - Entry point được trả về đúng địa chỉ gốc ở\n`0x000550F0`. ## :rocket: IV. Kết hợp phân tích tĩnh và động sử dụng IDA Pro > OllyDbg chỉ\ndừng lại ở mức \"một debugger tốt\", nó cung cấp khả năng phân tích động mạnh mẽ nhưng\nkhả năng phân tích tĩnh vẫn còn khá hạn chế. Reverse engineering yêu cầu phải mạnh ở cả\n2 khả năng này do đó khi dùng OllyDbg ta phải bổ trợ thêm các công cụ phân tích tĩnh như\nPestudio. Liệu có công cụ nào phân tích tĩnh hay động đều mạnh hay không? Đó chính là\nIDA Pro. IDA Pro là một công cụ reversing hoàn chỉnh, sử dụng được trên cả hai nền tảng\n32-bit và 64-bit, vừa là một trình disassembler đồng thời cũng hỗ trợ debug như một trình\ndebugger, hoạt động được trên các môi trường hệ điều hành khác nhau như Windows,\nLinux hoặc Mac OS X và thậm chí là remote (từ xa). Trong phần **IV** của bài viết, mình sẽ\ngiải quyết bài toán đi tìm hàm main của một mẫu file khác cũng bị packed bởi UPX có tên là\n\n[upxflag2c1.exe](https://samsclass.info/126/proj/upxflag2c1.exe). Lần này sẽ không còn file\ngốc nào để đối chiếu nữa, ta sẽ không biết OEP của **upxflag2c1.exe** ở đâu và bắt buộc\nphải áp dụng các kĩ thuật dynamic analysis và static analysis trên IDA Pro để tìm ra hàm\nmain của chương trình này. ### 1. Kiểm tra file thực thi là 32 bit hay 64 bit: IDA Pro có 2\nbản, 1 bản để phân tích các file thực thi 32 bit và bản còn lại là 64 bit, do đó trước tiên chúng\nta cần phải kiểm tra xem file `upxflag2c1.exe` này là thuộc loại nào. Ở đây ta sẽ dùng [HxD]\n(https://mh-nexus.de/en/downloads.php?product=HxD) để kiểm tra: ![]\n(https://i.imgur.com/OTJQtUy.png) Các bạn có thể thấy chữ **PE..L** bên trong string của\nfile này, do đó nó là file 32-bit. Từ thông tin đó, chúng ta biết sẽ phải mở `upxflag2c1.exe`\nbằng phiên bản 32-bit của IDA. Khi giao diện của IDA xuất hiện, chọn New để mở file mới,\ntìm đường dẫn tới `upxflag2c1.exe` để load nó vào IDA. Giữ nguyên các thiết lập mặc định\nvà nhấn OK để IDA tiến hành phân tích file. ### 2. Phân tích tĩnh (Static analysis): Load file\nvào IDA và chọn **Manual load** vì tùy chọn này sẽ giúp chúng ta có thể **nạp tất các\nsection** của file, đồng thời bỏ lựa chọn **Create imports segment** (chuyên gia Ricardo\nNarvaja khuyến nghị nên bỏ chọn khi làm việc với các packed files). ![]\n(https://i.imgur.com/PtYGFpo.png) Với các \"Please enter an address\" box hiện ra sau đó,\nchúng ta sẽ click \"Ok\" hết. ![](https://i.imgur.com/pkb3G4H.png) Đây là lúc IDA nạp từng\nsection của PE file. Click \"Yes\" cho tất cả các \"Please confirm\" box như thế này để nạp hết\ntất cả các section. ![](https://i.imgur.com/uhsF31c.png) Đây là giao diện của IDA sau khi đã\nload file xong: ![](https://i.imgur.com/fSqnl08.png) Tiếp theo ta đi tìm Entry Point của file\n\n\n-----\n\nupxflag2c1.exe . Bắt đầu từ việc kiểm tra các section hay segment của file này bằng cách\nấn **Shift F7** để mở ra tab **Program Segmentation**. ![](https://i.imgur.com/qL6K1L3.png)\nClick vào segment UPX0 trước để xem code tại địa chỉ bắt đầu (`start=00401000`) của nó\nnhư thế nào. ![](https://i.imgur.com/CBhFjyu.png) Để ý tại địa chỉ `0040162D` có dòng\ncomment `CODE XREF: start+1BC↓j` (đọc thêm về XREF tại [đây]\n(https://reverseengineering.stackexchange.com/questions/18074/what-does-xref-mean)).\nĐây là một tham chiếu trong mã thực thi, chuột phải vào `start+1BC↓j` rồi chọn **Xrefs graph\nto ...** để xem xét câu lệnh này làm gì. ![](https://i.imgur.com/Tj7b5S4.png) Câu lệnh này\nđang tham chiếu đến entry point của file `upxflag2c1.exe`. ![]\n(https://i.imgur.com/LWJlRT0.png) Chuyển tới vùng code được tham chiếu đến và ta có lệnh\n`jmp near ptr byte_40162D` nằm ở entry point. ![](https://i.imgur.com/9eYu16C.png) Nhưng\nđây chỉ là **Entry point của Stub**, không phải OEP. Chúng ta cần debug chương trình bắt\nđầu từ lệnh `JMP` này để tìm ra hàm main. ### 3. Debug file PE bằng IDA: Ấn **F2** để đặt\nmột breakpoint tại function `jmp near ptr byte_40162D` này. Sau khi có break point thì nhấn\n**F9** để debug. Lưu ý chọn Debugger là **Local Windows debugger** để chúng ta có thể\ndebug trực tiếp trên localhost. Sau đó sẽ có pop-up **Debugger Warning** hiện lên thì ta\nchọn **Yes**. ![](https://i.imgur.com/IeRx66C.png) Thao tác debug trên IDA đồng nghĩa với\nviệc mở và thực thi luôn file `.exe`. Nhưng khác với việc ta click vào và như thông thường\nfile `.exe` sẽ chạy một mạch từ đầu đến điểm kết thúc của chương trình, debugger cho phép\nta nhảy tới điểm nào thì file `.exe` sẽ chạy đến đó. F8 liên tục (Step Over) để trace qua tất cả\ncác lệnh cho đến khi IDA sẽ hiển thị một thông báo như dưới, cứ nhấn **Yes** để thông báo\ncho IDA biết và nhận diện lại section **UPX0** ban đầu như là **CODE** (ban đầu nó được\nđịnh nghĩa là *DATA*). ![](https://i.imgur.com/SKU4lM0.png) Tiếp tục F8 liên tục cho đến khi\nIDA không cho chúng ta F8 nữa. Nó sẽ bị khựng lại khi nhảy đến một địa chỉ nào đó với lệnh\n`call sub_C1000`, đồng thời khi nhìn vào màn hình console đang chạy file `upxflag2c1.exe`\nlúc này thì thấy có in ra dòng chữ \"Enter password:\". Lệnh`call sub_C1000` sẽ gọi đến\n**hàm API `sub_C1000`**, rất có thể **hàm API này chính là hàm main của chương trình**\nnên khi debug đến đây chương trình mới in ra được \"Enter password:\" như thế. ![]\n(https://i.imgur.com/yIDPNoT.png) Đi vào hàm `sub_C1000` này để xem thì quả đúng là như\nvậy. ![](https://i.imgur.com/JbFKxQT.png) IDA cho phép ta đọc mã giả của hàm main này\nbằng cách ấn phím **Tab**. ![](https://i.imgur.com/tjLY1mZ.png) Mã giả do IDA Pro biên dịch\ncó syntax cực kì giống C, chỉ khác ở chỗ các tên hàm chưa được IDA biên dịch sẽ được để\ntheo format là `sub_XXXXX` và nhiệm vụ của chúng ta là debug và đọc assembly để xem\ncác hàm `sub_XXXXX` nó là hàm gì trong C. Đây là code C do mình biên dịch lại, đi kèm\ntheo comment giải thích từng dòng code ở bên cạnh. ```c= int main() { char v1; // contains\nflag int i; // _BYTE v3[100]; // byte pointer char v4[12]; // contains inputted password char\nv5[8]; // this variable depends on v3 strcpy(v3, aW000111222asss); // copy value of\naW000111222asss (a string) to pointer v3 for ( i = 0; i < 5; ++i ) // run a for loop from i=0 to 5\nv5[i] = v3[10 * i]; // to append each element in the index \"10*1\" of the string\naW000111222asss pointed by v3. v5[5] = 0; // assign the final element of string v5 with '\\x00'\nto terminate it. printf('Enter Password:', 5); scanf(&unk_3581B4, (char)v4); // input password\nto v4 if(!strcmp(v4, v5)) // compare v4 and v5 printf(\"You didn't say the magic word! No flag\n\n\n-----\n\nfor you!, v1); else printf( Congratulations! The flag is, v1); // v4 and v5 is the same, print v1\ncontainning. return 0; } ``` Tóm lại, password mà chúng ta đã cần tìm đang nằm ở biến `v5`.\nBiến này được tạo ra bằng cách iterate và append từng phần từ của string `v3` với index có\ncông thức là `10*i`. Mà `v3` này là pointer trỏ đến constant `aW000111222asss`. Và\n`aW000111222asss` nó nằm ở đây (click thẳng vào nó để xem): ![]\n(https://i.imgur.com/R3VkfOj.png) Chúng ta chỉ cần demo lại thuật toán để tạo ra `v5` rồi\nchạy là lấy được password. Ở đây mình sử dụng python: ![](https://i.imgur.com/z6Ifurb.png)\nPassword là `WALDO`. Giờ chỉ cần bật file `upxflag2c1` lên rồi nhập vào là lấy được flag. ![]\n(https://i.imgur.com/kA2mbbH.png) **Flag:** `CORRUPTED_FILE_CONFUSES_UPX`\n\n\n-----",
    "language": "VI",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-09 - Method of analyzing and unpacking compressed PE (Portable Executable) files.pdf"
    ],
    "report_names": [
        "2022-04-09 - Method of analyzing and unpacking compressed PE (Portable Executable) files.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535735,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653705636,
    "ts_modification_date": 1653705636,
    "files": {
        "pdf": "https://archive.orkl.eu/d83061e1cf4e1561603f610ddd2b68fc219fceb9.pdf",
        "text": "https://archive.orkl.eu/d83061e1cf4e1561603f610ddd2b68fc219fceb9.txt",
        "img": "https://archive.orkl.eu/d83061e1cf4e1561603f610ddd2b68fc219fceb9.jpg"
    }
}