{
    "id": "c57f6d4b-14da-4636-961d-3bd61776ef57",
    "created_at": "2022-10-25T16:48:16.415571Z",
    "updated_at": "2025-03-27T02:15:35.639885Z",
    "deleted_at": null,
    "sha1_hash": "07ed9ccef8f3b0e30efe4c9110a73c5d537b6003",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-01-11T16:13:20Z",
    "file_modification_date": "2021-01-11T16:18:45Z",
    "file_size": 1338062,
    "plain_text": "### Vol.101\n\n\n-----\n\n## Contents\n\n##### Smoke Loader Learns New Tricks Overview of Smoke Loader's Operation 04\n\n Analysis of Injector 05\n\n Analysis of Main Bot 11\n\n Analysis of Plugin 20\n\n Conclusion 38\n\n\n#### Report Vol.101 2020 Q4\n\n\n###### ASEC (AhnLab Security Emergency-response Center) is a global security response group consisting of\n\n malware analysts and security experts. This report is published by ASEC and focuses on the most significant\n\n security threats and latest security technologies to guard against such threats. For further details, please visit\n\n AhnLab, Inc.’s homepage (www.ahnlab.com).\n\n\n-----\n\n# Smoke Loader Learns New Tricks\n\n##### Smoke Loader, a malware first discovered in 2011, has been continuously used and distributed\n\n by attackers ever since. Smoke Loader was in steady demands by attackers due to its various\n\n features and detection bypass techniques, which helped distribute CoinMiner malware.\n\n According to the weekly malware statistics, ASEC (AhnLab Security Emergency-response\n\n Center) discovered that Smoke Loader has been consistently distributed until very recently.\n\n The latest version of Smoke Loader was being distributed via an exploit kit and was acting as\n\n a medium to distribute ransomware. Also it was found using a different mapping injection\n\n technique, which copies shellcode into a different process using memory-mapped files.\n\n This report will introduce the analysis of Smoke Loader’s latest operation. In detail, we will take\n\n a closer look at the different injection methods.\n\n\n-----\n\n##### 1. Overview of Smoke Loader's Operation\n\n Smoke Loader in itself is closer to a downloader in terms of features. However, most of the\n\n plugins it supports have info stealer features, and it also supports plugins, such as DDoS.\n\n This implies that attackers can use Smoke Loader to download other malware, leak user\n\n information with various plugins, or simply as a DDoS botnet.\n\n Smoke Loader’s operation method is as follows:\n\n When Smoke Loader is executed, it injects a malicious shellcode into ‘explorer.exe,’ a normal\n\n process. However, the actual behavior is executed by ‘explorer.exe.’ It first connects to the C&C\n\n server and receives a command. In response to the command it can perform its tasks as a\n\n downloader that downloads additional malware from external sources. Afterward, it decrypts\n\n plugins received from the C&C server, runs another explorer.exe as a child process, and injects\n\n plugins with various features.\n\n Recently-sighted Smoke Loader was being distributed via the exploit kit, and at the time of the\n\n analysis, it was seen additionally downloading Stop ransomware. This meant that it was being\n\n used as a medium for ransomware distribution, and even if that was not the case, it could have\n\n downloaded additional malware at any time the attacker wished. When it was not operating\n\n as a downloader of additional malware, it acted as a DDoS botnet that received commands to\n\n launch a DDoS attack against specific addresses.\n\n Judging by the signature that exists in the binary of the Smoke Loader mentioned in this\n\n report, it can be assumed that this Smoke Loader is the 2020 version. Since it is the latest\n\n version, it differs significantly from that of the older versions in the context of injection\n\n methods. When injecting, Smoke Loader's latest version uses mapping injection by using\n\n memory-mapped file to copy the shellcode into a different address. This is the main difference\n\n between the older samples that used PROPagate technique for injection.\n\n\n-----\n\n##### 2. Analysis of Injector\n\n Smoke Loader is divided into the injector and the main bot. Injector, through\n\n analysis disruption technique and Clone DLL technique, injects the main bot into\n\n the explorer.exe, which is a normal process. The main bot carries out malicious\n\n behaviors such as communicating with the C&C server. Then, the injectors perform\n\n tasks related to analysis disruption and injection.\n\n There are also features aside from the items below. The malware first checks the\n\n language currently being used. If the language is Russian, it exits. The malware\n\n also checks for the integrity level of the current process, and if the level is lower\n\n than the medium level, it gives ‘runas’ factor, calls ShellExecuteExW() function, and\n\n restarts. This is because explorer.exe runs on a medium level. If the process that\n\n performs injection is of a lower level, the injection cannot be carried out, and further\n\n malicious behavior cannot be executed.\n\n 2.1. Analysis of disruption technique\n\n This section will introduce three major analysis disruption techniques among the\n\n techniques used by Smoke Loader: Anti Debugging, Anti VM, and Anti Sandbox.\n\n Note that because most of Smoke Loader's code is obfuscated and encrypted,\n\n as the codes are executed the process of decrypting codes to run afterwards is\n\n repeated. Also, when obtaining addresses of used functions, instead of directly\n\n calling GetProcAddress() API, it refers to PEB struct and directly obtains them.\n\n 1) Anti Debugging\n\n The Anti Debugging method first reads PEB struct and scans BeingDebugged\n\n flag located at +0x02 offset. If debugging is in progress, this flag is set to 1, and\n\n terminates.\n\n\n-----\n\n##### Afterward, it scans NtGlobalFlag flag that is located at +0x68 of PEB struct. Usually,\n\n this flag has the value of 0x00, but when it is executed due to debugger, it gains the\n\n value of 0x70, and terminates.\n\n As a last step, it uses NtQueryInformationProcess() function. If calling this function\n\n after giving ProcessDebugPort as an argument, and the debugging is in process, -1 (\n\n 0xFFFFFFFF) is returned.\n\n This means that the anti-debugging method used in Smoke Loader has various\n\n debugger detecting routines than the mentioned obfuscation and encryption methods.\n\n 2) Anti VM\n\n Anti VM method reads subkeys of the registry keys in Table 1 and confirms the\n\n virtual machine's strings.\n\n - HKLM\\System\\CurrentControlSet\\Enum\\IDE\n\n - HKLM\\System\\CurrentControlSet\\Enum\\SCSI\n\nTable 1. Subkeys of the registry key\n\n##### Table 2 shows strings that scan and virtual machines with the following strings.\n\n - Qemu : \"qemu\"\n\n - KVM : \"virtio\"\n\n - VMWare : \"vmware\"\n\n - VirtualBox : \"vbox\"\n\n - XEN : \"xen\"\n\nTable 2. Virtual machines that satisfy string condition\n\n\n-----\n\n##### Then, it assigns SystemInformationClass as SystemProcessesAndThreadsInformati\n\n on (0x5), and calls function RtlGetNativeSystemInformation(). As a result of calling\n\n this API, it earns a list of running processes and checks whether processes related to\n\n virtual machines are running, as shown in Table 3.\n\n - Qemu : \"qemu-ga.exe\", \"qga.exe\"\n\n - VirtualBox : \"vboxsservice.exe\", \"vboxtray.exe\"\n\n - VMWare : \"vmtoolsd.exe\"\n\n - Parallels : \"prl_tools.exe\"\n\nTable 3. Checking to confirm whether virtual machine-related processes are running\n\n##### Afterward, it assigns SystemInformationClass as SystemModuleInformation (0xB),\n\n and calls function RtlGetNativeSystemInformation(). Information of modules loaded\n\n to kernel area can be obtained through this, and then it scans for strings related to\n\n the virtual machine.\n\n - VMWare : \"vmci.s\" (vmci.sys), \"vmusbm\" (vmusbmouse.sys), \"vmmous\" (vmmouse.sys), \"vm3dmp\" (vm3dmp.sys), \"vmrawd\"\n\n(vmrawdsk.sys), \"vmmemc\" (vmmemctl.sys)\n\n - VirtualBox : \"vboxgu\" (VBoxGuest.sys), \"vboxsf\" (VBoxSF.sys), \"vboxmo\" (VBoxMouse.sys), \"vboxvi\" (VBoxVideo.sys), \"vboxdi\"\n\n(vboxdisp.sys)\n\n - KVM : \"vioser\" (vioser.sys)\n\nTable 4. Scan for virtual machine-related strings\n\n##### 3) Anti Sandbox and Anti-malware Bypass\n\n In the analysis above, the malware used RtlGetNativeSystemInformation() to obtain\n\n a list of running processes and ultimately scan virtual machines. ‘windanr.exe’ from\n\n\n-----\n\n##### Table 5, along with virtual machine related strings listed above, are the names of\n\n processes targeted for the scan. This process name is known to be running in a\n\n sandbox environment called ANY RUN. This means that the Smoke Loader does not\n\n continue with the behavior and terminates in a specific sandbox environment.\n\n - ANY.RUN : “windanr.exe”\n\nTable 5. Argument of string\n\n##### In a 64-bit environment, the malware additionally checks whether the current\n\n Windows OS was run as test mode. It assigns SystemInformationClass as System\n\n CodeIntegrityInformation(0x67), calls function NtQuerySystemInformation(), and\n\n checks whether the result value is CODEINTEGRITY_OPTION_TESTSIGN (0x2). In the\n\n latest 64-bit Windows OS, only the drivers that are normally signed can be loaded.\n\n Test mode environment, however, allows unsigned drivers to be loaded for driver\n\n developers. It can be assumed that attackers scan such an environment because\n\n there are cases of setting virtual machines in test mode for driver analysis in sandbox\n\n environments. According to the routine, however, the malware does not scan to\n\n find out whether CODEINTEGRITY_OPTION_TESTSIGN flag or 0x2 is included, but\n\n instead, scans for whether the value is precisely obtained. Thus, it can be assumed\n\n that if another option such as kernel mode integrity scan (CODEINTEGRITY_OPTION_\n\n ENABLED) is set, it does not work as intended.\n\n Additionally, it gives strings, shown in Figure 6, an argument and calls GeModule\n HandleA() API to checks whether there are DLLs (modules) with those names\n\n among the modules loaded to the current process. Among these, sbiedll.dll is a\n\n DLL that is loaded in a sandbox environment called Sandboxie, and aswhook.dll\n\n and snxhk.dll are DLLs loaded if an anti-malware product named Avast is installed.\n\n\n-----\n\n##### This means that the malware scans currently loaded modules to check whether the\n\n current environment is a sandbox environment or if a specific anti-malware product\n\n is installed.\n\n - Sandboxie : “sbiedll”\n\n - Avast : \"aswhook\", \"snxhk\"\n\nTable 6. Argument of strings\n\n##### 2.2. Clone DLL Technique\n\n Next, the report will examine ‘clone DLL technique,’ which Smoke Loader uses to\n\n bypass user-mode hooking. Smoke Loader copies ntdll.dll located at System32\n\n directory to Temp directory as four random string names, like 44DA.tmp. Afterward,\n\n it loads them as functions of LdrLoadDll(). If ntdll.dll is also loaded to the current\n\n process with the directory changed, the DLL is loaded to the process again, as\n\n shown in Figure 1.\n\nFigure 1. Newly loaded ntdll.dll\n\n##### For a sandbox-based security solution or anti-malware solution, DLL for monitoring\n\n purposes is injected into the process. Injected monitoring DLL hooks key API\n\n functions, and ntdll.dll is commonly targeted as a primary target. When calling API\n\n in a malware process hooked by monitoring DLL, it goes through monitoring DLL,\n\n allowing the monitoring of the malware’s behavior.\n\n\n-----\n\n##### In an environment where monitoring DLL is hooking API functions of current ntdll.\n\n dll, it is impossible to monitor the malware process because Smoke Loader loads a\n\n new ntdll.dll and calls API of the new ntdll.dll instead of APIs of the current ntdll.dll,\n\n preventing the existing hooked APIs from being called. The related technique was\n\n discussed in ASEC Report Vol.97, ‘ANALYSIS IN-DEPTH: User-Mode Hooking Bypass\n\n Techniques.‘\n\n Go to ASEC Report Vol.97\n\n 2.3. Injection\n\n Smoke Loader then injects the main bot, the substantial task performer, into the\n\n running Windows Explorer (explorer.exe). For API functions used at this time,\n\n functions of ntdll.dll newly loaded by Clone DLL technique are used.\n\n The injected data is encoded with the XOR key and is compressed. The current\n\n sample, from size 0x402DD9 to 0x2D02, is compressed and encoded data, and\n\n this data is XOR-decoded with the 0x80356B70 key. The result of this decoding\n\n is compressed with the LZ compression algorithm, and the malware uses the\n\n RtlDecompressBuffer() function to decompress it. Note that Smoke Loader is based\n\n on 32-bit OS, and in 64-bit OS, as explorer.exe is a 64-bit process, Smoke Loader\n\n encrypts and decompresses the 64-bit shellcode. 64-bit shellcode starts from\n\n 0x405ADB, which is right behind the 32-bit shellcode and has the size of 0x3CA5.\n\n Figure 2 shows the value of different data by architecture.\n\nFigure 2. Different data by architecture\n\n\n-----\n\n##### Older version of Smoke Loader used an injection method called PROPagate, but\n\n recently-found samples used mapping injection techniques, which uses shared\n\n memory-mapped file. This injection method is used when the injector is injecting\n\n the main bot into the explorer.exe and the main bot is injecting plugins.\n\n The malware first creates a section object and uses NtMapViewOfSection() function\n\n to map explorer.exe, a process targeted for injection, and the current process.\n\n Afterwards, when the data is copied to the mapped memory area of the current\n\n local process, data is used in a shared memory area in regards to the memory of the\n\n process targeted for injection.\n\n Other than the main bot shellcode, Smoke Loader also creates a section for the\n\n purpose of sending the directory name of the current malware and allocating\n\n memory to use in the future, repeating the above process twice. After injecting,\n\n the malware uses RtlCreateThread() function to operate the main bot injected in\n\n explorer.exe as a thread.\n\n 3. Analysis of Main Bot\n\n Smoke Loader’s main bot is a part that contains substantial features, and it operates\n\n after being injected into the explorer.exe. As explorer.exe, a normal process, runs\n\n internally, malicious behavior that Smoke Loader performs is seen as an activity of a\n\n normal process, which can complicate the malware detection process.\n\n The first task the main bot performs is creating two threads with features of ending\n\n the analysis tools by force. Since these threads operate repeatedly, analysis programs\n\n running in an environment that Smoke Loader is installed are shut down, it will shut\n\n down even if it is executed again.\n\n\n-----\n\n##### Next, communication with the C&C server takes place. The first set of data Smoke\n\n Loader receives consists of encoded commands and plugins. These plugins\n\n are encoded and saved in a file format. Then, the malware follows a decrypted\n\n command and recieves an external download URL. It serves as a downloader that\n\n downloaded additional malware.\n\n When additional malware is downloaded and executed the malware reads the codes\n\n again and decodes the file where encoded plugins are saved, runs explorer.exe as\n\n a child process, and injects into it. Note that, as shown in the process tree of Figure\n\n 3, the malware injects to each explorer.exe of each plugin. Thus, the user can check\n\n how many plugins are being operated by checking the number of explorer.exe\n\n created as child processes.\n\nFigure 3. Process Tree\n\n\n-----\n\n##### 3.1. Anti Analysis Tools\n\n The main bot creates two threads that perform tasks of scanning file name and\n\n Windows class, as shown below, and then ends the analysis tools by force.\n\n 1). File Name Scan\n\n The first thread gathers the file name of the running processes, and if they match\n\n the termination target, it ends the processes forcefully. Fifteen process names exist\n\n in the hash format as shown below. Note that because the key value of each sample\n\n is different, the hash value is different for each sample. Below is the list of force\n\n termination targets, which are mostly debuggers and monitoring tools.\n\n0x21A0BCF0 - autoruns.exe\n\n0x84995207 - procexp.exe\n\n0x537D7F12 - procexp64.exe\n\n0x8CB85509 - Procmon.exe\n\n0x506F17CF - procmon64.exe\n\n0x91974808 - tcpview.exe\n\n0x50ADED5F - wireshark.exe\n\n0x5B91613B - ProcessHacker.exe\n\n0x9AB77207 - ollydbg.exe\n\n0x07D90D1B - x32dbg.exe\n\n0x39D9001C - x64dbg.exe\n\n0x7BB74749 - idaq.exe\n\n0x7BB74163 - idaw.exe\n\n0x7E2CA0CC - idaq64.exe\n\n0x4406A0CC - idaw64.exe\n\nTable 7. Hash value by the process\n\n\n-----\n\n##### 2) Windows Class Check\n\n The second thread finds the current Windows classes, and if they match Windows class\n\n strings for termination, the thread terminates the process with that Windows class.\n\nFigure 4. Windows class check and termination routine\n\n##### As seen in Table 8, there are 8 Windows class strings, and the targets are debuggers\n\n and monitoring programs, identical to the filenames.\n\n0x16BD5185 - Autoruns\n\n0x3A807BB2 - PROCEXPL\n\n0xE292B92B - PROCMON_WINDOW_CLASS\n\n0x15A64B2D - TCPViewClass\n\n0x1D75A7DD - (Unconfirmed)\n\n0x08839CF8 - ProcessHacker\n\n0xC9A06FCC - OllyDbg\n\n0x15A764A4 - WinDbgFrameClass\n\nTable 8. Hash value by the process\n\n##### 3.2. Registering and Copying Task Scheduler\n\n Smoke Loader then copies the original malware as a random name into directory\n\n ‘\\AppData\\Roaming\\.’ It removes zone identifier in copied files that contains\n\n download history, and then adds them to the task scheduler. The COM object is\n\n\n-----\n\n##### used to add to the task scheduler, and the interval is set to 10 min. Table 9 shows\n\n CLSID and IID of COM that is used to add to the task scheduler.\n\n - CLSID TaskScheduler class : {0f87369f-a4e5-4cfc-bd3e-73e6154572dd}\n\n - IID ITaskService : {2FABA4C7-4DA9-4013-9697-20CC3FD40F85}\n\nTable 9. CLSID and IID of COM object\n\n##### Figure 5 shows the task scheduler file that has been created.\n\nFigure 5. Task scheduler file created\n\n##### 3.3. C&C Communication\n\n The task it performs next is communicating with the C&C server after decrypting\n\n and obtaining its server address. The C&C server addresses that exist in the current\n\n sample are shown in Table 10. Smoke Loader attempts to communicate with the\n\n\n-----\n\n##### C&C servers one at a time. If it fails to communicate with one server, it will attempt\n\n to connect to the next server address.\n\nhttp://rexstat35x[.]xyz/statweb955/\n\nhttp://dexspot2x[.]xyz/statweb955/\n\nhttp://atxspot20x[.]xyz/statweb955/\n\nhttp://rexspot7x[.]xyz/statweb955/\n\nhttp://fdmail85[.]club/statweb955/\n\nhttp://servicem977x[.]xyz/statweb955/\n\nhttp://advertxman7x[.]xyz/statweb955/\n\nhttp://starxpush7x[.]xyz/statweb955/\n\nTable 10. C&C server list\n\n##### Before connecting to the C&C server, it first looks for a bot ID. Since a bot ID is\n\n created based on the currently installed environment, it can be seen as a unique ID\n\n of the currently running Smoke Loader. When creating a bot ID, computer name\n\n that is obtained using GetComputerNameA(), volume serial number that is obtained\n\n using GetVolumeInformationA(), and hard-coded value 0x25A56A90 is used. Bot ID\n\n is the one obtained after using these values to obtain MD5.\n\n The malware, upon making further requests, creates a packet to use. The first is\n\n 0x07E4, and this means 2020 in decimal number. Seeing as the samples in the past\n\n had a value of 2017 and 2018, it can be assumed that this version was developed in\n\n 2020. This value is used as a method of verification when communicating with the\n\n C&C server later on. Aside from this, it also adds values such as computer name\n\n and ‘10001’ (0x2711) then encodes them with the rc4 algorithm. Figure 6 shows the\n\n content of the packet to send to the C&C server.\n\n\n-----\n\nFigure 6. Content of the packet to send to the C&C server\n\n##### Afterwards, it can receive an encoded response upon sending a POST request to\n\n the C&C server. When requesting a packet that is designated ‘10001,’ the response\n\n received from the C&C server consists of additional commands for Smoke Loader to\n\n execute, encoded plugins, and additional commands for the plugins.\n\n 3.4. C&C Command\n\n As for response data, the first 4-byte is the length of the C&C server that is located\n\n next, and the proportion of this size is decoded. For example, for data shown in\n\n Figure 7, the size of the command is about 0x87.\n\nFigure 7. Encoded commands\n\n##### The first 4-byte represent the size of the C&C server commands and how much will\n\n be decoded. In the example of Figure 8, the size of the command is 0x87.\n\n\n-----\n\nFigure 8. Decoded commands\n\n##### Figure 11 shows the of the decoded commands.\n\n-6|:|DDos (DDoS)_rules=6|https://nXXXXXXXXam.com/en/,|:||:|keylog_rules=iexplore.exe,opera.exe,chrome.exe,firefox.exe|:||:|plugin_\n\nsize=449864\n\n - 0x07E4 (2020): Signature.\n\n - 0x36 (6): C&C command\n\n - |:| : Plugin command separator\n\n - DDoS (DDoS)_rules=6|https://nXXXXXXXXam.com/en/,: DDoS (DDoS) plugin-related command\n\n - |:||:| : Plugin command separator\n\n - keylog_rules=iexplore.exe,opera.exe,chrome.exe,firefox.exe: Keylogger plugin-related command\n\n - |:||:| : Plugin command separator\n\n - plugin_size=449864: Size of the encoded plugin\n\nTable 11. ASCII analysis details\n\n##### The very first thing that exists is 0x07E4, which is 2020 in decimal number. This value,\n\n as mentioned above, is assumed to represent the year 2020. It is hard-coded into\n\n binary and is used to check whether the command will be normally received from the\n\n C&C server.\n\n Next is the real C&C server command with the size of 1-byte. For C&C command,\n\n ‘i,' ‘r,' ‘u,’ and numbers can arrive. ‘r,’ as it contains routine that self-deletes added\n\n\n-----\n\n##### task scheduler and encoded plugin files created with files, is a removal command. ‘i,’\n\n which connects to the C&C server and downloads and runs payload, is considered\n\n an install command. ‘u’ is similar to ‘i,’ but seeing that there is a routine that\n\n terminates processes that run plugins, is considered as upgrade command.\n\n Last, if a number is received instead of commands above, Smoke Loader attempts\n\n to connect to the C&C server as much as the number commanded and receives an\n\n encoded URL. Then it decodes this URL and performs the downloader feature by\n\n downloading additional files from the server and executing them.\n\n As shown in Figure 9, the packet number ‘10002’ is used when executing a\n\n command received from the C&C server. Remove command only sends the\n\n execution results. However, payloads for additional files can be received with\n\n install, upgrade, and commands with numbers. For the command that receives an\n\n additional payload, it runs the payload and sends packet number ‘10003’ at the end.\n\nFigure 9. Executing the command received from the C&C server\n\n\n-----\n\n##### Next, there are commands related to plugins that are separated by a plugin\n\n command separator. These commands are later used by plugins. Last, there is\n\n plugin_size, which are header-encoded plugins. Its size is what is configured in front\n\n of plugin_size. These plugins are encoded and saved as a random name in \\AppData\\\n\n directory, as shown in Figure 10.\n\nFigure 10. Files copied to \\AppData\\Roaming\\ directory and plugin files\n\n##### Note that the commands mentioned above are saved in memory-mapped files that\n\n were created with a bot ID name. This is to send commands to the plugins that will\n\n be injected into child process explorer.exe and be executed.\n\n 4. Analysis of Plugin\n\n When all procedures of the main bot are executed, Smoke Loader reads plugin data\n\n saved as a file format, runs explorer.exe as a child process, and injects each plugin.\n\n So far, ten plugins of Smoke Loader were confirmed, but it is known that it supports\n\n various other plugin types.\n\n 4.1. Account and Cookie Info Stealer\n\n Information of command used and packet transmitted for stealing user and cookie\n\n data is as follows:\n\n\n-----\n\n - Command: Not required\n\n - Transmitted packet: 10004 (x86)\n\nTable 12. Command and transmitted packet\n\n##### Smoke Loader’s plugin use similar methods to that of what ordinary info stealer\n\n malware use to perform feature of stealing account information and cookies from\n\n programs, such as web browsers and email clients. Note that for the main bot,\n\n packet number from 10001 to 10003 are used. Then, 10001 is used to send stolen\n\n information to the C&C server because it is the next number listed.\n\nFigure 11. Packet 10004, which is used in this plugin\n\n##### The targets for plugin data leakage are listed in Table 13.\n\n - Web Browser: FireFox, Internet Explorer, Edge, Chrome, Chromium, Amigo, QQBrowser, Yandex, Opera\n\n - Email Client: Outlook, Thunderbird\n\n - FTP Client: FileZilla, WinSCP\n\nTable 13. Targets for information leakage\n\n##### For Firefox and Thunderbird, the plugin steals account information and cookies from\n\n the logins.json file and cookies.sqlite file, and the same goes for Chromium-based\n\n\n-----\n\n##### web browsers where the plugin steals account information and cookies from Login\n\n Data file and Cookies file. It also targets Windows Vault, which includes account\n\n information of Internet Explorer and Edge browser from its target.\n\nFigure 12. Outlook information leakage routine\n\n##### An outlook that includes account information in registry, registry key of WinSCP, and\n\n configuration files of FileZilla are also targets.\n\n 4.2. Process Monitoring\n\n Information of command used and packet transmitted for process monitoring is as\n\n follows:\n\n - Command: \"procmon_rules\"\n\n - Transmitted packet: 10005, 10006 (x86)\n\nTable 14. Command and transmitted packet\n\n##### Table 15 shows an example of the command for an explanation. The command\n\n consists of the process name, three commands from 0 to 2, and unused numbers\n\n for distinction.\n\n\n-----\n\n - |:|procmon_rules=test1.exe|0?81,test2.exe|1?82,test3.exe|2?83\n\nTable 15. Command example\n\n##### This plugin periodically monitors processes, as shown in Figure 13, and when a\n\n process that matches the process name received as a command is confirmed, it\n\n executes the command that corresponds to each process name.\n\nFigure 13. Command supported by the plugin\n\n##### For example, test1.exe has command 0, which is the downloader command. While\n\n monitoring, if a process running with test1.exe is confirmed, the plugin sends packet\n\n 10005 for the process name to the C&C server, then downloads and executes\n\n additional malware. Ultimately, the plugin transmits packet 10006 to the C&C server.\n\n test2.exe gains command 1, and if a process with that name is found while\n\n monitoring, it is terminated by force. test3.exe gains command two, which is a\n\n reboot command, and if process test3.exe is running, attempts reboot, as shown in\n\n Figure 14. Upon executing commands 1 and 2, it transmits packet 10006 to the C&C\n\n server and notifies whether the process was a success or not.\n\n\n-----\n\nFigure 14. Reboot command\n\n##### 4.3. Web Browser Cookie Stealer\n\n Information of command used and packet transmitted for stealing web browser\n\n cookie is as follows:\n\n - Command: “fgclearcookies”\n\n - Transmitted packet: 10007 (x86)\n\nTable 16. Command and transmitted packet\n\n##### The plugin has a feature of stealing cookie info from a web browser. Instead of\n\n leaking cookie info that exists as the data file, it deletes pre-existing cookie files and\n\n leaks cookie data that is sent when the user connects to a website from the user's PC.\n\n Plugins with hooking feature, including this plugin, works as an injector when\n\n executed in explorer.exe, but also works when injected into other processes. This\n\n means that it has both the feature of injecting itself as an injector while monitoring\n\n certain processes. The feature of hooking also leaks information when acting in the\n\n process after being injected.\n\n\n-----\n\nFigure 15. Injector and injected functions\n\n##### The plugin first checks if there are ‘fgclearcookies’ among the commands received\n\n from the C&C server. If it exists, then it terminates all processes shown in Table 17.\n\n This is because if those processes are running, cookie deletion may fail.\n\n - iexplore.exe, microsoftedge.exe, microsoftedgecp.exe, firefox.exe, chrome.exe, opera.exe, browser.exe, plugin-container.exe\n\nTable 17. List of terminated processes\n\n##### Next, it deletes cookie files that exists in file path, such as '\\AppData\\Local\\\n\n Google\\Chrome\\User Data\\Default\\Cookies\", \"\\AppData\\Local\\Pakages\\Microsoft.\n\n MicrosoftEdge_8wekyb3d8bbwe\\.'\n\n It monitors running processes, and when a web browser, as shown in Table 18, is\n\n running, it injects itself.\n\n - firefox.exe, iexplorer.exe, chrome.exe, opera.exe, microsftedgecp.exe\n\nTable 18. Processes for monitoring\n\n\n-----\n\n##### The injected plugin hooks functions of DLLs, as shown in Table 19.\n\n - iexplorer.exe, microsoftedgecp.exe: HttpSendRequestA(), HttpSendRequestW(), InternetWriteFile(), HttpQueryInfoA(),\n\nInternetQueryOptionA(), InternetGetCookieA() - wininet.dll\n\n - firefox.exe: PR_Write() - nspr4.dll or nss3.dll\n\nTable 19. DLL for hooking\n\n##### Figure 16 shows codes that are responsible for hooking various APIs to obtain\n\n information.\n\nFigure 16. Hooking various APIs to obtain information\n\n##### The plugin uses a slightly different method for Chrome and Opera web browsers.\n\n Instead of hooking functions of related DLLs, it hooks functions that process SSL/\n\n TLS data. The problem is that as these functions are built statically in the DLL and\n\n\n-----\n\n##### functions are not exported separately, Smoke Loader must find the address of these\n\n functions from related binary.\n\n Table 20 shows DLL where the hooking target function and the functions are\n\n located.\n\n - chrome.exe: Presumed to be ssl3_write_app_data() - chrome.dll\n\n - opera.exe: Presumed to be ssl3_write_app_data() - opera.dll or opera_browser.dll\n\nTable 20. Hooking target function and DLL location\n\n##### To find the function above, the plugin first looks for KTLSProtocolMethod VMT\n\n (Virtual Method Table) from the .rdata section, as shown in Figure 17. The method\n\n used here is finding the table with size 0x48 from the .rdata section, a table\n\n containing 18 functions. Next, it hooks the 9th function, and this is assumed to be\n\n function ssl3_write_app_data(). The size of this table and order of ssl3_write_app_\n\n data() can be different for each version of the Chromium-based web browser.\n\n Hence, this hooking of Smoke Loader only works normally for specific versions.\n\n\n-----\n\nTable 17. Code related to KTLSProtocolMethod VMT (Virtual Method Table)\n\n##### Then, when the user connects to a website and sends cookie-related info by using\n\n the hooked function above, the hooking function is exposed, and the plugin collects\n\n relevant data received as an argument and leaks it to the C&C server.\n\n 4.4. FTP, Email Account Info Stealer\n\n Information of command used and packet transmitted for stealing FTP and email\n\n account credentials is as follows:\n\n - Command: Not required\n\n - Transmitted packet: 10008 (x86)\n\nTable 21. Command and transmitted packet\n\n##### The plugin checks the current process list and injected itself again into the\n\n information leakage target process. Targets of information leakage are various web\n\n browsers, email clients, and FTP clients, as shown in Table 22.\n\n\n-----\n\n - Web Browser: firefox.exe, iexplorer.exe, chrome.exe, opera.exe, microsoftedgecp.exe\n\n - Email Client: outlook.exe, thebat.exe, thebat32.exe, thebat64.exe, thunderbird.exe, mailmaster.exe, 263em.exe, foxmail.exe, alimail.\n\nexe, mailchat.exe\n\n - FTP Client: filezilla.exe, smartftp.exe, winscp.exe, flashfxp.exe, cuteftppro.exe\n\nTable 22. Targets for data breach\n\n##### When injected into the target process, the plugin hooks send() function and\n\n WSASend() function of ws2_32.dll. The hooking function checks the packet that is\n\n transmitted when the function is used, and the targets are: ftp (port 21), smtp (port\n\n 25, 587, 2525), imap (port 110), and pop3 (port 143) protocols. Figure 18 shows the\n\n code that compares and shows each port number.\n\nFigure 18. Comparison of port numbers\n\n\n-----\n\n##### After that, the plugin checks whether the packet content contains the ‘USER’ and\n\n ‘PASS’ string, and these strings are used when logging in from ftp or email-related\n\n protocol. This means that the plugin leaks account credentials by hooking send()\n\n and WSASend() function, stealing this string when a specific protocol sends the\n\n verification-related packet.\n\n 4.5. File Leakage\n\n Information of command used and packet transmitted for file leakage is as follows:\n\n - Command: \"filesearch_rules\"\n\n - Transmitted packet: 10009 (x86)\n\nTable 23. Command and transmitted packet\n\n##### The plugin obtains the feature of collecting and compressing files that include\n\n strings received as keywords and leaking them to the C&C server. The relevant\n\n command could not be received during analysis, but it is known that there are\n\n records of receiving keywords such as ‘wallet,’ ‘2fa,’ and ‘backup.’ This means that\n\n the plugin targets wallet file, backup file, or verification-related files. Figure 19 shows\n\n codes related to the file leakage.\n\nFigure 19. File leakage\n\n\n-----\n\n##### 4.6. DDoS attack\n\n Information of command used and packet transmitted for DDoS attack is as follows:\n\n - Command: 'DDoS_rules'\n\n - Transmitted packet: 10010 (x86)\n\nTable 17. Command and transmitted packet\n\n##### DDoS plugin can receive the following commands: The first received command is\n\n attack method, and there are eight attack methods (0 to 7) including HTTP GET\n\n Flooding, HTTP POST Flooding, SYN Flooding, and UDP Flooding. The second\n\n received command is the address of the attack target.\n\n - DDoS_rules=6|https://test.com/\n\nFigure 20. Routine of Slowlis DDoS attack\n\n##### 4.7. Keylogger\n\n Information of command used and packet transmitted for keylogger attack is as\n\n follows:\n\n\n-----\n\n - Command: 'keylog_rules'\n\n - Transmitted packet: 10011 (x86)\n\nTable 24. Command and transmitted packet\n\n##### As aforementioned, the malware received command (Table 25) from the C&C server.\n\n - keylog_rules=iexplore.exe,opera.exe,chrome.exe,firefox.exe\n\nTable 25. Command received from the C&C server\n\n##### This plugin monitors processes and, if the received process is running, executes\n\n injection. The injected plugin hooks TranslateMessage() and GetClipboardData(),\n\n meaning that it has features of keylogging and clipboard leaking, as shown in\n\n Figure 21.\n\nFigure 21. Hooking for keylogging and clipboard information leaking\n\n\n-----\n\n##### 4.8. Hidden TeamViewer\n\n Information of command used and packet transmitted for Hidden TeamViewer\n\n attack is as follows:\n\n - Command: \"runhtv\"\n\n - Transmitted packet: 10012, 10013 (x86)\n\nTable 26. Command and transmitted packet\n\n##### The plugin has the feature of installing TeamViewer program secretly, sending ID\n\n and password to the C&C server, and allowing the attacker to remotely connect to\n\n the infected PC.\n\n First, if there is runhtv command, it sends packet 10012 to download TeamViewer.\n\n Then as shown in Figure 22, it uses the Hidden Desktop method to execute\n\n TeamViewer.exe without showing GUI to the user, and proceeds to inject itself.\n\nFigure 22. Hidden execution using Hidden Desktop\n\n##### Injected plugin hooks various functions to fulfill two purposes. One is to\n\n make sure the user is not aware. TeamViewer.exe itself was executed with the\n\n Hidden Desktop method, but it also hooks functions like CreateProcessW() and\n\n\n-----\n\n##### CreateProcessWithTokenW() and edits Desktop name to run child processes\n\n with the Hidden Desktop method. It also hooks functions like MessageBoxA(),\n\n MessageBoxW(), and DialogBoxParamW() and makes them return 1 to hide related\n\n GUI. Figure 23 shows various API hooking routines in codes.\n\nFigure 23. Various API hooking routines\n\n##### The second purpose is to send ID and password at the time of installation to the\n\n infected PC to the C&C server. TeamViewer, upon being executed, automatically\n\n creates ID and password and displays them on the GUI screen. The one who knows\n\n this ID and password can remotely connect to the environment where TeamViewer is\n\n installed. TeamViewer shows this on the GUI screen after creating ID and password,\n\n\n-----\n\n##### and the API that is used is function SetWindowsTextW(). This means that, as shown\n\n in Figure 24, by hooking the same function, it obtains the string when showing ID\n\n and password, and it sends the information to the C&C server to allow attackers to\n\n remotely connect to PC using TeamViewer.\n\nFigure 24. Hooking SetWindowsTextW() function to obtain ID and password\n\n##### 4.9. User Mail Data Stealer\n\n Information of command used and packet transmitted for stealing user mail data is\n\n as follows:\n\n - Command: Not required\n\n - Transmitted packet: 10015 (x86)\n\nTable 27. Command and transmitted packet\n\n\n-----\n\n##### This plugin, as shown in Figure 25, leaks data files of user mail, such as .pst and .ost\n\n file of outlook.\n\nFigure 25. Leaking mail user data\n\n##### The targets for data breach and the target files are listed in Figure 28.\n\n - Outlook: .pst, .ost\n\n - Thunderbird: .mab, .msf, inbx, sent, template, drafts, archives\n\n - The Bat!: .tbb, .tbn, .abd\n\nTable 28. Targets for information leakage\n\n##### Directories, where the files are saved, are also designated, as shown in Table 29.\n\n - Outlook : \"%APPDATA%Microsoft\\Outlook\", \"%LOCALAPPDATA%Microsoft\\Outlook\", \"%ALLUSERSPROFILE%\\Microsoft\\Outlook\"\n\n - Thunderbird : \"%APPDATA%Thunderbird\"\n\n - The Bat! : \"%ALLUSERSPROFILE%\\The Bat!\", \"%APPDATA%\\BatMail\", \"%ALLUSERSPROFILE%\\BatMail\"\n\nTable 29. Directories of target files\n\n##### 4.10. Fake DNS\n\n Information of command used and packet transmitted for Fake DNS attack is as\n\n follows:\n\n\n-----\n\n - Command: “fakedns_rules”\n\n - Transmitted packet: None\n\nTable 30. Command and transmitted packet\n\n##### It performs an injection when the web browser, shown in Table 31, is executed.\n\n - firefox.exe, iexplorer.exe, chrome.exe, opera.exe, microsoftedgecp.exe\n\nTable 31. Processes for injection\n\n##### After the injection, it hooks GetAddrInfoW() function and GetAddrInfoExW()\n\n function of ws2_32.dll. When receiving the IP address of a certain URL after calling\n\n the functions from the web browser, the hooking function obtains the feature of\n\n comparing the IP address to the address received by command and changing it to\n\n the address assigned by the attacker. Figure 26 shows codes related to DNS query\n\n hooking.\n\nFigure 26. DNS query hooking\n\n\n-----\n\n##### 5. Conclusion\n\n Since its first appearance in 2011, Smoke Loader is constantly being distributed\n\n via exploit kit. As shown in this paper, Smoke Loader uses various plugins to not\n\n only leak user information but also download additional ransomware and encrypt\n\n the target PC. Furthermore, Smoke Loader enables attackers to utilize the user PC\n\n as a DDoS botnet, launch DDoS attacks, and install remote management tool to\n\n compromise the target PC. Being infected by Smoke Loader means that the infected\n\n PC is exposed to various forms of attacks. Companies and organizations must strive\n\n to improve security awareness among all employees, apply the latest security patch\n\n to all OS, and come up with effective prevention measures.\n\n AhnLab’s anti-malware solution, V3, detects and blocks Smoke Loader malware\n\n using the following aliases.\n\n [File Detection]\n\n - Trojan/Win32.Smokeldr.C4195812 (2020.09.14.04)\n\n [Behavior Detection]\n\n - Malware/MDP.Inject.M218\n\n [IOC]\n\n - Hash: 1fecfbf3b4ad934c79dd4b2b8fedce4d\n\n - C&C\n\n\n##### http://rexstat35x[.]xyz/statweb955/\n\n http://dexspot2x[.]xyz/statweb955/\n\n http://atxspot20x[.]xyz/statweb955/\n\n http://rexspot7x[.]xyz/statweb955/\n\n\n##### http://fdmail85[.]club/statweb955/\n\n http://servicem977x[.]xyz/statweb955/\n\n http://advertxman7x[.]xyz/statweb955/\n\n http://starxpush7x[.]xyz/statweb955/\n\n\n-----\n\n#### Report Vol.101\n\nContributors **ASEC Researchers**\n\nEditor **Content Creatives Team**\n\nDesign **Design Team**\n\n\nPublisher **AhnLab, Inc.**\n\nWebsite **www.ahnlab.com**\n\nEmail **global.info@ahnlab.com**\n\n\nDisclosure to or reproduction for others without the specific written authorization of AhnLab is prohibited.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/Report/AhnLab/ASEC_REPORT_vol.101_ENG.pdf",
        "https://global.ahnlab.com/global/upload/download/asecreport/ASEC%20REPORT_vol.101_ENG.pdf"
    ],
    "report_names": [
        "ASEC_REPORT_vol.101_ENG",
        "ASEC%20REPORT_vol.101_ENG.pdf"
    ],
    "threat_actors": [
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1610381600,
    "ts_modification_date": 1610381925,
    "files": {
        "pdf": "https://archive.orkl.eu/07ed9ccef8f3b0e30efe4c9110a73c5d537b6003.pdf",
        "text": "https://archive.orkl.eu/07ed9ccef8f3b0e30efe4c9110a73c5d537b6003.txt",
        "img": "https://archive.orkl.eu/07ed9ccef8f3b0e30efe4c9110a73c5d537b6003.jpg"
    }
}