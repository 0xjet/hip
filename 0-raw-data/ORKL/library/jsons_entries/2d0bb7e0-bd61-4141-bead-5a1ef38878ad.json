{
    "id": "2d0bb7e0-bd61-4141-bead-5a1ef38878ad",
    "created_at": "2022-10-25T16:48:10.706738Z",
    "updated_at": "2025-03-27T02:12:54.88116Z",
    "deleted_at": null,
    "sha1_hash": "e03962d19b844e0d8a5981af06762c4b25bb49f9",
    "title": "The Adventures of a Keystroke.pptx",
    "authors": "",
    "file_creation_date": "2013-10-14T20:45:46Z",
    "file_modification_date": "2013-10-14T20:45:46Z",
    "file_size": 32653172,
    "plain_text": "### The Adventures of a KeyStroke\n\n###### An in-depth look into Keyloggers on Windows\n Emre TINAZTEPE\n\n\n-----\n\n# What you will learn?\n\n###### ¡ Completing this training, you will be able to:\n ¡ Use a kernel debugger for malware analysis,\n\n ¡ Understand the threats posed by keyloggers,\n ¡ Detect / Remove all kinds of keyloggers,\n ¡ Understand how a keylogger works in greatest detail,\n\n ¡ Be prepared to Advanced Persistent Threats!\n\n ¡ We will cover a lot of OS Internal structures.\n\n ¡ Without dealing with OS Internals, you can’t be sure\n that your system is clean.\n\n\n###### 2\n\n\n-----\n\n# Who am I?\n\n###### ¡ Emre TINAZTEPE\n\n ¡ Ex military:\n\n ¡ Maltepe Military High School (21 / 421)\n ¡ Turkish War Academy (8 / 838)\n\n ¡ Passed half of his life in the army (First Lieutenant)\n ¡ Resigned 3 years ago.\n\n ¡ Low level guy who likes to deal with OS Internals\n\n ¡ Currently leading a Malware Analysis Team\n\n ¡ Responsible of malware analysis and mobile av dev.\n\n\n###### 3\n\n\n-----\n\n# Methodology\n\n###### ¡ Hard to easy because it all starts at hardware L\n\n ¡ If you have question, just interrupt me.\n\n ¡ Hands on labs combined with theory.\n\n ¡ Labs are made in a Win 7 x32 machine.\n\n\n###### 4\n\n\n-----\n\n# Why keyloggers?\n\n###### ¡ Because keyboard is the device you command your\n computers.\n\n ¡ Logging keys from a PC provides the malware\n authors with great power. \n\n ¡ Best way to gather intelligence.\n\n ¡ Russia is said to be switching to “typing machines” in\n critical institutions.\n\n ¡ Best way to get rich J\n\n\n###### 5\n\n\n-----\n\n# Before we begin\n\n###### ¡ Please download these files:\n ¡ Materials: http://bit.ly/1aLVnOI (pass: infected)\n\n ¡ Labs: http://bit.ly/16FZ73t\n\n ¡ Please turn your AV/Windows Defender OFF!\n\n\n###### 6\n\n\n-----\n\n# VirtualBox\n\n\n###### 7\n\n\n-----\n\n# Window Detective\n\n\n###### 8\n\n\n-----\n\n# API Monitor\n\n\n###### 9\n\n\n-----\n\n# Rootkit Unhooker\n\n\n###### 10\n\n\n-----\n\n# GMER / Tuluka\n\n\n###### 11\n\n\n-----\n\n# Process Explorer\n\n\n###### 12\n\n\n-----\n\n# Windbg\n\n\n###### 13\n\n\n-----\n\n# Windbg Cheat Sheet\n\n###### ¡ lm : Lists loaded modules (drivers, dlls)\n\n ¡ !process -1 0 : Displays current process �\b\u001d\n\n ¡ !process 0 0 winlogon.exe : Displays info for the process �\b\u001d\n\n ¡ .process EPROCESS : Switches to the process (implicit)\n\n ¡ bp ADDRESS : Puts a breakpoint at the address\n\n ¡ g,p,t : Go, Step, Trace\n\n ¡ bl : Lists the breakpoints\n\n ¡ bc INDEX : Clears the BP indicated by the index\n\n ¡ bd INDEX : Disables BP temporarily \n\n ¡ .echo : Outputs a string\n\n\n###### 14\n\n\n-----\n\n# Windbg Cheat Sheet\n\n###### ¡ .cls : Clears the screen\n\n ¡ u ADDRESS / SYMBOL : Unassembles the address\n\n ¡ uf ADRESS OF FUNCTION : Unassembles the whole func.\n\n ¡ db ADDRESS : Dumps the address.\n\n ¡ ? poi(ADDRESS) : Displays the address pointed by.\n\n\n###### 15\n\n\n###### ¡ !pic / !ioapic : Displays information about interrupt controllers.\n\n ¡ !drvobj \\Driver\\kbdclass 0x7: Display the specified driver.\n\n ¡ !devobj OBJECT : Display information about device obj.\n\n\n-----\n\n# Let’s infect ourselves\n\n###### ¡ Restart RED VM, make sure it is not in “KERNEL DEBUG” mode.\n\n ¡ Go to Materials/Keyloggers directory\n\n ¡ Double click “Elite Keylogger.exe”\n\n ¡ Install with default settings (Click NEXT multiple times)\n\n ¡ Choose “Allow” in case Windows Defender consents.\n\n ¡ Restart the VM in non debug mode.\n\n\n###### 16\n\n\n###### ¡ Write “unhide” on start menu and provide a password at least 3 chars\n long.\n\n ¡ Fire up a “Notepad” and write your name in it.\n\n ¡ Please also provide your Credit Card number JJJ\n\n ¡ Do not save it please, it is safer ???\n\n\n-----\n\n# You are infected now L\n\n###### ¡ We will see how to detect keyloggers in the following ours.\n\n ¡ For the moment, please restore your VM to snapshot\n\n\n###### 17\n\n\n###### “Informatics” and start your VM in “Kernel Debugging” Mode.\n\n\n-----\n\n# Ready to dive?\n\n\n###### 18\n\n\n-----\n\n# An overview of a mother board\n\n###### CPU\n\n Front Side Bus (FSB)\n\n North Bridge\n\n Internal Bus (IB)\n\n Peripherals\n\n\n###### 19\n\n\n-----\n\n# An overview of a mother board\n\n###### ¡ Bus is a communication system that transfers data\n between components inside a computer,\n\n ¡ FSB is the CPU's connection to the North Bridge and\n through it to rest of the system,\n\n ¡ North Bridge is a high-speed hub that in most\n systems connects the CPU to the graphics card and to RAM,\n\n ¡ South Bridge is a slower-speed hub that connects\n the CPU to the rest of the system.\n\n\n###### 20\n\n\n-----\n\n# South Bridge (SB)\n\n###### ¡ It is also named as “Input/Output Controller Hub”.\n\n ¡ Responsible from the peripheral device connections\n such as USB, PCI, PS/2, Sound and etc.\n\n ¡ Why two bridges? \n ¡ Same as the idea of having RAM, Cache, Register\n\n ¡ Simpler design which is easy to modify in terms of IO\n capabilities.\n\n ¡ It is what you actually connect your keyboard to.\n\n\n###### 21\n\n\n-----\n\n# PS/2 Keyboard Controller\n\n###### ¡ A component of a mainboard which handles the\n connection between a motherboard and a PS/2 keyboard.\n\n\n###### 22\n\n\n-----\n\n# PS/2 Keyboard\n\n###### ¡ Just a limited computer system which scans a\n wireframe continuously for finding a closed/opened circuit.\n\n\n###### 23\n\n\n-----\n\n# PS/2 Keyboard\n\n###### ¡ The PS/2 Keyboard is a device that talks to a PS/2\n controller using serial communication. \n\n ¡ The PS/2 Keyboard accepts commands and sends\n responses to those commands, and also sends scancodes indicating when a key was pressed or released.\n\n ¡ The keyboards processor includes its own timer, 33\n instruction set, and can even access 128K of external memory.\n\n 16 Byte Buffer\n\n\n###### 24\n\n\n-----\n\n# Talking to a Keyboard?\n\n###### ¡ A PS/2 Keyboard accepts many types of commands, \n\n ¡ Each command is one byte,\n\n ¡ Some commands have data byte/s which must be\n sent after the command byte,\n\n ¡ The keyboard typically responds to a command by\n sending either an \"ACK\" (to acknowledge the command) or a \"Resend\" (to say something was wrong with the previous command) back.\n\n\n###### 25\n\n\n-----\n\n# Talking to a Keyboard?\n\n###### - Commands must be sent one at a time (IN/OUT), - Some commands have data byte/s which must be sent after the\n command byte, - 0xFE (resend) expects a command to be sent again,    while 0xFA (ACK) means command is successfully processed.\n\n\n###### 26\n\n\n-----\n\n###### PS/2 Keyboard Controller/Encoder Ports\n\n IO Port Access Type Purpose\n\n Keyboard Encoder\n\n 0x60 Read Read Input Buffer\n\n 0x60 Write Send Command\n\n Keyboard Controller\n\n 0x64 Read Status Register\n\n 0x64 Write Send Command\n\n - Port 0x60 is what we use for reading and writing data to/from the\n keyboard device, - The Status Register contains various flags that indicate the state of\n the PS/2 controller such as the state of input/output buffers, - The Command Port (0x64) is used for sending commands to the PS/2\n Controller (not to PS/2 Devices).\n\n\n###### 27\n\n|IO Port|Access Type|Purpose|\n|---|---|---|\n|Keyboard Encoder|||\n|0x60|Read|Read Input Buffer|\n|0x60|Write|Send Command|\n|Keyboard Controller|||\n|0x64|Read|Status Register|\n|0x64|Write|Send Command|\n\n\n-----\n\n###### Some of the PS/2 Keyboard Encoder Commands\n\n\n###### 28\n\n|Command|Description|Data|\n|---|---|---|\n|0xED|Set LEDs|Bit0: ScrollLock Bit1: NumberLock Bit2: CapsLock|\n|0xEE|Echo|For diagnostic purposes.|\n|0xF0|Get/set current scan code set|0: Get current scan code set 1: Set scan code set 1 2: Set scan code set 2 3: Set scan code set 3|\n|0xF4|Enable scanning|-|\n|0xF5|Disable scanning|Discard key presses or mouse movements. Used especially while identifying the attached PS/2 device in order to prevent messing up the identification process.|\n\n\n-----\n\n# Scancodes and Code Sets\n\n###### ¡ A scan code set is a set of codes that determine\n when a key is pressed or repeated, or released.\n\n Scancode\n\n Make Code Release Code\n\n\n###### 29\n\n\n###### Scancode\n\n\n-----\n\n# Scancodes and Code Sets\n\n###### ¡ There are 3 scan code sets, normally on PC\n compatible systems the keyboard itself uses scan code set 2 and the keyboard controller translates this into scan code set 1 for compatibility.\n\n Microsoft Keyboard Scan Code Specification Document\n\n\n###### 30\n\n\n-----\n\n# How to read scancodes?\n\n###### ¡ Poll the Bit 0 of status register and then read the\n data from port 0x60\n\n ¡ To much CPU time!\n ¡ Multiple PS/2 devices lead to problems for differentiating\n the data.\n\n ¡ Wait for an interrupt to occur\n ¡ Much better!\n\n ¡ Wait for an IRQ 1 / IRQ 12 (wait for the next slideJ)\n\n\n###### 31\n\n\n-----\n\n# What is an interrupt?\n\n###### ¡ Interrupt is a signal to the processor emitted by\n hardware or software indicating an event that needs immediate attention.\n\n    Do this and let me know when it’s done! \n I am a little bit busy J\n\n It’s done!\n\n\n###### 32\n\n\n###### CPU\n\n\n###### Let’s see what you have.\n\n\n###### Device (Harddisk, Keyboard)\n\n\n-----\n\n# Why called as “IRQ”?\n\n###### ¡ Each peripheral device requests to “Interrupt the\n CPU” this is why it is a “Request” which may or may not be handled by the CPU. \n\n ¡ Question: What happens when multiple devices\n send an IRQ at the same time?\n\n ¡ Answer: The one with a higher IRQL gets processed\n while the others keep waiting.\n\n\n###### 33\n\n\n-----\n\n# Interrupt Handling\n\n###### ¡ One of the best advantages of an interrupt driven\n device is the ability to overlap device’s processing time with the CPU’s activity.\n\n Process a lengthy operation\n Device\n\n CPU\n\n t1 t2\n Issue an operation\n\n\n###### 34\n\n\n-----\n\n# Where do I connect my device?\n\n###### ¡ Question: If we have 2 or more devices attached to\n our mainboard, how will we differentiate one device’s interrupt from the other?\n\n ¡ Answer: Each motherboard has an at least one\n Programmable Interrupt Controller (PIC / APIC) into which your external devices get connected. You do not have to do anything, all is done seamlessly by this electronic circuit.\n\n\n###### 35\n\n\n-----\n\n### Programmable Interrupt Controller\n\n###### ¡ OMG! What is an interrupt controller?\n\n ¡ One of the most important chips making up the x86\n architecture,\n\n ¡ Without it, the x86 architecture would not be an\n interrupt driven architecture,\n\n ¡ The function of the PIC is to manage hardware\n interrupts and send them to the appropriate system interrupt. \n\n ¡ This way, no polling needed J\n\n\n###### 36\n\n\n-----\n\n### APIC\n\n###### ¡ More sophisticated interrupt handling and the ability\n to send interrupts between processors.\n\n ¡ In an APIC-based system, each CPU is made of a\n \"core\" and a \"local APIC\".\n\n Core Local APIC\n\n CPU\n\n\n###### 37\n\n\n###### Core Local APIC\n\n\n-----\n\n### I/O APIC\n\n###### ¡ The external I/O APIC is part of Intel’s system chip\n set. Its primary function is to receive external interrupt events from the system and its associated I/O devices and relay them to the local APIC as interrupt messages.\n\n ¡ It is programmed by the OS before enabling\n interrupt handling mechanism. \n\n Local APIC\n\n Local APIC I/O APIC\n\n Local APIC\n Interrupt Messages\n\n\n###### 38\n\n\n###### Local APIC\n\n\n###### External  Devices\n\n\n###### I/O APIC\n\n\n###### Local APIC\n\n\n-----\n\n### What magic CPU does to handle IRQs?\n\n###### ¡ There is no magic, we tell it what to do.\n\n ¡ We create a table of function pointers and tell the\n CPU where it resides.\n\n ¡ This table is called as “Interrupt Descriptor Table”\n and the address for this table is hold by a register called IDTR (IDT register).\n\n IDTR\n\n\n###### 39\n\n|Col1|Handler 0|Col3|\n|---|---|---|\n||Handler 1||\n||Handler 2||\n||Handler 3||\n||Handler 4||\n\n\n###### Handler 0\n\n Handler 1 Keyboard Interrupt Handler\n\n Handler 2\n\n Handler 3\n\n Handler 4\n\n IDT RAM\n\n\n-----\n\n### Intel x86 CPU Modes\n\n###### ¡ 3 + 1 Modes of operation is supported by CPU.\n ¡ Real Mode\n\n ¡ Virtual 8086 Mode\n ¡ Protected Mode\n ¡ System Management Mode\n\n\n###### 40\n\n\n-----\n\n### Real Mode\n\n###### ¡ Also called real address mode.\n\n ¡ Real mode is characterized by a 20-bit segmented\n memory address space and unlimited direct software access to all memory, I/O addresses and peripheral hardware.\n\n ¡ Real mode provides no support for memory\n protection, multitasking, or code privilege levels.\n\n ¡ Before the release of the 80286, which introduced\n Protected mode, real mode was the only available mode for x86 CPUs.\n\n ¡ In the interests of backwards compatibility, all x86\n CPUs start in real mode when reset.\n\n\n###### 41\n\n\n-----\n\n### Protected Mode\n\n###### ¡ Also called protected virtual address mode.\n\n ¡ It allows system software to use features such as\n virtual memory, paging and safe multi-tasking designed to increase an operating system's control over application software.\n\n Protected Power ON Real Mode\n Mode Create some  tables for  Virtual Memory and set PE bit in  CR0 register\n\n\n###### 42\n\n|Power ON Real Mode|Col2|Col3|\n|---|---|---|\n||Create some||\n\n\n###### Protected\n Mode\n\n\n-----\n\n### Virtual 8086 Mode\n\n###### ¡ Also called virtual real mode.\n\n ¡ Allows the execution of real mode applications that\n are incapable of running directly in protected mode while the processor is running a protected mode operating system.\n\n\n###### 43\n\n\n-----\n\n### System Management Mode\n\n###### ¡ Is an operating mode in which all normal execution\n (including the operating system) is suspended, and special separate software (usually firmware or a hardware-assisted debugger) is executed in high- privilege mode.\n\n ¡ SMM is a special-purpose operating mode provided\n for handling system-wide functions like:\n\n ¡ Handle system events like memory or chipset errors,\n ¡ Manage system safety functions, such as shutdown on\n high CPU temperature and turning the fans on and off,\n\n ¡ Emulate motherboard hardware that is unimplemented\n or buggy.\n\n\n###### 44\n\n\n-----\n\n### More on SMM\n\n###### ¡ A powerful mode of CPU which can even preempt\n the whole OS!!!\n\n ¡ SMM is entered via the SMI (system management\n interrupt)\n\n ¡ SMM is a really good place to execute malicious\n software without modifying the structures created by OS.\n\n Here comes the karate kick!\n\n\n###### 45\n\n\n-----\n\n### #1 SMM Rootkits\n\n\n###### 46\n\n\n-----\n\n### An overview of SMM Rootkits\n\n###### ¡ Did you know that you can see the keystrokes even\n before they are handled by “Interrupt Handler”?\n\n\n###### 47\n\n\n###### Normal Path\n\n Infected Path\n\n\n###### Normal Path\n\n\n-----\n\n### The implementation\n\n###### 1. Use SMRAM Control Register (SMRAMC)\n\n ¡ Check bit D_OPEN (is SMRAM visible to outside code)\n\n ¡ Check bit D_LCK (is SMRAMC is read-only, if yes a reset\n is needed)\n\n 2. If D_LCK bit is clear:\n\n 1. Set D_OPEN bit to make SMRAM visible to protected mode code,\n\n 2. Copy the SMM Handler code to the handler portion of SMRAM defined by Intel Docs,\n\n 3. Clear D_OPEN bit and set D_LCK bit to protect our evil code J\n\n 3. We are invisible!\n\n\n###### 48\n\n\n-----\n\n###### Routing IRQ 1 to Malicious SMM Handler\n\n 1. Modify the I/O APIC in such a way that when ever\n a user presses a key, our SMM code is executed,\n\n 2. SMM Handler reads the scan code, logs it and\n sends a special command to keyboard for overcoming the problem of a popped up scancode.\n\n 3. This in turn makes the next data written into the\n keyboard buffer available for OS Keyboard Interrupt handler,\n\n 4. Send an IPI to ourself for handling an emulated\n IRQ 1!\n\n 5. Let the OS think it is a real scancode generated by\n the keyboard encoder J\n\n\n###### 49\n\n\n-----\n\n###### Pros & Cons\n\n 1. Pros\n\n 1. Totally invisible to the OS!\n\n 2. No need to change any OS created structures.\n\n 3. Very hard to detect.\n\n 2. Cons\n\n 1. Works only with PS/2\n\n 2. Limited to single processor system\n\n 3. D_LCK bit is already set on modern systems L\n\n\n###### 50\n\n\n-----\n\n### #2 IDT Hooking\n\n\n###### 51\n\n\n-----\n\n###### Structure of an Interrupt Descriptor Table\n\n 1. Protected Mode counterpart of Real Mode\n Interrupt Vector Table (IVT),\n\n 2. Contains at most 256 entries.\n\n 3. Each entry is 8 bytes long and they are structured\n as defined below:\n\n nt!_KIDTENTRY   +0x000 Offset          : Uint2B   +0x002 Selector        : Uint2B   +0x004 Access         : Uint2B   +0x006 ExtendedOffset  : Uint2B\n\n\n###### 52\n\n\n-----\n\n###### Keyboard Interrupt is not mapped to IDT#1???\n\n 1. Where is IRQ 1 mapped? Which IDT Entry??? \n\n ¡ “IOAPIC makes IRQ and remaps IRQ to IDT.”\n\n\n###### 53\n\n\n###### kd> !ioapic �\b\u001d IoApic @ FEC00000 ID:1 (11) Arb:0 Inti00.: 00000000`000100ff  Vec:FF FixedDel  Ph:00000000   edg high   m Inti01.: 01000000`00000991 Vec:91 LowestDl Lg:01000000   edg high   Inti02.: 00000000`000100ff  Vec:FF FixedDel  Ph:00000000   edg high   m Inti03.: 00000000`000100ff  Vec:FF FixedDel  Ph:00000000   edg high   m\n kd> !idt –a 31: 84866058 i8042prt!I8042KeyboardInterruptService (KINTERRUPT 84866000) NO I/O APIC 91�\b\u001d : 84864058 i8042prt!I8042KeyboardInterruptService (KINTERRUPT 84864000)\n\n 2. Methods for retrieving the vector address:\n\n ¡ Use APIC\n ¡ Scan kernel memory\n ¡ Use the kernel API function (HalGetInterruptVector)\n\n\n-----\n\n###### How to read scancode?\n\n 1. It’s as easy as executing an “in al,60h” instruction J\n ¡ IN instruction empties the data, we need to put it back into its\n place for system’s use.\n\n\n###### 54\n\n\n###### 2. Here is an excerpt from the Keyboard Controller command\n set:\n\n Command 0xd2: Write keyboard output buffer\n Write the keyboard controllers output buffer with the byte next written to port 0x60, and act as if this is a keyboard generated data.\n\n\n-----\n\n###### Here is the method\n\n\n###### 55\n\n\n###### Record the keystroke into a buffer and execute the special keyboard controller command for putting it back into place\n\n\n-----\n\n### #3 Hacking KINTERRUPT\n\n\n###### 56\n\n\n-----\n\n###### Structure of a KINTERRUPT\n\n\n###### 57\n\n\n-----\n\n###### Where does this code come from?\n\n\n###### 58\n\n\n###### 1. KINTERRUPT->DispatchCode is actually a modified version\n of KiInterruptTemplate.\n\n 2. Can be easily modified for different kinds of interrupts such\n as KiChainedDispatch, KiFloatingDispatch.\n\n\n-----\n\n###### What does a DispatchCode do?\n\nAcquire the Raise the IRQL Release the\n\nCall the\n\nSpinLock of to Lower IRQL SpinLock of\n\nServiceRoutine\n\nServiceRoutine DEVICE_IRQL ServiceRoutine\n\n###### This is the point where “Interrupt Servicing” takes place!\n i8042KeyboardInterruptService\n\n\n###### 59\n\n\nAcquire the Raise the IRQL Release the\n\nCall the\n\nSpinLock of to Lower IRQL SpinLock of\n\nServiceRoutine\n\nServiceRoutine DEVICE_IRQL ServiceRoutine\n\n\nRelease the\n\nSpinLock of\nServiceRoutine\n\n\n-----\n\n###### How to intercept\n\n 1. Put an inline hook into DispatchCode’s prolog,\n\n\n###### 60\n\n\n###### 2. Create a new KINTERRUPT object and make EDI point to it,\n\n 3. Replace the ServiceRoutine field of KINTERRUPT,\n\n 4. Inline hook the ServiceRoutine.\n\n\n-----\n\n###### Windows Driver Model\n\n ¡ A layered design with support for adding drivers into the stack\n dynamically.\n\n ¡ Great design for management. \n\n ¡ Allows another driver to filter some other driver’s packets.\n\n\n###### 61\n\n\n-----\n\n###### Keyboard Device Stack\n\n\n###### 62\n\n\n-----\n\n###### What is an IRP?\n\n\n###### 63\n\n\n###### ¡ A structure which is used by the I/O manager for defining a request\n targeted to a device.\n\n ¡ Reading a file, writing to a file and much more operation is handled\n with IRPs.\n\n ¡ Each IRP has a Major code which makes it possible to call appropriate\n handler for that IRP.\n\n\n###### Upper Driver\n\n\n###### Lower Driver\n\n\n-----\n\n###### i8042prt.sys\n\n 1. Port driver for 8042 compatible keyboard and mouse\n devices.\n\n\n###### 64\n\n\n###### 2. Handles the interrupt for a keyboard device and delivers it\n to the system.\n\n 3. Contains good candidates for a keylogger.\n\n\n-----\n\n###### i8042prt.sys\n\n\n###### 65\n\n\n###### I8042prt.sys\n\n\nI8042KeyboardIsrDpc\n\n\nI8042KeyboardInterruptService\n\n\nI8042KeyboardIsrDpc\n\n\nI8042KeyboardInterruptService\n\n\n-----\n\n###### i8042prt.sys Overview\n\n\n###### 66\n\n\nI8xWriteDataToKeyboardQueue\n\n\n###### Adds the INPUT data into  keyboard input data queue\n\n\nCall IsrHookCallback if one is\nI8xGetByteAsynchronous I8xQueueCurrentKeyboardInput I8xWriteDataToKeyboardQueue\n\nregistered\n\n###### May also terminate the\n Adds the INPUT data into \n ISR by modifying \n\n\n###### Uses Globals.Read method\n internally\n\n\nI8xGetByteAsynchronous\n\n\n###### Queues a DPC for giving a  chance to class driver for processing\n the input data at DISPATCH LEVEL\n\n\n-----\n\n### #4 i8042prt!Globals Hack\n\n\n###### 67\n\n\n-----\n\n###### i8042prt.sys GLOBALS structure\n\n\n###### 68\n\n\n-----\n\n###### A look into i8042prt!Globals\n\n 8d94c601 ffb0a0000000  push  dword ptr [eax+0A0h] �\b\u001d 8d94c607 ff15cc40958d  call  dword ptr [i8042prt!Globals+0xc (8d9540cc)] 8d94c60d 8807          mov   byte ptr [edi],al 8d94c60f 0fb6c0        movzx  eax,al\n\n kd> dps i8042prt!Globals 8d9540c0 85799cd8 8d9540c4 8594cab8 8d9540c8 85a52c88 8d9540cc 8281a094 hal!READ_PORT_UCHAR 8d9540d0 8281a0fc hal!WRITE_PORT_UCHAR 8d9540d4 00720070 8d9540d8 859b3c80\n\n\n###### 69\n\n\n###### Replace it with your own J\n\n\n-----\n\n###### Globals Read Data Hook\n\n\n###### 70\n\n\n###### kd> bl *  0 d 8d94c57c   0001 (0001) i8042prt!I8xGetByteAsynchronous+0x81  \"r al;g;\"  1 d 8d94c599   0001 (0001) i8042prt!I8xGetByteAsynchronous+0x9e  \"r al;g;\"  2 e 8d94c60d   0001 (0001) i8042prt!I8xGetByteAsynchronous+0x112 \"r al;g;\"\n\n 0 3d 0 3d 0 3d 9 1d 1e 1d 9e 1d 1f 1d 9f 1d 20 1d a0 1d �\b\u001d 21 1d a1 1d 22 1d a2 1d 23 1d\n\n Here we have the keystrokes, also little noisy but can be parsed with a simple script. \n\n\n###### 0 3d 0 3d 0 3d 9 1d 1e 1d 9e 1d 1f 1d 9f 1d 20 1d a0 1d �\b\u001d 21 1d a1 1d 22 1d a2 1d 23 1d\n\n\n-----\n\n### #5 I8xGetByteAsynchronous\n\n\n###### 71\n\n\n-----\n\n###### I8xGetByteAsynchronous\n\n ¡ Defined as \n\n I8xGetByteAsynchronous(CCHAR KeyboardType,UCHAR*ScanCode)\n\n ¡ Pretty good place to hook.\n\n ¡ Internally uses Global.Read \n\n\n###### 72\n\n\n-----\n\n### #6 Hacking IsrHookCallback \n\n\n###### 73\n\n\n-----\n\n###### IsrHookCallback \n\n ¡ Used by upper level drivers to modify the scancode in the\n ISR routine. \n\n ¡ Gets called right after scan code is retrieved from the\n keyboard controller. \n\n\n###### 74\n\n\n-----\n\n###### Hack IsrHookCallback \n\n ¡ As easy as modifying DEVICE_EXTENSION of port device:\n\n ¡ DeviceObject->DeviceExtension->IsrHookCallback\n\n ¡ Right after that, keys will start flowing into our callback!\n\n ¡ Callback can even stop the ISR’s processing.\n\n\n###### 75\n\n\n-----\n\n### #7 Hacking ClassService\n\n\n###### 76\n\n\n-----\n\n###### What does I8xQueueCurrentKeyboardInput do?\n\n ¡ Queues a DPC for further processing.\n\n\n###### 77\n\n\n###### ¡ DPC calls DeviceExtension->ConnectData.ClassService function for\n delivering the scan code information to the class driver.\n\n ¡ Question: Can’t we hook that?\n\n ¡ Answer: Definitely yes!\n\n ¡ How: Replace the ClassService function with your own J\n\n\n-----\n\n###### I8xQueueCurrentKeyboardInput\n\n ¡ Queues a DPC object for further processing the input data.\n\n\n###### 78\n\n\n###### ¡ This gives class drivers or any upper level drivers a chance to\n process the input data structure, even modify it!\n\n ¡ As soon as IRQL drops to DISPATCH_LEVEL, DPC gets\n executed and calls the callback supplied by Class Driver.\n\n\nI8042KeyboardIsrDpc\n\n\n-----\n\n###### DPC – Deferred Procedure Call\n\n ¡ Time is a precious thing! \n\n ¡ Do what ever you can to make hardware feel better and\n queue a procedure to be called when everything is OK.\n\n\n###### 79\n\n\n###### ¡ This prevents keeping a CPU at a high IRQL level for a long\n time.\n\n\n-----\n\n### #8 I8xWriteDataToKeyboardQueue\n\n\n###### 80\n\n\n-----\n\n###### I8xWriteDataToKeyboardQueue\n\n ¡ A great candidate for hooking!\n\n\n###### 81\n\n\n###### ¡ Gets the INPUT data as it’s second parameter and writes that into it’s\n internal data queue.\n\n ¡ Flags describe whether the key is down or up.\n\n\n-----\n\n### #9 Filter Drivers\n\n\n###### 82\n\n\n-----\n\n###### How to filter?\n\n ¡ Meaning of layer in malware authors slang:\n\n ¡ “A point for injecting evil” \n\n ¡ Two methods:\n\n ¡ IoAttachDevice API: The IoAttachDevice routine attaches the\n\n\n###### 83\n\n\n###### caller's device object to a named target device object, so that I/O requests bound for the target device are routed first to the caller.\n\n NTSTATUS IoAttachDevice(  _In_  PDEVICE_OBJECT SourceDevice,  _In_  PUNICODE_STRING TargetDevice,  _Out_ PDEVICE_OBJECT *AttachedDevice );\n\n ¡ Registry hacks for devices. Set UpperFilter and LowerFilters. Upper\n filter drivers go between the operating system and the main driver, and lower filter drivers go between the main driver and the hardware.\n\n\n-----\n\n###### Let’s check for Keyboard Filters\n\n\n###### 84\n\n\n###### 1. Go to Materials/Applications copy RegShot directory to your Desktop.\n\n 2. Execute “regshot.exe”\n\n 3. Set output path to “Desktop”\n\n 4. Click on “1[st] Shot” -> “Shot”\n\n 5. Install “Zemana AntiLogger Free.exe”\n\n 6. Go to regshot again and click “2[nd] Shot” -> “Shot”\n\n 7. Click “compare”\n\n 8. Search for “UpperFilters” (Upper filters for keyboard device) ﻿\n\n 9. Copy the GUID and google it. Guess what does it define?\n\n 10. Restart the machine in DEBUG MODE and execute:\n\n 1. !drvobj \\Device\\kbdclass\n\n 2. !devstack SECOND OBJECT ADDRESS\n\n\n-----\n\n### #10 IRP Handler Hooking\n\n\n###### 85\n\n\n-----\n\n###### Keyboard Class Driver\n\n ¡ \\Driver\\kbdclass\n\n ¡ Represents a Keyboard Device either USB or PS/2. \n\n ¡ Used exclusively by the Raw Input Thread (RIT) (coming next).\n\n\n###### 86\n\n\n-----\n\n###### Look at the difference\n\n ¡ KbdClass has a READ routine while the Port Driver\n doesn’t! Why?\n\n\n###### 87\n\n\n-----\n\n###### Here is why\n\n ¡ Port driver doesn’t provide a read routine because it\n expects a “Keyboard Class Service Callback” to be registered by a class driver.\n\n ¡ Class driver gets the requests from the RIT and waits\n for KeyboardClassServiceCallback to get called by the keyboard port driver’s ISR DPC. \n\n ¡ This callback is registered by sending an IRP carrying a\n structure called as CONNECT_DATA with an IOCTL_INTERNAL_KEYBOARD_CONNECT code.\n\n ¡ This in turn makes the port driver record this callback\n routine for calling whenever an interrupt occurs.\n\n ¡ When ever the service callback gets called by port\n driver’s DPC, class driver completes the request of RIT which makes the RIT send another request.\n\n\n###### 88\n\n\n-----\n\n###### KeyboardClassServiceCallback \n\n ¡ Routine which dequeues an IRP each time it gets\n called by the port driver’s ISR DPC.\n\n ¡ As soon as data is copied to the IRP, it completes\n the IRP with STATUS_SUCCESS.\n\n\n###### 89\n\n\n-----\n\n### #12 Inline hooking for ClassCallback\n\n\n###### 90\n\n\n-----\n\n###### Hook the class callback\n\n ¡ We have already hacked this callback routine but in a\n different way. It was just a replacement of a pointer in ConnectData structure residing in port driver’s DeviceExtension.\n\n ¡ This time, another approach.\n\n ¡ Put an inline hook into KeyboardClassServiceCallback\n which will make us the king of scancodes J\n\n ¡ As easy as putting a 5 byte prolog into the routine.\n\n\n###### 91\n\n\n-----\n\n###### Let’s talk about “Raw Input Thread”\n\n ¡ A thread of csrss.exe which continuously makes a\n read request to keyboard class device.\n\n ¡ It is the guy who retrieves keystrokes from the\n class driver and posts them to appropriate queues.\n\n ¡ It’s mainly a loop which makes a request and waits\n for that request to complete which in turn makes another request and so forth…\n\n ¡ Key method here is StartDeviceRead which sends a �\b\u001d�\b\u001d\n read request to class driver asynchronously with an APC object.\n\n\n###### 92\n\n\n-----\n\n###### How it functions?\n\n\n###### 93\n\n\nMake an async\n\nread request\n**StartDeviceRead**\n\n\n###### Calls ProcessKeyboardInput\n\n\nGo to step one\n\n\nProcess the\nkeyboard data\n\nin APC routine\n\n\n-----\n\n### #13 Hacking Device Templates\n\n\n###### 94\n\n\n-----\n\n###### What is a Device Template?\n\n ¡ A structure for keeping device specific attributes\n such as keyboard and mouse.\n\n ¡ This is where the word “KbdClass” comes from J\n\n ¡ Also contains a function pointer which is responsible\n for processing the Keyboard or Mouse input hence the name : “ProcessKeyboardInput” \n\n\n###### 95\n\n\n-----\n\n###### Device Template\n\n\n###### 96\n\n\n-----\n\n###### It’s dump time\n\n\n###### 97\n\n\n-----\n\n### #14 Hook ProcessKeyboardInput\n\n\n###### 98\n\n\n-----\n\n###### ProcessKeyboardInput\n\n\n###### 99\n\n\n###### ProcessKeyboardInputWorker �\b\u001d\n\n\n-----\n\n###### Inside ProcessKeyboardInput\n\n ¡ Find the first call to worker function.\n\n ¡ EBX points to scancode,\n\n ¡ Worker function is also a good target.\n\n �\b\u001d\n\n\n###### 100\n\n\n-----\n\n### #15 Hook ProcessKeyboardInputWorker\n\n\n###### 101\n\n\n-----\n\n###### Inline Hook ProcessKeyboardInputWorker \n\n ¡ Pretty obvious J\n\n ¡ You can easily see that it is a 3 parameter function\n with the 1[st] parameter as ScanCode.\n\n\n###### 102\n\n\n-----\n\n### #16 Hacking xxxProcessKeyEvent\n\n\n###### 103\n\n\n-----\n\n###### xxxProcessKeyEvent\n\n ¡ Called by ProcessKeyboardInputWorker until each\n input event gets consumed. \n\n ¡ Lets take a look at the parameters:\n ¡ Pointer to a Keyboard Event structure,\n\n ¡ An ULONG_PTR value carrying extra information,\n ¡ A flag indicating if key is from hardware or not.\n\n ¡ Performs some language specific operations.\n\n\n###### 104\n\n\n-----\n\n###### Break on xxxProcessKeyEvent \n\n\n###### 105\n\n\n-----\n\n###### Virtual Key vs. Scan Code\n\n#### Scancode Virtual Key\n\n###### Hardware Dependent Independent\n\n\n###### 106\n\n\n-----\n\n###### Virtual Key vs. Scan Code\n\n\n###### 107\n\n\n-----\n\n###### xxxProcessKeyEvent \n\n\n###### 108\n\n\n###### xxxProcessKeyEvent \n\n\n-----\n\n###### Raw Key State Table\n\n ¡ Just a simple array holding UP / DOWN states of keys. \n\n ¡ Represents the physical state of keyboard.\n\n ¡ Let’s put a BP on it.\n\n\n###### 109\n\n\n-----\n\n###### Hook UpdateRawKeyState\n\n ¡ Two params:\n ¡ VirtualKey\n\n ¡ Key State (Make / Break)\n\n\n###### 110\n\n\n-----\n\n### #17 RawKeyState Sniffer\n\n\n###### 111\n\n\n-----\n\n###### Sniffing Raw Key State Table\n\n\n###### 112\n\n\n###### ¡ Can be easily retrieved by disassembling UpdateRawKeyState.\n\n ¡ First LEA instruction points to it,\n\n ¡ AV buster J\n\n\n-----\n\n###### Raw Key State Sniffer\n\n ¡ Put a BP on UpdateRawKeyState\n\n ¡ 2 bits for each VKEY (Down/Up – Toggled)\n\n\n###### 113\n\n\n-----\n\n###### Raw Key State Sniffer Demo\n\n ¡ Put a BP on UpdateRawKeyState end address.\n\n Offset: gafRawKeyState + (VK * 2 bits)\n\n\n###### 114\n\n\n-----\n\n### #18 Hacking xxxKeyEvent\n\n\n###### 115\n\n\n-----\n\n###### xxxKeyEvent\n\n ¡ Very critical function!\n\n ¡ Performs the POST operation of key into input queue.\n\n ¡ Called by xxxProcessKeyEvent for every input event.\n\n\n###### 116\n\n\n###### ¡ Responsible from calling window hooks (wait for next slides)\n\n ¡ Params: \n ¡ Virtual Key with flags,\n\n ¡ ScanCode\n\n\n-----\n\n###### xxxKeyEvent\n\n\n###### 117\n\n\n##### Call Low Update\n Level Async Key Post Input Keyboard State Message\n Hook Table\n\n\n##### Post Input\n Message\n\n\n-----\n\n###### xxxKeyEvent\n\n ¡ Very critical function!\n\n ¡ Performs the POST operation of key into input queue.\n\n ¡ Called by xxxProcessKeyEvent for every input event.\n\n ¡ Responsible of calling window hooks (wait for next slides)\n\n ¡ Params: \n ¡ Virtual Key with flags,\n\n ¡ ScanCode\n\n\n###### 118\n\n\n-----\n\n### #19 Hacking UpdateAsyncKeyState\n\n\n###### 119\n\n\n-----\n\n###### UpdateAsyncKeyState\n\n ¡ Looks same as the method for UpdateRawKeyState\n\n ¡ Async keystate table could also be sniffed.\n\n\n###### 120\n\n\n-----\n\n### #20 Hacking PostInputMessage\n\n\n###### 121\n\n\n-----\n\n###### PostInputMessage\n\n ¡ What it does?\n\n ¡ Calls StoreQMessage for saving the message into queue. ﻿\n Another target for hooking J\n\n ¡ Foreground thread queue receives the input event. \n\n\n###### 122\n\n\n-----\n\n###### PostInputMessage\n\n ¡ Put a BP on PostInputMessage.\n\n\n###### 123\n\n\n-----\n\n###### Here comes the second part J\n\n\n###### 124\n\n\n###### ¡ Thread now has an input event in it’s queue. Kernel is over!\n\n ¡ What’s next?\n\n\n-----\n\n###### Create Window API\n\n ¡ Creates a window with a Window Class. \n\n ¡ What is a window class? \n\n\n###### 125\n\n\n-----\n\n###### Classes vs. Windows\n\n\n###### 126\n\n\n## Window\n 3\n\n###### Window Procedure\n\n\n###### Window\n Class\n\n\n## Window\n 3\n\n\n## Window\n 1\n\n\n## 2\n\n\n-----\n\n###### WNDPROC Function\n\n ¡ Function defined as:\n\n LRESULT CALLBACK WindowProc(  _In_ HWND hwnd,  _In_ UINT uMsg,  _In_ WPARAM wParam,  _In_ LPARAM lParam );\n\n\n###### 127\n\n\n###### ¡ Every window has one WNDPROC. This is the entry point for\n window messages.\n\n\n-----\n\n### #21 Hacking Window Procedures\n\n\n###### 128\n\n\n-----\n\n###### WNDPROC Function\n\n\n###### 129\n\n\n###### ¡ We can either inline hook the WndProc or we can set a new\n WndProc by using GetWindowLong / SetWindowLong APIs.\n\n\n-----\n\n### #22 Subclassing a Window\n\n\n###### 130\n\n\n-----\n\n###### Subclassing\n\n\n###### 131\n\n\n###### ¡ MSDN Blog: When you subclass a window, you set the window\n procedure to a function of your choosing, and you remember the original window procedure so you can pass it to the CallWindowProc function when your subclass function wants to pass the message to the original window procedure.\n\n Window Class\n\n Window Subclass Procedure     (Log The Keystroke)\n\n Call The Original Window Procedure\n\n\n###### Window Class\n\n\n-----\n\n###### Subclassing\n\n ¡ SetWindowSubclass API is pretty good for that.\n\n\n###### 132\n\n\n###### ¡ CallWndProc could be used for retrieving keys from subclassed\n windows.\n\n\n-----\n\n###### Classes vs. Windows\n\n\n###### 133\n\n\n## Window\n\n\n###### Window\n Class\n\n\n## Window\n 3\n\n\n## Window\n 1\n\n\n## 2\n\n\n-----\n\n###### Message Loops\n\n\n###### 134\n\n\n###### ¡ Each UI Thread has one message loop for processing window\n messages. \n\n ¡ http://msdn.microsoft.com/en-us/library/windows/desktop/\n ms644928(v=vs.85).aspx\n\n\n-----\n\n### #23 Hacking GetMessage / PeekMessage\n\n\n###### 135\n\n\n-----\n\n###### GetMessage / PeekMessage\n\n\n###### 136\n\n\n###### ¡ Used for getting a message from the thread’s message queue.\n\n\n###### BOOL WINAPI GetMessage(  _Out_   LPMSG lpMsg,  _In_opt_ HWND hWnd,  _In_   UINT wMsgFilterMin,  _In_   UINT wMsgFilterMax );\n BOOL WINAPI PeekMessage(  _Out_   LPMSG lpMsg,  _In_opt_ HWND hWnd,  _In_   UINT wMsgFilterMin,  _In_   UINT wMsgFilterMax,  _In_   UINT wRemoveMsg );\n\n\n###### Blocking\n\n Non-Blocking\n\n\n-----\n\n###### GetMessage / PeekMessage\n\n ¡ Sniff GetMessage API call.\n\n\n###### 137\n\n\n-----\n\n### #24 Hacking Translate and Dispatch\n\n\n###### 138\n\n\n-----\n\n###### TranslateMessage / DispatchMessage\n\n ¡ Sniff TranslateMessage / DispatchMessage API calls.\n\n\n###### 139\n\n\n-----\n\n###### TranslateMessage\n\n ¡ Translate to what?\n\n\n###### 140\n\n\n###### WM_CHAR\n\n\n-----\n\n###### DispatchMessage\n\n ¡ Calls the Window Procedure of a Window Class.\n\n ¡ Hooking it will definitely give you a lot power.\n\n\n###### 141\n\n\n-----\n\n### #25 Hacking Counterparts\n\n\n###### 142\n\n\n-----\n\n###### Kernel Mode Counterparts\n\n\n###### 143\n\n\n###### ¡ The APIs which are used for message handling and delivering\n such as DispatchMessage,GetMessage, PeekMessage.\n\n ¡ All of them have their kernel mode counterparts starting with\n NtUser*. NtUserGetMessage, NtUserPeekMessage, NtUserTranslateMessage.\n\n ¡ These could be inline hooked by kernel mode keyloggers.\n\n ¡ Best example for this is “Elite Keylogger” (newest versions)\n\n ¡ Pretty effective!\n\n\n-----\n\n###### Inspecting Kernel Mode Counterparts\n\n\n###### 144\n\n\n###### ¡ Anti-rootkits such as GMER, KernelDetective or Tuluka could\n be used for detecting these kind of modifications.\n\n\n-----\n\n### #26 SSDT Shadow Hooking\n\n\n###### 145\n\n\n-----\n\n###### What is SSDT Shadow?\n\n ¡ Just a simple table residing in win32k.sys module.\n\n ¡ Holds the addresses of system services. \n\n\n###### 146\n\n\n###### ¡ This table is the glue between user mode APIs and the kernel\n mode counterparts. \n\n ¡ Hooking this table is so easy, and also effective.\n\n\n-----\n\n###### How it is used?\n\n NtUserGetMessage\n\n SSDT Shadow\n\n sysenter\n\n W32pServiceTable\n\n User Mode Kernel Mode\n\n\n###### 147\n\n|NtUserGetMessage sysenter|SSDT Shadow NtUserGetMessage|\n|---|---|\n\n\n###### NtUserGetMessage\n\n\n-----\n\n###### How to check?\n\n ¡ We can use anti-rootkits\n\n\n###### 148\n\n\n###### ¡ Windbg can also be used for displaying SSDT Shadow Table.\n\n\n-----\n\n###### Conversion Functions \n\n ¡ MapVirtualKey / MapVirtualKeyEx\n\n ¡ ToAscii / ToAsciiEx\n\n ¡ VkKeyScan / VkKeyScanEx\n\n\n###### 149\n\n\n-----\n\n### #27 GetKeyState / GetAsyncKeyState\n\n\n###### 150\n\n\n-----\n\n###### GetKeyState / GetAsyncKeyState\n\n\n###### 151\n\n\n###### ¡ APIs for determining the state of a key at some point time.\n\n ¡ Difference is: \n\n ¡ GetKeyState is more specific and doesn’t reflect the interrupt-level\n state information,\n\n ¡ GetAsyncKeyState reflects the interrupt-level state of keys.\n\n ¡ One of the most widely used technique by keyloggers.\n\n\n-----\n\n### #28 GetKeyboardState\n\n\n###### 152\n\n\n-----\n\n###### GetKeyboardState\n\n ¡ API for determining the state of a keyboard.\n\n ¡ Fills an array of virtual keys.\n\n ¡ One of the most widely used method used by keyloggers.\n\n\n###### 153\n\n\n-----\n\n### #29 Text Output APIs\n\n\n###### 154\n\n\n-----\n\n###### Text Output APIs\n\n ¡ APIs used by applications to output text. \n\n ¡ Examples: \n\n ¡ TextOut\n ¡ ExtTextOut \n\n ¡ DrawText / DrawTextEx\n\n\n###### 155\n\n\n-----\n\n### #30 GetWindowText\n\n\n###### 156\n\n\n-----\n\n###### GetWindowText\n\n ¡ Can be used within an injected thread.\n\n\n###### 157\n\n\n###### ¡ Copies the text of the specified window's title bar (if it has\n one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.\n\n\n-----\n\n### #31 WM_GETTEXT Message\n\n\n###### 158\n\n\n-----\n\n###### WM_GETTEXT Message\n\n ¡ Can be used for retrieving another applications window\n content.\n\n\n###### 159\n\n\n-----\n\n### #32 SetWindowsHookEx\n\n\n###### 160\n\n\n-----\n\n###### SetWindowHookEx\n\n ¡ Another term for saying “Keylogger” J\n\n\n###### 161\n\n\n###### ¡ Definitely the MOST WIDELY USED technique for keylogging!!!\n\n ¡ Nearly %95 of keyloggers use it J\n\n\n-----\n\n###### Why?\n\n\n###### 162\n\n\n###### ¡ It is a way for providing callbacks to developers but widely\n used by malware authors.\n\n ¡ Have pretty much variations such as “Low Level Hook”, “Get\n Message Hook” and etc.\n\n\n-----\n\n###### Hook Types\n\n ¡ WH_CALLWNDPROC : Installs a hook procedure that\n monitors messages before the system sends them to the destination window procedure.\n\n\n###### 163\n\n\n###### ¡ WH_CALLWNDPROCRET : Installs a hook procedure that\n monitors messages after they have been processed by the destination window procedure.\n\n ¡ WH_CBT : Installs a hook procedure that receives\n notifications useful to a Computer Based Training (CBT) application. \n\n ¡ WH_DEBUG : Installs a hook procedure useful for debugging\n other hook procedures.\n\n\n-----\n\n###### Hook Types\n\n\n###### 164\n\n\n###### ¡ WH_GETMESSAGE : Installs a hook procedure that monitors\n messages posted to a message queue.\n\n ¡ WH_JOURNALRECORD : Installs a hook procedure that\n records input messages posted to the system message queue.\n\n ¡ WH_KEYBOARD : Installs a hook procedure that monitors\n keystroke messages.\n\n ¡ WH_KEYBOARD_LL : Installs a hook procedure that\n monitors low-level keyboard input events.\n\n\n-----\n\n###### Low Level Hooks\n\n ¡ Starting from this slide\n\n ¡ What is a Hook Function?\n\n ¡ Only low level hooks are allowed in Raw Input Thread. \n\n ¡ Ability to block some input events using these hooks.\n\n ¡ Will be described separately.\n\n\n###### 165\n\n\n-----\n\n### #33 DirectX Keylogger\n\n\n###### 166\n\n\n-----\n\n###### DirectX\n\n ¡ Not widely used but a good way for logging keystrokes.\n\n\n###### 167\n\n\n-----\n\n###### How?\n\n ¡ Pretty easy to implement with DirectInputCreateEx API.\n\n ¡ CreateDevice API is used for keyboard device creation.\n\n\n###### 168\n\n\n-----\n\n### #34 Browser Extensions\n\n\n###### 169\n\n\n-----\n\n###### Browser Extensions\n\n ¡ Sneaky creatures! \n\n\n###### 170\n\n\n###### ¡ Not widely used but a great for bypassing security measures.\n\n\n-----\n\n###### Inspecting\n\n ¡ XPI files are just zip files.\n\n ¡ Unzip it and analyze what it does.\n\n\n###### 171\n\n\n-----\n\n###### Demos\n\n ¡ Go to Materials/Keyloggers folder:\n ¡ Analyze martin.exe\n\n ¡ Analyze AKLT_3.0.exe\n ¡ Analyze refog_personal_manager.exe”\n ¡ Analyze Elite Keylogger\n\n ¡ Analyze java keylogger\n ¡ Analyze Free Keylogger\n\n\n###### 172\n\n\n-----\n\n# Thanks\n\n\n###### 173\n\n\n-----\n\n###### 174\n\n\n# Questions?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://opensecuritytraining.info/Keylogging_files/The%20Adventures%20of%20a%20Keystroke.pdf"
    ],
    "report_names": [
        "The%20Adventures%20of%20a%20Keystroke.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716490,
    "ts_updated_at": 1743041574,
    "ts_creation_date": 1381783546,
    "ts_modification_date": 1381783546,
    "files": {
        "pdf": "https://archive.orkl.eu/e03962d19b844e0d8a5981af06762c4b25bb49f9.pdf",
        "text": "https://archive.orkl.eu/e03962d19b844e0d8a5981af06762c4b25bb49f9.txt",
        "img": "https://archive.orkl.eu/e03962d19b844e0d8a5981af06762c4b25bb49f9.jpg"
    }
}