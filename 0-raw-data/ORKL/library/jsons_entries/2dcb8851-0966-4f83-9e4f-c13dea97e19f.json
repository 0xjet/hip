{
    "id": "2dcb8851-0966-4f83-9e4f-c13dea97e19f",
    "created_at": "2023-01-12T15:04:40.460633Z",
    "updated_at": "2025-03-27T02:11:53.054237Z",
    "deleted_at": null,
    "sha1_hash": "f7d6ec1ec8ac49fcd5d39c3feb1e6575eda90e34",
    "title": "2020-06-09 - Web shell threat hunting with Azure Sentinel and Microsoft Threat Protection",
    "authors": "",
    "file_creation_date": "2022-05-28T15:51:15Z",
    "file_modification_date": "2022-05-28T15:51:15Z",
    "file_size": 803734,
    "plain_text": "# Web shell threat hunting with Azure Sentinel and Microsoft Threat Protection\n\n**techcommunity.microsoft.com/t5/azure-sentinel/web-shell-threat-hunting-with-azure-sentinel-and-microsoft/ba-**\np/1448065\n\nJune 9, 2020\n\n_Tom McElroy, Rob Mead – Microsoft Threat Intelligence Center_\n\nIn this blog we use Azure Sentinel to enrich the investigation of endpoint web shell alerts\nfrom Microsoft Defender Advanced Threat Protection (MDATP) by\ncorrelating with additional data sources, such as W3CIIS log. We then show\nhow Azure Sentinel’s Security Orchestration Automation and Response (SOAR) capabilities\ncan be used to automatically develop and share new insights from these logs back with\nMDATP, triggered by one of its own alerts.\n\nA ‘web shell’ is a persistence mechanism and backdoor often leveraged by attackers on web\nservers. Usually this involves an attacker writing a script to a web application directory and\nusing it to execute commands from a remote location. In the last 18 months the profile\nof web shell based attacks has increased, due in part to a number of vulnerabilities reported\n[in web applications such as CVE-2019-0604 or](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-0604) [CVE-2019-16759. Multiple threat actors have](https://nvd.nist.gov/vuln/detail/CVE-2019-16759)\nalso been seen to leverage web shells in recent campaigns, Microsoft has reported\non [GALLIUM and other groups earlier in the year. Web shells are an attractive remote](https://www.microsoft.com/security/blog/2019/12/12/gallium-targeting-global-telecom/)\naccess method for attackers since they often sit on internet facing infrastructure and\ntheir short content length can make writing anti-virus signatures for them difficult.\n\n\n-----\n\nThe scenario below has been created to form the basis of our investigation and enrichment.\n[An attacker will first exploit CVE-2019-0604, a patched SharePoint vulnerability, to place a](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-0604)\nweb shell file on the server. The attacker will then leverage the shell to copy itself into\nanother directory to provide a redundant backdoor.\n\nDiagram showing where MDATP alerts trigger during our investigation.\n\nWe will focus our investigation on two areas:\n\n**Web shell installation: A web shell file is placed on the server and the code it contains or**\nthe behaviours it exhibits result in an MDATP alert. In this scenario the alert will contain\ndetails of the potential shell (e.g. c:\\mywebapp\\webshell.aspx).\n\n**Web shell activity: The web server executes a series of suspicious commands that look like**\nthey might be web shell activity, and result in an MDATP alert. In this scenario the alert will\ncontain details of the suspicious processes executed.\n\n\n-----\n\nExample EDR alert for\n\nweb shell installation in the MDATP Security Center.\n\n## Connecting the data sources\n\n[MDATP alerts can be connected to Azure Sentinel using the built in connector. Once](https://docs.microsoft.com/en-us/azure/sentinel/connect-microsoft-defender-advanced-threat-protection)\nenabled, alerts are written to the SecurityAlert table.\n\nExample of an MDATP\n\nalert in Azure Sentinel.\n\nThe evidence associated with an alert in this table can be found in the ‘Entities’ field. This is\nwhere we’ll need to look to extract the details of suspicious files and processes.\n\nAdditional visibility into web servers can be enabled by configuring collection of web server\nlogs in Azure Sentinel. Although in this example we discuss collection from IIS web servers,\ndata could also be collected from other server technologies such as Apache or Tomcat to\nenable similar investigations. For more detail on configuring IIS log collection for Azure\n[Sentinel see here.](https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-sources-iis-logs)\n\n\n-----\n\nIn Azure Sentinel, the W3CIIS table contains details of requests made to the web server,\nincluding the source IP, the request page and the user agent used.\n\nAzure\n\nSentinel's W3CIIS log table.\n\n## Investigating the alerts and generating new insights\n\nBy connecting MDATP alerts and relevant data sources to Azure Sentinel, we can gain\nadditional insights and enrich our investigation. In the case of a web shell, we want to be\nable to answer questions such as how it got there and where the attack came from.\n\nActing against the web shell alone may provide a highly motivated attacker with a window of\nopportunity to start diversifying their access, but by acting against the web shell with MDATP\nin parallel to identifying the attacker’s IP and user agent in Azure Sentinel a more developed\npicture of the attacks can be formed.\n\n**Web shell installation**\n\nIn the attack scenario there are two instances where a web shell file is placed onto the\nserver; when the attacker uses Picker.aspx to deploy the initial shell and when the attacker\ncopies the file into a new directory. Both actions trigger MDATP alerts for the web shell file\nwhich contain a filename for the shell that we can further investigate. The diagram below\nhighlights where in the example scenario this activity takes place.\n\nMDATP alerts when files\n\nare written to the system.\n\nThe first step is to extract web script filenames from alerts in the Azure Sentinel\nSecurityAlerts table. The information is stored in a JSON entity, we need to parse that to\nextract its name and location. The query below will perform the extraction and display the\n\n\n-----\n\ntime the event was generated, the filename which is the name of the shell and the directory\nthat the shell is in.\n\nWeb shell file query, Part 1/2\n```\nlet timeWindow = 3d;\n//Script file extensions to match on, can be expanded for your environment\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\",\n\".cfm\", \".shtml\"]);\nSecurityAlert\n| where TimeGenerated > ago(timeWindow)\n| where ProviderName == \"MDATP\"\n//Parse and expand the alert JSON\n| extend alertData = parse_json(Entities)\n| mvexpand alertData\n| where alertData.Type == \"file\"\n//This can be expanded to include more file types\n| where alertData.Name has_any(scriptExtensions)\n| extend FileName = tostring(alertData.Name), Directory =\ntostring(alertData.Directory)\n| project TimeGenerated, FileName, Directory\n\n```\nThe alert has been parsed to provide the file name that triggered the alert, ‘fonts.aspx’, and\nthe location of the file. The web shell has been installed on a SharePoint server and written\nto the publicly accessible ‘Template\\Layouts’ directory.\n\nParsed alert showing web shell location.\n\nWe can now expand our Kusto query to join the extracted file with the W3CIISLog table and\nfind detail about web requests that were made to it. This is easy to do as we have the\nfilename and the time the alert was generated.\n\nWeb shell file query, Part 2/2\n```\n| join ( \nW3CIISLog \n| where TimeGenerated > ago(timeWindow) \n| where csUriStem has_any(scriptExtensions) \n| extend splitUriStem = split(csUriStem, \"/\") \n| extend FileName = splitUriStem[-1]\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by\nAttackerIP=cIP, AttackerUserAgent=csUserAgent, SiteName=sSiteName,\nShellLocation=csUriStem, tostring(FileName) \n) on FileName\n| project StartTime, EndTime, AttackerIP, AttackerUserAgent, SiteName, ShellLocation\n\n```\n\n-----\n\nBecause only the attacker knows the location of the web shell, we can be confident that\nrequests for it in W3CIIS log are malicious. The results of the query above will provide\nindicators for the potential attacker - The attacker IP address and user agent.\n\nPotential attacker IP and user agent identified.\n\nUsing these indicators we can investigate other actions the attacker has taken on the\nwebserver. Some of these follow-on queries have been automated in a Notebook covered\nlater in the post, but first we will explore what can be achieved if the alert doesn't provide the\nweb shell filename.\n\n### Web shell activity\n\nIn the example scenario the attacker uses the web shell to execute a command that copies\nitself to a backup location. In this case we can investigate with Azure Sentinel based upon\nthe suspicious command execution alerts from MDATP. The diagram below highlights where\nin the example scenario this activity takes place.\n\nSuspicious\n\ncommand execution stage.\n\nMultiple MDATP alerts may be received when suspicious commands are executed by an\nattacker through their web shell. In order to capture all alerts for web shell activity we will\nlook for those that implicate the IIS worker process – w3wp.exe, by searching the evidence\nin the ‘Entities’ field. For the purposes of our investigation, we can be confident that alerts\ninvolving w3wp.exe are related to web shells.\n\nCommand execution query, Part 1/4\n\n\n-----\n\n```\nlet timeRange 3d;\nlet alerts = SecurityAlert \n| where TimeGenerated > ago(timeRange)\n| extend alertData = parse_json(Entities), recordGuid = new_guid();\nlet shellAlerts = alerts\n| where ProviderName == \"MDATP\" \n| mvexpand alertData\n| where alertData.Type == \"file\" and alertData.Name == \"w3wp.exe\"\n| distinct SystemAlertId\n| join kind=inner (alerts) on SystemAlertId;\n\n```\nDue to the behavioural nature of the detection, the alerts do not provide the web shell file\nname, we need to consider another method of correlating them with the W3CIISLog table.\nHere we will use the time of command execution in the SecurityAlert table to collect linked\nweb request events from W3CIISLog table, this will give us some candidate files to\ninvestigate.\n\nBefore linking events we extend the query to extract the suspicious command, the time it\nwas executed and the host it was executed on.\n\nCommand execution query, Part 2/4\n\n\n-----\n\n```\n//Script file extensions to match on, can be expanded for your environment\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\",\n\".cfm\", \".shtml\"]);\nlet alldata = shellAlerts \n| mvexpand alertData\n| extend Type = alertData.Type;\n//Collect alerts that match our shell criteria\nlet filedata = alldata \n| extend id = tostring(alertData.$id) \n| extend ImageName = alertData.Name \n| where Type == \"file\" and ImageName != \"w3wp.exe\"\n| extend imagefileref = id;\n//Collect commandline and execution data from the alert\nlet commanddata = alldata\n| extend CommandLine = tostring(alertData.CommandLine) \n| extend creationtime = tostring(alertData.CreationTimeUtc) \n| where Type =~ \"process\" \n| where isnotempty(CommandLine) \n| extend imagefileref = tostring(alertData.ImageFile.$ref);\n//Collect information about the host where the command was executed\nlet hostdata = alldata\n| where Type =~ \"host\"\n| project HostName = tostring(alertData.HostName), DnsDomain =\ntostring(alertData.DnsDomain), SystemAlertId\n| distinct HostName, DnsDomain, SystemAlertId;\n//Now we have extracted the file and command line information from the MDATP JSON\nobject, re-combine them\nfiledata \n| join kind=inner ( \ncommanddata \n) on imagefileref\n| join kind=inner (hostdata) on SystemAlertId\n| project DisplayName, recordGuid, TimeGenerated, ImageName, CommandLine, HostName,\nDnsDomain\n\n```\nWhen attackers gain initial access, they often propagate their web shells into other\ndirectories, for redundancy and/or to bypass restrictions the web server implements on code\nexecuting from the IIS web root. If they do this via a shell command, the name of the shell\nwill appear on the command line. We can extract this value and place it in a column\n“PossibleShell”.\n\nCommand execution query, Part 3/4\n```\n| extend PossibleShell = iff(CommandLine has_any(scriptExtensions), extract(@'([a-zAZ0-9\\-\\_]+\\.[php|jsp|js|aspx|asmx|asax|cfm|shtml]+)(?:\\s|\"|$)', 1, CommandLine),\n\"n/a\" )\n\n```\nIn the output below, we can see the extracted commands and time created.\n\n\n-----\n\nWe can now expand the query to find the IP address and user agent of our attacker based\nupon the time of the suspicious command execution. By generating a time key we can join\nthe SecurityAlert and W3CIISLog tables. This join will allow us to extract access to script files\non the server during a 1 minute window of the command executing – this will provide us with\npossible web shell files and which client IP’s and user agents were accessing them at the\ntime. On busy web servers large numbers of scripts will be accessed throughout the day\nincreasing the chances of a false positive. To help mitigate this the query will only present\nscripts that have had less than 3 distinct client IP addresses visit them.\n\nCommand execution query, Part 4/4\n```\nlet lookupWindow = 1m;\nlet lookupBin = lookupWindow / 2.0;\nlet distinctIpThreshold = 3;\nlet commandKeyedData = filedata\n//Time key the command line ready for join with web log\n| join kind=inner ( \ncommanddata \n) on imagefileref\n| join kind=inner (hostdata) on SystemAlertId\n| project recordGuid, TimeGenerated, ImageName, CommandLine, TimeKey =\nbin(TimeGenerated, lookupBin), HostName, DnsDomain\n| extend Start = TimeGenerated;\n//Baseline page access by unique IP to later limit results\nlet baseline = W3CIISLog \n| where TimeGenerated > ago(timeRange)\n| project-rename SourceIP=cIP, PageAccessed=csUriStem\n| summarize dcount(SourceIP) by PageAccessed\n| where dcount_SourceIP <= distinctIpThreshold;\n// Time key join malicious command with web log to find correlated events\ncommandKeyedData\n| join kind=inner (\nW3CIISLog \n| where TimeGenerated > ago(timeRange)\n| where csUriStem has_any(scriptExtensions) \n| extend splitUriStem = split(csUriStem, \"/\") \n| extend FileName = splitUriStem[-1] | extend firstDir = splitUriStem[-2] | extend\nTimeKey = range(bin(TimeGenerated-lookupWindow, lookupBin), bin(TimeGenerated,\nlookupBin),lookupBin) \n| mv-expand TimeKey to typeof(datetime) \n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by\nSite=sSiteName, HostName=sComputerName, AttackerIP=cIP,\nAttackerUserAgent=csUserAgent, csUriStem, filename=tostring(FileName),\ntostring(firstDir), TimeKey\n) on TimeKey, HostName\n| where (StartTime - EndTime) between (0min .. lookupWindow)\n| extend attackerP = pack(AttackerIP, AttackerUserAgent) \n| summarize Site=makeset(Site), Attacker=make_bag(attackerP) by csUriStem, filename,\ntostring(ImageName), CommandLine, HostName\n| project Site, ShellLocation=csUriStem, ShellName=filename, ParentProcess=ImageName,\nCommandLine, Attacker, HostName\n| join kind=inner (baseline) on $left.ShellLocation == $right.PageAccessed\n\n```\n\n-----\n\nAs we can see in the image below the query was able to successfully link the commands that\nwere executed through a potential web shell on the server, this allows us to get the attackers\nIP address and their user agent for follow on queries.\n\nAttacker IP and user agent for follow-on queries.\n\nWe will take these new insights on the attack and use them to identify other activity on the\ncompromised web server. We could do this through additional queries, but to help speed the\nprocess up we have created a notebook that automatically enriches and reports interesting\nattacker activity.\n\n## Building out the investigation using Jupyter Notebooks\n\nJupyter notebooks are a great way to pull these investigation steps together in one place for\nanalysis. If you are new to Jupyter notebooks and would like to understand how it can help\n[with Azure Sentinel investigations Ian Hellen wrote a](https://techcommunity.microsoft.com/t5/user/viewprofilepage/user-id/313718) [series of blogs covering the topic.](https://techcommunity.microsoft.com/t5/azure-sentinel/why-use-jupyter-for-security-investigations/ba-p/475729)\n\nIn the example below we built a notebook wrapping each of these steps into a single analysis\nflow and have added some additional analytics to help understand what the attacker may\nhave been doing on your server.\n\n[The notebook uses the Kusto client built into MSTICPy to enable it to communicate directly](https://github.com/Microsoft/msticpy)\nwith your LogAnalytics server, we also use other MSTICPy dependencies to manipulate and\ninvestigate the data we recover. If you do not have MSTICPy configured in your environment\nalready then go ahead and “pip install msticpy”. More detailed instructions about installation\n[and setup can be found in the documentation.](https://readthedocs.org/projects/msticpy/)\n\nUpon loading into the notebook you will see a number of instructions that cover its use, begin\nby importing dependencies. Then configure, connect and authenticate with your LogAnalytics\ninstance.\n\nOnce configured the notebook provides two different investigations to choose from, these\nmatch the two scenarios we discussed earlier in the post. You can investigate alerts that are\nbased on a web shell file being detected or you can begin an investigation into alerts where\nsuspicious command execution from a likely web shell have been detected. Each\ninvestigation will automate the previous queries and prepare the data for further enrichment\nin the notebook.\n\nTo investigate a suspicious file alert, you will start with the cell “Begin File Investigation” to be\npresented with the option to choose which potential web shell file you would like to\ninvestigate. The cell will automatically retrieve MDATP alert entities from your server,\nautomating the manual hunting queries we executed earlier.\n\n\n-----\n\nYou can see in the image below that a web shell called fonts.aspx was dropped to the\nserver, matching the output of our manual hunting queries.\n\nTo investigate a suspicious command execution alert, you must first select the command you\nwish to investigate. Running the “Begin Command Investigation” cell will produce a list of\nsuspicious commands detected by MDATP for you to choose from, again this information will\nbe pulled directly from your server. You will need to select a GUID associated with the\ncommand you wish to investigate. As we discovered earlier in our investigation while\nrunning manual hunting queries, you can see in the image below that commands have been\nexecuted to copy a web shell file into different locations.\n\nWhile this is similar to the Kusto query we wrote earlier, this time the script will perform a\ncheck to see if the file has only been accessed by a single client IP, this is a further step to\nhelp narrow down candidate web shell files. The web shell files will often only be accessed\nby an attacker and no other users on the server, therefore the number of IP addresses\naccessing them will often be a single IP. If the attacker is rotating their infrastructure regularly\nyou can change the threshold at the top of the cell by changing the variable named\n“access_threshold”. The higher you increase this number the higher the risk of false\npositives, but on a production server this threshold can likely be raised quite high.\n\nRegardless of the type of alert you chose to investigate (file or command) we now have\ncandidate files to investigate, we can enrich them with access information to provide us with\na potential attacker IP and user agent. In the below image you can see that we have\nprocessed the candidate files and found potential attacker IP’s and user agents. If the\n“access_threshold” has been increased you may see files that have been accessed by\nlegitimate users at a similar time as the command was executed, especially if the server is\nbusy or the attack happens during core working hours.\n\n\n-----\n\nHere you can choose the attacker IP or user agent you want to investigate, or you can\nchoose to investigate both. You will also need to specify a look-back file access time window\nas the notebook will try to determine which files the attacker accessed immediately before\nthe web shell. By default it will look-back over 30 minutes of data before the suspected web\nshell execution. Once we have chosen these parameters it is time to continue executing the\nnotebook to generate a report.\n\nWe have successfully taken an MDATP alert and enriched it with information that has\nallowed us to find both the web shell location and the attacker's information.\n\nWhen dealing with a rapidly evolving incident, security teams can now act not only against\nthe web shell, but the IP and user agent selectors generated that can be used to block or\nfurther investigate the attacker.\n\nWe are in a position where we can choose to remove the attacker’s access in parallel to the\nweb shell removal. This effectively switches the focus of our investigation to the attacker and\nnot the tools they have used. When countering hands on keyboard attacks from both\nadvanced persistent threats and sophisticated cybercrime groups, understanding the\nattacker and their behavior is critical to successful eviction from the network. Removing the\nattacker's ability to communicate with their tools also removes any early warning the attacker\nmay see and will hamper their ability to persist. The notebook contains a file history analytic\nthat will allow the identification of files that may have been used to compromise the server so\nthe entry point can also be investigated.\n\nThe notebook provides two built-in analytics to help get your investigation started. As well as\nreporting the attacker IP, user agent, the location of the shell and the website impacted, the\nnotebook contains two analytics that it will generate a report on the following:\n\n\n-----\n\n**File History: This is a list of the files on the server accessed immediately before the**\nweb shell file was placed by the attacker. The option “previous file access window” can\nbe used to configure how far the script looks back through the logs. These files are\ngood leads to continue your investigation, in a scenario where a malicious web shell file\nwas detected on the server you may be able to use this analytic to identify the page\nthat was exploited immediately before the web shell is deployed by the actor.\n**Earliest Server Access: This analytic looks back across your server logs and**\ndetermines the earliest point that the attacker IP and/or user agent accessed your\nserver, this is limited by a time range and is configurable in the initial config & connect\nsection. By default, the notebook will look-back 3 days, but this can be easily\nexpanded.\n\nBelow is an example of the summary report the notebook generated about the attacker. We\ncan see that prior to their first web shell access they had made a request to “Picker.aspx”.\n[This file is strongly associated with the patched SharePoint vulnerability CVE-2019-0604.](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-0604)\n\nIn this scenario we have taken multiple alerts from MDATP and provided enrichments from\nW3CIIS Logging to identify the attackers IP and user agent, these can now be used to further\ninvestigate the attackers actions on the server. We have been able to automate components\nof that investigation in a notebook and have provided a workflow that analysts and\nresponders can use. The notebook also provides a foundation that can be built upon, with\n\n\n-----\n\nsome knowledge of Kusto and Python it s possible for security teams to tailor the notebook to\ntheir environment. We’ll explore such an expansion next and look at how we can\ncommunicate our findings back to MDATP.\n\n## Providing insights back to MDATP\n\nBy writing an analytic query in Azure Sentinel we can automate the generation of some of\nthese insights. When written as an analytic, the query below can be scheduled to run\nperiodically. It extracts web shell files from MDATP alerts over the last hour, correlates them\nwith historic data from the W3CIIS log and creates a new incident, enriched with the details\nof attacks leveraging the shell including the IP address of the attacker.\n\n\n-----\n\n```\nlet alertTimeWindow 1h;\nlet logTimeWindow = 7d;\n// Define script extensions that suit your web application environment - a sample are\nprovided below\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\",\n\".cfm\", \".shtml\"]); \nlet alertData = SecurityAlert \n| where TimeGenerated > ago(alertTimeWindow) \n| where ProviderName == \"MDATP\" \n// Parse and expand the alert JSON \n| extend alertData = parse_json(Entities) \n| mvexpand alertData;\nlet fileData = alertData\n// Extract web script files from MDATP alerts - our malicious web scripts - candidate\nweb shells\n| where alertData.Type =~ \"file\" \n| where alertData.Name has_any(scriptExtensions) \n| extend FileName = tostring(alertData.Name), Directory =\ntostring(alertData.Directory);\nlet hostData = alertData\n// Extract server details from alerts and map to alert id\n| where alertData.Type =~ \"host\"\n| project HostName = tostring(alertData.HostName), DnsDomain =\ntostring(alertData.DnsDomain), SystemAlertId\n| distinct HostName, DnsDomain, SystemAlertId;\n// Join the files on their impacted servers\nlet webshellData = fileData\n| join kind=inner (hostData) on SystemAlertId \n| project TimeGenerated, FileName, Directory, HostName, DnsDomain;\nwebshellData\n| join ( \n// Find requests that were made to this file on the impacted server in the W3CIISLog\ntable \nW3CIISLog \n| where TimeGenerated > ago(logTimeWindow) \n// Restrict to accesses to script extensions \n| where csUriStem has_any(scriptExtensions)\n| extend splitUriStem = split(csUriStem, \"/\") \n| extend FileName = splitUriStem[-1], HostName = sComputerName\n// Summarize potential attacker activity\n| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated),\nRequestUserAgents=make_set(csUserAgent), ReqestMethods=make_set(csMethod),\nRequestStatusCodes=make_set(scStatus), RequestCookies=make_set(csCookie),\nRequestReferers=make_set(csReferer), RequestQueryStrings=make_set(csUriQuery) by\nAttackerIP=cIP, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName),\nHostName \n) on FileName, HostName\n| project StartTime, EndTime, AttackerIP, RequestUserAgents, SiteName, ShellLocation,\nReqestMethods, RequestStatusCodes, RequestCookies, RequestReferers,\nRequestQueryStrings, RequestCount = count_\n// Expose the attacker ip address as a custom entity\n| extend timestamp=StartTime, IPCustomEntity = AttackerIP\n\n```\n\n-----\n\nWhen creating the analytic, as part of Azure Sentinel s Security Orchestration Automation\nand Response (SOAR) capabilities we can also specify an automated response - A playbook\nto run when incidents are generated. In the below example we have selected the Playbook\n[‘Restrict-MDATPIPAddress’](https://github.com/Azure/Azure-Sentinel/tree/master/Playbooks/Restrict-MDATPIPAddress)\n\nSelecting the Playbook\n\n‘Restrict-MDATPIPAddress'.\n\nThis playbook extracts IP Address information from the enriched incidents created by our\n[analytic, calls the MDATP indicator API and submits them as custom IoCs for](https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-atp/ti-indicator)\n‘AlertAndBlock’. Once submitted, MDATP will create new alerts where this IP address is\nobserved in the environment and block endpoints from connecting to it for 90 days.\n\nA similar analytic and automated response could also be configured for the scenario where\nwe link suspicious commands to web shells based on a time key. Playbooks can also be\ntriggered manually, if preferred through the incident investigation experience.\n\n## Enriching the Incident\n\n[Microsoft Threat Protection (MTP) orchestrates across endpoint, identity, email and](https://www.microsoft.com/en-us/security/business/threat-protection/integrated-threat-protection)\napplications to stop attack sprawl and auto-heal enterprise assets. Its built-in intelligence\nand automation combine signals across Microsoft ATP products into prioritized incidents\nenabling security professionals to determine the full scope and impact of the threat.\n\nThe installation and usage of a web shell is often only a small part of the overall attack. Web\nshells are used as beachheads to perform follow on actions such as credential theft, lateral\nmovement and data exfiltration. Each of these actions may generate signal in other Microsoft\nproducts such as Azure ATP or Microsoft Cloud App Security and MTP will create an incident\nthat covers them all. As well as web shell artifacts from MDATP this might include\ncompromised identities, or details of cloud applications such as OneDrive that were used to\nexfiltrate sensitive data from the network.\n\n\n-----\n\nBy enriching individual MDATP alerts with Azure Sentinel log sources we have shown that\nwe can build out the picture of the intrusion with details of the attacker and their\ninfrastructure. Extending this enrichment to an MTP incident allows us to take this further and\nperform compound enrichments based upon the full scope of the attack.\n\nWorking with an incident involving a web shell we can enrich endpoint alerts with the IP\naddress and user agent from web server logs as before. With the incident we might also get\ncompromised identities used in the attack from Azure ATP. We can combine these identities\nwith the IP address and user agent insights to fingerprint attacker activity inside other Azure\nSentinel logs sources – such as the SignIn logs or OfficeActivity.\n\nIn a follow up post we will describe how upcoming integration between MTP and Azure\nSentinel will allow us to enrich based upon the incident rather than individual alerts and\nexplore new scenarios that demonstrate the power of this combination.\n\n## Summary\n\nBy connecting MDATP alerts and relevant log sources to Azure Sentinel we combined\nsignals to further investigate web shell installation and activity alerts and gained additional\nhigh value insights – the attacker IP address and user agent. Using Jupyter notebooks we\nperformed an investigation based upon these insights to build out the big picture of the\nintrusion and identify the vulnerability that allowed the web shell to be installed. Using\nSentinel’s SOAR capabilities, we went further and automated the generation of these\ninsights, sharing them back with MDATP through the indicator API for further action – such\nas new alerting and blocking. A number of resources relevant to the blog were added to the\nAzure Sentinel github and can be found below:\n\n**[Kusto Query: Web shell file enrichment query](https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellFileAlertEnrich.yaml)**\n\n**[Kusto Query: Web shell command enrichment query](https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellCommandAlertEnrich.yaml)**\n\n**[Kusto Detection: Malicious alert linked we request](https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/MaliciousAlertLinkedWebRequests.yaml)**\n\n**[Jupyter Notebook: Web shell investigations using MDATP](https://github.com/Azure/Azure-Sentinel-Notebooks/blob/master/Guided%20Investigation%20-%20MDATP%20Webshell%20Alerts.ipynb)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-09 - Web shell threat hunting with Azure Sentinel and Microsoft Threat Protection.pdf"
    ],
    "report_names": [
        "2020-06-09 - Web shell threat hunting with Azure Sentinel and Microsoft Threat Protection.pdf"
    ],
    "threat_actors": [
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9faf32b7-0221-46ac-a716-c330c1f10c95",
            "created_at": "2022-10-25T16:07:23.652281Z",
            "updated_at": "2025-03-27T02:02:09.908624Z",
            "deleted_at": null,
            "main_name": "Gallium",
            "aliases": [
                "Alloy Taurus",
                "Granite Typhoon",
                "Phantom Panda"
            ],
            "source_name": "ETDA:Gallium",
            "tools": [
                "Agentemis",
                "BlackMould",
                "CHINACHOPPER",
                "China Chopper",
                "Chymine",
                "CinaRAT",
                "Cobalt Strike",
                "CobaltStrike",
                "Darkmoon",
                "Gen:Trojan.Heur.PT",
                "Gh0stCringe RAT",
                "HTran",
                "HUC Packet Transmit Tool",
                "LaZagne",
                "Mimikatz",
                "NBTscan",
                "PingPull",
                "Plink",
                "Poison Ivy",
                "PsExec",
                "PuTTY Link",
                "QuarkBandit",
                "Quasar RAT",
                "QuasarRAT",
                "Reshell",
                "SPIVY",
                "SinoChopper",
                "SoftEther VPN",
                "Sword2033",
                "WCE",
                "WinRAR",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Yggdrasil",
                "cobeacon",
                "nbtscan",
                "netcat",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7bf3ffe5-09ba-4378-8ea4-a6d748a494fd",
            "created_at": "2022-10-25T15:50:23.264584Z",
            "updated_at": "2025-03-27T02:00:55.414817Z",
            "deleted_at": null,
            "main_name": "GALLIUM",
            "aliases": [
                "GALLIUM",
                "Granite Typhoon"
            ],
            "source_name": "MITRE:GALLIUM",
            "tools": [
                "ipconfig",
                "cmd",
                "China Chopper",
                "PoisonIvy",
                "at",
                "PlugX",
                "PingPull",
                "BlackMould",
                "Mimikatz",
                "PsExec",
                "HTRAN",
                "NBTscan",
                "Windows Credential Editor"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c87ee2df-e528-4fa0-bed6-6ed29e390688",
            "created_at": "2023-01-06T13:46:39.150432Z",
            "updated_at": "2025-03-27T02:00:03.008665Z",
            "deleted_at": null,
            "main_name": "GALLIUM",
            "aliases": [
                "Red Dev 4",
                "Alloy Taurus",
                "Granite Typhoon"
            ],
            "source_name": "MISPGALAXY:GALLIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535880,
    "ts_updated_at": 1743041513,
    "ts_creation_date": 1653753075,
    "ts_modification_date": 1653753075,
    "files": {
        "pdf": "https://archive.orkl.eu/f7d6ec1ec8ac49fcd5d39c3feb1e6575eda90e34.pdf",
        "text": "https://archive.orkl.eu/f7d6ec1ec8ac49fcd5d39c3feb1e6575eda90e34.txt",
        "img": "https://archive.orkl.eu/f7d6ec1ec8ac49fcd5d39c3feb1e6575eda90e34.jpg"
    }
}