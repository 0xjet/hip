{
    "id": "3cb706aa-d3ca-43da-9cc6-abaf6693d011",
    "created_at": "2023-01-12T15:10:59.466207Z",
    "updated_at": "2025-03-27T02:09:29.665622Z",
    "deleted_at": null,
    "sha1_hash": "a465c2fa6e0c406a6585c158882a97169efd5a53",
    "title": "2021-08-16 - Statically unpacking a simple .NET dropper",
    "authors": "",
    "file_creation_date": "2022-05-28T23:14:33Z",
    "file_modification_date": "2022-05-28T23:14:33Z",
    "file_size": 1779247,
    "plain_text": "# Statically unpacking a simple .NET dropper\n\n**malcat.fr/blog/statically-unpacking-a-simple-net-dropper/**\n\n**Sample:**\n\n[15180ee9f6a8682b24a0d5cb0491bb4e09d457bfab5a24ec1fcb077dab59773b (Bazaar,](https://bazaar.abuse.ch/sample/15180ee9f6a8682b24a0d5cb0491bb4e09d457bfab5a24ec1fcb077dab59773b/) [VT)](https://www.virustotal.com/gui/file/15180ee9f6a8682b24a0d5cb0491bb4e09d457bfab5a24ec1fcb077dab59773b)\n\n**Infection chain:**\n\n.NET dropper -> .NET dropper + Reflective DLL -> Loki\n\n**Difficulty:**\n\nEasy\n\n## Introduction\n\nToday we will try to unpack a simple 2-layers .NET dropper using static analysis only. The\ngoal of most malware packer/obfuscator is not to be hard to crack: it is to circumvent AV\ndetection for a while, and eventually get replaced by a new one afterwards. And at the very\nend of the packer food chain are packers written in VB, .NET and AutoIT: they are\nparticularly cheap and easy to crack. The sample we are about to analyse is no exception\nand will make a good introduction to Malcat's decryption algorithms.\n\nA quick glance at the file metadata tells us immediately that the file is suspicious. A VB.NET\napplication from Microsoft with a 2013 copyright but freshly compiled... sure, those version\ninformations are 100% not fake.\n\n\n-----\n\nFigure 1: Fake\n\nversion information\nLet us cut the overview right there as we will directly focus on the packed payload.\n\n## Locating the payload\n\nMost .NET packers embed one or more encrypted assemblies. .NET assemblies are not\nsmall, they have to be put somewhere. They are usually put inside .NET resources\n(sometimes insides pictures), .NET static arrays or strings. For this sample, Malcat has\nalready spotted a 800KB+ hexadecimal string inside the program (HugeStringHexa), which is\nkind of unusual.\n\n\n-----\n\nFigure 2: A look at the anomalies\nThis is confirmed in the Strings view (shortcut: F6), which tells us than more than 90% of the\nfile is made of strings, and that our big hexadecimal string is by far the biggest one (the size\n412768 is given in characters, so actual size for UTF16 is twice as much, about 824KB).\nMoreover, it has exactly one code reference, which is always a good indicator for packed\ndata:\n\nFigure 3: Big hexa string\nIf we follow the string reference in the Code view (right-click on the string, and then choose\nCross-references sub-menu) we land on the code snippet presented below. By looking at the\nnames of the method and package there, we can infer that the application we are analyzing\nwas most likely a clean .NET software that has been only slightly modified to include a\ncouple of malicious methods. This is a technique commonly used by obfuscators to evade\nAV heuristics.\n\nThe content of the method also tells us that we won't have to start our VM for now. In fact,\nthe hexadecimal string seems to be decrypted using a simple XOR algorithm using the key\n```\n\"wnhILKQcVU\" :\n\n```\n\n-----\n\nFigure 4: String decryption\n\n## Decrypting the first layer\n\nMalcat comes with several decryption algorithms which we will use on the string. First, rightclick on the big hexa string and chose the `Transform... sub-menu. We will apply the`\nfollowing transformations (in order):\n\nchange text encoding from UTF-16le to UTF-8: we get an ascii hexadecimal string\nhex decode the hexadecimal string: we get the raw bytes\ndecrypt using the XOR algorithm and the key `\"wnhILKQcVU\"`\n\nAfter these three pass, we obtain ... a base64 string, so the job is still not finished. Using\nMalcat's transformations, we can easily decode the base64 string. The result is identified by\nMalcat as a ... GZIP archive. Sure, after encoding your payload in hexa and base64, now\nyou start to care about storage efficiency. But ok, Malcat can handle GZIP archives just fine.\nJust double-click the content stream inside the `files tab to finally obtain ... a new PE file!`\n\n\n-----\n\nFigure 5: Unpacking the first layer\nAt this point we can discard the rest of the application: the payload we just decrypted made\nfor more than 90% of the file and the packer authors cared enough to pack it several time.\nSo it's pretty safe to assume that we got everything there was to see there.\n\n## Decrypting the second layer\n\nThe second layer is also a .NET executable which also contains stolen VersionInformations\n(claims to be WallpaperChanger.dll). This time, there seem to be more than one packed\ncontent:\n\nwe see a high-entropy .net resource named `Tesla of about 60Kb`\none big base64 string of about 185Kb at offset `0x100131da`\ntwo small hexadecimal strings of ~100 bytes\n\nThe rest of the application seem to be a clean app, with a few added malicious methods\ninside the class\n```\nWallpaperChanger.QsJAksvOJQZGMrkQGUrJCZfDxJspOiApOTEDEDQQQBBEDh . So we will\n\n```\nsave us some time and not analyze the code, and instead focus on the packed data: the big\nresource and the big base64 string. Let us start with the resource.\n\n\n-----\n\nFigure 6: Second layer overview\nWhen adding a resource to a .NET program under VisualStudio, a standard resource getter\nname `get_<resource_name> is often created. So we will go into the symbols list (shortcut:`\n**F5), hit Ctrl+F and look for** `Tesla . There is exactly one method named`\n```\nWallpaperChanger.Properties.Resources.get_Tesla at offset 0x1000278c . The\n\n```\ngetter has only one code reference at address `0x100026dc which looks promising:`\n\nFigure 7: the method decrypting resource + strings\nWe see two different decryption methods called there:\n\nthe method `AESDecrypt used to decrypt the .NET resource` `Tesla`\nthe method `RijndaelDecrypt used to decrypt the two small base64 strings we`\nspotted earlier.\n\n\n-----\n\nThe big base64 string does not seem to be decrypted there. Since the small strings seem to\nbe of little interest, let us focus on the method `AESDecrypt first.`\n\n## Decrypting the Tesla resource\n\nIt looks like the authors of the packer were not satisfied with the security offered by XOR\nencryption and chose to step up their game:\n\nFigure 8: the method AESDecrypt\nThe code is pretty straightforward: the string `\"eرбF开ق艾A私اвдPءぎ迪\" is first encoded in`\nutf16-BE and then hashed using the SHA256 algorithm. The result will be used as KEY for\nthe AES algorithm. No IV is defined, since the encryption mode is set to ECB. At the end, the\nresource content is decrypted using AES. We could easily recover the decrypted content\nusing a debugger there, but since the code is pretty straightforward, we can also do\neverything statically inside Malcat. First, we need to compute the AES key. We can simulate\nwhat the code is doing using the following script:\n\n|Col1|import hashlib raw_bytes = \"eرбF开ق艾A私اвдPءぎ迪\".encode(\"utf-16-be\") print(hashlib.sha256(raw_bytes).hexdigest()) # -> \"ab6edf45e299a7b2968a9d7cd013c1164efc6165508d691f085b7d9462ee945b\"|\n|---|---|\n\n\n-----\n\nHit `F8 to enter the script editor, remove the example script, paste this content and you will`\nsee the result in the output window. Copy the key in the clipboard and you are ready to\ndecrypt the resource using Malcat's AES transform:\n\nFigure 9: decrypting the Tesla resource\nWhat we get is a reflexive PE injector .NET DLL rightly named `RunPE.dll . This is the kind`\nof utility assembly which is used by dropper to inject their payload into a running process.\nInteresting, but it's definitely not our payload.\n\n## Decrypting the base64 string\n\nOur next payload candidate is the big 185kb base64-encoded string located at address\n```\n0x100131da . There is again only on code location referencing this string at address\n0x1000208c . We can see that the string is decrypted using the method RijndaelDecrypt\n\n```\nthis time using the key `\"wnhILKQcVU\" . This is the same key which was used in the first`\nlayer for the XOR encryption.\n\n\n-----\n\nFigure 10: the RijndaelDecrypt method\nThis time the block cipher is used in CBC mode (the default in .NET) and the key generation\nis based on the Rfc2898 (aka PBKDF2) algorithm. If we have a look at the offical\ndocumentation, we can see that the constructor of the class `Rfc2898DeriveBytes takes`\ntwo inputs:\n\na key, which in our case would be the string `\"wnhILKQcVU\" (encoded in UTF-8 by`\ndefault, since no encoding is specified)\na salt, which looks like a 8 bytes array initialized with the value of the field\n\n```\nDD5783BCF1E9002BC00AD5B83A95ED6E4EBB4AD5\n\n```\n\nThe class `Rfc2898DeriveBytes is then used to generate a given number of bytes (32 and`\nthen 16 in this case) which are used as key and IV for the cipher. Regarding the Rijndael\nalgorithm, we can see that in the .NET core implementation, it defaults to AES256. This is\ngood news for us, this means that the only thing we have to figure out is how to generate the\nkey and IV. Again, we could debug the sample, but where is the fun in that? We will rewrite it\nin python instead.\n\nFirst thing first, we have to retrieve the salt value (an 8 bytes array) which is located in the\nfield `DD5783BCF1E9002BC00AD5B83A95ED6E4EBB4AD5 . By clicking on the field in the Code`\nview, we can see its definition in the `FieldTable structure. This field has three important`\nflags set: `HasRVA,` `Static and` `InitOnly which indicates that this is a static initialized`\nvariable. Also the `HasRVA flag tells us that the field has an entry inside the .NET`\n\n\n-----\n\nFigure 11: the field holding the salt value\nThe `FieldRVA table has only one entry for field number 0x15 (aka 21) which is our field`\n(the field `DD5783BCF1E9002BC00AD5B83A95ED6E4EBB4AD5 is at index 20 aka 0x14 in the`\n```\nFieldTable, but Field references start at 1 because 0 is reserved).\n\n```\nFigure 12: the corresponding FieldRVA entry\nThe format of the data stored depends on the field type (and whether or not a `ClassLayout`\nexists). But we are dealing with a very simple 8 bytes array here, so reading the initial value\nis very simple: it is `{ 1, 2, 3, 4, 5, 6, 7, 8 }, our salt.`\n\nNext, we need to emulate the behavior of the class `Rfc2898DeriveBytes . We will use the`\n```\nCryptodome python package which comes bundled with Malcat and its PBKDF2 algorithm.\n\n```\nGo into the script editor (shortcut: F8) and paste the following code:\n```\n  from Cryptodome.Protocol.KDF import PBKDF2\n  pwd = \"wnhILKQcVU\".encode(\"utf8\") \n  salt = bytes(range(1, 9))      # content of\n  DD5783BCF1E9002BC00AD5B83A95ED6E4EBB4AD5\n  data = PBKDF2(pwd, salt, 32 + 16)\n  print(data[:32].hex())       # the first 32 bytes are used for the key\n  # -> \"34ca280dd207ea1e1915f7ccdc5d59344c55c6863947e507e982a337bdc57742\" \n  print(data[32:].hex())       # the next 16 bytes are used for the IV\n  # -> \"be77bdd5564bbc0c4da984f89d88213d\"\n\n```\nNow that we know both the key and the IV, we can decrypt the string at offset `0x100131da`\nusing the usual steps:\n\nRight-click on the string from the code view or the strings view and chose Transform..\n\n|Col1|from Cryptodome.Protocol.KDF import PBKDF2 pwd = \"wnhILKQcVU\".encode(\"utf8\") salt = bytes(range(1, 9)) # content of DD5783BCF1E9002BC00AD5B83A95ED6E4EBB4AD5 data = PBKDF2(pwd, salt, 32 + 16) print(data[:32].hex()) # the first 32 bytes are used for the key # -> \"34ca280dd207ea1e1915f7ccdc5d59344c55c6863947e507e982a337bdc57742\" print(data[32:].hex()) # the next 16 bytes are used for the IV # -> \"be77bdd5564bbc0c4da984f89d88213d\"|\n|---|---|\n\n\n-----\n\nChange encoding from utf16 to utf8\nBase64 decode the result\nAES decrypt the result in CBC mode using the key and IV found above\nBase64 decode the result ...\nExtract the GZipped content ......\nWe get a new PE file!\n\nThe PE file looks like a native infostealer and is detected as Loki on [VirusTotal. While a lot of](https://www.virustotal.com/gui/file/85a7353b7657a5837c2c355b3ff114cb0936789777ed704a0edd1230cb8d5d8a/details)\nits content is in plain text, some strings and configurations are still encrypted. The decryption\nprocess may be the subject of another blog post.\n\nFigure 13: the final payload: Loki infostealer\n\n## Conclusion\n\nWe have seen how to navigate inside a .NET program, look for possible payload locations\nand how to use the different decryption algorithms inside Malcat to extract the stages of the\nmalware. We also introduced the python script engine of Malcat, even if we just scratched\nthe surface there (a scripting example which makes use of the bindings will be the subject of\na future blog post).\n\nStatically unpacking a sample, while more complicated than debugging, offer many\nadvantages:\n\nwe get better quality dumps\n\n\n-----\n\nwe don t care about anti-debugging and anti-sandboxing tricks\nthe scripts which were developed can be reused on other samples in the future\nit forces us to better understand the packing logic, and makes us less likely to miss\nsomething\n\nI hope you enjoyed this first tutorial, feel free to share with us your remarks or suggestions!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-16 - Statically unpacking a simple .NET dropper.pdf"
    ],
    "report_names": [
        "2021-08-16 - Statically unpacking a simple .NET dropper.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536259,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653779673,
    "ts_modification_date": 1653779673,
    "files": {
        "pdf": "https://archive.orkl.eu/a465c2fa6e0c406a6585c158882a97169efd5a53.pdf",
        "text": "https://archive.orkl.eu/a465c2fa6e0c406a6585c158882a97169efd5a53.txt",
        "img": "https://archive.orkl.eu/a465c2fa6e0c406a6585c158882a97169efd5a53.jpg"
    }
}