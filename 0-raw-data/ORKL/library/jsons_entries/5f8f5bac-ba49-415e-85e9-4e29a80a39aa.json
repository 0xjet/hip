{
    "id": "5f8f5bac-ba49-415e-85e9-4e29a80a39aa",
    "created_at": "2023-01-12T15:07:08.801081Z",
    "updated_at": "2025-03-27T02:16:59.319939Z",
    "deleted_at": null,
    "sha1_hash": "5a96860062a2345e7643bba87656e438c3827cf6",
    "title": "2018-02-04 - DorkBot- An Investigation",
    "authors": "",
    "file_creation_date": "2022-05-28T05:12:03Z",
    "file_modification_date": "2022-05-28T05:12:03Z",
    "file_size": 1396934,
    "plain_text": "# DorkBot: An Investigation\n\n**research.checkpoint.com/dorkbot-an-investigation/**\n\nFebruary 4, 2018\nResearch By: Mark Lechtik\n\n**Overview:**\n\n\nFebruary 4, 2018\n\n\nDorkBot is a known malware that dates back to 2012. It is thought to be distributed via links\non social media, instant messaging applications or infected removable media. Although it is a\nveteran among the notorious malware families, we believe that more networks have been\ninfected with Dorkbot than previously expected, with the most affected countries being Sri\nLanka, India and Russia.\n\n\n-----\n\n_General geographic distribution of the Dorkbot infections_\n\nThe malware essentially serves as a general purpose downloader and launcher of other\nbinary components, mostly modules for conducting DDoS attacks or stealing passwords. The\nanalysis in this case was based on the sample that was observed in multiple infections in the\nwild in the past month.\n\nThe DorkBot malware comes packed within a simple dropper, in which the payload is\nembedded as an RC4 encrypted blob. This blob can be found at the resource section of the\nbinary, encoded with Base64.\n\n\n-----\n\n**_Figure 1: Base64 encoded & RC4 encrypted resource_**\n\nThe RC4 ciphertext is prepended with 32 bytes of metadata containing the RC4 key for\ndecryption in bytes 8-12.\n\n**_Figure 2: Structure of the decoded resource_**\n\nThe dropper decodes the Base64 payload and decrypts the result, which consists of a PE\nloading shellcode and the raw binary of the malware. Right after decryption, control is\npassed to the shellcode which locates the raw binary, loads it and then passes execution to\nits entry point.\n\n**_Figure 3: Decryption and execution of the payload embedded within the resource_**\n\nThe malware’s dropper can be identified by a peculiar loop which invokes a message box to\nan undefined handle with the value 0xFFFFA481 and the text “Will exec“.\n\n\n-----\n\n**Payload**\n\nThe payload consists of the following actions taking place consecutively:\n\nArgument check: If a filename is passed as an argument, it will be looked up in the\ncurrent directory and executed with ShellExecuteW. However, if the argument ends\nwith “\\” it will be assumed to be a directory name. In the latter case, it will be opened in\na new window by spawning “explorer.exe” using ShellExecuteW, with the directory path\nappended to the current directory as an argument. This feature exists for the purpose\nof running other processes under the malware, and is leveraged to replace all shortcuts\nto run the malware first and then use it to spawn the actual shortcut path, thereby\nachieving persistence in the system.\nSelf-copy: The malware creates a copy of itself in %appdata%.\nAntiVM Check: Uses SetupDiGetDeviceRegistryPropertyA to obtain a string with the\ndevice name of the hard drive, and checks whether it contains one of the following as\nsubstrings: “vbox“, “qemu“, “vmware“, “virtual hd“. In case it does, the malware infers it\nruns in a VM and terminates.\n\n\n-----\n\nStart-up process termination: Enumerates all the following registry keys in order to shut\ndown all non-malware related start-up processes:\n\n**_Figure 4: Enumeration and termination of start-up process,_**\n_according to paths from registry run keys._\n\nComputer ID calculation: Each infected machine gets an ID of the format\n“<computer_name>#<calculated_md5>“, where the 2nd parameter is the MD5 hash of\na system info buffer with the following structure:\n\nAn example of such structure in run-time can be seen here:\n\n\n-----\n\n**_Figure 5: Structure of the buffer used for_**\n_calculating the hash value for the machine ID._\n\nGUID calculation: Most of the objects in the malware (events, mutexes, file-names etc.)\nare given a name based on a generated GUID, which is built the following way (based\non the system info struct explained earlier, SID of the current process owner and a key\npassed to the GUID generation function as an argument):\n\nDWORD Data1: MD5(sysinfo)[0..3] xor key\nDWORD Data2|Data3: MD5(sysinfo)[4..7] xor key\nDWORD Data4[0..3]: MD5(sysinfo)[8..11] xor CRC32(user_SID)\nDWORD Data4[4..7]: MD5(sysinfo)[12..15] xor CRC32(user_SID)\n\nAPC injection: Creates a suspended exe process, writes the contents of the malware’s\nmapped image to it, queues the main worker thread control function (described next)\nas an APC and resumes its main thread. Consequently, the aforementioned function\nstarts to run in the context of the initiated svchost.exe process.\n\n\n-----\n\nWorker thread control function: This routine contains the major bulk of the malware s\nfunctionality, and invokes its various features as threads. It is expected that this\nfunction will run under svchost.exe as a result of the injection described earlier, and in\ncase this fails will run in the context of the current process. However, the latter will not\nhappen in reality due to a bug in the code, where the handle of the initiated svchost.exe\nmain thread is closed right after the process handle is closed. This causes the process\nto crash, avoiding any further malicious activity to occur.\n\nThe flow of the actions taken by the function itself is:\n\nPE loading actions, namely applying relocations and resolving imports for the\nmalware’s mapped executable.\nCreation of a hidden scheduled task (with the use of the ITask COM class) which is set\nto start upon the current user’s logon.\nCreation of a registry runkey under\n_HKCM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run. The key’s name is a GUID_\ngenerated beforehand and the path is set to the file copied to %appdata%.\nDeletion of the original malware file in a separate thread (only if the malware runs from\na non-removable drive, and successfully injected to svchost.exe).\n\nIf the malware is executed from removable media, it will register a designated class for it\nunder HCKU\\Software\\Classes\\CLSID, with the classes name being a calculated GUID with\nthe key 0xDEADBEEF.\n\n\n-----\n\n**_Figure 6: Registration of a class for the malware_**\n\nFile modification watchdog: A thread that constantly calculates the CRC32 of the copied\nmalware binary in %appdata% and compares it with the original file’s CRC32. In case this\nchanges, the copied file is deleted and rewritten it with the contents of the original one.\n\n**_Figure 7: File modification watchdog code_**\n\nShortcut replacement thread: Iterates through all mounted drives (obtained with\nGetLogicalDriveStringsW) and enumerates all files in order to find those with “.lnk”\nextension. In case such a file is found, it’s target path is modified (using the IPersistFile\nCOM class) to execute cmd.exe with an argument consisting of:\n\nPath generated by the malware, containing the malware’s copy.\nThe enumerated file’s path, which will be invoked through the execution of the\nmalware itself.\n\nInjection of process watchdog code: The malware will enumerate all running processes and\nwill exclude 64 bit processes, the current process and ones which run an image with the\nnames “teamviewer.exe“\\”tv_w32.exe”\n\n\n-----\n\n**_Figure 8: Exclusion of TeamViewer from targeted processes for injection_**\n\nAll other processes (as well as a malware created notepad.exe process) will get injected with\nthe following piece of code:\n\n**_Figure 9: Injected process watchdog code_**\n\nwhere the pointers 0x11111111, 0x22222222, 0x33333333 and 0x44444444 will be replaced\nby the injecting function prior to writing the code, as can be seen below:\n\n\n-----\n\n**_Figure 10: Replacement of invalid pointers in the process watchdog_**\n\n_payloads to actual function pointers._\n\nThe injected code itself will wait indefinitely on an event, which will be signaled when the\noriginal malware process is terminated. In case this happens the malware is spawned again.\n\n\n-----\n\nCommunication: All C2 domains are resident within the binary as AES256-CBC encrypted\nblobs, ordered in a pointer table that can be found in offset 16 of the .data section.\n\n**_Figure 11: Encrypted CnC domain table_**\n\nThe key for decryption is “GD!brWJJBeTgTGSgEFB/quRcfCkBHWgl“\n\n\n-----\n\n**_Figure 12: Decryption routine for the CnC domains_**\n\nThe following types of communication can be observed in the malware:\n\n1. HTTP GET request to obtain a file from one of the sample’s CnCs. The CnC is\n\ncontacted through a subdomain of the format “v%d“, where the numeric value is\nobtained from a global variable set during run-time. If a file is returned from the server,\nit is being written with a random 10 character name under %appdata% and initiated\nwith CreateProcessW.\nNote: other variants of the malware may use different subdomains, e.g. “up%d“.\n\n\n-----\n\n2. A raw protocol over TCP, used to obtain new CnC addresses from which files can be\n\ndownloaded. The protocol request message is a buffer that consists of 170 bytes, and\nhas the following structure:\n\n**_Figure 13: Structure of a raw protocol request to the CnC_**\n\nThe response consists of 517 bytes and has the following structure:\n\n**_Figure 14: Response packet from the CnC_**\n\n\n-----\n\n**IOCs:**\n153a3104fe52062844fed64c7a033d8378f7977f – Dropper\n0cf0f00b7c78d68365b4c890c76941051e244e6f – Unpacked payload\n\nWe have 9 active Anti-Bot signatures for DorkBot family:\n\nWin32.Dorkbot.E\nWin32.Dorkbot.G\nWin32.Dorkbot.H\nWin32.Dorkbot.I\nWin32.Dorkbot.J\nWin32.Dorkbot.K\nWin32.Dorkbot.L\nWIN32.DorkBot.A\nWIN32.DorkBot.B\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-04 - DorkBot- An Investigation.pdf"
    ],
    "report_names": [
        "2018-02-04 - DorkBot- An Investigation.pdf"
    ],
    "threat_actors": [
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536028,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1653714723,
    "ts_modification_date": 1653714723,
    "files": {
        "pdf": "https://archive.orkl.eu/5a96860062a2345e7643bba87656e438c3827cf6.pdf",
        "text": "https://archive.orkl.eu/5a96860062a2345e7643bba87656e438c3827cf6.txt",
        "img": "https://archive.orkl.eu/5a96860062a2345e7643bba87656e438c3827cf6.jpg"
    }
}