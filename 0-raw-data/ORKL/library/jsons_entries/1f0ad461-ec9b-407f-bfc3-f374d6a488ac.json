{
    "id": "1f0ad461-ec9b-407f-bfc3-f374d6a488ac",
    "created_at": "2023-01-12T14:59:25.618618Z",
    "updated_at": "2025-03-27T02:05:44.58996Z",
    "deleted_at": null,
    "sha1_hash": "540e254690cc95d8f20d786ba04632569c9cd22a",
    "title": "2022-07-21 - Tecniche per semplificare l‚Äôanalisi del malware GuLoader",
    "authors": "",
    "file_creation_date": "2022-08-18T03:25:39Z",
    "file_modification_date": "2022-08-18T03:25:39Z",
    "file_size": 1519037,
    "plain_text": "# Tecniche per semplificare l‚Äôanalisi del malware GuLoader\n\n**[cert-agid.gov.it/news/malware/tecniche-per-semplificare-lanalisi-del-malware-guloader/](https://cert-agid.gov.it/news/malware/tecniche-per-semplificare-lanalisi-del-malware-guloader/)**\n\n21/07/2022\n\n[guloader](https://cert-agid.gov.it/tag/guloader/)\nGli analisti di CERT-AgID hanno osservato GuLoader in Italia per la prima volta verso la fine\nmese di marzo 2021. Nell‚Äôarco dello scorso anno sono state registrate solo 6 campagne che\nutilizzavano GuLoader sfruttando il tema ‚ÄúPagamenti‚Äú, ‚ÄúPreventivo‚Äù e ‚ÄúOrdine‚Äù con lo scopo\ndi veicolare il malware AgentTesla ed in un solo caso si √® avuta evidenza del rilascio di\n**Remcos.**\n\nLe campagne GuLoader in Italia sono terminate a fine settembre 2021 per poi ripresentarsi\nnel 2022, mantenendo gli stessi temi, con 4 nuove campagne: una ad aprile, un‚Äôaltra a met√†\ngiugno e le ultime due ‚Äì ad un mese esatto di distanza ‚Äì a met√† luglio.\n\nGuLoader √® un dropper che si caratterizza per l‚Äôefficacia delle sue misure anti-debug e anti[vm. Il CERT-AgID aveva gi√† discusso la natura di tali misure, anche se al tempo il packer](https://cert-agid.gov.it/wp-content/uploads/2020/06/CERT-AGID_Tecniche-di-AntiVM-AntiDBG-20200514.pdf)\nnon era stato identificato come GuLoader. Ad oggi, tali tecniche sono state affinate e ve ne\nsono state aggiunte di nuove, al punto che analizzare GuLoader √® diventato un compito\nabbastanza complesso.\n\n## Due vecchie tecniche migliorano\n\nGuLoader disponeva di un controllo anti-debug che, anzich√® cercare un comportamento\nanomalo delle API di Windows, verificava la presenza in memoria di artefatti usati dai\n**debugger (o loro plugin) per nascondersi dai malware.**\n\nEsempio di un‚Äôarea di memoria contenente codice e dati di Scylla, un plugin per nascondere\nil debugger, in un processo sotto debug.\nGuLoader non controllava direttamente la presenza di valori specifici ma utilizza l‚Äôhashing\n[DBJ2 su gli indirizzi di porzioni di memoria determinate empiricamente.](https://theartincode.stanis.me/008-djb2/)\n\n\n-----\n\n**Questa tecnica era totalmente efficace nel rilevare i debugger pi√π usati: la chiamata alla**\nfunzione che effettuava questo controllo era facilmente identificabile per via del fatto che\nprendeva un gran numero di argomenti (gli hash degli artefatti) terminati dal valore\n```\n0xffffffff . In questo caso era sufficiente rimpiazzare la chiamata con dei NOP per\n\n```\nsuperare l‚Äôostacolo.\n\nQuesta tecnica, oggi, esiste ancora ma qualcosa √® stato cambiato. Gli argomenti passati alla\nfunzione non si limitano agli hash ma contengono anche dei numeri.\n\nGli argomenti della funzione che\n\ncontrolla la presenza di debugger. Sono coppie composte da un numero ed un hash,\nterminate da uno zero.\nProbabilmente la tecnica di rilevamento √® stata aggiornata per essere pi√π resiliente ed\nadeguarsi alla continua evoluzione dei debugger.\n\n**Ancora oggi il rilevamento del debugger √® efficace e l‚Äôunica opzione per eludere questo**\ncontrollo √® quello di individuare la chiamata e di rimpiazzarla, oppure disinstallare i plugin\nnella speranza che il debugger non abbia artefatti propri rilevati da GuLoader. Disabilitare i\nplugin per√≤ comporter√† la facile individuazione del debugger tramite le usuali tecniche antidebug (es: tramite NtQueryInformationProcess) che GuLoader non disdegna. Per debuggare\nGuLoader √® quindi necessario procedere passo passo fino all‚Äôindividuazione di questa\nchiamata. Tuttavia, gli autori del dropper hanno individuato un metodo per rendere l‚Äôanalisi\npasso passo molto tediosa.\n\n## Tecniche di Anti-VM\n\nSfortunatamente per noi, GuLoader ha un ottimo controllo anti-vm che continua ad\n[ingannare anche le sandbox online. Quindi, eseguirlo in una VM insieme ad uno strumento](https://app.any.run/tasks/02138642-5020-4e81-a3cf-b5d9d4715ebf/)\nin grado di monitorare il traffico di rete non √® sufficiente per ottenere il drop URL ed il\npayload.\n\n\n-----\n\nLa tecnica che veniva usata nel campione analizzato nel bollettino allegato era stata\nbattezzata RDSTC trick e si basava su un assunto molto semplice: l‚Äôistruzione `cpuid`\ncausa un VM-exit non condizionale ed il suo risultato deve essere alterato dall‚Äôhypervisor\n(poich√® descrive le caratteristiche e le estensioni della CPU): questo comporta che in un\n**ambiente virtualizzato la sua esecuzione sia pi√π lenta che in uno fisico. Per effettuare**\nquesto genere di misurazioni √® necessario un timer molto preciso ed a bassa latenza di\naccesso, il timestamp counter (detto anche TSC e letto tramite `rdtsc ) presente nelle CPU`\nIntel e compatibili √® l‚Äôideale. La parte complessa √® tarare bene le soglie di rilevamento.\n\n**Nota tecnica**\n\nNelle CPU moderne il TSC √® un contatore slegato dalla frequenza e dallo stato\nenergetico della CPU. Tuttavia, lo stato energetico (si vedano le tecnologie di gestione\ntermica di Intel, da SpeedStep a HWP passando per Turbo Boost) della CPU influenza\npesantemente il tempo cronometrato di esecuzione delle istruzioni, per cui misurare la\ndurata delle istruzioni con il TSC non √® molto affidabile ma probabilmente sufficiente\nagli scopi.\n\nNel campione attuale questo controllo √® stato stravolto.\n\nA sinistra: il controllo sulla durata di cpuid e rdtsc tramite il timer di Windows. A destra: il\ncontrollo che rdtsc non ritorni valori fasulli.\nUn workaround per l‚ÄôRDTSC trick era quello di emulare un TSC lento.\n\nLa nuova strategia di temporizzazione utilizza il timer di Windows, accede direttamente ad\nuser space tramite KUSER_SHARED_DATA e misura l‚Äôesecuzione di `cpuid e` `rdtsc`\nripetutamente. Qualora il valore accumulato superi una certa soglia, GuLoader assume di\ntrovarsi in presenza di una VM. Viene aggiunto anche un controllo esplicito che verifica se\nrdtsc ritorna valori falsi, ad esempio che siano troppo ‚Äúlenti‚Äù.\n\nQuesti controlli sono efficaci e portano GuLoader a mostrare una finestra di avviso e\nterminare o entrare volutamente in un ciclo infinito, prevenendo l‚Äôanalisi automatica.\n\n\n-----\n\nIn aggiunta a questi controlli di temporizzazione √® sempre presente la verifica del bit 31 di\n```\nCPUID.1.ecx, che indica la presenza di un hypervisor con supporto di\n\n```\n**paravirtualizzazione. Dato che le VM non tendono a nascondersi, questo controllo risulta**\nefficace. Disabilitare la paravirtualizzazione ha i suoi costi rendendo l‚Äôesecuzione della VM\npi√π lenta ed onerosa.\n\nGuLoader cerca inoltre di determinare se √® eseguito dentro una VM anche tramite metodi pi√π\nconvenzionali. In particolare utilizza `EnumDeviceDrivers e` `EnumServicesStatusA per`\nenumerare i driver ed i servizi tipicamente installati nelle VM paravirtualizzate (es:\n_vmmouse.sys)._\n\nAnche queste misure sono piuttosto efficaci nel rilevare le VM. Maggiori dettagli sono\n[riportati in questa analisi di SonicWall.](https://securitynews.sonicwall.com/xmlpost/guloader-a-fileless-shellcode-based-malware-in-action/)\n\n## Tecnica Anti-Analisi\n\nNonostante la presenza di questi controlli, inizialmente era pi√π semplice riconoscerli e\nsaltarli. Oggi questo √® diventato pi√π complesso per via di una tecnica anti-analisi introdotta\nda qualche mese e piuttosto fastidiosa.\n\nL‚Äôexception handler che sposta l‚Äôinstruction pointer dopo ogni istruzione int3. Il numero di\nbyte di cui spostare eip in avanti √® ottenuto come xor tra 0x9d ed il byte successivo ad int3.\n\n\n-----\n\nSubito dopo aver decifrato il suo secondo stadio, lo shellcode di GuLoader installa un\nexception handler tramite `RtlAddVectoredExceptionHandler . Questo handler √® invocato`\ntramite delle istruzioni int3 sparse in tutto il codice.\n\nIstruzioni int3 sparse per il codide del\n\ndropper. Come si intuisce dalla presenza di istruzioni privilegiate, l‚Äôesecuzione non √® lineare.\nCome mostra il codice qui sopra, questo handler ha due funzioni:\n\n1. Verifica che non siano presenti breakpoint software (dopo l‚Äôistruzione `int3 ) o`\n\nhardware.\n2. Legge il valore del byte successivo all‚Äôistruzione `int3, effettua uno xor con` `0x9D e`\n\naggiunge questo valore all‚Äôinstruction pointer, di fatto spostando l‚Äôesecuzione in avanti.\n\nI controlli anti-debug di cui il punto 1) possono essere disabilitati rimpiazzando i salti\ncondizionali con dei nop. Ma il secondo punto rimane problematico: il debugger\ndecodificando le istruzioni sequenzialmente si confonde e diventa impossibile avere una\nvisione d‚Äôinsieme del codice, rendendo complesso il riconoscimento delle funzioni. Infine,\nquando l‚Äôhandler ritorna con il valore `EXCEPTION_CONTINUE_EXECUTION l‚Äôesecuzione torna`\nal codice interrotto tramite `NtContinue, la quale non da modo al debugger di interrompere`\nimmediatamente il processo, di fatto facendo saltare l‚Äôanalisi ‚Äúda int3 in int3‚Äú.\n\nPer aggirare il problema di non controllo sull‚Äôesecuzione √® necessario ricorrere a degli script\nper il proprio debugger. Ad esempio, per x64dbg √® possibile usare le seguenti istruzioni\n(quando `eip √® su` `int3 ):`\n\n```\n$ec = byte(eip + 1); xor $ec, 0x9d; eip = eip + $ec;\n\n```\n\n## Estrarre il drop url automaticamente\n\n\n-----\n\nLa nuova tecnica anti-analisi di GuLoader rende il debug molto tedioso e la presenza di\nnumerosi controlli anti-vm ed anti-debug non permettono l‚Äôesecuzione non controllata del\ndropper.\n\n### √à possibile velocizzare l‚Äôanalisi?\n\nLo shellcode di GuLoader appena avviato salta ad una procedura che decodifica il secondo\nstadio. La struttura dello shellcode √® la seguente:\n\nLa funzione che decifra il secondo stadio si trova\n\nsubito prima di esso.\nC‚Äô√® una prima parte, in blu, che non viene decodificata: essa contiene il codice di decodifica\nstesso. Tale codice √® chiamato tramite un‚Äôistruzione `call situata subito prima dell‚Äôinizio del`\nsecondo stadio. Questo fa s√¨ che dentro tale chiamata l‚Äôindirizzo di ritorno punti proprio al\n**secondo stadio.**\n\n\n-----\n\nDecodifica del secondo stadio tramite xor. La freccia verso sinistra indica l‚Äôistruzione call\nsubito prima del secondo stadio. A destra il codice di decodifica.\nNel secondo stadio, dopo una piccola pausa implementata con un ciclo che esegue `rdtsc,`\nGuLoader determina l‚Äôinizio del secondo stadio cercando la DWORD 0xE9Ea9011.\n\n\n-----\n\nGuloader determina l‚Äôinizio del secondo stadio cercando la DWORD 0xE9Ea9011 e\nsottraendovi 5 (la lunghezza di un jmp lungo).\nPossiamo ipotizzare che la chiave di decodifica vari da campione a campione: uno\nstrumento automatico dovrebbe essere in grado di estrarla o calcolarla. Estrarla √® complesso\nperch√® √® generata tramite istruzioni aritmetiche e richiederebbe l‚Äôesecuzione concolica\n(simbolica + concreta) dello shellcode. Analogo discorso per l‚Äôinizio del secondo stadio.\n\nUn‚Äôalternativa √® quella di sfruttare le debolezze della cifratura con xor e chiave piccola.\n\nIl secondo stadio probabilmente conterr√† delle sequenze di byte nulli: queste sequenze\nrilevano la chiave ma il tutto sta nel capire dove sono. Piuttosto che utilizzare offset fissi, un\napproccio ragionevole √® quello di considerare lo shellcode come una sequenza di DWORD\n(interi senza segno a 32 bit) ed ordinarli dal pi√π frequente a quello meno frequente.\n\n\n-----\n\nIpotizziamo che tra i primi valori sia presente anche la rotazione della chiave. Parliamo di\nrotazione della chiave perch√® lo xor pu√≤ non iniziare ad indirizzi multipli di 4 bytes, ovvero:\nnon √® allineato a DWORD e in questa campione non lo fa.\n\nPossiamo verificare velocemente questa ipotesi con un po‚Äô di codice Python. La chiave\nusata nel sample in analisi √® 0xb49be733.\n```\ndef count_dwords(data, skew=0):\nhist = {}\nfor i in range(0 + skew,\n(len(data)-skew)//4 * 4, 4):\ndw = struct.unpack(\"<I\", data[i:i+4])[0]\nif dw\n<= 0xffffff:\ncontinue\nif dw not in hist:\nhist[dw] = 1\nelse:\nhist[dw] += 1\nreturn {x[0]:x[1] for i, x in enumerate(sorted(hist.items(), key=lambda x: x[1])) if i < 10}\n\n```\nIl risultato di `count_dwords mostra che la (rotazione) della chiave √® il primo risultato:`\n```\n0x33e7b49b 53\n\n0xff000000 39\n\n0xbae7b49a 37\n\n0xffe7b49a 35\n\n0xfbfbfbfb 26\n\n0x78787878 24\n\n0xbae7b499 24\n\n0x49494949 23\n\n0xe5e5e5e5 23\n\n0x74747474 23\n\n```\nPer ogni possibile chiave, possiamo fare lo xor con lo shellcode, includendo la parte blu,\nvisto che non sappiamo dove finisce, e verificare la presenza del valore 0xE9EA9011,\nesattamente come fa GuLoader. Questo ci permette non solo di confermare che la chiave\n**√® giusta ma anche di determinare dove inizia il secondo stadio in modo da decifrare**\nsoltanto quello.\n```\ndef count_dwords(data, skew=0):\nhist = {}\nfor i in range(0 + skew,\n(len(data)-skew)//4 * 4, 4):\ndw = struct.unpack(\"<I\", data[i:i+4])[0]\nif dw\n<= 0xffffff:\ncontinue\nif dw not in hist:\nhist[dw] = 1\nelse:\nhist[dw] += 1\nreturn {x[0]:x[1] for i, x in enumerate(sorted(hist.items(), key=lambda x: x[1])) if i < 10}\ndef xor(b1, i1, b2, i2, l, dbg=False):\nres = [0] * l\nfor i\nin range(i1, i1+l):\nif dbg and i > len(b1):\nprint(\"Wrap around1\")\nif dbg and\ni-i1 < 16:\nprint(hex(i % len(b1)), hex(b1[i % len(b1)]), hex((i2 + i-i1) %\nlen(b2)), hex(b2[(i2 + i-i1) % len(b2)]), hex(b1[i % len(b1)] ^ b2[(i2 + ii1) % len(b2)]))\nres[i-i1] = b1[i % len(b1)] ^ b2[(i2 + i-i1) % len(b2)]\nreturn bytes(res)\ndef find_stage2(data, key):\nsign = b\"\\x11\\x90\\xea\\xe9\"\n#Alternative signature: b\"\\xe9\\x4d\\x01\\x00\"\nsign_off = 5 #Alternative\noffset: 0\ndec = b\"\"\nfor i in range(0, len(data), 4):\ndec = (dec + xor(data,\ni, key, 0, 4))[-8:]\nif sign in dec:\nj = dec.index(sign)\nreturn i+j-4sign_off\ndef shift(data, val):\nreturn data[val:] + data[:val] def\ndecrypt_stage2(data):\nfor k, v in count_dwords(data).items():\nprint(f\"ü§û\n\n```\n\n-----\n\n```\nPossible (rotated) decrypt key: {hex(k)} )\nkey = struct.pack( <I, k)\noffset\n= find_stage2(data, key)\nif offset is None:\nprint(f\"üòê No stage found for\nthis key, trying next one.\")\ncontinue\nelse:\nprint(f\"Stage 2 found at offset\n{hex(offset)}\")\nkey = shift(key, offset & 0x3)\nprint(f\"Adjusted key to:\n{hex(struct.unpack('<I', key)[0])}\")\ndec_data = data[:offset] + xor(data,\noffset, key, 0, len(data)-offset)\nprint(f\"ü¶æ Stage 2 decrypted.\")\nreturn\ndec_data\n\n```\nNel campione analizzato il secondo stadio inizia a 0x20ea. Il risultato dello script Python\nconferma che la decifratura √® corretta:\n\nü§û Possible (rotated) decrypt key: 0x33e7b49b\n```\nStage 2 found at offset 0x20ea\n\nAdjusted key to: 0xb49b33e7\n\n Stage 2 decrypted.\n\n### Come possiamo usare il codice del secondo stadio per velocizzare l‚Äôanalisi?\n\n```\nIl drop url √® contenuto in una stringa codificata. Fortunatamente la prima azione di GuLoader,\ndopo aver determinato l‚Äôinizio del secondo stadio, √® decodifcare la stringa L‚Äùntdll‚Äù per cui\npossiamo subito analizzare come avviene questo processo.\n\nTenere traccia degli indirizzi √® tedioso per via del codice superfluo: le stringhe sono salvate\n_xorate con una chiave di 0x2b byte e precedute da una DWORD che indica la lunghezza,_\nanch‚Äôessa √® xorata con una costante. Gli offset dove trovare queste stringhe codificate sono\nprobabilmente fissi e generati tramite istruzioni aritmetiche per cui ottenerli √® complicato.\n\nDa sinistra a destra: La funzione che ottiene l‚Äôindirizzo della chiave tramite il proprio indirizzo\ndi ritorno, la funzione intermedia che passa i parametri alla vera procedura di decifratura, il\ncodice di decifratura.\nTuttavia, se avessimo la chiave, potremmo provare un bruteforce alla ricerca di\n**stringhe stampabili e, tra queste, quelle che iniziano per http o contengono ://.**\n\n\n-----\n\nCon un po di pazienza si trova facilmente che GuLoader ottiene l indirizzo della chiave per\ndecifrare le stringhe in modo analogo a come ottiene l‚Äôindirizzo del secondo stadio: ovvero\n**tramite una chiamata posizionata subito prima della chiave. Con un po‚Äô di debug si**\nscopre che la lunghezza di questa chiave √® 0x2b byte.\n\n### Come trovare la chiave nel secondo stadio decifrato?\n\nL‚Äôidea √® di cercare tutte le chiamate con opcode 0xe8 e offset negativo (salto all‚Äôindietro) e\nconsiderare i byte successivi come la chiave. La speranza √® che non ve ne siano molte. In\nrealt√† possiamo provare a cercare esattamente i byte 0xe8, 0xd9, 0xfe, 0xff se ipotizziamo\nche la distanza tra la chiave e la funzione di decifratura non cambi ed eventualmente tornare\nad un metodo bruteforce nel caso questo fallisca.\n\nOttenuta la chiave √® possibile fare un bruteforce su ogni offset e prendere le stringhe\nstampabili di almeno n caratteri. Si deve porre attenzione al fatto che le stringhe sono, o\npotrebbero essere, in UTF-16.\n\nNello script di seguito riportato vengono ricercate tutte le stringhe ma mostrate solo quelle\ncon http o :// ed √® possibile ottimizzarlo per cercare solo quelle di interesse:\n```\ndef get_string_key(data):\ncall_strdec = b\"\\xe8\\xd9\\xfe\\xff\\xff\" #The string\nkey are the 0x2b bytes after this call.\n#If this fails, we can try looking\nfor all E8 (relative) calls\nif call_strdec in data:\ni =\ndata.index(call_strdec)+5\nreturn data[i:i+0x2b]\ndef find_strs(data, skey,\nmlen=100):\nstrs = []\ni = 0\nwhile i < len(data):\npossible = xor(data, i,\nskey, 0, mlen)\ns = b\"\";\nfor j in range(len(possible)):\nif (possible[j] >=\n0x20 and possible[j] <= 0x7f) or possible[j] in [0xa, 0xd, 0x00, 0x07]:\ns +=\nbytes([possible[j]])\nelse:\nbreak\ns2 = s.replace(b\"\\x00\", b\"\")\nif len(s2) >=\n5:\nstrs.append(s2)\ni += len(s)\ni += 1\nreturn strs\ndef interesting_str(strs):\nres = False\nfor s in strs:\nif b\"http\" in s or b\"://\" in s:\nprint(s)\nres =\nTrue\nreturn res\n\n### Lo script completo\n\n```\n**Lo script seguente √® un PoC su come estrarre il drop url da un campione GuLoader.**\nPotrebbe essere necessario sistemare `get_string_key con una nuova firma o`\nun‚Äôeuristica. La nuova firma √® ottenibile con una breve analisi: √® possibile anche posizionare\nun breakpoint in `ZwAllocateVirtualMemory e poi seguire le chiamate per arrivare`\ndirettamente alla funzione che decifra le stringhe (come mostrata nelle figure precedenti).\n\nLo script si esegue passandogli lo shellcode di GuLoader: questo va estratto manualmente\ndal vettore di infezione. Il campione in analisi utilizzava uno script NSIS per questo:\n\n\n-----\n\n```\nimport struct\nfrom binascii import hexlify\nimport sys\ndef\nread_shellcode(filename):\nwith open(filename, \"rb\") as f:\ndata = f.read()\nreturn data\ndef count_dwords(data, skew=0):\nhist = {}\nfor i in range(0 +\nskew, (len(data)-skew)//4 * 4, 4):\ndw = struct.unpack(\"<I\", data[i:i+4])[0]\nif dw <= 0xffffff:\ncontinue\nif dw not in hist:\nhist[dw] = 1\nelse:\nhist[dw]\n+= 1\nreturn {x[0]:x[1] for i, x in enumerate(sorted(hist.items(), key=lambda\nx: -x[1])) if i < 10}\ndef xor(b1, i1, b2, i2, l, dbg=False):\nres = [0] * l\nfor i in range(i1, i1+l):\nif dbg and i > len(b1):\nprint(\"Wrap around1\")\nif\ndbg and i-i1 < 16:\nprint(hex(i % len(b1)), hex(b1[i % len(b1)]), hex((i2 +\ni-i1) % len(b2)), hex(b2[(i2 + i-i1) % len(b2)]), hex(b1[i % len(b1)] ^\nb2[(i2 + i-i1) % len(b2)]))\nres[i-i1] = b1[i % len(b1)] ^ b2[(i2 + i-i1) %\nlen(b2)]\nreturn bytes(res)\ndef find_stage2(data, key):\nsign =\nb\"\\x11\\x90\\xea\\xe9\" #Alternative signature: b\"\\xe9\\x4d\\x01\\x00\"\nsign_off = 5\n#Alternative offset: 0\ndec = b\"\"\nfor i in range(0, len(data), 4):\ndec = (dec\n+ xor(data, i, key, 0, 4))[-8:]\nif sign in dec:\nj = dec.index(sign)\nreturn\ni+j-4-sign_off\ndef shift(data, val):\nreturn data[val:] + data[:val] def\ndecrypt_stage2(data):\nfor k, v in count_dwords(data).items():\nprint(f\"ü§û\nPossible (rotated) decrypt key: {hex(k)}\")\nkey = struct.pack(\"<I\", k)\noffset\n= find_stage2(data, key)\nif offset is None:\nprint(f\"üòê No stage found for\nthis key, trying next one.\")\ncontinue\nelse:\nprint(f\"Stage 2 found at offset\n{hex(offset)}\")\nkey = shift(key, offset & 0x3)\nprint(f\"Adjusted key to:\n{hex(struct.unpack('<I', key)[0])}\")\ndec_data = data[:offset] + xor(data,\noffset, key, 0, len(data)-offset)\nprint(f\"ü¶æ Stage 2 decrypted.\")\nreturn\ndec_data\ndef get_string_key(data):\ncall_strdec = b\"\\xe8\\xd9\\xfe\\xff\\xff\"\n#The string key are the 0x2b bytes after this call.\n#If this fails, we can\ntry looking for all E8 (relative) calls\nif call_strdec in data:\ni =\ndata.index(call_strdec)+5\nreturn data[i:i+0x2b]\ndef find_strs(data, skey,\nmlen=100):\nstrs = []\ni = 0\nwhile i < len(data):\npossible = xor(data, i,\nskey, 0, mlen)\ns = b\"\";\nfor j in range(len(possible)):\nif (possible[j] >=\n0x20 and possible[j] <= 0x7f) or possible[j] in [0xa, 0xd, 0x00, 0x07]:\ns +=\nbytes([possible[j]])\nelse:\nbreak\ns2 = s.replace(b\"\\x00\", b\"\")\nif len(s2) >=\n5:\nstrs.append(s2)\ni += len(s)\ni += 1\nreturn strs\ndef interesting_str(strs):\nres = False\nfor s in strs:\nif b\"http\" in s or b\"://\" in s:\nprint(s)\nres =\nTrue\nreturn res\ndef extract_info(data): dec_data = decrypt_stage2(data)\nprint(\"Looking for the string key.\")\nstr_key = get_string_key(dec_data)\nif\nstr_key is None:\nprint(\"üíî No string key found. Aborted.\")\nreturn False\nelse:\nprint(f\"ü•≥ String key found: {hexlify(str_key)}\")\nprint(\"Finding\nstrings by bruteforce...\")\nstrs = find_strs(dec_data, str_key)\nprint(\"Interesting strings found:\")\nreturn interesting_str(strs)\n#\n# MAIN\n#\nif len(sys.argv) != 2:\nprint(f\"Usage: {sys.argv[0]} SHELLCODE_FILENAME\",\nfile=sys.stderr)\nsys.exit(1)\nsys.exit(2 if not\nextract_info(read_shellcode(sys.argv[1])) else 0)\n\n```\n**Esempio**\n\n\n-----\n\n```\n$ python3 gl.py /shared/guloader_shellcode\n\n```\nü§û Possible (rotated) decrypt key: 0x33e7b49b\n```\nStage 2 found at offset 0x20ea\n\nAdjusted key to: 0xb49b33e7\n\n Stage 2 decrypted.\n\nLooking for the string key.\n\n\n```\nü•≥ String key found:\n```\nb'0fc5fc4b7eb350b07d046090e4a0b73cb0100ed1063f658e0d43f257ec17708039314398012d065c9e46\n\nFinding strings by bruteforce...\n\nInteresting strings found:\n\nb'https://91news.in/bcwq_WFnUhj158.bin'\n\n```\nOttenuto il drop url √® quindi possibile scaricare il payload. I primi 64 byte sono random e non\nusati, i restanti sono un PE xorato con una chiave.\n\nNon essendo il payload disponibile al momento di questa analisi non abbiamo potuto\nautomatizzare la sua decodifica. Si suggeriscono comunque due approcci:\n\nLa chiave √® solitamente tra i 0x200 e i 0x380 byte, i PE contengono spesso lunghe\nsequenze di byte nulli che rileverebbero la chiave. Cercando una sequenza ripetuta √®\npossibile estrarre la chiave.\nAlcuni campi di un PE sono noti, questo rileva parte della chiave.\n\n### Aggiornamento\n\nIn seguito all‚Äôanalisi di ulteriori sample √® stato notato che la variabilit√† tra questi √® troppo alta\naffinch√® un approccio basato sul riconoscimento di firme (come avviene nello script sopra)\npossa funzionare.\n\nL‚Äôalternativa √® quella di utilizzare un approccio puramente bruteforce:\n\n1. Enumerare le prime n DWORD pi√π presenti nello shellcode. La speranza √® che\n\nqualcuna di queste sia la chiave XOR per decodificare il secondo stadio (l‚Äôidea √® che il\nsecondo stadio contenga un numero elevato di zeri e quindi una volta cifrato un\nnumero elevato di DWORD che corrispondono alla chiave).\n2. Per ogni DWORD, usarla come chiave per decodificare il secondo stadio.\n\nContrariamente a prima non sono fatti controlli riguardo la validit√† del secondo stadio\nottenuto.\n3. Cercare tutte le chiamate dirette relative all‚Äôindietro, il cui offset sia compreso tra\n\n**valori negativi piccoli (di default lo script usa -500 e -100). Questo passo identifica**\nogni possibile chiamata che delimita la chiave per decifrare le stringhe. Contrariamente\na prima non sono fatte verifiche e tutti i candidati sono presi in considerazione.\n4. Usare tutte le chiavi candidate ottenute al punto 3 per decifrare le stringhe e\n\nmostrare quelle che contengono determinati caratteri (es: http).\n\n\n-----\n\nOltre a questo approccio puramente bruteforce, √® stata aggiunta la possibilit√† di continuare\nla ricerca quando viene trovata una stringa di interesse e soprattutto di salvare su file il\nsecondo stadio decodificato. Questo torner√† utile per decodificare il payload.\n```\nimport struct\nfrom binascii import hexlify\nimport sys\n#After this many\nbytes, stop decoding a (so far valid) string. NOTE: Guloader uses UTF-16,\nthe #no. of chars is halved!\nMAX_STRING_LEN = 150\n#Try this many possible\nStage2 decode keys\nMAX_STAGE2_DECODE_KEYS = 10\n#The call before the String\nkey must have an immediate between min and max (a bigger gap find more\ncandidates)\nDECODE_STRING_MIN_IMMEDIATE = -500\nDECODE_STRING_MAX_IMMEDIATE =\n-100\n#Read a binary file\ndef read_shellcode(filename):\nwith open(filename,\n\"rb\") as f:\ndata = f.read()\nreturn data\n#Count the DWORD in an array of\nbytes, not counting DWORD with the MSB equal to zero\ndef count_dwords(data,\nskew=0):\nhist = {}\nfor i in range(0 + skew, (len(data)-skew)//4 * 4, 4):\ndw\n= struct.unpack(\"<I\", data[i:i+4])[0]\nif dw <= 0xffffff:\ncontinue\nif dw not\nin hist:\nhist[dw] = 1\nelse:\nhist[dw] += 1\nreturn {x[0]:x[1] for i, x in\nenumerate(sorted(hist.items(), key=lambda x: -x[1])) if i <\nMAX_STAGE2_DECODE_KEYS}\n#XOR b1[i1, i1+l] with b2[i2:i2+l] and return the\nresult (which has length l!)\ndef xor(b1, i1, b2, i2, l):\nres = [0] * l\nfor i\nin range(i1, i1+l):\nres[i-i1] = b1[i % len(b1)] ^ b2[(i2 + i-i1) % len(b2)]\nreturn bytes(res)\n#Find all calls with negative offset, not too big nor too\nsmall\ndef get_string_keys(data):\nkeys = []\nfor i in range(0, len(data)-40x2b):\nif data[i] != 0xe8:\ncontinue\nimm = struct.unpack(\"<i\", data[i+1:i+5])\n[0]\nif imm >= DECODE_STRING_MAX_IMMEDIATE or imm <\nDECODE_STRING_MIN_IMMEDIATE:\ncontinue\nkeys.append(data[i+5:i+5+0x2b])\nreturn\nkeys\n#Decode Strings\ndef find_strs(data, skey, mlen=MAX_STRING_LEN):\nstrs =\n[]\ni = 0\nwhile i < len(data):\npossible = xor(data, i, skey, 0, mlen)\ns =\nb\"\";\nfor j in range(len(possible)):\nif (possible[j] >= 0x20 and possible[j]\n<= 0x7f) or possible[j] in [0xa, 0xd, 0x00, 0x07]:\ns += bytes([possible[j]])\nelse:\nbreak\ns2 = s.replace(b\"\\x00\", b\"\")\nif len(s2) >= 5:\nstrs.append(s2)\ni\n+= len(s)\ni += 1\nreturn strs\ndef interesting_str(strs):\nres = False\nfor s in\nstrs:\nif b\"http\" in s or b\"://\" in s:\nprint(s)\nres = True\nreturn res\ndef\nbruteforce(data):\nfor k, v in count_dwords(data).items():\nprint(f\"ü§û\nPossible (rotated) decrypt key: {hex(k)}\")\nkey = struct.pack(\"<I\", k)\nprint(f\"üëΩ Decoding the shellcode...\")\ndec_data = xor(data, 0, key, 0,\nlen(data))\nprint(f\"üîç Finding the possible string keys...\")\nkeys =\nget_string_keys(dec_data)\nprint(f\"üèãÔ∏è Found {len(keys)} keys. Brute\nforcing...\")\nfor k in keys:\nprint(f\"ü§û Trying key {hexlify(k)}\")\nstrs =\nfind_strs(dec_data, k)\nif interesting_str(strs):\nwhile True:\naction =\ninput(\"Type c to continue the search, q to quit, s FILENAME to save the\ndecoded stage and exit: \").split(\" \", 2)\ncmd = action[0].lower()\nif cmd ==\n\"q\":\nreturn True\nelif cmd == \"c\":\nbreak\nelif cmd == \"s\":\nwith\nopen(action[1].strip(), \"wb\") as f:\nf.write(dec_data)\nreturn True\nreturn\nFalse\n#\n# MAIN\n#\nif len(sys.argv) != 2:\nprint(f\"Usage: {sys.argv[0]}\nSHELLCODE_FILENAME\", file=sys.stderr)\nsys.exit(1)\nsys.exit(2 if not\nbruteforce(read_shellcode(sys.argv[1])) else 0)\n\n```\n\n-----\n\nIl payload scaricabile dal drop URL √® codificato tramite XOR con una chiave la cui lunghezza\n(e valore) cambia da sample a sample.\n\nLa chiave non √® salvata nel secondo stadio in chiaro ma √® a sua volta XORata con una\nWORD (intero di 16 bit) che guloader calcola a runtime tramite bruteforcing. L‚Äôalgoritmo che\nusa Guloader √® il seguente.\n```\n//Chiave (sconosciuta per noi)\n\nuint16_t key = { ... };\n\n//Payload scaricato\n\nuint16_t* payload = ...;\n\n//Calcolo della WORD da xorare con la chiave\n\nuint16_t index;\n\nfor (index = 0; (uint32_t)index < 0x10000; index++)\n\n  if (key[0] ^ index ^ payload[32] == 0x4d5a)\n\n   break;\n\n//Calcolo della chiave\n\nfor (int j = 0; j < sizeof(key)/sizeof(key[0]); j++)\n\n  key[j] ^= index;\n\n\n```\nGuloader pu√≤ calcolare index perch√® s√† che la prima WORD di un PE √® `0x4d5a (MZ) e`\nperch√® conosce dove √® la chiave codificata e la sua lunghezza.\n\nNoi non conosciamo dove si trova la chiave n√® la sua lunghezza ma possiamo di nuovo\nsfruttare della Crittoanalisi 101 per montare un attacco bruteforce.\n\nL‚Äôidea √® che conosciamo i primi due byte della chiave grazie alla firma MZ (chiamiamoli k0),\nk0pu√≤ comparire all‚Äôinterno del PE sia perch√® la WORD corrispondente nel PE era zero (0 ^\n_k0 = k0) sia perch√® per coincidenza l‚Äôoperazione di XOR l‚Äôha data come risultato_\n(word_nel_pe_originale ^ ki = k0).\n\nSupponiamo che troviamo solo instanze del primo tipo, la distanza in byte tra due di queste\nWORD di valore k0 √® un multiplo della chiave. E‚Äô un multiplo e non la lunghezza esatta\nperch√® non possiamo garantire che tutte le istanze di k0 compaiano nel PE codificato. Per\ncui prendendo la pi√π piccola lunghezza abbiamo buona probabilit√† di trovare la lunghezza\neffettiva della chiave.\n\nIstanze del secondo tipo (che, con un po‚Äô di forzatura, assunto una distribuzione uniforme di\nchiave e payload si verificano con probabilit√† 2^-16) possono indurre falsi positivi. Per cui si\nottiene una lista di possibili lunghezze (tutte quelle che non sono multiple di altre).\n\nAlla fine si ha un insieme di possibili lunghezze di chiavi, se si √® fortunati se ne ha una solo.\n\nSe le lunghezze ottenute sono tutte multiple della lunghezza effettiva l‚Äôattacco sotto fallisce,\nsi pu√≤ pensare in questo caso di fattorizzare le lunghezze trovare e considerare tutti i\npossibili divisori (questo √® ancora da implementare).\n\n\n-----\n\nPer trovare la chiave stessa verrebbe da provare a cercare una sequenza di byte che inizia\ncon k0 e che si ripete (almeno in parte). Ma le chiavi usate possono essere troppo lunghe\nperch√® questo succeda, ad esempio nel sample usato la chiave era di `0x606 byte, troppo`\nlunga affinch√® il PE avesse tutti questi zeri consecutivi.\n\nUn altro approccio √® utilizzare il secondo stadio decodificato e tentare un bruteforce.\n\nScorriamo ogni singola WORD s0 nel secondo stadio e la consideriamo come l‚Äôinizio della\nchiave, che ricordiamo √® XORata con la quantit√† index. Dato che conosciamo per certo k0,\npossiamo calcolare index = s0 ^ k0 visto che s0 = k0 ^ index. Se davvero s0 √® l‚Äôinizio della\nchiave codificata nel secondo stadio, calcolando si ^ ki, dove si sono le WORD successive a\n_s0 nel secondo stagio e ki quelle successive a k0 nel payload cifrato, per ogni i fino a_\nraggiungere la lunghezza stimata, la maggior parte di questi valori sar√† pari ad index.\n\nNon tutti saranno uguale ad index perch√® i ki sono in realt√† WORD che vengono dal payload\ncodificato e corrispondono alla WORD ki chiave solo se e solo se in quella posizione il PE\nconteneva una WORD nulla.\n\nTuttavia prendendo come candidati le chiavi che danno almeno m valori uguali ad index (di\ndefault m=10) si ha una buona probabilit√† di trovare dove inizia la chiave nel secondo stadio\ne il valore index.\n\nTrovati index, la chiave nel secondo stadio e la sua lunghezza, √® possibile emulare la\ndecodifica di Guloader ed ottenere il payload.\n\nLo script seguente prende da linea di comando il percorso del secondo stadio decodificato\n(generato dallo script sopra ad esempio) e del payload cifrato (cos√¨ come scaricato) e prova\nun attacco bruteforce per ottenere il payload.\n```\nimport binascii\nimport struct\nimport pefile\nimport sys\n#Xor b1[i1:i1+l]\nwith b2[i2:i2+l] and return a byte array of length l\ndef xor(b1, i1, b2, i2,\nl):\nres = [0] * l\nfor i in range(i1, i1+l):\nres[i-i1] = b1[i % len(b1)] ^\nb2[(i2 + i-i1) % len(b2)]\nreturn bytes(res)\n#Find the possible lengths of\nthe key and the possible keys (only those with a \"primitive\" length will be\neffetively used) def find_keys_and_lens(data, min_len=0x100):\n#We know the\nfirst two bytes of the PE, so we know the first two bytes of the key\nkey_start = xor(b\"MZ\", 0, data, 0, 2)\nprint(f\"Key start is\n{binascii.hexlify(key_start)}\")\n#Where was the last WORD with value\nkey_start\nlast_start = None\n#The keys found\nkeys = []\n#The lengths found (#\nof these is <= # keys as two or more keys can share a length)\nlens = []\n#Scan all the payload WORDs\nfor i in range(0, len(data), 2):\n#If not a key\nstart, skip\nif data[i:i+2] != key_start:\ncontinue\n#If this is the second key\nstart, save the key and the length if not already present\nif last_start is\nnot None :\npkey = data[last_start:i]\nif pkey not in keys:\nprint(f\"Found a\npossible key at offset {hex(i)} with (possible multiple) len\n{hex(len(pkey))}\")\nkeys.append(pkey)\nlast_start = i\n#We remove all the\nlength that are multiple of other lengths or too low\nfor k in sorted(keys,\nkey = lambda k: len(k)):\nl = len(k)\nif l < min len:\ncontinue\n#First (and\n\n```\n\n-----\n\n```\nsmallest) length\nif len(lens) == 0:\nlens.append(l)\n#No multiples? Add\nelif\nlen([ol for ol in lens if l % ol == 0]) == 0:\nlens.append(l)\nreturn keys,\nlens\n#\n# M A I N\n#\nif len(sys.argv) != 3:\nprint(f\"Usage: {sys.argv[0]}\nDECODED_STAGE2_FILENAME PAYLOAD_FILENAME\")\nsys.exit(1)\n#Read the data\nwith\nopen(sys.argv[2], \"rb\") as f:\ndata = f.read()[64:]\nwith open(sys.argv[1],\n\"rb\") as f:\nstage2 = f.read()\n#Get keys and lengths keys, lens =\nfind_keys_and_lens(data)\nprint(f\"Found {len(lens)} possible key length(s)\")\n#TODO: Show the key lengths and ask if we should add each divisor (if\ngreater than a threshold) of these length to the list (and the relative key\nprefixes to keys) before bruteforcing.\n# if the script fails to find the\npayload, try implementing this, even manually.\n#For each key length...\nfor\nkl in lens:\n#Get the possibly partially coded keys from the payload\ncandidates = [k for k in keys if len(k) == kl]\nprint(f\"Trying keys with len\n{hex(kl)} ({len(candidates)} candidate(s) found)\")\n#For each candidate\nn = 0\nfor c in candidates:\n#This WORD is known to be the valid (it's the first\nWORD of the key)\nk0 = struct.unpack(\"<H\", c[0:2])[0]\nprint(\"Looking for a\nmatch in the decoded stage2...\")\n#For each WORD in the second stage...\nfor i\nin range(0, len(stage2)-kl):\n#Progress\nif i % 10000 == 0:\nprint(f\"Still\nlooking... ({i*100//(len(stage2)-kl)}% of stage2 checked)\")\n#Calculate the\npossible index\ns0 = struct.unpack(\"<H\", stage2[i:i+2])[0]\nindex = s0 ^ k0\n#Count how many times index comes up when decodind the subsequent words\ncount_matches = 0\nfor j in range(2, kl, 2):\nsi = struct.unpack(\"<H\",\nstage2[i+j:i+j+2])[0]\nki = struct.unpack(\"<H\", c[j:j+2])[0]\nif si ^ ki ==\nindex:\ncount_matches += 1\n#If we have at least 10 matches, consider this a\npossible key\nif count_matches >= 10:\nprint(f\"A candidate matched\")\n#Find the\nkey\nkey = xor(stage2, i, struct.pack(\"<H\", index), 2, kl) #Decode the PE\npe\n= xor(data, 0, key, 0, len(data))\n#Try parsing the PE\ntry:\npefile.PE(data=pe)\nname = f\"Payload{n}.exe\"\nprint(f\"Possible key found,\nsaving payload to {name}\")\nwith open(name, \"wb\") as f:\nf.write(pe)\nexcept\nException as e:\ncontinue\n\n```\n\n-----\n\n```\n$ python3 gl3.py gu_s2.bin /Malwares/20220727/gumabelt_DNCAoUwjFj89.bin\nKey start is b'5848'\n\nFound a possible key at offset 0x5c3a with (possible multiple) len 0x3d7c\n\nFound a possible key at offset 0x10862 with (possible multiple) len 0xac28\n\nFound a possible key at offset 0x114ae with (possible multiple) len 0xc4c\n\nFound a possible key at offset 0x120fa with (possible multiple) len 0xc4c\n\nFound a possible key at offset 0x12d46 with (possible multiple) len 0xc4c\n\nFound a possible key at offset 0x1522a with (possible multiple) len 0x24e4\n\nFound a possible key at offset 0x1770e with (possible multiple) len 0x24e4\n\nFound a possible key at offset 0x20a9e with (possible multiple) len 0x9390\n\nFound a possible key at offset 0x28bbc with (possible multiple) len 0x811e\n\nFound a possible key at offset 0x2b6c6 with (possible multiple) len 0x2b0a\n\nFound a possible key at offset 0x2c312 with (possible multiple) len 0xc4c\n\nFound a possible key at offset 0x33e0a with (possible multiple) len 0x7af8\n\nFound a possible key at offset 0x34430 with (possible multiple) len 0x626\n\nFound 1 possible key lengths\n\nTrying keys with len 0x626 (1 candidate(s) found)\n\nLooking for a match in the decoded stage2...\n\nStill looking... (0% of stage2 checked)\n\nStill looking... (11% of stage2 checked)\n\nStill looking... (22% of stage2 checked)\n\nStill looking... (33% of stage2 checked)\n\nStill looking... (44% of stage2 checked)\n\nStill looking... (55% of stage2 checked)\n\nStill looking... (66% of stage2 checked)\n\nA candidate matched\n\nPossible key found, saving payload to Payload0.exe\n\nStill looking... (78% of stage2 checked)\n\nStill looking... (89% of stage2 checked)\n\n$ file Payload0.exe\nPayload0.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows\n\n### Aggiornamento\n\n```\n[E‚Äô disponibile anche la versione C degli stessi script. I parametri di ricerca sono definiti in](https://cert-agid.gov.it/wp-content/uploads/2022/08/gudecoder.zip)\nconfig.h.\n\nL‚Äôutilizzo √® il seguente :\n```\ngudecoder url FILE_STAGE2_CIFRATO\n\n...\n\ngudecoder payload FILE_STAGE2_DECIFRATO PAYLOAD_CIFRATO\n\n```\n[Taggato guloader](https://cert-agid.gov.it/tag/guloader/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-21 - Tecniche per semplificare l‚Äôanalisi del malware GuLoader.pdf"
    ],
    "report_names": [
        "2022-07-21 - Tecniche per semplificare l‚Äôanalisi del malware GuLoader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535565,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1660793139,
    "ts_modification_date": 1660793139,
    "files": {
        "pdf": "https://archive.orkl.eu/540e254690cc95d8f20d786ba04632569c9cd22a.pdf",
        "text": "https://archive.orkl.eu/540e254690cc95d8f20d786ba04632569c9cd22a.txt",
        "img": "https://archive.orkl.eu/540e254690cc95d8f20d786ba04632569c9cd22a.jpg"
    }
}