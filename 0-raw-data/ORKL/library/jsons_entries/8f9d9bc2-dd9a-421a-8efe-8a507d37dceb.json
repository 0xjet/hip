{
    "id": "8f9d9bc2-dd9a-421a-8efe-8a507d37dceb",
    "created_at": "2023-01-12T15:06:11.922054Z",
    "updated_at": "2025-03-27T02:06:05.935674Z",
    "deleted_at": null,
    "sha1_hash": "f63173e1b9f970c48559eb0e024237907d09cda0",
    "title": "2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part I- Debugging in The Scope of Native Layer",
    "authors": "",
    "file_creation_date": "2022-05-28T15:20:49Z",
    "file_modification_date": "2022-05-28T15:20:49Z",
    "file_size": 1017440,
    "plain_text": "# Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part I: Debugging in The Scope of Native Layer\n\n**blog.fortinet.com/2017/01/24/deep-analysis-of-android-rootnik-malware-using-advanced-anti-debug-and-anti-hook-**\npart-i-debugging-in-the-scope-of-native-layer\n\nJanuary 26, 2017\n\n\n-----\n\nThreat Research\n\nBy [Kai Lu | January 26, 2017](https://blog.fortinet.com/blog/search?author=Kai+Lu)\nRecently, we found a new Android rootnik malware which uses open-sourced Android root\nexploit tools and the MTK root scheme from the dashi root tool to gain root access on an\nAndroid device. The malware disguises itself as a file helper app and then uses very\nadvanced anti-debug and anti-hook techniques to prevent it from being reverse engineered.\nIt also uses a multidex scheme to load a secondary dex file. After successfully gaining root\n\n\n-----\n\nprivileges on the device, the rootnik malware can perform several malicious behaviors,\nincluding app and ad promotion, pushing porn, creating shortcuts on the home screen, silent\napp installation, pushing notification, etc. In this blog, I’ll provide a deep analysis of this\nmalware.\n\n## A Quick Look at the Malware\n\nThe malware app looks like a legitimate file helper app that manages your files and other\nresources stored on your Android phone.\n\n\n-----\n\nFigure 1. The malware app icon installed\n\n\n-----\n\nFigure 2. A view of the malware app\n\nWe decompiled the APK file, as shown in Figure 3.\n\n\n-----\n\nFigure 3. Decompile the malware app’s apk file\n\nIts package name is com.web.sdfile. First, let’s look at its AndroidManifest.xml file.\n\nFigure 4. AndroidManifest.xml file inside the malware app’s apk file\n\nWe can’t find the main activity com.sd.clip.activity.FileManagerActivity, service class, or\nbroadcast class in Figure 4. Obviously, the main logic of the file helper app is not located in\nthe classes.dex. After analysis, it was discovered that the malware app uses the multidex\nscheme to dynamically load a secondary dex file and execute it.\n\n## How Rootnik Works\n\n\n-----\n\n### I. Workflow of Rootnik\n\nThe following is the workflow of the android rootnik malware.\n\nFigure 5. An overview of the android rootnik malware’s workflow\n\n### II. Going deep into the first dex file\n\nThe following is a code snippet of the class SecAppWrapper.\n\n\n-----\n\nFigure 6. A code snippet of the class SecAppWrapper\n\nThe execution flow is shown below.\n\nStatic code block -> attachBaseContext -> onCreate\n\nThe static code block loads the dynamic link library libSecShell.so into the folder assets, and\nthe program enters into the native layer, performs several anti-debug operations, decrypts\nthe secondary dex file, and then uses a multidex scheme to load the decrypted secondary\ndex file, which is actually the main logic of the real application.\n\nThe class DexInstall is actually the class MultiDex, and it refers to\n\nhttps://android.googlesource.com/platform/frameworks/multidex/+/d79604bd38c101b54e417\n45f85ddc2e04d978af2/library/src/android/support/multidex/MultiDex.java\n\nThe program then invokes the method install of DexInstall to load the secondary dex file.\nThe invoking of the method install of DexInstall is executed in native layer.\n\nFigure 7. Installing the secondary dex file\n\n\n-----\n\nIn function attachBaseContext, the program loads the class com.sd.clip.base.MyApplication,\nwhich is the execution entry of the secondary dex. The method attach of Helper is a native\nmethod.\n\nIn function onCreate, the program executes the method onCreate of the class\ncom.sd.clip.base.MyApplication.\n\nThat’s it. The first dex file is rather simple. Next, we’ll do a deep analysis of the native layer\ncode, which is very complicated and tricky.\n\n### III. The scope of the native layer code\n\nAs described above, the native layer code uses some advanced anti-debug and anti-hook\ntechniques, and also uses several decryption algorithms to decrypt some byte arrays to get\nthe plain text string.\n\nThe following is part of the export functions in libSecShell.so. It becomes harder to analyze\ndue to obfuscated function names.\n\n\n-----\n\nFigure 8. Part of export functions in libSecShell.so\n\nAll anti-debug native code is located in function JNI_Onload.\n\nAs described in the last section, the method attach of class Helper in java scope is a native\nmethod. The program dynamically registers this method in native layer. The following is a\nsnippet of the ARM assembly code that registers native method in native layer.\n\nFigure 9. Dynamically register native method in native layer\n\nThe function RegisterNatives is used to register a native method. Its prototype is shown\nbelow.\n\n_jint RegisterNatives(JNIEnv *env,jclass clazz, const JNINativeMethod* methods,jint_\n_nMethods)_\n\nThe definition of JNINativeMethod is shown below.\n\n_typedef struct {_\n\n_const char* name;_\n\n_const char* signature;_\n\n_void* fnPtr;_\n\n_} JNINativeMethod;_\n\nThe first variable name is the method name in Java. Here, it’s the string “attach”. The\nthird variable, fnPtr, is a function pointer that points to a function in C code.\n\nWe next need to find the location of the anti-debug code and bypass it, analyze how the\nsecondary dex file is decrypted, and the dump the decrypted secondary dex file from\nmemory.\n\nLet’s look at the following code in IDA:\n\n\n-----\n\nFigure 10. Code snippet around anti-debug code\n\nBased on our deep analysis, the instruction at address 0xF832 is a jump to address\nloc_F924.\n\nAfter tracing some code, we found the anti-debug code.\n\nFigure 11. The location of the anti-debug code\n\nThe function p7E7056598F77DFCC42AE68DF7F0151CA() performs the anti-debug\noperations.\n\nThe following is its graphic execution flow, which is very complicated.\n\n\n-----\n\nFigure 12. The graphic execution flow of anti-debug code\n\nThe following are some methods of anti-debug and anti-hook used in the malware.\n\n1. Detect some popular hook frameworks, such as Xposed, substrate, adbi, ddi, dexposed.\nOnce found, hook it using these popular hook frameworks. It then kills the related process.\n\nFigure 13. Detection of Xposed hook framework\n\n\n-----\n\nFigure 14. Finding the hook feature\n\n2. It then uses an kind of multi-process ptrace to implement anti-debug, which is tricky a\nlittle. Here we don’t plan to provide a detailed analysis of the anti-debugging implementation\nmechanism, but only give some simple explanations.\n\nWe can see that there are two processes named com.web.sdfile.\n\nFigure 15. Two processes named com.web.sdfile\n\nThe following is a snippet of multi-process anti-debug code.\n\nFigure 16. A snippet of anti-debug code\n\n\n-----\n\n3. The program also uses inotify to monitor the memory and pagemap of the main process. It\ncauses the memory dumping to be incomplete. The two processes use pipe to communicate\nwith each other.\n\nIn short, these anti-debug and anti-hook methods create a big obstacle for reversing\nengineering. So bypassing these anti- methods is our first task.\n\nLet’s try to bypass them.\n\nAs described in Figure 10, the instruction at offset 0x0000F832 jumps to loc_F924, and then\nthe program executes these anti-debug codes. We can dynamically modify the values of\nsome registers or some ARM instructions to change the execution flow of the program when\ndynamically debugging. When the program executes the instruction “SUBS R1, R0, #0” at\noffset 0xF828, we modify the value of register R0 to a non-zero value, which makes the\ncondition of the instruction “BNE loc_F834” become true. This allows the program to jump to\nloc_F834.\n\nFigure 17. How to bypass the anti-debug code\n\nNext, we dynamically debug it, bypass the anti-debug, and then dump the decrypted\nsecondary dex file. The dynamic debugging is shown below.\n\nFigure 18. Modifying the value of R0 to non-zero\n\n\n-----\n\nFigure 19. Jump to local_75178834\n\nNext, jump to local_751788D8, as follows.\n\nFigure 20. Decryption function for the secondary dex\n\nThe function p34D946B85C4E13BE6E95110517F61C41 is the decryption function. The\nregister R0 points to the memory storing the encrypted dex file, and the value of R1 is the\nsize of file and is equal to 0x94A3E(608830). The encrypted dex file is secData0.jar in the\nfolder assets in the apk package. The following is the file secData0.jar.\n\n\n-----\n\nFigure 21. The file secData0.jar in the folder assets in the apk package\n\nFigure 22. The content of the decrypted secondary apk file in memory\n\nWe can now dump the memory of the decrypted file to the file decrypt.dump.\n\nThe decrypted file is a zip format file, and it contains the secondary dex file. After decryption,\nthe program decompresses the decrypted secondary apk to a dex file. The function\np3CBBD6F30D91F38FCD0A378BE7E54877 is used to decompress the file.\n\nNext, the function unk_75176334 invokes the java method install of class\ncom.secshell.shellwrapper.DexInstall to load the secondary dex.\n\n\n-----\n\nFigure 23. Decompressing the decrypted secondary apk and loading the secondary dex file\n\nFigure 24. Calling the method install via Jni\n\nHere we finish the analysis of native layer and get the decrypted the secondary apk file, then\n[will analyze the apk file in the part II of this blog.](https://blog.fortinet.com/2017/01/24/deep-analysis-of-android-rootnik-malware-using-advanced-anti-debug-and-anti-hook-part-ii-analysis-of-the-scope-of-java)\n\n## The Decryption Function That Decrypts secData0.jar in Native Layer:\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part I- Debugging in The Scope of Native Layer.pdf"
    ],
    "report_names": [
        "2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part I- Debugging in The Scope of Native Layer.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535971,
    "ts_updated_at": 1743041165,
    "ts_creation_date": 1653751249,
    "ts_modification_date": 1653751249,
    "files": {
        "pdf": "https://archive.orkl.eu/f63173e1b9f970c48559eb0e024237907d09cda0.pdf",
        "text": "https://archive.orkl.eu/f63173e1b9f970c48559eb0e024237907d09cda0.txt",
        "img": "https://archive.orkl.eu/f63173e1b9f970c48559eb0e024237907d09cda0.jpg"
    }
}