{
    "id": "4709fb4f-4116-4769-895d-cbb3e6f6a858",
    "created_at": "2023-01-12T15:08:27.507161Z",
    "updated_at": "2025-03-27T02:13:33.823957Z",
    "deleted_at": null,
    "sha1_hash": "79c112ac12d89cc4c2881a3b23c05b5eb05fbc98",
    "title": "2021-05-18 - Strong ARMing with MacOS- Adventures in Cross-Platform Emulation",
    "authors": "",
    "file_creation_date": "2022-05-28T23:11:58Z",
    "file_modification_date": "2022-05-28T23:11:58Z",
    "file_size": 1608876,
    "plain_text": "# Strong ARMing with MacOS: Adventures in Cross- Platform Emulation\n\n**[blogs.blackberry.com/en/2021/05/strong-arming-with-macos-adventures-in-cross-platform-emulation](https://blogs.blackberry.com/en/2021/05/strong-arming-with-macos-adventures-in-cross-platform-emulation)**\n\nThe BlackBerry Research & Intelligence Team\n\n### Summary:\n\n#### In a world where adversaries are becoming more sophisticated by the day, it is important that threat hunters can keep a competitive advantage and remain one step ahead of threat actors. Recent developments in Apple® hardware have made it even more difficult for security researchers to keep up, and the demand for ARM-targeted testing environments is increasing.\n\n BlackBerry recognizes the importance of supporting the cybersecurity community in the fight against cyberthreats, and is therefore following up its release of the PE Tree Tool in 2020 by sharing this methodology report to inform security researchers and pen-testers on how to successfully emulate a MacOS ARM64 kernel under QEMU.\n\n Pen-testers and researchers can use the virtualized environment of a stripped-down MacOS kernel for debugging and vulnerability discovery, and this illustrates the extent to which one can use emulation to manipulate and control the kernel to their desired ends,\n\n\n-----\n\n#### whether it be to find a critical bug or to patch an area of the kernel.\n\n More importantly, this project was a successful experiment in cross-platform emulation that has the potential for future development.\n\n### Introduction\n\n#### Demand for ARM-targeted testing environments is increasing. The first Apple silicon processors are appearing in the market in conjunction with the growing extent of ARM64 support on the most popular operating systems. This project was inspired by a series of recent developments in emulation software and Apple hardware as well as a race to be the first to coalesce them. iOS® kernel emulation on a MacOS host had already been attempted, accomplished, and published. Cross-platform virtualization like this is nothing new: ARM-based systems have been virtualizable on Intel-based host systems as early as 2009.\n\n QEMU, the versatile and dynamic emulator responsible for bringing this practice into practicality, is popular among developers and pen-testers for cross-platform emulation. Even the Android™ emulator is based on QEMU. It was only a matter of time before XNU, Apple’s own Unix-derived kernel, joined the party.\n\n### Background\n\n#### When emulating a kernel image, the first phase of the kernel boot stage is typically referred to as the 'bootstrap' phase. This is normally when the earliest kernel output appears and is the first visible output during an emulation session of the MacOS® ARM64e kernel. The MacOS 11.1 ARM64e kernel bootstrap process is shown below:\n```\nDarwin Kernel Version 20.2.0: Wed Dec 2 20:40:22 PST 2020; root:xnu7195.60.75~1/RELEASE_ARM64_T8020\npmap_startup() init/release time: 106420 microsec\npmap_startup() delayed init/release of 0 pages\nvm_page_bootstrap: 383584 free pages, 115105 wired pages, (up to 0 of which are\ndelayed free)\n\"vm_compressor_mode\" is 4\noslog_init completed, 16 chunks, 8 io pages\nstandard timeslicing quantum is 10000 us\nstandard background quantum is 2500 us\nWQ[wql_init]: init linktable with max:262144 elements (8388608 bytes)\nWQ[wqp_init]: init prepost table with max:262144 elements (8388608 bytes)\nmig_table_max_displ = 53 mach_kobj_count = 365\ndebug_log_init: Error!! gPanicBase is still not initialized\ndebug_log_init: Error!! gPanicBase is still not initialized\nkdp_core zlib memory 0x8000\nSerial requested, consistent debug disabled or debug boot arg not present,\nconfiguring debugging over serial\niBoot version:\n\n```\n\n-----\n\n#### Fifty seconds, 5086 lines, and 113 kexts later:\n```\nbash-3.2# ls\n.fseventsd   dev       mnt2      mnt5      mnt8      sbin\nSystem     etc       mnt3      mnt6      mnt9      usr\nbin       mnt1      mnt4      mnt7      private     var\nbash-3.2# ps -ef\n UID  PID PPID  C STIME  TTY      TIME CMD\n  0   1   0  0 12:02AM ??     0:10.31 /sbin/launchd\n  0   3   1  0 12:02AM ??     0:08.71 /bin/bash\n  0   5   3  0 12:05AM ??     0:03.41 ps -ef\n\n All of this is virtualized in a QEMU session, on a Linux® host, running an Intel® Core™ i5- 7500 CPU @ 3.40GHz. You can see the full output on our GitHub page:\n\n https://github.com/cylance/macos-arm64-emulation/blob/main/macos-qemu.log\n\n### Getting the Files\n\n#### In June 2020, Apple announced the first beta releases of MacOS 11 (Big Sur) along with universal binary support for both x86-64 and ARM64. Does that mean we can expect to find both the x86-64 and ARM64 kernels in this release?\n\n Yes!\n\n The OSX-KVM project provides a script to download the Big Sur installer package. From there, it was simply a matter of extracting one nested archive after the other to find the kernel image. This script does not have a good track record when it comes to reading Apple’s software update catalogs. Therefore, we’ve provided a link to the kernelcache, ramdisk, and device tree files below:\n\n https://mega.nz/file/GZwzGYKb#HscZIOg_K5JdUIvbLwwwW7_Ntc1z9c7QPOcEQRKwp8c\n\n Note that the next few steps are only necessary if these files are extracted from the installer package referenced below, instead of from the link above. Skip ahead to the Modifying QEMU section, or continue below if you are extracting the files from the installer package:\n# Download Big Sur installer and extract the HFS file system\n$ wget http://swcdn.apple.com/content/downloads/00/55/001-86606A_9SF1TL01U7/5duug9lar1gypwunjfl96dza0upa854qgg/InstallAssistant.pkg\n$ xar -xf InstallAssistant.pkg SharedSupport.dmg\n$ 7z e SharedSupport.dmg 5.hfs\n\n```\n\n-----\n\n#### An archive inside the SFR software update directory with a hash-style name contains the files we need. We must also extract the Mac® software update archive that contains the APFS file system. This file system contains many ARM64e binaries that are not present on the ramdisk, including bash and ls:\n```\n# Find and extract the SFR and Mac software update archives\n$ 7z l -ba 5.hfs | grep \".zip\"\n2020-12-08 01:49:10 .....   1982210   1982464 Shared Support/UpdateBrain.zip\n2020-12-08 01:52:41 .....  927135894  927137792 Shared\nSupport/SFR/com_apple_MobileAsset_SFRSoftwareUpdate/aabc1798a59cc185ea5a87bfd4dec012f\n2020-12-08 01:52:27 ..... 11256421743  2666487808 Shared\nSupport/com_apple_MobileAsset_MacSoftwareUpdate/6c799f422b6d995ccc7f3fb669fe3246fd9f6\n$ 7z e -so 5.hfs \"Shared\nSupport/SFR/com_apple_MobileAsset_SFRSoftwareUpdate/aabc1798a59cc185ea5a87bfd4dec012f\n > sfr.zip\n$ 7z e -so 5.hfs \"Shared\nSupport/com_apple_MobileAsset_MacSoftwareUpdate/6c799f422b6d995ccc7f3fb669fe3246fd9f6\n > mac.zip\n\n It’s important to note that the long, hash-style archive file names will vary from version to version. The ramdisk, device tree and kernel files can be easily extracted the SFR archive:\n# Extract the ramdisk, device tree, and kernel from the SFR archive\n$ 7z e sfr.zip AssetData/usr/standalone/update/ramdisk/arm64eSURamDisk.dmg\n$ 7z e sfr.zip AssetData/boot/Firmware/all_flash/DeviceTree.j273aap.im4p\n$ 7z e sfr.zip AssetData/boot/kernelcache.release.j273 \n\n The ramdisk file functions as the operating system. The device tree file identifies the devices for loading the relevant drivers. The kernel, begetter of all running processes, boots the system.\n\n### Decoding and Decompressing\n\n#### Now we’ve discovered the kernel image, ramdisk image, and device tree binary and can gather the requisite files into a single directory. Next, we move ahead to decode each of the three ASN1-encoded files with these scripts:\n\n```\n\n-----\n\n```\n$ SCRIPTS=~/source/xnu-qemu-arm64-tools/bootstrap_scripts\n$ python $SCRIPTS/asn1kerneldecode.py kernelcache.release.j273\nkernelcache.release.j273.asn1decoded\n$ python $SCRIPTS/asn1rdskdecode.py arm64eSURamDisk.dmg\narm64eSURamDisk.dmg.asn1decoded\n$ python $SCRIPTS/asn1dtredecode.py DeviceTree.j273aap.im4p\nDeviceTree.j273aap.im4p.asn1decoded\n\n#### The decoded device tree file and kernel image were LZFSE compressed, unlike the LZSS- compressed iOS kernel. LZFSE features a -decode option for such files:\n$ lzfse -decode -i kernelcache.release.j273.asn1decoded -o\nkernelcache.release.j273.out\n$ lzfse -decode -i DeviceTree.j273aap.im4p.asn1decoded -o\nDeviceTree.j273aap.im4p.out\n\n### Getting Bash and Other Binaries\n\n#### The root file system on the ramdisk was missing many common command line tools, including a shell client binary. Even the ls program was completely absent. This brings us to the mac.zip archive extracted earlier. Below are the contents of the AssetData/Restore directory in this archive:\n$ 7z l -ba mac.zip | grep \"AssetData/Restore\"\n2020-12-07 23:17:30 D....      0      0 AssetData/Restore\n2020-12-07 23:17:30 .....   2871122   2841290 \nAssetData/Restore/AppleDiagnostics.dmg\n2020-12-07 23:17:30 .....     328     328 \nAssetData/Restore/AppleDiagnostics.chunklist\n2020-12-07 23:17:30 .....     2416     2325 \nAssetData/Restore/BaseSystem.chunklist\n2020-12-07 23:16:50 .....  908228542  658466440 AssetData/Restore/022-10310098.dmg\n2020-12-07 23:17:32 .....  610378184  605691452 \nAssetData/Restore/BaseSystem.dmg\n2020-12-07 23:15:22 .....     3424     3261 AssetData/Restore/022-10310098.chunklist\n\n BaseSystem.dmg is for x86_64 installations only. 022-10310-098.dmg is for ARM64e installations only. After extracting the ARM64e installer and examining the contents:\n\n```\n\n-----\n\n```\n$ 7z e mac.zip AssetData/Restore/022-10310-098.dmg\n$ 7z l -ba 022-10310-098.dmg\n          .....     512     512 0 - MBR\n          .....     512     512 1 - Primary GPT Header\n          .....    16384    16384 2 - Primary GPT Table\n          .....  926695424  908185600 3 - Apple_APFS\n          .....    16384    16384 4 - Backup GPT Table\n          .....     512     512 5 - Backup GPT Header\n3 - Apple_APFS is the file system and contains the arm64e Mach-O binaries we need.\nWe extracted and mounted with apfs-fuse:\n$ 7z e 022-10310-098.dmg \"3 - Apple_APFS\"\n$ mkdir apfs\n$ apfs-fuse -o allow_other \"3 - Apple_APFS\" apfs\n\n#### Discovering a bash file within, we check the file type:\n$ find apfs -type f -name bash\napfs/root/bin/bash\n$ file apfs/root/bin/bash\napfs/root/bin/bash: Mach-O 64-bit arm64 executable, flags: <\nNOUNDEFS|DYLDLINK|TWOLEVEL|PIE >\n\n It turns out all of the Mach-O binaries in this directory were purely ARM64e executables, as well as those in the /sbin, /usr/bin, and /usr/sbin directories. To fit these binaries into the original ramdisk file, the ramdisk had to be resized. Hdiutil is the only tool for the job, but no port of hdiutil existed outside of MacOS. This means the ramdisk needed to be resized in a MacOS system:\n# cp arm64eSURamDisk.dmg.asn1decoded arm64eSURamDisk.dmg.out\n# hdiutil resize -size 1.5G -imagekey diskimage-class=CRawDiskImage\narm64eSURamDisk.dmg.out\n\n This was the only time throughout the entire project that access to a MacOS system was required. Fortunately, this can be done in a MacOS virtual machine (VM) that can be created with OSX-KVM. We mounted the ramdisk, cleared out its /System/Library/LaunchDaemons directory and transferred the binaries into the ramdisk file system:\n\n```\n\n-----\n\n```\n$ mkdir ramdisk\n$ sudo mount -t hfsplus -o force,rw arm64eSURamDisk.dmg.out ramdisk\n$ sudo rm -rf ramdisk/System/Library/LaunchDaemons/*\n$ sudo cp apfs/root/bin/* ramdisk/bin/\n$ sudo cp apfs/root/sbin/* ramdisk/sbin/\n$ sudo cp apfs/root/usr/bin/* ramdisk/usr/bin/\n$ sudo cp apfs/root/usr/sbin/* ramdisk/usr/sbin/\n\n#### We then created a new file at ramdisk/System/Library/LaunchDaemons/com.apple.bash.plist:\n$ sudo touch ramdisk/System/Library/LaunchDaemons/com.apple.bash.plist\n\n Afterwards we copied the following code into it:\n< ?xml version=\"1.0\" encoding=\"UTF-8\"? >\n< !DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"https://www.apple.com/DTDs/PropertyList-1.0.dtd\" >\n< plist version=\"1.0\" >\n< dict >\n    < key >Label< /key >\n    < string >com.apple.bash< /string >\n    < key >Umask< /key >\n    < integer >0< /integer >\n    < key >RunAtLoad< /key >\n    < true/ >\n    < key >ProgramArguments< /key >\n    < array >\n        < string >/bin/bash< /string >\n    < /array >\n    < key >StandardInPath< /key >\n    < string >/dev/console< /string >\n    < key >StandardOutPath< /key >\n    < string >/dev/console< /string >\n    < key >StandardErrorPath< /key >\n    < string >/dev/console< /string >\n    < key >POSIXSpawnType< /key >\n    < string >Interactive< /string >\n    < key >EnablePressuredExit< /key >\n    < false/ >\n    < key >UserName< /key >\n    < string >root< /string >\n< /dict >\n< /plis t>\n\n```\n\n-----\n\n#### Finally, we unmounted the file system and ramdisk:\n```\n$ sudo umount apfs ramdisk\n\n Then it was time to begin testing.\n\n### Modifying QEMU\n\n#### Since the kernelcache binary already contained all the necessary kexts, it was not necessary to create a kext collection. Thanks to the folks at Aleph Research for providing a modified version of QEMU that supports Apple’s XNU kernel. With access to this source, we managed to add support for MacOS on top of the iOS support already implemented.\n\n### Building QEMU\n\n#### We skimmed through the source files in xnu-qemu-arm64 and found two files that specifically targeted the iOS kernel used by the iPhone® 6s Plus: include/hw/arm/n66_iphone6plus.h and hw/arm/n66_iphone6splus.c. These files target a very specific iOS kernel: N66, build 16B92. The definitions and configurations in these files would likely be incompatible with the kernel we were using (J273, build 20C69), let alone any macOS kernel. To add additional support for the MacOS kernel, we:\n\n Copied these files; Renamed the variables, functions, and preprocessor directives to match the names of the MacOS kernel (J273), kernel version (20C69), and chipset (A21Z); and\n\n Updated the filenames in the QEMU command line:\ncp hw/arm/n66_iphone6splus.c hw/arm/j273_macos11.c\ncp include/hw/arm/n66_iphone6splus.h include/hw/arm/j273_macos11.h\nsed -i 's/N66/J273/g' hw/arm/j273_macos11.c include/hw/arm/j273_macos11.h\nsed -i 's/n66/j273/g' hw/arm/j273_macos11.c include/hw/arm/j273_macos11.h\nsed -i 's/16B92/20C69/g' hw/arm/j273_macos11.c include/hw/arm/j273_macos11.h\nsed -i 's/S8000/A12Z/g' hw/arm/j273_macos11.c include/hw/arm/j273_macos11.h\n\n As in the original xnu-qemu-arm64, we included the generated object files in hw/arm/Makefile.objs:\n\n```\n\n-----\n\n```\nsed -i \"s/obj-y += boot.o/obj-y += boot.o \\\nxnu_fb_cfg.o \\\nxnu_trampoline_hook.o \\\nxnu_pagetable.o xnu_cpacr.o \\\nxnu_dtb.o \\\nxnu_file_mmio_dev.o \\\nxnu_mem.o \\\nxnu.o \\\nn66_iphone6splus.o \\\nj273_macos11.o \\\nguest-services.o \\\nguest-socket.o \\\nguest-fds.o \\\nguest-file.o/g\" hw/arm/Makefile.objs\n\n#### After this, we began the QEMU build. Unfortunately, and unsurprisingly, the compiler produced an error:\n$ make -j6\n... (truncated output)\nscsi/qemu-pr-helper.c: In function ‘multipath_pr_out’:\nscsi/qemu-pr-helper.c:523:32: error: array subscript is outside array bounds of\n‘struct transportid *[]’ [-Werror=array-bounds]\n 523 |       paramp.trnptid_list[paramp.num_transportid++] = id;\n   |       ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n... (truncated output)\n\n But what if the linker doesn’t even need this qemu-pr-helper.c module or any other potentially unbuildable modules? Let’s run make again with the -k flag and CFLAGS=\"-Wno- error\":\n$ make -j6 -k CFLAGS=\"-Wno-error\"\n... (snip)\n$ ls ./aarch64-softmmu/qemu-system-aarch64\n./aarch64-softmmu/qemu-system-aarch64\n\n This appears to have succeeded. However, we are not out of the woods yet.\n\n### Switch to QEMU 5.1.0\n\n#### QEMU 5.1.0 supports the LDAPR instruction. QEMU 4.2.0 does not. The official ARM documentation states the following about this instruction:\n\n```\n\n-----\n\n#### This instruction is supported in architectures ARMv8.3-A and later. It is optionally supported in ARMv8.2-A with the RCpc extension.\n\n Xnu-qemu-arm64 is based on 4.2.0. QEMU 4.2.0 has very limited support of ARMv8.3 and no support for the LDAPR instruction. The immediate task ahead was to move all the xnu- related source files over to a freshly downloaded source of QEMU 5.1.0. Below is a Git diff showing the files added to the official QEMU 5.1.0 source from xnu-qemu-arm64:\n```\n$ git diff --no-index --name-only --diff-filter=A qemu-5.1.0 xnu-qemu-arm64-5.1.0\nxnu-qemu-arm64-5.1.0/hw/arm/guest-fds.c\nxnu-qemu-arm64-5.1.0/hw/arm/guest-file.c\nxnu-qemu-arm64-5.1.0/hw/arm/guest-services.c\nxnu-qemu-arm64-5.1.0/hw/arm/guest-socket.c\nxnu-qemu-arm64-5.1.0/hw/arm/j273_macos11.c\nxnu-qemu-arm64-5.1.0/hw/arm/n66_iphone6splus.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_cpacr.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_dtb.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_fb_cfg.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_file_mmio_dev.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_mem.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_pagetable.c\nxnu-qemu-arm64-5.1.0/hw/arm/xnu_trampoline_hook.c\nxnu-qemu-arm64-5.1.0/hw/display/xnu_ramfb.c\nxnu-qemu-arm64-5.1.0/include/hw/arm/guest-services/fds.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/guest-services/file.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/guest-services/general.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/guest-services/socket.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/j273_macos11.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/n66_iphone6splus.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_cpacr.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_dtb.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_fb_cfg.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_file_mmio_dev.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_mem.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_pagetable.h\nxnu-qemu-arm64-5.1.0/include/hw/arm/xnu_trampoline_hook.h\nxnu-qemu-arm64-5.1.0/include/hw/display/xnu_ramfb.h\n\n In addition to the following modified files in the official source:\n\n```\n\n-----\n\n```\n$ git diff --no-index --name-only --diff-filter=M qemu-5.1.0 xnu-qemu-arm64-5.1.0\nxnu-qemu-arm64-5.1.0/hw/arm/Makefile.objs\nxnu-qemu-arm64-5.1.0/target/arm/helper.c\n\n#### One particular function proved problematic:\nvoid allocate_ram(MemoryRegion *top, const char *name, hwaddr addr,\n         hwaddr size)\n{\n    MemoryRegion *sec = g_new(MemoryRegion, 1);\n    memory_region_init_ram(sec, NULL, name, size, &error_fatal);\n    memory_region_add_subregion(top, addr, sec);\n}\n\n Due to changes in the source from QEMU 4.2.0 to 5.1.0, memory_region_allocate_system_memory had to be changed to memory_region_init_ram. It takes the same arguments in the same order plus one extra (&error_fatal). The full Git diff file can be downloaded below:\n\n https://github.com/cylance/macos-arm64-emulation/blob/main/xnu-qemu-arm64-5.1.0.diff\n\n To apply the diff and build the modified QEMU source:\n\n Download the source for QEMU 5.1.0 to the same directory as the Git diff file Extract it Rename it to xnu-qemu-arm64-5.1.0 Apply the Git diff:\n$ wget https://download.qemu.org/qemu-5.1.0.tar.xz\n$ tar xf qemu-5.1.0.tar.xz\n$ mv qemu-5.1.0.tar.xz xnu-qemu-arm64-5.1.0\n$ git apply xnu-qemu-arm64-5.1.0.diff\n\n Configure the source and build it per the instructions provided by Aleph Research:\n$ cd xnu-qemu-arm64-5.1.0\n$ ./configure --target-list=aarch64-softmmu --disable-capstone --disable-pie -disable-slirp\n$ make -j6\n\n```\n\n-----\n\n#### No bypasses or build flags are necessary.\n\n### QEMU Dry Run\n\n#### The next thing to determine is: will it run? The run.sh script below has the updated QEMU command line, where we enabled remote kernel debugging with the -S -s option:\n```\n$ cat run.sh\n~/source/xnu-qemu-arm64-5.1.0/aarch64-softmmu/qemu-system-aarch64 \\\n-M macos11-j273-a12z,\\\nkernel-filename=kernelcache.release.j273.out,\\\ndtb-filename=Firmware/all_flash/DeviceTree.j273aap.im4p.out,\\\nramdisk-filename=arm64eSURamDisk.dmg.out,\\\nkern-cmd-args=\"kextlog=0xfff cpus=1 rd=md0 serial=2 -noprogress\",\\\nxnu-ramfb=off \\\n-cpu max \\\n-m 6G \\\n-serial mon:stdio \\\n-nographic \\\n-S -s\n$ ./run.sh\n\n Attaching the remote debugger on the same host:\n$ aarch64-linux-gnu-gdb -q -ex \"target remote:1234\"\nRemote debugging using :1234\nwarning: No executable has been specified and target does not support\ndetermining executable automatically. Try using the \"file\" command.\n0x0000000047ac4580 in ?? ()\n(gdb)\n\n 0x47ac4580 is the entry point to our MacOS 11 Big Sur ARM64e kernel image. On entry, addresses seen in QEMU will be physical addresses. Since this is an initial dry run, we let it loose:\n$ ./run.sh\n\n Or, in this case, we let it spin around endlessly on the same three instructions:\n\n```\n\n-----\n\n```\n0x479f4388   mrs   x0, s3_4_c15_c0_4 ; APCTL_EL1\n│\n0x479f438c   and   x1, x0, #0x2 \n│\n0x479f4390   cbz   x1, 0x479f4388 ; infinite loop\n\n#### Bit 1 (#0x2) is never set in the system coprocessor register s3_4_c15_c0_4, so it never breaks the loop. This is an Apple-specific hardware register. Apple registers are unrecognized by the official QEMU branch, but xnu-qemu-arm64 added several Apple registers to boot the iOS kernel, including s3_4_c15_c0_4. This register is also known as APCTL_EL1/MIGSTS.\n\n### Patching the Kernel\n\n#### That dry run barely got us on our feet. Not easily discouraged, we began skimming the QEMU source files for clues. After looking at the patching function we disabled, we could find nothing directly addressing the elusive “APCTL_EL1” register. The infinite loop above does show up in the XNU source in xnu-6153.141.1/osfmk/arm64/start.s:\n#ifdef HAS_APPLE_PAC\n#ifdef __APSTS_SUPPORTED__\n... (snip)\n#else\nmrs x0, ARM64_REG_APCTL_EL1\nand x1, x0, #(APCTL_EL1_MKEYVld)\ncbz x1, 1b  // Poll APCTL_EL1.MKEYVld\n... (snip)\n\n It is polling a flag by the name of MKEYVld.\n\n### MKEYVld\n\n#### What is the MKEYVld flag? Not many clues are in the XNU source. Perhaps a flag indicating some kind of validation status (MKEYVld = MAC key validated?). Most likely the kernel is waiting for it to be set by some other piece of hardware. We can force set this flag ourselves by adding to the following patch already provided by Aleph Research in our copied hw/arm/j273_macos11.c:\n\n```\n\n-----\n\n```\nstatic uint32_t g_set_cpacr_and_branch_inst[] = {\n  // 91400c21    add x1, x1, 3, lsl 12  # x1 = x1 + 0x3000\n  // d378dc21    lsl x1, x1, 8      # x1 = x1 * 0x100 (x1 = 0x300000)\n  // d5181041    msr cpacr_el1, x1    # cpacr_el1 = x1 (enable FP)\n  // d2800041    mov x1, #2        # MKEYVld\n  // d51cf081    mov apctl_el1, x1\n  // aa1f03e1    mov x1, xzr       # x1 = 0\n  // 14000eb5    b 0x1fc0         # branch to regular start\n  0x91400c21, 0xd378dc21, 0xd5181041,\n  0xd2800041, 0xd51cf081, 0xaa1f03e1,\n  0x14000eb5\n};\n\n#### We introduced two more instructions that set the MKEYVld flag (bit 1) in APCTL_EL1:\n  // d2800041    mov x1, #2        # MKEYVld\n  // d51cf081    mov apctl_el1, x1\n\n The presence of several fixed offsets in xnu-qemu-arm64/hw/arm/n66_iphone6splus.c shows that there were 11 places in the iOS kernel that required patching:\n#define INITIAL_BRANCH_VADDR_16B92 (0xfffffff0070a5098)\n#define BZERO_COND_BRANCH_VADDR_16B92 (0xfffffff0070996d8)\n#define SMC_INST_VADDR_16B92 (0xfffffff0070a7d3c)\n#define SLIDE_SET_INST_VADDR_16B92 (0xfffffff00748ef30)\n#define NOTIFY_KERNEL_TASK_PTR_16B92 (0xfffffff0070f4d90)\n#define CORE_TRUST_CHECK_16B92 (0xfffffff0061e136c)\n#define TFP0_TASK_FOR_PID_16B92 (0xfffffff0074a27bc)\n#define TFP0_CNVRT_PORT_TO_TASK_16B92 (0xfffffff0070d7cb8)\n#define TFP0_PORT_NAME_TO_TASK_16B92 (0xfffffff0070d82d8)\n#define TFP0_KERNEL_TASK_CMP_1_16B92 (0xfffffff0070d7b04)\n#define TFP0_KERNEL_TASK_CMP_2_16B92 (0xfffffff0070d810c)\n\n There was no way these hard-coded offsets would be compatible with the MacOS kernel image. This is when we realized we would need to tear the MacOS kernel apart in a disassembler to find the offsets.\n\n### IDA\n\n```\n\n-----\n\n#### Completing this project would have been impossible without a disassembler. IDA 7.5 was the primary candidate, chiefly because of its support for ARM64e binaries and the latest A64 instruction set. For instance, earlier versions of IDA (namely 7.0) do not recognize the pointer authentication code for instruction key B (PACIBSP) instruction, which appears at the start of nearly every function in the MacOS ARM64e kernel:\n\n Figure 1.\n\n Moreover, the kernel image used in this project contained no symbols. Functions had to be manually named, one by one, throughout the two-month testing and research period. ASCII strings offered the most reliable clues. The open-source XNU kernel was crucial in the struggle to identify the culprit of a crash or freeze. A total of 122645 functions have been defined in the IDA project so far. On initial analysis, however, IDA failed to define nearly every single function in the kernel binary. A script was needed to rectify this:\n\n\n-----\n\n```\nimport idc\nimport struct\nimport idautils\npacibsp = \"7F 23 03 D5\" # PACIBSP\nmatches = []\nea = idc.find_binary(0, 1, pacibsp)\nwhile ea != idc.BADADDR:\n  matches.append(ea)\n  ea = idc.find_binary(ea + 4, 1, pacibsp)\n# Move backwards to avoid nesting functions\nfor matchea in reversed(matches):\n  if not idc.get_func_name(matchea):\n    idc.add_func(matchea)\n\n#### The kernel image, kernelcache.release.j273.out, is ~83MB. While the script only took around 10 minutes to execute, the resulting mass of new functions and cross-references took over an hour to finish generating. After weeks of research and testing, all patches were written, and offsets defined:\n#define INITIAL_BRANCH_VADDR_20C69 (0xfffffe0007ac4580)\n#define BZERO_COND_BRANCH_VADDR_20C69 (0xfffffe0007ab8a3c)\n#define SLIDE_SET_INST_VADDR_20C69 (0xfffffe000806b438)\n#define CORE_TRUST_CHECK_20C69 (0xfffffe0008cb6538)\n#define DISABLE_IMGPF_NOJOP_20C69 (0xfffffe000806b234)\n\n### MSR Instructions\n\n#### QEMU is not equipped to emulate ARM-based Apple systems. Over 110 of Apple’s model- specific hardware registers (MSR), in addition to hundreds of others, are currently unrecognized by QEMU. The Aleph Research team added support for 12 Apple-specific registers required for the iOS kernel to boot. To reach the goal of fully booting the MacOS ARM64 kernel, 24 more hardware registers needed support. But which registers would we need to add?\n\n### Finding the Necessary Registers\n\n#### Getting to that bash prompt after two grueling months of research and testing was anything but a straightforward process. Unsupported MSR registers tended to pop up intermittently as we diagnosed and fixed one crash after another. We typically followed a “panic, crash and patch” strategy, adding register support for individual MSR’s on an ad hoc basis. The list of definitions below from hw/arm/j273_macos11.c are the result:\n\n```\n\n-----\n\n```\n  J273_CPREG_DEF(ARM64_REG_EHID1, 3, 0, 15, 3, 1, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_EHID10, 3, 0, 15, 10, 1, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_EHID4, 3, 0, 15, 4, 1, PL1_RW),\n  // EL2 registers\n  J273_CPREG_DEF(ARM64_REG_MIGSTS_EL1, 3, 4, 15, 0, 4, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_KERNELKEYLO_EL1, 3, 4, 15, 1, 0, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_KERNELKEYHI_EL1, 3, 4, 15, 1, 1, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_VMSA_LOCK_EL1, 3, 4, 15, 1, 2, PL1_RW),\n  J273_CPREG_DEF(APRR_EL0, 3, 4, 15, 2, 0, PL1_RW),\n  J273_CPREG_DEF(APRR_EL1, 3, 4, 15, 2, 1, PL1_RW),\n  J273_CPREG_DEF(CTRR_LOCK, 3, 4, 15, 2, 2, PL1_RW),\n  J273_CPREG_DEF(CTRR_A_LWR_EL1, 3, 4, 15, 2, 3, PL1_RW),\n  J273_CPREG_DEF(CTRR_A_UPR_EL1, 3, 4, 15, 2, 4, PL1_RW),\n  J273_CPREG_DEF(CTRR_CTL_EL1, 3, 4, 15, 2, 5, PL1_RW),\n  J273_CPREG_DEF(APRR_MASK_EN_EL1, 3, 4, 15, 2, 6, PL1_RW),\n  J273_CPREG_DEF(APRR_MASK_EL0, 3, 4, 15, 2, 7, PL1_RW),\n  J273_CPREG_DEF(ACC_CTRR_A_LWR_EL2, 3, 4, 15, 11, 0, PL1_RW),\n  J273_CPREG_DEF(ACC_CTRR_A_UPR_EL2, 3, 4, 15, 11, 1, PL1_RW),\n  J273_CPREG_DEF(ACC_CTRR_CTL_EL2, 3, 4, 15, 11, 4, PL1_RW),\n  J273_CPREG_DEF(ACC_CTRR_LOCK_EL2, 3, 4, 15, 11, 5, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_CYC_CFG, 3, 5, 15, 4, 0, PL1_RW),\n  J273_CPREG_DEF(ARM64_REG_CYC_OVRD, 3, 5, 15, 5, 0, PL1_RW),\n  J273_CPREG_DEF(IPI_SR, 3, 5, 15, 1, 1, PL1_RW),\n  J273_CPREG_DEF(UPMCR0, 3, 7, 15, 0, 4, PL1_RW),\n  J273_CPREG_DEF(UPMPCM, 3, 7, 15, 5, 4, PL1_RW),\n\n#### Unrecognized system registers typically appear as s#_#_c#_c#_# in various debuggers, where # corresponds to the arguments in each of the definitions above. For example, ARM64_REG_EHID1 or APRR_EL0 are parsed as s3_0_c15_c3_1 and s3_4_c15_c2_0, respectively. The last argument PL1_RW means “exception level 1 read/write”, which specifies the privilege level of the given registers. This indicates that the register is accessible in exception level 1 (EL1). Yet the level 2 (EL2) registers are marked with PL1_RW. This is because the following line in the function j273_cpu_setup prohibits EL2 registers:\nobject_property_set_bool(cpuobj, \"has_el2\", false, NULL);\n\n Setting this to true proved problematic, as QEMU then became unable to switch from physical to virtual addressing early in the boot process. The fix involved forcing QEMU to treat these registers as EL1 registers in define_one_arm_cp_reg_with_opaque (target/arm/helper.c):\n\n```\n\n-----\n\n```\n    case 4:\n    case 5:\n      /* min_EL EL2 */\n      mask = PL1_RW; // changed from mask = PL2_RW\n      break;\n\n#### We were initially apprehensive of this fix, as modifying any official QEMU source files to bypass errors may prove to be a dangerous endeavor. Fortunately, no calamities arose, and eventually all MSR registers were accounted for.\n\n### Device Tree\n\n#### The device tree (DeviceTree.j273aap.im4p.out) was responsible for over half of the panics during testing. Several properties and devices were either absent from the tree entirely, usually causing a crash, or needed to be manually adjusted to prevent later issues. We have written a program that can apply the necessary changes to a device tree file using a diff-style file:\n\n https://github.com/cylance/macos-arm64-emulation/tree/main/dtetool\n\n To create a compatible device tree, back up the device tree file and apply the changes specified in dtediff_20C69 with the dtetool program:\ncp DeviceTree.j273aap.im4p.out DeviceTree.j273aap.im4p.out.backup\n./dtetool DeviceTree.j273aap.im4p.out.backup -d dtediff_20C69 -o\nDeviceTree.j273aap.im4p.out\n\n The following section provides a more detailed description of each modification.\n\n### Device Tree Modifications\n\n#### The following property is changed to “running” to avoid an infinite loop in pe_identify_machine:\ndevice-tree/cpus/cpu0/state                 8 running\n\n The first element in arm-io/ranges is changed to 0x100000000:\n\n```\n\n-----\n\n```\ndevice-tree/arm-io/ranges                  8 0x100000000\n\n#### The following node is removed to ignore dockchannel-uart in order to use the default uart0 in serial_init:\ndevice-tree/dockchannel-uart\n\n The following properties are added to the “chosen” node to avoid the panics at the end of arm_init:\ndevice-tree/chosen/dram-base                8 0\ndevice-tree/chosen/dram-size                8 0\n\n The following properties are added to the lock-regs node to avoid the panic in subroutine 0xfffffe0007b2af00:\ndevice-tree/chosen/lock-regs/amcc/aperture-count 4 0 d\ndevice-tree/chosen/lock-regs/amcc/aperture-size 4 0 d\ndevice-tree/chosen/lock-regs/amcc/plane-count 4 0 d\ndevice-tree/chosen/lock-regs/amcc/plane-stride 4 0 d\ndevice-tree/chosen/lock-regs/amcc/aperture-phys-addr 0\ndevice-tree/chosen/lock-regs/amcc/cache-status 4 0 d\ndevice-tree/chosen/lock-regs/amcc/cache-status-reg-offset 4 0 d\ndevice-tree/chosen/lock-regs/amcc/cache-status-reg-mask 4 0 d\ndevice-tree/chosen/lock-regs/amcc/cache-status-reg-value 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/page-size-shift 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lower-limit 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lower-limit-reg-offset 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lower-limit-reg-mask 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/upper-limit 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/upper-limit-reg-offset 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/upper-limit-reg-mask 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lock 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lock-reg-offset 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lock-reg-mask 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/lock-reg-value 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/enable 4 0 d\ndevice-tree/chosen/lock-regs/amcc/amcc-ctrr-a/write-disable 4 0 d\n\n```\n\n-----\n\n#### One final device tree property is modified: the nvram.\n\n### NVRAM\n\n#### No external NVRAM file is necessary, as the device tree file can house all NVRAM data in a property called nvram-proxy-data. By default, this property is completely empty, which led to several problems later (i.e. panics), which were related to null pointers. Crafting and configuring the NVRAM to the kernel’s liking was a time-consuming task, albeit with a fairly simple outcome. Several issues cropped up in succession, and additional changes had to be made.\n\n### Null Pointers\n\n#### The first of the NVRAM-related issues happened in IODTNVRAM::init, where a null pointer reference to a lock variable caused a panic. This lock variable was supposed to have been initialized in IODTNVRAM::initNVRAMImage, but this function was never called. We discovered that the device-tree/chosen/nvram-total-size property in the device tree file was zero. Another panic occurred due to a null pointer reference in the IODTNVRAM::initOFVariables function. Apparently the nvram partition dictionary was not being set due to missing partition information in the device tree’s nvram data.\n\n### Nvram-Proxy-Data\n\n#### The solution to this problem was to tailor the device-tree/chosen/nvram-proxy-data and device-tree/chosen/nvram-total-size properties to the kernel’s needs. Clues as to what format this data must be in were given in IODTNVRAM::initNVRAMImage:\n\n\n-----\n\n```\nvoid\nIODTNVRAM::initNVRAMImage(void)\n{\n// ... (snip)\n// Look through the partitions to find the OF, MacOS partitions.\nwhile (currentOffset < kIODTNVRAMImageSize) {\ncurrentLength = ((UInt16 *)(_nvramImage + currentOffset))[1] * 16;\nif (currentLength < 16) {\nbreak;\n}\npartitionOffset = currentOffset + 16;\npartitionLength = currentLength - 16;\nif ((partitionOffset + partitionLength) > kIODTNVRAMImageSize) {\nbreak;\n}\nif (strncmp((const char *)_nvramImage + currentOffset + 4,\n  kIODTNVRAMOFPartitionName, 12) == 0) {\n_ofPartitionOffset = partitionOffset;\n_ofPartitionSize = partitionLength;\n}\n// ... (snip)\ninitOFVariables();\n}\n\n#### When initialized, the NVRAM must be a valid, non-zero size no greater than 65536. This is specified in the nvram-total-size property. In addition to a valid size the nvram must have at least one valid partition with a size of at least 32 bytes. Valid partition names include “common” (defined as kIODTNVRAMOFPartitionName) or “system” (not in the most recent XNU source). Below is the updated device tree data for nvram-proxy-data:\n...\n00000f60: 73 79 73 63 66 67 2f 42 47 4d 74 00 6e 76 72 61 syscfg/BGMt.nvra\n00000f70: 6d 2d 70 72 6f 78 79 2d 64 61 74 61 00 00 00 00 m-proxy-data....\n00000f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 ................\n00000f90: 00 00 02 00 63 6f 6d 6f 6e 00 00 00 00 00 00 ....common......\n00000fa0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n...\n\n Actual data starts at offset 0xf90 in our modified device tree file. The partition’s size is calculated by multiplying the 16-bit integer at offset 0xf92 by 16. In this case, 2 * 16 = 32 bytes. This includes the first 16 bytes containing the partition’s name and the remaining 16 null bytes. Now that the kernel is satisfied with our empty partition, the mystery of the missing NVRAM is solved.\n\n### Forcing JOP\n\n```\n\n-----\n\n#### All the required MSR registers had been added to QEMU. The device tree was properly tailored to the kernel’s requirements. The following launchd greeting in a GDB session gave a small boost of optimism:\n\n Thu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] <Notice>: hello\n\n The holy grail of a shell prompt is still beyond our grasp at this point. Something was spinning in the kernel, impeding progress once again:\n```\n... (snip)\nload_init_program: attempting to load /sbin/launchd\ngetExceptionList: failed to open /System/Library/Security/HardeningExceptions.plist\ndyld: setting comm page to 0x800000000\n000120.870479 wlan0.A[3] initWithProvider@120:amfm not matched\n000120.913992 wlan0.A[4] deferredStart@1726: Lowered adjustBusy(-1), getBusyState()\n-> 4\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: hello\nDarwin Bootstrapper Version 7.0.0: Tue Aug 25 21:19:12 PDT 2020;\nroot:libxpc_executables-2038.40.23.161.1~1/launchd/RELEASE_arm64e\nboot-args = debug=0x8 kextlog=0xfff cpus=1 rd=md0 serial=2\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Restore\nenvironment starting.\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: System\nIntegrity Protection is engaged.\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: entering ondemand mode\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: fsck\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: mount-phase-1\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: data-protection\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: check-migration-mode\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: unlock-data-volume\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: Doing boot\ntask: commit-boot-mode\nThu Jan 1 00:02:10 1970 localhost com.apple.xpc.launchd[1] < Notice >: boot-mode\ncommitted: (null)\n... (spinning)\n\n In an infinite loop at 0xfffffe00079ebcbc:\n\n```\n\n-----\n\n```\n(gdb) c\nContinuing.\n^C\nProgram received signal SIGINT, Interrupt.\n0xfffffe00079ebcbc in ?? ()\n(gdb)\n\n#### In Ldisable_jop:\n\n Figure 2.\n\n Notice the infinitely looping B.NE instruction. How did it get here? We looked a bit further up in the disassembly:\n\n Figure 3.\n\n```\n\n-----\n\n#### XNU kernel threads have a member called TH_DISABLE_USER_JOP. If set to a non-zero value, Ldisable_jop is invoked. SCTLR_EL1 (system control register) is then validated against a constant (0x7454599d) and freezes execution if the values do not match. Where is this thread property being set, and how can we prevent it in the most orthodox manner possible? Setting a write watchpoint in gdb for the address of the blocking thread’s TH_DISABLE_USER_JOP property leads to this location in posix_spawn:\n\n Figure 4.\n\n In posix_spawn (xnu-6153.141.1/bsd/kern/kern_exec.c):\n```\nerror = exec_activate_image(imgp);\n#if defined(HAS_APPLE_PAC)\nml_task_set_disable_user_jop(new_task, imgp->ip_flags & IMGPF_NOJOP ? TRUE : FALSE);\nml_thread_set_disable_user_jop(imgp->ip_new_thread, imgp->ip_flags & IMGPF_NOJOP ?\nTRUE : FALSE);\n#endif\n\n In the case of the blocking thread, imgp->ip_flags is set to 0x80000000, which indicates the IMGPF_NOJOP flag is enabled. The enabled status of this flag is written to the thread’s TH_DISABLE_USER_JOP property. So where is imgp->ip_flags set?\n\n```\n\n-----\n\n### Load_machfile\n\n#### IMGPF_NOJOP is enabled in load_machfile near the end of the function:\n\n Figure 5.\n\n Load_machfile compares the Mach-O executable’s identifier against several strings and enables IMGPF_NOJOP if any are a match:\n```\ncom.apple.security.cs.disable-library-validation\ncom.apple.private.cs.automator-plugins\ncom.apple.private.security.clear-library-validation\ncom.apple.perl5\ncom.apple.perl\norg.python.python\ncom.apple.expect\ncom.tcltk.wish\ncom.tcltk.tclsh\ncom.apple.ruby\ncom.apple.bash\ncom.apple.zsh\ncom.apple.ksh\n\n The bash identifier is among them. This flag may be a security mechanism to prevent certain executables from loading at boot time, as they may be used to compromise the system. Among them are several shell clients and script interpreters. The kernel blocks the executing thread if the Mach-O file’s identifier matches any of the above strings.\n\n### Solution\n\n#### NOP over the ORR W8, W8 #0x80000000 instruction to keep IMGPF_NOJOP disabled. This gave the go-ahead to the kernel to allow launchd to execute bash (via xpcproxy):\n\n```\n\n-----\n\n```\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: auto-pivot-root\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: allow-non-platform-code\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Doing boot\ntask: restore-datapartition\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: restoredatapartition: optional boot task not present\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: mount-phase-2\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: enable-swap\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: sandbox-enable-root-translation\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Doing boot\ntask: init-with-data-volume\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: deferred_install\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: fips\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: cache-start\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: bootroot\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: init_featureflags\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: EndpointSecurity\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: rc.server\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: tzinit\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: dirhelper\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: rootless-init\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: finish-demo-restore\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: systemstats\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: prng_seedctl\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Warning >: Unable to\nload cache\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: launchd\nUUID: 438960C9-7E3C-3D4A-9EA8-643FF64ACDF2\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Early boot\ncomplete. Continuing system boot.\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: entering bootstrap mode\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Error >: Failed to bootstrap path: path =\n/Library/Apple/System/Library/LaunchDaemons, error = 2: No such file or directory\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1]\n\n```\n\n-----\n\n```\n(com.apple.xpc.launchd.domain.system) < Critical >: No task access server\nconfigured! The system will not get very far.\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: exiting bootstrap mode\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1] < Notice >: Skipping\nboot-task: cache-tag\nThu Jan 1 00:01:58 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: exiting ondemand mode\nThe default interactive shell is now zsh.\nTo update your account to use zsh, please run `chsh -s /bin/zsh`.\nFor more details, please visit https://support.apple.com/kb/HT208050.\nbash-3.2#\n\n#### A prompt appeared at last. Yet stdin is not working and there is no keyboard input.\n\n### Serial Keyboard and FIQ\n\n#### A fully functioning bash prompt is useless without keyboard input. Keyboard input is read in a separate thread in a function called serial_keyboard_poll. The serial_keyboard_poll:\n\n Reads all pending characters from the stdin buffer Sets the 16-millisecond deadline by calling assert_wait_deadline Blocks execution in thread_block until the deadline has passed\n\n serial_keyboard_poll is then re-invoked by thread_invoke, and this sequence of events repeats indefinitely for as long as bash is open.\n\n```\n\n-----\n\n-----\n\n#### Figure 6.\n\n Yet this wasn’t happening. Thread_block was called only once, the thread stalled, and serial_keyboard_poll was never invoked again.\n\n We thought: maybe the deadline wasn’t being reached? Wait deadlines are specified in the assert_wait_deadline function. This function creates a waitq object for the current keyboard- polling thread with an optional deadline, in nanoseconds. When thread_block is called shortly afterwards, the thread hangs until the thread_clear_waitq_state kernel function clears the thread’s waitq object:\n```\nstatic inline void\nthread_clear_waitq_state(thread_t thread)\n{\n  thread->waitq = NULL;\n  thread->wait_event = NO_EVENT64;\n  thread->at_safe_point = FALSE;\n}\n\n But this function never got called, and the deadline was never reached. What does the thread do? It switches context to the system idle thread and blocks indefinitely, never invoking a continuation of serial_keyboard_poll to continue polling for stdin. Surely something somewhere is called that may lead to thread_clear_waitq_state? By back tracing the sequence of function calls in the XNU source, we discovered the origin of interrupt timers:\n\n```\n\n-----\n\n```\nthread_clear_waitq_state\nwaitq_pull_thread_locked\nclear_wait_internal\nthread_timer_expire\ntimer_queue_expire_with_options\ntimer_intr\nrtclock_intr\nsleh_fiq\n_fleh_fiq\n\n#### After analyzing this call flow, we were inching ever closer to the source of the problem. Analyzing the interoperability of threads, timers, clocks, and interrupts in the XNU kernel was slowly paying dividends.\n\n### Fast Interrupt Requests (FIQ)\n\n#### Further investigation revealed that not even fleh_fiq (first-level exception handler for Fast Interrupt Request) was being called. Something was seriously wrong, as fleh_fiq is integral to a working interrupt timer. Peripheral devices like keyboards and mice typically communicate with the kernel using Fast Interrupt Requests (FIQ) in the ARM architecture. We confirmed that FIQs were not firing in the emulator after looking at QEMU’s source. We discovered that arm_cpu_exec_interrupt, which is called for a fast interrupt request, never got called. No amount of keyboard-spamming would trigger this or any of the kernel functions listed above.\n\n### Hardware Timers\n\n#### Perhaps another possibility for a non-operational FIQ handler was timer-related? Threads often rely on hardware timers to notify the thread of a passed deadline. If no timer exists, no countdowns can be performed and idle threads waiting for a deadline will stall the system. Without a hardware timer to poll for FIQs, MacOS will ignore them. This is significant, as it would have affected not only standard keyboard input, but other areas of the kernel as well. Wait deadlines would never be reached, threads would hang, and services would never start simply because no hardware timer was present.\n\n### Enable_timebase_event_stream\n\n#### We did a comparison between the iOS and MacOS kernel for the enable_timebase_event_stream function. Why this function? Because this function modifies three timer-related system registers and could provide the answer to our timer dilemma. Below is from the MacOS kernel:\n\n```\n\n-----\n\n#### Figure 7.\n\n Contrast the above with the corresponding iOS kernel disassembly:\n\n Figure 8.\n\n We immediately noticed the presence of an extra register in the MacOS kernel: CNTV_CTL_EL0. With the help of a comprehensive list of iOS ARM64 system registers, we began to make the connection between these registers and the timer issues. The iOS kernel appeared to be enabling the physical timer by writing 1 to it, while the MacOS kernel was enabling the virtual timer by writing 1 to it. Then we noticed the line in the xnu-qemu- ARM64 source:\n\n\n-----\n\n```\n  qdev_connect_gpio_out(cpudev, GTIMER_PHYS,\n             qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));\n\n#### The GTIMER_VIRT constant gave it away almost instantly. QEMU’s official source lists five different global timer types in target/arm/cpu.h:\n#define GTIMER_PHYS   0\n#define GTIMER_VIRT   1\n#define GTIMER_HYP   2\n#define GTIMER_SEC   3\n#define GTIMER_HYPVIRT 4\n\n The solution was incredibly simple: MacOS uses a virtual timer. iOS uses a physical timer. Therefore, QEMU must specify a virtual timer with GTIMER_VIRT instead of GTIMER_PHYS when linking the timer to FIQ. Switching to GTIMER_VIRT:\n  qdev_connect_gpio_out(cpudev, GTIMER_VIRT,\n             qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));\n\n Followed by booting up the MacOS kernel, waiting for the bash prompt, then:\nbash-3.2# asdfasdfasdf\nbash-3.2# ls\n.fseventsd   dev       mnt3      mnt7      sbin\nLibrary     etc       mnt4      mnt8      usr\nSystem     mnt1      mnt5      mnt9      var\nbin       mnt2      mnt6      private\nbash-3.2#\n\n Such a simple answer to a cryptic problem. This final fix marks the end of the final phase of a fully bootable MacOS 11 ARM64e kernel.\n\n### Achieving a Functioning Emulator\n\n#### This chronicling of discoveries, fixes and accomplishments would not be complete without long-term failures and ineffective bypasses. Below are several examples that involved multiple days of research and testing and created quite a bit of frustration throughout.\n\n```\n\n-----\n\n### IORTC\n\n#### Before we discovered, diagnosed, and mitigated the timer dilemma, something related to the initialization of the RTC (real-time clock) had been blocking the bsd_init thread. IOKitInitializeTime was waiting for a matching IORTC service. The wait was initiated by IOService::waitForMatchingService, which relies on assert_wait or assert_wait_deadline to begin blocking the thread until a condition is met. assert_wait_deadline is non-functional without a working hardware timer. The kernel had no working hardware timer. We tried adding the no-rtc property to the device tree root and a child node (with the name rtc) to the arm-io node. This would invoke the bootstrap to immediately publish the IORTC service and skip the wait. After the real source of the problem was determined and fixed, these device tree nodes were removed.\n\n### Task-access Server and SIP\n\n#### The following message from the launchd output was a bit disconcerting:\n```\n< Critical >: No task-access server configured! The system will not get very far.\n\n It was originally attributed to code-signing, then attributed to SIP, and finally ignored once a functioning bash prompt was operational. This message caused several unneeded headaches. A task-access server is related to communication between tasks over the task- access port (defined as constant TASK_ACCESS_PORT with a value of 9). Assuming this only affected TCP connections, which this emulation project currently does not support, we ignored the error.\n\n### iOS Binary Incompatibility\n\n#### RootlessJB provides common Mach-O ARM64e binaries, including bash, that are runnable in the iOS kernel. These are iOS binaries for an iOS kernel. This explains why one is likely to see the following message when attempting to run said binaries on a MacOS system and never see a bash prompt:\nUsing iOS Platform policy\nport is not ready for callouts\n\n```\n\n-----\n\n#### The necessary command line tools are part of the base ARM64 system, archived deep within the MacOS Big Sur installer package. This is simply a warning to those attempting execution of the aforementioned iOS binaries in a MacOS environment: it probably won’t work.\n\n### Conclusion\n\n#### This project was a successful experiment in cross-platform emulation that has potential for future development. Hard disk and TCP tunneling (which xnu-qemu-arm64 already supports for iOS) still await implementation. Multi-core and KVM support would dramatically reduce the boot time, perhaps to mere seconds, and eliminate massive overhead. Full graphical support is a mere prospect (even less so in a cross-platform environment). But graphical support is low priority, so long as a functioning shell client is present. If it works, that is enough of a motivation to make it work well.\n\n### Example Commands\n\n#### To complement the article, we have decided to provide examples of command output from an emulated MacOS 11 ARM64e guest. For example, the following shows output from the lsof program:\n\n\n-----\n\n```\nbash-3.2# lsof -c launchd\nCOMMAND PID USER  FD  TYPE DEVICE SIZE/OFF NODE NAME\nlaunchd  1 root cwd  DIR  2,0   748  2 /\nlaunchd  1 root txt  REG  2,0  418976 940 /sbin/launchd\nlaunchd  1 root txt  REG  2,0  821120 958 /usr/lib/dyld\nlaunchd  1 root txt  REG  2,0  60880 977 /usr/lib/libSystem.B.dylib\nlaunchd  1 root txt  REG  2,0  443120 1024 /usr/lib/libobjc.A.dylib\nlaunchd  1 root txt  REG  2,0  79072 985 /usr/lib/libauditd.0.dylib\nlaunchd  1 root txt  REG  2,0  161504 989 /usr/lib/libbsm.0.dylib\nlaunchd  1 root txt  REG  2,0  77424 1044 /usr/lib/system/libcache.dylib\nlaunchd  1 root txt  REG  2,0  163856 1045\n/usr/lib/system/libcommonCrypto.dylib\nlaunchd  1 root txt  REG  2,0  64304 1046\n/usr/lib/system/libcompiler_rt.dylib\nlaunchd  1 root txt  REG  2,0  101696 1047 /usr/lib/system/libcopyfile.dylib\nlaunchd  1 root txt  REG  2,0  656832 1048\n/usr/lib/system/libcorecrypto.dylib\nlaunchd  1 root txt  REG  2,0  557520 1051 /usr/lib/system/libdispatch.dylib\nlaunchd  1 root txt  REG  2,0  501456 1052 /usr/lib/system/libdyld.dylib\nlaunchd  1 root txt  REG  2,0  57616 1053 /usr/lib/system/libkeymgr.dylib\nlaunchd  1 root txt  REG  2,0  35296 1055 /usr/lib/system/liblaunch.dylib\nlaunchd  1 root txt  REG  2,0  80192 1056 /usr/lib/system/libmacho.dylib\nlaunchd  1 root txt  REG  2,0  64432 1059\n/usr/lib/system/libquarantine.dylib\nlaunchd  1 root txt  REG  2,0  59168 1060\n/usr/lib/system/libremovefile.dylib\nlaunchd  1 root txt  REG  2,0  197136 1061\n/usr/lib/system/libsystem_asl.dylib\nlaunchd  1 root txt  REG  2,0  110560 1062\n/usr/lib/system/libsystem_blocks.dylib\nlaunchd  1 root txt  REG  2,0  758912 1063 /usr/lib/system/libsystem_c.dylib\nlaunchd  1 root txt  REG  2,0  53456 1064\n/usr/lib/system/libsystem_collections.dylib\nlaunchd  1 root txt  REG  2,0  100864 1065\n/usr/lib/system/libsystem_configuration.dylib\nlaunchd  1 root txt  REG  2,0  176752 1066\n/usr/lib/system/libsystem_containermanager.dylib\nlaunchd  1 root txt  REG  2,0  99584 1067\n/usr/lib/system/libsystem_coreservices.dylib\nlaunchd  1 root txt  REG  2,0  144048 1068\n/usr/lib/system/libsystem_darwin.dylib\nlaunchd  1 root txt  REG  2,0  132912 1069\n/usr/lib/system/libsystem_dnssd.dylib\nlaunchd  1 root txt  REG  2,0  75376 1070\n/usr/lib/system/libsystem_featureflags.dylib\nlaunchd  1 root txt  REG  2,0  451008 1071\n/usr/lib/system/libsystem_info.dylib\nlaunchd  1 root txt  REG  2,0  244320 1073 /usr/lib/system/libsystem_m.dylib\nlaunchd  1 root txt  REG  2,0  317408 1074\n/usr/lib/system/libsystem_malloc.dylib\nlaunchd  1 root txt  REG  2,0  166784 1075\n/usr/lib/system/libsystem_networkextension.dylib\nlaunchd  1 root txt  REG  2,0  115616 1076\n/usr/lib/system/libsystem_notify.dylib\n\n```\n\n-----\n\n```\nlaunchd  1 root txt  REG  2,0  21952 1078\n/usr/lib/system/libsystem_product_info_filter.dylib\nlaunchd  1 root txt  REG  2,0  103232 1080\n/usr/lib/system/libsystem_sandbox.dylib\nlaunchd  1 root txt  REG  2,0  80112 1081\n/usr/lib/system/libsystem_secinit.dylib\nlaunchd  1 root txt  REG  2,0  373952 1072\n/usr/lib/system/libsystem_kernel.dylib\nlaunchd  1 root txt  REG  2,0  105232 1077\n/usr/lib/system/libsystem_platform.dylib\nlaunchd  1 root txt  REG  2,0  149616 1079\n/usr/lib/system/libsystem_pthread.dylib\nlaunchd  1 root txt  REG  2,0  101552 1082\n/usr/lib/system/libsystem_symptoms.dylib\nlaunchd  1 root txt  REG  2,0  242032 1083\n/usr/lib/system/libsystem_trace.dylib\nlaunchd  1 root txt  REG  2,0  114304 1085 /usr/lib/system/libunwind.dylib\nlaunchd  1 root txt  REG  2,0  467728 1086 /usr/lib/system/libxpc.dylib\nlaunchd  1 root txt  REG  2,0  268336 993 /usr/lib/libc++abi.dylib\nlaunchd  1 root txt  REG  2,0  80128 1022 /usr/lib/liboah.dylib\nlaunchd  1 root txt  REG  2,0  787520 991 /usr/lib/libc++.1.dylib\nlaunchd  1 root  0w  CHR  0,0  0t4982 291 /dev/console\nlaunchd  1 root  1w  CHR  0,0  0t4982 291 /dev/console\n\n#### The df command lists active file systems, such as the root device where launchd, bash, and all other userland programs are located:\nbash-3.2# df -h\nFilesystem  Size  Used Avail Capacity iused   ifree %iused Mounted on\nroot_device 1.5Gi 130Mi 1.4Gi   9%  1668 4294965611  0%  /\ndevfs    168Ki   0Bi  100%   580     0 100%  /dev\n\n View network interfaces with ifconfig:\nbash-3.2# ifconfig\nALF, old data swfs_pid_entry, updaterules_msg < ptr >, updaterules_state < ptr\n>lo0: flags=8049< UP,LOOPBACK,RUNNING,MULTICAST > mtu 16384\n    options=1203< RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP >\n    inet 127.0.0.1 netmask 0xff000000\n    inet6 ::1 prefixlen 128\n    inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1\n    nd6 options=201< PERFORMNUD,DAD >\ngif0: flags=8010< POINTOPOINT,MULTICAST > mtu 1280\nstf0: flags=0<> mtu 1280\n\n```\n\n-----\n\n#### Finally, the full output of a shutdown command:\n```\nbash-3.2# shutdown -h now\nShutdown NOW!\nSystem shutdown time has arrived\nThu Jan 1 00:06:11 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) : System shutdown initiated by: shutdown.10<bash.3<-launchd.1\nThu Jan 1 00:06:11 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: committing to system shutdown\nKext loading now disabled.\nKext unloading now disabled.\nKext autounloading now disabled.\nKernel requests now disabled.\nSystem shutdown; requesting immediate kernelmanagerd exit.\nASP: System is shutting down, preventing further ASP upcalls\nASP: ASP: shutting down, drained\nbash-3.2# Thu Jan 1 00:06:41 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) : shutdown UNINITIALIZED -> COMMITTED\nThu Jan 1 00:06:41 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: shutdown already committed\nThu Jan 1 00:06:41 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: shutdown COMMITTED -> COMMITTED\nThu Jan 1 00:06:41 1970 localhost com.apple.xpc.launchd[1]\n(com.apple.xpc.launchd.domain.system) < Notice >: shutdown COMMITTED ->\nWAITING_ON_SERVICES\nASP: System is shutting down, (SIP is ENABLED) allowing process at path:\n/usr/sbin/spindump\nThu Jan 1 00:06:43 1970 localhost com.apple.xpc.launchd[1] < Notice >: Generating\nreport...\ndyld: dyld cache load error: shared cache file open() failed\ndyld: Library not loaded:\n/System/Library/PrivateFrameworks/CoreSymbolication.framework/Versions/A/CoreSymbolic\n Referenced from: /usr/sbin/spindump\n Reason: image not found\nAMFI: Denying core dump for pid 11 (spindump)Thu Jan 1 00:06:44 1970 localhost\ncom.apple.xpc.launchd[1] < Warning >: shutdown-stall: non-boot task exited with\nstatus 6\nThu Jan 1 00:06:44 1970 localhost com.apple.xpc.launchd[1] < Notice >: Report\ngenerated in 0 seconds.\nThu Jan 1 00:06:44 1970 localhost com.apple.xpc.launchd[1] < Error >: Host-level\nexception raised: pid = 11, thread = 0x50f, exception type = 0xd, codes = {\n25769803777 }, states = { 0 }\nsyncing disks... Killing all processes\ncontinuing\nhfs: unmount initiated on GoldenGateC20C69.arm64eSURamDisk on device b(2, 0)\ndone\nCPU halted\nASP: ASP: shutting down\npanic(cpu 0 caller 0xfffffe0008289f38): \"Halt/Restart Timed Out\"\n\n```\n\n-----\n\n#### Yes, that is a panic at the end. Add fatal shutdown to the list of issues awaiting a fix.\n\n### Resources\n\n#### Setup Guide\n\n https://github.com/cylance/macos-arm64-emulation\n\n Aleph Research\n\n Running iOS in QEMU to an interactive bash shell (1): tutorial\n\n https://github.com/alephsecurity/xnu-qemu-arm64\n\n https://github.com/alephsecurity/xnu-qemu-arm64-tools\n\n XNU\n\n XNU source tarballs - https://opensource.apple.com/tarballs/xnu/\n\n XNU source - https://github.com/apple-opensource/xnu\n\n Tools\n\n QEMU 5.1.0 - https://www.qemu.org/download/#source\n\n OSX-KVM - https://github.com/kholia/OSX-KVM\n\n xar - https://github.com/mackyle/xar\n\n apfs-fuse - https://github.com/sgan81/apfs-fuse\n\n Links\n\n https://landley.net/aboriginal/presentation.html\n\n https://developer.android.com/studio/run/emulator-commandline\n\n https://developer.arm.com/documentation/dui0801/g/A64-Data-Transfer-Instructions/LDAPR\n\n https://developer.arm.com/architectures/instruction-sets/base-isas/a64\n\n https://worthdoingbadly.com/xnuqemu3/\n\n\n-----\n\n## About The BlackBerry Research & Intelligence Team\n\n#### The BlackBerry Research & Intelligence team examines emerging and persistent threats, providing intelligence analysis for the benefit of defenders and the organizations they serve.\n\n Back\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-18 - Strong ARMing with MacOS- Adventures in Cross-Platform Emulation.pdf"
    ],
    "report_names": [
        "2021-05-18 - Strong ARMing with MacOS- Adventures in Cross-Platform Emulation.pdf"
    ],
    "threat_actors": [
        {
            "id": "cfdd35af-bd12-4c03-8737-08fca638346d",
            "created_at": "2022-10-25T16:07:24.165595Z",
            "updated_at": "2025-03-27T02:02:10.128957Z",
            "deleted_at": null,
            "main_name": "Sea Turtle",
            "aliases": [
                "Cosmic Wolf",
                "Marbled Dust",
                "Silicon",
                "Teal Kurma",
                "UNC1326"
            ],
            "source_name": "ETDA:Sea Turtle",
            "tools": [
                "Drupalgeddon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "33ae2a40-02cd-4dba-8461-d0a50e75578b",
            "created_at": "2023-01-06T13:46:38.947314Z",
            "updated_at": "2025-03-27T02:00:02.959421Z",
            "deleted_at": null,
            "main_name": "Sea Turtle",
            "aliases": [
                "SILICON",
                "Teal Kurma",
                "UNC1326",
                "COSMIC WOLF",
                "Marbled Dust"
            ],
            "source_name": "MISPGALAXY:Sea Turtle",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536107,
    "ts_updated_at": 1743041613,
    "ts_creation_date": 1653779518,
    "ts_modification_date": 1653779518,
    "files": {
        "pdf": "https://archive.orkl.eu/79c112ac12d89cc4c2881a3b23c05b5eb05fbc98.pdf",
        "text": "https://archive.orkl.eu/79c112ac12d89cc4c2881a3b23c05b5eb05fbc98.txt",
        "img": "https://archive.orkl.eu/79c112ac12d89cc4c2881a3b23c05b5eb05fbc98.jpg"
    }
}