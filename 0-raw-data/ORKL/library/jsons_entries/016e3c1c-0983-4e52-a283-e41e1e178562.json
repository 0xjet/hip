{
    "id": "016e3c1c-0983-4e52-a283-e41e1e178562",
    "created_at": "2023-01-12T15:02:34.285499Z",
    "updated_at": "2025-03-27T02:05:30.787599Z",
    "deleted_at": null,
    "sha1_hash": "8de669d11832d0f3e93043edecd3cd8a2a1c4eb9",
    "title": "2018-06-29 - Where we go, we don't need files- Analysis of fileless malware -Rozena-",
    "authors": "",
    "file_creation_date": "2022-05-28T01:26:40Z",
    "file_modification_date": "2022-05-28T01:26:40Z",
    "file_size": 2404265,
    "plain_text": "# Where we go, we don't need files: Analysis of fileless malware \"Rozena\"\n\n**[gdatasoftware.com/blog/2018/06/30862-fileless-malware-rozena](https://www.gdatasoftware.com/blog/2018/06/30862-fileless-malware-rozena)**\n\nFileless malware leverages exploits to run malicious commands or launch scripts directly\nfrom memory using legitimate system tools such as Windows Powershell. Code Red and\nSQL Slammer were pioneers of fileless malware which date back to the early 2000s.\nCurrently, this type of malware is on the rise once again.\n\n\n-----\n\nThe talk of the town within the first half of the year on Cyber Security community is the term\n“fileless” attack. It is an attack technique that does not require downloading nor dropping\nmalicious files into the system to execute its malicious behavior, but rather leverages on\nexploits to run malicious commands or launch scripts directly from memory via legitimate\nsystem tools. In fact, attacks such as Code Red and SQL Slammer worms in the early 2000s\ndo not save itself to any disk but store its malicious code solely in memory.\n\nHowever, the term \"fileless\" can also be a misnomer as there are attacks that may involve\npresence of files on the computer, such as opening an attachment from spam emails. Once\nexecuted, it may still save a file on disk and later use fileless techniques to gather\ninformation on the system and spread the infection throughout the network. These\ntechniques can be in the form of exploits and code injections to execute malicious code\ndirectly in memory, storing scripts in registry, and executing commands via legitimate tools. In\n[2017 alone, 13% of the gathered malware uses PowerShell to compromise the system.](https://www.gdatasoftware.com/blog/2018/03/30610-malware-number-2017)\n\nLegitimate system tools such as PowerShell and Windows Management Instrumentation are\nbeing abused for malicious activities, since these are all built-in tools that run in Windows\noperating system. One known malware family that uses PowerShell to download and\n[execute malicious files is the Emotet downloader.](https://cyber.wtf/2017/11/27/emotet-drops-zeus-panda-targeting-german-and-austrian-online-banking-users/)\n\nThere are even old malwares that changed its technique and now uses fileless attack. These\nmalwares aim to be more effective in terms of infecting machines and avoiding detection like\nRozena.\n\nRozena is a backdoor-type malware capable of opening a remote shell connection leading\nback to the malware author. A successful connection to the malware author yields numerous\nsecurity concerns not only to the affected machine, but also to other computers connected\non its network.\n\nThis was first seen in 2015 and made a comeback on March 2018. The old and new Rozena\nmalware still targets Microsoft Windows operating systems, but what made the difference is\n\n\n-----\n\nthe new one s adaption to the fileless technique which uses PowerShell scripts to execute its\n[malicious intent. A survey done by Barkly and the Ponemon Institute, which polled 665 IT](https://www.barkly.com/ponemon-2018-endpoint-security-statistics-trends)\nand security leaders, found out that fileless attack are 10 times more likely to succeed than\nthose of file-based attacks. This could be the probable reason why malware authors are now\nfollowing the fileless trail.\n\n## Arrival and Infection Routine Overview\n\nFigure 1: Steps of Rozena's infection routine\n\nThis file may arrive on a system as a dropped file by another malware or as a downloaded\nfile when visiting malicious sites. It may also arrive as an attachment on a crafted spam\nemail. Rozena is an executable file that masks itself as a Microsoft Word file. Upon\nexecution, it will create a text file named Hi6kI7hcxZwU in %temp% folder. Then the\nexeutable file will launch obfuscated and encoded PowerShell commands with specific order\nand purpose. In this case, we name these scripts as CREATOR script, DECODER script and\nINJECTOR script for easier tagging in the In-Depth Analysis. The creator script is\nresponsible in spawning the decoder script. The decoder script is to decrypt the content of\nHi6kI7hcxZwU and execute it. The decoded script will yield the injector script that will injects\nshellcode to PowerShell.exe.\n\nThis injected shellcode will create a reverse TCP connection to a remote server that will give\nan access to the malware author. It is like opening a door to the thieves that makes them\ntake and do whatever they want to the house, and can go beyond in reaching all its\nneighbors.\n\n## In-depth Analysis\n\n\n-----\n\nOne of the common techniques used to lure users in executing files from unknown sender or\nunknown downloads is to make them look harmless. Since the default Windows’ feature is\nnot to show the file extension, it is easier for the malware author to bait the user to execute\nthe file as shown in Figure 2. Rozena chooses to use Microsoft Word Icon, but it is a\nWindows executable file as shown in Figure 3 for Rozena’s file header.\n\nFigure 2: Rozena uses the icon of a Microsoft Word file to disguise itself\n\nFigure 3: File header of Rozena - note that the MZ header indicates a regular executable file\nUpon execution, it will create a file in %temp% folder with a fixed filename Hi6kI7hcxZwUI.\n\nFigure 4: The contents of \"Hi6kI7hcxZwUI\", as seen in HVIEW\nThen it will call CreateProcessA to a PowerShell script via command line, where we name\nthe first script as CREATOR Script.\n\n\n-----\n\nFigure 5: Shell - executing a PowerShell script\nNow let's take a closer look at the PowerShell parameters:\n\nFigure 6: First PowerShell script (parameter and partially encrypted code)\nThe parameters and functions consist of mixed lower and upper cases, and this is one of the\nobfuscation techniques used by this file for executing PowerShell scripts. PowerShell\ncommands by default is not case sensitive, thus doing this cannot affect its execution.\nAlmost all parameters used by this file has similar format – mixed cases and shortened\nsyntax.\n\n**-wIndOwsTY, is a syntax for -WindowStyle parameter of PowerShell. The truncating of**\nsyntax is also for obfuscation and anti-detection, and this is still a valid parameter because of\nhow PowerShell handles parameter binding.\n\n**HiddeN, which means that it will set the window style for this session to hidden. This**\nparameter is widely used to prevent the PowerShell from displaying a window when it\nexecutes a script.\n\n**-c, short for -Command. It will execute a command that follows the parameter as though**\nthey were typed at the PowerShell command prompt. The value after the command is an\nencrypted script block.\n\n\n-----\n\nFigure 7: Encrypted CREATOR Script\nUsing join, split and convert functions from PowerShell, this code will be decrypted as a\nscript as shown on Figure 8. The script also uses a pipeline operator (|) to send the\ncommand string to Invoke -Expression, that will execute the script on the infected machine.\nFor obfuscation and not to be detected easily, the 'iNVOKE-EXPreS'+'sIOn' is a\nconcatenated string for Invoke-Expression.\n\nFigure 8: Decrypted CREATOR Script\nThe first section that is boxed in red is only for variable declarations to be later used in the\nPowerShell parameter. The lower part which is boxed in gray are the new parameters for the\nsecond PowerShell that will be spawned.\n\nNow let us take a look at the newly created PowerShell script and its parameters:\n\n\n-----\n\nFigure 9: Encrypted DECODER script\nThe upper part boxed in red consists of PowerShell parameters and some obfuscation\nfunctions.\n\nNow let's break down each parameter:\n\n**-noniNtE, shortened syntax for -NonInteractive. It is used to prevent showing an interactive**\nprompt to the user. It is often combined with -WindowStyle Hidden to hide any script\nexecution.\n\n**-nOlOG, shortened syntax for -NoLogo. Hides the copyright banner when PowerShell is**\nexecuted.\n\n**-NOpROFI, shortened syntax for -NoProfile. Does not load the PowerShell profile.**\n\n**-wIndOwsTY HiddeN, shortened syntax for -WindowStyle Hidden. As mentioned above, to**\nprevent PowerShell from displaying when executed.\n\n**-ExeCUTIonPOlic BypaSS, truncated syntax for -ExecutionPolicy bypass. It is used to set**\nthe default execution policy for the current session. This parameter does not make any\nchanges to the PowerShell execution policy set in Windows Registry, nor writes file on disk to\nevade security checks and hide malicious execution.\n\nSetting the execution policy to bypass will not block any script execution and there are no\nwarnings or prompts to alarm the user. It is also regardless of the user’s profile, whether\nadministrator or not, the PowerShell script will still be executed.\n\nAfter -ExeCUTIonPOlic BypaSS, there is an obfuscated code that only yields ‘-ec’ when\ndecrypted.\n\n**-ec, truncated syntax for encodedcommand, it accepts a base-64-encoded data block**\nversion of a command. This parameter is used to submit commands to PowerShell that\nrequire complex quotation marks or curly braces. This parameter runs the base64-encoded\ncommand highlighted section from Figure 8.\n\nDecrypting the part boxed in green in Figure 9 which is a base-64-encoded data block. This\nwill generate another PowerShell script, calling this as the DECODER script.\n\n\n-----\n\nFigure 10: Decrypted DECODER script\nThe procedure is the same in the decrypted CREATOR Script shown in Figure 8. The part\nboxed in red is just variable declarations which will be used later as a parameter for\nPowerShell execution. The part boxed in gray has the same parameters as Figure 9, but with\ndifferent obfuscations used.\n\nIn the DECODER script, it used some new parameters highlighted in green, which is\nsomehow readable even with the strings are concatenated.\n\n**New-Object is used to create an instance of a .NET Framework class, which in this script, it**\ncreates System.Net.Webclient which is used to send and receive data from remote\nresources. Most of the threats today, especially downloaders that uses PowerShell scripts\nuses this code.\n\n**-f / -File, run commands from a specified file which points to the output of DownloadString()**\n\nthat downloads the content from Hi6kI7hcxZwU (file located in %temp% folder shown in\nFigure 2 to a buffer in the memory.\n\nSince this is an encrypted string, it will then be decrypted using XOR operation as seen on\nthe last part of the PowerShell script (DECODER script). The file Hi6kI7hcxZwU will\nsubsequently be deleted.\n\n\n-----\n\nFigure 11: Decrypted content of Hi6kI7hcxZwU\nThe decrypted output has the same structure as the CREATOR script. Notice the last part of\nthis script in Figure 11, it is an obfuscated parameter for Invoke-Expression and this will be\nthe third PowerShell Script to be executed by this file, calling this as the INJECTOR script.\nThis is a common anti-debugging technique by most malware wherein wrapping their code\nwith multiple layers of obfuscation and encryption. Decrypting this code, will yield us another\nbase-64-encoded data block.\n\nFigure 11b: Second half of the decrypted content of Hi6kI7hcxZwU\nAfter decrypting this base-64-encoded data block in Figure 12.a, we finally can see the script\nin its full glory:\n\n\n-----\n\nFigure 11b: Decrypted INJECTOR Script\nThe upper part highlighted in red has much a lot of readable strings and only few string\nobfuscations. There is DLLImport for kernel32.dll and msvcrt.dll, for importing APIs in\nWindows Kernel and msvcrt library. There are specific APIs that can be seen: VirtualAlloc,\nCreateThread and memset. These are common APIs used for executing a code injection.\nThe middle part contains hexadecimal byte values that make up a block of code and assign it\nto a variable. This block of code is referred to as the shellcode. In the bottom part,\nhightighted in green, the obfuscated functions will copy the hexadecimal byte values to the\nallocated memory and inject it to the running PowerShell.exe, using VirtualAlloc and memset.\n\n## Digging into the shellcode\n\nThe following APIs will be harvested and used:\n\n- WSASocketA\n\n- Connect\n\n- Recv\n\n- VirtualAlloc\n\n\n-----\n\nIt will try to establish a connection to a server: 18[.]231[.]121[.]185[:]443 (down at the time of\nanalysis). Notice that it also uses TCP port 443 which is used for SSL connections, as shown\non Figure 13. This means that all data passed through the server to the receiver remains\nprivate and integral and a way to avoid security checks and network detections. The IP\naddress and port number are hard-coded in the shellcode as hexadecimal byte values.\n\nFigure 12: The shell code contains a hard-coded IP address and port number\nRozena will make four attempts to establish a connection. The IP address was unreachable\nat the time of analysis, however.\n\n## It does not end here\n\nGiven that the IP address was not available for a connection, we might as well have stopped\nat this point. However: doing so would mean that we could not find out what Rozena can do\nto an infected machine. In order to proceed with the analysis, we set up a test environment.\nSince the IP address and port number were hard-coded in the shellcode, we just modified it\nto point to an internal dummy server for the sole purpose of continuing the analysis. This is\nthe only modification done in the whole script for further analysis. We also destroyed the\nmodified malware after the test so it will not find its way into anyone’s malware collection.\n\nFigure 14: Established connection to dummy server\n\n\n-----\n\nOnce the connection between the server and the infected machine is established, it is now\nready to receive files from the server that will be allocated in the memory and be executed.\n\nFigure 15: Metasploit framework Reverse TCP connection\n[The series of code above is from the Metasploit framework that creates a reverse TCP](https://en.wikipedia.org/wiki/Metasploit_Project#Payloads)\nconnection. In a reverse TCP connection, the infected machine will open the port that the\nserver will connect to. This is mostly used by backdoor malware since it bypasses firewall\nrestrictions on open ports.\n\nFigure 16: Established connection to infected machine seen in Metasploit\nThe infected machine is now connected to the dummy server that uses Kali Linux\nenvironment with Metasploit Framework. It uses meterpreter to craft and send files to the\ninfected machine or any other commands shown below\n\n\n-----\n\nFigure 17: Meterpreter commands\nTo be infected by a backdoor malware and looking on the few commands above that can be\nused to compromise the system is no doubt terrifying. It can literally do anything with the\ninfected machine, the files, be familiar with the system and infecting its network. This poses a\nlot of security threats and can cause huge amount of damage. Now that Rozena follows the\nfileless trail, its stealthy way of delivering and executing its malicious activity intensifies.\n\n## Prevention\n\nAs the world changes, malware authors adapt and make use of built-in legitimate tools for\ntheir infection that might leave us defenseless. But there is always a way to shield ourselves\nfrom these types of attack.\n\n1. Keep operating systems and software up-to-date, including security updates. Especially\nknowing that older systems have numerous vulnerabilities that can be exploit and be use for\nthe infection.\n\n2 It is strongly advised to download save or execute files from known and trusted sources\n\n\n-----\n\nmalware authors still use traditional arrival vector to lure users for executing malicious files.\nIf disabling system tools especially PowerShell is not an option, you will find some alternative\nways to configure PowerShell to prevent malicious script execution.\n\n3. Set [PowerShell Constrained Language Mode – this will limit the capability of PowerShell](https://blogs.msdn.microsoft.com/powershell/2017/11/02/powershell-constrained-language-mode/)\nby removing advanced feature such as .Net and Windows API calls, since most PowerShell\nscripts rely on these parameters and methods.\n4. [Pairing PowerShell with AppLocker – this will prevent unauthorized binary file from being](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker)\nexecuted.\n\n## IOC list & information for fellow researchers\n\nExecutable File (masks as Microsoft Word):\nc23d6700e93903d05079ca1ea4c1e36151cdba4c5518750dc604829c0d7b80a7\n\nCreated File (filename Hi6kI7hcxZwU):\nd906dc14dae9f23878da980aa0a3108c52fc3685cb746702593dfa881c23d13f\n\nConnected to remote server: 18[.]231[.]121[.]185[:]443\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-06-29 - Where we go, we don't need files- Analysis of fileless malware -Rozena-.pdf"
    ],
    "report_names": [
        "2018-06-29 - Where we go, we don't need files- Analysis of fileless malware -Rozena-.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535754,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653701200,
    "ts_modification_date": 1653701200,
    "files": {
        "pdf": "https://archive.orkl.eu/8de669d11832d0f3e93043edecd3cd8a2a1c4eb9.pdf",
        "text": "https://archive.orkl.eu/8de669d11832d0f3e93043edecd3cd8a2a1c4eb9.txt",
        "img": "https://archive.orkl.eu/8de669d11832d0f3e93043edecd3cd8a2a1c4eb9.jpg"
    }
}