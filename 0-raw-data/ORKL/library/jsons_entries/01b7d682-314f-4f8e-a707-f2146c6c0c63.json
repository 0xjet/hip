{
    "id": "01b7d682-314f-4f8e-a707-f2146c6c0c63",
    "created_at": "2023-01-12T15:04:56.655794Z",
    "updated_at": "2025-03-27T02:05:55.287143Z",
    "deleted_at": null,
    "sha1_hash": "52776ac8a65ef261aa7ffb385f17a274c40c6216",
    "title": "2021-01-27 - How We Hacked Azure Functions and Escaped Docker",
    "authors": "",
    "file_creation_date": "2022-05-28T15:17:05Z",
    "file_modification_date": "2022-05-28T15:17:05Z",
    "file_size": 845751,
    "plain_text": "# How We Escaped Docker in Azure Functions\n\n**[intezer.com/blog/research/how-we-hacked-azure-functions-and-escaped-docker/](https://www.intezer.com/blog/research/how-we-hacked-azure-functions-and-escaped-docker/)**\n\nWritten by Paul Litvak - 27 January 2021\n\n### Get Free Account\n\nJoin Now\n\n### Top Blogs\n\n\nJanuary 27, 2021\n\n\n**[Elephant Framework Delivered in Phishing Attacks Against Ukrainian Organizations](https://www.intezer.com/blog/research/elephant-malware-targeting-ukrainian-orgs/)**\n\nA recently developed malware framework called Elephant is being delivered in targeted\nspear phishing campaigns... [Read more](https://www.intezer.com/blog/research/elephant-malware-targeting-ukrainian-orgs/)\n\n**[Make your First Malware Honeypot in Under 20 Minutes](https://www.intezer.com/blog/malware-analysis/how-to-make-malware-honeypot/)**\n\nA “honeypot” is a metaphor that references using honey as bait for a lure or... [Read more](https://www.intezer.com/blog/malware-analysis/how-to-make-malware-honeypot/)\n\n**[Detection Rules for Sysjoker (and How to Make Them With Osquery)](https://www.intezer.com/blog/incident-response/detection-rules-sysjoker-osquery/)**\n\n\n-----\n\nOn January 11, 2022, we released a blog post on a new malware called SysJoker.... Read\nmore\n\nSummary of Findings\n\nWhat is Azure Functions?\n\nTechnical Analysis\n\nProof of Concept\n\nWhy Does this Matter?\n\n## Summary of Findings\n\n[In previous months we identified vulnerabilities in Microsoft Azure Network Watcher and](https://www.intezer.com/blog/cloud-security/cve-2020-16995-microsoft-azure-network-watcher-linux-extension/)\n[Azure App Services, leading us to investigate other types of Azure compute infrastructure.](https://www.intezer.com/blog/cloud-security/kud-i-enter-your-server-new-vulnerabilities-in-microsoft-azure/)\n[We found a new vulnerability in Azure Functions, which would allow an attacker to](https://azure.microsoft.com/en-us/services/functions/)\n**escalate privileges and escape the Azure Functions Docker container to the Docker**\n**host.**\n\nWe reported the vulnerability to Microsoft’s security team. They have determined the issue\nhas no security impact on Azure Functions users. Although it is possible to escape from the\nfunction to the host, the Docker host itself is protected by a Hyper-V boundary. Based on\nour findings Microsoft has made changes to block /etc and /sys directories since this\nchange has already been deployed.\n\nInstances like this underscore that vulnerabilities are sometimes out of the cloud user’s\ncontrol. Attackers can find a way inside through vulnerable third-party software. While you\nshould focus on reducing the attack surface as much as possible, you also need to prioritize\nthe runtime environment to make sure you don’t have any malicious code lurking in your\nsystems.\n\n## What is Azure Functions?\n\nAzure Functions is a serverless compute service that allows users to run code without\nhaving to provision or manage infrastructure. Azure Functions is Microsoft’s equivalent to\n[Amazon Web Services’ well-known Lambda service.](https://aws.amazon.com/lambda/)\n\nAzure Functions can be triggered by HTTP requests and are meant to run for only a few\nminutes in order to handle the event. Behind the scenes, the user’s code is run on an\nAzure-managed container and served without requiring the user to manage their own\ninfrastructure. In other words, if the user wants to take a shortcut they can, since it’s\nexpected that Microsoft will do it for them. This code is segmented securely and is not\nintended to escape from its confined environment. However, we will soon demonstrate\nwhy this is not the case.\n\n\n-----\n\nWe created a demonstration of the vulnerability—mimicking an attacker having execution\non Azure Functions and escalating privileges to achieve a full escape to the Docker host.\nCheck it out below.\n\nWatch Video At:\n\nhttps://youtu.be/YXIf3Xl1eZ8\n\n## Technical Analysis\n\nAn Azure function requires no infrastructure management. It’s triggered by a user merely\nuploading their code, which enables seamlessly calling the Function. In our example, it’s\n[invoked via HTTP: https://test11114117.azurewebsites.net](https://test11114117.azurewebsites.net/)\n\n_Figure 1: Example_\n\n_Azure Function handler code_\n\nAs the user can upload any code of their choice, we abused this to gain a foothold over the\nFunction container and further understand its internals. We wrote a reverse shell to connect\nto our control server once the Function was executed, so that we could operate an\ninteractive shell.\n\n\n-----\n\n_Figure 2: Azure Function reverse shell_\nOnce the shell was on our Function we noticed that we were running as a unprivileged ‘app’\nuser in an endpoint with a ‘SandboxHost’ hostname:\n\n_Figure 3:_\n\n_Connecting to the Function reverse shell_\nThe environment was mostly sterile from utilities, so we added several useful tools—most\nnotably nmap—to our Function directory and then reuploaded the new Function package.\n\nUsing nmap, we scanned localhost to familiarize ourselves with the server. As a result we\nspotted multiple open ports:\n\n\n-----\n\n_Figure 4: Running nmap on an Azure Function_\n\n## Escalating Privileges\n\nSince our goal was to find an elevation of privilege vulnerability, it was important that we\nfind sockets belonging to processes associated with root. After interrogating network-related\n/proc files, we were able to map the ports to their corresponding processes:\n\n_Figure 5: Mapping each open port to the process that owns it_\n\n\n-----\n\n[We found three privileged processes with an open port. The first was NGINX, a thoroughly](https://www.nginx.com/)\ntested open-source project. The local NGINX version had no known vulnerabilities so this\nwouldn’t have helped us.\n\nThe MSI and Mesh processes offered better chances at finding potential problems as they\nare close-sourced, undocumented Microsoft processes. As such, we were confident that\nthey had been less thoroughly tested.\n\nMSI, Managed Service Identity, a feature of the serverless model, eliminates the user’s\nneed to manage identities, easing development by letting Azure handle it instead.\n\nAs for the Mesh binary, we couldn’t find much information (it’s unrelated to Azure’s Fabric\nMesh service which has a similar name).\n\nUnfortunately, the binaries belonging to the two processes reside in root-owned directories\n(e.g. /root/mesh/init) and we didn’t have access to them.\n\nThe Mesh process seemed to be less documented and also very relevant for our purposes,\nso we focused our efforts on finding out what this component does.\n\nAfter searching for references to the Mesh binary in Google, we found the questioned\n[“/root/mesh/init” path in the build log of a public Docker image in Docker Hub belonging to a](https://hub.docker.com/layers/balag0/km/2/images/sha256-69b1fa875e4e67232364c8b25b3f803633fc82226a1ae65b61a5ce3530dc0625?context=explore)\nMicrosoft employee (we deduced this was public on purpose because it’s used internally\nsomehow).\n\nWe downloaded the image, created a container with it and extracted the Mesh Init binary.\nThe binary was compiled from a Go codebase and conveniently for our purposes wasn’t\nstripped.\n\nImmediately as we opened the binary in IDA we noticed some interesting functions:\n\n\n-----\n\n_Figure 6: Mesh binary_\n\n_mount functions_\nPerforming a mount is a privileged operation and should our unprivileged user access this\nfunctionality through the HTTP server, it could result in privilege escalation.\n\nWith this goal in mind and after some reverse engineering, we found the HTTP paths and\nvariables that would allow us to invoke these functions. The server expected an HTTP\nvariable to specify an operation to invoke:\n\nAt first we attempted to use the mount_RunCifs and mount_RunZip commands, however,\nwe had no success as the system was lacking binaries for these functions to actually work.\nWe had hoped that the third time would be the charm as we looked at mount_RunSquash:\n\n\n-----\n\n_Figure 7:_\n\n_mount_RunSquash function disassembly_\n[The RunSquash function would simply invoke squashfuse_ll (in the](https://github.com/vasi/squashfuse)\ninit_server_pkg_mount_runSquashInternal function) to mount the given squashfs image in\nthe path supplied by “filePath” HTTP variable onto the path specified by the “targetPath”\nHTTP variable.\n\n[With this information, we built our own squashfs filesystem containing only a single file that](https://tldp.org/HOWTO/SquashFS-HOWTO/whatis.html)\n[would grant our unprivileged app user root permissions using the sudoers mechanism.](https://linux.die.net/man/5/sudoers)\n\n_Figure 8: Creating the_\n\n_sudoers file on our own server_\n\n\n-----\n\n_Figure 9: Creating the squashfs image on our own server for the exploit_\n\nWe included this file in our new Function image and instructed the server to mount our evil\nsquashfs image over /etc/sudoers.d. This granted root to our unprivileged user:\n\n_Figure 10: Escalating to root_\n\n## Escaping Docker\n\nWe were able to escalate to root! However, we were still confined to our container. This new\nfreedom was still somewhat limiting but nonetheless an upgrade to a bigger “cage.”\n\nEscalating to root within a container is a remarkable achievement, yet escalating privileges\nwithin containers is not the final destination for an attacker. Compromising the Docker host\nwould give them much more control, allowing them to break away from the container which\nmight be monitored and moving to the Docker host which is often neglected in terms of\nsecurity. Containers are often scraped for unnecessary items which the attacker might find\ninteresting, so escalating to the Docker host could allow them to gather more compromising\nleads to incite further damage.\n\n[It’s a known bad practice to host containers with the ––privileged flag, or to grant them non-](https://containerjournal.com/topics/container-security/why-running-a-privileged-container-is-not-a-good-idea/)\ndefault capabilities, since this nullifies Docker’s security features. Seeing as Azure\nFunctions’ core is its container the first thing we did once we had execution over the\n\n\n-----\n\nFunction was to check what capabilities our container had been granted. This can be\nachieved by reading a process’s status file in the /proc directory:\n\n_Figure 11: Azure Function process capabilities_\n\nThe Cap fields relate to a Linux capability mechanism. We won’t go into detail but decoding\nthe Cap bitmap allows us to list the process’s capabilities, which all processes in the\ncontainer share:\n\n_Figure 12: Decoding Function process capabilities_\n\nWe were very surprised to discover that Azure Functions ran with several extra capabilities.\nWith these extra capabilities it was clear that the container was run with the ––privileged\nflag.\n\nThis by itself would not have helped us initially, since we only had access to an unprivileged\nuser, and the Docker escape techniques available in this scenario required root. This all\nchanged once we found the Privilege Escalation vulnerability.\n\nUsing a [known Docker escape technique we ran ‘ps’ on the Docker host:](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)\n\n\n-----\n\n_Figure 13: Running `ps` on the Docker Host_\n[In a nutshell, the technique we used—discovered by Felix Wilhem—abuses a feature within](https://twitter.com/_fel1x/status/1151487051986087936)\ncgroups and allows calling a binary on the Docker host (only with the SYS_ADMIN\ncapability as given by the ––privileged flag). In our PoC, we instructed the system to run the\n‘ps’ command and redirect its output to our containerized filesystem.\n\nOnce we have achieved execution on the Docker host we reported our findings to Microsoft.\nAfter assessment they have decided not to fix the bug, as they claim it does not impact\nsecurity. The reason for this is because the Docker host is not the final host by itself. This\n“host” was managed by HyperV (Virtual Machine Manager) and protected by its sandbox,\ntherefore our container was essentially a box within a box. This Docker host only contains\nour own Docker container, and it’s this real host that manages shared infrastructure\nbetween different Azure Functions belonging to various Azure customers, which we were\nnot able to access.\n\n## Proof of Concept\n\nTo make reproduction easier for those who would like to probe the Docker host\nenvironment, we’ve created an easy to run PoC. It contains instructions on how to upload\nan Azure Function with a reverse shell so that you can probe the Docker host yourself and\n[perhaps find some use out of it. It’s available on GitHub.](https://github.com/tsarpaul/Azure-Functions-EoP-PoC)\n\n\n-----\n\n## Why Does this Matter?\n\nNo matter how hard you work to secure your own code, sometimes vulnerabilities are out of\nyour control. It’s critical that you have protection measures in place to detect and terminate\nwhen the attacker executes unauthorized code in your production environment. This Zero\nTrust mentality is even echoed by Microsoft.\n\n## Try our Free Community Edition\n\n[Cloud Workload Protection Platforms (CWPP) like Intezer Protect monitor the runtime](https://www.intezer.com/)\nenvironment to detect and terminate any unauthorized code execution following a\nvulnerability exploitation or other attack vector.\n\nIntezer Protect defends the cloud-native stack—including VMs, containers and container\norchestration platforms—against the latest threats. You’ll want to know what code is running\n[in your production environments at all times. The community edition is a quick way to get](http://protect.intezer.com/signup)\nthis visibility.\n\n[Get Started for Free](http://protect.intezer.com/signup)\n\nIf you’re not ready to deploy, we also have a lab environment where you can simulate\n[attacks such as backdoors, malware, and Living off the Land (LotL) threats. Contact us to](https://www.intezer.com/contact-us/)\naccess this environment.\n\n**Paul Litvak**\nPaul is a malware analyst and reverse engineer at Intezer. He previously served as a\ndeveloper in the Israel Defense Force (IDF) Intelligence Corps for three years.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-27 - How We Hacked Azure Functions and Escaped Docker.pdf"
    ],
    "report_names": [
        "2021-01-27 - How We Hacked Azure Functions and Escaped Docker.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535896,
    "ts_updated_at": 1743041155,
    "ts_creation_date": 1653751025,
    "ts_modification_date": 1653751025,
    "files": {
        "pdf": "https://archive.orkl.eu/52776ac8a65ef261aa7ffb385f17a274c40c6216.pdf",
        "text": "https://archive.orkl.eu/52776ac8a65ef261aa7ffb385f17a274c40c6216.txt",
        "img": "https://archive.orkl.eu/52776ac8a65ef261aa7ffb385f17a274c40c6216.jpg"
    }
}