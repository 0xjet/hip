{
    "id": "ce2925e4-6530-4377-9e59-6076286275bb",
    "created_at": "2023-01-12T15:09:10.149708Z",
    "updated_at": "2025-03-27T02:05:19.10613Z",
    "deleted_at": null,
    "sha1_hash": "5107e2ae13f5145669c098c14b63ec97652dcfc2",
    "title": "Running ELF executables from memory",
    "authors": "",
    "file_creation_date": "2022-05-01T14:12:44Z",
    "file_modification_date": "2022-05-01T14:12:44Z",
    "file_size": 123539,
    "plain_text": "# Running ELF executables from memory\n\n**guitmz.com/running-elf-from-memory**\n\nGuilherme Thomazi March 27, 2019\n\n### 7 minute read  Published: 27 Mar, 2019\n\n Executing ELF binary files from memory with memfd_create syscall\n\n Something that always fascinated me was running code directly from memory. From Process Hollowing (aka RunPE) to PTRACE injection. I had some success playing around with it in\n```\nC in the past, without using any of the previous mentioned methods, but unfortunately the\n\n code is lost somewhere in the forums of VXHeavens (sadly no longer online) but the code was buggy and worked only with Linux 32bit systems (I wish I knew about shm_open back then, which is sort of an alternative for the syscall we are using in this post, mainly targeting older systems where memfd_create is not available).\n\n## Overview and code\n\n### Recently, I have been trying to code in assembly a bit, I find it very interesting and I believe every developer should understand at least the basics of it. I chose FASM as my assembler because I think it is very simple, powerful and I like its concepts (like same source, same output). More information about its design can be found here. Anyway, I have written a small tool, memrun, that allows you to run ELF files from memory using the memfd_create syscall, which is available in Linux where kernel version is >= 3.17 .\n\n What happens with memfd_create is that it acts like malloc syscall but will return a file descriptor that references an anonymous file (which does not exists in the disk) and we can pass it to execve and execute it from memory. There are a couple in-depth articles about it around the internet already so I will not get too deep into it. A nice one by magisterquis can be found at his page\n\n The assembly code might look too big but there are some things we need to take care in this case that we don’t need to when writing in a HLL like Go (as you can see in its example below). Also it’s nice if you want to use the code for an exploit, you can just adjust the assembly instructions to your needs. Both examples are for x86_64 only:\n\n```\n\n-----\n\n```\nformat ELF64 executable 3\ninclude \"struct.inc\"\ninclude \"utils.inc\"\nsegment readable executable\nentry start\nstart:\n;----------------------------------------------------------------------------; parsing command line arguments\n;---------------------------------------------------------------------------- pop  rcx            ; arg count\n cmp  rcx, 3          ; needs to be at least two for the self program\narg0 and target arg1\n jne  usage           ; exit 1 if not\n add  rsp, 8          ; skips arg0\n pop  rsi            ; gets arg1\n mov  rdi, sourcePath\n push rsi            ; save rsi\n push rdi\n call strToVar\n pop  rsi            ; restore rsi\n pop  rdi\n mov  rdi, targetProcessName\n pop  rsi            ; gets arg2\n push rdi\n call strToVar\n;----------------------------------------------------------------------------; opening source file for reading\n;---------------------------------------------------------------------------- mov  rdi, sourcePath      ; loads sourcePath to rdi\n xor  rsi, rsi         ; cleans rsi so open syscall doesnt try to use it\nas argument\n mov  rdx, O_RDONLY       ; O_RDONLY\n mov  rax, SYS_OPEN       ; open\n syscall             ; rax contains source fd (3)\n push rax            ; saving rax with source fd\n;----------------------------------------------------------------------------; getting source file information to fstat struct\n;---------------------------------------------------------------------------- mov  rdi, rax         ; load rax (source fd = 3) to rdi\n lea  rsi, [fstat]       ; load fstat struct to rsi\n mov  rax, SYS_FSTAT      ; sys_fstat\n syscall             ; fstat struct conntains file information\n mov  r12, qword[rsi + 48]   ; r12 contains file size in bytes (fstat.st_size)\n;----------------------------------------------------------------------------; creating memory map for source file\n;---------------------------------------------------------------------------- pop  rax            ; restore rax containing source fd\n mov  r8, rax          ; load r8 with source fd from rax\n mov  rax, SYS_MMAP       ; mmap number\n\n```\n\n-----\n\n```\n mov  rdi, 0           ; operating system will choose mapping destination\n mov  rsi, r12          ; load rsi with page size from fstat.st_size in\nr12\n mov  rdx, 0x1          ; new memory region will be marked read only\n mov  r10, 0x2          ; pages will not be shared\n mov  r9, 0           ; offset inside test.txt\n syscall             ; now rax will point to mapped location\n push rax            ; saving rax with mmap address\n;----------------------------------------------------------------------------; close source file\n;---------------------------------------------------------------------------- mov  rdi, r8          ; load rdi with source fd from r8\n mov  rax, SYS_CLOSE      ; close source fd\n syscall\n;----------------------------------------------------------------------------; creating memory fd with empty name (\"\")\n;---------------------------------------------------------------------------- lea  rdi, [bogusName]     ; empty string\n mov  rsi, MFD_CLOEXEC     ; memfd mode\n mov  rax, SYS_MEMFD_CREATE\n syscall             ; memfd_create\n mov  rbx, rax         ; memfd fd from rax to rbx\n;----------------------------------------------------------------------------; writing memory map (source file) content to memory fd\n;---------------------------------------------------------------------------- pop  rax            ; restoring rax with mmap address\n mov  rdx, r12         ; rdx contains fstat.st_size from r12\n mov  rsi, rax         ; load rsi with mmap address\n mov  rdi, rbx         ; load memfd fd from rbx into rdi\n mov  rax, SYS_WRITE      ; write buf to memfd fd\n syscall\n;----------------------------------------------------------------------------; executing memory fd with targetProcessName\n;---------------------------------------------------------------------------- xor  rdx, rdx\n lea  rsi, [argv]\n lea  rdi, [fdPath]\n mov  rax, SYS_EXECVE      ; execve the memfd fd in memory\n syscall\n;----------------------------------------------------------------------------; exit normally if everything works as expected\n;---------------------------------------------------------------------------- jmp  normal_exit\n;----------------------------------------------------------------------------; initialized data\n;----------------------------------------------------------------------------segment readable writable\nfstat       STAT\nusageMsg     db \"Usage: memrun <path_to_elf_file> <process_name>\", 0xA, 0\nsourcePath    db 256 dup 0\ntargetProcessName db 256 dup 0\nbogusName     db \"\", 0\nfdPath      db \"/proc/self/fd/3\", 0\nargv       dd targetProcessName\n\n```\n\n-----\n\n```\npackage main\nimport (\n     \"fmt\"\n     \"io/ioutil\"\n     \"os\"\n     \"syscall\"\n     \"unsafe\"\n)\n// the constant values below are valid for x86_64\nconst (\n     mfdCloexec = 0x0001\n     memfdCreate = 319\n)\nfunc runFromMemory(displayName string, filePath string) {\n     fdName := \"\" // *string cannot be initialized\n     fd, _, _ := syscall.Syscall(memfdCreate, uintptr(unsafe.Pointer(&fdName)),\nuintptr(mfdCloexec), 0)\n     buffer, _ := ioutil.ReadFile(filePath)\n     _, _ = syscall.Write(int(fd), buffer)\n     fdPath := fmt.Sprintf(\"/proc/self/fd/%d\", fd)\n     _ = syscall.Exec(fdPath, []string{displayName}, nil)\n}\nfunc main() {\n     lenArgs := len(os.Args)\n     if lenArgs < 3 || lenArgs > 3 {\n          fmt.Println(\"Usage: memrun process_name elf_binary\")\n          os.Exit(1)\n     }\n     runFromMemory(os.Args[1], os.Args[2])\n}\n\n### The full code for both versions can be found in this repo: https://github.com/guitmz/memrun\n\n## See it in action\n\n### Allow me to show it in action. Let’s start by creating a simple target file in C, named\ntarget.c . The file will try to open itself for reading and if it can’t, it will print a message\n\n forever every 5 seconds. We will execute it from memory:\n\n```\n\n-----\n\n```\n#include <stdio.h>\n#include <unistd.h>\nint main(int argc, char **argv)\n{\n printf(\"My process ID : %d\\n\", getpid());\n FILE *myself = fopen(argv[0], \"r\");\n if (myself == NULL) {\n    while(1) {\n        printf(\"I can't find myself, I must be running from memory!\\n\");\n        sleep(5);\n    }\n } else {\n    printf(\"I am just a regular boring file being executed from the disk...\\n\");\n }\n return 0;\n}\n\n### Now we build target.c :\n$ gcc target.c -o target\n\n We should also build our FASM or Go tool, I will use the assembly one here:\n$ fasm memrun.asm\nflat assembler version 1.73.04 (16384 kilobytes memory, x64)\n4 passes, 1221 bytes.\n\n Running the file normally gives us this:\n$ ./target\nMy process ID : 4944\nI am just a regular boring file being executed from the disk...\n\n But using memrun to run it will be totally different:\n$ ./memrun target MASTER_HACKER_PROCESS_NAME_1337\nMy process ID : 4945\nI can't find myself, I must be running from memory!\nI can't find myself, I must be running from memory!\n\n Furthermore, if you look for its pid with ps utility, this is what you get:\n$ ps -f 4945\nUID    PID PPID C STIME TTY   STAT  TIME CMD\nguitmz  4945 4842 0 15:31 pts/0  S+   0:00 MASTER_HACKER_PROCESS_NAME_1337\n\n Finally, let’s check the process directory:\n\n```\n\n-----\n\n```\n$ ls l /proc/4945/{cwd,exe}\nlrwxrwxrwx 1 guitmz guitmz 0 Mar 27 15:38 /proc/4945/cwd ->\n/home/guitmz/memrun/assembly\nlrwxrwxrwx 1 guitmz guitmz 0 Mar 27 15:38 /proc/4945/exe -> /memfd: (deleted)\n\n### Note the /memfd: (deleted) part, no actual file in disk for this process :)\n\n For those who know, this can be an interesting technique to run stealthy binaries in Linux, you can go even further by giving it a proper name (like a real Linux process) and detach it from the tty and change its cwd with some simple approches. Tip: fork is your friend :)\n\n TMZ\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/System Components and Abuse/Running ELF executables from memory.pdf"
    ],
    "report_names": [
        "Running ELF executables from memory.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536150,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1651414364,
    "ts_modification_date": 1651414364,
    "files": {
        "pdf": "https://archive.orkl.eu/5107e2ae13f5145669c098c14b63ec97652dcfc2.pdf",
        "text": "https://archive.orkl.eu/5107e2ae13f5145669c098c14b63ec97652dcfc2.txt",
        "img": "https://archive.orkl.eu/5107e2ae13f5145669c098c14b63ec97652dcfc2.jpg"
    }
}