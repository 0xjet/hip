{
    "id": "510986d6-e4f0-4dc2-ae71-d07ce2ff5b5b",
    "created_at": "2023-02-02T02:08:51.832723Z",
    "updated_at": "2025-03-27T02:13:34.632766Z",
    "deleted_at": null,
    "sha1_hash": "f6ca207dbb573c1d854dc3429888dcfdb90d1cfe",
    "title": "2023-01-16 - Dancing With Shellcodes- Analyzing Rhadamanthys Stealer",
    "authors": "",
    "file_creation_date": "2023-02-01T07:48:35Z",
    "file_modification_date": "2023-02-01T07:48:35Z",
    "file_size": 419932,
    "plain_text": "# Dancing With Shellcodes: Analyzing Rhadamanthys Stealer\n\n**[elis531989.medium.com/dancing-with-shellcodes-analyzing-rhadamanthys-stealer-3c4986966a88](https://elis531989.medium.com/dancing-with-shellcodes-analyzing-rhadamanthys-stealer-3c4986966a88)**\n\nEli Salem January 16, 2023\n\n[Eli Salem](https://elis531989.medium.com/?source=post_page-----3c4986966a88--------------------------------)\n\nJan 16\n\n\n20 min read\n\n## Threat Background\n\nRhadamanthys is a newly emerged Information-Stealer that is written in C++. according to\nmultiple reports[1] the malware has been active since late 2022.\n\nIn addition, the malware appears to masquerade itself as legitimate software such as\nAnyDesk installers[2], and Google Ads[3][13] to get the initial foothold.\n\nAs for usage, in the dark web, the malware authors offer various deals for using the malware\nsuch as monthly or even lifetime payments.\n\nRhadamanthys\nAlso, the authors emphasize the malware's capabilities ranging from stealing digital coins,\nand system information collection, to execution of other processes such as Powershell.\n\nIn this article, I will investigate the Rhadamanthys stealer and reverse engineer the entire\nchain, from the first dropper to the malware itself.\n\n\n-----\n\nAs always, I will do it in a hybrid step-by-step tutorial and an actual presentation and will\nfocus on the parts that I personally find more interesting(the ways the malware tries to evade\ndetection).\n\n1.\n2.\n3.\n\n## The Dropper\n\nFile hash: 89ec4405e9b2cab987f2e4f7e4b1666e\n\nThe dropper\nThe Rhadamanthys’s dropper is a 32-bit file and similar to many droppers, it has relatively\nlarge entropy which indicates potentially packed content inside of it.\n\nOne of the relatively new features of PEstudio is the ability to check if the ASLR[4] feature is\nenabled. In my analysis, I always prefer to disable the ASLR so the addresses in IDA and in\nXDBG will be the same for tracking purposes.\n\nIn PEstudio, go to “optional-header” and then to the ASLR bar, then you can see under the\n“detail” column if it is false (disabled) or true (enabled).\n\nCheck ASLR\n\n## Unpacking mechanism: getting to the first shellcode\n\nAs we observe the dropper in IDA, we see a large embedded “blob” in the .rdata section.\nUsually, these kinds of blobs can potentially contain data that will be decrypted during\nruntime.\n\nBlob\nThe first activity the dropper do is to create a new heap\n\nCreating new heap\nThen, the function sub_408028 will be the core function that will deal with encrypting the\nblob. Inside sub_408028, there are two interesting functions:\n\n1. - this function is responsible for returning an address containing the data to be written.\n2. - a wrapper of memcpy\n\nIn the first iteration, the embedded blob will be written into the newly created heap\n\nDecrypting the shellcode\nNext, the same function will override the blob and will decrypt a shellcode.\n\n\n-----\n\nDecrypting the shellcode\nThen, a call to VirtualAlloc will happen to create a newly allocated memory followed by\nmemcpy to copy the shellcode from the heap to the new memory. Lastly, a VirtualProtect API\ncall will be used to change the permission of the memory segment to RWX.\n\nDecrypting the shellcode\nThe entire chain can also be seen in the following pseudo-code of IDA pro:\n\nDecrypting the shellcode\nThe next thing we’ll do is go to the address 004065A1 in the WinMain function (remember,\nASLR is disabled so we can navigate easily in IDA and the debugger).\n\nWe could see that the value of the shellcode (that is dynamically located in the EAX register)\nis being transferred to another offset variable 42F6F0.\n\nAssign the shellcode address\n\n## Shellcode execution via Callback\n\nAfter having a shellcode with EXECUTE permission, we need a way to execute it, in this\ncase, the authors choose a cool trick in form of a Callback function.\n\nThe shellcode execution will go as the following:\n\n1. The function is responsible to invoke the API call\n2. receives as a parameter function named which is just a wrapper for another function\n\nthat jumps to the shellcode address\n3. The final result is that will get the address of the shellcode in its second argument “lpfn”\n\nand will execute it.\n\nImmEnumInputcontext function in Microsoft documentation\nThe logic can be seen in the following pseudo-code\n\nShellcode execution\nThe reason for choosing this way is most likely to evade anti-virus products that rely on\n_CreateThread \\ CreateRemoteThread as a trigger point to scan addresses that may contain_\nmalicious content.\n\nShellcode entry point\n\n## Investigating the first shellcode\n\nTo investigate the shellcode we can choose one of the two:\n\n1. Dump the entire allocated buffer and run it in Blobrunner[5]\n\n\n-----\n\n2. Continue with the code dynamically (because why not?)\n\nTo investigate it statically, we obviously must dump the shellcode, to do it do the following:\n\n1. Right click on the address of the shellcode and click “Follow in Memory Map”\n\nGoing to the memory map\n2. Then, in the memory map, right click on the shellcode address and then “Dump Memory to\nFile”\n\nDumping the shellcode\nThen, drag and drop the dumped file in IDA.\n\nTo summarize the steps until now see the following graph\n\n## Fixing the shellcode: Defining functions\n\nAfter the shellcode was loaded, we can see 5 functions that appear in the Function name\nbar. In addition, in the navigation bar, we can see the colors blue and brown.\n\nAccording to the IDA website[6] blue means “Regular functions, i.e. functions not recognized\nby FLIRT or Lumina.”\n\nAnd brown means “Instructions(code) not belonging to any functions. These could appear\nwhen IDA did not detect or misdetected function boundaries, or hint at code obfuscation\nbeing employed which could prevent proper function creation. It could also be data\nincorrectly being treated as code.”\n\nAnd when we look at an area in the IDA view that contains both we see the following:\n\nDefining functions\nWe can obviously see that the brown color is a legit code, however, IDA doesn't consider it\nas a code and therefore does not show it as a function.\n\nTo fix this, we can just scroll and observe statically from where this function starts and when\nit ends.\n\nIn our case, it starts at the address 000029E, we also see the prologue:\n\n_push ebp mov ebp, esp_\n\nAnd ends at the address 000036B with the epilogue:\n\n_leaveretrn_\n\nDefining functions\nNow that we know the function boundaries, we can mark it all, and click “P”\n\nDefining functions\n\n\n-----\n\nThen, we can see that the brown code is now considered a function, and a new function\n_sub_29E was added to the function name bar._\n\nDefining functions\n**NOTE: When fixing functions do not assume that the first “retrn” is the end of a function, pay**\nattention to the jumps that might bypass this return and might indicate a longer function.\n\n## Fixing the shellcode: Defining code\n\nIn addition to the convenient scenario of a code that looks like code and just doesn't interpret\nas a function, we have a more tricky scenario when we need to change the data itself.\n\nAt the beginning of the shellcode, we can see dynamically the assembly code “call 450028”\nthat suppose to take us to the address in 450028 which starts with “pop eax” and eventually\ncalls to the function in the address 45029E which in our case called sub_29E.\n\nHowever, as we can see, statically we just see jibberish and it does not look like the dynamic\nview.\n\nDefining as code\nTo fix it, we need to tell IDA that some specific addresses are actual code.\n\nFor example: in the dynamic view, we can see that the first 5 bytes are:\n\n_Call 450028_\n\nTherefore, we should tell IDA that the first 5 bytes are code, then, we can tell IDA to look at it\nas a function.\n\nTo do it, do the following:\n\n1. Mark the data\n2. Right click\n3. Click on “Undefine”\n\nDefining as code\nThen, mark the 5 bytes and tell IDA to look at it as Code.\n\nDefining as code\nDefining as code\nAfter doing it, we can see that the same data looks like the code from the debugger view\n\nDefining as code\nAnd as said, we can always turn it into a function of its own (because why not?)\n\nDefining as function\n\n\n-----\n\nAs we see, the function jumps to the address at _loc_28 (IDA) or_ _450028 (debugger),_\nhowever in IDA this content also needs to be fixed. Combining the two approaches of\ndefining as code and defining as function can fix will do the trick.\n\nDefining as code and defining as function\nAfter doing that, we now have 8 functions in the function name bar.\n\nFunction bar\n\n## Fixing the shellcode: Rebase the address\n\nThe last thing we need to do if we want to properly analyze the shellcode alongside the\ndebugger is to match the addresses. To do it do the following:\n\n1. Go to Edit\n2. Segments\n3. Rebase program\n\nRebase\n4. Change the value to the value of the actual entry point of the shellcode in the debugger\n\n5. Click OK\n\nRebase\nAnd now we can see that the addresses statically and dynamically the same\n\nRebase\nFinally, we can start and actually analyze the shellcode\n\n## Shellcode functionality\n\nThe first thing we can see is that the actual code in shellcode is very small, there are 8\\9\nfunctions, and the rest is a big chunk of data. From this, we can assume that the shellcode\nwill potentially use that data.\n\nSo let's “go with the flow” and understand this shellcode\n\n1. just jumps to\n2. jump jumps to\n\n_sub_45029E is a larger function that contains multiple functions._\n\nShellcode functionality\n**sub_450249This function access the Process Environment Block to get the address of**\n_Kernel32.dll. This behavior is traditional and happens in many shellcodes._\n\n\n-----\n\nGet kernel32 address\n**sub_45036EThis function gets 3 arguments**\n\n1. Kernel32 address\n2. Hashes\n3. An array that holds 4 functions\n\nIt then iterates through the kernel32 export functions and sends the names of the functions to\nanother function named sub_45040C. The only job of sub_45040C is to hash the function\nname it receives and return the hash.\n\nHashing function\nThen, sub_45036E checks if the hashed function name matches the hash it got as an\nargument, if yes, it puts it in the array and sends it back tosub_45029E.\n\nOverall the functions will be “VirtualAlloc, LocalFree, LocalAlloc, VirtualFree”\n\n**sub_450077**\n\nThis function will decrypt the large data that is stored in our shellcode, and write it to the\nLocalAlloc we saw. This beginning of the decrypted data will look like this\n\nDecrypting data\nNext, in the address 00450314, we can see the call for VirtualAlloc, don't forget to observe\nthe allocated memory using follow in dump of the EAX register (in my case it's 00470000).\n\nshellcode functionality\n**sub_45003A**\n\nThis function will happen several times and it is basically a memcpy that copies data from\none variable to the other.\n\ncopy function\n_sub_45003A will get the decrypted content and our newly allocated memory as arguments_\nand will copy the data to it.\n\ncopied data\nAnd finally, in the address 00450365, we have a “call ebx” that will take us into this our\nallocated memory in the offset 5BAB, and as we can see, it's also another shellcode.\n\nJump to another shellcode\n\n## Summarize the first shellcode\n\nTo summarize the entire shellcode activity, we can look at it from a code point of view\n\nShellcode functionality\nAnd from the following graph's point of view\n\n\n-----\n\nSecond shellcode decryption\n\n## The second shellcode aka Rhadamanthys loader\n\nThe main objective of this shellcode is to be the actual loader of the Rhadamanthys stealer.\nThis shellcode has multiple evasion capabilities and we will observe some of them.\n\n**Note- In a similar way to the first shellcode, some fixes are needed.**\n\n## Evasion Technique: Multiple Anti-Analysis\n\nThe Rhadamanthys loader contains large anti-analysis checks stolen from the al-khaser\nproject[7]. This project was also used in the Bumblebee malware.\n\nSome of the checks are checking for a virtual environment\n\nAnti-analysis checks\nAnti-analysis checks\nChecks for specific users that could hint about a lab environment\n\nAnti-analysis checks\nCheck for security-related DLLs\n\nAnti-analysis checks\nAt this point, it will be useless to continue writing the anti-analysis capabilities, so for those\nwho want to see all, please visit the al-khaser project GitHub page.\n\n## Evasion Technique: Manipulate Exception Handling\n\nOne of the most interesting capabilities of the Rhadamanthys loader is exception-handling\nmanipulation.\n\n**What is Exception handling?**\n\nAccording to Microsoft’s documentation[9]: “Structured exception handling (SEH) is a\nMicrosoft extension to C and C++ to handle certain exceptional code situations, such as\nhardware faults, gracefully.”\n\nThe SEH is basically a linked list that has two pointers:\n\n1. A pointer to the next SEH record\n2. A pointer to the function that contains the code to deal with the error\n\nExamples of errors are division by 0, and excessive string length.\n\n\n-----\n\nMicrosoft allows programmers to create their own exception handlers in order to manage\nerrors by themselves.\n\n**How the loader uses it?**\n\nFirst, the loader gets the address of ZwQueryInformationProcess, then it saves it on another\nvariable. Eventually, we enter the function named sub_5978.\n\nGetting ZwQueryInformationProcess\nIn sub_5978, the loader gets the address of KiUserExceptionDispatcher and starts to iterate\non it to search for a specific location where ZwQueryInformationProcess is called.\n\nIterating in\nIn sub_5A5C the loader set the hook in the desired location of the call to\n_ZwQueryInformationProcess_\n\nPatch\n**So how the change looks like?**\n\nIn the following image, we can see the call to ZwQueryInformationProcess that happens\ninside KiUserExceptionDispatcher from Ntdll as part of KiUserExceptionDispatcher's\nlegitimate behavior.\n\nAfter the change, we can see that the call was replaced to jump to a function in the loader\nthat will perform the ZwQueryInformationProcess and will modify the ProcessInformation flag\nto be 6D or MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE.\n\n**Why does this flag matters?**\n\nThis flag determines whether to allow execution outside the memory space of the loaded\nmodule. In other words, it enables exception handling to be performed on shellcode.\n\n**So how the exception handling will be managed?**\n\nWithout being noticed, the initial dropper has registered an SEH record in the process\nmemory with the name _except_handler3. Therefore, every exception that will be triggered\nby the shellcode will go there and will be managed by whatever logic the author decided.\n\nThis activity is most likely done to avoid raising suspicions if errors or exceptions anomalies\nwill trigger.\n\nThe entire activity can be seen in the following graph\n\nManipulating the SEH\n\n## Evasion Technique: Avoiding error message\n\n\n-----\n\nAfter controlling the exceptions, the loader will use the API call SetErrorMode with 0x8003 as\nan argument, this argument consists of the following three:\n\n1. - The system does not display the critical-error-handler message box. Instead, the\n\nsystem sends the error to the calling process.\n2. — The system does not display the Windows Error Reporting dialog.\n3. — The OpenFile function does not display a message box when it fails to find a file.\n\nInstead, the error is returned to the caller.\n\nIn other words, the loader doesn't want the system to display any error on the screen, and\nwants to handle them by himself.\n\nSimilar to controlling the exception handling, this is another maneuver of the loader to not\nraise any suspicions.\n\nsetErrorMode\n\n## Evasion Technique: Creating Mutex and impersonating a legitimate\n\nThe loader continues with creating a Mutex with the name that starts with\n“Global\\MSCTF.Asm.{digits}”.\n\nCreating Mutex\nNote that mutexes with this name are already found in the OS and are created by MSCTF.dll,\nand more info can be found in this[10] article.\n\nAfter creating the Mutex, we moved to a function named sub_2B92 which holds the core\nactivity and the main purpose of the loader.\n\n## Evasion Technique: Disabling hooks\n\nIn the function named sub_8060, we see one of the cool tricks of malware to protect\nthemselves against user mode hooking.\n\nIt first gets a handle to ntdll.dll and loads it to virtual memory, then, the loader gets the handle\nof the real ntdll.dll that is already loaded.\n\nCheck for hooks\nIt will then copy the bytes of the SYSCALL of ZwProtectVirtualMemory into another virtual\nmemory in order to use it without explicitly using the ZwProtectVirtualMemory in ntdll address\nspace.\n\n\n-----\n\nThen, it will get the export table of both real and fake modules and will iterate on them. They\nwill be compared using memcmp, and if they will found different, the loader will change the\nprotection of the real function of ntdll and will use memcpy to copy the data from the fake to\nthe real one. In this way, the malware verifies that no hooks are set.\n\nCheck for hooks\nIf we inspect it dynamically, this is a normal state when two functions are compared. We can\nsee that the virtual address is different but the bytes are the same\n\nCheck for hooks\nFor learning purposes, I changed the first byte of the real function to start with E9. Then, the\nloader took us to the memcpy function that copied the data from the fake to the real to\ncorrect the change I made.\n\nDisable hooks\nExcept for ntdll.dll, the loader will check the following DLLs:\n\n1.\n2.\n3.\n\nCheck for hooks in other DLLs\nThe entire activity can be seen in the following graph (Was lazy so I just copy paste this from\nmy previous blob)\n\nCheck for hooks logic\n\n## Config Decryption\n\nThe config decryption occurs in a function named sub_3DD4, which is a function that will do\nvarious activities that the main loader activity requires.\n\nIn sub_3DD4 we have two functions that will deal with the config decryption: sub_28AA and\n_sub_2911._\n\n**sub_28AA**\n\nThis function is basically just an RC4 algorithm\n\nConfig decryption\n**sub_2911**\n\nThis function is also part of the decryption algorithm\n\nConfig decryption\n\n\n-----\n\nWhen we step over sub_2911 dynamically, we can see the data that hold the encrypted\nconfig at the third argument (address 42F6F8 in my case).\n\nConfig decryption\nIn our case, we can see that the C2 will be http://185[.]209.160.99/blob/top.mp4\n\n## Network\n\nTo start the network activity, the loader first collects two key pieces of information from the\nmachine:\n\n1. The default language using\n2. The Locale using\n\nThen, the same function will start to set the user-agent to send the data to the C2 which is\nthe decrypted config we saw.\n\nCollect information about the machine\nSet the User-Agent\nTo communicate, the loader dynamically resolves multiple functions such as socket,\n_WSAIotcl, and CreateCompletionPort to use the IOCP socket model._\n\nNetwork activity\nThe loader uses WSAIoctl to invoke a handler for LPFN_CONNECTEX to use the\n_ConnectEx function._\n\nGetting ConnectEx\nEventually, the loader communicates with the APIs WSARecv & WSASend.\n\nSend & Recieve data\nIf we want to observe dynamically the data that is sent to the C2, do the following:\n\n1. Set a breakpoint at the address where is being executed\n2. Follow in dump the address of the second parameter aka\n3. This buffer is a structure, and its second parameter is a pointer to the actual buffer that\n\nis sent to the C2.\n4. To see it, just follow in dump\n\nObserving data send to the C2\nObserving data send to the C2\n\n## Loader’s goal\n\nAfter performing its various capabilities and tricks, the loader will execute its main goal.\n\n\n-----\n\n1. The loader will download a DLL from the C2\n2. Write it to the disk with the name of\n3. Spawn to execute the DLL with the export function “” which is a name of a legitimate\n\nexport function of the printui.dll.\n\nLoader goal\n\n## NSIS Module: The Rhadamanthys stealer\n\nThe Nsis module consists of two parts:\n\n1. A loader (the Nsis module before unpacking)\n2. The actual stealer\n\n## NSIS Loader\n\nThe loader is executed via a very long command that changed in every iteration\n\nNsis module command\nThe interesting thing about the NSIS loader is that there are many loaders out there, but their\ndetection rate is very low!\n\nNsis loader low detection rate\nFor the loader behavior, the NSIS loader just allocates data using LocalAlloc and copies it to\nmapped memory using MapViewOfFile and memmove. Eventually, it will jump to the\nshellcode address.\n\nLoader main goal\nDue to time constraints, I will not display this shellcode, however, it is just a small shellcode\nthat unpacks and inject into the memory the Rhadamanthys stealer itself.\n\n## Rhadamanthys stealer capabilities\n\nFinally, we arrived at the stealer himself!!!\n\n**Disclaimer: because of not abling to dynamically analyze the sample when the C2 was on, I**\nonly got the stealer from the following tria.ge sandbox link[11].\n\nAlso, for this part, I will only focus on the stealing capabilities and its targets.\n\n## Stealing KeePass passwords\n\nThe malware appears to be able to use the DLL KeePassHax[12], an open-source tool used\nto decrypt the password database.\n\n\n-----\n\nKeepass\n\n## Usage of SQLite\n\nThe malware can collect and extract data using SQLite\n\nSqlite\n\n## Target multiple browsers\n\nThe malware target the following browsers in their info-stealing activity:\n\n1. Coc CoC\n2. Pale Moon\n3. Sleipnir5\n4. Opera\n5. Chrome\n6. Twinkstar\n7. Firefox\n8. Edge\n\nBrowsers\n\n## Target OpenVPN\n\nThe malware appears to get the profile, username, and password of OpenVPN.\n\nOpenVPN\n\n## Target steam accounts\n\nThe malware appears to aim at Steam’s config\\loginusers.vdf which contains information\nabout Steam’s users.\n\nValve\n\n## Target FileZilla passwords\n\nThe malware search for FileZila’s specific files:\n\n1. recentservers.xml\n2. sitemanager.xml\n\nThese two files contain the passwords and other data of the FTP accounts.\n\n\n-----\n\nFileZilla\n\n## Target CoreFTP\n\nCoreFTP\n\n## Target Discord\n\nThe malware collects information from the discord directories, possibly to extract further\ndata.\n\nDiscord\n\n## Collecting Telegram data\n\nThe malware targets Telegram desktop data which is located in encrypted files (such as\n_D877F783D5D3EF8) in the “tdata” directory._\n\nTelegram\n\n## Collecting information from various email\n\nThe malware target the following email clients:\n\n1. Foxmail\n2. Outlook\n3. The BAT\n\nEmails\n\n## Extracting web credentials using Vaultcli functions\n\nVault activity\n\n## Target WinSCP\n\nThe malware target sensitive registry keys of the WinSCP in order to collect information.\n\nWinSCP\n\n## Target CryptoCurrency entities\n\nThe malware target the following cryptocurrencies entities and wallets:\n\n1. Dogecoin\n\n\n-----\n\n2. Litecoin\n3. Monero\n4. Qtum\n5. Armory\n6. Bytecoin\n7. Binance\n8. Electron\n9. Solar waller\n10. Zap\n\n11. WalletWasabi\n12. Zcash\n13. Ronin\n14. Avana\n15. OKX\n\nCrypto\nQuerying registry keys for digital coming entities from Joe[\n\n## Resolving APIs dynamically\n\nThe stealer is resolving dynamically his APIs using the GetModuleHandle and\nGetProcAddress API calls.\n\nDynamic resolving\n\n## Evasion technique: Modify and possibly manipulate AVAST modules\n\nThe stealer uses the same code that was used in the loader to verify and unhook functions\nand the same function appears to aim for the AVAST-related modules aswhook.dll &\n_aswAMSI.dll._\n\nCheck AVAST’s AMSI-related DLLs\nMore amsi-related functions and DLLs that are being targeted by the stealer are:\n\n1. avamsicli.dll\n2. amsi.dll\n3. AmsiScanString\n4. AmsiScanBuffer\n5. EtwEventWrite\n\nAt this stage, I decided to stop my analysis\n\nFor everyone's convenience, I also uploaded all the files from my analysis including the\nshellcodes to VirusTotal.\n\n\n-----\n\n## Rhadamanthys files\n\nhttps://www.virustotal.com/gui/file/8384322d609d7f26c6dc243422ecec3d40b30f29421210e7\nfba448e375a134f6\n\n## References\n\n[1] [https://threatmon.io/rhadamanthys-stealer-analysis-threatmon/](https://threatmon.io/rhadamanthys-stealer-analysis-threatmon/)\n\n[2] [https://mobile.twitter.com/JAMESWT_MHT/status/1610620178441568261](https://mobile.twitter.com/JAMESWT_MHT/status/1610620178441568261)\n\n[3] [https://mobile.twitter.com/1ZRR4H/status/1610590795278712832](https://mobile.twitter.com/1ZRR4H/status/1610590795278712832)\n\n[4] [https://en.wikipedia.org/wiki/Address_space_layout_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)\n\n[5] [https://github.com/OALabs/BlobRunner](https://github.com/OALabs/BlobRunner)\n\n[6] [https://hex-rays.com/blog/igors-tip-of-the-week-49-navigation-band/](https://hex-rays.com/blog/igors-tip-of-the-week-49-navigation-band/)\n\n[7] [https://github.com/LordNoteworthy/al-khaser](https://github.com/LordNoteworthy/al-khaser)\n\n[8] https://elis531989.medium.com/the-chronicles-of-bumblebee-the-hook-the-bee-and-thetrickbot-connection-686379311056\n\n[9] https://learn.microsoft.com/en-us/cpp/cpp/structured-exception-handling-c-cpp?\nview=msvc-170\n\n[10] https://www.hexacorn.com/blog/2018/12/25/enter-sandbox-part-22-ctf-capturing-thefalse-positive-artifacts/\n\n[11] [https://tria.ge/221227-vprhbsae8t/behavioral2#report](https://tria.ge/221227-vprhbsae8t/behavioral2#report)\n\n[12] [https://github.com/HoLLy-HaCKeR/KeePassHax](https://github.com/HoLLy-HaCKeR/KeePassHax)\n\n[13] [https://twitter.com/1ZRR4H/status/1614728368334716932](https://twitter.com/1ZRR4H/status/1614728368334716932)\n\n[14] [https://www.joesandbox.com/analysis/783578/0/html#](https://www.joesandbox.com/analysis/783578/0/html#)\n\n[15] https://blog.cyble.com/2023/01/12/rhadamanthys-new-stealer-spreading-through-googleads/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-16 - Dancing With Shellcodes- Analyzing Rhadamanthys Stealer.pdf"
    ],
    "report_names": [
        "2023-01-16 - Dancing With Shellcodes- Analyzing Rhadamanthys Stealer.pdf"
    ],
    "threat_actors": [
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1675303731,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1675237715,
    "ts_modification_date": 1675237715,
    "files": {
        "pdf": "https://archive.orkl.eu/f6ca207dbb573c1d854dc3429888dcfdb90d1cfe.pdf",
        "text": "https://archive.orkl.eu/f6ca207dbb573c1d854dc3429888dcfdb90d1cfe.txt",
        "img": "https://archive.orkl.eu/f6ca207dbb573c1d854dc3429888dcfdb90d1cfe.jpg"
    }
}