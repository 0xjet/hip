{
    "id": "0c7ecae2-ca28-48dc-bef4-478ed4ba0c82",
    "created_at": "2022-10-25T16:48:24.220225Z",
    "updated_at": "2025-03-27T02:10:53.331103Z",
    "deleted_at": null,
    "sha1_hash": "5a3d449416fe93ed374b4095ca574fd1a8c49df8",
    "title": "",
    "authors": "",
    "file_creation_date": "2012-07-27T09:39:48Z",
    "file_modification_date": "2012-07-27T09:39:48Z",
    "file_size": 420844,
    "plain_text": "# Baseband Attacks: Remote Exploitation of Memory Corruptions in Cellular Protocol Stacks\n\n## Ralf-Philipp Weinmann University of Luxembourg\n```\n            <ralf-philipp.weinmann@uni.lu>\n\n```\n\n## Abstract\n\nPublished attacks against smartphones have concentrated\non software running on the application processor. With\nnumerous countermeasures like ASLR, DEP and code\nsigning being deployed by operating system vendors,\npractical exploitation of memory corruptions on this processor has become a time-consuming endeavor. At the\nsame time, the cellular baseband stack of most smartphones runs on a separate processor and is significantly\nless hardened, if at all.\nIn this paper we demonstrate the risk of remotely\nexploitable memory corruptions in cellular baseband\nstacks. We analyze two widely deployed baseband\nstacks and give exemplary cases of memory corruptions\nthat can be leveraged to inject and execute arbitrary code\non the baseband processor. The vulnerabilities can be\ntriggered over the air interface using a rogue GSM base\nstation, for instance using OpenBTS together with a\nUSRP software defined radio.\n\n**Keywords: baseband security; radio firmware; mem-**\nory corruption; GSM\n\n## 1 Introduction\n\nDespite recent deployments of 4G networks, Global System for Mobile Communications (GSM) [7] still is the\nprevalent standard for cellular communications. With\nbillions of GSM handsets deployed, about 70% of all cellular connections in 2011 were estimated to have been\nperformed using GSM as bearer technology[1]. Moreover, GSM will not go away soon, as even the majority\nof Long Term Evolution (LTE) devices are backwardscompatible not only with 3G technology but with GSM\nto provide connectivity in areas lacking both 4G and 3G\ncoverage.\n\n1according to market data by Wireless Intelligence\n\n\nWhile the cryptographic algorithms A5/1 and A5/2\nused for link-level encryption of voice data in GSM have\nbeen practically broken [2, 1, 13] and interception attacks\nhave been shown to be easily possible [20, 21, 14] with\noff-the-shelf hardware, only little effort has been directed\nat researching the security of the software directly interfacing with the cellular network, the so-called cellular\nbaseband stack.\nIn the past, spoofing a GSM network required a significant investment, which limited the set of possible attackers. When GSM radio stacks were implemented, attacks\nagainst end devices were not much of a concern. Hence\nchecks on messages arriving over the air interface were\nlax as long as the stack passed interoperability tests and\ncertifications. Open-source solutions such as OpenBTS\n\n[4] allow anyone to run their own GSM network at a fraction of the cost of carrier-grade equipment, using a simple and cheap software-defined radio. This development\nhas made GSM security explorations possible for a significantly larger set of security researchers. Indeed, as\nthe reader will see in the following, insufficient verification of input parameters transmitted over the air interface\ncan lead to remotely exploitable memory corruptions in\nthe baseband stack.\nLet us briefly describe our attack scenario: The attacker will operate a rogue Base Transceiver Station\n(BTS) in vicinity to the targeted Mobile Station (MS).\nThe rogue BTS sends out system information messages\nannouncing the availability of a network that the targeted\nmobile station is willing to connect to. As the primary\ncriterion for network reception is signal strength, the attacker can force the MS to connect to its rogue base station by simply transmitting with a stronger signal than\nthe legitimate base station. This will not happen instantaneously, but the process can be sped up by using a GSM\njammer to selectively jam the frequency of the legitimate\nBTS. This scenario is very similar to the one used by\nIMSI catchers. Since GSM does not provide mutual authentication, there is no protection against fake BTSs.\n\n\n-----\n\nMobile stations come in different types: examples\nare USB data dongles providing connectivity to laptops,\ntablet devices with cellular connectivity and last but not\nleast, cellular phones. The class of cellular phones can be\ndivided into two types: so-called “feature phones” which\nonly offer their users basic functionalities such as making and receiving calls and sending and receiving text\nmessages and “smartphones” which can be considered\nas personal assistants. Smartphones allow their users to\nperform a wide variety of tasks; such as browsing the\nWeb, sending and receiving email, installing custom applications, taking pictures, shooting video, etc. Although\nthe results described in this paper may apply to all hand_sets running vulnerable protocol stacks, we made a delib-_\nerate decision to focus our research on smartphones, as\nthey are the most interesting targets for real-world attackers. Besides storing valuable personal data, smartphones\nhave become the gateway to the digital world for many\npeople. In 2011, the number of smartphones shipped surpassed the number of personal PCs and tablet PCs combined.\nA paper describing the anatomy of modern GSM telephones has been written by Welte [24]. Although the\nline drawn between smartphones and feature phones is\nfluid and shifting, we can use the following distinction in\ntheir hardware to separate the two: Feature phones only\nhave a single CPU that runs an operating system that both\ndisplays the user interface and at the same time runs the\nbaseband software stack. On the other hand, the majority\nof modern smartphones contain at least two CPUs[2], the\n_application processor, which handles the user interface_\nand runs the applications installed by the user and a second CPU, the baseband processor, that handles connectivity to the cellular network. Some smartphone designs\nuse a shared-memory architecture where the baseband\nprocessor can access all of the application processor’s\nmemory space while other designs have better isolation,\ni.e. the baseband processor and the application processor\nhave separate memories and exchange messages through\ndedicated communication channel, e.g. a serial line or a\nsmall shared-memory segment (see Figure 1).\nPublicly demonstrated attacks against smartphones\nhave concentrated on exploiting vulnerabilities in software running on the application processor.\nSpecialized knowledge and experience is required to\nimplement standards that are specified across several\nhundred documents; this is why baseband chip vendors\nusually sell their chips together with the corresponding software to drive it; this piece of software is called\nthe “baseband software stack”. Companies that currently sell GSM/3G baseband chips and stacks are: Qualcomm, Intel (formerly Infineon), Broadcom, Texas In\n2which may or may not be on the same die\n\n|Application Processor|Col2|RAM|\n|---|---|---|\n\n|Application Processor (slave)|Col2|\n|---|---|\n|||\n|RAM||\n|||\n|Digital Baseband Processor (master)||\n\n|Digital Baseband Processor|Col2|RAM|\n|---|---|---|\n||||\n\n\nstruments, ST-Ericsson, Renesas (formerly Nokia), Marvell, MediaTek, NVidia (formerly Icera), VIA Telecom\nand Spreadtrum.\nAccording to a recent market report published by\nStrategy Analytics [15], Qualcomm and Intel (using the\nComneon stack) together captured 60% of the baseband\nrevenue in 2011, hence we have contentracted our research on cellphones using these chips.\nBaseband software stacks however are less hardened\nagainst attacks than the code running on the application CPU; this can be witnessed by examining so-called\n“software unlocks” written for circumventing the network locks of Apple’s iPhone in a non-permanent manner [16]. These are local exploits executed with each\nstart-up of the telephone. They work by the application\nprocessor sending a sequence of AT commands to the\nbaseband. This sequence triggers a memory corruption\nvulnerability in the AT command interpreter of the baseband stack. Most of the vulnerabilities exploited so far\nhave been stack buffer overflows.\n\n**Our contribution** We analyze which areas of GSM\nbaseband stacks most likely contain programming errors\nleading to remotely exploitable memory corruptions. To\ndrive our point home, we describe two bugs for two vendors with a high market share that we found during our\nresearch. We discuss what difficulties had to be overcome to exploit these memory corruptions and what the\nresulting impact is.\n\n**Related Work** Mulliner, Golde and Seifert [18] systematically analyzed the resilience of a number of mobile\nphones against malformed short messages using fuzzing\nand demonstrated numerous remotely exploitable denial\nof service attacks using this vector – yet it is unclear\nwhether any of the described vulnerabilities lead to re\n\nSerial communication\n\nRAM\n\nor shared memory\n\nDigital Baseband Processor Digital Baseband\n\n(master) Processor RAM\n\n**_Shared memory architecture_** **_Baseband as modem_**\n\nFigure 1: Common architectures employed in smartphone designs\n\n\n-----\n\nmote code execution. At Black Hat 2009 Miller and\nMulliner presented a vulnerability in the SMS parsing\nfunctionality of iPhone [17] that can lead to remote code\nexecution; this attack does not require user interaction,\nbut it exploits a bug in CommCenter, which is running\non the application processor.\n\n**Structure of the paper** The paper is organized as follows: Section 2 provides some background and describes\nthe relevant aspects of GSM. Section 3 describes how we\nperformed our vulnerability analysis. Section 4 investigates the difficulty of leveraging such vulnerabilities into\nremote code execution. Section 5 gives an impact assessment of our research and Section 6 concludes this paper,\ngiving an outlook where future research in this area is\nheaded.\n\n## 2 Background\n\nUntil our first presentations in 2010, no one had demonstrated an attack resulting in remote code execution in\na baseband stack. This is moderately surprising. By\nfuzzing handsets, many crashes in the baseband stacks\ncan be found quickly. However most of these crashes\nseem to not be triggered by memory corruptions. To separate the wheat from the chaff and to leverage the inputs\nthat indeed cause memory corruptions, a deeper understanding of the baseband stack is necessary. This seems\nto have been the primary reason hindering security researchers from making progress in this area.\n\n## 2.1 Local exploits and unlocks\n\nFor years, the primary incentive driving the reverseengineering of cellphone firmwares has been the “unlock scene”. The existence of this scene is owed to the\nlock-in model many network operators employ. A socalled “network lock” causes a handset to only accept\nSIM cards of the operator selling the handset whereas\na SIM lock ties the handset to a specific SIM card (either identified by the IMSI or the ICCID). Implementing\none of these two restrictions – which are implemented\nin the baseband firmware – allows a carrier to sell the\nlocked handset for a cheaper, subsidized price. These\nbarriers have been circumvented in a number of ways:\nmissing integrity checks in bootloaders, broken integrity\nverification routines for flashing firmware updates and\nother logic errors were exploited. However, more recently memory corruption vulnerabilities (mostly stack\nbuffer overflows) in AT command parsing routines and\nthe SIM Toolkit functionality have been used to perform\nunlocks for the iPhone and Windows Mobile phones produced by HTC.\n\n\n## 2.2 GSM layers and information elements\n\nThe layering of cellular protocols does not cleanly map\nto the OSI model. The GSM protocol stack on the MS\nconsists of several layers (see Figure 2, adapted from [7])\nof which only the lowest three are considered in this paper. The physical layer (layer 1) of the air interface uses\nGaussian Minimum Shift Keying (GMSK) for modulating binary sequences and a combination of Time Division Multiple Access (TDMA), Frequency Division Multiple Access (FDMA) and frequency hopping for transmitting frames. The physical layer also implements logical signalling channels.\nThe data-link layer (layer 2) uses Link Access Procedure on Dm Channels (LAPDm) which is a simplified version of ISDN’s Link Access Protocol Channel\nD (LAPD) that has been adapted to the air interface.\nLAPDm handles transport of messages between protocol\nentities of layer 3 and signaling tasks.\nLayer 3 is significantly more complex and can be subdivided into the following sublayers (ordered from bottom to top of the stack again):\n\n_• Radio Resource Management (RR): e.g. channel_\nset-up and tear-down\n\n_• Mobility Management (MM): e.g. location updates_\n\n_• Connection Management (CM): call control (call_\nestablishment/release), supplementary services\n(e.g. USSD), SMS\n\nThe message format of layer 3 messages is specified\nin GSM 04.07 [8], the actual messages that can be exchanged are defined in GSM 04.08 [9]. A layer 3 message is composed of\n\n_• Transaction identifier or skip indicator (4 bits)_\n\n_• Protocol discriminator (4 bits)_\n\n_• Message type (8 bits)_\n\n_• Other information elements (potentially variable_\nlength)\n\nOf interest here are Information Elements (IEs), which\ncome in several flavors: V, LV, T, TV and TLV where T\ndenotes tag, L denotes length and V denotes value. The\ntypes V, T and TV are for Information Elements of fixed\nlength, whereas LV and TLV are used for information\nelements that have varying length.\n\n## 3 Vulnerability analysis\n\nCellular baseband stacks generally are not available in\nsource form for non-licensees[3]. However, in 2004 the\n\n3OsmoComBB, a project building an open-source GSM baseband\nstack for Calypso chipsets, being the exception here.\n\n\n-----\n\n**6271819#&6\":\";$ $:9& 66.** !\"#$%&'\n\n**/\"012&/$324%5$& //.**\n\n**!  & !\"#$%& .**\n\n**!\"#$%&'**\n\nFigure 2: Layers of a GSM software stack running on a\nMobile Station\n\n|<2::$5912:&6\":\";$ $:9& <6. 6271819#&6\":\";$ $:9& 66. /\"012&/$324%5$& //.|Col2|\n|---|---|\n||! & !\"#$%& .|\n||!\"#$%&'|\n\n\nsource code tree for the Vitelcom TSM30 mobile phone\nwas uploaded to a Sourceforge project [19]. Eventually it was removed, but only after having been available for download for a number of years. This source\ncode included an old version of the Condat GSM baseband stack[4] and allowed us to obtain a general understanding of the structure of cellular stacks. This knowledge proved to be very helpful for binary analysis of our\ntarget firmwares, even though these stack were written\nby completely different companies on different real-time\noperating system.\nWhen we began our analysis, we chose two example targets, namely the Apple iPhone 4 (using a Comneon stack on an Intel chip) and the HTC Dream (using a Qualcomm stack and chip). As baseband binaries\nare fairly large (multiple megabytes), we only reverseengineered the parts that we deemed interesting. For almost all smartphones, firmware updates are readily available either from the respective website of the respective\nvendor or from the website of a carrier. Most of the time\nthese updates do not only contain bug fixes or enhancements for the code running on the application CPU, but\nalso include a full baseband binary blob. To extract this\nfirmware image, it is necessary unpack – and for older\niPhones to decrypt – the firmware update. Tools and instructions on how to do this can usually be found on message boards dedicated to tinkering with the firmware of\ncellular phones. The reverse-engineering process is significantly simplified by error strings and file names of\nsource code files embedded in the binaries. These apparently are used for diagnosis on production devices using vendor applications such as Qualcomm’s QXDM and\nComneon’s Mobile Analyzer.\nAlmost all baseband processors are ARM processors\n\n4Condat was later bought by Texas Instruments. The stack can still\nbe found in their products.\n\n\nand therefore well supported by the IDA Pro disassembler. Moreover, Hex-Rays, the company producing IDA\nPro ships a decompiler for the ARM architecture that can\ngive reverse-engineers a significant speedup in analyzing\nlarger codebases such as baseband firmware images.\nFor the iPhone, a thriving scene exists that has already\nreverse-engineered parts of its baseband software to create “software unlocks”, software that is injected through\na local baseband exploit to allow to circumvent network\nlocks imposed by the carriers. Some documentation is on\nthese unlocks available in a wiki [5], a detailed description of the reverse-engineering of ultrasn0w is given in\n\n[16].\nOur main tools for identifying “interesting“ code paths\nwere IDA Pro and Google BinDiff. BinDiff allows us\nto re-identify known functions in binaries. By computing a number of metrics on the flow graphs of a function, a function “fingerprint” is obtained. A metric on\nthe function fingerprints then allows to identify “similar”\nfunctions in other binaries. “Symbol porting”, process of\nfunction re-identification, then works by observing that\nmost functions observed in the wild are equivalent when\ntheir similarity value is high enough.\nWe used BinDiff to identify functions such as\n```\nmemcpy(), memmove() and bcopy() and RTOS system\n\n```\nfunctions by using BinDiff to port symbols from several\nstandard compiler libraries and RTOS binaries with symbols. This then allowed us to identify functions that used\nvariable-length memory copies, enabling us to quickly\nsee which of them employed insufficient length checking for the data copied. In principle, IDA Pro’s FLIRT\nsignatures can be used for this purpose as well, but they\nare less flexible, since they don’t work on the flow graph\nabstraction model. For the iPhone 4 it proved to be very\nfruitful to start by analyzing the first generation iPhone\n(iPhone 2G) and identify security problems here – the\nwork can later be ported over using BinDiff, a tool described below. The advantage of this approach is that one\nhas to deal with a significantly reduced amount of functions since the iPhone 2G lacks UMTS and GPS functionality.\n\n## 3.1 Areas of interest\n\nBelow layer 3, there usually is little potential for exploitable memory corruptions, as the messages transmitted are too short. An exception to this rule are voice\ncodecs. Reading parts of the GSM layer 3 specification [9], an inclined reader finds multiple areas that look\npromising for exploitation: there are a large number of\nmessages that specify IEs to be encoded as TLV or LV,\neven though in the message description it becomes clear\nthat the values transmitted are of predefined length. This\ncan usually lead to a mismatch between different imple\n\n-----\n\nmenters and hence to the most classic of all memory corruptions, the buffer overflow. At one point there may be\na fixed-length buffer allocated, while at another point the\nmessage is copied into the buffer without making sure\nthat the message indeed is smaller than the buffer, trusting the length argument specified in the information element.\nSimilarly, many explicit state machines exist in [9],\nmany of which have state transitions depending on timer\nexpiries. As some of the state transitions involve allocation and deallocation of dynamic memory, dangling\npointers can arise if implementers are not carefully covering edge cases.\n\n## 3.2 Classification of bugs found\n\nTo get a better understanding of which parts of the cellular baseband code are most worthwhile auditing, it makes\nsense to classify the (memory corruption) vulnerabilities\nwe have found by type:\n\n**Insufficient length checks:**\nThese were by far the most common types of bugs\nwe encountered. They usually resulted in data on\nthe heap or on the stack being overwritten, which\ncan be leveraged by an attacker to gain control over\nthe execution flow using the usual methods. Exploitation of heap corruption bugs is vastly more\neasy than on current desktop platforms in these embedded systems – initially, we didn’t find a single\nexample of safe unlinking being employed in heap\nimplementations of baseband operating systems[5].\n\n**Object/structure lifecycle issues**\nDue to the generous use of state machines in GSM,\nmemory corruptions can arise out of lifecycle issues. These can be use-after-free bugs (e.g. a dangling pointer to a structure that has been deallocated already) or uninitialized variables (most useful when on the stack). Exploiting these issues can\nbe more difficult than the first kind, but given the\nfact that there are no exploitation countermeasures\nin place, they shouldn’t be easily discounted as “unexploitable”. Common examples of state machines\nare the state machine used for handling incoming\nSMSes and for Cell Broadcasts.\n\n**Integer overflows/underflows**\nWe only found a very small number of these bugs\ncompared to the other kinds. This may be either\nbecause our methods for detecting them (in binary\ncode) are not enough or because cellular code base\nis inherently less prone to these types of bugs\n\n5in reaction to our results, at least the Qualcomm modem heap now\nuses safe-unlinking, though [16].\n\n\n**Memory information leaks**\nWhilst this class of vulnerabilities is not a memory\ncorruption issue, memory information leaks can be\nhighly useful to leverage memory corruptions better. Usually, they arise in the same context as the\nlifecycle issues mentioned above, at least in baseband stacks.\n\nWe did not find any format string issues; this is not\nsurprising, given that most uses of sprintf()-like functions are in the diagnostic code and do not allow for arbitrary format strings to be passed.\n\n## 3.3 Finding insufficient length checks\n\nThe majority of bugs found where memory corruptions\nthat occurred to due insufficient checks on length fields\nbeing performed. In principle, these can be found\nby fuzzing all information elements with length fields.\nFuzzing however is a very crude method. Instead the\nmethod we employed was to look at the source code for\nthe baseband stack of the Vitel TSM30 and see which\ntypes of memory corruption problems were widespread\nin this code base. By identifying memcpy(), memmove()\nand similar memory-transfer library functions which are\ncalled with a non-constant length parameter, we identified potentially vulnerable routines and checked them individually in other baseband stacks.\n\n## 3.4 Issues with dual-mode\n\nIn baseband stacks that support both GSM and UMTS,\ncode paths between the two are often shared. This means\nthat in some instances a code path that should only be\nreachable when the device is talking to a UMTS base\nstation also is accessible using well-crafted GSM layer 3\nmessages (which of course are undefined in GSM 04.08).\nAn example of this is given in the next subsection. In\nother cases this type of bug can lead to uninitialized variables and object lifecycle issues.\n\n## 3.5 Examples of exploitable bugs found\n\n_• During the registration phase, a TMSI is assigned_\nto the handset if it has not been seen before. This\nTMSI is supposed to be always 32 bits long, but\na variable length field is used. Indeed, sending a\nlonger TMSI (e.g. 128 bytes) caused the baseband\nstack of iPhones with the Intel/Comneon to crash.\n\n_• For authentication, the base station transmits a chal-_\nlenge to the handset. In GSM, this challenge is a\n16 byte value called RAND. For UMTS a so-called\nAUTN challenge [11] is used – which is encoded as\na variable length IE, but in fact is specified to also\n\n\n-----\n\nbe be 16 bytes long. Interestingly, we were able\nto force the Qualcomm stack to accept this variable length AUTN challenge even in a GSM layer\n3 message by setting the message type to the one\nused for UMTS RANDs. This causes a classic stack\noverflow (for more than 48 bytes of AUTN), as this\nchallenge is copied to a buffer on the stack that apparently has only been provisioned for 16 byte challenges.\n\nThe above bugs are just two of many that were found;\nmore can easily be found by looking at all of the variable length information elements, sending long messages\nand subsequently locating the corresponding functions\nparsing them in the baseband firmware if the baseband\ncrashes. Alternatively, one can locate all functions that\ncopy memory and statically analyze where they are being\ncalled from – most firmware images contain debug information that allows an attacker to figure this out using the\nbinary firmware images only. We will not list all of the\nbugs that we have found in this paper as we yet have to\ndisclose them to the vendors; it currently is unclear how\nlong it takes to get them fixed. However, bear in mind\nthat the above examples barely scratch the surface.\n\n## 4 From bugs to exploits\n\nDeveloping exploits for embedded systems can be challenging if the platform is only partially understood, as is\nusually the case with large reverse-engineered code bases\nsuch as cellular protocol stacks. Moreover, debugging\ncapabilities can be very primitive if JTAG access to the\nchip has been disabled.\nHowever, to demonstrate the exploitability of a vulnerability, it is sufficient to make the phone perform an\nunexpected action: We have chosen to use the autoanswer functionality – defined in GSM specification\n07.07 (AT command set for GSM Mobile Equipment) –\nwhich makes the phone automatically pick up an incoming call without user interaction after a predefined number of rings.\nThe auto-answer feature is mandatory for cellular\nphones and enabled by sending the command ATS0=n\nover the AT command interface to the baseband; n indicates the number of rings after which the call should be\nautomatically picked up with n = 0 disabling the functionality. The above V.25ter command is a relict of the\ndays of PSTN modems; the register S0 was used to set\nthe number of rings after which a modem would pick up.\nTo enable the auto-answer in our exploit, we first locate the AT command handler for setting the S0 register.\nFor stack-buffer overflows or other exploits that give us\ncontrol over the program counter directly, we then load\nthe value 1 into register R0 and redirect the execution\n\n\nflow into this function. Depending on whether this setting is in RAM or whether it is backed by an EEPROM,\nwe either need to make sure that we continue the execution correctly or we can crash without any penalties.\nFor heap buffer overflows that result in the attacker being able to overwrite an arbitrary location in memory[6] it\nmay be easier to directly overwrite the location that is set\nin the AT command handler for S0 instead of redirecting\nthe execution flow. Alternatively, sometimes heap buffer\noverflows are followed by memory copies into a stack\nbuffer, in which case a heap buffer overflow can propagate and trigger a stack buffer overflow.\n\nFigure 3: Test setup: USRPv1, built-in FA-SY 1 module,\nlaptop running OpenBTS, test phones (Motorola Backflip, Apple iPhone 2G, HTC Dream, BlackBerry Bold\n9700)\n\n## 4.1 Our setup\n\nTo verify our research, we used a modified Ettus Research USRPv1 together with 2 RFX-900 daughterboards. Since the clock signal of the USRPv1 is imprecise (a clock drift of 20ppm is usual) and its standard reference clock of 64Mhz less suitable than a 52Mhz clock\nfor GSM (the GSM symbol rate is derived from a 13MHz\nclock), we have modified the USRP to use an an external clock and feed it clock signal produced by ClockTamer module. The USRP is connected to a Thinkpad\nX60 with a Core Duo CPU @1.6GHz that runs OpenBTS\n2.6, modified with patches to perform the exploits listed\nbelow. Figure 3 shows a picture our setup [7].\nIn our tests we did not spoof a carrier but rather operated a test network with MCC 001 and MNC 01 on a\nfrequency for which we had obtained authorization from\nthe local regulation authorities.\n\n6a so-called write 4 primitive\n7The photo shows the first generation setup, in which we were using\na FA-SY 1 module instead of a ClockTamer\n\n\n-----\n\n## 4.2 Device fingerprinting\n\nTo reliably exploit vulnerabilities in baseband stacks, it\nis useful to identify both the device and the exact version\nof the stack running on the device. This can be achieved\nin multiple ways, the easiest of which is using the International Mobile Station Equipment Identity and Software Version Number (IMEISV) [10]. The IMEISV has\nthe format AA-BBBBBB-CCCCCC-DD with decimal digits;\nthe part AA-BBBBBB designates the GSM Type Approval\nCode (TAC), CCCCCC designates the serial number of the\ndevice and DD the software version running on the device. The IMEISV can be queried by the base station\nduring the location update, allowing for targeted attacks.\nWe have modified OpenBTS to query the IMEISV during registration. TACs can be mapped to the manufacturer and model name using a TAC database. The official\ndatabase is maintained by T UV S [¨] UD BABT for the GSM[¨]\nAssociation and can not be queried by the general public. However, there exist public databases on the internet which cover a non-negligible portion of the assigned\nTAC space.\nAlternatively, memory information leaks and minor\nprotocol variations between baseband revisions could be\nused to fingerprint software versions.\n\n## 4.3 Debugging baseband stacks\n\nTo gain a better understanding of the internals of a baseband stack as well as to write proof-of-concept exploits\nit is helpful to be able to examine memory and register\ncontents at run time. In general, any debugging capabilities will greatly reduce the amount of development time\nfor any exploit.\nMost chipsets in mobile phones allow JTAG access to\nbe disabled or to be access-protected, for instance with a\nsecret key. This is done to prevent people from tampering not only with the baseband firmware but also from\nremoving SIM locks or changing the IMEI of the phone.\nWhether or not JTAG is disabled usually is left up to the\nOEM producing the phone and not to the chipset manufacturer.\nIn practice, a large number of cell phones on the market do allow JTAG access as can be witnessed from the\nlist of phones supported by dedicated cellphone repair\nboxes like the RIFF Box. Indeed, the HTC Dream we\nhave chosen as an object of study for this paper does allow JTAG access to the baseband processor. However,\nduring the boot process, JTAG access is disabled in the\nsecondary bootloader, the OSBL. The decision to disable\nJTAG is made based on a flag and can be patched out by\nsetting a breakpoint and changing the register the flag is\nloaded into, allowing us to have JTAG access to the baseband CPU at run time as well.\n\n\nA second way to debug devices with Qualcomm stacks\nis through the so called DIAG interface. This is an interface usually used for device diagnostics, however it can\nalso be used to peek and poke into memory at run time.\nGuillaume Delugr´e wrote an excellent debugger for older\nQualcomm basebands [6] that has been released as opensource software. As-is this version will only work on\npre-OKL4 chipsets. The HTC Dream on the other hand\nuses a baseband stack that runs on top of the OKL4 microkernel. This means that the DIAG task is running in\nARM user mode and hence has insufficient privileges to\naccess the needed debug registers. This situation can be\nremedied using a local privilege escalation in OKL4.\n\nOn Apple iPhones, JTAG access seems to be completely locked down. Hence, our debugging capabilities are limited. Baseband crash logs and baseband\ncrash dumps are the only debugging facilities we found\n(an example of a baseband crash log is given in Appendix B). These are copied from the iPhone to a\ncomputer during the sync process. Alternatively crash\nlogs can be obtained directly on jailbroken phones using an AT command, AT+XLOG. Baseband crash dumps\ncan be enabled by dialing *5005*CORE# in the phone\ndialer. These can be extracted from the directory\n```\n/Library/Logs/CrashReporter/Baseband on jail\n```\nbroken phones.\n\n## 4.4 Example target: HTC Dream\n\nTurning on auto-answer on the HTC Dream turned out\nto be easy once we had identified the AT command function changing the S0 register. We have written an exploit\nfor the AUTN stack buffer overflow previously described\nthat overwrites the program counter and the register R0 of\na stack frame. The program counter with the entry point\nof the S0 register handler, the register R0 with the value 1.\nSince the ring counter is only stored in volatile memory,\nwe cannot simply crash after writing this setting. Henceforth, we also needed to overwrite the program counter\nin the subsequent stack frame (which corresponds to the\nfunction that is the caller of the function corresponding\nto the stack frame we overwrote above) to make sure that\nexecution of the thread continued normally.\n\nTo execute this exploit, no modification of the\nOpenBTS code base was necessary. Rather, given this\nsingle layer 3 message – less than 100 bytes long – exploitation of the AUTN bug becomes almost trivial. This\npayload is sent to a running OpenBTS instance to the\n```\ntestcall UDP port after establishing a channel using\n\n```\nthe OpenBTS testcall command. The bug will be exploited and auto-answer enabled without the user being\nable to notice anything.\n\n\n-----\n\n## 4.5 Example target: Apple iPhone 4\n\nAuto-answer is an undocumented feature on all iPhones\nthat can be enabled by dialing *5005*AANS# in the\niPhone dialer, which in turn is translated into a ATS0=1\ncommand by CommCenter and sent to the baseband modem device. Auto-answer is a permanent setting that is\nstored in non-volatile memory on the application processor, i.e. a reboot of the iPhone/crash of the baseband\npreserves this change.\nAll iPhones except the iPhone 4 CDMA and the\niPhone 4S employ Intel (formerly Infineon) baseband\nchipsets running a Comneon stack. This stack is built on\ntop of the ThreadX RTOS for the iPhone 4[8]. The TMSI\noverflow we previously described is a heap-based overflow that allows us to overwrite an arbitrary location of\nmemory.\nWe have written a proof-of-concept exploit that\nuses malformed LOCATION UPDATING ACCEPT requests\ncontaining a TMSI that overwrites heap metadata of an\nallocation in a ThreadX memory block pool. To be\nable to send this to targets we had to slightly modify the OpenBTS code base to facilitate TMSIs longer\nthan 4 bytes. A LOCATION UPDATING REQUEST is sent\nby the phone as soon as it connects to our network to\nwhich OpenBTS will send the malformed LOCATION\n```\nUPDATING ACCEPT containing the payload. This results\n\n```\nin auto-answer to be enabled and our phone to briefly\nlose connectivity to the network.\nA more detailed description on how to exploit the\nsame bug on the iPhone 2G (which also uses a Comneon stack, but running on a different RTOS), albeit in\nan easier way, is described in [16].\n\n## 5 Impact\n\nSuccessful exploitation of memory corruption in GSM\nbaseband software stacks provides an attacker with access to privacy-relevant hardware of the telephone. Audio routing on the majority of chipsets is done on the\nbaseband CPU, which means that it has access to the\nbuilt-in microphone; similarly for built-in cameras. An\nattacker that has taken control over the baseband side of\na telephone can monitor a user completely transparently\n– without visibility of the compromise from the side of\nthe application CPU. Furthermore, given the large quantities of RAM available to the baseband on some phones,\nsurreptitious room monitoring is possible: Simply record\nthe audio from the microphone and store the compressed\naudio data to ring buffer in RAM. The payload then waits\nuntil a data connection is established and piggy-backs\nonto it, sending out the compressed recording to a server\nof its choice. A second obvious set of problems revolves\n\n8Nucleus PLUS is used for earlier models\n\n\naround billing issues: once the attacker has control over\nthe baseband he can place calls, send premium SMSes or\ncause large data transfers unbeknownst to the owner of\nthe phone. This obviously can cause problems for both\ncarriers and end-users. Compared to the above issues the\nfact that an attacker can arbitrarily and permanently brick\ndevices by writing to regions of NVRAM that contain\nimportant device data like the IMEI looks almost like a\nminor problem.\nThe impact can be even more devastating on sharedmemory designs such as the Qualcomm MSM7200 and\nsimilar platforms. On these, an ARM9 for the digital\nbaseband and an ARM11 for the application side share\nthe same memory, with the baseband core being the master. This means that no matter how well the operating\nsystem running on the application CPU is secured, bugs\nin the baseband stack with subsequent privilege escalations in OKL4 allow an attacker to take control over the\nwhole device. In designs where the application CPU and\nthe baseband CPU access separate memories the attacker\nhowever may still be able to elevate his access to the application CPU by exploiting bugs in one of the components interfacing the application processor with the baseband processor.\nForensics of volatile memory of the baseband stack is\ndifficult without leveraging another exploit – protections\nagainst unlockers have made hardware forensics such as\ndumping RAM contents of a live chip via JTAG on most\nproduction phones hard.\n\n## 6 Conclusions and Outlook\n\nWe have demonstrated that memory corruptions in baseband firmwares exist and can be practically exploited.\nThese security problems are to be taken seriously: practical exploitation of these completely compromises the\nintegrity of the attacked handset. Merely coming into\nthe proximity of a malicious base station is is sufficient\nto take over any vulnerable handset – no user interaction is required by the bugs we have outlined above. The\ncost of exploitation is low enough to make these attacks\na reality even for attackers with a limited budget: for the\nprice of a mid-range laptop – USD 1500 – an attacker\ncan buy the hardware to operate a malicious GSM cell\nwith OpenBTS.\nWe have disclosed the bugs described in this paper to\nthe affected baseband stack vendors. The TMSI overflow\nhas been assigned the CVE identifier CVE-2010-3832\nand has been fixed in the baseband firmware shipped\nwith Apple’s iOS 4.2. Although no public documentation on this matter exists, we understand that the AUTN\noverflow has been patched in Qualcomm’s tree and updates have been sent out to the OEMs. In December 2010\nwe reverse-engineered an updated baseband for the HTC\n\n\n-----\n\nDesire and confirmed that it did indeed contain a length\ncheck in the function parsing the AUTN parameter.\nWhile we did not investigate 3G stacks in detail, we\nexpect even handsets that operate in 3G-only mode to\nbe vulnerable to similar memory corruption problems –\neven though they require mutual authentication. Femtocells with modified software allow attackers to operate rogue 3G base stations [3]. The specification of the\n3GPP Radio Resource Control layer gives a significantly\nincreased attack surface: On almost 1500 pages the most\nbasic layer 3 protocol for 3GPP is defined [12]. Moreover, in contrast to the simple TLV encoding employed\nin GSM, the information elements of the RRC are ASN.1\nencoded, using Packed Encoding Rules (PER). As the\nmessage parsing functions of the RRC layer can be triggered before the authentication process has completed,\nthis gives a large attack surface.\nTo increase the security of baseband stacks, we suggest to vendors that baseband operating stacks undergo\na systematic and continuous code audit and use hardening options similar to the ones used in desktop operating\nsystems. This will make practical exploitation of security\nvulnerabilities in baseband stacks more difficult [23, 22].\nAlso, privilege-separation for establishing well-defined\nboundaries between the different portions of a baseband\nstack can be a very effective measure for making bugs\nthat can be triggered by consuming untrusted data much\nharder to exploit; this however requires a design overhaul\nof the respective baseband stack.\nWe understand that our findings have caused extensive\ncode reviews of multiple baseband stacks to happen.\n\n**Acknowledgements:** We’re grateful to Joshua Lackey\nand Harald Welte for providing detailed and thoughtful\ncomments on an early draft of the paper. Andr´e Stemper\n(University of Luxembourg) helped in practical ways by\napplying his excellent soldering skills! Without the products and support of the ex-Zynamics teams, many code\npaths would have been much harder to analyze. Planetbeing and MuscleNerd provided invaluable tips about the\niPhone 4 baseband. Last but not least, we are indebted\nto the WOOT reviewers for their constructive comments\nand to Aur´elien Francillon for being an extremely kind\nan knowledgable shepherd to this paper.\n\n## References\n\n[1] BARKAN, E., BIHAM, E., AND KELLER, N. Instant ciphertextonly cryptanalysis of GSM encrypted communication. In\n_CRYPTO 2003 (2003), D. Boneh, Ed., vol. 2729 of Lecture Notes_\n_in Computer Science, Springer, pp. 600–616._\n\n[2] BIRYUKOV, A., SHAMIR, A., AND WAGNER, D. Real time\ncryptanalysis of A5/1 on a PC. In FSE 2000 (2001), B. Schneier,\nEd., vol. 1978 of Lecture Notes in Computer Science, Springer,\npp. 1–18.\n\n\n\n[3] BORGAONKAR, R., GOLDE, N., AND REDON, K. Femtocells:\nA poisonous needle in the operators hay stack. presented at Black\nHat Las Vegas 2011, July 2011.\n\n[4] BURGESS, D. A., AND SAMRA, H. S. The Open BTS project.\n```\n  http://openbts.sourceforge.net/, Aug. 2008.\n\n```\n[5] COLLABORATIVE EFFORT. The iPhone Wiki. `http://`\n```\n  theiphonewiki.com, November 2010.\n\n```\n[6] DELUGRE´, G. R´etroconception et d´ebogage dun baseband\nqualcomm. In Symposium sur la scurit des technologies de\n_l’information et des communications (SSTIC 2012) (June 2012),_\npp. 393–411.\n\n[7] EBERSP ¨ACHER, J., V ¨OGEL, H.-J., BETTSTETTER, C., AND\nHARTMANN, C. GSM – Architecture, Protocols and Services,\n3rd ed. Wiley, 2009. ISBN 0470030704.\n\n[8] ETSI. Digital cellular telecommunications system (Phase 2+)\n(GSM); Mobile radio interface signalling layer 3;General aspects\n(GSM 04.07 version 7.3.0 Release 1998), Dec. 1999. ETSI EN\n300 940 V7.7.1.\n\n[9] ETSI. Digital cellular telecommunications system (Phase 2+)\n(GSM); Mobile radio interface layer 3 specification (GSM 04.08\nversion 7.7.1 Release 1998), Oct. 2000. ETSI EN 300 940 V7.7.1.\n\n[10] ETSI. Digital cellular telecommunications system (Phase 2+);\nNumbering, addressing and identification (3GPP TS 03.03 version 7.8.0 Release 1998), Sept. 2003. ETSI TS 100 927 V7.8.0.\n\n[11] ETSI. 3rd Generation Partnership Project; Technical Specification Group Core Network and Terminals; Mobile radio interface\nLayer 3 specification; Core network protocols; Stage 3 (Release\n8), Dec. 2008. 3GPP TS 24.008 V8.4.0.\n\n[12] ETSI. Universal Mobile Telecommunications System (UMTS);\nRadio Resource Control (RRC); Protocol specification (3GPP TS\n25.331 version 7.17.0 Release 7), July 2010. ETSI TS 125 331\nV7.17.0.\n\n[13] G ¨UNEYSU, T., KASPER, T., NOVOTN ´Y, M., PAAR, C., AND\nRUPP, A. Cryptanalysis with COPACOBANA. IEEE Transac_tions on Computers 57, 11 (2008), 1498–1513._\n\n[14] KRISSLER, S., NOHL, K., AND STEVENSON, F. A. The A5/1\nsecurity project. http://reflextor.com/trac/a51.\n\n[15] KUNDOJJALA, S. Baseband market share tracker: Qualcomm and Intel together capture 60 percent of 2011 baseband\nrevenue. http://www.strategyanalytics.com/default.\n```\n  aspx?mod=reportabstractviewer&a0=7261, April 2012.\n\n```\n[16] MILLER, C., BLAZAKIS, D., ZOVI, D. D., ESSER, S., IOZZO,\nV., AND WEINMANN, R.-P. iOS Hacker’s Handbook. Wiley,\n2012, ch. 11, p. 408.\n\n[17] MILLER, C., AND MULLINER, C. Fuzzing the\nphone in your phone. presented at Black Hat\nLas Vegas 2009, July 2009. `https://www.`\n```\n  blackhat.com/presentations/bh-usa-09/MILLER/\n  BHUSA09-Miller-FuzzingPhone-PAPER.pdf.\n\n```\n[18] MULLINER, C., GOLDE, N., AND SEIFERT, J.-P. SMS of\nDeath: From analyzing to attacking mobile phones on a large\nscale. In USENIX Security Symposium 2011 (2011), USENIX\nAssociation.\n\n[19] PURPLELABS. TSM30 firmware. `http://web.archive.`\n```\n  org/web/20060627121308/http://sourceforge.net/\n\n```\n`projects/plabs, Nov 2004.` Sourceforge project has been\ndeleted.\n\n[20] STEVENSON, F. A. [A51] The call of Kraken. Mailing list\npost: `http://lists.lists.reflextor.com/pipermail/`\n```\n  a51/2010-July/000683.html, July 2010.\n\n```\n[21] THE AIRPROBE TEAM. AirProbe – an air-interface analysis tool\nfor GSM. http://www.airprobe.org.\n\n\n-----\n\n[22] THE PAX TEAM. Documentation for the PaX project: Adress\nSpace Layout Randomization design & implementation. http:\n```\n  //pax.grsecurity.net/docs/aslr.txt, Apr. 2003.\n\n```\n[23] THE PAX TEAM. Documentation for the PaX project: Nonexecutable pages design & implementation. `http://pax.`\n```\n  grsecurity.net/docs/noexec.txt, May 2003.\n\n```\n[24] WELTE, H. Anatomy of contemporary GSM cellphone\nhardware. `http://laforge.gnumonks.org/papers/gsm_`\n```\n  phone-anatomy-latest.pdf, Apr. 2010.\n\n## A Example stack overflow: AUTN stack buffer overflow, Qualcomm stacks\n\n```\ncopy_auth_IE:\nPUSH  {R3-R7,LR}\nMOVS  R7, R0\nMOVS  R6, R1\nMOVS  R5, R2\nMOVS  R0, #0\nSTRB  R0, [R5]\nMOVS  R4, #0\nLDR   R0, =unk_17695952\nLDRB  R1, [R0]\nCMP   R1, #0\nBLS   j_exit_loop\n\nfalse\n\nj_loop_over_IEs:\nLDR   R2, =unk_17884340\nLSLS  R0, R4, #3\nADDS  R1, R0, R2\nLDRB  R1, [R1,#4]   ; check type of IE\nCMP   R1, #0\nBEQ   j_is_GSM_RAND  ; GSM RAND?\n\nfalse true\n\n172501FC:\nCMP   R1, #0x20    ; UMTS RAND?\nBEQ   j_is_UMTS_RAND\n\nj_is_GSM_RAND:\nMOVS  R1, #0x10    ; store constant len (16)\nSTRB  R1, [R6]\nLDR   R1, [R2,R0]\n\nfalse true MOVS  R2, #0x10    ; len = 16\n\nADDS  R1, R1, #1\nADDS  R0, R6, #1\nBLX   memcpy     ; constant len copy\nB    j_continue\n\n17250200:\nCMP   R1, #0xF0    ; key seq # true true\nBNE   j_continue\n\nj_is_UMTS_RAND:\nLDR   R1, [R2,R0]\nLDRB  R1, [R1,#1]\nSTRB  R1, [R5]    ; copy length from IE\n\nfalse LDR   R0, [R2,R0]MOVS  R2, R1     ; R2 = len\n\nADDS  R0, R0, #2\nMOVS  R1, R0     ; R1 = src\nADDS  R0, R5, #1   ; R0 = dest\nBLX   memcpy     ; unbounded memcpy() !\n\n17250204:\nLDR   R0, [R2,R0]\nLDRB  R0, [R0]\nLSLS  R0, R0, #0x1C true\nLSRS  R0, R0, #0x1C  ; mask lower nibble\nSTRB  R0, [R7]\nB    j_continue\n\nj_continue:\nADDS  R4, R4, #1\nLSLS  R4, R4, #0x18\nLSRS  R4, R4, #0x18\nLDR   R0, =unk_17695952\nLDRB  R0, [R0]\nCMP   R4, R0\nBCC   j_loop_over_IEs\n\nfalse\n\nj_exit_loop:\nMOVS  R0, #1\nPOP   {R3-R7,PC}\n\nFigure 4: Disassembly of a vulnerable routine handling\n```\nAUTHENTICATE REQUEST taken from HTC Dream radio\n\n```\nfirmware version 2.22.23.02\n\n\nFigure 5: Baseband crash log of an iPhone 4 running\nbaseband revision 01.59.00, triggered by a long TMSI in\na LOCATION UPDATING ACCEPT message\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.usenix.org/system/files/conference/woot12/woot12-final24.pdf"
    ],
    "report_names": [
        "woot12-final24.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "88854a9f-641a-4412-89db-449b4d5cbc51",
            "created_at": "2022-10-25T16:07:23.963599Z",
            "updated_at": "2025-03-27T02:02:10.051548Z",
            "deleted_at": null,
            "main_name": "Operation HangOver",
            "aliases": [
                "Monsoon",
                "Operation HangOver",
                "Viceroy Tiger"
            ],
            "source_name": "ETDA:Operation HangOver",
            "tools": [
                "AutoIt backdoor",
                "BADNEWS",
                "BackConfig",
                "JakyllHyde",
                "TINYTYPHON",
                "Unknown Logger",
                "WSCSPL"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3c5b0e7e-2388-4b63-9b97-6b027bec4bf7",
            "created_at": "2023-01-06T13:46:39.068694Z",
            "updated_at": "2025-03-27T02:00:02.989445Z",
            "deleted_at": null,
            "main_name": "Calypso",
            "aliases": [
                "BRONZE MEDLEY"
            ],
            "source_name": "MISPGALAXY:Calypso",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "13d9c5fc-af82-4474-90dd-188c4e40a399",
            "created_at": "2022-10-25T16:07:23.435079Z",
            "updated_at": "2025-03-27T02:02:09.800346Z",
            "deleted_at": null,
            "main_name": "Calypso",
            "aliases": [
                "Bronze Medley"
            ],
            "source_name": "ETDA:Calypso",
            "tools": [
                "Agent.dhwf",
                "Byeby",
                "Calypso RAT",
                "DCSync",
                "Destroy RAT",
                "DestroyRAT",
                "DoublePulsar",
                "EternalBlue",
                "EternalRomance",
                "FlyingDutchman",
                "Kaba",
                "Korplug",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "NBTscan",
                "OS_Check_445",
                "PlugX",
                "Quarks PwDump",
                "RedDelta",
                "SAMRID",
                "Sogu",
                "SysInternals",
                "TCP Port Scanner",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Whitebird",
                "Xamtrav",
                "ZXPortMap",
                "nbtscan",
                "netcat"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041453,
    "ts_creation_date": 1343381988,
    "ts_modification_date": 1343381988,
    "files": {
        "pdf": "https://archive.orkl.eu/5a3d449416fe93ed374b4095ca574fd1a8c49df8.pdf",
        "text": "https://archive.orkl.eu/5a3d449416fe93ed374b4095ca574fd1a8c49df8.txt",
        "img": "https://archive.orkl.eu/5a3d449416fe93ed374b4095ca574fd1a8c49df8.jpg"
    }
}