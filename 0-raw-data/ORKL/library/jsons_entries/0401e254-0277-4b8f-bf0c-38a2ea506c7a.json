{
    "id": "0401e254-0277-4b8f-bf0c-38a2ea506c7a",
    "created_at": "2023-01-12T15:09:36.672325Z",
    "updated_at": "2025-03-27T02:05:29.435471Z",
    "deleted_at": null,
    "sha1_hash": "ac9fae862e35e915c0820059aef7237397b49260",
    "title": "2020-08-18 - UPX Anti-Unpacking Techniques in IoT Malware",
    "authors": "",
    "file_creation_date": "2022-05-29T10:50:11Z",
    "file_modification_date": "2022-05-29T10:50:11Z",
    "file_size": 1333194,
    "plain_text": "# UPX Anti-Unpacking Techniques in IoT Malware\n\n**cujo.com/upx-anti-unpacking-techniques-in-iot-malware/**\n\n\nAugust 17, 2020\n\n\n-----\n\nAll posts\nAugust 17, 2020\n\nAttackers are always at the forefront of inventing new techniques to stay covert. It comes by\nno surprise that their tradecraft is also subject to continuous improvement and development.\nOne interesting facet of their tactics is how they are utilizing binary packing. Packing plays an\nimportant part in evasion and covert deploying of malicious binaries:\n\nIt helps attackers to avoid endpoint anti-virus detection software when deploying the\nmalicious binary to the target device\n\n\n-----\n\nPacking reduces the size of the binary on disk and in transit significantly: this comes\nhandy, when low visibility is required from the attacker’s side or for instance, an exploit\nkit requires small binaries to be delivered, otherwise it would break, and crooks would\nnot be able to disseminate malicious binaries properly\nPacking also enables to hide plain-text strings seen normally in the binary, throttling the\nanalysis that defenders may do on the binary\n\n## A Primer on Packing\n\nThere are commonly four packer types that we distinguish, but oftentimes the boundary\nbetween these might be thin. These are:\n\nCompressors: greatly reduces the size of the binary\nCryptors: using cryptographic algorithm to obfuscate the contents of the binary\nProtectors: used widely as copyright protection, for ex.: Virtual machine (VM)-based\ndigital rights and copy protection\nInstaller: binary wrapped around an installer for easy installment\n\nThere are many ways of identifying packed binaries:\n\nExamining visual representation of the binary: to explore similarities by visualizing\ncertain byte patterns of the binary; other application of it is to spot important\nstructures in the binary or to analyze given file formats in order to better understand it\nNon-standard section names\nSection with both Writable and Execute permissions may be a possible sign of a\npacker\nAddress of entry point somewhere else, then in the first section\nPresence of certain function calls\nIncreased entropy: taking the frequency of each byte value that are present in\neach block or section, then applying a certain entropy formula to calculate entropy\nscores for given sections: higher entropy scores may indicate the presence of\nencryption or packing\nVery few imports and very few recognizable strings\nUsing file identification tools (file, trid, etc..)\n\n### Unpacking mechanism\n\nA simple routine stub code is embedded into the now packed binary, that also acts as the\nentry point. As it starts running, it will allocate a new memory region in which it unpacks the\noriginal code. Then the program code jumps to the Original Entry Point (OEP) and continues\nwith the execution of the original, unpacked program.\n\n## UPX\n\n\n-----\n\nOne of most known packers is [UPX. It is an open-source implementation of an advanced file](https://en.wikipedia.org/wiki/UPX)\ncompressor, supporting lots of executable types, Linux and Windows too. Over the years,\nUPX has been judged both as a legitimate and a gray zone tool, as both innocent and\nmalicious programs like to use and abuse it commonly.\n\nUPX has been abused in a few different ways for many years:\n\nUse of Vanilla UPX: malware developers just take the original UPX compressor and\napply it to their malware. Easy to unpack, either automatically or manually.\nUse of Vanilla UPX, then the packed binary is hex modified: from an attacker\nperspective, the goal is to break automatic unpacking by modifying some hex bytes.\nThis will break the automatic upx –d unpacking method. Some of the most common\nmodifications include:\nRewriting the UPX! magic headers\nELF magic bytes are modified\nCopyright string is modified\nSection header names are modified\nExtra junk bytes added throughout the binary\nCustom UPX: since UPX is open source, anyone can go and look at its source code\non Github and modify certain methods or re-write complete functions. Once\nthe custom UPX program code is compiled, and then applied to a malicious binary,\nthere is no way to get a full picture and understand its custom functions or modified\nroutines right off the bat. Our only resort to understand the mechanism of the\ncustom packing is to manually reverse engineer it.\n\n## UPX Header Structures Abused\n\nSince it was not an easy task to find abused, malicious packed binaries to every plot, we\ncreated skeleton, packed programs, that will raise different error messages on different\nabuse scenarios, to try to emulate all exceptions:\n\np_info corrupted\n\n\n-----\n\nl_info corrupted\n\np_info corrupted\n\nIn order to understand what each of these corruption means, we need to dig further down\nand try to understand how the UPX header builds up after packing. We will find valuable\n[information in the open source project’s source code, inside linux.h:](https://github.com/upx/upx/blob/d7ba31cab8ce8d95d2c10e88d2ec787ac52005ef/src/stub/src/include/linux.h)\n\n\n-----\n\nstruct b_info _// 12-byte header before each compressed block_\n{\n\nuint32_t sz_unc; // uncompressed_size\nuint32_t sz_cpr; // compressed_size\nunsigned char b_method; // compression algorithm\nunsigned char b_ftid; // filter id\nunsigned char b_cto8; // filter parameter\nunsigned char b_unused; // unused\n\n};\n\nstruct l_info _// 12-byte trailer in header for loader (offset 116)_\n{\n\nuint32_t l_checksum; // checksum\nuint32_t l_magic; // UPX! magic [55 50 58 21]\nuint16_t l_lsize; // loader size\nuint8_t l_version; // version info\nuint8_t l_format; // UPX format\n\n};\n\nstruct p_info _// 12-byte packed program header follows stub loader_\n{\n\nuint32_t p_progid; // program header id [00 00 00 00]\nuint32_t p_filesize; // filesize [same as blocksize]\nuint32_t p_blocksize; // blocksize [same as filesize]\n\n};\n\nSo, each of these structs store important information for the packer to work properly, so when\nthe unpacking method is initiated, the target program is uncompressed as intended. If the\ncorresponding hex values to these structs are altered, we will get the previously seen error\nmessages.\n\n## Rundown\n\nNow that we have an understanding how the fields and structures build up, let’s look at an\nexample where UPX has been abused in some way or shape. Looking at the following hash:\n\nbc88a57e1203f5eec08d34b59d9de43fa121f9d92cc773c17ebfbe848a2f88cd\n\n\n-----\n\nPacked malware UPX header\n\nPacked malware UPX trailer\n\nWe need to focus on the underlined hex values. The trained eye will immediately spot\nthat at 0x98, the UPX! Magic header has been altered with the hex bytes of YTS. That is part\nof the l_info structure. If we go further and try to match the bytes with the previously shown\ncode structure, it is clear that “20 08” is the loader size. 0D is the version info and 0C should\nbe the UPX format. Right after l_info structure is the p_info structure at 0xA0. From the\nsource code we know that p_progid should be “00 00 00 00″. After that\ncomes p_filesize and p_blocksize, both storing the same size value, but in our case, it has\nbeen altered and erased. Fortunately, the value for the filesize and blocksize is also stored\nat 0x5C80, which is “58 B2 00 00”. We just need to put this value\ninto p_filesize and p_blocksize. The values at these 3 offsets should always be the same.\nWe also see in the trailer section that the string YTS appears twice. We also need to alter\nthese back to UPX! (55 50 58 21). The trailer section also contains “0D 0C” again, which is\nthe version and format info from the l_info.\n\nWe looked at l_info and p_info, but still have not touched b_info. Actually, there\nare two b_info structures in a UPX packed binary, one for the compressed target program\nand one for the compressed part of the loader itself.\n\n[If we look inside i386-linux.elf-entry.S (ELF x86), we will find that the offset of the first](https://github.com/upx/upx/blob/master/src/stub/src/i386-linux.elf-entry.S)\nstruct b_info for the compressed program is given in .long O_BINFO. The other b_info for\nthe compressed part of the loader, is located soon after the instruction call unfold near the\nlabel main:, reached from _start.\n\nOffset of the first struct b_info for the compressed program\n\n\n-----\n\nWe can even debug the whole process and find the exact offsets by uncommenting the\nseen int3 instruction and recompiling the UPX binary. Once we debugged a sample file and\nfound the offsets, we can make note of them and see the corresponding hex values:\n\nUncomment the int3 instruction to manually debug\n\nThe first b_info struct at 0x118\n\nThe second b_info struct at 0x559A\n\nThe b_method and the b_ftid must be the same for all b_info in the same file. There is a\nquick way to gain that information out of a binary, by running upx ––fileinfo on a sample,\npacked binary.\n\nUPX fileinfo argument\n\nWe have yet to see values for b_info being altered in the wild, but this might be\nanother abuse surface for UPX packed binaries at later stages. Currently, the most prevalent\nUPX abuses are alteration of l_info and p_info.\n\nLet’s summarize our findings of values for the structures in detail:\n\n\n-----\n\nOnce we put those in, our UPX packed binary now successfully unpacks.\n\n## Mozi\n\nLet’s look at another example: Mozi is one of the prevalent IoT malware families in 2020. It is\na perfect example for p_info alteration, as UPX packed Mozi binaries have been observed to\ncome with 0 value of the p_filesize and p_blocksize fields. This will defeat automatic\nunpacking, and in order to get the unpacked binary, we would need to figure out the\ncorrect values of these fields. Employing what we learned previously we quickly find the\ncorresponding filesize values in the trailer, and we can add that into p_info: “E1 A6 1E 00”\n\n\n-----\n\nAn example of employing UPX header corruption and erased p_filesize and p_blocksize fields\n\nAfter fixing the corrupted UPX header and the values of p_filesize and p_blocksize\n\n## Manual Unpacking from radare2\n\nWhere the automatic unpacking does not work with upx –d tool, even after fixing all the\nmentioned discrepancies and modified fields, we may attempt to manually extract the\nunpacked executable image from memory, like the following:\n\n### Resources:\n\n[https://github.com/upx/upx](https://github.com/upx/upx)\n[https://github.com/radareorg/radare2](https://github.com/radareorg/radare2)\n[https://github.com/upx/upx/issues/389](https://github.com/upx/upx/issues/389)\n\n\n-----\n\n[https://github.com/upx/upx/blob/master/src/stub/src/i386-linux.elf-entry.S](https://github.com/upx/upx/blob/master/src/stub/src/i386-linux.elf-entry.S)\n[https://github.com/upx/upx/blob/master/src/stub/src/amd64-linux.elf-entry.S](https://github.com/upx/upx/blob/master/src/stub/src/amd64-linux.elf-entry.S)\n\n### Appendix\n\nAppendix A\n\nAppendix B\n\n\n-----\n\nAppendix C\n\nUsed malware hash for analysis:\n\n_bc88a57e1203f5eec08d34b59d9de43fa121f9d92cc773c17ebfbe848a2f88cd_\n\n[Special thanks to @unixfreaxjp for his previous research on ELF packing.](https://twitter.com/unixfreaxjp)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-18 - UPX Anti-Unpacking Techniques in IoT Malware.pdf"
    ],
    "report_names": [
        "2020-08-18 - UPX Anti-Unpacking Techniques in IoT Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536176,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1653821411,
    "ts_modification_date": 1653821411,
    "files": {
        "pdf": "https://archive.orkl.eu/ac9fae862e35e915c0820059aef7237397b49260.pdf",
        "text": "https://archive.orkl.eu/ac9fae862e35e915c0820059aef7237397b49260.txt",
        "img": "https://archive.orkl.eu/ac9fae862e35e915c0820059aef7237397b49260.jpg"
    }
}