{
    "id": "87188311-c62a-43c6-a68b-64c4122272de",
    "created_at": "2023-01-12T15:08:22.363593Z",
    "updated_at": "2025-03-27T02:05:27.129951Z",
    "deleted_at": null,
    "sha1_hash": "ef82d766e6ece08f3dd98b2889d622ba2bf79002",
    "title": "2022-01-21 - Analysis of Xloader’s C2 Network Encryption",
    "authors": "",
    "file_creation_date": "2022-05-29T01:11:26Z",
    "file_modification_date": "2022-05-29T01:11:26Z",
    "file_size": 1726939,
    "plain_text": "# Analysis of Xloader’s C2 Network Encryption\n\n**zscaler.com/blogs/security-research/analysis-xloaders-c2-network-encryption**\n\n## Introduction\n\nXloader is an information stealing malware that is the successor to Formbook, which had been sold in hacking forums since early 2016.\nIn October 2020, Formbook was rebranded as Xloader and some significant improvements were introduced, especially related to the\ncommand and control (C2) network encryption. With the arrival of Xloader, the malware authors also stopped selling the panel’s code\ntogether with the malware executable. When Formbook was sold, a web-based command and control (C2) panel was given to\ncustomers, so they could self-manage their own botnets. In 2017, Formbook’s panel source was leaked, and subsequently, the threat\nactor behind Xloader moved to a different business model. Rather than distributing a fully functional crimeware kit, Xloader C2\ninfrastructure is rented to customers. This malware-as-a-service (MaaS) business model is likely more profitable and makes piracy more\ndifficult.\n\nThe capabilities of Xloader include the following:\n\nSteal credentials from web browsers and other applications\nCapture keystrokes\nTake screenshots\nSteal stored passwords\nDownload and execute additional binaries\nExecute commands\n\nPrevious blog posts have analyzed various aspects of Formbook and Xloader’s obfuscation. In this blog post, we perform a detailed\nanalysis of Xloader’s C2 network encryption and communication protocol. Note that Xloader is cross-platform with the ability to run on\nMicrosoft Windows and MacOS. This analysis focuses specifically on the Windows version of Xloader.\n\n## Technical Analysis\n\nXloader and Formbook use HTTP to communicate with the C2 server. An HTTP GET query is sent as a form of registration. Afterwards,\nthe malware makes HTTP POST requests to the C2 to exfiltrate information such as screenshots, stolen data, etc. In both cases, the\nGET parameters and the POST data share a similar format and are encrypted as shown in Figure 1. We will explain the encryption\nalgorithms in the following sections.\n\n\n-----\n\nFigure 1. Xloader C2 communications capture\n\n## Decoy and Real C2 Servers\n\nThroughout the Xloader malware there are multiple structures of encrypted blocks of data and code. These blocks are designed to\nconfuse malware analysts and disassemblers by using the assembly instructions for a function prologue push ebp and mov ebp, esp as\nshown in Figure 2. We have named these structures PUSHEBP encrypted blocks. These blocks are decrypted using an RC4 based\nalgorithm combined with an encoding layer and a custom virtual machine (VM).\n\nFigure 2. Xloader PUSHEBP encrypted block\n\nOne of these PUSHEBP blocks contains encrypted strings, and a list of decoy C2s. These decoys are legitimate domains that have\nbeen added to mislead malware researchers and automated malware analysis systems. The real C2 server is stored separately and\nencrypted using another more complex scheme. The pseudocode responsible for decrypting the real C2 server is shown in Figure 3.\n\nFigure 3. Xloader C2 decryption algorithm\n\n\n-----\n\nIn Figure 3, the RC4_based_Decryptor function consists of RC4 encryption (with a 0x14 byte key) with an additional two encoding layers\nas shown below:\n```\n ################################################################\n def decrypt_PUSHEBP_encrypted_function_block(self, rc4_key,\n encdata):\n  #backward / forward sub layer 1\n  encdata =\n self.decrypt_PUSHEBP_backward_forward_sub_layers(encdata)\n  #rc4\n  encdata = self.rc4(encdata, rc4_key)\n  #backward / forward sub layer 2\n  encdata =\n self.decrypt_PUSHEBP_backward_forward_sub_layers(encdata)\n  return encdata\n\n```\nThe additional encoding layers consist of simple subtraction operations:\n```\n ################################################################\n def decrypt_PUSHEBP_backward_forward_sub_layers(self, encdata):\n  encdata = list(encdata)\n  lencdata = len(encdata)\n  #backward sub\n  p1 = lencdata - 2\n  counter = lencdata - 1\n  while True:\n   encdata[p1] = chr(0xff&(ord(encdata[p1]) - ord(encdata[p1 +\n 1])))\n   p1 -= 1\n   counter -= 1\n   if not counter: break\n  #forward sub\n  p1 = 0\n  counter = lencdata - 1\n  while True:\n   encdata[p1] = chr(0xff&(ord(encdata[p1]) - ord(encdata[p1 +\n 1])))\n   p1 += 1\n   counter -= 1\n   if not counter: break\n  return ''.join(encdata)\n\n```\n[The VM_Decryptor function is another algorithm that is used by Xloader, which implements a custom virtual machine (VM). The](https://github.com/tildedennis/malware/blob/master/formbook/formbook_decryption.py)\nfollowing lines of Python reproduce the steps that Xloader performs to decrypt the real C2.\n\n\n-----\n\n```\n ################################################################\n # get blocks of enc strings\n b1 = GetPUSHEBPBlock(1)\n enc_strings_block = VM_Decryptor(b1)\n # get rc4 key 1, 0x14 bytes\n b8 = GetPUSHEBPBlock(8)\n key_rc4_1 = VM_Decryptor(b8)\n # get rc4 key 2, 014 bytes\n b2 = GetPUSHEBPBlock(2)\n key_rc4_2 = VM_Decryptor(b2)\n # get the block containing enc real C2\n b11 = GetPUSHEBPBlock(11)\n enc_real_c2 = VM_Decryptor(b11)\n # decrypt first layer of the real C2, use the RC4 based algorithm\n and\n # the SHA1 of the full block of encrypted strings\n enc_real_c2 = RC4_based_Decryptor(enc_real_c2,\n SHA1(enc_strings_block))\n # decrypt the next layers of the real C2, use RC4 based algorithm\n and\n # the two RC4 key recovered previously from the PUSHEBP blocks\n enc_real_c2 = RC4_based_Decryptor(enc_real_c2, key_rc4_1)\n dec_real_c2 = RC4_based_Decryptor(enc_real_c2, key_rc4_2)\n # the valid decrypted real c2 must start with www.\n b_ok = is_www(dec_real_c2)\n\n```\nOnce decrypted, the C2 URL has a format similar to www.domain.tld/botnet_id/.\n\nThe C2 communications occur with the decoy domains and the real C2 server, including sending stolen data from the victim. Thus, there\nis a possibility that a backup C2 can be hidden in the decoy C2 domains and be used as a fallback communication channel in the event\nthat the primary C2 domain is taken down.\n\n## Formbook Communication Encryption Specific Details\n\nIn FormBook, the HTTP GET parameters (and POST data) were encrypted in four steps:\n\n1. Using the domain and path of the real C2, an RC4 key was calculated in this way:\n\n_Reverse_DWORDs(SHA1(<domain>/<cncpath>/))_\n2. The result was used as an RC4 key to encrypt the data\n3. Once the data was RC4 encrypted, it was additionally encoded using Base64\n4. Data sent via HTTP POST requests was formatted using the character substitution that is shown in Table 1.\n\nOriginal Symbol Replacement Symbol\n\n+ \n/ _\n\n= .\n\n+ ~\n\n/ (\n\n= )\n\n+ <space>\n\nTable 1. Formbook C2 Characters Substitution\n\nTherefore, Formbook C2 communications could be easily decrypted by reversing the process since the C2 domain and path are known.\n\n\n-----\n\n## Xloader Communication Encryption Specific Details\n\nThe network encryption in XLoader is more complex. An additional RC4 layer was added to the process, with a convoluted algorithm\nthat is used to derive this encryption key using the following steps:\n\n1) To encrypt the HTTP network data, Xloader first calculates a key that we call Key0Comm as shown in Figure 4.\n\nFigure 4. Xloader KeyComm0 Derivation\n\nAs we can see in Figure 4, the PUSHEBP block 7 is decrypted using the Xloader VM. This block, once decrypted, has a length of 0x15\nbytes. The first 0x14 bytes are used as an RC4 key, and the last byte is used to choose and decrypt another PUSHEBP block (among\nthe blocks 4, 5, 6, 8, 9 and 10) based on a switch statement. Thus the parameter Key0Comm in derived as follows:\n\n_Key0Comm = RC4_based_Decryptor(decPushebpBlock7Key[:0x14], decSwitchBasedPushebpBlock)_\n\nHowever, the order of the PUSHEBP blocks, and the associations between the switch and the block number, changes from one sample\nto another (i.e., the code of this function is randomized), even on the same versions of Xloader. Figure 5 shows a comparison of this\nfunction between two different Xloader v2.5 samples.\n\n\n-----\n\nFigure 5. Xloader KeyComm0 Function to Map the Switch to a Block\n\nTable 2 shows how these switch statements map to different block IDs in these samples.\n\nSwitch 1 Switch 2 Switch 3 Switch 4 Switch 5 Switch 6\n\nSample 1 Block 4 Block 5 Block 10 Block 6 Block 9 Block 8\n\nSample 2 Block 6 Block 7 Block 8 Block 5 Block 4 Block 10\n\nTable 2. Xloader Block ID Mapping Example\n\nIn order to perform encryption for the C2 communications, the sample-specific table that maps these blocks must be known to derive the\nencryption key Key0Comm.\n\n2) Next, another key that we refer to as Key1Comm is calculated using the same algorithm as Formbook:\n\n_Key1Comm = Reverse_DWORDs(SHA1(<domain>/<cncpath>/))_\n\n3) Finally, we need to calculate one last key, using the Xloader custom RC4-based decryption algorithm as follows:\n\n_Key2Comm = RC4based_Decryptor(Key0Comm, Key1Comm)_\n\nHaving all three of these RC4 keys, we can encrypt and decrypt Xloader C2 communications. The packets are encrypted with two layers\nof standard RC4 using the keys Key2Comm and Key1Comm, as shown below:\n\n\n-----\n\n```\n Key0Comm = <…from binary…>\n c2 = \"www.pc6888.com\"\n c2path = \"htbn\"\n get1=\"xPeDUfwp=X/0PTsm65bsB0xA5p5tU+UuBoyxUJvYd1eRdC0qFrd+bv9rqN9yTTECZJTYp88Jb6Qhj\n uA==\"\n Key1Comm = Reverse_DWORDs(SHA1(f\"{c2}/{path}/\"))\n fake_var, encrypted_params = get1.split('=', 1)\n sdec0 = b64_trans(encrypted_params)\n sdec1 = base64.b64decode(sdec0)\n Key2Comm = RC4_based_Decryptor(Key0Comm, Key1Comm)\n sdec2 = rc4(sdec1, Key2Comm) #layers encrypted with standard rc4\n sdec3 = rc4(sdec2, Key1Comm)\n print(sdec3)\n\n```\nXloader also further applies the Base64 and character substitution described earlier for POST queries.\n\n## Conclusion\n\nXloader is a well-developed malware family that has numerous techniques to mislead researchers and hinder malware analysis\nincluding multiple layers of encryption and a custom virtual machine. Even though the authors abandoned the Formbook branch to focus\non the rebranded Xloader, both strains are still quite active today. Formbook is still being used by threat actors using the leaked panel\nsource code and self-managing the C2, while the original authors have continued to sell Xloader as MaaS, supporting and renting the\nservers infrastructure. Not surprisingly, it has been one of the most active threats in recent years.\n\n## Cloud Sandbox Detection\n\nZscaler's multilayered cloud security platform detects indicators at various levels, as shown below:\n\n## Indicators of Compromise\n\nVariant Version SHA256 Real C2\n\nXloader 2.5 c60a64f8910005f98f6cd8c5787e4fe8c6580751a43bdbbd6a14af1ef6999b8f http://www.finetipster[.]com/pvxz/\n\n\n-----\n\nXloader 2.5 2c78fa1d90fe76c14f0a642af43c560875054e342bbb144aa9ff8f0fdbb0670f http://www.go2payme[.]com/snec/\n\nXloader 2.5 f3c3c0c49c037e7efa2fbef61995c1dc97cfe2887281ba4b687bdd6aa0a44e0a http://www.pochi-owarai[.]com/hr8n/\n\nXloader 2.5 efd1897cf1232815bb1f1fbe8496804186d7c48c6bfa05b2dea6bd3bb0b67ed0 http://www.hosotructiep[.]online/bsz6/\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-21 - Analysis of Xloader’s C2 Network Encryption.pdf"
    ],
    "report_names": [
        "2022-01-21 - Analysis of Xloader’s C2 Network Encryption.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536102,
    "ts_updated_at": 1743041127,
    "ts_creation_date": 1653786686,
    "ts_modification_date": 1653786686,
    "files": {
        "pdf": "https://archive.orkl.eu/ef82d766e6ece08f3dd98b2889d622ba2bf79002.pdf",
        "text": "https://archive.orkl.eu/ef82d766e6ece08f3dd98b2889d622ba2bf79002.txt",
        "img": "https://archive.orkl.eu/ef82d766e6ece08f3dd98b2889d622ba2bf79002.jpg"
    }
}