{
    "id": "2c27d501-a50f-417b-9489-022476532e5f",
    "created_at": "2022-10-25T16:48:15.366434Z",
    "updated_at": "2025-03-27T02:16:25.579256Z",
    "deleted_at": null,
    "sha1_hash": "dc6523e3007d8365af182a52c347c8ead66aa9ee",
    "title": "VB2014-proceedings.indb",
    "authors": "",
    "file_creation_date": "2014-09-15T14:11:56Z",
    "file_modification_date": "2014-09-15T14:12:05Z",
    "file_size": 708347,
    "plain_text": "# BOOTKITS: PAST, PRESENT & FUTURE\n#### Eugene Rodionov ESET, Canada\n\n Alexander Matrosov Intel, USA\n\n David Harley ESET North America, UK\n\n Email rodionov@eset.com; alexander.matrosov@ intel.com; david.harley.ic@eset.com\n\n ABSTRACT\n\nBootkit threats have always been a powerful weapon in the\nhands of cybercriminals, allowing them to establish a persistent\nand stealthy presence in their victims’ systems. The most recent\nnotable spike in bootkit infections was associated with attacks on\n64-bit versions of the Microsoft Windows platform, which\nrestrict the loading of unsigned kernel-mode drivers. However,\nthese bootkits are not effective against UEFI-based platforms.\nSo, are UEFI-based machines immune against bootkit threats (or\nwould they be)?\n\nThe aim of this presentation is to show how bootkit threats have\nevolved over time and what we should expect in the near future.\nFirst, we will summarize what we have learned about the\nbootkits seen in the wild targeting the Microsoft Windows\nplatform: from TDL4 and Rovnix (the one used by the Carberp\nbanking trojan) up to Gapz (which employs one of the stealthiest\nbootkit infection techniques seen so far). We will review their\ninfection approaches and the methods they have employed to\nevade detection and removal from the system.\n\nSecondly, we will look at the security of the increasingly\npopular UEFI platform from the point of view of the bootkit\nauthor as UEFI becomes a target of choice for researchers in\noffensive security. Proof-of-concept bootkits targeting\n_Windows 8 using UEFI have already been released. We will_\nfocus on various attack vectors against UEFI and discuss\navailable tools and what measures should be taken to mitigate\nagainst them.\n\n#### INTRODUCTION\n\nThe fi rst bootkits started to emerge on the malware scene as\ncybercriminals realized that bootkit development was a way in\nwhich they could increase the profi tability of a kernel-mode\nrootkit by widening the range of its targets to include users of\n64-bit machines. This resulted in a trend whereby rootkit\ndevelopers began to focus on bootkits.\n\nThe main obstacle to 64-bit development was the need to bypass\nthe Microsoft kernel-mode code signing policy for system\ndrivers, and this is the rationale behind modern bootkit\ndevelopment. However, the history of the bootkit begins much\nearlier than that.\n\n\n#### BOOTKIT EVOLUTION\n\nThe fi rst IBM-PC-compatible boot sector viruses from 1987 used\nthe same concepts and approaches as modern threats, infecting\nboot loaders so that the malicious code was launched even\nbefore the operating system was booted.\n\nIn fact, attacks on the PC boot sector were already known from\n(and even before) the days of MS-DOS, and these have a part to\nplay in our understanding of the development of approaches to\ntaking over a system by compromising and hijacking the boot\nprocess.\n\nThe fi rst microcomputer to have been affected by viral software\nseems to have been the Apple II. At that time, Apple II diskettes\nusually contained the disk operating system. Around 1981 [1],\nthere were already versions of a ‘viral’ DOS reported at Texas\n_A&M. In general, though, the ‘credit’ for the ‘fi rst’ Apple II virus_\nis given to Rich Skrenta’s Elk Cloner (1982–3) [2, 3].\n\nAlthough Elk Cloner preceded PC boot sector viruses by several\nyears, its method of boot sector infection was very similar. It\nmodifi ed the loaded OS by hooking itself, and stayed resident in\nRAM in order to infect other fl oppies, intercepting disk accesses\nand overwriting their system boot sectors with its own code. The\nlater Load Runner (1989), affecting Apple IIGS and ProDOS [2],\nrarely gets a mention nowadays, but its speciality was to trap the\nreset command triggered by the key combination\nCONTROL+COMMAND+RESET and take it as a cue to write\nitself to the current diskette, so that it would survive a reset. This\nmay not be the earliest example of ‘persistence’ as a\ncharacteristic of malware that refused to go away after a reboot,\nbut it’s certainly a precursor to more sophisticated attempts to\nmaintain a malicious program’s presence.\n\n#### © Brain damage\n\nThe fi rst PC virus is usually considered to be Brain, a fairly\nbulky Boot Sector Infector (BSI), which misappropriated the fi rst\ntwo sectors for its own code and moved the original boot code\nup to the third sector, marking the sectors it used as ‘bad’ so that\nthey wouldn’t be overwritten.\n\nBrain had some features that signifi cantly prefi gured some of the\ncharacterizing features of modern bootkits. First, the use of a\nhidden storage area in which to keep its own code (though in a\nmuch more basic form than TDSS and its successors). Secondly,\nthe use of ‘bad’ sectors to protect that code from legitimate\nhousekeeping by the operating system. Thirdly, the stealthy\nhooking of the disk interrupt handler to ensure that the original,\nlegitimate boot sector stored in sector three was displayed when\nthe virus was active [2].\n\nThe volume of boot sector infectors and infection fi rst began to\ndecline when it became possible to change the boot order in setup\nso that the system would boot from the hard disk and ignore any\nleft-over fl oppy. However, it was the increasing take-up of\nmodern Windows versions and the virtual disappearance of the\nfl oppy drive that fi nally killed off the old-school BSI.\n\n#### BOOT INFECTION REBOOTED\n\n_Windows – and hardware and fi rmware technology – has moved_\non since Brain and its immediate successors, and boot infection\n\n\n-----\n\n_Figure 1: The system booting fl ow._\n\nhas evolved into new types of attack on operating system boot\n\n**Evolution of proof-of-**\n\nloaders, especially since Microsoft started to use a kernel-mode\n\n**concept bootkits**\n\ncode signing policy in its 64-bit operating systems.\n\neEye BootRoot – 2005\n\nAll bootkits aim to modify and subvert operating system\n\nThe fi rst MBR-based\n\ncomponents before the OS can be loaded. The most interesting\n\nbootkit for\n\ntarget components (Figure 1) are as follows: BIOS/UEFI, MBR\n\noperating systems.\n\n(Master Boot Record) and the operating system boot loader.\n\nVbootkit – 2007\n\nThe harbinger of modern bootkits is generally considered to be\n_eEye’s proof of concept (PoC) BootRoot [4], which was_\npresented at BlackHat 2005. BootRoot was an NDIS (Network _Microsoft Windows Vista_\nDriver Interface) backdoor demonstrating the use of an old Vbootkit x64 – 2009 [8]\nvector as a model for modern OS attacks.\n\nAt BlackHat 2007, Vbootkit [5] was released. This PoC code\ndemonstrated possible attacks on the Windows Vista kernel by on MS Windows 7\nmodifying the boot sector. The authors of Vbootkit released its\n\nStoned Bootkit – 2009\n\ncode as an open-source project, and that release coincided with\nthe initial detection of the fi rst malicious bootkit, Mebroot.\n\nbased bootkit infection.\n\nThis unusually sophisticated malware offered a real challenge\nfor anti-virus companies because it used new stealth techniques\nfor surviving after a reboot. The Stoned bootkit [6] was also MBR-based bootkit\nreleased at BlackHat, apparently so named in homage to the\nmuch earlier, but very successful Stoned BSI. 64-bit operating systems.\n\nThese proof-of-concept bootkits are not the direct cause for the DeepBoot – 2011 [9]\ncoinciding release of unequivocally malicious bootkits such as\nMebroot [7]. Malware developers were already searching for\nnew and stealthy ways to extend the window of active infection\n\nprotected mode.\n\nbefore security software detected an infection. In addition, in\n\nEvil Core – 2011 [10]\n\n2007 Microsoft Windows Vista enforced a kernel-mode code\nsigning policy on 64-bit operating systems, regulating the\ndistribution of system drivers. This triggered the resurrection of SMP (symmetric\nstealth implementation by subversion of the boot process, in the multiprocessing) for\nform of modern bootkits.\n\nAll known bootkits conform to one of two categories. The fi rst\ngroup consists of proof-of-concept demonstrations developed by\n\nVGA-based bootkit\n\nsecurity researchers, and the second consists of the real and\n\nconcept.\n\nunequivocally malicious threats developed by cybercriminals\n\nDreamBoot – 2013 [13]\n\n(see Table 1).\n\n#### Bootkit classifi cation UEFI bootkit.\n\n|Evolution of proof-of- concept bootkits|Evolution of bootkit threats|\n|---|---|\n|eEye BootRoot – 2005 The fi rst MBR-based bootkit for MS Windows operating systems.|Mebroot – 2007 The fi rst MBR-based bootkit in the wild.|\n|Vbootkit – 2007 The fi rst bootkit to target Microsoft Windows Vista.|Mebratix – 2008 The other malware family based on MBR infection.|\n|Vbootkit x64 – 2009 [8] The fi rst bootkit to bypass the digital signature checks on MS Windows 7.|Mebroot v2 – 2009 The evolved version of the Mebroot malware.|\n|Stoned Bootkit – 2009 Another example of MBR- based bootkit infection.|Olmarik (TDL4) – 2010/11 The fi rst 64-bit bootkit in the wild.|\n|Stoned Bootkit x64 – 2011 MBR-based bootkit supporting the infection of 64-bit operating systems.|Olmasco (TDL4 modifi cation) – 2011 The fi rst VBR-based bootkit infection.|\n|DeepBoot – 2011 [9] Used interesting tricks to switch from real-mode to protected mode.|Rovnix – 2011 The evolution of VBR-based infection with polymorphic code.|\n|Evil Core – 2011 [10] This concept bootkit used SMP (symmetric multiprocessing) for booting into protected-mode|Mebromi – 2011 The fi rst exploration of the concept of BIOSkits seen in the wild.|\n|VGA Bootkit – 2012 [11] VGA-based bootkit concept.|Gapz – 2012 [12] The next evolution of VBR infection|\n|DreamBoot – 2013 [13] The fi rst public concept of UEFI bootkit.|OldBoot - 2014 [14] The fi rst bootkit for the Android operating system in the wild.|\n\n\nThe main idea behind bootkits is to abuse and subvert the\noperating system in the course of the initial boot process. At the\n\n\n_Table 1: The chronological evolution of PoC bootkits versus_\n_real-world bootkit threats._\n\n\n-----\n\n|Bootkits MBR VBR/IPL MBR Code Partition Table IPL Code BIOS Parameter modification modification modification Block modification TDL4 Olmasco Rovnix Gapz|Col2|Col3|\n|---|---|---|\n|MBR Code modification|BIOS Parameter Block modification||\n||||\n|TDL4|Gapz||\n\n\n**IPL Code**\n**modification**\n\n\n**BIOS Parameter**\n**Block modification**\n\n\n**Partition Table**\n**modification**\n\n\n**TDL4**\n\n\n**MBR**\n\n\n**Rovnix**\n\n\n#### Figure 2: Bootkit classifi cation by type of boot sector infection.\n\nvery beginning of the bootup process, the BIOS code reads the\nMaster Boot Record at the fi rst sector of the bootable hard drive, **Load Infected MBR** **Continue kernel initialization**\nto which it transfers control. The MBR consists of the boot code\nand a partition table that describes the hard drive’s partitioning **InfectedMBR is loaded**\n\n**and executed**\n\nscheme. Modern bootkits can be classifi ed into two groups,\naccording to the type of boot sector infection employed: MBR **Load ldr16 from hidden file** **Call KdDebuggerInitialize1**\nand VBR (Volume Boot Record) bootkits (see Figure 2). The **system** **from kdcom.dll**\nmore sophisticated and stealthier bootkits we see are based on\nVBR infection techniques. **ldr16 is loadedand executed**\n\n**Load ntoskrnl.exe,**\n\n#### TDL4 and Olmasco Hook BIOS int 13h handler and hal.dll,kdcom.dll,bootvid.dll\n\n**restore original MBR**\n\n**ant etc.**\n\nTDL4 [15] and Olmasco [16] bootkits both target the MBR of\nthe bootable hard drive – however, they differ in that TDL4 **Original MBR code isloaded and executed**\noverwrites MBR code, whereas Olmasco modifi es the MBR’s\npartition table. Both infection approaches have the same result.\n\n**Load VBR** **Load winload.exe**\n\nMalicious components are initialized at boot time in order to\nload the malicious kernel-mode driver from the hidden storage\narea, and thus bypass the Microsoft kernel-mode code signing **VBR is loaded and executed**\npolicy enforced on x64 platforms. In Table 2, we show the\nmodules stored in the hidden fi le system of the TDL4 and used **Load bootmgr** **Read BCD**\n\n**Bootmgr is loaded**\n\nin the boot chain. **and receives control**\n\n_Figure 3: TDL4 bootkit workfl ow._\n\n**File name** **Description**\n\n\n**Continue kernel initialization**\n\n\n**Load Infected MBR**\n\n\n**Call KdDebuggerInitialize1**\n**from kdcom.dll**\n\n\n**Load winload.exe**\n\n\n**Load VBR**\n\n\n**MBR Code**\n**modification**\n\n\n**Bootkits**\n\n\n**VBR/IPL**\n\n\n**Substitute EmsEnabled option**\n**with WinPE**\n\n\n**MBR** **VBR** **Bootstrap Code** **File System Data**\n\n\n**File System Data**\n\n\n**Load ldr16 from hidden file**\n**system**\n\n\n**Load bootmgr**\n\n\n**Load ntoskrnl.exe,**\n**hal.dll,kdcom.dll,bootvid.dll**\n**ant etc.**\n\n\n**Olmasco**\n\n\ndrv64 The main bootkit driver for x64 systems\n\n_Table 2: TDL4 boot components._\n\nFigure 3 summarizes the boot process followed by the TDL4\nbootkit on Windows Vista and Windows 7 operating systems.\n\n#### Rovnix\n\nWin32/Rovnix is the fi rst known bootkit to target the VBR. Its\ninfection routine reads the 15 sectors following the VBR, which\ncontain the Initial Program Loader (IPL) code. These sectors are\n\n\n**Read BCD**\n\n\n**Gapz**\n\n\ncompressed and appended to the malicious bootstrap code. The\nresulting code is then written to the 15 sectors that follow the\nVBR, as shown in Figure 4. Consequently, on the next system\nstart-up, the malicious bootstrap code receives control.\n\n**MBR** **VBR** **Bootstrap Code** **File System Data**\n\n**Before Infecting**\n\nCompressed **After Infecting**\nData\n\n**Malicious**\n\n**Malicious** **Bootstrap**\n**MBR** **VBR** **File System Data** **Unsigned**\n**Code** **Code**\n\n**Driver**\n\nNTFS bootstrap code\n(15 sectors)\n\n_Figure 4: Win32/Rovnix approach to infection._\n\nWhen the malicious bootstrap code is executed it hooks the\nInt 13h handler in order to patch ntldr/bootmgr system\ncomponents so as to gain control after the boot loader\n\n|File name|Description|\n|---|---|\n|mbr|Original contents of the infected hard drive boot sector|\n|ldr16|16-bit real-mode loader code|\n|ldr32|Fake kdcom.dll for x86 systems|\n|ldr64|Fake kdcom.dll for x64 systems|\n|drv32|The main bootkit driver for x86 systems|\n|drv64|The main bootkit driver for x64 systems|\n\n|MBR|VBR|Bootstrap Code|Col4|File System Data|Col6|Col7|\n|---|---|---|---|---|---|---|\n|||Compressed Data||Before Infecting After Infecting|||\n|MBR|VBR|Malicious Code|Bootstrap Code|File System Data||Malicious Unsigned Driver|\n|||NTFS bootstrap code|||||\n|||(15 sectors)|||||\n\n\n**Malicious** **Bootstrap**\n**MBR** **VBR** **File System Data**\n**Code** **Code**\n\n\n**Hook BIOS int 13h handler and**\n**restore original MBR**\n\n\n**Malicious**\n**Code**\n\n\n-----\n\ncomponents are loaded. After that it decompresses and returns\ncontrol to the original bootstrap code.\n\nIn order to load its malicious unsigned driver into kernel-mode\naddress space and bypass the kernel-mode code signing policy,\nWin32/Rovnix employs the following technique. First, in order\nto propagate itself through processor execution mode switching\n(from real mode into protected mode), it uses the IDT (Interrupt\nDescriptor Table). This is a special system structure which is\nused in protected mode and consists of interrupt handler\ndescriptors. The malware copies itself over the second half of\nthe IDT, which is not used by the system. Secondly, it hooks the\nint 1h protected mode handler and sets hardware breakpoints so\nas to be able to receive control at specifi c points of the OS\nkernel loading process. By using debugging registers dr0–dr7,\nwhich are an essential part of the x86 and x64 architectures, the\nmalware gets control at some point during the kernel\ninitialization and loads its own malicious driver manually, thus\nbypassing the kernel-mode code integrity check.\n\n#### Gapz\n\nHistorically, there are two modifi cations of the bootkit\nWin32/Gapz implementing different infection methods. The\nfi rst version of the malware acted like a traditional MBR\ninfector, while the other version employed a rather sophisticated\nstealth approach to infecting the VBR. For this reason, in this\nsection we will focus on the latter, more interesting approach.\nWhat is remarkable about this technique is that only a few bytes\nof the original VBR are affected. The essence of this approach is\nthat Win32/Gapz modifi es the ‘Hidden Sectors’ fi eld of the\nVBR, while all the other data and code of the VBR and IPL\nremain untouched.\n\nThe fi eld that is targeted by the malware is located in the\nVolume Parameter Block (VPB), which is a special data\nstructure located in the VBR and describing the attributes of the\nNTFS volume. The purpose of the ‘Hidden Sectors’ fi elds is to\nprovide an offset in sectors to the Initial Program Loader (IPL)\nfrom the beginning of the volume, as illustrated in Figure 5.\n\n**NTFS Volume**\n\n0x200 0x1E00\n\n**MBR** **VBR** **IPL** **NTFS File System**\n\nNumber ofNumber of\n“Hidden Sectors”“Hidden Sectors”\n\n_Figure 5: ‘Hidden Sectors’ fi eld of BPB._\n\nThe IPL code is loaded and executed by the VBR: thus, by\nmodifying value of the ‘Hidden Sectors’ fi eld, the malware is\nable to intercept execution fl ow at boot time, as shown in Figure\n6. The next time the VBR code is executed, it loads and\nexecutes the bootkit code instead of the legitimate IPL. The\nbootkit image is written either before the very fi rst partition or\nafter the last partition of the hard drive.\n\n|Hard Drive|Col2|Col3|Col4|Col5|Col6|\n|---|---|---|---|---|---|\n|NTFS Volume 0x200 0x1E00||||||\n|MBR||Infected VBR|IPL|NTFS File System|Bootkit|\n|MMooddiiffiieedd vvaalluuee ooff nnuummbbeerr ooff ““HHiiddddeenn SSeeccttoorrss””||||||\n\n\n**Infected**\n**MBR** **IPL** **NTFS File System** **Bootkit**\n**VBR**\n\n\n_Figure 6: Layout of a hard drive infected by Win32/Gapz._\n\nThe main purpose of the bootkits considered above is to load\nand pass control to the malware’s kernel-mode module without\nbeing noticed by security software. The kernel-mode module of\nWin32/Gapz isn’t a conventional PE image, but is composed of\na set of blocks with position-independent code, each block\nserving a specifi c purpose as described in Table 3.\n\n**Block #** **Implemented functionality**\n\n1 General API, gathering information on the hard\ndrives, CRT string routines, etc.\n\n2 Cryptographic library: RC4, MD5, SHA1, AES,\nBASE64, etc.\n\n3 Hooking engine, disassembler engine.\n\n4 Hidden storage implementation.\n\n5 Hard disk driver hooks, self-defence.\n\n6 Payload manager.\n\n7 Payload injector into processes’ user-mode\naddress space.\n\n8 Network communication: data link layer.\n\n9 Network communication: transport layer.\n\n10 Network communication: protocol layer.\n\n11 Payload communication interface.\n\n12 Main routine.\n\n_Table 3: Win32/Gapz blocks description._\n\n#### Win32/Gapz: hidden storage implementation\n\nSo as to store payload and confi guration information secretly\nWin32/Gapz implements hidden storage. The image is located\nin a fi le named\n\n‘\\??\\C:\\System Volume Information\\{XXXXXXXX-XXXXXXXX-XXXX-XXXXXXXXXXXX}’\n\nwhere X signifi es hexadecimal numbers generated based on\nconfi guration information. The fi le is formatted as a FAT32\nvolume.\n\nTo keep the information stored within the hidden storage secret,\nits content is encrypted. The malware utilizes AES with key\nlength 256 bits in CBC (Cipher Block Chaining) mode to\nencrypt/decrypt each sector of the hidden storage. As IV\n(Initialization Value) for CBC mode, Win32/Gapz utilizes the\nnumber of the fi rst sector being encrypted/decrypted. Thus, even\nthough the same key is used to encrypt every sector of the hard\n\n|Block #|Implemented functionality|\n|---|---|\n|1|General API, gathering information on the hard drives, CRT string routines, etc.|\n|2|Cryptographic library: RC4, MD5, SHA1, AES, BASE64, etc.|\n|3|Hooking engine, disassembler engine.|\n|4|Hidden storage implementation.|\n|5|Hard disk driver hooks, self-defence.|\n|6|Payload manager.|\n|7|Payload injector into processes’ user-mode address space.|\n|8|Network communication: data link layer.|\n|9|Network communication: transport layer.|\n|10|Network communication: protocol layer.|\n|11|Payload communication interface.|\n|12|Main routine.|\n\n|NTFS Volume 0x200 0x1E00|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n|MBR||VBR|IPL|NTFS File System|\n|NNuummbbeerr ooff ““HHiiddddeenn SSeeccttoorrss””|||||\n\n\n**MBR** **VBR** **IPL** **NTFS File System**\n\n\n-----\n\ndrive, using different IVs for different sectors results in different\nciphertexts each time.\n\n#### Win32/Gapz: network communication\n\nIn order to communicate with C&C servers, Win32/Gapz\nemploys a rather sophisticated network implementation. The\nnetwork subsystem is designed in such a way as to bypass\npersonal fi rewalls and network-traffi c-monitoring software\nrunning on the infected machine. These features are achieved\ndue to customized implementation of TCP/IP stack protocols in\nkernel mode, the implementation being based on the miniport\nadapter driver. According to the NDIS specifi cation, the\nminiport driver is the lowest driver in the network driver stack\n– thus, using its interface makes it possible to bypass\nnetwork-traffi c-monitoring software, as shown in Figure 7.\n\nProtocol driver\n\n**Win32/Gapz** (tcpip.sys)\n**Network**\n**packet**\n\nFilter 1 driver\n\nSecurity software usually\noperates at the level of\nprotocol or intermediate drivers\n\nIntermediate driver\n\nFilter N driver\n\nWin32/Gapz communicates\n\nMiniport adapter driver\n\ndirectly to miniport adapter\n\n_Figure 7: Win32/Gapz custom network implementation._\n\nThe malware obtains a pointer to the structure describing the\nminiport adapter by inspecting the NDIS library (ndis.sys) code\nmanually. The routine responsible for handling NDIS miniport\nadapters is implemented in block #8 of the kernel-mode module.\nThe architecture of the Win32/Gapz network subsystem is\npresented in Figure 8.\n\nWin32/Gapz implementation OSI Model\n\nHTTP protocol Application/Presentation\n(block #10) Layer\n\nTCP/IP protocol\n\nNetwork/Transport Layer\n\n(block #9)\n\nNDIS miniport wrapper\n\nData Link Layer\n\n(block #8)\n\n_Figure 8: Win32/Gapz network architecture._\n\nThis approach allows the malware to use the socket interface to\ncommunicate with the C&C server without being noticed.\n\n\nCommunication with C&C servers is performed over HTTP.\nThe malware enforces encryption to protect the confi dentiality\nof the messages being exchanged between the bot and C&C\nserver and to check the authenticity of the message source (to\nprevent subversion by commands from C&C servers that are not\n‘authentic’ – a technique often used by security researchers to\ndisrupt a malicious botnet). The main purpose of the protocol is\nto request and download the payload and report the bot status to\nthe C&C server.\n\n#### UEFI SECURITY\n\nUEFI stands for Unifi ed Extensible Firmware Interface: the\nspecifi cation was originally developed to replace legacy BIOS\nboot software. The boot process in UEFI is substantially\ndifferent from that in the legacy BIOS environment: there is no\nlonger any MBR and VBR code, which on older systems\neventually load bootmgr and winload; these components are\nreplaced with the UEFI boot code. Instead of an MBR-based\npartitioning scheme, the GPT (GUID Partition Table)\npartitioning scheme is used as the layout of the hard drive. The\nUEFI bootloader is loaded from the special partition, referred to\nas the EFI System Partition, formatted using the FAT32 fi le\nsystem (FAT12 and FAT16 are also possible). The path to the\nbootloader is specifi ed in a dedicated NVRAM variable. For\ninstance, for Microsoft Windows 8, the path to the bootloader\nlooks like this: ‘\\EFI\\Microsoft\\Boot\\bootmgfw.efi ’. The\npurpose of this module is to locate the OS’s kernel loader\n(winload.efi for Microsoft Windows 8) and transfer control to it.\nThe functionality of winload.efi is essentially the same as that of\nwinload.exe – that is, to load the OS kernel image.\n\n#### UEFI bootkit: Dreamboot\n\nAs noted in Table 1, Dreamboot is the fi rst public\nproof-of-concept bootkit targeting UEFI and Windows\n_8. The bootkit infection results in the replacement of the_\noriginal UEFI bootloader with a malicious substitute.\nWhen this is executed by UEFI boot code, it looks for the\noriginal bootloader (bootmgfw.efi ), loads it and hooks the\nArchpx64TransferTo64BitApplicationAsm routine. The hook\nallows it to receive control at the time when the OS kernel\nloader – winload.efi – is in memory, but before the loader is\nexecuted. At this point the malware sets up another hook in\nwinload.efi on the OslArchTransferToKernel routine: the name\nis self-explanatory. The latter hook is triggered when the OS\nkernel image has been mapped into system address space and\nDreamboot patches it in order to disable kernel-mode security\nchecks (PatchGuard and so on). Figure 9 summarizes the\nDreamboot boot process.\n\n#### FUTURE THREATS AND FUTURE TOOLS\n\nImplementing forensics procedures for the UEFI platform is a\nproblem because popular forensic software is not covered.\nHowever, proof-of-concept UEFI bootkits have already been\npresented at many security conferences in the last few years,\nsome of them with source code. In the previous case of bootkits\ntargeting legacy bootstrap code in the MBR, it was two years\nfrom the release of the fi rst publicly known PoC code to\n\n|Protocol driver (tcpip.sys)|Col2|\n|---|---|\n|||\n\n|...|Col2|\n|---|---|\n|||\n|Filter 1 driver||\n|||\n\n|...|Col2|\n|---|---|\n|||\n|Intermediate driver||\n|||\n\n|Win32/Gapz implementation HTTP protocol (block #10) TCP/IP protocol (block #9) NDIS miniport wrapper (block #8)|Col2|OSI Model Application/Presentation Layer Network/Transport Layer Data Link Layer|\n|---|---|---|\n\n\nApplication/Presentation\nLayer\n\n\nHTTP protocol\n(block #10)\n\n\nNDIS miniport wrapper\n(block #8)\n\n\nProtocol driver\n(tcpip.sys)\n\n\nIntermediate driver\n\n\nMiniport adapter driver\n\n\n-----\n\n**Load kernel and boot**\n**start drivers**\n\n\n**UEFI boot code**\n\n\n_Figure 9: Dreamboot boot process._\n\nmalware samples being seen in the wild. The motivation for\nattacks on UEFI is growing every year because the number of\nPCs and laptops with a legacy BIOS is decreasing year on year.\nThe number of people using Microsoft Windows 8 is also\ngrowing, which means that the number of users with active\nSecure Boot is increasing.\n\nUEFI malware infection can attack by way of a number of\ndifferent vectors:\n\n - The fi rst type uses the same approach as the Dreamboot\nbootkit, based on replacing the original Windows Boot\nManager and adding a new boot loader (Figure 10).\n\n - The second approach is by directly abusing the UEFI DXE\n(Driver execution Environment) driver [17] (Figure 11).\n\n - The third method is to patch the UEFI ‘Option ROM’: for\nexample, the DXE Driver in Add-On Card (Network,\nStorage …), which isn’t embedded in the fi rmware volume\nin ROM [18, 19] (Figure 12).\n\n_Figure 11: UEFI infection by abusing DXE driver._\n\nThe Secure Boot implementation in the latest version of\n_Microsoft Windows protects the booting process from malware_\n\n_Figure 10: UEFI infection by replaced boot loader._ _Figure 12: Types of UEFI bootkit infection._\n\n\n**winload.efi**\n\n\n-----\n\nmodifi cations. However, researchers are trying to understand the\nmethods attackers could use to bypass Secure Boot exploiting\nvulnerabilities in BIOS/UEFI implementations in order to infect\nthe machine, and to mitigate against them [20, 21].\n\n#### CHIPSEC\n\n_Intel has developed a CHIPSEC framework especially for BIOS/_\nUEFI security assessment. This is an open-source framework for\nanalysing the security of PC platforms covering hardware,\nsystem fi rmware including BIOS/UEFI, and the confi guration of\nplatform components. It allows the creation of a security test\nsuite, security assessment tools for various low-level components\nand interfaces, as well as forensic capabilities for fi rmware.\nCHIPSEC is a framework developed in Python but with some\nparts coded in C++ for deeper integration with the hardware at\noperating system level. Besides Microsoft Windows and Linux\noperating systems, CHIPSEC can also run from a UEFI shell.\nThe framework architecture is presented in Figure 13.\n\n_Figure 13: CHIPSEC framework architecture._\n\nThe CHIPSEC framework can be used as a security testing tool\nfor searching for BIOS and UEFI fi rmware vulnerabilities. Also,\nthe functionality of this tool covers forensic approaches for live/\noffl ine fi rmware analysis from CHIPSEC modules [22]. This\ntool includes modules for hidden fi le system forensics directly\nfrom the UEFI shell without the need to boot the operating\nsystem. In addition, CHIPSEC has basic heuristics for detecting\nBIOS/UEFI bootkit infection.\n\n#### HIDDEN FILE SYSTEM READER TOOL\n\nImplementing hidden storage makes forensic analysis more\ndiffi cult because:\n\n  - Malicious fi les are not stored in the fi le system (diffi cult to\nextract)\n\n - Hidden storage cannot be decrypted without malware\nanalysis\n\n - Typical forensic tools do not work out of the box.\n\nTo tackle the problem of retrieving the contents of the hidden\nstorage areas, one needs to perform malware analysis and\nreconstruct the algorithms used to handle the stored data. In the\n\n\ncourse of our research into complex threats, we developed a tool\nsome time ago [23] which is intended to recover the contents of\nhidden storage used by such complex threats as:\n\n - TDL3 and its modifi cations\n\n - TDL4 and its modifi cations\n\n - Olmasco\n\n - Rovnix.A\n\n - Rovnix.B\n\n - Sirefef (ZeroAccess)\n\n - Goblin (XPAJ)\n\n - Flame (dump decrypted resource section)\n\nThe tool is very useful in incident response, threat analysis and\nmonitoring. It is able to dump the malware’s hidden storage, as\nwell as to dump any desired range of sectors of the hard drive.\nA screenshot of the tool’s output is shown in Figure 14.\n\n_Figure 14: Hidden fi le system reader._\n\n#### CONCLUSION\n\n_Microsoft claimed that the release of the Secure Boot technology_\nheralded the end of the bootkit era. In practice, Secure Boot just\nswitched the focus of the attackers towards a change in infection\nstrategy. There are still many active machines in the world with\nold operating systems where Secure Boot is not supported. For\nnon-targeted attacks, just intended to build botnets,\ncybercriminals will continue to use old bootkits and bootkit\ntechniques for MBR/VBR infection until a critical mass of users\nhave switched to modern hardware and operating systems.\n\nIn targeted attacks on Microsoft Windows 8, however, attackers\nwill use vulnerabilities in the most common BIOS/UEFI\nfi rmware. The security life cycle for BIOS/UEFI is totally\ndifferent from that in operating systems or popular software.\nThis presents a problem because the BIOS/UEFI fi rmware on\nend-users’ machines has sometimes never been updated since\nthe fi rst day they were used. We do not see a unifi ed updating\nprocess embedded in the operating system because different\nfi rmware vendors use different schemes for the delivery of\nupdates. Modern security software does not yet operate at the\n\n\n-----\n\nlevel of BIOS/UEFI fi rmware protection. In the opinion of the\nauthors of this paper [24], an interesting future lies ahead,\npossibly starting with targeted attacks: who’s to say that they\nhaven’t already started?\n\n#### REFERENCES\n\n[1] Slade, R. Robert Slade’s Guide to Computer Viruses.\n2nd Edition, Springer, 1996. http://www.amazon.com/\nRobert-Slades-Guide-Computer-Viruses/\ndp/0387946632.\n\n[2] Harley, D.; Slade, R.; Gattiker, U. Viruses Revealed.\nOsborne, 2007. http://www.amazon.com/VirusesRevealed-David-Harley/dp/B007PMOWTQ.\n\n[3] Ször, P. The Art of Computer Virus Research and\nDefense. Addison Wesley, 2005. http://books.google.\nco.uk/books/about/The_Art_of_Computer_Virus_\nResearch_and_D.html?id=XE-ddYF6uhYC&redir_\nesc=y.\n\n[4] Soeder, D.; Permeh, R. eEye BootRoot. BlackHat,\n2005. http://www.blackhat.com/presentations/bh-usa05/bh-us-05-soeder.pdf.\n\n[5] Kumar, N.; Kumar V. Vbootkit. BlackHat 2007.\nhttps://www.blackhat.com/presentations/bh-europe-07/\nKumar/Whitepaper/bh-eu-07-Kumar-WP-apr19.pdf.\n\n[6] Kleissner, P. Stoned Bootkit. BlackHat 2009.\nhttp://www.blackhat.com/presentations/bh-usa-09/\nKLEISSNER/BHUSA09-Kleissner-StonedBootkitPAPER.pdf.\n\n[7] Florio, E.; Kasslin, K. Your Computer is Now Stoned\n(...Again!): The Rise of MBR Rootkits. Symantec,\n2013. http://www.symantec.com/content/en/us/\nenterprise/media/security_response/whitepapers/your_\ncomputer_is_now_stoned.pdf.\n\n[8] Kumar, N.; Kumar V. VBootkit 2.0: Attacking Windows\n7 via Boot Sectors. HiTB 2009.\nhttp://conference.hitb.org/hitbsecconf2009dubai/\nmaterials/D2T2%20-%20Vipin%20and%20Nitin%20K\numar%20-%20vbootkit%202.0.pdf.\n\n[9] Economou, N.; Luksenberg A. Deep Boot. Ekoparty\n2011. http://www.ekoparty.org//archive/2011/\nekoparty2011_Economou-Luksenberg_Deep_Boot.pdf.\n\n[10] Ettlinger, W.; Vieböck, S. Evil Core Bootkit: Pwning\nMultiprocessor Systems. NinjaCon, 2011.\nhttp://downloads.ninjacon.net/downloads/\nproceedings/2011/Ettlinger_Viehboeck-Evil_Core_\nBootkit.pdf.\n\n[11] Diego, J.; Economou, N.A. VGA Persistent Rootkit.\nEkoparty 2012. http://corelabs.coresecurity.com/index.\nphp?module=Wiki&action=view&type=publication&n\name=vga_persistent_rootkit.\n\n[12] Rodionov, E.; Matrosov, A. Mind the Gapz: The most\ncomplex bootkit ever analyzed? ESET, 2013.\nhttp://www.welivesecurity.com/wp-content/\nuploads/2013/05/gapz-bootkit-whitepaper.pdf.\n\n\n\n[13] Kaczmarek, S. UEFI and Dreamboot. HiTB 2013.\nhttp://www.quarkslab.com/dl/13-04-hitb-uefi dreamboot.pdf.\n\n[14] Zihang, X. Oldboot: the fi rst bootkit on Android. 360,\n2014. http://blogs.360.cn/360mobile/2014/01/17/\noldboot-the-fi rst-bootkit-on-android/.\n\n[15] Rodionov, E.; Matrosov, A. The Evolution of TDL:\nConquering x64. ESET, 2011. http://www.eset.com/us/\nresources/white-papers/The_Evolution_of_TDL.pdf.\n\n[16] Matrosov, A. Olmasco bootkit: next circle of TDL4\nevolution (or not?). ESET, 2012.\nhttp://www.welivesecurity.com/2012/10/18/olmascobootkit-next-circle-of-tdl4-evolution-or-not-2/.\n\n[17] Intel® Platform Innovation Framework for UEFI\nSpecifi cation. http://www.intel.com/content/www/us/\nen/architecture-and-technology/unifi ed-extensiblefi rmware-interface/efi -specifi cations-generaltechnology.html.\n\n[18] UEFI Validation Option ROM Validation Guidance.\nMicrosoft, 2014. http://technet.microsoft.com/en-us/\nlibrary/dn747882.aspx.\n\n[19] Loukas, K. Mac EFI Rootkits. Black Hat 2012.\nhttp://ho.ax/De_Mysteriis_Dom_Jobsivs_Black_Hat_\nPaper.pdf.\n\n[20] Bulygin, Y.; Furtak, A.; Bazhaniuk, O. A tale of one\nsoftware bypass of Windows 8 Secure Boot. Black Hat\n2013. https://media.blackhat.com/us-13/us-13-BulyginA-Tale-of-One-Software-Bypass-of-Windows-8Secure-Boot-Slides.pdf.\n\n[21] Kallenberg, C.; Bulygin, Y. All Your Boot Are Belong\nTo Us Intel, MITRE. CanSecWest 2014.\nhttps://cansecwest.com/slides/2014/AllYourBoot_\ncsw14-intel-fi nal.pdf.\n\n[22] Intel CHIPSEC. https://github.com/chipsec/chipsec.\n\n[23] ESET Hidden File System Reader.\nhttp://www.eset.com/int/download//utilities/detail/\nfamily/173/.\n\n[24] Matrosov, A.; Rodionov, E.; Harley, D. Rootkits and\nBootkits: Advanced Malware Analysis. No Starch,\n2015 (in preparation).\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-RodionovMatrosov.pdf"
    ],
    "report_names": [
        "VB2014-RodionovMatrosov.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1410790316,
    "ts_modification_date": 1410790325,
    "files": {
        "pdf": "https://archive.orkl.eu/dc6523e3007d8365af182a52c347c8ead66aa9ee.pdf",
        "text": "https://archive.orkl.eu/dc6523e3007d8365af182a52c347c8ead66aa9ee.txt",
        "img": "https://archive.orkl.eu/dc6523e3007d8365af182a52c347c8ead66aa9ee.jpg"
    }
}