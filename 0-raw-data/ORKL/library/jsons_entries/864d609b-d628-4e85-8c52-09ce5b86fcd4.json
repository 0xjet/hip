{
    "id": "864d609b-d628-4e85-8c52-09ce5b86fcd4",
    "created_at": "2023-01-12T15:01:56.247556Z",
    "updated_at": "2025-03-27T02:05:29.315183Z",
    "deleted_at": null,
    "sha1_hash": "61d972acf3a42c94ae9b42362f16dd8eec0b952d",
    "title": "2022-05-03 - Unpacking Python Executables on Windows and Linux",
    "authors": "",
    "file_creation_date": "2022-05-28T18:21:35Z",
    "file_modification_date": "2022-05-28T18:21:35Z",
    "file_size": 523914,
    "plain_text": "# Unpacking Python Executables on Windows and Linux\n\n**[fortinet.com/blog/threat-research/unpacking-python-executables-windows-linux](https://www.fortinet.com/blog/threat-research/unpacking-python-executables-windows-linux)**\n\nMay 3, 2022\n\nThreat Research\n\nBy [Gergely Revay | May 03, 2022](https://www.fortinet.com/blog/search?author=Gergely+Revay)\n\nTraditional programs written in the python programming language are distributed as source\ncode and the python interpreter is used to run them. This is easy if one runs their own python\ncode; however, it is rather cumbersome to deliver commercial products this way. To help with\nthat, a couple of projects were created that can bundle a python program with all its\ndependencies into an executable file: Portable Executable (PE) on Windows and Executable\nand Linkable Format (ELF) on Linux/Unix.\n\nPython malware is also distributed as such packed executables. And if we talk about malware,\nthe question always come up, “how can we unpack and decompile the malware to look at its\n[python source code?” I discussed this topic in a video I created two years ago. But since then,](https://www.youtube.com/watch?v=jmC-FKNRdvk)\nnew python versions have come out and the unpacking techniques have changed.\n\n\n-----\n\nIn this blog post, we are going to go through the following topics:\n\nPacking\nUnpacking and decompiling on Windows below python version 3.9\nUnpacking and decompiling on Linux after python version 3.9\n\nDifferentiating between the older and newer python versions is important since a lot changed\nafter python 3.9, both in how python bytecode is generated and how (and whether) the source\ncode can be recovered.\n\n**Affected Platforms: Windows, Linux/Unix**\n\n## Packing\n\nFirst of all, let’s discuss what python packaging is—and specifically, PyInstaller. (Note: I use the\nterms packaging, packing, and bundling interchangeably.) The goal of packaging a python\nprogram is to create an executable that can run independently on an operating system. We\nshould not confuse this with general malware packing, where the goal is to hide malicious code\nfrom analysts and security tools. Python packaging does not intend to provide any security or\nobfuscation. It is only a side-effect of the packaging. When we bundle a python program, the\ntool that we use for packaging, such as PyInstaller, does the following:\n\nCompiles all .py source files to python bytecode (.pyc files)\nCollects all python compiled source code and python dependencies\nIncludes the operating system-dependent python interpreter (i.e.; libpython3.9.so.1.0 on\nLinux or python37.dll on Windows)\nBundles all this with a stub that first unpacks these files to disk or memory and then\nexecutes the original python code with the included interpreter.\n\nWhile there are a few projects that can create such packaged executables, the most well-known\n[is PyInstaller.](https://pyinstaller.org/en/stable/)\n\nTo understand how packaging works, we create a packed python executable on Windows.\nFigure 1 shows an extremely sophisticated example program that requires a master’s degree in\ncomputer engineering and around 10 years of experience to create.\n\nFigure 1 - Test program “evil_program.py”\n\nWe can easily run this program in a Windows terminal, as shown in Figure 2.\n\nFigure 2 - Running evil_program.py\n\nTo turn this python program into a packaged EXE file we can use PyInstaller, which I installed in\na python virtual environment (Figure 3).\n\nFigure 3 - Creating an EXE with PyInstaller\n\n\n-----\n\nIt is worth your time to scroll through the logs since they give some insight into what PyInstaller\ndoes under the hood. Once finished, the newly created evil_program.exe is listed under the\n\\dist\\ folder. Figure 4 shows that we can run this executable and get the same result as directly\nrunning the code. The big difference is that we can now move this EXE file to another Windows\nmachine and it should run standalone without any python dependency.\n\nFigure 4 - Running the newly created EXE file\n\n## Unpacking python < 3.9 on Windows\n\nNow that we have a packed EXE file, we can try to revert it back to python source code. In a\nreal reverse engineering scenario, the first question is usually, “how do we find out that the\nanalyzed binary is a packed python program?” The most common clue is that we will see a lot\nof strings starting with py (Figure 5).\n\nFigure 5 - Searching for 'py' in the binary's strings\n\nSpecifically to PyInstaller, we will also see the string MEIPASS in the binary.\n\nThe second question is, “which python version is used by the program?” The easiest way to find\nthis out is to run the program and monitor what files are created in the operating system’s (OS)\ntemporary folder. That’s because PyInstaller first unpacks all files in the temporary folder. By\nmonitoring the filesystem activity, we can see that the python38.dll (Figure 6) is saved in the\ntemporary folder. This tells us that python 3.8 was used to create the packed program and\ntherefore we will need the same python version for all further analysis.\n\nFigure 6 - Monitoring filesystem activity\n\nTo recover the source code, we have to tackle two challenges:\n\n1. Unpack all files from the EXE file. That will give us compiled python bytecode (.pyc) files\n2. Decompile the interesting .pyc files\n\nThe process of unpacking the EXE file will be similar in all versions of python under all\noperating systems. The bigger challenge is decompiling the .pyc files, because that changes in\nevery python version and tools only work with specific versions.\n\n[For unpacking this EXE file, we will use pyinstxtractor. Just download the pyinstxtractor.py to](https://github.com/extremecoders-re/pyinstxtractor)\nthe folder where you want to work with it (Figure 7 shows how to do that). An important detail to\nnote is that the python interpreter used must be the same version as the packed\npython program.\n\nFigure 7 - Unpacking evil_program.exe\n\nAnother important detail is that pyinstxtractor also provides hints as to which files could be the\nmain file of the python program. There are often some false positives, but this is still a huge\nhelp if the analyzed project is big. In this case, we know that the main file is evil program.pyc.\n\n\n-----\n\nThe EXE is unpacked into the evil_program.exe_extracted folder (Figure 8).\n\nFigure 8 - Extracted .pyc files\n\nThe next step is to decompile the evil_program.pyc. For that, we will use a tool\n[called uncompyle6. Again, this is a point where one must be conscious about the python](https://github.com/rocky/python-uncompyle6)\nversion and consult the documentation of the tool being used for decompilation. Uncompyle6\nonly supports up to python 3.8. After that, you will have to look for another tool (which we will\ndiscuss in the next section). The decompilation process is shown in Figure 9.\n\nFigure 9 - Decompiling the evil_program.pyc\n\nWith that, we have reached our goal and recovered the source code of this simple packed\npython program.\n\n## Unpacking python >= 3.9 on Linux\n\nIn this section, we are going to go through the same process under Linux using a newer python\nversion. The file we will analyze is a real malware sample that we found on VirusTotal during\n[our recent threat hunting. More information about this binary can be found on VirusTotal. Once I](https://www.virustotal.com/gui/file/b7b4482f87ca0e532014392f7c099716e4ace647c9f4f8b500839a2d083c3792)\nreverse engineered the file, I thought it would be interesting to write a blog post about the\nunpacking process. We are not going to focus on the analysis of the sample in this post.\n\nTo unpack the sample, we again use pyinstxtractor, but with a [twist. Figure 10 shows that the](https://github.com/extremecoders-re/pyinstxtractor/wiki/Extracting-Linux-ELF-binaries)\nsample is a 64-bit ELF binary. We cannot use pyinstxtractor directly on the ELF binary. So, we\nfirst need to dump the pydata section of the file into a separate file and run pyinstxtractor on\nthat.\n\nFigure 10 - Dump of the pydata section\n\nThe unpacking is shown in Figure 11. Again, we need to be conscious of using the correct\npython version, which in this case is 3.9.\n\nFigure 11 - Unpacking the pydata.dump\n\nThe fact that there is a RansomWare.pyc in the unpacked data makes it obvious what we are\ndealing with.\n\nWith python 3.9 we can no longer use uncompyle6. Instead, we can use a tool\n[like Decompyle++, which is a very promising project that uses a different, more generic,](https://github.com/zrax/pycdc)\napproach to decompilation. However, building the project is not very well explained on the\nwebsite, so Figure 12 shows you how to download and build it.\n\nFigure 12 - Building Decompile++ pycdc\n\nTo call the pycdc command from anywhere, we can also run sudo make install.\n\n\n-----\n\nThe pycdc command is the decompiler, so we use that to recover the source code of the\nRansomWare.pyc, as shown in Figure 13.\n\nFigure 13 - Decompiling the RansomWare.pyc\n\nWith that, we have reached our goal of recovering most of the original source code of\nRansomWare.py. Unfortunately, we may also see functions like the one in Figure 14, where\ndecompilation failed at some point.\n\nFigure 14 - Failed to decompile the write_key() function\n\nThis also happens in Java and .Net when we decompile the bytecode. Sometimes, the\ndecompiler fails and we only get partial code. In such cases, we need to find other ways to\ndetermine what happened in that function, such as dynamic analysis. In this case, we can use\nthe pycdas command to recover the ‘disassembled’ bytecode. There we can look up the\nfunctions, where the decompilation failed. Figure 15 shows the bytecode disassembly of the\nwrite_key() function.\n\nFigure 15 - Bytecode disassembly of the write_key() function\n\nAt the beginning of this section, I mentioned that we won’t be analyzing the sample. It looks like\nransomware, the python code was written for Windows but packed as an ELF executable,\nwhich usually runs on Linux/Unix systems. This may indicate that the sample is intended for the\nWindows Subsystem for Linux (WSL). But that’s a story for another blog post.\n\n## Conclusion\n\nIn this blog post we covered how to unpack and decompile python programs packaged with\nPyInstaller. We also discussed the following scenarios:\n\nWindows\nLinux\nPython versions greater or equal to 3.9\nPython versions lower or equal to 3.8\n\nReverse engineering python malware can be very useful because we can analyze it at a source\ncode level, which of course is much more efficient.\n\n## Fortinet Protection\n\nThe analyzed ransomware sample in this blog is detected by the following (AV) signature:\n\nELF/Filecoder.IG!tr\n\nSince PyInstaller writes the unpacked files on the disk before executing it, FortiEDR is also able\nto identify the malicious content.\n\n\n-----\n\n## IOCs\n\nFor the discussed ransomware sample:\n\n_Hxxps://images[.]idgesg[.]net/images/article/2018/02/ransomware_hacking_thinkstock_903183876-_\n_100749983-large[.]jpg_\n_lynrx_at_protonmail[.]com_\n_fernet_key.txt_\n_EMAIL_ME.txt_\n\n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization and](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-03 - Unpacking Python Executables on Windows and Linux.pdf"
    ],
    "report_names": [
        "2022-05-03 - Unpacking Python Executables on Windows and Linux.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535716,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1653762095,
    "ts_modification_date": 1653762095,
    "files": {
        "pdf": "https://archive.orkl.eu/61d972acf3a42c94ae9b42362f16dd8eec0b952d.pdf",
        "text": "https://archive.orkl.eu/61d972acf3a42c94ae9b42362f16dd8eec0b952d.txt",
        "img": "https://archive.orkl.eu/61d972acf3a42c94ae9b42362f16dd8eec0b952d.jpg"
    }
}