{
    "id": "cca41980-7c2d-4483-8629-0481b2395c04",
    "created_at": "2024-01-13T02:07:02.604256Z",
    "updated_at": "2025-03-27T02:09:51.971325Z",
    "deleted_at": null,
    "sha1_hash": "f9ebf0bee52c3bcf2193f1ab477359918b00da03",
    "title": "",
    "authors": "",
    "file_creation_date": "2024-01-12T10:10:22Z",
    "file_modification_date": "2024-01-12T10:10:22Z",
    "file_size": 2101349,
    "plain_text": "# Operation Triangulation: The last (hardware) mystery\n\n**[securelist.com/operation-triangulation-the-last-hardware-mystery/111669](https://securelist.com/operation-triangulation-the-last-hardware-mystery/111669/)**\n\nAuthors\n\n[Boris Larin](https://securelist.com/author/borislarin/)\n\n[Today, on December 27, 2023, we (Boris Larin, Leonid Bezvershenko, and Georgy](https://twitter.com/oct0xor)\n[Kucherin) delivered a presentation, titled, “Operation Triangulation: What You Get When](https://twitter.com/kucher1n)\nAttack iPhones of Researchers”, at the 37th Chaos Communication Congress (37C3),\nheld at Congress Center Hamburg. The presentation summarized the results of our long[term research into Operation Triangulation, conducted with our colleagues, Igor](https://twitter.com/2igosha)\n[Kuznetsov, Valentin Pashkov, and Mikhail Vinogradov.](https://twitter.com/2igosha)\n\nThis presentation was also the first time we had publicly disclosed the details of all\nexploits and vulnerabilities that were used in the attack. We discover and analyze new\nexploits and attacks using these on a daily basis, and we have discovered and reported\nmore than thirty in-the-wild zero-days in Adobe, Apple, Google, and Microsoft products,\nbut this is definitely the most sophisticated attack chain we have ever seen.\n\n## Operation Triangulation’ attack chain\n\nHere is a quick rundown of this 0-click iMessage attack, which used four zero-days and\nwas designed to work on iOS versions up to iOS 16.2.\n\nAttackers send a malicious iMessage attachment, which the application processes\nwithout showing any signs to the user.\n\n\n-----\n\n[This attachment exploits the remote code execution vulnerability CVE-2023-41990](https://support.apple.com/en-us/HT213842)\nin the undocumented, Apple-only ADJUST TrueType font instruction. This instruction\nhad existed since the early nineties before a patch removed it.\nIt uses return/jump oriented programming and multiple stages written in the\nNSExpression/NSPredicate query language, patching the JavaScriptCore library\nenvironment to execute a privilege escalation exploit written in JavaScript.\nThis JavaScript exploit is obfuscated to make it completely unreadable and to\nminimize its size. Still, it has around 11,000 lines of code, which are mainly\ndedicated to JavaScriptCore and kernel memory parsing and manipulation.\nIt exploits the JavaScriptCore debugging feature DollarVM ($vm) to gain the ability\nto manipulate JavaScriptCore’s memory from the script and execute native API\nfunctions.\nIt was designed to support both old and new iPhones and included a Pointer\nAuthentication Code (PAC) bypass for exploitation of recent models.\n[It uses the integer overflow vulnerability CVE-2023-32434 in XNU’s memory](https://support.apple.com/en-us/103837)\nmapping syscalls (mach_make_memory_entry and vm_map) to obtain read/write\naccess to the entire physical memory of the device at user level.\nIt uses hardware memory-mapped I/O (MMIO) registers to bypass the Page\n[Protection Layer (PPL). This was mitigated as CVE-2023-38606.](https://support.apple.com/en-us/HT213841)\nAfter exploiting all the vulnerabilities, the JavaScript exploit can do whatever it\nwants to the device including running spyware, but the attackers chose to: (a)\nlaunch the IMAgent process and inject a payload that clears the exploitation\nartefacts from the device; (b) run a Safari process in invisible mode and forward it to\na web page with the next stage.\nThe web page has a script that verifies the victim and, if the checks pass, receives\nthe next stage: the Safari exploit.\n[The Safari exploit uses CVE-2023-32435 to execute a shellcode.](https://support.apple.com/en-us/HT213676)\nThe shellcode executes another kernel exploit in the form of a Mach object file. It\n[uses the same vulnerabilities: CVE-2023-32434 and CVE-2023-38606. It is also](https://support.apple.com/en-us/103837)\nmassive in terms of size and functionality, but completely different from the kernel\nexploit written in JavaScript. Certain parts related to exploitation of the abovementioned vulnerabilities are all that the two share. Still, most of its code is also\ndedicated to parsing and manipulation of the kernel memory. It contains various\npost-exploitation utilities, which are mostly unused.\nThe exploit obtains root privileges and proceeds to execute other stages, which load\n[spyware. We covered these stages in our previous posts.](https://securelist.com/trng-2023/)\n\nWe are almost done reverse-engineering every aspect of this attack chain, and we will be\nreleasing a series of articles next year detailing each vulnerability and how it was\nexploited.\n\n\n-----\n\nHowever, there are certain aspects to one particular vulnerability that we have not been\nable to fully understand.\n\n## The mystery and the CVE-2023-38606 vulnerability\n\n[What we want to discuss is related to the vulnerability that has been mitigated as CVE-](https://support.apple.com/en-us/HT213841)\n[2023-38606. Recent iPhone models have additional hardware-based security protection](https://support.apple.com/en-us/HT213841)\nfor sensitive regions of the kernel memory. This protection prevents attackers from\nobtaining full control over the device if they can read and write kernel memory, as\n[achieved in this attack by exploiting CVE-2023-32434. We discovered that to bypass this](https://support.apple.com/en-us/103837)\nhardware-based security protection, the attackers used another hardware feature of\n[Apple-designed SoCs.](https://en.wikipedia.org/wiki/System_on_a_chip)\n\nIf we try to describe this feature and how the attackers took advantage of it, it all comes\ndown to this: they are able to write data to a certain physical address while bypassing the\nhardware-based memory protection by writing the data, destination address, and data\nhash to unknown hardware registers of the chip unused by the firmware.\n\nOur guess is that this unknown hardware feature was most likely intended to be used for\ndebugging or testing purposes by Apple engineers or the factory, or that it was included\nby mistake. Because this feature is not used by the firmware, we have no idea how\nattackers would know how to use it.\n\nWe are publishing the technical details, so that other iOS security researchers can\nconfirm our findings and come up with possible explanations of how the attackers learned\nabout this hardware feature.\n\n\n-----\n\n## Technical details\n\nVarious peripheral devices available in the SoC may provide special hardware registers\nthat can be used by the CPU to operate these devices. For this to work, these hardware\n[registers are mapped to the memory accessible by the CPU and are known as “memory-](https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O)\n[mapped I/O (MMIO)“.](https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O)\n\nAddress ranges for MMIOs of peripheral devices in Apple products (iPhones, Macs, and\n[others) are stored in a special file format: DeviceTree. Device tree files can be extracted](https://www.theiphonewiki.com/wiki/DeviceTree)\n[from the firmware, and their contents can be viewed with the help of the dt utility.](https://github.com/Siguza/dt)\n\n_Example of how MMIO ranges are stored in the device tree_\n\nFor example, in this screenshot, you can see the start (0x210f00000) and the size\n(0x50000) of the acc-impl MMIO range for cpu0.\n\nWhile analyzing the exploit used in the Operation Triangulation attack, I discovered that\nmost of the MMIOs used by the attackers to bypass the hardware-based kernel memory\nprotection do not belong to any MMIO ranges defined in the device tree. The exploit\ntargets Apple A12–A16 Bionic SoCs, targeting unknown MMIO blocks of registers that are\nlocated at the following addresses: 0x206040000, 0x206140000, and 0x206150000.\n\nThe prompted me to try something. I checked different device tree files for different\ndevices and different firmware files: no luck. I checked publicly available source code: no\nluck. I checked the kernel images, kernel extensions, iboot, and coprocessor firmware in\nsearch of a direct reference to these addresses: nothing.\n\nHow could it be that that the exploit used MMIOs that were not used by the firmware?\nHow did the attackers find out about them? What peripheral device(s) do these MMIO\naddresses belong to?\n\nIt occurred to me that I should check what other known MMIOs were located in the area\nclose to these unknown MMIO blocks. That approach was successful.\n\nLet us take a look at a dump of the device tree entry for gfx-asc, which is the GPU\ncoprocessor.\n\n\n-----\n\n_Dump of the device tree entry for gfx-asc_\n\nIt has two MMIO ranges: 0x206400000–0x20646C000 and 0x206050000–0x206050008.\nLet us take a look at how they correlate with the regions used by the exploit.\n\n_Correlation of the gfx-asc MMIO ranges and the addresses used by the exploit_\n\nTo be more precise, the exploit uses the following unknown addresses: 0x206040000,\n0x206140008, 0x206140108, 0x206150020, 0x206150040, and 0x206150048. We can\nsee that most of these are located in the area between the two gfx-asc regions, and the\nremaining one is located close to the beginning of the first gfx-asc region. This suggested\nthat all these MMIO registers most likely belonged to the GPU coprocessor!\n\nAfter that, I took a closer look at the exploit and found one more thing that confirmed my\ntheory. The first thing the exploit does during initialization is writing to some other MMIO\nregister, which is located at a different address for each SoC.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n\nif (cpuid == 0x8765EDEA):  # CPUFAMILY_ARM_EVEREST_SAWTOOTH (A16)\n\nbase = 0x23B700408\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0xDA33D83D): # CPUFAMILY_ARM_AVALANCHE_BLIZZARD\n(A15)\n\nbase = 0x23B7003C8\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0x1B588BB3): # CPUFAMILY_ARM_FIRESTORM_ICESTORM\n(A14)\n\nbase = 0x23B7003D0\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0x462504D2): # CPUFAMILY_ARM_LIGHTNING_THUNDER (A13)\n\nbase = 0x23B080390\n\ncommand = 0x1F0003FF\n\nelif (cpuid == 0x07D34B9F): # CPUFAMILY_ARM_VORTEX_TEMPEST (A12)\n\nbase = 0x23B080388\n\ncommand = 0x1F0003FF\n\nif ((~read_dword(base) & 0xF) != 0):\n\nwrite_dword(base, command)\n\nwhile(True):\n\nif ((~read_dword(base) & 0xF) == 0):\n\n\n-----\n\nbreak\n\n_Pseudocode for the GFX power manager control code from the exploit_\n\n[With the help of the device tree and Siguza’s utility, pmgr, I was able to discover that all](https://github.com/Siguza/dt)\nthese addresses corresponded to the GFX register in the power manager MMIO range.\n\nFinally, I obtained a third confirmation when I decided to try and access the registers\nlocated in these unknown regions. Almost instantly, the GPU coprocessor panicked with a\nmessage of, “GFX SERROR Exception class=0x2f (SError interrupt), IL=1, iss=0 –\npower(1)”.\n\nThis way, I was able to confirm that all these unknown MMIO registers used for the\nexploitation belonged to the GPU coprocessor. This motivated me to take a deeper look\nat its firmware, which is also written in ARM and unencrypted, but I could not find anything\nrelated to these registers in there.\n\nI decided to take a closer look at how the exploit operated these unknown MMIO\nregisters. The register 0x206040000 stands out from all the others because it is located in\na separate MMIO block from all the other registers. It is touched only during the\ninitialization and finalization stages of the exploit: it is the first register to be set during\ninitialization and the last one, during finalization. From my experience, it was clear that\nthe register either enabled/disabled the hardware feature used by the exploit or controlled\ninterrupts. I started to follow the interrupt route, and fairly soon, I was able to recognize\nthis unknown register, 0x206040000, and also discovered what exactly was mapped to\nthe address range of 0x206000000–0x206050000. Below, you can see the reverseengineered code of the exploit that I was able to recognize. I have given it a proper name.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n\ndef ml_dbgwrap_halt_cpu():\n\nvalue = read_qword(0x206040000)\n\nif ((value & 0x90000000) != 0):\n\nreturn\n\nwrite_qword(0x206040000, value | 0x80000000)\n\nwhile (True):\n\nif ((read_qword(0x206040000) & 0x10000000) != 0):\n\nbreak\n\ndef ml_dbgwrap_unhalt_cpu():\n\nvalue = read_qword(0x206040000)\n\nvalue = (value & 0xFFFFFFFF2FFFFFFF) | 0x40000000\n\nwrite_qword(0x206040000, value)\n\nwhile (True):\n\nif ((read_qword(0x206040000) & 0x10000000) == 0):\n\nbreak\n\n\n_Pseudocode for the usage of the, 0x206040000 register by the exploit_\n\n\n-----\n\nI was able to match the ml_dbgwrap_halt_cpu function from the pseudocode above to a\nfunction with the same name in the dbgwrap.c file of the XNU source code. This file\n[contains code for working with the ARM CoreSight MMIO debug registers of the main](https://developer.arm.com/Architectures/CoreSight%20Architecture)\nCPU. The source code states that there are four CoreSight-related MMIO regions, named\nED, CTI, PMU, and UTT. Each occupies 0x10000 bytes, and they are all located next to\none another. The ml_dbgwrap_halt_cpu function uses the UTT region, and the source\ncode states that, unlike the other three, it does not come from ARM, but is a proprietary\nApple feature that was added just for convenience.\n\nI was able to confirm that 0x206000000–0x206050000 was indeed a block of CoreSight\nMMIO debug registers for the GPU coprocessor by writing\nARM_DBG_LOCK_ACCESS_KEY to the corresponding location. Each core of the main\nCPU has its own block of CoreSight MMIO debug registers, but unlike the GPU\ncoprocessor, their addresses can be found in the device tree.\n\nIt is also interesting that the author(s) of this exploit knew how to use the proprietary\nApple UTT region to unhalt the CPU: this code is not part of the XNU source code.\nPerhaps it is fair to say that this could easily be found out through experimentation.\n\nSomething that cannot be found that way is what the attackers did with the registers in\nthe second unknown region. I am not sure what blocks of MMIO debug registers are\nlocated there, or how the attackers found out how to use them if they were not used by\nthe firmware.\n\nLet us look at the remaining unknown registers used by the exploit.\n\nThe registers 0x206140008 and 0x206140108 control enabling/disabling and running the\nhardware feature used by the exploit.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n\ndef dma_ctrl_1():\n\nctrl = 0x206140108\n\nvalue = read_qword(ctrl)\n\nwrite_qword(ctrl, value | 0x8000000000000001)\n\nsleep(1)\n\nwhile ((~read_qword(ctrl) & 0x8000000000000001) != 0):\n\nsleep(1)\n\ndef dma_ctrl_2(flag):\n\nctrl = 0x206140008\n\nvalue = read_qword(ctrl)\n\nif (flag):\n\nif ((value & 0x1000000000000000) == 0):\n\nvalue = value | 0x1000000000000000\n\nwrite_qword(ctrl, value)\n\nelse:\n\nif ((value & 0x1000000000000000) != 0):\n\nvalue = value & ~0x1000000000000000\n\nwrite_qword(ctrl, value)\n\n\n-----\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n\ndef dma_ctrl_3(value):\n\nctrl = 0x206140108\n\nvalue = value | 0x8000000000000000\n\nwrite_qword(ctrl, read_qword(ctrl) & value)\n\nwhile ((read_qword(ctrl) & 0x8000000000000001) != 0):\n\nsleep(1)\n\ndef dma_init(original_value_0x206140108):\n\ndma_ctrl_1()\n\ndma_ctrl_2(False)\n\ndma_ctrl_3(original_value_0x206140108)\n\ndef dma_done(original_value_0x206140108):\n\ndma_ctrl_1()\n\ndma_ctrl_2(True)\n\ndma_ctrl_3(original_value_0x206140108)\n\n\n_Pseudocode for the usage of the 0x206140008 and 0x206140108 registers by the exploit_\n\nThe register 0x206150020 is used only for Apple A15/A16 Bionic SoCs. It is set to 1\nduring the initialization stage of the exploit, and to its original value, during the finalization\nstage.\n\n\n-----\n\nThe register 0x206150040 is used to store some flags and the lower half of the\ndestination physical address.\n\nThe last register, 0x206150048, is used for storing the data that needs to be written and\nthe upper half of the destination physical address, bundled together with the data hash\nand another value (possibly a command). This hardware feature writes the data in aligned\nblocks of 0x40 bytes, and everything should be written to the 0x206150048 register in\nnine sequential writes.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n\nif (cpuid == 0x8765EDEA):  # CPUFAMILY_ARM_EVEREST_SAWTOOTH (A16)\n\ni = 8\n\nmask = 0x7FFFFFF\n\nelif (cpuid == 0xDA33D83D): # CPUFAMILY_ARM_AVALANCHE_BLIZZARD\n(A15)\n\ni = 8\n\nmask = 0x3FFFFF\n\nelif (cpuid == 0x1B588BB3): # CPUFAMILY_ARM_FIRESTORM_ICESTORM\n(A14)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\nelif (cpuid == 0x462504D2): # CPUFAMILY_ARM_LIGHTNING_THUNDER (A13)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\nelif (cpuid == 0x07D34B9F): # CPUFAMILY_ARM_VORTEX_TEMPEST (A12)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\ndma_init(original_value_0x206140108)\n\nhash1 = calculate_hash(data)\n\nhash2 = calculate_hash(data+0x20)\n\n\n-----\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n\nwrite_qword(0x206150040, 0x2000000 | (phys_addr & 0x3FC0))\n\npos = 0\n\nwhile (pos < 0x40):\n\nwrite_qword(0x206150048, read_qword(data + pos))\n\npos += 8\n\nphys_addr_upper = ((((phys_addr >> 14) & mask) << 18) & 0x3FFFFFFFFFFFF)\n\nvalue = phys_addr_upper | (hash1 << i) | (hash2 << 50) | 0x1F\n\nwrite_qword(0x206150048, value)\n\ndma_done(original_value_0x206140108)\n\n\n_Pseudocode for the usage of the 0x206150040 and 0x206150048 registers by the exploit_\n\nAs long as everything is done correctly, the hardware should perform a direct memory\naccess (DMA) operation and write the data to the requested location.\n\nThe exploit uses this hardware feature as a Page Protection Layer (PPL) bypass, mainly\nfor patching page table entries. It can also be used for patching the data in the protected\n__PPLDATA segment. The exploit does not use the feature to patch the kernel code, but\nonce during a test, I was able to overwrite an instruction in the __TEXT_EXEC segment\nof the kernel and get an “Undefined Kernel Instruction” panic with the expected address\nand value. This only worked once—the other times I tried I got an AMCC panic. I have an\nidea about what I did right that one time it worked, and I am planning to look deeper into\nthis in the future, because I think it would be really cool to take a vulnerability that was\nused to harm us and use it for something good, like enabling kernel debugging on new\niPhones.\n\nNow that all the work with all the MMIO registers has been covered, let us take a look at\none last thing: how hashes are calculated. The algorithm is shown below.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n\nsbox = [\n\n0x007, 0x00B, 0x00D, 0x013, 0x00E, 0x015, 0x01F, 0x016,\n\n0x019, 0x023, 0x02F, 0x037, 0x04F, 0x01A, 0x025, 0x043,\n\n0x03B, 0x057, 0x08F, 0x01C, 0x026, 0x029, 0x03D, 0x045,\n\n0x05B, 0x083, 0x097, 0x03E, 0x05D, 0x09B, 0x067, 0x117,\n\n0x02A, 0x031, 0x046, 0x049, 0x085, 0x103, 0x05E, 0x09D,\n\n0x06B, 0x0A7, 0x11B, 0x217, 0x09E, 0x06D, 0x0AB, 0x0C7,\n\n0x127, 0x02C, 0x032, 0x04A, 0x051, 0x086, 0x089, 0x105,\n\n0x203, 0x06E, 0x0AD, 0x12B, 0x147, 0x227, 0x034, 0x04C,\n\n0x052, 0x076, 0x08A, 0x091, 0x0AE, 0x106, 0x109, 0x0D3,\n\n0x12D, 0x205, 0x22B, 0x247, 0x07A, 0x0D5, 0x153, 0x22D,\n\n0x038, 0x054, 0x08C, 0x092, 0x061, 0x10A, 0x111, 0x206,\n\n0x209, 0x07C, 0x0BA, 0x0D6, 0x155, 0x193, 0x253, 0x28B,\n\n0x307, 0x0BC, 0x0DA, 0x156, 0x255, 0x293, 0x30B, 0x058,\n\n0x094, 0x062, 0x10C, 0x112, 0x0A1, 0x20A, 0x211, 0x0DC,\n\n0x196, 0x199, 0x256, 0x165, 0x259, 0x263, 0x30D, 0x313,\n\n0x098, 0x064, 0x114, 0x0A2, 0x15C, 0x0EA, 0x20C, 0x0C1,\n\n0x121, 0x212, 0x166, 0x19A, 0x299, 0x265, 0x2A3, 0x315,\n\n0x0EC, 0x1A6, 0x29A, 0x266, 0x1A9, 0x269, 0x319, 0x2C3,\n\n0x323, 0x068, 0x0A4, 0x118, 0x0C2, 0x122, 0x214, 0x141,\n\n0x221, 0x0F4, 0x16C, 0x1AA, 0x2A9, 0x325, 0x343, 0x0F8,\n\n0x174, 0x1AC, 0x2AA, 0x326, 0x329, 0x345, 0x383, 0x070,\n\n0x0A8, 0x0C4, 0x124, 0x218, 0x142, 0x222, 0x181, 0x241,\n\n0x178, 0x2AC, 0x32A, 0x2D1, 0x0B0, 0x0C8, 0x128, 0x144,\n\n0x1B8, 0x224, 0x1D4, 0x182, 0x242, 0x2D2, 0x32C, 0x281,\n\n0x351 0x389 0x1D8 0x2D4 0x352 0x38A 0x391 0x0D0\n\n\n-----\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n\n0x130, 0x148, 0x228, 0x184, 0x244, 0x282, 0x301, 0x1E4,\n\n0x2D8, 0x354, 0x38C, 0x392, 0x1E8, 0x2E4, 0x358, 0x394,\n\n0x362, 0x3A1, 0x150, 0x230, 0x188, 0x248, 0x284, 0x302,\n\n0x1F0, 0x2E8, 0x364, 0x398, 0x3A2, 0x0E0, 0x190, 0x250,\n\n0x2F0, 0x288, 0x368, 0x304, 0x3A4, 0x370, 0x3A8, 0x3C4,\n\n0x160, 0x290, 0x308, 0x3B0, 0x3C8, 0x3D0, 0x1A0, 0x260,\n\n0x310, 0x1C0, 0x2A0, 0x3E0, 0x2C0, 0x320, 0x340, 0x380\n\n]\n\ndef calculate_hash(buffer):\n\nacc = 0\n\nfor i in range(8):\n\npos = i * 4\n\nvalue = read_dword(buffer + pos)\n\nfor j in range(32):\n\nif (((value >> j) & 1) != 0):\n\nacc ^= sbox[32 * i + j]\n\nreturn acc\n\n\n_Pseudocode for the hash function used by this unknown hardware feature_\n\nAs you can see, it is a custom algorithm, and the hash is calculated by using a predefined\nsbox table. I tried to search for it in a large collection of binaries, but found nothing.\n\nYou may notice that this hash does not look very secure, as it occupies just 20 bits\n(10+10, as it is calculated twice), but it does its job as long as no one knows how to\n[calculate and use it. It is best summarized with the term “security by obscurity“.](https://encyclopedia.kaspersky.com/glossary/security-by-obscurity-security-through-obscurity/?utm_source=securelist&utm_medium=blog&utm_campaign=termin-explanation)\n\n\n-----\n\nHow could attackers discover and exploit this hardware feature if it is not used and there\nare no instructions anywhere in the firmware on how to use it?\n\nI ran one more test. I checked and found that the M1 chip inside the Mac also has this\n[unknown hardware feature. Then I used the amazing m1n1 tool to conduct an](https://github.com/AsahiLinux/m1n1)\nexperiment. This tool has a trace_range function, which traces all access to a provided\nrange of MMIO registers. I used it to set up tracing for the memory range 0x206110000–\n0x206400000, but it reported no usage of these registers by macOS.\n\nThrough an amazing coincidence, both my 37C3 presentation and this post discuss a\nvulnerability very similar to the one I talked about during my presentation at the 36th\nChaos Communication Congress (36C3) in 2019.\n\nIn the presentation titled, “Hacking Sony PlayStation Blu-ray Drives”, I talked about how I\nwas able to dump firmware and achieve code execution on the Blu-ray drives of Sony\nPlayStation 3 and 4 by using MMIO DMA registers that were accessible through SCSI\ncommands.\n\nWatch Video At: https://youtu.be/WW39dsbffMw\n\nI was able to discover and exploit this vulnerability, because earlier versions of the\nfirmware used these registers for all DRAM operations, but then Sony stopped using\nthem and started just accessing DRAM directly, because all DRAM was also mapped to\nthe CPU address space. Because no one was using these registers anymore and I knew\nhow to use them, I took advantage of them. It did not need to know any secret hash\nalgorithm.\n\n\n-----\n\nCould something similar have happened in this case? I do not know that, but this GPU\ncoprocessor first appeared in the recent Apple SoCs. In my personal opinion, based on all\nthe information that I provided above, I highly doubt that this hardware feature was\npreviously used for anything in retail firmware. Nevertheless, there is a possibility that it\nwas previously revealed by mistake in some particular firmware or XNU source code\nrelease and then removed.\n\nI was hoping to find out what was located inside the second unknown region from the fix\nfor this vulnerability implemented in iOS 16.6. I was able to find out how Apple mitigated\nthis issue, but they obfuscated the fix.\n\nApple mitigated this vulnerability by adding the MMIO ranges 0x206000000–\n0x206050000 and 0x206110000–0x206400000 used by the exploit to the pmap-io-ranges\nstored in the device tree. XNU uses the information stored there to determine whether to\nallow mapping of certain physical addresses. All entries stored there have a meaningful\ntag name that explains what kind of memory the range belongs to.\n\n_Example of entries stored in the pmap-io-ranges_\n\nHere, PCIe stands for “Peripheral Component Interconnect Express”, DART stands for\n“Device Address Resolution Table”, DAPF means “Device Address Filter”, and so on.\n\nAnd here are the tag names for regions used by the exploit. They stand out from the rest.\n\n_Entries for regions used by the exploit_\n\n\n-----\n\n## Conclusion\n\nThis is no ordinary vulnerability, and we have many unanswered questions. We do not\nknow how the attackers learned to use this unknown hardware feature or what its original\npurpose was. Neither do we know if it was developed by Apple or it’s a third-party\ncomponent like ARM CoreSight.\n\nWhat we do know—and what this vulnerability demonstrates—is that advanced\nhardware-based protections are useless in the face of a sophisticated attacker as long as\nthere are hardware features that can bypass those protections.\n\nHardware security very often relies on “security through obscurity”, and it is much more\ndifficult to reverse-engineer than software, but this is a flawed approach, because sooner\nor later, all secrets are revealed. Systems that rely on “security through obscurity” can\nnever be truly secure.\n\n## Update 2024-01-09\n\n[Famous hardware hacker Hector Martin (marcan) was able to figure out that what we](https://en.wikipedia.org/wiki/Hector_Martin_(hacker))\nthought was a custom hash was actually something a little different. It is an error\n[correction code (ECC), or more precisely, a Hamming code with a custom lookup table](https://en.wikipedia.org/wiki/Hamming_code)\n(what we call “sbox table” in the text above).\n\nThis discovery helps us understand the original purpose of this unknown hardware\nfeature. We originally thought it was a debugging feature that provided direct memory\naccess to the memory and was protected with a “dummy” hash for extra security. But the\nfact that it involves an ECC, coupled with the unstable behavior observed when trying to\nuse it to patch the kernel code, leads to the conclusion that this hardware feature\nprovides direct memory access to the cache.\n\nThis discovery also raises the possibility that this unused hardware feature could have\nbeen found through experimentation, but to do so would require attackers to solve a large\nnumber of unknown variables. Attackers could find values in a custom lookup table using\nbrute force, but they would also need to know that such a powerful cache debugging\nfeature exists, that it involves Hamming code and, most importantly, they would need to\nknow the location and purpose of all the MMIO registers involved, and how and in what\norder to interact with them. Were the attackers able to resolve all these unknown\nvariables by themselves or was this information revealed somewhere by mistake? It still\nremains a mystery.\n\n[Apple](https://securelist.com/tag/apple/)\n[Malware Technologies](https://securelist.com/tag/malware-technologies/)\n[Reverse engineering](https://securelist.com/tag/reverse-engineering/)\n[Targeted attacks](https://securelist.com/tag/targeted-attacks/)\n[Triangulation](https://securelist.com/tag/triangulation/)\n[Vulnerabilities and exploits](https://securelist.com/tag/vulnerabilities-and-exploits/)\n\n\n-----\n\n[Zero-day vulnerabilities](https://securelist.com/tag/zero-day-vulnerabilities/)\nOperation Triangulation: The last (hardware) mystery\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2023/2023.12.27.Operation_Triangulation/Operation%20Triangulation_%20The%20last%20%28hardware%29%20mystery%20_%20Securelist.pdf"
    ],
    "report_names": [
        "Operation Triangulation_ The last (hardware) mystery _ Securelist"
    ],
    "threat_actors": [
        {
            "id": "ad08bd3d-e65c-4cfd-874a-9944380573fd",
            "created_at": "2023-06-23T02:04:34.517668Z",
            "updated_at": "2025-03-27T02:02:10.081419Z",
            "deleted_at": null,
            "main_name": "Operation Triangulation",
            "aliases": [],
            "source_name": "ETDA:Operation Triangulation",
            "tools": [
                "TriangleDB"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bc289ba8-bc61-474c-8462-a3f7179d97bb",
            "created_at": "2022-10-25T16:07:24.450609Z",
            "updated_at": "2025-03-27T02:02:10.235933Z",
            "deleted_at": null,
            "main_name": "Avalanche",
            "aliases": [],
            "source_name": "ETDA:Avalanche",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "113b8930-4626-4fa0-9a3a-bcf3ef86f595",
            "created_at": "2024-02-06T02:00:04.14393Z",
            "updated_at": "2025-03-27T02:00:03.324612Z",
            "deleted_at": null,
            "main_name": "Operation Triangulation",
            "aliases": [],
            "source_name": "MISPGALAXY:Operation Triangulation",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1705111622,
    "ts_updated_at": 1743041391,
    "ts_creation_date": 1705054222,
    "ts_modification_date": 1705054222,
    "files": {
        "pdf": "https://archive.orkl.eu/f9ebf0bee52c3bcf2193f1ab477359918b00da03.pdf",
        "text": "https://archive.orkl.eu/f9ebf0bee52c3bcf2193f1ab477359918b00da03.txt",
        "img": "https://archive.orkl.eu/f9ebf0bee52c3bcf2193f1ab477359918b00da03.jpg"
    }
}