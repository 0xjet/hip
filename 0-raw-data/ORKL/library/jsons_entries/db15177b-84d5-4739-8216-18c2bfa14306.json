{
    "id": "db15177b-84d5-4739-8216-18c2bfa14306",
    "created_at": "2023-01-12T15:04:50.074732Z",
    "updated_at": "2025-03-27T02:05:23.572936Z",
    "deleted_at": null,
    "sha1_hash": "790da4bd8a76925fd385604faf5232ec8dd9c2bb",
    "title": "2022-04-04 - Sharing is Caring- Abusing Shared Sections for Code Injection",
    "authors": "",
    "file_creation_date": "2022-05-27T23:17:28Z",
    "file_modification_date": "2022-05-27T23:17:28Z",
    "file_size": 1076264,
    "plain_text": "# Sharing is Caring: Abusing Shared Sections for Code Injection\n\n**[billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/](https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/)**\n\nBill Demirkapi April 4, 2022\n\n[Security Research](https://billdemirkapi.me/tag/security-research/)\nIn this article, we will explore how to abuse certain quirks of PE Sections to place arbitrary\nshellcode into the memory of a remote process without requiring direct process access.\n\n**[Bill Demirkapi](https://billdemirkapi.me/author/bill/)**\n\nApr 4, 2022 • 8 min read\n\n\n-----\n\nMoving laterally across processes is a common technique seen in malware in order to\nspread across a system. In recent years, Microsoft has moved towards adding security\ntelemetry to combat this threat through the \"Microsoft-Windows-Threat-Intelligence\" ETW\nprovider.\n\n[This increased telemetry alongside existing methods such as ObRegisterCallbacks has](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks)\nmade it difficult to move laterally without exposing malicious operations to kernel-visible\ntelemetry. In this article, we will explore how to abuse certain quirks of PE Sections to place\narbitrary shellcode into the memory of a remote process without requiring direct process\naccess.\n\n## Background\n\nExisting methods of moving laterally often involve dangerous API calls such as OpenProcess\nto gain a process handle accompanied by memory-related operations such as VirtualAlloc,\nVirtualProtect, or WriteProcessMemory. In recent years, the detection surface for these\noperations has increased.\n\nFor example, on older versions of Windows, one of the only cross-process API calls that\nkernel drivers had documented visibility into was the creation of process and thread handles\nvia ObRegisterCallbacks.\n\nThe visibility introduced by Microsoft’s threat intelligence ETW provider has expanded to\ncover operations such as:\n\n1. Read/Write virtual memory calls ( EtwTiLogReadWriteVm ).\n2. Allocation of executable memory ( EtwTiLogAllocExecVm ).\n\n\n-----\n\n3. Changing the protection of memory to executable ( EtwTiLogProtectExecVm ).\n4. Mapping an executable section ( EtwTiLogMapExecView ).\n\nOther methods of entering the context of another process typically come with other detection\nvectors. For example, another method of moving laterally may involve disk-based attacks\nsuch as [Proxy Dll Injection. The problem with these sort-of attacks is that they often require](https://dl.packetstormsecurity.net/papers/win/intercept_apis_dll_redirection.pdf)\nwriting malicious code to disk which is visible to kernel-based defensive solutions.\n\nSince these visible operations are required by known methods of cross-process movement,\none must start looking beyond existing methods for staying ahead of telemetry available to\ndefenders.\n\n## Discovery\n\n[Recently I was investigating the extents you could corrupt a Portable Executable (PE) binary](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)\nwithout impacting its usability. For example, could you corrupt a known malicious tool such\nas [Mimikatz to an extent that wouldn't impact its operability but would break the image](https://github.com/gentilkiwi/mimikatz)\nparsers built into anti-virus software?\n\nSimilar to ELF executables in Linux, Windows PE images are made up of \"sections\". For\nexample, code is typically stored in a section called `.text, mutable data can be found in`\n```\n.data, and read-only data is generally in .rdata . How does the operating system know\n\n```\nwhat sections contain code or should be writable? Each section has \"characteristics\" which\ndefines how they are allocated.\n\n[There are over 35 documented characteristics for PE sections. The most common include](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags)\n```\nIMAGE_SCN_MEM_EXECUTE, IMAGE_SCN_MEM_READ, and IMAGE_SCN_MEM_WRITE which\n\n```\ndefine if a section should be executable, readable, and/or writeable. These only represent a\nsmall fraction of the possibilities for PE sections however.\n\nWhen attempting to corrupt the PE section header, one specific flag caught my eye:\n\n\"IMAGE_SCN_MEM_SHARED\" characteristic\nAccording to Microsoft's documentation, the `IMAGE_SCN_MEM_SHARED flag means that \"the`\nsection can be shared in memory\". What does this exactly mean? There isn't much\ndocumentation on the use of this flag online, but it turned out that if this flag is enabled, that\n\n\n-----\n\nsection s memory is shared across all processes that have the image loaded. For\nexample, if process A and B load a PE image with a section that is \"shared\" (and writable),\nany changes in the memory of that section in process A will be reflected in process B.\n\nSome research relevant to the theory we will discuss in this article is DLL shared sections:\n**a ghost of the past by** [Gynvael Coldwind. In his paper, Coldwind explored the potential](https://twitter.com/gynvael)\nvulnerabilities posed by binaries with PE sections that had the `IMAGE_SCN_MEM_SHARED`\ncharacteristic.\n\nColdwind explained that the risk posed by these PE images \"is an old and well-known\nsecurity problem\" with a reference to an article from Microsoft published in 2004 titled Why\n_shared sections are a security hole. The paper only focused on the threat posed by_\n\"Read/write shared sections\" and \"Read/only shared sections\" without addressing a third\noption, \"Read/write/execute shared sections\".\n\n## Exploiting Shared Sections\n\nAlthough the general risk of shared sections has been known by researchers and Microsoft\nthemselves for quite some time, there has not been significant investigation to the potential\nabuse of shared sections that are readable, writable, and executable (RWX-S).\n\nThere is great offensive potential for RWX-S binaries because if you can cause a remote\nprocess to load an RWX-S binary of your choice, you now have an executable memory page\nin the remote process that can be modified without being visible to kernel-based defensive\nsolutions. To inject code, an attacker could load an RWX-S binary into their process, edit the\nsection with whatever malicious code they want in memory, load the RWX-S binary into the\nremote process, and the changes in their own process would be reflected in the victim\nprocess as well.\n\nThe action of loading the RWX-S binary itself would still be visible to defensive solutions, but\nas we will discuss in a later section, there are plenty of options for legitimate RWX-S binaries\nthat are used outside of a malicious context.\n\nThere are a few noteworthy comments about using this technique:\n\n1. An attacker must be able to load an RWX-S binary into the remote process. This binary\n\ndoes not need to contain any malicious code other than a PE section that is RWX-S.\n2. If the RWX-S binary is x86, LoadLibrary calls inside of an x64 process will fail. x86\n\nbinaries can still be manually mapped inside x64 processes by opening the file,\ncreating a section with the attribute `SEC_IMAGE, and mapping a view of the section.`\n3. RWX-S binaries are not shared across sessions. RWX-S binaries are shared by\n\nunprivileged and privileged processes in the same session.\n\n\n-----\n\n4. Modifications to shared sections are not written to disk. For example, the buffer\n\nreturned by both ReadFile and mapping the image with the attribute `SEC_COMMIT do`\nnot contain any modifications on the shared section. Only when the binary is mapped\nas `SEC_IMAGE will these changes be present. This also means that any modifications`\nto the shared section will not break the authenticode signature on disk.\n5. Unless the used RWX-S binary has its entrypoint inside of the shared executable\n\nsection, an attacker must be able to cause execution at an arbitrary address in the\nremote process. This does not require direct process access. For example,\n[SetWindowsHookEx could be used to execute an arbitrary pointer in a module without](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa)\ndirect process access.\n\nIn the next sections, we will cover practical implementations for this theory and the\nprevalence of RWX-S host binaries in the wild.\n\n## Patching Entrypoint to Gain Execution\n\nIn certain cases, the requirement for an attacker to be able to execute an arbitrary pointer in\nthe remote process can be bypassed.\n\nIf the RWX-S host binary has its entrypoint located inside of an RWX-S section, then an\nattacker does not need a special execution method.\n\nInstead, before loading the RWX-S host binary into the remote process, an attacker can\npatch the memory located at the image's entrypoint to represent any arbitrary shellcode to be\nexecuted. When the victim process loads the RWX-S host binary and attempts to execute\nthe entrypoint, the attacker's shellcode will be executed instead.\n\n## Finding RWX-S Binaries In-the-Wild\n\nOne of the questions that this research attempts to address is \"How widespread is the RWX[S threat?\". For determining the prevalence of the technique, I used VirusTotal's Retrohunt](https://support.virustotal.com/hc/en-us/articles/360001293377-Retrohunt)\nfunctionality which allows users to \"scan all the files sent to VirusTotal in the past 12 months\nwith ... YARA rules\".\n\nFor detecting unsigned RWX-S binaries in-the-wild, a custom YARA rule was created that\nchecks for an RWX-S section in the PE image:\n\n\n-----\n\n```\nimport pe \nrule RWX_S_Search\n{\n     meta:\n          description = \"Detects RWX-S binaries.\"\n          author = \"Bill Demirkapi\"\n     condition:\n          for any i in (0..pe.number_of_sections - 1): (\n              (pe.sections[i].characteristics & pe.SECTION_MEM_READ) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_EXECUTE) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_WRITE) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_SHARED) )\n}\n\n```\nAll this rule does is enumerate a binaries' PE sections and checks if it is readable, writable,\nexecutable, and shared.\n\nWhen this rule was searched via Retrohunt, over 10,000 unsigned binaries were found\n(Retrohunt stops searching beyond 10,000 results).\n\nWhen this rule was searched again with a slight modification to check that the PE image is\nfor the `MACHINE_AMD64 machine type, there were only 99 x64 RWX-S binaries.`\n\nThis suggests that RWX-S binaries for x64 machines have been relatively uncommon for the\npast 12 months and indicates that defensive solutions may be able to filter for RWX-S\nbinaries without significant noise on protected machines.\n\nIn order to detect signed RWX-S binaries, the YARA rule above was slightly modified to\ncontain a check for authenticode signatures.\n```\nimport \"pe\"\nrule RWX_S_Signed_Search\n{\n     meta:\n          description = \"Detects RWX-S signed binaries. This only verifies that\nthe image contains a signature, not that it is valid.\"\n          author = \"Bill Demirkapi\"\n     condition:\n          for any i in (0..pe.number_of_sections - 1): (\n              (pe.sections[i].characteristics & pe.SECTION_MEM_READ) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_EXECUTE) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_WRITE) and\n              (pe.sections[i].characteristics & pe.SECTION_MEM_SHARED) )\n          and pe.number_of_signatures > 0\n}\n\n```\nUnfortunately with YARA rules, there is not an easy way to determine if a PE image contains\nan authenticode signature that has a valid certificate that has not expired or was signed with\na valid timestamp during the certificate's life. This means that the YARA rule above will\n\n\n-----\n\ncontain some false positives of binaries with invalid signatures. Since there were false\npositives, the rule above did not immediately provide a list of RWX-S binaries that have a\nvalid authenticode signature. To extract signed binaries, a simple Python script was written\nthat downloaded each sample below a detection threshold and verified the signature of each\nbinary.\n\nAfter this processing, approximately 15 unique binaries with valid authenticode signatures\nwere found. As seen with unsigned binaries, signed RWX-S binaries are not significantly\ncommon in-the-wild for the past 12 months. Additionally, only 5 of the 15 unique signed\nbinaries are for x64 machines. It is important to note that while this number may seem low,\nsigned binaries are only a convenience and are certainly not required in most situations.\n\n## Abusing Unsigned RWX-S Binaries\n\n Patching Unsigned Binaries\n\n[Given that mitigations such as User-Mode Code Integrity have not experienced widespread](https://docs.microsoft.com/en-us/windows/security/threat-protection/device-guard/introduction-to-device-guard-virtualization-based-security-and-windows-defender-application-control)\nadoption, patching existing unsigned binaries still remains a viable method.\n\nTo abuse RWX-S sections with unsigned binaries, an attacker could:\n\n1. Find a legitimate host unsigned DLL to patch.\n2. Read the unsigned DLL into memory and patch a section's characteristics to be\n\nreadable, writable, executable, and shared.\n3. Write this new patched RWX-S host binary somewhere on disk before using it.\n\nHere are a few suggestions for maintaining operational security:\n\n1. It is recommended that an attacker does not patch an existing binary on disk. For\n\nexample, if an attacker only modified the section characteristics of an existing binary\nand wrote this patch to the same path on disk, defensive solutions could detect that an\nRWX-S patch was applied to that existing file. Therefore, it is recommended that\npatched binaries be written to a different location on disk.\n2. It is recommended that an attacker add other patches besides just RWX-S. This can be\n\nmodifying other meaningless properties around the section's characteristics or\nmodifying random parts of the code (it is important that these changes do not appear\nmalicious). This is to make it harder to differentiate when an attacker has specifically\napplied an RWX-S patch on a binary.\n\n## Using Existing Unsigned Binaries\n\nCreating a custom patched binary is not required. For example, using the YARA rule in the\nprevious section, an attacker could use any of the existing unsigned RWX-S binaries that\nmay be used in legitimate applications.\n\n\n-----\n\n## Abusing Signed RWX-S Binaries in the Kernel\n\nAlthough there were only 15 signed RWX-S binaries discovered in the past 12 months, the\nfact that they have a valid authenticode signature can be useful during exploitation of\nprocesses that may require signed modules.\n\nOne interesting signed RWX-S binary that the search revealed was a signed driver. When\nattempting to test if shared sections are replicated from user-mode to kernel-mode, it was\nrevealed that the memory is not shared, even when the image is mapped and modified by a\nprocess in Session 0.\n\n## Conclusion\n\nAlthough the rarity of shared sections presents a unique opportunity for defenders to obtain\nhigh-fidelity telemetry, RWX-S binaries still serve as a powerful method that break common\nassumptions regarding cross-process memory allocation and execution. The primary\nchallenge for defenders around this technique is its prevalence in unsigned code. It may be\nrelatively simple to detect RWX-S binaries, but how do you tell if it is used in a legitimate\napplication?\n\n_[Shameless plug: Interested in my work? I am currently looking for a new position.](https://bit.ly/3x1Smw4)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-04 - Sharing is Caring- Abusing Shared Sections for Code Injection.pdf"
    ],
    "report_names": [
        "2022-04-04 - Sharing is Caring- Abusing Shared Sections for Code Injection.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535890,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653693448,
    "ts_modification_date": 1653693448,
    "files": {
        "pdf": "https://archive.orkl.eu/790da4bd8a76925fd385604faf5232ec8dd9c2bb.pdf",
        "text": "https://archive.orkl.eu/790da4bd8a76925fd385604faf5232ec8dd9c2bb.txt",
        "img": "https://archive.orkl.eu/790da4bd8a76925fd385604faf5232ec8dd9c2bb.jpg"
    }
}