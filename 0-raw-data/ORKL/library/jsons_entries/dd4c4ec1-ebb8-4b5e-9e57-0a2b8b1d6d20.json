{
    "id": "dd4c4ec1-ebb8-4b5e-9e57-0a2b8b1d6d20",
    "created_at": "2023-01-12T14:59:02.91894Z",
    "updated_at": "2025-03-27T02:17:01.605934Z",
    "deleted_at": null,
    "sha1_hash": "6de96ee3bffe6b7c8fbe160fbab20a91343352d6",
    "title": "2021-11-30 - Just another analysis of the njRAT malware – A step-by-step approach",
    "authors": "",
    "file_creation_date": "2022-05-27T23:04:13Z",
    "file_modification_date": "2022-05-27T23:04:13Z",
    "file_size": 3593665,
    "plain_text": "# Just another analysis of the njRAT malware – A step-by-step approach\n\n**[cybergeeks.tech/just-another-analysis-of-the-njrat-malware-a-step-by-step-approach/](https://cybergeeks.tech/just-another-analysis-of-the-njrat-malware-a-step-by-step-approach/)**\n\nSummary\n\nnjRAT (Bladabindi) is a .NET RAT (Remote Access Trojan) that allows attackers to take control of\nan infected machine. This malware has been used by APT actors in targeted attacks in Colombia\n(https://www.welivesecurity.com/2021/01/12/operation-spalax-targeted-malware-attacks[colombia/), by SideCopy (https://blog.talosintelligence.com/2021/07/sidecopy.html) and has been](https://blog.talosintelligence.com/2021/07/sidecopy.html)\ndistributed via phishing emails (https://labs.k7computing.com/index.php/malspam-campaignsdownload-njrat-from-paste-sites/). The version number in our analysis is 0.6.4 and the campaign\nID is “splitgateukrayna”. The following commands have been implemented: “proc”, “rss”, “rs”, “rsc”,\n“kl”, “inf”, “prof”, “rn”, “inv”, “ret”, “CAP”, “P”, “un”, “up”, “RG”. njRAT can also act as a keylogger\nbecause it records the pressed keys in a file which can be exfiltrated using the “kl” command. The\nrest of the commands will be explained in great detail in the Technical analysis section.\n\n**Analyst:** [@GeeksCyber](https://twitter.com/GeeksCyber)\n\nTechnical analysis\n\n**Disclaimer: We’re aware that there are some njRAT builders available that can be used to**\ngenerate executables however, we’re not interested in these tools, and we’ve performed the\nanalysis with zero knowledge from those.\n\nSHA256: 833f86074592648c0a758098e34ab605a2b922d94dbab7141e2ce87acec03c35\n\nThe analysis has been performed using dnSpy.\n\nThe malware tries to open a mutex called “49e91d08e684b1770e0cefa60401157a” using the\nOpenExisting method. If the mutex already exists, the process exits:\n\nFigure 1\n\nA new mutex named “49e91d08e684b1770e0cefa60401157a” is created by calling the Mutex\nconstructor:\n\nFigure 2\n\n\n-----\n\nThe path for the executable file that started the application is compared with\n“%AppData%\\services64.exe”. The malware authors implemented a function called “CompDir”,\nwhich compares the name of the files and the name of the directories:\n\nFigure 3\n\nFigure 4\nIf the above file exists (“services64.exe”), it’s deleted using the Delete function:\n\nFigure 5\nThe initial executable file is copied to “%AppData%\\services64.exe”. The new file is executed\nusing the Start method, and the current process exits:\n\nFigure 6\nThe binary sets the environment variable “SEE_MASK_NOZONECHECKS” to 1, which removes\nthe open file security warnings:\n\nFigure 7\nA new program-based exception is added to Windows Firewall using netsh (the program being the\nnewly created executable):\n\n\n-----\n\nFigure 8\n\nA new entry called “49e91d08e684b1770e0cefa60401157a” is added to the Run registry key. This\nrepresents a persistence mechanism, and the malware will run whenever the current user logs on:\n\nFigure 9\n\nFigure 10\nThere is a 2nd persistence mechanism that is not enabled in the malware. It would copy the\nexecutable to the Startup folder, as shown below:\n\nFigure 11\nThe RAT initializes a new instance of the Thread class by specifying the ThreadStart method:\n\nFigure 12\nA new TcpClient object is created by the executable. The malware establishes a connection to the\nC2 server 44gang44.duckdns[.]org (dynamic DNS service) on port 2222:\n\nFigure 13\nThe volume serial number for the C drive is extracted using the GetVolumeInformation API:\n\n\n-----\n\nFigure 14\nThe file retrieves the computer name and user name using the GetComputerName and\nGetUserName functions:\n\nFigure 15\n\nFigure 16\nThe last write time of the executable is obtained from the LastWriteTime property, as highlighted in\nfigure 17:\n\nFigure 17\nThe full operating system name is retrieved from the OSFullName property:\n\nFigure 18\nnjRAT determines the architecture of the system by checking the existence of the “Program Files\n(x86)” directory (it only exists on 64-bit systems):\n\n\n-----\n\nFigure 19\nThe capGetDriverDescriptionA API is utilized to check for the existence of a Webcam:\n\nFigure 20\nGetForegroundWindow is used to get a handle to the foreground window (the window with which\nthe user is currently working). The GetWindowText function copies the text of the foreground\nwindow’s title bar into a buffer. GetWindowThreadProcessId is used to retrieve the thread’s\nidentifier that created the foreground window, along with the process’ identifier that created the\nwindow. The result of the function is represented by the MainWindowTitle property of the process\nextracted before, which is Base64 encoded:\n\n\n-----\n\nFigure 21\nThe malware creates the\n“HKEY_CURRENT_USER\\Software\\49e91d08e684b1770e0cefa60401157a” registry key:\n\nFigure 22\nThe buffer that contains the following information is sent to the C2 server:\n\nBase64 of Campaign ID + volume serial number\nComputer name\nUser name\nLast write time of the malicious file\nOperating system name + system’s architecture\nWhether a Webcam is detected\nnjRAT Version\nBase64 of the main window title of the process\n\n\n-----\n\nFigure 23\nThe C2 response is copied into a buffer using the Receive method:\n\nFigure 24\nThe C2 server was emulated using FakeNet. The binary expects a response that contains\ninstructions separated by the “|’|’|” separator. Multiple commands are implemented by njRAT, as\nwe’ll describe later on:\n\nFigure 25\n**Keylogger functionalities**\n\nEvery pressed key is compared with multiple function/special keys:\n\nFigure 26\nIf the keys aren’t function/special keys, they’re mapped from virtual-key code into a scan code or\ncharacter value by calling the MapVirtualKey function. GetKeyboardLayout is utilized to retrieve\nthe active input locale identifier. The ToUnicodeEx API is utilized to translate the virtual-key code\nand keyboard state to the corresponding Unicode character:\n\n\n-----\n\nFigure 27\nThe GetAsyncKeyState API is utilized to determine whether a key is up or down:\n\nFigure 28\nThe window title of the process where the input is detected is also included in the logs file:\n\nFigure 29\nThe binary creates a file called “services64.exe.tmp” in the same directory, where the keylogger\ndata is stored. The WriteAllText method is utilized to populate the file:\n\nFigure 30\nAn example of a log file is displayed in figure 31:\n\n\n-----\n\nFigure 31\n\nNow we describe the commands implemented by njRAT.\n\n**“proc” command**\n\nCase 1 – “proc|’|’|~” (OK.Y == |’|’|) – retrieve information about the current process and the other\nrunning processes\n\nThe current process ID is retrieved and sent to the C2 server by calling the GetCurrentProcess\nfunction. The number of processes running on the host is also transmitted to the C2 server:\n\nFigure 32\nThe malware extracts the description of the files using the FileVersionInfo.FileDescription property,\nand then encodes it using the Base64 algorithm. For each process, a string that contains the\nprocess ID, the full path to the process, and the encoded file description (if available), is\nconstructed:\n\nFigure 33\n\n\n-----\n\nIn the case of Windows processes, the execution flow is different however, the scope is the same:\n\nFigure 34\nThe buffer that contains the concatenation of the strings computed above is exfiltrated to the C2\nserver:\n\nFigure 35\nCase 2 – “proc|’|’|k|’|’|<Process ID>” – kill a process\n\nThe process that corresponds to the process ID transmitted by the C2 server is stopped by calling\nthe Kill method. If successful, the malware sends a custom message to the server, otherwise it\nsends an exception message:\n\n\n-----\n\nFigure 36\nCase 3 – “proc|’|’|kd|’|’|<Process ID>” – kill a list of processes and delete the module files\n\nFirstly, the binary repeats the same procedure from above. It also extracts the full path to the\nprocess:\n\nFigure 37\nThe RAT tries to delete the file that corresponds to the above process. If successful, it sends a\nconfirmation message to the C2 server:\n\nFigure 38\nCase 4 – “proc|’|’|re|’|’|<Process ID>” – restart a process\n\nThe binary repeats the same procedure from above. It also extracts the full path to the process:\n\n\n-----\n\nFigure 39\nnjRAT executes the file extracted above. If successful, it sends a confirmation message to the C2\nserver:\n\nFigure 40\n**“rss” command – start a hidden command prompt and redirect the StandardOutput and**\nStandardError to the C2 server\n\nThe malware creates a “cmd.exe” process object and sets to true multiple values that indicate the\nfollowing: the error output should be written to StandardError, the input should be read from\nStandardInput, and the output should be written to StandardOutput. The method that will\nhandle the OutputDataReceived and ErrorDataReceived events of the newly created process is\nset to a function called “RS”. The method that will handle the Process.Exited events is set to a\nfunction called “ex”. The new process is started, and it begins read operations on the redirected\nStandardOutput and StandardError streams of the application:\n\nFigure 41\n\n\n-----\n\nThe RAT retrieves a late-bound value called Data, which represents the\nStandardError/StandardOutput of the cmd.exe process that is Base64 encoded and sent to the C2\nserver:\n\nFigure 42\nThe output of the cmd.exe process can be seen in the network traffic:\n\nFigure 43\nFigure 44 displays the cmd.exe process as the child of the initial process (Process Hacker tool):\n\nFigure 44\nIn the case of a Process.Exited event, the “ex” function just sends the string “rsc” to the C2:\n\nFigure 45\n\n**“rs|’|’|<Base64 command>” command – send a command to be executed by the hidden**\ncommand prompt\n\nThe C2 server can specify a command that is decoded using the Base64 algorithm, which is given\nas input to the cmd.exe process created earlier:\n\nFigure 46\nIt’s important to mention that the malware performs sanity checks and sends an exception\nmessage to the C2 if any error occurs in any case:\n\n\n-----\n\nFigure 47\n**“rsc” command – kill the hidden command prompt created earlier**\n\nThe command prompt process created earlier is killed by the RAT:\n\nFigure 48\n**“kl” command – exfiltrate the keylogger’s log file**\n\nThe content of the Logs variable, which is the output of the keylogger described above, is Base64\nencoded and exfiltrated to the C2 server:\n\nFigure 49\n**“inf” command – retrieve information about the volume serial number and malware configuration**\n(C2 server, process name, etc.)\n\nThe file checks the “HKCU\\Software\\49e91d08e684b1770e0cefa60401157a\\vn” registry value,\nwhich doesn’t exist at this time. The binary extracts again the volume serial number for the C drive\nand combines it with the following information: C2 server, C2 port number, the AppData folder, the\nname of the executable, and the process name. The resulting string is transmitted to the C2:\n\n\n-----\n\nFigure 50\n**“prof” command**\n\nCase 1 – “prof|’|’|~|’|’|<RegistryValue>|’|’|<Data>” – create a registry value in a specific registry key\n\nThe malware creates a value under\n“HKEY_CURRENT_USER\\Software\\49e91d08e684b1770e0cefa60401157a” and writes some\ndata to it:\n\nFigure 51\n\n\n-----\n\nCase 2 – prof| | |!| | |<RegistryValue>| | |<Data> - create a registry value in a specific registry key\nand retrieve the “!” registry value\n\nThe binary repeats the same operation from above:\n\nFigure 52\nThe RAT is looking to extract a value called “!” from the same registry key. The value’s content is\nsent to the C2 server:\n\nFigure 53\n\nFigure 54\nCase 3 – “prof|’|’|@|’|’|<RegistryValue>” – delete a registry value from a specific registry key\n\nnjRAT deletes the specified value from the same registry key, as highlighted in figure 55:\n\nFigure 55\n**“rn” command**\n\n\n-----\n\nCase 1 – rn| | |<Extension>| | |<URL> – download and run a file from the URL\n\nThe executable downloads the resource specified by the URL and stores the result as a Byte\narray by calling the DownloadData method:\n\nFigure 56\nThe array computed above will be stored in a file that is created in the TEMP directory. The file\nname is randomly generated and consists of 10 lowercase letters:\n\nFigure 57\n\nFigure 58\nThe new file is executed by calling the Start function, and a confirmation message is transmitted to\nthe C2:\n\nFigure 59\nCase 2 – “rn|’|’|<Extension>|’|’|<Base64 (Gzip compressed executable)>” – decode, decompress,\nand execute the executable\n\n\n-----\n\nThe file decodes the Base64 encoded content and then decompresses it using the ZIP function\n(depending on the flag, this function could also be used to Gzip compress content):\n\nFigure 60\n\nFigure 61\nAs in the first case, the content will be written to a file in the TEMP directory, and a confirmation\nmessage is sent to the C2 server.\n\n**“inv|’|’|<RegistryValue>|’|’|<String1>|’|’|<String2>” command – njRAT has plugins that can be**\ndownloaded, saved in registry keys, and then executed\n\nThe RAT checks the existence of the RegistryValue value under\n“HKCU\\Software\\49e91d08e684b1770e0cefa60401157a”:\n\n\n-----\n\nFigure 62\nWhether the above value doesn’t exist and array[3] has a length of 1, the malware sends a\nmessage to the C2 and finishes the command:\n\nFigure 63\nWhether the above value exists, its content is decoded using Base64, and a different message is\nforwarded to the C2 server:\n\nFigure 64\nFrom our analysis, this file is supposed to be a plugin of njRAT. The assembly is loaded via a\nfunction call to Assembly.Load and all the modules that are part of it are extracted using the\nGetModules method. The binary extracts the types defined in each module and expects some of\nthem to have a name that ends with “.A” (a class called “A” should be defined). For each of these\ntypes found, the process creates an instance of it using the system activator:\n\nFigure 65\n\n\n-----\n\nFigure 66\nThe binary calls the LateSet method multiple times in order to execute multiple late-bound field\nwrite calls. Basically, variables such as “h”, “p”, “osk”, “off” are set to OK.H (C2 domain), OK.P (C2\nport number), array[2] (this is provided by the C2) and “true”. The malware calls the plugin’s\nfunction called “start”:\n\nFigure 67\nWhether the registry value mentioned above doesn’t exist and array[3] has a length greater than\n1, array[3] is Base64 decoded, and then Gzip decompressed:\n\nFigure 68\nThe RegistryValue value is created under\n“HKEY_CURRENT_USER\\Software\\49e91d08e684b1770e0cefa60401157a”. The content from\nabove that was decompressed is encoded using Base64 and stored in this value:\n\nFigure 69\nThe same steps starting with loading the assembly (above figure 65) are executed one more time.\n\n\n-----\n\n**ret| | |<RegistryValue>| | |<String> command – similar to the inv command, this command**\ncan be used to execute a malicious assembly found in a registry key or transmitted by the C2\nserver\n\nThe process checks the existence of the RegistryValue value under\n“HKCU\\Software\\49e91d08e684b1770e0cefa60401157a”:\n\nFigure 70\nWhether the above value doesn’t exist and array[2] has a length of 1, the malware sends a\nmessage to the C2 and finishes the command:\n\nFigure 71\nWhether the above value exists, its content is decoded using Base64, and a different message is\nforwarded to the C2 server:\n\nFigure 72\nThe same execution flow as above figure 65 is followed (starting with Assembly.Load etc.). A\nvariable called “GT” is retrieved by calling the LateGet method; it is encoded using the Base64\nalgorithm and exfiltrated to the C2 server:\n\n\n-----\n\nFigure 73\nWhether the registry value mentioned above doesn’t exist and array[2] has a length greater than\n1, array[2] is Base64 decoded, and then Gzip decompressed:\n\nFigure 74\nThe RegistryValue value is created under\n“HKEY_CURRENT_USER\\Software\\49e91d08e684b1770e0cefa60401157a”. The content from\nabove that was decompressed is encoded using Base64 and stored in this value:\n\nFigure 75\nThe same steps starting with loading the assembly (above figure 65) are executed again.\n\n**“CAP|’|’|<Width>|’|’|<Height>” command – take screenshots**\n\nThe RAT creates a new Bitmap object used to create a new Graphics object by calling the\nGraphics.FromImage function. The CopyFromScreen method is utilized to perform a bit-block\ntransfer of color data from the screen to the Graphics object:\n\nFigure 76\nThe binary initializes a new instance of the Rectangle class with a specific position and size and\nthen draws the cursor on the Graphics object within the bounds:\n\n\n-----\n\nFigure 77\nThis command is used to take screenshots. GetThumbnailImage is utilized to obtain a thumbnail\nfor the bitmap image, which is saved in the jpeg format using the Image.Save function. The\nmalware computes the MD5 hash of the image:\n\nFigure 78\n\nFigure 79\nThe JFIF file is exfiltrated to the C2 server byte-by-byte:\n\nFigure 80\n**“P” command – “Ping”**\n\nThe process just sends the “P” letter to the C2:\n\n\n-----\n\nFigure 81\n**“un” command**\n\nCase 1 – “un|’|’|~” – completely uninstall the RAT\n\nThe NtSetInformationProcess API is used to set the process as “normal” (it can be killed without\ncrashing the OS and resulting in a BSOD, 0x1d = 29 = BreakOnTermination). The binary deletes\nthe value created for persistence at\n“HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\49e91d08e684b1770e0cefa60401157a”:\n\nFigure 82\n\nFigure 83\nnjRAT deletes the configured program exception from Windows Firewall. The\n“HKCU\\Software\\49e91d08e684b1770e0cefa60401157a” registry key is deleted, and the initial\nexecutable file is deleted as well:\n\nFigure 84\nCase 2 – “un|’|’|!” – kill the current process\n\nThe malicious process repeats the NtSetInformationProcess API call from above and exits:\n\n\n-----\n\nFigure 85\nCase 3 – “un|’|’|@” – restart the current process\n\nThe binary repeats the NtSetInformationProcess API call from above and spawns the initial\nexecutable:\n\nFigure 86\n**“up” command**\n\nCase 1 – “up|’|’|<URL>” – similar to the “rn” command, it’s used to update the RAT\n\nDownloadData is utilized to download an executable from a URL specified by the C2 server:\n\nFigure 87\nThe malicious process creates a registry value at “HKCU\\di” and saves the downloaded content in\na randomly generated file name located in the TEMP directory:\n\nFigure 88\nThe malware sends a message to the C2 server regarding the update confirmation. The newly\ncreated executable is run with the “UP:” parameter that contains the current process ID. When the\n“HKCU\\di” value is equal to “!”, then the malware executes the uninstall operation:\n\nFigure 89\nCase 2 – “up|’|’|<Base64 (Gzip compressed executable)>” – similar to the “rn” command, it’s used\nto update the RAT\n\nThe RAT decodes the Base64 encoded content and then decompresses it using the ZIP function:\n\n\n-----\n\nFigure 90\nThe execution flow that starts with creating the “HKCU\\di” key is followed one more time.\n\n**“RG” command**\n\nCase 1 – “RG|’|’|~|’|’|<RegistryKey>” – enumerate the registry key\n\nThe process opens the specified registry key using the GetKey function:\n\nFigure 91\n\nFigure 92\nThe executable constructs a string based on the registry key from above, which will be exfiltrated\nlater on:\n\nFigure 93\nThe GetSubKeyNames and GetValueNames methods are used to retrieve an array of strings that\ncontains the subkey names and the value names associated with the key. The concatenation of\nthe arrays is transmitted to the C2:\n\n\n-----\n\nFigure 94\nCase 2 – “RG|’|’|!|’|’|<RegistryKey>|’|’|<RegistryValue>|’|’|<Data>|’|’|<Type>” – create and set a\nregistry value\n\nThe SetValue function is utilized to create a value under the specified registry key, which contains\ndata provided above:\n\nFigure 95\nCase 3 – “RG|’|’|@|’|’|<RegistryKey>|’|’|<RegistryValue>” – delete a registry value\n\nThe DeleteValue method is used to delete the specified value from the registry key:\n\nFigure 96\nCase 4 – “RG|’|’|#|’|’|<RegistryKey>|’|’|<SubKey>” – create a sub key\n\nCreateSubKey is used to create a new subkey, as shown in figure 97:\n\n\n-----\n\nFigure 97\nCase 5 – “RG|’|’|$|’|’|<RegistryKey>|’|’|<SubKey>” – delete a sub key and any child sub keys\nrecursively\n\nDeleteSubKeyTree is utilized to delete the subkey and any child subkeys recursively:\n\nFigure 98\nReferences\n\n[MSDN: https://docs.microsoft.com/en-us/dotnet/api/,](https://docs.microsoft.com/en-us/dotnet/api/) https://docs.microsoft.com/enus/windows/win32/api/\n\ndnSpy: [https://github.com/dnSpy/dnSpy](https://github.com/dnSpy/dnSpy)\n\nFakenet: [https://github.com/fireeye/flare-fakenet-ng](https://github.com/fireeye/flare-fakenet-ng)\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/833f86074592648c0a758098e34ab605a2b922d94dbab7141e2c\ne87acec03c35\n\nAny.run: [https://app.any.run/tasks/78913e0b-1419-4571-8611-ac3372ffd578/](https://app.any.run/tasks/78913e0b-1419-4571-8611-ac3372ffd578/)\n\nESET: https://www.welivesecurity.com/2021/01/12/operation-spalax-targeted-malware-attackscolombia/\n\nTalos: [https://blog.talosintelligence.com/2021/07/sidecopy.html](https://blog.talosintelligence.com/2021/07/sidecopy.html)\n\nK7Computing: https://labs.k7computing.com/index.php/malspam-campaigns-download-njrat-frompaste-sites/\n\nINDICATORS OF COMPROMISE\n\nC2 domain: 44gang44.duckdns[.]org:2222\n\n\n-----\n\nSHA256: 833f86074592648c0a758098e34ab605a2b922d94dbab7141e2ce87acec03c35\n\nRegistry keys and values:\n\nHKCU\\Software\\49e91d08e684b1770e0cefa60401157a\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\49e91d08e684b1770e0cefa60401157a\nHKCU\\di\n\nFiles:\n\nC:\\Users\\<User>\\AppData\\Roaming\\services64.exe\nC:\\Users\\<User>\\AppData\\Roaming\\services64.exe.tmp\n\nMutex: 49e91d08e684b1770e0cefa60401157a\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-30 - Just another analysis of the njRAT malware – A step-by-step approach.pdf"
    ],
    "report_names": [
        "2021-11-30 - Just another analysis of the njRAT malware – A step-by-step approach.pdf"
    ],
    "threat_actors": [
        {
            "id": "64d750e4-67db-4461-bae2-6e75bfced852",
            "created_at": "2022-10-25T16:07:24.01415Z",
            "updated_at": "2025-03-27T02:02:10.077988Z",
            "deleted_at": null,
            "main_name": "Operation Spalax",
            "aliases": [],
            "source_name": "ETDA:Operation Spalax",
            "tools": [
                "AsyncRAT",
                "Bladabindi",
                "Jorik",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Socmer",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b584b10a-7d54-4d05-9e21-b223563df7b8",
            "created_at": "2022-10-25T16:07:24.181589Z",
            "updated_at": "2025-03-27T02:02:10.134233Z",
            "deleted_at": null,
            "main_name": "SideCopy",
            "aliases": [],
            "source_name": "ETDA:SideCopy",
            "tools": [
                "ActionRAT",
                "AllaKore",
                "Allakore RAT",
                "AresRAT",
                "Bladabindi",
                "CetaRAT",
                "DetaRAT",
                "EpicenterRAT",
                "Jorik",
                "Lilith",
                "Lilith RAT",
                "MargulasRAT",
                "ReverseRAT",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "187a0668-a968-4cf0-8bfd-4bc97c02f6dc",
            "created_at": "2022-10-27T08:27:12.955905Z",
            "updated_at": "2025-03-27T02:00:55.41311Z",
            "deleted_at": null,
            "main_name": "SideCopy",
            "aliases": [
                "SideCopy"
            ],
            "source_name": "MITRE:SideCopy",
            "tools": [
                "AuTo Stealer",
                "Action RAT"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a4f0e383-f447-4cd6-80e3-ffc073ed4e00",
            "created_at": "2023-01-06T13:46:39.30167Z",
            "updated_at": "2025-03-27T02:00:03.045082Z",
            "deleted_at": null,
            "main_name": "SideCopy",
            "aliases": [],
            "source_name": "MISPGALAXY:SideCopy",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535542,
    "ts_updated_at": 1743041821,
    "ts_creation_date": 1653692653,
    "ts_modification_date": 1653692653,
    "files": {
        "pdf": "https://archive.orkl.eu/6de96ee3bffe6b7c8fbe160fbab20a91343352d6.pdf",
        "text": "https://archive.orkl.eu/6de96ee3bffe6b7c8fbe160fbab20a91343352d6.txt",
        "img": "https://archive.orkl.eu/6de96ee3bffe6b7c8fbe160fbab20a91343352d6.jpg"
    }
}