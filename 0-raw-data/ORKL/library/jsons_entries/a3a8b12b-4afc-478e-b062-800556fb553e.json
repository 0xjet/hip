{
    "id": "a3a8b12b-4afc-478e-b062-800556fb553e",
    "created_at": "2023-01-12T15:06:37.407762Z",
    "updated_at": "2025-03-27T02:09:29.281752Z",
    "deleted_at": null,
    "sha1_hash": "2ebabbe434b93ef340a76935046343acc15691c5",
    "title": "2018-06-12 - Deep Dive into UPAS Kit vs. Kronos",
    "authors": "",
    "file_creation_date": "2022-05-28T05:12:05Z",
    "file_modification_date": "2022-05-28T05:12:05Z",
    "file_size": 1126409,
    "plain_text": "# Deep Dive into UPAS Kit vs. Kronos\n\n**research.checkpoint.com/deep-dive-upas-kit-vs-kronos/**\n\nJune 12, 2018\n_Research By: Mark Lechtik_\n\n**Introduction**\n\n\nJune 12, 2018\n\n\nIn this post we will be analyzing the UPAS Kit and the Kronos banking Trojan, two malwares\nthat have come under the spotlight recently due to the back story behind them.\n\n**Background**\n\nIn May 2017, WannaCry wreaked havoc in over 150 countries and brought down companies\nacross all industries. Luckily, the attack was brought to a halt by the British security\nresearcher, Marcus Hutchins, through the discovery of the first of several kill-switches.\n\nThe tide of thanks rapidly turned, however, when Hutchins was then arrested and\ninvestigated by the FBI for his alleged role in creating and distributing a previous and\nunrelated malware, the Kronos banking Trojan. But Hutchins’ woes didn’t end there, though,\nfor he has recently come under renewed investigation for being the supposed author of\nanother malware, UPAS Kit.\n\n\n-----\n\nUntil now, although much analysis has been done on Kronos, there is no online availability\nfor the same on UPAS Kit. So Check Point Research decided to take a closer look.\n\n**Disclaimer: Our research does not seek to imply or to make any claims with regards to**\nMarcus Hutchins’ role, or otherwise, to these two malwares, but is rather a mere comparison\nbetween them. Neither does our research show any conclusive evidence that point to\nwhether Kronos and UPAS Kit were written by the same person.\n\n**Initialization Phase**\n\n**Resolving ntdll.dll functions**\n\nUPAS Kit makes usage of multiple low-level ntdll functions and resolves their addresses\nduring run-time. While it may serve as a means to thwart analysis, this is not a very\nsophisticated trick on its own. The procedure responsible for this loading action iterates over\na table of functions containing entries of the following structure:\n\ntypdef struct _ntdll_function_entry{\n\nCHAR *function_name;\n\nPVOID function_address;\n\n}ntdll_function_entry;\n\nIt simply takes the string field of each entry and resolves the corresponding address using\nthe Win32 API function GetProcAddress. This can be seen in the following figure:\n\n**Figure 1: Resolution of ntdll function by UPAS Kit]**\n\n\n-----\n\nIn fact, a similar method is used in the Kronos malware to achieve the same goal. However,\nin this case the function names are not kept in cleartext in the binary, but rather as string\nhashes. Also, some of the resolved functions serve the purpose of being utilized as syscalls,\nthus making it a lot harder to detect the malware’s activity, whether it is by\nsandboxes\\emulators or even manually. To do this, Kronos leverages a slightly different\nfunction entry struct, as shown below:\n\ntypedef struct _ntdll_function_entry{\n\nCHAR *function_name_hash;\n\nPVOID function_address;\n\nDWORD encoded_syscall_number;\n\nDWORD is_used_as_syscall_flag;\n\n}ntdll_function_entry;\n\nThis certainly doesn’t imply that the latter is an extended mechanism of the first method,\nhowever if we compare the order of loaded functions (i.e. the order in which the table entries\nreside within the binary), it can be seen that there is some overlap between the two cases.\n\n**Figure 2: Comparison of loaded ntdll functions order.**\n\n**Anti-VM**\n\n\n-----\n\nIn order to avoid execution in analysis environments, the malware employs two techniques.\nThe first one avoids detection by the ThreatExpert sandbox, whereby the system volume\nserial number is retrieved using the function GetVolumeInformationW, and checked against\nthe value 0xCD1A40 (which corresponds to the aforementioned sandbox). The second\ntechnique is fairly well-known, and that is a check of VMWare’s artifact in a response from a\nvirtual I/O port used for communication between the guest and host. It’s noteworthy that once\nan unwanted environment is detected by the malware, it responds by spawning an error box\nwith the message shown below:\n\n**Figure 3: Anti-VM techniques used by UPAS Kit.**\n\nAlso, it should be noted that the equivalent checks made by Kronos differ quite a lot. These\nwork to seek for the existence of various processes or loaded modules in the malware’s\naddress space that might indicate the nature of the environment in which it’s executed.\nThese types of checks cover more scenarios than the former case, which may imply that the\nevasion procedures were written by different authors, or the same one taking a different\napproach to the problem.\n\n**Global Mutex**\n\n\n-----\n\nThe mutex name generated by the bot is the result of the action –\n_MD5(system_volume_serial || “LPLl3h3lDh1d3djP7P3”). In the event there was an error in_\nthe generation of the mutex name, a hardcoded value (“A5DEU79”) will be set to it.\n\n**Figure 4: Mutex name generation.**\n\nIn this case, a similarity can be spotted between Kronos and UPAS Kit in the implementation\nof the MD5 function, [as indicated by Ignacio Sanmillan (@ulexec) from Intezer. But what’s](https://twitter.com/ulexec/status/1005096227741020160)\nmore evident is that it creates a mutex name in a similar manner, by calculating\n_MD5(system_volume_serial), and in case this fails assigns it to MD5(“Kronos”)._\n\n**Self-Installation**\n\nIn order to remain persistent, UPAS Kit conducts several common actions.\n\nFirst it copies itself into a new directory under %APPDATA%, named ‘Microsoft’ as well as to\nthe %TEMP% directory. The name of the copied file will be the first seven characters of the\nglobal mutex name described above for %APPDATA%, and the same for %TEMP% only with\n“_l.exe” and “_a.exe” appended to it. Then, the current file name will be checked and\ncompared against the newly generated name, such that if the two don’t match then the\nmalware will get executed from the new path in %APPDATA%. If the check succeeds (i.e. at\nthe second time the malware runs from the %APPDATA% path), the current file path will be\nwritten to the well-known registry run-keys Software\\Microsoft\\Windows\\CurrentVersion\\Run\n(under both HKLM and HKCU), where the name of the key is identical to the name of the\ncopied file. Finally, the malware will establish the current system architecture using the\nfunction IsWow64Process, or GetNativeSystemInfo if the former is not available, and return it\nto the main function.\n\n\n-----\n\n**Figure 5: Architecture check.**\n\nThe naming convention used for both the file, registry key and mutex is similar for Kronos,\nwhere it uses the first eight characters of MD5(system_volume_serial) for this purpose.\n\n**Process Injection**\n\nThe injection conducted by the malware depends on the system architecture. In 32 bit\nsystems it would create the ‘explorer.exe’ process and inject its own image into it, whereas in\n64 bit systems it would do so for the 32 bit version of ‘iexplore.exe’, which resides at\n“%ProgramFiles(x86)%\\Internet Explorer“. The injection function itself gets a PID and the\nmain thread handle of the target process, as well as an address of the function to execute\nafter the injection takes place.\n\nIn order to conduct a successful injection, UPAS Kit uses a simple trick. First it copies its\ncurrent virtual image to a buffer, after which it attempts to allocate memory with the image’s\nsize at an arbitrary address in the remote process. The retrieved base address of the\nallocation will be used to relocate the injected image, which resides at the copied buffer, and\nwrite it to the target process. Then, it will prepare a hardcoded call stub and overwrite three\nof its DWORDs so that it will call the function that should be executed upon injection. These\nDWORDs are outlined in the following figure:\n\n\n-----\n\n**Figure 6: Call stub and replaced bytes.**\n\nThe struct that is pushed on the stack serves to convey some parameters that should be\nused later by the hook functions. These parameters include:\n\ntypedef struct _config_struct{\n\nDWORD whitelisted_process_pid;\n\nCHAR whitelisted_run_key_name[16];\n\nwchar_t whitelisted_malware_binary_path[260];\n\nwchar_t mutex_name[260];\n\nDWORD ntdll_load_status;\n\nDWORD some_flag;\n\n}config_struct;\n\nFinally, in order to trigger the execution of the requested function in the remote process, the\nmalware will set the entry point of the remote process by adjusting the value of EAX in the\nContext struct to that of the call stub function, and then resume execution by calling the\n_NtSetContextThread function. If this fails, it will attempt to spawn the target function (and not_\nthe call stub) directly with the CreateRemoteThread function.\n\n\n-----\n\n**Figure 7: Beginning execution in the injected process.**\n\n[In contrast to the above, Kronos conducts a different type of injection, as described here.](https://www.lexsi.com/securityhub/overview-kronos-banking-malware-rootkit/?lang=en)\nHaving said that, it is possible to notice a similarity between both injection implementations,\nin that both present an attempt to elevate the malware’s process token to SeDebugPrivilege,\nwhich is not mandatory for the injection to succeed. The call for the token elevation function,\nas well as the function itself (which is identical in both binaries), are shown below:\n\n**Figure 8: Injection comparison between Kronos and UPAS Kit.**\n\n**Injected Payload**\n\n\n-----\n\nOnce again, the payload executed after injection will differ depending on the underlying\nsystem architecture. For 32 bit processes the injected payload will carry out the following\nactions:\n\nAssign global variables based on the config_struct passed to it (as described in the\nprevious section)\nLoad dll‘s raw image\nCreate a mutex using the mutex name set by the injecting process\nCheck if an uninstall flag is on, and if not –\n\nCreates a thread to inject itself to all other processes, setting the hooking function\nas the one that should be executed upon injection.\nCreates a thread which is in charge of spreading the malware through USB\nmedia.\nEnters an infinite loop of communication with the C2 server.\n\nThe 64 bit payload is very similar, only it doesn’t check for the uninstall flag (hence can’t\nconduct an uninstall of the malware if requested), and doesn’t inject itself to all other\nprocesses, rendering the rootkit not useful. A comparison of both payloads can be seen in\nthe following figure:\n\n**Figure 9: Function invoked after initial injection of UPAS Kit to explorer.exe\\iexplore.exe.**\n\nWe will focus on both hooking mechanism and C2 communication in the subsequent\nsections, so we’ll address only the lateral movement through USB media here. The way it’s\ndone is by registering a new window class (with the name of the mutex described before)\nand entering an endless message loop.\n\n\n-----\n\n**Figure 10: Registration of window class for USB spreading thread.**\n\nEach intercepted message will be handled by a function that will inspect if it represents the\ninsertion of new media and if so will initiate the spreading action and report on it to the C2\nserver.\n\n\n-----\n\n**Figure 11: Window class handler for USB spreading thread.**\n\nThe spreading itself happens by copying the malware file to the USB drive and generating a\nnew autorun.inf file with the string “[autorun]\\r\\nopen=<malware_filename>_a.exe\\r\\n”. Then,\nthe spreader will look for any .lnk files and will replace their path with:\n\n‘/C start \\”\\” \\”<original_filename>\\\\\\” && start \\”\\” \\”<malicious_filename>_l.exe\\”‘.\n\nThis will cause both the original and malware files to be executed as a result of pressing the\ncorresponding shortcut. The replacement is done using the IShellLinkW COM class, as\noutlined below:\n\n\n-----\n\n**Figure 12: Replacement of path in .lnk files.**\n\n**User Land Rootkit Functionality**\n\nUPAS Kit uses a pretty straight forward inline hooking mechanism, which works using the\nfollowing flow:\n\na). Checks if the target function is already hooked (by comparing it’s first byte to 0xE9, which\nis the jmp instruction)\n\nb). If it isn’t, it starts disassembling the first bytes of the function, until it processes at least 5\nbytes. To do so, it uses a simple disassembly engine which merely counts the number of\ndisassembled bytes per instruction. These bytes are referred to as the stolen bytes.\n\n\n-----\n\nc). Prepares a buffer with 21 NOP bytes (0x90), and then reads the stolen bytes into it. Also,\nit modifies the last 5 bytes with a jump to the address that follows the stolen bytes. The\nbuffer’s protection is then set to be the same one used for the original bytes (i.e. should be\nexecutable).\n\nd). Sets the stolen bytes part of the original function to 0, and replaces the first 5 bytes with a\njump to the hook function.\n\n\n-----\n\nThe following ntdll.dll functions are hooked and are intended to hide the malware s artifacts,\nthus making it covert:\n\nNtResumeThread: Intercepted to inject the malware binary into newly created\nprocesses.\nNtQuerySystemInformation: Checks if the requested information class is\n_SystemProcessInformation, and if so compares the requested PID to the whitelisted_\nexplorer.exe PID. If these match, it will set the following\nSYSTEM_PROCESS_INFORMATION entry (corresponding to the process that\nprecedes the rogue explorer.exe) to point to the subsequent process to explorer.exe.\nNtQueryDirectoryFile: Hides the directory in which the malware copy resides\nNtEnumerateValueKey: Hides the registry run key corresponding to the malware\nNtDeleteValueKey: Same as above\nNtSetValueKey: Avoids the action if the requested key is the malware’s run key\nNtSetInformationFile: Checks if the file information class corresponds to one of the\nfollowing: FileDispositionInformation, FileRenameInformation, FileEndOfFileInformation\nor FileAllocationInformation. If so, compares the file name to the whitelisted malware’s\ncopy binary, and if they match avoids the action.\nNtOpenProcess: Avoids the action if the requested PID is that of the rogue explorer.exe\nprocess.\nNtWriteFile: Avoids the action if the target file is the malware’s binary.\n\nIt’s important to note that the hooking method used by Kronos is quite different. Although\nboth conduct inline hooking, Kronos uses a much more stable and safe implementation.\nInline hooking introduces a concurrency issue whereby a context switch that occurs before\nall stolen bytes are overwritten may cause a system crash if the hooked function is called\n(since it’s code is not in a consistent state). Therefore, the Kronos hooking method uses an\natomic write of the prologue bytes using the instruction ‘lock cmpxch8b’. In this sense, the\nhooking engine of UPAS Kit is a lot simpler, and instead carries out an unsafe write with\n_WriteProcessMemory function._\n\nHowever, once again some similarity can be spotted, and that is in the hook functions\nthemselves. Eight of the above hooks appear in a similar form within Kronos, and serve the\nexact same purposes. This suggests that part of the rootkit component in those binaries was\npossibly reused.\n\n**CnC Communication**\n\nThe interaction with the C&C server is done using the HTTP protocol. Most of the\ncommunication is done after the malware executed all other actions (i.e. injection, hooking\nand USB spreading). In this sequence of communication the malware beacons the server\nindefinitely and updates it with the following information:\n\nSystem architecture\n\n\n-----\n\nflag that indicates whether the malware copies at the %TEMP% directory still exist\nOS version\nBot version (in this case 1.0.0.0)\n\nThe server, in turn, may respond with one of two commands: ‘uninstall’ and ‘download’. The\nlatter can also include one of two subcommands: ‘update’ and ‘execute’, which are selfexplanatory. Several commands can be sent in one response, delimited by the “|” character,\nand the command sequence will begin after the first appearance of a “!” character. The\narguments of each command are delimited by a space.\n\nAnother possible message sent to the C2 server is an update on an infected USB, which will\nbe sent once the autorun file and malware binary are copied into it.\n\nIn essence, this is the central role of UPAS Kit, i.e. serve as a covert and infectious\ndownloader of other modules. Some of the modules for this malware offered for sale back in\n2012 can be seen in the following thread from the exploit.in forum:\n\nAlthough we didn’t investigate the additional modules, it seems from their description that\nthey are similar to ones leveraged by ZeuS and some of its variants.\n\n**References**\n\n**IOCs**\n\nAnalyzed UPAS Kit sample:\n1e87d2cbc136d9695b59e67f37035a45a9ad30f5fccc216387a03c0a62afa9d4\nAnalyzed Kronos sample (analyzed in Lexsi’s article):\n4181d8a4c2eda01094ca28d333a14b144641a5d529821b0083f61624422b25ed\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-06-12 - Deep Dive into UPAS Kit vs. Kronos.pdf"
    ],
    "report_names": [
        "2018-06-12 - Deep Dive into UPAS Kit vs. Kronos.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a76ba723-d744-472a-b683-19d80e105d9f",
            "created_at": "2023-01-06T13:46:39.089347Z",
            "updated_at": "2025-03-27T02:00:02.994033Z",
            "deleted_at": null,
            "main_name": "Attor",
            "aliases": [],
            "source_name": "MISPGALAXY:Attor",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535997,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653714725,
    "ts_modification_date": 1653714725,
    "files": {
        "pdf": "https://archive.orkl.eu/2ebabbe434b93ef340a76935046343acc15691c5.pdf",
        "text": "https://archive.orkl.eu/2ebabbe434b93ef340a76935046343acc15691c5.txt",
        "img": "https://archive.orkl.eu/2ebabbe434b93ef340a76935046343acc15691c5.jpg"
    }
}