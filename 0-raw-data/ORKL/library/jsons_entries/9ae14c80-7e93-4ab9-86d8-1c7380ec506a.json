{
    "id": "9ae14c80-7e93-4ab9-86d8-1c7380ec506a",
    "created_at": "2023-01-12T15:09:20.939329Z",
    "updated_at": "2025-03-27T02:15:41.845835Z",
    "deleted_at": null,
    "sha1_hash": "725416eab19f60a0d149e86ddf794db200456f81",
    "title": "2022-01-12 - Exploit Kits vs. Google Chrome",
    "authors": "",
    "file_creation_date": "2022-07-02T23:21:49Z",
    "file_modification_date": "2022-07-02T23:21:49Z",
    "file_size": 919187,
    "plain_text": "# Exploit Kits vs. Google Chrome\n\n**decoded.avast.io/janvojtesek/exploit-kits-vs-google-chrome/**\n\nby [Jan VojtěšekJanuary 12, 202234 min read](https://decoded.avast.io/author/janvojtesek/)\n\n\nJanuary 12, 2022\n\n\n[In October 2021, we discovered that the Magnitude exploit kit was testing out a Chromium exploit](https://decoded.avast.io/janvojtesek/magnitude-exploit-kit-still-alive-and-kicking/)\nchain in the wild. This really piqued our interest, because browser exploit kits have in the past few\nyears focused mainly on Internet Explorer vulnerabilities and it was believed that browsers like\nGoogle Chrome are just too big of a target for them.\n\n[#MagnitudeEK is now stepping up its game by using CVE-2021-21224 and CVE-2021-31956](https://twitter.com/hashtag/MagnitudeEK?src=hash&ref_src=twsrc%5Etfw)\nto exploit Chromium-based browsers. This is an interesting development since most exploit\nkits are currently targeting exclusively Internet Explorer, with Chromium staying out of their\nreach.\n\n[— Avast Threat Labs (@AvastThreatLabs) October 19, 2021](https://twitter.com/AvastThreatLabs/status/1450476708939767815?ref_src=twsrc%5Etfw)\n\nAbout a month later, we found that the [Underminer exploit kit followed suit and developed an](https://twitter.com/AvastThreatLabs/status/1458757035076440064?s=20)\nexploit for the same Chromium vulnerability. That meant there were two exploit kits that dared to\n[attack Google Chrome: Magnitude using CVE-2021-21224 and](https://nvd.nist.gov/vuln/detail/CVE-2021-21224) [CVE-2021-31956 and Underminer](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31956)\nusing [CVE-2021-21224,](https://nvd.nist.gov/vuln/detail/CVE-2021-21224) [CVE-2019-0808,](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2019-0808) [CVE-2020-1020, and](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-1020) [CVE-2020-1054.](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-1054)\n\nWe’ve been monitoring the exploit kit landscape very closely since our discoveries, watching out for\nany new developments. We were waiting for other exploit kits to jump on the bandwagon, but none\nother did, as far as we can tell. What’s more, Magnitude seems to have abandoned the Chromium\nexploit chain. And while Underminer still continues to use these exploits today, its traditional IE\nexploit chains are doing much better. According to our telemetry, less than 20% of Underminer’s\nexploitation attempts are targeting Chromium-based browsers.\n\nThis is some very good news because it suggests that the Chromium exploit chains were not as\nsuccessful as the attackers hoped they would be and that it is not currently very profitable for\nexploit kit developers to target Chromium users. In this blog post, we would like to offer some\nthoughts into why that could be the case and why the attackers might have even wanted to develop\nthese exploits in the first place. And since we don’t get to see a new Chromium exploit chain in the\nwild every day, we will also dissect Magnitude’s exploits and share some detailed technical\ninformation about them.\n\n\n-----\n\n## Exploit Kit Theory\n\nTo understand why exploit kit developers might have wanted to test Chromium exploits, let’s first\nlook at things from their perspective. Their end goal in developing and maintaining an exploit kit is\nto make a profit: they just simply want to maximize the difference between money “earned” and\nmoney spent. To achieve this goal, most modern exploit kits follow a simple formula. They buy ads\ntargeted to users who are likely to be vulnerable to their exploits (e.g. Internet Explorer users).\nThese ads contain JavaScript code that is automatically executed, even when the victim doesn’t\ninteract with the ad in any way (sometimes referred to as drive-by attacks). This code can then\nfurther profile the victim’s browser environment and select a suitable exploit for that environment. If\nthe exploitation succeeds, a malicious payload (e.g. ransomware or a coinminer) is deployed to the\nvictim. In this scenario, the money “earned” could be the ransom or mining rewards. On the other\nhand, the money spent is the cost of ads, infrastructure (renting servers, registering domain names\netc.), and the time the attacker spends on developing and maintaining the exploit kit.\n\nModus operandi of a typical browser exploit kit\nThe attackers would like to have many diverse exploits ready at any given time because it would\nallow them to cast a wide net for potential victims. But it is important to note that individual exploits\ngenerally get less effective over time. This is because the number of people susceptible to a known\nvulnerability will decrease as some people patch and other people upgrade to new devices (which\nare hopefully not plagued by the same vulnerabilities as their previous devices). This forces the\nattackers to always look for new vulnerabilities to exploit. If they stick with the same set of exploits\nfor years, their profit would eventually reduce down to almost nothing.\n\n\n-----\n\nSo how do they find the right vulnerabilities to exploit? After all, there are thousands of CVEs\nreported each year, but only a few of them are good candidates for being included in an exploit kit.\nWeaponizing an exploit generally takes a lot of time (unless, of course, there is a ready-to-use PoC\nor the exploit can be stolen from a competitor), so the attackers might first want to carefully take\ninto account multiple characteristics of each vulnerability. If a vulnerability scores well across these\ncharacteristics, it looks like a good candidate for inclusion in an exploit kit. Some of the more\nimportant characteristics are listed below.\n\n**Prevalence of the vulnerability**\n\nThe more users are affected by the vulnerability, the more attractive it is to the attackers.\n**Exploit reliability**\n\nMany exploits rely on some assumptions or are based on a race condition, which makes\nthem fail some of the time. The attackers obviously prefer high-reliability exploits.\n**Difficulty of exploit development**\n\nThis determines the time that needs to be spent on exploit development (if the attackers are\neven capable of exploiting the vulnerability). The attackers tend to prefer vulnerabilities with a\npublic PoC exploit, which they can often just integrate into their exploit kit with minimal effort.\n**Targeting precision**\n\nThe attackers care about how hard it is to identify (and target ads to) vulnerable victims. If\nthey misidentify victims too often (meaning that they serve exploits to victims who they cannot\nexploit), they’ll just lose money on the malvertising.\n**Expected vulnerability lifetime**\n\nAs was already discussed, each vulnerability gets less effective over time. However, the\nspeed at which the effectiveness drops can vary a lot between vulnerabilities, mostly based\non how effective is the patching process of the affected software.\n**Exploit detectability**\n\nThe attackers have to deal with numerous security solutions that are in the business of\nprotecting their users against exploits. These solutions can lower the exploit kit’s success rate\nby a lot, which is why the attackers prefer more stealthy exploits that are harder for the\ndefenders to detect.\n**Exploit potential**\n\nSome exploits give the attackers `System, while others might make them only end up inside`\na sandbox. Exploits with less potential are also less useful, because they either need to be\nchained with other LPE exploits, or they place limits on what the final malicious payload is\nable to do.\n\nLooking at these characteristics, the most plausible explanation for the failure of the Chromium\nexploit chains is the expected vulnerability lifetime. Google is extremely good at forcing users to\ninstall browser patches: Chrome updates are pushed to users when they’re ready and can happen\nmany times in a month (unlike e.g. Internet Explorer updates which are locked into the once-amonth “Patch Tuesday” cycle that is only broken for exceptionally severe vulnerabilities). When\nCVE-2021-21224 was a zero-day vulnerability, it affected billions of users. Within a few days,\nalmost all of these users received a patch. The only unpatched users were those who manually\ndisabled (or broke) automatic updates, those who somehow managed not to relaunch the browser\nin a long time, and those running Chromium forks with bad patching habits.\n\n\n-----\n\nA secondary reason for the failure could be attributed to bad targeting precision. Ad networks often\nallow the attackers to target ads based on various characteristics of the user’s browser\nenvironment, but the specific version of the browser is usually not one of these characteristics. For\nInternet Explorer vulnerabilities, this does not matter that much: the attackers can just buy ads for\nInternet Explorer users in general. As long as a certain percentage of Internet Explorer users is\nvulnerable to their exploits, they will make a profit. However, if they just blindly targeted Google\nChrome users, the percentage of vulnerable victims might be so low, that the cost of malvertising\nwould outweigh the money they would get by exploiting the few vulnerable users. Google also\n[plans to reduce the amount of information given in the](https://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-dates.html) `User-Agent string. Exploit kits often`\nheavily rely on this string for precise information about the browser version. With less information in\nthe `User-Agent header, they might have to come up with some custom version fingerprinting,`\nwhich would most likely be less accurate and costly to manage.\n\nNow that we have some context about exploit kits and Chromium, we can finally speculate about\nwhy the attackers decided to develop the Chromium exploit chains. First of all, adding new\nvulnerabilities to an exploit kit seems a lot like a “trial and error” activity. While the attackers might\nhave some expectations about how well a certain exploit will perform, they cannot know for sure\nhow useful it will be until they actually test it out in the wild. This means it should not be surprising\nthat sometimes, their attempts to integrate an exploit turn out worse than they expected. Perhaps\nthey misjudged the prevalence of the vulnerabilities or thought that it would be easier to target the\nvulnerable victims. Perhaps they focused too much on the characteristics that the exploits do well\non: after all, they have reliable, high-potential exploits for a browser that’s used by billions. It could\nalso be that this was all just some experimentation where the attackers just wanted to explore the\nland of Chromium exploits.\n\nIt’s also important to point out that the usage of Internet Explorer (which is currently vital for the\nsurvival of exploit kits) has been steadily dropping over the past few years. This may have forced\nthe attackers to experiment with how viable exploits for other browsers are because they know that\nsooner or later they will have to make the switch. But judging from these attempts, the attackers do\nnot seem fully capable of making the switch as of now. That is some good news because it could\nmean that if nothing significant changes, exploit kits might be forced to retire when Internet\nExplorer usage drops below some critical limit.\n\n## CVE-2021-21224\n\nLet’s now take a closer look at the Magnitude’s exploit chain that we discovered in the wild. The\nexploitation starts with a JavaScript exploit for CVE-2021-21224. This is a type confusion\n[vulnerability in V8, which allows the attacker to execute arbitrary code within a (sandboxed)](https://v8.dev/)\n[Chromium renderer process. A zero-day exploit for this vulnerability (or issue 1195777, as it was](https://bugs.chromium.org/p/chromium/issues/detail?id=1195777)\n[known back then since no CVE ID had been assigned yet) was dumped on Github on April 14,](https://web.archive.org/web/20210414162911/https://github.com/avboy1337/1195777-chrome0day/commit/e2a004a0a6cc9bbd3780d6bd585eee1131adbb4f)\n2021. The exploit worked for a couple of days against the latest Chrome version, until Google\nrushed out a patch about a week later.\n\nIt should not be surprising that Magnitude’s exploit is heavily inspired by the PoC on Github.\nHowever, while both Magnitude’s exploit and the PoC follow a very similar exploitation path, there\nare no matching code pieces, which suggests that the attackers didn’t resort that much to the\n\n\n-----\n\nCopy/Paste technique of exploit development. In fact, Magnitude s exploit looks like a more\ncleaned-up and reliable version of the PoC. And since there is no obfuscation employed (the\nattackers probably meant to add it in later), the exploit is very easy to read and debug. There are\neven very self-explanatory function names, such as `confusion_to_oob,` `addrof, and`\n```\narb_write, and variable names, such as oob_array, arb_write_buffer, and\noob_array_map_and_properties . The only way this could get any better for us researchers\n\n```\nwould be if the authors left a couple of helpful comments in there…\n\n[Interestingly, some parts of the exploit also seem inspired by a CTF writeup for a “pwn” challenge](https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/)\nfrom [*CTF 2019, in which the players were supposed to exploit a made-up vulnerability that was](https://ctftime.org/event/778)\nintroduced into a fork of V8. While CVE-2021-21224 is obviously a different (and actual rather than\nmade-up) vulnerability, many of the techniques outlined in that writeup apply for V8 exploitation in\ngeneral and so are used in the later stages of the Magnitude’s exploit, sometimes with the very\nsame variable names as those used in the writeup.\n\nThe core of the exploit,\n\ntriggering the vulnerability to corrupt the length of `vuln_array`\n[The root cause of the vulnerability is incorrect integer conversion during the](https://chromium.googlesource.com/v8/v8/+/09757f3b0a573a3db37a635b8a530b14ad4371c1%5E%21/)\n```\nSimplifiedLowering phase. This incorrect conversion is triggered in the exploit by the\nMath.max call, shown in the code snippet above. As can be seen, the exploit first calls foofunc\n\n```\nin a loop `0x10000 times. This is to make V8 compile that function because the bug only manifests`\nitself after JIT compilation. Then, `helper[\"gcfunc\"] gets called. The purpose of this function is`\njust to trigger garbage collection. We tested that the exploit also works without this call, but the\nauthors probably put it there to improve the exploit’s reliability. Then, `foofunc is called one more`\ntime, this time with `flagvar=true, which makes` `xvar=0xFFFFFFFF . Without the bug,` `lenvar`\nshould now evaluate to `-0xFFFFFFFF and the next statement should throw a` `RangeError`\nbecause it should not be possible to create an array with a negative length. However, because of\nthe bug, `lenvar evaluates to an unexpected value of` `1 . The reason for this is that the`\nvulnerable code incorrectly converts the result of `Math.max from an unsigned 32-bit integer`\n```\n0xFFFFFFFF to a signed 32-bit integer -1 . After constructing vuln_array, the exploit calls\nArray.prototype.shift on it. Under normal circumstances, this method should remove the first\n\n```\n\n-----\n\nelement from the array, so the length of `vuln_array should be zero. However, because of the`\ndisparity between the actual and the predicted value of `lenvar, V8 makes an incorrect`\noptimization here and just puts the 32-bit constant `0xFFFFFFFF into` `Array.length (this is`\ncomputed as `0-1 with an unsigned 32-bit underflow, where` `0 is the predicted length and` `-1`\nsignifies `Array.prototype.shift decrementing` `Array.length ).`\n\nA demonstration of how an overwrite on `vuln_array`\n\ncan corrupt the length of `oob_array`\nNow, the attackers have successfully crafted a JSArray with a corrupted `Array.length, which`\nallows them to perform out-of-bounds memory reads and writes. The very first out-of-bounds\nmemory write can be seen in the last statement of the `confusion_to_oob function. The exploit`\nhere writes `0xc00c to` `vuln_array[0x10] . This abuses the deterministic memory layout in V8`\nwhen a function creates two local arrays. Since `vuln_array was created first,` `oob_array is`\nlocated at a known offset from it in memory and so by making out-of-bounds memory accesses\nthrough `vuln_array, it is possible to access both the metadata and the actual data of`\n```\noob_array . In this case, the element at index 0x10 corresponds to offset 0x40, which is\n\n```\nwhere `Array.length of` `oob_array is stored. The out-of-bounds write therefore corrupts the`\nlength of `oob_array, so it is now too possible to read and write past its end.`\n\nThe `addrof and` `fakeobj exploit`\n\nprimitives\nNext, the exploit constructs the addrof and _[fakeobj exploit primitives. These are well-known and](http://phrack.org/issues/70/3.html#:~:text=4%20-%20Building%20exploit%20primitives)_\nvery powerful primitives in the world of JavaScript engine exploitation. In a nutshell, `addrof leaks`\nthe address of a JavaScript object, while `fakeobj creates a new, fake object at a given address.`\nHaving constructed these two primitives, the attacker can usually reuse existing techniques to get\nto their ultimate goal: arbitrary code execution.\n\n\n-----\n\nA step-by-step breakdown of the `addrof primitive. Note that just the lower 32 bits of the address`\nget leaked, while `%DebugPrint returns the whole 64-bit address. In practice, this doesn’t matter`\nbecause V8 compresses pointers by keeping upper 32 bits of all heap pointers constant.\nBoth primitives are constructed in a similar way, abusing the fact that `vuln_array[0x7] and`\n```\noob_array[0] point to the very same memory location. It is important to note here that\nvuln_array is internally represented by V8 as HOLEY_ELEMENTS, while oob_array is\nPACKED_DOUBLE_ELEMENTS (for more information about internal array representation in V8, please\n\n```\nrefer to [this blog post by the V8 devs). This makes it possible to write an object into](https://v8.dev/blog/elements-kinds) `vuln_array`\nand read it (or more precisely, the pointer to it) from the other end in `oob_array as a double. This`\nis exactly how `addrof is implemented, as can be seen above. Once the address is read, it is`\nconverted using `helper[\"f2ifunc\"] from double representation into an integer representation,`\nwith the upper 32 bits masked out, because the double takes 64 bits, while pointers in V8 are\n[compressed down to just 32 bits.](https://v8.dev/blog/pointer-compression) `fakeobj is implemented in the same fashion, just the other way`\naround. First, the pointer is converted into a double using `helper[\"i2ffunc\"] . The pointer,`\nencoded as a double, is then written into `oob_array[0] and then read from` `vuln_array[0x7],`\nwhich tricks V8 into treating it as an actual object. Note that there is no masking needed in\n```\nfakeobj because the double written into oob_array is represented by more bits than the\n\n```\npointer read from `vuln_array .`\n\nThe arbitrary read/write exploit primitives\n\n\n-----\n\nWith `addrof and` `fakeobj in place, the exploit follows a fairly standard exploitation path, which`\n[seems heavily inspired by the aforementioned *CTF 2019 writeup. The next primitives constructed](https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/)\nby the exploit are arbitrary read/write. To achieve these primitives, the exploit fakes a JSArray\n(aptly named `fake in the code snippet above) in such a way that it has full control over its`\nmetadata. It can then overwrite the fake JSArray’s `elements pointer, which points to the address`\nwhere the actual elements of the array get stored. Corrupting the `elements pointer allows the`\nattackers to point the fake array to an arbitrary address, and it is then subsequently possible to\nread/write to that address through reads/writes on the fake array.\n\nLet’s look at the implementation of the arbitrary read/write primitive in a bit more detail. The exploit\nfirst calls the `get_arw function to set up the fake JSArray. This function starts by using an`\noverread on `oob_array[3] in order to leak` `map and` `properties of` `oob_array (remember`\nthat the original length of `oob_array was` `3 and that its length got corrupted earlier). The` `map`\nand `properties point to structures that basically describe the object type in V8. Then, a new`\narray called `point_array gets created, with the` `oob_array_map_and_properties value as its`\nfirst element. Finally, the `fake JSArray gets constructed at offset` `0x20 before` `point_array .`\nThis offset was carefully chosen, so that the the JSArray structure corresponding to `fake`\noverlaps with `elements of` `point_array . Therefore, it is possible to control the internal`\nmembers of `fake by modifying the elements of` `point_array . Note that elements in`\n```\npoint_array take 64 bits, while members of the JSArray structure usually only take 32 bits, so\n\n```\nmodifying one element of `point_array might overwrite two members of` `fake at the same time.`\nNow, it should make sense why the first element of `point_array was set to`\n```\noob_array_map_and_properties . The first element is at the same address where V8 would look\n\n```\nfor the `map and` `properties of` `fake . By initializing it like this,` `fake is created to be a`\n```\nPACKED_DOUBLE_ELEMENTS JSArray, basically inheriting its type from oob_array .\n\n```\nThe second element of `point_array overlaps with the` `elements pointer and` `Array.length`\nof `fake . The exploit uses this for both arbitrary read and arbitrary write, first corrupting the`\n```\nelements pointer to point to the desired address and then reading/writing to that address through\nfake[0] . However, as can be seen in the exploit code above, there are some additional actions\n\n```\ntaken that are worth explaining. First of all, the exploit always makes sure that `addrvar is an odd`\n[number. This is because V8 expects pointers to be tagged, with the least significant bit set. Then,](https://v8.dev/blog/pointer-compression#value-tagging-in-v8)\nthere is the addition of `2<<32 to` `addrvar . As was explained before, the second element of`\n```\npoint_array takes up 64 bits in memory, while the elements pointer and Array.length both\n\n```\ntake up only 32 bits. This means that a write to `point_array[1] overwrites both members at`\nonce and the `2<<32 just simply sets the` `Array.length, which is controlled by the most`\nsignificant 32 bits. Finally, there is the subtraction of `8 from` `addrvar . This is because the`\n```\nelements pointer does not point straight to the first element, but instead to a\nFixedDoubleArray structure, which takes up eight bytes and precedes the actual element data\n\n```\nin memory.\n\n\n-----\n\nA dummy WebAssembly program that will get hollowed out and replaced by Magnitude’s shellcode\nThe final step taken by the exploit is converting the arbitrary read/write primitive into arbitrary code\nexecution. For this, it uses a well-known trick that takes advantage of WebAssembly. When V8 JITcompiles a WebAssembly function, it places the compiled code into memory pages that are both\n[writable and executable (there now seem to be some new mitigations that aim to prevent this trick,](https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/#:~:text=The%20beginning%20of%20the%20end%20of%20wasm%20RWX%3F)\nbut it is still working against V8 versions vulnerable to CVE-2021-21224). The exploit can therefore\nlocate the code of a JIT-compiled WebAssembly function, overwrite it with its own shellcode and\nthen call the original WebAssembly function from Javascript, which executes the shellcode planted\nthere.\n\nMagnitude’s exploit first creates a dummy WebAssembly module that contains a single function\ncalled `main, which just returns the number 42 (the original code of this function doesn’t really`\nmatter because it will get overwritten with the shellcode anyway). Using a combination of `addrof`\nand `arb_read, the exploit obtains the address where V8 JIT-compiled the function` `main .`\nInterestingly, it then constructs a whole new arbitrary write primitive using an ArrayBuffer with a\ncorrupted backing store pointer and uses this newly constructed primitive to write shellcode to the\naddress of `main . While it could theoretically use the first arbitrary write primitive to place the`\nshellcode there, it chooses this second method, most likely because it is more reliable. It seems\nthat the first method might crash V8 under some rare circumstances, which makes it not practical\nfor repeated use, such as when it gets called thousands of times to write a large shellcode buffer\ninto memory.\n\nThere are two shellcodes embedded in the exploit. The first one contains an exploit for CVE-202131956. This one gets executed first and its goal is to steal the `SYSTEM token to elevate the`\nprivileges of the current process. After the first shellcode returns, the second shellcode gets\nplanted inside the JIT-compiled WebAssembly function and executed. This second shellcode\ninjects Magniber ransomware into some already running process and lets it encrypt the victim’s\ndrives.\n\n## CVE-2021-31956\n\nLet’s now turn our attention to the second exploit in the chain, which Magnitude uses to escape the\nChromium sandbox. This is an exploit for CVE-2021-31956, a paged pool buffer overflow in the\n[Windows kernel. It was discovered in June 2021 by Boris Larin from Kaspersky, who found it being](https://twitter.com/oct0xor)\n[used as a zero-day in the wild as a part of the PuzzleMaker attack. The Kaspersky blog post about](https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/)\nPuzzleMaker briefly describes the vulnerability and the way the attackers chose to exploit it.\n[However, much more information about the vulnerability can be found in a two–part blog series by](https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/)\n[Alex Plaskett from NCC Group. This blog series goes into great detail and pretty much provides a](https://twitter.com/alexjplaskett)\nstep-by-step guide on how to exploit the vulnerability. We found that the attackers behind\nMagnitude followed this guide very closely, even though there are certainly many other approaches\n\n\n-----\n\nthat they could have chosen for exploitation. This shows yet again that publishing vulnerability\nresearch can be a double-edged sword. While the blog series certainly helped many defend\nagainst the vulnerability, it also made it much easier for the attackers to weaponize it.\n\nThe vulnerability lies in `ntfs.sys, inside the function` `NtfsQueryEaUserEaList, which is`\ndirectly reachable from the syscall `NtQueryEaFile . This syscall internally allocates a temporary`\nbuffer on the paged pool (the size of which is controllable by a syscall parameter) and places there\nthe NTFS Extended Attributes associated with a given file. Individual Extended Attributes are\nseparated by a padding of up to four bytes. By making the padding start directly at the end of the\nallocated pool chunk, it is possible to trigger an integer underflow which results in\n```\nNtfsQueryEaUserEaList writing subsequent Extended Attributes past the end of the pool chunk.\n\n```\nThe idea behind the exploit is to spray the pool so that chunks containing certain Windows\nNotification Facility (WNF) structures can be corrupted by the overflow. Using some WNF magic\nthat will be explained later, the exploit gains an arbitrary read/write primitive, which it uses to steal\nthe `SYSTEM token.`\n\nThe exploit starts by checking the victim’s Windows build number. Only builds 18362, 18363,\n19041, and 19042 (19H1 – 20H2) are supported, and the exploit bails out if it finds itself running on\na different build. The build number is then used to determine proper offsets into the `_EPROCESS`\nstructure as well as to determine correct syscall numbers, because syscalls are invoked directly by\nthe exploit, bypassing the usual syscall stubs in `ntdll .`\n\nCheck for the victim’s Windows build number\nNext, the exploit brute-forces file handles, until it finds one on which it can use the `NtSetEAFile`\nsyscall to set its NTFS Extended Attributes. Two attributes are set on this file, crafted to trigger an\noverflow of `0x10 bytes into the next pool chunk later when` `NtQueryEaFile gets called.`\n\n\n-----\n\nSpecially crafted NTFS Extended Attributes, designed to cause a paged pool buffer overflow\nWhen the specially crafted NTFS Extended Attributes are set, the exploit proceeds to spray the\npaged pool with `_WNF_NAME_INSTANCE and` `_WNF_STATE_DATA structures. These structures are`\nsprayed using the syscalls `NtCreateWnfStateName and` `NtUpdateWnfStateData, respectively.`\nThe exploit then creates 10 000 extra `_WNF_STATE_DATA structures in a row and frees each other`\none using `NtDeleteWnfStateData . This creates holes between` `_WNF_STATE_DATA chunks,`\nwhich are likely to get reclaimed on future pool allocations of similar size.\n\nWith this in mind, the exploit now triggers the vulnerability using `NtQueryEaFile, with a high`\nlikelihood of getting a pool chunk preceding a random `_WNF_STATE_DATA chunk and thus`\noverflowing into that chunk. If that really happens, the `_WNF_STATE_DATA structure will get`\ncorrupted as shown below. However, the exploit doesn’t know which `_WNF_STATE_DATA structure`\ngot corrupted, if any. To find the corrupted structure, it has to iterate over all of them and query its\n```\nChangeStamp using NtQueryWnfStateData . If the ChangeStamp contains the magic number\n0xcafe, the exploit found the corrupted chunk. In case the overflow does not hit any\n_WNF_STATE_DATA chunk, the exploit just simply tries triggering the vulnerability again, up to 32\n\n```\ntimes. Note that in case the overflow didn’t hit a `_WNF_STATE_DATA chunk, it might have corrupted`\na random chunk in the paged pool, which could result in a BSoD. However, during our testing of the\nexploit, we didn’t get any BSoDs during normal exploitation, which suggests that the pool spraying\ntechnique used by the attackers is relatively robust.\n\nThe corrupted `_WNF_STATE_DATA instance.` `AllocatedSize and` `DataSize were both`\nartificially increased, while `ChangeStamp got set to an easily recognizable value.`\nAfter a successful `_WNF_STATE_DATA corruption, more` `_WNF_NAME_INSTANCE structures get`\nsprayed on the pool, with the idea that they will reclaim the other chunks freed by\n```\nNtDeleteWnfStateData . By doing this, the attackers are trying to position a\n_WNF_NAME_INSTANCE chunk after the corrupted _WNF_STATE_DATA chunk in memory. To\n\n```\nexplain why they would want this, let’s first discuss what they achieved by corrupting the\n```\n_WNF_STATE_DATA chunk.\n\n```\n\n-----\n\nThe `_WNF_STATE_DATA structure can be thought of as a header preceding an actual`\n```\nWnfStateData buffer in memory. The WnfStateData buffer can be read using the syscall\nNtQueryWnfStateData and written to using NtUpdateWnfStateData .\n_WNF_STATE_DATA.AllocatedSize determines how many bytes can be written to\nWnfStateData and _WNF_STATE_DATA.DataSize determines how many bytes can be read. By\n\n```\ncorrupting these two fields and setting them to a high value, the exploit gains a relative memory\nread/write primitive, obtaining the ability to read/write memory even after the original\n```\nWnfStateData buffer. Now it should be clear why the attackers would want a\n_WNF_NAME_INSTANCE chunk after a corrupted _WNF_STATE_DATA chunk: they can use the\n\n```\noverread/overwrite to have full control over a `_WNF_NAME_INSTANCE structure. They just need to`\nperform an overread and scan the overread memory for bytes `03 09 A8, which denote the start`\nof their `_WNF_NAME_INSTANCE structure. If they want to change something in this structure, they`\ncan just modify some of the overread bytes and overwrite them back using\n```\nNtUpdateWnfStateData .\n\n```\nThe exploit scans the overread\n\nmemory, looking for a `_WNF_NAME_INSTANCE header.` `0x0903 here represents the`\n```\nNodeTypeCode, while 0xA8 is a preselected NodeByteSize .\n\n```\nWhat is so interesting about a `_WNF_NAME_INSTANCE structure, that the attackers want to have full`\ncontrol over it? Well, first of all, at offset `0x98 there is` `_WNF_NAME_INSTANCE.CreatorProcess,`\nwhich gives them a pointer to `_EPROCESS relevant to the current process. Kaspersky reported that`\nPuzzleMaker used a separate information disclosure vulnerability, [CVE-2021-31955, to leak the](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31955)\n```\n_EPROCESS base address. However, the attackers behind Magnitude do not need to use a second\n\n```\nvulnerability, because the `_EPROCESS address is just there for the taking.`\n\nAnother important offset is `0x58, which corresponds to` `_WNF_NAME_INSTANCE.StateData . As`\nthe name suggests, this is a pointer to a `_WNF_STATE_DATA structure. By modifying this, the`\nattackers can not only enlarge the `WnfStateData buffer but also redirect it to an arbitrary`\naddress, which gives them an arbitrary read/write primitive. There are some constraints though,\nsuch as that the `StateData pointer has to point` `0x10 bytes before the address that is to be`\nread/written and that there has to be some data there that makes sense when interpreted as a\n```\n_WNF_STATE_DATA structure.\n\n```\nThe `StateData pointer gets first set to` `_EPROCESS+0x28, which allows the exploit to read`\n```\n_KPROCESS.ThreadListHead (interestingly, this value gets leaked using ChangeStamp and\nDataSize, not through WnfStateData ). The ThreadListHead points to\n\n```\n\n-----\n\n```\n_KTHREAD.ThreadListEntry of the first thread, which is the current thread in the context of\n\n```\nChromium exploitation. By subtracting the offset of `ThreadListEntry, the exploit gets the`\n```\n_KTHREAD base address for the current thread.\n\n```\nWith the base address of `_KTHREAD, the exploit points` `StateData to` `_KTHREAD+0x220, which`\nallows it to read/write up to three bytes starting from `_KTHREAD+0x230 . It uses this to set the byte`\nat `_KTHREAD+0x232 to zero. On the targeted Windows builds, the offset` `0x232 corresponds to`\n```\n_KTHREAD.PreviousMode . Setting its value to SystemMode=0 tricks the kernel into believing that\n\n```\nsome of the thread’s syscalls are actually originating from the kernel. Specifically, this allows the\nthread to use the `NtReadVirtualMemory and` `NtWriteVirtualMemory syscalls to perform`\nreads and writes to the kernel address space.\n\nThe exploit corrupting `_KTHREAD.PreviousMode`\nAs was the case in the Chromium exploit, the attackers here just traded an arbitrary read/write\nprimitive for yet another arbitrary read/write primitive. However, note that the new primitive based\non `PreviousMode is a significant upgrade compared to the original` `StateData one. Most`\nimportantly, the new primitive is free of the constraints associated with the original one. The new\nprimitive is also more reliable because there are no longer race conditions that could potentially\ncause a BSoD. Not to mention that just simply calling `NtWriteVirtualMemory is much faster and`\nmuch less awkward than abusing multiple WNF-related syscalls to achieve the same result.\n\nWith a robust arbitrary read/write primitive in place, the exploit can finally do its thing and proceed\nto steal the `SYSTEM token. Using the leaked` `_EPROCESS address from before, it finds`\n```\n_EPROCESS.ActiveProcessLinks, which leads to a linked list of other _EPROCESS structures. It\n\n```\niterates over this list until it finds the `System process. Then it reads System’s` `_EPROCESS.Token`\nand assigns this value (with some of the `RefCnt bits masked out) to its own` `_EPROCESS`\nstructure. Finally, the exploit also turns off some mitigation flags in\n```\n_EPROCESS.MitigationFlags .\n\n```\nNow, the exploit has successfully elevated privileges and can pass control to the other shellcode,\nwhich was designed to load Magniber ransomware. But before it does that, the exploit performs\nmany cleanup actions that are necessary to avoid blue screening later on. It iterates over WNFrelated structures using `TemporaryNamesList from` `_EPROCESS.WnfContext and fixes all the`\n```\n_WNF_NAME_INSTANCE structures that got overflown into at the beginning of the exploit. It also\n\n```\nattempts to fix the `_POOL_HEADER of the overflown` `_WNF_STATE_DATA chunks. Finally, the exploit`\ngets rid of both read/write primitives by setting `_KTHREAD.PreviousMode back to` `UserMode=1`\nand using one last `NtUpdateWnfStateData` syscall to restore the corrupted `StateData pointer`\nback to its original value.\n\n\n-----\n\nFixups\n\nperformed on previously corrupted `_WNF_NAME_INSTANCE structures`\n\n## Final Thoughts\n\nIf this isn’t the first time you’re hearing about Magnitude, you might have noticed that it often\nexploits vulnerabilities that were previously weaponized by APT groups, who used them as zero[days in the wild. To name a few recent examples, CVE-2021-31956 was exploited by PuzzleMaker,](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31956)\n[CVE-2021-26411 was used in a](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26411) [high-profile attack targeting security researchers, CVE-2020-0986](https://blog.google/threat-analysis-group/new-campaign-targeting-security-researchers/)\n[was abused in Operation Powerfall, and](https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/) [CVE-2019-1367 was](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2019-1367) [reported to be exploited in the wild](https://www.blog.google/threat-analysis-group/identifying-vulnerabilities-and-protecting-you-phishing/)\n[by an undisclosed threat actor (who might be DarkHotel APT according to Qihoo 360). The fact that](https://blogs.360.cn/post/apt-c-06_0day.html)\nthe attackers behind Magnitude are so successful in reproducing complex exploits with no public\nPoCs could lead to some suspicion that they have somehow obtained under-the-counter access to\nprivate zero-day exploit samples. After all, we don’t know much about the attackers, but we do\nknow that they are skilled exploit developers, and perhaps Magnitude is not their only source of\nincome. But before we jump to any conclusions, we should mention that there are other, more\nplausible explanations for why they should prioritize vulnerabilities that were once exploited as\n\n\n-----\n\nzero-days. First, APT groups usually know what they are doing[ ]. If an APT group\ndecides that a vulnerability is worth exploiting in the wild, that generally means that the vulnerability\nis reliably weaponizable. In a way, the attackers behind Magnitude could abuse this to let the APT\ngroups do the hard work of selecting high-quality vulnerabilities for them. Second, zero-days in the\nwild usually attract a lot of research attention, which means that there are often detailed writeups\nthat analyze the vulnerability’s root cause and speculate about how it could get exploited. These\nwriteups make exploit development a lot easier compared to more obscure vulnerabilities which\nattracted only a limited amount of research.\n\nAs we’ve shown in this blog post, both Magnitude and Underminer managed to successfully\ndevelop exploit chains for Chromium on Windows. However, none of the exploit chains were\nparticularly successful in terms of the number of exploited victims. So what does this mean for the\nfuture of exploit kits? We believe that unless some new, hard-to-patch vulnerability comes up,\nexploit kits are not something that the average Google Chrome user should have to worry about\nmuch. After all, it has to be acknowledged that Google does a great job at patching and reducing\nthe browser’s attack surface. Unfortunately, the same cannot be said for all other Chromium-based\nbrowsers. We found that a big portion of those that we protected from Underminer were running\nChromium forks that were months (or even years) behind on patching. Because of this, we\nrecommend avoiding Chromium forks that are slow in applying security patches from the upstream.\nAlso note that some Chromium forks might have vulnerabilities in their own custom codebase. But\nas long as the number of users running the vulnerable forks is relatively low, exploit kit developers\nwill probably not even bother with implementing exploits specific just for them.\n\nFinally, we should also mention that it is not entirely impossible for exploit kits to attack using zeroday or n-day exploits. If that were to happen, the attackers would probably carry out a massive\nburst of malvertising or watering hole campaigns. In such a scenario, even regular Google Chrome\nusers would be at risk. The damage done by such an attack could be enormous, depending on the\nreaction time of browser developers, ad networks, security companies, LEAs, and other concerned\nparties. There are basically three ways that the attackers could get their hands on a zero-day\nexploit: they could either buy it, discover it themselves, or discover it being used by some other\nthreat actor. Fortunately, using some simple math we can see that the campaign would have to be\nvery successful if the attackers wanted to recover the cost of the zero-day, which is likely to\ndiscourage most of them. Regarding n-day exploitation, it all boils down to a race if the attackers\ncan develop a working exploit sooner than a patch gets written and rolled out to the end users. It’s\na hard race to win for the attackers, but it has been won before. We know of at least [two](https://github.com/r4j0x00/exploits/commit/d3a21075644a124c1bbc5966d4c43337191db9f6) [cases](https://web.archive.org/web/20210414162911/https://github.com/avboy1337/1195777-chrome0day/commit/e2a004a0a6cc9bbd3780d6bd585eee1131adbb4f)\nwhen an n-day exploit working against the latest Google Chrome version was dumped on GitHub\n(this probably doesn’t need to be written down, but dumping such exploits on GitHub is not a very\nbright idea). Fortunately, these were just renderer exploits and there were no accompanying\nsandbox escape exploits (which would be needed for full weaponization). But if it is possible to win\nthe race for one exploit, it’s not unthinkable that an attacker could win it for two exploits at the same\ntime.\n\n**Indicators of Compromise (IoCs)**\n\nMagnitude\n\n\n-----\n\nSHA-256 Note\n\n`71179e5677cbdfd8ab85507f90d403afb747fba0e2188b15bd70aac3144ae61a` CVE-202121224 exploit\n\n`a7135b92fc8072d0ad9a4d36e81a6b6b78f1528558ef0b19cb51502b50cffe6d` CVE-202121224 exploit\n\n`6c7ae2c24eaeed1cac0a35101498d87c914c262f2e0c2cd9350237929d3e1191` CVE-202131956 exploit\n\n`8c52d4a8f76e1604911cff7f6618ffaba330324490156a464a8ceaf9b590b40a` payload\ninjector\n\n`8ff658257649703ee3226c1748bbe9a2d5ab19f9ea640c52fc7d801744299676` payload\ninjector\n\nUnderminer\n\nSHA-256 Note\n\n`2ac255e1e7a93e6709de3bbefbc4e7955af44dbc6f977b60618237282b1fb970` CVE-2021-21224\nexploit\n\n`9552e0819f24deeea876ba3e7d5eff2d215ce0d3e1f043095a6b1db70327a3d2` HiddenBee\nloader\n\n`7a3ba9b9905f3e59e99b107e329980ea1c562a5522f5c8f362340473ebf2ac6d` HiddenBee\nmodule container\n\n`2595f4607fad7be0a36cb328345a18f344be0c89ab2f98d1828d4154d68365f8` amd64/coredll.bin\n\n`ed7e6318efa905f71614987942a94df56fd0e17c63d035738daf97895e8182ab` amd64/pcs.bin\n\n`c2c51aa8317286c79c4d012952015c382420e4d9049914c367d6e72d81185494` CVE-2019-0808\nexploit\n\n`d88371c41fc25c723b4706719090f5c8b93aad30f762f62f2afcd09dd3089169` CVE-2020-1020\nexploit\n\n`b201fd9a3622aff0b0d64e829c9d838b5f150a9b20a600e087602b5cdb11e7d3` CVE-2020-1054\nexploit\n\n[Tagged asCVE-2021-21224,](https://decoded.avast.io/tag/cve-2021-21224/) [CVE-2021-31956,](https://decoded.avast.io/tag/cve-2021-31956/) [exploit,](https://decoded.avast.io/tag/exploit/) [exploit kit,](https://decoded.avast.io/tag/exploit-kit/) [Magnitude,](https://decoded.avast.io/tag/magnitude/) [Underminer](https://decoded.avast.io/tag/underminer/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-12 - Exploit Kits vs. Google Chrome.pdf"
    ],
    "report_names": [
        "2022-01-12 - Exploit Kits vs. Google Chrome.pdf"
    ],
    "threat_actors": [
        {
            "id": "1dadf04e-d725-426f-9f6c-08c5be7da159",
            "created_at": "2022-10-25T15:50:23.624538Z",
            "updated_at": "2025-03-27T02:00:55.508759Z",
            "deleted_at": null,
            "main_name": "Darkhotel",
            "aliases": [
                "Darkhotel",
                "DUBNIUM",
                "Zigzag Hail"
            ],
            "source_name": "MITRE:Darkhotel",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b13c19d6-247d-47ba-86ba-15a94accc179",
            "created_at": "2024-05-01T02:03:08.149923Z",
            "updated_at": "2025-03-27T02:05:17.422065Z",
            "deleted_at": null,
            "main_name": "TUNGSTEN BRIDGE",
            "aliases": [
                "DUBNIUM ",
                "DarkHotel ",
                "CTG-1948 "
            ],
            "source_name": "Secureworks:TUNGSTEN BRIDGE",
            "tools": [
                "Nemim"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2b4eec94-7672-4bee-acb2-b857d0d26d12",
            "created_at": "2023-01-06T13:46:38.272109Z",
            "updated_at": "2025-03-27T02:00:02.790029Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "DUBNIUM",
                "Fallout Team",
                "Luder",
                "Tapaoux",
                "Shadow Crane",
                "APT-C-06",
                "SIG25",
                "Karba",
                "Nemim",
                "Nemin",
                "G0012",
                "ATK52",
                "T-APT-02",
                "TUNGSTEN BRIDGE",
                "Zigzag Hail"
            ],
            "source_name": "MISPGALAXY:DarkHotel",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536160,
    "ts_updated_at": 1743041741,
    "ts_creation_date": 1656804109,
    "ts_modification_date": 1656804109,
    "files": {
        "pdf": "https://archive.orkl.eu/725416eab19f60a0d149e86ddf794db200456f81.pdf",
        "text": "https://archive.orkl.eu/725416eab19f60a0d149e86ddf794db200456f81.txt",
        "img": "https://archive.orkl.eu/725416eab19f60a0d149e86ddf794db200456f81.jpg"
    }
}