{
    "id": "8b7bb85e-0b1e-419a-a36f-b6167412bef8",
    "created_at": "2023-01-12T15:01:50.899358Z",
    "updated_at": "2025-03-27T02:06:11.24105Z",
    "deleted_at": null,
    "sha1_hash": "b4cfe5db4c8b83cfcb5f9086fa1e17f3249ccc9c",
    "title": "2022-08-08 - Malware sandbox evasion in x64 assembly by checking ram size - Part 1",
    "authors": "",
    "file_creation_date": "2022-08-18T04:02:38Z",
    "file_modification_date": "2022-08-18T04:02:38Z",
    "file_size": 413858,
    "plain_text": "# Malware sandbox evasion in x64 assembly by checking ram size - Part 1\n\n**[accidentalrebel.com/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-1.html](https://www.accidentalrebel.com/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-1.html)**\n\n[During my malware sandbox evasion research, I stumbled upon the Unprotect Project](https://unprotect.it/)\nwebsite. It is a community-contributed repository of evasion techniques used by malware. I\nsaw that the the [Checking Memory Size technique doesn't have a example snippet yet so I](https://unprotect.it/technique/checking-memory-size/)\nfigured this would be a good first contribution to the project.\n\n## What to expect\n\nIn this blog post I'll be making a code snippet that showcases how to get the size of a\ncomputer's RAM in C. I will then convert this code into x64 assembly, mostly for me to\npractice writing in it, but also so that we can understand it better.\n\n## Checking the memory\n\nThe idea behind this evasion technique is simple. Most modern user machines will have at\nleast around 4GB of RAM. Anything lower than that can be an indication that the machine is\nprobably a sandbox (To save costs). While it's not exactly fool-proof, it can be used with\n[other techniques to have a better idea of the machine.](https://unprotect.it/category/sandbox-evasion/)\n\n\n-----\n\nThere are two available APIs to get the memory size of a computer on Windows:\n\n`GetPhysicallyInstalledSystemMemory and` `GlobalMemoryStatusEx .` [The former lists](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory)\nthe physically installed RAM from the BIOS, while [the latter lists the amount available for](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex)\nthe operating system to use. Note that the values returned from these two functions will be\ndifferent but from my tests the difference is only a few hundreds of bytes. Any of these two\nwe can use for our purpose.\n\n## Using GetPhysicallyInstalledSystemMemory\n\nCalling `GetPhysicallyInstalledSystemMemory in C is simple:`\n```\n#include <stdio.h>\n\n#include <windows.h>\n\nint main(void)\n\n{\n\n  unsigned long long memory_size = 0;\n\n  GetPhysicallyInstalledSystemMemory(&memory_size);\n\n  printf(\"Memory size: %lld\\n\", memory_size);\n\n}\n\n\n```\nRunning the above code shows the following result:\n\nAnd this is what my memory settings is set to on VMWare:\n\n\n-----\n\nYou'll immediately notice that the returned value is not exactly the same as the memory\nsettings. I, too, wondered about this so I did a couple of tests.\n\n## Investigating the results\n\nWhat I found was that the values that are returned by the\n```\nGetPhysicallyInstalledSystemMemory in hex format always have the last 3 bytes set\n\n```\nto zero. To test this I changed the VM settings and noted the values returned by the\nprogram. Here's a table of the results:\n\n**VM Settings** **Returned Value** **In Hex**\n\n2000MB 2048000 0x1F4000\n\n3324MB 3403776 0x33F000\n\n4096MB 4194304 0x400000\n\n4338MB 4493312 0x449000\n\n5675MB 5816320 0x58C000\n\n\n-----\n\nBefore you think that this is a VM thing, here is the same behavior with a Windows system\nthat is not on a VM:\n\n**Installed RAM** **Returned Value** **In Hex**\n\n16384MB 16777216 0x1000000\n\nAccording to the [MSDN docs, the value returned is taken from the SMBIOS firmware tables.](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory)\n[I tried to dig further and found the SMBIOS standard manual and saw that the value in the](https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.5.0.pdf)\nmemory size field is returned in MB. This still doesn't explain why the last 3 digits are\nalways zero though. I'm guessing that the API just truncates the last 3 values and saves the\nhigher bytes?\n\n**[EDIT(2022-08-15): Twitter user @Endeavxor pointed out that the returned value of](https://twitter.com/Endeavxor)**\n\"GetPhysicallyInstalledSystemMemory\" is expressed in kibibytes instead of kilobytes.\nThis means the result `4194304 when divided by` `1024 is` `4096 and is exactly the`\nMemory value set in the VM settings. This means the value returned by the function is\ncorrect. It's so simple and I missed it!\n\nBefore we get hopelessly trapped in the rabbit hole that is OS internals, let's continue by\nconverting our code above to x64 assembly.\n\n## Converting to x64 Assembly\n\nBefore we can call the `GetPhysicallyInstalledSystemMemory function, we first need to`\nreserve space on the stack that will serve as the `memory_size local variable. This is`\nwhere the result of the function will be placed.\n```\n  xor rax, rax  ; Clear rax\n\n  push rax    ; Push rax to the stack\n\n  lea rcx, [rsp] ; Argument 1; Load the memory location of memory_size to rcx\n\n\n```\nWe then call the `GetPhysicallyInstalledSystemMemory function making sure that we`\nreserve and release the shadow space.\n```\n  sub rsp, 32     ; Reserve shadow space\n\n  call  GetPhysicallyInstalledSystemMemory\n\n  add rsp, 32     ; Release shadow space\n\n\n### Aside: Shadow space\n\n```\nThe concept of \"Shadow Space\" is important in x64 assembly. I've already discussed\n[it briefly in a previous post but you can read up more about it here and then here.](https://www.accidentalrebel.com/converting-a-malware-dropper-to-x64-assembly.html)\n\n\n-----\n\nThe result on whether `GetPhysicallyInstalledSystemMemory succeeded or not is`\nplaced in the `ax register. It's good practice to add code to handle if a failure occurs, but`\nwe won't be bothering with that for our example.\n\nWhat we are interested in is the value placed in the memory location pointed to by\n```\nmemory_size . We can confirm this by checking the value on the stack, as shown below\n\n```\nwhere `58C000h converts to` `5816320 which is roughly near the` `5.5 GB setting we have`\nset in VMWare.\n\nA much easier way to confirm is that we can also use the `printf function to display the`\nvalue of `memory_size on the console. But before we can do that we first need to declare`\nthe `format string so we can pass it later as the first argument.`\n```\nsegment .data\n\n  msg_memory_size db \"Memory size: %lld\", 0xd, 0xa, 0\n\n\n```\nWe then call `printf making sure we load the correct argument data to the respective`\nregisters.\n\n\n-----\n\n```\n  mov rdx, [rsp]       ; Argument 2; Result of\nGetPhysicallyInstalledSystemMemory\n\n  lea rcx, [msg_memory_size] ; Argument 1; Format string\n\n  sub rsp, 32        ; Reserve shadow space\n\n  call  printf\n\n  add rsp, 32        ; Release shadow space\n\n```\nRunning that we can now display the value of the memory.\n\nHere's the full assembly code:\n```\n  bits 64\n\n  default rel\n\nsegment .data\n\n  msg_memory_size db \"Memory size: %lld\", 0xd, 0xa, 0\n\nsegment .text\n\n  global main\n\n  extern ExitProcess\n\n  extern GetPhysicallyInstalledSystemMemory\n\n  extern printf\n\nmain:\n\n  push  rbp\n\n  mov   rbp, rsp\n\n  xor rax, rax  ; Clear rax\n\n  push  rax   ; Push RAX to the stack\n\n  lea rcx, [rsp] ; Argument 1; Load the memory location of memory_size to rcx\n\n  sub rsp, 32   ; Reserve shadow space\n\n  call  GetPhysicallyInstalledSystemMemory\n\n  add rsp, 32   ; Release shadow space\n\n  mov rdx, [rsp] ; Argument 2; Result of GetPhysicallyInstalledSystemMemory\n\n  lea rcx, [msg_memory_size] ; Argument 1; Format string\n\n  sub rsp, 32   ; Reserve shadow space\n\n  call  printf\n\n  add rsp, 32   ; Release shadow space\n\n  add rsp, 0x8  ; Release the space of memory_size local variable\n\n  xor   rax, rax\n\n  call  ExitProcess\n\n\n## Up next\n\n```\nIn the next blog post I'll be showing how to get the size RAM size via an alternative method\nusing `GlobalMemoryStatusEx . The code is also straightforward but we'll be exploring`\nhow it's values differ from `GetPhysicallyInstalledSystemMemory and also how to deal`\nwith C structures on the stack in x64 assembly\n\n\n-----\n\nFor now, you can view the C and Assembly code along with the build scripts on the\nrepository [here.](https://github.com/accidentalrebel/sandbox-evasion-by-checking-ram-size)\n\n[Feel free to reach out to me on Twitter or](https://twitter.com/accidentalrebel) [LinkedIn for any questions or comments.](https://www.linkedin.com/in/juan-karlo-licudine/)\n\n## Comments\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-08 - Malware sandbox evasion in x64 assembly by checking ram size - Part 1.pdf"
    ],
    "report_names": [
        "2022-08-08 - Malware sandbox evasion in x64 assembly by checking ram size - Part 1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535710,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1660795358,
    "ts_modification_date": 1660795358,
    "files": {
        "pdf": "https://archive.orkl.eu/b4cfe5db4c8b83cfcb5f9086fa1e17f3249ccc9c.pdf",
        "text": "https://archive.orkl.eu/b4cfe5db4c8b83cfcb5f9086fa1e17f3249ccc9c.txt",
        "img": "https://archive.orkl.eu/b4cfe5db4c8b83cfcb5f9086fa1e17f3249ccc9c.jpg"
    }
}