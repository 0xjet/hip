{
    "id": "4c0de931-d20c-4513-b23a-3c6986345094",
    "created_at": "2022-10-25T16:48:17.254705Z",
    "updated_at": "2025-03-27T02:13:34.650084Z",
    "deleted_at": null,
    "sha1_hash": "7f2eae392eb9c697bc39f6581770c7ad05ae5ef3",
    "title": "",
    "authors": "",
    "file_creation_date": "2013-03-28T10:38:21Z",
    "file_modification_date": "2013-03-28T10:38:21Z",
    "file_size": 487395,
    "plain_text": "# Hey, You, Get Off of My Clipboard **On How Usability Trumps Security in Android Password Managers**\n\nSascha Fahl, Marian Harbach, Marten Oltrogge, Thomas Muders, and\nMatthew Smith\n\nDistributed Computing & Security Group\nLeibniz University of Hannover\nHannover, Germany\n```\n           lastname@dcsec.uni-hannover.de\n\n```\n**Abstract. Password managers aim to help users manage their ever in-**\ncreasing number of passwords for online authentication. Since users only\nhave to memorise one master secret to unlock an encrypted password\ndatabase or key chain storing all their (hopefully) different and strong\npasswords, password managers are intended to increase username/password security. With mobile Internet usage on the rise, password managers\nhave found their way onto smartphones and tablets. In this paper, we\nanalyse the security of password managers on Android devices. While encryption mechanisms are used to protect credentials, we will show that\na usability feature of the investigated mobile password managers puts\nthe users’ usernames and passwords at risk. We demonstrate the consequences of our findings by analysing 21 popular free and paid password\nmanagers for Android. We then make recommendations how to overcome the current problems and provide an implementation of a secure\nand usable mobile password manager.\n\n**Keywords: Android, Security, Apps, Password Managers, Vulnerability**\n\n## 1 Introduction\n\nToday, using text-based passwords is the most prominent authentication scheme\nin computer systems. Although researchers have been criticising this scheme as\nbeing hard to use in a secure way, it is still the most widely adopted system\nfor authenticating users. Previous research has shown that passwords chosen by\nusers are often easy to compromise by attackers [1,2,3,7,10].\nAnother problem with the wide-spread application of passwords is password\nre-use. Users register with many services on the Internet, each requiring them to\ncreate a new username/password tuple. Previous research has shown that users\noften deal with this password overload by re-using the same or similar passwords\nfor multiple accounts [8,13].\nMultiple mechanisms have been proposed to support the user in choosing more secure passwords (cf. [12,14]), all trying to alleviate the challenges\npassword-based authentication holds for their users.\n\n\n-----\n\nHowever, due to the bounded cognitive abilities and motivation of users, password re-use is still commonplace. Password managers (PMs) aim to overcome\nthis problem: they help the user to handle a large number of different passwords\nby storing them in encrypted form. To access the encrypted passwords, the user\nusually has to enter a single master secret that decrypts the password database.\nPassword managers often include a password generator to simplify the creation of\nnew unique and secure passwords. For convenience, login forms are pre-filled and\naccount information for new websites is captured on the fly. Another prominent\nfeature is the synchronisation of password databases between multiple devices.\nWhile early password manager applications were limited to desktop computers and their browsers [11], current implementations offer mobile password manager apps, that can be synchronised over the cloud to ensure that the password\ndatabase is available on all of the users’ devices. While users of desktop password\nmanagers benefit from a smooth integration into browsers, password manager\napps on mobile platforms offer less comfort. First, web browsers on smartphones\nand tablets often do not provide a plugin interface, that would allow for a smooth\nintegration of password managers. Second, the existence of dedicated apps for\nmany online services steadily increases the number of users that access online\nservices through an app instead of a website in a general-purpose web browser.\nThis circumstance requires that mobile password managers have to be able to\nmanage passwords not only for browsers but also for apps.\nUnfortunately, there is a fundamental problem with password manager apps\non Android: The OS does not offer an API to integrate password managers with\nthe browser or other apps. This has led to the adoption of a highly insecure\npractice to overcome this weakness: Password managers use the OS clipboard\nto transfer credentials from a password manager app to the browser or other\napps. This method effectively broadcasts credentials to all apps installed on the\nsmartphone.\nWe analysed the security of 21 password manager apps on Android, having a combined install base of 2,500,000 to 10,900,000 devices[1]. We found that\napps mostly use AES, Blowfish or a combination of both to encrypt credential\ndatabases, although some apps use their own crypto implementations and do\nnot rely on a proven open-source library. Seven apps use a key derivation function to derive the symmetric encryption key from the user’s master secret to\nstrengthen the security of encrypted credentials. We found one PM that directly\ninputs the user’s password as the encryption key and truncates passwords longer\nthan 16 characters. In case the password has less than 16 characters, the string\n‘FEDCBA9876543210” is appended to “strengthen” the password. Another PM\napp uses an HMAC algorithm with SHA-256 and the fixed initialisation vector ”notverysecretiv” for key derivation for every encrypted credential tuple.\nThree password manager apps provide their own cloud synchronisation feature\nto easily share passwords between multiple devices. Two of them synchronise\nthe users’ databases over a broken TLS channel (i. e. the apps are vulnerable\n\n1 The numbers are based on information provided by Google’s Play Market. Google\ndoes not provide more fine-grained numbers for an app’s install base.\n\n\n-----\n\ndue to incomplete TLS certificate validation) and hence allow a Man-In-TheMiddle attacker to capture the databases. We investigated this problem in [5]\nin more detail and analysed 13,500 popular Android apps and found that many\napp developers failed to apply TLS appropriately. However, most critically, all\napps use the clipboard feature to transfer credentials from the password manager to browsers or other apps. Two apps automatically copy credentials to the\nclipboard when the user clicks the URL for the given online account. Only one\napp allows a user to disable the clipboard feature.\nWhile there is known malware on desktop computers that threatens passwords copied to the computer’s clipboard[2], this circumstance has not been investigated in detail yet. Hence, to the best knowledge of the authors, this paper\nis the first analysis of password managers’ security on mobile devices.\nThe remainder of the paper is organised as follows: Section 2 gives background\ninformation on password managers and discusses peculiarities of password managers on desktops and mobile devices. Section 3 describes our attack against\npassword managers on Android and illustrates how captured credentials can be\nlinked to online services and how stolen information can be transferred to the\nattacker’s server without giving the user a chance to notice. Section 4 gives more\ndetails on the security of the PMs we analysed. To understand why developers\nadded the clipboard features to their apps, Section 5 summarises open interviews with app developers. Section 6 discusses countermeasures and presents an\nimplementation of a secure and usable password manager that overcomes the\npresented vulnerabilities. In Section 7, we conclude the paper and discuss future\nwork.\n\n## 2 Background\n\nWhile early password managers were simply a username/password database embedded in desktop computers’ browsers, the features of modern password managers are much more extensive and can be categorised as follows:\n\n_Browser-Embedded PM: Most web browsers, such as Google Chrome, Microsoft_\nInternet Explorer, Mozilla Firefox or Apple’s Safari, include an embedded password management feature. In case a user logs into a website for the first time,\nthe PM inquires whether the login credentials should be saved to ease future\nlogins by automatically filling the username and password into the login form.\nThese embedded password managers traditionally store credentials locally on the\nuser’s computer, but are increasingly syncing them between multiple devices using proprietary Cloud services. Some browsers do not encrypt credentials stored\nlocally or require the user to set a master secret to enable encryption. For example, Chrome uses the Google Account password to encrypt the synced password\ndatabase by default, but offers to use a dedicated secret as an advanced feature.\n\n2 e. g.: http://www.f-secure.com/v-descs/trojan_w32_qhost_je.shtml\n\n\n-----\n\n_Browser Plugins The majority of modern desktop web browsers provide an API_\nto extend their functionality by allowing the user to install third-party plugins\nor extensions. Many password managers are hence available as browser plugins.\nKeePass[3], 1Password[4] and Lastpass[5] are prominent examples of plugin-based\npassword managers. They encrypt passwords and protect them with a master\nsecret. These third-party password managers often provide further functionality\nand act as encrypted storage for more than just usernames and passwords: other\nsensitive information such as credit card numbers, online banking information\nor secret notes can be stored as well.\n\n**2.1** **Password Managers on Desktops**\n\nPassword managers on desktop computers are generally well integrated into the\nusers’ everyday Internet-facing software, such as browsers and email clients. Regardless of whether an embedded password manager or a third-party plugin is\nused, when the user accesses an online account for the first time or creates a\nnew account, the password manager automatically comes into play and offers\nthe user to securely store the new account information. The plugin APIs of\nmodern browsers offer a very comfortable integration of password managers into\nthe users’ workflows. When a user visits a website that requires authentication,\na password manager typically auto-fills the username and password and might\neven automatically submit the login form.\nEarly password managers for desktop computers (e. g. [11]) assumed a single\ndevice environment. Nowadays users often work with multiple devices such as\ndesktops, notebooks, smartphones and tablet PCs, which makes it necessary to\nsynchronise password databases between multiple devices to have credentials\navailable whenever needed. For this reason, some password managers offer to\nsync databases between multiple devices by storing credentials in the Cloud or by\nputting the database on USB drives. A popular way to sync password databases\nis the Dropbox service. The encrypted password database is stored in the user’s\nDropbox account and can be accessed from all the user’s devices. 1Password for\nexample maintains an encrypted database for sensitive information and allows\nusers to store and share the database via their Dropbox account.\n\n**2.2** **Password Managers on Mobile Devices**\n\nWhile password managers in desktop environments are well integrated into\nbrowsers and users’ workflows, the situation for third-party password managers\non mobile platforms is different. Neither of the major mobile platforms (Android,\niOS and Windows Mobile) nor mobile browsers provide a plugin API comparable\nto desktop computers. Additionally, the paradigm shift away from the browser\n\n3 cf.: http://keepass.info/\n4 cf.: https://agilebits.com/onepassword\n5 cf.: https://lastpass.com\n\n\n-----\n\nas a generic tool to surf the Internet towards the „there is an app for everything”\napproach makes integrating PMs into mobile ecosystems even harder.\nAPI limitations and the requirement to support arbitrary apps creates a\ndifferent usage pattern for mobile PMs. Instead of storing new account information automatically and auto-filling authentication forms, the workflows of mobile\nPMs typically consist of the following steps:\n\n1. The user has to switch to the PM app,\n2. then needs to find the appropriate username/password tuple from a list of\nstored credentials,\n3. copies the password to the clipboard,\n4. switches back to the app that requires authentication, and\n5. finally pastes the password into the corresponding text field before submitting the login form.\n6. In case the user does not remember the username for a given service, these\nsteps (except step 2) are repeated for the username as well.\n\nAlthough this workflow’s usability is far from optimal, it is the best mobile\npassword managers can provide so far. To understand why users nevertheless\nuse password managers on mobile devices, we analysed 2,000 user reviews in\nGoogle’s Play Market. To this end, we downloaded user reviews, manually extracted factors that motivate users to use PMs on their Android device and\nidentified the following reasons to be substantial:\n\n**Protection: Users feel that embedded PMs do not store the passwords in a way**\nthey believe to be secure (e. g. some users were angry that Android’s stock\nbrowser does not encrypt stored usernames and passwords).\n**Confidentiality Users do not trust embedded PMs in keeping their data confi-**\ndential (e. g. users were afraid that their credentials could be sent to Google).\n**Features: Embedded PMs are usually limited to usernames/passwords. Users**\noften want to store other confidential data, such as banking information.\n**Availability: Embedded PMs are usually limited to a single browser. Since**\nmany users need access to their information on multiple devices and browsers,\na vendor-independent PM is preferred.\n\nAfter having outlined background information on password managers, the\nnext section presents our attack on PM apps on Android and illustrates its\nconsequences for the user.\n\n## 3 Password Sniffing on Android\n\nAs illustrated in Section 2.2, the workflow of mobile password managers requires\nthe user to copy account credentials to the clipboard before switching to the target app and pasting them before actually logging in. There are some problems\nwith this practice: On Android, writing data to or reading data from the clipboard does not require any permission. Therefore, every app currently running\non an Android device can read the items stored in the clipboard at any time.\n\n\n-----\n\nTo make matters worse for password managers, the Android SDK provides the\n```\nandroid.content.ClipboardManager.OnPrimaryClipChangedListener inter\n```\nface, which defines a listener callback that is invoked each time the primary\nitem on the clipboard changes. This can be used by malicious apps to harvest\npasswords as they are passed through the clipboard. As a proof of concept we\nimplemented a password sniffer named PWSniff using this mechanism. PWSniff\nruns as a background service and does not require any Android permission to\nwork properly.\nAs long as no changes to the clipboard occur, the background service idles\nand therefore does not consume any CPU cycles. Directly after a new item is\ncopied to the clipboard, the listener callback is invoked by Android and the idling\nPWSniff background service is notified and then reads the primary item. Next,\nPWSniff determines the app which is currently in the foreground. This information can also be acquired without requesting any permission. We assume that\nthe foreground app at the time of copying is the app from which a user copied\ndata (cf. Section 2.2 step 1). In case this app is a known password manager, we\nassume that the primary clipboard item is either a service URL, a username or\na password (cf. Section 2.2 step 3). Whether the app is a password manager can\nbe determined based on the app’s user ID, which is assigned at install time and\ncan be mapped to the a unique app market ID. The third step in our attack\nis to wait for a foreground app switch by checking the current foreground app\nin a loop and waiting until the user brings another app to the foreground. In\ncase we identified the primary clipboard item as possibly confidential data (no\nmatter if it is a username or a password) copied from a password manager, the\nnew foreground app is assumed to be the destination of the credentials-copyoperation (cf. Section 2.2 step 4). Hence, by exploiting features of the Android\nSDK that require no special permissions in combination with a typical workflow\nin the context of using password manager apps on Android, it is easily possible to harvest (still potentially noisy) usernames and passwords from the world\nreadable clipboard.\nAt this point, an attacker cannot be sure which item is the username and\nwhich the password. But, in many cases it is possible to differentiate between\nboth items based on their structure. Usernames are often chosen to be easily\nmemorable (e. g. an email address) while passwords, especially those which are\nmanaged with PM software, usually are more “cryptic”. Even in cases where the\nusername and password cannot be easily distinguished, an attacker could first\ntry one combination of the sniffed items and in a second attempt the reversed\norder. In both cases, breaking into an account is straightforward.\n\n_Advanced Username Capture: The attack described above relies on the user copy-_\ning and pasting both the username and the password. Since users might just type\ntheir usernames from memory or use browser or app autofill features to save this\neffort, it might become necessary to acquire the username through an alternative\nmethod. For this, PWSniff can be equipped with the GET_ACCOUNTS permission. The permission allows the app to see usernames that other apps handle\n\n\n-----\n\non the smartphone and which are registered with the AccountManager [6]. This\nalso includes all email addresses used on the device. Since many online services\nuse email addresses as usernames, this list offers a good basis from which to\nguess usernames for many services.\nThe downside of this extension is that it involves the danger of a user becoming suspicious of the app’s permissions, which are presented to the user at\ninstall time. However, Felt et al. [6] demonstrated that users pay little attention\nto the permissions of an app and mostly do not understand the permissions’\nmeaning. While Felt et al’s. results account for Android’s permission system in\ngeneral, an app’s permissions are also grouped and classified based on their security relevance. In this respect, the GET_ACCOUNTS permission does not rank\nparticularly high and thus is not often shown on the first page. To ensure that\nthe GET_ACCOUNTS permission is not shown on the first page, an attacker\nonly needs to add more than three popular permissions such as INTERNET,\nLOCATION and STORAGE which are used by many apps to his malware app.\nThe best composition of permissions to mask the GET_ACCOUNTS permission\nis outside the scope of this work.\n\n_Advanced Account Capture: In Section 3, we illustrated that an Android app_\nwhich holds no special permissions is able to sniff online account credentials\nthat are copied to the clipboard when working with any password manager on\nAndroid in most cases. It is also possible to learn from which app a value was\ncopied to the clipboard and into which app the value was pasted. If the target\napp has a special purpose (e. g. the Skype app only logs into Skype), it is easy to\nguess to which online service the harvested credentials belong. However, in case\nthe target app is a multi-purpose Internet client such as a web browser, finding\nthe intended service is not quite as straightforward.\nTo learn for which account a password is used, an attacker can benefit from\nAndroid’s ProcFS features. The ProcFS is an interface to the kernel and provides information about a device such as information about the CPU, memory\nand network details. On Linux-based systems such as Android, the ProcFS is\nusually mounted at /proc. Most entries in /proc and its subdirectories can be\nread by everyone. The /proc/net/tcp file contains information about all TCP\nconnections on an Android device and is also world-readable and hence accessible by every app without requiring any permissions. Information such as source\nIP and port, destination IP and port and the UID of the process that created\nthe network connection are listed there. Since Android creates a static mapping\nof Apps to a UID at install time, one can easily learn which app connects to\nwhich Internet hosts based on the UID entry in /proc/net/tcp. Having the\ndestination IP for an app’s network connection at hand allows an attacker to\neasily infer to which online service a credential pair is connected by logging all\nnetwork connections of an app, immediately after a copy operation from a PM\nto another app was discovered.\n\n6 cf.: http://developer.android.com/reference/android/accounts/AccountManager.html\n\n\n-----\n\n_Exfiltrating the Data: In [5], we found that 92.8 % of 13,500 popular An-_\ndroid apps request Internet access. Adding the Internet permission to PWSniff should thus not raise undue concern. With this permission, transmitting\nthe harvested data is of course trivial. However, if a zero permission attack\napp is desired, exfiltration of the harvested data can still be done using another flaw in Android’s permission system. Egners et al. [4] describe a loophole\nin Android’s permission system that we adopt for our purposes and which allows PWSniff to send gathered credential information to a remote HTTP server\nwithout requiring the Internet permission. After the account login information\nwas gathered, the harvested data is cached until the device’s display is turned\noff. When this happens, an HTTP URL with the following structure is built:\n```\nhttp://<pwsniff-master>/pw#username#service. This URL is used to invis\n```\nibly open Android’s stock browser when the display is turned off by running\nthe following code in PWSniff. We explicitly call Android’s stock browser since\nsome third-party browsers do not hand back control for unknown protocols to\nthe Android OS, which is required to keep the attack stealthy.\nThe server behind the URL replies with a location header containing a custom\nprotocol, for example: ’Location:pwsniff://all.ok’. Since PWSniff includes\n[an activity that previously registered for the custom pwsniff:// protocol, the](pwsniff://)\n[browser passes handling for the URI pwsniff://all.ok to PWSniff. Staying](pwsniff://all.ok)\ninvisible, the activity then simply terminates.\nAfter demonstrating how credentials can be sniffed when Android password\nmanagers are used, how they can be mapped to online accounts and how this\ninformation can be exfiltrated stealthily, the next section gives some relevant\nexcerpts of our detailed security analysis of PMs on Android.\n\n## 4 Security in Detail\n\nWe analysed 13 free and 8 paid Android PM apps in detail. Our intention was\nto analyse which apps include the clipboard feature for credential copy & paste,\nwhich encryption algorithms protect the password database, whether or not the\napp includes an embedded browser, whether or not the SD card is used to store\nthe password database and whether or not the app removes itself from the recent\napps view. For analysis, we installed all apps on a Samsung Galaxy Nexus with\nAndroid 4.0. We applied forensic techniques[7] to learn database and configuration\nfiles’ structures of the installed password manager apps. To learn internals of the\npassword managers, we decompiled them[8] and conducted manual static code\nanalysis.\n\n7 We used the adb tool (cf.: http://developer.android.com/tools/help/adb.html) for\nlogical extraction.\n8 We used a bundle of decompilation tools: JD-GUI\n(cf.: http://java.decompiler.free.fr/?q=jdgui), apktool (cf.:\nhttp://code.google.com/p/android-apktool/) and dex2jar (cf.:\nhttp://code.google.com/p/android-apktool/)\n\n\n-----\n\nWe also conducted static code analysis on the same dataset as in [5] and found\nthat only two apps in this dataset registered for the clipboard change listener.\nWe analysed both apps manually and found no malicious behaviour in the apps.\n907 apps (6.7 %) in the sample access the clipboard API programatically to\nshare more complex objects than simple text strings such as images, video or\naudiofiles.\nTable 1 in the Appendix shows an overview of the security parameters we\nanalysed.\n\n**4.1** **Encryption**\n\nOne important aspect of PM security is the encryption mechanism to store credential databases. Android’s stock browser does not encrypt stored passwords in\nany way but protects them from unauthorised access by file system permissions.\nAndroid’s AccountManager mechanism provides centralised credential storage\nand also protects user credentials from unauthorised access by file system permissions, but the accounts.db database is not protected with an extra layer of\nencryption. This does not protect the password from forensic analysis.\nAll third party PMs we analysed apply some encryption mechanism to protect\nthe data. Android supports (3)DES, RC2, and RC5[9] to encrypt data out of\nthe box. Other encryption algorithms require the developer to add third-party\nlibraries to their app. We decompiled the PMs to find out what kind of encryption\nalgorithm is applied in each PM app. To provide stronger security, most password\nmanaging apps use the Advanced Encryption Standard (AES) with several key\nlengths. aWallet uses a combination of AES, Blowfish and 3DES.\nA critical aspect of encrypting password databases is the derivation of the\nencryption key [9] that is directly connected to the master secret used to unlock/decrypt the password database. Seven apps use a dedicated key derivation\nfunction to derive the symmetric encryption key from the user’s master secret\nto strengthen the security of encrypted credentials. We found one app that directly inputs the user’s password as the encryption key, truncating passwords\nlonger than 16 characters. In case the password has less than 16 characters, the\nstring ”FEDCBA9876543210” is appended to ”strengthen” the password. Another\napp uses an HMAC algorithm with SHA-256 and the fixed initialization vector\n```\n”notverysecretiv” for key derivation.\n\n```\n**4.2** **Storage**\n\nMost password managers, including Android’s stock browser, store password\ndatabases in files or SQLite databases that are only accessible by the password\nmanager app itself. Hence, other Android apps cannot access account information regardless of whether it is encrypted or not. Ten of the analysed PMs\n\n9 cf.: http://developer.android.com/reference/javax/crypto/spec/packagesummary.html\n\n\n-----\n\nstore databases on the SD card that is world readable without requiring further permissions on all devices with Android 4.0 and older. In combination with\ninappropriate database structures (not encrypting all information stored in the\npassword manager), an attacker is for instance able to learn for which services a\nuser holds accounts or for which services the same username and/or passwords\nare used.\n\n**4.3** **Recent Apps**\n\nAn essential feature of Android devices is an overview of the currently running\napps, also called the Recent Apps View. The Recent Apps View shows thumbnails\nof current foreground activities of all running apps. While a security feature\nof all analysed password managers is the automatic locking of the password\ndatabase either immediately after the password manager app was left or after\na configurable amount of time, we found only three apps that also replace their\nthumbnails in the recent apps view (cf. Table 1). In case the user copied online\naccount information (usually the location, username and password) and then\nleaves the password manager app to paste the information into another app, the\naccount information is left in the recent apps view and can be seen by anyone\nwith physical access to the user’s device. Although this threat is orthogonal to\nour attack (cf. Section 3), it outlines a security risk for users’ online credentials.\n\n**4.4** **Cloud Sync**\n\nWhile all password managers store their databases locally and allow synchronisation of their databases, most offer a more manual functionality using Dropbox\nor similar services. LastPass, SecureSafe and RoboForm provide dedicated Cloud\nstorage features to automatically synchronise all passwords remotely. In [5] we\nanalysed popular Android apps and found that many app developers fail to apply TLS appropriately, being vulnerable to active Man-In-The-Middle attacks.\nAlthough LastPass, SecureSafe and RoboForm protect their network communication with TLS, SecureSafe and RoboForm fail to verify the cloud servers’ TLS\ncertificates. Instead, they accept all certificates. In case of SecureSafe this however has not further security implications since in addition to TLS, SecureSafe\nuses a session-specific symmetric key, which is set up during the SRP-login[10], to\nadditionally encrypt password-data end-to-end. However, RoboForm leaks the\nusers’ credentials which are used for password encryption in the default case (i. e.\nthe user did not choose an extra password for encryption). Hence, an attacker\ncan gain access to the data in cleartext under this circumstances.\n\n## 5 The Developers View\n\nAfter analysing Android password managers on a technical basis, we contacted\ntheir developers via email and informed them about a possible security threat\n\n10 cf. RFC2945\n\n\n-----\n\nfor their users. We offered them to get in contact either via email or telephone to\ndiscuss the details of the PWSniff attack. We also posed the following questions:\n\n**– Why was the C&P feature used in the password manager app?**\n**– Were developers aware of the security threats arising from using the clip-**\nboard for username/password sharing, and, if so, why did they add the C&P\nfeature nonetheless?\n**– Which features, if any, do developers miss in Android’s SDK for developing**\na password manager app?\n\n15 of the 21 developers agreed to participate in the email interview and are\nanonymously referred to as P1, . . ., P15 in the following.\n\n**5.1** **Results**\n\nDuring the discussions with developers, we were able to identify three different\nreasons to add the usability-enhancing clipboard feature to PM apps. One was\nbecause the developers themselves were users of their apps and desired the feature themselves. (“As I’m a [. . . ] program user too, I added the copy feature\nbecause I needed to transfer usernames (that are usually long email addresses)\nand passwords to login forms in web browsers.”; P7). The second reason provided\nby PM developers was the wish to come as close as possible to PM functionality\non the desktop, because developers believed that users would reject their apps\nif they were not sufficiently usable. (“Copy to clipboard has been in [. . . ] Android from early on. [. . . ] It was something that we knew we needed to make the\napplication usable at all”; P4). Lastly, developers reported that users directly\nrequested a C&P feature for their app (“The feature was highly requested by\nusers. The most common example: users want to login to a website on their\nmobile device, so he/she copies credentials from [our PM] to the clipboard and\nthen pastes them into the browser.”; P15).\nAll but one developer were aware of security threats resulting from putting\npasswords into a device’s clipboard. Developers who were aware of the security\nthreat justified adding the clipboard integration, stating that they had no other\nchoice. They described it as a tradeoff between usability and security which was\ndecided in favour of increasing usability (“It’s a balance between ease of use\nand security. Of course it would be much more secure to not use the clipboard,\nhowever people accept the risk of doing so; the alternative of not using a password\nmanager is worse.”; P3). One developer interestingly described his decision not\nas a usability-security tradeoff but as a “one type of security versus another type\nof security” decision, alluding to the fact that without password managers users\nwould choose less secure passwords. Additionally, P4 stated: “On the whole,\nI think that password reuse [. . . ] is currently the biggest single problem with\npassword security today. And so, if a password manager gets people to use unique\npasswords for each site, the dangers of a publicly readable clipboard is a security\nrisk that can be worthwhile. [. . . ] What’s the alternative?”.\nAll developers criticised Android’s missing support for password manager\napps. A native integration into third party apps and browsers was described as\n\n\n-----\n\nthe most effective countermeasure against the password sniffing security threat\n(“Android doesn’t offer hooks into the native default browser [. . . ] and does not\nallow our app to access input fields of other apps [. . . ] which makes it necessary\nthat password managers make heavy use of the clipboard.”; P3).\n\n**5.2** **Discussion**\n\nBased on the lack of API support for third-party password managers on the\nAndroid OS, developers decided to opt for the best usability they could achieve\nby including the clipboard feature to allow users to copy-and-paste usernames\nand passwords from their apps to other apps. Although all but one developer\nwere aware of the possible security threat, they decided that better usability\nwas more important than stronger security. A justification multiple developers\noffered was that they had no other choice and that it was necessary to add the\nbest possible usability even if security was threatened.\n\n## 6 Countermeasures\n\nWith the results of our analysis and the developers’ comments in mind, we\nfirst discuss possible countermeasures to improve the security of a smartphone’s\nclipboard facilities as a global shared memory. Additionally, we present a PM\nimplementation for Android based on a customised soft-keyboard that provides\nusability features similar to desktop PMs and does not leak credentials over\npublic channels.\n\n_Secure Clipboard Architecture: Sniffing confidential information on Android de-_\nvices is currently easy since on the one hand, a proper plugin API for integrating\npassword managers is missing and, on the other hand, the design of the current\nclipboard mechanism on Android is not made for sharing confidential information\nbetween apps. The current clipboard model allows an arbitrary app to access\nclipboard items deposited by any other app. With the assumption that both,\nthe copy as well as the paste operation are triggered by the user, such a clipboard model does not cause security concerns. However, on Android, two other\nAPI features open the door for malicious activity: Android’s background service\nfeature for apps and the ClipboardManager.OnPrimaryClipChangedListener\nallow for stealthy harvesting of clipboard items (cf. Section 3). Therefore, we\npresent two possible modifications to improve Android’s clipboard model when\nit is accessed using API functionalities:\n\n**Permissions The current clipboard model allows every app to programmat-**\nically read data from and write data to the clipboard, without requiring\npermission for that. While user-triggered clipboard operations can remain\nunchanged, we propose two new permissions for API-based access to clipboard functionality: WRITE_TO_CLIPBOARD and READ_FROM_CLIPBOARD. Although the limited effects of Android’s permission model for the average\n\n\n-----\n\napp user have been discussed (cf. Felt et al. [6]), these permissions should be\nadded for completeness. This way, at least the tech-savvy users would have\na chance to see if an app is capable of accessing the clipboard programmatically and can warn the rest of the community. Since we identified only very\nfew apps to access the clipboard programatically (cf. Section 4), the proposed\nchanges would only impact a small number of apps. Regular, user-triggered\ncopy-and-paste operations would not be influenced by this modification.\n**Targeted Clipboard Copying a value to the clipboard on current Android**\nsmartphones is equivalent to broadcasting the information to all other apps.\nThis is contrary to the users’ intuition of using a copy-and-paste feature that\nis generally used to transfer information from one app to another. Therefore\nwe propose to extend API calls to the clipboard with a “target app” parameter that the app may request from the user. Keeping usability in mind, the\nnumber of target apps should be kept to a minimum. Apps providing an\nAPI-based copy feature may let the user choose target apps from a list of\nall apps or suggest useful targets as well as remember previous preferences.\nIf clipboard operations are triggered by the user, reading the clipboard’s\ncontents should only be possible through explicit user interaction as well.\n\nThe modifications to Android’s current clipboard model proposed above do\nnot only protect credentials from unwanted disclosure, but can also serve to\nshield any other (possibly confidential) information (such as financial or medical\ninformation), that a user might copy to the clipboard.\n\n_USecPassBoard: While the above solutions would alleviate the current security_\nproblems of PMs, they would also require modification of the Android OS itself.\nAdditionally, these measures cannot address the usability issues of mobile PMs,\ni. e. that the user needs to manually select credentials, switch apps and manually\npaste. To offer both better security and usability we propose a novel password\nmanager: USecPassBoard. To overcome the issues plaguing the traditional approach of mobile password managers, we went down a different path. We created\na soft-keyboard which integrates a password manager. Since soft-keyboards are\navailable in every app and can access a shared credential database, they integrate\nwell with most scenarios where credentials need to be entered. A custom softkeyboard implementation on Android replaces the default keyboard and provides\na custom means to input data into user-input fields. Figure 1 in the Appendix\nshows the user interface of the USecPassBoard PM. Besides preserving the regular keyboard functionality, it essentially adds two operations: (1) Creating a\nnew username/password entry and (2) inserting a username/password tuple at\nthe user’s discretion. Since USecPassBoard is a soft-keyboard, it is available in\nevery application, including the browser and stores passwords in a master secretprotected AES-256 encrypted database[11] to protect username/password tuples\nfrom unauthorized access. This effectively avoids the use of copy-and-paste on\nusernames and passwords while maintaining the flexibility of all available password managers.\n\n11 We use the SQLCipher (cf.: http://sqlcipher.net/sqlcipher-for-android/) database.\n\n\n-----\n\n_New Account: USecPassBoard analyses the context of user input to determine if_\ncredentials are being entered. The password context is determined by identifying\nwhich app is currently used (i. e. which app is in the foreground) and in case\nthe foreground app is a browser, it determines the website which is displayed by\nreading the browser’s first item cached in the history. Apps are uniquely identified\nbased on their package names managed by the Android operating system[12].\nUSecPassBoard then caches the input of all textfields in the foreground activity.\nThis is possible since soft-keyboards on Android are triggered when a textfield\nis activated by the user. Additionally, a soft-keyboard receives a reference of the\n`EditorInfo class[13]` which identifies an input as a text or a password field. After\nthe user completes the input and the keyboard loses the focus on a password\nfield, a notification is displayed in the status bar that a new dataset was created\n(cf. Figure 1) if there is no identical username/password tuple for the current\ncontext in the database. New username/password tuples are bound to the target\napp – based on its package name – and are not available for possibly malicious\napps. In case the user would like to share credentials between different apps\n(e. g. between two Facebook client apps), we allow this in the settings menu of\nUSecPassBoard.\n\n_Credential Insertion: In case USecPassBoard recognises a known password con-_\ntext (i. e. a package name of an app for which credentials are stored in the\ndatabase), the user can choose to insert this information by tapping into the input field for the username or password. A popup message appears after the user\ntapped onto the key button (cf. Figure 1) and a list of available credentials for\nthe given password context is displayed. Subsequently the selected username/password tuple is inserted at the user’s discretion and the login process can be\nstarted.\n\n_Security Considerations: All interactions between the USecPassBoard virtual_\nkeyboard and a target app must be initiated by the user by tapping into a text\ninput field. This creates a communication channel between the keyboard and the\ntarget app through Android’s InputMethodManager[14] which is not accessible\nfrom other third party apps. This allows the automatic storage of new account\ncredentials and insertion of stored credentials into uniquely identifiable target\napps.\nTarget apps are uniquely identified based on their package name that is\nmanaged by the Android OS and cannot be spoofed by malicious apps[15]. In\ncase the target app is the browser, a password context consists of the browser’s\npackage name and a target website. We identify the target website by reading the top item from the browser’s history. This is accessible with Android’s\nREAD_HISTORY_BOOKMARKS permission and gives us the currently viewed\nwebsite. Hence, we can avoid that users falsely insert credentials another website.\n\n12 cf.: http://developer.android.com/guide/topics/manifest/manifest-element.html\n13 cf.: https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html\n14 cf.: http://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html\n15 cf.: http://source.android.com/tech/security/\n\n\n-----\n\n## 7 Conclusions\n\nWith the rise of mobile devices, mobile password manager apps could be an\nintegral security tool for smartphone and tablet PC users. Since Android based\ndevices lack APIs for the integration of password managers, current solutions rely\nheavily on the clipboard to share credentials between the PM and other apps.\nWe analysed 21 popular password managers on Android which all are vulnerable\nto credential sniffing because a device’s clipboard is a publicly available storage\nthat can be accessed from any app. We showed that, using additional context\ninformation, malware is able to link the stolen credentials to the corresponding\nonline account in many cases. We interviewed developers of the analysed PM\napps and found that the majority of them were aware of possible security threats\nbut accepted the risk to provide better usability. Based on the analyses’ findings and developers’ feedback, we discuss modifications to Android’s clipboard\nmechanism to increase security for sensitive information. Finally, we present a\nsoft-keyboard that integrates a secure and easy-to-use password manager which\nprevents the leakage of usernames/passwords via the clipboard. This password\nmanager design is the first to offer both usability and security for Android-based\npassword managers.\nSince, in addition to security, usability is crucial for a password manager,\nin future work we plan to conduct multiple user studies for the USecPassBoard\npassword manager.\n\n\n-----\n\n## References\n\n1. M. Bishop and D. V Klein. Improving system security via proactive password\nchecking. Computers & Security, 14(3):233–249, 1995.\n2. J. Bonneau. The Science of Guessing: Analyzing an Anonymized Corpus of 70\nMillion Passwords. Security and Privacy (SP), 2012 IEEE Symposium on, pages\n538–552, 2012.\n3. M. Dell’Amico, P. Michiardi, and Y. Roudier. Password Strength: An Empirical\nAnalysis. In INFOCOM, 2010 Proceedings IEEE, pages 1–9, 2010.\n4. A. Egners, B. Marschollek, and U. Meyer. Messing with Android’s Permission\nModel. In IEEE International Conference on Trust, Security and Privacy in Com_puting and Communications, (IEEE TrustCom-12), May 2012._\n5. S. Fahl, M. Harbach, T. Muders, L. Baumgärtner, B. Freisleben, and M. Smith.\nWhy eve and mallory love android: an analysis of android ssl (in)security. In Pro_ceedings of the 2012 ACM conference on Computer and communications security,_\nCCS ’12, pages 50–61, New York, NY, USA, 2012. ACM.\n6. A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner. Android\npermissions: user attention, comprehension, and behavior. In Proceedings of the\n_Eighth Symposium on Usable Privacy and Security, SOUPS ’12, pages 3:1–3:14,_\nNew York, NY, USA, 2012. ACM.\n7. D. Florencio and C. Herley. A large-scale study of web password habits. Proceedings\n_of the 16th international conference on World Wide Web, pages 657–666, 2007._\n8. S. Gaw and E. W. Felten. Password management strategies for online accounts. In\n_Proceedings of the second symposium on Usable privacy and security, SOUPS ’06,_\npages 44–55, New York, NY, USA, 2006. ACM.\n9. B. Kaliski. PKCS #5: Password-Based cryptography specification version 2.0. RFC\n2898, Internet Engineering Task Force, Sept. 2000.\n10. D. Malone and K. Maher. Investigating the distribution of password choices. In\n_Proceedings of the 21st international conference on World Wide Web, WWW ’12,_\npages 301–310, New York, NY, USA, 2012. ACM.\n11. B. Ross, C. Jackson, N. Miyake, D. Boneh, and J. C. Mitchell. Stronger password\nauthentication using browser extensions. In Proceedings of the 14th conference on\n_USENIX Security Symposium - Volume 14, SSYM’05, pages 2–2, Berkeley, CA,_\nUSA, 2005. USENIX Association.\n12. R. Shay, P. G. Kelley, S. Komanduri, M. L. Mazurek, B. Ur, T. Vidas, L. Bauer,\nN. Christin, and L. F. Cranor. Correct horse battery staple: exploring the usability\nof system-assigned passphrases. In Proceedings of the Eighth Symposium on Usable\n_Privacy and Security, SOUPS ’12, pages 7:1–7:20, New York, NY, USA, 2012._\nACM.\n13. R. Shay, S. Komanduri, P. G. Kelley, P. G. Leon, M. L. Mazurek, L. Bauer,\nN. Christin, and L. F. Cranor. Encountering stronger password requirements: user\nattitudes and behaviors. In Proceedings of the Sixth Symposium on Usable Privacy\n_and Security, SOUPS ’10, pages 2:1–2:20, New York, NY, USA, 2010. ACM._\n14. B. Ur, P. G. Kelley, S. Komanduri, J. Lee, M. Maass, M. L. Mazurek, T. Passaro,\nR. Shay, T. Vidas, L. Bauer, N. Christin, and L. F. Cranor. How does your password\nmeasure up? the effect of strength meters on password creation. In Proceedings\n_of the 21st USENIX conference on Security symposium, Security’12, pages 5–5,_\nBerkeley, CA, USA, 2012. USENIX Association.\n\n\n-----\n\n## A Investigated Password Managers\n\n**Table** **1.** Overview of the analysed Android password manager apps.\n(EM=Encryption Method, KD=Key Derivation, C&P=copy&paste functionality, EB=Embedded Browser, SD=Writes database to SD card, RA=Removes\nitself from the recent apps view)\n\nFree\n**App** **Installs[1]** **EM** **KD** **C&P EB** **SD** **RA**\nPassDroid 100-500k AES SHA-256 ✓ – Backup ✓\n1Password 100-500k AES PBKDF2 ✓ ✓ Always ✓\nKeePassDroid 500k-1m AES[1] SHA-256 ✓ – Always ✓\nUPM 100-500k AES PBE ✓ – Backup ✓\nPocket 100-500k AES PBE ✓ – Backup ✓\nNS Wallet 10-50k AES – ✓ – ✓ ✓\nLastPass 100-500k AES _◦[4]_ ✓ ✓ – –\nPasswdSafe 10-50k AES – ✓ – ✓ ✓\nOI Safe 100-500k AES PBE ✓ – ✓ ✓\naWallet 100-500k AES[2] SHA-256 ✓ – Backup ✓\nMoxier Wallet 10-50k AES SHA-256 ✓ – – ✓\nKeeper 1-5m AES SHA-1 ✓ ✓ Backup ✓\nRoboForm 100-500k _◦[4]_ _◦[4]_ ✓ ✓ Backup ✓\nPaid\nmSecure 100-500k Blowfish SHA-256 ✓ – ✓ –\nSecret Safe 50-100k AES[3] SHA-256[3] ✓ – Backup ✓\nSafeWallet 10-50k AES HmacSHA1 ✓ – ✓ ✓\nSPB Wallet 10-50k AES _◦[4]_ ✓ – ✓ ✓\neWallet 10-50k AES PBE ✓ – ✓ –\nHandy Safe Pro 10-50k Blowfish – ✓ – – ✓\nDataVault 1-5k AES – ✓ – Backup ✓\nPassword Box 5-10k AES – ✓ – ✓ ✓\n\n1 KeePassDroid combines AES and Twofish\n2 aWallet combines AES, Blowfish and 3DES\n3 Secret Safe combines AES and Twofish for encryption and multiple rounds\nof SHA-256 and Whirlpool for key derivation.\n4 This information could not be found by reverse engineering.\n\n\n-----\n\n## B USecPassBoard User Interface\n\n\n(a) Asking the user to store new\ncredential tuple.\n\n(c) Selecting existing credential\ntuple.\n\n\n(b) Successfully stored new credential tuple.\n\n(d) Credentials filled in.\n\n\n**Fig. 1. The USecPassBoard workflow for storing new credential tuples and filling in**\nstored credentials.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://saschafahl.de/static/paper/pwmanagers2013.pdf"
    ],
    "report_names": [
        "pwmanagers2013.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1364467101,
    "ts_modification_date": 1364467101,
    "files": {
        "pdf": "https://archive.orkl.eu/7f2eae392eb9c697bc39f6581770c7ad05ae5ef3.pdf",
        "text": "https://archive.orkl.eu/7f2eae392eb9c697bc39f6581770c7ad05ae5ef3.txt",
        "img": "https://archive.orkl.eu/7f2eae392eb9c697bc39f6581770c7ad05ae5ef3.jpg"
    }
}