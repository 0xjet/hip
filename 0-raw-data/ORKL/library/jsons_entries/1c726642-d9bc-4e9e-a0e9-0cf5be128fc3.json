{
    "id": "1c726642-d9bc-4e9e-a0e9-0cf5be128fc3",
    "created_at": "2023-01-12T15:06:20.052444Z",
    "updated_at": "2025-03-27T02:16:25.505448Z",
    "deleted_at": null,
    "sha1_hash": "3ac814bf416d7769ea515b2f7324a0d3b5cba3b4",
    "title": "Advanced Metamorphic Techniques in Computer Viruses",
    "authors": "",
    "file_creation_date": "2008-11-14T11:27:34Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 318187,
    "plain_text": "## Advanced Metamorphic Techniques in Computer Viruses\n\n#### Philippe Beaucamps\n\n\n**_Abstract—Nowadays viruses use polymorphic techniques to mu-_**\ntate their code on each replication, thus evading detection by antiviruses. However detection by emulation can defeat simple polymorphism: thus metamorphic techniques are used which thoroughly\nchange the viral code, even after decryption. We briefly detail this\nevolution of virus protection techniques against detection and then\nstudy the METAPHOR virus, today’s most advanced metamorphic\nvirus.\n\n**_Keywords—Computer virus, Viral mutation, Polymorphism, Meta-_**\nmorphism, MetaPHOR, Virus history, Obfuscation, Viral genetic\ntechniques\n\nI. INTRODUCTION\n\nHen the first antiviral protections appeared in the late\n80’s to answer the nascent viral threat, they consisted\n# W\nof a mere binary scan of programs looking for known virus\nsignatures. Never mind, virus writers adapted their code so that\nit would mutate its binary form on each replication: as early as\nin 1988 a first virus protected itself using encryption, followed\nin 1990 by the first polymorphic viruses which were able to\nmutate their code as well as their decryption method. Their\nability to evade detection by the then antivirus software gave\nthem immediate “popularity”. Nevertheless antiviruses quickly\nadapted to this protection by letting viruses decrypt themselves\nand then only scanning the decrypted code looking for any\nknown signature. This led, as early as in 1997, to the first\n_metamorphic viruses which mutate their code in its decrypted_\n_form._\nThis article will therefore study polymorphism and its miscellaneous techniques and more particularly the most evolved\nones, namely metamorphic techniques. In order to do so, we\nwill study most notably the 2002 METAPHOR virus. For more\ndetails, the reader may consult Eric Filiol’s books [Fil05],[´]\n\n[Fil07] as well as the VX Heavens website, which is crammed\nwith malware resources.\n\n\n_A. First viruses_\n\nThe first virus outbreak broke out in 1981 with the ELK\nCLONER virus, followed by BRAIN in 1986, the first virus\nto implement stealth techniques, and from then by numerous\nother viruses. The most commonly used techniques consisted\nin appending the viral code at the end of the executable\nfile, modifying the entry point to point at the virus and then\nletting the virus spread among the system (fig. 1). Thus, a\nbasic protection method is form analysis where each virus\nis identified by a specific signature: such a signature is a\nsequence of – not necessarily consecutive – bytes whose\ndetection inside a program allows to identify as undeniably as\npossible infection by the virus. This method has the advantage\nof being non-greedy in its complexity as well as subject to a\ntiny rate of false alarms.\n\n\nII. POLYMORPHISM – EARLY STAGES\n\nThis section shortly describes the evolution and techniques\nof viruses from the most basic techniques to simple polymorphic techniques and finally to advanced metamorphic\ntechniques. The reader may refer to [Fil05], [Fil07], [Szo05],\n\n[Ayc06] for a more exhaustive and detailed study.\n\n\nBack in time, as early as in 1984, F. Cohen had been the\nfirst one to study viruses from a theoretical point of view,\nchristening them and defining them as programs which are\nable to infect other programs with a possibly evolved copy of\nthemselves. Thus, this definition already suggested the existence of viruses which would alter their form when replicating.\nAnd indeed such viruses turned up quite quickly. Cohen also\nshowed that the problem of virus detection was undecidable,\nmeaning in other words that no algorithm would ever be able\nto determine with unquestionable certainty whether a given\nprogram is a virus or not [Coh84].\n\n_B. Polymorphic viruses_\n\n\nPhilippe Beaucamps is with the Loria, Nancy, France, email:\nph.beaucamps at loria dot fr,\nand also with the Virology and Cryptology Lab of the Ecole Sup´erieure et[´]\nd’A li ti d T i i (A Si l A d ) R F\n\n\nThe first virus encrypting its code, CASCADE, appeared in\n1988. Yet its decryption method remained unchanged from one\nreplication to another and th s it as not reall a pol morphic\n\n\n-----\n\nvirus per se. In 1990 however, the first family of polymorphic\nviruses appeared: the CHAMELEON viruses (or V2P) which\nwere developped by Mark Washburn, were based on the\nCASCADE and VIENNA viruses and mutated the code of their\ndecryption method (fig. 2). The shock they created shaked the\nantiviral community, since detection techniques using a fixed\nsignature had suddenly become obsolete for this new brand of\nviruses.\n\nFig. 2. Polymorphic virus infection.\n\nThe famous WHALE virus appeared the same year: it\nincluded polymorphism, stealth and armouring techniques and\nmutated in particular the code of its mutation function using\nobfuscation techniques (dead code, test repetition, redundant\ncode, ...). Then “boards” appeared, where were shared viruses\nand e-zines, among which Phrack and 40Hex, and where\nwere worked out and shared new viral techniques. Then in\n1992 the first polymorphic engines appeared, like MTE, TPE,\nNED and DAME[1], which could be linked to the virus to\nproduce a polymorphic variant. They were quickly followed\nby the first virus creation toolkits, like VCL, PS-MPC and\nG2[2], some of which including polymorphism features. This\nsignalled the start of massive creation – in thousands – of\nsimple and polymorphic viruses.\n\nOn the antiviral community side, the answer came in 1992\nwhen Eugene Kaspersky worked out a technique now used by\nmost antivirus products, namely detection by code emulation.\nSince one could not anymore rely on the static version of\na program’s code to detect a virus, the code was run in a\ncontrolled (emulated or sandboxed) environment on a given\nnumber of instructions, and periodically or in the end the\naffected memory was analysed to detect the (possibly partially)\ndecrypted viral code. Indeed, and this is the base principle of\nmetamorphism, polymorphic codes had the major drawback of\nalways decrypting themselves into the memory into an invariant and thus detectable form. However this detection technique\n\n1MUTATION ENGINE (MTE) by Dark Avenger, TRIDENT POLYMORPHIC\nENGINE (TPE), NUKE ENCRYPTION DEVICE (NED) and DARK ANGEL’S\nMULTIPLE ENCRYPTOR (DAME).\n2VIRUS CONSTRUCTION LAB (VCL), PHALCON/SKISM MASS-PRODUCED CODE GENERATOR (PS-MPC) and PHALCON/SKISM’S G2 VIRUS\nG (G2)\n\n\nMetamorphic viruses are in a sense advanced polymorphic viruses: on each replication, the code to be executed\ncompletely mutates, without altering its functionality. Thus,\nencryption is not anymore necessary and, when used, the\ndecryption method as well as the decrypted code of the virus\nare different for each new generation. Figure 3 presents a\nbasic example of infection by a metamorphic virus, on its\ni[eme] mutation: in practice, the code is often encrypted and the\ndecryption routine is sometimes scattered among the host’s\ncode (ZMIST virus for instance).\nThe first metamorphic techniques made their appearance\nin 1997 with the TINY MUTATION COMPILER (TMC), by\nEnder. This virus had a compiler embedded in its body as well\nas its own sources in encrypted pseudocode. On execution, the\nvirus decrypted its source code, inserted dead code, mixed up\nits code and data, and recompiled everything.\nOn the same year, Z0mbie developped his Z0MBIE’S\nCODE MUTATION ENGINE (ZCME), which did not use any\nencryption techniques but allocated a 16K buffer where it\nrandomly copied out its instructions, linking them with each\nother with JMP instructions and filling the remaining space\nith dead code\n\n\nalso has the disadvantage of being quite cpu-intensive.\nSeveral techniques, called anti-emulation techniques, have\nbeen developped as a result by virus writers to hinder this kind\nof detection:\n\n - Using unusual instructions which an emulator might not\nsupport and interpret, or similar tricks that would prevent\nthe virus from decrypting itself correctly or that would\nbetray the presence of an emulator.\n\n - Inserting dead code that will loop long enough to have the\nemulator give up on detection, relying on the prohibitive\ncost of emulation (this technique is used by the BISTRO\nvirus for instance).\n\n - Random cancelling of decryption, thus running the viral\ncode only a random basis.\n\n - Entry Point Obscuring (EPO) techniques, which consist\nin avoiding executing the virus body at the very beginning\nof the host’s execution, but rather executing it during the\nhost execution or even in the end.\n\n\n\n - Using several encryption layers.\n\n - Decrypting and running the code chunk by chunk, some\nviruses decrypting and running only one instruction at a\ntime (like the DARK PARANOID virus, in 2004).\n\n - Metamorphic techniques, which transform the encrypted\ncode.\nThese techniques are detailed in the literature [Fil05],\n\n[Fil07], [Ayc06]: some of these techniques are used by\nMETAPHOR and we shall come back on them in the next\nsection.\nFinally, we state Spinellis’s recent result [Spi03], which\nestablishes the general complexity of the detection of such\nviruses. He shows that the problem of detecting polymorphic\nviruses, of bounded length, is NP-complete, by reducing to it\nthe well-known SAT problem of satisfiability.\n\n_C. Metamorphic viruses_\n\n\n-----\n\nFig. 3. Metamorphic virus infection on generation i.\n\nIn 1998, Vecna implemented MISS LEXOTAN, which disassembled itself, added some dead code and modified the\nform of its instructions, in a computational way most particularly (see later). To create dead code, it inserted most\nnotably meta-instructions XOR ebp, imm, with no effect,\nbut which defined which registers were used and thus should\nnot be modified. He also implemented REGSWAP later, which\nshuffled the registers. Here is an excerpt from LEXOTAN:\n\n```\nxor bp, __fill + __ax + __bx + __flag\n  ; tells that registers ax, bx and\n  ; the FLAGS are used by the code\nadd ax, bx\nxor bp, __fill + __ax + __flag\nadd ax, 10h\npush ax\nmov ax, 0\n\n```\n\nAfter transformation, this code may look like this, with no\njumps:\n```\n xor bp, __fill + __ax + __bx + __flag\n mov dx, bx\n xor cx, cx ;\n push cx ; dead code\n add ax, dx\n pop cx ;\n xor bp, __fill + __ax + __flag\n mov bx, 34h\n push bx\n mov bx, ffCCh\n pop ax\n add ax, bx\n xor bx, bx\n push ax\n mov bx, 10h\n sub ax, ax\n\n```\n\nIn 2000, the BADBOY, ZMORPH, EVOL, ZPERM, BISTRO\nand ZMIST viruses enter the growing list of metamorphic\nviruses, using more or less complex techniques. ZPERM\nmost notably introduces the REAL PERMUTATION ENGINE\n(RPME), which can be linked to other viruses, and enables\nrandom permutation of the virus code, with insertion of dead\ncode and branching using JMP instructions.\nZMIST, by Z0mbie, is more particularly one of the most\nevolved (and most stable) metamorphic viruses until now. It\nuses the following techniques:\n\n - Entry Point Obscuring (EPO).\nMetamorphism:\n\n\n**– (Random) encryption with two keys.**\n**– Code integration: it’s the first virus to use this**\nmethod which consists in scattering the decryptor’s\ncode directly among the host’s code, which makes\nthe virus hard to detect and hard to disinfect. The\nMISTFALL engine is used for this technique.\n**– Permutations (it uses ZPERM’s RPME engine).**\n**– Dead code, generated by the EXECUTABLE TRASH**\nGENERATOR (ETG).\n**– Syntaxic modification of instructions.**\nThe virus is analysed, along with other polymorphic and\nmetamorphic viruses, in [Szo05].\nFinally, METAPHOR, by Mental Driller, appears in 2002\nand is certainly the most advanced metamorphic virus until\ntoday. It may infect both Elf (on Linux) and PE (on Windows) files, on the local file system and on mounted partitions\n(in Linux) or shared folders (in Windows).\n\nLet’s also mention the recent development of Java and\nMSIL[3] viruses, which are platform-independent. .NET assemblies infection is simplified by the presence of assembler libraries (System.Reflection.Emit namespace) and both\ntechnologies enclose standard high level cryptography libraries. Only one metamorphic MSIL virus is known as of\ntoday, —Gastropod—, and there still are very few Java and\nMSIL viruses. But given the ubiquity of both technologies,\nthese viruses might well represent a threat in the near future\nfor any platform that supports them.\n\nThe rapid evolution of viral techniques towards first polymorphic and then metamorphic techniques motivated the\nworking out of new detection techniques, based on emulation\nand behaviour analysis allowing to identify suspect behaviours.\nHowever in the same time, they revealed two limitations that\nare inherent to antiviral defence and benefit virus writers.\nFirst, the efficiency of these methods relies on an often\nprohibitive complexity when iterated on a high number of\nfiles: defence cannot monopolize resources of the protected\nsystem whereas attack has a priori no cost nor time limits.\nMoreover a delay of a few hours or of a day is long enough\nfor a well-implemented virus to spread on a very large scale,\nhence the interest for virus writers to complicate as much as\npossible analysis of their viruses. Although these weaknesses,\ncombined with advanced metamorphic techniques, are not\nused yet in a lot of viruses (or these very viruses are often\nbuggy and easily detected and stopped), they define a new\nage of viral detection, in which current protection methods\nwill be thoroughly obsolete.\n\n\nIII. STUDY OF A METAMORPHIC VIRUS: METAPHOR\n\nThe cross-platform metamorphic virus METAPHOR[4] was\nwritten in 2002 by The Mental Driller and was the second\nhighly advanced metamorphic virus (with ZMIST), and the\nfirst ever polymorphic, and metamorphic, Linux virus. It was\npublished in 29A’s magazine [MD02]: its sources can be found\n\n\n3i.e. targetting .NET assemblies.\n4M PHOR i l k S E\n\n\n-----\n\non VX Heavens [MDa]. It uses highly advanced metamorphic\ntechniques which combine the majority of the techniques used\nby its predecessors. They’re used along with anti-heuristic and\nanti-emulation techniques.\n\n_A. Overview of the techniques used by METAPHOR_\n\n\nHere are the main polymorphic techniques used by METAPHOR:\n\n - XOR / SUB / ADD encryption, with random key, or no\nencryption at all;\n\n - Branching technique;\n\n - Pseudo-Random Index Decryption (PRIDE);\n\n - Metamorphic techniques:\n**– Dead code insertion;**\n**– Instruction modification;**\n**– Random modification and permutation of registers;**\n**– Code permutation;**\n**– Mutation of the memory access profile.**\n\n\n_B. Polymorphism in METAPHOR_\n\n_1) Encryption techniques: First let’s describe the miscel-_\nlaneous encryption techniques which are commonly used in\npolymorphic viruses (see [Mid99] for some more details and\nfor examples).\n_a) Basic encryption: The most simple ones, as well_\nas the most common ones, use a mere XOR (as shown in\nthe example), ADD or SUB encryption, with a key which is\nrandomly generated on each replication and which is stored\ninside the virus data or directly inside the decryption method.\nThe following code is a basic example of such an encryption:\n```\n mov esi, offset enc_code_start\n                ; start of encrypted code\n mov edi, esi ; start of decrypted code\n mov ecx, (offset enc_code_end      offset enc_code_start) / 4 ; size in dwords\n mov ebx, 6B3C728Ah ; encryption key\nstart:\n lodsd ; load a dword in eax\n xor eax, ebx ; decrypt it\n stosd ; save it\n loop start\nend:\n jmp enc_code_start\n\n```\n_b) Sliding key encryption: One drawback of the previous_\ntechnique is that, once the key has been chosen, each character\nis encrypted in a unique way. Thus the sliding key encryption\nupdates the key as the decryption progresses, either in a fixed\nway or for instance with the last encrypted character. For\ninstance, the previous code could be modified in the following\nway:\n\n\nas much as needed the input key. The previous code can be\neasily adapted to this technique, in the case of a single register\n(lfsr_init initializes the register, and lfsr_next shifts\nthe 32bits register, thus generating a new key):\n```\n ...\n mov ebx, 6B3C728Ah\n call lfsr_init ; init the register from the key\nstart:\n lodsd\n call lfsr_next ; ebx := 4 new bytes from keystream\n xor eax, ebx\n ...\n\n```\n_d) Encryption with permutation: The input data is simply_\npermutated. Permutation can occur on the scale of the whole\ndata, of chunks of bytes (of fixed or variable length), or even\nof each byte (with the ROR instruction for instance).\n_e) Multiple encryption: Several encryption techniques_\nare sequentially applied.\n_f) Random key encryption: The data is encrypted with a_\nrandom key which is not stored for future decryption. Upon\nexecution, the key (as well as the encryption technique) can\nonly be recovered by brute force attack or cryptanalysis. This\ntechnique disables any code emulation analysis. The size of\nthe key space (and possibly its properties) allows to control\nover the decryption time. This technique was introduced by\nDarkMan in 1999 in his RANDOM DECODING ALGORITHM\nENGINE (RDAE), which implemented several encryption\ntechniques without storing the key: only the code’s CRC32\nchecksum was stored. These techniques are detailed in [BF07],\n\n[Kha07].\n_g) Code-dependent encryption: The binary code itself is_\nused as the encryption key, or a combination of the code and\na random key. This technique was usually used to ensure\nthat the code had not been modified – during an antiviral\nanalysis (where the code could be patched to disable some\nanti-debugging techniques).\n\nUpon decryption, the virus needs access to the decryption\nkey(s). This key is usually directly stored in the program:\ninside the decryption procedure, inside the virus data or simply\nrelated to the host program (for instance the key can be the\nhost’s filename). The case of RDA is different since the key\nis retrieved by brute force. However other scenarios exist\nwhere the key isn’t stored in the code but is inferred from\nthe environment. This technique is called environmental key\ngeneration [RS98]. Here are some examples:\n\n```\n ...\n xor eax, ebx\n add ebx, eax\n ...\n\n```\n_c) Flow encryption: This method uses a key to generate a_\nkeystream of the same size as the data to encrypt. For instance\nthe generation of this pseudo-random keystream might use\none or several linear feedback shift registers (LFSR, see\nsection III D1) Some basic implementations simpl d plicate\n\n\n\n - The key is forged from the local environment. For instance, the key is the hard disk serial number, combined\nwith some random value stored in the code, etc.\n\n - The key depends on activation factors. For instance, it\ndepends on the current date and will only be valid during\nsome predetermined period. In consequence, the virus\nitself will be disabled outside the valid periods.\n\n - The key is stored on a web server, a news server, etc.\nThe most advanced implementation of this technique is\nthe proof of concept BRADLEY virus [Fil04]. It uses several encryption layers, whose keys are retrieved from the\nenvironment. The interest of such viruses from their writer’s\npoint of ie is that the can restrict the acti it of their\n\n\n-----\n\nvirus geographically as well as temporally. Filiol also shows\nin [Fil04] that, if the key is unknown during the analysis,\nthe cryptanalysis’s complexity is exponential (in BRADLEY’s\ncase).\n\nAs for METAPHOR, it encrypts its code with an initial\nprobability of 15/16 and uses an encryption method (with\nrandom key) of type XOR, ADD or SUB.\n\nHowever, METAPHOR’s decryption method is much more\ninteresting. It uses techniques that The Mental Driller had already implemented into the TUAREG engine (TAMELESS UN\nPREDICTABLE ANARCHIC RELENTLESS ENCRYPTION GEN\nERATOR) and that he describes in another issue of 29A’s magazine [MD00], [MDb]. This engine combined most notably\ntwo novel techniques, with an anti-heuristic purpose, which\nalso took part in the mutation of the decryption routine. Both\ntechniques, the branching technique and the PRIDE technique,\nare used in METAPHOR. Finally, an EPO technique is used to\ngive control to the decryption routine: METAPHOR changes\nall calls to the exit function into calls to this routine.\nThus, the virus only gains control after execution of the\nprogram, which contributes to its stealth and protects it from\nthe detection by emulation.\n_2) Branching technique: A basic decryption method has a_\nstructure that often follows a common template which will\ntrigger an alarm in any heuristic engine, as one can see with\nthe examples from last section. Thus the branching technique\nallows to simulate as much as possible the behaviour of an\ninnocuous program. Such programs will usually sequentially\ntest several conditions and, depending on the result, finally\nbranch on distinct paths. This technique therefore creates\nseveral random tests, until a given recursivity level, that will\ndefine an execution tree with leaves representing distinct ways\nto decrypt the code. Figure 4 describes the execution tree for a\nmaximum depth of recursivity equal to 2: each terminal branch\nhas its own decryption code, though the final result is the same,\nwhatever branch is taken. Thus for a depth of recursivity equal\nto n, 2[n] decryption branches are generated.\n\n```\nif (recLevel >= maxLevel) { // maximum depth?\n insert_code (); // decryption code\n build_instr (OP_CMP, REG_ECX, code_len);\n                  // CMP ecx, code_len\n jmp = insert_partial_jump (OP_JNZ); // JNZ <?>\n partial_jumps [cnt_partial_jumps ++] = jmp;\n           // update the target in the end\n ... // call the decrypted code\n return;\n}\nrecLevel ++;\nadd_node (insert_label ()); // save the new branch\nif (random_boolean ()) { // test CMP or TEST?\n int reg, val, op;\n reg = get_random_register ();\n val = 0x80000000 | (random () & 0x3fffffff);\n                 // 0x8XYYYYYY (X < 4)\n build_instr (OP_CMP, reg, val); // CMP reg, val\n op = OP_JB + (random () & 0x5); // JB/JA/JBE/JAE\n jmp = build_partial_jump (op); // partial jump\n} else {\n int reg, val, op;\n reg = get_random_register ();\n val = 0x1 << (random () & 0x1f); // 2ˆX (X < 32)\n build_instr (OP_TEST, reg, val); // TEST reg,val\n op = OP_JZ + (random () & 0x1); // JZ or JNZ\n jmp = build_partial_jump (op); // partial jump\n}\n/* first branch: */\nmake_branch ();\ncomplete_partial_jump (jmp, insert_label ());\n\n```\n\nmakes the same computation and all branches are shared and\nalternatively used to implement the decryption loop. Here is\nthe C algorithm used in METAPHOR (ll. 15750 – 16075):\n```\nvoid do_branching () {\n int i;\n\n```\n```\n make_branch ();\n for (i = 0; i < cnt_partial_jumps; i++)\n  // redirect each jump at a random node\n  complete_partial_jump (partial_jumps[i],\n       get_random_node ());\n}\nvoid make_branch () {\n int jmp;\n\n```\n```\n /* alternative branch: */\n make_branch ();\n recLevel --;\n}\n\n```\n\nFig. 4. Execution tree with and without branching technique.\n\nFurthermore, to reduce the risk of an heuristic alert upon\nexecution of a branch, terminal branches do not contain a\ndecryption loop but only its body: once the body is executed,\na jump is made to any one of the previous nodes in order\nto carr on decr ption Th s pon e ec tion each branch\n\n\nAnd here is an example code it could yield, for a recursivity\ndepth of 2:\n```\nbr0:\n cmp reg1, val1 ; reg1, random register\n              ; val1 = 8XYYYYYYh (X < 4)\n jcc alt0 ; jcc = jb / ja / jbe / jae\nbr1:\n test reg2, val2 ; reg2, random register\n              ; val2 = 2ˆX (X < 32)\n jcc alt1 ; jcc = jz / jnz\n <Decryption code 1>\n cmp ecx, code_len\n jnz br1’\n ...\nalt1:\n <Decryption code 2>\n        d l\n\n```\n\n-----\n\n```\n jnz br1\n ...\nalt0:\nbr1’:\n cmp reg3, val3\n jcc alt1’\n <Decryption code 3>\n cmp ecx, code_len\n jnz br0\n ...\nalt1’:\n <Decryption code 4>\n cmp ecx, code_len\n jnz br0\n ...\n\n```\nAs this will be detailed in section III-C about metamorphic\ntechniques, this code is actually an intermediate representation\nof the final code: once the code has been created, METAPHOR\ngenerates the final x86 code by rewriting each instruction\ninto an equivalent sequence of instructions and by randomly\ninserting dead code.\n_3) PRIDE technique (Pseudo-Random Index DEcryption):_\nThe purpose of this technique is also to protect the virus from\na heuristic detection. Indeed, even with the modification of\nthe execution tree of the decryption procedure, it follows the\nfollowing common mechanism (for a basic encryption):\n1) data := address of a buffer inside the data section of\nthe virus.\n2) Sequentially read data and create a new buffer, which\nwill contain the decrypted data.\n3) Give control to the new decrypted code.\nThe second stage of this procedure, which consists in\nsequentially reading a sequence of 1000 bytes or more in\nmemory, presents a high risk of heuristic alert. Therefore, the\n```\nPRIDE technique consists in decrypting data in a pseudo\n```\nrandom order and not anymore in a sequential order. Byte\n10 will be decrypted, then byte 23, then byte 7, then byte\n48, and so on. This memory access profile is much closer\nto an innocuous application’s memory access profile. In the\nsame time, this technique reinforces the polymorphism of the\ndecryption code.\nHere is the algorithm used for the PRIDE technique (ll.\n15570 – 15652 and 15827 – 15984). size_of_data is the\nsize of the data to be encrypted, rounded up to a power of 2.\nFirst the algorithm initializes its variables:\n```\npride_start = (size_of_data - 4) & random ();\n             // aligned on a dword boundary\npride_step = (size_of_data - 8) & random ();\n             // aligned on a qword boundary\npride_key = get_random_key ();\n\n```\nThen it initializes the registers to be used by the decryption\nroutine: CR, IR and BR. CR is the counter register and contains\nthe sequential decryption index, IR is the index register\nand contains the pseudo-random decryption index (XOR’ed\nactually with CR), BR is the buffer register used as temporary\nstorage for encrypted data. Compared to the decryption routine\nin section III-B1, we have: CR ≡ `ecx, IR ≡` `esi ≡` `edi and`\n```\nBR ≡ eax. The following code is written at the beginning of\n\n```\nthe decryption routine:\n\n```\nMOV BR, val’ ; val’ = random()\n\n```\n\nFinally, when the decryption routine’s body must be generated (call to insert_code inside the make_branch\nmethod), the algorithm writes:\n```\n PUSH IR\n XOR IR, CR\n MOV BR, [IR + source]\n XOR BR, key ; or ADD BR, +/- key\n              ; or nothing (no decryption)\n ADD IR, dest\n MOV [IR], BR ; write the decrypted dword\n POP IR\n ADD CR, val ; CR += [4;7]\n AND CR, val’ ; val’ = ((random() &\n     ; ˜size_of_data) | (size_of_data-4)) & -4\n     ; (-> CR := (CR % size_of_code) & FFFFFFFCh)\n ADD IR, pride_step\n AND IR, val’’ ; val’’ = ((random() &\n     ; ˜size_of_data) | (size_of_data-1)) & -1\n     ; (-> IR := IR % size_of_code)\n CMP CR, pride_start\n JNZ <?> ; jump at a random branch\n\n```\n```\nMOV CR, pride_start\n O l l ( i f d 4) d ()\n\n```\n\nFurthermore, the last instructions which update registers\n```\nCR and IR (ADD CR, val and AND CR, val’ for the\nCR register) are permutated with each other, with the obvi\n```\nous requirement that the AND instruction is executed before\nits ADD counterpart. Also, as we can see, pride_step\ndetermines the “order” of decryption: when equal to 0, it\nsimply corresponds to a sequential decryption (starting at\nindex (IR ˆ pride_start)).\n\nThis ends the study of polymorphic techniques in METAPHOR. Both techniques we described mainly aim to impede\nany detection by emulation: however, in a sense, they also have\na mutation role, not anymore in the form but in the behaviour.\nThis proximity between signatures used for form analysis and\nsignatures used for behaviour analysis is studied into more\ndetails in [Fil07].\n\n_C. Metamorphism in METAPHOR_\nMETAPHOR’s metamorphic engine takes up 70% of the\nsource code (11000 lines in all), the remaining 30% accounting\nfor the infection routines (20%) and the decryptor’s creation\nroutine (10%). This proportion isn’t uncommon: some metamorphic viruses devote up to 90% of their code to their\nmetamorphic engine. The engine is used to mutate the virus\nbody (more precisely the part to be encrypted) as well as the\ndecryptor itself.\nThe engine works according to the following template,\nwhich The Mental Driller calls humorously accordion model:\n1) Disassembly / Depermutation\n2) Compression\n3) Permutation\n4) Expansion\n5) Reassembly\nOne particularity of this engine, which conceptually differentiates it from its predecessors, is the use of an intermediate\nrepresentation which allows to dissociate from the complexity\nof the underlying processor’s instruction set and to simplify the\nmiscellaneous transformations and the code manipulation and\ncreation For instance eq i alences bet een `86 instr ctions`\n\n\n-----\n\nare deferred until the reassembly stage, jumps at other code\ninstructions are translated into a pointer perspective (that are\nmuch easier to manipulate, compared to offsets), etc.\n_1) Description of the pseudo-instruction set: METAPHOR_\nuses a limited instruction set. It only considers instructions\nthat are actually used by the code. Since this intermediate\nrepresentation isn’t used when modifying the host code, this\nrestriction is natural. This instruction set is organized as\nfollows:\n\n - Base instructions with 2 operands: ADD, OR, AND, SUB,\n```\n  XOR, CMP, MOV and TEST.\n\n```\n - Base instructions with 1 operand: PUSH, POP, Jcc, NOT,\n```\n  NEG, CALL and JMP.\n\n```\n - Other instructions: SHIFT, MOVZX, LEA, RET and NOT.\n\n - Macro-instructions:\n**– APICALL_BEGIN, APICALL_END, APICALL_STORE,**\nwhich represent the instruction sequences which are\nused when calling a Windows API (in the case of a\n```\n    PE infection): since the registers to be used by these\n\n```\ncalls are predefined, these macro-instructions ensure\ntheir protection from register swapping transformations.\n**– SET_WEIGHT which is used for “genetic” evolution**\n(see section III-D2).\n**– LINUX_GETPARAMS, which is similar to APICALL_**\n```\n    BEGIN, and represents the loading of parameters into\n\n```\ngeneral purpose registers.\n**– LINUX_SYSCALL which represents a syscall (int**\n```\n    80h – used to call a system function); and LINUX_\n    SYSCALL_STORE which represents a syscall fol\n```\nlowed by the result’s saving.\n\n - Instructions used only by internal operations: Mov Mem,\n```\n  Mem, used during the compression stage, and INC and\n  LITERAL_BYTE (unencoded byte to be inserted as it is)\n\n```\nwhich are used during the reassembly stage.\n\n```\nx86 instruction, during the permutation, it contains the in\n```\nstruction’s address inside the non-permutated code, etc.\nOnce the virus decrypted its code, it gives control to it. After\ninitialization of the variables and possible payload activation,\nit defines the form of next generation (internal organization of\nthe code – where to put code, where to put data, etc.). Then\nit starts the code transformation process.\n_2) Disassembly: The x86 code is first disassembled into an_\nintermediate representation which uses the previous instruction\nset. This procedure loads the intermediate code into the buffer\npointed by variable InstructionTable. It also creates an\narray of labels which contains all instructions which are the\ntarget of a branching instruction. In the end, the computed\nintermediate code has been depermutated and the inaccessible\ncode (dead code) removed: this is actually a direct consequence from the routine’s algorithm.\nThe x86 code is disassembled by following the execution\n_flow. The algorithm uses an array, FutureLabelTable,_\nwhich contains instructions which are waiting for their disassembly (namely these are the targets of conditional jumps\nand direct calls). Here is the algorithm:\n\n - If the current instruction was already disassembled, simply add a JMP instruction which points at the disassembled instruction. Then carry on disassembly with\nan instruction from FutureLabelTable (if any) or\nterminate.\n\n\nThe opcode choices are motivated by the equivalent x86\nopcode organization and by the sake of simplifying the manipulation of instructions and the coding of transformations. In\nparticular, for the first type of opcodes, the opcode itself (for\ninstance ADD) is encoded into bits 6..3, and the operand\ntypes into bits 2..0 and 7: bit 7 specifies whether the\noperands are 8 bits (for instance mov al, 12h) or 32 bits\n(for instance mov eax, 12h) whereas bits 2..0 specify\nthe type of operands (Reg, Imm, etc.).\nFinally, a pseudo-instruction is encoded in 16 bytes:\n```\nXX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX\nOP *--------- operands --------* LM *- instr -*\n\n```\n```\n OP contains the instruction opcode, on one byte. Then\n\n```\nthe operands are encoded (register index, memory address or\nimmediate value) on the following 10 bytes. Then LM (“Label\nMark”) is a flag on 1 byte telling whether this instruction is\nthe target of a branching instruction: when this is the case,\nthe instruction can neither be deleted nor compressed with\ninstructions preceding it. The last 4 bytes contain a pointer\nwhich has miscellaneous significations along the execution:\nd ring the disassembl it contains the address of the initial\n\n\n\n - Otherwise:\n1) If previous instructions did point at the current\ninstruction, update them in order to point at the new\ndisassembled instruction.\n2) Create the new pseudo-instruction. The following\ncases are more specifically distinguished:\n**– INC and DEC instructions are replaced by their**\n```\n     ADD and SUB counterparts: during the reassem\n```\nbly stage, the opposite transformation will be\napplied (or not).\n**– If this is a JMP instruction: either its target**\nwas already disassembled and we simply insert\na JMP instruction pointing at that instruction\n(by creating a label), or the target has not been\ndisassembled yet and we insert a mere NOP.\n**– If the instruction is a conditional jump or a direct**\ncall: if the target has been disassembled yet, add\nit to the wait array FutureLabelTable. Then\ninsert the corresponding branching instruction\n(pointing at the disassembled target, if it exists,\nor at the x86 target instruction).\n3) Finally, if this was a JMP instruction whose target\nhad not been disassembled yet, continue with this\ntarget. If the target was already disassembled, or the\ninstruction is a RET, continue with an instruction\nfrom FutureLabelTable (if any). Otherwise\ncontinue with the next instruction.\nCode permutation is carried out, as we will see, using\nunconditional jumps (no “opaque predicates” or similar tricks):\nduring the disassembly, the JMP instruction used to join two\nperm tated blocks is replaced b a NOP instr ction and the\n\n\n-----\n\ndisassembly continues with the new block. Given that the\npseudo-code is built in a linear way, its final shape will be\nthat of the depermutated code. Similarly, inaccessible code\nthat was inserted will never be disassembled.\n_3) Compression: After disassembly and depermutation, the_\ngenerated pseudocode is compressed. This cancels the expansion effects of the previous generations, since the compression\nrules are exactly the inverse of the expansion rules. There are\nfive kinds of rules:\n1) Instr -> Instr rules:\n\n   - XOR Reg, -1 `->` `NOT Reg`\n\n   - SUB Reg, Imm `->` `ADD Reg, -Imm`\n\n   - OR `Reg, 0` `->` `NOP`\n\n   - AND Reg, Reg `->` `CMP Reg, 0`\n\n   - ...\n2) Instr / Instr -> Instr rules:\n\n\n\n  - PUSH Imm / POP Reg\n```\n    -> MOV Reg, Imm\n\n```\n  - MOV Mem, Imm / PUSH Mem\n```\n    -> PUSH Imm\n\n```\n  - OP Mem, Imm / OP Mem, Imm2\n```\n    -> OP Mem, (Imm OP Imm2)\n\n```\n  - NOT Reg / NEG Reg\n```\n    -> ADD Reg, 1\n\n```\n  - TEST X, Y / !=Jcc\n```\n    -> NOP\n\n```\n  - Jcc @xxx / !Jcc @xxx\n```\n    -> JMP @xxx\n\n```\n  - ...\n3) Instr / Instr / Instr -> Instr rules:\n\n  - MOV Mem, Reg / OP Mem, Reg2 /\n```\n    Mov Reg, Mem -> OP Reg, Reg2\n\n```\n  - ...\n4) Instr / Instr / Instr -> Instr / Instr rules:\n\n\nstarting from the current instruction: if a compression occurs,\nit makes a three instructions step-back and continues. This\nallows to take into account any new reduction opportunity\nthat might have appeared with an instruction created by\nthe last reduction. For the sake of simplicity, instructions\nthat are deleted are simply replaced by NOP instructions.\nIn the end, the algorithm identifies all sequences of instructions that correspond to macro-instructions (APICALL_*,\n```\nLINUX_SYSCALL*, LINUX_GETPARAMS, SET_WEIGHT)\n\n```\nand replaces them accordingly. Also note that, for a reduction\n– of any type – to occur, no instruction, except the first one,\nshall be the target of a jump (flag LM).\nThe algorithm also allows to reduce sequences of operations\ninto a unique operation. For instance, ADD Reg, X / SUB\n```\nReg, Y will be reduced into ADD Reg, (X - Y): these\n\n```\ndecompositions are created during the expansion. Finally,\nwhen a Jcc instruction is replaced by a JMP instruction,\nthe following code is deleted (NOPed) until reaching a label\n(instruction with LM = 1).\nHere is an example of compression (this code represents a\nbasic decryption routine):\n```\n test esi, val1 | nop\n mov [Mem], val2 | mov esi, (val2 + val3)\n add [Mem], val3 | nop\n push [Mem] | nop\n pop esi | nop\n mov [Mem2], esi | mov edi, esi\n and esi, -1 | nop\n push [Mem2] | nop\n pop edi | nop\n push val4 | mov ecx, val4\n pop [Mem3] | nop\n or [Mem3], 0 | nop\n mov ecx, [Mem3] | nop\n mov ebx, val5 | mov ebx, val5 XOR val6\n xor ebx, val6 | nop\nlabel: |\n push [esi] | mov eax, [esi]\n or esi, 0 | nop\n pop eax | nop\n mov [Mem4], eax |==> xor eax, ebx\n push [Mem4] | nop\n pop [Mem5] | nop\n xor [Mem5], ebx | nop\n mov eax, [Mem5] | nop\n mov [Mem6], eax | mov [edi], eax\n push [Mem6] | nop\n pop [edi] | nop\n not esi | add esi, 4\n neg esi | nop\n add esi, 3 | nop\n sub edi, 0 | nop\n add edi, 4 | add edi, 4\n mov [Mem10], 4 | sub ecx, 4\n and [Mem10], -1 | nop\n add ecx, [Mem10] | nop\n mov [Mem11], ecx | cmp ecx, 0\n sub [Mem11], 5 | jnz label\n add [Mem11], 5 | nop\n jnz label | nop\n\n```\n\n\n   - MOV Mem, Reg / TEST Mem, Reg2 /\n```\n     Jcc @xxx -> TEST Reg, Reg2 / Jcc @xxx\n\n```\n   - ...\n5) Macro-operations identification rules:\n\n   - PUSH eax / PUSH ecx / PUSH edx\n```\n     -> APICALL_BEGIN\n\n```\n   - POP edx / POP ecx / POP eax\n```\n     -> APICALL_END\n\n```\n   - POP edx / POP ecx / POP ebx / POP eax\n```\n     -> LINUX_GETPARAMS\n\n```\n   - CALL Mem / MOV Mem2, eax\n```\n     -> CALL Mem / APICALL_STORE Mem2\n\n```\n   - INT 80h\n```\n     -> LINUX_SYSCALL\n\n```\n   - INT 80h / MOV Mem, eax\n```\n     -> LINUX_SYSCALL_STORE\n\n```\n   - PUSH Reg1 / MOV Reg1, Imm1 / MOV Reg2,\n```\n     Imm2 / MOV Mem, Reg2 / POP Reg1\n     -> SET_WEIGHT Mem, Imm1, Reg1, Reg2\n\n```\nNotation !=Jcc denotes “any opcode that is not a conditional jump” and the notation !Jcc denotes the inverse of the\nlast Jcc (for instance, JA and JBE). Furthermore, some of\nthese rules might not be verified in the general case, but they\nare in the case of METAPHOR’s code.\nThe algorithm is simple. It compresses the code as much as\npossible. When it looks up the next instruction, it skips any\n```\nNOP instruction that is not the target of jump or a call (flag\nLM is set). As long as it did not reach the end of the code,\n\n```\nit tries to compress ch nks of one t o or three instr ctions\n\n\n_4) Variable reorganization: METAPHOR aims to mutate_\nat the semantic level (instructions expansion / compression)\nand at the code level (permutation) as well as at the code\nbehaviour level. We already mentionned previously that it was\nmutating the internal organization of the viral code. When\nthe ir s gains control it allocates into memor a space of\n\n\n-----\n\n```\n(340000h + X) bytes, where X is a random value between\n0h and 01F000h. This space is then organized into 5 sections\n\n```\n(see figure 5):\n\n - Section Code contains the decrypted x86 code.\n\n - Section Buffers contains the miscellaneous arrays and\nbuffers used by the virus.\n\n - Section Data contains the virus global variables.\n\n - Section Disasm contains the disassembled code and\nthen the result of the expansion of the permutated code.\nWhen creating the decryption routine, it will contain its\npseudocode as well as the reassembled code.\n\n - La section Disasm2 is first used as a buffer, then it\ncontains the result of the permutation of the compressed\npseudocode, and finally it contains the reassembled code.\n\n\nThus the memory access profile is modified. This kind of\ntransformation isn’t however taken to extremes. For instance,\nthe code often reads the contents of pseudo-instructions, as\nin the following code excerpt (where esi and edi contain\npseudo-instructions addresses):\n```\n mov ecx, [esi+1] ; Get the value in ECX\n mov eax, [esi]\n add esi, 5\n and eax, 7 ; Get the register in EAX\n mov [edi+1], eax ; Set the register\n mov [edi+7], ecx ; Set the value\n\n```\n\nBefore starting the mutation and replication process, sections are randomly permutated and each section is shifted\nby a random value between 0h and 7FFFh. In the end, the\nmaximum required size (into memory) is: 300000h + 5\n```\n* [7FFFh = 340000h][. Thus, upon execution, M][ETA][PHOR]\n\n```\nnever has a unique memory access profile.\nThe virus contains about 200 global variables, each of these\nvariables being allocated 8 bytes inside the Data section.\nThese variables are accessed by their offset in that section. A\nregister is specifically assigned, which isn’t modified during\nthe virus execution, and which contains that section’s address.\nDuring generation 0, this base register is ebp. Thus, to access\nto the contents of variable InstructionTable, which is\nat offset 10h of the Data section, one uses:\n```\n mov eax, [ebp + 10h]\n\n```\n\nThis kind of access can be profiled, since the internal\norganization of an instruction does not mutate. However The\nMental Driller could have taken memory access profile mutation to extremes by modifying this very internal organization\nof pseudo-instructions. Given the massive use of instructions\naccessing the contents of these pseudo-instructions, impact\nwould have been even stronger, even though the mutation of\nthe organization of pseudo-instructions is quite limited (might\nwe add a few padding bytes to increase mutation possibilities).\nLet’s note that, in this transformation’s implementation,\nvariables are aligned on 8 bytes boundaries so that they can be\nrandomly positionned on any one of the first 4 bytes: finally,\nonly 4 bytes are used by a variable.\n_5) Permutation: Once the compression is over, the engine_\npermutates the code by splitting it into blocks of random\nsizes, between F0h and 1E0h. When doing the splitting, the\nfollowing breaks are avoided:\n\n - between a CALL instruction and the associated APICALL_\n```\n  STORE instruction;\n\n```\n - before a JMP or a RET instruction, to avoid two consecutive jumps;\n\n - before a JMP or a Jcc instruction, in order for the compression process to correctly compress any Jcc + JMP\nor CMP/TEST + Jcc instructions.\nOnce the code blocks have been computed and shuffled,\nthe new code is built (and its address saved into variable\n```\nPermutationResult). A jump at the first code block is\n\n```\ninserted at the very beginning of the code and the code blocks\nare linked with each other using JMP instructions, except in\nthe following cases:\n\n - The target block directly follows the current block.\n\n - The block’s last instruction is an unconditional jump or\na return instruction.\nThe final result shall look like:\n\n\nGiven that this register (ebp) is strictly reserved to data\naccess, it is sufficient to spot all instructions that use it to\nidentify read and write accesses to a variable and to list\nthese very variables. Method IdentifyVariables does\nthis job and replaces in each one of those instructions the offset\nby the index of the associated variable. Then the variables\nare shuffled: their organization inside the Data section is\nthus completely modified. Then, during reassembly, when\nan instruction uses one of these variables, the instruction is\nupdated to contain the new base register (initially ebp) and\nthe ne offset of the referenced ariable\n\n```\n jmp @block1\n@block4:\n ;-------------;\n ; block 4 ;\n ;-------------; (ends with a ret)\n@block2:\n ;-------------;\n ; block 2 ;\n ;-------------;\n@block3:\n ;-------------;\n ; block 3 ;\n ;-------------;\n jmp @block4\n@block1:\n\n```\n\n-----\n\n```\n ; block 1 ;\n ;-------------;\n jmp @block2\n\n```\n_6) Expansion: The expansion stage consists in applying_\nthe inverse rules from the compression stage. This method\nis called on the virus compressed pseudocode and, later, on\nthe decryption routine’s code.\nThe first step consists in randomly modifying the used\nregisters. A bijective transformation is applied, which takes\ninto account the following requirements:\n\n - No register should of course be transformed in ESP.\n\n - The base register (initially EBP) used to store the Data\nsection’s address (see section III-C4) should not be any\nof EAX, ECX or EDX (which are used by system calls).\n\n - The 8 bits register used by 8 bits operations in the code\nmust be related to a general purpose register (EAX, EBX,\n```\n  ECX or EDX).\n\n```\nThen, the expansion can start: it will update registers as\nwell as accesses to the virus’ global variables. The expansion’s\nresult is stored in variable ExpansionResult. To control\nthe size of expansion, a maximum level of recursivity is first\nchosen: it cannot be larger than 3. Then, for each instruction,\nwe increment the recursivity level and we randomly transform it, by using the inverse compression rules. Intermediate\ninstructions which are generated are also transformed. NOP\ninstructions are ignored in the compressed code (to avoid an\nuncontrolled increase of size, after several generations).\n\nWhen an instruction is generated, which uses a temporary\n_memory address, this memory address points at the Data_\nsection and should not have been allocated for the virus\nglobal variables nor by any previous instruction in the current\nexpansion chain. The VarMarksTable array is used to mark\nwhich addresses have been allocated. As for global variables,\nthe allocated address is randomly aligned on one of the first 4\nbytes. However, this is different in the case of the decryption\nroutine since the memory has not been allocated yet (with\na call to malloc): the space to be used by intermediate\noperations is then the data section that was allocated inside\nthe host file for the decryption operations.\n\nWhen an instruction uses an immediate value, this value\nis computationally decomposed into a sequence of operations\nthat finally yield the expected immediate value. This expansion is managed by method Xp_MakeComposedOPImm. It\nuses operators ADD, AND, OR and XOR (the SUB operator is randomly generated when transforming ADD instructions). Here is for instance the algorithm used to generate a\n```\nMOV Dest, Imm instruction:\n\n```\n\n_D. Randomness techniques_\n\n_1) Pseudo-Random Numbers Generator (PRNG): META-_\nPHOR makes a heavy use of random numbers. It uses its own\npseudo-random numbers generator, with two seeds, seed1\nand seed2, which are initialized depending on the UNIX date\nfor seed1 and on the code’s first bytes for seed2. Then\na random value is generated using the following algorithm\n(ror_X denotes right rotation by X bits):\n```\nint random () {\n seed1 ˆ= (seed2 + ror_13 (seed1 + seed2));\n seed2 = (seed1 + ror_17(seed2)) ˆ (seed1 + seed2);\n return seed1 + ror_17 (seed1 ˆ seed2);\n}\n\n```\nThough this may not be obvious at first sight, the second\nseed is very weak, given furthermore that it is initialized\ndepending on the code’s first bytes which have a low randomness: thus we get, in the worst case, a cyclic generator\nof 32 pseudo-random numbers (as soon as seed2 reaches\nvalue 0x00000000 or value 0xFFFFFFFF). For a random\n```\nseed2, a few tests allow to compute the PRNG’s period\n\n```\nabout 40000, which is barely better that the glibc’s generator (random () function), whose statistical properties are\nparticularly weak and whose period is in the order of 30000.\nPolymorphic viruses usually have their own pseudo-random\ngenerator, often of poor quality, which protects them at least\nfrom a heuristic alert due to a strong utilization of a system’s\nPRNG. Yet, some generators exist that are quite powerful and\nhave a small cost, but their use in polymorphic viruses is\nscarce Here are some of them:\n\n```\n* [MOV Dest, ˜v1 | Imm]\n AND Dest, v1 | Imm\n* [MOV Dest, v1]\n XOR Dest, v1 ˆ Imm\n\n```\n```\n* [MOV Dest, Imm]\n\n```\nIn addition, dead code is inserted, with probability 1/16,\nafter each expansion of an instruction of the compressed code\n(if this instruction’s opcode was a CMP, TEST, CALL or\n```\nAPICALL_STORE, a mere NOP is inserted):\n\n```\n  - Instructions that do nothing, like:\n```\n    MOV Reg, Reg\n    ADD Reg, 0\n    AND Reg, -1\n    ...\n    NOP\n\n```\n  - Tests that always fail, like:\n```\n   CMP Reg, Reg / JNZ [RandomLabel]\n\n```\n\n\n - Useless x86 instructions: STC, CLC.\n\n_7) Reassembly: The last stage consists in assembling the_\npseudo-code into valid x86 code. When several translations\nare possible, the algorithm chooses one at random. Also, short\njumps and long jumps are randomly used (when a short jump\nis possible), and jumps at subsequent addresses are stored in\narray JmpRelocationTable, in order to be updated in\nthe end. After completion of this stage, the code is ready for\nencryption and copy out in the host.\n\n```\nint v1 = random (), v2 = random ();\nchoose randomly among:\n* [MOV Dest, v1]\n ADD Dest, Imm - v1\n\n```\n```\n* [MOV Dest, v1 & Imm]\n OR Dest, ((v2 & Imm) ˆ (v1 & Imm)) | (v2 & Imm)\n* [MOV Dest, (v2 & ˜v1) | Imm]\n AND Dest, v1 | Imm\n\n```\n\n-----\n\n- Linear Congruential Generator (LCG), of which the\nfollowing code is an implementation:\n```\n unsigned int lcg_next (void) {\n  seed *= 1664525u;\n  seed += 1013904223u;\n  return seed;\n }\n\n```\n\n\n - Encryption of the viral code, or no encryption: initially,\nthe code is encrypted with probability 1/16.\n\n - Encryption method (ADD, XOR, SUB): initially, all methods have the same probability of being chosen.\n\n - Decryption routine’s code: form of the instructions, obfuscation type, use of anti-heuristic methods, etc.\nGiven that the virus does not store any information in its\nhost other than its code, it must still be able to update its\ngenetic material, from one generation to another. This is where\n```\nSET_WEIGHT macro-instructions come into play: they’re lo\n```\ncated on disassembly and, on reassembly, the “evolved” gene\nis used.\nHere is the algorithm used to update the genes (function\n```\nCheckForBooleanWeight). We notice that the genes val\n```\nues cannot exceed a minimal and a maximal threshold (thus\nthe associated probability never reaches 1 or 0).\n\n\n\n - Registers generaztors, like Xorshift generators (the following example code comes from [Mar03]) and generators with linear feedback shift registers (LFSR):\n```\n   /* Galois’ LFSR, with taps 32 31 29 1 */\n   unsigned int lfsrg_next (void) {\n    static unsigned int seed = time (NULL);\n    int i;\n    for (i = 0; i < 32; i++) // shift 32 times\n     seed = (seed >> 1) ˆ\n       (-(signed int)(seed & 1) & 0xd0000001u);\n    return seed;\n   }\n   unsigned int xorshift128_next (void) {\n    /* initialization with random values */\n    static unsigned int\n      x = 123456789, y = 362436069,\n      z = 521288629, w = 88675123;\n    unsigned int t;\n    t = x ˆ (x << 11);\n    x = y; y = z; z = w;\n    return w = (w ˆ (w >> 19)) ˆ (t ˆ (t >> 8));\n   }\n\n```\n_2) “Genetic” techniques: METAPHOR combines genetic_\ncharacteristics to its generator. Here is the principle. The virus\ncontains some sort of genetic material which will have a\ntendency to favour some behaviours rather than others. On\neach replication, this genetic material is updated with a small\nrandom variation from the preceding material.\nFor instance, a gene contains the current propension of the\nvirus to encrypt its code or not: the virus initially encrypts\nits code with probability 1/16. Depending on its decision, the\ngene will be altered in favour or in disfavour of encryption: if\nthe virus encrypts its body, it will have next time a higher probability to encrypt again its body, and conversely. Thus after a\nfew generations, either the code will have a strong propension\nto encryption, or a strong propension to absence of encryption.\nThe propension strengh is related to the survival time (and to\nthe number of replications) of the virus. Thus, if the virus has\na strong propension to encryption, this means that most of the\nprevious generations chose encryption and survived: this is\nkind of an implementation of natural selection, where viruses\nare preys and antiviruses are predators. Thus, let’s imagine\nthat the antivirus easily detects encrypted replications of the\nvirus (using statistical entropy analysis for instance) but not\nunencrypted replications. In this case, encrypted replications\nwill be detected before being able to replicate and increase\ntheir propension to encryption, and in the end, most of the\nsurvivors will come from unencrypted ancestors, with a high\npropension to no encryption.\nMETAPHOR contains a genetic material of 24 genes. In\nother words, 24 of its choices depend on its genetic history\nand its survival abilities. These genes are used for instance\nfor:\n\n  - Number of files to infect: initially, only 50% are infected.\n\n - Choice of the method of infection: position of the viral\ncode EPO t pe t pe of the s stem calls etc\n\n```\n/*\n Returns 1 or 0, depending on the gene’s contents.\n*[/]\nint query_gene (int gene) {\n int val = get_gene (gene);\n if ((random () & 0xFF) >= val) {\n  // return 1 and increase propension to 1\n  do {\n    // minimal threshold reached?\n    if (val < 0x08) return 1;\n    if ((random () & 0x0F) > 0)\n     // increase propension to 1:\n     set_gene (gene, -- val);\n  } while ((random () & 0x0F) == 0);\n  // repeat with probability 1/16\n  return 1;\n } else {\n  do {\n    // maximal threshold reached?\n    if (val >= 0xF8) return 0;\n    if ((random () & 0x0F) > 0)\n     // increase propension to 0\n     set_gene (gene, ++ val);\n  } while ((random () & 0x0F) == 0);\n  // repeat with probability 1/16\n  return 0;\n }\n}\n\n```\n\nFor a more detailled analysis of genetic viruses, one may\nrefer to M. Ludwig’s books [Lud95], [Lud93].\n\n_E. Detection of METAPHOR_\n\n\nAnalysis of METAPHOR comes to an end. As we saw,\nseveral advanced techniques of polymorphism and of antiemulation / anti-heuristic protection are implemented in this\nvirus. Nevertheless they’re not taken to their extremes and thus\nthis mutation model is still detectable, mainly because of the\nfollowing “weaknesses”:\n\n - The viral code’s encryption can always be identified by a\nstatistical analysis of the code [Fil07]. Indeed, a program\nusually has a predefined entropy profile, which shows\nfew variations when comparing miscellaneous executable\nfiles. Encrypted data, however, have a specific entropy\nprofile which is much more uniform, depending on the\nunderlying encryption system, and thus is characteristic\nof an encr pted content Same goes for compressed data\n\n\n-----\n\nAny antivirus using this kind of analysis will most likely\nconsider as suspect a program that contains a lot of encrypted content. However, several legitimate applications\nuse encrypted data, for the purpose of intellectual property protection. This is the case of “packed” applications\n(even though malware also uses packers on a regular\nbasis), and this is also the case of Skype for instance.\n\n- When the virus is executed, it compresses its code into\na form that is roughly the same from one generation\nto another, by conception: METAPHOR is therefore\nvulnerable to any form analysis that monitors memory. As\nwe might have expected, this weakness can be corrected\nto some extent, using miscellaneous techniques that are\npreferably not described here but easy to find out. Another\nweakness is also the immutability of METAPHOR’s\nmutation grammar.\n\n- METAPHOR’s mutation grammar is globally simple and\ndoes not use any sophisticated obfuscation tricks – this\nis by conception given that the virus wants to be able\nto revert effects of mutation. In other words, using more\nadvanced obfuscation techniques, possibly along with the\naddition of metadata into the code (as is the case with\nMISS LEXOTAN – see section II-C), would lead to a virus,\nwhich would be much harder to detect (speaking of its\nmere detectability as well as of the complexity of its\ndetectability).\n\n\nit also enables malwares to use more and more complex\ntechniques, without having to worry about their cost.\nAnd this is all the more true as, as we told previously,\nantiviruses will always be limited in time and CPU cost,\nunlike malwares.\nAlso, it should be noted that the state of the art of current\nmetamorphic techniques (with viral protection purpose) is\nnot representative of the threat they represent. Some antiviral\nexperts sweep blatantly away – recently again [She07] – this\nthreat on the pretext that it never actually proved itself except\nfor proving its own uselessness. And as a matter of fact, the\nhistory of metamorphic viruses tends to corroborate this: there\nare few of them, most of which are poorly accomplished and\ncontain critical flaws (bugs or conception flaws which make\ndetection easy). In the same time, development of rootkit techniques draws away attention. Yet, both threats are real, with\ndifferent maturities, but none of them should be overlooked.\nEven though the second one is mostly implemented in worms,\nwhich currently represent the most important infectious threat,\nand even though it is more technical than the first one, and\nthus within the means of more hackers.\nAll in all, if virus writers were a bit less “in a hurry”\nand refined their techniques, the antiviral community could be\nquickly overtaken. An advanced use of syntactic and functional\npolymorphism techniques, combined with advanced stealth\ntechniques, would theoretically make the complexity of the\ndetection problem prohibitive or even undecidable [Fil07]\n(POC virus PBMOT).\n\nREFERENCES\n\n\n\n - Except during decryption, METAPHOR does not protect\nitself from behaviour analysis.\n´E. Filiol studies into more details some aspects of METAPHOR in [Fil07], from a theoretical point of view, and most\nnotably regarding the detection barrier on which METAPHOR\nsits astride: if it mostly inclines towards detectability, some\nmodifications would be sufficient to have it incline towards\nthe other side (see the POC virus PBMOT). To sum up,\nMETAPHOR is a highly advanced virus, which could be really\ndangerous with a few improvements (PBMOT certainly is\nthe most appropriate proof). Other advances, as on the field\nof functional polymorphism, would also give metamorphic\nviruses more sophisticated means of defence against detection.\n\nIV. CONCLUSION\n\n\nIf polymorphic and above all metamorphic techniques described in this document enable viruses to protect themselves\nin a more efficient way against detection, their sophistication\nmostly stems from antiviral protection. For antiviral protection\nis in fact eternally submitted to two paradoxes:\n\n - The more it develops, the more viruses, worms and other\nmalwares use advanced protection techniques which get\nharder and harder to bypass. In a sense, it sentences\nitself indirectly to its own impotence (wrt these advanced\ntechniques). Yet currently it still remains efficient, thanks\nto the mediocre quality of most malwares or to the complexity of the mentionned protection techniques, which\ndiscourages most malware writers.\n\n - And secondly, if on one side the increase of RAM size\nand CPU speed, as well as the upcoming of multi-core\nprocessors seem to be in fa o r of anti iral protection\n\n\n\n[Ayc06] John Aycock. Computer Viruses and Malware. Springer, 2006.\n\n[BF07] Philippe Beaucamps and Eric Filiol. On the possibility of practically[´]\nobfuscating programs – towards a unified perspective of code protection.\n_Journal in Computer Virology, 3(1), April 2007._\n\n[Coh84] Fred Cohen. Computer viruses - theory and experiments, 1984.\n\n[Fil04] Eric Filiol. Strong cryptography armoured computer viruses forbid-[´]\nding code analysis: the BRADLEY virus. In Proceedings of the 14th\n_EICAR conference, May 2004._\n\n[Fil05] Eric Filiol.[´] _Computer viruses: from theory to applications. Springer_\nVerlag, 2005.\n\n[Fil07] Eric Filiol.[´] _Advanced viral techniques. Springer Verlag France, 2007._\nAn english translation is pending, due mid 2007.\n\n[Kha07] Kharn. Exploring RDA. .aware eZine, 1, January 2007.\n\n[Lud93] Mark Ludwig. _Computer Viruses, Artificial Life and Evolution._\nAmerican Eagle Publications, Inc., 1993.\n\n[Lud95] Mark Ludwig. The Giant Black Book of Computer Viruses. American Eagle Publications, Inc., 1995.\n\n[Mar03] George Marsaglia. Xorshift RNGs. Journal of Statistical Software,\n8(14), 2003.\n\n[MDa] The Mental Driller. METAPHOR source code. Version 1D available\nat: http://vx.netlux.org/src view.php?file=metaphor1d.zip.\n\n[MDb] The Mental Driller. TUAREG details and source code. Available in\n29A#5: http://vx.org.ua/29a/29A-5.html.\n\n[MD00] The Mental Driller. Advanced polymorphic engine construction.\n_29A, 5, December 2000._ Available at: http://vx.netlux.org/lib/vmd03.\nhtml.\n\n[MD02] The Mental Driller. Metamorphism in practice or ”how i made\nMETAPHOR and what i’ve learnt”. 29A, 6, February 2002. Available\nat: http://vx.netlux.org/lib/vmd01.html.\n\n[Mid99] MidNyte. An introduction to encryption, April 1999. Available at:\nhttp://vx.netlux.org/lib/vmn{04,05,06}.html.\n\n[RS98] James Riordan and Bruce Schneier. Environmental key generation\ntowards clueless agents. In Lecture Notes In Computer Science, volume\n1419, pages 15 – 24, 1998.\n\n[She07] Alisa Shevchenko. The evolution of self-defense technologies in\nmalware. Available at: http://www.net-security.org/article.php?id=1028,\nJ l 2007\n\n\n-----\n\n[Spi03] Diomidis Spinellis. Reliable identification of bounded-length viruses\nis NP-complete. IEEE Transactions on Information Theory, 49(1):280\n– 284, January 2003.\n\n[Szo05] Peter Szor. _The Art of Computer Virus Research and Defense._\nAddison Wesley Professional, 2005.\n\n**Philippe Beaucamps is a PhD student at the CNRS / LORIA in Nancy,**\nFrance. He works on the modelization of viral infections, and on formal and\npractical malware detection and protection.\nContact address: Loria, Equipe Carte, 615 rue du Jardin botanique, CS[´]\n20101, 54603 Villers-ls-Nancy Cedex France\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Advanced Metamorphic Techniques in Computer Viruses.pdf"
    ],
    "report_names": [
        "Advanced Metamorphic Techniques in Computer Viruses.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535980,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1226662054,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/3ac814bf416d7769ea515b2f7324a0d3b5cba3b4.pdf",
        "text": "https://archive.orkl.eu/3ac814bf416d7769ea515b2f7324a0d3b5cba3b4.txt",
        "img": "https://archive.orkl.eu/3ac814bf416d7769ea515b2f7324a0d3b5cba3b4.jpg"
    }
}