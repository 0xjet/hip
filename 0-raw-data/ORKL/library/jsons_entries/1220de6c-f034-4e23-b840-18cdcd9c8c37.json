{
    "id": "1220de6c-f034-4e23-b840-18cdcd9c8c37",
    "created_at": "2022-10-25T16:48:21.616836Z",
    "updated_at": "2025-03-27T02:17:23.52781Z",
    "deleted_at": null,
    "sha1_hash": "058540094f2591abb7de917954dcb886cc1697ce",
    "title": "",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 2586124,
    "plain_text": "-----\n\nNovetta is an advanced analytics company that extracts value from the increasing volume,\nvariety and velocity of data. By mastering scale and speed, our advanced analytics software and\n\nsolutions deliver the actionable insights needed to help our customers detect threat and fraud,\n\nprotect high value networks, and improve the bottom line.\n\nFor innovative solutions for today’s most mission-critical, advanced analytics\n\nchallenges, contact Novetta:\n\nPhone: (571) 282-3000 | www.novetta.com\n\n**www.OperationBlockbuster.com**\n\n\n-----\n\n# Table of Contents\n\n###### 1. Introduction............................................................... 4\n\n 2. [Installer] IndiaAlfa................................................. 7\n\n 3. [Installer] IndiaBravo............................................. 11\n\n 4. [Installer] IndiaCharlie......................................... 18\n\n 5. [Installer] IndiaDelta............................................  24\n\n 6. [Installer] IndiaEcho............................................. 27\n\n 7. [Installer] IndiaFoxtrot.........................................  32\n\n 8. [Installer] IndiaGolf..............................................  34\n\n 9. [Installer] IndiaHotel............................................  39\n\n 10. [Installer] IndiaIndia...........................................  40\n\n 11. [Installer] IndiaJuliett.........................................  42\n\n 12. [Installer] IndiaKilo.............................................  43\n\n 13. [Installer] IndiaWhiskey....................................  45\n\n 14. [Loader] LimaAlfa................................................ 51\n\n 15. [Loader] LimaBravo............................................  53\n\n 16. [Loader] LimaCharlie.........................................  54\n\n 17. [Loader] LimaDelta.............................................  56\n\n 18. [Uninstaller] UniformAlfa..................................  65\n\n 19. [Uninstaller] UniformJuliett..............................  66\n\n 20. Conclusion............................................................ 67\n\n\n-----\n\n### 1. Introduction\n\nThis report details some of the technical findings of the Lazarus Group’s malware, observed\nby Novetta during Operation Blockbuster. We recommend reading the initial report prior to\nthe reverse engineering reports for more details on the Operation and the Lazarus Group.\nThis reverse engineering report looks at the installers, loaders, and uninstallers found within\nthe Lazarus Group’s collection.\n\nInstallers provide an actor with a convenient way to install malware on a victim’s system with minimum user\nintervention. Installing malware on a victim’s system usually entails copying the malware binary to the appropriate,\ndesired location, installing a mechanism to ensure that the malware remains active after a system reboot, installing any\nadditional configuration parameters or files, and, of course, the actual activation of the malware on the victim’s machine.\nThese steps can be cumbersome and error prone when done manually. An installer eases the burden on the actor by\nproviding a single application that will perform the installation activities consistently across multiple infections.\n\nLoaders are responsible for loading a piece of malware on a victims’ system, but not necessary installing the malware.\nClearly loaders and installers have similar traits, but the primary distinction is that a loader is usually a support system\nfor another malware component. Loaders are typically responsible for loading a DLL component into memory given that a\nDLL cannot operate in a standalone mode such as an executable.\n\nOn the opposite side of the coin, an uninstaller removes a particular set of files from a victim system. In most cases, the\nuninstaller not only deletes the malware family’s binary, but also removes its services, ancillary files, and registry keys that\nwere installed as part of the installation process.\n\nThe Lazarus Group uses a variety of installers and loaders. Generally, there is a one-to-one relationship between installer\nand the malware family it installs, but there are examples where one installer family has been observed dropping different\nmalware families over time. This report will explore the various installers, uninstallers and loaders Novetta has observed\nthe Lazarus Group using.\n\nThe naming scheme used by Novetta for the malware identified during Operation Blockbuster consists of at least two\nidentifiers which each identifier coming from the International Civil Aviation Organization (ICAO)’s phonetic alphabet,\ncommonly referred to as the NATO phonetic alphabet. The first identifier specifies the general classification of the\nmalware family while the second identifier specifies the specific family within the larger general classification. For\nexample, IndiaAlfa specifies an installer family identified as Alfa.\n\n\n-----\n\n|FIRST LEVEL IDENTIFIER|GENERAL CLASSIFICATION|\n|---|---|\n|Delta|DDoS|\n|Hotel|HTTP Server|\n|India|Installer|\n|Lima|Loader|\n|Kilo|Keylogger|\n|Papa|Proxy|\n|Romeo|RAT|\n|Sierra|Spreader|\n|Tango|Tool (Non-classed)|\n|Uniform|Uninstaller|\n|Whiskey|Destructive Malware (“Wiper”)|\n\n\n**FIRST LEVEL IDENTIFIER** **GENERAL CLASSIFICATION**\n\nDelta DDoS\n\nHotel HTTP Server\n\nIndia Installer\n\nLima Loader\n\nKilo Keylogger\n\nPapa Proxy\n\nRomeo RAT\n\nSierra Spreader\n\nTango Tool (Non-classed)\n\nUniform Uninstaller\n\nWhiskey Destructive Malware (“Wiper”)\n\n**Table 1‑1: First Level Identifiers for the Lazarus Group Family Names and their Classification Meanings**\n\nThere is no temporal component to the second level identifiers given to malware families. While generally the second\nidentifiers are largely sequential (Alfa, Bravo, Charlie, and so on), the identifier does not indicate that one family came\nbefore another chronologically. Instead, the second level identifiers were assigned by the order Novetta discovered each\nparticular family.\n\n\n-----\n\n|Col1|eyAlfa eyBravo eyCharlie eyDelta|\n|---|---|\n|Whisk Whisk Whisk Whisk||\n\n\n## The Lazarus Group\n\n**WHISKEY** **UNIFORMUNIFORM** **TANGOTANGO** **SIERRASIERRA** **ROMEOROMEO** **PAPAPAPA** **LIMALIMA** **KILOKILO** **INDIA** **HOTEL** **DELTA**\n\nDestructive Uninstaller Tool Spreader RAT Proxy Loader Keylogger Installer HTTP Server DDoS\nMalware (Non-\n(”Wiper”) classed)\n\n**WhiskeyAlfa** **DeltaAlfa**\n\n**WhiskeyBravo** **DeltaBravo**\n\n**DeltaCharlie**\n\n**WhiskeyCharlie**\n\n**WhiskeyDelta**\n\n**UniformAlfa** **IndiaAlpha** **HotelAlfa**\n\n**UniformJuliett** **IndiaBravo**\n\n**TangoAlfa** **RomeoAlfa** **IndiaCharlie**\n\n**TangoBravo** **RomeoBravo** **IndiaDelta**\n\n**TangoCharlie** **RomeoCharlie** **IndiaEcho**\n\n**TangoDelta** **RomeoDelta** **IndiaFoxtrot**\n\n**RomeoEcho** **IndiaGolf**\n\n**RomeoFoxtrot** **IndiaHotel**\n\n**RomeoGolf** **IndiaIndia**\n\n**RomeoHotel** **IndiaJuliett**\n\n**SierraAlfa** **RomeoMike** **IndiaKilo**\n\n**SierraBravo** **RomeoNovember** **IndiaWhiskey**\n\n**SierraCharlie** **RomeoWhiskey**\n\n**SierraJuliett-MikeOne**\n\n**SierraJuliett-MikeTwo**\n\n**KiloAlfa**\n\n**LimaAlfa**\n\n**LimaBravo**\n\n**LimaCharlie**\n\n**PapaAlfa** **LimaDelta**\n\n\n-----\n\n### 2. [Installer] IndiaAlfa\n\nThe installer identified as IndiaAlfa has the characteristics of a phishing attack payload. IndiaAlfa mimics the behavior\nof opening a document file (PDF or Hangul’s[1] HWP) while at the same time installing a malicious payload. Samples of the\nIndiaAlfa family have been observed as early as September 2014 and as recently as May 2015, and identified samples have\ndropped a variety of Korean-language decoy documents.\n\nThere are slight variations between the various IndiaAlfa samples, but at their core each IndiaAlfa sample performs the\nfollowing tasks:\n\n1. Drop the phishing document (observed phishing documents are either PDF or HWP files)\n\n2. Drop the RomeoAlfa malware as %TEMP%\\AdobeArm.exe\n\n3. Open the phishing document\n\n4. Activate the RomeoAlfa malware\n\n5. Execute the suicide script to remove the IndiaAlfa binary.\n\n6. Terminate\n\nWhile the basic tasks remain the same over time for IndiaAlfa samples, the underlying methodologies differ. There are\ntwo known variants of IndiaAlfa which, for ease of identification, are given the names IndiaAlfa-One and IndiaAlfa-Two.\nIndiaAlfa-One samples have compile dates within September 2014 and IndiaAlfa-Two samples have observed compile\ndates from March 2015 onward.\n\n1 [Hancom. “Hangul Office 2014”. http://www.hancom.com/en/product/product2014vp_01.jsp Accessed 26 October 2015.](http://www.hancom.com/en/product/product2014vp_01.jsp)\n\n\n-----\n\n#### 2.1 IndiaAlfa-One\n\nIndiaAlfa-One samples drop two binaries in addition to a phishing document on the victim’s machine. The first\nexecutable is the RomeoAlfa malware and the second is a DLL that IndiaAlfa-One drops as HwpFilePathCheck.dll\n(SHA256: a7622ad260db5e66939e6b571e410df7b6e86cb0b633d155a7e27550f50e9cb6). Internally, the DLL is named\n```\n       hwp_vs6_com_dll.dll. HwpFilePathCheck.dll is a COM-based scaffold for opening a HWP file. The DLL\n\n```\ngenerates an instance of HWPFrame.HwpObject.1 in order to interact with the Hangul application for the purpose\nof opening the phishing document. Once the phishing document has been opened by the DLL’s OpenDocument\nexported function, the DLL serves no further purpose. The use of the DLL to open the HWP files is one of the defining\ncharacteristics of IndiaAlfa-One samples.\n\nIndiaAlfa-One samples have the earmarks of being the payload of a builder. The phishing document, the RomeoAlfa\nmalware payload, and the HwpFilePathCheck.dll binary are appended to the end of the IndiaAlfa-One binary. In\norder to extract the files (Tasks #1 and #2), the malware reads a stack of 32-bit values that indicate the size of the file image\nthat precedes the value. In other words, each file is appended to the end of the IndiaAlfa-One binary in a {image (variable\nsize), size of image (DWORD)} layer. There are three of these layers within the IndiaAlfa-One samples. In order (from last\nto first), the layers consist of the phishing document, the RomeoAlfa malware image, and the HwpFilePathCheck.dll\nimage. Figure 2-1 illustrates the stacks of appended binaries found within IndiaAlfa-One binaries.\n\nIndia Alfa-One Binary\n\nHwpFilePathCheck.dll binary\n\nsizeof(HwpFilePathCheck.dll)\n\nAlfa binary\n\nsizeof(Alfa binary)\n\nPhishing document\n\nsizeof(Phishing document)\n\n**Figure 2-1: Payload File Stacking within IndiaAlfa-One Samples**\n\nIn order to perform Task #3, IndiaAlfa-One will load the HwpFilePathCheck.dll binary into memory using\n```\n       LoadLibrary and then call the exported function OpenDocument with the name of the phishing document. The\n\n```\nname of the phishing document is hardcoded within IndiaAlfa-One and the observed samples use the Korean code page\nfor the filename string. After activating OpenDocument, IndiaAlfa-One will use the FindWindowA API function to\n\n\n-----\n\nlocate the opened document. If the window of the document is located, SetForegroundWindow is called to ensure that\nthe phishing document is the topmost window on the victim’s display.\n\nThe implementation of Task #5, the suicide script, uses a series of string concatenation operations in order to construct\nthe script before writing the script to a batch file, as illustrated below. Many suicide scripts are executed via a call to\n```\n       WinExec or CreateProcess API calls, but IndiaAlfa-One uses ShellExecuteA, which is a notable departure from\n\n```\nthe majority of Lazarus Group’s malware families including IndiaAlfa-One’s sibling IndiaAlfa-Two.\n```\n          strcpy(buffer, \"@echo off\\r\\n\");\n          strcpy(buffer, \":Loop\\r\\ndel /a H \\\"\");\n          strcat(buffer, szIndiaAlfaBinaryFilename);\n          strcat(buffer, \"\\\"\\r\\nif exist \\\"\");\n          strcat(buffer, szIndiaAlfaBinaryFilename);\n          strcat(buffer, \"\\\" goto Loop\\r\\ndel \\\"\");\n          strcat(buffer, szSuicideScriptFilename);\n          strcat(buffer, \"\\\"\");\n          WriteFile(fp, buffer, strlen(buffer), &NumberOfBytesWritten, 0);\n          CloseHandle(fp);\n          ShellExecuteA(0, \"open\", szSuicideScriptFilename, 0, 0, 0);\n\n```\n**Figure 2-2: Snippet of the IndiaAlfa-One Suicide Script Generation Code**\n\nThere is a unique mistake within the suicide script generation code in IndiaAlfa-One. The first instruction to construct the\ncontent of the suicide script is immediately rendered useless by the second instruction. Specifically, the strcpy(buffer,\n```\n       \"@echo off\\r\\n\") instruction has no effect since the next instruction, strcpy(buffer, \":Loop\\r\\ndel /a H\n       \\\"\"), will overwrite the results of the first instruction. The developer(s) should have used strcat instead of strcpy for the\n\n```\nsecond instruction if the @echo off command was desired. Ultimately this has no negative effects on the suicide script,\nbut it is an artifact that is also found in other Lazarus Group families using the same code for their suicide script generators,\nnotably WhiskeyAlfa-One and TangoDelta.\n\n\n-----\n\n#### 2.2 IndiaAlfa-Two\n\nThe development of IndiaAlfa-Two shows a change in technique, but only a slight deviation in methodology. The first\nnoticeable difference in IndiaAlfta-Two is the use of dynamic API loading. IndiaAlfa-Two is a simple installer which does\nnot require a significant number of function calls in order to execution its objectives, and the developers only dynamically\nload 7 functions. The API function names are encoded by XORing each byte in the string with 0xA7.\n\nWhile IndiaAlfa-One used a hardcoded filename for the phishing document, IndiaAlfa-Two relies on the name of itself to\nprovide the document’s name. For instance, if the IndiaAlfa-Two binary has the filename “abcdef.exe”, the dropped phishing\ndocument would be created within the same directory as the binary and given the name “abcdef.pdf” (for a PDF file).\n\nIndiaAlfa-Two uses the resource section of its binary to store the RomeoAlfa binary (in BIN\\101) as well as the phishing\ndocument (in BIN\\102). While IndiaAlfa-Two uses a simple XOR (using 0xA7 as the key) to obfuscate/encode API strings,\nthe authors make no effort to obfuscate the payload components. Both the RomeoAlfa binary and phishing document are\nstored within the resource section in plaintext.\n\nIndiaAlfa-Two does not use a secondary DLL in order to open the phishing document, instead using a simpler approach\nwith the ShellExecute API function, which will perform the default action the operating system has associated\nwith the file’s type. Additionally, the use of ShellExecute allows the IndiaAlfa-Two binary to serve various file types\nwithout additional overhead. For instance, the IndiaAlfa-Two samples can easily switch between PDF and HWP phishing\ndocuments without the need to recode the portion of the binary responsible for opening the document.\n\nIndiaAlfa-Two introduces a slight deviation in the tasks that IndiaAlfa-One performs. The first task that IndiaAlfa-Two\nperforms is the removal of the file %TEMP%\\~DF{random value}. IndiaAlfa-Two will attempt to move itself to the\n```\n       %TEMP%\\~DF{random value} filename prior to the suicide script’s execution. The suicide script itself is generated using a\n\n```\ndifferent technique than seen in IndiaAlfa-One. Notably, the script is generated in place on disk as seen in the Figure 2-3,\nrather than in memory and then copied to disk.\n```\n          void __noreturn Suicide(char *pszFilename)\n          {\n           FILE *fp;\n           char szSuicideScriptFilename[256];\n           GetTempPathA(0x104u, szSuicideScriptFilename);\n           strcat(szSuicideScriptFilename, \"PM0D4.bat\");\n           fp = fopen(szSuicideScriptFilename, \"wb\");\n           fprintf(fp, \":Repeat1\\r\\n\");\n           fprintf(fp, \"del \\”%s\\\"\\r\\n\", pszFilename);\n           fprintf(fp, \"if exist \\\"%s\\\" goto Repeat1\\r\\n\", pszFilename);\n           fprintf(fp, \"del \\\"%s\\\"\\r\\n\", szSuicideScriptFilename);\n           fclose(fp);\n           WinExec(szSuicideScriptFilename, 0);\n           exit(1);\n          }\n\n```\n**Figure 2-3: IndiaAlfa-Two’s Suicide Script Generator**\n\nWhile observed samples of IndiaAlfa-Two have only used PDF and HWP phishing documents, the binary indicates that\nMicrosoft Excel spreadsheet files (XLS) may also be used by the Lazarus group in attacks. IndiaAlfa-Two executes the code\nseen in Figure 2-4 immediately before beginning Task #1.\n```\n          printf(\"ExePath: %s\\nXlsPath: %s\\nTmpPath: %s\\n\", szTrojanFilenamePath,\n          szCoverFilenamePath, szNewDropperFilenamePath);\n\n```\n**Figure 2-4: Artifact within IndiaAlfa-Two Indicating the Possibility that IndiaAlfa-Two May Also be used with Excel Decoy Documents**\n\n\n-----\n\n### 3. [Installer] IndiaBravo\n\nIndiaBravo is a versatile installer that has been observed installing three different malware families: the RomeoBravo\nRAT, the RomeoCharlie RAT, and the PapaAlfa proxy. IndiaBravo provides a customizable framework that the authors of\nother malware families can utilize to install their malware on a victim’s machine. The IndiaBravo installer performs, at a\nminimum, four tasks:\n\n1. Dynamically load API functions (including functions that are not used by the installer).\n\n2. Call the WriteConfig function to install the configuration for the malware being installed.\n\n3. Call the ExtractDll function to install the malware image on the victim’s machine.\n\n4. Call CreateSVC to install and start the Windows service that is responsible for activating the installed malware.\n\nThe dynamic API loading component of IndiaBravo uses a combination of XOR and Space-Dot string obfuscation. The\nnames of libraries (e.g. kernel32.dll, advapi32.dll) are obfuscated by using the XOR byte manipulation with the\nconstant 0xA7 while the names of the API functions to load are obfuscated using the Space-Dot method. Of the 102 API\nfunctions that IndiaBravo loads during the dynamic API loading process, only 21-31% of the functions are used by the\ninstaller, depending on the type of malware being installed.\n\nAs previously stated, IndiaBravo is a framework, allowing a malware author to modify the base code to fit a particular\nmalware’s installation needs. As such, the WriteConfig function is by-and-large dropped depending on the malware,\nwhile the functions ExtractDll and CreateSVC are not. To date, there have been three IndiaBravo variants observed:\nIndiaBravo-RomeoBravo, as the name implies, installs the RomeoBravo RAT, IndiaBravo-RomeoCharlie installs the\nRomeoCharlie RAT, and IndiaBravo-PapaAlfa installs the PapaAlfa proxy. The malware image is appended to the end of\nthe IndiaBravo executable followed by a 32-bit value (DWORD) identifying the size of the malware image in exactly the\nsame way that IndiaAlfa stores its dropped components. Both IndiaBravo-RomeoBravo and IndiaBravo-RomeoCharlie\nstore their malware payloads in plaintext, while IndiaBravo-PapaAlfa offsets the value of each byte within its malware\npayload image by adding 0xD7 to each byte.\n\nBefore exploring the intricacies of each variant, it is best to explain the more general functions consistent across\nvariants, ExtractDll and CreateSVC. The ExtractDll function drops the malware on a victim’s system. While\nonly IndiaBravo-PapaAlfa has been observed decoding its payload prior to dropping said payload to disk, structural\nartifacts within IndiaBravo samples suggests that this may the more the norm for the IndiaBravo framework, rather\nthan the exception. Both of the IndiaBravo-Romeo variants contain code within ExtractDll that appears to forego\nmanipulating the payload’s image (or more precisely, performs the same act as IndiaBravo-PapaAlfa but with 0 as the\nconstant instead of 0xD7). The code fragment in Figure 3-1 from an IndiaBravo-RomeoBravo sample illustrates the\nlocation of where the IndiaBravo framework’s ExtractDll function would manipulate a payload’s image in memory:\n```\n          ptr = (char *)LocalAlloc(0x40u, dwImageSize);\n          if ( ptr )\n          {\n           memcpy(ptr, &pvImageSource[uBytes - 4] - dwImageSize, dwImageSize);\n           for ( i = 0; i < dwImageSize; ++i )\n             ptr[i] = ptr[i];\n\n```\n**Figure 3-1: Neutered Decryption Code Snippet from IndiaBravo’s ExtractDLL Function**\n\n\n-----\n\n|IndiaBravo-RomeoBravo|Local WMI Security Service provides performance library information from Windows Management Instrumentation providers network. If the Service is not running Wmi Security log is not being saved.|\n|---|---|\n|IndiaBravo-RomeoCharlie|Provides performance library information from Windows Management Instrumentation (WMI) providers to clients on the network. If the Service is not running, Wmi Security log is not being saved.|\n|IndiaBravo-PapaAlfa|Internet Network Moniter provides performance library information from Windows Management Instrumentation providers network. If the Service is not running, Wmi Security log is not being saved.|\n\n\nAfter extracting the payload’s image into memory, ExtractDll writes the file to disk within the %SYSDIR% directory using\nthe specified filename (which varies by variant). In order to camouflage the newly dropped malware, ExtractDll attempts\nto copy the timestamp for calc.exe to the newly dropped malware file before the ExtractDll function returns.\n\nWith the dropped malware written to disk thanks to ExtractDll, CreateSVC provides the scaffolding for persistence\nand activation of the dropped malware on the victim’s system. IndiaBravo’s general approach for establishing a service on\na victim’s machine is as follows:\n\n1. Create a registry key at HKLM\\SYSTEM\\CurrentControlSet\\services\\<name of new service>\n\n2. Set the Description and Parameter\\ServiceDll values appropriately\n\n3. Create a new service group under HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost for\n\nthe new service\n\n4. Call CreateServiceW to add the new service to the services database\n\n5. Call ChangeServiceConfig2W to ensure that the service will auto-restart after an error condition\n\n6. Call StartServiceW to activate the service\n\nThe values for the service group, the Description and ServiceDll values, and the name of the service are all specific\nto each of the IndiaBravo variants. Table 3-1 shows each of the Description fields for the various IndiaBravo variants\nwith the unique elements in bold. What is particularly interesting about the Description strings is the extremely slight\nvariations between each variant. The similarities between the various Description values vary so little that the typo\nof the missing space in “network.If” is found in all three variants of IndiaBravo. This commonality coupled with the\nfact that different IndiaBravo variants are being used to deliver different malware payloads adds additional support to the\nclaim that IndiaBravo is an installer framework that is customized for each type of dropped malware.\n\n**Local WMI Security Service provides performance library information from Windows**\n\nIndiaBravo-RomeoBravo Management Instrumentation providers network. If the Service is not running Wmi\n\nSecurity log is not being saved.\n\nProvides performance library information from Windows Management Instrumentation\n\nIndiaBravo-RomeoCharlie **(WMI) providers to clients on the network. If the Service is not running, Wmi Security log**\n\nis not being saved.\n\n**Internet Network Moniter provides performance library information from Windows**\n\nIndiaBravo-PapaAlfa Management Instrumentation providers network. If the Service is not running, Wmi\n\nSecurity log is not being saved.\n\n**Table 3-1: Description Values for the IndiaBravo Variants**\n\n\n-----\n\n|EXIT CODE|DESCRIPTION|\n|---|---|\n|0|IndiaBravo successfully completed|\n|1|(variant dependent)|\n|2|WriteConfig failed|\n|3|ExtractDll failed|\n|4|CreateSVC failed|\n\n\nOnce IndiaBravo completes its task of dropping the configuration for its malware, dropping the malware itself, and finally\ncreating and activating a service to ensure the malware’s persistence, IndiaBravo then terminates. Console applications,\nsuch as IndiaBravo, return an exit code upon completion. While the return code for an application is usually set to 0 and\nsubsequently ignored by the calling application (such as cmd.exe), the exit code can provide status information about\na program to the caller, allowing the caller to determine success or failure of an application’s task. This is a common\npractice for scriptable applications. IndiaBravo actively uses the exit code feature to signal the status of its operation,\nreturning a value of 0 to 4 depending on if an error occurred and, if so, what part of the framework experienced the error.\nTable 3-2 explains the meaning of each exit code:\n\n**EXIT** **DESCRIPTION**\n**CODE**\n\n0 IndiaBravo successfully completed\n\n1 (variant dependent)\n\n2 **WriteConfig failed**\n\n3 `ExtractDll failed`\n\n4 `CreateSVC failed`\n\n**Table 3-2: IndiaBravo’s Exit Codes**\n\nBecause each of the IndiaBravo variants customizes the framework to fit the needs of the malware and the developer, the\nfollowing subsections explore the key variations between each of the IndiaBravo variants.\n\n\n-----\n\n#### 3.1 IndiaBravo-RomeoBravo Variant\n\nIndiaBravo-RomeoBravo (IBRB) is the installer responsible for dropping the RomeoBravo malware. IBRB begins by dropping\nthe malware binary at %SYSDIR%\\wmisecsvc.dll. Compared to other IndiaBravo variants, the line of demarcation\nbetween IBRB’s ExtractDll and WriteConfig functions is more blurred based on the fact that ExtractDll also\nextracts a configuration data blob of 456 bytes from the IBRB binary. The configuration data exists immediately before the\nRomeoBravo image and is stored in plaintext. ExtractDll loads the configuration blob into memory.\n\nOnce ExtractDll completes the file and configuration data extraction, WriteConfig modifies the configuration\ndata blob by assigning a 64-bit, randomly generated value to the qwIdentifier field of the RomeoBravo configuration.\nThe WriteConfig encrypts the configuration data using the DNSCALC-style encoding scheme, and the encrypted\nconfiguration is then dropped to disk at %SYSDIR%\\tmscompg.ini.\n\nThe CreateSVC function follows the general IndiaBravo method of establishing a new service, but, specifically, the\nfunction generates a new service group named LocalWmiSecurity after establishing the registry entries necessary to\ndefine the WmiSecSvc service.\n\nIBRB monitors the status of each of the installation tasks and, if any of the tasks fails, calls a suicide script (saved in the\n```\n       %TEMP% directory as cvrit000.bat) to remove its binary. The suicide script, Figure 3-2, only removes the IBRB binary\n\n```\nand will not attempt to clean up any of the successful steps that may have occurred during the installation process.\n```\n          :L1\n          del \"<full path to>wmisecsvc.dll\"\n          if exist \"<full path to>wmisecsvc.dll\" goto L1\n          del <full path to>cvrit000.bat\n\n```\n**Figure 3-2: IndiaBravo-RomeoBravo’s Suicide Script**\n\nAfter completing the installation and activation tasks, IBRB then calls the suicide script to remove itself from the victim’s\nmachine.\n\n\n-----\n\n|FIELD|PATTERN|\n|---|---|\n|Service Name|<prefix1 string><name1 string><suffix1 string>|\n|DLL Filename|<prefix1 string><name1 string><suffix1 string>.dll|\n|Config Filename|<prefix1 string><name1 string><suffix1 string>tl.cpl|\n|Service Display Name|<prefix2 string> <name2 string> <suffix2 string>|\n|Service Group Name|<name3 string><prefix1 string>|\n\n\n#### 3.2 IndiaBravo-RomeoCharlie Variant\n\nIndiaBravo-RomeoCharlie (IBRC) is a verbose installer for the RomeoCharlie malware. IBRC records each step of the\ninstallation process to STDOUT. The IndiaBravo framework uses the Windows GUI subsystem, meaning any data sent\nto STDOUT is not echoed to the console as would be the case for a program that uses the Windows character subsystem.\nInstead, the user of IBRC would have to pipe STDOUT to a file. After a successful execution of IBRC, the output from\nSTDOUT looks like Figure 3-3.\n```\n          SvcName = WebOrderService\n\n```\n**[SVCNAME] = WebOrderService[1] - WriteConfig...**\n```\n          [2] - Extract Dll...\n          [3] - CreateSVC...\n          [4] – Success\n\n```\n**Figure 3-3: IndiaBravo-RomeoCharlie’s Output from STDOUT**\n\nThe SvcName and [SVCNAME] fields are identical, but variable. This a byproduct of how IBRC establishes the service.\nPrior to the call to WriteConfig, IBRC constructs the service name, service group, service display name, and the\nconfiguration filename by randomly selecting from a group of text strings to construct the values.\n\n**FIELD** **PATTERN**\n\nService Name <prefix1 string><name1 string><suffix1 string>\n\nDLL Filename <prefix1 string><name1 string><suffix1 string>.dll\n\nConfig Filename <prefix1 string><name1 string><suffix1 string>tl.cpl\n\nService Display Name <prefix2 string> <name2 string> <suffix2 string>\n\nService Group Name <name3 string><prefix1 string>\n\n**Table 3-3: IndiaBravo-RomeoCharlie’s Service Information Field Patterns**\n\n\n-----\n\n|SET|VALUES|\n|---|---|\n|prefix1|Wmi Dcom Timer Win Remote Sys App COM Web Com|\n|prefix2|WMI DCOM Timer Windows Remote System Application COM+ Web Internet Computer|\n|name1|Sec Log hlp Evt Order Registrys logon Mon Accesses HW|\n|name2|Security Log Helper Event Ordering Registrys Logon Moniter Accesses Hardwares|\n|name3|LocalHost Network LocalService LocalCenter NetWorkRestricted LocalNetwork LocalRestricted LocalMan LocalNo Service|\n|suffix1|Svc svc Man Manager SS host Psvc Agent Service Client|\n|suffix2|Service Service Manager Scheduler HOST Protocal Service Agent Services Client|\n\n\nThe values for the different prefix, name, and suffix string sets are as follows:\n\n**SET** **VALUES**\n\nWmi Dcom Timer Win Remote\n\nprefix1\n\nSys App COM Web Com\n\nWMI DCOM Timer Windows Remote\n\nprefix2\n\nSystem Application COM+ Web Internet Computer\n\nSec Log hlp Evt Order\n\nname1\n\nRegistrys logon Mon Accesses HW\n\nSecurity Log Helper Event Ordering\n\nname2\n\nRegistrys Logon Moniter Accesses Hardwares\n\nLocalHost Network LocalService LocalCenter NetWorkRestricted\n\nname3\n\nLocalNetwork LocalRestricted LocalMan LocalNo Service\n\nSvc svc Man Manager SS\n\nsuffix1\n\nhost Psvc Agent Service Client\n\nService Service Manager Scheduler\n\nsuffix2\n\nHOST Protocal Service Agent Services Client\n\n**Table 3-4: IndiaBravo-RomeoCharlie’s Possible Prefix, Names, and Suffix Values**\n\nNote that the index of the string used for prefix1 are the same for prefix2. This means that if IBRC randomly selects “Web”\nas the value for prefix1, prefix2 will have the value “Web Internet.” Likewise, the index for name2 will be the same as the\nindex used for name1 and suffix1 and suffix2 will have the same index into their respective string arrays. This ensures that\nthe display name for the service closely corresponds to the name given for the service name and DLL.\n\nIBRC is more interactive than the other IndiaBravo variants and can take an optional command line argument. The\nargument will be a number that specifies the port number that the RomeoCharlie malware will be configured to listen on.\nIn the absence of such a command line argument, the default port of 488 is selected. To ensure that the port is available as\na listening port, IBRC initializes the Winsock subsystem and attempts to connect to the port using the loopback address\n127.0.0.1. If the connection is successful, the socket disconnect function SendErrorAndCloseSocket, found in many\nof the Lazarus Group’s malware families, is used to close the socket. A successful connection to the port on the loopback\ninterface indicates that the port is unavailable for binding and will result in IBRC aborting the installation process\nimmediately and setting the exit code to 1.\n\nThe WriteConfig function within IBRC stores the configuration within the victim machine’s registry, not as a file.\nWhile the process of generating service information does, in fact, generate a configuration file name, a file is never\ngenerated by IBRC for the configuration. Instead, the configuration for RomeoCharlie is stored in the key HKLM\\\n```\n       SYSTEM\\CurrentControlSet\\Control\\WMI\\Security\\xc123465-efff-87cc-37abcdef9 as a data blob. The\n\n```\n**WriteConfig function also stores the specified listening port, assigns a randomly generated 64-bit number as the victim**\nmachine’s unique identifier, and saves the selected name of the service in the configuration’s data blob prior to setting the\nvalue in the registry.\n\nIBRC is unique among the observed IndiaBravo samples in that it does not use a suicide script to remove itself from a victim’s\nmachine after execution. Also unique is the inclusion of the string RS_SDKInstaller and RS_SDKINSTALLER within\nthe resource section’s String branch. This value is not found in the other IndiaBravo variants.\n\n\n-----\n\n#### 3.3 IndiaBravo-PapaAlfa Variant\n\nIndiaBravo-PapaAlfa (IBPA) is responsible for installing the PapaAlfa proxy malware on a victim’s machine. Using the\nsame method as IndiaBravo-RomeoCharlie, IBPA will record the state of each step of the installation process to STDOUT.\nWhen captured to file, the output from IBPA after a successful installation appears as seen in Figure 3-4.\n```\n          [2] - Extract Dll...\n\n```\n**[1] - WriteConfig...**\n```\n          [3] - CreateSVC...\n          [4] – Success\n\n```\n**Figure 3-4: IndiaBravo-PapaAlfa’s Output from STDOUT**\n\nThe most notable attribute of IBPA’s output is the reordering of operations. IBPA performs ExtractDll prior to\n**WriteConfig. The WriteConfig function will record the listening port as a 32-bit value within the file stored at**\n**%SYSDIR%\\pmsconfig.msi. The listening port is specified by either supplying an optional command line argument or, if**\nthe argument is missing, using the default port 443.\n\nThe ExtractDll function stores the PapaAlfa binary at %SYSDIR%\\netmonsvc.dll. The CreateSVC function will\ngenerate a new service named NetMonSvc and assign it to the newly created LocalMonNetwork service group before\nactivating the service.\n\nJust as IndiaBravo-RomeoBravo did, IBPA monitors the status of each of the installation tasks and, if any of the tasks fails,\nremoves its binary by calling the suicide script, saved to %TEMP% directory as cvrit000.bat. The suicide script, seen\nbelow and identical to the one used by IndiaBravo-RomeoBravo, only removes the IBPA binary and does not attempt to\nclean up any of the successful steps that may have occurred during the installation process.\n```\n          :L1\n          del \"<full path to>wmisecsvc.dll\"\n          if exist \"<full path to>wmisecsvc.dll\" goto L1\n          del <full path to>cvrit000.bat\n\n```\n**Figure 3-5: IndiaBravo-PapaAlfa’s Suicide Script**\n\nAfter completing the installation and activation tasks, IBPA calls the suicide script to remove itself from the victim’s\nmachine before terminating silently.\n\n#### 3.4 Swapping Out Payloads\n\nEvidence suggests that IndiaBravo malware, regardless of the variant, are compiled and assembled independently of the\npayloads that they carry, as there are several observed samples that have compile dates significantly out of sync with\nthe compile dates of their payloads. Additionally, there exists at least two known samples of IndiaBravo that have the\nsame compile date but carry payloads with dates that are 11 days apart. It is highly likely that the IndiaBravo malware is\ncompiled once and then reused for different payloads by simply using the compiled IndiaBravo binary as the foundation\nand appending the desired payload. This could easily be done using a simple script.\n\n\n-----\n\n### 4. [Installer] IndiaCharlie\n\nWith samples observed as far back at late 2013, IndiaCharlie, the installer for RomeoFoxtrot, is an interesting departure\nfrom the other India malware families with respect to the cryptography used to obfuscate API names dynamically\nloaded by the malware. Up until late 2015, when the developer(s) appeared to abandon dynamic API loading, the dynamic\nAPI loading functionality used a C++ implementation of AES to decrypt the names of API functions. This particular\nimplementation of AES comes from a Code Project post from 2002.[2] The use of AES encryption is somewhat rare\nwithin the collection of families found within the Lazarus Group. That said, the use of AES by the Lazarus Group is not\nunprecedented, as the same AES library is used by RomeoFoxtrot and SierraJuliett-MikeOne. What makes the use of AES\nparticularly interesting with regards to IndiaCharlie is the use of AES decryption for the deobfuscation of API names\nduring the dynamic API loading phase.\n\nIndiaCharlie can operate as both a standalone installer/loader and as a standalone service executable. There are\ntwo variants of IndiaCharlie. Earlier versions, identified as IndiaCharlie-One, do not directly install a service for\nRomeoFoxtrot; rather, they merely drop and subsequently load the RomeoFoxtrot binary (as %SYSDIR%\\backSched.dll).\nIn early 2015, the IndiaCharlie malware was observed mutating into a new variant, identified as IndiaCharlie-Two, that\nnot only drops the RomeoFoxtrot binary, but also installs the dropped binary as a service before activating the service.\nThe change in the variants’ methodologies corresponds to the changes in the RomeoFoxtrot functionality and the method\nby which RomeoFoxtrot initializes itself.\n\nBoth IndiaCharlie variants have common components and a sequence of events that occur. They begin by determining\nif the flag –s is present on the command line when the executable is activated. If found, the –s flag causes IndiaCharlie\nto activate in standalone mode, a mode that has slightly different meaning depending on the variant in question. If\nthe –s flag is missing, IndiaCharlie initializes as a service executable, which consists of establishing a ServiceMain\ncallback functions before calling the Windows API function StartServiceCtrlDispatcherA to start a new\nservice. When activated as a service, IndiaCharlie establishes the framework of a legitimate Windows service that goes\nfrom SERVICE_START_PENDING to SERVICE_RUNNING and finally to SERVICE_STOPPED. During the state changes,\nthe same sequence of functions that are called in standalone mode are called. Ultimately, if IndiaCharlie is run as a\nstandalone executable or a standalone service, the same sequence of installation/loading functions are called, making the\nuse of the Windows service scaffolding largely unnecessary.\n\nThe variants of IndiaCharlie share some common code attributes amongst themselves and the larger Lazarus malware\ncollection. For instance, as part of the process that drops the payload malware to the victim’s hard drive, the full directory\npath to the drop site is verified and constructed if necessary using the function described in Section 4.3.4 of the Operation\nBlockbuster report.[3] Also, whenever the suicide script is necessary, IndiaCharlie uses the same method and text for the\nsuicide script as IndiaGolf (see 6.2.7). The suicide script generation takes the form seen in Figure 4-1.\n\n[2 George Anescu. “A C++ Implementation of the Rijndael Encryption/Decryption method” http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr 8 Nov. 2002](http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr)\n\n3 http://www.operationblockbuster.com/wp-content/uploads/2016/02/Operation-Blockbuster-Report.pdf\n\n\n-----\n\n```\n          fp = fopen(\"d.bat\", \"w+\");\n          if ( fp)\n          {\n           fprintf(fp, \":R\\nIF NOT EXIST %s GOTO E\\ndel /a %s\\nGOTO R\\n:E\\ndel /a d.bat\", \"%1\",\n          \"%1\");\n           fclose(fp);\n           sprintf(cmdLine, \"d.bat \\\"%s\\\"\", &Filename);\n           WinExec(cmdLine, 0);\n\n```\n**Figure 4-1: Snippet of IndiaCharlie’s Suicide Script Generator**\n\nThe suicide script itself is somewhat unique in its approach. What makes this suicide script somewhat unique is that the\nname of the target file is not hardcoded into the batch file, but rather taken from the first argument of the command line\nexecuting the batch file. This technique is only used in a small number of the Lazarus Group’s families.\n\n#### 4.1 IndiaCharlie-One\n\nIndiaCharlie-One has compile dates ranging from at least late 2013 to early 2014 and is responsible for the delivery of the\nRomeoFoxtrot malware variant identified as RomeoFoxtrot-One. IndiaCharlie-One binaries perform the following steps\nas part of their payload loading:\n\n1. Ensure the path to %SYSDIR% exists, create the hierarchy of folders if necessary\n\n2. Copy the RomeoFoxtrot-One binary from a memory buffer within IndiaCharlie-One to the victim’s computer at\n```\n         %SYSDIR%\\backSched.dll\n\n```\n3. Set the backSched.dll’s file timestamp to match that of mspaint.exe’s.\n\n4. Load backSched.dll by calling LoadLibrary\n\n5. [If IndiaCharlie-One is activated as a service] Drop and execute the suicide script\n\nIndiaCharlie-One is better classified as a loader than an installer given that the malware simply drops the\nRomeoFoxtrot-One malware image on the victim’s machine, and it is up to the RomeoFoxtrot-One malware to perform\nthe actual persistence operations. Given RomeoFoxtrot-One’s functionality to install itself on a victim’s machine as a\nservice, the burden of establishing persistence is effectively lifted from IndiaCharlie-One. Instead, IndiaCharlie-One\nneed only ensure that the DllMain of the RomeoFoxtrot-One malware is activated. To perform this task, a call to\n```\n       LoadLibray is made in order to the load the RomeoFoxtrot-One malware into memory and thereby activate the\n       DllMain function.\n\n```\nWhile IndiaCharlie variants rely on AES to obfuscate the API function names, the embedded RomeoFoxtrot malware is\nactually stored within the IndiaCharlie-One binary in cleartext. Furthermore, the RomeoFoxtrot-One malware exists as a\nstatic buffer within IndiaCharlie-One’s .data section, meaning that swapping out the malware may require a recompile\nof the IndiaCharlie-One binary. This links IndiaCharlie-One to the specific RomeoFoxtrot-One malware it is delivering.\n\nWhen IndiaCharlie-One is activated as a service (which has the static identifier of WMPNetworkSvcUpdate), instead of\nstandalone mode, a suicide script is generated and executed. This indicates that in service mode, the IndiaCharlie-One\nbinary is expendable and should be removed after execution. The generation and execution of the suicide script occurs\nwhether or not the loading of the RomeoFoxtrot-One malware is successful.\n\n\n-----\n\n#### 4.2 IndiaCharlie-Two\n\nIndiaCharlie-Two is the installer for the RomeoFoxtrot variant identified as RomeoFoxtrot-Two and exhibits more\nvariation over the course of its known life span than IndiaCharlie-One. The RomeoFoxtrot-Two malware lacks the\nnecessary functionality to install itself as an active Windows service on the victim’s computer, therefore it is the\nresponsibility of IndiaCharlie-Two to not only drop and activate the RomeoFoxtrot-Two payload it contains, but to also\nestablish its persistence. In both standalone mode and in service mode, IndiaCharlie-Two performs the following tasks in\norder to drop, install, and activate the RomeoFoxtrot-Two payload on a victim’s machine:\n\n1. Dynamically generate the service name, service display name, service DLL filename, and the service description\n\n2. Ensure the path to location generated for the RomeoFoxtrot-Two binary (typically %SYSDIR%) exists, create the\n\nhierarchy of folders if necessary\n\n3. Copy the RomeoFoxtrot-Two binary from a memory buffer within IndiaCharlie-Two to the victim’s computer within\n\nthe %SYSDIR% directory under the name generated in Task #1\n\n4. Set the RomeoFoxtrot-Two’s file timestamp to match that of mspaint.exe’s.\n\n5. Install the Windows service using the generated parameters from Task #1\n\n6. Activate the newly installed service\n\n7. Open a hole within the victim’s Windows firewall for the listening port of the newly activate RomeoFoxtrot-Two\n\nmalware.\n\n8. [If IndiaCharlie-Two was activated as a service] Drop and execute the suicide script\n\nThe timeline for IndiaCharlie-Two is not as easily determined as IndiaCharlie-One’s. Two known samples of\nIndiaCharlie-Two have compile times of July 13, 2009 23:15. The associated RomeoFoxtrot-Two payloads within these\ntwo samples both have timestamps of July 14, 2009 01:05. While this may suggest that the malware date back to 2009, a\ncloser inspection of the payload malware’s export table reveals the more probably compile dates of January 13, 2015 07:41\nand December 11, 2014 03:45. It is not uncommon for malware developers to alter the compile timestamp in the PE header\nof a file to obfuscate when the malware was originally developed, but more often than not when this is done to a DLL\nwith exports, developers forget to modify the timestamp associated with the export table and thus leave behind the true\ncompilation timestamp. Give the intimate relationship between IndiaCharlie-Two and its RomeoFoxtrot-Two payload,\nit is more likely the earliest observed IndiaCharlie-Two binaries date from mid-December 2014. This assertion is further\nsupported by the first submitted dates on VirusTotal for the binaries with the July, 2009 compile dates showing the\nsamples being submitted within hours of each other on January 13, 2015.[4 5]\n\nIndiaCharlie-Two goes out of its way to attempt to blend into the existing Windows services. Task #1 is responsible for\nconstructing the necessary information for the new service that will provide persistence for the RomeoFoxtrot-Two payload.\nIn order to better mimic the victim’s currently installed services, Task #1 begins by using the Windows API function\n```\n       EnumServicesStatusA to pull a list of all currently installed services. From this list of services, one service entry is\n\n```\nrandomly selected to become the template for RomeoFoxtrot-Two’s service. IndiaCharlie-Two will take the service name,\nservice display name, and service description values from the template service and modify them as identified in Table 4-1.\n\n[4 VirusTotal. “Antivirus Scan for 8fe806470914f9cdaaaa8448aa6317547c618efd65d15947767753fc88bc73d9 at 2015-01-13 06:39:09 UTC” https://www.virustotal.com/en/file/8fe806470914f9cdaaaa8448aa6317547c618efd6](https://www.virustotal.com/en/file/8fe806470914f9cdaaaa8448aa6317547c618efd65d15947767753fc88bc73d9/analysis/)\n\n[5d15947767753fc88bc73d9/analysis/ 13 January 2015.](https://www.virustotal.com/en/file/8fe806470914f9cdaaaa8448aa6317547c618efd65d15947767753fc88bc73d9/analysis/)\n\n[5 VirusTotal. “Antivirus Scan for 2b731d82b76f6d50a9d3fd72ac16e6fbb76779b57b114044bb61cd6e422f0cd0 at 2015-01-13 07:58:44 UTC” https://www.virustotal.com/en/file/2b731d82b76f6d50a9d3f](https://www.virustotal.com/en/file/2b731d82b76f6d50a9d3fd72ac16e6fbb76779b57b114044bb61cd6e422f0cd0/analysis/)\n\n[d72ac16e6fbb76779b57b114044bb61cd6e422f0cd0/analysis/ 13 January 2015.](https://www.virustotal.com/en/file/2b731d82b76f6d50a9d3fd72ac16e6fbb76779b57b114044bb61cd6e422f0cd0/analysis/)\n\n\n-----\n\n|SERVICE DETAIL|ALTERATIONS|\n|---|---|\n|Service Name|Change template’s name to all lowercase If contains “svc”, replace “svc” with “mgr”. Otherwise append “svc”|\n|Service Display Name|From the template’s display name, make the following substitutions: “Services” to “Provider” “Service” to “Manager” Find the last space and overwrite last word with “Service” If there are no spaces, append “Service”|\n|Service Description|Concatenate the new service’s display name with “is an essential element in Windows System configuration and management.” Append the template’s description|\n\n|SERVICE DETAIL|VALUE|\n|---|---|\n|Service Name|fsbrmgr|\n|Service Display Name|File System Backup and Restore Manager|\n|Service Description|File System Backup and Restore Manager is used by Windows Backup to perform backup and recovery operations. If this service is stopped by a user, it may cause the currently running backup or recovery operation to fail. Disabling this service may disable backup and recovery operations using Windows Backup on this computer.|\n\n|SERVICE DETAIL|VALUE|\n|---|---|\n|Service Name|drvins|\n|Service Display Name|Driver Install Manager|\n|Service Description|Driver Install Manager is used by Windows Dirver Install to perform backup and recovery operations. If this service is stopped by a user, it may cause the currently running backup or recovery operation to fail. Disabling this service may disable backup and recovery operations using Windows Backup on this computer.|\n\n\n**SERVICE DETAIL** **ALTERATIONS**\n\nChange template’s name to all lowercase\n\nService Name\n\nIf contains “svc”, replace “svc” with “mgr”. Otherwise append “svc”\n\nFrom the template’s display name, make the following substitutions:\n\n“Services” to “Provider”\n\nService Display Name “Service” to “Manager”\n\nFind the last space and overwrite last word with “Service”\n\nIf there are no spaces, append “Service”\n\nConcatenate the new service’s display name with “is an essential element in Windows\nSystem configuration and management.”\n\nService Description\n\nAppend the template’s description\n\n**Table 4-1: IndiaCharlie-Two’s Service Detail Modification Steps**\n\nIf for any reason IndiaCharlie-Two is unable to access any of the services, and therefore unable to access the name, display\nname, and description of an installed Windows service on the victim’s machine, IndiaCharlie-Two falls back to a set of\ndefault values seen in Table 4-2.\n\n**SERVICE DETAIL** **VALUE**\n\nService Name fsbrmgr\n\nService Display Name File System Backup and Restore Manager\n\nFile System Backup and Restore Manager is used by Windows Backup to perform backup\nand recovery operations. If this service is stopped by a user, it may cause the currently\n\nService Description\n\nrunning backup or recovery operation to fail. Disabling this service may disable backup and\nrecovery operations using Windows Backup on this computer.\n\n**Table 4-2: IndiaCharlie-Two’s Failback Service Details**\n\nSometime between April 2015 and late-August 2015, the default values for IndiaCharlie-Two changed to the value seen in\nTable 4-3.\n\n**SERVICE DETAIL** **VALUE**\n\nService Name drvins\n\nService Display Name Driver Install Manager\n\nDriver Install Manager is used by Windows Dirver Install to perform backup and recovery\noperations. If this service is stopped by a user, it may cause the currently running backup or\n\nService Description\n\nrecovery operation to fail. Disabling this service may disable backup and recovery operations\nusing Windows Backup on this computer.\n\n**Table 4-3: IndiaCharlie-Two’s Post-April 2015 Fallback Service Details**\n\nThe name for the RomeoFoxtrot-Two binary is the combination of the generated service name and the extension .dll.\nThe location of the RomeoFoxtrot-Two malware is generated by calling the API function GetSystemDirectoryA, but,\nif that call fails, IndiaCharlie-Two defaults to C:\\windows\\system32.\n\n\n-----\n\nIndiaCharlie-Two uses the exact same function, sans the LoadLibrary call, that IndiaCharlie-One uses for extracting\nthe RomeoFoxtrot-Two binary from its .data section and writing the file to disk. Just as IndiaCharlie-One does not have\nan encrypted payload, IndiaCharlie-Two’s RomeoFoxtrot-Two payload is in cleartext with the exception of two known\nsamples that use simple XOR encoding. These two samples are believed to date from mid-Dec 2014 and are the same\nsamples that have the likely false July 2009 compile dates discussed above.\n\nIndiaCharlie-Two installs the RomeoFoxtrot-Two malware as a service on the victim’s machine (Task #5) as an\nsvchost-dependent service. IndiaCharlie-Two begins Task #5 by creating a new registry key under HKLM\\SYSTEM\\\n```\n       CurrentControlSet\\Services\\ with the generated name of the new service. The Parameters\\ServiceDll\n\n```\nvalue is set to point to the RomeoFoxtrot-Two binary on the victim’s machine. A new service group is added to the registry\nunder HKLM\\Software\\Microsoft\\Windows `NT\\CurrentVersion\\SvcHost. The generated service name serves`\nas both the new service group’s name and its only member. The newly generated service is added to the Windows service\ndatabase by calling CreateServiceA which also adds the description of the service. Lastly, ChangeServiceConfig2A\nis called twice, once to add the description of the service and again to establish the behavior of the service in the\nevent of an error (which is to simply restart the service). Finally, IndiaCharlie-Two activates the service by calling\n```\n       StartServiceA (Task #6).\n\n```\nRomeoFoxtrot-Two is a server-mode RAT, and so it requires a listening port on the victim’s machine. In order to allow\nexternally originating network connections, the Windows firewall must be modified by IndiaCharlie-Two to allow\nincoming connections. IndiaCharlie-Two attempts to poke a hole in the victim’s Windows firewall using two methods at\nthe same time (Figure 4-2).\n\n**cmd.exe /c netsh advfirewall firewall add rule name=\"<service’s name>\" dir=in action=allow**\n```\n          service=\"<service’s name>\" enable=yes\n\n```\n**cmd.exe /c netsh firewall addallowedprogram \"c:\\windows\\system32\\svchost.exe -k <service’s**\nname>\" \"<service name>\" enable\n\n**Figure 4-2: Commands used by IndiaCharlie-Two to Open Ports on the Victim’s Firewall**\n\nThe first netsh command allows the service to bind to any port (that is available) and the Windows firewall then allows\nincoming connections to the bound port. This command is specific to Windows versions newer than Windows XP. The\nsecond netsh command appears to attempt to perform the same task to grant service access through the firewall of\nWindows XP computers, but a typo in the command (“addallowedprogram” instead of “add allowedprogram”)\nprevents the command from working.\n\nWhen IndiaCharlie-Two is activated as a service or as a standalone executable, a suicide script is generated and executed\nat the conclusion of the installation process. As with IndiaCharlie-One, the IndiaCharlie-Two binary is expendable and\nshould be removed after execution based on the use of the suicide script. And, as with IndiaCharlie-One, the generation\nand execution of the suicide script occurs whether or not the loading of the RomeoFoxtrot-Two malware is successful.\n\nAn interesting shift in design occurred between April 2015 and late August 2015 with regards to how information leaking\nstrings are addressed. Prior to this, the values for the default service details as well as the strings used to construct the\nfirewall disabling commands are in cleartext in IndiaCharlie-Two samples. But at the same time that the default service\ndetails change, the developers begin encrypting the strings for the default service details as well as the component that\nmake up the firewall deactivation commands. The developers encrypt these important strings by applying a 64-byte XOR\nbuffer to the strings as seen in Figure 4-3.\n\n\n-----\n\n```\n          unsigned char decoderMatrix[64] = {64, 66, 35, 69, 121, 115, 78, 41, 39, 101, 51, 52, 39,\n          52, 55, 103, 65, 69, 101, 89, 111, 112, 106, 121, 94, 101, 98, 64, 89, 61, 66, 55, 69, 39,\n          105, 80, 33, 106, 84, 121, 33, 35, 101, 108, 51, 87, 112, 78, 42, 64, 72, 57, 113, 110, 35,\n          68, 62, 93, 48, 103, 55, 101, 51, 108};\n          for ( i = 0; i < dwLength; ++i )\n           pszString[i] ^= decoderMatrix[i % 64];\n\n```\n**Figure 4-3: IndiaCharlie-Two’s String Decoder Code Snippet**\n\nThe use of such a simple, but effective, encoding scheme is an interesting departure from the use of AES. As a matter\nof fact, the developers completely abandon AES in three known IndiaCharlie-Two samples along with the dynamic API\nloading functionality. IndiaCharlie-Two variants use only a small subset of the API functions that are dynamically loaded,\nand, even then, they are rarely used in place of their imported twins (e.g. CreateFileA from the import table is used\ninstead of the dynamically loaded CreateFileA). The two known samples with incorrect compile dates and the sample\nthat changes the default service detail values all forego the use of dynamic API loading and, as a result, AES encryption. It\nis unclear why these particular samples depart from the form of the other IndiaCharlie-Two variants.\n\n\n-----\n\n### 5. [Installer] IndiaDelta\n\nConsisting of a single known member, IndiaDelta is a simplistic installer responsible for dropping then activating the\nLimaAlfa loader (see Section 14) as well as dropping the WhiskeyCharlie wiper and its command file. While the general\nfunctionality the malware provides is simple (drop files and activate the next stage), the steps are somewhat convoluted.\n\nThe operating mode of IndiaDelta is determined by the number of command line arguments that are supplied to the\nexecutable when it is activated. If there are less than two command line arguments, the program quietly terminates. If\nthere are only two command arguments, IndiaDelta enters the relocation and re-initialization mode. If there are only four\narguments, IndiaDelta enters the installation and activation mode. Any other combination of command line arguments\nresults in IndiaDelta terminating quietly.\n\nBoth of IndiaDelta’s modes begin by dynamically loading API functions. Unlike the majority of other code within the\nLazarus Group’s collection, the dynamic API loading functionality is done without obfuscation of the API names. Rather,\nIndiaDelta performs a series of GetProcAddress calls with very little fanfare.\n\nThe relocation and re-initialization mode is responsible for, as the mode’s description suggests, relocating the IndiaDelta\nbinary to the victim’s %TEMP% directory and re-activating itself from within that location. The task of relocation consists\nof locating the %TEMP% directory on the victim’s machine, deleting any file within that directory that contains the\nsame filename as the currently active IndiaDelta binary, and then copying the original IndiaDelta binary to the victim’s\n```\n       %TEMP% directory. The re-initialization task generates a new set of command line arguments with the following format:\n         /install <name of the original IndiaDelta binary> <original command line arguments>\n\n```\nThe new instance of IndiaDelta is activated by passing the new IndiaDelta’s filename and the new command line to\n```\n       CreateProcess. The original IndiaDelta instance then terminates with the exit code set to 1.\n\n```\nThe installation and activation mode is the workhorse mode of the malware. The mode begins by verifying that the first\ncommand line argument is equal to /install as set by the relocation and re-initialization mode. IndiaDelta’s main thread\ncontinues as a Message Loop[6] to support the unnecessary Windows GUI subsystem that IndiaDelta operates under while\nthe actual installation and activation tasks are spun off into their own thread. The first task this mode performs is to set the\ncurrent working directory to the directory that contained the original IndiaDelta binary (the location of IndiaDelta at the\ntime of the relocation and re-initialization mode). Next, IndiaDelta begins the process of extracting its embedded files to disk.\n\nIndiaDelta stores its embed as a sequence of {header, file data} blocks appended to the end of its own binary image. The\nlast 8 bytes of the IndiaDelta binary contains two 32-bit values, each XOR’d with the 32-byte value 0x1234567 (in little\nendian). The first 32-bit value defines the number of embedded blocks contained within the installer, and the second (or\nlast) 32-bit value defines the offset to the start of the embedded blocks.\n\nEach embedded block contains a header that consists of 20 bytes that define the filename of the embedded file followed\nby a 32-bit value that defines the size of the embedded file image (but not necessarily the final size of the embed). The\n\n[6 Microsoft. “About Messages and Message Queues” https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx Accessed 8 November 2015](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx)\n\n\n-----\n\nembedded file’s image is BZip-compressed, which requires IndiaDelta to decompress each file upon extraction. Figure 5-1\nillustrates the layout of IndiaDelta’s embed stacking scheme.\n\nThe extraction process for each embedded file begins by reading in the header, determining the number of bytes to extract\nfrom the IndiaDelta image, and then saving those bytes (following the header) to the %TEMP% directory with a filename\nthat begins with zz followed by some random digits as generated by a call to GetTempFileNameA. Once the file has\nbeen written to disk, the BZip decompression function is called to inflate the binary and save the newly expanded file to\nthe name specified within the embedded file’s header. The zz file is then securely deleted using a secure deletion function\ncommon to the Lazarus Group.\n\nIndiaDelta’s Binary Image\n\nEmbed’s Filename [20 bytes]\n\nEmbed’s size (in bytes) [DWORD]\n\nEmbed’s File Image (Bzip’d) [variable]\n\nEmbed’s Filename [20 bytes]\n\nEmbed’s size (in bytes) [DWORD]\n\nEmbed’s File Image (Bzip’d) [variable]\n\nEmbed’s Filename [20 bytes]\n\nEmbed’s size (in bytes) [DWORD]\n\nEmbed’s File Image (Bzip’d) [variable]\n\nNum. of Embeds (encoded)[DWORD]\n\nOffset to First Embed (encoded)[DWORD}\n\n**Figure 5-1: IndiaDelta’s Embed Stacking Scheme**\n\n\n-----\n\nOnce all of the embedded files are extracted and decompressed, IndiaDelta enters an infinite loop that only terminates\nafter the secure delete function is able to successfully remove the original IndiaDelta’s file from the victim’s computer.\nEffectively, this is an overly complicated suicide script that doesn’t use a batch file. This is also a key characteristic of\nIndiaDelta and the malware it drops, as each subsequent stage attempts to delete the previous stage.\n\nAt the completion of the installation and activation mode, IndiaDelta attempts to move the first extract file (the LimaAlfa\nbinary) to the same name as the original IndiaDelta. LimaAlfa is then executed by a call to CreateProcess with the\nfollowing command line arguments:\n\n<name of current IndiaDelta binary> <original first argument> <original second argument>\n\nIndiaDelta does not use or care about the contents of the first and second arguments when IndiaDelta is originally called,\nbeyond the fact that arguments are present. Throughout both the relocation and re-initiation mode and the installation and\n_activation mode, the original command line arguments are merely carried forward to the next mode and ultimately the_\nnext stage (LimaAlfa).\n\n\n-----\n\n### 6. [Installer] IndiaEcho\n\nA classic example of open-source code usage, the installer IndiaEcho borrows heavily from the project “Pure WIN32\nSelf-Extract EXE Builder” by the CodeProject user CT Chang,[7] specifically the function ExtractBinaryFile from the\nSetupEx sub-project. While SetupEx uses the Windows GUI interface to provide feedback to the user about the progress\nof installation activities, IndiaEcho provides absolutely no feedback to the victim, given that the task is the installation\nof malware. The developer(s) of IndiaEcho leverage the file extraction technique of SetupEx while foregoing the GUI\ncomponents.\n\nThere are two known variants of IndiaEcho in the wild: IndiaEcho-One and IndiaEcho-Two. IndiaEcho-One is the full-\nfeatured base model, while IndiaEcho-Two greatly simplifies the installation operation. Both variants drop files from their\nrespective payload sections in the same manner, but IndiaEcho-One also installs a Windows service before generating\nand executing a suicide script. In addition to their operational differences, the variants also drop different members of the\nLazarus Group’s malware: IndiaEcho-One drops LimaBravo (see Section 15) and RomeoGolf along with a configuration\nfile, while IndiaEcho-Two drops IndiaBravo-RomeoBravo (see Section 3.1).\n\n7 [CT Chang. “Pure WIN32 Self-Extract EXE Builder”. http://www.codeproject.com/Articles/7053/Pure-WIN-Self-Extract-EXE-Builder 2004 May 16](http://www.codeproject.com/Articles/7053/Pure-WIN-Self-Extract-EXE-Builder)\n\n\n-----\n\n#### 6.1 IndiaEcho-One\n\nIndiaEcho-One loads API functions from kernel32.dll, urlmon.dll, userenv.dll, advapi32.dll,\n```\n       ws2_32.dll, and wininet.dll. If the entirety of the 53 API functions that IndiaEcho-One attempts to load do not\n\n```\nsuccessfully load, IndiaEcho-One generates and executes a suicide script without performing any further operations. Of\nthe 53 API functions that IndiaEcho-One loads, only 7 of the APIs are actively used by the malware; instead, the bulk of\nthe API function calls made by IndiaEcho-One during its operation come from the same API functions loaded as part of\nthe import table load operation when the binary is initially loaded into memory by Windows.\n\nIndiaEcho-One requires two temporary files for the process of extracting the payload components from itself. The\ndeveloper(s) of IndiaEcho-One used the source code verbatim from SetupEx’s ExtractBinaryFile to generate these two\nfilenames and ensure that there are no conflicting files with the same name within the victim’s %TEMP% directory (Figure\n6-1).\n```\n          GetTempPath(sizeof(szWinTmpPath), szWinTmpPath);\n          sprintf(szTmpBinFile1, \"%s%08X\", szWinTmpPath, GetTickCount());\n          sprintf(szTmpBinFile2, \"%s%08X\", szWinTmpPath, (DWORD)(GetTickCount()*12345)/8725);\n          DeleteFile(szTmpBinFile1);\n          DeleteFile(szTmpBinFile2);\n\n```\n**Figure 6-1: SetupEx’s Temporary Filename Generation Code Snippet from ExtractBinaryFile**\n\nIndiaEcho-One stores its payload within the SETUP\\2000 resource entry of its own binary. The contents of the resource\nare written to the szTmpBinFile1 specified path and then read into memory for parsing. With the contents of the\npayload file now in memory, the file from which they originated (specified by szTmpBinFile1) is deleted. The first 268\nbytes of the file specify the number of individual drop files that exist within the payload along with a string. The SetupEx\nproject specifies the format for the first 268 bytes as seen in Figure 6-2 (from the SetupEx source code).\n```\n          typedef struct tagSETUPINFO\n          {\n            DWORD   dwFileCount;\n            char    szAutoExecFile[MAX _ PATH];\n          } SETUPINFO, FAR * LPSETUPINFO;\n\n```\n**Figure 6-2: SetupEx’s SETUPINFO Structure Definition**\n\nThe szAutoExecFile string, while populated, has no purpose in IndiaEcho-One. dwFileCount specifies the number\nof individual drop files that exist within the payload memory structure. There are dwFileCount number of structures\nnamed EXTRACTFILEINFO that define the size, name, and timestamps of the individual files that follow the SETUPINFO\nstructure. The EXTRACTFILEINFO structure is defined as seen in Figure 6-3 (from the SetupEx source code).\n\n\n-----\n\n|Service Name|Mwsagent|\n|---|---|\n|Service Display Name|Mobile Communication Agent Service|\n|Service Description|Allows mobile service to commnicate|\n|Service DLL|Mwsagent.dll|\n\n```\n          typedef struct tagEXTRACTFILEINFO\n          {\n\n```\n**// Running index value of the current file out of the**\n**// total distributed file count.**\n```\n            DWORD      dwIndex;\n\n```\n**// Original file created time.**\n```\n            FILETIME    CreateTime;\n\n```\n**// Original file last read/written time.**\n```\n            FILETIME    LastAcessTime;\n\n```\n**// Original file last written time.**\n```\n            FILETIME    LastWriteTime;\n\n```\n**// Specifies the high-order DWORD value**\n**// of the file size, in bytes.**\n```\n            DWORD      dwFileSizeHigh;\n\n```\n**// Specifies the low-order DWORD**\n**// value of the file size, in bytes.**\n```\n            DWORD      dwFileSizeLow;\n            // A null-terminated string that\n\n```\n**// is the name of the original file.**\n```\n            char      szBinFileName[MAX _ PATH];\n          } EXTRACTFILEINFO, FAR * LPEXTRACTFILEINFO;\n\n```\n**Figure 6-3: SetupEx’s EXTRACTFILEINFO Structure Definition**\n\nIndiaEcho-One uses the EXTRACTFILEINFO structures to extract the individual drop files that follow the last\n```\n       EXTRACTFILEINFO structure. The extraction process for each file begins by generating a filename for the extracted file\n\n```\nbased on the szBinFileName field and placing the file in the %TEMP% directory. IndiaEcho-One modifies the first two\nbytes of the file being extracted if they match JE so that the first bytes become MZ. The extracted file is written to the\nvictim’s hard drive, and its timestamp is set according to the CreateTime, LastAcessTime, and LastWriteTime\nfields from the file’s EXTRACTFILEINFO structure.\n\nAfter extracting and dropping the files within its payload, IndiaEcho-One installs a service to support the extracted\nLimaBravo binary. IndiaEcho-One has an entire service installation subsystem responsible for installing the dropped\nLimaBravo binary as a Windows system service. From the onset, IndiaEcho-One establishes the necessary information to\nestablish a service, with known samples using the values in Table 6-1 to describe the service to install.\n\nService Name Mwsagent\n\nService Display Name Mobile Communication Agent Service\n\nService Description Allows mobile service to commnicate\n\nService DLL Mwsagent.dll\n\n**Table 6-1: Known Service Description Field Values for IndiaEcho-One**\n\n\n-----\n\nBefore the service can be installed, the service DLL must be prepared and relocated. IndiaEcho-One moves the file\nfrom its dropped location in %TEMP% to the %SYSDIR% directory and mimic the timestamp of mspaint.exe. Next, it\ninstalls and activates the service that ensures LimaBravo‘s persistence on the victim’s machine. This task is relatively\nstraightforward:\n\n1. Create a new service group under HKLM\\Software\\Microsoft\\Windows `NT\\CurrentVersion\\Svchost for`\n\nthe new service named Mwsagent\n\n2. Call CreateServiceA to add the new service to the service’s database\n\n3. Call ChangeServiceConfig2A to set the service’s description\n\n4. Create a registry key at HKLM\\SYSTEM\\CurrentControlSet\\services\\Mwsagent\n\n5. Set the Parameter\\ServiceDll value to point to the dropped LimaBravo binary\n\n6. Call StartServiceA to activate the service\n\nNext, IndiaEcho-One attempts to purge itself from the victim’s machine by generating and executing a suicide script. The\nsuicide script (Figure 6-4) is dropped as %TEMP%\\msgl.bat.\n```\n          :Repeat\n          del \"<IndiaEcho-One binary>\"\n          if exist \"<IndiaEcho-One binary>\" goto Repeat\n          del msgl.bat\n\n```\n**Figure 6-4: IndiaEcho-One’s Suicide Script**\n\n\n-----\n\n#### 6.2 IndiaEcho-Two\n\nThe sample set of IndiaEcho-Two is limited to a single observed sample from September 2014. The sample mimics\na screensaver installer called “sunny-leone-II-screensaver Setup File” by dropping both the legitimate\n```\n       install-sunny-leone-II-screensaver.exe executable and an IndiaBravo-RomeoBravo sample.\n\n```\nIndiaEcho-Two, from a structural perspective, has some interesting artifacts not found in the IndiaEcho-One variants.\nThe resource section of binary may contain references to the language used for various text strings found in dialogues\nand file information data. These language identifiers are typically set to match the language of the compiling computer\nor the computer upon which the source code was originally developed. IndiaEcho-Two contains three different language\nidentifiers: the icons within the resource section identify themselves as Dutch, the file information section uses the\nEnglish language, and an unused dialogue box defined within the resource section specifies Korean as its language. The\nlanguage associated with the icons is explainable based on the fact that they are lifted from the Inno Setup installer\nwhich, itself, has the language for the icon specified as Dutch. The English language of the file information section is most\nlikely a product of the fact that the file information was lifted directly from another installer. This only leaves the Korean\nlanguage for the dialogue without an immediately recognizable source outside of the original development machine’s\ndefault language possibly being Korean.\n\nAs IndiaEcho-Two uses the same dynamic API loading function as IndiaEcho-One, IndiaEcho-Two loads the same 53 API\nfunctions. Similarly, if the entirety of the 53 API functions that IndiaEcho-Two attempts to load do not successfully load,\nit silently terminates without performing any further operations, as IndiaEcho-Two does not use a suicide script upon\ntermination. Despite this insistence on dynamically loading API functions, IndiaEcho-Two does not use a single one of\nthe loaded API functions, instead using the same API functions loaded as part of the import table loading operation.\n\nIndiaEcho-Two uses the same file extraction routine found in IndiaEcho-One, with the exception that upon successful\nextraction, regardless of its type, each file to the victim’s hard drive is passed to CreateProcess in an attempt to\nexecute the file. Since the observed IndiaEcho-Two sample only drops the screensaver installer and the IndiaBravo-\nRomeoBravo installer, both of which are standalone executables, simply calling CreateProcess for each of the files is\nby and large one of the simplest methods for activating both components. Calling CreateProcess is a gross deviation\nfrom the SetupEx source code and therefore is a feature, like the JE/MZ substitution, unique to the IndiaEcho (specifically\nIndiaEcho-Two) code base.\n\nSince both dropped files are standalone, executable installers, the need for the service installation component found in\nIndiaEcho-One is no more; as such, IndiaEcho-One’s code for the service installation subsystem has been removed by\nthe developers. Also, given that IndiaEcho-Two is masquerading as a screensaver installer, the use of a suicide script to\ndelete the source file would turn out to be more suspicious than leaving the file in place, so the suicide script component\nof IndiaEcho-One is not found in IndiaEcho-Two. The removal of the service installation subsystem, the suicide script\ngeneration and execution, and the wholesale execution of the dropped files as they are dropped significantly streamlines\nthe code and functionality of IndiaEcho-Two compared to IndiaEcho-One. This makes the inclusion of unnecessary\nartifacts revealing the probable native language of the developer somewhat baffling.\n\n\n-----\n\n|Enables|Allows|Provides|\n|---|---|---|\n|Supports|Monitor||\n\n|Audio Service|Basic CAPI SubSystem|Account Manager|Internet Security|\n|---|---|---|---|\n|Power Manager|Software Licence|Cryptograpic API|System Event Manager|\n|Dialup Networking|Display Manager|Remote Access Protocol|ClamAV Updater|\n|Configuration|Network FileShare|BitLocker Encryption|Secure FileSystem|\n|Windows MediaPlayer||||\n\n\n### 7. [Installer] IndiaFoxtrot\n\nIndiaFoxtrot is an installer that drops, installs, and activates the combination of DeltaBravo and RomeoDelta. Activation\nof IndiaFoxtrot can include 1 or 4 additional command line arguments. If present, the first argument on the command\nmust be -i otherwise IndiaFoxtrot will simply terminate after executing its suicide script.\n\nBefore IndiaFoxtrot begins the installation process, it first verifies that the named mutex\n```\n       Global\\WindowsUpdateTracing0.5 — an indication of an existing RomeoDelta infection — does not exist on the\n\n```\nvictim’s system. After loading only two Windows DLLs (kernel32.dll and advapi32.dll) via a dynamic API loading\nscheme that relies on Space-Dot obfuscation, IndiaFoxtrot loads an encrypted data blob from its own resource section\ninto memory, where it applies a RC4 transformation to decrypt the data blob into the structure payload data.\n\nThe format of the structured payload data is the same as the format for IndiaWhiskey’s payload data (see Section 13), with\nthe exception of the first four bytes. In order to determine if the RC4 transformation resulted in correct decryption, the\nfirst four bytes of the data must equal ZBI followed by a NULL (0) character. For each file found within the structured\npayload data, IndiaFoxtrot writes the file to the %SYSDIR% directory. Any DLL found within the payload data is given a\nrandomized filename, while other file types are given the name described in the file’s payload header.\n\nAfter dropping the files within the payload data, IndiaFoxtrot installs the RomeoDelta DLL as a service. IndiaFoxtrot will\nrandomly construct the name of the service and the service’s description in the same manner as the installer IndiaGolf\n(see Section 8) and, to a lesser degree, IndiaBravo-RomeoBravo (see Section 3.1). IndiaFoxtrot uses randomly selected\nindices into a set of hardcoded strings to construct the service’s name, display name, and description. The three sets of\nhardcoded strings consist of a set of actions (Figure 7-1), a set of targets (Figure 7-2), and a set of descriptions (Figure 7-3).\n\nEnables Allows Provides\n\nSupports Monitor\n\n**Figure 7-1: IndiaFoxtrot’s Service Action Words**\n\nAudio Service Basic CAPI SubSystem Account Manager Internet Security\n\nPower Manager Software Licence Cryptograpic API System Event Manager\n\nDialup Networking Display Manager Remote Access Protocol ClamAV Updater\n\nConfiguration Network FileShare BitLocker Encryption Secure FileSystem\n\nWindows MediaPlayer\n\n**Figure 7-2: IndiaFoxtrot’s Service Targets**\n\nIf this service is stopped, system cannot be well performed\n\nThis service cannot be stopped.\n\nIf this service is disabled, any services that explicitly depend on it will fail to start.\n\n**Figure 7-3: IndiaFoxtrot’s Service Description Framing Strings**\n\n\n-----\n\nThe service name is constructed by selecting one of the target strings. The description is constructed by using the format\n\n<action> <target>.<description>\n\nwhere the <target> is the same as the value used for the service’s name. The description strings are identical to the\ndescription strings found in IndiaGolf.\n\nAfter generating the service information, a new service is constructed by generating new registry entries to make the\nRomeoDelta binary a svchost-based service DLL. With the registry and operating system now configured to treat the\nRomeoDelta binary as a service DLL, IndiaFoxtrot activates the service by calling StartService API function.\n\nIf the file drop or service activation steps fail, IndiaFoxtrot attempts to securely delete any artifacts it may have produced\nbefore calling the suicide script and terminating.\n\nIf IndiaFoxtrot is activated with only the -i command line argument (or activated without any arguments), IndiaFoxtrot\nactivates the DeltaBravo binary by calling CreateProcess after appending -reg to the command line supplied to the\nDeltaBravo binary. Otherwise, if IndiaFoxtort is activated with four additional arguments (including the -i argument),\nDeltaBravo is activated with the following command line arguments:\n```\n             0 <IndiaFoxtrot’s 2[nd] argument> <IndiaFoxtrot’s 3[rd] argument> <IndiaFoxtrot’s 4[th] argument>\n\n```\nOnce IndiaFoxtrot has completed its task, it generates a suicide script named AUTOEXEO.bat. The suicide script is\nexecuted via a call to CreateProcessA, and IndiaFoxtrot silently terminates.\n\n\n-----\n\n|INDIAGOLF VARIANT|PAYLOADS|ACTIVATION EXPORT|\n|---|---|---|\n|IndiaGolf-One|RomeoMike, DeltaAlfa, WhiskeyBravo|StartInstall|\n|IndiaGolf-Two|RomeoMile, DeltaAlfa, WhiskeyBravo, TangoBravo|_gdimain|\n|IndiaGolf-Three|RomeoMike, DeltaAlfa|UICreate|\n\n\n### 8. [Installer] IndiaGolf\n\nObserved as part of the 10 Days of Rain campaign,[8] IndiaGolf is a DLL-based installer responsible for the installation of\ntwo to four pieces of malware and their respective configuration files. There are three observed variants of IndiaGolf;\nthese variants differ primarily only in their payloads and exported activation function names (identified in Table 8-1),\nthough there are some minor functional changes that will be addressed later in this section. All three observed variants\ndrop RomeoMike and DeltaAlfa.\n\n**INDIAGOLF VARIANT** **PAYLOADS** **ACTIVATION EXPORT**\n\nIndiaGolf-One RomeoMike, DeltaAlfa, WhiskeyBravo `StartInstall`\n\nIndiaGolf-Two RomeoMile, DeltaAlfa, WhiskeyBravo, TangoBravo `_gdimain`\n\nIndiaGolf-Three RomeoMike, DeltaAlfa `UICreate`\n\n**Table 8-1: IndiaGolf Variants, Their Payloads and Their Activation Exports**\n\nActivation of IndiaGolf requires a loader that loads the IndiaGolf binary into memory and calls the appropriate export,\nreferred to as the “activation function.” Evidence suggests that LimaDelta (see Section 17) is responsible for these tasks.\nThe connection between LimaDelta and IndiaGolf is assumed based on the following characteristics:\n\n1. The compilation dates for LimaDelta and IndiaGolf samples are within hours or, in some cases, minutes of each other.\n\n2. The LimaDelta samples that have close compilation times to IndiaGolf ones load a binary and call an export with the\n\nsame name as the activation export found in the IndiaGolf samples.\n\n3. The size of the data structure passed from the LimaDelta members from characteristic #2 matches the expected data\n\nstructure for the corresponding IndiaGolf binary.\n\nWhile the particular payload components that the various IndiaGolf variants install may change from variant to variant,\noutside of RomeoMike and DeltaAlfa, a basic design pattern exists for all of the variants. For any payload component that\nrequires a Windows service to exist for the payload to operate, IndiaGolf performs the following tasks:\n\n1. Establish the necessary configuration parameters for the malware being dropped\n\n2. Write the necessary configuration file(s) to the victim’s hard drive using the names specific to the particular piece of\n\nmalware being deployed\n\n3. Decompress the payload image using a Zlib library\n\n4. Generate the parameters that define the service for the payload malware\n\n5. Install and activate the service for the payload malware\n\nThe activation function takes a single parameter: a memory pointer containing the configuration necessary for MikeRomeo.\nOnce called, the activation function passes control to an installation function, which uses the memory pointer not only as the\nconfiguration for the RomeoMike component to be installed, but as an indicator for if the RomeoMike component should be\ndropped at all. In order for IndiaGolf to drop, install, and activate RomeoMike, the memory pointer must not be NULL.\n\n8 Ten Days of Rain: Expert analysis of distributed denial-of-service attacks targeting South Korea.” McAfee. 2011. http://www.mcafee.com/us/resources/white-papers/wp-10-days-of-rain.pdf\n\n\n-----\n\n|Provides|Manages|Retrieves|Monitors|\n|---|---|---|---|\n|Enables|Configures|Adds|Manages|\n|Detects|Supports|Maintains|Creates|\n|Allows|Transmits|Creates|Contains|\n\n|Storage protect|Application information|Wmi adapter|Efficent game controler|\n|---|---|---|---|\n|Removal stoarage|Com library|Mpeg adapter|Comfortable game controler|\n|Account information|Distributed Link Tracking Client|Vga adapter|Comfortable Desktop Controler|\n|Remote user|Cryptograpic file|Wireless protection|Beautiful Background Color|\n|Remote account|Network account|DNS resolve|Beautiful Windows background|\n|System information|Logon information|Security Account|DNS Security controler|\n|Security inforamion|Security catalog|Security Inernet Bank|Media security container|\n\n\nUnderstanding the installation and activation process for RomeoMike is necessary in order to understand how additional\npayload components are installed and activated. The installation of RomeoMike begins (Task #1) by first establishing a\n64-bit identification number for the victim’s machine. The identification number will come from one of two places: if\n```\n       GetAdaptersInfo returns a valid result, the identification number is calculated as the 6-byte MAC address of the first\n\n```\nNIC plus 4 bytes from rand or, failing the API call, the concatenation of four rand calls. The configuration file is stored\nas %SYSDIR%\\faultrep.dat. It should be noted that the name of the configuration file is stored in plaintext within\nIndiaGolf despite the same string being encrypted with AES within RomeoMike. Before the configuration is dropped\nto disk (Task #2), the directory hierarchy verification and generation function found in many of the Lazarus Group’s\nmalware samples is used to ensure that the path exists (although, given it is %SYSDIR%, it should clearly already exist).\nOnce the file is written to disk, a randomly generated timestamp is applied to the file.\n\nThe RomeoMike binary is stored within the .data segment of IndiaGolf as a Zlib compressed byte array. To extract the\nbinary (Task #3), a memory buffer is allocated on the heap and passed to a Zlib decompression routine along with the\nexpected size of the file after decompression, the compressed byte array, and the size of the compressed byte array. If\nsuccessfully decompressed, the RomeoMike image is housed within the previously allocated heap memory buffer.\n\nRomeoMike requires that it run as a service DLL. IndiaGolf accommodates this requirement by first establishing the basic\ninformation for RomeoMike’s new service (Task #4). The generation of the service name, the service’s display name, the\nservice description, and the name of the RomeoMike DLL is done using a set of randomly generated indices into an array\nof hardcoded values in much the same way that IndiaBravo-RomeoBravo (see Section 3.1) generates service information.\nThe service information generator contains three different arrays—one array of actions (Figure 8-1), one array of service\ntargets (Figure 8-2), and one array of description framing strings (Figure 8-3).\n\nProvides Manages Retrieves Monitors\n\nEnables Configures Adds Manages\n\nDetects Supports Maintains Creates\n\nAllows Transmits Creates Contains\n\n**Figure 8-1: IndiaGolf’s Service Action Words**\n\nStorage protect Application information Wmi adapter Efficent game controler\n\nRemoval stoarage Com library Mpeg adapter Comfortable game controler\n\nAccount information Distributed Link Tracking Client Vga adapter Comfortable Desktop Controler\n\nRemote user Cryptograpic file Wireless protection Beautiful Background Color\n\nRemote account Network account DNS resolve Beautiful Windows background\n\nSystem information Logon information Security Account DNS Security controler\n\nSecurity inforamion Security catalog Security Inernet Bank Media security container\n\n**Figure 8-2: IndiaGolf’s Service Targets**\n\nIf this service is stopped, system cannot be well performed\n\nThis service cannot be stopped.\n\nIf this service is disabled, any services that explicitly depend on it will fail to start.\n\n**Figure 8-3: IndiaGolf’s Service Description Framing Strings**\n\nTo generate the service information, one entry from each of the three arrays is selected at random and applied to the\npatterns identified in Table 8-2. While the methodology around generating seemingly random but realistic service\n\n\n-----\n\n|FIELD|PATTERN|\n|---|---|\n|Service Display Name|{Service Target String} Service|\n|Service Description|{Action Word} {Service Target String}. {Framing String}|\n|Service Name|{4 random characters from service description}svc|\n|Service DLL Filename|%SYSDIR%\\{Service Name}.dll|\n\n\ninformation is largely sound, the high number of spelling errors in the service target strings makes the services much\nmore obvious, even to a novice system administrator. It is unclear why the developer(s) of IndiaGolf did not bother to spell\ncheck their work.\n\n**FIELD** **PATTERN**\n\nService Display Name {Service Target String} Service\n\nService Description {Action Word} {Service Target String}. {Framing String}\n\nService Name {4 random characters from service description}svc\n\nService DLL Filename %SYSDIR%\\{Service Name}.dll\n\n**Table 8-2: IndiaGolf’s Service Information Generation Patterns**\n\nAfter generating the service information, the RomeoMike image is written to disk and given a randomized timestamp.\nThe service is then established (Task #5) by performing the following step:\n\n1. Create a new service group under HKLM\\Software\\Microsoft\\Windows `NT\\CurrentVersion\\Svchost for`\n\nthe new service\n\n2. Call CreateServiceA to add the new service to the services database\n\n3. Call ChangeServiceConfig2A to set the service’s description\n\n4. Create a registry key at HKLM\\SYSTEM\\CurrentControlSet\\services\\<name of new service>\n\n5. Set Parameter\\ServiceDll value appropriately\n\n6. Call StartServiceA to activate the service\n\nFollowing the installation and activation of RomeoMike, IndiaGolf will repeat the tasks again to drop, install, and activate\nDeltaAlfa. The only different between the installation and activation of DeltaAlfa in comparison to RomeoMike is the\neffort required to install the two necessary configuration files for DeltaAlfa (Task #1): an attack activation configuration\nand an attack targeting configuration. IndiaGolf supplies both of the configuration files. The attack targeting\nconfiguration is dropped (in its encrypted form) from a memory buffer within IndiaGolf’s .data section while the attack\nactivation configuration is potentially modified prior to being dropped. If the current time is later than the hardcoded\nDeltaAlfa activation time, then the activation is adjusted to one day after the installation date. In other words, if the\nactivation time specified within IndiaGolf were March 6, 2011 at 9:30 AM, and IndiaGolf were executed on October 8, 2015\nat noon, IndiaGolf would supply DeltaAlfa with an attack activation configuration specifying October 9, 2015 at noon. For\neach of the DeltaAlfa configuration files that IndiaGolf drops, IndiaGolf generates a new randomized timestamp to assign\nto the files.\n\nDepending on the particular files that an IndiaGolf variant may drop, the tasks for dropping the configuration,\ndecompressing the binary to drop, and installing another service with newly generated service details is repeated for\neach file that is dropped. Once all of the files that the IndiaGolf variant is tasked by the developer(s) to drop have been\nsuccessfully installed and activated, IndiaGolf’s activation function will return and thus terminate the activity associated\nwith IndiaGolf.\n\n\n-----\n\n#### 8.1 IndiaGolf-One\n\nThe activation function (which is exported as StartInstall) of IndiaGolf-One contains additional functionality\nbesides simply calling the installation function. The first operation that IndiaGolf-One performs is the modification\nof the victim’s %SYSDIR%\\drivers\\etc\\hosts file in exactly the same way that TangoBravo performs the task. In\naddition, the functions within IndiaGolf-One responsible for the modification of the hosts file are the same as those\nfound in TangoBravo, indicating that TangoBravo may simply be an offshoot of IndiaGolf-One. The targeted domains\nfound in IndiaGolf-One are a subset of the targeted domains found in TangoBravo:\n\n         - explicitupdate.alyac.co.kr\n\n        - gms.ahnlab.com\n\n         - ko-kr.albn.altools.com\n\n         - ko-kr.alupdatealyac.altools.com\n\n        - su.ahnlab.com\n\n        - su3.ahnlab.com\n\n        - update.ahnlab.com\n\n         - ahnlab.nefficient.co.kr\n\nIndiaGolf-One drops three different malware families in the following order: RomeoMike, DeltaAlfa, and\nWhiskeyBravo-One. The task of dropping RomeoMike and DeltaAlfa occurs in the manner described previously.\nLikewise, the task of dropping, installing, and activating WhiskeyBravo-One follows the same pattern as the RomeoMike\nand DeltaAlfa installation and activation. IndiaGolf generates the configuration of WhiskeyBravo-One by setting the\ninstallation time field (offset 0) to the current system time on the victim’s machine in VARIANTTIME form and the\nactivation delay (offset 8) to 7 days.\n\nIndiaGolf-One generates and executes a suicide script after its tasks are completed. The suicide script generation uses\n```\n       fprintf to write the entire script to disk as d.bat in the current working directory of IndiaGolf-One before calling\n       CreateProcess to execute the script. The following code fragment illustrates the method of suicide script generation\n\n```\nand type of suicide script generated for IndiaGolf-One:\n```\n          fp = fopen(\"d.bat\", \"w+\");\n          if ( fp )\n          {\n           fprintf(fp, \":R\\nIF NOT EXIST %s GOTO E\\ndel /a %s\\nGOTO R\\n:E\\ndel /a d.bat\", \"%1\",\n          \"%1\");\n           fclose(fp);\n           sprintf(cmdLine, \"d.bat \\\"%s\\\"\", szIndiaGolfFilename);\n           CreateProcessA(0, cmdLine, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo,\n          &ProcessInformation);\n          }\n\n```\n**Figure 8-4: IndiaGolf-One’s Suicide Script Generation and Execution Code**\n\n\n-----\n\n#### 8.2 IndiaGolf-Two\n\nIndiaGolf-Two is nearly identical to IndiaGolf-One with the exceptions that IndiaGolf-Two replaces the\n```\n       %SYSDIR%\\drivers\\etc\\hosts file modification function with a dropped TangoBravo executable and the activation\n\n```\nfunction is exported as _gdimain. The TangoBravo executable is stored in the .data section of IndiaGolf and written\nto disk as %SYSDIR%\\rtdrvupr.exe with a randomly generate timestamp. IndiaGolf-Two activates the dropped\nTangoBravo by calling WinExec.\n\n#### 8.3 IndiaGolf-Three\n\nIndiaGolf-Three significantly streamlines the number of operations it performs. The activation function, exported as\n```\n       UICreate, does not drop TangoBravo nor WhiskeyBravo. Instead, IndiaGolf-Three only drops the RomeoMike and\n\n```\nDeltaAlfa payloads as described previously. IndiaGolf-Three forgoes the generation and execution of a suicide script. Instead,\nonce the installation task completes, IndiaGolf-Three merely returns control to the caller of the activation function.\n\n\n-----\n\n### 9. [Installer] IndiaHotel\n\nObserved as part of the SierraJuliett-MikeOne pushed commands, IndiaHotel is an installer that primarily installs\nIndiaIndia binaries and, in one known sample, also installs RomeoWhiskey. IndiaHotel uses a file storage format similar to\nthat of IndiaDelta (see Section 5), which involves appending the file(s) to drop at the end of the IndiaHotel binary.\n\nUpon activation, IndiaHotel, which is a standalone executable, begins by locating the end of its own binary and reading\nthe last four bytes as a DWORD value. The value indicates the number of files that IndiaHotel contains. For each file, the\nextraction process consists of the following operations:\n\n1. Read the previous four bytes as a DWORD to determine the size of the string containing the drop file’s filename\n\n2. Read the filename into memory\n\n3. Read the four bytes immediately before the filename as a DWORD to determine the size of the drop file\n\n4. Read the four bytes immediately before the file size field as a DWORD to determine the location of the start of the\n\ndrop file. The DWORD expresses the number of bytes from the beginning of the file.\n\n5. Read the drop file into memory and decompress the file with Zlib.\n\nThe IndiaHotel sample that is responsible for dropping RomeoWhiskey also generates a new service to support the\ndropped malware. This behavior consists of generating a new service name, service display name, and service description\nbased on artifacts from existing services on the victim’s computer. IndiaHotel then generates a set of registry entries in\norder to install the RomeoWhiskey as a svchost-based service on the victim’s computer.\n\nActivation of IndiaHotel’s payload varies depending on the particular malware family that the installer drops. For\nthe observed sample installing RomeoWhiskey, the malware activates the newly installed service via the Windows\nServices API. For variants installing IndiaIndia, the DLL of the malware is loaded into memory and executed via a call to\n```\n       LoadLibrary.\n\n```\nAfter dropping and activating the payload, IndiaHotel generates and executes a suicide script named either tsc.bat (for\nthe RomeoWhiskey installer) or dvi.bat (for the IndiaIndia installer).\n\n\n-----\n\n### 10. [Installer] IndiaIndia\n\nObserved as the payload of IndiaHotel, IndiaIndia is an installer that uses the same method of encapsulating payload files\nas IndiaHotel, but it also boasts the ability to report to a C2 information about the infected computer. Structured as a\nDLL, IndiaIndia begins executing its core functionality as soon as the loading binary (e.g. IndiaHotel) loads the DLL and\nactivates the DllMain function.\n\nIndiaIndia performs the following set of tasks before terminating:\n\n1. Dynamically load API functions\n\n2. Generate a name for the configuration file\n\n3. Generate information about the victim’s system and report the information to the C2 server\n\n4. Drop the configuration file (using the name specified in Task #2)\n\n5. Install a service for the malicious binary being dropped\n\n6. Drop the malicious binary (IndiaKilo)\n\n7. Tie the newly installed service to svchost as a subservice\n\n8. Activate the new service\n\n9. Generate and execute a suicide script to clean up the IndiaIndia artifacts\n\nNovetta observed IndiaHotel dropping a file with the name dvpi.dna alongside IndiaIndia. The file is the configuration,\nin plaintext, for both IndiaIndia and IndiaKilo. The data within the configuration is eventually saved to the victim’s\nmachine (Task 4) in an encrypted form (using a currently unidentified encryption scheme) and saved to a filename that\nis specific to the victim’s machine. Task 2 generates a 6-character filename with a 3-character extension. The filename\nand its extension consist solely of lowercase letters that are randomly selected using the rand function. Prior to the\ngeneration of the filename, however, IndiaIndia calls srand to seed the pseudorandom number generator (PRNG)\nwith the value of the primary hard drive’s serial number. The effect of calling of srand with a repeatable seed value\nis that the output of rand becomes predictable and repeatable itself. IndiaKilo uses the same method for generating\nits configuration file’s filename, thereby locking an infection resulting from IndiaIndia to a specific machine or, more\nprecisely, a specific hard drive.\n\nUsing one of the 10 C2 server addresses found within the configuration file, IndiaIndia reports its activation to the C2\nserver. IndiaIndia also reports details regarding the victim’s system along with a full list of the processes that are running\non a victim’s system, the filename of the executables responsible for each running process, and the title of the window for\neach running process. IndiaIndia gathers the following specific pieces of information about a victim’s system:\n\n       - Computer name\n\n         - Infected user’s username\n\n        - Windows OS version information (in a OSVERSIONINFOEXA structure)\n\n        - CPU information\n\n         - Locale information\n\n         - First network interface card’s (NIC’s) configuration including IP address, gateways, subnet mask, DHCP information\n\nand if WINS is available.\n\n\n-----\n\n         - Serial number and file system type of the primary hard drive\n\n         - Victim’s local time\n\n         - If any of the following applications are present on the victim’s machine based on registry keys within HKCU and\n```\n         HKLM: SecureCRT, Terminal Services, RealVNC, TightVNC, UltraVNC, Radmin, mRemote, TeamViewer, FileZilla,\n\n```\npcAnyware, Remote Desktop.\n\nThe list of processes (along with their related information) and the information that IndiaIndia gathers about a victim’s\nsystem are saved together in a single file located in the %TEMP% directory before being compressed with Zlib, encrypted,\nand uploaded to one of the 10 C2 servers.\n\nCommunication between IndiaIndia and one of its configured C2 server begins by IndiaIndia randomly selecting from\nthe list of 10 possible C2 servers. If a connection to the first selected C2 server fails, IndiaIndia waits 2 minutes before\nattempting to try to connect to another randomly selected C2 server. After a successful connection to a C2 server,\nIndiaIndia performs a handshake to establish a communication channel between itself and the C2 server. The handshake\nconsists of generating a random buffer, calculating the CRC32 value of the buffer, further encrypting the buffer using\na series of XOR operations, and then transmitting the size of the buffer, the buffer itself (prior to encryption), and the\nCRC32 value of the unencrypted buffer. If the C2 server responses with the CRC32 value of the encrypted buffer, the\nhandshake is successful. The unencrypted buffer’s contents become the encryption key for all future communication\nbetween the C2 server and IndiaIndia.\n\nAfter the transmission of the victim’s system information file to the C2 server, the C2 server responds with a 64-bit value\nrepresenting the unique identifier for the victim’s machine. The uploaded file is deleted using a secure deletion function\nthat simply overwrites the contents with random data prior to calling the DeleteFile API. The unique identifier is\nconverted to a string by means of the ui64toa function and used as the name for a named mutex. The named mutex is\nused by IndiaIndia, and later IndiaKilo, to determine exclusivity on the victim’s machine.\n\nTask #5 establishes a service for the binary that IndiaIndia ultimately drops by generating a service name, display\nname, and description by combing through the list of existing services and randomly picking components of the service\ndescription. With the service information generated, Task 5 calls CreateService to generate a new service with the\npath to the service’s binary set to %SystemRoot%\\system32\\svchost.exe -k <name of service>.\n\nAs mentioned previously, IndiaIndia uses the exact same method and format for embedding binaries within itself. Novetta\nonly observed IndiaIndia dropped IndiaKilo binaries, but the framework is generic enough to allow IndiaIndia to drop\nany binary that operates as a svchost-based service. Task 6 is responsible for dropping the embedded payload binary to the\nvictim’s machine.\n\nWhile IndiaIndia has already installed a new service for the dropped binary (Task 5), it is still necessary to establish\nregistry keys to support the service and tie it together with svchost.exe. Task 7 performs this operation by generating\na new service entry under HKLM\\SYSTEM\\CurrentControlSet\\Services\\<name of service>. The registry entry\ncontains the path to the dropped binary (from Task 6) and little more else.\n\nWith the payload (IndiaKilo) dropped and the service configured, the remaining task for IndiaIndia prior to clean up is the\nactivation of the payload binary on the victim’s computer. IndiaIndia calls StartService to activate the newly installed\nservice and thereby activate the next step of the infection.\n\nThe final act of IndiaIndia is the generation and execution of a suicide script named dvi.bat. IndiaIndia generates the\nsuicide script using a single wsprintfA call with the format string seen in Figure 10-1. The suicide script and its method\nof generation is identical to that found employed by IndiaHotel.\n```\n          @echo off\\r\\n:L1\\r\\ndel /a \\\"%s\\\"\\r\\nif exist \\\"%s\\\" goto L1\\r\\ndel /a \\\"%s\\\"\\r\\n\n\n```\n**Figure 10-1: wsprintfA Format String used to Generate IndiaIndia’s Suicide Script**\n\n\n-----\n\n### 11. [Installer] IndiaJuliett\n\nIndiaJuliett is a simplistic installer observed dropping and installing SierraJuliett-MarkOne, SierraJuliett-MarkOne along\nwith SierraBravo, and SierraJuliett-MarkTwo. IndiaJuliett’s structure is reminiscent of the structure of IndiaWhiskey-\nThree (see Section 13.3), in that the WinMain contains only a single function call to DialogBoxParamA. The core of\nIndiaJuliett’s functionality exists within the dialogue callback function that DialogBoxParamA invokes.\n\nThe malware installed by IndiaJuliett resides in the resource section of the IndiaJuliett binary. Depending on the\nparticular sample, the embedded malware may be encrypted using RC4. In order to properly decrypt the embedded files,\nIndiaJuliett decrypts the files in blocks of 5120 or 10240 bytes (depending on the sample). The S-Box of the RC4 decryption\nsystem is reset using the password cdefghijkl before decrypting each block.\n\nPrior to installing a service for the SierraJuliett-based malware or the SierraBravo malware, IndiaJuliett will attempt to\nstop and delete the existing services related to the malware families (SCardPrv or wuaserv for the SierraJuliett malware\nand Wmmvsvc for the SierraBravo malware). While other India families more commonly attempt to directly modify the\nvictim’s registry to install a new service, IndiaJuliett utilizes the Windows Services API function CreateServiceA to\ncreate a new service for its payload malware before calling StartService to activate the malware.\n\nThe configuration data, with special attention on the initial peer seed list data, of the SierraJuliett malware families is\nhardcoded into the IndiaJuliett binary. This requires the developer(s) of IndiaJuliett to recompile the malware each time a\nnew seed list is required.\n\nSome variants of IndiaJuliett attempts to disable the victim’s firewall prior to the installation of the malware payload(s).\nIndiaJuliett does this by setting the registry key HKEY_ LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\\n**Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\EnableFirewall to 0.**\n\nAfter the installation process concludes, IndiaJuliett will generate and execute a suicide script saved as d.bat.\n\n\n-----\n\n### 12. [Installer] IndiaKilo\n\nDropped by IndiaIndia, IndiaKilo is a repeatable installer that requires a C2 server to download new binaries at regular\nintervals. The categorization of IndiaKilo as an installer (an India) and not a RAT (a Romeo) is somewhat problematic.\nIndiaKilo could conceivably be considered an extremely lightweight RAT due solely to the fact that the C2 determines\nwhether or not IndiaKilo is to download and execute a file - this differs from the usual case of a downloader/installer, where\nthe determination is an inherent certainty. However, given that the only real operation that IndiaKilo performs is the\ndownloading and executing of a specified file from the C2 server, the classification of IndiaKilo as an India is the best fit.\n\nIndiaKilo operates as service DLL, and, after establishing the necessary environment to behave as a legitimate service,\nspawns a new thread for the execution of its core functionality. After initializing the Windows Winsock subsystem,\nIndiaKilo enters an infinite loop where the following tasks play out over and over again:\n\n1. Determine the machine-specific filename for the configuration file and load the configuration into memory\n\n2. Verify if only one instance of IndiaKilo is active\n\n3. Verify that a preconfigured number of minutes has elapsed since the last communication with a C2 server occurred\n\n4. Connect to one of the C2 servers found within the configuration\n\n5. Generate information about the currently active processes on the victim’s machine and save the information to a\n\ntemporary file\n\n6. Encrypt the process information file and upload the encrypted file to the C2 server\n\n7. Delete the process information file\n\n8. Receive a status command from the C2 server\n\n9. If the status indicates a new set of files are available, download and execute the files\n\n10. Reply to the C2 server with status of download and execution operation\n\n11. Update the last C2 server contact time and save the current configuration to disk\n\n12. Loop to Task 1\n\nIndiaKilo uses the same configuration file as IndiaIndia which also requires IndiaKilo to generate the same configuration\nname in Task 1. The configuration file’s filename is used not only for the name of the configuration file but also for\nthe basis of the name of the named mutex that determines exclusivity on the victim’s machine (Task 2). If either the\nconfiguration fails to load or another named mutex with the configuration file’s filename exists, IndiaKilo terminates its\ncore functionality thread, leaving only the shell of the service running.\n\nThe configuration file (Table 12-1) contains a wait time that determines how long IndiaKilo waits between successful C2\nserver contacts. IndiaKilo sleeps in one second intervals until the time since the last C2 server contact and the current\ntime exceeds the wait time.\n\n\n-----\n\n|Offset|Size|Description|\n|---|---|---|\n|0|4 bytes (DWORD)|IP address|\n|4|2 bytes (WORD)|Port|\n|6|2 bytes|not used|\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|8 bytes|Victim Identifier|\n|8|4 bytes (DWORD)|unused by IndiaKilo (used by IndiaIndia)|\n|12|4 bytes (DWORD)|unused by IndiaKilo (used by IndiaIndia)|\n|16|4 bytes (DWORD)|Wait time between C2 server contacts (in minutes)|\n|20|4 bytes (DWORD)|Last C2 server contact time (in time() form)|\n|24|80 bytes|Array of 10 C2 server entries with each entry having the following format: Offset Size Description 0 4 bytes (DWORD) IP address 4 2 bytes (WORD) Port 6 2 bytes not used|\n\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 8 bytes Victim Identifier\n\n8 4 bytes (DWORD) unused by IndiaKilo (used by IndiaIndia)\n\n12 4 bytes (DWORD) unused by IndiaKilo (used by IndiaIndia)\n\n16 4 bytes (DWORD) Wait time between C2 server contacts (in minutes)\n\n20 4 bytes (DWORD) Last C2 server contact time (in time() form)\n\nArray of 10 C2 server entries with each entry having the following format:\n\nOffset Size Description\n\n24 80 bytes 0 4 bytes (DWORD) IP address\n\n4 2 bytes (WORD) Port\n\n6 2 bytes not used\n\n**Table 12-1: Configuration File Structure of IndiaIndia and IndiaKilo**\n\nIndiaKilo uses the same C2 selection and connection procedure and protocol as IndiaIndia for Task #4. The code between\nIndiaKilo and IndiaIndia for the C2 server connection task is identical. The generation of process information, however,\ndiffers slightly between IndiaKilo and IndiaIndia. A notable difference is the inclusion of debugger and VM detection:\nIndiaKilo calls IsDebuggerPresent to determine if a debugger is attached to its process and attempts to open a handle\nto the events VMwareUserManagerEvent and VBoxHookNotifyEvent to determine if the malware is running in a\nVM. The detection of a VM environment or a debugger does not directly alter the flow of execution inside IndiaKilo, but\nthe information is stored within the process list file the malware generates (Task 5) and then encrypts before sending to\nthe C2 server (Task 6).\n\nAfter deleting the process information file (Task 7), IndiaKilo receives a 4-byte status response from the C2 server\nindicating if additional data is to follow (Task #8). If the status value is set to 4, then the C2 server transmits two files,\nwhich IndiaKilo saves in the %TEMP% directory with filenames beginning with TS. After downloading and decrypting the\ntwo files to the victim’s hard drive, IndiaKilo activates the first binary with the following command line (Task 9):\n\n<first file received> <second file received> <unique identifier for victim’s infection>\n\nAfter executing the command, IndiaKilo responds to the C2 server with a 4-byte value (DWORD) of 4 for a successful\nlaunch of the command or 3 for a failure (Task #10). In the event that the files failed to execute, the two downloaded files\nare securely deleted by IndiaGolf by overwriting their contents with random bytes before deleting them from the victim’s\nhard drive.\n\nThe connection between the C2 server and IndiaKilo terminates after the status update is transmitted and the last C2\nserver contact time is updated in the configuration in memory. The configuration in memory is then encrypted and saved\nto disk (Task #11).\n\n\n-----\n\n|ITEM|DEFAULT VALUE|\n|---|---|\n|Service Name|Windows Security|\n|Service Display Name|Windows Security|\n|Service DLL’s Filename|winsec.dll, rdmgr.dll or winauc.dll|\n|Configuration File’s Filename|dayipmr.tbl|\n\n\n### 13. [Installer] IndiaWhiskey\n\nThe principal installer for the RomeoWhiskey malware, IndiaWhiskey is a simple installer that, over the course of its\nlifespan, has used three different scaffolding codes to execute the same core installation process, resulting in three\ndistinguishable variants (IndiaWhiskey-One, IndiaWhiskey-Two, and IndiaWhiskey-Three). It is unclear the developer(s)’s\nmotivation for the scaffolding code changes for IndiaWhiskey, but regardless the core set of tasks remains the same:\n\n1. Dynamically load API functions\n\n2. Establish service information (filename, name, and display name)\n\n3. Drop the payload file(s) to the victim’s hard drive\n\n4. Install the Windows service that loads the RomeoWhiskey malware\n\n5. Activate the Windows service\n\n6. Generate and execute a suicide script\n\n7. Terminate\n\nIndiaWhiskey uses the Lazarus Group’s standard Space-Dot encoding scheme to obfuscate the names of the API functions\nthat it dynamically loads. In the same subroutine that loads the kernel32.dll API functions, IndiaWhiskey establishes\nthe name, display name, DLL filename, and configuration filename. The generation of service and file names do not\nuse Space-Dot encoding but rather are constructed using stack strings (the method by which a string is generated one\ncharacter at a time in a function’s stack) in order to prevent the strings from being visible. The default values for the\ngenerated names is provided in Table 13-1.\n\n**ITEM** **DEFAULT VALUE**\n\nService Name Windows Security\n\nService Display Name Windows Security\n\nService DLL’s Filename winsec.dll, rdmgr.dll or winauc.dll\n\nConfiguration File’s Filename dayipmr.tbl\n\n**Table 13-1: IndiaWhiskey’s Default Service and File Names**\n\nIndiaWhiskey stores its payload files within the resource section of its binary. Stored in either the resource section\n```\n       RT_BITMAP\\1033 (IndiaWhiskey-One and IndiaWhiskey-Three) or IMG\\159 (IndiaWhiskey-Two), the payload data blob\n\n```\nis encrypted using the DNSCALC-style encoding. The payload data blob is a collection of one or more files, each with their\nown header providing the desired filename for the file. Before parsing the payload data blob, IndiaWhiskey first verifies\nthat the decryption of the data blob was successful by determining if the decrypted data blob’s first four bytes are BMZA\n(IndiaWhiskey-One, IndiaWhiskey-Three) or the first two bytes are BM (IndiaWhiskey-Two). If the magic value does not\nmatch the expected value, the installer will skip to Task 6.\n\nThere is one notable deviation from the above described payload file storage method. A single version of IndiaWhiskey-One\nembeds its payload data blob within its .data segment, not within a resource. The BMZA magic bytes are not present in this\nvariant, and instead XADD is used to determine if the DNSCALC-style encoding was successfully removed.\n\n\n-----\n\nWith the integrity of the payload data blob verified, IndiaWhiskey begins the process of extracting the various payload\nfiles. Each file within the payload data blob begins with a header that defines the length of the filename for the file as\na 16-bit value, the filename, and a 32-bit value representing the size of the file itself. Immediately following the file’s\ninformation header is the file image itself. Figure 13-1 provides a visual illustration of how IndiaWhiskey stores files within\nits payload data blob. The payload data blob does not include any information that determines the number of files that it\nincludes; instead IndiaWhiskey continues to extract files until it reaches the end of the payload data blob. This approach\ncould allow a bad resource to result in erroneous output.\n\nFilename Length (2 Bytes)\n\nMagic Value (BM or BMZA)\n\nFilename (variable)\n\nFile Header\n\nFile Size (4 Bytes)\n\nFile Image\n\nFile Header\n\nFile Image\n\n**Figure 13-1: IndiaWhiskey’s Payload File Storage Format**\n\nIndiaWhiskey stores each file in the same directory as kernel32.dll– the %SYSDIR% directory. For each file that\nIndiaWhiskey extracts to disk, the installer first determines if a file with the same name exists, and, if so, it deletes the\nfile to make way for the extracted file. After writing the extracted file to disk, IndiaWhiskey alters the timestamp of the\nextracted file to match the timestamp of kernel32.dll in order to avoid drawing attention to the new addition.\n\nWith the RomeoWhiskey file dropped to disk, IndiaWhiskey must install and activate the service that ensures the\nmalware’s persistence, which is a relatively straightforward task:\n\n1. Call CreateServiceA to add the new service to the service’s database\n\n2. Call ChangeServiceConfig2A to set the service’s description\n\n3. Create a registry key at HKLM\\SYSTEM\\CurrentControlSet\\services\\<name of new service>\n\n4. Set the Parameter\\ServiceDll value appropriately to point to the dropped RomeoWhiskey binary\n\n5. Create a new service group under HKLM\\Software\\Microsoft\\Windows `NT\\CurrentVersion\\Svchost for`\n\nthe new service\n\n6. Call StartServiceA to activate the service\n\n\n-----\n\n|VARIANT|SERVICE DESCRIPTION VALUE|\n|---|---|\n|IndiaWhiskey-One|Allows reporting for windows services and applictions running in standard environments. If this service is disabled, any services that explicitly depend on it will fail to start.|\n|IndiaWhiskey-Two|Track system status such as Windows logon, network, and power events. Notifiy COM+ Event System subscribers of these events.|\n|IndiaWhiskey-Three|Allows reporting for windows services and applictions running in standard environments. If this service is disabled, any services that explicitly depend on it will fail to start.|\n\n\nThe description of the new service is variant-dependent, and, interestingly, the observed samples each have a misspelling\nas shown in Table 13-2 in bold.\n\n**VARIANT** **SERVICE DESCRIPTION VALUE**\n\nAllows reporting for windows services and applictions running in standard environments. If\nIndiaWhiskey-One\nthis service is disabled, any services that explicitly depend on it will fail to start.\n\nTrack system status such as Windows logon, network, and power events. Notifiy COM+\nIndiaWhiskey-Two\nEvent System subscribers of these events.\n\nAllows reporting for windows services and applictions running in standard environments. If\nIndiaWhiskey-Three\nthis service is disabled, any services that explicitly depend on it will fail to start.\n\n**Table 13-2: IndiaWhiskey Variants’ Service Description Values with Misspelled Highlighted in Bold**\n\nIndiaWhiskey concludes its life by generating and then executing a suicide script, saved as msvcrt.bat. An interesting\nartifact is the msvcrt.bat string: IndiaWhiskey-One and IndiaWhiskey-Three variants contain the string within the\nbinary’s .data section, while IndiaWhiskey-Two constructs the string using stack strings. This is yet another example\nof the subtle differences between variants. Although IndiaWhiskey-Two appears to exist between IndiaWhiskey-One\nand IndiaWhiskey-Three, chronologically speaking, these changes may indicate that at least two different developers\ngenerated the IndiaWhiskey variants. As mentioned previously, while it is the scaffolding code that truly differentiates the\nIndiaWhiskey variants, these subtle code and text changes may point to the existence of more than one active user of the\nIndiaWhiskey code base.\n\n\n-----\n\n#### 13.1 IndiaWhiskey-One\n\nOf the IndiaWhiskey variants, IndiaWhiskey-One is by far the most simplistic when tracing the execution of the\ninstaller. Given that it contains no unnecessary code, and in fact contains no scaffolding code at all, it is arguable that\nIndiaWhiskey-One is the baseline for the IndiaWhiskey family. The WinMain function for IndiaWhiskey-One, Figure\n13-2, is reused in all IndiaWhiskey variants nearly as-is.\n```\n          int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int\n          nShowCmd)\n          {\n           LoadKernel32APIAndGenerateNames();\n           LoadAdvapi32();\n           LoadShlwapiAPIs();\n           if ( !DropFile() )\n           {\n            InstallService();\n            ActivateService();\n           }\n           Suicide();\n           return 0;\n          }\n\n```\n**Figure 13-2: IndiaWhiskey-One’s WinMain Function**\n\n\n-----\n\n#### 13.2 IndiaWhiskey-Two\n\nThe outlier of the IndiaWhiskey variants, IndiaWhiskey-Two expands on the basic structure of IndiaWhiskey-One by\nadding an unnecessary chunk of code that displays two message boxes in case LoadShlwapiAPIs generates a Windows\nerror. It is unclear the intention of this additional code, as the first message box informs the user that no error has\noccurred, followed immediately by a message indicating that some error has occurred. Interestingly, the “Error Code”\nvalue is set to 0, a condition that defines the variable to always be false. The additional code is superfluous at best.\n```\n          int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int\n          nShowCmd)\n          {\n           DWORD lastError;\n           char String[260];\n           int v7;\n           LoadKernel32APIAndGenerateNames();\n           LoadAdvapiAPIs();\n           LoadShlwapiAPIs();\n           lastError = GetLastError();\n           memset(String, 0, 0x104);\n           if ( lastError && (v7 = lstrlenA(String)) != 0 )\n           {\n            lstrcpyA(String, \"No error occured.\\nClick 'OK' to continue.\");\n            MessageBoxA(0, String, \"Error\", 0);\n            sprintf(String, \"Unknown error occured.\\nError Code : %d\", v7);\n            MessageBoxA(0, String, \"Error\", 0);\n           }\n           else\n           {\n            if ( !DropMalware() )\n            {\n             InstallService();\n             ActivateService();\n            }\n            Suicide();\n           }\n           return 0;\n          }\n\n```\n**Figure 13-3: IndiaWhiskey-Two’s WinMain Function**\n\n\n-----\n\n#### 13.3 IndiaWhiskey-Three\n\nIndiaWhiskey-Three is by far the biggest shift from the baseline established by IndiaWhiskey-One. IndiaWhiskey-\nThree adds a bit of complexity by moving a large portion of the core functionality into a Windows dialog box function.\nThe WinMain, Figure 13-4, still calls the functions to perform the dynamic API loading and the service and file name\ngeneration, but it then calls DialogBoxParamA to generate a dialogue box.\n```\n          int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int\n          nShowCmd)\n          {\n           LoadKernel32APIAndGenerateNames();\n           LoadAdvapi32();\n           LoadShlwapiAPIs();\n           DialogBoxParamA(hInstance, \"TEST\", 0, DialogFunc, 0);\n           return 0;\n          }\n\n```\n**Figure 13-4: IndiaWhiskey-Three’s WinMain Function**\n\nThe DialogFunc function, Figure 13-5, is called when Windows begins to generate the dialogue box. It is at this point that\nthe rest of the IndiaWhiskey functionality continues.\n```\n          BOOL DialogFunc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)\n          {\n           if ( msg == WM _ PAINT )\n           {\n            if ( !fActive )\n            {\n             ShowWindow(hWnd, 0);\n             fActive ^= 1u;\n            }\n           }\n           else if ( msg == WM _ INITDIALOG )\n           {\n            ShowWindow(hWnd, 0);\n            if ( !DropFile() )\n            {\n             InstallService();\n             ActivateService();\n            }\n            Suicide();\n            EndDialog(hWnd, 0);\n            PostQuitMessage(0);\n           }\n           return 0;\n          }\n\n```\n**Figure 13-5: IndiaWhiskey-Three’s Dialogue Callback Function**\n\n\n-----\n\n### 14. [Loader] LimaAlfa\n\nThere are times when a piece of malware requires a support executable in order to execute. LimaAlfa is such a piece of\nmalware. LimaAlfa is responsible for the loading, removal of, and activation of the WhiskeyCharlie wiper malware and\nrequires three command line arguments in order to function:\n\n<file to delete> <configuration file key> <delay before commands, in seconds>\n\nIf there are not exactly three command line arguments, LimaAlfa quietly terminates.\n\nAs identified in the section describing IndiaDelta (see Section 5), LimaAlfa is dropped and activated by IndiaDelta,\nand the first command line argument passed to LimaAlfa is the filename of the IndiaDelta binary. The first task that\nLimaAlfa perform is the secure erasure of the IndiaDelta function by means of a secure deletion function. LimaAlfa then\nenters an infinite loop that only breaks with the removal of the IndiaDelta binary. For each iteration through the loop,\nthe secure file deletion function is called against the IndiaDelta binary, and the check condition is handled by calling\n```\n       GetFileAttributesA to determine if the IndiaDelta binary exists. In the same way that IndiaDelta would attempt to\n\n```\ndelete the previous stage of its loading process, LimaAlfa is continuing this trend by using a somewhat overly engineered\napproach to avoid using a suicide script.\n\nFor reasons that are not immediately clear, the next task LimaAlfa performs is to call LoadLibrary for user32.dll,\n```\n       advapi32.dll, shell32.dll, and shlwapi.dll. However, LimaAlfa does not attempt to load any API functions\n\n```\nfrom these DLLs, making the decision to load them into the process’s memory space somewhat baffling.\n\nLimaAlfa expects the presence of a file named mcu.dll, as the loader attempts to open the file by means of a fopen call.\nThe mcu.dll binary, a WhiskeyCharlie wiper binary, is one of the files that IndiaDelta drops. Instead of loading\n```\n       mcu.dll directly into the process’s memory space by calling LoadLibrary, LimaAlfa’s developers use the POSIX file\n\n```\nAPIs to open the file (fopen), determine the size of the file (ftell), and read the file into an allocated buffer (fread).\nAfter the contents of mcu.dll are loaded, LimaAlfa attempts to perform a secure delete of the file. This explains why the\ndeveloper(s) of LimaAlfa went to such trouble to load the file into memory instead of calling LoadLibrary: an active\nexecutable, even a DLL, cannot be deleted until it terminates. By loading the file into memory, LimaAlfa can manually\nload the DLL’s image and delete the source material without waiting.\n\nThe next task that LimaAlfa performs is the act of manually loading the mcu.dll image into its own process memory\nspace. This task requires LimaAlfa to allocate the correct amount of memory space, manually parse the PE header of\nthe image to properly fill the memory space, parse the import table and load the appropriate API functions necessary, fix\noffsets, and call the DllMain of the loaded image.\n\nWith the mcu.dll image loaded into LimaAlfa’s process space, the next task is to locate mcu.dll’s exported function\n```\n       Register. Register is the entry point of the WhiskeyCharlie malware and is explained in greater detail in the section\n\n```\ndedicated to that particular malware family in Novetta’s technical report on the Lazarus Group’s destructive malware.[9]\nLimaAlfa calls Register and passes the function three parameters: the name of the command file (hardcoded to\n```\n       mcu.inf), the string to decrypt the command file (as specified by the second command line argument) and the string\n\n```\n9 http://www.operationblockbuster.com/wp-content/uploads/2016/02/Operation-Blockbuster-Destructive-Malware-Report.pdf\n\n\n-----\n\npresenting the number of seconds to wait between each command (as specified by the third command line argument). At\nthis point, LimaAlfa is acting more like an incubator as it waits for Register to return after completing its tasks.\n\nOnce Register returns, LimaAlfa generates and executes a suicide script. The generation of the suicide script is\nextremely close in method and construction as IndiaAlfa’s suicide script generation function. The name of the batch\nfile that contains the suicide script is generated as zz followed by the output of rand and is located within the %TEMP%\ndirectory. Construction of the script itself is performed as seen in the code snippet in Figure 14-1.\n```\n          fp = CreateFileA(&szSuicideScriptFilename, 0x40000000u, 0, 0, 2u, 0x80u, 0);\n          if ( fp != (HANDLE)-1 )\n          {\n            lstrcpyA(buffer, \":x\\r\\ndel \\\"\");\n            lstrcatA(buffer, &szLimaAlfaFilename);\n            lstrcatA(buffer, \"\\\"\\r\\nif exist \\\"\");\n            lstrcatA(buffer, &szLimaAlfaFilename);\n            lstrcatA(buffer, \"\\\" goto x\\r\\ndel \\\"\");\n            lstrcatA(buffer, &szSuicideScriptFilename);\n            lstrcatA(buffer, \"\\\"\");\n            WriteFile(fp, buffer, lstrlenA(buffer), &NumberOfBytesWritten, 0);\n            CloseHandle(fp);\n            ShellExecuteA(0, \"open\", &szSuicideScriptFilename, 0, 0, 0);\n          }\n\n```\n**Figure 14-1: LimaAlfa’s Suicide Script Generator Code Snippet**\n\nThe execution of the suicide script occurs via a ShellExecute function call, as with IndiaAlfa. It is more than likely\nthat either the same author was responsible for the suicide script function in both IndiaAlfa and LimaAlfa or that the\ncode was shared.\n\n\n-----\n\n### 15. [Loader] LimaBravo\n\nNovetta observed IndiaEcho dropping LimaBravo as part of a two-stage loading system that ultimately loads RomeoGolf.\nLimaBravo is a service DLL that manually loads a Windows executable image (a DLL named perfc010.dat) into memory,\nthen executes the entry point function of the loaded image. Performing the same function as calling LoadLibrary,\nLimaBravo manually handles the tasks of memory allocation, section loading, import loading, and offset fix-ups before\nlocating the entry point of the image and transferring control to that function.\n\nLimaBravo generates a separate thread for the loading and eventual execution of the target image. This ensures that\nthe code necessary to support the service framework does not hang and at the same time provides a semi-autonomous\nexecution environment for the new image. Prior to loading the target time, LimaBravo ensures that a mutex with the\nname {17121AB3-079E-4622-9315-44C0364C6123} does not exist on the victim’s system, ensuring that only one\ninstance of LimaBravo is active at a time on the system.\n\nThe code responsible for the image loading is from the open-source code MemoryModule by Joachim Bauch.[10]\n\n[10 Joachim Bauch. “MemoryModule: Library to load a DLL from memory” https://github.com/fancycode/MemoryModule Accessed 5 February 2016.](https://github.com/fancycode/MemoryModule)\n\n\n-----\n\n### 16. [Loader] LimaCharlie\n\nLimaCharlie is a DLL-based loader and is both the loader and dropper for the RomeoHotel malware family. LimaCharlie’s\noperation consists of four tasks:\n\n1. Dynamically load API functions\n\n2. Verify RomeoHotel’s configuration and drop RomeoHotel DLL to disk\n\n3. Load and activate the RomeoHotel DLL\n\n4. Remove the RomeoHotel DLL\n\nLimaCharlie appears to be the second stage of a longer malware chain, as the second task it performs is the verification\nof the RomeoHotel’s configuration and temporary installation of the RomeoHotel DLL on the victim’s hard drive. This,\nalong with the fact that LimaCharlie operates as a DLL, indicates that LimaCharlie requires an installer prior to its\nactivation. It is currently not known which malware family is responsible for dropping and installing LimaCharlie.\n\nThe verification of the RomeoHotel configuration data’s registry entry is somewhat spotty in its approach. The verification\nconsists of decrypting the string containing the registry branch, using Caracachs, and then attempting to open the\nregistry key at the location HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security by calling RegOpenKey.\nIf the RegOpenKey function returns an error, LimaCharlie terminates. However, the configuration data is stored under\na subkey for RomeoHotel (HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security\\zc62a465-efff-87cc-\n```\n       47cdcdefa) that LimaCharlie attempts to read into memory via RegQueryValueEx. LimaCharlie makes no attempt\n\n```\nto determine if the RegQueryValueEx call fails, thereby providing no real verification that the configuration data truly\nexists. If the configuration data is available, LimaCharlie uses the data as the RomeoHotel configuration and produces a\nseries of calls to a nullsub function (a function that does nothing other than to return to the caller) with various fields\nfrom the configuration (Figure 16-1).\n```\n           RegQueryValueExA(phkResult, lpValueName, 0, 0, &Data, &NumberOfBytesRead);\n           RegCloseKey(phkResult);\n           GetSystemDirectoryW(FileName, 0x104);\n           wcscat(FileName, L\"\\\\\");\n           wcscat(FileName, Data.wszServiceDLL);\n           nullsub_1(&Data);\n           nullsub_1(&Data.arrwszC2s[9]);\n           nullsub_1(Data.wszServiceName);\n           nullsub_1(FileName);\n           memset(&buffer[0], 0, 100);\n           swprintf(\n            buffer,\n            L\"\\r\\nDefualt Sleep = %d, read Size = %d, %d \\r\\n\",\n            Data.dwSleepTimeBetweenReconnects,\n            NumberOfBytesRead,\n\n```\n**0xAE0);  // 0xAE0 is the expected size of the RomeoHotel configuration**\n```\n           nullsub_1(buffer);\n\n```\n**Figure 16-1: LimaCharlie’s Use of the RomeoHotel Configuration Data during the Verification Task**\n\n\n-----\n\nLimaCharlie’s dropping of the RomeoHotel binary is rather straightforward and similar to other installers’ within the\nLazarus Group’s collection of malware. LimaCharlie first determines its own file size and then reads a DWORD from the\nlast 4 bytes of itself. This value indicates the offset to the start of the RomeoHotel image within the LimaCharlie binary.\nThe RomeoHotel image begins with a DWORD specifying the size of the RomeoHotel binary contained within the image\ndata. LimaCharlie then allocates memory on the heap of the size specified before reading the RomeoHotel binary into\nmemory. The RomeoHotel binary is encrypted using Caracachs, which LimaCharlie removes before saving the binary to\ndisk as %TEMP%\\DQ{random number}.\n\nThe loading and activation of the dropped RomeoHotel binary is based on a CodeProject project by the user pasztorpisti.[11]\nDating back to 2000 but updated several times between 2012 and 2014, the LoadDll project contains a framework for\nloading a DLL into memory without using the Windows API function LoadLibrary. LimaCharlie uses the core code of\nthe project to, as the description suggests, load the RomeoHotel binary into memory and call the DLL’s DllMain function\nto activate the RomeoHotel malware.\n\nAfter loading the RomeoHotel binary into memory, the RomeoHotel binary is deleted from the victim’s hard drive\nvia the standard Windows API function DeleteFile. It is this action that justifies the use of the LoadDll code to\nload RomeoHotel. Had the developer(s) of RomeoHotel used LoadLibary to load the DLL into memory, the call to\n```\n       DeleteFile would have failed, as the Windows operating system would have a lock on the DLL. But by manually\n\n```\nloading the DLL into memory and then activating the DLL, Windows does not have such a lock, allowing the RomeoHotel\nDLL to be deleted and leaving little trace of the actual, malicious binary running on the victim’s system.\n\n[11 pasztorpisti. CodeProject. “Loading Win32/64 DLLs “manually” without LoadLibrary()” http://www.codeproject.com/Tips/430684/Loading-Win-DLLs-manually-without-LoadLibrary. 8 Mar 2014](http://www.codeproject.com/Tips/430684/Loading-Win-DLLs-manually-without-LoadLibrary)\n\n\n-----\n\n### 17. [Loader] LimaDelta\n\nA bit of an outlier in the Lazarus Group’s collection of malware, LimaDelta blurs its categorical lines by operating as both\na downloader and loader. Known LimaDelta samples were compiled between September 2010 and March 2011 and most\nlikely only operated during that time period, making it problematic to find intelligence on the files they downloaded.\nDespite the temporal distance between LimaDelta’s usage in the wild and the analysis of the malware family for this\nreport, there is evidence to suggest that LimaDelta downloaded and then loaded IndiaGolf (see Section 8). This section\nworks under the assumption that the downloaded binary is, indeed, IndiaGolf.\n\nLimaDelta, when viewed by its primary function of downloading and loading a file into running memory, is an example\nof over-engineering a solution for a relatively simple problem. When viewed at a macro level, LimaDelta performs the\nfollowing tasks:\n\n1. Connect to a C2 server and authenticate\n\n2. Send information about the victim’s machine and exchange LimaDelta configuration between the C2 server and the\n\nmalware\n\n3. Receive a list of download servers and a data blob containing the data to send to the installation function\n\n4. Connect to one of the download servers and authenticate\n\n5. Send information about the victim’s machine and receive 16 bytes from the download server\n\n6. Receive file from the download server and save it to the victim’s hard drive as a randomly generated named DLL\n\n7. Load the DLL into memory and decrypt a portion of the data blob\n\n8. Call the installation function with the decoded portion of the data blob\n\n9. Report status of DLL load to the C2 server and receive response from the C2 server\n\n10. Save the configuration to disk and delete additional files\n\n11. Generate and execute suicide script.\n\nThere are three variants of LimaDelta that differ primarily in their verification method for the files they download.\nLimaDelta-One blindly assumes the file it downloads is non-corrupt. LimaDelta-Two verifies the integrity of the\ndownloaded file via a CRC32 checksum. LimaDelta-Three uses MD5 to verify the integrity of the file it downloads.\nThere are subtle differences between each of the various variants that will be discussed below, but the average similarity\nbetween the variants (using BinDiff as the similarity engine) is roughly 94.5%, indicating very little change across the life\nspan of LimaDelta.\n\nLimaDelta can support up to 10 C2 servers via hardcoded IP and port number structures. From this list of C2 servers,\nLimaDelta randomly selects an entry and attempts to connect to the C2 server. If a server does not respond within 15\nseconds, the C2 server entry is removed from the list, another C2 server entry is selected, and the process repeats until\neither a successful connection occurs or the list empties.\n\nOnce connected to a C2 server, LimaDelta must authenticate with the C2 server. This authentication process (the last\nhalf of Task #2) is over-engineered when compared to other families within the Lazarus Group. Authentication between\nLimaDelta and the C2 server consists of constructing a variable-sized data blob that has a minimum of 70 bytes and an\nupper limit of 120 bytes, transmitting the data blob to the C2 server, receiving a 5-byte response from the C2 server, and\n\n\n-----\n\n|OFFSET|SIZE (BYTES)|DESCRIPTION|\n|---|---|---|\n|0|11|Constant values: 0x16, 0x03, 0x01, 0x00, 0x41, 0x01, 0x00, 0x00, 0x3D, 0x03, 0x01|\n|11|4|Current time (from time function) in big-endian order|\n|15|4|Randomly generated bytes|\n|19|4|Data from offset 15 XOR’d with the string 0x4C, 0x86, 0x25, 0xB7|\n|23|1|Total size of the authentication data blob|\n|24|1|Constant value: 0xC0|\n|25|18|Randomly generated bytes|\n|43|27|Constant values: 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x05, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x64, 0x00, 0x62, 0x00, 0x03, 0x00, 0x06, 0x00, 0x13, 0x00, 0x12, 0x00, 0x63, 0x01, 0x00, 0x00|\n|70|Variable (up to 50 bytes)|If the C2 server’s listening port is not 443, this field contains up to 50 bytes of randomly generated bytes. The number of bytes is randomly selected between 0 and 50.|\n\n|OFFSET|SIZE (BYTES)|DESCRIPTION|\n|---|---|---|\n|0|1|Status code: 0 indicates a failed authentication, 1 indicates a successful authentication|\n|1|4|Communications key base array|\n\n\nusing four of the received bytes as the communications key for any further communication. While the high-level events\njust described for the authentication process may not seem overly complex or cumbersome, it is the construction of the\nvariable-sized data blob that makes the authentication task appear overly engineered. The data blob, detailed in Table 17-1,\ncontains a large number of constant values and randomly generated data.\n\n**OFFSET** **SIZE (BYTES)** **DESCRIPTION**\n\nConstant values: 0x16, 0x03, 0x01, 0x00, 0x41, 0x01, 0x00, 0x00, 0x3D,\n0 11\n```\n                       0x03, 0x01\n\n```\n11 4 Current time (from time function) in big-endian order\n\n15 4 Randomly generated bytes\n\n19 4 Data from offset 15 XOR’d with the string 0x4C, 0x86, 0x25, 0xB7\n\n23 1 Total size of the authentication data blob\n\n24 1 Constant value: 0xC0\n\n25 18 Randomly generated bytes\n\nConstant values: 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x05, 0x00, 0x0A,\n\n43 27 `0x00, 0x09, 0x00, 0x64, 0x00, 0x62, 0x00, 0x03, 0x00, 0x06, 0x00, 0x13,`\n```\n                       0x00, 0x12, 0x00, 0x63, 0x01, 0x00, 0x00\n\n```\nIf the C2 server’s listening port is not 443, this field contains up to 50 bytes of\n\nVariable (up to\n70 randomly generated bytes. The number of bytes is randomly selected between 0\n\n50 bytes)\n\nand 50.\n\n**Table 17-1: LimaDelta’s Authentication Request Data Structure**\n\nAfter generating and transmitting the authentication data blob, LimaDelta receives a 5-byte data burst containing a status\ncode and an array of 4-bytes that constitutes the basis for the communication key going forward. Table 17-2 illustrates the\nstructure of the response from the C2 server.\n\n**OFFSET** **SIZE (BYTES)** **DESCRIPTION**\n\n0 1 Status code: 0 indicates a failed authentication, 1 indicates a successful authentication\n\n1 4 Communications key base array\n\n**Table 17-2: LimaDelta’s Authentication Response Data Structure**\n\nThe authentication scheme ultimately defines the encryption key that the LimaDelta binary and the C2 server use for\nfurther communications. The communication key base array (offset 1) sent from the server makes up one half of the\ncommunication key that LimaDelta uses for encrypting traffic between itself and the C2 server. The full key consists of\ntaking the communications key base array and XOR’ing each byte against its respective byte within the 4 random bytes\n(offset 15) LimaDelta sent as part of the authentication data. Figure 17-1 illustrates the code responsible for generating the\ncommunication key.\n\n\n-----\n\n|SIZE IN BYTES (DATA TYPE)|DESCRIPTION|\n|---|---|\n|2 (WORD)|Size of data blob (minus this field)|\n|Variable (NULL-terminated string)|Name of LimaDelta’s executable (as returned by GetModuleFileNameA)|\n|Variable (NULL-terminated string)|Full path to LimaDelta’s executable|\n|Variable (NULL-terminated string)|Computer’s name|\n|Variable (NULL-terminated string)|User’s name|\n|10|Randomly generated 10-byte buffer|\n|8 (VARIANTTIME)|Time and date that LimaDelta’s executable was written to disk|\n|8 (VARIANTTIME)|Time and date that LimaDelta was executed|\n|8 (VARIANTTIME)|Current time and date on victim’s system|\n|4 [DWORD]|Non-zero if SysInternal tools Process Monitor, Registry Monitor or File Monitor are active|\n|4 [DWORD]|Current value from GetTickCount|\n|Variable|Optional payload data blob|\n\n```\n          if ( response.bStatus )\n          {\n           memcpy(commKey, response.commKey, 4);\n           j = 0;\n           do\n           {\n            commKey[j] ^= random4ByteBuffer[j];\n            ++j;\n           }\n           while ( j < 4 );\n           dwDataKeyIndex = 0;\n           result = 1;\n          }\n\n```\n**Figure 17-1: LimaDelta Generating the Communications Encryption Key**\n\nWith the connection between the LimaDelta and the C2 server established and the communication encryption initialized,\nLimaDelta sends another packet of information to the C2 server, this time containing information about the victim’s\ncomputer (Table 17-3). At this point, all communication between LimaDelta and the C2 server uses the common network\ndata transmission and receiving functions to support an encrypted communication channel. LimaDelta uses the code\nfragment in Figure 17-2 to encode and decode communication between LimaDelta and the C2 server.\n\n**SIZE IN BYTES (DATA TYPE)** **DESCRIPTION**\n\n2 (WORD) Size of data blob (minus this field)\n\nVariable (NULL-terminated string) Name of LimaDelta’s executable (as returned by GetModuleFileNameA)\n\nVariable (NULL-terminated string) Full path to LimaDelta’s executable\n\nVariable (NULL-terminated string) Computer’s name\n\nVariable (NULL-terminated string) User’s name\n\n10 Randomly generated 10-byte buffer\n\n8 (VARIANTTIME) Time and date that LimaDelta’s executable was written to disk\n\n8 (VARIANTTIME) Time and date that LimaDelta was executed\n\n8 (VARIANTTIME) Current time and date on victim’s system\n\nNon-zero if SysInternal tools Process Monitor, Registry Monitor or File Monitor are\n4 [DWORD]\nactive\n\n4 [DWORD] Current value from GetTickCount\n\nVariable Optional payload data blob\n\n**Table 17-3: LimaDelta’s Victim’s System Information Data Blob Structure**\n\n\n-----\n\n```\n             i = dwDataKeyIndex;\n             do\n             {\n              *p++ ^= commKey[i];\n              i = dwDataKeyIndex++ + 1;\n              if ( dwDataKeyIndex == 4 )\n              {\n               i = 0;\n               dwDataKeyIndex = 0;\n              }\n              --dwBytesRemaining;\n             }\n             while ( dwBytesRemaining );\n\n```\n**Figure 17-2: LimaDelta’s Communication Encryption/Decryption Scheme’s Code**\n\nIt is interesting that the developer(s) of LimaDelta paid attention to the SysInternal tools while there is no other indication\nwithin the LimaDelta code base that tools such as debuggers are of any concern. The method by which LimaDelta\ndetermines if the SysInternal tools are present and active on the victim’s computer is the identification of window class\nnames from the tools. For the tool Process Monitor, LimaDelta looks for the window class PROCMON_WINDOW_CLASS\nwhile for Registry Monitor and File Monitor—two tools that have been out of active circulation since September 19,\n2009 due to their integration into Process Monitor—LimaDelta looks for the window class 18467-41. Conceivably, the\ninclusion of an indicator that these tools were active at the time of the infection could change the behavior of the C2\nserver’s responses, but without an active C2 server to test against, this is only a theory.\n\nTask 2 consists of LimaDelta receiving the name for a file to store on the victim’s computer, uploading the contents of the\nfile to the C2 server, receiving a data blob, and saving the data to the same file on the victim’s disk. It is not immediately\nclear the purpose of the file that LimaDelta and the C2 server exchange, but there is a limitation that the file cannot\nexceed 100 bytes. The content of the file is not used by LimaDelta, and without a filename it is not possible to speculate as\nto what malware family it may relate to.\n\nThe C2 server is not the ultimate end point from which LimaDelta receives the binary to load. Instead, the next task (Task\n3) consists of LimaDelta receiving a DWORD containing the number of download server records that the C2 server is\ngoing to send, followed by the download server records themselves. LimaDelta accepts a maximum of 10 download server\nrecords. The records are 6 bytes in length, with the first four bytes being the IP address of the download server and the\nlast two bytes being the port the download server listens to. Following the download of server records, the C2 server sends\nanother 4-byte value identifying the number of bytes that the C2 server is going to transmit. The C2 server then transmits\nup to 1KB of data which becomes the basis for the configuration data that LimaDelta passes to the installation function in\nTask 8. The connection to the C2 server is terminated upon completion of the data blob transfer.\n\nLimaDelta uses the same function to randomly select from the provided download server records and perform the\nsame form of authentication as was done when the malware contacted the C2 server (Task 4). Following a successful\nauthentication to a download server, LimaDelta sends another system information packet to the download server as it did\nwith the C2 server (Task 5), with the exception that the optional payload section now contains the first 14 bytes of the data\nblob to be passed to the installation function.\n\nAfter LimaDelta sends the system information data (along with the additional 14-byte payload), the download server will\nrespond with a 16-byte array. The contents of the 16-byte array are disregarded by all variants except LimaDelta-One,\nwhich ultimately passes the array to the installation function. LimaDelta must generate a filename before the file can be\nloaded into memory. The name that LimaDelta generates is variant-specific, but it is always sent as a.dll.\n\nIn order to transfer the DLL (Task 6), LimaDelta receives a 4-byte value, a DWORD, indicating the size of the file from the\ndownload server. LimaDelta receives the file in 12288 byte transmissions from the download server. To confirm the file was\n\n\n-----\n\nreceived, LimaDelta sends at least 128 bytes but no more than 384 bytes of the downloaded chuck, starting four bytes into the\nchuck, back to the download server. The number of bytes sent is randomly selected for each confirmation. The confirmation\nis preceded by the first four bytes (DWORD) indicating the number of bytes that LimaDelta is sending to the download server\nas confirmation. With LimaDelta having saved the file to disk, the file is loaded into memory via a call to LoadLibraryA,\nand the installation function is obtained by calling GetProcAddress with the variant-appropriate export name.\n\nWith the exception of the LimaDelta-One variant, the data blob to be used as the installation function’s parameter is\ndecrypted using the simple algorithm in Figure 17-3. From the algorithm, it is possible to infer a few details of the data\nstructure received in Task 3. For starters, the data contains 10 records, IP and port records, starting at offset 22. The value\nfor the IP address is encoded with the static XOR key 0x58713A6D, while the port number is not. Secondly, the encoded\nIP and port records appear to be 16 bytes in size, meaning LimaDelta expects exactly 10 such records to be present in the\ndata blob; therefore, at a minimum, the data blob is 182 bytes once you factor in the initial 22 byte offset.\n\n**unsigned char *pParamDataDecoded = pRomeoMikeConfigData;**\n```\n          unsigned char *pParamDataEncoded = &pDataBlob[22);\n          i = 10;\n          do\n          {\n           v13 = *( _ DWORD *)(pParamDataEncoded - 4);\n           *( _ DWORD *)pParamDataDecoded = *(DWORD*) pParamDataDecoded ^ 0x58713A6D;\n           *(( _ DWORD *)pParamDataDecoded + 1) = *( _ WORD *)(pParamDataEncoded);\n           pParamDataDecoded += 8;\n           pParamDataEncoded += 16;\n           --i;\n          }\n          while ( i );\n\n```\n**Figure 17-3: LimaDelta’s Code for Transforming the Downloaded Data Blob into the Installation Function’s Data Blob**\n\nWith the installation function now available in memory and the data structure necessary for the installation function\nready, LimaDelta calls the installation function and waits for the function to return. Once the installation function\nreturns, LimaDelta sends the value of 1 (as a 4-byte DWORD) to the download server and reads a 4-byte response that it\npromptly ignores before shutting down the connection to the download server.\n\nWith the usefulness of the DLL now over, LimaDelta removes the binary from memory by calling FreeLibraryA before\nsleeping for 300ms. The DLL is removed from the victim’s system by first overwriting the file with 4096-byte buffers\ncontaining the same 16-bit value. For each 4096-byte buffer used, a new 16-bit value is randomly generated. LimaDelta\ndeletes the destroyed file.\n\nLimaDelta saves the contents of the data blob obtained from the C2 server during Task 2. After saving the data blob to\ndisk, the actions that occur before termination vary by variant. Variants LimaDelta-One and LimaDelta-Two delete\nentries from the victim’s URL cache of Internet Explorer, while LimaDelta-Three deletes two .ini files. The final\nstep performed by all variants of LimaDelta prior to termination is the generation and execution of a suicide script.\nUsing sprintf to generate the script in a single pass and WriteFile to save the script to disk, LimaDelta calls\n```\n       CreateProcessA to execute the script as Figure 17-4 illustrates. The filename of the script is variant-dependent.\n\n```\n\n-----\n\n```\n           hFile = CreateFileA _ 0(szScriptName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);\n           if ( hFile != (HANDLE)-1 )\n           {\n            sprintf(\n             szScript,\n             \"@echo off\\r\\n:R\\r\\ndel /a \\\"%s\\\"\\r\\nif exist \\\"%s\\\" goto R\\r\\ndel /a \\\"%s\\\"\\r\\n\",\n             szLimaDeltaFilename,\n             szLimaDeltaFilename,\n             szScriptName);\n            WriteFile(hFile, szScript, strlen(szScript), &NumberOfBytesWritten, 0);\n            CloseHandle(hFile);\n            StartupInfo.cb = 0;\n            memset(&StartupInfo, 0, 0x40u);\n            StartupInfo.dwFlags = 1;\n            StartupInfo.wShowWindow = 0;\n            CreateProcessA(0, szScriptName, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation);\n           }\n\n```\n**Figure 17-4: LimaDelta’s Suicide Script Generator**\n\n\n-----\n\n#### 17.1 LimaDelta-One\n\nLimaDelta-One is the oldest observed variant within the LimaDelta family, dating back to September 2010. The\nmost notable difference from other LimaDelta variants is the fact that, instead of calling a single installation\nfunction, LimaDelta-One accesses two functions: DialingConnect and DialingClose. LimaDelta-One calls\n```\n       DialingClose first and passes two arguments to the function, the first being the data blob from Task 3 starting at\n\n```\noffset 14 and the second being the 16 bytes returned from the download server during Task 5. LimaDelta-One then calls\n```\n       DialingConnect with a pointer to an uninitialized 132-byte buffer. After the function returns, the first DWORD of the\n\n```\nbuffer is overwritten with return value from DialingClose and then transmitted to the download server during Task 9.\n\nPrior to the generation and execution of the suicide script, LimaDelta-One calls DeleteUrlCacheEntryA to remove\n```\n       hxxp://sub.sharebox.co.kr/SBUpdate.exe from the cache files on the victim’s machine. If any of the tasks\n\n```\nbetween Tasks 1 and 9 fail, LimaDelta-One also deletes the file ShareBoxC.dat that exists in the same path as the\nLimaDelta-One binary. The combination of the cache file deletion and dat file deletion may point to the possibility that\n```\n       sub.sharebox.co.kr was compromised and that LimaDelta-One was being installed as SBUpdate.exe.\n\n```\nWhen LimaDelta-One generates the suicide script, the script is saved to the %TEMP% directory using a randomly generated\nname. The name for the suicide script consists of four randomly generated digits between 0 and 9 followed by .bat. It is\ninteresting that the developer(s) would choice to generate each digit individually when it would be just as effective to use a\n```\n       sprintf(\"%d.bat\", rand()) statement to achieve the same result.\n\n```\n\n-----\n\n#### 17.2 LimaDelta-Two\n\nLimaDelta-Two introduces the idea of file integrity checks. After receiving the file from the download server, the last\n4-bytes are read from the file as a DWORD. A call to SetFilePointer and SetEndOfFile is used to remove the last\n4 bytes from the file. The DWORD represents the CRC32 checksum for the downloaded file. LimaDelta-Two calculates\nthe CRC32 checksum for the downloaded binary and compares it to the expected checksum value. If the values match,\nLimaDelta-Two considers the file valid, otherwise LimaDelta-Two indicates a failed download.\n\nLimaDelta-Two has been observed using two different names for the installation function: StartInstall and _gdimain.\nDespite their different names, both installation functions take the same parameters as described previously for Task 8.\n\nPrior to the generation and execution of the suicide script, LimaDelta-Two calls DeleteUrlCacheEntryA to remove\nthe following cache entries (and their associated files on disk):\n\n         - hxxp://sub.sharebox.co.kr/SBUpdate.exe\n\n         - hxxp://webfile.bobofile.co.kr/app/bobofile/setup/setup_bobofile.exe\n\n          - hxxp://webfile.filecity.co.kr/app/filecity/setup/setup_filecity.exe\n\nAs with LimaDelta-One, if any of the tasks between Task 1 and 9 fail, LimaDelta-Two deletes the file ShareBoxC.dat\nthat exists in the same path as the LimaDelta-Two binary. Just as the combination of specific URL cache entry and specific\nfile deletion of LimaDelta-One indicates that LimaDelta-One was hosted on a compromised site, LimaDelta-Two’s URL\ncache deletion may indicate that three Korean websites were compromised and hosting LimaDelta-Two.\n\nLimaDelta-Two uses the same suicide script generation function as LimaDelta-One. The reuse of the generator means\nthat the same sloppy random name generator that produces a four character .bat file filename is used in LimaDelta-Two,\nand that the suicide script will exist within the %TEMP% directory.\n\n\n-----\n\n#### 17.3 LimaDelta-Three\n\nLimaDelta-Three enhances the file integrity check by replacing the CRC32 checksum with a MD5 hash. Like\nLimaDelta-Two, after receiving the file from the download server, LimaDelta-Three reads the last 16-bytes from the file\nand calls to SetFilePointer and SetEndOfFile to remove the last 16 bytes from the file. The 16 bytes represent the\nMD5 hash of the downloaded file. LimaDelta-Three calculates the MD5 hash of the downloaded binary and compares\nit to the expected hash value. If the values match, LimaDelta-Three considers the file valid, otherwise the download is\nconsidered invalid.\n\nLimaDelta-Three uses a different name for the installation function: UICreate.\n\nLimaDelta-Three does not remove any URL cache files from the victim’s system prior to calling the suicide script. The\nmalware does, however, delete _ver.ini and ver.ini from the current working directory if any task between Task 1\nand Task 9 fails. Neither the purpose of these files nor their origin are unknown.\n\nThe suicide script generator in LimaDelta-Three produces the same suicide script as the other variants, and in the same\nmanner. But, unlike the previous LimaDelta variants described, LimaDelta-Three uses a static filename, saving the\ngenerated suicide script to %TEMP%\\vlt.bat.\n\nLimaDelta-Three has an interesting artifact within its strings. Using a dynamic API loader like all of the observed\nLimaDelta variants, LimaDelta-Three has what appears to be a gross editing error within its source code. The dynamic\nAPI loading function calls GetProcAddress for the specified API names after doing a bulk decryption of all API names.\nFor the WSACleanup API function, the authors supply the following to the GetProcAddress function:\n```\n             WSACleanupSTR_READFILE1 ReadFile\n\n```\nThe error would appear to indicate that the names of API functions are declared using #define preprocessor statements\nand that somehow a serious copy and paste or find and replace operation error has occurred but went undetected at\ncompile time. While the error has no operational impact on the malware, it does crack a door open to allow analysts to\npeak at the construction of the malware at the source code level.\n\n\n-----\n\n### 18. [Uninstaller] UniformAlfa\n\nTools and objectives can change during the course of an operation, making the rapid removal of an existing attack tool\nnecessary. UniformAlfa is an example of a tool designed for the purpose of removing other tools. When activated, it\nremoves the service and file artifacts that are associated with RomeoBravo.\n\nUniformAlfa begins by entering an infinite loop that calls the API function ControlService in order to stop the service\nnamed WmiSecSvc. The loop is only broken when the status of the WmiSecSvc returns SERVICE_CONTROL_ STOP,\nindicating that the service has successfully stopped. At this point the service can be safely removed from the Windows\noperating system by a call to the DeleteService function.\n\nNext, the files pmsconfig.msi, pmslog.msi, wmisecsvc.dll, and tmscompg.msi are deleted with a call to\n```\n       DeleteFile. Unlike other families within the Lazarus Group’s collection, the deletion of the four files does not include a\n\n```\nmore secure form of deletion.\n\nWith the RomeoBravo service stopped and deleted and the RomeoBravo executable and configuration files deleted,\nUniformAlfa concludes by generating and executing a suicide script which it writes to disk as 001pdm.bat.\n\n\n-----\n\n### 19. [Uninstaller] UniformJuliett\n\nThe SierraJuliett-MikeOne malware instructs its members to download UnformJuliett, the streamlined uninstaller for\nthe malware. Using the same dialog-based installer design pattern seen in other Lazarus Group malware families—most\nnotably, IndiaWhiskey-Three (see Section 13.3)—but using the template name of MAIN, UniformJuliett performs the\nfollowing tasks:\n\n1. Attempt to open a handle to the Rpcss service, terminate if unsuccessful.\n\n2. Open a handle to the wauserv service\n\n3. Stop the wauserv service\n\n4. Wait 1 second and then delete the wauserv service\n\n5. Delete the SierraJuliett-MikeOne binary at %SYSDIR%\\wauserv.dll\n\n6. Generate and execute suicide script\n\nTask 1, at first glance, seems unusual, as the Rpcss service is a legitimate service that SierraJuliett-MikeOne has shown\nno interaction with in the observed samples. The purpose of Task #1 appears to be determining if UniformJuliett has\nsufficient administrative privileges to interact with the Windows Services Manager through the Windows API. Since\n```\n       Rpcss is a required system service, being unable to access the service via the Windows API means that the application\n\n```\ndoes not have privileges. Of course, this raises the question as to why UniformJuliett does not use the SierraJuliett-\nMikeOne service for this test. The answer would appear to be that the test could be less reliable, as it is possible that the\nservice for SierraJuliett-MikeOne may have been removed by an administrator or antivirus product or the installation of\nthe service may have been faulty. Since the test of necessary privileges is a prerequisite of the subsequent tasks, ensuring\nthe reliability of the test is paramount.\n\nThe removal of the service is a straightforward set of calls to the Windows API functions that allow interaction with\nthe Windows services database. The deletion of the SierraJuliett-MikeOne binary, Task 5, has a peculiar code artifact,\nhowever. After constructing the filename and path information to the binary, UniformJuliett uses the directory hierarchy\nverification and generation function found in many of the Lazarus Groups families. This is wholly unnecessary, since\nthe SierraJuliett-MikeOne binary is stored within the %SYSDIR% directory, which is always available, else the Windows\noperating system would fail to load.\n\nThe suicide script that UniformJuliett generates is identical to the script found in IndiaCharlie. The generation of the\nsuicide script is the same in both, but the execution is different. IndiaCharlie uses the WinExec API function while\nUniformJuliett uses the CreateProcess API function. Functionally, both of the binaries perform the same task. But\nthis does indicate that sometime in the two years that occurred between UniformJuliett was compiled and the first\nobserved IndiaCharlie binary was compiled, the developer(s) decided to modify their code for some unknown reason.\n\n\n-----\n\n### 20. Conclusion\n\nWhile the capabilities for the installers, loaders, and uninstallers in this report are relatively straight forward and\nsingle-focused, analysis of these malware families provide further insight into the capabilities of the Lazarus Group.\nThe malware families within this report also show the differing level of refinement observed across Lazarus Group\nmalware: ranging from simplistic to convoluted to more advanced, but all ultimately effective. Analysis of these malware\nfamilies showcases some of common Lazarus Group strategies of code reuse and the customization of open-source code\nlibraries to alleviate some software development burdens. The use of decoy documents also reveals some of the potential\ntargets of the group’s malicious activity, specifically the use of decoy documents in spear phishing attacks observed\ntargeting South Korean government and aerospace organizations.\n\nRegardless of their sophistication or refinement, the malware families within the Lazarus Group’s India and Lima classes\nperform at a reasonable level for their designed purpose: the introduction and persistence of malware from the Lazarus\nGroup on a victim’s infrastructure.\n\n\n-----\n\nMcLean, Virginia – Headquarters\n7921 Jones Branch Drive\n5th Floor\nMcLean, VA 22102\n\n**www.OperationBlockbuster.com**\n\nPhone: (571) 282-3000\nwww.novetta.com\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.02.24.Operation_Blockbuster/Operation-Blockbuster-Loaders-Installers-and-Uninstallers-Report.pdf"
    ],
    "report_names": [
        "Operation-Blockbuster-Loaders-Installers-and-Uninstallers-Report"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d18fe42c-8407-4f96-aee0-a04e6dce219a",
            "created_at": "2023-01-06T13:46:38.275292Z",
            "updated_at": "2025-03-27T02:00:02.79092Z",
            "deleted_at": null,
            "main_name": "APT12",
            "aliases": [
                "Calc Team",
                "IXESHE",
                "BRONZE GLOBE",
                "BeeBus",
                "DynCalc",
                "DNSCalc",
                "Crimson Iron",
                "NUMBERED PANDA",
                "TG-2754",
                "Group 22"
            ],
            "source_name": "MISPGALAXY:APT12",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6a660ea2-1118-404a-9f8f-f0d6a1e9f184",
            "created_at": "2022-10-25T15:50:23.685924Z",
            "updated_at": "2025-03-27T02:00:55.52357Z",
            "deleted_at": null,
            "main_name": "APT12",
            "aliases": [
                "APT12",
                "IXESHE",
                "DynCalc",
                "Numbered Panda",
                "DNSCALC"
            ],
            "source_name": "MITRE:APT12",
            "tools": [
                "Ixeshe",
                "RIPTIDE",
                "HTRAN"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c5f79f58-db78-4cd7-88cf-c029a2199360",
            "created_at": "2022-10-25T16:07:23.325227Z",
            "updated_at": "2025-03-27T02:02:09.738383Z",
            "deleted_at": null,
            "main_name": "APT 12",
            "aliases": [
                "APT 12",
                "BeeBus",
                "Bronze Globe",
                "CTG-8223",
                "Calc Team",
                "Crimson Iron",
                "DNSCalc",
                "DynCALC",
                "Group 22",
                "Numbered Panda"
            ],
            "source_name": "ETDA:APT 12",
            "tools": [
                "AUMLIB",
                "ETUMBOT",
                "Exploz",
                "Graftor",
                "HIGHTIDE",
                "IHEATE",
                "IXESHE",
                "RIPTIDE",
                "RapidStealer",
                "Specfix",
                "THREEBYTE",
                "bbsinfo",
                "mswab",
                "yayih"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "e6e26922-3f4f-4243-9af5-cf9bea8b93bd",
            "created_at": "2022-10-25T16:47:55.577163Z",
            "updated_at": "2025-03-27T02:05:17.26824Z",
            "deleted_at": null,
            "main_name": "BRONZE GLOBE",
            "aliases": [
                "CTG-8223 ",
                "DNSCalc",
                "DyncCalc",
                "Numbered Panda ",
                "APT12 "
            ],
            "source_name": "Secureworks:BRONZE GLOBE",
            "tools": [
                " BeepService",
                " Etumbot",
                " Gh0st RAT",
                " Ixeshe",
                " Mswab",
                " RAdmin",
                " Seatran",
                " SvcInstaller",
                " Ziyang",
                "Badpuck"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041843,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/058540094f2591abb7de917954dcb886cc1697ce.pdf",
        "text": "https://archive.orkl.eu/058540094f2591abb7de917954dcb886cc1697ce.txt",
        "img": "https://archive.orkl.eu/058540094f2591abb7de917954dcb886cc1697ce.jpg"
    }
}