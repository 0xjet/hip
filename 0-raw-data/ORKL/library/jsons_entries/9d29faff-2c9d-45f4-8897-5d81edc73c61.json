{
    "id": "9d29faff-2c9d-45f4-8897-5d81edc73c61",
    "created_at": "2023-01-12T15:06:40.032474Z",
    "updated_at": "2025-03-27T02:09:18.706987Z",
    "deleted_at": null,
    "sha1_hash": "73884707df9f6f86cfd1787d48eaa2f999a02b36",
    "title": "2020-11-06 - Ransomware Alert- Pay2Key",
    "authors": "",
    "file_creation_date": "2022-05-28T18:09:56Z",
    "file_modification_date": "2022-05-28T18:09:56Z",
    "file_size": 650097,
    "plain_text": "# Ransomware Alert: Pay2Key\n\n**research.checkpoint.com/2020/ransomware-alert-pay2key/**\n\nNovember 6, 2020\n\n## Introduction\n\n\nNovember 6, 2020\n\n\nOver the past week, an exceptional number of Israeli companies reported ransomware attacks. While some of the attacks were carried out by\n[known ransomware strands like REvil and Ryuk, several large corporations experienced a full blown attack with a previously unknown](https://www.checkpoint.com/cyber-hub/threat-prevention/ransomware/ryuk-ransomware/)\nransomware variant names Pay2Key.\n\nAs days go by, more of the reported ransomware attacks turn out to be related to the new Pay2Key ransomware. The attacker followed the\nsame procedure to gain a foothold, propagate and remotely control the infection within the compromised companies.\n\nThe investigation so far indicates the attacker may have gained access to the organizations’ networks some time before the attack, but\npresented an ability to make a rapid move of spreading the ransomware within an hour to the entire network. After completing the\ninfection phase, the victims received a customized ransom note, with a relatively low demand of 7-9 bitcoins (~$110K-$140K).\n\nThe full scope of these attacks is still unraveling and is under investigation; but we, at Check Point Research and the Incident Response\nteams, would like to offer our initial analysis of this new ransomware variant, as well as to provide relevant IOC’s to help mitigate possible\nongoing attacks.\n\n**Key findings:**\n\n1. Previously unknown ransomware dubbed Pay2Key, carries targeted attacks against Israeli companies\n2. Initial infection is presumably made through RDP connection\n3. Lateral movement is made using psexec.exe to execute the ransomware on the different machines within the organization.\n4. Special attention was given to the design of the network communication, in order to reduce the noise a large number of encrypted\n\nmachines may generate while contacting the Command and Control servers.\n5. The encryption scheme is solid – using the AES and RSA algorithms.\n\n## Attacks Timeline\n\nDuring the last days, we were able to obtain bits and pieces of information as well as various forensics artifacts from Israeli Incident Response\nteams indicating that a new ransomware strain is being deployed against Israeli corporations (perhaps exclusively)\n\n\n-----\n\nCo b g t ese e e e ts, e e e ab e to b g toget e a pa t a age o t e attac s as t ey u o ded\n\n2020-06-28 – The attacker created a KeyBase account by the name of “pay2key”\n2020-10-26 – First ransomware sample compilation date\n2020-10-27 – Second ransomware sample compilation date\n2020-10-27 – First Pay2Key sample uploaded to VT and compiled on the same day – may indicate its first appearance in the wild.\n2020-10-28 – Second ransomware sample uploaded to VT – Indicating a possible attacked organization.\n2020-11-01 – Third sample compilation date\n2020-11-01 – The first reported attack (Sunday; working day in Israel)\n2020-11-02 – The second reported attack\n\nThe Pay2Key propagation appears to be conducted as follows:\n\n1. Right after midnight, the attackers connected to a machine on the targeted network most probably via RDP.\n2. A machine is defined as Pivot / Proxy point within the network, likely by using a program named “ConnectPC.exe”. All outgoing\n\ncommunication between all ransomware processes within the network and the attacker’s C&C server will be going through this proxy\nfrom this point on.\n3. The attacker used psexec.exe to execute “Cobalt.Client.exe”, which is the Pay2Key ransomware itself, on different machines within the\n\norganization.\n\n## New Ransomware\n\nAnalyzing Pay2Key ransomware operation, we were unable to correlate it to any other existing ransomware strain, and it appears to be\ndeveloped from scratch.\n\nOnly a single engine on VirusTotal detected the uploaded ransomware samples as malicious, even though the ransomware does not use a\nPacker or protection of any kind, to hide its internal functionality.\n\nNumerous compilation artifacts point to the fact that internally, this ransomware is in fact named Cobalt (not to be confused with Cobalt Strike).\n\nWhile the identity of the attacker is unknown, inconsistent English wording within the various strings found in the code, as well as the ones we\nobserved in the Log file, suggests that the attacker is not a native English speaker.\n\n### Ransom Demand\n\nAfter successful encryption, the ransomware drops a ransom note to the system, customized to the targeted corporation in the form of\n```\n[ORGANIZATION]_MESSAGE.TXT . The ransom amount ranges between 7 and 9 Bitcoins, among the ransom notes we observed.\n\n```\n\n-----\n\nFigure 1: Pay2Key ransom note – even the ASCII-art is customized per organization\nWorth mentioning, that although the ransom note informs the victims for data breach, like other double extortion ransomwares do, we have yet\nto find any evidence that supports it.\n\n### Pay2Key\n\nOne interesting thing to note is that the Keybase account used by the attacker to chat with their victims has the same logo of the Pay2Key\nEOSIO smart contract system. A possible explanation is the fact that when searching “pay2key” in Google images, this is the first result.\n\nFigure 2: Pay2Key Keybase.io profile\n\n## Technical Analysis\n\n### Initial Access\n\nOur analysis of the attack by Pay2Key focused on the binary of the ransomware itself since some of the previous stages in the attack were not\naccessible to us. The attack, as we mentioned earlier, started by manually accessing one of the machines on the victim’s network, likely via\nRDP. The attacker copied and created multiple files on the machine, including:\n\n\n-----\n\nCoba t C e t e e ay ey a so a e\nConfig.ini – A configuration file that specifies “Server” and “Port”\nConnectPC.exe – Pivot / Proxy server\n\nAfter the creation of these files on the infected machine, the attackers execute `ConnectPC.exe . Then, they copied or downloaded the`\n[PsExec utility and used it to remotely execute the ransomware on other machines in the organization. In order to work properly, the](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)\nransomware requires a config file to be located in the same working directory. Thus, `Config.ini is required to be dropped in the victim’s`\ncomputer along with `Cobalt.Client.exe . In the cases we’ve seen, the Pay2Key ransomware was executed from paths of this template:`\n```\nC:\\Windows\\Temp\\[organization-name]tmp\\Cobalt.Client.exe\n\n### Configuration\n\n```\nThe artifacts we were able to put our hands on are the ransomware, `Cobalt.Client.exe, and the configuration file. The configuration file is`\na very simple INI file that contained two entries — Server and Port. To our surprise, the Server wasn’t an external command and control server,\nbut rather the IP of the initial infected machine. Thus, we believe that the original machine was using `ConnectPC.exe as a utility to relay`\ncommunication from victims inside the organization to the external control server. This approach increases the chance that the different\nmachines will be able to communicate because internal communication is more likely to be allowed. It also decreases the chances that the\naddress of the command and control will be revealed by analysts as there is only one machine in the organization that knows of it.\n\nThe configuration file that was used in the attack looked like this:\n```\n[Config]\nServer = <internal IP address>\nPort = 5050\n\n```\nIf the ransomware was executed with `--config [path] as a command-line argument, it will read the configuration file from the path`\nspecified in the argument.\n\n### The Ransomware\n\nThe Pay2Key ransomware is written in C++ and compiled using MSVC++ 2015. It heavily relies on Object-Oriented Programming and uses\nwell-designed classes for its operation. It also makes use of 3rd-party libraries like the popular libraries of Boost. Luckily, the ransomware was\nnot stripped and it contained a decent amount of debug logs as well as rich RTTI information.\n```\n$ diec Cobalt.Client.exe \nPE: compiler: Microsoft Visual C/C++(2015 v.14.0)[-]\nPE: linker: Microsoft Linker(14.0, Visual Studio 2015 14.0*)[EXE32,console]\n$ rabin2 -I Cobalt.Client.exe | grep \"compiled\\|pdb\"\ncompiled Mon Oct 26 12:37:49 2020\ndbg_file F:\\2-Sources\\21-FinalCobalt\\Source\\cobalt\\Cobalt\\Cobalt\\Win32\\Release\\Client\\Cobalt.Client.pdb\n\n```\nUpon execution, Pay2Key is reading the Server and Port keys from the configuration file. If a configuration file was not found in the current\nworking directory and wasn’t supplied in the command line arguments, the ransomware will write “no config file found” to a file at `.\\Cobalt-`\n```\nClient-log.txt . This log file will be used extensively by the ransomware during its execution. Newer versions of the ransomware are\n\n```\nmaking sure to remove this log file from the disk. The full list of supported log messages can be found in the appendix section of this article.\n\nIt then initializes the main class of the program, `Cobalt::DataProcessing::RansomwareEngine, followed by initialization of other important`\nclasses that are responsible, among other things, for communication, message handling, managing files and encryption.\n\nPay2Key generates a pair of RSA keys and sends the public key to the server over raw TCP. The keys will be used to set up secure\ncommunication between the ransomware and the server. After sending the key, the ransomware will wait for messages from the server. These\nmessages are parsed and handled by a custom Message Handler.\n\n**Supported Messages**\n\n**Message_ID** **Message_Name** **Notes**\n\n0 PublicKey Receive the server’s public key\n\n1 Identification Send to the server the IP address, the MAC address and the hostname.\n\n2 Config Receive a configuration from the server. The configuration is a very important aspect in the\nransomware as it contains valuable information such as a list of file extensions to encrypt, the name\nof the victim’s organization, the ransom note, the extension of the encrypted file, and more.\n\n3 ExceptionMessage\n\n4 SessionKey Receive unique session key from the server\n\n\n-----\n\n**Message_ID** **Message_Name** **Notes**\n\n5 JobFinished Announce that the encryption job is finished\n\n6 Abort Stop the execution\n\n7 GetClientList N/A\n\n8 ClientList N/A\n\n9 GetClientInformation Send, upon request, status of different tasks like the encryption task.\n\n10 ClientInformation Send status of different tasks like the encryption task.\n\n11 Acknowledge\n\n12 GetIdentification Send to the server, upon request, the IP address, the MAC address and the hostname.\n\n13 None N/A\n\nThe ransomware uses dedicated classes to handle different messages. We noticed some of these handlers and message types are not\nimplemented in the binaries we have, and some of them aren’t even checked by the message handler manager. This is another indication that\nthe ransomware is under active development. The missing messages, perhaps, can be part of code that is now removed, or alternatively —\ncode that wasn’t implemented yet.\n\nDuring the reverse engineering process of the ransomware samples, we utilized the fact they contain rich RTTI data. Such information helps\n[us understand the role of different pieces of the code and the relationship between them. With the help of Cutter, we were able to inspect the](https://cutter.re/)\ndifferent classes elegantly.\n\nFigure 3: RTTI is parsed By Cutter and shown\n\nin the Classes window\nThe most interesting message type is “Config” as it contains information that the ransomware use during the infection. Analyzing the\nransomware without the information from this message results in constant fallbacks to default configurations. Among other things, the\nconfiguration message contains the list of file extensions to encrypt, the file extension for encrypted files (default `.enc ), the name for the`\nransom note file (default to “salam” as in `SALAM_MESSAGE.TXT ), and the ransom note.`\n\nIt is interesting to mention, that both the file name and the ransom note specified the name of the infected organization. The attackers even\nwent all the way to generate an ASCII-Art with the name of the infected organization. The file name of the ransom note from the config will\nhave the following template `[ORGANIZATION]_MESSAGE.TXT . In the incidents we analyzed, the extension that was received from the server`\n\n\n-----\n\nas `pay` `ey, but t cou d` a e bee a yt g e se as t e a so a e s e b e e oug\n\nAt the end of the encryption process, Pay2Key will also terminate the MS SQL service using the following command `net stop mssqlserver`\n```\n> nul in order to release the files locked by the service. It might also replace the wallpaper of the victim, but we did not see this happening on\n\n```\nthe machines we analyzed.\n\n### Evolution\n\nWe analyzed multiple samples in a small period of time and we noticed several improvements in them. This means that Pay2Key is under\nactive development and the developers update it with more features. For example, in the latest version of the ransomware, we noticed that the\nattackers added a Self Killing mechanism, in addition to a new command-line argument `--noreboot .`\n\nThe new “housekeeping” mechanism is responsible for removing the files created by the attacker and restarting the machine.\n\nFigure 4: The function that is responsible for removing the\n\nransomware and its files and restarting the system\n\n### Encryption\n\nAs standard for [ransomware, a hybrid of symmetric and asymmetric cryptography is used for file encryption — using the AES and RSA](https://www.checkpoint.com/cyber-hub/threat-prevention/ransomware/)\nalgorithms. The C2 server supplies an RSA public key at runtime during communication. This implies that this ransomware doesn’t encrypt\noffline – if there’s no internet connection, or the C2 is down, then no encryption will occur. Recent years have seen some ransomware that\naggressively use cryptographic primitives to put the onus of creating successful contact with the operations on the victim (e.g. by embedding\nthe server public key in the executable), and at the time this was considered a technical improvement, but evidently the authors here prefer the\nclassic flavor.\n\n\n-----\n\nFigure 5: A symmetric RC4 key is generated and\n\nencrypted using an RSA public key.\nOne unusual thing to point out is the use of RC4 for some (not all) of its cryptographic functions. RC4 is a stream cipher, and is easier to\nmisuse in catastrophic ways; it is usually popular among malware authors for its ease of implementation, but here the authors actually used a\nthird party implementation (via the Windows API). This may be the first ever time we’ve seen malware authors essentially say “we have the\nwhole world of cryptography at our fingertips, third party libraries for everything, powerful symmetric crypto as far as the eye can see. Let’s\npick… RC4”. But, again, for this to really matter would require some sort of subtle error when invoking the cipher, and we were not able to\npinpoint one.\n\nFigure 6: The malware attempts to access a user key in the “pippo container”,\n\nand generates a new one if it is not there.\n\n\n-----\n\not e cu os ty s t e a a e s use o a custo a ed ey co ta e a ed p ppo co ta `e` Ot e a so a e p etty uc\nuniversally set a `null value for the` `szContainer parameter, which defaults to a new key container — then performs all cryptographic`\noperations with the context still open. It’s a piece of boilerplate code, a standard ransomware building block that is known to work and\ncybercriminals therefore copy, paste and forget; the fact that the authors did not use it outright is evidence for some amount of unhealthy\ncuriosity about the windows cryptographic API and its capabilities.\n\nFigure 7: An AES key is derived from a\n\nhash value.\nOne final deviation from the “classic” ransomware formula is the use of `CryptDeriveKey on a hashed value in order to derive an AES key`\n(instead of the traditional `CryptGenKey ). If the hash values were derived deterministically then the resulting key could be reconstructed, but`\nsome element of randomness in the hash (or any other number of possible separate tweaks on the client or server side) could render this\napproach viable. Still, we can’t repeat enough that when it comes to cryptography, reinventing the wheel is not advised.\n\n## Conclusion\n\nWhile the attack is still under investigation, the recent Pay2Key ransomware attacks indicate a new threat actor is joining the trend of targeted\nransomware attacks – presenting well designed operation to maximize damage and minimize exposure.\n\nThe attack was observed targeting the Israeli private sector so far, but looking at the presented tactics, techniques, and procedures we see a\npotent actor who has no technical reason to limit his targets list to Israel. The incidents are still under investigation, and we will update this\nblogpost with new findings if any new findings come to light.\n\nCheck Point’s [Anti-Ransomware solution defends organizations against the most sophisticated ransomware attacks, and safely recovers](https://www.checkpoint.com/solutions/anti-ransomware/)\nencrypted data, ensuring business continuity and productivity. Anti-Ransomware is offered as part of Check Point’s comprehensive endpoint\nsecurity suite, SandBlast Agent, to deliver real-time threat prevention to your organization’s endpoints.\n\n## Acknowledgments\n\nWe would like to thank the researchers from Claroty Research for their assistance and collaboration during this research.\n\n## Check Point Protections\n\n**Threat Cloud Protections:**\n\nRansomware.Win32.Pay2Key.TC.a\nRansomware.Win32.Pay2Key.TC.b\n\n**Threat Emulation Protections:**\n\nTrojan.Wins.Cobalt.F\n\n## Appendix\n\n\n-----\n\nIndicators of Compromise\n\nHashes\n\n**SHA256** **MD5** **SHA1**\n\n5BAE961FEC67565FB88C8BCD3841B7090566D8FC12CCB70436B5269456E55C00 F3076ADD8669D1C33CD78B6879E694DE C3FA78\n\nEA7ED9BB14A7BDA590CF3FF81C8C37703A028C4FDB4599B6A283D68FDCB2613F 4E615861B6D7D778FDC1AC2A61148FE9 EAFFD4\n\nD2B612729D0C106CB5B0434E3D5DE1A5DC9D065D276D51A3FB25A08F39E18467 7DB5DD6F2231DA6EB07D907312B1ABE9 A048C2\n\n### Classes\n\n[List of Classes retrieved from Cutter based on RTTI information in the binary:](https://cutter.re/)\n\n\n-----\n\n```\nCobalt::Common::IDecryptor\nCobalt::Common::IDirectory\nCobalt::Common::IEncryptor\nCobalt::Common::IException\nCobalt::Common::IExceptionFactory\nCobalt::Common::IFile\nCobalt::Common::IFileMatcher\nCobalt::DataAccess::IFileReader\nCobalt::DataAccess::IFileWriter\nCobalt::DataAccess::ISystemFileManager\nCobalt::DataAccess::IWindowsDrive\nCobalt::Peripheral::IPeripheralConnection\nClasses:\nCobalt::Common::MyselfKiller\nCobalt::Common::CommonExceptionFactory, Base Classes: : Cobalt::Common::IExceptionFactory\nCobalt::Communication::AbortMessage, Base Classes: : Cobalt::Communication::ISerializableMessage, Cobalt::Communication::IMessage\nCobalt::Communication::AcknowledgeMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::ClientInformation, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::ConfigurationMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::ExceptionMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage, Cobalt::Common::IException\nCobalt::Communication::ExceptionMessage_1, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage, Cobalt::Common::IException\nCobalt::Communication::GetClientInformation, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::GetIdentificationMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::IMessage\nCobalt::Communication::IMessageExtractor\nCobalt::Communication::IMessageFactory\nCobalt::Communication::IMessagePackager\nCobalt::Communication::ISerializableMessage\nCobalt::Communication::IdentificationMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::JobFinishedMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::MessageExtractor, Base Classes: : Cobalt::Communication::IMessageExtractor\nCobalt::Communication::MessageFactory, Base Classes: : Cobalt::Communication::IMessageFactory\nCobalt::Communication::MessagePackager, Base Classes: : Cobalt::Communication::IMessagePackager\nCobalt::Communication::PublicKeyMessage, Base Classes: : Cobalt::Communication::ISerializableMessage,\nCobalt::Communication::IMessage\nCobalt::Communication::SessionKey, Base Classes: : Cobalt::Communication::ISerializableMessage, Cobalt::Communication::IMessage\nCobalt::DataAccess::BasicFileReader, Base Classes: : Cobalt::DataAccess::IFileReader\nCobalt::DataAccess::BasicFileWriter, Base Classes: : Cobalt::DataAccess::IFileWriter\nCobalt::DataAccess::WindowsDirectory, Base Classes: : Cobalt::Common::IDirectory\nCobalt::DataAccess::WindowsDriveHandler, Base Classes: : Cobalt::DataAccess::IWindowsDrive\nCobalt::DataAccess::WindowsFile, Base Classes: : Cobalt::Common::IFile\nCobalt::DataAccess::WindowsFileManager, Base Classes: : Cobalt::DataAccess::ISystemFileManager\nCobalt::DataProcessing::AESEncryptor, Base Classes: : Cobalt::Common::IEncryptor\nCobalt::DataProcessing::ExtensionFileMatcher, Base Classes: : Cobalt::Common::IFileMatcher\nCobalt::DataProcessing::RSAClient, Base Classes: : Cobalt::Common::IEncryptor\nCobalt::DataProcessing::RSAServer, Base Classes: : Cobalt::Common::IDecryptor\nCobalt::Peripheral::TCPClient, Base Classes: : Cobalt::Peripheral::IPeripheralConnection,\nstd::enable_shared_from_this_class_Cobalt::Peripheral::TCPClient_\n\n### Suspected file paths\nC:\\Windows\\IME\\en-GB\\client\\Cobalt.Client.exe\nC:\\Windows\\IME\\en-GB\\mngr\\ConnectPC.exe\nC:\\Windows\\IME\\en-GB\\mngr\\binPS\\PsExec.exe\nC:\\Windows\\Temp\\[organization-name]tmp\\Cobalt.Client.exe\n\n Strings Written to the Log\n\n```\n\n-----\n\n```\nRestarting\nApplication Closed\nwrong config file\nno config file found\nPrevent ShutDown\nend of main procedure\nmessage is encrypted\nmessage is not encrypted\nCannot initialize RSA encryptor\nCannot initialize RSA decryptor\nError: receiving wrong response\nreceiving server public key\nError: receiving wrong response\nreceiving session_key\nError: receiving Configuration Message\nStart Encrypting Engine\nGetClientInformation message received\nSending Identification message again\nReceive Abort Message\nConnection Restarted\nSending Identification Message\nError in getting ipaddress and macaddress\nSending public key\nSending public key finished\nsend_session_key\nWait for threads to finish their encrypting job\nEnd of encrypting\nChange Computer Background\nSend Job Finished Message\nWe are not connected to serverr, trying 3 second later\nSend Message in Another Thread\nSend message again time out reached\nConnect Again to Server\nSending Message Process Finished\ncopy file to desktop background path\nReceive Data\nFailed To Get Data....\nStart Searching Details of Drive\nIts in Black Path List\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-06 - Ransomware Alert- Pay2Key.pdf"
    ],
    "report_names": [
        "2020-11-06 - Ransomware Alert- Pay2Key.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536000,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653761396,
    "ts_modification_date": 1653761396,
    "files": {
        "pdf": "https://archive.orkl.eu/73884707df9f6f86cfd1787d48eaa2f999a02b36.pdf",
        "text": "https://archive.orkl.eu/73884707df9f6f86cfd1787d48eaa2f999a02b36.txt",
        "img": "https://archive.orkl.eu/73884707df9f6f86cfd1787d48eaa2f999a02b36.jpg"
    }
}