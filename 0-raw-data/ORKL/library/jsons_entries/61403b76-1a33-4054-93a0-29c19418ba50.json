{
    "id": "61403b76-1a33-4054-93a0-29c19418ba50",
    "created_at": "2023-01-12T15:06:46.901164Z",
    "updated_at": "2025-03-27T02:05:47.320069Z",
    "deleted_at": null,
    "sha1_hash": "906cedfeda10b22d0d7462b57700d4baa26f5027",
    "title": "2020-03-19 - Stantinko’s new cryptominer features unique obfuscation techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T02:45:36Z",
    "file_modification_date": "2022-05-28T02:45:36Z",
    "file_size": 985552,
    "plain_text": "# Stantinko’s new cryptominer features unique obfuscation techniques\n\n**[welivesecurity.com/2020/03/19/stantinko-new-cryptominer-unique-obfuscation-techniques/](https://www.welivesecurity.com/2020/03/19/stantinko-new-cryptominer-unique-obfuscation-techniques/)**\n\nMarch 19, 2020\n\nESET researchers bring to light unique obfuscation techniques discovered in the course of\nanalyzing a new cryptomining module distributed by the Stantinko group’s botnet\n\n[Vladislav Hrčka](https://www.welivesecurity.com/author/vhrcka/)\n19 Mar 2020 - 11:30AM\n\n\n-----\n\nESET researchers bring to light unique obfuscation techniques discovered in the course of\nanalyzing a new cryptomining module distributed by the Stantinko group’s botnet\n\n[In the new cryptomining module we discovered and described in our previous article, the](https://www.welivesecurity.com/2019/11/26/stantinko-botnet-adds-cryptomining-criminal-activities/)\n[cybercriminals behind the Stantinko botnet introduced several obfuscation techniques,](https://www.welivesecurity.com/2017/07/20/stantinko-massive-adware-campaign-operating-covertly-since-2012/)\nsome of which have not yet been publicly described. In this article, we dissect these\ntechniques and describe possible countermeasures against some of them.\n\nTo thwart the analysis and avoid detection, Stantinko’s new module uses various\nobfuscation techniques:\n\nObfuscation of strings – meaningful strings are constructed and only present in\nmemory when they are to be used\nControl-flow obfuscation – transformation of the control flow to a form that is hard to\nread and the execution order of basic blocks is unpredictable without extensive\nanalysis\nDead code – addition of code that is never executed; it also contains exports that are\nnever called. Its purpose is to make the files look more legitimate to prevent detection\nDo-nothing code – addition of code that is executed, but that has no material effect on\nthe overall functionality. It is meant to bypass behavioral detections\nDead strings and resources – addition of resources and strings with no impact on the\nfunctionality\n\nOut of these techniques, the most notable are obfuscation of strings and control-flow\nobfuscation; we will describe them in detail in the following sections.\n\n## Obfuscation of strings\n\nAll the strings embedded in the module are unrelated to the real functionality. Their source\nis unknown and they either serve as building blocks for constructing the strings that are\nactually used or they are not used at all.\n\nThe actual strings used by the malware are generated in memory in order to avoid filebased detection and thwart analysis. They are formed by rearranging bytes of the decoy\nstrings – those embedded in the module – and using standard functions for string\nmanipulation, such as strcpy(), strcat(), strncat(), strncpy(), sprintf(), memmove() and their\nUnicode versions.\n\nSince all the strings to be used in a particular function are always assembled sequentially at\nthe beginning of the function, one can emulate the entry points of the functions and extract\nthe sequences of printable characters that arise to reveal the strings.\n\n\n-----\n\n_Figure 1. Example of string obfuscation. There are 7 highlighted decoy strings in the image. For_\n\n_example, the one marked in red generates the string “NameService”._\n\n## Control-flow flattening\n\n[Control-flow flattening is an obfuscation technique used to thwart analysis and avoid](https://reverseengineering.stackexchange.com/questions/2221/what-is-a-control-flow-flattening-obfuscation-technique)\ndetection.\n\n\n-----\n\nCommon control-flow flattening is achieved by splitting a single function into basic blocks.\nThese blocks are then placed as dispatches into a switch statement inside of a loop (i.e.\neach dispatch consists of exactly one basic block). There is a control variable to determine\nwhich basic block should be executed in the switch statement; its initial value is assigned\nbefore the loop.\n\nThe basic blocks are all assigned an ID and the control variable always holds the ID of the\nbasic block to be executed.\n\nAll the basic blocks set the value of the control variable to the ID of its successor (a basic\nblock can have multiple possible successors; in that case the immediate successor can be\nchosen in a condition).\n\n_Figure 2. Structure of common control-flow-flattening loop_\n\nThere are various approaches to resolving this obfuscation, such as using IDA’s microcode\n[API. Rolf Rolles used this method to identify these loops heuristically, extract the control](https://www.hexblog.com/?p=1248)\nvariable from each flattened block and rearrange them in accordance with the control\nvariables.\n\nThis – and similar – approaches would not work on Stantinko’s obfuscation, because it has\nsome unique features compared to common control-flow-flattening obfuscations:\n\nCode is flattened on the source code level, which also means the compiler can\nintroduce some anomalies into the resulting binary\nThe control variable is incremented in a control block (to be explained later), not in\nbasic blocks\nDispatches contain multiple basic blocks (the division may be disjunctive, i.e. each\nbasic block belongs to exactly one dispatch, but sometimes the dispatches intertwine,\nmeaning that they share some basic blocks)\nFlattening loops can be nested and successive\nMultiple functions are merged\n\n\n-----\n\nThese features show that Stantinko has introduced new obstacles to this technique that\nmust be overcome in order to analyze its final payload.\n\n## Control-flow flattening in Stantinko\n\nIn most of Stantinko’s functions, the code is split into several dispatches (described above)\nand two control blocks — a head and a tail — that control the flow of the function.\n\nThe head decides which dispatch should be executed by checking the control variable. The\ntail increases the control variable by a fixed constant and either goes back to the head or\nexits the flattening loop:\n\n_Figure 3. Regular structure of Stantinko’s control-flow-flattening loop_\n\nStantinko appears to be flattening code of all functions and bodies of high-level constructs\n(such as a for loop), but sometimes it also tends to choose seemingly random blocks of\ncode. Since it applies the control-flow-flattening loops on both functions and high-level\nconstructs, they can be naturally nested and there happen to be multiple consecutive loops\ntoo.\n\nWhen a control-flow-flattening loop is created by merging code of multiple functions, the\ncontrol variable in the resulting merged function is initialized with different values, based on\nwhich of the original functions is called. The value of the control variable is passed to the\nresulting function as a parameter.\n\n\n-----\n\nWe overcame this obfuscation technique by rearranging the blocks in the binary; our\napproach is described in the next section.\n\nIt’s important to note that we observed multiple anomalies in some of the flattening loops\nthat make it harder to automate the deobfuscation process. The majority of them seem to\nbe generated by the compiler; this leads us to believe that the control-flow-flattening\nobfuscation is applied prior to compilation.\n\nWe witnessed the following anomalies; they can appear separately or in combination:\n\n1. Some dispatches can be just dead code – they will never be executed. (Examples in\n\nthe section “Dead code inside the control-flow-flattening loop” below.)\n2. Basic blocks inside of dispatches may intertwine, this means that they can contain\n\njoint code.\n\n\n-----\n\n_Figure 4. Structure of a flattening loop with dispatches sharing joint code_\n\n1. There are direct jumps from dispatches to a block outside the flattening loop, right\n\nbehind the tail, and to blocks that return from the function.\n\n\n-----\n\n_Figure 5. Structure of a flattening loop whose dispatch breaks directly out of the loop. Only one of_\n\n_the dashed lines occurs._\n\n1. There can be multiple tails, or no tail at all – in the latter case, the control variable is\n\nincreased at the end of each dispatch.\n\n_Figure 6. Structure of a flattening loop without any tail (left) and with multiple tails (right)_\n\n1. The head doesn’t contain a jump table right away. Instead, there can be multiple jump\n\ntables and there’s a sequence of branches, prior to the jump tables, binary-searching\nfor the correct dispatch.\n2. The value of the control variable might be used inside of the dispatches; this means\n\nthat the control value has to be preserved/computed even in the deobfuscated code.\n\n\n-----\n\n_Figure 7. The EDI register contains the control variable that is passed to EAX and used inside the_\n\n_dispatch. The dispatch is highlighted with red._\n\n1. Sometimes, the tail contains instructions that are crucial to restoring the correct values\n\nof registers and local variables. During deobfuscation, we remove the tail, so we must\nmake sure these instructions are executed after each dispatch, even if they are not\npart of it.\n2. There are cases where there is no dispatch whose ID is, at that moment, equal to the\n\ncurrent value of the control variable.\n\n### Deobfuscation\n\nOur goal is to build a deobfuscation function able to rearrange the code on the binary level\nto make it easily readable for a reverse engineer, while keeping the resulting code\nexecutable. It has to be able to recognize all basic blocks belonging to each dispatch and to\ncopy and move them arbitrarily.\n\nDuring basic block manipulation one has to make sure to recalculate relative addresses of\nbranch targets and addresses forming legitimate jump tables correctly.\n\nOur solution doesn’t take relocations into account; hence one always needs to make sure\nthat the sample is loaded at the same base address.\n\nWe used a reverse-engineering framework that provides us with some useful features, such\n[as assembly manipulation and a symbolic execution engine.](https://en.wikipedia.org/wiki/Symbolic_execution)\n\nThe core parameters of the function are the addresses of the control blocks (head and\ntails), range and step of the control variable, names of the registers, and the memory\nlocations containing the control variable, control_locations, and, lastly, the address of the\nfirst basic block following the loop, which we define as next_block. It obviously also requires\nthe address of the function to be deobfuscated and the address where the deobfuscated\nfunction should be placed.\n\n\n-----\n\nWe expect multiple tails due to anomaly 4 above.\n\nThe deobfuscation function iterates through the range of the control variable by its step\nvalue to simulate the real control-flow-flattening loop; in each iteration, the function starts by\ngenerating a context to deal with anomalies 6 and 7. The context is to be placed before the\nrespective dispatch.\n\nThe context is a basic block containing instructions assigning registers and memory\naddresses and keeping control_locations updated. The context of the first iteration just\npreserves the value of the control variable. (Note: no context is required to deal with\nanomaly number 4.)\n\nThe last basic blocks of the previous dispatch (or, in case of the first dispatch, the basic\nblocks right before the head) are redirected to the created context.\n\nThe initial basic block of a dispatch that is to be executed (in each of the iterations) is\ndetermined by the current value of the control variable (dispatch ID).\n\nThe actual basic block is found by symbolically executing the binary-search algorithm,\nwhich searches for a basic block with the current ID. The initial state of the symbolic\nexecution contains control_locations assigned to the current value of the control variable.\n\nWe stop the symbolic execution at the first basic block that (i) contains an unconditional\nbranch, or, (ii) has a destination that cannot be determined by the control variable.\n\nOne could also emulate this part or use a framework that would be able to simplify the\nbinary-search algorithm into a jump table and then convert that into a switch statement\ninstead. These methods deal with anomaly 5.\n\nIn case there’s no dispatch for a particular ID, the loop just continues and increases the\ncontrol variable due to anomaly 8.\n\nThe whole dispatch (i.e., each basic block that is reachable from its initial basic block to its\nhead, tail(s) or next_block) is then copied after the preceding context block (as described\nabove). It cannot be just moved due to anomaly 2.\n\nThere are currently two uncommon cases that can occur due to anomaly 3; both result in\npremature termination of the iteration. The cases happen when a dispatch:\n\nReturns from the function\nPoints to next_block\n\nFinally, when the iteration ends, the last basic blocks of the previous dispatch (or basic\nblocks right before the head, in case of the first dispatch), are redirected to the first basic\nblock outside the flattening loop.\n\n\n-----\n\nThis method solves anomaly 1 automatically, since the dead dispatches won t be copied\ninto the resulting code.\n\n_Figure 8. Example of an obfuscated function (left) and its deobfuscated counterpart (right). The_\n\n_dispatches are executed in this order: dispatch1 → dispatch2 → dispatch3._\n\nThese changes are then written to the virtual address where the deobfuscated function\nshould be placed.\n\nIn case we are dealing with flattening of merged functions, we point references to the target\nfunction having the identical initial value of the control variable in the parameter, to the\naddress of the new deobfuscated function.\n\n_Figure 9. Example of obfuscated (right) and deobfuscated (left) control flow graph_\n\n### Possible improvements\n\n\n-----\n\nThe approach described above operates exclusively at the assembly level, which isn t\nsufficient to make the deobfuscation fully automated.\n\nThe reason is that accurate recognition of all patterns is rather difficult, mostly due to\nvarious compiler optimizations present in the source code level obfuscations. The pattern\nrecognition is necessary in our case, for example, to automatically fill in the parameters of\nthe core deobfuscation function.\n\nThe advantage of this approach is that the resulting code can be executed right away and\none can use arbitrary reverse-engineering tools for further analysis.\n\nThis approach could be further improved by the use of a progressive intermediate\nrepresentation (IR), which provides optimization techniques that would, among other things,\nget rid of most of the anomalies generated by compilers, and thus allow automated\nrecognition of the parameters required by the deobfuscation function.\n\nOne could also use the selected IR for both recognition and the deobfuscation of which the\nlatter, in our case, consists of rearranging of basic blocks.\n\nThe drawback of this option is that the resulting code would also be in the IR, which means\nthat the consecutive analysis would have to be done with the IR as well. The number of\ntools working with the IR and their functionality could be rather limited, especially when it\ncomes to visualization. Due to this, it’d be hard to analyze a more complex sample,\nespecially when there are additional layers of obfuscation. We wouldn’t be able to execute\nthe resulting code either.\n\n## Dead code\n\nBy “dead code” we mean code that either is never executed, or has no overall impact on the\nfunctionality. The malware contains dead code mostly in the flattened loops (effectively\nremoved by our above-explained deobfuscation function), but there are also, for example,\nunused exports and there’s no way to distinguish the unused exports from the legitimate\nones.\n\nAs for dead code in the flattened loop: for Stantinko, it is always inside the dispatches that\nare never executed. It may contain modified parts of legitimate software such as WinSpy++\n(see the example below) that was obfuscated in the same way.\n\n\n-----\n\n_Figure 10. Deobfuscated part of dead code inside a dispatch containing legitimate WinSpy++ code_\n\n\n-----\n\n_Figure 11. The equivalent part of code (as in Figure 10) in the official release of WinSpy++_\n\n## Do-nothing code\n\nEven after the unflattening operation, there are parts of code that have no purpose at all,\nintermingled with the lines of the “real code”. This is probably meant to obscure the analysis\neven more or to bypass behavioral detection.\n\n\n-----\n\n-----\n\n_Figure 12. Marked parts are redundant code that iterates through the first two disk volume names_\n\n_and then does nothing with the returned values_\n\nSince the code isn’t much harder to read, we decided not to take any actions and analyzed\nthe code at this point.\n\nTo optimize out this do-nothing code in general: we’d have to, for example, generate\ndisjunct [slices containing all the Windows API calls that are present. The slicing criterion](https://en.wikipedia.org/wiki/Program_slicing)\nwould consist of all the parameters of the calls in each disjunct slice.\n\nSubsequently we’d execute the slices with a prepared call stack in a controlled environment\nand we’d consider a slice to be functional if it does at least one of the following:\n\nmake some changes to the underlying OS\nrequire an initial value of a function parameter or a global variable to be known\nassign a value of a function parameter or a global variable\ndirectly affect overall control flow of the function\n\n## Conclusion\n\nThe criminals behind the Stantinko botnet are constantly improving and developing new\nmodules that often contain non-standard and interesting techniques.\n\nWe have described their new cryptomining module previously; for the module’s functional\n[analysis, refer to our November 2019 blogpost. This module displays several obfuscation](https://www.welivesecurity.com/2019/11/26/stantinko-botnet-adds-cryptomining-criminal-activities/)\ntechniques aimed at protecting against detection and thwarting analysis. We analyzed the\ntechniques and described a possible approach to deobfuscating some of these techniques.\n\n_Note: For IoCs and the list of techniques mapped to the MITRE ATT&CK taxonomy, please_\n_refer to_ _[our previous article describing this cryptominer’s functionality.](https://www.welivesecurity.com/2019/11/26/stantinko-botnet-adds-cryptomining-criminal-activities/)_\n\n19 Mar 2020 - 11:30AM\n\n### Sign up to receive an email update whenever a new article is published in our Ukraine Crisis – Digital Security Resource Center\n\n\n-----\n\n### Newsletter\n\n Discussion\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-19 - Stantinko’s new cryptominer features unique obfuscation techniques.pdf"
    ],
    "report_names": [
        "2020-03-19 - Stantinko’s new cryptominer features unique obfuscation techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536006,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1653705936,
    "ts_modification_date": 1653705936,
    "files": {
        "pdf": "https://archive.orkl.eu/906cedfeda10b22d0d7462b57700d4baa26f5027.pdf",
        "text": "https://archive.orkl.eu/906cedfeda10b22d0d7462b57700d4baa26f5027.txt",
        "img": "https://archive.orkl.eu/906cedfeda10b22d0d7462b57700d4baa26f5027.jpg"
    }
}