{
    "id": "5d435819-ae61-47d0-b2bf-5b780b058ad4",
    "created_at": "2023-01-12T15:09:41.538417Z",
    "updated_at": "2025-03-27T02:09:29.581952Z",
    "deleted_at": null,
    "sha1_hash": "2ccae562b30cb2caad86c1fdaf2a358b4fac8015",
    "title": "2022-04-19 - Using Emulation Against Anti-Reverse Engineering Techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T18:21:28Z",
    "file_modification_date": "2022-05-28T18:21:28Z",
    "file_size": 92760,
    "plain_text": "# Using Emulation Against Anti-Reverse Engineering Techniques\n\n**[fortinet.com/blog/threat-research/Using-emulation-against-anti-reverse-engineering-techniques](https://www.fortinet.com/blog/threat-research/Using-emulation-against-anti-reverse-engineering-techniques)**\n\nThreat Research\n\nBy [Gergely Revay | April 19, 2022](https://www.fortinet.com/blog/search?author=Gergely+Revay)\n\nThe life of a malware reverse-engineer is not always easy. You might think that it is all fun\nand games, but in reality, it is bits and assembly. And as it is true for the whole security\nindustry, it is a cat and mouse game with malware developers. As we continuously expose\ntheir [malware, which leads us to learn more about the attackers and develop](https://www.fortinet.com/resources/cyberglossary/malware?utm_source=blog&utm_campaign=malware)\ncountermeasures, they keep trying to implement new ways of slowing down analysts and\n[reverse engineering. In a recent blog, we analyzed the Pandora ransomware and discussed](https://www.fortinet.com/blog/threat-research/looking-inside-pandoras-box)\nthat it is filled with anti-reverse-engineering techniques, and has multiple layers of code\nobfuscation.\n\nIn this blog post, instead of talking about what we discovered in the Pandora ransomware, I\nwould like to discuss how we did that. More specifically, we will fight the function call\nobfuscation and string encryption in this sample, using emulation. We will implement an\nIDAPython script using the flare-emu framework to turn the disassembly in IDA Pro more\nreadable. This will be a great help in the static analysis of the sample.\n\n**Affected Platforms: Windows**\n\n## Challenges in Pandora\n\n[For the detailed list of challenges we faced while reversing Pandora, read our analysis blog.](https://www.fortinet.com/blog/threat-research/looking-inside-pandoras-box)\nIn this post I will discuss two specific anti-reverse-engineering techniques that we’ve seen in\nPandora:\n\n-  Function call obfuscation with opaque predicates\n\n-  Encrypted strings\n\nFirst, let’s discuss what these challenges are exactly.\n\n### Function Call Obfuscation with Opaque Predicates\n\nFigure 1 shows what a simple function call looks like in the Pandora ransomware after it was\nunpacked.\n\nFigure 1 - Standard function call in Pandora\n\n\n-----\n\nWe can see that the address of the function that is being called is calculated in runtime.\ncs:qword_7FF6B6FF9AB8 seems to be the base address of some kind of function address\ntable. Then we use hardcoded values to find the right function pointer in that table and that is\nwhat we load into rax before calling it. An opaque predicate generally means an expression\nin the program whose outcome is known to the programmer, but it still needs to be evaluated\nin runtime. It is used in many different ways as an obfuscation and anti-analysis technique. In\nthis case, the value that goes in rax is fixed, but because it still has to be calculated in\nruntime it disrupts static-analysis tools.\n\nIf we use Figure 1 as an example, the address in rax is calculated like this:\n\nrax = *(*address_table_base + 0x260BB2E4) + 0xFFFFFFFFAAF7CABC)\n\nor in decimal:\n\nrax = *(*address_table_base + 638300900) - 1426601284)\n\nThe trivial solution for such a problem is to run the malware in a debugger and get the\naddress from there. But in this sample all function calls were like this (except those in the\nstatically linked libraries). That means that we would have needed to break at every function\ncall in the debugger just to have the slightest idea of what is happening in the malware. This\ncalled for automation.\n\n### Encrypted Strings\n\nAnother challenge of this particular ransomware sample was that all the interesting strings\nwere encrypted. There were a lot of plain text strings in the binary (shown in Figure 2), but\nthey were mostly Windows API function names and the strings in the embedded libraries.\nNone of the strings that would help us understand what the malware is doing are available in\nplain text. This is very common in modern malware, thus the solution to this challenge could\nbe used against a wide variety of malware.\n\nFigure 2 - Strings in the Pandora sample\n\nUsually when one encounters malware with encrypted strings, there are two approaches:\n\n-    Use a dynamic approach, such as debugging or emulation, and use the malware’s own\nstring decryption functions to do the work.\n\n-    Understand the decryption function in such detail that one can reimplement it in a\nsimple script. This is usually the way to go when the encryption is a simple one-byte XOR.\n\nIn the case of Pandora, there is not one, but at least 14 different string decryption functions,\nso reimplementing the decryption algorithm might not always be feasible.\n\n\n-----\n\n## Emulation\n\nEmulation allows us to pretend that the code is running on a CPU, but instead of running on\na real CPU, the emulation software runs the code. Emulation is usually very slow compared\nto real execution. However, it allows us full control over what we want to run and a very high\nlevel of interaction with the emulated code. With an emulator, for instance, we can emulate\njust one function of the malware (or even just a couple of lines of code) and evaluate the\nstate of the program at every instruction. A big advantage of emulation in this case is that we\ncan do it directly in IDA Pro.\n\n### flare-emu\n\n[flare-emu is an emulation framework created by the FLARE team at Mandiant. It builds on](https://github.com/mandiant/flare-emu)\n[the well-known emulation engine called Unicorn Engine and IDAPython. One could use the](https://www.unicorn-engine.org/)\nUnicorn Engine directly but flare-emu hides some of its complexities. Essentially, one can\ndefine what (which part of the code) one wants to emulate and define callback functions for\nspecific hooks that will be called when the emulation reaches that hook. A good example is\nthe callHook parameter, which accepts a callback function that will be called every time a\nCALL instruction is about to be emulated. In this callback function we can implement\nwhatever we want to do in that situation, i.e., dump registers, change data, skip call, etc.\nflare-emu turned out to be very straightforward and relatively easy to use (which does not\nmean that I did not need to look into its source code to figure out a few things).\n\n## Solving the Challenges\n\nAfter this extensive introduction, let’s finally write some code to solve these challenges with\nan IDAPython script.\n\n### Function Call Obfuscation\n\nFigure 3 shows again the problem we are trying to solve first. This is the first function call in\nthe main()function in the unpacked part of Pandora’s code. At this point we can be fairly sure\nthat if we emulate the main()function and check rax’s value before it is called then we get the\nright result. When we are already there, we could read out the arguments of the function call\nas well and add all this information to the assembly code as a comment in IDA Pro.\n\nFigure 3 - Function call obfuscation\n\nLet’s start to put together our IDAPython script. Figure 4 shows how we can initialize the\nemulation. When we launch the script, it should emulate the function in which the cursor\nstands at the moment in IDA (returned by get_screen_ea()).\n\nFigure 4 - Initialize the emulation\n\n\n-----\n\nTo initialize flare-emu, we just need to instantiate an EmuHelper. Flare-emu offers different\nways to run our emulation. We use the emulateRange() function, which is used to specify a\nmemory range we want to emulate. We set the start address to the beginning of the function\nand the end address can be omitted (None in python) which means that the emulation will\nrun until a return type instruction is reached. Note that the iterateAllPaths() instead of the\nemulateRange() should also work, however that caused problems due to another\nobfuscation technique in Pandora, which is not in the scope of this post. But in a less\ncomplex malware iterateAllPaths()could be a better option.\n\nWhen one of flare-emu’s emulation functions is called (emulateRange()in this case), then the\nemulation starts. The framework allows us to provide additional details for the emulation,\nsuch as processor state with registers and stack, or data for the callback functions, but we\ndon’t need those at this point.\n\nemulateRange()allows us to define callback functions for different hooks:\n\n-    instruction hook: called before the emulation of every instruction. I used this to color\nevery instruction that was emulated in IDA to visualize the coverage of the emulation.\n\n-    call hook: called whenever a CALL type of instruction will be emulated. Note that the\ncalled function is not emulated by default.\n\n-    memory access hook: called whenever memory is accessed for reading or writing.\n\nFor our current task we only need the callHook. As you can see in line 9 in Figure 4, we\nalready passed the call_hook function name as the callHook parameter (might not be the\ncleverest naming). Next, we need to define the callHook function, which can be seen in\nFigure 5.\n\nFigure 5 - First implementation of call_hook ()\n\nWe created the call_hook() function, that will be called by the emulator every time before a\nCALL instruction is emulated. In its current state, this function will log that it was executed,\nthen uses the analysisHelper to check whether the operand in the current CALL instruction is\na register or not. If not, then we can return because only the register case is interesting for\nus. Then we recover the register’s name (operand_name) and its value (operand_name) and\nlog them for now. If we run the script against the main function, then we get the results in\nFigure 6. Note that due to the numerous other evil obfuscations in the Pandora code, this\nsimple script won’t be able to emulate the whole function. But this can be done by extending\nthe script.\n\nFigure 6 - Results of the first test\n\n\n-----\n\nThe emulation found three CALL instructions and printed the values of the operand registers.\nIf we think about it, we have mostly solved the problem of function call obfuscation, because\nwe now know which addresses are called by the different CALL instructions. Now we just\nneed to add this to the disassembly in IDA. These are the things we want to do in IDA\nwhenever we resolve a CALL instruction:\n\n-    Add a comment with the address of the function that is being called\n\n-    Add a comment with the arguments for that function call\n\n-    Add a cross-reference in IDA to the function that is called\n\nFigure 7 shows the updated code.\n\nFigure 7 - Adding comment and cross-reference\n\nWhen creating the comment we use a nice feature from flare-emu. It allows us to get the\nfunction parameters in an architecture-independent way. This malware is x86_64 so we\ncould just take rcx, rdx, r8, r9, and the stack, but this way we don’t have to deal with that.\nOne of the arguments the call hook gets is the arguments variable and this will contain the\nvalues flare-emu thinks are the parameters of this function call. Of course, without analyzing\nthe called function, we won’t know how many parameters are expected so we will just print\nall of them.\n\nAt the end (line 23) we add an IDA cross-reference, which will be a great help further along\nin our analysis. If we run this code again on the main function, we get the result in Figure 8.\n\nFigure 8 - Results of the function call resolution\n\n### Encrypted String\n\nNow that we have the first problem out of the way, and have an emulation framework to work\nwith, we can move onto our second challenge, decrypting the strings. To be able to know\nwhich function to emulate to get the strings decrypted, our only requirement is that we need\nto know which functions are decryption functions. As always, reverse engineering is an\niterative process. Once we run the script we wrote on the main function, then we can start to\nanalyze the called functions. So how do we figure out if a function is a decryption function?\n(Spoiler: 0x7ff6b6f971e0 points to a decryption function.)\n\nA)  We see it in IDA. Without diving deep in the function at 0x7ff6b6f971e0, we can see in\nthe graph view (Figure 10) that it is fairly simple and has some loops.\n\nFigure 9. - Graph view at the function at 0x7ff6b6f971e0\n\n\n-----\n\nIf we scroll through the code, we find the basic block in Figure 10, where we see that it\niterates through some value and XORs it. This indicates that it might be an XOR-based\nencoding/encryption.\n\nFigure 10 - XOR indicates decoding/decryption\n\nB)  We see it in a debugger. Parallel to our static analysis, we of course can also debug the\nmalware (in a safe environment). In the debugger when we see a function that gets some\naddresses as an input and returns a string, that could mean that it is a decryption function.\nFigure 11 shows when the function at 0x7ff6b6f971e0 returns and indeed it returns the string\n“ThisIsMutexa” in rcx.\n\nFigure 11 - The decrypted string appears in rcx\n\nOnce we know that a function is a decryption function, we can rename it accordingly (we\nused mw_decrypt_str()). Interestingly, Pandora uses multiple decryption functions, which we\ndiscovered slowly as we dived deeper into the code. At the end we identified 14 different\ndecryption functions, however most of them looked very similar to Figure 9, which allowed us\nto quickly see if a function is just another decryption function.\n\nOnce we know (some) of the decryption functions, we can improve our IDAPython script to\nemulate the function call whenever we see that a decryption function is called. This is\nactually very similar to one of the examples in flare-emu’s documentation, which shows how\nwell such code can often be reused.\n\nFigure 12 shows the updated call_hook() function. Starting from line 23, we first check\nwhether the function at the address we are calling has a name that contains the string\nmw_decrypt_str. This is how we decide whether the called function is a decryption function.\nThis is not a very scientific method, but we want to reverse malware, not get a PhD.\n\nFigure 12 - Adding decryption to the call_hook()\n\nIf it is a decryption function, then we call the decrypt()function in our script. This will return\nthe decrypted plain text string. Then we create a comment that will include the decrypted\nstring as well.\n\nHow the decryption is emulated can be seen in Figure 13. We create a new EmuHelper\ninstance and when starting emulateRange, we use the function name (fname) to get the\nfunction’s address as the start address. We also pass the first four elements of the argv array\nas the argument registers. At the end we return the value in argv[0],  which should contain the\naddress of the decrypted string.\n\nFigure 13 - Emulating the decryption\n\n\n-----\n\nAfter running the script in IDA, the results are shown in Figure 12. The decrypted string was\nThisIsMutexa, which was added to the comment and logged in the output.\n\nFigure 14 - String decryption is successful\n\nNow we can automatically decrypt strings. As we progress with the analysis of the code and\nmore decryption functions are discovered, we can just rerun the script on the functions that\ncall these decryption functions to recover the plain text strings.\n\n## Conclusion\n\nThe Pandora ransomware is packed with obfuscation and anti-reverse-engineering\ntechniques. In this post we looked at two of these: function call obfuscation and string\nencryption. We used the flare-emu emulation framework to write an IDAPython script to\nresolve the addresses and arguments of the function calls as well as emulate the decryption\nfunctions to recover the strings as plain text. The final script can be developed further to deal\n[with the other anti-reverse-engineering challenges discussed in the deep dive analysis of the](https://www.fortinet.com/blog/threat-research/looking-inside-pandoras-box)\nPandora ransomware.\n\n## Fortinet Protection\n\nThe analyzed Pandora ransomware sample is detected by the following (AV) signature:\n\nW64/Filecoder.EGYTYFD!tr.ransom\n\nFortiEDR also detects and mitigates execution of Pandora ransomware through the\ncombination of behavioral analysis, and integration with machine learning and threat\nintelligence feeds. Execution of the Pandora sample analyzed as part of this blog triggers\nseven rules resulting in nine security events. Triggered rules were a result of pre-execution\nanalysis and post-execution behaviors. These security events can be observed below in\nFigure 15.\n\nFigure 15 - FortiEDR security events generated following execution of Pandora ransomware\nsample. Note that during this execution, FortiEDR was set to only log events rather than\nmitigate, to properly demonstrate detections post-execution.\n\nPre-execution detections included: identifying the malicious file (hash based), detection of a\nsuspicious packer, and presence of writeable code. Post-execution detections included:\ndetection of each file encryption attempt, detection of encrypted file rename attempt,\ndropping of the ransom note, and attempts to access SMB shares.\n\nIn Protect mode, FortiEDR will detect and mitigate detected behavior. In the case of\nPandora, this will prevent execution of the ransomware, mitigating malicious activity before it\noccurs, and will prevent subsequent file encryption attempts if the adversary is able to\n\n\n-----\n\nexecute the sample. The post-exploitation detections are not dependent on signature,\nmeaning they will effectively mitigate this activity for newer Pandora variants even with no\nprior knowledge of the samples.\n\n## IOCs\n\nMutex: ThisIsMutexa\n\nRansom note: Restore_My_Files.txt\n\nSHA256 hash of hardcoded public key:\n7b2c21eea03a370737d2fe7c108a3ed822be848cce07da2ddc66a30bc558af6b\n\nSHA256 hash of sample:\n5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b\n\n## ATT&CK TTPs\n\n**TTP Name** **TTP ID** **Description**\n\n\nObfuscated Files or Information:\nSoftware Packing\n\n\nImpair Defenses: Disable Windows\nEvent Logging\n\n\nImpair Defenses: Disable or Modify\nTools\n\n\nT1027.002 Modified UPX packer\n\nT1562.002 Disable event logging\n\nT1562.001 Bypass AMSI\n\n\nData from Local System T1005 Searches unmounted drives and\npartitions\n\nModify Registry T1112 Cryptographic keys are stored in\nthe registry\n\nData Encrypted for Impact T1486 As a ransomware it encrypts files\n\nCommand and Scripting Interpreter T1059 Uses cmd.exe to remove the\nshadow copies\n\nSystem Information Discovery T1082 Collects system information with\nGetSystemInfo()\n\n\n-----\n\nFile and Directory Discovery T1083 Discovers drives and enumerates\nfilesystems\n\nInhibit System Recovery T1490 Deletes shadow copies\n\nService Stop T1489 Terminates processes if they lock a\nfile\n\n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[and the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-19 - Using Emulation Against Anti-Reverse Engineering Techniques.pdf"
    ],
    "report_names": [
        "2022-04-19 - Using Emulation Against Anti-Reverse Engineering Techniques.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b69037ec-2605-4de4-bb32-a20d780a8406",
            "created_at": "2023-01-06T13:46:38.790766Z",
            "updated_at": "2025-03-27T02:00:02.919758Z",
            "deleted_at": null,
            "main_name": "MUSTANG PANDA",
            "aliases": [
                "TEMP.HEX",
                "TA416",
                "TANTALUM",
                "Twill Typhoon",
                "Earth Preta",
                "Stately Taurus",
                "LuminousMoth",
                "Polaris",
                "BRONZE PRESIDENT",
                "HoneyMyte",
                "Red Lich"
            ],
            "source_name": "MISPGALAXY:MUSTANG PANDA",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9baa7519-772a-4862-b412-6f0463691b89",
            "created_at": "2022-10-25T15:50:23.354429Z",
            "updated_at": "2025-03-27T02:00:55.45162Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Mustang Panda",
                "TA416",
                "RedDelta",
                "BRONZE PRESIDENT"
            ],
            "source_name": "MITRE:Mustang Panda",
            "tools": [
                "Cobalt Strike",
                "RCSession",
                "NBTscan",
                "PoisonIvy",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2ee03999-5432-4a65-a850-c543b4fefc3d",
            "created_at": "2022-10-25T16:07:23.882813Z",
            "updated_at": "2025-03-27T02:02:10.0116Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Bronze President",
                "Camaro Dragon",
                "Earth Preta",
                "HoneyMyte",
                "Mustang Panda",
                "Operation SMUGX",
                "Operation SmugX",
                "PKPLUG",
                "Red Lich",
                "Stately Taurus",
                "TEMP.Hex"
            ],
            "source_name": "ETDA:Mustang Panda",
            "tools": [
                "9002 RAT",
                "AdFind",
                "Agent.dhwf",
                "Agentemis",
                "CHINACHOPPER",
                "China Chopper",
                "Chymine",
                "ClaimLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "DCSync",
                "DOPLUGS",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Farseer",
                "Gen:Trojan.Heur.PT",
                "HOMEUNIX",
                "Hdump",
                "HenBox",
                "HidraQ",
                "Hodur",
                "Homux",
                "HopperTick",
                "Hydraq",
                "Impacket",
                "Kaba",
                "Korplug",
                "LadonGo",
                "MQsTTang",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "NBTscan",
                "NetSess",
                "Netview",
                "Orat",
                "POISONPLUG.SHADOW",
                "PUBLOAD",
                "PVE Find AD Users",
                "PlugX",
                "Poison Ivy",
                "PowerView",
                "QMAGENT",
                "RCSession",
                "RedDelta",
                "Roarur",
                "SPIVY",
                "ShadowPad Winnti",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TONEINS",
                "TONESHELL",
                "TVT",
                "TeamViewer",
                "Thoper",
                "TinyNote",
                "WispRider",
                "WmiExec",
                "XShellGhost",
                "Xamtrav",
                "Zupdax",
                "cobeacon",
                "nbtscan",
                "nmap",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536181,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653762088,
    "ts_modification_date": 1653762088,
    "files": {
        "pdf": "https://archive.orkl.eu/2ccae562b30cb2caad86c1fdaf2a358b4fac8015.pdf",
        "text": "https://archive.orkl.eu/2ccae562b30cb2caad86c1fdaf2a358b4fac8015.txt",
        "img": "https://archive.orkl.eu/2ccae562b30cb2caad86c1fdaf2a358b4fac8015.jpg"
    }
}