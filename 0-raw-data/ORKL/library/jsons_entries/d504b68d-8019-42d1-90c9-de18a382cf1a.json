{
    "id": "d504b68d-8019-42d1-90c9-de18a382cf1a",
    "created_at": "2023-01-12T14:59:46.282946Z",
    "updated_at": "2025-03-27T02:09:07.872273Z",
    "deleted_at": null,
    "sha1_hash": "c4fe261a2ae52168b7228b4de38bf1d7ad90b373",
    "title": "2014-07-10 - Versatile DDoS Trojan for Linux",
    "authors": "",
    "file_creation_date": "2022-05-28T04:49:32Z",
    "file_modification_date": "2022-05-28T04:49:32Z",
    "file_size": 1476411,
    "plain_text": "# Versatile DDoS Trojan for Linux\n\n**securelist.com/versatile-ddos-trojan-for-linux/64361/**\n\nAuthors\n\nMikhail Kuzin\n\nIn February 2014, an article was published on a popular Russian IT website under a curious\ntitle – [Studying the BillGates Linux Botnet. It described a Trojan with sufficiently versatile](http://habrahabr.ru/post/213973/)\nDDoS functionality. The capability that we found the most interesting was the Trojan’s ability\nto conduct DNS Amplification-type attacks. In addition, it followed from the article that the\nTrojan had a sophisticated modular structure, something we had not seen in the world of\nLinux malware before.\n\nThe article also provided a link for downloading all of the Trojan’s files (taken directly from an\ninfected machine) – which is what we did.\n\nThe archive that we downloaded contained the following files, which, according to the author\nof the article, were all modules of the same Trojan:\n\natddd;\ncupsdd;\ncupsddh;\nksapdd;\nkysapdd;\n\n\n-----\n\nskysapdd;\nxfsdxd.\n\nThe files cupsdd and cupsddh are detected by Kaspersky Lab products as\nBackdoor.Linux.Ganiw.a; atddd and the remaining files are detected as\nBackdoor.Linux.Mayday.f.\n\nThe archive with the files also contained a configuration file for cron – the Linux task\nscheduler. In this case, the utility is used by the Trojan as a means of getting a foothold in the\nsystem. The Trojan uses cron to perform the following tasks:\n\n1. Once a minute – terminate the processes of all applications that can interfere with its\n\noperation: .IptabLes, nfsd4, profild.key, nfsd, DDosl, lengchao32, b26, codelove,\nnode24\n2. Approximately once in ninety minutes – terminate all of its processes: kysapd, atdd,\n\nskysapd, xfsdx, ksapd\n3. Approximately once in two hours – download all of its components to the /etc folder\n\nfrom http://www.dgnfd564sdf.com:8080/[module_name] (module_name = name of the\nTrojan’s module, e.g., cupsdd), after deleting these files from the /etc folder\n4. Once in ninety minutes – relaunch all of its modules\n5. Every minute – purge system logs and bash command history and execute chmod\n\n7777 [module_name]\n\nDuring subsequent analysis of the files, we did not find any code responsible for saving the\nconfig file for cron. Most likely, the file was manually downloaded to the victim machine by a\ncybercriminal after gaining remote access to the system.\n\n## Backdoor.Linux.Mayday.f (atddd)\n\nThe file atddd is a backdoor designed to conduct various types of DDoS attacks against the\nservers specified. As mentioned above, Kaspersky Lab products detect it as\nBackdoor.Linux.Mayday.f. The files kysapdd, skysapdd, xfsdxd, ksapdd are almost exact\ncopies of atddd – with one exception, which is discussed later in the text.\n\nThe backdoor starts its operation by calling the function daemon(1, 0), continuing to run in\nthe background and redirecting standard input, output and errors to /dev/null\n\nNext, atddd collects relevant information about the system, including:\n\n1. system version (by calling uname())\n2. number of CPU cores and their clock rates (taken from /proc/cpuinfo)\n3. CPU load (taken from /proc/stat)\n4. network load (data for interfaces with the “eth” prefix taken from /proc/net/dev)\n\nThe information listed above is stored in the g statBase structure.\n\n\n-----\n\nAfter this, the backdoor decrypts strings defining the C&C server’s IP address and port\nnumber. The encryption algorithm used is very simple: an encrypted string is taken\ncharacter-by-character, with 1 added to the ASCII code of a character if its number is odd\nand subtracted from it if the character’s number is even. As a result, the string “3/3-2/4-26985” yields the IP-адрес “202.103.178.76”, while “2/:82” stands for port number “10991”.\n\nAfter this, atddd reads configuration file fwke.cfg, which is located in the same folder with the\nmalicious program. Information from the config file is saved in the g_fakeCfg structure. If the\nfile does not exist, the backdoor attempts to create it and store the following information in it:\n\n1st line: 0    //flag, if 1 then begin attack, if 0 then terminate attack\n\n2nd line: 127.0.0.1:127.0.0.1    //range of outgoing IP addresses\n\n3rd line: 10000:60000    //outgoing port range for an attack\n\n4th line: an empty line    //domain name in the case of DNS flood (see below)\n\nThis information is subsequently sent to the C&C server and can be updated with a\ncommand from the C&C.\n\nNext, the backdoor creates a new thread, CThreadTaskManager::ProcessMain(), in which\ncommands to begin an attack and terminate an attack are put into the execution queue. After\nthis, a new thread is created – CThreadHostStatus::ProcessMain(). In this thread, data on\nCPU and network load is updated every second and can subsequently be sent to the C&C\nserver if requested.\n\nAfter this, 20 threads are created, which read information from the task queue and,\ndepending on the information read, launch an attack or terminate it. However, some of the\nthreads may not be used in an attack if the relevant C&C command has a parameter (the\nnumber of threads to be used).\n\n\n-----\n\nThen the malware enters an endless loop of processing messages from the C&C. After a\nconnection with the C&C is established, information about system version and CPU clock\nrate, as well as data from the g_fakeCfg structure, is sent to the C&C every 30 seconds.\n\nIn response, the server should send 4 bytes, the first of which is the serial number of a\ncommand – from 1 to 4.\n\nNext, if the command has parameters, the C&C sends another 4 bytes defining the amount\nof data that will be sent (i.e., the parameters). Then the parameters themselves are sent;\ntheir size should match the number from the previous C&C response.\n\nAbout each command in greater detail:\n\n0x01. Command to launch an attack. Parameters define the attack’s type and the\nnumber of threads to be used. The attack type is defined by a byte which can take\nvalues from 0x80 to 0x84. This means that 5 attack types are possible:\n\n0x80 – TCP flood. The destination port number is sent by the C&C in its response\nas a parameter. The source port range is defined in fwke.cfg. Each new request\nis sent from a new port within the range defined, in the ascending order of port\nnumbers. The destination IP address is also defined in parameters.\n0x81 – UDP flood. The same as 0x80, but UDP is used as the transport layer\nprotocol.\n0x82 – ICMP flood. Same as above, but via ICMP.\n\n\n-----\n\n0x83, 0x84 – two DNS flood attacks. The only difference is the domain name sent\nin the DNS request. In the former case, the name is generated randomly, in the\nsecond, it is defined in a parameter (the fourth line in fwke.cfg). Essentially, both\nattacks are similar to 0x81, except that port 53 (the default port for the DNS\nservice) is used as destination port.\n0x02. Command to terminate an attack. The value in the first line of fwke.cfg is\nchanged to 0 and the attack is terminated.\n0x03. Command to update the file fwke.cfg. The response also includes a structure\nsimilar to g_fakeCfg, data from which is used to create the new fwke.cfg file.\n0x04. Command to send the current command’s execution status to the C&C server.\n\nIn addition to the above, the backdoor includes several empty methods (without any code),\nwhich have curious names: CThreadAttack::EmptyConnectionAtk,\nCThreadAttack::FakeUserAtk, CThreadAttack::HttpAtk. Apparently, the malware writer had\nplans to extend the malicious program’s functionality, and this is a test version rather than a\nfinal version. The file cupsdd, which is discussed below, provides a confirmation of this.\n\nThe files kysapdd, skysapdd, xfsdxd, ksapdd are almost identical copies of atddd, with the\nexception that they contain different C&C server addresses: 112.90.252.76:10991,\n112.90.22.197:10991, 116.10.189.246:10991 and 121.12.110.96:10991, respectively. The\nnames of their configuration files are also different: fsfe.cfg, btgw.cfg, fake.cfg, xcke.cfg,\nrespectively.\n\nThis means that, contrary to our expectations, the files atddd, kysapdd, skysapdd, xfsdxd,\nksapdd are not modules of a single piece of malware but rather different copies of the same\nTrojan, each connecting to its own C&C server. However, this is not the most curious part of\nit by far.\n\n## Backdoor.Linux.Ganiw.a (cupsdd)\n\nLike the files described above, this file is a backdoor designed to carry out various types of\nDDoS attacks. However, cupsdd is significantly more feature-rich and sophisticated than its\n‘colleagues’, although in places its code is very similar to that found in atddd.\n\nThe backdoor starts its operation by initializing the variables it needs from the string\n“116.10.189.246:30000:1:1:h:578856:579372:579888” (separator – “:”), which it first decrypts\nusing the RSA algorithm. The string contains the following variables:\n\ng_strConnTgt=116.10.189.246 – C&C server’s IP address\n\ng_iGatsPort=30000 – C&C server’s port\n\ng_iGatsIsFx=1 and g_iIsService=1 – flags used later\n\ng strBillTail=h – postfix for the name of the file that will be dropped (see below)\n\n\n-----\n\ng_strCryptStart=578856, g_strDStart=579372, g_strNStart=579888 – pointers to RSA data\n(encrypted string and key)\n\nNext, the malware drops and executes a file, which is located at offset 0xb1728 from the\nbeginning of the original file and is 335872 bytes in size, provided that the file is not already\nrunning. The malware checks whether the file is running by trying to bind a socket to\n127.0.0.1:10808. If the attempt is successful, it means that the file is not running, and it\nneeds to be dropped and executed.\n\nIf the file is already running, its process, whose PID can be found in the file /tmp/bill.lock, is\nterminated (kill(pid, 9)). Then the file is dropped anyway, replacing the existing copy.\n\nThe name of the file that is dropped is generated from the name of the current file that is\nrunning + postfix from the variable g_strBillTail. In our case, the file was named cupsddh and\nwas located in the same folder with the dropper.\n\nAfter this, the current process forks and the child process calls the function\nsystem(“/path/to/cupsddh”), which executes the file dropped.\n\nNext, the function daemon(1, 0) is called, for the same purpose as in the case of the sample\ndescribed above (atddd).\n\nAfter this, the malware handles the situation if cupsdd was executed earlier and is currently\nactive. For this purpose, it checks whether the file /tmp/gates.lock exists. If it does exist, the\ncurrent process is terminated (exit(0)). If not, the file (/tmp/gates.lock) is created and the PID\nof the current process is written to it.\n\nThen, if flag g_iIsService == 1, the backdoor sets itself to run at system startup by creating\nthe following script named DbSecuritySpt in /etc/init.d/:\n\n#!/bin/bash\n/path/to/cupsdd\n\n\n-----\n\nThe malware also creates symbolic links to the script in /etc/rc[1-5].1/S97DbSecuritySpt\n\nNext, the malware reads the configuration file conf.n (if it exists) from the same folder as the\none in which cupsdd is located. The first 4 bytes of the file define the size of the data which\nfollows. All the data is stored in the structure g_cnfgDoing.\n\nThen the malware reads the file containing commands – cmd.n. The format is the same as in\nconf.n. The data is stored in the structure g_cmdDoing.\n\nAfter this, the malware obtains all the necessary information about the system, including:\n\nThe operating system’s name and kernel version (e.g., Linux 3.11.0-15-generic), by\ncalling uname()\nCPU clock rate, taken from /proc/cpuinfo\nNumber of CPU cores, taken from /proc/cpuinfo, and CPU load, taken from /proc/stat\nNetwork load, taken from /proc/net/dev\nHard drive size in megabytes, taken from /proc/meminfo\nInformation about network interfaces, taken from /proc/net/dev\n\nAll the data is stored in the structure g statBase\n\n\n-----\n\nNext, a new stream, CThreadTaskGates::ProcessMain, is created, in which the following\ncommands are processed:\n\n0x03. DoConfigCommand(). Update the configuration file conf.n.\n0x05. DoUpdateCommand(). Start a new thread, CThreadUpdate::ProcessMain, in\nwhich update one of its components. The command accepts a number from 1 to 3 as a\nparameter. Each of the numbers is associated with one of the following strings:\n1 – “Alib” – the file /usr/lib/libamplify.so\n2 – “Bill” – the dropped module (cupsddh)\n3 – “Gates” – the dropper (cupsdd)\n\nDepending on the parameter, one of the malicious program’s components is updated. An\nupdate is launched by sending 6 bytes containing the string “EF76#^” to the C&C server,\nfollowed by one of the strings described above (depending on the parameter).\n\nThe C&C responds by sending 4 bytes containing the length (in bytes) of the file that will be\ntransferred next. Then the C&C transfers the file itself in 1024-byte packets.\n\nFirst, the file is saved in the /tmp folder under a random name consisting of digits. Then,\ndepending on the file that was received, the existing file cupsdd (or cupsddh) is replaced or\nthe file is copied to /usr/lib/libamplify.so\n\n\n-----\n\nNext, the temporary file is deleted from /tmp, and the chmod command is used to set 755\npermissions for the resulting file. After this, in the case of updating cupsddh, the active\nprocess is terminated and the new file is launched. In the case of updating cupsdd, the final\nstage (starting from copying a file from /tmp) is carried out by cupsddh, to which the relevant\ncommand is sent.\n\n0x07. DoCommandCommand(). Write a new command to cmd.n.\n0x02. StopUpdate(). Close the current connection, which was established in order to\nupdate modules.\n\nNext, the backdoor starts several threads, in which it simultaneously performs several\nadditional operations:\n\nCThreadClientStatus updates the data on CPU and network load in the g_statBase\nstructure every second.\nCThreadRecycle removes completed tasks from the queue.\nCThreadConnSender reads commands from the queue and passes them to the\ncupsddh module via a TCP connection with 127.0.0.1 on port 10808. In response it\nreceives the status of their execution.\nCThreadMonBill checks whether the module cupsddh is running once every minute. If\nnot, it drops and executes it again.\nCThreadLoopCmd reads commands from g_cmdDoing (the file cmd.n) and executes\nthem using the call system(cmd).\n\nNext, the main thread enters the loop of receiving and processing commands from the C&C\nserver. There are two possibilities in this case, depending on the g_iGatsIsFx flag:\n\n1. If the flag is set (==1), the malware simply uses the new thread to send information\n\nabout the system and the current configuration from g_cnfgDoing to the C&C and waits\nto receive commands in response, like the sample (atddd) described above;\n2. If the flag is not set, then the communication session is initiated by the C&C. In other\n\nwords, the malware waits for the C&C to connect and begins to transfer the data\nmentioned above only when a connection has been established.\n\n\n-----\n\nCommands received from the C&C are divided into two queues: either for execution in the\ncurrent module (in the thread CThreadTaskGates described above) or for passing to the\ncupsddh module (thread CThreadConnSender).\n\n## Backdoor.Linux.Ganiw.a (cupsddh)\n\nThe file is packed with UPX. After being unpacked, it calls daemon(1,0). It creates the file\n/tmp/bill.lock, in which it stores the PID of the current process. cupsddh stores system data in\nthe structure g_statBase, which is identical to that used by cupsdd.\n\nNext, it populates the structure g_provinceDns with the IP addresses of DNS servers\nconverted to binary data in network byte order using the function inet_addr(), taking data\nfrom the string array g_sProvinceDns (offset in unpacked file: 0x8f44с, size 4608 bytes).\n\ncupsddh executes command “insmod /usr/lib/xpacket.ko” in an attempt to load the kernel\nmodule into the kernel. However, the file is not present on ‘clean’ systems, and the malware\ndoes not make any attempt to download it or obtain it in any other way.\n\n\n-----\n\nNext, data from the file /usr/libamplify.so (as it turns out, this is not a library but one more\nconfig file) is loaded into the structure g_AmpResource. The file has the following format: 1st\ndword is the number of dwords that follow. Apparently, it contains the list of IP addresses for\nDNS servers that are currently relevant, i.e., those suitable for DNS Amplification type DDoS\nattacks.\n\nAfter this, the module creates two threads: CThreadTask and CThreadRecycle. The former\nexecutes commands from a queue comprising commands which came from the cupsdd\nmodule. The latter removes commands that have been executed. Next, the main thread\nbinds a socket to 127.0.0.1:10808 and enters an endless loop, receiving commands from the\ncupsdd module and putting the commands received into the above queue.\n\nThe following commands are possible:\n\n0x01. Start an attack according to the parameters received. See a more detailed\ndescription below.\n0x02. Terminate the current attack, setting the relevant flag.\n0x03. Update the current configuration in the g_cnfgDoing structure, which is used\nduring an attack. Also, update the current local MAC address, as well as the MAC and\nIP address of the current gateway in the structure g_statBase.\n0x05. The final stage of updating the cupsdd module (described above).\n\n\n-----\n\nTwo main attack modes are possible: normal mode and kernel mode.\n\n### Kernel mode\n\nThis mode uses [pktgen, a kernel-level packet generator built into Linux. Its advantage to the](http://www.linuxfoundation.org/collaborate/workgroups/networking/pktgen)\nattacker is that traffic is generated with the greatest speed possible for the given network\ninterface. In addition, the packets generated in this way cannot be detected using ordinary\nsniffers, e.g., the standard tcpdump, since packets are generated at kernel level.\n\nThe packet generator is controlled using a set of scripts/configs in the /proc/net/pktgen folder,\nbut the module pktgen must first be loaded into the kernel by calling the command\n“modprobe pktgen”. However, I did not find any such calls. Apparently, the call “insmod\n/usr/lib/xpacket.ko” is used instead, although, as mentioned above, the file is absent from the\nsystem by default. As a result, kernel mode is not operational in this version of the malware.\n\nNevertheless, the malware attempts to write several files to the /proc/net/pktgen folder,\nnamely:\n\n\n-----\n\n1. the file /proc/net/pktgen/kpktgend_%d for each CPU core, where %d is the core\n\nnumber, beginning from 0. The file’s contents is as follows:\nrem_device_all\nadd_device eth%d\nmax_before_softirq 10000\n\n\n-----\n\n2. the file /proc/net/pktgen/eth%d for each CPU core, where %d is the core number,\n\nbeginning from 0. The file’s contents is as follows:\ncount 0\nclone_skb 0\ndelay 0\nTXSIZE_RND\nmin_pkt_size %d\nmax_pkt_size %d\nIPSRC_RND\nsrc_min %s\nsrc_max %s\nUDPSRC_RND\nudp_src_min %d\nudp_src_max %d\ndst %s\nudp_dst_min %d\nudp_dst_max %d\ndst_mac %02x:%02x:%02x:%02x:%02x:%02x    //MAC address of the gateway from\n_g_statBase_\nis_multi %d\nmulti_dst %s    //if there are several addresses to be used in an attack (i.e., if the\n_value in the previous line is not equal to 0), they are set in these lines, the number of_\n_which matches the previous parameter_\npkt_type %d\ndns_domain %s\nsyn_flag %d\nis_dns_random %d\ndns_type %d\nis_edns %d\nedns_len %d\nis_edns_sec %d\n\nThe values of most pktgen parameters are passed from cupsdd via command\nparameters.\n\n3. the file /proc/net/pktgen/pgctrl, which contains the string “start”.\n\n### Normal attack mode\n\nAs in the case of atddd, normal attack mode uses raw sockets.\n\nThe following attack types are possible in this mode:\n\nCAttackSyn – TCP-SYN flood.\n\n\n-----\n\nCAttackUdp – UDP flood (as in the case of atddd)\nCAttackDns – DNS flood (as in the case of atddd)\nCAttackIcmp – ICMP flood (as in the case of atddd)\nCAttackCc – HTTP flood.\nCAttackAmp – DNS Amplification.\n\nThe last attack type on the list above is different in that packets are sent to vulnerable DNS\nservers, with the attack target specified as the sender’s IP address. As a result, the\ncybercriminal sends a small packet with a DNS request and the DNS server responds to the\nattack target with a significantly larger packet. The list of vulnerable DNS servers is stored in\nthe file libamplify.so, which is written to disk following the relevant command from the C&C.\n\n## Post Scriptum. BillGates v1.5\n\nThis version of the Trojan appeared a little later and is probably currently the latest.\nEssentially, this is the same cupsdd, only a little ‘shaped up’. Overall, there is more logic in\nthe code, plus there are a couple of new functions.\n\nThe most significant changes were made to the Gates module, i.e., the file cupsdd. Now it\nhas three operating modes. The choice of mode is based on the folder from which the file is\nlaunched. Specifically, if it is launched from /usr/bin/pojie, then monitoring mode is enabled,\notherwise the module operates in installation and updating mode, which is later superseded\nby the mode in which it controls the Bill module.\n\n\n-----\n\n1. Installation and updating mode.\n\nFirst, the module terminates its process working in monitoring mode, if it exists. Its PID\nis kept in the file /tmp/moni.lock.\nNext, it reinstalls and re-launches the Bill module.\nNext, if a process working in the ‘controlling the Bill module’ mode exists, that process\nis terminated. Its PID is kept in the file /tmp/gates.lock.\nIf the flag g_iIsService is set (it is defined in the same way as in the previous version),\nthe module sets itself to run at system startup in the same way as before (in the\nprevious version).\nNext, the module writes its path to the file /tmp/notify.file and then copies itself to the file\n/usr/bin/pojie. After this, it launches its copy, which is, obviously, set to run in monitoring\nmode, and then changes its own operating mode to controlling the Bill module.\n\n2. Monitoring mode.\n\nWrites the PID of the current process to the file /tmp/moni.lock. Next, it starts two\nthreads – one to monitor the Bill module and the other to monitor the Gates module\noperating in controlling Bill mode. If one of these processes is currently not running, the\nrelevant file is created and launched again.\n\n3. Controlling the Bill module mode.\n\nThe actions of the Gates module are exactly the same as they were in the previous\nversion of the Trojan (after installing the Bill module and initializing the relevant\nvariables and structures of the Trojan).\n\nTo summarize, in the new version of the Trojan its authors have added a little ‘robustness’\nwithout making any significant functionality changes.\n\n\n-----\n\nIt is also worth noting that the hard-coded IP address of the C&C server has remained the\nsame (116.10.189.246) in this version, but the port number has changed – it is now 36008\ninstead of 30000 in the previous version.\n\n[Backdoor](https://securelist.com/tag/backdoor/)\n[Botnets](https://securelist.com/tag/botnets/)\n[DDoS-attacks](https://securelist.com/tag/dos-attacks/)\n[DNS Amplification](https://securelist.com/tag/dns-amplification/)\n[Linux](https://securelist.com/tag/linux/)\n\nAuthors\n\nMikhail Kuzin\n\nVersatile DDoS Trojan for Linux\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2014/2014-07-10 - Versatile DDoS Trojan for Linux.pdf"
    ],
    "report_names": [
        "2014-07-10 - Versatile DDoS Trojan for Linux.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535586,
    "ts_updated_at": 1743041347,
    "ts_creation_date": 1653713372,
    "ts_modification_date": 1653713372,
    "files": {
        "pdf": "https://archive.orkl.eu/c4fe261a2ae52168b7228b4de38bf1d7ad90b373.pdf",
        "text": "https://archive.orkl.eu/c4fe261a2ae52168b7228b4de38bf1d7ad90b373.txt",
        "img": "https://archive.orkl.eu/c4fe261a2ae52168b7228b4de38bf1d7ad90b373.jpg"
    }
}