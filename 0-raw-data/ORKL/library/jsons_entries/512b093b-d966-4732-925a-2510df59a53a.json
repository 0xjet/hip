{
    "id": "512b093b-d966-4732-925a-2510df59a53a",
    "created_at": "2023-01-12T15:02:13.18769Z",
    "updated_at": "2025-03-27T02:05:18.778349Z",
    "deleted_at": null,
    "sha1_hash": "4d350353f24805886f8d835852274dc0a64934ab",
    "title": "2019-01-14 - A Quick Solution to an Ugly Reverse Engineering Problem",
    "authors": "",
    "file_creation_date": "2022-05-28T18:26:52Z",
    "file_modification_date": "2022-05-28T18:26:52Z",
    "file_size": 220396,
    "plain_text": "# A Quick Solution to an Ugly Reverse Engineering Problem\n\n**[msreverseengineering.com/blog/2019/1/14/a-quick-solution-to-an-ugly-reverse-engineering-problem](https://www.msreverseengineering.com/blog/2019/1/14/a-quick-solution-to-an-ugly-reverse-engineering-problem)**\n\nJanuary 14, 2019 [Rolf Rolles](http://10.10.0.46/blog?author=5111cf9ee4b0a36262da10df)\n\n\nJanuary 14, 2019\n\n\nReverse engineering tools tend to be developed against fundamental assumptions, for\nexample, that binaries will more or less conform to the standard patterns generated by\ncompilers; that instructions will not jump into other instructions; perhaps that symbols are\navailable, etc. As any reverse engineer knows, your day can get worse if the assumptions\nare violated. Your tools may work worse than usual, or even stop working entirely. This blog\npost is about one such minor irritation, and the cheap workaround that I used to fix it.\n\nIn particular, the binary I was analyzing -- one function in particular -- made an uncommon\nuse of an ordinary malware subterfuge technique, which wound up violating ordinary\nassumptions about the sizes of functions. In particular, malware authors quite often build\ndata that they need -- strings, most commonly -- in a dynamic fashion, so as to obscure the\ndata from analysts using tools such as \"strings\" or a hex editor. (Malware also commonly\nenciphers its strings somehow, though that is not the feature that I'll focus on in this entry.)\nAs such, we see a lot of the following in the function in question.\n\nWhat made this binary's use of the technique unusual was the scale at which it was applied.\nTypically the technique is used to obscure strings, usually no more than a few tens of bytes\napiece. This binary, on the other hand, used the technique to build two embedded\nexecutables, totaling about 16kb in data -- hence, there are about 16,000 writes like the one\nin the previous figure each implemented by a 7-byte instruction The function pictured\n\n\n-----\n\nabove comprises about 118KB of code -- over 25% of the total size of the binary. The\nfunction would have been large even without this extra subterfuge, as it has about 7kb of\ncompiled code apart from the instructions above.\n\nThe Hex-Rays decompilation for this function is about 32,500 lines. The bulk of this comes\nfrom two sources: first, the declaration of one stack local variable per written stack byte:\n\nSecond, one assignment statement per write to a stack variable:\n\nTo IDA's credit, it handles this function just fine; there is no noticeable slowdown in using\nIDA to analyze this function. Hex-Rays, however, has a harder time with it. (I don't\nnecessarily blame Hex-Rays for this; the function is 118KB, after all, and Hex-Rays has\nmuch more work to do than IDA does in dealing with it.) First, I had to alter the Hex-Rays\ndecompiler options in order to even decompile the function at all:\n\n\n-----\n\nAfter making this change, Hex-Rays was very slow in processing the function, maxing out\none of my CPU cores for about five minutes every time I wound up decompiling it. This is\nsuboptimal for several reasons:\n\nI often use the File->Produce file->Create .c file... menu command more than once\nwhile reverse engineering a particular binary. This function turns every such command\ninto a cigarette break.\n\n[Some plugins, such as Referee, are best used in conjunction with the command just](https://github.com/jkoppel/project-ironfist/tree/master/tools/Revitalize/Referee)\nmentioned.\n\nWhen using the decompiler on this function in an interactive fashion (such as by\nrenaming variables or adding comments), the UI becomes slow and unresponsive.\n\n\n-----\n\nRandomly looking at the cross-references to or from a given function becomes a\ngame of Russian Roulette instead of a normally snappy and breezy part of my reverse\nengineering processes. Decompile the wrong function and you end up having to wait\nfor the decompiler to finish.\n\nThus, it was clear that it was worth 15 minutes of my time to solve this problem. Clearly, the\nslowdowns all resulted from the presence of these 16,000 write instructions. I decided to\nsimply get rid of them, with the following high-level plan:\n\nExtract the two .bin files written onto the stack by the corresponding 112KB of\ncompiled code\n\nPatch those .bin files into the database\n\nReplace the 112KB worth of instructions with one patched call to memcpy()\n\nPatch the function's code to branch over the 112KB worth of stack writes\n\nThe first thing I did was copy and paste the Hex-Rays decompilation of the stack writes into\nits own text file. After a few quick sanity checks to make sure all the writes took place in\norder, I used a few regular expression search-and-replace operations and a tiny bit of\nmanual editing to clean the data up into a format that I could use in Python.\n\nNext, a few more lines of Python to save the data as a binary file:\n\nFrom there, I used IDA's Edit->Patch program->Assemble... command to write a small\npatch into the corresponding function:\n\n\n-----\n\nAfter a bit of fiddling and manual hex-editing the results, my patch was installed:\n\nAnd then I used a two-line IDC script to load the binary files as data in the proper location:\n\n\n-----\n\nAfterwards, the navigation bar showed that about 31% of the text section had been\nconverted into data:\n\nAnd now the problem is fixed. The function takes approximately two seconds to decompile,\nmore in line with what we'd expect for a 7kb function. Hooray; no more endless waiting, all\nfor the time cost of about three accidental decompilations of this function.\n\nThis example shows that, if you know your tools well enough to know what causes them\nproblems, that sometimes you can work your way around them. Always stay curious,\nexperiment, and don't simply settle for a suboptimal reverse engineering experience without\nexploring whether there might be an easier solution.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-01-14 - A Quick Solution to an Ugly Reverse Engineering Problem.pdf"
    ],
    "report_names": [
        "2019-01-14 - A Quick Solution to an Ugly Reverse Engineering Problem.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535733,
    "ts_updated_at": 1743041118,
    "ts_creation_date": 1653762412,
    "ts_modification_date": 1653762412,
    "files": {
        "pdf": "https://archive.orkl.eu/4d350353f24805886f8d835852274dc0a64934ab.pdf",
        "text": "https://archive.orkl.eu/4d350353f24805886f8d835852274dc0a64934ab.txt",
        "img": "https://archive.orkl.eu/4d350353f24805886f8d835852274dc0a64934ab.jpg"
    }
}