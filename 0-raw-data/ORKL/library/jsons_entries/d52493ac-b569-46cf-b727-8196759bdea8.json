{
    "id": "d52493ac-b569-46cf-b727-8196759bdea8",
    "created_at": "2023-01-12T15:07:32.252101Z",
    "updated_at": "2025-03-27T02:06:05.359064Z",
    "deleted_at": null,
    "sha1_hash": "96e22752ccc7e910f7eafaec1483c46abd80b5fe",
    "title": "2022-07-12 - Example Analysis of Multi-Component Malware",
    "authors": "",
    "file_creation_date": "2022-08-18T03:20:20Z",
    "file_modification_date": "2022-08-18T03:20:20Z",
    "file_size": 2609082,
    "plain_text": "# Example Analysis of Multi-Component Malware\n\n**[cyren.com/blog/articles/example-analysis-of-multi-component-malware](https://www.cyren.com/blog/articles/example-analysis-of-multi-component-malware)**\n\n## Cyren Security Blog\n\n\nJuly 13, 2022\n\n\nThe Cyren Security Blog is where Cyren engineers and thought leaders provide insights,\nresearch and analysis on a range of current cybersecurity topics.\n\nby Kervin Alintanahin\nRecently, we have received an increase in the number of malicious email samples with\n[password-protected attachments. The recent waves of attacks with Emotet use a similar](https://www.cyren.com/blog/articles/emotet-resurgence)\napproach. In this blog we describe our analysis of another set of samples that used file\narchives (e.g. zip file) secured with passwords.\n\nThe authors of this attack inserted the file archive file into an HTML file.\n\n\n-----\n\n_Figures 1.1 and 1.2: Emails with initial malware component, an HTML attachment_\n\nOnce the HTML file is opened, it will drop a file as if that file was downloaded by the user.\nThe HTML page also displays the password for the dropped file.\n\n_Figure 2. the HTML attachment will drop a password-protected archive file named_\n_download.zip_\n\n## Extracted File\n\nOne of the samples we analyzed contained a file named “IMG0457600xls.exe”. The authors\ntried to disguise the executable file as a Microsoft Office file by using XLS as part as its\nfilename and using a WORD icon. This error by the perpetrators is a red flag for users.\n\n\n-----\n\n_Figure 3. PE executable with a WORD icon and double extension xls.exe_\n\nA quick static analysis of the Portable Executable file reveals that it is a .NET executable so\n[we could use dnSpy to analyze its behavior. Reviewing its code, one of its methods contains](https://github.com/dnSpy/dnSpy/releases)\na URL to a file named “IMG0457600xls.png”. The PNG file extension suggests that it might\nbe an image file but it’s not. We downloaded the file so we could reverse engineer the code.\n\n_Figure 4. Excerpt code of the download behavior_\n\n## Fileless Payloads\n\nTo identify what the PNG file truly is, we created a simple tool to reverse its contents. After\nreversing the content, the downloaded file is another Windows PE object, a DLL file to be\nexact. This file type is commonly known as a reverse EXE. The DLL payload will be loaded\nin memory using the AppDomain.CurrentDomain.Load method. It will then search if it has a\nmember named “Dnypiempvyffgdjjm”. If found, it will invoke this member via the\nInvokeMember method that will execute the main code of the payload in memory.\n\n_Figure 5. Code excerpt of the loop searching for the member_\n\n\n-----\n\n_Figure 6. EnableServer method which will be called once the member is found_\n\nSince we had a copy of the downloaded DLL payload (reverse EXE with PNG extension), we\ncontinued our static analysis on this component before debugging the initial Windows PE\nExecutable file (IMG0457600xls.exe). Loading it in dnSpy, we could see valuable information\nabout it. The DLL filename was “Svcwmhdn.dll”. It was also obfuscated using Smart\nAssembly. We used the [de4dot tool to de-obfuscate and unpack the DLL component to make](https://github.com/de4dot/de4dot)\nit easier to analyze. Once it was de-obfuscated and unpacked, it gave us a clue that part of\nthe payload was also obfuscated by Fody/Costura.\n\n_Figure 7. File information of “Svcwmhdn.dll”_\n\n_Figure 8. Fody/Costura embedded resources_\n\n\n-----\n\n## Malware in action\n\n### Layers of Obfuscation\n\nAfter getting clues with our static analysis, we debugged the malware components. We begin\nour analysis from the point when the DLL is loaded into memory. At the start of its execution,\nit will decompress two resources before starting the actual malicious behavior. It uses the\nAES algorithm to decrypt both resources. It will first decrypt the resource tagged as\n“{0235d35d-030c-4d50-b46a-055fbb9ab683}”. This resource contains the strings the\nmalware uses. Next, it will decrypt “{8569c651-a5ff-4d2e-8dd8-aaa0f6904365}”. It is another\nWindows PE component, which will be loaded in memory. If the decryption fails, the DLL will\ntry to drop a copy of the component and load it into memory via the LoadFile method.\n\n_Figure 9. The 2 encrypted resources_\n\n\n-----\n\n_Figures 10.1 and 10.2. Decryption method with the AES key and IV, and_\n_aesCryptoServiceProvider_\n\n\n-----\n\n_Figure 11. Excerpt code of the decryption of one of the resources_\n\nChecking the information if we try to force it to drop the content, it is another executable\ncomponent. It contains resources that were compressed using Fody/Costura as seen in our\nstatic analysis in Figure 8. It has several resources to decompress. One of them is the\nProtobuf-net module. These resources were also decrypted and then decompressed. Take\nnote of the resource named “ _._.resources‎” (141363 bytes, Embedded, Public) which has a\nchild resource “Jhufjcjrbgyyuktdl” as this will be accessed later.\n\n\n-----\n\n_Figure 12. Decompression code for Fody/Costura embedded resources_\n\nAfter the layers of obfuscation and related initializations, we will now move at the start of the\nmalware. The method Dnypiempvyffgdjjm is where the main malware routine is located. At\nthe start, it will initialize its settings. By looking at Figure 14, we can see the list of the\npossible actions it can take. Most of the settings were set to false. And by just analyzing it,\nwe can assume that this malware only supports 32bit Operating Systems and will inject a\npayload in “MSBuild”.\n\n_Figure 13. Start of the main routine_\n\n\n-----\n\n_Figure 14. Settings of the malware_\n\n### Evasion\n\nAside from the 23 second delay set to evade sandboxes, it also checks if the username of\nthe machine is equal to “JohnDoe” or the computer name\\\\\\\\hostname is equal to “HAL9TH”.\nIf found true, it will terminate the execution. These strings are related to Windows Defender\nemulator.\n\nFigure 15 shows the code for checking the username\\\\\\\\computer name. Each string is\nobfuscated and will be fetched from the decrypted resource (“{0235d35d-030c-4d50-b46a055fbb9ab683}”). It will compute for the offset of the string by XORing the input integer and\nthen subtracting 0xA6. The first byte of the located offset is the string size followed by the\nencoded string. The encoded string is then decoded using B64 algorithm. This approach of\nretrieving the string is used throughout the malware.\n\n\n-----\n\n_Figure 15. Excerpt code for the checking of username and computer name/hostname_\n\n### Final Fileless Payload\n\nBased on the settings, we assumed that it will inject an executable payload in MSBUILD.exe.\nSo before it can proceed with the injection, it will need to retrieve the necessary API. Figure\n18 shows the code that will try to dynamically resolve the API’s. The approach to retrieve the\nstring is the same as mentioned earlier. The difference is that the API encoded strings have\nan “@” character randomly inserted. It needs to remove the “@” character before proceeding\nto use the B64 algorithm to decode it. Take a look at the example in the chart below. First, it\nwill get the corresponding DLL where it will import the API. In this example, it is “kernel32”.\nThen it will retrieve the API string. After decoding the string using the same approach\n[decoding the DLL string, it will be equal to ” [email protected]@VGhyZWFk”. It will then](https://www.cyren.com/cdn-cgi/l/email-protection)\nremove the “@” char before proceeding to decoding the string using B64 again.The final\noutput will be equal to the API string “ResumeThread”. It will dynamically resolve a few more\nAPI’s. These API’s will be used in its process injection routine.\n\n_Table 16. Data structure of encrypted strings used by the malware_\n\nDLL API\n\n\n-----\n\nkernel32.dll ResumeThread\n\nkernel32.dll Wow64SetThreadContext\n\nkernel32.dll SetThreadContext\n\nkernel32.dll GetThreadContext\n\nkernel32.dll VirtualAllocEx\n\nkernel32.dll WriteProcessMemory\n\nntdll.dll ZwUnmapViewOfSection\n\nkernel32.dll CreateProcessA\n\nkernel32.dll CloseHandle\n\nkernel32.dll ReadProcessMemory\n\n_Table 17. List of APIs_\n\n_Figure 18. The first API to be dynamically resolved is ResumeThread, imported from_\n_kernel32.dll_\n\nAt this point, it just needs the payload it will inject to MSBuild.exe. It hides the payload in the\nresource named “Jhufjcjrbgyyuktdl”. The data is reversed and then unpacked using GZIP.\nThe file is a copy of a Formbook malware. We detect this file as\nW32/Formbook.F.gen!Eldorado.\n\n\n-----\n\n_Figure 19. Start of the injection code._\n\nThe fileless payload Svcwmhdn.dll was created using Purecrypter. It is advertised as a file\nprotector and available for sale. And as seen in the GUI interface, these options were\navailable in the settings in Figure 14.\n\n\n-----\n\n_Figure 20. PureCrypter options GUI_\n\n## Indicators of Compromise (IOCs)\n\n**SHA256**\n\n6f10c68357f93bf51a1c92317675a525c261da91e14ee496c577ca777acc36f3\n\nDescription: email attachment\nFilename: IMG045760.html\nDetection: HTML/Dropper.A\n\n9629934a49df20bbe2c5a76b9d1cc2091005dfef0c4c08dae364e6d654713e46\n\nDescription: initial payload\nFilename: IMG0457600xls.exe\nDetection: W32/MSIL_Kryptik.GSO.gen!Eldorado\n\ndc419e1fb85ece7894a922bb02d96ec812220f731e91b52ab2bc8de44726ce83\n\nDescription: reverse PE fileless payload\nFilename: Svcwmhdn.dll\nDetection: W32/MSIL Kryptik.HJL.gen!Eldorado\n\n\n-----\n\n37ed1ba1aab413fbf59e196f9337f6295a1fbbf1540e76525b43725b1e0b012d\n\nDescription: final fileless payload\nFilename: Jhufjcjrbgyyuktdl\nDetection: W32/Formbook.F.gen!Eldorado\n\nJul 12, 2022 | [Malware,](https://www.cyren.com/blog/articles/category/malware) [Security Research & Analysis](https://www.cyren.com/blog/articles/category/security-research)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-12 - Example Analysis of Multi-Component Malware.pdf"
    ],
    "report_names": [
        "2022-07-12 - Example Analysis of Multi-Component Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536052,
    "ts_updated_at": 1743041165,
    "ts_creation_date": 1660792820,
    "ts_modification_date": 1660792820,
    "files": {
        "pdf": "https://archive.orkl.eu/96e22752ccc7e910f7eafaec1483c46abd80b5fe.pdf",
        "text": "https://archive.orkl.eu/96e22752ccc7e910f7eafaec1483c46abd80b5fe.txt",
        "img": "https://archive.orkl.eu/96e22752ccc7e910f7eafaec1483c46abd80b5fe.jpg"
    }
}