{
    "id": "a54e6cd1-6e17-47d4-864c-ecb40867a7dd",
    "created_at": "2023-01-12T14:59:49.940972Z",
    "updated_at": "2025-03-27T02:06:00.015126Z",
    "deleted_at": null,
    "sha1_hash": "d38483aa6b2f91be31de454a88df97e65617a4be",
    "title": "2018-08-30 - Reversing malware in a custom format- Hidden Bee elements",
    "authors": "",
    "file_creation_date": "2022-05-28T02:32:08Z",
    "file_modification_date": "2022-05-28T02:32:08Z",
    "file_size": 295623,
    "plain_text": "# Reversing malware in a custom format: Hidden Bee elements\n\n**[blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)**\n\nhasherezade August 30, 2018\n\nMalware can be made of many components. Often, we encounter macros and scripts that\nwork as malicious downloaders. Some functionalities can also be achieved by positionindependent code—so-called shellcode. But when it comes to more complex elements or\ncore modules, we almost take it for granted that it will be a PE file that is a native Windows\nexecutable format.\n\nThe reason for this is simple: It is much easier to provide complex functionality within a PE\nfile than within a shellcode. PE format has a well-defined structure, allowing for much more\nflexibility. We have certain headers that define what imports should be loaded and where, as\nwell as how the relocations should be applied. This is a default format generated when we\ncompile applications for Windows, and its structure is then used by Windows Loader to load\nand execute our application. Even when the malware authors write custom loaders, they are\nmostly for the PE format.\n\nHowever, sometimes we find exceptions. Last time, when we analyzed payloads related to\n[Hidden Bee (dropped by the Underminer exploit kit), we noticed something unusual. There](https://blog.malwarebytes.com/threat-analysis/2018/07/hidden-bee-miner-delivered-via-improved-drive-by-download-toolkit/)\nwere two payloads dropped that didn’t follow the PE format. Yet, their structure looked well\n\n\n-----\n\norganized and more complex than we usually encounter dealing with pieces of shellcode.\nWe decided to take a closer look and discovered that the authors of this malware actually\ncreated their own executable format, following a consistent structure.\n\n## Overview\n\n[The first payload: b3eb576e02849218867caefaa0412ccd (with .wasm extension, imitating](https://www.virustotal.com/#/file/76b70f1dfd64958fca7ab3e18fffe6d551474c2b25aaa9515181dec6ae112895/details)\nWeb Assembly) is a loader, downloading and unpacking a Cabinet file:\n\n[The second payload: 11310b509f8bf86daa5577758e9d1eb5, unpacked from the Cabinet:](https://www.virustotal.com/#/file/c1a6df241239359731c671203925a8265cf82a0c8c20c94d57a6a1ed09dec289/details)\n\nWe can see at first that in contrast to most shellcodes, it does not start from a code, but from\nsome headers. Comparing both modules, we can see that the header has the same structure\nin both cases.\n\n## Headers\n\nWe took a closer look to decipher the meaning of particular fields in the header.\n\n\n-----\n\nThe first DWORD: 0x10000301 is the same in both. We didn’t find this number\ncorresponding to any of the pieces within the module. So, we assume it is a magic number\nthat makes an identifier of this format.\n\nNext, two WORDs are offsets to elements related to loading the imports. The first one (0x18)\npoints to the list of DLLs. The second block (0x60) looks more mysterious at first. Its\nmeaning can be understood when we load the module in IDA. We can see the crossreferences to those fields:\n\nWe see that they are used as IAT—they are supposed to be filled with the addresses to the\nimported functions:\n\nThe next value is a DWORD (0x2A62). If we follow it in IDA, we see that it leads to the\nbeginning of a new function:\n\n\n-----\n\nThis function is not referenced by any other functions so we can suspect that it is the\nprogram’s Entry Point.\n\nThe meaning of the next value (0x509C) is easy to guess because it is the same as the size\nof the full module.\n\nThen, we have the last two DWORDs of the header. The second DWORD (0x4D78) leads to\nthe structure that is very similar to the PE’s relocations. We can guess that it must be a\nrelocation table of the module, and the previous DWORD specifies its size.\n\nThis is how we were able to reconstruct the full header:\n```\ntypedef struct {\n     DWORD magic;\n     WORD dll_list;\n     WORD iat;\n     DWORD ep;\n     DWORD mod_size;\n     DWORD relocs_size;\n     DWORD relocs;\n} t_bee_hdr;\n\n## Imports\n\n```\nAs we know from the header, the list of the DLLs starts at the offset 0x18. We can see that\neach of the DLL’s names are prepended with a number:\n\n\n-----\n\nThe numbers are not corresponding with a DLL name: In two different modules, the same\nDLL had different numbers assigned. But if we sum up all the numbers, we find that their\ntotal sum is the same as the number of DWORDs in the IAT. So, we can make an educated\nguess that those numbers are specifying how many functions will be imported from a\nparticular DLL.\n\nWe can describe it as the following structure (where the name’s length is not specified):\n```\ntypedef struct {\n     WORD func_count;\n     char name;\n} t_dll_name;\n\n```\nThen, the IAT comes as a list of DWORDs:\n\nIt is common in malware that when the function’s names are not given as an explicit string,\nthey are imported by checksum. The same is done in this case. Guessing the appropriate\nfunction that was used for calculating the checksum can be more difficult. Fortunately, we\nfound it in the loader component:\n\n\n-----\n\n```\nDWORD checksum(char func_name)\n{\n DWORD result = 0x1505;\n while ( *func_name )\n  result = *func_name++ + 33 * result;\n return result;\n}\n\n```\nKnowing that we paired appropriate checksums with the function’s names:\n\nOnce the address of the function is retrieved, it is stored in the IAT in place of the checksum.\n\n## Relocations\n\nCreating a relocation table is simple. It consists of the list of DWORDs that are identifying the\noffsets of the places in the code to which we should add the base where the module has\nbeen loaded. Without relocations applied, the module will crash (so, it is not positionindependent like a typical shellcode).\n\n## Comparison to PE format\n\nWhile the PE format is complex, with a variety of headers, this one contains only essentials.\nMost of the information that is usually stored in a PE header is completely omitted here.\n\n[You can see a PE format visualized by Ange Albertini here.](https://raw.githubusercontent.com/corkami/pics/master/binary/PE101.png)\n\n\n-----\n\nCompare it with the visualization of the currently analyzed format:\n\n## Static analysis\n\nWe can load this code into IDA as a blob of raw code. However, we will be missing important\ninformation. Due to the fact that the file doesn’t follow a PE structure, and its import table is\nnon-standard, we will have a hard time understanding which API calls are being made at\n[which offset. To solve this problem, I made a tool that resolves hashes into function names](https://github.com/hasherezade/bee_parser)\nand generates a TAG file to mark the offsets where each function’s address is going to be\nfilled.\n\n\n-----\n\n[Those tags can be loaded into IDA using an IFL plugin:](https://github.com/hasherezade/ida_ifl)\n\nHaving all the API functions tagged, it is much easier to understand which actions are\nperformed by the module. Here, for example, we can see that it will be establishing the\nconnection with the C2 server:\n\n## Dynamic analysis\n\nThis format is custom, so it is not supported by the typical tools for analysis. However, after\nunderstanding it, we can write our own tools, such as the parser for the headers and loader\nthat will help to run this format and analyze it dynamically.\n\nIn contrast to PE, the module doesn’t have any sections. So, we need to load it in a\ncontinuous memory region with RWX (read-write-execute) access. Walking through the\nrelocations list, we will add the value of the base at which the module was loaded to the\nlisted addresses. Then, we have to resolve the imported functions by their hashes and fill the\n\n\n-----\n\naddresses in the thunks. After preparing the stage, it just needs to jump at the Entry Point of\nthe module. We will load the prepared loader under the debugger and follow to the entry\npoint of the loaded module.\n\n## Simple but rare\n\nThe elements described here are pretty simple—they serve as a first stage of the full\nmalware package, downloading other pieces and injecting them into processes. However,\nwhat makes them interesting is the fact that their authors have shown some creativity and\ndecided to invent a custom format that is less complex than a full-fledged PE, but goes a\nstep further than a typical piece of shellcode.\n\nSuch module, in contrast to independent shellcode, is not self-sufficient and cannot be\nloaded in a trivial way, but must be parsed first. Given the fact that the format is custom, it is\nnot supported by existing tools. This is where programming skills come in handy for a\nmalware analyst.\n\nFortunately, fully custom formats are rather uncommon in the malware world; usually, authors\nrely heavily on existing formats, from time to time corrupting or customizing selected parts of\nPE headers.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-08-30 - Reversing malware in a custom format- Hidden Bee elements.pdf"
    ],
    "report_names": [
        "2018-08-30 - Reversing malware in a custom format- Hidden Bee elements.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535589,
    "ts_updated_at": 1743041160,
    "ts_creation_date": 1653705128,
    "ts_modification_date": 1653705128,
    "files": {
        "pdf": "https://archive.orkl.eu/d38483aa6b2f91be31de454a88df97e65617a4be.pdf",
        "text": "https://archive.orkl.eu/d38483aa6b2f91be31de454a88df97e65617a4be.txt",
        "img": "https://archive.orkl.eu/d38483aa6b2f91be31de454a88df97e65617a4be.jpg"
    }
}