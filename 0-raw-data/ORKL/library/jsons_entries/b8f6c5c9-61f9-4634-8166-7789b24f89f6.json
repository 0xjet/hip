{
    "id": "b8f6c5c9-61f9-4634-8166-7789b24f89f6",
    "created_at": "2023-01-12T15:01:42.708807Z",
    "updated_at": "2025-03-27T02:16:25.887433Z",
    "deleted_at": null,
    "sha1_hash": "a342b5bebe6be71f94b198f2aab2a3181ac8ea18",
    "title": "2022-06-30 - Toll fraud malware- How an Android application can drain your wallet",
    "authors": "",
    "file_creation_date": "2022-07-18T18:06:51Z",
    "file_modification_date": "2022-07-18T18:06:51Z",
    "file_size": 4048426,
    "plain_text": "# Toll fraud malware: How an Android application can drain your wallet\n\n**[microsoft.com/security/blog/2022/06/30/toll-fraud-malware-how-an-android-application-can-drain-your-wallet/](https://www.microsoft.com/security/blog/2022/06/30/toll-fraud-malware-how-an-android-application-can-drain-your-wallet/)**\n\nJune 30, 2022\n\nToll fraud malware, a subcategory of billing fraud in which malicious applications subscribe\nusers to premium services without their knowledge or consent, is one of the most prevalent\ntypes of Android malware – and it continues to evolve.\n\nCompared to other subcategories of billing fraud, which include SMS fraud and call fraud, toll\nfraud has unique behaviors. Whereas SMS fraud or call fraud use a simple attack flow to\nsend messages or calls to a premium number, toll fraud has a complex multi-step attack flow\nthat malware developers continue to improve.\n\nFor example, we saw new capabilities related to how this threat targets users of specific\nnetwork operators. It performs its routines only if the device is subscribed to any of its target\nnetwork operators. It also, by default, uses cellular connection for its activities and forces\ndevices to connect to the mobile network even if a Wi-Fi connection is available. Once the\nconnection to a target network is confirmed, it stealthily initiates a fraudulent subscription and\nconfirms it without the user’s consent, in some cases even intercepting the one-time\n\n\n-----\n\npassword (OTP) to do so. It then suppresses SMS notifications related to the subscription to\nprevent the user from becoming aware of the fraudulent transaction and unsubscribing from\nthe service.\n\nAnother unique behavior of toll fraud malware is its use of dynamic code loading, which\nmakes it difficult for mobile security solutions to detect threats through static analysis, since\nparts of the code are downloaded onto the device in certain parts of the attack flow. Despite\nthis evasion technique, we’ve identified characteristics that can be used to filter and detect\nthis threat. We also see adjustments in Android API restrictions and Google Play Store\npublishing policy that can help mitigate this threat.\n\nToll fraud has drawn media attention since Joker, its first major malware family, found its way\nto the Google Play Store back in 2017. Despite this attention, there’s not a lot of published\nmaterial about how this type of malware carries out its fraudulent activities. Our goal for this\nblog post is to share an in-depth analysis on how this malware operates, how analysts can\nbetter identify such threats, and how Android security can be improved to mitigate toll fraud.\nThis blog covers the following topics:\n\n## The WAP billing mechanism: An overview\n\nTo understand toll fraud malware, we need to know more about the billing mechanism that\nattackers use. The commonly used type of billing in toll fraud is Wireless Application Protocol\n(WAP). WAP billing is a payment mechanism that enables consumers to subscribe to paid\ncontent from sites that support this protocol and get charged directly through their mobile\nphone bill. The subscription process starts with the customer initiating a session with the\nservice provider over a cellular network and navigating to the website that provides the paid\nservice. As a second step, the user must click a subscription button, and, in some cases,\nreceive a one-time password (OTP) that has to be sent back to the service provider to verify\nthe subscription. The overall process is depicted below:\n\n\n-----\n\nFigure\n\n1. The WAP billing process in a nutshell\nIt should be noted that the process depends on the service provider, thus not all steps are\nalways present. For example, some providers do not require an OTP, which means that the\nmobile user can subscribe to a service by simply clicking the subscription button while the\ndevice is connected to a cellular network.\n\n## Fraudulent subscriptions via toll fraud\n\nWe classify a subscription as fraudulent when it takes place without a user’s consent. In the\ncase of toll fraud, the malware performs the subscription on behalf of the user in a way that\nthe overall process isn’t perceivable through the following steps:\n\n1. Disable the Wi-Fi connection or wait for the user to switch to a mobile network\n2. Silently navigate to the subscription page\n3. Auto-click the subscription button\n4. Intercept the OTP (if applicable)\n5. Send the OTP to the service provider (if applicable)\n6. Cancel the SMS notifications (if applicable)\n\n\n-----\n\nOne significant and permissionless inspection that the malware does before performing these\nsteps is to identify the subscriber’s country and mobile network through the mobile country\ncodes (MCC) and mobile network codes (MNC). This inspection is done to target users within\na specific country or region. Both codes can be fetched by using either the\n_TelephonyManageror the SystemPropertiesclass. The TelephonyManager.getSimOperator()_\nAPI call returns the MCC and MNCcodes as a concatenated string, while other functions of\nthe same class can be used to retrieve various information about the mobile network that the\ndevice is currently subscribed to. As the network and SIM operator may differ (e.g., in\nroaming), the getSimOperatorfunction is usually preferred by malware developers.\n\nThe same type of information can be fetched by using the SystemProperties.get(String key)\nfunction where the key parameter may be one or several (using multiple calls) of the following\nstrings: gsm.operator.numeric, gsm.sim.operator.numeric, gsm.operator.iso-country,\n_gsm.sim.operator.iso-country, gsm.operator.alpha, gsm.sim.operator.alpha_\n\nThe difference with the first call is that the android.os.SystemProperties class is marked as\n_@SystemApi, therefore an application has to use Java reflection to invoke the function. The_\nMNC and MCC codes are also used to evade detection, as the malicious activity won’t be\nperformed unless the SIM operator belongs to the ones targeted:\n\n_Figure 2. Joker malware running its payload, targeting South African mobile operators_\nThe following sections present an analysis of the fraudulent subscription steps in the context\nof the Android operating system. This analysis can help identify the API calls and the\npermissions needed for the implementation of a toll fraud scheme.\n\n### Forcing cellular communication\n\nVariants of toll fraud malware targeting Android API level 28 (Android 9.0) or lower disable\nthe Wi-Fi by invoking the setWifiEnabled method of the WifiManager class. The permissions\nneeded for this call are ACCESS_WIFI_STATE and CHANGE_WIFI_STATE. Since the\nprotection level for both permissions is set to normal, they are automatically approved by the\nsystem.\n\nMeanwhile, malware targeting a higher API level uses the requestNetwork function of the\n_ConnectivityManagerclass. The_ [Android developers page describes the requestNetwork](https://developer.android.com/reference/android/net/ConnectivityManager#requestNetwork(android.net.NetworkRequest,%20android.net.ConnectivityManager.NetworkCallback))\n_method as:_\n\n\n-----\n\n_This method will attempt to find the best network that matches the given NetworkRequest,_\n_and to bring up one that does if none currently satisfies the criteria. The platform will evaluate_\n_which network is the best at its own discretion. Throughput, latency, cost per byte, policy,_\n_user preference and other considerations may be factored in the decision of what is_\n_considered the best network._\n\nThe required permission for this call is either CHANGE_NETWORK_STATE (protection level:\nnormal) or WRITE_SETTINGS(protection level: signature|preinstalled|appop|pre23), but\nsince the latter is protected, the former is usually preferred by malware developers. In the\ncode snippet depicted below from a malware sample that can perform toll fraud, the function\n_vgy7is requesting a TRANSPORT_CELLULAR transport type (Constant Value: 0x00000000)_\nwith NET_CAPABILITY_INTERNET (Constant Value: 0x0000000c):\n\n_Figure 3. Code from a Joker malware sample requesting a TRANSPORT_CELLULAR_\n_transport type_\n_Figure 3. Code from a Joker malware sample requesting a TRANSPORT_CELLULAR_\n_transport type_\n\nThe NetworkCallbackis used to monitor the network status and retrieve a networktype\nvariable that can be used to bind the process to a particular network via the\n_ConnectivityManager.bindProcessToNetworkfunction. This allows the malware to use the_\nmobile network even when there is an existing Wi-Fi connection. The proof-of-concept code\ndepicted below uses the techniques described above to request a TRANSPORT_CELLULAR\ntransport type. If the transport type is available, it binds the process to the mobile network to\nload the host at example.com in the application’s WebView:\n\n\n-----\n\n_Figure 4. Proof-of-concept code to request a TRANSPORT_CELLULAR transport type_\nWhile it is expected that the Wi-Fi connection is preferred even when mobile connection is\nalso available, the process exclusively uses the cellular network to communicate with the\nserver:\n\n\n-----\n\n_Figure 5. The mobile browser loads example.com when TRANSPORT_CELLULAR transport_\n_type is available and loads a blank page when only Wi-Fi is available_\nIn fact, the user must manually disable mobile data to prevent the malware from using the\ncellular network. Even though the setWifiEnabledhas been deprecated, it can still be used by\nmalware targeting API level 28 or lower.\n\n### Fetching premium service offers and initiating subscriptions\n\nAssuming that the SIM operator is on the target list and the device is using a\n_TRANSPORT_CELLULARtype network, the next step is to fetch a list of websites offering_\npremium services and attempt to automatically subscribe to them.\n\nThe malware will communicate with a C2 server to retrieve a list of offered services. An offer\ncontains, between else, a URL which will lead to a redirection chain that will end up to a web\npage, known as landing page.\n\n\n-----\n\nWhat happens next depends on the way that the subscription process is initiated, thus the\nmalware usually includes code that can handle various subscription flows. In a typical case\nscenario, the user has to click an HTML element similar to the one depicted below (JOIN\nNOW), and as a second step, send a verification code back to the server:\n\n_Figure 6. A_\n\n_subscription page that’s loaded in the background without the user’s knowledge._\nFor the malware to do this automatically, it observes the page loading progress and injects\nJavaScript code designed to click HTML elements that initiate the subscription. As the user\ncan only subscribe once to one service, the code also marks the HTML page using a cookie\nto avoid duplicate subscriptions. The following is an example of such a code:\n\n\n-----\n\n_Figure 7. JavaScript injected code scraping related HTML elements_\nOn line 76, getElementsByTagNamereturns a collection of all the Document Object Model\n(DOM) elements tagged as input. The loop on line 78 goes through every element and\nchecks its typeas well as its name, value, and altproperties. When an element is found to\ncontain keywords, such as “confirm”, “click”, and “continue”, it is sent to the cfunction, as\ndepicted below:\n\n_Figure 8. JavaScript function simulating clicks on_\n\n_selected HTML elements_\nThe if statement on line 36 checks if the element has already been clicked by calling the jdh\nfunction, displayed below in Figure 12. Finally, the c function invokes the click() or submit()\nfunction by the time the branch on line 37 (see figure 11) is followed:\n\n\n-----\n\n_Figure 9._\n\n_JavaScript code checking if the page has already been visited_\nThe HTML page loading process is tracked using an onPageFinishedcallback of the\n_WebViewClientattached to the WebView. Subsequently, a handler that listens for relative_\nmessage types acts depending on the next steps that are required for the subscription to take\nplace. In the code snippet below, the URL loaded in the WebView and a signalwith id “128”is\nsent to handler2to evaluate the service and initiate the subscription process:\n\n\n-----\n\n_Figure 10. Malware_\n\n_evaluating the steps required to initiate the subscription process_\nMulti-step or target subscription processes may require additional verification steps. The\nhandler depicted below checks the page URL loaded in the WebView. If the URL matches\n_doi[.]mtndep.co.za/service/, then the handler runs the JavaScript code assigned to the_\n_Properties.call_jbridge_dump variable:_\n\n_Figure 11. Malware running code depending on certain conditions_\n\n\n-----\n\nA signal with id 107 triggers some additional steps that require communication with the\ncommand and control (C2) server. This case is demonstrated in the following figures:\n\n_Figure 12. Malware_\n\n_running code depending on the specific signal id_\nUpon receiving the signal, the handler invokes the v1.bhu8 function:\n\n_Figure 13. Malware attacking anti-fraud protection_\nAfter checking for the web-zdm[.]secure-d[.]io/api/v1/activatein the server’s reply, the\nmalware invokes the tpack[.]l2.bhu8[.]vgy7 function. This function sends the current URL\nloaded in the application’s WebView as well as some extra information like country code, and\nHTML code:\n\n\n-----\n\n_Figure 14. Malware sending information to the C2 server_\n\n_Figure 15. A solver-type service offered by the C2 server_\n\n### Intercepting OTPs\n\nIn most cases, the service provider sends an OTP that must be sent back to the server to\ncomplete the subscription process. As the OTP can be sent by using either the HTTP or\nUSSD protocol or SMS, the malware must be capable of intercepting these types of\n\n\n-----\n\ncommunication. For the HTTP protocol, the server s reply must be parsed to extract the\ntoken. For the USSD protocol, on the other hand, the only way to intercept is by using the\naccessibility service.\n\nOne method of intercepting an SMS message, requiring android.permission.RECEIVE_SMS\npermission, is to instantiate a BroadcastReceiver that listens for the SMS_RECEIVED action.\n\nThe following code snippet creates a BroadcastReceiverand overrides the onReceivecallback\nof the superclass to filter out messages that start with “rch”:\n\n_Figure 16. Code that filters out SMS messages that start with “rch”_\nSubsequently, it creates an IntentFilter, which renders the receiver capable of listening for an\n_SMS_RECEIVED action, and finally the receiver is registered dynamically:_\n\n_Figure 17._\n\n_The IntentFilter enabling the receiver to listen for an SMS_RECEIVED action_\nTo handle OTP messages that are sent using the HTTP protocol, the malware parses the\nHTML code to search for keywords indicating the verification token. The following code\ncontains a flow where the extracted token is sent to the server using the sendTextMessage\nAPI call:\n\n\n-----\n\n_Figure 18. Extracted token is sent to the C2 server using the sendTextMessage API call_\nThe additional permission that is required to enable this flow is SEND_SMS.\n\nAnother way of intercepting SMS messages is to extend the NotificationListenerService. This\nservice receives calls from the system when new notifications are posted or removed,\nincluding the ones sent from the system’s default SMS application. The code snippet below\ndemonstrates this functionality:\n\n\n-----\n\n_Figure 19. Extending the NotificationListenerService service_\nWe triggered a notification with the title “SMS_Received” and text “Pin:12345” during our\nanalysis, resulting in the following output in the application’s logcat:\n\n_Figure 20. Logcat_\n\n_output after a notification is posted_\nFinally, besides the broadcast receiver and the notification listener techniques of intercepting\n[an SMS message, a ContentObserver can be used to receive callbacks for changes to](https://developer.android.com/reference/android/database/ContentObserver)\nspecific content. The onChange callback of the SmsObserver class (depicted below) is called\neach time the system changes the SMS content provider state:\n\n\n-----\n\n_Figure 21. The proof-of-concept code monitoring for incoming SMS messages through_\n_SmsObserver_\n\n### Suppressing notifications\n\nSince API level 18, an application that extends the NotificationListenerService is authorized\nto suppress notifications triggered from other applications. The relevant API calls are:\n\n_cancelAllNotifications() to inform the notification manager to dismiss all notifications_\n_cancelNotification(String key) to inform the notification manager to dismiss a single_\nnotification\n_cancelNotifications(String [] keys) to inform the notification manager to dismiss multiple_\nnotifications at once.\n\n\n-----\n\nThis API subset is abused by malware developers to suppress service subscription\nnotification messages posted by the default SMS application. More specifically, upon\nsuccessful subscription, the service provider sends a message to the user to inform them\nabout the charges and offers the option to unsubscribe. By having access to the notification\nlistener service, the malware can call any of the functions mentioned above to remove the\nnotification.\n\n### Using dynamic code loading for cloaking\n\nCloaking refers to a set of techniques used to hide malicious behavior. For example, most toll\nfraud malware won’t take any action if the mobile network is not among its targets. Another\nexample of a cloaking mechanism used by these threats is dynamic code loading. This\nmeans that certain malware codes are only loaded when certain conditions are met, making it\ndifficult to detect by static analysis.\n\nThe following is a characteristic example of a multi-stage toll fraud malware with SHA-256:\n_2581aba12919ce6d9f89d86408d286a703c1e5037337d554259198c836a82d75 and package_\nname: com.cful.mmsto.sthemes.\n\n**Stage one**\n\nThis malware’s entry point is found to be the com.android.messaging.BugleApplication, a\nsubclass of the Application class. The malicious flow leads to the function below:\n\n_Figure 22. The function where the entry point of the malware leads to_\n\n\n-----\n\nThe call on line 21 fills the filesarray with the filenames fetched from the assets directory. The\n_for loop enters theif branch at line 32 if the name of the asset file ends with “355”. Querying_\nthe asset files of the app for such a filename yields the following result:\n\n_Figure 23. Query result when searching for “355”_\nThe PhoneNumberAlternateFormatsProto_355 is the source file which, in conjunction with a\ndestination file and the string “xh7FEC2clYuoNQ$ToT99ue0BINhw^Bzy”, is given as\nparameters to the ns.j function:\n\n_Figure 24. The ns.j function_\nThe SecretKeySpec on line 68 is constructed from the first 16 bytes of the SHA-1 digest of\nthe password string. This key is used to decrypt the file fetched from the assets using\nAdvanced Encryption Standard (AES) in electronic codebook (ECB) mode. The decryption\nresult is an ELF file that is saved in the application’s cache directory and loaded using the\n_System.load function._\n\n\n-----\n\n**Stage two**\n\nThe loaded library fetches the PhoneNumberAlternateFormatsProto_300file from the assets\nfolder using the AAssetManager_fromJava function and writes it to a temporary file with the\nname b in the /data/data/<package_name>/ directory, as seen on line 93 below:\n\n_Figure 25. Fetching the second payload from the assets directory._\nThe file b is then decrypted using an XOR operation with the key\n“xh7FEC2clYuoNQ$ToT99ue0BINhw^Bzy”, which is given from the Java side (see following\nfigures). The decrypted payload is saved with the name l in the application’s data directory:\n\n\n-----\n\n_Figure 26. Decrypting asset_\n\n_Figure 27. The native handleTask called from the Java code_\n\nThe same function loads the decrypted payload l and invokes the com.AdsView.pulgn using\nthe DexClassLoader class loader (variable names have been changed for clarity):\n\n_Figure 28. Dynamically loading the decrypted asset using the DexClassLoader_\nDecrypting the second payload manually yields the following APK file:\n\n\n-----\n\n_Figure 29. The decrypted APK file_\nIt must be mentioned that the DexClassLoadercan be used to load classes from .jar and .apk\nfiles that contain a classes.dex entry.\n\n**Stage three**\n\nThis decrypted APK consists of two main classes: the com.Helperand com.AdsView. The\n_com.AdsView.pulgnfunction is the first to be invoked by the native library described in the_\nprevious section:\n\n_Figure 30. pulgn is the first function to be invoked when the payload is loaded_\nThe runnable thread’s main functionality is to connect the host to xn3o[.]oss_accelerate[.]aliyuncs[.]com and download a JAR file named xn30, which is saved to the_\ncache directory with name nvi and then loaded using the startSdk function, as shown on line\n81 below:\n\n\n-----\n\n_Figure 31. Download and trigger the final payload_\nThe file xn30 is the final payload of stage three and is the one that performs the toll fraud\nactivities previously described.\n\n## Mitigating the threat of toll fraud malware\n\nToll fraud is one of the most common malware categories with high financial loss as its main\nimpact. Due to its sophisticated cloaking techniques, prevention from the side of the user\nplays a key role in keeping the device secure. A rule of thumb is to avoid installing Android\napplications from untrusted sources (sideloading) and always follow up with device updates.\nWe also recommend end users take the following steps to protect themselves from toll fraud\nmalware:\n\nInstall applications only from the Google Play Store or other trusted sources.\nAvoid granting SMS permissions, notification listener access, or accessibility access to\nany applications without a strong understanding of why the application needs it. These\nare powerful permissions that are not commonly needed.\n[Use a solution such as Microsoft Defender for Endpoint on Android to detect malicious](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-endpoint-android)\napplications.\nIf a device is no longer receiving updates, strongly consider replacing it with a new\ndevice.\n\n### Identifying potential malware\n\nFor security analysts, it is important to be aware that conventional mitigation techniques\nbased on static detection of malware code patterns can only offer limited remediation against\nthis malware. This is due to the extended use of reflection, encryption, compression,\n\n\n-----\n\nobfuscation, steganography, and dynamic code loading.\n\nThere are, however, characteristics that can be used to identify this type of malware. We can\nclassify these characteristics into three:\n\nPrimary characteristics – patterns in plaintext included in the application that can be\nanalyzed statically\nSecondary characteristics – common API calls used to conduct toll fraud activities\nTertiary characteristics – patterns in Google Play Store metadata such as the\napplication’s category, the developer’s profile, and user reviews, among others\n\nThe tertiary characteristics are useful for initial filtering for potential malware. Patterns\nobserved in the apps’ metadata are related to malware developers’ attempts to infect as\nmany devices as possible in a short amount of time, while remaining published on the Google\nPlay Store for as long as they can. We’ve observed that attackers often follow these steps to\nkeep their apps in the Google Play Store:\n\n1. Use open-source applications that belong to popular categories and can be trojanized\n\n[with minimal effort. The preferred application categories include personalization (like](https://support.google.com/googleplay/android-developer/answer/9859673)\nwallpaper and lock screen apps), beauty, editor, communication (such as messaging\nand chat apps), photography, and tools (like cleaner and fake antivirus apps).\n2. Upload clean versions until the application gets a sufficient number of installs.\n3. Update the application to dynamically load malicious code.\n4. Separate the malicious flow from the uploaded application to remain undetected for as\n\nlong as possible.\n\nThese applications often share common characteristics:\n\nExcessive use of permissions that are not suitable to the application’s usage (for\nexample, wallpaper, editor, and camera apps that bind the notification listener service or\nask for SMS permissions)\nConsistent user interfaces, with similar icons, policy pages, and buttons\nSimilar package names\nSuspicious developer profile (fake developer name and email address)\nNumerous user complaints in the reviews\n\nOnce potential malware samples are identified based on these tertiary characteristics, the\nprimary characteristics can be used for further filtering and confirmation. Applications cannot\nobfuscate their permission requests, use of the notification listener service, or use of\naccessibility service. These requests must appear in the AndroidManifest.xml file within the\nAPK, where they can be easily detected using static analysis. The commonly requested\npermissions by malware performing toll fraud may include: READ_SMS, RECEIVE_SMS,\n\n\n-----\n\n_SEND_SMS, CHANGE_WIFI_STATE, ACCESS_WIFI_STATE,_\n_CHANGE_NETWORK_STATE. Requests for notification listener and accessibility service_\nshould be considered extremely suspicious.\n\nSecondary characteristics also include suspicious API calls including: setWifiEnabled,\n_requestNetwork, setProccessDefaultnetwork, bindProcessToNetwork, getSimOperator and_\n_cancelAllNotifications. However, since these calls may be obfuscated and may be hard to_\nidentify during static analysis, a more in-depth analysis may be necessary for certainty.\n\n### Improving Android security and privacy\n\nGoogle continuously improves Android security and privacy as the mobile threat landscape\nevolves and new threats and adversary techniques are discovered. For example, in the\noperating system, API calls that can reveal potentially sensitive information continue to be\nremoved or restricted, and in the Google Play Store, the publication policies guard against\nuse of certain high-risk permissions (for example, the ability to receive or send SMSs) by\n[requiring a Permission Declaration Form to be completed justifying their use. We anticipate](https://support.google.com/googleplay/android-developer/answer/9214102)\nAndroid security will continue to evolve to address abuse.\n\nAs discussed, applications currently can identify the cellular network operator and can send\nnetwork traffic over the cellular network without any transparency to the user. Additionally,\napplications can request access to read and dismiss notifications, a very powerful capability,\nwithout needing to justify this behavior.\n\n## Conclusion\n\nToll fraud has been one of the most prevalent types of Android malware in Google Play Store\nsince 2017, when families like Joker and their variants made their first appearance. It\naccounted for 34.8% of installed Potentially Harmful Application (PHA) from the Google Play\nStore in the first quarter of 2022, ranking second only to spyware.\n\nBy subscribing users to premium services, this malware can lead to victims receiving\nsignificant mobile bill charges. Affected devices also have increased risk because this threat\nmanages to evade detection and can achieve a high number of installations before a single\nvariant gets removed.\n\nWith this blog, we want to inform end users about the details of this threat and how they can\nprotect themselves from toll fraud. We also aim to provide security analysts with guidance on\nhow to identify other malicious applications that use these techniques.\n\nOur in-depth analysis of this threat and its continuous evolution informs the protection we\nprovide through solutions like Microsoft Defender for Endpoint on Android.\n\n\n-----\n\nLearn how Microsoft Defender for Endpoint provides cross-platform security, including mobile\nthreat defense capabilities.\n\n**_Dimitrios Valsamaras and Sang Shin Jung_**\n\n_Microsoft 365 Defender Research Team_\n\n## Appendix\n\n### Samples (SHA-256)\n\n**Sample** **SHA-256**\n\n\nInitial APK\nfile\n\nPayload of\nstage two:\nElf File\n(loader)\n\nPayload of\nstage three:\nAPK (hostile\ndownloader)\n\nPayload of\nstage four:\nDEX (billing\nfraud)\n\n\n2581aba12919ce6d9f89d86408d286a703c1e5037337d554259198c836a82d75\n(com.cful.mmsto.sthemes)\n\n904169162209a93ac3769ae29c9b16d793d5d5e52b5bf198e59c6812d7d9eb14\n(PhoneNumberAlternateFormatsProto_355, decrypted)\n\n61130dfe436a77a65c04def94d3083ad3c6a18bf15bd59a320716a1f9b39d826\n(PhoneNumberAlternateFormatsProto_300, decrypted)\n\n4298952f8f254175410590e4ca2121959a0ba4fa90d61351e0ebb554e416500f\n\n\n### Common API calls and permissions\n\n**API Calls** **Permissions** **SDK**\n\n\nsetWifiEnabled CHANGE_WIFI _STATE\nACCESS_WIFI_STATE\n\n\n<29\n\n\nrequestNetwork CHANGE_NETWORK_STATE >28\n\nsetProcessDefaultNetwork <23\n\nbindProcessToNetwork >22\n\ngetActiveNetworkInfo ACCESS_NETWORK_STATE\n\ngetSimOperator\n\nget (SystemProperties)\n\n\n-----\n\naddJavascriptInterface\n\nevaluateJavascript >18\n\nonPageFinished\n\nonPageStarted\n\n\nonReceive for SMS BroadcastReceiver w/\nandroid.provider.Telephony.SMS_RECEIVED\n\n\nRECEIVE_SMS >19\n\n\ncreateFromPdu RECEIVE_SMS\n\ngetMessageBody\n\n\nonChange for SMS ContentObserver w/\nandroid.provider.telephony.SmsProvider’s content\nURI (“content://sms”)\n\nsendTextMessage\n\nonNotificationPosted\n\n### References\n\n\nREAD_SMS\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-30 - Toll fraud malware- How an Android application can drain your wallet.pdf"
    ],
    "report_names": [
        "2022-06-30 - Toll fraud malware- How an Android application can drain your wallet.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535702,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1658167611,
    "ts_modification_date": 1658167611,
    "files": {
        "pdf": "https://archive.orkl.eu/a342b5bebe6be71f94b198f2aab2a3181ac8ea18.pdf",
        "text": "https://archive.orkl.eu/a342b5bebe6be71f94b198f2aab2a3181ac8ea18.txt",
        "img": "https://archive.orkl.eu/a342b5bebe6be71f94b198f2aab2a3181ac8ea18.jpg"
    }
}