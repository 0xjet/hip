{
    "id": "083b4ed4-1aaa-48c2-a02a-8bba28a28644",
    "created_at": "2023-01-12T15:10:57.228941Z",
    "updated_at": "2025-03-27T02:05:55.402633Z",
    "deleted_at": null,
    "sha1_hash": "b18466d15219f0fb6d369519eb5867066e57fca3",
    "title": "2020-02-07 - Emotet Evolves With New Wi-Fi Spreader",
    "authors": "",
    "file_creation_date": "2022-05-28T17:48:11Z",
    "file_modification_date": "2022-05-28T17:48:11Z",
    "file_size": 3667316,
    "plain_text": "# Emotet Evolves With new Wi-Fi Spreader\n\n**binarydefense.com/emotet-evolves-with-new-wi-fi-spreader/**\n\nFebruary 7, 2020\n\nEmotet is a highly sophisticated trojan that typically also serves as a loader for other malware. A key functionality of Emotet is its ability\nto deliver custom modules or plugins that are suited for specific tasks, including stealing Outlook contacts, or spreading over a LAN.\nRecently, Binary Defense has identified a new loader type that takes advantage of the wlanAPI interface to enumerate all Wi-Fi networks\nin the area, and then attempts to spread to these networks, infecting all devices that it can access in the process (as seen in Figure 1).\n\n_Figure 1 Wi-Fi spreader overview_\n\n**Emotet’s Protocol**\n\n\n-----\n\n[Before getting into the analysis, Emotet s Protocol should be explained. The protocol is based on Google s Protobufs to serialize data](https://developers.google.com/protocol-buffers)\nsent to and from the server. The documentation for Protobufs shows that data is defined through the use of protocol buffer message\ntypes in a .proto file. While [Emotet uses several of these “messages”, the one this analysis will be focusing on is the Deliverable](https://binarydefense.com/threat_watch/emotet-returns-for-a-new-year-of-spam/)\nmessage, which is used when the server sends a response containing data to be loaded/executed. The message is as follows:\n\n_message Deliverable {_\n_required int32 ID = 1;_\n_required int32 executeFlag = 2;_\n_required bytes blob = 3;_\n_}_\n\nIn the above protobuf message, ID is the module ID, blob is the binary data, and executeFlag determines how the binary loaded. The\nexecuteFlag field can be one of the following:\n\n1: Reserved for payloads and standalone executables, like Trickbot. Drops in C:\\ProgramData and executes.\n2: Like Type 1, but duplicates user’s token.\n3: Loads the binary into memory. Typically used by modules, as they are mainly DLLs which can be easily loaded into memory.\n\n**Initial Binary**\n\nThe initial binary for the Wi-Fi spreader arrives on a system with module ID: 5079 and executeFlag: 1, which means it will be dropped\ninto [C:\\ProgramData before executing, like loader updates or other malware, like TrickBot. This initial binary is a self-extracting RAR file](https://www.binarydefense.com/C:/ProgramData)\nwhich contains the 2 binaries used for Wi-Fi spreading.\n\n_Figure 2 RAR Extraction_\n\nThe self-extracting RAR contains 2 files: service.exe and worm.exe. Worm.exe is configured as the setup file, as seen in Figure 2, for the\nself-extracting RAR, which means worm.exe will execute automatically once the RAR file has unpacked itself.\n\n**Worm.exe**\n\n\n-----\n\nWorm.exe is the main executable used for spreading. This executable has a timestamp of 04/16/2018 and was first submitted to\n[VirusTotal on 05/04/2018. The executable with this timestamp contained a hard-coded IP address of a Command and Control (C2)](https://www.virustotal.com/gui/home/upload)\nserver that was used by Emotet. This hints that this Wi-Fi spreading behavior has been running unnoticed for close to two years. This\nmay be in part due to how infrequently the binary is dropped. Based on our records, 01/23/2020 was the first time that Binary Defense\nobserved this file being delivered by Emotet, despite having data going back to when Emotet first came back in late August of 2019.\n\n**Operation of Worm.exe**\n\nUpon startup of Worm.exe, the first action it takes is to copy the service.exe string to a variable that will be used during file spreading.\nNext, it steps into the main loop and immediately begins profiling the wireless network using wlanAPI.dll calls in order to spread to any\nnetworks it can access, as seen in Figure 3.\n\n_Figure 3 Worm.exe Start_\n\nThe use of purely wlanAPI.dll calls for network profiling makes sense; it is one of the libraries used by Native Wi-Fi to manage wireless\nnetwork profiles and wireless network connections. A possibly unintended consequence of this is that researchers running this malware\nin VMs/automated sandboxes will not see any of worm.exe’s spreading behavior if a Wi-Fi card is not present. This can be bypassed\npartially by starting the WLAN auto config service in Windows 10; however, this only allows opening a handle to interface with. The\nsubsequent calls will crash the program at that point, so the bypass is not recommended.\n\n**Worm Information Gathering**\n\n\n-----\n\nAs seen in Figure 3, once a handle has been obtained, WlanEnumInterfaces is called. This function enumerates all Wi Fi devices\ncurrently enabled on the local computer, which it returns in a series of structures. These structures contain all the information relating to\nthe Wi-Fi device, including the device’s GUID and description.\n\nUsing the first available Wi-Fi device, WlanGetAvailableNetworkList is called to obtain a list of all available networks. Interestingly, this\nhas the dwFlag parameter set to WLAN_AVAILABLE_NETWORK_INCLUDE_ALL_ADHOC_PROFILES, which is an invalid parameter\non Windows XP with SP3 and Wireless LAN API for Windows XP with SP2, meaning this malware cannot properly run on Windows XP.\n\nNext, the malware begins profiling the network, saving the following information to a buffer:\n\n_SSID:        %s_\n_SIGNAL:       %d_\n_SECURITY:      [WPA|WPA2|UNKNOWN|WEP|OPEN]_\n_encryption:     [UNKNOWN|WEP104|CCMP|TKIP|WEP40|NONE]_\n_Note: [Current Connecting| OR_\n_WLAN_AVAILABLE_NETWORK_HAS_PROFILE| OR_\n_WLAN_AVAILABLE_NETWORK_CONSOLE_USER_PROFILE]_\n\nThis information is gathered for every available network in the list of networks. Then, a massive switch case used to handle connection\nnotifications is passed to the Wi-Fi device using WlanRegisterNotification. Finally, the network authentication method is obtained and\nencryption is parsed again. This can be one of the following:\n\nWPA2PSK\nWPAPSK\nUNKNOWN\nWEP\nOPEN\n\nThe encryption method can be one of the following:\n\nTKIP\nNOEN (None misspelled)\nWEP\nAES\n\n\n-----\n\n_Figure 4 Worm Generating Network Profile_\n\n**Worm Connection Brute-Forcing**\n\nAs seen in Figure 4, once each the information for each network has been obtained, the malware moves into the connection, bruteforcing loops. The first step is to zero out two important flags and then to use the data obtained to fill in the below template that will be\nused to create the Network Profiles:\n\n_<?xml version=”1.0″ encoding=”UTF-8″?>_\n\n_<WLANProfile xmlns=”http://www.microsoft.com/networking/WLAN/profile/v1″>   <name>%s</name>_\n\n_<SSIDConfig>_\n\n_<SSID>_\n\n_<name>%s</name>_\n\n_</SSID>_\n\n_</SSIDConfig>_\n\n_<connectionType>ESS</connectionType_\n\n_<connectionMode>auto</connectionMode>_\n\n_<MSM>_\n\n_<security>_\n\n_<authEncryption>_\n\n_<authentication>%s</authentication>_\n\n_<encryption>%s</encryption>_\n\n_<useOneX>false</useOneX>_\n\n_</authEncryption>_\n\n_<sharedKey>_\n\n\n-----\n\n_keyType passPhrase /keyType_\n_<protected>false</protected>_\n_<keyMaterial>%s</keyMaterial>_\n_</sharedKey>_\n_</security>_\n_</MSM>_\n_</WLANProfile>_\n\nIn the keyMaterial field, a password obtained from one of two internal password lists is used. Next, the profile is set and a connection is\nattempted.\n\nIf the connection results in “wlan_notification_acm_network_available”, NetworkAvailableFlag is set to 1.\nIf the connection results in “wlan_notification_msm_connected”, NetworkAvailableFlag and NetworkConnectedFlag are both set to\n1.\nIf the connection is not successful, NetworkAvailableFlag and NetworkConnectedFlag are both set to 0, and the function loops after\nmoving to the next password in the password list.\n\nIf the connection is successful, the malware sleeps for 14 seconds before sending an HTTP POST to its Command and Control (C2)\nserver at 87.106.37[.]146 on port 8080. The resource requested is a static, hard-coded value:\n_87.106.37[.]146:8080/230238982BSBYKDDH938473938HDUI33/index.php_\n\nThe data contained in the POST is:\n_c=<WirelessNetworkConnected>:<Password>_\n\nOnce a connection is established with the Wi-Fi network, worm.exe begins enumerating users and attempting to brute-force passwords\nfor all users on the network.\n\n\n-----\n\n_Figure 5 Enumerating all non-hidden shares_\n\n**Worm User Brute-Forcing**\n\nWith the infected victim now connected to a new network, the malware begins enumerating all non-hidden shares on the network, as\nseen in Figure 5. Once shares have been discovered, the malware attempts to connect to the IPC$ share for the network resources.\nUsing IPC$, it attempts to enumerate all users connected to the network resource. Using the second password list contained in the\nmalware, the malware attempts to then brute-force its way into all users enumerated, saving each successful attempt to 2 buffers: one\nfor the username and one for the password.\n\nIf it is unable to guess passwords for any users, it pivots to attempting to brute-force the “Administrator” account for the network\nresource.\n\nIf either of these brute-force attempts are successful, it then moves onto the spreader function.\n\n**Spreader**\n\n\n-----\n\n_Figure 6 Connecting and generating “my.exe”_\n\nWith buffers containing either a list of all usernames successfully brute-forced and their passwords, or the Administrator account and its\npassword, worm.exe can now begin spreading service.exe to other systems.\n\nThe malware first attempts to gain access to the C$\\\\ share for the connected network resource. This gives it access to the C drive of the\nspecified username. From there, it drops service.exe as my.exe in C:\\\\, as seen in Figure 6. Additionally, it adds a new service with the\nfollowing information using the recently dropped my.exe.\n\n_Binary Path Name: C:\\\\my.exe_\n_Desired Access: SERVICE_ALL_ACCESS_\n_Display Name: WinDefService_\n_Service Name: Windows Defender System Service_\n\nIt then starts this service, executing service.exe as my.exe on a remote system.\n\n\n-----\n\nService.exe is the infected payload installed on remote systems by worm.exe. This binary has a PE timestamp of 01/23/2020, which was\nthe date it was first found by Binary Defense. This binary is installed as a service called WinDefService by worm.exe.\n\n**Main Thread**\n\nService.exe’s startup is simple. It has a ServiceMain setup, which calls StartServiceCtrlDispatcher to connect the main thread of the\nservice process to the service control manager, meaning the main thread is run when the service is executed.\n\nIn the main thread, service.exe starts a new thread, which serves two purposes:\n\n1. Communicate back to a new C2 when the service is installed.\n2. Drop and execute the Emotet binary embedded in service.exe.\n\n**Service Communication**\n\nThe first action service.exe takes is to open a connection to 45.79.223[.]161:443 and send a request to\n/09FGR20HEU738LDF007E848F715BVE.php. Although the connection to the server uses port 443, which is normally used for Transport\nLayer Security (TLS) encrypted communications, the connection is unencrypted HTTP. When opening this connection, service.exe sets\nthe following flags:\n\n0x80000000 – INTERNET_FLAG_RELOAD\n0x04000000 – INTERNET_FLAG_NO_CACHE_WRITE\n0x00040000 – INTERNET_FLAG_NO_AUTH\n0x00008000 – INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP\n0x00004000 – INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS\n0x00002000 – INTERNET_FLAG_IGNORE_CERT_DATE_INVALID\n0x00001000 – INTERNET_FLAG_IGNORE_CERT_CN_INVALID\n0x00000400 – INTERNET_FLAG_HYPERLINK\n0x00000200 – INTERNET_FLAG_NO_UI\n0x00000100 – CACHE_ENTRY_ACCTIME_FC\n\nThe resource requested is hardcoded and static. This IP is currently an active Emotet Command and Control server (C2). The data\ncontained in the request is:\n\n_“c=installed”_\n\nThis notifies the server that service.exe has been properly installed. As both this request and the request sent by worm.exe are not sent\nover TLS/SSL, a [Suricata rule is included in this analysis.](https://suricata.readthedocs.io/en/suricata-4.1.4/what-is-suricata.html)\n\n_Figure 7. Flags used to create the new Emotet process_\n\n**Emotet Process**\n\nAfter service.exe has installed itself and communicated back to the C2, it begins dropping the embedded Emotet executable. First, it\nobtains the path to %TEMP%, and concatenates “setup.exe” to the end of it. Next, it enters a function which locates the embedded\nexecutable by specifying a hard-coded buffer offset. Once the embedded executable is located, it creates a new file at\n%Temp%\\\\setup.exe and writes the embedded executable to this file. It then calls CreateProcess in order to create a new process\nrunning the Emotet Executable as seen in Figure 7.\n\n\n-----\n\n**g**\n\nWith this newly discovered loader-type used by Emotet, a new threat vector is introduced to Emotet’s capabilities. Previously thought to\nonly spread through malspam and infected networks, Emotet can use this loader-type to spread through nearby wireless networks if the\nnetworks use insecure passwords. Binary Defense’s analysts recommend using strong passwords to secure wireless networks so that\nmalware like Emotet cannot gain unauthorized access to the network. Detection strategies for this threat include active monitoring of\nendpoints for new services being installed and investigating suspicious services or any processes running from temporary folders and\nuser profile application data folders. Network monitoring is also an effective detection, since the communications are unencrypted and\nthere are recognizable patterns that identify the malware message content.\n\n**IOCs**\n\n**Name** **Hash** **C2** **Additional IOCs**\n\n9.file 865cf5724137fa74bd34dd1928459110385af65ffa63b3734e18d09065c0fb36 87.106.37.146:8080,\n45.79.223.161:443\n\nWorm.exe 077eadce8fa6fc925b3f9bdab5940c14c20d9ce50d8a2f0be08f3071ea493de8 87.106.37.146:8080\n\nService.exe 64909f9f44b02b6a4620cdb177373abb229624f34f402335ecdb4d7c8b58520b 45.79.223.161:443 WinDefService\n%Temp%//setup.exe\n\nSuricata:\n\n_alert http $HOME_NET any <> 87.106.37.146 8080 (msg: “BDS BACKDOOR Emotet Wi-Fi spreader_\n_likely”;content:”POST”;http_method;content:”/230238982BSBYKDDH938473938HDUI33/index.php”;http_uri;classtype:backdoor-_\n_activity;sid:1;rev:1;)_\n_alert http $HOME_NET any <> 45.79.223.161 443 (msg: “BDS BACKDOOR Emotet Wi-Fi spreader_\n_likely”;content:”POST”;http_method;content:”/09FGR20HEU738LDF007E848F715BVE.php”;http_uri;classtype:backdoor-_\n_activity;sid:2;rev:1;)_\n\nYara:\n\nrule Emotet_Wifi_Worm {\n\nmeta:\n\ntitle = “Emotet Wi-Fi spreader, Worm.exe”\n\nauthor = “james.quinn@binarydefense.com”\n\nstrings:\n\n$string1 = ” NOTE : WLAN_AVAILABLE_NETWORK_HAS_PROFILE”\n\n$string2 = “IPC$” wide\n\n$ParseEnc =  { 8d 04 0e ff b0 64 02 00 00 05 0c 02 00 00 50 68 ?? ?? ?? ?? e8 ?? ?? ?? ?? 83 c4 0c 68 ?? ?? ?? ?? e8 ?? ?? ??\n?? 8b 44 ?4 14 8b 84 06 6c 02 00 00 59 83 f8 01 74 ?? 83 f8 02 74 ?? 7e ?? 83 f8 05 7e ?? 83 f8 07 7f ?? 68 ?? ?? ?? ?? eb ?? 68 ??\n?? ?? ?? eb ?? 68 ?? ?? ?? ?? eb ?? 68 ?? ?? ?? ?? eb ?? 68 ?? ?? ?? ?? e8 ?? ?? ?? ?? 59 68 ?? ?? ?? ?? e8 ?? ?? ?? ?? 8b 44 ?4\n14 8b 84 06 70 02 00 00 2b c3 59 74 ??  }\n\ncondition:\n\nall of them and uint16(0) == 0x5A4D\n\n}\n\nrule Emotet_Wifi_Service {\n\nmeta:\n\ntitle = “Emotet Wi-Fi Spreader, Service.exe”\n\nauthor = “james.quinn@binarydefense.com”\n\nstrings:\n\n$string1 = “WinDefService” wide\n\n\n-----\n\n$string2 c installed\n\n$CommsFunc = { 6a 00 68 00 f7 04 84 6a 00 6a 00 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 8d 45 f4 50 56 ff 15 ?? ?? ?? ?? 8b d8 85 db 74\n??  }\n\ncondition:\n\nall of them and uint16(0) == 0x5A4D\n\n}\n\n**About the Author**\n\nJames Quinn is a Threat Researcher and Malware Analyst for Binary Defense. When he is not working at Binary Defense, he works as a\nfreelance malware analyst and participates in security intelligence sharing groups. James is a major contributor to research of the\nEmotet botnet with the Cryptolaemus security researcher group.\n\n**About Binary Defense**\n\nBinary Defense is a managed security services provider with leading cybersecurity solutions that include SOC-as-a-Service, Managed\nDetection & Response, Security Information & Event Management and Counterintelligence. With our human-driven, technology-assisted\napproach, Binary Defense is able to provide their clients with immediate protection and visibility, combating and stopping the next\ngeneration of attacks that your business faces. The company isheadquartered in Stow, Ohio at 600 Alpha Parkway.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-07 - Emotet Evolves With New Wi-Fi Spreader.pdf"
    ],
    "report_names": [
        "2020-02-07 - Emotet Evolves With New Wi-Fi Spreader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536257,
    "ts_updated_at": 1743041155,
    "ts_creation_date": 1653760091,
    "ts_modification_date": 1653760091,
    "files": {
        "pdf": "https://archive.orkl.eu/b18466d15219f0fb6d369519eb5867066e57fca3.pdf",
        "text": "https://archive.orkl.eu/b18466d15219f0fb6d369519eb5867066e57fca3.txt",
        "img": "https://archive.orkl.eu/b18466d15219f0fb6d369519eb5867066e57fca3.jpg"
    }
}