{
    "id": "b47e526c-70a1-4413-8808-08325badde8d",
    "created_at": "2022-10-25T16:48:21.703117Z",
    "updated_at": "2025-03-27T02:16:25.868727Z",
    "deleted_at": null,
    "sha1_hash": "ca9b35c1494cea8229628edc7f0111eb09118f48",
    "title": "",
    "authors": "",
    "file_creation_date": "2017-09-19T09:40:58Z",
    "file_modification_date": "2017-09-19T09:40:58Z",
    "file_size": 2046285,
    "plain_text": "# Subverting Trust in Windows\n\n## Matt Graeber\n\n\n-----\n\n## Introduction\n\nIn the context of computer security, what is trust? Is it an implicit feeling of safety offered by modern\nsecurity solutions that alert to the presence of malicious code and/or actions? Is trust something that\nmust be explicitly acquired through careful evaluation of the software required to accomplish work in an\nenterprise? In reality, there is no single correct answer. Trust is inherently subjective. What is important\nis that each organization carefully consider what it means to place trust in technology. Organizations\nthat have a mature definition of trust should also question the means by which trust is validated by\nsecurity solutions and operating systems.\n\nNow that the wheels are turning in your head about what trust means to you, excluding code reviews\ninvolving manual human intervention, what are the technical means by which trust is validated? This is\nobviously a much more difficult question to answer and one that you may not have even asked yourself.\nThe intent of this whitepaper is to shine a light on how trust decisions are made by Microsoft Windows.\nBy demonstrating how trust can be subverted in Windows, you will hopefully be motivated to more\nfrequently ask yourself what trust means to you - an extremely important and underappreciated\nconcept in security.\n\nBeyond just the validation of the source and integrity of signed code, code signing and trust validation\nare also critical malware classification components for many security products (e.g. anti-virus and EDR\nsolutions). Proper trust validation also serves as an enforcement component of most application\nwhitelisting solutions (AppLocker, Device Guard, etc.). Subverting the trust architecture of Windows, in\nmany cases, is also likely to subvert the efficacy of security products.\n\n\n-----\n\n## The Windows User Mode Trust Architecture\n\nThe means by which executable code is attested to originate from a particular vendor is achieved with\n[Authenticode](https://msdn.microsoft.com/en-us/library/ms537359(v=vs.85).aspx) digital signatures. Within user mode, the APIs through which the trust of signed code is\nvalidated in user mode are [WinVerifyTrust and](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388208(v=vs.85).aspx) [WinVerifyTrustEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388209(v=vs.85).aspx) (which is simply a wrapper for\nWinVerifyTrust with a more well-defined function prototype).\n\nAs the footprint of Windows has grown over time, there has been a need to extend the signing and trust\narchitecture to support additional file and binary blob formats. Depending on the file/blob specification,\nsignatures may need to be stored in different formats and trust should be validated in a fashion specific\n[to the technology. For example, digital signatures are stored in the PE file format](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx) in one particular one\nway in a binary format. PowerShell scripts, on the other hand, are text files that can be signed, so their\nsignature, understandably, needs to be stored differently. Additionally, when signing code, hashes of the\ncode to be signed (typically referred to as the Authenticode hash) need to be computed and the way this\nis performed is different depending on the file/blob format. Regarding trust validation of digital\nsignatures, the method in which the trust of a device driver is established versus that of an HTTPS\ncertificate will, understandably, be different.\n\nConsidering the need to support digital signatures on unique formats and to perform trust validation in\nunique manners, Microsoft designed an extensible architecture to support just that. The [subject](https://msdn.microsoft.com/en-us/library/ms721625(v=vs.85).aspx)\n[interface package](https://msdn.microsoft.com/en-us/library/ms721625(v=vs.85).aspx) (SIP) architecture was designed to support the creation, retrieval, and hash\ncalculation/validation of digital signatures. The validation of trust of signed code is performed using\n[trust providers. Both the trust provider and SIP architectures are completely abstracted away from a](https://msdn.microsoft.com/en-us/library/ms721627(v=vs.85).aspx)\nsoftware developer performing code signing and/or trust validation through the use of WinVerifyTrust\nand various other exported functions in both wintrust.dll and crypt32.dll. As of this writing, there is no\nevidence that documentation of this architecture has been extended to third party software developers\nthat might want to support signing infrastructure for their specific file formats. One possible reason this\nmay have not occurred is because any file, regardless of format, can technically be “signed” through the\nusage of [catalog signing](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files) - a file format containing a list of file hashes that can then be Authenticode\nsigned. Do note that validation of catalog files can only occur if the “CryptSvc” service is running.\n\nAside from various Windows SDK header files and the occasional MSDN documentation for exported\nwintrust.dll and crypt32.dll functions, trust providers and SIPs are not documented. Due to the\ncomplexity involved in 3rd-party implementation however, Microsoft likely intentionally chose to not\ndocument these architectures. This whitepaper serves to document the trust provider and SIP\narchitectures while also explaining the ways in which they can be abused by an attacker as a means of\nsubverting trust, and optionally, gaining code execution in the context of processes that perform trust\nvalidation.\n\nAdditional topics covered briefly in this whitepaper will be the extensibility of the CryptoAPI in general\nto include cryptographic encoding/decoding, certificate management, etc. Microsoft couldn’t possibly\nanticipate future cryptographic requirements so they designed a fully extensible architecture\n\n\n-----\n\n(presumably dating back the early 90s) to accommodate the needs of the present and the future.\nUnfortunately, it’s this very extensibility that permits an attacker (with elevated privileges) to hijack\nexisting functionality.\n\n### Determining What Files Can Be Signed\n\nHow does one know what executable file types can be signed? A naïve approach might be to look at the\nfile properties of a potentially signed file and look at the “Digital Signatures” tab.\n\n**_The \"Digital Signatures\" tab indicates the presence of an embedded Authenticode signature._**\n\nWhile this method may confirm that some file types can be signed, as is the case in the image above for\n[ise.psm1 (a PowerShell script module file), this is far from a systematic method of performing signable](https://msdn.microsoft.com/en-us/library/dd878324(v=vs.85).aspx)\nfile type enumeration. Signature support for file types is implemented as part of a subject interface\npackage (SIP) - the architecture responsible for the creation, retrieval, and hash calculation/validation of\n\n\n-----\n\ndigital signatures. For example, in the image above, it can be seen that PowerShell script modules can be\nsigned. How does the Explorer UI know that PowerShell code can be signed in the first place?\n\nHere is a portion of the embedded signature in ise.psm1:\n```\n# SIG # Begin signature block\n# MIIXXAYJKoZIhvcNAQcCoIIXTTCCF0kCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB\n# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR\n# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUv0M9fHFPOaghmrZBoun/tqPG\n# zE6gghIxMIIEYDCCA0ygAwIBAgIKLqsR3FD/XJ3LwDAJBgUrDgMCHQUAMHAxKzAp\n# BgNVBAsTIkNvcHlyaWdodCAoYykgMTk5NyBNaWNyb3NvZnQgQ29ycC4xHjAcBgNV\n# BAsTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEhMB8GA1UEAxMYTWljcm9zb2Z0IFJv\n# b3QgQXV0aG9yaXR5MB4XDTA3MDgyMjIyMzEwMloXDTEyMDgyNTA3MDAwMFoweTEL\n# MAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1v\n# bmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEjMCEGA1UEAxMaTWlj\n# cm9zb2Z0IENvZGUgU2lnbmluZyBQQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\n# ggEKAoIBAQC3eX3WXbNFOag0rDHa+SU1SXfA+x+ex0Vx79FG6NSMw2tMUmL0mQLD\n# TdhJbC8kPmW/ziO3C0i3f3XdRb2qjw5QxSUr8qDnDSMf0UEk+mKZzxlFpZNKH5nN\n# sy8iw0otfG/ZFR47jDkQOd29KfRmOy0BMv/+J0imtWwBh5z7urJjf4L5XKCBhIWO\n# sPK4lKPPOKZQhRcnh07dMPYAPfTG+T2BvobtbDmnLjT2tC6vCn1ikXhmnJhzDYav\n…\n# HNHPPQanI9HpDNBxWrVzcH6zIV1vBHSeB/tFtZpOI+beHjx7X3d1cyCg5lfERzyQ\n# 3jJyjSbMMbz8Pj/1meM0rlWQ/ZnYYiQAtJYqUN3ctT21Uu3ZVVnw46A8voTnSRMd\n# 5mVFLFMeFyJkWgsyqLroBTm4U/G+gZ2BB0ImzSbSfIo=\n# SIG # End signature block\n\n```\nThis is how signatures happen to be stored in PowerShell code (MOF files being an exception). To\ncomplicate matters, every file type that can be signed has its signature stored in a unique fashion. For\n[example, the PE Authenticode specification explains how signatures are stored and validated in PE files](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx)\n(e.g. EXE, DLL, SYS, etc.).\n\nOne of the functions used to discover the SIP associated with a particular file type is the\n[CryptSIPRetrieveSubjectGuid](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542590(v=vs.85).aspx) function in crypt32.dll (most frequently called indirectly via\n[WinVerifyTrust). Given a filename and optional handle, CryptSIPRetrieveSubjectGuid returns a GUID that](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388208(v=vs.85).aspx)\nrepresents the SIP that can handle retrieving an embedded Authenticode signature. The function\nroughly works as follows:\n\n1. Based on file magic values, it tries to determine if the file is a PE, catalog file, CTL, or cabinet file.\n\nIf it is any of these file types, it returns the following respective SIP GUID:\n\n      - `C689AAB8-8E78-11D0-8C47-00C04FC295EE - PE`\n\n      - `DE351A43-8E59-11D0-8C47-00C04FC295EE - Catalog`\n\n      - `9BA61D3F-E73A-11D0-8CD2-00C04FC295EE - CTL`\n\n      - `C689AABA-8E78-11D0-8C47-00C04FC295EE - Cabinet`\n2. [If the file doesn’t match any of the previous file types, it will call CryptEnumOIDFunction, passing](https://msdn.microsoft.com/en-us/library/windows/desktop/aa379927(v=vs.85).aspx)\n\nit a function name of “CryptSIPDllIsMyFileType” and “CryptSIPDllIsMyFileType2”. These\nfunctions correspond to a lookup of the following registry keys, respectively:\n\n\n-----\n\n      - `HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\Enco`\n```\n       dingType 0\\CryptSIPDllIsMyFileType\\<All sub-GUIDs>\n\n```\n      - `HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\Enco`\n```\n       dingType 0\\CryptSIPDllIsMyFileType2\\<All sub-GUIDs>\n\n```\nAs CryptEnumOIDFunction enumerates each SIP GUID registry subkey, it will call the export function\nfrom the DLL listed in the “FuncName” and “Dll” registry values.\n\nThe function prototype for “CryptSIPDllIsMyFileType” is documented here and the function prototype\nfor “CryptSIPDllIsMyFileType2” is documented [here. If implemented, “CryptSIPDllIsMyFileType”](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542640(v=vs.85).aspx)\nfunctions are first called and if one of its functions returns “TRUE”, the SIP GUID that handles signatures\nis returned. In practice (on Windows 10, at least), no SIPs implement “CryptSIPDllIsMyFileType” so\n“CryptSIPDllIsMyFileType2” functions are then called to attempt to resolve the handling SIP. For\nexample, PowerShell (SIP GUID: 603BCC1F-4B59-4E08-B724-D2C6297EF351) implements\nCryptSIPDllIsMyFileType2 as pwrshsip!PsIsMyFileType. Upon disassembling, decompiling, and cleaning\nup the output, here is a representation of the PsIsMyFileType function in C for illustration purposes:\n```\n#define CRYPT_SUBJTYPE_POWERSHELL_IMAGE        \\\n { 0x603BCC1F,                    \\\n  0x4B59,                      \\\n  0x4E08,                      \\\n  { 0xB7, 0x24, 0xD2, 0xC6, 0x29, 0x7E, 0xF3, 0x51 } \\\n }\nBOOL WINAPI PsIsMyFileType(IN WCHAR *pwszFileName, OUT GUID *pgSubject) {\n BOOL bResult;\n WCHAR *SupportedExtensions[7];\n WCHAR *Extension;\n GUID PowerShellSIPGUID = CRYPT_SUBJTYPE_POWERSHELL_IMAGE;\n SupportedExtensions[0] = L\"ps1\";\n SupportedExtensions[1] = L\"ps1xml\";\n SupportedExtensions[2] = L\"psc1\";\n SupportedExtensions[3] = L\"psd1\";\n SupportedExtensions[4] = L\"psm1\";\n SupportedExtensions[5] = L\"cdxml\";\n SupportedExtensions[6] = L\"mof\";\n bResult = FALSE;\n if (pwszFileName && pgSubject) {\n  Extension = wcsrchr(pwszFileName, '.');\n  if (Extension) {\n   Extension++;\n   for (int i = 0; i < 7; i++) {\n    if (!_wcsicmp(Extension, SupportedExtensions[i])) {\n     bResult = TRUE;\n     memcpy(pgSubject, &PowerShellSIPGUID, sizeof(GUID));\n      break;\n    }\n\n```\n\n-----\n\n```\n   }\n  }\n }\n else {\n  SetLastError(ERROR_INVALID_PARAMETER);\n }\n return bResult;\n}\n\n```\nAs can be seen in the C code, if any file has any of the above extensions, then the PowerShell SIP will be\nused as the SIP for code signing purposes. “CryptSIPDllIsMyFileType2” need not just inspect file\nextensions though. The SIP could also optionally open a file handle and inspect magic values in the file to\nmake the correct file/blob SIP handler determination.\n\nOther supported SIP file type handler functions are as follows (non-exhaustive list):\n```\n 1. 000C10F1-0000-0000-C000-000000000046\n C:\\Windows\\System32\\MSISIP.DLL\n MsiSIPIsMyTypeOfFile\n 2. 06C9E010-38CE-11D4-A2A3-00104BD35090\n C:\\Windows\\System32\\wshext.dll\n IsFileSupportedName\n 3. 0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1\n C:\\Windows\\System32\\AppxSip.dll\n AppxSipIsFileSupportedName\n 4. 0F5F58B3-AADE-4B9A-A434-95742D92ECEB\n C:\\Windows\\System32\\AppxSip.dll\n AppxBundleSipIsFileSupportedName\n 5. 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB\n C:\\Windows\\System32\\wshext.dll\n IsFileSupportedName\n 6. 1A610570-38CE-11D4-A2A3-00104BD35090\n C:\\Windows\\System32\\wshext.dll\n IsFileSupportedName\n 7. 5598CFF1-68DB-4340-B57F-1CACF88C9A51\n C:\\Windows\\System32\\AppxSip.dll\n P7xSipIsFileSupportedName\n 8. 603BCC1F-4B59-4E08-B724-D2C6297EF351\n C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\pwrshsip.dll\n PsIsMyFileType\n 9. 9F3053C5-439D-4BF7-8A77-04F0450A1D9F\n C:\\Windows\\System32\\EsdSip.dll\n\n```\n\n-----\n\n```\n EsdSipIsMyFileType\n 10. CF78C6DE-64A2-4799-B506-89ADFF5D16D6\n C:\\Windows\\System32\\AppxSip.dll\n EappxSipIsFileSupportedName\n 11. D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C\n C:\\Windows\\System32\\AppxSip.dll\n EappxBundleSipIsFileSupportedName\n\n```\nIt may be a valuable exercise for the reader to reverse some of the above functions to see what types of\nfile and/or binary blobs Windows supports for code signing.\n\nOnce the software that needs to retrieve a signature obtains the GUID for the SIP, it can then proceed to\nextract the certificate.\n\n### File Signature Retrieval and Hash Validation\n\nOnce the SIP responsible for handling signing for a particular file/binary blob format is identified via its\nrespective GUID identifier, WinVerifyTrust will then know how to obtain the digital signature from the\nfile in question and validate its computed hash against the signed hash embedded within the digital\nsignature. To achieve this, WinVerifyTrust calls the following functions in the registry:\n\nSIP signature retrieval function location:\n```\n  ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingTy\n   pe 0\\CryptSIPDllGetSignedDataMsg\\{SIP Guid}\n     ○ Dll\n     ○ FuncName\n\n```\nSIP hash validation function:\n```\n  ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingTy\n   pe 0\\CryptSIPDllVerifyIndirectData\\{SIP Guid}\n     ○ Dll\n     ○ FuncName\n\n```\nThe function prototypes for CryptSIPDllGetSignedDataMsg and CryptSIPDllVerifyIndirectData are both\ndocumented in MSDN as well as within mssip.h in the Windows SDK.\n\nSIP signature retrieval function prototype:\n```\nBOOL WINAPI CryptSIPGetSignedDataMsg(\n   IN   SIP_SUBJECTINFO *pSubjectInfo,\n   OUT   DWORD      *pdwEncodingType,\n   IN   DWORD      dwIndex,\n   IN OUT DWORD      *pcbSignedDataMsg,\n   OUT   BYTE      *pbSignedDataMsg);\n\n```\n\n-----\n\nSIP hash validation function:\n```\nBOOL WINAPI CryptSIPVerifyIndirectData(\n   IN   SIP_SUBJECTINFO   *pSubjectInfo,\n   IN   SIP_INDIRECT_DATA  *pIndirectData);\n\n```\nThe arguments supplied to these functions are populated by the calling trust provider (more details on\nthe trust provider architecture in sections to follow). When CryptSIPGetSignedDataMsg is called, the SIP\n[will extract the encoded digital signature (a CERT_SIGNED_CONTENT_INFO structure most often ASN.1](https://msdn.microsoft.com/en-us/library/windows/desktop/aa377540(v=vs.85).aspx)\nPKCS_7_ASN_ENCODING and X509_ASN_ENCODING encoded) and return it via the “pbSignedDataMsg”\nparameter. The CERT_SIGNED_CONTENT_INFO content consists of the signing certificate (including its\nissuing chain), the algorithm used to hash and sign the file, and the signed hash of the file. The calling\ntrust provider then decodes the digital signature, extracts the hash algorithm and signed hash value and\npasses them to CryptSIPVerifyIndirectData. After the Authenticode hash is computed and compared\nagainst the signed hash, if they match, CryptSIPVerifyIndirectData returns TRUE. Otherwise, it returns\nFALSE and WinVerifyTrust will return an error indicating that there was a hash mismatch.\n\nCryptSIPVerifyIndirectData is one of the most important digital signature validation functions as it is\nwhat would indicate an error if an attacker simply applied an existing, legitimate digital signature to\n[their malware - a technique employed in the wild.](https://twitter.com/craiu/status/879690795946827776?lang=en)\n\nHere’s an example of what a hash mismatch would look like on a malware sample with a legitimate\nAuthenticode signature applied to it:\n\n**_Example of a hash mismatch error being displayed on an unsigned file with a Microsoft Authenticode signature applied to it_**\n\n**_(note identical SignerCertificate thumbprint values)_**\n\n\n-----\n\n**_An unsigned file fails to validate when it has an Authenticode signature from a signed file applied to it. This is by design._**\n\n### Trust Provider Architecture\n\nUp to this point, the basic architecture of SIPs has been discussed. As should now be understood, SIPs\nare only responsible for digital signature application, retrieval, and hash calculation/validation. The\npresence of a digital signature applied to a file is meaningless unless certain criteria are actually\nvalidated. This is where trust providers come into play - they validate trust based on a combination of\nparameters specified by the caller to WinVerifyTrust in addition to criteria built into the desired trust\nprovider.\n\nLike SIPs, trust providers are also uniquely identified by GUIDs. As of Windows 10, the following trust\nproviders are present:\n\n\n-----\n\n|A7F4C378-21BE-494e-BA0F-BB12C5D208C5|UNKNOWN .NET VERIFIER|\n|---|---|\n|7801EBD0-CF4B-11D0-851F-0060979387EA|CERT_CERTIFICATE_ACTION_VERIFY|\n|6078065B-8F22-4B13-BD9B-5B762776F386|CONFIG_CI_ACTION_VERIFY|\n|D41E4F1F-A407-11D1-8BC9-00C04FA30A41|COR_POLICY_LOCKDOWN_CHECK|\n|D41E4F1D-A407-11D1-8BC9-00C04FA30A41|COR_POLICY_PROVIDER_DOWNLOAD|\n|31D1ADC1-D329-11D1-8ED8-0080C76516C6|COREE_POLICY_PROVIDER|\n|F750E6C3-38EE-11D1-85E5-00C04FC295EE|DRIVER_ACTION_VERIFY|\n|573E31F8-AABA-11D0-8CCB-00C04FC295EE|HTTPSPROV_ACTION|\n|5555C2CD-17FB-11d1-85C4-00C04FC295EE|OFFICESIGN_ACTION_VERIFY|\n|64B9D180-8DA2-11CF-8736-00AA00A485EB|WIN_SPUB_ACTION_PUBLISHED_SOFTWARE|\n|C6B2E8D0-E005-11CF-A134-00C04FD7BF43|WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOB ADUI|\n|189A3842-3041-11D1-85E1-00C04FC295EE|WINTRUST_ACTION_GENERIC_CERT_VERIFY|\n|FC451C16-AC75-11D1-B4B8-00C04FB66EA0|WINTRUST_ACTION_GENERIC_CHAIN_VERIFY|\n|00AAC56B-CD44-11D0-8CC2-00C04FC295EE|WINTRUST_ACTION_GENERIC_VERIFY_V2|\n|573E31F8-DDBA-11D0-8CCB-00C04FC295EE|WINTRUST_ACTION_TRUSTPROVIDER_TEST|\n\n\nThe purpose of some of these trust providers is documented in MSDN and SoftPub.h in the Windows\nSDK, but their respective implementations are not documented, requiring a leap of faith from\ndevelopers that trust verification of certificates, signatures, chains, revocation, and time-stamping are\nperformed correctly. One of the more common trust providers used by a developer calling\nWinVerifyTrust will be WINTRUST_ACTION_GENERIC_VERIFY_V2 for generic Authenticode signature\ntrust validation. If the trust of a driver needs to be validated in user mode, DRIVER_ACTION_VERIFY should\nbe used.\n\nLike SIPs, trust providers are registered in the registry as well in the following key:\n```\n  ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\Providers\\Trust\n\n```\nWithin the “Trust” key is a list of subkeys corresponding to each step of trust provider validation that\ncan occur: Initialization, Message, Signature, Certificate, CertCheck, FinalPolicy, DiagnosticPolicy, and\nCleanup. Within each of these keys are the trust provider GUIDs that implement each of those steps (not\nall of which are required. e.g. CertCheck, DiagnosticPolicy, and Cleanup). Within each respective GUID\nsubkey are the DLLs and export functions that implement the trust provider steps: `$DLL and`\n```\n$Function.\n\n```\n\n-----\n\n**_Example of a trust provider registration in the registry_**\n\nThe purpose of each trust provider step can be broken down roughly as follows:\n\n**1.** **Initialization:**\n\na. Initializes the [CRYPT_PROVIDER_DATA](https://msdn.microsoft.com/en-us/library/windows/desktop/aa381453(v=vs.85).aspx) structure based on the [WINTRUST_DATA](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388205(v=vs.85).aspx)\n\nstructure passed to WinVerifyTrust. CRYPT_PROVIDER_DATA is a structure that is passed\nbetween all of the trust provider functions and serves to maintain state across all the\ncalls including and error codes that could have occurred each step along the way (see\nTRUSTERROR_STEP values in wintrust.h).\nb. Opens a read file handle to the file to be validated.\n**2.** **Message:**\n\na. Obtains signer information from the subject interface package. This is the only step in\n\nthe verification process that calls into the respective SIP to obtain the correct signature.\nNote that some trust verification utilities will first check the catalog store for a signature\nbefore attempting to obtain a signature from an embedded Authenticode signature.\nb. Both the “initialization” and “message” steps are referred as “object providers.”\n**3.** **Signature:**\n\na. In this step, the digital signature is built out and counter-signers and timestamps are\n\nvalidated.\nb. This step is referred to as a “signature provider.”\n**4.** **Certificate:**\n\na. In this step, the full certificate chain is built out.\nb. This step is referred to as a “certificate provider.”\n**5.** **CertCheck:**\n\na. If this optional step is implemented, this function is called for each index within the\n\ncertificate chain and is used to indicate to the trust provider that the certificate chain\nshould continue to be built out.\n**6.** **FinalPolicy:**\n\na. This is the function where the majority of trust decisions are made. At this point, the\n\nsignature and certificate chain has been decoded, parsed and supplied to this\nimplementing function.\nb. What components of the signature, certificate chain, and certificate store are validated\n\nvary depending upon the trust provider. Here is small list of some of the checks that\n\n\n-----\n\noccur when the WINTRUST_ACTION_GENERIC_VERIFY_V2 trust provider is used\n(implemented as wintrust!SoftPubAuthenticode):\n\ni. Verify that the file was signed with a certificate designated for code signing as\nindicated by an enhanced key usage (EKU) of “1.3.6.1.5.5.7.3.3”\nii. Check if the certificate is expired and hasn’t been timestamped.\niii. Check if the certificate has been revoked.\niv. Validate that the file was not signed using a hash algorithm that has been\ndesignated as “weak.”\nv. If the file was signed with a certificate designated for “Windows System\nComponent Verification” (EKU - 1.3.6.1.4.1.311.10.3.6), validate that the signing\ncertificate chains to a fixed set of trusted Microsoft root certificates.\n**7.** **DiagnosticPolicy:**\n\na. This optional step is designed to aid debugging for trust provider developers. It is\n\nintended to allow for a Microsoft developer to dump out structure contents prior to\nreturning to WinVerifyTrust.\nb. `WINTRUST_ACTION_TRUSTPROVIDER_TEST is the only trust provider that implements`\n\nthis step. `WINTRUST_ACTION_TRUSTPROVIDER_TEST` is identical to\nWINTRUST_ACTION_GENERIC_VERIFY_V2 but it just implements this extra step\nimplemented as wintrust!SoftpubDumpStructure. SoftpubDumpStructure dumps out\nthe populated CRYPT_DATA_PROVIDER structure to `C:\\TRUSTPOL.TXT. This step`\ncan be easily tested with signtool.exe (available in the Windows SDK) from an elevated\nprompt (required to write a file to C:\\) by specifying the\n`WINTRUST_ACTION_TRUSTPROVIDER_TEST` (Authenticode Test) trust provider\nGUID:\n```\n       i. signtool verify /pg {573E31F8-DDBA-11D0-8CCB          00C04FC295EE} filename.exe\n\n```\n**8.** **Cleanup:**\n\na. In this optional step, a trust provider can cleanup any [CRYPT_PROVIDER_PRIVDATA that](https://msdn.microsoft.com/en-us/library/windows/desktop/aa381456(v=vs.85).aspx)\n\nwas populated to pass policy-specific data across trust provider steps.\n\n### Trust Provider and SIP Registration\n\nIt is important to know the legitimate means by which trust providers and SIPs are registered in the\nregistry in order to understand how an attacker might take advantage of the registration process (or\nsubvert it entirely).\n\n#### SIP Registration\n\n[Subject interface packages are formally registered by calling the wintrust!CryptSIPAddProvider function](https://msdn.microsoft.com/en-us/library/windows/desktop/aa380283(v=vs.85).aspx)\nwithin a [DllRegisterServer](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682162(v=vs.85).aspx) export function. This enables the SIP to be formally registered by calling\n“regsvr32.exe SIPfilename.dll”. CryptSIPAddProvider requires a [SIP_ADD_NEWPROVIDER](https://msdn.microsoft.com/en-us/library/windows/desktop/aa387767(v=vs.85).aspx)\n\n\n-----\n\nstructure consisting of the export functions exported in the SIP DLL that implement signing functionality.\nThe following SIP_ADD_NEWPROVIDER fields are required:\n\n**1.** **pwszDLLFileName:**\n\nThe name of the SIP DLL. This can be just the file name but it should be a full path.\n**2.** **pwszGetFuncName:**\n\n[Export function name of implemented CryptSIPGetSignedDataMsg](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542585(v=vs.85).aspx)\n**3.** **pwszPutFuncName:**\n\n[Export function name of implemented CryptSIPPutSignedDataMsg](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542587(v=vs.85).aspx)\n**4.** **pwszCreateFuncName:**\n\n[Export function name of implemented CryptSIPCreateIndirectData](https://msdn.microsoft.com/en-us/library/windows/desktop/bb736358(v=vs.85).aspx)\n**5.** **pwszVerifyFuncName:**\n\n[Export function name of implemented CryptSIPVerifyIndirectData](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542591(v=vs.85).aspx)\n**6.** **pwszRemoveFuncName:**\n\n[Export function name of implemented CryptSIPRemoveSignedDataMsg](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542589(v=vs.85).aspx)\n\nThe following SIP_ADD_NEWPROVIDER fields are optional:\n\n**1.** **pwszIsFunctionNameFmt2:**\n\n[Export function name of implemented pfnIsFileSupportedName](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542640(v=vs.85).aspx)\n**2.** **pwszGetCapFuncName:**\n\n[Export function name of implemented pCryptSIPGetCaps](https://msdn.microsoft.com/en-us/library/windows/desktop/hh968154(v=vs.85).aspx)\n**3.** **pwszIsFunctionName:**\n\n[Export function name of implemented pfnIsFileSupported](https://msdn.microsoft.com/en-us/library/windows/desktop/cc542636(v=vs.85).aspx)\n\nUpon calling CryptSIPAddProvider, wintrust.dll adds the respective export function names and\nimplementing DLL to the\n“HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingType 0”\nsubkeys.\n\nSIP DLLs should also implement a DllUnregisterServer deregistration function that calls\n[CryptSIPRemoveProvider](https://msdn.microsoft.com/en-us/library/windows/desktop/aa380284(v=vs.85).aspx) to remove all relevant SIP registry entries.\n\n#### Trust Provider Registration\n\n[Trust providers are formally registered by calling the wintrust!WintrustAddActionID function within a](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388196(v=vs.85).aspx)\nDllRegisterServer export function. This enables the trust provider to be formally registered by calling\n“regsvr32.exe `TrustProviderfilename.dll”.` WintrustAddActionID requires a\n[CRYPT_REGISTER_ACTIONID structure consisting of the export functions exported in the trust provider](https://msdn.microsoft.com/en-us/library/windows/desktop/aa381463(v=vs.85).aspx)\nDLL that perform all the trust validation steps. Trust provider registration functionality can either be\nshared with that of a SIP registration or it can be separate in its own, dedicated DLL.\n\n\n-----\n\nUpon calling WintrustAddActionID, wintrust.dll adds the respective export function names and\nimplementing DLL to the\n“HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\Providers\\Trust”\nsubkeys.\n\nTrust providers are formally deregistered by calling wintrust!WintrustRemoveActionID within a\nDllUnregisterServer export function .\n\n#### Trust Provider and SIP Registration Example\n\nThe most significant trust provider registration resides in wintrust!DllRegisterServer which performs the\nfollowing registration steps:\n\n1. Calls WintrustDllRegisterServer\n\na. Registers ASN.1 encoding/decoding routines used by [CryptEncodeObject and](https://msdn.microsoft.com/en-us/library/windows/desktop/aa378145(v=vs.85).aspx)\n\n[CryptDecodeObject by calling wintrust!CryptRegisterOIDFunction. Many of these](https://msdn.microsoft.com/en-us/library/windows/desktop/aa378145(v=vs.85).aspx)\nfunctions are called upon creation of a digital signature. Their decoding counterpart\nfunctions will often be called when parsing digital signatures for verification purposes.\nLike with SIP and trust provider registrations, these implementing functions are also\nstored in the registry:\n```\n        ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\n          \\EncodingType\n          1\\[CryptDllDecodeObject|CryptDllEncodeObject]\n\n```\nAll of these encoding functions take on the following function signature:\n```\n        ● BOOL WINAPI EncoderDecoderFunction(DWORD\n          dwCertEncodingType, LPCSTR lpszStructType,\n          PSPC_PE_IMAGE_DATA pInfo, BYTE *pbEncoded, DWORD\n          *pcbEncoded);\n\n```\nWintrustDllRegisterServer registers the following encoding/decoding routines:\n\ni. 1.3.6.1.4.1.311.2.1.15 (SPC_PE_IMAGE_DATA_OBJID)\nFunction: wintrust!WVTAsn1SpcPeImageDataEncode\nii. 1.3.6.1.4.1.311.2.1.25 (SPC_CAB_DATA_OBJID)\nFunction: wintrust!WVTAsn1SpcLinkEncode\niii. 1.3.6.1.4.1.311.2.1.20 (SPC_JAVA_CLASS_DATA_OBJID)\nFunction: wintrust!WVTAsn1SpcLinkEncode\niv. 1.3.6.1.4.1.311.2.1.28 (SPC_LINK_OBJID)\nFunction: wintrust!WVTAsn1SpcLinkEncode\nv. 1.3.6.1.4.1.311.2.1.30 (SPC_SIGINFO_OBJID)\nFunction: wintrust!WVTAsn1SpcSigInfoEncode\nvi. 1.3.6.1.4.1.311.2.1.4 (SPC_INDIRECT_DATA_OBJID)\nFunction: wintrust!WVTAsn1SpcIndirectDataContentEncode\nvii. 1.3.6.1.4.1.311.2.1.10 (SPC_SP_AGENCY_INFO_OBJID)\n\n\n-----\n\nFunction: wintrust!WVTAsn1SpcSpAgencyInfoEncode\nviii. 1.3.6.1.4.1.311.2.1.26 (SPC_MINIMAL_CRITERIA_OBJID)\nFunction: wintrust!WVTAsn1SpcMinimalCriteriaInfoEncode\nix. 1.3.6.1.4.1.311.2.1.27 (SPC_FINANCIAL_CRITERIA_OBJID)\nFunction: wintrust!WVTAsn1SpcFinancialCriteriaInfoEncode\nx. 1.3.6.1.4.1.311.2.1.11 (SPC_STATEMENT_TYPE_OBJID)\nFunction: wintrust!WVTAsn1SpcStatementTypeEncode\nxi. 1.3.6.1.4.1.311.12.2.1 (CAT_NAMEVALUE_OBJID)\nFunction: wintrust!WVTAsn1CatNameValueEncode\nxii. 1.3.6.1.4.1.311.12.2.2 (CAT_MEMBERINFO_OBJID)\nFunction: wintrust!WVTAsn1CatMemberInfoEncode\nxiii. 1.3.6.1.4.1.311.12.2.3 (CAT_MEMBERINFO2_OBJID)\nFunction: wintrust!WVTAsn1CatMemberInfo2Encode\nxiv. 1.3.6.1.4.1.311.2.1.12 (SPC_SP_OPUS_INFO_OBJID)\nFunction: wintrust!WVTAsn1SpcSpOpusInfoEncode\nxv. 1.3.6.1.4.1.311.2.4.2 (szOID_INTENT_TO_SEAL)\nFunction: wintrust!WVTAsn1IntentToSealAttributeEncode\nxvi. 1.3.6.1.4.1.311.2.4.3 (szOID_SEALING_SIGNATURE)\nFunction: wintrust!WVTAsn1SealingSignatureAttributeEncode\nxvii. 1.3.6.1.4.1.311.2.4.4 (szOID_SEALING_TIMESTAMP)\nFunction: wintrust!WVTAsn1SealingTimestampAttributeEncode\n2. Next, SoftpubDllRegisterServer is called where it calls WintrustAddActionID to register the\n\nfollowing trust providers:\n\na. WINTRUST_ACTION_GENERIC_VERIFY_V2\nb. WIN_SPUB_ACTION_PUBLISHED_SOFTWARE\nc. WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI\nd. WINTRUST_ACTION_GENERIC_CERT_VERIFY\ne. WINTRUST_ACTION_TRUSTPROVIDER_TEST\nf. [HTTPSPROV_ACTION. The following related default “usages”](https://msdn.microsoft.com/en-us/library/windows/desktop/hh802766(v=vs.85).aspx) are also registered (all\n\nstored in\n```\n     HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\Provider\n     s\\Trust\\Usages):\n\n```\ni. 1.3.6.1.4.1.311.10.3.3 (szOID_SERVER_GATED_CRYPTO)\nAlloc/dealloc function: wintrust!SoftpubLoadDefUsageCallData\nii. 1.3.6.1.5.5.7.3.1 (szOID_PKIX_KP_SERVER_AUTH)\nAlloc/dealloc function: wintrust!SoftpubLoadDefUsageCallData\niii. 1.3.6.1.5.5.7.3.2 (szOID_PKIX_KP_CLIENT_AUTH)\nAlloc/dealloc function: wintrust!SoftpubLoadDefUsageCallData\niv. 2.16.840.1.113730.4.1 (szOID_SGC_NETSCAPE)\nAlloc/dealloc function: wintrust!SoftpubLoadDefUsageCallData\ng. DRIVER_ACTION_VERIFY\nh. WINTRUST_ACTION_GENERIC_CHAIN_VERIFY\n\n\n-----\n\n3. Finally, mssip32DllRegisterServer is called to register SIPs. Specifically, CryptSIPAddProvider is\n\ncalled to register the following SIPs:\n```\n     a. DE351A42-8E59-11D0-8C47-00C04FC295EE\n       CRYPT_SUBJTYPE_FLAT_IMAGE\n     b. C689AABA-8E78-11d0-8C47-00C04FC295EE\n       CRYPT_SUBJTYPE_CABINET_IMAGE\n     c. C689AAB8-8E78-11D0-8C47-00C04FC295EE\n       CRYPT_SUBJTYPE_PE_IMAGE\n     d. DE351A43-8E59-11D0-8C47-00C04FC295EE\n       CRYPT_SUBJTYPE_CATALOG_IMAGE\n     e. 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE\n       CRYPT_SUBJTYPE_CTL_IMAGE\n\n```\n4. mssip32DllRegisterServer also explicitly deregisters the following SIPs (in reality, the Java SIP\n\nartifacts remain in the registry in a default built of Windows):\n```\n     a. C689AAB9-8E78-11D0-8C47-00C04FC295EE\n       CRYPT_SUBJTYPE_JAVACLASS_IMAGE\n     b. 941C2937-1292-11D1-85BE-00C04FC295EE\n       CRYPT_SUBJTYPE_SS_IMAGE\n\n```\nWhile it is certainly not recommended, all wintrust trust provider and SIP registrations can be formally\nderegistered with the following command (from an elevated prompt):\n```\n  ● regsvr32.exe /u C:\\Windows\\System32\\wintrust.dll\n\n```\nRunning the above command would strip Windows of the ability to perform most digital signature\nretrieval and trust validation in user mode.\n\n### Trust Provider and SIP Interaction\n\nWhile the interaction between a SIP and a trust provider was mentioned in the “Message” trust provider\nstep previously, a diagram illustrating all the steps in order should be helpful.\n\n\n-----\n\n**_Illustration of the interplay between WinVerifyTrust, trust providers, and subject interface packages_**\n\nHopefully by now, there is a basic level of understanding about the role of trust providers and subject\ninterface packages and the extent to which their architecture is designed to be modular through\nregistration in the registry. In the next section, attacks on the modularity of the Windows trust\narchitecture will be discussed.\n\n\n-----\n\n## Windows Trust Architecture Attacks\n\nArmed with a basic understanding of the Windows user mode trust architecture and an elevated\nprivilege level, an attacker has what he/she needs to subvert trust. What might an attacker wish to\nachieve by subverting trust?\n\n1. Have the OS believe that attacker-supplied code was signed with and validated as a “trusted”\n\ncode signing certificate - e.g. one used to sign Microsoft code. The motivation behind such an\nattack would be any of the following:\n\na. To influence a security product to classify attacker supplied code as benign.\nb. To hide from security/diagnostic tools that perform signature validation.\nc. To generally remain under the radar. Incident responders may be more likely to\n\noverlook code that is “signed using a legitimate certificate”.\nd. To load malicious code in the context of any process that performs user mode trust\n\nvalidation.\n2. Subvert application whitelisting publisher rules that enforce policy based on trusted signing\n\nauthorities. Publisher enforcement is one of the most common whitelisting rule scenarios as it\nallows code signed by trusted publishers to execute even across updates versus hash rules that\ndon’t permit software updates and are more difficult to maintain and audit.\n\n### SIP Hijack #1: CryptSIPDllGetSignedDataMsg\n\nAs was explained earlier, the CryptSIPDllGetSignedDataMsg component of a SIP is what enables the\nretrieval of an encoded digital certificate from a signed file. As a reminder, the implemented export\nfunction for a SIP’s CryptSIPDllGetSignedDataMsg component is present in the following registry key:\n```\n  ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingTy\n   pe 0\\CryptSIPDllGetSignedDataMsg\\{SIP Guid}\n     ○ Dll - Path to the DLL that implements the digital signature\n       retrieval function\n     ○ FuncName - The name of the exported function that\n       implements the digital signature retrieval function\n\n```\nAdditionally, as was discussed previously, CryptSIPDllGetSignedDataMsg functions have the following\ndocumented function prototype:\n```\nBOOL WINAPI CryptSIPGetSignedDataMsg(\n   IN   SIP_SUBJECTINFO *pSubjectInfo,\n   OUT   DWORD      *pdwEncodingType,\n   IN   DWORD      dwIndex,\n   IN OUT DWORD      *pcbSignedDataMsg,\n   OUT   BYTE      *pbSignedDataMsg);\n\n```\n\n-----\n\nAny attacker familiar with C/C++ will be able to easily implement such a function and replace the\nexisting SIP entry with that of their malicious function. First, it is important to understand the meaning\nof each parameter:\n\n1. pSubjectInfo: A structure passed in from the calling trust provider that contains all the relevant\n\ninformation about the file from which a signature should be extracted. Here is an example dump\nof the structure passed to pwrshsip!PsGetSignature (the CryptSIPDllGetSignedDataMsg\ncomponent for the PowerShell SIP):\n```\n0:017> dt -r urlmon!SIP_SUBJECTINFO @rcx\n  +0x000 cbSize      : 0x80\n  +0x008 pgSubjectType  : 0x0000021a`95cfce10 _GUID {603bcc1f-4b594e08-b724-d2c6297ef351}\n   +0x000 Data1      : 0x603bcc1f\n   +0x004 Data2      : 0x4b59\n   +0x006 Data3      : 0x4e08\n   +0x008 Data4      : [8] \"???\"\n  +0x010 hFile      : 0x00000000`00000a0c Void\n  +0x018 pwsFileName   : 0x0000021a`9ad8c0d4 \"C:\\Program\nFiles\\WindowsPowerShell\\Modules\\Pester\\4.0.3\\Pester.psd1\"\n  +0x020 pwsDisplayName  : 0x0000021a`9ad8c0d4 \"C:\\Program\nFiles\\WindowsPowerShell\\Modules\\Pester\\4.0.3\\Pester.psd1\"\n  +0x028 dwReserved1   : 0\n  +0x02c dwIntVersion   : 0\n  +0x030 hProv      : 0x0000021a`ae7089e0\n  +0x038 DigestAlgorithm : _CRYPT_ALGORITHM_IDENTIFIER\n   +0x000 pszObjId     : (null) \n   +0x008 Parameters    : _CRYPTOAPI_BLOB\n     +0x000 cbData      : 0\n     +0x008 pbData      : (null) \n  +0x050 dwFlags     : 0\n  +0x054 dwEncodingType  : 0\n  +0x058 dwReserved2   : 0\n  +0x05c fdwCAPISettings : 0x23c00\n  +0x060 fdwSecuritySettings : 1\n  +0x064 dwIndex     : 0\n  +0x068 dwUnionChoice  : 0\n  +0x070 psFlat      : (null) \n  +0x070 psCatMember   : (null) \n  +0x070 psBlob      : (null) \n  +0x078 pClientData   : (null) \n\n```\n\n-----\n\n2. `pdwEncodingType: Upon retrieving the digital signature from the file specified in`\n\npSubjectInfo, this argument instructs the calling function (the trust provider “Message”\ncomponent) how to properly decode the return digital signature. This will most often be\nPKCS_7_ASN_ENCODING and X509_ASN_ENCODING binary OR’ed together.\n3. `dwIndex: This parameter should be zero but in theory, your SIP can have the ability to contain`\n\nmultiple embedded signatures and dwIndex would indicate which digital signature to extract\nfrom the specified file.\n4. `pcbSignedDataMsg: The length of the digital signature (in bytes) returned via`\n\npbSignedDataMsg.\n5. `pbSignedDataMsg: The encoded digital signature that’s returned to the calling trust`\n\nprovider.\n\nSo if an attacker were to implement this function and use it, as an example, to overwrite the\nCryptSIPDllGetSignedDataMsg component of the portable executable SIP (C689AAB8-8E78-11D0-8C4700C04FC295EE), any digital signature of the attackers choosing could be returned for any PE file.\n\nImagine the following fictional attack scenario:\n\n1. An attacker implements the CryptSIPDllGetSignedDataMsg component of the portable\n\nexecutable SIP and hijacks it in the registry.\n2. The implementation simply consists of returning the same Microsoft certificate for any\n\nexecutable file whether it has an embedded Authenticode signature or not.\n3. In order to ensure that a digital signature of the appropriate format is returned, it is best to set a\n\nbreakpoint on the legitimate CryptSIPDllGetSignedDataMsg in a debugger prior to hijacking it.\nDoing so confirms that Authenticode PKCS #7 signed data is always returned.\n\na. In a PowerShell script, this involves base64 decoding the “SIG # Begin signature block”.\nb. In a PE file with an embedded Authenticode signature, Authenticode PKCS #7 signed\n\n[data is present in the bCertificate field of the embedded WIN_CERTIFICATE structure as](https://msdn.microsoft.com/en-us/library/windows/desktop/dn582059(v=vs.85).aspx)\ndocumented in the [PE Authenticode specification.](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx)\nc. A catalog file itself is Authenticode PKCS #7 signed data (which can actually be used in\n\nan embedded PE Authenticode signature).\n4. Now, the attacker implementation simply needs to return the correct encoding, signature data\n\nlength, and signature data.\n\nIn this attack scenario, the hijacked CryptSIPDllGetSignedDataMsg will return the bytes of a catalog file\nused to sign many system components like notepad.exe. To easily determine the catalog file associated\nwith a signed file, sigcheck.exe can be used:\n```\n  ● sigcheck -i C:\\Windows\\System32\\notepad.exe\n\n```\nIn this instance, it returns the following catalog file path:\n```\n  ● C:\\WINDOWS\\system32\\CatRoot\\{F750E6C3-38EE-11D1-85E5   00C04FC295EE}\\Microsoft-Windows-Client-Features-Package   AutoMerged-shell~31bf3856ad364e35~amd64~~10.0.15063.0.cat\n\n```\n\n-----\n\nNow, the attacker implementation need only to return the bytes from that catalog file to have any PE\nfile appear to be signed using the same certificate as notepad.exe. A modular design approach might be\nto embed the desired signature content in an embedded resource in the attacker-supplied SIP DLL.\n\nWhat follows is an illustration showing how the PowerShell SIP CryptSIPDllGetSignedDataMsg\ncomponent is hijacked using a custom, malicious SIP that will always return the same, legitimate\nMicrosoft certificate for PowerShell files:\n\n**_Demonstration of a PowerShell CryptSIPDllGetSignedDataMsg Hijack_**\n\nIt can be seen that prior to the hijack, as expected, test.ps1 shows up as not signed. After the hijack\noccurs, however, test.ps1 appears to be signed with a Microsoft certificate:\n\n**_An unsigned PowerShell script that appears to all of a sudden be signed by Microsoft_**\n\n\n-----\n\n**_While the unsigned PowerShell script appears to be signed by Microsoft, it's hash will fail to validate accordingly._**\n\nSo the hijack was successful but with one caveat - the signature fails to validate because the computed\nhash doesn’t match with that of the signed hash in the digital signature. An additional side effect of this\nhijack is that any PowerShell code will have the same digital signature applied which would lead to hash\nmismatches in most cases.\n\nIn order to prevent trust validation from failing due to hash mismatches, the\nCryptSIPDllVerifyIndirectData also requires hijacking.\n\n### SIP Hijack #2: CryptSIPDllVerifyIndirectData\n\nAs was explained in the previous hijack scenario, hijacking the CryptSIPDllGetSignedDataMsg component\nof a registered SIP enables otherwise unsigned code to give the appearance of being signed. Considering\nthe hash will not match, however, the digital signature will fail to validate on attacker-supplied code.\nHijacking CryptSIPDllVerifyIndirectData will get the job done, however.\n\nAs a reminder, CryptSIPDllVerifyIndirectData implementations are stored in the following registry\nvalues:\n\n\n-----\n\n```\n  ● HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingTy\n   pe 0\\CryptSIPDllVerifyIndirectData\\{SIP Guid}\n     ○ Dll\n     ○ FuncName\n\n```\nThis is its function prototype:\n```\nBOOL WINAPI CryptSIPVerifyIndirectData(\n   IN   SIP_SUBJECTINFO   *pSubjectInfo,\n   IN   SIP_INDIRECT_DATA  *pIndirectData);\n\n```\nDebugging legitimate implementations of CryptSIPVerifyIndirectData confirmed that when the\ncalculated Authenticode hash matches that of the signed hash value, CryptSIPVerifyIndirectData returns\nTRUE. Therefore, all a malicious SIP needs to do is return TRUE resulting in the appearance of hash\nvalidation producing a match for the respective SIP[s] that were hijacked. Continuing with the\nPowerShell hijack example, a malicious SIP that simply returns true for the hash validation routine will\nalleviate the issue of attacker-supplied code not validating properly.\n\nThe implementation of this function could not be more straightforward:\n```\nBOOL WINAPI AutoApproveHash(\n SIP_SUBJECTINFO *pSubjectInfo,\n SIP_INDIRECT_DATA *pIndirectData) {\n   UNREFERENCED_PARAMETER(pSubjectInfo);\n   UNREFERENCED_PARAMETER(pIndirectData);\n   return TRUE;\n}\n\n```\nNext, hijacking the hash verification handler (along with the previously hijack signature retrieval\nfunction) will give pass all the checks of having unsigned PowerShell code pose as signed, Microsoft\ncode:\n\n**_Hijacking the CryptSIPVerifyIndirectData component of the PowerShell SIP_**\n\n\n-----\n\n**_Now, an unsigned PowerShell file appears signed and properly validated._**\n\n**_The \"Digital Signatures\" UI tab shows an unsigned PowerShell file that appears signed and properly validated._**\n\n\n-----\n\n**_Sysinternals sigcheck shows an unsigned PowerShell file that appears signed and properly validated._**\n\nA more ideal hijack scenario is to not even bother hijacking CryptSIPDllGetSignedDataMsg for the\ntargeted SIP. Rather, simply apply a legitimate Authenticode signature (e.g. from\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Modules\\ISE\\ise.psm1) to attacker-supplied code,\nand to only hijack CryptSIPVerifyIndirectData. Doing so affords an attacker the following benefits:\n\n1) There is less to hijack and clean up from.\n2) Benign, legitimately signed code will have its respective signature applied properly.\n3) Attacker-supplied code with a “legitimate” embedded Authenticode certificate is likely to\n\nreceive less scrutiny from a defender or security product.\n\n**_test.ps1 has the same embedded Authenticode signature applied as ise.psm1. The matching SignerCertificate thumbprint_**\n\n**_value confirms the match._**\n\n\n-----\n\nNote that while the examples up to this point have focused on the PowerShell SIP, these hijack\nprinciples apply to all SIPs. Here is an example of a hijacked portable executable SIP (C689AAB8-8E7811D0-8C47-00C04FC295EE) that has a legitimate Microsoft digital signature applied to an attackersupplied binary:\n\n**_notepad_backdoored.exe has the digital signature of notepad.exe (catalog-signed) applied to it._**\n\n**_The \"Digital Signatures\" UI tab also confirms that the attacker-suppled notepad_backdoored.exe validates as a signed_**\n\n**_Microsoft file._**\n\n\n-----\n\nThis hijack will convince any program that performs user-mode trust/signature validation including\nSysinternals Process Explorer:\n\n**_notepad_backdoored.exe appears as a \"verified signer\" in Sysinternals Process Explorer._**\n\n### Bypassing Device Guard UMCI Enforcement\n\nIn an application whitelisting scenario, hijacking the mechanism by which trust is validated using an\nunsigned/unapproved binary poses a bit of a “chicken and the egg” problem whereby the trust of the\nmalicious SIP DLL needs to be validated per the deployed whitelisting policy. It turns out, with Device\nGuard at least, that the system will fail to load the malicious SIP DLL which will subsequently cause trust\nvalidation to fail in many cases. This understandably has the potential to cause system stability issues.\nIdeally (for attackers) there would be a signed DLL that could serve the CryptSIPVerifyIndirectData role.\nFortunately, there is. Recall that CryptSIPVerifyIndirectData functions take on the following function\nsignature:\n```\nBOOL WINAPI CryptSIPVerifyIndirectData(\n   IN   SIP_SUBJECTINFO   *pSubjectInfo,\n   IN   SIP_INDIRECT_DATA  *pIndirectData);\n\n```\nAlso, in order to pass the validation check, the function must return TRUE. So, one is faced with the\nfollowing requirements to produce a signed CryptSIPVerifyIndirectData function:\n\n1) The DLL must be signed.\n2) The function must accept two parameters.\n3) The function must use the WINAPI/stdcall calling convention.\n4) The function must return TRUE (which is most often interpreted as a non-zero and/or odd\n\nnumber).\n5) The function must not alter the arguments passed in as this would likely lead to memory\n\ncorruption.\n\n\n-----\n\n6) The function must ideally have no other unanticipated side effects other than returning “TRUE.”\n7) The function must be exported.\n\nWhile undoubtedly, such a process of finding candidate functions could be automated by translating\nfunctions into an intermediate language for analysis, it didn’t take long to find a candidate export\nfunction - ntdll!DbgUiContinue:\n\n**_Annotated Disassembly of ntdll!DbgUiContinue_**\n\nSimply setting the CryptSIPVerifyIndirectData registry key for the target SIP to\n“C:\\Windows\\System32\\ntdll.dll” and “DbgUiContinue” was sufficient to pass the hash validation check\nfor any code that has a legitimate embedded Authenticode signature applied to it. In practice, when\ntested against the portable executable SIP on a Device Guard enforced system, attacker-supplied code\nwas blocked from executing. Hijacking the PowerShell SIP, however, enabled a constrained language\nmode bypass, enabling arbitrary, unsigned code execution. At this point, it is unclear as to what\nadditional (likely kernel-backed) trust assertions are made with portable executables versus PowerShell\ncode. There are also likely to be better hijack functions than DbgUiContinue but it was sufficient to\ndemonstrate a hijack without required an unsigned, attacker-supplied SIP DLL.\n\nThe following examples demonstrate Device Guard-enabled constrained language mode in PowerShell\npreventing the execution of Add-Type prior to the hijack followed by the subsequent bypass after the\nCryptSIPVerifyIndirectData hijack occurs:\n\n\n-----\n\n**_Prior to the hijack, the code in test.psm1 will be prevented from executing due to constrained language mode enforcement._**\n\n\n-----\n\n**_After the \"signed code reuse\" attack occurs, constrained language mode is circumvented._**\n\nDespite this form of hijack not representing a complete takeover of Device Guard user mode integrity\nenforcement (UMCI), it does however pose a good hijacking method from a stealth perspective because\nit doesn’t require an attacker to drop any malicious code to disk - i.e. the attacker supplied SIP.\n\n### Trust Provider “FinalPolicy” Hijack\n\nAs was described in the trust provider architecture section, the final trust decision is made by the\nFinalPolicy component of the trust provider. This is the function signature for FinalPolicy:\n```\nHRESULT WINAPI FinalPolicyFunction(_Inout_ struct _CRYPT_PROVIDER_DATA\n*pProvData);\n\n```\nThe FinalPolicy implementing function for the respective trust provider is located here:\n\n\n-----\n\n```\nHKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\Providers\\Trust\\Fin\nalPolicy\\{trust provider GUID}\n\n```\nWhile an attacker could choose to implement their own trust provider DLL to subvert FinalPolicy, this\nwould require dropping attacker-supplied, malicious code to disk. Additionally, the implementation of a\ntrust provider is sufficiently complex to fully implement compared to that of a SIP. As was described\npreviously however, signed code can be used to hijack FinalPolicy as a means of getting it to simulate\npassing all of its checks. A candidate signed hijack function would need to meet the following\nrequirements:\n\n1. The DLL must be signed.\n2. The function must accept one parameter.\n3. The function must use the WINAPI/stdcall calling convention.\n4. The function must return 0 (S_OK) which indicates success as an HRESULT.\n5. The function must not alter the arguments passed in as this would likely lead to memory\n\ncorruption.\n6. The function must ideally have no other unanticipated side effects other than returning 0.\n7. The function must be exported.\n\nThe unimplemented export function wintrust!SoftpubCleanup meets all the requirements to perform a\nhijack.\n\n**_Annotated SoftpubCleanup Disassembly_**\n\nWritten in C, this function is equivalent to the following:\n```\nHRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *data)\n{\n  return S_OK;\n}\n\n```\n\n-----\n\nAs an example, setting the FinalPolicy component of WINTRUST_ACTION_GENERIC_VERIFY_V2\n(00AAC56B-CD44-11D0-8CC2-00C04FC295EE) will cause many signature validation tools to consider\nunsigned code, or code with a legitimate signature applied, as trusted (e.g. Get-AuthenticodeSignature,\nsigcheck, signtool, etc.). In practice, performing this hijack with SoftpubCleanup causes Process Explorer\n(procexp) to reliably crash.\n\n### Hiding from Autoruns\n\nA side effect of applying a legitimate Microsoft Authenticode digital signature to attacker-supplied code\nhijacking the CryptSIPVerifyIndirectData component of a targeted SIP is that it will hide from Autoruns\nby default which does not display “Microsoft” or “Windows” entries by default.\n\nWith the portable executable SIP hijack in place, a persistent, attacker-supplied EXE does not show up by\ndefault:\n\n**_notepad_backdoored.exe is hidden from the default view in Autoruns._**\n\nWhen “Hide Microsoft Entries” and “Hide Windows Entries” are both deselected however, the malicious\nentry in the Run key becomes visible:\n\n**_Confirmation that notepad_backdoored.exe only appears upon deselecting \"Hide Windows Entries\"_**\n\n\n-----\n\n### Persistence and Code Execution\n\nWith knowledge of how to hijack SIPs and trust providers, it should be clear that beyond subverting\ntrust, these hijack attacks also permit persistent code execution in the context of any application that\nperforms code signing or signature validation. By implementing a SIP or trust provider, code execution is\npossible in the following non-exhaustive list of programs:\n\n1) DllHost.exe - When the “Digital Signatures” tab is displayed in file properties\n2) [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer)   - When the “Verified Signer” tab is displayed\n3) [Autoruns](https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns)\n4) [Sigcheck](https://docs.microsoft.com/en-us/sysinternals/downloads/sigcheck)\n5) consent.exe - Any time a UAC prompt is displayed\n6) signtool.exe\n7) smartscreen.exe\n8) [Get-AuthenticodeSignature](https://msdn.microsoft.com/en-us/powershell/reference/5.0/microsoft.powershell.security/get-authenticodesignature)\n9) [Set-AuthenticodeSignature](https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.security/set-authenticodesignature)\n10) Security vendor software that performs certificate validation based on calls to WinVerifyTrust.\n\nAdditional persistence and code execution opportunities exist and can be discovered by filtering off the\nfollowing registry key paths in Process Monitor:\n```\n  1) HKLM\\SOFTWARE\\Microsoft\\Cryptography\\Providers\n  2) HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\Providers\n  3) HKLM\\SOFTWARE\\Microsoft\\Cryptography\\OID\n  4) HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\OID\n\n```\nWhen hijacking a trust provider using attacker-supplied code, one possible stability consideration would\nbe to implement malicious logic as part of the “DiagnosticPolicy” component so as to not interfere with\nlegitimate trust functionality.\n\nWhen attempting to gain code execution in the context of a SIP, one possible code execution\nconsideration might be to implement malicious logic in a “CryptSIPDllIsMyFileType” component and to\nreturn “FALSE” indicating that other “CryptSIPDllIsMyFileType” and “CryptSIPDllIsMyFileType2”\ncomponents should be called to determined which SIP represents the file in question. Do be mindful\nhowever that any weaponization scenario comes with it its own unique set of indicators or compromise\nthat can be signatured.\n\nOne final consideration is that SIP and trust provider DLLs need not have their full path specified in the\n[registry. If just the SIP or trust provider filename is specified, it is loaded via the standard DLL load order.](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx)\nThis gives an attacker the ability to hijack existing SIP/trust provider DLLs without needing to modify the\nregistry. For example in Windows 10, the Microsoft Office SIP VBA macro SIP (9FA65764-C36F-43199737-658A34585BB7) is registered (WoW64 only) using only its file name: mso.dll. Additionally, with\n\n\n-----\n\nonly the filename of “mso.dll” specified, there is a potential for a generic DLL load order hijacking\nvulnerability to present itself in any code that performs user-mode trust validation.\n\n### Subverting CryptoAPI v2 (CAPI) Event Logging\n\nWhile not enabled by default, enabling the Microsoft-Windows-CAPI2/Operational event log can be a\nvaluable source of contextual information related to failed trust validation. Any time WinVerifyTrust is\ncalled, EID 81 is generated and events will be populated as error if signature or trust validation fails as a\nresult of the call. For example, here are the event details associated with a failed trust validation of\n“notepad_backdoored.exe” which has a legitimate Microsoft Authenticode digital signature applied to it\n(most relevant portions bolded):\n```\n- WinVerifyTrust \n ActionID {00AAC56B-CD44-11D0-8CC2-00C04FC295EE} \n - UIChoice WTD_UI_NONE \n  [value] 2 \n - RevocationCheck \n  [value] 0 \n - StateAction WTD_STATEACTION_VERIFY \n  [value] 1 \n - Flags \n  [value] 80000000 \n  [CPD_USE_NT5_CHAIN_FLAG] true \n - FileInfo \n  [filePath] C:\\Test\\notepad_backdoored.exe\n  [hasFileHandle] true \n - DigestInfo \n  [digestAlgorithm] SHA256 \n  [digest] \n4B2392D71DC2C44236EFD9861CACCE54CB53FB68AE0BB29FF467E98DB27FEE80 \n - RegPolicySetting \n  [value] 23C00 \n  [WTPF_OFFLINEOK_IND] true \n  [WTPF_OFFLINEOK_COM] true \n  [WTPF_OFFLINEOKNBU_IND] true \n  [WTPF_OFFLINEOKNBU_COM] true \n  [WTPF_IGNOREREVOCATIONONTS] true \n - SignatureSettingsFlags \n  [value] 20000000 \n  [WSS_OUT_FILE_SUPPORTS_SEAL] true \n - SignerInfo \n  - DigestAlgorithm \n   [oid] 2.16.840.1.101.3.4.2.1 \n   [hashName] SHA256 \n\n```\n\n-----\n\n```\n - CertificateChain \n  [chainRef] {8C6B5132-F22D-49F4-B8C7-75B096E56AE5} \n - TimestampInfo \n  [format] RFC 3161 \n  - DigestAlgorithm \n   [oid] 2.16.840.1.101.3.4.2.1 \n   [hashName] SHA256 \n  SignTime 2017-03-18T20:02:03.777Z \n - TimestampChain \n  [chainRef] {4BB8BB1B-8C68-4A12-87F1-1781D796CE20} \n - StepError \n  [stepID] 32 \n  [stepName] TRUSTERROR_STEP_FINAL_OBJPROV \n - Result The digital signature of the object did not verify.\n  [value] 80096010 \n - EventAuxInfo \n  [ProcessName] powershell.exe \n - CorrelationAuxInfo \n  [TaskId] {114F8A0E-3E22-4395-872A-4CD5A857B34C} \n  [SeqNumber] 9 \n - Result The digital signature of the object did not verify.\n  [value] 80096010\n\n```\nThe above event is an “Error” event. In this example, if the CryptSIPVerifyIndirectData component of the\nportable executable SIP were hijacked, the WinVerifyTrust event would still be logged but as an\n“Information” event indicating that trust validation was successful:\n```\n- WinVerifyTrust \n ActionID {00AAC56B-CD44-11D0-8CC2-00C04FC295EE} \n - UIChoice WTD_UI_NONE \n  [value] 2 \n - RevocationCheck \n  [value] 0\n - StateAction WTD_STATEACTION_VERIFY \n  [value] 1 \n - Flags \n  [value] 80001080 \n  [WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT] true \n  [WTD_CACHE_ONLY_URL_RETRIEVAL] true \n  [CPD_USE_NT5_CHAIN_FLAG] true \n - FileInfo \n  [filePath] C:\\Test\\notepad_backdoored.exe\n  [hasFileHandle] true \n - DigestInfo \n\n```\n\n-----\n\n```\n  [digestAlgorithm] SHA256 \n  [digest] \n4B2392D71DC2C44236EFD9861CACCE54CB53FB68AE0BB29FF467E98DB27FEE80 \n - RegPolicySetting \n  [value] 23C00 \n  [WTPF_OFFLINEOK_IND] true \n  [WTPF_OFFLINEOK_COM] true \n  [WTPF_OFFLINEOKNBU_IND] true \n  [WTPF_OFFLINEOKNBU_COM] true \n  [WTPF_IGNOREREVOCATIONONTS] true \n - SignatureSettingsFlags \n  [value] 20000000 \n  [WSS_OUT_FILE_SUPPORTS_SEAL] true \n - SignerInfo \n  - DigestAlgorithm \n   [oid] 2.16.840.1.101.3.4.2.1 \n   [hashName] SHA256 \n - CertificateChain \n  [chainRef] {BFF90ED0-0277-48F4-9217-DD3A39F331E2} \n - TimestampInfo \n  [format] RFC 3161 \n - DigestAlgorithm \n  [oid] 2.16.840.1.101.3.4.2.1 \n  [hashName] SHA256 \n  SignTime 2017-03-18T20:02:03.777Z \n - TimestampChain \n  [chainRef] {9A4340F3-6A10-47E7-ACB6-BC3F9F565249} \n - EventAuxInfo \n  [ProcessName] powershell.exe \n - CorrelationAuxInfo \n  [TaskId] {2B21CD36-7A9C-4636-91CE-33FBA0B81D08} \n  [SeqNumber] 11 \n - Result \n  [value] 0\n\n```\nSo while the Microsoft-Windows-CAPI2/Operational event can provide valuable attack context\n(primarily file path and the name of the verifying process), its expected behavior is subverted by\nemploying a trust validation attack.\n\n### Offensive Operational Considerations\n\nThe following suggestions are intended to help reduce/mitigate detection when implementing a\nmalicious SIP:\n\n\n-----\n\n- If the SIP is being used to hijack existing SIP functionality, implement the same function names\n\nas that of the functions you’re hijacking. This will prevent the need to change “FuncName”\nregistry values.\n\n- While it is not advised to replace legitimate SIP binaries on disk with those of your own (e.g.\n\nwintrust.dll), it is ideal to have your SIP DLL have the same name as the DLL you’re hijacking.\nWith the exception of SIP registrations with relative paths (e.g. WoW64 mso.dll), you will need\nto change “Dll” registry values. The least suspicious method of changing “Dll” values is to change\nstrip the file path from “Dll” and plant your SIP DLL in the current directory of the target\napplication if such a scenario is feasible. For example, change\n“C:\\Windows\\System32\\WINTRUST.dll” to just “WINTRUST.dll.” Note that wintrust.dll is not\npresent in [KnownDlls.](https://blogs.msdn.microsoft.com/larryosterman/2004/07/19/what-are-known-dlls-anyway/)\n\n- If implementing a full SIP (e.g. with proper registration/deregistration functionality), be mindful\n\nthat functions related to SIP operations are relatively easy to build Yara signatures for. Consider\nperforming SIP registration/hijacks directly through the registry. For example, the following\nimports would make for a good Yara rule:\n\n   - CryptSIPAddProvider\n\n   - CryptSIPRemoveProvider\n\n   - CryptSIPLoad\n\n   - CryptSetOIDFunctionValue\n\n   - CryptRegisterOIDFunction\n\n- If your SIP DLL is operating on “Microsoft\\Cryptography\\OID” key directly in the registry,\n\nobfuscate the subkey paths.\n\n- For the legitimate DLL that you plan to hijack with your SIP DLL, apply its Authenticode signature\n\nto your binary. While a hash mismatch will be present, ideally, you’re hijacking the\nCryptSIPVerifyIndirectData SIP component anyway to alleviate this issue. Note that many system\nbinaries are catalog signed. You can apply a catalog signature as an embedded Authenticode\nsignature, however. Applying the same certificate will produce an identical thumbprint\ncalculation and bypass some simple checks that security products might perform.\n\n- If you are registering a new SIP GUID, use a historically defined one that isn’t currently\n\nregistered and apply the same filename and export function names as the SIP GUID used. For\nexample, Silverlight has a SIP with the following GUID: BA08A66F-113B-4D58-9329A1B37AF30F0E\n\n   - Filename: xapauthenticodesip.dll\n\n   - Exports:\nXAP_CryptSIPCreateIndirectData,XAP_CryptSIPGetSignedDataMsg,XAP_CryptSIPPutSign\nedDataMsg,XAP_CryptSIPRemoveSignedDataMsg,XAP_CryptSIPVerifyIndirectData,XAP_I\nsFileSupportedName\n\n\n-----\n\n## Windows Trust Architecture Defenses\n\nWhat follows is practical mitigation and detection guidance for enterprise defenders, threat hunters,\nand security product developers.\n\n### Enterprise Defender Guidance\n\n#### Baseline, Trim, and Normalize SIPs and Trust Providers\n\n1. Baseline: It is recommended to sweep your environment for registered SIPs and trust providers\n\nand determine what is normal. Note that in the course of this research, there does not appear\nto exist any non-Microsoft SIP or trust provider. A list of known good SIPs and trust providers are\nlisted in the appendix.\n2. Trim: Remove unnecessary SIPs. For example, consider removing the registered Microsoft Office\n\nVBA WOW64 SIP – mso.dll (GUID: 9FA65764-C36F-4319-9737-658A34585BB7). On Windows 10,\nthis is a stale artifact and is also subject to DLL load order hijacking due to its lack of a full file\npath in the registry. Only consider SIP removal when you are confident that you do not need\nsigning support for a particular SIP. Removing the registration artifacts from the registry will\nsuffice without needing to call CryptSIPRemoveProvider.\n3. Normalize: Identify all SIPs and trust providers that utilize relative paths and supply them with\n\nfull file paths to eliminate any possibility of a load order hijack attack. An example of a SIP that\ndoesn’t register with a full file path is the following:\n```\n     ● 9FA65764-C36F-4319-9737-658A34585BB7 (WoW64) - mso.dll\n\n```\nThe following trust providers do not specify full file paths:\n```\n     ● A7F4C378-21BE-494e-BA0F-BB12C5D208C5\n     ● 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958\n     ● 31D1ADC1-D329-11D1-8ED8-0080C76516C6\n\n#### Registry Value SACL Auditing\n\n```\nConsidering the majority of the trust subversion attacks accounted for in this whitepaper involve\nmodifying registry values, SACL registry object auditing should be enabled for the following registry keys\nand all subkeys for “Set Value” access and success and failures:\n\n  - HKLM\\SOFTWARE\\Microsoft\\Cryptography\\OID\n\n  - HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\OID\n\n  - HKLM\\SOFTWARE\\Microsoft\\Cryptography\\Providers\\Trust\n\n  - HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\Providers\\Trust\n\nRegistry values for subkeys of the keys listed above will rarely change, if ever, meaning that triggered\nevents will be high value and easily deconflicted from a rare, benign modification. With SACL auditing\n\n\n-----\n\nenabled, a registry value change will generate a 4657 (“A registry value was modified”) event. Here is an\nexample entry:\n```\nA registry value was modified.\nSubject:\n Security ID:    DESKTOP-TEST\\TestUser\n Account Name:   TestUser\n Account Domain:  DESKTOP-TEST\n Logon ID:     0x70920\nObject:\n Object Name:   \n\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\OID\\EncodingType\n0\\CryptSIPDllVerifyIndirectData\\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}\n Object Value Name: FuncName\n Handle ID:     0x468\n Operation Type:  Existing registry value modified\nProcess Information:\n Process ID:    0x2de8\n Process Name:   C:\\Windows\\regedit.exe\nChange Information:\n Old Value Type:  REG_SZ\n Old Value:     CryptSIPVerifyIndirectData\n New Value Type:  REG_SZ\n New Value:     DbgUiContinue\n\n```\nInformation on Registry key auditing can be found here and here.\n\n#### Sysmon\n\nAs an alternative to registry SACL auditing, those using sysmon should include rules to detect changes to\nthe key listed above as well as any subkeys. This [sysmon ruleset](https://github.com/SwiftOnSecurity/sysmon-config) should serve as a great resource for\nbuilding sysmon registry rules.\n\n#### Code Integrity Event Log Events\n\nThe Microsoft-Windows-CodeIntegrity/Operational event log can be an extremely valuable indicator for\ndetecting malicious SIP or trust provider loads. Considering it does not appear as though the attacks\ndescribed in this whitepaper can be used to bypass protected processes, any protected process that\nperforms user mode trust validation may inadvertently attempt to load your malicious SIP or trust\n\n\n-----\n\nprovider DLL. As a result, the image load will fail and an EID 3033 event will be generated. Here is an\nexample:\n```\nCode Integrity determined that a process\n(\\Device\\HarddiskVolume2\\Windows\\System32\\SecurityHealthService.exe)\nattempted to load\n\\Device\\HarddiskVolume2\\Users\\TestUser\\Desktop\\Trust\\SIP\\MySIP.dll\nthat did not meet the Windows signing level requirements.\nEventData \n FileNameLength 66 \n FileNameBuffer\n\\Device\\HarddiskVolume2\\Users\\TestUser\\Desktop\\Trust\\SIP\\MySIP.dll \n ProcessNameLength 66 \n ProcessNameBuffer\n\\Device\\HarddiskVolume2\\Windows\\System32\\SecurityHealthService.exe \n RequestedPolicy 12 \n ValidatedPolicy 1 \n Status 3221226536\n\n```\nThe “RequestPolicy” and “ValidatedPolicy” fields refer to the signing level of the host process and DLL,\nrespectively.\n\nNote that this event will only generated if an attacker-supplied SIP or trust provider DLL is used. These\nvents will not be generated using the signed code reuse attack. Those attacks are detected via registry\nmonitoring, however.\n\nThe Microsoft-Windows-CodeIntegrity/Operational is also an extremely valuable source of event data\nwhen running Device Guard in audit mode or enforcement mode or by enabling [hypervisor code](https://docs.microsoft.com/en-us/windows/device-security/device-guard/deploy-device-guard-enable-virtualization-based-security)\n[integrity](https://docs.microsoft.com/en-us/windows/device-security/device-guard/deploy-device-guard-enable-virtualization-based-security) (HVCI).\n\n### Threat Hunting/Intel and Incident Response Guidance\n\n#### Threat Intel Research\n\nThose interested in hunting for potentially malicious and/or benign instances of SIP and trust provider\nDLLs using VirusTotal Retrohunt might want to use these basic Yara rules written by [Joe Desimone](https://twitter.com/dez_) at\n[Endgame.](https://www.endgame.com/our-experts/joe-desimone)\n```\nrule sip_key\n{\n  strings:\n  $str1 = \"CryptSIPDllGetSignedDataMsg\" nocase\n\n```\n\n-----\n\n```\n  $str2 = \"CryptSIPDllVerifyIndirectData\" nocase\n  condition:\n  any of them\n}\nrule final_policy_key\n{\n  strings:\n  $str1 = \"Providers\" nocase\n  $str2 = \"Trust\" nocase\n  $str3 = \"FinalPolicy\" nocase\n  condition:\n  all of them\n}\nrule sip_api\n{\n  strings:\n  $str1 = \"CryptSIPAddProvider\"\n  $str2 = \"WintrustAddActionID\"\n  $str3 = \"CryptRegisterDefaultOIDFunction\"\n  $str4 = \"CryptRegisterOIDFunction\"\n  condition:\n  any of them\n}\n\n```\nThese Yara rules could certainly be tweaked to be slightly more targeted but upon initial inspection, of\nthe 6500 binaries/files returned, there appeared to be no malicious, fully-implemented SIP or trust\nproviders other than a [PoC malicious SIP developed by the author of this whitepaper.](https://virustotal.com/en/file/9f53f93762103f8dc3f3e99c85bbe0ed6406646fd537e206fd2824223415a17b/analysis/)\n\n#### Use of Signature Validation Utilities\n\nBy now, it should be clear that without first validating against trust subversion attacks, that signature\nvalidation utilities like sigcheck, signtool, and Get-AuthenticodeSignature assume that the integrity of\nthe trust validation mechanisms has not been subverted. Therefore, as any threat hunter and DFIR\npractitioner should know, using a single analysis tool/methodology to classify something as benign,\nespecially on a system that is assumed to be compromised, is insufficient. If signature validation tools\nare to be used on a system assumed to be compromised, it would be best to validate that SIP and trust\nprovider registry keys have not been altered in addition to performing offline reputation validation of\ntheir respective DLLs by calculating their file hashes.\n\n\n-----\n\n### Security Vendor Guidance\n\nSecurity product developers should consider the following when building trust subversion attack\nmitigations/detections:\n\n1. Identify calls made to WinVerifyTrust in your codebase. If the user-mode trust architecture in\n\nWindows is relied upon, ensure that registry keys have not been hijacked and that reputation\nhas been established for SIPs and the trust providers your code relies upon.\n2. As has been stated previously, a trust hijack attack can serve as a means of getting code\n\nexecution in the context of code that calls WinVerifyTrust. One of the most effective means of\npreventing untrusted DLLs from being loaded into your process is to register an ELAM driver and\n[run your product as a protected service. As was mentioned previously, any attempted loads into](https://msdn.microsoft.com/en-us/library/windows/desktop/dn313124(v=vs.85).aspx)\na protected process will be prevented and generate a Microsoft-WindowsCodeIntegrity/Operational log 3033 event.\n3. Alert upon any change to SIP or trust provider registry keys.\n4. Any signed code for which a signature does not validate should be treated as if it is not signed.\n5. Non-Microsoft binaries that implement any of the following APIs should be treated with\n\nadditional suspicion:\n\na. CryptSIPAddProvider\nb. CryptSIPRemoveProvider\nc. CryptSIPLoad\nd. CryptSetOIDFunctionValue\ne. CryptRegisterOIDFunction\n\n\n-----\n\n## Appendix\n\n### Known Good SIP and Trust Provider Registrations\n\nThe following is a non-exhaustive list of known SIPs, trust providers, and their implementing DLLs (files\npaths removed)/functions. These should be used as a reference point for baselining normal in your\nenvironment.\n\n### Trust Providers\n```\nGUID: 7801EBD0-CF4B-11D0-851F-0060979387EA\nFriendly Name: CERT_CERTIFICATE_ACTION_VERIFY\n Capability: CertCheck\n  Dll: Cryptdlg.dll\n  Function Name: CertTrustCertPolicy\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: Cryptdlg.dll\n  Function Name: CertTrustCleanup\n Capability: FinalPolicy\n  Dll: Cryptdlg.dll\n  Function Name: CertTrustFinalPolicy\n Capability: Initialization\n  Dll: Cryptdlg.dll\n  Function Name: CertTrustInit\nGUID: 00AAC56B-CD44-11D0-8CC2-00C04FC295EE\nFriendly Name: WINTRUST_ACTION_GENERIC_VERIFY_V2\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubAuthenticode\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n\n```\n\n-----\n\n```\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: D41E4F1D-A407-11D1-8BC9-00C04FA30A41\nFriendly Name: COR_POLICY_PROVIDER_DOWNLOAD\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: FinalPolicy\n  Dll: urlmon.dll\n  Function Name: CORPolicyProvider\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: D41E4F1F-A407-11D1-8BC9-00C04FA30A41\nFriendly Name: COR_POLICY_LOCKDOWN_CHECK\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: FinalPolicy\n  Dll: ieframe.dll\n  Function Name: CORLockDownProvider\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: C6B2E8D0-E005-11CF-A134-00C04FD7BF43\nFriendly Name: WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n\n```\n\n-----\n\n```\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubAuthenticode\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: F750E6C3-38EE-11D1-85E5-00C04FC295EE\nFriendly Name: DRIVER_ACTION_VERIFY\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: DriverCleanupPolicy\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: DriverFinalPolicy\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: DriverInitializePolicy\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: A7F4C378-21BE-494e-BA0F-BB12C5D208C5\nFriendly Name:\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: FinalPolicy\n  Dll: mscorsecimpl.dll\n\n```\n\n-----\n\n```\n  Function Name: CORPolicyEE\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 6078065b-8f22-4b13-bd9b-5b762776f386\nFriendly Name: CONFIG_CI_ACTION_VERIFY\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: DriverCleanupPolicy\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: ConfigCiFinalPolicy\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: DriverInitializePolicy\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 31D1ADC1-D329-11D1-8ED8-0080C76516C6\nFriendly Name: COREE_POLICY_PROVIDER\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: FinalPolicy\n  Dll: mscorsec.dll\n  Function Name: CORPolicyEE\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n\n```\n\n-----\n\n```\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 573E31F8-DDBA-11D0-8CCB-00C04FC295EE\nFriendly Name: WINTRUST_ACTION_TRUSTPROVIDER_TEST\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: DiagnosticPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubDumpStructure\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubAuthenticode\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 573E31F8-AABA-11D0-8CCB-00C04FC295EE\nFriendly Name: HTTPSPROV_ACTION\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: HTTPSCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: HTTPSFinalProv\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n\n```\n\n-----\n\n```\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: FC451C16-AC75-11D1-B4B8-00C04FB66EA0\nFriendly Name: WINTRUST_ACTION_GENERIC_CHAIN_VERIFY\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: GenericChainCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: GenericChainFinalProv\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 189A3842-3041-11D1-85E1-00C04FC295EE\nFriendly Name: WINTRUST_ACTION_GENERIC_CERT_VERIFY\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubAuthenticode\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubDefCertInit\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 64B9D180-8DA2-11CF-8736-00AA00A485EB\n\n```\n\n-----\n\n```\nFriendly Name: WIN_SPUB_ACTION_PUBLISHED_SOFTWARE\n Capability: CertCheck\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCheckCert\n Capability: Certificate\n  Dll: WINTRUST.DLL\n  Function Name: WintrustCertificateTrust\n Capability: Cleanup\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubCleanup\n Capability: FinalPolicy\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubAuthenticode\n Capability: Initialization\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubInitialize\n Capability: Message\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadMessage\n Capability: Signature\n  Dll: WINTRUST.DLL\n  Function Name: SoftpubLoadSignature\nGUID: 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958\nFriendly Name:\n Capability: CertCheck\n  Dll: mso.dll\n  Function Name: MsoSoftpubCheckCert\n Capability: Certificate\n  Dll: mso.dll\n  Function Name: MsoWintrustCertificateTrust\n Capability: Cleanup\n  Dll: mso.dll\n  Function Name: MsoSoftpubCleanupPolicy\n Capability: DiagnosticPolicy\n  Dll: mso.dll\n  Function Name: MsoWintrustTestPolicy\n Capability: FinalPolicy\n  Dll: mso.dll\n  Function Name: MsoWintrustFinalPolicy\n Capability: Initialization\n  Dll: mso.dll\n  Function Name: MsoSoftpubInitialize\n Capability: Message\n  Dll: mso.dll\n  Function Name: MsoSoftpubLoadMessage\n Capability: Signature\n  Dll: mso.dll\n  Function Name: MsoSoftpubLoadSignature\n\n```\n\n-----\n\n### Subject Interface Packages\n```\nGUID: 0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1\nFriendly Name: AppX\n Capability: CryptSIPDllCreateIndirectData\n  Dll: AppxSip.dll\n  Function Name: AppxSipCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxSipGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: AppxSip.dll\n  Function Name: AppxSipIsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxSipPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxSipRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: AppxSip.dll\n  Function Name: AppxSipVerifyIndirectData\nGUID: C689AABA-8E78-11D0-8C47-00C04FC295EE\nFriendly Name: Cabinet\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPVerifyIndirectData\nGUID: 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE\nFriendly Name: CTL\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n\n```\n\n-----\n\n```\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPVerifyIndirectData\nGUID: 1A610570-38CE-11D4-A2A3-00104BD35090\nFriendly Name: WSHWindowsScriptFile\n Capability: CryptSIPDllCreateIndirectData\n  Dll: wshext.dll\n  Function Name: CreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: wshext.dll\n  Function Name: GetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: wshext.dll\n  Function Name: IsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: wshext.dll\n  Function Name: PutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: wshext.dll\n  Function Name: RemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: wshext.dll\n  Function Name: VerifyIndirectData\nGUID: 000C10F1-0000-0000-C000-000000000046\nFriendly Name: MSI\n Capability: CryptSIPDllCreateIndirectData\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPIsMyTypeOfFile\n\n```\n\n-----\n\n```\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: MSISIP.DLL\n  Function Name: MsiSIPVerifyIndirectData\nGUID: 603BCC1F-4B59-4E08-B724-D2C6297EF351\nFriendly Name: PowerShell\n Capability: CryptSIPDllCreateIndirectData\n  Dll: pwrshsip.dll\n  Function Name: PsCreateHash\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: pwrshsip.dll\n  Function Name: PsGetSignature\n Capability: CryptSIPDllIsMyFileType2\n  Dll: pwrshsip.dll\n  Function Name: PsIsMyFileType\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: pwrshsip.dll\n  Function Name: PsPutSignature\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: pwrshsip.dll\n  Function Name: PsDelSignature\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: pwrshsip.dll\n  Function Name: PsVerifyHash\nGUID: 06C9E010-38CE-11D4-A2A3-00104BD35090\nFriendly Name: WSHJScript\n Capability: CryptSIPDllCreateIndirectData\n  Dll: wshext.dll\n  Function Name: CreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: wshext.dll\n  Function Name: GetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: wshext.dll\n  Function Name: IsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: wshext.dll\n  Function Name: PutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: wshext.dll\n  Function Name: RemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: wshext.dll\n  Function Name: VerifyIndirectData\n\n```\n\n-----\n\n```\nGUID: CF78C6DE-64A2-4799-B506-89ADFF5D16D6\nFriendly Name: AppXEncrypted\n Capability: CryptSIPDllCreateIndirectData\n  Dll: AppxSip.dll\n  Function Name: EappxSipCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxSipGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: AppxSip.dll\n  Function Name: EappxSipIsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxSipPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxSipRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: AppxSip.dll\n  Function Name: EappxSipVerifyIndirectData\nGUID: D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C\nFriendly Name: AppXEncryptedBundle\n Capability: CryptSIPDllCreateIndirectData\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipIsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: AppxSip.dll\n  Function Name: EappxBundleSipVerifyIndirectData\nGUID: 0F5F58B3-AADE-4B9A-A434-95742D92ECEB\nFriendly Name: AppXBundle\n Capability: CryptSIPDllCreateIndirectData\n  Dll: AppxSip.dll\n  Function Name: AppxBundleSipCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxBundleSipGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: AppxSip.dll\n\n```\n\n-----\n\n```\n  Function Name: AppxBundleSipIsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxBundleSipPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: AppxBundleSipRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: AppxSip.dll\n  Function Name: AppxBundleSipVerifyIndirectData\nGUID: 9F3053C5-439D-4BF7-8A77-04F0450A1D9F\nFriendly Name: ElectronicSoftwareDistribution\n Capability: CryptSIPDllCreateIndirectData\n  Dll: EsdSip.dll\n  Function Name: EsdSipCreateHash\n Capability: CryptSIPDllGetCaps\n  Dll: EsdSip.dll\n  Function Name: EsdSipGetCaps\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: EsdSip.dll\n  Function Name: EsdSipGetSignature\n Capability: CryptSIPDllIsMyFileType2\n  Dll: EsdSip.dll\n  Function Name: EsdSipIsMyFileType\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: EsdSip.dll\n  Function Name: EsdSipPutSignature\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: EsdSip.dll\n  Function Name: EsdSipDelSignature\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: EsdSip.dll\n  Function Name: EsdSipVerifyHash\nGUID: C689AAB9-8E78-11D0-8C47-00C04FC295EE\nFriendly Name: JavaClass\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n\n```\n\n-----\n\n```\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPVerifyIndirectData\nGUID: 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB\nFriendly Name: WSHVBScript\n Capability: CryptSIPDllCreateIndirectData\n  Dll: wshext.dll\n  Function Name: CreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: wshext.dll\n  Function Name: GetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: wshext.dll\n  Function Name: IsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: wshext.dll\n  Function Name: PutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: wshext.dll\n  Function Name: RemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: wshext.dll\n  Function Name: VerifyIndirectData\nGUID: DE351A42-8E59-11D0-8C47-00C04FC295EE\nFriendly Name: Flat\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPVerifyIndirectData\n\n```\n\n-----\n\n```\nGUID: 5598CFF1-68DB-4340-B57F-1CACF88C9A51\nFriendly Name: AppXP7XSignature\n Capability: CryptSIPDllCreateIndirectData\n  Dll: AppxSip.dll\n  Function Name: P7SipCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: P7xSipGetSignedDataMsg\n Capability: CryptSIPDllIsMyFileType2\n  Dll: AppxSip.dll\n  Function Name: P7xSipIsFileSupportedName\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: P7xSipPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: AppxSip.dll\n  Function Name: P7xSipRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: AppxSip.dll\n  Function Name: P7xSipVerifyIndirectData\nGUID: DE351A43-8E59-11D0-8C47-00C04FC295EE\nFriendly Name: Catalog\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPVerifyIndirectData\nGUID: C689AAB8-8E78-11D0-8C47-00C04FC295EE\nFriendly Name: PortableExecutable\n Capability: CryptSIPDllCreateIndirectData\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: WINTRUST.DLL\n\n```\n\n-----\n\n```\n  Function Name: CryptSIPGetCaps\n Capability: CryptSIPDllGetSealedDigest\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSealedDigest\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: WINTRUST.DLL\n  Function Name: CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: WINTRUST.dll\n  Function Name: CryptSIPVerifyIndirectData\nGUID: BA08A66F-113B-4D58-9329-A1B37AF30F0E\nFriendly Name: SilverlightXAP\n Capability: CryptSIPDllCreateIndirectData\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_CryptSIPCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_CryptSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_CryptSIPPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_CryptSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_CryptSIPVerifyIndirectData\n Capability: CryptSIPDllIsMyFileType2\n  Dll: XapAuthenticodeSip.dll\n  Function Name: XAP_IsFileSupportedName\nGUID: CB034CC7-4A2D-8E07-48E7-F82436FFA03E\nFriendly Name: MicrosoftDynamicsNAV\n Capability: CryptSIPDllCreateIndirectData\n  Dll: navsip.dll\n  Function Name: NavSIPCreateIndirectData\n Capability: CryptSIPDllGetCaps\n  Dll: navsip.dll\n  Function Name: NavSIPGetCaps\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: navsip.dll\n  Function Name: NavSIPGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: navsip.dll\n  Function Name: NavSIPPutSignedDataMsg\n\n```\n\n-----\n\n```\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: navsip.dll\n  Function Name: NavSIPRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: navsip.dll\n  Function Name: NavSIPVerifyIndirectData\n Capability: CryptSIPDllIsMyFileType2\n  Dll: navsip.dll\n  Function Name: NavSIPIsFileSupportedName\nGUID: 9FA65764-C36F-4319-9737-658A34585BB7\nFriendly Name: MicrosoftOfficeVBA\n Capability: CryptSIPDllCreateIndirectData\n  Dll: mso.dll\n  Function Name: MsoVBADigSigCreateIndirectData\n Capability: CryptSIPDllGetSignedDataMsg\n  Dll: mso.dll\n  Function Name: MsoVBADigSigGetSignedDataMsg\n Capability: CryptSIPDllPutSignedDataMsg\n  Dll: mso.dll\n  Function Name: MsoVBADigSigPutSignedDataMsg\n Capability: CryptSIPDllRemoveSignedDataMsg\n  Dll: mso.dll\n  Function Name: MsoVBADigSigRemoveSignedDataMsg\n Capability: CryptSIPDllVerifyIndirectData\n  Dll: mso.dll\n  Function Name: MsoVBADigSigVerifyIndirectData\n\n```\n\n-----\n\n## References\n\nPrior to authoring this whitepaper, there was no information on the security implications of SIPs and\ntrust providers. The following references were helpful in completing this research, however:\n\n1. [SIP’s (Subject Interface Package) and Authenticode](https://blogs.technet.microsoft.com/eduardonavarro/2008/07/11/sips-subject-interface-package-and-authenticode/)\n2. [Cryptography Functions](https://msdn.microsoft.com/en-us/library/windows/desktop/aa380252(v=vs.85).aspx)\n3. How To Get Information from [Authenticode Signed Executables](https://support.microsoft.com/en-us/help/323809/how-to-get-information-from-authenticode-signed-executables)\n4. [Behind PowerShell Installer (for Windows XP / Windows Server 2003)](https://blogs.msdn.microsoft.com/powershell/2007/01/09/behind-powershell-installer-for-windows-xp-windows-server-2003/)\n5. [Microsoft Security Bulletin MS13-098](https://technet.microsoft.com/library/security/ms13-098#ID0EDHAG)\n6. MSDN documentation\n7. Windows SDK header files: mssip.h, wintrust.h, wincrypt.h, softpub.h\n8. [Subject Interface Packages - Part 1. Released after research was performed but this is a valuable](https://vcsjones.com/2017/08/10/subject-interface-packages/)\n\nresource about SIP design principles.\n9. [Subject Interface Packages - Part 2.](https://vcsjones.com/2017/08/11/subject-interface-packages-part-2/)\n\n\n-----\n\n## Acknowledgements\n\nThe following people performed a thorough review of this whitepaper and supplied invaluable feedback:\n\n  - [Brian Reitz,](https://twitter.com/brian_psu) [Will Schroeder, and Lee Christensen](https://twitter.com/harmj0y) [at SpecterOps](https://www.specterops.io/)\n\n  - [Casey Smith](https://twitter.com/subTee) [at Red Canary](https://www.redcanary.com/)\n\n  - [Daniel Schell](https://twitter.com/danonit) [and David Cottingham at Airlock Digital](https://twitter.com/c0tts)\n\n  - [Joe Desimone at Endgame](https://twitter.com/dez_)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf"
    ],
    "report_names": [
        "SpecterOps_Subverting_Trust_in_Windows.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1505814058,
    "ts_modification_date": 1505814058,
    "files": {
        "pdf": "https://archive.orkl.eu/ca9b35c1494cea8229628edc7f0111eb09118f48.pdf",
        "text": "https://archive.orkl.eu/ca9b35c1494cea8229628edc7f0111eb09118f48.txt",
        "img": "https://archive.orkl.eu/ca9b35c1494cea8229628edc7f0111eb09118f48.jpg"
    }
}