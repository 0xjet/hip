{
    "id": "50b7c88e-fb24-4b2f-a103-852c6a9efbf9",
    "created_at": "2023-01-12T15:09:12.407781Z",
    "updated_at": "2025-03-27T02:16:09.454536Z",
    "deleted_at": null,
    "sha1_hash": "6c217f11d36ed7d3f7972a8349ac1f2a7ec3fbba",
    "title": "2021-09-30 - GhostEmperor- From ProxyLogon to kernel mode",
    "authors": "",
    "file_creation_date": "2022-05-28T05:12:45Z",
    "file_modification_date": "2022-05-28T05:12:45Z",
    "file_size": 1809912,
    "plain_text": "# GhostEmperor: From ProxyLogon to kernel mode\n\n**[securelist.com/ghostemperor-from-proxylogon-to-kernel-mode/104407/](https://securelist.com/ghostemperor-from-proxylogon-to-kernel-mode/104407/)**\n\nAuthors\n\n[Mark Lechtik](https://securelist.com/author/marklechtik/)\n\nAseel Kayal\n\n[Paul Rascagneres](https://securelist.com/author/paulrascagneres/)\n\n[Vasily Berdnikov](https://securelist.com/author/vasilyberdnikov/)\n\n[Download GhostEmperor’s technical details (PDF)](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2021/09/30094337/GhostEmperor_technical-details_PDF_eng.pdf)\n\n\n-----\n\nWhile investigating a recent rise of attacks against Exchange servers, we noticed a recurring\ncluster of activity that appeared in several distinct compromised networks. This cluster stood\nout for its usage of a formerly unknown Windows kernel mode rootkit that we dubbed\nDemodex, and a sophisticated multi-stage malware framework aimed at providing remote\ncontrol over the attacked servers.\n\nThe former is used to hide the user mode malware’s artefacts from investigators and security\nsolutions, while demonstrating an interesting undocumented loading scheme involving the\n[kernel mode component of an open-source project named Cheat Engine to bypass the](https://www.cheatengine.org/)\nWindows Driver Signature Enforcement mechanism.\n\nIn an attempt to trace the duration of the observed attacks, we were able to see the toolset in\nquestion being used from as early as July 2020. Furthermore, we could see that the actor\nwas mostly focused on South East Asian targets, with outliers in Egypt, Afghanistan and\nEthiopia which included several governmental entities and telecommunication companies.\n\nWith a long-standing operation, high profile victims, advanced toolset and no affinity to a\nknown threat actor, we decided to dub the underlying cluster GhostEmperor. Our\ninvestigation into this activity leads us to believe that the underlying actor is highly skilled and\naccomplished in their craft, both of which are evident through the use of a broad set of\nunusual and sophisticated anti-forensic and anti-analysis techniques.\n\n## How were the victims initially infected?\n\nWe identified multiple attack vectors that triggered an infection chain leading to the execution\nof malware in memory. We noticed that the majority of the GhostEmperor infections were\ndeployed on public facing servers, as many of the malicious artefacts were installed by the\n‘httpd.exe’ Apache server process, the ‘w3wp.exe’ IIS Windows server process, or the\n‘oc4j.jar’ Oracle server process. This means that the attackers likely abused vulnerabilities in\nthe web applications running on those systems, allowing them to drop and execute their files.\n\nIt is worth mentioning that one of the GhostEmperor infections affected an Exchange server,\nand took place on March 4, 2021. This was only two days after the patch for the ProxyLogon\nvulnerability was released by Microsoft, and it is possible that the attackers exploited this\nvulnerability in order to allow them to achieve remote code execution on vulnerable\nExchange servers.\n\nAlthough GhostEmperor’s infections often start with a BAT file, in some cases the known\ninfection chain was preceded by an earlier stage: a malicious DLL that was side-loaded by\nwdichost.exe, a legitimate command line utility by Microsoft originally called MpCmdRun.exe.\nThe side-loaded DLL then proceeds to decode and load an additional executable called\nlicense.rtf. Unfortunately, we did not manage to retrieve this executable, but we saw that the\nconsecutive actions of loading it included the creation and execution of GhostEmperor\nscripts by wdichost.exe.\n\n\n-----\n\n_Example of a GhostEmperor infection chain started by a side-loaded DLL_\n\nLastly, some of the Demodex deployments were performed remotely from another system in\nthe network using legitimate tools such as WMI or PsExec, suggesting that the attackers\nhave infected parts of the victims’ networks beforehand.\n\n## Infection chain overview\n\nThe infection can be divided into several stages that operate in succession to activate an inmemory implant and allow it to deploy additional payloads during run time. This section\nprovides a brief overview of these stages, including a description of the final payloads. The\n[internals of these payloads can be found in a technical document that accompanies this](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2021/09/30094337/GhostEmperor_technical-details_PDF_eng.pdf)\npublication.\n\nThe flow of infection starts with a PowerShell dropper. The purpose of this component is to\nstage the subsequent element in the chain by installing it as a service. Before doing so, it\ncreates a couple of registry keys that it assigns encrypted data to, one of which corresponds\nto a payload that will be deployed in the later stages. It’s worth noting that the script itself is\ndelivered in a packed form, whereby its complete execution is dependent on a command-line\nargument that is used as a key to decrypt the bulk of its logic and data. Without this key, it’s\nimpossible to recover the flow that comes after this stage.\n\n\n-----\n\n_Initial stage comprised of encrypted PowerShell code that is decrypted based on an attacker-_\n_provided AES key during run time_\n\nThe next stage, which is executed as a service by the former, is intended to serve as yet\nanother precursor for the next phases. It is used to read the encrypted data from the\npreviously written registry keys and decrypt it to initiate the execution of an in-memory\nimplant. We identified two variants of this component, one developed in C++ and another in\n.NET. The latter, which appeared in the wild as early as March 2021, uses the GUID of the\ninfected machine to derive the decryption key, and is thus tailored to be executed on that\nspecific system. The C++ variant, on the other hand, relies on hardcoded AES 256\nencryption keys.\n\nThe third stage is the core implant that operates in memory after being deployed by the\naforementioned loader, and is injected into the address space of a newly created\nsvchost.exe process. Its main goal is to facilitate a communication channel with a C2 server,\nwhereby malicious traffic is masqueraded under the guise of communication with a benign\nservice, based on a Malleable C2 profile embedded within its configuration. It is important to\nnote that the implementation of the Malleable C2 feature, which is originally provided in the\nCobalt Strike framework, is customized and most likely rewritten based on reverse\nengineering of Cobalt Strike’s code.\n\nAnother interesting technique used to conceal the malicious traffic is the malware’s usage of\nfake file format headers to encapsulate the data passed to the C&C server. To do so, the inmemory implant synthesizes a fake media file of one of the formats RIFF, JPEG or PNG and\n\n\n-----\n\nputs any data conveyed to the server in encrypted form as its body. Thus, the transmitted\npacket appears as either an image or audio file and blends with other legitimate traffic in the\nnetwork.\n\n_Malleable C2 profile and fake header_\n\nThe last stage is the payload injected to the winlogon.exe process by the aforementioned\nimplant and used to provide remote control capabilities to the attackers. Such capabilities\ninclude initiation of a remote console or desktop session, with the latter supporting execution\nof sent mouse clicks and keystrokes on the target machine and retrieval of periodic\nscreenshots that reflect the output of those actions. This stage can also allow the attackers\nto load arbitrary .NET assemblies or execute PowerShell commands, as well as fully control\nthe victim’s filesystem in order to search, retrieve or push files to it.\n\nIn addition to the last stage payload, the core component is also capable of deploying a\nWindows kernel mode driver on the system. The purpose of this driver is to serve as a rootkit\nthat conceals malware artefacts such as files, registry keys and network traffic, thus gaining\nstealth and ability to avoid detection by security products and forensic investigators. The\nupcoming sections elaborate on how this driver is deployed (namely how it bypasses\nWindows mitigations, given that it’s not digitally signed) and what particular features it\nprovides to the user mode malicious implant.\n\n\n-----\n\n_Overview of the GhostEmperor infection chain_\n\n## Rootkit loading analysis\n\nOn modern 64-bit Windows operating systems, it is generally not possible to load an\nunsigned driver in a documented way due to the Driver Signature Enforcement mechanism\nintroduced by Microsoft. For this reason, attackers have abused vulnerabilities in signed\ndrivers to allow execution of unsigned code to kernel space. A typical approach1 taken by\nmany actors to date, and mostly in older versions of Windows, is to disable the Code\nIntegrity mechanism by switching the nt!g_CiEnabled flag that resides within the CI.DLL\nkernel module after getting write and execution primitives via vulnerable signed drivers. After\nshutting down the Code Integrity mechanism, an unsigned driver can be loaded.\n\nThis approach was limited by Microsoft with the introduction of Kernel Patch Protection (a.k.a\nPatchGuard). This mechanism protects modification of specific data structures in the\nWindows kernel memory space, including the nt!g_CiEnabled flag. For this reason, the\nmodification of this flag can now cause an invocation of a BSOD. This can be tackled by\nquickly setting the flag value, loading an unsigned driver and switching it back to the previous\nstate before PatchGuard identifies a change, though this still introduces a race condition that\ncan crash the system.\n\n\nThe approach used by the developer of this rootkit allows loading an unsigned driver without\nmodifying the Code Integrity image and dealing with a potential crash. It abuses features of a\nlegitimate and open-source2 signed driver named dbk64.sys which is shipped along with\n\n\n-----\n\nCheat Engine, an application created to bypass video game protections and introduce cheats\ninto them. This driver provides capability to write and execute code in kernel space by\ndesign, thus allowing it to run arbitrary code in kernel mode.\n\nAfter dropping the dbk64.sys driver with a randomly generated filename to disk and loading\nit, the malware issues documented3 IOCTLs to the driver that allow shellcode to be run in\nkernel space through the following sequence of actions:\n\nFirst, a memory buffer is allocated in the kernel space non-paged pool by issuing\nIOCTL_CE_ALLOCATEMEM_NONPAGED.\nA successfully allocated memory buffer will be then shared between the user mode\nmalware process and kernel address spaces using a direct I/O approach, whereby the\nkernel mode buffer’s address is mapped to a different address in user space. This is\nachieved by locking the buffer’s pages in physical memory so that they cannot be\npaged out (which is possible since they are allocated in the non-paged pool) following\nwhich an MDL for the buffer is created and a call to the\nMmMapLockedPagesSpecifyCache API function is made. All of this is implemented in\nthe handler of IOCTL_CE_MAP_MEMORY.\nAt this point the malware can access the buffer in user mode through the provided\npointer from the previous IOCTL and write to it. The written data will in turn be reflected\nin the same buffer in kernel space. This is used to write the shellcode into the buffer.\nAfter the writing is done, the buffer is unmapped from user space by issuing\nIOCTL_CE_UNMAP_MEMORY.\nThe written shellcode now resides only in kernel space and can be run by issuing\nIOCTL_CE_EXECUTE_CODE.\n\nThe purpose of the shellcode is to replace the dbk64.sys IOCTL dispatcher with an\nalternative one that in turn allows the loading of an unsigned driver. The alternative\ndispatcher is also implemented as position-independent code and is bundled with the\nshellcode. To replace the original dispatcher, the shellcode maps the code of the new\ndispatcher in memory and patches the pointer to the IRP_MJ_DEVICE_CONTROL routine in\nthe dbk64.sys driver object. At this point, the IRP_MJ_DEVICE_CONTROL pointer is set to\nthe new dispatcher’s address and any IOCTL issued to the driver will pass through it.\n\n_IRP_MJ_DEVICE_CONROL hooking_\n\n\n-----\n\nThe alternative dispatcher provides the same core capabilities as the original one, with the\naddition of a few that allow it to load a new driver to kernel space. The functionality that\nmakes it possible to achieve this goal is exposed through a set of IOCTL handlers that are\ncalled in succession, finally leading to the load of the malware’s kernel mode rootkit. Below is\na table of these IOCTLs with descriptions, arranged in the order they are invoked by the\nmalware’s user mode logic in charge of deploying the rootkit.\n\n\n**IOCTL**\n**Code**\n\n\n**Description**\n\n\n0x220180 Processes a buffer provided by the user mode malware component by\nverifying its size is 272 bytes and then decodes it by negating its bytes. This\nIOCTL is in fact not invoked by the user mode code.\n\n0x220184 Allocates a buffer in kernel space, locks its pages, creates an MDL and maps\nthe buffer to a user mode address using the\nMmMapLockedPagesSpecifyCache API. This is essentially equivalent to the\nchaining of functionalities in IOCTL_CE_ALLOCATEMEM_NONPAGED and\nIOCTL_CE_MAP_MEMORY from the original dispatcher.\nAfter this call, the user mode code has access to a kernel mode buffer and\ncan write to it using a pointer in user mode, as was the case for writing the\nshellcode. This time, however, the malware manually loads the rootkit’s PE\nimage into the allocated buffer.\n\n0x2201B4 Since the malware’s user mode code is in charge of loading the rootkit’s\nimage manually in IOCTL 0x220184, it has to resolve some function\naddresses in kernel space that appear as dependencies in the image’s Import\nAddress Table. This IOCTL allows the function names to be received from\nuser space as strings, retrieving their address with the\nMmGetSystemRoutineAddress API and providing it back to the user mode\ncode. The latter places the resolved address in the corresponding IAT entry of\nthe loaded image.\n\n0x220188 Unmaps the address of the kernel mode buffer from user space so it’s only\naccessible through its kernel mode pointer.\n\n0x2201B8 Creates a new driver object using the IoCreateDriver function, assigning the\ndriver initialization function pointer to a position-independent stub that is\ndelivered with the shellcode and, once invoked, calls the loaded rootkit’s\nDriverEntry function.\n\nIt is worth mentioning that the malware’s service makes use of a Cheat Engine utility called\nkernelmoduleuloader.exe (MD5: 96F5312281777E9CC912D5B2D09E6132) during the\nloading of the dbk64.sys driver. The driver is dropped along with the utility and a .sig file, with\nthe latter being used as a means of authenticating the component calling dbk64.sys by\nconveying a digital signature that is associated with its binary.\n\n\n-----\n\nAs the malware is not a component of Cheat Engine, it runs kernelmoduleunloader.exe as a\nnew process and injects it with a small shellcode that merely opens a handle to the\ndbk64.sys device with the CreateFileW API. The value of the handle is written as the second\nQWORD in the injected buffer, read by the malware’s process and gets duplicated using the\nDuplicateHandle API. From this point on, the malware’s service can call the driver as if it was\na signed Cheat Engine component.\n\n_An outline of the rootkit’s loading phases_\n\n## Demodex rootkit functionality\n\nThe loaded rootkit, which we dubbed Demodex, serves the purpose of hiding several\nartefacts of the malware’s service. This is achieved through a set of IOCTLs exposed by the\nrootkit’s driver that are in turn called by the service’s user mode code, each disguising a\nparticular malicious artefact. To access the rootkit’s functionality, the malware ought to obtain\na handle to the corresponding device object, after which the following IOCTLs are available\nfor further use:\n\n\n-----\n\n**0x220204: Receives an argument with the PID of the svchost.exe process which runs**\nthe code of the malicious service and stores it within a global variable. This variable is\nused by other IOCTLs later on.\n**0x220224: Initializes global variables that are later used to hold data such as the**\naforementioned svchost.exe PID, the name of the malware’s service, the path to the\nmalware’s DLL and a network port.\n**0x220300: Hides the malware’s service from a list within the services.exe process**\naddress space. The service’s name is passed as an argument to the IOCTL, in turn\nbeing sought in a system-maintained linked list. The corresponding entry is being\nunlinked, thus hiding the service from being easily detected. The logic in this handler is\n[reminiscent of the technique outlined here.](http://codeproject.com/Articles/46670/Service-Hiding#2_4)\n**0x220304: This IOCTL is used to register a file system filter driver’s notification routine**\nby using the IoRegisterFSRegistrationChange API. The notification routine invoked\nupon registration of a new file system verifies if it is an NTFS-based one and if so,\ncreates a device object for the rootkit which is attached to the subject file system’s\ndevice stack. Additionally, both the file system’s device object and the associated\nrootkit device object are registered in a global list maintained by the rootkit’s driver.\nSubsequent attempts to retrieve information from, access or modify the file will fail and\ngenerate error codes such as STATUS_NO_MORE_FILES or\nSTATUS_NO_SUCH_FILE.\n**0x220308: Hides TCP connections that make use of ports within a given range from**\nutilities that list them, such as netstat. This is done through a known4 method whereby\nthe IOCTL dispatch routine of the NSI proxy driver is hooked and the completion\nroutine is set to one that inspects the port of a given connection. If the underlying\nconnection’s port falls within the given range, its entry is removed from the system’s\nTCP table. The two ports that constitute the range are passed as arguments to the\nIOCTL.\n\n\n-----\n\n**0x22030C: Hides malware-related registry keys by hooking several registry operations**\nthrough the CmRegisterCallback API. The registered callback checks the type of\noperation and acts according to the following logic:\n\nFor operations of the type RegNtPostEnumerateKey or\nRegNtPostEnumerateValueKey (enumeration of a key or subkey) it verifies if\nthere is an attempt to enumerate the driver related key under\nHKLM\\SYSTEM\\ControlSet0**\\Services\\<malware_service_name> and if so, sets\nthe return status of the operation to STATUS_NO_MORE_ENTRIES in order to\nindicate there is no data to provide for the requested enumeration.\nFor operations of the type RegNtPreOpenKeyEx (attempt to open a key) on\nSOFTWARE\\Microsoft\\{EAAB20A7-9B68-4185-A447-7E4D21621943} it clears all\nthe driver’s internal global variables, which is equivalent to resetting its operation.\nThat’s because this key is used by the malware’s uninstaller PowerShell script,\nmentioned in previous sections.\nFor any attempt to change a key under HKLM\\MACHINE\\SYSTEM via an\noperation with code RegNtPreSaveKey or lower, it sets that return status to the\napplication error 0xC0000043.\n\nInterestingly, the pointer passed to CmRegisterCallback does not contain the direct address\nof the function handling the logic above, but instead an address at the end of the executable\nsection of the pci.sys driver’s image, which is originally filled with zeros as a means to align\nthe section in memory. Before passing the callback pointer to CmRegisterCallback, such a\nsection is sought within the pci.sys driver and the corresponding bytes within it are patched\nso as to invoke the call to the actual callback handling the above logic, as outlined below.\nThis allows all intercepted registry operations to appear as if they are handled by code that\noriginates in the legit pci.sys driver.\n\n_Code used to patch a section in the pci.sys image in memory in order to write it with a short_\n_shellcode stub that jumps into a registry inspection callback_\n\n\n-----\n\nIt is worth mentioning that the Demodex rootkit supports Windows 10 by design, and indeed\nappears to work according to our tests on Windows 10 builds. This is evident in the driver’s\ncode in multiple places where different flows of the code are taken based on the underlying\noperating system’s version. In such checks it is possible to observe that some flows\ncorrespond to the latest builds of Windows 10, as outlined in the code snippet below.\n\n## Obfuscation and anti-analysis methods\n\nThe authors of the malware components used in the GhostEmperor cluster of activity have\nmade some development choices that have implications on the forensic analysis process. To\ndemonstrate some of the hurdles that investigators face, we will limit the discussion to two\ncommon analysis tools – WinDbg and Volatility. Other tools may encounter similar drawbacks\nwhen dealing with the implants in question.\n\nFirst, due to the way Demodex is loaded, its driver is not properly enlisted in WinDbg along\nwith other system modules that are loaded in a documented way. That said, it is still possible\nto find the rootkit’s driver object by referring to its name (\\driver\\dump_audio_codec0), thus\nbeing able to list its associated device objects as well:\n\n_Driver object name listed in WinDBG_\n\nSimilarly, when trying to list system modules with the Volatility3 widows.driverscan module,\nthe Demodex driver is absent from the output. However, the framework does indicate that an\nanomaly is detected in the process of scanning the kernel’s memory space in search for the\ndriver:\n\n_Anomaly while listing the Demodex driver with the windows.driverscan Volatility3 module_\n\n\n-----\n\nIn addition, the malware authors have made a deliberate choice to remove all PE headers\nfrom memory-loaded images in both the third stage of the malware and the rootkit’s driver.\nThis is done by either introducing the image with a zeroed-out header to begin with (as is the\ncase in the third stage) and relying on a custom loader to prepare it for execution or by\nreplacing the header of the image after its loaded with the 0x00 value, as is the case with the\nrootkit’s driver. From a forensic perspective, this impedes the process of identifying PE\nimages loaded to memory by searching for their headers.\n\nAs mentioned in previous sections, the developers implemented a trampoline within the\npci.sys legitimate driver in order to mask the source of callbacks that are invoked for registryrelated operations. Thus, analysts that try to track such callbacks may miss out on some\nbecause they will appear to be benign calls. As demonstrated in the WinDbg listing of the\nCm* callbacks below, one of them is associated with the symbol\npci!ArbLibraryDeinitialize+0xa4; however, if we look at the code at the same address we can\nsee that it is in fact a small piece of shellcode emitted by the rootkit in order to jump to the\nactual malicious callback that hides the malware’s registry keys.\n\n\n-----\n\n_Listing of Cm callbacks and shellcode found within a seemingly benign code invoked from_\n_the pci.sys driver_\n\nApart from the above, the developers introduced more standard methods of obfuscation that\ntypically slow the static analysis of the code and are evident across multiple malware\ncomponents. An example of this is a pattern of string obfuscation whereby each string is\ndecoded with a set of predefined arithmetic and logic operations, such that different\noperands (e.g., shift offsets) are chosen for each string. This suggests that each string is\nobfuscated during compilation and that the authors have established a form of SDK that aids\nin uniquely obfuscating each sample during build time.\n\n_String decoding logic used to obtain clear-text strings from hardcoded blobs through a set of_\n_arithmetic and logic operations_\n\nSimilarly, it is possible to observe multiple instances of API call obfuscation in the code. This\nis done by replacing inline calls to API functions with other stub functions that build the\nrequested API name as a stack string, resolve it using GetProcAddress and call it while\npassing the arguments provided in a special struct to the stub function. The struct has a\nbigger size than required to pass the argument data, and most of it is filled with junk, such\nthat only particular fields have meaningful data that gets encoded before being passed to the\nstub. Those fields get decoded within the stub function and in turn passed to the API\nfunction.\n\n\n-----\n\n_Example of a stub used for API call obfuscation_\n\nIt is worth noting that as in the case of string obfuscation, each stub is uniquely built and\nmakes use of an argument struct of a different size where the fields that are occupied with\nactual argument data are chosen at random. The order in which the stack string is initialized\nis also random and each stub function is used only once as a replacement for a single inline\nAPI function call. In other words, the same API function used in different places in the code\nwill have different stubs for each place with different argument structs. This reinforces the\nobservation that the authors were using a designated obfuscation SDK in which the API call\nobfuscation is yet another feature.\n\nFinally, it is possible to see that some variants appeared in both obfuscated and nonobfuscated form. For example, we managed to view the C++ version of the second stage\nloader in two forms – one form that has no obfuscation at all and another that is heavily\nobfuscated (MD5: 18BE25AB5592329858965BEDFCC105AF). In the figure below we can\nsee the same function in the two variants: one has the original flow of the code as produced\nby a compiler without obfuscation, while the other has its control flow flattened to the point\nwhere it is impossible to track the order of actions.\n\n_Example of the same function used in two variants of the second stage loader; one is non-_\n_obfuscated and the other’s control flow was flattened_\n\n## Post-exploitation toolset\n\nOnce the attackers gain access to the compromised systems through the aforementioned\ninfection chain, they use a mix of legitimate and open-source offensive toolsets to harvest\nuser credentials and pivot to other systems in the network. This includes common utilities\nfrom the Sysinternals suite used to control processes (e.g., PsExec, PsList and ProcDump),\nas well as other tools like WinRAR, CertUtil and BITSAdmin. As for open-source tools, the\n\n\n-----\n\nattackers used tools such as mimkat_ssp, Get-PassHashes.ps1, Token.exe and Ladon.\nInternal network reconnaissance and communication is often carried out by NBTscan and\nPowercat.\n\nA more comprehensive outline of these tools along with the actual command lines used by\nthe threat actor to operate them can be found in the supplementary technical document.\n\n## Network infrastructure\n\nFor C2 communication, the attackers registered domains whose names appear to have been\nrandomly generated, potentially not to attract any attention to the malicious traffic.\nGhostEmperor mainly used hosting services based in Hong Kong and South Korea, such as\nDaou Technology or Anchent Asia Limited.\n\nnewlylab[.]com\nreclubpress[.]com\nwebdignusdata[.]com\nfreedecrease[.]com\naftercould[.]com\ndatacentreonline[.]com\nnewfreepre[.]com\n\nWe also observed additional IP addresses used for downloading some of the malicious\nsamples, or for C2 communication by the in-memory implant:\n\n154.223.135[.]214\n107.148.165[.]158\n27.102.114[.]55\n27.102.113[.]57\n27.102.113[.]240\n\n## Who were the targets?\n\nThe majority of GhostEmperor’s victims were government entities and telecommunication\ncompanies in South East Asia, with multiple high-profile entities targeted in Malaysia,\nThailand, Vietnam and Indonesia. We also observed additional victims of a similar nature\nfrom countries such as Egypt, Ethiopia and Afghanistan. Even though the latter cluster of\nvictims belongs to a different region from the one in which we saw GhostEmperor to be\nhighly active, we noticed that some of the organizations within it have strong ties with\ncountries in South East Asia. This means that the attackers might have leveraged those\ninfections to spy on the activities in countries that are of geopolitical interest to them.\n\n## Who is behind the attacks?\n\n\n-----\n\nWe attribute this activity to a formerly unknown Chinese-speaking threat actor. This is due to\nthe fact that the attackers made use of open-source tools such as Ladon or Mimikat_ssp that\nare popular among such actors, with additional data points such as version info found within\nthe resource section of second stage loader binaries that included a legal trademark field\nwith a Chinese character: ‘Windows庐 is a registered trademark of Microsoft Corporation.’\n\n_Version info of loader binary with a Chinese character_\n\nOn the same note, we observed that one of the decryption keys provided in a command line\nby the attackers and used to decode the first stage PowerShell scripts was ‘wudi520’.\nLooking it up in publicly available sources led us to a GitHub account under the same name.\nAlthough we cannot confirm this account is indeed connected to the GhostEmperor\nattackers, it has forked multiple code repositories with descriptions in Chinese or that are\notherwise authored by Chinese-speaking developers.\n\n_“wudi520” GitHub account_\n\n\n-----\n\nIn addition, we noticed some similarities between the features of Demodex and those of the\n[Derusbi rootkit, which was publicly described in the past and also attributed to a Chinese-](https://airbus-cyber-security.com/fr/newcomers-derusbi-family/)\nspeaking actor. The purpose of both is to hide malicious artefacts, where notably both have\nan almost identical flow for hiding TCP connections by hooking the nsiproxy.sys IOCTL\ndispatcher. The implementation of this filtering in the Demodex sample we analyzed is nearly\nidentical to one seen in an older Derusbi sample (MD5:\n24E9870973CEA42E6FAF705B14208E52) to the point that both use the same device\ncontrol code for this action and receive an IOCTL input of the same size. That said, it is\nworth noting that while Derusbi used a hardcoded range of 1025 to 1777 for the targeted\nports to hide, Demodex allows for an arbitrary range that can be configured by the attackers\nthrough the user mode malware.\n\n\n-----\n\n_Comparison of a similar IOCTL in the Demodex and Derusbi rootkits_\n\nIt is worth noting that in one of the victim systems we observed two instances of malicious\nsamples being dropped via a web shell. One led to the initiation of an infection chain\nconsisting of the first stage PowerShell dropper and second stage .NET service DLL, and\nanother was a drop of two binaries5 of the Netbot malware, formerly seen being used6 by the\nLucky Mouse group. Though we cannot attest to the fact that the very same web shell was\n\n\n-----\n\nused to drop both files, the proximity of events which occurred in the course of two days,\nmay suggest that underlying actor indeed deployed both samples and that it has a possible\nconnection to the Lucky Mouse group, whether through shared development resources or\nreused tools.\n\n## Conclusions\n\nGhostEmperor is an example of an advanced threat actor that goes after prominent targets\nand aims to maintain a long standing and persistent operation within their environments. We\nobserved that the underlying actor managed to remain under the radar for months, all the\nwhile demonstrating a finesse when it came to developing the malicious toolkit, a profound\nunderstanding of an investigator’s mindset and the ability to counter forensic analysis in\nvarious ways.\n\nAdditionally, while rootkits are generally considered a deprecated method of attack, this case\n[and other recent ones show that with a creative approach they can still be leveraged to gain](https://securelist.com/operation-tunnelsnake-and-moriya-rootkit/101831/)\na considerable level of stealth. As we have seen, the attackers conducted the required level\nof research to make the Demodex rootkit fully functional on Windows 10, allowing it to load\nthrough documented features of a third-party signed and benign driver. This suggests that\nrootkits still need to be taken into account as a TTP during investigations and that advanced\nthreat actors, such as the one behind GhostEmperor, are willing to continue making use of\nthem in future campaigns.\n\n## Indicators of compromise\n\n### Stage 1 – PowerShell Dropper\n\n012862165EC105A44FEA14FACE53492F – u_ex200822.ps1\n\n### Stage 2 – Service DLL\n\n6A44FDD66AB841C33949620666CA847A – RAudioUniConfig.dll\n\n2DD0885F84B890883A396030DB841D28\n\n1BC301AA9B861F762CE5F376228E992A – svchosts.exe\n\n### Stage 4\n\n0BBFBA106FBB9E310330DC87C32CB6D1 – Payload DLL\n\n6685323C61D8EDB4A6E35796AF34D626 – Remote Desktop Control DLL\n\n### Post-exploitation\n\nBE38D173E4E9118BDC2E83FD5F90BE3B – kekeo.exe\n\nF078AC9B012C503D35254AF9629D3B67 – debugall vbs\n\n\n-----\n\n### Driver\n\n7394229455151a9cd036383027a1536b\n\n### File paths\n\nC:\\Windows\\debug\\wia\n\n### PDB paths\n\nC:\\c\\getpwd\\x64\\Release\\getpwd.pdb\n\nD:\\Source\\workspace\\ExCtrl\\XControl\\Release\\XCLoader.pdb\n\n### Service name and DLL path\n\nMsMp4Hw – C:\\Windows\\System32\\msmp4dec.dll\n\nMsdecode – C:\\ProgramData\\Microsoft\\Network\\Connections\\msdecode.dll\n\nAuthSvc – C:\\Windows\\System32\\AuthSvc.dll\n\n### Registry keys for encrypted buffer\n\nHKLM\\Software\\Microsoft\\hiaudio\n\nHKLM\\Software\\Microsoft\\midihelp\n\nHKLM\\Software\\Microsoft\\data\n\nHKLM\\Software\\Microsoft\\update\n\n### Domains and IPs\n\nimap.newlylab[.]com\n\nmail.reclubpress[.]com\n\nimap.webdignusdata[.]com\n\nfreedecrease[.]com\n\naftercould[.]com\n\ndatacentreonline[.]com\n\ngame.newfreepre[.]com\n\n27.102.113[.]57\n\n27.102.113[.]240\n\n27.102.114[.]55\n\n27.102.115[.]51\n\n27.102.129[.]120\n\n107.148.165[.]158\n\n154.223.135[.]214\n\n1 This approach is well documented and demonstrated in the DSEFix public repository:\n\nhttps://github.com/hfiref0x/DSEFix\n\n\n-----\n\n[The source code of the driver can be found on GitHub.](https://github.com/cheat-engine/cheat-engine/blob/master/DBKKernel/IOPLDispatcher.c)\n\n3 They are outlined in the IOPLDispatcher.c source code within the Cheat Engines repository.\n\n\n4 A technique similar to the one observed in the Demodex rootkit is outlined in this code:\n\nhttps://github.com/bowlofstew/rootkit.com/blob/master/cardmagic/PortHidDemo_Vista.c\n\n5 Those binaries had the MD5s: 145FF08E736693D522F8A09C8D3405D6,\n\n7A162C26D56B0C55E6CD81CD953F510B\n\n\n6 [https://securelist.com/ksb-2019-review-of-the-year/95394/, detailed analysis of the Netbot](https://securelist.com/ksb-2019-review-of-the-year/95394/)\n\nmalware as part of Lucky Mouse campaigns is available to customers of our APT reporting\nservice.\n\n[APT](https://securelist.com/tag/apt/)\n[Drivers](https://securelist.com/tag/drivers/)\n[Dropper](https://securelist.com/tag/dropper/)\n[Malware Descriptions](https://securelist.com/tag/malware-descriptions/)\n[Malware Technologies](https://securelist.com/tag/malware-technologies/)\n[Microsoft](https://securelist.com/tag/microsoft/)\n[Rootkits](https://securelist.com/tag/rootkits/)\n[Targeted attacks](https://securelist.com/tag/targeted-attacks/)\n[Vulnerabilities](https://securelist.com/tag/vulnerabilities/)\n\nAuthors\n\n[Mark Lechtik](https://securelist.com/author/marklechtik/)\n\nAseel Kayal\n\n[Paul Rascagneres](https://securelist.com/author/paulrascagneres/)\n\n[Vasily Berdnikov](https://securelist.com/author/vasilyberdnikov/)\n\nGhostEmperor: From ProxyLogon to kernel mode\n\n\n-----\n\nYour email address will not be published. Required fields are marked\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-30 - GhostEmperor- From ProxyLogon to kernel mode.pdf"
    ],
    "report_names": [
        "2021-09-30 - GhostEmperor- From ProxyLogon to kernel mode.pdf"
    ],
    "threat_actors": [
        {
            "id": "7c390b96-8206-4194-81d8-ebbabb9910ff",
            "created_at": "2023-12-03T02:00:05.147496Z",
            "updated_at": "2025-03-27T02:00:03.259538Z",
            "deleted_at": null,
            "main_name": "TunnelSnake",
            "aliases": [],
            "source_name": "MISPGALAXY:TunnelSnake",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "4b48e4b6-09b0-4f4d-a78c-6b455d122e67",
            "created_at": "2022-10-25T16:07:24.020115Z",
            "updated_at": "2025-03-27T02:02:10.08247Z",
            "deleted_at": null,
            "main_name": "Operation TunnelSnake",
            "aliases": [],
            "source_name": "ETDA:Operation TunnelSnake",
            "tools": [
                "Moriya"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f0eca237-f191-448f-87d1-5d6b3651cbff",
            "created_at": "2024-02-06T02:00:04.140087Z",
            "updated_at": "2025-03-27T02:00:03.323578Z",
            "deleted_at": null,
            "main_name": "GhostEmperor",
            "aliases": [
                "FamousSparrow",
                "UNC2286",
                "Salt Typhoon",
                "RedMike"
            ],
            "source_name": "MISPGALAXY:GhostEmperor",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e3492534-85a6-4c87-a754-5ae4a56d7c8c",
            "created_at": "2022-10-25T15:50:23.819113Z",
            "updated_at": "2025-03-27T02:00:55.552554Z",
            "deleted_at": null,
            "main_name": "Threat Group-3390",
            "aliases": [
                "Threat Group-3390",
                "Earth Smilodon",
                "TG-3390",
                "Emissary Panda",
                "BRONZE UNION",
                "APT27",
                "Iron Tiger",
                "LuckyMouse"
            ],
            "source_name": "MITRE:Threat Group-3390",
            "tools": [
                "Systeminfo",
                "gsecdump",
                "PlugX",
                "ASPXSpy",
                "Cobalt Strike",
                "Mimikatz",
                "Impacket",
                "gh0st RAT",
                "certutil",
                "China Chopper",
                "HTTPBrowser",
                "Tasklist",
                "netstat",
                "SysUpdate",
                "HyperBro",
                "ZxShell",
                "RCSession",
                "ipconfig",
                "Clambling",
                "pwdump",
                "NBTscan",
                "Pandora",
                "Windows Credential Editor"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2c980ea7-04c4-4193-8535-52f87e66a96e",
            "created_at": "2024-05-01T02:03:07.994126Z",
            "updated_at": "2025-03-27T02:05:17.293799Z",
            "deleted_at": null,
            "main_name": "BRONZE UNION",
            "aliases": [
                "Budworm ",
                "Emissary Panda ",
                "Iron Tiger ",
                "Lucky Mouse ",
                "TG-3390 ",
                "Temp.Hippo ",
                "APT27 "
            ],
            "source_name": "Secureworks:BRONZE UNION",
            "tools": [
                " ASPXSpy",
                " China Chopper",
                " Enfal",
                " Gh0st RAT",
                " HttpBrowser",
                " Hunter",
                " HyperBro",
                " OwaAuth",
                " PlugX",
                " PoisonIvy",
                " Sysupdate",
                " ZxShell",
                "9002"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "c63ab035-f9f2-4723-959b-97a7b98b5942",
            "created_at": "2023-01-06T13:46:38.298354Z",
            "updated_at": "2025-03-27T02:00:02.798255Z",
            "deleted_at": null,
            "main_name": "APT27",
            "aliases": [
                "TG-3390",
                "EMISSARY PANDA",
                "TEMP.Hippo",
                "Budworm",
                "Group 35",
                "BRONZE UNION",
                "Lucky Mouse",
                "Iron Taurus",
                "GreedyTaotie",
                "Red Phoenix",
                "ZipToken",
                "Iron Tiger",
                "G0027",
                "Earth Smilodon"
            ],
            "source_name": "MISPGALAXY:APT27",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5c13338b-eaed-429a-9437-f5015aa98276",
            "created_at": "2022-10-25T16:07:23.582715Z",
            "updated_at": "2025-03-27T02:02:09.875151Z",
            "deleted_at": null,
            "main_name": "Emissary Panda",
            "aliases": [
                "APT 27",
                "ATK 15",
                "Bronze Union",
                "Budworm",
                "Earth Smilodon",
                "Emissary Panda",
                "Group 35",
                "Iron Taurus",
                "Iron Tiger",
                "LuckyMouse",
                "Operation DRBControl",
                "Operation Iron Tiger",
                "Operation PZChao",
                "Operation SpoiledLegacy",
                "Operation StealthyTrident",
                "Red Phoenix",
                "TEMP.Hippo",
                "TG-3390",
                "ZipToken"
            ],
            "source_name": "ETDA:Emissary Panda",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "Agent.dhwf",
                "AngryRebel",
                "Antak",
                "CHINACHOPPER",
                "China Chopper",
                "Destroy RAT",
                "DestroyRAT",
                "FOCUSFJORD",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HTTPBrowser",
                "HTran",
                "HUC Packet Transmit Tool",
                "HighShell",
                "HttpBrowser RAT",
                "HttpDump",
                "HyperBro",
                "HyperSSL",
                "HyperShell",
                "Kaba",
                "Korplug",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "Moudour",
                "Mydoor",
                "Nishang",
                "OwaAuth",
                "PCRat",
                "PlugX",
                "ProcDump",
                "PsExec",
                "RedDelta",
                "SEASHARPEE",
                "Sensocode",
                "SinoChopper",
                "Sogu",
                "SysUpdate",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Token Control",
                "TokenControl",
                "TwoFace",
                "WCE",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Xamtrav",
                "ZXShell",
                "gsecdump",
                "luckyowa"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d390d62a-6e11-46e5-a16f-a88898a8e6ff",
            "created_at": "2024-12-28T02:01:54.899899Z",
            "updated_at": "2025-03-27T02:02:10.122415Z",
            "deleted_at": null,
            "main_name": "Salt Typhoon",
            "aliases": [
                "Earth Estries",
                "FamousSparrow",
                "GhostEmperor",
                "RedMike",
                "Salt Typhoon",
                "UNC2286"
            ],
            "source_name": "ETDA:Salt Typhoon",
            "tools": [
                "Agentemis",
                "Backdr-NQ",
                "Cobalt Strike",
                "CobaltStrike",
                "Crowdoor",
                "Cryptmerlin",
                "Deed RAT",
                "Demodex",
                "FamousSparrow",
                "FuxosDoor",
                "GHOSTSPIDER",
                "HemiGate",
                "MASOL RAT",
                "Mimikatz",
                "NBTscan",
                "NinjaCopy",
                "ProcDump",
                "PsExec",
                "PsList",
                "SnappyBee",
                "SparrowDoor",
                "TrillClient",
                "WinRAR",
                "Zingdoor",
                "certutil",
                "certutil.exe",
                "cobeacon",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536152,
    "ts_updated_at": 1743041769,
    "ts_creation_date": 1653714765,
    "ts_modification_date": 1653714765,
    "files": {
        "pdf": "https://archive.orkl.eu/6c217f11d36ed7d3f7972a8349ac1f2a7ec3fbba.pdf",
        "text": "https://archive.orkl.eu/6c217f11d36ed7d3f7972a8349ac1f2a7ec3fbba.txt",
        "img": "https://archive.orkl.eu/6c217f11d36ed7d3f7972a8349ac1f2a7ec3fbba.jpg"
    }
}