{
    "id": "558edbe8-b78a-47b3-9c79-1f4f6b2f5c38",
    "created_at": "2023-01-12T15:08:23.884224Z",
    "updated_at": "2025-03-27T02:05:20.400531Z",
    "deleted_at": null,
    "sha1_hash": "d48e9835e8bdc94196e0471af1c63c3a52793fb4",
    "title": "2019-02-25 - How To- Analyzing a Malicious Hangul Word Processor Document from a DPRK Threat Actor Group",
    "authors": "",
    "file_creation_date": "2022-05-28T17:32:41Z",
    "file_modification_date": "2022-05-28T17:32:41Z",
    "file_size": 1470261,
    "plain_text": "# How To: Analyzing a Malicious Hangul Word Processor Document from a DPRK Threat Actor Group\n\n**[norfolkinfosec.com/how-to-analyzing-a-malicious-hangul-word-processor-document-from-a-dprk-threat-actor-group/](https://norfolkinfosec.com/how-to-analyzing-a-malicious-hangul-word-processor-document-from-a-dprk-threat-actor-group/)**\n\nnorfolk February 25, 2019\n\nA few days ago, [ESTsecurity published a post detailing a newly identified malicious Hangul](https://blog.alyac.co.kr/2140)\nWord Processor (HWP) document that shared technical characteristics with previously\nreported malicious activity attributed to North Korean threat actors (an important note: this\nparticular group is not typically associated with or clustered with the SWIFT/ATM adversary\ndetailed in other posts on this blog, although this blog avoids using specific vendor naming\nclassifications where possible).\n\nThe Hangul Office suite is widely used in South Korea; in the West, it’s significantly less\ncommon. As a result of this, there is limited public documentation regarding how to analyze\nexploit-laden HWP documents. This blog post is intended to provide additional\ndocumentation from start to finish of the file identified by ESTsecurity. As such, the language\nused will be somewhat less formal than the content typically posted here.\n\nThe following tools (in a VM) are recommended for analysis:\n\n1) [Cerbero Profiler (advanced or standard)](https://cerbero.io/profiler/)\n\n2) Process Hacker\n\n3) [Ghostscript](https://www.ghostscript.com/)\n\n4) Any debugger (I prefer the x96 suite)\n\n5) [jmp2it](https://github.com/adamkramer/jmp2it/releases)\n5) Hangul Office (optional) + a listener (e.g. FakeNet, Inetsim)\n\n6) [scdbg (optional)](http://sandsprite.com/blogs/index.php?uid=7&pid=152)\n\nI purchased my copy of Hangul Office on Amazon a while back. The English language\nversion is typically vulnerable to the same exploits. Cerbero Profiler has a trial version that\nwill work for this analysis (though it’s a great tool and deserves a purchase).\n\nAs a final note before analysis, two previous posts from other researchers deserve\n[recognition: Jacob Soo’s post pointed me towards Cerbero Profiler (and discusses some](http://www.vxsecurity.sg/2016/11/22/technical-teardown-exploit-malware-in-hwp-files/)\n[important HWP characteristics), and a post from Wayne Low at Fortinet has some great](https://www.fortinet.com/blog/threat-research/debugging-postscript-with-ghostscript.html)\nintroductory material for debugging Encapsulated PostScript (EPS).\n**Step 1: Triage and Analysis of the Document**\n\nMD5: f2e936ff1977d123809d167a2a51cdeb\n\nSHA1: 7a86e6bffba91997553ac4cf0baec407bc255212\n\nSHA256: 5d9e5c7b1b71af3c5f058f8521d383dbee88c99ebe8d509ebc8aeb52d4b6267b\n\n\n-----\n\nA copy of Hangul Word Processor isn t strictly necessary to analyze the file in question. If we\ndo have a copy and use it to open the document, we’ll notice two key events: the document\nwill spawn a copy of Internet Explorer, and the analysis environment will make a network call\nto a compromised Korean website. This information is useful later on, as it gives some basic\nguidelines for what to expect when analyzing the document’s payload.\n\nOpening the file in Cerbero Profiler will show several of the document’s different streams and\nobjects. For malicious HWP files (including the one discussed in Jacob Soo’s 2016 post\nnoted above), there will be malicious JavaScript present. In this case, we’re instead\ninterested in the contents of one of the streams, BIN0003.eps. The contents in these streams\nare usually zlib compressed, and Cerbero Profiler can apply filters to them to decompress\nthem:\n\nIn the “Format” tab, select all of the content of the stream, right click, and hit “filter.”\n\n\n-----\n\nScroll down to the “unpack” category and select “zlib.” Check the box for “raw” and click\n“add.” Then click “Preview” in the bottom right, select all, and copy the “Ascii” contents.\nThe above images detail the steps for copying and decompressing the contents of the EPS\nstream. Pasting these into a file will reveal a relatively simple EPS script.\n\n**Step 2: Analyzing the EPS script**\n\nPostScript is a stack-based programming language first conceived by Adobe in the 1980s.\n[The documentation for the language is nearly a thousand pages long. I do not recommend](https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/psrefman.pdf)\nreading it. Encapsulated PostScript [is a fork of this, with restrictions. The documentation for](https://blog.trendmicro.com/trendlabs-security-intelligence/hangul-word-processor-postscript-abused-malicious-attachments/)\nthis is [significantly shorter, but still probably not necessary. I would stick with](https://www-cdf.fnal.gov/offline/PostScript/5002.PDF) Fortinet’s\noverview.\n\nThe key concept for an EPS file is that each command is added to the top of a (clearable)\n“stack” in the order that it’s typed. Below is the EPS script we copied from Cerbero (pasted\ninto any text editor):\n\nThe decompressed EPS script\nEven without truly understanding the EPS language, we can infer what’s likely happening\nhere. At the top, a (truncated) set of hexadecimal bytes are added to the stack. A series of\nvariables are defined, a transformation is applied to the bytes, and (presumably) the “exec”\nfunction is applied to the results of this transformation. Even though we might not know\n\n\n-----\n\nprecisely how to interpret this transformation, we can assume that there is a second layer to\nthis script. In other programming languages, we might tell the script to Alert, MsgBox, or Print\nthe executed value (instead of executing this value), and EPS is no exception. Substitute the\n“exec” commands with a single print:\n\nReplace “exec exec” with “print”\n\n[We also need something to actually run the EPS file. Ghostscript supports EPS execution](https://www.ghostscript.com/download/gsdnld.html)\nand is a relatively quick install. Ghostscript comes with a GUI/Shell version and a commandline version. For this, we need to use the command-line version, as the shell won’t render all\nof the data that gets printed and thus we won’t be able to copy and paste it. Open up a\ncommand line prompt and copy the syntax below (noting the inverted slashes on a Windows\nsystem and the parenthesis- these were derived from test dragging files into the Shell\nversion to determine the proper syntax).\n\nExecuting an EPS file with Ghostscript\n\nHit enter, and it will print the contents. From there, copy and paste the content of the console\ninto a new text file:\n\n\n-----\n\nPrinted second-layer EPS script. The boxed brackets represent the boundaries of the hex\narray to be copied into a file for analysis.\nAt this stage, we can infer that we likely have executable shellcode: the beginning of the\nlarge byte array begins with a 0x90 “nop sled.” Copy just the hex array as bytes into a hex\neditor (such as HxD) and save the file. We can move on to the next analysis step.\n\n**Step 3: Analyzing Shellcode**\n\nThe dumped bytes don’t represent a compiled program; rather, they are raw instructions of\nexecutable code. There are two great tools that can help triage and analyze this code:\n\n1) scdbg- Emulates the shellcode and highlights key API calls\n2) jmp2it- Executes shellcode in an attachable, debuggable program\n\n\n-----\n\nBy performing a quick triage with scdbg, we can get a bit of a head start on the shellcode\nthat we’re about to examine (note: I had initially redacted the username in some images):\n\nWe can see a handful of API calls, including one that resolves the folder path for the\nProgram Files directory. However, our initial execution of the HWP document indicated that\nthe sample would launch Internet Explorer and issue a network callout. The API calls above\nare insufficient to perform those two tasks; hence, we need to debug the shellcode to\ndetermine what’s “missing” and why that might be.\n\nThe jmp2it tool will execute shellcode beginning at a specified offset (in this case, 0x00 will\nwork as that’s the start of the “noop sled”) and can pause it in an infinite loop while we attach\na debugger. It provides additional instructions for patching this loop and jumping in to the\nnext function.\n\nDebugging the shellcode itself requires a bit of practice. In this sample, immediately after the\nnoop sled, the first routine begins decoding additional code (and thus, modified the code):\n\nThe “analyze” button (both before and after any routines that change the code) will help\nhighlight specific functions.\n\n\n-----\n\nAs the code is relatively small, single-stepping through is not as daunting as it might be for a\nlarger sample (though, stepping out of loops that you already understand will certainly save\ntime). One of our questions from the triage was identifying additional API calls and next-step\nfunctionality. For the former, look for (and comment/label) functions that are repeated often:\n\nThe boxed routine on the left returns an API to the EAX register.\nUltimately, this shellcode stage will take several actions: it will attempt to open a (nonexistent) “thumbs.db” file (not pictured), and it will launch a suspended copy of Internet\nExplorer, inject additional code into its memory (using more resolved API calls) and then\ncreate a remote thread in that process to execute this code:\n\n\n-----\n\nWriting code to, and creating a remote thread in, the Internet Explorer process\n\n\n-----\n\nWe do not want to step into or over the CreateRemoteThread call. Instead, we want to dump\nthe executable section of code from the suspended Internet Explorer instance, and repeat\nthe debugging steps.\n\nIdentifying an additional set of injected code\nRunning this code through scdbg suggests that we’re nearing the end:\n\n\n-----\n\nNow we see our network traffic endpoint (a compromised website) and a series of API calls\ndirectly related to communicating with that location. Debugging this second set of shellcode\n(with the help of jmp2it) will show a similar pattern: an initial decoding routine, following by\nthe resolution of the API calls needed to carry out the next task:\n\nAnd finally, these are used to communicate with the endpoint:\n\nUnfortunately, this is where our analysis ends without running the sample and capturing a\nPCAP (or pulling one down from a sandbox). The next call is for the code to read the\nresponse from the server and execute it; presumably, this is an additional layer of shellcode\n(perhaps containing an embedded payload). Without that code, we can’t say for sure what\nthe payload might be; however, some quick pivoting on our initial code can help us make an\neducated assessment:\n\n\n-----\n\nIt would appear that “our” sample has a code overlap with a previously submitted sample,\n[and this sample communicates with a C2 previously highlighted in a Cisco Talos report.* In](https://blog.talosintelligence.com/2018/05/navrat.html)\nthat report, Cisco noted (and documented) a final payload classified as “NavRAT” delivered\nusing a very similar mechanism and containing the same file name from the ESTsecurity\nreport. If we were making an assessment, our best guess would be that we would expect the\nsame (or similar) payload here.\n\n- Most likely, somebody took the older shellcode, converted it into an executable for analysis,\nand uploaded to VirusTotal.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-02-25 - How To- Analyzing a Malicious Hangul Word Processor Document from a DPRK Threat Actor Group.pdf"
    ],
    "report_names": [
        "2019-02-25 - How To- Analyzing a Malicious Hangul Word Processor Document from a DPRK Threat Actor Group.pdf"
    ],
    "threat_actors": [
        {
            "id": "99cb4e5b-8071-4f9e-aa1d-45bfbb6197e3",
            "created_at": "2023-01-06T13:46:38.860754Z",
            "updated_at": "2025-03-27T02:00:02.937438Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "SectorJ04 Group",
                "Dudear",
                "G0092",
                "ATK103",
                "Hive0065",
                "Spandex Tempest",
                "GRACEFUL SPIDER",
                "GOLD TAHOE",
                "CHIMBORAZO",
                "SectorJ04"
            ],
            "source_name": "MISPGALAXY:TA505",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75d4d6a9-b5d1-4087-a7a0-e4a9587c45f4",
            "created_at": "2022-10-25T15:50:23.5188Z",
            "updated_at": "2025-03-27T02:00:55.489882Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "TA505",
                "Hive0065",
                "Spandex Tempest",
                "CHIMBORAZO"
            ],
            "source_name": "MITRE:TA505",
            "tools": [
                "AdFind",
                "Azorult",
                "FlawedAmmyy",
                "Mimikatz",
                "Dridex",
                "TrickBot",
                "Get2",
                "FlawedGrace",
                "Cobalt Strike",
                "ServHelper",
                "Amadey",
                "SDBbot",
                "PowerSploit"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e447d393-c259-46e2-9932-19be2ba67149",
            "created_at": "2022-10-25T16:07:24.28282Z",
            "updated_at": "2025-03-27T02:02:10.159466Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "ATK 103",
                "Chimborazo",
                "Gold Evergreen",
                "Gold Tahoe",
                "Graceful Spider",
                "Hive0065",
                "Operation Tovar",
                "Operation Trident Breach",
                "SectorJ04",
                "Spandex Tempest",
                "TA505",
                "TEMP.Warlock"
            ],
            "source_name": "ETDA:TA505",
            "tools": [
                "Amadey",
                "AmmyyRAT",
                "AndroMut",
                "Azer",
                "Bart",
                "Bugat v5",
                "CryptFile2",
                "CryptoLocker",
                "CryptoMix",
                "CryptoShield",
                "Dridex",
                "Dudear",
                "EmailStealer",
                "FRIENDSPEAK",
                "Fake Globe",
                "Fareit",
                "FlawedAmmyy",
                "FlawedGrace",
                "FlowerPippi",
                "GOZ",
                "GameOver Zeus",
                "GazGolder",
                "Gelup",
                "Get2",
                "GetandGo",
                "GlobeImposter",
                "Gorhax",
                "GraceWire",
                "Gussdoor",
                "Jaff",
                "Kasidet",
                "Kegotip",
                "Kneber",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Locky",
                "MINEBRIDGE",
                "MINEBRIDGE RAT",
                "MirrorBlast",
                "Neutrino Bot",
                "Neutrino Exploit Kit",
                "P2P Zeus",
                "Peer-to-Peer Zeus",
                "Philadelphia",
                "Philadephia Ransom",
                "Pony Loader",
                "Rakhni",
                "ReflectiveGnome",
                "Remote Manipulator System",
                "RockLoader",
                "RuRAT",
                "SDBbot",
                "ServHelper",
                "Shifu",
                "Siplog",
                "TeslaGun",
                "TiniMet",
                "TinyMet",
                "Trojan.Zbot",
                "Wsnpoem",
                "Zbot",
                "Zeta",
                "ZeuS",
                "Zeus"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536103,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1653759161,
    "ts_modification_date": 1653759161,
    "files": {
        "pdf": "https://archive.orkl.eu/d48e9835e8bdc94196e0471af1c63c3a52793fb4.pdf",
        "text": "https://archive.orkl.eu/d48e9835e8bdc94196e0471af1c63c3a52793fb4.txt",
        "img": "https://archive.orkl.eu/d48e9835e8bdc94196e0471af1c63c3a52793fb4.jpg"
    }
}