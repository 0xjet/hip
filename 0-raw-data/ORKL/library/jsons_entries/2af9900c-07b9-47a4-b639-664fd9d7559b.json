{
    "id": "2af9900c-07b9-47a4-b639-664fd9d7559b",
    "created_at": "2023-01-12T14:59:15.161084Z",
    "updated_at": "2025-03-27T02:09:29.621613Z",
    "deleted_at": null,
    "sha1_hash": "761ea36ac0b0ecf3102484f41fb9cdce02b892d1",
    "title": "2021-03-17 - Hidden menace- Peeling back the secrets of OnionCrypter",
    "authors": "",
    "file_creation_date": "2022-05-28T03:41:38Z",
    "file_modification_date": "2022-05-28T03:41:38Z",
    "file_size": 2249998,
    "plain_text": "# Hidden menace: Peeling back the secrets of OnionCrypter\n\n**decoded.avast.io/jakubkaloc/onion-crypter/**\n\nby [Jakub KaločMarch 17, 202120 min read](https://decoded.avast.io/author/jakubkaloc/)\n\n\nMarch 17, 2021\n\n\nOne of the goals of malware authors is to keep their creation undetected by antivirus\nsoftware. One possible solution for this are crypters. A crypter encrypts a program, so it\nlooks like meaningless data and it creates an envelope for this encrypted program also\ncalled a stub. This stub looks like an innocent program, it may also perform some tasks\nwhich are not harmful at all but its primary task is to decrypt a payload and run it.\n\n## Why is this one intriguing?\n\nThe crypter discussed in this blogpost uses a combination of multiple interesting techniques\nthat make it hard for analysts and for proper detection. One of the key techniques this\ncrypter uses is multiple layers of encryption. Because of this we are calling it\n“OnionCrypter”. It’s important to note the name reflects the many layers this crypter uses,\nit’s in no way related to the TOR browser or network.\n\nThis blogpost covers most of the techniques OnionCrypter used to complicate analysis and\nbreaks down its structure. This can help malware analysts because seeing samples like\nthese might get confusing and overwhelming at first not only for humans but also for\n\n\n-----\n\ndynamic analysis sandboxes.\n\nMost interestingly, we have found that OnionCrypter has been used by over 30 different\nmalware families since 2016. This includes some of the best known-most prevalent families\nsuch as Ursnif, Lokibot, Zeus, AgentTesla, and Smokeloader among others. In the last three\nyears we have protected almost 400,000 users around the world from malware protected by\nthis crypter. Its widespread use and length of time in use make it a key malware\ninfrastructure component. We believe that likely the authors of OnionCrypter offer it as an\nencrypting service. Based on the uniqueness of the first layer it is also safe to assume that\nauthors of OnionCrypter offer the option of a unique stub file to ensure that encrypted\nmalware will be undetectable. A service like this is frequently advertised as a FUD (fully\nundetectable) crypter.\n\n\n-----\n\nOnionCrypter forms a malware family on its own, even though it is used to protect malware\nfrom many different families. OnionCrypter has been around for several years so it is not\nsomething entirely new, however it is interesting that because of the multiple layers and\nuniqueness of the first layer, nobody was detecting this crypter as one malware family. After\ndownloading thousands of samples of this crypter from VirusTotal, we were able to confirm\nthat most of the detections from all AVs are based on detecting what’s encrypted inside this\ncrypter. Even when AVs are recognizing the samples as a crypter with some other malware\npacked inside, they are detecting the samples as tens of different malware families.\n\n## Statistics\n\nWith the data from more than 15,000 samples (where oldest samples date back to 2016) it\nwas possible to create a statistic on malware families which are using this crypter. The chart\nbelow shows that OnionCrypter is used by multiple malware authors.\n\nOccurrence of malware families in samples\nWith the same data it was possible to create graphical insight on prevalence of the crypter\nduring its existence.\n\nPrevalence of the OnionCrypter\nThis data can be further interpreted. The peaks suggest that in that time period there could\nhave emerged a new malware campaign which was using services of the OnionCrypter and\nwas spreading widely through the world. After a closer look at the highest peak and\nidentification of malware families inside the OnionCrypter encrypted samples, it was\n[possible to confirm that this peak corresponds to the spread of BetaBot malware family, a](https://www.securityweek.com/multi-layered-infection-attack-installs-betabot-malware)\nfamily that spreads ransomware and other malware, during the summer of 2019.\n\n\n-----\n\nBetaBot campaign using the OnionCrypter during the summer of 2019\n\n## Analysis\n\nOnionCrypter is 32-bit software written in C++. Architecture of OnionCrypter consists of\nthree layers. Each layer will be discussed in a separate section along with techniques which\ncan be found there.\n\n\n-----\n\nOnionCrypter Program structure\n\n## Layer 1\n\nThis is the outer layer of OnionCrypter. Even though the first layer includes usually at least\na few hundred functions, there is always one long function (let’s call it main function) with a\nlot of junk code but it also includes following functionalities which are important parts of\nOnionCrypter:\n\nCreation of a named event object\nAllocation of a memory\nLoad data to memory\nDecrypt of the loaded data\nPass execution to decrypted data\n\nThe easiest way to find this function is to check cross references to the `CreateEventA`\nAPI function.\n\n### Uniqueness\n\nAfter finding this main function in multiple samples there is the first obstacle – uniqueness.\nEach one of the analyzed samples had a unique main function. Differences vary between\nbig ones like completely different API function calls in the junk part of code or small ones\nlike those that use different registers and local variables in a cycle which seem the same.\nAs a consequence, creation of static rules for detection gets quite complicated if someone\nwants to cover the majority of samples.\n\n\n-----\n\nAfter seeing some samples it is possible to quite easily estimate which function is the main\nfunction. The main function is always quite long, because of junk code and often because of\nloop unrolling. It may happen that memory allocation or decryption happens in a small part\nof code between unrolled iterations of loops full of junk code.\n\nOverview of main function in IDA Pro\n\nFrom left to right\n\n260003293D1785571FEF5A2CF54E89B7AF0C1FBD5B970D2285F21BFC65E2981C\n\n05AAB2F7D5D432CBEB970BC5471B3FAE1E45F23E0933CC673BE923F7609F53AE\n\n17C2E36EE4387365AC00A84E91B59CE4D31D3BA04624902512810B7797A2356B\n\n81C479BF71196724055F1AF30CA05C9162B7D32E7B3363B7F93D1AAF0161E760\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nIn many cases one or more sleep calls ( sleep function from `synchapi.h ) are included`\nin the junk code. These sleep calls along with loops that have many iterations can increase\nexecution time by a few minutes. This can cause some simple dynamic analysis sandboxes\nto fail. Even when a sandbox is able to detect the final payload and scan it with Yara rules, it\nis often necessary to increase timeouts to 3 or more minutes.\n\n\n-----\n\nExample\n\nof junk code in IDA Pro\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\n\n\n-----\n\n### UPX impostors\n\nOne of the most common packers is the UPX packer which can compress programs and\nalso hide their original code. A few samples have the first layer modified to look like they are\nUPX packed even when they are not. At the first glance it is possible to see that the sample\nhas sections exactly like UPX, even when you analyze the sample with tools like “Detect It\nEasy”, the tool will incorrectly tell you that the sample is UPX packed.\n\nThis can lead to the confusion of an inexperienced analyst, but what is even worse it can\nconfuse analytical tools. There are multiple tools for automatic and static unpack of UPX\npacked programs and for extraction of original code for further analysis. When a tool like\nthis unpacks an UPX impostor sample the result will be random corrupted data. On data like\nthis any static detection will not be possible and a corrupted sample won’t run in dynamic\nanalytical boxes.\n\n### Exceptions\n\nThe majority of samples raise exceptions during debugging. In most cases it happens at the\nbeginning of the main function. Dealing with these exceptions can slow down manual\nanalysis and definitely make dynamic analysis more difficult. It’s a good idea to identify the\nplace where exceptions are raised, because even if some samples are throwing only a few\nexceptions, others do it in a loop and passing them one by one may be too time consuming.\n\nThe most common exceptions which could appear are:\n\nMicrosoft C++ exception with code `0xE06D7363`\n\nThis exception is usually thrown by some exotic functions used in junk code.\nSome of the functions causing this exception are:\n```\n         SCardEstablishContext\n         SCardConnectA\n         SCardTransmit\n\n```\nInstruction referenced memory at `XYZ . Memory could not be read. Exception code`\n```\n   0xC0000005\n\n```\nUnknown exception code `0x6EF`\n\nFrom function `GetServiceDisplayNameA`\n\nWe have also found that OnionCrypter combines functions that throw exceptions with the\ndata about the position of the mouse cursor. OnionCrypter uses a loop where it finds out the\ncursor position (X and Y coordinates) using the function `GetCursorPos and compares it`\nwith the position values from the previous iteration of the loop. If the X or Y coordinate didn’t\nchange, the program calls more functions that throw the exceptions, waits for a few\nseconds and starts the next iteration of the loop. It is expected from a normal user that he\nwill move his mouse during this timeframe, but it is not expected from a sandbox or analyst\n\n\n-----\n\nwho is pressing the `F9 key repeatedly to pass the throwing exception part of the program.`\nBecause of that we believe that throwing the exceptions is an anti-debug trick to make the\nmanual work of analysts harder.\n\n### Named event object\n\nOnionCrypter uses named event objects, which are hardcoded into the code and created in\nthe main function to avoid multiple executions of the payload. This feature is important for\nthe malware hidden inside, because many times can multiple simultaneous executions of\nparticular malware on one device cause some unexpected or unwanted behavior (e.g. there\nis no need to run the same ransomware twice on one device). After deeper analysis it was\npossible to connect multiple event objects to this particular software.\n\nCreation of named event object\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nTo facilitate extraction of new names of the event object and to automate processing, an\nIDAPython script was created. Among most common names of event objects are:\n\nmilsin\nsvet\nlifecicled\nparames\ncueevn\nStrolls\nMenulapkievent\ndoroga\n\n### Allocation of memory\n\nAt some point during the execution of the main function OnionCrypter has to create the\nmemory space where it loads and decrypts data. Another aspect of uniqueness is\ndemonstrated here. For allocation OnionCrypter uses one of the following functions:\n\n1. `GlobalAlloc`\n2. `VirtualAlloc`\n3. `HeapAlloc`\n\n\n-----\n\nIn other malware families it is normal that samples of a crypter belonging to the same family\nuse the same memory allocation function across all samples. In this case there are three\ndifferent functions. This complicates analysis and it is another anti-analysis trick to hide the\npayload, because it is not enough to hook one function and monitor allocated memory in\norder to find the payload. What is even worse, hooking all these functions may be a very\nslow way to find allocated memory, because the important allocation happens in some part\nof the junk code. At the same time, during execution of the junk code, allocation functions\nmay be called many times to allocate insignificant memory. Especially when these functions\nare used in a loop, monitoring all allocated places will be overwhelming. One possible\nsolution to solve this is the knowledge that the allocated memory for the encrypted data has\nall three of the `read/write/execute flags set to` `true . With some cleverly placed`\nbreakpoints in main function and monitoring of memory segments it is possible to find a\nmoment when a segment with `read/write/execute flags was created.`\n\n### Decryption of the second layer\n\nAfter memory allocation, data is moved into created space and decrypted. Either a decrypt\nloop is implemented inline in the main function or a separate function is called. Finding the\ndecrypt loop is easy with an `R/W breakpoint for allocated memory. Even here every`\nsample is quite unique. Even though all samples read data byte by byte and xor it with\nanother value, implementation of the decrypt algorithm is totally different, as can be seen in\nthe images below.\n\n\n-----\n\nStructure of decrypt loop in IDA Pro\n\nleft – 75E692519607C2E58A3E4F5606D17262D4387D8EEA92FAB9C11C64C4A6035FBC\n\nright –\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nOn the left side the decrypt algorithm of layer 2 is implemented as a part of the main\nfunction. This algorithm is quite simple – it uses one byte as a key value and does XOR\noperation on all bytes of encrypted data. What is even more interesting, this algorithm is so\nnaive, that if the key was originally set to zero, layer 2 would not be (de/en)crypted at all.\n\nOn the other hand the decrypt algorithm on the right side is quite complicated. It is a\nstandalone function, which receives as parameters pointer to the encrypted data, length of\nthe encrypted data and key seed value. Decryption goes from the beginning of the\nencrypted data and it does XOR operation of key value and each encrypted byte. Unlike the\nprevious decrypt algorithm, this one is a stream cipher, which generates a key stream. Key\nstream consists of key values where a new key value is generated from a key value used in\nthe previous iteration.\n\n### Passing execution to the second layer\n\nEven here are some creative ways of how to start the execution of the decrypted code. The\nsimplest, which is also the most frequent one, is to load a pointer to the decrypted code into\nthe register and call it.\n\n\n-----\n\nThings can get more interesting when there is no call to a register. Some samples use\n“Enum” functions like `EnumSystemLanguageGroupsA to pass execution. Originally this`\nfunction enumerates the language groups that are either installed on or supported by an\noperating system, but one of the parameters of this function is a pointer to an applicationdefined callback function. This callback function should process the enumerated language\ngroup information provided by the `EnumSystemLanguageGroupsA function. Instead of`\nproviding a pointer to the callback function a pointer to the decrypted code is given as\nparameter and as a result decrypted code gets executed.\n\nPassing execution to second layer\n\n909A94BCB5C0354D85B8BDB64D4EE49093CCA070653F73B99C201136B72CB94A\nA similar technique is used with all kinds of “Enum” functions e.g. `CertEnumSystemStore`\nor `EnumDisplayMonitors . Because of the amount of these functions and possibility of`\ntheir legitimate use, it is not feasible to detect OnionCrypter by this technique.\n\nPassing execution to second layer no.2\n\n846DCC9BCDC5C6103B2979FF93F4E1789B63827413B2FE56B1362129DF069DAF\nList of functions known to be used by OnionCrypter:\n\n```\nacmFormatEnumA\n\n```\n\n-----\n\n```\nEnumSystemCodePagesW\n\n```\n\n## Layer 2\n\nLayer 2 is a shell code whose ultimate task is to decrypt another layer. This process is not\nstraightforward at all. The overview of what happens on layer 2 can be seen on image\nbelow, but the “Decrypt layer 3” bubble hides quite a complicated process of decryption.\nThe layer 3 is decrypted in parts, but the decryption happens on another sublayer of the\nlayer 2, in shell codes. As if it’s not enough, even these shell codes are decrypted in small\nparts and then put together to form a decrypt sequence.\n\nMain structure of layer 2\n\n\n-----\n\nshell code\n\n### Finding DLLs and functions\n\nAs a first thing, OnionCrypter loads pointers to `kernel32.dll . It uses` `TIB (Thread`\nInformation Block) to find the Process Information Block and there is a pointer to a structure\n( PEB_LDR_DATA ) that contains information about all of the loaded modules in the current\nprocess. By searching this structure, OnionCrypter finds the base address of\n```\nkernel32.dll .\n\n```\nLoading list of modules\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nWhen OnionCrypter has the base address of `kernell32.dll, it loads the address of the`\nExport Table, which is well known. Then OnionCrypter iterates through the Name Pointer\nTable containing names of DLL functions. OnionCrypter calculates the `CRC32 from every`\nfunction name and compares that number to one received as a hard-coded parameter.\nWhen there is a match, an iterator value is used to find the function’s ordinal number in the\nOrdinal Table. With this number it is possible to look up the function’s address in the Export\nAddress Table. Even if this method is known, OnionCrypter tries to hide what it’s loading by\nusing pre-calculated `CRC32 numbers instead of strings with function names.`\n\n\n-----\n\nExample of loading pointers to DLL functions by CRC32 of their name\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nAs a first function, OnionCrypter loads `GetModuleHandleA . With this function it can then`\nload `advapi32.dll and` `ntdll.dll . In the next steps the program loads multiple`\nfunctions from DLLs and stores them in the same memory space, where shell code is\n\n\n-----\n\nrunning. Fixed storage is created for that.\n\nStorage of loaded functions inside shell code\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\n\n### Decrypting next layer\n\nNow shell code running on layer 2 starts decrypting layer 3. The structure of decryption is\ncomplex. At the highest level there is a big allocation of memory and a loop. Inside this loop\nis data decrypted in small chunks and copied into big memory, but it is not as simple as it\nseems.\n\nBefore that data chunk gets decrypted, the program first does one `VirtualAlloc of size`\n0x1000 bytes and with `RWX flags. After that, the program starts decrypting pieces of data`\nwith size of 16 bytes and putting them together. This is accompanied by such a large\nnumber of memory allocations that hooking allocation functions is useless (and annoying).\n\nAfter decrypting and joining the pieces with the size of 16 bytes, data is copied to\nVirtualAllocated memory. As it turned out, the data is another shellcode, which consists only\nof a decrypt loop. This shell code is called and decrypts some data from layer 2. Then the\ndecrypted data is transformed again by another function and copied into memory, whose\naddress is returned.\n\n\n-----\n\nMain structure of decrypt next layer code\n\n\n-----\n\nOnionCrypter has an option to compress data (or just some parts of data) with the\n```\nRtlCompressBuffer function. This compression is used before encryption. During the\n\n```\ndecryption process chunks of data are decompressed after they are decrypted, but before\nthey are merged with other chunks.\n\nWhen all pieces are decrypted and joined, execution is passed to the place where the\ndecrypted data is stored and the crypter starts execution of layer 3.\n\n## Layer 3\n\nThis layer is quite similar to the previous layer. At the beginning the same trick as described\nbefore is used to load some important API functions. This time the shell code loads even\nmore functions than before.\n\n\n-----\n\nStorage of loaded functions inside shell code\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\nEven when these function pointers are loaded, they are not necessarily used. Some\nsamples use `RtlDecompressBuffer and some do not. The most probable cause of this is`\nthat OnionCrypter offers options like “additional compression” or “sleep”, which the user can\nchoose when encrypting.\n\nDecryption of the data is the same as in the previous layer. After decryption, OnionCrypter\ncalls the `VirtualProtect function in a loop and changes permissions of memory starting`\nfrom the base address of the program itself to `R/W/X . After this change, OnionCrypter`\ncopies decrypted data and overwrites itself, including the PE header and following sections.\nThen the program changes back memory permissions using `VirtualProtect to ones`\nthat seem legit.\n\nIn the end, OnionCrypter finds the entry point in the new PE header and passes execution\nthere. This is the point where the payload which is now injected into the crypter process\nstarts running.\n\n\n-----\n\nPE header information before and after self-injection\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\n\nSection headers before and after self-injection\n\n8B85A4D9DF1140D25F11914EC4E429C505BD97551EDE19197D2B795C44770AFE\n\n## Conclusion\n\nOnionCrypter is a malware family which has been around for some time. Combined with the\nprevalence of this crypter and the fact that samples have such a unique first layer it’s logical\nto assume that crypter wasn’t developed as a one time thing. On the contrary, according to\nanalysis of multiple samples and their capture date, it was possible to see multiple versions\nof some parts of OnionCrypter.\n\nAcross all of samples these main features of the Onion crypter stay the same:\n\n**The three layer architecture**\n**Unique first layer with a lot of junk code**\n**Existence of the “main” function on layer 1**\n**General purpose and functionality of layer 2 and layer 3**\n\nOn the other hand these are some of the things that may vary between samples from\ndifferent versions:\n\n**The decrypt algorithm of the second layer – There can be found simpler and also**\nmore complicated decryption algorithms used to decrypt the layer 2, as was described\nin previous sections. It is improbable that authors would come up with a complicated\nalgorithm and then change it to something simple, just to make analysis easier. That is\nwhy it is possible that this part of OnionCrypter was updated with newer versions.\n\n\n-----\n\n**The location of the main function – In older samples the main function on layer**\n1 generally can be found very easily, because it is the `WinMain function, which is the`\nuser-provided entry point of the application. This was changed in newer versions,\nbecause the majority of recently captured samples have quite a simple and short\n```\n   WinMain function and the “main” function can be found as one of the other functions.\n\n```\n**Structure of layer 2 and layer 3 – Even though these layers can be found in all**\nsamples of OnionCrypter and always serve the same purpose they may differ in\nimplementation. As an example there are versions, which are loading less DLL\nfunctions. Also in some older versions the loading of DLL functions is not a standalone\nfunction. Based on the analysis, the internal layers have been reworked a bit to make\nthe layers more complex, to add new features and to make the decryption process\nmore complicated and obfuscated.\n**Injection of the final payload – Although the majority of samples are using the**\ntechnique of self-injection described in the previous section, there were cases where\nthe decrypted payload was injected into a new process created in a suspended state.\nThis technique is analogous to the self injection, but is done using a combination of\nfunctions `CreateProcessInternalW,` `VirtualProtectEx,` `WriteProcessMemory`\nand `ResumeThread .`\n\nThis blogpost covered techniques discovered in both older and new versions of\nOnionCrypter. The whole process of decryption and execution of payload was described for\nthe most complex and the most obfuscated versions, which can be considered to be the\nnewest and the most difficult to analyze.\n\n## Indicators of Compromise (IoC)\n\n[Hashes: https://github.com/avast/ioc/tree/master/OnionCrypter/samples.sha256](https://github.com/avast/ioc/tree/master/OnionCrypter/samples.sha256)\nList of the most common event names:\n[https://github.com/avast/ioc/tree/master/OnionCrypter/event_names.txt](https://github.com/avast/ioc/tree/master/OnionCrypter/event_names.txt)\n\n## Appendix\n\nRepository: [https://github.com/avast/ioc/tree/master/OnionCrypter](https://github.com/avast/ioc/tree/master/OnionCrypter)\nIDAPython script for extraction of event names from samples:\n[https://github.com/avast/ioc/tree/master/OnionCrypter/extras/extract_event_names.py](https://github.com/avast/ioc/tree/master/OnionCrypter/extras/extract_event_names.py)\n\n[Tagged asanalysis,](https://decoded.avast.io/tag/analysis/) [crypter,](https://decoded.avast.io/tag/crypter/) [malware,](https://decoded.avast.io/tag/malware/) [obfuscation,](https://decoded.avast.io/tag/obfuscation/) [reversing](https://decoded.avast.io/tag/reversing/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-17 - Hidden menace- Peeling back the secrets of OnionCrypter.pdf"
    ],
    "report_names": [
        "2021-03-17 - Hidden menace- Peeling back the secrets of OnionCrypter.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535555,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653709298,
    "ts_modification_date": 1653709298,
    "files": {
        "pdf": "https://archive.orkl.eu/761ea36ac0b0ecf3102484f41fb9cdce02b892d1.pdf",
        "text": "https://archive.orkl.eu/761ea36ac0b0ecf3102484f41fb9cdce02b892d1.txt",
        "img": "https://archive.orkl.eu/761ea36ac0b0ecf3102484f41fb9cdce02b892d1.jpg"
    }
}