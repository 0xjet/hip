{
    "id": "b841493e-0860-46f6-95d8-94c5d746d3b0",
    "created_at": "2023-01-12T14:59:51.984584Z",
    "updated_at": "2025-03-27T02:06:05.21718Z",
    "deleted_at": null,
    "sha1_hash": "d3667040239cb1a0217f2db64570d43833b713bb",
    "title": "2013-07-25 - ZeroAccess uses Self-Debugging",
    "authors": "",
    "file_creation_date": "2022-05-27T22:13:32Z",
    "file_modification_date": "2022-05-27T22:13:32Z",
    "file_size": 110788,
    "plain_text": "# ZeroAccess uses Self-Debugging\n\n**[blog.malwarebytes.com/threat-analysis/2013/07/zeroaccess-anti-debug-uses-debugger/](https://blog.malwarebytes.com/threat-analysis/2013/07/zeroaccess-anti-debug-uses-debugger/)**\n\nJoshua Cannell July 25, 2013\n\nDebuggers—a tool traditionally used to find errors (called “bugs”) in code—are also used by\nsecurity experts. In the field of malware analysis, debuggers are a vital tool used to reverseengineer malware binaries, helping analysts to understand the purpose and functionality of\nmalware when dynamic analysis isn’t enough.\n\nBecause they’re such a valuable tool, sometimes malware authors try to prevent analysts from\n[using them. By employing various techniques in the code (known as “anti-debugging”), malware](http://en.wikipedia.org/wiki/Debugging#Anti-debugging)\ncan successfully thwart junior analysts.\n\nRecently I found an interesting anti-debugging technique I haven’t seen before. I discovered this\ntechnique while reversing a ZeroAccess Trojan (seems it’s always ZeroAccess lately, right?).\n\nThe technique employs various native Win32 APIs used for debugging a process. By using\nthese APIs, the analyst cannot use their own debugger, since only one debugger can be\nattached to a process at a time.\n\nTo connect to the debugger at the API level, the Trojan uses DbgUIConnectToDbg. This API\nalong with others used to communicate with the Windows Debugger all seem to be\nundocumented by Microsoft.\n\nNext the Trojan creates a child process using the calling EXE (new-sirefef.exe). This was not\nsurprising, as malware usually does this while unpacking. Allow me to explain.\n\n\n-----\n\nTypically, a parent process creates a suspended child process using the calling EXE. Afterward,\nthe parent will de-obfuscate some code and then place it in the child. Whenever this is\ncomplete, the parent makes a call to execute the child (usually with ResumeThread), which is\nnow completely different from the calling EXE. And thus, while you have two processes that\nappear identical, they are completely different when viewed internally.\n\nThis sample doesn’t quite work this way. Under the creation flags parameter for the\n_CreateProcess function, the CREATE_SUSPENDED flag was not being used, but instead the_\nDEBUG_PROCESS flag. There was also another used, called\nCREATE_PRESERVE_CODE_AUTHZ_LEVEL (Note: for a list of process creation flags, click\n[here).](https://www.google.com/search?q=CREATE_PRESERVE_CODE_AUTHZ_LEVEL&oq=CREATE_PRESERVE_CODE_AUTHZ_LEVEL&aqs=chrome.0.69i57j69i61j69i62l3.847j0&sourceid=chrome&ie=UTF-8)\n\nNow both the parent and child process are being debugged, which means we can’t attach an\nadditional debugger to either. This complicates matters as the debugger is the primary tool we\nuse to step through code.\n\nHowever, we can still observe what’s happening statically using our IDA dump. The parent\nprocess appears to handle debug event codes and performs an action for each event (for a list\nof all codes, see [here). After an event has been processed the Trojan continues debugging and](http://msdn.microsoft.com/en-us/library/windows/desktop/ms679308(v=vs.85).aspx)\nreceives another event using DbgUiContinue.\n\n\n-----\n\nWhen an EXCEPTION_DEBUG_EVENT code is received, the Trojan enters a function that\ndecrypts a PE DLL file to the heap. The new PE is then placed into the memory space of the\nchild process.\n\nThe new PE file is actually the final unpacked version of the rootkit. We can dump the memory\nfrom here and load it into IDA to perform some static analysis. Looks like we have some\nwebsites in plain-text the Trojan is going to contact, possibly to locate the infected user\n(geoip_country_code).\n\nThis is just another example of how malware authors attempt to prevent reverse-engineering of\ntheir code with anti-debugging. In this example, however, the ZeroAccess Trojan does not allow\nthe analyst to use their own debugger by connecting to the Windows Debugger itself. All in all I\nthink it’s a very interesting technique, and we’re sure to see more of it in the future.\n\n_______________________________________________________________________________\n\n\n-----\n\n[Joshua Cannell is a Malware Intelligence Analyst at Malwarebytes where he performs research](http://blog.malwarebytes.org/author/jcannell/)\nand in-depth analysis on current malware threats. He has over 5 years of experience working\nwith US defense intelligence agencies where he analyzed malware and developed defense\nstrategies through reverse engineering techniques. His articles on the Unpacked blog feature\nthe latest news in malware as well as full-length technical analysis. Follow him on\nTwitter [@joshcannell](https://twitter.com/joshcannell)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2013/2013-07-25 - ZeroAccess uses Self-Debugging.pdf"
    ],
    "report_names": [
        "2013-07-25 - ZeroAccess uses Self-Debugging.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535591,
    "ts_updated_at": 1743041165,
    "ts_creation_date": 1653689612,
    "ts_modification_date": 1653689612,
    "files": {
        "pdf": "https://archive.orkl.eu/d3667040239cb1a0217f2db64570d43833b713bb.pdf",
        "text": "https://archive.orkl.eu/d3667040239cb1a0217f2db64570d43833b713bb.txt",
        "img": "https://archive.orkl.eu/d3667040239cb1a0217f2db64570d43833b713bb.jpg"
    }
}