{
    "id": "e09e3f81-9291-48d9-99d7-ccff9411081c",
    "created_at": "2023-01-12T15:02:21.745819Z",
    "updated_at": "2025-03-27T02:05:23.551895Z",
    "deleted_at": null,
    "sha1_hash": "898a77ff6824d16e73e43bf03c4b4970ed6e24fd",
    "title": "2021-04-22 - EMOTET- a State-Machine reversing exercise",
    "authors": "",
    "file_creation_date": "2022-05-28T17:58:58Z",
    "file_modification_date": "2022-05-28T17:58:58Z",
    "file_size": 708742,
    "plain_text": "# EMOTET: a State-Machine reversing exercise\n\n**github.com/cecio/EMOTET-2020-Reversing**\n\ncecio\n\n## Intro\n\nAround the 20th of December 2020, there was one of the \"usual\" EMOTET\nemail campaign hitting several countries. I had the possibility to get some\nsample and I decided to make this little analysis, to deep dive some specific\naspects of the malware itself.\n\nIn particular I had a look to how the malware has been written, with an analysis\nof the interesting techniques used.\n\n[There is a very good analysis done by Fortinet in 2019, where the also the first](https://www.fortinet.com/blog/threat-research/deep-dive-into-emotet-malware)\nstage has been analyzed. My exercise is more focused on the second stage on\na recent sample.\n\nIn this repository you will find all the DLLs, scripts and tools used for the\nanalysis, with the annotated Ghidra project file, with all the mapping to my\nfindings (API calls, program logic, etc). You can use this as starting point for\nadditional investigation on it. Enjoy ;-)\n\n## The Tools\n\nFireEye [Speakeasy](https://github.com/fireeye/speakeasy)\n\n\n-----\n\n[Ghidra](https://ghidra-sre.org/)\n[x64dbg](https://x64dbg.com/#start)\n[PE Bear](https://hshrzd.wordpress.com/pe-bear/)\ntime :-)\n\n## The infection chain\n\nEMOTET is usually spread by using e-mail campaign (in this case in Italian\nlanguage)\n\nThis particular sample is coming from what we can call the usual infection\nchain:\n\n1. delivery of an e-mail with a malicious zipped document\n2. once opened, the document runs an obfuscated powershell script and\n\ndownloads the 2nd stage\n3. the 2nd stage (in form of a DLL) is then executed\n4. the 2nd stage establish some persistence and try to connect a C2\n\n## The initial triage\n\nAll the files used for this analysis are in the repository. The \"dangerous\" ones\nare password protected (with the usual pwd).\n\nThe DLL ( sg.dll ) has the following characteristics:\n```\nFile Name: sg.dll  \nSize:   340480 \nSHA1:   b08e07b1d91f8724381e765d695601ea785d8276\n\n```\n\n-----\n\nThis DLL exports a single function named `RunDLL : once executed, it decrypts`\n\"in-memory\" an additional DLL. This one, dumped as `dump_1_0418.bin, is`\nthe target of my analysis:\n```\nFile Name: dump_1_0418.bin\nSize:    122880\nSHA1:    57cd8eac09714effa7b6f70b34039bbace4a3e23\n\n```\nAn initial overview of the dumped DLL, shows immediately that we don't have\nany string visible in it, no imports and a first look to the disassembly shows a\nheavily obfuscated code. We need to do some work here.\n\nI fired up Ghidra and started to snoop around. Starting from the only exported\nfunction `RunDLL you quickly end up to` `FUN_10009716 where you can spot a`\nmain loop with a kind of \"State-Machine\":\n\n\n-----\n\nIt looks like that a given double-word (stored in `ECX ) is controlling what the`\nprogram is doing. But this looks convoluted and not very easy to unroll, since\nnothing is really in clear. For example, if you try to isolate the library API call in\n**x64dbg, you will face something like this:**\n\n\n-----\n\nEvery single API call is done in this way: there is a bunch of `MOV, XOR, SHIFT`\n```\nand PUSH followed by a call to xxx606F (first red box), which decode in EAX\n\n```\nthe address of the function (called by the second red box). The number of\n```\nPUSH just before the CALL EAX are the parameters, which could be worth to\n\n```\ninspect.\n\nThe same \"state\" approach is also used in several sub-functions, not only in\nthe main loop. So, everything looks time consuming, and I'd like to find a way to\nget the high level picture of it.\n\n## Speakeasy\n\nThis tool is a little gem: Speakeasy can emulate the execution of user and\nkernel mode malware, allowing you to interact with the emulated code by using\nquick Python scripts. What I'd like to do was to map every single state of the\nmachine ( ECX value of the main loop), to something more meaningful, like\nDLL API calls.\n\nI had to work a bit to get what I wanted:\n\nthe emulation was failing in more than one point, with some invalid read. I\ninvestigated a bit the reason, and I saw that sometimes the `CALL EAX`\ndone in some location was not valid ( EAX set to 0). I decided to get the\neasy way and just skip these calls\nI had to modify the call to a specific API ( CryptStringToBinary )\nI mapped the machine state\nadded a `--state switch to control the flow of the emulation. You can`\nuse it to explore all the states (ex. `--state 0x167196bc ). You may`\nencounter errors if needed parts are not initialized, but you can\nreconstruct the proper flow by looking at the Ghidra decompilation\nin a second iteration, knowing where strings are decrypted, I added a\ndump of all the strings in clear (see following sections)\n\nThen the execution of the final script ( python emu_emotetdll.py -f\n```\nsg.dll ) gave me something very interesting. The list of the imported DLLs\n\n```\n(with related addresses):\n```\n0x10017a4c: 'kernel32.LoadLibraryW(\"advapi32.dll\")' -> 0x78000000\n0x10017a4c: 'kernel32.LoadLibraryW(\"crypt32.dll\")' -> 0x58000000\n0x10017a4c: 'kernel32.LoadLibraryW(\"shell32.dll\")' -> 0x69000000\n0x10017a4c: 'kernel32.LoadLibraryW(\"shlwapi.dll\")' -> 0x67000000\n0x10017a4c: 'kernel32.LoadLibraryW(\"urlmon.dll\")' -> 0x54500000\n0x10017a4c: 'kernel32.LoadLibraryW(\"userenv.dll\")' -> 0x76500000\n0x10017a4c: 'kernel32.LoadLibraryW(\"wininet.dll\")' -> 0x7bc00000\n0x10017a4c: 'kernel32.LoadLibraryW(\"wtsapi32.dll\")' -> 0x63000000\n...\n\n```\n\n-----\n\nand a lot of API calls, mapped to the machine state:\n```\n[+] State: 1de2d3e5\n0x10010ba0: 'kernel32.GetProcessHeap()' -> 0x7280\n0x10018080: 'kernel32.HeapAlloc(0x7280, 0x8, 0x4c)' -> 0x72a0\n[+] State: 5c80354\n0x10010ba0: 'kernel32.GetProcessHeap()' -> 0x7280\n0x10018080: 'kernel32.HeapAlloc(0x7280, 0x8, 0x20)' -> 0x72f0\n0x10017a4c: 'kernel32.LoadLibraryW(\"advapi32.dll\")' -> 0x78000000\n0x10010ba0: 'kernel32.GetProcessHeap()' -> 0x7280\n0x10014b3a: 'kernel32.HeapFree(0x7280, 0x0, 0x72f0)' -> 0x1\n0x10010ba0: 'kernel32.GetProcessHeap()' -> 0x7280\n...\n\n```\nThis list was not complete (because I skipped on purpose some failing calls\nand probably some calls were not correctly intercepted), but it gave me an\noverall picture of what was going on. Thanks FireEye!\n\n## Mapping\n\nWith the help of Speakeasy output and a combination of dynamic and static\nanalysis (done with x64gdb and Ghidra), I was able to reconstruct the main\nflows of the Malware. Consider that these flows are not complete, they are high\nlevel snapshot of what is going on for some (not all) the \"states\". I'm sure\nsomething is missing. This is the \"main\" flow\n\nThen we have the \"Persistency\" flow (the yellow boxes are the interesting\nones):\n\n\n-----\n\nAnd the initial \"C2\" communication flow:\n\n\n-----\n\nNot all the states were explored. I focused on persistence and initial C2. The\ngreat thing of this approach is that you can now alter the execution flow, by\nsetting the `ECX value you want to explore or execute.`\n\nI added a lot of details in the Ghidra file, by renaming the API calls and\ninserting comments. Every number reported in the graphs (ex 19a) are in the\ncomments, so you can easily track the code section.\n\nI renamed the functions with this standard:\n\na single underscore in front of API calls\na double underscore in front of internal function calls\n\n## Interesting findings: encrypted strings\n\nAll the strings are encrypted in a BLOB, located, in this particular dumped\nsample, at `0x1C800`\n\n\n-----\n\nThe green box is the XOR key and the yellow one is the length of the string.\nThe function used to perform the decryption is the\n```\n__decrypt_buffer_string_FUN_10006aba and\n__decrypt_headers_footer_FUN_100033f4\n\n```\n\n-----\n\nEvery single string is decrypted and then removed from memory after usage.\nThis is true even for C format strings. So you will not find anything in memory if\nyou try to inspect the mapped sections at runtime.\n\nAs said before, I added a specific section in the Speakeasy script to dump\nthose strings.\n\n## Interesting findings: list of C2 servers\n\nIP of C2 are dumped form the same BLOB (in this case at `0x1CA00 ) just after`\nthe decryption in step `20a .`\n\nAs stated in Fortinet Analysis, this list is made of IP (green box) and port\n(yellow box). You can decode the whole list if you pass this part of the binary in\nthe following python code:\n```\nimport sys\nimport struct\nb = bytearray(sys.stdin.buffer.read())\nfor x in range(0,len(b),8):\n  print('%u.%u.%u.%u:%u' %\n(b[x+3],b[x+2],b[x+1],b[x],struct.unpack('<H',bytes(b[x+4:x+6]))[0]))\n\n```\nYou can find the full list extracted in IoC section.\n\n## Interesting findings: persistence\n\nThis particular sample obtain persistency by installing a System Service. This\ncampaign deployed different versions of the DLL using also different\ntechniques: `Run Registry Key is one of them.`\n\nThe section installing the service is the 20a (state `0x204C3E9E ). The high`\nlevel steps are the following:\n\n\n-----\n\ndecrypt the format string `%s.%s`\n\ngenerates random chars to build the service name (which results in\nsomething like `xzyw.qwe )`\n\nget one random \"Service Description\" from the existing ones, and use it\nas description of the new service\n\n## Interesting findings: encrypted communications with C2\n\nIn section 8a (state `0x1C904052 ) we can spot out the load of a RSA public`\nkey\n\nAfter this we have a call to `CryptGenKey with algo` `CALG_AES_128 . So it`\nlooks that the sample is going to use a symmetric key to encrypt\ncommunication.\n\nIn section 20a (state `0x386459ce ) we see how the communication is`\nencrypted:\n\nCryptGenKey\nCryptEncrypt of the buffer to send, with the previous key\nCryptExportKey encrypted with the RSA public key\nthe exported and encrypted symmetric key is then prepended to the\nbuffer sent via HTTP\n\n## Wrap up\n\nThe analysis is far to be complete, there are a lot of unexplored part of the\nsample. At the end my goal was to build a procedure to make the analysis\neasier, even for different or future samples, where it would be faster to\nunderstand the overall picture.\n\n## Appendix: IoC\n\n\n-----\n\nC2 IP list:\n\n\n-----\n\n```\n118.38.110.192:80\n181.136.190.86:80\n167.71.148.58:443\n211.215.18.93:8080\n1.234.65.61:80\n209.236.123.42:8080\n187.162.250.23:443\n172.245.248.239:8080\n60.93.23.51:80\n177.144.130.105:443\n93.148.247.169:80\n177.144.130.105:8080\n110.39.162.2:443\n87.106.46.107:8080\n83.169.21.32:7080\n191.223.36.170:80\n95.76.153.115:80\n110.39.160.38:443\n45.16.226.117:443\n46.43.2.95:8080\n201.75.62.86:80\n190.114.254.163:8080\n12.162.84.2:8080\n46.101.58.37:8080\n197.232.36.108:80\n185.94.252.27:443\n70.32.84.74:8080\n202.79.24.136:443\n2.80.112.146:80\n202.134.4.210:7080\n105.209.235.113:8080\n187.162.248.237:80\n190.64.88.186:443\n111.67.12.221:8080\n5.196.35.138:7080\n50.28.51.143:8080\n181.30.61.163:443\n103.236.179.162:80\n81.215.230.173:443\n190.251.216.100:80\n51.255.165.160:8080\n149.202.72.142:7080\n192.175.111.212:7080\n178.250.54.208:8080\n24.232.228.233:80\n190.45.24.210:80\n45.184.103.73:80\n177.85.167.10:80\n212.71.237.140:8080\n181.120.29.49:80\n170.81.48.2:80\n68.183.170.114:8080\n35.143.99.174:80\n217.13.106.14:8080\n168.121.4.238:80\n\n```\n\n-----\n\n```\n172.104.169.32:8080\n111.67.12.222:8080\n62.84.75.50:80\n77.78.196.173:443\n177.23.7.151:80\n213.52.74.198:80\n12.163.208.58:80\n1.226.84.243:8080\n113.163.216.135:80\n188.225.32.231:7080\n191.182.6.118:80\n81.213.175.132:80\n104.131.41.185:8080\n152.169.22.67:80\n185.183.16.47:80\n192.232.229.54:7080\n186.146.13.184:443\n178.211.45.66:8080\n122.201.23.45:443\n70.32.115.157:8080\n190.24.243.186:80\n51.15.7.145:80\n46.105.114.137:8080\n81.214.253.80:443\n192.232.229.53:4143\n59.148.253.194:8080\n191.241.233.198:80\n181.61.182.143:80\n190.195.129.227:8090\n68.183.190.199:8080\n138.97.60.140:8080\n138.97.60.141:7080\n137.74.106.111:7080\n85.214.26.7:8080\n71.58.233.254:80\n94.176.234.118:443\n188.135.15.49:80\n80.15.100.37:80\n82.76.111.249:443\n155.186.9.160:80\n189.2.177.210:443\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-22 - EMOTET- a State-Machine reversing exercise.pdf"
    ],
    "report_names": [
        "2021-04-22 - EMOTET- a State-Machine reversing exercise.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535741,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653760738,
    "ts_modification_date": 1653760738,
    "files": {
        "pdf": "https://archive.orkl.eu/898a77ff6824d16e73e43bf03c4b4970ed6e24fd.pdf",
        "text": "https://archive.orkl.eu/898a77ff6824d16e73e43bf03c4b4970ed6e24fd.txt",
        "img": "https://archive.orkl.eu/898a77ff6824d16e73e43bf03c4b4970ed6e24fd.jpg"
    }
}