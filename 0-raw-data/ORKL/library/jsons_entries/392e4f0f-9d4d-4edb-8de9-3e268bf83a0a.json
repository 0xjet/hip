{
    "id": "392e4f0f-9d4d-4edb-8de9-3e268bf83a0a",
    "created_at": "2023-01-12T15:01:39.898415Z",
    "updated_at": "2025-03-27T02:05:56.872427Z",
    "deleted_at": null,
    "sha1_hash": "35cfe3be10d616190dff8a29fa5f784bbbccf641",
    "title": "2022-08-07 - Analyzing .NET Core Single File Samples (DUCKTAIL Case Study)",
    "authors": "",
    "file_creation_date": "2022-08-18T03:56:55Z",
    "file_modification_date": "2022-08-18T03:56:55Z",
    "file_size": 539558,
    "plain_text": "# Analyzing .NET Core Single File Samples (DUCKTAIL Case Study)\n\n**[forensicitguy.github.io/analyzing-net-core-single-file-ducktail/](https://forensicitguy.github.io/analyzing-net-core-single-file-ducktail/)**\n\nAugust 7, 2022\n\n### By Tony Lambert Posted 2022-08-07 8 min read\n\n This post is dedicated to my colleague Matt Graeber (@mattifestation) who showed me how to do the manual calculations and carving of PEs using CFF Explorer and a hex editor, making me think “there has to be a tool for this”. There are loads of ways to deploy .NET Framework applications, and I’ve mostly been familiar with just the traditional compile-and- run method. As .NET malware has evolved, adversaries have looked to use different deployment reasons for the same reason as legitimate developers. In some cases it’s easier, allows bundling files in different ways, or other reasons. One malware family named DUCKTAIL has recently embraced deployment in as a “.NET Single File” deployment feature. This feature is interesting in the sense that it allows a developer to deploy a .NET application to systems without requiring the systems to have a pre-deployed .NET Framework runtime installed. This dependency-free deployment is achieved by appending multiple binaries together into a single file, resulting in a large executable with multiple executables inside. In this post we’ll take a look at a DUCKTAIL sample and how the “single file” deployment choice affects malware analysis. The sample we’re working with is here in VT: https://www.virustotal.com/gui/file/740fd780b2b45c08d1abb45cddc6d1017c9fcc6bcce54fd8 415d87a80d328ff6.\n\n## Triaging the file\n\n### As always, we can start out triaging the file using a combination of diec and pehash . First, let’s figure out the file type:\n```\n  remnux@remnux:~/cases/ducktail$ diec\n  ducktail.exe\n\n  PE32\n\n    Compiler: Microsoft Visual C/C++(-)[-]\n\n    Linker: Microsoft Linker(14.29**)\n  [GUI32,signed]\n\n```\n\n-----\n\n### Right off the bat, we can see our output is a little different than what we’d expect for a standard .NET Framework app. In this case we see diec says the file was compiled using Visual C/C++ instead of a .NET language like C# or VB. Usually for .NET apps, the output would look similar to this:\n```\n  PE32\n\n    Library: .NET(v4.0.30319)[-]\n\n    Compiler: VB.NET(-)[-]\n\n    Linker: Microsoft Linker(8.0)\n  [GUI32]\n\n We know for sure we’re dealing with a Windows Portable Executable (PE) file, so let’s take a look at the import and rich header hashes. If you’re looking to get the imphash for a sample, you can easily do so with pehash . For the rich header hash, I like using the tool I made here that leverages the Python pefile library.\n  remnux@remnux:~/cases/ducktail$ pehash ducktail.exe\n\n  file\n\n    filepath:            ducktail.exe\n\n    md5:               72840061e0f1b2f4bc373b5561970303\n\n    sha1:              c773a6285a54183e792f23e499646f61d9b2f88f\n\n    sha256:             \n  740fd780b2b45c08d1abb45cddc6d1017c9fcc6bcce54fd8415d87a80d328ff6\n\n    ssdeep:             \n  1572864:ha0XsmjPyZmtmuwKl7E2LmZBhbCV6ZE5GSQiOjEBkqYnIgJM0cAZv7SGdAcA689p:jjPyZxu\n  wz+6y\n\n    imphash:             34dc34e244a6f4378a06076ff16fc082\n\n  remnux@remnux:~/cases/ducktail$ ./rhh-md5.py ducktail.exe\n\n  e0f1735adef0e9f084efeaee57b351d2\n\n```\n\n-----\n\n### The imphash and rich header hash values are different that what I expect of traditional .NET malware. Usually, .NET executables have an import hash of\n```\nf34d5f2d4577ed6d9ceec516c1f5a744 and .NET DLLs have an import hash of\ndae02f32a21e03ce65412f6e56942daa . In addition, .NET executables and DLLs usually\n\n don’t have rich header hashes. So this sample triages more like a native, unmanaged code binary than a .NET one.\n\n## Digging deeper with exiftool and pedump\n\n### We can get our first hints of the app being compiled as a .NET Core single file executable using exiftool and pedump .\n  remnux@remnux:~/cases/ducktail$ exiftool ducktail.exe\n\n  ExifTool Version Number     : 12.42\n\n  File Name            : ducktail.exe\n\n  Directory            : .\n\n  File Size            : 56 MB\n\n  File Modification Date/Time   : 2022:08:07 21:14:35-04:00\n\n  File Access Date/Time      : 2022:08:07 21:15:11-04:00\n\n  File Inode Change Date/Time   : 2022:08:07 21:15:04-04:00\n\n  File Permissions        : -rw-rw-r-\n  File Type            : Win32 EXE\n\n  File Type Extension       : exe\n\n  MIME Type            : application/octet-stream\n\n  Machine Type          : Intel 386 or later, and\n  compatibles\n\n  Time Stamp           : 2022:04:13 21:36:43-04:00\n\n  Image File Characteristics   : Executable, 32-bit\n\n  PE Type             : PE32\n\n  Linker Version         : 14.29\n\n  Code Size            : 233984\n\n  Initialized Data Size      : 331776\n\n  Uninitialized Data Size     : 0\n\n  Entry Point           : 0x2f8f0\n\n  OS Version           : 6.0\n\n  Image Version          : 0.0\n\n  Subsystem Version        : 6.0\n\n  Subsystem            : Windows GUI\n\n  File Version Number       : 1.0.0.0\n\n  Product Version Number     : 1.0.0.0\n\n  File Flags Mask         : 0x003f\n\n  File Flags           : (none)\n\n  File OS             : Win32\n\n  Object File Type        : Executable application\n\n  File Subtype          : 0\n\n  Language Code          : Neutral\n\n  Character Set          : Unicode\n\n  Company Name          : DataExtractor\n\n  File Description        : DataExtractor\n\n  File Version          : 1.0.0.0\n\n  Internal Name          : DataExtractor.dll\n\n  Legal Copyright         :\n\n```\n\n-----\n\n```\nOriginal File Name       : DataExtractor.dll\n\nProduct Name          : DataExtractor\n\nProduct Version         : 1.0.0\n\nAssembly Version        : 1.0.0.0\n\n```\n\n-----\n\n### The file size is 56 MB. It’s not the beefiest binary ever, but it’s still pretty heavy and that can indicate multiple binaries in a single file. From here we can look at binary properties with\n```\npedump to get some more data. In the interest of brevity I’ve cut down the pedump output\n\n to just the exports since it contains the relevant bits.\n  remnux@remnux:~/cases/ducktail$ pedump --exports\n  ducktail.exe\n\n  === EXPORTS ===\n\n  # module \"singlefilehost.exe\"\n\n  # flags=0x0 ts=\"2106-02-07 06:28:15\" version=0.0 \n  ord_base=1\n\n  # nFuncs=23 nNames=23\n\n   ORD ENTRY_VA NAME\n\n    1  21580 corehost_initialize\n\n    2  20ad0 corehost_load\n\n    3  20f20 corehost_main\n\n    4  21090 corehost_main_with_output_buffer\n\n    5  21960 corehost_resolve_component_dependencies\n\n    6   eba0 corehost_set_error_writer\n\n    7  218e0 corehost_unload\n\n    8   f260 hostfxr_close\n\n    9   e8d0 hostfxr_get_available_sdks\n\n    a   eaa0 hostfxr_get_native_search_directories\n\n    b   ef80 hostfxr_get_runtime_delegate\n\n    c   f190 hostfxr_get_runtime_properties\n\n    d   efd0 hostfxr_get_runtime_property_value\n\n    e   ed40 \n  hostfxr_initialize_for_dotnet_command_line\n\n    f   ee70 hostfxr_initialize_for_runtime_config\n\n   10   e520 hostfxr_main\n\n   11   e3e0 hostfxr_main_bundle_startupinfo\n\n```\n\n-----\n\n```\n 12   e490 hostfxr_main_startupinfo\n\n 13   e5c0 hostfxr_resolve_sdk\n\n 14   e720 hostfxr_resolve_sdk2\n\n 15   ef10 hostfxr_run_app\n\n 16   eba0 hostfxr_set_error_writer\n\n 17   f130 hostfxr_set_runtime_property_value\n\n```\n\n-----\n\n### .NET core single file apps are multiple binaries appended to one another, right? Well, the first binary in the append chain has the responsibility of being a “.NET loader” that loads subsequent .NET resources (appended after the loader) into memory at runtime. Once the resources get loaded, the actual .NET app gets run. The export details seen here in\n```\npedump are from the .NET loader overhead itself, which results in some good\n\n predictability. The .NET core “single file” apps should usually have exports like\ncorehost_initialize, corehost_load, and others.\n\n## Getting the actual app/malware\n\n### We’ve got our bearings a bit and we know from documentation that a “single file” app is just a bunch of binaries appended to each other. So, logically, we should be able to walk the file and extract all the PEs from it. We can do this using pecheck.py .\n  remnux@remnux:~/cases/ducktail$ pecheck -l P ducktail.exe\n  1: 0x00000000 EXE 32-bit 0x0350a17f 72840061e0f1b2f4bc373b5561970303 0x0350a17f\n  (EOF) b'' b'singlefilehost.exe'\n\n  2: 0x0008a71c DLL 64-bit 0x0013e6cb d35f8c57d217a41dfc5e68bf25e5ecb1 0x0350a17f\n  (EOF) b'empty' b'clrcompression.dll'\n\n  3: 0x0013e6cc DLL 64-bit 0x0024687b e127d23181160e02391e628192b1d08a 0x0350a17f\n  (EOF) b'clrjit.dll' b'clrjit.dll'\n\n  4: 0x0024687c DLL 64-bit 0x00652623 99004b84b758edc90f90671221152667 0x0350a17f\n  (EOF) b'CoreCLR.dll' b'coreclr.dll'\n\n  5: 0x00652624 DLL 64-bit 0x007443c3 ea613da6eeb3f2968faa2d65dabadab1 0x0350a17f\n  (EOF) b'mscordaccore.dll' b'mscordac.dll'\n\n  6: 0x007443c4 DLL 32-bit 0x008655c3 e02613d1a6211eb1bfc8d15431acbd68 0x0350a17f\n  (EOF) b'' b'e_sqlite3.dll'\n\n  ...\n\n  24: 0x0087fbd0 DLL 32-bit 0x010aed77 d3cfe3422fb4d5a93c1cf9807debd230 0x0350a17f\n  (EOF) b'' b'System.Private.CoreLib.dll'\n\n  25: 0x010aed80 DLL 32-bit 0x0111d57f 4ef7d9040e94a8c3a9ede74a8f66a73f 0x0350a17f\n  (EOF) b'' b'Dapper.dll'\n\n  26: 0x0111d580 DLL 32-bit 0x0117b77f a660b3d199853c0b014812f39e46eaa8 0x0350a17f\n  (EOF) b'' b'HtmlAgilityPack.dll'\n\n  27: 0x0117b780 DLL 32-bit 0x011ce97f 2904b6192503177cf287f6ae23ed65d5 0x0350a17f\n  (EOF) b'' b'Microsoft.Data.Sqlite.dll'\n\n  28: 0x011ce980 DLL 32-bit 0x0135e57f 47d413a62176af3f801b9f6a1146e1a7 0x0350a17f\n  (EOF) b'' b'Newtonsoft.Json.dll'\n\n  29: 0x0135e580 DLL 32-bit 0x019a2f7f 6697ec4f0f13bed443f3b070cc4192df 0x0350a17f\n  (EOF) b'' b'BouncyCastle.Crypto.dll'\n\n  30: 0x019a2f80 DLL 32-bit 0x019a4b7f 9b59e64ef76c1a543983b8dcb1ce8d75 0x0350a17f\n  (EOF) b'' b'SQLitePCLRaw.batteries_v2.dll'\n\n  31: 0x019a4b80 DLL 32-bit 0x019a637f 8b477db107c8ac8c219d90d94d93aaa4 0x0350a17f\n  (EOF) b'' b'SQLitePCLRaw.nativelibrary.dll'\n\n  32: 0x019a6380 DLL 32-bit 0x019ba57f 5bacb4c47e3ba56dd53cf88781bb4e05 0x0350a17f\n  (EOF) b'' b'SQLitePCLRaw.core.dll'\n\n  33: 0x019ba580 DLL 32-bit 0x019d077f 7a9ca8439b58afd87f4faec21968c087 0x0350a17f\n  (EOF) b'' b'SQLitePCLRaw.provider.dynamic_cdecl.dll'\n\n  34: 0x019d0780 DLL 32-bit 0x019d837f 5b015246ff6883063438c8ecf4af101e 0x0350a17f\n  (EOF) b'' b'System.Security.Cryptography.ProtectedData.dll'\n\n```\n\n-----\n\n```\n  35: 0x019d8380 DLL 32 bit 0x01a3417f ed5bdc648cba3d82edd0b14bed18b931 0x0350a17f\n  (EOF) b'' b'Telegram.Bot.dll'\n\n  36: 0x01a34180 DLL 32-bit 0x01aa217f 6a62b196160d1a477effa8e07ae48533 0x0350a17f\n  (EOF) b'' b'DataExtractor.dll'\n\n  37: 0x01aa2180 DLL 32-bit 0x01b7bb7f 0b360b2e48ad740b2045c96c228d8dfa 0x0350a17f\n  (EOF) b'' b'Microsoft.CSharp.dll'\n\n  ...\n\n  92: 0x03459580 DLL 32-bit 0x034c917f 6d306c25b62c2422a8411315307f5bf5 0x0350a17f\n  (EOF) b'' b'System.Text.RegularExpressions.dll'\n\n  93: 0x034c9180 DLL 32-bit 0x034e0b7f 21fef48538579c3d2533532c4b143e75 0x0350a17f\n  (EOF) b'' b'System.Threading.Channels.dll'\n\n  94: 0x034e0b80 DLL 32-bit 0x034f037f e58c38c4e4bfc5151c0f1ff350bfe6b7 0x0350a17f\n  (EOF) b'' b'System.Threading.dll'\n\n### Using pecheck with arguments to list the available PEs in the file reveals a whopping 94 different PE files within the single original ducktail.exe sample. Thankfully, there are only a couple of PEs here that are interesting to us: 35/Telegram.Bot.dll and 36/DataExtractor.dll. We can extract those with pecheck as well!\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/ducktail$ pecheck -l 35 -g s -D ducktail.exe >\n  Telegram.Bot.dll\n\n  remnux@remnux:~/cases/ducktail$ diec Telegram.Bot.dll\n\n  PE32\n\n    Library: .NET(v4.0.30319)[-]\n\n  remnux@remnux:~/cases/ducktail$ pecheck -l 36 -g s -D ducktail.exe >\n  DataExtractor.dll\n\n  remnux@remnux:~/cases/ducktail$ diec DataExtractor.dll\n  PE32\n\n    Library: .NET(v4.0.30319)[-]\n\n### Excellent, we’ve successfully extracted the actual DUCKTAIL .NET code from its “single file” container!\n\n## Decompilation and further steps\n\n### Decompiling is a breeze with this sample thanks to ilspycmd . Lately I’ve been using it with command line arguments to export code as a .NET project so I can get extra details in there like the icon used by the malware.\n  remnux@remnux:~/cases/ducktail$ mkdir ducktail-src\n\n  remnux@remnux:~/cases/ducktail$ ilspycmd -p -o ./ducktail-src/\n  DataExtractor.dll\n\n  remnux@remnux:~/cases/ducktail$ mkdir telegrambot-src\n\n  remnux@remnux:~/cases/ducktail$ ilspycmd -p -o ./telegrambot-src/\n  Telegram.Bot.dll\n\n  remnux@remnux:~/cases/ducktail$ tree -a ducktail-src/\n\n  ducktail-src/\n\n  ├── app.ico\n\n  ├── cnData\\Core\\Models\\Json\n\n  │  └── DataJsonModel.cs\n\n  ├── CokiWin\\Core\\Models\\Json\\BusinessJsonModel\n\n  │  ├── Adaccount_Permissions.cs\n\n  │  ├── BusinessJsonModel.cs\n\n  │  ├── Clients.cs\n\n  │  ├── Cursors1.cs\n\n  │  ├── Cursors.cs\n\n  │  ├── Datum1.cs\n\n  │  ├── Datum.cs\n\n  │  ├── Paging1.cs\n\n```\n\n-----\n\n```\n  │   Paging.cs\n\n  ├── DataExtractor\n\n  │  └── Program.cs\n\n  ...\n\n### From here, if you want to get into deeper analysis you can start with the Program.cs file and simply follow the flow of code to other files as relevant!\n\n```\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-07 - Analyzing .NET Core Single File Samples (DUCKTAIL Case Study).pdf"
    ],
    "report_names": [
        "2022-08-07 - Analyzing .NET Core Single File Samples (DUCKTAIL Case Study).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535699,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1660795015,
    "ts_modification_date": 1660795015,
    "files": {
        "pdf": "https://archive.orkl.eu/35cfe3be10d616190dff8a29fa5f784bbbccf641.pdf",
        "text": "https://archive.orkl.eu/35cfe3be10d616190dff8a29fa5f784bbbccf641.txt",
        "img": "https://archive.orkl.eu/35cfe3be10d616190dff8a29fa5f784bbbccf641.jpg"
    }
}