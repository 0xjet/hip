{
    "id": "60d0e4d3-dbe4-43d4-8543-29a6484f4e3a",
    "created_at": "2023-01-12T15:01:55.901678Z",
    "updated_at": "2025-03-27T02:09:18.25198Z",
    "deleted_at": null,
    "sha1_hash": "781de475617e717af7e7c9f83aafbbedee282582",
    "title": "2021-10-08 - SQUIRRELWAFFLE – Analysing The Main Loader",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:15Z",
    "file_modification_date": "2022-05-27T23:24:15Z",
    "file_size": 2859131,
    "plain_text": "# SQUIRRELWAFFLE – Analysing The Main Loader\n\n**[0ffset.net/reverse-engineering/malware-analysis/squirrelwaffle-main-loader/](https://www.0ffset.net/reverse-engineering/malware-analysis/squirrelwaffle-main-loader/)**\n\n\nOctober 8, 2021\n\n\n-----\n\n[Chuong Dong](https://www.0ffset.net/author/chuong-dong/)\n8th October 2021\n1 Comment\n\nThis is a follow up for [my last post on unpacking SQUIRRELWAFFLE’s custom packer. In](https://www.0ffset.net/reverse-engineering/malware-analysis/squirrelwaffle-custom-packer/)\nthis post, we will take a look at the main loader for this malware family, which is typically used\nfor downloading and launching Cobalt Strike.\n\nSince this is going to be a full analysis on this loader, we’ll be covering quite a lot. If you’re\ninterested in following along, you can grab the sample from MalwareBazaar.\n\n[SHA256: d6caf64597bd5e0803f7d0034e73195e83dae370450a2e890b82f77856830167](https://bazaar.abuse.ch/sample/d6caf64597bd5e0803f7d0034e73195e83dae370450a2e890b82f77856830167/)\n\n## Step 1: Entry Point\n\nAs a DLL, the SQUIRRELWAFFLE loader has three different export functions, which are\n_DllEntryPoint, DllRegisterServer, and ldr. Since DllRegisterServer and ldr share the same_\naddress, they are basically the same function. For the sake of simplicity, I will refer to this\nfunction as ldr.\n\n\n-----\n\nA quick look in IDA Pro will show us that DllEntryPoint only calls the function DllMain, which\nis an empty function that moves the value 1 into eax and returns. On the other hand, ldr is a\nwrapper function that calls sub_10003B50, which seems to contain the main functionality of\nthis loader, so we will treat this as the real entry point and begin our analysis.\n\n## Step 2: String Wrapper Structure\n\nWhen analyzing sub_10003B50, we can quickly see that they rarely use raw strings directly.\nInstead, they have some stack variables that are potentially loaded with string data, such as\ncontent and length, using functions such as sub_10006AA0.\n\nIn this example, we see the full path of %APPDATA% retrieved using getenv and passed in\n**sub_10006AA0 with its length.**\n\nAnalyzing the small snippet of code at the end of this function shows that the first parameter\nis used as a structure due to values being set at an offset from this variable.\n\n\n-----\n\nWe can use IDAs _Create new struct type functionality to create a structure with these_\ndefault fields based on the offsets used from this variable.\n```\nstruct string_struct\n{\n  void *pvoid0;\n  _BYTE gap4[12];\n  _DWORD dword10;\n  _DWORD dword14;\n};\n\n```\nIf we change the name of the main variable to string_structure and the type to the structure\nabove, the same snippet of code becomes easier to understand. The input string is written to\nthe pvoid0 field’s pointer, and its length is written to the dword10 field. As a result, we can\nrename these two fields to make things easier to analyze.\n\nSince the string_structure variable is returned, it is clear that the functionality of\n**sub_10006AA0 is to populate this wrapper structure with the input string and its size. When**\nneeded, the malware can access the string’s data through this wrapper structure. Although\nthis is excessive and makes analysis a bit more challenging, I don’t believe it is used as an\nanti-analysis mechanism. The malware author probably just wants a uniformed way to store\nand access strings.\n\nTypically, when a structure field’s name begins with “gap”,the field is not used anywhere in\nthe local function, so in most cases, we can safely ignore this field and update it if we ever\nencounter code that accesses it later on. The last field we need to analyze is the dword14\nfield.\n\n\n-----\n\nIn this part of the function, the field’s value is compared to the string’s size, and if it’s smaller,\nthe malware will allocate a new buffer that is one byte bigger than the string’s size. This new\nsize is set back to the dword14 field, and the newly allocated buffer is later set to the pvoid0\nfield and has the string input written to it. From this, we can assume the dword14 field\ncontains the default buffer size for the structure’s string buffer.\n\nAfter renaming all fields, the string structure should look like this in IDA.\n```\nstruct string_struct\n{\n  void *string_buffer;\n  _BYTE gap4[12];\n  _DWORD string_size;\n  _DWORD default_buffer_size;\n};\n\n```\nThis structure will eventually be used throughout the malware, and SQUIRRELWAFFLE will\nhave multiple functions that interact with it. There are functions to convert the structure to\ncontain wide characters, combine two structures into one, append a string into the structure’s\ncurrent string, etc. I won’t be discussing all of these functions and will simply refer to them by\ntheir functionality in the analysis.\n\n## Step 3: Encryption/Decryption Routine\n\nEven though most of SQUIRRELWAFFLE’s strings are stored in plaintext in the .rdata\nsection, the more important strings such as the list of C2 URLs are encoded and resolved by\nthe malware dynamically.\n\n\n-----\n\nWhen encoding/decoding data, SQUIRRELWAFFLE loads the buffer and its length into a\nstructure and loads the key and its length into another. Then, both structures’ fields are\npassed into function sub_100019B0 as parameters.\n\nUpon analyzing sub_100019B0, we can see that the algorithm boils down to a single for\nloop. First, SQUIRRELWAFFLE allocates an empty string structure to contain the result of\nthe algorithm. Then, the malware uses a for loop to iterate through each character in the\ndata, XOR-ing it with a character from the key.\n\nSince the same variable is used to index into both the data and the key, SQUIRRELWAFFLE\nmods its value by the key length when indexing into the key in order to reuse it when the\nlength of the data is greater than the length of the key. The output character is written into a\nstructure, which is later appended to the result structure. As a result, we can conclude that\n**sub_100019B0 is a XOR cipher that is used for encoding/decoding data.**\n\n\n-----\n\n## Step 4: Block Sandbox IP Addresses\n\nFrom reading others’ analysis on SQUIRRELWAFFLE, I happen to know the first encoded\nstring gets decoded into a list of IP addresses. In this particular sample however, instead of\nthe normal encoded data, an empty buffer is passed into the data structure instead.\n\nUsually for encoded strings, it is simple to guess their functionalities based on their decoded\ncontents. For strings that are replaced with an empty buffer because the malware authors\ndecide to leave the functionality out, we must track and analyze how the decoded data is\nused in order to understand its functionality.\n\nAfter decoding this buffer, SQUIRRELWAFFLE calls sub_100011A0, which calls\n**GetAdaptersInfo to retrieve the victim’s network adapter information. The malware then**\nuses it to retrieve the local machine’s IPv4 address, writes the address into a structure, and\nreturns it.\n\n\n-----\n\nAfter getting the machine’s IP address, SQUIRRELWAFFLE checks to see if the decoded\ndata contains the address. If it does, the malware exits immediately.\n\n\n-----\n\nFrom this, we know that the encoded buffer contains IP addresses to blacklist, and the\nmalware terminates if the machine’s address is blacklisted. This is typically used to check for\nIP addresses of sandboxes to prevent malware from running in these automated\nenvironments. Because the encoded data is an empty buffer, the feature is ignored for this\nparticular sample.\n\n## Step 5: Victim Information Extraction\n\nPrior to executing the main networking functionality, SQUIRRELWAFFLE calls the following\nWinAPI functions: GetComputerNameW to retrieve the local computer’s NetBIOS name,\n**GetUserNameW to retrieve the local username, and NetWkstaGetInfo to retrieve the**\ncomputer’s domain name.\n\n\n-----\n\nUsing the results of these function calls, SQUIRRELWAFFLE builds up a structure that\ncontains a string in the following format.\n```\n<computer name>\\t\\t<user name>\\t\\t<APPDATA path>\\t\\t<computer domain>\n\n```\nSince this victim information string is later delivered to C2 servers, SQUIRRELWAFFLE\nencodes it using the XOR cipher with the key “KJKLO” and Base64 to avoid sending it in\nplaintext.\n\n## Step 6: Decode C2 URLs\n\n\n-----\n\nIn its main networking function, SQUIRRELWAFFLE first decodes its C2 URL list using the\nXOR cipher with the key\n“SgGPfGgbzrSEtPOTtuYkdqSujuBDgXlopIUKrDONXaACWZxGxWkWoIvf”.\n\nBelow is the defanged version of the decoded content.\n```\npop[.]vicamtaynam[.]com/VtyiHAft|snsvidyapeeth[.]in/aXmo2Dr3|trinitytesttubebaby[.]com\nonline[.]com/ypCiZn7tMx|antoniocastroycia[.]com[.]co/WHe08obY|apexbiotech[.]net/VQgunQ\n\n```\nWe can see that the malware creates two C++ iterators. After splitting each URL by the\nseparator “|”, SQUIRRELWAFFLE adds the domain to its domain array and the path to its\npath array and iterates them using the generated iterators.\n\n\n-----\n\n## Step 7: Build & Send POST Request\n\nWhen building the POST request to send to each C2 server, SQUIRRELWAFFLE first builds\nthe URL endpoint path. It generates a random ASCII string with a random length between 1\nand 28 characters, retrieves the local machine’s IP address, and appends them together.\n\nSQUIRRELWAFFLE generates an endpoint path by encrypting this string using the XOR\ncipher with the key “KJKLO” and encoding it with Base64. The final POST request is built in\nthe format below.\n```\nPOST /<URL path>/<encoded endpoint path> HTTP/1.1\\r\\nHost: <URL>\\r\\nContent-Length:\n<encoded victim information length>\\r\\n\\r\\n<encoded victim information>\n\n```\nFor some reason, I can not produce this full string in my debugger because the encoded\nendpoint path is not properly resolved for some of the URLs. As an alternative, to confirm\n[that the format from static analysis above is correct, I run the sample on ANY.RUN and check](https://app.any.run/tasks/8223af38-1523-4f11-85be-5a4a93be6606)\nthe captured PCAP file.\n\n\n-----\n\nTo contact each C2 server, SQUIRRELWAFFLE calls WSAStartup to initiate use of the\nWinsock DLL and getaddrinfo to retrieve a structure containing the server’s address\ninformation. Next, it calls socket and connect to create a socket and establish a connection\nto the remote server.\n\nFinally, the malware calls send to send the fully crafted POST request and recv to wait and\nreceive a response from the server. Once received, the response string is written into a\nstructure and returned.\n\n\n-----\n\n## Step 8: Analyze C2 Server’s Response\n\nUsing the PCAP we get from ANY.RUN, we can quickly extract and view the C2 server’s\nresponse. Below is one of the responses captured.\n```\nf3p/QUVCQ0FBfn15eXV9f355eEJBQ0JGQnN/ZX5/fWR6e3pleHp1QkFDQkZCHhkOHmIbCUJFLi8nIiJGQglxEB\n\n```\nFrom static analysis, we can see that the response is decoded using Base64 and decrypted\nwith the XOR-cipher using the key “KJKLO”.\n\n\n-----\n\nWith CyberChef, we can quickly decode this and examine the raw content of the C2’s\nresponse.\n\n\n-----\n\nSince the threat actor has the C2 server response with a 404 code and NONE for some of\nthe response fields, we don’t really get much out of the response except for its general\nlayout. In order to know what each of the response fields does, we have to dive back into the\nsample with static analysis.\n\nIn IDA, we can see that SQUIRRELWAFFLE uses an iterator to iterate through all the\nresponse fields, and the fields are split by the separator “\\r\\n\\t\\t\\n\\r”. This gives us fifteen\ndifferent fields in the response.\n\nIf the 8th field in the response is “true”, the malware immediately skips the server’s response\nand goes back to contacting another server.\n\nSimilarly, if the first field corresponding to the HTTP response code is anything but “200”, the\nmalware also skips processing the server’s response.\n\n## Step 9: Register Executable To Registry\n\nWhen the length of the 6th response field is greater than 100, this field contains the content\nof an executable to be dropped and registered in the registry. SQUIRRELWAFFLE first\ngenerates a random name with a random length between 1 and 11, appends “.txt” to it, and\nlater uses it to drop the executable\n\n\n-----\n\nThe malware then calls std::_Fiopen with the newly generated filename to get a file stream\nto write to. It extracts the content of the executable from the response field and writes it to\nthe file stream.\n\nSQUIRRELWAFFLE then decodes the command “regsvr32.exe -s ”, appends the\nexecutable’s name to it, and calls WinExec to register it as a command component in the\nregistry.\n\n\n-----\n\n## Step 10: Drop & Execute Executable\n\nWhen the length of the 7th response field is greater than 100, this field contains the content\nof the next stage executable to be dropped and executed.\n\nSQUIRRELWAFFLE also generates another random name for the executable, appends it\nafter the machine’s TEMP path, and writes the executable’s content there.\n\nFinally, it calls system to launch a start command and execute the dropped executable.\n\n\n-----\n\n## Step 11: Shellcode Launching\n\nWhen the length of the 15th response field is greater than 10, this field contains a hex string\nthat SQUIRRELWAFFLE parses and executes as shellcode.\n\nThe malware uses strtoul to convert the hex string into a buffer of bytes. It then calls\n**CreateEventW to create an event object, allocates virtual memory, and writes the buffer into**\nthe allocated memory.\n\nThe call to CreateThreadpoolWait registers the allocated buffer as a callback function to\nexecute when the wait object completes. Finally, the call SetThreadpoolWait sets the wait\nobject for the event, which executes the callback function and launches the shellcode.\n\n## Step 12: Drop & Execute Custom Executable\n\nThis part is similar to Step 10, except that the executable’s path is provided in the 13th\nresponse field instead of being randomly generated.\n\nSQUIRRELWAFFLE reads the file’s content from the 5th response field, writes it into the\nspecified file path, and executes the command in the 14th response field to possibly launch\nthe dropped executable.\n\n\n-----\n\nAt this point, we have fully dissected the entire SQUIRRELWAFFLE loader and understood\nhow it can be used to launch executables and execute shellcode!\n\nIn the analysis, I skipped analyzing a lot of functions that can be automatically resolved using\n[IDA’s Lumina server and Capa. Since the malware reuses a lot of local variables for various](https://github.com/mandiant/capa)\nfunctionalities, I have to rename them in every image included in this post to avoid confusion.\n\n[If you have any trouble following the analysis, feel free to reach out to me via Twitter.](https://twitter.com/cPeterr)\n\n## 1 Comment\n\nComments are closed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-08 - SQUIRRELWAFFLE – Analysing The Main Loader.pdf"
    ],
    "report_names": [
        "2021-10-08 - SQUIRRELWAFFLE – Analysing The Main Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535715,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653693855,
    "ts_modification_date": 1653693855,
    "files": {
        "pdf": "https://archive.orkl.eu/781de475617e717af7e7c9f83aafbbedee282582.pdf",
        "text": "https://archive.orkl.eu/781de475617e717af7e7c9f83aafbbedee282582.txt",
        "img": "https://archive.orkl.eu/781de475617e717af7e7c9f83aafbbedee282582.jpg"
    }
}