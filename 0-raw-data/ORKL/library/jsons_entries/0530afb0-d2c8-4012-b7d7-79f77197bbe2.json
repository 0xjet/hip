{
    "id": "0530afb0-d2c8-4012-b7d7-79f77197bbe2",
    "created_at": "2023-01-12T15:07:42.229562Z",
    "updated_at": "2025-03-27T02:06:04.281786Z",
    "deleted_at": null,
    "sha1_hash": "ec0f3864bcf4a0ca69df91ed65fcdc91af31a293",
    "title": "2017-10-29 - Sality Configuration Extractor (sality_extractor.py)",
    "authors": "",
    "file_creation_date": "2022-05-28T17:47:58Z",
    "file_modification_date": "2022-05-28T17:47:58Z",
    "file_size": 84529,
    "plain_text": "# Sality Extractor\n\n# Copyright (C) 2017 quangnh89, develbranch.com\n\n#\n\n# This program is free software: you can redistribute it and/or modify\n\n# it under the terms of the GNU Affero General Public License as published by\n\n# the Free Software Foundation, either version 3 of the License, or\n\n# (at your option) any later version.\n\n#\n\n# This program is distributed in the hope that it will be useful,\n\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n# GNU Affero General Public License for more details.\n\n#\n\n# You should have received a copy of the GNU Affero General Public License\n\n# along with this program. If not, see .\n\n#\n\n# blog: https://develbranch.com\n# email: contact[at]develbranch.com\n\nimport pefile\n\nimport struct\n\nimport re\n\nimport argparse\n\nfrom unicorn import *\n\nfrom unicorn.x86_const import *\n\nfrom capstone import *\n\nfrom keystone import *\n\nfrom datetime import datetime\n\nclass SalityExtractor():\n\ndef __init__(self, sample_file=None, output_file=None):\n\nself.md = Cs(CS_ARCH_X86, CS_MODE_32)\n\nself.md.detail = True\n\nself.sample = sample_file\n\nself.output = output_file\n\nself.detected = False\n\nself.control_server = []\n\n# utility methods\n\n@staticmethod\n\n# display log message\n\ndef log(msg):\n\nprint str(datetime.now()), msg\n\n# dump all mapped memory to file\n\ndef dump_to_file(self, mu, pe, filename, new_ep_rva=None, runable=True):\n\nmemory_mapped_image = bytearray(mu.mem_read(pe.OPTIONAL_HEADER.ImageBase, pe.OPTIONAL_HEADER.SizeOfImage))\n\nfor section in pe.sections:\n\nva_adj = pe.adjust_SectionAlignment(section.VirtualAddress, pe.OPTIONAL_HEADER.SectionAlignment,\n\npe.OPTIONAL_HEADER.FileAlignment)\n\nif section.Misc_VirtualSize == 0 or section.SizeOfRawData == 0:\n\ncontinue\n\nif section.SizeOfRawData > len(memory_mapped_image):\n\ncontinue\n\nif pe.adjust_FileAlignment(section.PointerToRawData, pe.OPTIONAL_HEADER.FileAlignment) > len(\n\nmemory_mapped_image):\n\ncontinue\n\npe.set_bytes_at_rva(va_adj, bytes(memory_mapped_image[va_adj: va_adj + section.SizeOfRawData]))\n\n\n-----\n\npe te( e a e)\n# set new entrypoint\nif new_ep_rva is not None:\nself.log(\"New entry point %08x\" % new_ep_rva)\nf = open(filename, 'r+b')\nf.seek(pe.DOS_HEADER.e_lfanew + 4 + pe.FILE_HEADER.sizeof() + 0x10)\nf.write(struct.pack(' if not runable:\n_f.seek(0)_\n_f.write('mz')_\n_f.close()_\n_print ('[+] Save to file {}'.format(filename))_\n\n_@staticmethod_\n_def assembler(address, assembly):_\n_ks = Ks(KS_ARCH_X86, KS_MODE_32)_\n_encoding, _ = ks.asm(assembly, address)_\n_return ''.join(chr(e) for e in encoding)_\n\n_# callback for tracing invalid memory access (READ or WRITE)_\n_# noinspection PyUnusedLocal_\n_@staticmethod_\n_def hook_mem_invalid(uc, access, address, size, value, user_data):_\n_# return False to indicate we want to stop emulation_\n_return False_\n\n_# callback for tracing fake-IAT interrupt_\n_# noinspection PyUnusedLocal_\n_def hook_intr(self, uc, intno, user_data):_\n_# only handle fake-IAT interrupt_\n_if intno != 0xff:_\n_print (\"got interrupt %x ???\" % intno)_\n_uc.emu_stop()_\n_return_\n_eax = uc.reg_read(UC_X86_REG_EAX)_\n_dll_name, address, name, _ = self.import_addrs[eax]_\n_if 'kernel32' in dll_name.lower():_\n_if name == 'LoadLibraryA':_\n_uc.reg_write(UC_X86_REG_EAX, 0xabababab)_\n_elif name == 'GetProcAddress':_\n_uc.reg_write(UC_X86_REG_EAX, 0xbcbcbcbc)_\n_elif name == 'VirtualProtect':_\n_uc.reg_write(UC_X86_REG_EAX, 0x1)_\n\n_# noinspection PyBroadException_\n_# noinspection PyUnresolvedReferences_\n_def emulate_sality_dll(self, memory):_\n_try:_\n_pe = pefile.PE(data=memory, fast_load=True)_\n_except:_\n_return None_\n\n_self.log(\"[+] Parse Sality DLL\")_\n_pe.parse_data_directories()_\n_self.import_addrs = []_\n_for entry in pe.DIRECTORY_ENTRY_IMPORT:_\n_for imp in entry.imports:_\n_nparam = 1_\n_if entry.dll.lower() in 'kernel32.dll':_\n_if imp.name == 'LoadLibraryA':_\n_nparam = 1_\n_elif imp.name == 'GetProcAddress':_\n_nparam = 2_\n_elif imp.name == 'VirtualProtect':_\n_nparam = 4_\n\n\n-----\n\n_se_ _po t_add s appe d((e t y d,_ _p add ess,_ _p_ _a_ _e,_ _pa a_ _))_\n\n_self.log('[+] Analyze UPX stub code')_\n_entry_point_code = str(pe.get_memory_mapped_image())[pe.OPTIONAL_HEADER.AddressOfEntryPoint:]_\n_begin_addr = pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.AddressOfEntryPoint_\n_end_addr = begin_addr_\n_for i in self.md.disasm(str(entry_point_code), begin_addr):_\n_if i.mnemonic.lower() in ['popad', 'popal', 'popa']:_\n_end_addr = i.address + 1_\n_break_\n_self.log(\"[+] Initialize emulator in X86-32bit mode\")_\n_mu = Uc(UC_ARCH_X86, UC_MODE_32)_\n_# map memory for this emulation_\n_mu.mem_map(pe.OPTIONAL_HEADER.ImageBase, pe.OPTIONAL_HEADER.SizeOfImage)_\n_# stack_\n_stack_addr = 0x1000_\n_stack_size = 0x4000_\n_mu.mem_map(stack_addr, stack_size)_\n_# write machine code to be emulated to memory_\n_mu.mem_write(pe.OPTIONAL_HEADER.ImageBase, pe.get_memory_mapped_image())_\n_# initialize machine registers_\n_mu.reg_write(UC_X86_REG_ESP, stack_addr + stack_size / 2)_\n_# intercept invalid memory events_\n_mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, self.hook_mem_invalid)_\n_# build IAT table_\n_iat_addr = 0x10000_\n_e = self.assembler(iat_addr, 'mov eax, 1;int 0xff;ret 0xffff')_\n_iat_size_adj = pe.adjust_SectionAlignment(len(self.import_addrs) * len(e) + pe.OPTIONAL_HEADER.SectionAlignment,_\n_pe.OPTIONAL_HEADER.SectionAlignment, pe.OPTIONAL_HEADER.FileAlignment)_\n_mu.mem_map(iat_addr, iat_size_adj)_\n_for i in range(len(self.import_addrs)):_\n__, iat_entry, _, nparam = self.import_addrs[i]_\n_func_addr = iat_addr + i * len(e)_\n_if nparam > 1:_\n_c = self.assembler(func_addr, 'mov eax, %x;int 0xff;ret %x' % (i, nparam))_\n_else:_\n_c = self.assembler(func_addr, 'mov eax, %x;int 0xff;ret' % i)_\n_mu.mem_write(func_addr, c)_\n_mu.mem_write(iat_entry, struct.pack(' # handle interrupt ourselves_\n_mu.hook_add(UC_HOOK_INTR, self.hook_intr)_\n_self.log('[+] Emulate machine code')_\n_mu.emu_start(begin_addr, end_addr)_\n_decoded_memory = mu.mem_read(pe.OPTIONAL_HEADER.ImageBase, pe.OPTIONAL_HEADER.SizeOfImage)_\n_return decoded_memory_\n\n_@staticmethod_\n_def check_sality(code):_\n_signature = [(0,_\n_'\\xE8\\x00\\x00\\x00\\x00\\x5D\\x8B\\xC5\\x81\\xED\\x05\\x10\\x40\\x00\\x8A\\x9D\\x73\\x27\\x40\\x00\\x84\\xDB\\x74\\x13\\x81\\xC4'),_\n_(0x23,_\n_'\\x89\\x85\\x54\\x12\\x40\\x00\\xEB\\x19\\xC7\\x85\\x4D\\x14\\x40\\x00\\x22\\x22\\x22\\x22\\xC7\\x85\\x3A\\x14\\x40\\x00\\x33\\x33\\x33\\x33\\xE9\\x82\\x00\\x00\\x00\\x3_\n_for offset, s in signature:_\n_if s != code[offset:offset + len(s)]:_\n_return False_\n_return True_\n\n_# callback for tracing instructions_\n_# noinspection PyUnusedLocal_\n_def hook_code(self, uc, address, size, user_data):_\n_# I expect 'retn'_\n_if size != 1:_\n_return_\n_if uc.mem_read(address, size) != '\\xc3':_\n_return_\n\n\n-----\n\n_esp_ _uc eg_ ead(UC_ 86__ _G_ S )_\n_sality_entrypoint = struct.unpack(' code = uc.mem_read(sality_entrypoint, 0x100)_\n_if not self.check_sality(code):_\n_return_\n_self.detected = True_\n_uc.emu_stop()_\n\n_# noinspection PyBroadException_\n_def extract(self):_\n_if self.sample is None:_\n_return_\n_self.log(\"[+] Parse PE File\")_\n_try:_\n_self.sample.seek(0)_\n_except:_\n_pass_\n_pe = pefile.PE(data=self.sample.read(), fast_load=True)_\n_self.log(\"[+] Initialize emulator in X86-32bit mode\")_\n_mu = Uc(UC_ARCH_X86, UC_MODE_32)_\n_# map memory for this emulation_\n_mu.mem_map(pe.OPTIONAL_HEADER.ImageBase, pe.OPTIONAL_HEADER.SizeOfImage)_\n_# stack_\n_stack_addr = 0x1000_\n_stack_size = 0x4000_\n_mu.mem_map(stack_addr, stack_size)_\n_# write machine code to be emulated to memory_\n_mu.mem_write(pe.OPTIONAL_HEADER.ImageBase, pe.get_memory_mapped_image())_\n_# initialize machine registers_\n_mu.reg_write(UC_X86_REG_ESP, stack_addr + stack_size / 2)_\n_# tracing all instructions with customized callback_\n_mu.hook_add(UC_HOOK_CODE, self.hook_code)_\n_# intercept invalid memory events_\n_mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, self.hook_mem_invalid)_\n_self.log('[+] Emulate machine code')_\n_begin_addr = pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.AddressOfEntryPoint_\n_end_addr = pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.SizeOfImage_\n_try:_\n_mu.emu_start(begin_addr, end_addr)_\n_except Exception as e:_\n_self.log('[-] Emulator error: %s' % e)_\n_return_\n_if not self.detected:_\n_self.log('[-] Sality not found')_\n_return_\n_self.log(\"[+] Find Sality section\")_\n_sality_section_addr = None_\n_eip_rva = mu.reg_read(UC_X86_REG_EIP) - pe.OPTIONAL_HEADER.ImageBase_\n_for section in pe.sections:_\n_va_adj = pe.adjust_SectionAlignment(section.VirtualAddress, pe.OPTIONAL_HEADER.SectionAlignment,_\n_pe.OPTIONAL_HEADER.FileAlignment)_\n_if va_adj <= eip_rva < va_adj + section.Misc_VirtualSize:_\n_sality_section_addr = va_adj_\n_break_\n_if sality_section_addr is None:_\n_self.log(\"[-] Sality section not found\")_\n_return_\n_mapped_memory = str(mu.mem_read(pe.OPTIONAL_HEADER.ImageBase + sality_section_addr,_\n_pe.OPTIONAL_HEADER.SizeOfImage - sality_section_addr))_\n_self.detect_control_server(mapped_memory)_\n_for m in re.finditer('MZ', mapped_memory):_\n_sality_dll = mapped_memory[m.start():]_\n_decoded_sality_dll = self.emulate_sality_dll(sality_dll)_\n_if decoded_sality_dll is None:_\n_continue_\n\n\n-----\n\n_se detect_co t o _se_ _e (decoded_sa ty_d )_\n_if self.output is not None:_\n_self.output.write(decoded_sality_dll)_\n_self.log(\"[+] Write Sality DLL to file successfully\")_\n_self.log(\"[+] Analyze Sality DLL successfully\")_\n\n_def detect_control_server(self, memory):_\n_# detect URL_\n_urls = re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', memory)_\n_for _ in urls:_\n_self.control_server.append(str(_))_\n\n_def get_args():_\n_\"\"\"This function parses and return arguments passed in\"\"\"_\n_# Assign description to the help doc_\n_parser = argparse.ArgumentParser(description='Script extracts URLs of Win32-Sality variants from a given file.')_\n_# Add arguments_\n_parser.add_argument('-z', '--zip', action='store_true')_\n_parser.add_argument('-p', '--password', type=str, help='Password to open zip file', required=False,_\n_default=None)_\n_parser.add_argument('-n', '--name', type=str, help='File name in zip file', required=False, default=None)_\n_parser.add_argument('-d', '--dump', type=str, help='Dump sality DLL to file', required=False, default=None)_\n_parser.add_argument('file', nargs='?')_\n_# Array for all arguments passed to script_\n_args = parser.parse_args()_\n_file_name = None_\n_if args.file is not None and len(args.file) > 0:_\n_file_name = args.file_\n_# Return all variable values_\n_return file_name, args.zip, args.password, args.name, args.dump_\n\n_def main():_\n_# Match return values from get_args()_\n_# and assign to their respective variables_\n_z = None_\n_file_name, is_zip, password, name, dump = get_args()_\n_if file_name is None:_\n_print \"Enter file name\"_\n_return_\n_if is_zip:_\n_from zipfile import ZipFile_\n\n_z = ZipFile(file_name)_\n_f = z.open(name, 'r', password)_\n_else:_\n_f = open(file_name, 'rb')_\n_if dump is not None:_\n_d = open(dump, 'wb')_\n_else:_\n_d = None_\n_sd = SalityExtractor(f, d)_\n_sd.extract()_\n_if len(sd.control_server) > 0:_\n_print sd.control_server_\n_else:_\n_print 'Found nothing'_\n_if f is not None:_\n_f.close()_\n_if z is not None:_\n_z.close()_\n_if d is not None:_\n_d close()_\n\n\n-----\n\n_if __name__ == '__main__':_\n_main()_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-10-29 - Sality Configuration Extractor (sality_extractor.py).pdf"
    ],
    "report_names": [
        "2017-10-29 - Sality Configuration Extractor (sality_extractor.py).pdf"
    ],
    "threat_actors": [
        {
            "id": "1162e0d4-b69c-423d-a4da-f3080d1d2b0c",
            "created_at": "2023-01-06T13:46:38.508262Z",
            "updated_at": "2025-03-27T02:00:02.851407Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "Gaza Hackers Team",
                "Gaza cybergang",
                "Gaza Cybergang",
                "Operation Molerats",
                "Extreme Jackal",
                "ALUMINUM SARATOGA",
                "G0021",
                "BLACKSTEM"
            ],
            "source_name": "MISPGALAXY:Molerats",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "0c502f6d-640d-4e69-bfb8-328ba6540d4f",
            "created_at": "2022-10-25T15:50:23.756782Z",
            "updated_at": "2025-03-27T02:00:55.539397Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "Molerats",
                "Operation Molerats",
                "Gaza Cybergang"
            ],
            "source_name": "MITRE:Molerats",
            "tools": [
                "MoleNet",
                "DustySky",
                "DropBook",
                "SharpStage",
                "PoisonIvy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "847f600c-cf90-44c0-8b39-fb0d5adfcef4",
            "created_at": "2022-10-25T16:07:23.875541Z",
            "updated_at": "2025-03-27T02:02:10.005591Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "ATK 89",
                "Aluminum Saratoga",
                "Extreme Jackal",
                "Gaza Cybergang",
                "Gaza Hackers Team",
                "Molerats",
                "Operation DustySky",
                "Operation DustySky Part 2",
                "Operation Molerats",
                "Operation Moonlight",
                "Operation SneakyPastes",
                "Operation TopHat",
                "TA402",
                "TAG-CT5"
            ],
            "source_name": "ETDA:Molerats",
            "tools": [
                "BadPatch",
                "Bladabindi",
                "BrittleBush",
                "Chymine",
                "CinaRAT",
                "Darkmoon",
                "Downeks",
                "DropBook",
                "DustySky",
                "ExtRat",
                "Gen:Trojan.Heur.PT",
                "H-Worm",
                "H-Worm RAT",
                "Houdini",
                "Houdini RAT",
                "Hworm",
                "Iniduoh",
                "IronWind",
                "Jenxcus",
                "JhoneRAT",
                "Jorik",
                "KasperAgent",
                "Kognito",
                "LastConn",
                "Micropsia",
                "MoleNet",
                "Molerat Loader",
                "NeD Worm",
                "NimbleMamba",
                "Njw0rm",
                "Pierogi",
                "Poison Ivy",
                "Quasar RAT",
                "QuasarRAT",
                "SPIVY",
                "Scote",
                "SharpSploit",
                "SharpStage",
                "WSHRAT",
                "WelcomeChat",
                "Xtreme RAT",
                "XtremeRAT",
                "Yggdrasil",
                "dinihou",
                "dunihi",
                "njRAT",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536062,
    "ts_updated_at": 1743041164,
    "ts_creation_date": 1653760078,
    "ts_modification_date": 1653760078,
    "files": {
        "pdf": "https://archive.orkl.eu/ec0f3864bcf4a0ca69df91ed65fcdc91af31a293.pdf",
        "text": "https://archive.orkl.eu/ec0f3864bcf4a0ca69df91ed65fcdc91af31a293.txt",
        "img": "https://archive.orkl.eu/ec0f3864bcf4a0ca69df91ed65fcdc91af31a293.jpg"
    }
}