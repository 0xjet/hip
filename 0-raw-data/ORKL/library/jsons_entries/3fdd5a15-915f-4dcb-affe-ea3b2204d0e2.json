{
    "id": "3fdd5a15-915f-4dcb-affe-ea3b2204d0e2",
    "created_at": "2022-10-25T16:48:21.530476Z",
    "updated_at": "2025-03-27T02:09:55.056755Z",
    "deleted_at": null,
    "sha1_hash": "f1a02cdc30e256d40d50aa8939f9aa79313324b7",
    "title": "[RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1",
    "authors": "",
    "file_creation_date": "2020-12-21T03:53:47Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 2657414,
    "plain_text": "# [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1\n\n**blog.vincss.net/2020/12/re018-1-analyzing-new-malware-of-china-panda-hacker-group-used-to-attack-supply-chain-against-**\nvietnam-government-certification-authority.html\n\n**I. Introduction**\n\nIn process of monitoring and analyzing malware samples, we discovered an interesting blog post\n[of NTT here. Following the sample hash in this report, we noticed a hash on VirusTotal:](https://insight-jp.nttsecurity.com/post/102glv5/pandas-new-arsenal-part-3-smanager)\n\n_Figure 1. Hash’s information in the NTT blog_\n\nOn the event that a hacker group believed to be from Russia attacked and exploited the software\nsupply chain to target a series of major US agencies, along with discovery that the keyword\n**eToken.exe belongs to the software that is quite popularly used in agencies, organizations and**\nbusinesses in Vietnam, we have used eToken.exe and SafeNet as keywords for searching on\nVirusTotal and Google. As a result, we uncovered information about two remarkable installation\n[files (1, 2) that have been uploaded to VirusTotal since August 2020:](https://www.virustotal.com/gui/file/6be34df727fcb79123e4e8f472ad24b698d83395fb17d4db019e9976f485cd83/detection)\n\n\n-----\n\n_Figure 2. Information look up on VirusTotal_\n\nThe name of the installation files are quite familiar: gca01-client-v2-x32-8.3.msi and gca01**client-v2-x64-8.3.msi, We have tried to download these two files from the website and they**\nhave the same hash value. However, at the present time, all files on the VGCA homepage have\nbeen removed and replaced with the official clean version. According to the initial assessment, we\nconsider this could be an attack campaign aimed at the software supply chain that can be\nleveraged to target important agencies, organizations and businesses in Vietnam.\n\nOn December 17, ESET announced a discovery of an attack on APT they called \"th Operation\nSignSight\" against the Vietnam Government Certification Authority (VGCA). In that report,\nESET said they have also notified VNCERT and VGCA and VGCA has confirmed that they were\naware of the attack before and notified the users who downloaded the trojanized software.\n\nAt the time of analysis, we have obtained two setup files that have been tampered by hackers.\nThis blog post series will focus on analyzing the signatures and techniques that hackers have\napplied to malicious samples in these two installation files.\n\n**II. Analyze installation file**\n\nThis application is named as \" **SafeNet Authentication Clients\" from SafeNet .Inc company.**\nPortable Executable (PE) files are mostly signed with SafeNet certificates.\n\n\n-----\n\n_Figure 3. PE files signed with SafeNet certificate_\n\nBy using UniExtract tool, we extracted the entire file from an installer (x64 setup file). The total\nnumber of files is 218 files, 68 subfolders, the total size is 75.1 MB (78,778,368 bytes). To find\nout which file has been implanted by hackers, we only focus on analyzing and identifying\nunsigned PE files.\n\nWith the help of sigcheck tool in Micorsoft's SysInternals Suite, with the test parameters is\nsigned, hash, scan all PE files, scan the hash on VirusTotal, the output is csv file. Then sorting by\nunsigned file, resulting from VirusTotal, we discovered that eToken.exe is the file was\nimplanted by the hacker.\n\n_Figure 4. Discovered file was implanted by hacker_\n\nThe hash of this eToken.exe matches with the one in NTTSecurity's report. Another strange\npoint is that it’s a 32bit PE but located in the x64 directory, the version information such as\n“Company, Description, Product…” are not valid for such a large company application. Here is\n[the scan result of the eToken file on VirusTotal.](https://www.virustotal.com/gui/file/97a5fe1d2174e9d34cee8c1d6751bf01f99d8f40b1ae0bce205b8f2f0483225c/detection)\n\nSince this application is built with Visual C ++ of Visual Studio 2005 which is old version, and\nuses the Qt4 library, some of the dll files of this installer are also unsigned. We checked each file\nand determined that the files were clean, leaving only three suspicious files:\n**RegistereToken.exe, eTOKCSP.dll and eTOKCSP64.dll.**\n\nSo eToken.exe file is a malware that hackers have added to the installation of the software suite.\nTo find out how eToken.exe is executed, we analyze the installation file: msi file ( Microsoft\n_Windows Installer file): gca01-client-v2-x64-8.3.msi_\n\nExtracting the msi file to raw format before installing, we obtained two **.cab files (Microsoft**\n_Cabinet file): Data1.cab and Cabs.w1.cab. This is anomaly because a normal msi file has only_\none main .cab file. Check the Data1.cab file and the MSI log text file, **eToken.exe and**\n**RegistereToken.exe are in Data1.cab file. And both .exe files have no GUID ID info:**\n\n\n-----\n\n_Figure 5. Exe files do not have a GUID ID info_\n\nContinue checking the features: DriverFeature, and two files eToken.exe and\n**RegistereToken.exe msi file with Microsoft's Orca tool (a specialized tool for analyze and**\n_modify msi files). Through a search, the hacker has added a custom action: RegisterToken_\n(without \"e\" before Token) to the msi file and added that **CustomAction at the end of**\n**InstallExecuteSequence. RegistereToken.exe will be called with the parameter is**\n**eToken.exe:**\n\n_Figure 6. Hacker implanted a custom action_\n\nAnalyzing the RegistereToken.exe file, we see that this file was built on \"Wednesday,\n**22.07.2020 07:40:31 UTC\", ie 07/22/2020, 2h40m31s PM GMT +7, PE64, using VC ++**\n**2013:**\n\n_Figure 7. Information of the RegistereToken.exe file_\n\n**RegistereToken.exe's pseudo code only calls the WinExec API to execute the passed in**\nargument:\n\n\n-----\n\n_Figure 8. Tasks of RegistereToken.exe_\n\nWith all the information above and based on the timestamp in the **Data1.cab and**\n**RegistereToken.exe files, we can conclude:**\n\nHacker has created and modified the .msi file and created the Data1.cab file at\ntimestamp: 07/20/2020 - 15:15 UTC time, added the eToken.exe file at this time.\nBuild RegistereToken.exe file at timestamp: 22/07/2020 - 07:40 UTC\nAdd RegistereToken.exe file to Data1.cab at timestamp: 22/07/2020 - 08:40 UTC\n\nNote: According to Cab file format, the two Date and Time fields of a file in the cab file are DOS\n**Datetime format, each of which is a Word 2 bytes which reflect the time when the file was**\nadded according to DOS time. Cab file processing programs will convert and display in UTC time.\n[That is, the above UTC times are the current time on the hacker machine. See more here.](https://docs.microsoft.com/en-us/windows/win32/sysinfo/ms-dos-date-and-time)\n\n_Figure 9. MS DOS Datetime Information_\n\n**III. Analyze eToken.exe**\n\n\n-----\n\n**1. Analyze PE Structure**\n\nFile eToken.exe:\n\nSize: 192 KB (196,608 bytes)\nMD5: 830DD354A31EF40856978616F35BD6B7\nSHA256:\n97A5FE1D2174E9D34CEE8C1D6751BF01F99D8F40B1AE0BCE205B8F2F0483225C\n\nInformation about compiler, RichID and build timestamp:\n\nBuild with VC ++ 6 of Microsoft Visual Studio, Service Pack 6.\nBuild at: 26/04/2020 - 15:12:58 UTC\nChecksum is correct, file has not been modified PE Header.\nLinking with MFC42.dll library, Microsoft Foundation Class v4.2 library of Microsoft, is a\nlibrary supporting GUI programming on Windows, always included in Visual Studio suite.\nLink with a special library: dbghelp.dll. Use the MakeSureDirectoryPathExist API\n[function. See more here.](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-makesuredirectorypathexists)\n\nChecking the resource section of the file, we determined that this is a Dialog application, created\nby MFC Wizard of Visual Studio 6. The project name is VVSup, which means the .exe file when\nbuilt out would be VVSup.exe.\n\n_Figure 10. File's resource information_\n\n\n-----\n\n**2. Static code analysis**\n\n**eToken.exe (VVSup.exe) is built with dynamic link DLL mode with MFC42.dll, so the .exe**\nfile will be small and the functions of the MFC42 libirary will be easily identified via the name\nimport of the DLL. The name mangling rule of Microsoft VC ++ compiler reflects the class name,\nfunction name, parameter name, call type... of functions. IDA helps us to define the functions\nimport by ordinal of MFC42.dll using the file mfc42.ids and mfc42.idt included with IDA.\n\nHowever, VVSup is built with the RTTI (Runtime Type Information) option is disabled, so\nthere is no information about the RTTI and Virtual Method Table of all classes in the file. We\nonly have RTTI of class type_info, the root class of RTTI.\n\n_Figure 11. RTTI Info of type_info class_\n\nThe analysis will show how to define classes, recreate the code of this malware, and share\nexperience in applying when analyzing malwares/files using MFC.\n\nPlugins used:\n\nSimabus’s ClassInformer\nMatrosov’s HexRaysCodeXplorer\n**MFC_Helper**\n\nThe MFC C++ source code can be found in the src\\mfc directory of the Visual Studio installer.\n[Since MFC4.2 (MFC of VS6) is very old, it can be found on Github. We refer here. About the](https://github.com/dblock/msiext/tree/master/externals/WinDDK/7600.16385.1/inc/mfc42)\n[relationship chart of the classes of MFC (Hierarchy Chart), you can see at this link.](https://docs.microsoft.com/en-us/cpp/mfc/hierarchy-chart?view=msvc-160)\n\nThree important dlls file to diffing/compare with MFC malware, for example in this sample\n**eToken, are mfc42.dll, mfc42d.dll, mfco42d.dll. You can find and download the correct**\ndebug symbol file (.pdb) of the dlls you have. The most important one is **mfc42d.dll (debug**\n_build), since its .pdb will contain full information about the types, enumes, classes, and vtables_\nof the MFC classes. We export local types from mfc42d.dll to .h file, then import into our idb\ndatabase. IDA's Parse C ++ has an error, unable to parse the \"<>\" template syntax, so we find and\nreplace pairs of \"<\" and \">\" to \"_\" in .h files.\n\nParallel opening mfc42d.dll in new IDA together with IDA is parsing malware, copy names,\ntypes of classes, functions from mfc42d.dll. As mentioned, this malware is an MFC Dialog\napplication, so we will definitely have the following classes in the malware: CObject,\n**CCmdTarget, CWinThread, CWnd, CDialog. According to the MFC Wizard's auto-naming**\nrule, we have classes with the following names: CVVSupApp (inherited from CWinApp),\n**CAboutDlg (dialog About, resID = 100), CVVSupDlg (main dialog, resID = 102).**\n\nScan results of vtables, classes of two plugins ClassInformer and HexRaysCodeXplorer.\n\n\n-----\n\n_Figure 12. Scanning vtables, classes result_\n\nUse MFC_Helper scan CRuntimeClass, as expected, CVVSupDlg has CRuntimeClass and\nadd another class: CVVSupDlgAutoProxy. It shows that the hacker when running the MFC\nWizard, clicked to select support OLE Control.\n\n_Figure 13. Detect classe after run MFC_Helper_\n\nBased on the import function CWinApp::GetRuntimeClass, we can determine CVVSupApp\nvtable, and based on CDialog::GetRuntimeClass we can define two vtables of the other two\ndialogs. But which dialog is About, which dialog is a malware dialog? Identify all the internal\nstructures of MFX such as AFX_MSGMAP, AFX_DISPMAP, AFX_INTERFACEMAP...\n\nUsing the Xref to feature call the CDialog constructor: void __thiscall CDialog::CDialog\n**(CDialog *this, unsigned int nIDTemplate, CWnd *pParentWnd), nIDTemplate is the**\n**resID of the dialog, we define the vtable of** **CAboutDlg and CMalwareDlg. Because**\n**CMalwareDlg does not have CRuntimeClass and RTTI, so it is temporarily named like that.**\nThe hacker deleted the DECLARE_DYNAMIC_CREATE line of these two classes and the\n**CVVSupApp class when build.**\n\n\n-----\n\n_Figure 14. Identify vtable of CAboutDlg and CMalwareDlg_\n\nRelational Classes table of this malware:\n\n\n-----\n\n_Figure 15. Relational classes table of this malware_\n\nCopy the names of functions, types, function types, parameters ... from the respective parent\nclasses of the above classes, in the correct order in the vtable, identify the generated MFC Wizard\nfunctions and the functions the hacker wrote.\n\n_Figure 16. Result after copy name of functions, types, function types, parameters_\n\nEvery MFC application has a global variable called theApp, belonging to the main class\n**CXXXApp inheriting from CWinApp. In the case of this malware are: CVVSupApp theApp;**\nThis global variable is initialized by C RTL in the start function, called before main/WinMain,\nin table __xc_a. The functions in this table call after the C RTL constructors in __xi_a. These\ntables are the parameters passed to the internal _initterm function of C RTL.\n\n\n-----\n\n_Figure 17. TheApp global variable in the MFC application_\n\nThe flowchart of creating and executing an MFC application is as follows:\n\n_Figure 18. Flowchart of creating and executing an MFC application_\n\nThe CVVSupApp :: InitInstance function is also a common code generated by MFC wizard\n\n\n-----\n\n_Figure 19. CVVSupApp::InitInstance function_\n\nConstructor of CVVSupDlg: void CVVSupDlg::CVVSupDlg() is also common code\ngenerated by MFC Wizard. But in CVVSupDlg::OnInitDialog, which is called from\n**CVVSupDlg::DoModal(), we can see immediately, at the end of the code that the MFC Wizard**\ngenerated, CMalwareDlg is initialized and shown, then the malware exits forcibly **exit (0).**\n\n\n-----\n\n_Figure 20. CMalwareDlg was created and shown_\n\nThe value 129 is the resID of the CMalwareDlg dialog, and sizeof(CMalwareDlg) =\n**0x290, which is larger than the size of the parent CDialog. It proves that** **CMalwareDlg was**\nadded by hackers to some data members. Through analysis, we recreated the data members of\n**CMalwareDlg:**\n\n_Figure 21. Recreate data members of CMalwareDlg_\n\nThe CMalwareDlg::CMalwareDlg Constructor does the following initialization jobs. Note the\ncopy string \"192.168\" into the field m szMask:\n\n\n-----\n\n_Figure 22. Copy \"192.168\" string to m_szMask field_\n\nWhen shown, CMalwareDlg::OnInitDialog will be called, and the main function that is\nimportant for doing the malware's task is called here:\n\n_Figure 23. The Infect main function will do the malware's job_\n\nThe Infect (we named) function is relatively long, so it should be presented via the flowchart\nbelow:\n\n_Figure 24. Infect function flowchart_\n\n\n-----\n\nWe ll go into detail each of the important child functions called by the **Infect function of the**\n**CMalwareDlg class. The UserIsAdmin function, using the IsUserAdmin() API of**\n**shell32.dll:**\n\n_Figure 25. UserIsAdmin fuction_\n\n**GetSomeAPIAddrs function is a redundant function, function pointers are taken but**\ncompletely unused. We guess this could be an old code.\n\n_Figure 26. GetSomeAPIAddrs function_\n\n\n-----\n\nThe Base64Decode function is like other Base64 decode functions, except that the Base64 code\ntable is copied by the hacker to a char arrary m_szBase64Table and accessed from here. After\nbeing decoded Base64, the original ServiceName\n\"TmV0QmlvcyBNZXNzYWdlciBSZWdpc3Rlcg==\" will be \" **NetBios Messager**\n**Register\". The original ServiceDescription**\n\"TmV0QmlvcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gc3lzdGVtIGNvbXBvbmVudHMu\"\nwould be \"NetBios communication between system components.\"\n\nThe ExtractCabFile function is a global function, not part of the **CMalwareDlg class. Note**\nthat the file is created with the attribute hidden.\n\n_Figure 27. ExtractCabFile function_\n\nThe .cab file is completely embedded in the .data section, **size = 94874 (0x1729A). Hackers**\ndeclared the following equivalent: \"static BYTE g_abCabFile[] = {0xXXXX, 0xYYYY};\"\n(no const, so it will be located in .data section). Extracting that area, we have a **.cab file**\ncontaining a file, named smanager_ssl.dll, the date added to the cab is **04/26/2020 - 23:11**\n**UTC, build date 26.04.2020 15:11:24 UTC.**\n\n_Figure 28. The embedded .cab file contains the file smanager_ssl.dll_\n\nThe smanager_ssl.dll file (netapi32.dll) will be analyzed in the next post because it is\nrelatively complex.\n\n\n-----\n\n_Figure 29. RunExtrac32Exe function_\n\nThe ExecuteAndWait function is also a global function, using the ShellExecuteExA API to\ncall and wait until the execution completes.\n\n_Figure 30. ExecuteAndWait function_\n\nThe Config of the Proxy on the victim machine is defined by the hacker through a struct as shown,\n**PROXY_TYPE is an enum:**\n\n_Figure 31. struct PROXY_CONFIG_\n\n\n-----\n\nThe ReadProxyConfig function will read from the victim s registry first, otherwise it will read\nfrom the Firefox pref.js file. We are still not clear why hackers tried to read from Firefox, maybe\nthey did a reconnaisance to learn about the commonly used web browsers at the target.\n\n_Figure 32. ReadProxyConfig function_\n\nThe ReadProxyConfigFromRegistry function is a bit long so there are only important parts:\n\n_Figure 33. The main job of the ReadProxyConfigFromRegistry function_\n\n\n-----\n\nThe ReadProxyConfigFromFireFox function is very long so we won t cover it in detail here.\nThe UpdateFile function uses the memsearh equivalent function to find a string in the file's\ncontent, and C&C Info will be written at the found location. In the case of this malware, the mask\nstring is \"192.168\".\n\n_Figure 34: The UpdateFile function uses the memsearh equivalent function to find a string_\n\nWe recreated the C&C Info struct as follows:\n\n_Figure 35. struct of C&C info_\n\nAnd C&C info has been hardcoded by hackers in the code:\n\n\n-----\n\n_Figure 36. C&C information is hardcoded in the malicious code_\n\nThe content of smanager_ssl.dll* (netapi32.dll**) is original and after being updated from\n**g_CCInfo structure via:**\n\n_Figure 37. Contents of smanager_ssl.dll file (netapi32.dll) before and after being updated_\n\nThe function to load the extracted file and create the Scheduler Task:\n\n\n-----\n\n_Figure 38. Function LoadDllAndCreateSchedulerTask to load the extracted file and create a Scheduler Task_\n\nThen, if the malware is run with admin, it will register as a **ServiceDll, with the name**\nmentioned above, the Service registry key chosen at random from a table of ten elements, and\nappended \"Ex\". These series include: \"Winmads\", \"Winrs\", \"Vsssvr\", \"PlugSvr\", \"WaRpc\",\n\"GuiSvr\", \"WlanSvr\", \"DisSvr\", \"MediaSvr\", \"NvdiaSvr\".\n\nAfter appending Ex by the sprintf function, the registry key on the victim machine is created\nunder the branch HKLM\\SOFTWARE\\Microsoft\\Windows\n**NT\\CurrentVersion\\Svchost will be one of the following strings: “WinmadsEx”,**\n“WinrsEx”, “VsssvrEx”, “PlugSvrEx”, “WaRpcEx”, “GuiSvrEx”, “WlanSvrEx”,\n“DisSvrEx”, “MediaSvrEx”, “NvdiaSvrEx”.\n\nSince the function is also a bit long, only the main points are covered here:\n\n_Figure 39. Create a registry key on a victim machine_\n\n\n-----\n\n_Figure 40. Create service on victim machine_\n\nThe RegistryCall function is a self-written function by hacker, it is a global function, also only\ndoing tasks with the Registry. From our point of view, hackers' programming styles are extremely\nmessy and inconsistent (maybe this is how they intentionally confusing), which made it difficult\nfor us to analyze. After registering as a Dll service, the Infect function completes and returns.\nMalware will exit because of the above call to exit(0) on OnInitDialog\n\nWe will provide .xml file containing analysis information on IDA so anyone interested in this\nmalware can use it to re-import IDA and Ghidra using Ghidra's plugin xml_importer.py.\n\n\n-----\n\nThe IOCs of the malicious code have been noted in the article. You can write your own **.bat file or**\nscript using PowerShell, VBS ... to find and remove this malware on the victim's computers.\n\n**Note:**\n\nOriginal smanager_ssl.dll\n\nMD5: C11E25278417F985CC968C1E361A0FB0\nSHA256:\nF659B269FBE4128588F7A2FA4D6022CC74E508D28EEE05C5AFF26CC23B7BD1A5\n\n**netapi32.dll (ie smanager_ssl.dll has updated CCInfo):**\n\nMD5: 43CE409C21CAD2EF41C9E1725CA12CEA\nSHA256:\n6C1DB6C3D32C921858A4272E8CC7D78280B46BAD20A1DE23833CBE2956EEBF75\n\n[Click here for Vietnamese version: Part 1, Part 2](https://blog.vincss.net/2020/12/phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-Panda.html)\n\n**Trương Quốc Ngân (aka HTC)**\n\n**Malware Analysis - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.12.19.Panda_Vietnam/blog.vincss.net-RE018-1%20Analyzing%20new%20malware%20of%20China%20Panda%20hacker%20group%20used%20to%20attack%20supply%20chain%20against%20Vietnam.pdf"
    ],
    "report_names": [
        "blog.vincss.net-RE018-1 Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bbdb2d7d-4bf4-4100-a108-f4742cfd69ff",
            "created_at": "2022-10-25T16:07:24.01101Z",
            "updated_at": "2025-03-27T02:02:10.074776Z",
            "deleted_at": null,
            "main_name": "Operation SignSight",
            "aliases": [],
            "source_name": "ETDA:Operation SignSight",
            "tools": [
                "Mimikatz",
                "PhantomNet",
                "SManager"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041395,
    "ts_creation_date": 1608522827,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/f1a02cdc30e256d40d50aa8939f9aa79313324b7.pdf",
        "text": "https://archive.orkl.eu/f1a02cdc30e256d40d50aa8939f9aa79313324b7.txt",
        "img": "https://archive.orkl.eu/f1a02cdc30e256d40d50aa8939f9aa79313324b7.jpg"
    }
}