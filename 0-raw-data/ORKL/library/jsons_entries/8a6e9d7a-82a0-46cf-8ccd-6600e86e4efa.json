{
    "id": "8a6e9d7a-82a0-46cf-8ccd-6600e86e4efa",
    "created_at": "2023-04-26T02:08:08.213608Z",
    "updated_at": "2025-03-27T02:16:59.192682Z",
    "deleted_at": null,
    "sha1_hash": "99139b55b6234c874bfc534c787c1bdf821bcab8",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-06-13T21:31:33Z",
    "file_modification_date": "2021-06-13T21:31:33Z",
    "file_size": 2009243,
    "plain_text": "**1 / 2**\n\n\n# Secure PLC Coding Practices: Top 20 List\nVersion 1.0 (15 June 2021)\n\n**1.** **Modularize PLC Code**\n\nSplit PLC code into modules, using different function blocks (sub-routines). Test modules\nindependently.\n\n**2.** **Track operating modes**\n\nKeep the PLC in RUN mode. If PLCs are not in RUN mode, there should be an alarm to the\noperators.\n\n**3.** **Leave operational logic in the PLC wherever feasible**\n\nLeave as much operational logic e.g., totalizing or integrating, as possible directly in the PLC. The\nHMI does not get enough updates to do this well.\n\n**4.** **Use PLC flags as integrity checks**\n\nPut counters on PLC error flags to capture any math problems.\n\n**5.** **Use cryptographic and / or checksum integrity checks for PLC code**\n\nUse cryptographic hashes, or checksums if cryptographic hashes are unavailable, to check PLC code\nintegrity and raise an alarm when they change.\n\n**6.** **Validate timers and counters**\n\nIf timers and counters values are written to the PLC program, they should be validated by the PLC\nfor reasonableness and verify backward counts below zero.\n\n**7.** **Validate and alert for paired inputs / outputs**\n\nIf you have paired signals, ensure that both signals are not asserted together. Alarm the operator\nwhen input / output states occur that are physically not feasible. Consider making paired signals\nindependent or adding delay timers when toggling outputs could be damaging to actuators.\n\n**8.** **Validate HMI input variables at the PLC level, not only at HMI**\n\nHMI access to PLC variables can (and should) be restricted to a valid operational value range at the\nHMI, but further cross-checks in the PLC should be added to prevent, or alert on, values outside of\nthe acceptable ranges which are programmed into the HMI.\n\n**9.** **Validate indirections**\n\nValidate indirections by poisoning array ends to catch fence-post errors.\n\n**10.** **Assign designated register blocks by function (read/write/validate)**\n\nAssign designated register blocks for specific functions in order to validate data, avoid buffer\noverflows and block unauthorized external writes to protect controller data.\n\n**11.** **Instrument for plausibility checks**\n\nInstrument the process in a way that allows for plausibility checks by cross-checking different\nmeasurements.\n\n**12.** **Validate inputs based on physical plausibility**\n\nEnsure operators can only input what’s practical or physically feasible in the process. Set a timer for\nan operation to the duration it should physically take. Consider alerting when there are deviations.\nAlso alert when there is unexpected inactivity.\n\n\n-----\n\n**2 / 2**\n\n\n# Secure PLC Coding Practices: Top 20 List\nVersion 1.0 (15 June 2021)\n\n**13.** **Disable unneeded / unused communication ports and protocols**\n\nPLC controllers and network interface modules generally support multiple communication protocols\nthat are enabled by default. Disable ports and protocols that are not required for the application.\n\n**14.** **Restrict third-party data interfaces**\n\nRestrict the type of connections and available data for 3rd party interfaces. The connections and/or\ndata interfaces should be well defined and restricted to only allow read/write capabilities for the\nrequired data transfer.\n\n**15.** **Define a safe process state in case of a PLC restart**\n\nDefine safe states for the process in case of PLC restarts (e.g., energize contacts, de-energize, keep\nprevious state).\n\n**16.** **Summarize PLC cycle times and trend them on the HMI**\n\nSummarize PLC cycle time every 2-3 seconds and report to HMI for visualization on a graph.\n\n**17.** **Log PLC uptime and trend it on the HMI**\n\nLog PLC uptime to know when it’s been restarted. Trend and log uptime on the HMI for diagnostics.\n\n**18.** **Log PLC hard stops and trend them on the HMI**\n\nStore PLC hard stop events from faults or shutdowns for retrieval by HMI alarm systems to consult\nbefore PLC restarts. Time sync for more accurate data.\n\n**19.** **Monitor PLC memory usage and trend it on the HMI**\n\nMeasure and provide a baseline for memory usage for every controller deployed in the production\nenvironment and trend it on the HMI.\n\n**20.** **Trap false negatives and false positives for critical alerts**\n\nIdentify critical alerts and program a trap for those alerts. Set the trap to monitor the trigger\nconditions and the alert state for any deviation.\n\n**About the Secure PLC Programming project**\n\n\n-----\n\n**1 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 1. Modularize PLC Code\n\n**Split PLC code into modules, using different function blocks (sub-routines). Test**\n**modules independently.**\n\n**Security Objective** **Target Group**\nIntegrity of PLC logic Product Supplier\n\n### Guidance\nDo not program the complete PLC logic in one place e.g., in the main Organization Block or main\nroutine. Instead, split it into different function blocks (sub-routines) and monitor their execution time\nand their size in Kb.\n\nCreate separate segments for logic that functions independently. This helps in input validation,\naccess control management, integrity verification etc.\n\nModularized code also facilitates testing and keeping track of the integrity of code modules. If the\ncode inside the module has been meticulously tested, any modifications to these modules can be\nverified against the hash of the original code, e.g., by saving a hash of each of these modules (when\nthat’s an option in the PLC). This way, modules can be validated during the FAT/SAT or if the integrity\nof the code is in question after an incident.\n\n### Example\nGas Turbine logic is segregated into “startup”, “Inlet Guide Vanes Control”, “Bleed Valve Control” etc.\nso that you can apply standard logic systematically. This also helps in troubleshooting quickly if there\nwere to be a security incident.\n\nCustom function blocks that are tested rigorously can be re-used without alteration (and alerted if\nchange attempts are made) and locked against abuse/misuse with a password/digital signature.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nFacilitates the detection of newly added portions of code that could be\n\n**Security** malicious. Helps in logic standardization, consistency, and locking against\n\nunauthorized modifications.\n\nHelps control the program flow sequence and avoid loops, which could\n**Reliability**\ncause the logic to not react properly or crash.\n\nModular code is not only easier to debug (modules can be tested\nindependently) but also easier to maintain and update.\nAlso, the modules may be used for additional PLCs, thus allowing for\n\n**Maintenance**\n\ncommon code to be used and identified in separate PLCs. This can aid\nmaintenance personnel with quickly recognizing common modules\nduring troubleshooting.\n\n|modules independently.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Integrity of PLC logic|Product Supplier|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Facilitates the detection of newly added portions of code that could be malicious. Helps in logic standardization, consistency, and locking against unauthorized modifications.|\n|Reliability|Helps control the program flow sequence and avoid loops, which could cause the logic to not react properly or crash.|\n|Maintenance|Modular code is not only easier to debug (modules can be tested independently) but also easier to maintain and update. Also, the modules may be used for additional PLCs, thus allowing for common code to be used and identified in separate PLCs. This can aid maintenance personnel with quickly recognizing common modules during troubleshooting.|\n\n\n-----\n\n**2 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**Tactic:** [TA002 - Execution](https://collaborate.mitre.org/attackics/index.php/Execution)\n**MITRE ATT&CK for ICS**\n**[Technique: T0844 - Program Organization Units](https://collaborate.mitre.org/attackics/index.php/Technique/T0844)**\n**ISA 62443-3-3** **SR 3.4: Software and information integrity**\n**ISA 62443-4-2** **CR 3.4: Software and information integrity**\n**ISA 62443-4-1** **SI-2: Secure coding standards**\n\n**CWE-1120: Excessive Code Complexity**\n**MITRE CWE**\n**CWE-653: Insufficient Compartmentalization**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA002 - Execution Technique: T0844 - Program Organization Units|\n|ISA 62443-3-3|SR 3.4: Software and information integrity|\n|ISA 62443-4-2|CR 3.4: Software and information integrity|\n|ISA 62443-4-1|SI-2: Secure coding standards|\n|MITRE CWE|CWE-1120: Excessive Code Complexity CWE-653: Insufficient Compartmentalization|\n\n\n-----\n\n**3 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 2. Track operating modes\n\n**Keep the PLC in RUN mode. If PLCs are not in RUN mode, there should be an alarm to**\n**the operators.**\n\n**Security Objective** **Target Group**\n\nIntegration / Maintenance Service Provider\nIntegrity of PLC logic\nAsset Owner\n\n### Guidance\nIf PLCs are not in RUN mode (e.g., PROGRAM mode), their code could be changed to track the RUN\nmode. Some PLCs have a checksum to alert for code changes, but if they do not, there’s at least an\nindirect indicator of a potential issue while tracking operating modes:\n\n  - If PLCs are not in RUN mode, there should be an alarm to the operators. If they are aware\nthat someone is supposed to be working on that control system, they can acknowledge the\nalarm and move on.\n\n  - The HMI should be configured to re-alert the operator toward the end of the shift about the\npresence of the alarm. The goal should be to keep track of any staff or contractors in the\nplant doing work that might impact the process.\n\nException case: If the plant is in a testing or development phase, consider disabling this alarm but the\nplant should be isolated from higher levels of the network.\n\n### Example\nIf the PLC does not have a hardware switch for changing operating modes, it is recommended to at\nleast make use of software mechanisms that can restrict changing PLC code, e.g., password\nprotection in engineering software for reading and writing PLC code.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nThe operating mode (run / edit / write; for Allen Bradley PLCs: RUN /\nPROGram / REMote) determines if PLC can be tampered with. If the key\n**Security** switch is in REMote state, it is technically possible to make changes to\n\nthe PLC program over the communication interfaces even if the PLC is\nrunning.\n**Reliability** /\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA009 - Inhibit Response Function](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0858 - Utilize/Change Operating Mode](https://collaborate.mitre.org/attackics/index.php/Technique/T0858)\n**ISA/IEC 62443-4-1** **SI-1 : Security implementation review**\n\n|the operators.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Integrity of PLC logic|Integration / Maintenance Service Provider Asset Owner|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|The operating mode (run / edit / write; for Allen Bradley PLCs: RUN / PROGram / REMote) determines if PLC can be tampered with. If the key- switch is in REMote state, it is technically possible to make changes to the PLC program over the communication interfaces even if the PLC is running.|\n|Reliability|/|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA009 - Inhibit Response Function Technique: T0858 - Utilize/Change Operating Mode|\n|ISA/IEC 62443-4-1|SI-1 : Security implementation review|\n\n\n-----\n\n**4 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 3. Leave operational logic in the PLC wherever feasible\n\n**Leave as much operational logic e.g., totalizing or integrating, as possible directly in**\n**the PLC. The HMI does not get enough updates to do this well.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\n\nIntegrity of PLC logic Integration / Maintenance Service Provider\n\nAsset Owner\n\n### Guidance\nHMIs provide some level of coding capabilities, originally aimed to help operators enhance\nvisualization and alarming, that some programmers have employed to create code that should rather\nstay in the PLC to remain complete and auditable.\n\nCalculating values as close to the field as possible makes these calculations more accurate. The HMI\ndoes not get enough updates to do totalizing / integrating well. Also, there is always latency between\nHMI and PLC. Further, when the code is in the PLC, and an HMI restarts, it can always receive\ntotalizers/counts from a PLC.\n\nIn particular, HMI code to be avoided is anything related to security or safety functions such as\ninterlocks, timers, holds or permissives.\n\nFor analyzing process data values over time, a process data historian is the better choice than the\nHMI. Use queries in a process historian database to compare totalized values (over a period, over a\nbatch, over a process cycle) with totals aggregated locally in PLC logic. Alert on a variance greater\nthan that can be explained by differences in data granularity.\n\n### Example\n\n  - Code to establish conditions to enable/disable buttons: Enable/disable actions should be\ncontrolled on PLC layer, otherwise, actions can be performed on the HMI (or through\nnetwork) in PLC, although not meeting (intended) conditions.\n\n  - Timers to allow actions to the operator (delay timer for consecutive motor starts, timer to\nconsider valves closed/open or motor stopped) should not be put on the HMI layer but in\nthe PLC governing such motor/valve.\n\n  - Thresholds for alarms have to be part of PLC codes although displayed on HMIs.\n\n  - Water tank with changing volume: The PLC which controls flow in and out of the tank can\neasily totalize volume (and cross-validate totals). The HMI could do this as well, but it would\nneed to get the values from the PLC first. These values would need accurate time-stamps in\norder to get correct totals in case of latency or and might miss values if the HMI restarts.\n\n### Why?\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC logic|Product Supplier Integration / Maintenance Service Provider Asset Owner|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|1. Allows consistency in verifying code changes. HMI coding has its change control apart from PLC, generally not with the same rigor (especially in construction and commissioning phases), not allowing system owners to have a complete view and even losing important considerations. HMI’s do not include “forced signals” or changed value lists as PLCs or SCADAs, so HMI level changes|\n\n\n-----\n\n**5 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n**Beneficial for…?** **Why?**\n\nare more difficult to be detected, practically impossible to be\npart of an authorization change management plan.\n**2.** For an attacker, it is harder to manipulate totals distributed over\n\nmany PLCs than to manipulate totals all calculated in the HMI.\n**3.** If a portion of the enable/disable functions are not in the PLC,\n\nattackers might be able to manipulate the PLC and I/O without\nhaving to work the HMI portion as the proper information is\nalready obfuscated on the operator screen.\n\n**1.** Calculations are more efficient and accurate if closer to the field.\n\nAlso, totals and counts will still be available if HMI restarts (PLCs\ndo not restart as often and usually store these values in nonvolatile memory).\n**2.** Different sources for inputs and interlocks may mean non\n\n**Reliability**\n\nexpected failures. There can be different technologies for HMIs in\na plant (SCADA layer, but also field controller panels) and\nchanges in one of those will fail to be disseminated through the\nrest of layers, leading to inconsistences in visualization and\npossible failures in operation.\n\nCoding is easy to understand and transfer from PLC to PLC, not so much\n**Maintenance**\nfrom HMIs to HMIs.\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0836 - Modify Parameter](https://collaborate.mitre.org/attackics/index.php/Technique/T0836)\n**ISA 62443-3-3** **SR 3.6 : Deterministic Output**\n**ISA 62443-4-2** **CR 3.6 : Deterministic Output**\n\n|Beneficial for…?|Why?|\n|---|---|\n||are more difficult to be detected, practically impossible to be part of an authorization change management plan. 2. For an attacker, it is harder to manipulate totals distributed over many PLCs than to manipulate totals all calculated in the HMI. 3. If a portion of the enable/disable functions are not in the PLC, attackers might be able to manipulate the PLC and I/O without having to work the HMI portion as the proper information is already obfuscated on the operator screen.|\n|Reliability|1. Calculations are more efficient and accurate if closer to the field. Also, totals and counts will still be available if HMI restarts (PLCs do not restart as often and usually store these values in non- volatile memory). 2. Different sources for inputs and interlocks may mean non expected failures. There can be different technologies for HMIs in a plant (SCADA layer, but also field controller panels) and changes in one of those will fail to be disseminated through the rest of layers, leading to inconsistences in visualization and possible failures in operation.|\n|Maintenance|Coding is easy to understand and transfer from PLC to PLC, not so much from HMIs to HMIs.|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.6 : Deterministic Output|\n|ISA 62443-4-2|CR 3.6 : Deterministic Output|\n\n\n-----\n\n**6 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 4. Use PLC flags as integrity checks\n\n**Put counters on PLC error flags to capture any math problems.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nIntegrity of PLC logic\nIntegration / Maintenance Service Provider\n\n### Guidance\nIf the PLC code was working fine but suddenly does a divide by zero, investigate. If something is\ncommunicating peer to peer from another PLC and the function/logic does a divide by zero when it\nwasn’t expected, investigate.\n\nMost programmers will ignore the issue as a math error or worse yet, might presume their code is\nperfect and let the PLC enter a hard fault state. During code development, engineers need to test\nand validate their code modules (snippets or routines) by inputting data outside of expected bounds.\nThis may be termed Unit Level Test.\n\nAssign different, locked memory segments for firmware, logic and protocol stack. Test the protocol\nstack for abuse cases. Abuse cases could be peculiar flag conditions in a packet header.\n\n### Example\nPLC faults caused by out of bounds data are very common. This happens, for example, when an input\nvalue causes array indices go out of bounds, or timers with negative presets, or divide by zero\nexceptions.\n\nTypical flags of interest are\n\n  - divide by zero\n\n  - counter overflow\n\n  - negative counter or timer preset\n\n  - I/O scan overrun\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nAttacks on PLCs could include changing its logic, activating a new\nprogram, testing new code, loading a new process recipe, inserting\n\n**Security** auxiliary logic to send messages or activating some feature. Since most\n\nPLCs do not provide cryptographic integrity checks, flags can be a good\nindicator if one of the above logic changes happens.\n\nFlags taken seriously can avoid the PLC running with programming or I/O\n**Reliability**\nerrors. Also, if an error occurs, the source of the failure is more obvious.\n**Maintenance** /\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC logic|Product Supplier Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Attacks on PLCs could include changing its logic, activating a new program, testing new code, loading a new process recipe, inserting auxiliary logic to send messages or activating some feature. Since most PLCs do not provide cryptographic integrity checks, flags can be a good indicator if one of the above logic changes happens.|\n|Reliability|Flags taken seriously can avoid the PLC running with programming or I/O errors. Also, if an error occurs, the source of the failure is more obvious.|\n|Maintenance|/|\n\n\n-----\n\n**7 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**Tactic :** [TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)\n**MITRE ATT&CK for ICS**\n**Technique:** [T0836 - Modify Parameter](https://collaborate.mitre.org/attackics/index.php/Technique/T0836)\n\n**SR 3.5: Input Validation**\n**ISA 62443-3-3**\n**SR 3.6: Deterministic Output**\n\n**CR 3.5: Input Validation**\n**ISA 62443-4-2**\n**CR 3.6: Deterministic Output**\n\n**SI-2: Secure coding standards**\n**ISA 62443-4-1**\n**SVV-1: Security requirements testing**\n\n**CWE-128: Wrap-around**\n**CWE-190: Integer Overflow**\n\n**MITRE CWE**\n\n**CWE-369: Divide by Zero**\n**CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic : TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|ISA 62443-4-1|SI-2: Secure coding standards SVV-1: Security requirements testing|\n|MITRE CWE|CWE-128: Wrap-around CWE-190: Integer Overflow CWE-369: Divide by Zero CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**8 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 5. Use cryptographic and / or checksum integrity checks for PLC code\n\n**Use cryptographic hashes, or checksums if cryptographic hashes are unavailable, to**\n**check PLC code integrity and raise an alarm when they change.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\n\nIntegrity of PLC logic Integration / Maintenance Service Provider\n\nAsset Owner\n\n### Guidance\n**A) Checksums**\nWhere (cryptographic) hashes are not feasible, checksums may be an option. Some PLCs generate a\nunique Checksum when code is downloaded into the PLC Hardware. The Checksum should be\ndocumented by the manufacturer / integrator after SAT and be part of warranty / service-conditions.\n\nIf the checksum feature is not natively available in the controller, this can also be generated in the\nEWS/HMI and probed e.g., once a day to compare with the hash of the original code in the PLC to\nverify that they are matching. While this won’t provide real time alerts, it’s good enough to track if\nanyone is attempting changes to the PLC code.\n\nThe checksum value can also be moved into a PLC register and configured for an alarm when it\nchanges, the value can be sent to historians etc.\n\n**B) Hashes**\nPLC CPUs generally do not have the processing capacity to generate or check hashes while running.\nAttempting a hash might actually cause the PLC to crash. But the PLC’s engineering software might\nbe able to calculate hashes from the PLC code and save them either in the PLC or somewhere else in\nthe control system.\n\n### Example\nPLC vendors that are known to have checksum features:\n\n  - Siemens (see example)\n\n  - Rockwell\n\nAlso, external software can be used for generating checksums:\n\n  - Version dog\n\n  - Asset Guardian\n\n  - PAS\n\n**Siemens implementation example**\n\nExample for creating checksums in Siemens S7-1500 PLC:\n\nGetChecksum-Function Block reads actual checksum and with a lightweight script the “SATChecksum” can be stored as reference. A deviance from the Reference-Checksum can be stored with\nthe Datalog-Function.\n\n|check PLC code integrity and raise an alarm|when they change.|\n|---|---|\n|Security Objective|Target Group|\n|Integrity of PLC logic|Product Supplier Integration / Maintenance Service Provider Asset Owner|\n\n\n-----\n\n**9 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n**Rockwell Implementation Example:**\n\nThis is partial example of how an organization can develop a level of PLC program change detection\ncapability within their ICS environment. This example is specifically for a Rockwell Automation\nControlLogix PLC and is not complete; however, it illustrates how to retrieve the PLC processor state\ninto a register within the PLC. Once in a register in the PLC, the organization can use it create a\nconfiguration change alarm for display on an HMI, transmit the raw state information to an HMI for\ntrending and monitoring, or send it to a Historian for long term capture.\n\nThis practice provides an opportunity, using existing tools and capabilities, to gain situational\nawareness of when critical cyber assets change. It is up to the organization to complete the use of\nthis example in a method that works best in their environment.\n\n1. From the Controller Properties Dialog Box, select the configure button on “Change to Detect”\n\n\n-----\n\n**10 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n2. Within the selection window, choose all items to be monitored\n\n3. Create a Tag to receive the processor state information. This tag can be of type “LINT” or a 2\nword array of type “DINT”\n\n4. Use the Get System Values (GSV) instruction to get the processor state information from\n\nmemory and move it into a Tag that can be used in logic or read at the HMI\n\n\n-----\n\n**11 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nKnowing if PLC code was tampered with is essential for both noticing a\n\n**Security** compromise and verifying if a PLC is safe to operate after a potential\n\ncompromise.\n\nHashes or checksums can also be a means to verify if the PLC is (still)\n**Reliability**\nrunning code approved by the integrator / manufacturer.\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA002 - Execution,](https://collaborate.mitre.org/attackics/index.php/Execution)** [TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)\n**MITRE ATT&CK for ICS**\n**[Technique: T0873 - Project File Infection,](https://collaborate.mitre.org/attackics/index.php/Technique/T0873)** [T0833 - Modify Control Logic](https://collaborate.mitre.org/attackics/index.php/Technique/T0833)\n**ISA 62443-3-3** **SR 3.4 : Software and information integrity**\n\n**CR 3.4 : Software and information integrity**\n**ISA 62443-4-2**\n**EDR 3.12 : Provisioning product supplier roots of trust**\n\n**SI-1 : Security implementation review**\n**ISA 62443-4-1**\n**SVV-1 Security requirements testing**\n\n**CWE-345: Insufficient Verification of Data Authenticity**\n\n**MITRE CWE** - **(child) CWE-353: Missing Support for Integrity Check**\n\n              - **(child) CWE-354: Improper Validation of Integrity Check Value**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Knowing if PLC code was tampered with is essential for both noticing a compromise and verifying if a PLC is safe to operate after a potential compromise.|\n|Reliability|Hashes or checksums can also be a means to verify if the PLC is (still) running code approved by the integrator / manufacturer.|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA002 - Execution, TA010 - Impair Process Control Technique: T0873 - Project File Infection, T0833 - Modify Control Logic|\n|ISA 62443-3-3|SR 3.4 : Software and information integrity|\n|ISA 62443-4-2|CR 3.4 : Software and information integrity EDR 3.12 : Provisioning product supplier roots of trust|\n|ISA 62443-4-1|SI-1 : Security implementation review SVV-1 Security requirements testing|\n|MITRE CWE|CWE-345: Insufficient Verification of Data Authenticity  (child) CWE-353: Missing Support for Integrity Check  (child) CWE-354: Improper Validation of Integrity Check Value|\n\n\n-----\n\n**12 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 6. Validate timers and counters\n\n**If timers and counters values are written to the PLC program, they should be validated**\n**by the PLC for reasonableness and verify backward counts below zero.**\n\n**Security Objective** **Target Group**\n\nIntegration / Maintenance Service Provider\nIntegrity of PLC variables\nAsset Owner\n\n### Guidance\nTimers and counters can technically be preset to any value. Therefore, the valid range to preset a\ntimer or counter needs to should be restricted to meet the operational requirements.\n\nIf remote devices such as an HMI write timer or counter values to a program:\n\n  - do not let the HMI write to the timer or counter directly but go through a validation logic\n\n  - validate presets and timeout values in the PLC\n\nValidation of timer and counter inputs is easy to directly do in the PLC (without the need for any\nnetwork device capable of Deep Packet Inspection), since the PLC “knows” what the process state or\ncontext is. It can validate “what’ it gets and “when” it gets the commands or setpoints.\n\n### Example\nDuring PLC startup, timers and counters are usually preset to certain values.\n\nIf there is a timer that triggers alarms at 1.3 seconds, but that timer is preset maliciously to 5\nminutes, it might not trigger the alarm.\n\nIf there is a counter that causes a process to stop when it reaches 10,000 but that is set it to 11,000\nfrom the beginning, the process might not stop.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nIf I/O, timers, or presets are written directly to I/O, not being validated by\n\n**Security** the PLC, the PLC validation layer is evaded and the HMI (or other network\n\ndevices) are assigned an unwarranted level of trust.\n\nThe PLC can also validate when an operator accidentally presets bad\n**Reliability**\ntimer or counter values.\n\nHaving valid ranges for timers and counters documented and\n**Maintenance**\nautomatically validated may help when updating logic.\n\n### References\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC variables|Integration / Maintenance Service Provider Asset Owner|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|If I/O, timers, or presets are written directly to I/O, not being validated by the PLC, the PLC validation layer is evaded and the HMI (or other network devices) are assigned an unwarranted level of trust.|\n|Reliability|The PLC can also validate when an operator accidentally presets bad timer or counter values.|\n|Maintenance|Having valid ranges for timers and counters documented and automatically validated may help when updating logic.|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic : TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.5 : Input Validation|\n|ISA 62443-4-2|CR 3.5 : Input Validation|\n|ISA 62443-4-1|SI-2 : Secure coding standards SVV-1 : Security requirements testing|\n\n\n-----\n\n**13 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 7. Validate and alert for paired inputs / outputs\n\n**If you have paired signals, ensure that both signals are not asserted together. Alarm the**\n**operator when input / output states occur that are physically not feasible. Consider**\n**making paired signals independent or adding delay timers when toggling outputs**\n**could be damaging to actuators.**\n\n**Security Objective** **Target Group**\nIntegrity of PLC variables Product Supplier\nResilience Integration / Maintenance Service Provider\n\n### Guidance\nPaired inputs or outputs are those that physically cannot happen at the same time; they are mutually\nexclusive. Though paired signals cannot be asserted at the same time unless there is a failure or\nmalicious activity, PLC programmers often do not prevent that assertion from happening.\n\nValidation is easiest to directly do in the PLC, because the PLC is aware of the process state or\ncontext. Paired signals are easier to recognize and track if they have sequential addresses (e.g., input\n1 and input 2).\n\nAnother scenario where paired inputs or outputs could cause problems is when they are not asserted\nat the same time, but toggled quickly in a way that damages actuators.\n\n### Example\n**Examples of paired signals:**\n\n  - START and STOP\n\n`o` Independent start & stop: Configure start and stop as discrete outputs instead of\n\nhaving a single output that can be toggled on/off. By design, this does not allow\nsimultaneous triggers. For an attacker, it is way more complicated to rapidly toggle\non / off if two different outputs have to be set.\n`o` Timer for restart: Also consider adding a timer for a re-start after a stop is issued to\n\navoid rapid toggling off start/stop signals.\n\n  - FORWARD and REVERSE\n\n  - OPEN and CLOSE\n\n**Examples for toggling paired signals that could be damaging:**\n\nIf the PLC / MCC accepts a discrete input, this provides an easy option for an attacker to cause\nphysical damage on actuators. The well-known scenario for toggling outputs to do damage would be\nan MCC, but this practice applies to all scenarios where toggling outputs could do damage. A proof of\nconcept where rapidly toggling outputs could cause real damage was the Aurora Generator Test in\n2007 conducted by the Idaho National Laboratory, where toggling outputs out of sync caused circuit\nbreaker damage.\n\n|could be damaging to actuators.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Integrity of PLC variables Resilience|Product Supplier Integration / Maintenance Service Provider|\n\n\n-----\n\n**14 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\n1. If PLC programs do not account for what is going to happen if\n\nboth paired input signals are asserted at the same time, this is a\ngood attack vector.\n2. Both paired input signals being asserted is a warning that there is\n\n**Security**\n\nan operational error, programming error, or something malicious\nis going on.\n3. This avoids an attack scenario where physical damage can be\n\ncaused to actuators.\n\n1. Paired input signals can point to a sensor being broken or mis\nwired or that there is a mechanical problem like a stuck switch.\n\n**Reliability**\n\n2. Quickly toggling start and stop could also be done by mistake, so\n\nthis also prevents damage that might be done inadvertently.\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0836 - Modify Parameter, T0806 - Brute Force I/O](https://collaborate.mitre.org/attackics/index.php/Technique/T0836)\n\n**SR 3.5: Input Validation**\n**ISA 62443-3-3**\n**SR 3.6: Deterministic Output**\n\n**CR 3.5: Input Validation**\n**ISA 62443-4-2**\n**CR 3.6: Deterministic Output**\n\n**SI-2: Secure coding standards**\n**ISA 62443-4-1**\n**SVV-1: Security requirements testing**\n**MITRE CWE** **CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|1. If PLC programs do not account for what is going to happen if both paired input signals are asserted at the same time, this is a good attack vector. 2. Both paired input signals being asserted is a warning that there is an operational error, programming error, or something malicious is going on. 3. This avoids an attack scenario where physical damage can be caused to actuators.|\n|Reliability|1. Paired input signals can point to a sensor being broken or mis- wired or that there is a mechanical problem like a stuck switch. 2. Quickly toggling start and stop could also be done by mistake, so this also prevents damage that might be done inadvertently.|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0836 - Modify Parameter, T0806 - Brute Force I/O|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|ISA 62443-4-1|SI-2: Secure coding standards SVV-1: Security requirements testing|\n|MITRE CWE|CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**15 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 8. Validate HMI input variables at the PLC level, not only at HMI\n\n**HMI access to PLC variables can (and should) be restricted to a valid operational value**\n**range at the HMI, but further cross-checks in the PLC should be added to prevent, or**\n**alert on, values outside of the acceptable ranges which are programmed into the HMI.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nIntegrity of PLC variables\nIntegration / Maintenance Service Provider\n\n### Guidance\nInput validation could include out-of-bounds checks for valid operational values as well as valid\nvalues in terms of data types that are relative to the process.\n\nIf a PLC variable receives a value that is out-of-bounds, provide PLC logic to either\n\n  - input a default value to that variable which does not negatively affect the process, and can\nbe used as a flag for alerts, or\n\n  - input the last correct value to that value and log the event for further analysis.\n\n### Example\n**Example 1**\nAn operation requires a user to input a value on an HMI for valve pressure. Valid ranges for this\noperation are 0-100, and the user’s input is passed from the user input function on the HMI to the V1\nvariable in the PLC. In this case,\n\n1. HMI input to variable V1 has a restricted range of 0-100 (dec.) programmed into the HMI.\n2. The PLC has a cross-check logic that states:\n```\nIF V1 < 0 OR IF V1 > 100, SET V1 = 0.\n\n```\nThis provides a positive response of a presumably safe value to an invalid input to that variable.\n\n**Example 2**\nAn operation requires user input for measurement thresholds to a variable which should always be\nwithin an INT2 data range. The user input is passed from the HMI into the V2 variable in the PLC,\nwhich is a 16-bit data register.\n\n1. HMI input to variable V2 has a restricted range of -32768 to 32767 (dec.) programmed into\n\nthe HMI.\n2. The PLC has data-type cross-check logic that monitors the overflow variable (V3), which\n\nexists just after V2 in the PLC’s memory structure:\n```\nIF V2 = -32768 OR IF V2 = 32767 AND V3 != 0,\nSET V2 = 0 AND SET V3 = 0 AND SET DataTypeOverflowAlarm = TRUE.\n\n```\n**Example 3**\nScale PV (Process Value), SP (Set Point) and CV (Control Variable) for PID (Proportional, Integral,\nDerivative controller) to consistent or raw units to eliminate scaling errors causing control problem.\nIncorrect scaling might lead to inadvertent abuse cases.\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC variables|Product Supplier Integration / Maintenance Service Provider|\n\n\n-----\n\n**16 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\n**1.** While HMIs typically provide some sort of input validation, a\n\nmalicious actor can craft or replay modified packets to send\narbitrary values to the variables in the PLC which are open to\noutside influence (open to values passed from an HMI, for\nexample).\n**2.** PLC protocols are typically marketed as “open” protocols and\n\npublished to the general public, so creating malware that utilizes\n“open” protocol information can be trivial to develop. PLC\n\nSecurity variable mapping can typically occur through traffic analysis\n\nduring the reconnaissance phases of an attack, thus providing the\nintruder with the necessary information to craft malicious traffic\nto the target and thereby manipulate a process with\nunauthorized tools. Cross-checking values passed into the PLC\nbefore implementing that data into the process ensures valid\ndata ranges and mitigates an invalid value in those memory\nlocations by forcibly setting safe ranges when a value is detected\nas out-of-bounds during the course of the PLC scan.\nReliability /\nMaintenance /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0836 - Modify Parameter](https://collaborate.mitre.org/attackics/index.php/Technique/T0836)\n\n**SR 3.5: Input Validation**\n**ISA 62443-3-3**\n**SR 3.6: Deterministic Output**\n\n**CR 3.5: Input Validation**\n**ISA 62443-4-2**\n**CR 3.6: Deterministic Output**\n\n**SI-2: Secure coding standards**\n**ISA 62443-4-1**\n**SVV-1: Security requirements testing**\n**MITRE CWE** **CWE-1320: Improper Protection for Out of Bounds Signal Level Alerts**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|1. While HMIs typically provide some sort of input validation, a malicious actor can craft or replay modified packets to send arbitrary values to the variables in the PLC which are open to outside influence (open to values passed from an HMI, for example). 2. PLC protocols are typically marketed as “open” protocols and published to the general public, so creating malware that utilizes “open” protocol information can be trivial to develop. PLC variable mapping can typically occur through traffic analysis during the reconnaissance phases of an attack, thus providing the intruder with the necessary information to craft malicious traffic to the target and thereby manipulate a process with unauthorized tools. Cross-checking values passed into the PLC before implementing that data into the process ensures valid data ranges and mitigates an invalid value in those memory locations by forcibly setting safe ranges when a value is detected as out-of-bounds during the course of the PLC scan.|\n|Reliability|/|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|ISA 62443-4-1|SI-2: Secure coding standards SVV-1: Security requirements testing|\n|MITRE CWE|CWE-1320: Improper Protection for Out of Bounds Signal Level Alerts|\n\n\n-----\n\n**17 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 9. Validate indirections\n\n**Validate indirections by poisoning array ends to catch fence-post errors.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nIntegrity of PLC variables\nIntegration / Maintenance Service Provider\n\n### Guidance\nAn indirection is the use of the value of a register in another register. There are many reasons to use\nindirections.\n\nExamples for necessary indirections are:\n\n  - Variable frequency drives (VFDs) that trigger different actions for different frequencies using\nlookup tables.\n\n  - To decide which pump to start running first based on their current run times\n\nPLCs do not typically have an “end of an array” flag so it’s a good idea to create it in software; the\ngoal is to avoid unusual/unplanned PLC operations.\n\n### Example\n**Instruction List (IL) Programming**\nThe approach can be turned into a few function blocks and possibly even reused for other\napplications.\n\n**1.** **Create array mask**\n\nCheck if the array is binary-sized. If it is not binary-sized, create a mask to the next size up on a binary\nscale. e.g., if you have a need for 5 registers (not binary-sized):\n```\n[21 31 41 51 61]\n\n```\ndefine an array of 8:\n```\n[x x 21 31 41 51 61 x]\n\n```\nNext, take the index value to pick up for the indirection - in this example, it is 3.\n\nCaveat: Index begins at 0!\n```\n[21 31 41 51 61]\n__________^\n\n```\nIndex: 3\n\nadd an offset to it making up for the poisoned end. The offset can be 1 or higher, in this case it is 2:\n```\n[x x 21 31 41 51 61 x]\n______________^\n\n```\nIndex including offset: 3 + 2 = 5\n\nand then AND the index including offset with a mask that equals the array size.\nIn this example the array size is 8, thus index 7, so the mask would be 0x07. The mask makes sure the\nmaximum index you can get is 7, for example:\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC variables|Product Supplier Integration / Maintenance Service Provider|\n\n\n-----\n\n**18 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n```\n6 AND 0x07 would give back 6.\n7 AND 0x07 would give back 7\n8 AND 0x07 would give back 0.\n9 AND 0x07 would give back 1.\n\n```\nThis ensures you always address a value in the array.\n\n**2.** **Insert poisoned ends**\n\nPoisoning ends is optional. You would be able to detect manipulated indirections without the\npoisoning, but poisoning helps to catch fence-post errors because you get back a value that does not\nmake sense.\n\nThe point is that at index 0 of the array, there should be a value that is invalid – such as -1 or 65535.\nThis is “the poisoned end”. Likewise, at the last elements of the array you do the same:\n\nSo, for the array above, the poisoned version could look like this:\n```\n[-1 -1 21 31 41 51 61 -1]\n\n```\n**3.** **Record value of indirection address without mask**\n\nThen record the value of the indirect address without AND mask and offset:\nIn this example, you’d record 51 for index 3.\n```\n[21 31 41 51 61]\n__________^\n______Index 3\n\n```\n**4.** **Execute AND mask and compare values (=indirection validation)**\n\nCompare your recorded value to the value after you have done the offset and the AND mask.\n\n**4a.** **Case A: Correct Indirection**\n\n**First, offset:**\nIndex + Offset = 3 + 2 = 5\n\n**Second, mask:**\n```\n5 AND 0x07 = 5\n\n```\n**Third, indirection check:**\n```\n[-1 -1 21 31 41 51 61 -1]\n________________^\n\n```\nIndex including offset: 5\n```\nValue = 51 equals the recorded value, so everything is fine.\n\n```\n**4b.** **Case B: Manipulated Indirection**\n\nIf you now had a manipulated indirection, let’s say 7, let us see what happens:\n\n\n-----\n\n**19 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n**First, offset:**\n```\nIndex + Offset = 7 + 2 = 9\n\n```\n**Second, mask:**\n```\n9 AND 0x07 = 1\n\n```\n**Third, indirection check:**\n```\n[-1 -1 21 31 41 51 61 -1]\n_____^\n\n```\nIndex including offset: 1\n```\nValue = -1 does not equal the recorded value and also indicates your poisoned end, so you’d\n\n```\nknow your indirection is manipulated.\n\n**5.** **Execute fault / programmer alert**\n\nIf this validated value is different from your recorded one, then you know something is wrong. Raise\na software quality alarm.\n\nThen, check the indirection value. If it is a poisoned value, you should raise another software quality\nalarm. This is an indication of a fence-post error.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nMost PLCs do not have any feature to handle out-of-bounds indices for\narrays. There are two potentially dangerous scenarios that can stem\nfrom indirection mistakes:\n\n**First, if an indirection leads to reading from the wrong register, the**\n\n**Security** program executes using wrong values.\n\n**Second, if a wrong indirection leads to writing to the wrong register, the**\nprogram overwrites code or values you want to keep. In both cases,\nindirection errors can be hard to spot and can have serious impacts. They\ncan be caused by human error but also be inserted maliciously.\n**Reliability** Identifies non-malicious human errors in programming.\n**Maintenance** /\n\n### References\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Most PLCs do not have any feature to handle out-of-bounds indices for arrays. There are two potentially dangerous scenarios that can stem from indirection mistakes: First, if an indirection leads to reading from the wrong register, the program executes using wrong values. Second, if a wrong indirection leads to writing to the wrong register, the program overwrites code or values you want to keep. In both cases, indirection errors can be hard to spot and can have serious impacts. They can be caused by human error but also be inserted maliciously.|\n|Reliability|Identifies non-malicious human errors in programming.|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|ISA 62443-4-1|SI-2: Secure coding standards SVV-1: Security requirements testing|\n|MITRE CWE|CWE-129: Improper Validation of Array Index|\n\n\n-----\n\n**20 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 10. Assign designated register blocks by function\n (read/write/validate)\n\n**Assign designated register blocks for specific functions in order to validate data, avoid**\n**buffer overflows and block unauthorized external writes to protect controller data.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nIntegrity of PLC variables\nIntegration / Maintenance Service Provider\n\n### Guidance\nTemporary memory, also known as scratch pad memory, is an easily exploitable area of memory if\nthis practice is not followed. e.g., simply writing to a “Modbus” register that is out of bounds could\nlead to overwriting memory registers used for temporary calculations.\n\nGenerally, register memory can be accessed by other devices across the PLC network for read and\nwrite operations. Some registers could be read by an HMI, and others could be written by a SCADA\nsystem etc. Having specific register arrays for a certain application also makes it easier (in the\ncontroller or an external firewall is used) to configure Read only access from another device/HMI.\n\nExamples of functions for which designated register blocks make sense are:\n\n  - reading\n\n  - writing (from HMI / Controller / other external device)\n\n  - validating writes\n\n  - calculations\n\nEnsuring external writes to allowable registers also helps in avoiding main memory reset errors either\ndue to out of bound execution or malicious attempts. These designated register blocks can be used\nas buffers for I/O, timer, and counter writes by validating that the buffer is completely written (does\nnot contain part old, part new data) and validating all the data in the buffer.\n\n**Background:**\n\nMain memory and register memory are used differently. Main memory is used for storing currently\nexecuting program logic whereas the register memory is used as a temporary memory by the\ncurrently executing logic. Though register memory is a temporary one, since it is being used by the\nexecuting logic it is bound to contain some important variables that would affect the main logic.\n\n### Example\n**Examples for what could happen if this practice is not implemented:**\n(Reference: _G. P. H. Sandaruwan, P. S. Ranaweera, Vladimir A. Oleshchuk, PLC Security and Critical_\n_Infrastructure Protection):_\n\n  - Siemens typically uses the scratchpad memory in the flag area from flag 200.0 to flag 255.7.\nIf a bit is changed within this area there is a likelihood of a serious malfunction of the PLC\nbased on the importance of that bit or byte.\n\n  - Assume that an attacker can gain access to one of the machines in the PLC network and\ninfect that machine with a worm which is capable of writing arbitrary values to the register\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of PLC variables|Product Supplier Integration / Maintenance Service Provider|\n\n\n-----\n\n**21 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\nmemory. Since the register memory values changed arbitrarily, it can change the pressure\nvalue.\n\n  - Executing logic will set a new value based on the change and that may cause the system to\nexceed its safety margins and possibly driven to a failure.\n\n**Examples for implementing this practice:**\n\n  - In a scenario where there is a safety zone (but the DCS can read), the firewall can log any\n\"write’ attempts with a rule that these registers are READ ONLY in the safety zone.\n\n  - In another scenario, there could be some write-capable registers, and others are read only,\nbut having all the READ ONLY registers in a single array makes it easier to configure them in\nthe controller (or a firewall).\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nMakes it easier to protect the controller data by function\n(read/write/validate).\nMakes it easier for protocol sensitive firewalls to do their job: The rules\nget simpler because it is very clear what register blocks are allowed for\nthe HMI to access. Makes it easier to manage the (simpler) rules in the\nfirewall.\n\n**Security**\n\nMaking unauthorized changes to internal temporary memory is an easily\nexploitable vulnerability (By-pass Logic Attack).\nWhen inputs and outputs to PLC routines are properly validated, any\nchanges (by a malicious actor or by mistake) can be caught easily instead\nof staying in the logic sequence for long and throwing errors / causing\nissues later in execution.\n\nMakes reads and writes go faster because the number of transactions is\nreduced.\nEven authorized changes and programming mistakes can cause a\n\n**Reliability** malfunction if temporary memory is not protected.\n\nNetwork and communications errors on long messages can result in\nunintended errors if the validity of the data is not checked prior to\nprocessing.\n\nProgramming mistakes causing writing to temporary memory can make it\n\n**Maintenance** hard to find errors, so the problem can be avoided by assigning specific\n\nregisters for writes.\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Makes it easier to protect the controller data by function (read/write/validate). Makes it easier for protocol sensitive firewalls to do their job: The rules get simpler because it is very clear what register blocks are allowed for the HMI to access. Makes it easier to manage the (simpler) rules in the firewall. Making unauthorized changes to internal temporary memory is an easily exploitable vulnerability (By-pass Logic Attack). When inputs and outputs to PLC routines are properly validated, any changes (by a malicious actor or by mistake) can be caught easily instead of staying in the logic sequence for long and throwing errors / causing issues later in execution.|\n|Reliability|Makes reads and writes go faster because the number of transactions is reduced. Even authorized changes and programming mistakes can cause a malfunction if temporary memory is not protected. Network and communications errors on long messages can result in unintended errors if the validity of the data is not checked prior to processing.|\n|Maintenance|Programming mistakes causing writing to temporary memory can make it hard to find errors, so the problem can be avoided by assigning specific registers for writes.|\n\n\n-----\n\n**22 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**Tactic :** [TA009 - Inhibit Response Function,](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)\n\n**MITRE ATT&CK for ICS** [Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)\n\n**Technique:** [T0835 - Manipulate I/O image,](https://collaborate.mitre.org/attackics/index.php/Technique/T0835)\n\n**SR 3.4 : Software and information integrity**\n\n**ISA 62443-3-3** **SR 3.5 : Input Validation**\n\n**SR 3.6 : Deterministic Output**\n\n**SD-4: Secure design best practices**\n**SI-1: Security implementation review**\n\n**ISA 62443-4-1**\n\n**SI-2 : Secure coding standards**\n**SVV-1 : Security requirements testing**\n\n**CR 3.4 : Software and information integrity**\n\n**ISA 62443-4-2** **CR 3.5 : Input Validation**\n\n**CR 3.6 : Deterministic Output**\n\n**CWE-787: Out-of-bounds Write**\n**MITRE CWE**\n**CWE-653: Insufficient Compartmentalization**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic : TA009 - Inhibit Response Function, TA010 - Impair Process Control Technique: T0835 - Manipulate I/O image , T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 3.4 : Software and information integrity SR 3.5 : Input Validation SR 3.6 : Deterministic Output|\n|ISA 62443-4-1|SD-4: Secure design best practices SI-1: Security implementation review SI-2 : Secure coding standards SVV-1 : Security requirements testing|\n|ISA 62443-4-2|CR 3.4 : Software and information integrity CR 3.5 : Input Validation CR 3.6 : Deterministic Output|\n|MITRE CWE|CWE-787: Out-of-bounds Write CWE-653: Insufficient Compartmentalization|\n\n\n-----\n\n**23 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 11. Instrument for plausibility checks\n\n**Instrument the process in a way that allows for plausibility checks by cross-checking**\n**different measurements.**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nIntegrity of I/O values\nIntegration / Maintenance Service Provider\n\n### Guidance\nThere are different ways of using physical plausibility for validating measurements:\n\n**a) Compare integrated and time-independent measurements**\nPlausibility checks can be done by integrating or differentiating time-dependent values over a period\nof time and comparing to time-independent measurements.\n\n**b) Compare different measurement sources**\nAlso, measuring the same phenomenon in different ways can be a good plausibility check.\nDifferent measurement sources do not necessarily have to be different physical sensors, but can also\nmean using alternative communication channels (see examples).\n\n### Example\n**a) Compare integrated and time-independent measurements**\n\n  - Metered pump and tank level gauge: volumetric change should equal integrated flow.\n\n  - Burner in a boiler: added caloric heat should equal temperature rise.\n\n**b) Compare different measurement sources**\n\n  - Using air speed, artificial horizon, vertical speed, and altitude in the airplane to measure the\nphenomenon of the climbing / descending airplane.\n\n  - Comparing process parameter values from independent data loggers (tied into 4-20mA loops\nor relay contacts and transmitted via independent communication channels) to SCADA\nsystem data (coming in the “normal” way through PLC and HMI) and alerting on deviations\nand significantly off-specified values.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nFacilitates monitoring for manipulated values (assuming not all sensors\n**Security**\nare manipulated at once).\n\nPrevents acceptance or identifies (for future action) corrupted / wrong\n**Reliability**\nmeasurements as inputs.\n**Maintenance** Rules out the possible physical causes for failures more quickly.\n\n|Instrument the process in a way that allows different measurements.|for plausibility checks by cross-checking|\n|---|---|\n|Security Objective|Target Group|\n|Integrity of I/O values|Product Supplier Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Facilitates monitoring for manipulated values (assuming not all sensors are manipulated at once).|\n|Reliability|Prevents acceptance or identifies (for future action) corrupted / wrong measurements as inputs.|\n|Maintenance|Rules out the possible physical causes for failures more quickly.|\n\n\n-----\n\n**24 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0806 - Brute Force I/O](https://collaborate.mitre.org/attackics/index.php/Technique/T0806)\n\n**SR 3.5: Input Validation**\n**ISA 62443-3-3**\n**SR 3.6: Deterministic Output**\n\n**CR 3.5: Input Validation**\n**ISA 62443-4-2**\n**CR 3.6: Deterministic Output**\n**MITRE CWE** **CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0806 - Brute Force I/O|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|MITRE CWE|CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**25 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 12. Validate inputs based on physical plausibility\n\n**Ensure operators can only input what’s practical or physically feasible in the process.**\n**Set a timer for an operation to the duration it should physically take. Consider alerting**\n**when there are deviations. Also alert when there is unexpected inactivity.**\n\n**Security Objective** **Target Group**\nIntegrity of I/O values Integration / Maintenance Service Provider\n\n### Guidance\n**a) Monitor expected physical durations**\nIf the operation takes longer than expected to go from one extreme to the other, that is worthy of an\nalarm. Alternatively, if it does it too quickly, that is worthy of an alarm too.\n\nA simple solution could be a step-timeout alert. This would be useful for sequence/step-controlled\ntasks.\nFor example, the step “move object from A to B” takes 5 sec from start of the step until the transition\ncondition (sensor: object arrived at B) is met.\nIf the condition is met significantly too early or too late, the step-timeout is alert triggered.\n\n**b) Monitor expected physical repeating activity**\nPhysical plausibility checking can also mean alert for physically implausible inactivity: If there is an\nexpectation of a regular, repeating cycle of events (e.g., batches, diurnal patterns), an inactivity timer\nwould alert if something which is expected to change (discrete or analog value) remains static for far\ntoo long.\n\n### Example\n**a) Monitor expected physical durations**\n\n  - The gates on a dam takes a certain time to go from fully closed to fully open\n\n  - In a wastewater utility, a wet well takes a certain time to fill\n\n**b) Monitor expected physical repeating activity**\n\n  - Manufacturing process or pipeline batching should regularly cycle between control ranges or\noperating modes.\n\n  - Municipal wastewater treatment plants typically have a diurnal cycle of activity / pattern of\ninfluent flow rates.\n\n**c) Limit operator entry for set points to what’s practical/physically possible.**\n\n   - e.g., Oldsmar Florida case allowed for operator input that’s a) thousands of times more\nthan what was typically needed b) that’s physically not possible. Try to configure the\noperational limits in the PLC code wherever possible instead of using HMI scripts.\n\n|Security Objective|Target Group|\n|---|---|\n|Integrity of I/O values|Integration / Maintenance Service Provider|\n\n\n-----\n\n**26 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\n**1.** Deviations can indicate an actuator was already in the middle of\n\na travel state or that someone is trying to fake the I/O, e.g., by\ndoing a replay attack.\n\n**Security**\n\n**2.** Inactivity alerts facilitate monitoring for frozen or forced\n\nconstant values which could be the result of system or device\ntampering.\n\n**1.** Deviations give you an early alert for broken equipment due\n\nelectrical or mechanical failures.\n**2.** Inactivity alerts help flag measurements or system control loops\n\n**Reliability**\n\nwhich may be failing (thus static) due to physical device fault or\nan issue with the logic control algorithm or failed/improper\noperator input.\n**Maintenance**\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK for ICS**\n**Technique:** [T0806 - Brute Force I/O](https://collaborate.mitre.org/attackics/index.php/Technique/T0806)\n\n**SR 3.5: Input Validation**\n**ISA 62443-3-3**\n**SR 3.6: Deterministic Output**\n\n**CR 3.5: Input Validation**\n**ISA 62443-4-2**\n**CR 3.6: Deterministic Output**\n**MITRE CWE** **CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|1. Deviations can indicate an actuator was already in the middle of a travel state or that someone is trying to fake the I/O, e.g., by doing a replay attack. 2. Inactivity alerts facilitate monitoring for frozen or forced constant values which could be the result of system or device tampering.|\n|Reliability|1. Deviations give you an early alert for broken equipment due electrical or mechanical failures. 2. Inactivity alerts help flag measurements or system control loops which may be failing (thus static) due to physical device fault or an issue with the logic control algorithm or failed/improper operator input.|\n|Maintenance||\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA010 - Impair Process Control Technique: T0806 - Brute Force I/O|\n|ISA 62443-3-3|SR 3.5: Input Validation SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.5: Input Validation CR 3.6: Deterministic Output|\n|MITRE CWE|CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**27 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 13. Disable unneeded / unused communication ports and protocols\n\n**PLC controllers and network interface modules generally support multiple**\n**communication protocols that are enabled by default. Disable ports and protocols that**\n**are not required for the application.**\n\n**Security Objective** **Target Group**\nHardening Integration / Maintenance Service Provider\n\n### Guidance\nCommon protocols usually enabled by default are e.g., HTTP, HTTPS, SNMP, Telnet, FTP, MODBUS,\nPROFIBUS, EtherNet/IP, ICMP, etc.\n\nBest practice is to develop a data flow diagram that depicts the required communications between\nthe PLC and other components in the system.\n\nThe data flow diagram should show both the physical ports on the PLC as well as the logical networks\nthey are connected to. For each physical port, a list of required network protocols should be\nidentified and all others disabled.\n\n### Example\nFor example, many PLCs include an embedded web server for maintenance and troubleshooting. If\nthis feature will not be used, if possible, it should be disabled as this could be an attack vector.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nEvery enabled port and protocol add to the PLC’s potential attack\n\n**Security** surface. The easiest way to make sure an attacker can’t use them for\n\nunauthorized communication is to disable them altogether.\n\nIf a PLC cannot communicate via a certain port or protocol, this also\nreduces the potential amount of (malformed) traffic, be it malicious or\n\n**Reliability**\n\nnot, which decreases the chances of the PLC crashing because of\nunintended / malformed communication packages.\n\nDisabling unused ports and protocols also facilitates maintenance,\n\n**Maintenance** because it reduces the PLC’s overall complexity. What’s not there does\n\nnot need to be administrated or updated.\n\n### References\n\n|are not required for the application.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Hardening|Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Every enabled port and protocol add to the PLC’s potential attack surface. The easiest way to make sure an attacker can’t use them for unauthorized communication is to disable them altogether.|\n|Reliability|If a PLC cannot communicate via a certain port or protocol, this also reduces the potential amount of (malformed) traffic, be it malicious or not, which decreases the chances of the PLC crashing because of unintended / malformed communication packages.|\n|Maintenance|Disabling unused ports and protocols also facilitates maintenance, because it reduces the PLC’s overall complexity. What’s not there does not need to be administrated or updated.|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK for ICS|Tactic: TA005 - Discovery Technique: T0808 - Control Device Identification , T0841 - Network Service Scanning, T0854 - Serial Connection Enumeration|\n|ISA 62443-3-3|SR 7.6: Network and security configuration settings SR 7.7: Least functionality|\n|ISA 62443-4-2|EDR 2.13 : Use of physical diagnostic and test interfaces|\n|ISA 62443-4-1|SD-4: Secure design best practices SI-1: Security implementation review SVV-1: Security requirements testing|\n\n\n-----\n\n**28 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 14. Restrict third-party data interfaces\n\n**Restrict the type of connections and available data for 3rd party interfaces. The**\n**connections and/or data interfaces should be well defined and restricted to only allow**\n**read/write capabilities for the required data transfer.**\n\n**Security Objective** **Target Group**\nHardening Integration / Maintenance Service Provider\n\n### Guidance\nIn some cases, due to long cable runs or a large exchange of data, interfaced data connections\npresent a better business case than hard wired data exchange between two separate parties.\n\nThe following guidelines should be considered and followed where practical when designing and\nimplementing a third-party data exchange interface:\n\n  - Use a dedicated communications module, either directly connected to the 3rd party PLC or\ndata exchange equipment, or use dedicate network equipment physically segregated from\neach party’s core network.\n\n  - The MAC address of connected devices is typically available in system variables for any ICS\nEthernet-enabled device, making it possible to verify device identity with a multi-factor\napproach (IP address + MAC maker code = trusted device). This practice is certainly not foolproof, as MAC & IP addresses can be spoofed, but it serves to raise the bar in terms of\ncommunications between trusted ICS systems and devices.\n\n  - When selecting a protocol for 3rd party interfaces, choose a protocol which minimizes the\nability of the third party to write data to the owner’s system.\n\n  - Choose a connection method and connection port which prevents the 3rd party from being\nable to configure the owner’s PLC or data exchange equipment.\n\n  - The third party should not be able to read or write to any data that has not been explicitly\ndefined and made available.\n\n  - Use a watchdog timer for monitoring communication so that commands are not sent to a\nPLC in fault mode.\n\n  - Serial Connection: Use a dedicated communication module for each 3rd party interface with\na restricted array of data. Ensure the owner’s side of the connection is the Initiator and that\nthe third party is the Responder.\n\n  - Ethernet/IP: Some PLCs allow for communication modules to function as a firewall and can\nperform Deep Packet Inspection (DPI), or restrict communication module interfaces to limit\nthe data exchange to a predefined subset. If these features are available, and an Ethernet/IP\nprotocol is in use, ensure the features are enabled and configured.\n\n  - When operational or contractual requirements prevent the owner from accomplishing the\nprevious items, consider using a separate “data concentrator” (aka proxy/DMZ) PLC in order\nto buffer the data and protect the owner from unwanted writes/programming from the 3rd\nparty. Ensure the backplane of this PLC cannot be traversed from the 3rd party network.\n\n|Security Objective|Target Group|\n|---|---|\n|Hardening|Integration / Maintenance Service Provider|\n\n\n-----\n\n**29 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Example\n\n  - Pipeline or Lease Automatic Custody Transfer (LACT) units which transfer and meter\nhydrocarbons or water exchanged between an upstream producing or pipeline company and\na midstream pipeline company with network or serial interfaced connections sharing\nmetering, state, and permissive information between companies.\n\n  - Regional potable water purveyor (importer) sharing turnout water flow rate being delivered\nto a local municipality’s water plant.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\n1. Limit the exposure to 3rd party networks and equipment.\n**Security**\n2. Authenticate external devices to prevent spoofing.\n\nLimits the ability for intentional or unintentional modifications or access\n**Reliability**\nfrom 3rd party locations or equipment.\n**Maintenance**\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA010 - Impair Process Control](https://collaborate.mitre.org/attackics/index.php/Impair_Process_Control)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0836 - Modify Parameter](https://collaborate.mitre.org/attackics/index.php/Technique/T0836)\n\n**SR 7.6: Network and security configuration settings**\n**ISA 62443-3-3**\n**SR 7.7: Least functionality**\n\n**CR 7.6: Network and security configuration settings**\n**ISA 62443-4-2**\n**CR 7.7: Least functionality**\n\n**SD-4: Secure design best practices**\n\n**ISA 62443-4-1** **SI-1: Security implementation review**\n\n**SVV-1: Security requirements testing**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|1. Limit the exposure to 3rd party networks and equipment. 2. Authenticate external devices to prevent spoofing.|\n|Reliability|Limits the ability for intentional or unintentional modifications or access from 3rd party locations or equipment.|\n|Maintenance||\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA010 - Impair Process Control Technique: T0836 - Modify Parameter|\n|ISA 62443-3-3|SR 7.6: Network and security configuration settings SR 7.7: Least functionality|\n|ISA 62443-4-2|CR 7.6: Network and security configuration settings CR 7.7: Least functionality|\n|ISA 62443-4-1|SD-4: Secure design best practices SI-1: Security implementation review SVV-1: Security requirements testing|\n\n\n-----\n\n**30 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 15. Define a safe process state in case of a PLC restart\n\n**Define safe states for the process in case of PLC restarts (e.g., energize contacts, de-**\n**energize, keep previous state).**\n\n**Security Objective** **Target Group**\n\nProduct Supplier\nResilience\nIntegration / Maintenance Service Provider\n\n### Guidance\nIf something commands a PLC to restart in the middle of a working process, we should expect the\nprogram to pick up smoothly with minimal disruption to the process. Make sure that the process it\ncontrols is restart-safe.\n\nIf it is not practical to configure the PLC to restart-safely, be sure that it alerts you to this fact and\nthat it does not issue any new commands. Also, for that case, ensure that the Standard Operating\nProcedures (SOP) have very clear instructions for setting the manual controls so that the PLC will\nstart up the process properly.\n\nAlso, document all start-up, shut-down, steady state control, and flying control system restart\nprocedures.\n\n### Example\n/\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\n**Eliminates potential unexpected behavior:**\nThe most basic attack vector for a PLC is to force it to crash and / or\nrestart. For many PLCs, it is not that hard to do, because many PLCs\ncannot cope well with unexpected inputs or too much traffic. While there\n\n**Security**\n\nare several diagnostics for controller actions while it is running, how it\nhandles startup up with a running process is usually not clear. This may\nbe uncommon, but it is a basic attack vector if we take into account\nmalicious behavior of an attacker.\n\n**Avoid unexpected delays:**\nIf after a PLC power on, the state machine initializes to a state with some\nconditions that don’t let the process to start, and the operator cannot\n\n**Reliability**\n\nnormalize the system, a technician would need to enter the PLC program\nto force the conditions to go to the desired state to be able to start\noperation. This could cause delays and production losses.\n**Maintenance** /\n\n|energize, keep previous state).|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Resilience|Product Supplier Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Eliminates potential unexpected behavior: The most basic attack vector for a PLC is to force it to crash and / or restart. For many PLCs, it is not that hard to do, because many PLCs cannot cope well with unexpected inputs or too much traffic. While there are several diagnostics for controller actions while it is running, how it handles startup up with a running process is usually not clear. This may be uncommon, but it is a basic attack vector if we take into account malicious behavior of an attacker.|\n|Reliability|Avoid unexpected delays: If after a PLC power on, the state machine initializes to a state with some conditions that don’t let the process to start, and the operator cannot normalize the system, a technician would need to enter the PLC program to force the conditions to go to the desired state to be able to start operation. This could cause delays and production losses.|\n|Maintenance|/|\n\n\n-----\n\n**31 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA009 - Inhibit Response Function](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0816 - Device Restart/Shutdown](https://collaborate.mitre.org/attackics/index.php/Technique/T0816)\n**ISA 62443-3-3** **SR 3.6: Deterministic Output**\n**ISA 62443-4-2** **CR 3.6: Deterministic Output**\n**ISA 62443-4-1** **SVV-1: Security requirements testing**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA009 - Inhibit Response Function Technique: T0816 - Device Restart/Shutdown|\n|ISA 62443-3-3|SR 3.6: Deterministic Output|\n|ISA 62443-4-2|CR 3.6: Deterministic Output|\n|ISA 62443-4-1|SVV-1: Security requirements testing|\n\n\n-----\n\n**32 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 16. Summarize PLC cycle times and trend them on the HMI\n\n**Summarize PLC cycle time every 2-3 seconds and report to HMI for visualization on a**\n**graph.**\n\n**Security Objective** **Target Group**\nMonitoring Integration / Maintenance Service Provider\n\n### Guidance\nCycle times are usually system variables in a PLC and can be used for summarizing in PLC code.\nSummarization should be done to calculate average, peak, and minimum cycle times. The HMI should\ntrend these values and alert if there are significant changes.\n\nThe cycle time is the time it takes to compute each iteration of logic for the PLC. The iterations are\nthe combination of Ladder Diagrams (LD), Function Block Diagrams (FBD), Instruction List (IL), and\nStructured Text (ST). These logic components may be joined together with the Sequential Function\nCharts (SFC).\n\nCycle times should be constant on a PLC unless there are changes to e.g.\n\n  - network environment\n\n  - PLC logic\n\n  - process\n\nTherefore, unusual cycle time changes can be an indicator that PLC logic changed and thus provide\nvaluable information for integrity checks.\n\nVisualizing values over time using a graph provides an intuitive way to draw attention to anomalies\nwhich would be harder to notice by just having absolute values.\n\n### Example\nMany PLCs have a “maximum cycle time” monitoring at hardware level. If the cycle time exceeds the\nmaximum value, the hardware sets the CPU to STOP (5).\nOf course, attackers are aware of this and will keep a possible attack code as lean as possible to\nminimize the impact on the overall cycle time. In an additional software cycle time monitoring\nprogram, a reference cylce time tref is defined as base cycle time. As small fluctuations are natural,\nan acceptable threshold needs to be defined (1,3) The cycle monitoring is triggered, if the threshold\nis exceeded (2,4).\n\n|graph.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Monitoring|Integration / Maintenance Service Provider|\n\n\n-----\n\n**33 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\nAny deviance from the reference time can be stored in a logfile like this:\n\nIf cycle times are trended to the HMI, heavy CPU loads are visible at a glance. The following example\ndiagram shows an PLC-Program with periodically executed malicious code. (1,3) show acceptable\ncycle time fluctuations (“noise”) during normal operation, attack code is executed on (2,4) which\nincrease the cycle time.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nAttacks to PLCs include changing its logic, activating a new program,\ntesting new code, loading a new process recipe, inserting auxiliary logic\nto send messages or activate some feature. For most PLCs, traditional\ncryptographic integrity checks are not feasible. However, it’s good to\n\n**Security**\n\nalert if any of the above logic changes happen. Since cycle times are\nrather constant under normal circumstances, changes in cycle times are a\ngood indicator that the logic in one of the above logic components has\nchanged.\n**Reliability** See security, but for non-malicious causes.\n**Maintenance** /\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Attacks to PLCs include changing its logic, activating a new program, testing new code, loading a new process recipe, inserting auxiliary logic to send messages or activate some feature. For most PLCs, traditional cryptographic integrity checks are not feasible. However, it’s good to alert if any of the above logic changes happen. Since cycle times are rather constant under normal circumstances, changes in cycle times are a good indicator that the logic in one of the above logic components has changed.|\n|Reliability|See security, but for non-malicious causes.|\n|Maintenance|/|\n\n\n-----\n\n**34 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA002 - Execution](https://collaborate.mitre.org/attackics/index.php/Execution)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0873 - Project File Infection](https://collaborate.mitre.org/attackics/index.php/Technique/T0873)\n**ISA 62443-3-3** **SR 3.4: Software and information integrity**\n**ISA 62443-4-2** **EDR 3.2: Protection from malicious code**\n**MITRE CWE** **CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA002 - Execution Technique: T0873 - Project File Infection|\n|ISA 62443-3-3|SR 3.4: Software and information integrity|\n|ISA 62443-4-2|EDR 3.2: Protection from malicious code|\n|MITRE CWE|CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**35 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 17. Log PLC uptime and trend it on the HMI\n\n**Log PLC uptime to know when it’s been restarted. Trend and log uptime on the HMI for**\n**diagnostics.**\n\n**Security Objective** **Target Group**\nMonitoring Integration / Maintenance Service Provider\n\n### Guidance\nKeep track of PLC uptime\n\n  - in the PLC itself (if uptime is a system variable in the PLC)\n\n  - in the PLC itself if it has MIB-2 / any SNMP implementation\n\n  - externally by means of e.g., SNMP\n\nIf the PLC has SNMP with MIB-2, which is very common, the OID for uptime “sysUpTimeInstance(0)”\nis 1.3.6.1.2.1.1.3. Uptime resets are important indicators for PLC restarts. Make sure the HMI\nalerts to any sort of PLC restart.\n\nUptime correlated with error codes are good diagnostics.\n\n### Example\n/\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nThe most basic attack vector for a PLC is to force it to crash and / or\nrestart. For many PLCs, it is not that hard to do, because many PLCs\n\n**Security** cannot cope well with unexpected inputs or too much traffic. Thus,\n\nunexpected restarts can be an indicator that the PLC encounters unusual\nactions.\n\nPLC restarts are also good for diagnostics in case of failures and for\n**Reliability**\nmonitoring which PLCs are being worked on at what time.\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA009 - Inhibit Response Function](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0816 - Device Restart/Shutdown](https://collaborate.mitre.org/attackics/index.php/Technique/T0816)\n**ISA 62443-3-3** **SR 7.6: Network and security configuration settings**\n**ISA 62443-4-2** **CR 7.6: Network and security configuration settings**\n**MITRE CWE** **CWE-778: Insufficient Logging**\n\n|diagnostics.|Col2|\n|---|---|\n|Security Objective|Target Group|\n|Monitoring|Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|The most basic attack vector for a PLC is to force it to crash and / or restart. For many PLCs, it is not that hard to do, because many PLCs cannot cope well with unexpected inputs or too much traffic. Thus, unexpected restarts can be an indicator that the PLC encounters unusual actions.|\n|Reliability|PLC restarts are also good for diagnostics in case of failures and for monitoring which PLCs are being worked on at what time.|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA009 - Inhibit Response Function Technique: T0816 - Device Restart/Shutdown|\n|ISA 62443-3-3|SR 7.6: Network and security configuration settings|\n|ISA 62443-4-2|CR 7.6: Network and security configuration settings|\n|MITRE CWE|CWE-778: Insufficient Logging|\n\n\n-----\n\n**36 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 18. Log PLC hard stops and trend them on the HMI\n\n**Store PLC hard stop events from faults or shutdowns for retrieval by HMI alarm**\n**systems to consult before PLC restarts. Time sync for more accurate data.**\n\n**Security Objective** **Target Group**\nMonitoring Integration / Maintenance Service Provider\n\n### Guidance\nFault events indicate why a PLC shut down so that the issue can be addressed before a restart.\n\nSome PLCs may have error codes from the last case where the PLC faulted or shut down improperly.\nRecord those errors and then clear them. It might be a good idea to report those errors to the HMI as\ninformational data or perhaps to a syslog server, if those features and that infrastructure exist.\n\nMost PLCs also have some kind of first scan feature that generates events. It is a behavior that nearly\nall PLC equipment have in some form. It is basically one or more flags, or a designated routine that is\nexecuted on the first scan of a PLC after it “wakes up.” This First Scan should be logged and tracked.\n\n### Example\n/\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nLogs enable troubleshooting in case of an incident. Before a PLC becomes\n\n**Security** operational, especially after having experienced problems, it is important\n\nto ensure it is trustworthy.\n\nLogs are also good sources for debugging if the event was not caused\n**Reliability**\nmaliciously.\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA009 - Inhibit Response Function](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0816 - Device Restart/Shutdown 1](https://collaborate.mitre.org/attackics/index.php/Technique/T0816)\n**ISA 62443-3-3** **SR 7.6: Network and security configuration settings**\n**ISA 62443-4-2** **CR 7.6: Network and security configuration settings**\n**MITRE CWE** **CWE-778: Insufficient Logging**\n\n|Security Objective|Target Group|\n|---|---|\n|Monitoring|Integration / Maintenance Service Provider|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Logs enable troubleshooting in case of an incident. Before a PLC becomes operational, especially after having experienced problems, it is important to ensure it is trustworthy.|\n|Reliability|Logs are also good sources for debugging if the event was not caused maliciously.|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA009 - Inhibit Response Function Technique: T0816 - Device Restart/Shutdown 1|\n|ISA 62443-3-3|SR 7.6: Network and security configuration settings|\n|ISA 62443-4-2|CR 7.6: Network and security configuration settings|\n|MITRE CWE|CWE-778: Insufficient Logging|\n\n\n-----\n\n**37 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 19. Monitor PLC memory usage and trend it on the HMI\n\n**Measure and provide a baseline for memory usage for every controller deployed in the**\n**production environment and trend it on the HMI.**\n\n**Security Objective** **Target Group**\n\nIntegration / Maintenance Service Provider\nMonitoring\nAsset Owner\n\n### Guidance\nSince the increase of lines of code in the logic can also lead to increased memory consumption at\nruntime, it is recommended for PLC programmers to track any deviation from the baseline and\ndedicate an alarm class to this event.\n\n### Example\nIn Rockwell Allen Bradley PLCs, a baseline can be established on a controller and memory usage can\nbe tracked using the RSLogix 5000 Task Monitor Tool. Not only the main memory but also the I/O\nmemory and Ladder/Tag memory can be tracked using trends.\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nIncreased memory usage can be an indicator of the PLC running altered\n**Security**\ncode.\n\nTracking memory usage for the running programs could be useful in\n\n**Reliability** avoiding total memory consumption and eventual fault state for the PLC\n\ncontroller.\n\nTracking memory usage could be used in tuning and finding the best scan\n\n**Maintenance** time for the monitored controller but also in troubleshooting problems\n\nand issues related to faulty states.\n\n### References\n\n**Standard / framework Mapping**\n\n**[Tactic: TA002 - Execution](https://collaborate.mitre.org/attackics/index.php/Execution)**\n**MITRE ATT&CK ICS**\n**Technique:** [T0873 - Project File Infection](https://collaborate.mitre.org/attackics/index.php/Technique/T0873)\n**ISA 62443-3-3** **SR 3.4: Software and information integrity**\n**ISA 62443-4-2** **EDR 3.2: Protection from malicious code**\n\n|Security Objective|Target Group|\n|---|---|\n|Monitoring|Integration / Maintenance Service Provider Asset Owner|\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Increased memory usage can be an indicator of the PLC running altered code.|\n|Reliability|Tracking memory usage for the running programs could be useful in avoiding total memory consumption and eventual fault state for the PLC controller.|\n|Maintenance|Tracking memory usage could be used in tuning and finding the best scan time for the monitored controller but also in troubleshooting problems and issues related to faulty states.|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic: TA002 - Execution Technique: T0873 - Project File Infection|\n|ISA 62443-3-3|SR 3.4: Software and information integrity|\n|ISA 62443-4-2|EDR 3.2: Protection from malicious code|\n\n\n-----\n\n**38 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## 20. Trap false negatives and false positives for critical alerts\n\n**Identify critical alerts and program a trap for those alerts. Set the trap to monitor the**\n**trigger conditions and the alert state for any deviation.**\n\n**Security Objective** **Target Group**\nMonitoring Integration / Maintenance Service Provider\n\n### Guidance\nIn most cases, alert-states are boolean (True, False) and triggered by certain conditions as displayed\nbelow. E.g., the trigger bit for the alert ‘overpressure’ becomes TRUE, if Condition 1 ‘pressure switch\n1’, Condition 2 ‘pressure sensor value over critical threshold’, through n., are TRUE.\n\nTo masquerade an attack, an adversary could suppress the alert trigger bit and cause a false\nnegative.\n\nA trap for false negatives monitors the conditions for the trigger bit and the negated trigger bit itself.\nWith this simple setup, a false negative is detected. See the following picture:\n\nIn other cases, an adversary could deliberately cause false positives, to wear down the process\noperator’s attention.\n\nIn the same manner of the false negative trap, false positives can also be detected by monitoring the\nalert trigger bit and if the trigger conditions are met. If the conditions are NOT met, but the trigger bit\nis active, a false positive is detected: See the following picture:\n\n|Security Objective|Target Group|\n|---|---|\n|Monitoring|Integration / Maintenance Service Provider|\n\n\n-----\n\n**39 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Example\n**Example 1: Siemens offers in their Siemens S7-1200/1500 Products a Webserver with a wide range of**\nfunctions, for example display of the PLC-State, cycle time or scope records. It also has the option to\nview and modify data tables and variables. The access rights to the Webserver can be modified in the\nPLC-Hardware Settings. In case of mis-configured access rights an adversary could gain access to the\nPLC Variables and Datablocks. To create a false positive, the adversary selects an alert trigger bit and\nalters the state.\n\n**Example 2: In the Triton/Trisys/HatMan attack, rogue code suppressed alert states.**\n\n**Example 3: A bus-injection attack could send a false positive alert to a high-level SCADA client.**\n\n### Why?\n\n**Beneficial for…?** **Why?**\n\nMitigates false negative or false positives of critical alert messages\ncaused by an adversary obfuscating their attack (i.e., rogue code, bus\n\n**Security**\n\ninjection, tampering with accessible PLC state tables on unsecured\nwebservers).\n**Reliability** /\n**Maintenance** /\n\n### References\n\n**Standard / framework Mapping**\n\n**Tactic :** [TA009 - Inhibit Response Function](https://collaborate.mitre.org/attackics/index.php/Inhibit_Response_Function)\n**MITRE ATT&CK ICS**\n**Technique:** [T0878 - Alarm Suppression](https://collaborate.mitre.org/attackics/index.php/Technique/T0878)\n**ISA 62443-3-3** **SR 3.5 : Input Validation**\n**ISA 62443-4-2** **CR 3.5 : Input Validation**\n**ISA 62443-4-1** **SI-1 : Security implementation review**\n**MITRE CWE** **CWE-754: Improper Check for Unusual or Exceptional Conditions**\n\n|Why?|Col2|\n|---|---|\n|Beneficial for…?|Why?|\n|Security|Mitigates false negative or false positives of critical alert messages caused by an adversary obfuscating their attack (i.e., rogue code, bus injection, tampering with accessible PLC state tables on unsecured webservers).|\n|Reliability|/|\n|Maintenance|/|\n\n|References|Col2|\n|---|---|\n|Standard / framework|Mapping|\n|MITRE ATT&CK ICS|Tactic : TA009 - Inhibit Response Function Technique: T0878 - Alarm Suppression|\n|ISA 62443-3-3|SR 3.5 : Input Validation|\n|ISA 62443-4-2|CR 3.5 : Input Validation|\n|ISA 62443-4-1|SI-1 : Security implementation review|\n|MITRE CWE|CWE-754: Improper Check for Unusual or Exceptional Conditions|\n\n\n-----\n\n**40 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n## About the Secure PLC Programming project\nFor many years, Programmable Logic Controllers (PLCs) have been insecure by design. Several years\ninto customizing and applying best practices from IT gave rise to secure protocols, encrypted\ncommunications, network segmentation etc. However, to date, there has not been a focus on using\nthe characteristic features in PLCs (or SCADA/DCS) for security, or how to program PLCs with security\nin mind. This project – inspired by the existing Secure Coding Practices for IT – fills that gap.\n\n### Who should read and implement the Secure PLC Coding Practices?\nThese practices have been written for engineers. The aim of this project is to provide guidelines to\nengineers that are creating software (ladder logic, function charts etc.) to help improve the security\nposture of Industrial Control Systems. These practices leverage natively available functionality in the\nPLC/DCS. Little to no additional software tools or hardware is needed to implement these practices.\nThey can all be fit into the normal PLC programming and operating workflow. More than security\nexpertise, good knowledge of the PLCs to be protected, their logic, and the underlying process is\nneeded for implementing these practices.\n\n### What is the scope if this list / how do you define PLC Coding?\nTo fit the scope of the Top 20 Secure PLC Coding practices list, practices need to involve changes\nmade directly to a PLC. What you see in this document is a Top 20 selection of a larger number of\npotential secure PLC coding practices. There are also additional draft practices pertaining to the\noverall architecture, HMIs, or documentation. Those do not fit the scope of secure PLC coding, but\ncould be on a future list on secure PLC environment.\n\n### What are the benefits of applying Secure PLC Coding Practices?\nUsing these practices clearly has security benefits – mostly either reducing the attack surface or\nenabling faster troubleshooting if a security incident were to happen. However, many practices have\nadditional benefits beyond security. Some also make the PLC code more reliable, easier to debug and\nmaintain, easier to communicate, and possibly also leaner. Further, the secure PLC coding practices\nnot only help users in the event of a malicious attacker but also make the PLC code more robust to\nwithstand accidental misconfiguration or human error.\n\n### Who’s behind this project?\n[It all started with Jake Brodsky’s S4x20 talk “Secure Coding Practices for PLC’s”.](https://www.youtube.com/watch?v=JtsyyTfSP1I)\n\nAfter the conference, Dale Peterson initiated the Top 20 project. Jake Brodsky and Sarah Fluchs spent\nseveral hours on the phone to bring Jake’s proposed secure PLC coding practices to paper.\nAfterwards Dale, Jake and Sarah set up a platform at top20.isa.org, supported by ISA GCA, to\nstructure and gather additional input from the ICS security and engineers’ communities.\n\nDiscussions and consolidation of the practice texts, and curating a list of the most relevant Top 20\npractices took about a year; the process was accelerated by Vivek Ponnada who besides contributing\nand reviewing content, also organized regular calls until all comments on practices were resolved,\nMohamed Abdelmoez Sakesli who added all the standards references in one big effort, the MITRE\nCWE team who provided the CWE references last-minute, Sarah who compiled the document you\nare reading now, and Jake, Dale, John Cusimano, Dirk Rotermund, Josh Ruff, Thomas Rabenstein, Gus\nSerino, Walter Speth, Agustin Valencia Gil-Ortega, Marcel Rick-Cen, and Al Ratheesh R, who provided\ninput throughout the regular calls.\n\n\n-----\n\n**41 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\n### Supporters’ list\nThe Secure PLC Coding Project is, and continues to be, a true community effort, which would not\nhave been possible without countless contributors generously sharing their time and PLC/security\nknowledge. A total of 943 Users registered on the platform to discuss and contribute. Here is an\nalphabetical list of all who explicitly agreed to be named. Thank you everyone who took the time to\nsupport this project!\n\nAagam Shah Josie Houghton\n\nAdam Paturej Jozef Sulwinski\n\nAgustin Valencia Gil-Ortega Juan Pablo Angel Espejo\n\nAitor García Almiñana Khalid Ansari\n\nAlec Summers Marc Weber\n\nAl Ratheesh. R Marcel Rick-Cen\n\nAndreas Falk Martin Huddleston\n\nAnton Shipulin Massimiliano Zonta\n\nArkaitz Gamino Matthew Loong\n\nCarlos Olave Matthias Müller\n\nChris van den Hooven Michael Thompson\n\nChris Sistrunk Michal Stepien\n\nChristos Alexopoulos Miguel Angel Frias\n\nCris DeWitt Mohamed Abdelmoez Sakesli\n\nDale Peterson Moon Eluvangal Chandran\n\nDene Yandle Nahuel Iglesias\n\nDennis Verschoor Nalini Kanth\n\nDirk Rotermund Narasimha S. Himakuntala\n\nEdorta Echave García Omar Morando\n\nGananand Kini Oscar J. Delgado-Melo\n\nGeorge Alex Holburn Päivi Brunou\n\nGus Serino Peter Donnelly\n\n\n-----\n\n**42 / 42**\n\n\n# Secure PLC Coding Practices: Details\nVersion 1.0 (15 June 2021)\n\nHakija Agic Peter Jackson\n\nHector Medrano Ravindra Deshakulakarni\n\nHeiko Rudolph Rick Booij\n\nIsiah Jones Robert Albach\n\nJacob Brodsky Rushi Purohit\n\nJavier Perez Quezada Sarah Fluchs\n\nJ-D Bamford Sergei Biberdorf\n\nJoe Weiss Stephan Beirer\n\nJohn Cusimano Steve Christey Coley\n\nJohn Hoyt Thomas Rabenstein\n\nJohn Powell Tim Gale\n\nJohn Kingsley Vivek Ponnada\n\nJoseph J. Januszewski Vytautas Butrimas\n\nJosh Ruff Walter Speth\n\n**Special thanks to these organizations who generously provided infrastructure to use for the project**\n**team like domains, hosting, and web design and graphic design:**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://plc-security.com/content/Top_20_Secure_PLC_Coding_Practices_V1.0.pdf"
    ],
    "report_names": [
        "Top_20_Secure_PLC_Coding_Practices_V1.0.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1682474888,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1623619893,
    "ts_modification_date": 1623619893,
    "files": {
        "pdf": "https://archive.orkl.eu/99139b55b6234c874bfc534c787c1bdf821bcab8.pdf",
        "text": "https://archive.orkl.eu/99139b55b6234c874bfc534c787c1bdf821bcab8.txt",
        "img": "https://archive.orkl.eu/99139b55b6234c874bfc534c787c1bdf821bcab8.jpg"
    }
}