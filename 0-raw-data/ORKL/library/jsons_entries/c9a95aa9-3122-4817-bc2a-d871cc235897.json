{
    "id": "c9a95aa9-3122-4817-bc2a-d871cc235897",
    "created_at": "2023-01-12T15:02:19.205814Z",
    "updated_at": "2025-03-27T02:16:59.173617Z",
    "deleted_at": null,
    "sha1_hash": "3d0db72fa4f453ee01b699006609a3b577546945",
    "title": "2022-03-28 - Betabot in the Rearview Mirror",
    "authors": "",
    "file_creation_date": "2022-05-28T04:06:26Z",
    "file_modification_date": "2022-05-28T04:06:26Z",
    "file_size": 3420914,
    "plain_text": "# Betabot in the Rearview Mirror\n\n**[krabsonsecurity.com/2022/03/28/betabot-in-the-rearview-mirror/](https://krabsonsecurity.com/2022/03/28/betabot-in-the-rearview-mirror/)**\n\nAKA Alpha reverse engineer vs Betabot\n\nBetabot is a malware that by now should be familiar to most, if only in name. Initially\ndeveloped in 2013, the last version, 1.8.0.11, was released around 2015-2016 and a crack\nwas made around September 2016 which eventually became public. Rumors of a 1.9 version\nwere heard of, however no binaries were ever seen that corroborated this, so it is safe to say\nthat development has ceased completely since then. Despite this lack of updates, Betabot is\n[still widely used ‚Äì a recent Kaspersky report suggests that it accounts for 3.5% of their](https://securelist.com/financial-cyberthreats-in-2020/101638/)\nbanking malware detections in 2020, up from 2019‚Äôs 2.4%. Comprehensive deep dives into\n[the malware is lacking ‚Äì the closest thing to this is the excellent 2013 analysis by Zhongchun](https://www.virusbulletin.com/virusbulletin/2013/11/neurevt-bot-analysis)\nHuo ‚Äì and as such this series will aim to provide such a comprehensive overview covering\neverything notable that is in the binary.\n\nIn this post, we‚Äôll be analyzing a cracked 1.8.0.11 binary, which is also known as ‚ÄúNeurevt‚Äù\ndue to the string being present in the binary. What is great about this crack is that unlike a lot\nof cracks where integrity checks and anti-RE code are either entirely removed or\ncircumvented by patching deeper inside the binary, the reverse engineer has kept them\nentirely intact and generated the correct checksums instead, meaning that the binary we get\nfrom the crack is effectively identical to what the original malware author would‚Äôve given us.\nThere are at least 10 different integrity checks for the config spread throughout the binary ‚Äì if\nany of these fails, the bot will not function properly. In addition, this is the main crack that is\nfloating around, so virtually all Betabot binaries that are observed in the wild will be identical\nto this (with the exception of configuration values changing of course). Another implication of\nanalyzing this binary is that the specific protocol version (Betabot has had several\nincremental protocol updates throughout its history) is version 1.8.0.6 for the response, and\n1.8.0.5 for the bot request. This should not matter much at the end of the day however ‚Äì as\nthere are no other relevant copies of Betabot available.\n\nWe will start out with the general methodology of reverse engineering Betabot and the basic\nbuilding blocks of the malware, and then start looking at the most important parts of Betabot.\n\n## The first layer\n\nWe first start with the initial Betabot binary, which is a loader of sorts. The first layer is a fairly\ntypical packer. It sets an exception handler to relaunch itself upon a crash, and also detects\ndebuggers through the PEB.\n\n\n-----\n\nThe packer then xors an encrypted buffer and decompresses it using aplib, before finally\nmapping and executing it. The mapping is a bit special as the PE header at the beginning of\nthe buffer is fake, while the real PE header is semi-custom and encrypted.\n\n\n-----\n\n## The inner payload\n\nIn order to analyze this payload, I simply dumped it directly from memory at the OEP to avoid\ndealing with the PE header issues and then used fasm to generate a PE file that would allow\nme to analyze the dump in IDA. The simple FASM template is included in the appendix.\nFrom this point on, all analysis is done statically using IDA Pro.\n\n**Entrypoint(s) and import handling**\n\nThe payload has 3 entrypoints, a primary one and two others that are executed by the\ninjector for other functionalities (I believe it is for the botscript loader and the ring3 kit, which\nis discussed in the later section). All entrypoints call the same common-entrypoint function,\n\n\n-----\n\nhowever they differ in that they store their own address to a variable that is used to\ndetermine which entrypoint was called, in addition to setting two other flags to indicate to\nother functions which entrypoint was used.\n\nOne of the things the common entrypoint does is initializing the imports, which are stored in a\nglobal structure. This structure is initialized from a table of hashes (which I named\nImportHashTable) which takes the following form.\n\nHash, apiNameLen and indexDll should be fairly self-evident, however ptrStore is a very\nstrange entry ‚Äì it points to members in another structure (which I named\nImportTableRegular) that receives the final pointer. This structure is simply a bunch of\npointers to imported APIs.\n\nDLLs are loaded from a similar struct which is stored in an array ‚Äì and then APIs are loaded\nfrom a custom hash which combines the DLL name and API name together.\n\n\n-----\n\n-----\n\nThe most interesting part is in how Betabot does not just load the pointers for some APIs ‚Äì it\nalso creates a table of thunks for them. The first thunk for LdrGetProcedureAddress is a\nsimple push-ret stub and is not stored in the global thunk region. For all other thunked\nfunctions, the thunk is placed in the global thunk region and has a small structure appended\nmarked with the magic value (0xF820AB06) containing the original pointer. The thunk itself\ndepends on the kind of function ‚Äì if the function is a service function (for example a syscall\nstub, or a thunk itself), it is copied in its entirety to the new thunk region. If the function\nappears hooked, a special thunk stub is used instead.\n\n\n-----\n\nService functions are directly copied\n\n\n-----\n\nThunking of hooked functions\n\nCode for retrieving the original pointer of a thunked function pointer\nCode for automatic handling of the imports will be attached in the appendix after it is cleaned\nup.\n\n\n-----\n\nAfter initializing the import table, Betabot creates the registry key\n‚ÄúHKCU\\\\Software\\\\AppDataLow\\\\Software\\\\MyMailClient‚Äù, which is used to track the crash\ncount (more on this later).\n\n**Thread manager**\n\nBetabot has a slot-based system for managing its threads. This thread tracker supports\ntracking either 256 or 45 threads depending on whether the current process is Betabot‚Äôs\nmain process or not.\n\nAs we can see, there are either 45 or 256 slots available in the thread tracker. The first 31\n(starting from slot 0) are reserved for special usage, slot 31 and 32 are markers indicating\nthat the thread is a ‚Äúfree‚Äù thread without a hardcoded index, and will be dynamically allocated\na space starting from slot 34.\n\n\n-----\n\nWhen Betabot creates a new thread, it fakes the thread starting address as either being in\nKernel32 or being in Ntdll. It chooses the address as follows.\n\n\n-----\n\nTo fake the thread start address, it creates the thread suspended at the address, and then\nchange the Eax register to a custom stub which will receive the threadInfo structure and do\nthe final processing to call the desired function. This works because the thread is still in\nBaseThreadInitThunk and hasn‚Äôt called the target function yet ‚Äì it will do so by reading Eax\nwhich contains the new thread‚Äôs function.\n\nThe new stub it is set to a function I called EaxProc, which first hides itself from debuggers\nby using NtSetInformationThread, and then finally register itself in the thread tracker\nstructure.\n\n\n-----\n\n-----\n\nBack to the creator thread, it waits for it for 2 seconds and then sets the appropriate ACL if\nrequested and then returns.\n\n**Registry manager**\n\nBetabot has a two-level registry structure that uses a pseudorandom algorithm to generate\nregistry names from seed values. A value is referred to by two strings, its group and\nsubidentifier. Known groups are CS1 and CG1. The registry path is identified as follow\n(where str1 is the group ID):\n\n\n-----\n\nThe registry value name is generated from the subidentifier as follow:\n\nThe appendix contains information on known subidentifiers and their meanings.\n\n**Anti-analysis**\n\n\n-----\n\nBetabot employs several methods for the detection of virtual machines, sandboxes and\ndebuggers. Detection of sandboxes and debuggers result in the bot artificially\ncrashing/exiting, whereas VM detections are stored in some variables and do not result in a\ncrash ‚Äì however it will result in behaviors being modified in some specific code paths.\n\nSeveral antidebug tricks are also littered throughout regular functions ‚Äì for example the\nfollowing detection and crash appears in the middle of the initialization of the Dynamic\nContext structure.\n\nVM detection is done as follows.\n\n\n-----\n\n-----\n\nThere also appears to be a bug in the isVirtualMachine routine ‚Äì the result of isInVM is\ndiscarded. Regardless, if a VM is detected, it sets 2 variables and the bot attribute flag for\nVMs.\n\nIn addition to this, Betabot also detects the presence of Ollydbg, Regmon, ImmunityDbg,\nRohitab‚Äôs API Monitor, Procmon, IDA Pro. It also checks whether the disk contains the string\nVMWare or VBox.\n\n\n-----\n\n-----\n\nIt also tries to see whether its parent process is suspicious, and logs the information found\ninside the dynamicCTX and registry.\n\n\n-----\n\n**AV handling**\n\nBetabot detects AVs and modifies its behaviors based on what AV is installed. In addition to\nthis, it also is capable of attempting to kill AV solutions. To detect AVs, Betabot has several\nsignature packs with the format below, which are used to search in various places such as\nservices, Run key entries, and SOFTWARE registry keys.\n\n\n-----\n\nBetabot is also capable of terminating AVs. The orchestrators‚Äô logic is quite simple and\nrepetitive.\n\n\n-----\n\nTo see how it attacks an AV solution, let‚Äôs look at ESET.\n\n\n-----\n\nHere, we see that it tries to block the AV executables from launching using the IFEO key. It\ndoes not do so from its own context, instead it spawns a new process and injects into it to\nperform the registry operation from there. Some AVs do have a custom process that gets\nspawned and injected to (this is specifiable in the regWriteInjectedCall) but by default it is\nregedit.\n\n\n-----\n\nIf the attempt to set the IFEO key fails, Betabot attempts to prevent the executable from\nlaunching by creating a manifest/config file for it that contains invalid content. How it does\nthis is most interesting: it creates a pagefile there, which would get filled with random (and\nthus invalid) data.\n\n\n-----\n\n[This method originated probably from KernelMode.info in 2012. Interestingly enough ‚Äì I don‚Äôt](https://www.kernelmode.info/forum/viewtopic4b8c.html?t=1926)\nthink this idea has gained much prominence since then, as this is the first that I‚Äôve seen it in\npractice or mentioned anywhere at all.\n\n**LPE and UAC bypass**\n\nBetabot employs 2 CVEs as well as several other tricks to gain administrator privilege. The\nfirst thing we will be discussing are the LPEs. Currently, there are only 2 LPEs available,\nhowever the exploit orchestrator is designed in a module-based fashion so that more LPEs\ncan be added with little code change.\n\n\n-----\n\nAs we can see, Betabot checks for the presence of the KB that patches the exploit and the\nOS version checked prior to exploitation. The two exploited vulnerabilities are CVE-20151701 (KB3045171) and CVE-2015-0003 (KB3013455), and both are only exploited on 32-bit\nmachines. The first is exploited on Windows 7 and Vista whereas the second is exploited\nonly on Windows 7. The KB check is done as follows.\n\n\n-----\n\nFor both exploits, Betabot retrieves the base address of Ntoskrnl by using\nNtQuerySystemInformation with SystemModuleInformation.\n\n\n-----\n\nThe goal for both are to eventually be able to replace the current process‚Äôs token with a\ntoken from either explorer.exe or printui.exe (which would be launched as admin using\nShellExecute with runas), however in practice the code path for using printui is never\nreached so the token is always stolen from explorer.\n\n\n-----\n\nBoth exploits are public, ancient and well documented so I will not go into details about how\nthey each function here. However, an interesting little detail that I discovered while reversing\nthis exploit is that back in Windows 7, one is able to allocate memory at the address 0, which\nis then used to exploit the null pointer dereference vulnerability in CVE-2015-0003. This is\ndone by passing a value between 1 and 0x1000 (page size) as the base address to\nNtAllocateVirtualMemory.\n\nFor gaining administrator privileges, Betabot also has some other tricks, some interesting\nand some less so. The first simply tries to force the user to accept the administrator prompt\nby spamming it while faking the executed file as cmd.exe with some custom texts.\n\n\n-----\n\nI wish I could fix my issues so easily\nThe second abuses the ISecurityEditor interface to overwrite eudcedit.exe‚Äôs Image File\nExecution Options with the path to the current module. The ISecurityEditor interface did not\nhave proper security checks, allowing an unprivileged user to modify the ACL of an object\nthat they should not have access to. This was fixed on Windows 10 build 10147.\n\n\n-----\n\n-----\n\nIf this operation is successful, Betabot will attempt to launch eudcedit.exe, the debugger for\nwhich is now hijacked to be the Betabot payload.\n\n\n-----\n\n**USB Spreader**\n\nThe USB spreader runs as a Betabot managed thread if the feature is enabled in the C2. It\nuses RegisterDeviceNotificationA to register a notification whenever a new drive is inserted.\n\n\n-----\n\n-----\n\nUpon receiving a window callback, Betabot ensures that the message is one for a new\nvolume being inserted, and ensures that it can get the drive letter for the drive.\n\nThen, it checks whether the drive was already infected or not. This is done by checking for\nthe presence of a file called usb20.sys which Betabot will create as Hidden + Read-Only\nafter the infection process has completed.\n\nAfter this, the betabot binary is copied to Drive:\\\\pp.exe, and files on the drive are replaced\nwith malicious .lnk files that launch betabot along with the original files.\n\n\n-----\n\n-----\n\nIf a file has been successfully replaced, the usb20.sys marker file is created.\n\nLater on, if this shortcut is executed, Betabot is able to tell that it was spreaded like this by\nchecking whether its drive is removable.\n\n\n-----\n\n**Persistence**\n\nBetabot has persistence for both its file and process. Process protection is achieved via a\nRing3 userkit that filters process access, as well as a watchdog that monitors both the file\nand process.\n\n\n-----\n\n-----\n\n-----\n\n-----\n\n**Crash handling**\n\n\n-----\n\nEarly in the execution flow, Betabot registers an exception handler. Interestingly enough, this\nis used not for anti-debugging purposes but quite the opposite ‚Äì it is used to help the\ndeveloper debug issues and to increase stability.\n\nIf the exception handler is ever called, it first logs this in the registry in the CD1\\ECC values.\n\n\n-----\n\nThen, it writes the crash count to the MyMailClient registry key, or increments it if it already\nexists.\n\nFinally, if there is less than 24 crashes logged, it‚Äôll relaunch itself with the /exc parameter\ncorresponding to the number of retries, and then terminates itself.\n\n\n-----\n\n**Hooking engine**\n\nBetabot features an impressive ring-3 system wide hooking mechanism for persistence. As\ndescribed by Zhongchun Huo, it utilizes TLS slots to detect its own threads where hooking\nbehavior should not be applied. There are several ‚Äúclasses‚Äù of hooks, which I will detail\nbelow.\n\nThe first class of hooks is defensive hooks, meant to prevent access to files/registry keys\nthat are deemed protected by Betabot. Generally speaking, they take the following form:\n\n\n-----\n\n-----\n\nThe second class of hooks are hooks designed to sniff information for the stealer. The first\nexample of this are the hooks placed inside Putty‚Äôs process.\n\nHooks being applied\n\n\n-----\n\nData being saved temporally\n\n\n-----\n\nData finally being queued for sending via IPC to main process in savePuttyLog for sending to\nthe C2 server\nThere are also hooks for NtDeviceIoControl, PR_Write, EncryptMessage and SSL_Write.\n\n\n-----\n\nThe hook for NtDeviceIoControl is extremely fascinating, it is designed to intercept\noperations to the AFD device to filter unencrypted traffic directly. Major filtered operations are\nAFD_CONNECT where the hostname is checked against Betabots‚Äô internal blacklist, and\nAFD_SEND where the buffer is scanned and sniffed for passwords. This is also where the\nmysterious strings ‚Äúneurevt‚Äù comes into play üòâ\n\nAs we can see, it searches each packet inside the AFD_SEND request for usernames and\npasswords to log, but then curiously also performs another operation where it checks\nwhether the string ‚Äúwindowsupdate‚Äù or ‚Äúneurevt‚Äù is inside the buffer. If so, it forces the\nconnection to be disconnected. Unfortunately however, we do not know where the string\ncame from. Searches of intelligence feeds yielded no results, and there is no indicator as to\nwhether this is a competing malware variant or something else entirely. No mentions of\n\n\n-----\n\nneurevt can be found that is not from an analysis where the malware is referred to by the\nalias. If anyone from back then knew what this string is, please DM me on twitter, I would\nlove to hear the behind-the-scenes of this.\n\nThe hook for SSL_Write and EncryptMessage is fairly simple, both call the\nsearchForPasswordAndUsername routine to find usernames and passwords in ports for\nprotocols like FTP, SMTP, SMTPS, etc.\n\n\n-----\n\nLikewise, PR_Write just tries to parse the HTTP data for credentials.\n\nLastly in this group, there are hooks for Chrome. Here there are two variants of hooks ‚Äì one\nintercepting SSL_Write (which is located via scanning for the VMT), and the other\nintercepting IPC via hooking NtReadFile. The SSL_Write hook is similar in practice to the\nhook for Firefox.\n\n\n-----\n\nThe other hook for NtReadFile tries to find interesting strings inside the IPC buffer (namely\nPOST/post and HTTP/http), and tries to extract usernames and passwords out of the buffer if\nthis is found.\n\nThe final notable detail of Betabot‚Äôs hooking subsystem is its blocking of MBR bootkit\ninstallation via hooking NtOpenFile ‚Äì file operations on the physical drive without going\nthrough the filesystem are prohibited.\n\n\n-----\n\n**Termination of older versions of the bot**\n\nBetabot finds and kills threads belonging to older versions of itself by checking the TLS slots\nbelonging to threads inside its own process.\n\n\n-----\n\n-----\n\n**Communication cycle and protocol**\n\nBetabot‚Äôs protocol is binary-over-HTTP. RC4 is used for encryption. First, the URL is\ngenerated from the config, and then a random parameter is appended.\n\n\n-----\n\nThen, depending on the stage of its lifecycle, Betabot chooses a type of request to perform,\nand depending on the specific requests, some streams might be added.\n\nAfter the information streams are built, the generic request is constructed.\n\n\n-----\n\n-----\n\nIt encrypts and formats this data and then finally sends the request to the server. If a\nresponse is available, it tries to receive it and then parse it.\n\n\n-----\n\nFirst, the response‚Äôs disposition value is checked and if it is set to\nBB_DISPOSITION_UNINSTALL, the bot uninstalls itself. This might be of particular interest\nto those who want to write tools to terminate Betabot, since simply executing the function will\nbe enough to disable the bot permanently üòâ.\n\n\n-----\n\nThen, it processes and propagates the new general flags, minor flags, and custom flags via\nits windows-based IPC mechanism. It also tries to kill old betabot versions if told to do so by\nthe C2 server.\n\nIt then saves these values to the registry.\n\n\n-----\n\nThen, if proactive defense is enabled, it tries once to elevate privileges.\n\nThe knock interval is also saved to the dynamic context.\n\nThen, commands are processed. The structure of the commands are already described in\ntwo previous writeups on VB, so I will focus on the higher level details here:\n\nFor each command, first, the command ID is retrieved from a table by hashing the command\nstring.\n\n\n-----\n\n-----\n\nThe table is as follows:\n\nAfter that, the command ID is used to find out how to parse the parameters, and then finally\nthe handler inside the table is called.\n\nFinally, after all the commands are processed, the configuration streams are saved to the\nregistry and updated in-memory. Interestingly, the stream CF07 has no identified uses and\nseems to be reserved for future functionalities (that likely will never arrive).\n\n\n-----\n\n**Interesting commands**\n\nMost of the commands are self-explanatory and as such I will not discuss them in detail. The\nfirst interesting command that people would likely notice is ‚ÄúBotscript‚Äù. What exactly is a\nbotscript? Does Betabot have an embedded scripting engine? As it turns out, this is not the\ncase. Botscript is simply the developers name for injecting wscript into another process using\nRunPE and then using that to execute a script.\n\n\n-----\n\nTranslated sales thread describing Botscript\nBotscript operations run inside a new thread with index 3.\n\nIn the new thread, the botscript is downloaded and then injected.\n\n\n-----\n\n-----\n\n-----\n\nThe other interesting feature is support for running a SOCKS proxy server. The server config\nis parsed and then started in a new thread.\n\n\n-----\n\nOutside of attempting to port forward using COM s functionalities, it is a fairly bog standard\nproxy server.\n\nAn interesting detail is that the VB analysis considers the two following commands to be\nhandlers for Skype spamming operations.\n\n\n-----\n\nInterestingly, the handler for the hash 30A2060Dh currently seems to point to the same\nhandler as the hash for the command ‚Äúsys‚Äù, which is essentially just the shellexecute\noperation. The reason for this is unknown and I do not know what the original value before\nhashing might be. The handler for the hash 6EE4094Dh is no longer present.\n\nAnother thing you might notice is that a lot of commands are pointing to null handlers and are\nentirely missing. Unfortunately, these are now lost to time.\n\n## Inaccuracy in past public research\n\nWhile looking at some past materials on Betabot, I noticed some inaccuracies by other\nreverse engineers. For example, this post by CyberReason claims that the following code is\nused for anti-debugging reasons.\n\nhttps://www.cybereason.com/blog/betabot-banking-trojan-neurevt\n\n\n-----\n\nThe code snippet above, when fully annotated, is as follows.\n\nThis is then used as part of the hooking/filtering mechanism for NtCreateFile/NtOpenFile\nAPIs and is not used for anti-debugging reasons as suggested by CyberReason, but rather\nas a defensive feature as stated in the section on hooking.\n\n[An even bigger inaccuracy is in this post by Talos where they analyze a binary they consider](https://blog.talosintelligence.com/2021/08/neurevt-trojan-takes-aim-at-mexican.html)\nNeurevt. They claim that ‚Äúthe dropped payload ends up in a benign location of the filesystem\nand runs, thereby elevating its privilege by stealing service token information‚Äù. Problem is,\nthe binary they disassembled is not Neurevt at all, and none of the screenshot shown\nbelongs to Neurevt. The claim that this is a ‚Äúnew version of the Neurevt‚Äù appears entirely\nfalse to me ‚Äì Neurevt has been abandoned by the author since 2016 and this is unlikely to\nchange any time soon. As for how this misconception came to be ‚Äì it looks like multiple\nbinaries are dropped and the reverse engineer mixed them up, as the last request shown\nthat contains logout.php is indeed a Betabot knock request and the drop path\n(C:\\ProgramData\\Google Updater 2.09\\q99ig1gy1.exe) is indeed betabot-like, however other\nthan that none of the details described in the post matches Betabot.\n\nWhen publishing public information, reverse engineers should strive to verify their findings to\navoid unintentionally disseminating inaccurate information.\n\n**Appendix**\n\nThe IDC and sample for analysis will be uploaded within the next few days. Be warned that\nthe IDA database is NOT CLEAN, while it has enough information to give a solid overview of\nthe malware, I have not had the time to tidy it up in its entirety, as such it is not up to my\nusual standards. There is around 15% of the binary left that is unlabelled, and there are\n\n\n-----\n\nsome portions of the binary that is more clearly seen by simply looking at the code than at\nmy description ‚Äì as such, it is highly encouraged that readers toy around with Betabot and\nsee for themselves.\n\nFASM for making a fake PE file out of the dumped payload:\n```\nreal_addr = 2560000h\nreal_ep = 259848Bh\nformat PE GUI at (real_addr - 1000h)\nentry section_begin + real_ep - real_addr\nsection '.text' code readable writable executable\nsection_begin:\n    file 'bbdump0x2560000.bin'\n\n```\nList of registry key seeds and their identified meanings (some are previously identified in the\noriginal VB analysis):\n```\nutw = uac trick worked\nUTWS = shim elevation\nUTWIEF = ifeo reg trick\nAVKR = av kill ran\nBK32 = botkill run count\nBIS = bot came from spreading\nLCT = last communication time\nBID = bot installation date\nLSF = general flag\nLMSF = general flag minor\nLCSF = custom flags\nLISF = infoblob flags\nCF01 = cfg_versions_config\nCF02 = cfg_versions_dns_blocklist\nCF03 = cfg_versions_url_tracklist\nCF04 = cfg_versions_filesearch\nCF05 = cfg_versions_plugins\nCF06 = cfg_versions_web\nCF07 = unknown config, not used anywhere\nPNR1 = persistence restore count\nECRC = crash count\nECC1 - access violation\nECC2 - privileged instruction\nECC3 - illegal instruction\nECC4 - stack overflow\nECC5 - in page error\n\n```\nPartial listing of significant enums and structures used by the bot\n\n\n-----\n\n```\nenum BB_AV_INSTALLED\n{\n BB_AV_INSTALLED_NORTON = 1,\n BB_AV_INSTALLED_KAV = 2,\n BB_AV_INSTALLED_AVG = 4,\n BB_AV_INSTALLED_AVIRA = 8,\n BB_AV_INSTALLED_ESET = 16,\n BB_AV_INSTALLED_MCAFEE = 32,\n BB_AV_INSTALLED_TRENDMICRO = 64,\n BB_AV_INSTALLED_AVAST = 128,\n BB_AV_INSTALLED_MS_ESSENTIALS = 256,\n BB_AV_INSTALLED_BITDEFENDER = 512,\n BB_AV_INSTALLED_BULLGUARD = 1024,\n BB_AV_INSTALLED_RISING = 2048,\n BB_AV_INSTALLED_ARCAVIR = 4096,\n BB_AV_INSTALLED_WEBROOT = 8192,\n BB_AV_INSTALLED_EMSISOFT = 16384,\n BB_AV_INSTALLED_FSECURE = 32768,\n BB_AV_INSTALLED_PANDA = 65536,\n BB_AV_INSTALLED_PCTOOLS = 131072,\n BB_AV_INSTALLED_GDATA = 262144,\n BB_AV_INSTALLED_ZONEALARM = 524288,\n BB_AV_INSTALLED_BKAV = 1048576,\n BB_AV_INSTALLED_GBUSTER = 2097152,\n BB_AV_INSTALLED_DRWEB = 4194304,\n BB_AV_INSTALLED_SOPHOS_ENDPOINT = 8388608,\n BB_AV_INSTALLED_COMODO = 16777216,\n BB_AV_INSTALLED_AHNLAB_FREE = 33554432,\n BB_AV_INSTALLED_BAIDU_FREE = 67108864,\n BB_AV_INSTALLED_MALWAREBYTES_PRO = 134217728,\n};\n/* 620 */\nenum BB_CURRENT_PROCESS_FLAGS\n{\n BB_CURRENT_PROCESS_FLAGS_EXPLORER = 0x1,\n BB_CURRENT_PROCESS_FLAGS_BROWSER = 0x2,\n BB_CURRENT_PROCESS_FLAGS_USERPROFILE = 0x4,\n BB_CURRENT_PROCESS_FLAGS_DOTNET = 0x8,\n BB_CURRENT_PROCESS_FLAGS_HAS_SUSPICIOUS_MEM = 0x10,\n};\n/* 530 */\nenum BB_SOFTWARE\n{\n BB_SOFTWARE_STEAM = 1,\n BB_SOFTWARE_ORIGIN = 2,\n BB_SOFTWARE_RUNESCAPE = 4,\n BB_SOFTWARE_MINECRAFT = 8,\n BB_SOFTWARE_BLIZZARD = 16,\n BB_SOFTWARE_LOL = 64,\n BB_SOFTWARE_BITCOIN_RELATED = 128,\n BB_SOFTWARE_WEBCAM = 256,\n BB_SOFTWARE_JAVA = 512,\n BB_SOFTWARE_SKYPE = 1024,\n\n```\n\n-----\n\n```\n BB_SOFTWARE_VISUAL_STUDIO 2048,\n BB_SOFTWARE_VM_SOFTWARE = 4096,\n};\n/* 631 */\nenum BB_GENERAL_FLAGS\n{\n BB_GENERAL_FLAGS_PROACTIVE_DEFENSE = 0x1,\n BB_GENERAL_FLAGS_FORMGRAB_DISABLED = 0x2,\n BB_GENERAL_FLAGS_DNS_MODIFY_DISABLED = 0x4,\n BB_GENERAL_FLAGS_USB_SPREAD_ENABLED = 0x8,\n BB_GENERAL_FLAGS_AGGRESSIVE_PROACTIVE_DEFENSE_ENABLED = 0x10,\n BB_GENERAL_FLAGS_DYNAMIC_CONFIG_DISABLED = 0x20,\n BB_GENERAL_FLAGS_LOGIN_GRAB_DISABLED = 0x40,\n BB_GENERAL_FLAGS_USERKIT_DISABLED = 0x80,\n BB_GENERAL_FLAGS_SYS_INJECTIONS_DISABLED = 0x100,\n BB_GENERAL_FLAGS_SYS_INJECTIONS_XBROWSER_DISABLED = 0x200,\n BB_GENERAL_FLAGS_ANTI_EXPLOIT_KIT_ENABLED = 0x400,\n BB_GENERAL_FLAGS_ANTI_BOOTKIT_ENABLED = 0x800,\n BB_GENERAL_FLAGS_FORCE_IE_ENABLED = 0x1000,\n BB_GENERAL_FLAGS_PRIVILEGE_ESCALATION_EXPLOITS_ENABLED = 0x2000,\n BB_GENERAL_FLAGS_PROACTIVE_MINER_DEFENSE_ENABLED = 0x4000,\n BB_GENERAL_FLAGS_PROACTIVE_LOCKER_DEFENSE_ENABLED = 0x8000,\n BB_GENERAL_FLAGS_PROACTIVE_ANTI_OLDER_BETABOT_ENABLED = 0x10000,\n};\n/* 632 */\nenum BB_MINOR_FLAGS\n{\n BB_MINOR_FLAGS_DISABLE_IMAGE_EXECUTION_OPTIONS_FUNC = 0x1,\n BB_MINOR_FLAGS_DISABLE_UAC_FAKE_WINDOW = 0x2,\n BB_MINOR_FLAGS_DO_NOT_DISABLE_WINDOWS_SEC_SERVICES = 0x4,\n BB_MINOR_FLAGS_DISABLE_LUA = 0x8,\n BB_MINOR_FLAGS_DISABLE_AUTOUPDATES_ADDONS = 0x10,\n BB_MINOR_FLAGS_DISABLE_USERKIT_64BIT = 0x20,\n BB_MINOR_FLAGS_INSTALL_USE_HKLM_RUNONCE = 0x80,\n BB_MINOR_FLAGS_MINOR_FLAGS_INSTALL_ENABLE_SHELL_FOLDER = 0x100,\n BB_MINOR_FLAGS_ENABLE_DEBUG_MSG_SYSTEM = 0x200,\n BB_MINOR_FLAGS_ENABLE_DEBUG_ATTRIBUTES = 0x400,\n BB_MINOR_FLAGS_DEBUG_RESERVED_FOR_FUTURE_USE = 0x800,\n BB_MINOR_FLAGS_FORMGRAB_FILTER_USELESS_GRABS = 0x1000,\n BB_MINOR_FLAGS_FORMGRAB_RESERVED_R1 = 0x2000,\n BB_MINOR_FLAGS_FORMGRAB_RESERVED_R2 = 0x4000,\n BB_MINOR_FLAGS_DISABLE_INJECT_INTO_LOADERS = 0x8000,\n BB_MINOR_FLAGS_INJECT_RESERVED_R1 = 0x10000,\n BB_MINOR_FLAGS_INJECT_RESERVED_R2 = 0x20000,\n BB_MINOR_FLAGS_DISABLE_SSL_CERTIFICATE_WARNINGS = 0x40000,\n};\n/* 633 */\nenum BB_CUSTOM_FLAGS\n{\n BB_CUSTOM_FLAGS_DISABLE_WEB = 0x1,\n BB_CUSTOM_FLAGS_DISABLE_META_TAG_MODIFIER = 0x2,\n BB_CUSTOM_FLAGS_DISABLE_DOCTYPE_MODIFIER = 0x4,\n\n```\n\n-----\n\n```\n BB_CUSTOM_FLAGS_DISABLE_WEB_FOR_VM 0x8,\n BB_CUSTOM_FLAGS_DISABLE_X_FRAME_OPTIONS_REMOVER = 0x10,\n};\nenum BB_OSVERFLAG\n{\n BB_OSVERFLAG_SERVER2003 = 0x1,\n BB_OSVERFLAG_SERVER2008 = 0x2,\n BB_OSVERFLAG_SERVER2008R2 = 0x4,\n BB_OSVERFLAG_UNSUPPORTED = 0x8,\n BB_OSVERFLAG_WIN8 = 0x10,\n BB_OSVERFLAG_WIN7 = 0x20,\n BB_OSVERFLAG_VISTA = 0x40,\n BB_OSVERFLAG_XP = 0x80,\n BB_OSVERFLAG_BIT_32 = 0x100,\n BB_OSVERFLAG_BIT_64 = 0x200,\n BB_OSVERFLAG_SP1 = 0x400,\n BB_OSVERFLAG_SP2 = 0x800,\n BB_OSVERFLAG_SP3 = 0x1000,\n BB_OSVERFLAG_SERVER2012 = 0x2000,\n BB_OSVERFLAG_WIN10 = 0x4000,\n BB_OSVERFLAG_4001 = 0x8000,\n BB_OSVERFLAG_STARTER = 0x10000,\n BB_OSVERFLAG_HOMEBASIC = 0x20000,\n BB_OSVERFLAG_HOMEPREMIUM = 0x40000,\n BB_OSVERFLAG_PROFESSIONAL = 0x80000,\n BB_OSVERFLAG_ULTIMATE = 0x100000,\n BB_OSVERFLAG_BUSINESS = 0x200000,\n BB_OSVERFLAG_ENTERPRISE = 0x400000,\n BB_OSVERFLAG_DATACENTER = 0x800000,\n};\nenum BB_THREAD_TRACKER_INDEX : __int16\n{\n BB_THREAD_TRACKER_INDEX_0 = 0,\n BB_THREAD_TRACKER_INDEX_1 = 1,\n BB_THREAD_TRACKER_INDEX_ANTIBOT = 2,\n BB_THREAD_TRACKER_INDEX_BOTSCRIPT = 3,\n BB_THREAD_TRACKER_INDEX_PERSISTENCE = 4,\n BB_THREAD_TRACKER_INDEX_5 = 5,\n BB_THREAD_TRACKER_INDEX_6 = 6,\n BB_THREAD_TRACKER_INDEX_7 = 7,\n BB_THREAD_TRACKER_INDEX_8 = 8,\n BB_THREAD_TRACKER_INDEX_9 = 9,\n BB_THREAD_TRACKER_INDEX_10 = 10,\n BB_THREAD_TRACKER_INDEX_11 = 11,\n BB_THREAD_TRACKER_INDEX_IS_BEHIND_ROUTER_CHECK = 12,\n BB_THREAD_TRACKER_INDEX_PATCH_DETECTION = 13,\n BB_THREAD_TRACKER_INDEX_LAZY_DECRYPT_MAYBE = 14,\n BB_THREAD_TRACKER_INDEX_15 = 15,\n BB_THREAD_TRACKER_INDEX_16 = 16,\n BB_THREAD_TRACKER_INDEX_17 = 17,\n BB_THREAD_TRACKER_INDEX_INTEGRITY_CHECK = 18,\n BB_THREAD_TRACKER_INDEX_19 = 19,\n BB_THREAD_TRACKER_INDEX_20 = 20,\n BB_THREAD_TRACKER_INDEX_21 = 21,\n BB_THREAD_TRACKER_INDEX_WINDOW_HANDLER_IPC = 22,\n\n```\n\n-----\n\n```\n BB_THREAD_TRACKER_INDEX_USB_SPREADER 23,\n BB_THREAD_TRACKER_INDEX_PERSISTENCE_PROCESS = 24,\n BB_THREAD_TRACKER_INDEX_UAC = 25,\n BB_THREAD_TRACKER_INDEX_26 = 26,\n BB_THREAD_TRACKER_INDEX_BROWSER_HOOK = 27,\n BB_THREAD_TRACKER_INDEX_BROWSER_DUMMY = 28,\n BB_THREAD_TRACKER_INDEX_29 = 29,\n BB_THREAD_TRACKER_INDEX_30 = 30,\n BB_THREAD_TRACKER_INDEX_FREE2 = 31,\n BB_THREAD_TRACKER_INDEX_FREE1 = 32,\n BB_THREAD_TRACKER_INDEX_33 = 33,\n BB_THREAD_TRACKER_INDEX_FREE_START = 34,\n};\nenum BB_COMMAND_HASH\n{\n BB_COMMAND_HASH_DIE = 0x2A66058D,\n BB_COMMAND_HASH_UAC = 0x2A870594,\n BB_COMMAND_HASH_REM = 0x2A90059F,\n BB_COMMAND_HASH_SYS = 0x2AC105BA,\n BB_COMMAND_HASH_DDOS = 0x306B0605,\n BB_COMMAND_HASH_SPAM = 0x30A9060C,\n BB_COMMAND_HASH_SOCKS = 0x3726067E,\n BB_COMMAND_HASH_DWFILE = 0x3DCF06D6,\n BB_COMMAND_HASH_UPDATE = 0x3E0206DE,\n BB_COMMAND_HASH_PLUGIN = 0x3E1906EA,\n BB_COMMAND_HASH_BOTKILL = 0x4526074C,\n BB_COMMAND_HASH_BROWSER_CLEAR_CACHE = 0x4565075F,\n BB_COMMAND_HASH_DDOS_UDP = 0x4BCE077C,\n BB_COMMAND_HASH_DDOS_RUDY = 0x53D207F7,\n BB_COMMAND_HASH_BOTSCRIPT = 0x55330835,\n BB_COMMAND_HASH_DDOS_CONDIS = 0x647608B3,\n BB_COMMAND_HASH_DDOS_HTTPGET = 0x6E0A0933,\n BB_COMMAND_HASH_BROWSERVISIT = 0x794409BC,\n BB_COMMAND_HASH_DDOS_SLOWLORIS = 0x821A0A21,\n BB_COMMAND_HASH_BROWSERSETHOME = 0x8DC00A82,\n};\nenum BB_BOT_ATTRIBUTE\n{\n BB_BOT_ATTRIBUTE_HAS_SOURCE_USB = 0x1,\n BB_BOT_ATTRIBUTE_HAS_NET_FRAMEWORK = 0x2,\n BB_BOT_ATTRIBUTE_HAS_JAVA = 0x4,\n BB_BOT_ATTRIBUTE_HAS_STEAM = 0x8,\n BB_BOT_ATTRIBUTE_HAS_ROUTER = 0x10,\n BB_BOT_ATTRIBUTE_IS_ELEVATED = 0x20,\n BB_BOT_ATTRIBUTE_IS_GOOD_FOR_BITCOIN = 0x40,\n BB_BOT_ATTRIBUTE_IS_COMPUTER_SAVVY = 0x80,\n BB_BOT_ATTRIBUTE_IS_LAPTOP = 0x100,\n BB_BOT_ATTRIBUTE_UAC_ENABLED = 0x200,\n BB_BOT_ATTRIBUTE_HAS_USED_RDP = 0x400,\n BB_BOT_ATTRIBUTE_IS_VIRTUAL_MACHINE = 0x800,\n BB_BOT_ATTRIBUTE_HAS_SAMSUNG_DEVICE = 0x1000,\n BB_BOT_ATTRIBUTE_HAS_APPLE_DEVICE = 0x2000,\n BB_BOT_ATTRIBUTE_4000_UNKNOWN = 0x4000,\n BB_BOT_ATTRIBUTE_SAFE_BOOT = 0x8000,\n BB_BOT_ATTRIBUTE_AVKILL_HAS_EXECUTED = 0x1000000,\n\n```\n\n-----\n\n```\n BB_BOT_ATTRIBUTE_TRICK_WORKED_USED_IFEO_TRICK 0x8000000,\n BB_BOT_ATTRIBUTE_TRICK_WORKED_USED_SHIM_TRICK = 0x10000000,\n BB_BOT_ATTRIBUTE_UAC_REQUIRES_TRICK = 0x20000000,\n BB_BOT_ATTRIBUTE_UAC_TRICK_WORKED = 0x40000000,\n};\n/* 532 */\nenum BB_SECURITY_TOOL_INSTALLED\n{\n BB_SECURITY_TOOL_INSTALLED_ADWCLEANER = 0x1,\n BB_SECURITY_TOOL_INSTALLED_COMBOFIX = 0x2,\n BB_SECURITY_TOOL_INSTALLED_ADAWARE = 0x4,\n BB_SECURITY_TOOL_INSTALLED_SPYBOTSND = 0x8,\n BB_SECURITY_TOOL_INSTALLED_BANKERFIX = 0x10,\n BB_SECURITY_TOOL_INSTALLED_HOUSECALL = 0x20,\n BB_SECURITY_TOOL_INSTALLED_HIJACKTHIS = 0x40,\n BB_SECURITY_TOOL_INSTALLED_TRUSTEER = 0x80,\n};\nenum BB_BOT_REQUEST_TYPE\n{\n BB_BOT_REQUEST_TYPE_CHECKIN = 0x1,\n BB_BOT_REQUEST_TYPE_CHECKIN_BOOT = 0x2,\n BB_BOT_REQUEST_TYPE_UPDATE_STATS = 0x4,\n BB_BOT_REQUEST_TYPE_UPDATE_FORMGRAB = 0x8,\n BB_BOT_REQUEST_TYPE_UPDATE_STEALER = 0x10,\n BB_BOT_REQUEST_TYPE_UPDATE_INFOBLOB = 0x100,\n};\nstruct BB_REPORT_UNK\n{\n char JpegFakeHeader[8];\n __int16 size;\n __int16 magic;\n int header_crc32;\n int stringsCount;\n int exdataKey;\n int botVer;\n int reqType;\n int osVerFlag;\n int botAttribute;\n int botOS;\n int botAttribs;\n int botCustomAttrib;\n int debugAttribs;\n int currentTimeUnix;\n int currentTickCount;\n int timezoneBias;\n int botLocale;\n WORD botkillStats;\n __int16 socksPortA16MachineId;\n char hwid[16];\n int CFRegKeys[8];\n DWORD tasksStatus[8];\n int field_9C;\n int field_A0;\n\n```\n\n-----\n\n```\n int installedAV;\n int installedSoft;\n int securityToolsInstalled;\n int killedAVs;\n DWORD webAttributes;\n int screenSize;\n int exploitStatus;\n int field_C0;\n int field_C4;\n int field_C8;\n int field_CC;\n int field_D0;\n WORD RegECC[5];\n __int16 exceptionUnused1;\n __int16 exceptionUnused2;\n __int16 exceptionUnused3;\n __int16 exceptionUnused4;\n __int16 exceptionUnused5;\n __int16 exceptionUnused6;\n __int16 exceptionUnused7;\n __int16 persistenceRestoreCount;\n WORD crashCount;\n _BYTE gapF0[20];\n char stringBotGroupName[12];\n char botProcName[20];\n};\n/* 637 */\nenum BB_ENUMS\n{\n BB_REQUEST_MAGIC = 0xC1E5,\n BB_DISPOSITION_UNINSTALL = 0x10A15,\n};\nstruct BB_RESPONSE_STRUCT\n{\n int field_0;\n int field_4;\n int size;\n int statusCode;\n int knockInterval;\n int contentType;\n int disposition;\n int generalOpts;\n int minorOpts;\n int customOpts;\n int infoBlobStatus;\n int dynConfigVer;\n int dnslistVer;\n int urltrackVer;\n int filesearchVer;\n int pluginVer;\n int webVer;\n int reserved1;\n int reserved2;\n\n```\n\n-----\n\n```\n int cmdSize;\n int dnsSize;\n int trackedUrlSize;\n int dynConfSize;\n int filesearchConfSize;\n int pluginConfSize;\n int webConfSize;\n int field_68;\n};\n\n```\nOn a more personal side of things, as you might‚Äôve noticed, the blog has been fairly inactive\nand this is unlikely to change any time soon. In all likelihood, this is probably the last post on\nthis blog. The past years have been fun, much appreciation to all of those who stuck around,\nespecially those who are still doing cool research. If you have unfinished\nprojects/dealings/etc with me, it is best to contact me soon to get things resolved.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-28 - Betabot in the Rearview Mirror.pdf"
    ],
    "report_names": [
        "2022-03-28 - Betabot in the Rearview Mirror.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535739,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1653710786,
    "ts_modification_date": 1653710786,
    "files": {
        "pdf": "https://archive.orkl.eu/3d0db72fa4f453ee01b699006609a3b577546945.pdf",
        "text": "https://archive.orkl.eu/3d0db72fa4f453ee01b699006609a3b577546945.txt",
        "img": "https://archive.orkl.eu/3d0db72fa4f453ee01b699006609a3b577546945.jpg"
    }
}