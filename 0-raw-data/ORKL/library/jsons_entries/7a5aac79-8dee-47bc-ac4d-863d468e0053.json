{
    "id": "7a5aac79-8dee-47bc-ac4d-863d468e0053",
    "created_at": "2022-10-25T16:48:12.801229Z",
    "updated_at": "2025-03-27T02:09:50.981523Z",
    "deleted_at": null,
    "sha1_hash": "514924fa3306d01d91d86f800717140e7b461699",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-01-18T16:44:29Z",
    "file_modification_date": "2022-01-19T14:54:13Z",
    "file_size": 1152124,
    "plain_text": "# Technical details of MoonBounce’s implementation\n\n### Learn more on kaspersky.com   \n\n\n-----\n\n## MoonBounce UEFI Implant\n\nThe rogue CORE_DXE component was patched by the attackers to incorporate an additional, malicious payload, which represents\nwhat we refer to as the MoonBounce implant.\n\n**MD5** D94962550B90DDB3F80F62BD96BD9858\n\n**SHA1** 6BFB3634F6B6C5A114121FE53279331FF821EE1E\n\n**SHA256** 74B75B1A1375BA58A51436C02EB94D5ADCD49F284744CF2015E03DA036C2CF1A\n\n**Link time** Friday, 18.07.2014 03:29:55 UTC\n\n**File type** 64-Bit EFI_BOOT_SERVICES_DRIVER\n\n**File size** 1.698 MB\n\n**File name** CORE_DXE\n\nThis payload was appended to an unnamed section that follows the .reloc section and contains both shellcode and a malicious\ndriver that are introduced in memory through a multistage infection chain during boot time. The driver, which is supposed to run in\nthe context of the Windows kernel during its initialization phase, is in charge of deploying user-mode malware by injecting it into an\n**svchost.exe process, once the operating system is up and running.**\n\nThe aforementioned infection chain starts with a set of inline hooks at the beginning of several functions in the EFI_BOOT_SERVICES\nstructure. This structure, which is a part of the CORE_DXE image itself, contains a table of pointers to routines (referred to as Boot\nServices) that are callable by subsequent components in the boot sequence, such as the DXE drivers, boot loader and OS loader. Hooking\nfunctions in this table facilitates the propagation of malicious code to other boot components during system startup.\n\nThe hooked functions in the underlying EFI_BOOT_SERVICES table, namely AllocatePool, CreateEventEx and ExitBootServices,\nhave their first 5 bytes (typically referred to as the function’s prologue) replaced with a call instruction to a single malicious hook. The\nhook’s code checks the first bytes after the call instruction and, based on predefined byte patterns, can deduce the source function\ntriggering its execution. Based on this trait, it can dispatch the flow to successive handlers corresponding to each of the hooked\nfunctions.\n\nExample of a hook installed at the beginning of the AllocatePool boot services\n\n\n-----\n\np p y g p g g p y g\nexplanations:\n\nFlow of MoonBounce execution from boot sequence to malware deployment in user space\n\n**1. \u0007The first Boot Services function invoked in CORE_DXE after the EFI_BOOT_SERVICES structure initialization is**\n**AllocatePool, which diverts execution to its corresponding handler within the hook function.**\n\n\n-----\n\n**• Restores the original prologue bytes that were previously modified by the attackers to “48 89 5C 24 08” (corresponding to the**\ninstruction “mov [rsp+8], rbx”) and saves the state of the registers rcx,rdx,r8,r9,rsi and rdi (some of which are typically used\nto pass function arguments).\n\n**• Calls AllocatePool (which is now unhooked) with pre-configured parameters that are intended to allocate a buffer in memory**\nand assign it with shellcode used at later stages of the infection.\n\n**• Restores the saved state of the registers and passes control back to the beginning of AllocatePool, which is now executed**\nwith the original arguments with which it was invoked in the first place.\n\nAllocatePool’s hook logic\n\n**3. \u0007The next Boot Services function invoked in CORE_DXE is CreateEventEx that diverts execution to its handler within the**\nhook function.\n\n**4. CreateEventEx’s** handler:\n\n**• Restores the original prologue bytes that were previously modified by the attackers to “48 8B C4 48 89” (corresponding to the**\ninstructions “mov rax” and “mov [rax+8], rbx”) and saves the state of the registers rcx,rdx,r8,r9,rsi and rdi (some of which are\ntypically used to pass function arguments).\n\n**• Calls the now unhooked CreateEventEx with predefined arguments to register a callback for an event that represents a**\nlegacy boot (designated with the GUID {2A571201-4966-47F6-8B86-F31E41F32F10}, i.e. gEfiEventLegacyBootGuid). In\nthat case, the callback is responsible for passing control to the shellcode set up in AllocatePool’s hook.\n\n**• Restores the saved state of the registers and passes control back to the beginning of CreateEventEx, which is now executed**\nwith the original arguments with which it was invoked in the first place.\n\n\n-----\n\nCreateEventEx’s hook logic\n\n**5. \u0007The boot sequence continues, passing control to the Windows OS loader. At one point, this loader calls the hooked function**\n**ExitBootServices, which is supposed to hand control over to the OS loader and eliminate the dependency on the firmware-**\nbased Boot Services functions.\n\n**6. \u0007Execution is diverted to the** **ExitBootServices handler within the hook previously set up in CORE_DXE.**\n[The hooking of ExitBootServices in particular was described as a technique in the Vault7 leaks.](https://wikileaks.org/ciav7p1/cms/page_36896783.html)\n\n**7. \u0007The ExitBootServices handler conducts the following actions:**\n\n**• Restores the original prologue bytes that were previously modified by the attackers to “48 89 5C 24 08” (corresponding to the**\ninstruction “mov [rsp+8],rbx”).\n\n**• Takes the previous return address from the stack (the first address after the call to ExitBootServices) and searches for the**\nbyte pattern “41 55 48 CB” (corresponding to the instructions “push r13” and “retfq”) within a region of 0x158878 bytes after\nit. These bytes designate the end of the function OslArchTransferToKernel in the Windows OS loader image (typically named\n**winload.efi or osloader.exe and residing in the ESP partition on disk).**\n\n**• Copies 0x229 bytes of shellcode to address 0x98000 in memory.**\n\n**• Replaces the bytes starting with “48 CB” (retfq) at the end of the OslArchTransferToKernel function to E9 <offset_**\n**to_0x9800_shellcode>, which is essentially a jump to the shellcode that was just copied to 0x9800.**\n\n**• Restores the saved state of the registers and passes control back to the beginning of the now unhooked ExitBootServices,**\nwhich is executed as it was originally intended in flow of the Windows OS loader.\n\n\n-----\n\nExitBootServices’ hook logic\n\n**8. \u0007In the further execution flow of the Windows loader, it invokes the aforementioned OslArchTransferToKernel function, which**\npasses control from the OS loader to the Windows kernel. As mentioned in step 7, the last bytes of the function are replaced,\ndiverting execution to a formerly allocated shellcode that effectively serves as a hook for OslArchTransferToKernel.\n\n**9. The OslArchTransgerToKernel hook:**\n\n**• Locates the image base of ntoskrnl.exe in memory.**\n\n**• Resolves function addresses exported by ntoskrnl.exe, through which it uses a name-hashing algorithm with the following**\nequivalent logic:\n\n```\ndef fn_name_hash(name):\n  name_hash = 0\n  index = 1\n  for ch in name:\n    index += ord(ch)\n    name_hash += index\n  return (name_hash << 16) | index\n\n```\n\nThe compared function name hashes and their corresponding resolved functions are:\n\n**• 0x42790710 – ExRegisterCallback**\n**• 0x2802057D – ExAllocatePool**\n**• 0x1C88047D – MmMapIoSpace**\n\n**• Changes the Characteristics field in each section header of ntoskrnl.exe’s** image in memory:\n\n**• The IMAGE_SCN_MEM_DISCARDABLE bit gets disabled (the section cannot be discarded);**\n\n**• The IMAGE_SCN_MEM_EXECUTE, IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_NOT_PAGED bits get**\nenabled.\n\n**• Copies 0xCC bytes of another shellcode to the virtual address of the ntoskrnl.exe’s** relocation directory.\n\n**• Sets up an inline hook at the beginning of ExAllocatePool with a call instruction to the copied shellcode by placing the**\nbytes E8 <offset_to_shellcode> at the beginning of the function and saving the original bytes in a designated buffer.\n\n\n-----\n\nCode that set up a hook in the ExAllocatePool function within ntoskrnl.exe\n\n**10. \u0007Control is passed to the Windows kernel, which then invokes the hooked ExAllocatePool and in turn diverts execution to its**\nhook, which was set up in the previous stage.\n\n**11. The ExAllocatePool hook:**\n\n**• Verifies if the hook was previously executed by checking a predefined global flag. If not, the flag is set to designate that the**\nhook was run so that any subsequent execution of ExAllocatePool will invoke the original function flow.\n\n**• Calls MmMapIoSpace to map the driver mapping shellcode, which was set up during step 2, to the virtual address space of**\nthe Windows kernel.\n\n**• Jumps to the address of the now mapped shellcode, passing it the following arguments on stack:**\n\n**• Pointer to a buffer with the saved ExAllocatePool prologue bytes**\n\n**• Base address of ntoskrnl.exe**\n\n**• Pointer to ExAllocatePool**\n\nExAllocatePool hook logic\n\n\n-----\n\np p y g pp y\nspace of the kernel in the previous step gets executed. The purpose of this shellcode is to map a raw PE image of a malicious\ndriver (that is, appended at the end of the shellcode bytes) in memory and pass control to its entry point. To achieve this goal,\nthe shellcode:\n\n**• Checks if the buffer with the saved prologue bytes of ExAllocatePool passed to it in the first argument is equal to**\n**0x6F4EB841 (the original bytes in ExAllocatePool that were modified when it was hooked), in which case it resets the WP bit**\nin the CR0 register in order to be able to write to read-only pages in memory and restores these original bytes to the beginning\nof ExAllocatePool (which has its address provided as the third argument of the shellcode), effectively unhooking it. After that,\nthe shellcode restores the previous state of CR0 before it was modified.\n\n**• Resolves exported functions from ntoskrnl.exe that are essential for the subsequent PE mapping. The function address**\nresolution code makes use of yet another name-hashing algorithm, which is outlined in the equivalent logic below:\n\n```\ndef ror13(x):\n  return 0xFFFFFFFF & ((x >> 13) | (x << 32 – 13))\ndef fn_name_hash_ror13(f_name):\n  f_hash = 0\n  for i in f_name:\n    f_hash = ror13(f_hash)\n    f_hash += ord(i)\n  f_hash = ror13(f_hash)\n  return f_hash\n\n```\n\nThe functions resolved in this phase and their corresponding name hashes are the following:\n\n**• 0x0311B83F – ExAllocatePool**\n**• 0x41EBE619 – RtlInitAnsiString**\n**• 0x1C4F5B64 – RtlAnsiStringToUnicodeString**\n**• 0x0ADC68C7 – MmGetSystemRoutineAddress**\n\n**• Maps the malicious driver image to the kernel memory with the following common PE-loading steps:**\n\n**• Allocates space for the image with the now unhooked ExAllocatePool function**\n\n**• Copies headers and sections to their corresponding virtual addresses in memory**\n\n**• Applies relocations**\n\n**• Resolves imports by getting each name in the import table, initializing its string with RtlAnsiString and**\n**RtlAnsiStringToUnicodeString, and passing the result as an argument to MmGetSysteRoutineAddress, following which**\nthe argument string is freed with RtlFreeUnicodeString.\n\n**• Finally, control is passed to the entry point of the malicious driver.**\n\nFor clarity, steps 13-16, which are taken by the malicious driver and the user-mode malware it deploys, are explained in detail in the\nfollowing sections.\n\n\n-----\n\np p j g p\nthereby allowing it to have access to the internet. This is achieved by first having the driver register a callback using the\n**PsSetLoadImageNotifyRoutine API, which is invoked when the Windows loader maps a PE image to memory (as outlined in step**\n13 of figure 1). This callback in turn verifies that the inspected image is kernel32.dll and the underlying owning process is executed\nwith the command line: ‘SVCHOST.EXE -K NETSVCS’ or ‘SVCHOST.EXE -K NETSVCS -P’.\n\nConditions to locate the target svchost.exe process for injection by MoonBounce’s driver\n\nIf the above conditions are met, the driver continues to inject an embedded PE image, corresponding to a user-mode malware\nstager, to the matching svchost.exe process (as outlined in step 14 of figure 1). The injection leverages the Windows APC\n(Asynchronous Procedure Call) mechanism through the following actions:\n\n**• The driver enqueues a kernel mode APC routine, which will run in kernel mode with APC_LEVEL IRQL;**\n\n**• The kernel APC routine initializes the following data structure:**\n\n**Offset** **Field**\n\nA table with pointers to various fields in the current structure and Windows API functions\n0x0\nthat are used by the PE mapping shellcode\n\n0x28 PE mapping shellcode used to load the raw user mode stager PE to memory\n\n0x800 Buffer with the drop zone URL carrying the payload to be downloaded by the stager\n\n0xA00 Padding\n\n0x1000 Buffer with the raw image of the deployed user mode stager\n\nThe first field, which we will refer to as the mapping shellcode argument, shows the following layout:\n\n\n-----\n\np g\nthe following layout:\n\n**Offset** **Field**\n\n0x0 Pointer to PE mapping shellcode\n\n0x8 Pointer to the PE mapping shellcode argument described above\n\nPointer to the KTHREAD object corresponding to the current thread executing in the\n0x10\ncontext of the injected process\n\n0x18 Pointer to a notification event\n\nIt then calls the ExQueueWorkItem with the above structure in order to insert the worker routine to a system wide queue.\n\nInitialization of a WORK_QUEUE_ITEM structure used to schedule the execution of a worker routine in kernel space\n\n**• The Windows kernel has a designated system thread that picks up the previously enqueued task and executes its corresponding**\nroutine, passing it a pointer to the argument structure described above. In this case, the executed routine queues the\nPE-mapping shellcode with its own argument structure to the APC queue of the current thread running in the context of the\ninjected svchost.exe process.\n\nWorker routine injecting the malicious MoonBounce user-mode stager to an svchost.exe instance using APC injection\n\n**• Once the aforementioned user-mode thread within svchost.exe is scheduled to run, its execution is preceded by the PE-**\nmapping shellcode, which uses its argument structure to load the malware stager PE image to svchost.exe’s memory address\nspace and invoke its entry point (as outlined in step 15 of figure 1).\n\n\n-----\n\n**g**\n\n**MD5** 8DB7440B39761EA8ED75B7870542E1F3\n\n**SHA1** E21483618EEAE7CC476BC67BF768069572BE7FE0\n\n**SHA256** 4CC7A14BC2E40BE93BBDF6F871430F08C3335E893519D75EA37C66942E1EB7FA\n\n**Link time** Tuesday, 11.12.2018 09:25:17 UTC\n\n**File type** PE32+ executable (DLL) (GUI) x86-64, for MS Windows\n\n**File size** 66.5 KB\n\n**File name** None\n\nThe user-mode malware stager, which is injected to an svchost.exe process by the malicious driver, is a DLL packed with a common\nsoftware tool called MPRESS. It operates in a similar fashion to UPX, whereby the original sections of the PE are compressed into a\nnew section called .MPRESS1 and the code for unpacking is appended into another generated section named .MPRESS2. It gets\nexecuted during runtime in order to decompress the data and pass control to the original entry point within.\n\nAfter unpacking, the malware executes a basic staging component that reaches out to a C2 URL and obtains a PE image. The\nDLL receives an argument from the driver in the lpReserved parameter of the DllEntryPoint, which should contain a pointer to\na C2 URL. The same argument can contain additional optional data elements that can be used in a number of ways throughout\nexecution. These are laid out in a structure of the following form:\n\n**Offset** **Field**\n\n0x0 C&C URL (may also contain a scheduling related argument)\n\n0x11c User-Agent\n\n0x180 Proxy address\n\n0x1c0 Proxy username\n\n0x1e0 Proxy password\n\nTo receive a further payload to run, the malware:\n\n**• Runs a system time-dependent scheduling algorithm that postpones execution until reaching a predefined deadline value, at**\nwhich point the downloading logic is initiated. This value ought to be provided as part of the aforementioned DLL argument;\nhowever, we did not observe it being passed by the driver we analysed.\n\n**• Sets up an optional User-Agent or uses the default string “IE” instead. Once again, the driver in our case did not pass any**\nparticular argument to use in this field; therefore, it is expected to be the default value.\n\n**• Registers a callback function with the InternetSetStatusCallback API, which detects whether the system makes use of a**\nproxy, in which case the malware can use the proxy configuration provided in the DLL argument to issue a request.\n\n**• Sends a GET request to the C2 URL, expecting to receive a raw PE image as a response.**\n\n**• Maps the retrieved image to the current memory address space and invokes its entry point.**\n\n\n-----\n\n[Kaspersky’s threat research and reports: www.securelist.com](http://www.securelist.com)\n[Kaspersky’s blog. Business-related topics: business.kaspersky.com](http://business.kaspersky.com)\n[Enterprise security you can trust: kaspersky.com/enterprise-security](http://www.kaspersky.com/enterprise-security)\n\n**[kaspersky.com](http://www.kaspersky.com)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2022/01/19115831/MoonBounce_technical-details_eng.pdf"
    ],
    "report_names": [
        "MoonBounce_technical-details_eng.pdf"
    ],
    "threat_actors": [
        {
            "id": "23dfc9f5-1862-4510-a6ae-53d8e51f17b1",
            "created_at": "2024-05-01T02:03:08.146025Z",
            "updated_at": "2025-03-27T02:05:17.420497Z",
            "deleted_at": null,
            "main_name": "PLATINUM TERMINAL",
            "aliases": [
                "Longhorn ",
                "The Lamberts ",
                "Vault7 ",
                "APT-C-39 "
            ],
            "source_name": "Secureworks:PLATINUM TERMINAL",
            "tools": [
                " Assassin",
                " Marble Framework",
                "AfterMidnight"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716492,
    "ts_updated_at": 1743041390,
    "ts_creation_date": 1642524269,
    "ts_modification_date": 1642604053,
    "files": {
        "pdf": "https://archive.orkl.eu/514924fa3306d01d91d86f800717140e7b461699.pdf",
        "text": "https://archive.orkl.eu/514924fa3306d01d91d86f800717140e7b461699.txt",
        "img": "https://archive.orkl.eu/514924fa3306d01d91d86f800717140e7b461699.jpg"
    }
}