{
    "id": "671d45f9-4790-40fa-92b5-c41f464423d1",
    "created_at": "2023-02-02T02:08:24.884761Z",
    "updated_at": "2025-03-27T02:09:18.603588Z",
    "deleted_at": null,
    "sha1_hash": "1f00ba54856deaea1206c82ee1ee083b6f44487d",
    "title": "2023-01-30 - Following the Scent of TrickGate- 6-Year-Old Packer Used to Deploy the Most Wanted Malware",
    "authors": "",
    "file_creation_date": "2023-02-01T07:55:34Z",
    "file_modification_date": "2023-02-01T07:55:34Z",
    "file_size": 1934693,
    "plain_text": "## Following the Scent of TrickGate: 6-Year-Old Packer Used to Deploy the Most Wanted Malware\n\n**research.checkpoint.com/2023/following-the-scent-of-trickgate-6-year-old-packer-used-to-deploy-the-most-wanted-**\nmalware/\n\nJanuary 30, 2023\n\nJanuary 30, 2023\nResearch by: [Arie Olshtein](https://www.linkedin.com/in/arie-olshtein-95267590/)\n\n#### Executive summary\n\nInitially observed in July 2016, TrickGate is a shellcode-based packer offered as a\nservice to hide malware from EDRs and antivirus programs.\nOver the last 6 years, TrickGate was used to deploy the top members of the “Most\nWanted Malware” list, such as Cerber, Trickbot, Maze, Emotet, REvil, Cobalt Strike,\nAZORult, Formbook, AgentTesla and more.\nTrickGate managed to stay under the radar for years because it is transformative – it\nundergoes changes periodically. This characteristic caused the research community to\nidentify it by numerous attributes and names.\nWhile the packer’s wrapper changed over time, the main building blocks within\nTrickGate shellcode are still in use today.\nCheck Point [Threat Emulation successfully detects and blocks the TrickGate packer.](https://www.checkpoint.com/infinity/zero-day-protection/)\n\n#### Introduction\n\n\n-----\n\nCyber criminals increasingly rely on packers to carry out their malicious activities. The\npacker, also referred to as “Crypter” and “FUD” on hacking forums, makes it harder for\nantivirus programs to detect the malicious code. By using a packer, malicious actors can\nspread their malware more easily with fewer repercussions. One of the main characteristics\nof a commercial Packer-as-a-Service is that it doesn’t matter what the payload is, which\nmeans it can be used to pack many different malicious samples. Another important\ncharacteristic of the packer is that it is transformative – the packer’s wrapper is changed on a\nregular basis which enables it to remain invisible to security products.\n\nTrickGate is a good example of a strong, resilient Packer-as-a-Service, which has managed\nto stay under the cyber security radar for many years and continually improve itself in\ndifferent ways. We managed to track TrickGate’s breadcrumb trail despite its propensity for\nrapidly changing its outer wrapper.\n\nAlthough a lot of excellent research was conducted on the packer itself, TrickGate is a\nmaster of disguises and has been given many names based on its varied attributes. Its\n[names include “TrickGate”, “Emotet’s packer”, “new loader”, “Loncom”, “NSIS-based crypter”](https://www.gosecure.net/blog/2021/12/03/trickbot-leverages-zoom-work-from-home-interview-malspam-heavens-gate-and-spamhaus/)\nand more. We connect the dots from previous researches and with high confidence point to a\nsingle operation that seems to be offered as a service.\n\n#### TrickGate over the years.\n\nWe first observed TrickGate at the end of 2016. Back then, it was used to deliver Cerber\nransomware. Since that time, we are continually observing TrickGate and found it is used to\nspread all types of malwares tools, such as ransomware, RATs, info-stealers, bankers, and\nminers. We noticed that many APT groups and threat actors regularly use TrickGate to wrap\ntheir malicious code to prevent detection by security products. TrickGate has been involved\nin wrapping some of the best-known top-distribution malware families, such as Cerber,\nTrickbot, Maze, Emotet, REvil, CoinMiner, Cobalt Strike, DarkVNC, BuerLoader, HawkEye,\nNetWire, AZORult, Formbook, Remcos, Lokibot, AgentTesla, and many more.\n\nFigure 1 – TrickGate over the years.\n\n\n-----\n\n#### TrickGate Distribution.\n\nWe monitored between 40 to 650 attacks per week during the last 2 years. According to our\ntelemetry, the threat actors who use TrickGate primarily target the manufacturing sector, but\nalso attack education facilities, healthcare, finance and business enterprises. The attacks are\ndistributed all over the world, with an increased concentration in Taiwan and Turkey. The\nmost popular malware family used in the last 2 months is Formbook with 42% of the total\ntracked distribution.\n\nFigure 2 – TrickGate statistics during Oct-Nov 2022.\n\n#### Attack flow:\n\nFollowing is an overview of the attack flow that is commonly found in attacks involving\nTrickGate.\n\n\n-----\n\n##### Initial Access\n\nThe initial access made by the packer’s users can vary significantly. We monitor the packed\nsamples spreading mainly via phishing emails with malicious attachments, but also via\nmalicious links.\n\n##### Initial Files\n\nThe first stage mainly comes in the form of an archived executable, but we monitored many\nfile types and delivery permutations that lead to the same shellcode. We observed the\nfollowing file types at the first stage:\n\n**Archive: 7Z * ACE * ARJ * BZ * BZ2 * CAB * GZ * IMG * ISO * IZH * LHA * LZ * LZH * R00 ***\nRAR * TAR * TGZ * UU * UUE * XZ * Z * ZIP * ZIPX * ZST.\n\n**Executable: BAT * CMD * COM * EXE * LNK * PIF * SCR.**\n\n**Document: DOC * DOCX * PDF * XLL * XLS * XLSX * RTF.**\n\n##### Shellcode Loader\n\nThe second stage is the shellcode loader which is responsible for decrypting and running the\nshellcode.\n\nWe noticed 3 different types of code language used for the shellcode loader. NSIS script,\nAutoIT script and C all implement similar functionality.\n\n##### Shellcode\n\nThe shellcode is the core of the packer. It’s responsible for decrypting the payload and\nstealthily injecting it into a new process.\n\n##### Payload\n\nThe payload is the actual malicious code and is responsible for carrying out the intended\nmalicious activity. The payloads differ according to the actor who used the packer.\n\n\n-----\n\n# 1\n\n### Initial access\n\n# 2\n\n### Initial files\n\n# 3\n\n### Shellcode loader\n\n# 4\n\n### Shellcode\n\n# 5\n\n### Payload\n\n\nFigure 3 – Attack flow.\n\nExamples of the different attack flows we observed in the past year:\n\nFEB 24, 2022\n\n1. 2. 3. 4. 5. 6. 7.\n#### Email RAR LNK DownloadEXE NSISC++\n\nFigure 4 – LNK flow\n\nRAR: 3f5758da2f4469810958714faed747b2309142ae\n\nLNK: bba7c7e6b4cb113b8f8652d67ce3592901b18a74\n\nURL: jardinaix[.]fr/w.exe\n\nEXE 63205c7b5c84296478f1ad7d335aa06b8b7da536\n\nMar 10, 2022\n\n\n8.\n#### Formboo\n\n8.\n##### Formboo\n\n\n1. 2. 3. 4. 5. 6. 7. 8.\n#### Email RAR LNK DownloadEXE NSISC++ ShellcodeFormboo\n\n\n-----\n\nFigure 5 – PDF flow.\n\nPDF: 08a9cf364796b483327fb76335f166fe4bf7c581\n\nXLSX: 36b7140f0b5673d03c059a35c10e96e0ef3d429a\n\nURL: 192.227.196[.]211/t.wirr/XLD.exe\n\nEXE: 386e4686dd27b82e4cabca7a099fef08b000de81\n\nOct 3, 2022\n\n1. 2. 3. 4. 5.\n#### Email 7Z EXE SFXC++ Shellcode\n\nFigure 6 – SFX flow.\n\n7Z: fac7a9d4c7d74eea7ed87d2ac5fedad08cf1d50a\n\nEXE: 3437ea9b7592a4a05077028d54ef8ad194b45d2f\n\nNov 15, 2022\n\n\n6.\n#### Formboo\n\n\n1. 2. 3. 4. 5. 6.\n#### Email 7Z EXE SFXC++ ShellcodeFormboo\n\n\n1. 2. 3. 4. 5. 6.\n##### Email R11 EXE NSISAutoIT ShellcodeRemcos\n\nFigure 7 – AutoIT flow.\n\nR11: 755ee43ae80421c80abfab5481d44615784e76da\n\nEXE: 666c5b23521c1491adeeee26716a1794b09080ec\n\n#### Shellcode loader\n\nThe Shellcode loader usually contains a single function which is responsible for decrypting\nand loading the shellcode into memory. These are the basic steps:\n\n1. Read the encrypted shellcode. The encrypted shellcode can be stored in a file on the\n\ndisc, in the “.rdata” section or as a resource.\n2. Allocate memory for the shellcode, usually by calling VirtualAlloc.\n3. Decrypt the shellcode.\n\n\n1. 2. 3. 4. 5. 6.\n##### Email R11 EXE NSISAutoIT ShellcodeRemcos\n\n\n-----\n\n4. Trigger the shellcode. As we explain below, this can be done using a direct call or by\n\ncallback functions.\n\nFigure 8 – Shellcode loader – deobfuscated AutoIT version.\n\nFigure 9 – Shellcode loader C version.\n\nIn the more recent versions of TrickGate, the shellcode loader abuses the “Callback\nFunctions” mechanism. The loader utilizes many native API calls which take a memory\naddress as an argument of a callback function. Instead of the Callback Function, the loader\npasses on the address of the newly allocated memory which holds the shellcode. When\n[Windows reaches the point of the registered events, the DriverCallback executes the](https://learn.microsoft.com/en-us/windows/win32/api/mmiscapi/nf-mmiscapi-drivercallback)\nshellcode. This technique breaks the flow of the behavior we’re monitoring by having\nWindows OS run the shellcode at an unknown time. In the shellcode loader above, you can\nsee two examples of this in the images “EnumTimeFormatsA” and\n“EnumSystemCodePagesW”.\n\n#### Shellcode similarity and TrickGate vacation\n\n\n-----\n\nUsually, when we find code similarity between unrelated malware families, it is more likely\nthat the actors copied from a mutual resource or shared some pieces of code. For a long\ntime, we noticed a unique injection technique that incorporated the use of direct kernel\nsyscalls, but we didn’t realize the significance, thinking it was probably a fragment of shared\ncode. What caused us to suspect that this unique injection may be controlled solely by one\nactor is the fact that we saw an occasional “time-off” in operation, and it is very unlikely that\nseveral different groups will take a break at exactly the same time. The last break, which was\nmore than 3 months long (from June 13, 2022 to September 26, 2022) was an opportunity\nfor us to verify our suspicion, and dive into the shellcode.\n\nFigure 10 – TrickGate in the last 2 years.\n\nTo verify our suspicion, we started to analyze samples across the timeline.\n\nWe started our analysis by comparing a fresh sample to an older one. For this test we used\n\n2022-12_Remcos: a1f73365b88872de170e69ed2150c6df7adcdc9c\n\ncompared to\n\n2017-10_CoinMiner: 1a455baf4ce680d74af964ea6f5253bbeeacb3de\n\nWe know from the behavioral analysis that a similarity exists in the shellcode, so we ran the\nsamples till the point the shellcode is decrypted in memory and then we dumped the\n[shellcode to the disk. Next, we used the Zynamics BinDiff tool (owned by Google) to check](https://www.zynamics.com/bindiff.html)\nsimilarities in both shellcodes. The results showed a 50% similarity between the tested\nshellcodes. Fifty percent over a long period of time – more than five years – for quite a large\npiece of shellcode (~5kb) is unexpected. This automatically raised suspicions that this might\nbe a maintained shellcode, but we needed further evidence in the form of similarity analysis\nover shorter periods of times to see if it had changed gradually.\n\n\n-----\n\nFigure 11 – BinDiff result on shellcode extracted 2022-12_Remcos:\na1f73365b88872de170e69ed2150c6df7adcdc9c VS 2017-10_CoinMiner:\n1a455baf4ce680d74af964ea6f5253bbeeacb3de.\n\nFor further analysis, we took random samples from the past 6 years. For each sample, we\ndumped the shellcode and checked the similarity of the result over time. As you can see in\nthe following graph, the results point to small changes made over time. On the left side we\nsee samples dating from 2016 till 2020 showing about 90% similarity. On the right side, we\nsee a forked version showing a high similarity within itself, but lower similarity with the\noriginal version on the left.\n\n\n-----\n\nFigure 12 – Bindiff result on extracted shellcodes.\n\nWe then dived into the gap between the shellcodes to see the impact caused by:\n\nDifferent compilers\nObfuscations\nEvasion modules\nPersistence modules (run the packet payload at the next login)\nFunction order\nLocal variables vs structures\n\nAfter we cleaned the gap noise, we got the core functionality of the packer. The author\nconstantly maintained the shellcode but used “building blocks” as described in the next\nsection.\n\n\n-----\n\nFigure 13 – Control flow graph – on the main injection function. Diffing 2016-07_ Cerber:\n24aa45280c7821e0c9e404f6ce846f1ce00b9823 VS 2022-12_Remcos:\na1f73365b88872de170e69ed2150c6df7adcdc9c\n\n\n-----\n\nFigure 14 – Diffing kernel direct call of NtWriteVirtualMemory 2022-12_Remcos:\na1f73365b88872de170e69ed2150c6df7adcdc9c VS 2016-07_ Cerber:\n24aa45280c7821e0c9e404f6ce846f1ce00b9823\n\n#### TrickGate shellcode’s construction elements\n\nAs mentioned above, the shellcode has been constantly updated, but the main functionalities\nexist on all the samples since 2016. An overview of the shellcode’s building-blocks can be\ndescribed as follows:\n\nAPI hash resolving.\nLoad to memory and decrypt the payload.\nInjection using direct kernel calls.\n\nManually map a fresh copy of ntdll.\nDynamically retrieve the kernel syscall numbers.\nInvoke the desired syscalls.\nInject and run the payload\n\n\n-----\n\n**API hash resolving.**\n\nWhen we analyzed the TrickGate code, no constant strings can be found. Many times,\nTrickGate intentionally adds clean code and debug strings to throw off any analysis. To hide\nthe needed strings and its intentions, TrickGate uses a common technique called API\nhashing, in which all the needed Windows APIs are hidden with a hash number. Until\nJanuary 2021, TrickGate used to hash the shellcode string with CRC32. In the newer\nversion, TrickGate started using a custom hash function.\n\nThe equivalent Python hashing functions used in the last 2 years:\n```\ndef hash_str_ror1(str):\n\n  h = 8998\n\n  for c in str:\n\n    h += ord(c) + (((h >> 1) &amp; 0xffffffff) | ((h << 7) & 0xffffffff))\n\n  return h & 0xffffffff\n\ndef hash_str21(str):\n\n  h = 8998\n\n  for c in str:\n\n    h = ord(c) + (0x21 * h)\n\n  return h & 0xffffffff\n\n```\nThe following Kernel32 API names have been hashed in TrickGate samples:\n\n**API NAME** **CRC32** **hash_str_ror1** **hash_str21**\n\n**CloseHandle** 0xB09315F4 0x7fe1f1fb 0xd6eb2188\n\n**CreateFileW** 0xA1EFE929 0x7fe63623 0x8a111d91\n\n**CreateProcessW** 0x5C856C47 0x7fe2736c 0xa2eae210\n\n**ExitProcess** 0X251097CC 0x7f91a078 0x55e38b1f\n\n**GetCommandLineW** 0xD9B20494 0x7fb6c905 0x2ffe2c64\n\n**GetFileSize** 0xA7FB4165 0x7fbd727f 0x170c1ca1\n\n**GetModuleFileNameW** 0XFC6B42F1 0xff7f721a 0xd1775dc4\n\n**GetThreadContext** 0x649EB9C1 0x7fa1f993 0xc414ffe3\n\n**IsWow64Process** 0x2E50340B 0xff06dc87 0x943cf948\n\n**ReadFile** 0x95C03D0 0x7fe7f840 0x433a3842\n\n**ReadProcessMemory** 0xF7C7AE42 0x7fa3ef6e 0x9f4b589a\n\n**SetThreadContext** 0x5688CBD8 0xff31bf16 0x5692c66f\n\n\n-----\n\n**VirtualAlloc** 0x9CE0D4A 0x7fb47add 0xa5f15738\n\n**VirtualFree** 0xCD53F5DD 0x7f951704 0x50a26af\n\nFigure 15 – API hashing.\n\n**Load to memory and decrypt the payload.**\n\nTrickGate always changes the way the payload is decrypted, so unpacking solutions that we\nobserve now will not work on the next update. Most of the samples use a custom decryption\nmethod but on older samples we also saw known cyphers such as RC4 implementation or\nthe use of Windows APIs for encryption.\n\n**Injection using direct kernel calls:**\n\nAfter decrypting the payload, the shellcode then injects it into a newly created process. After\nthe process is created using the create_suspended flag, the injection is done by a set of\ndirect calls to the kernel. For every one of these ntdll API calls:\n\nNtCreateSection\nNtMapViewOfSection\nNtUnmapViewOfSection\nNtWriteVirtualMemory\nNtResumeThread\n\nThe following actions are executed:\n\nManually map a fresh copy of ntdll from the disk.\nResolve the address of a given hash in the newly mapped ntdll.\nDynamically extract the requested System Service Number (SSN).\nDirect kernel Invoke with the SSN.\n\n[For Windows 64-bit: Switch to 64-bit mode using “Heaven’s Gate” technique and](https://github.com/darkspik3/Valhalla-ezines/blob/master/Valhalla%20%231/articles/HEAVEN.TXT)\nSYSCALL SSN\nFor Windows 32-bit: Call SYSENTER SSN\n\n\n-----\n\nFigure 16 – Function call graph SYSCALL ID from Manually mapped DLL.\n\nThe way TrickGate invokes direct-syscalls is intriguing, as it uses a technique similar to Hell’s\nGate. [Hell’s Gate is a technique presented publicly in 2020 as a way to dynamically retrieve](https://github.com/am0nsec/HellsGate)\nand execute direct syscall numbers. Here you can find samples dating to 2016 which\nmanage to accomplish the equivalent action to retrieve and execute direct system calls\nwithout the need to maintain a System Service Descriptor Table (SSDT).\n\nFigure 17 – SSN dynamically extracted 2016-07_Cerber:\n24aa45280c7821e0c9e404f6ce846f1ce00b9823\n\nThe injection module has been the most consistent part over the years and has been\nobserved in all TrickGate shellcodes since 2016.\n\n\n-----\n\n#### Conclusion\n\nWe created strings correlating the most wanted malware in the last 6 years to a single\nPacker-as-a-Service named TrickGate, whose transformative abilities make it hard to identify\nand track. Understanding the packer’s building blocks is of crucial importance to detect the\nthreat, as blocking the packer will protect against the threat in an early stage, before the\npayload starts to run.\n\nPackers often get less attention, as researchers tend to focus their attention on the actual\nmalware, leaving the packer stub untouched. However, the identified packer can now be\nused as a focal point to detect new or unknown malware.\n\n#### Analyzed samples.\n\n03d9cbee9522c2c8a267b7e9599a9d245c35c7ac\n\n043ae57e01ebd0a96fa30b92821b712504cfde03\n\n1a455baf4ce680d74af964ea6f5253bbeeacb3de\n\n22f26496f2e8829af9f5cfcd79c47e03fe9a21bb\n\n24aa45280c7821e0c9e404f6ce846f1ce00b9823\n\n30e0181a018fa7dcbd2344dc32adcf77cf840ebe\n\n3437ea9b7592a4a05077028d54ef8ad194b45d2f\n\n3817bad277aa50016e08eed35e92d4a3b5247633\n\n4380044a9517a08514459005836c5f92e4a33871\n\n4f6fa448454b581d6c8e7aa6ed3ef72e66062bf8\n\n666c5b23521c1491adeeee26716a1794b09080ec\n\n75d999d431819311abf8bd048cd084acdcd5f4e1\n\n7f456f8b01fc8866aeed4678a14479b6eaa62fed\n\n975629358bfbba0344ef0dae4d22697ceb2a32b4\n\n977800bd7be3c5c9f2c0dac7f4806e586d8f7b1a\n\n9f20d00b4ec898a33e130720d4d29e94070e1575\n\na1f73365b88872de170e69ed2150c6df7adcdc9c\n\n\n-----\n\na661541c4cbeb1db859f6cec6c53979b5633c75e\n\nafbe838c881e5b223351ff8fa05ddeb3678581ba\n\nb2d58dfee71ce9c509fab1f00ce04c9526c60695\n\ne6dccf4b1fc5ab116b6bc1321346b35dbf42f387\n\nfa5c79321dd4cc2fea795d6ebe2e823abe33ca6f\n\nGO UP\n[BACK TO ALL POSTS](https://research.checkpoint.com/latest-publications/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-30 - Following the Scent of TrickGate- 6-Year-Old Packer Used to Deploy the Most Wanted Malware.pdf"
    ],
    "report_names": [
        "2023-01-30 - Following the Scent of TrickGate- 6-Year-Old Packer Used to Deploy the Most Wanted Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1675303704,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1675238134,
    "ts_modification_date": 1675238134,
    "files": {
        "pdf": "https://archive.orkl.eu/1f00ba54856deaea1206c82ee1ee083b6f44487d.pdf",
        "text": "https://archive.orkl.eu/1f00ba54856deaea1206c82ee1ee083b6f44487d.txt",
        "img": "https://archive.orkl.eu/1f00ba54856deaea1206c82ee1ee083b6f44487d.jpg"
    }
}