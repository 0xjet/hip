{
    "id": "e0283f0c-7dff-4567-9194-16c932989147",
    "created_at": "2023-01-12T14:59:06.276812Z",
    "updated_at": "2025-03-27T02:06:01.32728Z",
    "deleted_at": null,
    "sha1_hash": "859a6fc88fcf367736961b6791d4d63d2f270f5e",
    "title": "2021-06-10 - Hiding your syscalls",
    "authors": "",
    "file_creation_date": "2022-05-28T03:37:32Z",
    "file_modification_date": "2022-05-28T03:37:32Z",
    "file_size": 152223,
    "plain_text": "# Hiding Your Syscalls\n\n**passthehashbrowns.github.io/hiding-your-syscalls**\n\n## Hiding your syscalls\n\n\nJune 9, 2021\n\n\nI’ve previously blogged about using Frida to detect direct syscalls by looking for any syscall\ninstructions originating from outside of NTDLL. After writing some basic detections for that\npurpose, I was curious about how easy it would be to bypass those detections. The answer\nwas very!\n\nI’d like to note up top here that in this blog I’ll just be bypassing detections that I wrote\nmyself. To the best of my knowledge EDR vendors aren’t really alerting on direct syscalls yet.\n\n[You can find all of the source code for this blog post here.](https://github.com/passthehashbrowns/hiding-your-syscalls)\n\n## Basic detection methodology\n\nI’ll briefly recap the detections that I used in the previous post to detect the use of direct\nsyscalls. All syscalls in NTDLL follow a basic structure:\n```\nmov r10, rcx\nmov eax, *syscall number*\nsyscall\nret\n\n```\nSo in the previous post I described two detections here. The first is that we could look for the\n“mov r10,rcx” instruction and then inspect the next instruction to determine if it was a syscall,\nsince this allowed me to inspect the syscall number. I’ve since scrapped this idea since we\ncan just inspect the EAX register and pull the syscall number out of there when we find a\nsyscall. Additionally, this is an incredibly easy detection to bypass. Instead of moving the\nvalue in the R10 register into the RCX register, we could do the following instead:\n```\nmov r11, r10\nmov rcx, r11\n\n```\nAnd we could expand that into an incredibly complicated series of instructions if we wanted\nto. The same goes for detecting based on placing a syscall number into EAX. Instead of\nmoving the syscall into EAX, we could copy the above and just add an extra step. The OS\ndoesn’t really care so long as there’s a syscall number in eax when it transitions to the\nkernel.\n```\nmov r11, *syscall number*\nmov eax, r11\n\n```\n\n-----\n\nI actually think this is kind of cool to bypass because it s reminiscent of bypassing the\nsignature based detection from days of anti-virus past.\n\nSince we can’t rely on this, we can instead target the one instruction that all syscalls must\ncall by definition: syscall! We also need to look out for the int 2eh instruction which is the\nlegacy way of invoking a syscall, but it’s the same logic.\n\nAs I mentioned up top, we can attempt to detect this by looking for any syscall instructions\nthat originate from outside of NTDLL’s address space. I tested this detection against two\ntypes of programs: one that reads NTDLL from disk and dynamically resolves syscalls, and\none that has a syscall table embedded at compile time (a la Syswhispers). In both cases I\nwas able to detect the use of manual system calls.\n\n## Detection on disk\n\nOne thing I didn’t talk about in the last blog post was trying to determine if an executable is\nusing direct syscalls while it’s sitting on disk. At the time I was more interested in identifying\nthis behavior in-memory, but there’s many situations where you may have a suspicious\nbinary on disk. Whether that’s a PE/shellcode carved out of memory or an executable\ndropped to disk, we can take an identical approach as above to identify direct syscalls in use.\nWe can do this just with objdump and grep in the case of a plain PE.\n\nI’ve got a compiled copy of Dumpert on disk to test this with.\n```\nobjdump --disassemble -M intel Outflank-Dumpert.exe | grep \"syscall\"\n\n```\nAnd the output.\n```\n140013438:  0f 05          syscall\n140013443:  0f 05          syscall\n14001344e:  0f 05          syscall\n[truncated]\n14001356c:  0f 05          syscall\n140013577:  0f 05          syscall\n140013582:  0f 05          syscall\n\n```\nI ran this same command against a few other binaries to check for massive false positives. I\nchecked calc, notepad, Chrome, etc. and none of them triggered this behavior.\n\nI was also curious whether or not this would work on a project using stubs generated by\nSyswhispers so I went ahead and compiled a project using the files from the example-output\nfolder in the Syswhispers2 repo and a main function which used the code from the\n[CreateRemoteThread injection example.](https://github.com/jthuraisamy/SysWhispers2#before-and-after-example-of-classic-createremotethread-dll-injection)\n\n\n-----\n\nAnd it looks good. I think that all things considered this is actually a pretty free win with some\npretty boring static analysis.\n\nWe can also detect “int 2eh” invocations in the same manner to cover all the bases.\n\n## Back to memory\n\nAnyways back to detecting syscalls at runtime since on-disk detection does us no good with\nfileless malware. My methodology in the last post was to look for any syscall instructions and\nthen check if they originated from within the bounds of NTDLL. If it didn’t originate from\nNTDLL then it’s very likely that it was invoked manually. I’m sure there are exceptions to this,\nbut since you’re likely running this sort of detection against a suspected bad file we can take\nsome liberties in this regard.\n\n## Bypassing this detection\n\nWhen an EDR hooks a function, they often replace the first instruction with a JMP instruction\nto their own code. So if an EDR were to hook a syscall in NTDLL, it would look like this:\n```\njmp *address of EDR's function*\nmov eax, *syscall number*\nsyscall\nret\n\n```\nSo if we follow this model of hooking, there’s a nice syscall instruction just sitting there within\nNTDLL!\n\nAdditionally, I have yet to see an EDR that hooks every function in NTDLL. For reference,\nyou can check out [Mr-Un1k0d3r’s EDR repository, which contains a list of the NTDLL](https://github.com/Mr-Un1k0d3r/EDRs)\nfunctions that are hooked by several EDR vendors. There’s very little reason to hook every\nfunction, as only a subset of them are traditionally used by malware.\n\nSo in order for there to not be a clean syscall somewhere, the EDR would have to hook\nevery function in NTDLL AND clobber the entire function.\n\n\n-----\n\nMy theory was that in order to bypass the detection we could simply grab an unhooked\nsyscall stub (or just any clean syscall instruction) from NTDLL, get the address of the actual\n**syscall instruction, and patch a jump to it into our malicious syscall so that our stub will now**\nlook as follows:\n```\nmov r10, rcx\nmov eax, *syscall number*\njmp *address of legit syscall instruction*\nret\n\n## Obfuscating on disk\n\n```\nBefore I talk about implementing this I was curious whether or not this method would also\nhelp us avoid including syscall instructions in our binary. Since we’re just going to overwrite\nthe syscall instruction anyways, we don’t need to have it in the stub. So we can just replace it\nwith whatever to avoid having the syscall instruction show up in the disassembly.\n```\nmov r10, rcx\nmov eax, 55h\nnop //where our syscall should be\nret\n\n```\nThe nop instruction will get replaced with a jmp at runtime so nothing will show up if we use\nthe same objdump command as earlier.\n\nI think if you’re dropping to disk it may actually be worth it to obfuscate your syscall\ninstructions and reconstruct them at runtime even if you just replace the nop with a normal\nsyscall instruction. I doubt that any EDR currently alerts on this but it seems like a free win to\nme.\n\n## Implementation\n\nTo implement this I took the Dumpert project and used that as a base. You could generate\nthe necessary files using Syswhispers, but I used the files from Dumpert because it just has\nthe plain syscall stubs embedded which offered slightly lower complexity. However the same\nthing could be done with a Syswhispers project by changing a few variables. (I ended up\ndoing that after finishing this post, check out the section at the bottom)\n\nI used NtCreateFile as a proof of concept syscall since it creates a file that I can observe. To\nget the stub you’ll want to create a file named “Syscalls.asm” and add the following\n(assuming you’re on Windows 10):\n\n\n-----\n\n```\n.code\nNtCreateFile10 proc\n          mov r10, rcx\n          mov eax, 55h\n          syscall\n          ret\nNtCreateFile10 endp\nend\n\n```\nIn order to include this file in Visual Studio you’ll want to select the project in the Solution\nExplorer, and then in the toolbar select Project > Build Customizations and check “masm”\nthen OK. Then in the Solution Explorer right click on Syscalls.asm and set the Item Type to\n“Microsoft Macro Assembler”. This should include your assembly into the build.\n\nThe next few blocks of code are from this [post on ired.team about resolving syscalls](https://www.ired.team/offensive-security/defense-evasion/retrieving-ntdll-syscall-stubs-at-run-time?q=riv)\ndynamically, with some slight modifications.\n\nIn our header file.\n\n\n-----\n\n```\n#pragma once\n#include <Windows.h>\n#define STATUS_SUCCESS 0\n#define OBJ_CASE_INSENSITIVE 0x00000040L\n#define FILE_OVERWRITE_IF 0x00000005\n#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020\ntypedef LONG KPRIORITY;\n#define InitializeObjectAttributes( i, o, a, r, s ) {  \\\n   (i)->Length = sizeof( OBJECT_ATTRIBUTES );     \\\n   (i)->RootDirectory = r;              \\\n   (i)->Attributes = a;                \\\n   (i)->ObjectName = o;                \\\n   (i)->SecurityDescriptor = s;            \\\n   (i)->SecurityQualityOfService = NULL;       \\\n  }\ntypedef struct _UNICODE_STRING {\n     USHORT Length;\n     USHORT MaximumLength;\n     PWSTR Buffer;\n} UNICODE_STRING, * PUNICODE_STRING;\ntypedef const UNICODE_STRING* PCUNICODE_STRING;\ntypedef struct _OBJECT_ATTRIBUTES {\n     ULONG Length;\n     HANDLE RootDirectory;\n     PUNICODE_STRING ObjectName;\n     ULONG Attributes;\n     PVOID SecurityDescriptor;\n     PVOID SecurityQualityOfService;\n} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;\ntypedef struct _IO_STATUS_BLOCK\n{\n     union\n     {\n          LONG Status;\n          PVOID Pointer;\n     };\n     ULONG Information;\n} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;\nEXTERN_C NTSTATUS NtCreateFile10(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,\nPOBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER\nAllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition,\nULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);\nNTSTATUS(*NtCreateFile)(\n     PHANDLE FileHandle,\n     ACCESS_MASK DesiredAccess,\n     POBJECT_ATTRIBUTES ObjectAttributes,\n     PIO_STATUS_BLOCK IoStatusBlock,\n     PLARGE_INTEGER AllocationSize,\n\n```\n\n-----\n\n```\n     ULONG FileAttributes,\n     ULONG ShareAccess,\n     ULONG CreateDisposition,\n     ULONG CreateOptions,\n     PVOID EaBuffer,\n     ULONG EaLength\n     );\ntypedef void (WINAPI* _RtlInitUnicodeString)(\n     PUNICODE_STRING DestinationString,\n     PCWSTR SourceString\n     );\n\n```\nThis defines some structs that we need to call NtCreateFile as well as our NtCreateFile\nfunction prototype.\n\nIn our actual C file we’ll define a big ol’ block of variables within our main function.\n```\nSIZE_T bytesWritten = 0;\nDWORD oldProtection = 0;\nHANDLE file = NULL;\nDWORD fileSize = NULL;\nDWORD bytesRead = NULL;\nLPVOID fileData = NULL;\n// variables for NtCreateFile\nOBJECT_ATTRIBUTES oa;\nHANDLE fileHandle = NULL;\nNTSTATUS status = NULL;\nUNICODE_STRING fileName;\n_RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)\nGetProcAddress(GetModuleHandle(L\"ntdll.dll\"), \"RtlInitUnicodeString\");\nRtlInitUnicodeString(&fileName, (PCWSTR)L\"\\\\??\\\\c:\\\\temp\\\\temp.log\");\nIO_STATUS_BLOCK osb;\nZeroMemory(&osb, sizeof(IO_STATUS_BLOCK));\nInitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n```\nThen we’ll need to get the address of NTDLL and parse some information out of it. We’re\ngoing to use all this info to find the syscalls.\n\n\n-----\n\n```\n//Get NTDLL address\nHANDLE process = GetCurrentProcess();\nMODULEINFO mi;\nHMODULE ntdllModule = GetModuleHandleA(\"ntdll.dll\");\nGetModuleInformation(process, ntdllModule, &mi, sizeof(mi));\nLPVOID ntdllBase = mi.lpBaseOfDll;\nPIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)ntdllBase;\nPIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase +\ndosHeader->e_lfanew);\nDWORD exportDirRVA = imageNTHeaders>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\nPIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(imageNTHeaders);\nPIMAGE_SECTION_HEADER textSection = section;\nPIMAGE_SECTION_HEADER rdataSection = section;\nfor (int i = 0; i < imageNTHeaders->FileHeader.NumberOfSections; i++)\n     {\n          if (strcmp((CHAR*)section->Name, (CHAR*)\".rdata\") == 0) {\n              rdataSection = section;\n              break;\n          }\n          section++;\n     }\nPIMAGE_EXPORT_DIRECTORY exportDirectory =\n(PIMAGE_EXPORT_DIRECTORY)RVAtoRawOffset((DWORD_PTR)ntdllBase + exportDirRVA,\nrdataSection);\n\n```\nThis will get a handle to NTDLL and grab the base address. Using that base address we can\nparse out all of the headers and sections. Now we can modify the function that resolves the\nsyscall stubs to grab the first one.\n\n\n-----\n\n```\nPVOID RVAtoRawOffset(DWORD_PTR RVA, PIMAGE_SECTION_HEADER section)\n{\n     return (PVOID)RVA;\n}\nLPVOID GetFirstStub(PIMAGE_EXPORT_DIRECTORY exportDirectory, LPVOID fileData,\nPIMAGE_SECTION_HEADER textSection, PIMAGE_SECTION_HEADER rdataSection)\n{\n     PDWORD addressOfNames = (PDWORD)RVAtoRawOffset((DWORD_PTR)fileData + *\n(&exportDirectory->AddressOfNames), rdataSection);\n     PDWORD addressOfFunctions = (PDWORD)RVAtoRawOffset((DWORD_PTR)fileData + *\n(&exportDirectory->AddressOfFunctions), rdataSection);\n     for (int i = 0; i < exportDirectory->NumberOfNames; i++)\n     {\n          DWORD_PTR functionNameVA =\n(DWORD_PTR)RVAtoRawOffset((DWORD_PTR)fileData + addressOfNames[i], rdataSection);\n          DWORD_PTR functionVA = (DWORD_PTR)RVAtoRawOffset((DWORD_PTR)fileData\n+ addressOfFunctions[i + 1], textSection);\n          LPCSTR functionNameResolved = (LPCSTR)functionNameVA;\n          if (functionNameResolved[0] == 'N' && functionNameResolved[1] == 't')\n          {\n              return (LPVOID)functionVA;\n          }\n     }\n     return (LPVOID)NULL;\n}\n\n```\nThe original code would parse NTDLL for a given function, copy it into a buffer, and then\nreturn true. However in this case we don’t need the whole stub, we just need the address of\nit. The above code will just grab the first Nt function, but it could easily be adjusted to grab a\ngiven function that we know won’t be hooked or just a random NTDLL function.\n```\nLPVOID ntdllSyscallPointer = GetFirstStub(exportDirectory, ntdllBase, textSection,\nrdataSection);\n\n```\nNow that we have a pointer to a legit syscall we can write a function to patch our syscall with\na jump to the legit syscall.\n\n\n-----\n\n```\nchar createObfuscatedSyscall(LPVOID SyscallFunction, LPVOID ntdllSyscallPointer) {\n     //Get the address of the syscall instruction\n     LPVOID syscallAddress = (char*)ntdllSyscallPointer + 18;\n     //construct a trampoline\n     unsigned char jumpPrelude[] = { 0x00, 0x49, 0xBB }; //mov r11\n     unsigned char jumpAddress[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE,\n0xEF }; //placeholder where the address goes\n     *(void**)(jumpAddress) = syscallAddress; //replace the address\n     unsigned char jumpEpilogue[] = { 0x41, 0xFF, 0xE3, 0xC3 }; //jmp r11\n     //Copy it all into a final buffer\n     char finalSyscall[30];\n     memcpy(finalSyscall, SyscallFunction, 7);\n     memcpy(finalSyscall + 7, jumpPrelude, 3);\n     memcpy(finalSyscall + 7 + 3, jumpAddress, sizeof(jumpAddress));\n     memcpy(finalSyscall + 7 + 3 + 8, jumpEpilogue, 4);\n     //Make sure that we can execute\n     DWORD oldProtect = NULL;\n     VirtualProtectEx(GetCurrentProcess(), &finalSyscall, sizeof(finalSyscall),\nPAGE_EXECUTE_READWRITE, &oldProtect);\n     return &finalSyscall;\n}\n\n```\nThis looks a little convoluted but the underlying principle is:\n\nConstruct some assembly bytes which will store our syscall address into the R11\nregister and then JMP to it\nInsert the address of the syscall in NTDLL into the jmp\nCopy all of that into a buffer\nGive that buffer executable permissions and return it to the user\n\nThen we can call the function providing the NtCreateFile10 assembly stub and a pointer to\nthe legit NTDLL syscall.\n```\nNtCreateFile = createObfuscatedSyscall(&NtCreateFile10, ntdllSyscallPointer);\n\n```\nAssuming this works, we can then call NtCreateFile normally.\n```\nstatus = NtCreateFile(&fileHandle, FILE_GENERIC_WRITE, &oa, &osb, 0,\nFILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_OVERWRITE_IF,\nFILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n     if (status != STATUS_SUCCESS) {\n          printf(\"Syscall failed...\\n\");\n     }\n     else {\n          printf(\"Syscall succeeded!\\n\");\n     }\n     return 0;\n\n```\n\n-----\n\nAnd there you have it! All of the code necessary in order to:\n\nParse NTDLL for an arbitrary syscall stub\nGet the address of the legit syscall instruction\nPatch our malicious syscall stub with a JMP to the legit syscall\nCall our function which will jmp to NTDLL for the syscall\n\n**Note: One very important thing that I spent forever figuring out is that you need to DISABLE**\nIncremental Linking. If you do not then VS will construct a jump table which will ruin any\nattempts to access the embedded NtCreateFile stub. You can do this by right clicking the\nproject, selecting Linker > General and setting Enable Incremental Linking to No. There’s\nprobably a way around this but I have not found it.\n\n## Testing\n\nSo, moment of truth! Does this bypass actually work?\n\nWe’ll need a Frida script to verify if this bypasses our detection.\n\n\n-----\n\n```\nvar modules Process.enumerateModules()\nvar ntdll = modules[1]\nvar ntdllBase = ntdll.base\nsend(\"[*] Ntdll base: \" + ntdllBase)\nvar ntdllOffset = ntdllBase.add(ntdll.size)\nsend(\"[*] Ntdll end: \" + ntdllOffset)\nvar pNtAcceptConnectPort = Module.findExportByName('ntdll.dll',\n'NtAcceptConnectPort');\nInterceptor.attach(pNtAcceptConnectPort, {\n  onEnter: function (args){}\n})\nconst mainThread = Process.enumerateThreads()[0];\nProcess.enumerateThreads().map(t => {\nStalker.follow(t.id, {\n events: {\n  call: false, // CALL instructions: yes please\n  // Other events:\n  ret: false, // RET instructions\n  exec: false, // all instructions: not recommended as it's\n         //          a lot of data\n  block: false, // block executed: coarse execution trace\n  compile: false // block compiled: useful for coverage\n },\n onReceive(events) { \n },\n transform(iterator){\n   let instruction = iterator.next()\n   do{\n    if(instruction.mnemonic == \"syscall\"){\n      var addrInt = instruction.address.toInt32()\n      //If the syscall is coming from somewhere outside the bounds of NTDLL\n      //then it may be malicious\n      if(addrInt < ntdllBase.toInt32() || addrInt > ntdllOffset.toInt32()){\n        send(\"[+] Found a potentially malicious syscall\")\n        iterator.putCallout(onMatch)\n      }\n    }\n   iterator.keep()\n   } while ((instruction = iterator.next()) !== null)\n }\n})\n})\nfunction onMatch(context){\n  send(\"[+] Syscall number: \" + context.rax)\n}\n\n```\nThe above script will:\n\nResolve the bounds of NTDLL\n\n\n-----\n\nPlace a hook on NtAcceptConnectPort. This is the first Nt function and will help us\nverify that even if there is a hook placed on the function then the syscall should be\nintact.\nAdd a Stalker to every thread which will check every instruction to see if it is a syscall.\nIf it is, then we’ll check if it’s within the bounds of NTDLL. If it’s outside of NTDLL, then\nwe will attach a callout to it which will look at the EAX register and tell us what the\nsyscall number is. Then we’ll inform the user of the malicious syscall.\n\nIf instead of calling our createObfuscatedSyscall function we just call the syscall normally:\n```\nNtCreateFile = &NtCreateFile10;\nNtCreateFile(...)\n\n```\nThen it should be detected.\n```\n[?] Attempting process start..\n[+] Injecting => PID: 16308, Name:\nC:\\Users\\pcuser\\source\\repos\\suspendedunhook\\x64\\Debug\\find_syscall_address.exe\n[+] Process start success\n[*] Ntdll base: 0x7ffd31970000\n[*] Ntdll end: 0x7ffd31b65000\n[+] Found a potentially malicious syscall\n[+] Syscall number: 0x55\n\n```\nHowever if we do call createObfuscatedSyscall:\n```\n[?] Attempting process start..\n[+] Injecting => PID: 5320, Name:\nC:\\Users\\pcuser\\source\\repos\\suspendedunhook\\x64\\Debug\\find_syscall_address.exe\n[+] Process start success\n[*] Ntdll base: 0x7ffd31970000\n[*] Ntdll end: 0x7ffd31b65000\n\n```\nThen we get a clean bill of health! It appears as though we’ve successfully bypassed any\ndetection that looks for syscall instructions originating outside of NTDLL.\n\n## Integrating with Syswhispers\n\nI originally was just using the syscall stubs from the Dumpert project, but after I got that\nworking I figured I should probably also make this work with Syswhispers since that’s the\npredominant method for including syscall stubs into a VS project. In fact we only have to\nmake one modification to the stubs generated by Syswhispers, which is to add a bunch of\nnops to the end of each stub to make room for the extra instructions that we need to add.\nThey don’t have to be nops necessarily, so long as we have an extra 11 bytes.\n\nAlso instead of creating a new buffer and returning that, we’ll need to directly modify the\nSyswhispers stub. So createObfuscatedSyscall will now look like this.\n\n\n-----\n\n```\nvoid createObfuscatedSyscall(LPVOID SyscallFunction, LPVOID ntdllSyscallPointer) {\n     //Get the address of the syscall instruction\n     LPVOID syscallAddress = (char*)ntdllSyscallPointer + 18;\n     unsigned char jumpPrelude[] = { 0x49, 0xBB }; //mov r11\n     unsigned char jumpAddress[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE,\n0xEF }; //placeholder where the address goes\n     *(void**)(jumpAddress) = syscallAddress; //replace the address\n     unsigned char jumpEpilogue[] = { 0x41, 0xFF, 0xE3, 0xC3 }; //jmp r11\n     DWORD oldProtect = NULL;\n     VirtualProtectEx(GetCurrentProcess(), SyscallFunction, 61 + 2 + 8 + 4,\nPAGE_READWRITE, &oldProtect);\n     memcpy((char*)SyscallFunction + 61, jumpPrelude, 2);\n     memcpy((char*)SyscallFunction + 61 + 2, jumpAddress, sizeof(jumpAddress));\n     memcpy((char*)SyscallFunction + 61 + 2 + 8, jumpEpilogue, 4);\n     VirtualProtectEx(GetCurrentProcess(), SyscallFunction, 61 + 2 + 8 + 4,\noldProtect, &oldProtect);\n}\n\n```\nThere’s probably a more elegant solution to this but I was happy with a quick proof of\nconcept.\n\n## Conclusion\n\nThere is a compelling argument to be made that this is a solution for a non-existent problem.\nTo the best of my knowledge, EDR vendors have not really begun picking up on direct\nsyscalls. They may get finicky when it comes to reading NTDLL from disk, but for syscalls\nincluded at compile time I have not heard about any sort of detections. However I think that it\nis a good exercise to dig into our tooling in this manner. Personally, I’ve learned a LOT about\nsyscalls and upped my assembly skills a bit from hacking on this.\n\n## References\n\n[Syswhispers2 - JacksonT](https://github.com/jthuraisamy/SysWhispers2)\n\n[Dumpert - OutflankNL](https://github.com/outflanknl/Dumpert)\n\n[Retrieving NTDLL Syscall Stubs from Disk at Run-time - spotheplanet](https://www.ired.team/offensive-security/defense-evasion/retrieving-ntdll-syscall-stubs-at-run-time?q=riv)\n\n[Mr-Un1k0d3r - EDRs](https://github.com/Mr-Un1k0d3r/EDRs)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-10 - Hiding your syscalls.pdf"
    ],
    "report_names": [
        "2021-06-10 - Hiding your syscalls.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535546,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1653709052,
    "ts_modification_date": 1653709052,
    "files": {
        "pdf": "https://archive.orkl.eu/859a6fc88fcf367736961b6791d4d63d2f270f5e.pdf",
        "text": "https://archive.orkl.eu/859a6fc88fcf367736961b6791d4d63d2f270f5e.txt",
        "img": "https://archive.orkl.eu/859a6fc88fcf367736961b6791d4d63d2f270f5e.jpg"
    }
}