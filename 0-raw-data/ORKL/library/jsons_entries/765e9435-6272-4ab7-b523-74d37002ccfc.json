{
    "id": "765e9435-6272-4ab7-b523-74d37002ccfc",
    "created_at": "2022-10-25T16:48:20.580074Z",
    "updated_at": "2025-03-27T02:16:20.644112Z",
    "deleted_at": null,
    "sha1_hash": "42bc3ed806d32f12e7fcb224aa184abfda49d079",
    "title": "Microsoft Word - The Slingshot APT_report_ENG_final.docx",
    "authors": "",
    "file_creation_date": "2018-03-09T12:49:38Z",
    "file_modification_date": "2018-03-09T12:49:38Z",
    "file_size": 1061100,
    "plain_text": "# The Slingshot APT\n#### Version: 1.0 (06.March.2018)\n\n## Executive Summary\nWhile analysing an incident that involved a suspected keylogger, we identified a malicious library\nable to interact with a virtual file system, which is usually the sign of an advanced APT actor. This\nturned out to be a malicious loader internally named ‘Slingshot’, part of a new, and highly\nsophisticated attack platform that rivals Project Sauron and Regin in complexity.\n\nThe initial loader replaces the victim´s legitimate Windows library ‘scesrv.dll’ with a malicious one of\nexactly the same size. Not only that, it interacts with several other modules including a ring-0 loader,\nkernel-mode network sniffer, own base-independent packer, and virtual filesystem, among others.\n\nWhile for most victims the infection vector for Slingshot remains unknown, we were able to find\nseveral cases where the attackers got access to Mikrotik routers and placed a component\ndownloaded by Winbox Loader, a management suite for Mikrotik routers. In turn, this infected the\nadministrator of the router.\n\nWe believe this cluster of activity started in at least 2012 and was still active at the time of this\nanalysis (February 2018). We observed almost one hundred victims in the following countries:\nKenya, Yemen, Libya, Afghanistan, Iraq, Tanzania, Jordan, Mauritius, Somalia, Democratic Republic of\nthe Congo, Turkey, Sudan and United Arab Emirates.\n\nThis paper in a nutshell:\n\n- Slingshot is a new, previously unknown cyber-espionage platform which rivals Project Sauron\nand Regin in complexity\n\n- Slingshot has been active since at least 2012 until February 2018\n\n- We observed almost one hundred Slingshot victims, mainly in the Middle East and Africa\n\n- The attackers exploited an unknown vulnerability in Mikrotik routers as an infection vector\n\n## Technical Details\n\nDuring the analysis of anomalies from a system suspected of being infected with a keylogger, we\nfound an interesting artifact. This system had a DLL called ‘scesrv.dll’ (this same name is used by a\nsystem DLL) containing strings that seemed related to Virtual File System handling.\n\nThis was indeed a patched system library, loaded by services.exe with SYSTEM privileges. We called\nit Slingshot, based on internal strings.\n\nSlingshot is a loader that uses different components as summarized in the schema below. The\nfollowing sections provide a technical analysis for all of them.\n\n\n-----\n\n### Slingshot\n\nSlingshot is a loader used as a first stager. It replaces an existing system DLL with a malicious one of\nexactly the same size. We noticed that the attackers replace scesrv.dll more often than other DLLs,\nbut in some cases attackers also replaced spoolsv.exe.\n\nThe system DLL patching is one of the most technically interesting features of this loader, and it\nworks as follows:\n\n- Inserts all necessary modules into the victim’s system DLL file, compressing part of the original\nfile in the malware´s data section to retain the same size.\n\n- Changes the entry point, pointing to one of the added loaders. Loaders are written in the\ninfected DLL as base-independent code.\n\n- Calculates the new checksum of the DLL.\n\n- When started, after executing all malicious actions, the malware restores the original code of\nthe system DLL in memory.\n\nEach added malicious module has the following structure:\n\n{ uint module_id, uint module_size, char data[module_size] }.\n\nActually, the malware itself on disk is an array of modules.\n\n\n-----\n\n**Fig. 1 Green is the ID, yellow size in bytes, red the encrypted ‘Slingshot’ word.**\n\nFor instance, the described loader (6637DBCC6059A1E2E45956D98A3EA590) has the value\nmodule_id = 0xFF000001 and contains the encrypted word ‘Slingshot’. In its entry point it directly\njumps to the malicious code with ‘jmp 758E618C’.\n\nThe malicious module is located right after the header. Actually, this would be the unpacker for the\nembedded MZPE module. The original entry point address and the checksum of the DLL are stored in\nthe module with module_id=0xFF000003. The original code is stored in the module with\nmodule_id=0xEF000007.\n\nThis module uses the following parameters:\n\nSs -a 24964 -s 163007 -o 8 -l 313856 -r 24964 -z 228584\n\nwhere:\n\n- L – Size of the infected library\n\n- R – RVA of patched data in library (where the malware code starts)\n\n- A – RVA of modules array, 24964 = 0x6184 => ImageBase library .758E0000\n\n- S – size of modules array, 163007 = 0x27CBF => in the infected library modules are embedded\nfrom .758E6184 to .7590DE43 address\n\n- O – offset from the beginning of the compressed MZPE file till the modules list. Uses for finding\nthe modules array (address .758E6184 in a picture above)\n\n- Z – Maximum data size that will be restored in the original library\n\nTo ensure correct execution and avoid system crashes, Slingshot restores the original library data\nstored in ImageBase + R to ImageBase + R + Z in memory.\n\n\n-----\n\nIn case the malicious modules can´t be embedded into the target system library, Slingshot uses an\nadditional file on disk. The path for this file is stored in the module with module_id 0xFF000006. It\ncould be a hardcoded path in the recycler bin (first dword is 0x12000006O); or, if the first dword is\n0x12000007, malware tries to read this file directly from the PhysicalDrive object by calling:\n\nCreateFile(\\\\\\\\.\\\\PhysicalDrive + drive_number), SetFilePointer, ReadFile.\n\nModule_id 0xFF000007 stores the encryption key in module_id 0xCF000009: this module is called\n**Cahnadr and this is the main kernel mode loader implementing almost all the payloads.**\n\nAfter loading additional modules, Slingshot passes the execution to Cahnadr.\n\n### Ring0 loader\n\nThis loader is compressed in module_id 0xBF000001. Actually, there might be more than one, so in\ncase the first loader fails, there may be a second loader in the binary with module_id 0xBF000002. At\nthis stage, Slingshot uses its internal logging system actively:\n\nSlingshot checks if there is any kernel-mode payload and any loader available, and then the loaders\nare run one after the other.\n\nUpon starting, this loader gets SeLoadDriverPrivilege for installing malicious drivers into the system\nthat it will later abuse for obtaining kernel privileges.\n\nIn order to avoid leaving any traces of this activity in system logs, it renames the ETW-logs, and for\nthe Security and System logs adds the .tmp extension. After execution, the loader removes the\nextensions.\n\nThe final goal of this module is to load the Cahnadr module (kernel mode main payload, described\nbelow) into kernel mode. As previously stated, Slingshot has different ways to load code into kernel\nmode, each using its own loader.\n\nThe simplest loader is used for 32-bit systems where Driver Signature Enforcement (DSE), which\nrequires signed drivers, does not apply. This loader simply saves the driver on disk and loads it.\n\nWhen the driver is loaded, the loader shares the malicious payload with it by calling DeviceIoControl\nwith control code 0x222000.\n\n\n-----\n\nThis driver receives commands from the user-mode loader via DeviceIoControl. The only available\ncommand in this case allows running this code as a WorkItem into the System Worker Threads pool,\nwhich is a pool used by legitimate software for running quick tasks.\n\nIn cases where the operating system supports DSE, the loader exploits a couple of legitimate but\nvulnerable drivers that allow writing in MSR registers. Successful exploitation of the drivers would\nallow to set in the MSR_LSTAR register a handler that, after running Sleep, calls Cahnadr:\n\nIn order to prevent patch protection, the handler restores the original MSR register.\n\nThis loader leverages the following drivers:\n\n312E31851E0FC2072DBF9A128557D6EF Goad.sys – driver for x86 systems\n5F9785E7535F8F602CB294A54962C9E7 SpeedFan.sys - CVE-2007-5633\n9a237fa07ce3ed06ea924a9bed4a6b99 Sandra.sys - CVE-2010-1592\n978CD6D9666627842340EF774FD9E2AC ElbyCDIO.sys - CVE-2009-0824\n\nIt is important to mention that the digital signatures in these drivers are still not revoked.\n\n|312E31851E0FC2072DBF9A128557D6EF|Goad.sys – driver for x86 systems|\n|---|---|\n|5F9785E7535F8F602CB294A54962C9E7|SpeedFan.sys - CVE-2007-5633|\n|9a237fa07ce3ed06ea924a9bed4a6b99|Sandra.sys - CVE-2010-1592|\n|978CD6D9666627842340EF774FD9E2AC|ElbyCDIO.sys - CVE-2009-0824|\n\n\n-----\n\nAll the drivers above are loaded into the kernel directly by creating the required keys in the registry\nand calling the ntdll!NtLoadDriver function. The service key name in the registry starts with the PCX*\nprefix.\n\n**Cahnadr – main kernel-mode payload**\n\nThis payload can be considered the main orchestrator, running in kernel mode and providing the\nnecessary capabilities for all the other, user-mode payloads. This component is responsible for\ndifferent features, including:\n\n1. Anti-debugging actions and checking if the kernel is patched or not\n2. Calling system services directly to hide malicious activities\n3. Hooks KTHREAD.ServiceTable for threads\n4. Rootkit actions for hiding traffic\n5. Injecting user-mode payload (main malicious payload) into services.exe\n6. Providing malicious API for user-mode modules\n7. Providing communications via network\n8. Notifying GollumApp payload about process-related events, providing interfaces for\n\nmanipulating their memory\n9. Monitoring all network devices\n10. Providing sniffer functionality on the following protocols: ARP, TCP, UDP, DNS, ICMP, HTTP\n\nAnti-debug techniques include:\n\n- If kernel is already being debugged, it calls KdDisableDebugger() terminating the debugging\nprocess\n\n- It hooks LiveKd debugger driver's routines IRP_MJ_CREATE, IRP_MJ_READ, FastIoDeviceControl\n\n\n-----\n\n- Installs notifiers to monitor PsSetLoadImageNotifyRoutine. If the LoadImageNotify event\nhappens when LiveKdD.sys is loaded, the module patches the entry point that leads to error\nSTATUS_FAILED_DRIVER_ENTRY\n\nIn order to detect if the kernel is patched, it checks the kernel image in memory with the following\nkernel files on disk:\n\n- \\\\SystemRoot\\\\system32\\\\kernel_name\n\n- \\\\SystemRoot\\\\LastGood\\\\system32\\\\kernel_name\n\n- \\\\SystemRoot\\\\$*\\\\system32\\\\kernel_name\n\nFor newer x32 versions it also checks win32k.sys at the same paths.\n\nIt is important to note that Cahnadr checks only CheckSum and TimeStamp values for the kernel\nimage in memory. If one of them is different, it means that the kernel was patched, and it\nterminates its execution.\n\nActually, it needs an unpatched kernel and win32k.sys to get the origin function from\nKeServiceDescriptorTable and KeServiceDescriptorTableShadow, which will be used to directly\ninteract with system services and hooking the KTHREAD.ServiceTable on x32 systems.\n\nIn order to hide calls, it can associate system services to some Zw*, Rtl*, Nt* functions. Instead of\ntaking the addresses for these functions from SSDT, Cahnadr extracts them from the kernel image\non disk for unpatched kernels.\n\nIt also implements code to find a function address by its name by comparing exported routines from\nntdll and ntoskrnl addresses: if the address of the exported functions is the same as the system\nservice address, it means the address was correctly found.\n\nNtdll.dll exported functions addresses are also taken from the image stored on disk to avoid hooks\nset by other programs.\n\nFor routines not directly operating with system services, Cahnadr has a hardcoded list:\n\nNot all functions are mandatory to be found, there is a flag for each of them. All listed routines are\nused for injecting malicious code into user-mode processes.\n\nFor newer x32 versions this list was highly extended, adding debug-related functions and functions\nfor suspending and resuming threads and processes.\n\nFor x32 systems, Cahnadr hooks KTHREAD.ServiceTable. It copies the KeServiceDescriptorTable and\nKeServiceDescriptorTableShadow, then fills it with the original handlers restored from disk and\nchanges the address in KTHREAD.ServiceTable to pointer to a new structure. This is used to inject\nthreads into user mode: once a component is injected as a separate thread, Cahnadr patches its\nKTHREAD.ServiceTable with the original handlers in order to hide its malicious functionality and\navoid possible installed hooks.\n\nCahnadr also provides the following API functionality:\n\n\n-----\n\n- Direct disk access: read/write by raw-offset, defragmentation ban, etc. These routines are used\nfor working with the virtual file system\n\n- Read/write into memory by raw address\n\n- Routines for injecting code into a process as a separate thread. It is possible to set the thread\nstate and choose the preferred routine for creating the thread (NtCreateThreadEx or\nNtCreateThread). For GollumApp it is obligatory to use NtCreateThread\n\n- Get the access token by process_id\n\n- Get the SERVICE_DESCRIPTOR_TABLE address\n\n- Get the DRIVER_OBJECT object pointer by driver name\n\n- Get detailed information about processes opened in csrss.exe (start time, time in kernel mode,\ntime in user mode, number of calls ZwRead and ZwWrite, among of data received/sent via\nZwRead/ZwWrite)\n\n- Get handle for process_1 in process_2. In other words, opens process_1 from process_2. This\nway process_2 gets the handle of process_1\n\n- Close handle that belongs to any process\n\n- Provides network functionality: add a new network-related task, delete an old one, turn on/off a\nnetwork task, send information about all active network tasks to GollumApp\n\n- Hooks the ServiceTable in KTHREAD in the specified thread or process (only on x32), providing:\nsetting/deleting a hook by ThreadID, setting/deleting hook for all threads by PID, checking if\nthread/process was hooked\n\n- Sets time to sleep before shutdown\n\nCahnadr calls PsSetCreateProcessNotifyRoutine, PsSetCreateThreadNotifyRoutine routines in order\nto automate installing hooks. Created processes will be hooked if their parent process was hooked,\nas will threads if their process was hooked.\n\nShutdown notifications are detected by calling the IoRegisterShutdownNotification routine. When a\nnotification is received, it is sent to GollumApp with the time that GollumApp can spend for\ncompletion. While GollumApp works, Cahnadr sleeps.\n\nIt installs bugcheck notifications by calling the KeRegisterBugCheckReasonCallback routine. When a\nnotification is received it calls KeBugCheck with the undocumented POWER_FAILURE_SIMULATE\nparameter, which is a way to reboot from kernel mode without BSOD and crush dump. This way, in\ncase a fatal error occurs, Cahnadr reboots the system without creating a memory dump on disk.\n\nThe communication between kernel and user mode modules is implemented in different ways for\nx32 and x64 components.\n\nIn x64 components Cahnadr sets IRP-requests handlers for the ‘null.sys’ driver. Each handler\ncontains a ‘jmp’ operation to the malicious code located in the ‘null.sys’ image in memory. This is\nhow hooks are typically set in this APT, making them harder to detect. Also, the authors decided to\nuse IRP-requests shown in the picture below:\n\n\n-----\n\nWhile null.sys uses:\n\nHowever malicious and legitimate IRP-handlers have a conflicting component, as both null.sys and\n**Cahnadr can process requests to IRP-MJ-CLOSE. That’s why only one hook and three ordinary**\nhandlers are set. After that, user mode modules can send data to Cahnadr by calling\nCreateFile(\\\\\\\\.\\\\NUL, …) + DeviceIoControl.\n\nIn x32 components another approach was used. Cahnadr registers a RegistryCallback routine by\ncalling CmRegisterCallback to monitor all operations in the registry. When any user mode module\nsends something to Cahnadr it sets the ArbitraryUserPointer field of the TIB pointer to the related\ndata, starting with 0x2BADDOOD, and then calls RegEnumKeyW which triggers the kernel mode\ncallback.\n\nKernel mode registry callback checks that the registry operation is RegNtEnumerateKey and then\nlooks for 0x2BADDOOD:\n\nIf found, Cahnadr handles the command and returns the result to the buffer used in the request.\n\n### Kernel-mode networking module\n\n**Cahnadr hooks the following routines in order to hide its traffic, perform different tasks and provide**\nadditional functionality for the user mode components:\n\n- ndis!NdisMSendNetBufferListsComplete\n\n- ndis!NdisMIndicateReceiveNetBufferLists\n\n\n-----\n\nThese routines are callbacks run by network drivers to notify handlers with all data sent or received.\nThe function lists in PNET_BUFFER_LIST all packets and their related event. Cahnadr checks if there\nare Slingshot-related packets in this list, and if so, removes them. Let´s explain this in more detail:\n\nThe trick is that all the malware is allocated to a particular pool that allows discriminating it from\nother benign calls. NdisAllocateNetBufferListPool creates NET_BUFFER_LIST, that is initialized calling\nNdisAllocateNetBufferAndNetBufferList. When the network driver sends data, it gets into such a\nNET_BUFFER structure, which in turn, gets into NET_BUFFER_LIST. The callbacks routine\nNdisMSendNetBufferListsComplete, that gets the NET_BUFFER_LISTs with data successfully sent, is\nhooked. Malware simply checks if any entry in NET_BUFFER_LIST was allocated from the malware\npool and, if so, will simply not return it to the original handler.\n\nThis sniffer has a list of tasks, each one associated with a list of handlers. Inbound and outbound\npackets are examined and passed to the appropriate task’s processor, which calls all handlers\nassociated with the task. The result determines whether malware should hide the package.\n\nWe have seen three types of task:\n\nHTTP: This is the only handler that notifies GollumApp (user mode payload, described below) that\nHTTP data is being transferred.\n\nARPf: (two handlers for this type). The first one notifies GollumApp when an ARP-request is received\nand/or when an ARP-response is sent.\nThe second one stores this information in its internal storage, collecting information about the\nnetwork structure. This task is enabled by default.\n\nIP2f: (two handlers of this type). The first one checks if the package comes from the malware\noperators, only to decide whether the package should be hidden. This is decided by XORing two\nTimestamps values from the Options field in the TCP-header (RFC1323, code 0x080A). If the result is\nequal to 0xDEADFOOD then this package should be hidden.\n\nThe second one notifies GollumApp that some TCP/UDP or ICMP packets that suit malicious filters\nwere found.\n\nFor instance, for TPC traffic this filter uses the same described XOR procedure with the constant\n**0xDADAE000, sending GollumApp the seqNumber, askNumber and src port values.**\n\nFor UDP, packets with a length of 0x55 bytes containing DNS responses, it checks that the field\ndns.Identifier equals 0x212. In that case, the packet is hidden and GollumApp is notified with the\nresolved IP and TTL of the packet.\n\nFor ICMP, packets containing the «Destination port unreachable» error it checks that the overlying\nprotocol contains the constant 0xE17F (57727). In that case, GollumApp is notified with\nip.Destination, ip.identification, ip.length.\n\nThis task is enabled by default.\n\nThe malware identifies HTTP traffic by checking the ASK flag in TCP protocol, and by finding the HTTP\nsignature in the TCP package body. This task is disabled by default, however GollumApp can enable\nit.\n\nAdditionally, this kernel mode module provides the following functionality for user mode\ncomponents:\n\n- ARP-query: obtains the MAC-address for a specified IP address. Requires network interface as a\nparameter\n\n\n-----\n\n- ARP-reply: sends its own MAC address as a response to a specified ARP-request, regardless of\nwhether the IP from the request and the infected computer are the same or not\n\n- Sends custom network package, where all fields can be customized from the Ethernet-layer\n\n- Sends custom IPV4 package\n\nCahnadr supports IEEE 802.11 standard, allowing it to operate with WiFi frames.\n\nNetwork interfaces are traced using Plug-and-Play notifications with EventCategory PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES. When a network interface\nchange event happens, all hooks listed above apply and Cahnadr checks the category of the new\ninterface (bridge/wan/lan). Depending on the type of interface, it gets different data that is written\nin thee malware´s storage:\n\n- Ethernet: MAC-address and maximum frame size\n\n- Wireless (802.11) Access Point MAC-address and authentication state\n\n### User mode payloads\n\n**GollumApp**\n\nThis payload (named after the famous character from The Hobbit) is the main user mode payload,\norchestrating activities of other modules and having a constant interaction with the kernel mode\n**Cahnadr orchestrator.**\n\nInitially it is injected into services.exe as a separate user mode thread: first it allocates the memory,\nthen writes the module and creates the thread. After that, it calls CsrCreateRemoteThread in the\ncontext of the csrss.exe for creating the new thread in services.exe, which is typical for creating new\nuser mode threads from ring0. This is done in this way because malware works directly with system\nservices.\n\nThe following summarizes its functionality:\n\n-    Collects network-related information: routing tables, configuration, information about proxyservers and AutoConfigUrl settings\n\n-    Collect notifications about all changes in the routing table and/or changing interface IPaddress.\n\n-    Handles IO requests for the encrypted file system\n\n-    Contains various command processor for communication with CNC\n\n-    Collects all passwords saved in Mozilla and IE\n\n-    Can work with the clipboard\n\n-    Can log all pressed keys\n\n-    Collects information about hard disk partitions\n\n-    Collects information about USB devices and sends notifications when new device is\nconnected.\n\n-    Can run new process with SYSTEM privileges as a child of smss.exe\n\n-    Injects malicious module SsCb into specified process\n\n**SsCB**\n\nThis module provides the following features:\n\n- Makes screenshots of a specified window, or the whole desktop\n\n- Steals data from clipboard\n\n\n-----\n\n- Collects information about opened windows: title, size, position\n\n- Can close any window by sending WM_CLOSE message\n\n- Shows specified window by calling ShowWindow\n\n- Collects information about active desktop, active window, name of a process that created this\nwindow, title of a window, keyboard layout\n\n**ffproxy**\n\nCollects information related to proxy settings for all Mozilla profiles.\n\n- From pref.js: Collects HTTP and SSL proxies, autoconfig_url (contains local or remote URL to\nProxy AutoConfiguration file, for instance, when proxy settings are managed remotely)\n\n- From signons* files: retrieves domain, port and username with passwords, if available\n\n    - signons.sqlite for 3.5-32.0 versions\n\n    - signons3.txt for 3.0-3.5  versions\n\n    - signons2.txt from 1.5.0.10 and 2.0.0.2 to 3.0 versions\n\n    - signons.txt for lower versions\n\n**NeedleWatch**\n\nThis component is injected in almost all processes using the couple GollumApp and Cahnadr. It spies\non the content of the buffers passed to the following functions:\n\n\n\n- Functions that draw text\n\n\n\n    - gdi32!ExtTextOutW\n\n    - gdi32!ExtTextOutA\n\n    - gdi32!TextOutA\n\n    - gdi32!TextOutW\n\n- Functions that writes to Console\n\n    - kernel32!WriteConsoleA\n\n    - kernel32!WriteConsoleW\n\n- Function used for rendering unicode text by Uniscribe library\n\n    - usp10!ScriptShape\n\n- Function used for rendering text by DirectWrite\n\n    - dwrite!DWriteFontFace::GetGlyphIndicesW\n\n- Functions used for encryption and decryption by SSP (Security Support Provider)\n\n    - secur32!EncryptMessage\n\n    - secur32!DecryptMessage\n\n- Functions from Netscape Portable Runtime\n\n    - nspr4!PR_GetUniqueIdentity\n\n    - nspr4!PR_Read\n\n    - nspr4!PR_Write\n\nThe implementation is based on hooks. Each hook is set as one of the privileged instructions placed\nat the beginning of the function. Before placing hooks, NeedleWatch registers an exception handler\nby calling AddVectoredExceptionHandler, so when the hooked function is called, the first instruction\nraises an exception which is handled by NeedleWatch. In the malware exception handler\nNeedleWatch calls the original function and extracts all the sent/received data.\n\nFunctions from the secur32 and nspr4 modules are the most interesting ones.\n\n\n-----\n\nEncryptMessage and DecryptMessage are functions of the Security Support Provider Interface, not\nlinked to any Security Support Provider in particular, so hooking these functions allows NeedleWatch\nto spy on every provider: Digest, Kerberos, NTLM, Schannel, or any other one.\n\nNeedleWatch can also read encrypted Mozilla traffic as follows: Netscape Portable Runtime (NSPR)\nprovides a platform-neutral API for system level and libc-like functions. The API is used in Mozilla\nclients, many of Red Hat's and Oracle's server applications, and other software. In I/O NSPR operates\nwith file descriptors that can be layered. When read/write operations occur, NeedleWatch checks\nthe layer of the file descriptor and if it is NSS (Network Security Services), SSL or any other SSL-based\nlayer, NeedleWatch stores the data from the buffer sent in the I/O operation.\n\n**Sfc2**\n\nDisables Windows file protection, making sfc.exe utility believe that the patched disk system library\n(scesrv or spoolsv) is not.\n\nThis is possible by patching wcp.dll in the TrustedInstaller.exe process. Based on the exported\nwcp!RtlParseManifestMicrodomIntoCdf function, Sfc2 searches for the address of the non-exported\nwcp!GetRootElement function and calls it in order to retrieve the _XMLWALK_ELEMENT_DECL\nstructure. Once returned, this structure will be patched at the 0x34 offset with 0 instead of 0x1E.\n\nIn x64 version it hooks ZwCreateFile and ZwOpenFile in the same way as described in the\nNeedleWatch section. If the hook handler found that the file object name passed to function points\nto scesrv.dll library in system or in winsxs directory, malware changes the object name to scesrv.dll\nlocated in winsxs\\backup directory. So, when the process is trying to check patched scesrv, hooks\nmake it so that an unpatched backup file is checked instead.\n\n## Additional Technical Details\nAfter analyzing the main components of this framework, we still want to highlight some specific\ntechnical details and especially interesting related artifacts in this section.\n\n### Packer\n\nAll samples are packed with a previously unknown packer that transforms custom PE sample into\nbase-independent code. This way, the packer allows to compile new components of this APT as\nordinary PE files and, after unpacking, they can use them as a base-independent code.\n\nThat helps to embed them into other samples, among other advantages, such as easy process\ninjection or infecting system libraries. Other typical advantages such as smaller code and hiding\nfunctionality are also provided.\n\nAfter packing the resulting structure is as follows:\n\n1. Header, 0x400 bytes long\n2. Unpacker stub\n3. Data for unpacking\n\nThe header, initial base-independent code and all data that is necessary for unpacking are shown\nbelow:\n\n\n-----\n\nSome of the reserved parameters will be used internally by the unpacker, others are there for future\nimprovements. In later versions of this packer, module and section names are encrypted by a simple\nXOR-based algorithm.\n\nThe value at offset 0x198 contains the virtual address of a first section descriptor. Each section is\nrepresented in this structure with six fields: section RVA, characteristics, real size, packed size. If real\nsize is not equal to packed size if means that this section is encrypted. The last two fields are\nreserved. After the descriptor, there is a data section, followed by more descriptors with the same\nstructure.\n\nThe packing algorithm is based on the Aplib compression library:\n\n1. Packs each section with APlib compression\n2. Replaces the original PE header with a new one generated by the packer\n3. Adds a stub with the decrypt routine\n\nBase-independent code decrypt routine works as follows:\n\n1. Obtains the addresses of GetProcAddress & LoadLibrary functions\n2. Allocates memory for the original unpacked PE-file\n3. Unpacks all sections and writes them in the allocated memory\n4. Sets rights for each section by calling VirtualProtect\n5. Restores the original import table\n6. Fixes relocations; works with exceptions: for x64 images adds exception handlers\n\n(RtlAddFunctionTable), for x32 patches ntdll!RtlIsValidHandler so it always returns true\n7. Wipes all headers and returns execution to the original entry point\n\n\n-----\n\n### SlingDll.Dll and Minisling modules\n\nFor some victims we found that attackers did not use Slingshot. Instead, they used two components\nnamed SlingDll.dll and Minisling.\n\n**SlingDll is typically located in system32 folder as a standalone DLL with a random name and loaded**\nby svchost via COM Object hijacking (CLSID =6C19BE35-7500-11D1-AD94-00C04FD8FDFF). It uses\nmodule_id 0xFF000008 for fixing SlingDll.dll export table in runtime. Then it obtains the path to a\nMZPE sample from module_id 0xFF000008:\n\nand fills the export table with links to the exported routines of this file (DLL-forwarding). This way,\nwhen SlingDll.#1 is called, esscli.#1 will be run. The export table in memory looks like this:\n\nSlingDll.dll also uses a smart trick. Its image in memory looks initially like this:\n\n\n-----\n\nThen it copies the whole image to heap and UnmapViewOfFile to unload SlingDll.Dll image. After\nthat, it allocates new memory by calling VirtualAlloc with the same start address and size that the\nunloaded image had. Finally, malware copies all data from heap back to the allocated memory,\nresulting in the following:\n\nAt that moment the image is unloaded but keeps working because ImageBase is the same.\n\nThe last thing that SlingDll.dll does is run the Minisling module.\n\n**Minisling uses a global mutex (Global\\{6D29520B-F138-442e-B29F-A4E7140F33DE}) to ensure it is**\nrun only once. It checks if one of the following drivers is loaded into memory: DepFrzLo.sys,\nDeepFrz.sys, DfDiskLo.sys; and if none is found it checks how many times the operating system was\nrebooted before correctly shutting down. This is done by comparing EventRecordID from ETW-logs:\nmalware gets this value by sending an XML-requests with EventID=12 and Provider.Name =\nMicrosoft-Windows-Kernel-General in order to obtain the last reboot time, and with EventID=41 and\nProvider.Name = Microsoft-Windows-Kernel-Power to obtain the last unsuccessful attempt to turn\nthe machine off.\n\nWhen the limit of reboots is reached, Minisling deletes itself. In cases when the computer was\nsuccessfully rebooted, the counter is set to 0. If one of the drivers listed above is loaded or if the\ncounter limit is not reached, Minisling starts finding and executing loaders in the same sequence as\npreviously described.\n\n### Infected Mikrotik Device - chmhlpr.dll\n\nMikrotik is a Latvian network hardware provider. For managing their routers, this company provides\nto customers with software called WinBox that downloads a number of DLLs from the router’s file\nsystem and loads them directly into the computer memory. This is its normal behavior by design.\n\nA library called ip4.dll was added onto the router by the attacker. After it was added, the Winbox\nsoftware started to download and run it – we are not sure why.\n\nDuring our research, we found several victims whose Mikrotik routers were hacked, resulting in it\nreturning a suspicious ip4.dll file with the internal name chmhlpr.dll. Indeed, this DLL is a TrojanDownloader related to Slingshot.\n\nThat makes us believe that Slingshot is able to target victims by directly infecting Mikrotik routers in\norder to abuse this mechanism used by WinBox. We do not know how these routers were\ncompromised, however Wikileaks´ Vault7 describes the use of the ChimayRed exploit to compromise\nsuch devices. The exploit is now available on GitHub.\n\nMikrotik´s official forum declares that this exploit only works until RouterOS v.6.38.4, however this\nparticular victim was running version 6.38.5 of the firmware, making it unclear whether this version\nis still vulnerable or if attackers used a different one. We contacted Mikrotik and reported this attack\nprocedure. According to Mikrotik, latest versions of WinBox no longer download the ipv4.dll file\nfrom the router, closing the attack vector.\n\nThe following table summarizes malicious ipv4.dll files abusing this method:\n\n\n-----\n\n|MD5|Size|File location|\n|---|---|---|\n|042CC382ACB5B2B70C78BAA77BB7C5F9|43520|%AppData%\\Roaming\\mikrotik\\winbox\\5.20- 3610090039\\ipv4.dll|\n|AFAFF3310D8C094774DA6BA856C1A30E|43520|%AppData%\\Roaming\\Mikrotik\\Winbox\\5.20- 3610090039\\ipv4.dll|\n|01C85EE057B6B529891C0A4275A642DA|43520|%AppData%\\Roaming\\Mikrotik\\Winbox\\6.33.1- 1338332867\\ipv4.dll|\n|87A28A99697452A37FC229B3AA3AFE97|43520|%AppData%\\Roaming\\mikrotik\\winbox\\6.38.5- 3172206015\\ipv4.dll|\n\n\n**chmhlpr.dll downloads a malicious packed MZPE to execute. This library has four hardcoded**\nparameters:\n\n- IP for downloading the payload. In the sample that we found, the payload was located in the\nsame compromised Mikrotik router (192.168.88.1).\n\n- Port to connect to (4443 in our sample).\n\n- Number of connection attempts (3 in our sample).\n\n- Delay between attempts, in seconds (90 seconds in our sample).\n\nIf no IP is hardcoded, it waits for an incoming connection on the specified port.\n\nOnce it gets connection it sends the magic value 0x43237FB2 and waits for the packed module. It\nchecks for a constant at 0x84 offset, looking for 0xDEADFOOD in order to unpack and load this code.\nThen it shares the socket of the established connection to the new module and runs it.\n\nThe downloader can also use a proxy information detailed in:\n*UserSID*\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer\n\nIt searches for proxy credentials in:\n\n- Windows protected storage, where ItemName parameter contains proxy domain\n\n- Credentials from IE as documented here\n\n### KPWS\n\nThere is a second Trojan-Downloader called ‘kpws’ designed to download another Slingshot\ncomponent and run it. Unlike chmhlpr, it can´t connect over proxies, can’t listen for connection,\nparameters are set in cmd line (embedded in packed MZPE) and it actively uses logging.\n\nThe main difference, however, would be the magic constant sent as first packet, set to 0xC0FFEE43.\nThis tool contains a reference to Smeagol (Gollum’s original name in The Lord of the Rings) which\nactually refers to GollumApp.\n\n### Additional downloaders\n\n**‘Rc’ downloader**\nThis component named ‘rc’ has the same input parameters as chmhelp.dll and the same output\naskpws. It provides the following functionality:\n\n- Resolves environment variables.\n\n\n-----\n\n- Sends info about files in directory: path, size, date modified.\n\n- Write files, sends files.\n\n- Sends info about run processes: PID, PPID, creation time, name of the executable file for the\nprocess, account name with domain, is process run under Wow64.\n\n- Terminates process by PID.\n\n- Impersonates user by login and password received from server or by process PID.\n\n- Reverts to self after impersonation.\n\n- Creates process. If impersonation was successful than creation take place on behalf of\nimpersonated user.\n\n- Communicates with created process.\n\n- Sends name of the local computer, Windows version, build number, installed service pack.\n\n- Sends username.\n\n- Migrates to another process: infects process by PID with itself in memory. Socket connected to\nserver is passed too.\n\n- Migrates to another process: path to process to be created is received from server. Inject is only\nin memory. Socket connected to server is passed too. When injected, malware downloads and\nruns next Slingshot component.\n\n- Downloads and configures new module, then runs it in new thread in current process. All logging\nof new module will be send to server.\n\nThe configuration of a new module can be only done through command line (embedded in the\nheader of the packed component) and consists ofreceiving it from the C2 server, parsing it and\ninserting it into the downloaded sample.\n\nThis seems a strange behavior, as there is no need to do all this on the victim side.\n\nInterestingly, ‘rc’ logs in some victims showed connections to the 2869/1900/5431 ports, linked to\nvulnerabilities in previous UPnP protocols. This might be another one clue that attackers used\nvulnerable routers as infection vector.\n\n**Spork downloader**\n\nThis is the last downloader we have found, quite different from the ones described above:\n\nNot as interesting as its main duty (downloads and run a payload) is its implementation. This module\nintroduces a rule engine with embedded serialized rules. This is intended to find some Personal\nSecurity Products (PSPs) that suit the rules among the started processes. This is used to decide to\nwhich process the embedded malicious shellcode will be injected.\n\nRules are serialized according the following scheme:\n\n- Byte count_rules, count_PSPs.\n\n- Rule all_rules[count_rules] (6 or 8 bytes per rule depending on spork version - yellow).\n\n- Short offsets_to_PSP_names[count_PSPs] (purple).\n\n- Char PSP_names[count_PSPs][] (green).\n\n\n-----\n\nEach rule consists of 6 fields:\n\n- Process name of the PSP represented as index in offsets array.\n\n- Array of names of processes to inject to as index view too (some below will be described).\n\n- Min version of the PSP.\n\n- Max version of the PSP.\n\n- Flags: for example, x32/x64.\n\n- Type used as result when rule was found.\n\nSpork enumerates all the started processes, checking each of them with each rule. If any process\nmatches at least one of them, it decides whether to inject code into it depending on the type of the\nmatched rule. Type can be any of the following values:\n\n- Type 0: default\n\n- Type 1: error\n\n- Type 2: inject into matched PSP\n\n- Type 3: inject into lsass.exe\n\n- Type 4: inject into winlogon.exe\n\n- Type 5: inject into svchost.exe\n\n- Type 6: inject into process specified in second field of matched rule\n\nIf no process matches any rules, then the default process ‘svchost.exe’ is used for injection.\n\nThe matching process with a rule can be summarized as follows:\n\n- Process name is equal to the PSP name in rule\n\n- Version of the PSP is inside the bounds specified in the rule\n\n- Process suits all flags that are set in the rule\n\nThe version of PSP is determined by sequence calls to GetFileVersionInfo and VerQueryValue to get\ndwProductVersionMS field, which contains the number of the product this file (PSP) was distributed.\n\nThe following table summarizes the found PSP with the process to inject:\n\n\n-----\n\n|found PSP name|versions|bitness|process to inject|\n|---|---|---|---|\n|avfwsvc.exe|00-ff|x32|avguard.exe|\n|avfwsvc.exe|00-ff|x64|inssda64.exe|\n|avgtray.exe|00-ff|x32|avgtray.exe|\n|avgtray.exe|00-ff|x64|avgsrmaa.exe|\n|avp.exe|01-07|x32-x64|winlogon.exe|\n|avp.exe|08-0c|x32|avp.exe|\n|avp.exe|08-0c|x64|lsass.exe|\n|avp.exe|0d-0d|x32-x64|lsass.exe|\n|avastui.exe|00-ff|x32|avastui.exe|\n|avastui.exe|00-ff|x64|winlogon.exe|\n|avgnt.exe|00-ff|x32|avguard.exe|\n|avgnt.exe|00-ff|x64|inssda64.exe/avshadow.exe|\n|avgui.exe|00-ff|x32-x64|winlogon.exe|\n|bdagent.exe|00-ff|x32-x64|bdagent.exe|\n|cfp.exe|00-ff|x32-x64|cfp.exe|\n|casc.exe|07-08|x32-x64|svchost.exe|\n|casc.exe|05-06|x32-x64|error|\n|defenderdaemon.exe|00-ff|x32-x64|error|\n|egui.exe|00-ff|x32-x64|default - svchost.exe|\n|fsdfwd.exe|00-ff|x32-x64|default - svchost.exe|\n|mcagent.exe|00-ff|x32-x64|winlogon.exe|\n|rstray.exe|00-ff|x32|rstray.exe|\n|rstray.exe|00-ff|x64|error|\n|rtvscan.exe|00-ff|x32-x64|default - svchost.exe|\n|tmproxy.exe|00-ff|x32-x64|tmproxy.exe|\n|umxcfg.exe|07-08|x32-x64|default - svchost.exe|\n|umxcfg.exe|05-06|x32-x64|error|\n|zlclient.exe|00-ff|x32-x64|error|\n\n\n-----\n\nInstead of injecting the malicious code in already started processes, spork creates a new process of\nthe selected image. Process is created with the: flags hide, create no window, default instead of\nloading cursor and suspended. Then it creates a new section, fills it with malicious shellcode\ndepending on the created x32 or x64 process and patches the EntryPoint so that it calls the\nshellcode. The last step is calling ResumeThread to run it.\n\nThe new shellcode loads its needed libraries by parsing PEB, connects to its C2 (specified in cmdline), sends to it constant 0xC0FFEE44 or 0xC0FFEE43 depends on process bitness, downloads the\nmalware from the received answer, passes to it socket used for the connection and runs. Unlike all\nthe previously described downloaders, it doesn’t check for 0xDEADFOOD at 0x84 offset.\n\n## Victims\nUsing our telemetry, we were able to find almost one hundred victims, most of them based in the\nMiddle East and Africa. The following chart shows the percentage of victims per country:\n\n\n-----\n\n## Conclusions\nThe discovery of Slingshot reveals another complex ecosystem where multiple components work\ntogether in order to provide a very flexible and well-oiled cyber-espionage platform. The malware is\nhighly advanced, solving all sort of problems from a technical perspective and often in a very elegant\nway, combining older and newer components in a thoroughly thought-through, long-term operation,\nsomething to expect from a top-notch well-resourced actor. All this framework is designed for\nflexibility, reliability and to avoid detection, which explains why these components were not found\nfor more than six years.\n\nThis long-term campaign seemed to be focused on Africa and the Middle-East region, but obviously\nour telemetry only offers partial visibility and this could be just a subset.\n\nIn terms of attribution, we have not been able to find any definitive links to any previously known\nAPTs. Some of the techniques used by Slingshot, such as the exploitation of legitimate, yet\nvulnerable drivers has been seen before in other malware, such as Turla, Equation’s Grayfish\nplatform and White Lambert. Most of the debug messages found throughout the platform are\nwritten in perfect English. The references to Tolkien’s Lord of the Rings (Gollum, Smeagol) could\nsuggest the authors are fans of Tolkien’s work.\n\nOne interesting point is the possibility of abusing Mikrotik devices (and maybe other network\nhardware providers) as initial infection vector for some victims. We can´t exclude other spreading\nmethods for this campaign, given the versatility of this actor.\n\n## Appendix I - Scripts\n\n\n-----\n\n### String decryption\n\nInstead of storing strings in raw view, some components stores them in encrypted view and decrypts\nwhen it’s needed. This function implements decryption which can be used for further analysis.\n```\ndef get_name(name):\n  key =\nbytearray(b'\\xE0\\x80\\xC5\\xAF\\xB5\\xD7\\xC4\\xA1\\xBD\\xBA\\xE4\\xDA\\x96\\xBF\n\\x9A\\x8A\\x9A\\xA8\\xBE\\xD2\\x85\\x84\\xC4\\xB0\\xAA\\xEA\\xD8\\xAC\\xC4\\xF3\\xAF\n\\x00')\n  size = len(name)\n  ind = ((((0xFFFFFFFF84210843 * size) // 2 ** 32) + size) % (2 **\n32) // 16)\n  ind = ind + ind // 2 ** 31\n  ind = size - ind * 31\n  for i in range(len(name)):\n    key_i = key[ind]\n    name[i] ^= key_i\n    ind += 1\n    tmp = ( 0x8421085 * ind ) // 2**32\n    ind -= (((ind - tmp) // 2 + tmp) // 16) * 0x1F\n  return name\n\n### Spork rules viewer\n\n```\nAs mentioned above, spork contains serialized rules used by rules engine to check which PSP is\ninstalled. This script prints rules in readable view for two types of databases (6 or 8 bytes per rule):\n```\nimport argparse\nimport struct\ndef get_byte(data, offset):\n  byte_range = data[offset : offset + 1]\n  return struct.unpack('<B', byte_range)[0]\ndef get_short(data, offset):\n  byte_range = data[offset : offset + 2]\n  return struct.unpack('<H', byte_range)[0]\nclass rule:\n  rule_size = 8\n  def __init__(self, raw_rule):\n    self.index_process_name = get_byte(raw_rule, 0)\n    self.index_process_to_inject = [get_byte(raw_rule, 1)]\n    offset = 0\n    if rule_size == 8:\n      offset = 2\n      if get_byte(raw_rule, 2) != 0:\n\n```\n\n-----\n\n```\n        self.index_process_to_inject.append(get_byte(raw_rule\n, 2))\n      if get_byte(raw_rule, 3) != 0:\n        self.index_process_to_inject.append(get_byte(raw_rule\n, 3))\n    self.min_version = get_byte(raw_rule, 2 + offset)\n    self.max_version = get_byte(raw_rule, 3 + offset)\n    self.flags = get_byte(raw_rule, 4 + offset)\n    self.type_of_action = get_byte(raw_rule, 5 + offset)\nclass rule_db:\n  def __init__(self, input_file):\n    data = bytearray(open(input_file, \"rb\").read())\n    self.rules_count = get_byte(data, 0)\n    self.strings_count = get_byte(data, 1)\n    self.rules = []\n    for i in xrange(self.rules_count):\n      self.rules.append(rule(data[2 + i * rule.rule_size : 2 +\ni * rule.rule_size + rule.rule_size]))\n    self.offsets = []\n    self.strings = []\n    for i in xrange(self.strings_count):\n      self.offsets.append(get_short(data, 2 + self.rules_count\n* rule.rule_size + i * 2))\n      curr = start = self.offsets[i]\n      while data[curr] != 0:\n        curr += 1\n      self.strings.append(str(data[start : curr]))\n  def print_info(self):\n    for rule in self.rules:\n      process_to_inject = 'svchost.exe'\n      if rule.type_of_action == 1:\n        process_to_inject = 'error'\n      elif rule.type_of_action == 2:\n        process_to_inject =\nself.strings[rule.index_process_name]\n      elif rule.type_of_action == 3:\n        process_to_inject = 'lsass.exe'\n      elif rule.type_of_action == 4:\n        process_to_inject = 'winlogon.exe'\n      elif rule.type_of_action == 6:\n        process_to_inject = '/'.join([self.strings[i] for i\nin rule.index_process_to_inject])\n      bitness = 'x32-x64'\n      if rule.flags == 1:\n        bitness = 'x32'\n      elif rule.flags == 2:\n        bitness = 'x64'\n\n```\n\n-----\n\n```\n      print ('PSP: %s\\tversion: %02x-%02x\\tbitness: %s\\ttarget:\n%s' % (self.strings[rule.index_process_name], rule.min_version,\nrule.max_version, bitness, process_to_inject) )\nparser = argparse.ArgumentParser()\nparser.add_argument('input_file')\nargs = parser.parse_args()\nfor rule_size in [8, 6]:\n  try:\n    rule.rule_size = rule_size\n    db = rule_db(args.input_file)\n    db.print_info()\n    break\n  except:\n    continue\n\n## Appendix II - Indicators of compromise\n\n```\n**MD5**\n042cc382acb5b2b70c78baa77bb7c5f9\n11ccc2c5811c80f2a796817d9ccbe34b\n142970f7e10e3a49e583b2f557dcbe79\n64f705e55545a371e0f5e599cfbae5e9\n6637dbcc6059a1e2e45956d98a3ea590\n706269c041d94c4501b78c128f1c0e70\n7fb82333aa08f4bfbbfa515e7e93bad4\n87a28a99697452a37fc229b3aa3afe97\nafaff3310d8c094774da6ba856c1a30e\nb7a2525e05769540f48733d5673a77fa\nc638169aaa777d4f6eae43205a39e274\ndb71aed3b9ffbbfa4c49db036520ceeb\nf4944c5d47907ce93819aed8c4f76bcc\n\nMore indicators are available to Kaspersky Lab private report subscribers. Please contact\nintelreports@kaspersky.com\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "5910e58f-4bc9-4e4e-9dbb-887804094a01",
            "created_at": "2022-10-25T16:32:58.457399Z",
            "updated_at": "2022-10-25T16:32:58.457399Z",
            "deleted_at": null,
            "name": "OTX",
            "url": "https://otx.alienvault.com",
            "description": "Alienvault Open Threat Exchange (OTX)",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2018/2018.03.06.The-Slingshot-APT/The-Slingshot-APT_report_ENG_final.pdf",
        "https://s3-eu-west-1.amazonaws.com/khub-media/wp-content/uploads/sites/43/2018/03/09133534/The-Slingshot-APT_report_ENG_final.pdf"
    ],
    "report_names": [
        "The-Slingshot-APT_report_ENG_final",
        "The-Slingshot-APT_report_ENG_final.pdf"
    ],
    "threat_actors": [
        {
            "id": "a0d369c1-f0b7-4c70-a3a5-77aabbd17979",
            "created_at": "2022-10-25T15:50:23.311311Z",
            "updated_at": "2025-03-27T02:00:55.438117Z",
            "deleted_at": null,
            "main_name": "Strider",
            "aliases": [
                "ProjectSauron"
            ],
            "source_name": "MITRE:Strider",
            "tools": [
                "Remsec"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "99845f58-2c39-46f7-8369-bb621ebb7002",
            "created_at": "2022-10-25T16:07:24.238844Z",
            "updated_at": "2025-03-27T02:02:10.14785Z",
            "deleted_at": null,
            "main_name": "Strider",
            "aliases": [
                "ProjectSauron"
            ],
            "source_name": "ETDA:Strider",
            "tools": [
                "Backdoor.Remsec",
                "ProjectSauron",
                "Remsec"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c1ac2a5e-0225-47a4-8ac5-5fa898c96bde",
            "created_at": "2023-01-06T13:46:38.472883Z",
            "updated_at": "2025-03-27T02:00:02.84253Z",
            "deleted_at": null,
            "main_name": "ProjectSauron",
            "aliases": [
                "Sauron",
                "Project Sauron",
                "G0041"
            ],
            "source_name": "MISPGALAXY:ProjectSauron",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "23dfc9f5-1862-4510-a6ae-53d8e51f17b1",
            "created_at": "2024-05-01T02:03:08.146025Z",
            "updated_at": "2025-03-27T02:05:17.420497Z",
            "deleted_at": null,
            "main_name": "PLATINUM TERMINAL",
            "aliases": [
                "Longhorn ",
                "The Lamberts ",
                "Vault7 ",
                "APT-C-39 "
            ],
            "source_name": "Secureworks:PLATINUM TERMINAL",
            "tools": [
                " Assassin",
                " Marble Framework",
                "AfterMidnight"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716500,
    "ts_updated_at": 1743041780,
    "ts_creation_date": 1520599778,
    "ts_modification_date": 1520599778,
    "files": {
        "pdf": "https://archive.orkl.eu/42bc3ed806d32f12e7fcb224aa184abfda49d079.pdf",
        "text": "https://archive.orkl.eu/42bc3ed806d32f12e7fcb224aa184abfda49d079.txt",
        "img": "https://archive.orkl.eu/42bc3ed806d32f12e7fcb224aa184abfda49d079.jpg"
    }
}