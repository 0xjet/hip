{
    "id": "972a9826-f5a0-4fb1-864f-e77827b105cc",
    "created_at": "2023-01-12T14:59:50.158824Z",
    "updated_at": "2025-03-27T02:05:35.016143Z",
    "deleted_at": null,
    "sha1_hash": "ee6e251a7dc426931ad4fb156ed233a25a353a03",
    "title": "2022-01-07 - Unpacking Emotet malware part 02",
    "authors": "",
    "file_creation_date": "2022-05-27T18:58:06Z",
    "file_modification_date": "2022-05-27T18:58:06Z",
    "file_size": 2926150,
    "plain_text": "# Unpacking Emotet malware part 02\n\n**muha2xmad.github.io/unpacking/emotet-part-2/**\n\n\nJanuary 7, 2022\n\n\n-----\n\n### Muhammad Hasan Ali\n\nMalware Analysis learner\n\n5 minute read\n\n**As-salamu Alaykum**\n\n## Part 01 summary\n\n[Download the sample: Here](https://app.any.run/tasks/f907a5b5-689a-472d-a2f7-1a2c4899fc96/)\n\nfound `VirtualAlloc call in` `sub_417D50 and its address.`\n\nwe search for abnormal jumps. we found `jmp ecx and its address.`\n\n## Introduction\n\nwe will debug our sample with x32dbg tool to unpack the Emotet malware\n\n## Notes to be taken\n\nWhat is Packing: A trick which is Used to avoid AV detection and analysis.\n\nWhat is a packer: A tool that compresses, encrypts, and/or modifies a malicious file\nformat. [1](https://www.mcafee.com/blogs/enterprise/malware-packers-use-tricks-avoid-analysis-detection/#:~:text=One%20of%20the%20most%20popular,program%20against%20cracking%20or%20copying.)\n\nWhy using packers: To avoid AV detection and analysis to make it harder for\nresearchers to analyze the code\n\nWe need to find the the original entry point (OEP). What is the OEP: is the address of\n[the malware’s first instruction (where malicious code begins) before it was packed. 2](https://www.oreilly.com/library/view/learning-malware-analysis/9781788392501/12556df2-7825-4e43-8811-c0fabeab78d8.xhtml)\n\nHow to find the OEP: find the `tail jump . the tail jump It’s an unconditional jump`\n[exists in the tail of stub code, it points to address of unpack file. 3](https://www.0xbyte.com/unpacking-mzp-ransomware-manually/)\n\n[How to the unpack happen? 3 As we see in the figure (1). OS create stub code with packed](https://www.0xbyte.com/unpacking-mzp-ransomware-manually/)\nfile\n\n[What is stub code? 3 Stub code is responsible for unpacking packed sections, when](https://www.0xbyte.com/unpacking-mzp-ransomware-manually/)\nyou are running the file,the address of unpack file exists in the stub code to unpack\nfile. So at the end of the stub code we will see an unconditional jump (tail jump), that is\nmeant after execute the stub code will jump to the address of unpacking file.\n\n\n-----\n\nFigure(1):\n\nWhat is stack string? [answer](https://isc.sans.edu/forums/diary/Stackstrings+type+2/26192/#:~:text=This%20is%20a%20technique%20that,the%20allocated%20chunk%20of%20memory)\n\nWe need to know what is `VirtualAlloc ?` [Here](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx)\n\nSays that “Reserves, commits, or changes the state of a region of pages in the virtual\naddress space of the calling process. Memory allocated by this function is automatically\ninitialized to zero.”\n\n**Syntax**\n```\n LPVOID VirtualAlloc(\n [in, optional] LPVOID lpAddress,\n [in]      SIZE_T dwSize,\n [in]      DWORD flAllocationType,\n [in]      DWORD flProtect\n);\n\n```\nThe most important parameter of this function is `lpaddress, which returns the starting`\n**offset of the newly allocated memory. where we will extract the malware then dump it.**\n\n## Start Debugging\n\nOpen our sample by x32dbg and hit the entry point\n\n\n-----\n\nFigure(2):\n\nWe set a breakpoint over the jump instruction `jmp ecx at the address` `00417F1F by`\npressing `f2 . because after this jump the unpack process will happen.`\n\nFigure(3):\n\nThen we press `f9 to hit the breakpoint.`\n\n\n-----\n\nFigure(4):\n\nThen press `f7 we jump to another function. If we analyze this function we will notice that:`\n\nepilogue\n\nFigure(5):\n\n## Abnormal prologue\n\nFigure(6):\n\nThe last figure shows the abnormal prologue (1). And (2) is a suspecious instruction which\nwe will know late that is new `VirtualAlloc .`\n\nSo we set a breakpoint over this instruction `mov edx,dword ptr ds:[41C1B4] by` `f2`\nand press `f9 to hit the breakpoint.`\n\n\n-----\n\nFigure(7):\n\nNow if we `follow in dump We see that it’s allocating memory.`\n\nThen Press `f8 it will` `push edx to the stack which is the value of` `mov edx,dword ptr`\n```\nds:[41C1B4] .\n\n```\nThen Press `f8 . There is abnormal` `ret . Normal` `ret value will get back to wherever it`\nwas called from.\n\nHere it return to this address `002302F0 . Which will be the address of the unpacking`\nsection.\n\nFigure(9):\n\nSo step over it.\n\nIn the next part we will see functions (Unpacking routine) and we will explain it on the fly in\nthe next figure\n\n\n-----\n\nFigure(10):\n\nKeep stepping over untill you reach the breakpoint.\n\nThen we see this funtion and step into `f7 .`\n\nFigure(11):\n\nIt uses stack strings. which is mentioned above In introduction. (1) pushes them on the\n**stack.**\n\n\n-----\n\nFigure(12):\n\nTo get out from this function find `ret and set a breakpoint then press` `f9`\n\nAnd these functions do the same as above. So step over them `f8 . to see what inside a`\nfunction without executing it: Double click over a function and press `- button to get out.`\n\nFigure(13):\n\nUntill we get to this last function. step into `f7 .`\n\n\n-----\n\nFigure(14):\n\nAfter we get into the function we need to analyze it carefully\n\nFigure(14):\n\nAs we can see `call edx is calling` `VirtualAlloc :`\n\n`push 40` **RWX which is our indicator to know that this call could be** `VirtuallAlloc`\n\nFigure(15):\n\nOne step over `f8 and we will get the adress of newly memory allocated in` `eax`\n\n\n-----\n\nFigure(16):\n\nThen keep stepping over and get to this function `call 22FBC0 and then one more step`\nover. As we see in the dump section, the function writes over the newly memory allocate with\nthe exe file.\n\nFigure(17):\n\nWhen keep stepping we see that it’s copying files to the exe file\n\n```\n.text\n\n```\n\n-----\n\nFigure(18):\n\nthen `.rdata then` `.data then` `.reloc`\n\nUntill we get to the last `ret 8 as shown.`\n\nFigure(19):\n\n**Stay awake our file is almost finished. After the second** `ret .`\n\nFigure(20):\n\n\n-----\n\nNow we can dump the unpacked exe. `right click over` `eax and press` `Follow in`\n```\nMwmory map\n\n```\n**Sorry for this Mistake in the next figure. It’s** `Follow in Mwmory map`\n\nFigure(21):\n\nThen `right click and then press` `Dump memory to File`\n\n\n-----\n\nFigure(22):\n\nNow if we tried to open it in IDA. We will notice that’s can’t be analyzed\n\n\n-----\n\nFigure(23):\n\nSo we need to repair section headers using `PE bear tool.`\n\n**Before**\n\n\n-----\n\nFigure(24):\n\n**After editing**\n\nFigure(25):\n\nThen change the image base: if it’s different value of the OEP.\n\n\n-----\n\nFigure(26):\n\n## Unmap the unpacked file\n\nHow we edit the section headers? ordered steps.\n\nfirst: copy `Virtuall address values into` `Raw address values.`\n\nsecond: `Raw size Raw size of` `.test = Raw adress of` `.rdata - Raw adress of` `.text`\n```\nE000 - 1000 = D000\n\n```\nRaw size of `.rdata = Raw adress of` `.data - Raw adress of` `.rdata`\n```\nF000 - E000 = 1000\n\n```\nRaw size of `.data = Raw adress of` `.reloc - Raw adress of` `.data`\n```\n13000 - F000 = 4000\n\n```\nRaw size of `.reloc = still the same third: copy` `Raw size values into` `Virtual size`\nvalues.\n\n**After changing save the file. This is our unpacked malware**\n\n\n-----\n\n**See you in the next article. inshAllah**\n\n## Article quote\n\nﻋﻠﻰ اﻟﻀﻔﺔِ اﻷﺧﺮى ﻟﻦ ﻧﺨﺸﻰ اﻟﻐﺮق\n\n## Refernces\n\n1- https://www.mcafee.com/blogs/enterprise/malware-packers-use-tricks-avoid-analysisdetection/\n\n2-https://www.oreilly.com/library/view/learning-malware-analysis/9781788392501/12556df27825-4e43-8811-c0fabeab78d8.xhtml\n\n3- [https://www.0xbyte.com/unpacking-mzp-ransomware-manually/](https://www.0xbyte.com/unpacking-mzp-ransomware-manually/)\n\n4https://isc.sans.edu/forums/diary/Stackstrings+type+2/26192/#:~:text=This%20is%20a%20te\nchnique%20that,the%20allocated%20chunk%20of%20memory\n\n5- [https://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-07 - Unpacking Emotet malware part 02.pdf"
    ],
    "report_names": [
        "2022-01-07 - Unpacking Emotet malware part 02.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535590,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1653677886,
    "ts_modification_date": 1653677886,
    "files": {
        "pdf": "https://archive.orkl.eu/ee6e251a7dc426931ad4fb156ed233a25a353a03.pdf",
        "text": "https://archive.orkl.eu/ee6e251a7dc426931ad4fb156ed233a25a353a03.txt",
        "img": "https://archive.orkl.eu/ee6e251a7dc426931ad4fb156ed233a25a353a03.jpg"
    }
}