{
    "id": "86b892a3-692b-41bc-ae43-62f1f37e7680",
    "created_at": "2023-01-12T15:01:54.239997Z",
    "updated_at": "2025-03-27T02:05:47.837141Z",
    "deleted_at": null,
    "sha1_hash": "897179d8b1749d9d3ddadc211488bfe67442f0e9",
    "title": "2021-06-21 - VMProtect 2 - Part Two, Complete Static Analysis",
    "authors": "",
    "file_creation_date": "2022-05-29T01:33:38Z",
    "file_modification_date": "2022-05-29T01:33:38Z",
    "file_size": 817404,
    "plain_text": "# VMProtect 2 - Part Two, Complete Static Analysis\n\n**back.engineering/21/06/2021/**\n\ncalendar Jun 21, 2021\n\nclock 27 min read\ntag [VMProtect-2](https://back.engineering/tags/vmprotect-2/) [Obfuscation](https://back.engineering/tags/obfuscation/)\ncodepen Author(s): [_xeroxz](https://back.engineering/researchers/_xeroxz/)\nVMProtect 2 Project’s Group: [githacks.org/vmp2](https://githacks.org/vmp2)\n\n## Table Of Contents\n\n Purpose\n\n\nJune 21, 2021\n\n\nThe purpose of this article is to expound upon the prior work disclosed in the last article titled\n[“VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture”, as well as correct a](https://back.engineering/17/05/2021/)\nfew mistakes. In addition, this post will focus primarily on the creation of static analysis tools\nusing the knowledge disclosed in the prior post, and providing some detailed, albut unofficial,\n[VTIL documentation. This article will also showcase all projects on githacks.org/vmp2,](https://github.com/vtil-project/VTIL-Core)\nhowever, these projects are subject to change.\n\n## Intentions\n\nMy intentions behind this research is to further my knowledge in the subject of software\nprotection via native code virtualization, and code obfuscation, it is not to profit nor slander\nthe name of VMProtect. Rather, the creator(s) of said software are to be respected as their\nwork is clearly impressive and has arguably stood the test of time.\n\n## Definitions\n\n\n-----\n\n```\nCode Block : A virtual instruction block, or code block, is a sequence of virtual instructions\n\n```\nwhich are contained between virtual branching instructions. An example of this would be any\ninstructions following a JMP instruction and the next JMP or VMEXIT instruction. A code\n[block is represented in C++ as a structure (vm::instrs::code_block_t) containing a vector of](https://docs.back.engineering/vmprofiler/structvm_1_1instrs_1_1code__block__t.html)\nvirtual instructions, along with the beginning address of the code block contained in the\nstructure itself. Other metadata about a given code block is also contained inside of this\nstructure such as if the code block branches to two other code blocks, branches to only one\ncode block, or exits the virtual machine.\n```\nVMProtect 2 IL : Intermediate level of representation, or language. Consider the encoded\n\n```\nand encrypted virtual instructions to be the usable, native form of virtual instructions. Then IL\nwould be a higher level representation, typically IL representation refers to a representation\nof code used by compilers and assemblers. An example of VMProtect 2 IL is what\nVMAssembler does lexical analysis on, or a file containing the IL to be more specific.\n\n## VMProtect 2 - Project’s Overview\n\nNote: you can find the [doxygen for VMProfiler here](https://docs.back.engineering/vmprofiler/)\n[Although there may seem to be quite a handful of projects located at githacks.org/vmp2,](https://githacks.org/vmp2)\nthere is really only a single large library project and smaller projects which inherit this library.\n[VMProfiler is the base library for](https://githacks.org/vmp2/vmprofiler) [VMProfiler Qt,](https://githacks.org/vmp2/vmprofiler-qt) [VMProfiler CLI,](https://githacks.org/vmp2/vmprofiler-cli) [VMEmu, and](https://githacks.org/vmp2/vmemu) [VMAssembler.](https://githacks.org/vmp2/vmassembler)\n[Each of these projects are static analysis based and thus VMHook and](https://githacks.org/vmp2/vmhook) [um-hook do not](https://githacks.org/vmp2/um-hook)\ninherit [VMProfiler.](https://githacks.org/vmp2/vmprofiler)\n\n\n-----\n\n### VMHook - Overview\n\n[VMHook is a very small C++ framework for hooking into VMProtect 2 virtual machines, um-](https://githacks.org/vmp2/vmhook)\nhook inherits this framework and provides a demonstration of how to use the framework.\n[VMHook is not used to uncover virtual instructions and their functionality, rather to alter them.](https://githacks.org/vmp2/vmhook)\n\n**VMHook - Example, um-hook**\n\n\n-----\n\n```\n.data\n     __mbase dq 0h\n     public __mbase\n.code\n__lconstbzx proc\n     mov al, [rsi]\n     lea rsi, [rsi+1]\n     xor al, bl\n     dec al\n     ror al, 1\n     neg al\n     xor bl, al\n     pushfq  ; save flags...\n     cmp ax, 01Ch\n     je swap_val\n                        ; the constant is not 0x1C\n     popfq ; restore flags...\n     sub rbp, 2\n     mov [rbp], ax\n     mov rax, __mbase\n     add rax, 059FEh ; calc jmp rva is 0x59FE...\n     jmp rax\nswap_val: ; the constant is 0x1C\n     popfq ; restore flags...\n     mov ax, 5 ; bit 5 is VMX in ECX after CPUID...\n     sub rbp, 2\n     mov [rbp], ax\n     mov rax, __mbase\n     add rax, 059FEh ; calc jmp rva is 0x59FE...\n     jmp rax\n__lconstbzx endp\nend\n\n```\num-hook is a project which inherits VMHook, it demonstrates hooking the LCONSTBZX\nvirtual instruction and spoofing its immediate value. This subsequently affects the later virtual\nshift functions result, which ultimately results in the virtual routine returning true instead of\nfalse.\n\n### VMProfiler - Overview\n\n[VMProfiler is a C++ library which is used for static analysis of VMProtect 2 binaries. This is](https://githacks.org/vmp2/vmprofiler)\nthe base project for [VMProfiler Qt,](https://githacks.org/vmp2/vmprofiler-qt) [VMProfiler CLI,](https://githacks.org/vmp2/vmprofiler-cli) [VMEmu, and](https://githacks.org/vmp2/vmemu) [VMAssembler.](https://githacks.org/vmp2/vmassembler) [VMProfiler](https://githacks.org/vmp2/vmprofiler)\n[also inherits VTIL and contains virtual machine handler profiles and lifters.](https://github.com/vtil-project/VTIL-Core)\n\n**VMProfiler - Virtual Machine Handler Profiling**\n\n\n-----\n\nVirtual machine handlers are found and categorized via a pattern matching algorithm. The\nfirst iteration of this algorithm simply compared the native instructions bytes. However this\nhas proven to be ineffective as changes to the native instruction which don’t result in a\ndifferent outcome but do change the native instructions bytes will cause the algorithm to\nmiscatagorize or even fail to recongnize virtual machine handlers. Consider the following\ninstruction variants, all of which when executed have the same result but each has their own\nunique sequence of bytes.\n```\n0: 36 48 8b 00       mov  rax,QWORD PTR ss:[rax]\n4: 48 8b 00        mov  rax,QWORD PTR [rax] \n0: 36 48 8b 04 05 00 00  mov  rax,QWORD PTR ss:[rax*1+0x0]\n7: 00 00 \n\n```\n[In order to handle such cases, a new iteration of the profiling algorithm has been designed](https://githacks.org/vmp2/vmprofiler/-/blob/ebfc4f421e029af1b276c4caef47bee4c710ec3f/src/vmprofiles)\nand implemented. This new rendition still pattern matches, however for each instruction of a\n[virtual machine handler a lambda is defined. This lambda takes in a ZydisDecodedInstruction](https://zyantific.com/doc/zydis/struct_zydis_decoded_instruction__.html)\nparameter, by reference, and returns a boolean. The result being true if a given decoded\n[instruction meets all of the comparison cases. The usage of zydis for this purpose allows for](https://github.com/zyantific/zydis)\none to compare operands at a much finer level. For example, operand two from both\ninstructions in the figure above is of type `ZYDIS_OPERAND_TYPE_MEMORY . In addition, the`\nbase of this memory operand for both instructions is `RAX . The mnemonic of both`\ninstructions is the same. This sort of minimalist comparison thinking is what this rendition of\nthe profiling algorithm is based off of.\n```\nvm::handler::profile_t readq = {\n  // MOV RAX, [RAX]\n  // MOV [RBP], RAX\n  \"READQ\",\n  READQ,\n  NULL,\n  { { // MOV RAX, [RAX]\n    []( const zydis_decoded_instr_t &instr ) -> bool {\n      return instr.mnemonic == ZYDIS_MNEMONIC_MOV &&\n          instr.operands[ 0 ].type == ZYDIS_OPERAND_TYPE_REGISTER &&\n          instr.operands[ 0 ].reg.value == ZYDIS_REGISTER_RAX &&\n          instr.operands[ 1 ].type == ZYDIS_OPERAND_TYPE_MEMORY &&\n          instr.operands[ 1 ].mem.base == ZYDIS_REGISTER_RAX;\n    },\n    // MOV [RBP], RAX\n    []( const zydis_decoded_instr_t &instr ) -> bool {\n      return instr.mnemonic == ZYDIS_MNEMONIC_MOV && \n           instr.operands[ 0 ].type == ZYDIS_OPERAND_TYPE_MEMORY &&\n          instr.operands[ 0 ].mem.base == ZYDIS_REGISTER_RBP &&\n          instr.operands[ 1 ].type == ZYDIS_OPERAND_TYPE_REGISTER &&\n          instr.operands[ 1 ].reg.value == ZYDIS_REGISTER_RAX;\n    } } } };\n\n```\n\n-----\n\nIn the figure above, the [READQ profile is displayed. Notice that not every single instruction](https://back.engineering/17/05/2021/#READQ)\nfor a virtual machine handler must have a zydis lambda for it. Only enough for a unique\n[profile to be constructed for it. There are in fact additional native instructions for READQ](https://back.engineering/17/05/2021/#READQ)\nwhich are not accounted for with zydis comparison lambdas.\n\n**VMProfiler - Virtual Branch Detection Algorithm**\n\n[The most glaring consistency in a virtual branch is the usage of PUSHVSP. This virtual](https://back.engineering/17/05/2021/#PUSHVSP)\ninstruction is executed when two encrypted values are on the stack at `VSP + 0, and` `VSP`\n```\n+ 8 . These encrypted values are decrypted using the last LCONSTDW value of a given\n\n```\nblock. Thus a trivially small algorithm can be created based upon these two consistencies.\nThe first part of the algorithm will simply use `std::find_if with reverse iterators to locate`\nthe last [LCONSTDW in a given code block. This DWORD value will be interpreted as the](https://back.engineering/17/05/2021/#LCONSTDW)\nXOR key used to decrypt the encrypted relative virtual addresses of both branches. A\nsecond `std::find_if is now executed to locate a PUSHVSP virtual instruction that when`\nexecuted, two encrypted relative virtual addresses will be located on the stack. The algorithm\n[will interpret the top two stack values of every PUSHVSP instruction as encrypted relative](https://back.engineering/17/05/2021/#PUSHVSP)\n[virtual addresses and apply an XOR operation with the last LCONSTDW value.](https://back.engineering/17/05/2021/#LCONSTDW)\n\n\n-----\n\n```\nstd::optional< jcc_data > get_jcc_data( vm::ctx_t &vmctx, code_block_t &code_block )\n{\n  // there is no branch for this as this is a vmexit...\n  if ( code_block.vinstrs.back().mnemonic_t == vm::handler::VMEXIT )\n    return {};\n  // find the last LCONSTDW... the imm value is the JMP xor decrypt key...\n  // we loop backwards here (using rbegin and rend)...\n  auto result = std::find_if( code_block.vinstrs.rbegin(),\ncode_block.vinstrs.rend(),\n                []( const vm::instrs::virt_instr_t &vinstr ) -> bool\n{\n                  auto profile = vm::handler::get_profile(\nvinstr.mnemonic_t );\n                  return profile && profile->mnemonic ==\nvm::handler::LCONSTDW;\n                } );\n  jcc_data jcc;\n  const auto xor_key = static_cast< std::uint32_t >( result->operand.imm.u );\n  const auto &last_trace = code_block.vinstrs.back().trace_data;\n  // since result is already a variable and is a reverse itr\n  // i'm going to be using rbegin and rend here again...\n  //\n  // look for PUSHVSP virtual instructions with two encrypted virtual\n  // instruction rva's ontop of the virtual stack...\n  result = std::find_if(\n    code_block.vinstrs.rbegin(), code_block.vinstrs.rend(),\n    [ & ]( const vm::instrs::virt_instr_t &vinstr ) -> bool {\n      if ( auto profile = vm::handler::get_profile( vinstr.mnemonic_t );\n         profile && profile->mnemonic == vm::handler::PUSHVSP )\n      {\n        const auto possible_block_1 = code_block_addr( vmctx, \n                   vinstr.trace_data.vsp.qword[ 0 ] ^ xor_key ),\n              possible_block_2 = code_block_addr( vmctx, \n            vinstr.trace_data.vsp.qword[ 1 ] ^ xor_key );\n        // if this returns too many false positives we might have to get\n        // our hands dirty and look into trying to emulate each branch\n        // to see if the first instruction is an SREGQ...\n        return possible_block_1 > vmctx.module_base &&\n            possible_block_1 < vmctx.module_base + vmctx.image_size &&\n            possible_block_2 > vmctx.module_base &&\n            possible_block_2 < vmctx.module_base + vmctx.image_size;\n      }\n      return false;\n    } );\n  // if there are not two branches...\n  if ( result == code_block.vinstrs.rend() )\n  {\n    jcc.block_addr[ 0 ] = code_block_addr( vmctx, last_trace );\n    jcc.has_jcc = false;\n    jcc.type = jcc_type::absolute;\n\n```\n\n-----\n\n```\n  }\n  // else there are two branches...\n  else\n  {\n    jcc.block_addr[ 0 ] = code_block_addr( vmctx, \n          result->trace_data.vsp.qword[ 0 ] ^ xor_key );\n    jcc.block_addr[ 1 ] = code_block_addr( vmctx, \n          result->trace_data.vsp.qword[ 1 ] ^ xor_key );\n    jcc.has_jcc = true;\n    jcc.type = jcc_type::branching;\n  }\n  return jcc;\n}\n\n```\n_Note: the underlying flag in which the virtual branch is dependent on is not extracted using_\n_this algorithm. This is one of the negative aspects of this algorithm as it stands._\n\n### VMProfiler Qt - Overview\n\n[VMProfiler Qt is a small C++ Qt based GUI that allows for inspection of virtual instruction](https://githacks.org/vmp2/vmprofiler-qt)\n[traces. These traces are generated via VMEmu and contain all information for every virtual](https://githacks.org/vmp2/vmemu)\ninstruction. The GUI contains a window for virtual register values, native register values, the\nvirtual stack, virtual instructions, expandable virtual branches, and lastly a tab containing all\nvirtual machine handlers and their native instructions and transformations\n\n\n-----\n\n### VMProfiler CLI - Overview\n\n[VMProfiler CLI is a command line project which is used to demonstrate all VMProfiler](https://githacks.org/vmp2/vmprofiler-cli)\n[features. This project only consists of a single file (main.cpp), however it’s a good reference](https://githacks.org/vmp2/vmprofiler-cli/-/blob/93b14609ed8a0ca72fa9a0ac3bd2589703780135/src/main.cpp)\nfor those who are interested in inheriting VMProfiler as their code base.\n```\nUsage: vmprofiler-cli [options...]\nOptions:\n  --bin, --vmpbin    unpacked binary protected with VMProtect 2\n  --vmentry, --entry   rva to push prior to a vm_entry\n  --showhandlers     show all vm handlers...\n  --showhandler     show a specific vm handler given its index...\n  --vmp2file       path to .vmp2 file...\n  --showblockinstrs   show the virtual instructions of a specific code block...\n  --showallblocks    shows all information for all code blocks...\n  --devirt        lift to VTIL IR and apply optimizations, then display the\noutput...\n  -h, --help       Shows this page\n\n### VMEmu - Overview\n\n```\n[VMEmu is a](https://githacks.org/vmp2/vmemu) [unicorn-engine based project which emulates virtual machine handlers to](https://github.com/unicorn-engine/unicorn)\n[subsequently decrypt virtual instruction operands. VMEmu inherits VMProfiler which aids in](https://githacks.org/vmp2/vmemu)\n[determining if a given code block has a virtual JCC in it. VMEmu does not currently support](https://githacks.org/vmp2/vmemu)\ndumped modules as “dumped modules” can take many forms. There is not one standard file\nformat for a dumped module so support for dumped modules will come with another unicornengine based project to produce a standard dump format.\n```\nUsage: vmemu [options...]\nOptions:\n  --vmentry       relative virtual address to a vm entry... (Required)\n  --vmpbin        path to unpacked virtualized binary... (Required)\n  --out         output file name for trace file... (Required)\n  -h, --help       Shows this page\n\n```\n**VMEmu - Unicorn Engine, Static Decryption Of Opcodes**\n\nIn order to statically decrypt virtual instruction operands, one must first understand how these\noperands are encrypted in the first place. The algorithm VMProtect 2 uses to encrypt virtual\ninstruction operands can be represented as a mathematical formula.\n\n$$\\text{Let } F_n \\text{ be an encryption function and } T_{m,F_n} \\text{denote the } m\\text{th\ntransformation of function } F_n:$$ $$F_0(e, o) = T_{4, F_0} \\circ T_{3, F_0}\\circ T_{2, F_0}\n\\circ T_{1, F_0} \\circ T_{0, F_0}(e, o)$$ $$ G_0(e, o) = T_{1, F_0}(F_0(e, o), e) $$\n$$\\text{Thus:}$$ $$\\text{key}_{n+1} = G_n(\\text{key}_n, \\text{operand}_n)$$\n\n\n-----\n\n$$\\text{operand}_{n+1} = F_n(\\text{key}_n, \\text{operand}_n)$$ $$\\text{Furthermore:}$$\n$$T_{m, F_n} \\text{ maps to a given vm::transformation::type such that } T_{0, F_n} = \\text\n{vm::transform::type::generic\\textunderscore0},$$ $$T_{1, F_n} = \\text{\nvm::transform::type::rolling\\textunderscore key }, …, T_{6, F_n} = \\text{\nvm::transform::type::update\\textunderscore key }$$\n\nConsidering the above figure, decryption of operands is merely the inverse of function $F$.\nThis inverse is generated into native x86_64 instructions and embedded into each virtual\nmachine handler as well as calc_jmp. One could simply emulate these instructions via\nreimplementation of them in C/C++, however my implementation of such instructions is\n[merely for the purpose of encryption, not decryption. Instead, the usage of unicorn-engine is](https://github.com/unicorn-engine/unicorn)\npreferred in this situation as by simply emulating these virtual machine handlers, decrypted\noperands will be produced.\n\nUnderstand that no runtime value can possibly affect the decryption of operands, thus invalid\nmemory accesses can be ignored. However, runtime values can alter which virtual\ninstruction blocks are decrypted, thus the need for saving the context of the emulated CPU\nprior to execution of a branching virtual instruction. This will allow for restoring the state of\nthe emulated CPU prior to the branching instruction, but additionally altering which branch\nthe emulated CPU will take, allowing for complete decryption of all virtual instruction blocks\nstatically.\n\nTo reiterate, the usage of unicorn-engine is for computing $F(e, o)$ and $G(e, o)$ where $e$\ntakes the form of the native register $RBX$, $o$ takes the form of the native register $RAX$,\nand $T_{m, F_n}$ takes the form of transformation $m$th.\n\nIn addition, not only can decrypted operands be obtained using unicorn-engine, but views of\nthe virtual stack can be snapshotted for every single virtual instruction. This allows for\nalgorithms to take advantage of values that are on the stack. Calls to native WinAPI’s are\ndone outside of the virtual machine, except for rare cases such as the VMProtect 2 packer\nvirtual machine handler which calls `LoadLibrary with a pointer to the string “NTDLL.DLL”`\nin `RCX .`\n\n**VMEmu - Virtual Branching**\n\nSeeing all code paths is extremely important. Consider the most basic situation where a\nparameter is checked to see if it’s a nullptr.\n```\nauto demo(int* a)\n{\n  if (!a)\n    return {};\n  // more code down here\n}\n\n```\n\n-----\n\nAnalysis of the above code without being able to see all code paths would result in\nsomething useless. Thus seeing all branches inside of the virtual machine was the top\npriority. In this section I will detail how virtual branching works inside of the VMProtect 2\nvirtual machine, as well as the algorithms I’ve designed to recognize and analyze all paths.\n\nTo begin, not all code blocks end with a branching virtual instruction. Some end with virtual\nmachine exit’s, or absolute jumps. Thus the need for an algorithm which can determine if a\ngiven virtual instruction block will branch or not. In order to produce such an algorithm,\nintimate knowledge of the virtual machine branching mechanism is required, specifically how\n[native JCC’s are translated to virtual instructions.](https://www.felixcloutier.com/x86/jcc)\n\nConsider the possible affected flag bits of the [native ADD instruction. Flags](https://www.felixcloutier.com/x86/add) `OF,` `SF,` `ZF,`\n```\nAF, CF, and PF can all be affected depending on the computation. Native branching is\n\n```\n[done via JCC instructions which depend upon the state of a specific flag or flags.](https://www.felixcloutier.com/x86/jcc)\n```\ntest rax, rax\njz branch_1\n\n```\n_Figure 2._\n\nConsider figure 2, understand that the `JZ native instruction will jump to “branch_1” if the`\n```\nZF flag is set. One could reimplement figure 2 in such a way that only the native JMP\n\n```\ninstruction and a few other math and stack operations could be used. Reducing the number\n[of branching instructions to a single native JMP instruction.](https://www.felixcloutier.com/x86/jmp)\n\n[Consider that the native TEST instruction performs a bitwise](https://www.felixcloutier.com/x86/test) `AND on both operands, sets`\nflags accordingly, and disregards the `AND result. One could simply replace the native TEST`\n[instruction with a few stack operations and the native AND instruction.](https://www.felixcloutier.com/x86/and)\n```\n0: 50           push  rax\n1: 48 21 c0        and  rax,rax\n4: 9c           pushf\n5: 48 83 24 24 40     and  QWORD PTR [rsp],0x40\na: 48 c1 2c 24 03     shr  QWORD PTR [rsp],0x3\nf: 58           pop  rax\n10: ff 34 25 00 00 00 00  push  branch_1\n17: ff 34 25 00 00 00 00  push  branch_2\n1e: 48 8b 04 04       mov  rax,QWORD PTR [rsp+rax*1]\n22: 48 83 c4 10       add  rsp,0x10\n26: 48 89 44 24 f8     mov  QWORD PTR [rsp-0x8],rax\n2b: 58           pop  rax\n2c: ff 64 24 f0       jmp  QWORD PTR [rsp-0x10]\n\n```\n_Figure 3._ _Note: bittest/test is not used here as it is implemented via AND, and SHR._\n\nAlthough it may seem that converting a single instruction into multiple may be\ncounterproductive and requiring more work in the end, this is not the case as these\ninstructions will be reused in other orientations. Reimplementation of all JCC instructions\n\n\n-----\n\ncould be done quite simply using the above assembly code template. Even such branching\ninstructions as the `JRCXZ,` `JECXZ, and` `JCXZ instructions could be implemented by`\nsimply swapping `RAX with` `RCX / EAX / CX in the above example.`\n\nFigure 3, although in native x86_64, provides a solid example of how VMProtect 2 does\nbranching inside of the virtual machine. However, VMProtect 2 adds additional obfuscation\nvia math obfuscation. Firstly, both addresses pushed onto the stack are encrypted relative\nvirtual addresses. These addresses are decrypted via XOR. Although XOR, SUB, and other\nmath operations themselves are obfuscated into NAND operations.\n\n\n-----\n\n```\n; push encrypted relative virtual addresses onto the stack...\nLCONSTQ 0x19edc194\nLCONSTQ 0x19ed8382\nPUSHVSP\n; calculate which branch will be executed, then read its encrypted address on the\nstack...\nLCONSTBZXW 0x3\nLCONSTBSXQ 0xbf\nLREGQ 0x80\nNANDQ\nSREGQ 0x68\nSHRQ\nSREGQ 0x70\nADDQ\nSREGQ 0x48\nREADQ\n; clear the stack of encrypted addresses...\nSREGQ 0x68\nSREGQ 0x70\nSREGQ 0x90\n; put the selected branch encrypted address back onto the stack...\nLREGQ 0x68\nLREGQ 0x68\n; xor value on top of the stack with 59f6cb36\nLCONSTDW 0xa60934c9\nNANDDW\nSREGQ 0x48\nLCONSTDW 0x59f6cb36\nLREGDW 0x68\nNANDDW\nSREGQ 0x48\nNANDDW\nSREGQ 0x90\nSREGQ 0x70\n; removed virtual instructions...\n; …\n; load the decrypted relative virtual address and jmp...\nLREGQ 0x70\nJMP\n\n```\n_Figure 4._\n\nAs discussed prior, VMProtect 2 uses the XOR operation to decrypt and subsequently\nencrypt the relative virtual addresses pushed onto the stack. Selection of a specific\nencrypted relative virtual address is done by shifting a given flag to result in its value being\neither zero or eight. Then, adding `VSP to the resulting shift computes the address in which`\nthe encrypted relative virtual address is located.\n\n\n-----\n\n```\n#define FIRST_CONSTANT a60934c9\n#define SECOND_CONSTANT 59f6cb36\nunsigned int jcc_decrypt(unsigned int encrypted_rva)\n{\n  unsigned int result = ~encrypted_rva & ~encrypted_rva;\n  result = ~result & ~FIRST_CONSTANT;\n  result = ~(~encrypted_rva & ~SECOND_CONSTANT) & ~result;\n  return result;\n}\n\n```\n_Figure 5. Note: Notice that_ `FIRST_CONSTANT and` `SECOND_CONSTANT are inverses of each`\n_other._\n\n### VMAssembler - Overview\n\n[VMAssembler is a virtual instruction assembler project originally contemplated as a joke.](https://githacks.org/vmp2/vmassembler)\nRegardless of its significance to anything, it is a fun project that allows for an individual to\n[become more acquainted with the features of VMProtect 2. VMAssembler uses](https://githacks.org/vmp2/vmassembler) [LEX and](https://en.wikipedia.org/wiki/Lex_(software))\n[YACC to parse text files for labels and virtual instruction tokens. It then encodes and](https://en.wikipedia.org/wiki/Yacc)\nencrypts these virtual instructions based upon the specific virtual machine specified via the\ncommand line. Finally a C++ header file is generated which contains the assembled virtual\ninstructions as well as the original VMProtect’ed binary.\n\n**VMAssembler - Assembler Stages**\n\n[VMAssembler uses](https://githacks.org/vmp2/vmassembler) [LEX and](https://en.wikipedia.org/wiki/Lex_(software)) [YACC to parse text files for virtual instruction names and](https://en.wikipedia.org/wiki/Yacc)\nimmediate values. There are four main stages to VMAssembler, lexical analysis and parsing,\nvirtual instruction encoding, virtual instruction encryption, and lastly C++ code generation.\n\n**VMAssembler - Stage One, Lexical Analysis and Parsing**\n\n\n-----\n\nLexical analysis and token parsing are two stages themselves, however I will be referring to\nthese stages as one as the result of these is data structures manageable by C++.\n\n[The first stage of VMAssembler is almost entirely handled by LEX and](https://en.wikipedia.org/wiki/Lex_(software)) [YACC. Text is](https://en.wikipedia.org/wiki/Yacc)\nconverted into C++ structures representing virtual instructions. These structures are referred\nto as [_vinstr_meta and](https://docs.back.engineering/vmassembler/struct__vinstr__meta.html) [_vlable_meta. These structures are then used by stage two to](https://docs.back.engineering/vmassembler/struct__vlabel__meta.html)\nvalidate virtual instructions existence, as well as encoding these higher level representations\nof virtual instructions into decrypted virtual operands.\n\n**VMAssembler - Stage Two, Virtual Instruction Encoding**\n\n\n-----\n\nVirtual instruction encoding stage of assembling also validates the existence of all virtual\ninstructions for each virtual label. This is done by comparing profiled vm handler names with\nthe virtual instruction name token. If a virtual instruction does not exist then assembling will\ncease.\n\n\n-----\n\n```\nif ( !parse_t::get_instance() >for_each( [ & ]( _vlabel_meta label_data ) > bool {\n     std::printf( \"> checking label %s for invalid instructions... number of\ninstructions = %d\\n\",\n           label_data->label_name.c_str(), label_data->vinstrs.size() );\n     const auto result = std::find_if(\n       label_data->vinstrs.begin(), label_data->vinstrs.end(),\n       [ & ]( const _vinstr_meta &vinstr ) -> bool {\n         std::printf( \"> vinstr name = %s, has imm = %d, imm = 0x%p\\n\",\nvinstr.name.c_str(),\n               vinstr.has_imm, vinstr.imm );\n         for ( auto &vm_handler : vmctx->vm_handlers )\n           if ( vm_handler.profile && vm_handler.profile->name ==\nvinstr.name )\n             return false;\n         std::printf( \"[!] this vm protected file does not have the vm\nhandler for: %s...\\n\",\n               vinstr.name.c_str() );\n         return true;\n       } );\n     return result == label_data->vinstrs.end();\n   } ) )\n{\n  std::printf( \"[!] binary does not have the required vm handlers...\\n\" );\n  exit( -1 );\n}\n\n```\nOnce all virtual instruction IL is validated, encoding of these virtual instructions can\ncommence. The order in which the virtual instruction pointer advances is important to note\nthroughout the process of encoding and encrypting. The direction dictates the ordering of\noperands and virtual instructions.\n\n**VMAssembler - Stage Three, Virtual Instruction Encryption**\n\n\n-----\n\nJust like stage two of assembly, stage three must also take into consideration which way the\nvirtual instruction pointer advances. This is because operands must be encrypted in an order\nbased upon the direction of VIP’s advancement. The encryption key produced by the last\noperands encryption is used for the starting encryption key for the next as detailed in\n“VMEmu - Unicorn Engine, Static Decryption Of Opcodes”.\n\nThis stage will do $F^{-1}(e, o)$ and $G^{-1}(e, o)$ for each virtual instruction operand of\neach label. Lastly, the relative virtual address from vm_entry to the first operand of the first\nvirtual instruction is calculated and then encrypted using the inverse transformations used to\ndecrypt the relative virtual address to the virtual instructions themselves. You can find more\n[details about these transformations inside of the vm_entry section of the last article.](https://back.engineering/17/05/2021/#vm_entry)\n\n**VMAssembler - Stage Four, C++ Header Generation**\n\n\n-----\n\nStage four is the final stage of virtual instruction assembly. In this stage C++ code is\ngenerated. The code is completely self contained and environment agnostic. However, there\nare a few limitations to the current implementation. Most glaring is the need for a RWX (read,\nwrite, and executable) section. If one were to use this generated C++ code in a Windows\nkernel driver then the driver would not support HVCI systems. Also, as of 6/19/2021, MSVC\ncannot compile the generated header as for whatever reason, the static initializer for the raw\nmodule causes the compiler to hang. You must use clang-cl if you want to compile with the\ngenerated header file from VMAssembler.\n\n**VMAssembler - Example**\n\n[Once a C++ header has been generated using VMAssembler you can now include it into](https://githacks.org/vmp2/vmassembler)\nyour project and compile using any compiler that is not MSVC as the MSVC compiler for\nsome reason cannot handle such a large static initializer which the protected binary is\ncontained in, clang-cl handles it however. Each label that you define will be inserted into the\n```\nvm::calls enum. The value for each enum entry is the encrypted relative virtual address\n\n```\nto the virtual instructions of the label.\n\n\n-----\n\n```\nnamespace vm\n{\n     enum class calls : u32\n     {\n          get_hello = 0xbffd6fa5,\n          get_world = 0xbffd6f49,\n     };\n     //\n     // ...\n     //\n  template < calls e_call, class T, class... Ts > auto call( const Ts... args ) ->\nT\n  {\n    static auto __init_result = gen_data.init();\n    __vmcall_t vmcall = nullptr;\n    for ( auto idx = 0u; idx < sizeof( call_map ) / sizeof( _pair_t< u8, calls >\n); ++idx )\n      if ( call_map[ idx ].second == e_call )\n        vmcall = reinterpret_cast< __vmcall_t >(\n&gen_data.__vmcall_shell_code[ idx ] );\n    return reinterpret_cast< T >( vmcall( args... ) );\n  }\n}\n\n```\nYou can now call any label from your C++ code by simply specifying the `vm::calls enum`\nentry and the labels return type as templated params.\n```\n#include <iostream>\n#include \"test.hpp\"\nint main()\n{\n     const auto hello = vm::call< vm::calls::get_hello, vm::u64 >();\n  const auto world = vm::call< vm::calls::get_world, vm::u64 >();\n     std::printf( \"> %s %s\\n\", ( char * )&hello, (char*)&world );\n}\n\n```\n_Output_\n```\n> hello world\n\n## VTIL - Getting Started\n\n```\n[The VTIL project as it currently stands on github has some untold requirements and](https://github.com/vtil-project/VTIL-Core)\n[dependencies which are not submoduled. I have created a fork of VTIL which submodule’s](https://githacks.org/_xeroxz/vtil/)\nkeystone and capstone, as well as describes the Visual Studios configurations that must be\napplied to a project which inherits VTIL. VTIL uses C++ 2020 features such as the `concept`\n\n\n-----\n\nkeyword, thus the latest Visual Studios (2019) must be used, vs2017 is not supported. If you\nare compiling on a non-windows/non-visual studios environment you can ignore the last\nsentence.\n```\ngit clone --recursive https://githacks.org/_xeroxz/vtil.git\n\n```\n_Note: maybe this will become a branch in VTIL-Core, if so, you should refer to the official_\n_VTIL-Core repository if/when that happens._\n\nAnother requirement to compile VTIL is that you must define the `NOMINMAX macro prior to`\n[any inclusion of Windows.h as std::numeric_limits has static member functions (max, and](http://www.cplusplus.com/reference/limits/numeric_limits/)\nmin). These static member function names are treated as min/max macros and thus cause\ncompilation errors.\n```\n#define NOMAXMIN\n#include <Windows.h>\n\n```\nThe last requirement has to do with dynamic initializers causing stack overflows. In order for\nyour compiled executable containing VTIL to not crash instantly you must increase the initial\nstack size. I set mine to 4MB just for precaution as I have a large amount of dynamic\ninitializers in VMProfiler.\n```\nLinker->System->Stack Reserve Size/Stack Commit Size, set both to 4194304\n\n### VTIL - The Basic Block\n\n```\n[vtil::optimizer::apply_all operates on the](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Compiler/common/apply_all.hpp#L133) [vtil::basic_block object which can be constructed by](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L61)\n[calling vtil::basic_block::begin. A](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L285) [vtil::basic_block contains a list of VTIL instructions which](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L61)\n[ends with a branching instruction or a vexit. To add a new basic block linking to existing basic](https://docs.vtil.org/instruction-set/control-flow/vexit)\n[block’s you can call vtil::basic_block::fork.](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L290)\n\n\n-----\n\n```\n// Creates a new block connected to this block at the given vip, if already explored\nreturns nullptr,\n// should still be called if the caller knowns it is explored since this function\ncreates the linkage.\n//\nbasic_block* basic_block::fork( vip_t entry_vip )\n{\n  // Block cannot be forked before a branching instruction is hit.\n  //\n  fassert( is_complete() );\n  // Caller must provide a valid virtual instruction pointer.\n  //\n  fassert( entry_vip != invalid_vip );\n  // Invoke create block.\n  //\n  auto [blk, inserted] = owner->create_block( entry_vip, this );\n  return inserted ? blk : nullptr;\n}\n\n```\n_Note:_ `vtil::basic_block::fork will assert is_complete so ensure that your basic blocks`\n_end with a branching instruction prior to forking._\n\nOnce a basic block has been created, one can start appending VTIL instructions\n[documented at https://docs.vtil.org/ to the basic block object. For every defined VTIL](https://docs.vtil.org/)\ninstruction a templated function is created using the “WRAP_LAZY” macro. You can now\n“emplace_back” any VTIL instruction with ease in your virtual machine handler lifters.\n\n\n-----\n\n```\n    // Generate lazy wrappers for every instruction.\n    //\n#define WRAP_LAZY(x)                           \\\n    template<typename... Tx>                     \\\n    basic_block* x( Tx&&... operands )                \\\n    {                                \\\n      emplace_back( &ins:: x, std::forward<Tx>( operands )... );  \\\n      return this;                         \\\n    }\n    WRAP_LAZY( mov );  WRAP_LAZY( movsx );  WRAP_LAZY( str );  WRAP_LAZY(\nldd );\n    WRAP_LAZY( ifs );  WRAP_LAZY( neg );   WRAP_LAZY( add );  WRAP_LAZY(\nsub );\n    WRAP_LAZY( div );  WRAP_LAZY( idiv );   WRAP_LAZY( mul );  WRAP_LAZY(\nimul );\n    WRAP_LAZY( mulhi ); WRAP_LAZY( imulhi );  WRAP_LAZY( rem );  WRAP_LAZY(\nirem );\n    WRAP_LAZY( popcnt ); WRAP_LAZY( bsf );   WRAP_LAZY( bsr );  WRAP_LAZY(\nbnot );  \n    WRAP_LAZY( bshr );  WRAP_LAZY( bshl );   WRAP_LAZY( bxor );  WRAP_LAZY(\nbor );  \n    WRAP_LAZY( band );  WRAP_LAZY( bror );   WRAP_LAZY( brol );  WRAP_LAZY(\ntg );   \n    WRAP_LAZY( tge );  WRAP_LAZY( te );    WRAP_LAZY( tne );  WRAP_LAZY(\ntle );  \n    WRAP_LAZY( tl );   WRAP_LAZY( tug );   WRAP_LAZY( tuge );  WRAP_LAZY(\ntule );  \n    WRAP_LAZY( tul );  WRAP_LAZY( js );    WRAP_LAZY( jmp );  WRAP_LAZY(\nvexit ); \n    WRAP_LAZY( vemit ); WRAP_LAZY( vxcall );  WRAP_LAZY( nop );  WRAP_LAZY(\nsfence );\n    WRAP_LAZY( lfence ); WRAP_LAZY( vpinr );  WRAP_LAZY( vpinw ); WRAP_LAZY(\nvpinrm );  \n    WRAP_LAZY( vpinwm );\n#undef WRAP_LAZY\n\n### VTIL - VMProfiler Lifting\n\n```\n[Take an example for the virtual machine handler lifter LCONSTQ. The lifter simply adds a](https://back.engineering/17/05/2021/#LCONSTQ)\nVTIL push instruction which pushes a 64bit value onto the stack. Note the usage of\n[vtil::operand to create a 64bit immediate value operand.](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/arch/operands.hpp#L40)\n```\nvm::lifters::lifter_t lconstq = {\n  // push imm<N>\n  vm::handler::LCONSTQ,\n  []( vtil::basic_block *blk, vm::instrs::virt_instr_t *vinstr,\nvmp2::v3::code_block_t *code_blk ) {\n    blk->push( vtil::operand( vinstr->operand.imm.u, 64 ) );\n  } };\n\n```\n\n-----\n\nVMProfiler simply loops over all virtual instructions for a given block and applies lifters. Once\n[all code blocks are exhausted, vtil::optimizer::apply_all is called. This is the climax of VTIL](https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Compiler/common/apply_all.hpp#L133)\ncurrently as some of these optimization passes are targeted toward stack machined based\nobfuscation. The purpose of submodeling VTIL in vmprofiler is for these optimizations as\nprogramming these myself would take months of research. Compiler optimization is a field of\nits own, interesting, but not something I have the time to pursue at the moment so VTIL will\nsuffice.\n\n## Conclusion - Final Words and Future Work\n\nAlthough I have done much work on VMProtect 2, the main success of my endeavors has\ntruly been statically uncovering all virtual branches and producing a legible IL. Additionally\n[doing all of this in a, well documented,](https://docs.back.engineering/vmprofiler/) [open source, C++ library which can be inherited](https://githacks.org/vmp2/vmprofiler)\nfurther by other researchers. I would not consider the work I’ve done anything close to a\n“finished product” or something that could be presented as such, it is merely a step in the\nright direction for devirtualization. The last word of the last sentence leads me to my next\npoint.\n\nDevirtualization has been avoided throughout all of my documentation and articles pertaining\nto my VMProtect 2 work as to me this is something that has always been out of the scope of\nthe project. Considering I’m a lone researcher, there are many aspects to the virtual machine\narchitecture which could not be tackled by a single individual in a meaningful amount of time.\nFor example, when an instruction is not virtualized by VMProtect 2, a vmexit happens and\nthe original instruction is executed outside of the virtual machine. This means if I wanted to\nsee an ENTIRE routine it would require me to follow code execution back out of the virtual\nmachine and thus VMEmu would need many more months of development to support such a\nthing. The way that I have programmed these projects allows for multiple engineers working\non the code base at a given time, except there seems to be little to no interest in open\nsource development of these tools, even with such detailed documentation everyone wants\nto “make their own solution”, which is understandable, but not productive in the long run.\n\nAdditionally, devirtualization requires converting back to native x86_64. In order to do this,\nevery single virtual machine handler must be profiled, every single virtual machine handler\nmust have a VTIL lifter defined for it, and every single VTIL instruction must be mapped to a\nnative instruction. At least this is what seems to be required with the level of knowledge I\ncurrently have, there may well be a much more elegant way of going about this that I am\nsimply oblivious to at this time. Thus my conclusion to devirtualization: it is not a job for a\nsingle person, thus the goal of my project(s) has never been devirtualization, it’s always been\nan IL view of the virtual instructions with VTIL providing deobfuscation pseudo code. The IL\nalone is enough for a dedicated individual to begin research, the VTIL pseudo code makes it\n\n\n-----\n\neasier for the rest of us. VMProfiler Qt combined with IDA Pro as it currently exists can be\nused to analyze binaries protected with VMProtect 2. It may not be a beginner friendly\nsolution, but in my opinion, it will suffice.\n\nI must note that it is not a far stretch of the mind to assume private entities have well rounded\nsolutions for VMProtect 2. I can imagine what a team of individuals, much more skilled than\nmyself, working on devirtualization day in and day out would produce. On top of this,\nconsidering the length of time VMProtect 2 has been public, there has been ample time for\nthese private entities to create such tools.\n\n### Conclusion - Future Work\n\nLastly, during my research of VMProtect 2, there has been a subtle urge to reimplement\nsome of the obfuscation and virtual machine features myself in an open source manner to\nbetter convey the features of VMProtect 2. However, after much thought, it would be more\nproductive to create an obfuscation framework that would allow for these ideas to be created\nwith relative ease. A framework that would handle code analysis as well as file format\nparsing, deconstruction, and reconstruction. Something that is lower level than an LLVM\noptimization pass, but high enough level that a programmer using this framework would only\nneed to write the obfuscation algorithms themselves and would not have to even know the\nunderlying file format. This framework would only support a single ISA, which would be x86.\n[The details beyond this point are still being contemplated at: https://githacks.org/llo/](https://githacks.org/llo/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-21 - VMProtect 2 - Part Two, Complete Static Analysis.pdf"
    ],
    "report_names": [
        "2021-06-21 - VMProtect 2 - Part Two, Complete Static Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535714,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1653788018,
    "ts_modification_date": 1653788018,
    "files": {
        "pdf": "https://archive.orkl.eu/897179d8b1749d9d3ddadc211488bfe67442f0e9.pdf",
        "text": "https://archive.orkl.eu/897179d8b1749d9d3ddadc211488bfe67442f0e9.txt",
        "img": "https://archive.orkl.eu/897179d8b1749d9d3ddadc211488bfe67442f0e9.jpg"
    }
}