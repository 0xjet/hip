{
    "id": "2f6978c8-1ea6-478d-bcd3-6b2b95fb89d1",
    "created_at": "2023-01-12T15:09:56.817076Z",
    "updated_at": "2025-03-27T02:09:29.423823Z",
    "deleted_at": null,
    "sha1_hash": "8f3eb142790cc7e4f88f134339fe50dfe3c543bd",
    "title": "2020-02-06 - Living off another land- Ransomware borrows vulnerable driver to remove security software",
    "authors": "",
    "file_creation_date": "2022-05-27T21:51:20Z",
    "file_modification_date": "2022-05-27T21:51:20Z",
    "file_size": 922938,
    "plain_text": "# Living off another land: Ransomware borrows vulnerable driver to remove security software\n\n**news.sophos.com/en-us/2020/02/06/living-off-another-land-ransomware-borrows-vulnerable-driver-to-remove-security-**\nsoftware/\n\nFebruary 6, 2020\n\nSophos has been investigating two different ransomware attacks where the adversaries\ndeployed a legitimate, digitally signed hardware driver in order to delete security products\nfrom the targeted computers just prior to performing the destructive file encryption portion of\nthe attack.\n\nThe signed driver, part of a now-deprecated software package published by Taiwan-based\nmotherboard manufacturer Gigabyte, has a known vulnerability, tracked as CVE-201819320. The vulnerability, [published along with proof-of-concept code in 2018 and](https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities) widely\nreported at the time, was disclaimed by the company, who told the researcher who tried to\nreport the bug that “its products are not affected by the reported vulnerabilities.” The\ncompany later recanted, and has discontinued using the vulnerable driver, but it still exists,\nand it apparently remains a threat.\n\n\n-----\n\nThe sha1RSA Authenticode signature for the driver, with serial number\n**248472542c24ab8e429229acf121ca26 and thumbprint**\n**32daee48ae406222c2bb92c4f1b7f516e537175a, expired on October 17, 2013.**\n\nIn this attack scenario, the criminals have used the Gigabyte driver as a wedge so they could\nload a second, unsigned driver into Windows. This second driver then goes to great lengths\nto kill processes and files belonging to endpoint security products, bypassing tamper\nprotection, to enable the ransomware to attack without interference.\n\n\n-----\n\nThis is the first time we have observed ransomware shipping a trusted, signed (yet\nvulnerable) third party driver to patch the Windows kernel in-memory, load their own\nunsigned malicious driver, and take out security applications from kernel space. The\nransomware that was being installed in both instances calls itself RobbinHood.\n\nRansomware trying to circumvent security products is not new. For example, Nemty kills\nprocesses and services using regular taskkill, and Snatch ransomware figured out how to\n[reboot PCs into Safe Mode to get around endpoint protection. Obviously, doing the process](https://news.sophos.com/en-us/2019/12/09/snatch-ransomware-reboots-pcs-into-safe-mode-to-bypass-protection/)\nkilling from kernel mode has a lot of advantages.\n\nThis article takes a deep dive on how the attackers do it. We’re publishing this information\nnow so other defenders can anticipate and enact defenses against this novel attack, where\nadversaries bring a vulnerable third party driver to subvert the Windows kernel, terminate\ndefenses, and encrypt files unhindered by endpoint protection software.\n\n## Attacking Windows defenses\n\n\n-----\n\nWe ve recently seen the RobbinHood ransomware family perform this strategy to encrypt\nfiles without being hindered by endpoint protection software. They successfully subvert a\nsetting in kernel memory on Windows 7, Windows 8 and Windows 10.\n\nWithout diving into the ransomware or data encryption itself, we’re going to focus on the\nmodule with which the adversaries can kill encountered endpoint protection software. This\npart of the attack consists of several files embedded in STEEL.EXE. All of these files are\nextracted to C:\\WINDOWS\\TEMP\n\nSTEEL.EXE Kill application This is the application that kills the processes and files of\nsecurity products, using kernel drivers.\n\nROBNR.EXE Driver installer Deploys both the benign, signed third-party driver, and\nthe criminals’ unsigned kernel driver. Once deployed, the\nunsigned driver gets loaded by abusing a known\nvulnerability in the third-party driver.\n\n\nGDRV.SYS Vulnerable\nkernel driver\n\nRBNL.SYS Malicious\nkernel driver\n\nPLIST.TXT List of\nprocesses\n(and their\nassociated\nfiles) to\ndestroy\n\n### STEEL.EXE\n\n\nA benign but outdated Authenticode-signed driver that\ncontains a vulnerability.\n\nThe malicious driver that can kill processes and delete\nfiles from kernel space.\n\nThis is a text file containing the names of the applications\nthe malicious driver will kill and delete. This text file is not\nembedded in STEEL.EXE and may be tailored to the\nvictim’s environment.\n\n\nThe STEEL.EXE application kills the processes and deletes the files of security applications.\nIn order to do this, STEEL.EXE deploys a driver. The driver runs in kernel mode and is\ntherefore optimally positioned to take out processes and files without being hindered by\nsecurity controls like endpoint protection. Even though they run under NT\nAUTHORITY/SYSTEM, most parts of an endpoint security product run in user space.\n\nThe STEEL.EXE application first deploys ROBNR.EXE, which installs the malicious\nunsigned driver RBNL.SYS.\n\nOnce this driver is installed, STEEL.EXE reads the PLIST.TXT file and instructs the driver to\ndelete any application listed in PLIST.TXT, then killing their associated processes. If the\nprocess was running as a service, the service can no longer automatically restart as the\nassociated file has been deleted.\n\n\n-----\n\nOnce the STEEL.EXE process exits, the ransomware program can perform its encryption\nattack without being hindered by the security applications that have been taken out\ndecisively.\n\n### ROBNR.EXE\n\nThis application is dropped to the disk by STEEL.EXE. This is a convenient application that\ndrops and installs both the vulnerable GDRV.SYS driver, and the malicious RBNL.SYS\ndriver.\n\n64-bit Windows computers have a mechanism called driver signature enforcement which\nmeans that Windows only allows drivers to be loaded that have been properly signed by both\nthe manufacturer and Microsoft. This is a requirement for all drivers in order to be loaded on\n64-bit versions of Windows.\n\nThe malware authors did not bother to sign their malicious driver as it involves purchasing a\ncertificate. Also, a purchased certificate can be revoked by the certificate authority causing\nthe driver to no longer work, as it will no longer be accepted by Windows.\n\nInstead, the malware authors chose a different route. The properly signed third party\nGDRV.SYS driver contains a privilege escalation vulnerability as it allows reading and writing\nof arbitrary memory. The malware authors abuse this vulnerability in order to (temporarily)\ndisable driver signature enforcement in Windows – on-the-fly, in kernel memory. Once driver\nsignature enforcement is disabled, the attackers are able to load their unsigned malicious\ndriver.\n\n### Disabling Driver Signature Enforcement\n\nThe attackers are able to disable driver signature enforcement by changing a single variable\n(a single byte) that lives in kernel space. On Windows 7 (or older), this variable is called\n**nt!g_CiEnabled (NTOSKRNL.EXE). On Windows 8 and 10, this variable is called**\n**ci!g_CiOptions (CI.DLL). In order to resolve the location of this variable, the attackers use a**\nstrategy taken from DSEFix.\n\nOn Windows 8 or 10, the trick starts by loading the standard Windows component CI.DLL as\na data library using DONT_RESOLVE_DLL_REFERENCES in their process. Once CI.DLL is\nloaded, they query the location of CI.DLL in kernel memory via the GetModuleBaseByName\nfunction. It uses NtQuerySystemInformation(SystemModuleInformation …) to get the\nkernel addresses of all loaded kernel modules.\n\n\n-----\n\n-----\n\nDecompiled: Showing how the variable is found that controls Driver Signing Enforcement.\n\nDecompiled: Showing how to get a module’s kernel address.\nOnce they know those kernel addresses, the attackers resolve the exported CiInitialize\nfunction from the module’s export address table.Then they disassemble the instructions of\nthat function in order to find the call CipInitialize() instruction. Once that function is found,\nthey look for the mov dword ptr [address],ecx instruction. That address is g_CiOptions as\nshown in the figure below.\n\n\n-----\n\nDecompiled: Showing how to find the location of g_CiOptions using the HDE disassembler.\n\n\n-----\n\nNow that they know the location of the g_CiOptions variable in kernel space, the vulnerable\n[third party driver is dropped to disk and started. See this article on the exact vulnerability.](https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities)\nAny vulnerable driver that allows arbitrary read/write in kernel will do. So even though the\nattackers are using the GDRV.SYS driver to do this today, there’s no reason they will\ncontinue to use it if it becomes untenable to do so.\n\nThere are many other vulnerable drivers (with a similar vulnerability) in addition to the\nGigabyte driver that these or other attackers may choose to abuse later, such as ones from\nVirtualBox (CVE-2008-3431), Novell (CVE-2013-3956), CPU-Z (CVE-2017-15302), or ASUS\n(CVE-2018-18537). But in these attacks, we’ve only seen the Gigabyte driver being abused\nin this way.\n\nDecompiled: Showing how the malicious driver is deployed.\n\n## The malicious driver\n\nOnce the malicious driver is successfully deployed and started, the ROBNR.EXE process\nexits. Then STEEL.EXE starts processing the PLIST.TXT file, listing all the applications to\nkill.\n\nThis malicious kernel driver is used to terminate processes and delete the associated files. It\nemploys several tricks to kill these applications, even when they are in-use and protected by\ntamper protection mechanisms employed by security products.\n\n\n-----\n\nDecompiled: How the malicious driver starts.\n\n\n-----\n\nDecompiled:\n\nHow the malicious driver processes commands (IOCTL) from STEEL.EXE.\nThe following string was found in the malicious driver, indicating it was likely built by the\nsame authors behind the RobbinHood ransomware.\n```\nC:\\Users\\Mikhail\\Desktop\\Robnhold\\x64\\Win7Release\\Robbnhold.pdb\n\n## Deleting Files\n\n```\nThe malicious driver has various ways to delete files. But it does not pick one way, it runs\nthem all sequentially, in order to ensure the file really gets deleted.\n\nTo delete files that are in-use the malicious driver issues an I/O Request Packet (or IRP, a\n[low-level message passed between device drivers) directly on the NTFS.SYS storage](https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/i-o-request-packets)\ndevice. By clearing the ImageSectionObject and DataSectionObject pointers, the storage\ndevice assumes the files are not in-use and the file is safely deleted, even when the file is\nstill running as a process!\n\n[This trick is similar to the technique mentioned on this blog post.](http://0tutorials.blogspot.com/2011/10/learn-to-force-delete-running-file.html)\n\n\n-----\n\nDecompiled: The malicious driver\n\n\nuses multiple ways to delete a file.\n\n\n-----\n\nDecompiled: How the malicious driver deletes a file that is in-use.\n\n## Terminating Processes\n\nOnce the files are deleted, STEEL.EXE kills all the processes associated with the files.\nAgain, it uses its malicious kernel driver to terminate the processes.\n\n\n-----\n\nDecompile: How the malicious driver terminates a process.\n[Endpoint protection processes that rely on object handle filtering for their tamper protection](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_operation_registration)\ncannot prevent a kernel mode termination of processes or deletion of files. The process\nhandles opened by the malicious driver are kernel handles, and kernel handles cannot be\nfiltered. So, the malicious kernel driver can kill these processes without interference of\nendpoint security controls. One solution is for the endpoint protection process to watch for\nany process trying to install these vulnerable kernel mode drivers, and prevent the\ninstallation from taking place.\n\nIf the process was running as a service, the Service Control Manager of Windows will\n(usually) try to restart the process that just got killed. But it will fail to do so as the related file\nno longer exists. Consequently, the application is effectively and permanently disabled. The\nfailed attempts to restart the service show up in Event Logs.\n\nWhen STEEL.EXE has killed all the processes and files in the PLIST.TXT list, it exits. Now\nthe ransomware can encrypt all the files on the system unhindered.\n\n## What users can do to prevent this type of attack\n\nComputers that are fully patched and have no known vulnerabilities can still end up in ruin\nbecause this attacker brings his own vulnerability. So what can you do to prevent the initial\naccess by the attacker?\n\nAdopt a three-pronged approach to minimize your risk of falling victim to an attack.\n\n### 1. Threat protection that disrupts the whole attack chain\n\nToday’s ransomware attacks use multiple techniques and tactics, so focusing your defense\non a single technology leaves you very vulnerable.\n\nInstead, deploy a range of technologies to disrupt as many stages in the attack as possible.\nAnd integrate the public cloud into your security strategy.\n\n\n-----\n\n### 2. Strong security practices\n\nThese include:\n\nUse multi-factor authentication (MFA)\nUse complex passwords, managed through a password manager\nLimit access rights; give user accounts and admins only the access rights they need\nMake regular backups, and keep them offsite and offline where attackers can’t find\nthem\nLock down your RDP; turn it off if you don’t need it, use rate limiting, 2FA or a VPN if\nyou do\nEnsure tamper protection is enabled – other ransomware strains attempt to disable\nyour endpoint protection, and tamper protection is designed to prevent this from\nhappening\n\n### 3. Ongoing staff education\n\nPeople are invariably the weakest link in cybersecurity, and cybercriminals are experts at\nexploiting normal human behaviors for nefarious gain. Invest – and keep investing – in staff\ntraining.\n\n## IoCs\n\nWe analyzed the following files in the course of this investigation\n\n**SHA256** **Filename**\n\n791c32a95f401f7464214960e49e716656f6fd6fff135ac2a6ba607236d3346e STEEL.EXE\n\n99c3cc348f8ee4e87bce45b1dd185d31830c370ac43fd3e39ac50340f029ef79 ROBNR.EXE\n\n0b15b5cc64caf0c6ad9bd759eb35383b1f718edf3d7ab4cd912d0d8c1826edf8 RBNL.SYS\n\n31f4cfb4c71da44120752721103a16512444c13c2ac2d857a7e6f13cb679b427 GDRV.SYS\n\n### Acknowledgments\n\nSophosLabs would like to acknowledge the contributions of Anand Ajjan, Richard Cohen,\nSivagnanam Gn, Roland Gyorffi, Erik Loman, Peter Mackenzie, Vikas Singh, Gabor\nSzappanos, Alex Vermaning and Michael Wood to the analysis for this post.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-06 - Living off another land- Ransomware borrows vulnerable driver to remove security software.pdf"
    ],
    "report_names": [
        "2020-02-06 - Living off another land- Ransomware borrows vulnerable driver to remove security software.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536196,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653688280,
    "ts_modification_date": 1653688280,
    "files": {
        "pdf": "https://archive.orkl.eu/8f3eb142790cc7e4f88f134339fe50dfe3c543bd.pdf",
        "text": "https://archive.orkl.eu/8f3eb142790cc7e4f88f134339fe50dfe3c543bd.txt",
        "img": "https://archive.orkl.eu/8f3eb142790cc7e4f88f134339fe50dfe3c543bd.jpg"
    }
}