{
    "id": "4b240771-cd50-481e-add8-32a25bbb615b",
    "created_at": "2023-01-12T15:00:04.887959Z",
    "updated_at": "2025-03-27T02:09:17.787803Z",
    "deleted_at": null,
    "sha1_hash": "b02e09ddae86f95a3abc8b33bdf3d2bc2f8f5341",
    "title": "2022-04-18 - A blueprint for evading industry leading endpoint protection in 2022",
    "authors": "",
    "file_creation_date": "2022-05-28T16:04:13Z",
    "file_modification_date": "2022-05-28T16:04:13Z",
    "file_size": 3469980,
    "plain_text": "# A blueprint for evading industry leading endpoint protection in 2022\n\n**vanmieghem.io/blueprint-for-evading-edr-in-2022/**\n\nvivami April 18, 2022\n\n[Home](https://vanmieghem.io/)\n[Blog](https://vanmieghem.io/blog)\n[Projects](https://vanmieghem.io/projects)\n\nMonday. April 18, 2022 - 19 mins\nAbout two years ago I quit being a full-time red team operator. However, it still is a field of\nexpertise that stays very close to my heart. A few weeks ago, I was looking for a new side\nproject and decided to pick up an old red teaming hobby of mine: bypassing/evading\nendpoint protection solutions.\n\nIn this post, I’d like to lay out a collection of techniques that together can be used to\nbypassed industry leading enterprise endpoint protection solutions. This is purely for\neducational purposes for (ethical) red teamers and alike, so I’ve decided not to publicly\nrelease the source code. The aim for this post is to be accessible to a wide audience in the\nsecurity industry, but not to drill down to the nitty gritty details of every technique. Instead, I\nwill refer to writeups of others that deep dive better than I can.\n\nIn adversary simulations, a key challenge in the “initial access” phase is bypassing the\ndetection and response capabilities (EDR) on enterprise endpoints. Commercial command\nand control frameworks provide unmodifiable shellcode and binaries to the red team operator\nthat are heavily signatured by the endpoint protection industry and in order to execute that\nimplant, the signatures (both static and behavioural) of that shellcode need to be obfuscated.\n\nIn this post, I will cover the following techniques, with the ultimate goal of executing malicious\nshellcode, also known as a (shellcode) loader:\n\n1. Shellcode encryption\n2. Reducing entropy\n3. Escaping the (local) AV sandbox\n4. Import table obfuscation\n5. Disabling Event Tracing for Windows (ETW)\n\n\n-----\n\n6. Evading common malicious API call patterns\n7. Direct system calls and evading “mark of the syscall”\n8. Removing hooks in `ntdll.dll`\n9. Spoofing the thread call stack\n10. In-memory encryption of beacon\n\n11. A custom reflective loader\n12. OpSec configurations in your Malleable profile\n\n## 1. Shellcode encryption\n\nLet’s start with a basic but important topic, static shellcode obfuscation. In my loader, I\nleverage a XOR or RC4 encryption algorithm, because it is easy to implement and doesn’t\nleave a lot of external indicators of encryption activities performed by the loader. AES\nencryption to obfuscate static signatures of the shellcode leaves traces in the import address\ntable of the binary, which increase suspicion. I’ve had Windows Defender specifically trigger\non AES decryption functions (e.g. `CryptDecrypt,` `CryptHashData,` `CryptDeriveKey`\netc.) in earlier versions of this loader.\n\nOutput of dumpbin /imports, an easy giveaway of only AES decryption functions being used\nin the binary.\n\n## 2. Reducing entropy\n\nMany AV/EDR solutions consider binary entropy in their assessment of an unknown binary.\nSince we’re encrypting the shellcode, the entropy of our binary is rather high, which is a clear\nindicator of obfuscated parts of code in the binary.\n\nThere are several ways of reducing the entropy of our binary, two simple ones that work are:\n\n1. Adding low entropy resources to the binary, such as (low entropy) images.\n2. Adding strings, such as the English dictionary or some of `\"strings C:\\Program`\n```\n   Files\\Google\\Chrome\\Application\\100.0.4896.88\\chrome.dll\" output.\n\n```\n\n-----\n\nA more elegant solution would be to design and implement an algorithm that would\nobfuscate (encode/encrypt) the shellcode into English words (low entropy). That would kill\ntwo birds with one stone.\n\n## 3. Escaping the (local) AV sandbox\n\nMany EDR solutions will run the binary in a local sandbox for a few seconds to inspect its\nbehaviour. To avoid compromising on the end user experience, they cannot afford to inspect\nthe binary for longer than a few seconds (I’ve seen Avast taking up to 30 seconds in the\npast, but that was an exception). We can abuse this limitation by delaying the execution of\nour shellcode. Simply calculating a large prime number is my personal favourite. You can go\na bit further and deterministically calculate a prime number and use that number as (a part\nof) the key to your encrypted shellcode.\n\n## 4. Import table obfuscation\n\nYou want to avoid suspicious Windows API (WINAPI) from ending up in our IAT (import\naddress table). This table consists of an overview of all the Windows APIs that your binary\nimports from other system libraries. A list of suspicious (oftentimes therefore inspected by\n[EDR solutions) APIs can be found here. Typically, these are](https://github.com/Mr-Un1k0d3r/EDRs) `VirtualAlloc,`\n```\nVirtualProtect, WriteProcessMemory, CreateRemoteThread, SetThreadContext\n\n```\netc. Running `dumpbin /exports <binary.exe> will list all the imports. For the most part,`\nwe’ll use Direct System calls to bypass both EDR hooks (refer to section 7) of suspicious\nWINAPI calls, but for less suspicious API calls this method works just fine.\n\nWe add the function signature of the WINAPI call, get the address of the WINAPI in\n```\nntdll.dll and then create a function pointer to that address:\ntypedef BOOL (WINAPI * pVirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD \nflNewProtect, PDWORD lpflOldProtect);\npVirtualProtect fnVirtualProtect;\nunsigned char sVirtualProtect[] = {\n'V','i','r','t','u','a','l','P','r','o','t','e','c','t', 0x0 };\nunsigned char sKernel32[] = { 'k','e','r','n','e','l','3','2','.','d','l','l', 0x0 };\nfnVirtualProtect = (pVirtualProtect) GetProcAddress(GetModuleHandle((LPCSTR)\nsKernel32), (LPCSTR)sVirtualProtect);\n// call VirtualProtect\nfnVirtualProtect(address, dwSize, PAGE_READWRITE, &oldProt);\n\n```\nObfuscating strings using a character array cuts the string up in smaller pieces making them\nmore difficult to extract from a binary.\n\nThe call will still be to an `ntdll.dll WINAPI, and will not bypass any hooks in WINAPIs in`\n```\nntdll.dll, but is purely to remove suspicious functions from the IAT.\n\n```\n\n-----\n\n## 5. Disabling Event Tracing for Windows (ETW)\n\nMany EDR solutions leverage Event Tracing for Windows (ETW) extensively, in particular\nMicrosoft Defender for Endpoint (formerly known as Microsoft ATP). ETW allows for\nextensive instrumentation and tracing of a process’ functionality and WINAPI calls. ETW has\ncomponents in the kernel, mainly to register callbacks for system calls and other kernel\noperations, but also consists of a userland component that is part of `ntdll.dll` (ETW\ndeep dive and attack vectors). Since `ntdll.dll is a DLL loaded into the process of our`\nbinary, we have full control over this DLL and therefore the ETW functionality. There are [quite](https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/)\na [few](https://www.mdsec.co.uk/2020/03/hiding-your-net-etw/) [different bypasses for ETW in userspace, but the most common one is patching the](https://modexp.wordpress.com/2020/04/08/red-teams-etw/)\nfunction `EtwEventWrite which is called to write/log ETW events. We fetch its address in`\n```\nntdll.dll, and replace its first instructions with instructions to return 0 ( SUCCESS ).\nvoid disableETW(void) {\n     // return 0\n     unsigned char patch[] = { 0x48, 0x33, 0xc0, 0xc3};   // xor rax, rax; ret\n     ULONG oldprotect = 0;\n     size_t size = sizeof(patch);\n     HANDLE hCurrentProc = GetCurrentProcess();\n     unsigned char sEtwEventWrite[] = {\n'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };\n     void *pEventWrite = GetProcAddress(GetModuleHandle((LPCSTR) sNtdll), (LPCSTR)\nsEtwEventWrite);\n     NtProtectVirtualMemory(hCurrentProc, &pEventWrite, (PSIZE_T) &size,\nPAGE_READWRITE, &oldprotect);\n     memcpy(pEventWrite, patch, size / sizeof(patch[0]));\n     NtProtectVirtualMemory(hCurrentProc, &pEventWrite, (PSIZE_T) &size,\noldprotect, &oldprotect);\n     FlushInstructionCache(hCurrentProc, pEventWrite, size);\n}\n\n```\nI’ve found the above method to still work on the two tested EDRs, but this is a noisy ETW\npatch.\n\n## 6. Evading common malicious API call patterns\n\nMost behavioural detection is ultimately based on detecting malicious patterns. One of these\npatters is the order of specific WINAPI calls in a short timeframe. The suspicious WINAPI\ncalls briefly mentioned in section 4 are typically used to execute shellcode and therefore\nheavily monitored. However, these calls are also used for benign activity (the\n```\nVirtualAlloc, WriteProcess, CreateThread pattern in combination with a memory\n\n```\n\n-----\n\nallocation and write of ~250KB of shellcode) and so the challenge for EDR solutions is to\n[distinguish benign from malicious calls. Filip Olszak wrote a great blog post leveraging](https://blog.redbluepurple.io/offensive-research/bypassing-injection-detection)\ndelays and smaller chunks of allocating and writing memory to blend in with benign WINAPI\ncall behaviour. In short, his method adjusts the following behaviour of a typical shellcode\nloader:\n\n1. Instead of allocating one large chuck of memory and directly write the ~250KB implant\n\nshellcode into that memory, allocate small contiguous chunks of e.g. <64KB memory\nand mark them as `NO_ACCESS . Then write the shellcode in a similar chunk size to the`\nallocated memory pages.\n2. Introduce delays between every of the above mentioned operations. This will increase\n\nthe time required to execute the shellcode, but will also make the consecutive\nexecution pattern stand out much less.\n\nOne catch with this technique is to make sure you find a memory location that can fit your\nentire shellcode in consecutive memory pages. Filip’s [DripLoader implements this concept.](https://github.com/xuanxuan0/DripLoader)\n\nThe loader I’ve built does not inject the shellcode into another process but instead starts the\nshellcode in a thread in its own process space using `NtCreateThread . An unknown`\nprocess (our binary will de facto have low prevalence) into other processes (typically a\nWindows native ones) is suspicious activity that stands out (recommended read “Fork&Run –\nyou’re history”). It is much easier to blend into the noise of benign thread executions and\nmemory operations within a process when we run the shellcode within a thread in the\nloader’s process space. The downside however is that any crashing post-exploitation\nmodules will also crash the process of the loader and therefore the implant. Persistence\n[techniques as well as running stable and reliable BOFs can help to overcome this downside.](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm)\n\n## 7. Direct system calls and evading “mark of the syscall”\n\nThe loader leverages direct system calls for bypassing any hooks put in `ntdll.dll by the`\nEDRs. I want to avoid going into too much detail on how direct syscalls work, since it’s not\n[the purpose of this post and a lot of great posts have been written about it (e.g. Outflank).](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/)\n\nIn short, a direct syscall is a WINAPI call directly to the kernel system call equivalent. Instead\nof calling the `ntdll.dll` `VirtualAlloc we call its kernel equivalent`\n```\nNtAlocateVirtualMemory defined in the Windows kernel. This is great because we’re\n\n```\nbypassing any EDR hooks used to monitor calls to (in this example) `VirtualAlloc defined`\nin `ntdll.dll .`\n\nIn order to call a system call directly, we fetch the syscall ID of the system call we want to call\nfrom `ntdll.dll, use the function signature to push the correct order and types of function`\narguments to the stack, and call the `syscall <id> instruction. There are several tools that`\n[arrange all this for us, SysWhispers2 and](https://github.com/jthuraisamy/SysWhispers2) [SysWhisper3 are two great examples. From an](https://github.com/klezVirus/SysWhispers3)\nevasion perspective, there are two issues with calling direct system calls:\n\n\n-----\n\n1. Your binary ends up with having the `syscall instruction, which is easy to statically`\n\ndetect (a.k.a “mark of the syscall”, more in “SysWhispers is dead, long live\nSysWhispers!”).\n2. Unlike benign use of a system call that is called through its `ntdll.dll equivalent, the`\n\nreturn address of the system call does not point to `ntdll.dll . Instead, it points to`\nour code from where we called the syscall, which resides in memory regions outside of\n```\n   ntdll.dll . This is an indicator of a system call that is not called through\n   ntdll.dll, which is suspicious.\n\n```\nTo overcome these issues we can do the following:\n\n1. Implement an egg hunter mechanism. Replace the `syscall instruction with the` `egg`\n\n(some random unique identifiable pattern) and at runtime, search for this `egg in`\nmemory and replace it with the `syscall instruction using the` `ReadProcessMemory`\nand `WriteProcessMemory WINAPI calls. Thereafter, we can use direct system calls`\n[normally. This technique has been implemented by klezVirus.](https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/)\n2. Instead of calling the `syscall instruction from our own code, we search for the`\n```\n   syscall instruction in ntdll.dll and jump to that memory address once we’ve\n\n```\nprepared the stack to call the system call. This will result in an return address in RIP\nthat points to `ntdll.dll memory regions.`\n\n[Both techniques are part of SysWhisper3.](https://github.com/klezVirus/SysWhispers3)\n\n## 8. Removing hooks in ntdll.dll\n\nAnother nice technique to evade EDR hooks in `ntdll.dll is to overwrite the loaded`\n```\nntdll.dll that is loaded by default (and hooked by the EDR) with a fresh copy from\nntdll.dll . ntdll.dll is the first DLL that gets loaded by any Windows process. EDR\n\n```\nsolutions make sure their DLL is loaded shortly after, which puts all the hooks in place in the\nloaded `ntdll.dll before our own code will execute. If our code loads a fresh copy of`\n```\nntdll.dll in memory afterwards, those EDR hooks will be overwritten. RefleXXion is a\n\n```\n[C++ library that implements the research done for this technique by MDSec. RelfeXXion](https://www.mdsec.co.uk/2022/01/edr-parallel-asis-through-analysis/)\nuses direct system calls `NtOpenSection and` `NtMapViewOfSection to get a handle to a`\nclean `ntdll.dll in` `\\KnownDlls\\ntdll.dll (registry path with previously loaded DLLs).`\nIt then overwrites the `.TEXT section of the loaded` `ntdll.dll, which flushes out the EDR`\nhooks.\n\nI recommend to use adjust the RefleXXion library to use the same trick as described above\nin section 7.\n\n## 9. Spoofing the thread call stack\n\n\n-----\n\nThe next two sections cover two techniques that provide evasions against detecting our\nshellcode in memory. Due to the beaconing behaviour of an implant, for a majority of the time\nthe implant is sleeping, waiting for incoming tasks from its operator. During this time the\nimplant is vulnerable for memory scanning techniques from the EDR. The first of the two\nevasions described in this post is spoofing the thread call stack.\n\nWhen the implant is sleeping, its thread return address is pointing to our shellcode residing in\nmemory. By examining the return addresses of threads in a suspicious process, our implant\nshellcode can be easily identified. In order to avoid this, want to break this connection\nbetween the return address and shellcode. We can do so by hooking the `Sleep() function.`\nWhen that hook is called (by the implant/beacon shellcode), we overwrite the return address\nwith `0x0 and call the original` `Sleep() function. When` `Sleep() returns, we put the`\noriginal return address back in place so the thread returns to the correct address to continue\nexecution. [Mariusz Banach has implemented this technique in his ThreadStackSpoofer](https://twitter.com/mariuszbit)\nproject. This repo provides much more detail on the technique and also outlines some\ncaveats.\n\nWe can observe the result of spoofing the thread call stack in the two screenshots below,\nwhere the non-spoofed call stack points to non-backed memory locations and a spoofed\nthread call stack points to our hooked Sleep ( MySleep ) function and “cuts off” the rest of\nthe call stack.\n\nDefault beacon thread call stack.\n\nSpoofed beacon thread call stack.\n\n\n-----\n\n## 10. In-memory encryption of beacon\n\nThe other evasion for in-memory detection is to encrypt the implant’s executable memory\nregions while sleeping. Using the same sleep hook as described in the section above, we\ncan obtain the shellcode memory segment by examining the caller address (the beacon code\nthat calls `Sleep() and therefore our` `MySleep() hook). If the caller memory region is`\n```\nMEM_PRIVATE and EXECUTABLE and roughly the size of our shellcode, then the memory\n\n```\nsegment is encrypted with a XOR function and `Sleep() is called. Then` `Sleep() returns,`\nit decrypts the memory segment and returns to it.\n\nAnother technique is to register a Vectored Exception Handler (VEH) that handles\n```\nNO_ACCESS violation exceptions, decrypts the memory segments and changes the\n\n```\npermissions to `RX . Then just before sleeping, mark the memory segments as` `NO_ACCESS,`\nso that when `Sleep() returns, it throws a memory access violation exception. Because we`\nregistered a VEH, the exception is handled within that thread context and can be resumed at\nthe exact same location the exception was thrown. The VEH can simply decrypt and change\nthe permissions back to RX and the implant can continue execution. This technique prevents\na detectible `Sleep() hook being in place when the implant is sleeping.`\n\n[Mariusz Banach has also implemented this technique in ShellcodeFluctuation.](https://twitter.com/mariuszbit)\n\n## 11. A custom reflective loader\n\nThe beacon shellcode that we execute in this loader ultimately is a DLL that needs to be\nexecuted in memory. Many C2 frameworks leverage Stephen Fewer’s [ReflectiveLoader.](https://github.com/stephenfewer/ReflectiveDLLInjection)\nThere are many well written explanations of how exactly a relfective DLL loader works, and\nStephen Fewer’s code is also well documented, but in short a Reflective Loader does the\nfollowing:\n\n1. Resolve addresses to necessary `kernel32.dll WINAPIs required for loading the`\n\nDLL (e.g. `VirtualAlloc,` `LoadLibraryA etc.)`\n2. Write the DLL and its sections to memory\n3. Build up the DLL import table, so the DLL can call `ntdll.dll and` `kernel32.dll`\n\nWINAPIs\n4. Load any additional library’s and resolve their respective imported function addresses\n5. Call the DLL entrypoint\n\nCobalt Strike added support for a custom way for reflectively loading a DLL in memory that\nallows a red team operator to customize the way a beacon DLL gets loaded and add evasion\n[techniques. Bobby Cooke and Santiago P built a stealthy loader (BokuLoader) using Cobalt](https://github.com/boku7/BokuLoader)\nStrike’s UDRL which I’ve used in my loader. BokuLoader implements several evasion\ntechniques:\n\nLimit calls to `GetProcAddress() (commonly EDR hooked WINAPI call to resolve a`\nfunction address as we do in section 4)\n\n\n-----\n\n[AMSI & ETW bypasses](https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal)\nUse only direct system calls\nUse only `RW or` `RX, and no` `RWX ( EXECUTE_READWRITE ) permissions`\nRemoves beacon DLL headers from memory\n\n[Make sure to uncomment the two defines to leverage direct system calls via HellsGate &](https://github.com/boku7/BokuLoader/blob/055861a12871e2e7f3396dcac67e8ee40c46d757/BokuLoader64.c#L4)\nHalosGate and bypass ETW and AMSI (not really necessary, as we’ve already disabled\nETW and are not injecting the loader into another process).\n\n## 12. OpSec configurations in your Malleable profile\n\nIn your Malleable C2 profile, make sure the following options are configured, which limit the\nuse of `RWX marked memory (suspicious and easily detected) and clean up the shellcode`\nafter beacon has started.\n```\n  set startrwx    \"false\";\n  set userwx     \"false\";\n  set cleanup     \"true\";\n  set stomppe     \"true\";\n  set obfuscate    \"true\";\n  set sleep_mask   \"true\";\n  set smartinject   \"true\";\n\n## Conclusions\n\n```\nCombining these techniques allow you to bypass (among others) Microsoft Defender for\nEndpoint and CrowdStrike Falcon with 0 detections (tested mid April 2022), which together\nwith SentinelOne lead the endpoint protection industry.\n\n\n-----\n\nCrowdStrike Falcon with 0 alerts.\n\n\n-----\n\nWindows Defender (and also Microsoft Defender for Endpoint, not screenshotted) with 0\nalerts.\nOf course this is just one and the first step in fully compromising an endpoint, and this\ndoesn’t mean “game over” for the EDR solution. Depending on what post-exploitation\nactivity/modules the red team operator choses next, it can still be “game over” for the\nimplant. In general, either run BOFs, or tunnel post-ex tools through the implant’s SOCKS\nproxy feature. Also consider putting the EDR hooks patches back in place in our `Sleep()`\nhook to avoid detection of unhooking, as well as removing the ETW/AMSI patches.\n\nIt’s a cat and mouse game, and the cat is undoubtedly getting better.\n\n**Related Posts**\n\n[Towards generic .NET assembly obfuscation (Pt. 1)](https://vanmieghem.io/towards-generic-.net-obfuscation/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-18 - A blueprint for evading industry leading endpoint protection in 2022.pdf"
    ],
    "report_names": [
        "2022-04-18 - A blueprint for evading industry leading endpoint protection in 2022.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535604,
    "ts_updated_at": 1743041357,
    "ts_creation_date": 1653753853,
    "ts_modification_date": 1653753853,
    "files": {
        "pdf": "https://archive.orkl.eu/b02e09ddae86f95a3abc8b33bdf3d2bc2f8f5341.pdf",
        "text": "https://archive.orkl.eu/b02e09ddae86f95a3abc8b33bdf3d2bc2f8f5341.txt",
        "img": "https://archive.orkl.eu/b02e09ddae86f95a3abc8b33bdf3d2bc2f8f5341.jpg"
    }
}