{
    "id": "ca7be84a-4e6e-4b5e-afb1-2067b17d6a6a",
    "created_at": "2023-01-12T15:02:33.797786Z",
    "updated_at": "2025-03-27T02:05:48.478618Z",
    "deleted_at": null,
    "sha1_hash": "21dbee68f10d403049c62a9d3ae35340101ba999",
    "title": "2019-09-12 - InnfiRAT- A new RAT aiming for your cryptocurrency and more",
    "authors": "",
    "file_creation_date": "2022-05-27T19:09:26Z",
    "file_modification_date": "2022-05-27T19:09:26Z",
    "file_size": 6536386,
    "plain_text": "# InnfiRAT: A new RAT aiming for your cryptocurrency and more\n\n**zscaler.com/blogs/research/innfirat-new-rat-aiming-your-cryptocurrency-and-more**\n\nRecently, the Zscaler ThreatLabZ team came across a new RAT called InnfiRAT, which is written in .NET and designed to perform specific\ntasks from an infected machine. This blog provides an analysis of this new RAT, including the way it communicates, all the tasks it performs,\nand the information it steals.\n\n## Background\n\nAs with just about every piece of malware, InnfiRAT is designed to access and steal personal information on a user's computer. Among other\nthings, InnfiRAT is written to look for cryptocurrency wallet information, such as Bitcoin and Litecoin. InnfiRAT also grabs browser cookies to\nsteal stored usernames and passwords, as well as session data. In addition, this RAT has ScreenShot functionality so it can grab information\nfrom open windows. For example, if the user is reading email, the malware takes a screenshot. It also checks for other applications running\non the system, such as an active antivirus program.\n\nInnfiRAT sends the data it has collected to its command-and-control (C&C) server and requests further instructions. The C&C can also\ninstruct the malware to download additional payloads onto the infected system.\n\n## Technical analysis\n\n**1) Before executing the main payload, the malware initially checks whether the file is executing from %AppData% directory or not with the**\nname NvidiaDriver.exe. If not, then a web request is sent to “iplogger[.]com/1HEt47\" (possibly to check network connectivity).\n\n**2) It records all the running processes in an array, then iterates through each process and checks whether any process is running with the**\nname NvidiaDriver.exe. If so, the malware kills that process and waits for an exit.\n\n\n-----\n\ngu e C ec s e ecut o ocat o, te ates p ocess t a e d a e\n\n**3) InnfiRAT copies itself as %AppData%/NvidiaDriver.exe and executes it from %AppData% before terminating the current process.**\n\nFigure 2: The malware makes a copy of itself in %AppData%\n\n**4) After confirming the path of file execution, it writes a Base64 encoded PE file in memory, which is later decoded in its actual format and is**\nloaded after changing the entry point of the file. This is also a .NET executable and contains the actual functionality of the malware.\n\nFigure 3: Embedded PE file in encoded form\n\nFigure 4: Embedded PE file is decoded and executed\n\n## Analysis of embedded .NET executable\n\nAll the strings inside the file are encoded with a custom encoding scheme that utilizes the XOR operation.\n\n\n-----\n\nFigure 5: Strings decoding logic\n\nAs the execution of the malware starts, it checks for the presence of VM environment. It does so by checking the return value from the\nroutine JкыnеюwPреюLLщzьhdкXoJxбюHхрйFWрDлнруG7574208083337. If the return value is equal to the first value,\n**enum[0], defined in the enum shown below, then it continues the execution or else it terminates.**\n\nFigure 6: User-defined enum structure\n\nAfter performing the VM checks, the malware obtains the country and HWID information of the machine it is running on. To obtain the\ncountry information, it calls the routine EjarVhXфf8752612307563884480() [FetchNetworkInfo] and fetches the Country key value from the\nreturned data in JSON format. Similarly, to obtain the HWID, it calls the routine ubобмдGogBлzWKrgrыaZucвлC33208440168().\n\n## Anti-VM checks\n\n**Inside the JкыnеюwPреюLLщzьhdкXoJxбюHхрйFWрDлнруG7574208083337() [VMDetection] routine:**\n\n**Note: All the enum values are referenced using enum[index] during analysis where the index starts from 0.**\n\n**1. Performs WMIquery to obtain the following information:**\n\n**\"Manufacturer\"**\n\n**\"Caption\"**\n\n**\"Name\"**\n\n**\"ProcessorId\"**\n\n**\"NumberOfCores\"**\n\n**\"NumberOfLogicalProcessors\"**\n\n**\"L2CacheSize\"**\n\n**\"L3CacheSize\"**\n\n**\"SocketDesignation\"**\n\nIt then checks, one-by-one, if the manufacturer contains one of the below-mentioned strings and returns the value from\nthe enum as specified:\n\n\n-----\n\n**o** **o** **o** **etu** **s e u** [ ]\n**“VMwareVMware”** **returns enum[1]**\n**“Prl hyperv** **returns enum[3]**\n**“Microsoft Corporation”** **returns enum[4]**\n\n**2. WMIquery is performed again but this time to obtain the following information:**\n\n**\"DeviceID\"**\n**\"MediaType\"**\n**\"Model\"**\n**\"PNPDeviceID\"**\n**\"SerialNumber\"**\n\nA check is performed if the PnpDeviceId contains one of the below strings and returns the value from the enum as specified:\n\n**“VBOX_HARDDISK”** **returns enum[2]**\n**“VEN_VMWARE”** **returns enum[1]**\n\nIf none of the above conditions match, it returns enum[0].\n\n## Machine network information\n\n**Inside the EjarVhXфf8752612307563884480() [FetchNetworkInfo] routine:**\n\nA web request is sent to the following URL https://ipinfo[.]io/json and the received data is returned from the function. The received data\ncontains the following information:\n\n**\"ip\"**\n\n**\"city\"**\n\n**\"region\"**\n\n**\"country\"**\n\n**\"loc\"**\n\n**\"postal\"**\n\n**\"org\"**\n\nFigure 7: Web request being made\n\n## Network communication\n\n**Inside the мMлFкCцеGPбiбqюK1559516831() [CreateDuplexChannel] routine:**\n\nInnfiRAT sets up a duplex channel with the name “IVictim” using DuplexChannelFactory tcp://62[.]210[.]142[.]219:17231/IVictim\n\n\n-----\n\ngu e 8 C eat g a dup e c a e t C&C se e\n\nAfter forming the duplex channel with the name IVictim, it uses the IVictim interface, which contains the following methods:\n\n**“Subscribe”**\n**“CompleteTask”**\n**“GetDlls”**\n**“AvailableTasks”**\n\nFigure 9: Available methods in the IVictim interface\n\n**Inside the SуkdVkцiшkUояUuчPуюяmмuty187968776() [SubscribeVictim] routine:**\n\nInnfiRAT calls the subscriber method from the IVictim interface with login = “innfiniti”\n\nFigure 10: The subscribe method from the IVictim interface is invoked\n\n**Inside the хaxeYхсиghIжNпDмвQюwkуpкgимuбсфbnдбMвMC67210633684721828() [GetAndExecuteSpecifiedTask] routine:**\n\nInnfiRAT obtains the tasks inside a UserTask list by invoking AvailableTasks where UserTask has the following keys:\n\n**“ID”**\n\n**“Action”**\n\n**“URL”**\n\n**“FinalPoint”**\n\n**“Current”**\n\n**“Status”**\n\n**“Country”**\n\n**“RunSilent”**\n\n**“Argument”**\n\nIt iterates through each task. On each iteration, it first checks for the country value received to be equal to “ALL” OR the one present in\nthe BasicInfoVictim class, which was obtained earlier AND the action to perform is \"DownAndEx\" and the URL value is available.\n\nIf the above conditions match, then the CompleteTasks method is called with three arguments:\n**“login”**\n\n**“hwid”**\n\n**“TaskID”**\n\nThe RAT calls the routine rLPсаWFоWcTjzпTэBFWkъмзтшпD147152108377454681517643543() [ExecuteFile] with three arguments to\nexecute the file.\n\nArg1 = Path of the file to be executed [obtained from the URL]\n\nArg2 = Arguments to the file to be executed [obtained from Argument key of current UserTask element]\n\nArg3 = true/false [Obtained from RunSilent key of current UserTask element]\n\nAfter iterating all items in the UserTask list, it sleeps for 30,000 milliseconds.\n\n\n-----\n\nFigure 11: Country, action, and URL checks are performed and the specified task is completed\n\n## Process checks\n\n**Inside the LlсiсkнwychhVзjзNзxрFrUOE4656655235232302206601527615541285() [ProcessCheck] routine:**\n\nAll the running processes in the system are obtained, their names are converted to lowercase and then a check is performed to see if the\nname matches with any of the following strings:\n\n**“taskmgr”**\n\n**“processhacker”**\n\n**“procmon”**\n\n**“procexp”**\n\n**“pchunter”**\n\n**“procexp64”**\n\nIf there are any matches, the process terminates. Below are the snapshots depicting the actions performed.\n\nFigure 12: Obtaining processes, converting their names to lowercase, checking specific processes\n\nFigure 13: Converting ProcessName to lowercase\n\n\n-----\n\nFigure 14: Checking for above-mentioned running processes (process names are obfuscated here)\n\n**Inside wYxйыrоyTHuLдTч212065() [KillProcesses] routine:**\n\nInnfiRAT obtains the list of all processes running in the system and kills any process whose name contains one of the following strings:\n\n**“chrome”**\n\n**“browser”**\n\n**“firefox”**\n\n**“opera”**\n\n**“amigo”**\n\n**“kometa”**\n\n**“torch”**\n\n**“orbitum”**\n\nFigure 15: Kills processes that contain any of the above-mentioned strings\n\n## Scheduled execution\n\n**Inside the эйviMhйсuьZCпJфшcкLйшuв348374() [ScheduleMalwareExecution] routine:**\n\nThe CMD (cmd.exe) command string is constructed and executed to schedule the malware execution. The command string looks like below:\n\n**/C schtasks /create /tn WindowsUpdater /tr \"%AppData%NvidiaDriver.exe \" /st HH:mm /du 9999:59 /sc daily /ri 1 /f**\n\n\n-----\n\ngu e 6 C co a d s co st ucted a d e ecuted\n\n## C&C commands\n\n**Here are some tasks performed by the malware based on the commands received from C&C server:**\n\n**1. SendUrlAndExecute(string URL)**\n\nInnfiRAT downloads the file from the specified URL by calling the\nroutine жRfаeQbrwйfsLGыhчUrEжьFхaяGчрлCдtGжSofьQvдnIмs8383484343838630833542717281211() [DownloadFileFromUrl].\nInside this routine, a directory is first created with the name TEMP inside the %AppData% if it doesn’t exist. Then the file is downloaded and\nsaved inside this folder with the name extracted from the passed URL. The URL passed is broken into parts via delimiter ‘/’ and the last item\nis used as the file name.\n\nFigure 17: Create folder and download file\n\nOnce the download is complete, it calls the routine rLPсаWFоWcTjzпTэBFWkъмзтшпD147152108377454681517643543()\n\n**[ExecuteFile] with three arguments to execute the downloaded file.**\n\nArg1 = Path of the file to be executed\n\nArg2 = Arguments to the file to be executed\n\nArg3 = true\n\nFigure 18: Execute the downloaded file\n\n**2. ProfileInfo()**\n\nInside the routine, it collects the following information:\n\n\n-----\n\n**et o** **o** **{**\n**\"ip\"**\n**\"city\"**\n**\"region\"**\n**\"country\"**\n**\"loc\"**\n**\"postal\"**\n**\"org\"**\n**}**\n**“PCAdmin”**\n**“PCInformation” :{**\n**“FrameWorkDescription”**\n**“Processors”**\n**“PRocessorsCore”**\n**“VideoCards”**\n**}**\n\nIt then sends the information to the C&C server.\n\nFigure 19: UserProfile info being collected and sent to the C&C server\n\n**3. LoadLogs()**\n\nIt calls the GetDlls() routine, which obtains information inside a list of type DownloadDll where DownloadDll has two keys:\n\n**“Path”,           represents a relative path to an .exe file**\n\n**“ByteArray”      binary data**\n\nFigure 20: GetDlls being called\n\nAfter fetching the list, InnfiRAT traverses each element inside the list via a for-loop. Inside the for-loop:\n\nThe value of the Path key is split using delimiter “\\\\”. The second value in the split is the name of the directory. A check is performed to see if\nthe count after the split is greater than 2 and there is no directory with the name obtained from the Path key split inside the executing module\ndirectory. If the check is true, a directory with the obtained name is created.\n\nA check is performed if no file exists specified by Path key in the executing module directory. If the check is true, it creates the file and writes\nthe value of ByteArray to this created file.\n\nThe routine wYxйыrоyTHuLдTч212065() [KillProcesses] is called.\n\n\n-----\n\na y, data obta ed o **Use** **o** **e() s se t to t e C&C se** e\n\nFigure 21: A directory is created, file is created, and KillProcesses is called; response is sent to the C&C server\n**4. LoadCookies() - Steal Browser Cookie information**\n\nInnfiRAT calls the GetDlls() routine, which obtains information inside a list of type DownloadDll where DownloadDll has two keys:\n\n**“Path”          represents a relative path to an .exe file**\n\n**“ByteArray”     binary data**\n\nFigure 22: GetDlls being called\n\nAfter fetching the list, the malware traverses each element inside the list via for-loop. The following occurs inside the for-loop:\n\nThe value of the Path key is split using the delimiter “\\\\”. Second, the value in the split is the name of the directory. A check is performed if the\ncount after the split is greater than 2 and there is no directory with the name obtained from the Path key split inside the executing module\ndirectory. If the check is true, a directory with the obtained name is created.\n\nA check is performed if no file exists specified by the Path key in the executing module directory. If a check is true, it creates the file and\nwrites the value of ByteArray to this created file.\n\nFigure 23: Directory is created, file is created\n\nIt creates an empty list of BrowserCook type where BrowserCook has two keys, namely:\n**“CookiePaths”**\n\n**“BrowserName”**\n\nThe name and corresponding cookie path are retrieved for the following browsers one by one:\n\n\n-----\n\n**C** **o** **e**\n**“Yandex”**\n**“Kometa”**\n**“Amigo”**\n**“Torch”**\n**“Orbitum”**\n**“Opera”**\n**“Mozilla”**\n\nA BrowserCook type element is created with the fetched information and is added to the list created earlier.\n\nFigure 24: Browser info is retrieved and added to the list\n\nIt creates an empty list of BrowserCookie type where BrowserCookie has three keys, namely:\n\n**“Browser”**\n\n**“FileName”**\n\n**“FileArray”**\n\nInside, two for-loop elements of the BrowserCookie type are created, where the Browser key and FileArray key are both assigned values\nusing the information from the previously created BrowserCook list and the FileName is set to _Cookie.txt if the browser name for the\ncurrent element is not “Mozilla”, or else it is set to Cookie.txt.\n\nFigure 25: BrowserCookie elements list is built\n\nThe harvested BrowserCookie list is then sent to the C&C server and the temporary file and directory are deleted.\n\n\n-----\n\nFigure 26: File and directory is deleted\n\n**5. LoadWallets() - Steal Bitcoin Wallets**\n\nThe malware creates an empty list of the BitcoinWallet type where BitcoinWallet has two keys, namely:\n\n**“WalletArray”**\n\n**“WalletName”**\n\nA check is performed to see if a file for a Litecoin or Bitcoin wallet is present in the system at the following location:\n\n**Litecoin: %AppData%\\Litecoin\\wallet.dat**\n\n**Bitcoin: %AppData%\\Bitcoin\\wallet.dat**\n\nIf it is found, then the element of type BitcoinWallet is added to the list after assigning a name to the WalletName key and reading the\ncorresponding wallet file in the WalletArray key.\n\nFigure 27: File presence is checked, BitcoinWallet element is added to the list\n\nFinally, the created list is sent in response to the C&C server.\n\nFigure 28: List is sent in response to the C&C server\n\n**6. LoadFiles() - Steal small text files potentially containing sensitive information**\n\nInnfiRAT collects all the .txt files available on the desktop whose size is less than 2,097,152 bytes inside a list of CustomFile\ntypes. CustomFile has two keys namely:\n\n**“Name”**\n\n**“FileArray”**\n\n\n-----\n\ne c eated st s se t espo se to t e C&C se e\n\nFigure 29: Files are collected and sent to the C&C server\n\nFigure 30: Inside\n_HcапkцтеuxчI46156665847187238336657104255061.лQtdjюAKMCdскHUжfъqZTzmMнуз68532317728035381607276587242500 [CollectFiles_\n\n**7. LoadProcesses() - Get the list of running processes on the victim machine**\n\nInnfiRAT creates an empty list of type ProcessInfo where ProcessInfo has three keys, namely:\n\n**“ID”**\n\n**“Name”**\n\n**“Path”**\n\nIt obtains the list of all the processes running in the system and sends the list in response to the C&C server.\n\nFigure 31: Process information is obtained and the list is sent to the C&C server\n\n**8. Kill(int process) - Command to Kill a specific process on the victim machine**\n\nInnfiRAT obtains the list of all the processes running in the system and then inside a for-loop, the processID of obtained processes is\ncompared with the processID passed as an argument to this routine one at a time. If there is a match, the process is killed and the flag\nvariable is set to true.\n\n\n-----\n\na y, a espo se s se t to C&C se e\n\nFigure 32: Process is killed and response is sent\n\n**9. Screenshot() - Take a screenshot on the victim machine**\n\nIt calls the qюFpьGoJv97921676245() [CaptureScreenshot] routine and the returned value is sent to the C&C server.\n\nFigure 33: Screenshot captured and sent to the C&C server\n\nFigure 34: Inside the qюFpьGoJv97921676245() [CaptureScreenshot] routine\n\n**10. RunCommand(string command) - Execute specified command on the victim machine**\n\nThis creates a new CMD process, builds the command line argument using the command passed as an argument to this routine, and finally\nstarts the process.\n\n**Command line argument:  /c + “ ” + command**\n\n\n-----\n\ngu e 35 ece ed co a d s e ecuted\n\n**11. ClearCooks() - Clears browser Cookies on the victim machine for specific Browsers**\n\nInnfiRAT creates an empty list of BrowserCook type where BrowserCook has two keys, namely:\n**“CookiePaths”**\n**“BrowserName”**\n\nThe name and corresponding cookie path are retrieved for the following browsers one by one:\n\n**“Chrome”**\n**“Yandex”**\n**“Kometa”**\n**“Amigo”**\n**“Torch”**\n**“Orbitum”**\n**“Opera”**\n**“Mozilla”**\n\nA BrowserCook type element is created with the fetched information and is added to the list created earlier.\n\nFigure 36: Browser info is retrieved and added to the list\n\nThe routine wYxйыrоyTHuLдTч212065() [KillProcesses] is called.\n\nThe BrowserCook type list created earlier is traversed and cookies files are deleted using CookiePaths key value.\n\nFinally, a response is sent to the C&C server.\n\nFigure 37: The routine wYxйыrоyTHuLдTч212065() [KillProcesses] is called, cookie files are deleted, and response is sent to the C&C server\n\n## Conclusion\n\nA RAT, remote-access trojan, is a type of malware that includes a backdoor, giving intruders the ability to control the targeted computer\nremotely and enabling them to perform any number of tasks, such as logging keystrokes, accessing confidential information, activating the\nsystem's webcam, taking screenshots, formatting drives, and more. They can also be designed to spread to other systems on a network.\n\n\n-----\n\necause s a e usua y do oaded as a esu t o a use ope g a e a attac e t o do oad g a app cat o t at as bee\ninfected, the first line of defense is often the users who must, as always, refrain from downloading programs or opening attachments that\naren't from a trusted source.\n\nThe ThreatLabZ team continues to monitor this threat and ensure that Zscaler customers are protected.\n\n## IOCs\n\n**Md5: f992dd6dbe1e065dff73a20e3d7b1eef**\n\n**Downloading URL:**\nrgho[.]st/download/6yghkhzgm/84986b88fe9d7e3caf5183e4342e713adf6c3040/df3049723db33889ac49202cb3a2f21ac1b82d5b/peugeot.zip\n\n**NetworkURL: tcp://62[.]210[.]142[.]219:17231/IVictim**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-09-12 - InnfiRAT- A new RAT aiming for your cryptocurrency and more.pdf"
    ],
    "report_names": [
        "2019-09-12 - InnfiRAT- A new RAT aiming for your cryptocurrency and more.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535753,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653678566,
    "ts_modification_date": 1653678566,
    "files": {
        "pdf": "https://archive.orkl.eu/21dbee68f10d403049c62a9d3ae35340101ba999.pdf",
        "text": "https://archive.orkl.eu/21dbee68f10d403049c62a9d3ae35340101ba999.txt",
        "img": "https://archive.orkl.eu/21dbee68f10d403049c62a9d3ae35340101ba999.jpg"
    }
}