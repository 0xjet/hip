{
    "id": "8c582e14-647c-4380-b48f-242d5c92c7e2",
    "created_at": "2023-01-12T15:00:00.516385Z",
    "updated_at": "2025-03-27T02:08:41.120553Z",
    "deleted_at": null,
    "sha1_hash": "7882f38f0a670deed7cc05859cad562023884cc2",
    "title": "2018-01-17 - A coin miner with a “Heaven’s Gate”",
    "authors": "",
    "file_creation_date": "2022-05-28T02:31:31Z",
    "file_modification_date": "2022-05-28T02:31:31Z",
    "file_size": 386706,
    "plain_text": "# A coin miner with a “Heaven’s Gate”\n\n**[blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/amp/](https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/amp/)**\n\nhasherezade\n\nhasherezade\n4 years ago\n\nYou might call the last two years the years of ransomware. Ransomware was, without a\ndoubt, the most popular type of malware. But at the end of last year, we started observing\nthat ransomware was losing its popularity to coin miners. It is very much possible that this\ntrend will grow as 2018 progresses.\n\nFrom the point of view of the victim, this is a huge relief, because miners are not as much of\na threat as ransomware. They slow down the system, yes, but once you get rid of them you\ncan continue using your computer as before. No data is stolen, or lost as in the case with a\nransomware infection.\n\nFrom the point of view of a malware researcher, miners are so far disappointing. They don’t\ngive enough interesting material for a deeper analysis, mostly because they are based on\nwell-known open source components with little or no obfuscation.\n\nHowever, from time to time, we find coin miners incorporating interesting tricks. In one recent\nsample, we observed a technique called “Heaven’s Gate” that allows the malware to make\ninjections to 64-bit processes from 32-bit loaders. This trick is not new—its introduction is\ndated to 2009—but it’s curious to see it implemented in this new sample captured in wild.\n\nThose who are beginners in malware analysis can read on for a guide about what Heaven’s\nGate is and how to approach analyzing it.\n\n\n-----\n\n## Analyzed samples\n\n[7b3491e0028d443f11989efaeb0fbec2 – dropper #1](https://www.virustotal.com/#/file/f9c67313230bfc45ba8ffe5e6abeb8b7dc2eddc99c9cebc111fcd7c50d11dc80/details)\n\n[This sample was found in the continuation of the Ngay campaign (more about it](https://blog.malwarebytes.com/threat-analysis/2018/01/rig-exploit-kit-campaign-gets-deep-into-crypto-craze/) [here). A](http://malware-traffic-analysis.net/2018/01/11/index.html)\n[background check on similar samples lead me to the article of](https://secrary.com/ReversingMalware/CoinMiner/) [@_qaz_qaz, who described](https://twitter.com/_qaz_qaz)\nan earlier campaign with a similar sample. However, his analysis skipped details on the\nHeaven’s Gate technique.\n\n## Behavioral analysis\n\nTo observe the mentioned injection, we must run the sample on a 64-bit system. We can see\nthat it runs an instance of notepad, with parameters typical for mining cryptocurrency:\n\nLooking at the in-memory strings in ProcessExplorer, we can clearly see that it is not a real\n[notepad running, but the xmrig Monero miner:](https://github.com/xmrig/xmrig)\n\n\n-----\n\nSo, at this moment we’re confident that the notepad’s image has been replaced in memory,\nmost probably by the RunPE (Process Hollowing) technique.\n\nThe main dropper is 32-bit, but it injects a payload into a 64-bit notepad:\n\n\n-----\n\nThe fun part is that this type of injection is not supported by the official Windows API. We can\nread/write the memory of 32-bit processes from a 64-bit application (using Wow64 API), but\nnot the other way around.\n\nThere are, however, some unofficial solutions to this, such as the technique called “Heaven’s\nGate.”\n\n## Heaven’s Gate overview\n\nThe Heaven’s Gate technique was first described in 2009, by a hacker nicknamed Roy G.\n[Biv. Later, many adaptations were created, such as a library Wow64ext or, basing in it,](https://github.com/rwfpl/rewolf-wow64ext)\n[W64oWoW64. In the blog post from 2015, Alex Ionescu described mitigations against this](https://github.com/georgenicolaou/W64oWoW64)\ntechnique.\n\nBut let’s have a look at how it works.\n\n**Running 32-bit processes on 64-bit Windows**\n\nEvery 32-bit process that runs on a 64-bit version of Windows runs in a special subsystem\n[called WoW64 that emulates the 32-bit environment. We can explain it as a 32-bit sandbox](https://en.wikipedia.org/wiki/WoW64)\nthat is created inside a 64-bit process. So, first the 64-bit environment for the process is\ncreated. Then, inside it, the 32-bit environment is created. The application is executed in this\n32-bit environment and it has no access to the 64-bit part.\n\n\n-----\n\nIf we scan the 32-bit process from outside, via the 64-bit scanner, we can see that it has\ninside both 32 and 64 DLLs. Most importantly, it has two versions of NTDLL: 32-bit (loaded\nfrom a directory SysWow64) and 64-bit (loaded from a directory System32):\n\nHowever, the 32-bit process itself can’t see the 64-bit part and is limited to using the 32-bit\nDLLs. To make an injection to a 64-bit process, we’d need to use the 64-bit versions of\nappropriate functions.\n\n**Code segments**\n\nIn order to access the forbidden part of the environment, we need to understand how the\nisolation is made. It turns out that it’s quite simple. The 32- and 64-bit code execution is\naccessible via a different address of the code segment: 32-bit is 0x23 and 64-bit is 0x33.\n\nIf we call an address in a typical way, the mode that is used to interpret it is the one set by\ndefault. However, we can explicitly request to change it using assembler instructions.\n\n## Inside the miner: the Heaven’s Gate implementation\n\n[I will not do a full analysis of this miner because it has already been described here. Let’s](https://secrary.com/ReversingMalware/CoinMiner/)\njump directly to the place where the fun begins. The malware checks its environment, and if\nit finds that it’s running on a 64-bit system, it takes a different path to make an injection into a\n64-bit process:\n\n\n-----\n\nAfter some anti-analysis checks, it creates a new, suspended 64-bit process (in this case, it\nis a notepad):\n\nThis is the target into which the malicious payload is going to be injected.\n\nAs we discussed before, in order to inject the payload into a 64-bit process, we need to use\nthe appropriate 64-bit functions.\n\nFirst, the loader takes a handle to a 64-bit NTDLL:\n\n\n-----\n\nWhat happens inside this function `get_ntdll requires some deeper explanation. As a`\n[reference, we can also have a look at the analogical code in the ReWolf’s library.](https://github.com/rwfpl/rewolf-wow64ext/blob/fd28b57fe926f3e57540850c37cdbcc766173dba/src/wow64ext.cpp#L298)\n\nTo get access to the 64-bit part of the process environment, we need to manipulate the\nsegments selectors. Let’s see how our malware enters the 64-bit mode:\n\n_This code seems to be directly copied from the open source library:_\n_[https://github.com/rwfpl/rewolf-wow64ext/blob/master/src/internal.h#L26](https://github.com/rwfpl/rewolf-wow64ext/blob/master/src/internal.h#L26)_\n\nThe segment selector 0x33 is pushed on the stack. Then, the malware calls the next line: (By\nthis way, the next line’s address is also pushed on the stack.)\n\nAn address that was pushed is fixed by adding 5 bytes and set after the retf :\n\n\n-----\n\nAt the end, the instruction RETF is called. RETF is a “far return,” and in contrast to the\ncasual RET, it allows to specify not only the address where the execution should return, but\nalso the segment. It takes as arguments two DWORDs from the stack. So, when the RETF is\nhit, the actual return address is:\n```\n0x33:0x402A50\n\n```\nThanks to the changed segment, the code that starts at the specified address is interpreted\nas 64-bit. So, the code that is visible under the debugger as 32-bit…\n\n…is, in reality, 64-bit.\n\nFor the fast switching of those views, I used a feature of PE-bear:\n\nAnd this is how this piece of code looks, if it is interpreted as 64-bit:\n\n\n-----\n\nSo, the code that is executed here is responsible for moving the content of the R12 register\n[into a variable on the stack, and then switching back to the 32-bit mode. This is done for the](https://github.com/rwfpl/rewolf-wow64ext/blob/master/src/internal.h#L34)\n[purpose of getting 64bit Thread Environment Block (TEB), from which next we fetch the 64-](https://en.wikipedia.org/wiki/Win32_Thread_Information_Block)\nbit [Process Environment Block (PEB) —check the](https://en.wikipedia.org/wiki/Process_Environment_Block) [analogical code.](https://github.com/rwfpl/rewolf-wow64ext/blob/fd28b57fe926f3e57540850c37cdbcc766173dba/src/wow64ext.cpp#L283)\n\nThe 64-bit PEB is used as a starting point to search the 64-bit version of NTDLL. This part is\n[implemented in a casual way (a “vanilla” implementation of this technique can be found here)](https://github.com/rwfpl/rewolf-wow64ext/blob/fd28b57fe926f3e57540850c37cdbcc766173dba/src/wow64ext.cpp#L303)\nusing a pointer to the loaded libraries that is one of the fields in the PEB structure. So, from\nPEB we get a field called `Ldr :`\n\nLdr is a structure of the type `_PEB_LDR_DATA . It contains an entry called`\n```\nInMemoryOrderModuleList :\n\n```\nThis list contains all the loaded DLLs that are present in the memory of the examined\nprocess. We browse through this list until we find the DLL of our interest that, in this case, is\nNTDLL. This is exactly what the mentioned function `get_ntdll does. In order to find the`\nappropriate name, it calls the following function—denoted as `is_ntdll_lib —that checks`\nthe name of the library character-by-character and compares it with ntdll.dll. It is an\n[equivalent of this code](https://github.com/rwfpl/rewolf-wow64ext/blob/fd28b57fe926f3e57540850c37cdbcc766173dba/src/wow64ext.cpp#L324)\n\n\n-----\n\nIf the name matches, the address to the library is returned in a pair of registers:\n\nOnce we found NTDLL, we just needed to fetch addresses of the appropriate functions. We\ndid this by browsing the exports table of the DLL:\n\n\n-----\n\nThe following functions are being fetched:\n\nNttUnmapViewOfSection\nNtGetContextThread\nNtAllocateVirtualMemory\nNtReadVirtualMemory\nNtWriteVirtualMemory\nNtSetContextThread\n\nAs we know, those functions are typical for RunPE technique. First, the\n```\nNtUnmapViewOfSection is used to unmap the original PE file. Then, memory in the remote\n\n```\nprocess is allocated, and the new PE is written. At the end, the context of the process is\nchanged to start the execution from the injected module.\n\n[The addresses of the functions are saved and later called (similarly to this code) to](https://github.com/rwfpl/rewolf-wow64ext/blob/fd28b57fe926f3e57540850c37cdbcc766173dba/src/wow64ext.cpp#L75)\nmanipulate the remote process.\n\n## Conclusion\n\nSo far, authors of coin miners don’t show a lot of creativity. They achieve their goals by\nheavily relying on open-source components. The described case also shows this tendency –\nthey made use of a ready made implementation.\n\nThe Heaven’s Gate technique has been around for several years. Some malware use it for\nthe [purpose of being stealthy. But in case of this coin miner, authors probably aimed rather to](https://camal.coseinc.com/publish/Phenom%20-%20Bypassing%20Antivirus.pdf)\nmaximize performance by using a payload version that best fit the target architecture.\n\n[COMMENTS](https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate//#disqus_thread)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-01-17 - A coin miner with a “Heaven’s Gate”.pdf"
    ],
    "report_names": [
        "2018-01-17 - A coin miner with a “Heaven’s Gate”.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535600,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653705091,
    "ts_modification_date": 1653705091,
    "files": {
        "pdf": "https://archive.orkl.eu/7882f38f0a670deed7cc05859cad562023884cc2.pdf",
        "text": "https://archive.orkl.eu/7882f38f0a670deed7cc05859cad562023884cc2.txt",
        "img": "https://archive.orkl.eu/7882f38f0a670deed7cc05859cad562023884cc2.jpg"
    }
}