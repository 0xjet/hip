{
    "id": "27c05686-bf93-44aa-ae38-98fe01dd5058",
    "created_at": "2023-01-12T15:02:33.1711Z",
    "updated_at": "2025-03-27T02:05:24.655349Z",
    "deleted_at": null,
    "sha1_hash": "5fa485ad371ef8c25846c20c0c525fa1021c84a5",
    "title": "2021-11-09 - Scheming with URLs- One-Click Attack Surface in Linux Desktop Environments",
    "authors": "",
    "file_creation_date": "2022-05-28T04:48:54Z",
    "file_modification_date": "2022-05-28T04:48:54Z",
    "file_size": 1012763,
    "plain_text": "# One-Click Attack Surface in Linux Desktop Environments\n\n**[crowdstrike.com/blog/one-click-attack-surface-in-linux-desktop-environments/](https://www.crowdstrike.com/blog/one-click-attack-surface-in-linux-desktop-environments/)**\n\nLukas Kupczyk - Max Julian Hofmann November 9, 2021\n\nThe Advanced Research Team at CrowdStrike Intelligence discovered multiple vulnerabilities\naffecting libvncclient. In some widely used desktop environments, such as GNOME, these\nvulnerabilities can be triggered in a one-click fashion.\n\n## Introduction\n\nClient-side exploitation has become a crucial component of many attackers’ toolkits. In the\ndesktop space, exploiting browsers is considered to be one of the most impactful\ncapabilities, but due to continuous hardening measures and wide adoption of sandboxing, it\nis also one of the most complex. However, other components of a typical desktop\nenvironment have not been subject to the same scrutiny and can therefore pose risks that go\nunnoticed. Sparked by our own observations of applications helpfully spawning applications\nat the click of a link, we decided to investigate the security posture of a typical Linux desktop\nenvironment.\n\n## URL Scheme Handlers\n\n\n-----\n\nWhether the desktop starts an application when the user clicks on a link (e.g., in an email or\nan instant message) depends on whether a handler application is registered for a URL\nscheme. In a stock Ubuntu 21.04 desktop based on Gnome, there are various applications\nregistered as handlers for specific URL schemes. A full list of these handlers can be\nretrieved by grepping the `mimeinfo.cache file as follows:`\n```\n$ grep x-scheme-handler /usr/share/applications/mimeinfo.cache \nx-scheme-handler/apt=apturl.desktop;\nx-scheme-handler/chrome=firefox.desktop;\nx-scheme-handler/ftp=firefox.desktop;\nx-scheme-handler/ghelp=yelp.desktop;\nx-scheme-handler/help=yelp.desktop;\nx-scheme-handler/http=firefox.desktop;\nx-scheme-handler/https=firefox.desktop;\nx-scheme-handler/icy=org.gnome.Totem.desktop;\nx-scheme-handler/icyx=org.gnome.Totem.desktop;\nx-scheme-handler/info=yelp.desktop;\nx-scheme-handler/magnet=transmission-gtk.desktop;\nx-scheme-handler/mailto=thunderbird.desktop;\nx-scheme-handler/man=yelp.desktop;\nx-scheme-handler/mms=org.gnome.Totem.desktop;\nx-scheme-handler/mmsh=org.gnome.Totem.desktop;\nx-scheme-handler/net=org.gnome.Totem.desktop;\nx-scheme-handler/pnm=org.gnome.Totem.desktop;\nx-scheme-handler/rdp=org.remmina.Remmina.desktop;remmina-file.desktop;\nx-scheme-handler/remmina=org.remmina.Remmina.desktop;remmina-file.desktop;\nx-scheme-handler/rtmp=org.gnome.Totem.desktop;\nx-scheme-handler/rtp=org.gnome.Totem.desktop;\nx-scheme-handler/rtsp=org.gnome.Totem.desktop;\nx-scheme-handler/snap=snap-handle-link.desktop;\nx-scheme-handler/spice=org.remmina.Remmina.desktop;remmina-file.desktop;\nx-scheme-handler/uvox=org.gnome.Totem.desktop;\nx-scheme-handler/vnc=org.remmina.Remmina.desktop;remmina-file.desktop;\nx-scheme-handler/vnd.libreoffice.cmis=libreoffice-startcenter.desktop;\n\n```\nWhile a URL starting with a custom scheme might seem suspicious to cautious users, the\nexact target of a link can be hidden in applications that allow embedding HTML markup. An\nexample of such an application is the personal information management application\n[Evolution:](https://wiki.gnome.org/Apps/Evolution)\n\n\n-----\n\nFigure 1. Example of how a link target can be hidden in the Evolution application\n\nIn the previous URL handler listing, we have observed that the remote administration tool\n[Remmina is registered for the URL schemes](https://remmina.org/) `rdp,` `remmina,` `spice and` `vnc . The`\ncorresponding `.desktop file specified as part of the handler definition contains a reference`\nto the shell script `remmina-file-wrapper, which receives the specified URL as its second`\nargument ( %U placeholder):\n```\n$ cat /usr/share/applications/remmina-file.desktop\n[Desktop Entry]\n[...]\nExec=remmina-file-wrapper -c %U\nIcon=org.remmina.Remmina\nMimeType=application/x-remmina;x-scheme-handler/remmina;x-scheme-handler/rdp;xscheme-handler/spice;x-scheme-handler/vnc;\n[...]\n\n```\nThat shell script then starts the actual Remmina binary in case a matching URL is specified:\n\n\n-----\n\n```\n$ cat /usr/bin/remmina file wrapper\n#!/usr/bin/env bash\n[...]\nREMMINA=\"/usr/bin/remmina\"\nif [[ ! -f \"$REMMINA\" ]] ; then\n  REMMINA=\"${USRBIN}/remmina\"\nelse\n  REMMINA=\"remmina\"\nfi\nexport GLADE_HOME=\"$USRBIN/../share/remmina/ui/\"\ncase \"$@\" in\n  *rdp:*)\n    \"$REMMINA\" \"${@#rdp:\\/\\/}\"\n    ;;\n  *spice:*)\n    \"$REMMINA\" \"${@#spice:\\/\\/}\"\n    ;;\n  *vnc:*)\n    \"$REMMINA\" \"${@#vnc:\\/\\/}\"\n    ;;\n  *remmina:*)\n    \"$REMMINA\" \"${@#remmina:\\/\\/}\"\n    ;;\n  *)\n    \"$REMMINA\" \"${@}\"\n    ;;\nesac\n\n```\n[These URL handlers therefore open up quite a large attack surface that is reachable with](https://www.crowdstrike.com/cybersecurity-101/attack-surface/)\nminimal user interaction. As an example, clicking on a URL such as\n```\nvnc://user:pass@example.com/ automatically starts Remmina and instantly establishes\n\n```\na VNC connection with the given credentials to the specified remote host. Any vulnerability\naffecting Remmina’s VNC protocol implementation would therefore potentially allow for one[click exploitation scenarios. We therefore decided to take a closer look at libvncclient, which](https://github.com/LibVNC/libvncserver)\nis used by Remmina for its VNC support.\n\n## Code Auditing\n\n[Libvncclient implements the](https://libvnc.github.io/) [VNC protocol, which is based on the concept of a remote frame](https://datatracker.ietf.org/doc/html/rfc6143)\nbuffer. It offers functionality to transfer keystrokes and mouse inputs from the client to the\nserver while relaying the server’s graphical desktop as framebuffer updates to the client. The\noriginal specification of VNC’s underlying remote framebuffer protocol (RFB) was released in\n1998 and was relatively simple. However, over the years, various implementations added\nfurther features to optimize different aspects of the protocol, many of them aimed at reducing\n\n\n-----\n\nthe amount of data that needs to be transferred for framebuffer updates. On the flip side,\nthese optimizations naturally also resulted in more complexity and therefore an increased\n[attack surface.](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=vnc)\n\n[Two of these optimizations originate from the UltraVNC and](https://www.uvnc.com/) [TightVNC protocol](https://www.tightvnc.com/)\nimplementations and use custom encoding schemes. For compatibility reasons, both of\nthese schemes are also supported by libvncclient. As outlined in the following sections, a\nmanual code audit uncovered two distinct memory corruption vulnerabilities in the handling\nof these encoding schemes.\n\n### Heap Buffer Overflow in Ultra Encoding\n\nMessages from the VNC server to the client are handled by the\n```\nHandleRFBServerMessage() function. That function first reads the message type and then\n\n```\ncontinues to process the rest of the message accordingly. Framebuffer updates are\ntransmitted in messages of type `rfbFramebufferUpdate . These messages will then`\ncontain information about the number of rectangular framebuffer updates contained in the\nmessage, and for each rectangle, the data encoding (e.g., `rfbEncodingUltra for`\nUltraVNC encoding). The following source code excerpt from libvncclient shows the function\n```\nHandleUltraBPP(), which implements the processing of UltraVNC-encoded framebuffer\n\n```\nupdates:\n```\nstatic rfbBool\nHandleUltraBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n rfbZlibHeader hdr;\n int toRead=0;\n[...]\n lzo_uint uncompressedBytes = (( rw * rh ) * ( BPP / 8 ));\n if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n  return FALSE;\n toRead = rfbClientSwap32IfLE(hdr.nBytes);\n[...]\n\n```\nThe string `BPP in the function name will be expanded by the C preprocessor into three`\ndifferent functions for handling frame buffer updates with 8, 16 or 32 bits of color information\nper pixel. As shown in the listing, after reading the header from the socket via\n```\nReadFromRFBServer(), its field nBytes is used to set the signed integer variable\ntoRead . Afterward, toRead is used as the size to allocate a 4-byte aligned buffer\n\n```\n( ultra_buffer ) in case no previous one has been allocated in a prior invocation of the\nfunction, or if the previous one has an insufficient size:\n\n\n-----\n\n```\n[...]\n /* allocate enough space to store the incoming compressed packet */\n if ( client->ultra_buffer_size < toRead ) { if ( client->ultra_buffer != NULL ) {\n   free( client->ultra_buffer );\n  }\n  client->ultra_buffer_size = toRead;\n  /* buffer needs to be aligned on 4-byte boundaries */\n  if ((client->ultra_buffer_size % 4)!=0)\n   client->ultra_buffer_size += (4-(client->ultra_buffer_size % 4));\n  client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n[...]\n\n```\nAfterward, the code reads the amount of data specified by `toRead from the socket:`\n```\n[...]\n /* Fill the buffer, obtaining data from the server. */\n if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n   return FALSE;\n[...]\n\n```\nA malicious VNC server is able to fully control the value of the `toRead variable, including`\nnegative values. As a result, `ultra_buffer can be overflowed by first sending a frame`\nbuffer update that leads to an allocation of a certain size, followed by a second update that\nsets `toRead to a negative value. Then, the buffer allocated during the first frame buffer`\nupdate can be overflowed by the second one, as the condition `client-`\n```\n>ultra_buffer_size < toRead will not be fulfilled, leading to a call to\nReadFromRFBServer() where toRead is negative.\n\n```\nAs `ReadFromRFBServer() expects an unsigned integer value, the implicit type conversion`\nultimately leads to a `read() call with an overly large` `count value. The exact amount of`\ndata that is overwritten can be controlled by closing the underlying socket connection early.\n\n### Intra-Struct/Heap Overflow in Tight Encoding\n\nIn case Tight encoding is used for framebuffer updates, the function `HandleTightBPP() is`\ninvoked (similar to Ultra encoding, `BPP is a placeholder for the preprocessor). As shown in`\nthe following listing, the function reads the value `comp_ctl from the underlying socket:`\n\n\n-----\n\n```\nstatic rfbBool\nHandleTightBPP(rfbClient *client, int rx, int ry, int rw, int rh)\n{\n CARDBPP fill_colour;\n uint8_t comp_ctl;\n uint8_t filter_id;\n filterPtrBPP filterFn;\n z_streamp zs;\n int err, stream_id, compressedLen, bitsPixel;\n int bufferSize, rowSize, numRows, portionLen, rowsProcessed, extraBytes;\n rfbBool readUncompressed = FALSE;\n if (client->frameBuffer == NULL)\n  return FALSE;\n if (rx + rw > client->width || ry + rh > client->height)\n {\n  rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", rx, ry, rw, rh);\n  return FALSE;\n }\n if (!ReadFromRFBServer(client, (char *)&comp_ctl, 1))\n  return FALSE;\n[...]\n\n```\nThat value is used by the function to make a number of assumptions regarding the exact\nformat — e.g., it is used to select a filter function, defines the type of rectangle, and signals\nwhether compression is used. Later, the function `ReadCompactLen() is invoked to read the`\nvalue of `compressedLen from the underlying socket:`\n```\n[...]\n /* Read the length (1..3 bytes) of compressed data following. */\n compressedLen = (int)ReadCompactLen(client)\n[...]\nReadCompactLen() allows the server to specify a length value that uses up to three bytes.\n\n```\nThe most significant bits of the first one or two bytes specify whether another byte follows.\nTherefore, the specified size can consist of up to 22 bits (7 + 7 + 8). The maximum integer\nvalue that can be returned by the function is therefore 4,194,303 (2 ^ 22 – 1).\n\nIn case the client expects uncompressed data (indicated by `comp_ctl ),` `compressedLen`\nis passed to `ReadFromRFBServer() as the amount of data that is read into` `client-`\n```\n>buffer :\n[...]\n if (readUncompressed)\n {\n  if (!ReadFromRFBServer(client, (char *)client->buffer, compressedLen))\n   return FALSE;\n[...]\n\n```\n\n-----\n\nAs shown below, `client->buffer is a fixed-size array (307,200 bytes) located in the`\ncentral `rfbClient struct, which is heap-allocated for each connection:`\n```\ntypedef struct _rfbClient {\n     uint8_t* frameBuffer;\n[...]\n     int serverPort; /**< if -1, then use file recorded by vncrec */ rfbBool\nlistenSpecified; int listenPort, flashPort; struct { int x, y, w, h; } updateRect;\n/** Note that the CoRRE encoding uses this buffer and assumes it is big enough to\nhold 255 * 255 * 32 bits -> 260100 bytes. 640*480 = 307200 bytes.\n      Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.\n      Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */\n#define RFB_BUFFER_SIZE (640*480)\n     char buffer[RFB_BUFFER_SIZE];\n     char *bufoutptr;\n     unsigned int buffered;\n[...]\n\n```\nAs the maximum size of `compressedLen can exceed the size of the` `buffer struct`\nmember, the server is able to overflow said buffer and fully control the subsequent members\nof the `rfbClient struct as well as adjacent heap memory. This includes pointers through`\nwhich an arbitrary write primitive can be achieved as well as function pointers that allow\nhijacking of the control flow.\n\n## Fuzzing\n\nIn addition to manually auditing some of the libvncclient code base, we also made use of\n[afl++ to conduct fuzzing tests. To do so, we developed a thin wrapper around libvncclient’s](https://github.com/AFLplusplus/AFLplusplus)\nmain message dispatching function `HandleRFBServerMessage() . The argument for this`\nfunction is a client object that is configured to read framebuffer updates from `stdin . An`\nintroduction to the general methodology we applied to fuzzing in this case will be presented\nin a subsequent blog post.\n\nThrough fuzzing, we uncovered two additional bugs that are outlined below.\n\n### Heap Buffer Overflow in TRLE\n\nIn case a TRLE-encoded framebuffer update is received, the function `HandleTRLE() is`\ninvoked. As shown in the following source code excerpt, the function contains a loop that\nreceives an arbitrary amount of `0xFF bytes from the underlying socket into the heap-`\nallocated `client->raw_buffer :`\n\n\n-----\n\n```\nstatic rfbBool HandleTRLE(rfbClient client, int rx, int ry, int rw, int rh) {\n[...]\nuint8_t *buffer;\n[...]\nbuffer = (uint8_t*)(client->raw_buffer);\n[...]\nwhile (*buffer == 0xff) {\nif (!ReadFromRFBServer(client, (char*)buffer + 1, 1))\nreturn FALSE;\nlength += *buffer;\nbuffer++;\n}\n[...]\n}\n\n```\nAs there is no bounds check present, the buffer can be overflown by a malicious server.\n\n### Stack Buffer Overflow in ZRLE Encoding\n\nIn case a ZRLE-encoded framebuffer update is received, the function `HandleZRLE() is`\ninvoked. As shown in the following source code excerpt, the function first reads a structure of\ntype `rfbZRLEHeader from the server. Afterward, additional zlib-compressed data is`\nreceived.\n\n\n-----\n\n```\nstatic rfbBool HandleZRLE (rfbClient client, int rx, int ry, int rw, int rh)\n{\nwhile (( remaining > 0 ) && ( inflateResult == Z_OK )) {\n[...]\n          /* Fill the buffer, obtaining data from the server. */\n          if (!ReadFromRFBServer(client, client->buffer,toRead))\n              return FALSE;\n          client->decompStream.next_in = ( Bytef * )client->buffer;\n          client->decompStream.avail_in = toRead;\n          /* Need to uncompress buffer full. */\n          inflateResult = inflate( &client->decompStream, Z_SYNC_FLUSH );\n[...]\n     }\n     if ( inflateResult == Z_OK ) {\n[...]\n          for(j=0; j<rh; j+=rfbZRLETileHeight)\n              for(i=0; i<rw; i+=rfbZRLETileWidth) {\n[...]\nint result=HandleZRLETile(\nclient,\n(uint8_t *)buf,\nremaining,\nrx+i,\nry+j,\nsubWidth,\nsubHeight\n);\n[...]\n}\n\n```\nThe decompressed additional data is then passed to the function `HandleZRLETILE() as`\nthe parameter `buf . Its first byte determines the` `type of tile that is to be processed:`\n\n\n-----\n\n```\nstatic int HandleZRLETile(rfbClient client, uint8_t buffer,size_t buffer_length,\nint x,int y,int w,int h)\n{\n[...]\nuint8_t type;\n[...]\n     type = *buffer;\n     buffer++;\n[...]\n     if( type == 0 ) /* raw *\n[...]\n     else if( type == 1 ) /* solid */\n[...]\nelse if( type <= 127 ) { /* packed Palette */\n          CARDBPP palette[16];\n          int i,j,shift,\n[...]\n          /* read palette */\n          for(i=0; i<type; i++,buffer+=REALBPP/8)\n              palette[i] = UncompressCPixel(buffer);\n[...]\n}\n\n```\nAs shown in the above source code excerpt, in case `type is neither 0 nor 1 but less than or`\nequal to 127, a branch that handles a packed palette is taken. In this case, a stack-allocated\narray of 16 elements named `palette is declared. The exact value of` `type then`\ndetermines how many elements are read into the `palette array inside a for-loop. In case`\n```\ntype ’s value exceeds 16, an out-of-bounds write on the stack occurs.\n\n## Exploitability\n\n```\nWhile the outlined vulnerabilities allow to achieve an arbitrary write primitive and to fully\ncontrol the instruction pointer, the presence of address space layout randomization (ASLR)\nmakes exploitation difficult in a default Ubuntu x64 desktop environment. This is due to the\nfact that Remmina itself is compiled as a position-independent executable and is therefore\nsimilar to libraries loaded at a randomized location. Thus, an attacker has no fixed addresses\nto rely on. However, in case one of the vulnerabilities can be turned into an information leak,\nor by finding a separate bug allowing to disclose memory addresses, the outlined\nvulnerabilities would immediately allow for remote code execution.\n\n## Conclusion\n\n[While Linux distributions have begun to provide application-specific isolation mechanisms](https://ubuntu.com/core/docs/security-and-sandboxing)\n[and have also started to integrate sandboxing techniques in critical components that expose](https://gitlab.gnome.org/GNOME/tracker-miners/-/blob/master/src/libtracker-miners-common/tracker-seccomp.c)\ncomplex attack surfaces, many other parts of typical desktop environments have not been\nhardened in a similar fashion and remain comparably easy targets for exploitation. In the\ncase presented here, we were able to identify several memory corruption bugs that can be\ntriggered with minimal user interaction due to vulnerable URL handlers.\n\n\n-----\n\nSome of these were also identified through fuzzing, and we ll document our general\nmethodology in a subsequent blog post. The research is by far not exhaustive and should\nonly be considered to serve as an example of the extensive attack surface exposed by\ncustom URL handlers.\n\nIt is worth noting that Linux isn’t the only platform that exposes this type of attack surface. In\nfact, the recently disclosed MSHTML remote code execution vulnerability (CVE-2021-40444\n— for more information, see the [September 2021 Patch Tuesday update) on Windows](https://www.crowdstrike.com/blog/patch-tuesday-analysis-september-2021/)\noperating systems was also primarily enabled by the platform supporting and automatically\nadding custom protocol handlers for known file types.\n\nFinally, we would like to thank Christian Beier of the libvnc project for working with us and\ndeveloping patches for the bugs.\n\n**Additional Resources**\n\n_[Find out how CrowdStrike Intelligence uses fuzzing to hunt for bugs.](https://www.crowdstrike.com/blog/how-crowdstrike-intelligence-uses-fuzzing-to-hunt-for-bugs/)_\n_[Learn how CrowdStrike Falcon X combines automated analysis with human](https://www.crowdstrike.com/endpoint-security-products/falcon-x-threat-intelligence/)_\n_intelligence, enabling security teams, regardless of size or skill, to get ahead of the_\n_attacker’s next move._\n_[Falcon X Premium adds threat intelligence reporting and research from CrowdStrike](https://www.crowdstrike.com/resources/data-sheets/falcon-x-premium/)_\n_experts — enabling you to get ahead of nation-state, eCrime and hacktivist attacks._\n_[Falcon X Elite expands your team with access to an intelligence analyst to help defend](https://www.crowdstrike.com/endpoint-security-products/falcon-x-threat-intelligence/elite/)_\n_against threats targeting your organization._\n_Learn how to stop adversaries targeting your industry — schedule a free 1:1 intel_\n_briefing with a CrowdStrike threat intelligence expert today._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-09 - Scheming with URLs- One-Click Attack Surface in Linux Desktop Environments.pdf"
    ],
    "report_names": [
        "2021-11-09 - Scheming with URLs- One-Click Attack Surface in Linux Desktop Environments.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535753,
    "ts_updated_at": 1743041124,
    "ts_creation_date": 1653713334,
    "ts_modification_date": 1653713334,
    "files": {
        "pdf": "https://archive.orkl.eu/5fa485ad371ef8c25846c20c0c525fa1021c84a5.pdf",
        "text": "https://archive.orkl.eu/5fa485ad371ef8c25846c20c0c525fa1021c84a5.txt",
        "img": "https://archive.orkl.eu/5fa485ad371ef8c25846c20c0c525fa1021c84a5.jpg"
    }
}