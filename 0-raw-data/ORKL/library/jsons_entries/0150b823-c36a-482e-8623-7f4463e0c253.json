{
    "id": "0150b823-c36a-482e-8623-7f4463e0c253",
    "created_at": "2023-01-12T15:05:25.20085Z",
    "updated_at": "2025-03-27T02:08:40.22528Z",
    "deleted_at": null,
    "sha1_hash": "e41afec3b0d952b95911787752fc41d09a553af5",
    "title": "2020-05-31 - String Obfuscation in the Hamweq IRC-bot",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:27Z",
    "file_modification_date": "2022-05-29T01:19:27Z",
    "file_size": 75107,
    "plain_text": "# String Obfuscation in the Hamweq IRC-bot\n\n**[blag.nullteilerfrei.de/2020/05/31/string-obfuscation-in-the-hamweq-irc-bot/](https://blag.nullteilerfrei.de/2020/05/31/string-obfuscation-in-the-hamweq-irc-bot/)**\n\nborn\n\n[In this blog post, we will follow one of herrcore's awesome videos and re-implement the](https://www.youtube.com/watch?v=JPvcLLYR0tE)\nautomation as a Ghidra script in Java. The video in question is part of a series about a\n[legacy malware family called Hamweq.](https://malpedia.caad.fkie.fraunhofer.de/details/win.hamweq) CERT Polska published an extensive analysis of\nHamweq: The malware implements a IRC-based botnet with worm-like capabilities. In this\npost we will solely focus on the string deobfuscation functionality in the malware. ##\nIdentifying the String Deobfuscation Method Instantly after opening the sample\n```\n4eb33ce768def8f7db79ef935aabf1c712f78974237e96889e1be3ced0d7e619 in Ghidra,\n\n```\nyou can see four calls to `GetProcAddress . This method resolves an API function`\ndynamically, basically turning a string referencing a name of an API function into a pointer to\n[the corresponding function. According to the documentation, the second argument to](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)\n```\nGetProcAddress is that string. Following the memory address in Ghidra (by double\n```\nclicking) does not lead to any printable strings though. Hence _before_ these four calls to\n```\nGetProcAddress, these memory regions have to be modified during runtime. Otherwise,\nGetProcAddress would return the null pointer and calling that pointer, would crash the\n\n```\nprogram. The only two functions that can do this deobufscation step are `FUN_00402781`\nand `FUN_004027e1 . The first of the two seems to be doing something related to privileges,`\nbut since we want to focus on string obfuscation right now, we will not waste any time\nreverse engineering it but take a look at the function `FUN_004027e1 . This function accepts`\none string argument which is hard-coded to be `I0L0v3Y0u0V1rUs at this call. This is`\nprobably a reference to the famous ILOVEYOU virus from 2000 left by the malware author to\nour amusement. Because we are feeling lucky, let's rename `FUN_004027e1 to`\n```\npr_StringDeobfusaction . ## Optimizing Crappy Crypto pr_StringDeobfusaction\n\n```\nreferences the data at `0x00405020 and interprets it as an array of pointers to strings. Each`\nof these strings is then deobfuscated with a custom Xor-algorithm using the passed\nargument as a key. The deobfuscation algorithm is called on each of the referenced strings\nseparately: it first Xors each byte of the passed key onto each byte of the obfuscated data\nand then inverts every byte of the result. Since the Xor-operation is associative, the key can\nbe reduced to a single-byte Xor-key: For simplicity's sake, let us assume, the Xor key is not\n```\nI0L0v3Y0u0V1rUs but the sequence of numbers $23$, $42$ and $36$. Now let $x$ be a\n\n```\nsingle byte to be deobfuscated and let $\\otimes$ denote bit-wise Xor, then the following\nequation is true: \\[ ( ( x \\otimes 23) \\otimes 42) \\otimes 36 = x \\otimes (23 \\otimes 42 \\otimes\n36) = x \\otimes 25 \\] so instead of using the key $23$, $42$, $36$ one could simply use the\nkey $25$. Similarly, the key `I0L0v3Y0u0V1rUs can be reduced to $95$. The following Java`\nfunction implements this key-reduction:\n\n\n-----\n\n```\nprivate byte[] reduceKey(String key) {\n  byte ret[] = new byte[1];\n  for (byte b : key.getBytes()) {\n    ret[0] ^= b;\n  }\n  return ret;\n}\n\n```\n## Scripting We now want to write a script where the user specifies the address of the array\nof pointers to the obfuscated strings and Ghidra should then deobfuscate them all, print the\nresult, patch the data in memory, set the correct data-type and create bookmarks for all\ndeobfuscated strings:\n```\npublic void run() throws Exception {\n  byte[] key = reduceKey(\"I0L0v3Y0u0V1rUs\");\n  Address stringTable = askAddress(\"Enter Address\", \"Specify address of string\ntable\");\n  while (true) {\n    Address stringAddress = unpackAddressLE(getOriginalBytes(stringTable, 4));\n    if (stringAddress.getOffset() == 0)\n      break;\n    byte data[] = getOriginalBytes(stringAddress, 0x40);\n    if (data == null) {\n      break;\n    }\n    byte cypherText[] = readUntilZeroByte(data);\n    byte plainText[] = cryptXorAndInvert(cypherText, key);\n    println(String.format(\"0x%08X %s\", stringAddress.getOffset(), new\nString(plainText)));\n    setBytes(stringAddress, plainText);\n    clearListing(stringAddress, stringAddress.add(plainText.length - 1));\n    createData(stringAddress, new ArrayDataType(CharDataType.dataType,\nplainText.length, 1));\n    createBookmark(stringAddress, \"DeobfuscatedString\", new String(plainText));\n    stringTable = toAddr(stringTable.getOffset() + 4);\n  }\n}\n\n```\nThe only missing part now is the actual decryption routine:\n```\nprivate byte[] cryptXorAndInvert(byte[] data, byte[] key) {\n  final byte[] ret = new byte[data.length];\n  for (int k = 0; k < data.length; k++)\n    ret[k] = (byte) (~(data[k] ^ key[k % key.length]));\n  return ret;\n}\n\n```\nAs always, the complete script to deobfuscate strings from a Hamweq sample can be found\non GitHub.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-31 - String Obfuscation in the Hamweq IRC-bot.pdf"
    ],
    "report_names": [
        "2020-05-31 - String Obfuscation in the Hamweq IRC-bot.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535925,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653787167,
    "ts_modification_date": 1653787167,
    "files": {
        "pdf": "https://archive.orkl.eu/e41afec3b0d952b95911787752fc41d09a553af5.pdf",
        "text": "https://archive.orkl.eu/e41afec3b0d952b95911787752fc41d09a553af5.txt",
        "img": "https://archive.orkl.eu/e41afec3b0d952b95911787752fc41d09a553af5.jpg"
    }
}