{
    "id": "7cd66cf8-6014-4e38-9ce1-e54729c2d11d",
    "created_at": "2023-01-12T14:59:00.210817Z",
    "updated_at": "2025-03-27T02:09:29.461606Z",
    "deleted_at": null,
    "sha1_hash": "8ca84aa69fc64544a508db3b79bd97903d7cdaa5",
    "title": "2021-11-02 - Cobalt Strike Process Injection",
    "authors": "",
    "file_creation_date": "2022-05-28T05:03:45Z",
    "file_modification_date": "2022-05-28T05:03:45Z",
    "file_size": 2051324,
    "plain_text": "# Cobalt Strike Process Injection\n\n**boschko.ca/cobalt-strike-process-injection/**\n\nOlivier Laflamme November 2, 2021\n\n[Windows Internal](https://boschko.ca/tag/windows-internal/)\nDiscussing the various methods that Cobalt Strike uses to perform process injection.\n\n**[Olivier Laflamme](https://boschko.ca/author/olivier/)**\n\nNov 2, 2021 • 14 min read\n\n\n-----\n\nI ve documented some of my thoughts and ideas around process injection. In this blog will\nmostly cover some technical details about Cobalt Strike's process injection, as well as some\nof the red team attack techniques you may want to know?\n\n## Injection Function\n\nCobalt Strike currently provides process injection functions in some scenarios. The most\ncommon is to directly inject payload into a new process. This function can be executed\n[through various sessions that you have obtained, such as Artifact Kit,](https://www.cobaltstrike.com/help-artifact-kit) [Applet Kit and](https://www.youtube.com/watch?v=QvQerXsPSvc)\n[Resource Kit. This article will focus on Cobalt Strike's process injection in Beacon sessions.](https://www.cobaltstrike.com/help-resource-kit)\n\nThe `shinject command injects code into any remote process, some built-in post-`\nexploitation modules can also be injected to a particular remote process through this method.\nCobalt Strike did this because injecting shellocde into a new session would be safer than\nmigrating the session directly to another C2.\n\n(Probably the reason is that if the new session is not pulled up, it will be embarrassing if the\noriginal session has dropped.)\n\nTherefore, Cobalt Strike \"post-exploitation\" will start a temporary process when it is\nexecuted, and inject the DLL file corresponding to the payload into the process, and confirm\nthe result of the injection by retrieving the named pipe. Of course, this is just a special case\nof process injection. In this way, we can safely operate the main thread of these temporary\nprocesses without worrying about operation errors that cause the program to crash and\nresult in loss of permissions. This is a very important detail to understand when learning to\nuse Cobalt Strike injection process.\n\nThe first parameter of the inject command mentioned in the original text is the PID of the\ntarget program to be injected, and the second parameter is the architecture of the target\nprogram. If not filled, the default is x86.\n```\ninject 7696 x64\n\n```\n\n-----\n\nThe parameter writing method of `shinject is the same as that of inject. If the third`\nparameter is not written, you will be prompted to select a shellcode file. Pay attention to the\nbin format payload that needs to be generated.\n```\nshinject 7696 x64 C:\\Users\\VM_Windows\\Documents\\payload.bin\n\n```\nIn addition to the two beacon commands mentioned above, in fact, there is also a `shspawn .`\nIts role is to start a process and inject shellcode into it. The parameters only need to select\nthe program architecture.\n```\nshspawn x64 C:\\Users\\VM_Windows\\Documents\\payload.bin\n\n```\n\n-----\n\nAs shown in the figure, the payload is injected into the dllhost.exe program. This method is\nmuch more stable than the first two, and you are not afraid of crashing the program.\nshspawn and shinject are quite flexible because they allow us to provide any arbitrary\nshellcode – including 64-bit and stageless.\n\n**So whats actually going on?**\n\n## Prior Knowledge\n\nTo better understand all that follows lets take a step back and have a look at sacrificial\nprocesses by looking at execute-assembly.\n\nIn a nutshell, whats happening when you're invoking execute-assembly is that you're going\nto create a new job (as the function highly suggests) but the beauty of it is that there is a\n```\n spawn and as you can see the only difference between the two lines is just the\n\n```\n\n-----\n\narchitecture.\n\nSo if the beacon that is running on the target is x64 its actually going to spawn a new x64\njob, if not its going to spin a 32bit version.\n\nThe main takeaway isevery time you see `.spawn, especially with the BIDs which is the`\nreference to the current beacon running on the target, this is where things can get slightly\ndangerous if you dont understand whats happening.\n\nIn a nutshell, there is a concept in Cobalt Strike that is called sacrificial process. What is\ndoes is pretty simply. Its just going to spawn a process, and inject itself into it and do\nwhatever you asked for it to invoke. The main reason / the idea behind this is that your main\nbeacon is not going to die regardless of whatever you're running. Because technically, you\ncould kill your beacon if you're doing something extremely bad, and its just corrupting the\nwhole process, and you'd lose your foothold. So the idea here is that you're going to inject\ninside of a process that is not related to the current process.\n\nTherefore, even if you execute something in assembly and its not working the way its\nsupposed to then its just going to kill the sacrificial process as opposed to killing your whole\nbeacon.\n\nThe thing is, you might think that \"oh that's super cool ill just run my .net payload with\nexecute-assembly and nothing bad will happen\" but in reality if you look at the code there is\nno indicator that you're actually creating a remote process. Which is something that you\n\n\n-----\n\nshould keep in mind.\n\nSo the main takeaway is that you might want to have a list of all the functionality that uses\nthe `.spawn function because you may want to avoid doing remote process injection in some`\nspecific cases. Every time you see `.spawn in the CS code its pretty sure that it'll create a`\nnew process. This is something to keep in mind.\n\nYou'll also see something called SetupSmartInject and all that kind of stuff.\n\nReally, all that is is setting up everything needed to inject inside of the remote process. And\nhere its just using some internal magic to try an obfuscate what you're trying to do. But once\nagain, when it comes to EDR's and stuff like that, if you don't try and actually hide yourself\n\n\n-----\n\nyou re probably still going to raise alerts about the fact that you remotely created a process.\nAnd this is something that can be configured in your malleable profile.\n\n[This is a typical malleable config file. The idea behind these are that because most of the](https://github.com/threatexpress/malleable-c2/blob/master/jquery-c2.4.3.profile%20)\ntime its going to be using http so you'll want to customize your http traffic to blend into\nlegitimate traffic.\n\nSo this is usually where you have your SpawnTo Process information. As you can see the\nsacrificial process can actually be defined for both architectures. But whats important is that\nyou can specify which function you want to use when you do remote process injection. So\nyou can specify how you want to do it and in which order.\n\nBefore diving deeper into this, its always a good thing to disable the one's you think is\ninsecure. We'll discuss all about this further down the blog.\n\nIn this case the `NtQueueApcThread was commented out so you wont be using that one. By`\ndefault the top 6 listed are what you \"can\" use. `CreateThread as you know is only going to`\nbe used to create a thread inside of the remote process. `CreateRemoteThread is fairly safe`\nIF you had EDR unhooking in place. `NtQueueApcThread is probably the least secure one`\nof them. The reason is that `QueueApcThread is actually hijacking an existing thread most of`\nthe time. So sometimes if you're hijacking something that you shouldn't then you may run\ninto some unintended issues, so if possible avoid this at all costs. The other ones are more\nor less the same as `CreateRemoteThread just using a different approach. This is in my`\nopinion super important when it comes to process injection, because as we've just seen\nabove some CS functionality will force you to have process injection by default. And the ones\n\n\n-----\n\nthat rely on sacrificial processes will always call `.spawn and will always end up injecting`\ninside of a remote process. The process is actually going to be the one that you specify in\nyour profile, so technically you could have a different one for x64 and x86.\n\nNow there is quite a lot of people who have lists of processes that get spawned all the time\nthat don't live for to long so you could try to mimic that.\n\n## Injection Process\n\nThe [process-inject block in Cobalt Strike's Malleable C2 configuration file is where the](https://www.cobaltstrike.com/help-malleable-postex#processinject)\nconfigurations for process injection is defined. So this is usually where you have your\nSpawnTo Process information.\n```\nprocess-inject {\n  # set remote memory allocation technique\n  set allocator \"NtMapViewOfSection\";\n  # shape the content and properties of what we will inject\n  set min_alloc \"16384\";\n  set userwx  \"false\";\n  transform-x86 {\n    prepend \"\\x90\";\n  }\n  transform-x64 {\n    prepend \"\\x90\";\n  }\n  # specify how we execute code in the remote process\n  execute {\n    CreateThread \"ntdll!RtlUserThreadStart\";\n    CreateThread;\n    NtQueueApcThread-s;\n    CreateRemoteThread;\n    RtlCreateUserThread;\n  }\n}\n\n```\nSo, the execution flow for process-inject block of code in Cobalt Strike's Malleable profile is\nroughly as follows:\n\n1. Open the handle of the remote process.\n2. Allocate memory in remote processes.\n3. Copy the shellcode to the remote process.\n4. Execute shellcode in the remote process.\n\n**Step 1:**\n\n\n-----\n\nThe first step is to distribute and copy data to the remote host. If we start a temporary\nprocess; that is, we already have a handle to the remote process, at this time if we want to\n[inject the code into the existing remote process Cobalt Strike will use OpenProcess to solve](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\nthis problem.\n\n**Step 2:**\n\nCobalt Strike provides two options for allocating memory and copying data into remote\nprocesses.\n\nThe first solution is the classic: `VirtualAllocEx -> WriteProcessMemorypattern, which`\nis very common in attack tools. It is worth mentioning that this solution is also applicable to\ndifferent process architectures, and the application of process injection is not limited to the\ninjection of x64 target processes. This means that a good solution needs to take into account\nthe different extreme situations that can occur (for example, x86-> x64, or x64-> x86, etc.).\nThis makes it `VirtualAllocEx a relatively reliable choice, and Cobalt Strike's default`\nsolution is also this. If you want to directly specify this mode, you can set `process-inject`\n\n`allocator` option `VirtualAllocEx .`\n\nThe second solution provided by Cobalt Strike is `CreateFileMapping ->` `MapViewOfFile`\n-> `NtMapViewOfSection mode. This solution will first create a mapping file that supports`\nthe Windows system, and then map the view of the mapping file to the current process. Then\nCobalt Strike will copy the injected data to the memory associated with the view and\n```\nNtMapViewOfSection call our remote process. To use this scheme you can set the\nallocator to NtMapViewOfSection . The disadvantage of this scheme is only for x86\n-> x86 and x64 -> x64, regarding the cross-architecture injection when Cobalt\n\n```\nStrike will automatically switch back to `VirtualAllocEx mode.`\n\nWhen `VirtualAllocEx ->` `WriteProcessMemory mode injection is subject to soft`\ndefense it is also a good choice to try this scheme instead. (It is very useful when killing\nsoftware without detecting other methods of copying data to a remote process.)\n\n**Step 3:**\n\nThe third step is data conversion. Step 2 and this step as mentioned above assume that\neverything is normal and the original data is copied to the injected data, which is almost\nimpossible in a real environment. To this end, Cobalt Strike's `process-inject adds the`\nfunction of transforming and injecting data. The `min_alloc option is the minimum size of`\nthe block that Beacon will allocate in the remote process, `startrwx and the` `userwx`\noption is the initial Boolean value of the allocated memory and the final permission of the\nallocated memory. If you want to prohibit data from being readable, writable, and executable\n( RWX ), please set these values  to `false .` `transform-x86 and those that` `transform-`\n```\nx64 support converting data to another architecture. If you need to add data in advance,\n\n```\nmake sure it is executable code for the corresponding architecture.\n\n\n-----\n\nNote, many content signatures look for specific bytes at a fixed offset at the beginning of the\nobservable boundary. These checks occur in O (1) time, which is conducive to O (n) search.\nExcessive Inspection and security technology may consume a lot of memory, and\nperformance will be reduced accordingly.\n\n[Binary padding also affects post-exploitation of the thread start address offset in Cobalt](https://attack.mitre.org/techniques/T1009/)\nStrike. When a Beacon injects a DLL into memory; its `ReflectiveLoader starts the thread`\nat the position where the function exported by the DLL should be. This offset is shown in the\nthread start address feature, and is looking for a specific \"post-exploitation\" DLL of potential\nindicators. The data before injection into the DLL will affect this offset. (It ’s okay not to know\nabout thread related things, I will talk about it next ...)\n\n**Step 4:**\n\nThe fourth step is code execution. To better understand all of this let's take a look at the\nsubtle differences between different execution methods in a beacon:\n\n**CreateThread**\n```\nCreateThread from the beginning. I think that CreateThread if it exists, should first\n\n```\nappear in an execution block, this function only runs when it is limited to self-injection. Using\n```\nCreateThread will start a thread pointing to the code you want your Beacon to run. But be\n\n```\ncareful, when you self-inject in this way, the thread you pull will have a starting address,\nwhich is not related to the module (by module I mean DLL / current program itself) loaded\ninto the current process space. For this you can specify `CreateThread“module！`\n```\nsomefunction + 0x ##” . This variant will generate a suspended thread that points to the\n\n```\nspecified function, if the specified function cannot be `GetProcAddressobtained this is`\nbecause Beacon will use to `SetThreadContextupdate and will use this new thread to run`\nthe injected code, which is also a self-injection method that can provide you with a more\nfavorable foothold.\n\n**SetThreadContext**\n\nNext is `SetThreadContext, which is used in post-exploitation. One of the main thread`\nmethod interim process tasks generated. The Beacon is `SetThreadContext suitable for`\n```\nx86 -> x86, x64 -> x64and x64-> x86 . If you choose to use it SetThreadContext,\n\n```\nplace it in `CreateThread after the option in the execution block.` `SetThreadContext`\nwhen used; your thread will have a starting address that reflects the original execution entry\npoint of the temporary process which is very nice.\n\n**NtQueueApcThread-s**\n\nAnother way to suspend a process is to use it `NtQueueApcThread-s . This method uses`\n```\nNtQueueApcThread which is a one-time function to queue up when the target thread wakes\n\n```\nup next time. In this case, the target thread is the main thread of the temporary process. The\n\n\n-----\n\nnext step is to call `ResumeThread, this function wakes up the main thread of our suspended`\nprocess, because the process has been suspended at this time, we do not have to worry\nabout returning this main thread to the process. This method only applies to `x86 -> x86`\n```\nand x64 -> x64 .\n\n```\nDetermining whether to use `SetThreadContext or` `NtQueueApcThread-s depends on`\nyou. In most cases I think the latter is obviously more convenient.\n\n**NtQueueApcThread**\n\nAnother approach is through `NtQueueApcThread it is like` `NtQueueApcThread-sun but it`\ntargets existing remote processes. This method needs to push the RWX stub to the remote\nprocess. This stub contains the code related to the injection. To execute the stub, you need\nto add the stub to the APC queue of each thread in the remote process. The stub code will\nbe executed.\n\nSo what is the role of stubs?\n\nFirst, the stub checks whether it is already running, and if it is, it executes nothing, preventing\nthe injected code from running multiple times.\n\nThen the stub will be called with the code and its parameters we injected `CreateThread .`\nThis is done to let APC return quickly and let the original thread continue to work.\n\nNo thread will wake up and execute our stub. Beacon will wait about 200ms to start and\ncheck the stub to determine whether the code is still running. If not, update the stub and\nmark the injection as already running, and continue to the next item. This It is\n```\nNtQueueApcThread the implementation details of the technology.\n\n```\nAt present, I have used this method a few times, because some security products have very\nlittle attention to this incident. In other words, OPSEC has paid attention to it, and it is indeed\na memory indicator that promotes RWX stubs. It will also call the code of the remote process\nthat we push `CreateThread . The starting address of the thread does not support the`\nmodule on the disk. Use `Get-InjectedThread scan not effectively. If you think this`\ninjection method is valuable, please continue to use it. Pay attention to weighing its pros and\ncons. It is worth mentioning that this method is limited to x86 -> x86 and x64 -> x64.\n\n**CreateRemoteThread**\n\nAnother way is via `CreateRemoteThread which can be used literally as a remote injection`\ntechnology. Starting with Windows Vista, injecting code across session boundaries will fail. In\nCobalt Strike, `vanilla CreateRemoteThreadcovers` `x86 -> x86, x64 -> x64 and`\n```\nx64 -> x86 . The movement of this technology is also obvious. When this method is used to\n\n```\ncreate a thread in another process, it will trigger event 8 of the system monitoring tool\nSysmon. Such, Beacon has indeed implemented a `CreateRemoteThread variant that`\n\n\n-----\n\n`module！function + 0x ##` accepts a pseudo start address in the form\nCreateThreadSimilarly, Beacon will create its thread in the suspended state and use\n```\nSetThreadContext / ResumeThread enable to execute our code. This variant is limited to\nx86 -> x86 and x64 -> x64 . If the GetProcAddress specified function cannot be used,\n\n```\nthis variant will also fail.\n\n**RtlCreateUserThread**\n\nThe last way Cobalt Strike executes blocks is `RtlCreateUserThread . This way`\n```\nCreateRemoteThread functions is very enjoyable but has some limitations, it is not perfect\n\n```\nand has flaws.\n```\nRtlCreateUserThread code will be injected across the session boundary. It is said that\n\n```\nthere will be many problems during the injection on Windows XP. This method will also\ntrigger event 8 of the system monitoring tool Sysmon. One benefit is that it covers `x86->`\n```\nx86, x64-> x64, x64-> x86, and x86-> x64, the last case is very important.\nx86 -> x64 injection are in x86 Beacon carried out sessions. And for your post\n```\n_exploitation generation process x64 tasks, hashdump,_ `mimikatz,` `execute-assembly`\nand `powerpick modules are silent as x64. In order to achieve` `x86 -> x64 injection, this`\nmethod converts the x86 process to x64 mode and injects RWX stubs to facilitate calling\nfrom x64 `RtlCreateUserThread . This technique comes from Meterpreter. RWX stubs are`\na pretty good memory indicator. I have long suggested: \"Let the process stay in x64 mode as\nmuch as possible\", the above situation is why I would say this, and it is also recommended to\nput one in all. So `process-inject is the lowest way to have it, you can use it when there`\nis no other `work execute blockRtlCreateUserThread`\n\n### How to Live Without Process Injection\n\nWhen thinking about how to use these attack techniques flexibly, I was also thinking what to\ndo if none of these methods work?\n\nProcess injection is a technique used to, at its core transfer payload / capability to migrate to\ndifferent processes (such as from desktop session `0 to desktop session` `1 ), you can use`\nthe `runu command to transfer to different processes without process injection, (in other`\nwords, you can run `runu if you want to run a command under a parent in another desktop`\nsession.) and you can specify the program that you want to run as child processes of any\nprocess. This is a way to introduce a session to another desktop session without process\ninjection.\n\n\n-----\n\nProcess injection is also one of the methods to execute code without landing files on the\ntarget. Many post-exploitation functions in Cobalt Strike can choose to attack specific\nprocesses. For example, specifying the current Beacon process can be leveraged without\nhaving to perform a remote injection. This is more-or-less self-injection.\n\nOf course, life is not perfect and it is not perfect to execute code without a \"file on the\nground\". Sometimes it is best to put something on the disk.\n\nReferences:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-02 - Cobalt Strike Process Injection.pdf"
    ],
    "report_names": [
        "2021-11-02 - Cobalt Strike Process Injection.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535540,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653714225,
    "ts_modification_date": 1653714225,
    "files": {
        "pdf": "https://archive.orkl.eu/8ca84aa69fc64544a508db3b79bd97903d7cdaa5.pdf",
        "text": "https://archive.orkl.eu/8ca84aa69fc64544a508db3b79bd97903d7cdaa5.txt",
        "img": "https://archive.orkl.eu/8ca84aa69fc64544a508db3b79bd97903d7cdaa5.jpg"
    }
}