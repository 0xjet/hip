{
    "id": "fd2940d4-5bdb-4aac-b035-889e41d968c4",
    "created_at": "2023-01-12T15:08:22.505228Z",
    "updated_at": "2025-03-27T02:17:11.64052Z",
    "deleted_at": null,
    "sha1_hash": "503ac4da325f205a965df60f0312c3d866f8e11a",
    "title": "2016-12-01 - Alert (TA16-336A)- Avalanche (crimeware-as-a-service infrastructure)",
    "authors": "",
    "file_creation_date": "2021-03-25T16:25:41Z",
    "file_modification_date": "2022-05-01T17:11:48Z",
    "file_size": 722759,
    "plain_text": "# Persistence in Linux-Based IoT Malware\n\nCalvin Brierley, Jamie Pont, Budi Arief, David J. Barnes, and Julio\nHernandez-Castro\n\nSchool of Computing, University of Kent, Canterbury, England\n_{C.R.Brierley, J.Pont, B.Arief, D.J.Barnes, jch27}@kent.ac.uk_\n\n**Abstract. The Internet of Things (IoT) is a rapidly growing collection**\nof “smart” devices capable of communicating over the Internet. Being\nconnected to the Internet brings new features and convenience, but it\nalso poses new security threats, such as IoT malware. IoT malware has\nshown similar growth, making IoT devices highly vulnerable to remote\ncompromise. However, most IoT malware variants do not exhibit the\nability to gain persistence, as they typically lose control over the compromised device when the device is restarted. This paper investigates\nhow persistence for various IoT devices can be implemented by attackers, such that they retain control even after the device has been rebooted.\nHaving persistence would make it harder to remove IoT malware. We investigated methods that could be used by an attacker to gain persistence\non a variety of IoT devices, and compiled the requirements and potential\nissues faced by these methods, in order to understand how best to combat\nthis future threat. We successfully used these methods to gain persistence\non four vulnerable IoT devices with differing designs, features and architectures. We also identified ways to counter them. This work highlights\nthe enormous risk that persistence poses to potentially billions of IoT devices, and we hope our results and study will encourage manufacturers\nand developers to consider implementing our proposed countermeasures\nor create new techniques to combat this nascent threat.\n\n**Keywords: IoT · security · malware · persistence · attack · proof of concept**\n\n## 1 Introduction\n\nA standard piece of advice typically given to affected users for removing malware\nfrom an Internet of Things (IoT) device is to restart it, as most forms of IoT\nmalware lack the ability to maintain persistence [3,4]. This is because, in general,\nIoT malware is stored and executed from within temporary filesystems that\nreside in Random-Access Memory (RAM) [32]. As this type of memory is volatile,\nthe stored programs and data are lost when the device loses power, including\nany changes that the attacker may have made to the filesystem.\n\nThis is an earlier version of the paper that was published at Nordsec 2020. The final\n[authenticated publication is available online at https://doi.org/10.1007/978-3-](https://doi.org/10.1007/978-3-030-70852-8_1)\n```\n 030-70852-8 1\n\n```\n\n-----\n\n2 C. Brierley, J. Pont et al.\n\nHowever, there have been some families of IoT malware that are able to\nmaintain persistence in some form [15,27]. If persistent IoT malware becomes\nmore prevalent, many IoT devices will not be recoverable at all once they have\nbeen infected. Therefore, it is increasingly crucial for IoT developers both to\n_understand their devices’ potential vulnerabilities to persistence and to implement_\n_preventative measures to prohibit attackers from exploiting them. These two aims_\nserve as the motivation for our work.\n**Contributions. The key contributions of this paper are:**\n\n**– We summarise IoT persistence and its role in IoT based malware.**\n**– We explain the challenges currently preventing IoT malware from establish-**\ning persistence.\n**– We outline methods that could be used by IoT malware to gain persistence.**\n**– Finally, we explore how this will change the approach of IoT malware and**\nhow attackers could achieve and use persistence to perform new and previously infeasible attacks, and what can be done to counter this threat.\n\nIn Section 2 we give some background on Linux malware, IoT based malware\nand persistence. We also highlight previous research and some of the challenges\nattackers may encounter when attempting to gain persistence on IoT devices. In\nSection 3, we describe several methods that could be used by attackers to gain\npersistence on various types of IoT device, along with their requirements and\nlimitations. In Section 4 we show the results of attempting to gain persistence\non four vulnerable IoT devices using these methods. In Section 5, we discuss\nsome potential countermeasures that could be implemented to prevent an attacker from gaining persistence on an IoT device. Finally, Section 6 covers our\nconclusions and defines some recommended further work.\n\n## 2 Background\n\nVarious families of malware have increasingly attacked IoT devices. Popular botnets such as Bashlite and Mirai have infected hundreds of thousands of devices\nand have been responsible for one of the largest DDoS attacks in history [33,11].\nFortunately, this type of IoT malware is relatively simple to remove. By restarting the device, the malware will be unloaded from volatile memory, removing\nthe infection from the device when it reboots [3,4].\nHowever, some malware (such as Mirai) often exhibits worm-like behaviour\n\n[5] and after hijacking a device, it will scan the Internet for more victims to\ninfect. While users would sometimes restart their devices (either deliberately or\ncoincidentally) and clear the infection, it would not remove the underlying issue.\nThe devices could easily be reinfected, possibly within minutes [3].\nIn effect, this behaviour has led to competitions between botnet authors, each\nseeking to maximise their share of the limited number of vulnerable IoT devices.\nSome malware even exhibited security features to remove competing malware.\nMirai, for instance, would search for strings present in competing malware, kill\nany associated running processes and close any potentially vulnerable services\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 3\n\nrunning on specific ports to prevent any further attacks by competitors [5].\nHowever, these changes were not persistent and would be removed when the\ndevice was reset.\n\n**2.1** **Persistent IoT Malware**\n\nIoT malware capable of making persistent changes that secure its presence would\nbe able to maintain control over the device through reboots, both removing the\nrequirement to reinfect the equipment and helping towards keeping competitors\nat bay. The ability to secure persistence would also allow significant changes to\nthe device to persist after rebooting, allowing for more creative types of malware\nand attacks, such as ransomware [10] or long term spyware. This would also\nprovide a means for the malware operator to install additional malicious features,\nsuch as modules that can attack other devices on the infected device’s network.\nCurrently, restarting an infected device will remove the majority of IoT malware, but with persistence, the user would have to modify the flash memory of\nthe device to remove the infection. This is something not usually readily available nor practical to an average user. If the malware can also prevent updates\nor factory resets, specialist equipment or access to a debug/programming interface may be required to clear the infection. This is considered too complicated\nfor most IoT users to perform and may lead to IoT devices being discarded, or\nworse, knowingly left in an infected state.\n\n**2.2** **Challenges With Gaining Persistence**\n\nThere are two key challenges currently faced by IoT attackers when attempting\nto gain persistence on IoT devices:\n\n**– Read-Only. IoT devices often have data that is set to read-only for various**\nreasons, such as to prevent accidental modifications by programmer error.\nThis feature may also prevent attackers from making the necessary modifications to gain persistence.\n**– Variance. Each device is likely to have different hardware, update mecha-**\nnisms, software, architecture and filesystem types. Fortunately for IoT developers, the variation in IoT devices makes it quite difficult for attackers\nto create a universal method for gaining persistence. However, if an attacker\nwere to develop a method that affects a large number of devices with similar\nimplementation, it could reduce the required time investment immensely,\nleading to persistent IoT Malware becoming more common.\n\n**2.3** **Previous Persistent IoT Malware and Related Work**\n\nAfter identifying an increase in the presence of Linux based malware, researchers\nanalysed 10,548 samples over a year to gain a better understanding of the techniques used by malware authors [12]. They highlighted the quick development\n\n\n-----\n\n4 C. Brierley, J. Pont et al.\n\nand deployment of insecure IoT devices as a potential motive for attackers to\ntarget Linux for malware development.\nAs part of this analysis, they found that 21.10% (1,644) of the analysed samples implemented persistence methods. Some of these methods can be applied\nto IoT devices, but the attacker must be able to modify the filesystem. As mentioned previously, IoT devices often set certain data as read only, which would\nprevent these methods from working.\nSome IoT malware has achieved persistence, but it is less common and typically relies on a device having a writeable filesystem, which may reduce its\napplicability. We examine two examples of persistent IoT malware below.\n**Torii is a variant of Mirai that adds several features, most notably the intro-**\nduction of six techniques to gain persistence [15]. Each technique modifies files\non the infected device which are executed as part of the boot process, such as:\n\n**– .bashrc, which is executed whenever an interactive bash session is started;**\n**– initab, which is used to determine which processes should be ran during**\nthe Linux boot process at certain runlevels;\n**– crontab, which is used to execute files at a certain time or interval.**\nModifications to these files would allow the attacker to set particular programs or shell scripts to be run when the device boots.\n**VPNFilter is a complex IoT malware which affects a large number of routers**\n\n[30]. It is believed to have been developed by “Fancy Bear”, a Russian based\nhacker group [31]. Its modular structure allows many features to be implemented,\nranging from man-in-the-middle attacks to SCADA sniffing. Additionally, VPNFilter seems to include a section of code to erase and rewrite Memory Technology\nDevices (MTDs)[1], which could potentially be used to brick the device by wiping\nsegments of the device’s storage [28].\nVPNFilter modifies the /etc/config/crontab file, which will run the malware (which has presumably already been written to memory) every 5 minutes\n\n[27,29], even when the device is rebooted.\n\n## 3 Methods for Gaining Persistence\n\nDue to the challenges described in section 2.2, no universal methods to gain\npersistence on IoT devices have yet been identified. Instead, our approach is to\nuse a collection of methods to gain persistence on certain subsets of IoT devices.\nWe have identified several viable methods that could be used by an attacker\nto gain persistence on a variety of IoT devices. A summary of these methods can\nbe found in Table 1 and a detailed overview of each is provided in the following\nsubsections. The description of each method includes a list of requirements for\nits applicability, its feasibility, and any potential issues that may prevent it from\nworking effectively. A malware writer could perform reconnaissance to ascertain\nwhich method should be used, or simply attempt each method sequentially until\n\n1 Memory Technology Devices (MTD) are commonly used to communicate with flash\ndevices to manage storage on IoT devices.\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 5\n\n**Table 1. IoT Persistence Methods**\n\n**ID Method** **Modified Partition** **Complexity**\nA Modifying Writeable Filesystems Filesystem Low\nB Recreating Read-Only Filesystems Filesystem Medium\nC Initrd/Initramfs Modification Kernel High\nD “Set Writeable Flag” Kernel Module N/A High\nE Update Process Exploitation Filesystem/Kernel Device Dependant\nF UbootKit Bootloader High\n\nthey gain persistence. Some methods could be used in conjunction with others\nto improve their chances of success.\nThe techniques described assume that the attacker has gained access to the\nshell (such as via a guessable telnet password), and can run arbitrary commands.\nIdeally, the attacker should be able to determine the storage capabilities of the\ndevice and identify the device model.\nMany of these techniques also require the identification and modification of\nfilesystems and partitions in flash memory. The /proc/mtd file contains the partition definition and a name set by the developer via MTD, which may indicate\nits purpose. These partitions can be accessed by using the files /dev/mtdX or\n```\n/dev/mtdblockX where X is the partition index. The attacker can also find\n\n```\na list of mount points and their filesystem types in the /proc/mounts file, or\nuse analytic tools such as Binwalk [25] to identify recognisable file headers and\nmetadata.\n\n**3.1** **Modifying Writable Filesystems**\n\nWhen an IoT device has a writeable filesystem by default, the attacker should\nbe able to modify the filesystem directly via the shell, allowing them to edit\nimportant files that run on startup.\n**Requirements: The device must use a writable filesystem (e.g. yaffs2/**\n```\njffs2). The MTD filesystem partitions must be writeable. The attacker must\n\n```\nbe able to modify the startup scripts.\n**Feasibility: This is the simplest method and does not require any additional**\ntools. If the filesystem is writeable by default, the attacker can copy their malware to a known location on the device, then modify the startup scripts so that\nit is executed when the device is rebooted. This is similar to the technique used\nby VPNFilter and Torii, as described in section 2.1.\n**Potential Issues: The attacker must be able to obtain write permissions**\nfor the files they are attempting to modify, which is dependent on the privileges\nheld by the exploited application or compromised account used by the attacker.\nFurthermore, the writable filesystem must store files that can lead to the\nexecution of arbitrary code on startup. Otherwise, while the attacker may be\nable to store malware permanently, they will not be able to set it to run when\nthe device is booted.\nFinally, the filesystem may be mounted as read only, so additional steps may\nbe required to remount it as writeable.\n\n|ID|Method|Modified Partition|Complexity|\n|---|---|---|---|\n|A|Modifying Writeable Filesystems|Filesystem|Low|\n|B|Recreating Read-Only Filesystems|Filesystem|Medium|\n|C|Initrd/Initramfs Modification|Kernel|High|\n|D|“Set Writeable Flag” Kernel Module|N/A|High|\n|E|Update Process Exploitation|Filesystem/Kernel|Device Dependant|\n|F|UbootKit|Bootloader|High|\n\n\n-----\n\n6 C. Brierley, J. Pont et al.\n\n**3.2** **Recreating Read-Only Filesystems**\n\nIf the device is using a compressed read-only filesystem, the attacker will not be\nable to modify its files directly. Instead, the attacker can use specialised tools to\nrecreate the filesystem.\n**Requirements: The device must use a compressed read-only filesystem**\n(such as cramfs/squashfs). The attacker must be able to modify the flash\npartition which contains the read-only filesystem. The attacker must have the\nrequired software to recreate the filesystem.\n**Feasibility: While it is not possible to modify files within compressed read-**\nonly filesystems, it is possible to replace the entire filesystem in flash memory\nwith a modified version. To create a new version of the filesystem the attacker\nmust first obtain the compressed version, which resides in flash memory.\nOnce the attacker has identified the partition that holds the filesystem, they\ncan use the MTD subsystem to read it from flash to a file, which can then be\nextracted and modified to their requirements. The attacker can then re-pack it\nin the correct format. For squashfs and cramfs filesystems, this requires using\nthe mksquashfs and mkcramfs utilities respectively. The old version stored in\nthe filesystem partition can then be overwritten via the MTD files in /dev.\n**Potential Issues: Filesystems can vary significantly, even those of the same**\nformat. If the replacement filesystem type is different from what is expected by\nthe device, it might not be interpreted correctly, which will lead to a failure\nduring the boot process. For this approach to be practical, the attacker must\nmatch the used filesystem as closely as possible.\nRead-only filesystems may prove challenging to modify, as it is unlikely that\nthe tools used to build a new filesystem will be included on the exploited device.\nFor device updates, it would be expected that another machine would generate\na new filesystem that is then transferred to the device itself. To follow this same\nphilosophy, the attacker would need to copy the filesystem from the infected\ndevice to an external computer, then modify it using the required tools. It would\nthen need to be uploaded back to the device for writing. Filesystems are likely\nto be much larger than the average malware upload, and as they will need to\nbe uploaded to each infected device; this might not scale well if used for a large\nnumber of devices.\nAlternatively, attackers could compile and upload the required tools for use\non the devices themselves. However, as there are likely to be many different\nfilesystem types and device architectures, this may be not easy to manage.\n\n**3.3** **Initrd and Initramfs Modification**\n\nAs part of its booting processes, the Linux kernel may utilise an appended initrd\nor initramfs filesystem [18]. This is an initial filesystem which allows some setup\nof the device to be performed before mounting the real filesystem.\n**Requirements: The device must use an initrd or initramfs filesystem.**\nThe attacker must be able to modify the flash partition that contains the kernel.\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 7\n\n**Feasibility: First, the attacker must identify the MTD partition that con-**\ntains the Linux kernel. Once the correct partition has been identified, the attacker must analyse it and determine the offset of the filesystem that is appended\nto the kernel. After carving out the relevant data, they must save the original\nkernel and filesystem separately. The attacker can then extract and modify the\nfilesystem to include their required malware. Typically, an initramfs filesystem\nwill be contained in a CPIO archive, which will likely also be compressed, and\nas such, this may require multiple extraction steps. The extraction process must\nthen be reversed, and the resulting filesystem can then be appended to the original kernel. Finally, this data can be used to overwrite the original kernel flash\npartition.\n**Potential Issues: The kernel may be stored on the flash chip as an image for**\nuse with a chosen bootloader. This may require the attacker to take additional\nsteps to recreate the image and maintain compatibility with the bootloader, such\nas the inclusion of image headers that the bootloader may use to boot from the\npartition effectively.\nAs with Method B: unless the filesystem modifications are performed locally,\nlarge amounts of data may need to be transferred via the Internet, which might\nnot scale well.\n\n**3.4** **“Set Writeable Flag” Kernel Module**\n\nMTD can be used to manage partitions of flash memory. Developers may unset\nthe MTD WRITEABLE flag for partitions that are unlikely to need modification,\nwhich may also prevent attackers from making modifications that would allow them to gain persistence. This method allows an attacker to re-enable the\n```\nMTD WRITEABLE flag from within userspace if the requirements are met. While\n\n```\nthis method may not allow an attacker to gain persistence on its own, it may\nallow other methods to circumvent the read-only protections that were put in\nplace by the developers.\n**Requirements: The Linux kernel must support loadable modules. Access**\nto a device’s kernel header files or source tree will improve the kernel module’s\nodds of being compatible.\n**Feasibility: The MTD WRITEABLE partition flag can be difficult to modify**\nfrom userspace at runtime. However, by using a Loadable Kernel Module (LKM),\nan attacker could force this flag to be set from kernel space. There are existing\nkernel modules that have been created to implement this [19,16].\nKernel modules typically need to be compiled against the targeted kernel\nsource to be compatible. This is normally achieved by having access to either\nthe kernel’s headers or source tree [1]. If IoT developers use modified software\nthat falls under the GNU Public License (GPL), they may be required to make\nthe corresponding source code available [26]. The attacker can use this to compile\nthe kernel module for the targeted device.\nAfter compiling and uploading the LKM to the target device, the attacker\ncan use the insmod utility to insert the module into the kernel. Once inserted,\n\n\n-----\n\n8 C. Brierley, J. Pont et al.\n\nthe module is able to set all MTD partitions to be writeable, after which the\nattacker can use one of the other techniques to gain persistence.\n**Potential Issues: If the device’s kernel header and source code are unavail-**\nable, it may be difficult to compile the LKM such that it remains compatible.\nHowever, a defensive IoT tool “HADES-IoT” demonstrated that loadable kernel modules could be compiled with trial and error without the support of the\noriginal developer [9].\nThe developer may be able to prevent this method from being used by configuring the Linux kernel to verify the signature of kernel modules when they are\nloaded [2]. The attacker will not be able to forge a signature for kernel modules\nif they do not have access to the developer’s cryptographic keys.\n\n**3.5** **Update Process Exploitation**\n\nMost devices are expected to receive updates over their lifetime, either to provide new features to users or patches for security issues. However, vulnerable\nupdate implementations can potentially be used to attack the device and gain\npersistence.\n**Requirements: The device must implement a vulnerable update function,**\nsuch that the attacker can forge fake updates. The attacker must be able to\naccess the update function.\n**Feasibility: If an attacker gains access to a vulnerable update function, they**\nmay be able to provide a false firmware update which is accepted by the device.\nFor example, researchers found vulnerabilities in devices produced by Disney [8]\nand Netgear [7], which allowed them to upload modified firmware. An attacker\ncould use these modified updates to include malware and configuration files such\nthat arbitrary code is run each time the device is booted.\n**Potential Issues: The requirements for this method are quite niche. It not**\nonly requires that the attacker has access to the update process (for which they\nwill likely need to be authorised), but the process itself must also be vulnerable\nin such a way that the updates are not verified before being implemented.\nAs the update process will differ from device to device, what may work for one\nis very unlikely to work on another. The attacker will need to reverse engineer\nthe required format of the update for each targeted device’s update process. If\nthe forged update is incorrectly formatted, the update process may be halted,\npreventing the attacker from gaining persistence.\nThe attacker could attempt to modify the filesystem of an existing firmware\nfile provided by the developer, but the update process may also need to interpret\nmetadata defined by the developer. As such, the attacker will be expected to\nrecreate the metadata, such as file sizes or checksums. Some tools are available\nthat may assist in this process, such as the “Firmware Mod Kit” [24]. This\nwill not work for all update formats, especially if the developer has obfuscated,\nencrypted or signed the firmware they make available.\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 9\n\n**3.6** **Ubootkit**\n```\nDas U-Boot (Normally shortened to U-Boot), is a universal bootloader designed\n\n```\nfor use with a variety of embedded devices [14]. It is commonly used in IoT\ndevices to manage the booting process into the main operating system.\n**Requirements: The device must implement U-Boot as its bootloader. The**\nattacker must be able to modify the bootloader flash partition.\n**Feasibility: Researchers have produced an attack that demonstrates the**\ncreation of persistent root-level access in IoT devices, dubbed “UbootKit” [35].\nIf the filesystem MTD partition is marked as read-only, it may prevent some\nof the other methods from being used. UbootKit, however, targets the bootloader partition. If the bootloader partition is writeable, UbootKit can modify\n```\nU-Boot in such a way that when the device is next booted, it will run arbitrary\n\n```\ncode written by the attacker. UbootKit will use this vulnerability to corrupt subsequent boot stages and modify startup scripts during Linux’s boot sequence,\ngaining the ability to make persistent changes.\n**Potential Issues: The authors of Ubootkit state that it can be applied**\nto other devices and architectures than those used in the demonstration [35],\nbut that it would require modification. This technique relies on patching the\nbootloader and kernel of the device with new shellcode at specific offsets. As the\nbootloader and kernel will differ slightly on each targeted device model and version, determining the correct shellcode modifications may be time-consuming.\n\n## 4 Experimental Proof of Concepts and Results\n\nTo test the viability of the techniques described in the previous section, we applied them to a range of vulnerable IoT devices. For persistence to be considered\na viable and realistic attack method, the following two constraints were applied:\n\n**– No physical access to the device must be required during the process. Per-**\nsistence must be achievable remotely, preferably over the Internet.\n**– The method of persistence must allow an attacker to force the device to run**\na custom application when the device is rebooted.\n\nDuring our testing, we examined some local files on the device that are commonly found on Linux based systems to gather information about the device,\nsuch as /proc/mtd to identify partitions and /proc/mounts to identify filesystems. These would help determine the best technique to apply when attempting\nto gain persistence on that device.\n\n**4.1** **Netgear R6250 Router**\n\nThe Netgear R6250 router is one of many routers that had a command injection\nvulnerability present in their web server [21,17]. We used this vulnerability to\ngain access to the shell and begin reconnaissance.\n\n\n-----\n\n10 C. Brierley, J. Pont et al.\n\n**Table 2. Device Persistence Methods Exploits**\n\n**Device** **Persistence Method(s)** **Exploit**\n\nCommand Injection\n\nNetgear R6250 Router [Recreate Read-Only Filesystem &]\n“Set Writeable Flag” Kernel Module CVE-2016-6277 [21]\n\nBuffer Overflow\nD-Link DCS-932L Initrd/Initramfs Modification\nCVE-2019-10999 [22]\n\nCommand Injection\nYealink SIP-T38G Modify Writeable Filesystem\nCVE-2013-5758 [20]\n\nCommand Injection\nWiPG-1000 Modify Writeable Filesystem\nCVE-2019-3929 [23]\n\nFirst, we read the /proc/mounts file and found that the router used both a\n```\njffs2 and squashfs filesystem. We initially targeted the jffs2 filesystem as it\n\n```\nwas writeable by default and would have been the easiest to modify. However, it\nwas mounted to /tmp/openvpn and only contained configuration files, so while\nwe were able to make persistent modifications to the directory, it would not\ncause any arbitrary execution when the device was rebooted.\nWe instead decided to target the squashfs filesystem as it was mounted as\nthe root directory. We read /proc/mtd and identified a partition named “rootfs”,\nwhich was most likely the root filesystem. We read the partition and found it\nwas using squashfs version 4.0, with xz compression.\n**Gaining Persistence. After extracting the files, we modified the result to**\ninclude a file named testfile in /bin, then re-created the filesystem using the\n```\nmksquashfs utility. We then uploaded the generated filesystem to the temporary\n\n```\nmemory of the router. We overwrote the existing filesystem by writing our modified version to /dev/mtdblock15. When we rebooted the device, the testfile\nwas readable, indicating a persistent edit.\n**Read-Only MTD Partitions. During our exploitation of the device, we**\nfound that some of the partitions, notably the bootloader, had been marked as\nread-only via MTD. We were able to compile the Netgear’s mtd-rw kernel module\nagainst the firmware’s GPL source (https://kb.netgear.com/2649/NETGEAROpen-Source-Code-for-Programmers-GPL) and confirmed that inserting the module would allow attackers to set MTD partitions as writeable from userspace.\n\n**4.2** **D-Link DCS-932L**\n\nThe DCS-932L is a web-connected camera for both indoor and outdoor use. Customers can access the camera remotely via a web browser or linked application.\nThis camera has a buffer overflow vulnerability that allows an attacker to\ngain access to the shell and run arbitrary commands [22]. We used this to gain\naccess to the device and investigate how it manages its storage. We read the\n```\nmounts file and found only temporary and pseudo filesystems were being used,\n\n```\nleading us to believe that it was using rootfs as its main filesystem, which\nshould be appended to the end of the kernel. For this device, we attempted to\nuse Method C, modifying the initramfs so that our custom filesystem would\nbe loaded.\n\n|Device|Persistence Method(s)|Exploit|\n|---|---|---|\n|Netgear R6250 Router|Recreate Read-Only Filesystem & “Set Writeable Flag” Kernel Module|Command Injection CVE-2016-6277 [21]|\n|D-Link DCS-932L|Initrd/Initramfs Modification|Buffer Overflow CVE-2019-10999 [22]|\n|Yealink SIP-T38G|Modify Writeable Filesystem|Command Injection CVE-2013-5758 [20]|\n|WiPG-1000|Modify Writeable Filesystem|Command Injection CVE-2019-3929 [23]|\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 11\n\n**Fig. 1. Extracting the DCS-932L’s Root Filesystem from the Kernel Partition**\n\nWe read the /proc/mtd file and identified an MTD partition named “kernel”\nwhich we copied to a host machine to analyse. Using Binwalk [25], we found that\nthe filesystem could be extracted in three stages, as shown in Figure 1.\n\n1. Stage one was the raw data of the partition as it was stored on the flash\nchip. It was made up of a 64-bit uImage Header, and LZMA compressed\ndata. The uImage header contained metadata that the U-Boot bootloader\ncan use to boot the kernel contained in the LZMA payload. We extracted\nthe LZMA compressed data in preparation for stage two.\n2. Stage two consisted of the kernel and some further LZMA compressed data.\nWe identified that the LZMA data began at the offset 0x3AC000, so we carved\nthe data from this offset to the end of the file. We then decompressed this\ndata into stage three.\n3. After extracting the LZMA data, we were left with a CPIO archive, which\nwe could then extract or mount to view the root filesystem of the device.\n\n**Gaining Persistence. To gain persistence on this device, we needed to**\nmodify the kernel partition in such a way that the device would be able to boot\nand mount it correctly. To test our process, we changed the root filesystem to\ncontain a file named testfile in the /bin directory, then began to reverse the\nprocess we used to extract it. First, we compressed the filesystem into a CPIO\narchive. We then needed to compress the CPIO archive using LZMA. However,\nthe compression used by the device was non-streamed. To recreate this as best as\npossible, we used an old version of “LZMA utils” (https://tukaani.org/lzma/).\nWe then prepended the original binary/kernel data and compressed it using\nLZMA. Finally, we had to add a new uImage header. As uImage headers include\nchecksums to check the integrity of the image contents and the header itself\n\n[13], we could not simply prepend the original, as the checksums would fail\nto match when the device starts, causing a fault. Instead, we created a new\nheader with the mkimage utility. The arguments to recreate the metadata, such\n\n\n-----\n\n12 C. Brierley, J. Pont et al.\n\nas the architecture, load address and firmware name, were found by referring\nto the previous header. We uploaded the new image to the device in temporary\nmemory. As the kernel flash partition was writeable, we could copy it from\ntemporary memory to flash memory via the MTD subsystem.\nAfter restarting the device, we found our testfile was present in /bin,\nindicating a successful persistent modification. Attackers could use this technique to modify various startup scripts to perform malicious actions or even run\napplications included in the new filesystem.\n\n**4.3** **Yealink SIP-T38G**\n\nThe SIP-T38G is an Internet-connected VoIP desk phone, allowing users to\nmanage multiple calls and messages. We gained control of the device using an\nadaptation of an existing exploit for previous versions of the phone [20], which\nallowed us to investigate the device further.\nWe read the /proc/mounts file and found that the device used yaffs2 filesystems mounted to multiple locations, including the root (/), /boot, /phone,\n```\n/data, /config and /etc directories.\n\n```\nAs yaffs2 is a writeable filesystem with an MTD user module, we wrote\nto the filesystem via the shell. The /etc directory held scripts that are run at\nboot-time, which we could modify to run custom shell commands or applications\nwhen the system next boots.\n\n**4.4** **WiPG-1000**\n\nThe WiPG-1000 is a presenter that allows users to stream their screen from\nother devices on the same network. We used a command injection vulnerability\n\n[23,6] to start a telnet daemon, which we used to interact with the device via\nthe shell remotely.\nAfter connecting via telnet, we read /proc/mounts to identify the root\nmount. We found that the presenter used two types of storage, a flash chip and\nan Embedded Multi Media Card (eMMC). The eMMC used an ext2 filesystem,\nwhich was mounted to the root directory as read only. We were able to remount\nit as write enabled with the mount utility, after which we were able to easily\nmodify the filesystem via shell commands, which persisted through reboots.\n\n**4.5** **Results Summary**\n\nThere were significant variations in the structure of the devices we sought to\nexploit, with the different types of storage implementations requiring a variety\nof methods to be applied. However, we were able to gain persistence on every\ndevice by applying the described techniques.\nWe have created a process graph to show the best method for gaining persistence, by prioritising those which require the lower complexity to be implemented. This graph can be seen in Figure 2.\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 13\n\n## 5 Countermeasures\n\nBelow, we have listed several potential countermeasures that could be used to\nprevent an attacker from gaining persistence.\n\n**– Data Signing. The use of signatures allows verification that the data con-**\ntained on the flash chip has not been modified, which can prevent an attacker\nfrom gaining persistence. For example, uBoot has a “trusted boot” feature\nthat can check whether an image is correctly signed before continuing the\nboot process [34]. By cryptographically signing each stage of the booting\nprocess, such as the bootloader(s), operating system and filesystem, each\nstep can verify the signature of the next, creating a chain of trust. If a stage\nhas been modified, its signature will not be valid, and the device will fail to\nboot. This should, however, use immutable memory to bootstrap the process, such that an attacker cannot modify the chain of trust at the very\nfirst stage. As the attacker will not have the developer’s cryptographic keys,\nthey will be unable to forge a signature for any modifications they make to\nprotected stages.\n**– Device Updates. The methods outlined in our paper assume that the at-**\ntacker has gained shell access to the device. Users can prevent attackers from\ngaining access by regularly updating their device to patch vulnerabilities and\nprevent exploitation.\n**– Effective Factory Resetting. IoT devices often include a “factory reset”**\nfeature that can be used to restore corrupted partitions to their original\nstate. This could be used by victims to remove malware from the device if\nthe process can reset partitions that have been modified by an attacker.\n**– HADES-IoT. HADES-IoT is a system designed for use on IoT devices,**\nwhich provides a process whitelisting feature [9]. HADES-IoT records a hash\nof benign executables that are run in an uninfected state during a “profiling” stage. When a new process is spawned, HADES-IoT can compare it\nagainst its list of known benign executable hashes, preventing unknown processes from being created. This can frustrate attackers attempting to gain\npersistence and prevent uploaded malware from running.\n\n## 6 Conclusions and Future Work\n\nIn this work, we have discussed the increasing threat of persistence in IoT malware. We outlined the challenges that currently prevent IoT persistence from\nbeing easily achieved. We then detailed techniques that attackers could use to\ngain persistence on IoT devices, describing their requirements, what methodology they can use and which potential issues they might encounter. We demonstrated our ability to achieve true persistence in a wide range of different IoT\ndevices. Based on our findings, we outlined a potential process to identify the\nbest method of obtaining persistence. Finally, we listed several possible countermeasures that can be used to hinder attackers from getting persistence on\nvulnerable IoT devices.\n\n\n-----\n\n14 C. Brierley, J. Pont et al.\n\n**Fig. 2. Process to gain persistence**\n\n\n-----\n\nPersistence in Linux-Based IoT Malware 15\n\nWhilst we were able to gain persistence on all of our targeted devices, the\nvariations on device structure and implementation meant that it was a timeconsuming process that involved significant manual work. An attacker would\nalmost certainly want to automate this for massive-scale attacks. One possible\napproach is to search for or remotely fingerprint vulnerable devices and then\nlaunch the method appropriate for that model.\nAdditionally, whilst it was straightforward to gain persistence on some of\nthe devices we tested, others required more sophisticated methods that were\ntime-consuming to discover and implement. Attackers may soon look towards\nautomating both the discovery and the implementation of these more involved\nmethods for abusing them in large scale operations.\n\n## References\n\n[1. Building external modules, https://www.kernel.org/doc/html/latest/kbuild/](https://www.kernel.org/doc/html/latest/kbuild/modules.html)\n```\n  modules.html [Accessed: August 2020]\n\n```\n[2. Kernel module signing facility, https://www.kernel.org/doc/html/v4.15/admin-](https://www.kernel.org/doc/html/v4.15/admin-guide/module-signing.html)\n```\n  guide/module-signing.html [Accessed: August 2020]\n\n```\n3. What is the mirai botnet?, `https://www.cloudflare.com/learning/ddos/`\n```\n  glossary/mirai-botnet/ [Accessed: August 2020]\n\n```\n[4. What’s a mirai botnet doing with my router? (2016), https://blog.f-secure.com/](https://blog.f-secure.com/whats-a-mirai-botnet-doing-with-my-router/)\n```\n  whats-a-mirai-botnet-doing-with-my-router/ [Accessed: August 2020]\n\n```\n5. Antonakakis, M., April, T., Bailey, M., Bernhard, M., Bursztein, E., Cochran, J.,\nDurumeric, Z., Halderman, J.A., Invernizzi, L., Kallitsis, M., et al.: Understanding\nthe mirai botnet. In: 26th {USENIX} security symposium ({USENIX} Security\n17). pp. 1093–1110 (2017)\n6. Baines, J.: Crestron am/barco wepresent wipg/extron sharelink/teq av it/sharp pnl703wa/optoma wps-pro/blackbox hd wps/infocus liteshow - remote command in[jection (2019), https://www.exploit-db.com/exploits/46786 [Accessed: August](https://www.exploit-db.com/exploits/46786)\n2020]\n7. Birngruber, S., Hehenberger, F., Gr¨undlinger, P., Zeilinger, M., Vymazal, D.:\n[Netgear nighthawk firmware update vulnerability (2017), https://iot-lab-fh-](https://iot-lab-fh-ooe.github.io/netgear_update_vulnerability/)\n```\n  ooe.github.io/netgear update vulnerability/ [Accessed: August 2020]\n\n```\n8. Bozzato, C., Wyatt, L.: Circle with disney firmware update signature check bypass\n[vulnerability (2017), https://talosintelligence.com/vulnerability reports/](https://talosintelligence.com/vulnerability_reports/TALOS-2017-0405)\n```\n  TALOS-2017-0405 [Accessed: August 2020]\n\n```\n9. Breitenbacher, D., Homoliak, I., Aung, Y.L., Tippenhauer, N.O., Elovici, Y.:\nHades-iot: A practical host-based anomaly detection system for iot devices. In:\nProceedings of the 2019 ACM Asia Conference on Computer and Communications\nSecurity. pp. 479–484 (2019)\n10. Brierley, C., Pont, J., Arief, B., Barnes, D.J., Hernandez-Castro, J.: Paperw8: an\niot bricking ransomware proof of concept. In: Proceedings of the 15th International\nConference on Availability, Reliability and Security. pp. 1–10 (2020)\n11. Cloudflare: Famous ddos attacks — the largest ddos attacks of all time,\n```\n  https://www.cloudflare.com/learning/ddos/famous-ddos-attacks/ [Accessed:\n\n```\nAugust 2020]\n12. Cozzi, E., Graziano, M., Fratantonio, Y., Balzarotti, D.: Understanding linux malware. In: 2018 Symp. on Security and Privacy (SP). pp. 161–175. IEEE (2018)\n\n\n-----\n\n16 C. Brierley, J. Pont et al.\n\n[13. Denk, W.: u-boot/image.h (2020), https://github.com/u-boot/u-boot/blob/](https://github.com/u-boot/u-boot/blob/master/include/image.h)\n```\n  master/include/image.h [Accessed: August 2020]\n\n```\n[14. Glass, S.: Das u-boot – the universal boot loader (2020), http://www.denx.de/](http://www.denx.de/wiki/U-Boot)\n```\n  wiki/U-Boot [Accessed: August 2020]\n\n```\n15. Ilascu, I.: New iot botnet torii uses six methods for persistence, has no clear\n[purpose (2018), https://www.bleepingcomputer.com/news/security/new-iot-](https://www.bleepingcomputer.com/news/security/new-iot-botnet-torii-uses-six-methods-for-persistence-has-no-clear-purpose/)\n```\n  botnet-torii-uses-six-methods-for-persistence-has-no-clear-purpose/\n\n```\n[Accessed: August 2020]\n[16. jclehner: mtd-rw: Write-enabler for mtd partitions (2016), https://github.com/](https://github.com/jclehner/mtd-rw)\n```\n  jclehner/mtd-rw [Accessed: August 2020]\n\n```\n17. Land, J.: Multiple netgear routers are vulnerable to arbitrary command injection\n[(2016), https://www.kb.cert.org/vuls/id/582384/ [Accessed: August 2020]](https://www.kb.cert.org/vuls/id/582384/)\n18. Landley, R.: ramfs, rootfs and initramfs (2005), `https://www.kernel.org/`\n```\n  doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt [Accessed: Au\n```\ngust 2020]\n[19. mwarning: mtdrw (2019), https://github.com/mwarning/mtdRW [Accessed: Au-](https://github.com/mwarning/mtdRW)\ngust 2020]\n[20. NIST: Yealink voip phone sip-t38g - remote command execution (2014), https:](https://nvd.nist.gov/vuln/detail/CVE-2013-5758)\n```\n  //nvd.nist.gov/vuln/detail/CVE-2013-5758 [Accessed: August 2020]\n\n```\n[21. NIST: Cve-2016-6277 detail (2017), https://nvd.nist.gov/vuln/detail/CVE-](https://nvd.nist.gov/vuln/detail/CVE-2016-6277)\n```\n  2016-6277 [Accessed: August 2020]\n\n```\n[22. NIST: Cve-2019-10999 (2019), https://nvd.nist.gov/vuln/detail/CVE-2019-](https://nvd.nist.gov/vuln/detail/CVE-2019-10999)\n```\n  10999 [Accessed: August 2020]\n\n```\n[23. NIST: Cve-2019-3929 detail (2019), https://nvd.nist.gov/vuln/detail/CVE-](https://nvd.nist.gov/vuln/detail/CVE-2019-3929)\n```\n  2019-3929 [Accessed: August 2020]\n\n```\n[24. rampageX: firmware-mod-kit (2019), https://github.com/rampageX/firmware-](https://github.com/rampageX/firmware-mod-kit)\n```\n  mod-kit [Accessed: August 2020]\n\n```\n[25. ReFirmLabs: Binwalk (2019), https://github.com/ReFirmLabs/binwalk [Ac-](https://github.com/ReFirmLabs/binwalk)\ncessed: August 2020]\n26. Smith, B.: A quick guide to gplv3. Free Software Foundation, Inc. Online:\nhttp://www. gnu. org/licenses/quick-guide-gplv3. html. Referred 4, 2008 (2007)\n[27. Sophos: Vpnfilter botnet (2018), https://news.sophos.com/en-us/2018/05/24/](https://news.sophos.com/en-us/2018/05/24/vpnfilter-botnet-a-sophoslabs-analysis/)\n```\n  vpnfilter-botnet-a-sophoslabs-analysis/ [Accessed: August 2020]\n\n```\n28. Sophos: Vpnfilter botnet: a sophoslabs analysis: part 2 (2018), `https:`\n```\n  //news.sophos.com/en-us/2018/05/27/vpnfilter-botnet-a-sophoslabs  analysis-part-2/ [Accessed: August 2020]\n\n```\n29. Talos Intelligence: New vpnfilter malware targets at least 500k network[ing devices worldwide (2018), https://blog.talosintelligence.com/2018/05/](https://blog.talosintelligence.com/2018/05/VPNFilter.html)\n```\n  VPNFilter.html [Accessed: August 2020]\n\n```\n30. Talos Intelligence: Vpnfilter update: Vpnfilter exploits endpoints, targets\n[new devices (2018), https://blog.talosintelligence.com/2018/06/vpnfilter-](https://blog.talosintelligence.com/2018/06/vpnfilter-update.html)\n```\n  update.html [Accessed: August 2020]\n\n```\n31. Tung, L.: Fbi to all router users: Reboot now to neuter russia’s vpnfilter\nmalware (2018), `https://www.zdnet.com/article/fbi-to-all-router-users-`\n```\n  reboot-now-to-neuter-russias-vpnfilter-malware/ [Accessed: August 2020]\n\n```\n32. Vignau, B., Khoury, R., Hall´e, S.: 10 years of iot malware: a feature-based taxonomy. In: 2019 IEEE 19th International Conference on Software Quality, Reliability\nand Security Companion (QRS-C). pp. 458–465. IEEE (2019)\n33. Woolf, N.: Ddos attack that disrupted internet was largest of its kind in history, ex[perts say (2016), https://www.theguardian.com/technology/2016/oct/26/ddos-](https://www.theguardian.com/technology/2016/oct/26/ddos-attack-dyn-mirai-botnet)\n```\n  attack-dyn-mirai-botnet [Accessed: August 2020]\n\n```\n\n-----\n\nPersistence in Linux-Based IoT Malware 17\n\n[34. Yamada, M.: verified-boot.txt (2017), https://github.com/u-boot/u-boot/blob/](https://github.com/u-boot/u-boot/blob/master/doc/uImage.FIT/verified-boot.txt)\n```\n  master/doc/uImage.FIT/verified-boot.txt [Accessed: August 2020]\n\n```\n35. Yang, J., Geng, C., Wang, B., Liu, Z., Li, C., Gau, J., Liu, G., Ma, J., YANG, W.:\nUbootkit: A worm attack for the bootloader of iot devices. BlackHat Asia (2019)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Persistence/Persistence In IoT Malware.pdf"
    ],
    "report_names": [
        "Persistence In IoT Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "8670f370-1865-4264-9a1b-0dfe7617c329",
            "created_at": "2022-10-25T16:07:23.69953Z",
            "updated_at": "2025-03-27T02:02:09.929725Z",
            "deleted_at": null,
            "main_name": "Hades",
            "aliases": [
                "Operation TrickyMouse"
            ],
            "source_name": "ETDA:Hades",
            "tools": [
                "Brave Prince",
                "Gold Dragon",
                "GoldDragon",
                "Lovexxx",
                "Olympic Destroyer",
                "Running RAT",
                "RunningRAT",
                "SOURGRAPE",
                "running_rat"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bc289ba8-bc61-474c-8462-a3f7179d97bb",
            "created_at": "2022-10-25T16:07:24.450609Z",
            "updated_at": "2025-03-27T02:02:10.235933Z",
            "deleted_at": null,
            "main_name": "Avalanche",
            "aliases": [],
            "source_name": "ETDA:Avalanche",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536102,
    "ts_updated_at": 1743041831,
    "ts_creation_date": 1616689541,
    "ts_modification_date": 1651425108,
    "files": {
        "pdf": "https://archive.orkl.eu/503ac4da325f205a965df60f0312c3d866f8e11a.pdf",
        "text": "https://archive.orkl.eu/503ac4da325f205a965df60f0312c3d866f8e11a.txt",
        "img": "https://archive.orkl.eu/503ac4da325f205a965df60f0312c3d866f8e11a.jpg"
    }
}