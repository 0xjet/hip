{
    "id": "f25f1431-3eb4-4c91-8d3c-2961632d6c96",
    "created_at": "2023-01-12T15:07:05.296954Z",
    "updated_at": "2025-03-27T02:14:02.564262Z",
    "deleted_at": null,
    "sha1_hash": "f08cf2702b1ccac42382c80ffe5d0ea4da07d7d8",
    "title": "2020-01-22 - The malware analyst’s guide to PE timestamps",
    "authors": "",
    "file_creation_date": "2022-05-27T21:12:33Z",
    "file_modification_date": "2022-05-27T21:12:33Z",
    "file_size": 483220,
    "plain_text": "# The malware analyst’s guide to PE timestamps\n\n**[0xc0decafe.com/malware-analyst-guide-to-pe-timestamps/](https://0xc0decafe.com/malware-analyst-guide-to-pe-timestamps/)**\n\nJanuary 22, 2021\n\nThis blog post is all about time. More exactly, timestamps found in Portable Executable (PE)\nfiles that describe a (possible) compilation date. These PE timestamps may even reveal\ndetails about a threat actor. For instance, it is possible to deduce a threat actor’s working\nhours and use this information – hopefully together with other artifacts – for attribution\npurposes. But be aware: even though PE timestamps can be a valuable forensic artifact,\nthey can be forged with ease. While the COFF header field `TimeDateStamp is the most-`\nknown place to look for a compilation timestamp, there are more places where we can find\ntimestamps in a PE file.\n\nBut there are also special cases where PE timestamps are not correct due to new build\nfeatures, linker bugs, or simply forging. We’ll look into these cases and see how we can still\nget some information about the compilation date. Afterward, we’ll learn how to read PE\ntimestamps with a wide range of tools and how to automate this work in order to deal with\nlarger datasets. Of course, there are several real-world applications for malware / cyber\nthreat intelligence analysts of what we’ll learn in this blog post. Finally, I’ll give you some\nideas how you can utilize PE timestamps to reveal certain behaviors or characteristics of\nthreat actors.\n\n\n-----\n\nThis article assumes a basic understanding of the PE format. Good beginner write-ups are\n[“An In-Depth Look into the Win32 Portable Executable File Format” and “Portable](https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail)\nExecutable File Format“. As a follow-up, [Ange Albertini wrote a much more detailed technical](https://github.com/corkami/docs/blob/master/PE/PE.md)\narticle on the PE format.\n\nThis work wouldn’t have been possible without many great blog posts and papers published\nby the infosec community. I am standing on the shoulders of giants! I refer to these posts and\npapers in the following whenever possible.\n\n## The COFF File Header field TimeDateStamp (_IMAGE_FILE_HEADER)\n\nThe probably most cited field of the PE format that holds a compilation timestamp is the field\n\n`TimeDateStamp of the` [COFF File Header. It is a](https://wiki.osdev.org/COFF#Microsoft_PE.2FCOFF) `DWORD (32 bit / 4 bytes) member of the`\nstruct `_IMAGE_FILE_HEADER /` [COFF File Header. This struct is defined as follows:](https://wiki.osdev.org/COFF#Microsoft_PE.2FCOFF)\n```\ntypedef struct _IMAGE_FILE_HEADER {  \n WORD Machine;  \n WORD NumberOfSections;  \n DWORD TimeDateStamp;  \n DWORD PointerToSymbolTable;  \n DWORD NumberOfSymbols;  \n WORD SizeOfOptionalHeader;  \n WORD Characteristics; \n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n```\n`TimeDateStamp is in` [epoch, which measures the seconds that have passed since January](https://en.wikipedia.org/wiki/Epoch_(computing))\n1, 1970 UTC. Since it is a DWORD value, its range is quite limited. This will lead – if not fixed\n[before – to an integer overflow in the year 2038. Furthermore, epoch should not be](https://en.wikipedia.org/wiki/Year_2038_problem)\nconfused with Win32 epoch, which [starts in the year 1601.](https://devblogs.microsoft.com/oldnewthing/20090306-00/?p=18913)\n\nAs part of the linking process of the final PE binary, the linker sets the field `TimeDateStamp`\nin the COFF File Header. However, its purpose today is mainly supporting the module loader\nas Raymond Chen lays out in “Why are the module timestamps in Windows 10 so\nnonsensical?“:\n\nRemember what the timestamp is used for: It’s used by the module loader to determine\nwhether bound imports should be trusted. We’ve already seen cases where the\ntimestamp is inaccurate. For example, if you rebind a DLL, then the rebound DLL has\nthe same timestamp as the original, rather than the timestamp of the rebind, because\nyou don’t want to break the bindings of other DLLs that bound to your DLL.\n\nSo the timestamp is already unreliable.\n\nThe timestamp is really a unique ID that tells the loader, “The exports of this DLL have\nnot changed since the last time anybody bound to it.” […]\n\n_Raymond Chen – Why are the module timestamps in Windows 10 so nonsensical?_\n\n\n-----\n\n**Bottom line: even though nobody had the intention to tamper with a timestamp, it may**\n_already be unreliable in certain cases._\n\n## Additional timestamps found in the PE file format\n\nIn addition to the field `TimeDateStamp of the COFF File Header, there are further places`\nwhere we can find possible compilation timestamps in PE files.\n\n[I think the most complete listing was compiled by Walied Assar. He lists additional places in](http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html)\nthe PE format where we can find possible compilation timestamps. I’ll refer only to the ones\nthat can be used in order to determine the compilation time in the following sections.\n\nNevertheless, you should have a look at the other possible fields that Walied Assar’s\naforementioned article mentions. Just for completeness, I’ll list the directories that I do not\n**include in the following:**\n```\n   TimeDateStamp in _IMAGE_IMPORT_DESCRIPTOR (see\n   _IMAGE_EXPORT_DIRECTORY ; used in bound imports)\n   TimeDateStamp in _IMAGE_BOUND_IMPORT_DESCRIPTOR (see\n   _IMAGE_EXPORT_DIRECTORY ; used in bound imports)\n\n```\n`TimeDateStamp in` `_IMAGE_LOAD_CONFIG_DIRECTORY` [(obsolete since Windows XP)](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)\n\n### _IMAGE_EXPORT_DIRECTORY\n\nThe [export directory ( _IMAGE_EXPORT_DIRECTORY ) of the PE format contains also a field](https://blog.kowalczyk.info/articles/pefileformat.html)\ncalled `TimeDateStamp . Not all linkers seem to fill this field but Microsoft Visual Studio`\nlinkers fill it for both DLL and EXE PE files. For reference, the export directory structure\n```\n_IMAGE_EXPORT_DIRECTORY is defined as follows:\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\n  DWORD Characteristics;\n  DWORD TimeDateStamp;\n  WORD MajorVersion;\n  WORD MinorVersion;\n  DWORD Name;\n  DWORD Base;\n  DWORD NumberOfFunctions;\n  DWORD NumberOfNames;\n  DWORD AddressOfFunctions;\n  DWORD AddressOfNames;\n  DWORD AddressOfNameOrdinals;\n } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\n\n```\nThe field `TimeDateStamp is relevant for bound imports as other PE files that use bound`\nimports (see [Import Binding) refer to the value of this field in their own field](https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files) `TimeDateStamp`\nof `IMAGE_IMPORT_DESCRIPTOR . Or in other words: the linker fills the field` `TimeDateStamp`\nof `IMAGE_IMPORT_DESCRIPTOR with the value of` `TimeDateStamp of`\n\n\n-----\n\n```\n_IMAGE_EXPORT_DIRECTORY of the PE file that they bind their import to. This is the reason\n\n```\nwhy the field `TimeDateStamp of` `IMAGE_IMPORT_DESCRIPTOR are unusable to determine a`\npossible compilation date.\n\n[The value of this field describes the time when the export directory was created. Therefore, it](https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files)\ndoesn’t have to be equal to the `TimeDateStamp from the COFF File Header. But it is often`\n[equal or very close to it.](http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html)\n\n### _IMAGE_RESOURCE_DIRECTORY\n\nAnother `TimeDateStamp field resides in the resource directory`\n( _IMAGE_RESOURCE_DIRECTORY ). The corresponding structure is defined as follows:\n```\ntypedef struct _IMAGE_RESOURCE_DIRECTORY {\n   DWORD  Characteristics;\n   DWORD  TimeDateStamp;\n   WORD  MajorVersion;\n   WORD  MinorVersion;\n   WORD  NumberOfNamedEntries;\n   WORD  NumberOfIdEntries;\n } IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;\n\n```\n[While Microsoft Visual Studio linkers seem not to set this field, (old) Borland linkers set it.](http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html)\nThis is especially relevant for malware that is compiled with a Delphi version between Delphi\n4 and Delphi 2006. As we later see, there is a known bug so that these versions do not\ncorrectly set the field `TimeDateStamp of the COFF File Header. However, they set it – if the`\nPE file comprises resources – in the `IMAGE_RESOURCE_DIRECTORY and` [its subdirectories.](http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html)\n\n### _IMAGE_DEBUG_DIRECTORY\n\n[If the linker emits debug information (/DEBUG), then the PE file contains an](https://docs.microsoft.com/en-us/cpp/build/reference/debug-generate-debug-info?view=msvc-160) array of debug\ndirectories ( _IMAGE_DEBUG_DIRECTORY ). The corresponding structure contains a field called\n```\nTimeDateStamp and is defined as follows:\ntypedef struct _IMAGE_DEBUG_DIRECTORY {\n   DWORD  Characteristics;\n   DWORD  TimeDateStamp;\n   WORD  MajorVersion;\n   WORD  MinorVersion;\n   DWORD  Type;\n   DWORD  SizeOfData;\n   DWORD  AddressOfRawData;\n   DWORD  PointerToRawData;\n } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;\n\n```\nAs a PE file can contain several `_IMAGE_DEBUG_DIRECTORY s (stored in an array), it is` worth\nto check all of them, in case the timestamp of the first seems to be forged.\n\n\n-----\n\nFurthermore, one type of debugging information contains a timestamp. The field `Type`\nholds several constants (range `0x0 –` `0x9 ) that indicate the format of the debugging`\ninformation. If the field is set to `IMAGE_DEBUG_TYPE_CODEVIEW ( 0x2 ), then we can follow`\n```\nPointerToRawData of _IMAGE_DEBUG_DIRECTORY and we’ll find the CodeView\n\n```\ninformation.\n\nThe relevant structures `_CV_HEADER and` `_CV_INFO_PDB20` [are defined as follows:](https://github.com/tishion/PdbInfo/blob/master/PdbInfo/PEHelper.h)\n```\n#define CV_SIGNATURE_NB10 '01BN'    \n#define CV_SIGNATURE_NB09 '90BN'    \ntypedef struct _CV_HEADER        \n{    \n DWORD dwSignature;    \n DWORD dwOffset;    \n} CV_HEADER, *PCV_HEADER;    \ntypedef struct _CV_INFO_PDB20    \n{    \n CV_HEADER CvHeader;    \n DWORD dwSignature;    \n DWORD dwAge;    \n BYTE PdbFileName[];    \n} CV_INFO_PDB20, *PCV_INFO_PDB20;\n\n```\nIf the `_CV_HEADER ‘s signature in` `dwSignature equals` `CV_SIGNATURE_NB10, then the`\nPDB format is 2.0. In this case, the `dwSignature contains an epoch value describing when`\nthe debug information was created. If it is not in PDB format, then `dwSignature` may\ncomprises an unique identifier for each build. Note that the field `dwAge is not a timestamp`\nin epoch but rather an ever-increasing value that indicates an update to the PDB information.\n\n## Special cases\n\nThere are several noteworthy special cases where the timestamps are either not reliable or\nother timestamps should be preferred. The following sections will look into three of these\ncases and show possible ways to circumvent this limitation.\n\n### Delphi timestamps\n\nDo you know what happened on 1992-06-19? I googled it and found out that this was the\nday [Batman Returns was released in the USA. But that’s only relevant for Batman fans and](https://en.wikipedia.org/wiki/Batman_Returns)\nnot really related to timestamps. Something different happened, at least, if you believe the\nPE timestamps of likely thousands or even millions of Delphi binaries. They all were built on\n```\n1992-06-19 22:22:17 . The timestamp value is 0x2A425E19 ( 708992537 ).\n\n```\nWhat sounds like a very productive programmer evening is actually a bug in many Delphi\n[compiler versions. Delphi versions before Delphi 2007 (likely Delphi 4 – Delphi 2006) did not](https://stackoverflow.com/questions/1781443/how-can-i-get-the-compile-date-and-time-in-delphi)\nset the field `TimeDateStamp at all. It seems that they just used a preconfigured value for`\n\n\n-----\n\nthis field. Maybe they used a PE stub that they filled out accordingly. However, there [is a way](https://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/)\nto determine the real compilation timestamp of these binaries. If the sample comprises a\nresources directory ( _IMAGE_RESOURCE_DIRECTORY ), we can read its `TimeDateStamp`\nfield instead. But be aware that the value is not an epoch timestamp but a MS DOS\ntimestamp.\n\n**Bottom line: if you see a binary with a timestamp value of** `1992-06-19 22:22:17, then`\nyou are likely dealing with a Delphi binary that was compiled with a Delphi version before\nDelphi 2007. If there are resources, then you may get at least a compilation estimate from\nthe timestamp found in `_IMAGE_RESOURCE_DIRECTORY .`\n\n### Windows 10 reproducible builds timestamps\n\n[Windows 10 timestamps are nonsensical since Microsoft moved towards reproducible builds.](https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705)\nIn a nutshell, a reproducible build means starting a build from the exact same source code\nyields the exact same binary code. Obviously, timestamps are one obstacle in the way to\nreproducible builds. Therefore, timestamps are set to the hash of the resulting binary, which\npreserves reproducibility.\n\nLet’s have a look at a Windows 10 binary to verify this behavior. For instance,\n```\nregedit.exe comprises a TimeDateStamp value 0xBB9B6911 as can be seen in the\n\n```\n[following screenshot (using the tool pestudio). If we translate this value to UTC time, then](https://www.winitor.com/)\nthis date would be way in the future. As expected, the `TimeDateStamp value of Windows`\n10 binaries is unreliable.\n\n\n-----\n\nInspecting the PE compilation timestamp of regedit.exe (Windows 10) with pestudio.\nEven though I am not aware of a way to get a compilation timestamp directly from these\nbinaries, there are two possible ways to get at least an approximation. First, if the file was\nscanned at VirusTotal, then it must be older than the first submission date. This may be a\nvery inaccurate approximation but a good starting point.\n\nSecond, a better way to approximate the age of the binary would be to use a binary index\n[like Winbindex. For instance, here we can check if](https://winbindex.m417z.com/) [it indexes the](https://winbindex.m417z.com/?file=regedit.exe) `regedit.exe file from the`\nprevious example. And indeed: Winbindex lists this `regedit.exe file with sha256 hash`\n```\nd5de45decfd0fa08ac12f5725dfc7e5af1e3ed0325559101990fdcf02c439441 and states\n\n```\nthat it is part of Windows 10 1903 and 1909. So the earliest we can get is `2019-05-21,`\nwhich is the release date of Windows 10 1903.\n\n### Gozi2 / ISFB timestamps\n\nGozi2 / ISFB and [its forks are wide-spread malware strains. Malware analysts are likely to](https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/)\nstumble upon one or more of them during their career. Even though the timestamps of a Gozi\n/ ISFB sample may be forged, there is a “feature” of this malware family and many of its forks\n[that is likely more reliable. As stated by Maciej Kotowicz in his report on ISFB:](https://lokalhost.pl/txt/isfb_still.live.and.licking.Botconf2016.pdf)\n\n\n-----\n\nOne of first operations of all ISFB variants is to decode strings that are stored in .bss\nsection, section that is normally used to keep non-initialized global variables. The\nalgorithm used for string encoding is quite simple, it is a rolling xor with a compilation\ndate as a key.\n\n_ISFB: Still Live and Kicking by Maciej Kotowicz_\n\nAgain, the old rule of thumb holds here: threat actors are often as lazy as we are. Therefore,\n[they will not touch this “feature”. We can see this in an ISFB fork called LOLSnif. The sample](https://www.telekom.com/en/blog/group/article/lolsnif-tracking-another-ursnif-based-targeted-campaign-600062)\nthat was observed in campaigns in April 2020 loaded the plaintext key “Apr 1 2020” to\ndecrypt its strings.\n\nISFB fork LOLSnif loads\n\ncompilation date as plaintext string for string decryption\n\n## On the correctness of timestamps\n\nThreat actors who compile their malicious binaries can easily tamper with any of the\naforementioned timestamp values. I would say that forging timestamps is a low-hanging fruit\nand not doing so shows a lack of or disinterest in Operational Security (OPSEC),\nrespectively.\n\n\n-----\n\n**As a rule of thumb: you should never blindly trust the timestamp found in any of the**\n```\nTimeDateStamp fields as they can easily be forged! However, you can increase the\n\n```\nconfidence that you have in the correctness of this value by, for instance, correlating this with\nintrusion dates obtained from incident response engagements or metadata obtained from\n[sources like VirusTotal (e.g.](https://www.virustotal.com/) `First Submission ). Furthermore, you should never trust the`\n```\nTimeDateStamp value of packed binaries as this is one of the PE header fields that packers\n\n```\ntamper with in the first place. However, the `TimeDateStamp values of unpacked binaries`\nare in many cases (but certainly not all!) correct as threat actors often do not care about\ntampering with it.\n\n### Case study: custom loader DLLs used in SUNBURST attacks\n\nFor instance, the threat actor who is responsible for the sophisticated supply chain attack\nknown as [SUNBURST forged timestamps as stated in Microsoft’s report “Deep dive into the](https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html)\nSolorigate second-stage activation: From SUNBURST to TEARDROP and Raindrop“:\n\nThe custom loader DLLs dropped on disk carried compile timestamps ranging from\nJuly 2020 to October 2020, while the embedded Reflective DLLs carried compile\ntimestamps ranging from March 2016 to November 2017. The presence of 2016-2017\n[compile timestamps is likely due to attackers’ usage of custom Malleable C2 profiles](https://www.cobaltstrike.com/help-malleable-c2)\nwith synthetic compile timestamp (compile_time) values. At first glance it would appear\nas if the actor did not timestamp the compile time of the custom loader DLLs (2020\ncompile timestamps). However, forensic analysis of compromised systems revealed\nthat in a few cases, the timestamp of the custom loader DLLs’ introduction to systems\npredated the compile timestamps of the custom loader DLLs (i.e., the DLLs appear to\nhave been compiled at a future date).\n\n_Microsoft Security – Deep dive into the Solorigate second-stage activation: From_\n_SUNBURST to TEARDROP and Raindrop_\n\nThe interesting point here is that both the loader DLLs as well as the CobaltStrike Beacons\nhave forged timestamps. The timestamps of the CobaltStrike Beacons were likely forged as\npart of the CobaltStrike framework and carried timestamps way in the past. However, the\ninteresting thing here is that the outer layer – the custom loader DLLs – carried timestamps\nthat laid in the future.\n\nEven though it might be wild speculation why these timestamps predated the actual intrusion\ndates, one possible explanation is that the threat actor wanted the intrusion to appear to last\nless time than it actually lasted, in case the loader DLLs would have been found by the local\nnetwork defenders.\n\n## Read PE timestamps\n\n\n-----\n\nNumerous tools and (Python) modules allow us to read (and modify) several fields of the PE\nheader that can hold (compilation) timestamps. The following sections will show how these\ntimestamps can be read with tools that I deem important. The first tools serve for manual\ninspection of individual PE files. But the later sections will show how to use two well-known\nPython modules in order to automate the PE timestamp extraction as a means of analyzing\nseveral PE files of a campaign / a threat actor.\n\nNote that there is also [an issue with several tools. While some display the TimeDateStamp](https://www.hexacorn.com/blog/2019/03/11/pe-compilation-timestamps-vs-forensics/)\nas UTC time, some localize the TimeDateStamp and display incorrect information. IMHO the\ncorrect way is to display timestamps as UTC time and additionally indicate the shift that is\nrequired so that it’s in the supposedly correct time zone.\n\n### Read PE timestamps with a PE file viewer\n\nThis one is a no-brainer. Every PE file viewer like, for instance, [PE Tree,](https://github.com/blackberry/pe_tree) [pestudio, or](https://www.winitor.com/) PEbear displays the aforementioned `TimeDateStamp fields as seen in the following`\nscreenshot using PE Tree. Note how PE Tree correctly displays the `TimeDateStamp field`\nas UTC time.\n\nPE Tree displaying the field TimeDateStamp of the PE format’s FILE_HEADER structure.\n\n### Read PE timestamps with TimeDateStamp\n\n[Walied Assar wrote a tiny command line program called TimeDateStamp. This command line](http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html)\nprogram inspects half of a dozen timestamps that are defined in the PE format. Use the `-f`\nflag with a path to a PE file as follows:\n\n\n-----\n\n```\nC:\\Users\\USER\\Desktop>TimeDateStamp.exe f yara64.exe\n   TimeDateStamp from _IMAGE_FILE_HEADER    ---> Fri Jun 26 08:37:17 2020\n   TimeDateStamp from _IMAGE_EXPORT_DIRECTORY  ---> Empty\n   TimeDateStamp from _IMAGE_DEBUG_DIRECTORY  --->\n   TimeDateStamp from _IMAGE_LOAD_CONFIG_DIRECTORY ---> Empty  \n\n```\nAnother neat feature is that we can input a hex value (with or without leading `0x ) and the`\ntool spits out the corresponding date. For instance, if we input `0x2A425E19 (do you still`\nremember what that was?), then it spits out `Fri Jun 19 22:22:17 1992 correctly:`\n```\nC:\\Users\\USER\\Desktop>TimeDateStamp.exe 2A425E19\n Fri Jun 19 22:22:17 1992\n\n### Read PE timestamps with an hex editor\n\n```\n[Daniel Plohmann’s tweet with a list of DWORDs with only the most significant byte set and](https://twitter.com/push_pnx/status/1164900331098128385?s=20)\ntheir corresponding dates is particularly interesting. For those who work frequently with\nHexEditors inspecting binary formats (not necessarily the PE format), this table is very\nhelpful. Based on the most significant byte of the timestamp DWORD, we can quickly\nestimate the date.\n\nFor instance, the Delphi timestamp `0x2A425E19 falls in the bin` `0x2A000000 and`\n```\n0x2B000000, or for humans 1992-04-30 14:11:12 and 1992-11-10 17:31:28 . Note\n\n```\nthat each bin covers more or less six months.\n\nI’ve generated the bins for 2015 – 2025, which should be the most relevant as of 2021:\n```\nU -> 0x55000000 - 2015-03-11T09:42:40\n V -> 0x56000000 - 2015-09-21T15:02:56\n W -> 0x57000000 - 2016-04-02T19:23:12\n X -> 0x58000000 - 2016-10-13T23:43:28\n Y -> 0x59000000 - 2017-04-26T04:03:44\n Z -> 0x5a000000 - 2017-11-06T07:24:00\n [ -> 0x5b000000 - 2018-05-19T12:44:16\n \\ -> 0x5c000000 - 2018-11-29T16:04:32\n ] -> 0x5d000000 - 2019-06-11T21:24:48\n ^ -> 0x5e000000 - 2019-12-23T00:45:04\n _ -> 0x5f000000 - 2020-07-04T06:05:20\n ` -> 0x60000000 - 2021-01-14T09:25:36\n a -> 0x61000000 - 2021-07-27T14:45:52\n b -> 0x62000000 - 2022-02-06T18:06:08\n c -> 0x63000000 - 2022-08-19T23:26:24\n d -> 0x64000000 - 2023-03-02T02:46:40\n e -> 0x65000000 - 2023-09-12T08:06:56\n f -> 0x66000000 - 2024-03-24T11:27:12\n g -> 0x67000000 - 2024-10-04T16:47:28\n h -> 0x68000000 - 2025-04-16T21:07:44\n i -> 0x69000000 - 2025-10-28T00:28:00\n\n### Read PE timestamps from the command line\n\n```\n\n-----\n\nThere are many command line tools that can read the PE header. One tool I like to use is\n[readpe from the](https://manpages.debian.org/testing/pev/readpe.1.en.html) [pev toolkit. pev is open source, works on several platforms, and comes with](https://github.com/merces/pev)\nmany handy tools when dealing with PE files from the command line. Let’s just use `readpe`\nto read the field `TimeDateStamp of the COFF File Header from a packed IcedId`\nPhotoLoader sample\n[(4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193, first](https://www.virustotal.com/gui/file/4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193/details)\nsubmission to VT: 2020-05-27 23:31:27).\n\nWe call `readpe with the` `-h flag, which allows us to specify a header that we would like to`\ninspect. For our purpose, this is the COFF header ( coff ). As a result, `readpe dumps all`\nfields from this header.\n```\nreadpe -h coff 4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193\nCOFF/File header\n   Machine:             0x14c IMAGE_FILE_MACHINE_I386\n   Number of sections:       4\n   Date/time stamp:         1432567928 (Mon, 25 May 2015 15:32:08 UTC)\n   Symbol Table offset:       0\n   Number of symbols:        0\n   Size of optional header:     0xe0\n   Characteristics:         0x103\n   Characteristics names\n                     IMAGE_FILE_RELOCS_STRIPPED\n                     IMAGE_FILE_EXECUTABLE_IMAGE\n                     IMAGE_FILE_32BIT_MACHINE\n\n```\nHowever, the timestamp is forged since the first submission of this sample was in Spring\n2020 but the timestamp says that the sample is from Spring 2015. Let’s unpack the sample\nwith [unpac.me and we receive one unpacked child](https://www.unpac.me/results/c5c293b9-4951-4c2a-ad5e-312e599483db#/)\n(70fe6ccca21ce51800c7b998e8fc06997eac07e086f1dcdd87765b2dcea72395):\n```\nreadpe -h coff 70fe6ccca21ce51800c7b998e8fc06997eac07e086f1dcdd87765b2dcea72395\nCOFF/File header\n   Machine:             0x14c IMAGE_FILE_MACHINE_I386\n   Number of sections:       5\n   Date/time stamp:         1586956141 (Wed, 15 Apr 2020 13:09:01 UTC)\n   Symbol Table offset:       0\n   Number of symbols:        0\n   Size of optional header:     0xe0\n   Characteristics:         0x102\n   Characteristics names\n                     IMAGE_FILE_EXECUTABLE_IMAGE\n                     IMAGE_FILE_32BIT_MACHINE\n\n```\nNow, this timestamp looks much better. It is likely to be the correct compilation timestamp of\nthis sample due to the first submission to VT differs just one month. Furthermore, there is a\n[blog post published at the end of April 2020 that described this new variant of IcedId’s](https://sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html)\nPhotoLoader.\n\n### Read PE timestamps with pefile\n\n\n-----\n\n[pefile is a Python module to parse and modify PE files. The following script (based on this](https://github.com/erocarrera/pefile)\nblog post) shows how to read the field `TimeDateStamp from the COFF File Header and`\nconvert it to UTC time. In addition, it prints out how old the PE file is. Note that accessing\nother `TimeDateStamp fields as described in Section “Additional timestamps found in PE`\nfiles” works similarly. Please refer to the [usage examples of pefile.](https://github.com/erocarrera/pefile/blob/wiki/UsageExamples.md)\n```\nimport datetime\nimport pefile\nimport sys\npe = pefile.PE(sys.argv[1])\nts = int(pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split()[0], 16)\nutc_time = datetime.datetime.utcfromtimestamp(ts)\nt_delta = (datetime.datetime.today() - utc_time).days\nprint(utc_time.strftime(\"%Y-%m-%d %H:%M:%S +00:00 (UTC)\") + f\" ({t_delta} days old)\")\n\n```\nIf we run this simple script on a Delphi sample (Wabot,\n[ebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265), then we get a](https://www.virustotal.com/gui/file/ebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265/detection)\nsomewhat surprising result:\n```\npython get_timestamp_pefile.py\nebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265\n1992-06-19 22:40:53 +00:00 (UTC) (10436 days old)\n\n```\nThe value is `0x2A426275, which translates to` `1992-06-19 22:40:53 . This is not the`\nexpected Delphi timestamp `0x2A425E19 . The most significant two bytes are equal`\n( 0x2A42 ), but the least significant two bytes / WORD is different. A possible explanation is\nthat the timestamp was modified.\n\n### Read PE timestamps with lief\n\n[lief is another project to parse and modify PE files. Its core is written in C++ but there is a](https://lief.quarkslab.com/doc/latest/)\nPython module as well. In contrary to pefile, lief is can parse various executable formats\nsuch as [ELF and](https://lief.quarkslab.com/doc/latest/tutorials/03_elf_change_symbols.html) [MachO while offering the same interface. Therefore, lief works well in](https://lief.quarkslab.com/doc/latest/tutorials/11_macho_modification.html)\nprojects that do not only target one platform. Furthermore, lief added several advanced\n[features not yet implemented in pefile like working with PE Authenticode.](https://lief.quarkslab.com/doc/latest/tutorials/13_pe_authenticode.html)\n\n**Read COFF File Header timestamps**\n\nThe following code snippet shows the script `get_timestamp_lief.py that reads the PE`\nHeader field `TimeDateStamp (called by lief` `time_date_stamps ) and converts it to UTC`\ntime (analogous to the pefile script of the previous section). Just import the module `lief`\nand open the binary with the `parse method. The COFF File Header is accessible via`\n```\nheader and the field TimeDateStamp is called time_date_stamps in lief.\n\n```\n\n-----\n\n```\nimport datetime\n import lief\n import sys\n binary = lief.parse(sys.argv[1])\n ts = binary.header.time_date_stamps\n utc_time = datetime.datetime.utcfromtimestamp(ts)\n t_delta = (datetime.datetime.today() - utc_time).days\n print(utc_time.strftime(\"%Y-%m-%d %H:%M:%S +00:00 (UTC)\") + f\" ({t_delta} days\nold)\")\n\n```\n**Read Delphi timestamps**\n\nAgain, Delphi binaries that were compiled with Delphi 4 – Delphi 2006 had a bug: all of them\nhad the same `TimeDateStamp value in the COFF File Header. However, there is a way (as`\n[described by Hexacorn) to get the compilation timestamp via the field](https://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/) `TimeDateStamp in`\nthe resource directory ( _IMAGE_RESOURCE_DIRECTORY ). Be aware that in Delphi binaries\nthis field does not hold an epoch timestamp but rather a MS DOS timestamp.\n\nThe following script reads the a possible compilation timestamp for Delphi binaries. It\nboroughs the function `from_msdos from the project` [Time Decode to convert the MS DOS](https://github.com/digitalsleuth/time_decode)\ntimestamp to a readable string. First, it checks if the `TimeDateStamp field of the`\n```\nIMAGE_FILE_HEADER equals the expected Delphi timestamp (seen in Delphi 4 – Delphi\n\n```\n2006 binaries) in lines 26 – 27. In this case, it checks if there are resources with\n```\nbinary.has_resources in line 29 and then gets resource directory with\nbinary.resources in line 30. Finally, it gets the timestamp and converts it from MS DOS\n\n```\nformat to a readable string.\n\n\n-----\n\n```\nimport datetime\n import lief\n import sys\n def from_msdos(msdos):\n   \"\"\"taken from https://github.com/digitalsleuth/time_decode\"\"\"\n   msdos = hex(msdos)[2:]\n   binary = '{0:032b}'.format(int(msdos, 16))\n   stamp = [binary[:7], binary[7:11], binary[11:16], binary[16:21], binary[21:27],\nbinary[27:32]]\n   for val in stamp[:]:\n     dec = int(val, 2)\n     stamp.remove(val)\n     stamp.append(dec)\n   dos_year = stamp[0] + 1980\n   dos_month = stamp[1]\n   dos_day = stamp[2]\n   dos_hour = stamp[3]\n   dos_min = stamp[4]\n   dos_sec = stamp[5] * 2\n   if (dos_year in range(1970,2100)) or not (dos_month in range(1,13)) or not\n(dos_day in range(1,32)) or not (dos_hour in range(0,24)) or not (dos_min in\nrange(0,60)) or not (dos_sec in range(0,60)):\n     dt_obj = datetime.datetime(dos_year, dos_month, dos_day, dos_hour, dos_min,\ndos_sec)\n     return dt_obj.strftime('%Y-%m-%d %H:%M:%S')\n   return \"Not a valid MS DOS timestamp\"\n binary = lief.parse(sys.argv[1])\n ts = binary.header.time_date_stamps\n if ts == 0x2a425e19:\n   print('Found binary compiled with Delphi 4 - Delphi 2006')\n   if binary.has_resources:\n     root = binary.resources\n     if root.time_date_stamp != 0:\n       ts = root.time_date_stamp\n       dos_time = from_msdos(ts)\n       print(f'_IMAGE_RESOURCE_DIRECTORY: {hex(ts)} -> {dos_time}')\n     else:\n       print('Timestamp of _IMAGE_RESOURCE_DIRECTORY is set to zero')\n   else:\n     print('Binary has no resources.')\n else:\n   utc_time = datetime.datetime.utcfromtimestamp(ts)\n   print('Likely not a binary compiled with Delphi 4 - Delphi 2006')\n   print(hex(ts) + ' -> ' + utc_time.strftime(\"%Y-%m-%d %H:%M:%S +00:00 (UTC)\"))\n\n```\nI tested it with an older Azorult (version 3.1) sample:\n```\n> python lief_delphi_ts.py azor3.1_patched_fixed.pe32                \nFound binary compiled with Delphi 4 - Delphi 2006\n _IMAGE_RESOURCE_DIRECTORY: 0x4cbe1371 -> 2018-05-30 02:27:34\n\n```\n\n-----\n\nThis looks a lot better. First, it matches the Delphi timestamp in the COFF File Header as\nexpected. Luckily, there are resources and hence a `_IMAGE_RESOURCE_DIRECTORY struct.`\nThe date `2018-05-30 seems to be a reasonable compilation timestamp for an Azorult`\nversion 3.1 sample.\n\n## What can we do with PE timestamps?\n\nNow that we know where we can find PE timestamps and how we can read them using a\nwide range of tools, this section answers the final question: what can we do with PE\ntimestamps? The following sections should inspire what we can do with them but also warn\nyou once more that relying solely on this feature alone can certainly be very misleading.\n\n### Use case: Determine probable intrusion date\n\nIf timestamps found in PE files were always reliable, they could be used to determine\nprobable intrusion dates, especially if you are an observer on the outside. For instance, it\n[is common to hunt for ransomware samples on online cloud services like VirusTotal as these](https://0xc0decafe.com/never-upload-ransomware-samples-to-the-internet/)\nsamples contain information that can identify the possible victim.\n\n[For instance, CL0P ransomware timestamps are reliable. Firstly,](https://www.telekom.com/en/blog/group/article/inside-of-cl0p-s-ransomware-operation-615824) incident response\nengagements suggest this. Secondly, the temporal correlation between the sample\ntimestamps, the first submission to VirusTotal, and the publication of the victim’s data on their\nleak portal seem to be in line. If you combine these factors then you can likely estimate the\ndeployment date of the ransomware from the outside.\n\nNevertheless, this is in theory not limited to ransomware deployments. PE timestamps of\nsamples that were used in a certain intrusion (possible one in the interest of the public\n[domain) can be utilized to estimate the intrusion dates of nation-state actors like Winnti.](https://malpedia.caad.fkie.fraunhofer.de/details/win.winnti)\n[Samples of Winnti typically contain information such as a C&C domain and a campaign ID](https://www.welivesecurity.com/wp-content/uploads/2019/10/ESET_Winnti.pdf)\nthat can be used to guess possible victims. In addition, PE timestamps seem to be reliable to\na certain degree to estimate at least the year of the intrusion.\n\n### Use case: Timeline of threat actor’s campaigns and threat actor’s working hours\n\nAs stated by Bartholomew & Guerrero-Saade in their exceptional paper “Wave your false\nflags!“, timestamps allow for creating a timeline of a threat actor’s campaigns or deduce their\nworking hours:\n\n\n-----\n\nA great benefit of the Portable Executable file format is the inclusion of compilation\ntimes. Though these can be altered with ease, many samples include original\ntimestamps. Beyond an obvious indication of an actor’s longevity, timestamps allow for\nan understanding of specific campaigns as well as the evolution of an actor’s toolkit\nthroughout the years. With a large enough collection of related samples, it’s also\npossible to create a timeline of the campaign operators’ workday. Where these operate\nin any professional setting or with any semblance of discipline, it’s possible to match\nthe normal peaks and troughs of a workday and pinpoint a general timezone for their\noperations.\n\n_Bartholomew & Guerrero-Saade – Wave your false flags!_\n\nThere are at least two commonly plot types possible based on the PE timestamps:\n\n[timeline of the malware samples/families (see Page 32 of Mandiant’s APT1 report for a](https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf)\ngreat example)\nheatmap by day of week and hour of day (similar to the ones typically found in web\ntraffic analysis)\n\nBartholomew & Guerrero-Saade stated “With a large enough collection of related samples”\nall these cool things can be done. Honestly, I don’t have a large number of samples for this\nblog post at hand. Nevertheless, I’ve plotted a tiny timeline of the different SDBBot versions\npublished (based on the PE timestamps) in Summer 2020. The samples are on\n[MalwareBazaar.](https://bazaar.abuse.ch/browse.php?search=tag%3Asdbbot)\n\n\n-----\n\nTimeline of SDBBot versions in Summer 2020\nOf course, the is room for improvement, and not speaking of the horrible design. For\ninstance, we could plot tiny red dots on the X-axis for every day the threat actor was active.\nIn this case, this should give us a workday / weekend pattern.\n\n### Use case: Pinpoint a threat actor to a timezone\n\nThe previous section mentions that the timezone of a threat actor can be pinpointed based\non PE timestamps. In order for this to work out, there are two requirements:\n\n“large enough collection of related samples” that we can attribute to the threat actor\nwithout a doubt\ncertain confidence that the threat actor did not tamper with the PE timestamps\n\n\n-----\n\nIt is likely that the PE timestamps fall into a certain range if the threat actor works in a\nprofessional environment with regular office hours. Likely, most samples will be compiled\nwithin an 8 to 12 hours range, which maps to a 9 to 5 pattern plus/minus two hours.\nFurthermore, there are likely one or two days off like Saturday or Sunday. But this might\ndepend on the cultural origin of the threat actor. For instance, [996 working hour system is](https://en.wikipedia.org/wiki/996_working_hour_system)\ncommon in the People’s Republic of China. In addition, there could also be thirty minutes\nand up to two hours of lunch breaks.\n\nIf you can identify such a pattern, then you add/subtract the difference of hours so that this\nmaps to the 9 AM to 5 PM range of a timezone. In case your plot does not reveal a 9 to 5\npattern, then there are still possible explanations. In case you can see two possible 9 to 5\npatterns then this could indicate shift work.\n\nFinally, another warning example of why you should not blindly trust PE timestamps. Imagine\nthat you’ve dozens of samples of a threat actor. You are pretty confident that this threat actor\nworks normal working hours from 9 AM to 5 PM (GMT+0). You could assume that this threat\nactor may work in the United Kingdom or in Portugal if you blindly and solely rely on these\ntimestamps.\n\nSuppose that later on, you’ve got additional information from incident response\nengagements. Now, it seems that the threat actor works from 12 PM to 8 PM (GMT+0). This\nwould map from 9 AM to 5 PM (GMT+3). Possible countries would now be, for instance,\nRussia or Turkey. How can you really be sure that the threat actor did not manipulate the PE\ntimestamps and subtracted three hours from each and every timestamp found in the PE\nfiles?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-01-22 - The malware analyst’s guide to PE timestamps.pdf"
    ],
    "report_names": [
        "2020-01-22 - The malware analyst’s guide to PE timestamps.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dabb6779-f72e-40ca-90b7-1810ef08654d",
            "created_at": "2022-10-25T15:50:23.463113Z",
            "updated_at": "2025-03-27T02:00:55.47619Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "APT1",
                "Comment Crew",
                "Comment Group",
                "Comment Panda"
            ],
            "source_name": "MITRE:APT1",
            "tools": [
                "Seasalt",
                "ipconfig",
                "Cachedump",
                "PsExec",
                "GLOOXMAIL",
                "Lslsass",
                "PoisonIvy",
                "WEBC2",
                "Mimikatz",
                "gsecdump",
                "Pass-The-Hash Toolkit",
                "Tasklist",
                "xCmd",
                "pwdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "cf7fc640-acfe-41c4-9f3d-5515d53a3ffb",
            "created_at": "2023-01-06T13:46:38.228042Z",
            "updated_at": "2025-03-27T02:00:02.775905Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "GIF89a",
                "G0006",
                "PLA Unit 61398",
                "Group 3",
                "TG-8223",
                "Comment Group",
                "ShadyRAT",
                "COMMENT PANDA",
                "Comment Crew",
                "Byzantine Candor",
                "Brown Fox"
            ],
            "source_name": "MISPGALAXY:APT1",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536025,
    "ts_updated_at": 1743041642,
    "ts_creation_date": 1653685953,
    "ts_modification_date": 1653685953,
    "files": {
        "pdf": "https://archive.orkl.eu/f08cf2702b1ccac42382c80ffe5d0ea4da07d7d8.pdf",
        "text": "https://archive.orkl.eu/f08cf2702b1ccac42382c80ffe5d0ea4da07d7d8.txt",
        "img": "https://archive.orkl.eu/f08cf2702b1ccac42382c80ffe5d0ea4da07d7d8.jpg"
    }
}