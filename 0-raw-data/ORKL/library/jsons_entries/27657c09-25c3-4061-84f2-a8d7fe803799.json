{
    "id": "27657c09-25c3-4061-84f2-a8d7fe803799",
    "created_at": "2023-01-12T15:00:13.922435Z",
    "updated_at": "2025-03-27T02:05:22.479253Z",
    "deleted_at": null,
    "sha1_hash": "f80d5b974ca5510e16c059dc9d4979aab1a15851",
    "title": "2019-07-09 - A Deep Dive Into IcedID Malware- Part I - Unpacking, Hooking and Process Injection",
    "authors": "",
    "file_creation_date": "2022-05-28T15:21:04Z",
    "file_modification_date": "2022-05-28T15:21:04Z",
    "file_size": 194460,
    "plain_text": "# A Deep Dive Into IcedID Malware: Part I - Unpacking, Hooking and Process Injection\n\n**[fortinet.com/blog/threat-research/icedid-malware-analysis-part-one.html](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-one.html)**\n\nJuly 9, 2019\n\n_FortiGuard Labs Threat Analysis Report Series_\n\nIcedID is a banking trojan which performs web injection on browsers and acts as proxy to\ninspect and manipulate traffic. It steals information, such as credentials, from victims. It then\nsends that stolen information to a remote server.\n\nRecently, the FortiGuard Labs team started to investigate some IcedID samples. In this\n[series of blogs, I will provide a detailed analysis of a new IcedID malware sample. The entire](https://www.fortinet.com/resources/cyberglossary/malware?utm_source=blog&utm_campaign=2021-q1-malware)\ndetailed analysis is divided into three parts.\n\nThis blog is Part I below. Let’s dive in.\n\n## 0x01 Malicious PE Executable\n\nThe sample being analyzed is a PE executable, and is most commonly distributed by a\ncompromised Office file. The following image is the process tree after executing the PE file.\nWe can see that this sample of IcedID eventually creates a svchost.exe parent process and\nthree svchost.exe child processes. In addition, it can deliver a Trickbot payload, highlighted\nin red. In this series of blogs, the analysis of the Trickbot payload won’t be covered. We will\nonly focus on how IcedID works internally.\n\nFigure 1. The process tree after executing the IcedID sample\n\n\n-----\n\nAs shown in Figure 1, the PE executable first launches itself with a command line parameter\n“-q=xxxxxxxxxx”. This new process then continues by launching a svchost.exe process.\nOnce the first svchost.exe process is launched, the previous two processes exit. Finally, this\nsvchost.exe parent process then launches three svchost.exe processes.\n\n## 0x02 Unpacking PE Executable\n\nWe can now start to dynamically analyze the PE execution. After tracing a few steps from the\nentry point, the program goes into the function sub_00415CAE() as follows.\n\nFigure 2. Jump to the trampoline code\n\nIn the trampoline code, it is used for decrypting the code segment. Eventually, it can jump to\nthe real entry point of the program. At that point, the unpacking of the PE executable is\ncomplete.\n\nFigure 3. Jump back to the real entry point 0x401000\n\nThe following is the pseudo code of the real entry point of the program.\n\nFigure 4. The pseudo code of the real entry point\n\nHere is a list of the key functions:\n\n1. Check if the command line parameter starts with “-q=”. If yes, it jumps to step 2.\n\nOtherwise, it jumps to step 3.\n2. Create the svchost.exe process and perform process injection.\n3. Create a new process with a TSC parameter (“-q=xxxxxxxxx”).\n\nWe ran this sample without any parameters so it could go into the third step (sub_4012E9).\n\nFigure 5. The function sub_4012E9()\n\nAfter performing the rdtsc instruction, the return value is converted into a string as a\nparameter of the new process execution. Next, the program sets an environment variable in\nthe process context. The name of the variable is the command line parameter without the\nprefix “-q=”.\n\nFigure 6. Set an environment variable in process context\n\nFinally, it invokes the CreateProcessA function to create itself with a parameter.\n\nNext, we will continue the analysis with the new running process.\n\n## 0x03 Hooking Technique and Process Injection\n\n\n-----\n\nAfter launching the new process, the program goes to the real entry point of the program, as\nshown in Figure 4. At this point, the check_parameter() function returns TRUE because the\ncommand line parameter starts with “-q=”. It then goes to the sub_40124A() function.\n\nFigure 7. The pseudo code of sub_40124A()\n\nIn the function hook_NtCreateUserProcess(), it first invokes the function\nNtProtectVirtualMemory to change the protection of the first five bytes of the function\nNtCreateUserProcess to PAGE_EXECUTE_READWRITE. It then modifies those five bytes\nwith a JMP instruction. Finally, it again invokes the function NtProtectVirtualMemory to\nrestore protection to the first five bytes.\n\nFigure 8. Hooking the function NtCreateUserProcess\n\nThe following is the assembly code of the function NtCreateUserProcess hooked.\n\nFigure 9. The assembly code of the function NtCreateUserProcess hooked\n\nInside the function CreateProcessA, the code invokes the low-level API\nNtCreateUserProcess. After the function CreateProcessA is invoked in Figure 7, the program\ngoes to the trampoline code sub_4010B7(). The following is the pseudo code of the\ntrampoline code.\n\nFigure 10. The trampoline pseudo code of NtCreateUserProcess hooked\n\nThe following list is what the trampoline code actually does.\n\n1. Unhooks the function NtCreateUserProcess.\n2. Calls the function NtCreateUserProcess, which performs the main work of creating a\n\nnew process.\n3. Decompresses the buffer using RtlDecompressBuffer.\n4. Performs process injection into the svchost.exe process and hooks RtlExitUserProcess\n\nin the process space of svchost.exe.\n\nLet’s take a closer look at step four. The following is the pseudo code of the function\nsub_401745() in that step.\n\nFigure 11. Perform process injection into the svchost.exe process and hook its\nRtlExitUserProcess\n\nIt first uses NtAllocateVirtualMemory to allocate the memory region in the remote process\nspace(svchost.exe). Next, it uses ZwWriteVirutalMemory to perform the code injection into\nthe memory region in the svchost.exe process.\n\nFigure 12. Process injection into in svchost.exe process\n\n\n-----\n\nIt then sets up a hook for the RtlExitUserProcess API in the process space of svchost.exe. It\nshould be noted that there is a little difference between hooking RtlExitUserProcess and\nhooking NtCreateUserProcess in Figure 8. The former is to hook the API of remote process\nspace, while the latter is to hook the API in its current process space.\n\nFigure 13. Hook RtlExitUserProcess\n\nThe assembly code of the hooked RtlExitUserProcess is shown in Figure 14.\n\nFigure 14. The hooked RtlExitUserProcess in svchost.exe process\n\nAs shown in Figure 7, the process svchost.exe was created without a parameter. It could\nimmediately exit if running svchost.exe without parameter, and after it exits, it could invoke\nthe low-level API RtlExitUserProcess. Because IcedID hooks the RtlExitUserProcess, it\ncould jump to the trampoline code to execute the IcedID payload.\n\nThe injected memory regions in the remote process svchost.ext are shown in Figure 15. We\ncan see that two memory regions have been injected. The code segment is stored in the\nmemory region(0xa1000 ~ 0xa7000).\n\nFigure 15. The injected memory regions of svchost.exe process\n\nAs shown in Figure 14, it jumps to 0xA2B2D, which is in memory region(0xA0000 ~\n0xAC000). The offset of the trampoline code from this memory region is 0x2B2D.\n\n## 0x03 Conclusion\n\nWe have walked through how to unpack the IcedID malware, hooking, and process injection\n[techniques used by IcedID, as well as how to execute the IcedID payload. In the next blog, I](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-two.html)\nwill provide a deep analysis of the IcedID payload (0xA2B2D).\n\n## 0x04 Solution\n\nThis malicious PE file has been detected as “W32/Kryptik.GTSU!tr” by the FortiGuard\nAntiVirus service.\n\n## 0x05 Reference\n\nSHA256 Hash:\n\nPE executable\n(b8113a604e6c190bbd8b687fd2ba7386d4d98234f5138a71bcf15f0a3c812e91)\n\n_[Learn more about FortiGuard Labs and the FortiGuard Security Services portfolio.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_ _Sign_\n_up for our weekly FortiGuard Threat Brief._\n\n\n-----\n\n_[Read about the FortiGuard Security Rating Service, which provides security audits and best](https://www.fortinet.com/support-and-training/support-services/fortiguard-security-subscriptions/security-rating.html?utm_source=blog&utm_campaign=2018-blog-security-rating-service)_\n_practices._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-07-09 - A Deep Dive Into IcedID Malware- Part I - Unpacking, Hooking and Process Injection.pdf"
    ],
    "report_names": [
        "2019-07-09 - A Deep Dive Into IcedID Malware- Part I - Unpacking, Hooking and Process Injection.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535613,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653751264,
    "ts_modification_date": 1653751264,
    "files": {
        "pdf": "https://archive.orkl.eu/f80d5b974ca5510e16c059dc9d4979aab1a15851.pdf",
        "text": "https://archive.orkl.eu/f80d5b974ca5510e16c059dc9d4979aab1a15851.txt",
        "img": "https://archive.orkl.eu/f80d5b974ca5510e16c059dc9d4979aab1a15851.jpg"
    }
}