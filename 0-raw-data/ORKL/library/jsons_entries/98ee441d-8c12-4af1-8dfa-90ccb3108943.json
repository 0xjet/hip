{
    "id": "98ee441d-8c12-4af1-8dfa-90ccb3108943",
    "created_at": "2023-01-12T15:01:57.012323Z",
    "updated_at": "2025-03-27T02:17:11.530736Z",
    "deleted_at": null,
    "sha1_hash": "099c775046edda41d653fa2e6bd23d8f29fa4c40",
    "title": "2020-07-14 - PYTHON MALWARE ON THE RISE",
    "authors": "",
    "file_creation_date": "2022-05-28T03:29:51Z",
    "file_modification_date": "2022-05-28T03:29:51Z",
    "file_size": 1215785,
    "plain_text": "# Python Malware On The Rise\n\n**[cyborgsecurity.com/cyborg_labs/python-malware-on-the-rise/](https://www.cyborgsecurity.com/cyborg_labs/python-malware-on-the-rise/)**\n\nJuly 14, 2020\n\n[The vast majority of serious malware over the past 30 years has been written in Assembly or](https://software.imdea.org/~juanca/papers/malsource_raid16.pdf)\ncompiled languages such as C, C++, and Delphi. However, ever-increasing over the past\ndecade, a large amount of malware has been written in interpreted languages, such as\nPython. The low barrier to entry, ease of use, rapid development process, and massive\nlibrary collection has made Python attractive for millions of developers- including malware\nauthors. Python has quickly become a standard language in which threat actors create\nRemote Access Trojans (RATs), information stealers, and vulnerability exploit tools.\nAs [Python continues to grow radically in popularity and the](https://www.techrepublic.com/article/python-is-eating-the-world-how-one-developers-side-project-became-the-hottest-programming-language-on-the-planet/) C malware\nmonoculture continues to be challenged, it would seem only certain that Python will be\nincreasingly utilized as malware in cyber attacks.\n\n\n-----\n\nImage Source: Stack Overflow\n\n## THE TIMES THEY ARE A-CHANGIN’\n\nIn comparison to a standard compiled language like C, writing malware in Python comes with\na whole host of difficulties. The first being that Python is required to be installed on the\noperating system in order to interpret and execute Python code. However, as we’ll see in the\nnext section, a Python program can easily be converted into a native executable using a\nvariety of different methods.\n\nMalware written in Python will also have adverse effects on file size, memory footprint, and\nprocessing power. Serious malware is often designed to be small, stealthy, have low memory\nfootprint, and use limited processing power. A compiled malware sample written in C might\nbe 200 KB, while a comparable malware sample written in Python might be 20 MB after\nconverted into an executable. Both the CPU & RAM usage will also be significantly higher\nwhen using an interpreted language.\n\nHowever, it’s 2020 and the digital landscape isn’t what it once was. The internet is faster than\nit’s ever been, our computers have more memory & storage capacity than ever, and CPUs\nget faster every year. Python is also more ubiquitous than ever, coming pre-installed on\nmacOS and most all Linux distributions by default.\n\n## NO INTERPRETER? NO PROBLEM!\n\nMicrosoft Windows is still the primary target for most malicious campaigns, and it does not\ncome with Python installed by default. Therefore, for threat actors to distribute their malware\neffectively they must convert their Python code into an executable format. There are many\nmethods to “compile Python” into a native executable. Let’s take a look at the few most\npopular methods…\n\n## PyInstaller\n\n[PyInstaller is capable of building Python applications into stand-alone executables for](https://www.pyinstaller.org/)\nWindows, Linux, macOS and more by “freezing” Python code. It is one of the most popular\nmethods to convert Python code into executable format and has been used widely for both\nlegitimate and malicious purposes.\n\nLet’s create a simple “Hello, world!” program in Python and freeze it into a stand-alone\nexecutable using PyInstaller:\n\n\n-----\n\n```\n$ cat hello.py\nprint('Hello, world!')\n$ pyinstaller --onefile hello.py\n...\n$ ./dist/hello \nHello, world!\n$ file dist/hello \ndist/hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,\ninterpreter\n/lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32,\nBuildID[sha1]=294d1f19a085a730da19a6c55788ec0\n8c2187039, stripped\n$ du -sh dist/hello \n7.0M dist/hello\n\n```\nThis process created a portable, stand-alone Linux ELF (Executable and Linkable Format)\nwhich is the equivalent to an EXE on Windows. Now let’s create and compile a “Hello, world!”\nprogram in C on Linux for comparison:\n```\n$ cat hello.c\n#include \nint main() {\n  printf(\"Hello, world!\");\n}\n$ gcc hello.c -o hello\n$ ./hello \nHello, world!\n$ file hello\nhello: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked,\ninterpreter\n/lib64/ld-linux-x86-64.so.2, BuildID[sha1]=480c7c75e09c169ab25d1b81bd28f66fde08da7c,\nfor GNU/Li\nnux 3.2.0, not stripped\n$ du -sh hello\n20K hello\n\n```\nNotice how much larger the file size is: 7 MB (Python) vs 20 KB (C)! This demonstrates the\nmajor drawback we discussed previously about file size and memory usage. The Python\nexecutable is so much larger due to the fact it must bundle the Python interpreter (as a\nshared object file on Linux) inside the executable itself in order to run.\n\n## py2exe\n\n\n-----\n\n[Py2exe is another popular method to convert Python code into Windows EXE (executable)](https://www.py2exe.org/)\nformat that can be run natively. Similar to PyInstaller, it bundles the Python interpreter with\nyour Python code to make a portable executable. Py2exe is likely to fall out of style with time\nas it has not been supported past Python 3.4, this is due to the bytecode in CPython being\nheavily changed in Python 3.6 and beyond.\n\nPy2exe utilizes distutils and requires a small `setup.py script to be created to produce an`\nexecutable. Let’s create an example “Hello, world!” executable using py2exe:\n```\n> type hello.py\nprint('Hello, world!')\n> type setup.py\nimport py2exe\nfrom distutils.core import setup\nsetup(\n  console=['hello.py'],\n  options={'py2exe': {'bundle_files': 1, 'compressed': True}},\n  zipfile=None\n)\n> python setup.py py2exe\n...\n> dist\\hello.exe\nHello, world!\n\n```\nThe `hello.exe created by py2exe is similar in size to PyInstaller coming in at 6.83 MB.`\n\n\n-----\n\n## Nuitka\n\n[Nuitka is perhaps the most underutilized, and yet more advanced method of compiling](https://nuitka.net/)\nPython code to an executable. It translates Python code into a C program that then is linked\nagainst libpython to execute code the same as CPython. Nuitka can use a variety of C\ncompilers including gcc, clang, MinGW64, Visual Studio 2019+, and clang-cl to convert your\nPython code to C.\n\nLet’s create a “Hello, world!” Python program on Linux and compile it using Nuitka:\n\n\n-----\n\n```\n$ cat hello.py\nprint('Hello, world!')\n$ nuitka3 hello.py\n...\n$ ./hello.bin\nHello, world!\n$ file hello.bin \nhello.bin: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically\nlinked, interpreter\n/lib64/ld-linux-x86-64.so.2, BuildID[sha1]=eb6a504e8922f8983b23ce6e82c45a907c6ebadf,\nfor GNU/Linux \n3.2.0, stripped\n$ du -sh hello.bin\n432K hello.bin\n\n```\nNuitka produced a portable binary very simply, and at 432 KB is a fraction of the size of what\nPyInstaller or py2exe can produce! How is Nuitka able to do this? Let’s take a look at the\nbuild folder:\n```\n$ cloc hello.build/\n------------------------------------------------------------------------------Language           files     blank    comment      code\n------------------------------------------------------------------------------C                11      2263      709      8109\nC/C++ Header           1       1       0       7\n------------------------------------------------------------------------------SUM:              12      2264      709      8116\n------------------------------------------------------------------------------\n```\nNuitka produced over 8,000 lines of C code from our 1 line Python program. The way Nuitka\nworks is it actually translates the Python modules into C code and then uses libpython and\nstatic C files of its own to execute in the same way as CPython does.\n\nThis is very impressive, and it seems highly likely the Nuitka “Python compiler” will see\nfurther adoption as time goes on. As we’ll see later, Nuitka might have a further, built-in\nadvantage in protection against Reverse Engineering (RE). There already exist several tools\nto easily analyze binaries produced by PyInstaller and py2exe to recover Python source\ncode. However, by Nuitka translating the Python code to C it is much more difficult to reverse\nengineer.\n\n## YO DAWG, I HEARD YOU LIKE TOOLS…\n\n\n-----\n\nPython malware can take advantage of a massive ecosystem of open-source Python\npackages and repositories. Almost anything you could think of, someone has already built it\nusing Python. This is a huge advantage to malware authors as simplistic capabilities can be\ncherry-picked from the open web and more complex capabilities likely don’t need to be\nwritten from scratch.\n\nLet’s take a look at three simple, yet powerful tool examples:\n\n1. Code Obfuscation\n2. Taking Screenshots\n3. Performing Web Requests\n\n## Tool Example 1 — Obfuscation\n\nMalware authors using Python have many libraries they could use to obfuscate their Python\ncode to make code readability much more difficult, such as: [pyminifier and](https://github.com/liftoff/pyminifier) [pyarmor.](https://github.com/dashingsoft/pyarmor)\n\nHere’s a small example of how `pyarmor can obfuscate Python code:`\n\n\n-----\n\n```\n$ cat hello.py \nprint('Hello, world!')\n$ pyarmor obfuscate hello.py\n...\n$ cat dist/hello.py\nfrom pytransform import pyarmor_runtime\npyarmor_runtime()\n__pyarmor__(__name__, __file__,\nb'\\x50\\x59\\x41\\x52\\x4d\\x4f\\x52\\x00\\x00\\x03\\x08\\x00\\x55\\x0d\\x0d\\\nx0a\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\xd5\\x00\\x00\\x00\\x0\n\\x18\\xf4\\x63\\x79\\xf6\\xaa\\xd7\\xbd\\xc8\\x85\\x25\\x4e\\x4f\\xa6\\x80\\x72\\x9f\\x00\\x00\\x00\\x00\\x\n0\\x00\\xec\\x50\\x8c\\x64\\x26\\x42\\xd6\\x01\\x10\\x54\\xca\\x9c\\xb6\\x30\\x82\\x05\\xb8\\x63\\x3f\\xb0\\\n97\\x0b\\xc1\\x49\\xc9\\x47\\x86\\x55\\x61\\x93\\x75\\xa2\\xc2\\x8c\\xb7\\x13\\x87\\xff\\x31\\x46\\xa5\\x29\nxdf\\x32\\xed\\x7a\\xb9\\xa0\\xe1\\x9a\\x50\\x4a\\x65\\x25\\xdb\\xbe\\x1b\\xb6\\xcd\\xd4\\xe7\\xc2\\x97\\x3\n\\xd3\\xd0\\x74\\xb8\\xd5\\xab\\x48\\xd3\\x05\\x29\\x5e\\x31\\xcf\\x3f\\xd3\\x51\\x78\\x13\\xbc\\xb3\\x3e\\x\na\\x05\\xfb\\xac\\xed\\xfa\\xc1\\xe3\\xb8\\xa2\\xaa\\xfb\\xaa\\xbb\\xb5\\x92\\x19\\x73\\xf0\\x78\\xe4\\x9f\\\n7a\\x1c\\x0c\\x6a\\xa7\\x8b\\x19\\x38\\x37\\x7f\\x16\\xe8\\x61\\x41\\x68\\xef\\x6a\\x96\\x3f\\x68\\x2b\\xb7\nx39\\x51\\xa3\\xfc\\xbd\\x65\\xdb\\xb8\\xff\\x39\\xfe\\xc0\\x3d\\x16\\x51\\x7f\\xc9\\x7f\\x8b\\xbd\\x88\\x8\n\\xe1\\x23\\x61\\xd0\\xf1\\xd3\\xf8\\xfa\\xce\\x86\\x92\\x6d\\x4d\\xd7\\x69\\x50\\x8b\\xf1\\x09\\x31\\xcc\\x\nf\\x37\\x12\\xd4\\xbd\\x3d\\x0d\\x6e\\xbb\\x28\\x3e\\xac\\xbb\\xc4\\xdb\\x98\\xb5\\x85\\xa6\\x19\\x11\\x74\\\ndf', 1)\n$ python dist/hello.py\nHello, world!\n\n## Tool Example 2 — Screenshots\n\n```\nInformation stealing malware will often come with the capability to take screenshots of the\nusers desktop in order to steal sensitive information. Using Python this is all too easy and\n[there are several libraries to accomplish this, including: pyscreenshot and](https://github.com/ponty/pyscreenshot) [python-mss.](https://github.com/BoboTiG/python-mss)\n\nA screenshot can easily be taken with `python-mss like this:`\n```\nfrom mss import mss\nwith mss() as sct:\n  sct.shot()\n\n## Tool Example 3 — Web Requests\n\n```\n\n-----\n\nMalware will often conduct web requests to do a variety of different things on a compromised\nendpoint, including: web-based command & control (C2), obtaining the external IP address,\ndownloading a second stage payload, and more. Using Python, making web requests is very\nsimple and can be done using the standard library or with open-source libraries such\nas: [requests and](https://github.com/psf/requests) [httpx.](https://github.com/encode/httpx)\n\nThe external IP address of a compromised endpoint can easily be obtained\nusing `requests like so:`\n```\nimport requests\nexternal_ip = requests.get('http://whatismyip.akamai.com/').text\n\n## THE STRENGTH OF EVAL()\n\n```\nTypically, Python’s `eval() built-in function is seen as very dangerous as it presents serious`\nsecurity risks when used in production code. However, `eval() has a huge strength when`\nused within Python malware.\n\nThe `eval() function is very powerful and can be used to execute strings of Python code`\nfrom within the Python program itself. This single function is often seen as an advanced\ncapability in compiled malware. It is the ability to run high-level scripts or “plugins” on-the-fly\nwhen utilized correctly. This is similar to when C malware includes a Lua scripting engine to\ngive the malware the ability to execute Lua scripts. This has been seen in high-profile\n[malware such as Flame.](https://en.wikipedia.org/wiki/Flame_(malware))\n\nLet’s imagine a hypothetical APT group is interacting remotely with some Python-based\nmalware. If this group came into an unexpected situation where they needed to react quickly,\nbeing able to directly execute Python code on the end target would be highly beneficial. In\naddition, the Python malware could be placed on a target effectively “featureless” and\ncapabilities could be executed on the target on an as-needed basis to remain stealthy.\n\n## INTO THE WILD\n\nAlright, let’s take a look at a few real world Python malware samples!\n\n\n-----\n\nImage Source: Lord of the Rings — Fellowship of the Ring\n\n## SeaDuke\n\nThe SeaDuke malware is likely the most high-profile compromise that Python-based\nmalware has been involved in. During 2015 and 2016, the Democratic National Committee\n(DNC) was compromised by two threat actor groups that have been attributed by many\nanalysts to APT 28 & 29.\n\n[Some fantastic analysis of SeaDuke was conducted by Palo Alto’s Unit 42. The](https://unit42.paloaltonetworks.com/unit-42-technical-analysis-seaduke/) decompiled\nPython source code Unit 42 uncovered can be found here. In addition, F-Secure published a\ngreat [whitepaper on Duke malware that covers SeaDuke and associated malware.](https://blog-assets.f-secure.com/wp-content/uploads/2020/03/18122307/F-Secure_Dukes_Whitepaper.pdf)\n\nThe SeaDuke malware is a Python trojan that was made into a Windows executable using\n[PyInstaller and packed with UPX. The Python source code was obfuscated to make the code](https://en.wikipedia.org/wiki/UPX)\nmore difficult for analysts to read. The malware had many capabilities including several\nmethods to establish persistence on Windows, ability to run cross-platform, and perform web\nrequests for command & control.\n\n## PWOBot\n\nPWOBot is Python-based malware, similar to SeaDuke it is compiled using PyInstaller into a\nWindows executable. It was prevalent during 2013–2015 and affected several European\norganizations, mostly in Poland.\n\nThe malware was very full featured and included the ability to log key strokes, establish\npersistence on Windows, download & execute files, execute Python code, create web\nrequests, and mine cryptocurrency. Some great analysis of PWOBot was conducted by Palo\nAlto’s Unit 42.\n\n## PyLocky\n\n\n-----\n\n[PyLocky is a Python-based ransomware, compiled with PyInstaller into a Windows](https://www.cyborgsecurity.com/glossary/ransomware/)\nstandalone executable. It targeted several different countries including the USA, France,\nItaly, and Korea. It included anti-sandbox capabilities, command & control, and encrypted\nfiles using 3DES (Triple DES) cipher.\n\n[Some great analysis of PyLocky was conducted by Trend Micro. Talos Intelligence analysts](https://blog.trendmicro.com/trendlabs-security-intelligence/a-closer-look-at-the-locky-poser-pylocky-ransomware/)\n[reversed engineered PyLocky and were able to create a file decryptor for victims to restore](https://talosintelligence.com/pylocky)\ntheir encrypted files.\n\n## PoetRAT\n\nPoetRAT is a Python-based trojan that targeted the Azerbaijan government and energy\nsector in early 2020. The trojan enumerated systems and stole information related to\nICS/SCADA systems that control wind turbines.\n\nThe malware was dropped using malicious Microsoft Word documents. The RAT presented\nmany capabilities for stealing information including file extraction over FTP, taking images\nwith webcams, uploading additional tools, keylogging, browser enumeration, and credential\ntheft. Talos Intelligence reported on this threat actor and produced a fantastic writeup on the\nunknown actor that used this malware.\n\nThis short script was used by the threat actor to capture web cam images:\n\nImage Source: Talos Intelligence\n\n## Open Source\n\nIn addition to the malware found in the wild, several Python RATs are available open-source\nsuch as [pupy and](https://github.com/n1nj4sec/pupy) [Stitch. These open-source Python trojans show just how complex and](https://github.com/nathanlopez/Stitch)\nfeature rich Python malware can be. The pupy RAT is cross-platform, features an all-inmemory execution guideline, leaves a very low footprint, can combine several C2 encryption\nmethods, migrate into processes using reflective injection, and can load remote python code\nfrom memory.\n\n## PYTHON MALWARE ANALYSIS TOOLS\n\n\n-----\n\nThere are many tools available to analyze Python malware, even in compiled form. Let’s take\na cursory look at what tools malware analysts can use to tear into Python malware.\n\n## uncompyle6\n\n[The successor to decompyle, uncompyle, and uncompyle2- uncompyle6 is a native Python](https://github.com/rocky/python-uncompyle6/)\ncross-version decompiler and fragment decompiler. It can be used to translate Python\nbytecode back into Python source code.\n\nFor example, taking our “Hello, world!” script from earlier and executing it as a module I’m\npresented with a pyc file (byte code). We can recover the source code of our script by using\nuncompyle.\n```\n$ xxd hello.cpython-38.pyc \n00000000: 550d 0d0a 0000 0000 16f3 075f 1700 0000 U.........._....\n00000010: e300 0000 0000 0000 0000 0000 0000 0000 ................\n00000020: 0002 0000 0040 0000 0073 0c00 0000 6500 [email protected]\n00000030: 6400 8301 0100 6401 5300 2902 7a0d 4865 d.....d.S.).z.He\n00000040: 6c6c 6f2c 2077 6f72 6c64 214e 2901 da05 llo, world!N)...\n00000050: 7072 696e 74a9 0072 0200 0000 7202 0000 print..r....r...\n00000060: 00fa 2d2f 686f 6d65 2f75 7365 722f 746d ..-/home/user/tm\n00000070: 702f 7079 7468 6f6e 5f61 7274 6963 6c65 p/python_article\n00000080: 2f6e 2f74 6573 742f 6865 6c6c 6f2e 7079 /n/test/hello.py\n00000090: da08 3c6d 6f64 756c 653e 0100 0000 f300 ........\n000000a0: 0000 00\n$ uncompyle6 hello.cpython-38.pyc | grep -v '#'\nprint('Hello, world!')\n\n## pyinstxtractor.py (PyInstaller Extractor)\n\n```\nThe [PyInstaller Extractor can extract Python data from PyInstaller compiled executables. It’s](https://github.com/extremecoders-re/pyinstxtractor)\nvery simple to run:\n```\n> python pyinstxtractor.py hello.exe\n...\n\n```\nThis will produce pyc files you can then use with the uncompyle6 decompiler to recover\nsource code.\n\n## python-exe-unpacker\n\nThe [pythonexeunpack.py script can be used to unpack and decompile executables that are](https://github.com/countercept/python-exe-unpacker)\nbuilt with py2exe. It can be used like so:\n```\n> python python_exe_unpack.py -i hello.exe\n...\n\n## DETECTING PYTHON COMPILED EXECUTABLES\n\n```\n\n-----\n\nBoth PyInstaller and py2exe when compiled on Windows place unique strings within their\nbinary executable. Which means they can be detected with simple YARA rules.\n\nPyInstaller writes the string “pyi-windows-manifest-filename” near the end of the executable,\nyou can see it here in a hex editor (HxD):\n\n[Here’s a YARA rule for detecting PyInstaller compiled executables (Source):](https://isc.sans.edu/forums/diary/Python+Malware+Part+1/21057/)\n```\nimport \"pe\"\nrule PE_File_pyinstaller\n{\n  meta:\n    author = \"Didier Stevens (https://DidierStevens.com)\"\n    description = \"Detect PE file produced by pyinstaller\"\n  strings:\n    $a = \"pyi-windows-manifest-filename\"\n  condition:\n    pe.number_of_resources > 0 and $a\n}\n\n```\n\n-----\n\n[Here s a second YARA rule for detecting py2exe compiled executables (Source):](https://github.com/NVISO-BE/YARA/blob/master/py2exe.yara)\n```\nimport \"pe\"\nrule py2exe\n{\n meta:\n    author = \"Didier Stevens (https://www.nviso.be)\"\n    description = \"Detect PE file produced by py2exe\"\n condition:\n    for any i in (0 .. pe.number_of_resources - 1):\n     (pe.resources[i].type_string ==\n\"P\\x00Y\\x00T\\x00H\\x00O\\x00N\\x00S\\x00C\\x00R\\x00I\\x00P\\x00T\\x00\")\n}\n\n## CONCLUSION\n\n```\nThat’s all for now from the world of Python malware. It’s very interesting watching malware\ntrends change as computer systems become faster and easier to operate. As a security\nindustry we need to keep an eye on Python-based malware, or it might just sink its fangs into\nus when we’re least expecting.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-14 - PYTHON MALWARE ON THE RISE.pdf"
    ],
    "report_names": [
        "2020-07-14 - PYTHON MALWARE ON THE RISE.pdf"
    ],
    "threat_actors": [
        {
            "id": "64d750e4-67db-4461-bae2-6e75bfced852",
            "created_at": "2022-10-25T16:07:24.01415Z",
            "updated_at": "2025-03-27T02:02:10.077988Z",
            "deleted_at": null,
            "main_name": "Operation Spalax",
            "aliases": [],
            "source_name": "ETDA:Operation Spalax",
            "tools": [
                "AsyncRAT",
                "Bladabindi",
                "Jorik",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Socmer",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535717,
    "ts_updated_at": 1743041831,
    "ts_creation_date": 1653708591,
    "ts_modification_date": 1653708591,
    "files": {
        "pdf": "https://archive.orkl.eu/099c775046edda41d653fa2e6bd23d8f29fa4c40.pdf",
        "text": "https://archive.orkl.eu/099c775046edda41d653fa2e6bd23d8f29fa4c40.txt",
        "img": "https://archive.orkl.eu/099c775046edda41d653fa2e6bd23d8f29fa4c40.jpg"
    }
}