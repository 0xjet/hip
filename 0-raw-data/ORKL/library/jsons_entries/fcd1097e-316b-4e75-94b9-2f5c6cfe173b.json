{
    "id": "fcd1097e-316b-4e75-94b9-2f5c6cfe173b",
    "created_at": "2023-01-12T15:00:05.960142Z",
    "updated_at": "2025-03-27T02:05:37.817895Z",
    "deleted_at": null,
    "sha1_hash": "47bbeb218e55800bd4519620d00c6ab727f75ae9",
    "title": "2020-02-20 - Analysis of an Unusual HawkEye Sample",
    "authors": "",
    "file_creation_date": "2022-05-28T01:58:56Z",
    "file_modification_date": "2022-05-28T01:58:56Z",
    "file_size": 1559263,
    "plain_text": "# Analysis of an Unusual HawkEye Sample\n\n**govcert.ch/blog/analysis-of-an-unusual-hawkeye-sample/**\n\n## GovCERT.ch\n\n[Homepage](https://www.govcert.ch/)\n[GovCERT.ch](https://www.govcert.ch/blog/) Blog\n\n### Blog Posts\n\nRecently published blog posts:\n\n[12.12.2021Zero-Day Exploit Targeting Popular Java Library Log4j](https://www.govcert.ch/blog/zero-day-exploit-targeting-popular-java-library-log4j/)\n[09.03.2021Exchange Vulnerability 2021](https://www.govcert.ch/blog/exchange-vulnerability-2021/)\n[27.10.2020Cyber Security for the Healthcare Sector During Covid19](https://www.govcert.ch/blog/cyber-security-for-the-healthcare-sector-during-covid19/)\n\n### Blog Archive\n\n\nClose\n\n\nGo to the blog archive and browse all previous blog posts we have published so\nfar.\n\n### RSS Feed\n\nSubscribe to the GovCERT.ch blog RSS feed to stay up to date and get notified\nabout new blog posts.\n\n\n-----\n\nWhitepapers\n\n### Whitepapers\n\nRecently published whitepapers:\n\n[23.09.2019Trickbot - An analysis of data collected from the botnet](https://www.govcert.ch/whitepapers/trickbot-an-analysis-of-data-collected-from-the-botnet/)\n[03.03.2017Scripting IDA Debugger to Deobfuscate Nymaim](https://www.govcert.ch/whitepapers/scripting-ida-debugger-to-deobfuscate-nymaim/)\n23.05.2016Technical Report about the Malware used in the\nCyberespionage against RUAG\n\n### Whitepapers RSS feed\n\n\nClose\n\n\nSubscribe to the whitepapers RSS feed to stay up to date and get notified about\nnew whitepapers.\n\n[Report an Incident](https://www.govcert.ch/report/)\n\nClose\n\n### Report an incident to NCSC\n\nReport an incident: incidents[at]govcert{dot}ch\nGeneral inquiries: outreach[at]govcert{dot}ch\n\n### Point of contact for CERTs and CSIRTs\n\nThe following email address can be considered as point of contact for FIRST\nmembers and other CERTs/CSIRTs:\n\nincidents[at]govcert{dot}ch\n\n### Encrypted Email\n\nGovCERT.ch [PGP-Key (preferred)](https://www.govcert.ch/downloads/govcert.pgp)\nAlternative GovCERT.ch PGP Key (for older versions of PGP without\nCurve25519 support)\n[GovCERT.ch SMIME](https://www.govcert.ch/downloads/govcert_2021.crt)\n\n\n-----\n\n[Statistics](https://www.govcert.ch/statistics/)\n\n\n-----\n\nClose\n\n\n## Breadcrumbs\n\n Introduction\n\nCurrently, we are observing HawkEye samples being distributed by large\nmalspam waves. HawkEye1 is a keylogger which has been around quite a long\ntime (since 2013) and has evolved since then and gained more functionality.\nThere are several good blog posts about HawkEye in general 2 3 . Recently we\nobserved an interesting obfuscation method in a HawkEye binary 4, which we\nare going to describe in this blog post.\n\n\n## Extracting Base32 encoded DLL\n\nHawkEye is written in .NET and thus we can analyze it rather easily with the\nhelp of dnSpy .5\n\nLooking through the decompiled source code in dnSpy we find the method\n```\ngate in the class Sinister .\n\n```\n\nThe Base326 encoded strings are concatenated, then reversed and decoded.\nThe output of the decoded string is a DLL written in .NET as well. We can easily\ndecode the string using `rev and` `base32 on a Linux system or with the help`\nof similar tools.\n\nAfter decoding, the DLL is loaded and the property `iraq is set via reflection 7.`\nThis value is a concatenated string consisting of the following nine static strings.\n\n\n-----\n\n_Side note: The concatenated string used here is encoded with non-latin letters_\n_(maybe Farsi, any feedback most welcome). Trying to concatenate the strings in_\n_[a text editor did not really work, however, using dotnetfiddle.net revealed the](https://dotnetfiddle.net/)_\n_correct string._ _Update: According to our colleagues at FedPol/BKP the string is_\n_actually Urdu. Thanks for the hint, most appreciated._\n\n\n-----\n\n)\n\n## Extracting EXE file from embedded PNG\n\nAfter opening the DLL in `dnspy, we can examine the` `set_iraq method. The`\nonly thing this method does is to pass the argument to the method\n```\nArgueMents.e1 .\n\n```\nThe method `e1 loads and starts another executable file (lines 34â€“36). In order`\nto analyze this executable, we need to know how it is loaded into the\n```\nrawAssembly array and how we can extract it.\n\n```\n\n-----\n\nLine 30 instantiates a `Bitmap object with the value that was passed to the`\n```\nset_iraq method. Looking at the code of the method i10 we see, that the\n\n```\nimage is loaded from the `ResourceManager of the main binary. The bitmap is a`\nPNG file, located in the resource section of the main executable.\n\nNext, the `Bitmap is passed to the method` `e5 . This method reads the width`\nand the height of the PNG. It then loops over the height (inner loop) and the\nwidth (outer loop) and stores the red, green and blue value of every pixel into a\narray and returns it. The alpha values as well as all pixels that are `r,g,b,a =`\n```\n(0,0,0,0) are omitted.\n\n```\n\n-----\n\nThe resulting array is then passed to the decryption method `e9 .`\n\nIn this method, a new array is created which is 16 bytes smaller than the array\ncontaining the color values. Then, the image array is copied to the new array\n(the first 16 bytes are omitted). The first 16 bytes are in fact the key needed to\ndecrypt the rest of the data using `XOR . There is a` `for loop, which will iterate`\nover every value in the smaller array and XORs the value with the\ncorresponding value of the key.\n\nThe decoded data is a PE file (exe), which is loaded into the memory. Finally the\n```\nEntryPoint of the File is called.\n\n```\nAs the key is stored in the Image itself, we can write a small python script to\ndecrypt this and similar images.\n\n\n-----\n\n```\n#!/usr/bin/python3\nfrom PIL import Image\nimport argparse\nKEY_LENGTH = 16\ndef get_color_values(file_name):\n  arr = bytearray()\n  im = Image.open(file_name)\n  w, h = im.size\n  for i in range(w):\n    for j in range(h):\n      r, g, b, t = im.getpixel((i, j))\n      # ignore zero values\n      if (r, g, b, t) != (0, 0, 0, 0):\n        arr.extend([r, g, b])\n  return arr\ndef process(input_file, output_file):\n  arr = get_color_values(input_file)\n  key = arr[:KEY_LENGTH]\n  data = arr[KEY_LENGTH:]\n  for i in range(len(data)):\n    data[i] ^= key[i % KEY_LENGTH]\n  with open(output_file, \"wb\") as o:\n    o.write(data)\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\"input_file\")\n  parser.add_argument(\"output_file\")\n  args = parser.parse_args()\n  process(args.input_file, args.output_file)\n\n```\nIn this case, the resulting PE file is once again heavily obfuscated, the first stage\nis obfuscated with Babel Obfuscator .8 The final payload after several\nobfuscation rounds is HawkEye.\n\n## Conclusion\n\nThe obfuscation technique using a PNG file to store a PE file is neither new, nor\nvery advanced. However we found it to be noteworthy nevertheless as we do\nnot see it often. It could be an interesting way to bypass anti virus products,\nbecause the PE file is loaded directly into the memory, however in this case, the\nresulting HawkEye binary stores a copy of itself on the disk after the infection\nand therefore may be detected by AV products.\n\n\n-----\n\nThe detection rate of VirusTotal shows, that the smuggling technique is actually\nworking. The initial malicious file 4 is detected by only 17 AV engines (two weeks\nafter the first upload). The decrypted PE file9 was detected by 34 engines right\nafter upload.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-20 - Analysis of an Unusual HawkEye Sample.pdf"
    ],
    "report_names": [
        "2020-02-20 - Analysis of an Unusual HawkEye Sample.pdf"
    ],
    "threat_actors": [
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535605,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1653703136,
    "ts_modification_date": 1653703136,
    "files": {
        "pdf": "https://archive.orkl.eu/47bbeb218e55800bd4519620d00c6ab727f75ae9.pdf",
        "text": "https://archive.orkl.eu/47bbeb218e55800bd4519620d00c6ab727f75ae9.txt",
        "img": "https://archive.orkl.eu/47bbeb218e55800bd4519620d00c6ab727f75ae9.jpg"
    }
}