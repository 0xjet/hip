{
    "id": "2931ca62-3859-49cd-80ad-045bf7f17671",
    "created_at": "2023-01-12T15:10:31.100829Z",
    "updated_at": "2025-03-27T02:05:45.585652Z",
    "deleted_at": null,
    "sha1_hash": "3a97b6d075c62b4081d1394aa7464f0fc1da965a",
    "title": "2019-06-06 - A Deep Dive into the Emotet Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T15:20:59Z",
    "file_modification_date": "2022-05-28T15:20:59Z",
    "file_size": 370455,
    "plain_text": "# A Deep Dive into the Emotet Malware\n\n**[fortinet.com/blog/threat-research/deep-dive-into-emotet-malware.html](https://www.fortinet.com/blog/threat-research/deep-dive-into-emotet-malware.html)**\n\nJune 6, 2019\n\nEmotet is a trojan that is primarily spread through spam emails. During its lifecycle, it has gone\nthrough a few iterations. Early versions were delivered as a malicious JavaScript file. Later\nversions evolved to use macro-enabled Office documents to retrieve a malicious payload from a C2\nserver.\n\nFortiGuard Labs has been tracking Emotet since it was first discovered, and in this blog, I will\nprovide a deep analysis of a new Emotet sample found in early May. This detailed analysis\nincludes how to unpack the persistent payload, how Emotet malware communicates with its C2\nservers, how to identify the hard-coded C2 server list and RSA key in the executable, as well as\nhow it encrypts the data it gathers.\n\n## 0x01 Malicious Word Document\n\nThis sample is a Word document file. When you open it and enable the macro in Word, the\nmalware starts to execute.\n\n**Figure 1. Executing a PowerShell script**\n\n\n-----\n\nWe can see here that the VB script inside the malicious Word document file is able to create a new\nprocess with PowerShell. The option ‘-e’ in PowerShell indicates that it accepts a base64-encoded\nstring version of commands.\n\nThe decoded PowerShell script is shown in Figure 2:\n\n**Figure 2. Debugging the decoded PowerShell script**\n\nThe variable $YBAAU_D is a list which includes five URLs. It uses them to download a payload\nfrom a remote server and then execute it. The following table lists each malicious URL, the name\nof the payload that can be downloaded from the corresponding URL, the Sha256 value, and\npayload size.\n\nWhen I started to investigate this sample in early May, the first two URLs could not be accessed,\nwhile the three remaining URLs were all active. All three payloads are PE files.\n\nNext, we will choose one of them to do further investigation. In this blog, all analysis is based on\nthe payload p4xl0bbb85.exe\n(sha256:21145645cac74e0b590813eafd257a2c4af6c6be0bc86d873ad0e6c005c0911d).\n\n## 0x02 First Layer Payload\n\nThe payload p4xl0bbb85.exe is packed by a customized packer. After it executes, it creates three\nnew processes, shown below:\n\n**Figure 3. The process tree after executing the payload p4xl0bbb85.exe**\n\nIt first launches the process (pid:2784) with the command line ‘--f02b3a38’. It then writes the PE file\n‘itsportal.exe’ into the folder C:\\Users\\[XXX]\\AppData\\Local\\itsportal\\. Next, it executes itsportal.exe\nwithout any parameters. After itsportal.exe is executed, it is able to launch the process (pid:1980)\nwith the command line ‘--c6857361’. Finally, the first three created processes exit and the PE file\np4xl0bbb85.exe is deleted the from hard disk. The PE file itsportal.exe is the persistent payload.\n\n**Figure 4. The persistent payload**\n\n## 0x03 Analysis of Persistent Payload\n\nIn this section, we will continue to analyze the persistent payload itsportal.exe. This payload has a\ncustomized packer. After tracing a few steps from the entry point, the program goes into the\nfunction sub_4012E0().\n\n**Figure 5. The function sub_4012E0()**\n\nThe following is the pseudo C code of the function sub_4012E0().\n\n**Figure 6. The pseudo C code of the function sub_4012E0()**\n\n\n-----\n\nIn this function, the malware invokes the function sub_401440() to allocate a new memory\nregion(0x1D0000) with VirtualAllocEx(), and sets the starting address of this memory plus 0x102f0\nas the trampoline address.\n\nThen, in the loop, it first copies the first 0x7B bytes of data from 0xf080f8 to the new memory\nregion, then continues to copy data. When the byte reaches 0x37, it’s not copied to the new\nmemory region. The size of data copied into the memory region is 0x10600.\n\nNext, the function sub_401560() is used to decrypt the data in the new memory region, and at this\npoint the trampoline code is decrypted. Later, we will see that the program is going to jump to the\ntrampoline code. Finally, the program jumps to 0x00401260 to execute its instructions.\n\n**Figure 7. Jump to 0x00401260**\n\nAs shown in Figure 8, the program will jump to 0x1E02F0 to execute the trampoline code.\n\n**Figure 8. Jump to the trampoline code**\n\nThe trampoline code mainly does the following things:\n\n1. Allocates a new memory region (0x1F0000) with a size of 0x10000, and it is named memory\nregion A.\n2. Copies 0xf600 bytes of data from 0x1D0124 to the memory region A.\n3. Decrypts the data of memory region A set up in step 2. The decryption algorithm is shown below.\n\n4. Allocates a new memory region(0x200000), whose size is 0x14000. It is named memory region\nB.\n5. Copies the first 0x400 bytes of data from memory region A to the start of memory region B.\n6. Copies all segments of data from memory region A to memory region B.\n7. Calls the function UnmapViewofFile(0x400000) that enables it to unmap a mapped view of a file\nby calling a process’s address space.\n8. Calls the function VirtualAlloc(0x400000,0x14000,MEM_COMMIT|MEM_RESERVE,\nPAGE_EXECUTE_READWRITE) to enable execute, read/write access to the memory region.\n9. Copies the 0x14000 bytes of data from memory region B to 0x400000.\n10. Jumps back to the real entry point (0x4CA90) from the trampoline to execute instructions. At\nthis point, the unpacking work is finished.\n\nThe following screenshot is the memory map. I highlight three allocated memory regions as well as\nthe unpacked program.\n\n**Figure 9. Highlight of three allocated memory regions and the unpacked program**\n\nFinally, the program jumps to the real entry point 0x4C9A0. (NOTE: At this time, you could use the\nplugin OllyDumpEx to dump the unpacked program in x64dbg. Once you get the unpacked\nprogram, you could perform static analysis on it with IDA Pro.)\n\n**Figure 10. Jump to the real entry point**\n\n\n-----\n\nSo far, we have demonstrated how to unpack the Emotet malware. In the unpacked program, the\nC2 server list is hard-coded at offset 0x40F710, and the public key is hard-coded at offset\n**0x40FBF0.**\n\n## 0x04 Communication with C2 Server\n\nIn order to investigate its communication with the C2 server, we first need to obtain the C2 server\nlist. As mentioned in section 3, the C2 server list is hard-coded in the executable file. After\nunpacking, we can see that the buffer starting at offset 0x40F710 stores the C2 server list, as\nshown in Figure 11:\n\n**Figure 11. The hard-coded C2 server list**\n\nA global variable is stored at 0x004124A0. It has the following structure in the C programming\nlanguage.\n\n**_struct g_ip_port_list_**\n\n**_{_**\n\n**_DWORD *c2_list;_**\n\n**_DWORD *current_c2;_**\n\n**_DWORD size;_**\n\n**_DWORD current_c2_index;_**\n\n**_}_**\n\nThe member variable c2_list points to the hard-coded C2 server list buffer. Each item in this list\nincludes a pair of an IP address and port. Its size is 8 bytes, with the first four bytes representing\nthe IP address, followed by the two bytes that represent the port. The member variable\n**_current_c2 points to the currently selected C2 server. The member variable size is the size of the_**\nC2 server list. The member variable current_c2_index represents the index of the current selected\nC2 server in the C2 server list.\n\nThis sample has 61 C2 servers, which are listed below.\n\n200.58.171.51:80\n\n189.196.140.187:80\n\n222.104.222.145:443\n\n115.132.227.247:443\n\n190.85.206.228:80\n\n216.98.148.136:4143\n\n\n-----\n\n111.67.12.221:8080\n\n185.94.252.27:443\n\n139.59.19.157:80\n\n159.69.211.211:8080\n\n107.159.94.183:8080\n\n72.47.248.48:8080\n\n24.150.44.53:80\n\n176.58.93.123:8080\n\n186.139.160.193:8080\n\n217.199.175.216:8080\n\n181.199.151.19:80\n\n85.132.96.242:80\n\n51.255.50.164:8080\n\n103.213.212.42:443\n\n192.155.90.90:7080\n\n66.209.69.165:443\n\n109.104.79.48:8080\n\n181.142.29.90:80\n\n77.82.85.35:8080\n\n190.171.230.41:80\n\n144.76.117.247:8080\n\n187.188.166.192:80\n\n201.203.99.129:8080\n\n200.114.142.40:8080\n\n43.229.62.186:8080\n\n189.213.208.168:21\n\n\n-----\n\n181.37.126.2:80\n\n109.73.52.242:8080\n\n181.29.101.13:80\n\n190.180.52.146:20\n\n82.226.163.9:80\n\n200.28.131.215:443\n\n213.172.88.13:80\n\n185.86.148.222:8080\n\n190.117.206.153:443\n\n192.163.199.254:8080\n\n103.201.150.209:80\n\n181.30.126.66:80\n\n200.107.105.16:465\n\n165.227.213.173:8080\n\n81.3.6.78:7080\n\n5.9.128.163:8080\n\n69.163.33.82:8080\n\n196.6.112.70:443\n\n37.59.1.74:8080\n\n23.254.203.51:8080\n\n190.147.116.32:21\n\n200.45.57.96:143\n\n91.205.215.57:7080\n\n189.205.185.71:465\n\n219.94.254.93:8080\n\n186.71.54.77:20\n\n\n-----\n\n175.107.200.27:443\n\n66.228.45.129:8080\n\n62.75.143.100:7080\n\nNext, let’s take a look at the traffic sent to the C2 servers. In this sample, it sends an HTTP POST\nrequest to the C2 server.\n\n**Figure 12. The captured traffic that is sent to the C2 servers**\n\nThe HTTP session is shown below. The HTTP body data is encoded with the URL Encode\nalgorithm.\n\n**Figure 13. The HTTP session data**\n\nAfter performing URL decoding, we can see the data is encoded with Base64. After Base64\ndecoding, we can finally see the real data that is encrypted. In this next section, let’s dive into the\nencryption algorithm of the HTTP body data.\n\n**Figure 14. The Decoded HTTP body data with URL decoding and Base64 decoding**\n\n## 0x05 Encryption Algorithm\n\nThe Emotet malware can gather some system info, such as host name, the list of all processes\nrunning on the infected machine, etc. The following is the set of gathered data.\n\n**Figure 15. The structure of the gathered data**\n\nNext, the gathered data is compressed with the Deflate algorithm.\n\n**Figure 16. The data compressed using the Deflate algorithm**\n\nNext, the malware encrypts the compressed data in Figure 16 with a session key, and packs the\nsession key (AES), that is encrypted using an RSA public key, along with a hash value and the\nencrypted data, into the following structure.\n\n**Figure 17. The packed data structure**\n\nThe size of the session key encrypted by RSA public key is 0x60 in bytes. The size of the hash\nvalue is 0x14.\n\nAfter packing these three data elements, the malware continues to encode the packed data with\nBase64, and then encodes it with a URL encoding algorithm. It finally forms the http body data that\nwill be sent to the C2 server.\n\n**Figure 18. The HTTP body data**\n\n\n-----\n\nWe have now finished the deep analysis of the data encryption algorithm of the Emotet malware in\ncommunication with C2 servers.\n\nFor the other half of this communication, where the program has to handle the response data from\nthe C2 server, it first decrypts the HTTP response data and the decodes the corresponding data\nwith Deflate algorithm.\n\nAdditionally, the RSA key is hard-coded at offset 0x0040FBF0 in the unpacked program as DER\nEncoding of ASN.1. Its size is 0x6A in bytes.\n\n**Figure 19. The hard-coded RSA key in DER format**\n\n## 0x06 Solution\n\nThis malicious Word document has been detected as “VBA/Agent.NRN!tr.dldr”, and the payload file\nhas been detected as “W32/Kryptik.GSJJ!tr” by the FortiGuard AntiVirus service.\n\nFortinet has also developed an IPS signature named “Emotet.Botnet” to detect the traffic between\nthe C2 server and the infected machine.\n\nThe URLs used to download Emotet have been rated as “Malicious Websites” by the FortiGuard\nWebFilter service.\n\n## 0x07 Conclusion\n\nEmotet is a sophisticated malware that uses an advanced custom packer and complicated\nencryption algorithm to communicate with its C2 server, as well as other advanced functionalities. It\ncould retrieve attack payload or other related malware payloads from C2 servers. Those attack\npayloads are designed to steal sensitive data from the victim.\n\nWe will continue to monitor the activities between Emotet and its C2 servers.\n\nIn the next blog, I will document some interesting research regarding how to programmatically\nunpack the Emotet executable and extract the hard-coded C2 server list and RSA key from the\nexecutable. My goal is to help researchers quickly identify traffic from Emotet, as well as save more\ntime on reverse engineering. You’re welcome to stay tuned!\n\n## Reference\n\n**SHA256 Hash:**\n\n45b3a138f08570ca324abd24b4cc18fc7671a6b064817670f4c85c12cfc1218f(Word document)\n30bb20ed402afe7585bae4689f75e0e90e6d6580a229042c3a51eecefc153db7(1n592ynn2ys9gg0.exe)\n2c9b8ed7cb7ce9b49579453283292ddf478c6ab2953b66c27aac8dfc84c6fb2b(s9cbyx.exe)\n\n21145645cac74e0b590813eafd257a2c4af6c6be0bc86d873ad0e6c005c0911d(p4xl0bbb85.exe)\n\n21145645cac74e0b590813eafd257a2c4af6c6be0bc86d873ad0e6c005c0911d(itsportal.exe)\n\n**URLs:**\n\n\n-----\n\nhxxp://webaphobia[.]com/images/72Ca/\nhxxps://montalegrense[.]graficosassociados.com/keywords/FOYo/\nhxxp://purimaro[.]com/1/ww/\nhxxp://jpmtech[.]com/css/GOOvqd/\nhxxp://118.89.215.166/wp-includes/l5/\n\n_[Learn more about FortiGuard Labs and the FortiGuard Security Services portfolio.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_ _[Sign up for our](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_\n_weekly FortiGuard Threat Brief._\n\n_[Read about the FortiGuard Security Rating Service, which provides security audits and best](https://www.fortinet.com/support-and-training/support-services/fortiguard-security-subscriptions/security-rating.html?utm_source=blog&utm_campaign=2018-blog-security-rating-service)_\n_practices._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-06-06 - A Deep Dive into the Emotet Malware.pdf"
    ],
    "report_names": [
        "2019-06-06 - A Deep Dive into the Emotet Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536231,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1653751259,
    "ts_modification_date": 1653751259,
    "files": {
        "pdf": "https://archive.orkl.eu/3a97b6d075c62b4081d1394aa7464f0fc1da965a.pdf",
        "text": "https://archive.orkl.eu/3a97b6d075c62b4081d1394aa7464f0fc1da965a.txt",
        "img": "https://archive.orkl.eu/3a97b6d075c62b4081d1394aa7464f0fc1da965a.jpg"
    }
}