{
    "id": "50e51f3b-88bd-4225-8a0e-ea07342b17e5",
    "created_at": "2023-01-12T15:00:58.289141Z",
    "updated_at": "2025-03-27T02:05:38.80565Z",
    "deleted_at": null,
    "sha1_hash": "16e77b18c7ee52d16e00205be1e39032f5411660",
    "title": "2017-11-28 - Newly Observed Ursnif Variant Employs Malicious TLS Callback Technique to Achieve Process Injection",
    "authors": "",
    "file_creation_date": "2022-05-28T16:54:00Z",
    "file_modification_date": "2022-05-28T16:54:00Z",
    "file_size": 808232,
    "plain_text": "# Newly Observed Ursnif Variant Employs Malicious TLS Callback Technique to Achieve Process Injection\n\n**[fireeye.com/blog/threat-research/2017/11/ursnif-variant-malicious-tls-callback-technique.html](https://www.fireeye.com/blog/threat-research/2017/11/ursnif-variant-malicious-tls-callback-technique.html)**\n\n## Threat Research Blog\n\nNovember 28, 2017 | by [Abhay Vaish,](https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/abhay-vaish) [Sandor Nemes](https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/sandor-nemes)\n[Malware](https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-tags/malware)\n\n[Malware Analysis](https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-tags/malware-analysis)\n\n**Introduction**\n\nTLS (Thread Local Storage) callbacks are provided by the Windows operating system to support\nadditional initialization and termination for per-thread data structures.\n\nAs [previously reported, malicious TLS callbacks, as an anti-analysis trick, have been observed for](https://www.fireeye.com/blog/threat-research/2013/02/the-number-of-the-beast.html)\nquite some time and can allow for PE files to include malicious TLS callback functions to be\nexecuted prior to the AddressOfEntryPoint field (the normal start of intended execution) in the PE\nheader. In essence, unsuspecting analysts and automated security tools can miss the actual entry\npoint to malcode if they do not account for it in the beginning of their analysis and insert a\nbreakpoint on the regular offset pointed to by AddressOfEntryPoint.\n\nWe recently came across a Ursnif/Gozi-ISFB sample that manipulated TLS callbacks while\ninjecting to child process. Though many of the malware binaries (or their packers) use some\nvariation of GetThreadContext/SetThreadContext or CreateRemoteThread Windows API functions\n\n\n-----\n\nto change the entry point of the remote process during injection, this sample (and the related\ncluster) is using a relatively lesser-known stealth technique. This little deviation from the standard\ntextbook approach may cause some generic unpackers or tools to break following the execution\nflow, if they do not account for the technique.\n\n**Distribution**\n\nSince early 2017, we have regularly observed the abuse of compromised Sharepoint accounts to\nhost malicious payloads, with distribution of URIs via spam emails. Some of the major campaigns\nwe’ve observed involve distributing Dridex within the UK and Ursnif/Gozi-ISFB in Australia. The\nrecently observed Ursnif variant discussed in this post was discovered via a spam email. A sample\nlure can been seen in Figure 1.\n\n\n-----\n\nFigure 1: Malicious email lure distributing Ursnif\n\nAfter clicking on the “REVIEW DOCUMENT” button, the malware downloads a ZIP file named\n_YourMYOBSupply_Order.zip from the following location:_\n\n\n-----\n\nhttps://eacg1my.sharepoint.com/personal/steve_robson_eaconsultinggroup_com/_layouts/15/download.aspx?\ndocid=<redacted>&amp;authkey=<redacted>\n\nThe ZIP file contains a malicious JavaScript file that, when executed, will download and execute\nthe Ursnif/Gozi-ISFB payload.\n\nThe activities of the distribution are difficult to identify within an organization’s normal network\nactivity because the command and control (C2) server of this payload communicates over HTTPS\nand the compromised Sharepoint accounts being used also communicate over HTTPS.\n\n**Variant Analysis**\n\nOn execution, the observed sample (MD5: 13794d1d8e87c69119237256ef068043) tries to create a\nchild process named svchost.exe (using the svchost.exe file from the System32 folder) using the\nCreateProcessW API function in suspended mode.\n\nNext, for process hollowing of svchost.exe, the malware creates a section object and maps the\nsection using ZwMapViewOfSection. It uses the memset function to fill the mapped section with\nzeroes, and then leverages memcpy to copy the unpacked DLL to that region. The malware then\nresolves three lower level API functions by walking the ntdll.dll module.\n\nThe malware then constructs its entry shellcode into a newly mapped region in memory.\n\nIn an effort to manipulate and identify the mapped sections of the child process, it reads out the\nPEB structure of the process using a call to ZwReadVirtualMemory.\n\nThe malware will then change protection permissions of the PE header of the child process to\nenable write access to that page. It then uses a call to ZwWriteVirtualMemory to write 18 bytes of\nbuffer at offset 0x40 from the start of svchost.exe process executable in the target child process.\nThe malware then cleverly changes the region protection back to “read only” to avoid suspicion.\n\nAgain, it repeats the procedure of changing protections for the PE image of svchost.exe to write 8\nbytes at an offset of 0x198 bytes from the start of the process executable.\n\n**The Stealthy Tweak**\n\nThis buffer, when correctly placed at the offset, will represent the TLS directory offset for the\nprocess because offset 0x198 is the location of the TLS directory in PE executable, and the next\nDWORD represents the size of the directory (seen in Figure 2). Notice how the malware writes the\noffset 0x40 for directory and the size 0x18 bytes in an effort to point to the buffer it had already\ncrafted at offset 0x40 with size 0x18 bytes.\n\nFigure 2: TLS directory location and size\n\n\n-----\n\nThe TLS directory structure, when used to parse out that buffer of 0x18 bytes, points to an offset\ncontaining a list of pointers representing AddressOfCallBacks (see Figure 3).\n\nFigure 3: TLS directory structure with pointers\n\nIf we take a look at offset 0xe058, it points to the list of AddressOfCallBacks (Figure 4), and if we\ngo to the offset 0xe058 in memory we are pointed to the only callback address at offset 0xe068 which is in fact the actual entry point code (Figure 5).\n\nFigure 4: Offset 0xe058\n\n\n-----\n\nFigure 5: Offset 0xe068 in memory\n\nFinally, the malware unmaps the view using ZwUnmapViewOfSection and calls ResumeThread to\nbegin malicious execution of its injected process (from the injected TLS callback address instead of\nthe regular AddressOfEntryPoint listed in the PE header). Hence, the execution will first land at the\ninjected TLS callback (see Figure 6).\n\nFigure 6: Actual entry point\n\n**Impact**\n\nThe [leaked source code of Ursnif/Gozi-ISFB used the standard DllMain call entry point to initialize](https://github.com/gbrindisi/malware/blob/master/windows/gozi-isfb/AcDll/stubs.c)\nthe injected DLL image and execute its entry (see Figure 7).\n\nFigure 7: DllMain call used in leaked Ursnif source code\n\n\n-----\n\nThis newer variant shows that actors are not only modifying the malware to evade signatures, they\nare also equipping them with stealthier techniques. Unaware debugging environments or detection\nframeworks can potentially miss the actual hidden TLS callback entry point, allowing the malware\nto perform its malicious activities under the hood.\n\n**Indicators of Compromise**\n\nFilename :YourMYOBSupply_Order.zip\n\nMD5 : f6ee68d03f3958785fce45a1b4f590b4\n\nSHA256 : 772bc1ae314dcea525789bc7dc5b41f2d4358b755ec221d783ca79b5555f22ce\n\nFilename : YourMYOBSupply_Order.js\n\nMD5 : c9f18579a269b8c28684b827079be52b\n\nSHA256 : 9f7413a57595ffe33ca320df26231d30a521596ef47fb3e3ed54af1a95609132\n\nFilename : download[1].aspx\n\nMD5 : 13794d1d8e87c69119237256ef068043\n\nSHA256 : e498b56833da8c0170ffba4b8bcd04f85b99f9c892e20712d6c8e3ff711fa66c\n\nPrevious Post\nNext Post\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-11-28 - Newly Observed Ursnif Variant Employs Malicious TLS Callback Technique to Achieve Process Injection.pdf"
    ],
    "report_names": [
        "2017-11-28 - Newly Observed Ursnif Variant Employs Malicious TLS Callback Technique to Achieve Process Injection.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535658,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1653756840,
    "ts_modification_date": 1653756840,
    "files": {
        "pdf": "https://archive.orkl.eu/16e77b18c7ee52d16e00205be1e39032f5411660.pdf",
        "text": "https://archive.orkl.eu/16e77b18c7ee52d16e00205be1e39032f5411660.txt",
        "img": "https://archive.orkl.eu/16e77b18c7ee52d16e00205be1e39032f5411660.jpg"
    }
}