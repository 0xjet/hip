{
    "id": "86d043ac-0337-4aaf-b31d-95c3eb5bd6eb",
    "created_at": "2024-01-04T02:07:15.851503Z",
    "updated_at": "2025-03-27T02:08:40.608754Z",
    "deleted_at": null,
    "sha1_hash": "592fcf14459be0097fb64c1b854a2af05b632ced",
    "title": "",
    "authors": "",
    "file_creation_date": "2017-01-20T21:03:42Z",
    "file_modification_date": "2017-01-20T20:07:16Z",
    "file_size": 911197,
    "plain_text": "[See discussions, stats, and author profiles for this publication at: https://www.researchgate.net/publication/320250366](https://www.researchgate.net/publication/320250366_Botnet_protocol_inference_in_the_presence_of_encrypted_traffic?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_2&_esc=publicationCoverPdf)\n\n### Botnet protocol inference in the presence of encrypted traffic\n\n**Conference Paper · May 2017**\n\nDOI: 10.1109/INFOCOM.2017.8057064\n\n\nCITATIONS\n17\n\n**5 authors, including:**\n\n[Lorenzo De Carli](https://www.researchgate.net/profile/Lorenzo-De-Carli?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[The University of Calgary](https://www.researchgate.net/institution/The_University_of_Calgary?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**46** PUBLICATIONS **440** CITATIONS\n\n\nREADS\n558\n\n\n[Alok Tongaonkar](https://www.researchgate.net/profile/Alok-Tongaonkar?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n**21** PUBLICATIONS **539** CITATIONS\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Alok-Tongaonkar?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Lorenzo-De-Carli?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n[Somesh Jha](https://www.researchgate.net/profile/Somesh-Jha-3?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[University of Wisconsin–Madison](https://www.researchgate.net/institution/University_of_Wisconsin-Madison?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**298** PUBLICATIONS **32,738** CITATIONS\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Somesh-Jha-3?enrichId=rgreq-2041a270478a3e077c78db92bc7d8875-XXX&enrichSource=Y292ZXJQYWdlOzMyMDI1MDM2NjtBUzo5NTU5ODQyNTE5OTgyMDlAMTYwNDkzNTgxNTU0NA%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n-----\n\n# Botnet Protocol Inference in the Presence of Encrypted Traffic[∗]\n\n#### Lorenzo De Carli[1] Ruben Torres[2] Gaspar Modelo-Howard[2] Alok Tongaonkar[3] Somesh Jha[4]\n\n1Colorado State University 2Symantec 3RedLock Inc. 4University of Wisconsin, Madison\n\n\n**_Abstract—Network protocol reverse engineering of botnet_**\n**command and control (C&C) is a challenging task, which**\n**requires various manual steps and a significant amount of domain**\n**knowledge. Furthermore, most of today’s C&C protocols are**\n**encrypted, which prevents any analysis on the traffic without first**\n**discovering the encryption algorithm and key. To address these**\n**challenges, we present an end-to-end system for automatically**\n**discovering the encryption algorithm and keys, generating a**\n**protocol specification for the C&C traffic, and crafting effective**\n**network signatures. In order to infer the encryption algorithm**\n**and key, we enhance state-of-the-art techniques to extract this in-**\n**formation using lightweight binary analysis. In order to generate**\n**protocol specifications we infer field types purely by analyzing**\n**network traffic. We evaluate our approach on three prominent**\n**malware families: Sality, ZeroAccess and Ramnit. Our results**\n**are encouraging: the approach decrypts all three protocols,**\n**detects 97% of fields whose semantics are supported, and infers**\n**specifications that correctly align with real protocol specifications.**\n\nI. INTRODUCTION\n\nModern malware increasingly instantiates botnets: network\nof compromised computers that perform a diverse set of malicious activities. Usually motivated by financial gain, botnets\nincorporate a wide range of functionalities, such as launching\nDDoS and spam campaigns, stealing personal information,\nand committing e-commerce fraud. The large size of many\nbotnets [1], [2] make them an extremely effective attack tool.\nA crucial aspect of botnets, given their distributed nature, is\nnetwork communication. Bots on infected machines routinely\n“phone home” to botnet servers, receive instructions, and perform data exfiltration. Understanding the semantics of botnet\ncommunications allows the analyst to quickly gain insight to\nthe malware’s mechanisms, and to generate network signatures\nto detect malicious traffic. Understanding malware communications can also enable remediation actions and forensics.\nIn order to understand bot network behavior, analysts\nuse a variety of techniques such as manual traffic collection/inspection and sandboxed execution of malware. Increasing use of encrypted communication also imposes manual debugging of malware binaries to analyze and reverse encryption.\nThese procedures are time-consuming, error-prone and unable\nto cope with the rates at which new malware appears. Limited,\nmanually-inferred protocol understanding may also result in\nineffective signatures, which are excessively specific to the\navailable traffic samples, and can be easily circumvented.\nIn this paper, we propose a novel technique for automatic\ninference of malware network protocol specifications, given\n\n_∗_ Supported in part by NSF grant CNS-1228782. Emails: ldecarli@colostate.edu, {ruben torresguerra, gaspar modelohoward}@symantec.com, alok@redlock.io, jha@cs.wisc.edu.\n\n\nsamples of a malware’s communications and the malware\nbinary. We focus on malware Command & Control (C&C)\nprotocols, used by botmasters to control malware-infected\nhosts and to execute various malicious activities. Such communications tend to be based on custom binary formats [3],\nmaking it possible to specialize the analysis to this domain.\nAlso, each C&C protocol is specific to its malware family—\nproviding the advantages of constituting a reliable fingerprint,\nand giving insight into the malware structure and intent.\nReverse-engineering a malware protocol is extremely difficult: messages are oftentimes ambiguous, and may contain\nerrors or purposely-injected noise. Our approach casts it as a\n_type inferencing problem [4]: we assume that each message_\nconsists of a sequence of binary fields, and we define a type\n_system describing all possible field types. We then run a novel_\ntype inferencing algorithm to infer message structure.\nAnother significant issue is that—given the wide adoption of\nencryption in C&C network traffic [3]—decryption is required\nbefore inference can be accomplished. We therefore also\npropose a system to extract C&C encryption keys by applying\ndynamic analysis on the malware binary. Our approach extends\nexisting techniques (such as [5]), focusing their application on\nuses of encryption involving network data.\nOur approach can significantly alleviate the analysis burden\non human analysts, facilitating timely deployment of countermeasures against new malware. Also, a signature generation\nstep based on our specifications can leverage rich semantic\nunderstanding, leading to signatures that are resilient to incremental changes in the C&C protocol. Finally, differently from\nprevious works we strive to provide a practical workflow for\nthe analyst, by: (i) allowing to leverage both traffic generated\nin a controlled environment and samples captured in the wild,\nand (ii) discovering rich field types that provide actionable\nmaterial (e.g. downloaded executables).\nWe evaluated our approach on three different malware\nprotocols. Results demonstrate that our prototype correctly\ninfers details of the encryption used in each protocol, enabling\ndecryption. Furthermore, it detects 97% of fields whose type\nis supported by our approach, with negligible false positives.\nFinally, an evaluation of signatures based on the generated\nspecification shows 98% sample coverage/no false positives.\n**In summary, this paper contributes: (i) a technique**\n_for rich malware protocol inference requiring only decrypted_\n_network traffic, and (ii) a practical, scalable solution to infer_\n_details of encryption used by malware in network protocols,_\n_leveraging state-of-the art encryption analysis techniques._\n\n\n-----\n\n|Col1|Col2|\n|---|---|\n||B.3|\n\n|B.1-B.3|Algo: RC4 Key: 0769F9C5...|\n|---|---|\n\n|B.4|Col2|\n|---|---|\n|||\n\n|C.1|Col2|\n|---|---|\n|||\n\n|C.2|Col2|\n|---|---|\n|||\n\n\n**Malware**\n\n\n**(a) System architecture**\n\n\n**Sandboxed Execution: Traffic generation**\n\n**A** E5AAC031EA6423733B5B741C499F39C1A627...\n\n**Trace analysis (Encryption Profile)**\n\n**B.1-B.3** **Algo: RC4 Key: 0769F9C5...**\n\n**Encryption inference/Message decryption**\n\n**B.4** FE3467CDF24535AC46746573000400004D5A...\n\n**Message clustering by type (using detected type field)**\n\n**C.1** FE3467CDF24535AC| Type |000400004D5A...\n\n**Content field inference**\n**C.2** **|Magic |F24535AC| Type |00040000| Exe...**\n\n**Dependent field inference**\n\n**C.3** |Magic | CRC  | Type |Exe len | Exe...\n\n#### ...\n\n**Specification abstraction**\n\nField 1: 4-byte Magic, Field 2: 4-byte CRC, Field 3: 4\n**C.5**\n\nbyte Msg Type, Field 4: 4-byte Field 5 len, Field 5: EXE\n\n**(b) Protocol decryption and inference example**\n\n\nFig. 1: Outline of the proposed system and example of operation\n\n\nII. OVERVIEW\n\n\nWe decompose the problem of reverse-engineering C&C\nprotocols into: (1) C&C traffic decryption, using dynamic\nanalysis to extract encryption keys from malware executions,\nand (2) automatic derivation of protocol specification via type\ninference over decrypted C&C traffic. This section outlines\nboth steps, using as an example a message format from the\nC&C protocol of the ZeroAccess malware [6] (details of each\nstep are then given in § III). Such message format is used by\nZeroAccess to download executable payloads to an infected\nmachine. It consists of a sequence of binary fields: (i) 4-byte\nmagic value that identifies the protocol, (ii) 4-byte message\nCRC, (iii) 4-byte message type, (iv) 4-byte payload length, and\n(v) payload (executable file). Each message is fully encrypted\nusing the RC4 cipher and a static key. The overall system\narchitecture is depicted in Fig. 1(a). Fig. 1(b) highlights the\noutput of each step using an example message.\n_a) Encryption analysis: In step A, the malware of in-_\nterest is executed in a sandbox which traces machine instructions, network system calls, and generated/received network\npackets. The instruction trace is then processed by a sequence\nof analysis steps. Step B.1 pre-selects candidate instruction\nsequences that behave like encryption functions. Step B.2\nperforms a more detailed analysis of each candidate, either\nmapping it to a specific known encryption cipher, or discarding\nit. Each surviving candidate represents the dynamic execution\nof an encryption function. Step B.3 matches the output of\neach candidate to the input of network system calls, retaining\nonly candidates whose output is sent on the network (the\nother candidates likely represent non-C&C related events—\ne.g. encryption of local files). Step B.4 maps the retained\nuses of encryption to the payload of C&C packets emitted\nduring sandbox execution. It then heuristically infers if the\nencryption key is either static or derived from the payload: if\neither condition is true, decryption of any malware messages\n(not just sandbox-generated ones) becomes possible. At the\n\n\nend of this step, all messages in the dataset get decrypted.\n**Integrating additional samples: Once our approach has**\nlearned decryption information, it can decrypt any protocol\nmessage. This enables the analyst to feed additional C&C messages from external sources (honeypots, etc.) into the protocol\nanalysis stage, potentially inferring a richer specification.\n_b) Protocol analysis: Most C&C protocols define mul-_\ntiple message types for different purposes. As each type has\na distinct structure, it is crucial that messages are clustered\nby type, so each type can be analyzed separately. Step C.1\ndetects fields specifying the message type, and clusters messages based on the values of those fields. Step C.2 identifies\n_content fields, i.e. fields whose structure is self-evident and_\n_independent from the context (the rest of the message). The_\nfirst and last field of the example message in Fig. 1(b) fall\nin this category: the Magic field can be determined as it\nholds a constant value across messages. The EXE file field is\nalso easily identifiable as PE executables have a recognizable\nstructure. We instantiated an initial set of type definitions based\non our experience with C&C protocols; this set can be easily\nextended/customized for specific analysis tasks. Step C.3 determines dependent field types. These fields express properties\nof other fields or of the message. Our example message\ncontains two: Message CRC and Payload Length (which in this\ncase expresses the length of the EXE file). Step C.4 detects\n_composite field types, such as lists of content or dependent_\nfields (not present in Fig. 1(b)). Finally, Step C.5 reconciles the\nsequence of fields extracted from each individual message into\na single protocol specification using sequence alignment [7].\n\nIII. PROTOCOL INFERENCE\n_A. Sandboxed execution_\n\nThe first component of our system investigates whether the\nmalware uses encryption algorithms. It begins by running the\nmalware in a controlled environment consisting of a virtual\nmachine augmented with program tracing (sandbox in the\nfollowing). This stage collects three different program traces:\n\n\n-----\n\n_• A system call trace S, capturing malware-triggered system_\ncalls used to send network data (e.g. send()). Each call is\nrepresented as a set R[S] of memory locations and registers\nused to pass network-bound data to the OS. S therefore\nconsists of a sequence of n such sets R1[S][...R]n[S][.]\n\n_• An instruction trace T_, representing an ordered sequence\nof m processor instructions executed by the malware.\nFormally, T = t1...tm, where each instruction ti is a\ntuple (i, a, R[T] _, W_ _[T]_ ). i is the instruction opcode, a the\ninstruction address in memory, R[T] the set of memory\nlocations/registers read by the instruction, and W _[T]_ the set\nof memory locations/registers written by the instruction.\n\n_• A network trace N of all packets generated by the sandbox._\n\n_B. Encryption Analysis_\n\nOnce traces of the malware execution are available, we\nanalyze them to locate instances of encryption use.\n_1) Candidate Detection:_ This step executes a candi_date detection procedure, which takes as input the instruction_\ntrace T and locates a set C of candidate encryption instances.\nEach candidate in C is a sequence D ⊆ _T_, representing the\npossible execution of an encryption primitive.\nIn order to detect encryption in instruction traces several\napproaches could be used, such as [5], [8], [9]. In our\nevaluation we use ALIGOT [5] as it is a recent approach with\npublicly available and well-documented source code. ALIGOT\nis based on the insight that loops are recurring structures in\ncipher implementations, therefore searching execution traces\nfor chains of dynamic loops. We observed however that the\nbase ALIGOT algorithm does not scale to traces larger than a\nfew tens of thousands of instructions, which prevents a direct\napplication to our case. We concluded that the issue lies in\nALIGOT’s loop detection, which treats each new instruction as\nthe potential beginning of a new loop, reaching an impractical\nmemory footprint in long sections of straight-line code. After\ndetermining that dynamic loops can be seen as maximal\n_repetitions [10], we replace ALIGOT loop detection with_\nour implementation of the Kolpakov/Kucherov algorithm [11],\nwhich finds all maximal repetitions in a string in linear time.\nOur optimization lifts the maximum practical trace size from\ntens of thousands of instructions to a few millions.\n_2) Candidate Matching:_ This step executes a candi_date matching procedure which receives as input the set of_\ncandidate encryption instances C from the previous step,\nand determines whether each candidate corresponds to the\nexecution of an actual cipher. Formally, candidate matching\ncomputes a mapping C → _K∪{⊥}, where K is a set of known_\nciphers, while ⊥ represents a failed match. Furthermore, the\nprocedure determines the set of inputs (keys, plaintexts) and\noutputs (ciphertexts) for each instance. The output of the\nprocedure is a set of matched candidates M, where each\nelement in M is a tuple (D, k, R[M] _, W_ _[M]_ ). D ⊆ _T is the_\nsequence of instructions in the candidate encryption instance;\n_k ∈_ _K is the encryption cipher being used, R[M]_ is the set of\ninputs passed to the cipher, and W _[M]_ its set of outputs.\nIt may be possible to implement candidate matching using\n\n\nseveral possible approaches, such as [5], [12]. We again use the\napproach proposed by ALIGOT for the same reasons discussed\npreviously. It works by determining all possible input and\noutput parameters to/from the candidate encryption instance,\nand verifying if any input/output combination matches that of\na known cipher. In our implementation we deploy an optimization, by filtering parameters (such as pointers) unlikely\nto constitute either key material, ciphertext or plaintext.\n_3) Candidate Filtering: This step consists of a candi-_\n_date filtering procedure which receives as input the set of_\nmatched candidates M emitted by the previous step, and the\nsystem call trace S. candidate filtering eliminates elements in\n_M whose output is not used to generate network messages._\nRecall that each system call in S is described by a set R[S]\n\nof memory locations and registers used to specify the data to\nsend on the network. A candidate m = (D, k, R[M] _, W_ _[M]_ ) is\nretained only if ∃R[S] _∈_ _S, s.t. O = (W_ _[M]_ _∩_ _R[S]) ̸= ∅_ and\nno other instruction writes the location(s) in O between the\nexecution of m and the execution of the system call R[S]. The\noutput is a filtered set of encrypted instances F, with F ⊆ _M_ .\nWe note that there is still potential for false positives\nfrom network-bound encrypted data generated by the malware\nprocess for non-C&C related purposes. These could be avoided\nby discarding flows which match known protocols. We leave\nthis additional filtering to future work.\n_4) Key Type Inference/Decryption: The next goal is to_\ninfer general information about how the malware performs\nencryption. Malware use of ciphers is oftentimes closer to\nobfuscation than proper encryption [3], employing symmetric\nciphers and keys that are either static or provided in the\nmessages. This implies that —once the encryption details have\nbeen learned—it is possible to decrypt any C&C message\nwithin the protocol, not only the ones observed in the sandbox.\nWe first determine where the outputs of encryption instances\nin the set F appear in the sandbox-generated network packets\nfrom the trace N, by matching the output of encryption instances to packets. We then apply the following two heuristics:\n**_Key type inference: If the key is constant across all observed_**\n_message samples, then the C&C protocol is assumed to use_\n_the very same key for all possible messages. If the key appears_\n_at a constant offset within observed message samples, then the_\n_key is assumed to be located at that offset in every message._\n**_Decryption: If the observed encryption instances cover full_**\n_message payloads, the C&C protocol is assumed to fully_\n_encrypt each message. If the observed encryption instances_\n_only partially overlap with message payloads, it is assumed_\n_that the malware encrypts only certain message fields._\nAfter executing this step, the analyst can provide additional\nmessage samples, in order to augment the dataset for protocol\nanalysis. If encryption was detected, all available messages get\ndecrypted. The only exception to this is when the malware\nonly encrypts certain fields. If so, the algorithm has not yet\naccrued enough information to determine which parts of each\nmessage may be encrypted (beyond the ones discovered during\ntrace analysis). In this case, decryption is performed later on\na per-field basis, as part of field inference (§ III-C2).\n\n\n-----\n\n|Rule target|Details|\n|---|---|\n|String|Detect sequences of printable characters.|\n|IPv4|Match message payload to an IP blacklist.|\n|Timestamp|Detect 4-byte POSIX timestamps (must describe a date within a week of when the message was sent).|\n|PE|Locate Windows binaries with a PE parser.|\n|ZIP|Locate ZIP files. Identify ZIP sections by magic number and merge contiguous sections.|\n|Magic|Detect magic numbers. Looks for a constant prefix appearing in every message.|\n|Padding|Detect message padding (an iterated constant se- quence trailing every message).|\n\n\nTABLE I: Content-field detection rules\n\nFormally, the output of this step is a set of decrypted message samples S = s1, ..., sn. (see Fig. 2(a) for an example).\n\n_C. Protocol Analysis_\n\nThe goal of the next part is to analyze decrypted message\nsamples to infer a protocol specification P . For the purpose of\nour work we define P as a set of n message types T1, ..., Tn.\nEach Ti is in turn is a sequence of m field types t1, ..., tm.\n_1) Message Clustering: This step determines a partition of_\nthe sample set S, associating each sample with exactly one\nmessage type. We use the insight that most protocols include\none or more fields that explicitly specify the message type. We\ntherefore detect likely candidates for message type fields, and\ncluster messages based on the value of those fields. In order to\ndetect type fields without any prior information about message\nstructure, we use a heuristics due to Bermudez et al. [13],\nwhich works by measuring causality between candidate fields\nin pairs of client request/server response messages (the values\nof such fields are highly likely to be related). We then assign\neach message to a type based on the value of its type fields.\n_2) Field inference: After messages have been clustered by_\ntype, we proceed to perform field inference. The overall goal\nis to determine a partition of each message sample s ∈ _S in_\na sequence of fields f1, ..., fn. Of course, for each field fi we\nalso want to obtain the corresponding field type ti.\nOur approach is based on a taxonomy of binary protocol\nfields in four broad categories. The first includes content\n_fields, i.e. fields that carry various type of information (IP_\naddresses, executables, etc.) between client and server. The\nsecond category includes dependent fields, i.e. fields that describe properties of other fields, such as their offset or length.\nThe third category consists of encrypted fields, i.e. content and\ndependent fields that are encrypted. The third category occurs\nin C&C protocols that perform partial message encryption. We\nalso define composite fields, consisting of repeated sequences\nof basic fields types (e.g. a list of IP addresses).\nThe core idea of our field inference approach is to detect\ncontent fields using a rule-based technique. Once content\nfields have been located, the algorithm searches for dependent\nfields. Furthermore, if the protocol performs partial message\nencryption, the algorithm analyzes the message looking for\nsigns of encrypted content, which is then decrypted to extract\nadditional fields. Finally, the algorithm analyzes the sequence\nof all discovered fields to identify composite fields.\n\n\n**Content-field inference. The assumption behind this pass is**\nthat the structure of many types of content fields is selfevident, i.e. it can be detected by a rule-based approach. For\nexample, consider the example message in Fig. 1(b) after\nStep C.1. The EXE file field detected in Step C.2 has a selfevident structure: a well-defined format recognizable by a PE\nfile parser. We implemented a library of detection rules—\ndetailed in Table I—for various content types, based on our\nexperience with C&C protocols. In order to identify content\nfields, the detector runs all available rules on message samples.\nRules receive a set of samples and output the detected fields,\nwith no constraints on how they are implemented. We found\nadding rules to be straightforward: developing the ZIP detector\ntook us two hours with no previous familiarity with the format.\n**Dependent-field inference. This step breaks each message**\nsegment not already covered by a content field in 1-, 2and 4-byte N -grams. It then checks if the value of each\n_N_ -gram matches a property of an existing content field or\nof the message. In the example of Fig. 1(b), Step C.3, two\ndependent fields are detected: CRC and LENGTH. Table II\nlists the properties each N -gram is checked against.\n**Encrypted-field inference. A special case of fields are en-**\ncrypted fields in partially encrypted protocols. In order to\nidentify such fields within the rest of a message, we devise\na technique based on the observation that the ciphertext of\nan encrypted field appears as a random bitstring, while the\ncorresponding plaintext exhibits some type of structure.\nWe use a randomness test by Goubault-Larreq and Olivain [14]. Briefly, the test works by estimating the Shannon entropy HN[MLE] of a sequence of N bytes using the\nmaximum-likelihood estimator, and comparing it with the\nexpected value HN of the N -truncated entropy of a uniformly random sequence of the same length. If the distance\nis less than a predefined threshold, the sequence of bytes\nunder examination is judged random (see [14] for details).\nConsider a procedure randomness test that performs such\na test, and a message M . For each possible byte offset\n_o = 1...n in the message and for each possible field length_\n_l, our detector computes randomness test(M_ [o : o + l])\nand randomness test(D(M [o : o + l])) (where D is the\ndecryption function). Whenever the original byte sequence is\nrandom—according to the test—but the decrypted one is not,\nthe decrypted value is passed to the content- and dependentfield detectors.\n**Composite-field inference. Protocol specifications may in-**\nclude set semantics [15], i.e. repeated sequences of one or\nmore field types; different messages of the same type may\ncarry sequences of different length. Our approach therefore\nincorporates a detector—based on the Kolpakov/Kucherov\nalgorithm (§ III-B1)—to find repetitions in the sequence of\ndiscovered fields. Sequences of different lengths but carrying\nthe same type(s) are mapped to the same composite field type.\nOverall, the field inference steps output a set of messages,\neach labeled with a set of discovered fields (e.g. see Fig. 2(b)).\n_5) Specification Abstraction: The final step processes all_\nmessages in each type cluster, isolating the commonalities\n\n\n-----\n\n|Rule target|Details|\n|---|---|\n|Length|Detect fields whose value F satisfies F = aL −b for some a, b (L is a field or message length).|\n|Offset|Detect fields whose value F satisfies F = aO for some a (O is the offset of a known content field).|\n|CRC|Detect fields whose value matches H(M) (M is the message content and H a known hash function).|\n\n\nTABLE II: Dependent-field detection rules\n\nbetween sequences of fields in different messages, and abstracting a message-type specification T (recall that such\nspecification consists of a sequence of field types t1, ..., tm).\nThis step is necessary to reconcile inconsistencies in the fields\ndetected in different messages of the same type, which arise\nfor two reasons. First, message clusters determined in Step C.1\nmay be imprecise, or a protocol may use different message\nformats within the same declared message type. Second, rulebased heuristics may not detect all occurrences of a field.\nIn order to merge multiple field sequences in a single\nspecification, we use the Needleman-Wunsch algorithm [7]—a\ndynamic programming technique to find the optimal alignment\nof similar sequences, often used for message comparison and\nclustering (e.g. [15], [16]). A significant issue is that the\ncoverage of message samples may not be complete, as each\nmessage may include one or more sections in which the\nfield inference step was not able to detect any field. When\nperforming alignment, we allow sequences to include blanks\nrepresenting one or more unknown field. We treat blanks as\nwildcards, allowing them to align with any concrete field type.\nFor each message type, we choose the message sample\nfor which the richest set of fields has been inferred, and we\ngenerate a specification based on that. Then, we iteratively\nalign the field sequence in the specification with the field\nsequences in all other messages of the same type. Every time\nthe two sequences align, we “fuse” them in a single sequence\nspecification (if a blank aligns with a concrete field type, the\nmerged specifications only includes the latter). If a cluster\ncontains messages that do not align with the specification, we\nsplit it and repeat specification abstraction on both the newly\ncreated clusters, recursively splitting them again if necessary.\nThe final output is the protocol specification (e.g. Fig. 2(c)).\n\n_D. Signature Generation_\n\nOne relevant use for malware protocol specifications is the\ngeneration of network signatures. We therefore also propose a\nmethodology to generate deterministic signatures, which verify\nan ordered set of tests, each of which checks the presence\nof an expected field. We declare a match if all the (ordered)\ntests in a signature are satisfied. The tests are rules that check\nparticular field characteristics in a given group of contiguous\nbytes, defined by an offset and length. We develop tests for\nall the content-field detectors in Table I. For example, the\n_MATCH STRING test will check for the existence of only_\nprintable characters in the group. In addition, we developed\ntests to check for the dependent fields in Table II. For instance,\n_MATCH MSG LENGTH will check that the message length_\nis equal to the value of the input byte group.\n\n\nIV. EVALUATION\n\nWe evaluate our approach in depth showing that it can:\n(i) correctly identify encryption uses, (ii) effectively infer the\nstructure of C&C messages, (iii) generate correct protocol\nspecifications, and (iv) lead to effective network signatures.\n\n_A. Malware Families under Examination_\n\nFor our evaluation, we selected three malware families\nbased on: (i) the level of understanding of the C&C protocol\nby the research community, so to have a well-defined ground\ntruth; and (ii) the popularity of the malware in recent times.\nFor each family we collected and run one binary sample. The\nfamilies are: Sality [17], a polymorphic file infector and downloader with complex features, such as P2P support (we focus\non the Sality.AE variant). Ramnit [18], a malware platform\nwith various capabilities, provided through a flexible plugin\narchitecture. Ramnit’s botnet is estimated to have included\n3M+ infected machines at his peak [19]. ZeroAccess [6], a\ntrojan that can act as a backdoor and download additional\nmalware. It uses P2P to participate in botnets extending to\ntens of thousands of infected machines [20].\n\n_B. Infrastructure_\n\nOur sandbox implementation (Step A in Fig 1(a)) is based\non the Cuckoo sandbox [21], extended with a custom analysis\npackage based on PIN [22] to generate instruction traces[1].\nThe sandbox output (instruction trace, syscall trace and\nnetwork trace) is passed to our encryption analysis tool\n(Steps B.1-B.4). The candidate detection and candidate matching steps in our algorithm are based on the publicly available\nALIGOT Python implementation [23], modified to introduce\nour optimizations. Separately, the tool analyzes the sandboxgenerated network trace to extract malware messages, and\nmatches extracted messages with detected encryption uses; if\npossible each message is then decrypted (Step B.4). This step\nreturns a list of message samples annotated with encryption\ninformation (Fig. 2(a)).\nA second application implements message clustering, field\ninference, and abstraction (Steps C.1-C.5). The output consists\nof (i) a list of messages, each augmented with a list of detected\nfields (Fig. 2(b)), and (ii) specifications for each detected\nmessage type (Fig. 2(c)). Overall, our toolchain consists of\n17500 lines of Python code and 1900 lines of C++.\n\n_C. Additional Datasets_\n\nIn order to augment the diversity of our C&C dataset beyond\nthe messages obtained from the sandbox, we integrated additional message datasets, detailed in Table III (user-generated\ntraces were anonymized). To extract C&C messages from the\nnetwork traces, we used a combination of Snort [24], custom\nscripts and manual inspection. We emphasize that message\nextraction was a non-trivial effort, spawning several weeks of\nanalyst’s time. Benign traffic samples used for our signature\nmatching evaluation (§ IV-H) are also detailed in Table III.\n\n1We used industry-standard tools for VM tuning and hardening (e.g. pafish)\nto circumvent malware anti-VM techniques.\n\n\n-----\n\n**ORIGIN: Ramnit** **ORIGIN: Ramnit** **MESSAGE_TYPE: \"E2-CS-0\"**\n**L4 PROTOCOL: TCP** **PAYLOAD: 00FF4B000000E20020000(...)** **FIELD #1:** _type=\"MAGIC\" length=\"2\" content=\"00FF\"_\n**SOURCE IP: 192.168.1.1** **FIELDS INFORMATION:** **FIELD #2:** _type=\"MSG_LENGTH\" length=\"4\"\\_\n**SOURCE PORT: 49197** **FIELD #1:** _type=\"MAGIC\" position=\"0-1\"_ _content=\"4B000000\"_\n**DESTINATION IP: 192.168.1.2** **FIELD #2:** _type=\"MSG_LENGTH\" position=\"2-5\"_ **FIELD #3:** _type=\"MSG_TYPE\" length=\"1\" content=\"E2\"_\n**DESTINATION PORT: 443** **FIELD #3:** _type=\"MSG_TYPE\" position=\"6\"_ **FIELD #4:** _type=\"BLANK\" length=\"1\" content=\"00\"_\n**DIRECTION: Client → Server** **FIELD** **#4: type=\"FIELD_LENGTH\"\\** **FIELD #5:** _type=\"FIELD_LENGTH\" refers-to=\"6\"\\_\n**TIMESTAMP: 1435260024.859** _position=\"8-11\" refers-to=\"5\"_ _length=\"4\" content=\"20000000\"_\n**PAYLOAD: 00FF4B000000E20020000(...)** **FIELD** **#5:** _type=\"ENCRYPTED_RANGE\"\\_ **FIELD #6:** _type=\"ENCRYPTED_RANGE\"length=\"32\"\\_\n**ENCRYPTION INFORMATION:** _position=\"12-43\"_ _content_type=\"variable\"_\n**USE #1:** _cipher=\"RC4\" key=\"626C61636B\"\\_ **FIELD #5.1:** _type=\"STRING\"\\_ **FIELD #6.1:** _type=\"STRING\" length=\"32\"\\_\n_length=\"32\" offset=\"49\"\\_ _position=\"12-43\"_ _content_type=\"variable\"_\n_plaintext=\"353437353563(...)\"_ **FIELD #6: type=\"FIELD_LENGTH\"\\** **FIELD #7:** _type=\"BLANK\" length=\"1\" content=\"00\"_\n**USE #2:** _cipher=\"RC4\" key=\"626C61636B\"\\_ _Position =\"45-48\" refers-to=\"7\"_ **FIELD #8:** _type=\"FIELD_LENGTH\" refers-to=\"9\"\\_\n_length=\"32\" offset=\"12\"\\_ **FIELD #7:** _type=\"ENCRYPTED_RANGE\"\\_ _length=\"4\" content=\"20000000”_\n_plaintext=\"306263356665(...)\"_ _position=\"49-80\"_ **FIELD #9:** _type=\"ENCRYPTED_RANGE\" length=\"32\"\\_\n\n**FIELD #7.1: type=\"STRING\"\\** _content_type=\"variable\"_\n_position=\"49-80\"_ **FIELD #9.1:** _type=\"STRING\" length=\"32\"\\_\n**MESSAGE TYPE: E2** _content_type=\"variable\"_\n\n**(a) Output of decryption (step B.4)** **(b) Output of field inference (C.1-C.4)** **(c) Output of specification abstraction (C.5)**\n\nFig. 2: Examples of output of various algorithmic steps for the Ramnit C&C protocol\n\n|Traces used to extract C&C samples|Col2|Col3|\n|---|---|---|\n|Trace|Size|Type|\n|ISP|635GB (330M flows)|User-generated traffic from large European ISP|\n|MTA|386MB (17K flows)|Malware-generated traffic from controlled environment [25]|\n|Traces containing benign traffic|||\n|DARPA|3.4GB (858K flows)|DARPA corpus [26] (week #2)|\n|M57|4.6GB (93K flows)|Corpus for forensics training [27]|\n\n\nTABLE III: External traces used in the evaluation\n\n_D. Encryption Analysis_\n\n\nIn this section, we evaluate how effective is our encryption\nanalysis algorithm in: (i) detecting the use of encryption, and\n(ii) inferring details of the encryption used in C&C protocols.\nIn order to evaluate the detection part, we define an encryp_tion instance as a contiguous block of message bytes encrypted_\nwith the same key. We ran the malware binaries, collected\ninstruction traces and fed them to our analysis infrastructure\n(Steps B.1-B.3). We then compared the number of detected\ninstances to the true number determined via manual analysis.\nTable IV, col. 2 shows that our approach detects all encryption\ninstances for all malware families. As repeated experiments led\nto the same outcome, we present the result of a sample run.\nWe then fed the detected encrypted instances and the\nsandbox-generated network traces to our encryption inference\nalgorithm (Step B.4). In all cases, the tool mapped instances\nto C&C messages, and correctly inferred encryption details\nof interest (see Table IV col. 3-5). Overall, results in this\nsection suggest that our approach is effective in detecting and\nassessing uses of encryption in C&C protocol messages.\n\n_E. Message Clustering/Inference_\n\nThis part of our evaluation investigates the effectiveness of\nour approach in: (i) clustering C&C messages by type, and\n(ii) detecting various field types within messages. In this step,\nwe integrated the set of malware messages obtained from\nthe sandbox with samples from the traces in Table III. The\naggregated dataset consists of 20615 Sality messages, 1237\nRamnit messages and 49378 ZeroAccess messages.\n**Clustering: This step detects message-type fields and parti-**\ntions the message set based on these fields. For Sality, our\n\n\ntrace only includes client-to-server messages, which prevents\nthe message-type heuristic (§ III-C1) from being applied. All\nmessages are therefore mapped to a single type, which is\ncorrect, as all messages are of the pack exchange variety (used\nby peers to spread IPs of other bots). In the case of Ramnit and\nZeroAccess full conversations are available. In both cases the\nheuristics isolates the relevant message-type bytes, identifying\n_23 of 29 true message types for Ramnit, and 4 out of 4 true_\n_message types for ZeroAccess. The discrepancy in Ramnit_\nmessage types is due to messages with the same declared type\nbut different structure, perhaps reflecting protocol evolution.\n**Field inference: This step analyzes messages in each type**\ncluster. Rule-based detectors are used to identify various types\nof field (ref. Tables I and II). We define two metrics to assess\nthe effectiveness of field inference: for a set of samples of a\ngiven type, field coverage is the fraction of correctly-inferred\nfields, while byte coverage is the fraction of bytes within\ncorrectly inferred fields. We consider a field to be correctly\ninferred if its type/position align with that of a true field.\nWe note that the C&C protocols evaluated include several\nfield types not supported by our approach. This is because\nwe only support fields that map to generic data types (e.g.\nstring, IPv4, CRC) and ignore malware-specific data types\n(e.g. ZeroAccess messages carry binary values expressing the\nage in seconds of peer IP addresses).\nFig. 3(a) presents field and byte coverage of the set of\nsupported fields for each message type (i.e. the baseline\nonly includes fields whose type is supported by our detectors). For Ramnit we only present aggregate results—\naverage/min/max—as this malware defines 29 distinct types.\nType names are taken from protocol specifications.\nIn general, our approach detects the majority of supported\nfields/bytes. The limited coverage of certain ZeroAccess message types is due to timestamps which predate their respective\nmessages by more than one week, causing the timestamp\ndetector to ignore them. Sality’s undetected content consists\nof message-type fields, that cannot be identified since only\nclient-side messages are available. Note that that most message\ntypes contain < 10 fields, therefore even a limited number\nof undetected fields can greatly affect the result. Overall we\nachieve 97% supported-field coverage (amounting to 97% of\n\n\n-----\n\n```\n1.0\n0.8\n\n```\n```\n1.0\n0.8\n\n```\n```\n0.6\n0.4\n\n```\n```\n0.6\n0.4\n\n```\n```\n0.2\n0.0\n\n```\n|Col1|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Field Byte|Col15|Col16|Covera coverag|Col18|Col19|ge e|Col21|Col22|Col23|Col24|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n\n|Col1|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Field Byte|Col15|Col16|Covera coverag|Col18|Col19|ge e|Col21|Col22|Col23|Col24|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n|||||||||||||||||||||||||\n\n```\nSality\n URLs\n\n```\n```\nSality\n URLs\n\n```\n```\n ZA\ngetF\n\n```\n```\n ZA\nsetF\n\n```\n```\n ZA\nretL\n\n```\n```\n ZA\ngetF\n\n```\n```\n ZA\nsetF\n\n```\n```\n ZA\nretL\n\n```\n```\n ZA\ngetL\n\n```\n```\n ZA\ngetL\n\n```\n```\n ZA\nsrv?\n\n```\n```\n ZA\nyes!\n\n```\n```\n0.2\n0.0\n\n```\n```\n ZA\nsrv?\n\n```\n```\n ZA\nyes!\n\n```\n```\nRamnit\n(all)\n\n```\n```\nRamnit\n(all)\n\n```\n\n(a) Coverage of supported field types (b) Overall coverage\n\nFig. 3: Coverage of supported field types and of full message content for each message type\n\n|Malware|Instances found/present|Key material|Cipher|Encryption type|\n|---|---|---|---|---|\n|Sality|64/64|Carried in message|RC4|full message|\n|Ramnit|32/32|Constant|RC4|partial(some fields only)|\n|ZeroAccess|120/120|Constant|RC4|full message|\n\n\nTABLE IV: Details of the encryption used by each malware\n\nbytes in those fields), with null or negligible false positive rate.\nFig. 3(b) presents overall coverage of all message content,\nincluding fields for which no detector is available. The large\nmajority of undetected fields/bytes is taken up by ZeroAccess’\npeer-age fields described above. Such semantics are malwarespecific and cannot be captured by generic rules.\nIn summary, results show that our approach can identify a\nsignificant fraction of the structures carried by C&C messages.\n\n_F. Specification Abstraction_\n\n\n2.50 GHz processors and 64 GB of RAM. We do not present\nsandbox execution times as they depend on the malware\nunder analysis (e.g. our Sality binary waits 10 minutes before\ngenerating traffic). We emphasize that although our current\nimplementation is single-threaded, each step presents abundant\nopportunities for parallelism. For example, analysis of distinct\nmessages could be largely performed in parallel.\n\n_H. Signature Generation and Matching_\n\n\nIn order to evaluate the correctness of auto-generated specifications we compare them to manually-generated specifications based on domain knowledge and analyses of the C&C\nprotocols ( [17], [28], [29]). Results are presented in Table V.\nColumn #3 in the table shows the number of inferred types\nin each case. In most cases, there is a 1:1 mapping between\ninferred and actual types; the exception is the ZeroAccess retL\nmessage type, for which our algorithm abstracts 2 different\nmessage sub-types. Messages of this type carry sequences\nof (Peer IP address, Peer age) pairs. The composite-field\nheuristics detect a sequence of fields only if it includes three\nor more elements; hence, sequences of length 2 are mapped\nto a dedicated field type.\nColumn #4 lists the number of supported field types in\nthe specification of each message type. Columns #5 describes\nhow many supported fields were correctly recognized for each\nmessage type. Column #6 details false positives: fields that\nwere inferred but are not present in the protocol specification.\nOverall, our approach produces informative specifications,\nconsistent with the structure of the protocol under analysis.\n\n_G. Performance_\n\n\nFor each of the C&C message sets, we generated (using\nthe methodology described in § III-D) and tested signatures\nusing 5-fold cross-validation (4 partitions for training and 1\nfor testing in every iteration). The signature generation and\nmatching logic is implemented as a set of PERL scripts,\ntotaling 700 lines of code. This code receives as input (i)\nprotocols specifications generated by our toolchain, and (ii) a\nset of messages extracted from network traffic. Each message\nis then either matched to a malware protocol specification, or\ndiscarded as benign if no match is found.\nTable VII shows, for the three malware families, the average\npercentage of messages of a given family that matches the\nsignatures. We also show a column for Others, which include\nall the traffic from the malware-free traces DARPA and M57.\nThese traces consist of a mix of popular protocols (DNS,\nHTTP) and unknown UDP and TCP traffic. Overall, our results\nshow no false positives and very low false negatives.\n\nV. DISCUSSION\n\n\nTable VI details the performance of all steps of our algorithm when running on a Linux Server with Intel Xeon\n\n\n**Per-session encryption and TLS: In order to decrypt mes-**\nsage samples from external sources, our approach requires that\nencryption key and/or the decryption approach inferred from\nsandbox-originated traces, are valid for any protocol message.\nIt is in principle possible to design protocols that generate permessage keys which are non-trivial to infer, or use asymmetric\nencryption. One case of particular interest within this category\nis that of protocols using TLS. First, we note that as long as the\ncipher can be detected, our approach can be extended to extract\nthe plaintext for messages generated/received by the sandbox.\nHowever, since each connection dynamically negotiates unique\nkeys, it is no longer possible to infer a botnet-wide encryption\nkey. Decryption may still be achieved via protocol-specific\napproaches; e.g. decrypt TLS connections via TLS proxying.\n\n\n-----\n\n|Malware|Msg types (ground truth)|#Msg types (inferred)|#Supported fields (ground truth)|#Supported fields (correctly inferred)|#Supported fields (false positives)|\n|---|---|---|---|---|---|\n|Sality|URLs|1|4|3|0|\n|Ramnit|29 types|28|168|124|6|\n|ZeroAccess|getF|1|5|4|0|\n||setF|1|5|4|0|\n||srv?|1|10|5|0|\n||yes!|1|10|4|0|\n||getL|1|5|4|0|\n||retL|2|266|262|2|\n\n\nTABLE V: Breakdown of inferred specifications\n\n\nIn our work, we observed that malware commonly tends\nto use simple forms of symmetric encryption, and to reuse\nkeys. For example, our C&C dataset for the popular Ramnit\nmalware shows that the same key was used in 2012 and 2014.\n**Text-based protocols: Our approach focuses on binary-**\nonly protocols due to their popularity, however it is possible\nfor malware to use text-based protocols. Although supporting\nthem is outside the scope of this work, we note that the\nencryption analysis component can still be applied.\n**Session semantics: Our current analysis does not inves-**\ntigate how multiple messages are organized into sessions.\nAlthough inferring the protocol state machine (such as in [30])\nis outside the scope of our work, our approach could be easily\nextended to infer various types of session-related information.\nIn particular, our approach partitions each malware connection\ninto an ordered sequence of client and server messages,\nenabling inference of the conversation structure (e.g. Client\n_messages of type A are always followed by server messages of_\n_type B). It would be similarly possible to detect session keys—_\nfields that are common across requests and responses—e.g.\nusing the heuristics from [13]. We leave this as future work.\n\nVI. RELATED WORK\n\n**Protocol reverse engineering: Techniques proposed for pro-**\ntocol reverse-engineering can be divided into three groups,\ndepending on their input data. The first one generates protocol specifications from network traces. For instance, ScriptGen [31] generates a state machine from the network traffic\nobserved, in order to produce scripts that approximate responses to different protocol requests, while [15] automatically\ninfers message formats using a few very generic pre-defined\nfield semantics. None of these approaches targets binary\nprotocols; furthermore, we infer detailed specifications which\ninclude rich field types, and we deal with encryption while\nprevious works do not.\nThe second group of works in this space includes techniques that analyze execution traces captured as a program is\ncommunicating over the network. [32] presents a technique\nto generate specifications by instrumenting a program during\nmessage processing. The approach focuses on server-side\ncode, which in the malware world is notoriously difficult to\naccess. Dispatcher [33] does automatic reverse-engineering\nof C&C protocols by performing dynamic analysis on the\nmalware binary. By tainting the incoming data from the\nnetwork, the authors can derive detailed semantics of fields\n\n\nafter identifying the prototype of the function in which the\ndata will be used. For outgoing data, the authors employ\na series of heuristics to determine the position, size and\nsemantics of fields. The authors also consider protocols that\nuse encryption, by leveraging existing techniques [34], where\nplain-text data is extracted from the input (output) buffers to\nencryption (decryption) functions. We differ from Dispatcher\nin two important ways: (i) we can learn and generalize\nencryption details, enabling analysis of samples not generated\nin the sandbox, and signature generation and online traffic\ndecryption; (ii) we only require lightweight, passive binary\nanalysis which can be avoided if a malware from the same\nfamily has been analyzed in the past.\nThe third group of works follows a hybrid approach.\nProspex [35] analyzes both network traffic and execution traces\nto infer the malware’s protocol state machine. However, [35]\ndoes not handle encrypted traffic.\n**Botnet C&C traffic detection: Several approaches in litera-**\nture focus on generating unique patterns or signatures to identify C&C protocol communications. ProVex [3] is probably\nclosest to our work. It heuristically attempts to decrypt packets\nusing known encryption algorithms and extracts a statistical\nprofile of the byte distribution in the payload. Differently from\nour approach, it requires previous knowledge of encryption\nkeys. In addition, its signatures are probabilistic and thus\npotentially prone to higher false positives, while we can build\nvery detailed signatures based on field semantics. Botzilla [36]\nworks similarly but does not perform decryption, assuming\ninstead that recurring textual features can be found even within\nencrypted messages. CoCoSpot [37] also targets C&C protocols and deals with encryption traffic by using features that are\northogonal to payload obfuscation, such as message lengths.\nFIRMA [38] generates malware signatures that primarily target HTTP-based C&C communication. Similarly, Perdisci et\nal. [39] uses URL-based features to cluster malware-derived\nHTTP samples and generate effective signatures (as opposed\nto our approach, which focuses on binary messages). Both\n\n[38], [39] rely on deriving sets of constant tokens via string\nanalysis, which is not possible in the presence of encryption.\n**C&C Server Fingerprinting: These kinds of works try to**\nidentify C&C servers by analyzing their response to carefully\nconstructed probes. Two recent works in this area are [40],\n\n[41]. These works aim at generating probes that elicit a\nmeaningful answer from the server, while we aim at inferring\nfull specifications for message formats to enable detection.\n\n\n-----\n\n|Malware|#Instructions in program trace|Trace analysis|#Msg samples in dataset|Avg. #fields per message|Enc. inference/ Msg decryption|Clustering|Field inference|Specification abstraction|\n|---|---|---|---|---|---|---|---|---|\n|Sality|67M|103min|20615|6|2s|2s|8s|8s|\n|Ramnit|13M|16min|1237|7|<1s|<1s|5min|<1s|\n|ZeroAccess|19M|20min|49378|131|3s|44s|73min|36s|\n\n\nTABLE VI: Dataset sizes and execution times of algorithmic steps\n\n|Malware|Average % of Messages Detected per Signature Sality Ramnit ZeroAccess Others|Col3|Col4|Col5|\n|---|---|---|---|---|\n|Sality|100|0|0|0|\n|Ramnit|0|96.4|0|0|\n|ZeroAccess|0|0|99.9|0|\n\n\nTABLE VII: Traffic classification results\n\nVII. CONCLUSION\n\nIn this paper we present a solution to infer the format of\nmalware binary C&C protocols. Understanding such protocols\nis crucial to gain insight into how malware works, and to build\neffective network-based malware detectors. Our inference algorithm produces detailed protocol specifications, including\nrich content types—significantly alleviating the cumbersome\nand error-prone task of understanding malware communications manually. Our approach works in the presence of\nencryption, using program analysis to recover encryption keys.\nEvaluation results show that our approach is effective in decrypting malware samples and infers rich specifications, which\ngenerate effective network signatures for C&C protocols.\n\nREFERENCES\n\n[1] “Internet Security Threat Report, Volume 20,” Symantec, Tech. Rep.,\nApr. 2015.\n\n[2] “Safeguarding The Internet: Level 3 Botnet Research Report,” Level 3\nCommunications, Tech. Rep., Jun. 2015.\n\n[3] C. Rossow and C. J. Dietrich, “Provex: Detecting botnets with\nencrypted command and control channels,” in DIMVA, 2013.\n\n[4] J. C. Mitchell, Foundations of Programming Languages. Cambridge,\nMA, USA: MIT Press, 1996.\n\n[5] J. Calvet, J. M. Fernandez, and J.-Y. Marion, “Aligot: Cryptographic\nFunction Identification in Obfuscated Binary Programs,” in CCS, 2012.\n\n[6] J. Wyke, “The ZeroAccess Botnet - Mining and Fraud for Massive\nFinancial Gain,” Sophos, Tech. Rep., Sep. 2012.\n\n[7] S. B. Needleman and C. D. Wunsch, “A general method applicable to\nthe search for similarities in the amino acid sequence of two proteins,”\n_Journal of Molecular Biology, vol. 48, no. 3, pp. 443–453, Mar. 1970._\n\n[8] R. Zhao, D. Gu, J. Li, and R. Yu, “Detection and analysis of cryptographic data inside software,” in ISC, 2011.\n\n[9] F. Gr¨obert, C. Willems, and T. Holz, “Automated Identification of\nCryptographic Primitives in Binary Programs.” in RAID, 2011.\n\n[10] M. Lothaire, Applied combinatorics on words. Cambridge University\nPress, 2005.\n\n[11] R. Kolpakov and G. Kucherov, “Finding maximal repetitions in a word\nin linear time,” in FOCS, 1999.\n\n[12] P. Lestringant, F. Guih´ery, and P.-A. Fouque, “Automated identification\nof cryptographic primitives in binary code with data flow graph isomorphism,” in ASIA CCS, 2015.\n\n[13] I. Bermudez, A. Tongaonkar, M. Iliofotou, M. Mellia, and M. M.\nMunafo, “Automatic Protocol Field Inference for Deeper Protocol\nUnderstanding,” in IFIP, 2015.\n\n[14] J. Goubault-Larrecq and J. Olivain, “Detecting Subverted Cryptographic\nProtocols by Entropy Checking,” ENS-Cachan, Tech. Rep. LSV-06-13,\n2006.\n\n[15] W. Cui, J. Kannan, and H. J. Wang, “Discoverer: Automatic protocol\nreverse engineering from network traces,” in USENIX, 2007.\n\n[16] M. A. Beddoe, “Network protocol analysis using bioinformatics\nalgorithms,” Tech. Rep., 2004.\n\n\n\n[17] N. Falliere, “Sality: Story of a peer-to-peer viral network,” Symantec,\nTech. Rep., Jul. 2011.\n\n[18] Symantec Security Response, “W.32 Ramnit Analysis,” Symantec,\nTech. Rep., Feb. 2015.\n\n[19] “Europol cracks down on botnet _|_ Ars Technica.” [Online].\nAvailable: http://arstechnica.com/tech-policy/2015/02/europol-cracksdown-on-botnet-infecting-3-2-million-computers/\n\n[20] “ZeroAccess botnet resumes click-fraud activity after sixmonth break _|_ Dell SecureWorks Blog.” [Online]. Available: http://www.secureworks.com/resources/blog/zeroaccess-botnetresumes-click-fraud-activity-after-six-month-break/\n\n[21] “Cuckoo Sandbox.” [Online]. Available: http://cuckoosandbox.org/\n\n[22] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,\nS. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building Customized\nProgram Analysis Tools with Dynamic Instrumentation,” in PLDI,\n2005.\n\n[23] “Aligot source code,” May 2016. [Online]. Available: https://code.\ngoogle.com/archive/p/aligot/\n\n[24] “Snort IDS,” May 2016. [Online]. Available: http://www.snort.org/\n\n[25] “Malware-Traffic-Analysis.net.” [Online]. Available: http://malwaretraffic-analysis.net/about.html\n\n[26] R. Lippmann, J. W. Haines, D. J. Fried, J. Korba, and K. Das,\n“Analysis and results of the 1999 DARPA off-line intrusion detection\nevaluation,” in RAID, 2000.\n\n[27] “M57-Patents Scenario,” May 2016. [Online]. Available: http://\ndigitalcorpora.org/corpora/scenarios/m57-patents-scenario\n\n[28] C. Chen, “Virus Bulletin: Ramnit bot,” Nov. 2012. [Online]. Available: https://www.virusbtn.com/virusbulletin/archive/2012/\n11/vb201211-Ramnit.dkb\n\n[29] K. McNamee, “Malware analysis report - botnet: ZeroAccess/Sirefef,”\nKindsight, Tech. Rep., Jul. 2014.\n\n[30] C. Y. Cho, E. C. R. Shin, D. Song, and others, “Inference and analysis\nof formal models of botnet command and control protocols,” in CCS,\n2010.\n\n[31] C. Leita, K. Mermoud, and M. Dacier, “ScriptGen: an automated script\ngeneration tool for Honeyd,” in ACSAC, 2005.\n\n[32] G. Wondracek, P. M. Comparetti, C. Kruegel, and E. Kirda, “Automatic\nNetwork Protocol Analysis,” in NDSS, 2008.\n\n[33] J. Caballero, P. Poosankam, C. Kreibich, and D. Song, “Dispatcher:\nEnabling active botnet infiltration using automatic protocol reverseengineering,” in CCS, 2009.\n\n[34] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace, “ReFormat:\nAutomatic reverse engineering of encrypted messages,” in ESORICS,\n2009.\n\n[35] P. M. Comparetti, G. Wondracek, C. Kruegel, and E. Kirda, “Prospex:\nProtocol Specification Extraction,” in IEEE S&P, 2009.\n\n[36] K. Rieck, G. Schwenk, T. Limmer, T. Holz, and P. Laskov, “Botzilla:\ndetecting the phoning home of malicious software,” in SAC, 2010.\n\n[37] C. J. Dietrich, C. Rossow, and N. Pohlmann, “CoCoSpot: Clustering\nand recognizing botnet command and control channels using traffic\nanalysis,” Computer Networks, vol. 57, no. 2, pp. 475–486, Feb. 2013.\n\n[38] M. Z. Rafique and J. Caballero, “Firma: Malware clustering and\nnetwork signature generation with mixed network behaviors,” in RAID,\n2013.\n\n[39] R. Perdisci, W. Lee, and N. Feamster, “Behavioral Clustering of\nHTTP-Based Malware and Signature Generation Using Malicious\nNetwork Traces.” in NSDI, 2010.\n\n[40] A. Nappa, Z. Xu, J. Caballero, and G. Gu, “CyberProbe: Towards\nInternet-Scale Active Detection of Malicious Servers,” in NDSS, 2014.\n\n[41] Z. Xu, A. Nappa, R. Baykov, G. Yang, J. Caballero, and G. Gu,\n“Autoprobe: Towards automatic active malicious server probing using\ndynamic binary analysis,” in CCS, 2014.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.researchgate.net/profile/Lorenzo-De-Carli/publication/320250366_Botnet_protocol_inference_in_the_presence_of_encrypted_traffic/links/5fa9608792851cc286a08592/Botnet-protocol-inference-in-the-presence-of-encrypted-traffic.pdf?origin=publication_detail"
    ],
    "report_names": [
        "Botnet-protocol-inference-in-the-presence-of-encrypted-traffic.pdf?origin=publication_detail"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1704334035,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1484946222,
    "ts_modification_date": 1484942836,
    "files": {
        "pdf": "https://archive.orkl.eu/592fcf14459be0097fb64c1b854a2af05b632ced.pdf",
        "text": "https://archive.orkl.eu/592fcf14459be0097fb64c1b854a2af05b632ced.txt",
        "img": "https://archive.orkl.eu/592fcf14459be0097fb64c1b854a2af05b632ced.jpg"
    }
}